{"sha": "d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDlhNmJkMzJhZGM0MGE3ZTFlNWM3MjY5MmEzMzBmMTQ0NTNhZDdmMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-10-13T19:06:23Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-10-13T19:06:23Z"}, "message": "builtin-types.def (BT_FN_BOOL_UINT_LONGPTR_LONGPTR_LONGPTR, [...]): New.\n\ngcc/\n2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n\t    Aldy Hernandez  <aldyh@redhat.com>\n\t    Ilya Verbin  <ilya.verbin@intel.com>\n\n\t* builtin-types.def (BT_FN_BOOL_UINT_LONGPTR_LONGPTR_LONGPTR,\n\tBT_FN_BOOL_UINT_ULLPTR_ULLPTR_ULLPTR,\n\tBT_FN_BOOL_UINT_LONGPTR_LONG_LONGPTR_LONGPTR,\n\tBT_FN_BOOL_UINT_ULLPTR_ULL_ULLPTR_ULLPTR,\n\tBT_FN_VOID_INT_SIZE_PTR_PTR_PTR_UINT_PTR,\n\tBT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR,\n\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,\n\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_LONG_LONG_LONG,\n\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_ULL_ULL_ULL,\n\tBT_FN_VOID_LONG_VAR, BT_FN_VOID_ULL_VAR): New.\n\t(BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR,\n\tBT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR,\n\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR): Remove.\n\t* cgraph.h (enum cgraph_simd_clone_arg_type): Add\n\tSIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP,\n\tSIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP and\n\tSIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP.\n\t(struct cgraph_simd_clone_arg): Adjust comment.\n\t* coretypes.h (struct gomp_ordered): New forward decl.\n\t* gimple.c (gimple_build_omp_critical): Add CLAUSES argument,\n\tset critical clauses to it.\n\t(gimple_build_omp_ordered): Return gomp_ordered * instead of\n\tgimple *.  Add CLAUSES argument, set ordered clauses to it.\n\t(gimple_copy): Unshare clauses on GIMPLE_OMP_CRITICAL and\n\tGIMPLE_OMP_ORDERED.\n\t* gimple.def (GIMPLE_OMP_ORDERED): Change from GSS_OMP to\n\tGSS_OMP_SINGLE_LAYOUT, move it after GIMPLE_OMP_TEAMS.\n\t* gimple.h (enum gf_mask): Add GF_OMP_TASK_TASKLOOP.  Add another bit\n\tto GF_OMP_FOR_KIND_MASK mask. Add GF_OMP_FOR_KIND_TASKLOOP, renumber\n\tGF_OMP_FOR_KIND_CILKFOR and GF_OMP_FOR_KIND_OACC_LOOP.  Adjust\n\tGF_OMP_FOR_SIMD, GF_OMP_FOR_COMBINED and GF_OMP_FOR_COMBINED_INTO.\n\tAdd another bit to GF_OMP_TARGET_KIND_MASK mask.  Add\n\tGF_OMP_TARGET_KIND_ENTER_DATA and GF_OMP_TARGET_KIND_EXIT_DATA,\n\trenumber\n\tGF_OMP_TARGET_KIND_OACC_{PARALLEL,KERNELS,DATA,UPDATE,ENTER_EXIT_DATA}.\n\t(gomp_critical): Add clauses field.\n\t(gomp_ordered): New struct.\n\t(is_a_helper <gomp_ordered *>::test): New inline.\n\t(gimple_build_omp_critical): Add CLAUSES argument.\n\t(gimple_build_omp_ordered): Likewise.  Return gomp_ordered *\n\tinstead of gimple *.\n\t(gimple_omp_critical_clauses, gimple_omp_critical_clauses_ptr,\n\tgimple_omp_critical_set_clauses, gimple_omp_ordered_clauses,\n\tgimple_omp_ordered_clauses_ptr, gimple_omp_ordered_set_clauses,\n\tgimple_omp_task_taskloop_p, gimple_omp_task_set_taskloop_p): New\n\tinline functions.\n\t* gimple-pretty-print.c (dump_gimple_omp_for): Handle taskloop.\n\t(dump_gimple_omp_target): Handle enter data and exit data.\n\t(dump_gimple_omp_block): Don't handle GIMPLE_OMP_ORDERED here.\n\t(dump_gimple_omp_critical): Print clauses.\n\t(dump_gimple_omp_ordered): New function.\n\t(dump_gimple_omp_task): Handle taskloop.\n\t(pp_gimple_stmt_1): Use dump_gimple_omp_ordered for\n\tGIMPLE_OMP_ORDERED.\n\t* gimple-walk.c (walk_gimple_op): Walk clauses on\n\tGIMPLE_OMP_CRITICAL and GIMPLE_OMP_ORDERED.\n\t* gimplify.c (enum gimplify_omp_var_data): Add GOVD_MAP_0LEN_ARRAY.\n\t(enum omp_region_type): Add ORT_COMBINED_TARGET and ORT_NONE.\n\t(struct gimplify_omp_ctx): Add loop_iter_var,\n\ttarget_map_scalars_firstprivate, target_map_pointers_as_0len_arrays\n\tand target_firstprivatize_array_bases fields.\n\t(delete_omp_context): Release loop_iter_var.\n\t(gimplify_bind_expr): Handle ORT_NONE.\n\t(maybe_fold_stmt): Adjust check for ORT_TARGET for the addition of\n\tORT_COMBINED_TARGET.\n\t(is_gimple_stmt): Return true for OMP_TASKLOOP, OMP_TEAMS and\n\tOMP_TARGET{,_DATA,_UPDATE,_ENTER_DATA,_EXIT_DATA}.\n\t(omp_firstprivatize_variable): Handle ORT_NONE.  Adjust check for\n\tORT_TARGET for the addition of ORT_COMBINED_TARGET.  Handle\n\tctx->target_map_scalars_firstprivate.\n\t(omp_add_variable): Handle ORT_NONE.  Allow map clause together with\n\tdata sharing clauses.  For data sharing clause with VLA decl\n\ton omp target/target data don't add firstprivate for the pointer.\n\tCall omp_notice_variable on TYPE_SIZE_UNIT only if it is a DECL_P.\n\t(omp_notice_threadprivate_variable): Adjust check for ORT_TARGET for\n\tthe addition of ORT_COMBINED_TARGET.\n\t(omp_notice_variable): Handle ORT_NONE.  Adjust check for ORT_TARGET\n\tfor the addition of ORT_COMBINED_TARGET.  Handle implicit mapping of\n\tpointers as zero length array sections and\n\tctx->target_map_scalars_firstprivate mapping of scalars as firstprivate\n\tdata sharing.\n\t(omp_check_private): Handle omp_member_access_dummy_var vars.\n\t(find_decl_expr): New function.\n\t(gimplify_scan_omp_clauses): Add CODE argument.  For OMP_CLAUSE_IF\n\tcomplain if OMP_CLAUSE_IF_MODIFIER is present and does not match code.\n\tHandle OMP_CLAUSE_GANG separately.  Handle\n\tOMP_CLAUSE_{PRIORITY,GRAINSIZE,NUM_TASKS,NOGROUP,THREADS,SIMD,SIMDLEN}\n\tclauses.  Diagnose linear clause on combined\n\tdistribute {, parallel for} simd construct, unless it is the loop\n\titerator.  Handle struct element GOMP_MAP_FIRSTPRIVATE_POINTER.\n\tHandle map clauses with COMPONENT_REF.  Initialize\n\tctx->target_map_scalars_firstprivate,\n\tctx->target_firstprivatize_array_bases and\n\tctx->target_map_pointers_as_0len_arrays.  Add firstprivate for\n\tlinear clause even to target region if combined.  Remove\n\tmap clauses with GOMP_MAP_FIRSTPRIVATE_POINTER kind from\n\tOMP_TARGET_{,ENTER_,EXIT_}DATA.  For GOMP_MAP_FIRSTPRIVATE_POINTER\n\tmap kind with non-INTEGER_CST OMP_CLAUSE_SIZE firstprivatize the bias.\n\tHandle OMP_CLAUSE_DEPEND_{SINK,SOURCE}.  Handle\n\tOMP_CLAUSE_{{USE,IS}_DEVICE_PTR,DEFAULTMAP,HINT}.\n\tFor linear clause on worksharing loop combined with parallel add\n\tshared clause on the parallel.  Handle OMP_CLAUSE_REDUCTION\n\twith MEM_REF OMP_CLAUSE_DECL.  Set DECL_NAME on\n\tomp_member_access_dummy_var vars.  Add lastprivate clause to outer\n\ttaskloop if needed.\n\t(gimplify_adjust_omp_clauses_1): Handle GOVD_MAP_0LEN_ARRAY.\n\tIf gimplify_omp_ctxp->target_firstprivatize_array_bases, use\n\tGOMP_MAP_FIRSTPRIVATE_POINTER map kind instead of\n\tGOMP_MAP_POINTER.\n\t(gimplify_adjust_omp_clauses): Add CODE argument.  Handle removal\n\tof GOMP_MAP_FIRSTPRIVATE_POINTER struct elements for struct not seen\n\tin target body.  Handle removal of struct mapping if struct is not\n\tseen in target body.  Remove GOMP_MAP_STRUCT map clause on\n\tOMP_TARGET_EXIT_DATA.  Adjust check for ORT_TARGET for the\n\taddition of ORT_COMBINED_TARGET.  Use GOMP_MAP_FIRSTPRIVATE_POINTER\n\tinstead of GOMP_MAP_POINTER if ctx->target_firstprivatize_array_bases\n\tfor VLAs.  Set OMP_CLAUSE_MAP_PRIVATE if both data sharing and map\n\tclause appear together.  Handle\n\tOMP_CLAUSE_{{USE,IS}_DEVICE_PTR,DEFAULTMAP,HINT}.  Don't remove map\n\tclause if it has map-type-modifier always.  Handle\n\tOMP_CLAUSE_{PRIORITY,GRAINSIZE,NUM_TASKS,NOGROUP,THREADS,SIMD,SIMDLEN}\n\tclauses.\n\t(gimplify_oacc_cache, gimplify_omp_parallel, gimplify_omp_task):\n\tAdjust gimplify_scan_omp_clauses and gimplify_adjust_omp_clauses\n\tcallers.\n\t(gimplify_omp_for): Likewise.  Handle OMP_TASKLOOP.  Initialize\n\tloop_iter_var.  Use OMP_FOR_ORIG_DECLS.  Fix handling of lastprivate\n\titerators in doacross loops.\n\t(gimplify_omp_workshare): Adjust gimplify_scan_omp_clauses and\n\tgimplify_adjust_omp_clauses callers.  Use ORT_COMBINED_TARGET\n\tfor OMP_TARGET_COMBINED.  Adjust check for ORT_TARGET\n\tfor the addition of ORT_COMBINED_TARGET.\n\t(gimplify_omp_target_update): Adjust gimplify_scan_omp_clauses and\n\tgimplify_adjust_omp_clauses callers.  Handle OMP_TARGET_ENTER_DATA\n\tand OMP_TARGET_EXIT_DATA.\n\t(gimplify_omp_ordered): New function.\n\t(gimplify_expr): Handle OMP_TASKLOOP, OMP_TARGET_ENTER_DATA and\n\tOMP_TARGET_EXIT_DATA.  Use gimplify_omp_ordered for OMP_ORDERED.\n\tGimplify clauses on OMP_CRITICAL.\n\t* internal-fn.c (expand_GOMP_SIMD_ORDERED_START,\n\texpand_GOMP_SIMD_ORDERED_END): New functions.\n\t* internal-fn.def (GOMP_SIMD_ORDERED_START,\n\tGOMP_SIMD_ORDERED_END): New internal functions.\n\t* omp-builtins.def (BUILT_IN_GOMP_LOOP_DOACROSS_STATIC_START,\n\tBUILT_IN_GOMP_LOOP_DOACROSS_DYNAMIC_START,\n\tBUILT_IN_GOMP_LOOP_DOACROSS_GUIDED_START,\n\tBUILT_IN_GOMP_LOOP_DOACROSS_RUNTIME_START,\n\tBUILT_IN_GOMP_LOOP_ULL_DOACROSS_STATIC_START,\n\tBUILT_IN_GOMP_LOOP_ULL_DOACROSS_DYNAMIC_START,\n\tBUILT_IN_GOMP_LOOP_ULL_DOACROSS_GUIDED_START,\n\tBUILT_IN_GOMP_LOOP_ULL_DOACROSS_RUNTIME_START,\n\tBUILT_IN_GOMP_DOACROSS_POST, BUILT_IN_GOMP_DOACROSS_WAIT,\n\tBUILT_IN_GOMP_DOACROSS_ULL_POST, BUILT_IN_GOMP_DOACROSS_ULL_WAIT,\n\tBUILT_IN_GOMP_TARGET_ENTER_EXIT_DATA, BUILT_IN_GOMP_TASKLOOP,\n\tBUILT_IN_GOMP_TASKLOOP_ULL): New built-ins.\n\t(BUILT_IN_GOMP_TASK): Add INT argument to the end.\n\t(BUILT_IN_GOMP_TARGET): Rename from GOMP_target to GOMP_target_41,\n\tadjust type.\n\t(BUILT_IN_GOMP_TARGET_DATA): Rename from GOMP_target_data to\n\tGOMP_target_data_41, adjust type.\n\t(BUILT_IN_GOMP_TARGET_UPDATE): Rename from GOMP_target_update to\n\tGOMP_target_update_41, adjust type.\n\t* omp-low.c (struct omp_region): Adjust comments, add ord_stmt\n\tfield.\n\t(struct omp_for_data): Add ordered and simd_schedule fields.\n\t(omp_member_access_dummy_var, unshare_and_remap_1,\n\tunshare_and_remap, is_taskloop_ctx): New functions.\n\t(is_taskreg_ctx): Use is_parallel_ctx and is_task_ctx.\n\t(extract_omp_for_data): Handle taskloops and doacross loops\n\tand simd schedule modifier.\n\t(omp_adjust_chunk_size): New function.\n\t(get_ws_args_for): Use it.\n\t(lookup_sfield): Change first argument to splay_tree_key,\n\tadd overload with first argument tree.\n\t(maybe_lookup_field): Likewise.\n\t(use_pointer_for_field): Handle omp_member_access_dummy_var.\n\t(omp_copy_decl_2): If var is TREE_ADDRESSABLE listed in\n\ttask_shared_vars, clear TREE_ADDRESSABLE on the copy.\n\t(build_outer_var_ref): Add LASTPRIVATE argument, handle\n\ttaskloops and omp_member_access_dummy_var vars.\n\t(build_sender_ref): Change first argument to splay_tree_key,\n\tadd overload with first argument tree.\n\t(install_var_field): For mask & 8 use &DECL_UID as key instead\n\tof the tree itself.\n\t(fixup_child_record_type): Const qualify *.omp_data_i.\n\t(scan_sharing_clauses): Handle OMP_CLAUSE_SHARED_FIRSTPRIVATE,\n\tC/C++ array reductions, OMP_CLAUSE_{IS,USE}_DEVICE_PTR clauses,\n\tOMP_CLAUSE_{PRIORITY,GRAINSIZE,NUM_TASKS,SIMDLEN,THREADS,SIMD} and\n\tOMP_CLAUSE_{NOGROUP,DEFAULTMAP} clauses, OMP_CLAUSE__LOOPTEMP_ clause\n\ton taskloop, GOMP_MAP_FIRSTPRIVATE_POINTER, OMP_CLAUSE_MAP_PRIVATE.\n\t(create_omp_child_function): Set TREE_READONLY on .omp_data_i.\n\t(find_combined_for): Allow searching for different GIMPLE_OMP_FOR\n\tkinds.\n\t(add_taskreg_looptemp_clauses): New function.\n\t(scan_omp_parallel): Use it.\n\t(scan_omp_task): Likewise.\n\t(finish_taskreg_scan): Handle OMP_CLAUSE_SHARED_FIRSTPRIVATE.\n\tFor taskloop, move fields for the first two _LOOPTEMP_ clauses first.\n\t(check_omp_nesting_restrictions): Handle GF_OMP_TARGET_KIND_ENTER_DATA\n\tand GF_OMP_TARGET_KIND_EXIT_DATA.  Formatting fixes.  Allow the\n\tsandwiched taskloop constructs.  Type check\n\tOMP_CLAUSE_DEPEND_{KIND,SOURCE}.  Allow ordered simd inside of simd\n\tregion.  Diagnose depend(source) or depend(sink:...) on\n\ttarget constructs or task/taskloop.\n\t(handle_simd_reference): Use get_name.\n\t(lower_rec_input_clauses): Likewise.  Ignore all\n\tOMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE clauses on taskloop construct.\n\tAllow _LOOPTEMP_ clause on GOMP_TASK.  Unshare new_var\n\tbefore passing it to omp_clause_{default,copy}_ctor.  Handle\n\tOMP_CLAUSE_REDUCTION with MEM_REF OMP_CLAUSE_DECL.  Set\n\tlastprivate_firstprivate flag for linear that needs copyin and\n\tcopyout.  Use BUILT_IN_ALLOCA_WITH_ALIGN instead of BUILT_IN_ALLOCA.\n\t(lower_lastprivate_clauses): For OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE\n\ton taskloop lookup decl in outer context.  Pass true to\n\tbuild_outer_var_ref lastprivate argument.  Handle\n\tOMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV lastprivate if the decl is global\n\toutside of outer taskloop for.\n\t(lower_reduction_clauses): Handle OMP_CLAUSE_REDUCTION with MEM_REF\n\tOMP_CLAUSE_DECL.\n\t(lower_send_clauses): Ignore first two _LOOPTEMP_ clauses in taskloop\n\tGOMP_TASK.  Handle OMP_CLAUSE_SHARED_FIRSTPRIVATE.  Handle\n\tomp_member_access_dummy_var vars.  Handle OMP_CLAUSE_REDUCTION\n\twith MEM_REF OMP_CLAUSE_DECL.  Use new lookup_sfield overload.\n\t(lower_send_shared_vars): Ignore fields with NULL or FIELD_DECL\n\tabstract origin.  Handle omp_member_access_dummy_var vars.\n\t(expand_parallel_call): Use expand_omp_build_assign.\n\t(expand_task_call): Handle taskloop construct expansion.  Add\n\tREGION argument.  Use GOMP_TASK_* defines instead of hardcoded\n\tintegers.  Add priority argument to GOMP_task* calls.  Or in\n\tGOMP_TASK_FLAG_PRIORITY into flags if priority is present for\n\tGOMP_task call.\n\t(expand_omp_build_assign): Add prototype.  Add AFTER\n\targument, if true emit statements after *GSI_P and continue linking.\n\t(expand_omp_taskreg): Adjust expand_task_call caller.\n\t(expand_omp_for_init_counts): Rename zero_iter_bb argument to\n\tzero_iter1_bb and first_zero_iter to first_zero_iter1, add\n\tzero_iter2_bb and first_zero_iter2 arguments, handle computation\n\tof counts even for ordered loops.\n\t(expand_omp_for_init_vars): Handle GOMP_TASK inner_stmt.\n\t(expand_omp_ordered_source, expand_omp_ordered_sink,\n\texpand_omp_ordered_source_sink, expand_omp_for_ordered_loops): New\n\tfunctions.\n\t(expand_omp_for_generic): Use omp_adjust_chunk_size.  Handle linear\n\tclauses on worksharing loop.  Handle DOACROSS loop expansion.\n\t(expand_omp_for_static_nochunk): Handle linear clauses on\n\tworksharing loop.  Adjust expand_omp_for_init_counts\n\tcallers.\n\t(expand_omp_for_static_chunk): Likewise.  Use omp_adjust_chunk_size.\n\t(expand_omp_simd): Handle addressable fd->loop.v.  Adjust\n\texpand_omp_for_init_counts callers.\n\t(expand_omp_taskloop_for_outer, expand_omp_taskloop_for_inner): New\n\tfunctions.\n\t(expand_omp_for): Call expand_omp_taskloop_for_* for taskloop.\n\tHandle doacross loops.\n\t(expand_omp_target): Handle GF_OMP_TARGET_KIND_ENTER_DATA and\n\tGF_OMP_TARGET_KIND_EXIT_DATA.  Pass flags and depend arguments to\n\tGOMP_target_{41,update_41,enter_exit_data} libcalls.\n\t(expand_omp): Don't expand ordered depend constructs here, record\n\tord_stmt instead for later expand_omp_for_generic.\n\t(build_omp_regions_1): Handle GF_OMP_TARGET_KIND_ENTER_DATA and\n\tGF_OMP_TARGET_KIND_EXIT_DATA.  Treat GIMPLE_OMP_ORDERED with depend\n\tclause as stand-alone directive.\n\t(lower_omp_ordered_clauses): New function.\n\t(lower_omp_ordered): Handle OMP_CLAUSE_SIMD, for OMP_CLAUSE_DEPEND\n\tdon't lower anything.\n\t(lower_omp_for_lastprivate): Use last _looptemp_ clause\n\ton taskloop for comparison.\n\t(lower_omp_for): Handle taskloop constructs.  Adjust OMP_CLAUSE_DECL\n\tand OMP_CLAUSE_LINEAR_STEP so that expand_omp_for_* can use it during\n\texpansion for linear adjustments.\n\t(create_task_copyfn): Handle OMP_CLAUSE_SHARED_FIRSTPRIVATE.\n\t(lower_depend_clauses): Assert not seeing sink/source depend kinds.\n\tSet TREE_ADDRESSABLE on array.  Change first argument from gimple *\n\tto tree * pointing to the stmt's clauses.\n\t(lower_omp_taskreg): Adjust lower_depend_clauses caller.\n\t(lower_omp_target): Handle GF_OMP_TARGET_KIND_ENTER_DATA\n\tand GF_OMP_TARGET_KIND_EXIT_DATA, depend clauses,\n\tGOMP_MAP_{RELEASE,ALWAYS_{TO,FROM,TOFROM},FIRSTPRIVATE_POINTER,STRUCT}\n\tmap kinds, OMP_CLAUSE_{FIRSTPRIVATE,PRIVATE,{IS,USE}_DEVICE_PTR\n\tclauses.  Always use short kind and 8-bit align shift.\n\t(lower_omp_regimplify_p): Use IS_TYPE_OR_DECL_P macro.\n\t(struct lower_omp_regimplify_operands_data): New type.\n\t(lower_omp_regimplify_operands_p, lower_omp_regimplify_operands):\n\tNew functions.\n\t(lower_omp_1): Use lower_omp_regimplify_operands instead of\n\tgimple_regimplify_operands.\n\t(make_gimple_omp_edges): Handle GF_OMP_TARGET_KIND_ENTER_DATA and\n\tGF_OMP_TARGET_KIND_EXIT_DATA.  Treat GIMPLE_OMP_ORDERED with depend\n\tclause as stand-alone directive.\n\t(simd_clone_clauses_extract): Honor OMP_CLAUSE_LINEAR_KIND.\n\t(simd_clone_mangle): Mangle the various linear kinds\n\tper the new ABI.\n\t(simd_clone_adjust_argument_types): Handle\n\tSIMD_CLONE_ARG_TYPE_LINEAR_*_CONSTANT_STEP.\n\t(simd_clone_init_simd_arrays): Don't do anything for uval.\n\t(simd_clone_adjust): Handle\n\tSIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP like\n\tSIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP.\n\tHandle SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP.\n\t* omp-low.h (omp_member_access_dummy_var): New prototype.\n\t* passes.def (pass_simduid_cleanup): Schedule another copy of the\n\tpass after all optimizations.\n\t* tree.c (omp_clause_code_name): Add entries for\n\tOMP_CLAUSE_{TO_DECLARE,LINK,{USE,IS}_DEVICE_PTR,DEFAULTMAP,HINT}\n\tand OMP_CLAUSE_{PRIORITY,GRAINSIZE,NUM_TASKS,NOGROUP,THREADS,SIMD}.\n\t(omp_clause_num_ops): Likewise.  Bump number of OMP_CLAUSE_REDUCTION\n\targuments to 5 and for OMP_CLAUSE_ORDERED to 1.\n\t(walk_tree_1): Adjust for OMP_CLAUSE_ORDERED having 1 argument and\n\tOMP_CLAUSE_REDUCTION 5 arguments.  Handle\n\tOMP_CLAUSE_{TO_DECLARE,LINK,{USE,IS}_DEVICE_PTR,DEFAULTMAP,HINT}\n\tand OMP_CLAUSE_{PRIORITY,GRAINSIZE,NUM_TASKS,NOGROUP,THREADS,SIMD}\n\tclauses.\n\t* tree-core.h (enum omp_clause_linear_kind): New.\n\t(struct tree_omp_clause): Change type of map_kind\n\tfrom unsigned char to unsigned int.  Add subcode.if_modifier\n\tand subcode.linear_kind fields.\n\t(enum omp_clause_code): Add\n\tOMP_CLAUSE_{TO_DECLARE,LINK,{USE,IS}_DEVICE_PTR,DEFAULTMAP,HINT}\n\tand OMP_CLAUSE_{PRIORITY,GRAINSIZE,NUM_TASKS,NOGROUP,THREADS,SIMD}.\n\t(OMP_CLAUSE_REDUCTION): Document\n\tOMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER.\n\t(enum omp_clause_depend_kind): Add OMP_CLAUSE_DEPEND_{SOURCE,SINK}.\n\t* tree.def (OMP_FOR): Add OMP_FOR_ORIG_DECLS operand.\n\t(OMP_CRITICAL): Move before OMP_SINGLE.  Add OMP_CRITICAL_CLAUSES\n\toperand.\n\t(OMP_ORDERED): Move before OMP_SINGLE.  Add OMP_ORDERED_CLAUSES\n\toperand.\n\t(OMP_TASKLOOP, OMP_TARGET_ENTER_DATA, OMP_TARGET_EXIT_DATA): New tree\n\tcodes.\n\t* tree.h (OMP_BODY): Replace OMP_CRITICAL with OMP_TASKGROUP.\n\t(OMP_CLAUSE_SET_MAP_KIND): Cast to unsigned int rather than unsigned\n\tchar.\n\t(OMP_CRITICAL_NAME): Adjust to be 3rd operand instead of 2nd.\n\t(OMP_CLAUSE_NUM_TASKS_EXPR): Formatting fix.\n\t(OMP_STANDALONE_CLAUSES): Adjust to cover OMP_TARGET_{ENTER,EXIT}_DATA.\n\t(OMP_CLAUSE_DEPEND_SINK_NEGATIVE, OMP_TARGET_COMBINED,\n\tOMP_CLAUSE_MAP_PRIVATE, OMP_FOR_ORIG_DECLS, OMP_CLAUSE_IF_MODIFIER,\n\tOMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION, OMP_CRITICAL_CLAUSES,\n\tOMP_CLAUSE_PRIVATE_TASKLOOP_IV, OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV,\n\tOMP_CLAUSE_HINT_EXPR, OMP_CLAUSE_SCHEDULE_SIMD,\n\tOMP_CLAUSE_LINEAR_KIND, OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER,\n\tOMP_CLAUSE_SHARED_FIRSTPRIVATE, OMP_ORDERED_CLAUSES,\n\tOMP_TARGET_ENTER_DATA_CLAUSES, OMP_TARGET_EXIT_DATA_CLAUSES,\n\tOMP_CLAUSE_NUM_TASKS_EXPR, OMP_CLAUSE_GRAINSIZE_EXPR,\n\tOMP_CLAUSE_PRIORITY_EXPR, OMP_CLAUSE_ORDERED_EXPR): Define.\n\t* tree-inline.c (remap_gimple_stmt): Handle clauses on\n\tGIMPLE_OMP_ORDERED and GIMPLE_OMP_CRITICAL.  For\n\tIFN_GOMP_SIMD_ORDERED_{START,END} set has_simduid_loops.\n\t* tree-nested.c (convert_nonlocal_omp_clauses): Handle\n\tOMP_CLAUSE_{TO_DECLARE,LINK,{USE,IS}_DEVICE_PTR,SIMDLEN,PRIORITY,SIMD}\n\tand OMP_CLAUSE_{GRAINSIZE,NUM_TASKS,HINT,NOGROUP,THREADS,DEFAULTMAP}\n\tclauses.  Handle OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER.\n\t(convert_local_omp_clauses): Likewise.\n\t* tree-pretty-print.c (dump_omp_clause): Handle\n\tOMP_CLAUSE_{TO_DECLARE,LINK,{USE,IS}_DEVICE_PTR,SIMDLEN,PRIORITY,SIMD}\n\tand OMP_CLAUSE_{GRAINSIZE,NUM_TASKS,HINT,NOGROUP,THREADS,DEFAULTMAP}\n\tclauses.  Handle OMP_CLAUSE_IF_MODIFIER, OMP_CLAUSE_ORDERED_EXPR,\n\tOMP_CLAUSE_SCHEDULE_SIMD, OMP_CLAUSE_LINEAR_KIND,\n\tOMP_CLAUSE_DEPEND_{SOURCE,SINK}.  Use \"delete\" for\n\tGOMP_MAP_FORCE_DEALLOC.  Handle\n\tGOMP_MAP_{ALWAYS_{TO,FROM,TOFROM},RELEASE,FIRSTPRIVATE_POINTER,STRUCT}.\n\t(dump_generic_node): Handle OMP_TASKLOOP, OMP_TARGET_{ENTER,EXIT}_DATA\n\tand clauses on OMP_ORDERED and OMP_CRITICAL.\n\t* tree-vectorizer.c (adjust_simduid_builtins): Adjust comment.\n\tRemove IFN_GOMP_SIMD_ORDERED_{START,END}.\n\t(vectorize_loops): Adjust comments.\n\t(pass_simduid_cleanup::execute): Likewise.\n\t* tree-vect-stmts.c (vectorizable_simd_clone_call): Handle\n\tSIMD_CLONE_ARG_TYPE_LINEAR_{REF,VAL,UVAL}_CONSTANT_STEP.\n\t* wide-int.h (wi::gcd): New.\ngcc/c-family/\n2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n\t    Aldy Hernandez  <aldyh@redhat.com>\n\n\t* c-common.c (enum c_builtin_type): Define DEF_FUNCTION_TYPE_9,\n\tDEF_FUNCTION_TYPE_10 and DEF_FUNCTION_TYPE_11.\n\t(c_define_builtins): Likewise.\n\t* c-common.h (enum c_omp_clause_split): Add\n\tC_OMP_CLAUSE_SPLIT_TASKLOOP.\n\t(c_finish_omp_critical, c_finish_omp_ordered): Add CLAUSES argument.\n\t(c_finish_omp_for): Add ORIG_DECLV argument.\n\t* c-cppbuiltin.c (c_cpp_builtins): Predefine _OPENMP as\n\t201511 instead of 201307.\n\t* c-omp.c (c_finish_omp_critical): Add CLAUSES argument, set\n\tOMP_CRITICAL_CLAUSES to it.\n\t(c_finish_omp_ordered): Add CLAUSES argument, set\n\tOMP_ORDERED_CLAUSES to it.\n\t(c_finish_omp_for): Add ORIG_DECLV argument, set OMP_FOR_ORIG_DECLS\n\tto it if OMP_FOR.  Clear DECL_INITIAL on the IVs.\n\t(c_omp_split_clauses): Handle OpenMP 4.5 combined/composite\n\tconstructs and new OpenMP 4.5 clauses.  Clear\n\tOMP_CLAUSE_SCHEDULE_SIMD if not combined with OMP_SIMD.  Add\n\tverification code.\n\t* c-pragma.c (omp_pragmas_simd): Add taskloop.\n\t* c-pragma.h (enum pragma_kind): Add PRAGMA_OMP_TASKLOOP.\n\t(enum pragma_omp_clause): Add\n\tPRAGMA_OMP_CLAUSE_{DEFAULTMAP,GRAINSIZE,HINT,{IS,USE}_DEVICE_PTR}\n\tand PRAGMA_OMP_CLAUSE_{LINK,NOGROUP,NUM_TASKS,PRIORITY,SIMD,THREADS}.\ngcc/c/\n2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n\t    Aldy Hernandez  <aldyh@redhat.com>\n\n\t* c-parser.c (c_parser_pragma): Handle PRAGMA_OMP_ORDERED here.\n\t(c_parser_omp_clause_name): Handle OpenMP 4.5 clauses.\n\t(c_parser_omp_variable_list): Handle structure elements for\n\tmap, to and from clauses.  Handle array sections in reduction\n\tclause.  Formatting fixes.\n\t(c_parser_omp_clause_if): Add IS_OMP argument, handle parsing of\n\tif clause modifiers.\n\t(c_parser_omp_clause_num_tasks, c_parser_omp_clause_grainsize,\n\tc_parser_omp_clause_priority, c_parser_omp_clause_hint,\n\tc_parser_omp_clause_defaultmap, c_parser_omp_clause_use_device_ptr,\n\tc_parser_omp_clause_is_device_ptr): New functions.\n\t(c_parser_omp_clause_ordered): Parse optional parameter.\n\t(c_parser_omp_clause_reduction): Handle array reductions.\n\t(c_parser_omp_clause_schedule): Parse optional simd modifier.\n\t(c_parser_omp_clause_nogroup, c_parser_omp_clause_orderedkind): New\n\tfunctions.\n\t(c_parser_omp_clause_linear): Parse linear clause modifiers.\n\t(c_parser_omp_clause_depend_sink): New function.\n\t(c_parser_omp_clause_depend): Parse source/sink depend kinds.\n\t(c_parser_omp_clause_map): Parse release/delete map kinds and\n\toptional always modifier.\n\t(c_parser_oacc_all_clauses): Adjust c_parser_omp_clause_if\n\tand c_finish_omp_clauses callers.\n\t(c_parser_omp_all_clauses): Likewise.  Parse OpenMP 4.5 clauses.\n\tParse \"to\" as OMP_CLAUSE_TO_DECLARE if on declare target directive.\n\t(c_parser_oacc_cache): Adjust c_finish_omp_clauses caller.\n\t(OMP_CRITICAL_CLAUSE_MASK): Define.\n\t(c_parser_omp_critical): Parse critical clauses.\n\t(c_parser_omp_for_loop): Handle doacross loops, adjust\n\tc_finish_omp_for and c_finish_omp_clauses callers.\n\t(OMP_SIMD_CLAUSE_MASK): Add simdlen clause.\n\t(c_parser_omp_simd): Allow ordered clause if it has no parameter.\n\t(OMP_FOR_CLAUSE_MASK): Add linear clause.\n\t(c_parser_omp_for): Disallow ordered clause when combined with\n\tdistribute.  Disallow linear clause when combined with distribute\n\tand not combined with simd.\n\t(OMP_ORDERED_CLAUSE_MASK, OMP_ORDERED_DEPEND_CLAUSE_MASK): Define.\n\t(c_parser_omp_ordered): Add CONTEXT argument, remove LOC argument,\n\tparse clauses and if depend clause is found, don't parse a body.\n\t(c_parser_omp_parallel): Disallow copyin clause on target parallel.\n\tAllow target parallel without for after it.\n\t(OMP_TASK_CLAUSE_MASK): Add priority clause.\n\t(OMP_TARGET_DATA_CLAUSE_MASK): Add use_device_ptr clause.\n\t(c_parser_omp_target_data): Diagnose no map clauses or clauses with\n\tinvalid kinds.\n\t(OMP_TARGET_UPDATE_CLAUSE_MASK): Add depend and nowait clauses.\n\t(OMP_TARGET_ENTER_DATA_CLAUSE_MASK,\n\tOMP_TARGET_EXIT_DATA_CLAUSE_MASK): Define.\n\t(c_parser_omp_target_enter_data, c_parser_omp_target_exit_data): New\n\tfunctions.\n\t(OMP_TARGET_CLAUSE_MASK): Add depend, nowait, private, firstprivate,\n\tdefaultmap and is_device_ptr clauses.\n\t(c_parser_omp_target): Parse target parallel and target simd.  Set\n\tOMP_TARGET_COMBINED on combined constructs.  Parse target enter data\n\tand target exit data.  Diagnose invalid map kinds.\n\t(OMP_DECLARE_TARGET_CLAUSE_MASK): Define.\n\t(c_parser_omp_declare_target): Parse OpenMP 4.5 forms of this\n\tconstruct.\n\t(c_parser_omp_declare_reduction): Use STRIP_NOPS when checking for\n\t&omp_priv.\n\t(OMP_TASKLOOP_CLAUSE_MASK): Define.\n\t(c_parser_omp_taskloop): New function.\n\t(c_parser_omp_construct): Don't handle PRAGMA_OMP_ORDERED here,\n\thandle PRAGMA_OMP_TASKLOOP.\n\t(c_parser_cilk_for): Adjust c_finish_omp_clauses callers.\n\t* c-tree.h (c_finish_omp_clauses): Add two new arguments.\n\t* c-typeck.c (handle_omp_array_sections_1): Fix comment typo.\n\tAdd IS_OMP argument, handle structure element bases, diagnose\n\tbitfields, pass IS_OMP recursively, diagnose known zero length\n\tarray sections in depend clauses, handle array sections in reduction\n\tclause, diagnose negative length even for pointers.\n\t(handle_omp_array_sections): Add IS_OMP argument, use auto_vec for\n\ttypes, pass IS_OMP down to handle_omp_array_sections_1, handle\n\tarray sections in reduction clause, set\n\tOMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION if map could be zero\n\tlength array section, use GOMP_MAP_FIRSTPRIVATE_POINTER for IS_OMP.\n\t(c_finish_omp_clauses): Add IS_OMP and DECLARE_SIMD arguments.\n\tHandle new OpenMP 4.5 clauses and new restrictions for the old ones.\ngcc/cp/\n2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n\t    Aldy Hernandez  <aldyh@redhat.com>\n\n\t* class.c (finish_struct_1): Call finish_omp_declare_simd_methods.\n\t* cp-gimplify.c (cp_gimplify_expr): Handle OMP_TASKLOOP.\n\t(cp_genericize_r): Likewise.\n\t(cxx_omp_finish_clause): Don't diagnose references.\n\t(cxx_omp_disregard_value_expr): New function.\n\t* cp-objcp-common.h (LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR): Redefine.\n\t* cp-tree.h (OMP_FOR_GIMPLIFYING_P): Document for OMP_TASKLOOP.\n\t(DECL_OMP_PRIVATIZED_MEMBER): Define.\n\t(finish_omp_declare_simd_methods, push_omp_privatization_clauses,\n\tpop_omp_privatization_clauses, save_omp_privatization_clauses,\n\trestore_omp_privatization_clauses, omp_privatize_field,\n\tcxx_omp_disregard_value_expr): New prototypes.\n\t(finish_omp_clauses): Add two new arguments.\n\t(finish_omp_for): Add ORIG_DECLV argument.\n\t* parser.c (cp_parser_lambda_body): Call\n\tsave_omp_privatization_clauses and restore_omp_privatization_clauses.\n\t(cp_parser_omp_clause_name): Handle OpenMP 4.5 clauses.\n\t(cp_parser_omp_var_list_no_open): Handle structure elements for\n\tmap, to and from clauses.  Handle array sections in reduction\n\tclause.  Parse this keyword.  Formatting fixes.\n\t(cp_parser_omp_clause_if): Add IS_OMP argument, handle parsing of\n\tif clause modifiers.\n\t(cp_parser_omp_clause_num_tasks, cp_parser_omp_clause_grainsize,\n\tcp_parser_omp_clause_priority, cp_parser_omp_clause_hint,\n\tcp_parser_omp_clause_defaultmap): New functions.\n\t(cp_parser_omp_clause_ordered): Parse optional parameter.\n\t(cp_parser_omp_clause_reduction): Handle array reductions.\n\t(cp_parser_omp_clause_schedule): Parse optional simd modifier.\n\t(cp_parser_omp_clause_nogroup, cp_parser_omp_clause_orderedkind):\n\tNew functions.\n\t(cp_parser_omp_clause_linear): Parse linear clause modifiers.\n\t(cp_parser_omp_clause_depend_sink): New function.\n\t(cp_parser_omp_clause_depend): Parse source/sink depend kinds.\n\t(cp_parser_omp_clause_map): Parse release/delete map kinds and\n\toptional always modifier.\n\t(cp_parser_oacc_all_clauses): Adjust cp_parser_omp_clause_if\n\tand finish_omp_clauses callers.\n\t(cp_parser_omp_all_clauses): Likewise.  Parse OpenMP 4.5 clauses.\n\tParse \"to\" as OMP_CLAUSE_TO_DECLARE if on declare target directive.\n\t(OMP_CRITICAL_CLAUSE_MASK): Define.\n\t(cp_parser_omp_critical): Parse critical clauses.\n\t(cp_parser_omp_for_incr): Use cp_tree_equal if\n\tprocessing_template_decl.\n\t(cp_parser_omp_for_loop_init): Return tree instead of bool.  Handle\n\tnon-static data member iterators.\n\t(cp_parser_omp_for_loop): Handle doacross loops, adjust\n\tfinish_omp_for and finish_omp_clauses callers.\n\t(cp_omp_split_clauses): Adjust finish_omp_clauses caller.\n\t(OMP_SIMD_CLAUSE_MASK): Add simdlen clause.\n\t(cp_parser_omp_simd): Allow ordered clause if it has no parameter.\n\t(OMP_FOR_CLAUSE_MASK): Add linear clause.\n\t(cp_parser_omp_for): Disallow ordered clause when combined with\n\tdistribute.  Disallow linear clause when combined with distribute\n\tand not combined with simd.\n\t(OMP_ORDERED_CLAUSE_MASK, OMP_ORDERED_DEPEND_CLAUSE_MASK): Define.\n\t(cp_parser_omp_ordered): Add CONTEXT argument, return bool instead\n\tof tree, parse clauses and if depend clause is found, don't parse\n\ta body.\n\t(cp_parser_omp_parallel): Disallow copyin clause on target parallel.\n\tAllow target parallel without for after it.\n\t(OMP_TASK_CLAUSE_MASK): Add priority clause.\n\t(OMP_TARGET_DATA_CLAUSE_MASK): Add use_device_ptr clause.\n\t(cp_parser_omp_target_data): Diagnose no map clauses or clauses with\n\tinvalid kinds.\n\t(OMP_TARGET_UPDATE_CLAUSE_MASK): Add depend and nowait clauses.\n\t(OMP_TARGET_ENTER_DATA_CLAUSE_MASK,\n\tOMP_TARGET_EXIT_DATA_CLAUSE_MASK): Define.\n\t(cp_parser_omp_target_enter_data, cp_parser_omp_target_exit_data): New\n\tfunctions.\n\t(OMP_TARGET_CLAUSE_MASK): Add depend, nowait, private, firstprivate,\n\tdefaultmap and is_device_ptr clauses.\n\t(cp_parser_omp_target): Parse target parallel and target simd.  Set\n\tOMP_TARGET_COMBINED on combined constructs.  Parse target enter data\n\tand target exit data.  Diagnose invalid map kinds.\n\t(cp_parser_oacc_cache): Adjust finish_omp_clauses caller.\n\t(OMP_DECLARE_TARGET_CLAUSE_MASK): Define.\n\t(cp_parser_omp_declare_target): Parse OpenMP 4.5 forms of this\n\tconstruct.\n\t(OMP_TASKLOOP_CLAUSE_MASK): Define.\n\t(cp_parser_omp_taskloop): New function.\n\t(cp_parser_omp_construct): Don't handle PRAGMA_OMP_ORDERED here,\n\thandle PRAGMA_OMP_TASKLOOP.\n\t(cp_parser_pragma): Handle PRAGMA_OMP_ORDERED here directly,\n\thandle PRAGMA_OMP_TASKLOOP, call push_omp_privatization_clauses\n\tand pop_omp_privatization_clauses around parsing calls.\n\t(cp_parser_cilk_for): Adjust finish_omp_clauses caller.\n\t* pt.c (apply_late_template_attributes): Adjust tsubst_omp_clauses\n\tand finish_omp_clauses callers.\n\t(tsubst_omp_clause_decl): Return NULL if decl is NULL.\n\tFor TREE_LIST, copy over OMP_CLAUSE_DEPEND_SINK_NEGATIVE bit.\n\tUse tsubst_expr instead of tsubst_copy, undo convert_from_reference\n\teffects.\n\t(tsubst_omp_clauses): Add ALLOW_FIELDS argument.  Handle new\n\tOpenMP 4.5 clauses.  Use tsubst_omp_clause_decl for more clauses.\n\tIf ALLOW_FIELDS, handle non-static data members in the clauses.\n\tClear OMP_CLAUSE_LINEAR_STEP if it has been cleared before.\n\t(omp_parallel_combined_clauses): New variable.\n\t(tsubst_omp_for_iterator): Add ORIG_DECLV argument, recur on\n\tOMP_FOR_ORIG_DECLS, handle non-static data member iterators.\n\tImprove handling of clauses on combined constructs.\n\t(tsubst_expr): Call push_omp_privatization_clauses and\n\tpop_omp_privatization_clauses around instantiation of certain\n\tOpenMP constructs, improve handling of clauses on combined\n\tconstructs, handle OMP_TASKLOOP, adjust tsubst_omp_for_iterator,\n\ttsubst_omp_clauses and finish_omp_for callers, handle clauses on\n\tcritical and ordered, handle OMP_TARGET_{ENTER,EXIT}_DATA.\n\t(instantiate_decl): Call save_omp_privatization_clauses and\n\trestore_omp_privatization_clauses around instantiation.\n\t(dependent_omp_for_p): Fix up comment typo.  Handle SCOPE_REF.\n\t* semantics.c (omp_private_member_map, omp_private_member_vec,\n\tomp_private_member_ignore_next): New variables.\n\t(finish_non_static_data_member): Return dummy decl for privatized\n\tnon-static data members.\n\t(omp_clause_decl_field, omp_clause_printable_decl,\n\tomp_note_field_privatization, omp_privatize_field): New functions.\n\t(handle_omp_array_sections_1): Fix comment typo.\n\tAdd IS_OMP argument, handle structure element bases, diagnose\n\tbitfields, pass IS_OMP recursively, diagnose known zero length\n\tarray sections in depend clauses, handle array sections in reduction\n\tclause, diagnose negative length even for pointers.\n\t(handle_omp_array_sections): Add IS_OMP argument, use auto_vec for\n\ttypes, pass IS_OMP down to handle_omp_array_sections_1, handle\n\tarray sections in reduction clause, set\n\tOMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION if map could be zero\n\tlength array section, use GOMP_MAP_FIRSTPRIVATE_POINTER for IS_OMP.\n\t(finish_omp_reduction_clause): Handle array sections and arrays.\n\tUse omp_clause_printable_decl.\n\t(finish_omp_declare_simd_methods, cp_finish_omp_clause_depend_sink):\n\tNew functions.\n\t(finish_omp_clauses): Add ALLOW_FIELDS and DECLARE_SIMD arguments.\n\tHandle new OpenMP 4.5 clauses and new restrictions for the old\n\tones, handle non-static data members, reject this keyword when not\n\tallowed.\n\t(push_omp_privatization_clauses, pop_omp_privatization_clauses,\n\tsave_omp_privatization_clauses, restore_omp_privatization_clauses):\n\tNew functions.\n\t(handle_omp_for_class_iterator): Handle OMP_TASKLOOP class iterators.\n\tAdd collapse and ordered arguments.  Fix handling of lastprivate\n\titerators in doacross loops.\n\t(finish_omp_for): Add ORIG_DECLV argument, handle doacross loops,\n\tadjust c_finish_omp_for, handle_omp_for_class_iterator and\n\tfinish_omp_clauses callers.  Fill in OMP_CLAUSE_LINEAR_STEP on simd\n\tloops with non-static data member iterators.\ngcc/fortran/\n2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n\t    Ilya Verbin  <ilya.verbin@intel.com>\n\n\t* f95-lang.c (DEF_FUNCTION_TYPE_9, DEF_FUNCTION_TYPE_10,\n\tDEF_FUNCTION_TYPE_11, DEF_FUNCTION_TYPE_VAR_1): Define.\n\t* trans-openmp.c (gfc_trans_omp_clauses): Set\n\tOMP_CLAUSE_IF_MODIFIER to ERROR_MARK, OMP_CLAUSE_ORDERED_EXPR\n\tto NULL.\n\t(gfc_trans_omp_critical): Adjust for addition of clauses.\n\t(gfc_trans_omp_ordered): Likewise.\n\t* types.def (BT_FN_BOOL_UINT_LONGPTR_LONGPTR_LONGPTR,\n\tBT_FN_BOOL_UINT_ULLPTR_ULLPTR_ULLPTR,\n\tBT_FN_BOOL_UINT_LONGPTR_LONG_LONGPTR_LONGPTR,\n\tBT_FN_BOOL_UINT_ULLPTR_ULL_ULLPTR_ULLPTR,\n\tBT_FN_VOID_INT_SIZE_PTR_PTR_PTR_UINT_PTR,\n\tBT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR,\n\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,\n\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_LONG_LONG_LONG,\n\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_ULL_ULL_ULL,\n\tBT_FN_VOID_LONG_VAR, BT_FN_VOID_ULL_VAR): New.\n\t(BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR,\n\tBT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR,\n\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR): Remove.\ngcc/lto/\n2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n\n\t* lto-lang.c (DEF_FUNCTION_TYPE_9, DEF_FUNCTION_TYPE_10,\n\tDEF_FUNCTION_TYPE_11): Define.\ngcc/jit/\n2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n\n\t* jit-builtins.c (DEF_FUNCTION_TYPE_9, DEF_FUNCTION_TYPE_10,\n\tDEF_FUNCTION_TYPE_11): Define.\n\t* jit-builtins.h (DEF_FUNCTION_TYPE_9, DEF_FUNCTION_TYPE_10,\n\tDEF_FUNCTION_TYPE_11): Define.\ngcc/ada/\n2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n\n\t* gcc-interface/utils.c (DEF_FUNCTION_TYPE_9, DEF_FUNCTION_TYPE_10,\n\tDEF_FUNCTION_TYPE_11): Define.\ngcc/testsuite/\n2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n\t    Aldy Hernandez  <aldyh@redhat.com>\n\n\t* c-c++-common/gomp/cancel-1.c (f2): Add map clause to target data.\n\t* c-c++-common/gomp/clauses-1.c: New test.\n\t* c-c++-common/gomp/clauses-2.c: New test.\n\t* c-c++-common/gomp/clauses-3.c: New test.\n\t* c-c++-common/gomp/clauses-4.c: New test.\n\t* c-c++-common/gomp/declare-target-1.c: New test.\n\t* c-c++-common/gomp/declare-target-2.c: New test.\n\t* c-c++-common/gomp/depend-3.c: New test.\n\t* c-c++-common/gomp/depend-4.c: New test.\n\t* c-c++-common/gomp/doacross-1.c: New test.\n\t* c-c++-common/gomp/if-1.c: New test.\n\t* c-c++-common/gomp/if-2.c: New test.\n\t* c-c++-common/gomp/linear-1.c: New test.\n\t* c-c++-common/gomp/map-2.c: New test.\n\t* c-c++-common/gomp/map-3.c: New test.\n\t* c-c++-common/gomp/nesting-1.c (f_omp_parallel,\n\tf_omp_target_data): Add map clause to target data.\n\t* c-c++-common/gomp/nesting-warn-1.c (f_omp_target): Likewise.\n\t* c-c++-common/gomp/ordered-1.c: New test.\n\t* c-c++-common/gomp/ordered-2.c: New test.\n\t* c-c++-common/gomp/ordered-3.c: New test.\n\t* c-c++-common/gomp/pr61486-1.c (foo): Remove linear clause\n\ton non-iterator.\n\t* c-c++-common/gomp/pr61486-2.c (test, test2): Remove ordered\n\tclause and ordered construct where no longer allowed.\n\t* c-c++-common/gomp/priority-1.c: New test.\n\t* c-c++-common/gomp/reduction-1.c: New test.\n\t* c-c++-common/gomp/schedule-simd-1.c: New test.\n\t* c-c++-common/gomp/sink-1.c: New test.\n\t* c-c++-common/gomp/sink-2.c: New test.\n\t* c-c++-common/gomp/sink-3.c: New test.\n\t* c-c++-common/gomp/sink-4.c: New test.\n\t* c-c++-common/gomp/udr-1.c: New test.\n\t* c-c++-common/taskloop-1.c: New test.\n\t* c-c++-common/cpp/openmp-define-3.c: Adjust for the new\n\tvalue of _OPENMP macro.\n\t* c-c++-common/cilk-plus/PS/body.c (foo): Adjust expected diagnostics.\n\t* c-c++-common/goacc-gomp/nesting-fail-1.c (f_acc_parallel,\n\tf_acc_kernels, f_acc_data, f_acc_loop): Add map clause to target data.\n\t* gcc.dg/gomp/clause-1.c:\n\t* gcc.dg/gomp/reduction-1.c: New test.\n\t* gcc.dg/gomp/sink-fold-1.c: New test.\n\t* gcc.dg/gomp/sink-fold-2.c: New test.\n\t* gcc.dg/gomp/sink-fold-3.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-15.c: New test.\n\t* g++.dg/gomp/clause-1.C (T::test): Remove dg-error on privatization\n\tof non-static data members.\n\t* g++.dg/gomp/clause-3.C (foo): Remove one dg-error directive.\n\tAdd some linear clause tests.\n\t* g++.dg/gomp/declare-simd-3.C: New test.\n\t* g++.dg/gomp/linear-1.C: New test.\n\t* g++.dg/gomp/member-1.C: New test.\n\t* g++.dg/gomp/member-2.C: New test.\n\t* g++.dg/gomp/pr66571-2.C: New test.\n\t* g++.dg/gomp/pr67504.C (foo): Add test for ordered clause with\n\tdependent argument.\n\t* g++.dg/gomp/pr67522.C (foo): Add test for invalid array section\n\tin reduction clause.\n\t* g++.dg/gomp/reference-1.C: New test.\n\t* g++.dg/gomp/sink-1.C: New test.\n\t* g++.dg/gomp/sink-2.C: New test.\n\t* g++.dg/gomp/sink-3.C: New test.\n\t* g++.dg/gomp/task-1.C: Remove both dg-error directives.\n\t* g++.dg/gomp/this-1.C: New test.\n\t* g++.dg/gomp/this-2.C: New test.\n\t* g++.dg/vect/simd-clone-2.cc: New test.\n\t* g++.dg/vect/simd-clone-2.h: New test.\n\t* g++.dg/vect/simd-clone-3.cc: New test.\n\t* g++.dg/vect/simd-clone-4.cc: New test.\n\t* g++.dg/vect/simd-clone-4.h: New test.\n\t* g++.dg/vect/simd-clone-5.cc: New test.\ninclude/\n2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n\t    Ilya Verbin  <ilya.verbin@intel.com>\n\n\t* gomp-constants.h (GOMP_MAP_FLAG_ALWAYS): Define.\n\t(enum gomp_map_kind): Add GOMP_MAP_FIRSTPRIVATE,\n\tGOMP_MAP_FIRSTPRIVATE_INT, GOMP_MAP_USE_DEVICE_PTR,\n\tGOMP_MAP_ZERO_LEN_ARRAY_SECTION, GOMP_MAP_ALWAYS_TO,\n\tGOMP_MAP_ALWAYS_FROM, GOMP_MAP_ALWAYS_TOFROM, GOMP_MAP_STRUCT,\n\tGOMP_MAP_DELETE_ZERO_LEN_ARRAY_SECTION, GOMP_MAP_DELETE,\n\tGOMP_MAP_RELEASE, GOMP_MAP_FIRSTPRIVATE_POINTER.\n\t(GOMP_MAP_ALWAYS_TO_P, GOMP_MAP_ALWAYS_FROM_P): Define.\n\t(GOMP_TASK_FLAG_UNTIED, GOMP_TASK_FLAG_FINAL, GOMP_TASK_FLAG_MERGEABLE,\n\tGOMP_TASK_FLAG_DEPEND, GOMP_TASK_FLAG_PRIORITY, GOMP_TASK_FLAG_UP,\n\tGOMP_TASK_FLAG_GRAINSIZE, GOMP_TASK_FLAG_IF, GOMP_TASK_FLAG_NOGROUP,\n\tGOMP_TARGET_FLAG_NOWAIT, GOMP_TARGET_FLAG_EXIT_DATA,\n\tGOMP_TARGET_FLAG_UPDATE): Define.\nlibgomp/\n2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n\t    Aldy Hernandez  <aldyh@redhat.com>\n\t    Ilya Verbin  <ilya.verbin@intel.com>\n\n\t* config/linux/affinity.c (omp_get_place_num_procs,\n\tomp_get_place_proc_ids, gomp_get_place_proc_ids_8): New functions.\n\t* config/linux/doacross.h: New file.\n\t* config/posix/affinity.c (omp_get_place_num_procs,\n\tomp_get_place_proc_ids, gomp_get_place_proc_ids_8): New functions.\n\t* config/posix/doacross.h: New file.\n\t* env.c: Include gomp-constants.h.\n\t(struct gomp_task_icv): Rename run_sched_modifier to\n\trun_sched_chunk_size.\n\t(gomp_max_task_priority_var): New variable.\n\t(parse_schedule): Rename run_sched_modifier to run_sched_chunk_size.\n\t(handle_omp_display_env): Change _OPENMP value from 201307 to\n\t201511.  Print OMP_MAX_TASK_PRIORITY.\n\t(initialize_env): Parse OMP_MAX_TASK_PRIORITY.\n\t(omp_set_schedule, omp_get_schedule): Rename modifier argument to\n\tchunk_size and run_sched_modifier to run_sched_chunk_size.\n\t(omp_get_max_task_priority, omp_get_initial_device,\n\tomp_get_num_places, omp_get_place_num, omp_get_partition_num_places,\n\tomp_get_partition_place_nums): New functions.\n\t* fortran.c (omp_set_schedule_, omp_set_schedule_8_,\n\tomp_get_schedule_, omp_get_schedule_8_): Rename modifier argument\n\tto chunk_size.\n\t(omp_get_num_places_, omp_get_place_num_procs_,\n\tomp_get_place_num_procs_8_, omp_get_place_proc_ids_,\n\tomp_get_place_proc_ids_8_, omp_get_place_num_,\n\tomp_get_partition_num_places_, omp_get_partition_place_nums_,\n\tomp_get_partition_place_nums_8_, omp_get_initial_device_,\n\tomp_get_max_task_priority_): New functions.\n\t* libgomp_g.h (GOMP_loop_doacross_static_start,\n\tGOMP_loop_doacross_dynamic_start, GOMP_loop_doacross_guided_start,\n\tGOMP_loop_doacross_runtime_start, GOMP_loop_ull_doacross_static_start,\n\tGOMP_loop_ull_doacross_dynamic_start,\n\tGOMP_loop_ull_doacross_guided_start,\n\tGOMP_loop_ull_doacross_runtime_start, GOMP_doacross_post,\n\tGOMP_doacross_wait, GOMP_doacross_ull_post, GOMP_doacross_wait,\n\tGOMP_taskloop, GOMP_taskloop_ull, GOMP_target_41,\n\tGOMP_target_data_41, GOMP_target_update_41,\n\tGOMP_target_enter_exit_data): New prototypes.\n\t(GOMP_task): Add prototype argument.\n\t* libgomp.h (_LIBGOMP_CHECKING_): Define to 0 if not yet defined.\n\t(struct gomp_doacross_work_share): New type.\n\t(struct gomp_work_share): Add doacross field.\n\t(struct gomp_task_icv): Rename run_sched_modifier to\n\trun_sched_chunk_size.\n\t(enum gomp_task_kind): Rename GOMP_TASK_IFFALSE to\n\tGOMP_TASK_UNDEFERRED.  Add comments.\n\t(struct gomp_task_depend_entry): Add comments.\n\t(struct gomp_task): Likewise.\n\t(struct gomp_taskgroup): Likewise.\n\t(struct gomp_target_task): New type.\n\t(struct gomp_team): Add comment.\n\t(gomp_get_place_proc_ids_8, gomp_doacross_init,\n\tgomp_doacross_ull_init, gomp_task_maybe_wait_for_dependencies,\n\tgomp_create_target_task, gomp_target_task_fn): New prototypes.\n\t(struct target_var_desc): New type.\n\t(struct target_mem_desc): Adjust comment.  Use struct\n\ttarget_var_desc instead of splay_tree_key for list.\n\t(REFCOUNT_INFINITY): Define.\n\t(struct splay_tree_key_s): Remove copy_from field.\n\t(struct gomp_device_descr): Add dev2dev_func field.\n\t(enum gomp_map_vars_kind): New enum.\n\t(gomp_map_vars): Add one argument.\n\t* libgomp.map (OMP_4.5): Export omp_get_max_task_priority,\n\tomp_get_max_task_priority_, omp_get_num_places, omp_get_num_places_,\n\tomp_get_place_num_procs, omp_get_place_num_procs_,\n\tomp_get_place_num_procs_8_, omp_get_place_proc_ids,\n\tomp_get_place_proc_ids_, omp_get_place_proc_ids_8_, omp_get_place_num,\n\tomp_get_place_num_, omp_get_partition_num_places,\n\tomp_get_partition_num_places_, omp_get_partition_place_nums,\n\tomp_get_partition_place_nums_, omp_get_partition_place_nums_8_,\n\tomp_get_initial_device, omp_get_initial_device_, omp_target_alloc,\n\tomp_target_free, omp_target_is_present, omp_target_memcpy,\n\tomp_target_memcpy_rect, omp_target_associate_ptr and\n\tomp_target_disassociate_ptr.\n\t(GOMP_4.0.2): Renamed to ...\n\t(GOMP_4.5): ... this.  Export GOMP_target_41, GOMP_target_data_41,\n\tGOMP_target_update_41, GOMP_target_enter_exit_data, GOMP_taskloop,\n\tGOMP_taskloop_ull, GOMP_loop_doacross_dynamic_start,\n\tGOMP_loop_doacross_guided_start, GOMP_loop_doacross_runtime_start,\n\tGOMP_loop_doacross_static_start, GOMP_doacross_post,\n\tGOMP_doacross_wait, GOMP_loop_ull_doacross_dynamic_start,\n\tGOMP_loop_ull_doacross_guided_start,\n\tGOMP_loop_ull_doacross_runtime_start,\n\tGOMP_loop_ull_doacross_static_start, GOMP_doacross_ull_post and\n\tGOMP_doacross_ull_wait.\n\t* libgomp.texi: Document omp_get_max_task_priority.\n\tRename modifier argument to chunk_size for omp_set_schedule and\n\tomp_get_schedule.  Document OMP_MAX_TASK_PRIORITY env var.\n\t* loop.c (GOMP_loop_runtime_start): Adjust for run_sched_modifier\n\tto run_sched_chunk_size renaming.\n\t(GOMP_loop_ordered_runtime_start): Likewise.\n\t(gomp_loop_doacross_static_start, gomp_loop_doacross_dynamic_start,\n\tgomp_loop_doacross_guided_start, GOMP_loop_doacross_runtime_start,\n\tGOMP_parallel_loop_runtime_start): New functions.\n\t(GOMP_parallel_loop_runtime): Adjust for run_sched_modifier\n\tto run_sched_chunk_size renaming.\n\t(GOMP_loop_doacross_static_start, GOMP_loop_doacross_dynamic_start,\n\tGOMP_loop_doacross_guided_start): New functions or aliases.\n\t* loop_ull.c (GOMP_loop_ull_runtime_start): Adjust for\n\trun_sched_modifier to run_sched_chunk_size renaming.\n\t(GOMP_loop_ull_ordered_runtime_start): Likewise.\n\t(gomp_loop_ull_doacross_static_start,\n\tgomp_loop_ull_doacross_dynamic_start,\n\tgomp_loop_ull_doacross_guided_start,\n\tGOMP_loop_ull_doacross_runtime_start): New functions.\n\t(GOMP_loop_ull_doacross_static_start,\n\tGOMP_loop_ull_doacross_dynamic_start,\n\tGOMP_loop_ull_doacross_guided_start): New functions or aliases.\n\t* oacc-mem.c (acc_map_data, present_create_copy,\n\tgomp_acc_insert_pointer): Pass GOMP_MAP_VARS_OPENACC instead of false\n\tto gomp_map_vars.\n\t(gomp_acc_remove_pointer): Use copy_from from target_var_desc.\n\t* oacc-parallel.c (GOACC_data_start): Pass GOMP_MAP_VARS_OPENACC\n\tinstead of false to gomp_map_vars.\n\t(GOACC_parallel_keyed): Likewise.  Use copy_from from target_var_desc.\n\t* omp.h.in (omp_lock_hint_t): New type.\n\t(omp_init_lock_with_hint, omp_init_nest_lock_with_hint,\n\tomp_get_num_places, omp_get_place_num_procs, omp_get_place_proc_ids,\n\tomp_get_place_num, omp_get_partition_num_places,\n\tomp_get_partition_place_nums, omp_get_initial_device,\n\tomp_get_max_task_priority, omp_target_alloc, omp_target_free,\n\tomp_target_is_present, omp_target_memcpy, omp_target_memcpy_rect,\n\tomp_target_associate_ptr, omp_target_disassociate_ptr): New\n\tprototypes.\n\t* omp_lib.f90.in (omp_lock_hint_kind): New parameter.\n\t(omp_lock_hint_none, omp_lock_hint_uncontended,\n\tomp_lock_hint_contended, omp_lock_hint_nonspeculative,\n\tomp_lock_hint_speculative): New parameters.\n\t(omp_init_lock_with_hint, omp_init_nest_lock_with_hint,\n\tomp_get_num_places, omp_get_place_num_procs, omp_get_place_proc_ids,\n\tomp_get_place_num, omp_get_partition_num_places,\n\tomp_get_partition_place_nums, omp_get_initial_device,\n\tomp_get_max_task_priority): New interfaces.\n\t(omp_set_schedule, omp_get_schedule): Rename modifier argument\n\tto chunk_size.\n\t* omp_lib.h.in (omp_lock_hint_kind): New parameter.\n\t(omp_lock_hint_none, omp_lock_hint_uncontended,\n\tomp_lock_hint_contended, omp_lock_hint_nonspeculative,\n\tomp_lock_hint_speculative): New parameters.\n\t(omp_init_lock_with_hint, omp_init_nest_lock_with_hint,\n\tomp_get_num_places, omp_get_place_num_procs, omp_get_place_proc_ids,\n\tomp_get_place_num, omp_get_partition_num_places,\n\tomp_get_partition_place_nums, omp_get_initial_device,\n\tomp_get_max_task_priority): New functions and subroutines.\n\t* ordered.c: Include stdarg.h and string.h.\n\t(MAX_COLLAPSED_BITS): Define.\n\t(gomp_doacross_init, GOMP_doacross_post, GOMP_doacross_wait,\n\tgomp_doacross_ull_init, GOMP_doacross_ull_post,\n\tGOMP_doacross_ull_wait): New functions.\n\t* target.c: Include errno.h.\n\t(resolve_device): If device is not initialized, call\n\tgomp_init_device on it.\n\t(gomp_map_lookup): New function.\n\t(gomp_map_vars_existing): Add tgt_var argument, fill it in.\n\tDon't bump refcount if REFCOUNT_INFINITY.  Handle\n\tGOMP_MAP_ALWAYS_TO_P.\n\t(get_kind): Rename is_openacc argument to short_mapkind.\n\t(gomp_map_pointer): Use gomp_map_lookup.\n\t(gomp_map_fields_existing): New function.\n\t(gomp_map_vars): Rename is_openacc argument to short_mapkind\n\tand is_target to pragma_kind.  Handle GOMP_MAP_VARS_ENTER_DATA,\n\thandle GOMP_MAP_FIRSTPRIVATE_INT, GOMP_MAP_STRUCT,\n\tGOMP_MAP_USE_DEVICE_PTR, GOMP_MAP_ZERO_LEN_ARRAY_SECTION.\n\tAdjust for tgt->list changed type and copy_from living in there.\n\t(gomp_copy_from_async): Adjust for tgt->list changed type and\n\tcopy_from living in there.\n\t(gomp_unmap_vars): Likewise.\n\t(gomp_update): Likewise.  Rename is_openacc argument to\n\tshort_mapkind.  Don't fail if object is not mapped.\n\t(gomp_load_image_to_device): Initialize refcount to\n\tREFCOUNT_INFINITY.\n\t(gomp_target_fallback): New function.\n\t(gomp_get_target_fn_addr): Likewise.\n\t(GOMP_target): Adjust gomp_map_vars caller, use\n\tgomp_get_target_fn_addr and gomp_target_fallback.\n\t(GOMP_target_41): New function.\n\t(gomp_target_data_fallback): New function.\n\t(GOMP_target_data): Use it, adjust gomp_map_vars caller.\n\t(GOMP_target_data_41): New function.\n\t(GOMP_target_update): Adjust gomp_update caller.\n\t(GOMP_target_update_41): New function.\n\t(gomp_exit_data, GOMP_target_enter_exit_data,\n\tgomp_target_task_fn, omp_target_alloc, omp_target_free,\n\tomp_target_is_present, omp_target_memcpy,\n\tomp_target_memcpy_rect_worker, omp_target_memcpy_rect,\n\tomp_target_associate_ptr, omp_target_disassociate_ptr,\n\tgomp_load_plugin_for_device): New functions.\n\t* task.c: Include gomp-constants.h.  Include taskloop.c\n\ttwice to get GOMP_taskloop and GOMP_taskloop_ull definitions.\n\t(gomp_task_handle_depend): New function.\n\t(GOMP_task): Use it.  Add priority argument.  Use\n\tgomp-constant.h constants instead of hardcoded numbers.\n\tRename GOMP_TASK_IFFALSE to GOMP_TASK_UNDEFERRED.\n\t(gomp_create_target_task): New function.\n\t(verify_children_queue, verify_taskgroup_queue,\n\tverify_task_queue): New functions.\n\t(gomp_task_run_pre): Call verify_*_queue functions.\n\tIf an upcoming tied task is about to leave the sibling or\n\ttaskgroup queues in an invalid state, adjust appropriately.\n\tRemove taskgroup argument.  Add comments.\n\t(gomp_task_run_post_handle_dependers): Add comments.\n\t(gomp_task_run_post_remove_parent): Likewise.\n\t(gomp_barrier_handle_tasks): Adjust gomp_task_run_pre caller.\n\t(GOMP_taskwait): Likewise.  Add comments.\n\t(gomp_task_maybe_wait_for_dependencies): Fix scheduling\n\tproblem such that the first non parent_depends_on task does not\n\tend up at the end of the children queue.\n\t(GOMP_taskgroup_start): Rename GOMP_TASK_IFFALSE to\n\tGOMP_TASK_UNDEFERRED.\n\t(GOMP_taskgroup_end): Adjust gomp_task_run_pre caller.\n\t* taskloop.c: New file.\n\t* testsuite/lib/libgomp.exp\n\t(check_effective_target_offload_device_nonshared_as): New proc.\n\t* testsuite/libgomp.c/affinity-2.c: New test.\n\t* testsuite/libgomp.c/doacross-1.c: New test.\n\t* testsuite/libgomp.c/doacross-2.c: New test.\n\t* testsuite/libgomp.c/examples-4/declare_target-1.c (fib_wrapper):\n\tAdd map clause to target.\n\t* testsuite/libgomp.c/examples-4/declare_target-4.c (accum): Likewise.\n\t* testsuite/libgomp.c/examples-4/declare_target-5.c (accum): Likewise.\n\t* testsuite/libgomp.c/examples-4/device-1.c (main): Likewise.\n\t* testsuite/libgomp.c/examples-4/device-3.c (main): Likewise.\n\t* testsuite/libgomp.c/examples-4/target_data-3.c (gramSchmidt):\n\tLikewise.\n\t* testsuite/libgomp.c/examples-4/teams-2.c (dotprod): Likewise.\n\t* testsuite/libgomp.c/examples-4/teams-3.c (dotprod): Likewise.\n\t* testsuite/libgomp.c/examples-4/teams-4.c (dotprod): Likewise.\n\t* testsuite/libgomp.c/for-2.h (OMPTGT, OMPTO, OMPFROM): Define if\n\tnot defined.  Use those where needed.\n\t* testsuite/libgomp.c/for-4.c: New test.\n\t* testsuite/libgomp.c/for-5.c: New test.\n\t* testsuite/libgomp.c/for-6.c: New test.\n\t* testsuite/libgomp.c/linear-1.c: New test.\n\t* testsuite/libgomp.c/ordered-4.c: New test.\n\t* testsuite/libgomp.c/pr66199-2.c (f2): Adjust for linear clause\n\tonly allowed on the loop iterator.\n\t* testsuite/libgomp.c/pr66199-3.c: New test.\n\t* testsuite/libgomp.c/pr66199-4.c: New test.\n\t* testsuite/libgomp.c/reduction-7.c: New test.\n\t* testsuite/libgomp.c/reduction-8.c: New test.\n\t* testsuite/libgomp.c/reduction-9.c: New test.\n\t* testsuite/libgomp.c/reduction-10.c: New test.\n\t* testsuite/libgomp.c/target-1.c (fn2, fn3, fn4): Add\n\tmap(tofrom:s).\n\t* testsuite/libgomp.c/target-2.c (fn2, fn3, fn4): Likewise.\n\t* testsuite/libgomp.c/target-7.c (foo): Add map(h) where needed.\n\t* testsuite/libgomp.c/target-11.c: New test.\n\t* testsuite/libgomp.c/target-12.c: New test.\n\t* testsuite/libgomp.c/target-13.c: New test.\n\t* testsuite/libgomp.c/target-14.c: New test.\n\t* testsuite/libgomp.c/target-15.c: New test.\n\t* testsuite/libgomp.c/target-16.c: New test.\n\t* testsuite/libgomp.c/target-17.c: New test.\n\t* testsuite/libgomp.c/target-18.c: New test.\n\t* testsuite/libgomp.c/target-19.c: New test.\n\t* testsuite/libgomp.c/target-20.c: New test.\n\t* testsuite/libgomp.c/target-21.c: New test.\n\t* testsuite/libgomp.c/target-22.c: New test.\n\t* testsuite/libgomp.c/target-23.c: New test.\n\t* testsuite/libgomp.c/target-24.c: New test.\n\t* testsuite/libgomp.c/target-25.c: New test.\n\t* testsuite/libgomp.c/target-26.c: New test.\n\t* testsuite/libgomp.c/target-27.c: New test.\n\t* testsuite/libgomp.c/taskloop-1.c: New test.\n\t* testsuite/libgomp.c/taskloop-2.c: New test.\n\t* testsuite/libgomp.c/taskloop-3.c: New test.\n\t* testsuite/libgomp.c/taskloop-4.c: New test.\n\t* testsuite/libgomp.c++/ctor-13.C: New test.\n\t* testsuite/libgomp.c++/doacross-1.C: New test.\n\t* testsuite/libgomp.c++/examples-4/declare_target-2.C:\n\tReplace offload_device with offload_device_nonshared_as.\n\t* testsuite/libgomp.c++/for-12.C: New test.\n\t* testsuite/libgomp.c++/for-13.C: New test.\n\t* testsuite/libgomp.c++/for-14.C: New test.\n\t* testsuite/libgomp.c++/linear-1.C: New test.\n\t* testsuite/libgomp.c++/member-1.C: New test.\n\t* testsuite/libgomp.c++/member-2.C: New test.\n\t* testsuite/libgomp.c++/member-3.C: New test.\n\t* testsuite/libgomp.c++/member-4.C: New test.\n\t* testsuite/libgomp.c++/member-5.C: New test.\n\t* testsuite/libgomp.c++/ordered-1.C: New test.\n\t* testsuite/libgomp.c++/reduction-5.C: New test.\n\t* testsuite/libgomp.c++/reduction-6.C: New test.\n\t* testsuite/libgomp.c++/reduction-7.C: New test.\n\t* testsuite/libgomp.c++/reduction-8.C: New test.\n\t* testsuite/libgomp.c++/reduction-9.C: New test.\n\t* testsuite/libgomp.c++/reduction-10.C: New test.\n\t* testsuite/libgomp.c++/reference-1.C: New test.\n\t* testsuite/libgomp.c++/simd14.C: New test.\n\t* testsuite/libgomp.c++/target-2.C (fn2): Add map(tofrom: s) clause.\n\t* testsuite/libgomp.c++/target-5.C: New test.\n\t* testsuite/libgomp.c++/target-6.C: New test.\n\t* testsuite/libgomp.c++/target-7.C: New test.\n\t* testsuite/libgomp.c++/target-8.C: New test.\n\t* testsuite/libgomp.c++/target-9.C: New test.\n\t* testsuite/libgomp.c++/target-10.C: New test.\n\t* testsuite/libgomp.c++/target-11.C: New test.\n\t* testsuite/libgomp.c++/target-12.C: New test.\n\t* testsuite/libgomp.c++/taskloop-1.C: New test.\n\t* testsuite/libgomp.c++/taskloop-2.C: New test.\n\t* testsuite/libgomp.c++/taskloop-3.C: New test.\n\t* testsuite/libgomp.c++/taskloop-4.C: New test.\n\t* testsuite/libgomp.c++/taskloop-5.C: New test.\n\t* testsuite/libgomp.c++/taskloop-6.C: New test.\n\t* testsuite/libgomp.c++/taskloop-7.C: New test.\n\t* testsuite/libgomp.c++/taskloop-8.C: New test.\n\t* testsuite/libgomp.c++/taskloop-9.C: New test.\n\t* testsuite/libgomp.fortran/affinity1.f90: New test.\n\t* testsuite/libgomp.fortran/affinity2.f90: New test.\nliboffloadmic/\n2015-10-13  Ilya Verbin  <ilya.verbin@intel.com>\n\n\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_dev2dev): New\n\tfunction.\n\t* plugin/offload_target_main.cpp (__offload_target_tgt2tgt): New\n\tstatic function, register it in liboffloadmic.\n\nFrom-SVN: r228777", "tree": {"sha": "e8508f7b6cd5600095f6c36ccd08e6440d82340c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8508f7b6cd5600095f6c36ccd08e6440d82340c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/comments", "author": null, "committer": null, "parents": [{"sha": "1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa"}], "stats": {"total": 28558, "additions": 26878, "deletions": 1680}, "files": [{"sha": "750c73aad08c55754e9742b87baecdbf44373c0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1,3 +1,378 @@\n+2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* builtin-types.def (BT_FN_BOOL_UINT_LONGPTR_LONGPTR_LONGPTR,\n+\tBT_FN_BOOL_UINT_ULLPTR_ULLPTR_ULLPTR,\n+\tBT_FN_BOOL_UINT_LONGPTR_LONG_LONGPTR_LONGPTR,\n+\tBT_FN_BOOL_UINT_ULLPTR_ULL_ULLPTR_ULLPTR,\n+\tBT_FN_VOID_INT_SIZE_PTR_PTR_PTR_UINT_PTR,\n+\tBT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR,\n+\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,\n+\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_LONG_LONG_LONG,\n+\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_ULL_ULL_ULL,\n+\tBT_FN_VOID_LONG_VAR, BT_FN_VOID_ULL_VAR): New.\n+\t(BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR,\n+\tBT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR,\n+\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR): Remove.\n+\t* cgraph.h (enum cgraph_simd_clone_arg_type): Add\n+\tSIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP,\n+\tSIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP and\n+\tSIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP.\n+\t(struct cgraph_simd_clone_arg): Adjust comment.\n+\t* coretypes.h (struct gomp_ordered): New forward decl.\n+\t* gimple.c (gimple_build_omp_critical): Add CLAUSES argument,\n+\tset critical clauses to it.\n+\t(gimple_build_omp_ordered): Return gomp_ordered * instead of\n+\tgimple *.  Add CLAUSES argument, set ordered clauses to it.\n+\t(gimple_copy): Unshare clauses on GIMPLE_OMP_CRITICAL and\n+\tGIMPLE_OMP_ORDERED.\n+\t* gimple.def (GIMPLE_OMP_ORDERED): Change from GSS_OMP to\n+\tGSS_OMP_SINGLE_LAYOUT, move it after GIMPLE_OMP_TEAMS.\n+\t* gimple.h (enum gf_mask): Add GF_OMP_TASK_TASKLOOP.  Add another bit\n+\tto GF_OMP_FOR_KIND_MASK mask. Add GF_OMP_FOR_KIND_TASKLOOP, renumber\n+\tGF_OMP_FOR_KIND_CILKFOR and GF_OMP_FOR_KIND_OACC_LOOP.  Adjust\n+\tGF_OMP_FOR_SIMD, GF_OMP_FOR_COMBINED and GF_OMP_FOR_COMBINED_INTO.\n+\tAdd another bit to GF_OMP_TARGET_KIND_MASK mask.  Add\n+\tGF_OMP_TARGET_KIND_ENTER_DATA and GF_OMP_TARGET_KIND_EXIT_DATA,\n+\trenumber\n+\tGF_OMP_TARGET_KIND_OACC_{PARALLEL,KERNELS,DATA,UPDATE,ENTER_EXIT_DATA}.\n+\t(gomp_critical): Add clauses field.\n+\t(gomp_ordered): New struct.\n+\t(is_a_helper <gomp_ordered *>::test): New inline.\n+\t(gimple_build_omp_critical): Add CLAUSES argument.\n+\t(gimple_build_omp_ordered): Likewise.  Return gomp_ordered *\n+\tinstead of gimple *.\n+\t(gimple_omp_critical_clauses, gimple_omp_critical_clauses_ptr,\n+\tgimple_omp_critical_set_clauses, gimple_omp_ordered_clauses,\n+\tgimple_omp_ordered_clauses_ptr, gimple_omp_ordered_set_clauses,\n+\tgimple_omp_task_taskloop_p, gimple_omp_task_set_taskloop_p): New\n+\tinline functions.\n+\t* gimple-pretty-print.c (dump_gimple_omp_for): Handle taskloop.\n+\t(dump_gimple_omp_target): Handle enter data and exit data.\n+\t(dump_gimple_omp_block): Don't handle GIMPLE_OMP_ORDERED here.\n+\t(dump_gimple_omp_critical): Print clauses.\n+\t(dump_gimple_omp_ordered): New function.\n+\t(dump_gimple_omp_task): Handle taskloop.\n+\t(pp_gimple_stmt_1): Use dump_gimple_omp_ordered for\n+\tGIMPLE_OMP_ORDERED.\n+\t* gimple-walk.c (walk_gimple_op): Walk clauses on\n+\tGIMPLE_OMP_CRITICAL and GIMPLE_OMP_ORDERED.\n+\t* gimplify.c (enum gimplify_omp_var_data): Add GOVD_MAP_0LEN_ARRAY.\n+\t(enum omp_region_type): Add ORT_COMBINED_TARGET and ORT_NONE.\n+\t(struct gimplify_omp_ctx): Add loop_iter_var,\n+\ttarget_map_scalars_firstprivate, target_map_pointers_as_0len_arrays\n+\tand target_firstprivatize_array_bases fields.\n+\t(delete_omp_context): Release loop_iter_var.\n+\t(gimplify_bind_expr): Handle ORT_NONE.\n+\t(maybe_fold_stmt): Adjust check for ORT_TARGET for the addition of\n+\tORT_COMBINED_TARGET.\n+\t(is_gimple_stmt): Return true for OMP_TASKLOOP, OMP_TEAMS and\n+\tOMP_TARGET{,_DATA,_UPDATE,_ENTER_DATA,_EXIT_DATA}.\n+\t(omp_firstprivatize_variable): Handle ORT_NONE.  Adjust check for\n+\tORT_TARGET for the addition of ORT_COMBINED_TARGET.  Handle\n+\tctx->target_map_scalars_firstprivate.\n+\t(omp_add_variable): Handle ORT_NONE.  Allow map clause together with\n+\tdata sharing clauses.  For data sharing clause with VLA decl\n+\ton omp target/target data don't add firstprivate for the pointer.\n+\tCall omp_notice_variable on TYPE_SIZE_UNIT only if it is a DECL_P.\n+\t(omp_notice_threadprivate_variable): Adjust check for ORT_TARGET for\n+\tthe addition of ORT_COMBINED_TARGET.\n+\t(omp_notice_variable): Handle ORT_NONE.  Adjust check for ORT_TARGET\n+\tfor the addition of ORT_COMBINED_TARGET.  Handle implicit mapping of\n+\tpointers as zero length array sections and\n+\tctx->target_map_scalars_firstprivate mapping of scalars as firstprivate\n+\tdata sharing.\n+\t(omp_check_private): Handle omp_member_access_dummy_var vars.\n+\t(find_decl_expr): New function.\n+\t(gimplify_scan_omp_clauses): Add CODE argument.  For OMP_CLAUSE_IF\n+\tcomplain if OMP_CLAUSE_IF_MODIFIER is present and does not match code.\n+\tHandle OMP_CLAUSE_GANG separately.  Handle\n+\tOMP_CLAUSE_{PRIORITY,GRAINSIZE,NUM_TASKS,NOGROUP,THREADS,SIMD,SIMDLEN}\n+\tclauses.  Diagnose linear clause on combined\n+\tdistribute {, parallel for} simd construct, unless it is the loop\n+\titerator.  Handle struct element GOMP_MAP_FIRSTPRIVATE_POINTER.\n+\tHandle map clauses with COMPONENT_REF.  Initialize\n+\tctx->target_map_scalars_firstprivate,\n+\tctx->target_firstprivatize_array_bases and\n+\tctx->target_map_pointers_as_0len_arrays.  Add firstprivate for\n+\tlinear clause even to target region if combined.  Remove\n+\tmap clauses with GOMP_MAP_FIRSTPRIVATE_POINTER kind from\n+\tOMP_TARGET_{,ENTER_,EXIT_}DATA.  For GOMP_MAP_FIRSTPRIVATE_POINTER\n+\tmap kind with non-INTEGER_CST OMP_CLAUSE_SIZE firstprivatize the bias.\n+\tHandle OMP_CLAUSE_DEPEND_{SINK,SOURCE}.  Handle\n+\tOMP_CLAUSE_{{USE,IS}_DEVICE_PTR,DEFAULTMAP,HINT}.\n+\tFor linear clause on worksharing loop combined with parallel add\n+\tshared clause on the parallel.  Handle OMP_CLAUSE_REDUCTION\n+\twith MEM_REF OMP_CLAUSE_DECL.  Set DECL_NAME on\n+\tomp_member_access_dummy_var vars.  Add lastprivate clause to outer\n+\ttaskloop if needed.\n+\t(gimplify_adjust_omp_clauses_1): Handle GOVD_MAP_0LEN_ARRAY.\n+\tIf gimplify_omp_ctxp->target_firstprivatize_array_bases, use\n+\tGOMP_MAP_FIRSTPRIVATE_POINTER map kind instead of\n+\tGOMP_MAP_POINTER.\n+\t(gimplify_adjust_omp_clauses): Add CODE argument.  Handle removal\n+\tof GOMP_MAP_FIRSTPRIVATE_POINTER struct elements for struct not seen\n+\tin target body.  Handle removal of struct mapping if struct is not\n+\tseen in target body.  Remove GOMP_MAP_STRUCT map clause on\n+\tOMP_TARGET_EXIT_DATA.  Adjust check for ORT_TARGET for the\n+\taddition of ORT_COMBINED_TARGET.  Use GOMP_MAP_FIRSTPRIVATE_POINTER\n+\tinstead of GOMP_MAP_POINTER if ctx->target_firstprivatize_array_bases\n+\tfor VLAs.  Set OMP_CLAUSE_MAP_PRIVATE if both data sharing and map\n+\tclause appear together.  Handle\n+\tOMP_CLAUSE_{{USE,IS}_DEVICE_PTR,DEFAULTMAP,HINT}.  Don't remove map\n+\tclause if it has map-type-modifier always.  Handle\n+\tOMP_CLAUSE_{PRIORITY,GRAINSIZE,NUM_TASKS,NOGROUP,THREADS,SIMD,SIMDLEN}\n+\tclauses.\n+\t(gimplify_oacc_cache, gimplify_omp_parallel, gimplify_omp_task):\n+\tAdjust gimplify_scan_omp_clauses and gimplify_adjust_omp_clauses\n+\tcallers.\n+\t(gimplify_omp_for): Likewise.  Handle OMP_TASKLOOP.  Initialize\n+\tloop_iter_var.  Use OMP_FOR_ORIG_DECLS.  Fix handling of lastprivate\n+\titerators in doacross loops.\n+\t(gimplify_omp_workshare): Adjust gimplify_scan_omp_clauses and\n+\tgimplify_adjust_omp_clauses callers.  Use ORT_COMBINED_TARGET\n+\tfor OMP_TARGET_COMBINED.  Adjust check for ORT_TARGET\n+\tfor the addition of ORT_COMBINED_TARGET.\n+\t(gimplify_omp_target_update): Adjust gimplify_scan_omp_clauses and\n+\tgimplify_adjust_omp_clauses callers.  Handle OMP_TARGET_ENTER_DATA\n+\tand OMP_TARGET_EXIT_DATA.\n+\t(gimplify_omp_ordered): New function.\n+\t(gimplify_expr): Handle OMP_TASKLOOP, OMP_TARGET_ENTER_DATA and\n+\tOMP_TARGET_EXIT_DATA.  Use gimplify_omp_ordered for OMP_ORDERED.\n+\tGimplify clauses on OMP_CRITICAL.\n+\t* internal-fn.c (expand_GOMP_SIMD_ORDERED_START,\n+\texpand_GOMP_SIMD_ORDERED_END): New functions.\n+\t* internal-fn.def (GOMP_SIMD_ORDERED_START,\n+\tGOMP_SIMD_ORDERED_END): New internal functions.\n+\t* omp-builtins.def (BUILT_IN_GOMP_LOOP_DOACROSS_STATIC_START,\n+\tBUILT_IN_GOMP_LOOP_DOACROSS_DYNAMIC_START,\n+\tBUILT_IN_GOMP_LOOP_DOACROSS_GUIDED_START,\n+\tBUILT_IN_GOMP_LOOP_DOACROSS_RUNTIME_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_DOACROSS_STATIC_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_DOACROSS_DYNAMIC_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_DOACROSS_GUIDED_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_DOACROSS_RUNTIME_START,\n+\tBUILT_IN_GOMP_DOACROSS_POST, BUILT_IN_GOMP_DOACROSS_WAIT,\n+\tBUILT_IN_GOMP_DOACROSS_ULL_POST, BUILT_IN_GOMP_DOACROSS_ULL_WAIT,\n+\tBUILT_IN_GOMP_TARGET_ENTER_EXIT_DATA, BUILT_IN_GOMP_TASKLOOP,\n+\tBUILT_IN_GOMP_TASKLOOP_ULL): New built-ins.\n+\t(BUILT_IN_GOMP_TASK): Add INT argument to the end.\n+\t(BUILT_IN_GOMP_TARGET): Rename from GOMP_target to GOMP_target_41,\n+\tadjust type.\n+\t(BUILT_IN_GOMP_TARGET_DATA): Rename from GOMP_target_data to\n+\tGOMP_target_data_41, adjust type.\n+\t(BUILT_IN_GOMP_TARGET_UPDATE): Rename from GOMP_target_update to\n+\tGOMP_target_update_41, adjust type.\n+\t* omp-low.c (struct omp_region): Adjust comments, add ord_stmt\n+\tfield.\n+\t(struct omp_for_data): Add ordered and simd_schedule fields.\n+\t(omp_member_access_dummy_var, unshare_and_remap_1,\n+\tunshare_and_remap, is_taskloop_ctx): New functions.\n+\t(is_taskreg_ctx): Use is_parallel_ctx and is_task_ctx.\n+\t(extract_omp_for_data): Handle taskloops and doacross loops\n+\tand simd schedule modifier.\n+\t(omp_adjust_chunk_size): New function.\n+\t(get_ws_args_for): Use it.\n+\t(lookup_sfield): Change first argument to splay_tree_key,\n+\tadd overload with first argument tree.\n+\t(maybe_lookup_field): Likewise.\n+\t(use_pointer_for_field): Handle omp_member_access_dummy_var.\n+\t(omp_copy_decl_2): If var is TREE_ADDRESSABLE listed in\n+\ttask_shared_vars, clear TREE_ADDRESSABLE on the copy.\n+\t(build_outer_var_ref): Add LASTPRIVATE argument, handle\n+\ttaskloops and omp_member_access_dummy_var vars.\n+\t(build_sender_ref): Change first argument to splay_tree_key,\n+\tadd overload with first argument tree.\n+\t(install_var_field): For mask & 8 use &DECL_UID as key instead\n+\tof the tree itself.\n+\t(fixup_child_record_type): Const qualify *.omp_data_i.\n+\t(scan_sharing_clauses): Handle OMP_CLAUSE_SHARED_FIRSTPRIVATE,\n+\tC/C++ array reductions, OMP_CLAUSE_{IS,USE}_DEVICE_PTR clauses,\n+\tOMP_CLAUSE_{PRIORITY,GRAINSIZE,NUM_TASKS,SIMDLEN,THREADS,SIMD} and\n+\tOMP_CLAUSE_{NOGROUP,DEFAULTMAP} clauses, OMP_CLAUSE__LOOPTEMP_ clause\n+\ton taskloop, GOMP_MAP_FIRSTPRIVATE_POINTER, OMP_CLAUSE_MAP_PRIVATE.\n+\t(create_omp_child_function): Set TREE_READONLY on .omp_data_i.\n+\t(find_combined_for): Allow searching for different GIMPLE_OMP_FOR\n+\tkinds.\n+\t(add_taskreg_looptemp_clauses): New function.\n+\t(scan_omp_parallel): Use it.\n+\t(scan_omp_task): Likewise.\n+\t(finish_taskreg_scan): Handle OMP_CLAUSE_SHARED_FIRSTPRIVATE.\n+\tFor taskloop, move fields for the first two _LOOPTEMP_ clauses first.\n+\t(check_omp_nesting_restrictions): Handle GF_OMP_TARGET_KIND_ENTER_DATA\n+\tand GF_OMP_TARGET_KIND_EXIT_DATA.  Formatting fixes.  Allow the\n+\tsandwiched taskloop constructs.  Type check\n+\tOMP_CLAUSE_DEPEND_{KIND,SOURCE}.  Allow ordered simd inside of simd\n+\tregion.  Diagnose depend(source) or depend(sink:...) on\n+\ttarget constructs or task/taskloop.\n+\t(handle_simd_reference): Use get_name.\n+\t(lower_rec_input_clauses): Likewise.  Ignore all\n+\tOMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE clauses on taskloop construct.\n+\tAllow _LOOPTEMP_ clause on GOMP_TASK.  Unshare new_var\n+\tbefore passing it to omp_clause_{default,copy}_ctor.  Handle\n+\tOMP_CLAUSE_REDUCTION with MEM_REF OMP_CLAUSE_DECL.  Set\n+\tlastprivate_firstprivate flag for linear that needs copyin and\n+\tcopyout.  Use BUILT_IN_ALLOCA_WITH_ALIGN instead of BUILT_IN_ALLOCA.\n+\t(lower_lastprivate_clauses): For OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE\n+\ton taskloop lookup decl in outer context.  Pass true to\n+\tbuild_outer_var_ref lastprivate argument.  Handle\n+\tOMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV lastprivate if the decl is global\n+\toutside of outer taskloop for.\n+\t(lower_reduction_clauses): Handle OMP_CLAUSE_REDUCTION with MEM_REF\n+\tOMP_CLAUSE_DECL.\n+\t(lower_send_clauses): Ignore first two _LOOPTEMP_ clauses in taskloop\n+\tGOMP_TASK.  Handle OMP_CLAUSE_SHARED_FIRSTPRIVATE.  Handle\n+\tomp_member_access_dummy_var vars.  Handle OMP_CLAUSE_REDUCTION\n+\twith MEM_REF OMP_CLAUSE_DECL.  Use new lookup_sfield overload.\n+\t(lower_send_shared_vars): Ignore fields with NULL or FIELD_DECL\n+\tabstract origin.  Handle omp_member_access_dummy_var vars.\n+\t(expand_parallel_call): Use expand_omp_build_assign.\n+\t(expand_task_call): Handle taskloop construct expansion.  Add\n+\tREGION argument.  Use GOMP_TASK_* defines instead of hardcoded\n+\tintegers.  Add priority argument to GOMP_task* calls.  Or in\n+\tGOMP_TASK_FLAG_PRIORITY into flags if priority is present for\n+\tGOMP_task call.\n+\t(expand_omp_build_assign): Add prototype.  Add AFTER\n+\targument, if true emit statements after *GSI_P and continue linking.\n+\t(expand_omp_taskreg): Adjust expand_task_call caller.\n+\t(expand_omp_for_init_counts): Rename zero_iter_bb argument to\n+\tzero_iter1_bb and first_zero_iter to first_zero_iter1, add\n+\tzero_iter2_bb and first_zero_iter2 arguments, handle computation\n+\tof counts even for ordered loops.\n+\t(expand_omp_for_init_vars): Handle GOMP_TASK inner_stmt.\n+\t(expand_omp_ordered_source, expand_omp_ordered_sink,\n+\texpand_omp_ordered_source_sink, expand_omp_for_ordered_loops): New\n+\tfunctions.\n+\t(expand_omp_for_generic): Use omp_adjust_chunk_size.  Handle linear\n+\tclauses on worksharing loop.  Handle DOACROSS loop expansion.\n+\t(expand_omp_for_static_nochunk): Handle linear clauses on\n+\tworksharing loop.  Adjust expand_omp_for_init_counts\n+\tcallers.\n+\t(expand_omp_for_static_chunk): Likewise.  Use omp_adjust_chunk_size.\n+\t(expand_omp_simd): Handle addressable fd->loop.v.  Adjust\n+\texpand_omp_for_init_counts callers.\n+\t(expand_omp_taskloop_for_outer, expand_omp_taskloop_for_inner): New\n+\tfunctions.\n+\t(expand_omp_for): Call expand_omp_taskloop_for_* for taskloop.\n+\tHandle doacross loops.\n+\t(expand_omp_target): Handle GF_OMP_TARGET_KIND_ENTER_DATA and\n+\tGF_OMP_TARGET_KIND_EXIT_DATA.  Pass flags and depend arguments to\n+\tGOMP_target_{41,update_41,enter_exit_data} libcalls.\n+\t(expand_omp): Don't expand ordered depend constructs here, record\n+\tord_stmt instead for later expand_omp_for_generic.\n+\t(build_omp_regions_1): Handle GF_OMP_TARGET_KIND_ENTER_DATA and\n+\tGF_OMP_TARGET_KIND_EXIT_DATA.  Treat GIMPLE_OMP_ORDERED with depend\n+\tclause as stand-alone directive.\n+\t(lower_omp_ordered_clauses): New function.\n+\t(lower_omp_ordered): Handle OMP_CLAUSE_SIMD, for OMP_CLAUSE_DEPEND\n+\tdon't lower anything.\n+\t(lower_omp_for_lastprivate): Use last _looptemp_ clause\n+\ton taskloop for comparison.\n+\t(lower_omp_for): Handle taskloop constructs.  Adjust OMP_CLAUSE_DECL\n+\tand OMP_CLAUSE_LINEAR_STEP so that expand_omp_for_* can use it during\n+\texpansion for linear adjustments.\n+\t(create_task_copyfn): Handle OMP_CLAUSE_SHARED_FIRSTPRIVATE.\n+\t(lower_depend_clauses): Assert not seeing sink/source depend kinds.\n+\tSet TREE_ADDRESSABLE on array.  Change first argument from gimple *\n+\tto tree * pointing to the stmt's clauses.\n+\t(lower_omp_taskreg): Adjust lower_depend_clauses caller.\n+\t(lower_omp_target): Handle GF_OMP_TARGET_KIND_ENTER_DATA\n+\tand GF_OMP_TARGET_KIND_EXIT_DATA, depend clauses,\n+\tGOMP_MAP_{RELEASE,ALWAYS_{TO,FROM,TOFROM},FIRSTPRIVATE_POINTER,STRUCT}\n+\tmap kinds, OMP_CLAUSE_{FIRSTPRIVATE,PRIVATE,{IS,USE}_DEVICE_PTR\n+\tclauses.  Always use short kind and 8-bit align shift.\n+\t(lower_omp_regimplify_p): Use IS_TYPE_OR_DECL_P macro.\n+\t(struct lower_omp_regimplify_operands_data): New type.\n+\t(lower_omp_regimplify_operands_p, lower_omp_regimplify_operands):\n+\tNew functions.\n+\t(lower_omp_1): Use lower_omp_regimplify_operands instead of\n+\tgimple_regimplify_operands.\n+\t(make_gimple_omp_edges): Handle GF_OMP_TARGET_KIND_ENTER_DATA and\n+\tGF_OMP_TARGET_KIND_EXIT_DATA.  Treat GIMPLE_OMP_ORDERED with depend\n+\tclause as stand-alone directive.\n+\t(simd_clone_clauses_extract): Honor OMP_CLAUSE_LINEAR_KIND.\n+\t(simd_clone_mangle): Mangle the various linear kinds\n+\tper the new ABI.\n+\t(simd_clone_adjust_argument_types): Handle\n+\tSIMD_CLONE_ARG_TYPE_LINEAR_*_CONSTANT_STEP.\n+\t(simd_clone_init_simd_arrays): Don't do anything for uval.\n+\t(simd_clone_adjust): Handle\n+\tSIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP like\n+\tSIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP.\n+\tHandle SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP.\n+\t* omp-low.h (omp_member_access_dummy_var): New prototype.\n+\t* passes.def (pass_simduid_cleanup): Schedule another copy of the\n+\tpass after all optimizations.\n+\t* tree.c (omp_clause_code_name): Add entries for\n+\tOMP_CLAUSE_{TO_DECLARE,LINK,{USE,IS}_DEVICE_PTR,DEFAULTMAP,HINT}\n+\tand OMP_CLAUSE_{PRIORITY,GRAINSIZE,NUM_TASKS,NOGROUP,THREADS,SIMD}.\n+\t(omp_clause_num_ops): Likewise.  Bump number of OMP_CLAUSE_REDUCTION\n+\targuments to 5 and for OMP_CLAUSE_ORDERED to 1.\n+\t(walk_tree_1): Adjust for OMP_CLAUSE_ORDERED having 1 argument and\n+\tOMP_CLAUSE_REDUCTION 5 arguments.  Handle\n+\tOMP_CLAUSE_{TO_DECLARE,LINK,{USE,IS}_DEVICE_PTR,DEFAULTMAP,HINT}\n+\tand OMP_CLAUSE_{PRIORITY,GRAINSIZE,NUM_TASKS,NOGROUP,THREADS,SIMD}\n+\tclauses.\n+\t* tree-core.h (enum omp_clause_linear_kind): New.\n+\t(struct tree_omp_clause): Change type of map_kind\n+\tfrom unsigned char to unsigned int.  Add subcode.if_modifier\n+\tand subcode.linear_kind fields.\n+\t(enum omp_clause_code): Add\n+\tOMP_CLAUSE_{TO_DECLARE,LINK,{USE,IS}_DEVICE_PTR,DEFAULTMAP,HINT}\n+\tand OMP_CLAUSE_{PRIORITY,GRAINSIZE,NUM_TASKS,NOGROUP,THREADS,SIMD}.\n+\t(OMP_CLAUSE_REDUCTION): Document\n+\tOMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER.\n+\t(enum omp_clause_depend_kind): Add OMP_CLAUSE_DEPEND_{SOURCE,SINK}.\n+\t* tree.def (OMP_FOR): Add OMP_FOR_ORIG_DECLS operand.\n+\t(OMP_CRITICAL): Move before OMP_SINGLE.  Add OMP_CRITICAL_CLAUSES\n+\toperand.\n+\t(OMP_ORDERED): Move before OMP_SINGLE.  Add OMP_ORDERED_CLAUSES\n+\toperand.\n+\t(OMP_TASKLOOP, OMP_TARGET_ENTER_DATA, OMP_TARGET_EXIT_DATA): New tree\n+\tcodes.\n+\t* tree.h (OMP_BODY): Replace OMP_CRITICAL with OMP_TASKGROUP.\n+\t(OMP_CLAUSE_SET_MAP_KIND): Cast to unsigned int rather than unsigned\n+\tchar.\n+\t(OMP_CRITICAL_NAME): Adjust to be 3rd operand instead of 2nd.\n+\t(OMP_CLAUSE_NUM_TASKS_EXPR): Formatting fix.\n+\t(OMP_STANDALONE_CLAUSES): Adjust to cover OMP_TARGET_{ENTER,EXIT}_DATA.\n+\t(OMP_CLAUSE_DEPEND_SINK_NEGATIVE, OMP_TARGET_COMBINED,\n+\tOMP_CLAUSE_MAP_PRIVATE, OMP_FOR_ORIG_DECLS, OMP_CLAUSE_IF_MODIFIER,\n+\tOMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION, OMP_CRITICAL_CLAUSES,\n+\tOMP_CLAUSE_PRIVATE_TASKLOOP_IV, OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV,\n+\tOMP_CLAUSE_HINT_EXPR, OMP_CLAUSE_SCHEDULE_SIMD,\n+\tOMP_CLAUSE_LINEAR_KIND, OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER,\n+\tOMP_CLAUSE_SHARED_FIRSTPRIVATE, OMP_ORDERED_CLAUSES,\n+\tOMP_TARGET_ENTER_DATA_CLAUSES, OMP_TARGET_EXIT_DATA_CLAUSES,\n+\tOMP_CLAUSE_NUM_TASKS_EXPR, OMP_CLAUSE_GRAINSIZE_EXPR,\n+\tOMP_CLAUSE_PRIORITY_EXPR, OMP_CLAUSE_ORDERED_EXPR): Define.\n+\t* tree-inline.c (remap_gimple_stmt): Handle clauses on\n+\tGIMPLE_OMP_ORDERED and GIMPLE_OMP_CRITICAL.  For\n+\tIFN_GOMP_SIMD_ORDERED_{START,END} set has_simduid_loops.\n+\t* tree-nested.c (convert_nonlocal_omp_clauses): Handle\n+\tOMP_CLAUSE_{TO_DECLARE,LINK,{USE,IS}_DEVICE_PTR,SIMDLEN,PRIORITY,SIMD}\n+\tand OMP_CLAUSE_{GRAINSIZE,NUM_TASKS,HINT,NOGROUP,THREADS,DEFAULTMAP}\n+\tclauses.  Handle OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER.\n+\t(convert_local_omp_clauses): Likewise.\n+\t* tree-pretty-print.c (dump_omp_clause): Handle\n+\tOMP_CLAUSE_{TO_DECLARE,LINK,{USE,IS}_DEVICE_PTR,SIMDLEN,PRIORITY,SIMD}\n+\tand OMP_CLAUSE_{GRAINSIZE,NUM_TASKS,HINT,NOGROUP,THREADS,DEFAULTMAP}\n+\tclauses.  Handle OMP_CLAUSE_IF_MODIFIER, OMP_CLAUSE_ORDERED_EXPR,\n+\tOMP_CLAUSE_SCHEDULE_SIMD, OMP_CLAUSE_LINEAR_KIND,\n+\tOMP_CLAUSE_DEPEND_{SOURCE,SINK}.  Use \"delete\" for\n+\tGOMP_MAP_FORCE_DEALLOC.  Handle\n+\tGOMP_MAP_{ALWAYS_{TO,FROM,TOFROM},RELEASE,FIRSTPRIVATE_POINTER,STRUCT}.\n+\t(dump_generic_node): Handle OMP_TASKLOOP, OMP_TARGET_{ENTER,EXIT}_DATA\n+\tand clauses on OMP_ORDERED and OMP_CRITICAL.\n+\t* tree-vectorizer.c (adjust_simduid_builtins): Adjust comment.\n+\tRemove IFN_GOMP_SIMD_ORDERED_{START,END}.\n+\t(vectorize_loops): Adjust comments.\n+\t(pass_simduid_cleanup::execute): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_simd_clone_call): Handle\n+\tSIMD_CLONE_ARG_TYPE_LINEAR_{REF,VAL,UVAL}_CONSTANT_STEP.\n+\t* wide-int.h (wi::gcd): New.\n+\n 2015-10-13  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (classify_argument): Use CEIL where applicable."}, {"sha": "9effe45f230049306c0d86c60f0725da816515f0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1,3 +1,8 @@\n+2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc-interface/utils.c (DEF_FUNCTION_TYPE_9, DEF_FUNCTION_TYPE_10,\n+\tDEF_FUNCTION_TYPE_11): Define.\n+\n 2015-10-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/Make-lang.in: Make sure that GNAT1_OBJS and not just"}, {"sha": "917c2803f0d1c4df1cbc6c45b64d7674351cbd3c", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -5369,6 +5369,12 @@ enum c_builtin_type\n \t\t\t    ARG6, ARG7) NAME,\n #define DEF_FUNCTION_TYPE_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n \t\t\t    ARG6, ARG7, ARG8) NAME,\n+#define DEF_FUNCTION_TYPE_9(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8, ARG9) NAME,\n+#define DEF_FUNCTION_TYPE_10(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10) NAME,\n+#define DEF_FUNCTION_TYPE_11(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) NAME,\n #define DEF_FUNCTION_TYPE_VAR_0(NAME, RETURN) NAME,\n #define DEF_FUNCTION_TYPE_VAR_1(NAME, RETURN, ARG1) NAME,\n #define DEF_FUNCTION_TYPE_VAR_2(NAME, RETURN, ARG1, ARG2) NAME,\n@@ -5392,6 +5398,9 @@ enum c_builtin_type\n #undef DEF_FUNCTION_TYPE_6\n #undef DEF_FUNCTION_TYPE_7\n #undef DEF_FUNCTION_TYPE_8\n+#undef DEF_FUNCTION_TYPE_9\n+#undef DEF_FUNCTION_TYPE_10\n+#undef DEF_FUNCTION_TYPE_11\n #undef DEF_FUNCTION_TYPE_VAR_0\n #undef DEF_FUNCTION_TYPE_VAR_1\n #undef DEF_FUNCTION_TYPE_VAR_2\n@@ -5493,6 +5502,18 @@ install_builtin_function_types (void)\n \t\t\t    ARG6, ARG7, ARG8)\t\t\t\t\\\n   def_fn_type (ENUM, RETURN, 0, 8, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n \t       ARG7, ARG8);\n+#define DEF_FUNCTION_TYPE_9(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8, ARG9)\t\t\t\\\n+  def_fn_type (ENUM, RETURN, 0, 9, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n+\t       ARG7, ARG8, ARG9);\n+#define DEF_FUNCTION_TYPE_10(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5,\\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10)\t\t\\\n+  def_fn_type (ENUM, RETURN, 0, 10, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n+\t       ARG7, ARG8, ARG9, ARG10);\n+#define DEF_FUNCTION_TYPE_11(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5,\\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)\t\\\n+  def_fn_type (ENUM, RETURN, 0, 11, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n+\t       ARG7, ARG8, ARG9, ARG10, ARG11);\n #define DEF_FUNCTION_TYPE_VAR_0(ENUM, RETURN) \\\n   def_fn_type (ENUM, RETURN, 1, 0);\n #define DEF_FUNCTION_TYPE_VAR_1(ENUM, RETURN, ARG1) \\\n@@ -5526,6 +5547,9 @@ install_builtin_function_types (void)\n #undef DEF_FUNCTION_TYPE_6\n #undef DEF_FUNCTION_TYPE_7\n #undef DEF_FUNCTION_TYPE_8\n+#undef DEF_FUNCTION_TYPE_9\n+#undef DEF_FUNCTION_TYPE_10\n+#undef DEF_FUNCTION_TYPE_11\n #undef DEF_FUNCTION_TYPE_VAR_0\n #undef DEF_FUNCTION_TYPE_VAR_1\n #undef DEF_FUNCTION_TYPE_VAR_2"}, {"sha": "b561436f55ce595e8a9ea8d850a6183b91ad2f6e", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -473,6 +473,11 @@ DEF_FUNCTION_TYPE_4 (BT_FN_VOID_SIZE_VPTR_PTR_INT, BT_VOID, BT_SIZE,\n \t\t     BT_VOLATILE_PTR, BT_PTR, BT_INT)\n DEF_FUNCTION_TYPE_4 (BT_FN_VOID_SIZE_CONST_VPTR_PTR_INT, BT_VOID, BT_SIZE,\n \t\t     BT_CONST_VOLATILE_PTR, BT_PTR, BT_INT)\n+DEF_FUNCTION_TYPE_4 (BT_FN_BOOL_UINT_LONGPTR_LONGPTR_LONGPTR,\n+\t\t     BT_BOOL, BT_UINT, BT_PTR_LONG, BT_PTR_LONG, BT_PTR_LONG)\n+DEF_FUNCTION_TYPE_4 (BT_FN_BOOL_UINT_ULLPTR_ULLPTR_ULLPTR,\n+\t\t     BT_BOOL, BT_UINT, BT_PTR_ULONGLONG, BT_PTR_ULONGLONG,\n+\t\t     BT_PTR_ULONGLONG)\n \n DEF_FUNCTION_TYPE_5 (BT_FN_INT_STRING_INT_SIZE_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_STRING, BT_INT, BT_SIZE, BT_CONST_STRING,\n@@ -497,6 +502,12 @@ DEF_FUNCTION_TYPE_5 (BT_FN_VOID_INT_SIZE_PTR_PTR_PTR,\n DEF_FUNCTION_TYPE_5 (BT_FN_VOID_OMPFN_PTR_UINT_UINT_UINT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT, BT_UINT,\n \t\t     BT_UINT)\n+DEF_FUNCTION_TYPE_5 (BT_FN_BOOL_UINT_LONGPTR_LONG_LONGPTR_LONGPTR,\n+\t\t     BT_BOOL, BT_UINT, BT_PTR_LONG, BT_LONG, BT_PTR_LONG,\n+\t\t     BT_PTR_LONG)\n+DEF_FUNCTION_TYPE_5 (BT_FN_BOOL_UINT_ULLPTR_ULL_ULLPTR_ULLPTR,\n+\t\t     BT_BOOL, BT_UINT, BT_PTR_ULONGLONG, BT_ULONGLONG,\n+\t\t     BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n \n DEF_FUNCTION_TYPE_6 (BT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_STRING, BT_SIZE, BT_INT, BT_SIZE,\n@@ -524,8 +535,6 @@ DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_VPTR_PTR_I16_BOOL_INT_INT,\n \t\t     BT_INT)\n DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_SIZE_VPTR_PTR_PTR_INT_INT, BT_BOOL, BT_SIZE,\n \t\t     BT_VOLATILE_PTR, BT_PTR, BT_PTR, BT_INT, BT_INT)\n-DEF_FUNCTION_TYPE_6 (BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR,\n-\t\t     BT_VOID, BT_INT, BT_PTR, BT_SIZE, BT_PTR, BT_PTR, BT_PTR)\n \n DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_UINT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n@@ -534,17 +543,31 @@ DEF_FUNCTION_TYPE_7 (BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n \t\t     BT_BOOL, BT_BOOL, BT_ULONGLONG, BT_ULONGLONG,\n \t\t     BT_ULONGLONG, BT_ULONGLONG,\n \t\t     BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n-DEF_FUNCTION_TYPE_7 (BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR,\n-\t\t     BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_PTR, BT_SIZE,\n-\t\t     BT_PTR, BT_PTR, BT_PTR)\n+DEF_FUNCTION_TYPE_7 (BT_FN_VOID_INT_SIZE_PTR_PTR_PTR_UINT_PTR,\n+\t\t     BT_VOID, BT_INT, BT_SIZE, BT_PTR, BT_PTR, BT_PTR, BT_UINT,\n+\t\t     BT_PTR)\n \n+DEF_FUNCTION_TYPE_8 (BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR,\n+\t\t     BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_SIZE, BT_PTR,\n+\t\t     BT_PTR, BT_PTR, BT_UINT, BT_PTR)\n DEF_FUNCTION_TYPE_8 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n \t\t     BT_LONG, BT_LONG, BT_LONG, BT_LONG, BT_UINT)\n-DEF_FUNCTION_TYPE_8 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR,\n+\n+DEF_FUNCTION_TYPE_9 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n \t\t     BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n-\t\t     BT_BOOL, BT_UINT, BT_PTR)\n+\t\t     BT_BOOL, BT_UINT, BT_PTR, BT_INT)\n+\n+DEF_FUNCTION_TYPE_11 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_LONG_LONG_LONG,\n+\t\t      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n+\t\t      BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n+\t\t      BT_UINT, BT_LONG, BT_INT, BT_LONG, BT_LONG, BT_LONG)\n+DEF_FUNCTION_TYPE_11 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_ULL_ULL_ULL,\n+\t\t      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n+\t\t      BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n+\t\t      BT_UINT, BT_LONG, BT_INT,\n+\t\t      BT_ULONGLONG, BT_ULONGLONG, BT_ULONGLONG)\n \n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_VOID_VAR, BT_VOID)\n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_INT_VAR, BT_INT)\n@@ -559,6 +582,10 @@ DEF_FUNCTION_TYPE_VAR_1 (BT_FN_INT_CONST_STRING_VAR,\n \t\t\t BT_INT, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_VAR_1 (BT_FN_UINT32_UINT32_VAR,\n \t\t\t BT_UINT32, BT_UINT32)\n+DEF_FUNCTION_TYPE_VAR_1 (BT_FN_VOID_LONG_VAR,\n+\t\t\t BT_VOID, BT_LONG)\n+DEF_FUNCTION_TYPE_VAR_1 (BT_FN_VOID_ULL_VAR,\n+\t\t\t BT_VOID, BT_ULONGLONG)\n \n DEF_FUNCTION_TYPE_VAR_2 (BT_FN_INT_FILEPTR_CONST_STRING_VAR,\n \t\t\t BT_INT, BT_FILEPTR, BT_CONST_STRING)"}, {"sha": "4521a275b36b5a910c52ce1bf84b21017e8f64a8", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1,3 +1,31 @@\n+2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* c-common.c (enum c_builtin_type): Define DEF_FUNCTION_TYPE_9,\n+\tDEF_FUNCTION_TYPE_10 and DEF_FUNCTION_TYPE_11.\n+\t(c_define_builtins): Likewise.\n+\t* c-common.h (enum c_omp_clause_split): Add\n+\tC_OMP_CLAUSE_SPLIT_TASKLOOP.\n+\t(c_finish_omp_critical, c_finish_omp_ordered): Add CLAUSES argument.\n+\t(c_finish_omp_for): Add ORIG_DECLV argument.\n+\t* c-cppbuiltin.c (c_cpp_builtins): Predefine _OPENMP as\n+\t201511 instead of 201307.\n+\t* c-omp.c (c_finish_omp_critical): Add CLAUSES argument, set\n+\tOMP_CRITICAL_CLAUSES to it.\n+\t(c_finish_omp_ordered): Add CLAUSES argument, set\n+\tOMP_ORDERED_CLAUSES to it.\n+\t(c_finish_omp_for): Add ORIG_DECLV argument, set OMP_FOR_ORIG_DECLS\n+\tto it if OMP_FOR.  Clear DECL_INITIAL on the IVs.\n+\t(c_omp_split_clauses): Handle OpenMP 4.5 combined/composite\n+\tconstructs and new OpenMP 4.5 clauses.  Clear\n+\tOMP_CLAUSE_SCHEDULE_SIMD if not combined with OMP_SIMD.  Add\n+\tverification code.\n+\t* c-pragma.c (omp_pragmas_simd): Add taskloop.\n+\t* c-pragma.h (enum pragma_kind): Add PRAGMA_OMP_TASKLOOP.\n+\t(enum pragma_omp_clause): Add\n+\tPRAGMA_OMP_CLAUSE_{DEFAULTMAP,GRAINSIZE,HINT,{IS,USE}_DEVICE_PTR}\n+\tand PRAGMA_OMP_CLAUSE_{LINK,NOGROUP,NUM_TASKS,PRIORITY,SIMD,THREADS}.\n+\n 2015-10-05  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* c-lex.c (interpret_float): Use real_equal instead of"}, {"sha": "1c75921d5426650b4c1b3139cece6ca55a32c929", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -5548,6 +5548,12 @@ enum c_builtin_type\n \t\t\t    ARG6, ARG7) NAME,\n #define DEF_FUNCTION_TYPE_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n \t\t\t    ARG6, ARG7, ARG8) NAME,\n+#define DEF_FUNCTION_TYPE_9(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8, ARG9) NAME,\n+#define DEF_FUNCTION_TYPE_10(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10) NAME,\n+#define DEF_FUNCTION_TYPE_11(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) NAME,\n #define DEF_FUNCTION_TYPE_VAR_0(NAME, RETURN) NAME,\n #define DEF_FUNCTION_TYPE_VAR_1(NAME, RETURN, ARG1) NAME,\n #define DEF_FUNCTION_TYPE_VAR_2(NAME, RETURN, ARG1, ARG2) NAME,\n@@ -5571,6 +5577,9 @@ enum c_builtin_type\n #undef DEF_FUNCTION_TYPE_6\n #undef DEF_FUNCTION_TYPE_7\n #undef DEF_FUNCTION_TYPE_8\n+#undef DEF_FUNCTION_TYPE_9\n+#undef DEF_FUNCTION_TYPE_10\n+#undef DEF_FUNCTION_TYPE_11\n #undef DEF_FUNCTION_TYPE_VAR_0\n #undef DEF_FUNCTION_TYPE_VAR_1\n #undef DEF_FUNCTION_TYPE_VAR_2\n@@ -5659,6 +5668,18 @@ c_define_builtins (tree va_list_ref_type_node, tree va_list_arg_type_node)\n \t\t\t    ARG6, ARG7, ARG8)\t\t\t\t\\\n   def_fn_type (ENUM, RETURN, 0, 8, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n \t       ARG7, ARG8);\n+#define DEF_FUNCTION_TYPE_9(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8, ARG9)\t\t\t\\\n+  def_fn_type (ENUM, RETURN, 0, 9, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n+\t       ARG7, ARG8, ARG9);\n+#define DEF_FUNCTION_TYPE_10(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10)\t\t \\\n+  def_fn_type (ENUM, RETURN, 0, 10, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t \\\n+\t       ARG7, ARG8, ARG9, ARG10);\n+#define DEF_FUNCTION_TYPE_11(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)\t \\\n+  def_fn_type (ENUM, RETURN, 0, 11, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t \\\n+\t       ARG7, ARG8, ARG9, ARG10, ARG11);\n #define DEF_FUNCTION_TYPE_VAR_0(ENUM, RETURN) \\\n   def_fn_type (ENUM, RETURN, 1, 0);\n #define DEF_FUNCTION_TYPE_VAR_1(ENUM, RETURN, ARG1) \\\n@@ -5692,6 +5713,9 @@ c_define_builtins (tree va_list_ref_type_node, tree va_list_arg_type_node)\n #undef DEF_FUNCTION_TYPE_6\n #undef DEF_FUNCTION_TYPE_7\n #undef DEF_FUNCTION_TYPE_8\n+#undef DEF_FUNCTION_TYPE_9\n+#undef DEF_FUNCTION_TYPE_10\n+#undef DEF_FUNCTION_TYPE_11\n #undef DEF_FUNCTION_TYPE_VAR_0\n #undef DEF_FUNCTION_TYPE_VAR_1\n #undef DEF_FUNCTION_TYPE_VAR_2"}, {"sha": "cf4448230d9fc875720e2921b5c960f434749890", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1252,21 +1252,22 @@ enum c_omp_clause_split\n   C_OMP_CLAUSE_SPLIT_FOR,\n   C_OMP_CLAUSE_SPLIT_SIMD,\n   C_OMP_CLAUSE_SPLIT_COUNT,\n-  C_OMP_CLAUSE_SPLIT_SECTIONS = C_OMP_CLAUSE_SPLIT_FOR\n+  C_OMP_CLAUSE_SPLIT_SECTIONS = C_OMP_CLAUSE_SPLIT_FOR,\n+  C_OMP_CLAUSE_SPLIT_TASKLOOP = C_OMP_CLAUSE_SPLIT_FOR\n };\n \n extern tree c_finish_omp_master (location_t, tree);\n extern tree c_finish_omp_taskgroup (location_t, tree);\n-extern tree c_finish_omp_critical (location_t, tree, tree);\n-extern tree c_finish_omp_ordered (location_t, tree);\n+extern tree c_finish_omp_critical (location_t, tree, tree, tree);\n+extern tree c_finish_omp_ordered (location_t, tree, tree);\n extern void c_finish_omp_barrier (location_t);\n extern tree c_finish_omp_atomic (location_t, enum tree_code, enum tree_code,\n \t\t\t\t tree, tree, tree, tree, tree, bool, bool);\n extern void c_finish_omp_flush (location_t);\n extern void c_finish_omp_taskwait (location_t);\n extern void c_finish_omp_taskyield (location_t);\n extern tree c_finish_omp_for (location_t, enum tree_code, tree, tree, tree,\n-\t\t\t      tree, tree, tree);\n+\t\t\t      tree, tree, tree, tree);\n extern tree c_finish_oacc_wait (location_t, tree, tree);\n extern void c_omp_split_clauses (location_t, enum tree_code, omp_clause_mask,\n \t\t\t\t tree, tree *);"}, {"sha": "35d246bb7b1729c15531dd334a88fa0a09bb733d", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1223,7 +1223,7 @@ c_cpp_builtins (cpp_reader *pfile)\n     cpp_define (pfile, \"_OPENACC=201306\");\n \n   if (flag_openmp)\n-    cpp_define (pfile, \"_OPENMP=201307\");\n+    cpp_define (pfile, \"_OPENMP=201511\");\n \n   for (i = 0; i < NUM_INT_N_ENTS; i ++)\n     if (int_n_enabled_p[i])"}, {"sha": "36f9b6627e59b98577e20c180112aa9e7c895726", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 196, "deletions": 49, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -100,12 +100,13 @@ c_finish_omp_taskgroup (location_t loc, tree stmt)\n    if it was omitted.  LOC is the location of the #pragma.  */\n \n tree\n-c_finish_omp_critical (location_t loc, tree body, tree name)\n+c_finish_omp_critical (location_t loc, tree body, tree name, tree clauses)\n {\n   tree stmt = make_node (OMP_CRITICAL);\n   TREE_TYPE (stmt) = void_type_node;\n   OMP_CRITICAL_BODY (stmt) = body;\n   OMP_CRITICAL_NAME (stmt) = name;\n+  OMP_CRITICAL_CLAUSES (stmt) = clauses;\n   SET_EXPR_LOCATION (stmt, loc);\n   return add_stmt (stmt);\n }\n@@ -114,9 +115,12 @@ c_finish_omp_critical (location_t loc, tree body, tree name)\n    that follows the pragma.  LOC is the location of the #pragma.  */\n \n tree\n-c_finish_omp_ordered (location_t loc, tree stmt)\n+c_finish_omp_ordered (location_t loc, tree clauses, tree stmt)\n {\n-  tree t = build1 (OMP_ORDERED, void_type_node, stmt);\n+  tree t = make_node (OMP_ORDERED);\n+  TREE_TYPE (t) = void_type_node;\n+  OMP_ORDERED_BODY (t) = stmt;\n+  OMP_ORDERED_CLAUSES (t) = clauses;\n   SET_EXPR_LOCATION (t, loc);\n   return add_stmt (t);\n }\n@@ -428,14 +432,19 @@ c_omp_for_incr_canonicalize_ptr (location_t loc, tree decl, tree incr)\n \n /* Validate and generate OMP_FOR.\n    DECLV is a vector of iteration variables, for each collapsed loop.\n+\n+   ORIG_DECLV, if non-NULL, is a vector with the original iteration\n+   variables (prior to any transformations, by say, C++ iterators).\n+\n    INITV, CONDV and INCRV are vectors containing initialization\n    expressions, controlling predicates and increment expressions.\n    BODY is the body of the loop and PRE_BODY statements that go before\n    the loop.  */\n \n tree\n c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n-\t\t  tree initv, tree condv, tree incrv, tree body, tree pre_body)\n+\t\t  tree orig_declv, tree initv, tree condv, tree incrv,\n+\t\t  tree body, tree pre_body)\n {\n   location_t elocus;\n   bool fail = false;\n@@ -480,6 +489,7 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t      init = integer_zero_node;\n \t      fail = true;\n \t    }\n+\t  DECL_INITIAL (decl) = NULL_TREE;\n \n \t  init = build_modify_expr (elocus, decl, NULL_TREE, NOP_EXPR,\n \t      \t\t\t    /* FIXME diagnostics: This should\n@@ -673,33 +683,42 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n       OMP_FOR_INCR (t) = incrv;\n       OMP_FOR_BODY (t) = body;\n       OMP_FOR_PRE_BODY (t) = pre_body;\n+      if (code == OMP_FOR)\n+\tOMP_FOR_ORIG_DECLS (t) = orig_declv;\n \n       SET_EXPR_LOCATION (t, locus);\n       return add_stmt (t);\n     }\n }\n \n-/* Right now we have 14 different combined constructs, this\n+/* Right now we have 21 different combined/composite constructs, this\n    function attempts to split or duplicate clauses for combined\n    constructs.  CODE is the innermost construct in the combined construct,\n    and MASK allows to determine which constructs are combined together,\n    as every construct has at least one clause that no other construct\n    has (except for OMP_SECTIONS, but that can be only combined with parallel).\n-   Combined constructs are:\n-   #pragma omp parallel for\n-   #pragma omp parallel sections\n-   #pragma omp parallel for simd\n-   #pragma omp for simd\n-   #pragma omp distribute simd\n+   Combined/composite constructs are:\n    #pragma omp distribute parallel for\n    #pragma omp distribute parallel for simd\n-   #pragma omp teams distribute\n-   #pragma omp teams distribute parallel for\n-   #pragma omp teams distribute parallel for simd\n+   #pragma omp distribute simd\n+   #pragma omp for simd\n+   #pragma omp parallel for\n+   #pragma omp parallel for simd\n+   #pragma omp parallel sections\n+   #pragma omp target parallel\n+   #pragma omp target parallel for\n+   #pragma omp target parallel for simd\n    #pragma omp target teams\n    #pragma omp target teams distribute\n    #pragma omp target teams distribute parallel for\n-   #pragma omp target teams distribute parallel for simd  */\n+   #pragma omp target teams distribute parallel for simd\n+   #pragma omp target teams distribute simd\n+   #pragma omp target simd\n+   #pragma omp taskloop simd\n+   #pragma omp teams distribute\n+   #pragma omp teams distribute parallel for\n+   #pragma omp teams distribute parallel for simd\n+   #pragma omp teams distribute simd  */\n \n void\n c_omp_split_clauses (location_t loc, enum tree_code code,\n@@ -738,6 +757,8 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t/* First the clauses that are unique to some constructs.  */\n \tcase OMP_CLAUSE_DEVICE:\n \tcase OMP_CLAUSE_MAP:\n+\tcase OMP_CLAUSE_IS_DEVICE_PTR:\n+\tcase OMP_CLAUSE_DEFAULTMAP:\n \t  s = C_OMP_CLAUSE_SPLIT_TARGET;\n \t  break;\n \tcase OMP_CLAUSE_NUM_TEAMS:\n@@ -753,25 +774,51 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t  s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n \t  break;\n \tcase OMP_CLAUSE_ORDERED:\n-\tcase OMP_CLAUSE_SCHEDULE:\n \tcase OMP_CLAUSE_NOWAIT:\n \t  s = C_OMP_CLAUSE_SPLIT_FOR;\n \t  break;\n+\tcase OMP_CLAUSE_SCHEDULE:\n+\t  s = C_OMP_CLAUSE_SPLIT_FOR;\n+\t  if (code != OMP_SIMD)\n+\t    OMP_CLAUSE_SCHEDULE_SIMD (clauses) = 0;\n+\t  break;\n \tcase OMP_CLAUSE_SAFELEN:\n-\tcase OMP_CLAUSE_LINEAR:\n+\tcase OMP_CLAUSE_SIMDLEN:\n \tcase OMP_CLAUSE_ALIGNED:\n \t  s = C_OMP_CLAUSE_SPLIT_SIMD;\n \t  break;\n-\t/* Duplicate this to all of distribute, for and simd.  */\n+\tcase OMP_CLAUSE_GRAINSIZE:\n+\tcase OMP_CLAUSE_NUM_TASKS:\n+\tcase OMP_CLAUSE_FINAL:\n+\tcase OMP_CLAUSE_UNTIED:\n+\tcase OMP_CLAUSE_MERGEABLE:\n+\tcase OMP_CLAUSE_NOGROUP:\n+\tcase OMP_CLAUSE_PRIORITY:\n+\t  s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n+\t  break;\n+\t/* Duplicate this to all of taskloop, distribute, for and simd.  */\n \tcase OMP_CLAUSE_COLLAPSE:\n \t  if (code == OMP_SIMD)\n \t    {\n-\t      c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n-\t\t\t\t    OMP_CLAUSE_COLLAPSE);\n-\t      OMP_CLAUSE_COLLAPSE_EXPR (c)\n-\t\t= OMP_CLAUSE_COLLAPSE_EXPR (clauses);\n-\t      OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_SIMD];\n-\t      cclauses[C_OMP_CLAUSE_SPLIT_SIMD] = c;\n+\t      if ((mask & ((OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE)\n+\t\t\t   | (OMP_CLAUSE_MASK_1\n+\t\t\t      << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)\n+\t\t\t   | (OMP_CLAUSE_MASK_1\n+\t\t\t      << PRAGMA_OMP_CLAUSE_NOGROUP))) != 0)\n+\t\t{\n+\t\t  c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t\tOMP_CLAUSE_COLLAPSE);\n+\t\t  OMP_CLAUSE_COLLAPSE_EXPR (c)\n+\t\t    = OMP_CLAUSE_COLLAPSE_EXPR (clauses);\n+\t\t  OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_SIMD];\n+\t\t  cclauses[C_OMP_CLAUSE_SPLIT_SIMD] = c;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* This must be #pragma omp target simd */\n+\t\t  s = C_OMP_CLAUSE_SPLIT_SIMD;\n+\t\t  break;\n+\t\t}\n \t    }\n \t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE)) != 0)\n \t    {\n@@ -789,10 +836,13 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t      else\n \t\ts = C_OMP_CLAUSE_SPLIT_FOR;\n \t    }\n+\t  else if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP))\n+\t\t   != 0)\n+\t    s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n \t  else\n \t    s = C_OMP_CLAUSE_SPLIT_DISTRIBUTE;\n \t  break;\n-\t/* Private clause is supported on all constructs but target,\n+\t/* Private clause is supported on all constructs,\n \t   it is enough to put it on the innermost one.  For\n \t   #pragma omp {for,sections} put it on parallel though,\n \t   as that's what we did for OpenMP 3.1.  */\n@@ -808,9 +858,28 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t    }\n \t  break;\n \t/* Firstprivate clause is supported on all constructs but\n-\t   target and simd.  Put it on the outermost of those and\n-\t   duplicate on parallel.  */\n+\t   simd.  Put it on the outermost of those and duplicate on teams\n+\t   and parallel.  */\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP))\n+\t      != 0)\n+\t    {\n+\t      if (code == OMP_SIMD\n+\t\t  && (mask & ((OMP_CLAUSE_MASK_1\n+\t\t\t       << PRAGMA_OMP_CLAUSE_NUM_THREADS)\n+\t\t\t      | (OMP_CLAUSE_MASK_1\n+\t\t\t\t << PRAGMA_OMP_CLAUSE_NUM_TEAMS))) == 0)\n+\t\t{\n+\t\t  /* This must be #pragma omp target simd.  */\n+\t\t  s = C_OMP_CLAUSE_SPLIT_TARGET;\n+\t\t  break;\n+\t\t}\n+\t      c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t    OMP_CLAUSE_FIRSTPRIVATE);\n+\t      OMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (clauses);\n+\t      OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_TARGET];\n+\t      cclauses[C_OMP_CLAUSE_SPLIT_TARGET] = c;\n+\t    }\n \t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS))\n \t      != 0)\n \t    {\n@@ -831,7 +900,9 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t\t}\n \t      else\n \t\t/* This must be\n-\t\t   #pragma omp parallel{, for{, simd}, sections}.  */\n+\t\t   #pragma omp parallel{, for{, simd}, sections}\n+\t\t   or\n+\t\t   #pragma omp target parallel.  */\n \t\ts = C_OMP_CLAUSE_SPLIT_PARALLEL;\n \t    }\n \t  else if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_TEAMS))\n@@ -851,7 +922,14 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t    {\n \t      /* This must be #pragma omp distribute simd.  */\n \t      gcc_assert (code == OMP_SIMD);\n-\t      s = C_OMP_CLAUSE_SPLIT_TEAMS;\n+\t      s = C_OMP_CLAUSE_SPLIT_DISTRIBUTE;\n+\t    }\n+\t  else if ((mask & (OMP_CLAUSE_MASK_1\n+\t\t\t    << PRAGMA_OMP_CLAUSE_NOGROUP)) != 0)\n+\t    {\n+\t      /* This must be #pragma omp taskloop simd.  */\n+\t      gcc_assert (code == OMP_SIMD);\n+\t      s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n \t    }\n \t  else\n \t    {\n@@ -889,17 +967,25 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t    }\n \t  s = C_OMP_CLAUSE_SPLIT_SIMD;\n \t  break;\n-\t/* Shared and default clauses are allowed on private and teams.  */\n+\t/* Shared and default clauses are allowed on parallel, teams and\n+\t   taskloop.  */\n \tcase OMP_CLAUSE_SHARED:\n \tcase OMP_CLAUSE_DEFAULT:\n-\t  if (code == OMP_TEAMS)\n+\t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP))\n+\t      != 0)\n \t    {\n-\t      s = C_OMP_CLAUSE_SPLIT_TEAMS;\n+\t      s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n \t      break;\n \t    }\n \t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_TEAMS))\n \t      != 0)\n \t    {\n+\t      if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS))\n+\t\t  == 0)\n+\t\t{\n+\t\t  s = C_OMP_CLAUSE_SPLIT_TEAMS;\n+\t\t  break;\n+\t\t}\n \t      c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n \t\t\t\t    OMP_CLAUSE_CODE (clauses));\n \t      if (OMP_CLAUSE_CODE (clauses) == OMP_CLAUSE_SHARED)\n@@ -909,28 +995,29 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t\t  = OMP_CLAUSE_DEFAULT_KIND (clauses);\n \t      OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];\n \t      cclauses[C_OMP_CLAUSE_SPLIT_TEAMS] = c;\n-\t      \n \t    }\n \t  s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n \t  break;\n \t/* Reduction is allowed on simd, for, parallel, sections and teams.\n \t   Duplicate it on all of them, but omit on for or sections if\n \t   parallel is present.  */\n \tcase OMP_CLAUSE_REDUCTION:\n-\t  if (code == OMP_SIMD)\n-\t    {\n-\t      c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n-\t\t\t\t    OMP_CLAUSE_REDUCTION);\n-\t      OMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (clauses);\n-\t      OMP_CLAUSE_REDUCTION_CODE (c)\n-\t\t= OMP_CLAUSE_REDUCTION_CODE (clauses);\n-\t      OMP_CLAUSE_REDUCTION_PLACEHOLDER (c)\n-\t\t= OMP_CLAUSE_REDUCTION_PLACEHOLDER (clauses);\n-\t      OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_SIMD];\n-\t      cclauses[C_OMP_CLAUSE_SPLIT_SIMD] = c;\n-\t    }\n \t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE)) != 0)\n \t    {\n+\t      if (code == OMP_SIMD)\n+\t\t{\n+\t\t  c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t\tOMP_CLAUSE_REDUCTION);\n+\t\t  OMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (clauses);\n+\t\t  OMP_CLAUSE_REDUCTION_CODE (c)\n+\t\t    = OMP_CLAUSE_REDUCTION_CODE (clauses);\n+\t\t  OMP_CLAUSE_REDUCTION_PLACEHOLDER (c)\n+\t\t    = OMP_CLAUSE_REDUCTION_PLACEHOLDER (clauses);\n+\t\t  OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (c)\n+\t\t    = OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (clauses);\n+\t\t  OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_SIMD];\n+\t\t  cclauses[C_OMP_CLAUSE_SPLIT_SIMD] = c;\n+\t\t}\n \t      if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_TEAMS))\n \t\t  != 0)\n \t\t{\n@@ -941,6 +1028,8 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t\t    = OMP_CLAUSE_REDUCTION_CODE (clauses);\n \t\t  OMP_CLAUSE_REDUCTION_PLACEHOLDER (c)\n \t\t    = OMP_CLAUSE_REDUCTION_PLACEHOLDER (clauses);\n+\t\t  OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (c)\n+\t\t    = OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (clauses);\n \t\t  OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL];\n \t\t  cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL] = c;\n \t\t  s = C_OMP_CLAUSE_SPLIT_TEAMS;\n@@ -951,25 +1040,83 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t      else\n \t\ts = C_OMP_CLAUSE_SPLIT_FOR;\n \t    }\n-\t  else if (code == OMP_SECTIONS)\n+\t  else if (code == OMP_SECTIONS || code == OMP_PARALLEL)\n \t    s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n+\t  else if (code == OMP_SIMD)\n+\t    s = C_OMP_CLAUSE_SPLIT_SIMD;\n \t  else\n \t    s = C_OMP_CLAUSE_SPLIT_TEAMS;\n \t  break;\n \tcase OMP_CLAUSE_IF:\n-\t  /* FIXME: This is currently being discussed.  */\n-\t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS))\n+\t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP))\n \t      != 0)\n-\t    s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n+\t    s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n+\t  else if ((mask & (OMP_CLAUSE_MASK_1\n+\t\t\t    << PRAGMA_OMP_CLAUSE_NUM_THREADS)) != 0)\n+\t    {\n+\t      if ((mask & (OMP_CLAUSE_MASK_1\n+\t\t\t   << PRAGMA_OMP_CLAUSE_MAP)) != 0)\n+\t\t{\n+\t\t  if (OMP_CLAUSE_IF_MODIFIER (clauses) == OMP_PARALLEL)\n+\t\t    s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n+\t\t  else if (OMP_CLAUSE_IF_MODIFIER (clauses) == OMP_TARGET)\n+\t\t    s = C_OMP_CLAUSE_SPLIT_TARGET;\n+\t\t  else if (OMP_CLAUSE_IF_MODIFIER (clauses) == ERROR_MARK)\n+\t\t    {\n+\t\t      c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t\t    OMP_CLAUSE_IF);\n+\t\t      OMP_CLAUSE_IF_MODIFIER (c)\n+\t\t\t= OMP_CLAUSE_IF_MODIFIER (clauses);\n+\t\t      OMP_CLAUSE_IF_EXPR (c) = OMP_CLAUSE_IF_EXPR (clauses);\n+\t\t      OMP_CLAUSE_CHAIN (c)\n+\t\t\t= cclauses[C_OMP_CLAUSE_SPLIT_TARGET];\n+\t\t      cclauses[C_OMP_CLAUSE_SPLIT_TARGET] = c;\n+\t\t      s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      error_at (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t\"expected %<parallel%> or %<target%> %<if%> \"\n+\t\t\t\t\"clause modifier\");\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\ts = C_OMP_CLAUSE_SPLIT_PARALLEL;\n+\t    }\n \t  else\n \t    s = C_OMP_CLAUSE_SPLIT_TARGET;\n \t  break;\n+\tcase OMP_CLAUSE_LINEAR:\n+\t  /* Linear clause is allowed on simd and for.  Put it on the\n+\t     innermost construct.  */\n+\t  if (code == OMP_SIMD)\n+\t    s = C_OMP_CLAUSE_SPLIT_SIMD;\n+\t  else\n+\t    s = C_OMP_CLAUSE_SPLIT_FOR;\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n       OMP_CLAUSE_CHAIN (clauses) = cclauses[s];\n       cclauses[s] = clauses;\n     }\n+#ifdef ENABLE_CHECKING\n+  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP)) == 0)\n+    gcc_assert (cclauses[C_OMP_CLAUSE_SPLIT_TARGET] == NULL_TREE);\n+  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_TEAMS)) == 0)\n+    gcc_assert (cclauses[C_OMP_CLAUSE_SPLIT_TEAMS] == NULL_TREE);\n+  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) == 0)\n+    gcc_assert (cclauses[C_OMP_CLAUSE_SPLIT_DISTRIBUTE] == NULL_TREE);\n+  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS)) == 0)\n+    gcc_assert (cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL] == NULL_TREE);\n+  if ((mask & ((OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE)\n+\t       | (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP))) == 0\n+      && code != OMP_SECTIONS)\n+    gcc_assert (cclauses[C_OMP_CLAUSE_SPLIT_FOR] == NULL_TREE);\n+  if (code != OMP_SIMD)\n+    gcc_assert (cclauses[C_OMP_CLAUSE_SPLIT_SIMD] == NULL_TREE);\n+#endif\n }\n \n "}, {"sha": "834a916fcb59bd4edd50bec959c2f6a6cec2eaf0", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1246,6 +1246,7 @@ static const struct omp_pragma_def omp_pragmas_simd[] = {\n   { \"parallel\", PRAGMA_OMP_PARALLEL },\n   { \"simd\", PRAGMA_OMP_SIMD },\n   { \"target\", PRAGMA_OMP_TARGET },\n+  { \"taskloop\", PRAGMA_OMP_TASKLOOP },\n   { \"teams\", PRAGMA_OMP_TEAMS },\n };\n "}, {"sha": "cec920f6f3aa723ba813c121e7876abf13b1e539", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -36,6 +36,7 @@ enum pragma_kind {\n   PRAGMA_OACC_PARALLEL,\n   PRAGMA_OACC_UPDATE,\n   PRAGMA_OACC_WAIT,\n+\n   PRAGMA_OMP_ATOMIC,\n   PRAGMA_OMP_BARRIER,\n   PRAGMA_OMP_CANCEL,\n@@ -56,6 +57,7 @@ enum pragma_kind {\n   PRAGMA_OMP_TARGET,\n   PRAGMA_OMP_TASK,\n   PRAGMA_OMP_TASKGROUP,\n+  PRAGMA_OMP_TASKLOOP,\n   PRAGMA_OMP_TASKWAIT,\n   PRAGMA_OMP_TASKYIELD,\n   PRAGMA_OMP_THREADPRIVATE,\n@@ -74,7 +76,7 @@ enum pragma_kind {\n };\n \n \n-/* All clauses defined by OpenACC 2.0, and OpenMP 2.5, 3.0, 3.1, and 4.0.\n+/* All clauses defined by OpenACC 2.0, and OpenMP 2.5, 3.0, 3.1, 4.0 and 4.5.\n    Used internally by both C and C++ parsers.  */\n enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_NONE = 0,\n@@ -84,39 +86,50 @@ enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_COPYIN,\n   PRAGMA_OMP_CLAUSE_COPYPRIVATE,\n   PRAGMA_OMP_CLAUSE_DEFAULT,\n+  PRAGMA_OMP_CLAUSE_DEFAULTMAP,\n   PRAGMA_OMP_CLAUSE_DEPEND,\n   PRAGMA_OMP_CLAUSE_DEVICE,\n   PRAGMA_OMP_CLAUSE_DIST_SCHEDULE,\n   PRAGMA_OMP_CLAUSE_FINAL,\n   PRAGMA_OMP_CLAUSE_FIRSTPRIVATE,\n   PRAGMA_OMP_CLAUSE_FOR,\n   PRAGMA_OMP_CLAUSE_FROM,\n+  PRAGMA_OMP_CLAUSE_GRAINSIZE,\n+  PRAGMA_OMP_CLAUSE_HINT,\n   PRAGMA_OMP_CLAUSE_IF,\n   PRAGMA_OMP_CLAUSE_INBRANCH,\n+  PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR,\n   PRAGMA_OMP_CLAUSE_LASTPRIVATE,\n   PRAGMA_OMP_CLAUSE_LINEAR,\n+  PRAGMA_OMP_CLAUSE_LINK,\n   PRAGMA_OMP_CLAUSE_MAP,\n   PRAGMA_OMP_CLAUSE_MERGEABLE,\n+  PRAGMA_OMP_CLAUSE_NOGROUP,\n   PRAGMA_OMP_CLAUSE_NOTINBRANCH,\n   PRAGMA_OMP_CLAUSE_NOWAIT,\n+  PRAGMA_OMP_CLAUSE_NUM_TASKS,\n   PRAGMA_OMP_CLAUSE_NUM_TEAMS,\n   PRAGMA_OMP_CLAUSE_NUM_THREADS,\n   PRAGMA_OMP_CLAUSE_ORDERED,\n   PRAGMA_OMP_CLAUSE_PARALLEL,\n+  PRAGMA_OMP_CLAUSE_PRIORITY,\n   PRAGMA_OMP_CLAUSE_PRIVATE,\n   PRAGMA_OMP_CLAUSE_PROC_BIND,\n   PRAGMA_OMP_CLAUSE_REDUCTION,\n   PRAGMA_OMP_CLAUSE_SAFELEN,\n   PRAGMA_OMP_CLAUSE_SCHEDULE,\n   PRAGMA_OMP_CLAUSE_SECTIONS,\n   PRAGMA_OMP_CLAUSE_SHARED,\n+  PRAGMA_OMP_CLAUSE_SIMD,\n   PRAGMA_OMP_CLAUSE_SIMDLEN,\n   PRAGMA_OMP_CLAUSE_TASKGROUP,\n   PRAGMA_OMP_CLAUSE_THREAD_LIMIT,\n+  PRAGMA_OMP_CLAUSE_THREADS,\n   PRAGMA_OMP_CLAUSE_TO,\n   PRAGMA_OMP_CLAUSE_UNIFORM,\n   PRAGMA_OMP_CLAUSE_UNTIED,\n-  \n+  PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR,\n+\n   /* Clauses for Cilk Plus SIMD-enabled function.  */\n   PRAGMA_CILK_CLAUSE_NOMASK,\n   PRAGMA_CILK_CLAUSE_MASK,"}, {"sha": "a54921a145f329c9ae684e6dba3ffb5fb6de9dca", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1,3 +1,85 @@\n+2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* c-parser.c (c_parser_pragma): Handle PRAGMA_OMP_ORDERED here.\n+\t(c_parser_omp_clause_name): Handle OpenMP 4.5 clauses.\n+\t(c_parser_omp_variable_list): Handle structure elements for\n+\tmap, to and from clauses.  Handle array sections in reduction\n+\tclause.  Formatting fixes.\n+\t(c_parser_omp_clause_if): Add IS_OMP argument, handle parsing of\n+\tif clause modifiers.\n+\t(c_parser_omp_clause_num_tasks, c_parser_omp_clause_grainsize,\n+\tc_parser_omp_clause_priority, c_parser_omp_clause_hint,\n+\tc_parser_omp_clause_defaultmap, c_parser_omp_clause_use_device_ptr,\n+\tc_parser_omp_clause_is_device_ptr): New functions.\n+\t(c_parser_omp_clause_ordered): Parse optional parameter.\n+\t(c_parser_omp_clause_reduction): Handle array reductions.\n+\t(c_parser_omp_clause_schedule): Parse optional simd modifier.\n+\t(c_parser_omp_clause_nogroup, c_parser_omp_clause_orderedkind): New\n+\tfunctions.\n+\t(c_parser_omp_clause_linear): Parse linear clause modifiers.\n+\t(c_parser_omp_clause_depend_sink): New function.\n+\t(c_parser_omp_clause_depend): Parse source/sink depend kinds.\n+\t(c_parser_omp_clause_map): Parse release/delete map kinds and\n+\toptional always modifier.\n+\t(c_parser_oacc_all_clauses): Adjust c_parser_omp_clause_if\n+\tand c_finish_omp_clauses callers.\n+\t(c_parser_omp_all_clauses): Likewise.  Parse OpenMP 4.5 clauses.\n+\tParse \"to\" as OMP_CLAUSE_TO_DECLARE if on declare target directive.\n+\t(c_parser_oacc_cache): Adjust c_finish_omp_clauses caller.\n+\t(OMP_CRITICAL_CLAUSE_MASK): Define.\n+\t(c_parser_omp_critical): Parse critical clauses.\n+\t(c_parser_omp_for_loop): Handle doacross loops, adjust\n+\tc_finish_omp_for and c_finish_omp_clauses callers.\n+\t(OMP_SIMD_CLAUSE_MASK): Add simdlen clause.\n+\t(c_parser_omp_simd): Allow ordered clause if it has no parameter.\n+\t(OMP_FOR_CLAUSE_MASK): Add linear clause.\n+\t(c_parser_omp_for): Disallow ordered clause when combined with\n+\tdistribute.  Disallow linear clause when combined with distribute\n+\tand not combined with simd.\n+\t(OMP_ORDERED_CLAUSE_MASK, OMP_ORDERED_DEPEND_CLAUSE_MASK): Define.\n+\t(c_parser_omp_ordered): Add CONTEXT argument, remove LOC argument,\n+\tparse clauses and if depend clause is found, don't parse a body.\n+\t(c_parser_omp_parallel): Disallow copyin clause on target parallel.\n+\tAllow target parallel without for after it.\n+\t(OMP_TASK_CLAUSE_MASK): Add priority clause.\n+\t(OMP_TARGET_DATA_CLAUSE_MASK): Add use_device_ptr clause.\n+\t(c_parser_omp_target_data): Diagnose no map clauses or clauses with\n+\tinvalid kinds.\n+\t(OMP_TARGET_UPDATE_CLAUSE_MASK): Add depend and nowait clauses.\n+\t(OMP_TARGET_ENTER_DATA_CLAUSE_MASK,\n+\tOMP_TARGET_EXIT_DATA_CLAUSE_MASK): Define.\n+\t(c_parser_omp_target_enter_data, c_parser_omp_target_exit_data): New\n+\tfunctions.\n+\t(OMP_TARGET_CLAUSE_MASK): Add depend, nowait, private, firstprivate,\n+\tdefaultmap and is_device_ptr clauses.\n+\t(c_parser_omp_target): Parse target parallel and target simd.  Set\n+\tOMP_TARGET_COMBINED on combined constructs.  Parse target enter data\n+\tand target exit data.  Diagnose invalid map kinds.\n+\t(OMP_DECLARE_TARGET_CLAUSE_MASK): Define.\n+\t(c_parser_omp_declare_target): Parse OpenMP 4.5 forms of this\n+\tconstruct.\n+\t(c_parser_omp_declare_reduction): Use STRIP_NOPS when checking for\n+\t&omp_priv.\n+\t(OMP_TASKLOOP_CLAUSE_MASK): Define.\n+\t(c_parser_omp_taskloop): New function.\n+\t(c_parser_omp_construct): Don't handle PRAGMA_OMP_ORDERED here,\n+\thandle PRAGMA_OMP_TASKLOOP.\n+\t(c_parser_cilk_for): Adjust c_finish_omp_clauses callers.\n+\t* c-tree.h (c_finish_omp_clauses): Add two new arguments.\n+\t* c-typeck.c (handle_omp_array_sections_1): Fix comment typo.\n+\tAdd IS_OMP argument, handle structure element bases, diagnose\n+\tbitfields, pass IS_OMP recursively, diagnose known zero length\n+\tarray sections in depend clauses, handle array sections in reduction\n+\tclause, diagnose negative length even for pointers.\n+\t(handle_omp_array_sections): Add IS_OMP argument, use auto_vec for\n+\ttypes, pass IS_OMP down to handle_omp_array_sections_1, handle\n+\tarray sections in reduction clause, set\n+\tOMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION if map could be zero\n+\tlength array section, use GOMP_MAP_FIRSTPRIVATE_POINTER for IS_OMP.\n+\t(c_finish_omp_clauses): Add IS_OMP and DECLARE_SIMD arguments.\n+\tHandle new OpenMP 4.5 clauses and new restrictions for the old ones.\n+\n 2015-10-06  Marek Polacek  <polacek@redhat.com>\n \n \t* c-parser.c (c_parser_statement_after_labels): Use"}, {"sha": "704ebc6bdc6e8a2c3fc677097f771288714ed078", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 1412, "deletions": 101, "changes": 1513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1255,6 +1255,7 @@ static bool c_parser_pragma (c_parser *, enum pragma_context);\n static bool c_parser_omp_target (c_parser *, enum pragma_context);\n static void c_parser_omp_end_declare_target (c_parser *);\n static void c_parser_omp_declare (c_parser *, enum pragma_context);\n+static bool c_parser_omp_ordered (c_parser *, enum pragma_context);\n \n /* These Objective-C parser functions are only ever called when\n    compiling Objective-C.  */\n@@ -9804,6 +9805,10 @@ c_parser_pragma (c_parser *parser, enum pragma_context context)\n     case PRAGMA_OMP_DECLARE_REDUCTION:\n       c_parser_omp_declare (parser, context);\n       return false;\n+\n+    case PRAGMA_OMP_ORDERED:\n+      return c_parser_omp_ordered (parser, context);\n+\n     case PRAGMA_IVDEP:\n       c_parser_consume_pragma (parser);\n       c_parser_skip_to_pragma_eol (parser);\n@@ -9969,7 +9974,9 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OACC_CLAUSE_CREATE;\n \t  break;\n \tcase 'd':\n-\t  if (!strcmp (\"delete\", p))\n+\t  if (!strcmp (\"defaultmap\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_DEFAULTMAP;\n+\t  else if (!strcmp (\"delete\", p))\n \t    result = PRAGMA_OACC_CLAUSE_DELETE;\n \t  else if (!strcmp (\"depend\", p))\n \t    result = PRAGMA_OMP_CLAUSE_DEPEND;\n@@ -9991,20 +9998,28 @@ c_parser_omp_clause_name (c_parser *parser)\n \tcase 'g':\n \t  if (!strcmp (\"gang\", p))\n \t    result = PRAGMA_OACC_CLAUSE_GANG;\n+\t  else if (!strcmp (\"grainsize\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_GRAINSIZE;\n \t  break;\n \tcase 'h':\n-\t  if (!strcmp (\"host\", p))\n+\t  if (!strcmp (\"hint\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_HINT;\n+\t  else if (!strcmp (\"host\", p))\n \t    result = PRAGMA_OACC_CLAUSE_HOST;\n \t  break;\n \tcase 'i':\n \t  if (!strcmp (\"inbranch\", p))\n \t    result = PRAGMA_OMP_CLAUSE_INBRANCH;\n+\t  else if (!strcmp (\"is_device_ptr\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR;\n \t  break;\n \tcase 'l':\n \t  if (!strcmp (\"lastprivate\", p))\n \t    result = PRAGMA_OMP_CLAUSE_LASTPRIVATE;\n \t  else if (!strcmp (\"linear\", p))\n \t    result = PRAGMA_OMP_CLAUSE_LINEAR;\n+\t  else if (!strcmp (\"link\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_LINK;\n \t  break;\n \tcase 'm':\n \t  if (!strcmp (\"map\", p))\n@@ -10015,12 +10030,16 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_CILK_CLAUSE_MASK;\n \t  break;\n \tcase 'n':\n-\t  if (!strcmp (\"notinbranch\", p))\n+\t  if (!strcmp (\"nogroup\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_NOGROUP;\n+\t  else if (!strcmp (\"notinbranch\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NOTINBRANCH;\n \t  else if (!strcmp (\"nowait\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NOWAIT;\n \t  else if (!strcmp (\"num_gangs\", p))\n \t    result = PRAGMA_OACC_CLAUSE_NUM_GANGS;\n+\t  else if (!strcmp (\"num_tasks\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_NUM_TASKS;\n \t  else if (!strcmp (\"num_teams\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NUM_TEAMS;\n \t  else if (!strcmp (\"num_threads\", p))\n@@ -10051,6 +10070,8 @@ c_parser_omp_clause_name (c_parser *parser)\n \t  else if (!strcmp (\"present_or_create\", p)\n \t\t   || !strcmp (\"pcreate\", p))\n \t    result = PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE;\n+\t  else if (!strcmp (\"priority\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_PRIORITY;\n \t  else if (!strcmp (\"private\", p))\n \t    result = PRAGMA_OMP_CLAUSE_PRIVATE;\n \t  else if (!strcmp (\"proc_bind\", p))\n@@ -10071,6 +10092,8 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OACC_CLAUSE_SEQ;\n \t  else if (!strcmp (\"shared\", p))\n \t    result = PRAGMA_OMP_CLAUSE_SHARED;\n+\t  else if (!strcmp (\"simd\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_SIMD;\n \t  else if (!strcmp (\"simdlen\", p))\n \t    result = PRAGMA_OMP_CLAUSE_SIMDLEN;\n \t  else if (!strcmp (\"self\", p))\n@@ -10081,6 +10104,8 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_TASKGROUP;\n \t  else if (!strcmp (\"thread_limit\", p))\n \t    result = PRAGMA_OMP_CLAUSE_THREAD_LIMIT;\n+\t  else if (!strcmp (\"threads\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_THREADS;\n \t  else if (!strcmp (\"to\", p))\n \t    result = PRAGMA_OMP_CLAUSE_TO;\n \t  break;\n@@ -10089,6 +10114,8 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_UNIFORM;\n \t  else if (!strcmp (\"untied\", p))\n \t    result = PRAGMA_OMP_CLAUSE_UNTIED;\n+\t  else if (!strcmp (\"use_device_ptr\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR;\n \t  break;\n \tcase 'v':\n \t  if (!strcmp (\"vector\", p))\n@@ -10228,11 +10255,27 @@ c_parser_omp_variable_list (c_parser *parser,\n \t\t  t = error_mark_node;\n \t\t  break;\n \t\t}\n-\t      /* FALL THROUGH.  */\n+\t      /* FALLTHROUGH  */\n \t    case OMP_CLAUSE_MAP:\n \t    case OMP_CLAUSE_FROM:\n \t    case OMP_CLAUSE_TO:\n+\t      while (c_parser_next_token_is (parser, CPP_DOT))\n+\t\t{\n+\t\t  location_t op_loc = c_parser_peek_token (parser)->location;\n+\t\t  c_parser_consume_token (parser);\n+\t\t  if (!c_parser_next_token_is (parser, CPP_NAME))\n+\t\t    {\n+\t\t      c_parser_error (parser, \"expected identifier\");\n+\t\t      t = error_mark_node;\n+\t\t      break;\n+\t\t    }\n+\t\t  tree ident = c_parser_peek_token (parser)->value;\n+\t\t  c_parser_consume_token (parser);\n+\t\t  t = build_component_ref (op_loc, t, ident);\n+\t\t}\n+\t      /* FALLTHROUGH  */\n \t    case OMP_CLAUSE_DEPEND:\n+\t    case OMP_CLAUSE_REDUCTION:\n \t      while (c_parser_next_token_is (parser, CPP_OPEN_SQUARE))\n \t\t{\n \t\t  tree low_bound = NULL_TREE, length = NULL_TREE;\n@@ -10274,15 +10317,15 @@ c_parser_omp_variable_list (c_parser *parser,\n \t\t\t  && !TREE_READONLY (low_bound))\n \t\t\t{\n \t\t\t  error_at (clause_loc,\n-\t\t\t\t\t\"%qD is not a constant\", low_bound);\n+\t\t\t\t    \"%qD is not a constant\", low_bound);\n \t\t\t  t = error_mark_node;\n \t\t\t}\n \n \t\t      if (TREE_CODE (length) != INTEGER_CST\n \t\t\t  && !TREE_READONLY (length))\n \t\t\t{\n \t\t\t  error_at (clause_loc,\n-\t\t\t\t\t\"%qD is not a constant\", length);\n+\t\t\t\t    \"%qD is not a constant\", length);\n \t\t\t  t = error_mark_node;\n \t\t\t}\n \t\t    }\n@@ -10588,28 +10631,149 @@ c_parser_omp_clause_final (c_parser *parser, tree list)\n }\n \n /* OpenACC, OpenMP 2.5:\n-   if ( expression ) */\n+   if ( expression )\n+\n+   OpenMP 4.5:\n+   if ( directive-name-modifier : expression )\n+\n+   directive-name-modifier:\n+     parallel | task | taskloop | target data | target | target update\n+     | target enter data | target exit data  */\n \n static tree\n-c_parser_omp_clause_if (c_parser *parser, tree list)\n+c_parser_omp_clause_if (c_parser *parser, tree list, bool is_omp)\n {\n-  location_t loc = c_parser_peek_token (parser)->location;\n-  if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n-    {\n-      tree t = c_parser_paren_condition (parser);\n-      tree c;\n+  location_t location = c_parser_peek_token (parser)->location;\n+  enum tree_code if_modifier = ERROR_MARK;\n \n-      check_no_duplicate_clause (list, OMP_CLAUSE_IF, \"if\");\n+  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    return list;\n \n-      c = build_omp_clause (loc, OMP_CLAUSE_IF);\n-      OMP_CLAUSE_IF_EXPR (c) = t;\n-      OMP_CLAUSE_CHAIN (c) = list;\n-      list = c;\n+  if (is_omp && c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      int n = 2;\n+      if (strcmp (p, \"parallel\") == 0)\n+\tif_modifier = OMP_PARALLEL;\n+      else if (strcmp (p, \"task\") == 0)\n+\tif_modifier = OMP_TASK;\n+      else if (strcmp (p, \"taskloop\") == 0)\n+\tif_modifier = OMP_TASKLOOP;\n+      else if (strcmp (p, \"target\") == 0)\n+\t{\n+\t  if_modifier = OMP_TARGET;\n+\t  if (c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n+\t    {\n+\t      p = IDENTIFIER_POINTER (c_parser_peek_2nd_token (parser)->value);\n+\t      if (strcmp (\"data\", p) == 0)\n+\t\tif_modifier = OMP_TARGET_DATA;\n+\t      else if (strcmp (\"update\", p) == 0)\n+\t\tif_modifier = OMP_TARGET_UPDATE;\n+\t      else if (strcmp (\"enter\", p) == 0)\n+\t\tif_modifier = OMP_TARGET_ENTER_DATA;\n+\t      else if (strcmp (\"exit\", p) == 0)\n+\t\tif_modifier = OMP_TARGET_EXIT_DATA;\n+\t      if (if_modifier != OMP_TARGET)\n+\t\t{\n+\t\t  n = 3;\n+\t\t  c_parser_consume_token (parser);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  location_t loc = c_parser_peek_2nd_token (parser)->location;\n+\t\t  error_at (loc, \"expected %<data%>, %<update%>, %<enter%> \"\n+\t\t\t\t \"or %<exit%>\");\n+\t\t  if_modifier = ERROR_MARK;\n+\t\t}\n+\t      if (if_modifier == OMP_TARGET_ENTER_DATA\n+\t\t  || if_modifier == OMP_TARGET_EXIT_DATA)\n+\t\t{\n+\t\t  if (c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n+\t\t    {\n+\t\t      p = IDENTIFIER_POINTER\n+\t\t\t\t(c_parser_peek_2nd_token (parser)->value);\n+\t\t      if (strcmp (\"data\", p) == 0)\n+\t\t\tn = 4;\n+\t\t    }\n+\t\t  if (n == 4)\n+\t\t    c_parser_consume_token (parser);\n+\t\t  else\n+\t\t    {\n+\t\t      location_t loc\n+\t\t\t= c_parser_peek_2nd_token (parser)->location;\n+\t\t      error_at (loc, \"expected %<data%>\");\n+\t\t      if_modifier = ERROR_MARK;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      if (if_modifier != ERROR_MARK)\n+\t{\n+\t  if (c_parser_peek_2nd_token (parser)->type == CPP_COLON)\n+\t    {\n+\t      c_parser_consume_token (parser);\n+\t      c_parser_consume_token (parser);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (n > 2)\n+\t\t{\n+\t\t  location_t loc = c_parser_peek_2nd_token (parser)->location;\n+\t\t  error_at (loc, \"expected %<:%>\");\n+\t\t}\n+\t      if_modifier = ERROR_MARK;\n+\t    }\n+\t}\n     }\n-  else\n-    c_parser_error (parser, \"expected %<(%>\");\n \n-  return list;\n+  tree t = c_parser_condition (parser), c;\n+  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\n+  for (c = list; c ; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IF)\n+      {\n+\tif (if_modifier != ERROR_MARK\n+\t    && OMP_CLAUSE_IF_MODIFIER (c) == if_modifier)\n+\t  {\n+\t    const char *p = NULL;\n+\t    switch (if_modifier)\n+\t      {\n+\t      case OMP_PARALLEL: p = \"parallel\"; break;\n+\t      case OMP_TASK: p = \"task\"; break;\n+\t      case OMP_TASKLOOP: p = \"taskloop\"; break;\n+\t      case OMP_TARGET_DATA: p = \"target data\"; break;\n+\t      case OMP_TARGET: p = \"target\"; break;\n+\t      case OMP_TARGET_UPDATE: p = \"target update\"; break;\n+\t      case OMP_TARGET_ENTER_DATA: p = \"enter data\"; break;\n+\t      case OMP_TARGET_EXIT_DATA: p = \"exit data\"; break;\n+\t      default: gcc_unreachable ();\n+\t      }\n+\t    error_at (location, \"too many %<if%> clauses with %qs modifier\",\n+\t\t      p);\n+\t    return list;\n+\t  }\n+\telse if (OMP_CLAUSE_IF_MODIFIER (c) == if_modifier)\n+\t  {\n+\t    if (!is_omp)\n+\t      error_at (location, \"too many %<if%> clauses\");\n+\t    else\n+\t      error_at (location, \"too many %<if%> clauses without modifier\");\n+\t    return list;\n+\t  }\n+\telse if (if_modifier == ERROR_MARK\n+\t\t || OMP_CLAUSE_IF_MODIFIER (c) == ERROR_MARK)\n+\t  {\n+\t    error_at (location, \"if any %<if%> clause has modifier, then all \"\n+\t\t\t\t\"%<if%> clauses have to use modifier\");\n+\t    return list;\n+\t  }\n+      }\n+\n+  c = build_omp_clause (location, OMP_CLAUSE_IF);\n+  OMP_CLAUSE_IF_MODIFIER (c) = if_modifier;\n+  OMP_CLAUSE_IF_EXPR (c) = t;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n }\n \n /* OpenMP 2.5:\n@@ -10743,6 +10907,239 @@ c_parser_omp_clause_num_threads (c_parser *parser, tree list)\n   return list;\n }\n \n+/* OpenMP 4.5:\n+   num_tasks ( expression ) */\n+\n+static tree\n+c_parser_omp_clause_num_tasks (c_parser *parser, tree list)\n+{\n+  location_t num_tasks_loc = c_parser_peek_token (parser)->location;\n+  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    {\n+      location_t expr_loc = c_parser_peek_token (parser)->location;\n+      tree c, t = c_parser_expression (parser).value;\n+      mark_exp_read (t);\n+      t = c_fully_fold (t, false, NULL);\n+\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t{\n+\t  c_parser_error (parser, \"expected integer expression\");\n+\t  return list;\n+\t}\n+\n+      /* Attempt to statically determine when the number isn't positive.  */\n+      c = fold_build2_loc (expr_loc, LE_EXPR, boolean_type_node, t,\n+\t\t\t   build_int_cst (TREE_TYPE (t), 0));\n+      if (CAN_HAVE_LOCATION_P (c))\n+\tSET_EXPR_LOCATION (c, expr_loc);\n+      if (c == boolean_true_node)\n+\t{\n+\t  warning_at (expr_loc, 0, \"%<num_tasks%> value must be positive\");\n+\t  t = integer_one_node;\n+\t}\n+\n+      check_no_duplicate_clause (list, OMP_CLAUSE_NUM_TASKS, \"num_tasks\");\n+\n+      c = build_omp_clause (num_tasks_loc, OMP_CLAUSE_NUM_TASKS);\n+      OMP_CLAUSE_NUM_TASKS_EXPR (c) = t;\n+      OMP_CLAUSE_CHAIN (c) = list;\n+      list = c;\n+    }\n+\n+  return list;\n+}\n+\n+/* OpenMP 4.5:\n+   grainsize ( expression ) */\n+\n+static tree\n+c_parser_omp_clause_grainsize (c_parser *parser, tree list)\n+{\n+  location_t grainsize_loc = c_parser_peek_token (parser)->location;\n+  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    {\n+      location_t expr_loc = c_parser_peek_token (parser)->location;\n+      tree c, t = c_parser_expression (parser).value;\n+      mark_exp_read (t);\n+      t = c_fully_fold (t, false, NULL);\n+\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t{\n+\t  c_parser_error (parser, \"expected integer expression\");\n+\t  return list;\n+\t}\n+\n+      /* Attempt to statically determine when the number isn't positive.  */\n+      c = fold_build2_loc (expr_loc, LE_EXPR, boolean_type_node, t,\n+\t\t\t   build_int_cst (TREE_TYPE (t), 0));\n+      if (CAN_HAVE_LOCATION_P (c))\n+\tSET_EXPR_LOCATION (c, expr_loc);\n+      if (c == boolean_true_node)\n+\t{\n+\t  warning_at (expr_loc, 0, \"%<grainsize%> value must be positive\");\n+\t  t = integer_one_node;\n+\t}\n+\n+      check_no_duplicate_clause (list, OMP_CLAUSE_GRAINSIZE, \"grainsize\");\n+\n+      c = build_omp_clause (grainsize_loc, OMP_CLAUSE_GRAINSIZE);\n+      OMP_CLAUSE_GRAINSIZE_EXPR (c) = t;\n+      OMP_CLAUSE_CHAIN (c) = list;\n+      list = c;\n+    }\n+\n+  return list;\n+}\n+\n+/* OpenMP 4.5:\n+   priority ( expression ) */\n+\n+static tree\n+c_parser_omp_clause_priority (c_parser *parser, tree list)\n+{\n+  location_t priority_loc = c_parser_peek_token (parser)->location;\n+  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    {\n+      location_t expr_loc = c_parser_peek_token (parser)->location;\n+      tree c, t = c_parser_expression (parser).value;\n+      mark_exp_read (t);\n+      t = c_fully_fold (t, false, NULL);\n+\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t{\n+\t  c_parser_error (parser, \"expected integer expression\");\n+\t  return list;\n+\t}\n+\n+      /* Attempt to statically determine when the number isn't\n+\t non-negative.  */\n+      c = fold_build2_loc (expr_loc, LT_EXPR, boolean_type_node, t,\n+\t\t\t   build_int_cst (TREE_TYPE (t), 0));\n+      if (CAN_HAVE_LOCATION_P (c))\n+\tSET_EXPR_LOCATION (c, expr_loc);\n+      if (c == boolean_true_node)\n+\t{\n+\t  warning_at (expr_loc, 0, \"%<priority%> value must be non-negative\");\n+\t  t = integer_one_node;\n+\t}\n+\n+      check_no_duplicate_clause (list, OMP_CLAUSE_PRIORITY, \"priority\");\n+\n+      c = build_omp_clause (priority_loc, OMP_CLAUSE_PRIORITY);\n+      OMP_CLAUSE_PRIORITY_EXPR (c) = t;\n+      OMP_CLAUSE_CHAIN (c) = list;\n+      list = c;\n+    }\n+\n+  return list;\n+}\n+\n+/* OpenMP 4.5:\n+   hint ( expression ) */\n+\n+static tree\n+c_parser_omp_clause_hint (c_parser *parser, tree list)\n+{\n+  location_t hint_loc = c_parser_peek_token (parser)->location;\n+  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    {\n+      tree c, t = c_parser_expression (parser).value;\n+      mark_exp_read (t);\n+      t = c_fully_fold (t, false, NULL);\n+\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t{\n+\t  c_parser_error (parser, \"expected integer expression\");\n+\t  return list;\n+\t}\n+\n+      check_no_duplicate_clause (list, OMP_CLAUSE_HINT, \"hint\");\n+\n+      c = build_omp_clause (hint_loc, OMP_CLAUSE_HINT);\n+      OMP_CLAUSE_HINT_EXPR (c) = t;\n+      OMP_CLAUSE_CHAIN (c) = list;\n+      list = c;\n+    }\n+\n+  return list;\n+}\n+\n+/* OpenMP 4.5:\n+   defaultmap ( tofrom : scalar ) */\n+\n+static tree\n+c_parser_omp_clause_defaultmap (c_parser *parser, tree list)\n+{\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  tree c;\n+  const char *p;\n+\n+  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    return list;\n+  if (!c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      c_parser_error (parser, \"expected %<tofrom%>\");\n+      goto out_err;\n+    }\n+  p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+  if (strcmp (p, \"tofrom\") != 0)\n+    {\n+      c_parser_error (parser, \"expected %<tofrom%>\");\n+      goto out_err;\n+    }\n+  c_parser_consume_token (parser);\n+  if (!c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n+    goto out_err;\n+  if (!c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      c_parser_error (parser, \"expected %<scalar%>\");\n+      goto out_err;\n+    }\n+  p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+  if (strcmp (p, \"scalar\") != 0)\n+    {\n+      c_parser_error (parser, \"expected %<scalar%>\");\n+      goto out_err;\n+    }\n+  c_parser_consume_token (parser);\n+  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  check_no_duplicate_clause (list, OMP_CLAUSE_DEFAULTMAP, \"defaultmap\");\n+  c = build_omp_clause (loc, OMP_CLAUSE_DEFAULTMAP);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+\n+ out_err:\n+  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  return list;\n+}\n+\n+/* OpenMP 4.5:\n+   use_device_ptr ( variable-list ) */\n+\n+static tree\n+c_parser_omp_clause_use_device_ptr (c_parser *parser, tree list)\n+{\n+  return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_USE_DEVICE_PTR,\n+\t\t\t\t       list);\n+}\n+\n+/* OpenMP 4.5:\n+   is_device_ptr ( variable-list ) */\n+\n+static tree\n+c_parser_omp_clause_is_device_ptr (c_parser *parser, tree list)\n+{\n+  return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_IS_DEVICE_PTR, list);\n+}\n+\n /* OpenACC:\n    num_workers ( expression ) */\n \n@@ -10837,19 +11234,44 @@ c_parser_oacc_clause_wait (c_parser *parser, tree list)\n }\n \n /* OpenMP 2.5:\n-   ordered */\n+   ordered\n+\n+   OpenMP 4.5:\n+   ordered ( constant-expression ) */\n \n static tree\n c_parser_omp_clause_ordered (c_parser *parser, tree list)\n {\n-  tree c;\n-\n   check_no_duplicate_clause (list, OMP_CLAUSE_ORDERED, \"ordered\");\n \n-  c = build_omp_clause (c_parser_peek_token (parser)->location,\n-\t\t\tOMP_CLAUSE_ORDERED);\n+  tree c, num = NULL_TREE;\n+  HOST_WIDE_INT n;\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n+    {\n+      c_parser_consume_token (parser);\n+      num = c_parser_expr_no_commas (parser, NULL).value;\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+    }\n+  if (num == error_mark_node)\n+    return list;\n+  if (num)\n+    {\n+      mark_exp_read (num);\n+      num = c_fully_fold (num, false, NULL);\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (num))\n+\t  || !tree_fits_shwi_p (num)\n+\t  || (n = tree_to_shwi (num)) <= 0\n+\t  || (int) n != n)\n+\t{\n+\t  error_at (loc, \"ordered argument needs positive \"\n+\t\t\t \"constant integer expression\");\n+\t  return list;\n+\t}\n+    }\n+  c = build_omp_clause (loc, OMP_CLAUSE_ORDERED);\n+  OMP_CLAUSE_ORDERED_EXPR (c) = num;\n   OMP_CLAUSE_CHAIN (c) = list;\n-\n   return c;\n }\n \n@@ -10948,7 +11370,27 @@ c_parser_omp_clause_reduction (c_parser *parser, tree list)\n \t\t\t\t\t   OMP_CLAUSE_REDUCTION, list);\n \t  for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n \t    {\n-\t      tree type = TREE_TYPE (OMP_CLAUSE_DECL (c));\n+\t      tree d = OMP_CLAUSE_DECL (c), type;\n+\t      if (TREE_CODE (d) != TREE_LIST)\n+\t\ttype = TREE_TYPE (d);\n+\t      else\n+\t\t{\n+\t\t  int cnt = 0;\n+\t\t  tree t;\n+\t\t  for (t = d; TREE_CODE (t) == TREE_LIST; t = TREE_CHAIN (t))\n+\t\t    cnt++;\n+\t\t  type = TREE_TYPE (t);\n+\t\t  while (cnt > 0)\n+\t\t    {\n+\t\t      if (TREE_CODE (type) != POINTER_TYPE\n+\t\t\t  && TREE_CODE (type) != ARRAY_TYPE)\n+\t\t\tbreak;\n+\t\t      type = TREE_TYPE (type);\n+\t\t      cnt--;\n+\t\t    }\n+\t\t}\n+\t      while (TREE_CODE (type) == ARRAY_TYPE)\n+\t\ttype = TREE_TYPE (type);\n \t      OMP_CLAUSE_REDUCTION_CODE (c) = code;\n \t      if (code == ERROR_MARK\n \t\t  || !(INTEGRAL_TYPE_P (type)\n@@ -10972,7 +11414,13 @@ c_parser_omp_clause_reduction (c_parser *parser, tree list)\n \n    schedule-kind:\n      static | dynamic | guided | runtime | auto\n-*/\n+\n+   OpenMP 4.5:\n+   schedule ( schedule-modifier : schedule-kind )\n+   schedule ( schedule-modifier : schedule-kind , expression )\n+\n+   schedule-modifier:\n+     simd  */\n \n static tree\n c_parser_omp_clause_schedule (c_parser *parser, tree list)\n@@ -10985,6 +11433,19 @@ c_parser_omp_clause_schedule (c_parser *parser, tree list)\n \n   c = build_omp_clause (loc, OMP_CLAUSE_SCHEDULE);\n \n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      tree kind = c_parser_peek_token (parser)->value;\n+      const char *p = IDENTIFIER_POINTER (kind);\n+      if (strcmp (\"simd\", p) == 0\n+\t  && c_parser_peek_2nd_token (parser)->type == CPP_COLON)\n+\t{\n+\t  OMP_CLAUSE_SCHEDULE_SIMD (c) = 1;\n+\t  c_parser_consume_token (parser);\n+\t  c_parser_consume_token (parser);\n+\t}\n+    }\n+\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n       tree kind = c_parser_peek_token (parser)->value;\n@@ -11163,6 +11624,33 @@ c_parser_omp_clause_cancelkind (c_parser *parser ATTRIBUTE_UNUSED,\n   return c;\n }\n \n+/* OpenMP 4.5:\n+   nogroup */\n+\n+static tree\n+c_parser_omp_clause_nogroup (c_parser *parser ATTRIBUTE_UNUSED, tree list)\n+{\n+  check_no_duplicate_clause (list, OMP_CLAUSE_NOGROUP, \"nogroup\");\n+  tree c = build_omp_clause (c_parser_peek_token (parser)->location,\n+\t\t\t     OMP_CLAUSE_NOGROUP);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+}\n+\n+/* OpenMP 4.5:\n+   simd\n+   threads */\n+\n+static tree\n+c_parser_omp_clause_orderedkind (c_parser *parser ATTRIBUTE_UNUSED,\n+\t\t\t\t enum omp_clause_code code, tree list)\n+{\n+  check_no_duplicate_clause (list, code, omp_clause_code_name[code]);\n+  tree c = build_omp_clause (c_parser_peek_token (parser)->location, code);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+}\n+\n /* OpenMP 4.0:\n    num_teams ( expression ) */\n \n@@ -11291,20 +11779,44 @@ c_parser_omp_clause_aligned (c_parser *parser, tree list)\n \n /* OpenMP 4.0:\n    linear ( variable-list )\n-   linear ( variable-list : expression ) */\n+   linear ( variable-list : expression )\n+\n+   OpenMP 4.5:\n+   linear ( modifier ( variable-list ) )\n+   linear ( modifier ( variable-list ) : expression ) */\n \n static tree\n c_parser_omp_clause_linear (c_parser *parser, tree list, bool is_cilk_simd_fn)\n {\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n   tree nl, c, step;\n+  enum omp_clause_linear_kind kind = OMP_CLAUSE_LINEAR_DEFAULT;\n \n   if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     return list;\n \n+  if (!is_cilk_simd_fn\n+      && c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      c_token *tok = c_parser_peek_token (parser);\n+      const char *p = IDENTIFIER_POINTER (tok->value);\n+      if (strcmp (\"val\", p) == 0)\n+\tkind = OMP_CLAUSE_LINEAR_VAL;\n+      if (c_parser_peek_2nd_token (parser)->type != CPP_OPEN_PAREN)\n+\tkind = OMP_CLAUSE_LINEAR_DEFAULT;\n+      if (kind != OMP_CLAUSE_LINEAR_DEFAULT)\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  c_parser_consume_token (parser);\n+\t}\n+    }\n+\n   nl = c_parser_omp_variable_list (parser, clause_loc,\n \t\t\t\t   OMP_CLAUSE_LINEAR, list);\n \n+  if (kind != OMP_CLAUSE_LINEAR_DEFAULT)\n+    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\n   if (c_parser_next_token_is (parser, CPP_COLON))\n     {\n       c_parser_consume_token (parser);\n@@ -11330,6 +11842,7 @@ c_parser_omp_clause_linear (c_parser *parser, tree list, bool is_cilk_simd_fn)\n   for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n     {\n       OMP_CLAUSE_LINEAR_STEP (c) = step;\n+      OMP_CLAUSE_LINEAR_KIND (c) = kind;\n     }\n \n   c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n@@ -11408,11 +11921,98 @@ c_parser_omp_clause_simdlen (c_parser *parser, tree list)\n   return c;\n }\n \n+/* OpenMP 4.5:\n+   vec:\n+     identifier [+/- integer]\n+     vec , identifier [+/- integer]\n+*/\n+\n+static tree\n+c_parser_omp_clause_depend_sink (c_parser *parser, location_t clause_loc,\n+\t\t\t\t tree list)\n+{\n+  tree vec = NULL;\n+  if (c_parser_next_token_is_not (parser, CPP_NAME)\n+      || c_parser_peek_token (parser)->id_kind != C_ID_ID)\n+    {\n+      c_parser_error (parser, \"expected identifier\");\n+      return list;\n+    }\n+\n+  while (c_parser_next_token_is (parser, CPP_NAME)\n+\t && c_parser_peek_token (parser)->id_kind == C_ID_ID)\n+    {\n+      tree t = lookup_name (c_parser_peek_token (parser)->value);\n+      tree addend = NULL;\n+\n+      if (t == NULL_TREE)\n+\t{\n+\t  undeclared_variable (c_parser_peek_token (parser)->location,\n+\t\t\t       c_parser_peek_token (parser)->value);\n+\t  t = error_mark_node;\n+\t}\n+\n+      c_parser_consume_token (parser);\n+\n+      bool neg = false;\n+      if (c_parser_next_token_is (parser, CPP_MINUS))\n+\tneg = true;\n+      else if (!c_parser_next_token_is (parser, CPP_PLUS))\n+\t{\n+\t  addend = integer_zero_node;\n+\t  neg = false;\n+\t  goto add_to_vector;\n+\t}\n+      c_parser_consume_token (parser);\n+\n+      if (c_parser_next_token_is_not (parser, CPP_NUMBER))\n+\t{\n+\t  c_parser_error (parser, \"expected integer\");\n+\t  return list;\n+\t}\n+\n+      addend = c_parser_peek_token (parser)->value;\n+      if (TREE_CODE (addend) != INTEGER_CST)\n+\t{\n+\t  c_parser_error (parser, \"expected integer\");\n+\t  return list;\n+\t}\n+      c_parser_consume_token (parser);\n+\n+    add_to_vector:\n+      if (t != error_mark_node)\n+\t{\n+\t  vec = tree_cons (addend, t, vec);\n+\t  if (neg)\n+\t    OMP_CLAUSE_DEPEND_SINK_NEGATIVE (vec) = 1;\n+\t}\n+\n+      if (c_parser_next_token_is_not (parser, CPP_COMMA))\n+\tbreak;\n+\n+      c_parser_consume_token (parser);\n+    }\n+\n+  if (vec == NULL_TREE)\n+    return list;\n+\n+  tree u = build_omp_clause (clause_loc, OMP_CLAUSE_DEPEND);\n+  OMP_CLAUSE_DEPEND_KIND (u) = OMP_CLAUSE_DEPEND_SINK;\n+  OMP_CLAUSE_DECL (u) = nreverse (vec);\n+  OMP_CLAUSE_CHAIN (u) = list;\n+  return u;\n+}\n+\n /* OpenMP 4.0:\n    depend ( depend-kind: variable-list )\n \n    depend-kind:\n-     in | out | inout  */\n+     in | out | inout\n+\n+   OpenMP 4.5:\n+   depend ( source )\n+\n+   depend ( sink  : vec )  */\n \n static tree\n c_parser_omp_clause_depend (c_parser *parser, tree list)\n@@ -11433,21 +12033,41 @@ c_parser_omp_clause_depend (c_parser *parser, tree list)\n \tkind = OMP_CLAUSE_DEPEND_INOUT;\n       else if (strcmp (\"out\", p) == 0)\n \tkind = OMP_CLAUSE_DEPEND_OUT;\n+      else if (strcmp (\"source\", p) == 0)\n+\tkind = OMP_CLAUSE_DEPEND_SOURCE;\n+      else if (strcmp (\"sink\", p) == 0)\n+\tkind = OMP_CLAUSE_DEPEND_SINK;\n       else\n \tgoto invalid_kind;\n     }\n   else\n     goto invalid_kind;\n \n   c_parser_consume_token (parser);\n+\n+  if (kind == OMP_CLAUSE_DEPEND_SOURCE)\n+    {\n+      c = build_omp_clause (clause_loc, OMP_CLAUSE_DEPEND);\n+      OMP_CLAUSE_DEPEND_KIND (c) = kind;\n+      OMP_CLAUSE_DECL (c) = NULL_TREE;\n+      OMP_CLAUSE_CHAIN (c) = list;\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      return c;\n+    }\n+\n   if (!c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n     goto resync_fail;\n \n-  nl = c_parser_omp_variable_list (parser, clause_loc,\n-\t\t\t\t   OMP_CLAUSE_DEPEND, list);\n+  if (kind == OMP_CLAUSE_DEPEND_SINK)\n+    nl = c_parser_omp_clause_depend_sink (parser, clause_loc, list);\n+  else\n+    {\n+      nl = c_parser_omp_variable_list (parser, clause_loc,\n+\t\t\t\t       OMP_CLAUSE_DEPEND, list);\n \n-  for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n-    OMP_CLAUSE_DEPEND_KIND (c) = kind;\n+      for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n+\tOMP_CLAUSE_DEPEND_KIND (c) = kind;\n+    }\n \n   c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n   return nl;\n@@ -11464,30 +12084,77 @@ c_parser_omp_clause_depend (c_parser *parser, tree list)\n    map ( variable-list )\n \n    map-kind:\n-     alloc | to | from | tofrom  */\n+     alloc | to | from | tofrom\n+\n+   OpenMP 4.5:\n+   map-kind:\n+     alloc | to | from | tofrom | release | delete\n+\n+   map ( always [,] map-kind: variable-list ) */\n \n static tree\n c_parser_omp_clause_map (c_parser *parser, tree list)\n {\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n   enum gomp_map_kind kind = GOMP_MAP_TOFROM;\n+  int always = 0;\n+  enum c_id_kind always_id_kind = C_ID_NONE;\n+  location_t always_loc = UNKNOWN_LOCATION;\n+  tree always_id = NULL_TREE;\n   tree nl, c;\n \n   if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     return list;\n \n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      c_token *tok = c_parser_peek_token (parser);\n+      const char *p = IDENTIFIER_POINTER (tok->value);\n+      always_id_kind = tok->id_kind;\n+      always_loc = tok->location;\n+      always_id = tok->value;\n+      if (strcmp (\"always\", p) == 0)\n+\t{\n+\t  c_token *sectok = c_parser_peek_2nd_token (parser);\n+\t  if (sectok->type == CPP_COMMA)\n+\t    {\n+\t      c_parser_consume_token (parser);\n+\t      c_parser_consume_token (parser);\n+\t      always = 2;\n+\t    }\n+\t  else if (sectok->type == CPP_NAME)\n+\t    {\n+\t      p = IDENTIFIER_POINTER (sectok->value);\n+\t      if (strcmp (\"alloc\", p) == 0\n+\t\t  || strcmp (\"to\", p) == 0\n+\t\t  || strcmp (\"from\", p) == 0\n+\t\t  || strcmp (\"tofrom\", p) == 0\n+\t\t  || strcmp (\"release\", p) == 0\n+\t\t  || strcmp (\"delete\", p) == 0)\n+\t\t{\n+\t\t  c_parser_consume_token (parser);\n+\t\t  always = 1;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n   if (c_parser_next_token_is (parser, CPP_NAME)\n       && c_parser_peek_2nd_token (parser)->type == CPP_COLON)\n     {\n       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n       if (strcmp (\"alloc\", p) == 0)\n \tkind = GOMP_MAP_ALLOC;\n       else if (strcmp (\"to\", p) == 0)\n-\tkind = GOMP_MAP_TO;\n+\tkind = always ? GOMP_MAP_ALWAYS_TO : GOMP_MAP_TO;\n       else if (strcmp (\"from\", p) == 0)\n-\tkind = GOMP_MAP_FROM;\n+\tkind = always ? GOMP_MAP_ALWAYS_FROM : GOMP_MAP_FROM;\n       else if (strcmp (\"tofrom\", p) == 0)\n-\tkind = GOMP_MAP_TOFROM;\n+\tkind = always ? GOMP_MAP_ALWAYS_TOFROM : GOMP_MAP_TOFROM;\n+      else if (strcmp (\"release\", p) == 0)\n+\tkind = GOMP_MAP_RELEASE;\n+      else if (strcmp (\"delete\", p) == 0)\n+\tkind = GOMP_MAP_DELETE;\n       else\n \t{\n \t  c_parser_error (parser, \"invalid map kind\");\n@@ -11498,6 +12165,35 @@ c_parser_omp_clause_map (c_parser *parser, tree list)\n       c_parser_consume_token (parser);\n       c_parser_consume_token (parser);\n     }\n+  else if (always)\n+    {\n+      if (always_id_kind != C_ID_ID)\n+\t{\n+\t  c_parser_error (parser, \"expected identifier\");\n+\t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\t  return list;\n+\t}\n+\n+      tree t = lookup_name (always_id);\n+      if (t == NULL_TREE)\n+\t{\n+\t  undeclared_variable (always_loc, always_id);\n+\t  t = error_mark_node;\n+\t}\n+      if (t != error_mark_node)\n+\t{\n+\t  tree u = build_omp_clause (clause_loc, OMP_CLAUSE_MAP);\n+\t  OMP_CLAUSE_DECL (u) = t;\n+\t  OMP_CLAUSE_CHAIN (u) = list;\n+\t  OMP_CLAUSE_SET_MAP_KIND (u, kind);\n+\t  list = u;\n+\t}\n+      if (always == 1)\n+\t{\n+\t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\t  return list;\n+\t}\n+    }\n \n   nl = c_parser_omp_variable_list (parser, clause_loc, OMP_CLAUSE_MAP, list);\n \n@@ -11735,7 +12431,7 @@ c_parser_oacc_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  c_name = \"host\";\n \t  break;\n \tcase PRAGMA_OACC_CLAUSE_IF:\n-\t  clauses = c_parser_omp_clause_if (parser, clauses);\n+\t  clauses = c_parser_omp_clause_if (parser, clauses, false);\n \t  c_name = \"if\";\n \t  break;\n \tcase PRAGMA_OACC_CLAUSE_NUM_GANGS:\n@@ -11806,7 +12502,7 @@ c_parser_oacc_all_clauses (c_parser *parser, omp_clause_mask mask,\n   c_parser_skip_to_pragma_eol (parser);\n \n   if (finish_p)\n-    return c_finish_omp_clauses (clauses);\n+    return c_finish_omp_clauses (clauses, false);\n \n   return clauses;\n }\n@@ -11860,8 +12556,20 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  clauses = c_parser_omp_clause_final (parser, clauses);\n \t  c_name = \"final\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_GRAINSIZE:\n+\t  clauses = c_parser_omp_clause_grainsize (parser, clauses);\n+\t  c_name = \"grainsize\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_HINT:\n+\t  clauses = c_parser_omp_clause_hint (parser, clauses);\n+\t  c_name = \"hint\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_DEFAULTMAP:\n+\t  clauses = c_parser_omp_clause_defaultmap (parser, clauses);\n+\t  c_name = \"defaultmap\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_IF:\n-\t  clauses = c_parser_omp_clause_if (parser, clauses);\n+\t  clauses = c_parser_omp_clause_if (parser, clauses, true);\n \t  c_name = \"if\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_LASTPRIVATE:\n@@ -11876,6 +12584,10 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  clauses = c_parser_omp_clause_nowait (parser, clauses);\n \t  c_name = \"nowait\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_NUM_TASKS:\n+\t  clauses = c_parser_omp_clause_num_tasks (parser, clauses);\n+\t  c_name = \"num_tasks\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_NUM_THREADS:\n \t  clauses = c_parser_omp_clause_num_threads (parser, clauses);\n \t  c_name = \"num_threads\";\n@@ -11884,6 +12596,10 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  clauses = c_parser_omp_clause_ordered (parser, clauses);\n \t  c_name = \"ordered\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_PRIORITY:\n+\t  clauses = c_parser_omp_clause_priority (parser, clauses);\n+\t  c_name = \"priority\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_PRIVATE:\n \t  clauses = c_parser_omp_clause_private (parser, clauses);\n \t  c_name = \"private\";\n@@ -11953,8 +12669,18 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  if (!first)\n \t    goto clause_not_first;\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_LINK:\n+\t  clauses\n+\t    = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_LINK, clauses);\n+\t  c_name = \"link\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_TO:\n-\t  clauses = c_parser_omp_clause_to (parser, clauses);\n+\t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LINK)) != 0)\n+\t    clauses\n+\t      = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_TO_DECLARE,\n+\t\t\t\t\t      clauses);\n+\t  else\n+\t    clauses = c_parser_omp_clause_to (parser, clauses);\n \t  c_name = \"to\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_FROM:\n@@ -11991,6 +12717,14 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  clauses = c_parser_omp_clause_map (parser, clauses);\n \t  c_name = \"map\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR:\n+\t  clauses = c_parser_omp_clause_use_device_ptr (parser, clauses);\n+\t  c_name = \"use_device_ptr\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR:\n+\t  clauses = c_parser_omp_clause_is_device_ptr (parser, clauses);\n+\t  c_name = \"is_device_ptr\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_DEVICE:\n \t  clauses = c_parser_omp_clause_device (parser, clauses);\n \t  c_name = \"device\";\n@@ -12015,6 +12749,22 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  clauses = c_parser_omp_clause_simdlen (parser, clauses);\n \t  c_name = \"simdlen\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_NOGROUP:\n+\t  clauses = c_parser_omp_clause_nogroup (parser, clauses);\n+\t  c_name = \"nogroup\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_THREADS:\n+\t  clauses\n+\t    = c_parser_omp_clause_orderedkind (parser, OMP_CLAUSE_THREADS,\n+\t\t\t\t\t       clauses);\n+\t  c_name = \"threads\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_SIMD:\n+\t  clauses\n+\t    = c_parser_omp_clause_orderedkind (parser, OMP_CLAUSE_SIMD,\n+\t\t\t\t\t       clauses);\n+\t  c_name = \"simd\";\n+\t  break;\n \tdefault:\n \t  c_parser_error (parser, \"expected %<#pragma omp%> clause\");\n \t  goto saw_error;\n@@ -12035,7 +12785,11 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n   c_parser_skip_to_pragma_eol (parser);\n \n   if (finish_p)\n-    return c_finish_omp_clauses (clauses);\n+    {\n+      if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_UNIFORM)) != 0)\n+\treturn c_finish_omp_clauses (clauses, true, true);\n+      return c_finish_omp_clauses (clauses, true);\n+    }\n \n   return clauses;\n }\n@@ -12068,7 +12822,7 @@ c_parser_oacc_cache (location_t loc, c_parser *parser)\n   tree stmt, clauses;\n \n   clauses = c_parser_omp_var_list_parens (parser, OMP_CLAUSE__CACHE_, NULL);\n-  clauses = c_finish_omp_clauses (clauses);\n+  clauses = c_finish_omp_clauses (clauses, false);\n \n   c_parser_skip_to_pragma_eol (parser);\n \n@@ -12852,12 +13606,18 @@ c_parser_omp_barrier (c_parser *parser)\n    # pragma omp critical [(name)] new-line\n      structured-block\n \n+   OpenMP 4.5:\n+   # pragma omp critical [(name) [hint(expression)]] new-line\n+\n   LOC is the location of the #pragma itself.  */\n \n+#define OMP_CRITICAL_CLAUSE_MASK\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_HINT) )\n+\n static tree\n c_parser_omp_critical (location_t loc, c_parser *parser)\n {\n-  tree stmt, name = NULL;\n+  tree stmt, name = NULL_TREE, clauses = NULL_TREE;\n \n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n     {\n@@ -12870,13 +13630,20 @@ c_parser_omp_critical (location_t loc, c_parser *parser)\n \t}\n       else\n \tc_parser_error (parser, \"expected identifier\");\n+\n+      clauses = c_parser_omp_all_clauses (parser,\n+\t\t\t\t\t  OMP_CRITICAL_CLAUSE_MASK,\n+\t\t\t\t\t  \"#pragma omp critical\");\n+    }\n+  else\n+    {\n+      if (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n+\tc_parser_error (parser, \"expected %<(%> or end of line\");\n+      c_parser_skip_to_pragma_eol (parser);\n     }\n-  else if (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n-    c_parser_error (parser, \"expected %<(%> or end of line\");\n-  c_parser_skip_to_pragma_eol (parser);\n \n   stmt = c_parser_omp_structured_block (parser);\n-  return c_finish_omp_critical (loc, stmt, name);\n+  return c_finish_omp_critical (loc, stmt, name, clauses);\n }\n \n /* OpenMP 2.5:\n@@ -12912,21 +13679,51 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n   tree decl, cond, incr, save_break, save_cont, body, init, stmt, cl;\n   tree declv, condv, incrv, initv, ret = NULL_TREE;\n   tree pre_body = NULL_TREE, this_pre_body;\n+  tree ordered_cl = NULL_TREE;\n   bool fail = false, open_brace_parsed = false;\n-  int i, collapse = 1, nbraces = 0;\n+  int i, collapse = 1, ordered = 0, count, nbraces = 0;\n   location_t for_loc;\n   vec<tree, va_gc> *for_block = make_tree_vector ();\n \n   for (cl = clauses; cl; cl = OMP_CLAUSE_CHAIN (cl))\n     if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_COLLAPSE)\n       collapse = tree_to_shwi (OMP_CLAUSE_COLLAPSE_EXPR (cl));\n+    else if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_ORDERED\n+\t     && OMP_CLAUSE_ORDERED_EXPR (cl))\n+      {\n+\tordered_cl = cl;\n+\tordered = tree_to_shwi (OMP_CLAUSE_ORDERED_EXPR (cl));\n+      }\n+\n+  if (ordered && ordered < collapse)\n+    {\n+      error_at (OMP_CLAUSE_LOCATION (ordered_cl),\n+\t\t\"%<ordered%> clause parameter is less than %<collapse%>\");\n+      OMP_CLAUSE_ORDERED_EXPR (ordered_cl)\n+\t= build_int_cst (NULL_TREE, collapse);\n+      ordered = collapse;\n+    }\n+  if (ordered)\n+    {\n+      for (tree *pc = &clauses; *pc; )\n+\tif (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_LINEAR)\n+\t  {\n+\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n+\t\t      \"%<linear%> clause may not be specified together \"\n+\t\t      \"with %<ordered%> clause with a parameter\");\n+\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n+\t  }\n+\telse\n+\t  pc = &OMP_CLAUSE_CHAIN (*pc);\n+    }\n \n-  gcc_assert (collapse >= 1);\n+  gcc_assert (collapse >= 1 && ordered >= 0);\n+  count = ordered ? ordered : collapse;\n \n-  declv = make_tree_vec (collapse);\n-  initv = make_tree_vec (collapse);\n-  condv = make_tree_vec (collapse);\n-  incrv = make_tree_vec (collapse);\n+  declv = make_tree_vec (count);\n+  initv = make_tree_vec (count);\n+  condv = make_tree_vec (count);\n+  incrv = make_tree_vec (count);\n \n   if (code != CILK_FOR\n       && !c_parser_next_token_is_keyword (parser, RID_FOR))\n@@ -12943,7 +13740,7 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n   for_loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_token (parser);\n \n-  for (i = 0; i < collapse; i++)\n+  for (i = 0; i < count; i++)\n     {\n       int bracecount = 0;\n \n@@ -13067,7 +13864,7 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n \t}\n \n     parse_next:\n-      if (i == collapse - 1)\n+      if (i == count - 1)\n \tbreak;\n \n       /* FIXME: OpenMP 3.0 draft isn't very clear on what exactly is allowed\n@@ -13098,7 +13895,7 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n \t\t  bracecount--;\n \t\t}\n \t      fail = true;\n-\t      collapse = 0;\n+\t      count = 0;\n \t      break;\n \t    }\n \t}\n@@ -13165,7 +13962,7 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n      an error from the initialization parsing.  */\n   if (!fail)\n     {\n-      stmt = c_finish_omp_for (loc, code, declv, initv, condv,\n+      stmt = c_finish_omp_for (loc, code, declv, NULL, initv, condv,\n \t\t\t       incrv, body, pre_body);\n       if (stmt)\n \t{\n@@ -13179,10 +13976,10 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n \t\t  c = &OMP_CLAUSE_CHAIN (*c);\n \t\telse\n \t\t  {\n-\t\t    for (i = 0; i < collapse; i++)\n+\t\t    for (i = 0; i < count; i++)\n \t\t      if (TREE_VEC_ELT (declv, i) == OMP_CLAUSE_DECL (*c))\n \t\t\tbreak;\n-\t\t    if (i == collapse)\n+\t\t    if (i == count)\n \t\t      c = &OMP_CLAUSE_CHAIN (*c);\n \t\t    else if (OMP_CLAUSE_CODE (*c) == OMP_CLAUSE_FIRSTPRIVATE)\n \t\t      {\n@@ -13238,7 +14035,7 @@ omp_split_clauses (location_t loc, enum tree_code code,\n   c_omp_split_clauses (loc, code, mask, clauses, cclauses);\n   for (i = 0; i < C_OMP_CLAUSE_SPLIT_COUNT; i++)\n     if (cclauses[i])\n-      cclauses[i] = c_finish_omp_clauses (cclauses[i]);\n+      cclauses[i] = c_finish_omp_clauses (cclauses[i], true);\n }\n \n /* OpenMP 4.0:\n@@ -13250,6 +14047,7 @@ omp_split_clauses (location_t loc, enum tree_code code,\n \n #define OMP_SIMD_CLAUSE_MASK\t\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SAFELEN)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SIMDLEN)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LINEAR)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALIGNED)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n@@ -13265,13 +14063,21 @@ c_parser_omp_simd (location_t loc, c_parser *parser,\n \n   strcat (p_name, \" simd\");\n   mask |= OMP_SIMD_CLAUSE_MASK;\n-  mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ORDERED);\n \n   clauses = c_parser_omp_all_clauses (parser, mask, p_name, cclauses == NULL);\n   if (cclauses)\n     {\n       omp_split_clauses (loc, OMP_SIMD, mask, clauses, cclauses);\n       clauses = cclauses[C_OMP_CLAUSE_SPLIT_SIMD];\n+      tree c = find_omp_clause (cclauses[C_OMP_CLAUSE_SPLIT_FOR],\n+\t\t\t\tOMP_CLAUSE_ORDERED);\n+      if (c && OMP_CLAUSE_ORDERED_EXPR (c))\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"%<ordered%> clause with parameter may not be specified \"\n+\t\t    \"on %qs construct\", p_name);\n+\t  OMP_CLAUSE_ORDERED_EXPR (c) = NULL_TREE;\n+\t}\n     }\n \n   block = c_begin_compound_stmt (true);\n@@ -13297,6 +14103,7 @@ c_parser_omp_simd (location_t loc, c_parser *parser,\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LINEAR)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ORDERED)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE)\t\\\n@@ -13313,6 +14120,9 @@ c_parser_omp_for (location_t loc, c_parser *parser,\n   mask |= OMP_FOR_CLAUSE_MASK;\n   if (cclauses)\n     mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT);\n+  /* Composite distribute parallel for{, simd} disallows ordered clause.  */\n+  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) != 0)\n+    mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ORDERED);\n \n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n@@ -13347,6 +14157,10 @@ c_parser_omp_for (location_t loc, c_parser *parser,\n       return NULL_TREE;\n     }\n \n+  /* Composite distribute parallel for disallows linear clause.  */\n+  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) != 0)\n+    mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LINEAR);\n+\n   clauses = c_parser_omp_all_clauses (parser, mask, p_name, cclauses == NULL);\n   if (cclauses)\n     {\n@@ -13380,14 +14194,61 @@ c_parser_omp_master (location_t loc, c_parser *parser)\n    # pragma omp ordered new-line\n      structured-block\n \n-   LOC is the location of the #pragma itself.\n-*/\n+   OpenMP 4.5:\n+   # pragma omp ordered ordered-clauses new-line\n+     structured-block\n+\n+   # pragma omp ordered depend-clauses new-line  */\n+\n+#define OMP_ORDERED_CLAUSE_MASK\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_THREADS)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SIMD))\n+\n+#define OMP_ORDERED_DEPEND_CLAUSE_MASK\t\t\t\t\\\n+\t(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\n+\n+static bool\n+c_parser_omp_ordered (c_parser *parser, enum pragma_context context)\n+{\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  c_parser_consume_pragma (parser);\n+\n+  if (context != pragma_stmt && context != pragma_compound)\n+    {\n+      c_parser_error (parser, \"expected declaration specifiers\");\n+      c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n+      return false;\n+    }\n+\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\n+      if (!strcmp (\"depend\", p))\n+\t{\n+\t  if (context == pragma_stmt)\n+\t    {\n+\t      error_at (loc,\n+\t\t\t\"%<#pragma omp ordered%> with %<depend> clause may \"\n+\t\t\t\"only be used in compound statements\");\n+\t      c_parser_skip_to_pragma_eol (parser);\n+\t      return false;\n+\t    }\n+\n+\t  tree clauses\n+\t    = c_parser_omp_all_clauses (parser,\n+\t\t\t\t\tOMP_ORDERED_DEPEND_CLAUSE_MASK,\n+\t\t\t\t\t\"#pragma omp ordered\");\n+\t  c_finish_omp_ordered (loc, clauses, NULL_TREE);\n+\t  return false;\n+\t}\n+    }\n \n-static tree\n-c_parser_omp_ordered (location_t loc, c_parser *parser)\n-{\n-  c_parser_skip_to_pragma_eol (parser);\n-  return c_finish_omp_ordered (loc, c_parser_omp_structured_block (parser));\n+  tree clauses = c_parser_omp_all_clauses (parser, OMP_ORDERED_CLAUSE_MASK,\n+\t\t\t\t\t   \"#pragma omp ordered\");\n+  c_finish_omp_ordered (loc, clauses,\n+\t\t\tc_parser_omp_structured_block (parser));\n+  return true;\n }\n \n /* OpenMP 2.5:\n@@ -13540,6 +14401,10 @@ c_parser_omp_parallel (location_t loc, c_parser *parser,\n \n   strcat (p_name, \" parallel\");\n   mask |= OMP_PARALLEL_CLAUSE_MASK;\n+  /* #pragma omp target parallel{, for, for simd} disallow copyin clause.  */\n+  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP)) != 0\n+      && (mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) == 0)\n+    mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COPYIN);\n \n   if (c_parser_next_token_is_keyword (parser, RID_FOR))\n     {\n@@ -13560,7 +14425,11 @@ c_parser_omp_parallel (location_t loc, c_parser *parser,\n       OMP_PARALLEL_COMBINED (stmt) = 1;\n       return stmt;\n     }\n-  else if (cclauses)\n+  /* When combined with distribute, parallel has to be followed by for.\n+     #pragma omp target parallel is allowed though.  */\n+  else if (cclauses\n+\t   && (mask & (OMP_CLAUSE_MASK_1\n+\t\t       << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) != 0)\n     {\n       error_at (loc, \"expected %<for%> after %qs\", p_name);\n       c_parser_skip_to_pragma_eol (parser);\n@@ -13571,7 +14440,7 @@ c_parser_omp_parallel (location_t loc, c_parser *parser,\n       c_parser_skip_to_pragma_eol (parser, false);\n       return NULL_TREE;\n     }\n-  else if (c_parser_next_token_is (parser, CPP_NAME))\n+  else if (cclauses == NULL && c_parser_next_token_is (parser, CPP_NAME))\n     {\n       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n       if (strcmp (p, \"sections\") == 0)\n@@ -13592,6 +14461,11 @@ c_parser_omp_parallel (location_t loc, c_parser *parser,\n     }\n \n   clauses = c_parser_omp_all_clauses (parser, mask, p_name, cclauses == NULL);\n+  if (cclauses)\n+    {\n+      omp_split_clauses (loc, OMP_PARALLEL, mask, clauses, cclauses);\n+      clauses = cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL];\n+    }\n \n   block = c_begin_omp_parallel ();\n   c_parser_statement (parser);\n@@ -13643,7 +14517,8 @@ c_parser_omp_single (location_t loc, c_parser *parser)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SHARED)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FINAL)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MERGEABLE)\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY))\n \n static tree\n c_parser_omp_task (location_t loc, c_parser *parser)\n@@ -13923,17 +14798,56 @@ c_parser_omp_teams (location_t loc, c_parser *parser,\n #define OMP_TARGET_DATA_CLAUSE_MASK\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEVICE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP)\t\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR))\n \n static tree\n c_parser_omp_target_data (location_t loc, c_parser *parser)\n {\n-  tree stmt = make_node (OMP_TARGET_DATA);\n-  TREE_TYPE (stmt) = void_type_node;\n-\n-  OMP_TARGET_DATA_CLAUSES (stmt)\n+  tree clauses\n     = c_parser_omp_all_clauses (parser, OMP_TARGET_DATA_CLAUSE_MASK,\n \t\t\t\t\"#pragma omp target data\");\n+  int map_seen = 0;\n+  for (tree *pc = &clauses; *pc;)\n+    {\n+      if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)\n+\tswitch (OMP_CLAUSE_MAP_KIND (*pc))\n+\t  {\n+\t  case GOMP_MAP_TO:\n+\t  case GOMP_MAP_ALWAYS_TO:\n+\t  case GOMP_MAP_FROM:\n+\t  case GOMP_MAP_ALWAYS_FROM:\n+\t  case GOMP_MAP_TOFROM:\n+\t  case GOMP_MAP_ALWAYS_TOFROM:\n+\t  case GOMP_MAP_ALLOC:\n+\t    map_seen = 3;\n+\t    break;\n+\t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t    break;\n+\t  default:\n+\t    map_seen |= 1;\n+\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n+\t\t      \"%<#pragma omp target data%> with map-type other \"\n+\t\t      \"than %<to%>, %<from%>, %<tofrom%> or %<alloc%> \"\n+\t\t      \"on %<map%> clause\");\n+\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n+\t    continue;\n+\t  }\n+      pc = &OMP_CLAUSE_CHAIN (*pc);\n+    }\n+\n+  if (map_seen != 3)\n+    {\n+      if (map_seen == 0)\n+\terror_at (loc,\n+\t\t  \"%<#pragma omp target data%> must contain at least \"\n+\t\t  \"one %<map%> clause\");\n+      return NULL_TREE;\n+    }\n+\n+  tree stmt = make_node (OMP_TARGET_DATA);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_TARGET_DATA_CLAUSES (stmt) = clauses;\n   keep_next_level ();\n   tree block = c_begin_compound_stmt (true);\n   add_stmt (c_parser_omp_structured_block (parser));\n@@ -13950,7 +14864,9 @@ c_parser_omp_target_data (location_t loc, c_parser *parser)\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FROM)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_TO)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEVICE)\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n static bool\n c_parser_omp_target_update (location_t loc, c_parser *parser,\n@@ -13985,20 +14901,198 @@ c_parser_omp_target_update (location_t loc, c_parser *parser,\n   return false;\n }\n \n+/* OpenMP 4.5:\n+   # pragma omp target enter data target-data-clause[optseq] new-line  */\n+\n+#define OMP_TARGET_ENTER_DATA_CLAUSE_MASK\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEVICE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT))\n+\n+static tree\n+c_parser_omp_target_enter_data (location_t loc, c_parser *parser,\n+\t\t\t\tenum pragma_context context)\n+{\n+  bool data_seen = false;\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      if (strcmp (p, \"data\") == 0)\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  data_seen = true;\n+\t}\n+    }\n+  if (!data_seen)\n+    {\n+      c_parser_error (parser, \"expected %<data%>\");\n+      c_parser_skip_to_pragma_eol (parser);\n+      return NULL_TREE;\n+    }\n+\n+  if (context == pragma_stmt)\n+    {\n+      error_at (loc,\n+\t\t\"%<#pragma omp target enter data%> may only be \"\n+\t\t\"used in compound statements\");\n+      c_parser_skip_to_pragma_eol (parser);\n+      return NULL_TREE;\n+    }\n+\n+  tree clauses\n+    = c_parser_omp_all_clauses (parser, OMP_TARGET_ENTER_DATA_CLAUSE_MASK,\n+\t\t\t\t\"#pragma omp target enter data\");\n+  int map_seen = 0;\n+  for (tree *pc = &clauses; *pc;)\n+    {\n+      if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)\n+\tswitch (OMP_CLAUSE_MAP_KIND (*pc))\n+\t  {\n+\t  case GOMP_MAP_TO:\n+\t  case GOMP_MAP_ALWAYS_TO:\n+\t  case GOMP_MAP_ALLOC:\n+\t    map_seen = 3;\n+\t    break;\n+\t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t    break;\n+\t  default:\n+\t    map_seen |= 1;\n+\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n+\t\t      \"%<#pragma omp target enter data%> with map-type other \"\n+\t\t      \"than %<to%> or %<alloc%> on %<map%> clause\");\n+\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n+\t    continue;\n+\t  }\n+      pc = &OMP_CLAUSE_CHAIN (*pc);\n+    }\n+\n+  if (map_seen != 3)\n+    {\n+      if (map_seen == 0)\n+\terror_at (loc,\n+\t\t  \"%<#pragma omp target enter data%> must contain at least \"\n+\t\t  \"one %<map%> clause\");\n+      return NULL_TREE;\n+    }\n+\n+  tree stmt = make_node (OMP_TARGET_ENTER_DATA);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_TARGET_ENTER_DATA_CLAUSES (stmt) = clauses;\n+  SET_EXPR_LOCATION (stmt, loc);\n+  add_stmt (stmt);\n+  return stmt;\n+}\n+\n+/* OpenMP 4.5:\n+   # pragma omp target exit data target-data-clause[optseq] new-line  */\n+\n+#define OMP_TARGET_EXIT_DATA_CLAUSE_MASK\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEVICE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT))\n+\n+static tree\n+c_parser_omp_target_exit_data (location_t loc, c_parser *parser,\n+\t\t\t       enum pragma_context context)\n+{\n+  bool data_seen = false;\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      if (strcmp (p, \"data\") == 0)\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  data_seen = true;\n+\t}\n+    }\n+  if (!data_seen)\n+    {\n+      c_parser_error (parser, \"expected %<data%>\");\n+      c_parser_skip_to_pragma_eol (parser);\n+      return NULL_TREE;\n+    }\n+\n+  if (context == pragma_stmt)\n+    {\n+      error_at (loc,\n+\t\t\"%<#pragma omp target exit data%> may only be \"\n+\t\t\"used in compound statements\");\n+      c_parser_skip_to_pragma_eol (parser);\n+      return NULL_TREE;\n+    }\n+\n+  tree clauses\n+    = c_parser_omp_all_clauses (parser, OMP_TARGET_EXIT_DATA_CLAUSE_MASK,\n+\t\t\t\t\"#pragma omp target exit data\");\n+\n+  int map_seen = 0;\n+  for (tree *pc = &clauses; *pc;)\n+    {\n+      if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)\n+\tswitch (OMP_CLAUSE_MAP_KIND (*pc))\n+\t  {\n+\t  case GOMP_MAP_FROM:\n+\t  case GOMP_MAP_ALWAYS_FROM:\n+\t  case GOMP_MAP_RELEASE:\n+\t  case GOMP_MAP_DELETE:\n+\t    map_seen = 3;\n+\t    break;\n+\t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t    break;\n+\t  default:\n+\t    map_seen |= 1;\n+\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n+\t\t      \"%<#pragma omp target exit data%> with map-type other \"\n+\t\t      \"than %<from%>, %<release> or %<delete%> on %<map%>\"\n+\t\t      \" clause\");\n+\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n+\t    continue;\n+\t  }\n+      pc = &OMP_CLAUSE_CHAIN (*pc);\n+    }\n+\n+  if (map_seen != 3)\n+    {\n+      if (map_seen == 0)\n+\terror_at (loc,\n+\t\t  \"%<#pragma omp target exit data%> must contain at least one \"\n+\t\t  \"%<map%> clause\");\n+      return NULL_TREE;\n+    }\n+\n+  tree stmt = make_node (OMP_TARGET_EXIT_DATA);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_TARGET_EXIT_DATA_CLAUSES (stmt) = clauses;\n+  SET_EXPR_LOCATION (stmt, loc);\n+  add_stmt (stmt);\n+  return stmt;\n+}\n+\n /* OpenMP 4.0:\n    # pragma omp target target-clause[optseq] new-line\n      structured-block  */\n \n #define OMP_TARGET_CLAUSE_MASK\t\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEVICE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP)\t\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEFAULTMAP)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR))\n \n static bool\n c_parser_omp_target (c_parser *parser, enum pragma_context context)\n {\n   location_t loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_pragma (parser);\n+  tree *pc = NULL, stmt, block;\n \n   if (context != pragma_stmt && context != pragma_compound)\n     {\n@@ -14010,8 +15104,15 @@ c_parser_omp_target (c_parser *parser, enum pragma_context context)\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      enum tree_code ccode = ERROR_MARK;\n \n       if (strcmp (p, \"teams\") == 0)\n+\tccode = OMP_TEAMS;\n+      else if (strcmp (p, \"parallel\") == 0)\n+\tccode = OMP_PARALLEL;\n+      else if (strcmp (p, \"simd\") == 0)\n+\tccode = OMP_SIMD;\n+      if (ccode != ERROR_MARK)\n \t{\n \t  tree cclauses[C_OMP_CLAUSE_SPLIT_COUNT];\n \t  char p_name[sizeof (\"#pragma omp target teams distribute \"\n@@ -14021,24 +15122,59 @@ c_parser_omp_target (c_parser *parser, enum pragma_context context)\n \t  strcpy (p_name, \"#pragma omp target\");\n \t  if (!flag_openmp)  /* flag_openmp_simd  */\n \t    {\n-\t      tree stmt = c_parser_omp_teams (loc, parser, p_name,\n-\t\t\t\t\t      OMP_TARGET_CLAUSE_MASK,\n-\t\t\t\t\t      cclauses);\n+\t      tree stmt;\n+\t      switch (ccode)\n+\t\t{\n+\t\tcase OMP_TEAMS:\n+\t\t  stmt = c_parser_omp_teams (loc, parser, p_name,\n+\t\t\t\t\t     OMP_TARGET_CLAUSE_MASK,\n+\t\t\t\t\t     cclauses);\n+\t\t  break;\n+\t\tcase OMP_PARALLEL:\n+\t\t  stmt = c_parser_omp_parallel (loc, parser, p_name,\n+\t\t\t\t\t\tOMP_TARGET_CLAUSE_MASK,\n+\t\t\t\t\t\tcclauses);\n+\t\t  break;\n+\t\tcase OMP_SIMD:\n+\t\t  stmt = c_parser_omp_simd (loc, parser, p_name,\n+\t\t\t\t\t    OMP_TARGET_CLAUSE_MASK,\n+\t\t\t\t\t    cclauses);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n \t      return stmt != NULL_TREE;\n \t    }\n \t  keep_next_level ();\n-\t  tree block = c_begin_compound_stmt (true);\n-\t  tree ret = c_parser_omp_teams (loc, parser, p_name,\n-\t\t\t\t\t OMP_TARGET_CLAUSE_MASK, cclauses);\n+\t  tree block = c_begin_compound_stmt (true), ret;\n+\t  switch (ccode)\n+\t    {\n+\t    case OMP_TEAMS:\n+\t      ret = c_parser_omp_teams (loc, parser, p_name,\n+\t\t\t\t\tOMP_TARGET_CLAUSE_MASK, cclauses);\n+\t      break;\n+\t    case OMP_PARALLEL:\n+\t      ret = c_parser_omp_parallel (loc, parser, p_name,\n+\t\t\t\t\t   OMP_TARGET_CLAUSE_MASK, cclauses);\n+\t      break;\n+\t    case OMP_SIMD:\n+\t      ret = c_parser_omp_simd (loc, parser, p_name,\n+\t\t\t\t       OMP_TARGET_CLAUSE_MASK, cclauses);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n \t  block = c_end_compound_stmt (loc, block, true);\n \t  if (ret == NULL_TREE)\n \t    return false;\n \t  tree stmt = make_node (OMP_TARGET);\n \t  TREE_TYPE (stmt) = void_type_node;\n \t  OMP_TARGET_CLAUSES (stmt) = cclauses[C_OMP_CLAUSE_SPLIT_TARGET];\n \t  OMP_TARGET_BODY (stmt) = block;\n+\t  OMP_TARGET_COMBINED (stmt) = 1;\n \t  add_stmt (stmt);\n-\t  return true;\n+\t  pc = &OMP_TARGET_CLAUSES (stmt);\n+\t  goto check_clauses;\n \t}\n       else if (!flag_openmp)  /* flag_openmp_simd  */\n \t{\n@@ -14051,26 +15187,65 @@ c_parser_omp_target (c_parser *parser, enum pragma_context context)\n \t  c_parser_omp_target_data (loc, parser);\n \t  return true;\n \t}\n+      else if (strcmp (p, \"enter\") == 0)\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  c_parser_omp_target_enter_data (loc, parser, context);\n+\t  return false;\n+\t}\n+      else if (strcmp (p, \"exit\") == 0)\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  c_parser_omp_target_exit_data (loc, parser, context);\n+\t  return false;\n+\t}\n       else if (strcmp (p, \"update\") == 0)\n \t{\n \t  c_parser_consume_token (parser);\n \t  return c_parser_omp_target_update (loc, parser, context);\n \t}\n     }\n \n-  tree stmt = make_node (OMP_TARGET);\n+  stmt = make_node (OMP_TARGET);\n   TREE_TYPE (stmt) = void_type_node;\n \n   OMP_TARGET_CLAUSES (stmt)\n     = c_parser_omp_all_clauses (parser, OMP_TARGET_CLAUSE_MASK,\n \t\t\t\t\"#pragma omp target\");\n+  pc = &OMP_TARGET_CLAUSES (stmt);\n   keep_next_level ();\n-  tree block = c_begin_compound_stmt (true);\n+  block = c_begin_compound_stmt (true);\n   add_stmt (c_parser_omp_structured_block (parser));\n   OMP_TARGET_BODY (stmt) = c_end_compound_stmt (loc, block, true);\n \n   SET_EXPR_LOCATION (stmt, loc);\n   add_stmt (stmt);\n+\n+check_clauses:\n+  while (*pc)\n+    {\n+      if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)\n+\tswitch (OMP_CLAUSE_MAP_KIND (*pc))\n+\t  {\n+\t  case GOMP_MAP_TO:\n+\t  case GOMP_MAP_ALWAYS_TO:\n+\t  case GOMP_MAP_FROM:\n+\t  case GOMP_MAP_ALWAYS_FROM:\n+\t  case GOMP_MAP_TOFROM:\n+\t  case GOMP_MAP_ALWAYS_TOFROM:\n+\t  case GOMP_MAP_ALLOC:\n+\t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t    break;\n+\t  default:\n+\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n+\t\t      \"%<#pragma omp target%> with map-type other \"\n+\t\t      \"than %<to%>, %<from%>, %<tofrom%> or %<alloc%> \"\n+\t\t      \"on %<map%> clause\");\n+\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n+\t    continue;\n+\t  }\n+      pc = &OMP_CLAUSE_CHAIN (*pc);\n+    }\n   return true;\n }\n \n@@ -14306,13 +15481,64 @@ c_finish_omp_declare_simd (c_parser *parser, tree fndecl, tree parms,\n /* OpenMP 4.0:\n    # pragma omp declare target new-line\n    declarations and definitions\n-   # pragma omp end declare target new-line  */\n+   # pragma omp end declare target new-line\n+\n+   OpenMP 4.5:\n+   # pragma omp declare target ( extended-list ) new-line\n+\n+   # pragma omp declare target declare-target-clauses[seq] new-line  */\n+\n+#define OMP_DECLARE_TARGET_CLAUSE_MASK\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_TO)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LINK))\n \n static void\n c_parser_omp_declare_target (c_parser *parser)\n {\n-  c_parser_skip_to_pragma_eol (parser);\n-  current_omp_declare_target_attribute++;\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  tree clauses = NULL_TREE;\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    clauses = c_parser_omp_all_clauses (parser, OMP_DECLARE_TARGET_CLAUSE_MASK,\n+\t\t\t\t\t\"#pragma omp declare target\");\n+  else if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n+    {\n+      clauses = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_TO_DECLARE,\n+\t\t\t\t\t      clauses);\n+      c_parser_skip_to_pragma_eol (parser);\n+    }\n+  else\n+    {\n+      c_parser_skip_to_pragma_eol (parser);\n+      current_omp_declare_target_attribute++;\n+      return;\n+    }\n+  if (current_omp_declare_target_attribute)\n+    error_at (loc, \"%<#pragma omp declare target%> with clauses in between \"\n+\t\t   \"%<#pragma omp declare target%> without clauses and \"\n+\t\t   \"%<#pragma omp end declare target%>\");\n+  for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+    {\n+      tree t = OMP_CLAUSE_DECL (c), id;\n+      tree at1 = lookup_attribute (\"omp declare target\", DECL_ATTRIBUTES (t));\n+      tree at2 = lookup_attribute (\"omp declare target link\",\n+\t\t\t\t   DECL_ATTRIBUTES (t));\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINK)\n+\t{\n+\t  id = get_identifier (\"omp declare target link\");\n+\t  std::swap (at1, at2);\n+\t}\n+      else\n+\tid = get_identifier (\"omp declare target\");\n+      if (at2)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"%qD specified both in declare target %<link%> and %<to%>\"\n+\t\t    \" clauses\", t);\n+\t  continue;\n+\t}\n+      if (!at1)\n+\tDECL_ATTRIBUTES (t) = tree_cons (id, NULL_TREE, DECL_ATTRIBUTES (t));\n+    }\n }\n \n static void\n@@ -14612,9 +15838,13 @@ c_parser_omp_declare_reduction (c_parser *parser, enum pragma_context context)\n \t\t  int j;\n \t\t  tree c = initializer.value;\n \t\t  for (j = 0; j < call_expr_nargs (c); j++)\n-\t\t    if (TREE_CODE (CALL_EXPR_ARG (c, j)) == ADDR_EXPR\n-\t\t\t&& TREE_OPERAND (CALL_EXPR_ARG (c, j), 0) == omp_priv)\n-\t\t      break;\n+\t\t    {\n+\t\t      tree a = CALL_EXPR_ARG (c, j);\n+\t\t      STRIP_NOPS (a);\n+\t\t      if (TREE_CODE (a) == ADDR_EXPR\n+\t\t\t  && TREE_OPERAND (a, 0) == omp_priv)\n+\t\t\tbreak;\n+\t\t    }\n \t\t  if (j == call_expr_nargs (c))\n \t\t    error (\"one of the initializer call arguments should be \"\n \t\t\t   \"%<&omp_priv%>\");\n@@ -14741,6 +15971,86 @@ c_parser_omp_declare (c_parser *parser, enum pragma_context context)\n   c_parser_skip_to_pragma_eol (parser);\n }\n \n+/* OpenMP 4.5:\n+   #pragma omp taskloop taskloop-clause[optseq] new-line\n+     for-loop\n+\n+   #pragma omp taskloop simd taskloop-simd-clause[optseq] new-line\n+     for-loop  */\n+\n+#define OMP_TASKLOOP_CLAUSE_MASK\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SHARED)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEFAULT)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_GRAINSIZE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_TASKS)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COLLAPSE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_UNTIED)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FINAL)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MERGEABLE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY))\n+\n+static tree\n+c_parser_omp_taskloop (location_t loc, c_parser *parser,\n+\t\t       char *p_name, omp_clause_mask mask, tree *cclauses)\n+{\n+  tree clauses, block, ret;\n+\n+  strcat (p_name, \" taskloop\");\n+  mask |= OMP_TASKLOOP_CLAUSE_MASK;\n+\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\n+      if (strcmp (p, \"simd\") == 0)\n+\t{\n+\t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t  if (cclauses == NULL)\n+\t    cclauses = cclauses_buf;\n+\t  mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION);\n+\t  c_parser_consume_token (parser);\n+\t  if (!flag_openmp)  /* flag_openmp_simd  */\n+\t    return c_parser_omp_simd (loc, parser, p_name, mask, cclauses);\n+\t  block = c_begin_compound_stmt (true);\n+\t  ret = c_parser_omp_simd (loc, parser, p_name, mask, cclauses);\n+\t  block = c_end_compound_stmt (loc, block, true);\n+\t  if (ret == NULL)\n+\t    return ret;\n+\t  ret = make_node (OMP_TASKLOOP);\n+\t  TREE_TYPE (ret) = void_type_node;\n+\t  OMP_FOR_BODY (ret) = block;\n+\t  OMP_FOR_CLAUSES (ret) = cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP];\n+\t  SET_EXPR_LOCATION (ret, loc);\n+\t  add_stmt (ret);\n+\t  return ret;\n+\t}\n+    }\n+  if (!flag_openmp)  /* flag_openmp_simd  */\n+    {\n+      c_parser_skip_to_pragma_eol (parser, false);\n+      return NULL_TREE;\n+    }\n+\n+  clauses = c_parser_omp_all_clauses (parser, mask, p_name, cclauses == NULL);\n+  if (cclauses)\n+    {\n+      omp_split_clauses (loc, OMP_TASKLOOP, mask, clauses, cclauses);\n+      clauses = cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP];\n+    }\n+\n+  block = c_begin_compound_stmt (true);\n+  ret = c_parser_omp_for_loop (loc, parser, OMP_TASKLOOP, clauses, NULL);\n+  block = c_end_compound_stmt (loc, block, true);\n+  add_stmt (block);\n+\n+  return ret;\n+}\n+\n /* Main entry point to parsing most OpenMP pragmas.  */\n \n static void\n@@ -14798,9 +16108,6 @@ c_parser_omp_construct (c_parser *parser)\n     case PRAGMA_OMP_MASTER:\n       stmt = c_parser_omp_master (loc, parser);\n       break;\n-    case PRAGMA_OMP_ORDERED:\n-      stmt = c_parser_omp_ordered (loc, parser);\n-      break;\n     case PRAGMA_OMP_PARALLEL:\n       strcpy (p_name, \"#pragma omp\");\n       stmt = c_parser_omp_parallel (loc, parser, p_name, mask, NULL);\n@@ -14822,6 +16129,10 @@ c_parser_omp_construct (c_parser *parser)\n     case PRAGMA_OMP_TASKGROUP:\n       stmt = c_parser_omp_taskgroup (parser);\n       break;\n+    case PRAGMA_OMP_TASKLOOP:\n+      strcpy (p_name, \"#pragma omp\");\n+      stmt = c_parser_omp_taskloop (loc, parser, p_name, mask, NULL);\n+      break;\n     case PRAGMA_OMP_TEAMS:\n       strcpy (p_name, \"#pragma omp\");\n       stmt = c_parser_omp_teams (loc, parser, p_name, mask, NULL);\n@@ -15224,7 +16535,7 @@ c_parser_cilk_for (c_parser *parser, tree grain)\n   tree clauses = build_omp_clause (EXPR_LOCATION (grain), OMP_CLAUSE_SCHEDULE);\n   OMP_CLAUSE_SCHEDULE_KIND (clauses) = OMP_CLAUSE_SCHEDULE_CILKFOR;\n   OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clauses) = grain;\n-  clauses = c_finish_omp_clauses (clauses);\n+  clauses = c_finish_omp_clauses (clauses, false);\n \n   tree block = c_begin_compound_stmt (true);\n   tree sb = push_stmt_list ();\n@@ -15289,7 +16600,7 @@ c_parser_cilk_for (c_parser *parser, tree grain)\n       OMP_CLAUSE_OPERAND (c, 0)\n \t= cilk_for_number_of_iterations (omp_for);\n       OMP_CLAUSE_CHAIN (c) = clauses;\n-      OMP_PARALLEL_CLAUSES (omp_par) = c_finish_omp_clauses (c);\n+      OMP_PARALLEL_CLAUSES (omp_par) = c_finish_omp_clauses (c, true);\n       add_stmt (omp_par);\n     }\n "}, {"sha": "bee03d3dc4560d38a0755e7d4e8c8109c87715af", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -649,7 +649,7 @@ extern tree c_begin_omp_task (void);\n extern tree c_finish_omp_task (location_t, tree, tree);\n extern void c_finish_omp_cancel (location_t, tree);\n extern void c_finish_omp_cancellation_point (location_t, tree);\n-extern tree c_finish_omp_clauses (tree);\n+extern tree c_finish_omp_clauses (tree, bool, bool = false);\n extern tree c_build_va_arg (location_t, tree, tree);\n extern tree c_finish_transaction (location_t, tree, int);\n extern bool c_tree_equal (tree, tree);"}, {"sha": "bc43602909313d4150bbbb7db9992f328ae8ea83", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 474, "deletions": 58, "changes": 532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -11654,21 +11654,47 @@ c_finish_omp_cancellation_point (location_t loc, tree clauses)\n    map(a[:b][2:1][:c][:2][:d][e:f][2:5])\n    FIRST_NON_ONE will be 3, array-section-subscript [:b], [2:1] and [:c]\n    all are or may have length of 1, array-section-subscript [:2] is the\n-   first one knonwn not to have length 1.  For array-section-subscript\n+   first one known not to have length 1.  For array-section-subscript\n    <= FIRST_NON_ONE we diagnose non-contiguous arrays if low bound isn't\n    0 or length isn't the array domain max + 1, for > FIRST_NON_ONE we\n    can if MAYBE_ZERO_LEN is false.  MAYBE_ZERO_LEN will be true in the above\n    case though, as some lengths could be zero.  */\n \n static tree\n handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n-\t\t\t     bool &maybe_zero_len, unsigned int &first_non_one)\n+\t\t\t     bool &maybe_zero_len, unsigned int &first_non_one,\n+\t\t\t     bool is_omp)\n {\n   tree ret, low_bound, length, type;\n   if (TREE_CODE (t) != TREE_LIST)\n     {\n       if (error_operand_p (t))\n \treturn error_mark_node;\n+      ret = t;\n+      if (TREE_CODE (t) == COMPONENT_REF\n+\t  && is_omp\n+\t  && (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TO\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FROM))\n+\t{\n+\t  if (DECL_BIT_FIELD (TREE_OPERAND (t, 1)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"bit-field %qE in %qs clause\",\n+\t\t\tt, omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      return error_mark_node;\n+\t    }\n+\t  while (TREE_CODE (t) == COMPONENT_REF)\n+\t    {\n+\t      if (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == UNION_TYPE)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qE is a member of a union\", t);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t      t = TREE_OPERAND (t, 0);\n+\t    }\n+\t}\n       if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t{\n \t  if (DECL_P (t))\n@@ -11689,11 +11715,11 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t  return error_mark_node;\n \t}\n-      return t;\n+      return ret;\n     }\n \n   ret = handle_omp_array_sections_1 (c, TREE_CHAIN (t), types,\n-\t\t\t\t     maybe_zero_len, first_non_one);\n+\t\t\t\t     maybe_zero_len, first_non_one, is_omp);\n   if (ret == error_mark_node || ret == NULL_TREE)\n     return ret;\n \n@@ -11734,11 +11760,32 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n   if (length != NULL_TREE)\n     {\n       if (!integer_nonzerop (length))\n-\tmaybe_zero_len = true;\n+\t{\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t    {\n+\t      if (integer_zerop (length))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"zero length array section in %qs clause\",\n+\t\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t    }\n+\t  else\n+\t    maybe_zero_len = true;\n+\t}\n       if (first_non_one == types.length ()\n \t  && (TREE_CODE (length) != INTEGER_CST || integer_onep (length)))\n \tfirst_non_one++;\n     }\n+  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+      && !integer_zerop (low_bound))\n+    {\n+      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\"%<reduction%> array section has to be zero-based\");\n+      return error_mark_node;\n+    }\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       if (length == NULL_TREE\n@@ -11786,7 +11833,17 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t  return error_mark_node;\n \t\t}\n \t      if (tree_int_cst_equal (size, low_bound))\n-\t\tmaybe_zero_len = true;\n+\t\t{\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t\t    {\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"zero length array section in %qs clause\",\n+\t\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t      return error_mark_node;\n+\t\t    }\n+\t\t  maybe_zero_len = true;\n+\t\t}\n \t      else if (length == NULL_TREE\n \t\t       && first_non_one == types.length ()\n \t\t       && tree_int_cst_equal\n@@ -11796,7 +11853,9 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t    }\n \t  else if (length == NULL_TREE)\n \t    {\n-\t      maybe_zero_len = true;\n+\t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+\t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+\t\tmaybe_zero_len = true;\n \t      if (first_non_one == types.length ())\n \t\tfirst_non_one++;\n \t    }\n@@ -11830,7 +11889,9 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t}\n       else if (length == NULL_TREE)\n \t{\n-\t  maybe_zero_len = true;\n+\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+\t    maybe_zero_len = true;\n \t  if (first_non_one == types.length ())\n \t    first_non_one++;\n \t}\n@@ -11854,6 +11915,15 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t    \"for pointer type length expression must be specified\");\n \t  return error_mark_node;\n \t}\n+      if (length != NULL_TREE\n+\t  && TREE_CODE (length) == INTEGER_CST\n+\t  && tree_int_cst_sgn (length) == -1)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"negative length in array section in %qs clause\",\n+\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t  return error_mark_node;\n+\t}\n       /* If there is a pointer type anywhere but in the very first\n \t array-section-subscript, the array section can't be contiguous.  */\n       if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n@@ -11887,28 +11957,22 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n /* Handle array sections for clause C.  */\n \n static bool\n-handle_omp_array_sections (tree c)\n+handle_omp_array_sections (tree c, bool is_omp)\n {\n   bool maybe_zero_len = false;\n   unsigned int first_non_one = 0;\n-  vec<tree> types = vNULL;\n+  auto_vec<tree, 10> types;\n   tree first = handle_omp_array_sections_1 (c, OMP_CLAUSE_DECL (c), types,\n-\t\t\t\t\t    maybe_zero_len, first_non_one);\n+\t\t\t\t\t    maybe_zero_len, first_non_one,\n+\t\t\t\t\t    is_omp);\n   if (first == error_mark_node)\n-    {\n-      types.release ();\n-      return true;\n-    }\n+    return true;\n   if (first == NULL_TREE)\n-    {\n-      types.release ();\n-      return false;\n-    }\n+    return false;\n   if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND)\n     {\n       tree t = OMP_CLAUSE_DECL (c);\n       tree tem = NULL_TREE;\n-      types.release ();\n       /* Need to evaluate side effects in the length expressions\n \t if any.  */\n       while (TREE_CODE (t) == TREE_LIST)\n@@ -11978,7 +12042,6 @@ handle_omp_array_sections (tree c)\n \t\t\t\t\"array section is not contiguous in %qs \"\n \t\t\t\t\"clause\",\n \t\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n-\t\t      types.release ();\n \t\t      return true;\n \t\t    }\n \t\t}\n@@ -11997,7 +12060,9 @@ handle_omp_array_sections (tree c)\n \t    {\n \t      tree l;\n \n-\t      if (i > first_non_one && length && integer_nonzerop (length))\n+\t      if (i > first_non_one\n+\t\t  && ((length && integer_nonzerop (length))\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION))\n \t\tcontinue;\n \t      if (length)\n \t\tl = fold_convert (sizetype, length);\n@@ -12022,6 +12087,22 @@ handle_omp_array_sections (tree c)\n \t      else if (size == NULL_TREE)\n \t\t{\n \t\t  size = size_in_bytes (TREE_TYPE (types[i]));\n+\t\t  tree eltype = TREE_TYPE (types[num - 1]);\n+\t\t  while (TREE_CODE (eltype) == ARRAY_TYPE)\n+\t\t    eltype = TREE_TYPE (eltype);\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t\t    {\n+\t\t      if (integer_zerop (size)\n+\t\t\t  || integer_zerop (size_in_bytes (eltype)))\n+\t\t\t{\n+\t\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t    \"zero length array section in %qs clause\",\n+\t\t\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t\t  return error_mark_node;\n+\t\t\t}\n+\t\t      size = size_binop (EXACT_DIV_EXPR, size,\n+\t\t\t\t\t size_in_bytes (eltype));\n+\t\t    }\n \t\t  size = size_binop (MULT_EXPR, size, l);\n \t\t  if (condition)\n \t\t    size = fold_build3 (COND_EXPR, sizetype, condition,\n@@ -12031,20 +12112,56 @@ handle_omp_array_sections (tree c)\n \t\tsize = size_binop (MULT_EXPR, size, l);\n \t    }\n \t}\n-      types.release ();\n       if (side_effects)\n \tsize = build2 (COMPOUND_EXPR, sizetype, side_effects, size);\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t{\n+\t  size = size_binop (MINUS_EXPR, size, size_one_node);\n+\t  size = c_fully_fold (size, false, NULL);\n+\t  tree index_type = build_index_type (size);\n+\t  tree eltype = TREE_TYPE (first);\n+\t  while (TREE_CODE (eltype) == ARRAY_TYPE)\n+\t    eltype = TREE_TYPE (eltype);\n+\t  tree type = build_array_type (eltype, index_type);\n+\t  tree ptype = build_pointer_type (eltype);\n+\t  if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n+\t    t = build_fold_addr_expr (t);\n+\t  t = build2 (MEM_REF, type, t, build_int_cst (ptype, 0));\n+\t  OMP_CLAUSE_DECL (c) = t;\n+\t  return false;\n+\t}\n       first = c_fully_fold (first, false, NULL);\n       OMP_CLAUSE_DECL (c) = first;\n       if (size)\n \tsize = c_fully_fold (size, false, NULL);\n       OMP_CLAUSE_SIZE (c) = size;\n-      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n+      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP\n+\t  || (TREE_CODE (t) == COMPONENT_REF\n+\t      && TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE))\n \treturn false;\n       gcc_assert (OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_FORCE_DEVICEPTR);\n+      if (is_omp)\n+\tswitch (OMP_CLAUSE_MAP_KIND (c))\n+\t  {\n+\t  case GOMP_MAP_ALLOC:\n+\t  case GOMP_MAP_TO:\n+\t  case GOMP_MAP_FROM:\n+\t  case GOMP_MAP_TOFROM:\n+\t  case GOMP_MAP_ALWAYS_TO:\n+\t  case GOMP_MAP_ALWAYS_FROM:\n+\t  case GOMP_MAP_ALWAYS_TOFROM:\n+\t  case GOMP_MAP_RELEASE:\n+\t  case GOMP_MAP_DELETE:\n+\t    OMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION (c) = 1;\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n       tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n-      OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_POINTER);\n-      if (!c_mark_addressable (t))\n+      OMP_CLAUSE_SET_MAP_KIND (c2, is_omp\n+\t\t\t\t   ? GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t\t\t   : GOMP_MAP_POINTER);\n+      if (!is_omp && !c_mark_addressable (t))\n \treturn false;\n       OMP_CLAUSE_DECL (c2) = t;\n       t = build_fold_addr_expr (first);\n@@ -12109,11 +12226,12 @@ c_find_omp_placeholder_r (tree *tp, int *, void *data)\n    Remove any elements from the list that are invalid.  */\n \n tree\n-c_finish_omp_clauses (tree clauses)\n+c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n {\n   bitmap_head generic_head, firstprivate_head, lastprivate_head;\n-  bitmap_head aligned_head;\n-  tree c, t, *pc;\n+  bitmap_head aligned_head, map_head, map_field_head, generic_field_head;\n+  tree c, t, type, *pc;\n+  tree simdlen = NULL_TREE, safelen = NULL_TREE;\n   bool branch_seen = false;\n   bool copyprivate_seen = false;\n   tree *nowait_clause = NULL;\n@@ -12123,6 +12241,9 @@ c_finish_omp_clauses (tree clauses)\n   bitmap_initialize (&firstprivate_head, &bitmap_default_obstack);\n   bitmap_initialize (&lastprivate_head, &bitmap_default_obstack);\n   bitmap_initialize (&aligned_head, &bitmap_default_obstack);\n+  bitmap_initialize (&map_head, &bitmap_default_obstack);\n+  bitmap_initialize (&map_field_head, &bitmap_default_obstack);\n+  bitmap_initialize (&generic_field_head, &bitmap_default_obstack);\n \n   for (pc = &clauses, c = clauses; c ; c = *pc)\n     {\n@@ -12144,9 +12265,61 @@ c_finish_omp_clauses (tree clauses)\n \tcase OMP_CLAUSE_REDUCTION:\n \t  need_implicitly_determined = true;\n \t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) == TREE_LIST)\n+\t    {\n+\t      if (handle_omp_array_sections (c, is_omp))\n+\t\t{\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\n+\t      t = OMP_CLAUSE_DECL (c);\n+\t    }\n+\t  t = require_complete_type (t);\n+\t  if (t == error_mark_node)\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  type = TREE_TYPE (t);\n+\t  if (TREE_CODE (t) == MEM_REF)\n+\t    type = TREE_TYPE (type);\n+\t  if (TREE_CODE (type) == ARRAY_TYPE)\n+\t    {\n+\t      tree oatype = type;\n+\t      gcc_assert (TREE_CODE (t) != MEM_REF);\n+\t      while (TREE_CODE (type) == ARRAY_TYPE)\n+\t\ttype = TREE_TYPE (type);\n+\t      if (integer_zerop (TYPE_SIZE_UNIT (type)))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qD in %<reduction%> clause is a zero size array\",\n+\t\t\t    t);\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\t      tree size = size_binop (EXACT_DIV_EXPR, TYPE_SIZE_UNIT (oatype),\n+\t\t\t\t      TYPE_SIZE_UNIT (type));\n+\t      if (integer_zerop (size))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qD in %<reduction%> clause is a zero size array\",\n+\t\t\t    t);\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\t      size = size_binop (MINUS_EXPR, size, size_one_node);\n+\t      tree index_type = build_index_type (size);\n+\t      tree atype = build_array_type (type, index_type);\n+\t      tree ptype = build_pointer_type (type);\n+\t      if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n+\t\tt = build_fold_addr_expr (t);\n+\t      t = build2 (MEM_REF, atype, t, build_int_cst (ptype, 0));\n+\t      OMP_CLAUSE_DECL (c) = t;\n+\t    }\n \t  if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) == NULL_TREE\n-\t      && (FLOAT_TYPE_P (TREE_TYPE (t))\n-\t\t  || TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE))\n+\t      && (FLOAT_TYPE_P (type)\n+\t\t  || TREE_CODE (type) == COMPLEX_TYPE))\n \t    {\n \t      enum tree_code r_code = OMP_CLAUSE_REDUCTION_CODE (c);\n \t      const char *r_name = NULL;\n@@ -12158,11 +12331,11 @@ c_finish_omp_clauses (tree clauses)\n \t\tcase MINUS_EXPR:\n \t\t  break;\n \t\tcase MIN_EXPR:\n-\t\t  if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE)\n+\t\t  if (TREE_CODE (type) == COMPLEX_TYPE)\n \t\t    r_name = \"min\";\n \t\t  break;\n \t\tcase MAX_EXPR:\n-\t\t  if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE)\n+\t\t  if (TREE_CODE (type) == COMPLEX_TYPE)\n \t\t    r_name = \"max\";\n \t\t  break;\n \t\tcase BIT_AND_EXPR:\n@@ -12175,11 +12348,11 @@ c_finish_omp_clauses (tree clauses)\n \t\t  r_name = \"|\";\n \t\t  break;\n \t\tcase TRUTH_ANDIF_EXPR:\n-\t\t  if (FLOAT_TYPE_P (TREE_TYPE (t)))\n+\t\t  if (FLOAT_TYPE_P (type))\n \t\t    r_name = \"&&\";\n \t\t  break;\n \t\tcase TRUTH_ORIF_EXPR:\n-\t\t  if (FLOAT_TYPE_P (TREE_TYPE (t)))\n+\t\t  if (FLOAT_TYPE_P (type))\n \t\t    r_name = \"||\";\n \t\t  break;\n \t\tdefault:\n@@ -12197,37 +12370,49 @@ c_finish_omp_clauses (tree clauses)\n \t  else if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) == error_mark_node)\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\"user defined reduction not found for %qD\", t);\n+\t\t\t\"user defined reduction not found for %qE\", t);\n \t      remove = true;\n \t      break;\n \t    }\n \t  else if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n \t    {\n \t      tree list = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);\n-\t      tree type = TYPE_MAIN_VARIANT (TREE_TYPE (t));\n+\t      type = TYPE_MAIN_VARIANT (type);\n \t      tree placeholder = build_decl (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\t     VAR_DECL, NULL_TREE, type);\n+\t      tree decl_placeholder = NULL_TREE;\n \t      OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = placeholder;\n \t      DECL_ARTIFICIAL (placeholder) = 1;\n \t      DECL_IGNORED_P (placeholder) = 1;\n+\t      if (TREE_CODE (t) == MEM_REF)\n+\t\t{\n+\t\t  decl_placeholder = build_decl (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t VAR_DECL, NULL_TREE, type);\n+\t\t  OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (c) = decl_placeholder;\n+\t\t  DECL_ARTIFICIAL (decl_placeholder) = 1;\n+\t\t  DECL_IGNORED_P (decl_placeholder) = 1;\n+\t\t}\n \t      if (TREE_ADDRESSABLE (TREE_VEC_ELT (list, 0)))\n \t\tc_mark_addressable (placeholder);\n \t      if (TREE_ADDRESSABLE (TREE_VEC_ELT (list, 1)))\n-\t\tc_mark_addressable (OMP_CLAUSE_DECL (c));\n+\t\tc_mark_addressable (decl_placeholder ? decl_placeholder\n+\t\t\t\t    : OMP_CLAUSE_DECL (c));\n \t      OMP_CLAUSE_REDUCTION_MERGE (c)\n \t\t= c_clone_omp_udr (TREE_VEC_ELT (list, 2),\n \t\t\t\t   TREE_VEC_ELT (list, 0),\n \t\t\t\t   TREE_VEC_ELT (list, 1),\n-\t\t\t\t   OMP_CLAUSE_DECL (c), placeholder);\n+\t\t\t\t   decl_placeholder ? decl_placeholder\n+\t\t\t\t   : OMP_CLAUSE_DECL (c), placeholder);\n \t      OMP_CLAUSE_REDUCTION_MERGE (c)\n \t\t= build3_loc (OMP_CLAUSE_LOCATION (c), BIND_EXPR,\n \t\t\t      void_type_node, NULL_TREE,\n-\t\t\t       OMP_CLAUSE_REDUCTION_MERGE (c), NULL_TREE);\n+\t\t\t      OMP_CLAUSE_REDUCTION_MERGE (c), NULL_TREE);\n \t      TREE_SIDE_EFFECTS (OMP_CLAUSE_REDUCTION_MERGE (c)) = 1;\n \t      if (TREE_VEC_LENGTH (list) == 6)\n \t\t{\n \t\t  if (TREE_ADDRESSABLE (TREE_VEC_ELT (list, 3)))\n-\t\t    c_mark_addressable (OMP_CLAUSE_DECL (c));\n+\t\t    c_mark_addressable (decl_placeholder ? decl_placeholder\n+\t\t\t\t\t: OMP_CLAUSE_DECL (c));\n \t\t  if (TREE_ADDRESSABLE (TREE_VEC_ELT (list, 4)))\n \t\t    c_mark_addressable (placeholder);\n \t\t  tree init = TREE_VEC_ELT (list, 5);\n@@ -12236,11 +12421,15 @@ c_finish_omp_clauses (tree clauses)\n \t\t  OMP_CLAUSE_REDUCTION_INIT (c)\n \t\t    = c_clone_omp_udr (init, TREE_VEC_ELT (list, 4),\n \t\t\t\t       TREE_VEC_ELT (list, 3),\n-\t\t\t\t       OMP_CLAUSE_DECL (c), placeholder);\n+\t\t\t\t       decl_placeholder ? decl_placeholder\n+\t\t\t\t       : OMP_CLAUSE_DECL (c), placeholder);\n \t\t  if (TREE_VEC_ELT (list, 5) == error_mark_node)\n-\t\t    OMP_CLAUSE_REDUCTION_INIT (c)\n-\t\t      = build2 (INIT_EXPR, TREE_TYPE (t), t,\n-\t\t\t\tOMP_CLAUSE_REDUCTION_INIT (c));\n+\t\t    {\n+\t\t      tree v = decl_placeholder ? decl_placeholder : t;\n+\t\t      OMP_CLAUSE_REDUCTION_INIT (c)\n+\t\t\t= build2 (INIT_EXPR, TREE_TYPE (v), v,\n+\t\t\t\t  OMP_CLAUSE_REDUCTION_INIT (c));\n+\t\t    }\n \t\t  if (walk_tree (&OMP_CLAUSE_REDUCTION_INIT (c),\n \t\t\t\t c_find_omp_placeholder_r,\n \t\t\t\t placeholder, NULL))\n@@ -12249,20 +12438,36 @@ c_finish_omp_clauses (tree clauses)\n \t      else\n \t\t{\n \t\t  tree init;\n-\t\t  if (AGGREGATE_TYPE_P (TREE_TYPE (t)))\n-\t\t    init = build_constructor (TREE_TYPE (t), NULL);\n+\t\t  tree v = decl_placeholder ? decl_placeholder : t;\n+\t\t  if (AGGREGATE_TYPE_P (TREE_TYPE (v)))\n+\t\t    init = build_constructor (TREE_TYPE (v), NULL);\n \t\t  else\n-\t\t    init = fold_convert (TREE_TYPE (t), integer_zero_node);\n+\t\t    init = fold_convert (TREE_TYPE (v), integer_zero_node);\n \t\t  OMP_CLAUSE_REDUCTION_INIT (c)\n-\t\t    = build2 (INIT_EXPR, TREE_TYPE (t), t, init);\n+\t\t    = build2 (INIT_EXPR, TREE_TYPE (v), v, init);\n \t\t}\n \t      OMP_CLAUSE_REDUCTION_INIT (c)\n \t\t= build3_loc (OMP_CLAUSE_LOCATION (c), BIND_EXPR,\n \t\t\t      void_type_node, NULL_TREE,\n \t\t\t       OMP_CLAUSE_REDUCTION_INIT (c), NULL_TREE);\n \t      TREE_SIDE_EFFECTS (OMP_CLAUSE_REDUCTION_INIT (c)) = 1;\n \t    }\n-\t  goto check_dup_generic;\n+\t  if (TREE_CODE (t) == MEM_REF)\n+\t    {\n+\t      if (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (t))) == NULL_TREE\n+\t\t  || TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (t))))\n+\t\t     != INTEGER_CST)\n+\t\t{\n+\t\t  sorry (\"variable length element type in array \"\n+\t\t\t \"%<reduction%> clause\");\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\t      t = TREE_OPERAND (t, 0);\n+\t      if (TREE_CODE (t) == ADDR_EXPR)\n+\t\tt = TREE_OPERAND (t, 0);\n+\t    }\n+\t  goto check_dup_generic_t;\n \n \tcase OMP_CLAUSE_COPYPRIVATE:\n \t  copyprivate_seen = true;\n@@ -12288,7 +12493,17 @@ c_finish_omp_clauses (tree clauses)\n \t  goto check_dup_generic;\n \n \tcase OMP_CLAUSE_LINEAR:\n+\t  if (!declare_simd)\n+\t    need_implicitly_determined = true;\n \t  t = OMP_CLAUSE_DECL (c);\n+\t  if (!declare_simd\n+\t      && OMP_CLAUSE_LINEAR_KIND (c) != OMP_CLAUSE_LINEAR_DEFAULT)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"modifier should not be specified in %<linear%> \"\n+\t\t\t\"clause on %<simd%> or %<for%> constructs\");\n+\t      OMP_CLAUSE_LINEAR_KIND (c) = OMP_CLAUSE_LINEAR_DEFAULT;\n+\t    }\n \t  if (!INTEGRAL_TYPE_P (TREE_TYPE (t))\n \t      && TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE)\n \t    {\n@@ -12316,6 +12531,7 @@ c_finish_omp_clauses (tree clauses)\n \n \tcheck_dup_generic:\n \t  t = OMP_CLAUSE_DECL (c);\n+\tcheck_dup_generic_t:\n \t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n@@ -12406,9 +12622,41 @@ c_finish_omp_clauses (tree clauses)\n \n \tcase OMP_CLAUSE_DEPEND:\n \t  t = OMP_CLAUSE_DECL (c);\n+\t  if (t == NULL_TREE)\n+\t    {\n+\t      gcc_assert (OMP_CLAUSE_DEPEND_KIND (c)\n+\t\t\t  == OMP_CLAUSE_DEPEND_SOURCE);\n+\t      break;\n+\t    }\n+\t  if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK)\n+\t    {\n+\t      gcc_assert (TREE_CODE (t) == TREE_LIST);\n+\t      for (; t; t = TREE_CHAIN (t))\n+\t\t{\n+\t\t  tree decl = TREE_VALUE (t);\n+\t\t  if (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE)\n+\t\t    {\n+\t\t      tree offset = TREE_PURPOSE (t);\n+\t\t      bool neg = wi::neg_p ((wide_int) offset);\n+\t\t      offset = fold_unary (ABS_EXPR, TREE_TYPE (offset), offset);\n+\t\t      tree t2 = pointer_int_sum (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t neg ? MINUS_EXPR : PLUS_EXPR,\n+\t\t\t\t\t\t decl, offset);\n+\t\t      t2 = fold_build2_loc (OMP_CLAUSE_LOCATION (c), MINUS_EXPR,\n+\t\t\t\t\t    sizetype, t2, decl);\n+\t\t      if (t2 == error_mark_node)\n+\t\t\t{\n+\t\t\t  remove = true;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      TREE_PURPOSE (t) = t2;\n+\t\t    }\n+\t\t}\n+\t      break;\n+\t    }\n \t  if (TREE_CODE (t) == TREE_LIST)\n \t    {\n-\t      if (handle_omp_array_sections (c))\n+\t      if (handle_omp_array_sections (c, is_omp))\n \t\tremove = true;\n \t      break;\n \t    }\n@@ -12431,7 +12679,7 @@ c_finish_omp_clauses (tree clauses)\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (t) == TREE_LIST)\n \t    {\n-\t      if (handle_omp_array_sections (c))\n+\t      if (handle_omp_array_sections (c, is_omp))\n \t\tremove = true;\n \t      else\n \t\t{\n@@ -12444,12 +12692,85 @@ c_finish_omp_clauses (tree clauses)\n \t\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t\t      remove = true;\n \t\t    }\n+\t\t  while (TREE_CODE (t) == ARRAY_REF)\n+\t\t    t = TREE_OPERAND (t, 0);\n+\t\t  if (TREE_CODE (t) == COMPONENT_REF\n+\t\t      && TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n+\t\t    {\n+\t\t      while (TREE_CODE (t) == COMPONENT_REF)\n+\t\t\tt = TREE_OPERAND (t, 0);\n+\t\t      if (bitmap_bit_p (&map_field_head, DECL_UID (t)))\n+\t\t\tbreak;\n+\t\t      if (bitmap_bit_p (&map_head, DECL_UID (t)))\n+\t\t\t{\n+\t\t\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n+\t\t\t    error (\"%qD appears more than once in motion\"\n+\t\t\t\t   \" clauses\", t);\n+\t\t\t  else\n+\t\t\t    error (\"%qD appears more than once in map\"\n+\t\t\t\t   \" clauses\", t);\n+\t\t\t  remove = true;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  bitmap_set_bit (&map_head, DECL_UID (t));\n+\t\t\t  bitmap_set_bit (&map_field_head, DECL_UID (t));\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t      break;\n \t    }\n \t  if (t == error_mark_node)\n-\t    remove = true;\n-\t  else if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  if (TREE_CODE (t) == COMPONENT_REF\n+\t      && is_omp\n+\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE__CACHE_)\n+\t    {\n+\t      if (DECL_BIT_FIELD (TREE_OPERAND (t, 1)))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"bit-field %qE in %qs clause\",\n+\t\t\t    t, omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  remove = true;\n+\t\t}\n+\t      else if (!lang_hooks.types.omp_mappable_type (TREE_TYPE (t)))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qE does not have a mappable type in %qs clause\",\n+\t\t\t    t, omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  remove = true;\n+\t\t}\n+\t      while (TREE_CODE (t) == COMPONENT_REF)\n+\t\t{\n+\t\t  if (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0)))\n+\t\t      == UNION_TYPE)\n+\t\t    {\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"%qE is a member of a union\", t);\n+\t\t      remove = true;\n+\t\t      break;\n+\t\t    }\n+\t\t  t = TREE_OPERAND (t, 0);\n+\t\t}\n+\t      if (remove)\n+\t\tbreak;\n+\t      if (VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n+\t\t{\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t\t      && (OMP_CLAUSE_MAP_KIND (c)\n+\t\t\t  == GOMP_MAP_FIRSTPRIVATE_POINTER))\n+\t\t    {\n+\t\t      if (bitmap_bit_p (&generic_field_head, DECL_UID (t)))\n+\t\t\tbreak;\n+\t\t    }\n+\t\t  else if (bitmap_bit_p (&map_field_head, DECL_UID (t)))\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qE is not a variable in %qs clause\", t,\n@@ -12467,16 +12788,36 @@ c_finish_omp_clauses (tree clauses)\n \t    remove = true;\n \t  else if (!(OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t\t     && (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER\n+\t\t\t || (OMP_CLAUSE_MAP_KIND (c)\n+\t\t\t     == GOMP_MAP_FIRSTPRIVATE_POINTER)\n \t\t\t || (OMP_CLAUSE_MAP_KIND (c)\n \t\t\t     == GOMP_MAP_FORCE_DEVICEPTR)))\n+\t\t   && t == OMP_CLAUSE_DECL (c)\n \t\t   && !lang_hooks.types.omp_mappable_type (TREE_TYPE (t)))\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qD does not have a mappable type in %qs clause\", t,\n \t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n-\t  else if (bitmap_bit_p (&generic_head, DECL_UID (t)))\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t\t   && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER)\n+\t    {\n+\t      if (bitmap_bit_p (&generic_head, DECL_UID (t))\n+\t\t  || bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n+\t\t{\n+\t\t  error (\"%qD appears more than once in data clauses\", t);\n+\t\t  remove = true;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  bitmap_set_bit (&generic_head, DECL_UID (t));\n+\t\t  if (t != OMP_CLAUSE_DECL (c)\n+\t\t      && TREE_CODE (OMP_CLAUSE_DECL (c)) == COMPONENT_REF)\n+\t\t    bitmap_set_bit (&generic_field_head, DECL_UID (t));\n+\t\t}\n+\t    }\n+\t  else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n \t    {\n \t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n \t\terror (\"%qD appears more than once in motion clauses\", t);\n@@ -12485,7 +12826,42 @@ c_finish_omp_clauses (tree clauses)\n \t      remove = true;\n \t    }\n \t  else\n-\t    bitmap_set_bit (&generic_head, DECL_UID (t));\n+\t    {\n+\t      bitmap_set_bit (&map_head, DECL_UID (t));\n+\t      if (t != OMP_CLAUSE_DECL (c)\n+\t\t  && TREE_CODE (OMP_CLAUSE_DECL (c)) == COMPONENT_REF)\n+\t\tbitmap_set_bit (&map_field_head, DECL_UID (t));\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_TO_DECLARE:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) == FUNCTION_DECL)\n+\t    break;\n+\t  /* FALLTHRU */\n+\tcase OMP_CLAUSE_LINK:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (!VAR_P (t))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE is not a variable in clause %qs\", t,\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      remove = true;\n+\t    }\n+\t  else if (DECL_THREAD_LOCAL_P (t))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD is threadprivate variable in %qs clause\", t,\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      remove = true;\n+\t    }\n+\t  else if (!lang_hooks.types.omp_mappable_type (TREE_TYPE (t)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD does not have a mappable type in %qs clause\", t,\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      remove = true;\n+\t    }\n \t  break;\n \n \tcase OMP_CLAUSE_UNIFORM:\n@@ -12503,6 +12879,19 @@ c_finish_omp_clauses (tree clauses)\n \t    }\n \t  goto check_dup_generic;\n \n+\tcase OMP_CLAUSE_IS_DEVICE_PTR:\n+\tcase OMP_CLAUSE_USE_DEVICE_PTR:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE\n+\t      && TREE_CODE (TREE_TYPE (t)) != ARRAY_TYPE)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qs variable is neither a pointer nor an array\",\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      remove = true;\n+\t    }\n+\t  goto check_dup_generic;\n+\n \tcase OMP_CLAUSE_NOWAIT:\n \t  if (copyprivate_seen)\n \t    {\n@@ -12527,15 +12916,21 @@ c_finish_omp_clauses (tree clauses)\n \tcase OMP_CLAUSE_COLLAPSE:\n \tcase OMP_CLAUSE_FINAL:\n \tcase OMP_CLAUSE_MERGEABLE:\n-\tcase OMP_CLAUSE_SAFELEN:\n-\tcase OMP_CLAUSE_SIMDLEN:\n \tcase OMP_CLAUSE_DEVICE:\n \tcase OMP_CLAUSE_DIST_SCHEDULE:\n \tcase OMP_CLAUSE_PARALLEL:\n \tcase OMP_CLAUSE_FOR:\n \tcase OMP_CLAUSE_SECTIONS:\n \tcase OMP_CLAUSE_TASKGROUP:\n \tcase OMP_CLAUSE_PROC_BIND:\n+\tcase OMP_CLAUSE_PRIORITY:\n+\tcase OMP_CLAUSE_GRAINSIZE:\n+\tcase OMP_CLAUSE_NUM_TASKS:\n+\tcase OMP_CLAUSE_NOGROUP:\n+\tcase OMP_CLAUSE_THREADS:\n+\tcase OMP_CLAUSE_SIMD:\n+\tcase OMP_CLAUSE_HINT:\n+\tcase OMP_CLAUSE_DEFAULTMAP:\n \tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \tcase OMP_CLAUSE_NUM_GANGS:\n \tcase OMP_CLAUSE_NUM_WORKERS:\n@@ -12550,6 +12945,15 @@ c_finish_omp_clauses (tree clauses)\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n \t  continue;\n \n+\tcase OMP_CLAUSE_SAFELEN:\n+\t  safelen = c;\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  continue;\n+\tcase OMP_CLAUSE_SIMDLEN:\n+\t  simdlen = c;\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  continue;\n+\n \tcase OMP_CLAUSE_INBRANCH:\n \tcase OMP_CLAUSE_NOTINBRANCH:\n \t  if (branch_seen)\n@@ -12619,6 +13023,18 @@ c_finish_omp_clauses (tree clauses)\n \tpc = &OMP_CLAUSE_CHAIN (c);\n     }\n \n+  if (simdlen\n+      && safelen\n+      && tree_int_cst_lt (OMP_CLAUSE_SAFELEN_EXPR (safelen),\n+\t\t\t  OMP_CLAUSE_SIMDLEN_EXPR (simdlen)))\n+    {\n+      error_at (OMP_CLAUSE_LOCATION (simdlen),\n+\t\t\"%<simdlen%> clause value is bigger than \"\n+\t\t\"%<safelen%> clause value\");\n+      OMP_CLAUSE_SIMDLEN_EXPR (simdlen)\n+\t= OMP_CLAUSE_SAFELEN_EXPR (safelen);\n+    }\n+\n   bitmap_obstack_release (NULL);\n   return clauses;\n }"}, {"sha": "7c54f24cc7e3c642a793e08255fa48776f6745de", "filename": "gcc/cgraph.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -643,8 +643,14 @@ enum cgraph_simd_clone_arg_type\n {\n   SIMD_CLONE_ARG_TYPE_VECTOR,\n   SIMD_CLONE_ARG_TYPE_UNIFORM,\n+  /* These are only for integer/pointer arguments passed by value.  */\n   SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP,\n   SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP,\n+  /* These 3 are only for reference type arguments or arguments passed\n+     by reference.  */\n+  SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP,\n+  SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP,\n+  SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP,\n   SIMD_CLONE_ARG_TYPE_MASK\n };\n \n@@ -684,7 +690,7 @@ struct GTY(()) cgraph_simd_clone_arg {\n      variable), uniform, or vector.  */\n   enum cgraph_simd_clone_arg_type arg_type;\n \n-  /* For arg_type SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP this is\n+  /* For arg_type SIMD_CLONE_ARG_TYPE_LINEAR_*CONSTANT_STEP this is\n      the constant linear step, if arg_type is\n      SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP, this is index of\n      the uniform argument holding the step, otherwise 0.  */"}, {"sha": "3439c382cab63a447b92437acd57a25eed43c04c", "filename": "gcc/coretypes.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -112,6 +112,7 @@ struct gomp_atomic_load;\n struct gomp_atomic_store;\n struct gomp_continue;\n struct gomp_critical;\n+struct gomp_ordered;\n struct gomp_for;\n struct gomp_parallel;\n struct gomp_task;"}, {"sha": "b5951afbee49e4d94cc4c19302e185f9f8d3a319", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1,3 +1,150 @@\n+2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* class.c (finish_struct_1): Call finish_omp_declare_simd_methods.\n+\t* cp-gimplify.c (cp_gimplify_expr): Handle OMP_TASKLOOP.\n+\t(cp_genericize_r): Likewise.\n+\t(cxx_omp_finish_clause): Don't diagnose references.\n+\t(cxx_omp_disregard_value_expr): New function.\n+\t* cp-objcp-common.h (LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR): Redefine.\n+\t* cp-tree.h (OMP_FOR_GIMPLIFYING_P): Document for OMP_TASKLOOP.\n+\t(DECL_OMP_PRIVATIZED_MEMBER): Define.\n+\t(finish_omp_declare_simd_methods, push_omp_privatization_clauses,\n+\tpop_omp_privatization_clauses, save_omp_privatization_clauses,\n+\trestore_omp_privatization_clauses, omp_privatize_field,\n+\tcxx_omp_disregard_value_expr): New prototypes.\n+\t(finish_omp_clauses): Add two new arguments.\n+\t(finish_omp_for): Add ORIG_DECLV argument.\n+\t* parser.c (cp_parser_lambda_body): Call\n+\tsave_omp_privatization_clauses and restore_omp_privatization_clauses.\n+\t(cp_parser_omp_clause_name): Handle OpenMP 4.5 clauses.\n+\t(cp_parser_omp_var_list_no_open): Handle structure elements for\n+\tmap, to and from clauses.  Handle array sections in reduction\n+\tclause.  Parse this keyword.  Formatting fixes.\n+\t(cp_parser_omp_clause_if): Add IS_OMP argument, handle parsing of\n+\tif clause modifiers.\n+\t(cp_parser_omp_clause_num_tasks, cp_parser_omp_clause_grainsize,\n+\tcp_parser_omp_clause_priority, cp_parser_omp_clause_hint,\n+\tcp_parser_omp_clause_defaultmap): New functions.\n+\t(cp_parser_omp_clause_ordered): Parse optional parameter.\n+\t(cp_parser_omp_clause_reduction): Handle array reductions.\n+\t(cp_parser_omp_clause_schedule): Parse optional simd modifier.\n+\t(cp_parser_omp_clause_nogroup, cp_parser_omp_clause_orderedkind):\n+\tNew functions.\n+\t(cp_parser_omp_clause_linear): Parse linear clause modifiers.\n+\t(cp_parser_omp_clause_depend_sink): New function.\n+\t(cp_parser_omp_clause_depend): Parse source/sink depend kinds.\n+\t(cp_parser_omp_clause_map): Parse release/delete map kinds and\n+\toptional always modifier.\n+\t(cp_parser_oacc_all_clauses): Adjust cp_parser_omp_clause_if\n+\tand finish_omp_clauses callers.\n+\t(cp_parser_omp_all_clauses): Likewise.  Parse OpenMP 4.5 clauses.\n+\tParse \"to\" as OMP_CLAUSE_TO_DECLARE if on declare target directive.\n+\t(OMP_CRITICAL_CLAUSE_MASK): Define.\n+\t(cp_parser_omp_critical): Parse critical clauses.\n+\t(cp_parser_omp_for_incr): Use cp_tree_equal if\n+\tprocessing_template_decl.\n+\t(cp_parser_omp_for_loop_init): Return tree instead of bool.  Handle\n+\tnon-static data member iterators.\n+\t(cp_parser_omp_for_loop): Handle doacross loops, adjust\n+\tfinish_omp_for and finish_omp_clauses callers.\n+\t(cp_omp_split_clauses): Adjust finish_omp_clauses caller.\n+\t(OMP_SIMD_CLAUSE_MASK): Add simdlen clause.\n+\t(cp_parser_omp_simd): Allow ordered clause if it has no parameter.\n+\t(OMP_FOR_CLAUSE_MASK): Add linear clause.\n+\t(cp_parser_omp_for): Disallow ordered clause when combined with\n+\tdistribute.  Disallow linear clause when combined with distribute\n+\tand not combined with simd.\n+\t(OMP_ORDERED_CLAUSE_MASK, OMP_ORDERED_DEPEND_CLAUSE_MASK): Define.\n+\t(cp_parser_omp_ordered): Add CONTEXT argument, return bool instead\n+\tof tree, parse clauses and if depend clause is found, don't parse\n+\ta body.\n+\t(cp_parser_omp_parallel): Disallow copyin clause on target parallel.\n+\tAllow target parallel without for after it.\n+\t(OMP_TASK_CLAUSE_MASK): Add priority clause.\n+\t(OMP_TARGET_DATA_CLAUSE_MASK): Add use_device_ptr clause.\n+\t(cp_parser_omp_target_data): Diagnose no map clauses or clauses with\n+\tinvalid kinds.\n+\t(OMP_TARGET_UPDATE_CLAUSE_MASK): Add depend and nowait clauses.\n+\t(OMP_TARGET_ENTER_DATA_CLAUSE_MASK,\n+\tOMP_TARGET_EXIT_DATA_CLAUSE_MASK): Define.\n+\t(cp_parser_omp_target_enter_data, cp_parser_omp_target_exit_data): New\n+\tfunctions.\n+\t(OMP_TARGET_CLAUSE_MASK): Add depend, nowait, private, firstprivate,\n+\tdefaultmap and is_device_ptr clauses.\n+\t(cp_parser_omp_target): Parse target parallel and target simd.  Set\n+\tOMP_TARGET_COMBINED on combined constructs.  Parse target enter data\n+\tand target exit data.  Diagnose invalid map kinds.\n+\t(cp_parser_oacc_cache): Adjust finish_omp_clauses caller.\n+\t(OMP_DECLARE_TARGET_CLAUSE_MASK): Define.\n+\t(cp_parser_omp_declare_target): Parse OpenMP 4.5 forms of this\n+\tconstruct.\n+\t(OMP_TASKLOOP_CLAUSE_MASK): Define.\n+\t(cp_parser_omp_taskloop): New function.\n+\t(cp_parser_omp_construct): Don't handle PRAGMA_OMP_ORDERED here,\n+\thandle PRAGMA_OMP_TASKLOOP.\n+\t(cp_parser_pragma): Handle PRAGMA_OMP_ORDERED here directly,\n+\thandle PRAGMA_OMP_TASKLOOP, call push_omp_privatization_clauses\n+\tand pop_omp_privatization_clauses around parsing calls.\n+\t(cp_parser_cilk_for): Adjust finish_omp_clauses caller.\n+\t* pt.c (apply_late_template_attributes): Adjust tsubst_omp_clauses\n+\tand finish_omp_clauses callers.\n+\t(tsubst_omp_clause_decl): Return NULL if decl is NULL.\n+\tFor TREE_LIST, copy over OMP_CLAUSE_DEPEND_SINK_NEGATIVE bit.\n+\tUse tsubst_expr instead of tsubst_copy, undo convert_from_reference\n+\teffects.\n+\t(tsubst_omp_clauses): Add ALLOW_FIELDS argument.  Handle new\n+\tOpenMP 4.5 clauses.  Use tsubst_omp_clause_decl for more clauses.\n+\tIf ALLOW_FIELDS, handle non-static data members in the clauses.\n+\tClear OMP_CLAUSE_LINEAR_STEP if it has been cleared before.\n+\t(omp_parallel_combined_clauses): New variable.\n+\t(tsubst_omp_for_iterator): Add ORIG_DECLV argument, recur on\n+\tOMP_FOR_ORIG_DECLS, handle non-static data member iterators.\n+\tImprove handling of clauses on combined constructs.\n+\t(tsubst_expr): Call push_omp_privatization_clauses and\n+\tpop_omp_privatization_clauses around instantiation of certain\n+\tOpenMP constructs, improve handling of clauses on combined\n+\tconstructs, handle OMP_TASKLOOP, adjust tsubst_omp_for_iterator,\n+\ttsubst_omp_clauses and finish_omp_for callers, handle clauses on\n+\tcritical and ordered, handle OMP_TARGET_{ENTER,EXIT}_DATA.\n+\t(instantiate_decl): Call save_omp_privatization_clauses and\n+\trestore_omp_privatization_clauses around instantiation.\n+\t(dependent_omp_for_p): Fix up comment typo.  Handle SCOPE_REF.\n+\t* semantics.c (omp_private_member_map, omp_private_member_vec,\n+\tomp_private_member_ignore_next): New variables.\n+\t(finish_non_static_data_member): Return dummy decl for privatized\n+\tnon-static data members.\n+\t(omp_clause_decl_field, omp_clause_printable_decl,\n+\tomp_note_field_privatization, omp_privatize_field): New functions.\n+\t(handle_omp_array_sections_1): Fix comment typo.\n+\tAdd IS_OMP argument, handle structure element bases, diagnose\n+\tbitfields, pass IS_OMP recursively, diagnose known zero length\n+\tarray sections in depend clauses, handle array sections in reduction\n+\tclause, diagnose negative length even for pointers.\n+\t(handle_omp_array_sections): Add IS_OMP argument, use auto_vec for\n+\ttypes, pass IS_OMP down to handle_omp_array_sections_1, handle\n+\tarray sections in reduction clause, set\n+\tOMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION if map could be zero\n+\tlength array section, use GOMP_MAP_FIRSTPRIVATE_POINTER for IS_OMP.\n+\t(finish_omp_reduction_clause): Handle array sections and arrays.\n+\tUse omp_clause_printable_decl.\n+\t(finish_omp_declare_simd_methods, cp_finish_omp_clause_depend_sink):\n+\tNew functions.\n+\t(finish_omp_clauses): Add ALLOW_FIELDS and DECLARE_SIMD arguments.\n+\tHandle new OpenMP 4.5 clauses and new restrictions for the old\n+\tones, handle non-static data members, reject this keyword when not\n+\tallowed.\n+\t(push_omp_privatization_clauses, pop_omp_privatization_clauses,\n+\tsave_omp_privatization_clauses, restore_omp_privatization_clauses):\n+\tNew functions.\n+\t(handle_omp_for_class_iterator): Handle OMP_TASKLOOP class iterators.\n+\tAdd collapse and ordered arguments.  Fix handling of lastprivate\n+\titerators in doacross loops.\n+\t(finish_omp_for): Add ORIG_DECLV argument, handle doacross loops,\n+\tadjust c_finish_omp_for, handle_omp_for_class_iterator and\n+\tfinish_omp_clauses callers.  Fill in OMP_CLAUSE_LINEAR_STEP on simd\n+\tloops with non-static data member iterators.\n+\n 2015-10-12  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tPR c++/58566"}, {"sha": "685b7b3fc18dda8b2bd2da4d34f8d1fdd72ad349", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -6697,6 +6697,8 @@ finish_struct_1 (tree t)\n \n   finish_struct_bits (t);\n   set_method_tm_attributes (t);\n+  if (flag_openmp || flag_openmp_simd)\n+    finish_omp_declare_simd_methods (t);\n \n   /* Complete the rtl for any static member objects of the type we're\n      working on.  */"}, {"sha": "e37cbc7cd99df70632d70a72c1c274c5818de05c", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -713,6 +713,7 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n     case OMP_FOR:\n     case OMP_SIMD:\n     case OMP_DISTRIBUTE:\n+    case OMP_TASKLOOP:\n       ret = cp_gimplify_omp_for (expr_p, pre_p);\n       break;\n \n@@ -1294,7 +1295,8 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n     genericize_break_stmt (stmt_p);\n   else if (TREE_CODE (stmt) == OMP_FOR\n \t   || TREE_CODE (stmt) == OMP_SIMD\n-\t   || TREE_CODE (stmt) == OMP_DISTRIBUTE)\n+\t   || TREE_CODE (stmt) == OMP_DISTRIBUTE\n+\t   || TREE_CODE (stmt) == OMP_TASKLOOP)\n     genericize_omp_for_stmt (stmt_p, walk_subtrees, data);\n   else if (TREE_CODE (stmt) == SIZEOF_EXPR)\n     {\n@@ -1752,16 +1754,7 @@ cxx_omp_finish_clause (tree c, gimple_seq *)\n   if (decl == error_mark_node)\n     make_shared = true;\n   else if (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE)\n-    {\n-      if (is_invisiref_parm (decl))\n-\tinner_type = TREE_TYPE (inner_type);\n-      else\n-\t{\n-\t  error (\"%qE implicitly determined as %<firstprivate%> has reference type\",\n-\t\t decl);\n-\t  make_shared = true;\n-\t}\n-    }\n+    inner_type = TREE_TYPE (inner_type);\n \n   /* We're interested in the base element, not arrays.  */\n   while (TREE_CODE (inner_type) == ARRAY_TYPE)\n@@ -1778,3 +1771,19 @@ cxx_omp_finish_clause (tree c, gimple_seq *)\n   if (make_shared)\n     OMP_CLAUSE_CODE (c) = OMP_CLAUSE_SHARED;\n }\n+\n+/* Return true if DECL's DECL_VALUE_EXPR (if any) should be\n+   disregarded in OpenMP construct, because it is going to be\n+   remapped during OpenMP lowering.  SHARED is true if DECL\n+   is going to be shared, false if it is going to be privatized.  */\n+\n+bool\n+cxx_omp_disregard_value_expr (tree decl, bool shared)\n+{\n+  return !shared\n+\t && VAR_P (decl)\n+\t && DECL_HAS_VALUE_EXPR_P (decl)\n+\t && DECL_ARTIFICIAL (decl)\n+\t && DECL_LANG_SPECIFIC (decl)\n+\t && DECL_OMP_PRIVATIZED_MEMBER (decl);\n+}"}, {"sha": "199c3f1bc0e4a7df6a62b7c285662e05060dbe0c", "filename": "gcc/cp/cp-objcp-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcp%2Fcp-objcp-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcp%2Fcp-objcp-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -150,6 +150,8 @@ extern void cp_common_init_ts (void);\n #define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE cxx_omp_privatize_by_reference\n #undef LANG_HOOKS_OMP_MAPPABLE_TYPE\n #define LANG_HOOKS_OMP_MAPPABLE_TYPE cp_omp_mappable_type\n+#undef LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR\n+#define LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR cxx_omp_disregard_value_expr\n \n #undef LANG_HOOKS_EH_USE_CXA_END_CLEANUP\n #define LANG_HOOKS_EH_USE_CXA_END_CLEANUP true"}, {"sha": "16db41f79e98fcee6f27617c295fc2eb86a13440", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -58,7 +58,8 @@ c-common.h, not after.\n       STMT_EXPR_NO_SCOPE (in STMT_EXPR)\n       BIND_EXPR_TRY_BLOCK (in BIND_EXPR)\n       TYPENAME_IS_ENUM_P (in TYPENAME_TYPE)\n-      OMP_FOR_GIMPLIFYING_P (in OMP_FOR, OMP_SIMD and OMP_DISTRIBUTE)\n+      OMP_FOR_GIMPLIFYING_P (in OMP_FOR, OMP_SIMD, OMP_DISTRIBUTE,\n+\t\t\t     and OMP_TASKLOOP)\n       BASELINK_QUALIFIED_P (in BASELINK)\n       TARGET_EXPR_IMPLICIT_P (in TARGET_EXPR)\n       TEMPLATE_PARM_PARAMETER_PACK (in TEMPLATE_PARM_INDEX)\n@@ -2172,6 +2173,7 @@ struct GTY(()) lang_decl_base {\n   unsigned repo_available_p : 1;\t   /* var or fn */\n   unsigned threadprivate_or_deleted_p : 1; /* var or fn */\n   unsigned anticipated_p : 1;\t\t   /* fn, type or template */\n+  /* anticipated_p reused as DECL_OMP_PRIVATIZED_MEMBER in var */\n   unsigned friend_or_tls : 1;\t\t   /* var, fn, type or template */\n   unsigned template_conv_p : 1;\t\t   /* var or template */\n   unsigned odr_used : 1;\t\t   /* var or fn */\n@@ -3512,6 +3514,11 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   (DECL_LANG_SPECIFIC (TYPE_FUNCTION_OR_TEMPLATE_DECL_CHECK (NODE)) \\\n    ->u.base.anticipated_p)\n \n+/* True for artificial decls added for OpenMP privatized non-static\n+   data members.  */\n+#define DECL_OMP_PRIVATIZED_MEMBER(NODE) \\\n+  (DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))->u.base.anticipated_p)\n+\n /* Nonzero if NODE is a FUNCTION_DECL which was declared as a friend\n    within a class but has not been declared in the surrounding scope.\n    The function is invisible except via argument dependent lookup.  */\n@@ -6301,7 +6308,12 @@ extern void finalize_nrv\t\t\t(tree *, tree, tree);\n extern tree omp_reduction_id\t\t\t(enum tree_code, tree, tree);\n extern tree cp_remove_omp_priv_cleanup_stmt\t(tree *, int *, void *);\n extern void cp_check_omp_declare_reduction\t(tree);\n-extern tree finish_omp_clauses\t\t\t(tree);\n+extern void finish_omp_declare_simd_methods\t(tree);\n+extern tree finish_omp_clauses\t\t\t(tree, bool, bool = false);\n+extern tree push_omp_privatization_clauses\t(bool);\n+extern void pop_omp_privatization_clauses\t(tree);\n+extern void save_omp_privatization_clauses\t(vec<tree> &);\n+extern void restore_omp_privatization_clauses\t(vec<tree> &);\n extern void finish_omp_threadprivate\t\t(tree);\n extern tree begin_omp_structured_block\t\t(void);\n extern tree finish_omp_structured_block\t\t(tree);\n@@ -6314,7 +6326,7 @@ extern tree begin_omp_task\t\t\t(void);\n extern tree finish_omp_task\t\t\t(tree, tree);\n extern tree finish_omp_for\t\t\t(location_t, enum tree_code,\n \t\t\t\t\t\t tree, tree, tree, tree, tree,\n-\t\t\t\t\t\t tree, tree);\n+\t\t\t\t\t\t tree, tree, tree);\n extern void finish_omp_atomic\t\t\t(enum tree_code, enum tree_code,\n \t\t\t\t\t\t tree, tree, tree, tree, tree,\n \t\t\t\t\t\t bool);\n@@ -6324,6 +6336,7 @@ extern void finish_omp_taskwait\t\t\t(void);\n extern void finish_omp_taskyield\t\t(void);\n extern void finish_omp_cancel\t\t\t(tree);\n extern void finish_omp_cancellation_point\t(tree);\n+extern tree omp_privatize_field\t\t\t(tree);\n extern tree begin_transaction_stmt\t\t(location_t, tree *, int);\n extern void finish_transaction_stmt\t\t(tree, tree, int, tree);\n extern tree build_transaction_expr\t\t(location_t, tree, int, tree);\n@@ -6693,6 +6706,7 @@ extern tree cxx_omp_clause_assign_op\t\t(tree, tree, tree);\n extern tree cxx_omp_clause_dtor\t\t\t(tree, tree);\n extern void cxx_omp_finish_clause\t\t(tree, gimple_seq *);\n extern bool cxx_omp_privatize_by_reference\t(const_tree);\n+extern bool cxx_omp_disregard_value_expr\t(tree, bool);\n \n /* in name-lookup.c */\n extern void suggest_alternatives_for            (location_t, tree);"}, {"sha": "435757d3fa1c3f85f9fba4b4d29029e349a91bb1", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1487, "deletions": 168, "changes": 1655, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -9820,6 +9820,8 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n     /* Still increment function_depth so that we don't GC in the\n        middle of an expression.  */\n     ++function_depth;\n+  vec<tree> omp_privatization_save;\n+  save_omp_privatization_clauses (omp_privatization_save);\n   /* Clear this in case we're in the middle of a default argument.  */\n   parser->local_variables_forbidden_p = false;\n \n@@ -9921,6 +9923,7 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n       expand_or_defer_fn (fn);\n   }\n \n+  restore_omp_privatization_clauses (omp_privatization_save);\n   parser->local_variables_forbidden_p = local_variables_forbidden_p;\n   if (nested)\n     pop_function_context();\n@@ -29093,7 +29096,9 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OACC_CLAUSE_CREATE;\n \t  break;\n \tcase 'd':\n-\t  if (!strcmp (\"depend\", p))\n+\t  if (!strcmp (\"defaultmap\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_DEFAULTMAP;\n+\t  else if (!strcmp (\"depend\", p))\n \t    result = PRAGMA_OMP_CLAUSE_DEPEND;\n \t  else if (!strcmp (\"device\", p))\n \t    result = PRAGMA_OMP_CLAUSE_DEVICE;\n@@ -29110,19 +29115,29 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t  else if (!strcmp (\"from\", p))\n \t    result = PRAGMA_OMP_CLAUSE_FROM;\n \t  break;\n+\tcase 'g':\n+\t  if (!strcmp (\"grainsize\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_GRAINSIZE;\n+\t  break;\n \tcase 'h':\n-\t  if (!strcmp (\"host\", p))\n+\t  if (!strcmp (\"hint\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_HINT;\n+\t  else if (!strcmp (\"host\", p))\n \t    result = PRAGMA_OACC_CLAUSE_HOST;\n \t  break;\n \tcase 'i':\n \t  if (!strcmp (\"inbranch\", p))\n \t    result = PRAGMA_OMP_CLAUSE_INBRANCH;\n+\t  else if (!strcmp (\"is_device_ptr\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR;\n \t  break;\n \tcase 'l':\n \t  if (!strcmp (\"lastprivate\", p))\n \t    result = PRAGMA_OMP_CLAUSE_LASTPRIVATE;\n \t  else if (!strcmp (\"linear\", p))\n \t    result = PRAGMA_OMP_CLAUSE_LINEAR;\n+\t  else if (!strcmp (\"link\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_LINK;\n \t  break;\n \tcase 'm':\n \t  if (!strcmp (\"map\", p))\n@@ -29133,14 +29148,18 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_CILK_CLAUSE_MASK;\n \t  break;\n \tcase 'n':\n-\t  if (!strcmp (\"notinbranch\", p))\n+\t  if (!strcmp (\"nogroup\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_NOGROUP;\n+\t  else if (!strcmp (\"notinbranch\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NOTINBRANCH;\n \t  else if (!strcmp (\"nowait\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NOWAIT;\n \t  else if (flag_cilkplus && !strcmp (\"nomask\", p))\n \t    result = PRAGMA_CILK_CLAUSE_NOMASK;\n \t  else if (!strcmp (\"num_gangs\", p))\n \t    result = PRAGMA_OACC_CLAUSE_NUM_GANGS;\n+\t  else if (!strcmp (\"num_tasks\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_NUM_TASKS;\n \t  else if (!strcmp (\"num_teams\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NUM_TEAMS;\n \t  else if (!strcmp (\"num_threads\", p))\n@@ -29169,6 +29188,8 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t  else if (!strcmp (\"present_or_create\", p)\n \t\t   || !strcmp (\"pcreate\", p))\n \t    result = PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE;\n+\t  else if (!strcmp (\"priority\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_PRIORITY;\n \t  else if (!strcmp (\"proc_bind\", p))\n \t    result = PRAGMA_OMP_CLAUSE_PROC_BIND;\n \t  break;\n@@ -29187,6 +29208,8 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OACC_CLAUSE_SELF;\n \t  else if (!strcmp (\"shared\", p))\n \t    result = PRAGMA_OMP_CLAUSE_SHARED;\n+\t  else if (!strcmp (\"simd\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_SIMD;\n \t  else if (!strcmp (\"simdlen\", p))\n \t    result = PRAGMA_OMP_CLAUSE_SIMDLEN;\n \t  break;\n@@ -29195,6 +29218,8 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_TASKGROUP;\n \t  else if (!strcmp (\"thread_limit\", p))\n \t    result = PRAGMA_OMP_CLAUSE_THREAD_LIMIT;\n+\t  else if (!strcmp (\"threads\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_THREADS;\n \t  else if (!strcmp (\"to\", p))\n \t    result = PRAGMA_OMP_CLAUSE_TO;\n \t  break;\n@@ -29203,6 +29228,8 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_UNIFORM;\n \t  else if (!strcmp (\"untied\", p))\n \t    result = PRAGMA_OMP_CLAUSE_UNTIED;\n+\t  else if (!strcmp (\"use_device_ptr\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR;\n \t  break;\n \tcase 'v':\n \t  if (!strcmp (\"vector_length\", p))\n@@ -29273,18 +29300,33 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n       tree name, decl;\n \n       token = cp_lexer_peek_token (parser->lexer);\n-      name = cp_parser_id_expression (parser, /*template_p=*/false,\n-\t\t\t\t      /*check_dependency_p=*/true,\n-\t\t\t\t      /*template_p=*/NULL,\n-\t\t\t\t      /*declarator_p=*/false,\n-\t\t\t\t      /*optional_p=*/false);\n-      if (name == error_mark_node)\n-\tgoto skip_comma;\n+      if (kind != 0\n+\t  && current_class_ptr\n+\t  && cp_parser_is_keyword (token, RID_THIS))\n+\t{\n+\t  decl = finish_this_expr ();\n+\t  if (TREE_CODE (decl) == NON_LVALUE_EXPR\n+\t      || CONVERT_EXPR_P (decl))\n+\t    decl = TREE_OPERAND (decl, 0);\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t}\n+      else\n+\t{\n+\t  name = cp_parser_id_expression (parser, /*template_p=*/false,\n+\t\t\t\t\t  /*check_dependency_p=*/true,\n+\t\t\t\t\t  /*template_p=*/NULL,\n+\t\t\t\t\t  /*declarator_p=*/false,\n+\t\t\t\t\t  /*optional_p=*/false);\n+\t  if (name == error_mark_node)\n+\t    goto skip_comma;\n \n-      decl = cp_parser_lookup_name_simple (parser, name, token->location);\n+\t  decl = cp_parser_lookup_name_simple (parser, name, token->location);\n+\t  if (decl == error_mark_node)\n+\t    cp_parser_name_lookup_error (parser, name, decl, NLE_NULL,\n+\t\t\t\t\t token->location);\n+\t}\n       if (decl == error_mark_node)\n-\tcp_parser_name_lookup_error (parser, name, decl, NLE_NULL,\n-\t\t\t\t     token->location);\n+\t;\n       else if (kind != 0)\n \t{\n \t  switch (kind)\n@@ -29296,11 +29338,24 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t  decl = error_mark_node;\n \t\t  break;\n \t\t}\n-\t      /* FALL THROUGH.  */\n+\t      /* FALLTHROUGH.  */\n \t    case OMP_CLAUSE_MAP:\n \t    case OMP_CLAUSE_FROM:\n \t    case OMP_CLAUSE_TO:\n+\t      while (cp_lexer_next_token_is (parser->lexer, CPP_DOT))\n+\t\t{\n+\t\t  location_t loc\n+\t\t    = cp_lexer_peek_token (parser->lexer)->location;\n+\t\t  cp_id_kind idk = CP_ID_KIND_NONE;\n+\t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t  decl\n+\t\t    = cp_parser_postfix_dot_deref_expression (parser, CPP_DOT,\n+\t\t\t\t\t\t\t      decl, false,\n+\t\t\t\t\t\t\t      &idk, loc);\n+\t\t}\n+\t      /* FALLTHROUGH.  */\n \t    case OMP_CLAUSE_DEPEND:\n+\t    case OMP_CLAUSE_REDUCTION:\n \t      while (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_SQUARE))\n \t\t{\n \t\t  tree low_bound = NULL_TREE, length = NULL_TREE;\n@@ -29334,15 +29389,15 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t\t  && !TREE_READONLY (low_bound))\n \t\t\t{\n \t\t\t  error_at (token->location,\n-\t\t\t\t\t\"%qD is not a constant\", low_bound);\n+\t\t\t\t    \"%qD is not a constant\", low_bound);\n \t\t\t  decl = error_mark_node;\n \t\t\t}\n \n \t\t      if (TREE_CODE (length) != INTEGER_CST\n \t\t\t  && !TREE_READONLY (length))\n \t\t\t{\n \t\t\t  error_at (token->location,\n-\t\t\t\t\t\"%qD is not a constant\", length);\n+\t\t\t\t    \"%qD is not a constant\", length);\n \t\t\t  decl = error_mark_node;\n \t\t\t}\n \t\t    }\n@@ -29753,16 +29808,102 @@ cp_parser_omp_clause_final (cp_parser *parser, tree list, location_t location)\n }\n \n /* OpenMP 2.5:\n-   if ( expression ) */\n+   if ( expression )\n+\n+   OpenMP 4.5:\n+   if ( directive-name-modifier : expression )\n+\n+   directive-name-modifier:\n+     parallel | task | taskloop | target data | target | target update\n+     | target enter data | target exit data  */\n \n static tree\n-cp_parser_omp_clause_if (cp_parser *parser, tree list, location_t location)\n+cp_parser_omp_clause_if (cp_parser *parser, tree list, location_t location,\n+\t\t\t bool is_omp)\n {\n   tree t, c;\n+  enum tree_code if_modifier = ERROR_MARK;\n \n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n+  if (is_omp && cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+      int n = 2;\n+\n+      if (strcmp (\"parallel\", p) == 0)\n+\tif_modifier = OMP_PARALLEL;\n+      else if (strcmp (\"task\", p) == 0)\n+\tif_modifier = OMP_TASK;\n+      else if (strcmp (\"taskloop\", p) == 0)\n+\tif_modifier = OMP_TASKLOOP;\n+      else if (strcmp (\"target\", p) == 0)\n+\t{\n+\t  if_modifier = OMP_TARGET;\n+\t  if (cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n+\t    {\n+\t      id = cp_lexer_peek_nth_token (parser->lexer, 2)->u.value;\n+\t      p = IDENTIFIER_POINTER (id);\n+\t      if (strcmp (\"data\", p) == 0)\n+\t\tif_modifier = OMP_TARGET_DATA;\n+\t      else if (strcmp (\"update\", p) == 0)\n+\t\tif_modifier = OMP_TARGET_UPDATE;\n+\t      else if (strcmp (\"enter\", p) == 0)\n+\t\tif_modifier = OMP_TARGET_ENTER_DATA;\n+\t      else if (strcmp (\"exit\", p) == 0)\n+\t\tif_modifier = OMP_TARGET_EXIT_DATA;\n+\t      if (if_modifier != OMP_TARGET)\n+\t\tn = 3;\n+\t      else\n+\t\t{\n+\t\t  location_t loc\n+\t\t    = cp_lexer_peek_nth_token (parser->lexer, 2)->location;\n+\t\t  error_at (loc, \"expected %<data%>, %<update%>, %<enter%> \"\n+\t\t\t\t \"or %<exit%>\");\n+\t\t  if_modifier = ERROR_MARK;\n+\t\t}\n+\t      if (if_modifier == OMP_TARGET_ENTER_DATA\n+\t\t  || if_modifier == OMP_TARGET_EXIT_DATA)\n+\t\t{\n+\t\t  if (cp_lexer_nth_token_is (parser->lexer, 3, CPP_NAME))\n+\t\t    {\n+\t\t      id = cp_lexer_peek_nth_token (parser->lexer, 3)->u.value;\n+\t\t      p = IDENTIFIER_POINTER (id);\n+\t\t      if (strcmp (\"data\", p) == 0)\n+\t\t\tn = 4;\n+\t\t    }\n+\t\t  if (n != 4)\n+\t\t    {\n+\t\t      location_t loc\n+\t\t\t= cp_lexer_peek_nth_token (parser->lexer, 3)->location;\n+\t\t      error_at (loc, \"expected %<data%>\");\n+\t\t      if_modifier = ERROR_MARK;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      if (if_modifier != ERROR_MARK)\n+\t{\n+\t  if (cp_lexer_nth_token_is (parser->lexer, n, CPP_COLON))\n+\t    {\n+\t      while (n-- > 0)\n+\t\tcp_lexer_consume_token (parser->lexer);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (n > 2)\n+\t\t{\n+\t\t  location_t loc\n+\t\t    = cp_lexer_peek_nth_token (parser->lexer, n)->location;\n+\t\t  error_at (loc, \"expected %<:%>\");\n+\t\t}\n+\t      if_modifier = ERROR_MARK;\n+\t    }\n+\t}\n+    }\n+\n   t = cp_parser_condition (parser);\n \n   if (t == error_mark_node\n@@ -29771,9 +29912,48 @@ cp_parser_omp_clause_if (cp_parser *parser, tree list, location_t location)\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n \n-  check_no_duplicate_clause (list, OMP_CLAUSE_IF, \"if\", location);\n+  for (c = list; c ; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IF)\n+      {\n+\tif (if_modifier != ERROR_MARK\n+\t    && OMP_CLAUSE_IF_MODIFIER (c) == if_modifier)\n+\t  {\n+\t    const char *p = NULL;\n+\t    switch (if_modifier)\n+\t      {\n+\t      case OMP_PARALLEL: p = \"parallel\"; break;\n+\t      case OMP_TASK: p = \"task\"; break;\n+\t      case OMP_TASKLOOP: p = \"taskloop\"; break;\n+\t      case OMP_TARGET_DATA: p = \"target data\"; break;\n+\t      case OMP_TARGET: p = \"target\"; break;\n+\t      case OMP_TARGET_UPDATE: p = \"target update\"; break;\n+\t      case OMP_TARGET_ENTER_DATA: p = \"enter data\"; break;\n+\t      case OMP_TARGET_EXIT_DATA: p = \"exit data\"; break;\n+\t      default: gcc_unreachable ();\n+\t      }\n+\t    error_at (location, \"too many %<if%> clauses with %qs modifier\",\n+\t\t      p);\n+\t    return list;\n+\t  }\n+\telse if (OMP_CLAUSE_IF_MODIFIER (c) == if_modifier)\n+\t  {\n+\t    if (!is_omp)\n+\t      error_at (location, \"too many %<if%> clauses\");\n+\t    else\n+\t      error_at (location, \"too many %<if%> clauses without modifier\");\n+\t    return list;\n+\t  }\n+\telse if (if_modifier == ERROR_MARK\n+\t\t || OMP_CLAUSE_IF_MODIFIER (c) == ERROR_MARK)\n+\t  {\n+\t    error_at (location, \"if any %<if%> clause has modifier, then all \"\n+\t\t\t\t\"%<if%> clauses have to use modifier\");\n+\t    return list;\n+\t  }\n+      }\n \n   c = build_omp_clause (location, OMP_CLAUSE_IF);\n+  OMP_CLAUSE_IF_MODIFIER (c) = if_modifier;\n   OMP_CLAUSE_IF_EXPR (c) = t;\n   OMP_CLAUSE_CHAIN (c) = list;\n \n@@ -29879,6 +30059,184 @@ cp_parser_omp_clause_num_threads (cp_parser *parser, tree list,\n   return c;\n }\n \n+/* OpenMP 4.5:\n+   num_tasks ( expression ) */\n+\n+static tree\n+cp_parser_omp_clause_num_tasks (cp_parser *parser, tree list,\n+\t\t\t\tlocation_t location)\n+{\n+  tree t, c;\n+\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+    return list;\n+\n+  t = cp_parser_expression (parser);\n+\n+  if (t == error_mark_node\n+      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_NUM_TASKS,\n+\t\t\t     \"num_tasks\", location);\n+\n+  c = build_omp_clause (location, OMP_CLAUSE_NUM_TASKS);\n+  OMP_CLAUSE_NUM_TASKS_EXPR (c) = t;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+\n+  return c;\n+}\n+\n+/* OpenMP 4.5:\n+   grainsize ( expression ) */\n+\n+static tree\n+cp_parser_omp_clause_grainsize (cp_parser *parser, tree list,\n+\t\t\t\tlocation_t location)\n+{\n+  tree t, c;\n+\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+    return list;\n+\n+  t = cp_parser_expression (parser);\n+\n+  if (t == error_mark_node\n+      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_GRAINSIZE,\n+\t\t\t     \"grainsize\", location);\n+\n+  c = build_omp_clause (location, OMP_CLAUSE_GRAINSIZE);\n+  OMP_CLAUSE_GRAINSIZE_EXPR (c) = t;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+\n+  return c;\n+}\n+\n+/* OpenMP 4.5:\n+   priority ( expression ) */\n+\n+static tree\n+cp_parser_omp_clause_priority (cp_parser *parser, tree list,\n+\t\t\t       location_t location)\n+{\n+  tree t, c;\n+\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+    return list;\n+\n+  t = cp_parser_expression (parser);\n+\n+  if (t == error_mark_node\n+      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_PRIORITY,\n+\t\t\t     \"priority\", location);\n+\n+  c = build_omp_clause (location, OMP_CLAUSE_PRIORITY);\n+  OMP_CLAUSE_PRIORITY_EXPR (c) = t;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+\n+  return c;\n+}\n+\n+/* OpenMP 4.5:\n+   hint ( expression ) */\n+\n+static tree\n+cp_parser_omp_clause_hint (cp_parser *parser, tree list,\n+\t\t\t   location_t location)\n+{\n+  tree t, c;\n+\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+    return list;\n+\n+  t = cp_parser_expression (parser);\n+\n+  if (t == error_mark_node\n+      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_HINT, \"hint\", location);\n+\n+  c = build_omp_clause (location, OMP_CLAUSE_HINT);\n+  OMP_CLAUSE_HINT_EXPR (c) = t;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+\n+  return c;\n+}\n+\n+/* OpenMP 4.5:\n+   defaultmap ( tofrom : scalar ) */\n+\n+static tree\n+cp_parser_omp_clause_defaultmap (cp_parser *parser, tree list,\n+\t\t\t\t location_t location)\n+{\n+  tree c, id;\n+  const char *p;\n+\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+    return list;\n+\n+  if (!cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      cp_parser_error (parser, \"expected %<tofrom%>\");\n+      goto out_err;\n+    }\n+  id = cp_lexer_peek_token (parser->lexer)->u.value;\n+  p = IDENTIFIER_POINTER (id);\n+  if (strcmp (p, \"tofrom\") != 0)\n+    {\n+      cp_parser_error (parser, \"expected %<tofrom%>\");\n+      goto out_err;\n+    }\n+  cp_lexer_consume_token (parser->lexer);\n+  if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n+    goto out_err;\n+\n+  if (!cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      cp_parser_error (parser, \"expected %<scalar%>\");\n+      goto out_err;\n+    }\n+  id = cp_lexer_peek_token (parser->lexer)->u.value;\n+  p = IDENTIFIER_POINTER (id);\n+  if (strcmp (p, \"scalar\") != 0)\n+    {\n+      cp_parser_error (parser, \"expected %<scalar%>\");\n+      goto out_err;\n+    }\n+  cp_lexer_consume_token (parser->lexer);\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+    goto out_err;\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_DEFAULTMAP, \"defaultmap\",\n+\t\t\t     location);\n+\n+  c = build_omp_clause (location, OMP_CLAUSE_DEFAULTMAP);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+\n+ out_err:\n+  cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t /*or_comma=*/false,\n+\t\t\t\t\t /*consume_paren=*/true);\n+  return list;\n+}\n+\n /* OpenACC:\n    num_workers ( expression ) */\n \n@@ -29917,18 +30275,49 @@ cp_parser_omp_clause_num_workers (cp_parser *parser, tree list)\n }\n \n /* OpenMP 2.5:\n-   ordered */\n+   ordered\n+\n+   OpenMP 4.5:\n+   ordered ( constant-expression ) */\n \n static tree\n-cp_parser_omp_clause_ordered (cp_parser * /*parser*/,\n+cp_parser_omp_clause_ordered (cp_parser *parser,\n \t\t\t      tree list, location_t location)\n {\n-  tree c;\n+  tree c, num = NULL_TREE;\n+  HOST_WIDE_INT n;\n \n   check_no_duplicate_clause (list, OMP_CLAUSE_ORDERED,\n \t\t\t     \"ordered\", location);\n \n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      num = cp_parser_constant_expression (parser);\n+\n+      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+\tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t       /*or_comma=*/false,\n+\t\t\t\t\t       /*consume_paren=*/true);\n+\n+      if (num == error_mark_node)\n+\treturn list;\n+      num = fold_non_dependent_expr (num);\n+      if (!tree_fits_shwi_p (num)\n+\t  || !INTEGRAL_TYPE_P (TREE_TYPE (num))\n+\t  || (n = tree_to_shwi (num)) <= 0\n+\t  || (int) n != n)\n+\t{\n+\t  error_at (location,\n+\t\t    \"ordered argument needs positive constant integer \"\n+\t\t    \"expression\");\n+\t  return list;\n+\t}\n+    }\n+\n   c = build_omp_clause (location, OMP_CLAUSE_ORDERED);\n+  OMP_CLAUSE_ORDERED_EXPR (c) = num;\n   OMP_CLAUSE_CHAIN (c) = list;\n   return c;\n }\n@@ -30047,7 +30436,14 @@ cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n    schedule ( schedule-kind , expression )\n \n    schedule-kind:\n-     static | dynamic | guided | runtime | auto  */\n+     static | dynamic | guided | runtime | auto\n+\n+   OpenMP 4.5:\n+   schedule ( schedule-modifier : schedule-kind )\n+   schedule ( schedule-modifier : schedule-kind , expression )\n+\n+   schedule-modifier:\n+     simd  */\n \n static tree\n cp_parser_omp_clause_schedule (cp_parser *parser, tree list, location_t location)\n@@ -30059,6 +30455,19 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list, location_t location\n \n   c = build_omp_clause (location, OMP_CLAUSE_SCHEDULE);\n \n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+      if (strcmp (\"simd\", p) == 0\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_COLON))\n+\t{\n+\t  OMP_CLAUSE_SCHEDULE_SIMD (c) = 1;\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t}\n+    }\n+\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n@@ -30180,6 +30589,34 @@ cp_parser_omp_clause_cancelkind (cp_parser * /*parser*/,\n   return c;\n }\n \n+/* OpenMP 4.5:\n+   nogroup */\n+\n+static tree\n+cp_parser_omp_clause_nogroup (cp_parser * /*parser*/,\n+\t\t\t      tree list, location_t location)\n+{\n+  check_no_duplicate_clause (list, OMP_CLAUSE_NOGROUP, \"nogroup\", location);\n+  tree c = build_omp_clause (location, OMP_CLAUSE_NOGROUP);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+}\n+\n+/* OpenMP 4.5:\n+   simd\n+   threads */\n+\n+static tree\n+cp_parser_omp_clause_orderedkind (cp_parser * /*parser*/,\n+\t\t\t\t  enum omp_clause_code code,\n+\t\t\t\t  tree list, location_t location)\n+{\n+  check_no_duplicate_clause (list, code, omp_clause_code_name[code], location);\n+  tree c = build_omp_clause (location, code);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+}\n+\n /* OpenMP 4.0:\n    num_teams ( expression ) */\n \n@@ -30277,20 +30714,55 @@ cp_parser_omp_clause_aligned (cp_parser *parser, tree list)\n \n /* OpenMP 4.0:\n    linear ( variable-list )\n-   linear ( variable-list : expression )  */\n+   linear ( variable-list : expression )\n+\n+   OpenMP 4.5:\n+   linear ( modifier ( variable-list ) )\n+   linear ( modifier ( variable-list ) : expression ) */\n \n static tree\n cp_parser_omp_clause_linear (cp_parser *parser, tree list, \n \t\t\t     bool is_cilk_simd_fn)\n {\n   tree nlist, c, step = integer_one_node;\n   bool colon;\n+  enum omp_clause_linear_kind kind = OMP_CLAUSE_LINEAR_DEFAULT;\n \n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n-  nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_LINEAR, list,\n-\t\t\t\t\t  &colon);\n+  if (!is_cilk_simd_fn\n+      && cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+\n+      if (strcmp (\"ref\", p) == 0)\n+\tkind = OMP_CLAUSE_LINEAR_REF;\n+      else if (strcmp (\"val\", p) == 0)\n+\tkind = OMP_CLAUSE_LINEAR_VAL;\n+      else if (strcmp (\"uval\", p) == 0)\n+\tkind = OMP_CLAUSE_LINEAR_UVAL;\n+      if (cp_lexer_nth_token_is (parser->lexer, 2, CPP_OPEN_PAREN))\n+\tcp_lexer_consume_token (parser->lexer);\n+      else\n+\tkind = OMP_CLAUSE_LINEAR_DEFAULT;\n+    }\n+\n+  if (kind == OMP_CLAUSE_LINEAR_DEFAULT)\n+    nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_LINEAR, list,\n+\t\t\t\t\t    &colon);\n+  else\n+    {\n+      nlist = cp_parser_omp_var_list (parser, OMP_CLAUSE_LINEAR, list);\n+      colon = cp_lexer_next_token_is (parser->lexer, CPP_COLON);\n+      if (colon)\n+\tcp_parser_require (parser, CPP_COLON, RT_COLON);\n+      else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+\tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t       /*or_comma=*/false,\n+\t\t\t\t\t       /*consume_paren=*/true);\n+    }\n \n   if (colon)\n     {\n@@ -30311,7 +30783,10 @@ cp_parser_omp_clause_linear (cp_parser *parser, tree list,\n     }\n \n   for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))\n-    OMP_CLAUSE_LINEAR_STEP (c) = step;\n+    {\n+      OMP_CLAUSE_LINEAR_STEP (c) = step;\n+      OMP_CLAUSE_LINEAR_KIND (c) = kind;\n+    }\n \n   return nlist;\n }\n@@ -30365,23 +30840,113 @@ cp_parser_omp_clause_simdlen (cp_parser *parser, tree list,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n \n-  check_no_duplicate_clause (list, OMP_CLAUSE_SIMDLEN, \"simdlen\", location);\n+  check_no_duplicate_clause (list, OMP_CLAUSE_SIMDLEN, \"simdlen\", location);\n+\n+  c = build_omp_clause (location, OMP_CLAUSE_SIMDLEN);\n+  OMP_CLAUSE_SIMDLEN_EXPR (c) = t;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+\n+  return c;\n+}\n+\n+/* OpenMP 4.5:\n+   vec:\n+     identifier [+/- integer]\n+     vec , identifier [+/- integer]\n+*/\n+\n+static tree\n+cp_parser_omp_clause_depend_sink (cp_parser *parser, location_t clause_loc,\n+\t\t\t\t  tree list)\n+{\n+  tree vec = NULL;\n+\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n+    {\n+      cp_parser_error (parser, \"expected identifier\");\n+      return list;\n+    }\n+\n+  while (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      location_t id_loc = cp_lexer_peek_token (parser->lexer)->location;\n+      tree t, identifier = cp_parser_identifier (parser);\n+      tree addend = NULL;\n+\n+      if (identifier == error_mark_node)\n+\tt = error_mark_node;\n+      else\n+\t{\n+\t  t = cp_parser_lookup_name_simple\n+\t\t(parser, identifier,\n+\t\t cp_lexer_peek_token (parser->lexer)->location);\n+\t  if (t == error_mark_node)\n+\t    cp_parser_name_lookup_error (parser, identifier, t, NLE_NULL,\n+\t\t\t\t\t id_loc);\n+\t}\n+\n+      bool neg = false;\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_MINUS))\n+\tneg = true;\n+      else if (!cp_lexer_next_token_is (parser->lexer, CPP_PLUS))\n+\t{\n+\t  addend = integer_zero_node;\n+\t  goto add_to_vector;\n+\t}\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_NUMBER))\n+\t{\n+\t  cp_parser_error (parser, \"expected integer\");\n+\t  return list;\n+\t}\n+\n+      addend = cp_lexer_peek_token (parser->lexer)->u.value;\n+      if (TREE_CODE (addend) != INTEGER_CST)\n+\t{\n+\t  cp_parser_error (parser, \"expected integer\");\n+\t  return list;\n+\t}\n+      cp_lexer_consume_token (parser->lexer);\n+\n+    add_to_vector:\n+      if (t != error_mark_node)\n+\t{\n+\t  vec = tree_cons (addend, t, vec);\n+\t  if (neg)\n+\t    OMP_CLAUSE_DEPEND_SINK_NEGATIVE (vec) = 1;\n+\t}\n \n-  c = build_omp_clause (location, OMP_CLAUSE_SIMDLEN);\n-  OMP_CLAUSE_SIMDLEN_EXPR (c) = t;\n-  OMP_CLAUSE_CHAIN (c) = list;\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA))\n+\tbreak;\n \n-  return c;\n+      cp_lexer_consume_token (parser->lexer);\n+    }\n+\n+  if (cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN) && vec)\n+    {\n+      tree u = build_omp_clause (clause_loc, OMP_CLAUSE_DEPEND);\n+      OMP_CLAUSE_DEPEND_KIND (u) = OMP_CLAUSE_DEPEND_SINK;\n+      OMP_CLAUSE_DECL (u) = nreverse (vec);\n+      OMP_CLAUSE_CHAIN (u) = list;\n+      return u;\n+    }\n+  return list;\n }\n \n /* OpenMP 4.0:\n    depend ( depend-kind : variable-list )\n \n    depend-kind:\n-     in | out | inout  */\n+     in | out | inout\n+\n+   OpenMP 4.5:\n+   depend ( source )\n+\n+   depend ( sink : vec ) */\n \n static tree\n-cp_parser_omp_clause_depend (cp_parser *parser, tree list)\n+cp_parser_omp_clause_depend (cp_parser *parser, tree list, location_t loc)\n {\n   tree nlist, c;\n   enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_INOUT;\n@@ -30400,22 +30965,44 @@ cp_parser_omp_clause_depend (cp_parser *parser, tree list)\n \tkind = OMP_CLAUSE_DEPEND_INOUT;\n       else if (strcmp (\"out\", p) == 0)\n \tkind = OMP_CLAUSE_DEPEND_OUT;\n+      else if (strcmp (\"source\", p) == 0)\n+\tkind = OMP_CLAUSE_DEPEND_SOURCE;\n+      else if (strcmp (\"sink\", p) == 0)\n+\tkind = OMP_CLAUSE_DEPEND_SINK;\n       else\n \tgoto invalid_kind;\n     }\n   else\n     goto invalid_kind;\n \n   cp_lexer_consume_token (parser->lexer);\n+\n+  if (kind == OMP_CLAUSE_DEPEND_SOURCE)\n+    {\n+      c = build_omp_clause (loc, OMP_CLAUSE_DEPEND);\n+      OMP_CLAUSE_DEPEND_KIND (c) = kind;\n+      OMP_CLAUSE_DECL (c) = NULL_TREE;\n+      OMP_CLAUSE_CHAIN (c) = list;\n+      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+\tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t       /*or_comma=*/false,\n+\t\t\t\t\t       /*consume_paren=*/true);\n+      return c;\n+    }\n+\n   if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n     goto resync_fail;\n \n-  nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_DEPEND, list,\n-\t\t\t\t\t  NULL);\n-\n-  for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))\n-    OMP_CLAUSE_DEPEND_KIND (c) = kind;\n+  if (kind == OMP_CLAUSE_DEPEND_SINK)\n+    nlist = cp_parser_omp_clause_depend_sink (parser, loc, list);\n+  else\n+    {\n+      nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_DEPEND,\n+\t\t\t\t\t      list, NULL);\n \n+      for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))\n+\tOMP_CLAUSE_DEPEND_KIND (c) = kind;\n+    }\n   return nlist;\n \n  invalid_kind:\n@@ -30432,17 +31019,48 @@ cp_parser_omp_clause_depend (cp_parser *parser, tree list)\n    map ( variable-list )\n \n    map-kind:\n-     alloc | to | from | tofrom  */\n+     alloc | to | from | tofrom\n+\n+   OpenMP 4.5:\n+   map-kind:\n+     alloc | to | from | tofrom | release | delete\n+\n+   map ( always [,] map-kind: variable-list ) */\n \n static tree\n cp_parser_omp_clause_map (cp_parser *parser, tree list)\n {\n   tree nlist, c;\n   enum gomp_map_kind kind = GOMP_MAP_TOFROM;\n+  bool always = false;\n \n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+\n+      if (strcmp (\"always\", p) == 0)\n+\t{\n+\t  int nth = 2;\n+\t  if (cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_COMMA)\n+\t    nth++;\n+\t  if ((cp_lexer_peek_nth_token (parser->lexer, nth)->type == CPP_NAME\n+\t       || (cp_lexer_peek_nth_token (parser->lexer, nth)->keyword\n+\t\t   == RID_DELETE))\n+\t      && (cp_lexer_peek_nth_token (parser->lexer, nth + 1)->type\n+\t\t  == CPP_COLON))\n+\t    {\n+\t      always = true;\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      if (nth == 3)\n+\t\tcp_lexer_consume_token (parser->lexer);\n+\t    }\n+\t}\n+    }\n+\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n       && cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_COLON)\n     {\n@@ -30452,11 +31070,13 @@ cp_parser_omp_clause_map (cp_parser *parser, tree list)\n       if (strcmp (\"alloc\", p) == 0)\n \tkind = GOMP_MAP_ALLOC;\n       else if (strcmp (\"to\", p) == 0)\n-\tkind = GOMP_MAP_TO;\n+\tkind = always ? GOMP_MAP_ALWAYS_TO : GOMP_MAP_TO;\n       else if (strcmp (\"from\", p) == 0)\n-\tkind = GOMP_MAP_FROM;\n+\tkind = always ? GOMP_MAP_ALWAYS_FROM : GOMP_MAP_FROM;\n       else if (strcmp (\"tofrom\", p) == 0)\n-\tkind = GOMP_MAP_TOFROM;\n+\tkind = always ? GOMP_MAP_ALWAYS_TOFROM : GOMP_MAP_TOFROM;\n+      else if (strcmp (\"release\", p) == 0)\n+\tkind = GOMP_MAP_RELEASE;\n       else\n \t{\n \t  cp_parser_error (parser, \"invalid map kind\");\n@@ -30468,6 +31088,13 @@ cp_parser_omp_clause_map (cp_parser *parser, tree list)\n       cp_lexer_consume_token (parser->lexer);\n       cp_lexer_consume_token (parser->lexer);\n     }\n+  else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_DELETE)\n+\t   && cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_COLON)\n+    {\n+      kind = GOMP_MAP_DELETE;\n+      cp_lexer_consume_token (parser->lexer);\n+      cp_lexer_consume_token (parser->lexer);\n+    }\n \n   nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_MAP, list,\n \t\t\t\t\t  NULL);\n@@ -30710,7 +31337,7 @@ cp_parser_oacc_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  c_name = \"host\";\n \t  break;\n \tcase PRAGMA_OACC_CLAUSE_IF:\n-\t  clauses = cp_parser_omp_clause_if (parser, clauses, here);\n+\t  clauses = cp_parser_omp_clause_if (parser, clauses, here, false);\n \t  c_name = \"if\";\n \t  break;\n \tcase PRAGMA_OACC_CLAUSE_NUM_GANGS:\n@@ -30777,7 +31404,7 @@ cp_parser_oacc_all_clauses (cp_parser *parser, omp_clause_mask mask,\n   cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n \n   if (finish_p)\n-    return finish_omp_clauses (clauses);\n+    return finish_omp_clauses (clauses, false);\n \n   return clauses;\n }\n@@ -30838,8 +31465,34 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t\t\t\t\t    clauses);\n \t  c_name = \"firstprivate\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_GRAINSIZE:\n+\t  clauses = cp_parser_omp_clause_grainsize (parser, clauses,\n+\t\t\t\t\t\t    token->location);\n+\t  c_name = \"grainsize\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_HINT:\n+\t  clauses = cp_parser_omp_clause_hint (parser, clauses,\n+\t\t\t\t\t       token->location);\n+\t  c_name = \"hint\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_DEFAULTMAP:\n+\t  clauses = cp_parser_omp_clause_defaultmap (parser, clauses,\n+\t\t\t\t\t\t     token->location);\n+\t  c_name = \"defaultmap\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR:\n+\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_USE_DEVICE_PTR,\n+\t\t\t\t\t    clauses);\n+\t  c_name = \"use_device_ptr\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR:\n+\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_IS_DEVICE_PTR,\n+\t\t\t\t\t    clauses);\n+\t  c_name = \"is_device_ptr\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_IF:\n-\t  clauses = cp_parser_omp_clause_if (parser, clauses, token->location);\n+\t  clauses = cp_parser_omp_clause_if (parser, clauses, token->location,\n+\t\t\t\t\t     true);\n \t  c_name = \"if\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_LASTPRIVATE:\n@@ -30856,6 +31509,11 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  clauses = cp_parser_omp_clause_nowait (parser, clauses, token->location);\n \t  c_name = \"nowait\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_NUM_TASKS:\n+\t  clauses = cp_parser_omp_clause_num_tasks (parser, clauses,\n+\t\t\t\t\t\t    token->location);\n+\t  c_name = \"num_tasks\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_NUM_THREADS:\n \t  clauses = cp_parser_omp_clause_num_threads (parser, clauses,\n \t\t\t\t\t\t      token->location);\n@@ -30866,6 +31524,11 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t\t\t\t\t\t  token->location);\n \t  c_name = \"ordered\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_PRIORITY:\n+\t  clauses = cp_parser_omp_clause_priority (parser, clauses,\n+\t\t\t\t\t\t   token->location);\n+\t  c_name = \"priority\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_PRIVATE:\n \t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_PRIVATE,\n \t\t\t\t\t    clauses);\n@@ -30936,14 +31599,20 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  if (!first)\n \t    goto clause_not_first;\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_LINK:\n+\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_LINK, clauses);\n+\t  c_name = \"to\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_TO:\n-\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_TO,\n-\t\t\t\t\t    clauses);\n+\t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LINK)) != 0)\n+\t    clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_TO_DECLARE,\n+\t\t\t\t\t      clauses);\n+\t  else\n+\t    clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_TO, clauses);\n \t  c_name = \"to\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_FROM:\n-\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_FROM,\n-\t\t\t\t\t    clauses);\n+\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_FROM, clauses);\n \t  c_name = \"from\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_UNIFORM:\n@@ -30972,7 +31641,8 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  c_name = \"linear\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_DEPEND:\n-\t  clauses = cp_parser_omp_clause_depend (parser, clauses);\n+\t  clauses = cp_parser_omp_clause_depend (parser, clauses,\n+\t\t\t\t\t\t token->location);\n \t  c_name = \"depend\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_MAP:\n@@ -31004,6 +31674,23 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t\t\t\t\t\t  token->location);\n \t  c_name = \"simdlen\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_NOGROUP:\n+\t  clauses = cp_parser_omp_clause_nogroup (parser, clauses,\n+\t\t\t\t\t\t  token->location);\n+\t  c_name = \"nogroup\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_THREADS:\n+\t  clauses\n+\t    = cp_parser_omp_clause_orderedkind (parser, OMP_CLAUSE_THREADS,\n+\t\t\t\t\t\tclauses, token->location);\n+\t  c_name = \"threads\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_SIMD:\n+\t  clauses\n+\t    = cp_parser_omp_clause_orderedkind (parser, OMP_CLAUSE_SIMD,\n+\t\t\t\t\t\tclauses, token->location);\n+\t  c_name = \"simd\";\n+\t  break;\n \tcase PRAGMA_CILK_CLAUSE_VECTORLENGTH:\n \t  clauses = cp_parser_cilk_simd_vectorlength (parser, clauses, true);\n \t  c_name = \"simdlen\";\n@@ -31029,7 +31716,12 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n   if (!(flag_cilkplus && pragma_tok == NULL))\n     cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n   if (finish_p)\n-    return finish_omp_clauses (clauses);\n+    {\n+      if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_UNIFORM)) != 0)\n+\treturn finish_omp_clauses (clauses, false, true);\n+      else\n+\treturn finish_omp_clauses (clauses, true);\n+    }\n   return clauses;\n }\n \n@@ -31522,12 +32214,19 @@ cp_parser_omp_barrier (cp_parser *parser, cp_token *pragma_tok)\n \n /* OpenMP 2.5:\n    # pragma omp critical [(name)] new-line\n+     structured-block\n+\n+   OpenMP 4.5:\n+   # pragma omp critical [(name) [hint(expression)]] new-line\n      structured-block  */\n \n+#define OMP_CRITICAL_CLAUSE_MASK\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_HINT) )\n+\n static tree\n cp_parser_omp_critical (cp_parser *parser, cp_token *pragma_tok)\n {\n-  tree stmt, name = NULL;\n+  tree stmt, name = NULL_TREE, clauses = NULL_TREE;\n \n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n@@ -31542,11 +32241,16 @@ cp_parser_omp_critical (cp_parser *parser, cp_token *pragma_tok)\n \t\t\t\t\t       /*consume_paren=*/true);\n       if (name == error_mark_node)\n \tname = NULL;\n+\n+      clauses = cp_parser_omp_all_clauses (parser,\n+\t\t\t\t\t   OMP_CRITICAL_CLAUSE_MASK,\n+\t\t\t\t\t   \"#pragma omp critical\", pragma_tok);\n     }\n-  cp_parser_require_pragma_eol (parser, pragma_tok);\n+  else\n+    cp_parser_require_pragma_eol (parser, pragma_tok);\n \n   stmt = cp_parser_omp_structured_block (parser);\n-  return c_finish_omp_critical (input_location, stmt, name);\n+  return c_finish_omp_critical (input_location, stmt, name, clauses);\n }\n \n /* OpenMP 2.5:\n@@ -31624,13 +32328,15 @@ cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n \t    ? PREINCREMENT_EXPR : PREDECREMENT_EXPR);\n       cp_lexer_consume_token (parser->lexer);\n       lhs = cp_parser_simple_cast_expression (parser);\n-      if (lhs != decl)\n+      if (lhs != decl\n+\t  && (!processing_template_decl || !cp_tree_equal (lhs, decl)))\n \treturn error_mark_node;\n       return build2 (op, TREE_TYPE (decl), decl, NULL_TREE);\n     }\n \n   lhs = cp_parser_primary_expression (parser, false, false, false, &idk);\n-  if (lhs != decl)\n+  if (lhs != decl\n+      && (!processing_template_decl || !cp_tree_equal (lhs, decl)))\n     return error_mark_node;\n \n   token = cp_lexer_peek_token (parser->lexer);\n@@ -31656,7 +32362,8 @@ cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n   lhs = cp_parser_binary_expression (parser, false, false,\n \t\t\t\t     PREC_ADDITIVE_EXPRESSION, NULL);\n   token = cp_lexer_peek_token (parser->lexer);\n-  decl_first = lhs == decl;\n+  decl_first = (lhs == decl\n+\t\t|| (processing_template_decl && cp_tree_equal (lhs, decl)));\n   if (decl_first)\n     lhs = NULL_TREE;\n   if (token->type != CPP_PLUS\n@@ -31689,7 +32396,9 @@ cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n \n   if (!decl_first)\n     {\n-      if (rhs != decl || op == MINUS_EXPR)\n+      if ((rhs != decl\n+\t   && (!processing_template_decl || !cp_tree_equal (rhs, decl)))\n+\t  || op == MINUS_EXPR)\n \treturn error_mark_node;\n       rhs = build2 (op, TREE_TYPE (decl), lhs, decl);\n     }\n@@ -31705,7 +32414,7 @@ cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n    Return true if the resulting construct should have an\n    OMP_CLAUSE_PRIVATE added to it.  */\n \n-static bool\n+static tree\n cp_parser_omp_for_loop_init (cp_parser *parser,\n \t\t\t     enum tree_code code,\n \t\t\t     tree &this_pre_body,\n@@ -31715,9 +32424,9 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \t\t\t     tree &real_decl)\n {\n   if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n-    return false;\n+    return NULL_TREE;\n \n-  bool add_private_clause = false;\n+  tree add_private_clause = NULL_TREE;\n \n   /* See 2.5.1 (in OpenMP 3.0, similar wording is in 2.5 standard too):\n \n@@ -31848,6 +32557,33 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n       cp_parser_parse_tentatively (parser);\n       decl = cp_parser_primary_expression (parser, false, false,\n \t\t\t\t\t   false, &idk);\n+      cp_token *last_tok = cp_lexer_peek_token (parser->lexer);\n+      if (!cp_parser_error_occurred (parser)\n+\t  && decl\n+\t  && (TREE_CODE (decl) == COMPONENT_REF\n+\t      || (TREE_CODE (decl) == SCOPE_REF && TREE_TYPE (decl))))\n+\t{\n+\t  cp_parser_abort_tentative_parse (parser);\n+\t  cp_parser_parse_tentatively (parser);\n+\t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\t  tree name = cp_parser_id_expression (parser, /*template_p=*/false,\n+\t\t\t\t\t       /*check_dependency_p=*/true,\n+\t\t\t\t\t       /*template_p=*/NULL,\n+\t\t\t\t\t       /*declarator_p=*/false,\n+\t\t\t\t\t       /*optional_p=*/false);\n+\t  if (name != error_mark_node\n+\t      && last_tok == cp_lexer_peek_token (parser->lexer))\n+\t    {\n+\t      decl = cp_parser_lookup_name_simple (parser, name,\n+\t\t\t\t\t\t   token->location);\n+\t      if (TREE_CODE (decl) == FIELD_DECL)\n+\t\tadd_private_clause = omp_privatize_field (decl);\n+\t    }\n+\t  cp_parser_abort_tentative_parse (parser);\n+\t  cp_parser_parse_tentatively (parser);\n+\t  decl = cp_parser_primary_expression (parser, false, false,\n+\t\t\t\t\t       false, &idk);\n+\t}\n       if (!cp_parser_error_occurred (parser)\n \t  && decl\n \t  && DECL_P (decl)\n@@ -31862,7 +32598,8 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \t\t\t\t\t\t decl, NOP_EXPR,\n \t\t\t\t\t\t rhs,\n \t\t\t\t\t\t tf_warning_or_error));\n-\t  add_private_clause = true;\n+\t  if (!add_private_clause)\n+\t    add_private_clause = decl;\n \t}\n       else\n \t{\n@@ -31888,29 +32625,58 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n {\n   tree init, cond, incr, body, decl, pre_body = NULL_TREE, ret;\n   tree real_decl, initv, condv, incrv, declv;\n-  tree this_pre_body, cl;\n+  tree this_pre_body, cl, ordered_cl = NULL_TREE;\n   location_t loc_first;\n   bool collapse_err = false;\n-  int i, collapse = 1, nbraces = 0;\n+  int i, collapse = 1, ordered = 0, count, nbraces = 0;\n   vec<tree, va_gc> *for_block = make_tree_vector ();\n \n   for (cl = clauses; cl; cl = OMP_CLAUSE_CHAIN (cl))\n     if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_COLLAPSE)\n       collapse = tree_to_shwi (OMP_CLAUSE_COLLAPSE_EXPR (cl));\n+    else if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_ORDERED\n+\t     && OMP_CLAUSE_ORDERED_EXPR (cl))\n+      {\n+\tordered_cl = cl;\n+\tordered = tree_to_shwi (OMP_CLAUSE_ORDERED_EXPR (cl));\n+      }\n+\n+  if (ordered && ordered < collapse)\n+    {\n+      error_at (OMP_CLAUSE_LOCATION (ordered_cl),\n+\t\t\"%<ordered%> clause parameter is less than %<collapse%>\");\n+      OMP_CLAUSE_ORDERED_EXPR (ordered_cl)\n+\t= build_int_cst (NULL_TREE, collapse);\n+      ordered = collapse;\n+    }\n+  if (ordered)\n+    {\n+      for (tree *pc = &clauses; *pc; )\n+\tif (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_LINEAR)\n+\t  {\n+\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n+\t\t      \"%<linear%> clause may not be specified together \"\n+\t\t      \"with %<ordered%> clause with a parameter\");\n+\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n+\t  }\n+\telse\n+\t  pc = &OMP_CLAUSE_CHAIN (*pc);\n+    }\n \n-  gcc_assert (collapse >= 1);\n+  gcc_assert (collapse >= 1 && ordered >= 0);\n+  count = ordered ? ordered : collapse;\n \n-  declv = make_tree_vec (collapse);\n-  initv = make_tree_vec (collapse);\n-  condv = make_tree_vec (collapse);\n-  incrv = make_tree_vec (collapse);\n+  declv = make_tree_vec (count);\n+  initv = make_tree_vec (count);\n+  condv = make_tree_vec (count);\n+  incrv = make_tree_vec (count);\n \n   loc_first = cp_lexer_peek_token (parser->lexer)->location;\n \n-  for (i = 0; i < collapse; i++)\n+  for (i = 0; i < count; i++)\n     {\n       int bracecount = 0;\n-      bool add_private_clause = false;\n+      tree add_private_clause = NULL_TREE;\n       location_t loc;\n \n       if (code != CILK_FOR\n@@ -31934,9 +32700,9 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n       this_pre_body = push_stmt_list ();\n \n       add_private_clause\n-\t|= cp_parser_omp_for_loop_init (parser, code,\n-\t\t\t\t\tthis_pre_body, for_block,\n-\t\t\t\t\tinit, decl, real_decl);\n+\t= cp_parser_omp_for_loop_init (parser, code,\n+\t\t\t\t       this_pre_body, for_block,\n+\t\t\t\t       init, decl, real_decl);\n \n       cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n       if (this_pre_body)\n@@ -31985,13 +32751,13 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t\t    OMP_CLAUSE_CHAIN (l) = clauses;\n \t\t    clauses = l;\n \t\t  }\n-\t\tadd_private_clause = false;\n+\t\tadd_private_clause = NULL_TREE;\n \t      }\n \t    else\n \t      {\n \t\tif (OMP_CLAUSE_CODE (*c) == OMP_CLAUSE_PRIVATE\n \t\t    && OMP_CLAUSE_DECL (*c) == real_decl)\n-\t\t  add_private_clause = false;\n+\t\t  add_private_clause = NULL_TREE;\n \t\tc = &OMP_CLAUSE_CHAIN (*c);\n \t      }\n \t}\n@@ -32017,13 +32783,22 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t    }\n \t  if (c == NULL)\n \t    {\n-\t      c = build_omp_clause (loc, OMP_CLAUSE_PRIVATE);\n-\t      OMP_CLAUSE_DECL (c) = decl;\n-\t      c = finish_omp_clauses (c);\n+\t      if (code != OMP_SIMD)\n+\t\tc = build_omp_clause (loc, OMP_CLAUSE_PRIVATE);\n+\t      else if (collapse == 1)\n+\t\tc = build_omp_clause (loc, OMP_CLAUSE_LINEAR);\n+\t      else\n+\t\tc = build_omp_clause (loc, OMP_CLAUSE_LASTPRIVATE);\n+\t      OMP_CLAUSE_DECL (c) = add_private_clause;\n+\t      c = finish_omp_clauses (c, true);\n \t      if (c)\n \t\t{\n \t\t  OMP_CLAUSE_CHAIN (c) = clauses;\n \t\t  clauses = c;\n+\t\t  /* For linear, signal that we need to fill up\n+\t\t     the so far unknown linear step.  */\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR)\n+\t\t    OMP_CLAUSE_LINEAR_STEP (c) = NULL_TREE;\n \t\t}\n \t    }\n \t}\n@@ -32040,7 +32815,8 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t     until finish_omp_for.  */\n \t  if (real_decl\n \t      && ((processing_template_decl\n-\t\t   && !POINTER_TYPE_P (TREE_TYPE (real_decl)))\n+\t\t   && (TREE_TYPE (real_decl) == NULL_TREE\n+\t\t       || !POINTER_TYPE_P (TREE_TYPE (real_decl))))\n \t\t  || CLASS_TYPE_P (TREE_TYPE (real_decl))))\n \t    incr = cp_parser_omp_for_incr (parser, real_decl);\n \t  else\n@@ -32059,7 +32835,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n       TREE_VEC_ELT (condv, i) = cond;\n       TREE_VEC_ELT (incrv, i) = incr;\n \n-      if (i == collapse - 1)\n+      if (i == count - 1)\n \tbreak;\n \n       /* FIXME: OpenMP 3.0 draft isn't very clear on what exactly is allowed\n@@ -32114,8 +32890,8 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n   if (declv == NULL_TREE)\n     ret = NULL_TREE;\n   else\n-    ret = finish_omp_for (loc_first, code, declv, initv, condv, incrv, body,\n-\t\t\t  pre_body, clauses);\n+    ret = finish_omp_for (loc_first, code, declv, NULL, initv, condv, incrv,\n+\t\t\t  body, pre_body, clauses);\n \n   while (nbraces)\n     {\n@@ -32158,7 +32934,7 @@ cp_omp_split_clauses (location_t loc, enum tree_code code,\n   c_omp_split_clauses (loc, code, mask, clauses, cclauses);\n   for (i = 0; i < C_OMP_CLAUSE_SPLIT_COUNT; i++)\n     if (cclauses[i])\n-      cclauses[i] = finish_omp_clauses (cclauses[i]);\n+      cclauses[i] = finish_omp_clauses (cclauses[i], true);\n }\n \n /* OpenMP 4.0:\n@@ -32167,6 +32943,7 @@ cp_omp_split_clauses (location_t loc, enum tree_code code,\n \n #define OMP_SIMD_CLAUSE_MASK\t\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SAFELEN)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SIMDLEN)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LINEAR)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALIGNED)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n@@ -32184,14 +32961,22 @@ cp_parser_omp_simd (cp_parser *parser, cp_token *pragma_tok,\n \n   strcat (p_name, \" simd\");\n   mask |= OMP_SIMD_CLAUSE_MASK;\n-  mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ORDERED);\n \n   clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,\n \t\t\t\t       cclauses == NULL);\n   if (cclauses)\n     {\n       cp_omp_split_clauses (loc, OMP_SIMD, mask, clauses, cclauses);\n       clauses = cclauses[C_OMP_CLAUSE_SPLIT_SIMD];\n+      tree c = find_omp_clause (cclauses[C_OMP_CLAUSE_SPLIT_FOR],\n+\t\t\t\tOMP_CLAUSE_ORDERED);\n+      if (c && OMP_CLAUSE_ORDERED_EXPR (c))\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"%<ordered%> clause with parameter may not be specified \"\n+\t\t    \"on %qs construct\", p_name);\n+\t  OMP_CLAUSE_ORDERED_EXPR (c) = NULL_TREE;\n+\t}\n     }\n \n   sb = begin_omp_structured_block ();\n@@ -32217,6 +33002,7 @@ cp_parser_omp_simd (cp_parser *parser, cp_token *pragma_tok,\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LINEAR)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ORDERED)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE)\t\\\n@@ -32235,6 +33021,9 @@ cp_parser_omp_for (cp_parser *parser, cp_token *pragma_tok,\n   mask |= OMP_FOR_CLAUSE_MASK;\n   if (cclauses)\n     mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT);\n+  /* Composite distribute parallel for{, simd} disallows ordered clause.  */\n+  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) != 0)\n+    mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ORDERED);\n \n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n@@ -32274,6 +33063,10 @@ cp_parser_omp_for (cp_parser *parser, cp_token *pragma_tok,\n       return NULL_TREE;\n     }\n \n+  /* Composite distribute parallel for disallows linear clause.  */\n+  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) != 0)\n+    mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LINEAR);\n+\n   clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,\n \t\t\t\t       cclauses == NULL);\n   if (cclauses)\n@@ -32307,14 +33100,62 @@ cp_parser_omp_master (cp_parser *parser, cp_token *pragma_tok)\n \n /* OpenMP 2.5:\n    # pragma omp ordered new-line\n+     structured-block\n+\n+   OpenMP 4.5:\n+   # pragma omp ordered ordered-clauses new-line\n      structured-block  */\n \n-static tree\n-cp_parser_omp_ordered (cp_parser *parser, cp_token *pragma_tok)\n+#define OMP_ORDERED_CLAUSE_MASK\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_THREADS)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SIMD))\n+\n+#define OMP_ORDERED_DEPEND_CLAUSE_MASK\t\t\t\t\\\n+\t(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\n+\n+static bool\n+cp_parser_omp_ordered (cp_parser *parser, cp_token *pragma_tok,\n+\t\t       enum pragma_context context)\n {\n-  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n-  cp_parser_require_pragma_eol (parser, pragma_tok);\n-  return c_finish_omp_ordered (loc, cp_parser_omp_structured_block (parser));\n+  location_t loc = pragma_tok->location;\n+\n+  if (context != pragma_stmt && context != pragma_compound)\n+    {\n+      cp_parser_error (parser, \"expected declaration specifiers\");\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      return false;\n+    }\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+\n+      if (strcmp (p, \"depend\") == 0)\n+\t{\n+\t  if (context == pragma_stmt)\n+\t    {\n+\t      error_at (pragma_tok->location, \"%<#pragma omp ordered%> with \"\n+\t\t\t\"%<depend%> clause may only be used in compound \"\n+\t\t\t\"statements\");\n+\t      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+\t      return false;\n+\t    }\n+\t  tree clauses\n+\t    = cp_parser_omp_all_clauses (parser,\n+\t\t\t\t\t OMP_ORDERED_DEPEND_CLAUSE_MASK,\n+\t\t\t\t\t \"#pragma omp ordered\", pragma_tok);\n+\t  c_finish_omp_ordered (loc, clauses, NULL_TREE);\n+\t  return false;\n+\t}\n+    }\n+\n+  tree clauses\n+    = cp_parser_omp_all_clauses (parser, OMP_ORDERED_CLAUSE_MASK,\n+\t\t\t\t \"#pragma omp ordered\", pragma_tok);\n+  c_finish_omp_ordered (loc, clauses,\n+\t\t\tcp_parser_omp_structured_block (parser));\n+  return true;\n }\n \n /* OpenMP 2.5:\n@@ -32452,6 +33293,10 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,\n \n   strcat (p_name, \" parallel\");\n   mask |= OMP_PARALLEL_CLAUSE_MASK;\n+  /* #pragma omp target parallel{, for, for simd} disallow copyin clause.  */\n+  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP)) != 0\n+      && (mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) == 0)\n+    mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COPYIN);\n \n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_FOR))\n     {\n@@ -32473,7 +33318,11 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,\n       OMP_PARALLEL_COMBINED (stmt) = 1;\n       return stmt;\n     }\n-  else if (cclauses)\n+  /* When combined with distribute, parallel has to be followed by for.\n+     #pragma omp target parallel is allowed though.  */\n+  else if (cclauses\n+\t   && (mask & (OMP_CLAUSE_MASK_1\n+\t\t       << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) != 0)\n     {\n       error_at (loc, \"expected %<for%> after %qs\", p_name);\n       cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n@@ -32484,7 +33333,7 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,\n       cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n       return NULL_TREE;\n     }\n-  else if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+  else if (cclauses == NULL && cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n@@ -32506,6 +33355,11 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,\n     }\n \n   clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok);\n+  if (cclauses)\n+    {\n+      cp_omp_split_clauses (loc, OMP_PARALLEL, mask, clauses, cclauses);\n+      clauses = cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL];\n+    }\n \n   block = begin_omp_parallel ();\n   save = cp_parser_begin_omp_structured_block (parser);\n@@ -32552,7 +33406,8 @@ cp_parser_omp_single (cp_parser *parser, cp_token *pragma_tok)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SHARED)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FINAL)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MERGEABLE)\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY))\n \n static tree\n cp_parser_omp_task (cp_parser *parser, cp_token *pragma_tok)\n@@ -32780,91 +33635,305 @@ cp_parser_omp_distribute (cp_parser *parser, cp_token *pragma_tok,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_THREAD_LIMIT)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEFAULT))\n \n-static tree\n-cp_parser_omp_teams (cp_parser *parser, cp_token *pragma_tok,\n-\t\t     char *p_name, omp_clause_mask mask, tree *cclauses)\n-{\n-  tree clauses, sb, ret;\n-  unsigned int save;\n-  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+static tree\n+cp_parser_omp_teams (cp_parser *parser, cp_token *pragma_tok,\n+\t\t     char *p_name, omp_clause_mask mask, tree *cclauses)\n+{\n+  tree clauses, sb, ret;\n+  unsigned int save;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  strcat (p_name, \" teams\");\n+  mask |= OMP_TEAMS_CLAUSE_MASK;\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+      if (strcmp (p, \"distribute\") == 0)\n+\t{\n+\t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t  if (cclauses == NULL)\n+\t    cclauses = cclauses_buf;\n+\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (!flag_openmp)  /* flag_openmp_simd  */\n+\t    return cp_parser_omp_distribute (parser, pragma_tok, p_name, mask,\n+\t\t\t\t\t     cclauses);\n+\t  sb = begin_omp_structured_block ();\n+\t  save = cp_parser_begin_omp_structured_block (parser);\n+\t  ret = cp_parser_omp_distribute (parser, pragma_tok, p_name, mask,\n+\t\t\t\t\t  cclauses);\n+\t  cp_parser_end_omp_structured_block (parser, save);\n+\t  tree body = finish_omp_structured_block (sb);\n+\t  if (ret == NULL)\n+\t    return ret;\n+\t  clauses = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];\n+\t  ret = make_node (OMP_TEAMS);\n+\t  TREE_TYPE (ret) = void_type_node;\n+\t  OMP_TEAMS_CLAUSES (ret) = clauses;\n+\t  OMP_TEAMS_BODY (ret) = body;\n+\t  OMP_TEAMS_COMBINED (ret) = 1;\n+\t  return add_stmt (ret);\n+\t}\n+    }\n+  if (!flag_openmp)  /* flag_openmp_simd  */\n+    {\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      return NULL_TREE;\n+    }\n+\n+  clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,\n+\t\t\t\t       cclauses == NULL);\n+  if (cclauses)\n+    {\n+      cp_omp_split_clauses (loc, OMP_TEAMS, mask, clauses, cclauses);\n+      clauses = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];\n+    }\n+\n+  tree stmt = make_node (OMP_TEAMS);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_TEAMS_CLAUSES (stmt) = clauses;\n+  OMP_TEAMS_BODY (stmt) = cp_parser_omp_structured_block (parser);\n+\n+  return add_stmt (stmt);\n+}\n+\n+/* OpenMP 4.0:\n+   # pragma omp target data target-data-clause[optseq] new-line\n+     structured-block  */\n+\n+#define OMP_TARGET_DATA_CLAUSE_MASK\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEVICE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR))\n+\n+static tree\n+cp_parser_omp_target_data (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree clauses\n+    = cp_parser_omp_all_clauses (parser, OMP_TARGET_DATA_CLAUSE_MASK,\n+\t\t\t\t \"#pragma omp target data\", pragma_tok);\n+  int map_seen = 0;\n+  for (tree *pc = &clauses; *pc;)\n+    {\n+      if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)\n+\tswitch (OMP_CLAUSE_MAP_KIND (*pc))\n+\t  {\n+\t  case GOMP_MAP_TO:\n+\t  case GOMP_MAP_ALWAYS_TO:\n+\t  case GOMP_MAP_FROM:\n+\t  case GOMP_MAP_ALWAYS_FROM:\n+\t  case GOMP_MAP_TOFROM:\n+\t  case GOMP_MAP_ALWAYS_TOFROM:\n+\t  case GOMP_MAP_ALLOC:\n+\t    map_seen = 3;\n+\t    break;\n+\t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t    break;\n+\t  default:\n+\t    map_seen |= 1;\n+\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n+\t\t      \"%<#pragma omp target data%> with map-type other \"\n+\t\t      \"than %<to%>, %<from%>, %<tofrom%> or %<alloc%> \"\n+\t\t      \"on %<map%> clause\");\n+\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n+\t    continue;\n+\t  }\n+      pc = &OMP_CLAUSE_CHAIN (*pc);\n+    }\n+\n+  if (map_seen != 3)\n+    {\n+      if (map_seen == 0)\n+\terror_at (pragma_tok->location,\n+\t\t  \"%<#pragma omp target data%> must contain at least \"\n+\t\t  \"one %<map%> clause\");\n+      return NULL_TREE;\n+    }\n+\n+  tree stmt = make_node (OMP_TARGET_DATA);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_TARGET_DATA_CLAUSES (stmt) = clauses;\n+\n+  keep_next_level (true);\n+  OMP_TARGET_DATA_BODY (stmt) = cp_parser_omp_structured_block (parser);\n+\n+  SET_EXPR_LOCATION (stmt, pragma_tok->location);\n+  return add_stmt (stmt);\n+}\n+\n+/* OpenMP 4.5:\n+   # pragma omp target enter data target-enter-data-clause[optseq] new-line\n+     structured-block  */\n \n-  strcat (p_name, \" teams\");\n-  mask |= OMP_TEAMS_CLAUSE_MASK;\n+#define OMP_TARGET_ENTER_DATA_CLAUSE_MASK\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEVICE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n+static tree\n+cp_parser_omp_target_enter_data (cp_parser *parser, cp_token *pragma_tok,\n+\t\t\t\t enum pragma_context context)\n+{\n+  bool data_seen = false;\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n-      if (strcmp (p, \"distribute\") == 0)\n-\t{\n-\t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n-\t  if (cclauses == NULL)\n-\t    cclauses = cclauses_buf;\n \n+      if (strcmp (p, \"data\") == 0)\n+\t{\n \t  cp_lexer_consume_token (parser->lexer);\n-\t  if (!flag_openmp)  /* flag_openmp_simd  */\n-\t    return cp_parser_omp_distribute (parser, pragma_tok, p_name, mask,\n-\t\t\t\t\t     cclauses);\n-\t  sb = begin_omp_structured_block ();\n-\t  save = cp_parser_begin_omp_structured_block (parser);\n-\t  ret = cp_parser_omp_distribute (parser, pragma_tok, p_name, mask,\n-\t\t\t\t\t  cclauses);\n-\t  cp_parser_end_omp_structured_block (parser, save);\n-\t  tree body = finish_omp_structured_block (sb);\n-\t  if (ret == NULL)\n-\t    return ret;\n-\t  clauses = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];\n-\t  ret = make_node (OMP_TEAMS);\n-\t  TREE_TYPE (ret) = void_type_node;\n-\t  OMP_TEAMS_CLAUSES (ret) = clauses;\n-\t  OMP_TEAMS_BODY (ret) = body;\n-\t  OMP_TEAMS_COMBINED (ret) = 1;\n-\t  return add_stmt (ret);\n+\t  data_seen = true;\n \t}\n     }\n-  if (!flag_openmp)  /* flag_openmp_simd  */\n+  if (!data_seen)\n     {\n+      cp_parser_error (parser, \"expected %<data%>\");\n       cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n       return NULL_TREE;\n     }\n \n-  clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,\n-\t\t\t\t       cclauses == NULL);\n-  if (cclauses)\n+  if (context == pragma_stmt)\n     {\n-      cp_omp_split_clauses (loc, OMP_TEAMS, mask, clauses, cclauses);\n-      clauses = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];\n+      error_at (pragma_tok->location,\n+\t\t\"%<#pragma omp target enter data%> may only be \"\n+\t\t\"used in compound statements\");\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      return NULL_TREE;\n     }\n \n-  tree stmt = make_node (OMP_TEAMS);\n-  TREE_TYPE (stmt) = void_type_node;\n-  OMP_TEAMS_CLAUSES (stmt) = clauses;\n-  OMP_TEAMS_BODY (stmt) = cp_parser_omp_structured_block (parser);\n+  tree clauses\n+    = cp_parser_omp_all_clauses (parser, OMP_TARGET_ENTER_DATA_CLAUSE_MASK,\n+\t\t\t\t \"#pragma omp target enter data\", pragma_tok);\n+  int map_seen = 0;\n+  for (tree *pc = &clauses; *pc;)\n+    {\n+      if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)\n+\tswitch (OMP_CLAUSE_MAP_KIND (*pc))\n+\t  {\n+\t  case GOMP_MAP_TO:\n+\t  case GOMP_MAP_ALWAYS_TO:\n+\t  case GOMP_MAP_ALLOC:\n+\t    map_seen = 3;\n+\t    break;\n+\t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t    break;\n+\t  default:\n+\t    map_seen |= 1;\n+\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n+\t\t      \"%<#pragma omp target enter data%> with map-type other \"\n+\t\t      \"than %<to%> or %<alloc%> on %<map%> clause\");\n+\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n+\t    continue;\n+\t  }\n+      pc = &OMP_CLAUSE_CHAIN (*pc);\n+    }\n+\n+  if (map_seen != 3)\n+    {\n+      if (map_seen == 0)\n+\terror_at (pragma_tok->location,\n+\t\t  \"%<#pragma omp target enter data%> must contain at least \"\n+\t\t  \"one %<map%> clause\");\n+      return NULL_TREE;\n+    }\n \n+  tree stmt = make_node (OMP_TARGET_ENTER_DATA);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_TARGET_ENTER_DATA_CLAUSES (stmt) = clauses;\n+  SET_EXPR_LOCATION (stmt, pragma_tok->location);\n   return add_stmt (stmt);\n }\n \n-/* OpenMP 4.0:\n-   # pragma omp target data target-data-clause[optseq] new-line\n+/* OpenMP 4.5:\n+   # pragma omp target exit data target-enter-data-clause[optseq] new-line\n      structured-block  */\n \n-#define OMP_TARGET_DATA_CLAUSE_MASK\t\t\t\t\\\n+#define OMP_TARGET_EXIT_DATA_CLAUSE_MASK\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEVICE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP)\t\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n static tree\n-cp_parser_omp_target_data (cp_parser *parser, cp_token *pragma_tok)\n+cp_parser_omp_target_exit_data (cp_parser *parser, cp_token *pragma_tok,\n+\t\t\t\tenum pragma_context context)\n {\n-  tree stmt = make_node (OMP_TARGET_DATA);\n-  TREE_TYPE (stmt) = void_type_node;\n+  bool data_seen = false;\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *p = IDENTIFIER_POINTER (id);\n \n-  OMP_TARGET_DATA_CLAUSES (stmt)\n-    = cp_parser_omp_all_clauses (parser, OMP_TARGET_DATA_CLAUSE_MASK,\n-\t\t\t\t \"#pragma omp target data\", pragma_tok);\n-  keep_next_level (true);\n-  OMP_TARGET_DATA_BODY (stmt) = cp_parser_omp_structured_block (parser);\n+      if (strcmp (p, \"data\") == 0)\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  data_seen = true;\n+\t}\n+    }\n+  if (!data_seen)\n+    {\n+      cp_parser_error (parser, \"expected %<data%>\");\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      return NULL_TREE;\n+    }\n+\n+  if (context == pragma_stmt)\n+    {\n+      error_at (pragma_tok->location,\n+\t\t\"%<#pragma omp target exit data%> may only be \"\n+\t\t\"used in compound statements\");\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      return NULL_TREE;\n+    }\n+\n+  tree clauses\n+    = cp_parser_omp_all_clauses (parser, OMP_TARGET_EXIT_DATA_CLAUSE_MASK,\n+\t\t\t\t \"#pragma omp target exit data\", pragma_tok);\n+  int map_seen = 0;\n+  for (tree *pc = &clauses; *pc;)\n+    {\n+      if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)\n+\tswitch (OMP_CLAUSE_MAP_KIND (*pc))\n+\t  {\n+\t  case GOMP_MAP_FROM:\n+\t  case GOMP_MAP_ALWAYS_FROM:\n+\t  case GOMP_MAP_RELEASE:\n+\t  case GOMP_MAP_DELETE:\n+\t    map_seen = 3;\n+\t    break;\n+\t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t    break;\n+\t  default:\n+\t    map_seen |= 1;\n+\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n+\t\t      \"%<#pragma omp target exit data%> with map-type other \"\n+\t\t      \"than %<from%>, %<release%> or %<delete%> on %<map%>\"\n+\t\t      \" clause\");\n+\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n+\t    continue;\n+\t  }\n+      pc = &OMP_CLAUSE_CHAIN (*pc);\n+    }\n+\n+  if (map_seen != 3)\n+    {\n+      if (map_seen == 0)\n+\terror_at (pragma_tok->location,\n+\t\t  \"%<#pragma omp target exit data%> must contain at least \"\n+\t\t  \"one %<map%> clause\");\n+      return NULL_TREE;\n+    }\n \n+  tree stmt = make_node (OMP_TARGET_EXIT_DATA);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_TARGET_EXIT_DATA_CLAUSES (stmt) = clauses;\n   SET_EXPR_LOCATION (stmt, pragma_tok->location);\n   return add_stmt (stmt);\n }\n@@ -32876,7 +33945,9 @@ cp_parser_omp_target_data (cp_parser *parser, cp_token *pragma_tok)\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FROM)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_TO)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEVICE)\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n static bool\n cp_parser_omp_target_update (cp_parser *parser, cp_token *pragma_tok,\n@@ -32918,12 +33989,20 @@ cp_parser_omp_target_update (cp_parser *parser, cp_token *pragma_tok,\n #define OMP_TARGET_CLAUSE_MASK\t\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEVICE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP)\t\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEFAULTMAP)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR))\n \n static bool\n cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n \t\t      enum pragma_context context)\n {\n+  tree *pc = NULL, stmt;\n+\n   if (context != pragma_stmt && context != pragma_compound)\n     {\n       cp_parser_error (parser, \"expected declaration specifiers\");\n@@ -32935,8 +34014,15 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n     {\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n+      enum tree_code ccode = ERROR_MARK;\n \n       if (strcmp (p, \"teams\") == 0)\n+\tccode = OMP_TEAMS;\n+      else if (strcmp (p, \"parallel\") == 0)\n+\tccode = OMP_PARALLEL;\n+      else if (strcmp (p, \"simd\") == 0)\n+\tccode = OMP_SIMD;\n+      if (ccode != ERROR_MARK)\n \t{\n \t  tree cclauses[C_OMP_CLAUSE_SPLIT_COUNT];\n \t  char p_name[sizeof (\"#pragma omp target teams distribute \"\n@@ -32946,16 +34032,49 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n \t  strcpy (p_name, \"#pragma omp target\");\n \t  if (!flag_openmp)  /* flag_openmp_simd  */\n \t    {\n-\t      tree stmt = cp_parser_omp_teams (parser, pragma_tok, p_name,\n-\t\t\t\t\t       OMP_TARGET_CLAUSE_MASK,\n-\t\t\t\t\t       cclauses);\n+\t      tree stmt;\n+\t      switch (ccode)\n+\t\t{\n+\t\tcase OMP_TEAMS:\n+\t\t  stmt = cp_parser_omp_teams (parser, pragma_tok, p_name,\n+\t\t\t\t\t      OMP_TARGET_CLAUSE_MASK,\n+\t\t\t\t\t      cclauses);\n+\t\t  break;\n+\t\tcase OMP_PARALLEL:\n+\t\t  stmt = cp_parser_omp_parallel (parser, pragma_tok, p_name,\n+\t\t\t\t\t\t OMP_TARGET_CLAUSE_MASK,\n+\t\t\t\t\t\t cclauses);\n+\t\t  break;\n+\t\tcase OMP_SIMD:\n+\t\t  stmt = cp_parser_omp_simd (parser, pragma_tok, p_name,\n+\t\t\t\t\t     OMP_TARGET_CLAUSE_MASK,\n+\t\t\t\t\t     cclauses);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n \t      return stmt != NULL_TREE;\n \t    }\n \t  keep_next_level (true);\n-\t  tree sb = begin_omp_structured_block ();\n+\t  tree sb = begin_omp_structured_block (), ret;\n \t  unsigned save = cp_parser_begin_omp_structured_block (parser);\n-\t  tree ret = cp_parser_omp_teams (parser, pragma_tok, p_name,\n-\t\t\t\t\t  OMP_TARGET_CLAUSE_MASK, cclauses);\n+\t  switch (ccode)\n+\t    {\n+\t    case OMP_TEAMS:\n+\t      ret = cp_parser_omp_teams (parser, pragma_tok, p_name,\n+\t\t\t\t\t OMP_TARGET_CLAUSE_MASK, cclauses);\n+\t      break;\n+\t    case OMP_PARALLEL:\n+\t      ret = cp_parser_omp_parallel (parser, pragma_tok, p_name,\n+\t\t\t\t\t    OMP_TARGET_CLAUSE_MASK, cclauses);\n+\t      break;\n+\t    case OMP_SIMD:\n+\t      ret = cp_parser_omp_simd (parser, pragma_tok, p_name,\n+\t\t\t\t\tOMP_TARGET_CLAUSE_MASK, cclauses);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n \t  cp_parser_end_omp_structured_block (parser, save);\n \t  tree body = finish_omp_structured_block (sb);\n \t  if (ret == NULL_TREE)\n@@ -32964,8 +34083,10 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n \t  TREE_TYPE (stmt) = void_type_node;\n \t  OMP_TARGET_CLAUSES (stmt) = cclauses[C_OMP_CLAUSE_SPLIT_TARGET];\n \t  OMP_TARGET_BODY (stmt) = body;\n+\t  OMP_TARGET_COMBINED (stmt) = 1;\n \t  add_stmt (stmt);\n-\t  return true;\n+\t  pc = &OMP_TARGET_CLAUSES (stmt);\n+\t  goto check_clauses;\n \t}\n       else if (!flag_openmp)  /* flag_openmp_simd  */\n \t{\n@@ -32978,24 +34099,63 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n \t  cp_parser_omp_target_data (parser, pragma_tok);\n \t  return true;\n \t}\n+      else if (strcmp (p, \"enter\") == 0)\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  cp_parser_omp_target_enter_data (parser, pragma_tok, context);\n+\t  return false;\n+\t}\n+      else if (strcmp (p, \"exit\") == 0)\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  cp_parser_omp_target_exit_data (parser, pragma_tok, context);\n+\t  return false;\n+\t}\n       else if (strcmp (p, \"update\") == 0)\n \t{\n \t  cp_lexer_consume_token (parser->lexer);\n \t  return cp_parser_omp_target_update (parser, pragma_tok, context);\n \t}\n     }\n \n-  tree stmt = make_node (OMP_TARGET);\n+  stmt = make_node (OMP_TARGET);\n   TREE_TYPE (stmt) = void_type_node;\n \n   OMP_TARGET_CLAUSES (stmt)\n     = cp_parser_omp_all_clauses (parser, OMP_TARGET_CLAUSE_MASK,\n \t\t\t\t \"#pragma omp target\", pragma_tok);\n+  pc = &OMP_TARGET_CLAUSES (stmt);\n   keep_next_level (true);\n   OMP_TARGET_BODY (stmt) = cp_parser_omp_structured_block (parser);\n \n   SET_EXPR_LOCATION (stmt, pragma_tok->location);\n   add_stmt (stmt);\n+\n+check_clauses:\n+  while (*pc)\n+    {\n+      if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)\n+\tswitch (OMP_CLAUSE_MAP_KIND (*pc))\n+\t  {\n+\t  case GOMP_MAP_TO:\n+\t  case GOMP_MAP_ALWAYS_TO:\n+\t  case GOMP_MAP_FROM:\n+\t  case GOMP_MAP_ALWAYS_FROM:\n+\t  case GOMP_MAP_TOFROM:\n+\t  case GOMP_MAP_ALWAYS_TOFROM:\n+\t  case GOMP_MAP_ALLOC:\n+\t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t    break;\n+\t  default:\n+\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n+\t\t      \"%<#pragma omp target%> with map-type other \"\n+\t\t      \"than %<to%>, %<from%>, %<tofrom%> or %<alloc%> \"\n+\t\t      \"on %<map%> clause\");\n+\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n+\t    continue;\n+\t  }\n+      pc = &OMP_CLAUSE_CHAIN (*pc);\n+    }\n   return true;\n }\n \n@@ -33009,7 +34169,7 @@ cp_parser_oacc_cache (cp_parser *parser, cp_token *pragma_tok)\n   tree stmt, clauses;\n \n   clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE__CACHE_, NULL_TREE);\n-  clauses = finish_omp_clauses (clauses);\n+  clauses = finish_omp_clauses (clauses, false);\n \n   cp_parser_require_pragma_eol (parser, cp_lexer_peek_token (parser->lexer));\n \n@@ -33463,13 +34623,65 @@ cp_parser_late_parsing_omp_declare_simd (cp_parser *parser, tree attrs)\n /* OpenMP 4.0:\n    # pragma omp declare target new-line\n    declarations and definitions\n-   # pragma omp end declare target new-line  */\n+   # pragma omp end declare target new-line\n+\n+   OpenMP 4.5:\n+   # pragma omp declare target ( extended-list ) new-line\n+\n+   # pragma omp declare target declare-target-clauses[seq] new-line  */\n+\n+#define OMP_DECLARE_TARGET_CLAUSE_MASK\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_TO)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LINK))\n \n static void\n cp_parser_omp_declare_target (cp_parser *parser, cp_token *pragma_tok)\n {\n-  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-  scope_chain->omp_declare_target_attribute++;\n+  tree clauses = NULL_TREE;\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    clauses\n+      = cp_parser_omp_all_clauses (parser, OMP_DECLARE_TARGET_CLAUSE_MASK,\n+\t\t\t\t   \"#pragma omp declare target\", pragma_tok);\n+  else if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+    {\n+      clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_TO_DECLARE,\n+\t\t\t\t\tclauses);\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+    }\n+  else\n+    {\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      scope_chain->omp_declare_target_attribute++;\n+      return;\n+    }\n+  if (scope_chain->omp_declare_target_attribute)\n+    error_at (pragma_tok->location,\n+\t      \"%<#pragma omp declare target%> with clauses in between \"\n+\t      \"%<#pragma omp declare target%> without clauses and \"\n+\t      \"%<#pragma omp end declare target%>\");\n+  for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+    {\n+      tree t = OMP_CLAUSE_DECL (c), id;\n+      tree at1 = lookup_attribute (\"omp declare target\", DECL_ATTRIBUTES (t));\n+      tree at2 = lookup_attribute (\"omp declare target link\",\n+\t\t\t\t   DECL_ATTRIBUTES (t));\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINK)\n+\t{\n+\t  id = get_identifier (\"omp declare target link\");\n+\t  std::swap (at1, at2);\n+\t}\n+      else\n+\tid = get_identifier (\"omp declare target\");\n+      if (at2)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"%qD specified both in declare target %<link%> and %<to%>\"\n+\t\t    \" clauses\", t);\n+\t  continue;\n+\t}\n+      if (!at1)\n+\tDECL_ATTRIBUTES (t) = tree_cons (id, NULL_TREE, DECL_ATTRIBUTES (t));\n+    }\n }\n \n static void\n@@ -33957,6 +35169,97 @@ cp_parser_omp_declare (cp_parser *parser, cp_token *pragma_tok,\n   cp_parser_require_pragma_eol (parser, pragma_tok);\n }\n \n+/* OpenMP 4.5:\n+   #pragma omp taskloop taskloop-clause[optseq] new-line\n+     for-loop\n+\n+   #pragma omp taskloop simd taskloop-simd-clause[optseq] new-line\n+     for-loop  */\n+\n+#define OMP_TASKLOOP_CLAUSE_MASK\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SHARED)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEFAULT)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_GRAINSIZE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_TASKS)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COLLAPSE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_UNTIED)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FINAL)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MERGEABLE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY))\n+\n+static tree\n+cp_parser_omp_taskloop (cp_parser *parser, cp_token *pragma_tok,\n+\t\t\tchar *p_name, omp_clause_mask mask, tree *cclauses)\n+{\n+  tree clauses, sb, ret;\n+  unsigned int save;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  strcat (p_name, \" taskloop\");\n+  mask |= OMP_TASKLOOP_CLAUSE_MASK;\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+\n+      if (strcmp (p, \"simd\") == 0)\n+\t{\n+\t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t  if (cclauses == NULL)\n+\t    cclauses = cclauses_buf;\n+\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (!flag_openmp)  /* flag_openmp_simd  */\n+\t    return cp_parser_omp_simd (parser, pragma_tok, p_name, mask,\n+\t\t\t\t       cclauses);\n+\t  sb = begin_omp_structured_block ();\n+\t  save = cp_parser_begin_omp_structured_block (parser);\n+\t  ret = cp_parser_omp_simd (parser, pragma_tok, p_name, mask,\n+\t\t\t\t    cclauses);\n+\t  cp_parser_end_omp_structured_block (parser, save);\n+\t  tree body = finish_omp_structured_block (sb);\n+\t  if (ret == NULL)\n+\t    return ret;\n+\t  ret = make_node (OMP_TASKLOOP);\n+\t  TREE_TYPE (ret) = void_type_node;\n+\t  OMP_FOR_BODY (ret) = body;\n+\t  OMP_FOR_CLAUSES (ret) = cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP];\n+\t  SET_EXPR_LOCATION (ret, loc);\n+\t  add_stmt (ret);\n+\t  return ret;\n+\t}\n+    }\n+  if (!flag_openmp)  /* flag_openmp_simd  */\n+    {\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      return NULL_TREE;\n+    }\n+\n+  clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,\n+\t\t\t\t       cclauses == NULL);\n+  if (cclauses)\n+    {\n+      cp_omp_split_clauses (loc, OMP_TASKLOOP, mask, clauses, cclauses);\n+      clauses = cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP];\n+    }\n+\n+  sb = begin_omp_structured_block ();\n+  save = cp_parser_begin_omp_structured_block (parser);\n+\n+  ret = cp_parser_omp_for_loop (parser, OMP_TASKLOOP, clauses, cclauses);\n+\n+  cp_parser_end_omp_structured_block (parser, save);\n+  add_stmt (finish_omp_structured_block (sb));\n+\n+  return ret;\n+}\n+\n /* Main entry point to OpenMP statement pragmas.  */\n \n static void\n@@ -34012,9 +35315,6 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok)\n     case PRAGMA_OMP_MASTER:\n       stmt = cp_parser_omp_master (parser, pragma_tok);\n       break;\n-    case PRAGMA_OMP_ORDERED:\n-      stmt = cp_parser_omp_ordered (parser, pragma_tok);\n-      break;\n     case PRAGMA_OMP_PARALLEL:\n       strcpy (p_name, \"#pragma omp\");\n       stmt = cp_parser_omp_parallel (parser, pragma_tok, p_name, mask, NULL);\n@@ -34036,6 +35336,10 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok)\n     case PRAGMA_OMP_TASKGROUP:\n       stmt = cp_parser_omp_taskgroup (parser, pragma_tok);\n       break;\n+    case PRAGMA_OMP_TASKLOOP:\n+      strcpy (p_name, \"#pragma omp\");\n+      stmt = cp_parser_omp_taskloop (parser, pragma_tok, p_name, mask, NULL);\n+      break;\n     case PRAGMA_OMP_TEAMS:\n       strcpy (p_name, \"#pragma omp\");\n       stmt = cp_parser_omp_teams (parser, pragma_tok, p_name, mask, NULL);\n@@ -34424,6 +35728,8 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n {\n   cp_token *pragma_tok;\n   unsigned int id;\n+  tree stmt;\n+  bool ret;\n \n   pragma_tok = cp_lexer_consume_token (parser->lexer);\n   gcc_assert (pragma_tok->type == CPP_PRAGMA);\n@@ -34555,21 +35861,32 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n     case PRAGMA_OMP_DISTRIBUTE:\n     case PRAGMA_OMP_FOR:\n     case PRAGMA_OMP_MASTER:\n-    case PRAGMA_OMP_ORDERED:\n     case PRAGMA_OMP_PARALLEL:\n     case PRAGMA_OMP_SECTIONS:\n     case PRAGMA_OMP_SIMD:\n     case PRAGMA_OMP_SINGLE:\n     case PRAGMA_OMP_TASK:\n     case PRAGMA_OMP_TASKGROUP:\n+    case PRAGMA_OMP_TASKLOOP:\n     case PRAGMA_OMP_TEAMS:\n       if (context != pragma_stmt && context != pragma_compound)\n \tgoto bad_stmt;\n+      stmt = push_omp_privatization_clauses (false);\n       cp_parser_omp_construct (parser, pragma_tok);\n+      pop_omp_privatization_clauses (stmt);\n       return true;\n \n+    case PRAGMA_OMP_ORDERED:\n+      stmt = push_omp_privatization_clauses (false);\n+      ret = cp_parser_omp_ordered (parser, pragma_tok, context);\n+      pop_omp_privatization_clauses (stmt);\n+      return ret;\n+\n     case PRAGMA_OMP_TARGET:\n-      return cp_parser_omp_target (parser, pragma_tok, context);\n+      stmt = push_omp_privatization_clauses (false);\n+      ret = cp_parser_omp_target (parser, pragma_tok, context);\n+      pop_omp_privatization_clauses (stmt);\n+      return ret;\n \n     case PRAGMA_OMP_END_DECLARE_TARGET:\n       cp_parser_omp_end_declare_target (parser, pragma_tok);\n@@ -34610,7 +35927,9 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n \t\t    \"%<#pragma simd%> must be inside a function\");\n \t  break;\n \t}\n+      stmt = push_omp_privatization_clauses (false);\n       cp_parser_cilk_simd (parser, pragma_tok);\n+      pop_omp_privatization_clauses (stmt);\n       return true;\n \n     case PRAGMA_CILK_GRAINSIZE:\n@@ -34990,7 +36309,7 @@ cp_parser_cilk_for (cp_parser *parser, tree grain)\n   tree clauses = build_omp_clause (EXPR_LOCATION (grain), OMP_CLAUSE_SCHEDULE);\n   OMP_CLAUSE_SCHEDULE_KIND (clauses) = OMP_CLAUSE_SCHEDULE_CILKFOR;\n   OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clauses) = grain;\n-  clauses = finish_omp_clauses (clauses);\n+  clauses = finish_omp_clauses (clauses, false);\n \n   tree ret = cp_parser_omp_for_loop (parser, CILK_FOR, clauses, NULL);\n   if (ret)"}, {"sha": "14a5ddd9bb395db5ebc5f03424220fb0600a0d6f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 267, "deletions": 52, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -9519,7 +9519,7 @@ can_complete_type_without_circularity (tree type)\n     return 1;\n }\n \n-static tree tsubst_omp_clauses (tree, bool, tree, tsubst_flags_t, tree);\n+static tree tsubst_omp_clauses (tree, bool, bool, tree, tsubst_flags_t, tree);\n \n /* Apply any attributes which had to be deferred until instantiation\n    time.  DECL_P, ATTRIBUTES and ATTR_FLAGS are as cplus_decl_attributes;\n@@ -9568,10 +9568,10 @@ apply_late_template_attributes (tree *decl_p, tree attributes, int attr_flags,\n \t\t  && TREE_VALUE (t))\n \t\t{\n \t\t  tree clauses = TREE_VALUE (TREE_VALUE (t));\n-\t\t  clauses = tsubst_omp_clauses (clauses, true, args,\n+\t\t  clauses = tsubst_omp_clauses (clauses, true, false, args,\n \t\t\t\t\t\tcomplain, in_decl);\n \t\t  c_omp_declare_simd_clauses_to_decls (*decl_p, clauses);\n-\t\t  clauses = finish_omp_clauses (clauses);\n+\t\t  clauses = finish_omp_clauses (clauses, false, true);\n \t\t  tree parms = DECL_ARGUMENTS (*decl_p);\n \t\t  clauses\n \t\t    = c_omp_declare_simd_clauses_to_numbers (parms, clauses);\n@@ -14290,13 +14290,21 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n }\n \n /* Helper function for tsubst_omp_clauses, used for instantiation of\n-   OMP_CLAUSE_DECL of clauses that handles also OpenMP array sections\n-   represented with TREE_LIST.  */\n+   OMP_CLAUSE_DECL of clauses.  */\n \n static tree\n tsubst_omp_clause_decl (tree decl, tree args, tsubst_flags_t complain,\n \t\t\ttree in_decl)\n {\n+  if (decl == NULL_TREE)\n+    return NULL_TREE;\n+\n+  /* Handle an OpenMP array section represented as a TREE_LIST (or\n+     OMP_CLAUSE_DEPEND_KIND).  An OMP_CLAUSE_DEPEND (with a depend\n+     kind of OMP_CLAUSE_DEPEND_SINK) can also be represented as a\n+     TREE_LIST.  We can handle it exactly the same as an array section\n+     (purpose, value, and a chain), even though the nomenclature\n+     (low_bound, length, etc) is different.  */\n   if (TREE_CODE (decl) == TREE_LIST)\n     {\n       tree low_bound\n@@ -14310,18 +14318,29 @@ tsubst_omp_clause_decl (tree decl, tree args, tsubst_flags_t complain,\n \t  && TREE_VALUE (decl) == length\n \t  && TREE_CHAIN (decl) == chain)\n \treturn decl;\n-      return tree_cons (low_bound, length, chain);\n-    }\n-  return tsubst_copy (decl, args, complain, in_decl);\n+      tree ret = tree_cons (low_bound, length, chain);\n+      OMP_CLAUSE_DEPEND_SINK_NEGATIVE (ret)\n+\t= OMP_CLAUSE_DEPEND_SINK_NEGATIVE (decl);\n+      return ret;\n+    }\n+  tree ret = tsubst_expr (decl, args, complain, in_decl,\n+\t\t\t  /*integral_constant_expression_p=*/false);\n+  /* Undo convert_from_reference tsubst_expr could have called.  */\n+  if (decl\n+      && REFERENCE_REF_P (ret)\n+      && !REFERENCE_REF_P (decl))\n+    ret = TREE_OPERAND (ret, 0);\n+  return ret;\n }\n \n /* Like tsubst_copy, but specifically for OpenMP clauses.  */\n \n static tree\n-tsubst_omp_clauses (tree clauses, bool declare_simd,\n+tsubst_omp_clauses (tree clauses, bool declare_simd, bool allow_fields,\n \t\t    tree args, tsubst_flags_t complain, tree in_decl)\n {\n-  tree new_clauses = NULL, nc, oc;\n+  tree new_clauses = NULL_TREE, nc, oc;\n+  tree linear_no_step = NULL_TREE;\n \n   for (oc = clauses; oc ; oc = OMP_CLAUSE_CHAIN (oc))\n     {\n@@ -14347,13 +14366,12 @@ tsubst_omp_clauses (tree clauses, bool declare_simd,\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE_COPYPRIVATE:\n \tcase OMP_CLAUSE_UNIFORM:\n-\t  OMP_CLAUSE_DECL (nc) = tsubst_copy (OMP_CLAUSE_DECL (oc), args,\n-\t\t\t\t\t      complain, in_decl);\n-\t  break;\n \tcase OMP_CLAUSE_DEPEND:\n \tcase OMP_CLAUSE_FROM:\n \tcase OMP_CLAUSE_TO:\n \tcase OMP_CLAUSE_MAP:\n+\tcase OMP_CLAUSE_USE_DEVICE_PTR:\n+\tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \t  OMP_CLAUSE_DECL (nc)\n \t    = tsubst_omp_clause_decl (OMP_CLAUSE_DECL (oc), args, complain,\n \t\t\t\t      in_decl);\n@@ -14369,6 +14387,11 @@ tsubst_omp_clauses (tree clauses, bool declare_simd,\n \tcase OMP_CLAUSE_THREAD_LIMIT:\n \tcase OMP_CLAUSE_SAFELEN:\n \tcase OMP_CLAUSE_SIMDLEN:\n+\tcase OMP_CLAUSE_NUM_TASKS:\n+\tcase OMP_CLAUSE_GRAINSIZE:\n+\tcase OMP_CLAUSE_PRIORITY:\n+\tcase OMP_CLAUSE_ORDERED:\n+\tcase OMP_CLAUSE_HINT:\n \t  OMP_CLAUSE_OPERAND (nc, 0)\n \t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 0), args, complain, \n \t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n@@ -14389,19 +14412,26 @@ tsubst_omp_clauses (tree clauses, bool declare_simd,\n \t      else\n \t\tgcc_assert (identifier_p (placeholder));\n \t    }\n-\t  OMP_CLAUSE_DECL (nc) = tsubst_copy (OMP_CLAUSE_DECL (oc), args,\n-\t\t\t\t\t      complain, in_decl);\n+\t  OMP_CLAUSE_DECL (nc)\n+\t    = tsubst_omp_clause_decl (OMP_CLAUSE_DECL (oc), args, complain,\n+\t\t\t\t      in_decl);\n \t  break;\n \tcase OMP_CLAUSE_LINEAR:\n \tcase OMP_CLAUSE_ALIGNED:\n-\t  OMP_CLAUSE_DECL (nc) = tsubst_copy (OMP_CLAUSE_DECL (oc), args,\n-\t\t\t\t\t      complain, in_decl);\n+\t  OMP_CLAUSE_DECL (nc)\n+\t    = tsubst_omp_clause_decl (OMP_CLAUSE_DECL (oc), args, complain,\n+\t\t\t\t      in_decl);\n \t  OMP_CLAUSE_OPERAND (nc, 1)\n \t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 1), args, complain,\n \t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n+\t  if (OMP_CLAUSE_CODE (oc) == OMP_CLAUSE_LINEAR\n+\t      && OMP_CLAUSE_LINEAR_STEP (oc) == NULL_TREE)\n+\t    {\n+\t      gcc_assert (!linear_no_step);\n+\t      linear_no_step = nc;\n+\t    }\n \t  break;\n \tcase OMP_CLAUSE_NOWAIT:\n-\tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_MERGEABLE:\n@@ -14412,15 +14442,86 @@ tsubst_omp_clauses (tree clauses, bool declare_simd,\n \tcase OMP_CLAUSE_PARALLEL:\n \tcase OMP_CLAUSE_SECTIONS:\n \tcase OMP_CLAUSE_TASKGROUP:\n+\tcase OMP_CLAUSE_NOGROUP:\n+\tcase OMP_CLAUSE_THREADS:\n+\tcase OMP_CLAUSE_SIMD:\n+\tcase OMP_CLAUSE_DEFAULTMAP:\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n+      if (allow_fields)\n+\tswitch (OMP_CLAUSE_CODE (nc))\n+\t  {\n+\t  case OMP_CLAUSE_PRIVATE:\n+\t  case OMP_CLAUSE_FIRSTPRIVATE:\n+\t  case OMP_CLAUSE_LASTPRIVATE:\n+\t  case OMP_CLAUSE_COPYPRIVATE:\n+\t  case OMP_CLAUSE_LINEAR:\n+\t  case OMP_CLAUSE_REDUCTION:\n+\t  case OMP_CLAUSE_USE_DEVICE_PTR:\n+\t  case OMP_CLAUSE_IS_DEVICE_PTR:\n+\t    /* tsubst_expr on SCOPE_REF results in returning\n+\t       finish_non_static_data_member result.  Undo that here.  */\n+\t    if (TREE_CODE (OMP_CLAUSE_DECL (oc)) == SCOPE_REF\n+\t\t&& (TREE_CODE (TREE_OPERAND (OMP_CLAUSE_DECL (oc), 1))\n+\t\t    == IDENTIFIER_NODE))\n+\t      {\n+\t\ttree t = OMP_CLAUSE_DECL (nc);\n+\t\ttree v = t;\n+\t\twhile (v)\n+\t\t  switch (TREE_CODE (v))\n+\t\t    {\n+\t\t    case COMPONENT_REF:\n+\t\t    case MEM_REF:\n+\t\t    case INDIRECT_REF:\n+\t\t    CASE_CONVERT:\n+\t\t    case POINTER_PLUS_EXPR:\n+\t\t      v = TREE_OPERAND (v, 0);\n+\t\t      continue;\n+\t\t    case PARM_DECL:\n+\t\t      if (DECL_CONTEXT (v) == current_function_decl\n+\t\t\t  && DECL_ARTIFICIAL (v)\n+\t\t\t  && DECL_NAME (v) == this_identifier)\n+\t\t\tOMP_CLAUSE_DECL (nc) = TREE_OPERAND (t, 1);\n+\t\t      /* FALLTHRU */\n+\t\t    default:\n+\t\t      v = NULL_TREE;\n+\t\t      break;\n+\t\t    }\n+\t      }\n+\t    else if (VAR_P (OMP_CLAUSE_DECL (oc))\n+\t\t     && DECL_HAS_VALUE_EXPR_P (OMP_CLAUSE_DECL (oc))\n+\t\t     && DECL_ARTIFICIAL (OMP_CLAUSE_DECL (oc))\n+\t\t     && DECL_LANG_SPECIFIC (OMP_CLAUSE_DECL (oc))\n+\t\t     && DECL_OMP_PRIVATIZED_MEMBER (OMP_CLAUSE_DECL (oc)))\n+\t      {\n+\t\ttree decl = OMP_CLAUSE_DECL (nc);\n+\t\tif (VAR_P (decl))\n+\t\t  {\n+\t\t    if (!DECL_LANG_SPECIFIC (decl))\n+\t\t      retrofit_lang_decl (decl);\n+\t\t    DECL_OMP_PRIVATIZED_MEMBER (decl) = 1;\n+\t\t  }\n+\t      }\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n     }\n \n   new_clauses = nreverse (new_clauses);\n   if (!declare_simd)\n-    new_clauses = finish_omp_clauses (new_clauses);\n+    {\n+      new_clauses = finish_omp_clauses (new_clauses, allow_fields);\n+      if (linear_no_step)\n+\tfor (nc = new_clauses; nc; nc = OMP_CLAUSE_CHAIN (nc))\n+\t  if (nc == linear_no_step)\n+\t    {\n+\t      OMP_CLAUSE_LINEAR_STEP (nc) = NULL_TREE;\n+\t      break;\n+\t    }\n+    }\n   return new_clauses;\n }\n \n@@ -14467,11 +14568,17 @@ tsubst_copy_asm_operands (tree t, tree args, tsubst_flags_t complain,\n #undef RECUR\n }\n \n+/* Used to temporarily communicate the list of #pragma omp parallel\n+   clauses to #pragma omp for instantiation if they are combined\n+   together.  */\n+\n+static tree *omp_parallel_combined_clauses;\n+\n /* Substitute one OMP_FOR iterator.  */\n \n static void\n-tsubst_omp_for_iterator (tree t, int i, tree declv, tree initv,\n-\t\t\t tree condv, tree incrv, tree *clauses,\n+tsubst_omp_for_iterator (tree t, int i, tree declv, tree orig_declv,\n+\t\t\t tree initv, tree condv, tree incrv, tree *clauses,\n \t\t\t tree args, tsubst_flags_t complain, tree in_decl,\n \t\t\t bool integral_constant_expression_p)\n {\n@@ -14482,6 +14589,13 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree initv,\n \n   init = TREE_VEC_ELT (OMP_FOR_INIT (t), i);\n   gcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n+\n+  if (orig_declv && OMP_FOR_ORIG_DECLS (t))\n+    {\n+      tree o = TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (t), i);\n+      TREE_VEC_ELT (orig_declv, i) = RECUR (o);\n+    }\n+\n   decl = TREE_OPERAND (init, 0);\n   init = TREE_OPERAND (init, 1);\n   tree decl_expr = NULL_TREE;\n@@ -14495,7 +14609,41 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree initv,\n       decl = tsubst_decl (decl, args, complain);\n     }\n   else\n-    decl = RECUR (decl);\n+    {\n+      if (TREE_CODE (decl) == SCOPE_REF)\n+\t{\n+\t  decl = RECUR (decl);\n+\t  if (TREE_CODE (decl) == COMPONENT_REF)\n+\t    {\n+\t      tree v = decl;\n+\t      while (v)\n+\t\tswitch (TREE_CODE (v))\n+\t\t  {\n+\t\t  case COMPONENT_REF:\n+\t\t  case MEM_REF:\n+\t\t  case INDIRECT_REF:\n+\t\t  CASE_CONVERT:\n+\t\t  case POINTER_PLUS_EXPR:\n+\t\t    v = TREE_OPERAND (v, 0);\n+\t\t    continue;\n+\t\t  case PARM_DECL:\n+\t\t    if (DECL_CONTEXT (v) == current_function_decl\n+\t\t\t&& DECL_ARTIFICIAL (v)\n+\t\t\t&& DECL_NAME (v) == this_identifier)\n+\t\t      {\n+\t\t\tdecl = TREE_OPERAND (decl, 1);\n+\t\t\tdecl = omp_privatize_field (decl);\n+\t\t      }\n+\t\t    /* FALLTHRU */\n+\t\t  default:\n+\t\t    v = NULL_TREE;\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\t}\n+      else\n+\tdecl = RECUR (decl);\n+    }\n   init = RECUR (init);\n \n   tree auto_node = type_uses_auto (TREE_TYPE (decl));\n@@ -14542,25 +14690,51 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree initv,\n     }\n   else if (init)\n     {\n-      tree c;\n-      for (c = *clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n+      tree *pc;\n+      int j;\n+      for (j = (omp_parallel_combined_clauses == NULL ? 1 : 0); j < 2; j++)\n \t{\n-\t  if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n-\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n-\t      && OMP_CLAUSE_DECL (c) == decl)\n+\t  for (pc = j ? clauses : omp_parallel_combined_clauses; *pc; )\n+\t    {\n+\t      if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_PRIVATE\n+\t\t  && OMP_CLAUSE_DECL (*pc) == decl)\n+\t\tbreak;\n+\t      else if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_LASTPRIVATE\n+\t\t       && OMP_CLAUSE_DECL (*pc) == decl)\n+\t\t{\n+\t\t  if (j)\n+\t\t    break;\n+\t\t  /* Move lastprivate (decl) clause to OMP_FOR_CLAUSES.  */\n+\t\t  tree c = *pc;\n+\t\t  *pc = OMP_CLAUSE_CHAIN (c);\n+\t\t  OMP_CLAUSE_CHAIN (c) = *clauses;\n+\t\t  *clauses = c;\n+\t\t}\n+\t      else if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_FIRSTPRIVATE\n+\t\t       && OMP_CLAUSE_DECL (*pc) == decl)\n+\t\t{\n+\t\t  error (\"iteration variable %qD should not be firstprivate\",\n+\t\t\t decl);\n+\t\t  *pc = OMP_CLAUSE_CHAIN (*pc);\n+\t\t}\n+\t      else if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_REDUCTION\n+\t\t       && OMP_CLAUSE_DECL (*pc) == decl)\n+\t\t{\n+\t\t  error (\"iteration variable %qD should not be reduction\",\n+\t\t\t decl);\n+\t\t  *pc = OMP_CLAUSE_CHAIN (*pc);\n+\t\t}\n+\t      else\n+\t\tpc = &OMP_CLAUSE_CHAIN (*pc);\n+\t    }\n+\t  if (*pc)\n \t    break;\n-\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n-\t\t   && OMP_CLAUSE_DECL (c) == decl)\n-\t    error (\"iteration variable %qD should not be firstprivate\", decl);\n-\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n-\t\t   && OMP_CLAUSE_DECL (c) == decl)\n-\t    error (\"iteration variable %qD should not be reduction\", decl);\n \t}\n-      if (c == NULL)\n+      if (*pc == NULL_TREE)\n \t{\n-\t  c = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n+\t  tree c = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n \t  OMP_CLAUSE_DECL (c) = decl;\n-\t  c = finish_omp_clauses (c);\n+\t  c = finish_omp_clauses (c, true);\n \t  if (c)\n \t    {\n \t      OMP_CLAUSE_CHAIN (c) = *clauses;\n@@ -15021,38 +15195,50 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       break;\n \n     case OMP_PARALLEL:\n-      tmp = tsubst_omp_clauses (OMP_PARALLEL_CLAUSES (t), false,\n+      r = push_omp_privatization_clauses (OMP_PARALLEL_COMBINED (t));\n+      tmp = tsubst_omp_clauses (OMP_PARALLEL_CLAUSES (t), false, true,\n \t\t\t\targs, complain, in_decl);\n+      if (OMP_PARALLEL_COMBINED (t))\n+\tomp_parallel_combined_clauses = &tmp;\n       stmt = begin_omp_parallel ();\n       RECUR (OMP_PARALLEL_BODY (t));\n+      gcc_assert (omp_parallel_combined_clauses == NULL);\n       OMP_PARALLEL_COMBINED (finish_omp_parallel (tmp, stmt))\n \t= OMP_PARALLEL_COMBINED (t);\n+      pop_omp_privatization_clauses (r);\n       break;\n \n     case OMP_TASK:\n-      tmp = tsubst_omp_clauses (OMP_TASK_CLAUSES (t), false,\n+      r = push_omp_privatization_clauses (false);\n+      tmp = tsubst_omp_clauses (OMP_TASK_CLAUSES (t), false, true,\n \t\t\t\targs, complain, in_decl);\n       stmt = begin_omp_task ();\n       RECUR (OMP_TASK_BODY (t));\n       finish_omp_task (tmp, stmt);\n+      pop_omp_privatization_clauses (r);\n       break;\n \n     case OMP_FOR:\n     case OMP_SIMD:\n     case CILK_SIMD:\n     case CILK_FOR:\n     case OMP_DISTRIBUTE:\n+    case OMP_TASKLOOP:\n       {\n \ttree clauses, body, pre_body;\n \ttree declv = NULL_TREE, initv = NULL_TREE, condv = NULL_TREE;\n+\ttree orig_declv = NULL_TREE;\n \ttree incrv = NULL_TREE;\n \tint i;\n \n-\tclauses = tsubst_omp_clauses (OMP_FOR_CLAUSES (t), false,\n+\tr = push_omp_privatization_clauses (OMP_FOR_INIT (t) == NULL_TREE);\n+\tclauses = tsubst_omp_clauses (OMP_FOR_CLAUSES (t), false, true,\n \t\t\t\t      args, complain, in_decl);\n \tif (OMP_FOR_INIT (t) != NULL_TREE)\n \t  {\n \t    declv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n+\t    if (TREE_CODE (t) == OMP_FOR && OMP_FOR_ORIG_DECLS (t))\n+\t      orig_declv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n \t    initv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n \t    condv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n \t    incrv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n@@ -15066,17 +15252,19 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \n \tif (OMP_FOR_INIT (t) != NULL_TREE)\n \t  for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (t)); i++)\n-\t    tsubst_omp_for_iterator (t, i, declv, initv, condv, incrv,\n-\t\t\t\t     &clauses, args, complain, in_decl,\n+\t    tsubst_omp_for_iterator (t, i, declv, orig_declv, initv, condv,\n+\t\t\t\t     incrv, &clauses, args, complain, in_decl,\n \t\t\t\t     integral_constant_expression_p);\n+\tomp_parallel_combined_clauses = NULL;\n \n \tbody = push_stmt_list ();\n \tRECUR (OMP_FOR_BODY (t));\n \tbody = pop_stmt_list (body);\n \n \tif (OMP_FOR_INIT (t) != NULL_TREE)\n-\t  t = finish_omp_for (EXPR_LOCATION (t), TREE_CODE (t), declv, initv,\n-\t\t\t      condv, incrv, body, pre_body, clauses);\n+\t  t = finish_omp_for (EXPR_LOCATION (t), TREE_CODE (t), declv,\n+\t\t\t      orig_declv, initv, condv, incrv, body, pre_body,\n+\t\t\t      clauses);\n \telse\n \t  {\n \t    t = make_node (TREE_CODE (t));\n@@ -15089,13 +15277,19 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t  }\n \n \tadd_stmt (finish_omp_structured_block (stmt));\n+\tpop_omp_privatization_clauses (r);\n       }\n       break;\n \n     case OMP_SECTIONS:\n+      omp_parallel_combined_clauses = NULL;\n+      /* FALLTHRU */\n     case OMP_SINGLE:\n     case OMP_TEAMS:\n-      tmp = tsubst_omp_clauses (OMP_CLAUSES (t), false,\n+    case OMP_CRITICAL:\n+      r = push_omp_privatization_clauses (TREE_CODE (t) == OMP_TEAMS\n+\t\t\t\t\t  && OMP_TEAMS_COMBINED (t));\n+      tmp = tsubst_omp_clauses (OMP_CLAUSES (t), false, true,\n \t\t\t\targs, complain, in_decl);\n       stmt = push_stmt_list ();\n       RECUR (OMP_BODY (t));\n@@ -15105,11 +15299,12 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       OMP_BODY (t) = stmt;\n       OMP_CLAUSES (t) = tmp;\n       add_stmt (t);\n+      pop_omp_privatization_clauses (r);\n       break;\n \n     case OMP_TARGET_DATA:\n     case OMP_TARGET:\n-      tmp = tsubst_omp_clauses (OMP_CLAUSES (t), false,\n+      tmp = tsubst_omp_clauses (OMP_CLAUSES (t), false, true,\n \t\t\t\targs, complain, in_decl);\n       keep_next_level (true);\n       stmt = begin_omp_structured_block ();\n@@ -15124,18 +15319,31 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       break;\n \n     case OMP_TARGET_UPDATE:\n-      tmp = tsubst_omp_clauses (OMP_TARGET_UPDATE_CLAUSES (t), false,\n+    case OMP_TARGET_ENTER_DATA:\n+    case OMP_TARGET_EXIT_DATA:\n+      tmp = tsubst_omp_clauses (OMP_STANDALONE_CLAUSES (t), false, true,\n+\t\t\t\targs, complain, in_decl);\n+      t = copy_node (t);\n+      OMP_STANDALONE_CLAUSES (t) = tmp;\n+      add_stmt (t);\n+      break;\n+\n+    case OMP_ORDERED:\n+      tmp = tsubst_omp_clauses (OMP_ORDERED_CLAUSES (t), false, true,\n \t\t\t\targs, complain, in_decl);\n+      stmt = push_stmt_list ();\n+      RECUR (OMP_BODY (t));\n+      stmt = pop_stmt_list (stmt);\n+\n       t = copy_node (t);\n-      OMP_TARGET_UPDATE_CLAUSES (t) = tmp;\n+      OMP_BODY (t) = stmt;\n+      OMP_ORDERED_CLAUSES (t) = tmp;\n       add_stmt (t);\n       break;\n \n     case OMP_SECTION:\n-    case OMP_CRITICAL:\n     case OMP_MASTER:\n     case OMP_TASKGROUP:\n-    case OMP_ORDERED:\n       stmt = push_stmt_list ();\n       RECUR (OMP_BODY (t));\n       stmt = pop_stmt_list (stmt);\n@@ -21053,7 +21261,7 @@ instantiate_decl (tree d, int defer_ok,\n   bool external_p;\n   bool deleted_p;\n   tree fn_context;\n-  bool nested;\n+  bool nested = false;\n \n   /* This function should only be used to instantiate templates for\n      functions and static member variables.  */\n@@ -21278,6 +21486,10 @@ instantiate_decl (tree d, int defer_ok,\n \n   fn_context = decl_function_context (d);\n   nested = (current_function_decl != NULL_TREE);\n+  vec<tree> omp_privatization_save;\n+  if (nested)\n+    save_omp_privatization_clauses (omp_privatization_save);\n+\n   if (!fn_context)\n     push_to_top_level ();\n   else\n@@ -21447,6 +21659,8 @@ instantiate_decl (tree d, int defer_ok,\n   c_inhibit_evaluation_warnings = saved_inhibit_evaluation_warnings;\n   pop_deferring_access_checks ();\n   pop_tinst_level ();\n+  if (nested)\n+    restore_omp_privatization_clauses (omp_privatization_save);\n \n   timevar_pop (TV_TEMPLATE_INST);\n \n@@ -22811,7 +23025,7 @@ dependent_template_id_p (tree tmpl, tree args)\n }\n \n /* Returns TRUE if OMP_FOR with DECLV, INITV, CONDV and INCRV vectors\n-   is dependent.  */\n+   are dependent.  */\n \n bool\n dependent_omp_for_p (tree declv, tree initv, tree condv, tree incrv)\n@@ -22828,7 +23042,8 @@ dependent_omp_for_p (tree declv, tree initv, tree condv, tree incrv)\n       tree cond = TREE_VEC_ELT (condv, i);\n       tree incr = TREE_VEC_ELT (incrv, i);\n \n-      if (type_dependent_expression_p (decl))\n+      if (type_dependent_expression_p (decl)\n+\t  || TREE_CODE (decl) == SCOPE_REF)\n \treturn true;\n \n       if (init && type_dependent_expression_p (init))"}, {"sha": "8796b176c15ac6cf785f43c8dbb9f2a37840db74", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1223, "deletions": 107, "changes": 1330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -63,6 +63,12 @@ static tree maybe_convert_cond (tree);\n static tree finalize_nrv_r (tree *, int *, void *);\n static tree capture_decltype (tree);\n \n+/* Used for OpenMP non-static data member privatization.  */\n+\n+static hash_map<tree, tree> *omp_private_member_map;\n+static vec<tree> omp_private_member_vec;\n+static bool omp_private_member_ignore_next;\n+\n \n /* Deferred Access Checking Overview\n    ---------------------------------\n@@ -1704,6 +1710,8 @@ tree\n finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n {\n   gcc_assert (TREE_CODE (decl) == FIELD_DECL);\n+  bool try_omp_private = !object && omp_private_member_map;\n+  tree ret;\n \n   if (!object)\n     {\n@@ -1755,17 +1763,17 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n \t  type = cp_build_qualified_type (type, quals);\n \t}\n \n-      return (convert_from_reference\n+      ret = (convert_from_reference\n \t      (build_min (COMPONENT_REF, type, object, decl, NULL_TREE)));\n     }\n   /* If PROCESSING_TEMPLATE_DECL is nonzero here, then\n      QUALIFYING_SCOPE is also non-null.  Wrap this in a SCOPE_REF\n      for now.  */\n   else if (processing_template_decl)\n-    return build_qualified_name (TREE_TYPE (decl),\n-\t\t\t\t qualifying_scope,\n-\t\t\t\t decl,\n-\t\t\t\t /*template_p=*/false);\n+    ret = build_qualified_name (TREE_TYPE (decl),\n+\t\t\t\tqualifying_scope,\n+\t\t\t\tdecl,\n+\t\t\t\t/*template_p=*/false);\n   else\n     {\n       tree access_type = TREE_TYPE (object);\n@@ -1782,11 +1790,18 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n \t\t\t\t     &binfo);\n \t}\n \n-      return build_class_member_access_expr (object, decl,\n-\t\t\t\t\t     /*access_path=*/NULL_TREE,\n-\t\t\t\t\t     /*preserve_reference=*/false,\n-\t\t\t\t\t     tf_warning_or_error);\n+      ret = build_class_member_access_expr (object, decl,\n+\t\t\t\t\t    /*access_path=*/NULL_TREE,\n+\t\t\t\t\t    /*preserve_reference=*/false,\n+\t\t\t\t\t    tf_warning_or_error);\n     }\n+  if (try_omp_private)\n+    {\n+      tree *v = omp_private_member_map->get (decl);\n+      if (v)\n+\tret = convert_from_reference (*v);\n+    }\n+  return ret;\n }\n \n /* If we are currently parsing a template and we encountered a typedef\n@@ -4252,6 +4267,91 @@ cxx_omp_create_clause_info (tree c, tree type, bool need_default_ctor,\n   return errorcount != save_errorcount;\n }\n \n+/* If DECL is DECL_OMP_PRIVATIZED_MEMBER, return corresponding\n+   FIELD_DECL, otherwise return DECL itself.  */\n+\n+static tree\n+omp_clause_decl_field (tree decl)\n+{\n+  if (VAR_P (decl)\n+      && DECL_HAS_VALUE_EXPR_P (decl)\n+      && DECL_ARTIFICIAL (decl)\n+      && DECL_LANG_SPECIFIC (decl)\n+      && DECL_OMP_PRIVATIZED_MEMBER (decl))\n+    {\n+      tree f = DECL_VALUE_EXPR (decl);\n+      if (TREE_CODE (f) == INDIRECT_REF)\n+\tf = TREE_OPERAND (f, 0);\n+      if (TREE_CODE (f) == COMPONENT_REF)\n+\t{\n+\t  f = TREE_OPERAND (f, 1);\n+\t  gcc_assert (TREE_CODE (f) == FIELD_DECL);\n+\t  return f;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Adjust DECL if needed for printing using %qE.  */\n+\n+static tree\n+omp_clause_printable_decl (tree decl)\n+{\n+  tree t = omp_clause_decl_field (decl);\n+  if (t)\n+    return t;\n+  return decl;\n+}\n+\n+/* For a FIELD_DECL F and corresponding DECL_OMP_PRIVATIZED_MEMBER\n+   VAR_DECL T that doesn't need a DECL_EXPR added, record it for\n+   privatization.  */\n+\n+static void\n+omp_note_field_privatization (tree f, tree t)\n+{\n+  if (!omp_private_member_map)\n+    omp_private_member_map = new hash_map<tree, tree>;\n+  tree &v = omp_private_member_map->get_or_insert (f);\n+  if (v == NULL_TREE)\n+    {\n+      v = t;\n+      omp_private_member_vec.safe_push (f);\n+      /* Signal that we don't want to create DECL_EXPR for this dummy var.  */\n+      omp_private_member_vec.safe_push (integer_zero_node);\n+    }\n+}\n+\n+/* Privatize FIELD_DECL T, return corresponding DECL_OMP_PRIVATIZED_MEMBER\n+   dummy VAR_DECL.  */\n+\n+tree\n+omp_privatize_field (tree t)\n+{\n+  tree m = finish_non_static_data_member (t, NULL_TREE, NULL_TREE);\n+  if (m == error_mark_node)\n+    return error_mark_node;\n+  if (!omp_private_member_map)\n+    omp_private_member_map = new hash_map<tree, tree>;\n+  if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE)\n+    {\n+      gcc_assert (TREE_CODE (m) == INDIRECT_REF);\n+      m = TREE_OPERAND (m, 0);\n+    }\n+  tree &v = omp_private_member_map->get_or_insert (t);\n+  if (v == NULL_TREE)\n+    {\n+      v = create_temporary_var (TREE_TYPE (m));\n+      if (!DECL_LANG_SPECIFIC (v))\n+\tretrofit_lang_decl (v);\n+      DECL_OMP_PRIVATIZED_MEMBER (v) = 1;\n+      SET_DECL_VALUE_EXPR (v, m);\n+      DECL_HAS_VALUE_EXPR_P (v) = 1;\n+      omp_private_member_vec.safe_push (t);\n+    }\n+  return v;\n+}\n+\n /* Helper function for handle_omp_array_sections.  Called recursively\n    to handle multiple array-section-subscripts.  C is the clause,\n    T current expression (initially OMP_CLAUSE_DECL), which is either\n@@ -4266,21 +4366,51 @@ cxx_omp_create_clause_info (tree c, tree type, bool need_default_ctor,\n    map(a[:b][2:1][:c][:2][:d][e:f][2:5])\n    FIRST_NON_ONE will be 3, array-section-subscript [:b], [2:1] and [:c]\n    all are or may have length of 1, array-section-subscript [:2] is the\n-   first one knonwn not to have length 1.  For array-section-subscript\n+   first one known not to have length 1.  For array-section-subscript\n    <= FIRST_NON_ONE we diagnose non-contiguous arrays if low bound isn't\n    0 or length isn't the array domain max + 1, for > FIRST_NON_ONE we\n    can if MAYBE_ZERO_LEN is false.  MAYBE_ZERO_LEN will be true in the above\n    case though, as some lengths could be zero.  */\n \n static tree\n handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n-\t\t\t     bool &maybe_zero_len, unsigned int &first_non_one)\n+\t\t\t     bool &maybe_zero_len, unsigned int &first_non_one,\n+\t\t\t     bool is_omp)\n {\n   tree ret, low_bound, length, type;\n   if (TREE_CODE (t) != TREE_LIST)\n     {\n       if (error_operand_p (t))\n \treturn error_mark_node;\n+      if (REFERENCE_REF_P (t)\n+\t  && TREE_CODE (TREE_OPERAND (t, 0)) == COMPONENT_REF)\n+\tt = TREE_OPERAND (t, 0);\n+      ret = t;\n+      if (TREE_CODE (t) == COMPONENT_REF\n+\t  && is_omp\n+\t  && (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TO\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FROM)\n+\t  && !type_dependent_expression_p (t))\n+\t{\n+\t  if (DECL_BIT_FIELD (TREE_OPERAND (t, 1)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"bit-field %qE in %qs clause\",\n+\t\t\tt, omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      return error_mark_node;\n+\t    }\n+\t  while (TREE_CODE (t) == COMPONENT_REF)\n+\t    {\n+\t      if (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == UNION_TYPE)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qE is a member of a union\", t);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t      t = TREE_OPERAND (t, 0);\n+\t    }\n+\t}\n       if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t{\n \t  if (processing_template_decl)\n@@ -4295,6 +4425,15 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t      omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t  return error_mark_node;\n \t}\n+      else if (TREE_CODE (t) == PARM_DECL\n+\t       && DECL_ARTIFICIAL (t)\n+\t       && DECL_NAME (t) == this_identifier)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"%<this%> allowed in OpenMP only in %<declare simd%>\"\n+\t\t    \" clauses\");\n+\t  return error_mark_node;\n+\t}\n       else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n \t       && VAR_P (t) && CP_DECL_THREAD_LOCAL_P (t))\n \t{\n@@ -4303,14 +4442,17 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t  return error_mark_node;\n \t}\n-      if (type_dependent_expression_p (t))\n+      if (type_dependent_expression_p (ret))\n \treturn NULL_TREE;\n-      t = convert_from_reference (t);\n-      return t;\n+      ret = convert_from_reference (ret);\n+      return ret;\n     }\n \n+  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+      && TREE_CODE (TREE_CHAIN (t)) == FIELD_DECL)\n+    TREE_CHAIN (t) = omp_privatize_field (TREE_CHAIN (t));\n   ret = handle_omp_array_sections_1 (c, TREE_CHAIN (t), types,\n-\t\t\t\t     maybe_zero_len, first_non_one);\n+\t\t\t\t     maybe_zero_len, first_non_one, is_omp);\n   if (ret == error_mark_node || ret == NULL_TREE)\n     return ret;\n \n@@ -4358,11 +4500,32 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n   if (length != NULL_TREE)\n     {\n       if (!integer_nonzerop (length))\n-\tmaybe_zero_len = true;\n+\t{\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t    {\n+\t      if (integer_zerop (length))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"zero length array section in %qs clause\",\n+\t\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t    }\n+\t  else\n+\t    maybe_zero_len = true;\n+\t}\n       if (first_non_one == types.length ()\n \t  && (TREE_CODE (length) != INTEGER_CST || integer_onep (length)))\n \tfirst_non_one++;\n     }\n+  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+      && !integer_zerop (low_bound))\n+    {\n+      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\"%<reduction%> array section has to be zero-based\");\n+      return error_mark_node;\n+    }\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       if (length == NULL_TREE\n@@ -4410,7 +4573,17 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t  return error_mark_node;\n \t\t}\n \t      if (tree_int_cst_equal (size, low_bound))\n-\t\tmaybe_zero_len = true;\n+\t\t{\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t\t    {\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"zero length array section in %qs clause\",\n+\t\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t      return error_mark_node;\n+\t\t    }\n+\t\t  maybe_zero_len = true;\n+\t\t}\n \t      else if (length == NULL_TREE\n \t\t       && first_non_one == types.length ()\n \t\t       && tree_int_cst_equal\n@@ -4420,7 +4593,9 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t    }\n \t  else if (length == NULL_TREE)\n \t    {\n-\t      maybe_zero_len = true;\n+\t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+\t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+\t\tmaybe_zero_len = true;\n \t      if (first_non_one == types.length ())\n \t\tfirst_non_one++;\n \t    }\n@@ -4454,7 +4629,9 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t}\n       else if (length == NULL_TREE)\n \t{\n-\t  maybe_zero_len = true;\n+\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+\t    maybe_zero_len = true;\n \t  if (first_non_one == types.length ())\n \t    first_non_one++;\n \t}\n@@ -4478,6 +4655,15 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t    \"for pointer type length expression must be specified\");\n \t  return error_mark_node;\n \t}\n+      if (length != NULL_TREE\n+\t  && TREE_CODE (length) == INTEGER_CST\n+\t  && tree_int_cst_sgn (length) == -1)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"negative length in array section in %qs clause\",\n+\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t  return error_mark_node;\n+\t}\n       /* If there is a pointer type anywhere but in the very first\n \t array-section-subscript, the array section can't be contiguous.  */\n       if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n@@ -4511,13 +4697,14 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n /* Handle array sections for clause C.  */\n \n static bool\n-handle_omp_array_sections (tree c)\n+handle_omp_array_sections (tree c, bool is_omp)\n {\n   bool maybe_zero_len = false;\n   unsigned int first_non_one = 0;\n-  auto_vec<tree> types;\n+  auto_vec<tree, 10> types;\n   tree first = handle_omp_array_sections_1 (c, OMP_CLAUSE_DECL (c), types,\n-\t\t\t\t\t    maybe_zero_len, first_non_one);\n+\t\t\t\t\t    maybe_zero_len, first_non_one,\n+\t\t\t\t\t    is_omp);\n   if (first == error_mark_node)\n     return true;\n   if (first == NULL_TREE)\n@@ -4619,7 +4806,9 @@ handle_omp_array_sections (tree c)\n \t    {\n \t      tree l;\n \n-\t      if (i > first_non_one && length && integer_nonzerop (length))\n+\t      if (i > first_non_one\n+\t\t  && ((length && integer_nonzerop (length))\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION))\n \t\tcontinue;\n \t      if (length)\n \t\tl = fold_convert (sizetype, length);\n@@ -4644,6 +4833,12 @@ handle_omp_array_sections (tree c)\n \t      else if (size == NULL_TREE)\n \t\t{\n \t\t  size = size_in_bytes (TREE_TYPE (types[i]));\n+\t\t  tree eltype = TREE_TYPE (types[num - 1]);\n+\t\t  while (TREE_CODE (eltype) == ARRAY_TYPE)\n+\t\t    eltype = TREE_TYPE (eltype);\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t\t    size = size_binop (EXACT_DIV_EXPR, size,\n+\t\t\t\t       size_in_bytes (eltype));\n \t\t  size = size_binop (MULT_EXPR, size, l);\n \t\t  if (condition)\n \t\t    size = fold_build3 (COND_EXPR, sizetype, condition,\n@@ -4657,14 +4852,52 @@ handle_omp_array_sections (tree c)\n \t{\n \t  if (side_effects)\n \t    size = build2 (COMPOUND_EXPR, sizetype, side_effects, size);\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t    {\n+\t      size = size_binop (MINUS_EXPR, size, size_one_node);\n+\t      tree index_type = build_index_type (size);\n+\t      tree eltype = TREE_TYPE (first);\n+\t      while (TREE_CODE (eltype) == ARRAY_TYPE)\n+\t\teltype = TREE_TYPE (eltype);\n+\t      tree type = build_array_type (eltype, index_type);\n+\t      tree ptype = build_pointer_type (eltype);\n+\t      if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE\n+\t\t  && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (t))))\n+\t\tt = convert_from_reference (t);\n+\t      else if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n+\t\tt = build_fold_addr_expr (t);\n+\t      t = build2 (MEM_REF, type, t, build_int_cst (ptype, 0));\n+\t      OMP_CLAUSE_DECL (c) = t;\n+\t      return false;\n+\t    }\n \t  OMP_CLAUSE_DECL (c) = first;\n \t  OMP_CLAUSE_SIZE (c) = size;\n-\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n+\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP\n+\t      || (TREE_CODE (t) == COMPONENT_REF\n+\t\t  && TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE))\n \t    return false;\n+\t  if (is_omp)\n+\t    switch (OMP_CLAUSE_MAP_KIND (c))\n+\t      {\n+\t      case GOMP_MAP_ALLOC:\n+\t      case GOMP_MAP_TO:\n+\t      case GOMP_MAP_FROM:\n+\t      case GOMP_MAP_TOFROM:\n+\t      case GOMP_MAP_ALWAYS_TO:\n+\t      case GOMP_MAP_ALWAYS_FROM:\n+\t      case GOMP_MAP_ALWAYS_TOFROM:\n+\t      case GOMP_MAP_RELEASE:\n+\t      case GOMP_MAP_DELETE:\n+\t\tOMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION (c) = 1;\n+\t\tbreak;\n+\t      default:\n+\t\tbreak;\n+\t      }\n \t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t      OMP_CLAUSE_MAP);\n-\t  OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_POINTER);\n-\t  if (!cxx_mark_addressable (t))\n+\t  OMP_CLAUSE_SET_MAP_KIND (c2, is_omp ? GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t\t\t\t      : GOMP_MAP_POINTER);\n+\t  if (!is_omp && !cxx_mark_addressable (t))\n \t    return false;\n \t  OMP_CLAUSE_DECL (c2) = t;\n \t  t = build_fold_addr_expr (first);\n@@ -4682,7 +4915,8 @@ handle_omp_array_sections (tree c)\n \t  OMP_CLAUSE_CHAIN (c2) = OMP_CLAUSE_CHAIN (c);\n \t  OMP_CLAUSE_CHAIN (c) = c2;\n \t  ptr = OMP_CLAUSE_DECL (c2);\n-\t  if (TREE_CODE (TREE_TYPE (ptr)) == REFERENCE_TYPE\n+\t  if (!is_omp\n+\t      && TREE_CODE (TREE_TYPE (ptr)) == REFERENCE_TYPE\n \t      && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (ptr))))\n \t    {\n \t      tree c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n@@ -5091,9 +5325,45 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n {\n   tree t = OMP_CLAUSE_DECL (c);\n   bool predefined = false;\n+  if (TREE_CODE (t) == TREE_LIST)\n+    {\n+      gcc_assert (processing_template_decl);\n+      return false;\n+    }\n   tree type = TREE_TYPE (t);\n+  if (TREE_CODE (t) == MEM_REF)\n+    type = TREE_TYPE (type);\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      tree oatype = type;\n+      gcc_assert (TREE_CODE (t) != MEM_REF);\n+      while (TREE_CODE (type) == ARRAY_TYPE)\n+\ttype = TREE_TYPE (type);\n+      if (!processing_template_decl)\n+\t{\n+\t  t = require_complete_type (t);\n+\t  if (t == error_mark_node)\n+\t    return true;\n+\t  tree size = size_binop (EXACT_DIV_EXPR, TYPE_SIZE_UNIT (oatype),\n+\t\t\t\t  TYPE_SIZE_UNIT (type));\n+\t  if (integer_zerop (size))\n+\t    {\n+\t      error (\"%qE in %<reduction%> clause is a zero size array\",\n+\t\t     omp_clause_printable_decl (t));\n+\t      return true;\n+\t    }\n+\t  size = size_binop (MINUS_EXPR, size, size_one_node);\n+\t  tree index_type = build_index_type (size);\n+\t  tree atype = build_array_type (type, index_type);\n+\t  tree ptype = build_pointer_type (type);\n+\t  if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n+\t    t = build_fold_addr_expr (t);\n+\t  t = build2 (MEM_REF, atype, t, build_int_cst (ptype, 0));\n+\t  OMP_CLAUSE_DECL (c) = t;\n+\t}\n+    }\n   if (type == error_mark_node)\n     return true;\n   else if (ARITHMETIC_TYPE_P (type))\n@@ -5126,9 +5396,10 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n       default:\n \tbreak;\n       }\n-  else if (TREE_CODE (type) == ARRAY_TYPE || TYPE_READONLY (type))\n+  else if (TYPE_READONLY (type))\n     {\n-      error (\"%qE has invalid type for %<reduction%>\", t);\n+      error (\"%qE has const type for %<reduction%>\",\n+\t     omp_clause_printable_decl (t));\n       return true;\n     }\n   else if (!processing_template_decl)\n@@ -5149,9 +5420,7 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n \n   tree id = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);\n \n-  type = TYPE_MAIN_VARIANT (TREE_TYPE (t));\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n+  type = TYPE_MAIN_VARIANT (type);\n   OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = NULL_TREE;\n   if (id == NULL_TREE)\n     id = omp_reduction_id (OMP_CLAUSE_REDUCTION_CODE (c),\n@@ -5169,7 +5438,7 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n       if (TREE_CODE (body) == STATEMENT_LIST)\n \t{\n \t  tree_stmt_iterator tsi;\n-\t  tree placeholder = NULL_TREE;\n+\t  tree placeholder = NULL_TREE, decl_placeholder = NULL_TREE;\n \t  int i;\n \t  tree stmts[7];\n \t  tree atype = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (id)));\n@@ -5190,14 +5459,24 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n \t      DECL_ARTIFICIAL (placeholder) = 1;\n \t      DECL_IGNORED_P (placeholder) = 1;\n \t      OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = placeholder;\n+\t      if (TREE_CODE (t) == MEM_REF)\n+\t\t{\n+\t\t  decl_placeholder = build_lang_decl (VAR_DECL, NULL_TREE,\n+\t\t\t\t\t\t      type);\n+\t\t  DECL_ARTIFICIAL (decl_placeholder) = 1;\n+\t\t  DECL_IGNORED_P (decl_placeholder) = 1;\n+\t\t  OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (c) = decl_placeholder;\n+\t\t}\n \t      if (TREE_ADDRESSABLE (DECL_EXPR_DECL (stmts[0])))\n \t\tcxx_mark_addressable (placeholder);\n \t      if (TREE_ADDRESSABLE (DECL_EXPR_DECL (stmts[1]))\n \t\t  && TREE_CODE (TREE_TYPE (OMP_CLAUSE_DECL (c)))\n \t\t     != REFERENCE_TYPE)\n-\t\tcxx_mark_addressable (OMP_CLAUSE_DECL (c));\n+\t\tcxx_mark_addressable (decl_placeholder ? decl_placeholder\n+\t\t\t\t      : OMP_CLAUSE_DECL (c));\n \t      tree omp_out = placeholder;\n-\t      tree omp_in = convert_from_reference (OMP_CLAUSE_DECL (c));\n+\t      tree omp_in = decl_placeholder ? decl_placeholder\n+\t\t\t    : convert_from_reference (OMP_CLAUSE_DECL (c));\n \t      if (need_static_cast)\n \t\t{\n \t\t  tree rtype = build_reference_type (atype);\n@@ -5219,10 +5498,12 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n \t      gcc_assert (TREE_CODE (stmts[3]) == DECL_EXPR\n \t\t\t  && TREE_CODE (stmts[4]) == DECL_EXPR);\n \t      if (TREE_ADDRESSABLE (DECL_EXPR_DECL (stmts[3])))\n-\t\tcxx_mark_addressable (OMP_CLAUSE_DECL (c));\n+\t\tcxx_mark_addressable (decl_placeholder ? decl_placeholder\n+\t\t\t\t      : OMP_CLAUSE_DECL (c));\n \t      if (TREE_ADDRESSABLE (DECL_EXPR_DECL (stmts[4])))\n \t\tcxx_mark_addressable (placeholder);\n-\t      tree omp_priv = convert_from_reference (OMP_CLAUSE_DECL (c));\n+\t      tree omp_priv = decl_placeholder ? decl_placeholder\n+\t\t\t      : convert_from_reference (OMP_CLAUSE_DECL (c));\n \t      tree omp_orig = placeholder;\n \t      if (need_static_cast)\n \t\t{\n@@ -5261,7 +5542,8 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n \t      else\n \t\t{\n \t\t  tree init;\n-\t\t  tree v = convert_from_reference (t);\n+\t\t  tree v = decl_placeholder ? decl_placeholder\n+\t\t\t   : convert_from_reference (t);\n \t\t  if (AGGREGATE_TYPE_P (TREE_TYPE (v)))\n \t\t    init = build_constructor (TREE_TYPE (v), NULL);\n \t\t  else\n@@ -5276,21 +5558,98 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n     *need_dtor = true;\n   else\n     {\n-      error (\"user defined reduction not found for %qD\", t);\n+      error (\"user defined reduction not found for %qE\",\n+\t     omp_clause_printable_decl (t));\n       return true;\n     }\n+  if (TREE_CODE (OMP_CLAUSE_DECL (c)) == MEM_REF)\n+    gcc_assert (TYPE_SIZE_UNIT (type)\n+\t\t&& TREE_CODE (TYPE_SIZE_UNIT (type)) == INTEGER_CST);\n+  return false;\n+}\n+\n+/* Called from finish_struct_1.  linear(this) or linear(this:step)\n+   clauses might not be finalized yet because the class has been incomplete\n+   when parsing #pragma omp declare simd methods.  Fix those up now.  */\n+\n+void\n+finish_omp_declare_simd_methods (tree t)\n+{\n+  if (processing_template_decl)\n+    return;\n+\n+  for (tree x = TYPE_METHODS (t); x; x = DECL_CHAIN (x))\n+    {\n+      if (TREE_CODE (TREE_TYPE (x)) != METHOD_TYPE)\n+\tcontinue;\n+      tree ods = lookup_attribute (\"omp declare simd\", DECL_ATTRIBUTES (x));\n+      if (!ods || !TREE_VALUE (ods))\n+\tcontinue;\n+      for (tree c = TREE_VALUE (TREE_VALUE (ods)); c; c = OMP_CLAUSE_CHAIN (c))\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR\n+\t    && integer_zerop (OMP_CLAUSE_DECL (c))\n+\t    && OMP_CLAUSE_LINEAR_STEP (c)\n+\t    && TREE_CODE (TREE_TYPE (OMP_CLAUSE_LINEAR_STEP (c)))\n+\t       == POINTER_TYPE)\n+\t  {\n+\t    tree s = OMP_CLAUSE_LINEAR_STEP (c);\n+\t    s = fold_convert_loc (OMP_CLAUSE_LOCATION (c), sizetype, s);\n+\t    s = fold_build2_loc (OMP_CLAUSE_LOCATION (c), MULT_EXPR,\n+\t\t\t\t sizetype, s, TYPE_SIZE_UNIT (t));\n+\t    OMP_CLAUSE_LINEAR_STEP (c) = s;\n+\t  }\n+    }\n+}\n+\n+/* Adjust sink depend clause to take into account pointer offsets.\n+\n+   Return TRUE if there was a problem processing the offset, and the\n+   whole clause should be removed.  */\n+\n+static bool\n+cp_finish_omp_clause_depend_sink (tree sink_clause)\n+{\n+  tree t = OMP_CLAUSE_DECL (sink_clause);\n+  gcc_assert (TREE_CODE (t) == TREE_LIST);\n+\n+  /* Make sure we don't adjust things twice for templates.  */\n+  if (processing_template_decl)\n+    return false;\n+\n+  for (; t; t = TREE_CHAIN (t))\n+    {\n+      tree decl = TREE_VALUE (t);\n+      if (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE)\n+\t{\n+\t  tree offset = TREE_PURPOSE (t);\n+\t  bool neg = wi::neg_p ((wide_int) offset);\n+\t  offset = fold_unary (ABS_EXPR, TREE_TYPE (offset), offset);\n+\t  decl = mark_rvalue_use (decl);\n+\t  decl = convert_from_reference (decl);\n+\t  tree t2 = pointer_int_sum (OMP_CLAUSE_LOCATION (sink_clause),\n+\t\t\t\t     neg ? MINUS_EXPR : PLUS_EXPR,\n+\t\t\t\t     decl, offset);\n+\t  t2 = fold_build2_loc (OMP_CLAUSE_LOCATION (sink_clause),\n+\t\t\t\tMINUS_EXPR, sizetype, t2,\n+\t\t\t\tdecl);\n+\t  if (t2 == error_mark_node)\n+\t    return true;\n+\t  TREE_PURPOSE (t) = t2;\n+\t}\n+    }\n   return false;\n }\n \n /* For all elements of CLAUSES, validate them vs OpenMP constraints.\n    Remove any elements from the list that are invalid.  */\n \n tree\n-finish_omp_clauses (tree clauses)\n+finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n {\n   bitmap_head generic_head, firstprivate_head, lastprivate_head;\n-  bitmap_head aligned_head;\n+  bitmap_head aligned_head, map_head, map_field_head, generic_field_head;\n   tree c, t, *pc;\n+  tree safelen = NULL_TREE;\n   bool branch_seen = false;\n   bool copyprivate_seen = false;\n \n@@ -5299,35 +5658,93 @@ finish_omp_clauses (tree clauses)\n   bitmap_initialize (&firstprivate_head, &bitmap_default_obstack);\n   bitmap_initialize (&lastprivate_head, &bitmap_default_obstack);\n   bitmap_initialize (&aligned_head, &bitmap_default_obstack);\n+  bitmap_initialize (&map_head, &bitmap_default_obstack);\n+  bitmap_initialize (&map_field_head, &bitmap_default_obstack);\n+  bitmap_initialize (&generic_field_head, &bitmap_default_obstack);\n \n   for (pc = &clauses, c = clauses; c ; c = *pc)\n     {\n       bool remove = false;\n+      bool field_ok = false;\n \n       switch (OMP_CLAUSE_CODE (c))\n \t{\n \tcase OMP_CLAUSE_SHARED:\n \t  goto check_dup_generic;\n \tcase OMP_CLAUSE_PRIVATE:\n+\t  field_ok = allow_fields;\n \t  goto check_dup_generic;\n \tcase OMP_CLAUSE_REDUCTION:\n+\t  field_ok = allow_fields;\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) == TREE_LIST)\n+\t    {\n+\t      if (handle_omp_array_sections (c, allow_fields))\n+\t\t{\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\t      if (TREE_CODE (t) == TREE_LIST)\n+\t\t{\n+\t\t  while (TREE_CODE (t) == TREE_LIST)\n+\t\t    t = TREE_CHAIN (t);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (TREE_CODE (t) == MEM_REF);\n+\t\t  t = TREE_OPERAND (t, 0);\n+\t\t  if (TREE_CODE (t) == ADDR_EXPR\n+\t\t      || TREE_CODE (t) == INDIRECT_REF)\n+\t\t    t = TREE_OPERAND (t, 0);\n+\t\t}\n+\t      tree n = omp_clause_decl_field (t);\n+\t      if (n)\n+\t\tt = n;\n+\t      goto check_dup_generic_t;\n+\t    }\n \t  goto check_dup_generic;\n \tcase OMP_CLAUSE_COPYPRIVATE:\n \t  copyprivate_seen = true;\n+\t  field_ok = allow_fields;\n \t  goto check_dup_generic;\n \tcase OMP_CLAUSE_COPYIN:\n \t  goto check_dup_generic;\n \tcase OMP_CLAUSE_LINEAR:\n+\t  field_ok = allow_fields;\n \t  t = OMP_CLAUSE_DECL (c);\n+\t  if (!declare_simd\n+\t      && OMP_CLAUSE_LINEAR_KIND (c) != OMP_CLAUSE_LINEAR_DEFAULT)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"modifier should not be specified in %<linear%> \"\n+\t\t\t\"clause on %<simd%> or %<for%> constructs\");\n+\t      OMP_CLAUSE_LINEAR_KIND (c) = OMP_CLAUSE_LINEAR_DEFAULT;\n+\t    }\n \t  if ((VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n-\t      && !type_dependent_expression_p (t)\n-\t      && !INTEGRAL_TYPE_P (TREE_TYPE (t))\n-\t      && TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE)\n+\t      && !type_dependent_expression_p (t))\n \t    {\n-\t      error (\"linear clause applied to non-integral non-pointer \"\n-\t\t     \"variable with %qT type\", TREE_TYPE (t));\n-\t      remove = true;\n-\t      break;\n+\t      tree type = TREE_TYPE (t);\n+\t      if ((OMP_CLAUSE_LINEAR_KIND (c) == OMP_CLAUSE_LINEAR_REF\n+\t\t   || OMP_CLAUSE_LINEAR_KIND (c) == OMP_CLAUSE_LINEAR_UVAL)\n+\t\t  && TREE_CODE (type) != REFERENCE_TYPE)\n+\t\t{\n+\t\t  error (\"linear clause with %qs modifier applied to \"\n+\t\t\t \"non-reference variable with %qT type\",\n+\t\t\t OMP_CLAUSE_LINEAR_KIND (c) == OMP_CLAUSE_LINEAR_REF\n+\t\t\t ? \"ref\" : \"uval\", TREE_TYPE (t));\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\t      if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t\ttype = TREE_TYPE (type);\n+\t      if (!INTEGRAL_TYPE_P (type)\n+\t\t  && TREE_CODE (type) != POINTER_TYPE)\n+\t\t{\n+\t\t  error (\"linear clause applied to non-integral non-pointer \"\n+\t\t\t \"variable with %qT type\", TREE_TYPE (t));\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n \t    }\n \t  t = OMP_CLAUSE_LINEAR_STEP (c);\n \t  if (t == NULL_TREE)\n@@ -5354,29 +5771,72 @@ finish_omp_clauses (tree clauses)\n \t\t  if (TREE_CODE (OMP_CLAUSE_DECL (c)) == PARM_DECL)\n \t\t    t = maybe_constant_value (t);\n \t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n-\t\t  if (TREE_CODE (TREE_TYPE (OMP_CLAUSE_DECL (c)))\n-\t\t      == POINTER_TYPE)\n+\t\t  tree type = TREE_TYPE (OMP_CLAUSE_DECL (c));\n+\t\t  if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t\t    type = TREE_TYPE (type);\n+\t\t  if (OMP_CLAUSE_LINEAR_KIND (c) == OMP_CLAUSE_LINEAR_REF)\n+\t\t    {\n+\t\t      type = build_pointer_type (type);\n+\t\t      tree d = fold_convert (type, OMP_CLAUSE_DECL (c));\n+\t\t      t = pointer_int_sum (OMP_CLAUSE_LOCATION (c), PLUS_EXPR,\n+\t\t\t\t\t   d, t);\n+\t\t      t = fold_build2_loc (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t   MINUS_EXPR, sizetype, t, d);\n+\t\t      if (t == error_mark_node)\n+\t\t\t{\n+\t\t\t  remove = true;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t  else if (TREE_CODE (type) == POINTER_TYPE\n+\t\t\t   /* Can't multiply the step yet if *this\n+\t\t\t      is still incomplete type.  */\n+\t\t\t   && (!declare_simd\n+\t\t\t       || TREE_CODE (OMP_CLAUSE_DECL (c)) != PARM_DECL\n+\t\t\t       || !DECL_ARTIFICIAL (OMP_CLAUSE_DECL (c))\n+\t\t\t       || DECL_NAME (OMP_CLAUSE_DECL (c))\n+\t\t\t\t  != this_identifier\n+\t\t\t       || !TYPE_BEING_DEFINED (TREE_TYPE (type))))\n \t\t    {\n+\t\t      tree d = convert_from_reference (OMP_CLAUSE_DECL (c));\n \t\t      t = pointer_int_sum (OMP_CLAUSE_LOCATION (c), PLUS_EXPR,\n-\t\t\t\t\t   OMP_CLAUSE_DECL (c), t);\n+\t\t\t\t\t   d, t);\n \t\t      t = fold_build2_loc (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t   MINUS_EXPR, sizetype, t,\n-\t\t\t\t\t   OMP_CLAUSE_DECL (c));\n+\t\t\t\t\t   MINUS_EXPR, sizetype, t, d);\n \t\t      if (t == error_mark_node)\n \t\t\t{\n \t\t\t  remove = true;\n \t\t\t  break;\n \t\t\t}\n \t\t    }\n \t\t  else\n-\t\t    t = fold_convert (TREE_TYPE (OMP_CLAUSE_DECL (c)), t);\n+\t\t    t = fold_convert (type, t);\n \t\t}\n \t      OMP_CLAUSE_LINEAR_STEP (c) = t;\n \t    }\n \t  goto check_dup_generic;\n \tcheck_dup_generic:\n-\t  t = OMP_CLAUSE_DECL (c);\n-\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n+\t  t = omp_clause_decl_field (OMP_CLAUSE_DECL (c));\n+\t  if (t)\n+\t    {\n+\t      if (!remove)\n+\t\tomp_note_field_privatization (t, OMP_CLAUSE_DECL (c));\n+\t    }\n+\t  else\n+\t    t = OMP_CLAUSE_DECL (c);\n+\tcheck_dup_generic_t:\n+\t  if (t == current_class_ptr\n+\t      && (!declare_simd\n+\t\t  || (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_LINEAR\n+\t\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_UNIFORM)))\n+\t    {\n+\t      error (\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n+\t\t     \" clauses\");\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL\n+\t      && (!field_ok || TREE_CODE (t) != FIELD_DECL))\n \t    {\n \t      if (processing_template_decl)\n \t\tbreak;\n@@ -5397,11 +5857,34 @@ finish_omp_clauses (tree clauses)\n \t    }\n \t  else\n \t    bitmap_set_bit (&generic_head, DECL_UID (t));\n+\t  if (!field_ok)\n+\t    break;\n+\thandle_field_decl:\n+\t  if (!remove\n+\t      && TREE_CODE (t) == FIELD_DECL\n+\t      && t == OMP_CLAUSE_DECL (c))\n+\t    {\n+\t      OMP_CLAUSE_DECL (c) = omp_privatize_field (t);\n+\t      if (OMP_CLAUSE_DECL (c) == error_mark_node)\n+\t\tremove = true;\n+\t    }\n \t  break;\n \n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n-\t  t = OMP_CLAUSE_DECL (c);\n-\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n+\t  t = omp_clause_decl_field (OMP_CLAUSE_DECL (c));\n+\t  if (t)\n+\t    omp_note_field_privatization (t, OMP_CLAUSE_DECL (c));\n+\t  else\n+\t    t = OMP_CLAUSE_DECL (c);\n+\t  if (t == current_class_ptr)\n+\t    {\n+\t      error (\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n+\t\t     \" clauses\");\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL\n+\t      && (!allow_fields || TREE_CODE (t) != FIELD_DECL))\n \t    {\n \t      if (processing_template_decl)\n \t\tbreak;\n@@ -5419,11 +5902,23 @@ finish_omp_clauses (tree clauses)\n \t    }\n \t  else\n \t    bitmap_set_bit (&firstprivate_head, DECL_UID (t));\n-\t  break;\n+\t  goto handle_field_decl;\n \n \tcase OMP_CLAUSE_LASTPRIVATE:\n-\t  t = OMP_CLAUSE_DECL (c);\n-\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n+\t  t = omp_clause_decl_field (OMP_CLAUSE_DECL (c));\n+\t  if (t)\n+\t    omp_note_field_privatization (t, OMP_CLAUSE_DECL (c));\n+\t  else\n+\t    t = OMP_CLAUSE_DECL (c);\n+\t  if (t == current_class_ptr)\n+\t    {\n+\t      error (\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n+\t\t     \" clauses\");\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL\n+\t      && (!allow_fields || TREE_CODE (t) != FIELD_DECL))\n \t    {\n \t      if (processing_template_decl)\n \t\tbreak;\n@@ -5441,7 +5936,7 @@ finish_omp_clauses (tree clauses)\n \t    }\n \t  else\n \t    bitmap_set_bit (&lastprivate_head, DECL_UID (t));\n-\t  break;\n+\t  goto handle_field_decl;\n \n \tcase OMP_CLAUSE_IF:\n \t  t = OMP_CLAUSE_IF_EXPR (c);\n@@ -5477,7 +5972,17 @@ finish_omp_clauses (tree clauses)\n \t    {\n \t      t = mark_rvalue_use (t);\n \t      if (!processing_template_decl)\n-\t\tt = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t\t{\n+\t\t  t = maybe_constant_value (t);\n+\t\t  if (TREE_CODE (t) == INTEGER_CST\n+\t\t      && tree_int_cst_sgn (t) != 1)\n+\t\t    {\n+\t\t      warning_at (OMP_CLAUSE_LOCATION (c), 0,\n+\t\t\t\t  \"%<num_threads%> value must be positive\");\n+\t\t      t = integer_one_node;\n+\t\t    }\n+\t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t\t}\n \t      OMP_CLAUSE_NUM_THREADS_EXPR (c) = t;\n \t    }\n \t  break;\n@@ -5545,6 +6050,8 @@ finish_omp_clauses (tree clauses)\n \t\t    }\n \t\t}\n \t      OMP_CLAUSE_OPERAND (c, 0) = t;\n+\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SAFELEN)\n+\t\tsafelen = c;\n \t    }\n \t  break;\n \n@@ -5562,7 +6069,17 @@ finish_omp_clauses (tree clauses)\n \t    {\n \t      t = mark_rvalue_use (t);\n \t      if (!processing_template_decl)\n-\t\tt = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t\t{\n+\t\t  t = maybe_constant_value (t);\n+\t\t  if (TREE_CODE (t) == INTEGER_CST\n+\t\t      && tree_int_cst_sgn (t) != 1)\n+\t\t    {\n+\t\t      warning_at (OMP_CLAUSE_LOCATION (c), 0,\n+\t\t\t\t  \"%<num_teams%> value must be positive\");\n+\t\t      t = integer_one_node;\n+\t\t    }\n+\t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t\t}\n \t      OMP_CLAUSE_NUM_TEAMS_EXPR (c) = t;\n \t    }\n \t  break;\n@@ -5619,7 +6136,17 @@ finish_omp_clauses (tree clauses)\n \t    {\n \t      t = mark_rvalue_use (t);\n \t      if (!processing_template_decl)\n-\t\tt = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t\t{\n+\t\t  t = maybe_constant_value (t);\n+\t\t  if (TREE_CODE (t) == INTEGER_CST\n+\t\t      && tree_int_cst_sgn (t) != 1)\n+\t\t    {\n+\t\t      warning_at (OMP_CLAUSE_LOCATION (c), 0,\n+\t\t\t\t  \"%<thread_limit%> value must be positive\");\n+\t\t      t = integer_one_node;\n+\t\t    }\n+\t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t\t}\n \t      OMP_CLAUSE_THREAD_LIMIT_EXPR (c) = t;\n \t    }\n \t  break;\n@@ -5667,6 +6194,13 @@ finish_omp_clauses (tree clauses)\n \n \tcase OMP_CLAUSE_ALIGNED:\n \t  t = OMP_CLAUSE_DECL (c);\n+\t  if (t == current_class_ptr && !declare_simd)\n+\t    {\n+\t      error (\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n+\t\t     \" clauses\");\n+\t      remove = true;\n+\t      break;\n+\t    }\n \t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t    {\n \t      if (processing_template_decl)\n@@ -5729,9 +6263,21 @@ finish_omp_clauses (tree clauses)\n \n \tcase OMP_CLAUSE_DEPEND:\n \t  t = OMP_CLAUSE_DECL (c);\n+\t  if (t == NULL_TREE)\n+\t    {\n+\t      gcc_assert (OMP_CLAUSE_DEPEND_KIND (c)\n+\t\t\t  == OMP_CLAUSE_DEPEND_SOURCE);\n+\t      break;\n+\t    }\n+\t  if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK)\n+\t    {\n+\t      if (cp_finish_omp_clause_depend_sink (c))\n+\t\tremove = true;\n+\t      break;\n+\t    }\n \t  if (TREE_CODE (t) == TREE_LIST)\n \t    {\n-\t      if (handle_omp_array_sections (c))\n+\t      if (handle_omp_array_sections (c, allow_fields))\n \t\tremove = true;\n \t      break;\n \t    }\n@@ -5747,6 +6293,12 @@ finish_omp_clauses (tree clauses)\n \t\terror (\"%qE is not a variable in %<depend%> clause\", t);\n \t      remove = true;\n \t    }\n+\t  else if (t == current_class_ptr)\n+\t    {\n+\t      error (\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n+\t\t     \" clauses\");\n+\t      remove = true;\n+\t    }\n \t  else if (!processing_template_decl\n \t\t   && !cxx_mark_addressable (t))\n \t    remove = true;\n@@ -5759,7 +6311,7 @@ finish_omp_clauses (tree clauses)\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (t) == TREE_LIST)\n \t    {\n-\t      if (handle_omp_array_sections (c))\n+\t      if (handle_omp_array_sections (c, allow_fields))\n \t\tremove = true;\n \t      else\n \t\t{\n@@ -5774,12 +6326,90 @@ finish_omp_clauses (tree clauses)\n \t\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t\t      remove = true;\n \t\t    }\n+\t\t  while (TREE_CODE (t) == ARRAY_REF)\n+\t\t    t = TREE_OPERAND (t, 0);\n+\t\t  if (TREE_CODE (t) == COMPONENT_REF\n+\t\t      && TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n+\t\t    {\n+\t\t      while (TREE_CODE (t) == COMPONENT_REF)\n+\t\t\tt = TREE_OPERAND (t, 0);\n+\t\t      if (bitmap_bit_p (&map_field_head, DECL_UID (t)))\n+\t\t\tbreak;\n+\t\t      if (bitmap_bit_p (&map_head, DECL_UID (t)))\n+\t\t\t{\n+\t\t\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n+\t\t\t    error (\"%qD appears more than once in motion\"\n+\t\t\t\t   \" clauses\", t);\n+\t\t\t  else\n+\t\t\t    error (\"%qD appears more than once in map\"\n+\t\t\t\t   \" clauses\", t);\n+\t\t\t  remove = true;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  bitmap_set_bit (&map_head, DECL_UID (t));\n+\t\t\t  bitmap_set_bit (&map_field_head, DECL_UID (t));\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t      break;\n \t    }\n \t  if (t == error_mark_node)\n-\t    remove = true;\n-\t  else if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  if (REFERENCE_REF_P (t)\n+\t      && TREE_CODE (TREE_OPERAND (t, 0)) == COMPONENT_REF)\n+\t    t = TREE_OPERAND (t, 0);\n+\t  if (TREE_CODE (t) == COMPONENT_REF\n+\t      && allow_fields\n+\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE__CACHE_)\n+\t    {\n+\t      if (type_dependent_expression_p (t))\n+\t\tbreak;\n+\t      if (DECL_BIT_FIELD (TREE_OPERAND (t, 1)))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"bit-field %qE in %qs clause\",\n+\t\t\t    t, omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  remove = true;\n+\t\t}\n+\t      else if (!cp_omp_mappable_type (TREE_TYPE (t)))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qE does not have a mappable type in %qs clause\",\n+\t\t\t    t, omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  remove = true;\n+\t\t}\n+\t      while (TREE_CODE (t) == COMPONENT_REF)\n+\t\t{\n+\t\t  if (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0)))\n+\t\t      == UNION_TYPE)\n+\t\t    {\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"%qE is a member of a union\", t);\n+\t\t      remove = true;\n+\t\t      break;\n+\t\t    }\n+\t\t  t = TREE_OPERAND (t, 0);\n+\t\t}\n+\t      if (remove)\n+\t\tbreak;\n+\t      if (VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n+\t\t{\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t\t      && (OMP_CLAUSE_MAP_KIND (c)\n+\t\t\t  == GOMP_MAP_FIRSTPRIVATE_POINTER))\n+\t\t    {\n+\t\t      if (bitmap_bit_p (&generic_field_head, DECL_UID (t)))\n+\t\t\tbreak;\n+\t\t    }\n+\t\t  else if (bitmap_bit_p (&map_field_head, DECL_UID (t)))\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t    {\n \t      if (processing_template_decl)\n \t\tbreak;\n@@ -5800,12 +6430,22 @@ finish_omp_clauses (tree clauses)\n \t\t     omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n+\t  else if (t == current_class_ptr)\n+\t    {\n+\t      error (\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n+\t\t     \" clauses\");\n+\t      remove = true;\n+\t      break;\n+\t    }\n \t  else if (!processing_template_decl\n \t\t   && TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE\n \t\t   && !cxx_mark_addressable (t))\n \t    remove = true;\n \t  else if (!(OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t\t     && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER)\n+\t\t     && (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER\n+\t\t\t || (OMP_CLAUSE_MAP_KIND (c)\n+\t\t\t     == GOMP_MAP_FIRSTPRIVATE_POINTER)))\n+\t\t   && t == OMP_CLAUSE_DECL (c)\n \t\t   && !type_dependent_expression_p (t)\n \t\t   && !cp_omp_mappable_type ((TREE_CODE (TREE_TYPE (t))\n \t\t\t\t\t      == REFERENCE_TYPE)\n@@ -5817,7 +6457,28 @@ finish_omp_clauses (tree clauses)\n \t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n-\t  else if (bitmap_bit_p (&generic_head, DECL_UID (t)))\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t\t   && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER)\n+\t    {\n+\t      if (bitmap_bit_p (&generic_head, DECL_UID (t))\n+\t\t  || bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n+\t\t{\n+\t\t  error (\"%qD appears more than once in data clauses\", t);\n+\t\t  remove = true;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  bitmap_set_bit (&generic_head, DECL_UID (t));\n+\t\t  if (t != OMP_CLAUSE_DECL (c)\n+\t\t      && (TREE_CODE (OMP_CLAUSE_DECL (c)) == COMPONENT_REF\n+\t\t\t  || (REFERENCE_REF_P (OMP_CLAUSE_DECL (c))\n+\t\t\t      && (TREE_CODE (TREE_OPERAND (OMP_CLAUSE_DECL (c),\n+\t\t\t\t\t\t\t   0))\n+\t\t\t\t  == COMPONENT_REF))))\n+\t\t    bitmap_set_bit (&generic_field_head, DECL_UID (t));\n+\t\t}\n+\t    }\n+\t  else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n \t    {\n \t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n \t\terror (\"%qD appears more than once in motion clauses\", t);\n@@ -5826,7 +6487,42 @@ finish_omp_clauses (tree clauses)\n \t      remove = true;\n \t    }\n \t  else\n-\t    bitmap_set_bit (&generic_head, DECL_UID (t));\n+\t    {\n+\t      bitmap_set_bit (&map_head, DECL_UID (t));\n+\t      if (t != OMP_CLAUSE_DECL (c)\n+\t\t  && TREE_CODE (OMP_CLAUSE_DECL (c)) == COMPONENT_REF)\n+\t\tbitmap_set_bit (&map_field_head, DECL_UID (t));\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_TO_DECLARE:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) == FUNCTION_DECL)\n+\t    break;\n+\t  /* FALLTHRU */\n+\tcase OMP_CLAUSE_LINK:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (!VAR_P (t))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE is not a variable in clause %qs\", t,\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      remove = true;\n+\t    }\n+\t  else if (DECL_THREAD_LOCAL_P (t))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD is threadprivate variable in %qs clause\", t,\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      remove = true;\n+\t    }\n+\t  else if (!cp_omp_mappable_type (TREE_TYPE (t)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD does not have a mappable type in %qs clause\", t,\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      remove = true;\n+\t    }\n \t  break;\n \n \tcase OMP_CLAUSE_UNIFORM:\n@@ -5844,6 +6540,137 @@ finish_omp_clauses (tree clauses)\n \t    }\n \t  goto check_dup_generic;\n \n+\tcase OMP_CLAUSE_NUM_TASKS:\n+\t  t = OMP_CLAUSE_NUM_TASKS_EXPR (c);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (!type_dependent_expression_p (t)\n+\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      error (\"%<num_tasks%> expression must be integral\");\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      t = mark_rvalue_use (t);\n+\t      if (!processing_template_decl)\n+\t\t{\n+\t\t  t = maybe_constant_value (t);\n+\t\t  if (TREE_CODE (t) == INTEGER_CST\n+\t\t      && tree_int_cst_sgn (t) != 1)\n+\t\t    {\n+\t\t      warning_at (OMP_CLAUSE_LOCATION (c), 0,\n+\t\t\t\t  \"%<num_tasks%> value must be positive\");\n+\t\t      t = integer_one_node;\n+\t\t    }\n+\t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t\t}\n+\t      OMP_CLAUSE_NUM_TASKS_EXPR (c) = t;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_GRAINSIZE:\n+\t  t = OMP_CLAUSE_GRAINSIZE_EXPR (c);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (!type_dependent_expression_p (t)\n+\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      error (\"%<grainsize%> expression must be integral\");\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      t = mark_rvalue_use (t);\n+\t      if (!processing_template_decl)\n+\t\t{\n+\t\t  t = maybe_constant_value (t);\n+\t\t  if (TREE_CODE (t) == INTEGER_CST\n+\t\t      && tree_int_cst_sgn (t) != 1)\n+\t\t    {\n+\t\t      warning_at (OMP_CLAUSE_LOCATION (c), 0,\n+\t\t\t\t  \"%<grainsize%> value must be positive\");\n+\t\t      t = integer_one_node;\n+\t\t    }\n+\t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t\t}\n+\t      OMP_CLAUSE_GRAINSIZE_EXPR (c) = t;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_PRIORITY:\n+\t  t = OMP_CLAUSE_PRIORITY_EXPR (c);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (!type_dependent_expression_p (t)\n+\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      error (\"%<priority%> expression must be integral\");\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      t = mark_rvalue_use (t);\n+\t      if (!processing_template_decl)\n+\t\t{\n+\t\t  t = maybe_constant_value (t);\n+\t\t  if (TREE_CODE (t) == INTEGER_CST\n+\t\t      && tree_int_cst_sgn (t) == -1)\n+\t\t    {\n+\t\t      warning_at (OMP_CLAUSE_LOCATION (c), 0,\n+\t\t\t\t  \"%<priority%> value must be non-negative\");\n+\t\t      t = integer_one_node;\n+\t\t    }\n+\t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t\t}\n+\t      OMP_CLAUSE_PRIORITY_EXPR (c) = t;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_HINT:\n+\t  t = OMP_CLAUSE_HINT_EXPR (c);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (!type_dependent_expression_p (t)\n+\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      error (\"%<num_tasks%> expression must be integral\");\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      t = mark_rvalue_use (t);\n+\t      if (!processing_template_decl)\n+\t\t{\n+\t\t  t = maybe_constant_value (t);\n+\t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t\t}\n+\t      OMP_CLAUSE_HINT_EXPR (c) = t;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_IS_DEVICE_PTR:\n+\tcase OMP_CLAUSE_USE_DEVICE_PTR:\n+\t  field_ok = allow_fields;\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (!type_dependent_expression_p (t))\n+\t    {\n+\t      tree type = TREE_TYPE (t);\n+\t      if (TREE_CODE (type) != POINTER_TYPE\n+\t\t  && TREE_CODE (type) != ARRAY_TYPE\n+\t\t  && (TREE_CODE (type) != REFERENCE_TYPE\n+\t\t      || (TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n+\t\t\t  && TREE_CODE (TREE_TYPE (type)) != ARRAY_TYPE)))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qs variable is neither a pointer, nor an array\"\n+\t\t\t    \"nor reference to pointer or array\",\n+\t\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  remove = true;\n+\t\t}\n+\t    }\n+\t  goto check_dup_generic;\n+\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n@@ -5855,6 +6682,10 @@ finish_omp_clauses (tree clauses)\n \tcase OMP_CLAUSE_SECTIONS:\n \tcase OMP_CLAUSE_TASKGROUP:\n \tcase OMP_CLAUSE_PROC_BIND:\n+\tcase OMP_CLAUSE_NOGROUP:\n+\tcase OMP_CLAUSE_THREADS:\n+\tcase OMP_CLAUSE_SIMD:\n+\tcase OMP_CLAUSE_DEFAULTMAP:\n \tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \t  break;\n \n@@ -5883,7 +6714,7 @@ finish_omp_clauses (tree clauses)\n     {\n       enum omp_clause_code c_kind = OMP_CLAUSE_CODE (c);\n       bool remove = false;\n-      bool need_complete_non_reference = false;\n+      bool need_complete_type = false;\n       bool need_default_ctor = false;\n       bool need_copy_ctor = false;\n       bool need_copy_assignment = false;\n@@ -5897,31 +6728,49 @@ finish_omp_clauses (tree clauses)\n \t  need_implicitly_determined = true;\n \t  break;\n \tcase OMP_CLAUSE_PRIVATE:\n-\t  need_complete_non_reference = true;\n+\t  need_complete_type = true;\n \t  need_default_ctor = true;\n \t  need_dtor = true;\n \t  need_implicitly_determined = true;\n \t  break;\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n-\t  need_complete_non_reference = true;\n+\t  need_complete_type = true;\n \t  need_copy_ctor = true;\n \t  need_dtor = true;\n \t  need_implicitly_determined = true;\n \t  break;\n \tcase OMP_CLAUSE_LASTPRIVATE:\n-\t  need_complete_non_reference = true;\n+\t  need_complete_type = true;\n \t  need_copy_assignment = true;\n \t  need_implicitly_determined = true;\n \t  break;\n \tcase OMP_CLAUSE_REDUCTION:\n \t  need_implicitly_determined = true;\n \t  break;\n+\tcase OMP_CLAUSE_LINEAR:\n+\t  if (!declare_simd)\n+\t    need_implicitly_determined = true;\n+\t  break;\n \tcase OMP_CLAUSE_COPYPRIVATE:\n \t  need_copy_assignment = true;\n \t  break;\n \tcase OMP_CLAUSE_COPYIN:\n \t  need_copy_assignment = true;\n \t  break;\n+\tcase OMP_CLAUSE_SIMDLEN:\n+\t  if (safelen\n+\t      && !processing_template_decl\n+\t      && tree_int_cst_lt (OMP_CLAUSE_SAFELEN_EXPR (safelen),\n+\t\t\t\t  OMP_CLAUSE_SIMDLEN_EXPR (c)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<simdlen%> clause value is bigger than \"\n+\t\t\t\"%<safelen%> clause value\");\n+\t      OMP_CLAUSE_SIMDLEN_EXPR (c)\n+\t\t= OMP_CLAUSE_SAFELEN_EXPR (safelen);\n+\t    }\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  continue;\n \tcase OMP_CLAUSE_NOWAIT:\n \t  if (copyprivate_seen)\n \t    {\n@@ -5975,18 +6824,14 @@ finish_omp_clauses (tree clauses)\n \t  break;\n \t}\n \n-      if (need_complete_non_reference || need_copy_assignment)\n+      if (need_complete_type || need_copy_assignment)\n \t{\n \t  t = require_complete_type (t);\n \t  if (t == error_mark_node)\n \t    remove = true;\n \t  else if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE\n-\t\t   && need_complete_non_reference)\n-\t    {\n-\t      error (\"%qE has reference type for %qs\", t,\n-\t\t     omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n-\t      remove = true;\n-\t    }\n+\t\t   && !complete_type_or_else (TREE_TYPE (TREE_TYPE (t)), t))\n+\t    remove = true;\n \t}\n       if (need_implicitly_determined)\n \t{\n@@ -6014,19 +6859,21 @@ finish_omp_clauses (tree clauses)\n \t  if (share_name)\n \t    {\n \t      error (\"%qE is predetermined %qs for %qs\",\n-\t\t     t, share_name, omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t     omp_clause_printable_decl (t), share_name,\n+\t\t     omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n \t}\n \n       /* We're interested in the base element, not arrays.  */\n       inner_type = type = TREE_TYPE (t);\n-      while (TREE_CODE (inner_type) == ARRAY_TYPE)\n-\tinner_type = TREE_TYPE (inner_type);\n-\n-      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+      if ((need_complete_type\n+\t   || need_copy_assignment\n+\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n \t  && TREE_CODE (inner_type) == REFERENCE_TYPE)\n \tinner_type = TREE_TYPE (inner_type);\n+      while (TREE_CODE (inner_type) == ARRAY_TYPE)\n+\tinner_type = TREE_TYPE (inner_type);\n \n       /* Check for special function availability by building a call to one.\n \t Save the results, because later we won't be in the right context\n@@ -6051,6 +6898,134 @@ finish_omp_clauses (tree clauses)\n   return clauses;\n }\n \n+/* Start processing OpenMP clauses that can include any\n+   privatization clauses for non-static data members.  */\n+\n+tree\n+push_omp_privatization_clauses (bool ignore_next)\n+{\n+  if (omp_private_member_ignore_next)\n+    {\n+      omp_private_member_ignore_next = ignore_next;\n+      return NULL_TREE;\n+    }\n+  omp_private_member_ignore_next = ignore_next;\n+  if (omp_private_member_map)\n+    omp_private_member_vec.safe_push (error_mark_node);\n+  return push_stmt_list ();\n+}\n+\n+/* Revert remapping of any non-static data members since\n+   the last push_omp_privatization_clauses () call.  */\n+\n+void\n+pop_omp_privatization_clauses (tree stmt)\n+{\n+  if (stmt == NULL_TREE)\n+    return;\n+  stmt = pop_stmt_list (stmt);\n+  if (omp_private_member_map)\n+    {\n+      while (!omp_private_member_vec.is_empty ())\n+\t{\n+\t  tree t = omp_private_member_vec.pop ();\n+\t  if (t == error_mark_node)\n+\t    {\n+\t      add_stmt (stmt);\n+\t      return;\n+\t    }\n+\t  bool no_decl_expr = t == integer_zero_node;\n+\t  if (no_decl_expr)\n+\t    t = omp_private_member_vec.pop ();\n+\t  tree *v = omp_private_member_map->get (t);\n+\t  gcc_assert (v);\n+\t  if (!no_decl_expr)\n+\t    add_decl_expr (*v);\n+\t  omp_private_member_map->remove (t);\n+\t}\n+      delete omp_private_member_map;\n+      omp_private_member_map = NULL;\n+    }\n+  add_stmt (stmt);\n+}\n+\n+/* Remember OpenMP privatization clauses mapping and clear it.\n+   Used for lambdas.  */\n+\n+void\n+save_omp_privatization_clauses (vec<tree> &save)\n+{\n+  save = vNULL;\n+  if (omp_private_member_ignore_next)\n+    save.safe_push (integer_one_node);\n+  omp_private_member_ignore_next = false;\n+  if (!omp_private_member_map)\n+    return;\n+\n+  while (!omp_private_member_vec.is_empty ())\n+    {\n+      tree t = omp_private_member_vec.pop ();\n+      if (t == error_mark_node)\n+\t{\n+\t  save.safe_push (t);\n+\t  continue;\n+\t}\n+      tree n = t;\n+      if (t == integer_zero_node)\n+\tt = omp_private_member_vec.pop ();\n+      tree *v = omp_private_member_map->get (t);\n+      gcc_assert (v);\n+      save.safe_push (*v);\n+      save.safe_push (t);\n+      if (n != t)\n+\tsave.safe_push (n);\n+    }\n+  delete omp_private_member_map;\n+  omp_private_member_map = NULL;\n+}\n+\n+/* Restore OpenMP privatization clauses mapping saved by the\n+   above function.  */\n+\n+void\n+restore_omp_privatization_clauses (vec<tree> &save)\n+{\n+  gcc_assert (omp_private_member_vec.is_empty ());\n+  omp_private_member_ignore_next = false;\n+  if (save.is_empty ())\n+    return;\n+  if (save.length () == 1 && save[0] == integer_one_node)\n+    {\n+      omp_private_member_ignore_next = true;\n+      save.release ();\n+      return;\n+    }\n+    \n+  omp_private_member_map = new hash_map <tree, tree>;\n+  while (!save.is_empty ())\n+    {\n+      tree t = save.pop ();\n+      tree n = t;\n+      if (t != error_mark_node)\n+\t{\n+\t  if (t == integer_one_node)\n+\t    {\n+\t      omp_private_member_ignore_next = true;\n+\t      gcc_assert (save.is_empty ());\n+\t      break;\n+\t    }\n+\t  if (t == integer_zero_node)\n+\t    t = save.pop ();\n+\t  tree &v = omp_private_member_map->get_or_insert (t);\n+\t  v = save.pop ();\n+\t}\n+      omp_private_member_vec.safe_push (t);\n+      if (n != t)\n+\tomp_private_member_vec.safe_push (n);\n+    }\n+  save.release ();\n+}\n+\n /* For all variables in the tree_list VARS, mark them as thread local.  */\n \n void\n@@ -6228,9 +7203,10 @@ finish_omp_task (tree clauses, tree body)\n    into integral iterator.  Return FALSE if successful.  */\n \n static bool\n-handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n-\t\t\t       tree condv, tree incrv, tree *body,\n-\t\t\t       tree *pre_body, tree clauses, tree *lastp)\n+handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n+\t\t\t       tree declv, tree initv, tree condv, tree incrv,\n+\t\t\t       tree *body, tree *pre_body, tree &clauses,\n+\t\t\t       tree *lastp, int collapse, int ordered)\n {\n   tree diff, iter_init, iter_incr = NULL, last;\n   tree incr_var = NULL, orig_pre_body, orig_body, c;\n@@ -6388,24 +7364,59 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n     }\n \n   incr = cp_convert (TREE_TYPE (diff), incr, tf_warning_or_error);\n+  bool taskloop_iv_seen = false;\n   for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n     if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n \t&& OMP_CLAUSE_DECL (c) == iter)\n-      break;\n+      {\n+\tif (code == OMP_TASKLOOP)\n+\t  {\n+\t    taskloop_iv_seen = true;\n+\t    OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV (c) = 1;\n+\t  }\n+\tbreak;\n+      }\n+    else if (code == OMP_TASKLOOP\n+\t     && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n+\t     && OMP_CLAUSE_DECL (c) == iter)\n+      {\n+\ttaskloop_iv_seen = true;\n+\tOMP_CLAUSE_PRIVATE_TASKLOOP_IV (c) = 1;\n+      }\n \n   decl = create_temporary_var (TREE_TYPE (diff));\n   pushdecl (decl);\n   add_decl_expr (decl);\n   last = create_temporary_var (TREE_TYPE (diff));\n   pushdecl (last);\n   add_decl_expr (last);\n-  if (c && iter_incr == NULL)\n+  if (c && iter_incr == NULL && TREE_CODE (incr) != INTEGER_CST\n+      && (!ordered || (i < collapse && collapse > 1)))\n     {\n       incr_var = create_temporary_var (TREE_TYPE (diff));\n       pushdecl (incr_var);\n       add_decl_expr (incr_var);\n     }\n   gcc_assert (stmts_are_full_exprs_p ());\n+  tree diffvar = NULL_TREE;\n+  if (code == OMP_TASKLOOP)\n+    {\n+      if (!taskloop_iv_seen)\n+\t{\n+\t  tree ivc = build_omp_clause (locus, OMP_CLAUSE_FIRSTPRIVATE);\n+\t  OMP_CLAUSE_DECL (ivc) = iter;\n+\t  cxx_omp_finish_clause (ivc, NULL);\n+\t  OMP_CLAUSE_CHAIN (ivc) = clauses;\n+\t  clauses = ivc;\n+\t}\n+      tree lvc = build_omp_clause (locus, OMP_CLAUSE_FIRSTPRIVATE);\n+      OMP_CLAUSE_DECL (lvc) = last;\n+      OMP_CLAUSE_CHAIN (lvc) = clauses;\n+      clauses = lvc;\n+      diffvar = create_temporary_var (TREE_TYPE (diff));\n+      pushdecl (diffvar);\n+      add_decl_expr (diffvar);\n+    }\n \n   orig_pre_body = *pre_body;\n   *pre_body = push_stmt_list ();\n@@ -6416,19 +7427,32 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n \t\t\t\t\t   iter, NOP_EXPR, init,\n \t\t\t\t\t   tf_warning_or_error));\n   init = build_int_cst (TREE_TYPE (diff), 0);\n-  if (c && iter_incr == NULL)\n+  if (c && iter_incr == NULL\n+      && (!ordered || (i < collapse && collapse > 1)))\n     {\n-      finish_expr_stmt (build_x_modify_expr (elocus,\n-\t\t\t\t\t     incr_var, NOP_EXPR,\n-\t\t\t\t\t     incr, tf_warning_or_error));\n-      incr = incr_var;\n+      if (incr_var)\n+\t{\n+\t  finish_expr_stmt (build_x_modify_expr (elocus,\n+\t\t\t\t\t\t incr_var, NOP_EXPR,\n+\t\t\t\t\t\t incr, tf_warning_or_error));\n+\t  incr = incr_var;\n+\t}\n       iter_incr = build_x_modify_expr (elocus,\n \t\t\t\t       iter, PLUS_EXPR, incr,\n \t\t\t\t       tf_warning_or_error);\n     }\n+  if (c && ordered && i < collapse && collapse > 1)\n+    iter_incr = incr;\n   finish_expr_stmt (build_x_modify_expr (elocus,\n \t\t\t\t\t last, NOP_EXPR, init,\n \t\t\t\t\t tf_warning_or_error));\n+  if (diffvar)\n+    {\n+      finish_expr_stmt (build_x_modify_expr (elocus,\n+\t\t\t\t\t     diffvar, NOP_EXPR,\n+\t\t\t\t\t     diff, tf_warning_or_error));\n+      diff = diffvar;\n+    }\n   *pre_body = pop_stmt_list (*pre_body);\n \n   cond = cp_build_binary_op (elocus,\n@@ -6455,7 +7479,22 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n   if (c)\n     {\n       OMP_CLAUSE_LASTPRIVATE_STMT (c) = push_stmt_list ();\n-      finish_expr_stmt (iter_incr);\n+      if (!ordered)\n+\tfinish_expr_stmt (iter_incr);\n+      else\n+\t{\n+\t  iter_init = decl;\n+\t  if (i < collapse && collapse > 1 && !error_operand_p (iter_incr))\n+\t    iter_init = build2 (PLUS_EXPR, TREE_TYPE (diff),\n+\t\t\t\titer_init, iter_incr);\n+\t  iter_init = build2 (MINUS_EXPR, TREE_TYPE (diff), iter_init, last);\n+\t  iter_init = build_x_modify_expr (elocus,\n+\t\t\t\t\t   iter, PLUS_EXPR, iter_init,\n+\t\t\t\t\t   tf_warning_or_error);\n+\t  if (iter_init != error_mark_node)\n+\t    iter_init = build1 (NOP_EXPR, void_type_node, iter_init);\n+\t  finish_expr_stmt (iter_init);\n+\t}\n       OMP_CLAUSE_LASTPRIVATE_STMT (c)\n \t= pop_stmt_list (OMP_CLAUSE_LASTPRIVATE_STMT (c));\n     }\n@@ -6477,18 +7516,29 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n    sk_omp scope.  */\n \n tree\n-finish_omp_for (location_t locus, enum tree_code code, tree declv, tree initv,\n-\t\ttree condv, tree incrv, tree body, tree pre_body, tree clauses)\n+finish_omp_for (location_t locus, enum tree_code code, tree declv,\n+\t\ttree orig_declv, tree initv, tree condv, tree incrv,\n+\t\ttree body, tree pre_body, tree clauses)\n {\n   tree omp_for = NULL, orig_incr = NULL;\n   tree decl = NULL, init, cond, incr, orig_decl = NULL_TREE, block = NULL_TREE;\n   tree last = NULL_TREE;\n   location_t elocus;\n   int i;\n+  int collapse = 1;\n+  int ordered = 0;\n \n   gcc_assert (TREE_VEC_LENGTH (declv) == TREE_VEC_LENGTH (initv));\n   gcc_assert (TREE_VEC_LENGTH (declv) == TREE_VEC_LENGTH (condv));\n   gcc_assert (TREE_VEC_LENGTH (declv) == TREE_VEC_LENGTH (incrv));\n+  if (TREE_VEC_LENGTH (declv) > 1)\n+    {\n+      tree c = find_omp_clause (clauses, OMP_CLAUSE_COLLAPSE);\n+      if (c)\n+\tcollapse = tree_to_shwi (OMP_CLAUSE_COLLAPSE_EXPR (c));\n+      if (collapse != TREE_VEC_LENGTH (declv))\n+\tordered = TREE_VEC_LENGTH (declv);\n+    }\n   for (i = 0; i < TREE_VEC_LENGTH (declv); i++)\n     {\n       decl = TREE_VEC_ELT (declv, i);\n@@ -6572,6 +7622,9 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv, tree initv,\n       return add_stmt (stmt);\n     }\n \n+  if (!orig_declv)\n+    orig_declv = copy_node (declv);\n+\n   if (processing_template_decl)\n     orig_incr = make_tree_vec (TREE_VEC_LENGTH (incrv));\n \n@@ -6614,9 +7667,10 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv, tree initv,\n \t    }\n \t  if (code == CILK_FOR && i == 0)\n \t    orig_decl = decl;\n-\t  if (handle_omp_for_class_iterator (i, locus, declv, initv, condv,\n-\t\t\t\t\t     incrv, &body, &pre_body,\n-\t\t\t\t\t     clauses, &last))\n+\t  if (handle_omp_for_class_iterator (i, locus, code, declv, initv,\n+\t\t\t\t\t     condv, incrv, &body, &pre_body,\n+\t\t\t\t\t     clauses, &last, collapse,\n+\t\t\t\t\t     ordered))\n \t    return NULL;\n \t  continue;\n \t}\n@@ -6672,8 +7726,8 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv, tree initv,\n   if (code == CILK_FOR && !processing_template_decl)\n     block = push_stmt_list ();\n \n-  omp_for = c_finish_omp_for (locus, code, declv, initv, condv, incrv,\n-\t\t\t      body, pre_body);\n+  omp_for = c_finish_omp_for (locus, code, declv, orig_declv, initv, condv,\n+\t\t\t      incrv, body, pre_body);\n \n   if (omp_for == NULL)\n     {\n@@ -6716,6 +7770,68 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv, tree initv,\n     }\n   OMP_FOR_CLAUSES (omp_for) = clauses;\n \n+  /* For simd loops with non-static data member iterators, we could have added\n+     OMP_CLAUSE_LINEAR clauses without OMP_CLAUSE_LINEAR_STEP.  As we know the\n+     step at this point, fill it in.  */\n+  if (code == OMP_SIMD && !processing_template_decl\n+      && TREE_VEC_LENGTH (OMP_FOR_INCR (omp_for)) == 1)\n+    for (tree c = find_omp_clause (clauses, OMP_CLAUSE_LINEAR); c;\n+\t c = find_omp_clause (OMP_CLAUSE_CHAIN (c), OMP_CLAUSE_LINEAR))\n+      if (OMP_CLAUSE_LINEAR_STEP (c) == NULL_TREE)\n+\t{\n+\t  decl = TREE_OPERAND (TREE_VEC_ELT (OMP_FOR_INIT (omp_for), 0), 0);\n+\t  gcc_assert (decl == OMP_CLAUSE_DECL (c));\n+\t  incr = TREE_VEC_ELT (OMP_FOR_INCR (omp_for), 0);\n+\t  tree step, stept;\n+\t  switch (TREE_CODE (incr))\n+\t    {\n+\t    case PREINCREMENT_EXPR:\n+\t    case POSTINCREMENT_EXPR:\n+\t      /* c_omp_for_incr_canonicalize_ptr() should have been\n+\t\t called to massage things appropriately.  */\n+\t      gcc_assert (!POINTER_TYPE_P (TREE_TYPE (decl)));\n+\t      OMP_CLAUSE_LINEAR_STEP (c) = build_int_cst (TREE_TYPE (decl), 1);\n+\t      break;\n+\t    case PREDECREMENT_EXPR:\n+\t    case POSTDECREMENT_EXPR:\n+\t      /* c_omp_for_incr_canonicalize_ptr() should have been\n+\t\t called to massage things appropriately.  */\n+\t      gcc_assert (!POINTER_TYPE_P (TREE_TYPE (decl)));\n+\t      OMP_CLAUSE_LINEAR_STEP (c)\n+\t\t= build_int_cst (TREE_TYPE (decl), -1);\n+\t      break;\n+\t    case MODIFY_EXPR:\n+\t      gcc_assert (TREE_OPERAND (incr, 0) == decl);\n+\t      incr = TREE_OPERAND (incr, 1);\n+\t      switch (TREE_CODE (incr))\n+\t\t{\n+\t\tcase PLUS_EXPR:\n+\t\t  if (TREE_OPERAND (incr, 1) == decl)\n+\t\t    step = TREE_OPERAND (incr, 0);\n+\t\t  else\n+\t\t    step = TREE_OPERAND (incr, 1);\n+\t\t  break;\n+\t\tcase MINUS_EXPR:\n+\t\tcase POINTER_PLUS_EXPR:\n+\t\t  gcc_assert (TREE_OPERAND (incr, 0) == decl);\n+\t\t  step = TREE_OPERAND (incr, 1);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      stept = TREE_TYPE (decl);\n+\t      if (POINTER_TYPE_P (stept))\n+\t\tstept = sizetype;\n+\t      step = fold_convert (stept, step);\n+\t      if (TREE_CODE (incr) == MINUS_EXPR)\n+\t\tstep = fold_build1 (NEGATE_EXPR, stept, step);\n+\t      OMP_CLAUSE_LINEAR_STEP (c) = step;\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+\n   if (block)\n     {\n       tree omp_par = make_node (OMP_PARALLEL);\n@@ -6802,7 +7918,7 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv, tree initv,\n       OMP_CLAUSE_OPERAND (c, 0)\n \t= cilk_for_number_of_iterations (omp_for);\n       OMP_CLAUSE_CHAIN (c) = clauses;\n-      OMP_PARALLEL_CLAUSES (omp_par) = finish_omp_clauses (c);\n+      OMP_PARALLEL_CLAUSES (omp_par) = finish_omp_clauses (c, false);\n       add_stmt (omp_par);\n       return omp_par;\n     }"}, {"sha": "4bd35774cf9e4b9dc1a7bdb4896ec6294b7896a1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1,3 +1,27 @@\n+2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* f95-lang.c (DEF_FUNCTION_TYPE_9, DEF_FUNCTION_TYPE_10,\n+\tDEF_FUNCTION_TYPE_11, DEF_FUNCTION_TYPE_VAR_1): Define.\n+\t* trans-openmp.c (gfc_trans_omp_clauses): Set\n+\tOMP_CLAUSE_IF_MODIFIER to ERROR_MARK, OMP_CLAUSE_ORDERED_EXPR\n+\tto NULL.\n+\t(gfc_trans_omp_critical): Adjust for addition of clauses.\n+\t(gfc_trans_omp_ordered): Likewise.\n+\t* types.def (BT_FN_BOOL_UINT_LONGPTR_LONGPTR_LONGPTR,\n+\tBT_FN_BOOL_UINT_ULLPTR_ULLPTR_ULLPTR,\n+\tBT_FN_BOOL_UINT_LONGPTR_LONG_LONGPTR_LONGPTR,\n+\tBT_FN_BOOL_UINT_ULLPTR_ULL_ULLPTR_ULLPTR,\n+\tBT_FN_VOID_INT_SIZE_PTR_PTR_PTR_UINT_PTR,\n+\tBT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR,\n+\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,\n+\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_LONG_LONG_LONG,\n+\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_ULL_ULL_ULL,\n+\tBT_FN_VOID_LONG_VAR, BT_FN_VOID_ULL_VAR): New.\n+\t(BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR,\n+\tBT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR,\n+\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR): Remove.\n+\n 2015-10-07  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \tPR fortran/65889"}, {"sha": "67b0bac6e616f2601e090b7c3e404b886526f0f7", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -633,7 +633,14 @@ gfc_init_builtin_functions (void)\n \t\t\t    ARG6, ARG7) NAME,\n #define DEF_FUNCTION_TYPE_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n \t\t\t    ARG6, ARG7, ARG8) NAME,\n+#define DEF_FUNCTION_TYPE_9(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8, ARG9) NAME,\n+#define DEF_FUNCTION_TYPE_10(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10) NAME,\n+#define DEF_FUNCTION_TYPE_11(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) NAME,\n #define DEF_FUNCTION_TYPE_VAR_0(NAME, RETURN) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_1(NAME, RETURN, ARG1) NAME,\n #define DEF_FUNCTION_TYPE_VAR_2(NAME, RETURN, ARG1, ARG2) NAME,\n #define DEF_FUNCTION_TYPE_VAR_6(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n \t\t\t\t ARG6) NAME,\n@@ -651,7 +658,11 @@ gfc_init_builtin_functions (void)\n #undef DEF_FUNCTION_TYPE_6\n #undef DEF_FUNCTION_TYPE_7\n #undef DEF_FUNCTION_TYPE_8\n+#undef DEF_FUNCTION_TYPE_9\n+#undef DEF_FUNCTION_TYPE_10\n+#undef DEF_FUNCTION_TYPE_11\n #undef DEF_FUNCTION_TYPE_VAR_0\n+#undef DEF_FUNCTION_TYPE_VAR_1\n #undef DEF_FUNCTION_TYPE_VAR_2\n #undef DEF_FUNCTION_TYPE_VAR_6\n #undef DEF_FUNCTION_TYPE_VAR_7\n@@ -1086,10 +1097,60 @@ gfc_init_builtin_functions (void)\n \t\t\t\tbuiltin_types[(int) ARG7],\t\t\\\n \t\t\t\tbuiltin_types[(int) ARG8],\t\t\\\n \t\t\t\tNULL_TREE);\n+#define DEF_FUNCTION_TYPE_9(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8, ARG9)\t\t\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_function_type_list (builtin_types[(int) RETURN],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG1],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG2],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG3],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG4],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG5],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG6],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG7],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG8],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG9],\t\t\\\n+\t\t\t\tNULL_TREE);\n+#define DEF_FUNCTION_TYPE_10(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4,\t\\\n+\t\t\t     ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_function_type_list (builtin_types[(int) RETURN],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG1],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG2],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG3],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG4],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG5],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG6],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG7],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG8],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG9],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG10],\t\t\\\n+\t\t\t\tNULL_TREE);\n+#define DEF_FUNCTION_TYPE_11(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4,\t\\\n+\t\t\t     ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)\\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_function_type_list (builtin_types[(int) RETURN],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG1],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG2],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG3],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG4],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG5],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG6],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG7],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG8],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG9],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG10],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG11],\t\t\\\n+\t\t\t\tNULL_TREE);\n #define DEF_FUNCTION_TYPE_VAR_0(ENUM, RETURN)\t\t\t\t\\\n   builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n     = build_varargs_function_type_list (builtin_types[(int) RETURN],    \\\n                                         NULL_TREE);\n+#define DEF_FUNCTION_TYPE_VAR_1(ENUM, RETURN, ARG1)\t\t\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_varargs_function_type_list (builtin_types[(int) RETURN],    \\\n+\t\t\t\t\tbuiltin_types[(int) ARG1],     \t\\\n+\t\t\t\t\tNULL_TREE);\n #define DEF_FUNCTION_TYPE_VAR_2(ENUM, RETURN, ARG1, ARG2)\t\t\\\n   builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n     = build_varargs_function_type_list (builtin_types[(int) RETURN],   \t\\\n@@ -1133,7 +1194,9 @@ gfc_init_builtin_functions (void)\n #undef DEF_FUNCTION_TYPE_6\n #undef DEF_FUNCTION_TYPE_7\n #undef DEF_FUNCTION_TYPE_8\n+#undef DEF_FUNCTION_TYPE_10\n #undef DEF_FUNCTION_TYPE_VAR_0\n+#undef DEF_FUNCTION_TYPE_VAR_1\n #undef DEF_FUNCTION_TYPE_VAR_2\n #undef DEF_FUNCTION_TYPE_VAR_6\n #undef DEF_FUNCTION_TYPE_VAR_7"}, {"sha": "b6284c9c957d49013c118c200b5e94380d58e222", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -2245,6 +2245,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n       gfc_add_block_to_block (block, &se.post);\n \n       c = build_omp_clause (where.lb->location, OMP_CLAUSE_IF);\n+      OMP_CLAUSE_IF_MODIFIER (c) = ERROR_MARK;\n       OMP_CLAUSE_IF_EXPR (c) = if_var;\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n@@ -2348,6 +2349,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n   if (clauses->ordered)\n     {\n       c = build_omp_clause (where.lb->location, OMP_CLAUSE_ORDERED);\n+      OMP_CLAUSE_ORDERED_EXPR (c) = NULL_TREE;\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n@@ -2523,6 +2525,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n   if (clauses->seq)\n     {\n       c = build_omp_clause (where.lb->location, OMP_CLAUSE_ORDERED);\n+      OMP_CLAUSE_ORDERED_EXPR (c) = NULL_TREE;\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n   if (clauses->independent)\n@@ -3095,7 +3098,8 @@ gfc_trans_omp_critical (gfc_code *code)\n   if (code->ext.omp_name != NULL)\n     name = get_identifier (code->ext.omp_name);\n   stmt = gfc_trans_code (code->block->next);\n-  return build2_loc (input_location, OMP_CRITICAL, void_type_node, stmt, name);\n+  return build3_loc (input_location, OMP_CRITICAL, void_type_node, stmt,\n+\t\t     NULL_TREE, name);\n }\n \n typedef struct dovar_init_d {\n@@ -3486,7 +3490,8 @@ gfc_trans_omp_master (gfc_code *code)\n static tree\n gfc_trans_omp_ordered (gfc_code *code)\n {\n-  return build1_v (OMP_ORDERED, gfc_trans_code (code->block->next));\n+  return build2_loc (input_location, OMP_ORDERED, void_type_node,\n+\t\t     gfc_trans_code (code->block->next), NULL_TREE);\n }\n \n static tree"}, {"sha": "ca7565482aa50d818506529cef1448c83a101512", "filename": "gcc/fortran/types.def", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ffortran%2Ftypes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ffortran%2Ftypes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftypes.def?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -154,6 +154,11 @@ DEF_FUNCTION_TYPE_4 (BT_FN_VOID_SIZE_VPTR_PTR_INT, BT_VOID, BT_SIZE,\n \t\t     BT_VOLATILE_PTR, BT_PTR, BT_INT)\n DEF_FUNCTION_TYPE_4 (BT_FN_VOID_SIZE_CONST_VPTR_PTR_INT, BT_VOID, BT_SIZE,\n \t\t     BT_CONST_VOLATILE_PTR, BT_PTR, BT_INT)\n+DEF_FUNCTION_TYPE_4 (BT_FN_BOOL_UINT_LONGPTR_LONGPTR_LONGPTR,\n+\t\t     BT_BOOL, BT_UINT, BT_PTR_LONG, BT_PTR_LONG, BT_PTR_LONG)\n+DEF_FUNCTION_TYPE_4 (BT_FN_BOOL_UINT_ULLPTR_ULLPTR_ULLPTR,\n+\t\t     BT_BOOL, BT_UINT, BT_PTR_ULONGLONG, BT_PTR_ULONGLONG,\n+\t\t     BT_PTR_ULONGLONG)\n \n DEF_FUNCTION_TYPE_5 (BT_FN_VOID_OMPFN_PTR_UINT_UINT_UINT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT, BT_UINT,\n@@ -165,6 +170,12 @@ DEF_FUNCTION_TYPE_5 (BT_FN_VOID_SIZE_VPTR_PTR_PTR_INT, BT_VOID, BT_SIZE,\n \t\t     BT_VOLATILE_PTR, BT_PTR, BT_PTR, BT_INT)\n DEF_FUNCTION_TYPE_5 (BT_FN_VOID_INT_SIZE_PTR_PTR_PTR,\n \t\t     BT_VOID, BT_INT, BT_SIZE, BT_PTR, BT_PTR, BT_PTR)\n+DEF_FUNCTION_TYPE_5 (BT_FN_BOOL_UINT_LONGPTR_LONG_LONGPTR_LONGPTR,\n+\t\t     BT_BOOL, BT_UINT, BT_PTR_LONG, BT_LONG, BT_PTR_LONG,\n+\t\t     BT_PTR_LONG)\n+DEF_FUNCTION_TYPE_5 (BT_FN_BOOL_UINT_ULLPTR_ULL_ULLPTR_ULLPTR,\n+\t\t     BT_BOOL, BT_UINT, BT_PTR_ULONGLONG, BT_ULONGLONG,\n+\t\t     BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n \n DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n                      BT_BOOL, BT_LONG, BT_LONG, BT_LONG, BT_LONG,\n@@ -189,8 +200,6 @@ DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_VPTR_PTR_I16_BOOL_INT_INT,\n \t\t     BT_INT)\n DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_SIZE_VPTR_PTR_PTR_INT_INT, BT_BOOL, BT_SIZE,\n \t\t     BT_VOLATILE_PTR, BT_PTR, BT_PTR, BT_INT, BT_INT)\n-DEF_FUNCTION_TYPE_6 (BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR,\n-\t\t     BT_VOID, BT_INT, BT_PTR, BT_SIZE, BT_PTR, BT_PTR, BT_PTR)\n \n DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_UINT,\n                      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n@@ -199,20 +208,39 @@ DEF_FUNCTION_TYPE_7 (BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n \t\t     BT_BOOL, BT_BOOL, BT_ULONGLONG, BT_ULONGLONG,\n \t\t     BT_ULONGLONG, BT_ULONGLONG,\n \t\t     BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n-DEF_FUNCTION_TYPE_7 (BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR,\n-\t\t     BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_PTR, BT_SIZE,\n-\t\t     BT_PTR, BT_PTR, BT_PTR)\n+DEF_FUNCTION_TYPE_7 (BT_FN_VOID_INT_SIZE_PTR_PTR_PTR_UINT_PTR,\n+\t\t     BT_VOID, BT_INT, BT_SIZE, BT_PTR, BT_PTR, BT_PTR, BT_UINT,\n+\t\t     BT_PTR)\n \n DEF_FUNCTION_TYPE_8 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n \t\t     BT_LONG, BT_LONG, BT_LONG, BT_LONG, BT_UINT)\n-DEF_FUNCTION_TYPE_8 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR,\n+DEF_FUNCTION_TYPE_8 (BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR,\n+\t\t     BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_SIZE, BT_PTR,\n+\t\t     BT_PTR, BT_PTR, BT_UINT, BT_PTR)\n+\n+DEF_FUNCTION_TYPE_9 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n \t\t     BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n-\t\t     BT_BOOL, BT_UINT, BT_PTR)\n+\t\t     BT_BOOL, BT_UINT, BT_PTR, BT_INT)\n+\n+DEF_FUNCTION_TYPE_11 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_LONG_LONG_LONG,\n+\t\t      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n+\t\t      BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n+\t\t      BT_UINT, BT_LONG, BT_INT, BT_LONG, BT_LONG, BT_LONG)\n+DEF_FUNCTION_TYPE_11 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_ULL_ULL_ULL,\n+\t\t      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n+\t\t      BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n+\t\t      BT_UINT, BT_LONG, BT_INT,\n+\t\t      BT_ULONGLONG, BT_ULONGLONG, BT_ULONGLONG)\n \n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_VOID_VAR, BT_VOID)\n \n+DEF_FUNCTION_TYPE_VAR_1 (BT_FN_VOID_LONG_VAR,\n+\t\t\t BT_VOID, BT_LONG)\n+DEF_FUNCTION_TYPE_VAR_1 (BT_FN_VOID_ULL_VAR,\n+\t\t\t BT_VOID, BT_ULONGLONG)\n+\n DEF_FUNCTION_TYPE_VAR_2 (BT_FN_VOID_INT_INT_VAR, BT_VOID, BT_INT, BT_INT)\n \n DEF_FUNCTION_TYPE_VAR_7 (BT_FN_VOID_INT_SIZE_PTR_PTR_PTR_INT_INT_VAR,"}, {"sha": "9780220c47d47f0226cc8ded2b4e2566093a7178", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1134,6 +1134,9 @@ dump_gimple_omp_for (pretty_printer *buffer, gomp_for *gs, int spc, int flags)\n \tcase GF_OMP_FOR_KIND_DISTRIBUTE:\n \t  kind = \" distribute\";\n \t  break;\n+\tcase GF_OMP_FOR_KIND_TASKLOOP:\n+\t  kind = \" taskloop\";\n+\t  break;\n \tcase GF_OMP_FOR_KIND_CILKFOR:\n \t  kind = \" _Cilk_for\";\n \t  break;\n@@ -1174,6 +1177,9 @@ dump_gimple_omp_for (pretty_printer *buffer, gomp_for *gs, int spc, int flags)\n \tcase GF_OMP_FOR_KIND_DISTRIBUTE:\n \t  pp_string (buffer, \"#pragma omp distribute\");\n \t  break;\n+\tcase GF_OMP_FOR_KIND_TASKLOOP:\n+\t  pp_string (buffer, \"#pragma omp taskloop\");\n+\t  break;\n \tcase GF_OMP_FOR_KIND_CILKFOR:\n \t  break;\n \tcase GF_OMP_FOR_KIND_OACC_LOOP:\n@@ -1330,6 +1336,12 @@ dump_gimple_omp_target (pretty_printer *buffer, gomp_target *gs,\n     case GF_OMP_TARGET_KIND_UPDATE:\n       kind = \" update\";\n       break;\n+    case GF_OMP_TARGET_KIND_ENTER_DATA:\n+      kind = \" enter data\";\n+      break;\n+    case GF_OMP_TARGET_KIND_EXIT_DATA:\n+      kind = \" exit data\";\n+      break;\n     case GF_OMP_TARGET_KIND_OACC_KERNELS:\n       kind = \" oacc_kernels\";\n       break;\n@@ -1477,9 +1489,6 @@ dump_gimple_omp_block (pretty_printer *buffer, gimple *gs, int spc, int flags)\n \tcase GIMPLE_OMP_TASKGROUP:\n \t  pp_string (buffer, \"#pragma omp taskgroup\");\n \t  break;\n-\tcase GIMPLE_OMP_ORDERED:\n-\t  pp_string (buffer, \"#pragma omp ordered\");\n-\t  break;\n \tcase GIMPLE_OMP_SECTION:\n \t  pp_string (buffer, \"#pragma omp section\");\n \t  break;\n@@ -1517,6 +1526,32 @@ dump_gimple_omp_critical (pretty_printer *buffer, gomp_critical *gs,\n \t\t\t     flags, false);\n \t  pp_right_paren (buffer);\n \t}\n+      dump_omp_clauses (buffer, gimple_omp_critical_clauses (gs), spc, flags);\n+      if (!gimple_seq_empty_p (gimple_omp_body (gs)))\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_left_brace (buffer);\n+\t  pp_newline (buffer);\n+\t  dump_gimple_seq (buffer, gimple_omp_body (gs), spc + 4, flags);\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_right_brace (buffer);\n+\t}\n+    }\n+}\n+\n+/* Dump a GIMPLE_OMP_ORDERED tuple on the pretty_printer BUFFER.  */\n+\n+static void\n+dump_gimple_omp_ordered (pretty_printer *buffer, gomp_ordered *gs,\n+\t\t\t int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <%+BODY <%S> >\", gs,\n+\t\t     gimple_omp_body (gs));\n+  else\n+    {\n+      pp_string (buffer, \"#pragma omp ordered\");\n+      dump_omp_clauses (buffer, gimple_omp_ordered_clauses (gs), spc, flags);\n       if (!gimple_seq_empty_p (gimple_omp_body (gs)))\n \t{\n \t  newline_and_indent (buffer, spc + 2);\n@@ -1969,7 +2004,10 @@ dump_gimple_omp_task (pretty_printer *buffer, gomp_task *gs, int spc,\n   else\n     {\n       gimple_seq body;\n-      pp_string (buffer, \"#pragma omp task\");\n+      if (gimple_omp_task_taskloop_p (gs))\n+\tpp_string (buffer, \"#pragma omp taskloop\");\n+      else\n+\tpp_string (buffer, \"#pragma omp task\");\n       dump_omp_clauses (buffer, gimple_omp_task_clauses (gs), spc, flags);\n       if (gimple_omp_task_child_fn (gs))\n \t{\n@@ -2235,11 +2273,15 @@ pp_gimple_stmt_1 (pretty_printer *buffer, gimple *gs, int spc, int flags)\n \n     case GIMPLE_OMP_MASTER:\n     case GIMPLE_OMP_TASKGROUP:\n-    case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_SECTION:\n       dump_gimple_omp_block (buffer, gs, spc, flags);\n       break;\n \n+    case GIMPLE_OMP_ORDERED:\n+      dump_gimple_omp_ordered (buffer, as_a <gomp_ordered *> (gs), spc,\n+\t\t\t       flags);\n+      break;\n+\n     case GIMPLE_OMP_CRITICAL:\n       dump_gimple_omp_critical (buffer, as_a <gomp_critical *> (gs), spc,\n \t\t\t\tflags);"}, {"sha": "b045c67d3575f33595672fd416e7765f77c4cf31", "filename": "gcc/gimple-walk.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fgimple-walk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fgimple-walk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-walk.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -320,6 +320,20 @@ walk_gimple_op (gimple *stmt, walk_tree_fn callback_op,\n \t\t\t callback_op, wi, pset);\n \tif (ret)\n \t  return ret;\n+\tret = walk_tree (gimple_omp_critical_clauses_ptr (omp_stmt),\n+\t\t\t callback_op, wi, pset);\n+\tif (ret)\n+\t  return ret;\n+      }\n+      break;\n+\n+    case GIMPLE_OMP_ORDERED:\n+      {\n+\tgomp_ordered *omp_stmt = as_a <gomp_ordered *> (stmt);\n+\tret = walk_tree (gimple_omp_ordered_clauses_ptr (omp_stmt),\n+\t\t\t callback_op, wi, pset);\n+\tif (ret)\n+\t  return ret;\n       }\n       break;\n "}, {"sha": "5312d6e055dff8f0e3444cb20b6f0272896669f9", "filename": "gcc/gimple.c", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -838,14 +838,16 @@ gimple_build_debug_source_bind_stat (tree var, tree value,\n /* Build a GIMPLE_OMP_CRITICAL statement.\n \n    BODY is the sequence of statements for which only one thread can execute.\n-   NAME is optional identifier for this critical block.  */\n+   NAME is optional identifier for this critical block.\n+   CLAUSES are clauses for this critical block.  */\n \n gomp_critical *\n-gimple_build_omp_critical (gimple_seq body, tree name)\n+gimple_build_omp_critical (gimple_seq body, tree name, tree clauses)\n {\n   gomp_critical *p\n     = as_a <gomp_critical *> (gimple_alloc (GIMPLE_OMP_CRITICAL, 0));\n   gimple_omp_critical_set_name (p, name);\n+  gimple_omp_critical_set_clauses (p, clauses);\n   if (body)\n     gimple_omp_set_body (p, body);\n \n@@ -994,12 +996,15 @@ gimple_build_omp_continue (tree control_def, tree control_use)\n /* Build a GIMPLE_OMP_ORDERED statement.\n \n    BODY is the sequence of statements inside a loop that will executed in\n-   sequence.  */\n+   sequence.\n+   CLAUSES are clauses for this statement.  */\n \n-gimple *\n-gimple_build_omp_ordered (gimple_seq body)\n+gomp_ordered *\n+gimple_build_omp_ordered (gimple_seq body, tree clauses)\n {\n-  gimple *p = gimple_alloc (GIMPLE_OMP_ORDERED, 0);\n+  gomp_ordered *p\n+    = as_a <gomp_ordered *> (gimple_alloc (GIMPLE_OMP_ORDERED, 0));\n+  gimple_omp_ordered_set_clauses (p, clauses);\n   if (body)\n     gimple_omp_set_body (p, body);\n \n@@ -1779,9 +1784,18 @@ gimple_copy (gimple *stmt)\n \t  goto copy_omp_body;\n \n \tcase GIMPLE_OMP_CRITICAL:\n-\t  t = unshare_expr (gimple_omp_critical_name (\n-\t\t\t      as_a <gomp_critical *> (stmt)));\n+\t  t = unshare_expr (gimple_omp_critical_name\n+\t\t\t\t(as_a <gomp_critical *> (stmt)));\n \t  gimple_omp_critical_set_name (as_a <gomp_critical *> (copy), t);\n+\t  t = unshare_expr (gimple_omp_critical_clauses\n+\t\t\t\t(as_a <gomp_critical *> (stmt)));\n+\t  gimple_omp_critical_set_clauses (as_a <gomp_critical *> (copy), t);\n+\t  goto copy_omp_body;\n+\n+\tcase GIMPLE_OMP_ORDERED:\n+\t  t = unshare_expr (gimple_omp_ordered_clauses\n+\t\t\t\t(as_a <gomp_ordered *> (stmt)));\n+\t  gimple_omp_ordered_set_clauses (as_a <gomp_ordered *> (copy), t);\n \t  goto copy_omp_body;\n \n \tcase GIMPLE_OMP_SECTIONS:\n@@ -1797,7 +1811,6 @@ gimple_copy (gimple *stmt)\n \tcase GIMPLE_OMP_SECTION:\n \tcase GIMPLE_OMP_MASTER:\n \tcase GIMPLE_OMP_TASKGROUP:\n-\tcase GIMPLE_OMP_ORDERED:\n \tcopy_omp_body:\n \t  new_seq = gimple_seq_copy (gimple_omp_body (stmt));\n \t  gimple_omp_set_body (copy, new_seq);"}, {"sha": "d3ca402aea79b5391f7fe2b4e94d719769797e5c", "filename": "gcc/gimple.def", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fgimple.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fgimple.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.def?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -283,10 +283,6 @@ DEFGSCODE(GIMPLE_OMP_MASTER, \"gimple_omp_master\", GSS_OMP)\n    BODY is the sequence of statements to execute in the taskgroup section.  */\n DEFGSCODE(GIMPLE_OMP_TASKGROUP, \"gimple_omp_taskgroup\", GSS_OMP)\n \n-/* GIMPLE_OMP_ORDERED <BODY> represents #pragma omp ordered.\n-   BODY is the sequence of statements to execute in the ordered section.  */\n-DEFGSCODE(GIMPLE_OMP_ORDERED, \"gimple_omp_ordered\", GSS_OMP)\n-\n /* GIMPLE_OMP_PARALLEL <BODY, CLAUSES, CHILD_FN, DATA_ARG> represents\n \n    #pragma omp parallel [CLAUSES]\n@@ -375,6 +371,11 @@ DEFGSCODE(GIMPLE_OMP_TARGET, \"gimple_omp_target\", GSS_OMP_PARALLEL_LAYOUT)\n    CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  */\n DEFGSCODE(GIMPLE_OMP_TEAMS, \"gimple_omp_teams\", GSS_OMP_SINGLE_LAYOUT)\n \n+/* GIMPLE_OMP_ORDERED <BODY, CLAUSES> represents #pragma omp ordered.\n+   BODY is the sequence of statements to execute in the ordered section.\n+   CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  */\n+DEFGSCODE(GIMPLE_OMP_ORDERED, \"gimple_omp_ordered\", GSS_OMP_SINGLE_LAYOUT)\n+\n /* GIMPLE_PREDICT <PREDICT, OUTCOME> specifies a hint for branch prediction.\n \n    PREDICT is one of the predictors from predict.def."}, {"sha": "02d0db59752d7d75ab244db2e4db0905d7c22ee3", "filename": "gcc/gimple.h", "status": "modified", "additions": 133, "deletions": 18, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -146,26 +146,30 @@ enum gf_mask {\n     GF_CALL_CTRL_ALTERING       = 1 << 7,\n     GF_CALL_WITH_BOUNDS \t= 1 << 8,\n     GF_OMP_PARALLEL_COMBINED\t= 1 << 0,\n-    GF_OMP_FOR_KIND_MASK\t= (1 << 3) - 1,\n+    GF_OMP_TASK_TASKLOOP\t= 1 << 0,\n+    GF_OMP_FOR_KIND_MASK\t= (1 << 4) - 1,\n     GF_OMP_FOR_KIND_FOR\t\t= 0,\n     GF_OMP_FOR_KIND_DISTRIBUTE\t= 1,\n-    GF_OMP_FOR_KIND_CILKFOR     = 2,\n-    GF_OMP_FOR_KIND_OACC_LOOP\t= 3,\n+    GF_OMP_FOR_KIND_TASKLOOP\t= 2,\n+    GF_OMP_FOR_KIND_CILKFOR     = 3,\n+    GF_OMP_FOR_KIND_OACC_LOOP\t= 4,\n     /* Flag for SIMD variants of OMP_FOR kinds.  */\n-    GF_OMP_FOR_SIMD\t\t= 1 << 2,\n+    GF_OMP_FOR_SIMD\t\t= 1 << 3,\n     GF_OMP_FOR_KIND_SIMD\t= GF_OMP_FOR_SIMD | 0,\n     GF_OMP_FOR_KIND_CILKSIMD\t= GF_OMP_FOR_SIMD | 1,\n-    GF_OMP_FOR_COMBINED\t\t= 1 << 3,\n-    GF_OMP_FOR_COMBINED_INTO\t= 1 << 4,\n-    GF_OMP_TARGET_KIND_MASK\t= (1 << 3) - 1,\n+    GF_OMP_FOR_COMBINED\t\t= 1 << 4,\n+    GF_OMP_FOR_COMBINED_INTO\t= 1 << 5,\n+    GF_OMP_TARGET_KIND_MASK\t= (1 << 4) - 1,\n     GF_OMP_TARGET_KIND_REGION\t= 0,\n     GF_OMP_TARGET_KIND_DATA\t= 1,\n     GF_OMP_TARGET_KIND_UPDATE\t= 2,\n-    GF_OMP_TARGET_KIND_OACC_PARALLEL = 3,\n-    GF_OMP_TARGET_KIND_OACC_KERNELS = 4,\n-    GF_OMP_TARGET_KIND_OACC_DATA = 5,\n-    GF_OMP_TARGET_KIND_OACC_UPDATE = 6,\n-    GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA = 7,\n+    GF_OMP_TARGET_KIND_ENTER_DATA = 3,\n+    GF_OMP_TARGET_KIND_EXIT_DATA = 4,\n+    GF_OMP_TARGET_KIND_OACC_PARALLEL = 5,\n+    GF_OMP_TARGET_KIND_OACC_KERNELS = 6,\n+    GF_OMP_TARGET_KIND_OACC_DATA = 7,\n+    GF_OMP_TARGET_KIND_OACC_UPDATE = 8,\n+    GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA = 9,\n \n     /* True on an GIMPLE_OMP_RETURN statement if the return does not require\n        a thread synchronization via some sort of barrier.  The exact barrier\n@@ -571,7 +575,10 @@ struct GTY((tag(\"GSS_OMP_CRITICAL\")))\n {\n   /* [ WORD 1-7 ] : base class */\n \n-  /* [ WORD 8 ]\n+  /* [ WORD 8 ]  */\n+  tree clauses;\n+\n+  /* [ WORD 9 ]\n      Critical section name.  */\n   tree name;\n };\n@@ -717,7 +724,7 @@ struct GTY((tag(\"GSS_OMP_CONTINUE\")))\n   tree control_use;\n };\n \n-/* GIMPLE_OMP_SINGLE, GIMPLE_OMP_TEAMS */\n+/* GIMPLE_OMP_SINGLE, GIMPLE_OMP_TEAMS, GIMPLE_OMP_ORDERED */\n \n struct GTY((tag(\"GSS_OMP_SINGLE_LAYOUT\")))\n   gimple_statement_omp_single_layout : public gimple_statement_omp\n@@ -742,6 +749,13 @@ struct GTY((tag(\"GSS_OMP_SINGLE_LAYOUT\")))\n          stmt->code == GIMPLE_OMP_TEAMS.  */\n };\n \n+struct GTY((tag(\"GSS_OMP_SINGLE_LAYOUT\")))\n+  gomp_ordered : public gimple_statement_omp_single_layout\n+{\n+    /* No extra fields; adds invariant:\n+\t stmt->code == GIMPLE_OMP_ORDERED.  */\n+};\n+\n \n /* GIMPLE_OMP_ATOMIC_LOAD.\n    Note: This is based on gimple, not g_s_omp, because g_s_omp\n@@ -1071,6 +1085,14 @@ is_a_helper <gomp_critical *>::test (gimple *gs)\n   return gs->code == GIMPLE_OMP_CRITICAL;\n }\n \n+template <>\n+template <>\n+inline bool\n+is_a_helper <gomp_ordered *>::test (gimple *gs)\n+{\n+  return gs->code == GIMPLE_OMP_ORDERED;\n+}\n+\n template <>\n template <>\n inline bool\n@@ -1279,6 +1301,14 @@ is_a_helper <const gomp_critical *>::test (const gimple *gs)\n   return gs->code == GIMPLE_OMP_CRITICAL;\n }\n \n+template <>\n+template <>\n+inline bool\n+is_a_helper <const gomp_ordered *>::test (const gimple *gs)\n+{\n+  return gs->code == GIMPLE_OMP_ORDERED;\n+}\n+\n template <>\n template <>\n inline bool\n@@ -1413,7 +1443,7 @@ gdebug *gimple_build_debug_bind_stat (tree, tree, gimple * MEM_STAT_DECL);\n gdebug *gimple_build_debug_source_bind_stat (tree, tree, gimple * MEM_STAT_DECL);\n #define gimple_build_debug_source_bind(var,val,stmt)\t\t\t\\\n   gimple_build_debug_source_bind_stat ((var), (val), (stmt) MEM_STAT_INFO)\n-gomp_critical *gimple_build_omp_critical (gimple_seq, tree);\n+gomp_critical *gimple_build_omp_critical (gimple_seq, tree, tree);\n gomp_for *gimple_build_omp_for (gimple_seq, int, tree, size_t, gimple_seq);\n gomp_parallel *gimple_build_omp_parallel (gimple_seq, tree, tree, tree);\n gomp_task *gimple_build_omp_task (gimple_seq, tree, tree, tree, tree,\n@@ -1422,7 +1452,7 @@ gimple *gimple_build_omp_section (gimple_seq);\n gimple *gimple_build_omp_master (gimple_seq);\n gimple *gimple_build_omp_taskgroup (gimple_seq);\n gomp_continue *gimple_build_omp_continue (tree, tree);\n-gimple *gimple_build_omp_ordered (gimple_seq);\n+gomp_ordered *gimple_build_omp_ordered (gimple_seq, tree);\n gimple *gimple_build_omp_return (bool);\n gomp_sections *gimple_build_omp_sections (gimple_seq, tree);\n gimple *gimple_build_omp_sections_switch (void);\n@@ -4658,7 +4688,8 @@ gimple_omp_critical_name (const gomp_critical *crit_stmt)\n }\n \n \n-/* Return a pointer to the name associated with OMP critical statement GS.  */\n+/* Return a pointer to the name associated with OMP critical statement\n+   CRIT_STMT.  */\n \n static inline tree *\n gimple_omp_critical_name_ptr (gomp_critical *crit_stmt)\n@@ -4667,7 +4698,8 @@ gimple_omp_critical_name_ptr (gomp_critical *crit_stmt)\n }\n \n \n-/* Set NAME to be the name associated with OMP critical statement GS.  */\n+/* Set NAME to be the name associated with OMP critical statement\n+   CRIT_STMT.  */\n \n static inline void\n gimple_omp_critical_set_name (gomp_critical *crit_stmt, tree name)\n@@ -4676,6 +4708,64 @@ gimple_omp_critical_set_name (gomp_critical *crit_stmt, tree name)\n }\n \n \n+/* Return the clauses associated with OMP_CRITICAL statement CRIT_STMT.  */\n+\n+static inline tree\n+gimple_omp_critical_clauses (const gomp_critical *crit_stmt)\n+{\n+  return crit_stmt->clauses;\n+}\n+\n+\n+/* Return a pointer to the clauses associated with OMP critical statement\n+   CRIT_STMT.  */\n+\n+static inline tree *\n+gimple_omp_critical_clauses_ptr (gomp_critical *crit_stmt)\n+{\n+  return &crit_stmt->clauses;\n+}\n+\n+\n+/* Set CLAUSES to be the clauses associated with OMP critical statement\n+   CRIT_STMT.  */\n+\n+static inline void\n+gimple_omp_critical_set_clauses (gomp_critical *crit_stmt, tree clauses)\n+{\n+  crit_stmt->clauses = clauses;\n+}\n+\n+\n+/* Return the clauses associated with OMP_ORDERED statement ORD_STMT.  */\n+\n+static inline tree\n+gimple_omp_ordered_clauses (const gomp_ordered *ord_stmt)\n+{\n+  return ord_stmt->clauses;\n+}\n+\n+\n+/* Return a pointer to the clauses associated with OMP ordered statement\n+   ORD_STMT.  */\n+\n+static inline tree *\n+gimple_omp_ordered_clauses_ptr (gomp_ordered *ord_stmt)\n+{\n+  return &ord_stmt->clauses;\n+}\n+\n+\n+/* Set CLAUSES to be the clauses associated with OMP ordered statement\n+   ORD_STMT.  */\n+\n+static inline void\n+gimple_omp_ordered_set_clauses (gomp_ordered *ord_stmt, tree clauses)\n+{\n+  ord_stmt->clauses = clauses;\n+}\n+\n+\n /* Return the kind of the OMP_FOR statemement G.  */\n \n static inline int\n@@ -5090,6 +5180,31 @@ gimple_omp_task_set_clauses (gimple *gs, tree clauses)\n }\n \n \n+/* Return true if OMP task statement G has the\n+   GF_OMP_TASK_TASKLOOP flag set.  */\n+\n+static inline bool\n+gimple_omp_task_taskloop_p (const gimple *g)\n+{\n+  GIMPLE_CHECK (g, GIMPLE_OMP_TASK);\n+  return (gimple_omp_subcode (g) & GF_OMP_TASK_TASKLOOP) != 0;\n+}\n+\n+\n+/* Set the GF_OMP_TASK_TASKLOOP field in G depending on the boolean\n+   value of TASKLOOP_P.  */\n+\n+static inline void\n+gimple_omp_task_set_taskloop_p (gimple *g, bool taskloop_p)\n+{\n+  GIMPLE_CHECK (g, GIMPLE_OMP_TASK);\n+  if (taskloop_p)\n+    g->subcode |= GF_OMP_TASK_TASKLOOP;\n+  else\n+    g->subcode &= ~GF_OMP_TASK_TASKLOOP;\n+}\n+\n+\n /* Return the child function used to hold the body of OMP_TASK GS.  */\n \n static inline tree"}, {"sha": "4a9f7fd6cbf7e210c323758a6426d990d5cc6042", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1110, "deletions": 98, "changes": 1208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -91,6 +91,8 @@ enum gimplify_omp_var_data\n   /* Flag for GOVD_LINEAR or GOVD_LASTPRIVATE: no outer reference.  */\n   GOVD_LINEAR_LASTPRIVATE_NO_OUTER = 16384,\n \n+  GOVD_MAP_0LEN_ARRAY = 32768,\n+\n   GOVD_DATA_SHARE_CLASS = (GOVD_SHARED | GOVD_PRIVATE | GOVD_FIRSTPRIVATE\n \t\t\t   | GOVD_LASTPRIVATE | GOVD_REDUCTION | GOVD_LINEAR\n \t\t\t   | GOVD_LOCAL)\n@@ -110,7 +112,11 @@ enum omp_region_type\n   /* Data region.  */\n   ORT_TARGET_DATA = 16,\n   /* Data region with offloading.  */\n-  ORT_TARGET = 32\n+  ORT_TARGET = 32,\n+  ORT_COMBINED_TARGET = 33,\n+  /* Dummy OpenMP region, used to disable expansion of\n+     DECL_VALUE_EXPRs in taskloop pre body.  */\n+  ORT_NONE = 64\n };\n \n /* Gimplify hashtable helper.  */\n@@ -147,11 +153,16 @@ struct gimplify_omp_ctx\n   struct gimplify_omp_ctx *outer_context;\n   splay_tree variables;\n   hash_set<tree> *privatized_types;\n+  /* Iteration variables in an OMP_FOR.  */\n+  vec<tree> loop_iter_var;\n   location_t location;\n   enum omp_clause_default_kind default_kind;\n   enum omp_region_type region_type;\n   bool combined_loop;\n   bool distribute;\n+  bool target_map_scalars_firstprivate;\n+  bool target_map_pointers_as_0len_arrays;\n+  bool target_firstprivatize_array_bases;\n };\n \n static struct gimplify_ctx *gimplify_ctxp;\n@@ -382,6 +393,7 @@ delete_omp_context (struct gimplify_omp_ctx *c)\n {\n   splay_tree_delete (c->variables);\n   delete c->privatized_types;\n+  c->loop_iter_var.release ();\n   XDELETE (c);\n }\n \n@@ -1070,7 +1082,7 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n \t  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n \n \t  /* Mark variable as local.  */\n-\t  if (ctx && !DECL_EXTERNAL (t)\n+\t  if (ctx && ctx->region_type != ORT_NONE && !DECL_EXTERNAL (t)\n \t      && (! DECL_SEEN_IN_BIND_EXPR_P (t)\n \t\t  || splay_tree_lookup (ctx->variables,\n \t\t\t\t\t(splay_tree_key) t) == NULL))\n@@ -2255,8 +2267,7 @@ maybe_fold_stmt (gimple_stmt_iterator *gsi)\n {\n   struct gimplify_omp_ctx *ctx;\n   for (ctx = gimplify_omp_ctxp; ctx; ctx = ctx->outer_context)\n-    if (ctx->region_type == ORT_TARGET\n-\t|| (ctx->region_type & (ORT_PARALLEL | ORT_TASK)) != 0)\n+    if ((ctx->region_type & (ORT_TARGET | ORT_PARALLEL | ORT_TASK)) != 0)\n       return false;\n   return fold_stmt (gsi);\n }\n@@ -4467,6 +4478,13 @@ is_gimple_stmt (tree t)\n     case OMP_ORDERED:\n     case OMP_CRITICAL:\n     case OMP_TASK:\n+    case OMP_TARGET:\n+    case OMP_TARGET_DATA:\n+    case OMP_TARGET_UPDATE:\n+    case OMP_TARGET_ENTER_DATA:\n+    case OMP_TARGET_EXIT_DATA:\n+    case OMP_TASKLOOP:\n+    case OMP_TEAMS:\n       /* These are always void.  */\n       return true;\n \n@@ -5536,7 +5554,7 @@ omp_firstprivatize_variable (struct gimplify_omp_ctx *ctx, tree decl)\n {\n   splay_tree_node n;\n \n-  if (decl == NULL || !DECL_P (decl))\n+  if (decl == NULL || !DECL_P (decl) || ctx->region_type == ORT_NONE)\n     return;\n \n   do\n@@ -5551,8 +5569,13 @@ omp_firstprivatize_variable (struct gimplify_omp_ctx *ctx, tree decl)\n \t  else\n \t    return;\n \t}\n-      else if (ctx->region_type == ORT_TARGET)\n-\tomp_add_variable (ctx, decl, GOVD_MAP | GOVD_MAP_TO_ONLY);\n+      else if ((ctx->region_type & ORT_TARGET) != 0)\n+\t{\n+\t  if (ctx->target_map_scalars_firstprivate)\n+\t    omp_add_variable (ctx, decl, GOVD_FIRSTPRIVATE);\n+\t  else\n+\t    omp_add_variable (ctx, decl, GOVD_MAP | GOVD_MAP_TO_ONLY);\n+\t}\n       else if (ctx->region_type != ORT_WORKSHARE\n \t       && ctx->region_type != ORT_SIMD\n \t       && ctx->region_type != ORT_TARGET_DATA)\n@@ -5628,7 +5651,7 @@ omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)\n   unsigned int nflags;\n   tree t;\n \n-  if (error_operand_p (decl))\n+  if (error_operand_p (decl) || ctx->region_type == ORT_NONE)\n     return;\n \n   /* Never elide decls whose type has TREE_ADDRESSABLE set.  This means\n@@ -5638,7 +5661,7 @@ omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)\n     flags |= GOVD_SEEN;\n \n   n = splay_tree_lookup (ctx->variables, (splay_tree_key)decl);\n-  if (n != NULL && n->value != GOVD_ALIGNED)\n+  if (n != NULL && (n->value & GOVD_DATA_SHARE_CLASS) != 0)\n     {\n       /* We shouldn't be re-adding the decl with the same data\n \t sharing class.  */\n@@ -5668,6 +5691,9 @@ omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)\n \t    nflags = GOVD_MAP | GOVD_MAP_TO_ONLY | GOVD_EXPLICIT;\n \t  else if (flags & GOVD_PRIVATE)\n \t    nflags = GOVD_PRIVATE;\n+\t  else if ((ctx->region_type & (ORT_TARGET | ORT_TARGET_DATA)) != 0\n+\t\t   && (flags & GOVD_FIRSTPRIVATE))\n+\t    nflags = GOVD_PRIVATE | GOVD_EXPLICIT;\n \t  else\n \t    nflags = GOVD_FIRSTPRIVATE;\n \t  nflags |= flags & GOVD_SEEN;\n@@ -5712,7 +5738,7 @@ omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)\n       if ((flags & GOVD_SHARED) == 0)\n \t{\n \t  t = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (decl)));\n-\t  if (TREE_CODE (t) != INTEGER_CST)\n+\t  if (DECL_P (t))\n \t    omp_notice_variable (ctx, t, true);\n \t}\n     }\n@@ -5736,7 +5762,7 @@ omp_notice_threadprivate_variable (struct gimplify_omp_ctx *ctx, tree decl,\n   struct gimplify_omp_ctx *octx;\n \n   for (octx = ctx; octx; octx = octx->outer_context)\n-    if (octx->region_type == ORT_TARGET)\n+    if ((octx->region_type & ORT_TARGET) != 0)\n       {\n \tn = splay_tree_lookup (octx->variables, (splay_tree_key)decl);\n \tif (n == NULL)\n@@ -5871,6 +5897,9 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n   if (error_operand_p (decl))\n     return false;\n \n+  if (ctx->region_type == ORT_NONE)\n+    return lang_hooks.decls.omp_disregard_value_expr (decl, false);\n+\n   /* Threadprivate variables are predetermined.  */\n   if (is_global_var (decl))\n     {\n@@ -5887,19 +5916,66 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n     }\n \n   n = splay_tree_lookup (ctx->variables, (splay_tree_key)decl);\n-  if (ctx->region_type == ORT_TARGET)\n+  if ((ctx->region_type & ORT_TARGET) != 0)\n     {\n       ret = lang_hooks.decls.omp_disregard_value_expr (decl, true);\n       if (n == NULL)\n \t{\n-\t  if (!lang_hooks.types.omp_mappable_type (TREE_TYPE (decl)))\n+\t  unsigned nflags = flags;\n+\t  if (ctx->target_map_pointers_as_0len_arrays\n+\t      || ctx->target_map_scalars_firstprivate)\n+\t    {\n+\t      bool is_declare_target = false;\n+\t      bool is_scalar = false;\n+\t      if (is_global_var (decl)\n+\t\t  && varpool_node::get_create (decl)->offloadable)\n+\t\t{\n+\t\t  struct gimplify_omp_ctx *octx;\n+\t\t  for (octx = ctx->outer_context;\n+\t\t       octx; octx = octx->outer_context)\n+\t\t    {\n+\t\t      n = splay_tree_lookup (octx->variables,\n+\t\t\t\t\t     (splay_tree_key)decl);\n+\t\t      if (n\n+\t\t\t  && (n->value & GOVD_DATA_SHARE_CLASS) != GOVD_SHARED\n+\t\t\t  && (n->value & GOVD_DATA_SHARE_CLASS) != 0)\n+\t\t\tbreak;\n+\t\t    }\n+\t\t  is_declare_target = octx == NULL;\n+\t\t}\n+\t      if (!is_declare_target && ctx->target_map_scalars_firstprivate)\n+\t\t{\n+\t\t  tree type = TREE_TYPE (decl);\n+\t\t  if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t\t    type = TREE_TYPE (type);\n+\t\t  if (TREE_CODE (type) == COMPLEX_TYPE)\n+\t\t    type = TREE_TYPE (type);\n+\t\t  if (INTEGRAL_TYPE_P (type)\n+\t\t      || SCALAR_FLOAT_TYPE_P (type)\n+\t\t      || TREE_CODE (type) == POINTER_TYPE)\n+\t\t    is_scalar = true;\n+\t\t}\n+\t      if (is_declare_target)\n+\t\t;\n+\t      else if (ctx->target_map_pointers_as_0len_arrays\n+\t\t       && (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE\n+\t\t\t   || (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE\n+\t\t\t       && TREE_CODE (TREE_TYPE (TREE_TYPE (decl)))\n+\t\t\t\t  == POINTER_TYPE)))\n+\t\tnflags |= GOVD_MAP | GOVD_MAP_0LEN_ARRAY;\n+\t      else if (is_scalar)\n+\t\tnflags |= GOVD_FIRSTPRIVATE;\n+\t    }\n+\t  if (nflags == flags\n+\t      && !lang_hooks.types.omp_mappable_type (TREE_TYPE (decl)))\n \t    {\n \t      error (\"%qD referenced in target region does not have \"\n \t\t     \"a mappable type\", decl);\n-\t      omp_add_variable (ctx, decl, GOVD_MAP | GOVD_EXPLICIT | flags);\n+\t      nflags |= GOVD_MAP | GOVD_EXPLICIT;\n \t    }\n-\t  else\n-\t    omp_add_variable (ctx, decl, GOVD_MAP | flags);\n+\t  else if (nflags == flags)\n+\t    nflags |= GOVD_MAP;\n+\t  omp_add_variable (ctx, decl, nflags);\n \t}\n       else\n \t{\n@@ -6046,19 +6122,38 @@ omp_check_private (struct gimplify_omp_ctx *ctx, tree decl, bool copyprivate)\n     {\n       ctx = ctx->outer_context;\n       if (ctx == NULL)\n-\treturn !(is_global_var (decl)\n-\t\t /* References might be private, but might be shared too,\n-\t\t    when checking for copyprivate, assume they might be\n-\t\t    private, otherwise assume they might be shared.  */\n-\t\t || (!copyprivate\n-\t\t     && lang_hooks.decls.omp_privatize_by_reference (decl)));\n+\t{\n+\t  if (is_global_var (decl))\n+\t    return false;\n+\n+\t  /* References might be private, but might be shared too,\n+\t     when checking for copyprivate, assume they might be\n+\t     private, otherwise assume they might be shared.  */\n+\t  if (copyprivate)\n+\t    return true;\n+\n+\t  if (lang_hooks.decls.omp_privatize_by_reference (decl))\n+\t    return false;\n+\n+\t  /* Treat C++ privatized non-static data members outside\n+\t     of the privatization the same.  */\n+\t  if (omp_member_access_dummy_var (decl))\n+\t    return false;\n+\n+\t  return true;\n+\t}\n \n       if ((ctx->region_type & (ORT_TARGET | ORT_TARGET_DATA)) != 0)\n \tcontinue;\n \n       n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n       if (n != NULL)\n-\treturn (n->value & GOVD_SHARED) == 0;\n+\t{\n+\t  if ((n->value & GOVD_LOCAL) != 0\n+\t      && omp_member_access_dummy_var (decl))\n+\t    return false;\n+\t  return (n->value & GOVD_SHARED) == 0;\n+\t}\n     }\n   while (ctx->region_type == ORT_WORKSHARE\n \t || ctx->region_type == ORT_SIMD);\n@@ -6095,18 +6190,55 @@ omp_no_lastprivate (struct gimplify_omp_ctx *ctx)\n   while (1);\n }\n \n+/* Callback for walk_tree to find a DECL_EXPR for the given DECL.  */\n+\n+static tree\n+find_decl_expr (tree *tp, int *walk_subtrees, void *data)\n+{\n+  tree t = *tp;\n+\n+  /* If this node has been visited, unmark it and keep looking.  */\n+  if (TREE_CODE (t) == DECL_EXPR && DECL_EXPR_DECL (t) == (tree) data)\n+    return t;\n+\n+  if (IS_TYPE_OR_DECL_P (t))\n+    *walk_subtrees = 0;\n+  return NULL_TREE;\n+}\n+\n /* Scan the OMP clauses in *LIST_P, installing mappings into a new\n    and previous omp contexts.  */\n \n static void\n gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n-\t\t\t   enum omp_region_type region_type)\n+\t\t\t   enum omp_region_type region_type,\n+\t\t\t   enum tree_code code)\n {\n   struct gimplify_omp_ctx *ctx, *outer_ctx;\n   tree c;\n+  hash_map<tree, tree> *struct_map_to_clause = NULL;\n+  tree *orig_list_p = list_p;\n \n   ctx = new_omp_context (region_type);\n   outer_ctx = ctx->outer_context;\n+  if (code == OMP_TARGET && !lang_GNU_Fortran ())\n+    {\n+      ctx->target_map_pointers_as_0len_arrays = true;\n+      /* FIXME: For Fortran we want to set this too, when\n+\t the Fortran FE is updated to OpenMP 4.5.  */\n+      ctx->target_map_scalars_firstprivate = true;\n+    }\n+  if (!lang_GNU_Fortran ())\n+    switch (code)\n+      {\n+      case OMP_TARGET:\n+      case OMP_TARGET_DATA:\n+      case OMP_TARGET_ENTER_DATA:\n+      case OMP_TARGET_EXIT_DATA:\n+\tctx->target_firstprivatize_array_bases = true;\n+      default:\n+\tbreak;\n+      }\n \n   while ((c = *list_p) != NULL)\n     {\n@@ -6151,6 +6283,12 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t   && splay_tree_lookup (outer_ctx->variables,\n \t\t\t\t\t (splay_tree_key) decl) == NULL)\n \t    omp_add_variable (outer_ctx, decl, GOVD_SHARED | GOVD_SEEN);\n+\t  else if (outer_ctx\n+\t\t   && (outer_ctx->region_type & ORT_TASK) != 0\n+\t\t   && outer_ctx->combined_loop\n+\t\t   && splay_tree_lookup (outer_ctx->variables,\n+\t\t\t\t\t (splay_tree_key) decl) == NULL)\n+\t    omp_add_variable (outer_ctx, decl, GOVD_LASTPRIVATE | GOVD_SEEN);\n \t  else if (outer_ctx\n \t\t   && outer_ctx->region_type == ORT_WORKSHARE\n \t\t   && outer_ctx->combined_loop\n@@ -6171,7 +6309,28 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tcase OMP_CLAUSE_REDUCTION:\n \t  flags = GOVD_REDUCTION | GOVD_SEEN | GOVD_EXPLICIT;\n \t  check_non_private = \"reduction\";\n-\t  goto do_add;\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (decl) == MEM_REF)\n+\t    {\n+\t      tree type = TREE_TYPE (decl);\n+\t      if (gimplify_expr (&TYPE_MAX_VALUE (TYPE_DOMAIN (type)), pre_p,\n+\t\t\t\t NULL, is_gimple_val, fb_rvalue) == GS_ERROR)\n+\t\t{\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\t      tree v = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n+\t      if (DECL_P (v))\n+\t\t{\n+\t\t  omp_firstprivatize_variable (ctx, v);\n+\t\t  omp_notice_variable (ctx, v, true);\n+\t\t}\n+\t      decl = TREE_OPERAND (decl, 0);\n+\t      if (TREE_CODE (decl) == ADDR_EXPR\n+\t\t  || TREE_CODE (decl) == INDIRECT_REF)\n+\t\tdecl = TREE_OPERAND (decl, 0);\n+\t    }\n+\t  goto do_add_decl;\n \tcase OMP_CLAUSE_LINEAR:\n \t  if (gimplify_expr (&OMP_CLAUSE_LINEAR_STEP (c), pre_p, NULL,\n \t\t\t     is_gimple_val, fb_rvalue) == GS_ERROR)\n@@ -6181,6 +6340,36 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t    }\n \t  else\n \t    {\n+\t      if (code == OMP_SIMD\n+\t\t  && !OMP_CLAUSE_LINEAR_NO_COPYIN (c))\n+\t\t{\n+\t\t  struct gimplify_omp_ctx *octx = outer_ctx;\n+\t\t  if (octx\n+\t\t      && octx->region_type == ORT_WORKSHARE\n+\t\t      && octx->combined_loop\n+\t\t      && !octx->distribute)\n+\t\t    {\n+\t\t      if (octx->outer_context\n+\t\t\t  && (octx->outer_context->region_type\n+\t\t\t      == ORT_COMBINED_PARALLEL))\n+\t\t\toctx = octx->outer_context->outer_context;\n+\t\t      else\n+\t\t\toctx = octx->outer_context;\n+\t\t    }\n+\t\t  if (octx\n+\t\t      && octx->region_type == ORT_WORKSHARE\n+\t\t      && octx->combined_loop\n+\t\t      && octx->distribute\n+\t\t      && !lang_GNU_Fortran ())\n+\t\t    {\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"%<linear%> clause for variable other than \"\n+\t\t\t\t\"loop iterator specified on construct \"\n+\t\t\t\t\"combined with %<distribute%>\");\n+\t\t      remove = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n \t      /* For combined #pragma omp parallel for simd, need to put\n \t\t lastprivate and perhaps firstprivate too on the\n \t\t parallel.  Similarly for #pragma omp for simd.  */\n@@ -6199,6 +6388,11 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t      decl = NULL_TREE;\n \t\t      break;\n \t\t    }\n+\t\t  flags = GOVD_SEEN;\n+\t\t  if (!OMP_CLAUSE_LINEAR_NO_COPYIN (c))\n+\t\t    flags |= GOVD_FIRSTPRIVATE;\n+\t\t  if (!OMP_CLAUSE_LINEAR_NO_COPYOUT (c))\n+\t\t    flags |= GOVD_LASTPRIVATE;\n \t\t  if (octx\n \t\t      && octx->region_type == ORT_WORKSHARE\n \t\t      && octx->combined_loop)\n@@ -6212,19 +6406,28 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t      else if (omp_check_private (octx, decl, false))\n \t\t\tbreak;\n \t\t    }\n+\t\t  else if (octx\n+\t\t\t   && (octx->region_type & ORT_TASK) != 0\n+\t\t\t   && octx->combined_loop)\n+\t\t    ;\n+\t\t  else if (octx\n+\t\t\t   && octx->region_type == ORT_COMBINED_PARALLEL\n+\t\t\t   && ctx->region_type == ORT_WORKSHARE\n+\t\t\t   && octx == outer_ctx)\n+\t\t    flags = GOVD_SEEN | GOVD_SHARED;\n+\t\t  else if (octx\n+\t\t\t   && octx->region_type == ORT_COMBINED_TARGET)\n+\t\t    flags &= ~GOVD_LASTPRIVATE;\n \t\t  else\n \t\t    break;\n-\t\t  if (splay_tree_lookup (octx->variables,\n-\t\t\t\t\t (splay_tree_key) decl) != NULL)\n+\t\t  splay_tree_node on\n+\t\t    = splay_tree_lookup (octx->variables,\n+\t\t\t\t\t (splay_tree_key) decl);\n+\t\t  if (on && (on->value & GOVD_DATA_SHARE_CLASS) != 0)\n \t\t    {\n \t\t      octx = NULL;\n \t\t      break;\n \t\t    }\n-\t\t  flags = GOVD_SEEN;\n-\t\t  if (!OMP_CLAUSE_LINEAR_NO_COPYIN (c))\n-\t\t    flags |= GOVD_FIRSTPRIVATE;\n-\t\t  if (!OMP_CLAUSE_LINEAR_NO_COPYOUT (c))\n-\t\t    flags |= GOVD_LASTPRIVATE;\n \t\t  omp_add_variable (octx, decl, flags);\n \t\t  if (octx->outer_context == NULL)\n \t\t    break;\n@@ -6249,10 +6452,24 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tcase OMP_CLAUSE_MAP:\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  if (error_operand_p (decl))\n+\t    remove = true;\n+\t  switch (code)\n \t    {\n-\t      remove = true;\n+\t    case OMP_TARGET:\n+\t      break;\n+\t    case OMP_TARGET_DATA:\n+\t    case OMP_TARGET_ENTER_DATA:\n+\t    case OMP_TARGET_EXIT_DATA:\n+\t      if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER)\n+\t\t/* For target {,enter ,exit }data only the array slice is\n+\t\t   mapped, but not the pointer to it.  */\n+\t\tremove = true;\n+\t      break;\n+\t    default:\n \t      break;\n \t    }\n+\t  if (remove)\n+\t    break;\n \t  if (OMP_CLAUSE_SIZE (c) == NULL_TREE)\n \t    OMP_CLAUSE_SIZE (c) = DECL_P (decl) ? DECL_SIZE_UNIT (decl)\n \t\t\t\t  : TYPE_SIZE_UNIT (TREE_TYPE (decl));\n@@ -6262,21 +6479,254 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      remove = true;\n \t      break;\n \t    }\n+\t  else if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t   && TREE_CODE (OMP_CLAUSE_SIZE (c)) != INTEGER_CST)\n+\t    {\n+\t      OMP_CLAUSE_SIZE (c)\n+\t\t= get_initialized_tmp_var (OMP_CLAUSE_SIZE (c), pre_p, NULL);\n+\t      omp_add_variable (ctx, OMP_CLAUSE_SIZE (c),\n+\t\t\t\tGOVD_FIRSTPRIVATE | GOVD_SEEN);\n+\t    }\n \t  if (!DECL_P (decl))\n \t    {\n-\t      if (gimplify_expr (&OMP_CLAUSE_DECL (c), pre_p,\n-\t\t\t\t NULL, is_gimple_lvalue, fb_lvalue)\n+\t      tree d = decl, *pd;\n+\t      if (TREE_CODE (d) == ARRAY_REF)\n+\t\t{\n+\t\t  while (TREE_CODE (d) == ARRAY_REF)\n+\t\t    d = TREE_OPERAND (d, 0);\n+\t\t  if (TREE_CODE (d) == COMPONENT_REF\n+\t\t      && TREE_CODE (TREE_TYPE (d)) == ARRAY_TYPE)\n+\t\t    decl = d;\n+\t\t}\n+\t      pd = &OMP_CLAUSE_DECL (c);\n+\t      if (d == decl\n+\t\t  && TREE_CODE (decl) == INDIRECT_REF\n+\t\t  && TREE_CODE (TREE_OPERAND (decl, 0)) == COMPONENT_REF\n+\t\t  && (TREE_CODE (TREE_TYPE (TREE_OPERAND (decl, 0)))\n+\t\t      == REFERENCE_TYPE))\n+\t\t{\n+\t\t  pd = &TREE_OPERAND (decl, 0);\n+\t\t  decl = TREE_OPERAND (decl, 0);\n+\t\t}\n+\t      if (TREE_CODE (decl) == COMPONENT_REF)\n+\t\t{\n+\t\t  while (TREE_CODE (decl) == COMPONENT_REF)\n+\t\t    decl = TREE_OPERAND (decl, 0);\n+\t\t}\n+\t      if (gimplify_expr (pd, pre_p, NULL, is_gimple_lvalue, fb_lvalue)\n \t\t  == GS_ERROR)\n \t\t{\n \t\t  remove = true;\n \t\t  break;\n \t\t}\n+\t      if (DECL_P (decl))\n+\t\t{\n+\t\t  if (error_operand_p (decl))\n+\t\t    {\n+\t\t      remove = true;\n+\t\t      break;\n+\t\t    }\n+\n+\t\t  if (TYPE_SIZE_UNIT (TREE_TYPE (decl)) == NULL\n+\t\t      || (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (decl)))\n+\t\t\t  != INTEGER_CST))\n+\t\t    {\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"mapping field %qE of variable length \"\n+\t\t\t\t\"structure\", OMP_CLAUSE_DECL (c));\n+\t\t      remove = true;\n+\t\t      break;\n+\t\t    }\n+\n+\t\t  tree offset;\n+\t\t  HOST_WIDE_INT bitsize, bitpos;\n+\t\t  machine_mode mode;\n+\t\t  int unsignedp, volatilep = 0;\n+\t\t  tree base = OMP_CLAUSE_DECL (c);\n+\t\t  while (TREE_CODE (base) == ARRAY_REF)\n+\t\t    base = TREE_OPERAND (base, 0);\n+\t\t  if (TREE_CODE (base) == INDIRECT_REF)\n+\t\t    base = TREE_OPERAND (base, 0);\n+\t\t  base = get_inner_reference (base, &bitsize, &bitpos, &offset,\n+\t\t\t\t\t      &mode, &unsignedp,\n+\t\t\t\t\t      &volatilep, false);\n+\t\t  gcc_assert (base == decl\n+\t\t\t      && (offset == NULL_TREE\n+\t\t\t\t  || TREE_CODE (offset) == INTEGER_CST));\n+\n+\t\t  splay_tree_node n\n+\t\t    = splay_tree_lookup (ctx->variables, (splay_tree_key)decl);\n+\t\t  bool ptr = (OMP_CLAUSE_MAP_KIND (c)\n+\t\t\t      == GOMP_MAP_FIRSTPRIVATE_POINTER);\n+\t\t  if (n == NULL || (n->value & (ptr ? GOVD_PRIVATE\n+\t\t\t\t\t\t    : GOVD_MAP)) == 0)\n+\t\t    {\n+\t\t      if (ptr)\n+\t\t\t{\n+\t\t\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t      OMP_CLAUSE_PRIVATE);\n+\t\t\t  OMP_CLAUSE_DECL (c2) = decl;\n+\t\t\t  OMP_CLAUSE_CHAIN (c2) = *orig_list_p;\n+\t\t\t  *orig_list_p = c2;\n+\t\t\t  if (struct_map_to_clause == NULL)\n+\t\t\t    struct_map_to_clause = new hash_map<tree, tree>;\n+\t\t\t  tree *osc;\n+\t\t\t  if (n == NULL || (n->value & GOVD_MAP) == 0)\n+\t\t\t    osc = NULL;\n+\t\t\t  else\n+\t\t\t    osc = struct_map_to_clause->get (decl);\n+\t\t\t  if (osc == NULL)\n+\t\t\t    struct_map_to_clause->put (decl,\n+\t\t\t\t\t\t       tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t\t  c,\n+\t\t\t\t\t\t\t\t  NULL_TREE));\n+\t\t\t  else\n+\t\t\t    *osc = tree_cons (*osc, c, NULL_TREE);\n+\t\t\t  flags = GOVD_PRIVATE | GOVD_EXPLICIT;\n+\t\t\t  goto do_add_decl;\n+\t\t\t}\n+\t\t      *list_p = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t  OMP_CLAUSE_MAP);\n+\t\t      OMP_CLAUSE_SET_MAP_KIND (*list_p, GOMP_MAP_STRUCT);\n+\t\t      OMP_CLAUSE_DECL (*list_p) = decl;\n+\t\t      OMP_CLAUSE_SIZE (*list_p) = size_int (1);\n+\t\t      OMP_CLAUSE_CHAIN (*list_p) = c;\n+\t\t      if (struct_map_to_clause == NULL)\n+\t\t\tstruct_map_to_clause = new hash_map<tree, tree>;\n+\t\t      struct_map_to_clause->put (decl, *list_p);\n+\t\t      list_p = &OMP_CLAUSE_CHAIN (*list_p);\n+\t\t      flags = GOVD_MAP | GOVD_EXPLICIT;\n+\t\t      if (OMP_CLAUSE_MAP_KIND (c) & GOMP_MAP_FLAG_ALWAYS)\n+\t\t\tflags |= GOVD_SEEN;\n+\t\t      goto do_add_decl;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      tree *osc = struct_map_to_clause->get (decl);\n+\t\t      tree *sc = NULL, *pt = NULL;\n+\t\t      if (!ptr && TREE_CODE (*osc) == TREE_LIST)\n+\t\t\tosc = &TREE_PURPOSE (*osc);\n+\t\t      if (OMP_CLAUSE_MAP_KIND (c) & GOMP_MAP_FLAG_ALWAYS)\n+\t\t\tn->value |= GOVD_SEEN;\n+\t\t      offset_int o1, o2;\n+\t\t      if (offset)\n+\t\t\to1 = wi::to_offset (offset);\n+\t\t      else\n+\t\t\to1 = 0;\n+\t\t      if (bitpos)\n+\t\t\to1 = o1 + bitpos / BITS_PER_UNIT;\n+\t\t      if (ptr)\n+\t\t\tpt = osc;\n+\t\t      else\n+\t\t\tsc = &OMP_CLAUSE_CHAIN (*osc);\n+\t\t      for (; ptr ? (*pt && (sc = &TREE_VALUE (*pt)))\n+\t\t\t\t : *sc != c;\n+\t\t\t   ptr ? (pt = &TREE_CHAIN (*pt))\n+\t\t\t       : (sc = &OMP_CLAUSE_CHAIN (*sc)))\n+\t\t\tif (TREE_CODE (OMP_CLAUSE_DECL (*sc)) != COMPONENT_REF\n+\t\t\t    && (TREE_CODE (OMP_CLAUSE_DECL (*sc))\n+\t\t\t\t!= INDIRECT_REF)\n+\t\t\t    && TREE_CODE (OMP_CLAUSE_DECL (*sc)) != ARRAY_REF)\n+\t\t\t  break;\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    tree offset2;\n+\t\t\t    HOST_WIDE_INT bitsize2, bitpos2;\n+\t\t\t    base = OMP_CLAUSE_DECL (*sc);\n+\t\t\t    if (TREE_CODE (base) == ARRAY_REF)\n+\t\t\t      {\n+\t\t\t\twhile (TREE_CODE (base) == ARRAY_REF)\n+\t\t\t\t  base = TREE_OPERAND (base, 0);\n+\t\t\t\tif (TREE_CODE (base) != COMPONENT_REF\n+\t\t\t\t    || (TREE_CODE (TREE_TYPE (base))\n+\t\t\t\t\t!= ARRAY_TYPE))\n+\t\t\t\t  break;\n+\t\t\t      }\n+\t\t\t    else if (TREE_CODE (base) == INDIRECT_REF\n+\t\t\t\t     && (TREE_CODE (TREE_OPERAND (base, 0))\n+\t\t\t\t\t == COMPONENT_REF)\n+\t\t\t\t     && (TREE_CODE (TREE_TYPE\n+\t\t\t\t\t\t     (TREE_OPERAND (base, 0)))\n+\t\t\t\t\t == REFERENCE_TYPE))\n+\t\t\t      base = TREE_OPERAND (base, 0);\n+\t\t\t    base = get_inner_reference (base, &bitsize2,\n+\t\t\t\t\t\t\t&bitpos2, &offset2,\n+\t\t\t\t\t\t\t&mode, &unsignedp,\n+\t\t\t\t\t\t\t&volatilep, false);\n+\t\t\t    if (base != decl)\n+\t\t\t      break;\n+\t\t\t    gcc_assert (offset == NULL_TREE\n+\t\t\t\t\t|| TREE_CODE (offset) == INTEGER_CST);\n+\t\t\t    tree d1 = OMP_CLAUSE_DECL (*sc);\n+\t\t\t    tree d2 = OMP_CLAUSE_DECL (c);\n+\t\t\t    while (TREE_CODE (d1) == ARRAY_REF)\n+\t\t\t      d1 = TREE_OPERAND (d1, 0);\n+\t\t\t    while (TREE_CODE (d2) == ARRAY_REF)\n+\t\t\t      d2 = TREE_OPERAND (d2, 0);\n+\t\t\t    if (TREE_CODE (d1) == INDIRECT_REF)\n+\t\t\t      d1 = TREE_OPERAND (d1, 0);\n+\t\t\t    if (TREE_CODE (d2) == INDIRECT_REF)\n+\t\t\t      d2 = TREE_OPERAND (d2, 0);\n+\t\t\t    while (TREE_CODE (d1) == COMPONENT_REF)\n+\t\t\t      if (TREE_CODE (d2) == COMPONENT_REF\n+\t\t\t\t  && TREE_OPERAND (d1, 1)\n+\t\t\t\t     == TREE_OPERAND (d2, 1))\n+\t\t\t\t{\n+\t\t\t\t  d1 = TREE_OPERAND (d1, 0);\n+\t\t\t\t  d2 = TREE_OPERAND (d2, 0);\n+\t\t\t\t}\n+\t\t\t      else\n+\t\t\t\tbreak;\n+\t\t\t    if (d1 == d2)\n+\t\t\t      {\n+\t\t\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t  \"%qE appears more than once in map \"\n+\t\t\t\t\t  \"clauses\", OMP_CLAUSE_DECL (c));\n+\t\t\t\tremove = true;\n+\t\t\t\tbreak;\n+\t\t\t      }\n+\t\t\t    if (offset2)\n+\t\t\t      o2 = wi::to_offset (offset2);\n+\t\t\t    else\n+\t\t\t      o2 = 0;\n+\t\t\t    if (bitpos2)\n+\t\t\t      o2 = o2 + bitpos2 / BITS_PER_UNIT;\n+\t\t\t    if (wi::ltu_p (o1, o2)\n+\t\t\t\t|| (wi::eq_p (o1, o2) && bitpos < bitpos2))\n+\t\t\t      break;\n+\t\t\t  }\n+\t\t      if (ptr)\n+\t\t\t{\n+\t\t\t  if (!remove)\n+\t\t\t    *pt = tree_cons (TREE_PURPOSE (*osc), c, *pt);\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      if (!remove)\n+\t\t\tOMP_CLAUSE_SIZE (*osc)\n+\t\t\t  = size_binop (PLUS_EXPR, OMP_CLAUSE_SIZE (*osc),\n+\t\t\t\t\tsize_one_node);\n+\t\t      if (!remove && *sc != c)\n+\t\t\t{\n+\t\t\t  *list_p = OMP_CLAUSE_CHAIN (c);\n+\t\t\t  OMP_CLAUSE_CHAIN (c) = *sc;\n+\t\t\t  *sc = c;\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n \t      break;\n \t    }\n \t  flags = GOVD_MAP | GOVD_EXPLICIT;\n \t  goto do_add;\n \n \tcase OMP_CLAUSE_DEPEND:\n+\t  if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK\n+\t      || OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SOURCE)\n+\t    {\n+\t      /* Nothing to do.  OMP_CLAUSE_DECL will be lowered in\n+\t\t omp-low.c.  */\n+\t      break;\n+\t    }\n \t  if (TREE_CODE (OMP_CLAUSE_DECL (c)) == COMPOUND_EXPR)\n \t    {\n \t      gimplify_expr (&TREE_OPERAND (OMP_CLAUSE_DECL (c), 0), pre_p,\n@@ -6328,19 +6778,46 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t    }\n \t  goto do_notice;\n \n+\tcase OMP_CLAUSE_USE_DEVICE_PTR:\n+\t  flags = GOVD_FIRSTPRIVATE | GOVD_EXPLICIT;\n+\t  goto do_add;\n+\tcase OMP_CLAUSE_IS_DEVICE_PTR:\n+\t  flags = GOVD_FIRSTPRIVATE | GOVD_EXPLICIT;\n+\t  goto do_add;\n+\n \tdo_add:\n \t  decl = OMP_CLAUSE_DECL (c);\n+\tdo_add_decl:\n \t  if (error_operand_p (decl))\n \t    {\n \t      remove = true;\n \t      break;\n \t    }\n+\t  if (DECL_NAME (decl) == NULL_TREE && (flags & GOVD_SHARED) == 0)\n+\t    {\n+\t      tree t = omp_member_access_dummy_var (decl);\n+\t      if (t)\n+\t\t{\n+\t\t  tree v = DECL_VALUE_EXPR (decl);\n+\t\t  DECL_NAME (decl) = DECL_NAME (TREE_OPERAND (v, 1));\n+\t\t  if (outer_ctx)\n+\t\t    omp_notice_variable (outer_ctx, t, true);\n+\t\t}\n+\t    }\n \t  omp_add_variable (ctx, decl, flags);\n \t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n \t      && OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n \t    {\n \t      omp_add_variable (ctx, OMP_CLAUSE_REDUCTION_PLACEHOLDER (c),\n \t\t\t\tGOVD_LOCAL | GOVD_SEEN);\n+\t      if (OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (c)\n+\t\t  && walk_tree (&OMP_CLAUSE_REDUCTION_INIT (c),\n+\t\t\t\tfind_decl_expr,\n+\t\t\t\tOMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (c),\n+\t\t\t\tNULL) == NULL_TREE)\n+\t\tomp_add_variable (ctx,\n+\t\t\t\t  OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (c),\n+\t\t\t\t  GOVD_LOCAL | GOVD_SEEN);\n \t      gimplify_omp_ctxp = ctx;\n \t      push_gimplify_context ();\n \n@@ -6444,6 +6921,11 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t    omp_notice_variable (outer_ctx, decl, true);\n \t  if (check_non_private\n \t      && region_type == ORT_WORKSHARE\n+\t      && (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION\n+\t\t  || decl == OMP_CLAUSE_DECL (c)\n+\t\t  || (TREE_CODE (OMP_CLAUSE_DECL (c)) == MEM_REF\n+\t\t      && (TREE_CODE (TREE_OPERAND (OMP_CLAUSE_DECL (c), 0))\n+\t\t\t  == ADDR_EXPR)))\n \t      && omp_check_private (ctx, decl, false))\n \t    {\n \t      error (\"%s variable %qE is private in outer context\",\n@@ -6452,8 +6934,33 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t    }\n \t  break;\n \n-\tcase OMP_CLAUSE_FINAL:\n \tcase OMP_CLAUSE_IF:\n+\t  if (OMP_CLAUSE_IF_MODIFIER (c) != ERROR_MARK\n+\t      && OMP_CLAUSE_IF_MODIFIER (c) != code)\n+\t    {\n+\t      const char *p[2];\n+\t      for (int i = 0; i < 2; i++)\n+\t\tswitch (i ? OMP_CLAUSE_IF_MODIFIER (c) : code)\n+\t\t  {\n+\t\t  case OMP_PARALLEL: p[i] = \"parallel\"; break;\n+\t\t  case OMP_TASK: p[i] = \"task\"; break;\n+\t\t  case OMP_TASKLOOP: p[i] = \"taskloop\"; break;\n+\t\t  case OMP_TARGET_DATA: p[i] = \"target data\"; break;\n+\t\t  case OMP_TARGET: p[i] = \"target\"; break;\n+\t\t  case OMP_TARGET_UPDATE: p[i] = \"target update\"; break;\n+\t\t  case OMP_TARGET_ENTER_DATA:\n+\t\t    p[i] = \"target enter data\"; break;\n+\t\t  case OMP_TARGET_EXIT_DATA: p[i] = \"target exit data\"; break;\n+\t\t  default: gcc_unreachable ();\n+\t\t  }\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"expected %qs %<if%> clause modifier rather than %qs\",\n+\t\t\tp[0], p[1]);\n+\t      remove = true;\n+\t    }\n+\t  /* Fall through.  */\n+\n+\tcase OMP_CLAUSE_FINAL:\n \t  OMP_CLAUSE_OPERAND (c, 0)\n \t    = gimple_boolify (OMP_CLAUSE_OPERAND (c, 0));\n \t  /* Fall through.  */\n@@ -6464,21 +6971,29 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tcase OMP_CLAUSE_THREAD_LIMIT:\n \tcase OMP_CLAUSE_DIST_SCHEDULE:\n \tcase OMP_CLAUSE_DEVICE:\n+\tcase OMP_CLAUSE_PRIORITY:\n+\tcase OMP_CLAUSE_GRAINSIZE:\n+\tcase OMP_CLAUSE_NUM_TASKS:\n+\tcase OMP_CLAUSE_HINT:\n \tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \tcase OMP_CLAUSE_ASYNC:\n \tcase OMP_CLAUSE_WAIT:\n \tcase OMP_CLAUSE_NUM_GANGS:\n \tcase OMP_CLAUSE_NUM_WORKERS:\n \tcase OMP_CLAUSE_VECTOR_LENGTH:\n-\tcase OMP_CLAUSE_GANG:\n \tcase OMP_CLAUSE_WORKER:\n \tcase OMP_CLAUSE_VECTOR:\n \t  if (gimplify_expr (&OMP_CLAUSE_OPERAND (c, 0), pre_p, NULL,\n \t\t\t     is_gimple_val, fb_rvalue) == GS_ERROR)\n \t    remove = true;\n-\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_GANG\n-\t      && gimplify_expr (&OMP_CLAUSE_OPERAND (c, 1), pre_p, NULL,\n-\t\t\t\tis_gimple_val, fb_rvalue) == GS_ERROR)\n+\t  break;\n+\n+\tcase OMP_CLAUSE_GANG:\n+\t  if (gimplify_expr (&OMP_CLAUSE_OPERAND (c, 0), pre_p, NULL,\n+\t\t\t     is_gimple_val, fb_rvalue) == GS_ERROR)\n+\t    remove = true;\n+\t  if (gimplify_expr (&OMP_CLAUSE_OPERAND (c, 1), pre_p, NULL,\n+\t\t\t     is_gimple_val, fb_rvalue) == GS_ERROR)\n \t    remove = true;\n \t  break;\n \n@@ -6497,6 +7012,14 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tcase OMP_CLAUSE_MERGEABLE:\n \tcase OMP_CLAUSE_PROC_BIND:\n \tcase OMP_CLAUSE_SAFELEN:\n+\tcase OMP_CLAUSE_SIMDLEN:\n+\tcase OMP_CLAUSE_NOGROUP:\n+\tcase OMP_CLAUSE_THREADS:\n+\tcase OMP_CLAUSE_SIMD:\n+\t  break;\n+\n+\tcase OMP_CLAUSE_DEFAULTMAP:\n+\t  ctx->target_map_scalars_firstprivate = false;\n \t  break;\n \n \tcase OMP_CLAUSE_ALIGNED:\n@@ -6532,6 +7055,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n     }\n \n   gimplify_omp_ctxp = ctx;\n+  if (struct_map_to_clause)\n+    delete struct_map_to_clause;\n }\n \n struct gimplify_adjust_omp_clauses_data\n@@ -6612,6 +7137,30 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n     OMP_CLAUSE_PRIVATE_DEBUG (clause) = 1;\n   else if (code == OMP_CLAUSE_PRIVATE && (flags & GOVD_PRIVATE_OUTER_REF))\n     OMP_CLAUSE_PRIVATE_OUTER_REF (clause) = 1;\n+  else if (code == OMP_CLAUSE_MAP && (flags & GOVD_MAP_0LEN_ARRAY) != 0)\n+    {\n+      tree nc = build_omp_clause (input_location, OMP_CLAUSE_MAP);\n+      OMP_CLAUSE_DECL (nc) = decl;\n+      if (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE\n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) == POINTER_TYPE)\n+\tOMP_CLAUSE_DECL (clause)\n+\t  = build_simple_mem_ref_loc (input_location, decl);\n+      OMP_CLAUSE_DECL (clause)\n+\t= build2 (MEM_REF, char_type_node, OMP_CLAUSE_DECL (clause),\n+\t\t  build_int_cst (build_pointer_type (char_type_node), 0));\n+      OMP_CLAUSE_SIZE (clause) = size_zero_node;\n+      OMP_CLAUSE_SIZE (nc) = size_zero_node;\n+      OMP_CLAUSE_SET_MAP_KIND (clause, GOMP_MAP_ALLOC);\n+      OMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION (clause) = 1;\n+      OMP_CLAUSE_SET_MAP_KIND (nc, GOMP_MAP_FIRSTPRIVATE_POINTER);\n+      OMP_CLAUSE_CHAIN (nc) = *list_p;\n+      OMP_CLAUSE_CHAIN (clause) = nc;\n+      struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n+      gimplify_omp_ctxp = ctx->outer_context;\n+      gimplify_expr (&TREE_OPERAND (OMP_CLAUSE_DECL (clause), 0),\n+\t\t     pre_p, NULL, is_gimple_val, fb_rvalue);\n+      gimplify_omp_ctxp = ctx;\n+    }\n   else if (code == OMP_CLAUSE_MAP)\n     {\n       OMP_CLAUSE_SET_MAP_KIND (clause,\n@@ -6638,7 +7187,10 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n \t\t\t\t      OMP_CLAUSE_MAP);\n \t  OMP_CLAUSE_DECL (nc) = decl;\n \t  OMP_CLAUSE_SIZE (nc) = size_zero_node;\n-\t  OMP_CLAUSE_SET_MAP_KIND (nc, GOMP_MAP_POINTER);\n+\t  if (gimplify_omp_ctxp->target_firstprivatize_array_bases)\n+\t    OMP_CLAUSE_SET_MAP_KIND (nc, GOMP_MAP_FIRSTPRIVATE_POINTER);\n+\t  else\n+\t    OMP_CLAUSE_SET_MAP_KIND (nc, GOMP_MAP_POINTER);\n \t  OMP_CLAUSE_CHAIN (nc) = OMP_CLAUSE_CHAIN (clause);\n \t  OMP_CLAUSE_CHAIN (clause) = nc;\n \t}\n@@ -6666,7 +7218,8 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n }\n \n static void\n-gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p)\n+gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p,\n+\t\t\t     enum tree_code code)\n {\n   struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n   tree c, decl;\n@@ -6761,13 +7314,56 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p)\n \tcase OMP_CLAUSE_MAP:\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  if (!DECL_P (decl))\n-\t    break;\n+\t    {\n+\t      if ((ctx->region_type & ORT_TARGET) != 0\n+\t\t  && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER)\n+\t\t{\n+\t\t  if (TREE_CODE (decl) == INDIRECT_REF\n+\t\t      && TREE_CODE (TREE_OPERAND (decl, 0)) == COMPONENT_REF\n+\t\t      && (TREE_CODE (TREE_TYPE (TREE_OPERAND (decl, 0)))\n+\t\t\t  == REFERENCE_TYPE))\n+\t\t    decl = TREE_OPERAND (decl, 0);\n+\t\t  if (TREE_CODE (decl) == COMPONENT_REF)\n+\t\t    {\n+\t\t      while (TREE_CODE (decl) == COMPONENT_REF)\n+\t\t\tdecl = TREE_OPERAND (decl, 0);\n+\t\t      if (DECL_P (decl))\n+\t\t\t{\n+\t\t\t  n = splay_tree_lookup (ctx->variables,\n+\t\t\t\t\t\t (splay_tree_key) decl);\n+\t\t\t  if (!(n->value & GOVD_SEEN))\n+\t\t\t    remove = true;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      break;\n+\t    }\n \t  n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n-\t  if (ctx->region_type == ORT_TARGET && !(n->value & GOVD_SEEN))\n+\t  if ((ctx->region_type & ORT_TARGET) != 0\n+\t      && !(n->value & GOVD_SEEN)\n+\t      && ((OMP_CLAUSE_MAP_KIND (c) & GOMP_MAP_FLAG_ALWAYS) == 0\n+\t\t  || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_STRUCT))\n+\t    {\n+\t      remove = true;\n+\t      /* For struct element mapping, if struct is never referenced\n+\t\t in target block and none of the mapping has always modifier,\n+\t\t remove all the struct element mappings, which immediately\n+\t\t follow the GOMP_MAP_STRUCT map clause.  */\n+\t      if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_STRUCT)\n+\t\t{\n+\t\t  HOST_WIDE_INT cnt = tree_to_shwi (OMP_CLAUSE_SIZE (c));\n+\t\t  while (cnt--)\n+\t\t    OMP_CLAUSE_CHAIN (c)\n+\t\t      = OMP_CLAUSE_CHAIN (OMP_CLAUSE_CHAIN (c));\n+\t\t}\n+\t    }\n+\t  else if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_STRUCT\n+\t\t   && code == OMP_TARGET_EXIT_DATA)\n \t    remove = true;\n \t  else if (DECL_SIZE (decl)\n \t\t   && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST\n-\t\t   && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_POINTER)\n+\t\t   && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_POINTER\n+\t\t   && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_FIRSTPRIVATE_POINTER)\n \t    {\n \t      /* For GOMP_MAP_FORCE_DEVICEPTR, we'll never enter here, because\n \t\t for these, TREE_CODE (DECL_SIZE (decl)) will always be\n@@ -6787,17 +7383,33 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p)\n \t\t  omp_notice_variable (ctx->outer_context,\n \t\t\t\t       OMP_CLAUSE_SIZE (c), true);\n \t\t}\n-\t      tree nc = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t  OMP_CLAUSE_MAP);\n-\t      OMP_CLAUSE_DECL (nc) = decl;\n-\t      OMP_CLAUSE_SIZE (nc) = size_zero_node;\n-\t      OMP_CLAUSE_SET_MAP_KIND (nc, GOMP_MAP_POINTER);\n-\t      OMP_CLAUSE_CHAIN (nc) = OMP_CLAUSE_CHAIN (c);\n-\t      OMP_CLAUSE_CHAIN (c) = nc;\n-\t      c = nc;\n+\t      if (((ctx->region_type & ORT_TARGET) != 0\n+\t\t   || !ctx->target_firstprivatize_array_bases)\n+\t\t  && ((n->value & GOVD_SEEN) == 0\n+\t\t      || (n->value & (GOVD_PRIVATE | GOVD_FIRSTPRIVATE)) == 0))\n+\t\t{\n+\t\t  tree nc = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t      OMP_CLAUSE_MAP);\n+\t\t  OMP_CLAUSE_DECL (nc) = decl;\n+\t\t  OMP_CLAUSE_SIZE (nc) = size_zero_node;\n+\t\t  if (ctx->target_firstprivatize_array_bases)\n+\t\t    OMP_CLAUSE_SET_MAP_KIND (nc,\n+\t\t\t\t\t     GOMP_MAP_FIRSTPRIVATE_POINTER);\n+\t\t  else\n+\t\t    OMP_CLAUSE_SET_MAP_KIND (nc, GOMP_MAP_POINTER);\n+\t\t  OMP_CLAUSE_CHAIN (nc) = OMP_CLAUSE_CHAIN (c);\n+\t\t  OMP_CLAUSE_CHAIN (c) = nc;\n+\t\t  c = nc;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (OMP_CLAUSE_SIZE (c) == NULL_TREE)\n+\t\tOMP_CLAUSE_SIZE (c) = DECL_SIZE_UNIT (decl);\n+\t      if ((n->value & GOVD_SEEN)\n+\t\t  && (n->value & (GOVD_PRIVATE | GOVD_FIRSTPRIVATE)))\n+\t\tOMP_CLAUSE_MAP_PRIVATE (c) = 1;\n \t    }\n-\t  else if (OMP_CLAUSE_SIZE (c) == NULL_TREE)\n-\t    OMP_CLAUSE_SIZE (c) = DECL_SIZE_UNIT (decl);\n \t  break;\n \n \tcase OMP_CLAUSE_TO:\n@@ -6846,7 +7458,18 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p)\n \tcase OMP_CLAUSE_MERGEABLE:\n \tcase OMP_CLAUSE_PROC_BIND:\n \tcase OMP_CLAUSE_SAFELEN:\n+\tcase OMP_CLAUSE_SIMDLEN:\n \tcase OMP_CLAUSE_DEPEND:\n+\tcase OMP_CLAUSE_PRIORITY:\n+\tcase OMP_CLAUSE_GRAINSIZE:\n+\tcase OMP_CLAUSE_NUM_TASKS:\n+\tcase OMP_CLAUSE_NOGROUP:\n+\tcase OMP_CLAUSE_THREADS:\n+\tcase OMP_CLAUSE_SIMD:\n+\tcase OMP_CLAUSE_HINT:\n+\tcase OMP_CLAUSE_DEFAULTMAP:\n+\tcase OMP_CLAUSE_USE_DEVICE_PTR:\n+\tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \tcase OMP_CLAUSE_ASYNC:\n \tcase OMP_CLAUSE_WAIT:\n@@ -6890,8 +7513,9 @@ gimplify_oacc_cache (tree *expr_p, gimple_seq *pre_p)\n {\n   tree expr = *expr_p;\n \n-  gimplify_scan_omp_clauses (&OACC_CACHE_CLAUSES (expr), pre_p, ORT_WORKSHARE);\n-  gimplify_adjust_omp_clauses (pre_p, &OACC_CACHE_CLAUSES (expr));\n+  gimplify_scan_omp_clauses (&OACC_CACHE_CLAUSES (expr), pre_p, ORT_WORKSHARE,\n+\t\t\t     OACC_CACHE);\n+  gimplify_adjust_omp_clauses (pre_p, &OACC_CACHE_CLAUSES (expr), OACC_CACHE);\n \n   /* TODO: Do something sensible with this information.  */\n \n@@ -6913,7 +7537,7 @@ gimplify_omp_parallel (tree *expr_p, gimple_seq *pre_p)\n   gimplify_scan_omp_clauses (&OMP_PARALLEL_CLAUSES (expr), pre_p,\n \t\t\t     OMP_PARALLEL_COMBINED (expr)\n \t\t\t     ? ORT_COMBINED_PARALLEL\n-\t\t\t     : ORT_PARALLEL);\n+\t\t\t     : ORT_PARALLEL, OMP_PARALLEL);\n \n   push_gimplify_context ();\n \n@@ -6923,7 +7547,8 @@ gimplify_omp_parallel (tree *expr_p, gimple_seq *pre_p)\n   else\n     pop_gimplify_context (NULL);\n \n-  gimplify_adjust_omp_clauses (pre_p, &OMP_PARALLEL_CLAUSES (expr));\n+  gimplify_adjust_omp_clauses (pre_p, &OMP_PARALLEL_CLAUSES (expr),\n+\t\t\t       OMP_PARALLEL);\n \n   g = gimple_build_omp_parallel (body,\n \t\t\t\t OMP_PARALLEL_CLAUSES (expr),\n@@ -6949,7 +7574,7 @@ gimplify_omp_task (tree *expr_p, gimple_seq *pre_p)\n   gimplify_scan_omp_clauses (&OMP_TASK_CLAUSES (expr), pre_p,\n \t\t\t     find_omp_clause (OMP_TASK_CLAUSES (expr),\n \t\t\t\t\t      OMP_CLAUSE_UNTIED)\n-\t\t\t     ? ORT_UNTIED_TASK : ORT_TASK);\n+\t\t\t     ? ORT_UNTIED_TASK : ORT_TASK, OMP_TASK);\n \n   push_gimplify_context ();\n \n@@ -6959,7 +7584,7 @@ gimplify_omp_task (tree *expr_p, gimple_seq *pre_p)\n   else\n     pop_gimplify_context (NULL);\n \n-  gimplify_adjust_omp_clauses (pre_p, &OMP_TASK_CLAUSES (expr));\n+  gimplify_adjust_omp_clauses (pre_p, &OMP_TASK_CLAUSES (expr), OMP_TASK);\n \n   g = gimple_build_omp_task (body,\n \t\t\t     OMP_TASK_CLAUSES (expr),\n@@ -7007,8 +7632,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n   gomp_for *gfor;\n   gimple_seq for_body, for_pre_body;\n   int i;\n-  bool simd;\n   bitmap has_decl_expr = NULL;\n+  enum omp_region_type ort = ORT_WORKSHARE;\n \n   orig_for_stmt = for_stmt = *expr_p;\n \n@@ -7018,19 +7643,24 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n     case CILK_FOR:\n     case OMP_DISTRIBUTE:\n     case OACC_LOOP:\n-      simd = false;\n+      break;\n+    case OMP_TASKLOOP:\n+      if (find_omp_clause (OMP_FOR_CLAUSES (for_stmt), OMP_CLAUSE_UNTIED))\n+\tort = ORT_UNTIED_TASK;\n+      else\n+\tort = ORT_TASK;\n       break;\n     case OMP_SIMD:\n     case CILK_SIMD:\n-      simd = true;\n+      ort = ORT_SIMD;\n       break;\n     default:\n       gcc_unreachable ();\n     }\n \n   /* Set OMP_CLAUSE_LINEAR_NO_COPYIN flag on explicit linear\n      clause for the IV.  */\n-  if (simd && TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) == 1)\n+  if (ort == ORT_SIMD && TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) == 1)\n     {\n       t = TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), 0);\n       gcc_assert (TREE_CODE (t) == MODIFY_EXPR);\n@@ -7057,14 +7687,16 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t}\n     }\n \n-  gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (for_stmt), pre_p,\n-\t\t\t     simd ? ORT_SIMD : ORT_WORKSHARE);\n+  if (TREE_CODE (for_stmt) != OMP_TASKLOOP)\n+    gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (for_stmt), pre_p, ort,\n+\t\t\t       TREE_CODE (for_stmt));\n+\n   if (TREE_CODE (for_stmt) == OMP_DISTRIBUTE)\n     gimplify_omp_ctxp->distribute = true;\n \n   /* Handle OMP_FOR_INIT.  */\n   for_pre_body = NULL;\n-  if (simd && OMP_FOR_PRE_BODY (for_stmt))\n+  if (ort == ORT_SIMD && OMP_FOR_PRE_BODY (for_stmt))\n     {\n       has_decl_expr = BITMAP_ALLOC (NULL);\n       if (TREE_CODE (OMP_FOR_PRE_BODY (for_stmt)) == DECL_EXPR\n@@ -7087,20 +7719,109 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t    }\n \t}\n     }\n-  gimplify_and_add (OMP_FOR_PRE_BODY (for_stmt), &for_pre_body);\n+  if (OMP_FOR_PRE_BODY (for_stmt))\n+    {\n+      if (TREE_CODE (for_stmt) != OMP_TASKLOOP || gimplify_omp_ctxp)\n+\tgimplify_and_add (OMP_FOR_PRE_BODY (for_stmt), &for_pre_body);\n+      else\n+\t{\n+\t  struct gimplify_omp_ctx ctx;\n+\t  memset (&ctx, 0, sizeof (ctx));\n+\t  ctx.region_type = ORT_NONE;\n+\t  gimplify_omp_ctxp = &ctx;\n+\t  gimplify_and_add (OMP_FOR_PRE_BODY (for_stmt), &for_pre_body);\n+\t  gimplify_omp_ctxp = NULL;\n+\t}\n+    }\n   OMP_FOR_PRE_BODY (for_stmt) = NULL_TREE;\n \n   if (OMP_FOR_INIT (for_stmt) == NULL_TREE)\n+    for_stmt = inner_for_stmt;\n+\n+  /* For taskloop, need to gimplify the start, end and step before the\n+     taskloop, outside of the taskloop omp context.  */\n+  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP)\n     {\n-      for_stmt = inner_for_stmt;\n-      gimplify_omp_ctxp->combined_loop = true;\n+      for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)); i++)\n+\t{\n+\t  t = TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), i);\n+\t  if (!is_gimple_constant (TREE_OPERAND (t, 1)))\n+\t    {\n+\t      TREE_OPERAND (t, 1)\n+\t\t= get_initialized_tmp_var (TREE_OPERAND (t, 1),\n+\t\t\t\t\t   pre_p, NULL);\n+\t      tree c = build_omp_clause (input_location,\n+\t\t\t\t\t OMP_CLAUSE_FIRSTPRIVATE);\n+\t      OMP_CLAUSE_DECL (c) = TREE_OPERAND (t, 1);\n+\t      OMP_CLAUSE_CHAIN (c) = OMP_FOR_CLAUSES (orig_for_stmt);\n+\t      OMP_FOR_CLAUSES (orig_for_stmt) = c;\n+\t    }\n+\n+\t  /* Handle OMP_FOR_COND.  */\n+\t  t = TREE_VEC_ELT (OMP_FOR_COND (for_stmt), i);\n+\t  if (!is_gimple_constant (TREE_OPERAND (t, 1)))\n+\t    {\n+\t      TREE_OPERAND (t, 1)\n+\t\t= get_initialized_tmp_var (TREE_OPERAND (t, 1),\n+\t\t\t\t\t   gimple_seq_empty_p (for_pre_body)\n+\t\t\t\t\t   ? pre_p : &for_pre_body, NULL);\n+\t      tree c = build_omp_clause (input_location,\n+\t\t\t\t\t OMP_CLAUSE_FIRSTPRIVATE);\n+\t      OMP_CLAUSE_DECL (c) = TREE_OPERAND (t, 1);\n+\t      OMP_CLAUSE_CHAIN (c) = OMP_FOR_CLAUSES (orig_for_stmt);\n+\t      OMP_FOR_CLAUSES (orig_for_stmt) = c;\n+\t    }\n+\n+\t  /* Handle OMP_FOR_INCR.  */\n+\t  t = TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), i);\n+\t  if (TREE_CODE (t) == MODIFY_EXPR)\n+\t    {\n+\t      decl = TREE_OPERAND (t, 0);\n+\t      t = TREE_OPERAND (t, 1);\n+\t      tree *tp = &TREE_OPERAND (t, 1);\n+\t      if (TREE_CODE (t) == PLUS_EXPR && *tp == decl)\n+\t\ttp = &TREE_OPERAND (t, 0);\n+\n+\t      if (!is_gimple_constant (*tp))\n+\t\t{\n+\t\t  gimple_seq *seq = gimple_seq_empty_p (for_pre_body)\n+\t\t\t\t    ? pre_p : &for_pre_body;\n+\t\t  *tp = get_initialized_tmp_var (*tp, seq, NULL);\n+\t\t  tree c = build_omp_clause (input_location,\n+\t\t\t\t\t     OMP_CLAUSE_FIRSTPRIVATE);\n+\t\t  OMP_CLAUSE_DECL (c) = *tp;\n+\t\t  OMP_CLAUSE_CHAIN (c) = OMP_FOR_CLAUSES (orig_for_stmt);\n+\t\t  OMP_FOR_CLAUSES (orig_for_stmt) = c;\n+\t\t}\n+\t    }\n+\t}\n+\n+      gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (orig_for_stmt), pre_p, ort,\n+\t\t\t\t OMP_TASKLOOP);\n     }\n \n+  if (orig_for_stmt != for_stmt)\n+    gimplify_omp_ctxp->combined_loop = true;\n+\n   for_body = NULL;\n   gcc_assert (TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt))\n \t      == TREE_VEC_LENGTH (OMP_FOR_COND (for_stmt)));\n   gcc_assert (TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt))\n \t      == TREE_VEC_LENGTH (OMP_FOR_INCR (for_stmt)));\n+\n+  tree c = find_omp_clause (OMP_FOR_CLAUSES (for_stmt), OMP_CLAUSE_ORDERED);\n+  bool is_doacross = false;\n+  if (c && OMP_CLAUSE_ORDERED_EXPR (c))\n+    {\n+      is_doacross = true;\n+      gimplify_omp_ctxp->loop_iter_var.create (TREE_VEC_LENGTH\n+\t\t\t\t\t\t (OMP_FOR_INIT (for_stmt))\n+\t\t\t\t\t       * 2);\n+    }\n+  int collapse = 1;\n+  c = find_omp_clause (OMP_FOR_CLAUSES (for_stmt), OMP_CLAUSE_COLLAPSE);\n+  if (c)\n+    collapse = tree_to_shwi (OMP_CLAUSE_COLLAPSE_EXPR (c));\n   for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)); i++)\n     {\n       t = TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), i);\n@@ -7109,16 +7830,25 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n       gcc_assert (DECL_P (decl));\n       gcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (decl))\n \t\t  || POINTER_TYPE_P (TREE_TYPE (decl)));\n+      if (is_doacross)\n+\t{\n+\t  if (TREE_CODE (for_stmt) == OMP_FOR && OMP_FOR_ORIG_DECLS (for_stmt))\n+\t    gimplify_omp_ctxp->loop_iter_var.quick_push\n+\t      (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (for_stmt), i));\n+\t  else\n+\t    gimplify_omp_ctxp->loop_iter_var.quick_push (decl);\n+\t  gimplify_omp_ctxp->loop_iter_var.quick_push (decl);\n+\t}\n \n       /* Make sure the iteration variable is private.  */\n       tree c = NULL_TREE;\n       tree c2 = NULL_TREE;\n       if (orig_for_stmt != for_stmt)\n \t/* Do this only on innermost construct for combined ones.  */;\n-      else if (simd)\n+      else if (ort == ORT_SIMD)\n \t{\n \t  splay_tree_node n = splay_tree_lookup (gimplify_omp_ctxp->variables,\n-\t\t\t\t\t\t (splay_tree_key)decl);\n+\t\t\t\t\t\t (splay_tree_key) decl);\n \t  omp_is_private (gimplify_omp_ctxp, decl,\n \t\t\t  1 + (TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt))\n \t\t\t       != 1));\n@@ -7169,6 +7899,11 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t      else if (omp_check_private (outer, decl, false))\n \t\t\touter = NULL;\n \t\t    }\n+\t\t  else if (((outer->region_type & ORT_TASK) != 0)\n+\t\t\t   && outer->combined_loop\n+\t\t\t   && !omp_check_private (gimplify_omp_ctxp,\n+\t\t\t\t\t\t  decl, false))\n+\t\t    ;\n \t\t  else if (outer->region_type != ORT_COMBINED_PARALLEL)\n \t\t    outer = NULL;\n \t\t  if (outer)\n@@ -7213,6 +7948,11 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t      else if (omp_check_private (outer, decl, false))\n \t\t\touter = NULL;\n \t\t    }\n+\t\t  else if (((outer->region_type & ORT_TASK) != 0)\n+\t\t\t   && outer->combined_loop\n+\t\t\t   && !omp_check_private (gimplify_omp_ctxp,\n+\t\t\t\t\t\t  decl, false))\n+\t\t    ;\n \t\t  else if (outer->region_type != ORT_COMBINED_PARALLEL)\n \t\t    outer = NULL;\n \t\t  if (outer)\n@@ -7255,14 +7995,16 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n       if (orig_for_stmt != for_stmt)\n \tvar = decl;\n       else if (!is_gimple_reg (decl)\n-\t       || (simd && TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) > 1))\n+\t       || (ort == ORT_SIMD\n+\t\t   && TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) > 1))\n \t{\n \t  var = create_tmp_var (TREE_TYPE (decl), get_name (decl));\n \t  TREE_OPERAND (t, 0) = var;\n \n \t  gimplify_seq_add_stmt (&for_body, gimple_build_assign (decl, var));\n \n-\t  if (simd && TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) == 1)\n+\t  if (ort == ORT_SIMD\n+\t      && TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) == 1)\n \t    {\n \t      c2 = build_omp_clause (input_location, OMP_CLAUSE_LINEAR);\n \t      OMP_CLAUSE_LINEAR_NO_COPYIN (c2) = 1;\n@@ -7396,8 +8138,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t  OMP_CLAUSE_LINEAR_STEP (c2) = OMP_CLAUSE_LINEAR_STEP (c);\n \t}\n \n-      if ((var != decl || TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) > 1)\n-\t  && orig_for_stmt == for_stmt)\n+      if ((var != decl || collapse > 1) && orig_for_stmt == for_stmt)\n \t{\n \t  for (c = OMP_FOR_CLAUSES (for_stmt); c ; c = OMP_CLAUSE_CHAIN (c))\n \t    if (((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n@@ -7407,16 +8148,22 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t     && OMP_CLAUSE_LINEAR_GIMPLE_SEQ (c) == NULL))\n \t\t&& OMP_CLAUSE_DECL (c) == decl)\n \t      {\n-\t\tt = TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), i);\n-\t\tgcc_assert (TREE_CODE (t) == MODIFY_EXPR);\n-\t\tgcc_assert (TREE_OPERAND (t, 0) == var);\n-\t\tt = TREE_OPERAND (t, 1);\n-\t\tgcc_assert (TREE_CODE (t) == PLUS_EXPR\n-\t\t\t    || TREE_CODE (t) == MINUS_EXPR\n-\t\t\t    || TREE_CODE (t) == POINTER_PLUS_EXPR);\n-\t\tgcc_assert (TREE_OPERAND (t, 0) == var);\n-\t\tt = build2 (TREE_CODE (t), TREE_TYPE (decl), decl,\n-\t\t\t    TREE_OPERAND (t, 1));\n+\t\tif (is_doacross && (collapse == 1 || i >= collapse))\n+\t\t  t = var;\n+\t\telse\n+\t\t  {\n+\t\t    t = TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), i);\n+\t\t    gcc_assert (TREE_CODE (t) == MODIFY_EXPR);\n+\t\t    gcc_assert (TREE_OPERAND (t, 0) == var);\n+\t\t    t = TREE_OPERAND (t, 1);\n+\t\t    gcc_assert (TREE_CODE (t) == PLUS_EXPR\n+\t\t\t\t|| TREE_CODE (t) == MINUS_EXPR\n+\t\t\t\t|| TREE_CODE (t) == POINTER_PLUS_EXPR);\n+\t\t    gcc_assert (TREE_OPERAND (t, 0) == var);\n+\t\t    t = build2 (TREE_CODE (t), TREE_TYPE (decl),\n+\t\t\t\tis_doacross ? var : decl,\n+\t\t\t\tTREE_OPERAND (t, 1));\n+\t\t  }\n \t\tgimple_seq *seq;\n \t\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n \t\t  seq = &OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c);\n@@ -7429,22 +8176,48 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \n   BITMAP_FREE (has_decl_expr);\n \n-  gimplify_and_add (OMP_FOR_BODY (orig_for_stmt), &for_body);\n+  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP)\n+    {\n+      push_gimplify_context ();\n+      if (TREE_CODE (OMP_FOR_BODY (orig_for_stmt)) != BIND_EXPR)\n+\t{\n+\t  OMP_FOR_BODY (orig_for_stmt)\n+\t    = build3 (BIND_EXPR, void_type_node, NULL,\n+\t\t      OMP_FOR_BODY (orig_for_stmt), NULL);\n+\t  TREE_SIDE_EFFECTS (OMP_FOR_BODY (orig_for_stmt)) = 1;\n+\t}\n+    }\n+\n+  gimple *g = gimplify_and_return_first (OMP_FOR_BODY (orig_for_stmt),\n+\t\t\t\t\t &for_body);\n+\n+  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP)\n+    {\n+      if (gimple_code (g) == GIMPLE_BIND)\n+\tpop_gimplify_context (g);\n+      else\n+\tpop_gimplify_context (NULL);\n+    }\n \n   if (orig_for_stmt != for_stmt)\n     for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)); i++)\n       {\n \tt = TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), i);\n \tdecl = TREE_OPERAND (t, 0);\n+\tstruct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n+\tif (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP)\n+\t  gimplify_omp_ctxp = ctx->outer_context;\n \tvar = create_tmp_var (TREE_TYPE (decl), get_name (decl));\n+\tgimplify_omp_ctxp = ctx;\n \tomp_add_variable (gimplify_omp_ctxp, var, GOVD_PRIVATE | GOVD_SEEN);\n \tTREE_OPERAND (t, 0) = var;\n \tt = TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), i);\n \tTREE_OPERAND (t, 1) = copy_node (TREE_OPERAND (t, 1));\n \tTREE_OPERAND (TREE_OPERAND (t, 1), 0) = var;\n       }\n \n-  gimplify_adjust_omp_clauses (pre_p, &OMP_FOR_CLAUSES (orig_for_stmt));\n+  gimplify_adjust_omp_clauses (pre_p, &OMP_FOR_CLAUSES (orig_for_stmt),\n+\t\t\t       TREE_CODE (orig_for_stmt));\n \n   int kind;\n   switch (TREE_CODE (orig_for_stmt))\n@@ -7454,6 +8227,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n     case CILK_SIMD: kind = GF_OMP_FOR_KIND_CILKSIMD; break;\n     case CILK_FOR: kind = GF_OMP_FOR_KIND_CILKFOR; break;\n     case OMP_DISTRIBUTE: kind = GF_OMP_FOR_KIND_DISTRIBUTE; break;\n+    case OMP_TASKLOOP: kind = GF_OMP_FOR_KIND_TASKLOOP; break;\n     case OACC_LOOP: kind = GF_OMP_FOR_KIND_OACC_LOOP; break;\n     default:\n       gcc_unreachable ();\n@@ -7488,7 +8262,139 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n       gimple_omp_for_set_incr (gfor, i, TREE_OPERAND (t, 1));\n     }\n \n-  gimplify_seq_add_stmt (pre_p, gfor);\n+  /* OMP_TASKLOOP is gimplified as two GIMPLE_OMP_FOR taskloop\n+     constructs with GIMPLE_OMP_TASK sandwiched in between them.\n+     The outer taskloop stands for computing the number of iterations,\n+     counts for collapsed loops and holding taskloop specific clauses.\n+     The task construct stands for the effect of data sharing on the\n+     explicit task it creates and the inner taskloop stands for expansion\n+     of the static loop inside of the explicit task construct.  */\n+  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP)\n+    {\n+      tree *gfor_clauses_ptr = gimple_omp_for_clauses_ptr (gfor);\n+      tree task_clauses = NULL_TREE;\n+      tree c = *gfor_clauses_ptr;\n+      tree *gtask_clauses_ptr = &task_clauses;\n+      tree outer_for_clauses = NULL_TREE;\n+      tree *gforo_clauses_ptr = &outer_for_clauses;\n+      for (; c; c = OMP_CLAUSE_CHAIN (c))\n+\tswitch (OMP_CLAUSE_CODE (c))\n+\t  {\n+\t  /* These clauses are allowed on task, move them there.  */\n+\t  case OMP_CLAUSE_SHARED:\n+\t  case OMP_CLAUSE_FIRSTPRIVATE:\n+\t  case OMP_CLAUSE_DEFAULT:\n+\t  case OMP_CLAUSE_IF:\n+\t  case OMP_CLAUSE_UNTIED:\n+\t  case OMP_CLAUSE_FINAL:\n+\t  case OMP_CLAUSE_MERGEABLE:\n+\t  case OMP_CLAUSE_PRIORITY:\n+\t    *gtask_clauses_ptr = c;\n+\t    gtask_clauses_ptr = &OMP_CLAUSE_CHAIN (c);\n+\t    break;\n+\t  case OMP_CLAUSE_PRIVATE:\n+\t    if (OMP_CLAUSE_PRIVATE_TASKLOOP_IV (c))\n+\t      {\n+\t\t/* We want private on outer for and firstprivate\n+\t\t   on task.  */\n+\t\t*gtask_clauses_ptr\n+\t\t  = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t      OMP_CLAUSE_FIRSTPRIVATE);\n+\t\tOMP_CLAUSE_DECL (*gtask_clauses_ptr) = OMP_CLAUSE_DECL (c);\n+\t\tlang_hooks.decls.omp_finish_clause (*gtask_clauses_ptr, NULL);\n+\t\tgtask_clauses_ptr = &OMP_CLAUSE_CHAIN (*gtask_clauses_ptr);\n+\t\t*gforo_clauses_ptr = c;\n+\t\tgforo_clauses_ptr = &OMP_CLAUSE_CHAIN (c);\n+\t      }\n+\t    else\n+\t      {\n+\t\t*gtask_clauses_ptr = c;\n+\t\tgtask_clauses_ptr = &OMP_CLAUSE_CHAIN (c);\n+\t      }\n+\t    break;\n+\t  /* These clauses go into outer taskloop clauses.  */\n+\t  case OMP_CLAUSE_GRAINSIZE:\n+\t  case OMP_CLAUSE_NUM_TASKS:\n+\t  case OMP_CLAUSE_NOGROUP:\n+\t    *gforo_clauses_ptr = c;\n+\t    gforo_clauses_ptr = &OMP_CLAUSE_CHAIN (c);\n+\t    break;\n+\t  /* Taskloop clause we duplicate on both taskloops.  */\n+\t  case OMP_CLAUSE_COLLAPSE:\n+\t    *gfor_clauses_ptr = c;\n+\t    gfor_clauses_ptr = &OMP_CLAUSE_CHAIN (c);\n+\t    *gforo_clauses_ptr = copy_node (c);\n+\t    gforo_clauses_ptr = &OMP_CLAUSE_CHAIN (*gforo_clauses_ptr);\n+\t    break;\n+\t  /* For lastprivate, keep the clause on inner taskloop, and add\n+\t     a shared clause on task.  If the same decl is also firstprivate,\n+\t     add also firstprivate clause on the inner taskloop.  */\n+\t  case OMP_CLAUSE_LASTPRIVATE:\n+\t    if (OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV (c))\n+\t      {\n+\t\t/* For taskloop C++ lastprivate IVs, we want:\n+\t\t   1) private on outer taskloop\n+\t\t   2) firstprivate and shared on task\n+\t\t   3) lastprivate on inner taskloop  */\n+\t\t*gtask_clauses_ptr\n+\t\t  = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t      OMP_CLAUSE_FIRSTPRIVATE);\n+\t\tOMP_CLAUSE_DECL (*gtask_clauses_ptr) = OMP_CLAUSE_DECL (c);\n+\t\tlang_hooks.decls.omp_finish_clause (*gtask_clauses_ptr, NULL);\n+\t\tgtask_clauses_ptr = &OMP_CLAUSE_CHAIN (*gtask_clauses_ptr);\n+\t\tOMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (c) = 1;\n+\t\t*gforo_clauses_ptr = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t       OMP_CLAUSE_PRIVATE);\n+\t\tOMP_CLAUSE_DECL (*gforo_clauses_ptr) = OMP_CLAUSE_DECL (c);\n+\t\tOMP_CLAUSE_PRIVATE_TASKLOOP_IV (*gforo_clauses_ptr) = 1;\n+\t\tTREE_TYPE (*gforo_clauses_ptr) = TREE_TYPE (c);\n+\t\tgforo_clauses_ptr = &OMP_CLAUSE_CHAIN (*gforo_clauses_ptr);\n+\t      }\n+\t    *gfor_clauses_ptr = c;\n+\t    gfor_clauses_ptr = &OMP_CLAUSE_CHAIN (c);\n+\t    *gtask_clauses_ptr\n+\t      = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_SHARED);\n+\t    OMP_CLAUSE_DECL (*gtask_clauses_ptr) = OMP_CLAUSE_DECL (c);\n+\t    if (OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (c))\n+\t      OMP_CLAUSE_SHARED_FIRSTPRIVATE (*gtask_clauses_ptr) = 1;\n+\t    gtask_clauses_ptr\n+\t      = &OMP_CLAUSE_CHAIN (*gtask_clauses_ptr);\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+      *gfor_clauses_ptr = NULL_TREE;\n+      *gtask_clauses_ptr = NULL_TREE;\n+      *gforo_clauses_ptr = NULL_TREE;\n+      g = gimple_build_bind (NULL_TREE, gfor, NULL_TREE);\n+      g = gimple_build_omp_task (g, task_clauses, NULL_TREE, NULL_TREE,\n+\t\t\t\t NULL_TREE, NULL_TREE, NULL_TREE);\n+      gimple_omp_task_set_taskloop_p (g, true);\n+      g = gimple_build_bind (NULL_TREE, g, NULL_TREE);\n+      gomp_for *gforo\n+\t= gimple_build_omp_for (g, GF_OMP_FOR_KIND_TASKLOOP, outer_for_clauses,\n+\t\t\t\tgimple_omp_for_collapse (gfor),\n+\t\t\t\tgimple_omp_for_pre_body (gfor));\n+      gimple_omp_for_set_pre_body (gfor, NULL);\n+      gimple_omp_for_set_combined_p (gforo, true);\n+      gimple_omp_for_set_combined_into_p (gfor, true);\n+      for (i = 0; i < (int) gimple_omp_for_collapse (gfor); i++)\n+\t{\n+\t  t = unshare_expr (gimple_omp_for_index (gfor, i));\n+\t  gimple_omp_for_set_index (gforo, i, t);\n+\t  t = unshare_expr (gimple_omp_for_initial (gfor, i));\n+\t  gimple_omp_for_set_initial (gforo, i, t);\n+\t  gimple_omp_for_set_cond (gforo, i,\n+\t\t\t\t   gimple_omp_for_cond (gfor, i));\n+\t  t = unshare_expr (gimple_omp_for_final (gfor, i));\n+\t  gimple_omp_for_set_final (gforo, i, t);\n+\t  t = unshare_expr (gimple_omp_for_incr (gfor, i));\n+\t  gimple_omp_for_set_incr (gforo, i, t);\n+\t}\n+      gimplify_seq_add_stmt (pre_p, gforo);\n+    }\n+  else\n+    gimplify_seq_add_stmt (pre_p, gfor);\n   if (ret != GS_ALL_DONE)\n     return GS_ERROR;\n   *expr_p = NULL_TREE;\n@@ -7511,9 +8417,11 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n     case OMP_SINGLE:\n       ort = ORT_WORKSHARE;\n       break;\n+    case OMP_TARGET:\n+      ort = OMP_TARGET_COMBINED (expr) ? ORT_COMBINED_TARGET : ORT_TARGET;\n+      break;\n     case OACC_KERNELS:\n     case OACC_PARALLEL:\n-    case OMP_TARGET:\n       ort = ORT_TARGET;\n       break;\n     case OACC_DATA:\n@@ -7526,8 +8434,9 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n     default:\n       gcc_unreachable ();\n     }\n-  gimplify_scan_omp_clauses (&OMP_CLAUSES (expr), pre_p, ort);\n-  if (ort == ORT_TARGET || ort == ORT_TARGET_DATA)\n+  gimplify_scan_omp_clauses (&OMP_CLAUSES (expr), pre_p, ort,\n+\t\t\t     TREE_CODE (expr));\n+  if ((ort & (ORT_TARGET | ORT_TARGET_DATA)) != 0)\n     {\n       push_gimplify_context ();\n       gimple *g = gimplify_and_return_first (OMP_BODY (expr), &body);\n@@ -7560,7 +8469,7 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n     }\n   else\n     gimplify_and_add (OMP_BODY (expr), &body);\n-  gimplify_adjust_omp_clauses (pre_p, &OMP_CLAUSES (expr));\n+  gimplify_adjust_omp_clauses (pre_p, &OMP_CLAUSES (expr), TREE_CODE (expr));\n \n   switch (TREE_CODE (expr))\n     {\n@@ -7625,12 +8534,19 @@ gimplify_omp_target_update (tree *expr_p, gimple_seq *pre_p)\n     case OMP_TARGET_UPDATE:\n       kind = GF_OMP_TARGET_KIND_UPDATE;\n       break;\n+    case OMP_TARGET_ENTER_DATA:\n+      kind = GF_OMP_TARGET_KIND_ENTER_DATA;\n+      break;\n+    case OMP_TARGET_EXIT_DATA:\n+      kind = GF_OMP_TARGET_KIND_EXIT_DATA;\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n   gimplify_scan_omp_clauses (&OMP_STANDALONE_CLAUSES (expr), pre_p,\n-\t\t\t     ORT_WORKSHARE);\n-  gimplify_adjust_omp_clauses (pre_p, &OMP_STANDALONE_CLAUSES (expr));\n+\t\t\t     ORT_WORKSHARE, TREE_CODE (expr));\n+  gimplify_adjust_omp_clauses (pre_p, &OMP_STANDALONE_CLAUSES (expr),\n+\t\t\t       TREE_CODE (expr));\n   stmt = gimple_build_omp_target (NULL, kind, OMP_STANDALONE_CLAUSES (expr));\n \n   gimplify_seq_add_stmt (pre_p, stmt);\n@@ -7845,6 +8761,93 @@ gimplify_transaction (tree *expr_p, gimple_seq *pre_p)\n   return GS_ALL_DONE;\n }\n \n+/* Gimplify an OMP_ORDERED construct.  EXPR is the tree version.  BODY\n+   is the OMP_BODY of the original EXPR (which has already been\n+   gimplified so it's not present in the EXPR).\n+\n+   Return the gimplified GIMPLE_OMP_ORDERED tuple.  */\n+\n+static gimple *\n+gimplify_omp_ordered (tree expr, gimple_seq body)\n+{\n+  tree c, decls;\n+  int failures = 0;\n+  unsigned int i;\n+  tree source_c = NULL_TREE;\n+  tree sink_c = NULL_TREE;\n+\n+  if (gimplify_omp_ctxp)\n+    for (c = OMP_ORDERED_CLAUSES (expr); c; c = OMP_CLAUSE_CHAIN (c))\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t  && gimplify_omp_ctxp->loop_iter_var.is_empty ()\n+\t  && (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK\n+\t      || OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SOURCE))\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"%<depend%> clause must be closely nested \"\n+\t\t    \"inside a loop with %<ordered%> clause with \"\n+\t\t    \"a parameter\");\n+\t  failures++;\n+\t}\n+      else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t       && OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK)\n+\t{\n+\t  bool fail = false;\n+\t  for (decls = OMP_CLAUSE_DECL (c), i = 0;\n+\t       decls && TREE_CODE (decls) == TREE_LIST;\n+\t       decls = TREE_CHAIN (decls), ++i)\n+\t    if (i >= gimplify_omp_ctxp->loop_iter_var.length () / 2)\n+\t      continue;\n+\t    else if (TREE_VALUE (decls)\n+\t\t     != gimplify_omp_ctxp->loop_iter_var[2 * i])\n+\t      {\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"variable %qE is not an iteration \"\n+\t\t\t  \"of outermost loop %d, expected %qE\",\n+\t\t\t  TREE_VALUE (decls), i + 1,\n+\t\t\t  gimplify_omp_ctxp->loop_iter_var[2 * i]);\n+\t\tfail = true;\n+\t\tfailures++;\n+\t      }\n+\t    else\n+\t      TREE_VALUE (decls)\n+\t\t= gimplify_omp_ctxp->loop_iter_var[2 * i + 1];\n+\t  if (!fail && i != gimplify_omp_ctxp->loop_iter_var.length () / 2)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"number of variables in %<depend(sink)%> \"\n+\t\t\t\"clause does not match number of \"\n+\t\t\t\"iteration variables\");\n+\t      failures++;\n+\t    }\n+\t  sink_c = c;\n+\t}\n+      else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t       && OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SOURCE)\n+\t{\n+\t  if (source_c)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"more than one %<depend(source)%> clause on an \"\n+\t\t\t\"%<ordered%> construct\");\n+\t      failures++;\n+\t    }\n+\t  else\n+\t    source_c = c;\n+\t}\n+  if (source_c && sink_c)\n+    {\n+      error_at (OMP_CLAUSE_LOCATION (source_c),\n+\t\t\"%<depend(source)%> clause specified together with \"\n+\t\t\"%<depend(sink:)%> clauses on the same construct\");\n+      failures++;\n+    }\n+\n+  if (failures)\n+    return gimple_build_nop ();\n+  return gimple_build_omp_ordered (body, OMP_ORDERED_CLAUSES (expr));\n+}\n+\n /* Convert the GENERIC expression tree *EXPR_P to GIMPLE.  If the\n    expression produces a value to be used as an operand inside a GIMPLE\n    statement, the value will be stored back in *EXPR_P.  This value will\n@@ -8574,6 +9577,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \tcase CILK_SIMD:\n \tcase CILK_FOR:\n \tcase OMP_DISTRIBUTE:\n+\tcase OMP_TASKLOOP:\n \tcase OACC_LOOP:\n \t  ret = gimplify_omp_for (expr_p, pre_p);\n \t  break;\n@@ -8619,6 +9623,8 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \tcase OACC_EXIT_DATA:\n \tcase OACC_UPDATE:\n \tcase OMP_TARGET_UPDATE:\n+\tcase OMP_TARGET_ENTER_DATA:\n+\tcase OMP_TARGET_EXIT_DATA:\n \t  gimplify_omp_target_update (expr_p, pre_p);\n \t  ret = GS_ALL_DONE;\n \t  break;\n@@ -8655,11 +9661,17 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\t}\n \t\tbreak;\n \t      case OMP_ORDERED:\n-\t\tg = gimple_build_omp_ordered (body);\n+\t\tg = gimplify_omp_ordered (*expr_p, body);\n \t\tbreak;\n \t      case OMP_CRITICAL:\n+\t\tgimplify_scan_omp_clauses (&OMP_CRITICAL_CLAUSES (*expr_p),\n+\t\t\t\t\t   pre_p, ORT_WORKSHARE, OMP_CRITICAL);\n+\t\tgimplify_adjust_omp_clauses (pre_p,\n+\t\t\t\t\t     &OMP_CRITICAL_CLAUSES (*expr_p),\n+\t\t\t\t\t     OMP_CRITICAL);\n \t\tg = gimple_build_omp_critical (body,\n-\t\t    \t\t\t       OMP_CRITICAL_NAME (*expr_p));\n+\t\t    \t\t\t       OMP_CRITICAL_NAME (*expr_p),\n+\t\t    \t\t\t       OMP_CRITICAL_CLAUSES (*expr_p));\n \t\tbreak;\n \t      default:\n \t\tgcc_unreachable ();"}, {"sha": "f12d3aff96a9dbaf41c1edceb3c6b393fed65d29", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -175,6 +175,22 @@ expand_GOMP_SIMD_LAST_LANE (gcall *)\n   gcc_unreachable ();\n }\n \n+/* This should get expanded in adjust_simduid_builtins.  */\n+\n+static void\n+expand_GOMP_SIMD_ORDERED_START (gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n+/* This should get expanded in adjust_simduid_builtins.  */\n+\n+static void\n+expand_GOMP_SIMD_ORDERED_END (gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n /* This should get expanded in the sanopt pass.  */\n \n static void"}, {"sha": "305cf1b858cb243dd77212b23a0cae57a9fe1727", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -44,6 +44,8 @@ DEF_INTERNAL_FN (STORE_LANES, ECF_CONST | ECF_LEAF, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_LANE, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_VF, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_LAST_LANE, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMD_ORDERED_START, ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMD_ORDERED_END, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (LOOP_VECTORIZED, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (MASK_LOAD, ECF_PURE | ECF_LEAF, NULL)\n DEF_INTERNAL_FN (MASK_STORE, ECF_LEAF, NULL)"}, {"sha": "4922bc0511be48e5d28e1109612e2b75eed3b7ce", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1,3 +1,10 @@\n+2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* jit-builtins.c (DEF_FUNCTION_TYPE_9, DEF_FUNCTION_TYPE_10,\n+\tDEF_FUNCTION_TYPE_11): Define.\n+\t* jit-builtins.h (DEF_FUNCTION_TYPE_9, DEF_FUNCTION_TYPE_10,\n+\tDEF_FUNCTION_TYPE_11): Define.\n+\n 2015-09-30  Thomas Schwinge  <thomas@codesourcery.com>\n \t    Ulrich Drepper  <drepper@gmail.com>\n "}, {"sha": "e67c0f86ceabafbb64f4ac69196be412e7450b3d", "filename": "gcc/jit/jit-builtins.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fjit%2Fjit-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fjit%2Fjit-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-builtins.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -306,6 +306,20 @@ builtins_manager::make_type (enum jit_builtin_type type_id)\n \t\t\t    ARG6, ARG7, ARG8)\t\t\t\t\\\n       case ENUM: return make_fn_type (ENUM, RETURN, 0, 8, ARG1, ARG2, ARG3, \\\n \t\t\t\t      ARG4, ARG5, ARG6, ARG7, ARG8);\n+#define DEF_FUNCTION_TYPE_9(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8, ARG9)\t\t\t\\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 0, 9, ARG1, ARG2, ARG3, \\\n+\t\t\t\t      ARG4, ARG5, ARG6, ARG7, ARG8, ARG9);\n+#define DEF_FUNCTION_TYPE_10(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10)\t\t \\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 0, 10, ARG1, ARG2, ARG3, \\\n+\t\t\t\t      ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, \\\n+\t\t\t\t      ARG10);\n+#define DEF_FUNCTION_TYPE_11(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)\t \\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 0, 11, ARG1, ARG2, ARG3, \\\n+\t\t\t\t      ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, \\\n+\t\t\t\t      ARG10, ARG11);\n #define DEF_FUNCTION_TYPE_VAR_0(ENUM, RETURN) \\\n       case ENUM: return make_fn_type (ENUM, RETURN, 1, 0);\n #define DEF_FUNCTION_TYPE_VAR_1(ENUM, RETURN, ARG1) \\\n@@ -343,6 +357,9 @@ builtins_manager::make_type (enum jit_builtin_type type_id)\n #undef DEF_FUNCTION_TYPE_6\n #undef DEF_FUNCTION_TYPE_7\n #undef DEF_FUNCTION_TYPE_8\n+#undef DEF_FUNCTION_TYPE_9\n+#undef DEF_FUNCTION_TYPE_10\n+#undef DEF_FUNCTION_TYPE_11\n #undef DEF_FUNCTION_TYPE_VAR_0\n #undef DEF_FUNCTION_TYPE_VAR_1\n #undef DEF_FUNCTION_TYPE_VAR_2"}, {"sha": "97e279e328b3f44ae3a5e4135d91b92d97f7794c", "filename": "gcc/jit/jit-builtins.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fjit%2Fjit-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fjit%2Fjit-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-builtins.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -43,6 +43,12 @@ enum jit_builtin_type\n \t\t\t    ARG6, ARG7) NAME,\n #define DEF_FUNCTION_TYPE_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n \t\t\t    ARG6, ARG7, ARG8) NAME,\n+#define DEF_FUNCTION_TYPE_9(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8, ARG9) NAME,\n+#define DEF_FUNCTION_TYPE_10(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10) NAME,\n+#define DEF_FUNCTION_TYPE_11(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) NAME,\n #define DEF_FUNCTION_TYPE_VAR_0(NAME, RETURN) NAME,\n #define DEF_FUNCTION_TYPE_VAR_1(NAME, RETURN, ARG1) NAME,\n #define DEF_FUNCTION_TYPE_VAR_2(NAME, RETURN, ARG1, ARG2) NAME,\n@@ -66,6 +72,9 @@ enum jit_builtin_type\n #undef DEF_FUNCTION_TYPE_6\n #undef DEF_FUNCTION_TYPE_7\n #undef DEF_FUNCTION_TYPE_8\n+#undef DEF_FUNCTION_TYPE_9\n+#undef DEF_FUNCTION_TYPE_10\n+#undef DEF_FUNCTION_TYPE_11\n #undef DEF_FUNCTION_TYPE_VAR_0\n #undef DEF_FUNCTION_TYPE_VAR_1\n #undef DEF_FUNCTION_TYPE_VAR_2"}, {"sha": "79cd853241a6e67d0a9078737964ce9b272bd4f3", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1,3 +1,8 @@\n+2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* lto-lang.c (DEF_FUNCTION_TYPE_9, DEF_FUNCTION_TYPE_10,\n+\tDEF_FUNCTION_TYPE_11): Define.\n+\n 2015-10-10  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto.c (hash_canonical_type): Honor"}, {"sha": "94b54dcb397ac09181d7f2315e851ee1493f9a16", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -153,6 +153,12 @@ enum lto_builtin_type\n \t\t\t    ARG6, ARG7) NAME,\n #define DEF_FUNCTION_TYPE_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n \t\t\t    ARG6, ARG7, ARG8) NAME,\n+#define DEF_FUNCTION_TYPE_9(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8, ARG9) NAME,\n+#define DEF_FUNCTION_TYPE_10(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10) NAME,\n+#define DEF_FUNCTION_TYPE_11(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) NAME,\n #define DEF_FUNCTION_TYPE_VAR_0(NAME, RETURN) NAME,\n #define DEF_FUNCTION_TYPE_VAR_1(NAME, RETURN, ARG1) NAME,\n #define DEF_FUNCTION_TYPE_VAR_2(NAME, RETURN, ARG1, ARG2) NAME,\n@@ -176,6 +182,9 @@ enum lto_builtin_type\n #undef DEF_FUNCTION_TYPE_6\n #undef DEF_FUNCTION_TYPE_7\n #undef DEF_FUNCTION_TYPE_8\n+#undef DEF_FUNCTION_TYPE_9\n+#undef DEF_FUNCTION_TYPE_10\n+#undef DEF_FUNCTION_TYPE_11\n #undef DEF_FUNCTION_TYPE_VAR_0\n #undef DEF_FUNCTION_TYPE_VAR_1\n #undef DEF_FUNCTION_TYPE_VAR_2\n@@ -656,6 +665,18 @@ lto_define_builtins (tree va_list_ref_type_node ATTRIBUTE_UNUSED,\n \t\t\t    ARG6, ARG7, ARG8)\t\t\t\t\\\n   def_fn_type (ENUM, RETURN, 0, 8, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n \t       ARG7, ARG8);\n+#define DEF_FUNCTION_TYPE_9(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8, ARG9)\t\t\t\\\n+  def_fn_type (ENUM, RETURN, 0, 9, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n+\t       ARG7, ARG8, ARG9);\n+#define DEF_FUNCTION_TYPE_10(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10)\t\t \\\n+  def_fn_type (ENUM, RETURN, 0, 10, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t \\\n+\t       ARG7, ARG8, ARG9, ARG10);\n+#define DEF_FUNCTION_TYPE_11(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)\t \\\n+  def_fn_type (ENUM, RETURN, 0, 11, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t \\\n+\t       ARG7, ARG8, ARG9, ARG10, ARG11);\n #define DEF_FUNCTION_TYPE_VAR_0(ENUM, RETURN) \\\n   def_fn_type (ENUM, RETURN, 1, 0);\n #define DEF_FUNCTION_TYPE_VAR_1(ENUM, RETURN, ARG1) \\\n@@ -689,6 +710,9 @@ lto_define_builtins (tree va_list_ref_type_node ATTRIBUTE_UNUSED,\n #undef DEF_FUNCTION_TYPE_6\n #undef DEF_FUNCTION_TYPE_7\n #undef DEF_FUNCTION_TYPE_8\n+#undef DEF_FUNCTION_TYPE_9\n+#undef DEF_FUNCTION_TYPE_10\n+#undef DEF_FUNCTION_TYPE_11\n #undef DEF_FUNCTION_TYPE_VAR_0\n #undef DEF_FUNCTION_TYPE_VAR_1\n #undef DEF_FUNCTION_TYPE_VAR_2"}, {"sha": "ea9cf0d13723ced8bf374c1258cc4f17bce93a13", "filename": "gcc/omp-builtins.def", "status": "modified", "additions": 57, "deletions": 7, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fomp-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fomp-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-builtins.def?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -129,6 +129,22 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ORDERED_RUNTIME_START,\n \t\t  \"GOMP_loop_ordered_runtime_start\",\n \t\t  BT_FN_BOOL_LONG_LONG_LONG_LONGPTR_LONGPTR,\n \t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_DOACROSS_STATIC_START,\n+\t\t  \"GOMP_loop_doacross_static_start\",\n+\t\t  BT_FN_BOOL_UINT_LONGPTR_LONG_LONGPTR_LONGPTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_DOACROSS_DYNAMIC_START,\n+\t\t  \"GOMP_loop_doacross_dynamic_start\",\n+\t\t  BT_FN_BOOL_UINT_LONGPTR_LONG_LONGPTR_LONGPTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_DOACROSS_GUIDED_START,\n+\t\t  \"GOMP_loop_doacross_guided_start\",\n+\t\t  BT_FN_BOOL_UINT_LONGPTR_LONG_LONGPTR_LONGPTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_DOACROSS_RUNTIME_START,\n+\t\t  \"GOMP_loop_doacross_runtime_start\",\n+\t\t  BT_FN_BOOL_UINT_LONGPTR_LONGPTR_LONGPTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_STATIC_NEXT, \"GOMP_loop_static_next\",\n \t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_DYNAMIC_NEXT, \"GOMP_loop_dynamic_next\",\n@@ -181,6 +197,22 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_ORDERED_RUNTIME_START,\n \t\t  \"GOMP_loop_ull_ordered_runtime_start\",\n \t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n \t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_DOACROSS_STATIC_START,\n+\t\t  \"GOMP_loop_ull_doacross_static_start\",\n+\t\t  BT_FN_BOOL_UINT_ULLPTR_ULL_ULLPTR_ULLPTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_DOACROSS_DYNAMIC_START,\n+\t\t  \"GOMP_loop_ull_doacross_dynamic_start\",\n+\t\t  BT_FN_BOOL_UINT_ULLPTR_ULL_ULLPTR_ULLPTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_DOACROSS_GUIDED_START,\n+\t\t  \"GOMP_loop_ull_doacross_guided_start\",\n+\t\t  BT_FN_BOOL_UINT_ULLPTR_ULL_ULLPTR_ULLPTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_DOACROSS_RUNTIME_START,\n+\t\t  \"GOMP_loop_ull_doacross_runtime_start\",\n+\t\t  BT_FN_BOOL_UINT_ULLPTR_ULLPTR_ULLPTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_STATIC_NEXT, \"GOMP_loop_ull_static_next\",\n \t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_DYNAMIC_NEXT, \"GOMP_loop_ull_dynamic_next\",\n@@ -230,10 +262,24 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_ORDERED_START, \"GOMP_ordered_start\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_ORDERED_END, \"GOMP_ordered_end\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_DOACROSS_POST, \"GOMP_doacross_post\",\n+\t\t  BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_DOACROSS_WAIT, \"GOMP_doacross_wait\",\n+\t\t  BT_FN_VOID_LONG_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_DOACROSS_ULL_POST, \"GOMP_doacross_ull_post\",\n+\t\t  BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_DOACROSS_ULL_WAIT, \"GOMP_doacross_ull_wait\",\n+\t\t  BT_FN_VOID_ULL_VAR, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL, \"GOMP_parallel\",\n \t\t  BT_FN_VOID_OMPFN_PTR_UINT_UINT, ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASK, \"GOMP_task\",\n-\t\t  BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR,\n+\t\t  BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKLOOP, \"GOMP_taskloop\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_LONG_LONG_LONG,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKLOOP_ULL, \"GOMP_taskloop_ull\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_ULL_ULL_ULL,\n \t\t  ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_START, \"GOMP_sections_start\",\n \t\t  BT_FN_UINT_UINT, ATTR_NOTHROW_LEAF_LIST)\n@@ -256,14 +302,18 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SINGLE_COPY_START, \"GOMP_single_copy_start\",\n \t\t  BT_FN_PTR, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SINGLE_COPY_END, \"GOMP_single_copy_end\",\n \t\t  BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET, \"GOMP_target\",\n-\t\t  BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR,\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET, \"GOMP_target_41\",\n+\t\t  BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR,\n \t\t  ATTR_NOTHROW_LIST)\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET_DATA, \"GOMP_target_data\",\n-\t\t  BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET_DATA, \"GOMP_target_data_41\",\n+\t\t  BT_FN_VOID_INT_SIZE_PTR_PTR_PTR, ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET_END_DATA, \"GOMP_target_end_data\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET_UPDATE, \"GOMP_target_update\",\n-\t\t  BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET_UPDATE, \"GOMP_target_update_41\",\n+\t\t  BT_FN_VOID_INT_SIZE_PTR_PTR_PTR_UINT_PTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET_ENTER_EXIT_DATA,\n+\t\t  \"GOMP_target_enter_exit_data\",\n+\t\t  BT_FN_VOID_INT_SIZE_PTR_PTR_PTR_UINT_PTR, ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TEAMS, \"GOMP_teams\",\n \t\t  BT_FN_VOID_UINT_UINT, ATTR_NOTHROW_LIST)"}, {"sha": "b444864f0d1992fe95d28c98f9ea99a6901c5308", "filename": "gcc/omp-low.c", "status": "modified", "additions": 3837, "deletions": 440, "changes": 4277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "2fb2028f6cf45faa9642f6a56b5e507de1228c60", "filename": "gcc/omp-low.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fomp-low.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fomp-low.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -29,6 +29,7 @@ extern tree omp_reduction_init_op (location_t, enum tree_code, tree);\n extern tree omp_reduction_init (tree, tree);\n extern bool make_gimple_omp_edges (basic_block, struct omp_region **, int *);\n extern void omp_finish_file (void);\n+extern tree omp_member_access_dummy_var (tree);\n extern tree get_oacc_fn_attrib (tree);\n \n extern GTY(()) vec<tree, va_gc> *offload_funcs;"}, {"sha": "dc3f44c122c0a8d340c779693bf1159b0af36b55", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -341,6 +341,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_tm_memopt);\n       NEXT_PASS (pass_tm_edges);\n   POP_INSERT_PASSES ()\n+  NEXT_PASS (pass_simduid_cleanup);\n   NEXT_PASS (pass_vtable_verify);\n   NEXT_PASS (pass_lower_vaarg);\n   NEXT_PASS (pass_lower_vector);"}, {"sha": "c4fd225d4a05cad166fe0f2dee2c86d09868f700", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1,3 +1,78 @@\n+2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* c-c++-common/gomp/cancel-1.c (f2): Add map clause to target data.\n+\t* c-c++-common/gomp/clauses-1.c: New test.\n+\t* c-c++-common/gomp/clauses-2.c: New test.\n+\t* c-c++-common/gomp/clauses-3.c: New test.\n+\t* c-c++-common/gomp/clauses-4.c: New test.\n+\t* c-c++-common/gomp/declare-target-1.c: New test.\n+\t* c-c++-common/gomp/declare-target-2.c: New test.\n+\t* c-c++-common/gomp/depend-3.c: New test.\n+\t* c-c++-common/gomp/depend-4.c: New test.\n+\t* c-c++-common/gomp/doacross-1.c: New test.\n+\t* c-c++-common/gomp/if-1.c: New test.\n+\t* c-c++-common/gomp/if-2.c: New test.\n+\t* c-c++-common/gomp/linear-1.c: New test.\n+\t* c-c++-common/gomp/map-2.c: New test.\n+\t* c-c++-common/gomp/map-3.c: New test.\n+\t* c-c++-common/gomp/nesting-1.c (f_omp_parallel,\n+\tf_omp_target_data): Add map clause to target data.\n+\t* c-c++-common/gomp/nesting-warn-1.c (f_omp_target): Likewise.\n+\t* c-c++-common/gomp/ordered-1.c: New test.\n+\t* c-c++-common/gomp/ordered-2.c: New test.\n+\t* c-c++-common/gomp/ordered-3.c: New test.\n+\t* c-c++-common/gomp/pr61486-1.c (foo): Remove linear clause\n+\ton non-iterator.\n+\t* c-c++-common/gomp/pr61486-2.c (test, test2): Remove ordered\n+\tclause and ordered construct where no longer allowed.\n+\t* c-c++-common/gomp/priority-1.c: New test.\n+\t* c-c++-common/gomp/reduction-1.c: New test.\n+\t* c-c++-common/gomp/schedule-simd-1.c: New test.\n+\t* c-c++-common/gomp/sink-1.c: New test.\n+\t* c-c++-common/gomp/sink-2.c: New test.\n+\t* c-c++-common/gomp/sink-3.c: New test.\n+\t* c-c++-common/gomp/sink-4.c: New test.\n+\t* c-c++-common/gomp/udr-1.c: New test.\n+\t* c-c++-common/taskloop-1.c: New test.\n+\t* c-c++-common/cpp/openmp-define-3.c: Adjust for the new\n+\tvalue of _OPENMP macro.\n+\t* c-c++-common/cilk-plus/PS/body.c (foo): Adjust expected diagnostics.\n+\t* c-c++-common/goacc-gomp/nesting-fail-1.c (f_acc_parallel,\n+\tf_acc_kernels, f_acc_data, f_acc_loop): Add map clause to target data.\n+\t* gcc.dg/gomp/clause-1.c:\n+\t* gcc.dg/gomp/reduction-1.c: New test.\n+\t* gcc.dg/gomp/sink-fold-1.c: New test.\n+\t* gcc.dg/gomp/sink-fold-2.c: New test.\n+\t* gcc.dg/gomp/sink-fold-3.c: New test.\n+\t* gcc.dg/vect/vect-simd-clone-15.c: New test.\n+\t* g++.dg/gomp/clause-1.C (T::test): Remove dg-error on privatization\n+\tof non-static data members.\n+\t* g++.dg/gomp/clause-3.C (foo): Remove one dg-error directive.\n+\tAdd some linear clause tests.\n+\t* g++.dg/gomp/declare-simd-3.C: New test.\n+\t* g++.dg/gomp/linear-1.C: New test.\n+\t* g++.dg/gomp/member-1.C: New test.\n+\t* g++.dg/gomp/member-2.C: New test.\n+\t* g++.dg/gomp/pr66571-2.C: New test.\n+\t* g++.dg/gomp/pr67504.C (foo): Add test for ordered clause with\n+\tdependent argument.\n+\t* g++.dg/gomp/pr67522.C (foo): Add test for invalid array section\n+\tin reduction clause.\n+\t* g++.dg/gomp/reference-1.C: New test.\n+\t* g++.dg/gomp/sink-1.C: New test.\n+\t* g++.dg/gomp/sink-2.C: New test.\n+\t* g++.dg/gomp/sink-3.C: New test.\n+\t* g++.dg/gomp/task-1.C: Remove both dg-error directives.\n+\t* g++.dg/gomp/this-1.C: New test.\n+\t* g++.dg/gomp/this-2.C: New test.\n+\t* g++.dg/vect/simd-clone-2.cc: New test.\n+\t* g++.dg/vect/simd-clone-2.h: New test.\n+\t* g++.dg/vect/simd-clone-3.cc: New test.\n+\t* g++.dg/vect/simd-clone-4.cc: New test.\n+\t* g++.dg/vect/simd-clone-4.h: New test.\n+\t* g++.dg/vect/simd-clone-5.cc: New test.\n+\n 2015-10-13  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* gcc/testsuite/gcc.target/aarch64/table-intrinsics.c: Fix regexp"}, {"sha": "ed85a7a65ebb61133eb91f1b42cbcf914f26b7ad", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/body.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fbody.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fbody.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fbody.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -27,7 +27,7 @@ void foo()\n #pragma simd\n   for (int i=0; i < 1000; ++i)\n     {\n-#pragma omp for /* { dg-error \"OpenMP constructs may not\" } */\n+#pragma omp for /* { dg-error \"OpenMP constructs other than\" } */\n       for (j=0; j < 1000; ++j)\n \ta[i] = b[i];\n     }"}, {"sha": "ef283d4e7ce6a9551a2bd2fd39bbe0ae12ba1e46", "filename": "gcc/testsuite/c-c++-common/cpp/openmp-define-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fopenmp-define-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fopenmp-define-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fopenmp-define-3.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -6,6 +6,6 @@\n # error _OPENMP not defined\n #endif\n \n-#if _OPENMP != 201307\n+#if _OPENMP != 201511\n # error _OPENMP defined to wrong value\n #endif"}, {"sha": "ac614e7d646f61f109a9f7bec93cad11af668c88", "filename": "gcc/testsuite/c-c++-common/goacc-gomp/nesting-fail-1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-fail-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-fail-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-fail-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -230,7 +230,7 @@ f_acc_parallel (void)\n   {\n #pragma omp target /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n     ;\n-#pragma omp target data /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+#pragma omp target data map(i) /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n     ;\n #pragma omp target update to(i) /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n   }\n@@ -300,7 +300,7 @@ f_acc_kernels (void)\n   {\n #pragma omp target /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n     ;\n-#pragma omp target data /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+#pragma omp target data map(i) /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n     ;\n #pragma omp target update to(i) /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n   }\n@@ -370,7 +370,7 @@ f_acc_data (void)\n   {\n #pragma omp target /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n     ;\n-#pragma omp target data /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+#pragma omp target data map(i) /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n     ;\n #pragma omp target update to(i) /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n   }\n@@ -450,7 +450,7 @@ f_acc_loop (void)\n     {\n #pragma omp target /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n       ;\n-#pragma omp target data /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+#pragma omp target data map(i) /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n       ;\n #pragma omp target update to(i) /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n     }"}, {"sha": "13de881d049a8c608930dbdd73020c2732bb4197", "filename": "gcc/testsuite/c-c++-common/gomp/cancel-1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcancel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcancel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcancel-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -17,7 +17,7 @@ f1 (void)\n void\n f2 (void)\n {\n-  int i;\n+  int i, j = 0;\n   #pragma omp parallel\n   {\n     #pragma omp cancel parallel\n@@ -132,7 +132,7 @@ f2 (void)\n \t#pragma omp cancellation point taskgroup/* { dg-error \"not closely nested inside\" } */\n       }\n     }\n-    #pragma omp target data\n+    #pragma omp target data map(j)\n     {\n       #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n       #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n@@ -155,7 +155,7 @@ f2 (void)\n       #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n     }\n   }\n-  #pragma omp target data\n+  #pragma omp target data map(j)\n   {\n     #pragma omp cancel parallel\t\t\t/* { dg-error \"not closely nested inside\" } */\n     #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n@@ -214,7 +214,7 @@ f2 (void)\n     }\n   #pragma omp for\n   for (i = 0; i < 10; i++)\n-    #pragma omp target data\n+    #pragma omp target data map(j)\n     {\n       #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n       #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n@@ -241,7 +241,7 @@ f2 (void)\n   #pragma omp for ordered\n   for (i = 0; i < 10; i++)\n     #pragma omp ordered\n-      #pragma omp target data\n+      #pragma omp target data map(j)\n       {\n \t#pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n \t#pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n@@ -292,7 +292,7 @@ f2 (void)\n   }\n   #pragma omp sections\n   {\n-    #pragma omp target data\n+    #pragma omp target data map(j)\n     {\n       #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n       #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n@@ -304,7 +304,7 @@ f2 (void)\n       #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n     }\n     #pragma omp section\n-    #pragma omp target data\n+    #pragma omp target data map(j)\n     {\n       #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n       #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */"}, {"sha": "2d1c352a3f29aec16dbf1371b79c79b2d1660d3a", "filename": "gcc/testsuite/c-c++-common/gomp/clauses-1.c", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,162 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+/* { dg-additional-options \"-std=c99\" { target c } } */\n+\n+int t;\n+#pragma omp threadprivate (t)\n+\n+#pragma omp declare target\n+int f, l, ll, r;\n+\n+void\n+foo (int d, int m, int i1, int i2, int p, int *idp, int s,\n+     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q)\n+{\n+  #pragma omp distribute parallel for \\\n+    private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) schedule(static, 4)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp distribute parallel for simd \\\n+    private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) schedule(static, 4) \\\n+    safelen(8) simdlen(4) aligned(q: 32)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp distribute simd \\\n+    private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n+    safelen(8) simdlen(4) aligned(q: 32) reduction(+:r)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+}\n+#pragma omp end declare target\n+\n+void\n+bar (int d, int m, int i1, int i2, int p, int *idp, int s,\n+     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q)\n+{\n+  #pragma omp for simd \\\n+    private (p) firstprivate (f) lastprivate (l) linear (ll:1) reduction(+:r) schedule(static, 4) collapse(1) nowait \\\n+    safelen(8) simdlen(4) aligned(q: 32)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel for \\\n+    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel for simd \\\n+    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) \\\n+    safelen(8) simdlen(4) aligned(q: 32)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel sections \\\n+    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l)\n+  {\n+    #pragma omp section\n+    {}\n+    #pragma omp section\n+    {}\n+  }\n+  #pragma omp target parallel \\\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    ;\n+  #pragma omp target parallel for \\\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target parallel for simd \\\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) \\\n+    safelen(8) simdlen(4) aligned(q: 32)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target teams \\\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n+    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl)\n+    ;\n+  #pragma omp target teams distribute \\\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n+    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n+    collapse(1) dist_schedule(static, 16)\n+  for (int i = 0; i < 64; i++)\n+    ;\n+  #pragma omp target teams distribute parallel for \\\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n+    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n+    collapse(1) dist_schedule(static, 16) \\\n+    if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) schedule(static, 4)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target teams distribute parallel for simd \\\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n+    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n+    collapse(1) dist_schedule(static, 16) \\\n+    if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) schedule(static, 4) \\\n+    safelen(8) simdlen(4) aligned(q: 32)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target teams distribute simd \\\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n+    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n+    collapse(1) dist_schedule(static, 16) \\\n+    safelen(8) simdlen(4) aligned(q: 32)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target simd \\\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n+    safelen(8) simdlen(4) lastprivate (l) linear(ll: 1) aligned(q: 32) reduction(+:r)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskloop simd \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) final(fi) mergeable nogroup priority (pp) \\\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(+:r)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskwait\n+  #pragma omp taskloop simd \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) if(taskloop: i1) final(fi) priority (pp) \\\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(+:r)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target\n+  #pragma omp teams distribute \\\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n+    collapse(1) dist_schedule(static, 16)\n+  for (int i = 0; i < 64; i++)\n+    ;\n+  #pragma omp target\n+  #pragma omp teams distribute parallel for \\\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n+    collapse(1) dist_schedule(static, 16) \\\n+    if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) schedule(static, 4)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target\n+  #pragma omp teams distribute parallel for simd \\\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n+    collapse(1) dist_schedule(static, 16) \\\n+    if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) schedule(static, 4) \\\n+    safelen(8) simdlen(4) aligned(q: 32)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target\n+  #pragma omp teams distribute simd \\\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n+    collapse(1) dist_schedule(static, 16) \\\n+    safelen(8) simdlen(4) aligned(q: 32)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+}"}, {"sha": "6e136bacc53926f9c3011e10d8a0591503ef0c2d", "filename": "gcc/testsuite/c-c++-common/gomp/clauses-2.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-2.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,53 @@\n+struct S { int r; int *s; int t[10]; };\n+void bar (int *);\n+\n+void\n+foo (int *p, int q, struct S t, int i, int j, int k, int l)\n+{\n+  #pragma omp target map (q), firstprivate (q)\n+    bar (&q);\n+  #pragma omp target map (p[0]) firstprivate (p) /* { dg-error \"appears more than once in data clauses\" } */\n+    bar (p);\n+  #pragma omp target firstprivate (p), map (p[0]) /* { dg-error \"appears more than once in data clauses\" } */\n+    bar (p);\n+  #pragma omp target map (p[0]) map (p)\n+    bar (p);\n+  #pragma omp target map (p) , map (p[0])\n+    bar (p);\n+  #pragma omp target map (q) map (q) /* { dg-error \"appears more than once in map clauses\" } */\n+    bar (&q);\n+  #pragma omp target map (p[0]) map (p[0]) /* { dg-error \"appears more than once in data clauses\" } */\n+    bar (p);\n+  #pragma omp target map (t) map (t.r) /* { dg-error \"appears more than once in map clauses\" } */\n+    bar (&t.r);\n+  #pragma omp target map (t.r) map (t) /* { dg-error \"appears more than once in map clauses\" } */\n+    bar (&t.r);\n+  #pragma omp target map (t.r) map (t.r) /* { dg-error \"appears more than once in map clauses\" } */\n+    bar (&t.r);\n+  #pragma omp target firstprivate (t), map (t.r)\n+    bar (&t.r);\n+  #pragma omp target map (t.r) firstprivate (t)\n+    bar (&t.r);\n+  #pragma omp target map (t.s[0]) map (t)\n+    bar (t.s);\n+  #pragma omp target map (t) map(t.s[0])\n+    bar (t.s);\n+  #pragma omp target firstprivate (t) map (t.s[0]) /* { dg-error \"appears more than once in data clauses\" } */\n+    bar (t.s);\n+  #pragma omp target map (t.s[0]) firstprivate (t) /* { dg-error \"appears more than once in data clauses\" } */\n+    bar (t.s);\n+  #pragma omp target map (t.s[0]) map (t.s[2]) /* { dg-error \"appears more than once in map clauses\" } */\n+    bar (t.s);\n+  #pragma omp target map (t.t[0:2]) map (t.t[4:6]) /* { dg-error \"appears more than once in map clauses\" } */\n+    bar (t.t);\n+  #pragma omp target map (t.t[i:j]) map (t.t[k:l]) /* { dg-error \"appears more than once in map clauses\" } */\n+    bar (t.t);\n+  #pragma omp target map (t.s[0]) map (t.r)\n+    bar (t.s);\n+  #pragma omp target map (t.r) ,map (t.s[0])\n+    bar (t.s);\n+  #pragma omp target map (t.r) map (t) map (t.s[0]) firstprivate (t) /* { dg-error \"appears more than once in map clauses\" } */\n+    bar (t.s); /* { dg-error \"appears more than once in data clauses\" \"\" { target *-*-* } 49 } */\n+  #pragma omp target map (t) map (t.r) firstprivate (t) map (t.s[0])  /* { dg-error \"appears more than once in map clauses\" } */\n+    bar (t.s); /* { dg-error \"appears more than once in data clauses\" \"\" { target *-*-* } 51 } */\n+}"}, {"sha": "7e07a81c31939def3ec3bbf44efee30ea309f0e2", "filename": "gcc/testsuite/c-c++-common/gomp/clauses-3.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-3.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,23 @@\n+struct T { int a; int *b; };\n+struct S { int *s; char u; struct T v; long x; };\n+\n+void bar (int *);\n+#pragma omp declare target to (bar)\n+\n+int\n+main ()\n+{\n+  int a[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+  struct S s = { a, 5, { 6, a + 5 }, 99L };\n+  #pragma omp target map (s.v.a, s.u, s.x)\n+  ;\n+  #pragma omp target map (s.v.a, s.u, s.x)\n+  bar (&s.v.a);\n+  #pragma omp target map (s.v.a) map (always, to: s.u) map (s.x)\n+  ;\n+  #pragma omp target map (s.s[0]) map (s.v.b[:3])\n+  ;\n+  #pragma omp target map (s.s[0]) map (s.v.b[:3])\n+  bar (s.s);\n+  return 0;\n+}"}, {"sha": "104b129a9aa7f72118c3d74577fbcc7f71220ac5", "filename": "gcc/testsuite/c-c++-common/gomp/clauses-4.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-4.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,96 @@\n+int t;\n+#pragma omp threadprivate (t)\n+\n+void\n+foo (int y, short z)\n+{\n+  int x;\n+  #pragma omp target teams map (from: x)\n+  #pragma omp distribute simd linear (x : 2)\n+  for (x = 0; x < 64; x += 2)\n+    ;\n+  #pragma omp target teams map (from: x)\n+  #pragma omp distribute parallel for simd linear (x)\n+  for (x = 0; x < 64; x++)\n+    ;\n+  #pragma omp target teams map (tofrom: y)\n+  #pragma omp distribute simd linear (y : 2)\t/* { dg-error \".linear. clause for variable other than loop iterator specified on construct combined with .distribute.\" } */\n+  for (x = 0; x < 64; x += 2)\n+    y += 2;\n+  #pragma omp target teams map (tofrom: z)\n+  #pragma omp distribute parallel for simd linear (z)\t/* { dg-error \".linear. clause for variable other than loop iterator specified on construct combined with .distribute.\" } */\n+  for (x = 0; x < 64; x++)\n+    z++;\n+  #pragma omp target teams map (tofrom: z)\n+  #pragma omp distribute parallel for linear (z: 4)\t/* { dg-error \".linear. is not valid for .#pragma omp distribute parallel for.\" } */\n+  for (x = 0; x < 64; x++)\n+    z += 4;\n+  #pragma omp target map (from: x)\n+  #pragma omp teams distribute simd linear (x : 2)\n+  for (x = 0; x < 64; x += 2)\n+    ;\n+  #pragma omp target map (from: x)\n+  #pragma omp teams distribute parallel for simd linear (x)\n+  for (x = 0; x < 64; x++)\n+    ;\n+  #pragma omp target map (tofrom: y)\n+  #pragma omp teams distribute simd linear (y : 2)\t/* { dg-error \".linear. clause for variable other than loop iterator specified on construct combined with .distribute.\" } */\n+  for (x = 0; x < 64; x += 2)\n+    y += 2;\n+  #pragma omp target map (tofrom: z)\n+  #pragma omp teams distribute parallel for simd linear (z)\t/* { dg-error \".linear. clause for variable other than loop iterator specified on construct combined with .distribute.\" } */\n+  for (x = 0; x < 64; x++)\n+    z++;\n+  #pragma omp target map (tofrom: z)\n+  #pragma omp teams distribute parallel for linear (z: 4)\t/* { dg-error \".linear. is not valid for .#pragma omp teams distribute parallel for.\" } */\n+  for (x = 0; x < 64; x++)\n+    z += 4;\n+  #pragma omp target parallel copyin (t)\t/* { dg-error \".copyin. is not valid for .#pragma omp target parallel.\" } */\n+    ;\n+  #pragma omp target parallel for copyin (t)\t/* { dg-error \".copyin. is not valid for .#pragma omp target parallel for.\" } */\n+  for (x = 0; x < 64; x++)\n+    ;\n+  #pragma omp target parallel for simd copyin (t)\t/* { dg-error \".copyin. is not valid for .#pragma omp target parallel for simd.\" } */\n+  for (x = 0; x < 64; x++)\n+    ;\n+  #pragma omp target teams\n+  #pragma omp distribute parallel for ordered\t\t/* { dg-error \".ordered. is not valid for .#pragma omp distribute parallel for.\" } */\n+  for (x = 0; x < 64; x++)\n+    {\n+      #pragma omp ordered\t/* { dg-error \"ordered region must be closely nested inside a loop region with an ordered clause\" } */\n+      ;\n+    }\n+  #pragma omp target teams\n+  #pragma omp distribute parallel for simd ordered\t/* { dg-error \".ordered. is not valid for .#pragma omp distribute parallel for simd.\" } */\n+  for (x = 0; x < 64; x++)\n+    {\n+      #pragma omp ordered simd, threads\t/* { dg-error \"OpenMP constructs other than .#pragma omp ordered simd. may not be nested inside simd region\" } */\n+      ;\n+    }\n+  #pragma omp target\n+  #pragma omp teams distribute parallel for ordered\t\t/* { dg-error \".ordered. is not valid for .#pragma omp teams distribute parallel for.\" } */\n+  for (x = 0; x < 64; x++)\n+    {\n+      #pragma omp ordered\t/* { dg-error \"ordered region must be closely nested inside a loop region with an ordered clause\" } */\n+      ;\n+    }\n+  #pragma omp target\n+  #pragma omp teams distribute parallel for simd ordered\t/* { dg-error \".ordered. is not valid for .#pragma omp teams distribute parallel for simd.\" } */\n+  for (x = 0; x < 64; x++)\n+    {\n+      #pragma omp ordered simd, threads\t/* { dg-error \"OpenMP constructs other than .#pragma omp ordered simd. may not be nested inside simd region\" } */\n+      ;\n+    }\n+  #pragma omp target teams distribute parallel for ordered\t\t/* { dg-error \".ordered. is not valid for .#pragma omp target teams distribute parallel for.\" } */\n+  for (x = 0; x < 64; x++)\n+    {\n+      #pragma omp ordered\t/* { dg-error \"ordered region must be closely nested inside a loop region with an ordered clause\" } */\n+      ;\n+    }\n+  #pragma omp target teams distribute parallel for simd ordered\t/* { dg-error \".ordered. is not valid for .#pragma omp target teams distribute parallel for simd.\" } */\n+  for (x = 0; x < 64; x++)\n+    {\n+      #pragma omp ordered simd, threads\t/* { dg-error \"OpenMP constructs other than .#pragma omp ordered simd. may not be nested inside simd region\" } */\n+      ;\n+    }\n+}"}, {"sha": "a1f1ea717b7fafa65eec6baa039c18306f925288", "filename": "gcc/testsuite/c-c++-common/gomp/declare-target-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+int foo (void), bar (void);\n+extern int a;\n+int b;\n+char d;\n+#pragma omp declare target\n+long c;\n+#pragma omp end declare target\n+\n+#pragma omp declare target (bar, a)\n+#pragma omp declare target to (b) link (d) to (foo)"}, {"sha": "b9313d86447dc006d5e6b101c5744838445554dd", "filename": "gcc/testsuite/c-c++-common/gomp/declare-target-2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-2.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+extern int a;\n+#pragma omp declare target\n+#pragma omp declare target to (a)\t\t/* { dg-error \"with clauses in between\" } */\n+#pragma omp end declare target\n+int b;\n+#pragma omp declare target to (b) link (b)\t/* { dg-error \"specified both in declare target\" } */\n+int c;\n+#pragma omp declare target (c)\n+#pragma omp declare target link (c)\t\t/* { dg-error \"specified both in declare target\" } */\n+int foo (void);\n+#pragma omp declare target link (foo)\t\t/* { dg-error \"is not a variable in clause\" } */\n+struct S;\n+extern struct S d[];\t\t\t\t/* { dg-error \"array type has incomplete element type\" \"\" { target c } } */\n+#pragma omp declare target to (d)\t\t/* { dg-error \"does not have a mappable type in\" } */\n+extern struct S e;\n+#pragma omp declare target link (e)\t\t/* { dg-error \"does not have a mappable type in\" } */\n+extern int f[];\n+#pragma omp declare target to (f)\t\t/* { dg-error \"does not have a mappable type in\" } */\n+int g, h;\n+#pragma omp threadprivate (g, h)\n+#pragma omp declare target to (g)\t\t/* { dg-error \"is threadprivate variable in\" } */\n+#pragma omp declare target link (h)\t\t/* { dg-error \"is threadprivate variable in\" } */\n+int j[10];\n+#pragma omp declare target to (j[0:4])\t\t/* { dg-error \"expected\" } */"}, {"sha": "22fcd8d9c704821e3601402e5851ee95a8fb7628", "filename": "gcc/testsuite/c-c++-common/gomp/depend-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-3.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void bar (int a[10][10][10]);\n+void\n+foo (int a[10][10][10], int **b, int x)\n+{\n+  int c[10][10][10];\n+  #pragma omp task depend(out: a[2:4][3:0][:7])\t/* { dg-error \"zero length array section\" } */\n+    bar (a);\n+  #pragma omp task depend(inout: b[:7][0:0][:0]) /* { dg-error \"zero length array section\" } */\n+    bar (a);\n+  #pragma omp task depend(in: c[:][:][10:])\t/* { dg-error \"zero length array section\" } */\n+    bar (c);\n+  #pragma omp task depend(out: a[2:4][3:0][:x])\t/* { dg-error \"zero length array section\" } */\n+    bar (a);\n+  #pragma omp task depend(inout: b[:x][0:0][:0]) /* { dg-error \"zero length array section\" } */\n+    bar (a);\n+  #pragma omp task depend(in: c[:][x-2:x][10:])\t/* { dg-error \"zero length array section\" } */\n+    bar (c);\n+}"}, {"sha": "d40b1fa83cde3f25ee6e8402cf1530d67362cbde", "filename": "gcc/testsuite/c-c++-common/gomp/depend-4.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-4.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void\n+foo (int *p, int (*q)[10], int r[10], int s[10][10])\n+{\n+  int a[10], b[10][10];\n+  #pragma omp task depend (inout: p[-1:2])\n+  ;\n+  #pragma omp task depend (inout: q[-1:2][2:4])\n+  ;\n+  #pragma omp task depend (inout: q[-1:2][-2:4]) /* { dg-error \"negative low bound in array section in\" } */\n+  ;\n+  #pragma omp task depend (inout: r[-1:2])\n+  ;\n+  #pragma omp task depend (inout: s[-1:2][2:4])\n+  ;\n+  #pragma omp task depend (inout: s[-1:2][-2:4]) /* { dg-error \"negative low bound in array section in\" } */\n+  ;\n+  #pragma omp task depend (inout: a[-1:2])\t /* { dg-error \"negative low bound in array section in\" } */\n+  ;\n+  #pragma omp task depend (inout: b[-1:2][2:4])\t /* { dg-error \"negative low bound in array section in\" } */\n+  ;\n+  #pragma omp task depend (inout: b[1:2][-2:4])\t /* { dg-error \"negative low bound in array section in\" } */\n+  ;\n+  #pragma omp task depend (inout: p[2:-3])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp task depend (inout: q[2:-3][:])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp task depend (inout: q[2:3][0:-1])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp task depend (inout: r[2:-5])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp task depend (inout: s[2:-5][:])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp task depend (inout: s[2:5][0:-4])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp task depend (inout: a[2:-5])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp task depend (inout: b[2:-5][0:10]) /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp task depend (inout: b[2:5][0:-4]) /* { dg-error \"negative length in array section in\" } */\n+  ;\n+}"}, {"sha": "89c3dd3c7c6f669d6c457ea24aa74fca45ecb1c5", "filename": "gcc/testsuite/c-c++-common/gomp/doacross-1.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdoacross-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdoacross-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdoacross-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void\n+foo (void)\n+{\n+  int i, j, k;\n+  #pragma omp for ordered (1)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered depend (sink: i - 1)\n+      #pragma omp ordered depend (source)\n+    }\n+  #pragma omp for ordered (1) collapse (1)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered depend (sink: i - 1)\n+      #pragma omp ordered depend (source)\n+    }\n+  #pragma omp for collapse (2) ordered (1)\t\t/* { dg-error \"clause parameter is less than\" } */\n+  for (i = 0; i < 64; i++)\n+    for (j = 0; j < 64; j++)\n+      {\n+\t#pragma omp ordered depend (sink: i - 1)\t/* { dg-error \"does not match number\" } */\n+\t#pragma omp ordered depend (source)\n+      }\n+  #pragma omp for ordered (2) collapse (3)\t\t/* { dg-error \"clause parameter is less than\" } */\n+  for (i = 0; i < 64; i++)\n+    for (j = 0; j < 64; j++)\n+      for (k = 0; k < 64; k++)\n+\t{\n+\t  #pragma omp ordered depend (sink: i - 1, j - 2) /* { dg-error \"does not match number\" } */\n+\t  #pragma omp ordered depend (source)\n+\t}\n+  #pragma omp ordered depend (sink: j)\t\t\t/* { dg-error \"clause must be closely nested inside an ordered loop\" } */\n+  #pragma omp ordered depend (source)\t\t\t/* { dg-error \"clause must be closely nested inside an ordered loop\" } */\n+  #pragma omp for ordered (1)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered depend (sink: i - 1) depend (sink: i - 2)\n+      #pragma omp ordered depend (source) depend (source) /* { dg-error \"more than one .depend.source.. clause on an\" } */\n+    }\n+  #pragma omp for ordered (1)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered depend (sink: i - 1) depend (source) depend (sink: i - 2) /* { dg-error \"clause specified together with\" } */\n+    }\n+}"}, {"sha": "4ba708c50c3adb5871eb95f06e99acc1d40fbb3b", "filename": "gcc/testsuite/c-c++-common/gomp/if-1.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fif-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fif-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fif-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void\n+foo (int a, int b, int *p, int *q)\n+{\n+  int i;\n+  #pragma omp parallel if (a)\n+    ;\n+  #pragma omp parallel if (parallel:a)\n+    ;\n+  #pragma omp parallel for simd if (a)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp parallel for simd if (parallel : a)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp task if (a)\n+    ;\n+  #pragma omp task if (task: a)\n+    ;\n+  #pragma omp taskloop if (a)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp taskloop if (taskloop : a)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp target if (a)\n+    ;\n+  #pragma omp target if (target: a)\n+    ;\n+  #pragma omp target teams distribute parallel for simd if (a)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp target teams distribute parallel for simd if (parallel : a) if (target: b)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp target data if (a) map (p[0:2])\n+    ;\n+  #pragma omp target data if (target data: a) map (p[0:2])\n+    ;\n+  #pragma omp target enter data if (a) map (to: p[0:2])\n+  #pragma omp target enter data if (target enter data: a) map (to: p[0:2])\n+  #pragma omp target exit data if (a) map (from: p[0:2])\n+  #pragma omp target exit data if (target exit data: a) map (from: p[0:2])\n+  #pragma omp target update if (a) to (q[0:3])\n+  #pragma omp target update if (target update:a) to (q[0:3])\n+}"}, {"sha": "f1f417ed23571cbe15393de63944d1e8c22e0b5d", "filename": "gcc/testsuite/c-c++-common/gomp/if-2.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fif-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fif-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fif-2.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void\n+foo (int a, int b, int *p, int *q, int task)\n+{\n+  int i;\n+  #pragma omp parallel if (a) if (b) /* { dg-error \"too many .if. clauses without modifier\" } */\n+    ;\n+  #pragma omp parallel if (a) if (parallel: b) /* { dg-error \"if any .if. clause has modifier, then all .if. clauses have to use modifier\" } */\n+    ;\n+  #pragma omp parallel if (parallel: a) if (b) /* { dg-error \"if any .if. clause has modifier, then all .if. clauses have to use modifier\" } */\n+    ;\n+  #pragma omp parallel if (parallel:a) if (parallel:a) /* { dg-error \"too many .if. clauses with .parallel. modifier\" } */\n+    ;\n+  #pragma omp parallel if (task:a) /* { dg-error \"expected .parallel. .if. clause modifier rather than .task.\" } */ \\\n+    if (taskloop: b) /* { dg-error \"expected .parallel. .if. clause modifier rather than .taskloop.\" } */\n+    ;\n+  #pragma omp parallel if (target update:a) /* { dg-error \"expected .parallel. .if. clause modifier rather than .target update.\" } */\n+    ;\n+  #pragma omp parallel for simd if (target update: a) /* { dg-error \"expected .parallel. .if. clause modifier rather than .target update.\" } */\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp task if (task)\n+    ;\n+  #pragma omp task if (task: task)\n+    ;\n+  #pragma omp task if (parallel: a) /* { dg-error \"expected .task. .if. clause modifier rather than .parallel.\" } */\n+    ;\n+  #pragma omp taskloop if (task : a) /* { dg-error \"expected .taskloop. .if. clause modifier rather than .task.\" } */\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp target if (taskloop: a) /* { dg-error \"expected .target. .if. clause modifier rather than .taskloop.\" } */\n+    ;\n+  #pragma omp target teams distribute parallel for simd if (target exit data : a) /* { dg-error \"expected .parallel. or .target. .if. clause modifier\" } */\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp target data if (target: a) map (p[0:2]) /* { dg-error \"expected .target data. .if. clause modifier rather than .target.\" } */\n+    ;\n+  #pragma omp target enter data if (target data: a) map (to: p[0:2]) /* { dg-error \"expected .target enter data. .if. clause modifier rather than .target data.\" } */\n+  #pragma omp target exit data if (target enter data: a) map (from: p[0:2]) /* { dg-error \"expected .target exit data. .if. clause modifier rather than .target enter data.\" } */\n+  #pragma omp target update if (target exit data:a) to (q[0:3]) /* { dg-error \"expected .target update. .if. clause modifier rather than .target exit data.\" } */\n+}"}, {"sha": "4557e22cb4f704fea9a84596c8dc969aaac54bd7", "filename": "gcc/testsuite/c-c++-common/gomp/linear-1.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flinear-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flinear-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flinear-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+int i;\n+\n+#pragma omp declare simd linear (val (x) : 1) linear (y : 2)\n+int bar (int x, int y, int z);\n+\n+void\n+foo (int x, int y)\n+{\n+  #pragma omp simd linear (i: 3)\n+  for (i = 0; i < 33; i += 3)\n+    ;\n+  #pragma omp simd linear (val (i): 3)\t\t/* { dg-error \"modifier should not be specified in\" } */\n+  for (i = 0; i < 33; i += 3)\n+    ;\n+  #pragma omp simd linear (x: y + 1)\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp simd linear (val (x): y + 1)\t/* { dg-error \"modifier should not be specified in\" } */\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp for linear (x: y + 1)\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp for linear (val (x): y + 1)\t/* { dg-error \"modifier should not be specified in\" } */\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp for simd linear (i: 3)\n+  for (i = 0; i < 33; i += 3)\n+    ;\n+  #pragma omp for simd linear (val (i): 3)\t/* { dg-error \"modifier should not be specified in\" } */\n+  for (i = 0; i < 33; i += 3)\n+    ;\n+  #pragma omp for simd linear (x: y + 1)\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp for simd linear (val (x): y + 1)\t/* { dg-error \"modifier should not be specified in\" } */\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+}"}, {"sha": "101f4047b854253fb2ceef1e1c0e2a042bfe5c2d", "filename": "gcc/testsuite/c-c++-common/gomp/map-2.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-2.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void\n+foo (int *p, int (*q)[10], int r[10], int s[10][10])\n+{\n+  int a[10], b[10][10];\n+  #pragma omp target map (tofrom: p[-1:2])\n+  ;\n+  #pragma omp target map (tofrom: q[-1:2][0:10])\n+  ;\n+  #pragma omp target map (tofrom: q[-1:2][-2:10]) /* { dg-error \"negative low bound in array section in\" } */\n+  ;\n+  #pragma omp target map (tofrom: r[-1:2])\n+  ;\n+  #pragma omp target map (tofrom: s[-1:2][:])\n+  ;\n+  #pragma omp target map (tofrom: s[-1:2][-2:10]) /* { dg-error \"negative low bound in array section in\" } */\n+  ;\n+  #pragma omp target map (tofrom: a[-1:2])\t /* { dg-error \"negative low bound in array section in\" } */\n+  ;\n+  #pragma omp target map (tofrom: b[-1:2][0:])\t /* { dg-error \"negative low bound in array section in\" } */\n+  ;\n+  #pragma omp target map (tofrom: b[1:2][-2:10]) /* { dg-error \"negative low bound in array section in\" } */\n+  ;\n+  #pragma omp target map (tofrom: p[2:-3])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp target map (tofrom: q[2:-3][:])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp target map (tofrom: q[2:3][0:-1])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp target map (tofrom: r[2:-5])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp target map (tofrom: s[2:-5][:])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp target map (tofrom: s[2:5][0:-4])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp target map (tofrom: a[2:-5])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp target map (tofrom: b[2:-5][0:10]) /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp target map (tofrom: b[2:5][0:-4]) /* { dg-error \"negative length in array section in\" } */\n+  ;\n+}"}, {"sha": "8a14b9c888e8c76603af39cb1bfcc02c2acf9e07", "filename": "gcc/testsuite/c-c++-common/gomp/map-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-3.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,21 @@\n+struct S { int i : 1; int j : 4; long long k : 25; };\n+void bar (struct S, int);\n+#pragma omp declare target to (bar)\n+\n+void\n+foo (struct S a, struct S b, struct S c, struct S d)\n+{\n+  #pragma omp target map (a)\n+  bar (a, 0);\n+  #pragma omp target map (a) map (b.i)\t\t/* { dg-error \"bit-field .b.\\(S::\\|\\)i. in .map. clause\" } */\n+  bar (a, b.i);\n+  #pragma omp target map (a) map (b.j)\t\t/* { dg-error \"bit-field .b.\\(S::\\|\\)j. in .map. clause\" } */\n+  bar (a, b.j);\n+  #pragma omp target map (a) map (b.k)\t\t/* { dg-error \"bit-field .b.\\(S::\\|\\)k. in .map. clause\" } */\n+  bar (a, b.k);\n+  #pragma omp target data map (a) map (b.i)\t/* { dg-error \"bit-field .b.\\(S::\\|\\)i. in .map. clause\" } */\n+  {\n+    #pragma omp target enter data map (alloc: a) map (to: c.j)\t\t/* { dg-error \"bit-field .c.\\(S::\\|\\)j. in .map. clause\" } */\n+    #pragma omp target exit data map (release: a) map (from: d.k)\t/* { dg-error \"bit-field .d.\\(S::\\|\\)k. in .map. clause\" } */\n+  }\n+}"}, {"sha": "61b2f818b08bffb2086949831051bf5f8fe5ef74", "filename": "gcc/testsuite/c-c++-common/gomp/nesting-1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fnesting-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fnesting-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fnesting-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -11,20 +11,20 @@ f_omp_parallel (void)\n #pragma omp target\n     ;\n \n-#pragma omp target data\n+#pragma omp target data map(i)\n     ;\n \n #pragma omp target update to(i)\n \n-#pragma omp target data\n+#pragma omp target data map(i)\n     {\n #pragma omp parallel\n       ;\n \n #pragma omp target\n       ;\n \n-#pragma omp target data\n+#pragma omp target data map(i)\n       ;\n \n #pragma omp target update to(i)\n@@ -45,28 +45,28 @@ f_omp_target (void)\n void\n f_omp_target_data (void)\n {\n-#pragma omp target data\n+#pragma omp target data map(i)\n   {\n #pragma omp parallel\n     ;\n \n #pragma omp target\n     ;\n \n-#pragma omp target data\n+#pragma omp target data map(i)\n     ;\n \n #pragma omp target update to(i)\n \n-#pragma omp target data\n+#pragma omp target data map(i)\n     {\n #pragma omp parallel\n       ;\n \n #pragma omp target\n       ;\n \n-#pragma omp target data\n+#pragma omp target data map(i)\n       ;\n \n #pragma omp target update to(i)"}, {"sha": "92ced7099078eccb2bbc738f96431ac70c179425", "filename": "gcc/testsuite/c-c++-common/gomp/nesting-warn-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fnesting-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fnesting-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fnesting-warn-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -7,15 +7,15 @@ f_omp_target (void)\n   {\n #pragma omp target /* { dg-warning \"target construct inside of target region\" } */\n     ;\n-#pragma omp target data /* { dg-warning \"target data construct inside of target region\" } */\n+#pragma omp target data map(i) /* { dg-warning \"target data construct inside of target region\" } */\n     ;\n #pragma omp target update to(i) /* { dg-warning \"target update construct inside of target region\" } */\n \n #pragma omp parallel\n     {\n #pragma omp target /* { dg-warning \"target construct inside of target region\" } */\n       ;\n-#pragma omp target data /* { dg-warning \"target data construct inside of target region\" } */\n+#pragma omp target data map(i) /* { dg-warning \"target data construct inside of target region\" } */\n       ;\n #pragma omp target update to(i) /* { dg-warning \"target update construct inside of target region\" } */\n     }"}, {"sha": "11022593e3e594b21ee22f3d02c77a58d376e4be", "filename": "gcc/testsuite/c-c++-common/gomp/ordered-1.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fordered-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fordered-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fordered-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,91 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd\" } */\n+/* { dg-additional-options \"-msse2\" { target sse2_runtime } } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#define N 1024\n+extern\n+#ifdef __cplusplus\n+\"C\"\n+#endif\n+void abort (void);\n+\n+int last;\n+\n+void\n+bar (unsigned char *a, int i, int safelen)\n+{\n+  int j, k;\n+  if (i != last++)\n+    abort ();\n+  for (j = i - safelen - 32; j < i; j++)\n+    if (j >= 0 && a[j] != 2)\n+      break;\n+  if (j <= i - safelen || a[j] != 1)\n+    abort ();\n+  for (k = j; k < i + safelen + 32; k++)\n+    if (k >= N || a[k] != 1)\n+      break;\n+  if (k <= i || k > j + safelen)\n+    abort ();\n+  if (k < N && a[k] != 0)\n+    abort ();\n+  for (; k < i + safelen + 32; k++)\n+    if (k < N && a[k] != 0)\n+      abort ();\n+}\n+\n+static inline void\n+foo (unsigned char *a, int i)\n+{\n+  #pragma omp ordered simd\n+  bar (a, i, 64);\n+}\n+\n+int\n+main ()\n+{\n+  unsigned char a[N], b[N];\n+  int i;\n+  #pragma omp simd\n+  for (i = 0; i < N; i++)\n+    a[i] = 0;\n+  #pragma omp simd safelen (64)\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i]++;\n+      foo (a, i);\n+      a[i]++;\n+    }\n+  #pragma omp simd\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = 0;\n+      b[i] = 0;\n+    }\n+  last = 0;\n+  #pragma omp simd safelen (32)\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i]++;\n+      #pragma omp ordered simd\n+      bar (a, i, 32);\n+      a[i]++;\n+    }\n+  for (i = 0; i < N; i++)\n+    if (a[i] != 2)\n+      abort ();\n+  #pragma omp simd safelen (32)\n+  for (i = 1; i < N; i++)\n+    {\n+      #pragma omp ordered simd\n+      b[i] = b[i - 1] + 1;\n+      a[i]++;\n+      #pragma omp ordered simd\n+      a[i] += a[i - 1];\n+    }\n+  for (i = 0; i < N; i++)\n+    if (a[i] != (unsigned char) (2 + 3 * i) || b[i] != (unsigned char) i)\n+      abort ();\n+  return 0;\n+}"}, {"sha": "96442978a9f50de722d701c5c4ac7e23037a7ed4", "filename": "gcc/testsuite/c-c++-common/gomp/ordered-2.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fordered-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fordered-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fordered-2.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O0 -fopenmp-simd\" } */\n+\n+#include \"ordered-1.c\""}, {"sha": "1d7ff80f74386fbbc348b6c8f6171262ee3b2787", "filename": "gcc/testsuite/c-c++-common/gomp/ordered-3.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fordered-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fordered-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fordered-3.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,91 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void\n+foo (void)\n+{\n+  int i;\n+  #pragma omp for ordered\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered\n+      ;\n+    }\n+  #pragma omp for ordered\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered threads\n+      ;\n+    }\n+  #pragma omp for ordered\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered threads threads\t/* { dg-error \"too many .threads. clauses\" } */\n+      ;\n+    }\n+  #pragma omp simd\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered simd\n+      ;\n+    }\n+  #pragma omp simd\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered simd simd\t\t/* { dg-error \"too many .simd. clauses\" } */\n+      ;\n+    }\n+  #pragma omp for simd ordered\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered threads, simd\n+      ;\n+    }\n+  #pragma omp for simd ordered\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered threads, simd, threads, simd\t/* { dg-error \"too many .threads. clauses\" } */\n+      ;\t/* { dg-error \"too many .simd. clauses\" \"\" { target *-*-* } 47 } */\n+    }\n+  #pragma omp for simd ordered(1)\t/* { dg-error \".ordered. clause with parameter may not be specified on .#pragma omp for simd. construct\" } */\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered depend(sink: i - 1)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause with a parameter\" } */\n+      #pragma omp ordered depend(source)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause with a parameter\" } */\n+    }\n+  #pragma omp parallel for simd ordered(1)\t/* { dg-error \".ordered. clause with parameter may not be specified on .#pragma omp parallel for simd. construct\" } */\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered depend(sink: i - 1)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause with a parameter\" } */\n+      #pragma omp ordered depend(source)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause with a parameter\" } */\n+    }\n+}\n+\n+void\n+bar (int x)\n+{\n+  switch (x)\n+    {\n+    case 0:\n+      #pragma omp ordered\n+      ;\n+      break;\n+    case 1:\n+      #pragma omp ordered threads\n+      ;\n+      break;\n+    case 2:\n+      #pragma omp ordered threads, threads\t/* { dg-error \"too many .threads. clauses\" } */\n+      ;\n+      break;\n+    }\n+}\n+\n+void\n+baz (void)\n+{\n+  #pragma omp ordered simd\n+  ;\n+  #pragma omp ordered simd, simd\t\t/* { dg-error \"too many .simd. clauses\" } */\n+  ;\n+}"}, {"sha": "dbd621f0dba777f8233b40bea93a2813aa737015", "filename": "gcc/testsuite/c-c++-common/gomp/pr61486-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr61486-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr61486-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr61486-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -6,8 +6,8 @@ int\n foo (int *a)\n {\n   int i, j = 0;\n-  #pragma omp target teams distribute simd linear(i, j) map(a[:10])\n+  #pragma omp target teams distribute simd linear(i) map(a[:10])\n   for (i = 0; i < 10; i++)\n-    a[i] = j++;\n-  return i + j;\n+    a[i] = j;\n+  return i;\n }"}, {"sha": "804a8270660c2d64fac7d41c1ea453471a27d71f", "filename": "gcc/testsuite/c-c++-common/gomp/pr61486-2.c", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr61486-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr61486-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr61486-2.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -50,22 +50,21 @@ test (int n, int o, int p, int q, int r, int s, int *pp)\n     \tprivate (p) firstprivate (q) shared (n) reduction (+: r) \\\n     \tthread_limit (n * 2) dist_schedule (static, 4) collapse (2) \\\n     \tnum_threads (n + 4) proc_bind (spread) lastprivate (s) \\\n-    \tordered schedule (static, 8)\n+    \tschedule (static, 8)\n       for (i = 0; i < 10; i++)\n \tfor (j = 0; j < 10; j++)\n \t  {\n \t    r = r + 1;\n \t    p = q;\n \t    dosomething (a, n, p + q);\n-\t    #pragma omp ordered\n-\t      p = q;\n+\t    p = q;\n \t    s = i * 10 + j;\n \t  }\n     #pragma omp target teams distribute parallel for device (n + 1) num_teams (n + 4) \\\n     \tif (n != 6)map (from: n) map (alloc: a[2:o-2]) default(shared) \\\n     \tprivate (p) firstprivate (q) shared (n) reduction (+: r) \\\n     \tthread_limit (n * 2) dist_schedule (static, 4) num_threads (n + 4) \\\n-    \tproc_bind (master) lastprivate (s) ordered schedule (static, 8)\n+    \tproc_bind (master) lastprivate (s) schedule (static, 8)\n       for (i = 0; i < 10; i++)\n \t{\n \t  for (j = 0; j < 10; j++)\n@@ -74,8 +73,7 @@ test (int n, int o, int p, int q, int r, int s, int *pp)\n \t      p = q;\n \t      dosomething (a, n, p + q);\n \t    }\n-\t  #pragma omp ordered\n-\t    p = q;\n+\t  p = q;\n \t  s = i * 10;\n \t}\n     #pragma omp target teams distribute parallel for simd device (n + 1) \\\n@@ -165,22 +163,21 @@ test (int n, int o, int p, int q, int r, int s, int *pp)\n \tdefault(shared) private (p) firstprivate (q) shared (n) reduction (+: r) \\\n     \tthread_limit (n * 2) dist_schedule (static, 4) collapse (2) \\\n     \tnum_threads (n + 4) proc_bind (spread) lastprivate (s) \\\n-    \tordered schedule (static, 8)\n+    \tschedule (static, 8)\n       for (i = 0; i < 10; i++)\n \tfor (j = 0; j < 10; j++)\n \t  {\n \t    r = r + 1;\n \t    p = q;\n \t    dosomething (a, n, p + q);\n-\t    #pragma omp ordered\n-\t      p = q;\n+\t    p = q;\n \t    s = i * 10 + j;\n \t  }\n     #pragma omp target device (n + 1) if (n != 6)map(from:n) map(alloc:a[2:o-2])\n     #pragma omp teams distribute parallel for num_teams (n + 4) if (n != 6) \\\n \tdefault(shared) private (p) firstprivate (q) shared (n) reduction (+: r) \\\n     \tthread_limit (n * 2) dist_schedule (static, 4) num_threads (n + 4) \\\n-    \tproc_bind (master) lastprivate (s) ordered schedule (static, 8)\n+    \tproc_bind (master) lastprivate (s) schedule (static, 8)\n       for (i = 0; i < 10; i++)\n \t{\n \t  for (j = 0; j < 10; j++)\n@@ -189,8 +186,7 @@ test (int n, int o, int p, int q, int r, int s, int *pp)\n \t      p = q;\n \t      dosomething (a, n, p + q);\n \t    }\n-\t  #pragma omp ordered\n-\t    p = q;\n+\t  p = q;\n \t  s = i * 10;\n \t}\n     #pragma omp target device (n + 1) if (n != 6)map(from:n) map(alloc:a[2:o-2])\n@@ -273,23 +269,22 @@ test (int n, int o, int p, int q, int r, int s, int *pp)\n \tdefault(shared) private (p) firstprivate (q) shared (n) reduction (+: r) \\\n     \tcollapse (2) dist_schedule (static, 4) \\\n     \tnum_threads (n + 4) proc_bind (spread) lastprivate (s) \\\n-    \tordered schedule (static, 8)\n+    \tschedule (static, 8)\n       for (i = 0; i < 10; i++)\n \tfor (j = 0; j < 10; j++)\n \t  {\n \t    r = r + 1;\n \t    p = q;\n \t    dosomething (a, n, p + q);\n-\t    #pragma omp ordered\n-\t      p = q;\n+\t    p = q;\n \t    s = i * 10 + j;\n \t  }\n     #pragma omp target teams device (n + 1) if (n != 6)map(from:n) map(alloc:a[2:o-2]) \\\n \tnum_teams (n + 4) thread_limit (n * 2)\n     #pragma omp distribute parallel for if (n != 6) \\\n \tdefault(shared) private (p) firstprivate (q) shared (n) reduction (+: r) \\\n     \tnum_threads (n + 4) dist_schedule (static, 4) \\\n-    \tproc_bind (master) lastprivate (s) ordered schedule (static, 8)\n+    \tproc_bind (master) lastprivate (s) schedule (static, 8)\n       for (i = 0; i < 10; i++)\n \t{\n \t  for (j = 0; j < 10; j++)\n@@ -298,8 +293,7 @@ test (int n, int o, int p, int q, int r, int s, int *pp)\n \t      p = q;\n \t      dosomething (a, n, p + q);\n \t    }\n-\t  #pragma omp ordered\n-\t    p = q;\n+\t  p = q;\n \t  s = i * 10;\n \t}\n     #pragma omp target teams device (n + 1) if (n != 6)map(from:n) map(alloc:a[2:o-2]) \\\n@@ -385,21 +379,20 @@ test2 (int n, int o, int p, int r, int s, int *pp)\n \tdefault(shared) private (p) firstprivate (q) shared (n) reduction (+: r) \\\n     \tcollapse (2) dist_schedule (static, 4) \\\n     \tnum_threads (n + 4) proc_bind (spread) lastprivate (s) \\\n-    \tordered schedule (static, 8)\n+    \tschedule (static, 8)\n       for (i = 0; i < 10; i++)\n \tfor (j = 0; j < 10; j++)\n \t  {\n \t    r = r + 1;\n \t    p = q;\n \t    dosomething (a, n, p + q);\n-\t    #pragma omp ordered\n-\t      p = q;\n+\t    p = q;\n \t    s = i * 10 + j;\n \t  }\n     #pragma omp distribute parallel for if (n != 6) \\\n \tdefault(shared) private (p) firstprivate (q) shared (n) reduction (+: r) \\\n     \tnum_threads (n + 4) dist_schedule (static, 4) \\\n-    \tproc_bind (master) lastprivate (s) ordered schedule (static, 8)\n+    \tproc_bind (master) lastprivate (s) schedule (static, 8)\n       for (i = 0; i < 10; i++)\n \t{\n \t  for (j = 0; j < 10; j++)\n@@ -408,8 +401,7 @@ test2 (int n, int o, int p, int r, int s, int *pp)\n \t      p = q;\n \t      dosomething (a, n, p + q);\n \t    }\n-\t  #pragma omp ordered\n-\t    p = q;\n+\t  p = q;\n \t  s = i * 10;\n \t}\n     #pragma omp distribute parallel for simd if (n != 6)default(shared) \\"}, {"sha": "e2eebf9147d8bc2a20c4a68cd5d63f0b70fb9455", "filename": "gcc/testsuite/c-c++-common/gomp/priority-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpriority-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpriority-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpriority-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,26 @@\n+void bar (void);\n+\n+void\n+foo (int x, unsigned long long y)\n+{\n+  #pragma omp task\n+    bar ();\n+  #pragma omp taskloop\n+    for (int i = 0; i < 10; i++)\n+      bar ();\n+  #pragma omp task\n+    bar ();\n+  #pragma omp taskloop\n+    for (unsigned long long int i = 0; i < y; i++)\n+      bar ();\n+  #pragma omp task priority (1)\n+    bar ();\n+  #pragma omp taskloop priority (1)\n+    for (int i = 0; i < 10; i++)\n+      bar ();\n+  #pragma omp task priority (x + 1)\n+    bar ();\n+  #pragma omp taskloop priority (x + 1)\n+    for (unsigned long long int i = 0; i < y; i++)\n+      bar ();\n+}"}, {"sha": "23e79d9c3c724a3b744fe8ee37c1e62b86722205", "filename": "gcc/testsuite/c-c++-common/gomp/reduction-1.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freduction-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freduction-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freduction-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void bar (int a[10][10][10]);\n+extern int f[][2];\t\t\t\t\t/* { dg-error \"has incomplete type\" \"\" { target c++ } } */\n+extern int g[];\t\t\t\t\t\t/* { dg-error \"has incomplete type\" \"\" { target c++ } } */\n+void\n+foo (int a[10][10][10], int **b, int x)\n+{\n+  int c[10][10][0];\n+  int d[0];\n+  char e[12];\n+  #pragma omp parallel reduction(+: a[:4][:0][:7])\t/* { dg-error \"zero length array section\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: b[:7][0:0][:0])\t/* { dg-error \"zero length array section\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: c[:][:][0:])\t/* { dg-error \"zero length array section|for unknown bound array type length expression must be specified\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: a[:4][:0][:x])\t/* { dg-error \"zero length array section\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: b[:x][0:0][:0])\t/* { dg-error \"zero length array section\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: c[:][:x][0:])\t/* { dg-error \"zero length array section|for unknown bound array type length expression must be specified\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: d)\t\t\t/* { dg-error \"is a zero size array\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: a[0:4])\n+    bar (a);\n+  #pragma omp parallel reduction(+: a[2:4])\t\t/* { dg-error \"array section has to be zero-based\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: e[2:4])\t\t/* { dg-error \"array section has to be zero-based\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: a[0.5:2])\t\t/* { dg-error \"low bound \\[^\\n\\r]* of array section does not have integral type\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: a[0:2.5])\t\t/* { dg-error \"length \\[^\\n\\r]* of array section does not have integral type\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: f[:][0:2])\t\t/* { dg-error \"for unknown bound array type length expression must be specified\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: a[:][0:10])\t\t/* { dg-error \"for pointer type length expression must be specified\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: a[:10][0:12])\t/* { dg-error \"above array section size\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: b[0:10][0:10])\t/* { dg-error \"array section is not contiguous\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: a[0:2][0:9])\t/* { dg-error \"array section is not contiguous\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: f)\t\t\t/* { dg-error \"has an incomplete type|invalid use of array with unspecified bounds\" } */\n+    bar (a);\n+  #pragma omp parallel reduction(+: g)\t\t\t/* { dg-error \"has an incomplete type|invalid use of array with unspecified bounds\" } */\n+    bar (a);\n+}"}, {"sha": "e6a7bb92fcfaf832a161f91119f518f117232c66", "filename": "gcc/testsuite/c-c++-common/gomp/schedule-simd-1.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fschedule-simd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fschedule-simd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fschedule-simd-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -O2\" } */\n+/* { dg-additional-options \"-mavx512f\" { target { x86_64-*-* i?86-*-* } } } */\n+\n+#define N 1024\n+int a[N], b[N], c[N];\n+\n+void\n+f1 (void)\n+{\n+  int i;\n+  #pragma omp parallel for simd schedule (simd:static)\n+  for (i = 0; i < N; i++)\n+    a[i] = b[i] + c[i];\n+}\n+\n+void\n+f2 (void)\n+{\n+  int i;\n+  #pragma omp parallel for simd schedule (simd: static, 7)\n+  for (i = 0; i < N; i++)\n+    a[i] = b[i] + c[i];\n+}\n+\n+void\n+f3 (void)\n+{\n+  int i;\n+  #pragma omp parallel for simd schedule (simd : dynamic, 7)\n+  for (i = 0; i < N; i++)\n+    a[i] = b[i] + c[i];\n+}\n+\n+void\n+f4 (void)\n+{\n+  int i;\n+  #pragma omp parallel for simd schedule ( simd:runtime)\n+  for (i = 0; i < N; i++)\n+    a[i] = b[i] + c[i];\n+}\n+\n+void\n+f5 (void)\n+{\n+  int i;\n+  #pragma omp parallel for simd schedule (simd:auto)\n+  for (i = 0; i < N; i++)\n+    a[i] = b[i] + c[i];\n+}"}, {"sha": "4872a0723156d2f30e4cbd0f28138da9d6f96d4b", "filename": "gcc/testsuite/c-c++-common/gomp/sink-1.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsink-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsink-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsink-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -Wunknown-pragmas -Werror\" } */\n+\n+extern void bark (void);\n+int i,j,k;\n+int array[555];\n+\n+int\n+main()\n+{\n+#pragma omp parallel for ordered(2)\n+  for (i=0; i < 100; ++i)\n+    for (j=0; j < 100; ++j)\n+      {\n+/* OUT variant does not apply to ORDERED construct.  */\n+#pragma omp ordered depend(out:i) /* { dg-error \"invalid depend kind\" } */\n+\n+/* depend(sink...) is allowed without an offset.  */\n+#pragma omp ordered depend(sink:i,j-1)\n+\n+#pragma omp ordered depend(sink:i-1,j+2)\n+      bark ();\n+      }\n+\n+/* depend(sink...) does not apply to `omp task'.  */\n+#pragma omp task depend(sink:i+3) /* { dg-error \"only allowed in 'omp ordered'\" } */\n+  bark();\n+\n+#pragma omp ordered depend(source) /* { dg-error \"'depend' clause must be closely nested\" } */\n+\n+#pragma omp parallel for ordered(2)\n+  for (i=0; i < 100; ++i)\n+    for (j=0; j < 100; ++j)\n+      {\n+/* Multiple depend(source) allowed.  */\n+#pragma omp ordered depend(source)\n+#pragma omp ordered depend(source)\n+      }\n+\n+#pragma omp parallel for ordered(2)\n+  for (i=0; i < 100; ++i)\n+    for (j=0; j < 100; ++j)\n+      {\n+#pragma omp ordered depend(sink:i-2,j-2,k+2) /* { dg-error \"does not match number of iteration var\" } */\n+\tbark();\n+      }\n+\n+#pragma omp parallel for ordered(2)\n+  for (i=0; i < 100; ++i)\n+    for (j=0; j < 100; ++j)\n+      {\n+#pragma omp ordered depend(sink:i-2) /* { dg-error \"does not match number of iteration variables\" } */\n+\tbark();\n+      }\n+\n+#pragma omp parallel for ordered(2)\n+  for (i=0; i < 100; ++i)\n+    for (j=0; j < 100; ++j)\n+      {\n+#pragma omp ordered depend(sink:k,i) /* { dg-error \"is not an iteration\" } */\n+\tbark();\n+      }\n+}\n+\n+void bar (int, int, int);\n+\n+void\n+foo (int n, int m, int o)\n+{\n+  int i, j, k;\n+  #pragma omp for collapse(2) ordered(3)\n+  for (i = 0; i < m; i++)\n+    {\n+      for (j = 0; j < n; j++)\n+\tfor (k = 0; k < o; k++)\n+\t  {\n+#pragma omp ordered depend(sink: i-1,j,k) depend(sink: i,j-1,k-1) depend(sink: i-1,j-1,k+1)\n+\t    bar (i, j, k);\n+#pragma omp ordered depend(source)\n+\t  }\n+    }\n+}\n+\n+int\n+baz ()\n+{\n+  int i, j;\n+#pragma omp parallel for ordered(2)\n+  for (i=0; i < 100; ++i)\n+    for (j=0; j < 100; ++j)\n+      {\n+#pragma omp ordered depend(sink:i-1,j-3)\n+\tbar (i, j, 0);\n+#pragma omp ordered depend(source)\n+      }\n+}"}, {"sha": "e781a6fd9459e700e55e352b1cf7ae942f02eda7", "filename": "gcc/testsuite/c-c++-common/gomp/sink-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsink-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsink-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsink-2.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+\n+void bar (int *);\n+\n+void\n+foo ()\n+{\n+  int i,j;\n+#pragma omp parallel for ordered(1)\n+  for (i=0; i < 100; ++i)\n+    {\n+#pragma omp ordered depend(sink:i-1)\n+    bar(&i);\n+#pragma omp ordered depend(source)\n+    }\n+}"}, {"sha": "7cb16ed0f76005024f8ba070bf51ff97568c32b9", "filename": "gcc/testsuite/c-c++-common/gomp/sink-3.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsink-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsink-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsink-3.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+/* Test that we can handle multiple undeclared sink variables\n+   gracefully.  */\n+\n+void bar (int *);\n+\n+void\n+foo ()\n+{\n+  int i,j;\n+#pragma omp parallel for ordered(1)\n+  for (i=0; i < 100; ++i)\n+    {\n+#pragma omp ordered depend(sink:poo-1,paa+1) /* { dg-error \"poo.*declared.*paa.*declared\" } */\n+    bar(&i);\n+#pragma omp ordered depend(source)\n+    }\n+}"}, {"sha": "11b6d9973c9dff5c6f7830c4838a5de69fe41094", "filename": "gcc/testsuite/c-c++-common/gomp/sink-4.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsink-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsink-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsink-4.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-omplower\" } */\n+\n+/* Test that we adjust pointer offsets for sink variables\n+   correctly.  */\n+\n+typedef struct {\n+    char stuff[400];\n+} foo;\n+\n+void\n+funk (foo *begin, foo *end)\n+{\n+  foo *p;\n+#pragma omp parallel for ordered(1)\n+  for (p=end; p > begin; p--)\n+    {\n+#pragma omp ordered depend(sink:p+1)\n+      void bar ();\n+        bar();\n+#pragma omp ordered depend(source)\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"depend\\\\(sink:p\\\\+400\\\\)\" 1 \"omplower\" } } */"}, {"sha": "7c50ff6f9b747dbf3e6fe8b08607273413b43b39", "filename": "gcc/testsuite/c-c++-common/gomp/udr-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fudr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fudr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fudr-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+struct S {};\n+void foo (void *, void *);\n+void bar (void *, void *);\n+void baz (void *);\n+#pragma omp declare reduction(+:struct S:foo (&omp_out, &omp_in))initializer(bar(&omp_priv, &omp_orig))\n+\n+void\n+test (void)\n+{\n+  struct S a, b[10];\n+  #pragma omp parallel reduction(+:a)\n+    baz (&a);\n+}"}, {"sha": "f5c3a5d153f2820bb8846d392c7de7b2155e0186", "filename": "gcc/testsuite/c-c++-common/taskloop-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftaskloop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftaskloop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftaskloop-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+\n+int e;\n+int bar (int, int);\n+void baz (int, int, int, int *, int *, int *);\n+\n+void\n+foo (int a, int b, int c, int d, int f, int g, int h, int j, int k, int l)\n+{\n+  int i;\n+  #pragma omp taskloop if (a) final (b) untied default(none) mergeable \\\n+    private(c) firstprivate (e) shared (d) num_tasks(f) collapse(1)\n+  for (i = bar (g, h) + j; i < k; i += l)\n+    baz (i, d, e++, &c, &d, &e);\n+}"}, {"sha": "76ee4970fc37b0e3b6e5c60b0b4fc2bb43a1b873", "filename": "gcc/testsuite/g++.dg/gomp/clause-1.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-1.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -9,22 +9,22 @@ struct T\n \n void T::test()\n {\n-  #pragma omp parallel private(n)\t// { dg-error \"T::n\" }\n+  #pragma omp parallel private(n)\n     n = 1;\n \n   #pragma omp parallel shared(n)\t// { dg-error \"T::n\" }\n     n = 1;\n \n-  #pragma omp parallel firstprivate(n)\t// { dg-error \"T::n\" }\n+  #pragma omp parallel firstprivate(n)\n     n = 1;\n \n-  #pragma omp sections lastprivate(n)\t// { dg-error \"T::n\" }\n+  #pragma omp sections lastprivate(n)\n     { n = 1; }\n \n-  #pragma omp parallel reduction(+:n)\t// { dg-error \"T::n\" }\n+  #pragma omp parallel reduction(+:n)\n     n = 1;\n \n-  #pragma omp single copyprivate(n)\t// { dg-error \"T::n\" }\n+  #pragma omp single copyprivate(n)\n     n = 1;\n \n   #pragma omp parallel copyin(n)\t// { dg-error \"T::n\" }"}, {"sha": "54f795717dd81920635062cd1b824846ef99936f", "filename": "gcc/testsuite/g++.dg/gomp/clause-3.C", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -34,6 +34,9 @@ foo (int x)\n #pragma omp p for lastprivate (x, x) // { dg-error \"more than once\" }\n   for (i = 0; i < 10; i++)\n     ;\n+#pragma omp p for linear (x, x) // { dg-error \"more than once\" }\n+  for (i = 0; i < 10; i++)\n+    ;\n #pragma omp single private (x) copyprivate (x) // { dg-error \"more than once\" }\n     ;\n #pragma omp p shared (bar) // { dg-error \"is not a variable\" }\n@@ -46,7 +49,7 @@ foo (int x)\n     ;\n #pragma omp p reduction (*:s) // { dg-error \"user defined reduction not found for\" }\n     ;\n-#pragma omp p reduction (-:a) // { dg-error \"has invalid type for\" }\n+#pragma omp p reduction (-:a)\n     ;\n   d = 0;\n #pragma omp p reduction (*:d)\n@@ -80,6 +83,9 @@ foo (int x)\n     ;\n #pragma omp p reduction (*:t) // { dg-error \"predetermined 'threadprivate'\" }\n     ;\n+#pragma omp p for linear (t) // { dg-error \"predetermined 'threadprivate'\" }\n+  for (i = 0; i < 10; i++)\n+    ;\n #pragma omp p shared (c) // { dg-error \"predetermined 'shared'\" }\n     ;\n #pragma omp p private (c) // { dg-error \"predetermined 'shared'\" }\n@@ -91,4 +97,7 @@ foo (int x)\n     ;\n #pragma omp p reduction (*:c) // { dg-error \"predetermined 'shared'\" }\n     ;\n+#pragma omp p for linear (c:2) // { dg-error \"predetermined 'shared'\" }\n+  for (i = 0; i < 10; i++)\n+    ;\n }"}, {"sha": "5a444e57121958ba49839511b457918b1fe52705", "filename": "gcc/testsuite/g++.dg/gomp/declare-simd-3.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-3.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do compile }\n+\n+#pragma omp declare simd uniform(b) linear(c, d) linear(uval(e)) linear(ref(f))\n+int f1 (int a, int b, int c, int &d, int &e, int &f)\n+{\n+  a++;\n+  b++;\n+  c++;\n+  d++;\n+  e++;\n+  f++;\n+  return a + b + c + d + e + f;\n+}\n+\n+#pragma omp declare simd uniform(b) linear(c, d) linear(uval(e)) linear(ref(f))\n+int f2 (int a, int b, int c, int &d, int &e, int &f)\n+{\n+  asm volatile (\"\" : : \"r\" (&a));\n+  asm volatile (\"\" : : \"r\" (&b));\n+  asm volatile (\"\" : : \"r\" (&c));\n+  asm volatile (\"\" : : \"r\" (&d));\n+  asm volatile (\"\" : : \"r\" (&e));\n+  asm volatile (\"\" : : \"r\" (&f));\n+  a++;\n+  b++;\n+  c++;\n+  d++;\n+  e++;\n+  f++;\n+  return a + b + c + d + e + f;\n+}\n+\n+#pragma omp declare simd uniform(b) linear(c, d) linear(uval(e)) linear(ref(f))\n+int f3 (const int a, const int b, const int c, const int &d, const int &e, const int &f)\n+{\n+  return a + b + c + d + e + f;\n+}\n+\n+#pragma omp declare simd uniform(b) linear(c, d) linear(uval(e)) linear(ref(f))\n+int f4 (const int a, const int b, const int c, const int &d, const int &e, const int &f)\n+{\n+  asm volatile (\"\" : : \"r\" (&a));\n+  asm volatile (\"\" : : \"r\" (&b));\n+  asm volatile (\"\" : : \"r\" (&c));\n+  asm volatile (\"\" : : \"r\" (&d));\n+  asm volatile (\"\" : : \"r\" (&e));\n+  asm volatile (\"\" : : \"r\" (&f));\n+  return a + b + c + d + e + f;\n+}"}, {"sha": "68d58fee59f8d95869c762928bbc3c786ff01b08", "filename": "gcc/testsuite/g++.dg/gomp/linear-1.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Flinear-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Flinear-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Flinear-1.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,48 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+int i;\n+\n+#pragma omp declare simd linear (ref (x) : 1) linear (uval (y) : 2)\n+int bar (int &x, int &y, int z);\n+\n+void\n+foo (int &x, int &y)\n+{\n+  #pragma omp simd linear (x: y + 1)\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp simd linear (val (x): y + 1)\t// { dg-error \"modifier should not be specified in\" }\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp simd linear (ref (x): y + 1)\t// { dg-error \"modifier should not be specified in\" }\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp simd linear (uval (x): y + 1)\t// { dg-error \"modifier should not be specified in\" }\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp for linear (x: y + 1)\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp for linear (val (x): y + 1)\t// { dg-error \"modifier should not be specified in\" }\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp for linear (ref (x): y + 1)\t// { dg-error \"modifier should not be specified in\" }\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp for linear (uval (x): y + 1)\t// { dg-error \"modifier should not be specified in\" }\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp for simd linear (x: y + 1)\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp for simd linear (val (x): y + 1)\t// { dg-error \"modifier should not be specified in\" }\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp for simd linear (ref (x): y + 1)\t// { dg-error \"modifier should not be specified in\" }\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp for simd linear (uval (x): y + 1)\t// { dg-error \"modifier should not be specified in\" }\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+}"}, {"sha": "cf32b098123d161a2aa9b09a81daade6ebaafee6", "filename": "gcc/testsuite/g++.dg/gomp/member-1.C", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-1.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,252 @@\n+struct T { T () {}; virtual ~T () {}; int t; };\n+struct S : virtual public T { int a; void foo (); };\n+template <typename T>\n+struct U { U () {}; virtual ~U () {}; T t; };\n+template <typename T>\n+struct V : virtual public U<T> { T a; void foo (); };\n+\n+void\n+S::foo ()\n+{\n+#pragma omp parallel firstprivate (a, t)\n+  {\n+    int *q1 = &a;\n+    int *q2 = &this->a;\n+    int q3 = a;\n+    int q4 = this->a;\n+    int *q5 = &t;\n+    int *q6 = &this->t;\n+    int q7 = t;\n+    int q8 = this->t;\n+    int q9 = T::t;\n+    int q10 = this->T::t;\n+    int &q11 = a;\n+    int &q12 = this->a;\n+    int &q13 = t;\n+    int &q14 = this->t;\n+    int &q15 = S::a;\n+    int &q16 = this->S::a;\n+    int &q17 = T::t;\n+    int &q18 = this->T::t;\n+  }\n+#pragma omp parallel private (a, t)\n+  {\n+    a = 7;\n+    S::a += 9;\n+    t = 10;\n+    T::t += 11;\n+  }\n+#pragma omp parallel\n+  {\n+  #pragma omp sections lastprivate (S::a, T::t)\n+    {\n+    #pragma omp section\n+      {\n+\tS::a = 6;\n+\tT::t = 8;\n+      }\n+    }\n+  }\n+#pragma omp parallel\n+  {\n+  #pragma omp for firstprivate (a, t) lastprivate (a, t)\n+    for (int i = 0; i < 10; i++)\n+      {\n+\tint q19 = a + t;\n+\tif (i == 9)\n+\t  {\n+\t    a = i;\n+\t    T::t = i + 2;\n+\t  }\n+      }\n+  }\n+#pragma omp sections lastprivate (a, t)\n+  {\n+  #pragma omp section\n+    {\n+      a = 5;\n+      t = 6;\n+    }\n+  }\n+#pragma omp for firstprivate (a, t) lastprivate (a, t)\n+  for (int i = 0; i < 10; i++)\n+    {\n+      int q20 = a + t;\n+      if (i == 9)\n+\t{\n+\t  a = i;\n+\t  T::t = i + 2;\n+\t}\n+    }\n+#pragma omp parallel sections lastprivate (a, t)\n+  {\n+  #pragma omp section\n+    {\n+      a = 5;\n+      t = 6;\n+    }\n+  }\n+#pragma omp parallel\n+  {\n+    #pragma omp task firstprivate (a, t)\n+    {\n+      S::a++;\n+      t++;\n+    }\n+  }\n+#pragma omp parallel\n+  {\n+    #pragma omp taskloop firstprivate (a, t) lastprivate (t)\n+    for (int i = 0; i < a; i++)\n+      t++;\n+  }\n+#pragma omp taskloop firstprivate (a, t) lastprivate (t)\n+  for (int i = 0; i < a; i++)\n+    t++;\n+  a = 1;\n+  t = 0;\n+#pragma omp parallel sections reduction (*: S::a) reduction (+: t)\n+  {\n+    {\n+      a = 1;\n+      t = 2;\n+    }\n+    #pragma omp section\n+    {\n+      a = 2;\n+      t = 3;\n+    }\n+    #pragma omp section\n+    {\n+      a = 3;\n+      t = 4;\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void\n+V<T>::foo ()\n+{\n+#pragma omp parallel firstprivate (a, U<T>::t)\n+  {\n+    int *q1 = &a;\n+    int *q2 = &this->a;\n+    int q3 = a;\n+    int q4 = this->a;\n+    int *q5 = &(U<T>::t);\n+    int *q6 = &this->U<T>::t;\n+    int q7 = U<T>::t;\n+    int q8 = this->U<T>::t;\n+    int q9 = U<T>::t;\n+    int q10 = this->U<T>::t;\n+    int &q11 = a;\n+    int &q12 = this->a;\n+    int &q13 = U<T>::t;\n+    int &q14 = this->U<T>::t;\n+    int &q15 = V::a;\n+    int &q16 = this->V::a;\n+    int &q17 = U<T>::t;\n+    int &q18 = this->U<T>::t;\n+  }\n+#pragma omp parallel private (a, U<T>::t)\n+  {\n+    a = 7;\n+    V::a += 9;\n+    U<T>::t = 10;\n+    U<T>::t += 11;\n+  }\n+#pragma omp parallel\n+  {\n+  #pragma omp sections lastprivate (V::a, U<T>::t)\n+    {\n+    #pragma omp section\n+      {\n+\tV::a = 6;\n+\tU<T>::t = 8;\n+      }\n+    }\n+  }\n+#pragma omp parallel\n+  {\n+  #pragma omp for firstprivate (a, U<T>::t) lastprivate (a, U<T>::t)\n+    for (int i = 0; i < 10; i++)\n+      {\n+\tint q19 = a + U<T>::t;\n+\tif (i == 9)\n+\t  {\n+\t    a = i;\n+\t    U<T>::t = i + 2;\n+\t  }\n+      }\n+  }\n+#pragma omp sections lastprivate (a, U<T>::t)\n+  {\n+  #pragma omp section\n+    {\n+      a = 5;\n+      U<T>::t = 6;\n+    }\n+  }\n+#pragma omp for firstprivate (a, U<T>::t) lastprivate (a, U<T>::t)\n+  for (int i = 0; i < 10; i++)\n+    {\n+      int q20 = a + U<T>::t;\n+      if (i == 9)\n+\t{\n+\t  a = i;\n+\t  U<T>::t = i + 2;\n+\t}\n+    }\n+#pragma omp parallel sections lastprivate (a, U<T>::t)\n+  {\n+  #pragma omp section\n+    {\n+      a = 5;\n+      U<T>::t = 6;\n+    }\n+  }\n+#pragma omp parallel\n+  {\n+    #pragma omp task firstprivate (a, U<T>::t)\n+    {\n+      V::a++;\n+      U<T>::t++;\n+    }\n+  }\n+#pragma omp parallel\n+  {\n+    #pragma omp taskloop firstprivate (a, U<T>::t) lastprivate (U<T>::t)\n+    for (int i = 0; i < a; i++)\n+      U<T>::t++;\n+  }\n+#pragma omp taskloop firstprivate (a, U<T>::t) lastprivate (U<T>::t)\n+  for (int i = 0; i < a; i++)\n+    U<T>::t++;\n+  a = 1;\n+  U<T>::t = 0;\n+#pragma omp parallel sections reduction (*: V::a) reduction (+: U<T>::t)\n+  {\n+    {\n+      a = 1;\n+      U<T>::t = 2;\n+    }\n+    #pragma omp section\n+    {\n+      a = 2;\n+      U<T>::t = 3;\n+    }\n+    #pragma omp section\n+    {\n+      a = 3;\n+      U<T>::t = 4;\n+    }\n+  }\n+}\n+\n+void\n+bar ()\n+{\n+  V<int> v;\n+  v.foo ();\n+}"}, {"sha": "97c03952a13d50aac4637f21e205e9bcbab025f7", "filename": "gcc/testsuite/g++.dg/gomp/member-2.C", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-2.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,168 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+int d;\n+\n+struct A\n+{\n+  A () : a(2), b(3), c(d) {}\n+  A (int x) : a(2), b(x), c(d) {}\n+  int a;\n+  A (const A &);\n+  A &operator= (const A &);\n+  const A &operator= (const A &) const;\n+  mutable int b;\n+  int &c;\n+};\n+\n+struct B : public A\n+{\n+  B () : h(5) {}\n+  ~B ();\n+  B (const B &);\n+  A e;\n+  mutable A f;\n+  const A g;\n+  const int h;\n+  int m1 ();\n+  int m2 ();\n+  int m3 () const;\n+  int m4 () const;\n+};\n+\n+void foo (A &);\n+\n+#pragma omp declare reduction (+:A:omp_out.b += omp_in.b) initializer (foo (omp_priv))\n+\n+int\n+B::m1 ()\n+{\n+  #pragma omp parallel private (a, b, c, e, f, g)\n+    ;\n+  #pragma omp parallel firstprivate (a, b, c, e, f, g)\n+    ;\n+  #pragma omp parallel for lastprivate (a, b, c, e, f, g)\n+    for (int i = 0; i < 10; i++)\n+      ;\n+  #pragma omp simd linear (a, b, c : 1)\n+    for (int i = 0; i < 10; i++)\n+      {\n+\ta++;\n+\tb++;\n+\tc++;\n+      }\n+  #pragma omp parallel for reduction (+:a, b, c, e, f)\n+    for (int i = 0; i < 10; i++)\n+      ;\n+  return 0;\n+}\n+\n+int\n+B::m2 ()\n+{\n+  #pragma omp parallel private (h)\t// { dg-error \"is predetermined .shared. for .private.\" }\n+    ;\n+  #pragma omp parallel firstprivate (h)\n+    ;\n+  #pragma omp parallel for lastprivate (h)\t// { dg-error \"is predetermined .shared. for .lastprivate.\" }\n+    for (int i = 0; i < 10; i++)\n+      ;\n+  #pragma omp simd linear (h : 1)\t// { dg-error \"is predetermined .shared. for .linear.\" }\n+    for (int i = 0; i < 10; i++)\n+      ;\n+  #pragma omp parallel for reduction (+:h)\t// { dg-error \"is predetermined .shared. for .reduction.\" }\n+    for (int i = 0; i < 10; i++)\n+      ;\n+  #pragma omp parallel for reduction (+:g)\t// { dg-error \"has const type for .reduction.\" }\n+    for (int i = 0; i < 10; i++)\n+      ;\n+  #pragma omp parallel shared (a)\t// { dg-error \"is not a variable in clause\" }\n+    ;\n+  #pragma omp parallel shared (b)\t// { dg-error \"is not a variable in clause\" }\n+    ;\n+  #pragma omp parallel shared (c)\t// { dg-error \"is not a variable in clause\" }\n+    ;\n+  #pragma omp parallel shared (e)\t// { dg-error \"is not a variable in clause\" }\n+    ;\n+  #pragma omp parallel shared (f)\t// { dg-error \"is not a variable in clause\" }\n+    ;\n+  #pragma omp parallel shared (g)\t// { dg-error \"is not a variable in clause\" }\n+    ;\n+  #pragma omp parallel shared (h)\t// { dg-error \"is not a variable in clause\" }\n+    ;\n+  return 0;\n+}\n+\n+int\n+B::m3 () const\n+{\n+  #pragma omp parallel private (b, c, e, f, g)\n+    ;\n+  #pragma omp parallel firstprivate (b, c, e, f, g)\n+    ;\n+  #pragma omp parallel for lastprivate (b, c, e, f, g)\n+    for (int i = 0; i < 10; i++)\n+      ;\n+  #pragma omp simd linear (b, c : 1)\n+    for (int i = 0; i < 10; i++)\n+      {\n+\tb++;\n+\tc++;\n+      }\n+  #pragma omp parallel for reduction (+:b, c, f)\n+    for (int i = 0; i < 10; i++)\n+      ;\n+  return 0;\n+}\n+\n+int\n+B::m4 () const\n+{\n+  #pragma omp parallel private (a)\t// { dg-error \"is predetermined .shared. for .private.\" }\n+    ;\n+  #pragma omp parallel firstprivate (a)\n+    ;\n+  #pragma omp parallel for lastprivate (a)\t// { dg-error \"is predetermined .shared. for .lastprivate.\" }\n+    for (int i = 0; i < 10; i++)\n+      ;\n+  #pragma omp simd linear (a : 1)\t// { dg-error \"is predetermined .shared. for .linear.\" }\n+    for (int i = 0; i < 10; i++)\n+      ;\n+  #pragma omp parallel for reduction (+:a)\t// { dg-error \"is predetermined .shared. for .reduction.\" }\n+    for (int i = 0; i < 10; i++)\n+      ;\n+  #pragma omp parallel private (h)\t// { dg-error \"is predetermined .shared. for .private.\" }\n+    ;\n+  #pragma omp parallel firstprivate (h)\n+    ;\n+  #pragma omp parallel for lastprivate (h)\t// { dg-error \"is predetermined .shared. for .lastprivate.\" }\n+    for (int i = 0; i < 10; i++)\n+      ;\n+  #pragma omp simd linear (h : 1)\t// { dg-error \"is predetermined .shared. for .linear.\" }\n+    for (int i = 0; i < 10; i++)\n+      ;\n+  #pragma omp parallel for reduction (+:h)\t// { dg-error \"is predetermined .shared. for .reduction.\" }\n+    for (int i = 0; i < 10; i++)\n+      ;\n+  #pragma omp parallel for reduction (+:e)\t// { dg-error \"has const type for .reduction.\" }\n+    for (int i = 0; i < 10; i++)\n+      ;\n+  #pragma omp parallel for reduction (+:g)\t// { dg-error \"has const type for .reduction.\" }\n+    for (int i = 0; i < 10; i++)\n+      ;\n+  #pragma omp parallel shared (a)\t// { dg-error \"is not a variable in clause\" }\n+    ;\n+  #pragma omp parallel shared (b)\t// { dg-error \"is not a variable in clause\" }\n+    ;\n+  #pragma omp parallel shared (c)\t// { dg-error \"is not a variable in clause\" }\n+    ;\n+  #pragma omp parallel shared (e)\t// { dg-error \"is not a variable in clause\" }\n+    ;\n+  #pragma omp parallel shared (f)\t// { dg-error \"is not a variable in clause\" }\n+    ;\n+  #pragma omp parallel shared (g)\t// { dg-error \"is not a variable in clause\" }\n+    ;\n+  #pragma omp parallel shared (h)\t// { dg-error \"is not a variable in clause\" }\n+    ;\n+  return 0;\n+}"}, {"sha": "ac4c609c90c2abbf334502533ba88173ff29aab6", "filename": "gcc/testsuite/g++.dg/gomp/pr66571-2.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr66571-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr66571-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr66571-2.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,36 @@\n+// PR c++/66571\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+template <typename T>\n+extern void bar (T, T, T, T);\n+\n+template <typename T>\n+void\n+foo (T a, T b, T c, T d)\n+{\n+  #pragma omp parallel for simd private (a) firstprivate (b) lastprivate (c) linear (d:2)\n+  for (int i = 0; i < 10; i++)\n+    bar<T> (a, b, c, d), d += 2;\n+  #pragma omp parallel private (c)\n+    #pragma omp single copyprivate (c)\n+      bar<T> (a, b, c, d);\n+  T e = a;\n+  T f = b;\n+  T g = c;\n+  T h = d;\n+  #pragma omp parallel for simd private (e) firstprivate (f) lastprivate (g) linear (h:2)\n+  for (int i = 0; i < 10; i++)\n+    bar<T> (e, f, g, h), h += 2;\n+  #pragma omp parallel private (g)\n+    #pragma omp single copyprivate (g)\n+      bar<T> (e, f, g, h);\n+}\n+\n+void\n+baz ()\n+{\n+  int a = 0, b = 0, c = 0, d = 0;\n+  foo <int> (a, b, c, d);\n+  foo <int &> (a, b, c, d);\n+}"}, {"sha": "8270b7cf494522e4988bb3fac6374b48f6348c92", "filename": "gcc/testsuite/g++.dg/gomp/pr67504.C", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr67504.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr67504.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr67504.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -12,4 +12,8 @@ foo (T x)\n   #pragma omp for collapse (x + 1) // { dg-error \"collapse argument needs positive constant integer expression\" }\n   for (int i = 0; i < 10; i++)\n     ;\n+  #pragma omp for ordered (x + 1) // { dg-error \"ordered argument needs positive constant integer expression\" }\n+  for (int i = 0; i < 10; i++)\n+    for (int j = 0; j < 10; j++)\n+      ;\n }"}, {"sha": "da8cb74d1fa25038452d6a933ea259f5425cb763", "filename": "gcc/testsuite/g++.dg/gomp/pr67522.C", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr67522.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr67522.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr67522.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -17,6 +17,10 @@ foo (void)\n \n   #pragma omp task depend (inout: S[0:10])\t// { dg-error \"is not a variable in\" }\n   ;\n+\n+  #pragma omp for reduction (+:S[0:10])\t\t// { dg-error \"is not a variable in\" }\n+  for (int i = 0; i < 16; i++)\n+    ;\n }\n \n void"}, {"sha": "d53ca93d6f1d4edb6bdaea084e44c2ba4a7609c5", "filename": "gcc/testsuite/g++.dg/gomp/reference-1.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Freference-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Freference-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Freference-1.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile }\n+\n+struct S;\t// { dg-message \"forward declaration\" }\n+void foo (S &);\n+\n+void\n+f1 (S &x)\t// { dg-error \"has incomplete type\" }\n+{\n+#pragma omp parallel private (x)\n+  foo (x);\n+}\n+\n+void\n+f2 (S &x)\t// { dg-error \"has incomplete type\" }\n+{\n+#pragma omp parallel firstprivate (x)\n+  foo (x);\n+}\n+\n+void\n+f3 (S &x)\t// { dg-error \"has incomplete type\" }\n+{\n+#pragma omp parallel for lastprivate (x)\n+  for (int i = 0; i < 10; i++)\n+    foo (x);\n+}"}, {"sha": "982d36c7aa06b6acd606221649499d729c944c8a", "filename": "gcc/testsuite/g++.dg/gomp/sink-1.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsink-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsink-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsink-1.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+\n+void bar (int, int, int);\n+\n+template<typename T>\n+void baz ()\n+{\n+  T i, j;\n+#pragma omp parallel for ordered(2)\n+  for (i=0; i < 100; ++i)\n+    for (j=0; j < 100; ++j)\n+      {\n+#pragma omp ordered depend(sink:i-3,j)\n+\tbar (i, j, 0);\n+#pragma omp ordered depend(source)\n+      }\n+}\n+\n+int main()\n+{\n+  baz<int>();\n+}"}, {"sha": "d1681a77aadcf3495651b32b45fd273d7fba41de", "filename": "gcc/testsuite/g++.dg/gomp/sink-2.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsink-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsink-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsink-2.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do compile } */\n+\n+/* Tests iterators are allowed in ordered loops and that we keep track\n+   of the original iterator DECL for diagnostic purposes.  */\n+\n+#include <iostream>\n+#include <vector>\n+\n+/* Test plain iterator.  */\n+void foo1 ()\n+{\n+  std::vector<int> v;\n+  for (int i=1; i<=5; i++) v.push_back(i);\n+\n+  std::vector<int>::const_iterator it;\n+\n+#pragma omp parallel for ordered(1)\n+  for (it = v.begin(); it < v.end(); ++it)\n+    {\n+#pragma omp ordered depend(sink:it-1)\n+    std::cout << *it << '\\n';\n+#pragma omp ordered depend(source)\n+    }\n+}\n+\n+/* Test non-dependent iterator in a template.  */\n+template <int N>\n+void foo2 ()\n+{\n+  std::vector<int> v;\n+  for (int i=1; i<=5; i++) v.push_back(i);\n+\n+  std::vector<int>::const_iterator it;\n+#pragma omp parallel for ordered(1)\n+  for (it = v.begin(); it < v.end(); ++it)\n+    {\n+#pragma omp ordered depend(sink:it-1)\n+    std::cout << *it << '\\n';\n+#pragma omp ordered depend(source)\n+    }\n+}\n+\n+/* Test dependent iterator in a template.  */\n+template <typename T>\n+void foo3 ()\n+{\n+  std::vector<T> v;\n+  for (int i=1; i<=5; i++) v.push_back(i);\n+\n+  typename std::vector<T>::const_iterator it;\n+#pragma omp parallel for ordered(1)\n+  for (it = v.begin(); it < v.end(); ++it)\n+    {\n+#pragma omp ordered depend(sink:it-1)\n+    std::cout << *it << '\\n';\n+#pragma omp ordered depend(source)\n+    }\n+}  \n+\n+int main ()\n+{\n+  foo2 <0> ();\n+  foo3 <int> ();\n+}"}, {"sha": "4271d66faefa65856dba1197964c61a597f3de7b", "filename": "gcc/testsuite/g++.dg/gomp/sink-3.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsink-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsink-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsink-3.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+/* Test that we adjust pointer offsets for sink variables\n+   correctly.  */\n+\n+typedef struct {\n+    char stuff[400];\n+} foo;\n+\n+foo *end, *begin, *p;\n+\n+template<int N>\n+void\n+funk ()\n+{\n+  int i,j;\n+#pragma omp parallel for ordered(1)\n+  for (p=end; p > begin; p--)\n+    {\n+#pragma omp ordered depend(sink:p+1)\n+      void bar ();\n+        bar();\n+#pragma omp ordered depend(source)\n+    }\n+}\n+\n+void foobar()\n+{\n+  funk<3>();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"depend\\\\(sink:p\\\\+400\\\\)\" 1 \"gimple\" } } */"}, {"sha": "7f40279caf7e079b5229f95ec93193802768dcc8", "filename": "gcc/testsuite/g++.dg/gomp/task-1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftask-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftask-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftask-1.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -10,8 +10,8 @@ const A a;\n void foo (A &p)\n {\n   const A &q = a;\n-#pragma omp task\t// { dg-error \"has reference type\" }\n+#pragma omp task\n   bar (p);\n-#pragma omp task\t// { dg-error \"has reference type\" }\n+#pragma omp task\n   bar (q);\n }"}, {"sha": "0e2dd8caa23ead7306df9135268d4a523071d861", "filename": "gcc/testsuite/g++.dg/gomp/this-1.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fthis-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fthis-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fthis-1.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,68 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+struct S\n+{\n+  #pragma omp declare simd linear(this)\t\t// { dg-error \"is not an function argument\" }\n+  static void foo ();\n+  void bar ();\n+};\n+\n+void\n+S::bar ()\n+{\n+  #pragma omp parallel firstprivate (this)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+    ;\n+  #pragma omp parallel for lastprivate (this)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  for (int i = 0; i < 10; i++)\n+    ;\n+  #pragma omp parallel shared (this)\t\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+    ;\n+  #pragma omp for linear (this)\t\t\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  for (int i = 0; i < 10; i++)\n+    ;\n+  #pragma omp task depend(inout: this)\t\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+    ;\n+  #pragma omp task depend(inout: this[0])\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+    ;\n+  #pragma omp parallel private (this)\t\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  {\n+    #pragma omp single copyprivate (this)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+    ;\n+  }\n+}\n+\n+template <int N>\n+struct T\n+{\n+  #pragma omp declare simd linear(this)\t\t// { dg-error \"is not an function argument\" }\n+  static void foo ();\n+  void bar ();\n+};\n+\n+template <int N>\n+void\n+T<N>::bar ()\n+{\n+  #pragma omp parallel firstprivate (this)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+    ;\n+  #pragma omp parallel for lastprivate (this)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  for (int i = 0; i < 10; i++)\n+    ;\n+  #pragma omp parallel shared (this)\t\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+    ;\n+  #pragma omp for linear (this)\t\t\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  for (int i = 0; i < 10; i++)\n+    ;\n+  #pragma omp task depend(inout: this)\t\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+    ;\n+  #pragma omp task depend(inout: this[0])\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+    ;\n+  #pragma omp parallel private (this)\t\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  {\n+    #pragma omp single copyprivate (this)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+    ;\n+  }\n+}\n+\n+template struct T<0>;"}, {"sha": "d03b8a0728efa2b343b7a8023d95d2d6b848ceaa", "filename": "gcc/testsuite/g++.dg/gomp/this-2.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fthis-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fthis-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fthis-2.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+struct S\n+{\n+  void bar (int);\n+};\n+\n+void\n+S::bar (int x)\n+{\n+  #pragma omp target map (this, x)\t\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+    ;\n+  #pragma omp target map (this[0], x)\t\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+    ;\n+  #pragma omp target update to (this, x)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  #pragma omp target update to (this[0], x)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  #pragma omp target update from (this, x)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  #pragma omp target update from (this[1], x)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+}\n+\n+template <int N>\n+struct T\n+{\n+  void bar (int);\n+};\n+\n+template <int N>\n+void\n+T<N>::bar (int x)\n+{\n+  #pragma omp target map (this, x)\t\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+    ;\n+  #pragma omp target map (this[0], x)\t\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+    ;\n+  #pragma omp target update to (this, x)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  #pragma omp target update to (this[0], x)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  #pragma omp target update from (this, x)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  #pragma omp target update from (this[1], x)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+}\n+\n+template struct T<0>;"}, {"sha": "1a1b982fc2034fc9e31f7bfdb2f3086d5a0f8beb", "filename": "gcc/testsuite/g++.dg/vect/simd-clone-2.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-2.cc?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,55 @@\n+// { dg-require-effective-target vect_simd_clones }\n+// { dg-additional-options \"-fopenmp-simd -fno-inline -DONE_FILE\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+#include \"../../gcc.dg/vect/tree-vect.h\"\n+\n+#ifdef ONE_FILE\n+#include \"simd-clone-3.cc\"\n+#else\n+#include \"simd-clone-2.h\"\n+#endif\n+\n+T b __attribute__((aligned (32)));\n+\n+void\n+do_main ()\n+{\n+  int i, r = 0;\n+  S a[64];\n+  for (i = 0; i < 64; i++)\n+    {\n+      a[i].s = i;\n+      b.t[i] = i;\n+    }\n+  #pragma omp simd reduction(+:r)\n+  for (i = 0; i < 64; i++)\n+    r += a[16].f0 (i);\n+  if (r != 64 * 63 / 2 + 64 * 16)\n+    __builtin_abort ();\n+  r = 0;\n+  #pragma omp simd reduction(+:r)\n+  for (i = 0; i < 64; i++)\n+    r += a[32].f1 (i);\n+  if (r != 64 * 63 / 2 + 64 * 32)\n+    __builtin_abort ();\n+  r = 0;\n+  #pragma omp simd reduction(+:r)\n+  for (i = 0; i < 64; i++)\n+    r += a[i].f2 (i);\n+  if (r != 64 * 63)\n+    __builtin_abort ();\n+  r = 0;\n+  #pragma omp simd reduction(+:r)\n+  for (i = 0; i < 64; i++)\n+    r += b.f3 (i);\n+  if (r != 64 * 63 / 2)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  do_main ();\n+}"}, {"sha": "d082330f6b7b048fe162dd6d0a10da94ac4a2aee", "filename": "gcc/testsuite/g++.dg/vect/simd-clone-2.h", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-2.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,17 @@\n+struct S\n+{\n+  int s;\n+  #pragma omp declare simd notinbranch\n+  int f0 (int x);\n+  #pragma omp declare simd notinbranch uniform(this)\n+  int f1 (int x);\n+  #pragma omp declare simd notinbranch linear(this:sizeof(this)/sizeof(this))\n+  int f2 (int x);\n+};\n+\n+struct T\n+{\n+  int t[64];\n+  #pragma omp declare simd aligned(this:32) uniform(this) linear(x)\n+  int f3 (int x);\n+};"}, {"sha": "1057a7eb5f6a51dcf5b756af665e7af368e0774c", "filename": "gcc/testsuite/g++.dg/vect/simd-clone-3.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-3.cc?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,34 @@\n+// { dg-require-effective-target vect_simd_clones }\n+// { dg-additional-options \"-fopenmp-simd -fno-inline\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-additional-sources \"simd-clone-2.cc\" }\n+\n+#include \"simd-clone-2.h\"\n+\n+#pragma omp declare simd notinbranch\n+int\n+S::f0 (int x)\n+{\n+  return x + s;\n+}\n+\n+#pragma omp declare simd notinbranch uniform(this)\n+int\n+S::f1 (int x)\n+{\n+  return x + s;\n+}\n+\n+#pragma omp declare simd notinbranch linear(this:sizeof(this)/sizeof(this))\n+int\n+S::f2 (int x)\n+{\n+  return x + this->S::s;\n+}\n+\n+#pragma omp declare simd uniform(this) aligned(this:32) linear(x)\n+int\n+T::f3 (int x)\n+{\n+  return t[x];\n+}"}, {"sha": "32bdfd446ae2c46e7dfd7d162ea40565bee4c7c9", "filename": "gcc/testsuite/g++.dg/vect/simd-clone-4.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-4.cc?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,55 @@\n+// { dg-require-effective-target vect_simd_clones }\n+// { dg-additional-options \"-fopenmp-simd -fno-inline -DONE_FILE\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+#include \"../../gcc.dg/vect/tree-vect.h\"\n+\n+#ifdef ONE_FILE\n+#include \"simd-clone-5.cc\"\n+#else\n+#include \"simd-clone-4.h\"\n+#endif\n+\n+T<0> b __attribute__((aligned (32)));\n+\n+void\n+do_main ()\n+{\n+  int i, r = 0;\n+  S<0> a[64];\n+  for (i = 0; i < 64; i++)\n+    {\n+      a[i].s = i;\n+      b.t[i] = i;\n+    }\n+  #pragma omp simd reduction(+:r)\n+  for (i = 0; i < 64; i++)\n+    r += a[16].f0 (i);\n+  if (r != 64 * 63 / 2 + 64 * 16)\n+    __builtin_abort ();\n+  r = 0;\n+  #pragma omp simd reduction(+:r)\n+  for (i = 0; i < 64; i++)\n+    r += a[32].f1 (i);\n+  if (r != 64 * 63 / 2 + 64 * 32)\n+    __builtin_abort ();\n+  r = 0;\n+  #pragma omp simd reduction(+:r)\n+  for (i = 0; i < 64; i++)\n+    r += a[i].f2 (i);\n+  if (r != 64 * 63)\n+    __builtin_abort ();\n+  r = 0;\n+  #pragma omp simd reduction(+:r)\n+  for (i = 0; i < 64; i++)\n+    r += b.f3 (i);\n+  if (r != 64 * 63 / 2)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  do_main ();\n+}"}, {"sha": "2b0244cac9c16e6b2c0c1c79cb4a09fe2819f75d", "filename": "gcc/testsuite/g++.dg/vect/simd-clone-4.h", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-4.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,19 @@\n+template <int N>\n+struct S\n+{\n+  int s;\n+  #pragma omp declare simd notinbranch\n+  int f0 (int x);\n+  #pragma omp declare simd notinbranch uniform(this)\n+  int f1 (int x);\n+  #pragma omp declare simd notinbranch linear(this:sizeof(this)/sizeof(this))\n+  int f2 (int x);\n+};\n+\n+template <int N>\n+struct T\n+{\n+  int t[64];\n+  #pragma omp declare simd aligned(this:32) uniform(this) linear(x)\n+  int f3 (int x);\n+};"}, {"sha": "07ec8a8079efc327f9d0e9702133416857241009", "filename": "gcc/testsuite/g++.dg/vect/simd-clone-5.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-clone-5.cc?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,41 @@\n+// { dg-require-effective-target vect_simd_clones }\n+// { dg-additional-options \"-fopenmp-simd -fno-inline\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-additional-sources \"simd-clone-4.cc\" }\n+\n+#include \"simd-clone-4.h\"\n+\n+#pragma omp declare simd notinbranch\n+template <int N>\n+int\n+S<N>::f0 (int x)\n+{\n+  return x + s;\n+}\n+\n+#pragma omp declare simd notinbranch uniform(this)\n+template <int N>\n+int\n+S<N>::f1 (int x)\n+{\n+  return x + s;\n+}\n+\n+#pragma omp declare simd notinbranch linear(this:sizeof(this)/sizeof(this))\n+template <int N>\n+int\n+S<N>::f2 (int x)\n+{\n+  return x + this->S::s;\n+}\n+\n+#pragma omp declare simd uniform(this) aligned(this:32) linear(x)\n+template <int N>\n+int\n+T<N>::f3 (int x)\n+{\n+  return t[x];\n+}\n+\n+template struct S<0>;\n+template struct T<0>;"}, {"sha": "c2d1fc69ed49859f9e8b77b8f2a05f554e3f7ec0", "filename": "gcc/testsuite/gcc.dg/gomp/clause-1.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -34,6 +34,9 @@ foo (int x)\n #pragma omp p for lastprivate (x, x) /* { dg-error \"more than once\" } */\n   for (i = 0; i < 10; i++)\n     ;\n+#pragma omp p for linear (x, x) /* { dg-error \"more than once\" } */\n+  for (i = 0; i < 10; i++)\n+    ;\n #pragma omp single private (x) copyprivate (x) /* { dg-error \"more than\" } */\n     ;\n #pragma omp p shared (bar) /* { dg-error \"is not a variable\" } */\n@@ -46,7 +49,7 @@ foo (int x)\n     ;\n #pragma omp p reduction (*:s) /* { dg-error \"user defined reduction not found for\" } */\n     ;\n-#pragma omp p reduction (-:a) /* { dg-error \"user defined reduction not found for\" } */\n+#pragma omp p reduction (-:a)\n     ;\n   d = 0;\n #pragma omp p reduction (*:d)\n@@ -80,6 +83,9 @@ foo (int x)\n     ;\n #pragma omp p reduction (*:t) /* { dg-error \"predetermined 'threadprivate\" } */\n     ;\n+#pragma omp p for linear (t) /* { dg-error \"predetermined 'threadprivate\" } */\n+  for (i = 0; i < 10; i++)\n+    ;\n #pragma omp p shared (c) /* { dg-error \"predetermined 'shared'\" } */\n     ;\n #pragma omp p private (c) /* { dg-error \"predetermined 'shared'\" } */\n@@ -91,4 +97,7 @@ foo (int x)\n     ;\n #pragma omp p reduction (*:c) /* { dg-error \"predetermined 'shared'\" } */\n     ;\n+#pragma omp p for linear (c) /* { dg-error \"predetermined 'shared'\" } */\n+  for (i = 0; i < 10; i++)\n+    ;\n }"}, {"sha": "0aeb21e6d155890f8190bb67134d50227e0f522b", "filename": "gcc/testsuite/gcc.dg/gomp/reduction-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Freduction-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Freduction-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Freduction-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+struct S {};\n+void foo (void *, void *);\n+void bar (void *, void *);\n+void baz (void *);\n+#pragma omp declare reduction(+:struct S:foo (&omp_out, &omp_in))initializer(bar(&omp_priv, &omp_orig))\n+\n+void\n+test (void)\n+{\n+  struct S b[10];\n+  #pragma omp parallel reduction(+:b[0:5])\t/* { dg-error \"zero length array section\" } */\n+    baz (b);\n+  #pragma omp parallel reduction(+:b[:10])\t/* { dg-error \"zero length array section\" } */\n+    baz (b);\n+  #pragma omp parallel reduction(+:b)\t\t/* { dg-error \"is a zero size array\" } */\n+    baz (b);\n+}"}, {"sha": "d166dac950b2b641230f3c9b483f94270cc00781", "filename": "gcc/testsuite/gcc.dg/gomp/sink-fold-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsink-fold-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsink-fold-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsink-fold-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-omplower\" } */\n+\n+/* Test depend(sink) clause folding.  */\n+\n+int i,j,k, N;\n+\n+extern void bar();\n+\n+void\n+funk ()\n+{\n+#pragma omp parallel for ordered(3)\n+  for (i=0; i < N; i++)\n+    for (j=0; j < N; ++j)\n+      for (k=0; k < N; ++k)\n+    {\n+/* We remove the (sink:i,j-1,k) by virtue of it the i+0.  The remaining\n+   clauses get folded with a GCD of -2 for `i' and a maximum of -2, +2 for\n+   'j' and 'k'.  */\n+#pragma omp ordered \\\n+  depend(sink:i-8,j-2,k+2) \\\n+  depend(sink:i, j-1,k) \\\n+  depend(sink:i-4,j-3,k+6) \\\n+  depend(sink:i-6,j-4,k-6)\n+        bar();\n+#pragma omp ordered depend(source)\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"omp ordered depend\\\\(sink:i-2,j-2,k\\\\+2\\\\)\" 1 \"omplower\" { xfail *-*-* } } } */"}, {"sha": "f3cdaee19008c2ea54766621b37ef4b2cd784c04", "filename": "gcc/testsuite/gcc.dg/gomp/sink-fold-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsink-fold-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsink-fold-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsink-fold-2.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+\n+int i,j, N;\n+\n+extern void bar();\n+\n+void\n+funk ()\n+{\n+#pragma omp parallel for ordered(2)\n+  for (i=0; i < N; i += 3)\n+    for (j=0; j < N; ++j)\n+    {\n+#pragma omp ordered depend(sink:i-8,j-1) /* { dg-warning \"refers to iteration never in the iteration space\" } */\n+#pragma omp ordered depend(sink:i+3,j-1) /* { dg-warning \"waiting for lexically later iteration\" } */\n+        bar();\n+#pragma omp ordered depend(source)\n+    }\n+}"}, {"sha": "d3af18e17e7fa4d82e91ae8b689a29e08edc445e", "filename": "gcc/testsuite/gcc.dg/gomp/sink-fold-3.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsink-fold-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsink-fold-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsink-fold-3.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-omplower\" } */\n+\n+/* Test that we fold sink offsets correctly while taking into account\n+   pointer sizes.  */\n+\n+typedef struct {\n+    char stuff[400];\n+} foo;\n+\n+void\n+funk (foo *begin, foo *end)\n+{\n+  foo *p;\n+#pragma omp parallel for ordered(1)\n+  for (p=end; p > begin; p--)\n+    {\n+#pragma omp ordered depend(sink:p+2) depend(sink:p+4)\n+      void bar ();\n+        bar();\n+#pragma omp ordered depend(source)\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"depend\\\\(sink:p\\\\+800\\\\)\" 1 \"omplower\" } } */"}, {"sha": "675ac7026b67edda2e573367643eb68063559bc2", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-15.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-15.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef N\n+#define N 1024\n+#endif\n+\n+int array[N];\n+\n+#pragma omp declare simd linear(val(b):-3), notinbranch\n+__attribute__((noinline)) int\n+foo (int a, int b)\n+{\n+  return a + b;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+bar ()\n+{\n+  int i;\n+#pragma omp simd\n+  for (i = 0; i < N; ++i)\n+    array[i] = foo (i >> 1, -i * 3);\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  bar ();\n+  for (i = 0; i < N; i++)\n+    if (array[i] != ((i >> 1) + (-3 * i)))\n+      abort ();\n+  return 0;\n+}"}, {"sha": "6b17da718b323e64aeb3685a522fd73d4f3592d0", "filename": "gcc/tree-core.h", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -232,7 +232,10 @@ enum omp_clause_code {\n      Operand 2: OMP_CLAUSE_REDUCTION_MERGE: Stmt-list to merge private var\n                 into the shared one.\n      Operand 3: OMP_CLAUSE_REDUCTION_PLACEHOLDER: A dummy VAR_DECL\n-                placeholder used in OMP_CLAUSE_REDUCTION_{INIT,MERGE}.  */\n+                placeholder used in OMP_CLAUSE_REDUCTION_{INIT,MERGE}.\n+     Operand 4: OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER: Another dummy\n+\t\tVAR_DECL placeholder, used like the above for C/C++ array\n+\t\treductions.  */\n   OMP_CLAUSE_REDUCTION,\n \n   /* OpenMP clause: copyin (variable_list).  */\n@@ -253,6 +256,13 @@ enum omp_clause_code {\n   /* OpenMP clause: uniform (argument-list).  */\n   OMP_CLAUSE_UNIFORM,\n \n+  /* OpenMP clause: to (extended-list).\n+     Only when it appears in declare target.  */\n+  OMP_CLAUSE_TO_DECLARE,\n+\n+  /* OpenMP clause: link (variable-list).  */\n+  OMP_CLAUSE_LINK,\n+\n   /* OpenMP clause: from (variable-list).  */\n   OMP_CLAUSE_FROM,\n \n@@ -267,6 +277,12 @@ enum omp_clause_code {\n      OpenMP clause: map ({alloc:,to:,from:,tofrom:,}variable-list).  */\n   OMP_CLAUSE_MAP,\n \n+  /* OpenMP clause: use_device_ptr (variable-list).  */\n+  OMP_CLAUSE_USE_DEVICE_PTR,\n+\n+  /* OpenMP clause: is_device_ptr (variable-list).  */\n+  OMP_CLAUSE_IS_DEVICE_PTR,\n+\n   /* Internal structure to hold OpenACC cache directive's variable-list.\n      #pragma acc cache (variable-list).  */\n   OMP_CLAUSE__CACHE_,\n@@ -312,7 +328,7 @@ enum omp_clause_code {\n   /* OpenMP clause: nowait.  */\n   OMP_CLAUSE_NOWAIT,\n \n-  /* OpenMP clause: ordered.  */\n+  /* OpenMP clause: ordered [(constant-integer-expression)].  */\n   OMP_CLAUSE_ORDERED,\n \n   /* OpenMP clause: default.  */\n@@ -369,6 +385,30 @@ enum omp_clause_code {\n   /* OpenMP clause: taskgroup.  */\n   OMP_CLAUSE_TASKGROUP,\n \n+  /* OpenMP clause: priority (integer-expression).  */\n+  OMP_CLAUSE_PRIORITY,\n+\n+  /* OpenMP clause: grainsize (integer-expression).  */\n+  OMP_CLAUSE_GRAINSIZE,\n+\n+  /* OpenMP clause: num_tasks (integer-expression).  */\n+  OMP_CLAUSE_NUM_TASKS,\n+\n+  /* OpenMP clause: nogroup.  */\n+  OMP_CLAUSE_NOGROUP,\n+\n+  /* OpenMP clause: threads.  */\n+  OMP_CLAUSE_THREADS,\n+\n+  /* OpenMP clause: simd.  */\n+  OMP_CLAUSE_SIMD,\n+\n+  /* OpenMP clause: hint (integer-expression).  */\n+  OMP_CLAUSE_HINT,\n+\n+  /* OpenMP clause: defaultmap (tofrom: scalar).  */\n+  OMP_CLAUSE_DEFAULTMAP,\n+\n   /* Internally used only clause, holding SIMD uid.  */\n   OMP_CLAUSE__SIMDUID_,\n \n@@ -1218,6 +1258,8 @@ enum omp_clause_depend_kind\n   OMP_CLAUSE_DEPEND_IN,\n   OMP_CLAUSE_DEPEND_OUT,\n   OMP_CLAUSE_DEPEND_INOUT,\n+  OMP_CLAUSE_DEPEND_SOURCE,\n+  OMP_CLAUSE_DEPEND_SINK,\n   OMP_CLAUSE_DEPEND_LAST\n };\n \n@@ -1232,6 +1274,14 @@ enum omp_clause_proc_bind_kind\n   OMP_CLAUSE_PROC_BIND_LAST\n };\n \n+enum omp_clause_linear_kind\n+{\n+  OMP_CLAUSE_LINEAR_DEFAULT,\n+  OMP_CLAUSE_LINEAR_REF,\n+  OMP_CLAUSE_LINEAR_VAL,\n+  OMP_CLAUSE_LINEAR_UVAL\n+};\n+\n struct GTY(()) tree_exp {\n   struct tree_typed typed;\n   location_t locus;\n@@ -1293,9 +1343,11 @@ struct GTY(()) tree_omp_clause {\n     enum omp_clause_schedule_kind  schedule_kind;\n     enum omp_clause_depend_kind    depend_kind;\n     /* See include/gomp-constants.h for enum gomp_map_kind's values.  */\n-    unsigned char\t\t   map_kind;\n+    unsigned int\t\t   map_kind;\n     enum omp_clause_proc_bind_kind proc_bind_kind;\n     enum tree_code                 reduction_code;\n+    enum omp_clause_linear_kind    linear_kind;\n+    enum tree_code                 if_modifier;\n   } GTY ((skip)) subcode;\n \n   /* The gimplification of OMP_CLAUSE_REDUCTION_{INIT,MERGE} for omp-low's"}, {"sha": "b8269eff63341783ca46d7bc30b0215c6dd0db9e", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1481,7 +1481,9 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \n \tcase GIMPLE_OMP_ORDERED:\n \t  s1 = remap_gimple_seq (gimple_omp_body (stmt), id);\n-\t  copy = gimple_build_omp_ordered (s1);\n+\t  copy = gimple_build_omp_ordered\n+\t\t   (s1,\n+\t\t    gimple_omp_ordered_clauses (as_a <gomp_ordered *> (stmt)));\n \t  break;\n \n \tcase GIMPLE_OMP_SECTION:\n@@ -1517,8 +1519,10 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \tcase GIMPLE_OMP_CRITICAL:\n \t  s1 = remap_gimple_seq (gimple_omp_body (stmt), id);\n \t  copy = gimple_build_omp_critical (s1,\n-\t\t\t\t\t    gimple_omp_critical_name (\n-\t\t\t\t\t      as_a <gomp_critical *> (stmt)));\n+\t\t\t\t\t    gimple_omp_critical_name\n+\t\t\t\t\t      (as_a <gomp_critical *> (stmt)),\n+\t\t\t\t\t    gimple_omp_critical_clauses\n+\t\t\t\t\t      (as_a <gomp_critical *> (stmt)));\n \t  break;\n \n \tcase GIMPLE_TRANSACTION:\n@@ -1615,6 +1619,11 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \t    gimple_call_set_tail (call_stmt, false);\n \t  if (gimple_call_from_thunk_p (call_stmt))\n \t    gimple_call_set_from_thunk (call_stmt, false);\n+\t  if (gimple_call_internal_p (call_stmt)\n+\t      && IN_RANGE (gimple_call_internal_fn (call_stmt),\n+\t\t\t   IFN_GOMP_SIMD_ORDERED_START,\n+\t\t\t   IFN_GOMP_SIMD_ORDERED_END))\n+\t    DECL_STRUCT_FUNCTION (id->dst_fn)->has_simduid_loops = true;\n \t}\n \n       /* Remap the region numbers for __builtin_eh_{pointer,filter},"}, {"sha": "0f509334ef14f150ba6666db9cdc33d0b9c06fba", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1102,6 +1102,10 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n \tcase OMP_CLAUSE_COPYPRIVATE:\n \tcase OMP_CLAUSE_SHARED:\n+\tcase OMP_CLAUSE_TO_DECLARE:\n+\tcase OMP_CLAUSE_LINK:\n+\tcase OMP_CLAUSE_USE_DEVICE_PTR:\n+\tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \tdo_decl_clause:\n \t  decl = OMP_CLAUSE_DECL (clause);\n \t  if (TREE_CODE (decl) == VAR_DECL\n@@ -1128,6 +1132,11 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_NUM_TEAMS:\n \tcase OMP_CLAUSE_THREAD_LIMIT:\n \tcase OMP_CLAUSE_SAFELEN:\n+\tcase OMP_CLAUSE_SIMDLEN:\n+\tcase OMP_CLAUSE_PRIORITY:\n+\tcase OMP_CLAUSE_GRAINSIZE:\n+\tcase OMP_CLAUSE_NUM_TASKS:\n+\tcase OMP_CLAUSE_HINT:\n \tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \t  wi->val_only = true;\n \t  wi->is_lhs = false;\n@@ -1192,6 +1201,10 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_MERGEABLE:\n \tcase OMP_CLAUSE_PROC_BIND:\n+\tcase OMP_CLAUSE_NOGROUP:\n+\tcase OMP_CLAUSE_THREADS:\n+\tcase OMP_CLAUSE_SIMD:\n+\tcase OMP_CLAUSE_DEFAULTMAP:\n \t  break;\n \n \tdefault:\n@@ -1212,6 +1225,9 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t\t= DECL_CONTEXT (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause));\n \t      DECL_CONTEXT (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))\n \t\t= info->context;\n+\t      if (OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (clause))\n+\t\tDECL_CONTEXT (OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (clause))\n+\t\t  = info->context;\n \t      walk_body (convert_nonlocal_reference_stmt,\n \t\t\t convert_nonlocal_reference_op, info,\n \t\t\t &OMP_CLAUSE_REDUCTION_GIMPLE_INIT (clause));\n@@ -1220,6 +1236,9 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t\t\t &OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (clause));\n \t      DECL_CONTEXT (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))\n \t\t= old_context;\n+\t      if (OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (clause))\n+\t\tDECL_CONTEXT (OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (clause))\n+\t\t  = old_context;\n \t    }\n \t  break;\n \n@@ -1730,6 +1749,10 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n \tcase OMP_CLAUSE_COPYPRIVATE:\n \tcase OMP_CLAUSE_SHARED:\n+\tcase OMP_CLAUSE_TO_DECLARE:\n+\tcase OMP_CLAUSE_LINK:\n+\tcase OMP_CLAUSE_USE_DEVICE_PTR:\n+\tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \tdo_decl_clause:\n \t  decl = OMP_CLAUSE_DECL (clause);\n \t  if (TREE_CODE (decl) == VAR_DECL\n@@ -1761,6 +1784,11 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_NUM_TEAMS:\n \tcase OMP_CLAUSE_THREAD_LIMIT:\n \tcase OMP_CLAUSE_SAFELEN:\n+\tcase OMP_CLAUSE_SIMDLEN:\n+\tcase OMP_CLAUSE_PRIORITY:\n+\tcase OMP_CLAUSE_GRAINSIZE:\n+\tcase OMP_CLAUSE_NUM_TASKS:\n+\tcase OMP_CLAUSE_HINT:\n \tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \t  wi->val_only = true;\n \t  wi->is_lhs = false;\n@@ -1830,6 +1858,10 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_MERGEABLE:\n \tcase OMP_CLAUSE_PROC_BIND:\n+\tcase OMP_CLAUSE_NOGROUP:\n+\tcase OMP_CLAUSE_THREADS:\n+\tcase OMP_CLAUSE_SIMD:\n+\tcase OMP_CLAUSE_DEFAULTMAP:\n \t  break;\n \n \tdefault:\n@@ -1850,6 +1882,9 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t\t= DECL_CONTEXT (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause));\n \t      DECL_CONTEXT (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))\n \t\t= info->context;\n+\t      if (OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (clause))\n+\t\tDECL_CONTEXT (OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (clause))\n+\t\t  = info->context;\n \t      walk_body (convert_local_reference_stmt,\n \t\t\t convert_local_reference_op, info,\n \t\t\t &OMP_CLAUSE_REDUCTION_GIMPLE_INIT (clause));\n@@ -1858,6 +1893,9 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t\t\t &OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (clause));\n \t      DECL_CONTEXT (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))\n \t\t= old_context;\n+\t      if (OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (clause))\n+\t\tDECL_CONTEXT (OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (clause))\n+\t\t  = old_context;\n \t    }\n \t  break;\n "}, {"sha": "11f9005110785ae8a316149e13471e49f6d224cc", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 159, "deletions": 2, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -330,6 +330,12 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n     case OMP_CLAUSE_UNIFORM:\n       name = \"uniform\";\n       goto print_remap;\n+    case OMP_CLAUSE_USE_DEVICE_PTR:\n+      name = \"use_device_ptr\";\n+      goto print_remap;\n+    case OMP_CLAUSE_IS_DEVICE_PTR:\n+      name = \"is_device_ptr\";\n+      goto print_remap;\n     case OMP_CLAUSE__LOOPTEMP_:\n       name = \"_looptemp_\";\n       goto print_remap;\n@@ -339,6 +345,12 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n     case OMP_CLAUSE_USE_DEVICE:\n       name = \"use_device\";\n       goto print_remap;\n+    case OMP_CLAUSE_TO_DECLARE:\n+      name = \"to\";\n+      goto print_remap;\n+    case OMP_CLAUSE_LINK:\n+      name = \"link\";\n+      goto print_remap;\n   print_remap:\n       pp_string (pp, name);\n       pp_left_paren (pp);\n@@ -362,6 +374,20 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n \n     case OMP_CLAUSE_IF:\n       pp_string (pp, \"if(\");\n+      switch (OMP_CLAUSE_IF_MODIFIER (clause))\n+\t{\n+\tcase ERROR_MARK: break;\n+\tcase OMP_PARALLEL: pp_string (pp, \"parallel:\"); break;\n+\tcase OMP_TASK: pp_string (pp, \"task:\"); break;\n+\tcase OMP_TASKLOOP: pp_string (pp, \"taskloop:\"); break;\n+\tcase OMP_TARGET_DATA: pp_string (pp, \"target data:\"); break;\n+\tcase OMP_TARGET: pp_string (pp, \"target:\"); break;\n+\tcase OMP_TARGET_UPDATE: pp_string (pp, \"target update:\"); break;\n+\tcase OMP_TARGET_ENTER_DATA:\n+\t  pp_string (pp, \"target enter data:\"); break;\n+\tcase OMP_TARGET_EXIT_DATA: pp_string (pp, \"target exit data:\"); break;\n+\tdefault: gcc_unreachable ();\n+\t}\n       dump_generic_node (pp, OMP_CLAUSE_IF_EXPR (clause),\n \t\t\t spc, flags, false);\n       pp_right_paren (pp);\n@@ -386,6 +412,13 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n       break;\n     case OMP_CLAUSE_ORDERED:\n       pp_string (pp, \"ordered\");\n+      if (OMP_CLAUSE_ORDERED_EXPR (clause))\n+\t{\n+\t  pp_left_paren (pp);\n+\t  dump_generic_node (pp, OMP_CLAUSE_ORDERED_EXPR (clause),\n+\t\t\t     spc, flags, false);\n+\t  pp_right_paren (pp);\n+\t}\n       break;\n \n     case OMP_CLAUSE_DEFAULT:\n@@ -414,6 +447,8 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n \n     case OMP_CLAUSE_SCHEDULE:\n       pp_string (pp, \"schedule(\");\n+      if (OMP_CLAUSE_SCHEDULE_SIMD (clause))\n+\tpp_string (pp, \"simd:\");\n       switch (OMP_CLAUSE_SCHEDULE_KIND (clause))\n \t{\n \tcase OMP_CLAUSE_SCHEDULE_STATIC:\n@@ -470,8 +505,26 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n \n     case OMP_CLAUSE_LINEAR:\n       pp_string (pp, \"linear(\");\n+      switch (OMP_CLAUSE_LINEAR_KIND (clause))\n+\t{\n+\tcase OMP_CLAUSE_LINEAR_DEFAULT:\n+\t  break;\n+\tcase OMP_CLAUSE_LINEAR_REF:\n+\t  pp_string (pp, \"ref(\");\n+\t  break;\n+\tcase OMP_CLAUSE_LINEAR_VAL:\n+\t  pp_string (pp, \"val(\");\n+\t  break;\n+\tcase OMP_CLAUSE_LINEAR_UVAL:\n+\t  pp_string (pp, \"uval(\");\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n       dump_generic_node (pp, OMP_CLAUSE_DECL (clause),\n \t\t\t spc, flags, false);\n+      if (OMP_CLAUSE_LINEAR_KIND (clause) != OMP_CLAUSE_LINEAR_DEFAULT)\n+\tpp_right_paren (pp);\n       pp_colon (pp);\n       dump_generic_node (pp, OMP_CLAUSE_LINEAR_STEP (clause),\n \t\t\t spc, flags, false);\n@@ -504,6 +557,31 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n \tcase OMP_CLAUSE_DEPEND_INOUT:\n \t  pp_string (pp, \"inout\");\n \t  break;\n+\tcase OMP_CLAUSE_DEPEND_SOURCE:\n+\t  pp_string (pp, \"source)\");\n+\t  return;\n+\tcase OMP_CLAUSE_DEPEND_SINK:\n+\t  pp_string (pp, \"sink:\");\n+\t  for (tree t = OMP_CLAUSE_DECL (clause); t; t = TREE_CHAIN (t))\n+\t    if (TREE_CODE (t) == TREE_LIST)\n+\t      {\n+\t\tdump_generic_node (pp, TREE_VALUE (t), spc, flags, false);\n+\t\tif (TREE_PURPOSE (t) != integer_zero_node)\n+\t\t  {\n+\t\t    if (OMP_CLAUSE_DEPEND_SINK_NEGATIVE (t))\n+\t\t      pp_minus (pp);\n+\t\t    else\n+\t\t      pp_plus (pp);\n+\t\t    dump_generic_node (pp, TREE_PURPOSE (t), spc, flags,\n+\t\t\t\t       false);\n+\t\t  }\n+\t\tif (TREE_CHAIN (t))\n+\t\t  pp_comma (pp);\n+\t      }\n+\t    else\n+\t      gcc_unreachable ();\n+\t  pp_right_paren (pp);\n+\t  return;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -547,11 +625,29 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n \t  pp_string (pp, \"force_present\");\n \t  break;\n \tcase GOMP_MAP_FORCE_DEALLOC:\n-\t  pp_string (pp, \"force_dealloc\");\n+\t  pp_string (pp, \"delete\");\n \t  break;\n \tcase GOMP_MAP_FORCE_DEVICEPTR:\n \t  pp_string (pp, \"force_deviceptr\");\n \t  break;\n+\tcase GOMP_MAP_ALWAYS_TO:\n+\t  pp_string (pp, \"always,to\");\n+\t  break;\n+\tcase GOMP_MAP_ALWAYS_FROM:\n+\t  pp_string (pp, \"always,from\");\n+\t  break;\n+\tcase GOMP_MAP_ALWAYS_TOFROM:\n+\t  pp_string (pp, \"always,tofrom\");\n+\t  break;\n+\tcase GOMP_MAP_RELEASE:\n+\t  pp_string (pp, \"release\");\n+\t  break;\n+\tcase GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t  pp_string (pp, \"firstprivate\");\n+\t  break;\n+\tcase GOMP_MAP_STRUCT:\n+\t  pp_string (pp, \"struct\");\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -562,7 +658,9 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n       if (OMP_CLAUSE_SIZE (clause))\n \t{\n \t  if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_MAP\n-\t      && OMP_CLAUSE_MAP_KIND (clause) == GOMP_MAP_POINTER)\n+\t      && (OMP_CLAUSE_MAP_KIND (clause) == GOMP_MAP_POINTER\n+\t\t  || OMP_CLAUSE_MAP_KIND (clause)\n+\t\t     == GOMP_MAP_FIRSTPRIVATE_POINTER))\n \t    pp_string (pp, \" [pointer assign, bias: \");\n \t  else if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_MAP\n \t\t   && OMP_CLAUSE_MAP_KIND (clause) == GOMP_MAP_TO_PSET)\n@@ -660,6 +758,38 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n       pp_right_paren (pp);\n       break;\n \n+    case OMP_CLAUSE_PRIORITY:\n+      pp_string (pp, \"priority(\");\n+      dump_generic_node (pp, OMP_CLAUSE_PRIORITY_EXPR (clause),\n+\t\t\t spc, flags, false);\n+      pp_right_paren (pp);\n+      break;\n+\n+    case OMP_CLAUSE_GRAINSIZE:\n+      pp_string (pp, \"grainsize(\");\n+      dump_generic_node (pp, OMP_CLAUSE_GRAINSIZE_EXPR (clause),\n+\t\t\t spc, flags, false);\n+      pp_right_paren (pp);\n+      break;\n+\n+    case OMP_CLAUSE_NUM_TASKS:\n+      pp_string (pp, \"num_tasks(\");\n+      dump_generic_node (pp, OMP_CLAUSE_NUM_TASKS_EXPR (clause),\n+\t\t\t spc, flags, false);\n+      pp_right_paren (pp);\n+      break;\n+\n+    case OMP_CLAUSE_HINT:\n+      pp_string (pp, \"hint(\");\n+      dump_generic_node (pp, OMP_CLAUSE_HINT_EXPR (clause),\n+\t\t\t spc, flags, false);\n+      pp_right_paren (pp);\n+      break;\n+\n+    case OMP_CLAUSE_DEFAULTMAP:\n+      pp_string (pp, \"defaultmap(tofrom:scalar)\");\n+      break;\n+\n     case OMP_CLAUSE__SIMDUID_:\n       pp_string (pp, \"_simduid_(\");\n       dump_generic_node (pp, OMP_CLAUSE__SIMDUID__DECL (clause),\n@@ -778,6 +908,15 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n     case OMP_CLAUSE_TASKGROUP:\n       pp_string (pp, \"taskgroup\");\n       break;\n+    case OMP_CLAUSE_NOGROUP:\n+      pp_string (pp, \"nogroup\");\n+      break;\n+    case OMP_CLAUSE_THREADS:\n+      pp_string (pp, \"threads\");\n+      break;\n+    case OMP_CLAUSE_SIMD:\n+      pp_string (pp, \"simd\");\n+      break;\n     case OMP_CLAUSE_INDEPENDENT:\n       pp_string (pp, \"independent\");\n       break;\n@@ -2624,6 +2763,10 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, int flags,\n       pp_string (pp, \"#pragma omp distribute\");\n       goto dump_omp_loop;\n \n+    case OMP_TASKLOOP:\n+      pp_string (pp, \"#pragma omp taskloop\");\n+      goto dump_omp_loop;\n+\n     case OACC_LOOP:\n       pp_string (pp, \"#pragma acc loop\");\n       goto dump_omp_loop;\n@@ -2638,6 +2781,18 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, int flags,\n       dump_omp_clauses (pp, OMP_TARGET_DATA_CLAUSES (node), spc, flags);\n       goto dump_omp_body;\n \n+    case OMP_TARGET_ENTER_DATA:\n+      pp_string (pp, \"#pragma omp target enter data\");\n+      dump_omp_clauses (pp, OMP_TARGET_ENTER_DATA_CLAUSES (node), spc, flags);\n+      is_expr = false;\n+      break;\n+\n+    case OMP_TARGET_EXIT_DATA:\n+      pp_string (pp, \"#pragma omp target exit data\");\n+      dump_omp_clauses (pp, OMP_TARGET_EXIT_DATA_CLAUSES (node), spc, flags);\n+      is_expr = false;\n+      break;\n+\n     case OMP_TARGET:\n       pp_string (pp, \"#pragma omp target\");\n       dump_omp_clauses (pp, OMP_TARGET_CLAUSES (node), spc, flags);\n@@ -2738,6 +2893,7 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, int flags,\n \n     case OMP_ORDERED:\n       pp_string (pp, \"#pragma omp ordered\");\n+      dump_omp_clauses (pp, OMP_ORDERED_CLAUSES (node), spc, flags);\n       goto dump_omp_body;\n \n     case OMP_CRITICAL:\n@@ -2750,6 +2906,7 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, int flags,\n \t\t\t     flags, false);\n \t  pp_right_paren (pp);\n \t}\n+      dump_omp_clauses (pp, OMP_CRITICAL_CLAUSES (node), spc, flags);\n       goto dump_omp_body;\n \n     case OMP_ATOMIC:"}, {"sha": "a5e1cb7a935f03c9f19c417d4d22f76af490933d", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -2892,13 +2892,16 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t  i = -1;\n \t\tbreak;\n \t      case SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP:\n+\t      case SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP:\n \t\tif (arginfo[i].dt == vect_constant_def\n \t\t    || arginfo[i].dt == vect_external_def\n \t\t    || (arginfo[i].linear_step\n \t\t\t!= n->simdclone->args[i].linear_step))\n \t\t  i = -1;\n \t\tbreak;\n \t      case SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP:\n+\t      case SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP:\n+\t      case SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP:\n \t\t/* FORNOW */\n \t\ti = -1;\n \t\tbreak;"}, {"sha": "3e6fd355e8395303405578e4a0c14d632d28879e", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -149,8 +149,9 @@ simd_array_to_simduid::equal (const simd_array_to_simduid *p1,\n   return p1->decl == p2->decl;\n }\n \n-/* Fold IFN_GOMP_SIMD_LANE, IFN_GOMP_SIMD_VF and IFN_GOMP_SIMD_LAST_LANE\n-   into their corresponding constants.  */\n+/* Fold IFN_GOMP_SIMD_LANE, IFN_GOMP_SIMD_VF, IFN_GOMP_SIMD_LAST_LANE,\n+   into their corresponding constants and remove\n+   IFN_GOMP_SIMD_ORDERED_{START,END}.  */\n \n static void\n adjust_simduid_builtins (hash_table<simduid_to_vf> *htab)\n@@ -161,23 +162,32 @@ adjust_simduid_builtins (hash_table<simduid_to_vf> *htab)\n     {\n       gimple_stmt_iterator i;\n \n-      for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n+      for (i = gsi_start_bb (bb); !gsi_end_p (i); )\n \t{\n \t  unsigned int vf = 1;\n \t  enum internal_fn ifn;\n \t  gimple *stmt = gsi_stmt (i);\n \t  tree t;\n \t  if (!is_gimple_call (stmt)\n \t      || !gimple_call_internal_p (stmt))\n-\t    continue;\n+\t    {\n+\t      gsi_next (&i);\n+\t      continue;\n+\t    }\n \t  ifn = gimple_call_internal_fn (stmt);\n \t  switch (ifn)\n \t    {\n \t    case IFN_GOMP_SIMD_LANE:\n \t    case IFN_GOMP_SIMD_VF:\n \t    case IFN_GOMP_SIMD_LAST_LANE:\n \t      break;\n+\t    case IFN_GOMP_SIMD_ORDERED_START:\n+\t    case IFN_GOMP_SIMD_ORDERED_END:\n+\t      gsi_remove (&i, true);\n+\t      unlink_stmt_vdef (stmt);\n+\t      continue;\n \t    default:\n+\t      gsi_next (&i);\n \t      continue;\n \t    }\n \t  tree arg = gimple_call_arg (stmt, 0);\n@@ -206,6 +216,7 @@ adjust_simduid_builtins (hash_table<simduid_to_vf> *htab)\n \t      gcc_unreachable ();\n \t    }\n \t  update_call_from_tree (&i, t);\n+\t  gsi_next (&i);\n \t}\n     }\n }\n@@ -562,7 +573,7 @@ vectorize_loops (void)\n \n   free_stmt_vec_info_vec ();\n \n-  /* Fold IFN_GOMP_SIMD_{VF,LANE,LAST_LANE} builtins.  */\n+  /* Fold IFN_GOMP_SIMD_{VF,LANE,LAST_LANE,ORDERED_{START,END}} builtins.  */\n   if (cfun->has_simduid_loops)\n     adjust_simduid_builtins (simduid_to_vf_htab);\n \n@@ -624,7 +635,7 @@ pass_simduid_cleanup::execute (function *fun)\n \n   note_simd_array_uses (&simd_array_to_simduid_htab);\n \n-  /* Fold IFN_GOMP_SIMD_{VF,LANE,LAST_LANE} builtins.  */\n+  /* Fold IFN_GOMP_SIMD_{VF,LANE,LAST_LANE,ORDERED_{START,END}} builtins.  */\n   adjust_simduid_builtins (NULL);\n \n   /* Shrink any \"omp array simd\" temporary arrays to the"}, {"sha": "905c60ef269ee8f172db5ea312ef3e1334395e76", "filename": "gcc/tree.c", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -280,16 +280,20 @@ unsigned const char omp_clause_num_ops[] =\n   1, /* OMP_CLAUSE_SHARED  */\n   1, /* OMP_CLAUSE_FIRSTPRIVATE  */\n   2, /* OMP_CLAUSE_LASTPRIVATE  */\n-  4, /* OMP_CLAUSE_REDUCTION  */\n+  5, /* OMP_CLAUSE_REDUCTION  */\n   1, /* OMP_CLAUSE_COPYIN  */\n   1, /* OMP_CLAUSE_COPYPRIVATE  */\n   3, /* OMP_CLAUSE_LINEAR  */\n   2, /* OMP_CLAUSE_ALIGNED  */\n   1, /* OMP_CLAUSE_DEPEND  */\n   1, /* OMP_CLAUSE_UNIFORM  */\n+  1, /* OMP_CLAUSE_TO_DECLARE  */\n+  1, /* OMP_CLAUSE_LINK  */\n   2, /* OMP_CLAUSE_FROM  */\n   2, /* OMP_CLAUSE_TO  */\n   2, /* OMP_CLAUSE_MAP  */\n+  1, /* OMP_CLAUSE_USE_DEVICE_PTR  */\n+  1, /* OMP_CLAUSE_IS_DEVICE_PTR  */\n   2, /* OMP_CLAUSE__CACHE_  */\n   1, /* OMP_CLAUSE_DEVICE_RESIDENT  */\n   1, /* OMP_CLAUSE_USE_DEVICE  */\n@@ -303,7 +307,7 @@ unsigned const char omp_clause_num_ops[] =\n   1, /* OMP_CLAUSE_NUM_THREADS  */\n   1, /* OMP_CLAUSE_SCHEDULE  */\n   0, /* OMP_CLAUSE_NOWAIT  */\n-  0, /* OMP_CLAUSE_ORDERED  */\n+  1, /* OMP_CLAUSE_ORDERED  */\n   0, /* OMP_CLAUSE_DEFAULT  */\n   3, /* OMP_CLAUSE_COLLAPSE  */\n   0, /* OMP_CLAUSE_UNTIED   */\n@@ -322,6 +326,14 @@ unsigned const char omp_clause_num_ops[] =\n   0, /* OMP_CLAUSE_PARALLEL  */\n   0, /* OMP_CLAUSE_SECTIONS  */\n   0, /* OMP_CLAUSE_TASKGROUP  */\n+  1, /* OMP_CLAUSE_PRIORITY  */\n+  1, /* OMP_CLAUSE_GRAINSIZE  */\n+  1, /* OMP_CLAUSE_NUM_TASKS  */\n+  0, /* OMP_CLAUSE_NOGROUP  */\n+  0, /* OMP_CLAUSE_THREADS  */\n+  0, /* OMP_CLAUSE_SIMD  */\n+  1, /* OMP_CLAUSE_HINT  */\n+  0, /* OMP_CLAUSE_DEFALTMAP  */\n   1, /* OMP_CLAUSE__SIMDUID_  */\n   1, /* OMP_CLAUSE__CILK_FOR_COUNT_  */\n   0, /* OMP_CLAUSE_INDEPENDENT  */\n@@ -346,9 +358,13 @@ const char * const omp_clause_code_name[] =\n   \"aligned\",\n   \"depend\",\n   \"uniform\",\n+  \"to\",\n+  \"link\",\n   \"from\",\n   \"to\",\n   \"map\",\n+  \"use_device_ptr\",\n+  \"is_device_ptr\",\n   \"_cache_\",\n   \"device_resident\",\n   \"use_device\",\n@@ -381,6 +397,14 @@ const char * const omp_clause_code_name[] =\n   \"parallel\",\n   \"sections\",\n   \"taskgroup\",\n+  \"priority\",\n+  \"grainsize\",\n+  \"num_tasks\",\n+  \"nogroup\",\n+  \"threads\",\n+  \"simd\",\n+  \"hint\",\n+  \"defaultmap\",\n   \"_simduid_\",\n   \"_Cilk_for_count_\",\n   \"independent\",\n@@ -11458,6 +11482,15 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_DIST_SCHEDULE:\n \tcase OMP_CLAUSE_SAFELEN:\n \tcase OMP_CLAUSE_SIMDLEN:\n+\tcase OMP_CLAUSE_ORDERED:\n+\tcase OMP_CLAUSE_PRIORITY:\n+\tcase OMP_CLAUSE_GRAINSIZE:\n+\tcase OMP_CLAUSE_NUM_TASKS:\n+\tcase OMP_CLAUSE_HINT:\n+\tcase OMP_CLAUSE_TO_DECLARE:\n+\tcase OMP_CLAUSE_LINK:\n+\tcase OMP_CLAUSE_USE_DEVICE_PTR:\n+\tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \tcase OMP_CLAUSE__LOOPTEMP_:\n \tcase OMP_CLAUSE__SIMDUID_:\n \tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n@@ -11466,7 +11499,6 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \n \tcase OMP_CLAUSE_INDEPENDENT:\n \tcase OMP_CLAUSE_NOWAIT:\n-\tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_MERGEABLE:\n@@ -11477,6 +11509,10 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_PARALLEL:\n \tcase OMP_CLAUSE_SECTIONS:\n \tcase OMP_CLAUSE_TASKGROUP:\n+\tcase OMP_CLAUSE_NOGROUP:\n+\tcase OMP_CLAUSE_THREADS:\n+\tcase OMP_CLAUSE_SIMD:\n+\tcase OMP_CLAUSE_DEFAULTMAP:\n \tcase OMP_CLAUSE_AUTO:\n \tcase OMP_CLAUSE_SEQ:\n \t  WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n@@ -11512,7 +11548,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_REDUCTION:\n \t  {\n \t    int i;\n-\t    for (i = 0; i < 4; i++)\n+\t    for (i = 0; i < 5; i++)\n \t      WALK_SUBTREE (OMP_CLAUSE_OPERAND (*tp, i));\n \t    WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n \t  }"}, {"sha": "64e07270a7ed6de8fd8768ae0bf6b5c3d48feeaa", "filename": "gcc/tree.def", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1087,32 +1087,41 @@ DEFTREECODE (OMP_TASK, \"omp_task\", tcc_statement, 2)\n \tfrom INIT, COND, and INCR that are technically part of the\n \tOMP_FOR structured block, but are evaluated before the loop\n \tbody begins.\n+   Operand 6: OMP_FOR_ORIG_DECLS: If non-NULL, list of DECLs initialized\n+\tin OMP_FOR_INIT.  In some cases, like C++ iterators, the original\n+\tDECL init has been lost in gimplification and now contains a\n+\ttemporary (D.nnnn).  This list contains the original DECLs in\n+\tthe source.\n \n    VAR must be an integer or pointer variable, which is implicitly thread\n    private.  N1, N2 and INCR are required to be loop invariant integer\n    expressions that are evaluated without any synchronization.\n    The evaluation order, frequency of evaluation and side-effects are\n    unspecified by the standards.  */\n-DEFTREECODE (OMP_FOR, \"omp_for\", tcc_statement, 6)\n+DEFTREECODE (OMP_FOR, \"omp_for\", tcc_statement, 7)\n \n /* OpenMP - #pragma omp simd [clause1 ... clauseN]\n-   Operands like for OMP_FOR.  */\n+   Operands like operands 1-6 of OMP_FOR.  */\n DEFTREECODE (OMP_SIMD, \"omp_simd\", tcc_statement, 6)\n \n /* Cilk Plus - #pragma simd [clause1 ... clauseN]\n-   Operands like for OMP_FOR.  */\n+   Operands like operands 1-6 of OMP_FOR.  */\n DEFTREECODE (CILK_SIMD, \"cilk_simd\", tcc_statement, 6)\n \n /* Cilk Plus - _Cilk_for (..)\n-   Operands like for OMP_FOR.  */\n+   Operands like operands 1-6 of OMP_FOR.  */\n DEFTREECODE (CILK_FOR, \"cilk_for\", tcc_statement, 6)\n \n /* OpenMP - #pragma omp distribute [clause1 ... clauseN]\n-   Operands like for OMP_FOR.  */\n+   Operands like operands 1-6 of OMP_FOR.  */\n DEFTREECODE (OMP_DISTRIBUTE, \"omp_distribute\", tcc_statement, 6)\n \n+/* OpenMP - #pragma omp taskloop [clause1 ... clauseN]\n+   Operands like operands 1-6 of OMP_FOR.  */\n+DEFTREECODE (OMP_TASKLOOP, \"omp_taskloop\", tcc_statement, 6)\n+\n /* OpenMP - #pragma acc loop [clause1 ... clauseN]\n-   Operands like for OMP_FOR.  */\n+   Operands like operands 1-6 of OMP_FOR.  */\n DEFTREECODE (OACC_LOOP, \"oacc_loop\", tcc_statement, 6)\n \n /* OpenMP - #pragma omp teams [clause1 ... clauseN]\n@@ -1135,6 +1144,17 @@ DEFTREECODE (OMP_TARGET, \"omp_target\", tcc_statement, 2)\n    Operand 1: OMP_SECTIONS_CLAUSES: List of clauses.  */\n DEFTREECODE (OMP_SECTIONS, \"omp_sections\", tcc_statement, 2)\n \n+/* OpenMP - #pragma omp ordered\n+   Operand 0: OMP_ORDERED_BODY: Master section body.\n+   Operand 1: OMP_ORDERED_CLAUSES: List of clauses.  */\n+DEFTREECODE (OMP_ORDERED, \"omp_ordered\", tcc_statement, 2)\n+\n+/* OpenMP - #pragma omp critical [name]\n+   Operand 0: OMP_CRITICAL_BODY: Critical section body.\n+   Operand 1: OMP_CRITICAL_CLAUSES: List of clauses.\n+   Operand 2: OMP_CRITICAL_NAME: Identifier for critical section.  */\n+DEFTREECODE (OMP_CRITICAL, \"omp_critical\", tcc_statement, 3)\n+\n /* OpenMP - #pragma omp single\n    Operand 0: OMP_SINGLE_BODY: Single section body.\n    Operand 1: OMP_SINGLE_CLAUSES: List of clauses.  */\n@@ -1152,15 +1172,6 @@ DEFTREECODE (OMP_MASTER, \"omp_master\", tcc_statement, 1)\n    Operand 0: OMP_TASKGROUP_BODY: Taskgroup body.  */\n DEFTREECODE (OMP_TASKGROUP, \"omp_taskgroup\", tcc_statement, 1)\n \n-/* OpenMP - #pragma omp ordered\n-   Operand 0: OMP_ORDERED_BODY: Master section body.  */\n-DEFTREECODE (OMP_ORDERED, \"omp_ordered\", tcc_statement, 1)\n-\n-/* OpenMP - #pragma omp critical [name]\n-   Operand 0: OMP_CRITICAL_BODY: Critical section body.\n-   Operand 1: OMP_CRITICAL_NAME: Identifier for critical section.  */\n-DEFTREECODE (OMP_CRITICAL, \"omp_critical\", tcc_statement, 2)\n-\n /* OpenACC - #pragma acc cache (variable1 ... variableN)\n    Operand 0: OACC_CACHE_CLAUSES: List of variables (transformed into\n \tOMP_CLAUSE__CACHE_ clauses).  */\n@@ -1186,6 +1197,14 @@ DEFTREECODE (OACC_UPDATE, \"oacc_update\", tcc_statement, 1)\n    Operand 0: OMP_TARGET_UPDATE_CLAUSES: List of clauses.  */\n DEFTREECODE (OMP_TARGET_UPDATE, \"omp_target_update\", tcc_statement, 1)\n \n+/* OpenMP - #pragma omp target enter data [clause1 ... clauseN]\n+   Operand 0: OMP_TARGET_ENTER_DATA_CLAUSES: List of clauses.  */\n+DEFTREECODE (OMP_TARGET_ENTER_DATA, \"omp_target_enter_data\", tcc_statement, 1)\n+\n+/* OpenMP - #pragma omp target exit data [clause1 ... clauseN]\n+   Operand 0: OMP_TARGET_EXIT_DATA_CLAUSES: List of clauses.  */\n+DEFTREECODE (OMP_TARGET_EXIT_DATA, \"omp_target_exit_data\", tcc_statement, 1)\n+\n /* OMP_ATOMIC through OMP_ATOMIC_CAPTURE_NEW must be consecutive,\n    or OMP_ATOMIC_SEQ_CST needs adjusting.  */\n "}, {"sha": "f62cd2746a90c904195cea220d8dbdc86b51ee5e", "filename": "gcc/tree.h", "status": "modified", "additions": 73, "deletions": 4, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1204,13 +1204,13 @@ extern void protected_set_expr_location (tree, location_t);\n /* Generic accessors for OMP nodes that keep the body as operand 0, and clauses\n    as operand 1.  */\n #define OMP_BODY(NODE) \\\n-  TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_PARALLEL, OMP_CRITICAL), 0)\n+  TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_PARALLEL, OMP_TASKGROUP), 0)\n #define OMP_CLAUSES(NODE) \\\n   TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_PARALLEL, OMP_SINGLE), 1)\n \n /* Generic accessors for OMP nodes that keep clauses as operand 0.  */\n #define OMP_STANDALONE_CLAUSES(NODE) \\\n-  TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_CACHE, OMP_TARGET_UPDATE), 0)\n+  TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_CACHE, OMP_TARGET_EXIT_DATA), 0)\n \n #define OACC_PARALLEL_BODY(NODE) \\\n   TREE_OPERAND (OACC_PARALLEL_CHECK (NODE), 0)\n@@ -1264,6 +1264,8 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_FOR_COND(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 3)\n #define OMP_FOR_INCR(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 4)\n #define OMP_FOR_PRE_BODY(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 5)\n+/* Note that this is only available for OMP_FOR, hence OMP_FOR_CHECK.  */\n+#define OMP_FOR_ORIG_DECLS(NODE)   TREE_OPERAND (OMP_FOR_CHECK (NODE), 6)\n \n #define OMP_SECTIONS_BODY(NODE)    TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 0)\n #define OMP_SECTIONS_CLAUSES(NODE) TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 1)\n@@ -1278,9 +1280,11 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_TASKGROUP_BODY(NODE)   TREE_OPERAND (OMP_TASKGROUP_CHECK (NODE), 0)\n \n #define OMP_ORDERED_BODY(NODE)\t   TREE_OPERAND (OMP_ORDERED_CHECK (NODE), 0)\n+#define OMP_ORDERED_CLAUSES(NODE)  TREE_OPERAND (OMP_ORDERED_CHECK (NODE), 1)\n \n #define OMP_CRITICAL_BODY(NODE)    TREE_OPERAND (OMP_CRITICAL_CHECK (NODE), 0)\n-#define OMP_CRITICAL_NAME(NODE)    TREE_OPERAND (OMP_CRITICAL_CHECK (NODE), 1)\n+#define OMP_CRITICAL_CLAUSES(NODE) TREE_OPERAND (OMP_CRITICAL_CHECK (NODE), 1)\n+#define OMP_CRITICAL_NAME(NODE)    TREE_OPERAND (OMP_CRITICAL_CHECK (NODE), 2)\n \n #define OMP_TEAMS_BODY(NODE)\t   TREE_OPERAND (OMP_TEAMS_CHECK (NODE), 0)\n #define OMP_TEAMS_CLAUSES(NODE)\t   TREE_OPERAND (OMP_TEAMS_CHECK (NODE), 1)\n@@ -1296,6 +1300,12 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_TARGET_UPDATE_CLAUSES(NODE)\\\n   TREE_OPERAND (OMP_TARGET_UPDATE_CHECK (NODE), 0)\n \n+#define OMP_TARGET_ENTER_DATA_CLAUSES(NODE)\\\n+  TREE_OPERAND (OMP_TARGET_ENTER_DATA_CHECK (NODE), 0)\n+\n+#define OMP_TARGET_EXIT_DATA_CLAUSES(NODE)\\\n+  TREE_OPERAND (OMP_TARGET_EXIT_DATA_CHECK (NODE), 0)\n+\n #define OMP_CLAUSE_SIZE(NODE)\t\t\t\t\t\t\\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (OMP_CLAUSE_CHECK (NODE),\t\\\n \t\t\t\t\t      OMP_CLAUSE_FROM,\t\t\\\n@@ -1335,6 +1345,11 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_TEAMS_COMBINED(NODE) \\\n   (OMP_TEAMS_CHECK (NODE)->base.private_flag)\n \n+/* True on an OMP_TARGET statement if it represents explicit\n+   combined target teams, target parallel or target simd constructs.  */\n+#define OMP_TARGET_COMBINED(NODE) \\\n+  (OMP_TARGET_CHECK (NODE)->base.private_flag)\n+\n /* True if OMP_ATOMIC* is supposed to be sequentially consistent\n    as opposed to relaxed.  */\n #define OMP_ATOMIC_SEQ_CST(NODE) \\\n@@ -1352,6 +1367,12 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_PRIVATE_OUTER_REF(NODE) \\\n   TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PRIVATE))\n \n+/* True if a PRIVATE clause is for a C++ class IV on taskloop construct\n+   (thus should be private on the outer taskloop and firstprivate on\n+   task).  */\n+#define OMP_CLAUSE_PRIVATE_TASKLOOP_IV(NODE) \\\n+  TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PRIVATE))\n+\n /* True on a LASTPRIVATE clause if a FIRSTPRIVATE clause for the same\n    decl is present in the chain.  */\n #define OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE(NODE) \\\n@@ -1363,6 +1384,21 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ(NODE) \\\n   (OMP_CLAUSE_CHECK (NODE))->omp_clause.gimple_reduction_init\n \n+/* True if a LASTPRIVATE clause is for a C++ class IV on taskloop construct\n+   (thus should be lastprivate on the outer taskloop and firstprivate on\n+   task).  */\n+#define OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV(NODE) \\\n+  TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LASTPRIVATE))\n+\n+/* True on a SHARED clause if a FIRSTPRIVATE clause for the same\n+   decl is present in the chain (this can happen only for taskloop\n+   with FIRSTPRIVATE/LASTPRIVATE on it originally.  */\n+#define OMP_CLAUSE_SHARED_FIRSTPRIVATE(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SHARED)->base.public_flag)\n+\n+#define OMP_CLAUSE_IF_MODIFIER(NODE)\t\\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_IF)->omp_clause.subcode.if_modifier)\n+\n #define OMP_CLAUSE_FINAL_EXPR(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_FINAL), 0)\n #define OMP_CLAUSE_IF_EXPR(NODE) \\\n@@ -1371,6 +1407,16 @@ extern void protected_set_expr_location (tree, location_t);\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_THREADS),0)\n #define OMP_CLAUSE_SCHEDULE_CHUNK_EXPR(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SCHEDULE), 0)\n+#define OMP_CLAUSE_NUM_TASKS_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_TASKS), 0)\n+#define OMP_CLAUSE_HINT_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_HINT), 0)\n+\n+#define OMP_CLAUSE_GRAINSIZE_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_GRAINSIZE),0)\n+\n+#define OMP_CLAUSE_PRIORITY_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PRIORITY),0)\n \n /* OpenACC clause expressions  */\n #define OMP_CLAUSE_EXPR(NODE, CLAUSE) \\\n@@ -1406,17 +1452,28 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_DEPEND_KIND(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEPEND)->omp_clause.subcode.depend_kind)\n \n+#define OMP_CLAUSE_DEPEND_SINK_NEGATIVE(NODE) \\\n+  TREE_PUBLIC (TREE_LIST_CHECK (NODE))\n+\n #define OMP_CLAUSE_MAP_KIND(NODE) \\\n   ((enum gomp_map_kind) OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->omp_clause.subcode.map_kind)\n #define OMP_CLAUSE_SET_MAP_KIND(NODE, MAP_KIND) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->omp_clause.subcode.map_kind \\\n-   = (unsigned char) (MAP_KIND))\n+   = (unsigned int) (MAP_KIND))\n \n /* Nonzero if this map clause is for array (rather than pointer) based array\n    section with zero bias.  Both the non-decl OMP_CLAUSE_MAP and corresponding\n    OMP_CLAUSE_MAP with GOMP_MAP_POINTER are marked with this flag.  */\n #define OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->base.public_flag)\n+/* Nonzero if the same decl appears both in OMP_CLAUSE_MAP and either\n+   OMP_CLAUSE_PRIVATE or OMP_CLAUSE_FIRSTPRIVATE.  */\n+#define OMP_CLAUSE_MAP_PRIVATE(NODE) \\\n+  TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP))\n+/* Nonzero if this is a mapped array section, that might need special\n+   treatment if OMP_CLAUSE_SIZE is zero.  */\n+#define OMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION(NODE) \\\n+  TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP))\n \n #define OMP_CLAUSE_PROC_BIND_KIND(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PROC_BIND)->omp_clause.subcode.proc_bind_kind)\n@@ -1428,6 +1485,9 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_COLLAPSE_COUNT(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_COLLAPSE), 2)\n \n+#define OMP_CLAUSE_ORDERED_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ORDERED), 0)\n+\n #define OMP_CLAUSE_REDUCTION_CODE(NODE)\t\\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION)->omp_clause.subcode.reduction_code)\n #define OMP_CLAUSE_REDUCTION_INIT(NODE) \\\n@@ -1440,6 +1500,8 @@ extern void protected_set_expr_location (tree, location_t);\n   (OMP_CLAUSE_CHECK (NODE))->omp_clause.gimple_reduction_merge\n #define OMP_CLAUSE_REDUCTION_PLACEHOLDER(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION), 3)\n+#define OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION), 4)\n \n /* True if a REDUCTION clause may reference the original list item (omp_orig)\n    in its OMP_CLAUSE_REDUCTION_{,GIMPLE_}INIT.  */\n@@ -1474,6 +1536,9 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_LINEAR_GIMPLE_SEQ(NODE) \\\n   (OMP_CLAUSE_CHECK (NODE))->omp_clause.gimple_reduction_init\n \n+#define OMP_CLAUSE_LINEAR_KIND(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR)->omp_clause.subcode.linear_kind)\n+\n #define OMP_CLAUSE_ALIGNED_ALIGNMENT(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ALIGNED), 1)\n \n@@ -1503,6 +1568,10 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_SCHEDULE_KIND(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SCHEDULE)->omp_clause.subcode.schedule_kind)\n \n+/* True if a SCHEDULE clause has the simd modifier on it.  */\n+#define OMP_CLAUSE_SCHEDULE_SIMD(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SCHEDULE)->base.public_flag)\n+\n #define OMP_CLAUSE_DEFAULT_KIND(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEFAULT)->omp_clause.subcode.default_kind)\n "}, {"sha": "ff156791547229c91c0d69dfe74d1d7a2ae06ee7", "filename": "gcc/wide-int.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -507,6 +507,7 @@ namespace wi\n   BINARY_FUNCTION div_round (const T1 &, const T2 &, signop, bool * = 0);\n   BINARY_FUNCTION divmod_trunc (const T1 &, const T2 &, signop,\n \t\t\t\tWI_BINARY_RESULT (T1, T2) *);\n+  BINARY_FUNCTION gcd (const T1 &, const T2 &, signop = UNSIGNED);\n   BINARY_FUNCTION mod_trunc (const T1 &, const T2 &, signop, bool * = 0);\n   BINARY_FUNCTION smod_trunc (const T1 &, const T2 &);\n   BINARY_FUNCTION umod_trunc (const T1 &, const T2 &);\n@@ -2643,6 +2644,27 @@ wi::divmod_trunc (const T1 &x, const T2 &y, signop sgn,\n   return quotient;\n }\n \n+/* Compute the greatest common divisor of two numbers A and B using\n+   Euclid's algorithm.  */\n+template <typename T1, typename T2>\n+inline WI_BINARY_RESULT (T1, T2)\n+wi::gcd (const T1 &a, const T2 &b, signop sgn)\n+{\n+  T1 x, y, z;\n+\n+  x = wi::abs (a);\n+  y = wi::abs (b);\n+\n+  while (gt_p (x, 0, sgn))\n+    {\n+      z = mod_trunc (y, x, sgn);\n+      y = x;\n+      x = z;\n+    }\n+\n+  return y;\n+}\n+\n /* Compute X / Y, rouding towards 0, and return the remainder.\n    Treat X and Y as having the signedness given by SGN.  Indicate\n    in *OVERFLOW if the division overflows.  */"}, {"sha": "bfec2588e534bad25ccf7fc7e243fd787629740b", "filename": "include/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1,3 +1,20 @@\n+2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* gomp-constants.h (GOMP_MAP_FLAG_ALWAYS): Define.\n+\t(enum gomp_map_kind): Add GOMP_MAP_FIRSTPRIVATE,\n+\tGOMP_MAP_FIRSTPRIVATE_INT, GOMP_MAP_USE_DEVICE_PTR,\n+\tGOMP_MAP_ZERO_LEN_ARRAY_SECTION, GOMP_MAP_ALWAYS_TO,\n+\tGOMP_MAP_ALWAYS_FROM, GOMP_MAP_ALWAYS_TOFROM, GOMP_MAP_STRUCT,\n+\tGOMP_MAP_DELETE_ZERO_LEN_ARRAY_SECTION, GOMP_MAP_DELETE,\n+\tGOMP_MAP_RELEASE, GOMP_MAP_FIRSTPRIVATE_POINTER.\n+\t(GOMP_MAP_ALWAYS_TO_P, GOMP_MAP_ALWAYS_FROM_P): Define.\n+\t(GOMP_TASK_FLAG_UNTIED, GOMP_TASK_FLAG_FINAL, GOMP_TASK_FLAG_MERGEABLE,\n+\tGOMP_TASK_FLAG_DEPEND, GOMP_TASK_FLAG_PRIORITY, GOMP_TASK_FLAG_UP,\n+\tGOMP_TASK_FLAG_GRAINSIZE, GOMP_TASK_FLAG_IF, GOMP_TASK_FLAG_NOGROUP,\n+\tGOMP_TARGET_FLAG_NOWAIT, GOMP_TARGET_FLAG_EXIT_DATA,\n+\tGOMP_TARGET_FLAG_UPDATE): Define.\n+\n 2015-09-28  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* gomp-constants.h (GOMP_VERSION_NVIDIA_PTX): Increment."}, {"sha": "f834dec4f1f40e07ad60ef73a4166e88b63680d8", "filename": "include/gomp-constants.h", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -41,6 +41,8 @@\n #define GOMP_MAP_FLAG_SPECIAL_1\t\t(1 << 3)\n #define GOMP_MAP_FLAG_SPECIAL\t\t(GOMP_MAP_FLAG_SPECIAL_1 \\\n \t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL_0)\n+/* OpenMP always flag.  */\n+#define GOMP_MAP_FLAG_ALWAYS\t\t(1 << 6)\n /* Flag to force a specific behavior (or else, trigger a run-time error).  */\n #define GOMP_MAP_FLAG_FORCE\t\t(1 << 7)\n \n@@ -70,14 +72,57 @@ enum gomp_map_kind\n     /* Is a device pointer.  OMP_CLAUSE_SIZE for these is unused; is implicitly\n        POINTER_SIZE_UNITS.  */\n     GOMP_MAP_FORCE_DEVICEPTR =\t\t(GOMP_MAP_FLAG_SPECIAL_1 | 0),\n+    /* Do not map, copy bits for firstprivate instead.  */\n+    GOMP_MAP_FIRSTPRIVATE =\t\t(GOMP_MAP_FLAG_SPECIAL | 0),\n+    /* Similarly, but store the value in the pointer rather than\n+       pointed by the pointer.  */\n+    GOMP_MAP_FIRSTPRIVATE_INT =\t\t(GOMP_MAP_FLAG_SPECIAL | 1),\n+    /* Pointer translate host address into device address and copy that\n+       back to host.  */\n+    GOMP_MAP_USE_DEVICE_PTR =\t\t(GOMP_MAP_FLAG_SPECIAL | 2),\n+    /* Allocate a zero length array section.  Prefer next non-zero length\n+       mapping over previous non-zero length mapping over zero length mapping\n+       at the address.  If not already mapped, do nothing (and pointer translate\n+       to NULL).  */\n+    GOMP_MAP_ZERO_LEN_ARRAY_SECTION = \t(GOMP_MAP_FLAG_SPECIAL | 3),\n     /* Allocate.  */\n     GOMP_MAP_FORCE_ALLOC =\t\t(GOMP_MAP_FLAG_FORCE | GOMP_MAP_ALLOC),\n     /* ..., and copy to device.  */\n     GOMP_MAP_FORCE_TO =\t\t\t(GOMP_MAP_FLAG_FORCE | GOMP_MAP_TO),\n     /* ..., and copy from device.  */\n     GOMP_MAP_FORCE_FROM =\t\t(GOMP_MAP_FLAG_FORCE | GOMP_MAP_FROM),\n     /* ..., and copy to and from device.  */\n-    GOMP_MAP_FORCE_TOFROM =\t\t(GOMP_MAP_FLAG_FORCE | GOMP_MAP_TOFROM)\n+    GOMP_MAP_FORCE_TOFROM =\t\t(GOMP_MAP_FLAG_FORCE | GOMP_MAP_TOFROM),\n+    /* If not already present, allocate.  And unconditionally copy to\n+       device.  */\n+    GOMP_MAP_ALWAYS_TO =\t\t(GOMP_MAP_FLAG_ALWAYS | GOMP_MAP_TO),\n+    /* If not already present, allocate.  And unconditionally copy from\n+       device.  */\n+    GOMP_MAP_ALWAYS_FROM =\t\t(GOMP_MAP_FLAG_ALWAYS | GOMP_MAP_FROM),\n+    /* If not already present, allocate.  And unconditionally copy to and from\n+       device.  */\n+    GOMP_MAP_ALWAYS_TOFROM =\t\t(GOMP_MAP_FLAG_ALWAYS | GOMP_MAP_TOFROM),\n+    /* Map a sparse struct; the address is the base of the structure, alignment\n+       it's required alignment, and size is the number of adjacent entries\n+       that belong to the struct.  The adjacent entries should be sorted by\n+       increasing address, so it is easy to determine lowest needed address\n+       (address of the first adjacent entry) and highest needed address\n+       (address of the last adjacent entry plus its size).  */\n+    GOMP_MAP_STRUCT =\t\t\t(GOMP_MAP_FLAG_ALWAYS\n+\t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL | 0),\n+    /* Forced deallocation of zero length array section.  */\n+    GOMP_MAP_DELETE_ZERO_LEN_ARRAY_SECTION\n+      =\t\t\t\t\t(GOMP_MAP_FLAG_ALWAYS\n+\t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL | 3),\n+    /* OpenMP 4.1 alias for forced deallocation.  */\n+    GOMP_MAP_DELETE =\t\t\tGOMP_MAP_FORCE_DEALLOC,\n+    /* Decrement usage count and deallocate if zero.  */\n+    GOMP_MAP_RELEASE =\t\t\t(GOMP_MAP_FLAG_ALWAYS\n+\t\t\t\t\t | GOMP_MAP_FORCE_DEALLOC),\n+\n+    /* Internal to GCC, not used in libgomp.  */\n+    /* Do not map, but pointer assign a pointer instead.  */\n+    GOMP_MAP_FIRSTPRIVATE_POINTER =\t(GOMP_MAP_LAST | 1)\n   };\n \n #define GOMP_MAP_COPY_TO_P(X) \\\n@@ -91,6 +136,12 @@ enum gomp_map_kind\n #define GOMP_MAP_POINTER_P(X) \\\n   ((X) == GOMP_MAP_POINTER)\n \n+#define GOMP_MAP_ALWAYS_TO_P(X) \\\n+  (((X) == GOMP_MAP_ALWAYS_TO) || ((X) == GOMP_MAP_ALWAYS_TOFROM))\n+\n+#define GOMP_MAP_ALWAYS_FROM_P(X) \\\n+  (((X) == GOMP_MAP_ALWAYS_FROM) || ((X) == GOMP_MAP_ALWAYS_TOFROM))\n+\n \n /* Asynchronous behavior.  Keep in sync with\n    libgomp/{openacc.h,openacc.f90,openacc_lib.h}:acc_async_t.  */\n@@ -113,6 +164,23 @@ enum gomp_map_kind\n #define GOMP_DEVICE_ICV\t\t\t-1\n #define GOMP_DEVICE_HOST_FALLBACK\t-2\n \n+/* GOMP_task/GOMP_taskloop* flags argument.  */\n+#define GOMP_TASK_FLAG_UNTIED\t\t(1 << 0)\n+#define GOMP_TASK_FLAG_FINAL\t\t(1 << 1)\n+#define GOMP_TASK_FLAG_MERGEABLE\t(1 << 2)\n+#define GOMP_TASK_FLAG_DEPEND\t\t(1 << 3)\n+#define GOMP_TASK_FLAG_PRIORITY\t\t(1 << 4)\n+#define GOMP_TASK_FLAG_UP\t\t(1 << 8)\n+#define GOMP_TASK_FLAG_GRAINSIZE\t(1 << 9)\n+#define GOMP_TASK_FLAG_IF\t\t(1 << 10)\n+#define GOMP_TASK_FLAG_NOGROUP\t\t(1 << 11)\n+\n+/* GOMP_target{_41,update_41,enter_exit_data} flags argument.  */\n+#define GOMP_TARGET_FLAG_NOWAIT\t\t(1 << 0)\n+#define GOMP_TARGET_FLAG_EXIT_DATA\t(1 << 1)\n+/* Internal to libgomp.  */\n+#define GOMP_TARGET_FLAG_UPDATE\t\t(1U << 31)\n+\n /* Versions of libgomp and device-specific plugins.  */\n #define GOMP_VERSION\t0\n #define GOMP_VERSION_NVIDIA_PTX 1"}, {"sha": "df4e9370f81409a0ae8c840d899f71100e65cbf6", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -1,3 +1,317 @@\n+2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* config/linux/affinity.c (omp_get_place_num_procs,\n+\tomp_get_place_proc_ids, gomp_get_place_proc_ids_8): New functions.\n+\t* config/linux/doacross.h: New file.\n+\t* config/posix/affinity.c (omp_get_place_num_procs,\n+\tomp_get_place_proc_ids, gomp_get_place_proc_ids_8): New functions.\n+\t* config/posix/doacross.h: New file.\n+\t* env.c: Include gomp-constants.h.\n+\t(struct gomp_task_icv): Rename run_sched_modifier to\n+\trun_sched_chunk_size.\n+\t(gomp_max_task_priority_var): New variable.\n+\t(parse_schedule): Rename run_sched_modifier to run_sched_chunk_size.\n+\t(handle_omp_display_env): Change _OPENMP value from 201307 to\n+\t201511.  Print OMP_MAX_TASK_PRIORITY.\n+\t(initialize_env): Parse OMP_MAX_TASK_PRIORITY.\n+\t(omp_set_schedule, omp_get_schedule): Rename modifier argument to\n+\tchunk_size and run_sched_modifier to run_sched_chunk_size.\n+\t(omp_get_max_task_priority, omp_get_initial_device,\n+\tomp_get_num_places, omp_get_place_num, omp_get_partition_num_places,\n+\tomp_get_partition_place_nums): New functions.\n+\t* fortran.c (omp_set_schedule_, omp_set_schedule_8_,\n+\tomp_get_schedule_, omp_get_schedule_8_): Rename modifier argument\n+\tto chunk_size.\n+\t(omp_get_num_places_, omp_get_place_num_procs_,\n+\tomp_get_place_num_procs_8_, omp_get_place_proc_ids_,\n+\tomp_get_place_proc_ids_8_, omp_get_place_num_,\n+\tomp_get_partition_num_places_, omp_get_partition_place_nums_,\n+\tomp_get_partition_place_nums_8_, omp_get_initial_device_,\n+\tomp_get_max_task_priority_): New functions.\n+\t* libgomp_g.h (GOMP_loop_doacross_static_start,\n+\tGOMP_loop_doacross_dynamic_start, GOMP_loop_doacross_guided_start,\n+\tGOMP_loop_doacross_runtime_start, GOMP_loop_ull_doacross_static_start,\n+\tGOMP_loop_ull_doacross_dynamic_start,\n+\tGOMP_loop_ull_doacross_guided_start,\n+\tGOMP_loop_ull_doacross_runtime_start, GOMP_doacross_post,\n+\tGOMP_doacross_wait, GOMP_doacross_ull_post, GOMP_doacross_wait,\n+\tGOMP_taskloop, GOMP_taskloop_ull, GOMP_target_41,\n+\tGOMP_target_data_41, GOMP_target_update_41,\n+\tGOMP_target_enter_exit_data): New prototypes.\n+\t(GOMP_task): Add prototype argument.\n+\t* libgomp.h (_LIBGOMP_CHECKING_): Define to 0 if not yet defined.\n+\t(struct gomp_doacross_work_share): New type.\n+\t(struct gomp_work_share): Add doacross field.\n+\t(struct gomp_task_icv): Rename run_sched_modifier to\n+\trun_sched_chunk_size.\n+\t(enum gomp_task_kind): Rename GOMP_TASK_IFFALSE to\n+\tGOMP_TASK_UNDEFERRED.  Add comments.\n+\t(struct gomp_task_depend_entry): Add comments.\n+\t(struct gomp_task): Likewise.\n+\t(struct gomp_taskgroup): Likewise.\n+\t(struct gomp_target_task): New type.\n+\t(struct gomp_team): Add comment.\n+\t(gomp_get_place_proc_ids_8, gomp_doacross_init,\n+\tgomp_doacross_ull_init, gomp_task_maybe_wait_for_dependencies,\n+\tgomp_create_target_task, gomp_target_task_fn): New prototypes.\n+\t(struct target_var_desc): New type.\n+\t(struct target_mem_desc): Adjust comment.  Use struct\n+\ttarget_var_desc instead of splay_tree_key for list.\n+\t(REFCOUNT_INFINITY): Define.\n+\t(struct splay_tree_key_s): Remove copy_from field.\n+\t(struct gomp_device_descr): Add dev2dev_func field.\n+\t(enum gomp_map_vars_kind): New enum.\n+\t(gomp_map_vars): Add one argument.\n+\t* libgomp.map (OMP_4.5): Export omp_get_max_task_priority,\n+\tomp_get_max_task_priority_, omp_get_num_places, omp_get_num_places_,\n+\tomp_get_place_num_procs, omp_get_place_num_procs_,\n+\tomp_get_place_num_procs_8_, omp_get_place_proc_ids,\n+\tomp_get_place_proc_ids_, omp_get_place_proc_ids_8_, omp_get_place_num,\n+\tomp_get_place_num_, omp_get_partition_num_places,\n+\tomp_get_partition_num_places_, omp_get_partition_place_nums,\n+\tomp_get_partition_place_nums_, omp_get_partition_place_nums_8_,\n+\tomp_get_initial_device, omp_get_initial_device_, omp_target_alloc,\n+\tomp_target_free, omp_target_is_present, omp_target_memcpy,\n+\tomp_target_memcpy_rect, omp_target_associate_ptr and\n+\tomp_target_disassociate_ptr.\n+\t(GOMP_4.0.2): Renamed to ...\n+\t(GOMP_4.5): ... this.  Export GOMP_target_41, GOMP_target_data_41,\n+\tGOMP_target_update_41, GOMP_target_enter_exit_data, GOMP_taskloop,\n+\tGOMP_taskloop_ull, GOMP_loop_doacross_dynamic_start,\n+\tGOMP_loop_doacross_guided_start, GOMP_loop_doacross_runtime_start,\n+\tGOMP_loop_doacross_static_start, GOMP_doacross_post,\n+\tGOMP_doacross_wait, GOMP_loop_ull_doacross_dynamic_start,\n+\tGOMP_loop_ull_doacross_guided_start,\n+\tGOMP_loop_ull_doacross_runtime_start,\n+\tGOMP_loop_ull_doacross_static_start, GOMP_doacross_ull_post and\n+\tGOMP_doacross_ull_wait.\n+\t* libgomp.texi: Document omp_get_max_task_priority.\n+\tRename modifier argument to chunk_size for omp_set_schedule and\n+\tomp_get_schedule.  Document OMP_MAX_TASK_PRIORITY env var.\n+\t* loop.c (GOMP_loop_runtime_start): Adjust for run_sched_modifier\n+\tto run_sched_chunk_size renaming.\n+\t(GOMP_loop_ordered_runtime_start): Likewise.\n+\t(gomp_loop_doacross_static_start, gomp_loop_doacross_dynamic_start,\n+\tgomp_loop_doacross_guided_start, GOMP_loop_doacross_runtime_start,\n+\tGOMP_parallel_loop_runtime_start): New functions.\n+\t(GOMP_parallel_loop_runtime): Adjust for run_sched_modifier\n+\tto run_sched_chunk_size renaming.\n+\t(GOMP_loop_doacross_static_start, GOMP_loop_doacross_dynamic_start,\n+\tGOMP_loop_doacross_guided_start): New functions or aliases.\n+\t* loop_ull.c (GOMP_loop_ull_runtime_start): Adjust for\n+\trun_sched_modifier to run_sched_chunk_size renaming.\n+\t(GOMP_loop_ull_ordered_runtime_start): Likewise.\n+\t(gomp_loop_ull_doacross_static_start,\n+\tgomp_loop_ull_doacross_dynamic_start,\n+\tgomp_loop_ull_doacross_guided_start,\n+\tGOMP_loop_ull_doacross_runtime_start): New functions.\n+\t(GOMP_loop_ull_doacross_static_start,\n+\tGOMP_loop_ull_doacross_dynamic_start,\n+\tGOMP_loop_ull_doacross_guided_start): New functions or aliases.\n+\t* oacc-mem.c (acc_map_data, present_create_copy,\n+\tgomp_acc_insert_pointer): Pass GOMP_MAP_VARS_OPENACC instead of false\n+\tto gomp_map_vars.\n+\t(gomp_acc_remove_pointer): Use copy_from from target_var_desc.\n+\t* oacc-parallel.c (GOACC_data_start): Pass GOMP_MAP_VARS_OPENACC\n+\tinstead of false to gomp_map_vars.\n+\t(GOACC_parallel_keyed): Likewise.  Use copy_from from target_var_desc.\n+\t* omp.h.in (omp_lock_hint_t): New type.\n+\t(omp_init_lock_with_hint, omp_init_nest_lock_with_hint,\n+\tomp_get_num_places, omp_get_place_num_procs, omp_get_place_proc_ids,\n+\tomp_get_place_num, omp_get_partition_num_places,\n+\tomp_get_partition_place_nums, omp_get_initial_device,\n+\tomp_get_max_task_priority, omp_target_alloc, omp_target_free,\n+\tomp_target_is_present, omp_target_memcpy, omp_target_memcpy_rect,\n+\tomp_target_associate_ptr, omp_target_disassociate_ptr): New\n+\tprototypes.\n+\t* omp_lib.f90.in (omp_lock_hint_kind): New parameter.\n+\t(omp_lock_hint_none, omp_lock_hint_uncontended,\n+\tomp_lock_hint_contended, omp_lock_hint_nonspeculative,\n+\tomp_lock_hint_speculative): New parameters.\n+\t(omp_init_lock_with_hint, omp_init_nest_lock_with_hint,\n+\tomp_get_num_places, omp_get_place_num_procs, omp_get_place_proc_ids,\n+\tomp_get_place_num, omp_get_partition_num_places,\n+\tomp_get_partition_place_nums, omp_get_initial_device,\n+\tomp_get_max_task_priority): New interfaces.\n+\t(omp_set_schedule, omp_get_schedule): Rename modifier argument\n+\tto chunk_size.\n+\t* omp_lib.h.in (omp_lock_hint_kind): New parameter.\n+\t(omp_lock_hint_none, omp_lock_hint_uncontended,\n+\tomp_lock_hint_contended, omp_lock_hint_nonspeculative,\n+\tomp_lock_hint_speculative): New parameters.\n+\t(omp_init_lock_with_hint, omp_init_nest_lock_with_hint,\n+\tomp_get_num_places, omp_get_place_num_procs, omp_get_place_proc_ids,\n+\tomp_get_place_num, omp_get_partition_num_places,\n+\tomp_get_partition_place_nums, omp_get_initial_device,\n+\tomp_get_max_task_priority): New functions and subroutines.\n+\t* ordered.c: Include stdarg.h and string.h.\n+\t(MAX_COLLAPSED_BITS): Define.\n+\t(gomp_doacross_init, GOMP_doacross_post, GOMP_doacross_wait,\n+\tgomp_doacross_ull_init, GOMP_doacross_ull_post,\n+\tGOMP_doacross_ull_wait): New functions.\n+\t* target.c: Include errno.h.\n+\t(resolve_device): If device is not initialized, call\n+\tgomp_init_device on it.\n+\t(gomp_map_lookup): New function.\n+\t(gomp_map_vars_existing): Add tgt_var argument, fill it in.\n+\tDon't bump refcount if REFCOUNT_INFINITY.  Handle\n+\tGOMP_MAP_ALWAYS_TO_P.\n+\t(get_kind): Rename is_openacc argument to short_mapkind.\n+\t(gomp_map_pointer): Use gomp_map_lookup.\n+\t(gomp_map_fields_existing): New function.\n+\t(gomp_map_vars): Rename is_openacc argument to short_mapkind\n+\tand is_target to pragma_kind.  Handle GOMP_MAP_VARS_ENTER_DATA,\n+\thandle GOMP_MAP_FIRSTPRIVATE_INT, GOMP_MAP_STRUCT,\n+\tGOMP_MAP_USE_DEVICE_PTR, GOMP_MAP_ZERO_LEN_ARRAY_SECTION.\n+\tAdjust for tgt->list changed type and copy_from living in there.\n+\t(gomp_copy_from_async): Adjust for tgt->list changed type and\n+\tcopy_from living in there.\n+\t(gomp_unmap_vars): Likewise.\n+\t(gomp_update): Likewise.  Rename is_openacc argument to\n+\tshort_mapkind.  Don't fail if object is not mapped.\n+\t(gomp_load_image_to_device): Initialize refcount to\n+\tREFCOUNT_INFINITY.\n+\t(gomp_target_fallback): New function.\n+\t(gomp_get_target_fn_addr): Likewise.\n+\t(GOMP_target): Adjust gomp_map_vars caller, use\n+\tgomp_get_target_fn_addr and gomp_target_fallback.\n+\t(GOMP_target_41): New function.\n+\t(gomp_target_data_fallback): New function.\n+\t(GOMP_target_data): Use it, adjust gomp_map_vars caller.\n+\t(GOMP_target_data_41): New function.\n+\t(GOMP_target_update): Adjust gomp_update caller.\n+\t(GOMP_target_update_41): New function.\n+\t(gomp_exit_data, GOMP_target_enter_exit_data,\n+\tgomp_target_task_fn, omp_target_alloc, omp_target_free,\n+\tomp_target_is_present, omp_target_memcpy,\n+\tomp_target_memcpy_rect_worker, omp_target_memcpy_rect,\n+\tomp_target_associate_ptr, omp_target_disassociate_ptr,\n+\tgomp_load_plugin_for_device): New functions.\n+\t* task.c: Include gomp-constants.h.  Include taskloop.c\n+\ttwice to get GOMP_taskloop and GOMP_taskloop_ull definitions.\n+\t(gomp_task_handle_depend): New function.\n+\t(GOMP_task): Use it.  Add priority argument.  Use\n+\tgomp-constant.h constants instead of hardcoded numbers.\n+\tRename GOMP_TASK_IFFALSE to GOMP_TASK_UNDEFERRED.\n+\t(gomp_create_target_task): New function.\n+\t(verify_children_queue, verify_taskgroup_queue,\n+\tverify_task_queue): New functions.\n+\t(gomp_task_run_pre): Call verify_*_queue functions.\n+\tIf an upcoming tied task is about to leave the sibling or\n+\ttaskgroup queues in an invalid state, adjust appropriately.\n+\tRemove taskgroup argument.  Add comments.\n+\t(gomp_task_run_post_handle_dependers): Add comments.\n+\t(gomp_task_run_post_remove_parent): Likewise.\n+\t(gomp_barrier_handle_tasks): Adjust gomp_task_run_pre caller.\n+\t(GOMP_taskwait): Likewise.  Add comments.\n+\t(gomp_task_maybe_wait_for_dependencies): Fix scheduling\n+\tproblem such that the first non parent_depends_on task does not\n+\tend up at the end of the children queue.\n+\t(GOMP_taskgroup_start): Rename GOMP_TASK_IFFALSE to\n+\tGOMP_TASK_UNDEFERRED.\n+\t(GOMP_taskgroup_end): Adjust gomp_task_run_pre caller.\n+\t* taskloop.c: New file.\n+\t* testsuite/lib/libgomp.exp\n+\t(check_effective_target_offload_device_nonshared_as): New proc.\n+\t* testsuite/libgomp.c/affinity-2.c: New test.\n+\t* testsuite/libgomp.c/doacross-1.c: New test.\n+\t* testsuite/libgomp.c/doacross-2.c: New test.\n+\t* testsuite/libgomp.c/examples-4/declare_target-1.c (fib_wrapper):\n+\tAdd map clause to target.\n+\t* testsuite/libgomp.c/examples-4/declare_target-4.c (accum): Likewise.\n+\t* testsuite/libgomp.c/examples-4/declare_target-5.c (accum): Likewise.\n+\t* testsuite/libgomp.c/examples-4/device-1.c (main): Likewise.\n+\t* testsuite/libgomp.c/examples-4/device-3.c (main): Likewise.\n+\t* testsuite/libgomp.c/examples-4/target_data-3.c (gramSchmidt):\n+\tLikewise.\n+\t* testsuite/libgomp.c/examples-4/teams-2.c (dotprod): Likewise.\n+\t* testsuite/libgomp.c/examples-4/teams-3.c (dotprod): Likewise.\n+\t* testsuite/libgomp.c/examples-4/teams-4.c (dotprod): Likewise.\n+\t* testsuite/libgomp.c/for-2.h (OMPTGT, OMPTO, OMPFROM): Define if\n+\tnot defined.  Use those where needed.\n+\t* testsuite/libgomp.c/for-4.c: New test.\n+\t* testsuite/libgomp.c/for-5.c: New test.\n+\t* testsuite/libgomp.c/for-6.c: New test.\n+\t* testsuite/libgomp.c/linear-1.c: New test.\n+\t* testsuite/libgomp.c/ordered-4.c: New test.\n+\t* testsuite/libgomp.c/pr66199-2.c (f2): Adjust for linear clause\n+\tonly allowed on the loop iterator.\n+\t* testsuite/libgomp.c/pr66199-3.c: New test.\n+\t* testsuite/libgomp.c/pr66199-4.c: New test.\n+\t* testsuite/libgomp.c/reduction-7.c: New test.\n+\t* testsuite/libgomp.c/reduction-8.c: New test.\n+\t* testsuite/libgomp.c/reduction-9.c: New test.\n+\t* testsuite/libgomp.c/reduction-10.c: New test.\n+\t* testsuite/libgomp.c/target-1.c (fn2, fn3, fn4): Add\n+\tmap(tofrom:s).\n+\t* testsuite/libgomp.c/target-2.c (fn2, fn3, fn4): Likewise.\n+\t* testsuite/libgomp.c/target-7.c (foo): Add map(h) where needed.\n+\t* testsuite/libgomp.c/target-11.c: New test.\n+\t* testsuite/libgomp.c/target-12.c: New test.\n+\t* testsuite/libgomp.c/target-13.c: New test.\n+\t* testsuite/libgomp.c/target-14.c: New test.\n+\t* testsuite/libgomp.c/target-15.c: New test.\n+\t* testsuite/libgomp.c/target-16.c: New test.\n+\t* testsuite/libgomp.c/target-17.c: New test.\n+\t* testsuite/libgomp.c/target-18.c: New test.\n+\t* testsuite/libgomp.c/target-19.c: New test.\n+\t* testsuite/libgomp.c/target-20.c: New test.\n+\t* testsuite/libgomp.c/target-21.c: New test.\n+\t* testsuite/libgomp.c/target-22.c: New test.\n+\t* testsuite/libgomp.c/target-23.c: New test.\n+\t* testsuite/libgomp.c/target-24.c: New test.\n+\t* testsuite/libgomp.c/target-25.c: New test.\n+\t* testsuite/libgomp.c/target-26.c: New test.\n+\t* testsuite/libgomp.c/target-27.c: New test.\n+\t* testsuite/libgomp.c/taskloop-1.c: New test.\n+\t* testsuite/libgomp.c/taskloop-2.c: New test.\n+\t* testsuite/libgomp.c/taskloop-3.c: New test.\n+\t* testsuite/libgomp.c/taskloop-4.c: New test.\n+\t* testsuite/libgomp.c++/ctor-13.C: New test.\n+\t* testsuite/libgomp.c++/doacross-1.C: New test.\n+\t* testsuite/libgomp.c++/examples-4/declare_target-2.C:\n+\tReplace offload_device with offload_device_nonshared_as.\n+\t* testsuite/libgomp.c++/for-12.C: New test.\n+\t* testsuite/libgomp.c++/for-13.C: New test.\n+\t* testsuite/libgomp.c++/for-14.C: New test.\n+\t* testsuite/libgomp.c++/linear-1.C: New test.\n+\t* testsuite/libgomp.c++/member-1.C: New test.\n+\t* testsuite/libgomp.c++/member-2.C: New test.\n+\t* testsuite/libgomp.c++/member-3.C: New test.\n+\t* testsuite/libgomp.c++/member-4.C: New test.\n+\t* testsuite/libgomp.c++/member-5.C: New test.\n+\t* testsuite/libgomp.c++/ordered-1.C: New test.\n+\t* testsuite/libgomp.c++/reduction-5.C: New test.\n+\t* testsuite/libgomp.c++/reduction-6.C: New test.\n+\t* testsuite/libgomp.c++/reduction-7.C: New test.\n+\t* testsuite/libgomp.c++/reduction-8.C: New test.\n+\t* testsuite/libgomp.c++/reduction-9.C: New test.\n+\t* testsuite/libgomp.c++/reduction-10.C: New test.\n+\t* testsuite/libgomp.c++/reference-1.C: New test.\n+\t* testsuite/libgomp.c++/simd14.C: New test.\n+\t* testsuite/libgomp.c++/target-2.C (fn2): Add map(tofrom: s) clause.\n+\t* testsuite/libgomp.c++/target-5.C: New test.\n+\t* testsuite/libgomp.c++/target-6.C: New test.\n+\t* testsuite/libgomp.c++/target-7.C: New test.\n+\t* testsuite/libgomp.c++/target-8.C: New test.\n+\t* testsuite/libgomp.c++/target-9.C: New test.\n+\t* testsuite/libgomp.c++/target-10.C: New test.\n+\t* testsuite/libgomp.c++/target-11.C: New test.\n+\t* testsuite/libgomp.c++/target-12.C: New test.\n+\t* testsuite/libgomp.c++/taskloop-1.C: New test.\n+\t* testsuite/libgomp.c++/taskloop-2.C: New test.\n+\t* testsuite/libgomp.c++/taskloop-3.C: New test.\n+\t* testsuite/libgomp.c++/taskloop-4.C: New test.\n+\t* testsuite/libgomp.c++/taskloop-5.C: New test.\n+\t* testsuite/libgomp.c++/taskloop-6.C: New test.\n+\t* testsuite/libgomp.c++/taskloop-7.C: New test.\n+\t* testsuite/libgomp.c++/taskloop-8.C: New test.\n+\t* testsuite/libgomp.c++/taskloop-9.C: New test.\n+\t* testsuite/libgomp.fortran/affinity1.f90: New test.\n+\t* testsuite/libgomp.fortran/affinity2.f90: New test.\n+\n 2015-10-13  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/67476"}, {"sha": "775ee0a7fdf0258c8a3bb2b5ddf1006606bc64f9", "filename": "libgomp/config/linux/affinity.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fconfig%2Flinux%2Faffinity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fconfig%2Flinux%2Faffinity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Faffinity.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -353,6 +353,45 @@ gomp_affinity_print_place (void *p)\n     fprintf (stderr, \":%lu\", len);\n }\n \n+int\n+omp_get_place_num_procs (int place_num)\n+{\n+  if (place_num < 0 || place_num >= gomp_places_list_len)\n+    return 0;\n+\n+  cpu_set_t *cpusetp = (cpu_set_t *) gomp_places_list[place_num];\n+  return gomp_cpuset_popcount (gomp_cpuset_size, cpusetp);\n+}\n+\n+void\n+omp_get_place_proc_ids (int place_num, int *ids)\n+{\n+  if (place_num < 0 || place_num >= gomp_places_list_len)\n+    return;\n+\n+  cpu_set_t *cpusetp = (cpu_set_t *) gomp_places_list[place_num];\n+  unsigned long i, max = 8 * gomp_cpuset_size;\n+  for (i = 0; i < max; i++)\n+    if (CPU_ISSET_S (i, gomp_cpuset_size, cpusetp))\n+      *ids++ = i;\n+}\n+\n+void\n+gomp_get_place_proc_ids_8 (int place_num, int64_t *ids)\n+{\n+  if (place_num < 0 || place_num >= gomp_places_list_len)\n+    return;\n+\n+  cpu_set_t *cpusetp = (cpu_set_t *) gomp_places_list[place_num];\n+  unsigned long i, max = 8 * gomp_cpuset_size;\n+  for (i = 0; i < max; i++)\n+    if (CPU_ISSET_S (i, gomp_cpuset_size, cpusetp))\n+      *ids++ = i;\n+}\n+\n+ialias(omp_get_place_num_procs)\n+ialias(omp_get_place_proc_ids)\n+\n #else\n \n #include \"../posix/affinity.c\""}, {"sha": "7a5a645f3cfdd36c83d49ffd2f3eb1320ebaaea3", "filename": "libgomp/config/linux/doacross.h", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fconfig%2Flinux%2Fdoacross.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fconfig%2Flinux%2Fdoacross.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fdoacross.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,57 @@\n+/* Copyright (C) 2015 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is a Linux specific implementation of doacross spinning.  */\n+\n+#ifndef GOMP_DOACROSS_H\n+#define GOMP_DOACROSS_H 1\n+\n+#include \"libgomp.h\"\n+#include <errno.h>\n+#include \"wait.h\"\n+\n+#ifdef HAVE_ATTRIBUTE_VISIBILITY\n+# pragma GCC visibility push(hidden)\n+#endif\n+\n+static inline void doacross_spin (unsigned long *addr, unsigned long expected,\n+\t\t\t\t  unsigned long cur)\n+{\n+  /* FIXME: back off depending on how large expected - cur is.  */\n+  do\n+    {\n+      cpu_relax ();\n+      cur = __atomic_load_n (addr, MEMMODEL_RELAXED);\n+      if (expected < cur)\n+\treturn;\n+    }\n+  while (1);\n+}\n+\n+#ifdef HAVE_ATTRIBUTE_VISIBILITY\n+# pragma GCC visibility pop\n+#endif\n+\n+#endif /* GOMP_DOACROSS_H */"}, {"sha": "9008853c953cecebbffa62b408d948c3d183b2ae", "filename": "libgomp/config/posix/affinity.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fconfig%2Fposix%2Faffinity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fconfig%2Fposix%2Faffinity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Faffinity.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -114,3 +114,27 @@ gomp_affinity_print_place (void *p)\n {\n   (void) p;\n }\n+\n+int\n+omp_get_place_num_procs (int place_num)\n+{\n+  (void) place_num;\n+  return 0;\n+}\n+\n+void\n+omp_get_place_proc_ids (int place_num, int *ids)\n+{\n+  (void) place_num;\n+  (void) ids;\n+}\n+\n+void\n+gomp_get_place_proc_ids_8 (int place_num, int64_t *ids)\n+{\n+  (void) place_num;\n+  (void) ids;\n+}\n+\n+ialias(omp_get_place_num_procs)\n+ialias(omp_get_place_proc_ids)"}, {"sha": "537bcbba51c04d7e1a83ad9377dfdfb6258a6272", "filename": "libgomp/config/posix/doacross.h", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fconfig%2Fposix%2Fdoacross.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fconfig%2Fposix%2Fdoacross.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fdoacross.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -0,0 +1,62 @@\n+/* Copyright (C) 2015 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is a generic implementation of doacross spinning.  */\n+\n+#ifndef GOMP_DOACROSS_H\n+#define GOMP_DOACROSS_H 1\n+\n+#include \"libgomp.h\"\n+#include <errno.h>\n+\n+#ifdef HAVE_ATTRIBUTE_VISIBILITY\n+# pragma GCC visibility push(hidden)\n+#endif\n+\n+static inline void\n+cpu_relax (void)\n+{\n+  __asm volatile (\"\" : : : \"memory\");\n+}\n+\n+static inline void doacross_spin (unsigned long *addr, unsigned long expected,\n+\t\t\t\t  unsigned long cur)\n+{\n+  /* FIXME: back off depending on how large expected - cur is.  */\n+  do\n+    {\n+      cpu_relax ();\n+      cur = __atomic_load_n (addr, MEMMODEL_RELAXED);\n+      if (expected < cur)\n+\treturn;\n+    }\n+  while (1);\n+}\n+\n+#ifdef HAVE_ATTRIBUTE_VISIBILITY\n+# pragma GCC visibility pop\n+#endif\n+\n+#endif /* GOMP_DOACROSS_H */"}, {"sha": "5d6cdcf01841310f049eeed4f3555df42772943c", "filename": "libgomp/env.c", "status": "modified", "additions": 83, "deletions": 13, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fenv.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -29,6 +29,7 @@\n #include \"libgomp.h\"\n #include \"libgomp_f.h\"\n #include \"oacc-int.h\"\n+#include \"gomp-constants.h\"\n #include <ctype.h>\n #include <stdlib.h>\n #include <stdio.h>\n@@ -58,7 +59,7 @@ struct gomp_task_icv gomp_global_icv = {\n   .nthreads_var = 1,\n   .thread_limit_var = UINT_MAX,\n   .run_sched_var = GFS_DYNAMIC,\n-  .run_sched_modifier = 1,\n+  .run_sched_chunk_size = 1,\n   .default_device_var = 0,\n   .dyn_var = false,\n   .nest_var = false,\n@@ -68,6 +69,7 @@ struct gomp_task_icv gomp_global_icv = {\n \n unsigned long gomp_max_active_levels_var = INT_MAX;\n bool gomp_cancel_var = false;\n+int gomp_max_task_priority_var = 0;\n #ifndef HAVE_SYNC_BUILTINS\n gomp_mutex_t gomp_managed_threads_lock;\n #endif\n@@ -123,7 +125,7 @@ parse_schedule (void)\n     ++env;\n   if (*env == '\\0')\n     {\n-      gomp_global_icv.run_sched_modifier\n+      gomp_global_icv.run_sched_chunk_size\n \t= gomp_global_icv.run_sched_var != GFS_STATIC;\n       return;\n     }\n@@ -149,7 +151,7 @@ parse_schedule (void)\n \n   if (value == 0 && gomp_global_icv.run_sched_var != GFS_STATIC)\n     value = 1;\n-  gomp_global_icv.run_sched_modifier = value;\n+  gomp_global_icv.run_sched_chunk_size = value;\n   return;\n \n  unknown:\n@@ -1069,7 +1071,7 @@ handle_omp_display_env (unsigned long stacksize, int wait_policy)\n \n   fputs (\"\\nOPENMP DISPLAY ENVIRONMENT BEGIN\\n\", stderr);\n \n-  fputs (\"  _OPENMP = '201307'\\n\", stderr);\n+  fputs (\"  _OPENMP = '201511'\\n\", stderr);\n   fprintf (stderr, \"  OMP_DYNAMIC = '%s'\\n\",\n \t   gomp_global_icv.dyn_var ? \"TRUE\" : \"FALSE\");\n   fprintf (stderr, \"  OMP_NESTED = '%s'\\n\",\n@@ -1157,6 +1159,8 @@ handle_omp_display_env (unsigned long stacksize, int wait_policy)\n \t   gomp_cancel_var ? \"TRUE\" : \"FALSE\");\n   fprintf (stderr, \"  OMP_DEFAULT_DEVICE = '%d'\\n\",\n \t   gomp_global_icv.default_device_var);\n+  fprintf (stderr, \"  OMP_MAX_TASK_PRIORITY = '%d'\\n\",\n+\t   gomp_max_task_priority_var);\n \n   if (verbose)\n     {\n@@ -1189,6 +1193,7 @@ initialize_env (void)\n   parse_boolean (\"OMP_NESTED\", &gomp_global_icv.nest_var);\n   parse_boolean (\"OMP_CANCELLATION\", &gomp_cancel_var);\n   parse_int (\"OMP_DEFAULT_DEVICE\", &gomp_global_icv.default_device_var, true);\n+  parse_int (\"OMP_MAX_TASK_PRIORITY\", &gomp_max_task_priority_var, true);\n   parse_unsigned_long (\"OMP_MAX_ACTIVE_LEVELS\", &gomp_max_active_levels_var,\n \t\t       true);\n   if (parse_unsigned_long (\"OMP_THREAD_LIMIT\", &thread_limit_var, false))\n@@ -1337,21 +1342,21 @@ omp_get_nested (void)\n }\n \n void\n-omp_set_schedule (omp_sched_t kind, int modifier)\n+omp_set_schedule (omp_sched_t kind, int chunk_size)\n {\n   struct gomp_task_icv *icv = gomp_icv (true);\n   switch (kind)\n     {\n     case omp_sched_static:\n-      if (modifier < 1)\n-\tmodifier = 0;\n-      icv->run_sched_modifier = modifier;\n+      if (chunk_size < 1)\n+\tchunk_size = 0;\n+      icv->run_sched_chunk_size = chunk_size;\n       break;\n     case omp_sched_dynamic:\n     case omp_sched_guided:\n-      if (modifier < 1)\n-\tmodifier = 1;\n-      icv->run_sched_modifier = modifier;\n+      if (chunk_size < 1)\n+\tchunk_size = 1;\n+      icv->run_sched_chunk_size = chunk_size;\n       break;\n     case omp_sched_auto:\n       break;\n@@ -1362,11 +1367,11 @@ omp_set_schedule (omp_sched_t kind, int modifier)\n }\n \n void\n-omp_get_schedule (omp_sched_t *kind, int *modifier)\n+omp_get_schedule (omp_sched_t *kind, int *chunk_size)\n {\n   struct gomp_task_icv *icv = gomp_icv (false);\n   *kind = icv->run_sched_var;\n-  *modifier = icv->run_sched_modifier;\n+  *chunk_size = icv->run_sched_chunk_size;\n }\n \n int\n@@ -1402,6 +1407,12 @@ omp_get_cancellation (void)\n   return gomp_cancel_var;\n }\n \n+int\n+omp_get_max_task_priority (void)\n+{\n+  return gomp_max_task_priority_var;\n+}\n+\n omp_proc_bind_t\n omp_get_proc_bind (void)\n {\n@@ -1450,6 +1461,59 @@ omp_is_initial_device (void)\n   return 1;\n }\n \n+int\n+omp_get_initial_device (void)\n+{\n+  return GOMP_DEVICE_HOST_FALLBACK;\n+}\n+\n+int\n+omp_get_num_places (void)\n+{\n+  return gomp_places_list_len;\n+}\n+\n+int\n+omp_get_place_num (void)\n+{\n+  if (gomp_places_list == NULL)\n+    return -1;\n+\n+  struct gomp_thread *thr = gomp_thread ();\n+  if (thr->place == 0)\n+    gomp_init_affinity ();\n+\n+  return (int) thr->place - 1;\n+}\n+\n+int\n+omp_get_partition_num_places (void)\n+{\n+  if (gomp_places_list == NULL)\n+    return 0;\n+\n+  struct gomp_thread *thr = gomp_thread ();\n+  if (thr->place == 0)\n+    gomp_init_affinity ();\n+\n+  return thr->ts.place_partition_len;\n+}\n+\n+void\n+omp_get_partition_place_nums (int *place_nums)\n+{\n+  if (gomp_places_list == NULL)\n+    return;\n+\n+  struct gomp_thread *thr = gomp_thread ();\n+  if (thr->place == 0)\n+    gomp_init_affinity ();\n+\n+  unsigned int i;\n+  for (i = 0; i < thr->ts.place_partition_len; i++)\n+    *place_nums++ = thr->ts.place_partition_off + i;\n+}\n+\n ialias (omp_set_dynamic)\n ialias (omp_set_nested)\n ialias (omp_set_num_threads)\n@@ -1469,3 +1533,9 @@ ialias (omp_get_num_devices)\n ialias (omp_get_num_teams)\n ialias (omp_get_team_num)\n ialias (omp_is_initial_device)\n+ialias (omp_get_initial_device)\n+ialias (omp_get_max_task_priority)\n+ialias (omp_get_num_places)\n+ialias (omp_get_place_num)\n+ialias (omp_get_partition_num_places)\n+ialias (omp_get_partition_place_nums)"}, {"sha": "ceff9ac48e66d97bd02dc05083c5b96e792bd800", "filename": "libgomp/fortran.c", "status": "modified", "additions": 95, "deletions": 12, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ffortran.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ffortran.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ffortran.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -68,12 +68,20 @@ ialias_redirect (omp_get_active_level)\n ialias_redirect (omp_in_final)\n ialias_redirect (omp_get_cancellation)\n ialias_redirect (omp_get_proc_bind)\n+ialias_redirect (omp_get_num_places)\n+ialias_redirect (omp_get_place_num_procs)\n+ialias_redirect (omp_get_place_proc_ids)\n+ialias_redirect (omp_get_place_num)\n+ialias_redirect (omp_get_partition_num_places)\n+ialias_redirect (omp_get_partition_place_nums)\n ialias_redirect (omp_set_default_device)\n ialias_redirect (omp_get_default_device)\n ialias_redirect (omp_get_num_devices)\n ialias_redirect (omp_get_num_teams)\n ialias_redirect (omp_get_team_num)\n ialias_redirect (omp_is_initial_device)\n+ialias_redirect (omp_get_initial_device)\n+ialias_redirect (omp_get_max_task_priority)\n #endif\n \n #ifndef LIBGOMP_GNU_SYMBOL_VERSIONING\n@@ -343,35 +351,35 @@ omp_get_wtime_ (void)\n }\n \n void\n-omp_set_schedule_ (const int32_t *kind, const int32_t *modifier)\n+omp_set_schedule_ (const int32_t *kind, const int32_t *chunk_size)\n {\n-  omp_set_schedule (*kind, *modifier);\n+  omp_set_schedule (*kind, *chunk_size);\n }\n \n void\n-omp_set_schedule_8_ (const int32_t *kind, const int64_t *modifier)\n+omp_set_schedule_8_ (const int32_t *kind, const int64_t *chunk_size)\n {\n-  omp_set_schedule (*kind, TO_INT (*modifier));\n+  omp_set_schedule (*kind, TO_INT (*chunk_size));\n }\n \n void\n-omp_get_schedule_ (int32_t *kind, int32_t *modifier)\n+omp_get_schedule_ (int32_t *kind, int32_t *chunk_size)\n {\n   omp_sched_t k;\n-  int m;\n-  omp_get_schedule (&k, &m);\n+  int cs;\n+  omp_get_schedule (&k, &cs);\n   *kind = k;\n-  *modifier = m;\n+  *chunk_size = cs;\n }\n \n void\n-omp_get_schedule_8_ (int32_t *kind, int64_t *modifier)\n+omp_get_schedule_8_ (int32_t *kind, int64_t *chunk_size)\n {\n   omp_sched_t k;\n-  int m;\n-  omp_get_schedule (&k, &m);\n+  int cs;\n+  omp_get_schedule (&k, &cs);\n   *kind = k;\n-  *modifier = m;\n+  *chunk_size = cs;\n }\n \n int32_t\n@@ -452,6 +460,69 @@ omp_get_proc_bind_ (void)\n   return omp_get_proc_bind ();\n }\n \n+int32_t\n+omp_get_num_places_ (void)\n+{\n+  return omp_get_num_places ();\n+}\n+\n+int32_t\n+omp_get_place_num_procs_ (const int32_t *place_num)\n+{\n+  return omp_get_place_num_procs (*place_num);\n+}\n+\n+int32_t\n+omp_get_place_num_procs_8_ (const int64_t *place_num)\n+{\n+  return omp_get_place_num_procs (TO_INT (*place_num));\n+}\n+\n+void\n+omp_get_place_proc_ids_ (const int32_t *place_num, int32_t *ids)\n+{\n+  omp_get_place_proc_ids (*place_num, ids);\n+}\n+\n+void\n+omp_get_place_proc_ids_8_ (const int64_t *place_num, int64_t *ids)\n+{\n+  gomp_get_place_proc_ids_8 (TO_INT (*place_num), ids);\n+}\n+\n+int32_t\n+omp_get_place_num_ (void)\n+{\n+  return omp_get_place_num ();\n+}\n+\n+int32_t\n+omp_get_partition_num_places_ (void)\n+{\n+  return omp_get_partition_num_places ();\n+}\n+\n+void\n+omp_get_partition_place_nums_ (int32_t *place_nums)\n+{\n+  omp_get_partition_place_nums (place_nums);\n+}\n+\n+void\n+omp_get_partition_place_nums_8_ (int64_t *place_nums)\n+{\n+  if (gomp_places_list == NULL)\n+    return;\n+\n+  struct gomp_thread *thr = gomp_thread ();\n+  if (thr->place == 0)\n+    gomp_init_affinity ();\n+\n+  unsigned int i;\n+  for (i = 0; i < thr->ts.place_partition_len; i++)\n+    *place_nums++ = (int64_t) thr->ts.place_partition_off + i;\n+}\n+\n void\n omp_set_default_device_ (const int32_t *device_num)\n {\n@@ -493,3 +564,15 @@ omp_is_initial_device_ (void)\n {\n   return omp_is_initial_device ();\n }\n+\n+int32_t\n+omp_get_initial_device_ (void)\n+{\n+  return omp_get_initial_device ();\n+}\n+\n+int32_t\n+omp_get_max_task_priority_ (void)\n+{\n+  return omp_get_max_task_priority ();\n+}"}, {"sha": "9c8b1fb87449a89aff133c7969e4a1b155aeac89", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 143, "deletions": 14, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -36,6 +36,11 @@\n #ifndef LIBGOMP_H \n #define LIBGOMP_H 1\n \n+#ifndef _LIBGOMP_CHECKING_\n+/* Define to 1 to perform internal sanity checks.  */\n+#define _LIBGOMP_CHECKING_ 0\n+#endif\n+\n #include \"config.h\"\n #include \"gstdint.h\"\n #include \"libgomp-plugin.h\"\n@@ -78,6 +83,44 @@ enum gomp_schedule_type\n   GFS_AUTO\n };\n \n+struct gomp_doacross_work_share\n+{\n+  union {\n+    /* chunk_size copy, as ws->chunk_size is multiplied by incr for\n+       GFS_DYNAMIC.  */\n+    long chunk_size;\n+    /* Likewise, but for ull implementation.  */\n+    unsigned long long chunk_size_ull;\n+    /* For schedule(static,0) this is the number\n+       of iterations assigned to the last thread, i.e. number of\n+       iterations / number of threads.  */\n+    long q;\n+    /* Likewise, but for ull implementation.  */\n+    unsigned long long q_ull;\n+  };\n+  /* Size of each array entry (padded to cache line size).  */\n+  unsigned long elt_sz;\n+  /* Number of dimensions in sink vectors.  */\n+  unsigned int ncounts;\n+  /* True if the iterations can be flattened.  */\n+  bool flattened;\n+  /* Actual array (of elt_sz sized units), aligned to cache line size.\n+     This is indexed by team_id for GFS_STATIC and outermost iteration\n+     / chunk_size for other schedules.  */\n+  unsigned char *array;\n+  /* These two are only used for schedule(static,0).  */\n+  /* This one is number of iterations % number of threads.  */\n+  long t;\n+  union {\n+    /* And this one is cached t * (q + 1).  */\n+    long boundary;\n+    /* Likewise, but for the ull implementation.  */\n+    unsigned long long boundary_ull;\n+  };\n+  /* Array of shift counts for each dimension if they can be flattened.  */\n+  unsigned int shift_counts[];\n+};\n+\n struct gomp_work_share\n {\n   /* This member records the SCHEDULE clause to be used for this construct.\n@@ -109,13 +152,18 @@ struct gomp_work_share\n     };\n   };\n \n-  /* This is a circular queue that details which threads will be allowed\n-     into the ordered region and in which order.  When a thread allocates\n-     iterations on which it is going to work, it also registers itself at\n-     the end of the array.  When a thread reaches the ordered region, it\n-     checks to see if it is the one at the head of the queue.  If not, it\n-     blocks on its RELEASE semaphore.  */\n-  unsigned *ordered_team_ids;\n+  union {\n+    /* This is a circular queue that details which threads will be allowed\n+       into the ordered region and in which order.  When a thread allocates\n+       iterations on which it is going to work, it also registers itself at\n+       the end of the array.  When a thread reaches the ordered region, it\n+       checks to see if it is the one at the head of the queue.  If not, it\n+       blocks on its RELEASE semaphore.  */\n+    unsigned *ordered_team_ids;\n+\n+    /* This is a pointer to DOACROSS work share data.  */\n+    struct gomp_doacross_work_share *doacross;\n+  };\n \n   /* This is the number of threads that have registered themselves in\n      the circular queue ordered_team_ids.  */\n@@ -234,7 +282,7 @@ struct gomp_task_icv\n {\n   unsigned long nthreads_var;\n   enum gomp_schedule_type run_sched_var;\n-  int run_sched_modifier;\n+  int run_sched_chunk_size;\n   int default_device_var;\n   unsigned int thread_limit_var;\n   bool dyn_var;\n@@ -263,9 +311,13 @@ extern char *goacc_device_type;\n \n enum gomp_task_kind\n {\n+  /* Implicit task.  */\n   GOMP_TASK_IMPLICIT,\n-  GOMP_TASK_IFFALSE,\n+  /* Undeferred task.  */\n+  GOMP_TASK_UNDEFERRED,\n+  /* Task created by GOMP_task and waiting to be run.  */\n   GOMP_TASK_WAITING,\n+  /* Task currently executing or scheduled and about to execute.  */\n   GOMP_TASK_TIED\n };\n \n@@ -275,10 +327,13 @@ struct htab;\n \n struct gomp_task_depend_entry\n {\n+  /* Address of dependency.  */\n   void *addr;\n   struct gomp_task_depend_entry *next;\n   struct gomp_task_depend_entry *prev;\n+  /* Task that provides the dependency in ADDR.  */\n   struct gomp_task *task;\n+  /* Depend entry is of type \"IN\".  */\n   bool is_in;\n   bool redundant;\n   bool redundant_out;\n@@ -306,19 +361,35 @@ struct gomp_taskwait\n \n struct gomp_task\n {\n+  /* Parent circular list.  See children description below.  */\n   struct gomp_task *parent;\n+  /* Circular list representing the children of this task.\n+\n+     In this list we first have parent_depends_on ready to run tasks,\n+     then !parent_depends_on ready to run tasks, and finally already\n+     running tasks.  */\n   struct gomp_task *children;\n   struct gomp_task *next_child;\n   struct gomp_task *prev_child;\n+  /* Circular task_queue in `struct gomp_team'.\n+\n+     GOMP_TASK_WAITING tasks come before GOMP_TASK_TIED tasks.  */\n   struct gomp_task *next_queue;\n   struct gomp_task *prev_queue;\n+  /* Circular queue in gomp_taskgroup->children.\n+\n+     GOMP_TASK_WAITING tasks come before GOMP_TASK_TIED tasks.  */\n   struct gomp_task *next_taskgroup;\n   struct gomp_task *prev_taskgroup;\n+  /* Taskgroup this task belongs in.  */\n   struct gomp_taskgroup *taskgroup;\n+  /* Tasks that depend on this task.  */\n   struct gomp_dependers_vec *dependers;\n   struct htab *depend_hash;\n   struct gomp_taskwait *taskwait;\n+  /* Number of items in DEPEND.  */\n   size_t depend_count;\n+  /* Number of tasks in the DEPENDERS field above.  */\n   size_t num_dependees;\n   struct gomp_task_icv icv;\n   void (*fn) (void *);\n@@ -327,20 +398,41 @@ struct gomp_task\n   bool in_tied_task;\n   bool final_task;\n   bool copy_ctors_done;\n+  /* Set for undeferred tasks with unsatisfied dependencies which\n+     block further execution of their parent until the dependencies\n+     are satisfied.  */\n   bool parent_depends_on;\n+  /* Dependencies provided and/or needed for this task.  DEPEND_COUNT\n+     is the number of items available.  */\n   struct gomp_task_depend_entry depend[];\n };\n \n struct gomp_taskgroup\n {\n   struct gomp_taskgroup *prev;\n+  /* Circular list of tasks that belong in this taskgroup.\n+\n+     Tasks are chained by next/prev_taskgroup within gomp_task, and\n+     are sorted by GOMP_TASK_WAITING tasks, and then GOMP_TASK_TIED\n+     tasks.  */\n   struct gomp_task *children;\n   bool in_taskgroup_wait;\n   bool cancelled;\n   gomp_sem_t taskgroup_sem;\n   size_t num_children;\n };\n \n+struct gomp_target_task\n+{\n+  struct gomp_device_descr *devicep;\n+  void (*fn) (void *);\n+  size_t mapnum;\n+  size_t *sizes;\n+  unsigned short *kinds;\n+  unsigned int flags;\n+  void *hostaddrs[];\n+};\n+\n /* This structure describes a \"team\" of threads.  These are the threads\n    that are spawned by a PARALLEL constructs, as well as the work sharing\n    constructs that the team encounters.  */\n@@ -403,6 +495,8 @@ struct gomp_team\n   struct gomp_work_share work_shares[8];\n \n   gomp_mutex_t task_lock;\n+  /* Scheduled tasks.  Chain fields are next/prev_queue within a\n+     gomp_task.  */\n   struct gomp_task *task_queue;\n   /* Number of all GOMP_TASK_{WAITING,TIED} tasks in the team.  */\n   unsigned int task_count;\n@@ -531,6 +625,7 @@ extern bool gomp_affinity_same_place (void *, void *);\n extern bool gomp_affinity_finalize_place_list (bool);\n extern bool gomp_affinity_init_level (int, unsigned long, bool);\n extern void gomp_affinity_print_place (void *);\n+extern void gomp_get_place_proc_ids_8 (int, int64_t *);\n \n /* alloc.c */\n \n@@ -600,6 +695,9 @@ extern void gomp_ordered_next (void);\n extern void gomp_ordered_static_init (void);\n extern void gomp_ordered_static_next (void);\n extern void gomp_ordered_sync (void);\n+extern void gomp_doacross_init (unsigned, long *, long);\n+extern void gomp_doacross_ull_init (unsigned, unsigned long long *,\n+\t\t\t\t    unsigned long long);\n \n /* parallel.c */\n \n@@ -616,6 +714,11 @@ extern void gomp_init_task (struct gomp_task *, struct gomp_task *,\n \t\t\t    struct gomp_task_icv *);\n extern void gomp_end_task (void);\n extern void gomp_barrier_handle_tasks (gomp_barrier_state_t);\n+extern void gomp_task_maybe_wait_for_dependencies (void **);\n+extern void gomp_create_target_task (struct gomp_device_descr *,\n+\t\t\t\t     void (*) (void *), size_t, void **,\n+\t\t\t\t     size_t *, unsigned short *, unsigned int,\n+\t\t\t\t     void **);\n \n static void inline\n gomp_finish_task (struct gomp_task *task)\n@@ -636,11 +739,25 @@ extern void gomp_free_thread (void *);\n \n extern void gomp_init_targets_once (void);\n extern int gomp_get_num_devices (void);\n+extern void gomp_target_task_fn (void *);\n \n typedef struct splay_tree_node_s *splay_tree_node;\n typedef struct splay_tree_s *splay_tree;\n typedef struct splay_tree_key_s *splay_tree_key;\n \n+struct target_var_desc {\n+  /* Splay key.  */\n+  splay_tree_key key;\n+  /* True if data should be copied from device to host at the end.  */\n+  bool copy_from;\n+  /* True if data always should be copied from device to host at the end.  */\n+  bool always_copy_from;\n+  /* Relative offset against key host_start.  */\n+  uintptr_t offset;\n+  /* Actual length.  */\n+  uintptr_t length;\n+};\n+\n struct target_mem_desc {\n   /* Reference count.  */\n   uintptr_t refcount;\n@@ -660,11 +777,14 @@ struct target_mem_desc {\n   /* Corresponding target device descriptor.  */\n   struct gomp_device_descr *device_descr;\n \n-  /* List of splay keys to remove (or decrease refcount)\n+  /* List of target items to remove (or decrease refcount)\n      at the end of region.  */\n-  splay_tree_key list[];\n+  struct target_var_desc list[];\n };\n \n+/* Special value for refcount - infinity.  */\n+#define REFCOUNT_INFINITY (~(uintptr_t) 0)\n+\n struct splay_tree_key_s {\n   /* Address of the host object.  */\n   uintptr_t host_start;\n@@ -678,8 +798,6 @@ struct splay_tree_key_s {\n   uintptr_t refcount;\n   /* Asynchronous reference count.  */\n   uintptr_t async_refcount;\n-  /* True if data should be copied from device to host at the end.  */\n-  bool copy_from;\n };\n \n #include \"splay-tree.h\"\n@@ -757,6 +875,7 @@ struct gomp_device_descr\n   void (*free_func) (int, void *);\n   void *(*dev2host_func) (int, void *, const void *, size_t);\n   void *(*host2dev_func) (int, void *, const void *, size_t);\n+  void *(*dev2dev_func) (int, void *, const void *, size_t);\n   void (*run_func) (int, void *, void *);\n \n   /* Splay tree containing information about mapped memory regions.  */\n@@ -774,12 +893,22 @@ struct gomp_device_descr\n   acc_dispatch_t openacc;\n };\n \n+/* Kind of the pragma, for which gomp_map_vars () is called.  */\n+enum gomp_map_vars_kind\n+{\n+  GOMP_MAP_VARS_OPENACC,\n+  GOMP_MAP_VARS_TARGET,\n+  GOMP_MAP_VARS_DATA,\n+  GOMP_MAP_VARS_ENTER_DATA\n+};\n+\n extern void gomp_acc_insert_pointer (size_t, void **, size_t *, void *);\n extern void gomp_acc_remove_pointer (void *, bool, int, int);\n \n extern struct target_mem_desc *gomp_map_vars (struct gomp_device_descr *,\n \t\t\t\t\t      size_t, void **, void **,\n-\t\t\t\t\t      size_t *, void *, bool, bool);\n+\t\t\t\t\t      size_t *, void *, bool,\n+\t\t\t\t\t      enum gomp_map_vars_kind);\n extern void gomp_copy_from_async (struct target_mem_desc *);\n extern void gomp_unmap_vars (struct target_mem_desc *, bool);\n extern void gomp_init_device (struct gomp_device_descr *);"}, {"sha": "2153661ed5aa8375db8ae028a93a9e13554fa663", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -134,6 +134,36 @@ OMP_4.0 {\n \tomp_is_initial_device_;\n } OMP_3.1;\n \n+OMP_4.5 {\n+  global:\n+\tomp_get_max_task_priority;\n+\tomp_get_max_task_priority_;\n+\tomp_get_num_places;\n+\tomp_get_num_places_;\n+\tomp_get_place_num_procs;\n+\tomp_get_place_num_procs_;\n+\tomp_get_place_num_procs_8_;\n+\tomp_get_place_proc_ids;\n+\tomp_get_place_proc_ids_;\n+\tomp_get_place_proc_ids_8_;\n+\tomp_get_place_num;\n+\tomp_get_place_num_;\n+\tomp_get_partition_num_places;\n+\tomp_get_partition_num_places_;\n+\tomp_get_partition_place_nums;\n+\tomp_get_partition_place_nums_;\n+\tomp_get_partition_place_nums_8_;\n+\tomp_get_initial_device;\n+\tomp_get_initial_device_;\n+\tomp_target_alloc;\n+\tomp_target_free;\n+\tomp_target_is_present;\n+\tomp_target_memcpy;\n+\tomp_target_memcpy_rect;\n+\tomp_target_associate_ptr;\n+\tomp_target_disassociate_ptr;\n+} OMP_4.0;\n+\n GOMP_1.0 {\n   global:\n \tGOMP_atomic_end;\n@@ -234,10 +264,28 @@ GOMP_4.0.1 {\n \tGOMP_offload_unregister;\n } GOMP_4.0;\n \n-GOMP_4.0.2 {\n+GOMP_4.5 {\n   global:\n+\tGOMP_target_41;\n+\tGOMP_target_data_41;\n+\tGOMP_target_update_41;\n+\tGOMP_target_enter_exit_data;\n+\tGOMP_taskloop;\n+\tGOMP_taskloop_ull;\n \tGOMP_offload_register_ver;\n \tGOMP_offload_unregister_ver;\n+\tGOMP_loop_doacross_dynamic_start;\n+\tGOMP_loop_doacross_guided_start;\n+\tGOMP_loop_doacross_runtime_start;\n+\tGOMP_loop_doacross_static_start;\n+\tGOMP_doacross_post;\n+\tGOMP_doacross_wait;\n+\tGOMP_loop_ull_doacross_dynamic_start;\n+\tGOMP_loop_ull_doacross_guided_start;\n+\tGOMP_loop_ull_doacross_runtime_start;\n+\tGOMP_loop_ull_doacross_static_start;\n+\tGOMP_doacross_ull_post;\n+\tGOMP_doacross_ull_wait;\n } GOMP_4.0.1;\n \n OACC_2.0 {"}, {"sha": "67e6d199066f8808457b1d95f3b43109de07f12f", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -155,6 +155,7 @@ linkage, and do not throw exceptions.\n * omp_get_dynamic::             Dynamic teams setting\n * omp_get_level::               Number of parallel regions\n * omp_get_max_active_levels::   Maximum number of active regions\n+* omp_get_max_task_priority::   Maximum task priority value that can be set\n * omp_get_max_threads::         Maximum number of threads of parallel region\n * omp_get_nested::              Nested parallel regions\n * omp_get_num_devices::         Number of target devices\n@@ -388,6 +389,27 @@ This function obtains the maximum allowed number of nested, active parallel regi\n @end table\n \n \n+@node omp_get_max_task_priority\n+@section @code{omp_get_max_task_priority} -- Maximum priority value\n+that can be set for tasks.\n+@table @asis\n+@item @emph{Description}:\n+This function obtains the maximum allowed priority number for tasks.\n+\n+@item @emph{C/C++}\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int omp_get_max_task_priority(void);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{integer function omp_get_max_task_priority()}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openmp.org/, OpenMP specification v4.5}, Section 3.2.29.\n+@end table\n+\n \n @node omp_get_max_threads\n @section @code{omp_get_max_threads} -- Maximum number of threads of parallel region\n@@ -581,18 +603,18 @@ set via @env{OMP_PROC_BIND}.  Possible values are @code{omp_proc_bind_false},\n Obtain the runtime scheduling method.  The @var{kind} argument will be\n set to the value @code{omp_sched_static}, @code{omp_sched_dynamic},\n @code{omp_sched_guided} or @code{omp_sched_auto}.  The second argument,\n-@var{modifier}, is set to the chunk size.\n+@var{chunk_size}, is set to the chunk size.\n \n @item @emph{C/C++}\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{void omp_get_schedule(omp_sched_t *kind, int *modifier);}\n+@item @emph{Prototype}: @tab @code{void omp_get_schedule(omp_sched_t *kind, int *chunk_size);}\n @end multitable\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_get_schedule(kind, modifier)}\n+@item @emph{Interface}: @tab @code{subroutine omp_get_schedule(kind, chunk_size)}\n @item                   @tab @code{integer(kind=omp_sched_kind) kind}\n-@item                   @tab @code{integer modifier}\n+@item                   @tab @code{integer chunk_size}\n @end multitable\n \n @item @emph{See also}:\n@@ -929,19 +951,19 @@ Sets the runtime scheduling method.  The @var{kind} argument can have the\n value @code{omp_sched_static}, @code{omp_sched_dynamic},\n @code{omp_sched_guided} or @code{omp_sched_auto}.  Except for\n @code{omp_sched_auto}, the chunk size is set to the value of\n-@var{modifier} if positive, or to the default value if zero or negative.\n-For @code{omp_sched_auto} the @var{modifier} argument is ignored.\n+@var{chunk_size} if positive, or to the default value if zero or negative.\n+For @code{omp_sched_auto} the @var{chunk_size} argument is ignored.\n \n @item @emph{C/C++}\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{void omp_set_schedule(omp_sched_t kind, int modifier);}\n+@item @emph{Prototype}: @tab @code{void omp_set_schedule(omp_sched_t kind, int chunk_size);}\n @end multitable\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_set_schedule(kind, modifier)}\n+@item @emph{Interface}: @tab @code{subroutine omp_set_schedule(kind, chunk_size)}\n @item                   @tab @code{integer(kind=omp_sched_kind) kind}\n-@item                   @tab @code{integer modifier}\n+@item                   @tab @code{integer chunk_size}\n @end multitable\n \n @item @emph{See also}:\n@@ -1311,6 +1333,7 @@ beginning with @env{GOMP_} are GNU extensions.\n * OMP_DEFAULT_DEVICE::      Set the device used in target regions\n * OMP_DYNAMIC::             Dynamic adjustment of threads\n * OMP_MAX_ACTIVE_LEVELS::   Set the maximum number of nested parallel regions\n+* OMP_MAX_TASK_PRIORITY::   Set the maximum task priority value\n * OMP_NESTED::              Nested parallel regions\n * OMP_NUM_THREADS::         Specifies the number of threads to use\n * OMP_PROC_BIND::           Whether theads may be moved between CPUs\n@@ -1420,6 +1443,26 @@ If undefined, the number of active levels is unlimited.\n \n \n \n+@node OMP_MAX_TASK_PRIORITY\n+@section @env{OMP_MAX_TASK_PRIORITY} -- Set the maximum priority\n+number that can be set for a task.\n+@cindex Environment Variable\n+@table @asis\n+@item @emph{Description}:\n+Specifies the initial value for the maximum priority value that can be\n+set for a task.  The value of this variable shall be a non-negative\n+integer, and zero is allowed.  If undefined, the default priority is\n+0.\n+\n+@item @emph{See also}:\n+@ref{omp_get_max_task_priority}\n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specification v4.5}, Section 4.14\n+@end table\n+\n+\n+\n @node OMP_NESTED\n @section @env{OMP_NESTED} -- Nested parallel regions\n @cindex Environment Variable"}, {"sha": "c28ad2116dc40e9130fe0b2dee4654a131b9f645", "filename": "libgomp/libgomp_g.h", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Flibgomp_g.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Flibgomp_g.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp_g.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -71,6 +71,15 @@ extern bool GOMP_loop_ordered_dynamic_next (long *, long *);\n extern bool GOMP_loop_ordered_guided_next (long *, long *);\n extern bool GOMP_loop_ordered_runtime_next (long *, long *);\n \n+extern bool GOMP_loop_doacross_static_start (unsigned, long *, long, long *,\n+\t\t\t\t\t     long *);\n+extern bool GOMP_loop_doacross_dynamic_start (unsigned, long *, long, long *,\n+\t\t\t\t\t      long *);\n+extern bool GOMP_loop_doacross_guided_start (unsigned, long *, long, long *,\n+\t\t\t\t\t     long *);\n+extern bool GOMP_loop_doacross_runtime_start (unsigned, long *, long *,\n+\t\t\t\t\t      long *);\n+\n extern void GOMP_parallel_loop_static_start (void (*)(void *), void *,\n \t\t\t\t\t     unsigned, long, long, long, long);\n extern void GOMP_parallel_loop_dynamic_start (void (*)(void *), void *,\n@@ -164,10 +173,34 @@ extern bool GOMP_loop_ull_ordered_guided_next (unsigned long long *,\n extern bool GOMP_loop_ull_ordered_runtime_next (unsigned long long *,\n \t\t\t\t\t\tunsigned long long *);\n \n+extern bool GOMP_loop_ull_doacross_static_start (unsigned,\n+\t\t\t\t\t\t unsigned long long *,\n+\t\t\t\t\t\t unsigned long long,\n+\t\t\t\t\t\t unsigned long long *,\n+\t\t\t\t\t\t unsigned long long *);\n+extern bool GOMP_loop_ull_doacross_dynamic_start (unsigned,\n+\t\t\t\t\t\t  unsigned long long *,\n+\t\t\t\t\t\t  unsigned long long,\n+\t\t\t\t\t\t  unsigned long long *,\n+\t\t\t\t\t\t  unsigned long long *);\n+extern bool GOMP_loop_ull_doacross_guided_start (unsigned,\n+\t\t\t\t\t\t unsigned long long *,\n+\t\t\t\t\t\t unsigned long long,\n+\t\t\t\t\t\t unsigned long long *,\n+\t\t\t\t\t\t unsigned long long *);\n+extern bool GOMP_loop_ull_doacross_runtime_start (unsigned,\n+\t\t\t\t\t\t  unsigned long long *,\n+\t\t\t\t\t\t  unsigned long long *,\n+\t\t\t\t\t\t  unsigned long long *);\n+\n /* ordered.c */\n \n extern void GOMP_ordered_start (void);\n extern void GOMP_ordered_end (void);\n+extern void GOMP_doacross_post (long *);\n+extern void GOMP_doacross_wait (long, ...);\n+extern void GOMP_doacross_ull_post (unsigned long long *);\n+extern void GOMP_doacross_ull_wait (unsigned long long, ...);\n \n /* parallel.c */\n \n@@ -180,7 +213,15 @@ extern bool GOMP_cancellation_point (int);\n /* task.c */\n \n extern void GOMP_task (void (*) (void *), void *, void (*) (void *, void *),\n-\t\t       long, long, bool, unsigned, void **);\n+\t\t       long, long, bool, unsigned, void **, int);\n+extern void GOMP_taskloop (void (*) (void *), void *,\n+\t\t\t   void (*) (void *, void *), long, long, unsigned,\n+\t\t\t   unsigned long, int, long, long, long);\n+extern void GOMP_taskloop_ull (void (*) (void *), void *,\n+\t\t\t       void (*) (void *, void *), long, long,\n+\t\t\t       unsigned, unsigned long, int,\n+\t\t\t       unsigned long long, unsigned long long,\n+\t\t\t       unsigned long long);\n extern void GOMP_taskwait (void);\n extern void GOMP_taskyield (void);\n extern void GOMP_taskgroup_start (void);\n@@ -208,11 +249,20 @@ extern void GOMP_single_copy_end (void *);\n \n extern void GOMP_target (int, void (*) (void *), const void *,\n \t\t\t size_t, void **, size_t *, unsigned char *);\n+extern void GOMP_target_41 (int, void (*) (void *), size_t, void **, size_t *,\n+\t\t\t  unsigned short *, unsigned int, void **);\n extern void GOMP_target_data (int, const void *,\n \t\t\t      size_t, void **, size_t *, unsigned char *);\n+extern void GOMP_target_data_41 (int, size_t, void **, size_t *,\n+\t\t\t       unsigned short *);\n extern void GOMP_target_end_data (void);\n extern void GOMP_target_update (int, const void *,\n \t\t\t\tsize_t, void **, size_t *, unsigned char *);\n+extern void GOMP_target_update_41 (int, size_t, void **, size_t *,\n+\t\t\t\t   unsigned short *, unsigned int, void **);\n+extern void GOMP_target_enter_exit_data (int, size_t, void **, size_t *,\n+\t\t\t\t\t unsigned short *, unsigned int,\n+\t\t\t\t\t void **);\n extern void GOMP_teams (unsigned int, unsigned int);\n \n /* oacc-parallel.c */"}, {"sha": "812f66cd7253c4e35080d31f12aed0faac832061", "filename": "libgomp/loop.c", "status": "modified", "additions": 147, "deletions": 8, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Floop.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -169,13 +169,16 @@ GOMP_loop_runtime_start (long start, long end, long incr,\n   switch (icv->run_sched_var)\n     {\n     case GFS_STATIC:\n-      return gomp_loop_static_start (start, end, incr, icv->run_sched_modifier,\n+      return gomp_loop_static_start (start, end, incr,\n+\t\t\t\t     icv->run_sched_chunk_size,\n \t\t\t\t     istart, iend);\n     case GFS_DYNAMIC:\n-      return gomp_loop_dynamic_start (start, end, incr, icv->run_sched_modifier,\n+      return gomp_loop_dynamic_start (start, end, incr,\n+\t\t\t\t      icv->run_sched_chunk_size,\n \t\t\t\t      istart, iend);\n     case GFS_GUIDED:\n-      return gomp_loop_guided_start (start, end, incr, icv->run_sched_modifier,\n+      return gomp_loop_guided_start (start, end, incr,\n+\t\t\t\t     icv->run_sched_chunk_size,\n \t\t\t\t     istart, iend);\n     case GFS_AUTO:\n       /* For now map to schedule(static), later on we could play with feedback\n@@ -266,15 +269,15 @@ GOMP_loop_ordered_runtime_start (long start, long end, long incr,\n     {\n     case GFS_STATIC:\n       return gomp_loop_ordered_static_start (start, end, incr,\n-\t\t\t\t\t     icv->run_sched_modifier,\n+\t\t\t\t\t     icv->run_sched_chunk_size,\n \t\t\t\t\t     istart, iend);\n     case GFS_DYNAMIC:\n       return gomp_loop_ordered_dynamic_start (start, end, incr,\n-\t\t\t\t\t      icv->run_sched_modifier,\n+\t\t\t\t\t      icv->run_sched_chunk_size,\n \t\t\t\t\t      istart, iend);\n     case GFS_GUIDED:\n       return gomp_loop_ordered_guided_start (start, end, incr,\n-\t\t\t\t\t     icv->run_sched_modifier,\n+\t\t\t\t\t     icv->run_sched_chunk_size,\n \t\t\t\t\t     istart, iend);\n     case GFS_AUTO:\n       /* For now map to schedule(static), later on we could play with feedback\n@@ -286,6 +289,111 @@ GOMP_loop_ordered_runtime_start (long start, long end, long incr,\n     }\n }\n \n+/* The *_doacross_*_start routines are similar.  The only difference is that\n+   this work-share construct is initialized to expect an ORDERED(N) - DOACROSS\n+   section, and the worksharing loop iterates always from 0 to COUNTS[0] - 1\n+   and other COUNTS array elements tell the library number of iterations\n+   in the ordered inner loops.  */\n+\n+static bool\n+gomp_loop_doacross_static_start (unsigned ncounts, long *counts,\n+\t\t\t\t long chunk_size, long *istart, long *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+\n+  thr->ts.static_trip = 0;\n+  if (gomp_work_share_start (false))\n+    {\n+      gomp_loop_init (thr->ts.work_share, 0, counts[0], 1,\n+\t\t      GFS_STATIC, chunk_size);\n+      gomp_doacross_init (ncounts, counts, chunk_size);\n+      gomp_work_share_init_done ();\n+    }\n+\n+  return !gomp_iter_static_next (istart, iend);\n+}\n+\n+static bool\n+gomp_loop_doacross_dynamic_start (unsigned ncounts, long *counts,\n+\t\t\t\t  long chunk_size, long *istart, long *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  bool ret;\n+\n+  if (gomp_work_share_start (false))\n+    {\n+      gomp_loop_init (thr->ts.work_share, 0, counts[0], 1,\n+\t\t      GFS_DYNAMIC, chunk_size);\n+      gomp_doacross_init (ncounts, counts, chunk_size);\n+      gomp_work_share_init_done ();\n+    }\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+  ret = gomp_iter_dynamic_next (istart, iend);\n+#else\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n+  ret = gomp_iter_dynamic_next_locked (istart, iend);\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+#endif\n+\n+  return ret;\n+}\n+\n+static bool\n+gomp_loop_doacross_guided_start (unsigned ncounts, long *counts,\n+\t\t\t\t long chunk_size, long *istart, long *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  bool ret;\n+\n+  if (gomp_work_share_start (false))\n+    {\n+      gomp_loop_init (thr->ts.work_share, 0, counts[0], 1,\n+\t\t      GFS_GUIDED, chunk_size);\n+      gomp_doacross_init (ncounts, counts, chunk_size);\n+      gomp_work_share_init_done ();\n+    }\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+  ret = gomp_iter_guided_next (istart, iend);\n+#else\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n+  ret = gomp_iter_guided_next_locked (istart, iend);\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+#endif\n+\n+  return ret;\n+}\n+\n+bool\n+GOMP_loop_doacross_runtime_start (unsigned ncounts, long *counts,\n+\t\t\t\t  long *istart, long *iend)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  switch (icv->run_sched_var)\n+    {\n+    case GFS_STATIC:\n+      return gomp_loop_doacross_static_start (ncounts, counts,\n+\t\t\t\t\t      icv->run_sched_chunk_size,\n+\t\t\t\t\t      istart, iend);\n+    case GFS_DYNAMIC:\n+      return gomp_loop_doacross_dynamic_start (ncounts, counts,\n+\t\t\t\t\t       icv->run_sched_chunk_size,\n+\t\t\t\t\t       istart, iend);\n+    case GFS_GUIDED:\n+      return gomp_loop_doacross_guided_start (ncounts, counts,\n+\t\t\t\t\t      icv->run_sched_chunk_size,\n+\t\t\t\t\t      istart, iend);\n+    case GFS_AUTO:\n+      /* For now map to schedule(static), later on we could play with feedback\n+\t driven choice.  */\n+      return gomp_loop_doacross_static_start (ncounts, counts,\n+\t\t\t\t\t      0, istart, iend);\n+    default:\n+      abort ();\n+    }\n+}\n+\n /* The *_next routines are called when the thread completes processing of \n    the iteration block currently assigned to it.  If the work-share \n    construct is bound directly to a parallel construct, then the iteration\n@@ -484,7 +592,7 @@ GOMP_parallel_loop_runtime_start (void (*fn) (void *), void *data,\n {\n   struct gomp_task_icv *icv = gomp_icv (false);\n   gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n-\t\t\t    icv->run_sched_var, icv->run_sched_modifier, 0);\n+\t\t\t    icv->run_sched_var, icv->run_sched_chunk_size, 0);\n }\n \n ialias_redirect (GOMP_parallel_end)\n@@ -529,7 +637,7 @@ GOMP_parallel_loop_runtime (void (*fn) (void *), void *data,\n {\n   struct gomp_task_icv *icv = gomp_icv (false);\n   gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n-\t\t\t    icv->run_sched_var, icv->run_sched_modifier,\n+\t\t\t    icv->run_sched_var, icv->run_sched_chunk_size,\n \t\t\t    flags);\n   fn (data);\n   GOMP_parallel_end ();\n@@ -578,6 +686,13 @@ extern __typeof(gomp_loop_ordered_dynamic_start) GOMP_loop_ordered_dynamic_start\n extern __typeof(gomp_loop_ordered_guided_start) GOMP_loop_ordered_guided_start\n \t__attribute__((alias (\"gomp_loop_ordered_guided_start\")));\n \n+extern __typeof(gomp_loop_doacross_static_start) GOMP_loop_doacross_static_start\n+\t__attribute__((alias (\"gomp_loop_doacross_static_start\")));\n+extern __typeof(gomp_loop_doacross_dynamic_start) GOMP_loop_doacross_dynamic_start\n+\t__attribute__((alias (\"gomp_loop_doacross_dynamic_start\")));\n+extern __typeof(gomp_loop_doacross_guided_start) GOMP_loop_doacross_guided_start\n+\t__attribute__((alias (\"gomp_loop_doacross_guided_start\")));\n+\n extern __typeof(gomp_loop_static_next) GOMP_loop_static_next\n \t__attribute__((alias (\"gomp_loop_static_next\")));\n extern __typeof(gomp_loop_dynamic_next) GOMP_loop_dynamic_next\n@@ -637,6 +752,30 @@ GOMP_loop_ordered_guided_start (long start, long end, long incr,\n \t\t\t\t\t istart, iend);\n }\n \n+bool\n+GOMP_loop_doacross_static_start (unsigned ncounts, long *counts,\n+\t\t\t\t long chunk_size, long *istart, long *iend)\n+{\n+  return gomp_loop_doacross_static_start (ncounts, counts, chunk_size,\n+\t\t\t\t\t  istart, iend);\n+}\n+\n+bool\n+GOMP_loop_doacross_dynamic_start (unsigned ncounts, long *counts,\n+\t\t\t\t  long chunk_size, long *istart, long *iend)\n+{\n+  return gomp_loop_doacross_dynamic_start (ncounts, counts, chunk_size,\n+\t\t\t\t\t   istart, iend);\n+}\n+\n+bool\n+GOMP_loop_doacross_guided_start (unsigned ncounts, long *counts,\n+\t\t\t\t long chunk_size, long *istart, long *iend)\n+{\n+  return gomp_loop_doacross_guided_start (ncounts, counts, chunk_size,\n+\t\t\t\t\t  istart, iend);\n+}\n+\n bool\n GOMP_loop_static_next (long *istart, long *iend)\n {"}, {"sha": "1f2ed5460242a6f591ef5404762c212a8e66c156", "filename": "libgomp/loop_ull.c", "status": "modified", "additions": 148, "deletions": 6, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Floop_ull.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Floop_ull.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Floop_ull.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -175,15 +175,15 @@ GOMP_loop_ull_runtime_start (bool up, gomp_ull start, gomp_ull end,\n     {\n     case GFS_STATIC:\n       return gomp_loop_ull_static_start (up, start, end, incr,\n-\t\t\t\t\t icv->run_sched_modifier,\n+\t\t\t\t\t icv->run_sched_chunk_size,\n \t\t\t\t\t istart, iend);\n     case GFS_DYNAMIC:\n       return gomp_loop_ull_dynamic_start (up, start, end, incr,\n-\t\t\t\t\t  icv->run_sched_modifier,\n+\t\t\t\t\t  icv->run_sched_chunk_size,\n \t\t\t\t\t  istart, iend);\n     case GFS_GUIDED:\n       return gomp_loop_ull_guided_start (up, start, end, incr,\n-\t\t\t\t\t icv->run_sched_modifier,\n+\t\t\t\t\t icv->run_sched_chunk_size,\n \t\t\t\t\t istart, iend);\n     case GFS_AUTO:\n       /* For now map to schedule(static), later on we could play with feedback\n@@ -279,15 +279,15 @@ GOMP_loop_ull_ordered_runtime_start (bool up, gomp_ull start, gomp_ull end,\n     {\n     case GFS_STATIC:\n       return gomp_loop_ull_ordered_static_start (up, start, end, incr,\n-\t\t\t\t\t\t icv->run_sched_modifier,\n+\t\t\t\t\t\t icv->run_sched_chunk_size,\n \t\t\t\t\t\t istart, iend);\n     case GFS_DYNAMIC:\n       return gomp_loop_ull_ordered_dynamic_start (up, start, end, incr,\n-\t\t\t\t\t\t  icv->run_sched_modifier,\n+\t\t\t\t\t\t  icv->run_sched_chunk_size,\n \t\t\t\t\t\t  istart, iend);\n     case GFS_GUIDED:\n       return gomp_loop_ull_ordered_guided_start (up, start, end, incr,\n-\t\t\t\t\t\t icv->run_sched_modifier,\n+\t\t\t\t\t\t icv->run_sched_chunk_size,\n \t\t\t\t\t\t istart, iend);\n     case GFS_AUTO:\n       /* For now map to schedule(static), later on we could play with feedback\n@@ -299,6 +299,114 @@ GOMP_loop_ull_ordered_runtime_start (bool up, gomp_ull start, gomp_ull end,\n     }\n }\n \n+/* The *_doacross_*_start routines are similar.  The only difference is that\n+   this work-share construct is initialized to expect an ORDERED(N) - DOACROSS\n+   section, and the worksharing loop iterates always from 0 to COUNTS[0] - 1\n+   and other COUNTS array elements tell the library number of iterations\n+   in the ordered inner loops.  */\n+\n+static bool\n+gomp_loop_ull_doacross_static_start (unsigned ncounts, gomp_ull *counts,\n+\t\t\t\t     gomp_ull chunk_size, gomp_ull *istart,\n+\t\t\t\t     gomp_ull *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+\n+  thr->ts.static_trip = 0;\n+  if (gomp_work_share_start (false))\n+    {\n+      gomp_loop_ull_init (thr->ts.work_share, true, 0, counts[0], 1,\n+\t\t\t  GFS_STATIC, chunk_size);\n+      gomp_doacross_ull_init (ncounts, counts, chunk_size);\n+      gomp_work_share_init_done ();\n+    }\n+\n+  return !gomp_iter_ull_static_next (istart, iend);\n+}\n+\n+static bool\n+gomp_loop_ull_doacross_dynamic_start (unsigned ncounts, gomp_ull *counts,\n+\t\t\t\t      gomp_ull chunk_size, gomp_ull *istart,\n+\t\t\t\t      gomp_ull *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  bool ret;\n+\n+  if (gomp_work_share_start (false))\n+    {\n+      gomp_loop_ull_init (thr->ts.work_share, true, 0, counts[0], 1,\n+\t\t\t  GFS_DYNAMIC, chunk_size);\n+      gomp_doacross_ull_init (ncounts, counts, chunk_size);\n+      gomp_work_share_init_done ();\n+    }\n+\n+#if defined HAVE_SYNC_BUILTINS && defined __LP64__\n+  ret = gomp_iter_ull_dynamic_next (istart, iend);\n+#else\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n+  ret = gomp_iter_ull_dynamic_next_locked (istart, iend);\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+#endif\n+\n+  return ret;\n+}\n+\n+static bool\n+gomp_loop_ull_doacross_guided_start (unsigned ncounts, gomp_ull *counts,\n+\t\t\t\t     gomp_ull chunk_size, gomp_ull *istart,\n+\t\t\t\t     gomp_ull *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  bool ret;\n+\n+  if (gomp_work_share_start (false))\n+    {\n+      gomp_loop_ull_init (thr->ts.work_share, true, 0, counts[0], 1,\n+\t\t\t  GFS_GUIDED, chunk_size);\n+      gomp_doacross_ull_init (ncounts, counts, chunk_size);\n+      gomp_work_share_init_done ();\n+    }\n+\n+#if defined HAVE_SYNC_BUILTINS && defined __LP64__\n+  ret = gomp_iter_ull_guided_next (istart, iend);\n+#else\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n+  ret = gomp_iter_ull_guided_next_locked (istart, iend);\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+#endif\n+\n+  return ret;\n+}\n+\n+bool\n+GOMP_loop_ull_doacross_runtime_start (unsigned ncounts, gomp_ull *counts,\n+\t\t\t\t      gomp_ull *istart, gomp_ull *iend)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  switch (icv->run_sched_var)\n+    {\n+    case GFS_STATIC:\n+      return gomp_loop_ull_doacross_static_start (ncounts, counts,\n+\t\t\t\t\t\t  icv->run_sched_chunk_size,\n+\t\t\t\t\t\t  istart, iend);\n+    case GFS_DYNAMIC:\n+      return gomp_loop_ull_doacross_dynamic_start (ncounts, counts,\n+\t\t\t\t\t\t   icv->run_sched_chunk_size,\n+\t\t\t\t\t\t   istart, iend);\n+    case GFS_GUIDED:\n+      return gomp_loop_ull_doacross_guided_start (ncounts, counts,\n+\t\t\t\t\t\t  icv->run_sched_chunk_size,\n+\t\t\t\t\t\t  istart, iend);\n+    case GFS_AUTO:\n+      /* For now map to schedule(static), later on we could play with feedback\n+\t driven choice.  */\n+      return gomp_loop_ull_doacross_static_start (ncounts, counts,\n+\t\t\t\t\t\t  0, istart, iend);\n+    default:\n+      abort ();\n+    }\n+}\n+\n /* The *_next routines are called when the thread completes processing of\n    the iteration block currently assigned to it.  If the work-share\n    construct is bound directly to a parallel construct, then the iteration\n@@ -466,6 +574,13 @@ extern __typeof(gomp_loop_ull_ordered_dynamic_start) GOMP_loop_ull_ordered_dynam\n extern __typeof(gomp_loop_ull_ordered_guided_start) GOMP_loop_ull_ordered_guided_start\n \t__attribute__((alias (\"gomp_loop_ull_ordered_guided_start\")));\n \n+extern __typeof(gomp_loop_ull_doacross_static_start) GOMP_loop_ull_doacross_static_start\n+\t__attribute__((alias (\"gomp_loop_ull_doacross_static_start\")));\n+extern __typeof(gomp_loop_ull_doacross_dynamic_start) GOMP_loop_ull_doacross_dynamic_start\n+\t__attribute__((alias (\"gomp_loop_ull_doacross_dynamic_start\")));\n+extern __typeof(gomp_loop_ull_doacross_guided_start) GOMP_loop_ull_doacross_guided_start\n+\t__attribute__((alias (\"gomp_loop_ull_doacross_guided_start\")));\n+\n extern __typeof(gomp_loop_ull_static_next) GOMP_loop_ull_static_next\n \t__attribute__((alias (\"gomp_loop_ull_static_next\")));\n extern __typeof(gomp_loop_ull_dynamic_next) GOMP_loop_ull_dynamic_next\n@@ -534,6 +649,33 @@ GOMP_loop_ull_ordered_guided_start (bool up, gomp_ull start, gomp_ull end,\n \t\t\t\t\t     istart, iend);\n }\n \n+bool\n+GOMP_loop_ull_doacross_static_start (unsigned ncounts, gomp_ull *counts,\n+\t\t\t\t     gomp_ull chunk_size, gomp_ull *istart,\n+\t\t\t\t     gomp_ull *iend)\n+{\n+  return gomp_loop_ull_doacross_static_start (ncounts, counts, chunk_size,\n+\t\t\t\t\t      istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ull_doacross_dynamic_start (unsigned ncounts, gomp_ull *counts,\n+\t\t\t\t      gomp_ull chunk_size, gomp_ull *istart,\n+\t\t\t\t      gomp_ull *iend)\n+{\n+  return gomp_loop_ull_doacross_dynamic_start (ncounts, counts, chunk_size,\n+\t\t\t\t\t       istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ull_doacross_guided_start (unsigned ncounts, gomp_ull *counts,\n+\t\t\t\t     gomp_ull chunk_size, gomp_ull *istart,\n+\t\t\t\t     gomp_ull *iend)\n+{\n+  return gomp_loop_ull_doacross_guided_start (ncounts, counts, chunk_size,\n+\t\t\t\t\t      istart, iend);\n+}\n+\n bool\n GOMP_loop_ull_static_next (gomp_ull *istart, gomp_ull *iend)\n {"}, {"sha": "af067d6e73c09ec55226a1c86a4333bd5225f3bb", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -289,7 +289,8 @@ acc_map_data (void *h, void *d, size_t s)\n       if (d != h)\n         gomp_fatal (\"cannot map data on shared-memory system\");\n \n-      tgt = gomp_map_vars (NULL, 0, NULL, NULL, NULL, NULL, true, false);\n+      tgt = gomp_map_vars (NULL, 0, NULL, NULL, NULL, NULL, true,\n+\t\t\t   GOMP_MAP_VARS_OPENACC);\n     }\n   else\n     {\n@@ -318,7 +319,7 @@ acc_map_data (void *h, void *d, size_t s)\n       gomp_mutex_unlock (&acc_dev->lock);\n \n       tgt = gomp_map_vars (acc_dev, mapnum, &hostaddrs, &devaddrs, &sizes,\n-\t\t\t   &kinds, true, false);\n+\t\t\t   &kinds, true, GOMP_MAP_VARS_OPENACC);\n     }\n \n   gomp_mutex_lock (&acc_dev->lock);\n@@ -447,7 +448,7 @@ present_create_copy (unsigned f, void *h, size_t s)\n       gomp_mutex_unlock (&acc_dev->lock);\n \n       tgt = gomp_map_vars (acc_dev, mapnum, &hostaddrs, NULL, &s, &kinds, true,\n-\t\t\t   false);\n+\t\t\t   GOMP_MAP_VARS_OPENACC);\n \n       gomp_mutex_lock (&acc_dev->lock);\n \n@@ -594,7 +595,7 @@ gomp_acc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,\n \n   gomp_debug (0, \"  %s: prepare mappings\\n\", __FUNCTION__);\n   tgt = gomp_map_vars (acc_dev, mapnum, hostaddrs,\n-\t\t       NULL, sizes, kinds, true, false);\n+\t\t       NULL, sizes, kinds, true, GOMP_MAP_VARS_OPENACC);\n   gomp_debug (0, \"  %s: mappings prepared\\n\", __FUNCTION__);\n \n   gomp_mutex_lock (&acc_dev->lock);\n@@ -651,7 +652,7 @@ gomp_acc_remove_pointer (void *h, bool force_copyfrom, int async, int mapnum)\n     }\n \n   if (force_copyfrom)\n-    t->list[0]->copy_from = 1;\n+    t->list[0].copy_from = 1;\n \n   gomp_mutex_unlock (&acc_dev->lock);\n "}, {"sha": "b150106981e1eb69c5b2c5f9752e6369dc6da517", "filename": "libgomp/oacc-parallel.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Foacc-parallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Foacc-parallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-parallel.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -168,12 +168,12 @@ GOACC_parallel_keyed (int device, void (*fn) (void *),\n     tgt_fn = (void (*)) fn;\n \n   tgt = gomp_map_vars (acc_dev, mapnum, hostaddrs, NULL, sizes, kinds, true,\n-\t\t       false);\n+\t\t       GOMP_MAP_VARS_OPENACC);\n \n   devaddrs = gomp_alloca (sizeof (void *) * mapnum);\n   for (i = 0; i < mapnum; i++)\n-    devaddrs[i] = (void *) (tgt->list[i]->tgt->tgt_start\n-\t\t\t    + tgt->list[i]->tgt_offset);\n+    devaddrs[i] = (void *) (tgt->list[i].key->tgt->tgt_start\n+\t\t\t    + tgt->list[i].key->tgt_offset);\n \n   acc_dev->openacc.exec_func (tgt_fn, mapnum, hostaddrs, devaddrs, sizes,\n \t\t\t      kinds, async, dims, tgt);\n@@ -228,7 +228,8 @@ GOACC_data_start (int device, size_t mapnum,\n   if ((acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n       || host_fallback)\n     {\n-      tgt = gomp_map_vars (NULL, 0, NULL, NULL, NULL, NULL, true, false);\n+      tgt = gomp_map_vars (NULL, 0, NULL, NULL, NULL, NULL, true,\n+\t\t\t   GOMP_MAP_VARS_OPENACC);\n       tgt->prev = thr->mapped_data;\n       thr->mapped_data = tgt;\n \n@@ -237,7 +238,7 @@ GOACC_data_start (int device, size_t mapnum,\n \n   gomp_debug (0, \"  %s: prepare mappings\\n\", __FUNCTION__);\n   tgt = gomp_map_vars (acc_dev, mapnum, hostaddrs, NULL, sizes, kinds, true,\n-\t\t       false);\n+\t\t       GOMP_MAP_VARS_OPENACC);\n   gomp_debug (0, \"  %s: mappings prepared\\n\", __FUNCTION__);\n   tgt->prev = thr->mapped_data;\n   thr->mapped_data = tgt;"}, {"sha": "090498ad7849bea81484b896145a85f0a854515b", "filename": "libgomp/omp.h.in", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fomp.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fomp.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp.h.in?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -62,6 +62,15 @@ typedef enum omp_proc_bind_t\n   omp_proc_bind_spread = 4\n } omp_proc_bind_t;\n \n+typedef enum omp_lock_hint_t\n+{\n+  omp_lock_hint_none = 0,\n+  omp_lock_hint_uncontended = 1,\n+  omp_lock_hint_contended = 2,\n+  omp_lock_hint_nonspeculative = 4,\n+  omp_lock_hint_speculative = 8,\n+} omp_lock_hint_t;\n+\n #ifdef __cplusplus\n extern \"C\" {\n # define __GOMP_NOTHROW throw ()\n@@ -84,12 +93,16 @@ extern void omp_set_nested (int) __GOMP_NOTHROW;\n extern int omp_get_nested (void) __GOMP_NOTHROW;\n \n extern void omp_init_lock (omp_lock_t *) __GOMP_NOTHROW;\n+extern void omp_init_lock_with_hint (omp_lock_t *, omp_lock_hint_t)\n+  __GOMP_NOTHROW;\n extern void omp_destroy_lock (omp_lock_t *) __GOMP_NOTHROW;\n extern void omp_set_lock (omp_lock_t *) __GOMP_NOTHROW;\n extern void omp_unset_lock (omp_lock_t *) __GOMP_NOTHROW;\n extern int omp_test_lock (omp_lock_t *) __GOMP_NOTHROW;\n \n extern void omp_init_nest_lock (omp_nest_lock_t *) __GOMP_NOTHROW;\n+extern void omp_init_nest_lock_with_hint (omp_lock_t *, omp_lock_hint_t)\n+  __GOMP_NOTHROW;\n extern void omp_destroy_nest_lock (omp_nest_lock_t *) __GOMP_NOTHROW;\n extern void omp_set_nest_lock (omp_nest_lock_t *) __GOMP_NOTHROW;\n extern void omp_unset_nest_lock (omp_nest_lock_t *) __GOMP_NOTHROW;\n@@ -112,6 +125,12 @@ extern int omp_in_final (void) __GOMP_NOTHROW;\n \n extern int omp_get_cancellation (void) __GOMP_NOTHROW;\n extern omp_proc_bind_t omp_get_proc_bind (void) __GOMP_NOTHROW;\n+extern int omp_get_num_places (void) __GOMP_NOTHROW;\n+extern int omp_get_place_num_procs (int) __GOMP_NOTHROW;\n+extern void omp_get_place_proc_ids (int, int *) __GOMP_NOTHROW;\n+extern int omp_get_place_num (void) __GOMP_NOTHROW;\n+extern int omp_get_partition_num_places (void) __GOMP_NOTHROW;\n+extern void omp_get_partition_place_nums (int *) __GOMP_NOTHROW;\n \n extern void omp_set_default_device (int) __GOMP_NOTHROW;\n extern int omp_get_default_device (void) __GOMP_NOTHROW;\n@@ -120,6 +139,24 @@ extern int omp_get_num_teams (void) __GOMP_NOTHROW;\n extern int omp_get_team_num (void) __GOMP_NOTHROW;\n \n extern int omp_is_initial_device (void) __GOMP_NOTHROW;\n+extern int omp_get_initial_device (void) __GOMP_NOTHROW;\n+extern int omp_get_max_task_priority (void) __GOMP_NOTHROW;\n+\n+extern void *omp_target_alloc (__SIZE_TYPE__, int) __GOMP_NOTHROW;\n+extern void omp_target_free (void *, int) __GOMP_NOTHROW;\n+extern int omp_target_is_present (void *, int) __GOMP_NOTHROW;\n+extern int omp_target_memcpy (void *, void *, __SIZE_TYPE__, __SIZE_TYPE__,\n+\t\t\t      __SIZE_TYPE__, int, int) __GOMP_NOTHROW;\n+extern int omp_target_memcpy_rect (void *, void *, __SIZE_TYPE__, int,\n+\t\t\t\t   const __SIZE_TYPE__ *,\n+\t\t\t\t   const __SIZE_TYPE__ *,\n+\t\t\t\t   const __SIZE_TYPE__ *,\n+\t\t\t\t   const __SIZE_TYPE__ *,\n+\t\t\t\t   const __SIZE_TYPE__ *, int, int)\n+  __GOMP_NOTHROW;\n+extern int omp_target_associate_ptr (void *, void *, __SIZE_TYPE__,\n+\t\t\t\t     __SIZE_TYPE__, int) __GOMP_NOTHROW;\n+extern int omp_target_disassociate_ptr (void *, int) __GOMP_NOTHROW;\n \n #ifdef __cplusplus\n }"}, {"sha": "28df9c1664e94613e140a2e1a25e97bcb5dc413a", "filename": "libgomp/omp_lib.f90.in", "status": "modified", "additions": 109, "deletions": 13, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fomp_lib.f90.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fomp_lib.f90.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.f90.in?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -29,15 +29,31 @@\n         integer, parameter :: omp_nest_lock_kind = @OMP_NEST_LOCK_KIND@\n         integer, parameter :: omp_sched_kind = 4\n         integer, parameter :: omp_proc_bind_kind = 4\n+        integer, parameter :: omp_lock_hint_kind = 4\n         integer (omp_sched_kind), parameter :: omp_sched_static = 1\n         integer (omp_sched_kind), parameter :: omp_sched_dynamic = 2\n         integer (omp_sched_kind), parameter :: omp_sched_guided = 3\n         integer (omp_sched_kind), parameter :: omp_sched_auto = 4\n-        integer (omp_proc_bind_kind), parameter :: omp_proc_bind_false = 0\n-        integer (omp_proc_bind_kind), parameter :: omp_proc_bind_true = 1\n-        integer (omp_proc_bind_kind), parameter :: omp_proc_bind_master = 2\n-        integer (omp_proc_bind_kind), parameter :: omp_proc_bind_close = 3\n-        integer (omp_proc_bind_kind), parameter :: omp_proc_bind_spread = 4\n+        integer (omp_proc_bind_kind), &\n+                 parameter :: omp_proc_bind_false = 0\n+        integer (omp_proc_bind_kind), &\n+                 parameter :: omp_proc_bind_true = 1\n+        integer (omp_proc_bind_kind), &\n+                 parameter :: omp_proc_bind_master = 2\n+        integer (omp_proc_bind_kind), &\n+                 parameter :: omp_proc_bind_close = 3\n+        integer (omp_proc_bind_kind), &\n+                 parameter :: omp_proc_bind_spread = 4\n+        integer (omp_lock_hint_kind), &\n+                 parameter :: omp_lock_hint_none = 0\n+        integer (omp_lock_hint_kind), &\n+                 parameter :: omp_lock_hint_uncontended = 1\n+        integer (omp_lock_hint_kind), &\n+                 parameter :: omp_lock_hint_contended = 2\n+        integer (omp_lock_hint_kind), &\n+                 parameter :: omp_lock_hint_nonspeculative = 4\n+        integer (omp_lock_hint_kind), &\n+                 parameter :: omp_lock_hint_speculative = 8\n       end module\n \n       module omp_lib\n@@ -52,13 +68,29 @@\n           end subroutine omp_init_lock\n         end interface\n \n+        interface\n+          subroutine omp_init_lock_with_hint (svar, hint)\n+            use omp_lib_kinds\n+            integer (omp_lock_kind), intent (out) :: svar\n+            integer (omp_lock_hint_kind), intent (in) :: hint\n+          end subroutine omp_init_lock_with_hint\n+        end interface\n+\n         interface\n           subroutine omp_init_nest_lock (nvar)\n             use omp_lib_kinds\n             integer (omp_nest_lock_kind), intent (out) :: nvar\n           end subroutine omp_init_nest_lock\n         end interface\n \n+        interface\n+          subroutine omp_init_nest_lock_with_hint (nvar, hint)\n+            use omp_lib_kinds\n+            integer (omp_nest_lock_kind), intent (out) :: nvar\n+            integer (omp_lock_hint_kind), intent (in) :: hint\n+          end subroutine omp_init_nest_lock_with_hint\n+        end interface\n+\n         interface\n           subroutine omp_destroy_lock (svar)\n             use omp_lib_kinds\n@@ -199,28 +231,28 @@\n         end interface\n \n         interface omp_set_schedule\n-          subroutine omp_set_schedule (kind, modifier)\n+          subroutine omp_set_schedule (kind, chunk_size)\n             use omp_lib_kinds\n             integer (omp_sched_kind), intent (in) :: kind\n-            integer (4), intent (in) :: modifier\n+            integer (4), intent (in) :: chunk_size\n           end subroutine omp_set_schedule\n-          subroutine omp_set_schedule_8 (kind, modifier)\n+          subroutine omp_set_schedule_8 (kind, chunk_size)\n             use omp_lib_kinds\n             integer (omp_sched_kind), intent (in) :: kind\n-            integer (8), intent (in) :: modifier\n+            integer (8), intent (in) :: chunk_size\n           end subroutine omp_set_schedule_8\n          end interface\n \n         interface omp_get_schedule\n-          subroutine omp_get_schedule (kind, modifier)\n+          subroutine omp_get_schedule (kind, chunk_size)\n             use omp_lib_kinds\n             integer (omp_sched_kind), intent (out) :: kind\n-            integer (4), intent (out) :: modifier\n+            integer (4), intent (out) :: chunk_size\n           end subroutine omp_get_schedule\n-          subroutine omp_get_schedule_8 (kind, modifier)\n+          subroutine omp_get_schedule_8 (kind, chunk_size)\n             use omp_lib_kinds\n             integer (omp_sched_kind), intent (out) :: kind\n-            integer (8), intent (out) :: modifier\n+            integer (8), intent (out) :: chunk_size\n           end subroutine omp_get_schedule_8\n          end interface\n \n@@ -298,6 +330,58 @@\n           end function omp_get_proc_bind\n         end interface\n \n+        interface\n+          function omp_get_num_places ()\n+            integer (4) :: omp_get_num_places\n+          end function omp_get_num_places\n+        end interface\n+\n+        interface omp_get_place_num_procs\n+          function omp_get_place_num_procs (place_num)\n+            integer (4), intent(in) :: place_num\n+            integer (4) :: omp_get_place_num_procs\n+          end function omp_get_place_num_procs\n+\n+          function omp_get_place_num_procs_8 (place_num)\n+            integer (8), intent(in) :: place_num\n+            integer (4) :: omp_get_place_num_procs_8\n+          end function omp_get_place_num_procs_8\n+        end interface\n+\n+        interface omp_get_place_proc_ids\n+          subroutine omp_get_place_proc_ids (place_num, ids)\n+            integer (4), intent(in) :: place_num\n+            integer (4), intent(out) :: ids(*)\n+          end subroutine omp_get_place_proc_ids\n+\n+          subroutine omp_get_place_proc_ids_8 (place_num, ids)\n+            integer (8), intent(in) :: place_num\n+            integer (8), intent(out) :: ids(*)\n+          end subroutine omp_get_place_proc_ids_8\n+        end interface\n+\n+        interface\n+          function omp_get_place_num ()\n+            integer (4) :: omp_get_place_num\n+          end function omp_get_place_num\n+        end interface\n+\n+        interface\n+          function omp_get_partition_num_places ()\n+            integer (4) :: omp_get_partition_num_places\n+          end function omp_get_partition_num_places\n+        end interface\n+\n+        interface omp_get_partition_place_nums\n+          subroutine omp_get_partition_place_nums (place_nums)\n+            integer (4), intent(out) :: place_nums(*)\n+          end subroutine omp_get_partition_place_nums\n+\n+          subroutine omp_get_partition_place_nums_8 (place_nums)\n+            integer (8), intent(out) :: place_nums(*)\n+          end subroutine omp_get_partition_place_nums_8\n+        end interface\n+\n         interface omp_set_default_device\n           subroutine omp_set_default_device (device_num)\n             integer (4), intent (in) :: device_num\n@@ -337,4 +421,16 @@\n           end function omp_is_initial_device\n         end interface\n \n+        interface\n+          function omp_get_initial_device ()\n+            integer (4) :: omp_get_initial_device\n+          end function omp_get_initial_device\n+        end interface\n+\n+        interface\n+          function omp_get_max_task_priority ()\n+            integer (4) :: omp_get_max_task_priority\n+          end function omp_get_max_task_priority\n+        end interface\n+\n       end module omp_lib"}, {"sha": "816624245008d6f00fa25c40312732de5bdb9f96", "filename": "libgomp/omp_lib.h.in", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fomp_lib.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fomp_lib.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.h.in?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -46,9 +46,23 @@\n       parameter (omp_proc_bind_master = 2)\n       parameter (omp_proc_bind_close = 3)\n       parameter (omp_proc_bind_spread = 4)\n+      integer omp_lock_hint_kind\n+      parameter (omp_lock_hint_kind = 4)\n+      integer (omp_lock_hint_kind) omp_lock_hint_none\n+      integer (omp_lock_hint_kind) omp_lock_hint_uncontended\n+      integer (omp_lock_hint_kind) omp_lock_hint_contended\n+      integer (omp_lock_hint_kind) omp_lock_hint_nonspeculative\n+      integer (omp_lock_hint_kind) omp_lock_hint_speculative\n+      parameter (omp_lock_hint_none = 0)\n+      parameter (omp_lock_hint_uncontended = 1)\n+      parameter (omp_lock_hint_contended = 2)\n+      parameter (omp_lock_hint_nonspeculative = 4)\n+      parameter (omp_lock_hint_speculative = 8)\n       parameter (openmp_version = 201307)\n \n       external omp_init_lock, omp_init_nest_lock\n+      external omp_init_lock_with_hint\n+      external omp_init_nest_lock_with_hint\n       external omp_destroy_lock, omp_destroy_nest_lock\n       external omp_set_lock, omp_set_nest_lock\n       external omp_unset_lock, omp_unset_nest_lock\n@@ -88,6 +102,17 @@\n       external omp_get_proc_bind\n       integer(omp_proc_bind_kind) omp_get_proc_bind\n \n+      integer(4) omp_get_num_places\n+      external omp_get_num_places\n+      integer(4) omp_get_place_num_procs\n+      external omp_get_place_num_procs\n+      external omp_get_place_proc_ids\n+      integer(4) omp_get_place_num\n+      external omp_get_place_num\n+      integer(4) omp_get_partition_num_places\n+      external omp_get_partition_num_places\n+      external omp_get_partition_place_nums\n+\n       external omp_set_default_device, omp_get_default_device\n       external omp_get_num_devices, omp_get_num_teams\n       external omp_get_team_num\n@@ -96,3 +121,8 @@\n \n       external omp_is_initial_device\n       logical(4) omp_is_initial_device\n+      external omp_get_initial_device\n+      integer(4) omp_get_initial_device\n+\n+      external omp_get_max_task_priority\n+      integer(4) omp_get_max_task_priority"}, {"sha": "fdac3ee8f5854d677f5481ba7bc7fd6e94485736", "filename": "libgomp/ordered.c", "status": "modified", "additions": 521, "deletions": 0, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fordered.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Fordered.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fordered.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0", "patch": "@@ -26,6 +26,9 @@\n /* This file handles the ORDERED construct.  */\n \n #include \"libgomp.h\"\n+#include <stdarg.h>\n+#include <string.h>\n+#include \"doacross.h\"\n \n \n /* This function is called when first allocating an iteration block.  That\n@@ -250,3 +253,521 @@ void\n GOMP_ordered_end (void)\n {\n }\n+\n+/* DOACROSS initialization.  */\n+\n+#define MAX_COLLAPSED_BITS (__SIZEOF_LONG__ * __CHAR_BIT__)\n+\n+void\n+gomp_doacross_init (unsigned ncounts, long *counts, long chunk_size)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_team *team = thr->ts.team;\n+  struct gomp_work_share *ws = thr->ts.work_share;\n+  unsigned int i, bits[MAX_COLLAPSED_BITS], num_bits = 0;\n+  unsigned long ent, num_ents, elt_sz, shift_sz;\n+  struct gomp_doacross_work_share *doacross;\n+\n+  if (team == NULL || team->nthreads == 1)\n+    return;\n+\n+  for (i = 0; i < ncounts; i++)\n+    {\n+      /* If any count is 0, GOMP_doacross_{post,wait} can't be called.  */\n+      if (counts[i] == 0)\n+\treturn;\n+\n+      if (num_bits <= MAX_COLLAPSED_BITS)\n+\t{\n+\t  unsigned int this_bits;\n+\t  if (counts[i] == 1)\n+\t    this_bits = 1;\n+\t  else\n+\t    this_bits = __SIZEOF_LONG__ * __CHAR_BIT__\n+\t\t\t- __builtin_clzl (counts[i] - 1);\n+\t  if (num_bits + this_bits <= MAX_COLLAPSED_BITS)\n+\t    {\n+\t      bits[i] = this_bits;\n+\t      num_bits += this_bits;\n+\t    }\n+\t  else\n+\t    num_bits = MAX_COLLAPSED_BITS + 1;\n+\t}\n+    }\n+\n+  if (ws->sched == GFS_STATIC)\n+    num_ents = team->nthreads;\n+  else\n+    num_ents = (counts[0] - 1) / chunk_size + 1;\n+  if (num_bits <= MAX_COLLAPSED_BITS)\n+    {\n+      elt_sz = sizeof (unsigned long);\n+      shift_sz = ncounts * sizeof (unsigned int);\n+    }\n+  else\n+    {\n+      elt_sz = sizeof (unsigned long) * ncounts;\n+      shift_sz = 0;\n+    }\n+  elt_sz = (elt_sz + 63) & ~63UL;\n+\n+  doacross = gomp_malloc (sizeof (*doacross) + 63 + num_ents * elt_sz\n+\t\t\t  + shift_sz);\n+  doacross->chunk_size = chunk_size;\n+  doacross->elt_sz = elt_sz;\n+  doacross->ncounts = ncounts;\n+  doacross->flattened = false;\n+  doacross->array = (unsigned char *)\n+\t\t    ((((uintptr_t) (doacross + 1)) + 63 + shift_sz)\n+\t\t     & ~(uintptr_t) 63);\n+  if (num_bits <= MAX_COLLAPSED_BITS)\n+    {\n+      unsigned int shift_count = 0;\n+      doacross->flattened = true;\n+      for (i = ncounts; i > 0; i--)\n+\t{\n+\t  doacross->shift_counts[i - 1] = shift_count;\n+\t  shift_count += bits[i - 1];\n+\t}\n+      for (ent = 0; ent < num_ents; ent++)\n+\t*(unsigned long *) (doacross->array + ent * elt_sz) = 0;\n+    }\n+  else\n+    for (ent = 0; ent < num_ents; ent++)\n+      memset (doacross->array + ent * elt_sz, '\\0',\n+\t      sizeof (unsigned long) * ncounts);\n+  if (ws->sched == GFS_STATIC && chunk_size == 0)\n+    {\n+      unsigned long q = counts[0] / num_ents;\n+      unsigned long t = counts[0] % num_ents;\n+      doacross->boundary = t * (q + 1);\n+      doacross->q = q;\n+      doacross->t = t;\n+    }\n+  ws->doacross = doacross;\n+}\n+\n+/* DOACROSS POST operation.  */\n+\n+void\n+GOMP_doacross_post (long *counts)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_work_share *ws = thr->ts.work_share;\n+  struct gomp_doacross_work_share *doacross = ws->doacross;\n+  unsigned long ent;\n+  unsigned int i;\n+\n+  if (__builtin_expect (doacross == NULL, 0))\n+    {\n+      __sync_synchronize ();\n+      return;\n+    }\n+\n+  if (__builtin_expect (ws->sched == GFS_STATIC, 1))\n+    ent = thr->ts.team_id;\n+  else\n+    ent = counts[0] / doacross->chunk_size;\n+  unsigned long *array = (unsigned long *) (doacross->array\n+\t\t\t\t\t    + ent * doacross->elt_sz);\n+\n+  if (__builtin_expect (doacross->flattened, 1))\n+    {\n+      unsigned long flattened\n+\t= (unsigned long) counts[0] << doacross->shift_counts[0];\n+\n+      for (i = 1; i < doacross->ncounts; i++)\n+\tflattened |= (unsigned long) counts[i]\n+\t\t     << doacross->shift_counts[i];\n+      flattened++;\n+      if (flattened == __atomic_load_n (array, MEMMODEL_ACQUIRE))\n+\t__atomic_thread_fence (MEMMODEL_RELEASE);\n+      else\n+\t__atomic_store_n (array, flattened, MEMMODEL_RELEASE);\n+      return;\n+    }\n+\n+  __atomic_thread_fence (MEMMODEL_ACQUIRE);\n+  for (i = doacross->ncounts; i-- > 0; )\n+    {\n+      if (counts[i] + 1UL != __atomic_load_n (&array[i], MEMMODEL_RELAXED))\n+\t__atomic_store_n (&array[i], counts[i] + 1UL, MEMMODEL_RELEASE);\n+    }\n+}\n+\n+/* DOACROSS WAIT operation.  */\n+\n+void\n+GOMP_doacross_wait (long first, ...)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_work_share *ws = thr->ts.work_share;\n+  struct gomp_doacross_work_share *doacross = ws->doacross;\n+  va_list ap;\n+  unsigned long ent;\n+  unsigned int i;\n+\n+  if (__builtin_expect (doacross == NULL, 0))\n+    {\n+      __sync_synchronize ();\n+      return;\n+    }\n+\n+  if (__builtin_expect (ws->sched == GFS_STATIC, 1))\n+    {\n+      if (ws->chunk_size == 0)\n+\t{\n+\t  if (first < doacross->boundary)\n+\t    ent = first / (doacross->q + 1);\n+\t  else\n+\t    ent = (first - doacross->boundary) / doacross->q\n+\t\t  + doacross->t;\n+\t}\n+      else\n+\tent = first / ws->chunk_size % thr->ts.team->nthreads;\n+    }\n+  else\n+    ent = first / doacross->chunk_size;\n+  unsigned long *array = (unsigned long *) (doacross->array\n+\t\t\t\t\t    + ent * doacross->elt_sz);\n+\n+  if (__builtin_expect (doacross->flattened, 1))\n+    {\n+      unsigned long flattened\n+\t= (unsigned long) first << doacross->shift_counts[0];\n+      unsigned long cur;\n+\n+      va_start (ap, first);\n+      for (i = 1; i < doacross->ncounts; i++)\n+\tflattened |= (unsigned long) va_arg (ap, long)\n+\t\t     << doacross->shift_counts[i];\n+      cur = __atomic_load_n (array, MEMMODEL_ACQUIRE);\n+      if (flattened < cur)\n+\t{\n+\t  __atomic_thread_fence (MEMMODEL_RELEASE);\n+\t  va_end (ap);\n+\t  return;\n+\t}\n+      doacross_spin (array, flattened, cur);\n+      __atomic_thread_fence (MEMMODEL_RELEASE);\n+      va_end (ap);\n+      return;\n+    }\n+\n+  do\n+    {\n+      va_start (ap, first);\n+      for (i = 0; i < doacross->ncounts; i++)\n+\t{\n+\t  unsigned long thisv\n+\t    = (unsigned long) (i ? va_arg (ap, long) : first) + 1;\n+\t  unsigned long cur = __atomic_load_n (&array[i], MEMMODEL_RELAXED);\n+\t  if (thisv < cur)\n+\t    {\n+\t      i = doacross->ncounts;\n+\t      break;\n+\t    }\n+\t  if (thisv > cur)\n+\t    break;\n+\t}\n+      va_end (ap);\n+      if (i == doacross->ncounts)\n+\tbreak;\n+      cpu_relax ();\n+    }\n+  while (1);\n+  __sync_synchronize ();\n+}\n+\n+typedef unsigned long long gomp_ull;\n+\n+void\n+gomp_doacross_ull_init (unsigned ncounts, gomp_ull *counts, gomp_ull chunk_size)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_team *team = thr->ts.team;\n+  struct gomp_work_share *ws = thr->ts.work_share;\n+  unsigned int i, bits[MAX_COLLAPSED_BITS], num_bits = 0;\n+  unsigned long ent, num_ents, elt_sz, shift_sz;\n+  struct gomp_doacross_work_share *doacross;\n+\n+  if (team == NULL || team->nthreads == 1)\n+    return;\n+\n+  for (i = 0; i < ncounts; i++)\n+    {\n+      /* If any count is 0, GOMP_doacross_{post,wait} can't be called.  */\n+      if (counts[i] == 0)\n+\treturn;\n+\n+      if (num_bits <= MAX_COLLAPSED_BITS)\n+\t{\n+\t  unsigned int this_bits;\n+\t  if (counts[i] == 1)\n+\t    this_bits = 1;\n+\t  else\n+\t    this_bits = __SIZEOF_LONG_LONG__ * __CHAR_BIT__\n+\t\t\t- __builtin_clzll (counts[i] - 1);\n+\t  if (num_bits + this_bits <= MAX_COLLAPSED_BITS)\n+\t    {\n+\t      bits[i] = this_bits;\n+\t      num_bits += this_bits;\n+\t    }\n+\t  else\n+\t    num_bits = MAX_COLLAPSED_BITS + 1;\n+\t}\n+    }\n+\n+  if (ws->sched == GFS_STATIC)\n+    num_ents = team->nthreads;\n+  else\n+    num_ents = (counts[0] - 1) / chunk_size + 1;\n+  if (num_bits <= MAX_COLLAPSED_BITS)\n+    {\n+      elt_sz = sizeof (unsigned long);\n+      shift_sz = ncounts * sizeof (unsigned int);\n+    }\n+  else\n+    {\n+      if (sizeof (gomp_ull) == sizeof (unsigned long))\n+\telt_sz = sizeof (gomp_ull) * ncounts;\n+      else if (sizeof (gomp_ull) == 2 * sizeof (unsigned long))\n+\telt_sz = sizeof (unsigned long) * 2 * ncounts;\n+      else\n+\tabort ();\n+      shift_sz = 0;\n+    }\n+  elt_sz = (elt_sz + 63) & ~63UL;\n+\n+  doacross = gomp_malloc (sizeof (*doacross) + 63 + num_ents * elt_sz\n+\t\t\t  + shift_sz);\n+  doacross->chunk_size_ull = chunk_size;\n+  doacross->elt_sz = elt_sz;\n+  doacross->ncounts = ncounts;\n+  doacross->flattened = false;\n+  doacross->boundary = 0;\n+  doacross->array = (unsigned char *)\n+\t\t    ((((uintptr_t) (doacross + 1)) + 63 + shift_sz)\n+\t\t     & ~(uintptr_t) 63);\n+  if (num_bits <= MAX_COLLAPSED_BITS)\n+    {\n+      unsigned int shift_count = 0;\n+      doacross->flattened = true;\n+      for (i = ncounts; i > 0; i--)\n+\t{\n+\t  doacross->shift_counts[i - 1] = shift_count;\n+\t  shift_count += bits[i - 1];\n+\t}\n+      for (ent = 0; ent < num_ents; ent++)\n+\t*(unsigned long *) (doacross->array + ent * elt_sz) = 0;\n+    }\n+  else\n+    for (ent = 0; ent < num_ents; ent++)\n+      memset (doacross->array + ent * elt_sz, '\\0',\n+\t      sizeof (unsigned long) * ncounts);\n+  if (ws->sched == GFS_STATIC && chunk_size == 0)\n+    {\n+      gomp_ull q = counts[0] / num_ents;\n+      gomp_ull t = counts[0] % num_ents;\n+      doacross->boundary_ull = t * (q + 1);\n+      doacross->q_ull = q;\n+      doacross->t = t;\n+    }\n+  ws->doacross = doacross;\n+}\n+\n+/* DOACROSS POST operation.  */\n+\n+void\n+GOMP_doacross_ull_post (gomp_ull *counts)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_work_share *ws = thr->ts.work_share;\n+  struct gomp_doacross_work_share *doacross = ws->doacross;\n+  unsigned long ent;\n+  unsigned int i;\n+\n+  if (__builtin_expect (doacross == NULL, 0))\n+    {\n+      __sync_synchronize ();\n+      return;\n+    }\n+\n+  if (__builtin_expect (ws->sched == GFS_STATIC, 1))\n+    ent = thr->ts.team_id;\n+  else\n+    ent = counts[0] / doacross->chunk_size_ull;\n+\n+  if (__builtin_expect (doacross->flattened, 1))\n+    {\n+      unsigned long *array = (unsigned long *) (doacross->array\n+\t\t\t      + ent * doacross->elt_sz);\n+      gomp_ull flattened\n+\t= counts[0] << doacross->shift_counts[0];\n+\n+      for (i = 1; i < doacross->ncounts; i++)\n+\tflattened |= counts[i] << doacross->shift_counts[i];\n+      flattened++;\n+      if (flattened == __atomic_load_n (array, MEMMODEL_ACQUIRE))\n+\t__atomic_thread_fence (MEMMODEL_RELEASE);\n+      else\n+\t__atomic_store_n (array, flattened, MEMMODEL_RELEASE);\n+      return;\n+    }\n+\n+  __atomic_thread_fence (MEMMODEL_ACQUIRE);\n+  if (sizeof (gomp_ull) == sizeof (unsigned long))\n+    {\n+      gomp_ull *array = (gomp_ull *) (doacross->array\n+\t\t\t\t      + ent * doacross->elt_sz);\n+\n+      for (i = doacross->ncounts; i-- > 0; )\n+\t{\n+\t  if (counts[i] + 1UL != __atomic_load_n (&array[i], MEMMODEL_RELAXED))\n+\t    __atomic_store_n (&array[i], counts[i] + 1UL, MEMMODEL_RELEASE);\n+\t}\n+    }\n+  else\n+    {\n+      unsigned long *array = (unsigned long *) (doacross->array\n+\t\t\t\t\t\t+ ent * doacross->elt_sz);\n+\n+      for (i = doacross->ncounts; i-- > 0; )\n+\t{\n+\t  gomp_ull cull = counts[i] + 1UL;\n+\t  unsigned long c = (unsigned long) cull;\n+\t  if (c != __atomic_load_n (&array[2 * i + 1], MEMMODEL_RELAXED))\n+\t    __atomic_store_n (&array[2 * i + 1], c, MEMMODEL_RELEASE);\n+\t  c = cull >> (__SIZEOF_LONG_LONG__ * __CHAR_BIT__ / 2);\n+\t  if (c != __atomic_load_n (&array[2 * i], MEMMODEL_RELAXED))\n+\t    __atomic_store_n (&array[2 * i], c, MEMMODEL_RELEASE);\n+\t}\n+    }\n+}\n+\n+/* DOACROSS WAIT operation.  */\n+\n+void\n+GOMP_doacross_ull_wait (gomp_ull first, ...)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_work_share *ws = thr->ts.work_share;\n+  struct gomp_doacross_work_share *doacross = ws->doacross;\n+  va_list ap;\n+  unsigned long ent;\n+  unsigned int i;\n+\n+  if (__builtin_expect (doacross == NULL, 0))\n+    {\n+      __sync_synchronize ();\n+      return;\n+    }\n+\n+  if (__builtin_expect (ws->sched == GFS_STATIC, 1))\n+    {\n+      if (ws->chunk_size_ull == 0)\n+\t{\n+\t  if (first < doacross->boundary_ull)\n+\t    ent = first / (doacross->q_ull + 1);\n+\t  else\n+\t    ent = (first - doacross->boundary_ull) / doacross->q_ull\n+\t\t  + doacross->t;\n+\t}\n+      else\n+\tent = first / ws->chunk_size_ull % thr->ts.team->nthreads;\n+    }\n+  else\n+    ent = first / doacross->chunk_size_ull;\n+\n+  if (__builtin_expect (doacross->flattened, 1))\n+    {\n+      unsigned long *array = (unsigned long *) (doacross->array\n+\t\t\t\t\t\t+ ent * doacross->elt_sz);\n+      gomp_ull flattened = first << doacross->shift_counts[0];\n+      unsigned long cur;\n+\n+      va_start (ap, first);\n+      for (i = 1; i < doacross->ncounts; i++)\n+\tflattened |= va_arg (ap, gomp_ull)\n+\t\t     << doacross->shift_counts[i];\n+      cur = __atomic_load_n (array, MEMMODEL_ACQUIRE);\n+      if (flattened < cur)\n+\t{\n+\t  __atomic_thread_fence (MEMMODEL_RELEASE);\n+\t  va_end (ap);\n+\t  return;\n+\t}\n+      doacross_spin (array, flattened, cur);\n+      __atomic_thread_fence (MEMMODEL_RELEASE);\n+      va_end (ap);\n+      return;\n+    }\n+\n+  if (sizeof (gomp_ull) == sizeof (unsigned long))\n+    {\n+      gomp_ull *array = (gomp_ull *) (doacross->array\n+\t\t\t\t      + ent * doacross->elt_sz);\n+      do\n+\t{\n+\t  va_start (ap, first);\n+\t  for (i = 0; i < doacross->ncounts; i++)\n+\t    {\n+\t      gomp_ull thisv\n+\t\t= (i ? va_arg (ap, gomp_ull) : first) + 1;\n+\t      gomp_ull cur = __atomic_load_n (&array[i], MEMMODEL_RELAXED);\n+\t      if (thisv < cur)\n+\t\t{\n+\t\t  i = doacross->ncounts;\n+\t\t  break;\n+\t\t}\n+\t      if (thisv > cur)\n+\t\tbreak;\n+\t    }\n+\t  va_end (ap);\n+\t  if (i == doacross->ncounts)\n+\t    break;\n+\t  cpu_relax ();\n+\t}\n+      while (1);\n+    }\n+  else\n+    {\n+      unsigned long *array = (unsigned long *) (doacross->array\n+\t\t\t\t\t\t+ ent * doacross->elt_sz);\n+      do\n+\t{\n+\t  va_start (ap, first);\n+\t  for (i = 0; i < doacross->ncounts; i++)\n+\t    {\n+\t      gomp_ull thisv\n+\t\t= (i ? va_arg (ap, gomp_ull) : first) + 1;\n+\t      unsigned long t\n+\t\t= thisv >> (__SIZEOF_LONG_LONG__ * __CHAR_BIT__ / 2);\n+\t      unsigned long cur\n+\t\t= __atomic_load_n (&array[2 * i], MEMMODEL_RELAXED);\n+\t      if (t < cur)\n+\t\t{\n+\t\t  i = doacross->ncounts;\n+\t\t  break;\n+\t\t}\n+\t      if (t > cur)\n+\t\tbreak;\n+\t      t = thisv;\n+\t      cur = __atomic_load_n (&array[2 * i + 1], MEMMODEL_RELAXED);\n+\t      if (t < cur)\n+\t\t{\n+\t\t  i = doacross->ncounts;\n+\t\t  break;\n+\t\t}\n+\t      if (t > cur)\n+\t\tbreak;\n+\t    }\n+\t  va_end (ap);\n+\t  if (i == doacross->ncounts)\n+\t    break;\n+\t  cpu_relax ();\n+\t}\n+      while (1);\n+    }\n+  __sync_synchronize ();\n+}"}, {"sha": "de6a2c9c9c5d7a60529e3e9037079eee1075d08b", "filename": "libgomp/target.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "1246c6ae3187fbeabd21a21bce634cbeef3a7d09", "filename": "libgomp/task.c", "status": "modified", "additions": 533, "deletions": 148, "changes": 681, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftask.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "f57a5a16ef22f6ec04af19e52cc6b6cacd7ed463", "filename": "libgomp/taskloop.c", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftaskloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftaskloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftaskloop.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "6dc1e8ef3ca64dee857beac69a36c1c931397ff8", "filename": "libgomp/testsuite/lib/libgomp.exp", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "8c7a09f315d9c1ef9ac165eed08242e87a66b69c", "filename": "libgomp/testsuite/libgomp.c++/ctor-13.C", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-13.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "bc53ee6e8a2b7702aa7c35b74af59fb52ac06f82", "filename": "libgomp/testsuite/libgomp.c++/doacross-1.C", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fdoacross-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fdoacross-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fdoacross-1.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "6d5b5e47990417e7fdeb60420110b028c9592ebb", "filename": "libgomp/testsuite/libgomp.c++/examples-4/declare_target-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fexamples-4%2Fdeclare_target-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fexamples-4%2Fdeclare_target-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fexamples-4%2Fdeclare_target-2.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "ea32192e45d8d94bb3263d61a14b5988a40ea9f3", "filename": "libgomp/testsuite/libgomp.c++/for-12.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-12.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "ac1601a766fc82ef3e8b503483db70a6ee3f1f89", "filename": "libgomp/testsuite/libgomp.c++/for-13.C", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-13.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "7738473b6011fcd1a5fea0d23ff3930f2151e5a6", "filename": "libgomp/testsuite/libgomp.c++/for-14.C", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-14.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "1dd1ffc89398b50e1303b20b2b9abf8b9faed6d0", "filename": "libgomp/testsuite/libgomp.c++/linear-1.C", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Flinear-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Flinear-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Flinear-1.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "d2d0c5b26674ffa34d3c160ad09f4bc6e1d3c206", "filename": "libgomp/testsuite/libgomp.c++/member-1.C", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-1.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "bb348d8a82231a284cb4d840109728101baa74ef", "filename": "libgomp/testsuite/libgomp.c++/member-2.C", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-2.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "50bd587d86bb4aef1b319019618eb90ab40dfa56", "filename": "libgomp/testsuite/libgomp.c++/member-3.C", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-3.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "f76695de6fb9a2a3a7193ff7783f368d005f4779", "filename": "libgomp/testsuite/libgomp.c++/member-4.C", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-4.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "d6fec7a841a700faf1f5abece1478453e2832777", "filename": "libgomp/testsuite/libgomp.c++/member-5.C", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-5.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "a1bedd808ac8664a72c382f18211ddced034df85", "filename": "libgomp/testsuite/libgomp.c++/ordered-1.C", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fordered-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fordered-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fordered-1.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "2254430f168c60b4636103db4d853710c75e12c3", "filename": "libgomp/testsuite/libgomp.c++/reduction-10.C", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-10.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "212fd69be58e78aea01d2945984edb3bc47bc84d", "filename": "libgomp/testsuite/libgomp.c++/reduction-5.C", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-5.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "f180ca35edde25391c5efc418fe014d10e7d36e4", "filename": "libgomp/testsuite/libgomp.c++/reduction-6.C", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-6.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "75f9d08aac4b0396a750e11c2bc69c3a62b99a7c", "filename": "libgomp/testsuite/libgomp.c++/reduction-7.C", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-7.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "cffd7cc2d4c9ec7b334ecab97aa63fbc896a5f4a", "filename": "libgomp/testsuite/libgomp.c++/reduction-8.C", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-8.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "117a8f66c527e7d282035561e0244eadb62d3d05", "filename": "libgomp/testsuite/libgomp.c++/reduction-9.C", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-9.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "f2a78614a138c3c98a8961f6f2c2845f1b144a87", "filename": "libgomp/testsuite/libgomp.c++/reference-1.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freference-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freference-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freference-1.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "dc18cb619acc978ee7e244fa7be0f71374e120d8", "filename": "libgomp/testsuite/libgomp.c++/simd14.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd14.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "860773eed15fd6f6f97520aa19b7702a528854aa", "filename": "libgomp/testsuite/libgomp.c++/target-10.C", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-10.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "fe99603351da5464cd8dbf0812cddc11dca9874f", "filename": "libgomp/testsuite/libgomp.c++/target-11.C", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-11.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "3b4ed57df6885cc203189b56298d48e29365bfb9", "filename": "libgomp/testsuite/libgomp.c++/target-12.C", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-12.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "1eab7f29b4a799804206f798df4c47b47ddc0f41", "filename": "libgomp/testsuite/libgomp.c++/target-2.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-2.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "6639be394c6cdc32b158f29d71551708b2634214", "filename": "libgomp/testsuite/libgomp.c++/target-5.C", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-5.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "8dbafb0437bd4cab64c2235cf5c6e6b343dde1ce", "filename": "libgomp/testsuite/libgomp.c++/target-6.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-6.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "e13c50f26dae14f2aa5463a44ae5c979b09c4ef5", "filename": "libgomp/testsuite/libgomp.c++/target-7.C", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-7.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "d886b476754eecf6c3ce7b7973aa5cfe7aeb2b5b", "filename": "libgomp/testsuite/libgomp.c++/target-8.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-8.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "a5d171b0b3d897375fcaefe272739e7f26e7bef5", "filename": "libgomp/testsuite/libgomp.c++/target-9.C", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-9.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "66f8e0b1d7c95f5f32d8ec3aae3bd5ac34e6ea5c", "filename": "libgomp/testsuite/libgomp.c++/taskloop-1.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-1.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "67a0e92717ed3e7b2d52030c7873a42b7627c733", "filename": "libgomp/testsuite/libgomp.c++/taskloop-2.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-2.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "bfd793c1c58602678000f0724e62716712a4bf8e", "filename": "libgomp/testsuite/libgomp.c++/taskloop-3.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-3.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "937cfcc00290931f32e94169d0cd1f6558b3b007", "filename": "libgomp/testsuite/libgomp.c++/taskloop-4.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-4.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "eb464467b669a8d5e32a433073a112bae6e63c76", "filename": "libgomp/testsuite/libgomp.c++/taskloop-5.C", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-5.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "edf7f7a371bf24df8138e010b3f37e6f7a06fb71", "filename": "libgomp/testsuite/libgomp.c++/taskloop-6.C", "status": "added", "additions": 442, "deletions": 0, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-6.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "b9a3c81e381fcf0467ea403c3284c53ac16d6dcd", "filename": "libgomp/testsuite/libgomp.c++/taskloop-7.C", "status": "added", "additions": 400, "deletions": 0, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-7.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "d164907d1d6e8ad8b9cfda274fa7483693335341", "filename": "libgomp/testsuite/libgomp.c++/taskloop-8.C", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-8.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "65abc31ff8d06be5576f4161b3fb266bd86c1eb3", "filename": "libgomp/testsuite/libgomp.c++/taskloop-9.C", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-9.C?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "f821657470473004056523fdb1eef41383e8d26c", "filename": "libgomp/testsuite/libgomp.c/affinity-2.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Faffinity-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Faffinity-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Faffinity-2.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "0794c80ec2e99631e95757174a1664412170c978", "filename": "libgomp/testsuite/libgomp.c/doacross-1.c", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "e491bb22965164200c5a755f0c5eb48ad51d5771", "filename": "libgomp/testsuite/libgomp.c/doacross-2.c", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-2.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "6d4bc4fac12bf61f495a8555b14847cbd656ca4e", "filename": "libgomp/testsuite/libgomp.c/examples-4/declare_target-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fdeclare_target-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fdeclare_target-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fdeclare_target-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "f24143669517578d706602473c07e88753687ee9", "filename": "libgomp/testsuite/libgomp.c/examples-4/declare_target-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fdeclare_target-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fdeclare_target-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fdeclare_target-4.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "33d6137afd52bba39fc18b8073ea5570a16b8ac8", "filename": "libgomp/testsuite/libgomp.c/examples-4/declare_target-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fdeclare_target-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fdeclare_target-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fdeclare_target-5.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "dad8572f8f016dd4524cbbde2ddd6ebf87651f86", "filename": "libgomp/testsuite/libgomp.c/examples-4/device-1.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fdevice-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fdevice-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fdevice-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "af0865332785b1f7f8d459ef1096269516905548", "filename": "libgomp/testsuite/libgomp.c/examples-4/device-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fdevice-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fdevice-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fdevice-3.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "46b674013d0eb8e9dbfc4c3c1d05890388abafa2", "filename": "libgomp/testsuite/libgomp.c/examples-4/target_data-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Ftarget_data-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Ftarget_data-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Ftarget_data-3.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "7d0a60ebb5146c6770790670e1b37b04b031cf11", "filename": "libgomp/testsuite/libgomp.c/examples-4/teams-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fteams-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fteams-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fteams-2.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "5fe63a68a4b31e1488da3a64955e4fb2da7613a3", "filename": "libgomp/testsuite/libgomp.c/examples-4/teams-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fteams-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fteams-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fteams-3.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "6136eabef66aeb4bee1ab1814963eddac81a003e", "filename": "libgomp/testsuite/libgomp.c/examples-4/teams-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fteams-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fteams-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fteams-4.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "0bd116c5aec1a488b1a0cfaf7d8f8b66e5d14ab2", "filename": "libgomp/testsuite/libgomp.c/for-2.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-2.h?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "ef5465e1e769d3116f62e3434663a836e177f275", "filename": "libgomp/testsuite/libgomp.c/for-4.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-4.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "84e636ab0f98e48b447d8a4b3c123ec19a28d642", "filename": "libgomp/testsuite/libgomp.c/for-5.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-5.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "7f3c65e82b13f01334b2187789a30cabde92d699", "filename": "libgomp/testsuite/libgomp.c/for-6.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-6.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "f86fb33c5da657d382dbe0d7c69838c5f463ad7b", "filename": "libgomp/testsuite/libgomp.c/linear-1.c", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Flinear-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Flinear-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Flinear-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "8412d4715c31aaac0d19b8f3361848b4f61e6a1c", "filename": "libgomp/testsuite/libgomp.c/ordered-4.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fordered-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fordered-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fordered-4.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "2fc9eec529a09753b6057048edd29513361bfa1f", "filename": "libgomp/testsuite/libgomp.c/pr66199-2.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-2.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "fe0ccb47197f1467f1116a08807eb60029cb521e", "filename": "libgomp/testsuite/libgomp.c/pr66199-3.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-3.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "a9b1bb8a59e992130f73a7a99232d6a370f9d392", "filename": "libgomp/testsuite/libgomp.c/pr66199-4.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-4.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "3c95ebd4a4bb53a984fa895a8caef9b346b255a0", "filename": "libgomp/testsuite/libgomp.c/reduction-10.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-10.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "347c26f46d390cf77db880b69d9141ee085c4da0", "filename": "libgomp/testsuite/libgomp.c/reduction-7.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-7.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "f4ec03aabea475802c73c69152269f21b0d39d39", "filename": "libgomp/testsuite/libgomp.c/reduction-8.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-8.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "13605c1ab8882229147459459a79129580d698ae", "filename": "libgomp/testsuite/libgomp.c/reduction-9.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-9.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "c7abb008182ae99cff929741e77711721df3fc60", "filename": "libgomp/testsuite/libgomp.c/target-1.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "625c2863f4b2476f869bc5234946ec686add0ddc", "filename": "libgomp/testsuite/libgomp.c/target-11.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-11.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "e6b009463ad2fee79921d9f8479bd05dae77c4a7", "filename": "libgomp/testsuite/libgomp.c/target-12.c", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-12.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "168850b507c01e917b83276c9a1500fd6944ee1f", "filename": "libgomp/testsuite/libgomp.c/target-13.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-13.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "17d383407a2d728999aba538485581d3c433a008", "filename": "libgomp/testsuite/libgomp.c/target-14.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-14.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "fee9252ef3da134d04ca8497ab92801e84a10cb4", "filename": "libgomp/testsuite/libgomp.c/target-15.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-15.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "7b0919b1b00271775f8825efa7d82de00508c707", "filename": "libgomp/testsuite/libgomp.c/target-16.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-16.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "4a762012eaf7a57b284b667ce0e95bd36ae3b0a7", "filename": "libgomp/testsuite/libgomp.c/target-17.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-17.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "cbacaf6a77ac673864f943a88e312e743441155f", "filename": "libgomp/testsuite/libgomp.c/target-18.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-18.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "710c5078ff67d299f52557a5e930a8e924e073a7", "filename": "libgomp/testsuite/libgomp.c/target-19.c", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-19.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "0ba766c0a82b20cc72491be2a9cc28a199ccc3c8", "filename": "libgomp/testsuite/libgomp.c/target-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-2.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "3f4e798a7554a892b1132cba00798cc0e8c15029", "filename": "libgomp/testsuite/libgomp.c/target-20.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-20.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "41498cf21483e5ea08c7f24c36ccec60fe5c26d6", "filename": "libgomp/testsuite/libgomp.c/target-21.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-21.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "aad8a0a09df70349aa909c5a53a64811cf5757a1", "filename": "libgomp/testsuite/libgomp.c/target-22.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-22.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "fb1532a07b257bb6187e1efaea46bc5bf07ce4ea", "filename": "libgomp/testsuite/libgomp.c/target-23.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-23.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "e0ff29aaee8b515dc1808b52fa8348a609d71f55", "filename": "libgomp/testsuite/libgomp.c/target-24.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-24.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "aeb19aee5102374fa8eebca3ac42c59dcc10aba3", "filename": "libgomp/testsuite/libgomp.c/target-25.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-25.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "fa6b52598da9b4ba07b5bc992c8c12dc7eed1933", "filename": "libgomp/testsuite/libgomp.c/target-26.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-26.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "c86651b02e3be6872661da53e5b682425b083b27", "filename": "libgomp/testsuite/libgomp.c/target-27.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-27.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "41a1332bb0c92bb6cc514a603d0ef17af5432b0b", "filename": "libgomp/testsuite/libgomp.c/target-7.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-7.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "21551f2950c560c6c7fc7a8e78c2bf7422dd0473", "filename": "libgomp/testsuite/libgomp.c/taskloop-1.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftaskloop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftaskloop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftaskloop-1.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "be893ebf80aaa4ad639d9d7c05b1a831d3ca0464", "filename": "libgomp/testsuite/libgomp.c/taskloop-2.c", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftaskloop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftaskloop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftaskloop-2.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "5356d7f0251cc45a73964c503f1d0b68eff37390", "filename": "libgomp/testsuite/libgomp.c/taskloop-3.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftaskloop-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftaskloop-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftaskloop-3.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "a69be19c9c21ed5be2f011f7fdfbd50b76b60d40", "filename": "libgomp/testsuite/libgomp.c/taskloop-4.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftaskloop-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.c%2Ftaskloop-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftaskloop-4.c?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "26b5185ba3c5813648679db969f3b2ecb7b8dd48", "filename": "libgomp/testsuite/libgomp.fortran/affinity1.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.fortran%2Faffinity1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.fortran%2Faffinity1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Faffinity1.f90?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "338f0e8bb93240fd68f29630df6c24081b182543", "filename": "libgomp/testsuite/libgomp.fortran/affinity2.f90", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.fortran%2Faffinity2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/libgomp%2Ftestsuite%2Flibgomp.fortran%2Faffinity2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Faffinity2.f90?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "82e7999188c97a270a17a4ef615c03d698eaef50", "filename": "liboffloadmic/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/liboffloadmic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/liboffloadmic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FChangeLog?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "26ac6fed982c70651f5fb1f1aba42dcc822895f4", "filename": "liboffloadmic/plugin/libgomp-plugin-intelmic.cpp", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}, {"sha": "18b014641b64da908ae5802695cad74c18662d40", "filename": "liboffloadmic/plugin/offload_target_main.cpp", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/liboffloadmic%2Fplugin%2Foffload_target_main.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a6bd32adc40a7e1e5c72692a330f14453ad7f0/liboffloadmic%2Fplugin%2Foffload_target_main.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Foffload_target_main.cpp?ref=d9a6bd32adc40a7e1e5c72692a330f14453ad7f0"}]}