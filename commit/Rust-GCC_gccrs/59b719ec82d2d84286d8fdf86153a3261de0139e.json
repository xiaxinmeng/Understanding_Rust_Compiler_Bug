{"sha": "59b719ec82d2d84286d8fdf86153a3261de0139e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTliNzE5ZWM4MmQyZDg0Mjg2ZDhmZGY4NjE1M2EzMjYxZGUwMTM5ZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2011-12-06T03:41:44Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2011-12-06T03:41:44Z"}, "message": "re PR target/50906 (e500 exception unwinding under \"-Os\" causes SIGSEGV)\n\n\tPR target/50906\n\t* config/rs6000/rs6000.c (rs6000_emit_prologue <TARGET_SPE_ABI>):\n\tDo not mark r11 setup as frame-related.  Pass correct offset to\n\trs6000_emit_savres_rtx.  Correct out-of-line rs6000_frame_related\n\targuments.  Correct sp_offset.  Remove \"offset\" fudge from\n\tin-line rs6000_frame_related call.  Rename misleading variable.\n\tFix comments and whitespace.  Tidy some expressions.\n\t(rs6000_emit_epilogue <TARGET_SPE_ABI>): Always set frame_reg_rtx\n\tto r11 in out-of-line case.  Correct sp_offset.  Pass correct\n\toffset to rs6000_emit_savres_rtx.  Rename misleading variable.\n\tFix comments and whitespace.  Tidy some expressions.\n\t(rs6000_emit_epilogue <non-TARGET_SPE_ABI>): Add sp_offset\n\tadjustment when !saving_GPRs_inline.  Correct register mode\n\tused in address calcs.\n\t(rs6000_emit_epilogue <non-TARGET_SPE_ABI>): Similarly when\n\t!restoring_GPRs_inline.\n\nFrom-SVN: r182039", "tree": {"sha": "a7fdcab07896057cfb60354593240f5f906e4086", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7fdcab07896057cfb60354593240f5f906e4086"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59b719ec82d2d84286d8fdf86153a3261de0139e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59b719ec82d2d84286d8fdf86153a3261de0139e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59b719ec82d2d84286d8fdf86153a3261de0139e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59b719ec82d2d84286d8fdf86153a3261de0139e/comments", "author": null, "committer": null, "parents": [{"sha": "6184a33dce6c113cc602dbfbd48e0a1605836168", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6184a33dce6c113cc602dbfbd48e0a1605836168", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6184a33dce6c113cc602dbfbd48e0a1605836168"}], "stats": {"total": 215, "additions": 118, "deletions": 97}, "files": [{"sha": "18ad86a146352b8410c719cf7c321545090a1095", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b719ec82d2d84286d8fdf86153a3261de0139e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b719ec82d2d84286d8fdf86153a3261de0139e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=59b719ec82d2d84286d8fdf86153a3261de0139e", "patch": "@@ -1,6 +1,25 @@\n+2011-12-06  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/50906\n+\t* config/rs6000/rs6000.c (rs6000_emit_prologue <TARGET_SPE_ABI>):\n+\tDo not mark r11 setup as frame-related.  Pass correct offset to\n+\trs6000_emit_savres_rtx.  Correct out-of-line rs6000_frame_related\n+\targuments.  Correct sp_offset.  Remove \"offset\" fudge from\n+\tin-line rs6000_frame_related call.  Rename misleading variable.\n+\tFix comments and whitespace.  Tidy some expressions.\n+\t(rs6000_emit_epilogue <TARGET_SPE_ABI>): Always set frame_reg_rtx\n+\tto r11 in out-of-line case.  Correct sp_offset.  Pass correct\n+\toffset to rs6000_emit_savres_rtx.  Rename misleading variable.\n+\tFix comments and whitespace.  Tidy some expressions.\n+\t(rs6000_emit_epilogue <non-TARGET_SPE_ABI>): Add sp_offset\n+\tadjustment when !saving_GPRs_inline.  Correct register mode\n+\tused in address calcs.\n+\t(rs6000_emit_epilogue <non-TARGET_SPE_ABI>): Similarly when\n+\t!restoring_GPRs_inline.\n+\n 2011-12-06  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>\n \n-\t* config/arm/vfp.md (*combine_vcvt_f64_<FCVTI32typename>): Fix \n+\t* config/arm/vfp.md (*combine_vcvt_f64_<FCVTI32typename>): Fix\n \tformatting character for vmov.f64 case.\n \n 2011-12-05  Jakub Jelinek  <jakub@redhat.com>\n@@ -149,15 +168,15 @@\n \n 2011-12-05  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>\n \n-       * config/arm/arm.c (vfp3_const_double_for_fract_bits): Define.\n-       * config/arm/arm-protos.h (vfp3_const_double_for_fract_bits): Declare.\n-       * config/arm/constraints.md (\"Dt\"): New constraint.\n-       * config/arm/predicates.md\n-       (const_double_vcvt_power_of_two_reciprocal): New.\n-       * config/arm/vfp.md (FCVTI32typename): New.\n-       (FCVT): New iterator.\n-       (*combine_vcvt_f32_<FCVTI32typename>): New.\n-       (*combine_vcvt_f64_<FCVTI32typename>): New.\n+\t* config/arm/arm.c (vfp3_const_double_for_fract_bits): Define.\n+\t* config/arm/arm-protos.h (vfp3_const_double_for_fract_bits): Declare.\n+\t* config/arm/constraints.md (\"Dt\"): New constraint.\n+\t* config/arm/predicates.md\n+\t(const_double_vcvt_power_of_two_reciprocal): New.\n+\t* config/arm/vfp.md (FCVTI32typename): New.\n+\t(FCVT): New iterator.\n+\t(*combine_vcvt_f32_<FCVTI32typename>): New.\n+\t(*combine_vcvt_f64_<FCVTI32typename>): New.\n \n 2011-12-05  Richard Guenther  <rguenther@suse.de>\n "}, {"sha": "c8eacafb0b8882a66f1f46882e8309abac707f45", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 89, "deletions": 87, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b719ec82d2d84286d8fdf86153a3261de0139e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b719ec82d2d84286d8fdf86153a3261de0139e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=59b719ec82d2d84286d8fdf86153a3261de0139e", "patch": "@@ -19551,56 +19551,52 @@ rs6000_emit_prologue (void)\n     {\n       int i;\n       rtx spe_save_area_ptr;\n- \n+      int save_ptr_to_sp;\n+      int ool_adjust = 0;\n+\n       /* Determine whether we can address all of the registers that need\n-\t to be saved with an offset from the stack pointer that fits in\n+\t to be saved with an offset from frame_reg_rtx that fits in\n \t the small const field for SPE memory instructions.  */\n-      int spe_regs_addressable_via_sp\n-\t= (SPE_CONST_OFFSET_OK(info->spe_gp_save_offset + sp_offset\n-\t\t\t       + (32 - info->first_gp_reg_save - 1) * reg_size)\n+      int spe_regs_addressable\n+\t= (SPE_CONST_OFFSET_OK (info->spe_gp_save_offset + sp_offset\n+\t\t\t\t+ reg_size * (32 - info->first_gp_reg_save - 1))\n \t   && saving_GPRs_inline);\n       int spe_offset;\n- \n-      if (spe_regs_addressable_via_sp)\n+\n+      if (spe_regs_addressable)\n \t{\n \t  spe_save_area_ptr = frame_reg_rtx;\n+\t  save_ptr_to_sp = info->total_size - sp_offset;\n \t  spe_offset = info->spe_gp_save_offset + sp_offset;\n \t}\n       else\n \t{\n \t  /* Make r11 point to the start of the SPE save area.  We need\n \t     to be careful here if r11 is holding the static chain.  If\n-\t     it is, then temporarily save it in r0.  We would use r0 as\n-\t     our base register here, but using r0 as a base register in\n-\t     loads and stores means something different from what we\n-\t     would like.  */\n-\t  int ool_adjust = (saving_GPRs_inline\n-\t\t\t    ? 0\n-\t\t\t    : (info->first_gp_reg_save\n-\t\t\t       - (FIRST_SAVRES_REGISTER+1))*8);\n-\t  HOST_WIDE_INT offset = (info->spe_gp_save_offset\n-\t\t\t\t  + sp_offset - ool_adjust);\n+\t     it is, then temporarily save it in r0.  */\n+\t  int offset;\n+\n+\t  if (!saving_GPRs_inline)\n+\t    ool_adjust = 8 * (info->first_gp_reg_save\n+\t\t\t      - (FIRST_SAVRES_REGISTER + 1));\n+\t  offset = info->spe_gp_save_offset + sp_offset - ool_adjust;\n+\t  spe_save_area_ptr = gen_rtx_REG (Pmode, 11);\n+\t  save_ptr_to_sp = info->total_size - sp_offset + offset;\n+\t  spe_offset = 0;\n \n \t  if (using_static_chain_p)\n \t    {\n \t      rtx r0 = gen_rtx_REG (Pmode, 0);\n \t      gcc_assert (info->first_gp_reg_save > 11);\n- \n-\t      emit_move_insn (r0, gen_rtx_REG (Pmode, 11));\n+\n+\t      emit_move_insn (r0, spe_save_area_ptr);\n \t    }\n- \n-\t  spe_save_area_ptr = gen_rtx_REG (Pmode, 11);\n-\t  insn = emit_insn (gen_addsi3 (spe_save_area_ptr,\n-\t\t\t\t\tframe_reg_rtx,\n-\t\t\t\t\tGEN_INT (offset)));\n-\t  /* We need to make sure the move to r11 gets noted for\n-\t     properly outputting unwind information.  */\n-\t  if (!saving_GPRs_inline)\n-\t    rs6000_frame_related (insn, frame_reg_rtx, offset,\n-\t\t\t\t  NULL_RTX, NULL_RTX);\n-\t  spe_offset = 0;\n+\t  emit_insn (gen_addsi3 (spe_save_area_ptr,\n+\t\t\t\t frame_reg_rtx, GEN_INT (offset)));\n+\t  if (REGNO (frame_reg_rtx) == 11)\n+\t    sp_offset = -info->spe_gp_save_offset + ool_adjust;\n \t}\n- \n+\n       if (saving_GPRs_inline)\n \t{\n \t  for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n@@ -19612,58 +19608,65 @@ rs6000_emit_prologue (void)\n \t\t/* We're doing all this to ensure that the offset fits into\n \t\t   the immediate offset of 'evstdd'.  */\n \t\tgcc_assert (SPE_CONST_OFFSET_OK (reg_size * i + spe_offset));\n- \n+\n \t\toffset = GEN_INT (reg_size * i + spe_offset);\n \t\taddr = gen_rtx_PLUS (Pmode, spe_save_area_ptr, offset);\n \t\tmem = gen_rtx_MEM (V2SImode, addr);\n-  \n+\n \t\tinsn = emit_move_insn (mem, reg);\n-\t   \n-\t\trs6000_frame_related (insn, spe_save_area_ptr,\n-\t\t\t\t      info->spe_gp_save_offset\n-\t\t\t\t      + sp_offset + reg_size * i,\n-\t\t\t\t      offset, const0_rtx);\n+\n+\t\trs6000_frame_related (insn,\n+\t\t\t\t      spe_save_area_ptr, save_ptr_to_sp,\n+\t\t\t\t      NULL_RTX, NULL_RTX);\n \t      }\n \t}\n       else\n \t{\n-\t  insn = rs6000_emit_savres_rtx (info, gen_rtx_REG (Pmode, 11),\n-\t\t\t\t\t 0, reg_mode,\n+\t  insn = rs6000_emit_savres_rtx (info, spe_save_area_ptr,\n+\t\t\t\t\t ool_adjust, reg_mode,\n \t\t\t\t\t /*savep=*/true, /*gpr=*/true,\n \t\t\t\t\t /*lr=*/false);\n-\t  rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n+\n+\t  rs6000_frame_related (insn, spe_save_area_ptr, save_ptr_to_sp,\n \t\t\t\tNULL_RTX, NULL_RTX);\n \t}\n-\t\t\t\t\t\n- \n+\n       /* Move the static chain pointer back.  */\n-      if (using_static_chain_p && !spe_regs_addressable_via_sp)\n-\temit_move_insn (gen_rtx_REG (Pmode, 11), gen_rtx_REG (Pmode, 0));\n+      if (using_static_chain_p && !spe_regs_addressable)\n+\temit_move_insn (spe_save_area_ptr, gen_rtx_REG (Pmode, 0));\n     }\n   else if (!WORLD_SAVE_P (info) && !saving_GPRs_inline)\n     {\n       if (DEFAULT_ABI == ABI_DARWIN)\n \t{\n-\t  rtx dest_reg = gen_rtx_REG (reg_mode, 11);\n+\t  rtx dest_reg = gen_rtx_REG (Pmode, 11);\n \t  if (info->first_fp_reg_save == 64)\n-\t    /* we only need a copy, no fprs were saved.  */\n-\t    emit_move_insn (dest_reg, frame_reg_rtx);\n+\t    {\n+\t      /* we only need a copy, no fprs were saved.  */\n+\t      if (dest_reg != frame_reg_rtx)\n+\t\temit_move_insn (dest_reg, frame_reg_rtx);\n+\t    }\n \t  else\n \t    {\n-\t      rtx offset = GEN_INT (sp_offset\n-\t\t\t\t    + (-8 * (64-info->first_fp_reg_save)));\n+\t      int save_off = 8 * (64 - info->first_fp_reg_save);\n+\t      rtx offset = GEN_INT (sp_offset - save_off);\n+\n+\t      if (REGNO (dest_reg) == REGNO (frame_reg_rtx))\n+\t\tsp_offset = save_off;\n \t      emit_insn (gen_add3_insn (dest_reg, frame_reg_rtx, offset));\n \t    }\n \t}\n       /* Need to adjust r11 (r12) if we saved any FPRs.  */\n       else if (info->first_fp_reg_save != 64)\n-        {\n-\t  rtx dest_reg = gen_rtx_REG (reg_mode, DEFAULT_ABI == ABI_AIX\n-\t\t\t\t      ? 12 : 11);\n-\t  rtx offset = GEN_INT (sp_offset\n-                                + (-8 * (64-info->first_fp_reg_save)));\n+\t{\n+\t  rtx dest_reg = gen_rtx_REG (Pmode, DEFAULT_ABI == ABI_AIX ? 12 : 11);\n+\t  int save_off = 8 * (64 - info->first_fp_reg_save);\n+\t  rtx offset = GEN_INT (sp_offset - save_off);\n+\n+\t  if (REGNO (dest_reg) == REGNO (frame_reg_rtx))\n+\t    sp_offset = save_off;\n \t  emit_insn (gen_add3_insn (dest_reg, frame_reg_rtx, offset));\n-        }\n+\t}\n \n       insn = rs6000_emit_savres_rtx (info, frame_reg_rtx,\n \t\t\t\t     info->gp_save_offset + sp_offset,\n@@ -20577,40 +20580,39 @@ rs6000_emit_epilogue (int sibcall)\n       && info->first_gp_reg_save != 32)\n     {\n       /* Determine whether we can address all of the registers that need\n-         to be saved with an offset from the stack pointer that fits in\n-         the small const field for SPE memory instructions.  */\n-      int spe_regs_addressable_via_sp\n-\t= (SPE_CONST_OFFSET_OK(info->spe_gp_save_offset + sp_offset\n-\t\t\t       + (32 - info->first_gp_reg_save - 1) * reg_size)\n+\t to be saved with an offset from frame_reg_rtx that fits in\n+\t the small const field for SPE memory instructions.  */\n+      int spe_regs_addressable\n+\t= (SPE_CONST_OFFSET_OK (info->spe_gp_save_offset + sp_offset\n+\t\t\t\t+ reg_size * (32 - info->first_gp_reg_save - 1))\n \t   && restoring_GPRs_inline);\n       int spe_offset;\n+      int ool_adjust = 0;\n \n-      if (spe_regs_addressable_via_sp)\n+      if (spe_regs_addressable)\n \tspe_offset = info->spe_gp_save_offset + sp_offset;\n       else\n-        {\n+\t{\n \t  rtx old_frame_reg_rtx = frame_reg_rtx;\n-          /* Make r11 point to the start of the SPE save area.  We worried about\n-             not clobbering it when we were saving registers in the prologue.\n-             There's no need to worry here because the static chain is passed\n-             anew to every function.  */\n-\t  int ool_adjust = (restoring_GPRs_inline\n-\t\t\t    ? 0\n-\t\t\t    : (info->first_gp_reg_save\n-\t\t\t       - (FIRST_SAVRES_REGISTER + 1)) * 8);\n-\n-\t  if (frame_reg_rtx == sp_reg_rtx)\n-\t    frame_reg_rtx = gen_rtx_REG (Pmode, 11);\n-          emit_insn (gen_addsi3 (frame_reg_rtx, old_frame_reg_rtx,\n+\t  /* Make r11 point to the start of the SPE save area.  We worried about\n+\t     not clobbering it when we were saving registers in the prologue.\n+\t     There's no need to worry here because the static chain is passed\n+\t     anew to every function.  */\n+\n+\t  if (!restoring_GPRs_inline)\n+\t    ool_adjust = 8 * (info->first_gp_reg_save\n+\t\t\t      - (FIRST_SAVRES_REGISTER + 1));\n+\t  frame_reg_rtx = gen_rtx_REG (Pmode, 11);\n+\t  emit_insn (gen_addsi3 (frame_reg_rtx, old_frame_reg_rtx,\n \t\t\t\t GEN_INT (info->spe_gp_save_offset\n \t\t\t\t\t  + sp_offset\n \t\t\t\t\t  - ool_adjust)));\n \t  /* Keep the invariant that frame_reg_rtx + sp_offset points\n \t     at the top of the stack frame.  */\n-\t  sp_offset = -info->spe_gp_save_offset;\n+\t  sp_offset = -info->spe_gp_save_offset + ool_adjust;\n \n-          spe_offset = 0;\n-        }\n+\t  spe_offset = 0;\n+\t}\n \n       if (restoring_GPRs_inline)\n \t{\n@@ -20632,8 +20634,8 @@ rs6000_emit_epilogue (int sibcall)\n \t      }\n \t}\n       else\n-\trs6000_emit_savres_rtx (info, gen_rtx_REG (Pmode, 11),\n-\t\t\t\t0, reg_mode,\n+\trs6000_emit_savres_rtx (info, frame_reg_rtx,\n+\t\t\t\tool_adjust, reg_mode,\n \t\t\t\t/*savep=*/false, /*gpr=*/true,\n \t\t\t\t/*lr=*/true);\n     }\n@@ -20646,22 +20648,22 @@ rs6000_emit_epilogue (int sibcall)\n       if (can_use_exit)\n \t{\n \t  rs6000_emit_stack_reset (info, sp_reg_rtx, frame_reg_rtx,\n-\t\t\t\t sp_offset, can_use_exit);\n+\t\t\t\t   sp_offset, can_use_exit);\n \t  if (DEFAULT_ABI == ABI_DARWIN)\n \t    /* we only need a copy, no fprs were saved.  */\n-\t    emit_move_insn (gen_rtx_REG (reg_mode, 11), frame_reg_rtx);\n+\t    emit_move_insn (gen_rtx_REG (Pmode, 11), frame_reg_rtx);\n \n \t  if (info->cr_save_p)\n \t    rs6000_restore_saved_cr (cr_save_reg, using_mtcr_multiple);\n \t}\n       else\n \t{\n-\t  emit_insn (gen_add3_insn (gen_rtx_REG (Pmode, DEFAULT_ABI == ABI_AIX\n-\t\t\t\t\t\t\t? 12 : 11),\n-\t\t\t\t    frame_reg_rtx,\n+\t  rtx src_reg = gen_rtx_REG (Pmode, DEFAULT_ABI == ABI_AIX ? 12 : 11);\n+\n+\t  emit_insn (gen_add3_insn (src_reg, frame_reg_rtx,\n \t\t\t\t    GEN_INT (sp_offset - info->fp_size)));\n-\t  if (REGNO (frame_reg_rtx) == 11)\n-\t    sp_offset += info->fp_size;\n+\t  if (REGNO (frame_reg_rtx) == REGNO (src_reg))\n+\t    sp_offset = info->fp_size;\n \t}\n \n       rs6000_emit_savres_rtx (info, frame_reg_rtx,"}]}