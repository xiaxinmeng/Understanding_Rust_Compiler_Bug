{"sha": "9ad2c6927100e3ba84b7e6b6d528cc18ca295ec9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFkMmM2OTI3MTAwZTNiYTg0YjdlNmI2ZDUyOGNjMThjYTI5NWVjOQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-02-05T23:37:09Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-02-05T23:37:09Z"}, "message": "(EXTRA_CONSTAINTS): Delete 'R' support.\n\n(CONST_OK_FOR_LETTER_P): Correct 'K' comment.\n\nFrom-SVN: r3428", "tree": {"sha": "f6ec6d92216be672b1b42d31b4afb8d0d6629ea9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6ec6d92216be672b1b42d31b4afb8d0d6629ea9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ad2c6927100e3ba84b7e6b6d528cc18ca295ec9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ad2c6927100e3ba84b7e6b6d528cc18ca295ec9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ad2c6927100e3ba84b7e6b6d528cc18ca295ec9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ad2c6927100e3ba84b7e6b6d528cc18ca295ec9/comments", "author": null, "committer": null, "parents": [{"sha": "193013107a125e9956d54dad764eade5cc76aef7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/193013107a125e9956d54dad764eade5cc76aef7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/193013107a125e9956d54dad764eade5cc76aef7"}], "stats": {"total": 38, "additions": 14, "deletions": 24}, "files": [{"sha": "8a1e93771df0a8abc7302de873fc4c6e376bd384", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ad2c6927100e3ba84b7e6b6d528cc18ca295ec9/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ad2c6927100e3ba84b7e6b6d528cc18ca295ec9/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=9ad2c6927100e3ba84b7e6b6d528cc18ca295ec9", "patch": "@@ -568,7 +568,7 @@ extern char leaf_reg_backmap[];\n    For SPARC, `I' is used for the range of constants an insn\n    can actually contain.\n    `J' is used for the range which is just zero (since that is R0).\n-   `K' is used for the 5-bit operand of a compare insns.  */\n+   `K' is used for constants which can be loaded with a single sethi insn.  */\n \n #define SMALL_INT(X) ((unsigned) (INTVAL (X) + 0x1000) < 0x2000)\n \n@@ -1114,8 +1114,6 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n    these things in insns and then not re-recognize the insns, causing\n    constrain_operands to fail.\n \n-   `R' handles the LO_SUM which can be an address for `Q'.\n-\n    `S' handles constraints for calls.  */\n \n #ifndef REG_OK_STRICT\n@@ -1134,10 +1132,6 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n        && ! symbolic_memory_operand (OP, VOIDmode))\t\\\n       || (reload_in_progress && GET_CODE (OP) == REG\t\\\n \t  && REGNO (OP) >= FIRST_PSEUDO_REGISTER))\t\\\n-   : (C) == 'R'\t\t\t\t\t\t\\\n-   ? (GET_CODE (OP) == LO_SUM\t\t\t\t\\\n-      && GET_CODE (XEXP (OP, 0)) == REG\t\t\t\\\n-      && REG_OK_FOR_BASE_P (XEXP (OP, 0)))\t\t\\\n    : (C) == 'S'\t\t\t\t\t\t\\\n    ? (CONSTANT_P (OP) || memory_address_p (Pmode, OP))\t\\\n    : (C) == 'T'\t\t\t\t\t\t\\\n@@ -1154,23 +1148,19 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n #define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n-  ((C) == 'Q' ?\t\t\t\t\t\t\\\n-   (GET_CODE (OP) == REG ?\t\t\t\t\\\n-    (REGNO (OP) >= FIRST_PSEUDO_REGISTER\t\t\\\n-     && reg_renumber[REGNO (OP)] < 0)\t\t\t\\\n-    : GET_CODE (OP) == MEM)\t\t\t\t\\\n-   : ((C) == 'R' ?\t\t\t\t\t\\\n-      (GET_CODE (OP) == LO_SUM\t\t\t\t\\\n-       && GET_CODE (XEXP (OP, 0)) == REG\t\t\\\n-       && REG_OK_FOR_BASE_P (XEXP (OP, 0)))\t\t\\\n-      : ((C) == 'S'\t\t\t\t\t\\\n-\t ? (CONSTANT_P (OP)\t\t\t\t\\\n-\t    || (GET_CODE (OP) == REG && reg_renumber[REGNO (OP)] > 0)\\\n-\t    || strict_memory_address_p (Pmode, OP)) \t\\\n-\t : ((C) == 'T' ?\t\t\t\t\\\n-\t    mem_aligned_8 (OP) && strict_memory_address_p (Pmode, OP) \\\n-\t    : ((C) == 'U' ?\t\t\t\t\\\n-\t       register_ok_for_ldd (OP) : 0)))))\n+  ((C) == 'Q'\t\t\t\t\t\t\\\n+   ? (GET_CODE (OP) == REG\t\t\t\t\\\n+      ? (REGNO (OP) >= FIRST_PSEUDO_REGISTER\t\t\\\n+\t && reg_renumber[REGNO (OP)] < 0)\t\t\\\n+      : GET_CODE (OP) == MEM)\t\t\t\t\\\n+   : (C) == 'S'\t\t\t\t\t\t\\\n+   ? (CONSTANT_P (OP)\t\t\t\t\t\\\n+      || (GET_CODE (OP) == REG && reg_renumber[REGNO (OP)] > 0) \\\n+      || strict_memory_address_p (Pmode, OP)) \t\t\\\n+   : (C) == 'T'\t\t\t\t\t\t\\\n+   ? mem_aligned_8 (OP) && strict_memory_address_p (Pmode, OP) \\\n+   : (C) == 'U'\t\t\t\t\t\t\\\n+   ? register_ok_for_ldd (OP) : 0)\n #endif\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression"}]}