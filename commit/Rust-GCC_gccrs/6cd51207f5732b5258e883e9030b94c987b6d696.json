{"sha": "6cd51207f5732b5258e883e9030b94c987b6d696", "node_id": "C_kwDOANBUbNoAKDZjZDUxMjA3ZjU3MzJiNTI1OGU4ODNlOTAzMGI5NGM5ODdiNmQ2OTY", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-01-06T21:13:04Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-01-07T22:11:56Z"}, "message": "c++: check delete access with trivial init [PR20040]\n\nApparently we need to check the accessibility of the deallocation function\neven if there is no initialization.\n\n\tPR c++/20040\n\ngcc/cp/ChangeLog:\n\n\t* init.c (build_new_1): Also build pointer cleanup if\n\tTYPE_GETS_DELETE.\n\t* cp-tree.h (TYPE_GETS_VEC_DELETE): New.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/init/delete4.C: New test.", "tree": {"sha": "ed273fb8060d19c9175856c892efb20bea769f7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed273fb8060d19c9175856c892efb20bea769f7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cd51207f5732b5258e883e9030b94c987b6d696", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cd51207f5732b5258e883e9030b94c987b6d696", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cd51207f5732b5258e883e9030b94c987b6d696", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cd51207f5732b5258e883e9030b94c987b6d696/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "997130f778c56466a825627644e510960585521b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/997130f778c56466a825627644e510960585521b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/997130f778c56466a825627644e510960585521b"}], "stats": {"total": 143, "additions": 82, "deletions": 61}, "files": [{"sha": "f8225c18a48f037768b927fed68b0184c3f66a78", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd51207f5732b5258e883e9030b94c987b6d696/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd51207f5732b5258e883e9030b94c987b6d696/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6cd51207f5732b5258e883e9030b94c987b6d696", "patch": "@@ -2395,6 +2395,7 @@ struct GTY(()) lang_type {\n /* Nonzero for _CLASSTYPE means that operator delete is defined.  */\n #define TYPE_GETS_DELETE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->gets_delete)\n #define TYPE_GETS_REG_DELETE(NODE) (TYPE_GETS_DELETE (NODE) & 1)\n+#define TYPE_GETS_VEC_DELETE(NODE) (TYPE_GETS_DELETE (NODE) & 2)\n \n /* Nonzero if `new NODE[x]' should cause the allocation of extra\n    storage to indicate how many array elements are in use.  */"}, {"sha": "6226812b47008af750b7b87a7ad780b379894cc2", "filename": "gcc/cp/init.c", "status": "modified", "additions": 67, "deletions": 61, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd51207f5732b5258e883e9030b94c987b6d696/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd51207f5732b5258e883e9030b94c987b6d696/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=6cd51207f5732b5258e883e9030b94c987b6d696", "patch": "@@ -3316,6 +3316,12 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t\t     ? TYPE_HAS_ARRAY_NEW_OPERATOR (elt_type)\n \t\t     : TYPE_HAS_NEW_OPERATOR (elt_type));\n \n+  bool member_delete_p = (!globally_qualified_p\n+\t\t\t  && CLASS_TYPE_P (elt_type)\n+\t\t\t  && (array_p\n+\t\t\t      ? TYPE_GETS_VEC_DELETE (elt_type)\n+\t\t\t      : TYPE_GETS_REG_DELETE (elt_type)));\n+\n   if (member_new_p)\n     {\n       /* Use a class-specific operator new.  */\n@@ -3473,7 +3479,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \n   /* In the simple case, we can stop now.  */\n   pointer_type = build_pointer_type (type);\n-  if (!cookie_size && !is_initialized)\n+  if (!cookie_size && !is_initialized && !member_delete_p)\n     return build_nop (pointer_type, alloc_call);\n \n   /* Store the result of the allocation call in a variable so that we can\n@@ -3700,76 +3706,76 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \n       if (init_expr == error_mark_node)\n \treturn error_mark_node;\n+    }\n+  else\n+    init_expr = NULL_TREE;\n \n-      /* If any part of the object initialization terminates by throwing an\n-\t exception and a suitable deallocation function can be found, the\n-\t deallocation function is called to free the memory in which the\n-\t object was being constructed, after which the exception continues\n-\t to propagate in the context of the new-expression. If no\n-\t unambiguous matching deallocation function can be found,\n-\t propagating the exception does not cause the object's memory to be\n-\t freed.  */\n-      if (flag_exceptions)\n+  /* If any part of the object initialization terminates by throwing an\n+     exception and a suitable deallocation function can be found, the\n+     deallocation function is called to free the memory in which the\n+     object was being constructed, after which the exception continues\n+     to propagate in the context of the new-expression. If no\n+     unambiguous matching deallocation function can be found,\n+     propagating the exception does not cause the object's memory to be\n+     freed.  */\n+  if (flag_exceptions && (init_expr || member_delete_p))\n+    {\n+      enum tree_code dcode = array_p ? VEC_DELETE_EXPR : DELETE_EXPR;\n+      tree cleanup;\n+\n+      /* The Standard is unclear here, but the right thing to do\n+\t is to use the same method for finding deallocation\n+\t functions that we use for finding allocation functions.  */\n+      cleanup = (build_op_delete_call\n+\t\t (dcode,\n+\t\t  alloc_node,\n+\t\t  size,\n+\t\t  globally_qualified_p,\n+\t\t  placement_allocation_fn_p ? alloc_call : NULL_TREE,\n+\t\t  alloc_fn,\n+\t\t  complain));\n+\n+      if (cleanup && init_expr && !processing_template_decl)\n+\t/* Ack!  First we allocate the memory.  Then we set our sentry\n+\t   variable to true, and expand a cleanup that deletes the\n+\t   memory if sentry is true.  Then we run the constructor, and\n+\t   finally clear the sentry.\n+\n+\t   We need to do this because we allocate the space first, so\n+\t   if there are any temporaries with cleanups in the\n+\t   constructor args, we need this EH region to extend until\n+\t   end of full-expression to preserve nesting.\n+\n+\t   We used to try to evaluate the args first to avoid this, but\n+\t   since C++17 [expr.new] says that \"The invocation of the\n+\t   allocation function is sequenced before the evaluations of\n+\t   expressions in the new-initializer.\"  */\n \t{\n-\t  enum tree_code dcode = array_p ? VEC_DELETE_EXPR : DELETE_EXPR;\n-\t  tree cleanup;\n-\n-\t  /* The Standard is unclear here, but the right thing to do\n-\t     is to use the same method for finding deallocation\n-\t     functions that we use for finding allocation functions.  */\n-\t  cleanup = (build_op_delete_call\n-\t\t     (dcode,\n-\t\t      alloc_node,\n-\t\t      size,\n-\t\t      globally_qualified_p,\n-\t\t      placement_allocation_fn_p ? alloc_call : NULL_TREE,\n-\t\t      alloc_fn,\n-\t\t      complain));\n-\n-\t  if (cleanup && !processing_template_decl)\n-\t    /* Ack!  First we allocate the memory.  Then we set our sentry\n-\t       variable to true, and expand a cleanup that deletes the\n-\t       memory if sentry is true.  Then we run the constructor, and\n-\t       finally clear the sentry.\n-\n-\t       We need to do this because we allocate the space first, so\n-\t       if there are any temporaries with cleanups in the\n-\t       constructor args, we need this EH region to extend until\n-\t       end of full-expression to preserve nesting.\n-\n-\t       We used to try to evaluate the args first to avoid this, but\n-\t       since C++17 [expr.new] says that \"The invocation of the\n-\t       allocation function is sequenced before the evaluations of\n-\t       expressions in the new-initializer.\"  */\n-\t    {\n-\t      tree end, sentry, begin;\n+\t  tree end, sentry, begin;\n \n-\t      begin = get_target_expr (boolean_true_node);\n-\t      CLEANUP_EH_ONLY (begin) = 1;\n+\t  begin = get_target_expr (boolean_true_node);\n+\t  CLEANUP_EH_ONLY (begin) = 1;\n \n-\t      sentry = TARGET_EXPR_SLOT (begin);\n+\t  sentry = TARGET_EXPR_SLOT (begin);\n \n-\t      /* CLEANUP is compiler-generated, so no diagnostics.  */\n-\t      suppress_warning (cleanup);\n+\t  /* CLEANUP is compiler-generated, so no diagnostics.  */\n+\t  suppress_warning (cleanup);\n \n-\t      TARGET_EXPR_CLEANUP (begin)\n-\t\t= build3 (COND_EXPR, void_type_node, sentry,\n-\t\t\t  cleanup, void_node);\n+\t  TARGET_EXPR_CLEANUP (begin)\n+\t    = build3 (COND_EXPR, void_type_node, sentry,\n+\t\t      cleanup, void_node);\n \n-\t      end = build2 (MODIFY_EXPR, TREE_TYPE (sentry),\n-\t\t\t    sentry, boolean_false_node);\n+\t  end = build2 (MODIFY_EXPR, TREE_TYPE (sentry),\n+\t\t\tsentry, boolean_false_node);\n \n-\t      init_expr\n-\t\t= build2 (COMPOUND_EXPR, void_type_node, begin,\n-\t\t\t  build2 (COMPOUND_EXPR, void_type_node, init_expr,\n-\t\t\t\t  end));\n-\t      /* Likewise, this is compiler-generated.  */\n-\t      suppress_warning (init_expr);\n-\t    }\n+\t  init_expr\n+\t    = build2 (COMPOUND_EXPR, void_type_node, begin,\n+\t\t      build2 (COMPOUND_EXPR, void_type_node, init_expr,\n+\t\t\t      end));\n+\t  /* Likewise, this is compiler-generated.  */\n+\t  suppress_warning (init_expr);\n \t}\n     }\n-  else\n-    init_expr = NULL_TREE;\n \n   /* Now build up the return value in reverse order.  */\n "}, {"sha": "94932b4b82c261d1c97e3da053d61bc28f28599f", "filename": "gcc/testsuite/g++.dg/init/delete4.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd51207f5732b5258e883e9030b94c987b6d696/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fdelete4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd51207f5732b5258e883e9030b94c987b6d696/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fdelete4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fdelete4.C?ref=6cd51207f5732b5258e883e9030b94c987b6d696", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/20040\n+\n+class X\n+{\n+  void operator delete(void *p) throw () {} // { dg-message \"declared private\" }\n+};\n+\n+X xa;\n+\n+int mymain()\n+{\n+  X *p = new X; // { dg-error \"is private\" }\n+  return 0;\n+}"}]}