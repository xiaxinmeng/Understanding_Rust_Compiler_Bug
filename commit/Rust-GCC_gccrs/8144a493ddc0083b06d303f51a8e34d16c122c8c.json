{"sha": "8144a493ddc0083b06d303f51a8e34d16c122c8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE0NGE0OTNkZGMwMDgzYjA2ZDMwM2Y1MWE4ZTM0ZDE2YzEyMmM4Yw==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2017-01-17T19:34:26Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2017-01-17T19:34:26Z"}, "message": "This patch simplifies the handling of EH return.\n\nThis patch simplifies the handling of EH return.  We force the use of the\nframe pointer so the return location is always at FP + 8.  This means we\ncan emit a simple volatile access in EH_RETURN_HANDLER_RTX without needing md\npatterns, splitters and frame offset calculations.  The new implementation also\nfixes various bugs in aarch64_final_eh_return_addr, which does not work with\n-fomit-frame-pointer, alloca or outgoing arguments.\n\n    gcc/\n\t* config/aarch64/aarch64.md (eh_return): Remove pattern and splitter.\n\t* config/aarch64/aarch64.h (AARCH64_EH_STACKADJ_REGNUM): Remove.\n\t(EH_RETURN_HANDLER_RTX): New define.\n\t* config/aarch64/aarch64.c (aarch64_frame_pointer_required):\n\tForce frame pointer in EH return functions.\n\t(aarch64_expand_epilogue): Add barrier for eh_return.\n\t(aarch64_final_eh_return_addr): Remove.\n\t(aarch64_eh_return_handler_rtx): New function.\n\t* config/aarch64/aarch64-protos.h (aarch64_final_eh_return_addr):\n\tRemove.\n\t(aarch64_eh_return_handler_rtx): New prototype.\n\n    testsuite/\n\t* gcc.target/aarch64/eh_return.c: New test.\n\nFrom-SVN: r244547", "tree": {"sha": "7d5f87929af63c4e61ef125668d02add9f1aa5e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d5f87929af63c4e61ef125668d02add9f1aa5e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8144a493ddc0083b06d303f51a8e34d16c122c8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8144a493ddc0083b06d303f51a8e34d16c122c8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8144a493ddc0083b06d303f51a8e34d16c122c8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8144a493ddc0083b06d303f51a8e34d16c122c8c/comments", "author": null, "committer": null, "parents": [{"sha": "a6607774860fae67f0913d98e30f3158aa0e77a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6607774860fae67f0913d98e30f3158aa0e77a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6607774860fae67f0913d98e30f3158aa0e77a5"}], "stats": {"total": 204, "additions": 139, "deletions": 65}, "files": [{"sha": "a8ba01c5f05d950320b32231e8b3fbd22cc23133", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8144a493ddc0083b06d303f51a8e34d16c122c8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8144a493ddc0083b06d303f51a8e34d16c122c8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8144a493ddc0083b06d303f51a8e34d16c122c8c", "patch": "@@ -1,3 +1,17 @@\n+2017-01-17  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/aarch64/aarch64.md (eh_return): Remove pattern and splitter.\n+\t* config/aarch64/aarch64.h (AARCH64_EH_STACKADJ_REGNUM): Remove.\n+\t(EH_RETURN_HANDLER_RTX): New define.\n+\t* config/aarch64/aarch64.c (aarch64_frame_pointer_required):\n+\tForce frame pointer in EH return functions.\n+\t(aarch64_expand_epilogue): Add barrier for eh_return.\n+\t(aarch64_final_eh_return_addr): Remove.\n+\t(aarch64_eh_return_handler_rtx): New function.\n+\t* config/aarch64/aarch64-protos.h (aarch64_final_eh_return_addr):\n+\tRemove.\n+\t(aarch64_eh_return_handler_rtx): New prototype.\n+\n 2017-01-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* config/rs6000/altivec.h (vec_rlmi): New #define."}, {"sha": "602f54f934a9b62e782154e7f19cafe3b1bf0481", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8144a493ddc0083b06d303f51a8e34d16c122c8c/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8144a493ddc0083b06d303f51a8e34d16c122c8c/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=8144a493ddc0083b06d303f51a8e34d16c122c8c", "patch": "@@ -358,7 +358,7 @@ int aarch64_hard_regno_mode_ok (unsigned, machine_mode);\n int aarch64_hard_regno_nregs (unsigned, machine_mode);\n int aarch64_uxt_size (int, HOST_WIDE_INT);\n int aarch64_vec_fpconst_pow_of_2 (rtx);\n-rtx aarch64_final_eh_return_addr (void);\n+rtx aarch64_eh_return_handler_rtx (void);\n rtx aarch64_mask_from_zextract_ops (rtx, rtx);\n const char *aarch64_output_move_struct (rtx *operands);\n rtx aarch64_return_addr (int, rtx);"}, {"sha": "27f2dc9c1c7fba8300720a1250d868c0abd43269", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 35, "deletions": 42, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8144a493ddc0083b06d303f51a8e34d16c122c8c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8144a493ddc0083b06d303f51a8e34d16c122c8c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=8144a493ddc0083b06d303f51a8e34d16c122c8c", "patch": "@@ -2762,6 +2762,10 @@ aarch64_frame_pointer_required (void)\n       && (!crtl->is_leaf || df_regs_ever_live_p (LR_REGNUM)))\n     return true;\n \n+  /* Force a frame pointer for EH returns so the return address is at FP+8.  */\n+  if (crtl->calls_eh_return)\n+    return true;\n+\n   return false;\n }\n \n@@ -3620,7 +3624,8 @@ aarch64_expand_epilogue (bool for_sibcall)\n \t\t\t + cfun->machine->frame.saved_varargs_size) != 0;\n \n   /* Emit a barrier to prevent loads from a deallocated stack.  */\n-  if (final_adjust > crtl->outgoing_args_size || cfun->calls_alloca)\n+  if (final_adjust > crtl->outgoing_args_size || cfun->calls_alloca\n+      || crtl->calls_eh_return)\n     {\n       emit_insn (gen_stack_tie (stack_pointer_rtx, stack_pointer_rtx));\n       need_barrier_p = false;\n@@ -3688,52 +3693,40 @@ aarch64_expand_epilogue (bool for_sibcall)\n     emit_jump_insn (ret_rtx);\n }\n \n-/* Return the place to copy the exception unwinding return address to.\n-   This will probably be a stack slot, but could (in theory be the\n-   return register).  */\n-rtx\n-aarch64_final_eh_return_addr (void)\n-{\n-  HOST_WIDE_INT fp_offset;\n-\n-  aarch64_layout_frame ();\n+/* Implement EH_RETURN_HANDLER_RTX.  EH returns need to either return\n+   normally or return to a previous frame after unwinding.\n \n-  fp_offset = cfun->machine->frame.frame_size\n-\t      - cfun->machine->frame.hard_fp_offset;\n+   An EH return uses a single shared return sequence.  The epilogue is\n+   exactly like a normal epilogue except that it has an extra input\n+   register (EH_RETURN_STACKADJ_RTX) which contains the stack adjustment\n+   that must be applied after the frame has been destroyed.  An extra label\n+   is inserted before the epilogue which initializes this register to zero,\n+   and this is the entry point for a normal return.\n \n-  if (cfun->machine->frame.reg_offset[LR_REGNUM] < 0)\n-    return gen_rtx_REG (DImode, LR_REGNUM);\n+   An actual EH return updates the return address, initializes the stack\n+   adjustment and jumps directly into the epilogue (bypassing the zeroing\n+   of the adjustment).  Since the return address is typically saved on the\n+   stack when a function makes a call, the saved LR must be updated outside\n+   the epilogue.\n \n-  /* DSE and CSELIB do not detect an alias between sp+k1 and fp+k2.  This can\n-     result in a store to save LR introduced by builtin_eh_return () being\n-     incorrectly deleted because the alias is not detected.\n-     So in the calculation of the address to copy the exception unwinding\n-     return address to, we note 2 cases.\n-     If FP is needed and the fp_offset is 0, it means that SP = FP and hence\n-     we return a SP-relative location since all the addresses are SP-relative\n-     in this case.  This prevents the store from being optimized away.\n-     If the fp_offset is not 0, then the addresses will be FP-relative and\n-     therefore we return a FP-relative location.  */\n+   This poses problems as the store is generated well before the epilogue,\n+   so the offset of LR is not known yet.  Also optimizations will remove the\n+   store as it appears dead, even after the epilogue is generated (as the\n+   base or offset for loading LR is different in many cases).\n \n-  if (frame_pointer_needed)\n-    {\n-      if (fp_offset)\n-        return gen_frame_mem (DImode,\n-\t\t\t      plus_constant (Pmode, hard_frame_pointer_rtx, UNITS_PER_WORD));\n-      else\n-        return gen_frame_mem (DImode,\n-\t\t\t      plus_constant (Pmode, stack_pointer_rtx, UNITS_PER_WORD));\n-    }\n-\n-  /* If FP is not needed, we calculate the location of LR, which would be\n-     at the top of the saved registers block.  */\n+   To avoid these problems this implementation forces the frame pointer\n+   in eh_return functions so that the location of LR is fixed and known early.\n+   It also marks the store volatile, so no optimization is permitted to\n+   remove the store.  */\n+rtx\n+aarch64_eh_return_handler_rtx (void)\n+{\n+  rtx tmp = gen_frame_mem (Pmode,\n+    plus_constant (Pmode, hard_frame_pointer_rtx, UNITS_PER_WORD));\n \n-  return gen_frame_mem (DImode,\n-\t\t\tplus_constant (Pmode,\n-\t\t\t\t       stack_pointer_rtx,\n-\t\t\t\t       fp_offset\n-\t\t\t\t       + cfun->machine->frame.saved_regs_size\n-\t\t\t\t       - 2 * UNITS_PER_WORD));\n+  /* Mark the store volatile, so no optimization is permitted to remove it.  */\n+  MEM_VOLATILE_P (tmp) = true;\n+  return tmp;\n }\n \n /* Output code to add DELTA to the first argument, and then jump"}, {"sha": "f6c18e84223be49e3efd516e2a1eed222bf8d7de", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8144a493ddc0083b06d303f51a8e34d16c122c8c/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8144a493ddc0083b06d303f51a8e34d16c122c8c/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=8144a493ddc0083b06d303f51a8e34d16c122c8c", "patch": "@@ -400,9 +400,9 @@ extern unsigned aarch64_architecture_version;\n #define ASM_DECLARE_FUNCTION_NAME(STR, NAME, DECL)\t\\\n   aarch64_declare_function_name (STR, NAME, DECL)\n \n-/* The register that holds the return address in exception handlers.  */\n-#define AARCH64_EH_STACKADJ_REGNUM\t(R0_REGNUM + 4)\n-#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, AARCH64_EH_STACKADJ_REGNUM)\n+/* For EH returns X4 contains the stack adjustment.  */\n+#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, R4_REGNUM)\n+#define EH_RETURN_HANDLER_RTX  aarch64_eh_return_handler_rtx ()\n \n /* Don't use __builtin_setjmp until we've defined it.  */\n #undef DONT_USE_BUILTIN_SETJMP"}, {"sha": "b3be106ac6ff1fb77bdc05cb4b0e57102787b87c", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8144a493ddc0083b06d303f51a8e34d16c122c8c/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8144a493ddc0083b06d303f51a8e34d16c122c8c/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=8144a493ddc0083b06d303f51a8e34d16c122c8c", "patch": "@@ -592,25 +592,6 @@\n   [(set_attr \"type\" \"branch\")]\n )\n \n-(define_insn \"eh_return\"\n-  [(unspec_volatile [(match_operand:DI 0 \"register_operand\" \"r\")]\n-    UNSPECV_EH_RETURN)]\n-  \"\"\n-  \"#\"\n-  [(set_attr \"type\" \"branch\")]\n-\n-)\n-\n-(define_split\n-  [(unspec_volatile [(match_operand:DI 0 \"register_operand\" \"\")]\n-    UNSPECV_EH_RETURN)]\n-  \"reload_completed\"\n-  [(set (match_dup 1) (match_dup 0))]\n-  {\n-    operands[1] = aarch64_final_eh_return_addr ();\n-  }\n-)\n-\n (define_insn \"*cb<optab><mode>1\"\n   [(set (pc) (if_then_else (EQL (match_operand:GPI 0 \"register_operand\" \"r\")\n \t\t\t\t(const_int 0))"}, {"sha": "eb1e3cc56b5bcbcf17311d1cac0064e1944783ee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8144a493ddc0083b06d303f51a8e34d16c122c8c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8144a493ddc0083b06d303f51a8e34d16c122c8c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8144a493ddc0083b06d303f51a8e34d16c122c8c", "patch": "@@ -1,3 +1,7 @@\n+2017-01-17  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* gcc.target/aarch64/eh_return.c: New test.\n+\n 2017-01-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* vec-rlmi-rlnm.c: New file."}, {"sha": "32179488085ed4c84aa77007565c875d09c4197c", "filename": "gcc/testsuite/gcc.target/aarch64/eh_return.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8144a493ddc0083b06d303f51a8e34d16c122c8c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Feh_return.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8144a493ddc0083b06d303f51a8e34d16c122c8c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Feh_return.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Feh_return.c?ref=8144a493ddc0083b06d303f51a8e34d16c122c8c", "patch": "@@ -0,0 +1,82 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-inline\" } */\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+int val, test, failed;\n+\n+int main (void);\n+\n+void\n+eh0 (void *p)\n+{\n+  val = (int)(long)p & 7;\n+  if (val)\n+    abort ();\n+}\n+\n+void\n+eh1 (void *p, int x)\n+{\n+  void *q = __builtin_alloca (x);\n+  eh0 (q);\n+  __builtin_eh_return (0, p);\n+}\n+\n+void\n+eh2a (int a,int b,int c,int d,int e,int f,int g,int h, void *p)\n+{\n+  val = a + b + c + d + e + f + g + h +  (int)(long)p & 7;\n+}\n+\n+void\n+eh2 (void *p)\n+{\n+  eh2a (val, val, val, val, val, val, val, val, p);\n+  __builtin_eh_return (0, p);\n+}\n+\n+\n+void\n+continuation (void)\n+{\n+  test++;\n+  main ();\n+}\n+\n+void\n+fail (void)\n+{\n+  failed = 1;\n+  printf (\"failed\\n\");\n+  continuation ();\n+}\n+\n+void\n+do_test1 (void)\n+{\n+  if (!val)\n+    eh1 (continuation, 100);\n+  fail ();\n+}\n+\n+void\n+do_test2 (void)\n+{\n+  if (!val)\n+    eh2 (continuation);\n+  fail ();\n+}\n+\n+int\n+main (void)\n+{\n+  if (test == 0)\n+    do_test1 ();\n+  if (test == 1)\n+    do_test2 ();\n+  if (failed || test != 2)\n+    exit (1);\n+  exit (0);\n+}"}]}