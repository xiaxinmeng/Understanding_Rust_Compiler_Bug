{"sha": "0fd1870171ae93d025808cd060ea6e9c47a31727", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZkMTg3MDE3MWFlOTNkMDI1ODA4Y2QwNjBlYTZlOWM0N2EzMTcyNw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2003-11-20T19:24:03Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2003-11-20T19:24:03Z"}, "message": "re PR libstdc++/11602 (codecvt<wchar_t, char, mbstate_t> is slow.)\n\n2003-11-20  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/11602\n\t* config/locale/gnu/codecvt_members.cc (codecvt::do_out):\n\tRewrite, using both wcsnrtombs and wcrtomb in a loop: the\n\tformer is very fast, but stops if encounters a NUL.\n\t* testsuite/performance/wchar_t_out.cc: New, from the PR.\n\nFrom-SVN: r73769", "tree": {"sha": "2adffb326dda57098d9a4127b8de1d2942935825", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2adffb326dda57098d9a4127b8de1d2942935825"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fd1870171ae93d025808cd060ea6e9c47a31727", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fd1870171ae93d025808cd060ea6e9c47a31727", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fd1870171ae93d025808cd060ea6e9c47a31727", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fd1870171ae93d025808cd060ea6e9c47a31727/comments", "author": null, "committer": null, "parents": [{"sha": "c5b2a8ae6ceefc7ee6810d29a9d84e32ec40b068", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5b2a8ae6ceefc7ee6810d29a9d84e32ec40b068", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5b2a8ae6ceefc7ee6810d29a9d84e32ec40b068"}], "stats": {"total": 187, "additions": 142, "deletions": 45}, "files": [{"sha": "fad159db410ca047d77220cdf933922fd7b2101e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd1870171ae93d025808cd060ea6e9c47a31727/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd1870171ae93d025808cd060ea6e9c47a31727/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0fd1870171ae93d025808cd060ea6e9c47a31727", "patch": "@@ -1,3 +1,11 @@\n+2003-11-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/11602\n+\t* config/locale/gnu/codecvt_members.cc (codecvt::do_out):\n+\tRewrite, using both wcsnrtombs and wcrtomb in a loop: the\n+\tformer is very fast, but stops if encounters a NUL.\n+\t* testsuite/performance/wchar_t_out.cc: New, from the PR.\n+\n 2003-11-19  Paolo Carlini  <pcarlini@suse.de>\n \n \t* config/locale/gnu/codecvt_members.cc (do_out): If"}, {"sha": "708941a9a35223f97db28ceb02d039fffe43609e", "filename": "libstdc++-v3/config/locale/gnu/codecvt_members.cc", "status": "modified", "additions": 50, "deletions": 45, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd1870171ae93d025808cd060ea6e9c47a31727/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fcodecvt_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd1870171ae93d025808cd060ea6e9c47a31727/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fcodecvt_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fcodecvt_members.cc?ref=0fd1870171ae93d025808cd060ea6e9c47a31727", "patch": "@@ -48,68 +48,73 @@ namespace std\n \t extern_type*& __to_next) const\n   {\n     result __ret = ok;\n-    // A temporary state must be used since the result of the last\n-    // conversion may be thrown away.\n-    state_type __tmp_state(__state);   \n+    state_type __tmp_state(__state);\n \n #if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n     __c_locale __old = __uselocale(_M_c_locale_codecvt);\n #endif\n \n-    // The conversion must be done by calling wcrtomb in a loop rather\n-    // than using wcsrtombs because wcsrtombs assumes that the input is\n-    // zero-terminated.\n-\n-    // Either we can upper bound the total number of external characters to\n-    // something smaller than __to_end - __to or the conversion must be done\n-    // using a temporary destination buffer since it is not possible to\n-    // pass the size of the buffer to wcrtomb\n-    if (MB_CUR_MAX * (__from_end - __from) - (__to_end - __to) <= 0)\n-      while (__from < __from_end)\n-\t{\n-\t  const size_t __conv = wcrtomb(__to, *__from, &__tmp_state);\n-\t  if (__conv == static_cast<size_t>(-1))\n-\t    {\n-\t      __ret = error;\n-\t      break;\n-\t    }\n-\t  __state = __tmp_state;\n-\t  __to += __conv;\n-\t  __from++;\n-\t}\n-    else\n+    // wcsnrtombs is *very* fast but stops if encounters NUL characters:\n+    // in case we fall back to wcrtomb and then continue, in a loop.\n+    // NB: wcsnrtombs is a GNU extension\n+    __from_next = __from;\n+    __to_next = __to;\n+    while (__from_next < __from_end && __to_next < __to_end\n+\t   && __ret == ok)\n       {\n-\textern_type __buf[MB_LEN_MAX];\n-\twhile (__from < __from_end && __to < __to_end)\n+\tconst intern_type* __from_chunk_end = wmemchr(__from_next, L'\\0',\n+\t\t\t\t\t\t      __from_end - __from_next);\n+\tif (!__from_chunk_end)\n+\t  __from_chunk_end = __from_end;\n+\n+\tconst intern_type* __tmp_from = __from_next;\n+\tconst size_t __conv = wcsnrtombs(__to_next, &__from_next,\n+\t\t\t\t\t __from_chunk_end - __from_next,\n+\t\t\t\t\t __to_end - __to_next, &__state);\n+\tif (__conv == static_cast<size_t>(-1))\n+\t  {\n+\t    // In case of error, in order to stop at the exact place we\n+\t    // have to start again from the beginning with a series of\n+\t    // wcrtomb.\n+\t    while (__tmp_from < __from_next)\n+\t      __to_next += wcrtomb(__to_next, *__tmp_from++, &__tmp_state);\n+\t    __state = __tmp_state;\t    \n+\t    __ret = error;\n+\t  }\n+\telse if (__from_next && __from_next < __from_chunk_end)\n+\t  {\n+\t    __to_next += __conv;\n+\t    __ret = partial;\n+\t  }\n+\telse\n \t  {\n-\t    const size_t __conv = wcrtomb(__buf, *__from, &__tmp_state);\n+\t    __from_next = __from_chunk_end;\n+\t    __to_next += __conv;\n+\t  }\n+\n+\tif (__from_next < __from_end && __ret == ok)\n+\t  {\n+\t    extern_type __buf[MB_LEN_MAX];\n+\t    __tmp_state = __state;\n+\t    const size_t __conv = wcrtomb(__buf, *__from_next, &__tmp_state);\n \t    if (__conv == static_cast<size_t>(-1))\n+\t      __ret = error;\n+\t    else if (__conv > static_cast<size_t>(__to_end - __to_next))\n+\t      __ret = partial;\n+\t    else\n \t      {\n-\t\t__ret = error;\n-\t\tbreak;\n-\t      }\n-\t    else if (__conv > static_cast<size_t>(__to_end - __to))\n-\t      {\n-\t\t__ret = partial;\n-\t\tbreak;\n+\t\tmemcpy(__to_next, __buf, __conv);\n+\t\t__state = __tmp_state;\n+\t\t__to_next += __conv;\n+\t\t++__from_next;\n \t      }\n-\t    \n-\t    memcpy(__to, __buf, __conv);\n-\t    __state = __tmp_state;\n-\t    __to += __conv;\n-\t    __from++;\n \t  }\n       }\n \n #if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n     __uselocale(__old);\n #endif\n \n-    if (__ret == ok && __from < __from_end)\n-      __ret = partial;\n-\n-    __from_next = __from;\n-    __to_next = __to;\n     return __ret; \n   }\n   "}, {"sha": "4e5106817d09cfd9c7c02bcaeb5324954aa1f4bd", "filename": "libstdc++-v3/testsuite/performance/wchar_t_out.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd1870171ae93d025808cd060ea6e9c47a31727/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fwchar_t_out.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd1870171ae93d025808cd060ea6e9c47a31727/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fwchar_t_out.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fwchar_t_out.cc?ref=0fd1870171ae93d025808cd060ea6e9c47a31727", "patch": "@@ -0,0 +1,84 @@\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cstdio>\n+#include <cstring>\n+#include <fstream>\n+#include <langinfo.h>\n+#include <iconv.h>\n+#include <testsuite_performance.h>\n+\n+// libstdc++/11602\n+int main(int argc, char** argv)\n+{\n+  using namespace std;\n+  using namespace __gnu_test;\n+\n+  time_counter time;\n+  resource_counter resource;\n+  const int iters = 300000;\n+\n+  wchar_t wbuf[1024];\n+  char cbuf[1024];\n+  \n+  wmemset(wbuf, L'a', 1024);\n+\n+  // C (iconv)\n+  iconv_t cd = iconv_open(nl_langinfo(CODESET), \"WCHAR_T\");\n+  start_counters(time, resource);\n+  for (int i = 0; i < iters; ++i)\n+    {\n+      size_t inbytesleft = 1024 * sizeof(wchar_t);\n+      size_t outbytesleft = 1024;\n+      char* in = reinterpret_cast<char*>(wbuf);\n+      char* out = cbuf;\n+      iconv(cd, &in, &inbytesleft, &out, &outbytesleft);\n+    }\n+  stop_counters(time, resource);\n+  iconv_close(cd);\n+  report_performance(__FILE__, \"C (iconv)\", time, resource);\n+  clear_counters(time, resource);\n+\n+  // C++ (codecvt)\n+  locale loc;\n+  const codecvt<wchar_t, char, mbstate_t>& cvt =\n+    use_facet<codecvt<wchar_t, char, mbstate_t> >(loc);\n+  mbstate_t state;\n+  memset(&state, 0, sizeof(state));\n+  start_counters(time, resource);\n+  for (int i = 0; i < iters; ++i)\n+    {\n+      const wchar_t* from_next;\n+      char* to_next;\n+      cvt.out(state, wbuf, wbuf + 1024, from_next,\n+\t      cbuf, cbuf + 1024, to_next);\n+    }\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"C++ (codecvt)\", time, resource);\n+\n+  return 0;\n+}"}]}