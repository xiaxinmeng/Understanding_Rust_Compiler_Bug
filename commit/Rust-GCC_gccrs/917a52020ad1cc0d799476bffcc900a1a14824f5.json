{"sha": "917a52020ad1cc0d799476bffcc900a1a14824f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE3YTUyMDIwYWQxY2MwZDc5OTQ3NmJmZmNjOTAwYTFhMTQ4MjRmNQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2012-05-18T12:02:54Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-05-18T12:02:54Z"}, "message": "tree-ssa-reassoc.c (bip_map): Remove decl.\n\n2012-05-18  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* tree-ssa-reassoc.c (bip_map): Remove decl.\n\t(completely_remove_stmt): Remove function.\n\t(remove_def_if_absorbed_call): Remove function.\n\t(remove_visited_stmt_chain): Remove __builtin_powi handling.\n\t(possibly_move_powi): Remove function.\n\t(rewrite_expr_tree): Remove calls to possibly_move_powi.\n\t(rewrite_expr_tree_parallel): Likewise.\n\t(attempt_builtin_powi): Build multiplies explicitly rather than\n\trelying on the ops vector and rank system.\n\t(transform_stmt_to_copy): New function.\n\t(transform_stmt_to_multiply): Likewise.\n\t(reassociate_bb): Handle leftover operations after __builtin_powi\n\toptimization; build a final multiply if necessary.\n\nFrom-SVN: r187652", "tree": {"sha": "e8aa98877561a85e4c17f8ef2fef82264eb52d91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8aa98877561a85e4c17f8ef2fef82264eb52d91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/917a52020ad1cc0d799476bffcc900a1a14824f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/917a52020ad1cc0d799476bffcc900a1a14824f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/917a52020ad1cc0d799476bffcc900a1a14824f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/917a52020ad1cc0d799476bffcc900a1a14824f5/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "387df8716035d8a7e1f8a1fb74804ee39e16ed3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/387df8716035d8a7e1f8a1fb74804ee39e16ed3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/387df8716035d8a7e1f8a1fb74804ee39e16ed3f"}], "stats": {"total": 298, "additions": 120, "deletions": 178}, "files": [{"sha": "0d91248aedd5b523647bfd8eed9249f8586197fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917a52020ad1cc0d799476bffcc900a1a14824f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917a52020ad1cc0d799476bffcc900a1a14824f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=917a52020ad1cc0d799476bffcc900a1a14824f5", "patch": "@@ -1,3 +1,19 @@\n+2012-05-18  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* tree-ssa-reassoc.c (bip_map): Remove decl.\n+\t(completely_remove_stmt): Remove function.\n+\t(remove_def_if_absorbed_call): Remove function.\n+\t(remove_visited_stmt_chain): Remove __builtin_powi handling.\n+\t(possibly_move_powi): Remove function.\n+\t(rewrite_expr_tree): Remove calls to possibly_move_powi.\n+\t(rewrite_expr_tree_parallel): Likewise.\n+\t(attempt_builtin_powi): Build multiplies explicitly rather than\n+\trelying on the ops vector and rank system.\n+\t(transform_stmt_to_copy): New function.\n+\t(transform_stmt_to_multiply): Likewise.\n+\t(reassociate_bb): Handle leftover operations after __builtin_powi\n+\toptimization; build a final multiply if necessary.\n+\n 2012-05-18  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraphunit.c (varpool_finalize_decl): Allow external decls."}, {"sha": "9c363931b7662995de0df331f03a987acbb08f24", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 104, "deletions": 178, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917a52020ad1cc0d799476bffcc900a1a14824f5/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917a52020ad1cc0d799476bffcc900a1a14824f5/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=917a52020ad1cc0d799476bffcc900a1a14824f5", "patch": "@@ -200,10 +200,6 @@ static long *bb_rank;\n /* Operand->rank hashtable.  */\n static struct pointer_map_t *operand_rank;\n \n-/* Map from inserted __builtin_powi calls to multiply chains that\n-   feed them.  */\n-static struct pointer_map_t *bip_map;\n-\n /* Forward decls.  */\n static long get_rank (tree);\n \n@@ -2184,32 +2180,6 @@ is_phi_for_stmt (gimple stmt, tree operand)\n   return false;\n }\n \n-/* Remove STMT, unlink its virtual defs, and release its SSA defs.  */\n-\n-static inline void\n-completely_remove_stmt (gimple stmt)\n-{\n-  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n-  gsi_remove (&gsi, true);\n-  unlink_stmt_vdef (stmt);\n-  release_defs (stmt);\n-}\n-\n-/* If OP is defined by a builtin call that has been absorbed by\n-   reassociation, remove its defining statement completely.  */\n-\n-static inline void\n-remove_def_if_absorbed_call (tree op)\n-{\n-  gimple stmt;\n-\n-  if (TREE_CODE (op) == SSA_NAME\n-      && has_zero_uses (op)\n-      && is_gimple_call ((stmt = SSA_NAME_DEF_STMT (op)))\n-      && gimple_visited_p (stmt))\n-    completely_remove_stmt (stmt);\n-}\n-\n /* Remove def stmt of VAR if VAR has zero uses and recurse\n    on rhs1 operand if so.  */\n \n@@ -2218,7 +2188,6 @@ remove_visited_stmt_chain (tree var)\n {\n   gimple stmt;\n   gimple_stmt_iterator gsi;\n-  tree var2;\n \n   while (1)\n     {\n@@ -2228,95 +2197,15 @@ remove_visited_stmt_chain (tree var)\n       if (is_gimple_assign (stmt) && gimple_visited_p (stmt))\n \t{\n \t  var = gimple_assign_rhs1 (stmt);\n-\t  var2 = gimple_assign_rhs2 (stmt);\n \t  gsi = gsi_for_stmt (stmt);\n \t  gsi_remove (&gsi, true);\n \t  release_defs (stmt);\n-\t  /* A multiply whose operands are both fed by builtin pow/powi\n-\t     calls must check whether to remove rhs2 as well.  */\n-\t  remove_def_if_absorbed_call (var2);\n-\t}\n-      else if (is_gimple_call (stmt) && gimple_visited_p (stmt))\n-\t{\n-\t  completely_remove_stmt (stmt);\n-\t  return;\n \t}\n       else\n \treturn;\n     }\n }\n \n-/* If OP is an SSA name, find its definition and determine whether it\n-   is a call to __builtin_powi.  If so, move the definition prior to\n-   STMT.  Only do this during early reassociation.  */\n-\n-static void\n-possibly_move_powi (gimple stmt, tree op)\n-{\n-  gimple stmt2, *mpy;\n-  tree fndecl;\n-  gimple_stmt_iterator gsi1, gsi2;\n-\n-  if (!first_pass_instance\n-      || !flag_unsafe_math_optimizations\n-      || TREE_CODE (op) != SSA_NAME)\n-    return;\n-  \n-  stmt2 = SSA_NAME_DEF_STMT (op);\n-\n-  if (!is_gimple_call (stmt2)\n-      || !has_single_use (gimple_call_lhs (stmt2)))\n-    return;\n-\n-  fndecl = gimple_call_fndecl (stmt2);\n-\n-  if (!fndecl\n-      || DECL_BUILT_IN_CLASS (fndecl) != BUILT_IN_NORMAL)\n-    return;\n-\n-  switch (DECL_FUNCTION_CODE (fndecl))\n-    {\n-    CASE_FLT_FN (BUILT_IN_POWI):\n-      break;\n-    default:\n-      return;\n-    }\n-\n-  /* Move the __builtin_powi.  */\n-  gsi1 = gsi_for_stmt (stmt);\n-  gsi2 = gsi_for_stmt (stmt2);\n-  gsi_move_before (&gsi2, &gsi1);\n-\n-  /* See if there are multiplies feeding the __builtin_powi base\n-     argument that must also be moved.  */\n-  while ((mpy = (gimple *) pointer_map_contains (bip_map, stmt2)) != NULL)\n-    {\n-      /* If we've already moved this statement, we're done.  This is\n-         identified by a NULL entry for the statement in bip_map.  */\n-      gimple *next = (gimple *) pointer_map_contains (bip_map, *mpy);\n-      if (next && !*next)\n-\treturn;\n-\n-      stmt = stmt2;\n-      stmt2 = *mpy;\n-      gsi1 = gsi_for_stmt (stmt);\n-      gsi2 = gsi_for_stmt (stmt2);\n-      gsi_move_before (&gsi2, &gsi1);\n-\n-      /* The moved multiply may be DAG'd from multiple calls if it\n-\t was the result of a cached multiply.  Only move it once.\n-\t Rank order ensures we move it to the right place the first\n-\t time.  */\n-      if (next)\n-\t*next = NULL;\n-      else\n-\t{\n-\t  next = (gimple *) pointer_map_insert (bip_map, *mpy);\n-\t  *next = NULL;\n-\t}\n-    }\n-}\n-\n /* This function checks three consequtive operands in\n    passed operands vector OPS starting from OPINDEX and\n    swaps two operands if it is profitable for binary operation\n@@ -2421,9 +2310,6 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n \t      fprintf (dump_file, \" into \");\n \t      print_gimple_stmt (dump_file, stmt, 0, 0);\n \t    }\n-\n-\t  possibly_move_powi (stmt, oe1->op);\n-\t  possibly_move_powi (stmt, oe2->op);\n \t}\n       return;\n     }\n@@ -2469,8 +2355,6 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n \t  fprintf (dump_file, \" into \");\n \t  print_gimple_stmt (dump_file, stmt, 0, 0);\n \t}\n-\n-      possibly_move_powi (stmt, oe->op);\n     }\n   /* Recurse on the LHS of the binary operator, which is guaranteed to\n      be the non-leaf side.  */\n@@ -2644,9 +2528,6 @@ rewrite_expr_tree_parallel (gimple stmt, int width,\n \t  fprintf (dump_file, \" into \");\n \t  print_gimple_stmt (dump_file, stmts[i], 0, 0);\n \t}\n-\n-      possibly_move_powi (stmts[i], op1);\n-      possibly_move_powi (stmts[i], op2);\n     }\n \n   remove_visited_stmt_chain (last_rhs1);\n@@ -3222,11 +3103,10 @@ get_reassoc_pow_ssa_name (tree *target, tree type)\n \n /* Look for repeated operands in OPS in the multiply tree rooted at\n    STMT.  Replace them with an optimal sequence of multiplies and powi\n-   builtin calls, and remove the used operands from OPS.  Push new\n-   SSA names onto OPS that represent the introduced multiplies and\n-   builtin calls.  */\n+   builtin calls, and remove the used operands from OPS.  Return an\n+   SSA name representing the value of the replacement sequence.  */\n \n-static void\n+static tree\n attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops,\n \t\t      tree *target)\n {\n@@ -3235,6 +3115,7 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops,\n   operand_entry_t oe;\n   repeat_factor_t rf1, rf2;\n   repeat_factor rfnew;\n+  tree result = NULL_TREE;\n   tree target_ssa, iter_result;\n   tree type = TREE_TYPE (gimple_get_lhs (stmt));\n   tree powi_fndecl = mathfn_built_in (type, BUILT_IN_POWI);\n@@ -3244,7 +3125,7 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops,\n   /* Nothing to do if BUILT_IN_POWI doesn't exist for this type and\n      target.  */\n   if (!powi_fndecl)\n-    return;\n+    return NULL_TREE;\n \n   /* Allocate the repeated factor vector.  */\n   repeat_factor_vec = VEC_alloc (repeat_factor, heap, 10);\n@@ -3315,7 +3196,6 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops,\n   while (true)\n     {\n       HOST_WIDE_INT power;\n-      gimple last_mul = NULL;\n \n       /* First look for the largest cached product of factors from\n \t preceding iterations.  If found, create a builtin_powi for\n@@ -3353,25 +3233,14 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops,\n \t    }\n \t  else\n \t    {\n-\t      gimple *value;\n-\n \t      iter_result = get_reassoc_pow_ssa_name (target, type);\n \t      pow_stmt = gimple_build_call (powi_fndecl, 2, rf1->repr, \n \t\t\t\t\t    build_int_cst (integer_type_node,\n \t\t\t\t\t\t\t   power));\n \t      gimple_call_set_lhs (pow_stmt, iter_result);\n \t      gimple_set_location (pow_stmt, gimple_location (stmt));\n-\t      /* Temporarily place the call; we will move it and its\n-\t\t feeding multiplies to the correct place during\n-\t\t rewrite_expr.  */\n \t      gsi_insert_before (&gsi, pow_stmt, GSI_SAME_STMT);\n \n-\t      if (!operand_equal_p (rf1->repr, rf1->factor, 0))\n-\t\t{\n-\t\t  value = (gimple *) pointer_map_insert (bip_map, pow_stmt);\n-\t\t  *value = SSA_NAME_DEF_STMT (rf1->repr);\n-\t\t}\n-\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n \t\t  unsigned elt;\n@@ -3457,15 +3326,6 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops,\n \t\t  gsi_insert_before (&gsi, mul_stmt, GSI_SAME_STMT);\n \t\t  rf1->repr = target_ssa;\n \n-\t\t  /* Chain multiplies together for later movement.  */\n-\t\t  if (last_mul)\n-\t\t    {\n-\t\t      gimple *value\n-\t\t\t= (gimple *) pointer_map_insert (bip_map, mul_stmt);\n-\t\t      *value = last_mul;\n-\t\t    }\n-\t\t  last_mul = mul_stmt;\n-\n \t\t  /* Don't reprocess the multiply we just introduced.  */\n \t\t  gimple_set_visited (mul_stmt, true);\n \t\t}\n@@ -3481,19 +3341,22 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops,\n \t  gimple_call_set_lhs (pow_stmt, iter_result);\n \t  gimple_set_location (pow_stmt, gimple_location (stmt));\n \t  gsi_insert_before (&gsi, pow_stmt, GSI_SAME_STMT);\n-\n-\t  /* If we inserted a chain of multiplies before the pow_stmt,\n-\t     record that fact so we can move it later when we move the\n-\t     pow_stmt.  */\n-\t  if (last_mul)\n-\t    {\n-\t      gimple *value = (gimple *) pointer_map_insert (bip_map, pow_stmt);\n-\t      *value = last_mul;\n-\t    }\n \t}\n \n-      /* Append the result of this iteration to the ops vector.  */\n-      add_to_ops_vec (ops, iter_result);\n+      /* If we previously formed at least one other builtin_powi call,\n+\t form the product of this one and those others.  */\n+      if (result)\n+\t{\n+\t  tree new_result = get_reassoc_pow_ssa_name (target, type);\n+\t  mul_stmt = gimple_build_assign_with_ops (MULT_EXPR, new_result,\n+\t\t\t\t\t\t   result, iter_result);\n+\t  gimple_set_location (mul_stmt, gimple_location (stmt));\n+\t  gsi_insert_before (&gsi, mul_stmt, GSI_SAME_STMT);\n+\t  gimple_set_visited (mul_stmt, true);\n+\t  result = new_result;\n+\t}\n+      else\n+\tresult = iter_result;\n \n       /* Decrement the occurrence count of each element in the product\n \t by the count found above, and remove this many copies of each\n@@ -3534,6 +3397,59 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops,\n      clean up.  */\n   VEC_qsort (operand_entry_t, *ops, sort_by_operand_rank);\n   VEC_free (repeat_factor, heap, repeat_factor_vec);\n+\n+  /* Return the final product computed herein.  Note that there may\n+     still be some elements with single occurrence count left in OPS;\n+     those will be handled by the normal reassociation logic.  */\n+  return result;\n+}\n+\n+/* Transform STMT at *GSI into a copy by replacing its rhs with NEW_RHS.  */\n+\n+static void\n+transform_stmt_to_copy (gimple_stmt_iterator *gsi, gimple stmt, tree new_rhs)\n+{\n+  tree rhs1;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Transforming \");\n+      print_gimple_stmt (dump_file, stmt, 0, 0);\n+    }\n+\n+  rhs1 = gimple_assign_rhs1 (stmt);\n+  gimple_assign_set_rhs_from_tree (gsi, new_rhs);\n+  update_stmt (stmt);\n+  remove_visited_stmt_chain (rhs1);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \" into \");\n+      print_gimple_stmt (dump_file, stmt, 0, 0);\n+    }\n+}\n+\n+/* Transform STMT at *GSI into a multiply of RHS1 and RHS2.  */\n+\n+static void\n+transform_stmt_to_multiply (gimple_stmt_iterator *gsi, gimple stmt,\n+\t\t\t    tree rhs1, tree rhs2)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Transforming \");\n+      print_gimple_stmt (dump_file, stmt, 0, 0);\n+    }\n+\n+  gimple_assign_set_rhs_with_ops_1 (gsi, MULT_EXPR, rhs1, rhs2, NULL_TREE);\n+  update_stmt (gsi_stmt (*gsi));\n+  remove_visited_stmt_chain (rhs1);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \" into \");\n+      print_gimple_stmt (dump_file, stmt, 0, 0);\n+    }\n }\n \n /* Reassociate expressions in basic block BB and its post-dominator as\n@@ -3606,7 +3522,7 @@ reassociate_bb (basic_block bb)\n \t  if (associative_tree_code (rhs_code))\n \t    {\n \t      VEC(operand_entry_t, heap) *ops = NULL;\n-\t      bip_map = pointer_map_create ();\n+\t      tree powi_result = NULL_TREE;\n \n \t      /* There may be no immediate uses left by the time we\n \t\t get here because we may have eliminated them all.  */\n@@ -3630,28 +3546,21 @@ reassociate_bb (basic_block bb)\n \t      if (first_pass_instance\n \t\t  && rhs_code == MULT_EXPR\n \t\t  && flag_unsafe_math_optimizations)\n-\t\tattempt_builtin_powi (stmt, &ops, &target);\n+\t\tpowi_result = attempt_builtin_powi (stmt, &ops, &target);\n \n-\t      if (VEC_length (operand_entry_t, ops) == 1)\n+\t      /* If the operand vector is now empty, all operands were \n+\t\t consumed by the __builtin_powi optimization.  */\n+\t      if (VEC_length (operand_entry_t, ops) == 0)\n+\t\ttransform_stmt_to_copy (&gsi, stmt, powi_result);\n+\t      else if (VEC_length (operand_entry_t, ops) == 1)\n \t\t{\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    {\n-\t\t      fprintf (dump_file, \"Transforming \");\n-\t\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t\t    }\n-\n-\t\t  rhs1 = gimple_assign_rhs1 (stmt);\n-\t\t  gimple_assign_set_rhs_from_tree (&gsi,\n-\t\t\t\t\t\t   VEC_last (operand_entry_t,\n-\t\t\t\t\t\t\t     ops)->op);\n-\t\t  update_stmt (stmt);\n-\t\t  remove_visited_stmt_chain (rhs1);\n-\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    {\n-\t\t      fprintf (dump_file, \" into \");\n-\t\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t\t    }\n+\t\t  tree last_op = VEC_last (operand_entry_t, ops)->op;\n+\t\t  \n+\t\t  if (powi_result)\n+\t\t    transform_stmt_to_multiply (&gsi, stmt, last_op,\n+\t\t\t\t\t\tpowi_result);\n+\t\t  else\n+\t\t    transform_stmt_to_copy (&gsi, stmt, last_op);\n \t\t}\n \t      else\n \t\t{\n@@ -3668,10 +3577,27 @@ reassociate_bb (basic_block bb)\n \t\t    rewrite_expr_tree_parallel (stmt, width, ops);\n \t\t  else\n \t\t    rewrite_expr_tree (stmt, 0, ops, false);\n+\n+\t\t  /* If we combined some repeated factors into a \n+\t\t     __builtin_powi call, multiply that result by the\n+\t\t     reassociated operands.  */\n+\t\t  if (powi_result)\n+\t\t    {\n+\t\t      gimple mul_stmt;\n+\t\t      tree type = TREE_TYPE (gimple_get_lhs (stmt));\n+\t\t      tree target_ssa = get_reassoc_pow_ssa_name (&target,\n+\t\t\t\t\t\t\t\t  type);\n+\t\t      gimple_set_lhs (stmt, target_ssa);\n+\t\t      update_stmt (stmt);\n+\t\t      mul_stmt = gimple_build_assign_with_ops (MULT_EXPR, lhs,\n+\t\t\t\t\t\t\t       powi_result,\n+\t\t\t\t\t\t\t       target_ssa);\n+\t\t      gimple_set_location (mul_stmt, gimple_location (stmt));\n+\t\t      gsi_insert_after (&gsi, mul_stmt, GSI_NEW_STMT);\n+\t\t    }\n \t\t}\n \n \t      VEC_free (operand_entry_t, heap, ops);\n-\t      pointer_map_destroy (bip_map);\n \t    }\n \t}\n     }"}]}