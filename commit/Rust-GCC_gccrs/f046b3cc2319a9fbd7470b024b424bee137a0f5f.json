{"sha": "f046b3cc2319a9fbd7470b024b424bee137a0f5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA0NmIzY2MyMzE5YTlmYmQ3NDcwYjAyNGI0MjRiZWUxMzdhMGY1Zg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-04-14T20:45:20Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-04-14T20:45:20Z"}, "message": "calls.c (emit_library_call): Handle saving of stack slots when ACCUMULATE_OUTGOING_ARGS is defined.\n\n        * calls.c (emit_library_call): Handle saving of stack slots when\n        ACCUMULATE_OUTGOING_ARGS is defined.\n        (emit_library_call_value): Likewise.\n\nFrom-SVN: r13902", "tree": {"sha": "c159ee4e6aabc6e4912f87a623248719024069a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c159ee4e6aabc6e4912f87a623248719024069a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f046b3cc2319a9fbd7470b024b424bee137a0f5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f046b3cc2319a9fbd7470b024b424bee137a0f5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f046b3cc2319a9fbd7470b024b424bee137a0f5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f046b3cc2319a9fbd7470b024b424bee137a0f5f/comments", "author": null, "committer": null, "parents": [{"sha": "07e6159a93ea82838fe788c50485e095263b2ab4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07e6159a93ea82838fe788c50485e095263b2ab4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07e6159a93ea82838fe788c50485e095263b2ab4"}], "stats": {"total": 500, "additions": 460, "deletions": 40}, "files": [{"sha": "25fc40e8fc4f916f1736af97af451c1f36654c02", "filename": "gcc/calls.c", "status": "modified", "additions": 460, "deletions": 40, "changes": 500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f046b3cc2319a9fbd7470b024b424bee137a0f5f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f046b3cc2319a9fbd7470b024b424bee137a0f5f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=f046b3cc2319a9fbd7470b024b424bee137a0f5f", "patch": "@@ -2276,10 +2276,32 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n   rtx argblock = 0;\n   CUMULATIVE_ARGS args_so_far;\n   struct arg { rtx value; enum machine_mode mode; rtx reg; int partial;\n-\t       struct args_size offset; struct args_size size; };\n+\t       struct args_size offset; struct args_size size; rtx save_area; };\n   struct arg *argvec;\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n   rtx call_fusage = 0;\n+  /* Size of the stack reserved for parameter registers.  */\n+  int reg_parm_stack_space = 0;\n+#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n+  /* Define the boundary of the register parm stack space that needs to be\n+     save, if any.  */\n+  int low_to_save = -1, high_to_save;\n+  rtx save_area = 0;            /* Place that it is saved */\n+#endif\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+  int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n+  char *initial_stack_usage_map = stack_usage_map;\n+  int needed;\n+#endif\n+\n+#ifdef REG_PARM_STACK_SPACE\n+#ifdef MAYBE_REG_PARM_STACK_SPACE\n+  reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n+#else\n+  reg_parm_stack_space = REG_PARM_STACK_SPACE (fndecl);\n+#endif\n+#endif\n \n   VA_START (p, nargs);\n \n@@ -2300,6 +2322,8 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n      library functions shouldn't have many args.  */\n \n   argvec = (struct arg *) alloca (nargs * sizeof (struct arg));\n+  bzero ((char *) argvec, nargs * sizeof (struct arg));\n+\n \n   INIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE, fun, 0);\n \n@@ -2379,23 +2403,15 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \t  )\n \targs_size.constant += argvec[count].size.constant;\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-      /* If this arg is actually passed on the stack, it might be\n-\t clobbering something we already put there (this library call might\n-\t be inside the evaluation of an argument to a function whose call\n-\t requires the stack).  This will only occur when the library call\n-\t has sufficient args to run out of argument registers.  Abort in\n-\t this case; if this ever occurs, code must be added to save and\n-\t restore the arg slot.  */\n-\n-      if (argvec[count].reg == 0 || argvec[count].partial != 0)\n-\tabort ();\n-#endif\n-\n       FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree) 0, 1);\n     }\n   va_end (p);\n \n+#ifdef FINAL_REG_PARM_STACK_SPACE\n+  reg_parm_stack_space = FINAL_REG_PARM_STACK_SPACE (args_size.constant,\n+\t\t\t\t\t\t     args_size.var);\n+#endif\n+      \n   /* If this machine requires an external definition for library\n      functions, write one out.  */\n   assemble_external_libcall (fun);\n@@ -2408,22 +2424,65 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \n #ifdef REG_PARM_STACK_SPACE\n   args_size.constant = MAX (args_size.constant,\n-\t\t\t    REG_PARM_STACK_SPACE (NULL_TREE));\n+\t\t\t    reg_parm_stack_space);\n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n-  args_size.constant -= REG_PARM_STACK_SPACE (NULL_TREE);\n+  args_size.constant -= reg_parm_stack_space;\n #endif\n #endif\n \n   if (args_size.constant > current_function_outgoing_args_size)\n     current_function_outgoing_args_size = args_size.constant;\n \n #ifdef ACCUMULATE_OUTGOING_ARGS\n-  args_size.constant = 0;\n+  /* Since the stack pointer will never be pushed, it is possible for\n+     the evaluation of a parm to clobber something we have already\n+     written to the stack.  Since most function calls on RISC machines\n+     do not use the stack, this is uncommon, but must work correctly.\n+\n+     Therefore, we save any area of the stack that was already written\n+     and that we are using.  Here we set up to do this by making a new\n+     stack usage map from the old one.\n+\n+     Another approach might be to try to reorder the argument\n+     evaluations to avoid this conflicting stack usage.  */\n+\n+  needed = args_size.constant;\n+#if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n+  /* Since we will be writing into the entire argument area, the\n+     map must be allocated for its entire size, not just the part that\n+     is the responsibility of the caller.  */\n+  needed += reg_parm_stack_space;\n+#endif\n+\n+#ifdef ARGS_GROW_DOWNWARD\n+  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n+\t\t\t\t     needed + 1);\n+#else\n+  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n+\t\t\t\t     needed);\n #endif\n+  stack_usage_map = (char *) alloca (highest_outgoing_arg_in_use);\n+\n+  if (initial_highest_arg_in_use)\n+    bcopy (initial_stack_usage_map, stack_usage_map,\n+\t   initial_highest_arg_in_use);\n+\n+  if (initial_highest_arg_in_use != highest_outgoing_arg_in_use)\n+    bzero (&stack_usage_map[initial_highest_arg_in_use],\n+\t   highest_outgoing_arg_in_use - initial_highest_arg_in_use);\n+  needed = 0;\n \n+  /* The address of the outgoing argument list must not be copied to a\n+     register here, because argblock would be left pointing to the\n+     wrong place after the call to allocate_dynamic_stack_space below.\n+     */\n+\n+  argblock = virtual_outgoing_args_rtx;\n+#else /* not ACCUMULATE_OUTGOING_ARGS */\n #ifndef PUSH_ROUNDING\n   argblock = push_block (GEN_INT (args_size.constant), 0, 0);\n #endif\n+#endif\n \n #ifdef PUSH_ARGS_REVERSED\n #ifdef STACK_BOUNDARY\n@@ -2443,6 +2502,68 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n   argnum = 0;\n #endif\n \n+#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n+  /* The argument list is the property of the called routine and it\n+     may clobber it.  If the fixed area has been used for previous\n+     parameters, we must save and restore it.\n+\n+     Here we compute the boundary of the that needs to be saved, if any.  */\n+\n+#ifdef ARGS_GROW_DOWNWARD\n+  for (count = 0; count < reg_parm_stack_space + 1; count++)\n+#else\n+  for (count = 0; count < reg_parm_stack_space; count++)\n+#endif\n+    {\n+      if (count >=  highest_outgoing_arg_in_use\n+\t  || stack_usage_map[count] == 0)\n+\tcontinue;\n+\n+      if (low_to_save == -1)\n+\tlow_to_save = count;\n+\n+      high_to_save = count;\n+    }\n+\n+  if (low_to_save >= 0)\n+    {\n+      int num_to_save = high_to_save - low_to_save + 1;\n+      enum machine_mode save_mode\n+\t= mode_for_size (num_to_save * BITS_PER_UNIT, MODE_INT, 1);\n+      rtx stack_area;\n+\n+      /* If we don't have the required alignment, must do this in BLKmode.  */\n+      if ((low_to_save & (MIN (GET_MODE_SIZE (save_mode),\n+\t\t\t       BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n+\tsave_mode = BLKmode;\n+\n+      stack_area = gen_rtx (MEM, save_mode,\n+\t\t\t    memory_address (save_mode,\n+\t\t\t\t\t    \n+#ifdef ARGS_GROW_DOWNWARD\n+\t\t\t\t\t    plus_constant (argblock,\n+\t\t\t\t\t\t\t   - high_to_save)\n+#else\n+\t\t\t\t\t    plus_constant (argblock,\n+\t\t\t\t\t\t\t   low_to_save)\n+#endif\n+\t\t\t\t\t    ));\n+      if (save_mode == BLKmode)\n+\t{\n+\t  save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n+\t  MEM_IN_STRUCT_P (save_area) = 0;\n+\t  emit_block_move (validize_mem (save_area), stack_area,\n+\t\t\t   GEN_INT (num_to_save),\n+\t\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n+\t}\n+      else\n+\t{\n+\t  save_area = gen_reg_rtx (save_mode);\n+\t  emit_move_insn (save_area, stack_area);\n+\t}\n+    }\n+#endif\n+\t  \n   /* Push the args that need to be pushed.  */\n \n   for (count = 0; count < nargs; count++, argnum += inc)\n@@ -2451,11 +2572,59 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n       register rtx val = argvec[argnum].value;\n       rtx reg = argvec[argnum].reg;\n       int partial = argvec[argnum].partial;\n+      int lower_bound, upper_bound, i;\n \n       if (! (reg != 0 && partial == 0))\n-\temit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n-\t\t\targblock, GEN_INT (argvec[count].offset.constant));\n-      NO_DEFER_POP;\n+\t{\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+\t  /* If this is being stored into a pre-allocated, fixed-size, stack\n+\t     area, save any previous data at that location.  */\n+\n+#ifdef ARGS_GROW_DOWNWARD\n+\t  /* stack_slot is negative, but we want to index stack_usage_map\n+\t     with positive values.  */\n+\t  upper_bound = -argvec[count].offset.constant + 1;\n+\t  lower_bound = upper_bound - argvec[count].size.constant;\n+#else\n+\t  lower_bound = argvec[count].offset.constant;\n+\t  upper_bound = lower_bound + argvec[count].size.constant;\n+#endif\n+\n+\t  for (i = lower_bound; i < upper_bound; i++)\n+\t    if (stack_usage_map[i]\n+#ifdef REG_PARM_STACK_SPACE\n+\t\t/* Don't store things in the fixed argument area at this point;\n+\t\t   it has already been saved.  */\n+\t\t&& i > reg_parm_stack_space\n+#endif\n+\t\t)\n+\t      break;\n+\n+\t  if (i != upper_bound)\n+\t    {\n+\t      /* We need to make a save area.  See what mode we can make it.  */\n+\t      enum machine_mode save_mode\n+\t\t= mode_for_size (argvec[count].size.constant * BITS_PER_UNIT,\n+\t\t\t\t MODE_INT, 1);\n+\t      rtx stack_area\n+\t\t= gen_rtx (MEM, save_mode,\n+\t\t\t   memory_address (save_mode, plus_constant (argblock,\n+\t\t\t\t\t   argvec[count].offset.constant)));\n+\t      argvec[count].save_area = gen_reg_rtx (save_mode);\n+\t      emit_move_insn (argvec[count].save_area, stack_area);\n+\t    }\n+#endif\n+\t  emit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n+\t\t\t  argblock, GEN_INT (argvec[count].offset.constant));\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+\t  /* Now mark the segment we just used.  */\n+\t  for (i = lower_bound; i < upper_bound; i++)\n+\t    stack_usage_map[i] = 1;\n+#endif\n+\n+\t  NO_DEFER_POP;\n+\t}\n     }\n \n #ifndef PUSH_ARGS_REVERSED\n@@ -2524,6 +2693,48 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \n   /* Now restore inhibit_defer_pop to its actual original value.  */\n   OK_DEFER_POP;\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+#ifdef REG_PARM_STACK_SPACE\n+      if (save_area)\n+\t{\n+\t  enum machine_mode save_mode = GET_MODE (save_area);\n+\t  rtx stack_area\n+\t    = gen_rtx (MEM, save_mode,\n+\t\t       memory_address (save_mode,\n+#ifdef ARGS_GROW_DOWNWARD\n+\t\t\t\t       plus_constant (argblock, - high_to_save)\n+#else\n+\t\t\t\t       plus_constant (argblock, low_to_save)\n+#endif\n+\t\t\t\t       ));\n+\n+\t  if (save_mode != BLKmode)\n+\t    emit_move_insn (stack_area, save_area);\n+\t  else\n+\t    emit_block_move (stack_area, validize_mem (save_area),\n+\t\t\t     GEN_INT (high_to_save - low_to_save + 1),\n+\t\t\t     PARM_BOUNDARY / BITS_PER_UNIT);\n+\t}\n+#endif\n+\t  \n+  /* If we saved any argument areas, restore them.  */\n+  for (count = 0; count < nargs; count++)\n+    if (argvec[count].save_area)\n+      {\n+\tenum machine_mode save_mode = GET_MODE (argvec[count].save_area);\n+\trtx stack_area\n+\t  = gen_rtx (MEM, save_mode,\n+\t\t     memory_address (save_mode, plus_constant (argblock,\n+\t\t\t\t     argvec[count].offset.constant)));\n+\n+\temit_move_insn (stack_area, argvec[count].save_area);\n+      }\n+\n+  highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n+  stack_usage_map = initial_stack_usage_map;\n+#endif\n+\n }\n \f\n /* Like emit_library_call except that an extra argument, VALUE,\n@@ -2557,14 +2768,37 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n   rtx argblock = 0;\n   CUMULATIVE_ARGS args_so_far;\n   struct arg { rtx value; enum machine_mode mode; rtx reg; int partial;\n-\t       struct args_size offset; struct args_size size; };\n+\t       struct args_size offset; struct args_size size; rtx save_area; };\n   struct arg *argvec;\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n   rtx call_fusage = 0;\n+  /* Size of the stack reserved for parameter registers.  */\n+  int reg_parm_stack_space = 0;\n   rtx mem_value = 0;\n   int pcc_struct_value = 0;\n   int struct_value_size = 0;\n   int is_const;\n+  int needed;\n+\n+#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n+  /* Define the boundary of the register parm stack space that needs to be\n+     save, if any.  */\n+  int low_to_save = -1, high_to_save;\n+  rtx save_area = 0;            /* Place that it is saved */\n+#endif\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+  int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n+  char *initial_stack_usage_map = stack_usage_map;\n+#endif\n+\n+#ifdef REG_PARM_STACK_SPACE\n+#ifdef MAYBE_REG_PARM_STACK_SPACE\n+  reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n+#else\n+  reg_parm_stack_space = REG_PARM_STACK_SPACE (fndecl);\n+#endif\n+#endif\n \n   VA_START (p, nargs);\n \n@@ -2613,6 +2847,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n      library functions shouldn't have many args.  */\n \n   argvec = (struct arg *) alloca ((nargs + 1) * sizeof (struct arg));\n+  bzero ((char *) argvec, nargs * sizeof (struct arg));\n \n   INIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE, fun, 0);\n \n@@ -2734,23 +2969,14 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \t  )\n \targs_size.constant += argvec[count].size.constant;\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-      /* If this arg is actually passed on the stack, it might be\n-\t clobbering something we already put there (this library call might\n-\t be inside the evaluation of an argument to a function whose call\n-\t requires the stack).  This will only occur when the library call\n-\t has sufficient args to run out of argument registers.  Abort in\n-\t this case; if this ever occurs, code must be added to save and\n-\t restore the arg slot.  */\n-\n-      if (argvec[count].reg == 0 || argvec[count].partial != 0)\n-\tabort ();\n-#endif\n-\n       FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree) 0, 1);\n     }\n   va_end (p);\n \n+#ifdef FINAL_REG_PARM_STACK_SPACE\n+  reg_parm_stack_space = FINAL_REG_PARM_STACK_SPACE (args_size.constant,\n+\t\t\t\t\t\t     args_size.var);\n+#endif\n   /* If this machine requires an external definition for library\n      functions, write one out.  */\n   assemble_external_libcall (fun);\n@@ -2763,22 +2989,65 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \n #ifdef REG_PARM_STACK_SPACE\n   args_size.constant = MAX (args_size.constant,\n-\t\t\t    REG_PARM_STACK_SPACE (NULL_TREE));\n+\t\t\t    reg_parm_stack_space);\n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n-  args_size.constant -= REG_PARM_STACK_SPACE (NULL_TREE);\n+  args_size.constant -= reg_parm_stack_space);\n #endif\n #endif\n \n   if (args_size.constant > current_function_outgoing_args_size)\n     current_function_outgoing_args_size = args_size.constant;\n \n #ifdef ACCUMULATE_OUTGOING_ARGS\n-  args_size.constant = 0;\n+  /* Since the stack pointer will never be pushed, it is possible for\n+     the evaluation of a parm to clobber something we have already\n+     written to the stack.  Since most function calls on RISC machines\n+     do not use the stack, this is uncommon, but must work correctly.\n+\n+     Therefore, we save any area of the stack that was already written\n+     and that we are using.  Here we set up to do this by making a new\n+     stack usage map from the old one.\n+\n+     Another approach might be to try to reorder the argument\n+     evaluations to avoid this conflicting stack usage.  */\n+\n+  needed = args_size.constant;\n+#if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n+  /* Since we will be writing into the entire argument area, the\n+     map must be allocated for its entire size, not just the part that\n+     is the responsibility of the caller.  */\n+  needed += reg_parm_stack_space;\n+#endif\n+\n+#ifdef ARGS_GROW_DOWNWARD\n+  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n+\t\t\t\t     needed + 1);\n+#else\n+  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n+\t\t\t\t     needed);\n #endif\n+  stack_usage_map = (char *) alloca (highest_outgoing_arg_in_use);\n+\n+  if (initial_highest_arg_in_use)\n+    bcopy (initial_stack_usage_map, stack_usage_map,\n+\t   initial_highest_arg_in_use);\n+\n+  if (initial_highest_arg_in_use != highest_outgoing_arg_in_use)\n+    bzero (&stack_usage_map[initial_highest_arg_in_use],\n+\t   highest_outgoing_arg_in_use - initial_highest_arg_in_use);\n+  needed = 0;\n \n+  /* The address of the outgoing argument list must not be copied to a\n+     register here, because argblock would be left pointing to the\n+     wrong place after the call to allocate_dynamic_stack_space below.\n+     */\n+\n+  argblock = virtual_outgoing_args_rtx;\n+#else /* not ACCUMULATE_OUTGOING_ARGS */\n #ifndef PUSH_ROUNDING\n   argblock = push_block (GEN_INT (args_size.constant), 0, 0);\n #endif\n+#endif\n \n #ifdef PUSH_ARGS_REVERSED\n #ifdef STACK_BOUNDARY\n@@ -2798,6 +3067,68 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n   argnum = 0;\n #endif\n \n+#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n+  /* The argument list is the property of the called routine and it\n+     may clobber it.  If the fixed area has been used for previous\n+     parameters, we must save and restore it.\n+\n+     Here we compute the boundary of the that needs to be saved, if any.  */\n+\n+#ifdef ARGS_GROW_DOWNWARD\n+  for (count = 0; count < reg_parm_stack_space + 1; count++)\n+#else\n+  for (count = 0; count < reg_parm_stack_space; count++)\n+#endif\n+    {\n+      if (count >=  highest_outgoing_arg_in_use\n+\t  || stack_usage_map[count] == 0)\n+\tcontinue;\n+\n+      if (low_to_save == -1)\n+\tlow_to_save = count;\n+\n+      high_to_save = count;\n+    }\n+\n+  if (low_to_save >= 0)\n+    {\n+      int num_to_save = high_to_save - low_to_save + 1;\n+      enum machine_mode save_mode\n+\t= mode_for_size (num_to_save * BITS_PER_UNIT, MODE_INT, 1);\n+      rtx stack_area;\n+\n+      /* If we don't have the required alignment, must do this in BLKmode.  */\n+      if ((low_to_save & (MIN (GET_MODE_SIZE (save_mode),\n+\t\t\t       BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n+\tsave_mode = BLKmode;\n+\n+      stack_area = gen_rtx (MEM, save_mode,\n+\t\t\t    memory_address (save_mode,\n+\t\t\t\t\t    \n+#ifdef ARGS_GROW_DOWNWARD\n+\t\t\t\t\t    plus_constant (argblock,\n+\t\t\t\t\t\t\t   - high_to_save)\n+#else\n+\t\t\t\t\t    plus_constant (argblock,\n+\t\t\t\t\t\t\t   low_to_save)\n+#endif\n+\t\t\t\t\t    ));\n+      if (save_mode == BLKmode)\n+\t{\n+\t  save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n+\t  MEM_IN_STRUCT_P (save_area) = 0;\n+\t  emit_block_move (validize_mem (save_area), stack_area,\n+\t\t\t   GEN_INT (num_to_save),\n+\t\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n+\t}\n+      else\n+\t{\n+\t  save_area = gen_reg_rtx (save_mode);\n+\t  emit_move_insn (save_area, stack_area);\n+\t}\n+    }\n+#endif\n+\t  \n   /* Push the args that need to be pushed.  */\n \n   for (count = 0; count < nargs; count++, argnum += inc)\n@@ -2806,11 +3137,59 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n       register rtx val = argvec[argnum].value;\n       rtx reg = argvec[argnum].reg;\n       int partial = argvec[argnum].partial;\n+      int lower_bound, upper_bound, i;\n \n       if (! (reg != 0 && partial == 0))\n-\temit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n-\t\t\targblock, GEN_INT (argvec[count].offset.constant));\n-      NO_DEFER_POP;\n+\t{\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+\t  /* If this is being stored into a pre-allocated, fixed-size, stack\n+\t     area, save any previous data at that location.  */\n+\n+#ifdef ARGS_GROW_DOWNWARD\n+\t  /* stack_slot is negative, but we want to index stack_usage_map\n+\t     with positive values.  */\n+\t  upper_bound = -argvec[count].offset.constant + 1;\n+\t  lower_bound = upper_bound - argvec[count].size.constant;\n+#else\n+\t  lower_bound = argvec[count].offset.constant;\n+\t  upper_bound = lower_bound + argvec[count].size.constant;\n+#endif\n+\n+\t  for (i = lower_bound; i < upper_bound; i++)\n+\t    if (stack_usage_map[i]\n+#ifdef REG_PARM_STACK_SPACE\n+\t\t/* Don't store things in the fixed argument area at this point;\n+\t\t   it has already been saved.  */\n+\t\t&& i > reg_parm_stack_space\n+#endif\n+\t\t)\n+\t      break;\n+\n+\t  if (i != upper_bound)\n+\t    {\n+\t      /* We need to make a save area.  See what mode we can make it.  */\n+\t      enum machine_mode save_mode\n+\t\t= mode_for_size (argvec[count].size.constant * BITS_PER_UNIT,\n+\t\t\t\t MODE_INT, 1);\n+\t      rtx stack_area\n+\t\t= gen_rtx (MEM, save_mode,\n+\t\t\t   memory_address (save_mode, plus_constant (argblock,\n+\t\t\t\t\t   argvec[count].offset.constant)));\n+\t      argvec[count].save_area = gen_reg_rtx (save_mode);\n+\t      emit_move_insn (argvec[count].save_area, stack_area);\n+\t    }\n+#endif\n+\t  emit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n+\t\t\t  argblock, GEN_INT (argvec[count].offset.constant));\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+\t  /* Now mark the segment we just used.  */\n+\t  for (i = lower_bound; i < upper_bound; i++)\n+\t    stack_usage_map[i] = 1;\n+#endif\n+\n+\t  NO_DEFER_POP;\n+\t}\n     }\n \n #ifndef PUSH_ARGS_REVERSED\n@@ -2905,6 +3284,47 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \tvalue = hard_libcall_value (outmode);\n     }\n \n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+#ifdef REG_PARM_STACK_SPACE\n+      if (save_area)\n+\t{\n+\t  enum machine_mode save_mode = GET_MODE (save_area);\n+\t  rtx stack_area\n+\t    = gen_rtx (MEM, save_mode,\n+\t\t       memory_address (save_mode,\n+#ifdef ARGS_GROW_DOWNWARD\n+\t\t\t\t       plus_constant (argblock, - high_to_save)\n+#else\n+\t\t\t\t       plus_constant (argblock, low_to_save)\n+#endif\n+\t\t\t\t       ));\n+\n+\t  if (save_mode != BLKmode)\n+\t    emit_move_insn (stack_area, save_area);\n+\t  else\n+\t    emit_block_move (stack_area, validize_mem (save_area),\n+\t\t\t     GEN_INT (high_to_save - low_to_save + 1),\n+\t\t\t     PARM_BOUNDARY / BITS_PER_UNIT);\n+\t}\n+#endif\n+\t  \n+  /* If we saved any argument areas, restore them.  */\n+  for (count = 0; count < nargs; count++)\n+    if (argvec[count].save_area)\n+      {\n+\tenum machine_mode save_mode = GET_MODE (argvec[count].save_area);\n+\trtx stack_area\n+\t  = gen_rtx (MEM, save_mode,\n+\t\t     memory_address (save_mode, plus_constant (argblock,\n+\t\t\t\t     argvec[count].offset.constant)));\n+\n+\temit_move_insn (stack_area, argvec[count].save_area);\n+      }\n+\n+  highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n+  stack_usage_map = initial_stack_usage_map;\n+#endif\n+\n   return value;\n }\n \f"}]}