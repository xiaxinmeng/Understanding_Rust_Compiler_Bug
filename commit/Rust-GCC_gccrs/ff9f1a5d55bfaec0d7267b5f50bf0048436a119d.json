{"sha": "ff9f1a5d55bfaec0d7267b5f50bf0048436a119d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY5ZjFhNWQ1NWJmYWVjMGQ3MjY3YjVmNTBiZjAwNDg0MzZhMTE5ZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-05-17T18:46:32Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-05-17T18:46:32Z"}, "message": "decl2.c (finish_anon_union): Generalize error messages to handle anonymous structures.\n\n\t* decl2.c (finish_anon_union): Generalize error messages to handle\n\tanonymous structures.\n\t* init.c (perform_member_init): Remove `name' parameter.\n\t(build_field_list): New function.\n\t(sort_member_init): Handle anonymous union initialization order\n\tcorrectly.  Check for multiple initializations of the same union.\n\t(emit_base_init): Don't look up fields by name here.\n\t(expand_member_init): Record the result of name lookup for future\n\treference.\n\t* typeck.c (build_component_ref): Fix formatting.\n\nFrom-SVN: r33963", "tree": {"sha": "757b0885c16d983c79e15343fd00c84bd9038798", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/757b0885c16d983c79e15343fd00c84bd9038798"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff9f1a5d55bfaec0d7267b5f50bf0048436a119d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff9f1a5d55bfaec0d7267b5f50bf0048436a119d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff9f1a5d55bfaec0d7267b5f50bf0048436a119d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff9f1a5d55bfaec0d7267b5f50bf0048436a119d/comments", "author": null, "committer": null, "parents": [{"sha": "2c0b35cb894747518533852e3a60cde8a8e6250b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c0b35cb894747518533852e3a60cde8a8e6250b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c0b35cb894747518533852e3a60cde8a8e6250b"}], "stats": {"total": 375, "additions": 258, "deletions": 117}, "files": [{"sha": "bcde1a2b3de6ab3f16f798151bc5369f1caf1c4c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9f1a5d55bfaec0d7267b5f50bf0048436a119d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9f1a5d55bfaec0d7267b5f50bf0048436a119d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ff9f1a5d55bfaec0d7267b5f50bf0048436a119d", "patch": "@@ -1,3 +1,16 @@\n+2000-05-17  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* decl2.c (finish_anon_union): Generalize error messages to handle\n+\tanonymous structures.\n+\t* init.c (perform_member_init): Remove `name' parameter.\n+\t(build_field_list): New function.\n+\t(sort_member_init): Handle anonymous union initialization order\n+\tcorrectly.  Check for multiple initializations of the same union.\n+\t(emit_base_init): Don't look up fields by name here.\n+\t(expand_member_init): Record the result of name lookup for future\n+\treference.\n+\t* typeck.c (build_component_ref): Fix formatting.\n+\t\n Wed May 17 17:27:44 2000  Andrew Cagney  <cagney@b1.cygnus.com>\n \n \t* decl.c (pop_label): Replace warn_unused with warn_unused_label."}, {"sha": "ad47f9142276825759a5c33a50ac8cedde42cd86", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9f1a5d55bfaec0d7267b5f50bf0048436a119d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9f1a5d55bfaec0d7267b5f50bf0048436a119d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ff9f1a5d55bfaec0d7267b5f50bf0048436a119d", "patch": "@@ -2172,7 +2172,7 @@ finish_anon_union (anon_union_decl)\n \n   if (public_p)\n     {\n-      error (\"global anonymous unions must be declared static\");\n+      error (\"namespace-scope anonymous aggregates must be static\");\n       return;\n     }\n \n@@ -2182,7 +2182,7 @@ finish_anon_union (anon_union_decl)\n \n   if (main_decl == NULL_TREE)\n     {\n-      warning (\"anonymous union with no members\");\n+      warning (\"anonymous aggregate with no members\");\n       return;\n     }\n "}, {"sha": "81c301a21e1daadaae38c2d4449458e5a93e8c26", "filename": "gcc/cp/init.c", "status": "modified", "additions": 186, "deletions": 112, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9f1a5d55bfaec0d7267b5f50bf0048436a119d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9f1a5d55bfaec0d7267b5f50bf0048436a119d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=ff9f1a5d55bfaec0d7267b5f50bf0048436a119d", "patch": "@@ -39,7 +39,7 @@ static void construct_virtual_bases PARAMS ((tree, tree, tree, tree, tree));\n static void expand_aggr_init_1 PARAMS ((tree, tree, tree, tree, int));\n static void expand_default_init PARAMS ((tree, tree, tree, tree, int));\n static tree build_vec_delete_1 PARAMS ((tree, tree, tree, tree, int));\n-static void perform_member_init PARAMS ((tree, tree, tree, int));\n+static void perform_member_init PARAMS ((tree, tree, int));\n static void sort_base_init PARAMS ((tree, tree *, tree *));\n static tree build_builtin_delete_call PARAMS ((tree));\n static int member_init_ok_or_else PARAMS ((tree, tree, const char *));\n@@ -52,6 +52,7 @@ static tree dfs_initialize_vtbl_ptrs PARAMS ((tree, void *));\n static tree build_new_1\tPARAMS ((tree));\n static tree get_cookie_size PARAMS ((tree));\n static tree build_dtor_call PARAMS ((tree, tree, int));\n+static tree build_field_list PARAMS ((tree, tree, int *));\n \n /* Set up local variable for this file.  MUST BE CALLED AFTER\n    INIT_DECL_PROCESSING.  */\n@@ -175,14 +176,14 @@ initialize_vtbl_ptrs (type, addr)\n /* Subroutine of emit_base_init.  */\n \n static void\n-perform_member_init (member, name, init, explicit)\n-     tree member, name, init;\n+perform_member_init (member, init, explicit)\n+     tree member, init;\n      int explicit;\n {\n   tree decl;\n   tree type = TREE_TYPE (member);\n \n-  decl = build_component_ref (current_class_ref, name, NULL_TREE, explicit);\n+  decl = build_component_ref (current_class_ref, member, NULL_TREE, explicit);\n \n   if (decl == error_mark_node)\n     return;\n@@ -192,8 +193,11 @@ perform_member_init (member, name, init, explicit)\n      synthesized copy constructor.  */\n   if (ANON_AGGR_TYPE_P (type))\n     {\n-      init = build (INIT_EXPR, type, decl, TREE_VALUE (init));\n-      finish_expr_stmt (init);\n+      if (init)\n+\t{\n+\t  init = build (INIT_EXPR, type, decl, TREE_VALUE (init));\n+\t  finish_expr_stmt (init);\n+\t}\n     }\n   else if (TYPE_NEEDS_CONSTRUCTING (type)\n \t   || (init && TYPE_HAS_CONSTRUCTOR (type)))\n@@ -268,7 +272,7 @@ perform_member_init (member, name, init, explicit)\n     {\n       tree expr;\n \n-      expr = build_component_ref (current_class_ref, name, NULL_TREE,\n+      expr = build_component_ref (current_class_ref, member, NULL_TREE,\n \t\t\t\t  explicit);\n       expr = build_delete (type, expr, integer_zero_node,\n \t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n@@ -278,91 +282,198 @@ perform_member_init (member, name, init, explicit)\n     }\n }\n \n+/* Returns a TREE_LIST containing (as the TREE_PURPOSE of each node) all\n+   the FIELD_DECLs on the TYPE_FIELDS list for T, in reverse order.  */\n+\n+static tree \n+build_field_list (t, list, uses_unions_p)\n+     tree t;\n+     tree list;\n+     int *uses_unions_p;\n+{\n+  tree fields;\n+\n+  /* Note whether or not T is a union.  */\n+  if (TREE_CODE (t) == UNION_TYPE)\n+    *uses_unions_p = 1;\n+\n+  for (fields = TYPE_FIELDS (t); fields; fields = TREE_CHAIN (fields))\n+    {\n+      /* Skip CONST_DECLs for enumeration constants and so forth.  */\n+      if (TREE_CODE (fields) != FIELD_DECL)\n+\tcontinue;\n+      \n+      /* Keep track of whether or not any fields are unions.  */\n+      if (TREE_CODE (TREE_TYPE (fields)) == UNION_TYPE)\n+\t*uses_unions_p = 1;\n+\n+      /* For an anonymous struct or union, we must recursively\n+\t consider the fields of the anonymous type.  They can be\n+\t directly initialized from the constructor.  */\n+      if (ANON_AGGR_TYPE_P (TREE_TYPE (fields)))\n+\t{\n+\t  /* Add this field itself.  Synthesized copy constructors\n+\t     initialize the entire aggregate.  */\n+\t  list = tree_cons (fields, NULL_TREE, list);\n+\t  /* And now add the fields in the anonymous aggregate.  */\n+\t  list = build_field_list (TREE_TYPE (fields), list, \n+\t\t\t\t   uses_unions_p);\n+\t}\n+      /* Add this field.  */\n+      else if (DECL_NAME (fields))\n+\tlist = tree_cons (fields, NULL_TREE, list);\n+    }\n+\n+  return list;\n+}\n+\n /* Subroutine of emit_member_init.  */\n \n static tree\n sort_member_init (t)\n      tree t;\n {\n-  tree x, member, name, field;\n-  tree init_list = NULL_TREE;\n-  int last_pos = 0;\n-  tree last_field = NULL_TREE;\n+  tree init_list;\n+  tree last_field;\n+  tree init;\n+  int uses_unions_p;\n+\n+  /* Build up a list of the various fields, in sorted order.  */\n+  init_list = nreverse (build_field_list (t, NULL_TREE, &uses_unions_p));\n+\n+  /* Go through the explicit initializers, adding them to the\n+     INIT_LIST.  */\n+  last_field = init_list;\n+  for (init = current_member_init_list; init; init = TREE_CHAIN (init))\n+    {\n+      tree f;\n+      tree initialized_field;\n+\n+      initialized_field = TREE_PURPOSE (init);\n+      my_friendly_assert (TREE_CODE (initialized_field) == FIELD_DECL,\n+\t\t\t  20000516);\n+\n+      /* If the explicit initializers are in sorted order, then the\n+\t INITIALIZED_FIELD will be for a field following the\n+\t LAST_FIELD.  */\n+      for (f = last_field; f; f = TREE_CHAIN (f))\n+\tif (TREE_PURPOSE (f) == initialized_field)\n+\t  break;\n+\n+      /* Give a warning, if appropriate.  */\n+      if (warn_reorder && !f)\n+\t{\n+\t  cp_warning_at (\"member initializers for `%#D'\", last_field);\n+\t  cp_warning_at (\"  and `%#D'\", initialized_field);\n+\t  warning (\"  will be re-ordered to match declaration order\");\n+\t}\n \n-  for (member = TYPE_FIELDS (t); member ; member = TREE_CHAIN (member))\n-    {\n-      int pos;\n+      /* Look again, from the beginning of the list.  We must find the\n+\t field on this loop.  */\n+      if (!f)\n+\t{\n+\t  f = init_list;\n+\t  while (TREE_PURPOSE (f) != initialized_field)\n+\t    f = TREE_CHAIN (f);\n+\t}\n \n-      /* member could be, for example, a CONST_DECL for an enumerated\n-\t tag; we don't want to try to initialize that, since it already\n-\t has a value.  */\n-      if (TREE_CODE (member) != FIELD_DECL || !DECL_NAME (member))\n-\tcontinue;\n+      /* If there was already an explicit initializer for this field,\n+\t issue an error.  */\n+      if (TREE_TYPE (f))\n+\tcp_error (\"multiple initializations given for member `%D'\",\n+\t\t  initialized_field);\n+      else\n+\t{\n+\t  /* Mark the field as explicitly initialized.  */\n+\t  TREE_TYPE (f) = error_mark_node;\n+\t  /* And insert the initializer.  */\n+\t  TREE_VALUE (f) = TREE_VALUE (init);\n+\t}\n+\n+      /* Remember the location of the last explicitly initialized\n+\t field.  */\n+      last_field = f;\n+    }\n+\n+  /* [class.base.init]\n \n-      for (x = current_member_init_list, pos = 0; x; x = TREE_CHAIN (x), ++pos)\n+     If a ctor-initializer specifies more than one mem-initializer for\n+     multiple members of the same union (including members of\n+     anonymous unions), the ctor-initializer is ill-formed.  */\n+  if (uses_unions_p)\n+    {\n+      last_field = NULL_TREE;\n+      for (init = init_list; init; init = TREE_CHAIN (init))\n \t{\n-\t  /* If we cleared this out, then pay no attention to it.  */\n-\t  if (TREE_PURPOSE (x) == NULL_TREE)\n+\t  tree field;\n+\t  tree field_type;\n+\t  int done;\n+\n+\t  /* Skip uninitialized members.  */\n+\t  if (!TREE_TYPE (init))\n+\t    continue;\n+\t  /* See if this field is a member of a union, or a member of a\n+\t     structure contained in a union, etc.  */\n+\t  field = TREE_PURPOSE (init);\n+\t  for (field_type = DECL_CONTEXT (field);\n+\t       !same_type_p (field_type, t);\n+\t       field_type = TYPE_CONTEXT (field_type))\n+\t    if (TREE_CODE (field_type) == UNION_TYPE)\n+\t      break;\n+\t  /* If this field is not a member of a union, skip it.  */\n+\t  if (TREE_CODE (field_type) != UNION_TYPE)\n \t    continue;\n-\t  name = TREE_PURPOSE (x);\n \n-\t  if (TREE_CODE (name) == IDENTIFIER_NODE)\n-\t    field = IDENTIFIER_CLASS_VALUE (name);\n-\t  else\n+\t  /* It's only an error if we have two initializers for the same\n+\t     union type.  */\n+\t  if (!last_field)\n \t    {\n-\t      my_friendly_assert (TREE_CODE (name) == FIELD_DECL, 348); \n-\t      field = name;\n+\t      last_field = field;\n+\t      continue;\n \t    }\n \n-\t  /* If one member shadows another, get the outermost one.  */\n-\t  if (TREE_CODE (field) == TREE_LIST)\n-\t    field = TREE_VALUE (field);\n+\t  /* See if LAST_FIELD and the field initialized by INIT are\n+\t     members of the same union.  If so, there's a problem,\n+\t     unless they're actually members of the same structure\n+\t     which is itself a member of a union.  For example, given:\n \n-\t  if (field == member)\n+\t       union { struct { int i; int j; }; };\n+\n+\t     initializing both `i' and `j' makes sense.  */\n+\t  field_type = DECL_CONTEXT (field);\n+\t  done = 0;\n+\t  do\n \t    {\n-\t      if (warn_reorder)\n+\t      tree last_field_type;\n+\n+\t      last_field_type = DECL_CONTEXT (last_field);\n+\t      while (1)\n \t\t{\n-\t\t  if (pos < last_pos)\n+\t\t  if (same_type_p (last_field_type, field_type))\n \t\t    {\n-\t\t      cp_warning_at (\"member initializers for `%#D'\", last_field);\n-\t\t      cp_warning_at (\"  and `%#D'\", field);\n-\t\t      warning (\"  will be re-ordered to match declaration order\");\n+\t\t      if (TREE_CODE (field_type) == UNION_TYPE)\n+\t\t\tcp_error (\"initializations for multiple members of `%T'\",\n+\t\t\t\t  last_field_type);\n+\t\t      done = 1;\n+\t\t      break;\n \t\t    }\n-\t\t  last_pos = pos;\n-\t\t  last_field = field;\n-\t\t}\n \n-\t      /* Make sure we won't try to work on this init again.  */\n-\t      TREE_PURPOSE (x) = NULL_TREE;\n-\t      x = build_tree_list (name, TREE_VALUE (x));\n-\t      goto got_it;\n-\t    }\n-\t}\n+\t\t  if (same_type_p (last_field_type, t))\n+\t\t    break;\n \n-      /* If we didn't find MEMBER in the list, create a dummy entry\n-\t so the two lists (INIT_LIST and the list of members) will be\n-\t symmetrical.  */\n-      x = build_tree_list (NULL_TREE, NULL_TREE);\n-    got_it:\n-      init_list = chainon (init_list, x); \n-    }\n+\t\t  last_field_type = TYPE_CONTEXT (last_field_type);\n+\t\t}\n+\t      \n+\t      /* If we've reached the outermost class, then we're\n+\t\t done.  */\n+\t      if (same_type_p (field_type, t))\n+\t\tbreak;\n \n-  /* Initializers for base members go at the end.  */\n-  for (x = current_member_init_list ; x ; x = TREE_CHAIN (x))\n-    {\n-      name = TREE_PURPOSE (x);\n-      if (name)\n-\t{\n-\t  if (purpose_member (name, init_list))\n-\t    {\n-\t      cp_error (\"multiple initializations given for member `%D'\",\n-\t\t\tIDENTIFIER_CLASS_VALUE (name));\n-\t      continue;\n+\t      field_type = TYPE_CONTEXT (field_type);\n \t    }\n-\t      \n-\t  init_list = chainon (init_list,\n-\t\t\t       build_tree_list (name, TREE_VALUE (x)));\n-\t  TREE_PURPOSE (x) = NULL_TREE;\n+\t  while (!done);\n+\n+\t  last_field = field;\n \t}\n     }\n \n@@ -586,32 +697,23 @@ emit_base_init (t)\n   /* Initialize the vtable pointers for the class.  */\n   initialize_vtbl_ptrs (t, current_class_ptr);\n \n-  for (member = TYPE_FIELDS (t); member; member = TREE_CHAIN (member))\n+  while (mem_init_list)\n     {\n-      tree init, name;\n+      tree init;\n+      tree member;\n       int from_init_list;\n \n-      /* member could be, for example, a CONST_DECL for an enumerated\n-\t tag; we don't want to try to initialize that, since it already\n-\t has a value.  */\n-      if (TREE_CODE (member) != FIELD_DECL || !DECL_NAME (member))\n-\tcontinue;\n+      member = TREE_PURPOSE (mem_init_list);\n \n       /* See if we had a user-specified member initialization.  */\n-      if (TREE_PURPOSE (mem_init_list))\n+      if (TREE_TYPE (mem_init_list))\n \t{\n-\t  name = TREE_PURPOSE (mem_init_list);\n \t  init = TREE_VALUE (mem_init_list);\n \t  from_init_list = 1;\n-\n-\t  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE\n-\t\t\t      || TREE_CODE (name) == FIELD_DECL, 349);\n \t}\n       else\n \t{\n-\t  name = DECL_NAME (member);\n \t  init = DECL_INITIAL (member);\n-\n \t  from_init_list = 0;\n \n \t  /* Effective C++ rule 12.  */\n@@ -621,35 +723,7 @@ emit_base_init (t)\n \t    cp_warning (\"`%D' should be initialized in the member initialization list\", member);\t    \n \t}\n \n-      perform_member_init (member, name, init, from_init_list);\n-      mem_init_list = TREE_CHAIN (mem_init_list);\n-    }\n-\n-  /* Now initialize any members from our bases.  */\n-  while (mem_init_list)\n-    {\n-      tree name, init, field;\n-\n-      if (TREE_PURPOSE (mem_init_list))\n-\t{\n-\t  name = TREE_PURPOSE (mem_init_list);\n-\t  init = TREE_VALUE (mem_init_list);\n-\n-\t  if (TREE_CODE (name) == IDENTIFIER_NODE)\n-\t    field = IDENTIFIER_CLASS_VALUE (name);\n-\t  else\n-\t    field = name;\n-\n-\t  /* If one member shadows another, get the outermost one.  */\n-\t  if (TREE_CODE (field) == TREE_LIST)\n-\t    {\n-\t      field = TREE_VALUE (field);\n-\t      if (decl_type_context (field) != current_class_type)\n-\t\tcp_error (\"field `%D' not in immediate context\", field);\n-\t    }\n-\n-\t  perform_member_init (field, name, init, 1);\n-\t}\n+      perform_member_init (member, init, from_init_list);\n       mem_init_list = TREE_CHAIN (mem_init_list);\n     }\n }\n@@ -992,7 +1066,7 @@ expand_member_init (exp, name, init)\n \t  return;\n \t}\n \n-      member_init = build_tree_list (name, init);\n+      member_init = build_tree_list (field, init);\n       current_member_init_list = chainon (current_member_init_list, member_init);\n     }\n }"}, {"sha": "01606fa205ab8c9916e3f2bb9ee40e94d7ada204", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9f1a5d55bfaec0d7267b5f50bf0048436a119d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9f1a5d55bfaec0d7267b5f50bf0048436a119d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ff9f1a5d55bfaec0d7267b5f50bf0048436a119d", "patch": "@@ -2189,9 +2189,7 @@ build_component_ref (datum, component, basetype_path, protect)\n       tree base = context;\n       while (!same_type_p (base, basetype) && TYPE_NAME (base)\n \t     && ANON_AGGR_TYPE_P (base))\n-\t{\n-\t  base = TYPE_CONTEXT (base);\n-\t}\n+\tbase = TYPE_CONTEXT (base);\n \n       /* Handle base classes here...  */\n       if (base != basetype && TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (basetype))"}, {"sha": "543b714163ba8908c6358679c5a1543e9c1cc1c5", "filename": "gcc/testsuite/g++.old-deja/g++.other/union3.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9f1a5d55bfaec0d7267b5f50bf0048436a119d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Funion3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9f1a5d55bfaec0d7267b5f50bf0048436a119d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Funion3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Funion3.C?ref=ff9f1a5d55bfaec0d7267b5f50bf0048436a119d", "patch": "@@ -0,0 +1,23 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+struct A\n+{\n+  union \n+  {\n+    int i;\n+  };\n+  int j;\n+\n+  A ();\n+};\n+\n+A::A ()\n+  : i (1), j (i = 0)\n+{\n+}\n+\n+int main ()\n+{\n+  A a;\n+  return a.i;\n+}"}, {"sha": "ac1925ee4bf41f60d3031e2c3d483eb6b1dfd90f", "filename": "gcc/testsuite/g++.old-deja/g++.other/union4.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9f1a5d55bfaec0d7267b5f50bf0048436a119d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Funion4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9f1a5d55bfaec0d7267b5f50bf0048436a119d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Funion4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Funion4.C?ref=ff9f1a5d55bfaec0d7267b5f50bf0048436a119d", "patch": "@@ -0,0 +1,33 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+// Special g++ Options:\n+\n+union A\n+{\n+  int i;\n+  int j;\n+\n+  A () : i (3), j (2) {} // ERROR - multiple initializations\n+};\n+\n+union B\n+{\n+  int i;\n+  union {\n+    int j;\n+  };\n+\n+  B () : i (3), j (2) {} // ERROR - multiple initializations\n+};\n+\n+union C\n+{\n+  union {\n+    struct {\n+      int i;\n+      int j;\n+    };\n+  };\n+\n+  C () : i (3), j (2) {}\n+};"}]}