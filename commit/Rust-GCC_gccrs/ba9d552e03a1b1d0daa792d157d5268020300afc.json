{"sha": "ba9d552e03a1b1d0daa792d157d5268020300afc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE5ZDU1MmUwM2ExYjFkMGRhYTc5MmQxNTdkNTI2ODAyMDMwMGFmYw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2004-01-29T00:18:40Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-01-29T00:18:40Z"}, "message": "Makefile.am (bits_headers): Remove allocator_traits.h.\n\n\n2004-01-28  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/Makefile.am (bits_headers): Remove allocator_traits.h.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/allocator_traits.h: Remove.\n\t* include/bits/allocator.h: Remove allocator_traits.h include, and\n\trelevant comments.\n\t(allocator): Empty base class, inherit from the underlying allocator.\n\t* src/allocator-inst.cc: Move __pool_alloc instantiation to...\n\t* src/allocator.cc: ...here. New. For the underlying allocators.\n\tAdd __mt_alloc, __pool_alloc, new_allocator, malloc_allocator bits.\n\t* config/linker-map.gnu: Remove __pool_alloc bits.\n\t* src/Makefile.am (sources): Add allocator.cc.\n\t* src/Makefile.in: Regenerate.\n\t* testsuite/20_util/allocator/1.cc: Split second test into...\n\t* testsuite/20_util/allocator/8230.cc: ...this.\n\t* include/bits/stl_bvector.h (__gnu_norm): Change bit_vector\n\ttypedef to use std::allocatore. Format.\n\t* include/ext/pool_allocator.h: Remove allocator_traits.h include,\n\t_Alloc_traits.\n\t* include/ext/mt_allocator.h (__gnu_cxx): Qualify\n\t__throw_bad_alloc calls. Don't include <memory>.\n\t* include/ext/malloc_allocator.h: Remove <memory> include.\n\t* include/ext/new_allocator.h (new_allocator): Same.\n\t* include/ext/ropeimpl.h (__gnu_cxx): Remove __alloc using\n\tdeclaration. Switch __alloc to _Alloc.\n\t* include/ext/hashtable.h: Remove __alloc.\n\t* include/backward/alloc.h: Only inject allocator, not\n\timplementation details.\n\n\t* include/ext/mt_allocator.h: Replace free with delete.\n\nFrom-SVN: r76821", "tree": {"sha": "436fcf4b51f314a43559cf24267e305879ad9edf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/436fcf4b51f314a43559cf24267e305879ad9edf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba9d552e03a1b1d0daa792d157d5268020300afc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba9d552e03a1b1d0daa792d157d5268020300afc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba9d552e03a1b1d0daa792d157d5268020300afc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba9d552e03a1b1d0daa792d157d5268020300afc/comments", "author": null, "committer": null, "parents": [{"sha": "63d47f2ab40888e60069135b3838f4fdcf42c7e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63d47f2ab40888e60069135b3838f4fdcf42c7e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63d47f2ab40888e60069135b3838f4fdcf42c7e9"}], "stats": {"total": 1236, "additions": 537, "deletions": 699}, "files": [{"sha": "fd632dd1e9b97f5915c6fdad044f5f6fe983b8b4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -1,3 +1,35 @@\n+2004-01-28  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/Makefile.am (bits_headers): Remove allocator_traits.h.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/bits/allocator_traits.h: Remove.\n+\t* include/bits/allocator.h: Remove allocator_traits.h include, and\n+\trelevant comments.\n+\t(allocator): Empty base class, inherit from the underlying allocator.\n+\t* src/allocator-inst.cc: Move __pool_alloc instantiation to...\n+\t* src/allocator.cc: ...here. New. For the underlying allocators.\n+\tAdd __mt_alloc, __pool_alloc, new_allocator, malloc_allocator bits.\n+\t* config/linker-map.gnu: Remove __pool_alloc bits.\n+\t* src/Makefile.am (sources): Add allocator.cc.\n+\t* src/Makefile.in: Regenerate.\n+\t* testsuite/20_util/allocator/1.cc: Split second test into...\n+\t* testsuite/20_util/allocator/8230.cc: ...this. \n+\t* include/bits/stl_bvector.h (__gnu_norm): Change bit_vector\n+\ttypedef to use std::allocatore. Format.\n+\t* include/ext/pool_allocator.h: Remove allocator_traits.h include,\n+\t_Alloc_traits.\n+\t* include/ext/mt_allocator.h (__gnu_cxx): Qualify\n+\t__throw_bad_alloc calls. Don't include <memory>.\n+\t* include/ext/malloc_allocator.h: Remove <memory> include.\n+\t* include/ext/new_allocator.h (new_allocator): Same.\n+\t* include/ext/ropeimpl.h (__gnu_cxx): Remove __alloc using\n+\tdeclaration. Switch __alloc to _Alloc.\n+\t* include/ext/hashtable.h: Remove __alloc.\n+\t* include/backward/alloc.h: Only inject allocator, not\n+\timplementation details.\n+\n+\t* include/ext/mt_allocator.h: Replace free with delete.\n+\t\n 2004-01-28  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* src/globals_io.cc: Change to __gnu_internal namespace."}, {"sha": "c6acb2ab4b909e6649b37054fd46192474e43b52", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -1,6 +1,6 @@\n ## Linker script for GNU ld 2.13.91+ only.\n ##\n-## Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+## Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n ##\n ## This file is part of the libstdc++ version 3 distribution.\n ##\n@@ -207,10 +207,6 @@ GLIBCXX_3.4 {\n     __signbitf;\n     __signbitl;\n \n-    # __gnu_cxx::__pool_alloc\n-    _ZN9__gnu_cxx12__pool_allocILb1ELi0EE8allocateE[jm];\n-    _ZN9__gnu_cxx12__pool_allocILb1ELi0EE10deallocateEPv[jm];\n-\n     # __gnu_cxx::stdio_sync_filebuf\n     _ZTVN9__gnu_cxx18stdio_sync_filebufI[cw]St11char_traitsI[cw]EEE;\n "}, {"sha": "f95c1a021c1c5a59a6fb7149cea370ceadf82625", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -1,6 +1,6 @@\n ## Makefile for the include subdirectory of the GNU C++ Standard library.\n ##\n-## Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+## Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n ##\n ## This file is part of the libstdc++ version 3 distribution.\n ## Process this file with automake to produce Makefile.in.\n@@ -92,7 +92,6 @@ bits_srcdir = ${glibcxx_srcdir}/include/bits\n bits_builddir = ./bits\n bits_headers = \\\n \t${bits_srcdir}/allocator.h \\\n-\t${bits_srcdir}/allocator_traits.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n \t${bits_srcdir}/basic_string.h \\"}, {"sha": "8ab2f7babfac963ae3f1f7f90270f0025833ec31", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -1,4 +1,4 @@\n-# Makefile.in generated by automake 1.7.9 from Makefile.am.\n+# Makefile.in generated by automake 1.7.8 from Makefile.am.\n # @configure_input@\n \n # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n@@ -287,7 +287,6 @@ bits_srcdir = ${glibcxx_srcdir}/include/bits\n bits_builddir = ./bits\n bits_headers = \\\n \t${bits_srcdir}/allocator.h \\\n-\t${bits_srcdir}/allocator_traits.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n \t${bits_srcdir}/basic_string.h \\\n@@ -519,15 +518,15 @@ debug_headers = \\\n \t${debug_srcdir}/string \\\n \t${debug_srcdir}/vector\n \n-@GLIBCXX_C_HEADERS_C_STD_FALSE@c_base_headers_extra = \n \n # Some of the different \"C\" header models need extra files.\n # Some \"C\" header schemes require the \"C\" compatibility headers.\n # For --enable-cheaders=c_std\n @GLIBCXX_C_HEADERS_C_STD_TRUE@c_base_headers_extra = ${c_base_srcdir}/cmath.tcc\n-@GLIBCXX_C_HEADERS_COMPATIBILITY_FALSE@c_compatibility_headers_extra = \n+@GLIBCXX_C_HEADERS_C_STD_FALSE@c_base_headers_extra = \n \n @GLIBCXX_C_HEADERS_COMPATIBILITY_TRUE@c_compatibility_headers_extra = ${c_compatibility_headers}\n+@GLIBCXX_C_HEADERS_COMPATIBILITY_FALSE@c_compatibility_headers_extra = \n \n host_srcdir = ${glibcxx_srcdir}/$(OS_INC_SRCDIR)\n host_builddir = ./${host_alias}/bits\n@@ -566,10 +565,10 @@ pch_input = ${host_builddir}/stdc++.h\n pch_output_builddir = ${host_builddir}/stdc++.h.gch\n pch_source = ${glibcxx_srcdir}/include/stdc++.h\n PCHFLAGS = -Winvalid-pch -Wno-deprecated -x c++-header $(CXXFLAGS)\n-@GLIBCXX_BUILD_PCH_TRUE@pch_build = ${pch_input}\n @GLIBCXX_BUILD_PCH_FALSE@pch_build = \n-@GLIBCXX_BUILD_PCH_TRUE@pch_install = install-pch\n+@GLIBCXX_BUILD_PCH_TRUE@pch_build = ${pch_input}\n @GLIBCXX_BUILD_PCH_FALSE@pch_install = \n+@GLIBCXX_BUILD_PCH_TRUE@pch_install = install-pch\n \n # List of all timestamp files.  By keeping only one copy of this list, both\n # CLEANFILES and all-local are kept up-to-date.\n@@ -673,7 +672,7 @@ install-am: all-am\n installcheck: installcheck-am\n install-strip:\n \t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  INSTALL_STRIP_FLAG=-s \\\n \t  `test -z '$(STRIP)' || \\\n \t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n mostlyclean-generic:"}, {"sha": "d3c3c738b95e57cbeca0d1cf3dae97a37737cce3", "filename": "libstdc++-v3/include/backward/alloc.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -1,6 +1,6 @@\n // Backward-compat support -*- C++ -*-\n \n-// Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -47,9 +47,6 @@\n #include <bits/c++config.h>\n #include <bits/allocator.h>\n \n-using __gnu_cxx::__pool_alloc;\n-using std::__alloc;\n-using std::__simple_alloc;\n using std::allocator;\n \n #endif"}, {"sha": "e54dbc88c5a1f441613d00046250a86f3bb4e309", "filename": "libstdc++-v3/include/backward/bvector.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fbvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fbvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fbvector.h?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -1,6 +1,6 @@\n // Backward-compat support -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -59,7 +59,7 @@\n #include \"backward_warning.h\"\n #include <vector>\n \n-using std::bit_vector;\n+typedef std::vector<bool, allocator<bool> > bit_vector;\n \n #endif /* _BACKWARD_BVECTOR_H */\n "}, {"sha": "a8e40e202a572ecaff63c0f03084bf09c5fef164", "filename": "libstdc++-v3/include/bits/allocator.h", "status": "modified", "additions": 31, "deletions": 113, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -1,6 +1,6 @@\n // Allocators -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -45,82 +45,48 @@\n  *  You should not attempt to use it directly.\n  */\n \n-/**\n- *  @defgroup Allocators Memory Allocators\n- *  @if maint\n- *  allocator.h implements some node allocators.  These are NOT the same as\n- *  allocators in the C++ standard, nor in the original H-P STL.  They do not\n- *  encapsulate different pointer types; we assume that there is only one\n- *  pointer type.  The C++ standard allocators are intended to allocate\n- *  individual objects, not pools or arenas.\n- *\n- *  In this file allocators are of two different styles:  \"standard\" and\n- *  \"SGI\" (quotes included).  \"Standard\" allocators conform to 20.4.  \"SGI\"\n- *  allocators differ in AT LEAST the following ways (add to this list as you\n- *  discover them):\n- *\n- *   - \"Standard\" allocate() takes two parameters (n_count,hint=0) but \"SGI\"\n- *     allocate() takes one paramter (n_size).\n- *   - Likewise, \"standard\" deallocate()'s argument is a count, but in \"SGI\"\n- *     is a byte size.\n- *   - max_size(), construct(), and destroy() are missing in \"SGI\" allocators.\n- *   - reallocate(p,oldsz,newsz) is added in \"SGI\", and behaves as\n- *     if p=realloc(p,newsz).\n- *\n- *  \"SGI\" allocators may be wrapped in __allocator to convert the interface\n- *  into a \"standard\" one.\n- *  @endif\n- *\n- *  The canonical description of these classes is in docs/html/ext/howto.html\n- *  or online at http://gcc.gnu.org/onlinedocs/libstdc++/ext/howto.html#3\n-*/\n-\n #ifndef _ALLOCATOR_H\n #define _ALLOCATOR_H 1\n \n-#include <bits/functexcept.h>   // For __throw_bad_alloc\n-#include <bits/allocator_traits.h>\n+#if 1\n+# include <ext/mt_allocator.h>\n+# define __glibcxx_default_allocator  __gnu_cxx::__mt_alloc\n+#endif\n \n-// Pick a default underlying allocator.\n-#include <ext/pool_allocator.h>\n+#if 0\n+# include <ext/pool_allocator.h>\n+# define __glibcxx_default_allocator  __gnu_cxx::__pool_alloc\n+#endif\n \n namespace std\n {\n-  typedef __gnu_cxx::__pool_alloc<true, 0>    __alloc;\n+  template<typename _Tp>\n+    class allocator;\n \n-  /// The version for the default allocator.\n-  template<typename _Tp, typename _Tp1>\n-    struct _Alloc_traits<_Tp, allocator<_Tp1> >\n+  template<>\n+    class allocator<void>\n     {\n-      static const bool _S_instanceless = true;\n-      typedef __simple_alloc<_Tp, __alloc> _Alloc_type;\n-      typedef allocator<_Tp> allocator_type;\n+    public:\n+      typedef size_t      size_type;\n+      typedef ptrdiff_t   difference_type;\n+      typedef void*       pointer;\n+      typedef const void* const_pointer;\n+      typedef void        value_type;\n+\n+      template<typename _Tp1>\n+        struct rebind\n+        { typedef allocator<_Tp1> other; };\n     };\n-  //@}\n-}\n \n-namespace std\n-{\n   /**\n    *  @brief  The \"standard\" allocator, as per [20.4].\n    *\n-   *  The private _Alloc is \"SGI\" style.  (See comments at the top\n-   *  of allocator.h.)\n-   *\n-   *  The underlying allocator behaves as follows.\n-   *    - __pool_alloc is used via two typedefs\n-   *    - \"__alloc\" typedef is threadsafe via the locks\n-   *    - __new_alloc is used for memory requests\n-   *\n    *  (See @link Allocators allocators info @endlink for more.)\n    */\n   template<typename _Tp>\n-    class allocator\n+    class allocator: public __glibcxx_default_allocator<_Tp>  \n     {\n-      // The underlying allocator.\n-      typedef __alloc _Alloc;     \n-     \n-    public:\n+   public:\n       typedef size_t     size_type;\n       typedef ptrdiff_t  difference_type;\n       typedef _Tp*       pointer;\n@@ -135,68 +101,17 @@ namespace std\n \n       allocator() throw() { }\n \n-      allocator(const allocator&) throw() { }\n+      allocator(const allocator& a) throw() \n+      : __glibcxx_default_allocator<_Tp>(a) { }\n \n       template<typename _Tp1>\n         allocator(const allocator<_Tp1>&) throw() { }\n \n       ~allocator() throw() { }\n \n-      pointer\n-      address(reference __x) const { return &__x; }\n-\n-      const_pointer\n-      address(const_reference __x) const { return &__x; }\n-\n-      // NB: __n is permitted to be 0.  The C++ standard says nothing\n-      // about what the return value is when __n == 0.\n-      _Tp*\n-      allocate(size_type __n, const void* = 0)\n-      {\n-\t_Tp* __ret = 0;\n-\tif (__n)\n-\t  {\n-\t    if (__n <= this->max_size())\n-\t      __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));\n-\t    else\n-\t      __throw_bad_alloc();\n-\t  }\n-\treturn __ret;\n-      }\n-\n-      // __p is not permitted to be a null pointer.\n-      void\n-      deallocate(pointer __p, size_type __n)\n-      { _Alloc::deallocate(__p, __n * sizeof(_Tp)); }\n-\n-      size_type\n-      max_size() const throw() { return size_t(-1) / sizeof(_Tp); }\n-\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 402. wrong new expression in [some_]allocator::construct\n-      void \n-      construct(pointer __p, const _Tp& __val) { ::new(__p) _Tp(__val); }\n-\n-      void \n-      destroy(pointer __p) { __p->~_Tp(); }\n+      // Inherit everything else.\n     };\n \n-  template<>\n-    class allocator<void>\n-    {\n-    public:\n-      typedef size_t      size_type;\n-      typedef ptrdiff_t   difference_type;\n-      typedef void*       pointer;\n-      typedef const void* const_pointer;\n-      typedef void        value_type;\n-\n-      template<typename _Tp1>\n-        struct rebind\n-        { typedef allocator<_Tp1> other; };\n-    };\n-\n-\n   template<typename _T1, typename _T2>\n     inline bool\n     operator==(const allocator<_T1>&, const allocator<_T2>&)\n@@ -214,6 +129,9 @@ namespace std\n   extern template class allocator<char>;\n   extern template class allocator<wchar_t>;\n #endif\n+\n+  // Undefine.\n+#undef __glibcxx_default_allocator\n } // namespace std\n \n #endif"}, {"sha": "93bae7a2d44236131b892e58ca403e59c6f9fc26", "filename": "libstdc++-v3/include/bits/allocator_traits.h", "status": "removed", "additions": 0, "deletions": 237, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d47f2ab40888e60069135b3838f4fdcf42c7e9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d47f2ab40888e60069135b3838f4fdcf42c7e9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator_traits.h?ref=63d47f2ab40888e60069135b3838f4fdcf42c7e9", "patch": "@@ -1,237 +0,0 @@\n-// Allocators -*- C++ -*-\n-\n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- * Copyright (c) 1996-1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _ALLOCATOR_TRAITS_H\n-#define _ALLOCATOR_TRAITS_H 1\n-\n-#include <cstddef>\n-\n-namespace std\n-{\n-  /**\n-   *  @if maint\n-   *  This is used primarily (only?) in _Alloc_traits and other places to\n-   *  help provide the _Alloc_type typedef.  All it does is forward the\n-   *  requests after some minimal checking.\n-   *\n-   *  This is neither \"standard\"-conforming nor \"SGI\".  The _Alloc parameter\n-   *  must be \"SGI\" style.\n-   *  @endif\n-   *  (See @link Allocators allocators info @endlink for more.)\n-   */\n-  template<typename _Tp, typename _Alloc>\n-    class __simple_alloc\n-    {\n-    public:\n-      static _Tp*\n-      allocate(size_t __n)\n-      {\n-\t_Tp* __ret = 0;\n-\tif (__n)\n-\t  __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));\n-\treturn __ret;\n-      }\n-  \n-      static _Tp*\n-      allocate()\n-      { return (_Tp*) _Alloc::allocate(sizeof (_Tp)); }\n-  \n-      static void\n-      deallocate(_Tp* __p, size_t __n)\n-      { if (0 != __n) _Alloc::deallocate(__p, __n * sizeof (_Tp)); }\n-  \n-      static void\n-      deallocate(_Tp* __p)\n-      { _Alloc::deallocate(__p, sizeof (_Tp)); }\n-    };\n-\n-\n-  /**\n-   *  @if maint\n-   *  Allocator adaptor to turn an \"SGI\" style allocator (e.g.,\n-   *  __alloc, __malloc_alloc) into a \"standard\" conforming\n-   *  allocator.  Note that this adaptor does *not* assume that all\n-   *  objects of the underlying alloc class are identical, nor does it\n-   *  assume that all of the underlying alloc's member functions are\n-   *  static member functions.  Note, also, that __allocator<_Tp,\n-   *  __alloc> is essentially the same thing as allocator<_Tp>.\n-   *  @endif\n-   *  (See @link Allocators allocators info @endlink for more.)\n-   */\n-  template<typename _Tp, typename _Alloc>\n-    struct __allocator\n-    {\n-      _Alloc __underlying_alloc;\n-      \n-      typedef size_t    size_type;\n-      typedef ptrdiff_t difference_type;\n-      typedef _Tp*       pointer;\n-      typedef const _Tp* const_pointer;\n-      typedef _Tp&       reference;\n-      typedef const _Tp& const_reference;\n-      typedef _Tp        value_type;\n-\n-      template<typename _Tp1>\n-        struct rebind\n-        { typedef __allocator<_Tp1, _Alloc> other; };\n-\n-      __allocator() throw() { }\n-\n-      __allocator(const __allocator& __a) throw()\n-      : __underlying_alloc(__a.__underlying_alloc) { }\n-\n-      template<typename _Tp1>\n-        __allocator(const __allocator<_Tp1, _Alloc>& __a) throw()\n-        : __underlying_alloc(__a.__underlying_alloc) { }\n-\n-      ~__allocator() throw() { }\n-\n-      pointer\n-      address(reference __x) const { return &__x; }\n-\n-      const_pointer\n-      address(const_reference __x) const { return &__x; }\n-\n-      // NB: __n is permitted to be 0.  The C++ standard says nothing\n-      // about what the return value is when __n == 0.\n-      _Tp*\n-      allocate(size_type __n, const void* = 0)\n-      {\n-\t_Tp* __ret = 0;\n-\tif (__n)\n-\t  __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));\n-\treturn __ret;\n-      }\n-\n-      // __p is not permitted to be a null pointer.\n-      void\n-      deallocate(pointer __p, size_type __n)\n-      { __underlying_alloc.deallocate(__p, __n * sizeof(_Tp)); }\n-      \n-      size_type\n-      max_size() const throw() { return size_t(-1) / sizeof(_Tp); }\n-\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 402. wrong new expression in [some_]allocator::construct\n-      void\n-      construct(pointer __p, const _Tp& __val) { ::new(__p) _Tp(__val); }\n-      \n-      void\n-      destroy(pointer __p) { __p->~_Tp(); }\n-    };\n-\n-  template<typename _Alloc>\n-    struct __allocator<void, _Alloc>\n-    {\n-      typedef size_t      size_type;\n-      typedef ptrdiff_t   difference_type;\n-      typedef void*       pointer;\n-      typedef const void* const_pointer;\n-      typedef void        value_type;\n-\n-      template<typename _Tp1>\n-        struct rebind\n-        { typedef __allocator<_Tp1, _Alloc> other; };\n-    };\n-\n-  template<typename _Tp, typename _Alloc>\n-    inline bool\n-    operator==(const __allocator<_Tp,_Alloc>& __a1, \n-\t       const __allocator<_Tp,_Alloc>& __a2)\n-    { return __a1.__underlying_alloc == __a2.__underlying_alloc; }\n-\n-  template<typename _Tp, typename _Alloc>\n-    inline bool\n-    operator!=(const __allocator<_Tp, _Alloc>& __a1,\n-               const __allocator<_Tp, _Alloc>& __a2)\n-    { return __a1.__underlying_alloc != __a2.__underlying_alloc; }\n-\n-\n-  /**\n-   *  @if maint\n-   *  Another allocator adaptor:  _Alloc_traits.  This serves two purposes.\n-   *  First, make it possible to write containers that can use either \"SGI\"\n-   *  style allocators or \"standard\" allocators.  Second, provide a mechanism\n-   *  so that containers can query whether or not the allocator has distinct\n-   *  instances.  If not, the container can avoid wasting a word of memory to\n-   *  store an empty object.  For examples of use, see stl_vector.h, etc, or\n-   *  any of the other classes derived from this one.\n-   *\n-   *  This adaptor uses partial specialization.  The general case of\n-   *  _Alloc_traits<_Tp, _Alloc> assumes that _Alloc is a\n-   *  standard-conforming allocator, possibly with non-equal instances and\n-   *  non-static members.  (It still behaves correctly even if _Alloc has\n-   *  static member and if all instances are equal.  Refinements affect\n-   *  performance, not correctness.)\n-   *\n-   *  There are always two members:  allocator_type, which is a standard-\n-   *  conforming allocator type for allocating objects of type _Tp, and\n-   *  _S_instanceless, a static const member of type bool.  If\n-   *  _S_instanceless is true, this means that there is no difference\n-   *  between any two instances of type allocator_type.  Furthermore, if\n-   *  _S_instanceless is true, then _Alloc_traits has one additional\n-   *  member:  _Alloc_type.  This type encapsulates allocation and\n-   *  deallocation of objects of type _Tp through a static interface; it\n-   *  has two member functions, whose signatures are\n-   *\n-   *  -  static _Tp* allocate(size_t)\n-   *  -  static void deallocate(_Tp*, size_t)\n-   *\n-   *  The size_t parameters are \"standard\" style (see top of\n-   *  allocator.h) in that they take counts, not sizes.\n-   *\n-   *  @endif\n-   *  (See @link Allocators allocators info @endlink for more.)\n-   */\n-  // The fully general version.\n-  template<typename _Tp, typename _Allocator>\n-    struct _Alloc_traits\n-    {\n-      static const bool _S_instanceless = false;\n-      typedef typename _Allocator::template rebind<_Tp>::other allocator_type;\n-    };\n-\n-  template<typename _Tp, typename _Allocator>\n-    const bool _Alloc_traits<_Tp, _Allocator>::_S_instanceless;\n-} // namespace std\n-\n-#endif"}, {"sha": "4087de48cc31520b6dced201f19e70887f6776cd", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 309, "deletions": 223, "changes": 532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -66,237 +66,325 @@ namespace __gnu_norm\n   typedef unsigned long _Bit_type;\n   enum { _S_word_bit = int(CHAR_BIT * sizeof(_Bit_type)) };\n \n-struct _Bit_reference {\n+  struct _Bit_reference \n+  {\n+    _Bit_type * _M_p;\n+    _Bit_type _M_mask;\n \n-  _Bit_type * _M_p;\n-  _Bit_type _M_mask;\n-  _Bit_reference(_Bit_type * __x, _Bit_type __y) \n-    : _M_p(__x), _M_mask(__y) {}\n+    _Bit_reference(_Bit_type * __x, _Bit_type __y) \n+    : _M_p(__x), _M_mask(__y) { }\n \n-public:\n-  _Bit_reference() : _M_p(0), _M_mask(0) {}\n-  operator bool() const { return !!(*_M_p & _M_mask); }\n-  _Bit_reference& operator=(bool __x)\n-  {\n-    if (__x)  *_M_p |= _M_mask;\n-    else      *_M_p &= ~_M_mask;\n-    return *this;\n-  }\n-  _Bit_reference& operator=(const _Bit_reference& __x) \n+    _Bit_reference() : _M_p(0), _M_mask(0) { }\n+\n+    operator bool() const { return !!(*_M_p & _M_mask); }\n+\n+    _Bit_reference& \n+    operator=(bool __x)\n+    {\n+      if (__x)  \n+\t*_M_p |= _M_mask;\n+      else      \n+\t*_M_p &= ~_M_mask;\n+      return *this;\n+    }\n+\n+    _Bit_reference& \n+    operator=(const _Bit_reference& __x) \n     { return *this = bool(__x); }\n-  bool operator==(const _Bit_reference& __x) const\n+\n+    bool \n+    operator==(const _Bit_reference& __x) const\n     { return bool(*this) == bool(__x); }\n-  bool operator<(const _Bit_reference& __x) const\n+\n+    bool \n+    operator<(const _Bit_reference& __x) const\n     { return !bool(*this) && bool(__x); }\n-  void flip() { *_M_p ^= _M_mask; }\n-};\n \n-struct _Bit_iterator_base : public iterator<random_access_iterator_tag, bool>\n-{\n-  _Bit_type * _M_p;\n-  unsigned int _M_offset;\n+    void \n+    flip() { *_M_p ^= _M_mask; }\n+  };\n+\n+  struct _Bit_iterator_base : public iterator<random_access_iterator_tag, bool>\n+  {\n+    _Bit_type * _M_p;\n+    unsigned int _M_offset;\n \n-  _Bit_iterator_base(_Bit_type * __x, unsigned int __y)\n-    : _M_p(__x), _M_offset(__y) {}\n+    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)\n+    : _M_p(__x), _M_offset(__y) { }\n \n-  void _M_bump_up() {\n-    if (_M_offset++ == _S_word_bit - 1) {\n-      _M_offset = 0;\n-      ++_M_p;\n+    void \n+    _M_bump_up() \n+    {\n+      if (_M_offset++ == _S_word_bit - 1) \n+\t{\n+\t  _M_offset = 0;\n+\t  ++_M_p;\n+\t}\n     }\n-  }\n-  void _M_bump_down() {\n-    if (_M_offset-- == 0) {\n-      _M_offset = _S_word_bit - 1;\n-      --_M_p;\n+\n+    void \n+    _M_bump_down() \n+    {\n+      if (_M_offset-- == 0) \n+\t{\n+\t  _M_offset = _S_word_bit - 1;\n+\t  --_M_p;\n+\t}\n+    }\n+    \n+    void \n+    _M_incr(ptrdiff_t __i) \n+    {\n+      difference_type __n = __i + _M_offset;\n+      _M_p += __n / _S_word_bit;\n+      __n = __n % _S_word_bit;\n+      if (__n < 0) \n+\t{\n+\t  _M_offset = static_cast<unsigned int>(__n + _S_word_bit);\n+\t  --_M_p;\n+\t} \n+      else\n+\t_M_offset = static_cast<unsigned int>(__n);\n+    }\n+    \n+    bool \n+    operator==(const _Bit_iterator_base& __i) const \n+    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }\n+    \n+    bool \n+    operator<(const _Bit_iterator_base& __i) const \n+    {\n+      return _M_p < __i._M_p \n+\t|| (_M_p == __i._M_p && _M_offset < __i._M_offset);\n     }\n-  }\n \n-  void _M_incr(ptrdiff_t __i) {\n-    difference_type __n = __i + _M_offset;\n-    _M_p += __n / _S_word_bit;\n-    __n = __n % _S_word_bit;\n-    if (__n < 0) {\n-      _M_offset = (unsigned int) __n + _S_word_bit;\n-      --_M_p;\n-    } else\n-      _M_offset = (unsigned int) __n;\n-  }\n+    bool \n+    operator!=(const _Bit_iterator_base& __i) const \n+    { return !(*this == __i); }\n+    \n+    bool \n+    operator>(const _Bit_iterator_base& __i) const \n+    { return __i < *this; }\n \n-  bool operator==(const _Bit_iterator_base& __i) const {\n-    return _M_p == __i._M_p && _M_offset == __i._M_offset;\n-  }\n-  bool operator<(const _Bit_iterator_base& __i) const {\n-    return _M_p < __i._M_p || (_M_p == __i._M_p && _M_offset < __i._M_offset);\n-  }\n-  bool operator!=(const _Bit_iterator_base& __i) const {\n-    return !(*this == __i);\n-  }\n-  bool operator>(const _Bit_iterator_base& __i) const {\n-    return __i < *this;\n-  }\n-  bool operator<=(const _Bit_iterator_base& __i) const {\n-    return !(__i < *this); \n-  }\n-  bool operator>=(const _Bit_iterator_base& __i) const {\n-    return !(*this < __i);\n+    bool \n+    operator<=(const _Bit_iterator_base& __i) const \n+    { return !(__i < *this); }\n+\n+    bool \n+    operator>=(const _Bit_iterator_base& __i) const \n+    { return !(*this < __i); }\n+  };\n+\n+  inline ptrdiff_t\n+  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) \n+  {\n+    return _S_word_bit * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset;\n   }\n-};\n \n-inline ptrdiff_t\n-operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {\n-  return _S_word_bit * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset;\n-}\n \n+  struct _Bit_iterator : public _Bit_iterator_base\n+  {\n+    typedef _Bit_reference  reference;\n+    typedef _Bit_reference* pointer;\n+    typedef _Bit_iterator   iterator;\n \n-struct _Bit_iterator : public _Bit_iterator_base\n-{\n-  typedef _Bit_reference  reference;\n-  typedef _Bit_reference* pointer;\n-  typedef _Bit_iterator   iterator;\n-\n-  _Bit_iterator() : _Bit_iterator_base(0, 0) {}\n-  _Bit_iterator(_Bit_type * __x, unsigned int __y) \n-    : _Bit_iterator_base(__x, __y) {}\n-\n-  reference operator*() const { return reference(_M_p, 1UL << _M_offset); }\n-  iterator& operator++() {\n-    _M_bump_up();\n-    return *this;\n-  }\n-  iterator operator++(int) {\n-    iterator __tmp = *this;\n-    _M_bump_up();\n-    return __tmp;\n-  }\n-  iterator& operator--() {\n-    _M_bump_down();\n-    return *this;\n-  }\n-  iterator operator--(int) {\n-    iterator __tmp = *this;\n-    _M_bump_down();\n-    return __tmp;\n-  }\n-  iterator& operator+=(difference_type __i) {\n-    _M_incr(__i);\n-    return *this;\n-  }\n-  iterator& operator-=(difference_type __i) {\n-    *this += -__i;\n-    return *this;\n-  }\n-  iterator operator+(difference_type __i) const {\n-    iterator __tmp = *this;\n-    return __tmp += __i;\n-  }\n-  iterator operator-(difference_type __i) const {\n-    iterator __tmp = *this;\n-    return __tmp -= __i;\n-  }\n+    _Bit_iterator() : _Bit_iterator_base(0, 0) { }\n+    _Bit_iterator(_Bit_type * __x, unsigned int __y) \n+    : _Bit_iterator_base(__x, __y) { }\n+    \n+    reference \n+    operator*() const { return reference(_M_p, 1UL << _M_offset); }\n \n-  reference operator[](difference_type __i) { return *(*this + __i); }\n-};\n+    iterator& \n+    operator++() \n+    {\n+      _M_bump_up();\n+      return *this;\n+    }\n+    \n+    iterator \n+    operator++(int) \n+    {\n+      iterator __tmp = *this;\n+      _M_bump_up();\n+      return __tmp;\n+    }\n \n-inline _Bit_iterator \n-operator+(ptrdiff_t __n, const _Bit_iterator& __x) { return __x + __n; }\n+    iterator& \n+    operator--() \n+    {\n+      _M_bump_down();\n+      return *this;\n+    }\n \n+    iterator \n+    operator--(int) \n+    {\n+      iterator __tmp = *this;\n+      _M_bump_down();\n+      return __tmp;\n+    }\n \n-struct _Bit_const_iterator : public _Bit_iterator_base\n-{\n-  typedef bool                 reference;\n-  typedef bool                 const_reference;\n-  typedef const bool*          pointer;\n-  typedef _Bit_const_iterator  const_iterator;\n-\n-  _Bit_const_iterator() : _Bit_iterator_base(0, 0) {}\n-  _Bit_const_iterator(_Bit_type * __x, unsigned int __y) \n-    : _Bit_iterator_base(__x, __y) {}\n-  _Bit_const_iterator(const _Bit_iterator& __x) \n-    : _Bit_iterator_base(__x._M_p, __x._M_offset) {}\n-\n-  const_reference operator*() const {\n-    return _Bit_reference(_M_p, 1UL << _M_offset);\n-  }\n-  const_iterator& operator++() {\n-    _M_bump_up();\n-    return *this;\n-  }\n-  const_iterator operator++(int) {\n-    const_iterator __tmp = *this;\n-    _M_bump_up();\n-    return __tmp;\n-  }\n-  const_iterator& operator--() {\n-    _M_bump_down();\n-    return *this;\n-  }\n-  const_iterator operator--(int) {\n-    const_iterator __tmp = *this;\n-    _M_bump_down();\n-    return __tmp;\n-  }\n-  const_iterator& operator+=(difference_type __i) {\n-    _M_incr(__i);\n-    return *this;\n-  }\n-  const_iterator& operator-=(difference_type __i) {\n-    *this += -__i;\n-    return *this;\n-  }\n-  const_iterator operator+(difference_type __i) const {\n-    const_iterator __tmp = *this;\n-    return __tmp += __i;\n-  }\n-  const_iterator operator-(difference_type __i) const {\n-    const_iterator __tmp = *this;\n-    return __tmp -= __i;\n-  }\n-  const_reference operator[](difference_type __i) { \n-    return *(*this + __i); \n-  }\n-};\n+    iterator& \n+    operator+=(difference_type __i) \n+    {\n+      _M_incr(__i);\n+      return *this;\n+    }\n \n-inline _Bit_const_iterator \n-operator+(ptrdiff_t __n, const _Bit_const_iterator& __x) { return __x + __n; }\n+    iterator&\n+    operator-=(difference_type __i) \n+    {\n+      *this += -__i;\n+      return *this;\n+    }\n \n+    iterator \n+    operator+(difference_type __i) const \n+    {\n+      iterator __tmp = *this;\n+      return __tmp += __i;\n+    }\n+    \n+    iterator \n+    operator-(difference_type __i) const \n+    {\n+      iterator __tmp = *this;\n+      return __tmp -= __i;\n+    }\n+    \n+    reference \n+    operator[](difference_type __i) { return *(*this + __i); }\n+  };\n+  \n+  inline _Bit_iterator \n+  operator+(ptrdiff_t __n, const _Bit_iterator& __x) { return __x + __n; }\n \n-template <class _Alloc>\n-class _Bvector_base\n-  : public _Alloc::template rebind<_Bit_type>::other\n-{\n-  typedef typename _Alloc::template rebind<_Bit_type>::other _Bit_alloc_type;\n-public:\n-  typedef _Alloc allocator_type;\n-  allocator_type get_allocator() const {\n-    return *static_cast<const _Bit_alloc_type*>(this);\n-  }\n \n-  _Bvector_base(const allocator_type& __a)\n-    : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0) { }\n-  ~_Bvector_base() { this->_M_deallocate(); }\n+  struct _Bit_const_iterator : public _Bit_iterator_base\n+  {\n+    typedef bool                 reference;\n+    typedef bool                 const_reference;\n+    typedef const bool*          pointer;\n+    typedef _Bit_const_iterator  const_iterator;\n+    \n+    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }\n+    _Bit_const_iterator(_Bit_type * __x, unsigned int __y) \n+    : _Bit_iterator_base(__x, __y) { }\n+    _Bit_const_iterator(const _Bit_iterator& __x) \n+    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }\n+\n+    const_reference \n+    operator*() const \n+    { return _Bit_reference(_M_p, 1UL << _M_offset); }\n+    \n+    const_iterator& \n+    operator++() \n+    {\n+      _M_bump_up();\n+      return *this;\n+    }\n+\n+    const_iterator \n+    operator++(int) \n+    {\n+      const_iterator __tmp = *this;\n+      _M_bump_up();\n+      return __tmp;\n+    }\n \n-protected:\n-  _Bit_type* _M_bit_alloc(size_t __n) {\n-    return _Bit_alloc_type::allocate((__n + _S_word_bit - 1)/_S_word_bit);\n-  }\n-  void _M_deallocate() {\n-    if (_M_start._M_p)\n-      _Bit_alloc_type::deallocate(_M_start._M_p, _M_end_of_storage - _M_start._M_p);\n-  }  \n+    const_iterator& \n+    operator--() \n+    {\n+      _M_bump_down();\n+      return *this;\n+    }\n+\n+    const_iterator \n+    operator--(int) \n+    {\n+      const_iterator __tmp = *this;\n+      _M_bump_down();\n+      return __tmp;\n+    }\n \n-  _Bit_iterator _M_start;\n-  _Bit_iterator _M_finish;\n-  _Bit_type * _M_end_of_storage;\n-};\n+    const_iterator& \n+    operator+=(difference_type __i) \n+    {\n+      _M_incr(__i);\n+      return *this;\n+    }\n+\n+    const_iterator& \n+    operator-=(difference_type __i) \n+    {\n+      *this += -__i;\n+      return *this;\n+    }\n+\n+    const_iterator operator+(difference_type __i) const {\n+      const_iterator __tmp = *this;\n+      return __tmp += __i;\n+    }\n \n+    const_iterator \n+    operator-(difference_type __i) const \n+    {\n+      const_iterator __tmp = *this;\n+      return __tmp -= __i;\n+    }\n+\n+    const_reference \n+    operator[](difference_type __i) \n+    { return *(*this + __i); }\n+  };\n+  \n+  inline _Bit_const_iterator \n+  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x) \n+  { return __x + __n; }\n+\n+  template<class _Alloc>\n+    class _Bvector_base\n+    : public _Alloc::template rebind<_Bit_type>::other\n+    {\n+      typedef typename _Alloc::template rebind<_Bit_type>::other _Bit_alloc_type;\n+\n+    public:\n+      typedef _Alloc allocator_type;\n+      \n+      allocator_type \n+      get_allocator() const \n+      { return *static_cast<const _Bit_alloc_type*>(this); }\n+      \n+      _Bvector_base(const allocator_type& __a)\n+      : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0) { }\n+\n+      ~_Bvector_base() { this->_M_deallocate(); }\n+\n+    protected:\n+      _Bit_type* \n+      _M_bit_alloc(size_t __n) \n+      { return _Bit_alloc_type::allocate((__n + _S_word_bit - 1)/_S_word_bit);}\n+\n+      void \n+      _M_deallocate() \n+      {\n+\tif (_M_start._M_p)\n+\t  _Bit_alloc_type::deallocate(_M_start._M_p, \n+\t\t\t\t      _M_end_of_storage - _M_start._M_p);\n+      }  \n+      \n+      _Bit_iterator _M_start;\n+      _Bit_iterator _M_finish;\n+      _Bit_type* _M_end_of_storage;\n+    };\n } // namespace __gnu_norm\n \n // Declare a partial specialization of vector<T, Alloc>.\n #include <bits/stl_vector.h>\n+\n namespace __gnu_norm\n {\n-\n   /**\n    *  @brief  A specialization of vector for booleans which offers fixed time\n    *  access to individual elements in any order.\n@@ -309,12 +397,13 @@ namespace __gnu_norm\n    *  @ingroup Containers\n    *  @ingroup Sequences\n    *\n-   *  In some terminology a %vector can be described as a dynamic C-style array,\n-   *  it offers fast and efficient access to individual elements in any order\n-   *  and saves the user from worrying about memory and size allocation.\n-   *  Subscripting ( @c [] ) access is also provided as with C-style arrays.\n+   *  In some terminology a %vector can be described as a dynamic\n+   *  C-style array, it offers fast and efficient access to individual\n+   *  elements in any order and saves the user from worrying about\n+   *  memory and size allocation.  Subscripting ( @c [] ) access is\n+   *  also provided as with C-style arrays.\n   */\n-template <typename _Alloc> \n+template<typename _Alloc> \n   class vector<bool, _Alloc> : public _Bvector_base<_Alloc> \n   {\n   public:\n@@ -370,7 +459,7 @@ template <typename _Alloc>\n       }\n     }\n   \n-    template <class _InputIterator>\n+    template<class _InputIterator>\n     void _M_initialize_range(_InputIterator __first, _InputIterator __last,\n                              input_iterator_tag) {\n       this->_M_start = iterator();\n@@ -380,15 +469,15 @@ template <typename _Alloc>\n         push_back(*__first);\n     }\n   \n-    template <class _ForwardIterator>\n+    template<class _ForwardIterator>\n     void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,\n                              forward_iterator_tag) {\n       size_type __n = std::distance(__first, __last);\n       _M_initialize(__n);\n       std::copy(__first, __last, this->_M_start);\n     }\n   \n-    template <class _InputIterator>\n+    template<class _InputIterator>\n     void _M_insert_range(iterator __pos,\n                          _InputIterator __first, _InputIterator __last,\n                          input_iterator_tag) {\n@@ -398,7 +487,7 @@ template <typename _Alloc>\n       }\n     }\n   \n-    template <class _ForwardIterator>\n+    template<class _ForwardIterator>\n     void _M_insert_range(iterator __position,\n                          _ForwardIterator __first, _ForwardIterator __last,\n                          forward_iterator_tag) {\n@@ -462,7 +551,7 @@ template <typename _Alloc>\n       { _M_range_check(__n); return (*this)[__n]; }\n   \n     explicit vector(const allocator_type& __a = allocator_type())\n-      : _Bvector_base<_Alloc>(__a) {}\n+      : _Bvector_base<_Alloc>(__a) { }\n   \n     vector(size_type __n, bool __value,\n               const allocator_type& __a = allocator_type())\n@@ -486,19 +575,19 @@ template <typename _Alloc>\n   \n     // Check whether it's an integral type.  If so, it's not an iterator.\n   \n-    template <class _Integer>\n+    template<class _Integer>\n     void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type) {\n       _M_initialize(__n);\n       std::fill(this->_M_start._M_p, this->_M_end_of_storage, __x ? ~0 : 0);\n     }\n   \n-    template <class _InputIterator>\n+    template<class _InputIterator>\n     void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n                                 __false_type) {\n       _M_initialize_range(__first, __last, std::__iterator_category(__first));\n     }\n   \n-    template <class _InputIterator>\n+    template<class _InputIterator>\n     vector(_InputIterator __first, _InputIterator __last,\n              const allocator_type& __a = allocator_type())\n       : _Bvector_base<_Alloc>(__a)\n@@ -538,21 +627,21 @@ template <typename _Alloc>\n   \n     void assign(size_t __n, bool __x) { _M_fill_assign(__n, __x); }\n   \n-    template <class _InputIterator>\n+    template<class _InputIterator>\n     void assign(_InputIterator __first, _InputIterator __last) {\n       typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n       _M_assign_dispatch(__first, __last, _Integral());\n     }\n   \n-    template <class _Integer>\n+    template<class _Integer>\n     void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n       { _M_fill_assign((size_t) __n, (bool) __val); }\n   \n-    template <class _InputIterator>\n+    template<class _InputIterator>\n     void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, __false_type)\n       { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n   \n-    template <class _InputIterator>\n+    template<class _InputIterator>\n     void _M_assign_aux(_InputIterator __first, _InputIterator __last,\n                        input_iterator_tag) {\n       iterator __cur = begin();\n@@ -564,7 +653,7 @@ template <typename _Alloc>\n         insert(end(), __first, __last);\n     }\n   \n-    template <class _ForwardIterator>\n+    template<class _ForwardIterator>\n     void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n                        forward_iterator_tag) {\n       size_type __len = std::distance(__first, __last);\n@@ -625,20 +714,20 @@ template <typename _Alloc>\n   \n     // Check whether it's an integral type.  If so, it's not an iterator.\n   \n-    template <class _Integer>\n+    template<class _Integer>\n     void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n                             __true_type) {\n       _M_fill_insert(__pos, __n, __x);\n     }\n   \n-    template <class _InputIterator>\n+    template<class _InputIterator>\n     void _M_insert_dispatch(iterator __pos,\n                             _InputIterator __first, _InputIterator __last,\n                             __false_type) {\n       _M_insert_range(__pos, __first, __last, std::__iterator_category(__first));\n     }\n   \n-    template <class _InputIterator>\n+    template<class _InputIterator>\n     void insert(iterator __position,\n                 _InputIterator __first, _InputIterator __last) {\n       typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n@@ -695,9 +784,6 @@ template <typename _Alloc>\n   \n     void clear() { erase(begin(), end()); }\n   };\n-\n-  // This typedef is non-standard.  It is provided for backward compatibility.\n-  typedef vector<bool, __alloc> bit_vector;\n } // namespace __gnu_norm\n \n-#endif /* _BVECTOR_H */\n+#endif "}, {"sha": "fd9f6a9f092782e7a547d42c73d07fa493b27843", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -94,7 +94,7 @@ namespace __gnu_norm\n       }\n       \n       ~_Vector_base() \n-      { _M_deallocate(this->_M_start,\n+      { _M_deallocate(this->_M_start, \n \t\t      this->_M_end_of_storage - this->_M_start); }\n \n     public:"}, {"sha": "f81a8580b15ab8fd0bb086e433f43adb41bd2bff", "filename": "libstdc++-v3/include/ext/hashtable.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -1,6 +1,6 @@\n // Hashtable implementation used by containers -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -91,8 +91,8 @@ struct _Hashtable_node\n   _Val _M_val;\n };\n \n-template <class _Val, class _Key, class _HashFcn,\n-          class _ExtractKey, class _EqualKey, class _Alloc = std::__alloc>\n+template <class _Val, class _Key, class _HashFcn, class _ExtractKey, \n+\t  class _EqualKey, class _Alloc = std::allocator<_Val> >\n class hashtable;\n \n template <class _Val, class _Key, class _HashFcn,"}, {"sha": "c8533b80c1a4698242535d6db40d216ea74bedc5", "filename": "libstdc++-v3/include/ext/malloc_allocator.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -1,6 +1,6 @@\n // Allocator that wraps \"C\" malloc -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,7 +31,6 @@\n #define _MALLOC_ALLOCATOR_H 1\n \n #include <new>\n-#include <memory>\n \n namespace __gnu_cxx\n {\n@@ -78,7 +77,7 @@ namespace __gnu_cxx\n       // NB: __n is permitted to be 0.  The C++ standard says nothing\n       // about what the return value is when __n == 0.\n       pointer\n-      allocate(size_type __n, std::allocator<void>::const_pointer __h = 0)\n+      allocate(size_type __n, const void* __h = 0)\n       { return static_cast<_Tp*>(malloc(__n * sizeof(_Tp))); }\n \n       // __p is not permitted to be a null pointer."}, {"sha": "9bb7bf47dddb51efe92327558adaff05567ea7d3", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -36,8 +36,6 @@\n #define _MT_ALLOCATOR_H 1\n \n #include <new>\n-#include <memory>\n-#include <cstdlib>\n #include <bits/functexcept.h>\n #include <bits/gthr.h>\n #include <bits/atomicity.h>\n@@ -230,7 +228,7 @@ namespace __gnu_cxx\n \n     public:\n       pointer\n-      allocate(size_t __n, std::allocator<void>::const_pointer __h = 0)\n+      allocate(size_t __n, const void* __h = 0)\n       {\n         /*\n          * Although the test in __gthread_once() would suffice, we\n@@ -260,7 +258,7 @@ namespace __gnu_cxx\n           {\n             void* __ret = ::operator new(__n * sizeof(_Tp));\n             if (!__ret)\n-              __throw_bad_alloc();\n+              std::__throw_bad_alloc();\n             return static_cast<_Tp*>(__ret);\n           }\n \n@@ -314,10 +312,10 @@ namespace __gnu_cxx\n                     __gthread_mutex_unlock(_S_bin[bin].mutex);\n \n                     _S_bin[bin].first[thread_id] =\n-                      static_cast<block_record*>(::operator new(_S_chunk_size));\n+                     static_cast<block_record*>(::operator new(_S_chunk_size));\n \n                     if (!_S_bin[bin].first[thread_id])\n-                      __throw_bad_alloc();\n+                      std::__throw_bad_alloc();\n \n                     _S_bin[bin].free[thread_id] = block_count;\n \n@@ -385,7 +383,7 @@ namespace __gnu_cxx\n                   static_cast<block_record*>(::operator new(_S_chunk_size));\n \n                 if (!_S_bin[bin].first[0])\n-                  __throw_bad_alloc();\n+                  std::__throw_bad_alloc();\n \n                 size_t bin_t = 1 << bin;\n                 size_t block_count = \n@@ -441,11 +439,11 @@ namespace __gnu_cxx\n       {\n         /*\n          * Requests larger than _S_max_bytes are handled by\n-         * malloc/free directly\n+         * operators new/delete directly\n          */\n         if (__n * sizeof(_Tp) > _S_max_bytes || _S_force_new)\n           {\n-            free(__p);\n+            ::operator delete(__p);\n             return;\n           }\n \n@@ -584,10 +582,10 @@ namespace __gnu_cxx\n        * Setup the bin map for quick lookup of the relevant bin\n        */\n       _S_binmap = (binmap_type*)\n-        malloc ((_S_max_bytes + 1) * sizeof(binmap_type));\n+        ::operator new ((_S_max_bytes + 1) * sizeof(binmap_type));\n \n       if (!_S_binmap)\n-        __throw_bad_alloc();\n+        std::__throw_bad_alloc();\n \n       binmap_type* bp_t = _S_binmap;\n       binmap_type bin_max_t = 1;\n@@ -615,7 +613,7 @@ namespace __gnu_cxx\n               new(sizeof(thread_record) * _S_max_threads));\n \n           if (!_S_thread_freelist_first)\n-            __throw_bad_alloc();\n+            std::__throw_bad_alloc();\n \n           /*\n            * NOTE! The first assignable thread id is 1 since the global\n@@ -651,7 +649,7 @@ namespace __gnu_cxx\n         new(sizeof(bin_record) * _S_no_of_bins));\n \n       if (!_S_bin)\n-        __throw_bad_alloc();\n+        std::__throw_bad_alloc();\n \n       std::size_t __n = 1;\n \n@@ -666,13 +664,13 @@ namespace __gnu_cxx\n             new(sizeof(block_record*) * __n));\n \n           if (!_S_bin[bin].first)\n-            __throw_bad_alloc();\n+            std::__throw_bad_alloc();\n \n           _S_bin[bin].last = static_cast<block_record**>(::operator \n             new(sizeof(block_record*) * __n));\n \n           if (!_S_bin[bin].last)\n-            __throw_bad_alloc();\n+            std::__throw_bad_alloc();\n \n #ifdef __GTHREADS\n           if (__gthread_active_p())\n@@ -681,13 +679,13 @@ namespace __gnu_cxx\n                 new(sizeof(size_t) * __n));\n \n               if (!_S_bin[bin].free)\n-                __throw_bad_alloc();\n+                std::__throw_bad_alloc();\n \n               _S_bin[bin].used = static_cast<size_t*>(::operator \n                 new(sizeof(size_t) * __n));\n \n               if (!_S_bin[bin].used)\n-                __throw_bad_alloc();\n+                std::__throw_bad_alloc();\n \n               _S_bin[bin].mutex = static_cast<__gthread_mutex_t*>(::operator \n                 new(sizeof(__gthread_mutex_t)));\n@@ -781,8 +779,8 @@ namespace __gnu_cxx\n   __mt_alloc<_Tp>::_S_once_mt = __GTHREAD_ONCE_INIT;\n #endif\n \n-  template<typename _Tp> bool\n-  volatile __mt_alloc<_Tp>::_S_initialized = false;\n+  template<typename _Tp> \n+  bool volatile __mt_alloc<_Tp>::_S_initialized = false;\n \n   template<typename _Tp> bool\n   __mt_alloc<_Tp>::_S_force_new = false;\n@@ -792,7 +790,7 @@ namespace __gnu_cxx\n \n   /*\n    * Allocation requests (after round-up to power of 2) below this\n-   * value will be handled by the allocator. A raw malloc/free() call\n+   * value will be handled by the allocator. A raw new/ call\n    * will be used for requests larger than this value.\n    */\n   template<typename _Tp> size_t\n@@ -853,14 +851,12 @@ namespace __gnu_cxx\n \n   template<typename _Tp>\n     inline bool\n-    operator==(const __mt_alloc<_Tp>&,\n-               const __mt_alloc<_Tp>&)\n+    operator==(const __mt_alloc<_Tp>&, const __mt_alloc<_Tp>&)\n     { return true; }\n   \n   template<typename _Tp>\n     inline bool\n-    operator!=(const __mt_alloc<_Tp>&,\n-               const __mt_alloc<_Tp>&)\n+    operator!=(const __mt_alloc<_Tp>&, const __mt_alloc<_Tp>&)\n     { return false; }\n } // namespace __gnu_cxx\n "}, {"sha": "e52c82ed6de5df3400bf7e78d6994d0d901d2dc2", "filename": "libstdc++-v3/include/ext/new_allocator.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -1,6 +1,6 @@\n // Allocator that wraps operator new -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -77,7 +77,7 @@ namespace __gnu_cxx\n       // NB: __n is permitted to be 0.  The C++ standard says nothing\n       // about what the return value is when __n == 0.\n       pointer\n-      allocate(size_type __n, allocator<void>::const_pointer __h = 0)\n+      allocate(size_type __n, const void* __h = 0)\n       { return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp))); }\n \n       // __p is not permitted to be a null pointer."}, {"sha": "2893890466c12ba65d695bb3569eb265cb59ebbc", "filename": "libstdc++-v3/include/ext/pool_allocator.h", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -1,6 +1,6 @@\n // Allocators -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -51,7 +51,6 @@\n #include <bits/functexcept.h>\n #include <bits/stl_threads.h>\n #include <bits/atomicity.h>\n-#include <bits/allocator_traits.h>\n \n namespace __gnu_cxx\n {\n@@ -360,33 +359,4 @@ namespace __gnu_cxx\n #endif\n } // namespace __gnu_cxx\n \n-namespace std\n-{\n-  //@{\n-  /// Versions for the predefined \"SGI\" style allocators.\n-  template<typename _Tp, bool __thr, int __inst>\n-    struct _Alloc_traits<_Tp, __gnu_cxx::__pool_alloc<__thr, __inst> >\n-    {\n-      static const bool _S_instanceless = true;\n-      typedef __gnu_cxx::__pool_alloc<__thr, __inst>\tbase_alloc_type;\n-      typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n-      typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n-    };\n-  //@}\n-\n-  //@{\n-  /// Versions for the __allocator adaptor used with the predefined\n-  /// \"SGI\" style allocators.\n-  template<typename _Tp, typename _Tp1, bool __thr, int __inst>\n-    struct _Alloc_traits<_Tp, __allocator<_Tp1,\n-\t\t\t\t     __gnu_cxx::__pool_alloc<__thr, __inst> > >\n-    {\n-      static const bool _S_instanceless = true;\n-      typedef __gnu_cxx::__pool_alloc<__thr, __inst>\tbase_alloc_type;\n-      typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n-      typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n-    };\n-  //@}\n-} // namespace std\n-\n #endif"}, {"sha": "0e545feff7fa8ead1ae72d04abfbe959a0c3e6e2", "filename": "libstdc++-v3/include/ext/ropeimpl.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -1,6 +1,6 @@\n // SGI's rope class implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -59,7 +59,6 @@ namespace __gnu_cxx\n   using std::printf;\n   using std::basic_ostream;\n   using std::__throw_length_error;\n-  using std::__alloc;\n   using std::_Destroy;\n   using std::uninitialized_fill_n;\n \n@@ -875,15 +874,15 @@ bool rope<_CharT, _Alloc>::_S_apply_to_pieces(\n \t\tsize_t __len = __end - __begin;\n \t\tbool __result;\n \t\t_CharT* __buffer =\n-\t\t  (_CharT*)__alloc::allocate(__len * sizeof(_CharT));\n+\t\t  (_CharT*)_Alloc::allocate(__len * sizeof(_CharT));\n \t\ttry {\n \t\t  (*(__f->_M_fn))(__begin, __len, __buffer);\n \t\t  __result = __c(__buffer, __len);\n-                  __alloc::deallocate(__buffer, __len * sizeof(_CharT));\n+                  _Alloc::deallocate(__buffer, __len * sizeof(_CharT));\n                 }\n \t\tcatch(...)\n \t\t  {\n-\t\t    __alloc::deallocate(__buffer, __len * sizeof(_CharT));\n+\t\t    _Alloc::deallocate(__buffer, __len * sizeof(_CharT));\n \t\t    __throw_exception_again;\n \t\t  }\n \t\treturn __result;"}, {"sha": "f51ea39de0b4fd7fa997fe07a9508afb4c65dcd4", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -91,6 +91,7 @@ basic_file.cc: ${glibcxx_srcdir}/$(BASIC_FILE_CC)\n \n # Sources present in the src directory.\n sources = \\\n+\tallocator.cc \\\n \tcodecvt.cc \\\n \tcomplex_io.cc \\\n \tctype.cc \\"}, {"sha": "ff570f9fafaa60cd77d6eab2e24f534ca2e93a6f", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -1,4 +1,4 @@\n-# Makefile.in generated by automake 1.7.9 from Makefile.am.\n+# Makefile.in generated by automake 1.7.8 from Makefile.am.\n # @configure_input@\n \n # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n@@ -247,6 +247,7 @@ host_sources_extra = \\\n \n # Sources present in the src directory.\n sources = \\\n+\tallocator.cc \\\n \tcodecvt.cc \\\n \tcomplex_io.cc \\\n \tctype.cc \\\n@@ -360,10 +361,10 @@ am__objects_1 = codecvt_members.lo collate_members.lo ctype_members.lo \\\n \tmessages_members.lo monetary_members.lo numeric_members.lo \\\n \ttime_members.lo\n am__objects_2 = basic_file.lo c++locale.lo\n-am__objects_3 = codecvt.lo complex_io.lo ctype.lo debug.lo demangle.lo \\\n-\tfunctexcept.lo globals_locale.lo globals_io.lo ios.lo \\\n-\tios_failure.lo ios_init.lo ios_locale.lo limits.lo list.lo \\\n-\tlocale.lo locale_init.lo locale_facets.lo localename.lo \\\n+am__objects_3 = allocator.lo codecvt.lo complex_io.lo ctype.lo debug.lo \\\n+\tdemangle.lo functexcept.lo globals_locale.lo globals_io.lo \\\n+\tios.lo ios_failure.lo ios_init.lo ios_locale.lo limits.lo \\\n+\tlist.lo locale.lo locale_init.lo locale_facets.lo localename.lo \\\n \tstdexcept.lo strstream.lo tree.lo allocator-inst.lo \\\n \tconcept-inst.lo fstream-inst.lo ext-inst.lo io-inst.lo \\\n \tistream-inst.lo locale-inst.lo locale-misc-inst.lo misc-inst.lo \\\n@@ -552,7 +553,7 @@ install-am: all-am\n installcheck: installcheck-am\n install-strip:\n \t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  INSTALL_STRIP_FLAG=-s \\\n \t  `test -z '$(STRIP)' || \\\n \t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n mostlyclean-generic:"}, {"sha": "3fcbb608098509984c1cbc6816139f4c8deece10", "filename": "libstdc++-v3/src/allocator-inst.cc", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Fsrc%2Fallocator-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Fsrc%2Fallocator-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fallocator-inst.cc?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -1,6 +1,6 @@\n // Explicit instantiation file.\n \n-// Copyright (C) 1999, 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -39,8 +39,3 @@ namespace std\n   template class allocator<char>;\n   template class allocator<wchar_t>;\n } // namespace std\n-\n-namespace __gnu_cxx\n-{\n-  template class __pool_alloc<true, 0>;\n-} // namespace __gnu_cxx"}, {"sha": "c2f084711ea80343114df692e39a469e59973d1c", "filename": "libstdc++-v3/src/allocator.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Fsrc%2Fallocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Fsrc%2Fallocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fallocator.cc?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -0,0 +1,57 @@\n+// Allocator details.\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882:\n+//\n+\n+#include <bits/c++config.h>\n+#include <memory>\n+#include <ext/mt_allocator.h>\n+#include <ext/pool_allocator.h>\n+\n+// Explicitly instantiate the static data members of the underlying\n+// allocator.\n+namespace __gnu_cxx\n+{\n+  // Static data members and member functions of __mt_alloc.\n+  static template class __mt_alloc<char>;\n+\n+  template\n+    void __mt_alloc<char>::_S_init();\n+\n+   template\n+    size_t __mt_alloc<char>::_S_get_thread_id();\n+\n+   template\n+    void __mt_alloc<char>::_S_thread_key_destr(void*);\n+\n+  // Static members of __pool_alloc.\n+  template class __pool_alloc<true, 0>;\n+} // namespace __gnu_cxx"}, {"sha": "8d35be39bb7c2a04b5bfd4868ce2f30e65ce78b8", "filename": "libstdc++-v3/testsuite/20_util/allocator/1.cc", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F1.cc?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -1,6 +1,6 @@\n // 2001-06-14  Benjamin Kosnik  <bkoz@redhat.com>\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -58,32 +58,8 @@ void test01()\n   VERIFY( check_delete );\n }\n \n-// libstdc++/8230\n-void test02()\n-{\n-  bool test __attribute__((unused)) = true;\n-  try \n-    {\n-      std::allocator<int> alloc;\n-      const std::allocator<int>::size_type n = alloc.max_size();\n-      int* p = alloc.allocate(n + 1);\n-      p[n] = 2002;\n-    } \n-  catch(const std::bad_alloc& e) \n-    {\n-      // Allowed.\n-      test = true;\n-    }\n-  catch(...) \n-    {\n-      test = false;\n-    }\n-  VERIFY( test );\n-}\n-\n int main()\n {\n   test01();\n-  test02();\n   return 0;\n }"}, {"sha": "7747dd7bce99b3ebf25deb9e0ca89dabae77fa83", "filename": "libstdc++-v3/testsuite/20_util/allocator/8230.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F8230.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9d552e03a1b1d0daa792d157d5268020300afc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F8230.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F8230.cc?ref=ba9d552e03a1b1d0daa792d157d5268020300afc", "patch": "@@ -0,0 +1,54 @@\n+// 2001-06-14  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <memory>\n+#include <stdexcept>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/8230\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  try \n+    {\n+      std::allocator<int> alloc;\n+      const std::allocator<int>::size_type n = alloc.max_size();\n+      int* p = alloc.allocate(n + 1);\n+      p[n] = 2002;\n+    } \n+  catch(const std::bad_alloc& e) \n+    {\n+      // Allowed.\n+      test = true;\n+    }\n+  catch(...) \n+    {\n+      test = false;\n+    }\n+  VERIFY( test );\n+}\n+\n+int main()\n+{\n+  test02();\n+  return 0;\n+}"}]}