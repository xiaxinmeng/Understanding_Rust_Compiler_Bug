{"sha": "3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MyYThlZDBkOWE1NmE0NWE2N2Y4N2M1ZmEzYTA5M2M2ODUyZTYyYg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-09-19T16:18:06Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-09-19T16:18:06Z"}, "message": "dump_printf: use %T and %G throughout\n\nAs promised at Cauldron, this patch uses %T and %G with dump_printf and\ndump_printf_loc calls to eliminate calls to\n\n  dump_generic_expr (MSG_*, arg, TDF_SLIM)  (via %T)\n\nand\n\n  dump_gimple_stmt (MSG_*, TDF_SLIM, stmt, 0)  (via %G)\n\nthroughout the middle-end, simplifying numerous dump callsites.\n\nA few calls to these functions didn't match the above pattern; I didn't\ntouch these.  I wasn't able to use %E anywhere.\n\ngcc/ChangeLog:\n\t* tree-data-ref.c (runtime_alias_check_p): Use formatted printing\n\twith %T in place of calls to dump_generic_expr.\n\t(prune_runtime_alias_test_list): Likewise.\n\t(create_runtime_alias_checks): Likewise.\n\t* tree-vect-data-refs.c (vect_check_nonzero_value): Likewise.\n\t(vect_analyze_data_ref_dependence): Likewise.\n\t(vect_slp_analyze_data_ref_dependence): Likewise.\n\t(vect_record_base_alignment): Likewise.  Use %G in place of call\n\tto dump_gimple_stmt.\n\t(vect_compute_data_ref_alignment): Likewise.\n\t(verify_data_ref_alignment): Likewise.\n\t(vect_find_same_alignment_drs): Likewise.\n\t(vect_analyze_group_access_1): Likewise.\n\t(vect_analyze_data_ref_accesses): Likewise.\n\t(dependence_distance_ge_vf): Likewise.\n\t(dump_lower_bound): Likewise.\n\t(vect_prune_runtime_alias_test_list): Likewise.\n\t(vect_find_stmt_data_reference): Likewise.\n\t(vect_analyze_data_refs): Likewise.\n\t(vect_create_addr_base_for_vector_ref): Likewise.\n\t(vect_create_data_ref_ptr): Likewise.\n\t* tree-vect-loop-manip.c (vect_set_loop_condition): Likewise.\n\t(vect_can_advance_ivs_p): Likewise.\n\t(vect_update_ivs_after_vectorizer): Likewise.\n\t(vect_gen_prolog_loop_niters): Likewise.\n\t(vect_prepare_for_masked_peels): Likewise.\n\t* tree-vect-loop.c (vect_determine_vf_for_stmt): Likewise.\n\t(vect_determine_vectorization_factor): Likewise.\n\t(vect_is_simple_iv_evolution): Likewise.\n\t(vect_analyze_scalar_cycles_1): Likewise.\n\t(vect_analyze_loop_operations): Likewise.\n\t(report_vect_op): Likewise.\n\t(vect_is_slp_reduction): Likewise.\n\t(check_reduction_path): Likewise.\n\t(vect_is_simple_reduction): Likewise.\n\t(vect_create_epilog_for_reduction): Likewise.\n\t(vect_finalize_reduction:): Likewise.\n\t(vectorizable_induction): Likewise.\n\t(vect_transform_loop_stmt): Likewise.\n\t(vect_transform_loop): Likewise.\n\t(optimize_mask_stores): Likewise.\n\t* tree-vect-patterns.c (vect_pattern_detected): Likewise.\n\t(vect_split_statement): Likewise.\n\t(vect_recog_over_widening_pattern): Likewise.\n\t(vect_recog_average_pattern): Likewise.\n\t(vect_determine_min_output_precision_1): Likewise.\n\t(vect_determine_precisions_from_range): Likewise.\n\t(vect_determine_precisions_from_users): Likewise.\n\t(vect_mark_pattern_stmts): Likewise.\n\t(vect_pattern_recog_1): Likewise.\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Likewise.\n\t(vect_record_max_nunits): Likewise.\n\t(vect_build_slp_tree_1): Likewise.\n\t(vect_build_slp_tree_2): Likewise.\n\t(vect_print_slp_tree): Likewise.\n\t(vect_analyze_slp_instance): Likewise.\n\t(vect_detect_hybrid_slp_stmts): Likewise.\n\t(vect_detect_hybrid_slp_1): Likewise.\n\t(vect_slp_analyze_operations): Likewise.\n\t(vect_slp_analyze_bb_1): Likewise.\n\t(vect_transform_slp_perm_load): Likewise.\n\t(vect_schedule_slp_instance): Likewise.\n\t* tree-vect-stmts.c (vect_mark_relevant): Likewise.\n\t(vect_mark_stmts_to_be_vectorized): Likewise.\n\t(vect_init_vector_1): Likewise.\n\t(vect_get_vec_def_for_operand): Likewise.\n\t(vect_finish_stmt_generation_1): Likewise.\n\t(vect_check_load_store_mask): Likewise.\n\t(vectorizable_call): Likewise.\n\t(vectorizable_conversion): Likewise.\n\t(vectorizable_operation): Likewise.\n\t(vectorizable_load): Likewise.\n\t(vect_analyze_stmt): Likewise.\n\t(vect_is_simple_use): Likewise.\n\t(vect_get_vector_types_for_stmt): Likewise.\n\t(vect_get_mask_type_for_stmt): Likewise.\n\t* tree-vectorizer.c (increase_alignment): Likewise.\n\nFrom-SVN: r264424", "tree": {"sha": "2fa8ce8ba5f0234a7d233606a588146eafaa1e26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fa8ce8ba5f0234a7d233606a588146eafaa1e26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5bbb71154e5f113b53a5835a86e5d548f5502fd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bbb71154e5f113b53a5835a86e5d548f5502fd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bbb71154e5f113b53a5835a86e5d548f5502fd6"}], "stats": {"total": 1502, "additions": 522, "deletions": 980}, "files": [{"sha": "cf3d66a6c03cbfb11a71b98d4c0f3c8020e52541", "filename": "gcc/ChangeLog", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b", "patch": "@@ -1,3 +1,83 @@\n+2018-09-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* tree-data-ref.c (runtime_alias_check_p): Use formatted printing\n+\twith %T in place of calls to dump_generic_expr.\n+\t(prune_runtime_alias_test_list): Likewise.\n+\t(create_runtime_alias_checks): Likewise.\n+\t* tree-vect-data-refs.c (vect_check_nonzero_value): Likewise.\n+\t(vect_analyze_data_ref_dependence): Likewise.\n+\t(vect_slp_analyze_data_ref_dependence): Likewise.\n+\t(vect_record_base_alignment): Likewise.  Use %G in place of call\n+\tto dump_gimple_stmt.\n+\t(vect_compute_data_ref_alignment): Likewise.\n+\t(verify_data_ref_alignment): Likewise.\n+\t(vect_find_same_alignment_drs): Likewise.\n+\t(vect_analyze_group_access_1): Likewise.\n+\t(vect_analyze_data_ref_accesses): Likewise.\n+\t(dependence_distance_ge_vf): Likewise.\n+\t(dump_lower_bound): Likewise.\n+\t(vect_prune_runtime_alias_test_list): Likewise.\n+\t(vect_find_stmt_data_reference): Likewise.\n+\t(vect_analyze_data_refs): Likewise.\n+\t(vect_create_addr_base_for_vector_ref): Likewise.\n+\t(vect_create_data_ref_ptr): Likewise.\n+\t* tree-vect-loop-manip.c (vect_set_loop_condition): Likewise.\n+\t(vect_can_advance_ivs_p): Likewise.\n+\t(vect_update_ivs_after_vectorizer): Likewise.\n+\t(vect_gen_prolog_loop_niters): Likewise.\n+\t(vect_prepare_for_masked_peels): Likewise.\n+\t* tree-vect-loop.c (vect_determine_vf_for_stmt): Likewise.\n+\t(vect_determine_vectorization_factor): Likewise.\n+\t(vect_is_simple_iv_evolution): Likewise.\n+\t(vect_analyze_scalar_cycles_1): Likewise.\n+\t(vect_analyze_loop_operations): Likewise.\n+\t(report_vect_op): Likewise.\n+\t(vect_is_slp_reduction): Likewise.\n+\t(check_reduction_path): Likewise.\n+\t(vect_is_simple_reduction): Likewise.\n+\t(vect_create_epilog_for_reduction): Likewise.\n+\t(vect_finalize_reduction:): Likewise.\n+\t(vectorizable_induction): Likewise.\n+\t(vect_transform_loop_stmt): Likewise.\n+\t(vect_transform_loop): Likewise.\n+\t(optimize_mask_stores): Likewise.\n+\t* tree-vect-patterns.c (vect_pattern_detected): Likewise.\n+\t(vect_split_statement): Likewise.\n+\t(vect_recog_over_widening_pattern): Likewise.\n+\t(vect_recog_average_pattern): Likewise.\n+\t(vect_determine_min_output_precision_1): Likewise.\n+\t(vect_determine_precisions_from_range): Likewise.\n+\t(vect_determine_precisions_from_users): Likewise.\n+\t(vect_mark_pattern_stmts): Likewise.\n+\t(vect_pattern_recog_1): Likewise.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Likewise.\n+\t(vect_record_max_nunits): Likewise.\n+\t(vect_build_slp_tree_1): Likewise.\n+\t(vect_build_slp_tree_2): Likewise.\n+\t(vect_print_slp_tree): Likewise.\n+\t(vect_analyze_slp_instance): Likewise.\n+\t(vect_detect_hybrid_slp_stmts): Likewise.\n+\t(vect_detect_hybrid_slp_1): Likewise.\n+\t(vect_slp_analyze_operations): Likewise.\n+\t(vect_slp_analyze_bb_1): Likewise.\n+\t(vect_transform_slp_perm_load): Likewise.\n+\t(vect_schedule_slp_instance): Likewise.\n+\t* tree-vect-stmts.c (vect_mark_relevant): Likewise.\n+\t(vect_mark_stmts_to_be_vectorized): Likewise.\n+\t(vect_init_vector_1): Likewise.\n+\t(vect_get_vec_def_for_operand): Likewise.\n+\t(vect_finish_stmt_generation_1): Likewise.\n+\t(vect_check_load_store_mask): Likewise.\n+\t(vectorizable_call): Likewise.\n+\t(vectorizable_conversion): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t(vect_analyze_stmt): Likewise.\n+\t(vect_is_simple_use): Likewise.\n+\t(vect_get_vector_types_for_stmt): Likewise.\n+\t(vect_get_mask_type_for_stmt): Likewise.\n+\t* tree-vectorizer.c (increase_alignment): Likewise.\n+\n 2018-09-19  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* doc/rtl.texi: Adjust vec_select description."}, {"sha": "bf30a61c868dfbc778f6603395bb5b57fe28d795", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b", "patch": "@@ -1322,13 +1322,9 @@ bool\n runtime_alias_check_p (ddr_p ddr, struct loop *loop, bool speed_p)\n {\n   if (dump_enabled_p ())\n-    {\n-      dump_printf (MSG_NOTE, \"consider run-time aliasing test between \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_A (ddr)));\n-      dump_printf (MSG_NOTE,  \" and \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_B (ddr)));\n-      dump_printf (MSG_NOTE, \"\\n\");\n-    }\n+    dump_printf (MSG_NOTE,\n+\t\t \"consider run-time aliasing test between %T and %T\\n\",\n+\t\t DR_REF (DDR_A (ddr)), DR_REF (DDR_B (ddr)));\n \n   if (!speed_p)\n     {\n@@ -1469,17 +1465,9 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n       if (*dr_a1 == *dr_a2 && *dr_b1 == *dr_b2)\n \t{\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf (MSG_NOTE, \"found equal ranges \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a1->dr));\n-\t      dump_printf (MSG_NOTE,  \", \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b1->dr));\n-\t      dump_printf (MSG_NOTE,  \" and \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a2->dr));\n-\t      dump_printf (MSG_NOTE,  \", \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b2->dr));\n-\t      dump_printf (MSG_NOTE, \"\\n\");\n-\t    }\n+\t    dump_printf (MSG_NOTE, \"found equal ranges %T, %T and %T, %T\\n\",\n+\t\t\t DR_REF (dr_a1->dr), DR_REF (dr_b1->dr),\n+\t\t\t DR_REF (dr_a2->dr), DR_REF (dr_b2->dr));\n \t  alias_pairs->ordered_remove (i--);\n \t  continue;\n \t}\n@@ -1576,17 +1564,9 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \t      dr_a1->align = MIN (dr_a1->align, new_align);\n \t    }\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf (MSG_NOTE, \"merging ranges for \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a1->dr));\n-\t      dump_printf (MSG_NOTE,  \", \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b1->dr));\n-\t      dump_printf (MSG_NOTE,  \" and \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a2->dr));\n-\t      dump_printf (MSG_NOTE,  \", \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b2->dr));\n-\t      dump_printf (MSG_NOTE, \"\\n\");\n-\t    }\n+\t    dump_printf (MSG_NOTE, \"merging ranges for %T, %T and %T, %T\\n\",\n+\t\t\t DR_REF (dr_a1->dr), DR_REF (dr_b1->dr),\n+\t\t\t DR_REF (dr_a2->dr), DR_REF (dr_b2->dr));\n \t  alias_pairs->ordered_remove (i);\n \t  i--;\n \t}\n@@ -1925,13 +1905,9 @@ create_runtime_alias_checks (struct loop *loop,\n       const dr_with_seg_len& dr_b = (*alias_pairs)[i].second;\n \n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf (MSG_NOTE, \"create runtime check for data references \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a.dr));\n-\t  dump_printf (MSG_NOTE, \" and \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b.dr));\n-\t  dump_printf (MSG_NOTE, \"\\n\");\n-\t}\n+\tdump_printf (MSG_NOTE,\n+\t\t     \"create runtime check for data references %T and %T\\n\",\n+\t\t     DR_REF (dr_a.dr), DR_REF (dr_b.dr));\n \n       /* Create condition expression for each pair data references.  */\n       create_intersect_range_checks (loop, &part_cond_expr, dr_a, dr_b);"}, {"sha": "56b7968dab0828538186db67016acc3ee1bd8058", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 155, "deletions": 326, "changes": 481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b", "patch": "@@ -183,11 +183,9 @@ vect_check_nonzero_value (loop_vec_info loop_vinfo, tree value)\n       return;\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"need run-time check that \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, value);\n-      dump_printf (MSG_NOTE, \" is nonzero\\n\");\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"need run-time check that %T is nonzero\\n\",\n+\t\t     value);\n   LOOP_VINFO_CHECK_NONZERO (loop_vinfo).safe_push (value);\n }\n \n@@ -351,32 +349,18 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  || STMT_VINFO_GATHER_SCATTER_P (stmtinfo_b))\n \t{\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t       \"versioning for alias not supported for: \"\n-\t\t\t       \"can't determine dependence between \");\n-\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t DR_REF (dra));\n-\t      dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n-\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t DR_REF (drb));\n-\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t    }\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"versioning for alias not supported for: \"\n+\t\t\t     \"can't determine dependence between %T and %T\\n\",\n+\t\t\t     DR_REF (dra), DR_REF (drb));\n \t  return true;\n \t}\n \n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"versioning for alias required: \"\n-\t\t\t   \"can't determine dependence between \");\n-\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t     DR_REF (dra));\n-\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n-\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t     DR_REF (drb));\n-\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"versioning for alias required: \"\n+\t\t\t \"can't determine dependence between %T and %T\\n\",\n+\t\t\t DR_REF (dra), DR_REF (drb));\n \n       /* Add to list of ddrs that need to be tested at run-time.  */\n       return !vect_mark_for_runtime_alias_test (ddr, loop_vinfo);\n@@ -399,30 +383,18 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  || STMT_VINFO_GATHER_SCATTER_P (stmtinfo_b))\n \t{\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t       \"versioning for alias not supported for: \"\n-\t\t\t       \"bad dist vector for \");\n-\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t DR_REF (dra));\n-\t      dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n-\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t DR_REF (drb));\n-\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t    }\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"versioning for alias not supported for: \"\n+\t\t\t     \"bad dist vector for %T and %T\\n\",\n+\t\t\t     DR_REF (dra), DR_REF (drb));\n \t  return true;\n \t}\n \n       if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                           \"versioning for alias required: \"\n-                           \"bad dist vector for \");\n-          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (dra));\n-          dump_printf (MSG_MISSED_OPTIMIZATION,  \" and \");\n-          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (drb));\n-          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-        }\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"versioning for alias required: \"\n+\t\t\t \"bad dist vector for %T and %T\\n\",\n+\t\t\t DR_REF (dra), DR_REF (drb));\n       /* Add to list of ddrs that need to be tested at run-time.  */\n       return !vect_mark_for_runtime_alias_test (ddr, loop_vinfo);\n     }\n@@ -445,14 +417,9 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n       if (dist == 0)\n \t{\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t                       \"dependence distance == 0 between \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n-\t      dump_printf (MSG_NOTE, \" and \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n-\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"dependence distance == 0 between %T and %T\\n\",\n+\t\t\t     DR_REF (dra), DR_REF (drb));\n \n \t  /* When we perform grouped accesses and perform implicit CSE\n \t     by detecting equal accesses and doing disambiguation with\n@@ -537,15 +504,10 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t}\n \n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t               \"not vectorized, possible dependence \"\n-\t               \"between data-refs \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n-\t  dump_printf (MSG_NOTE,  \" and \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n-\t  dump_printf (MSG_NOTE,  \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized, possible dependence \"\n+\t\t\t \"between data-refs %T and %T\\n\",\n+\t\t\t DR_REF (dra), DR_REF (drb));\n \n       return true;\n     }\n@@ -639,24 +601,14 @@ vect_slp_analyze_data_ref_dependence (vec_info *vinfo,\n   if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n     {\n       if  (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"can't determine dependence between \");\n-\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (dra));\n-\t  dump_printf (MSG_MISSED_OPTIMIZATION,  \" and \");\n-\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (drb));\n-\t  dump_printf (MSG_MISSED_OPTIMIZATION,  \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"can't determine dependence between %T and %T\\n\",\n+\t\t\t DR_REF (dra), DR_REF (drb));\n     }\n   else if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"determined dependence between \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n-      dump_printf (MSG_NOTE, \" and \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n-      dump_printf (MSG_NOTE,  \"\\n\");\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"determined dependence between %T and %T\\n\",\n+\t\t     DR_REF (dra), DR_REF (drb));\n \n   return true;\n }\n@@ -814,19 +766,15 @@ vect_record_base_alignment (stmt_vec_info stmt_info,\n     {\n       entry = drb;\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"recording new base alignment for \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, drb->base_address);\n-\t  dump_printf (MSG_NOTE, \"\\n\");\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"  alignment:    %d\\n\", drb->base_alignment);\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"  misalignment: %d\\n\", drb->base_misalignment);\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"  based on:     \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"recording new base alignment for %T\\n\"\n+\t\t\t \"  alignment:    %d\\n\"\n+\t\t\t \"  misalignment: %d\\n\"\n+\t\t\t \"  based on:     %G\",\n+\t\t\t drb->base_address,\n+\t\t\t drb->base_alignment,\n+\t\t\t drb->base_misalignment,\n+\t\t\t stmt_info->stmt);\n     }\n }\n \n@@ -977,12 +925,8 @@ vect_compute_data_ref_alignment (dr_vec_info *dr_info)\n       || TREE_CODE (drb->step) != INTEGER_CST)\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t                   \"Unknown alignment for access: \");\n-\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, ref);\n-\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"Unknown alignment for access: %T\\n\", ref);\n       return;\n     }\n \n@@ -995,24 +939,17 @@ vect_compute_data_ref_alignment (dr_vec_info *dr_info)\n \t\t\t\t\t     vector_alignment * BITS_PER_UNIT))\n \t{\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t                       \"can't force alignment of ref: \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, ref);\n-\t      dump_printf (MSG_NOTE, \"\\n\");\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"can't force alignment of ref: %T\\n\", ref);\n \t  return;\n \t}\n \n       /* Force the alignment of the decl.\n \t NOTE: This is the only change to the code we make during\n \t the analysis phase, before deciding to vectorize the loop.  */\n       if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_NOTE, vect_location, \"force alignment of \");\n-          dump_generic_expr (MSG_NOTE, TDF_SLIM, ref);\n-          dump_printf (MSG_NOTE, \"\\n\");\n-        }\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"force alignment of %T\\n\", ref);\n \n       dr_info->base_decl = base;\n       dr_info->base_misaligned = true;\n@@ -1034,25 +971,17 @@ vect_compute_data_ref_alignment (dr_vec_info *dr_info)\n \t\t\t   &const_misalignment))\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"Non-constant misalignment for access: \");\n-\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, ref);\n-\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"Non-constant misalignment for access: %T\\n\", ref);\n       return;\n     }\n \n   SET_DR_MISALIGNMENT (dr_info, const_misalignment);\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t       \"misalign = %d bytes of ref \",\n-\t\t       DR_MISALIGNMENT (dr_info));\n-      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, ref);\n-      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-    }\n+    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t     \"misalign = %d bytes of ref %T\\n\",\n+\t\t     DR_MISALIGNMENT (dr_info), ref);\n \n   return;\n }\n@@ -1143,9 +1072,7 @@ verify_data_ref_alignment (dr_vec_info *dr_info)\n \t\t\t     \"not vectorized: unsupported unaligned \"\n \t\t\t     \"store.\");\n \n-\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t     DR_REF (dr_info->dr));\n-\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n+\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"%T\\n\", DR_REF (dr_info->dr));\n \t}\n       return false;\n     }\n@@ -2337,14 +2264,9 @@ vect_find_same_alignment_drs (vec_info *vinfo, data_dependence_relation *ddr)\n   STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_a).safe_push (drb);\n   STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_b).safe_push (dra);\n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"accesses have the same alignment: \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n-      dump_printf (MSG_NOTE,  \" and \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n-      dump_printf (MSG_NOTE, \"\\n\");\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"accesses have the same alignment: %T and %T\\n\",\n+\t\t     DR_REF (dra), DR_REF (drb));\n }\n \n \n@@ -2474,15 +2396,10 @@ vect_analyze_group_access_1 (dr_vec_info *dr_info)\n       if ((dr_step % type_size) != 0)\n \t{\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t                       \"Step \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, step);\n-\t      dump_printf (MSG_NOTE,\n-\t\t\t   \" is not a multiple of the element size for \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr));\n-\t      dump_printf (MSG_NOTE, \"\\n\");\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Step %T is not a multiple of the element size\"\n+\t\t\t     \" for %T\\n\",\n+\t\t\t     step, DR_REF (dr));\n \t  return false;\n \t}\n       groupsize = absu_hwi (dr_step) / type_size;\n@@ -2506,25 +2423,17 @@ vect_analyze_group_access_1 (dr_vec_info *dr_info)\n \t  DR_GROUP_SIZE (stmt_info) = groupsize;\n \t  DR_GROUP_GAP (stmt_info) = groupsize - 1;\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t                       \"Detected single element interleaving \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr));\n-\t      dump_printf (MSG_NOTE, \" step \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, step);\n-\t      dump_printf (MSG_NOTE, \"\\n\");\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Detected single element interleaving %T\"\n+\t\t\t     \" step %T\\n\",\n+\t\t\t     DR_REF (dr), step);\n \n \t  return true;\n \t}\n \n       if (dump_enabled_p ())\n-        {\n- \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t                   \"not consecutive access \");\n-\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t    stmt_info->stmt, 0);\n-        }\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not consecutive access %G\", stmt_info->stmt);\n \n       if (bb_vinfo)\n \t{\n@@ -2654,9 +2563,8 @@ vect_analyze_group_access_1 (dr_vec_info *dr_info)\n \t    dump_printf (MSG_NOTE, \"strided store \");\n \t  else\n \t    dump_printf (MSG_NOTE, \"store \");\n-\t  dump_printf (MSG_NOTE, \"of size %u starting with \",\n-\t\t       (unsigned)groupsize);\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n+\t  dump_printf (MSG_NOTE, \"of size %u starting with %G\",\n+\t\t       (unsigned)groupsize, stmt_info->stmt);\n \t  if (DR_GROUP_GAP (stmt_info) != 0)\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"There is a gap of %u elements after the group\\n\",\n@@ -3049,18 +2957,11 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t    }\n \n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t       \"Detected interleaving \");\n-\t      if (DR_IS_READ (dra))\n-\t\tdump_printf (MSG_NOTE, \"load \");\n-\t      else\n-\t\tdump_printf (MSG_NOTE, \"store \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n-\t      dump_printf (MSG_NOTE,  \" and \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n-\t      dump_printf (MSG_NOTE, \"\\n\");\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     DR_IS_READ (dra)\n+\t\t\t     ? \"Detected interleaving load %T and %T\\n\"\n+\t\t\t     : \"Detected interleaving store %T and %T\\n\",\n+\t\t\t     DR_REF (dra), DR_REF (drb));\n \n \t  /* Link the found element into the group list.  */\n \t  if (!DR_GROUP_FIRST_ELEMENT (stmtinfo_a))\n@@ -3236,14 +3137,9 @@ dependence_distance_ge_vf (data_dependence_relation *ddr,\n     }\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"dependence distance between \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_A (ddr)));\n-      dump_printf (MSG_NOTE,  \" and \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_B (ddr)));\n-      dump_printf (MSG_NOTE,  \" is >= VF\\n\");\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"dependence distance between %T and %T is >= VF\\n\",\n+\t\t     DR_REF (DDR_A (ddr)), DR_REF (DDR_B (ddr)));\n \n   return true;\n }\n@@ -3253,9 +3149,9 @@ dependence_distance_ge_vf (data_dependence_relation *ddr,\n static void\n dump_lower_bound (dump_flags_t dump_kind, const vec_lower_bound &lower_bound)\n {\n-  dump_printf (dump_kind, \"%s (\", lower_bound.unsigned_p ? \"unsigned\" : \"abs\");\n-  dump_generic_expr (dump_kind, TDF_SLIM, lower_bound.expr);\n-  dump_printf (dump_kind, \") >= \");\n+  dump_printf (dump_kind, \"%s (%T) >= \",\n+\t       lower_bound.unsigned_p ? \"unsigned\" : \"abs\",\n+\t       lower_bound.expr);\n   dump_dec (dump_kind, lower_bound.min_value);\n }\n \n@@ -3424,13 +3320,10 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t  if (!compared_objects.add (new_pair))\n \t    {\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_NOTE, vect_location, \"checking that \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, new_pair.first);\n-\t\t  dump_printf (MSG_NOTE, \" and \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, new_pair.second);\n-\t\t  dump_printf (MSG_NOTE, \" have different addresses\\n\");\n-\t\t}\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"checking that %T and %T\"\n+\t\t\t\t \" have different addresses\\n\",\n+\t\t\t\t new_pair.first, new_pair.second);\n \t      LOOP_VINFO_CHECK_UNEQUAL_ADDRS (loop_vinfo).safe_push (new_pair);\n \t    }\n \t  continue;\n@@ -3450,14 +3343,10 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t\t\t\t\t\t &lower_bound)))\n \t{\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t       \"no need for alias check between \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_info_a->dr));\n-\t      dump_printf (MSG_NOTE, \" and \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_info_b->dr));\n-\t      dump_printf (MSG_NOTE, \" when VF is 1\\n\");\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"no need for alias check between \"\n+\t\t\t     \"%T and %T when VF is 1\\n\",\n+\t\t\t     DR_REF (dr_info_a->dr), DR_REF (dr_info_b->dr));\n \t  continue;\n \t}\n \n@@ -3475,13 +3364,11 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t  bool unsigned_p = dr_known_forward_stride_p (dr_info_a->dr);\n \t  if (dump_enabled_p ())\n \t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location, \"no alias between \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_info_a->dr));\n-\t      dump_printf (MSG_NOTE, \" and \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_info_b->dr));\n-\t      dump_printf (MSG_NOTE, \" when the step \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_STEP (dr_info_a->dr));\n-\t      dump_printf (MSG_NOTE, \" is outside \");\n+\t      dump_printf_loc (MSG_NOTE, vect_location, \"no alias between \"\n+\t\t\t       \"%T and %T when the step %T is outside \",\n+\t\t\t       DR_REF (dr_info_a->dr),\n+\t\t\t       DR_REF (dr_info_b->dr),\n+\t\t\t       DR_STEP (dr_info_a->dr));\n \t      if (unsigned_p)\n \t\tdump_printf (MSG_NOTE, \"[0\");\n \t      else\n@@ -3553,10 +3440,8 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t  if (res >= 0 && dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t       \"can tell at compile time that \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_info_a->dr));\n-\t      dump_printf (MSG_NOTE, \" and \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_info_b->dr));\n+\t\t\t       \"can tell at compile time that %T and %T\",\n+\t\t\t       DR_REF (dr_info_a->dr), DR_REF (dr_info_b->dr));\n \t      if (res == 0)\n \t\tdump_printf (MSG_NOTE, \" do not alias\\n\");\n \t      else\n@@ -3974,23 +3859,17 @@ vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n   if (gimple_has_volatile_ops (stmt))\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"not vectorized: volatile type \");\n-\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: volatile type %G\", stmt);\n       return false;\n     }\n \n   if (stmt_can_throw_internal (stmt))\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"not vectorized: statement can throw an \"\n-\t\t\t   \"exception \");\n-\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: statement can throw an exception %G\",\n+\t\t\t stmt);\n       return false;\n     }\n \n@@ -4004,12 +3883,9 @@ vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n   if (refs.length () > 1)\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"not vectorized: more than one data ref \"\n-\t\t\t   \"in stmt: \");\n-\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: more than one data ref \"\n+\t\t\t \"in stmt: %G\", stmt);\n       return false;\n     }\n \n@@ -4019,11 +3895,8 @@ vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n \t    && gimple_call_internal_fn (call) != IFN_MASK_STORE))\n       {\n \tif (dump_enabled_p ())\n-\t  {\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION,  vect_location,\n-\t\t\t     \"not vectorized: dr in a call \");\n-\t    dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-\t  }\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION,  vect_location,\n+\t\t\t   \"not vectorized: dr in a call %G\", stmt);\n \treturn false;\n       }\n \n@@ -4032,12 +3905,9 @@ vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n       && DECL_BIT_FIELD (TREE_OPERAND (DR_REF (dr), 1)))\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"not vectorized: statement is bitfield \"\n-\t\t\t   \"access \");\n-\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: statement is bitfield \"\n+\t\t\t \"access %G\", stmt);\n       return false;\n     }\n \n@@ -4194,13 +4064,9 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t  if (gatherscatter == SG_NONE)\n \t    {\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                   \"not vectorized: data ref analysis \"\n-                                   \"failed \");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t    stmt_info->stmt, 0);\n-\t\t}\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"not vectorized: data ref analysis \"\n+\t\t\t\t \"failed %G\", stmt_info->stmt);\n \t      if (is_a <bb_vec_info> (vinfo))\n \t\t{\n \t\t  /* In BB vectorization the ref can still participate\n@@ -4218,13 +4084,9 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t  if (nested_in_vect_loop_p (loop, stmt_info))\n \t    {\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t   \"not vectorized: data ref analysis \"\n-\t\t\t\t   \"failed \");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t    stmt_info->stmt, 0);\n-\t\t}\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"not vectorized: data ref analysis \"\n+\t\t\t\t \"failed %G\", stmt_info->stmt);\n \t      return false;\n \t    }\n \t  STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) = true;\n@@ -4234,13 +4096,9 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n       if (base && VAR_P (base) && DECL_NONALIASED (base))\n \t{\n           if (dump_enabled_p ())\n-            {\n-              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                               \"not vectorized: base object not addressable \"\n-\t\t\t       \"for stmt: \");\n-\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\tstmt_info->stmt, 0);\n-            }\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: base object not addressable \"\n+\t\t\t     \"for stmt: %G\", stmt_info->stmt);\n           if (is_a <bb_vec_info> (vinfo))\n \t    {\n \t      /* In BB vectorization the ref can still participate\n@@ -4258,13 +4116,9 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t  if (nested_in_vect_loop_p (loop, stmt_info))\n \t    {\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                                   \"not vectorized: not suitable for strided \"\n-                                   \"load \");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t    stmt_info->stmt, 0);\n-\t\t}\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"not vectorized: not suitable for strided \"\n+\t\t\t\t \"load %G\", stmt_info->stmt);\n \t      return false;\n \t    }\n \t  STMT_VINFO_STRIDED_P (stmt_info) = true;\n@@ -4293,43 +4147,32 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t  tree init_ref = build_fold_indirect_ref (init_addr);\n \n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-                               \"analyze in outer loop: \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, init_ref);\n-\t      dump_printf (MSG_NOTE, \"\\n\");\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"analyze in outer loop: %T\\n\", init_ref);\n \n \t  if (!dr_analyze_innermost (&STMT_VINFO_DR_WRT_VEC_LOOP (stmt_info),\n \t\t\t\t     init_ref, loop))\n \t    /* dr_analyze_innermost already explained the failure.  */\n \t    return false;\n \n           if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-                               \"\\touter base_address: \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-                                 STMT_VINFO_DR_BASE_ADDRESS (stmt_info));\n-\t      dump_printf (MSG_NOTE, \"\\n\\touter offset from base address: \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-                                 STMT_VINFO_DR_OFFSET (stmt_info));\n-\t      dump_printf (MSG_NOTE,\n-                           \"\\n\\touter constant offset from base address: \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-                                 STMT_VINFO_DR_INIT (stmt_info));\n-\t      dump_printf (MSG_NOTE, \"\\n\\touter step: \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-                                 STMT_VINFO_DR_STEP (stmt_info));\n-\t      dump_printf (MSG_NOTE, \"\\n\\touter base alignment: %d\\n\",\n-\t\t\t   STMT_VINFO_DR_BASE_ALIGNMENT (stmt_info));\n-\t      dump_printf (MSG_NOTE, \"\\n\\touter base misalignment: %d\\n\",\n-\t\t\t   STMT_VINFO_DR_BASE_MISALIGNMENT (stmt_info));\n-\t      dump_printf (MSG_NOTE, \"\\n\\touter offset alignment: %d\\n\",\n-\t\t\t   STMT_VINFO_DR_OFFSET_ALIGNMENT (stmt_info));\n-\t      dump_printf (MSG_NOTE, \"\\n\\touter step alignment: %d\\n\",\n-\t\t\t   STMT_VINFO_DR_STEP_ALIGNMENT (stmt_info));\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"\\touter base_address: %T\\n\"\n+\t\t\t     \"\\touter offset from base address: %T\\n\"\n+\t\t\t     \"\\touter constant offset from base address: %T\\n\"\n+\t\t\t     \"\\touter step: %T\\n\"\n+\t\t\t     \"\\touter base alignment: %d\\n\\n\"\n+\t\t\t     \"\\touter base misalignment: %d\\n\"\n+\t\t\t     \"\\touter offset alignment: %d\\n\"\n+\t\t\t     \"\\touter step alignment: %d\\n\",\n+\t\t\t     STMT_VINFO_DR_BASE_ADDRESS (stmt_info),\n+\t\t\t     STMT_VINFO_DR_OFFSET (stmt_info),\n+\t\t\t     STMT_VINFO_DR_INIT (stmt_info),\n+\t\t\t     STMT_VINFO_DR_STEP (stmt_info),\n+\t\t\t     STMT_VINFO_DR_BASE_ALIGNMENT (stmt_info),\n+\t\t\t     STMT_VINFO_DR_BASE_MISALIGNMENT (stmt_info),\n+\t\t\t     STMT_VINFO_DR_OFFSET_ALIGNMENT (stmt_info),\n+\t\t\t     STMT_VINFO_DR_STEP_ALIGNMENT (stmt_info));\n \t}\n \n       /* Set vectype for STMT.  */\n@@ -4341,9 +4184,8 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n           if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                               \"not vectorized: no vectype for stmt: \");\n-\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\tstmt_info->stmt, 0);\n+                               \"not vectorized: no vectype for stmt: %G\",\n+\t\t\t       stmt_info->stmt);\n               dump_printf (MSG_MISSED_OPTIMIZATION, \" scalar_type: \");\n               dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_DETAILS,\n                                  scalar_type);\n@@ -4362,14 +4204,9 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n       else\n \t{\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t       \"got vectype for stmt: \");\n-\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-\t\t\t\t STMT_VINFO_VECTYPE (stmt_info));\n-\t      dump_printf (MSG_NOTE, \"\\n\");\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"got vectype for stmt: %G%T\\n\",\n+\t\t\t     stmt_info->stmt, STMT_VINFO_VECTYPE (stmt_info));\n \t}\n \n       /* Adjust the minimal vectorization factor according to the\n@@ -4386,16 +4223,13 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t      || !get_vectype_for_scalar_type (TREE_TYPE (gs_info.offset)))\n \t    {\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t   (gatherscatter == GATHER) ?\n-\t\t\t\t   \"not vectorized: not suitable for gather \"\n-\t\t\t\t   \"load \" :\n-\t\t\t\t   \"not vectorized: not suitable for scatter \"\n-\t\t\t\t   \"store \");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t    stmt_info->stmt, 0);\n-\t\t}\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t (gatherscatter == GATHER) ?\n+\t\t\t\t \"not vectorized: not suitable for gather \"\n+\t\t\t\t \"load %G\" :\n+\t\t\t\t \"not vectorized: not suitable for scatter \"\n+\t\t\t\t \"store %G\",\n+\t\t\t\t stmt_info->stmt);\n \t      return false;\n \t    }\n \t  STMT_VINFO_GATHER_SCATTER_P (stmt_info) = gatherscatter;\n@@ -4610,11 +4444,7 @@ vect_create_addr_base_for_vector_ref (stmt_vec_info stmt_info,\n     }\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"created \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, addr_base);\n-      dump_printf (MSG_NOTE, \"\\n\");\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location, \"created %T\\n\", addr_base);\n \n   return addr_base;\n }\n@@ -4728,9 +4558,9 @@ vect_create_data_ref_ptr (stmt_vec_info stmt_info, tree aggr_type,\n     {\n       tree dr_base_type = TREE_TYPE (DR_BASE_OBJECT (dr));\n       dump_printf_loc (MSG_NOTE, vect_location,\n-                       \"create %s-pointer variable to type: \",\n-\t\t       get_tree_code_name (TREE_CODE (aggr_type)));\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, aggr_type);\n+                       \"create %s-pointer variable to type: %T\",\n+\t\t       get_tree_code_name (TREE_CODE (aggr_type)),\n+\t\t       aggr_type);\n       if (TREE_CODE (dr_base_type) == ARRAY_TYPE)\n         dump_printf (MSG_NOTE, \"  vectorizing an array ref: \");\n       else if (TREE_CODE (dr_base_type) == VECTOR_TYPE)\n@@ -4739,8 +4569,7 @@ vect_create_data_ref_ptr (stmt_vec_info stmt_info, tree aggr_type,\n         dump_printf (MSG_NOTE, \"  vectorizing a record based array ref: \");\n       else\n         dump_printf (MSG_NOTE, \"  vectorizing a pointer ref: \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_BASE_OBJECT (dr));\n-      dump_printf (MSG_NOTE, \"\\n\");\n+      dump_printf (MSG_NOTE, \"%T\\n\", DR_BASE_OBJECT (dr));\n     }\n \n   /* (1) Create the new aggregate-pointer variable."}, {"sha": "a93c6eecb520dbcad43aed54886928b0468d9a72", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b", "patch": "@@ -943,10 +943,8 @@ vect_set_loop_condition (struct loop *loop, loop_vec_info loop_vinfo,\n     gsi_remove (&loop_cond_gsi, true);\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"New loop exit condition: \");\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, cond_stmt, 0);\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location, \"New loop exit condition: %G\",\n+\t\t     cond_stmt);\n }\n \n /* Helper routine of slpeel_tree_duplicate_loop_to_edge_cfg.\n@@ -1383,10 +1381,8 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n       gphi *phi = gsi.phi ();\n       stmt_vec_info phi_info = loop_vinfo->lookup_stmt (phi);\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi_info->stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: %G\",\n+\t\t\t phi_info->stmt);\n \n       /* Skip virtual phi's. The data dependences that are associated with\n \t virtual defs/uses (i.e., memory accesses) are analyzed elsewhere.\n@@ -1506,11 +1502,8 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo,\n       gphi *phi1 = gsi1.phi ();\n       stmt_vec_info phi_info = loop_vinfo->lookup_stmt (phi);\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"vect_update_ivs_after_vectorizer: phi: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"vect_update_ivs_after_vectorizer: phi: %G\", phi);\n \n       /* Skip reduction and virtual phis.  */\n       if (!iv_phi_p (phi_info))\n@@ -1677,12 +1670,8 @@ vect_gen_prolog_loop_niters (loop_vec_info loop_vinfo,\n     }\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-                       \"niters for prolog loop: \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, iters);\n-      dump_printf (MSG_NOTE, \"\\n\");\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"niters for prolog loop: %T\\n\", iters);\n \n   var = create_tmp_var (niters_type, \"prolog_loop_niters\");\n   iters_name = force_gimple_operand (iters, &new_stmts, false, var);\n@@ -1801,12 +1790,9 @@ vect_prepare_for_masked_peels (loop_vec_info loop_vinfo)\n     }\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"misalignment for fully-masked loop: \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, misalign_in_elems);\n-      dump_printf (MSG_NOTE, \"\\n\");\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"misalignment for fully-masked loop: %T\\n\",\n+\t\t     misalign_in_elems);\n \n   LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo) = misalign_in_elems;\n "}, {"sha": "640b0b9700c747966fe9914bb59144b9608100a4", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 63, "deletions": 152, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b", "patch": "@@ -215,10 +215,8 @@ vect_determine_vf_for_stmt (stmt_vec_info stmt_info, poly_uint64 *vf,\n {\n   vec_info *vinfo = stmt_info->vinfo;\n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"==> examining statement: \");\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location, \"==> examining statement: %G\",\n+\t\t     stmt_info->stmt);\n   if (!vect_determine_vf_for_stmt_1 (stmt_info, false, vf, mask_producers))\n     return false;\n \n@@ -234,23 +232,18 @@ vect_determine_vf_for_stmt (stmt_vec_info stmt_info, poly_uint64 *vf,\n \t{\n \t  stmt_vec_info def_stmt_info = vinfo->lookup_stmt (gsi_stmt (si));\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t       \"==> examining pattern def stmt: \");\n-\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n-\t\t\t\tdef_stmt_info->stmt, 0);\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"==> examining pattern def stmt: %G\",\n+\t\t\t     def_stmt_info->stmt);\n \t  if (!vect_determine_vf_for_stmt_1 (def_stmt_info, true,\n \t\t\t\t\t     vf, mask_producers))\n \t    return false;\n \t}\n \n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"==> examining pattern statement: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"==> examining pattern statement: %G\",\n+\t\t\t stmt_info->stmt);\n       if (!vect_determine_vf_for_stmt_1 (stmt_info, true, vf, mask_producers))\n \treturn false;\n     }\n@@ -309,10 +302,8 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t  phi = si.phi ();\n \t  stmt_info = loop_vinfo->lookup_stmt (phi);\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location, \"==> examining phi: \");\n-\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location, \"==> examining phi: %G\",\n+\t\t\t     phi);\n \n \t  gcc_assert (stmt_info);\n \n@@ -323,35 +314,25 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n               scalar_type = TREE_TYPE (PHI_RESULT (phi));\n \n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n-                                   \"get vectype for scalar type:  \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n-                  dump_printf (MSG_NOTE, \"\\n\");\n-\t\t}\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"get vectype for scalar type:  %T\\n\",\n+\t\t\t\t scalar_type);\n \n \t      vectype = get_vectype_for_scalar_type (scalar_type);\n \t      if (!vectype)\n \t\t{\n \t\t  if (dump_enabled_p ())\n-\t\t    {\n-\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                       \"not vectorized: unsupported \"\n-                                       \"data-type \");\n-\t\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-                                         scalar_type);\n-                      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t\t    }\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"not vectorized: unsupported \"\n+\t\t\t\t     \"data-type %T\\n\",\n+\t\t\t\t     scalar_type);\n \t\t  return false;\n \t\t}\n \t      STMT_VINFO_VECTYPE (stmt_info) = vectype;\n \n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_NOTE, vect_location, \"vectype: \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, vectype);\n-                  dump_printf (MSG_NOTE, \"\\n\");\n-\t\t}\n+\t\tdump_printf_loc (MSG_NOTE, vect_location, \"vectype: %T\\n\",\n+\t\t\t\t vectype);\n \n \t      if (dump_enabled_p ())\n \t\t{\n@@ -432,13 +413,8 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n   init_expr = unshare_expr (initial_condition_in_loop_num (access_fn, loop_nb));\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"step: \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, step_expr);\n-      dump_printf (MSG_NOTE, \",  init: \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, init_expr);\n-      dump_printf (MSG_NOTE, \"\\n\");\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location, \"step: %T,  init: %T\\n\",\n+\t\t     step_expr, init_expr);\n \n   *init = init_expr;\n   *step = step_expr;\n@@ -525,10 +501,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n       stmt_vec_info stmt_vinfo = loop_vinfo->lookup_stmt (phi);\n \n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: %G\", phi);\n \n       /* Skip virtual phi's.  The data dependences that are associated with\n          virtual defs/uses (i.e., memory accesses) are analyzed elsewhere.  */\n@@ -543,12 +516,8 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n \t{\n \t  STRIP_NOPS (access_fn);\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-                               \"Access function of PHI: \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, access_fn);\n-              dump_printf (MSG_NOTE, \"\\n\");\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Access function of PHI: %T\\n\", access_fn);\n \t  STMT_VINFO_LOOP_PHI_EVOLUTION_BASE_UNCHANGED (stmt_vinfo)\n \t    = initial_condition_in_loop_num (access_fn, loop->num);\n \t  STMT_VINFO_LOOP_PHI_EVOLUTION_PART (stmt_vinfo)\n@@ -583,10 +552,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n       tree def = PHI_RESULT (phi);\n \n       if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: \");\n-          dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n-        }\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: %G\", phi);\n \n       gcc_assert (!virtual_operand_p (def)\n \t\t  && STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_unknown_def_type);\n@@ -1551,10 +1517,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n \n \t  stmt_info = loop_vinfo->lookup_stmt (phi);\n           if (dump_enabled_p ())\n-            {\n-              dump_printf_loc (MSG_NOTE, vect_location, \"examining phi: \");\n-              dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n-            }\n+\t    dump_printf_loc (MSG_NOTE, vect_location, \"examining phi: %G\", phi);\n \t  if (virtual_operand_p (gimple_phi_result (phi)))\n \t    continue;\n \n@@ -1636,12 +1599,9 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n           if (!ok)\n             {\n               if (dump_enabled_p ())\n-                {\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t   \"not vectorized: relevant phi not \"\n-\t\t\t\t   \"supported: \");\n-                  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, phi, 0);\n-                }\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"not vectorized: relevant phi not \"\n+\t\t\t\t \"supported: %G\", phi);\n \t      return false;\n             }\n         }\n@@ -2505,8 +2465,7 @@ neutral_op_for_slp_reduction (slp_tree slp_node, tree_code code,\n static void\n report_vect_op (dump_flags_t msg_type, gimple *stmt, const char *msg)\n {\n-  dump_printf_loc (msg_type, vect_location, \"%s\", msg);\n-  dump_gimple_stmt (msg_type, TDF_SLIM, stmt, 0);\n+  dump_printf_loc (msg_type, vect_location, \"%s%G\", msg, stmt);\n }\n \n /* DEF_STMT_INFO occurs in a loop that contains a potential reduction\n@@ -2666,10 +2625,8 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n \t      && vect_valid_reduction_input_p (def_stmt_info))\n   \t    {\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_NOTE, vect_location, \"swapping oprnds: \");\n-\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, next_stmt, 0);\n-\t\t}\n+\t\tdump_printf_loc (MSG_NOTE, vect_location, \"swapping oprnds: %G\",\n+\t\t\t\t next_stmt);\n \n \t      swap_ssa_operands (next_stmt,\n \t \t\t         gimple_assign_rhs1_ptr (next_stmt),\n@@ -2801,10 +2758,7 @@ check_reduction_path (dump_user_location_t loc, loop_p loop, gphi *phi,\n       unsigned i;\n       std::pair<ssa_op_iter, use_operand_p> *x;\n       FOR_EACH_VEC_ELT (path, i, x)\n-\t{\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, USE_FROM_PTR (x->second));\n-\t  dump_printf (MSG_NOTE, \" \");\n-\t}\n+\tdump_printf (MSG_NOTE, \"%T \", USE_FROM_PTR (x->second));\n       dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n@@ -2947,12 +2901,8 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n   if (TREE_CODE (loop_arg) != SSA_NAME)\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"reduction: not ssa_name: \");\n-\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, loop_arg);\n-          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"reduction: not ssa_name: %T\\n\", loop_arg);\n       return NULL;\n     }\n \n@@ -2974,12 +2924,9 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n   else\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"reduction: unhandled reduction operation: \");\n-\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t    def_stmt_info->stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"reduction: unhandled reduction operation: %G\",\n+\t\t\t def_stmt_info->stmt);\n       return NULL;\n     }\n \n@@ -3137,27 +3084,14 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n       if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"reduction: multiple types: operation type: \");\n-          dump_generic_expr (MSG_NOTE, TDF_SLIM, type);\n-          dump_printf (MSG_NOTE, \", operands types: \");\n-          dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-\t\t\t     TREE_TYPE (op1));\n-          dump_printf (MSG_NOTE, \",\");\n-          dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-\t\t\t     TREE_TYPE (op2));\n+\t\t\t   \"reduction: multiple types: operation type: \"\n+\t\t\t   \"%T, operands types: %T,%T\",\n+\t\t\t   type,  TREE_TYPE (op1), TREE_TYPE (op2));\n           if (op3)\n-            {\n-              dump_printf (MSG_NOTE, \",\");\n-              dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-\t\t\t\t TREE_TYPE (op3));\n-            }\n+\t    dump_printf (MSG_NOTE, \",%T\", TREE_TYPE (op3));\n \n           if (op4)\n-            {\n-              dump_printf (MSG_NOTE, \",\");\n-              dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-\t\t\t\t TREE_TYPE (op4));\n-            }\n+\t    dump_printf (MSG_NOTE, \",%T\", TREE_TYPE (op4));\n           dump_printf (MSG_NOTE, \"\\n\");\n         }\n \n@@ -4582,12 +4516,9 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n \t  add_phi_arg (phi, def, loop_latch_edge (loop), UNKNOWN_LOCATION);\n \n           if (dump_enabled_p ())\n-            {\n-              dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t       \"transform reduction: created def-use cycle: \");\n-              dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n-              dump_gimple_stmt (MSG_NOTE, TDF_SLIM, SSA_NAME_DEF_STMT (def), 0);\n-            }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"transform reduction: created def-use cycle: %G%G\",\n+\t\t\t     phi, SSA_NAME_DEF_STMT (def));\n         }\n     }\n \n@@ -5703,11 +5634,9 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n \t\t  add_phi_arg (vect_phi, PHI_RESULT (inner_phi->stmt),\n \t\t\t       loop_latch_edge (outer_loop), UNKNOWN_LOCATION);\n                   if (dump_enabled_p ())\n-                    {\n-                      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t       \"created double reduction phi node: \");\n-                      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, vect_phi, 0);\n-                    }\n+\t\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t     \"created double reduction phi node: %G\",\n+\t\t\t\t     vect_phi);\n \n                   vect_phi_res = PHI_RESULT (vect_phi);\n \n@@ -7783,23 +7712,17 @@ vectorizable_induction (stmt_vec_info stmt_info,\n \n \t  STMT_VINFO_VEC_STMT (stmt_vinfo) = new_stmt_info;\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t       \"vector of inductions after inner-loop:\");\n-\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, new_stmt, 0);\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"vector of inductions after inner-loop:%G\",\n+\t\t\t     new_stmt);\n \t}\n     }\n \n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"transform induction: created def-use cycle: \");\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, induction_phi, 0);\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n-\t\t\tSSA_NAME_DEF_STMT (vec_def), 0);\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"transform induction: created def-use cycle: %G%G\",\n+\t\t     induction_phi, SSA_NAME_DEF_STMT (vec_def));\n \n   return true;\n }\n@@ -8231,11 +8154,8 @@ vect_transform_loop_stmt (loop_vec_info loop_vinfo, stmt_vec_info stmt_info,\n   poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"------>vectorizing statement: \");\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"------>vectorizing statement: %G\", stmt_info->stmt);\n \n   if (MAY_HAVE_DEBUG_BIND_STMTS && !STMT_VINFO_LIVE_P (stmt_info))\n     vect_loop_kill_debug_uses (loop, stmt_info);\n@@ -8416,11 +8336,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n         {\n \t  gphi *phi = si.phi ();\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-                               \"------>vectorizing phi: \");\n-\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"------>vectorizing phi: %G\", phi);\n \t  stmt_info = loop_vinfo->lookup_stmt (phi);\n \t  if (!stmt_info)\n \t    continue;\n@@ -8790,11 +8707,8 @@ optimize_mask_stores (struct loop *loop)\n \t  /* Setup GSI_TO to the non-empty block start.  */\n \t  gsi_to = gsi_start_bb (store_bb);\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t       \"Move stmt to created bb\\n\");\n-\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, last, 0);\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Move stmt to created bb\\n%G\", last);\n \t  /* Move all stored value producers if possible.  */\n \t  while (!gsi_end_p (gsi))\n \t    {\n@@ -8858,11 +8772,8 @@ optimize_mask_stores (struct loop *loop)\n \n \t      /* Can move STMT1 to STORE_BB.  */\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t   \"Move stmt to created bb\\n\");\n-\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt1, 0);\n-\t\t}\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"Move stmt to created bb\\n%G\", stmt1);\n \t      gsi_move_before (&gsi_from, &gsi_to);\n \t      /* Shift GSI_TO for further insertion.  */\n \t      gsi_prev (&gsi_to);"}, {"sha": "7956c1326d34c1dc0b681b55c34d91933e87faf2", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 33, "deletions": 73, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b", "patch": "@@ -88,10 +88,7 @@ static void\n vect_pattern_detected (const char *name, gimple *stmt)\n {\n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"%s: detected: \", name);\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location, \"%s: detected: %G\", name, stmt);\n }\n \n /* Associate pattern statement PATTERN_STMT with ORIG_STMT_INFO and\n@@ -639,11 +636,8 @@ vect_split_statement (stmt_vec_info stmt2_info, tree new_rhs,\n       vect_init_pattern_stmt (stmt1, orig_stmt2_info, vectype);\n \n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"Splitting pattern statement: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt2_info->stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Splitting pattern statement: %G\", stmt2_info->stmt);\n \n       /* Since STMT2_INFO is a pattern statement, we can change it\n \t in-situ without worrying about changing the code for the\n@@ -652,10 +646,9 @@ vect_split_statement (stmt_vec_info stmt2_info, tree new_rhs,\n \n       if (dump_enabled_p ())\n \t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location, \"into: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt1, 0);\n-\t  dump_printf_loc (MSG_NOTE, vect_location, \"and: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt2_info->stmt, 0);\n+\t  dump_printf_loc (MSG_NOTE, vect_location, \"into: %G\", stmt1);\n+\t  dump_printf_loc (MSG_NOTE, vect_location, \"and: %G\",\n+\t\t\t   stmt2_info->stmt);\n \t}\n \n       gimple_seq *def_seq = &STMT_VINFO_PATTERN_DEF_SEQ (orig_stmt2_info);\n@@ -683,11 +676,8 @@ vect_split_statement (stmt_vec_info stmt2_info, tree new_rhs,\n \treturn false;\n \n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"Splitting statement: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt2_info->stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Splitting statement: %G\", stmt2_info->stmt);\n \n       /* Add STMT1 as a singleton pattern definition sequence.  */\n       gimple_seq *def_seq = &STMT_VINFO_PATTERN_DEF_SEQ (stmt2_info);\n@@ -702,10 +692,8 @@ vect_split_statement (stmt_vec_info stmt2_info, tree new_rhs,\n       if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"into pattern statements: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt1, 0);\n-\t  dump_printf_loc (MSG_NOTE, vect_location, \"and: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, new_stmt2, 0);\n+\t\t\t   \"into pattern statements: %G\", stmt1);\n+\t  dump_printf_loc (MSG_NOTE, vect_location, \"and: %G\", new_stmt2);\n \t}\n \n       return true;\n@@ -1662,13 +1650,8 @@ vect_recog_over_widening_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n     return NULL;\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"demoting \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, type);\n-      dump_printf (MSG_NOTE, \" to \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, new_type);\n-      dump_printf (MSG_NOTE, \"\\n\");\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location, \"demoting %T to %T\\n\",\n+\t\t     type, new_type);\n \n   /* Calculate the rhs operands for an operation on NEW_TYPE.  */\n   tree ops[3] = {};\n@@ -1684,11 +1667,8 @@ vect_recog_over_widening_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n   gimple_set_location (pattern_stmt, gimple_location (last_stmt));\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"created pattern stmt: \");\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"created pattern stmt: %G\", pattern_stmt);\n \n   pattern_stmt = vect_convert_output (last_stmt_info, type,\n \t\t\t\t      pattern_stmt, new_vectype);\n@@ -1831,11 +1811,8 @@ vect_recog_average_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n   gimple_set_location (average_stmt, gimple_location (last_stmt));\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"created pattern stmt: \");\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, average_stmt, 0);\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"created pattern stmt: %G\", average_stmt);\n \n   return vect_convert_output (last_stmt_info, type, average_stmt, new_vectype);\n }\n@@ -4411,12 +4388,9 @@ vect_determine_min_output_precision_1 (stmt_vec_info stmt_info, tree lhs)\n     }\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"only the low %d bits of \",\n-\t\t       precision);\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, lhs);\n-      dump_printf (MSG_NOTE, \" are significant\\n\");\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"only the low %d bits of %T are significant\\n\",\n+\t\t     precision, lhs);\n   stmt_info->min_output_precision = precision;\n   return true;\n }\n@@ -4524,13 +4498,10 @@ vect_determine_precisions_from_range (stmt_vec_info stmt_info, gassign *stmt)\n     return;\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"can narrow to %s:%d\"\n-\t\t       \" without loss of precision: \",\n-\t\t       sign == SIGNED ? \"signed\" : \"unsigned\",\n-\t\t       value_precision);\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location, \"can narrow to %s:%d\"\n+\t\t     \" without loss of precision: %G\",\n+\t\t     sign == SIGNED ? \"signed\" : \"unsigned\",\n+\t\t     value_precision, stmt);\n \n   vect_set_operation_type (stmt_info, type, value_precision, sign);\n   vect_set_min_input_precision (stmt_info, type, value_precision);\n@@ -4599,13 +4570,10 @@ vect_determine_precisions_from_users (stmt_vec_info stmt_info, gassign *stmt)\n   if (operation_precision < precision)\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location, \"can narrow to %s:%d\"\n-\t\t\t   \" without affecting users: \",\n-\t\t\t   TYPE_UNSIGNED (type) ? \"unsigned\" : \"signed\",\n-\t\t\t   operation_precision);\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"can narrow to %s:%d\"\n+\t\t\t \" without affecting users: %G\",\n+\t\t\t TYPE_UNSIGNED (type) ? \"unsigned\" : \"signed\",\n+\t\t\t operation_precision, stmt);\n       vect_set_operation_type (stmt_info, type, operation_precision,\n \t\t\t       TYPE_SIGN (type));\n     }\n@@ -4727,11 +4695,8 @@ vect_mark_pattern_stmts (stmt_vec_info orig_stmt_info, gimple *pattern_stmt,\n \t sequence.  */\n       orig_pattern_stmt = orig_stmt_info->stmt;\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"replacing earlier pattern \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, orig_pattern_stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"replacing earlier pattern %G\", orig_pattern_stmt);\n \n       /* To keep the book-keeping simple, just swap the lhs of the\n \t old and new statements, so that the old one has a valid but\n@@ -4741,10 +4706,7 @@ vect_mark_pattern_stmts (stmt_vec_info orig_stmt_info, gimple *pattern_stmt,\n       gimple_set_lhs (pattern_stmt, old_lhs);\n \n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location, \"with \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"with %G\", pattern_stmt);\n \n       /* Switch to the statement that ORIG replaces.  */\n       orig_stmt_info = STMT_VINFO_RELATED_STMT (orig_stmt_info);\n@@ -4830,11 +4792,9 @@ vect_pattern_recog_1 (vect_recog_func *recog_func, stmt_vec_info stmt_info)\n  \n   /* Found a vectorizable pattern.  */\n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-                       \"%s pattern recognized: \", recog_func->name);\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"%s pattern recognized: %G\",\n+\t\t     recog_func->name, pattern_stmt);\n \n   /* Mark the stmts that are involved in the pattern. */\n   vect_mark_pattern_stmts (stmt_info, pattern_stmt, pattern_vectype);"}, {"sha": "ae1c453c5df069858f97a50b6fb54c619d641959", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 80, "deletions": 162, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b", "patch": "@@ -368,12 +368,9 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n       if (!vect_is_simple_use (oprnd, vinfo, &dt, &def_stmt_info))\n \t{\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t       \"Build SLP failed: can't analyze def for \");\n-\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, oprnd);\n-              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t    }\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"Build SLP failed: can't analyze def for %T\\n\",\n+\t\t\t     oprnd);\n \n \t  return -1;\n \t}\n@@ -425,13 +422,9 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \t\t\t\t\t\t      TYPE_MODE (type))))\n \t    {\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t   \"Build SLP failed: invalid type of def \"\n-\t\t\t\t   \"for variable-length SLP \");\n-\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, oprnd);\n-\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t\t}\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"Build SLP failed: invalid type of def \"\n+\t\t\t\t \"for variable-length SLP %T\\n\", oprnd);\n \t      return -1;\n \t    }\n \t}\n@@ -452,12 +445,9 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \tdefault:\n \t  /* FORNOW: Not supported.  */\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t       \"Build SLP failed: illegal type of def \");\n-\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, oprnd);\n-              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t    }\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"Build SLP failed: illegal type of def %T\\n\",\n+\t\t\t     oprnd);\n \n \t  return -1;\n \t}\n@@ -471,13 +461,9 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n       if (STMT_VINFO_NUM_SLP_USES (stmt_info) != 0)\n \t{\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t       \"Build SLP failed: cannot swap operands of \"\n-\t\t\t       \"shared stmt \");\n-\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\tstmt_info->stmt, 0);\n-\t    }\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"Build SLP failed: cannot swap operands of \"\n+\t\t\t     \"shared stmt %G\", stmt_info->stmt);\n \t  return -1;\n \t}\n \n@@ -513,11 +499,9 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \t\t\t     gimple_op_ptr (stmt_info->stmt, op + 1));\n \t}\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"swapped operands to match def types in \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"swapped operands to match def types in %G\",\n+\t\t\t stmt_info->stmt);\n     }\n \n   *swap = swapped;\n@@ -573,13 +557,9 @@ vect_record_max_nunits (stmt_vec_info stmt_info, unsigned int group_size,\n   if (!vectype)\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"Build SLP failed: unsupported data-type in \");\n-\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t    stmt_info->stmt, 0);\n-\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"Build SLP failed: unsupported data-type in %G\\n\",\n+\t\t\t stmt_info->stmt);\n       /* Fatal mismatch.  */\n       return false;\n     }\n@@ -677,20 +657,15 @@ vect_build_slp_tree_1 (unsigned char *swap,\n       matches[i] = false;\n \n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location, \"Build SLP for \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"Build SLP for %G\", stmt);\n \n       /* Fail to vectorize statements marked as unvectorizable.  */\n       if (!STMT_VINFO_VECTORIZABLE (stmt_info))\n         {\n           if (dump_enabled_p ())\n-            {\n-              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t       \"Build SLP failed: unvectorizable statement \");\n-              dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-            }\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"Build SLP failed: unvectorizable statement %G\",\n+\t\t\t     stmt);\n \t  /* Fatal mismatch.  */\n \t  matches[0] = false;\n           return false;\n@@ -700,12 +675,9 @@ vect_build_slp_tree_1 (unsigned char *swap,\n       if (lhs == NULL_TREE)\n \t{\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t       \"Build SLP failed: not GIMPLE_ASSIGN nor \"\n-\t\t\t       \"GIMPLE_CALL \");\n-\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-\t    }\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"Build SLP failed: not GIMPLE_ASSIGN nor \"\n+\t\t\t     \"GIMPLE_CALL %G\", stmt);\n \t  /* Fatal mismatch.  */\n \t  matches[0] = false;\n \t  return false;\n@@ -737,12 +709,9 @@ vect_build_slp_tree_1 (unsigned char *swap,\n \t      || gimple_call_chain (call_stmt))\n \t    {\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-\t\t\t\t   \"Build SLP failed: unsupported call type \");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t    call_stmt, 0);\n-\t\t}\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"Build SLP failed: unsupported call type %G\",\n+\t\t\t\t call_stmt);\n \t      /* Fatal mismatch.  */\n \t      matches[0] = false;\n \t      return false;\n@@ -848,12 +817,9 @@ vect_build_slp_tree_1 (unsigned char *swap,\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t\t   \"Build SLP failed: different operation \"\n-\t\t\t\t   \"in stmt \");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t\t\t\t   \"in stmt %G\", stmt);\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t   \"original stmt \");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t    first_stmt_info->stmt, 0);\n+\t\t\t\t   \"original stmt %G\", first_stmt_info->stmt);\n \t\t}\n \t      /* Mismatch.  */\n \t      continue;\n@@ -863,12 +829,9 @@ vect_build_slp_tree_1 (unsigned char *swap,\n \t      && !operand_equal_p (first_op1, gimple_assign_rhs2 (stmt), 0))\n \t    {\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-\t\t\t\t   \"Build SLP failed: different shift \"\n-\t\t\t\t   \"arguments in \");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-\t\t}\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"Build SLP failed: different shift \"\n+\t\t\t\t \"arguments in %G\", stmt);\n \t      /* Mismatch.  */\n \t      continue;\n \t    }\n@@ -879,12 +842,9 @@ vect_build_slp_tree_1 (unsigned char *swap,\n \t\t\t\t       as_a <gcall *> (stmt)))\n \t\t{\n \t\t  if (dump_enabled_p ())\n-\t\t    {\n-\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-\t\t\t\t       \"Build SLP failed: different calls in \");\n-\t\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t\tstmt, 0);\n-\t\t    }\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"Build SLP failed: different calls in %G\",\n+\t\t\t\t     stmt);\n \t\t  /* Mismatch.  */\n \t\t  continue;\n \t\t}\n@@ -910,14 +870,11 @@ vect_build_slp_tree_1 (unsigned char *swap,\n                   if (prev_first_load != first_load)\n                     {\n                       if (dump_enabled_p ())\n-                        {\n-                          dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n-\t\t\t\t\t   vect_location, \n-\t\t\t\t\t   \"Build SLP failed: different \"\n-\t\t\t\t\t   \"interleaving chains in one node \");\n-                          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t\t    stmt, 0);\n-                        }\n+\t\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION,\n+\t\t\t\t\t vect_location,\n+\t\t\t\t\t \"Build SLP failed: different \"\n+\t\t\t\t\t \"interleaving chains in one node %G\",\n+\t\t\t\t\t stmt);\n \t\t      /* Mismatch.  */\n \t\t      continue;\n                     }\n@@ -932,11 +889,8 @@ vect_build_slp_tree_1 (unsigned char *swap,\n \t    {\n \t      /* Not grouped load.  */\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-\t\t\t\t   \"Build SLP failed: not grouped load \");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-\t\t}\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"Build SLP failed: not grouped load %G\", stmt);\n \n \t      /* FORNOW: Not grouped loads are not supported.  */\n \t      /* Fatal mismatch.  */\n@@ -952,12 +906,9 @@ vect_build_slp_tree_1 (unsigned char *swap,\n \t      && rhs_code != CALL_EXPR)\n \t    {\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t   \"Build SLP failed: operation\");\n-\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" unsupported \");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-\t\t}\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"Build SLP failed: operation unsupported %G\",\n+\t\t\t\t stmt);\n \t      /* Fatal mismatch.  */\n \t      matches[0] = false;\n \t      return false;\n@@ -990,13 +941,9 @@ vect_build_slp_tree_1 (unsigned char *swap,\n \t      else\n \t\t{\n \t\t  if (dump_enabled_p ())\n-\t\t    {\n-\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t       \"Build SLP failed: different\"\n-\t\t\t\t       \" operation\");\n-\t\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t\tstmt, 0);\n-\t\t    }\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"Build SLP failed: different\"\n+\t\t\t\t     \" operation %G\", stmt);\n \t\t  /* Mismatch.  */\n \t\t  continue;\n \t\t}\n@@ -1027,13 +974,9 @@ vect_build_slp_tree_1 (unsigned char *swap,\n \t\t  {\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t     \"Build SLP failed: different operation \"\n-\t\t\t\t     \"in stmt \");\n-\t\t    dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t      stmts[i]->stmt, 0);\n+\t\t\t\t     \"in stmt %G\", stmts[i]->stmt);\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t     \"original stmt \");\n-\t\t    dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t      first_stmt_info->stmt, 0);\n+\t\t\t\t     \"original stmt %G\", first_stmt_info->stmt);\n \t\t  }\n \t      }\n \t  return false;\n@@ -1370,14 +1313,11 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t      if (!swap_not_matching)\n \t\t\t{\n \t\t\t  if (dump_enabled_p ())\n-\t\t\t    {\n-\t\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n-\t\t\t\t\t       vect_location,\n-\t\t\t\t\t       \"Build SLP failed: cannot swap \"\n-\t\t\t\t\t       \"operands of shared stmt \");\n-\t\t\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION,\n-\t\t\t\t\t\tTDF_SLIM, stmts[j]->stmt, 0);\n-\t\t\t    }\n+\t\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n+\t\t\t\t\t     vect_location,\n+\t\t\t\t\t     \"Build SLP failed: cannot swap \"\n+\t\t\t\t\t     \"operands of shared stmt %G\",\n+\t\t\t\t\t     stmts[j]->stmt);\n \t\t\t  goto fail;\n \t\t\t}\n \t\t      swap_not_matching = false;\n@@ -1507,10 +1447,7 @@ vect_print_slp_tree (dump_flags_t dump_kind, dump_location_t loc,\n \t\t   SLP_TREE_DEF_TYPE (node) != vect_internal_def\n \t\t   ? \" (external)\" : \"\");\n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n-    {\n-      dump_printf_loc (dump_kind, loc, \"\\tstmt %d \", i);\n-      dump_gimple_stmt (dump_kind, TDF_SLIM, stmt_info->stmt, 0);\n-    }\n+    dump_printf_loc (dump_kind, loc, \"\\tstmt %d %G\", i, stmt_info->stmt);\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     vect_print_slp_tree (dump_kind, loc, child);\n }\n@@ -1901,12 +1838,9 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   if (!vectype)\n     {\n       if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"Build SLP failed: unsupported data-type \");\n-          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, scalar_type);\n-          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-        }\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"Build SLP failed: unsupported data-type %T\\n\",\n+\t\t\t scalar_type);\n \n       return false;\n     }\n@@ -2034,13 +1968,9 @@ vect_analyze_slp_instance (vec_info *vinfo,\n           if (!vect_supported_load_permutation_p (new_instance))\n             {\n               if (dump_enabled_p ())\n-                {\n-                  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t   \"Build SLP failed: unsupported load \"\n-\t\t\t\t   \"permutation \");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION,\n-\t\t\t\t    TDF_SLIM, stmt_info->stmt, 0);\n-                }\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"Build SLP failed: unsupported load \"\n+\t\t\t\t \"permutation %G\", stmt_info->stmt);\n \t      vect_free_slp_instance (new_instance, false);\n               return false;\n             }\n@@ -2276,11 +2206,8 @@ vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype)\n \t\t     && STMT_VINFO_DEF_TYPE (use_vinfo) == vect_reduction_def))\n \t      {\n \t\tif (dump_enabled_p ())\n-\t\t  {\n-\t\t    dump_printf_loc (MSG_NOTE, vect_location, \"use of SLP \"\n-\t\t\t\t     \"def in non-SLP stmt: \");\n-\t\t    dump_gimple_stmt (MSG_NOTE, TDF_SLIM, use_stmt, 0);\n-\t\t  }\n+\t\t  dump_printf_loc (MSG_NOTE, vect_location, \"use of SLP \"\n+\t\t\t\t   \"def in non-SLP stmt: %G\", use_stmt);\n \t\tstype = hybrid;\n \t      }\n \t  }\n@@ -2290,10 +2217,8 @@ vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype)\n       && !HYBRID_SLP_STMT (stmt_vinfo))\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location, \"marking hybrid: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_vinfo->stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"marking hybrid: %G\",\n+\t\t\t stmt_vinfo->stmt);\n       STMT_SLP_TYPE (stmt_vinfo) = hybrid;\n     }\n \n@@ -2317,10 +2242,8 @@ vect_detect_hybrid_slp_1 (tree *tp, int *, void *data)\n   if (def_stmt_info && PURE_SLP_STMT (def_stmt_info))\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location, \"marking hybrid: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, def_stmt_info->stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"marking hybrid: %G\",\n+\t\t\t def_stmt_info->stmt);\n       STMT_SLP_TYPE (def_stmt_info) = hybrid;\n     }\n \n@@ -2583,8 +2506,8 @@ vect_slp_analyze_operations (vec_info *vinfo)\n \t  slp_tree node = SLP_INSTANCE_TREE (instance);\n \t  stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"removing SLP instance operations starting from: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n+\t\t\t   \"removing SLP instance operations starting from: %G\",\n+\t\t\t   stmt_info->stmt);\n \t  vect_free_slp_instance (instance, false);\n           vinfo->slp_instances.ordered_remove (i);\n \t  cost_vec.release ();\n@@ -2863,8 +2786,8 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n \t  slp_tree node = SLP_INSTANCE_TREE (instance);\n \t  stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"removing SLP instance operations starting from: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n+\t\t\t   \"removing SLP instance operations starting from: %G\",\n+\t\t\t   stmt_info->stmt);\n \t  vect_free_slp_instance (instance, false);\n \t  BB_VINFO_SLP_INSTANCES (bb_vinfo).ordered_remove (i);\n \t  continue;\n@@ -3713,13 +3636,10 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \t  else\n \t    {\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t   \"permutation requires at \"\n-\t\t\t\t   \"least three vectors \");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t    stmt_info->stmt, 0);\n-\t\t}\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"permutation requires at \"\n+\t\t\t\t \"least three vectors %G\",\n+\t\t\t\t stmt_info->stmt);\n \t      gcc_assert (analyze_only);\n \t      return false;\n \t    }\n@@ -3858,11 +3778,9 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n     SLP_TREE_VEC_STMTS (node).create (SLP_TREE_NUMBER_OF_VEC_STMTS (node));\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE,vect_location,\n-\t\t       \"------>vectorizing SLP node starting from: \");\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"------>vectorizing SLP node starting from: %G\",\n+\t\t     stmt_info->stmt);\n \n   /* Vectorized stmts go before the last scalar stmt which is where\n      all uses are ready.  */"}, {"sha": "7a6efdb511714b88987dc3e38192779357c2032f", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 87, "deletions": 203, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b", "patch": "@@ -202,11 +202,9 @@ vect_mark_relevant (vec<stmt_vec_info> *worklist, stmt_vec_info stmt_info,\n   bool save_live_p = STMT_VINFO_LIVE_P (stmt_info);\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"mark relevant %d, live %d: \", relevant, live_p);\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"mark relevant %d, live %d: %G\", relevant, live_p,\n+\t\t     stmt_info->stmt);\n \n   /* If this stmt is an original stmt in a pattern, we might need to mark its\n      related pattern stmt instead of the original stmt.  However, such stmts\n@@ -633,10 +631,8 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t{\n \t  stmt_vec_info phi_info = loop_vinfo->lookup_stmt (gsi_stmt (si));\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location, \"init: phi relevant? \");\n-\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi_info->stmt, 0);\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location, \"init: phi relevant? %G\",\n+\t\t\t     phi_info->stmt);\n \n \t  if (vect_stmt_relevant_p (phi_info, loop_vinfo, &relevant, &live_p))\n \t    vect_mark_relevant (&worklist, phi_info, relevant, live_p);\n@@ -645,10 +641,8 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t{\n \t  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (gsi_stmt (si));\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location, \"init: stmt relevant? \");\n-\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n-\t    }\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"init: stmt relevant? %G\", stmt_info->stmt);\n \n \t  if (vect_stmt_relevant_p (stmt_info, loop_vinfo, &relevant, &live_p))\n \t    vect_mark_relevant (&worklist, stmt_info, relevant, live_p);\n@@ -663,11 +657,8 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \n       stmt_vec_info stmt_vinfo = worklist.pop ();\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"worklist: examine stmt: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_vinfo->stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"worklist: examine stmt: %G\", stmt_vinfo->stmt);\n \n       /* Examine the USEs of STMT. For each USE, mark the stmt that defines it\n \t (DEF_STMT) as relevant/irrelevant according to the relevance property\n@@ -1383,11 +1374,8 @@ vect_init_vector_1 (stmt_vec_info stmt_vinfo, gimple *new_stmt,\n     }\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-                       \"created new init_stmt: \");\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, new_stmt, 0);\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"created new init_stmt: %G\", new_stmt);\n }\n \n /* Function vect_init_vector.\n@@ -1539,22 +1527,15 @@ vect_get_vec_def_for_operand (tree op, stmt_vec_info stmt_vinfo, tree vectype)\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-                       \"vect_get_vec_def_for_operand: \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, op);\n-      dump_printf (MSG_NOTE, \"\\n\");\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"vect_get_vec_def_for_operand: %T\\n\", op);\n \n   stmt_vec_info def_stmt_info;\n   is_simple_use = vect_is_simple_use (op, loop_vinfo, &dt,\n \t\t\t\t      &def_stmt_info, &def_stmt);\n   gcc_assert (is_simple_use);\n   if (def_stmt && dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"  def_stmt =  \");\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, def_stmt, 0);\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location, \"  def_stmt =  %G\", def_stmt);\n \n   if (dt == vect_constant_def || dt == vect_external_def)\n     {\n@@ -1725,10 +1706,7 @@ vect_finish_stmt_generation_1 (stmt_vec_info stmt_info, gimple *vec_stmt)\n   stmt_vec_info vec_stmt_info = vinfo->add_stmt (vec_stmt);\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"add new stmt: \");\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, vec_stmt, 0);\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location, \"add new stmt: %G\", vec_stmt);\n \n   gimple_set_location (vec_stmt, gimple_location (stmt_info->stmt));\n \n@@ -2535,15 +2513,11 @@ vect_check_load_store_mask (stmt_vec_info stmt_info, tree mask,\n \t\tTYPE_VECTOR_SUBPARTS (vectype)))\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"vector mask type \");\n-\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, mask_vectype);\n-\t  dump_printf (MSG_MISSED_OPTIMIZATION,\n-\t\t       \" does not match vector data type \");\n-\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, vectype);\n-\t  dump_printf (MSG_MISSED_OPTIMIZATION, \".\\n\");\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"vector mask type %T\",\n+\t\t\t \" does not match vector data type %T.\\n\",\n+\t\t\t mask_vectype, vectype);\n+\n       return false;\n     }\n \n@@ -3222,12 +3196,8 @@ vectorizable_call (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   if (!vectype_in)\n     {\n       if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                           \"no vectype for scalar type \");\n-          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, rhs_type);\n-          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-        }\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"no vectype for scalar type %T\\n\", rhs_type);\n \n       return false;\n     }\n@@ -4716,12 +4686,8 @@ vectorizable_conversion (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   if (!vectype_in)\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                           \"no vectype for scalar type \");\n-\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, rhs_type);\n-          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"no vectype for scalar type %T\\n\", rhs_type);\n \n       return false;\n     }\n@@ -4730,13 +4696,9 @@ vectorizable_conversion (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       && !VECTOR_BOOLEAN_TYPE_P (vectype_in))\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                           \"can't convert between boolean and non \"\n-\t\t\t   \"boolean vectors\");\n-\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, rhs_type);\n-          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"can't convert between boolean and non \"\n+\t\t\t \"boolean vectors %T\\n\", rhs_type);\n \n       return false;\n     }\n@@ -5893,13 +5855,9 @@ vectorizable_operation (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   if (!vectype)\n     {\n       if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                           \"no vectype for scalar type \");\n-          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-                             TREE_TYPE (op0));\n-          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-        }\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"no vectype for scalar type %T\\n\",\n+\t\t\t TREE_TYPE (op0));\n \n       return false;\n     }\n@@ -7675,11 +7633,8 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t{\n \t  gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t       \"hoisting out of the vectorized loop: \");\n-\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-\t    }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"hoisting out of the vectorized loop: %G\", stmt);\n \t  scalar_dest = copy_ssa_name (scalar_dest);\n \t  tree rhs = unshare_expr (gimple_assign_rhs1 (stmt));\n \t  gsi_insert_on_edge_immediate\n@@ -9439,10 +9394,8 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n   gimple_seq pattern_def_seq;\n \n   if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"==> examining statement: \");\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n-    }\n+    dump_printf_loc (MSG_NOTE, vect_location, \"==> examining statement: %G\",\n+\t\t     stmt_info->stmt);\n \n   if (gimple_has_volatile_ops (stmt_info->stmt))\n     {\n@@ -9468,12 +9421,9 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n \t    {\n \t      /* Analyze def stmt of STMT if it's a pattern stmt.  */\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t   \"==> examining pattern def statement: \");\n-\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n-\t\t\t\t    pattern_def_stmt_info->stmt, 0);\n-\t\t}\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"==> examining pattern def statement: %G\",\n+\t\t\t\t pattern_def_stmt_info->stmt);\n \n \t      if (!vect_analyze_stmt (pattern_def_stmt_info,\n \t\t\t\t      need_to_vectorize, node, node_instance,\n@@ -9509,11 +9459,9 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n           /* Analyze PATTERN_STMT instead of the original stmt.  */\n \t  stmt_info = pattern_stmt_info;\n           if (dump_enabled_p ())\n-            {\n-              dump_printf_loc (MSG_NOTE, vect_location,\n-                               \"==> examining pattern statement: \");\n-\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n-            }\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"==> examining pattern statement: %G\",\n+\t\t\t     stmt_info->stmt);\n         }\n       else\n         {\n@@ -9531,11 +9479,9 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n     {\n       /* Analyze PATTERN_STMT too.  */\n       if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_NOTE, vect_location,\n-                           \"==> examining pattern statement: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt_info->stmt, 0);\n-        }\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"==> examining pattern statement: %G\",\n+\t\t\t pattern_stmt_info->stmt);\n \n       if (!vect_analyze_stmt (pattern_stmt_info, need_to_vectorize, node,\n \t\t\t      node_instance, cost_vec))\n@@ -9629,13 +9575,9 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n   if (!ok)\n     {\n       if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                           \"not vectorized: relevant stmt not \");\n-          dump_printf (MSG_MISSED_OPTIMIZATION, \"supported: \");\n-\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t    stmt_info->stmt, 0);\n-        }\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: relevant stmt not supported: %G\",\n+\t\t\t stmt_info->stmt);\n \n       return false;\n     }\n@@ -9647,12 +9589,9 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n       && !can_vectorize_live_stmts (stmt_info, NULL, node, NULL, cost_vec))\n     {\n       if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                           \"not vectorized: live stmt not supported: \");\n-\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t    stmt_info->stmt, 0);\n-        }\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: live stmt not supported: %G\",\n+\t\t\t stmt_info->stmt);\n \n        return false;\n     }\n@@ -10142,12 +10081,8 @@ vect_is_simple_use (tree operand, vec_info *vinfo, enum vect_def_type *dt,\n       *vectype = STMT_VINFO_VECTYPE (def_stmt_info);\n       gcc_assert (*vectype != NULL_TREE);\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"vect_is_simple_use: vectype \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, *vectype);\n-\t  dump_printf (MSG_NOTE, \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"vect_is_simple_use: vectype %T\\n\", *vectype);\n     }\n   else if (*dt == vect_uninitialized_def\n \t   || *dt == vect_constant_def\n@@ -10629,22 +10564,16 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \t}\n \n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"not vectorized: irregular stmt.\");\n-\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: irregular stmt.%G\", stmt);\n       return false;\n     }\n \n   if (VECTOR_MODE_P (TYPE_MODE (gimple_expr_type (stmt))))\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"not vectorized: vector stmt in loop:\");\n-\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: vector stmt in loop:%G\", stmt);\n       return false;\n     }\n \n@@ -10682,35 +10611,23 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \t}\n \n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"get vectype for scalar type:  \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n-\t  dump_printf (MSG_NOTE, \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"get vectype for scalar type:  %T\\n\", scalar_type);\n       vectype = get_vectype_for_scalar_type (scalar_type);\n       if (!vectype)\n \t{\n \t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t       \"not vectorized: unsupported data-type \");\n-\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t scalar_type);\n-\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t    }\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: unsupported data-type %T\\n\",\n+\t\t\t     scalar_type);\n \t  return false;\n \t}\n \n       if (!*stmt_vectype_out)\n \t*stmt_vectype_out = vectype;\n \n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location, \"vectype: \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, vectype);\n-\t  dump_printf (MSG_NOTE, \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"vectype: %T\\n\", vectype);\n     }\n \n   /* Don't try to compute scalar types if the stmt produces a boolean\n@@ -10730,47 +10647,34 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \t\t\t\t\t\t       &dummy, &dummy);\n \t}\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"get vectype for scalar type:  \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n-\t  dump_printf (MSG_NOTE, \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"get vectype for scalar type:  %T\\n\", scalar_type);\n       nunits_vectype = get_vectype_for_scalar_type (scalar_type);\n     }\n   if (!nunits_vectype)\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"not vectorized: unsupported data-type \");\n-\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, scalar_type);\n-\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: unsupported data-type %T\\n\",\n+\t\t\t scalar_type);\n       return false;\n     }\n \n   if (maybe_ne (GET_MODE_SIZE (TYPE_MODE (vectype)),\n \t\tGET_MODE_SIZE (TYPE_MODE (nunits_vectype))))\n     {\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"not vectorized: different sized vector \"\n-\t\t\t   \"types in statement, \");\n-\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, vectype);\n-\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n-\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, nunits_vectype);\n-\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: different sized vector \"\n+\t\t\t \"types in statement, %T and %T\\n\",\n+\t\t\t vectype, nunits_vectype);\n       return false;\n     }\n \n   if (dump_enabled_p ())\n     {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"vectype: \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, nunits_vectype);\n-      dump_printf (MSG_NOTE, \"\\n\");\n+      dump_printf_loc (MSG_NOTE, vect_location, \"vectype: %T\\n\",\n+\t\t       nunits_vectype);\n \n       dump_printf_loc (MSG_NOTE, vect_location, \"nunits = \");\n       dump_dec (MSG_NOTE, TYPE_VECTOR_SUBPARTS (nunits_vectype));\n@@ -10818,13 +10722,9 @@ vect_get_mask_type_for_stmt (stmt_vec_info stmt_info)\n \t  if (!vect_is_simple_use (rhs, stmt_info->vinfo, &dt, &vectype))\n \t    {\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t   \"not vectorized: can't compute mask type \"\n-\t\t\t\t   \"for statement, \");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt,\n-\t\t\t\t    0);\n-\t\t}\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"not vectorized: can't compute mask type \"\n+\t\t\t\t \"for statement, %G\", stmt);\n \t      return NULL_TREE;\n \t    }\n \n@@ -10840,34 +10740,21 @@ vect_get_mask_type_for_stmt (stmt_vec_info stmt_info)\n \t\t\t     TYPE_VECTOR_SUBPARTS (vectype)))\n \t    {\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t   \"not vectorized: different sized masks \"\n-\t\t\t\t   \"types in statement, \");\n-\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t     mask_type);\n-\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n-\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t     vectype);\n-\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t\t}\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"not vectorized: different sized masks \"\n+\t\t\t\t \"types in statement, %T and %T\\n\",\n+\t\t\t\t mask_type, vectype);\n \t      return NULL_TREE;\n \t    }\n \t  else if (VECTOR_BOOLEAN_TYPE_P (mask_type)\n \t\t   != VECTOR_BOOLEAN_TYPE_P (vectype))\n \t    {\n \t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t   \"not vectorized: mixed mask and \"\n-\t\t\t\t   \"nonmask vector types in statement, \");\n-\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t     mask_type);\n-\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n-\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t     vectype);\n-\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t\t}\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"not vectorized: mixed mask and \"\n+\t\t\t\t \"nonmask vector types in statement, \"\n+\t\t\t\t \"%T and %T\\n\",\n+\t\t\t\t mask_type, vectype);\n \t      return NULL_TREE;\n \t    }\n \t}\n@@ -10884,11 +10771,8 @@ vect_get_mask_type_for_stmt (stmt_vec_info stmt_info)\n   /* No mask_type should mean loop invariant predicate.\n      This is probably a subject for optimization in if-conversion.  */\n   if (!mask_type && dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t       \"not vectorized: can't compute mask type \"\n-\t\t       \"for statement, \");\n-      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-    }\n+    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t     \"not vectorized: can't compute mask type \"\n+\t\t     \"for statement, %G\", stmt);\n   return mask_type;\n }"}, {"sha": "23bddf3f4551f85b2a9b0775ad24fbcc952a50b1", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=3c2a8ed0d9a56a45a67f87c5fa3a093c6852e62b", "patch": "@@ -1425,9 +1425,7 @@ increase_alignment (void)\n       if (alignment && vect_can_force_dr_alignment_p (decl, alignment))\n         {\n \t  vnode->increase_alignment (alignment);\n-          dump_printf (MSG_NOTE, \"Increasing alignment of decl: \");\n-          dump_generic_expr (MSG_NOTE, TDF_SLIM, decl);\n-          dump_printf (MSG_NOTE, \"\\n\");\n+          dump_printf (MSG_NOTE, \"Increasing alignment of decl: %T\\n\", decl);\n         }\n     }\n "}]}