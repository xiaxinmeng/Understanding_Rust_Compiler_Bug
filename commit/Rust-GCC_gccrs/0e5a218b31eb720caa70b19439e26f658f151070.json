{"sha": "0e5a218b31eb720caa70b19439e26f658f151070", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU1YTIxOGIzMWViNzIwY2FhNzBiMTk0MzllMjZmNjU4ZjE1MTA3MA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-11-27T19:21:52Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-11-27T19:21:52Z"}, "message": "re PR fortran/33541 (gfortran wrongly imports renamed-use-associated symbol unrenamed)\n\n2007-11-27  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/33541\n\t*interface.c (compare_actual_formal): Exclude assumed size\n\tarrays from the possibility of scalar to array mapping.\n\t* decl.c (get_proc_name): Fix whitespace problem.\n\n\tPR fortran/34231\n\t* gfortran.h : Add 'use_rename' bit to symbol_attribute.\n\t* module.c : Add 'renamed' field to pointer_info.u.rsym.\n\t(load_generic_interfaces): Add 'renamed' that is set after the\n\tnumber_use_names is called.  This is used to set the attribute\n\tuse_rename, which, in its turn identifies those symbols that\n\thave not been renamed.\n\t(load_needed): If pointer_info.u.rsym->renamed is set, then\n\tset the use_rename attribute of the symbol.\n\t(read_module): Correct an erroneous use of use_flag. Use the\n\trenamed flag and the use_rename attribute to determine which\n\tsymbols are not renamed.\n\n2007-11-27  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/33541\n\t* gfortran.dg/use_11.f90: New test.\n\n\tPR fortran/34231\n\t* gfortran.dg/generic_15.f90: New test.\n\nFrom-SVN: r130471", "tree": {"sha": "be82a309f3817052399ef60052788c41bf329635", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be82a309f3817052399ef60052788c41bf329635"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e5a218b31eb720caa70b19439e26f658f151070", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e5a218b31eb720caa70b19439e26f658f151070", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e5a218b31eb720caa70b19439e26f658f151070", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e5a218b31eb720caa70b19439e26f658f151070/comments", "author": null, "committer": null, "parents": [{"sha": "f98e89380fd7ca4035221eaa9a8efad0e420d1b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f98e89380fd7ca4035221eaa9a8efad0e420d1b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f98e89380fd7ca4035221eaa9a8efad0e420d1b5"}], "stats": {"total": 119, "additions": 110, "deletions": 9}, "files": [{"sha": "cbcfa98056eb22327039d810e2e6767728405cc3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a218b31eb720caa70b19439e26f658f151070/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a218b31eb720caa70b19439e26f658f151070/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0e5a218b31eb720caa70b19439e26f658f151070", "patch": "@@ -1,3 +1,23 @@\n+2007-11-27  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/33541\n+\t*interface.c (compare_actual_formal): Exclude assumed size\n+\tarrays from the possibility of scalar to array mapping.\n+\t* decl.c (get_proc_name): Fix whitespace problem.\n+\n+\tPR fortran/34231\n+\t* gfortran.h : Add 'use_rename' bit to symbol_attribute.\n+\t* module.c : Add 'renamed' field to pointer_info.u.rsym.\n+\t(load_generic_interfaces): Add 'renamed' that is set after the\n+\tnumber_use_names is called.  This is used to set the attribute\n+\tuse_rename, which, in its turn identifies those symbols that\n+\thave not been renamed.\n+\t(load_needed): If pointer_info.u.rsym->renamed is set, then\n+\tset the use_rename attribute of the symbol.\n+\t(read_module): Correct an erroneous use of use_flag. Use the\n+\trenamed flag and the use_rename attribute to determine which\n+\tsymbols are not renamed.\n+\n 2007-11-26  Steven G. Kargl  <kargls@comcast.net>\n \n \tPR fortran/34203"}, {"sha": "a35071b5655681368accbfaffe554fbad7a0c76a", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a218b31eb720caa70b19439e26f658f151070/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a218b31eb720caa70b19439e26f658f151070/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=0e5a218b31eb720caa70b19439e26f658f151070", "patch": "@@ -728,9 +728,9 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)\n \t  /* If the ENTRY proceeds its specification, we need to ensure\n \t     that this does not raise a \"has no IMPLICIT type\" error.  */\n \t  if (sym->ts.type == BT_UNKNOWN)\n-\t\tsym->attr.untyped = 1;\n+\t    sym->attr.untyped = 1;\n \n-\t    (*result)->ts = sym->ts;\n+\t  (*result)->ts = sym->ts;\n \n \t  /* Put the symbol in the procedure namespace so that, should\n \t     the ENTRY preceed its specification, the specification"}, {"sha": "52ebe932f0eae6c6449cd04a9eefb725ffcc45a6", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a218b31eb720caa70b19439e26f658f151070/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a218b31eb720caa70b19439e26f658f151070/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=0e5a218b31eb720caa70b19439e26f658f151070", "patch": "@@ -618,6 +618,7 @@ typedef struct\n     protected:1,\t\t/* Symbol has been marked as protected.  */\n     use_assoc:1,\t\t/* Symbol has been use-associated.  */\n     use_only:1,\t\t\t/* Symbol has been use-associated, with ONLY.  */\n+    use_rename:1,\t\t/* Symbol has been use-associated and renamed.  */\n     imported:1;\t\t\t/* Symbol has been associated by IMPORT.  */\n \n   unsigned in_namelist:1, in_common:1, in_equivalence:1;"}, {"sha": "0ff31127e954a51467e6e850a38ccb0cfbbcccbd", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a218b31eb720caa70b19439e26f658f151070/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a218b31eb720caa70b19439e26f658f151070/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=0e5a218b31eb720caa70b19439e26f658f151070", "patch": "@@ -1782,7 +1782,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t       || f->sym->as->type == AS_DEFERRED);\n \n       if (f->sym->ts.type == BT_CHARACTER && a->expr->ts.type == BT_CHARACTER\n-\t  && a->expr->rank == 0\n+\t  && a->expr->rank == 0 && !ranks_must_agree\n \t  && f->sym->as && f->sym->as->type != AS_ASSUMED_SHAPE)\n \t{\n \t  if (where && (gfc_option.allow_std & GFC_STD_F2003) == 0)"}, {"sha": "a81067cf51d219e34d1e44d3ec673ce168ad44ff", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a218b31eb720caa70b19439e26f658f151070/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a218b31eb720caa70b19439e26f658f151070/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=0e5a218b31eb720caa70b19439e26f658f151070", "patch": "@@ -136,7 +136,7 @@ typedef struct pointer_info\n       enum\n       { UNUSED, NEEDED, USED }\n       state;\n-      int ns, referenced;\n+      int ns, referenced, renamed;\n       module_locus where;\n       fixup_t *stfixup;\n       gfc_symtree *symtree;\n@@ -3260,7 +3260,7 @@ load_generic_interfaces (void)\n   char name[GFC_MAX_SYMBOL_LEN + 1], module[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symbol *sym;\n   gfc_interface *generic = NULL;\n-  int n, i;\n+  int n, i, renamed;\n \n   mio_lparen ();\n \n@@ -3272,6 +3272,7 @@ load_generic_interfaces (void)\n       mio_internal_string (module);\n \n       n = number_use_names (name, false);\n+      renamed = n ? 1 : 0;\n       n = n ? n : 1;\n \n       for (i = 1; i <= n; i++)\n@@ -3300,7 +3301,9 @@ load_generic_interfaces (void)\n \t    {\n \t      /* Make symtree inaccessible by renaming if the symbol has\n \t\t been added by a USE statement without an ONLY(11.3.2).  */\n-\t      if (st && !st->n.sym->attr.use_only && only_flag\n+\t      if (st && only_flag\n+\t\t     && !st->n.sym->attr.use_only\n+\t\t     && !st->n.sym->attr.use_rename\n \t\t     && strcmp (st->n.sym->module, module_name) == 0)\n \t\tst->name = gfc_get_string (\"hidden.%s\", name);\n \t      else if (st)\n@@ -3342,6 +3345,7 @@ load_generic_interfaces (void)\n \t    }\n \n \t  sym->attr.use_only = only_flag;\n+\t  sym->attr.use_rename = renamed;\n \n \t  if (i == 1)\n \t    {\n@@ -3523,6 +3527,8 @@ load_needed (pointer_info *p)\n   sym->attr.use_assoc = 1;\n   if (only_flag)\n     sym->attr.use_only = 1;\n+  if (p->u.rsym.renamed)\n+    sym->attr.use_rename = 1;\n \n   return 1;\n }\n@@ -3666,6 +3672,8 @@ read_module (void)\n       /* See how many use names there are.  If none, go through the start\n \t of the loop at least once.  */\n       nuse = number_use_names (name, false);\n+      info->u.rsym.renamed = nuse ? 1 : 0;\n+\n       if (nuse == 0)\n \tnuse = 1;\n \n@@ -3679,7 +3687,7 @@ read_module (void)\n \n \t  /* Skip symtree nodes not in an ONLY clause, unless there\n \t     is an existing symtree loaded from another USE statement.  */\n-\t  if (p == NULL && only_flag)\n+\t  if (p == NULL)\n \t    {\n \t      st = gfc_find_symtree (gfc_current_ns->sym_root, name);\n \t      if (st != NULL)\n@@ -3691,7 +3699,7 @@ read_module (void)\n \t     this symbol, which is not in an ONLY clause, must not be\n \t     added to the namespace(11.3.2).  Note that find_symbol\n \t     only returns the first occurrence that it finds.  */\n-\t  if (!only_flag\n+\t  if (!only_flag && !info->u.rsym.renamed\n \t\t&& strcmp (name, module_name) != 0\n \t\t&& find_symbol (gfc_current_ns->sym_root, name,\n \t\t\t\tmodule_name, 0))\n@@ -3712,7 +3720,9 @@ read_module (void)\n \n \t      /* Make symtree inaccessible by renaming if the symbol has\n \t\t been added by a USE statement without an ONLY(11.3.2).  */\n-\t      if (st && !st->n.sym->attr.use_only && only_flag\n+\t      if (st && only_flag\n+\t\t     && !st->n.sym->attr.use_only\n+\t\t     && !st->n.sym->attr.use_rename\n \t\t     && strcmp (st->n.sym->module, module_name) == 0)\n \t\tst->name = gfc_get_string (\"hidden.%s\", name);\n "}, {"sha": "370cc55a8523b9d8af251c1874029e7eae2852e3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a218b31eb720caa70b19439e26f658f151070/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a218b31eb720caa70b19439e26f658f151070/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e5a218b31eb720caa70b19439e26f658f151070", "patch": "@@ -1,3 +1,11 @@\n+2007-11-27  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/33541\n+\t* gfortran.dg/use_11.f90: New test.\n+\n+\tPR fortran/34231\n+\t* gfortran.dg/generic_15.f90: New test.\n+\n 2007-11-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/34225"}, {"sha": "127868473ff9595af1d1b7a67af28f2388a91966", "filename": "gcc/testsuite/gfortran.dg/generic_15.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a218b31eb720caa70b19439e26f658f151070/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a218b31eb720caa70b19439e26f658f151070/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_15.f90?ref=0e5a218b31eb720caa70b19439e26f658f151070", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do run }\n+! Test the fix for PR34231, in which the assumed size 'cnames'\n+! would be wrongly associated with the scalar argument.\n+!\n+! Contributed by <francois.jacq@irsn.fr>\n+!\n+MODULE test\n+\n+   TYPE odbase ; INTEGER :: value ; END TYPE\n+\n+   INTERFACE odfname\n+      MODULE PROCEDURE odfamilycname,odfamilycnames\n+   END INTERFACE\n+\n+   CONTAINS\n+\n+   SUBROUTINE odfamilycnames(base,nfam,cnames)\n+      TYPE(odbase),INTENT(in)  :: base\n+      INTEGER     ,INTENT(out) :: nfam\n+      CHARACTER(*),INTENT(out) :: cnames(*)\n+      cnames(1:nfam)='odfamilycnames'\n+   END SUBROUTINE\n+\n+   SUBROUTINE odfamilycname(base,pos,cname)\n+      TYPE(odbase),INTENT(in)  :: base\n+      INTEGER     ,INTENT(in)  :: pos\n+      CHARACTER(*),INTENT(out) :: cname\n+      cname='odfamilycname'\n+   END SUBROUTINE\n+\n+END MODULE\n+\n+PROGRAM main\n+  USE test\n+  TYPE(odbase) :: base\n+  INTEGER :: i=1\n+  CHARACTER(14) :: cname\n+  CHARACTER(14) :: cnames(1)\n+  CALL odfname(base,i,cname)\n+  if (trim (cname) .ne. \"odfamilycname\") call abort\n+  CALL odfname(base,i,cnames)\n+  if (trim (cnames(1)) .ne. \"odfamilycnames\") call abort\n+END PROGRAM\n+! { dg-final { cleanup-modules \"test\" } }"}, {"sha": "02efe8e51ab904cc7486bb8b448404b60a7e40af", "filename": "gcc/testsuite/gfortran.dg/use_11.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a218b31eb720caa70b19439e26f658f151070/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a218b31eb720caa70b19439e26f658f151070/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_11.f90?ref=0e5a218b31eb720caa70b19439e26f658f151070", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do run }\n+! Test the fix for a regression caused by the fix for PR33541,\n+! in which the second local version of a would not be associated.\n+!\n+! Contributed by Dominique d'Humieres <dominiq@lps.ens.fr>\n+!            and Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+module m\n+  integer :: a\n+end module m\n+\n+use m, local1 => a\n+use m, local2 => a\n+local1 = 5\n+local2 = 3\n+if (local1 .ne. local2) call abort ()\n+end\n+! { dg-final { cleanup-modules \"test\" } }"}]}