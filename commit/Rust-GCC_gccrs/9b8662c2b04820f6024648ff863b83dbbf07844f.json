{"sha": "9b8662c2b04820f6024648ff863b83dbbf07844f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI4NjYyYzJiMDQ4MjBmNjAyNDY0OGZmODYzYjgzZGJiZjA3ODQ0Zg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-08-23T16:03:15Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-08-23T16:03:15Z"}, "message": "Core 975\n\n\tCore 975\n\t* decl.c (cxx_init_decl_processing): Initialize\n\tdependent_lambda_return_type_node.\n\t* cp-tree.h (cp_tree_index): Add CPTI_DEPENDENT_LAMBDA_RETURN_TYPE.\n\t(dependent_lambda_return_type_node): Define.\n\t(DECLTYPE_FOR_LAMBDA_RETURN): Remove.\n\t* semantics.c (lambda_return_type): Handle overloaded function.\n\tUse dependent_lambda_return_type_node instead of\n\tDECLTYPE_FOR_LAMBDA_RETURN.\n\t(apply_lambda_return_type): Don't check dependent_type_p.\n\t* pt.c (tsubst_copy_and_build): Handle lambda return type deduction.\n\t(instantiate_class_template_1): Likewise.\n\t(tsubst): Don't use DECLTYPE_FOR_LAMBDA_RETURN.\n\t* mangle.c (write_type): Likewise.\n\t* typeck.c (structural_comptypes): Likewise.\n\t(check_return_expr): Handle dependent_lambda_return_type_node.\n\nFrom-SVN: r177995", "tree": {"sha": "095408f307618afaaf5d92253bb0546486159200", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/095408f307618afaaf5d92253bb0546486159200"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b8662c2b04820f6024648ff863b83dbbf07844f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b8662c2b04820f6024648ff863b83dbbf07844f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b8662c2b04820f6024648ff863b83dbbf07844f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b8662c2b04820f6024648ff863b83dbbf07844f/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2787914706395bf7864bdc76491ada1b0a552cae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2787914706395bf7864bdc76491ada1b0a552cae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2787914706395bf7864bdc76491ada1b0a552cae"}], "stats": {"total": 155, "additions": 97, "deletions": 58}, "files": [{"sha": "0f325a8936740ce43ad316262d99750db478b1bc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9b8662c2b04820f6024648ff863b83dbbf07844f", "patch": "@@ -1,3 +1,22 @@\n+2011-08-23  Jason Merrill  <jason@redhat.com>\n+\n+\tCore 975\n+\t* decl.c (cxx_init_decl_processing): Initialize\n+\tdependent_lambda_return_type_node.\n+\t* cp-tree.h (cp_tree_index): Add CPTI_DEPENDENT_LAMBDA_RETURN_TYPE.\n+\t(dependent_lambda_return_type_node): Define.\n+\t(DECLTYPE_FOR_LAMBDA_RETURN): Remove.\n+\t* semantics.c (lambda_return_type): Handle overloaded function.\n+\tUse dependent_lambda_return_type_node instead of\n+\tDECLTYPE_FOR_LAMBDA_RETURN.\n+\t(apply_lambda_return_type): Don't check dependent_type_p.\n+\t* pt.c (tsubst_copy_and_build): Handle lambda return type deduction.\n+\t(instantiate_class_template_1): Likewise.\n+\t(tsubst): Don't use DECLTYPE_FOR_LAMBDA_RETURN.\n+\t* mangle.c (write_type): Likewise.\n+\t* typeck.c (structural_comptypes): Likewise.\n+\t(check_return_expr): Handle dependent_lambda_return_type_node.\n+\n 2011-08-23  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/50024"}, {"sha": "859594393979bdc5bb0c653b846835720166bd56", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9b8662c2b04820f6024648ff863b83dbbf07844f", "patch": "@@ -83,7 +83,6 @@ c-common.h, not after.\n       STMT_IS_FULL_EXPR_P (in _STMT)\n       TARGET_EXPR_LIST_INIT_P (in TARGET_EXPR)\n       LAMBDA_EXPR_MUTABLE_P (in LAMBDA_EXPR)\n-      DECLTYPE_FOR_LAMBDA_RETURN (in DECLTYPE_TYPE)\n       DECL_FINAL_P (in FUNCTION_DECL)\n       QUALIFIED_NAME_IS_TEMPLATE (in SCOPE_REF)\n    2: IDENTIFIER_OPNAME_P (in IDENTIFIER_NODE)\n@@ -775,6 +774,7 @@ enum cp_tree_index\n     CPTI_CLASS_TYPE,\n     CPTI_UNKNOWN_TYPE,\n     CPTI_INIT_LIST_TYPE,\n+    CPTI_DEPENDENT_LAMBDA_RETURN_TYPE,\n     CPTI_VTBL_TYPE,\n     CPTI_VTBL_PTR_TYPE,\n     CPTI_STD,\n@@ -846,6 +846,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define class_type_node\t\t\tcp_global_trees[CPTI_CLASS_TYPE]\n #define unknown_type_node\t\tcp_global_trees[CPTI_UNKNOWN_TYPE]\n #define init_list_type_node\t\tcp_global_trees[CPTI_INIT_LIST_TYPE]\n+#define dependent_lambda_return_type_node cp_global_trees[CPTI_DEPENDENT_LAMBDA_RETURN_TYPE]\n #define vtbl_type_node\t\t\tcp_global_trees[CPTI_VTBL_TYPE]\n #define vtbl_ptr_type_node\t\tcp_global_trees[CPTI_VTBL_PTR_TYPE]\n #define std_node\t\t\tcp_global_trees[CPTI_STD]\n@@ -3425,12 +3426,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   (DECLTYPE_TYPE_CHECK (NODE))->type_common.string_flag\n \n /* These flags indicate that we want different semantics from normal\n-   decltype: lambda capture just drops references, lambda return also does\n-   type decay, lambda proxies look through implicit dereference.  */\n+   decltype: lambda capture just drops references, lambda proxies look\n+   through implicit dereference.  */\n #define DECLTYPE_FOR_LAMBDA_CAPTURE(NODE) \\\n   TREE_LANG_FLAG_0 (DECLTYPE_TYPE_CHECK (NODE))\n-#define DECLTYPE_FOR_LAMBDA_RETURN(NODE) \\\n-  TREE_LANG_FLAG_1 (DECLTYPE_TYPE_CHECK (NODE))\n #define DECLTYPE_FOR_LAMBDA_PROXY(NODE) \\\n   TREE_LANG_FLAG_2 (DECLTYPE_TYPE_CHECK (NODE))\n "}, {"sha": "c375cf7a78df1794732a0d99b2b122f28cbd4676", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9b8662c2b04820f6024648ff863b83dbbf07844f", "patch": "@@ -3597,6 +3597,10 @@ cxx_init_decl_processing (void)\n   init_list_type_node = make_node (LANG_TYPE);\n   record_unknown_type (init_list_type_node, \"init list\");\n \n+  dependent_lambda_return_type_node = make_node (LANG_TYPE);\n+  record_unknown_type (dependent_lambda_return_type_node,\n+\t\t       \"undeduced lambda return type\");\n+\n   {\n     /* Make sure we get a unique function type, so we can give\n        its pointer type a name.  (This wins for gdb.) */"}, {"sha": "4c7cc79d4e34b892387c4dc370508339f12dfc35", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=9b8662c2b04820f6024648ff863b83dbbf07844f", "patch": "@@ -1953,7 +1953,7 @@ write_type (tree type)\n             case DECLTYPE_TYPE:\n \t      /* These shouldn't make it into mangling.  */\n \t      gcc_assert (!DECLTYPE_FOR_LAMBDA_CAPTURE (type)\n-\t\t\t  && !DECLTYPE_FOR_LAMBDA_RETURN (type));\n+\t\t\t  && !DECLTYPE_FOR_LAMBDA_PROXY (type));\n \n \t      /* In ABI <5, we stripped decltype of a plain decl.  */\n \t      if (!abi_version_at_least (5)"}, {"sha": "6b970f97777c4b6d03bccef92f228bbce9cbf562", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9b8662c2b04820f6024648ff863b83dbbf07844f", "patch": "@@ -8887,7 +8887,16 @@ instantiate_class_template_1 (tree type)\n     }\n \n   if (CLASSTYPE_LAMBDA_EXPR (type))\n-    maybe_add_lambda_conv_op (type);\n+    {\n+      tree lambda = CLASSTYPE_LAMBDA_EXPR (type);\n+      if (LAMBDA_EXPR_DEDUCE_RETURN_TYPE_P (lambda))\n+\t{\n+\t  apply_lambda_return_type (lambda, void_type_node);\n+\t  LAMBDA_EXPR_RETURN_TYPE (lambda) = NULL_TREE;\n+\t}\n+      instantiate_decl (lambda_function (type), false, false);\n+      maybe_add_lambda_conv_op (type);\n+    }\n \n   /* Set the file and line number information to whatever is given for\n      the class itself.  This puts error messages involving generated\n@@ -11420,8 +11429,6 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n \tif (DECLTYPE_FOR_LAMBDA_CAPTURE (t))\n \t  type = lambda_capture_field_type (type);\n-\telse if (DECLTYPE_FOR_LAMBDA_RETURN (t))\n-\t  type = lambda_return_type (type);\n \telse if (DECLTYPE_FOR_LAMBDA_PROXY (t))\n \t  type = lambda_proxy_type (type);\n \telse\n@@ -13882,10 +13889,17 @@ tsubst_copy_and_build (tree t,\n \tLAMBDA_EXPR_MUTABLE_P (r) = LAMBDA_EXPR_MUTABLE_P (t);\n \tLAMBDA_EXPR_DISCRIMINATOR (r)\n \t  = (LAMBDA_EXPR_DISCRIMINATOR (t));\n-\tLAMBDA_EXPR_CAPTURE_LIST (r)\n-\t  = RECUR (LAMBDA_EXPR_CAPTURE_LIST (t));\n \tLAMBDA_EXPR_EXTRA_SCOPE (r)\n \t  = RECUR (LAMBDA_EXPR_EXTRA_SCOPE (t));\n+\tif (LAMBDA_EXPR_RETURN_TYPE (t) == dependent_lambda_return_type_node)\n+\t  {\n+\t    LAMBDA_EXPR_RETURN_TYPE (r) = dependent_lambda_return_type_node;\n+\t    LAMBDA_EXPR_DEDUCE_RETURN_TYPE_P (r) = true;\n+\t  }\n+\telse\n+\t  LAMBDA_EXPR_RETURN_TYPE (r)\n+\t    = tsubst (LAMBDA_EXPR_RETURN_TYPE (t), args, complain, in_decl);\n+\n \tgcc_assert (LAMBDA_EXPR_THIS_CAPTURE (t) == NULL_TREE\n \t\t    && LAMBDA_EXPR_PENDING_PROXIES (t) == NULL);\n \n@@ -13895,9 +13909,10 @@ tsubst_copy_and_build (tree t,\n \t   declaration of the op() for later calls to lambda_function.  */\n \tcomplete_type (type);\n \n-\ttype = tsubst (LAMBDA_EXPR_RETURN_TYPE (t), args, complain, in_decl);\n-\tif (type)\n-\t  apply_lambda_return_type (r, type);\n+\t/* The capture list refers to closure members, so this needs to\n+\t   wait until after we finish instantiating the type.  */\n+\tLAMBDA_EXPR_CAPTURE_LIST (r)\n+\t  = RECUR (LAMBDA_EXPR_CAPTURE_LIST (t));\n \n \treturn build_lambda_object (r);\n       }"}, {"sha": "5deb2ebfbd168381e6fd71ac9572c9cce4ac8f1b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9b8662c2b04820f6024648ff863b83dbbf07844f", "patch": "@@ -8323,18 +8323,14 @@ tree\n lambda_return_type (tree expr)\n {\n   tree type;\n-  if (BRACE_ENCLOSED_INITIALIZER_P (expr))\n+  if (type_unknown_p (expr)\n+      || BRACE_ENCLOSED_INITIALIZER_P (expr))\n     {\n-      warning (0, \"cannot deduce lambda return type from a braced-init-list\");\n+      cxx_incomplete_type_error (expr, TREE_TYPE (expr));\n       return void_type_node;\n     }\n   if (type_dependent_expression_p (expr))\n-    {\n-      type = cxx_make_type (DECLTYPE_TYPE);\n-      DECLTYPE_TYPE_EXPR (type) = expr;\n-      DECLTYPE_FOR_LAMBDA_RETURN (type) = true;\n-      SET_TYPE_STRUCTURAL_EQUALITY (type);\n-    }\n+    type = dependent_lambda_return_type_node;\n   else\n     type = cv_unqualified (type_decays_to (unlowered_expr_type (expr)));\n   return type;\n@@ -8394,12 +8390,10 @@ apply_lambda_return_type (tree lambda, tree return_type)\n \n   LAMBDA_EXPR_RETURN_TYPE (lambda) = return_type;\n \n-  /* If we got a DECLTYPE_TYPE, don't stick it in the function yet,\n-     it would interfere with instantiating the closure type.  */\n-  if (dependent_type_p (return_type))\n-    return;\n   if (return_type == error_mark_node)\n     return;\n+  if (TREE_TYPE (TREE_TYPE (fco)) == return_type)\n+    return;\n \n   /* TREE_TYPE (FUNCTION_DECL) == METHOD_TYPE\n      TREE_TYPE (METHOD_TYPE)   == return-type  */\n@@ -8412,6 +8406,7 @@ apply_lambda_return_type (tree lambda, tree return_type)\n   /* We already have a DECL_RESULT from start_preparsed_function.\n      Now we need to redo the work it and allocate_struct_function\n      did to reflect the new type.  */\n+  gcc_assert (current_function_decl == fco);\n   result = build_decl (input_location, RESULT_DECL, NULL_TREE,\n \t\t       TYPE_MAIN_VARIANT (return_type));\n   DECL_ARTIFICIAL (result) = 1;"}, {"sha": "9db0ce34214fe75ff1325a41a34df7ad7c6a78b4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9b8662c2b04820f6024648ff863b83dbbf07844f", "patch": "@@ -1331,8 +1331,8 @@ structural_comptypes (tree t1, tree t2, int strict)\n           != DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (t2)\n \t  || (DECLTYPE_FOR_LAMBDA_CAPTURE (t1)\n \t      != DECLTYPE_FOR_LAMBDA_CAPTURE (t2))\n-\t  || (DECLTYPE_FOR_LAMBDA_RETURN (t1)\n-\t      != DECLTYPE_FOR_LAMBDA_RETURN (t2))\n+\t  || (DECLTYPE_FOR_LAMBDA_PROXY (t1)\n+\t      != DECLTYPE_FOR_LAMBDA_PROXY (t2))\n           || !cp_tree_equal (DECLTYPE_TYPE_EXPR (t1), \n                              DECLTYPE_TYPE_EXPR (t2)))\n         return false;\n@@ -7657,15 +7657,14 @@ check_return_expr (tree retval, bool *no_warning)\n \t  tree type = lambda_return_type (retval);\n \t  tree oldtype = LAMBDA_EXPR_RETURN_TYPE (lambda);\n \n-\t  if (VOID_TYPE_P (type))\n-\t    { /* Nothing.  */ }\n-\t  else if (oldtype == NULL_TREE)\n-\t    {\n-\t      pedwarn (input_location, OPT_pedantic, \"lambda return type \"\n-\t\t       \"can only be deduced when the return statement is \"\n-\t\t       \"the only statement in the function body\");\n-\t      apply_lambda_return_type (lambda, type);\n-\t    }\n+\t  if (oldtype == NULL_TREE)\n+\t    apply_lambda_return_type (lambda, type);\n+\t  /* If one of the answers is type-dependent, we can't do any\n+\t     better until instantiation time.  */\n+\t  else if (oldtype == dependent_lambda_return_type_node)\n+\t    /* Leave it.  */;\n+\t  else if (type == dependent_lambda_return_type_node)\n+\t    apply_lambda_return_type (lambda, type);\n \t  else if (!same_type_p (type, oldtype))\n \t    error (\"inconsistent types %qT and %qT deduced for \"\n \t\t   \"lambda return type\", type, oldtype);"}, {"sha": "9dfa4d3eb2939be4f8694afe29b31d3f52297566", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9b8662c2b04820f6024648ff863b83dbbf07844f", "patch": "@@ -1,3 +1,11 @@\n+2011-08-23  Jason Merrill  <jason@redhat.com>\n+\n+\tCore 975\n+\t* g++.dg/cpp0x/lambda/lambda-deduce-ext-neg2.C: Now accepted.\n+\t* g++.dg/cpp0x/lambda/lambda-deduce-ext-neg.C: Adjust.\n+\t* g++.dg/cpp0x/lambda/lambda-deduce2.C: Test returning overload.\n+\t* g++.dg/cpp0x/lambda/lambda-deduce-neg.C: Remove #include.\n+\n 2011-08-23  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/50024"}, {"sha": "f93e78a27c4e802debdf9c35a9398a7bf47d8c4d", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-deduce-ext-neg.C", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-ext-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-ext-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-ext-neg.C?ref=9b8662c2b04820f6024648ff863b83dbbf07844f", "patch": "@@ -1,24 +1,22 @@\n-// Testcase for an extension to allow return type deduction when the lambda\n-// contains more than just a single return-statement.\n+// Testcase for DR 975.\n \n // { dg-options -std=c++0x }\n \n bool b;\n-template <class T>\n-T f (T t)\n-{\n-  return [=]\n-    {\n-      auto i = t+1;\n-      if (b)\n-\treturn i+1;\n-      else\n-\treturn i+2;\t\t// { dg-error \"lambda return type\" }\n-    }();\n+struct A { int fn1(); const int& fn2(); };\n+struct B { int fn1(); long fn2(); };\n+\n+template <class T> int f (T t) {\n+  return [](T t){\n+    if (b)\n+      return t.fn1();\n+    else\n+      return t.fn2();\t\t// { dg-error \"inconsistent types\" }\n+  }(t);\n }\n \n int main()\n {\n-  if (f(1) != 3)\n-    return 1;\n+  f(A());\t\t\t// { dg-bogus \"\" } int and const int& are compatible\n+  f(B());\t\t\t// { dg-message \"from here\" } int and long are not\n }"}, {"sha": "5c63409b6815e4b9b0bdfb453bf271a0e9a9b4e9", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-deduce-ext-neg2.C", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-ext-neg2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-ext-neg2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-ext-neg2.C?ref=9b8662c2b04820f6024648ff863b83dbbf07844f", "patch": "@@ -1,6 +1,5 @@\n-// Test that in pedantic mode, we warn about the extension to allow return\n-// type deduction when the lambda contains more than just a single\n-// return-statement.\n+// Test that this is accepted even when pedantic now that it's part\n+// of the standard.\n \n // { dg-options \"-std=c++0x -pedantic\" }\n \n@@ -11,7 +10,7 @@ T f (T t)\n   [=] { return t+1; };\t\t// OK\n   return [=] {\n     auto i = t+1;\n-    return i+1;\t\t\t// { dg-warning \"only statement\" }\n+    return i+1;\n   }();\n }\n "}, {"sha": "c932c09db3c29e20537eea188e0c0792d7cf9828", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-deduce-neg.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-neg.C?ref=9b8662c2b04820f6024648ff863b83dbbf07844f", "patch": "@@ -1,5 +1,4 @@\n // { dg-options \"-std=c++0x\" }\n-#include <cassert>\n \n int main() {\n   int i = 0;"}, {"sha": "eeb9814a05439249171ff33b4cb14adf25a68edd", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-deduce2.C", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b8662c2b04820f6024648ff863b83dbbf07844f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce2.C?ref=9b8662c2b04820f6024648ff863b83dbbf07844f", "patch": "@@ -1,7 +1,11 @@\n // PR c++/43875\n // { dg-options \"-std=c++0x\" }\n \n+void f();\n+void f(int);\n+\n int main()\n {\n-   auto x2 = []{ return { 1, 2 }; }; // { dg-message \"return\" }\n+  auto x1 = []{ return f; };\t    // { dg-error \"return|overloaded\" }\n+  auto x2 = []{ return { 1, 2 }; }; // { dg-error \"return|list\" }\n }"}]}