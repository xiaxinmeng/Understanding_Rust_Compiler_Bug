{"sha": "fdabe5c2ef530b511e8b86fb814c8f226ec693d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRhYmU1YzJlZjUzMGI1MTFlOGI4NmZiODE0YzhmMjI2ZWM2OTNkOQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-09-19T02:51:15Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-09-19T02:51:15Z"}, "message": "tree-ssa-dom.c (nonzero_vars_stack, [...]): New global varrays to replace the block local varrays.\n\n\n\t* tree-ssa-dom.c (nonzero_vars_stack, vrp_variables_stack): New\n\tglobal varrays to replace the block local varrays.\n\t(struct dom_walk_block_data): Remove, no longer used.\n\t(get_eq_expr_value): No longer need to pass around pointers to local\n\tvarrays.  Callers updated.  Unused markers added to unused parameters.\n\t(record_range, record_equivalences_from_stmt): Likewise.\n\t(record_equivalences_from_incoming_edge): Likewise.\n\t(record_var_is_nonzero): Likewise.  Update now that we have a\n\tsingle global varray of SSA_NAMEs that need restoring.\n\t(dom_opt_initialize_block_local_data): Kill, no longer used.\n\t(tree_ssa_dominator_optimize): Initialize new global varrays.\n\tUpdate callbacks in dominator walker structure.\n\t(dom_opt_initialize_block): Add markers to NONZERO_VAR_STACK and\n\tVRP_VARIABLES_STACK.\n\t(restore_nonzero_vars_to_original_value): Update now that we have\n\ta single global varray of SSA_NAMEs that need restoring.\n\t(dom_opt_finalize_block): Similarly for VRP_VARIABLES_STACK.\n\tRemove unused variables.\n\t(optimize_stmt): Remove unused variable.\n\nFrom-SVN: r87719", "tree": {"sha": "effbd5ffec721cf0bd8d6d2b08c41aa6d36810a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/effbd5ffec721cf0bd8d6d2b08c41aa6d36810a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdabe5c2ef530b511e8b86fb814c8f226ec693d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdabe5c2ef530b511e8b86fb814c8f226ec693d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdabe5c2ef530b511e8b86fb814c8f226ec693d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdabe5c2ef530b511e8b86fb814c8f226ec693d9/comments", "author": null, "committer": null, "parents": [{"sha": "45576477031d982780f013a53485b7f1d5c91143", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45576477031d982780f013a53485b7f1d5c91143", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45576477031d982780f013a53485b7f1d5c91143"}], "stats": {"total": 183, "additions": 79, "deletions": 104}, "files": [{"sha": "f06c54206f4ea4e5f8a355daab37b45a5cffa7f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdabe5c2ef530b511e8b86fb814c8f226ec693d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdabe5c2ef530b511e8b86fb814c8f226ec693d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fdabe5c2ef530b511e8b86fb814c8f226ec693d9", "patch": "@@ -1,3 +1,25 @@\n+2004-09-18 Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dom.c (nonzero_vars_stack, vrp_variables_stack): New\n+\tglobal varrays to replace the block local varrays.\n+\t(struct dom_walk_block_data): Remove, no longer used.\n+\t(get_eq_expr_value): No longer need to pass around pointers to local\n+\tvarrays.  Callers updated.  Unused markers added to unused parameters.\n+\t(record_range, record_equivalences_from_stmt): Likewise.\n+\t(record_equivalences_from_incoming_edge): Likewise.\n+\t(record_var_is_nonzero): Likewise.  Update now that we have a\n+\tsingle global varray of SSA_NAMEs that need restoring.\n+\t(dom_opt_initialize_block_local_data): Kill, no longer used.\n+\t(tree_ssa_dominator_optimize): Initialize new global varrays.\n+\tUpdate callbacks in dominator walker structure.\n+\t(dom_opt_initialize_block): Add markers to NONZERO_VAR_STACK and\n+\tVRP_VARIABLES_STACK.\n+\t(restore_nonzero_vars_to_original_value): Update now that we have\n+\ta single global varray of SSA_NAMEs that need restoring.\n+\t(dom_opt_finalize_block): Similarly for VRP_VARIABLES_STACK.\n+\tRemove unused variables.\n+\t(optimize_stmt): Remove unused variable.\n+\n 2004-09-18  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-cfg.c (thread_jumps):  Fix updating of the profile."}, {"sha": "e50c4489e8508df5a1e89d66839fba03463fcd0d", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 57, "deletions": 104, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdabe5c2ef530b511e8b86fb814c8f226ec693d9/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdabe5c2ef530b511e8b86fb814c8f226ec693d9/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=fdabe5c2ef530b511e8b86fb814c8f226ec693d9", "patch": "@@ -129,6 +129,13 @@ static varray_type const_and_copies_stack;\n    know their exact value.  */\n static bitmap nonzero_vars;\n \n+/* Stack of SSA_NAMEs which need their NONZERO_VARS property cleared\n+   when the current block is finalized. \n+\n+   A NULL entry is used to mark the end of names needing their \n+   entry in NONZERO_VARS cleared during finalization of this block.  */\n+static varray_type nonzero_vars_stack;\n+\n /* Track whether or not we have changed the control flow graph.  */\n static bool cfg_altered;\n \n@@ -201,21 +208,16 @@ static struct opt_stats_d opt_stats;\n    by the index, SSA_VERSION.  */\n static varray_type vrp_data;\n \n-/* Datastructure for block local data used during the dominator walk.  \n-   We maintain a stack of these as we recursively walk down the\n-   dominator tree.  */\n+/* Array of variables which have their values constrained by operations\n+   in this basic block.  We use this during finalization to know\n+   which variables need their VRP data updated.  */\n \n-struct dom_walk_block_data\n-{\n-  /* Similarly for the nonzero state of variables that needs to be\n-     restored during finalization.  */\n-  varray_type nonzero_vars;\n-\n-  /* Array of variables which have their values constrained by operations\n-     in this basic block.  We use this during finalization to know\n-     which variables need their VRP data updated.  */\n-  varray_type vrp_variables;\n-};\n+/* Stack of SSA_NAMEs which had their values constrainted by operations\n+   in this basic block.  During finalization of this block we use this\n+   list to determine which variables need their VRP data updated.\n+\n+   A NULL entry marks the end of the SSA_NAMEs associated with this block.  */\n+static varray_type vrp_variables_stack;\n \n struct eq_expr_value\n {\n@@ -230,8 +232,7 @@ static void optimize_stmt (struct dom_walk_data *,\n static inline tree get_value_for (tree, varray_type table);\n static inline void set_value_for (tree, tree, varray_type table);\n static tree lookup_avail_expr (tree, bool);\n-static struct eq_expr_value get_eq_expr_value (tree, int,\n-\t\t\t\t\t       basic_block, varray_type *);\n+static struct eq_expr_value get_eq_expr_value (tree, int, basic_block);\n static hashval_t avail_expr_hash (const void *);\n static hashval_t real_avail_expr_hash (const void *);\n static int avail_expr_eq (const void *, const void *);\n@@ -246,26 +247,24 @@ static tree simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *,\n static tree simplify_cond_and_lookup_avail_expr (tree, stmt_ann_t, int);\n static tree simplify_switch_and_lookup_avail_expr (tree, int);\n static tree find_equivalent_equality_comparison (tree);\n-static void record_range (tree, basic_block, varray_type *);\n+static void record_range (tree, basic_block);\n static bool extract_range_from_cond (tree, tree *, tree *, int *);\n static void record_equivalences_from_phis (struct dom_walk_data *, basic_block);\n static void record_equivalences_from_incoming_edge (struct dom_walk_data *,\n \t\t\t\t\t\t    basic_block);\n static bool eliminate_redundant_computations (struct dom_walk_data *,\n \t\t\t\t\t      tree, stmt_ann_t);\n-static void record_equivalences_from_stmt (tree, varray_type *,\n-\t\t\t\t\t   int, stmt_ann_t);\n+static void record_equivalences_from_stmt (tree, int, stmt_ann_t);\n static void thread_across_edge (struct dom_walk_data *, edge);\n static void dom_opt_finalize_block (struct dom_walk_data *, basic_block);\n-static void dom_opt_initialize_block_local_data (struct dom_walk_data *,\n-\t\t\t\t\t\t basic_block, bool);\n static void dom_opt_initialize_block (struct dom_walk_data *, basic_block);\n static void cprop_into_phis (struct dom_walk_data *, basic_block);\n static void remove_local_expressions_from_table (void);\n static void restore_vars_to_original_value (void);\n static void restore_currdefs_to_original_value (void);\n static void register_definitions_for_stmt (tree);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n+static void restore_nonzero_vars_to_original_value (void);\n \n /* Local version of fold that doesn't introduce cruft.  */\n \n@@ -324,6 +323,8 @@ tree_ssa_dominator_optimize (void)\n   VARRAY_TREE_INIT (block_defs_stack, 20, \"Block DEFS stack\");\n   VARRAY_TREE_INIT (const_and_copies, num_ssa_names, \"const_and_copies\");\n   VARRAY_TREE_INIT (const_and_copies_stack, 20, \"Block const_and_copies stack\");\n+  VARRAY_TREE_INIT (nonzero_vars_stack, 20, \"Block nonzero_vars stack\");\n+  VARRAY_TREE_INIT (vrp_variables_stack, 20, \"Block vrp_variables stack\");\n   nonzero_vars = BITMAP_XMALLOC ();\n   VARRAY_GENERIC_PTR_INIT (vrp_data, num_ssa_names, \"vrp_data\");\n   need_eh_cleanup = BITMAP_XMALLOC ();\n@@ -332,7 +333,7 @@ tree_ssa_dominator_optimize (void)\n   /* Setup callbacks for the generic dominator tree walker.  */\n   walk_data.walk_stmts_backward = false;\n   walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data = dom_opt_initialize_block_local_data;\n+  walk_data.initialize_block_local_data = NULL;\n   walk_data.before_dom_children_before_stmts = dom_opt_initialize_block;\n   walk_data.before_dom_children_walk_stmts = optimize_stmt;\n   walk_data.before_dom_children_after_stmts = cprop_into_phis;\n@@ -343,7 +344,7 @@ tree_ssa_dominator_optimize (void)\n      When we attach more stuff we'll need to fill this out with a real\n      structure.  */\n   walk_data.global_data = NULL;\n-  walk_data.block_local_data_size = sizeof (struct dom_walk_block_data);\n+  walk_data.block_local_data_size = 0;\n \n   /* Now initialize the dominator walker.  */\n   init_walk_dominator_tree (&walk_data);\n@@ -704,45 +705,6 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n }\n \n \n-/* Initialize the local stacks.\n-     \n-   AVAIL_EXPRS stores all the expressions made available in this block.\n-\n-   CONST_AND_COPIES stores var/value pairs to restore at the end of this\n-   block.\n-\n-   NONZERO_VARS stores the vars which have a nonzero value made in this\n-   block.\n-\n-   STMTS_TO_RESCAN is a list of statements we will rescan for operands.\n-\n-   VRP_VARIABLES is the list of variables which have had their values\n-   constrained by an operation in this block.\n-\n-   These stacks are cleared in the finalization routine run for each\n-   block.  */\n-\n-static void\n-dom_opt_initialize_block_local_data (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t\t     basic_block bb ATTRIBUTE_UNUSED,\n-\t\t\t\t     bool recycled ATTRIBUTE_UNUSED)\n-{\n-  struct dom_walk_block_data *bd\n-    = (struct dom_walk_block_data *)VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n-\n-  /* We get cleared memory from the allocator, so if the memory is not\n-     cleared, then we are re-using a previously allocated entry.  In\n-     that case, we can also re-use the underlying virtual arrays.  Just\n-     make sure we clear them before using them!  */\n-  if (recycled)\n-    {\n-      gcc_assert (!bd->nonzero_vars\n-\t\t  || VARRAY_ACTIVE_SIZE (bd->nonzero_vars) == 0);\n-      gcc_assert (!bd->vrp_variables\n-\t\t  || VARRAY_ACTIVE_SIZE (bd->vrp_variables) == 0);\n-    }\n-}\n-\n /* Initialize local stacks for this optimizer and record equivalences\n    upon entry to BB.  Equivalences can come from the edge traversed to\n    reach BB or they may come from PHI nodes at the start of BB.  */\n@@ -758,6 +720,8 @@ dom_opt_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n   VARRAY_PUSH_TREE (avail_exprs_stack, NULL_TREE);\n   VARRAY_PUSH_TREE (block_defs_stack, NULL_TREE);\n   VARRAY_PUSH_TREE (const_and_copies_stack, NULL_TREE);\n+  VARRAY_PUSH_TREE (nonzero_vars_stack, NULL_TREE);\n+  VARRAY_PUSH_TREE (vrp_variables_stack, NULL_TREE);\n \n   record_equivalences_from_incoming_edge (walk_data, bb);\n \n@@ -831,18 +795,17 @@ remove_local_expressions_from_table (void)\n    state, stopping when there are LIMIT entries left in LOCALs.  */\n \n static void\n-restore_nonzero_vars_to_original_value (varray_type locals,\n-\t\t\t\t\tunsigned limit,\n-\t\t\t\t\tbitmap table)\n+restore_nonzero_vars_to_original_value ()\n {\n-  if (!locals)\n-    return;\n-\n-  while (VARRAY_ACTIVE_SIZE (locals) > limit)\n+  while (VARRAY_ACTIVE_SIZE (nonzero_vars_stack) > 0)\n     {\n-      tree name = VARRAY_TOP_TREE (locals);\n-      VARRAY_POP (locals);\n-      bitmap_clear_bit (table, SSA_NAME_VERSION (name));\n+      tree name = VARRAY_TOP_TREE (nonzero_vars_stack);\n+      VARRAY_POP (nonzero_vars_stack);\n+\n+      if (name == NULL)\n+\tbreak;\n+\n+      bitmap_clear_bit (nonzero_vars, SSA_NAME_VERSION (name));\n     }\n }\n \n@@ -912,8 +875,6 @@ restore_currdefs_to_original_value (void)\n static void\n dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n {\n-  struct dom_walk_block_data *bd\n-    = VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n   tree last;\n \n   /* If we are at a leaf node in the dominator graph, see if we can thread\n@@ -1006,7 +967,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n     }\n \n   remove_local_expressions_from_table ();\n-  restore_nonzero_vars_to_original_value (bd->nonzero_vars, 0, nonzero_vars);\n+  restore_nonzero_vars_to_original_value ();\n   restore_vars_to_original_value ();\n   restore_currdefs_to_original_value ();\n \n@@ -1016,18 +977,23 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n      To be efficient, we note which variables have had their values\n      constrained in this block.  So walk over each variable in the\n      VRP_VARIABLEs array.  */\n-  while (bd->vrp_variables && VARRAY_ACTIVE_SIZE (bd->vrp_variables) > 0)\n+  while (VARRAY_ACTIVE_SIZE (vrp_variables_stack) > 0)\n     {\n-      tree var = VARRAY_TOP_TREE (bd->vrp_variables);\n+      tree var = VARRAY_TOP_TREE (vrp_variables_stack);\n \n       /* Each variable has a stack of value range records.  We want to\n \t invalidate those associated with our basic block.  So we walk\n \t the array backwards popping off records associated with our\n \t block.  Once we hit a record not associated with our block\n \t we are done.  */\n-      varray_type var_vrp_records = VARRAY_GENERIC_PTR (vrp_data,\n-\t\t\t\t\t\t\tSSA_NAME_VERSION (var));\n+      varray_type var_vrp_records;\n+\n+      VARRAY_POP (vrp_variables_stack);\n+\n+      if (var == NULL)\n+\tbreak;\n \n+      var_vrp_records = VARRAY_GENERIC_PTR (vrp_data, SSA_NAME_VERSION (var));\n       while (VARRAY_ACTIVE_SIZE (var_vrp_records) > 0)\n \t{\n \t  struct vrp_element *element\n@@ -1039,7 +1005,6 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t  VARRAY_POP (var_vrp_records);\n \t}\n \n-      VARRAY_POP (bd->vrp_variables);\n     }\n \n   /* If we queued any statements to rescan in this block, then\n@@ -1165,15 +1130,13 @@ single_incoming_edge_ignoring_loop_edges (basic_block bb)\n    has more than one incoming edge, then no equivalence is created.  */\n \n static void\n-record_equivalences_from_incoming_edge (struct dom_walk_data *walk_data,\n+record_equivalences_from_incoming_edge (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t\t\t\t\tbasic_block bb)\n {\n   int edge_flags;\n   basic_block parent;\n   struct eq_expr_value eq_expr_value;\n   tree parent_block_last_stmt = NULL;\n-  struct dom_walk_block_data *bd\n-    = VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n \n   /* If our parent block ended with a control statment, then we may be\n      able to record some equivalences based on which outgoing edge from\n@@ -1219,8 +1182,7 @@ record_equivalences_from_incoming_edge (struct dom_walk_data *walk_data,\n       && (edge_flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n     eq_expr_value = get_eq_expr_value (parent_block_last_stmt,\n \t\t\t\t       (edge_flags & EDGE_TRUE_VALUE) != 0,\n-\t\t\t\t       bb,\n-\t\t\t\t       &bd->vrp_variables);\n+\t\t\t\t       bb);\n   /* Similarly when the parent block ended in a SWITCH_EXPR.\n      We can only know the value of the switch's condition if the dominator\n      parent is also the only predecessor of this block.  */\n@@ -1326,7 +1288,7 @@ htab_statistics (FILE *file, htab_t htab)\n    value, then we do nothing.  */\n \n static void\n-record_var_is_nonzero (tree var, varray_type *block_nonzero_vars_p)\n+record_var_is_nonzero (tree var)\n {\n   int indx = SSA_NAME_VERSION (var);\n \n@@ -1338,9 +1300,7 @@ record_var_is_nonzero (tree var, varray_type *block_nonzero_vars_p)\n \n   /* Record this SSA_NAME so that we can reset the global table\n      when we leave this block.  */\n-  if (! *block_nonzero_vars_p)\n-    VARRAY_TREE_INIT (*block_nonzero_vars_p, 2, \"block_nonzero_vars\");\n-  VARRAY_PUSH_TREE (*block_nonzero_vars_p, var);\n+  VARRAY_PUSH_TREE (nonzero_vars_stack, var);\n }\n \n /* Enter a statement into the true/false expression hash table indicating\n@@ -2403,7 +2363,6 @@ eliminate_redundant_computations (struct dom_walk_data *walk_data,\n \n static void\n record_equivalences_from_stmt (tree stmt,\n-\t\t\t       varray_type *block_nonzero_vars_p,\n \t\t\t       int may_optimize_p,\n \t\t\t       stmt_ann_t ann)\n {\n@@ -2440,14 +2399,14 @@ record_equivalences_from_stmt (tree stmt,\n           || (TREE_CODE (rhs) == ADDR_EXPR\n \t      && DECL_P (TREE_OPERAND (rhs, 0))\n \t      && ! DECL_WEAK (TREE_OPERAND (rhs, 0))))\n-\trecord_var_is_nonzero (lhs, block_nonzero_vars_p);\n+\trecord_var_is_nonzero (lhs);\n \n       /* IOR of any value with a nonzero value will result in a nonzero\n \t value.  Even if we do not know the exact result recording that\n \t the result is nonzero is worth the effort.  */\n       if (TREE_CODE (rhs) == BIT_IOR_EXPR\n \t  && integer_nonzerop (TREE_OPERAND (rhs, 1)))\n-\trecord_var_is_nonzero (lhs, block_nonzero_vars_p);\n+\trecord_var_is_nonzero (lhs);\n     }\n \n   /* Look at both sides for pointer dereferences.  If we find one, then\n@@ -2473,7 +2432,7 @@ record_equivalences_from_stmt (tree stmt,\n \t      {\n \t\ttree def = SSA_NAME_DEF_STMT (op);\n \n-\t\trecord_var_is_nonzero (op, block_nonzero_vars_p);\n+\t\trecord_var_is_nonzero (op);\n \n \t\t/* And walk up the USE-DEF chains noting other SSA_NAMEs\n \t\t   which are known to have a nonzero value.  */\n@@ -2677,8 +2636,6 @@ optimize_stmt (struct dom_walk_data *walk_data, basic_block bb,\n   tree stmt;\n   bool may_optimize_p;\n   bool may_have_exposed_new_symbols = false;\n-  struct dom_walk_block_data *bd\n-    = VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n \n   stmt = bsi_stmt (si);\n \n@@ -2742,7 +2699,6 @@ optimize_stmt (struct dom_walk_data *walk_data, basic_block bb,\n   /* Record any additional equivalences created by this statement.  */\n   if (TREE_CODE (stmt) == MODIFY_EXPR)\n     record_equivalences_from_stmt (stmt,\n-\t\t\t\t   &bd->nonzero_vars,\n \t\t\t\t   may_optimize_p,\n \t\t\t\t   ann);\n \n@@ -3017,7 +2973,7 @@ extract_range_from_cond (tree cond, tree *hi_p, tree *lo_p, int *inverted_p)\n /* Record a range created by COND for basic block BB.  */\n \n static void\n-record_range (tree cond, basic_block bb, varray_type *vrp_variables_p)\n+record_range (tree cond, basic_block bb)\n {\n   /* We explicitly ignore NE_EXPRs.  They rarely allow for meaningful\n      range optimizations and significantly complicate the implementation.  */\n@@ -3043,9 +2999,7 @@ record_range (tree cond, basic_block bb, varray_type *vrp_variables_p)\n \t}\n       \n       VARRAY_PUSH_GENERIC_PTR (*vrp_records_p, element);\n-      if (! *vrp_variables_p)\n-\tVARRAY_TREE_INIT (*vrp_variables_p, 2, \"vrp_variables\");\n-      VARRAY_PUSH_TREE (*vrp_variables_p, TREE_OPERAND (cond, 0));\n+      VARRAY_PUSH_TREE (vrp_variables_stack, TREE_OPERAND (cond, 0));\n     }\n }\n \n@@ -3068,8 +3022,7 @@ record_range (tree cond, basic_block bb, varray_type *vrp_variables_p)\n static struct eq_expr_value\n get_eq_expr_value (tree if_stmt,\n \t\t   int true_arm,\n-\t\t   basic_block bb,\n-\t\t   varray_type *vrp_variables_p)\n+\t\t   basic_block bb)\n {\n   tree cond;\n   struct eq_expr_value retval;\n@@ -3138,7 +3091,7 @@ get_eq_expr_value (tree if_stmt,\n \t      record_cond (inverted, boolean_false_node);\n \n \t      if (TREE_CONSTANT (op1))\n-\t\trecord_range (cond, bb, vrp_variables_p);\n+\t\trecord_range (cond, bb);\n \n \t\t/* If the conditional is of the form 'X == Y', return 'X = Y'\n \t\t   for the true arm.  */\n@@ -3157,7 +3110,7 @@ get_eq_expr_value (tree if_stmt,\n \t      record_cond (cond, boolean_false_node);\n \n \t      if (TREE_CONSTANT (op1))\n-\t\trecord_range (inverted, bb, vrp_variables_p);\n+\t\trecord_range (inverted, bb);\n \n \t\t/* If the conditional is of the form 'X != Y', return 'X = Y'\n \t\t   for the false arm.  */"}]}