{"sha": "752ae91493c7b2a0d99405a35ecb42407762000d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzUyYWU5MTQ5M2M3YjJhMGQ5OTQwNWEzNWVjYjQyNDA3NzYyMDAwZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-12-15T02:24:21Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-12-15T02:24:21Z"}, "message": "regrename.c (struct value_data): Add max_value_regs.\n\n        * regrename.c (struct value_data): Add max_value_regs.\n        (init_value_data): Initialize it.\n        (kill_value): Kill values that overlap the dying register.\n        (set_value_regno): New.\n        (kill_set_value, kill_autoinc_value, copy_value): Use it.\n        (copyprop_hardreg_forward_1): Kill earlyclobber operands\n        before looking at inputs.\n\nFrom-SVN: r48028", "tree": {"sha": "7448cea313891240a92a6424a5a0a25319ac62b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7448cea313891240a92a6424a5a0a25319ac62b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/752ae91493c7b2a0d99405a35ecb42407762000d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/752ae91493c7b2a0d99405a35ecb42407762000d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/752ae91493c7b2a0d99405a35ecb42407762000d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/752ae91493c7b2a0d99405a35ecb42407762000d/comments", "author": null, "committer": null, "parents": [{"sha": "ebd97b96f754b3a2e6d68ce4218b6c3b26edc5de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebd97b96f754b3a2e6d68ce4218b6c3b26edc5de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebd97b96f754b3a2e6d68ce4218b6c3b26edc5de"}], "stats": {"total": 66, "additions": 59, "deletions": 7}, "files": [{"sha": "623adb9aa6e933fe24fcd639d844d5f15fa8ba11", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/752ae91493c7b2a0d99405a35ecb42407762000d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/752ae91493c7b2a0d99405a35ecb42407762000d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=752ae91493c7b2a0d99405a35ecb42407762000d", "patch": "@@ -1,3 +1,13 @@\n+2001-12-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* regrename.c (struct value_data): Add max_value_regs.\n+\t(init_value_data): Initialize it.\n+\t(kill_value): Kill values that overlap the dying register.\n+\t(set_value_regno): New.\n+\t(kill_set_value, kill_autoinc_value, copy_value): Use it.\n+\t(copyprop_hardreg_forward_1): Kill earlyclobber operands\n+\tbefore looking at inputs.\n+\n 2001-12-14  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.h (ASM_OUTPUT_DEF_FROM_DECLS): Handle\n@@ -180,8 +190,8 @@ Fri Dec 14 12:05:14 CET 2001  Jan Hubicka  <jh@suse.cz>\n 2001-12-13  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* config/rs6000/rs6000.md (eh_set_lr_di): Change scratch\n-        constraint to base register.\n-        (eh_set_lr_si): Same.\n+\tconstraint to base register.\n+\t(eh_set_lr_si): Same.\n \n 2001-12-13  Hans-Peter Nilsson  <hp@axis.com>\n \n@@ -284,7 +294,7 @@ Thu Dec 13 12:31:07 CET 2001  Jan Hubicka  <jh@suse.cz>\n \t(flag_prefetch_loop_arrays): New global variable.\n \t(lang_independent_option): Add -fprefetch-loop-arrays.\n \t(rest_of_compilation) Pass LOOP_PREFETCH when flag_prefetch_loop_arrays\n-        is set.\n+\tis set.\n \t* Makefile.in (toplev.c): Depend on insn-flags.h.\n \t* invoke.texi (-fprefetch-loop-arrays): Document.\n "}, {"sha": "4683de40620c4d6039e49f6368b471a6bd0a82f8", "filename": "gcc/regrename.c", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/752ae91493c7b2a0d99405a35ecb42407762000d/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/752ae91493c7b2a0d99405a35ecb42407762000d/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=752ae91493c7b2a0d99405a35ecb42407762000d", "patch": "@@ -984,10 +984,13 @@ struct value_data_entry\n struct value_data\n {\n   struct value_data_entry e[FIRST_PSEUDO_REGISTER];\n+  unsigned int max_value_regs;\n };\n \n static void kill_value_regno PARAMS ((unsigned, struct value_data *));\n static void kill_value PARAMS ((rtx, struct value_data *));\n+static void set_value_regno PARAMS ((unsigned, enum machine_mode,\n+\t\t\t\t     struct value_data *));\n static void init_value_data PARAMS ((struct value_data *));\n static void kill_clobbered_value PARAMS ((rtx, rtx, void *));\n static void kill_set_value PARAMS ((rtx, rtx, void *));\n@@ -1054,13 +1057,46 @@ kill_value (x, vd)\n     {\n       unsigned int regno = REGNO (x);\n       unsigned int n = HARD_REGNO_NREGS (regno, GET_MODE (x));\n-      unsigned int i;\n+      unsigned int i, j;\n \n+      /* Kill the value we're told to kill.  */\n       for (i = 0; i < n; ++i)\n \tkill_value_regno (regno + i, vd);\n+\n+      /* Kill everything that overlapped what we're told to kill.  */\n+      if (regno < vd->max_value_regs)\n+\tj = 0;\n+      else\n+\tj = regno - vd->max_value_regs;\n+      for (; j < regno; ++j)\n+\t{\n+\t  if (vd->e[j].mode == VOIDmode)\n+\t    continue;\n+\t  n = HARD_REGNO_NREGS (regno, vd->e[j].mode);\n+\t  if (j + n > regno)\n+\t    for (i = 0; i < n; ++i)\n+\t      kill_value_regno (j + i, vd);\n+\t}\n     }\n }\n \n+/* Remember that REGNO is valid in MODE.  */\n+\n+static void\n+set_value_regno (regno, mode, vd)\n+     unsigned int regno;\n+     enum machine_mode mode;\n+     struct value_data *vd;\n+{\n+  unsigned int nregs;\n+\n+  vd->e[regno].mode = mode;\n+\n+  nregs = HARD_REGNO_NREGS (regno, mode);\n+  if (nregs > vd->max_value_regs)\n+    vd->max_value_regs = nregs;\n+}\n+\n /* Initialize VD such that there are no known relationships between regs.  */\n \n static void\n@@ -1074,6 +1110,7 @@ init_value_data (vd)\n       vd->e[i].oldest_regno = i;\n       vd->e[i].next_regno = INVALID_REGNUM;\n     }\n+  vd->max_value_regs = 0;\n }\n \n /* Called through note_stores.  If X is clobbered, kill its value.  */\n@@ -1102,7 +1139,7 @@ kill_set_value (x, set, data)\n   if (GET_CODE (set) != CLOBBER && REG_P (x))\n     {\n       kill_value (x, vd);\n-      vd->e[REGNO (x)].mode = GET_MODE (x);\n+      set_value_regno (REGNO (x), GET_MODE (x), vd);\n     }\n }\n \n@@ -1122,7 +1159,7 @@ kill_autoinc_value (px, data)\n     {\n       x = XEXP (x, 0);\n       kill_value (x, vd);\n-      vd->e[REGNO (x)].mode = Pmode;\n+      set_value_regno (REGNO (x), Pmode, vd);\n       return -1;\n     }\n \n@@ -1160,7 +1197,7 @@ copy_value (dest, src, vd)\n      assign it now and assume the value came from an input argument\n      or somesuch.  */\n   if (vd->e[sr].mode == VOIDmode)\n-    vd->e[sr].mode = vd->e[dr].mode;\n+    set_value_regno (sr, vd->e[dr].mode, vd);\n \n   /* Link DR at the end of the value chain used by SR.  */\n \n@@ -1426,6 +1463,11 @@ copyprop_hardreg_forward_1 (bb, vd)\n       /* ??? REG_INC is useless, since stack pushes aren't done that way.  */\n       for_each_rtx (&PATTERN (insn), kill_autoinc_value, vd);\n \n+      /* Kill all early-clobbered operands.  */\n+      for (i = 0; i < n_ops; i++)\n+\tif (recog_op_alt[i][alt].earlyclobber)\n+\t  kill_value (recog_data.operand[i], vd);\n+\n       /* Special-case plain move instructions, since we may well\n \t be able to do the move from a different register class.  */\n       if (set && REG_P (SET_SRC (set)))"}]}