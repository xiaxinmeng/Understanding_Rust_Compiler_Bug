{"sha": "5b6f12c7bf5e8699aee3f4c04e68c59906668e50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI2ZjEyYzdiZjVlODY5OWFlZTNmNGMwNGU2OGM1OTkwNjY2OGU1MA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-31T15:53:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-31T15:53:25Z"}, "message": "[multiple changes]\n\n2014-01-31  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Process_Formals): In Ada2012 mode, place\n\tsubprogram with an incomplete untagged formals on the list of\n\tprivate dependents, to verify that the type is properly completed\n\tin the private part.\n\t* sem_attr.adb: Code clean up.\n\n2014-01-31  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch6.adb: Minor reformatting.\n\n2014-01-31  Vincent Celier  <celier@adacore.com>\n\n\t* prj-attr.adb (First_Attribute_Of): Return Unknown_Attribute\n\twhen Pkg is unknown.\n\nFrom-SVN: r207354", "tree": {"sha": "8fa29086241568cba4b06a5dc4e2350469b69339", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fa29086241568cba4b06a5dc4e2350469b69339"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b6f12c7bf5e8699aee3f4c04e68c59906668e50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b6f12c7bf5e8699aee3f4c04e68c59906668e50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b6f12c7bf5e8699aee3f4c04e68c59906668e50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b6f12c7bf5e8699aee3f4c04e68c59906668e50/comments", "author": null, "committer": null, "parents": [{"sha": "d950f05197f4a02eb6e1347b068bbeaee3b4f768", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d950f05197f4a02eb6e1347b068bbeaee3b4f768", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d950f05197f4a02eb6e1347b068bbeaee3b4f768"}], "stats": {"total": 75, "additions": 51, "deletions": 24}, "files": [{"sha": "f5748bfa766a9122e7b9815036f77dd2111e1cf1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b6f12c7bf5e8699aee3f4c04e68c59906668e50/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b6f12c7bf5e8699aee3f4c04e68c59906668e50/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5b6f12c7bf5e8699aee3f4c04e68c59906668e50", "patch": "@@ -1,3 +1,20 @@\n+2014-01-31  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Process_Formals): In Ada2012 mode, place\n+\tsubprogram with an incomplete untagged formals on the list of\n+\tprivate dependents, to verify that the type is properly completed\n+\tin the private part.\n+\t* sem_attr.adb: Code clean up.\n+\n+2014-01-31  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch6.adb: Minor reformatting.\n+\n+2014-01-31  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-attr.adb (First_Attribute_Of): Return Unknown_Attribute\n+\twhen Pkg is unknown.\n+\n 2014-01-31  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_res.adb (Resolve_Entity_Name): Comment"}, {"sha": "4aad9d46518e7dbd36233bceafd0548b7c7e4041", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b6f12c7bf5e8699aee3f4c04e68c59906668e50/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b6f12c7bf5e8699aee3f4c04e68c59906668e50/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=5b6f12c7bf5e8699aee3f4c04e68c59906668e50", "patch": "@@ -8764,8 +8764,8 @@ package body Exp_Ch6 is\n                --  is done because the input type may lack aspect/pragma\n                --  predicate and simply inherit those from its ancestor.\n \n-               --  Note that predicate pragmas include all three cases of\n-               --  predicate aspects (Predicate, Dynamic_Predicate,\n+               --  Note that predicate pragmas correspond to all three cases\n+               --  of predicate aspects (Predicate, Dynamic_Predicate, and\n                --  Static_Predicate), so this routine checks for all three\n                --  cases.\n \n@@ -8880,7 +8880,7 @@ package body Exp_Ch6 is\n          then\n             null;\n \n-         --  Add the item\n+         --  Otherwise, add the item\n \n          else\n             if No (List) then\n@@ -9552,9 +9552,9 @@ package body Exp_Ch6 is\n       end if;\n \n       --  For now we test whether E denotes a function or access-to-function\n-      --  type whose result subtype is inherently limited. Later this test may\n-      --  be revised to allow composite nonlimited types. Functions with a\n-      --  foreign convention or whose result type has a foreign convention\n+      --  type whose result subtype is inherently limited. Later this test\n+      --  may be revised to allow composite nonlimited types. Functions with\n+      --  a foreign convention or whose result type has a foreign convention\n       --  never qualify.\n \n       if Ekind_In (E, E_Function, E_Generic_Function)\n@@ -9595,13 +9595,13 @@ package body Exp_Ch6 is\n       Function_Id : Entity_Id;\n \n    begin\n-      --  Return False when the expander is inactive, since awareness of\n-      --  build-in-place treatment is only relevant during expansion. Note that\n-      --  Is_Build_In_Place_Function, which is called as part of this function,\n-      --  is also conditioned this way, but we need to check here as well to\n-      --  avoid blowing up on processing protected calls when expansion is\n-      --  disabled (such as with -gnatc) since those would trip over the raise\n-      --  of Program_Error below.\n+      --  Return False if the expander is currently inactive, since awareness\n+      --  of build-in-place treatment is only relevant during expansion. Note\n+      --  that Is_Build_In_Place_Function, which is called as part of this\n+      --  function, is also conditioned this way, but we need to check here as\n+      --  well to avoid blowing up on processing protected calls when expansion\n+      --  is disabled (such as with -gnatc) since those would trip over the\n+      --  raise of Program_Error below.\n \n       --  In SPARK mode, build-in-place calls are not expanded, so that we\n       --  may end up with a call that is neither resolved to an entity, nor\n@@ -9778,8 +9778,7 @@ package body Exp_Ch6 is\n             --  Handle CPP primitives found in derivations of CPP_Class types.\n             --  These primitives must have been inherited from some parent, and\n             --  there is no need to register them in the dispatch table because\n-            --  Build_Inherit_Prims takes care of the initialization of these\n-            --  slots.\n+            --  Build_Inherit_Prims takes care of initializing these slots.\n \n             elsif Is_Imported (Subp)\n                and then (Convention (Subp) = Convention_CPP"}, {"sha": "6550436f44c2200129d85820c3ac8cf80660c4da", "filename": "gcc/ada/prj-attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b6f12c7bf5e8699aee3f4c04e68c59906668e50/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b6f12c7bf5e8699aee3f4c04e68c59906668e50/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=5b6f12c7bf5e8699aee3f4c04e68c59906668e50", "patch": "@@ -1013,7 +1013,7 @@ package body Prj.Attr is\n      (Pkg : Package_Node_Id) return Attribute_Node_Id\n    is\n    begin\n-      if Pkg = Empty_Package then\n+      if Pkg = Empty_Package or else Pkg = Unknown_Package then\n          return Empty_Attribute;\n       else\n          return"}, {"sha": "8e3b806ad3feacf2b0ba9e29f31b3ff47f1fee63", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b6f12c7bf5e8699aee3f4c04e68c59906668e50/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b6f12c7bf5e8699aee3f4c04e68c59906668e50/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=5b6f12c7bf5e8699aee3f4c04e68c59906668e50", "patch": "@@ -6149,7 +6149,11 @@ package body Sem_Attr is\n                   end;\n \n                elsif Is_Record_Type (P_Type) then\n-                  Check_Component_Reference (Comp, P_Type);\n+                  if Nkind (Comp) /= N_Identifier then\n+                     Error_Msg_N (\"name should be identifier or OTHERS\", Comp);\n+                  else\n+                     Check_Component_Reference (Comp, P_Type);\n+                  end if;\n                end if;\n \n                Next (Comp);"}, {"sha": "b9520de39337508429ab85ee7d5de807b7df1101", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b6f12c7bf5e8699aee3f4c04e68c59906668e50/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b6f12c7bf5e8699aee3f4c04e68c59906668e50/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=5b6f12c7bf5e8699aee3f4c04e68c59906668e50", "patch": "@@ -1907,10 +1907,11 @@ package body Sem_Ch6 is\n                   if Is_Tagged_Type (Typ) then\n                      null;\n \n-                  elsif Nkind_In (Parent (Parent (N)),\n-                     N_Accept_Statement,\n-                     N_Entry_Body,\n-                     N_Subprogram_Body)\n+                  elsif Nkind (Parent (N)) = N_Subprogram_Body\n+                    or else\n+                      Nkind_In (Parent (Parent (N)),\n+                        N_Accept_Statement,\n+                        N_Entry_Body)\n                   then\n                      Error_Msg_NE\n                        (\"invalid use of untagged incomplete type&\",\n@@ -11010,9 +11011,15 @@ package body Sem_Ch6 is\n                --  Ada 2012: tagged incomplete types are allowed as generic\n                --  formal types. They do not introduce dependencies and the\n                --  corresponding generic subprogram does not have a delayed\n-               --  freeze, because it does not need a freeze node.\n-\n-               if Is_Tagged_Type (Formal_Type) then\n+               --  freeze, because it does not need a freeze node. However,\n+               --  it is still the case that untagged incomplete types cannot\n+               --  be Taft-amendment types and must be completed in private\n+               --  part, so the subprogram must appear in the list of private\n+               --  dependents of the type.\n+\n+               if Is_Tagged_Type (Formal_Type)\n+                 or else Ada_Version >= Ada_2012\n+               then\n                   if Ekind (Scope (Current_Scope)) = E_Package\n                     and then not From_Limited_With (Formal_Type)\n                     and then not Is_Generic_Type (Formal_Type)"}]}