{"sha": "1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY0YzViOWJiMmViODE4ODBlMmJjNzI1NDM1ZDU5NmZjZDJiZGZlZg==", "commit": {"author": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2019-05-13T13:32:00Z"}, "committer": {"name": "Chung-Lin Tang", "email": "cltang@gcc.gnu.org", "date": "2019-05-13T13:32:00Z"}, "message": "2019-05-13  Chung-Lin Tang  <cltang@codesourcery.com>\n\n\tReviewed-by: Thomas Schwinge <thomas@codesourcery.com>\n\n\tlibgomp/\n\t* libgomp-plugin.h (struct goacc_asyncqueue): Declare.\n\t(struct goacc_asyncqueue_list): Likewise.\n\t(goacc_aq): Likewise.\n\t(goacc_aq_list): Likewise.\n\t(GOMP_OFFLOAD_openacc_register_async_cleanup): Remove.\n\t(GOMP_OFFLOAD_openacc_async_test): Remove.\n\t(GOMP_OFFLOAD_openacc_async_test_all): Remove.\n\t(GOMP_OFFLOAD_openacc_async_wait): Remove.\n\t(GOMP_OFFLOAD_openacc_async_wait_async): Remove.\n\t(GOMP_OFFLOAD_openacc_async_wait_all): Remove.\n\t(GOMP_OFFLOAD_openacc_async_wait_all_async): Remove.\n\t(GOMP_OFFLOAD_openacc_async_set_async): Remove.\n\t(GOMP_OFFLOAD_openacc_exec): Adjust declaration.\n\t(GOMP_OFFLOAD_openacc_cuda_get_stream): Likewise.\n\t(GOMP_OFFLOAD_openacc_cuda_set_stream): Likewise.\n\t(GOMP_OFFLOAD_openacc_async_exec): Declare.\n\t(GOMP_OFFLOAD_openacc_async_construct): Declare.\n\t(GOMP_OFFLOAD_openacc_async_destruct): Declare.\n\t(GOMP_OFFLOAD_openacc_async_test): Declare.\n\t(GOMP_OFFLOAD_openacc_async_synchronize): Declare.\n\t(GOMP_OFFLOAD_openacc_async_serialize): Declare.\n\t(GOMP_OFFLOAD_openacc_async_queue_callback): Declare.\n\t(GOMP_OFFLOAD_openacc_async_host2dev): Declare.\n\t(GOMP_OFFLOAD_openacc_async_dev2host): Declare.\n\n\t* libgomp.h (struct acc_dispatch_t): Define 'async' sub-struct.\n\t(gomp_acc_insert_pointer): Adjust declaration.\n\t(gomp_copy_host2dev): New declaration.\n\t(gomp_copy_dev2host): Likewise.\n\t(gomp_map_vars_async): Likewise.\n\t(gomp_unmap_tgt): Likewise.\n\t(gomp_unmap_vars_async): Likewise.\n\t(gomp_fini_device): Likewise.\n\n\t* oacc-async.c (get_goacc_thread): New function.\n\t(get_goacc_thread_device): New function.\n\t(lookup_goacc_asyncqueue): New function.\n\t(get_goacc_asyncqueue): New function.\n\t(acc_async_test): Adjust code to use new async design.\n\t(acc_async_test_all): Likewise.\n\t(acc_wait): Likewise.\n\t(acc_wait_async): Likewise.\n\t(acc_wait_all): Likewise.\n\t(acc_wait_all_async): Likewise.\n\t(goacc_async_free): New function.\n\t(goacc_init_asyncqueues): Likewise.\n\t(goacc_fini_asyncqueues): Likewise.\n\t* oacc-cuda.c (acc_get_cuda_stream): Adjust code to use new async\n\tdesign.\n\t(acc_set_cuda_stream): Likewise.\n\t* oacc-host.c (host_openacc_exec): Adjust parameters, remove 'async'.\n\t(host_openacc_register_async_cleanup): Remove.\n\t(host_openacc_async_exec): New function.\n\t(host_openacc_async_test): Adjust parameters.\n\t(host_openacc_async_test_all): Remove.\n\t(host_openacc_async_wait): Remove.\n\t(host_openacc_async_wait_async): Remove.\n\t(host_openacc_async_wait_all): Remove.\n\t(host_openacc_async_wait_all_async): Remove.\n\t(host_openacc_async_set_async): Remove.\n\t(host_openacc_async_synchronize): New function.\n\t(host_openacc_async_serialize): New function.\n\t(host_openacc_async_host2dev): New function.\n\t(host_openacc_async_dev2host): New function.\n\t(host_openacc_async_queue_callback): New function.\n\t(host_openacc_async_construct): New function.\n\t(host_openacc_async_destruct): New function.\n\t(struct gomp_device_descr host_dispatch): Remove initialization of old\n\tinterface, add intialization of new async sub-struct.\n\t* oacc-init.c (acc_shutdown_1): Adjust to use gomp_fini_device.\n\t(goacc_attach_host_thread_to_device): Remove old async code usage.\n\t* oacc-int.h (goacc_init_asyncqueues): New declaration.\n\t(goacc_fini_asyncqueues): Likewise.\n\t(goacc_async_copyout_unmap_vars): Likewise.\n\t(goacc_async_free): Likewise.\n\t(get_goacc_asyncqueue): Likewise.\n\t(lookup_goacc_asyncqueue): Likewise.\n\n\t* oacc-mem.c (memcpy_tofrom_device): Adjust code to use new async\n\tdesign.\n\t(present_create_copy): Adjust code to use new async design.\n\t(delete_copyout): Likewise.\n\t(update_dev_host): Likewise.\n\t(gomp_acc_insert_pointer): Add async parameter, adjust code to use new\n\tasync design.\n\t(gomp_acc_remove_pointer): Adjust code to use new async design.\n\t* oacc-parallel.c (GOACC_parallel_keyed): Adjust code to use new async\n\tdesign.\n\t(GOACC_enter_exit_data): Likewise.\n\t(goacc_wait): Likewise.\n\t(GOACC_update): Likewise.\n\t* oacc-plugin.c (GOMP_PLUGIN_async_unmap_vars): Change to assert fail\n\twhen called, warn as obsolete in comment.\n\n\t* target.c (goacc_device_copy_async): New function.\n\t(gomp_copy_host2dev): Remove 'static', add goacc_asyncqueue parameter,\n\tadd goacc_device_copy_async case.\n\t(gomp_copy_dev2host): Likewise.\n\t(gomp_map_vars_existing): Add goacc_asyncqueue parameter, adjust code.\n\t(gomp_map_pointer): Likewise.\n\t(gomp_map_fields_existing): Likewise.\n\t(gomp_map_vars_internal): New always_inline function, renamed from\n\tgomp_map_vars.\n\t(gomp_map_vars): Implement by calling gomp_map_vars_internal.\n\t(gomp_map_vars_async): Implement by calling gomp_map_vars_internal,\n\tpassing goacc_asyncqueue argument.\n\t(gomp_unmap_tgt): Remove static, add attribute_hidden.\n\t(gomp_unref_tgt): New function.\n\t(gomp_unmap_vars_internal): New always_inline function, renamed from\n\tgomp_unmap_vars.\n\t(gomp_unmap_vars): Implement by calling gomp_unmap_vars_internal.\n\t(gomp_unmap_vars_async): Implement by calling\n\tgomp_unmap_vars_internal, passing goacc_asyncqueue argument.\n\t(gomp_fini_device): New function.\n\t(gomp_exit_data): Adjust gomp_copy_dev2host call.\n\t(gomp_load_plugin_for_device): Remove old interface, adjust to load\n\tnew async interface.\n\t(gomp_target_fini): Adjust code to call gomp_fini_device.\n\n\t* plugin/plugin-nvptx.c (struct cuda_map): Remove.\n\t(struct ptx_stream): Remove.\n\t(struct nvptx_thread): Remove current_stream field.\n\t(cuda_map_create): Remove.\n\t(cuda_map_destroy): Remove.\n\t(map_init): Remove.\n\t(map_fini): Remove.\n\t(map_pop): Remove.\n\t(map_push): Remove.\n\t(struct goacc_asyncqueue): Define.\n\t(struct nvptx_callback): Define.\n\t(struct ptx_free_block): Define.\n\t(struct ptx_device): Remove null_stream, active_streams, async_streams,\n\tstream_lock, and next fields.\n\t(enum ptx_event_type): Remove.\n\t(struct ptx_event): Remove.\n\t(ptx_event_lock): Remove.\n\t(ptx_events): Remove.\n\t(init_streams_for_device): Remove.\n\t(fini_streams_for_device): Remove.\n\t(select_stream_for_async): Remove.\n\t(nvptx_init): Remove ptx_events and ptx_event_lock references.\n\t(nvptx_attach_host_thread_to_device): Remove CUDA_ERROR_NOT_PERMITTED\n\tcase.\n\t(nvptx_open_device): Add free_blocks initialization, remove\n\tinit_streams_for_device call.\n\t(nvptx_close_device): Remove fini_streams_for_device call, add\n\tfree_blocks destruct code.\n\t(event_gc): Remove.\n\t(event_add): Remove.\n\t(nvptx_exec): Adjust parameters and code.\n\t(nvptx_free): Likewise.\n\t(nvptx_host2dev): Remove.\n\t(nvptx_dev2host): Remove.\n\t(nvptx_set_async): Remove.\n\t(nvptx_async_test): Remove.\n\t(nvptx_async_test_all): Remove.\n\t(nvptx_wait): Remove.\n\t(nvptx_wait_async): Remove.\n\t(nvptx_wait_all): Remove.\n\t(nvptx_wait_all_async): Remove.\n\t(nvptx_get_cuda_stream): Remove.\n\t(nvptx_set_cuda_stream): Remove.\n\t(GOMP_OFFLOAD_alloc): Adjust code.\n\t(GOMP_OFFLOAD_free): Likewise.\n\t(GOMP_OFFLOAD_openacc_register_async_cleanup): Remove.\n\t(GOMP_OFFLOAD_openacc_exec): Adjust parameters and code.\n\t(GOMP_OFFLOAD_openacc_async_test_all): Remove.\n\t(GOMP_OFFLOAD_openacc_async_wait): Remove.\n\t(GOMP_OFFLOAD_openacc_async_wait_async): Remove.\n\t(GOMP_OFFLOAD_openacc_async_wait_all): Remove.\n\t(GOMP_OFFLOAD_openacc_async_wait_all_async): Remove.\n\t(GOMP_OFFLOAD_openacc_async_set_async): Remove.\n\t(cuda_free_argmem): New function.\n\t(GOMP_OFFLOAD_openacc_async_exec): New plugin hook function.\n\t(GOMP_OFFLOAD_openacc_create_thread_data): Adjust code.\n\t(GOMP_OFFLOAD_openacc_cuda_get_stream): Adjust code.\n\t(GOMP_OFFLOAD_openacc_cuda_set_stream): Adjust code.\n\t(GOMP_OFFLOAD_openacc_async_construct): New plugin hook function.\n\t(GOMP_OFFLOAD_openacc_async_destruct): New plugin hook function.\n\t(GOMP_OFFLOAD_openacc_async_test): Remove and re-implement.\n\t(GOMP_OFFLOAD_openacc_async_synchronize): New plugin hook function.\n\t(GOMP_OFFLOAD_openacc_async_serialize): New plugin hook function.\n\t(GOMP_OFFLOAD_openacc_async_queue_callback): New plugin hook function.\n\t(cuda_callback_wrapper): New function.\n\t(cuda_memcpy_sanity_check): New function.\n\t(GOMP_OFFLOAD_host2dev): Remove and re-implement.\n\t(GOMP_OFFLOAD_dev2host): Remove and re-implement.\n\t(GOMP_OFFLOAD_openacc_async_host2dev): New plugin hook function.\n\t(GOMP_OFFLOAD_openacc_async_dev2host): New plugin hook function.\n\nFrom-SVN: r271128", "tree": {"sha": "5bc5ab9a965b79bc46065ff6f4ac986b34239caa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bc5ab9a965b79bc46065ff6f4ac986b34239caa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/comments", "author": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f78f5d239203d0da6638bc5e20080971d61d09d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f78f5d239203d0da6638bc5e20080971d61d09d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f78f5d239203d0da6638bc5e20080971d61d09d9"}], "stats": {"total": 2377, "additions": 1107, "deletions": 1270}, "files": [{"sha": "a16d5244f54ec94f9f973109fa84735a22e215c2", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "patch": "@@ -1,3 +1,193 @@\n+2019-05-13  Chung-Lin Tang <cltang@codesourcery.com>\n+\n+\t* libgomp-plugin.h (struct goacc_asyncqueue): Declare.\n+\t(struct goacc_asyncqueue_list): Likewise.\n+\t(goacc_aq): Likewise.\n+\t(goacc_aq_list): Likewise.\n+\t(GOMP_OFFLOAD_openacc_register_async_cleanup): Remove.\n+\t(GOMP_OFFLOAD_openacc_async_test): Remove.\n+\t(GOMP_OFFLOAD_openacc_async_test_all): Remove.\n+\t(GOMP_OFFLOAD_openacc_async_wait): Remove.\n+\t(GOMP_OFFLOAD_openacc_async_wait_async): Remove.\n+\t(GOMP_OFFLOAD_openacc_async_wait_all): Remove.\n+\t(GOMP_OFFLOAD_openacc_async_wait_all_async): Remove.\n+\t(GOMP_OFFLOAD_openacc_async_set_async): Remove.\n+\t(GOMP_OFFLOAD_openacc_exec): Adjust declaration.\n+\t(GOMP_OFFLOAD_openacc_cuda_get_stream): Likewise.\n+\t(GOMP_OFFLOAD_openacc_cuda_set_stream): Likewise.\n+\t(GOMP_OFFLOAD_openacc_async_exec): Declare.\n+\t(GOMP_OFFLOAD_openacc_async_construct): Declare.\n+\t(GOMP_OFFLOAD_openacc_async_destruct): Declare.\n+\t(GOMP_OFFLOAD_openacc_async_test): Declare.\n+\t(GOMP_OFFLOAD_openacc_async_synchronize): Declare.\n+\t(GOMP_OFFLOAD_openacc_async_serialize): Declare.\n+\t(GOMP_OFFLOAD_openacc_async_queue_callback): Declare.\n+\t(GOMP_OFFLOAD_openacc_async_host2dev): Declare.\n+\t(GOMP_OFFLOAD_openacc_async_dev2host): Declare.\n+\n+\t* libgomp.h (struct acc_dispatch_t): Define 'async' sub-struct.\n+\t(gomp_acc_insert_pointer): Adjust declaration.\n+\t(gomp_copy_host2dev): New declaration.\n+\t(gomp_copy_dev2host): Likewise.\n+\t(gomp_map_vars_async): Likewise.\n+\t(gomp_unmap_tgt): Likewise.\n+\t(gomp_unmap_vars_async): Likewise.\n+\t(gomp_fini_device): Likewise.\n+\n+\t* oacc-async.c (get_goacc_thread): New function.\n+\t(get_goacc_thread_device): New function.\n+\t(lookup_goacc_asyncqueue): New function.\n+\t(get_goacc_asyncqueue): New function.\n+\t(acc_async_test): Adjust code to use new async design.\n+\t(acc_async_test_all): Likewise.\n+\t(acc_wait): Likewise.\n+\t(acc_wait_async): Likewise.\n+\t(acc_wait_all): Likewise.\n+\t(acc_wait_all_async): Likewise.\n+\t(goacc_async_free): New function.\n+\t(goacc_init_asyncqueues): Likewise.\n+\t(goacc_fini_asyncqueues): Likewise.\n+\t* oacc-cuda.c (acc_get_cuda_stream): Adjust code to use new async\n+\tdesign.\n+\t(acc_set_cuda_stream): Likewise.\n+\t* oacc-host.c (host_openacc_exec): Adjust parameters, remove 'async'.\n+\t(host_openacc_register_async_cleanup): Remove.\n+\t(host_openacc_async_exec): New function.\n+\t(host_openacc_async_test): Adjust parameters.\n+\t(host_openacc_async_test_all): Remove.\n+\t(host_openacc_async_wait): Remove.\n+\t(host_openacc_async_wait_async): Remove.\n+\t(host_openacc_async_wait_all): Remove.\n+\t(host_openacc_async_wait_all_async): Remove.\n+\t(host_openacc_async_set_async): Remove.\n+\t(host_openacc_async_synchronize): New function.\n+\t(host_openacc_async_serialize): New function.\n+\t(host_openacc_async_host2dev): New function.\n+\t(host_openacc_async_dev2host): New function.\n+\t(host_openacc_async_queue_callback): New function.\n+\t(host_openacc_async_construct): New function.\n+\t(host_openacc_async_destruct): New function.\n+\t(struct gomp_device_descr host_dispatch): Remove initialization of old\n+\tinterface, add intialization of new async sub-struct.\n+\t* oacc-init.c (acc_shutdown_1): Adjust to use gomp_fini_device.\n+\t(goacc_attach_host_thread_to_device): Remove old async code usage.\n+\t* oacc-int.h (goacc_init_asyncqueues): New declaration.\n+\t(goacc_fini_asyncqueues): Likewise.\n+\t(goacc_async_copyout_unmap_vars): Likewise.\n+\t(goacc_async_free): Likewise.\n+\t(get_goacc_asyncqueue): Likewise.\n+\t(lookup_goacc_asyncqueue): Likewise.\n+\t* oacc-mem.c (memcpy_tofrom_device): Adjust code to use new async\n+\tdesign.\n+\t(present_create_copy): Adjust code to use new async design.\n+\t(delete_copyout): Likewise.\n+\t(update_dev_host): Likewise.\n+\t(gomp_acc_insert_pointer): Add async parameter, adjust code to use new\n+\tasync design.\n+\t(gomp_acc_remove_pointer): Adjust code to use new async design.\n+\t* oacc-parallel.c (GOACC_parallel_keyed): Adjust code to use new async\n+\tdesign.\n+\t(GOACC_enter_exit_data): Likewise.\n+\t(goacc_wait): Likewise.\n+\t(GOACC_update): Likewise.\n+\t* oacc-plugin.c (GOMP_PLUGIN_async_unmap_vars): Change to assert fail\n+\twhen called, warn as obsolete in comment.\n+\t* target.c (goacc_device_copy_async): New function.\n+\t(gomp_copy_host2dev): Remove 'static', add goacc_asyncqueue parameter,\n+\tadd goacc_device_copy_async case.\n+\t(gomp_copy_dev2host): Likewise.\n+\t(gomp_map_vars_existing): Add goacc_asyncqueue parameter, adjust code.\n+\t(gomp_map_pointer): Likewise.\n+\t(gomp_map_fields_existing): Likewise.\n+\t(gomp_map_vars_internal): New always_inline function, renamed from\n+\tgomp_map_vars.\n+\t(gomp_map_vars): Implement by calling gomp_map_vars_internal.\n+\t(gomp_map_vars_async): Implement by calling gomp_map_vars_internal,\n+\tpassing goacc_asyncqueue argument.\n+\t(gomp_unmap_tgt): Remove static, add attribute_hidden.\n+\t(gomp_unref_tgt): New function.\n+\t(gomp_unmap_vars_internal): New always_inline function, renamed from\n+\tgomp_unmap_vars.\n+\t(gomp_unmap_vars): Implement by calling gomp_unmap_vars_internal.\n+\t(gomp_unmap_vars_async): Implement by calling\n+\tgomp_unmap_vars_internal, passing goacc_asyncqueue argument.\n+\t(gomp_fini_device): New function.\n+\t(gomp_exit_data): Adjust gomp_copy_dev2host call.\n+\t(gomp_load_plugin_for_device): Remove old interface, adjust to load\n+\tnew async interface.\n+\t(gomp_target_fini): Adjust code to call gomp_fini_device.\n+\n+\t* plugin/plugin-nvptx.c (struct cuda_map): Remove.\n+\t(struct ptx_stream): Remove.\n+\t(struct nvptx_thread): Remove current_stream field.\n+\t(cuda_map_create): Remove.\n+\t(cuda_map_destroy): Remove.\n+\t(map_init): Remove.\n+\t(map_fini): Remove.\n+\t(map_pop): Remove.\n+\t(map_push): Remove.\n+\t(struct goacc_asyncqueue): Define.\n+\t(struct nvptx_callback): Define.\n+\t(struct ptx_free_block): Define.\n+\t(struct ptx_device): Remove null_stream, active_streams, async_streams,\n+\tstream_lock, and next fields.\n+\t(enum ptx_event_type): Remove.\n+\t(struct ptx_event): Remove.\n+\t(ptx_event_lock): Remove.\n+\t(ptx_events): Remove.\n+\t(init_streams_for_device): Remove.\n+\t(fini_streams_for_device): Remove.\n+\t(select_stream_for_async): Remove.\n+\t(nvptx_init): Remove ptx_events and ptx_event_lock references.\n+\t(nvptx_attach_host_thread_to_device): Remove CUDA_ERROR_NOT_PERMITTED\n+\tcase.\n+\t(nvptx_open_device): Add free_blocks initialization, remove\n+\tinit_streams_for_device call.\n+\t(nvptx_close_device): Remove fini_streams_for_device call, add\n+\tfree_blocks destruct code.\n+\t(event_gc): Remove.\n+\t(event_add): Remove.\n+\t(nvptx_exec): Adjust parameters and code.\n+\t(nvptx_free): Likewise.\n+\t(nvptx_host2dev): Remove.\n+\t(nvptx_dev2host): Remove.\n+\t(nvptx_set_async): Remove.\n+\t(nvptx_async_test): Remove.\n+\t(nvptx_async_test_all): Remove.\n+\t(nvptx_wait): Remove.\n+\t(nvptx_wait_async): Remove.\n+\t(nvptx_wait_all): Remove.\n+\t(nvptx_wait_all_async): Remove.\n+\t(nvptx_get_cuda_stream): Remove.\n+\t(nvptx_set_cuda_stream): Remove.\n+\t(GOMP_OFFLOAD_alloc): Adjust code.\n+\t(GOMP_OFFLOAD_free): Likewise.\n+\t(GOMP_OFFLOAD_openacc_register_async_cleanup): Remove.\n+\t(GOMP_OFFLOAD_openacc_exec): Adjust parameters and code.\n+\t(GOMP_OFFLOAD_openacc_async_test_all): Remove.\n+\t(GOMP_OFFLOAD_openacc_async_wait): Remove.\n+\t(GOMP_OFFLOAD_openacc_async_wait_async): Remove.\n+\t(GOMP_OFFLOAD_openacc_async_wait_all): Remove.\n+\t(GOMP_OFFLOAD_openacc_async_wait_all_async): Remove.\n+\t(GOMP_OFFLOAD_openacc_async_set_async): Remove.\n+\t(cuda_free_argmem): New function.\n+\t(GOMP_OFFLOAD_openacc_async_exec): New plugin hook function.\n+\t(GOMP_OFFLOAD_openacc_create_thread_data): Adjust code.\n+\t(GOMP_OFFLOAD_openacc_cuda_get_stream): Adjust code.\n+\t(GOMP_OFFLOAD_openacc_cuda_set_stream): Adjust code.\n+\t(GOMP_OFFLOAD_openacc_async_construct): New plugin hook function.\n+\t(GOMP_OFFLOAD_openacc_async_destruct): New plugin hook function.\n+\t(GOMP_OFFLOAD_openacc_async_test): Remove and re-implement.\n+\t(GOMP_OFFLOAD_openacc_async_synchronize): New plugin hook function.\n+\t(GOMP_OFFLOAD_openacc_async_serialize): New plugin hook function.\n+\t(GOMP_OFFLOAD_openacc_async_queue_callback): New plugin hook function.\n+\t(cuda_callback_wrapper): New function.\n+\t(cuda_memcpy_sanity_check): New function.\n+\t(GOMP_OFFLOAD_host2dev): Remove and re-implement.\n+\t(GOMP_OFFLOAD_dev2host): Remove and re-implement.\n+\t(GOMP_OFFLOAD_openacc_async_host2dev): New plugin hook function.\n+\t(GOMP_OFFLOAD_openacc_async_dev2host): New plugin hook function.\n+\n 2019-05-07  Thomas Schwinge  <thomas@codesourcery.com>\n \n \tPR target/87835"}, {"sha": "01483f27f4cb9d3033e533e9c6e91db519e4345a", "filename": "libgomp/libgomp-plugin.h", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Flibgomp-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Flibgomp-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp-plugin.h?ref=1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "patch": "@@ -53,6 +53,20 @@ enum offload_target_type\n   OFFLOAD_TARGET_TYPE_HSA = 7\n };\n \n+/* Opaque type to represent plugin-dependent implementation of an\n+   OpenACC asynchronous queue.  */\n+struct goacc_asyncqueue;\n+\n+/* Used to keep a list of active asynchronous queues.  */\n+struct goacc_asyncqueue_list\n+{\n+  struct goacc_asyncqueue *aq;\n+  struct goacc_asyncqueue_list *next;\n+};\n+\n+typedef struct goacc_asyncqueue *goacc_aq;\n+typedef struct goacc_asyncqueue_list *goacc_aq_list;\n+\n /* Auxiliary struct, used for transferring pairs of addresses from plugin\n    to libgomp.  */\n struct addr_pair\n@@ -93,22 +107,31 @@ extern bool GOMP_OFFLOAD_dev2dev (int, void *, const void *, size_t);\n extern bool GOMP_OFFLOAD_can_run (void *);\n extern void GOMP_OFFLOAD_run (int, void *, void *, void **);\n extern void GOMP_OFFLOAD_async_run (int, void *, void *, void **, void *);\n+\n extern void GOMP_OFFLOAD_openacc_exec (void (*) (void *), size_t, void **,\n-\t\t\t\t       void **, int, unsigned *, void *);\n-extern void GOMP_OFFLOAD_openacc_register_async_cleanup (void *, int);\n-extern int GOMP_OFFLOAD_openacc_async_test (int);\n-extern int GOMP_OFFLOAD_openacc_async_test_all (void);\n-extern void GOMP_OFFLOAD_openacc_async_wait (int);\n-extern void GOMP_OFFLOAD_openacc_async_wait_async (int, int);\n-extern void GOMP_OFFLOAD_openacc_async_wait_all (void);\n-extern void GOMP_OFFLOAD_openacc_async_wait_all_async (int);\n-extern void GOMP_OFFLOAD_openacc_async_set_async (int);\n+\t\t\t\t       void **, unsigned *, void *);\n extern void *GOMP_OFFLOAD_openacc_create_thread_data (int);\n extern void GOMP_OFFLOAD_openacc_destroy_thread_data (void *);\n+extern struct goacc_asyncqueue *GOMP_OFFLOAD_openacc_async_construct (void);\n+extern bool GOMP_OFFLOAD_openacc_async_destruct (struct goacc_asyncqueue *);\n+extern int GOMP_OFFLOAD_openacc_async_test (struct goacc_asyncqueue *);\n+extern bool GOMP_OFFLOAD_openacc_async_synchronize (struct goacc_asyncqueue *);\n+extern bool GOMP_OFFLOAD_openacc_async_serialize (struct goacc_asyncqueue *,\n+\t\t\t\t\t\t  struct goacc_asyncqueue *);\n+extern void GOMP_OFFLOAD_openacc_async_queue_callback (struct goacc_asyncqueue *,\n+\t\t\t\t\t\t       void (*)(void *), void *);\n+extern void GOMP_OFFLOAD_openacc_async_exec (void (*) (void *), size_t, void **,\n+\t\t\t\t\t     void **, unsigned *, void *,\n+\t\t\t\t\t     struct goacc_asyncqueue *);\n+extern bool GOMP_OFFLOAD_openacc_async_dev2host (int, void *, const void *, size_t,\n+\t\t\t\t\t\t struct goacc_asyncqueue *);\n+extern bool GOMP_OFFLOAD_openacc_async_host2dev (int, void *, const void *, size_t,\n+\t\t\t\t\t\t struct goacc_asyncqueue *);\n extern void *GOMP_OFFLOAD_openacc_cuda_get_current_device (void);\n extern void *GOMP_OFFLOAD_openacc_cuda_get_current_context (void);\n-extern void *GOMP_OFFLOAD_openacc_cuda_get_stream (int);\n-extern int GOMP_OFFLOAD_openacc_cuda_set_stream (int, void *);\n+extern void *GOMP_OFFLOAD_openacc_cuda_get_stream (struct goacc_asyncqueue *);\n+extern int GOMP_OFFLOAD_openacc_cuda_set_stream (struct goacc_asyncqueue *,\n+\t\t\t\t\t\t void *);\n \n #ifdef __cplusplus\n }"}, {"sha": "9f433160ab5921755118b36fb9c8e79d4e03c1dc", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "patch": "@@ -949,24 +949,31 @@ typedef struct acc_dispatch_t\n   /* Execute.  */\n   __typeof (GOMP_OFFLOAD_openacc_exec) *exec_func;\n \n-  /* Async cleanup callback registration.  */\n-  __typeof (GOMP_OFFLOAD_openacc_register_async_cleanup)\n-    *register_async_cleanup_func;\n-\n-  /* Asynchronous routines.  */\n-  __typeof (GOMP_OFFLOAD_openacc_async_test) *async_test_func;\n-  __typeof (GOMP_OFFLOAD_openacc_async_test_all) *async_test_all_func;\n-  __typeof (GOMP_OFFLOAD_openacc_async_wait) *async_wait_func;\n-  __typeof (GOMP_OFFLOAD_openacc_async_wait_async) *async_wait_async_func;\n-  __typeof (GOMP_OFFLOAD_openacc_async_wait_all) *async_wait_all_func;\n-  __typeof (GOMP_OFFLOAD_openacc_async_wait_all_async)\n-    *async_wait_all_async_func;\n-  __typeof (GOMP_OFFLOAD_openacc_async_set_async) *async_set_async_func;\n-\n   /* Create/destroy TLS data.  */\n   __typeof (GOMP_OFFLOAD_openacc_create_thread_data) *create_thread_data_func;\n   __typeof (GOMP_OFFLOAD_openacc_destroy_thread_data)\n     *destroy_thread_data_func;\n+  \n+  struct {\n+    /* Once created and put into the \"active\" list, asyncqueues are then never\n+       destructed and removed from the \"active\" list, other than if the TODO\n+       device is shut down.  */\n+    gomp_mutex_t lock;\n+    int nasyncqueue;\n+    struct goacc_asyncqueue **asyncqueue;\n+    struct goacc_asyncqueue_list *active;\n+\n+    __typeof (GOMP_OFFLOAD_openacc_async_construct) *construct_func;\n+    __typeof (GOMP_OFFLOAD_openacc_async_destruct) *destruct_func;\n+    __typeof (GOMP_OFFLOAD_openacc_async_test) *test_func;\n+    __typeof (GOMP_OFFLOAD_openacc_async_synchronize) *synchronize_func;\n+    __typeof (GOMP_OFFLOAD_openacc_async_serialize) *serialize_func;\n+    __typeof (GOMP_OFFLOAD_openacc_async_queue_callback) *queue_callback_func;\n+\n+    __typeof (GOMP_OFFLOAD_openacc_async_exec) *exec_func;\n+    __typeof (GOMP_OFFLOAD_openacc_async_dev2host) *dev2host_func;\n+    __typeof (GOMP_OFFLOAD_openacc_async_host2dev) *host2dev_func;\n+  } async;\n \n   /* NVIDIA target specific routines.  */\n   struct {\n@@ -1053,17 +1060,33 @@ enum gomp_map_vars_kind\n   GOMP_MAP_VARS_ENTER_DATA\n };\n \n-extern void gomp_acc_insert_pointer (size_t, void **, size_t *, void *);\n+extern void gomp_acc_insert_pointer (size_t, void **, size_t *, void *, int);\n extern void gomp_acc_remove_pointer (void *, size_t, bool, int, int, int);\n extern void gomp_acc_declare_allocate (bool, size_t, void **, size_t *,\n \t\t\t\t       unsigned short *);\n+struct gomp_coalesce_buf;\n+extern void gomp_copy_host2dev (struct gomp_device_descr *,\n+\t\t\t\tstruct goacc_asyncqueue *, void *, const void *,\n+\t\t\t\tsize_t, struct gomp_coalesce_buf *);\n+extern void gomp_copy_dev2host (struct gomp_device_descr *,\n+\t\t\t\tstruct goacc_asyncqueue *, void *, const void *,\n+\t\t\t\tsize_t);\n \n extern struct target_mem_desc *gomp_map_vars (struct gomp_device_descr *,\n \t\t\t\t\t      size_t, void **, void **,\n \t\t\t\t\t      size_t *, void *, bool,\n \t\t\t\t\t      enum gomp_map_vars_kind);\n+extern struct target_mem_desc *gomp_map_vars_async (struct gomp_device_descr *,\n+\t\t\t\t\t\t    struct goacc_asyncqueue *,\n+\t\t\t\t\t\t    size_t, void **, void **,\n+\t\t\t\t\t\t    size_t *, void *, bool,\n+\t\t\t\t\t\t    enum gomp_map_vars_kind);\n+extern void gomp_unmap_tgt (struct target_mem_desc *);\n extern void gomp_unmap_vars (struct target_mem_desc *, bool);\n+extern void gomp_unmap_vars_async (struct target_mem_desc *, bool,\n+\t\t\t\t   struct goacc_asyncqueue *);\n extern void gomp_init_device (struct gomp_device_descr *);\n+extern bool gomp_fini_device (struct gomp_device_descr *);\n extern void gomp_free_memmap (struct splay_tree_s *);\n extern void gomp_unload_device (struct gomp_device_descr *);\n extern bool gomp_remove_var (struct gomp_device_descr *, splay_tree_key);"}, {"sha": "51bb676610c8622f567535bb0c755c37e87704e2", "filename": "libgomp/oacc-async.c", "status": "modified", "additions": 223, "deletions": 27, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Foacc-async.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Foacc-async.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-async.c?ref=1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "patch": "@@ -27,47 +27,160 @@\n    <http://www.gnu.org/licenses/>.  */\n \n #include <assert.h>\n+#include <string.h>\n #include \"openacc.h\"\n #include \"libgomp.h\"\n #include \"oacc-int.h\"\n \n-int\n-acc_async_test (int async)\n+static struct goacc_thread *\n+get_goacc_thread (void)\n {\n-  if (!async_valid_p (async))\n-    gomp_fatal (\"invalid async argument: %d\", async);\n-\n   struct goacc_thread *thr = goacc_thread ();\n \n   if (!thr || !thr->dev)\n     gomp_fatal (\"no device active\");\n \n-  return thr->dev->openacc.async_test_func (async);\n+  return thr;\n }\n \n-int\n-acc_async_test_all (void)\n+static struct gomp_device_descr *\n+get_goacc_thread_device (void)\n {\n   struct goacc_thread *thr = goacc_thread ();\n \n   if (!thr || !thr->dev)\n     gomp_fatal (\"no device active\");\n \n-  return thr->dev->openacc.async_test_all_func ();\n+  return thr->dev;\n }\n \n-void\n-acc_wait (int async)\n+static int\n+validate_async_val (int async)\n {\n   if (!async_valid_p (async))\n-    gomp_fatal (\"invalid async argument: %d\", async);\n+    gomp_fatal (\"invalid async-argument: %d\", async);\n+\n+  if (async == acc_async_sync)\n+    return -1;\n+\n+  if (async == acc_async_noval)\n+    return 0;\n+\n+  if (async >= 0)\n+    /* TODO: we reserve 0 for acc_async_noval before we can clarify the\n+       semantics of \"default_async\".  */\n+    return 1 + async;\n+  else\n+    __builtin_unreachable ();\n+}\n+\n+/* Return the asyncqueue to be used for OpenACC async-argument ASYNC.  This\n+   might return NULL if no asyncqueue is to be used.  Otherwise, if CREATE,\n+   create the asyncqueue if it doesn't exist yet.  */\n+\n+attribute_hidden struct goacc_asyncqueue *\n+lookup_goacc_asyncqueue (struct goacc_thread *thr, bool create, int async)\n+{\n+  async = validate_async_val (async);\n+  if (async < 0)\n+    return NULL;\n+\n+  struct goacc_asyncqueue *ret_aq = NULL;\n+  struct gomp_device_descr *dev = thr->dev;\n+\n+  gomp_mutex_lock (&dev->openacc.async.lock);\n \n+  if (!create\n+      && (async >= dev->openacc.async.nasyncqueue\n+\t  || !dev->openacc.async.asyncqueue[async]))\n+    goto end;\n+\n+  if (async >= dev->openacc.async.nasyncqueue)\n+    {\n+      int diff = async + 1 - dev->openacc.async.nasyncqueue;\n+      dev->openacc.async.asyncqueue\n+\t= gomp_realloc (dev->openacc.async.asyncqueue,\n+\t\t\tsizeof (goacc_aq) * (async + 1));\n+      memset (dev->openacc.async.asyncqueue + dev->openacc.async.nasyncqueue,\n+\t      0, sizeof (goacc_aq) * diff);\n+      dev->openacc.async.nasyncqueue = async + 1;\n+    }\n+\n+  if (!dev->openacc.async.asyncqueue[async])\n+    {\n+      dev->openacc.async.asyncqueue[async] = dev->openacc.async.construct_func ();\n+\n+      if (!dev->openacc.async.asyncqueue[async])\n+\t{\n+\t  gomp_mutex_unlock (&dev->openacc.async.lock);\n+\t  gomp_fatal (\"async %d creation failed\", async);\n+\t}\n+      \n+      /* Link new async queue into active list.  */\n+      goacc_aq_list n = gomp_malloc (sizeof (struct goacc_asyncqueue_list));\n+      n->aq = dev->openacc.async.asyncqueue[async];\n+      n->next = dev->openacc.async.active;\n+      dev->openacc.async.active = n;\n+    }\n+\n+  ret_aq = dev->openacc.async.asyncqueue[async];\n+\n+ end:\n+  gomp_mutex_unlock (&dev->openacc.async.lock);\n+  return ret_aq;\n+}\n+\n+/* Return the asyncqueue to be used for OpenACC async-argument ASYNC.  This\n+   might return NULL if no asyncqueue is to be used.  Otherwise, create the\n+   asyncqueue if it doesn't exist yet.  */\n+\n+attribute_hidden struct goacc_asyncqueue *\n+get_goacc_asyncqueue (int async)\n+{\n+  struct goacc_thread *thr = get_goacc_thread ();\n+  return lookup_goacc_asyncqueue (thr, true, async);\n+}\n+\n+int\n+acc_async_test (int async)\n+{\n   struct goacc_thread *thr = goacc_thread ();\n \n   if (!thr || !thr->dev)\n     gomp_fatal (\"no device active\");\n \n-  thr->dev->openacc.async_wait_func (async);\n+  goacc_aq aq = lookup_goacc_asyncqueue (thr, false, async);\n+  if (!aq)\n+    return 1;\n+  else\n+    return thr->dev->openacc.async.test_func (aq);\n+}\n+\n+int\n+acc_async_test_all (void)\n+{\n+  struct goacc_thread *thr = get_goacc_thread ();\n+\n+  int ret = 1;\n+  gomp_mutex_lock (&thr->dev->openacc.async.lock);\n+  for (goacc_aq_list l = thr->dev->openacc.async.active; l; l = l->next)\n+    if (!thr->dev->openacc.async.test_func (l->aq))\n+      {\n+\tret = 0;\n+\tbreak;\n+      }\n+  gomp_mutex_unlock (&thr->dev->openacc.async.lock);\n+  return ret;\n+}\n+\n+void\n+acc_wait (int async)\n+{\n+  struct goacc_thread *thr = get_goacc_thread ();\n+\n+  goacc_aq aq = lookup_goacc_asyncqueue (thr, false, async);\n+  if (aq && !thr->dev->openacc.async.synchronize_func (aq))\n+    gomp_fatal (\"wait on %d failed\", async);\n }\n \n /* acc_async_wait is an OpenACC 1.0 compatibility name for acc_wait.  */\n@@ -84,23 +197,46 @@ acc_async_wait (int async)\n void\n acc_wait_async (int async1, int async2)\n {\n-  struct goacc_thread *thr = goacc_thread ();\n+  struct goacc_thread *thr = get_goacc_thread ();\n \n-  if (!thr || !thr->dev)\n-    gomp_fatal (\"no device active\");\n+  goacc_aq aq1 = lookup_goacc_asyncqueue (thr, false, async1);\n+  /* TODO: Is this also correct for acc_async_sync, assuming that in this case,\n+     we'll always be synchronous anyways?  */\n+  if (!aq1)\n+    return;\n+\n+  goacc_aq aq2 = lookup_goacc_asyncqueue (thr, true, async2);\n+  /* An async queue is always synchronized with itself.  */\n+  if (aq1 == aq2)\n+    return;\n \n-  thr->dev->openacc.async_wait_async_func (async1, async2);\n+  if (aq2)\n+    {\n+      if (!thr->dev->openacc.async.serialize_func (aq1, aq2))\n+\tgomp_fatal (\"ordering of async ids %d and %d failed\", async1, async2);\n+    }\n+  else\n+    {\n+      /* TODO: Local thread synchronization.\n+\t Necessary for the \"async2 == acc_async_sync\" case, or can just skip?  */\n+      if (!thr->dev->openacc.async.synchronize_func (aq1))\n+\tgomp_fatal (\"wait on %d failed\", async1);\n+    }\n }\n \n void\n acc_wait_all (void)\n {\n-  struct goacc_thread *thr = goacc_thread ();\n+  struct gomp_device_descr *dev = get_goacc_thread_device ();\n \n-  if (!thr || !thr->dev)\n-    gomp_fatal (\"no device active\");\n+  bool ret = true;\n+  gomp_mutex_lock (&dev->openacc.async.lock);\n+  for (goacc_aq_list l = dev->openacc.async.active; l; l = l->next)\n+    ret &= dev->openacc.async.synchronize_func (l->aq);\n+  gomp_mutex_unlock (&dev->openacc.async.lock);\n \n-  thr->dev->openacc.async_wait_all_func ();\n+  if (!ret)\n+    gomp_fatal (\"wait all failed\");\n }\n \n /* acc_async_wait_all is an OpenACC 1.0 compatibility name for acc_wait_all.  */\n@@ -117,13 +253,73 @@ acc_async_wait_all (void)\n void\n acc_wait_all_async (int async)\n {\n-  if (!async_valid_p (async))\n-    gomp_fatal (\"invalid async argument: %d\", async);\n+  struct goacc_thread *thr = get_goacc_thread ();\n \n-  struct goacc_thread *thr = goacc_thread ();\n+  goacc_aq waiting_queue = lookup_goacc_asyncqueue (thr, true, async);\n \n-  if (!thr || !thr->dev)\n-    gomp_fatal (\"no device active\");\n+  bool ret = true;\n+  gomp_mutex_lock (&thr->dev->openacc.async.lock);\n+  for (goacc_aq_list l = thr->dev->openacc.async.active; l; l = l->next)\n+    {\n+      if (waiting_queue)\n+\tret &= thr->dev->openacc.async.serialize_func (l->aq, waiting_queue);\n+      else\n+\t/* TODO: Local thread synchronization.\n+\t   Necessary for the \"async2 == acc_async_sync\" case, or can just skip?  */\n+\tret &= thr->dev->openacc.async.synchronize_func (l->aq);\n+    }\n+  gomp_mutex_unlock (&thr->dev->openacc.async.lock);\n+\n+  if (!ret)\n+    gomp_fatal (\"wait all async(%d) failed\", async);\n+}\n+\n+attribute_hidden void\n+goacc_async_free (struct gomp_device_descr *devicep,\n+\t\t  struct goacc_asyncqueue *aq, void *ptr)\n+{\n+  if (!aq)\n+    free (ptr);\n+  else\n+    devicep->openacc.async.queue_callback_func (aq, free, ptr);\n+}\n+\n+/* This function initializes the asyncqueues for the device specified by\n+   DEVICEP.  TODO DEVICEP must be locked on entry, and remains locked on\n+   return.  */\n+\n+attribute_hidden void\n+goacc_init_asyncqueues (struct gomp_device_descr *devicep)\n+{\n+  devicep->openacc.async.nasyncqueue = 0;\n+  devicep->openacc.async.asyncqueue = NULL;\n+  devicep->openacc.async.active = NULL;\n+  gomp_mutex_init (&devicep->openacc.async.lock);\n+}\n \n-  thr->dev->openacc.async_wait_all_async_func (async);\n+/* This function finalizes the asyncqueues for the device specified by DEVICEP.\n+   TODO DEVICEP must be locked on entry, and remains locked on return.  */\n+\n+attribute_hidden bool\n+goacc_fini_asyncqueues (struct gomp_device_descr *devicep)\n+{\n+  bool ret = true;\n+  gomp_mutex_lock (&devicep->openacc.async.lock);\n+  if (devicep->openacc.async.nasyncqueue > 0)\n+    {\n+      goacc_aq_list next;\n+      for (goacc_aq_list l = devicep->openacc.async.active; l; l = next)\n+\t{\n+\t  ret &= devicep->openacc.async.destruct_func (l->aq);\n+\t  next = l->next;\n+\t  free (l);\n+\t}\n+      free (devicep->openacc.async.asyncqueue);\n+      devicep->openacc.async.nasyncqueue = 0;\n+      devicep->openacc.async.asyncqueue = NULL;\n+      devicep->openacc.async.active = NULL;\n+    }\n+  gomp_mutex_unlock (&devicep->openacc.async.lock);\n+  gomp_mutex_destroy (&devicep->openacc.async.lock);\n+  return ret;\n }"}, {"sha": "1a6946c5ddabc208a9fd7be78cc98632c77a634a", "filename": "libgomp/oacc-cuda.c", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Foacc-cuda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Foacc-cuda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-cuda.c?ref=1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "patch": "@@ -30,6 +30,7 @@\n #include \"config.h\"\n #include \"libgomp.h\"\n #include \"oacc-int.h\"\n+#include <assert.h>\n \n void *\n acc_get_current_cuda_device (void)\n@@ -62,7 +63,11 @@ acc_get_cuda_stream (int async)\n     return NULL;\n \n   if (thr && thr->dev && thr->dev->openacc.cuda.get_stream_func)\n-    return thr->dev->openacc.cuda.get_stream_func (async);\n+    {\n+      goacc_aq aq = lookup_goacc_asyncqueue (thr, false, async);\n+      if (aq)\n+\treturn thr->dev->openacc.cuda.get_stream_func (aq);\n+    }\n  \n   return NULL;\n }\n@@ -79,8 +84,23 @@ acc_set_cuda_stream (int async, void *stream)\n \n   thr = goacc_thread ();\n \n+  int ret = -1;\n   if (thr && thr->dev && thr->dev->openacc.cuda.set_stream_func)\n-    return thr->dev->openacc.cuda.set_stream_func (async, stream);\n-\n-  return -1;\n+    {\n+      goacc_aq aq = get_goacc_asyncqueue (async);\n+      /* Due to not using an asyncqueue for \"acc_async_sync\", this cannot be\n+\t used to change the CUDA stream associated with \"acc_async_sync\".  */\n+      if (!aq)\n+\t{\n+\t  assert (async == acc_async_sync);\n+\t  gomp_debug (0, \"Refusing request to set CUDA stream associated\"\n+\t\t      \" with \\\"acc_async_sync\\\"\\n\");\n+\t  return 0;\n+\t}\n+      gomp_mutex_lock (&thr->dev->openacc.async.lock);\n+      ret = thr->dev->openacc.cuda.set_stream_func (aq, stream);\n+      gomp_mutex_unlock (&thr->dev->openacc.async.lock);\n+    }\n+\n+  return ret;\n }"}, {"sha": "00484b9f6ed9c58b704fcf0f51ad4e41ae5f80cb", "filename": "libgomp/oacc-host.c", "status": "modified", "additions": 64, "deletions": 28, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Foacc-host.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Foacc-host.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-host.c?ref=1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "patch": "@@ -140,55 +140,89 @@ host_openacc_exec (void (*fn) (void *),\n \t\t   size_t mapnum __attribute__ ((unused)),\n \t\t   void **hostaddrs,\n \t\t   void **devaddrs __attribute__ ((unused)),\n-\t\t   int async __attribute__ ((unused)),\n-\t\t   unsigned *dims __attribute ((unused)),\n+\t\t   unsigned *dims __attribute__ ((unused)),\n \t\t   void *targ_mem_desc __attribute__ ((unused)))\n {\n   fn (hostaddrs);\n }\n \n static void\n-host_openacc_register_async_cleanup (void *targ_mem_desc __attribute__ ((unused)),\n-\t\t\t\t     int async __attribute__ ((unused)))\n+host_openacc_async_exec (void (*fn) (void *),\n+\t\t\t size_t mapnum __attribute__ ((unused)),\n+\t\t\t void **hostaddrs,\n+\t\t\t void **devaddrs __attribute__ ((unused)),\n+\t\t\t unsigned *dims __attribute__ ((unused)),\n+\t\t\t void *targ_mem_desc __attribute__ ((unused)),\n+\t\t\t struct goacc_asyncqueue *aq __attribute__ ((unused)))\n {\n+  fn (hostaddrs);\n }\n \n static int\n-host_openacc_async_test (int async __attribute__ ((unused)))\n+host_openacc_async_test (struct goacc_asyncqueue *aq __attribute__ ((unused)))\n {\n   return 1;\n }\n \n-static int\n-host_openacc_async_test_all (void)\n+static bool\n+host_openacc_async_synchronize (struct goacc_asyncqueue *aq\n+\t\t\t\t__attribute__ ((unused)))\n {\n-  return 1;\n+  return true;\n }\n \n-static void\n-host_openacc_async_wait (int async __attribute__ ((unused)))\n+static bool\n+host_openacc_async_serialize (struct goacc_asyncqueue *aq1\n+\t\t\t      __attribute__ ((unused)),\n+\t\t\t      struct goacc_asyncqueue *aq2\n+\t\t\t      __attribute__ ((unused)))\n {\n+  return true;\n }\n \n-static void\n-host_openacc_async_wait_async (int async1 __attribute__ ((unused)),\n-\t\t\t       int async2 __attribute__ ((unused)))\n+static bool\n+host_openacc_async_host2dev (int ord __attribute__ ((unused)),\n+\t\t\t     void *dst __attribute__ ((unused)),\n+\t\t\t     const void *src __attribute__ ((unused)),\n+\t\t\t     size_t n __attribute__ ((unused)),\n+\t\t\t     struct goacc_asyncqueue *aq\n+\t\t\t     __attribute__ ((unused)))\n {\n+  return true;\n }\n \n-static void\n-host_openacc_async_wait_all (void)\n+static bool\n+host_openacc_async_dev2host (int ord __attribute__ ((unused)),\n+\t\t\t     void *dst __attribute__ ((unused)),\n+\t\t\t     const void *src __attribute__ ((unused)),\n+\t\t\t     size_t n __attribute__ ((unused)),\n+\t\t\t     struct goacc_asyncqueue *aq\n+\t\t\t     __attribute__ ((unused)))\n {\n+  return true;\n }\n \n static void\n-host_openacc_async_wait_all_async (int async __attribute__ ((unused)))\n+host_openacc_async_queue_callback (struct goacc_asyncqueue *aq\n+\t\t\t\t   __attribute__ ((unused)),\n+\t\t\t\t   void (*callback_fn)(void *)\n+\t\t\t\t   __attribute__ ((unused)),\n+\t\t\t\t   void *userptr __attribute__ ((unused)))\n {\n }\n \n-static void\n-host_openacc_async_set_async (int async __attribute__ ((unused)))\n+static struct goacc_asyncqueue *\n+host_openacc_async_construct (void)\n {\n+  /* Non-NULL 0xffff... value as opaque dummy.  */\n+  return (struct goacc_asyncqueue *) -1;\n+}\n+\n+static bool\n+host_openacc_async_destruct (struct goacc_asyncqueue *aq\n+\t\t\t     __attribute__ ((unused)))\n+{\n+  return true;\n }\n \n static void *\n@@ -235,19 +269,21 @@ static struct gomp_device_descr host_dispatch =\n \n       .exec_func = host_openacc_exec,\n \n-      .register_async_cleanup_func = host_openacc_register_async_cleanup,\n-\n-      .async_test_func = host_openacc_async_test,\n-      .async_test_all_func = host_openacc_async_test_all,\n-      .async_wait_func = host_openacc_async_wait,\n-      .async_wait_async_func = host_openacc_async_wait_async,\n-      .async_wait_all_func = host_openacc_async_wait_all,\n-      .async_wait_all_async_func = host_openacc_async_wait_all_async,\n-      .async_set_async_func = host_openacc_async_set_async,\n-\n       .create_thread_data_func = host_openacc_create_thread_data,\n       .destroy_thread_data_func = host_openacc_destroy_thread_data,\n \n+      .async = {\n+\t.construct_func = host_openacc_async_construct,\n+\t.destruct_func = host_openacc_async_destruct,\n+\t.test_func = host_openacc_async_test,\n+\t.synchronize_func = host_openacc_async_synchronize,\n+\t.serialize_func = host_openacc_async_serialize,\n+\t.queue_callback_func = host_openacc_async_queue_callback,\n+\t.exec_func = host_openacc_async_exec,\n+\t.dev2host_func = host_openacc_async_dev2host,\n+\t.host2dev_func = host_openacc_async_host2dev,\n+      },\n+\n       .cuda = {\n \t.get_current_device_func = NULL,\n \t.get_current_context_func = NULL,"}, {"sha": "28471e40ba00631b0d155b073b19d101541f3c83", "filename": "libgomp/oacc-init.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Foacc-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Foacc-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-init.c?ref=1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "patch": "@@ -309,7 +309,7 @@ acc_shutdown_1 (acc_device_t d)\n       if (acc_dev->state == GOMP_DEVICE_INITIALIZED)\n         {\n \t  devices_active = true;\n-\t  ret &= acc_dev->fini_device_func (acc_dev->target_id);\n+\t  ret &= gomp_fini_device (acc_dev);\n \t  acc_dev->state = GOMP_DEVICE_UNINITIALIZED;\n \t}\n       gomp_mutex_unlock (&acc_dev->lock);\n@@ -426,8 +426,6 @@ goacc_attach_host_thread_to_device (int ord)\n   \n   thr->target_tls\n     = acc_dev->openacc.create_thread_data_func (ord);\n-  \n-  acc_dev->openacc.async_set_async_func (acc_async_sync);\n }\n \n /* OpenACC 2.0a (3.2.12, 3.2.13) doesn't specify whether the serialization of"}, {"sha": "e4b6ea6b7db47e33a014b6dc077e2e7e7e4224f5", "filename": "libgomp/oacc-int.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Foacc-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Foacc-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-int.h?ref=1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "patch": "@@ -99,6 +99,13 @@ void goacc_restore_bind (void);\n void goacc_lazy_initialize (void);\n void goacc_host_init (void);\n \n+void goacc_init_asyncqueues (struct gomp_device_descr *);\n+bool goacc_fini_asyncqueues (struct gomp_device_descr *);\n+void goacc_async_free (struct gomp_device_descr *, struct goacc_asyncqueue *,\n+\t\t       void *);\n+struct goacc_asyncqueue *get_goacc_asyncqueue (int);\n+struct goacc_asyncqueue *lookup_goacc_asyncqueue (struct goacc_thread *, bool,\n+\t\t\t\t\t\t  int);\n static inline bool\n async_valid_stream_id_p (int async)\n {"}, {"sha": "03df0d4fbf63c2cc18385cb818dd2cb044236bff", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 21, "deletions": 36, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "patch": "@@ -172,18 +172,11 @@ memcpy_tofrom_device (bool from, void *d, void *h, size_t s, int async,\n       return;\n     }\n \n-  if (async > acc_async_sync)\n-    thr->dev->openacc.async_set_async_func (async);\n-\n-  bool ret = (from\n-\t      ? thr->dev->dev2host_func (thr->dev->target_id, h, d, s)\n-\t      : thr->dev->host2dev_func (thr->dev->target_id, d, h, s));\n-\n-  if (async > acc_async_sync)\n-    thr->dev->openacc.async_set_async_func (acc_async_sync);\n-\n-  if (!ret)\n-    gomp_fatal (\"error in %s\", libfnname);\n+  goacc_aq aq = get_goacc_asyncqueue (async);\n+  if (from)\n+    gomp_copy_dev2host (thr->dev, aq, h, d, s);\n+  else\n+    gomp_copy_host2dev (thr->dev, aq, d, h, s, /* TODO: cbuf? */ NULL);\n }\n \n void\n@@ -509,17 +502,13 @@ present_create_copy (unsigned f, void *h, size_t s, int async)\n \n       gomp_mutex_unlock (&acc_dev->lock);\n \n-      if (async > acc_async_sync)\n-\tacc_dev->openacc.async_set_async_func (async);\n+      goacc_aq aq = get_goacc_asyncqueue (async);\n \n-      tgt = gomp_map_vars (acc_dev, mapnum, &hostaddrs, NULL, &s, &kinds, true,\n-\t\t\t   GOMP_MAP_VARS_OPENACC);\n+      tgt = gomp_map_vars_async (acc_dev, aq, mapnum, &hostaddrs, NULL, &s,\n+\t\t\t\t &kinds, true, GOMP_MAP_VARS_OPENACC);\n       /* Initialize dynamic refcount.  */\n       tgt->list[0].key->dynamic_refcount = 1;\n \n-      if (async > acc_async_sync)\n-\tacc_dev->openacc.async_set_async_func (acc_async_sync);\n-\n       gomp_mutex_lock (&acc_dev->lock);\n \n       d = tgt->to_free;\n@@ -676,13 +665,9 @@ delete_copyout (unsigned f, void *h, size_t s, int async, const char *libfnname)\n \n       if (f & FLAG_COPYOUT)\n \t{\n-\t  if (async > acc_async_sync)\n-\t    acc_dev->openacc.async_set_async_func (async);\n-\t  acc_dev->dev2host_func (acc_dev->target_id, h, d, s);\n-\t  if (async > acc_async_sync)\n-\t    acc_dev->openacc.async_set_async_func (acc_async_sync);\n+\t  goacc_aq aq = get_goacc_asyncqueue (async);\n+\t  gomp_copy_dev2host (acc_dev, aq, h, d, s);\n \t}\n-\n       gomp_remove_var (acc_dev, n);\n     }\n \n@@ -765,16 +750,12 @@ update_dev_host (int is_dev, void *h, size_t s, int async)\n   d = (void *) (n->tgt->tgt_start + n->tgt_offset\n \t\t+ (uintptr_t) h - n->host_start);\n \n-  if (async > acc_async_sync)\n-    acc_dev->openacc.async_set_async_func (async);\n+  goacc_aq aq = get_goacc_asyncqueue (async);\n \n   if (is_dev)\n-    acc_dev->host2dev_func (acc_dev->target_id, d, h, s);\n+    gomp_copy_host2dev (acc_dev, aq, d, h, s, /* TODO: cbuf? */ NULL);\n   else\n-    acc_dev->dev2host_func (acc_dev->target_id, h, d, s);\n-\n-  if (async > acc_async_sync)\n-    acc_dev->openacc.async_set_async_func (acc_async_sync);\n+    gomp_copy_dev2host (acc_dev, aq, h, d, s);\n \n   gomp_mutex_unlock (&acc_dev->lock);\n }\n@@ -805,7 +786,7 @@ acc_update_self_async (void *h, size_t s, int async)\n \n void\n gomp_acc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,\n-\t\t\t void *kinds)\n+\t\t\t void *kinds, int async)\n {\n   struct target_mem_desc *tgt;\n   struct goacc_thread *thr = goacc_thread ();\n@@ -835,8 +816,9 @@ gomp_acc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,\n     }\n \n   gomp_debug (0, \"  %s: prepare mappings\\n\", __FUNCTION__);\n-  tgt = gomp_map_vars (acc_dev, mapnum, hostaddrs,\n-\t\t       NULL, sizes, kinds, true, GOMP_MAP_VARS_OPENACC);\n+  goacc_aq aq = get_goacc_asyncqueue (async);\n+  tgt = gomp_map_vars_async (acc_dev, aq, mapnum, hostaddrs,\n+\t\t\t     NULL, sizes, kinds, true, GOMP_MAP_VARS_OPENACC);\n   gomp_debug (0, \"  %s: mappings prepared\\n\", __FUNCTION__);\n \n   /* Initialize dynamic refcount.  */\n@@ -930,7 +912,10 @@ gomp_acc_remove_pointer (void *h, size_t s, bool force_copyfrom, int async,\n       if (async < acc_async_noval)\n \tgomp_unmap_vars (t, true);\n       else\n-\tt->device_descr->openacc.register_async_cleanup_func (t, async);\n+\t{\n+\t  goacc_aq aq = get_goacc_asyncqueue (async);\n+\t  gomp_unmap_vars_async (t, true, aq);\n+\t}\n     }\n \n   gomp_mutex_unlock (&acc_dev->lock);"}, {"sha": "fa99a2ad1a90778146cfa9ef734247c33e9b70da", "filename": "libgomp/oacc-parallel.c", "status": "modified", "additions": 29, "deletions": 51, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Foacc-parallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Foacc-parallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-parallel.c?ref=1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "patch": "@@ -217,8 +217,6 @@ GOACC_parallel_keyed (int flags_m, void (*fn) (void *),\n     }\n   va_end (ap);\n   \n-  acc_dev->openacc.async_set_async_func (async);\n-\n   if (!(acc_dev->capabilities & GOMP_OFFLOAD_CAP_NATIVE_EXEC))\n     {\n       k.host_start = (uintptr_t) fn;\n@@ -235,44 +233,29 @@ GOACC_parallel_keyed (int flags_m, void (*fn) (void *),\n   else\n     tgt_fn = (void (*)) fn;\n \n-  tgt = gomp_map_vars (acc_dev, mapnum, hostaddrs, NULL, sizes, kinds, true,\n-\t\t       GOMP_MAP_VARS_OPENACC);\n+  goacc_aq aq = get_goacc_asyncqueue (async);\n \n+  tgt = gomp_map_vars_async (acc_dev, aq, mapnum, hostaddrs, NULL, sizes, kinds,\n+\t\t\t     true, GOMP_MAP_VARS_OPENACC);\n+  \n   devaddrs = gomp_alloca (sizeof (void *) * mapnum);\n   for (i = 0; i < mapnum; i++)\n     devaddrs[i] = (void *) (tgt->list[i].key->tgt->tgt_start\n \t\t\t    + tgt->list[i].key->tgt_offset\n \t\t\t    + tgt->list[i].offset);\n-\n-  acc_dev->openacc.exec_func (tgt_fn, mapnum, hostaddrs, devaddrs,\n-\t\t\t      async, dims, tgt);\n-\n-  /* If running synchronously, unmap immediately.  */\n-  bool copyfrom = true;\n-  if (async_synchronous_p (async))\n-    gomp_unmap_vars (tgt, true);\n+  if (aq == NULL)\n+    {\n+      acc_dev->openacc.exec_func (tgt_fn, mapnum, hostaddrs, devaddrs,\n+\t\t\t\t  dims, tgt);\n+      /* If running synchronously, unmap immediately.  */\n+      gomp_unmap_vars (tgt, true);\n+    }\n   else\n     {\n-      bool async_unmap = false;\n-      for (size_t i = 0; i < tgt->list_count; i++)\n-\t{\n-\t  splay_tree_key k = tgt->list[i].key;\n-\t  if (k && k->refcount == 1)\n-\t    {\n-\t      async_unmap = true;\n-\t      break;\n-\t    }\n-\t}\n-      if (async_unmap)\n-\ttgt->device_descr->openacc.register_async_cleanup_func (tgt, async);\n-      else\n-\t{\n-\t  copyfrom = false;\n-\t  gomp_unmap_vars (tgt, copyfrom);\n-\t}\n+      acc_dev->openacc.async.exec_func (tgt_fn, mapnum, hostaddrs, devaddrs,\n+\t\t\t\t\tdims, tgt, aq);\n+      gomp_unmap_vars_async (tgt, true, aq);\n     }\n-\n-  acc_dev->openacc.async_set_async_func (acc_async_sync);\n }\n \n /* Legacy entry point (GCC 5).  Only provide host fallback execution.  */\n@@ -383,8 +366,6 @@ GOACC_enter_exit_data (int flags_m, size_t mapnum,\n \tfinalize = true;\n     }\n \n-  acc_dev->openacc.async_set_async_func (async);\n-\n   /* Determine if this is an \"acc enter data\".  */\n   for (i = 0; i < mapnum; ++i)\n     {\n@@ -437,11 +418,11 @@ GOACC_enter_exit_data (int flags_m, size_t mapnum,\n \t\t{\n \t\tcase GOMP_MAP_ALLOC:\n \t\tcase GOMP_MAP_FORCE_ALLOC:\n-\t\t  acc_create (hostaddrs[i], sizes[i]);\n+\t\t  acc_create_async (hostaddrs[i], sizes[i], async);\n \t\t  break;\n \t\tcase GOMP_MAP_TO:\n \t\tcase GOMP_MAP_FORCE_TO:\n-\t\t  acc_copyin (hostaddrs[i], sizes[i]);\n+\t\t  acc_copyin_async (hostaddrs[i], sizes[i], async);\n \t\t  break;\n \t\tdefault:\n \t\t  gomp_fatal (\">>>> GOACC_enter_exit_data UNHANDLED kind 0x%.2x\",\n@@ -452,7 +433,7 @@ GOACC_enter_exit_data (int flags_m, size_t mapnum,\n \t  else\n \t    {\n \t      gomp_acc_insert_pointer (pointer, &hostaddrs[i],\n-\t\t\t\t       &sizes[i], &kinds[i]);\n+\t\t\t\t       &sizes[i], &kinds[i], async);\n \t      /* Increment 'i' by two because OpenACC requires fortran\n \t\t arrays to be contiguous, so each PSET is associated with\n \t\t one of MAP_FORCE_ALLOC/MAP_FORCE_PRESET/MAP_FORCE_TO, and\n@@ -477,17 +458,17 @@ GOACC_enter_exit_data (int flags_m, size_t mapnum,\n \t\tif (acc_is_present (hostaddrs[i], sizes[i]))\n \t\t  {\n \t\t    if (finalize)\n-\t\t      acc_delete_finalize (hostaddrs[i], sizes[i]);\n+\t\t      acc_delete_finalize_async (hostaddrs[i], sizes[i], async);\n \t\t    else\n-\t\t      acc_delete (hostaddrs[i], sizes[i]);\n+\t\t      acc_delete_async (hostaddrs[i], sizes[i], async);\n \t\t  }\n \t\tbreak;\n \t      case GOMP_MAP_FROM:\n \t      case GOMP_MAP_FORCE_FROM:\n \t\tif (finalize)\n-\t\t  acc_copyout_finalize (hostaddrs[i], sizes[i]);\n+\t\t  acc_copyout_finalize_async (hostaddrs[i], sizes[i], async);\n \t\telse\n-\t\t  acc_copyout (hostaddrs[i], sizes[i]);\n+\t\t  acc_copyout_async (hostaddrs[i], sizes[i], async);\n \t\tbreak;\n \t      default:\n \t\tgomp_fatal (\">>>> GOACC_enter_exit_data UNHANDLED kind 0x%.2x\",\n@@ -505,8 +486,6 @@ GOACC_enter_exit_data (int flags_m, size_t mapnum,\n \t    i += pointer - 1;\n \t  }\n       }\n-\n-  acc_dev->openacc.async_set_async_func (acc_async_sync);\n }\n \n static void\n@@ -532,9 +511,10 @@ goacc_wait (int async, int num_waits, va_list *ap)\n       if (async == acc_async_sync)\n \tacc_wait (qid);\n       else if (qid == async)\n-\t;/* If we're waiting on the same asynchronous queue as we're\n-\t    launching on, the queue itself will order work as\n-\t    required, so there's no need to wait explicitly.  */\n+\t/* If we're waiting on the same asynchronous queue as we're\n+\t   launching on, the queue itself will order work as\n+\t   required, so there's no need to wait explicitly.  */\n+\t;\n       else\n \tacc_wait_async (qid, async);\n     }\n@@ -567,8 +547,6 @@ GOACC_update (int flags_m, size_t mapnum,\n       va_end (ap);\n     }\n \n-  acc_dev->openacc.async_set_async_func (async);\n-\n   bool update_device = false;\n   for (i = 0; i < mapnum; ++i)\n     {\n@@ -591,6 +569,8 @@ GOACC_update (int flags_m, size_t mapnum,\n \t\t the value of the allocated device memory in the\n \t\t previous pointer.  */\n \t      *(uintptr_t *) hostaddrs[i] = (uintptr_t)dptr;\n+\t      /* TODO: verify that we really cannot use acc_update_device_async\n+\t\t here.  */\n \t      acc_update_device (hostaddrs[i], sizeof (uintptr_t));\n \n \t      /* Restore the host pointer.  */\n@@ -608,7 +588,7 @@ GOACC_update (int flags_m, size_t mapnum,\n \t  /* Fallthru  */\n \tcase GOMP_MAP_FORCE_TO:\n \t  update_device = true;\n-\t  acc_update_device (hostaddrs[i], sizes[i]);\n+\t  acc_update_device_async (hostaddrs[i], sizes[i], async);\n \t  break;\n \n \tcase GOMP_MAP_FROM:\n@@ -620,16 +600,14 @@ GOACC_update (int flags_m, size_t mapnum,\n \t  /* Fallthru  */\n \tcase GOMP_MAP_FORCE_FROM:\n \t  update_device = false;\n-\t  acc_update_self (hostaddrs[i], sizes[i]);\n+\t  acc_update_self_async (hostaddrs[i], sizes[i], async);\n \t  break;\n \n \tdefault:\n \t  gomp_fatal (\">>>> GOACC_update UNHANDLED kind 0x%.2x\", kind);\n \t  break;\n \t}\n     }\n-\n-  acc_dev->openacc.async_set_async_func (acc_async_sync);\n }\n \n void"}, {"sha": "5480c1db56eea49b0681047c4e90c296d44f6305", "filename": "libgomp/oacc-plugin.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Foacc-plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Foacc-plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-plugin.c?ref=1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "patch": "@@ -30,15 +30,12 @@\n #include \"oacc-plugin.h\"\n #include \"oacc-int.h\"\n \n+/* This plugin function is now obsolete.  */\n void\n-GOMP_PLUGIN_async_unmap_vars (void *ptr, int async)\n+GOMP_PLUGIN_async_unmap_vars (void *ptr __attribute__((unused)),\n+\t\t\t      int async __attribute__((unused)))\n {\n-  struct target_mem_desc *tgt = ptr;\n-  struct gomp_device_descr *devicep = tgt->device_descr;\n-\n-  devicep->openacc.async_set_async_func (async);\n-  gomp_unmap_vars (tgt, true);\n-  devicep->openacc.async_set_async_func (acc_async_sync);\n+  gomp_fatal (\"invalid plugin function\");\n }\n \n /* Return the target-specific part of the TLS data for the current thread.  */"}, {"sha": "a16badcfa9de0329c3d8bb757ff5dc516341f1a4", "filename": "libgomp/plugin/cuda-lib.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Fplugin%2Fcuda-lib.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Fplugin%2Fcuda-lib.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fcuda-lib.def?ref=1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "patch": "@@ -42,6 +42,7 @@ CUDA_ONE_CALL (cuModuleLoad)\n CUDA_ONE_CALL (cuModuleLoadData)\n CUDA_ONE_CALL (cuModuleUnload)\n CUDA_ONE_CALL_MAYBE_NULL (cuOccupancyMaxPotentialBlockSize)\n+CUDA_ONE_CALL (cuStreamAddCallback)\n CUDA_ONE_CALL (cuStreamCreate)\n CUDA_ONE_CALL (cuStreamDestroy)\n CUDA_ONE_CALL (cuStreamQuery)"}, {"sha": "e65f9725349e9c83b3925b25f45f4435ebc4208e", "filename": "libgomp/plugin/cuda/cuda.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Fplugin%2Fcuda%2Fcuda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Fplugin%2Fcuda%2Fcuda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fcuda%2Fcuda.h?ref=1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "patch": "@@ -54,7 +54,11 @@ typedef enum {\n   CUDA_ERROR_INVALID_CONTEXT = 201,\n   CUDA_ERROR_NOT_FOUND = 500,\n   CUDA_ERROR_NOT_READY = 600,\n-  CUDA_ERROR_LAUNCH_FAILED = 719\n+  CUDA_ERROR_LAUNCH_FAILED = 719,\n+  CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE = 720,\n+  CUDA_ERROR_NOT_PERMITTED = 800,\n+  CUDA_ERROR_NOT_SUPPORTED = 801,\n+  CUDA_ERROR_UNKNOWN = 999\n } CUresult;\n \n typedef enum {\n@@ -173,6 +177,8 @@ CUresult cuModuleLoadData (CUmodule *, const void *);\n CUresult cuModuleUnload (CUmodule);\n CUresult cuOccupancyMaxPotentialBlockSize(int *, int *, CUfunction,\n \t\t\t\t\t  CUoccupancyB2DSize, size_t, int);\n+typedef void (*CUstreamCallback)(CUstream, CUresult, void *);\n+CUresult cuStreamAddCallback(CUstream, CUstreamCallback, void *, unsigned int);\n CUresult cuStreamCreate (CUstream *, unsigned);\n #define cuStreamDestroy cuStreamDestroy_v2\n CUresult cuStreamDestroy (CUstream);"}, {"sha": "8f71e69acb602fb8a3f023d66db3bf170ae5d17c", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 316, "deletions": 1029, "changes": 1345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "patch": "@@ -192,175 +192,30 @@ cuda_error (CUresult r)\n static unsigned int instantiated_devices = 0;\n static pthread_mutex_t ptx_dev_lock = PTHREAD_MUTEX_INITIALIZER;\n \n-struct cuda_map\n+/* NVPTX/CUDA specific definition of asynchronous queues.  */\n+struct goacc_asyncqueue\n {\n-  CUdeviceptr d;\n-  size_t size;\n-  bool active;\n-  struct cuda_map *next;\n+  CUstream cuda_stream;\n };\n \n-struct ptx_stream\n+struct nvptx_callback\n {\n-  CUstream stream;\n-  pthread_t host_thread;\n-  bool multithreaded;\n-  struct cuda_map *map;\n-  struct ptx_stream *next;\n+  void (*fn) (void *);\n+  void *ptr;\n+  struct goacc_asyncqueue *aq;\n+  struct nvptx_callback *next;\n };\n \n /* Thread-specific data for PTX.  */\n \n struct nvptx_thread\n {\n-  struct ptx_stream *current_stream;\n+  /* We currently have this embedded inside the plugin because libgomp manages\n+     devices through integer target_ids.  This might be better if using an\n+     opaque target-specific pointer directly from gomp_device_descr.  */\n   struct ptx_device *ptx_dev;\n };\n \n-static struct cuda_map *\n-cuda_map_create (size_t size)\n-{\n-  struct cuda_map *map = GOMP_PLUGIN_malloc (sizeof (struct cuda_map));\n-\n-  assert (map);\n-\n-  map->next = NULL;\n-  map->size = size;\n-  map->active = false;\n-\n-  CUDA_CALL_ERET (NULL, cuMemAlloc, &map->d, size);\n-  assert (map->d);\n-\n-  return map;\n-}\n-\n-static void\n-cuda_map_destroy (struct cuda_map *map)\n-{\n-  if (map->active)\n-    /* Possible reasons for the map to be still active:\n-       - the associated async kernel might still be running.\n-       - the associated async kernel might have finished, but the\n-         corresponding event that should trigger the pop_map has not been\n-\t processed by event_gc.\n-       - the associated sync kernel might have aborted\n-\n-       The async cases could happen if the user specified an async region\n-       without adding a corresponding wait that is guaranteed to be executed\n-       (before returning from main, or in an atexit handler).\n-       We do not want to deallocate a device pointer that is still being\n-       used, so skip it.\n-\n-       In the sync case, the device pointer is no longer used, but deallocating\n-       it using cuMemFree will not succeed, so skip it.\n-\n-       TODO: Handle this in a more constructive way, by f.i. waiting for streams\n-       to finish before de-allocating them (PR88981), or by ensuring the CUDA\n-       lib atexit handler is called before rather than after the libgomp plugin\n-       atexit handler (PR83795).  */\n-    ;\n-  else\n-    CUDA_CALL_NOCHECK (cuMemFree, map->d);\n-\n-  free (map);\n-}\n-\n-/* The following map_* routines manage the CUDA device memory that\n-   contains the data mapping arguments for cuLaunchKernel.  Each\n-   asynchronous PTX stream may have multiple pending kernel\n-   invocations, which are launched in a FIFO order.  As such, the map\n-   routines maintains a queue of cuLaunchKernel arguments.\n-\n-   Calls to map_push and map_pop must be guarded by ptx_event_lock.\n-   Likewise, calls to map_init and map_fini are guarded by\n-   ptx_dev_lock inside GOMP_OFFLOAD_init_device and\n-   GOMP_OFFLOAD_fini_device, respectively.  */\n-\n-static bool\n-map_init (struct ptx_stream *s)\n-{\n-  int size = getpagesize ();\n-\n-  assert (s);\n-\n-  s->map = cuda_map_create (size);\n-\n-  return true;\n-}\n-\n-static bool\n-map_fini (struct ptx_stream *s)\n-{\n-  assert (s->map->next == NULL);\n-\n-  cuda_map_destroy (s->map);\n-\n-  return true;\n-}\n-\n-static void\n-map_pop (struct ptx_stream *s)\n-{\n-  struct cuda_map *next;\n-\n-  assert (s != NULL);\n-\n-  if (s->map->next == NULL)\n-    {\n-      s->map->active = false;\n-      return;\n-    }\n-\n-  next = s->map->next;\n-  cuda_map_destroy (s->map);\n-  s->map = next;\n-}\n-\n-static CUdeviceptr\n-map_push (struct ptx_stream *s, size_t size)\n-{\n-  struct cuda_map *map = NULL;\n-  struct cuda_map **t;\n-\n-  assert (s);\n-  assert (s->map);\n-\n-  /* Select an element to push.  */\n-  if (s->map->active)\n-    map = cuda_map_create (size);\n-  else\n-    {\n-      /* Pop the inactive front element.  */\n-      struct cuda_map *pop = s->map;\n-      s->map = pop->next;\n-      pop->next = NULL;\n-\n-      if (pop->size < size)\n-\t{\n-\t  cuda_map_destroy (pop);\n-\n-\t  map = cuda_map_create (size);\n-\t}\n-      else\n-\tmap = pop;\n-    }\n-\n-  /* Check that the element is as expected.  */\n-  assert (map->next == NULL);\n-  assert (!map->active);\n-\n-  /* Mark the element active.  */\n-  map->active = true;\n-\n-  /* Push the element to the back of the list.  */\n-  for (t = &s->map; (*t) != NULL; t = &(*t)->next)\n-    ;\n-  assert (t != NULL && *t == NULL);\n-  *t = map;\n-\n-  return map->d;\n-}\n-\n /* Target data function launch information.  */\n \n struct targ_fn_launch\n@@ -412,22 +267,18 @@ struct ptx_image_data\n   struct ptx_image_data *next;\n };\n \n+struct ptx_free_block\n+{\n+  void *ptr;\n+  struct ptx_free_block *next;\n+};\n+\n struct ptx_device\n {\n   CUcontext ctx;\n   bool ctx_shared;\n   CUdevice dev;\n-  struct ptx_stream *null_stream;\n-  /* All non-null streams associated with this device (actually context),\n-     either created implicitly or passed in from the user (via\n-     acc_set_cuda_stream).  */\n-  struct ptx_stream *active_streams;\n-  struct {\n-    struct ptx_stream **arr;\n-    int size;\n-  } async_streams;\n-  /* A lock for use when manipulating the above stream list and array.  */\n-  pthread_mutex_t stream_lock;\n+\n   int ord;\n   bool overlap;\n   bool map;\n@@ -445,32 +296,13 @@ struct ptx_device\n \n   struct ptx_image_data *images;  /* Images loaded on device.  */\n   pthread_mutex_t image_lock;     /* Lock for above list.  */\n-  \n-  struct ptx_device *next;\n-};\n \n-enum ptx_event_type\n-{\n-  PTX_EVT_MEM,\n-  PTX_EVT_KNL,\n-  PTX_EVT_SYNC,\n-  PTX_EVT_ASYNC_CLEANUP\n-};\n-\n-struct ptx_event\n-{\n-  CUevent *evt;\n-  int type;\n-  void *addr;\n-  int ord;\n-  int val;\n+  struct ptx_free_block *free_blocks;\n+  pthread_mutex_t free_blocks_lock;\n \n-  struct ptx_event *next;\n+  struct ptx_device *next;\n };\n \n-static pthread_mutex_t ptx_event_lock;\n-static struct ptx_event *ptx_events;\n-\n static struct ptx_device **ptx_devices;\n \n static inline struct nvptx_thread *\n@@ -479,193 +311,6 @@ nvptx_thread (void)\n   return (struct nvptx_thread *) GOMP_PLUGIN_acc_thread ();\n }\n \n-static bool\n-init_streams_for_device (struct ptx_device *ptx_dev, int concurrency)\n-{\n-  int i;\n-  struct ptx_stream *null_stream\n-    = GOMP_PLUGIN_malloc (sizeof (struct ptx_stream));\n-\n-  null_stream->stream = NULL;\n-  null_stream->host_thread = pthread_self ();\n-  null_stream->multithreaded = true;\n-  if (!map_init (null_stream))\n-    return false;\n-\n-  ptx_dev->null_stream = null_stream;\n-  ptx_dev->active_streams = NULL;\n-  pthread_mutex_init (&ptx_dev->stream_lock, NULL);\n-\n-  if (concurrency < 1)\n-    concurrency = 1;\n-\n-  /* This is just a guess -- make space for as many async streams as the\n-     current device is capable of concurrently executing.  This can grow\n-     later as necessary.  No streams are created yet.  */\n-  ptx_dev->async_streams.arr\n-    = GOMP_PLUGIN_malloc (concurrency * sizeof (struct ptx_stream *));\n-  ptx_dev->async_streams.size = concurrency;\n-\n-  for (i = 0; i < concurrency; i++)\n-    ptx_dev->async_streams.arr[i] = NULL;\n-\n-  return true;\n-}\n-\n-static bool\n-fini_streams_for_device (struct ptx_device *ptx_dev)\n-{\n-  free (ptx_dev->async_streams.arr);\n-\n-  bool ret = true;\n-  while (ptx_dev->active_streams != NULL)\n-    {\n-      struct ptx_stream *s = ptx_dev->active_streams;\n-      ptx_dev->active_streams = ptx_dev->active_streams->next;\n-\n-      ret &= map_fini (s);\n-\n-      CUresult r = CUDA_CALL_NOCHECK (cuStreamDestroy, s->stream);\n-      if (r != CUDA_SUCCESS)\n-\t{\n-\t  GOMP_PLUGIN_error (\"cuStreamDestroy error: %s\", cuda_error (r));\n-\t  ret = false;\n-\t}\n-      free (s);\n-    }\n-\n-  ret &= map_fini (ptx_dev->null_stream);\n-  free (ptx_dev->null_stream);\n-  return ret;\n-}\n-\n-/* Select a stream for (OpenACC-semantics) ASYNC argument for the current\n-   thread THREAD (and also current device/context).  If CREATE is true, create\n-   the stream if it does not exist (or use EXISTING if it is non-NULL), and\n-   associate the stream with the same thread argument.  Returns stream to use\n-   as result.  */\n-\n-static struct ptx_stream *\n-select_stream_for_async (int async, pthread_t thread, bool create,\n-\t\t\t CUstream existing)\n-{\n-  struct nvptx_thread *nvthd = nvptx_thread ();\n-  /* Local copy of TLS variable.  */\n-  struct ptx_device *ptx_dev = nvthd->ptx_dev;\n-  struct ptx_stream *stream = NULL;\n-  int orig_async = async;\n-\n-  /* The special value acc_async_noval (-1) maps (for now) to an\n-     implicitly-created stream, which is then handled the same as any other\n-     numbered async stream.  Other options are available, e.g. using the null\n-     stream for anonymous async operations, or choosing an idle stream from an\n-     active set.  But, stick with this for now.  */\n-  if (async > acc_async_sync)\n-    async++;\n-\n-  if (create)\n-    pthread_mutex_lock (&ptx_dev->stream_lock);\n-\n-  /* NOTE: AFAICT there's no particular need for acc_async_sync to map to the\n-     null stream, and in fact better performance may be obtainable if it doesn't\n-     (because the null stream enforces overly-strict synchronisation with\n-     respect to other streams for legacy reasons, and that's probably not\n-     needed with OpenACC).  Maybe investigate later.  */\n-  if (async == acc_async_sync)\n-    stream = ptx_dev->null_stream;\n-  else if (async >= 0 && async < ptx_dev->async_streams.size\n-\t   && ptx_dev->async_streams.arr[async] && !(create && existing))\n-    stream = ptx_dev->async_streams.arr[async];\n-  else if (async >= 0 && create)\n-    {\n-      if (async >= ptx_dev->async_streams.size)\n-\t{\n-\t  int i, newsize = ptx_dev->async_streams.size * 2;\n-\n-\t  if (async >= newsize)\n-\t    newsize = async + 1;\n-\n-\t  ptx_dev->async_streams.arr\n-\t    = GOMP_PLUGIN_realloc (ptx_dev->async_streams.arr,\n-\t\t\t\t   newsize * sizeof (struct ptx_stream *));\n-\n-\t  for (i = ptx_dev->async_streams.size; i < newsize; i++)\n-\t    ptx_dev->async_streams.arr[i] = NULL;\n-\n-\t  ptx_dev->async_streams.size = newsize;\n-\t}\n-\n-      /* Create a new stream on-demand if there isn't one already, or if we're\n-\t setting a particular async value to an existing (externally-provided)\n-\t stream.  */\n-      if (!ptx_dev->async_streams.arr[async] || existing)\n-        {\n-\t  CUresult r;\n-\t  struct ptx_stream *s\n-\t    = GOMP_PLUGIN_malloc (sizeof (struct ptx_stream));\n-\n-\t  if (existing)\n-\t    s->stream = existing;\n-\t  else\n-\t    {\n-\t      r = CUDA_CALL_NOCHECK (cuStreamCreate, &s->stream,\n-\t\t\t\t     CU_STREAM_DEFAULT);\n-\t      if (r != CUDA_SUCCESS)\n-\t\t{\n-\t\t  pthread_mutex_unlock (&ptx_dev->stream_lock);\n-\t\t  GOMP_PLUGIN_fatal (\"cuStreamCreate error: %s\",\n-\t\t\t\t     cuda_error (r));\n-\t\t}\n-\t    }\n-\n-\t  /* If CREATE is true, we're going to be queueing some work on this\n-\t     stream.  Associate it with the current host thread.  */\n-\t  s->host_thread = thread;\n-\t  s->multithreaded = false;\n-\n-\t  if (!map_init (s))\n-\t    {\n-\t      pthread_mutex_unlock (&ptx_dev->stream_lock);\n-\t      GOMP_PLUGIN_fatal (\"map_init fail\");\n-\t    }\n-\n-\t  s->next = ptx_dev->active_streams;\n-\t  ptx_dev->active_streams = s;\n-\t  ptx_dev->async_streams.arr[async] = s;\n-\t}\n-\n-      stream = ptx_dev->async_streams.arr[async];\n-    }\n-  else if (async < 0)\n-    {\n-      if (create)\n-\tpthread_mutex_unlock (&ptx_dev->stream_lock);\n-      GOMP_PLUGIN_fatal (\"bad async %d\", async);\n-    }\n-\n-  if (create)\n-    {\n-      assert (stream != NULL);\n-\n-      /* If we're trying to use the same stream from different threads\n-\t simultaneously, set stream->multithreaded to true.  This affects the\n-\t behaviour of acc_async_test_all and acc_wait_all, which are supposed to\n-\t only wait for asynchronous launches from the same host thread they are\n-\t invoked on.  If multiple threads use the same async value, we make note\n-\t of that here and fall back to testing/waiting for all threads in those\n-\t functions.  */\n-      if (thread != stream->host_thread)\n-        stream->multithreaded = true;\n-\n-      pthread_mutex_unlock (&ptx_dev->stream_lock);\n-    }\n-  else if (stream && !stream->multithreaded\n-\t   && !pthread_equal (stream->host_thread, thread))\n-    GOMP_PLUGIN_fatal (\"async %d used on wrong thread\", orig_async);\n-\n-  return stream;\n-}\n-\n /* Initialize the device.  Return TRUE on success, else FALSE.  PTX_DEV_LOCK\n    should be locked on entry and remains locked on exit.  */\n \n@@ -677,9 +322,6 @@ nvptx_init (void)\n   if (instantiated_devices != 0)\n     return true;\n \n-  ptx_events = NULL;\n-  pthread_mutex_init (&ptx_event_lock, NULL);\n-\n   if (!init_cuda_lib ())\n     return false;\n \n@@ -703,6 +345,11 @@ nvptx_attach_host_thread_to_device (int n)\n   CUcontext thd_ctx;\n \n   r = CUDA_CALL_NOCHECK (cuCtxGetDevice, &dev);\n+  if (r == CUDA_ERROR_NOT_PERMITTED)\n+    {\n+      /* Assume we're in a CUDA callback, just return true.  */\n+      return true;\n+    }\n   if (r != CUDA_SUCCESS && r != CUDA_ERROR_INVALID_CONTEXT)\n     {\n       GOMP_PLUGIN_error (\"cuCtxGetDevice error: %s\", cuda_error (r));\n@@ -847,8 +494,8 @@ nvptx_open_device (int n)\n   ptx_dev->images = NULL;\n   pthread_mutex_init (&ptx_dev->image_lock, NULL);\n \n-  if (!init_streams_for_device (ptx_dev, async_engines))\n-    return NULL;\n+  ptx_dev->free_blocks = NULL;\n+  pthread_mutex_init (&ptx_dev->free_blocks_lock, NULL);\n \n   return ptx_dev;\n }\n@@ -859,9 +506,15 @@ nvptx_close_device (struct ptx_device *ptx_dev)\n   if (!ptx_dev)\n     return true;\n \n-  if (!fini_streams_for_device (ptx_dev))\n-    return false;\n-  \n+  for (struct ptx_free_block *b = ptx_dev->free_blocks; b;)\n+    {\n+      struct ptx_free_block *b_next = b->next;\n+      CUDA_CALL (cuMemFree, (CUdeviceptr) b->ptr);\n+      free (b);\n+      b = b_next;\n+    }\n+\n+  pthread_mutex_destroy (&ptx_dev->free_blocks_lock);\n   pthread_mutex_destroy (&ptx_dev->image_lock);\n \n   if (!ptx_dev->ctx_shared)\n@@ -1040,140 +693,20 @@ link_ptx (CUmodule *module, const struct targ_ptx_obj *ptx_objs,\n   return true;\n }\n \n-static void\n-event_gc (bool memmap_lockable)\n-{\n-  struct ptx_event *ptx_event = ptx_events;\n-  struct ptx_event *async_cleanups = NULL;\n-  struct nvptx_thread *nvthd = nvptx_thread ();\n-\n-  pthread_mutex_lock (&ptx_event_lock);\n-\n-  while (ptx_event != NULL)\n-    {\n-      CUresult r;\n-      struct ptx_event *e = ptx_event;\n-\n-      ptx_event = ptx_event->next;\n-\n-      if (e->ord != nvthd->ptx_dev->ord)\n-\tcontinue;\n-\n-      r = CUDA_CALL_NOCHECK (cuEventQuery, *e->evt);\n-      if (r == CUDA_SUCCESS)\n-\t{\n-\t  bool append_async = false;\n-\t  CUevent *te;\n-\n-\t  te = e->evt;\n-\n-\t  switch (e->type)\n-\t    {\n-\t    case PTX_EVT_MEM:\n-\t    case PTX_EVT_SYNC:\n-\t      break;\n-\n-\t    case PTX_EVT_KNL:\n-\t      map_pop (e->addr);\n-\t      break;\n-\n-\t    case PTX_EVT_ASYNC_CLEANUP:\n-\t      {\n-\t\t/* The function gomp_plugin_async_unmap_vars needs to claim the\n-\t\t   memory-map splay tree lock for the current device, so we\n-\t\t   can't call it when one of our callers has already claimed\n-\t\t   the lock.  In that case, just delay the GC for this event\n-\t\t   until later.  */\n-\t\tif (!memmap_lockable)\n-\t\t  continue;\n-\n-\t\tappend_async = true;\n-\t      }\n-\t      break;\n-\t    }\n-\n-\t  CUDA_CALL_NOCHECK (cuEventDestroy, *te);\n-\t  free ((void *)te);\n-\n-\t  /* Unlink 'e' from ptx_events list.  */\n-\t  if (ptx_events == e)\n-\t    ptx_events = ptx_events->next;\n-\t  else\n-\t    {\n-\t      struct ptx_event *e_ = ptx_events;\n-\t      while (e_->next != e)\n-\t\te_ = e_->next;\n-\t      e_->next = e_->next->next;\n-\t    }\n-\n-\t  if (append_async)\n-\t    {\n-\t      e->next = async_cleanups;\n-\t      async_cleanups = e;\n-\t    }\n-\t  else\n-\t    free (e);\n-\t}\n-    }\n-\n-  pthread_mutex_unlock (&ptx_event_lock);\n-\n-  /* We have to do these here, after ptx_event_lock is released.  */\n-  while (async_cleanups)\n-    {\n-      struct ptx_event *e = async_cleanups;\n-      async_cleanups = async_cleanups->next;\n-\n-      GOMP_PLUGIN_async_unmap_vars (e->addr, e->val);\n-      free (e);\n-    }\n-}\n-\n-static void\n-event_add (enum ptx_event_type type, CUevent *e, void *h, int val)\n-{\n-  struct ptx_event *ptx_event;\n-  struct nvptx_thread *nvthd = nvptx_thread ();\n-\n-  assert (type == PTX_EVT_MEM || type == PTX_EVT_KNL || type == PTX_EVT_SYNC\n-\t  || type == PTX_EVT_ASYNC_CLEANUP);\n-\n-  ptx_event = GOMP_PLUGIN_malloc (sizeof (struct ptx_event));\n-  ptx_event->type = type;\n-  ptx_event->evt = e;\n-  ptx_event->addr = h;\n-  ptx_event->ord = nvthd->ptx_dev->ord;\n-  ptx_event->val = val;\n-\n-  pthread_mutex_lock (&ptx_event_lock);\n-\n-  ptx_event->next = ptx_events;\n-  ptx_events = ptx_event;\n-\n-  pthread_mutex_unlock (&ptx_event_lock);\n-}\n-\n static void\n nvptx_exec (void (*fn), size_t mapnum, void **hostaddrs, void **devaddrs,\n-\t    int async, unsigned *dims, void *targ_mem_desc)\n+\t    unsigned *dims, void *targ_mem_desc,\n+\t    CUdeviceptr dp, CUstream stream)\n {\n   struct targ_fn_descriptor *targ_fn = (struct targ_fn_descriptor *) fn;\n   CUfunction function;\n-  CUresult r;\n   int i;\n-  struct ptx_stream *dev_str;\n   void *kargs[1];\n-  void *hp;\n-  CUdeviceptr dp = 0;\n   struct nvptx_thread *nvthd = nvptx_thread ();\n   int warp_size = nvthd->ptx_dev->warp_size;\n-  const char *maybe_abort_msg = \"(perhaps abort was called)\";\n \n   function = targ_fn->fn;\n \n-  dev_str = select_stream_for_async (async, pthread_self (), false, NULL);\n-  assert (dev_str == nvthd->current_stream);\n-\n   /* Initialize the launch dimensions.  Typically this is constant,\n      provided by the device compiler, but we must permit runtime\n      values.  */\n@@ -1361,27 +894,6 @@ nvptx_exec (void (*fn), size_t mapnum, void **hostaddrs, void **devaddrs,\n \t\t\t   dims[GOMP_DIM_VECTOR]);\n     }\n \n-  if (mapnum > 0)\n-    {\n-      /* This reserves a chunk of a pre-allocated page of memory mapped on both\n-\t the host and the device. HP is a host pointer to the new chunk, and DP is\n-\t the corresponding device pointer.  */\n-      pthread_mutex_lock (&ptx_event_lock);\n-      dp = map_push (dev_str, mapnum * sizeof (void *));\n-      pthread_mutex_unlock (&ptx_event_lock);\n-\n-      GOMP_PLUGIN_debug (0, \"  %s: prepare mappings\\n\", __FUNCTION__);\n-\n-      /* Copy the array of arguments to the mapped page.  */\n-      hp = alloca(sizeof(void *) * mapnum);\n-      for (i = 0; i < mapnum; i++)\n-\t((void **) hp)[i] = devaddrs[i];\n-\n-      /* Copy the (device) pointers to arguments to the device */\n-      CUDA_CALL_ASSERT (cuMemcpyHtoD, dp, hp,\n-\t\t\tmapnum * sizeof (void *));\n-    }\n-\n   GOMP_PLUGIN_debug (0, \"  %s: kernel %s: launch\"\n \t\t     \" gangs=%u, workers=%u, vectors=%u\\n\",\n \t\t     __FUNCTION__, targ_fn->launch->fn, dims[GOMP_DIM_GANG],\n@@ -1392,62 +904,14 @@ nvptx_exec (void (*fn), size_t mapnum, void **hostaddrs, void **devaddrs,\n   // num_gangs\t\tnctaid.x\n   // num_workers\tntid.y\n   // vector length\tntid.x\n-\n   kargs[0] = &dp;\n   CUDA_CALL_ASSERT (cuLaunchKernel, function,\n \t\t    dims[GOMP_DIM_GANG], 1, 1,\n \t\t    dims[GOMP_DIM_VECTOR], dims[GOMP_DIM_WORKER], 1,\n-\t\t    0, dev_str->stream, kargs, 0);\n-\n-#ifndef DISABLE_ASYNC\n-  if (async < acc_async_noval)\n-    {\n-      r = CUDA_CALL_NOCHECK (cuStreamSynchronize, dev_str->stream);\n-      if (r == CUDA_ERROR_LAUNCH_FAILED)\n-\tGOMP_PLUGIN_fatal (\"cuStreamSynchronize error: %s %s\\n\", cuda_error (r),\n-\t\t\t   maybe_abort_msg);\n-      else if (r != CUDA_SUCCESS)\n-        GOMP_PLUGIN_fatal (\"cuStreamSynchronize error: %s\", cuda_error (r));\n-    }\n-  else\n-    {\n-      CUevent *e;\n-\n-      e = (CUevent *)GOMP_PLUGIN_malloc (sizeof (CUevent));\n-\n-      r = CUDA_CALL_NOCHECK (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n-      if (r == CUDA_ERROR_LAUNCH_FAILED)\n-\tGOMP_PLUGIN_fatal (\"cuEventCreate error: %s %s\\n\", cuda_error (r),\n-\t\t\t   maybe_abort_msg);\n-      else if (r != CUDA_SUCCESS)\n-        GOMP_PLUGIN_fatal (\"cuEventCreate error: %s\", cuda_error (r));\n-\n-      event_gc (true);\n-\n-      CUDA_CALL_ASSERT (cuEventRecord, *e, dev_str->stream);\n-\n-      if (mapnum > 0)\n-\tevent_add (PTX_EVT_KNL, e, (void *)dev_str, 0);\n-    }\n-#else\n-  r = CUDA_CALL_NOCHECK (cuCtxSynchronize, );\n-  if (r == CUDA_ERROR_LAUNCH_FAILED)\n-    GOMP_PLUGIN_fatal (\"cuCtxSynchronize error: %s %s\\n\", cuda_error (r),\n-\t\t       maybe_abort_msg);\n-  else if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuCtxSynchronize error: %s\", cuda_error (r));\n-#endif\n+\t\t    0, stream, kargs, 0);\n \n   GOMP_PLUGIN_debug (0, \"  %s: kernel %s: finished\\n\", __FUNCTION__,\n \t\t     targ_fn->launch->fn);\n-\n-#ifndef DISABLE_ASYNC\n-  if (async < acc_async_noval)\n-#endif\n-    {\n-      if (mapnum > 0)\n-\tmap_pop (dev_str);\n-    }\n }\n \n void * openacc_get_current_cuda_context (void);\n@@ -1462,8 +926,21 @@ nvptx_alloc (size_t s)\n }\n \n static bool\n-nvptx_free (void *p)\n+nvptx_free (void *p, struct ptx_device *ptx_dev)\n {\n+  /* Assume callback context if this is null.  */\n+  if (GOMP_PLUGIN_acc_thread () == NULL)\n+    {\n+      struct ptx_free_block *n\n+\t= GOMP_PLUGIN_malloc (sizeof (struct ptx_free_block));\n+      n->ptr = p;\n+      pthread_mutex_lock (&ptx_dev->free_blocks_lock);\n+      n->next = ptx_dev->free_blocks;\n+      ptx_dev->free_blocks = n;\n+      pthread_mutex_unlock (&ptx_dev->free_blocks_lock);\n+      return true;\n+    }\n+\n   CUdeviceptr pb;\n   size_t ps;\n \n@@ -1478,318 +955,19 @@ nvptx_free (void *p)\n   return true;\n }\n \n-\n-static bool\n-nvptx_host2dev (void *d, const void *h, size_t s)\n+static void *\n+nvptx_get_current_cuda_device (void)\n {\n-  CUdeviceptr pb;\n-  size_t ps;\n   struct nvptx_thread *nvthd = nvptx_thread ();\n \n-  if (!s)\n-    return true;\n-  if (!d)\n-    {\n-      GOMP_PLUGIN_error (\"invalid device address\");\n-      return false;\n-    }\n-\n-  CUDA_CALL (cuMemGetAddressRange, &pb, &ps, (CUdeviceptr) d);\n-\n-  if (!pb)\n-    {\n-      GOMP_PLUGIN_error (\"invalid device address\");\n-      return false;\n-    }\n-  if (!h)\n-    {\n-      GOMP_PLUGIN_error (\"invalid host address\");\n-      return false;\n-    }\n-  if (d == h)\n-    {\n-      GOMP_PLUGIN_error (\"invalid host or device address\");\n-      return false;\n-    }\n-  if ((void *)(d + s) > (void *)(pb + ps))\n-    {\n-      GOMP_PLUGIN_error (\"invalid size\");\n-      return false;\n-    }\n-\n-#ifndef DISABLE_ASYNC\n-  if (nvthd && nvthd->current_stream != nvthd->ptx_dev->null_stream)\n-    {\n-      CUevent *e = (CUevent *)GOMP_PLUGIN_malloc (sizeof (CUevent));\n-      CUDA_CALL (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n-      event_gc (false);\n-      CUDA_CALL (cuMemcpyHtoDAsync,\n-\t\t (CUdeviceptr) d, h, s, nvthd->current_stream->stream);\n-      CUDA_CALL (cuEventRecord, *e, nvthd->current_stream->stream);\n-      event_add (PTX_EVT_MEM, e, (void *)h, 0);\n-    }\n-  else\n-#endif\n-    CUDA_CALL (cuMemcpyHtoD, (CUdeviceptr) d, h, s);\n+  if (!nvthd || !nvthd->ptx_dev)\n+    return NULL;\n \n-  return true;\n+  return &nvthd->ptx_dev->dev;\n }\n \n-static bool\n-nvptx_dev2host (void *h, const void *d, size_t s)\n-{\n-  CUdeviceptr pb;\n-  size_t ps;\n-  struct nvptx_thread *nvthd = nvptx_thread ();\n-\n-  if (!s)\n-    return true;\n-  if (!d)\n-    {\n-      GOMP_PLUGIN_error (\"invalid device address\");\n-      return false;\n-    }\n-\n-  CUDA_CALL (cuMemGetAddressRange, &pb, &ps, (CUdeviceptr) d);\n-\n-  if (!pb)\n-    {\n-      GOMP_PLUGIN_error (\"invalid device address\");\n-      return false;\n-    }\n-  if (!h)\n-    {\n-      GOMP_PLUGIN_error (\"invalid host address\");\n-      return false;\n-    }\n-  if (d == h)\n-    {\n-      GOMP_PLUGIN_error (\"invalid host or device address\");\n-      return false;\n-    }\n-  if ((void *)(d + s) > (void *)(pb + ps))\n-    {\n-      GOMP_PLUGIN_error (\"invalid size\");\n-      return false;\n-    }\n-\n-#ifndef DISABLE_ASYNC\n-  if (nvthd && nvthd->current_stream != nvthd->ptx_dev->null_stream)\n-    {\n-      CUevent *e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));\n-      CUDA_CALL (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n-      event_gc (false);\n-      CUDA_CALL (cuMemcpyDtoHAsync,\n-\t\t h, (CUdeviceptr) d, s, nvthd->current_stream->stream);\n-      CUDA_CALL (cuEventRecord, *e, nvthd->current_stream->stream);\n-      event_add (PTX_EVT_MEM, e, (void *)h, 0);\n-    }\n-  else\n-#endif\n-    CUDA_CALL (cuMemcpyDtoH, h, (CUdeviceptr) d, s);\n-\n-  return true;\n-}\n-\n-static void\n-nvptx_set_async (int async)\n-{\n-  struct nvptx_thread *nvthd = nvptx_thread ();\n-  nvthd->current_stream\n-    = select_stream_for_async (async, pthread_self (), true, NULL);\n-}\n-\n-static int\n-nvptx_async_test (int async)\n-{\n-  CUresult r;\n-  struct ptx_stream *s;\n-\n-  s = select_stream_for_async (async, pthread_self (), false, NULL);\n-  if (!s)\n-    return 1;\n-\n-  r = CUDA_CALL_NOCHECK (cuStreamQuery, s->stream);\n-  if (r == CUDA_SUCCESS)\n-    {\n-      /* The oacc-parallel.c:goacc_wait function calls this hook to determine\n-\t whether all work has completed on this stream, and if so omits the call\n-\t to the wait hook.  If that happens, event_gc might not get called\n-\t (which prevents variables from getting unmapped and their associated\n-\t device storage freed), so call it here.  */\n-      event_gc (true);\n-      return 1;\n-    }\n-  else if (r == CUDA_ERROR_NOT_READY)\n-    return 0;\n-\n-  GOMP_PLUGIN_fatal (\"cuStreamQuery error: %s\", cuda_error (r));\n-\n-  return 0;\n-}\n-\n-static int\n-nvptx_async_test_all (void)\n-{\n-  struct ptx_stream *s;\n-  pthread_t self = pthread_self ();\n-  struct nvptx_thread *nvthd = nvptx_thread ();\n-\n-  pthread_mutex_lock (&nvthd->ptx_dev->stream_lock);\n-\n-  for (s = nvthd->ptx_dev->active_streams; s != NULL; s = s->next)\n-    {\n-      if ((s->multithreaded || pthread_equal (s->host_thread, self))\n-\t  && CUDA_CALL_NOCHECK (cuStreamQuery,\n-\t\t\t\ts->stream) == CUDA_ERROR_NOT_READY)\n-\t{\n-\t  pthread_mutex_unlock (&nvthd->ptx_dev->stream_lock);\n-\t  return 0;\n-\t}\n-    }\n-\n-  pthread_mutex_unlock (&nvthd->ptx_dev->stream_lock);\n-\n-  event_gc (true);\n-\n-  return 1;\n-}\n-\n-static void\n-nvptx_wait (int async)\n-{\n-  struct ptx_stream *s;\n-\n-  s = select_stream_for_async (async, pthread_self (), false, NULL);\n-  if (!s)\n-    return;\n-\n-  CUDA_CALL_ASSERT (cuStreamSynchronize, s->stream);\n-\n-  event_gc (true);\n-}\n-\n-static void\n-nvptx_wait_async (int async1, int async2)\n-{\n-  CUevent *e;\n-  struct ptx_stream *s1, *s2;\n-  pthread_t self = pthread_self ();\n-\n-  s1 = select_stream_for_async (async1, self, false, NULL);\n-  if (!s1)\n-    return;\n-\n-  /* The stream that is waiting (rather than being waited for) doesn't\n-     necessarily have to exist already.  */\n-  s2 = select_stream_for_async (async2, self, true, NULL);\n-\n-  /* A stream is always synchronized with itself.  */\n-  if (s1 == s2)\n-    return;\n-\n-  e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));\n-\n-  CUDA_CALL_ASSERT (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n-\n-  event_gc (true);\n-\n-  CUDA_CALL_ASSERT (cuEventRecord, *e, s1->stream);\n-\n-  event_add (PTX_EVT_SYNC, e, NULL, 0);\n-\n-  CUDA_CALL_ASSERT (cuStreamWaitEvent, s2->stream, *e, 0);\n-}\n-\n-static void\n-nvptx_wait_all (void)\n-{\n-  CUresult r;\n-  struct ptx_stream *s;\n-  pthread_t self = pthread_self ();\n-  struct nvptx_thread *nvthd = nvptx_thread ();\n-\n-  pthread_mutex_lock (&nvthd->ptx_dev->stream_lock);\n-\n-  /* Wait for active streams initiated by this thread (or by multiple threads)\n-     to complete.  */\n-  for (s = nvthd->ptx_dev->active_streams; s != NULL; s = s->next)\n-    {\n-      if (s->multithreaded || pthread_equal (s->host_thread, self))\n-\t{\n-\t  r = CUDA_CALL_NOCHECK (cuStreamQuery, s->stream);\n-\t  if (r == CUDA_SUCCESS)\n-\t    continue;\n-\t  else if (r != CUDA_ERROR_NOT_READY)\n-\t    GOMP_PLUGIN_fatal (\"cuStreamQuery error: %s\", cuda_error (r));\n-\n-\t  CUDA_CALL_ASSERT (cuStreamSynchronize, s->stream);\n-\t}\n-    }\n-\n-  pthread_mutex_unlock (&nvthd->ptx_dev->stream_lock);\n-\n-  event_gc (true);\n-}\n-\n-static void\n-nvptx_wait_all_async (int async)\n-{\n-  struct ptx_stream *waiting_stream, *other_stream;\n-  CUevent *e;\n-  struct nvptx_thread *nvthd = nvptx_thread ();\n-  pthread_t self = pthread_self ();\n-\n-  /* The stream doing the waiting.  This could be the first mention of the\n-     stream, so create it if necessary.  */\n-  waiting_stream\n-    = select_stream_for_async (async, pthread_self (), true, NULL);\n-\n-  /* Launches on the null stream already block on other streams in the\n-     context.  */\n-  if (!waiting_stream || waiting_stream == nvthd->ptx_dev->null_stream)\n-    return;\n-\n-  event_gc (true);\n-\n-  pthread_mutex_lock (&nvthd->ptx_dev->stream_lock);\n-\n-  for (other_stream = nvthd->ptx_dev->active_streams;\n-       other_stream != NULL;\n-       other_stream = other_stream->next)\n-    {\n-      if (!other_stream->multithreaded\n-\t  && !pthread_equal (other_stream->host_thread, self))\n-\tcontinue;\n-\n-      e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));\n-\n-      CUDA_CALL_ASSERT (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n-\n-      /* Record an event on the waited-for stream.  */\n-      CUDA_CALL_ASSERT (cuEventRecord, *e, other_stream->stream);\n-\n-      event_add (PTX_EVT_SYNC, e, NULL, 0);\n-\n-      CUDA_CALL_ASSERT (cuStreamWaitEvent, waiting_stream->stream, *e, 0);\n-   }\n-\n-  pthread_mutex_unlock (&nvthd->ptx_dev->stream_lock);\n-}\n-\n-static void *\n-nvptx_get_current_cuda_device (void)\n-{\n-  struct nvptx_thread *nvthd = nvptx_thread ();\n-\n-  if (!nvthd || !nvthd->ptx_dev)\n-    return NULL;\n-\n-  return &nvthd->ptx_dev->dev;\n-}\n-\n-static void *\n-nvptx_get_current_cuda_context (void)\n+static void *\n+nvptx_get_current_cuda_context (void)\n {\n   struct nvptx_thread *nvthd = nvptx_thread ();\n \n@@ -1799,75 +977,6 @@ nvptx_get_current_cuda_context (void)\n   return nvthd->ptx_dev->ctx;\n }\n \n-static void *\n-nvptx_get_cuda_stream (int async)\n-{\n-  struct ptx_stream *s;\n-  struct nvptx_thread *nvthd = nvptx_thread ();\n-\n-  if (!nvthd || !nvthd->ptx_dev)\n-    return NULL;\n-\n-  s = select_stream_for_async (async, pthread_self (), false, NULL);\n-\n-  return s ? s->stream : NULL;\n-}\n-\n-static int\n-nvptx_set_cuda_stream (int async, void *stream)\n-{\n-  struct ptx_stream *oldstream;\n-  pthread_t self = pthread_self ();\n-  struct nvptx_thread *nvthd = nvptx_thread ();\n-\n-  /* Due to the \"null_stream\" usage for \"acc_async_sync\", this cannot be used\n-     to change the stream handle associated with \"acc_async_sync\".  */\n-  if (async == acc_async_sync)\n-    {\n-      GOMP_PLUGIN_debug (0, \"Refusing request to set CUDA stream associated\"\n-\t\t\t \" with \\\"acc_async_sync\\\"\\n\");\n-      return 0;\n-    }\n-\n-  pthread_mutex_lock (&nvthd->ptx_dev->stream_lock);\n-\n-  /* We have a list of active streams and an array mapping async values to\n-     entries of that list.  We need to take \"ownership\" of the passed-in stream,\n-     and add it to our list, removing the previous entry also (if there was one)\n-     in order to prevent resource leaks.  Note the potential for surprise\n-     here: maybe we should keep track of passed-in streams and leave it up to\n-     the user to tidy those up, but that doesn't work for stream handles\n-     returned from acc_get_cuda_stream above...  */\n-\n-  oldstream = select_stream_for_async (async, self, false, NULL);\n-\n-  if (oldstream)\n-    {\n-      if (nvthd->ptx_dev->active_streams == oldstream)\n-\tnvthd->ptx_dev->active_streams = nvthd->ptx_dev->active_streams->next;\n-      else\n-\t{\n-\t  struct ptx_stream *s = nvthd->ptx_dev->active_streams;\n-\t  while (s->next != oldstream)\n-\t    s = s->next;\n-\t  s->next = s->next->next;\n-\t}\n-\n-      CUDA_CALL_ASSERT (cuStreamDestroy, oldstream->stream);\n-\n-      if (!map_fini (oldstream))\n-\tGOMP_PLUGIN_fatal (\"error when freeing host memory\");\n-\n-      free (oldstream);\n-    }\n-\n-  pthread_mutex_unlock (&nvthd->ptx_dev->stream_lock);\n-\n-  (void) select_stream_for_async (async, self, true, (CUstream) stream);\n-\n-  return 1;\n-}\n-\n /* Plugin entry points.  */\n \n const char *\n@@ -2107,100 +1216,116 @@ GOMP_OFFLOAD_alloc (int ord, size_t size)\n {\n   if (!nvptx_attach_host_thread_to_device (ord))\n     return NULL;\n-  return nvptx_alloc (size);\n-}\n \n-bool\n-GOMP_OFFLOAD_free (int ord, void *ptr)\n-{\n-  return (nvptx_attach_host_thread_to_device (ord)\n-\t  && nvptx_free (ptr));\n-}\n+  struct ptx_device *ptx_dev = ptx_devices[ord];\n+  struct ptx_free_block *blocks, *tmp;\n \n-bool\n-GOMP_OFFLOAD_dev2host (int ord, void *dst, const void *src, size_t n)\n-{\n-  return (nvptx_attach_host_thread_to_device (ord)\n-\t  && nvptx_dev2host (dst, src, n));\n-}\n+  pthread_mutex_lock (&ptx_dev->free_blocks_lock);\n+  blocks = ptx_dev->free_blocks;\n+  ptx_dev->free_blocks = NULL;\n+  pthread_mutex_unlock (&ptx_dev->free_blocks_lock);\n \n-bool\n-GOMP_OFFLOAD_host2dev (int ord, void *dst, const void *src, size_t n)\n-{\n-  return (nvptx_attach_host_thread_to_device (ord)\n-\t  && nvptx_host2dev (dst, src, n));\n+  while (blocks)\n+    {\n+      tmp = blocks->next;\n+      nvptx_free (blocks->ptr, ptx_dev);\n+      free (blocks);\n+      blocks = tmp;\n+    }\n+\n+  return nvptx_alloc (size);\n }\n \n bool\n-GOMP_OFFLOAD_dev2dev (int ord, void *dst, const void *src, size_t n)\n+GOMP_OFFLOAD_free (int ord, void *ptr)\n {\n-  struct ptx_device *ptx_dev = ptx_devices[ord];\n-  CUDA_CALL (cuMemcpyDtoDAsync, (CUdeviceptr) dst, (CUdeviceptr) src, n,\n-\t\t\t\tptx_dev->null_stream->stream);\n-  return true;\n+  return (nvptx_attach_host_thread_to_device (ord)\n+\t  && nvptx_free (ptr, ptx_devices[ord]));\n }\n \n-void (*device_run) (int n, void *fn_ptr, void *vars) = NULL;\n-\n void\n GOMP_OFFLOAD_openacc_exec (void (*fn) (void *), size_t mapnum,\n \t\t\t   void **hostaddrs, void **devaddrs,\n-\t\t\t   int async, unsigned *dims, void *targ_mem_desc)\n+\t\t\t   unsigned *dims, void *targ_mem_desc)\n {\n-  nvptx_exec (fn, mapnum, hostaddrs, devaddrs, async, dims, targ_mem_desc);\n-}\n+  GOMP_PLUGIN_debug (0, \"  %s: prepare mappings\\n\", __FUNCTION__);\n \n-void\n-GOMP_OFFLOAD_openacc_register_async_cleanup (void *targ_mem_desc, int async)\n-{\n-  struct nvptx_thread *nvthd = nvptx_thread ();\n-  CUevent *e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));\n+  void **hp = NULL;\n+  CUdeviceptr dp = 0;\n \n-  CUDA_CALL_ASSERT (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n-  CUDA_CALL_ASSERT (cuEventRecord, *e, nvthd->current_stream->stream);\n-  event_add (PTX_EVT_ASYNC_CLEANUP, e, targ_mem_desc, async);\n-}\n+  if (mapnum > 0)\n+    {\n+      hp = alloca (mapnum * sizeof (void *));\n+      for (int i = 0; i < mapnum; i++)\n+\thp[i] = (devaddrs[i] ? devaddrs[i] : hostaddrs[i]);\n+      CUDA_CALL_ASSERT (cuMemAlloc, &dp, mapnum * sizeof (void *));\n+    }\n \n-int\n-GOMP_OFFLOAD_openacc_async_test (int async)\n-{\n-  return nvptx_async_test (async);\n-}\n+  /* Copy the (device) pointers to arguments to the device (dp and hp might in\n+     fact have the same value on a unified-memory system).  */\n+  if (mapnum > 0)\n+    CUDA_CALL_ASSERT (cuMemcpyHtoD, dp, (void *) hp,\n+\t\t      mapnum * sizeof (void *));\n \n-int\n-GOMP_OFFLOAD_openacc_async_test_all (void)\n-{\n-  return nvptx_async_test_all ();\n-}\n+  nvptx_exec (fn, mapnum, hostaddrs, devaddrs, dims, targ_mem_desc,\n+\t      dp, NULL);\n \n-void\n-GOMP_OFFLOAD_openacc_async_wait (int async)\n-{\n-  nvptx_wait (async);\n+  CUresult r = CUDA_CALL_NOCHECK (cuStreamSynchronize, NULL);\n+  const char *maybe_abort_msg = \"(perhaps abort was called)\";\n+  if (r == CUDA_ERROR_LAUNCH_FAILED)\n+    GOMP_PLUGIN_fatal (\"cuStreamSynchronize error: %s %s\\n\", cuda_error (r),\n+\t\t       maybe_abort_msg);\n+  else if (r != CUDA_SUCCESS)\n+    GOMP_PLUGIN_fatal (\"cuStreamSynchronize error: %s\", cuda_error (r));\n+  CUDA_CALL_ASSERT (cuMemFree, dp);\n }\n \n-void\n-GOMP_OFFLOAD_openacc_async_wait_async (int async1, int async2)\n+static void\n+cuda_free_argmem (void *ptr)\n {\n-  nvptx_wait_async (async1, async2);\n+  void **block = (void **) ptr;\n+  nvptx_free (block[0], (struct ptx_device *) block[1]);\n+  free (block);\n }\n \n void\n-GOMP_OFFLOAD_openacc_async_wait_all (void)\n+GOMP_OFFLOAD_openacc_async_exec (void (*fn) (void *), size_t mapnum,\n+\t\t\t\t void **hostaddrs, void **devaddrs,\n+\t\t\t\t unsigned *dims, void *targ_mem_desc,\n+\t\t\t\t struct goacc_asyncqueue *aq)\n {\n-  nvptx_wait_all ();\n-}\n+  GOMP_PLUGIN_debug (0, \"  %s: prepare mappings\\n\", __FUNCTION__);\n \n-void\n-GOMP_OFFLOAD_openacc_async_wait_all_async (int async)\n-{\n-  nvptx_wait_all_async (async);\n-}\n+  void **hp = NULL;\n+  CUdeviceptr dp = 0;\n+  void **block = NULL;\n \n-void\n-GOMP_OFFLOAD_openacc_async_set_async (int async)\n-{\n-  nvptx_set_async (async);\n+  if (mapnum > 0)\n+    {\n+      block = (void **) GOMP_PLUGIN_malloc ((mapnum + 2) * sizeof (void *));\n+      hp = block + 2;\n+      for (int i = 0; i < mapnum; i++)\n+\thp[i] = (devaddrs[i] ? devaddrs[i] : hostaddrs[i]);\n+      CUDA_CALL_ASSERT (cuMemAlloc, &dp, mapnum * sizeof (void *));\n+    }\n+\n+  /* Copy the (device) pointers to arguments to the device (dp and hp might in\n+     fact have the same value on a unified-memory system).  */\n+  if (mapnum > 0)\n+    {\n+      CUDA_CALL_ASSERT (cuMemcpyHtoDAsync, dp, (void *) hp,\n+\t\t\tmapnum * sizeof (void *), aq->cuda_stream);\n+      block[0] = (void *) dp;\n+\n+      struct nvptx_thread *nvthd =\n+\t(struct nvptx_thread *) GOMP_PLUGIN_acc_thread ();\n+      block[1] = (void *) nvthd->ptx_dev;\n+    }\n+  nvptx_exec (fn, mapnum, hostaddrs, devaddrs, dims, targ_mem_desc,\n+\t      dp, aq->cuda_stream);\n+\n+  if (mapnum > 0)\n+    GOMP_OFFLOAD_openacc_async_queue_callback (aq, cuda_free_argmem, block);\n }\n \n void *\n@@ -2222,7 +1347,6 @@ GOMP_OFFLOAD_openacc_create_thread_data (int ord)\n   if (!thd_ctx)\n     CUDA_CALL_ASSERT (cuCtxPushCurrent, ptx_dev->ctx);\n \n-  nvthd->current_stream = ptx_dev->null_stream;\n   nvthd->ptx_dev = ptx_dev;\n \n   return (void *) nvthd;\n@@ -2246,20 +1370,184 @@ GOMP_OFFLOAD_openacc_cuda_get_current_context (void)\n   return nvptx_get_current_cuda_context ();\n }\n \n-/* NOTE: This returns a CUstream, not a ptx_stream pointer.  */\n-\n+/* This returns a CUstream.  */\n void *\n-GOMP_OFFLOAD_openacc_cuda_get_stream (int async)\n+GOMP_OFFLOAD_openacc_cuda_get_stream (struct goacc_asyncqueue *aq)\n+{\n+  return (void *) aq->cuda_stream;\n+}\n+\n+/* This takes a CUstream.  */\n+int\n+GOMP_OFFLOAD_openacc_cuda_set_stream (struct goacc_asyncqueue *aq, void *stream)\n+{\n+  if (aq->cuda_stream)\n+    {\n+      CUDA_CALL_ASSERT (cuStreamSynchronize, aq->cuda_stream);\n+      CUDA_CALL_ASSERT (cuStreamDestroy, aq->cuda_stream);\n+    }\n+\n+  aq->cuda_stream = (CUstream) stream;\n+  return 1;\n+}\n+\n+struct goacc_asyncqueue *\n+GOMP_OFFLOAD_openacc_async_construct (void)\n {\n-  return nvptx_get_cuda_stream (async);\n+  CUstream stream = NULL;\n+  CUDA_CALL_ERET (NULL, cuStreamCreate, &stream, CU_STREAM_DEFAULT);\n+\n+  struct goacc_asyncqueue *aq\n+    = GOMP_PLUGIN_malloc (sizeof (struct goacc_asyncqueue));\n+  aq->cuda_stream = stream;\n+  return aq;\n }\n \n-/* NOTE: This takes a CUstream, not a ptx_stream pointer.  */\n+bool\n+GOMP_OFFLOAD_openacc_async_destruct (struct goacc_asyncqueue *aq)\n+{\n+  CUDA_CALL_ERET (false, cuStreamDestroy, aq->cuda_stream);\n+  free (aq);\n+  return true;\n+}\n \n int\n-GOMP_OFFLOAD_openacc_cuda_set_stream (int async, void *stream)\n+GOMP_OFFLOAD_openacc_async_test (struct goacc_asyncqueue *aq)\n {\n-  return nvptx_set_cuda_stream (async, stream);\n+  CUresult r = CUDA_CALL_NOCHECK (cuStreamQuery, aq->cuda_stream);\n+  if (r == CUDA_SUCCESS)\n+    return 1;\n+  if (r == CUDA_ERROR_NOT_READY)\n+    return 0;\n+\n+  GOMP_PLUGIN_error (\"cuStreamQuery error: %s\", cuda_error (r));\n+  return -1;\n+}\n+\n+bool\n+GOMP_OFFLOAD_openacc_async_synchronize (struct goacc_asyncqueue *aq)\n+{\n+  CUDA_CALL_ERET (false, cuStreamSynchronize, aq->cuda_stream);\n+  return true;\n+}\n+\n+bool\n+GOMP_OFFLOAD_openacc_async_serialize (struct goacc_asyncqueue *aq1,\n+\t\t\t\t      struct goacc_asyncqueue *aq2)\n+{\n+  CUevent e;\n+  CUDA_CALL_ERET (false, cuEventCreate, &e, CU_EVENT_DISABLE_TIMING);\n+  CUDA_CALL_ERET (false, cuEventRecord, e, aq1->cuda_stream);\n+  CUDA_CALL_ERET (false, cuStreamWaitEvent, aq2->cuda_stream, e, 0);\n+  return true;\n+}\n+\n+static void\n+cuda_callback_wrapper (CUstream stream, CUresult res, void *ptr)\n+{\n+  if (res != CUDA_SUCCESS)\n+    GOMP_PLUGIN_fatal (\"%s error: %s\", __FUNCTION__, cuda_error (res));\n+  struct nvptx_callback *cb = (struct nvptx_callback *) ptr;\n+  cb->fn (cb->ptr);\n+  free (ptr);\n+}\n+\n+void\n+GOMP_OFFLOAD_openacc_async_queue_callback (struct goacc_asyncqueue *aq,\n+\t\t\t\t\t   void (*callback_fn)(void *),\n+\t\t\t\t\t   void *userptr)\n+{\n+  struct nvptx_callback *b = GOMP_PLUGIN_malloc (sizeof (*b));\n+  b->fn = callback_fn;\n+  b->ptr = userptr;\n+  b->aq = aq;\n+  CUDA_CALL_ASSERT (cuStreamAddCallback, aq->cuda_stream,\n+\t\t    cuda_callback_wrapper, (void *) b, 0);\n+}\n+\n+static bool\n+cuda_memcpy_sanity_check (const void *h, const void *d, size_t s)\n+{\n+  CUdeviceptr pb;\n+  size_t ps;\n+  if (!s)\n+    return true;\n+  if (!d)\n+    {\n+      GOMP_PLUGIN_error (\"invalid device address\");\n+      return false;\n+    }\n+  CUDA_CALL (cuMemGetAddressRange, &pb, &ps, (CUdeviceptr) d);\n+  if (!pb)\n+    {\n+      GOMP_PLUGIN_error (\"invalid device address\");\n+      return false;\n+    }\n+  if (!h)\n+    {\n+      GOMP_PLUGIN_error (\"invalid host address\");\n+      return false;\n+    }\n+  if (d == h)\n+    {\n+      GOMP_PLUGIN_error (\"invalid host or device address\");\n+      return false;\n+    }\n+  if ((void *)(d + s) > (void *)(pb + ps))\n+    {\n+      GOMP_PLUGIN_error (\"invalid size\");\n+      return false;\n+    }\n+  return true;\n+}\n+\n+bool\n+GOMP_OFFLOAD_host2dev (int ord, void *dst, const void *src, size_t n)\n+{\n+  if (!nvptx_attach_host_thread_to_device (ord)\n+      || !cuda_memcpy_sanity_check (src, dst, n))\n+    return false;\n+  CUDA_CALL (cuMemcpyHtoD, (CUdeviceptr) dst, src, n);\n+  return true;\n+}\n+\n+bool\n+GOMP_OFFLOAD_dev2host (int ord, void *dst, const void *src, size_t n)\n+{\n+  if (!nvptx_attach_host_thread_to_device (ord)\n+      || !cuda_memcpy_sanity_check (dst, src, n))\n+    return false;\n+  CUDA_CALL (cuMemcpyDtoH, dst, (CUdeviceptr) src, n);\n+  return true;\n+}\n+\n+bool\n+GOMP_OFFLOAD_dev2dev (int ord, void *dst, const void *src, size_t n)\n+{\n+  CUDA_CALL (cuMemcpyDtoDAsync, (CUdeviceptr) dst, (CUdeviceptr) src, n, NULL);\n+  return true;\n+}\n+\n+bool\n+GOMP_OFFLOAD_openacc_async_host2dev (int ord, void *dst, const void *src,\n+\t\t\t\t     size_t n, struct goacc_asyncqueue *aq)\n+{\n+  if (!nvptx_attach_host_thread_to_device (ord)\n+      || !cuda_memcpy_sanity_check (src, dst, n))\n+    return false;\n+  CUDA_CALL (cuMemcpyHtoDAsync, (CUdeviceptr) dst, src, n, aq->cuda_stream);\n+  return true;\n+}\n+\n+bool\n+GOMP_OFFLOAD_openacc_async_dev2host (int ord, void *dst, const void *src,\n+\t\t\t\t     size_t n, struct goacc_asyncqueue *aq)\n+{\n+  if (!nvptx_attach_host_thread_to_device (ord)\n+      || !cuda_memcpy_sanity_check (dst, src, n))\n+    return false;\n+  CUDA_CALL (cuMemcpyDtoHAsync, dst, (CUdeviceptr) src, n, aq->cuda_stream);\n+  return true;\n }\n \n /* Adjust launch dimensions: pick good values for number of blocks and warps\n@@ -2360,8 +1648,7 @@ GOMP_OFFLOAD_run (int ord, void *tgt_fn, void *tgt_vars, void **args)\n     CU_LAUNCH_PARAM_END\n   };\n   r = CUDA_CALL_NOCHECK (cuLaunchKernel, function, teams, 1, 1,\n-\t\t\t 32, threads, 1, 0, ptx_dev->null_stream->stream,\n-\t\t\t NULL, config);\n+\t\t\t 32, threads, 1, 0, NULL, NULL, config);\n   if (r != CUDA_SUCCESS)\n     GOMP_PLUGIN_fatal (\"cuLaunchKernel error: %s\", cuda_error (r));\n "}, {"sha": "2e0905effb3b3f56f503dfb60d065011e31ff10c", "filename": "libgomp/target.c", "status": "modified", "additions": 148, "deletions": 58, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=1f4c5b9bb2eb81880e2bc725435d596fcd2bdfef", "patch": "@@ -177,6 +177,22 @@ gomp_device_copy (struct gomp_device_descr *devicep,\n     }\n }\n \n+static inline void\n+goacc_device_copy_async (struct gomp_device_descr *devicep,\n+\t\t\t bool (*copy_func) (int, void *, const void *, size_t,\n+\t\t\t\t\t    struct goacc_asyncqueue *),\n+\t\t\t const char *dst, void *dstaddr,\n+\t\t\t const char *src, const void *srcaddr,\n+\t\t\t size_t size, struct goacc_asyncqueue *aq)\n+{\n+  if (!copy_func (devicep->target_id, dstaddr, srcaddr, size, aq))\n+    {\n+      gomp_mutex_unlock (&devicep->lock);\n+      gomp_fatal (\"Copying of %s object [%p..%p) to %s object [%p..%p) failed\",\n+\t\t  src, srcaddr, srcaddr + size, dst, dstaddr, dstaddr + size);\n+    }\n+}\n+\n /* Infrastructure for coalescing adjacent or nearly adjacent (in device addresses)\n    host to device memory transfers.  */\n \n@@ -269,8 +285,9 @@ gomp_to_device_kind_p (int kind)\n     }\n }\n \n-static void\n+attribute_hidden void\n gomp_copy_host2dev (struct gomp_device_descr *devicep,\n+\t\t    struct goacc_asyncqueue *aq,\n \t\t    void *d, const void *h, size_t sz,\n \t\t    struct gomp_coalesce_buf *cbuf)\n {\n@@ -299,14 +316,23 @@ gomp_copy_host2dev (struct gomp_device_descr *devicep,\n \t    }\n \t}\n     }\n-  gomp_device_copy (devicep, devicep->host2dev_func, \"dev\", d, \"host\", h, sz);\n+  if (__builtin_expect (aq != NULL, 0))\n+    goacc_device_copy_async (devicep, devicep->openacc.async.host2dev_func,\n+\t\t\t     \"dev\", d, \"host\", h, sz, aq);\n+  else\n+    gomp_device_copy (devicep, devicep->host2dev_func, \"dev\", d, \"host\", h, sz);\n }\n \n-static void\n+attribute_hidden void\n gomp_copy_dev2host (struct gomp_device_descr *devicep,\n+\t\t    struct goacc_asyncqueue *aq,\n \t\t    void *h, const void *d, size_t sz)\n {\n-  gomp_device_copy (devicep, devicep->dev2host_func, \"host\", h, \"dev\", d, sz);\n+  if (__builtin_expect (aq != NULL, 0))\n+    goacc_device_copy_async (devicep, devicep->openacc.async.dev2host_func,\n+\t\t\t     \"host\", h, \"dev\", d, sz, aq);\n+  else\n+    gomp_device_copy (devicep, devicep->dev2host_func, \"host\", h, \"dev\", d, sz);\n }\n \n static void\n@@ -324,7 +350,8 @@ gomp_free_device_memory (struct gomp_device_descr *devicep, void *devptr)\n    Helper function of gomp_map_vars.  */\n \n static inline void\n-gomp_map_vars_existing (struct gomp_device_descr *devicep, splay_tree_key oldn,\n+gomp_map_vars_existing (struct gomp_device_descr *devicep,\n+\t\t\tstruct goacc_asyncqueue *aq, splay_tree_key oldn,\n \t\t\tsplay_tree_key newn, struct target_var_desc *tgt_var,\n \t\t\tunsigned char kind, struct gomp_coalesce_buf *cbuf)\n {\n@@ -346,7 +373,7 @@ gomp_map_vars_existing (struct gomp_device_descr *devicep, splay_tree_key oldn,\n     }\n \n   if (GOMP_MAP_ALWAYS_TO_P (kind))\n-    gomp_copy_host2dev (devicep,\n+    gomp_copy_host2dev (devicep, aq,\n \t\t\t(void *) (oldn->tgt->tgt_start + oldn->tgt_offset\n \t\t\t\t  + newn->host_start - oldn->host_start),\n \t\t\t(void *) newn->host_start,\n@@ -364,8 +391,8 @@ get_kind (bool short_mapkind, void *kinds, int idx)\n }\n \n static void\n-gomp_map_pointer (struct target_mem_desc *tgt, uintptr_t host_ptr,\n-\t\t  uintptr_t target_offset, uintptr_t bias,\n+gomp_map_pointer (struct target_mem_desc *tgt, struct goacc_asyncqueue *aq,\n+\t\t  uintptr_t host_ptr, uintptr_t target_offset, uintptr_t bias,\n \t\t  struct gomp_coalesce_buf *cbuf)\n {\n   struct gomp_device_descr *devicep = tgt->device_descr;\n@@ -376,7 +403,7 @@ gomp_map_pointer (struct target_mem_desc *tgt, uintptr_t host_ptr,\n   if (cur_node.host_start == (uintptr_t) NULL)\n     {\n       cur_node.tgt_offset = (uintptr_t) NULL;\n-      gomp_copy_host2dev (devicep,\n+      gomp_copy_host2dev (devicep, aq,\n \t\t\t  (void *) (tgt->tgt_start + target_offset),\n \t\t\t  (void *) &cur_node.tgt_offset,\n \t\t\t  sizeof (void *), cbuf);\n@@ -398,12 +425,13 @@ gomp_map_pointer (struct target_mem_desc *tgt, uintptr_t host_ptr,\n      array section.  Now subtract bias to get what we want\n      to initialize the pointer with.  */\n   cur_node.tgt_offset -= bias;\n-  gomp_copy_host2dev (devicep, (void *) (tgt->tgt_start + target_offset),\n+  gomp_copy_host2dev (devicep, aq, (void *) (tgt->tgt_start + target_offset),\n \t\t      (void *) &cur_node.tgt_offset, sizeof (void *), cbuf);\n }\n \n static void\n-gomp_map_fields_existing (struct target_mem_desc *tgt, splay_tree_key n,\n+gomp_map_fields_existing (struct target_mem_desc *tgt,\n+\t\t\t  struct goacc_asyncqueue *aq, splay_tree_key n,\n \t\t\t  size_t first, size_t i, void **hostaddrs,\n \t\t\t  size_t *sizes, void *kinds,\n \t\t\t  struct gomp_coalesce_buf *cbuf)\n@@ -423,7 +451,7 @@ gomp_map_fields_existing (struct target_mem_desc *tgt, splay_tree_key n,\n       && n2->tgt == n->tgt\n       && n2->host_start - n->host_start == n2->tgt_offset - n->tgt_offset)\n     {\n-      gomp_map_vars_existing (devicep, n2, &cur_node,\n+      gomp_map_vars_existing (devicep, aq, n2, &cur_node,\n \t\t\t      &tgt->list[i], kind & typemask, cbuf);\n       return;\n     }\n@@ -439,8 +467,8 @@ gomp_map_fields_existing (struct target_mem_desc *tgt, splay_tree_key n,\n \t      && n2->host_start - n->host_start\n \t\t == n2->tgt_offset - n->tgt_offset)\n \t    {\n-\t      gomp_map_vars_existing (devicep, n2, &cur_node, &tgt->list[i],\n-\t\t\t\t      kind & typemask, cbuf);\n+\t      gomp_map_vars_existing (devicep, aq, n2, &cur_node,\n+\t\t\t\t      &tgt->list[i], kind & typemask, cbuf);\n \t      return;\n \t    }\n \t}\n@@ -451,7 +479,7 @@ gomp_map_fields_existing (struct target_mem_desc *tgt, splay_tree_key n,\n \t  && n2->tgt == n->tgt\n \t  && n2->host_start - n->host_start == n2->tgt_offset - n->tgt_offset)\n \t{\n-\t  gomp_map_vars_existing (devicep, n2, &cur_node, &tgt->list[i],\n+\t  gomp_map_vars_existing (devicep, aq, n2, &cur_node, &tgt->list[i],\n \t\t\t\t  kind & typemask, cbuf);\n \t  return;\n \t}\n@@ -483,10 +511,12 @@ gomp_map_val (struct target_mem_desc *tgt, void **hostaddrs, size_t i)\n   return tgt->tgt_start + tgt->list[i].offset;\n }\n \n-attribute_hidden struct target_mem_desc *\n-gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n-\t       void **hostaddrs, void **devaddrs, size_t *sizes, void *kinds,\n-\t       bool short_mapkind, enum gomp_map_vars_kind pragma_kind)\n+static inline __attribute__((always_inline)) struct target_mem_desc *\n+gomp_map_vars_internal (struct gomp_device_descr *devicep,\n+\t\t\tstruct goacc_asyncqueue *aq, size_t mapnum,\n+\t\t\tvoid **hostaddrs, void **devaddrs, size_t *sizes,\n+\t\t\tvoid *kinds, bool short_mapkind,\n+\t\t\tenum gomp_map_vars_kind pragma_kind)\n {\n   size_t i, tgt_align, tgt_size, not_found_cnt = 0;\n   bool has_firstprivate = false;\n@@ -600,7 +630,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t      continue;\n \t    }\n \t  for (i = first; i <= last; i++)\n-\t    gomp_map_fields_existing (tgt, n, first, i, hostaddrs,\n+\t    gomp_map_fields_existing (tgt, aq, n, first, i, hostaddrs,\n \t\t\t\t      sizes, kinds, NULL);\n \t  i--;\n \t  continue;\n@@ -645,7 +675,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n       else\n \tn = splay_tree_lookup (mem_map, &cur_node);\n       if (n && n->refcount != REFCOUNT_LINK)\n-\tgomp_map_vars_existing (devicep, n, &cur_node, &tgt->list[i],\n+\tgomp_map_vars_existing (devicep, aq, n, &cur_node, &tgt->list[i],\n \t\t\t\tkind & typemask, NULL);\n       else\n \t{\n@@ -756,7 +786,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\ttgt_size = (tgt_size + align - 1) & ~(align - 1);\n \t\ttgt->list[i].offset = tgt_size;\n \t\tlen = sizes[i];\n-\t\tgomp_copy_host2dev (devicep,\n+\t\tgomp_copy_host2dev (devicep, aq,\n \t\t\t\t    (void *) (tgt->tgt_start + tgt_size),\n \t\t\t\t    (void *) hostaddrs[i], len, cbufp);\n \t\ttgt_size += len;\n@@ -790,7 +820,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t    continue;\n \t\t  }\n \t\tfor (i = first; i <= last; i++)\n-\t\t  gomp_map_fields_existing (tgt, n, first, i, hostaddrs,\n+\t\t  gomp_map_fields_existing (tgt, aq, n, first, i, hostaddrs,\n \t\t\t\t\t    sizes, kinds, cbufp);\n \t\ti--;\n \t\tcontinue;\n@@ -810,7 +840,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t  cur_node.tgt_offset = gomp_map_val (tgt, hostaddrs, i - 1);\n \t\tif (cur_node.tgt_offset)\n \t\t  cur_node.tgt_offset -= sizes[i];\n-\t\tgomp_copy_host2dev (devicep,\n+\t\tgomp_copy_host2dev (devicep, aq,\n \t\t\t\t    (void *) (n->tgt->tgt_start\n \t\t\t\t\t      + n->tgt_offset\n \t\t\t\t\t      + cur_node.host_start\n@@ -831,7 +861,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t      k->host_end = k->host_start + sizeof (void *);\n \t    splay_tree_key n = splay_tree_lookup (mem_map, k);\n \t    if (n && n->refcount != REFCOUNT_LINK)\n-\t      gomp_map_vars_existing (devicep, n, k, &tgt->list[i],\n+\t      gomp_map_vars_existing (devicep, aq, n, k, &tgt->list[i],\n \t\t\t\t      kind & typemask, cbufp);\n \t    else\n \t      {\n@@ -884,18 +914,19 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t  case GOMP_MAP_FORCE_TOFROM:\n \t\t  case GOMP_MAP_ALWAYS_TO:\n \t\t  case GOMP_MAP_ALWAYS_TOFROM:\n-\t\t    gomp_copy_host2dev (devicep,\n+\t\t    gomp_copy_host2dev (devicep, aq,\n \t\t\t\t\t(void *) (tgt->tgt_start\n \t\t\t\t\t\t  + k->tgt_offset),\n \t\t\t\t\t(void *) k->host_start,\n \t\t\t\t\tk->host_end - k->host_start, cbufp);\n \t\t    break;\n \t\t  case GOMP_MAP_POINTER:\n-\t\t    gomp_map_pointer (tgt, (uintptr_t) *(void **) k->host_start,\n+\t\t    gomp_map_pointer (tgt, aq,\n+\t\t\t\t      (uintptr_t) *(void **) k->host_start,\n \t\t\t\t      k->tgt_offset, sizes[i], cbufp);\n \t\t    break;\n \t\t  case GOMP_MAP_TO_PSET:\n-\t\t    gomp_copy_host2dev (devicep,\n+\t\t    gomp_copy_host2dev (devicep, aq,\n \t\t\t\t\t(void *) (tgt->tgt_start\n \t\t\t\t\t\t  + k->tgt_offset),\n \t\t\t\t\t(void *) k->host_start,\n@@ -917,7 +948,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t\t  tgt->list[j].always_copy_from = false;\n \t\t\t  if (k->refcount != REFCOUNT_INFINITY)\n \t\t\t    k->refcount++;\n-\t\t\t  gomp_map_pointer (tgt,\n+\t\t\t  gomp_map_pointer (tgt, aq,\n \t\t\t\t\t    (uintptr_t) *(void **) hostaddrs[j],\n \t\t\t\t\t    k->tgt_offset\n \t\t\t\t\t    + ((uintptr_t) hostaddrs[j]\n@@ -946,7 +977,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t    break;\n \t\t  case GOMP_MAP_FORCE_DEVICEPTR:\n \t\t    assert (k->host_end - k->host_start == sizeof (void *));\n-\t\t    gomp_copy_host2dev (devicep,\n+\t\t    gomp_copy_host2dev (devicep, aq,\n \t\t\t\t\t(void *) (tgt->tgt_start\n \t\t\t\t\t\t  + k->tgt_offset),\n \t\t\t\t\t(void *) k->host_start,\n@@ -965,7 +996,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t    void *tgt_addr = (void *) (tgt->tgt_start + k->tgt_offset);\n \t\t    /* We intentionally do not use coalescing here, as it's not\n \t\t       data allocated by the current call to this function.  */\n-\t\t    gomp_copy_host2dev (devicep, (void *) n->tgt_offset,\n+\t\t    gomp_copy_host2dev (devicep, aq, (void *) n->tgt_offset,\n \t\t\t\t\t&tgt_addr, sizeof (void *), NULL);\n \t\t  }\n \t\tarray++;\n@@ -978,7 +1009,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n       for (i = 0; i < mapnum; i++)\n \t{\n \t  cur_node.tgt_offset = gomp_map_val (tgt, hostaddrs, i);\n-\t  gomp_copy_host2dev (devicep,\n+\t  gomp_copy_host2dev (devicep, aq,\n \t\t\t      (void *) (tgt->tgt_start + i * sizeof (void *)),\n \t\t\t      (void *) &cur_node.tgt_offset, sizeof (void *),\n \t\t\t      cbufp);\n@@ -989,7 +1020,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n     {\n       long c = 0;\n       for (c = 0; c < cbuf.chunk_cnt; ++c)\n-\tgomp_copy_host2dev (devicep,\n+\tgomp_copy_host2dev (devicep, aq,\n \t\t\t    (void *) (tgt->tgt_start + cbuf.chunks[c].start),\n \t\t\t    (char *) cbuf.buf + (cbuf.chunks[c].start\n \t\t\t\t\t\t - cbuf.chunks[0].start),\n@@ -1012,7 +1043,27 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n   return tgt;\n }\n \n-static void\n+attribute_hidden struct target_mem_desc *\n+gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n+\t       void **hostaddrs, void **devaddrs, size_t *sizes, void *kinds,\n+\t       bool short_mapkind, enum gomp_map_vars_kind pragma_kind)\n+{\n+  return gomp_map_vars_internal (devicep, NULL, mapnum, hostaddrs, devaddrs,\n+\t\t\t\t sizes, kinds, short_mapkind, pragma_kind);\n+}\n+\n+attribute_hidden struct target_mem_desc *\n+gomp_map_vars_async (struct gomp_device_descr *devicep,\n+\t\t     struct goacc_asyncqueue *aq, size_t mapnum,\n+\t\t     void **hostaddrs, void **devaddrs, size_t *sizes,\n+\t\t     void *kinds, bool short_mapkind,\n+\t\t     enum gomp_map_vars_kind pragma_kind)\n+{\n+  return gomp_map_vars_internal (devicep, aq, mapnum, hostaddrs, devaddrs,\n+\t\t\t\t sizes, kinds, short_mapkind, pragma_kind);\n+}\n+\n+attribute_hidden void\n gomp_unmap_tgt (struct target_mem_desc *tgt)\n {\n   /* Deallocate on target the tgt->tgt_start .. tgt->tgt_end region.  */\n@@ -1040,12 +1091,24 @@ gomp_remove_var (struct gomp_device_descr *devicep, splay_tree_key k)\n   return is_tgt_unmapped;\n }\n \n+static void\n+gomp_unref_tgt (void *ptr)\n+{\n+  struct target_mem_desc *tgt = (struct target_mem_desc *) ptr;\n+\n+  if (tgt->refcount > 1)\n+    tgt->refcount--;\n+  else\n+    gomp_unmap_tgt (tgt);\n+}\n+\n /* Unmap variables described by TGT.  If DO_COPYFROM is true, copy relevant\n    variables back from device to host: if it is false, it is assumed that this\n    has been done already.  */\n \n-attribute_hidden void\n-gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)\n+static inline __attribute__((always_inline)) void\n+gomp_unmap_vars_internal (struct target_mem_desc *tgt, bool do_copyfrom,\n+\t\t\t  struct goacc_asyncqueue *aq)\n {\n   struct gomp_device_descr *devicep = tgt->device_descr;\n \n@@ -1082,7 +1145,7 @@ gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)\n \n       if ((do_unmap && do_copyfrom && tgt->list[i].copy_from)\n \t  || tgt->list[i].always_copy_from)\n-\tgomp_copy_dev2host (devicep,\n+\tgomp_copy_dev2host (devicep, aq,\n \t\t\t    (void *) (k->host_start + tgt->list[i].offset),\n \t\t\t    (void *) (k->tgt->tgt_start + k->tgt_offset\n \t\t\t\t      + tgt->list[i].offset),\n@@ -1091,14 +1154,28 @@ gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)\n \tgomp_remove_var (devicep, k);\n     }\n \n-  if (tgt->refcount > 1)\n-    tgt->refcount--;\n+  if (aq)\n+    devicep->openacc.async.queue_callback_func (aq, gomp_unref_tgt,\n+\t\t\t\t\t\t(void *) tgt);\n   else\n-    gomp_unmap_tgt (tgt);\n+    gomp_unref_tgt ((void *) tgt);\n \n   gomp_mutex_unlock (&devicep->lock);\n }\n \n+attribute_hidden void\n+gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)\n+{\n+  gomp_unmap_vars_internal (tgt, do_copyfrom, NULL);\n+}\n+\n+attribute_hidden void\n+gomp_unmap_vars_async (struct target_mem_desc *tgt, bool do_copyfrom,\n+\t\t       struct goacc_asyncqueue *aq)\n+{\n+  gomp_unmap_vars_internal (tgt, do_copyfrom, aq);\n+}\n+\n static void\n gomp_update (struct gomp_device_descr *devicep, size_t mapnum, void **hostaddrs,\n \t     size_t *sizes, void *kinds, bool short_mapkind)\n@@ -1148,9 +1225,10 @@ gomp_update (struct gomp_device_descr *devicep, size_t mapnum, void **hostaddrs,\n \t    size_t size = cur_node.host_end - cur_node.host_start;\n \n \t    if (GOMP_MAP_COPY_TO_P (kind & typemask))\n-\t      gomp_copy_host2dev (devicep, devaddr, hostaddr, size, NULL);\n+\t      gomp_copy_host2dev (devicep, NULL, devaddr, hostaddr, size,\n+\t\t\t\t  NULL);\n \t    if (GOMP_MAP_COPY_FROM_P (kind & typemask))\n-\t      gomp_copy_dev2host (devicep, hostaddr, devaddr, size);\n+\t      gomp_copy_dev2host (devicep, NULL, hostaddr, devaddr, size);\n \t  }\n       }\n   gomp_mutex_unlock (&devicep->lock);\n@@ -1443,9 +1521,24 @@ gomp_init_device (struct gomp_device_descr *devicep)\n \t\t\t\t   false);\n     }\n \n+  /* Initialize OpenACC asynchronous queues.  */\n+  goacc_init_asyncqueues (devicep);\n+\n   devicep->state = GOMP_DEVICE_INITIALIZED;\n }\n \n+/* This function finalizes the target device, specified by DEVICEP.  DEVICEP\n+   must be locked on entry, and remains locked on return.  */\n+\n+attribute_hidden bool\n+gomp_fini_device (struct gomp_device_descr *devicep)\n+{\n+  bool ret = goacc_fini_asyncqueues (devicep);\n+  ret &= devicep->fini_device_func (devicep->target_id);\n+  devicep->state = GOMP_DEVICE_FINALIZED;\n+  return ret;\n+}\n+\n attribute_hidden void\n gomp_unload_device (struct gomp_device_descr *devicep)\n {\n@@ -1954,7 +2047,7 @@ gomp_exit_data (struct gomp_device_descr *devicep, size_t mapnum,\n \n \t  if ((kind == GOMP_MAP_FROM && k->refcount == 0)\n \t      || kind == GOMP_MAP_ALWAYS_FROM)\n-\t    gomp_copy_dev2host (devicep, (void *) cur_node.host_start,\n+\t    gomp_copy_dev2host (devicep, NULL, (void *) cur_node.host_start,\n \t\t\t\t(void *) (k->tgt->tgt_start + k->tgt_offset\n \t\t\t\t\t  + cur_node.host_start\n \t\t\t\t\t  - k->host_start),\n@@ -2636,20 +2729,20 @@ gomp_load_plugin_for_device (struct gomp_device_descr *device,\n   if (device->capabilities & GOMP_OFFLOAD_CAP_OPENACC_200)\n     {\n       if (!DLSYM_OPT (openacc.exec, openacc_exec)\n-\t  || !DLSYM_OPT (openacc.register_async_cleanup,\n-\t\t\t openacc_register_async_cleanup)\n-\t  || !DLSYM_OPT (openacc.async_test, openacc_async_test)\n-\t  || !DLSYM_OPT (openacc.async_test_all, openacc_async_test_all)\n-\t  || !DLSYM_OPT (openacc.async_wait, openacc_async_wait)\n-\t  || !DLSYM_OPT (openacc.async_wait_async, openacc_async_wait_async)\n-\t  || !DLSYM_OPT (openacc.async_wait_all, openacc_async_wait_all)\n-\t  || !DLSYM_OPT (openacc.async_wait_all_async,\n-\t\t\t openacc_async_wait_all_async)\n-\t  || !DLSYM_OPT (openacc.async_set_async, openacc_async_set_async)\n \t  || !DLSYM_OPT (openacc.create_thread_data,\n \t\t\t openacc_create_thread_data)\n \t  || !DLSYM_OPT (openacc.destroy_thread_data,\n-\t\t\t openacc_destroy_thread_data))\n+\t\t\t openacc_destroy_thread_data)\n+\t  || !DLSYM_OPT (openacc.async.construct, openacc_async_construct)\n+\t  || !DLSYM_OPT (openacc.async.destruct, openacc_async_destruct)\n+\t  || !DLSYM_OPT (openacc.async.test, openacc_async_test)\n+\t  || !DLSYM_OPT (openacc.async.synchronize, openacc_async_synchronize)\n+\t  || !DLSYM_OPT (openacc.async.serialize, openacc_async_serialize)\n+\t  || !DLSYM_OPT (openacc.async.queue_callback,\n+\t\t\t openacc_async_queue_callback)\n+\t  || !DLSYM_OPT (openacc.async.exec, openacc_async_exec)\n+\t  || !DLSYM_OPT (openacc.async.dev2host, openacc_async_dev2host)\n+\t  || !DLSYM_OPT (openacc.async.host2dev, openacc_async_host2dev))\n \t{\n \t  /* Require all the OpenACC handlers if we have\n \t     GOMP_OFFLOAD_CAP_OPENACC_200.  */\n@@ -2700,10 +2793,7 @@ gomp_target_fini (void)\n       struct gomp_device_descr *devicep = &devices[i];\n       gomp_mutex_lock (&devicep->lock);\n       if (devicep->state == GOMP_DEVICE_INITIALIZED)\n-\t{\n-\t  ret = devicep->fini_device_func (devicep->target_id);\n-\t  devicep->state = GOMP_DEVICE_FINALIZED;\n-\t}\n+\tret = gomp_fini_device (devicep);\n       gomp_mutex_unlock (&devicep->lock);\n       if (!ret)\n \tgomp_fatal (\"device finalization failed\");"}]}