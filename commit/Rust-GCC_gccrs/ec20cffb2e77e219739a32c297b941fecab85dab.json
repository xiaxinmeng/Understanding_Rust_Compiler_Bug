{"sha": "ec20cffb2e77e219739a32c297b941fecab85dab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMyMGNmZmIyZTc3ZTIxOTczOWEzMmMyOTdiOTQxZmVjYWI4NWRhYg==", "commit": {"author": {"name": "Jason Thorpe", "email": "thorpej@gcc.gnu.org", "date": "2002-10-01T20:16:04Z"}, "committer": {"name": "Jason Thorpe", "email": "thorpej@gcc.gnu.org", "date": "2002-10-01T20:16:04Z"}, "message": "[multiple changes]\n\n2002-10-01  Matt Thomas  <matt@3am-software.com>\n            Jason Thorpe  <thorpej@wasabisystems.com>\n\n* config.gcc (vax-*-netbsdelf*): Enable configuration.\n* config/elfos.h (PCC_BITFIELD_TYPE_MATTERS): Define only\nif not already defined.\n* config/vax/elf.h: New file.\n* config/vax/netbsd-elf.h: New file.\n* config/vax/vax.c: Include \"debug.h\".\n(vax_output_function_prologue): Add dwarf2 support.  Use\nMAIN_NAME_P when checking for VMS_TARGET stack adjust.\n* config/vax/vax.h (CONST_OK_FOR_LETTER_P): Add cases for\n'J' [0..63], 'K' [-128..127], 'L' [-32768..32767],\n'M' [0..255], 'N' [0..65535], and, 'O' [-63..-1].\n(VAX_ISTREAM_SYNC): Remove.\n(INITIALIZE_TRAMPOLINE): Use gen_sync_istream.\n(JUMP_TABLES_IN_TEXT_SECTION): Define.\n(ASM_OUTPUT_REG_POP): Use reg_names for the stack pointer.\n(ASM_OUTPUT_ADDR_VEC_ELT): Use ASM_GENERATE_INTERNAL_LABEL\nand assemble_name.\n(ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n(PRINT_OPERAND_PUNCT_VALID_P): Accept '|'.\n(PRINT_OPERAND): Output REGISTER_PREFIX for '|'.\n(INCOMING_RETURN_ADDR_RTX): Define.\n* config/vax/vax.md (VUNSPEC_BLOCKAGE)\n(VUNSPEC_SYNC_ISTREAM): Define.\n(blockage): Use VUNSPEC_BLOCKAGE.\n(sync_istream): New insn.\n\n\n2002-10-01  Richard Henderson  <rth@redhat.com>\n\n* config/vax/vax.md (call_pop, *call_pop, call_value_pop)\n(*call_value_pop, call, call_value): Add dwarf2 EH support.\n(*call): New insn.\n\nFrom-SVN: r57702", "tree": {"sha": "12fb6765596785cdd40ed2f4afd15f1223c7721e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12fb6765596785cdd40ed2f4afd15f1223c7721e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec20cffb2e77e219739a32c297b941fecab85dab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec20cffb2e77e219739a32c297b941fecab85dab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec20cffb2e77e219739a32c297b941fecab85dab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec20cffb2e77e219739a32c297b941fecab85dab/comments", "author": null, "committer": null, "parents": [{"sha": "6f7e9e94497e08e6efba3b3793fea5eb7f17ad8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f7e9e94497e08e6efba3b3793fea5eb7f17ad8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f7e9e94497e08e6efba3b3793fea5eb7f17ad8e"}], "stats": {"total": 348, "additions": 291, "deletions": 57}, "files": [{"sha": "d1a6dda3a38d7f51cba48dc0981713da03b65c6b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec20cffb2e77e219739a32c297b941fecab85dab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec20cffb2e77e219739a32c297b941fecab85dab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec20cffb2e77e219739a32c297b941fecab85dab", "patch": "@@ -1,3 +1,38 @@\n+2002-10-01  Matt Thomas  <matt@3am-software.com>\n+            Jason Thorpe  <thorpej@wasabisystems.com>\n+\n+\t* config.gcc (vax-*-netbsdelf*): Enable configuration.\n+\t* config/elfos.h (PCC_BITFIELD_TYPE_MATTERS): Define only \n+\tif not already defined.\n+\t* config/vax/elf.h: New file.\n+\t* config/vax/netbsd-elf.h: New file.\n+\t* config/vax/vax.c: Include \"debug.h\".\n+\t(vax_output_function_prologue): Add dwarf2 support.  Use\n+\tMAIN_NAME_P when checking for VMS_TARGET stack adjust.\n+\t* config/vax/vax.h (CONST_OK_FOR_LETTER_P): Add cases for\n+\t'J' [0..63], 'K' [-128..127], 'L' [-32768..32767],\n+\t'M' [0..255], 'N' [0..65535], and, 'O' [-63..-1].\n+\t(VAX_ISTREAM_SYNC): Remove.\n+\t(INITIALIZE_TRAMPOLINE): Use gen_sync_istream.\n+\t(JUMP_TABLES_IN_TEXT_SECTION): Define.\n+\t(ASM_OUTPUT_REG_POP): Use reg_names for the stack pointer.\n+\t(ASM_OUTPUT_ADDR_VEC_ELT): Use ASM_GENERATE_INTERNAL_LABEL\n+\tand assemble_name.\n+\t(ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n+\t(PRINT_OPERAND_PUNCT_VALID_P): Accept '|'.\n+\t(PRINT_OPERAND): Output REGISTER_PREFIX for '|'.\n+\t(INCOMING_RETURN_ADDR_RTX): Define.\n+\t* config/vax/vax.md (VUNSPEC_BLOCKAGE)\n+\t(VUNSPEC_SYNC_ISTREAM): Define.\n+\t(blockage): Use VUNSPEC_BLOCKAGE.\n+\t(sync_istream): New insn.\n+\n+2002-10-01  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/vax/vax.md (call_pop, *call_pop, call_value_pop)\n+\t(*call_value_pop, call, call_value): Add dwarf2 EH support.\n+\t(*call): New insn.\n+\n 2002-10-01  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c/8083"}, {"sha": "961dee16332470220a899b264546da020ed7d5eb", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec20cffb2e77e219739a32c297b941fecab85dab/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec20cffb2e77e219739a32c297b941fecab85dab/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=ec20cffb2e77e219739a32c297b941fecab85dab", "patch": "@@ -2609,7 +2609,8 @@ vax-*-sysv*)\t\t\t# VAXen running system V\n \txm_defines=POSIX\n \t;;\n vax-*-netbsdelf*)\n-\techo \"GCC does not yet support the ${machine} target\"; exit 1\n+\ttm_file=\"${tm_file} elfos.h netbsd.h netbsd-elf.h vax/elf.h vax/netbsd-elf.h\"\n+\tfloat_format=vax\n \t;;\n vax-*-netbsd*)\n \ttm_file=\"${tm_file} netbsd.h netbsd-aout.h vax/netbsd.h\""}, {"sha": "1900e9aeb0e49b15b545e4cfa6944b8dda78b8d5", "filename": "gcc/config/elfos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec20cffb2e77e219739a32c297b941fecab85dab/gcc%2Fconfig%2Felfos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec20cffb2e77e219739a32c297b941fecab85dab/gcc%2Fconfig%2Felfos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felfos.h?ref=ec20cffb2e77e219739a32c297b941fecab85dab", "patch": "@@ -48,7 +48,9 @@ Boston, MA 02111-1307, USA.  */\n \n /* Writing `int' for a bit-field forces int alignment for the structure.  */\n \n+#ifndef PCC_BITFIELD_TYPE_MATTERS\n #define PCC_BITFIELD_TYPE_MATTERS 1\n+#endif\n \n /* Implicit library calls should use memcpy, not bcopy, etc.  */\n "}, {"sha": "2f1a37566cdce539aba2d4340f95722845a16731", "filename": "gcc/config/vax/elf.h", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec20cffb2e77e219739a32c297b941fecab85dab/gcc%2Fconfig%2Fvax%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec20cffb2e77e219739a32c297b941fecab85dab/gcc%2Fconfig%2Fvax%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Felf.h?ref=ec20cffb2e77e219739a32c297b941fecab85dab", "patch": "@@ -0,0 +1,97 @@\n+/* Target definitions for GNU compiler for VAX using ELF\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Contributed by Matt Thomas (matt@3am-software.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#undef REGISTER_PREFIX\n+#undef REGISTER_NAMES\n+#define REGISTER_PREFIX \"%\"\n+#define REGISTER_NAMES \\\n+{\"%r0\", \"%r1\",  \"%r2\",  \"%r3\", \"%r4\", \"%r5\", \"%r6\", \"%r7\", \\\n+ \"%r8\", \"%r9\", \"%r10\", \"%r11\", \"%ap\", \"%fp\", \"%sp\", \"%pc\"}\n+  \n+#undef SIZE_TYPE\n+#define SIZE_TYPE \"long unsigned int\"\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"long int\"\n+\n+/* Profiling routine.  */\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+  fprintf (FILE, \"\\tmovab .LP%d,%sr0\\n\\tjsb __mcount+2\\n\", (LABELNO), \\\n+           REGISTER_PREFIX)\n+  \n+/*  Let's be re-entrant.  */\n+#undef PCC_STATIC_STRUCT_RETURN\n+\n+/* Make sure .stabs for a function are always the same section.  */\n+#define\tDBX_OUTPUT_FUNCTION_END(file,decl) function_section(decl)\n+\n+/* Before the prologue, the top of the frame is below the argument\n+   count pushed by the CALLS and before the start of the saved registers.  */\n+#define INCOMING_FRAME_SP_OFFSET 0\n+\n+/* We use R2-R5 (call-clobbered) registers for exceptions.  */\n+#define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N) + 2 : INVALID_REGNUM)\n+\n+/* Place the top of the stack for the DWARF2 EH stackadj value.  */\n+#define EH_RETURN_STACKADJ_RTX\t\t\t\t\t\t\\\n+  gen_rtx_MEM (SImode,\t\t\t\t\t\t\t\\\n+\t       plus_constant (gen_rtx_REG (Pmode, FRAME_POINTER_REGNUM), \\\n+\t\t\t      -4))\n+\n+/* Simple store the return handler into the call frame.  */\n+#define EH_RETURN_HANDLER_RTX\t\t\t\t\t\t\\\n+  gen_rtx_MEM (Pmode,\t\t\t\t\t\t\t\\\n+\t       plus_constant (gen_rtx_REG (Pmode, FRAME_POINTER_REGNUM), \\\n+\t\t\t      16))\n+\n+\n+/* Reserve the top of the stack for exception handler stackadj value.  */\n+#undef STARTING_FRAME_OFFSET\n+#define STARTING_FRAME_OFFSET -4\n+\n+/* The VAX wants no space between the case instruction and the jump table.  */\n+#undef  ASM_OUTPUT_BEFORE_CASE_LABEL\n+#define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\n+\n+/* Get the udiv/urem calls out of the user's namespace.  */\n+#undef  UDIVSI3_LIBCALL\n+#define UDIVSI3_LIBCALL \"*__udiv\"\n+#undef  UMODSI3_LIBCALL\n+#define UMODSI3_LIBCALL \"*__urem\"\n+\n+#undef OVERRIDE_OPTIONS\n+#define OVERRIDE_OPTIONS\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      /* Do generic VAX overrides.  */\t\t\\\n+      override_options ();\t\t\t\\\n+\t\t\t\t\t\t\\\n+      /* Turn off function CSE if we're \t\\\n+\t doing PIC.  */\t\t\t\t\\\n+      if (flag_pic) flag_no_function_cse = 1;\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* VAX ELF is always gas; override the generic VAX ASM_SPEC.  */\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \"\""}, {"sha": "e28d1a157439d9a1ee7c51d38001be59b55e0a05", "filename": "gcc/config/vax/netbsd-elf.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec20cffb2e77e219739a32c297b941fecab85dab/gcc%2Fconfig%2Fvax%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec20cffb2e77e219739a32c297b941fecab85dab/gcc%2Fconfig%2Fvax%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fnetbsd-elf.h?ref=ec20cffb2e77e219739a32c297b941fecab85dab", "patch": "@@ -0,0 +1,61 @@\n+/* Definitions of target machine for GNU compiler,\n+   for NetBSD/vax ELF systems.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Names to predefine in the preprocessor for this target OS.  */\n+#undef TARGET_OS_CPP_BUILTINS\n+#define TARGET_OS_CPP_BUILTINS()\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      NETBSD_OS_CPP_BUILTINS_ELF();\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC NETBSD_CPP_SPEC\n+\n+#define NETBSD_ENTRY_POINT \"__start\"\n+\n+#undef LINK_SPEC\n+#if 1\n+/* FIXME: We must link all executables statically until PIC support\n+   is added to the compiler.  */\n+#define LINK_SPEC \\\n+  \"%{assert*} %{R*} %{rpath*} \\\n+   %{shared:%eThe -shared option is not currently supported for VAX ELF.} \\\n+   %{!shared: \\\n+     -dc -dp \\\n+     %{!nostdlib: \\\n+       %{!r*: \\\n+\t %{!e*:-e %(netbsd_entry_point)}}} \\\n+     %{!static:-static} \\\n+     %{static:-static}}\"\n+#else\n+#define LINK_SPEC NETBSD_LINK_SPEC_ELF\n+#endif\n+\n+#define EXTRA_SPECS\t\t\t\t\\\n+  { \"netbsd_entry_point\", NETBSD_ENTRY_POINT },\n+\n+/* We use gas, not the UNIX assembler.  */\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT 0\n+\n+#undef ASM_FINAL_SPEC"}, {"sha": "f8b0a0d3343dabbb4339d556e0b16183b8508b4a", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec20cffb2e77e219739a32c297b941fecab85dab/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec20cffb2e77e219739a32c297b941fecab85dab/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=ec20cffb2e77e219739a32c297b941fecab85dab", "patch": "@@ -34,6 +34,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"expr.h\"\n #include \"flags.h\"\n+#include \"debug.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n@@ -101,40 +102,31 @@ vax_output_function_prologue (file, size)\n \n   fprintf (file, \"\\t.word 0x%x\\n\", mask);\n \n-  if (VMS_TARGET)\n+  if (dwarf2out_do_frame ())\n     {\n-      /*\n-       * This works for both gcc and g++.  It first checks to see if\n-       * the current routine is \"main\", which will only happen for\n-       * GCC, and add the jsb if it is.  If is not the case then try\n-       * and see if __MAIN_NAME is part of current_function_name,\n-       * which will only happen if we are running g++, and add the jsb\n-       * if it is.  In gcc there should never be a paren in the\n-       * function name, and in g++ there is always a \"(\" in the\n-       * function name, thus there should never be any confusion.\n-       *\n-       * Adjusting the stack pointer by 4 before calling C$MAIN_ARGS\n-       * is required when linking with the VMS POSIX version of the C\n-       * run-time library; using `subl2 $4,r0' is adequate but we use\n-       * `clrl -(sp)' instead.  The extra 4 bytes could be removed\n-       * after the call because STARTING_FRAME_OFFSET's setting of -4\n-       * will end up adding them right back again, but don't bother.\n-       */\n-\n-      const char *p = current_function_name;\n-      int is_main = strcmp (\"main\", p) == 0;\n-#     define __MAIN_NAME \" main(\"\n-\n-      while (!is_main && *p != '\\0')\n-\t{\n-\t  if (*p == *__MAIN_NAME\n-\t      && strncmp (p, __MAIN_NAME, sizeof __MAIN_NAME - sizeof \"\") == 0)\n-\t    is_main = 1;\n-\t  else\n-\t    p++;\n-\t}\n+      const char *label = dwarf2out_cfi_label ();\n+      int offset = 0;\n+\n+      for (regno = FIRST_PSEUDO_REGISTER-1; regno >= 0; --regno)\n+\tif (regs_ever_live[regno] && !call_used_regs[regno])\n+\t  dwarf2out_reg_save (label, regno, offset -= 4);\n \n-      if (is_main)\n+      dwarf2out_reg_save (label, PC_REGNUM, offset -= 4);\n+      dwarf2out_reg_save (label, FRAME_POINTER_REGNUM, offset -= 4);\n+      dwarf2out_reg_save (label, ARG_POINTER_REGNUM, offset -= 4);\n+      dwarf2out_def_cfa (label, FRAME_POINTER_REGNUM, -(offset - 4));\n+    }\n+\n+  if (VMS_TARGET)\n+    {\n+      /* Adjusting the stack pointer by 4 before calling C$MAIN_ARGS\n+\t is required when linking with the VMS POSIX version of the C\n+\t run-time library; using `subl2 $4,r0' is adequate but we use\n+\t `clrl -(sp)' instead.  The extra 4 bytes could be removed\n+\t after the call because STARTING_FRAME_OFFSET's setting of -4\n+\t will end up adding them right back again, but don't bother.  */\n+\n+      if (MAIN_NAME_P (DECL_NAME (current_function_decl)))\n \tfprintf (file, \"\\tclrl -(%ssp)\\n\\tjsb _C$MAIN_ARGS\\n\",\n \t         REGISTER_PREFIX);\n     }"}, {"sha": "1a163ad77635e87ec6976b7820444ab52cbe3fe6", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 70, "deletions": 24, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec20cffb2e77e219739a32c297b941fecab85dab/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec20cffb2e77e219739a32c297b941fecab85dab/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=ec20cffb2e77e219739a32c297b941fecab85dab", "patch": "@@ -28,6 +28,15 @@\n ;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n ;;- updates for most instructions.\n \n+;; UNSPEC_VOLATILE usage:\n+\n+(define_constants\n+  [(VUNSPEC_BLOCKAGE 0)     ; `blockage' insn to prevent scheduling across an\n+\t\t\t    ;   insn in the code.\n+   (VUNSPEC_SYNC_ISTREAM 1) ; sequence of insns to sync the I-stream\n+  ]\n+)\n+\n ;; We don't want to allow a constant operand for test insns because\n ;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n ;; be folded while optimizing anyway.\n@@ -1798,32 +1807,33 @@\n   \"\"\n   \"decl %0\\;jgequ %l1\")\n \f\n-;; Note that operand 1 is total size of args, in bytes,\n-;; and what the call insn wants is the number of words.\n-;; It is used in the call instruction as a byte, but in the addl2 as\n-;; a word.  Since the only time we actually use it in the call instruction\n-;; is when it is a constant, SImode (for addl2) is the proper mode.\n (define_expand \"call_pop\"\n   [(parallel [(call (match_operand:QI 0 \"memory_operand\" \"\")\n \t\t    (match_operand:SI 1 \"const_int_operand\" \"\"))\n \t      (set (reg:SI 14)\n \t\t   (plus:SI (reg:SI 14)\n \t\t\t    (match_operand:SI 3 \"immediate_operand\" \"\")))])]\n   \"\"\n-  \"\n {\n-  if (INTVAL (operands[1]) > 255 * 4)\n+  if (INTVAL (operands[3]) > 255 * 4 || INTVAL (operands[3]) % 4)\n     abort ();\n-  operands[1] = GEN_INT ((INTVAL (operands[1]) + 3)/ 4);\n-}\")\n+\n+  /* Operand 1 is the number of bytes to be popped by DW_CFA_GNU_args_size\n+     during EH unwinding.  We must include the argument count pushed by\n+     the calls instruction.  */\n+  operands[1] = GEN_INT (INTVAL (operands[3]) + 4);\n+})\n \n (define_insn \"*call_pop\"\n   [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n \t (match_operand:SI 1 \"const_int_operand\" \"n\"))\n    (set (reg:SI 14) (plus:SI (reg:SI 14)\n \t\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n-  \"calls %1,%0\")\n+{\n+  operands[1] = GEN_INT ((INTVAL (operands[1]) - 4) / 4);\n+  return \"calls %1,%0\";\n+})\n \n (define_expand \"call_value_pop\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n@@ -1833,12 +1843,15 @@\n \t\t   (plus:SI (reg:SI 14)\n \t\t\t    (match_operand:SI 4 \"immediate_operand\" \"\")))])]\n   \"\"\n-  \"\n {\n-  if (INTVAL (operands[2]) > 255 * 4)\n-    abort ();      \n-  operands[2] = GEN_INT ((INTVAL (operands[2]) + 3)/ 4);\n-}\")\n+  if (INTVAL (operands[4]) > 255 * 4 || INTVAL (operands[4]) % 4)\n+    abort ();\n+\n+  /* Operand 2 is the number of bytes to be popped by DW_CFA_GNU_args_size\n+     during EH unwinding.  We must include the argument count pushed by\n+     the calls instruction.  */\n+  operands[2] = GEN_INT (INTVAL (operands[4]) + 4);\n+})\n \n (define_insn \"*call_value_pop\"\n   [(set (match_operand 0 \"\" \"\")\n@@ -1847,20 +1860,47 @@\n    (set (reg:SI 14) (plus:SI (reg:SI 14)\n \t\t\t     (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n   \"\"\n-  \"calls %2,%1\")\n+  \"*\n+{\n+  operands[2] = GEN_INT ((INTVAL (operands[2]) - 4) / 4);\n+  return \\\"calls %2,%1\\\";\n+}\")\n+\n+(define_expand \"call\"\n+  [(call (match_operand:QI 0 \"memory_operand\" \"\")\n+      (match_operand:SI 1 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Operand 1 is the number of bytes to be popped by DW_CFA_GNU_args_size\n+     during EH unwinding.  We must include the argument count pushed by\n+     the calls instruction.  */\n+  operands[1] = GEN_INT (INTVAL (operands[1]) + 4);\n+}\")\n \n-;; Define another set of these for the case of functions with no operands.\n-;; These will allow the optimizers to do a slightly better job.\n-(define_insn \"call\"\n-  [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n-\t (const_int 0))]\n+(define_insn \"*call\"\n+   [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n+       (match_operand:SI 1 \"const_int_operand\" \"\"))]\n   \"\"\n   \"calls $0,%0\")\n \n-(define_insn \"call_value\"\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"\" \"\")\n+      (call (match_operand:QI 1 \"memory_operand\" \"\")\n+            (match_operand:SI 2 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  /* Operand 2 is the number of bytes to be popped by DW_CFA_GNU_args_size\n+     during EH unwinding.  We must include the argument count pushed by\n+     the calls instruction.  */\n+  operands[2] = GEN_INT (INTVAL (operands[2]) + 4);\n+}\")\n+\n+(define_insn \"*call_value\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (match_operand:QI 1 \"memory_operand\" \"m\")\n-\t      (const_int 0)))]\n+\t      (match_operand:SI 2 \"const_int_operand\" \"\")))]\n   \"\"\n   \"calls $0,%1\")\n \n@@ -1897,7 +1937,7 @@\n ;; all of memory.  This blocks insns from being moved across this point.\n \n (define_insn \"blockage\"\n-  [(unspec_volatile [(const_int 0)] 0)]\n+  [(unspec_volatile [(const_int 0)] VUNSPEC_BLOCKAGE)]\n   \"\"\n   \"\")\n \n@@ -2121,3 +2161,9 @@\n     = GEN_INT (INTVAL (operands[3]) & ~((1 << INTVAL (operands[2])) - 1));\n   return \\\"rotl %2,%1,%0\\;bicl2 %N3,%0\\\";\n }\")\n+\n+;; Instruction sequence to sync the VAX instruction stream.\n+(define_insn \"sync_istream\"\n+  [(unspec_volatile [(const_int 0)] VUNSPEC_SYNC_ISTREAM)]\n+  \"\"\n+  \"movpsl -(%|sp)\\;pushal 1(%|pc)\\;rei\")"}]}