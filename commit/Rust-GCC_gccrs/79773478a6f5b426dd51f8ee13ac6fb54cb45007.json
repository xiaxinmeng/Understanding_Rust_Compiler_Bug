{"sha": "79773478a6f5b426dd51f8ee13ac6fb54cb45007", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk3NzM0NzhhNmY1YjQyNmRkNTFmOGVlMTNhYzZmYjU0Y2I0NTAwNw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2006-04-12T01:26:23Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2006-04-12T01:26:23Z"}, "message": "rs6000.c (rs6000_mixed_function_arg): Update magic NULL_RTX comment.\n\n\t* config/rs6000/rs6000.c (rs6000_mixed_function_arg): Update\n\tmagic NULL_RTX comment.\n\t(function_arg): Store entire fp arg to mem if any part should go\n\ton stack.\n\t(rs6000_arg_partial_bytes): Adjust for above change.\n\nFrom-SVN: r112880", "tree": {"sha": "67df74dbf8974b57e11bd540be83d1f9c46111e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67df74dbf8974b57e11bd540be83d1f9c46111e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79773478a6f5b426dd51f8ee13ac6fb54cb45007", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79773478a6f5b426dd51f8ee13ac6fb54cb45007", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79773478a6f5b426dd51f8ee13ac6fb54cb45007", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79773478a6f5b426dd51f8ee13ac6fb54cb45007/comments", "author": null, "committer": null, "parents": [{"sha": "11279bd9e4cfe78234fed8c829e5cb27b5643ba4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11279bd9e4cfe78234fed8c829e5cb27b5643ba4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11279bd9e4cfe78234fed8c829e5cb27b5643ba4"}], "stats": {"total": 53, "additions": 29, "deletions": 24}, "files": [{"sha": "d64827710aaa78f4490fc9c285518a38ed16b629", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79773478a6f5b426dd51f8ee13ac6fb54cb45007/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79773478a6f5b426dd51f8ee13ac6fb54cb45007/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79773478a6f5b426dd51f8ee13ac6fb54cb45007", "patch": "@@ -1,3 +1,11 @@\n+2006-04-12  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* config/rs6000/rs6000.c (rs6000_mixed_function_arg): Update\n+\tmagic NULL_RTX comment.\n+\t(function_arg): Store entire fp arg to mem if any part should go\n+\ton stack.\n+\t(rs6000_arg_partial_bytes): Adjust for above change.\n+\n 2006-04-11  Roger Sayle  <roger@eyesopen.com>\n \n \t* dwarf2out.c (output_call_frame_info): Create debug_frame_section"}, {"sha": "2bc0fd7ebcd2d03a8bc723b188c0e79dfcddeccf", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79773478a6f5b426dd51f8ee13ac6fb54cb45007/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79773478a6f5b426dd51f8ee13ac6fb54cb45007/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=79773478a6f5b426dd51f8ee13ac6fb54cb45007", "patch": "@@ -5058,17 +5058,13 @@ rs6000_mixed_function_arg (enum machine_mode mode, tree type, int align_words)\n   if (align_words + n_units > GP_ARG_NUM_REG)\n     /* Not all of the arg fits in gprs.  Say that it goes in memory too,\n        using a magic NULL_RTX component.\n-       FIXME: This is not strictly correct.  Only some of the arg\n-       belongs in memory, not all of it.  However, there isn't any way\n-       to do this currently, apart from building rtx descriptions for\n-       the pieces of memory we want stored.  Due to bugs in the generic\n-       code we can't use the normal function_arg_partial_nregs scheme\n-       with the PARALLEL arg description we emit here.\n-       In any case, the code to store the whole arg to memory is often\n-       more efficient than code to store pieces, and we know that space\n-       is available in the right place for the whole arg.  */\n-    /* FIXME: This should be fixed since the conversion to\n-       TARGET_ARG_PARTIAL_BYTES.  */\n+       This is not strictly correct.  Only some of the arg belongs in\n+       memory, not all of it.  However, the normal scheme using\n+       function_arg_partial_nregs can result in unusual subregs, eg.\n+       (subreg:SI (reg:DF) 4), which are not handled well.  The code to\n+       store the whole arg to memory is often more efficient than code\n+       to store pieces, and we know that space is available in the right\n+       place for the whole arg.  */\n     rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, NULL_RTX, const0_rtx);\n \n   i = 0;\n@@ -5310,9 +5306,8 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t include the portion actually in registers here.  */\n \t\t      enum machine_mode rmode = TARGET_32BIT ? SImode : DImode;\n \t\t      rtx off;\n-\t\t      int i=0;\n-\t\t      if (align_words + n_words > GP_ARG_NUM_REG\n-\t\t\t  && (TARGET_32BIT && TARGET_POWERPC64))\n+\t\t      int i = 0;\n+\t\t      if (align_words + n_words > GP_ARG_NUM_REG)\n \t\t\t/* Not all of the arg fits in gprs.  Say that it\n \t\t\t   goes in memory too, using a magic NULL_RTX\n \t\t\t   component.  Also see comment in\n@@ -5391,18 +5386,20 @@ rs6000_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n   align_words = rs6000_parm_start (mode, type, cum->words);\n \n-  if (USE_FP_FOR_ARG_P (cum, mode, type)\n+  if (USE_FP_FOR_ARG_P (cum, mode, type))\n+    {\n       /* If we are passing this arg in the fixed parameter save area\n \t (gprs or memory) as well as fprs, then this function should\n-\t return the number of bytes passed in the parameter save area\n-\t rather than bytes passed in fprs.  */\n-      && !(type\n-\t   && (cum->nargs_prototype <= 0\n-\t       || (DEFAULT_ABI == ABI_AIX\n-\t\t   && TARGET_XL_COMPAT\n-\t\t   && align_words >= GP_ARG_NUM_REG))))\n-    {\n-      if (cum->fregno + ((GET_MODE_SIZE (mode) + 7) >> 3) > FP_ARG_MAX_REG + 1)\n+\t return the number of partial bytes passed in the parameter\n+\t save area rather than partial bytes passed in fprs.  */\n+      if (type\n+\t  && (cum->nargs_prototype <= 0\n+\t      || (DEFAULT_ABI == ABI_AIX\n+\t\t  && TARGET_XL_COMPAT\n+\t\t  && align_words >= GP_ARG_NUM_REG)))\n+\treturn 0;\n+      else if (cum->fregno + ((GET_MODE_SIZE (mode) + 7) >> 3)\n+\t       > FP_ARG_MAX_REG + 1)\n \tret = (FP_ARG_MAX_REG + 1 - cum->fregno) * 8;\n       else if (cum->nargs_prototype >= 0)\n \treturn 0;"}]}