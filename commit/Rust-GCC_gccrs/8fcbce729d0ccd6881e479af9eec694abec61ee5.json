{"sha": "8fcbce729d0ccd6881e479af9eec694abec61ee5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZjYmNlNzI5ZDBjY2Q2ODgxZTQ3OWFmOWVlYzY5NGFiZWM2MWVlNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-02-08T09:09:01Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-02-08T09:09:01Z"}, "message": "re PR middle-end/60092 (posix_memalign not recognized to derive alias and alignment info)\n\n\tPR middle-end/60092\n\t* tree-ssa-ccp.c (surely_varying_stmt_p): Don't return true\n\tif TYPE_ATTRIBUTES (gimple_call_fntype ()) contain\n\tassume_aligned or alloc_align attributes.\n\t(bit_value_assume_aligned): Add ATTR, PTRVAL and ALLOC_ALIGN\n\targuments.  Handle also assume_aligned and alloc_align attributes.\n\t(evaluate_stmt): Adjust bit_value_assume_aligned caller.\n\tHandle calls to functions with assume_aligned or alloc_align\n\tattributes.\n\t* doc/extend.texi: Document assume_aligned and alloc_align\n\tattributes.\nc-family/\n\t* c-common.c (handle_alloc_size_attribute): Use tree_fits_uhwi_p\n\tand tree_to_uhwi.\n\t(handle_alloc_align_attribute, handle_assume_aligned_attribute): New\n\tfunctions.\n\t(c_common_attribute_table): Add alloc_align and assume_aligned\n\tattributes.\ntestsuite/\n\t* gcc.dg/attr-alloc_align-1.c: New test.\n\t* gcc.dg/attr-alloc_align-2.c: New test.\n\t* gcc.dg/attr-alloc_align-3.c: New test.\n\t* gcc.dg/attr-assume_aligned-1.c: New test.\n\t* gcc.dg/attr-assume_aligned-2.c: New test.\n\t* gcc.dg/attr-assume_aligned-3.c: New test.\n\nFrom-SVN: r207628", "tree": {"sha": "f4136c704d65e778659cad96324aa2c41d89c897", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4136c704d65e778659cad96324aa2c41d89c897"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fcbce729d0ccd6881e479af9eec694abec61ee5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fcbce729d0ccd6881e479af9eec694abec61ee5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fcbce729d0ccd6881e479af9eec694abec61ee5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fcbce729d0ccd6881e479af9eec694abec61ee5/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "451bdd23084ab3282aa438f8d2808ea091cc0758", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/451bdd23084ab3282aa438f8d2808ea091cc0758", "html_url": "https://github.com/Rust-GCC/gccrs/commit/451bdd23084ab3282aa438f8d2808ea091cc0758"}], "stats": {"total": 426, "additions": 398, "deletions": 28}, "files": [{"sha": "2b9464a3d6df82fca4a44c3071f110e0216a52a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8fcbce729d0ccd6881e479af9eec694abec61ee5", "patch": "@@ -1,3 +1,17 @@\n+2014-02-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/60092\n+\t* tree-ssa-ccp.c (surely_varying_stmt_p): Don't return true\n+\tif TYPE_ATTRIBUTES (gimple_call_fntype ()) contain\n+\tassume_aligned or alloc_align attributes.\n+\t(bit_value_assume_aligned): Add ATTR, PTRVAL and ALLOC_ALIGN\n+\targuments.  Handle also assume_aligned and alloc_align attributes.\n+\t(evaluate_stmt): Adjust bit_value_assume_aligned caller.\n+\tHandle calls to functions with assume_aligned or alloc_align\n+\tattributes.\n+\t* doc/extend.texi: Document assume_aligned and alloc_align\n+\tattributes.\n+\n 2014-02-08  Terry Guo  <terry.guo@arm.com>\n \n \t* doc/invoke.texi: Document ARM -march=armv7e-m."}, {"sha": "ba14b99da0745bece25cc2f7d3ad064cb9400cd2", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=8fcbce729d0ccd6881e479af9eec694abec61ee5", "patch": "@@ -1,3 +1,13 @@\n+2014-02-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/60092\n+\t* c-common.c (handle_alloc_size_attribute): Use tree_fits_uhwi_p\n+\tand tree_to_uhwi.\n+\t(handle_alloc_align_attribute, handle_assume_aligned_attribute): New\n+\tfunctions.\n+\t(c_common_attribute_table): Add alloc_align and assume_aligned\n+\tattributes.\n+\n 2014-02-06  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/60087"}, {"sha": "5cf285bc58272b6835e318dc43d1f5339712e62d", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 58, "deletions": 4, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=8fcbce729d0ccd6881e479af9eec694abec61ee5", "patch": "@@ -366,6 +366,8 @@ static tree handle_warn_unused_result_attribute (tree *, tree, tree, int,\n static tree handle_sentinel_attribute (tree *, tree, tree, int, bool *);\n static tree handle_type_generic_attribute (tree *, tree, tree, int, bool *);\n static tree handle_alloc_size_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_alloc_align_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_assume_aligned_attribute (tree *, tree, tree, int, bool *);\n static tree handle_target_attribute (tree *, tree, tree, int, bool *);\n static tree handle_optimize_attribute (tree *, tree, tree, int, bool *);\n static tree ignore_attribute (tree *, tree, tree, int, bool *);\n@@ -766,6 +768,10 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_omp_declare_simd_attribute, false },\n   { \"omp declare target\",     0, 0, true, false, false,\n \t\t\t      handle_omp_declare_target_attribute, false },\n+  { \"alloc_align\",\t      1, 1, false, true, true,\n+\t\t\t      handle_alloc_align_attribute, false },\n+  { \"assume_aligned\",\t      1, 2, false, true, true,\n+\t\t\t      handle_assume_aligned_attribute, false },\n   { NULL,                     0, 0, false, false, false, NULL, false }\n };\n \n@@ -8043,10 +8049,9 @@ handle_alloc_size_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n \t  && TREE_CODE (position) != FUNCTION_DECL)\n \tposition = default_conversion (position);\n \n-      if (TREE_CODE (position) != INTEGER_CST\n-\t  || TREE_INT_CST_HIGH (position)\n-\t  || TREE_INT_CST_LOW (position) < 1\n-\t  || TREE_INT_CST_LOW (position) > arg_count )\n+      if (!tree_fits_uhwi_p (position)\n+\t  || !arg_count\n+\t  || !IN_RANGE (tree_to_uhwi (position), 1, arg_count))\n \t{\n \t  warning (OPT_Wattributes,\n \t           \"alloc_size parameter outside range\");\n@@ -8057,6 +8062,55 @@ handle_alloc_size_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n   return NULL_TREE;\n }\n \n+/* Handle a \"alloc_align\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_alloc_align_attribute (tree *node, tree, tree args, int,\n+\t\t\t      bool *no_add_attrs)\n+{\n+  unsigned arg_count = type_num_arguments (*node);\n+  tree position = TREE_VALUE (args);\n+  if (position && TREE_CODE (position) != IDENTIFIER_NODE)\n+    position = default_conversion (position);\n+\n+  if (!tree_fits_uhwi_p (position)\n+      || !arg_count\n+      || !IN_RANGE (tree_to_uhwi (position), 1, arg_count))\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"alloc_align parameter outside range\");\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"assume_aligned\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_assume_aligned_attribute (tree *, tree, tree args, int,\n+\t\t\t\t bool *no_add_attrs)\n+{\n+  for (; args; args = TREE_CHAIN (args))\n+    {\n+      tree position = TREE_VALUE (args);\n+      if (position && TREE_CODE (position) != IDENTIFIER_NODE\n+\t  && TREE_CODE (position) != FUNCTION_DECL)\n+\tposition = default_conversion (position);\n+\n+      if (TREE_CODE (position) != INTEGER_CST)\n+\t{\n+\t  warning (OPT_Wattributes,\n+\t\t   \"assume_aligned parameter not integer constant\");\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"fn spec\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "a969fb4939c368f33c664833539de5ff30bf0908", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=8fcbce729d0ccd6881e479af9eec694abec61ee5", "patch": "@@ -2154,8 +2154,8 @@ The keyword @code{__attribute__} allows you to specify special\n attributes when making a declaration.  This keyword is followed by an\n attribute specification inside double parentheses.  The following\n attributes are currently defined for functions on all targets:\n-@code{aligned}, @code{alloc_size}, @code{noreturn},\n-@code{returns_twice}, @code{noinline}, @code{noclone},\n+@code{aligned}, @code{alloc_size}, @code{alloc_align}, @code{assume_aligned},\n+@code{noreturn}, @code{returns_twice}, @code{noinline}, @code{noclone},\n @code{always_inline}, @code{flatten}, @code{pure}, @code{const},\n @code{nothrow}, @code{sentinel}, @code{format}, @code{format_arg},\n @code{no_instrument_function}, @code{no_split_stack},\n@@ -2249,6 +2249,46 @@ declares that @code{my_calloc} returns memory of the size given by\n the product of parameter 1 and 2 and that @code{my_realloc} returns memory\n of the size given by parameter 2.\n \n+@item alloc_align\n+@cindex @code{alloc_align} attribute\n+The @code{alloc_align} attribute is used to tell the compiler that the\n+function return value points to memory, where the returned pointer minimum\n+alignment is given by one of the functions parameters.  GCC uses this\n+information to improve pointer alignment analysis.\n+\n+The function parameter denoting the allocated alignment is specified by\n+one integer argument, whose number is the argument of the attribute.\n+Argument numbering starts at one.\n+\n+For instance,\n+\n+@smallexample\n+void* my_memalign(size_t, size_t) __attribute__((alloc_align(1)))\n+@end smallexample\n+\n+@noindent\n+declares that @code{my_memalign} returns memory with minimum alignment\n+given by parameter 1.\n+\n+@item assume_aligned\n+@cindex @code{assume_aligned} attribute\n+The @code{assume_aligned} attribute is used to tell the compiler that the\n+function return value points to memory, where the returned pointer minimum\n+alignment is given by the first argument.\n+If the attribute has two arguments, the second argument is misalignment offset.\n+\n+For instance\n+\n+@smallexample\n+void* my_alloc1(size_t) __attribute__((assume_aligned(16)))\n+void* my_alloc2(size_t) __attribute__((assume_aligned(32, 8)))\n+@end smallexample\n+\n+@noindent\n+declares that @code{my_alloc1} returns 16-byte aligned pointer and\n+that @code{my_alloc2} returns a pointer whose value modulo 32 is equal\n+to 8.\n+\n @item always_inline\n @cindex @code{always_inline} function attribute\n Generally, functions are not inlined unless optimization is specified."}, {"sha": "274081191219eb6c53c27d3e7510b74d73b10a97", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8fcbce729d0ccd6881e479af9eec694abec61ee5", "patch": "@@ -1,3 +1,13 @@\n+2014-02-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/60092\n+\t* gcc.dg/attr-alloc_align-1.c: New test.\n+\t* gcc.dg/attr-alloc_align-2.c: New test.\n+\t* gcc.dg/attr-alloc_align-3.c: New test.\n+\t* gcc.dg/attr-assume_aligned-1.c: New test.\n+\t* gcc.dg/attr-assume_aligned-2.c: New test.\n+\t* gcc.dg/attr-assume_aligned-3.c: New test.\n+\n 2014-02-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/60077"}, {"sha": "45f5ec065e452c45059e2c859408353d8d9f972e", "filename": "gcc/testsuite/gcc.dg/attr-alloc_align-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-1.c?ref=8fcbce729d0ccd6881e479af9eec694abec61ee5", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3\" } */\n+\n+double *my_alloc1 (int len, int align) __attribute__((__alloc_align__ (2)));\n+double *my_alloc2 (int align, int len) __attribute__((alloc_align (1)));\n+\n+void\n+test1 (int len, int align)\n+{\n+  int i;\n+  double *__restrict o1 = my_alloc1 (len, 32);\n+  double *__restrict o2 = my_alloc1 (len, 32);\n+  double *__restrict o3 = my_alloc1 (len, 32);\n+  double *__restrict i1 = my_alloc1 (len, 32);\n+  double *__restrict i2 = my_alloc1 (len, align);\n+  for (i = 0; i < len; ++i)\n+    {\n+      o1[i] = i1[i] * i2[i];\n+      o2[i] = i1[i] + i2[i];\n+      o3[i] = i1[i] - i2[i];\n+    }\n+}\n+\n+void\n+test2 (int len, int align)\n+{\n+  int i;\n+  double *__restrict o1 = my_alloc2 (32, len);\n+  double *__restrict o2 = my_alloc2 (32, len);\n+  double *__restrict o3 = my_alloc2 (32, len);\n+  double *__restrict i1 = my_alloc2 (32, len);\n+  double *__restrict i2 = my_alloc2 (align, len);\n+  for (i = 0; i < len; ++i)\n+    {\n+      o1[i] = i1[i] * i2[i];\n+      o2[i] = i1[i] + i2[i];\n+      o3[i] = i1[i] - i2[i];\n+    }\n+}"}, {"sha": "3dc7a219839c18ce52339516acf2050e9ba3bd94", "filename": "gcc/testsuite/gcc.dg/attr-alloc_align-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-2.c?ref=8fcbce729d0ccd6881e479af9eec694abec61ee5", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+\n+int i;\n+void *f1 (int) __attribute__((alloc_align (1)));\n+void *f2 (int, int, int) __attribute__((alloc_align (3)));\n+void *f3 (void) __attribute__((alloc_align)); /* { dg-error \"wrong number of arguments specified\" } */\n+void *f4 (int, int) __attribute__((alloc_align (1, 2))); /* { dg-error \"wrong number of arguments specified\" } */\n+void *f5 (void) __attribute__((alloc_align (i))); /* { dg-warning \"outside range\" } */\n+void *f6 (int) __attribute__((alloc_align (0))); /* { dg-warning \"outside range\" } */\n+void *f7 (int) __attribute__((alloc_align (2))); /* { dg-warning \"outside range\" } */"}, {"sha": "2efe0c0684abfcaedf0959ed2335baeaaca31146", "filename": "gcc/testsuite/gcc.dg/attr-alloc_align-3.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-3.c?ref=8fcbce729d0ccd6881e479af9eec694abec61ee5", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+char *my_alloc1 (int len, int align) __attribute__((__alloc_align__ (2)));\n+char *my_alloc2 (int align, int len) __attribute__((alloc_align (1)));\n+\n+int\n+test1 (int len)\n+{\n+  int i;\n+  char *p = my_alloc1 (len, 32);\n+  return ((__INTPTR_TYPE__) p) & 31;\n+}\n+\n+int\n+test2 (int len)\n+{\n+  int i;\n+  char *p = my_alloc2 (32, len);\n+  return ((__INTPTR_TYPE__) p) & 31;\n+}\n+\n+int\n+test3 (int len)\n+{\n+  int i;\n+  char *p = my_alloc1 (len, 16);\n+  return ((__INTPTR_TYPE__) p) & 15;\n+}\n+\n+int\n+test4 (int len)\n+{\n+  int i;\n+  char *p = my_alloc2 (16, len);\n+  return ((__INTPTR_TYPE__) p) & 15;\n+}\n+\n+int\n+test5 (int len, int align)\n+{\n+  int i;\n+  char *p = my_alloc1 (len, align);\n+  return ((__INTPTR_TYPE__) p) & 15;\n+}\n+\n+int\n+test6 (int len, int align)\n+{\n+  int i;\n+  char *p = my_alloc2 (align, len);\n+  return ((__INTPTR_TYPE__) p) & 15;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"return 0\" 4 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "9a7d5a1ffe6ed851484dd84630622307da2db8b5", "filename": "gcc/testsuite/gcc.dg/attr-assume_aligned-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume_aligned-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume_aligned-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume_aligned-1.c?ref=8fcbce729d0ccd6881e479af9eec694abec61ee5", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3\" } */\n+\n+double *my_alloc1 (int len) __attribute__((__assume_aligned__ (16)));\n+double *my_alloc2 (int len) __attribute__((__assume_aligned__ (32, 16)));\n+\n+void\n+test1 (int len)\n+{\n+  int i;\n+  double *__restrict o1 = my_alloc1 (len);\n+  double *__restrict o2 = my_alloc1 (len);\n+  double *__restrict o3 = my_alloc1 (len);\n+  double *__restrict i1 = my_alloc1 (len);\n+  double *__restrict i2 = my_alloc1 (len);\n+  for (i = 0; i < len; ++i)\n+    {\n+      o1[i] = i1[i] * i2[i];\n+      o2[i] = i1[i] + i2[i];\n+      o3[i] = i1[i] - i2[i];\n+    }\n+}\n+\n+void\n+test2 (int len)\n+{\n+  int i;\n+  double *__restrict o1 = my_alloc2 (len);\n+  double *__restrict o2 = my_alloc2 (len);\n+  double *__restrict o3 = my_alloc2 (len);\n+  double *__restrict i1 = my_alloc2 (len);\n+  double *__restrict i2 = my_alloc2 (len);\n+  for (i = 0; i < len; ++i)\n+    {\n+      o1[i] = i1[i] * i2[i];\n+      o2[i] = i1[i] + i2[i];\n+      o3[i] = i1[i] - i2[i];\n+    }\n+}"}, {"sha": "9ab558945b374ffdf0bcc3c20576419229e96ade", "filename": "gcc/testsuite/gcc.dg/attr-assume_aligned-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume_aligned-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume_aligned-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume_aligned-2.c?ref=8fcbce729d0ccd6881e479af9eec694abec61ee5", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+\n+int i;\n+void *f1 (void) __attribute__((assume_aligned (32)));\n+void *f2 (void) __attribute__((assume_aligned (16, 4)));\n+void *f3 (void) __attribute__((assume_aligned)); /* { dg-error \"wrong number of arguments specified\" } */\n+void *f4 (void) __attribute__((assume_aligned (32, 16, 8))); /* { dg-error \"wrong number of arguments specified\" } */\n+void *f5 (void) __attribute__((assume_aligned (i))); /* { dg-warning \"integer constant\" } */"}, {"sha": "3731aac50eae4b3bf921bd1bf32b9c4afab40388", "filename": "gcc/testsuite/gcc.dg/attr-assume_aligned-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume_aligned-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume_aligned-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume_aligned-3.c?ref=8fcbce729d0ccd6881e479af9eec694abec61ee5", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+char *my_alloc1 (int len) __attribute__((__assume_aligned__ (32)));\n+char *my_alloc2 (int len) __attribute__((assume_aligned (32, 4)));\n+\n+int\n+test1 (int len)\n+{\n+  int i;\n+  char *p = my_alloc1 (len);\n+  return ((__INTPTR_TYPE__) p) & 31;\n+}\n+\n+int\n+test2 (int len)\n+{\n+  int i;\n+  char *p = my_alloc2 (len);\n+  return (((__INTPTR_TYPE__) p) & 31) != 4;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"return 0\" 2 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "eeefeaf07240fdbbb345c04365451136dfa6253c", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 88, "deletions": 22, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fcbce729d0ccd6881e479af9eec694abec61ee5/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=8fcbce729d0ccd6881e479af9eec694abec61ee5", "patch": "@@ -738,13 +738,18 @@ surely_varying_stmt_p (gimple stmt)\n     return true;\n \n   /* If it is a call and does not return a value or is not a\n-     builtin and not an indirect call, it is varying.  */\n+     builtin and not an indirect call or a call to function with\n+     assume_aligned/alloc_align attribute, it is varying.  */\n   if (is_gimple_call (stmt))\n     {\n-      tree fndecl;\n+      tree fndecl, fntype = gimple_call_fntype (stmt);\n       if (!gimple_call_lhs (stmt)\n \t  || ((fndecl = gimple_call_fndecl (stmt)) != NULL_TREE\n-\t      && !DECL_BUILT_IN (fndecl)))\n+\t      && !DECL_BUILT_IN (fndecl)\n+\t      && !lookup_attribute (\"assume_aligned\",\n+\t\t\t\t    TYPE_ATTRIBUTES (fntype))\n+\t      && !lookup_attribute (\"alloc_align\",\n+\t\t\t\t    TYPE_ATTRIBUTES (fntype))))\n \treturn true;\n     }\n \n@@ -1476,40 +1481,86 @@ bit_value_binop (enum tree_code code, tree type, tree rhs1, tree rhs2)\n   return val;\n }\n \n-/* Return the propagation value when applying __builtin_assume_aligned to\n-   its arguments.  */\n+/* Return the propagation value for __builtin_assume_aligned\n+   and functions with assume_aligned or alloc_aligned attribute.\n+   For __builtin_assume_aligned, ATTR is NULL_TREE,\n+   for assume_aligned attribute ATTR is non-NULL and ALLOC_ALIGNED\n+   is false, for alloc_aligned attribute ATTR is non-NULL and\n+   ALLOC_ALIGNED is true.  */\n \n static prop_value_t\n-bit_value_assume_aligned (gimple stmt)\n+bit_value_assume_aligned (gimple stmt, tree attr, prop_value_t ptrval,\n+\t\t\t  bool alloc_aligned)\n {\n-  tree ptr = gimple_call_arg (stmt, 0), align, misalign = NULL_TREE;\n-  tree type = TREE_TYPE (ptr);\n+  tree align, misalign = NULL_TREE, type;\n   unsigned HOST_WIDE_INT aligni, misaligni = 0;\n-  prop_value_t ptrval = get_value_for_expr (ptr, true);\n   prop_value_t alignval;\n   double_int value, mask;\n   prop_value_t val;\n+\n+  if (attr == NULL_TREE)\n+    {\n+      tree ptr = gimple_call_arg (stmt, 0);\n+      type = TREE_TYPE (ptr);\n+      ptrval = get_value_for_expr (ptr, true);\n+    }\n+  else\n+    {\n+      tree lhs = gimple_call_lhs (stmt);\n+      type = TREE_TYPE (lhs);\n+    }\n+\n   if (ptrval.lattice_val == UNDEFINED)\n     return ptrval;\n   gcc_assert ((ptrval.lattice_val == CONSTANT\n \t       && TREE_CODE (ptrval.value) == INTEGER_CST)\n \t      || ptrval.mask.is_minus_one ());\n-  align = gimple_call_arg (stmt, 1);\n-  if (!tree_fits_uhwi_p (align))\n-    return ptrval;\n-  aligni = tree_to_uhwi (align);\n-  if (aligni <= 1\n-      || (aligni & (aligni - 1)) != 0)\n-    return ptrval;\n-  if (gimple_call_num_args (stmt) > 2)\n+  if (attr == NULL_TREE)\n     {\n-      misalign = gimple_call_arg (stmt, 2);\n-      if (!tree_fits_uhwi_p (misalign))\n+      /* Get aligni and misaligni from __builtin_assume_aligned.  */\n+      align = gimple_call_arg (stmt, 1);\n+      if (!tree_fits_uhwi_p (align))\n \treturn ptrval;\n-      misaligni = tree_to_uhwi (misalign);\n-      if (misaligni >= aligni)\n+      aligni = tree_to_uhwi (align);\n+      if (gimple_call_num_args (stmt) > 2)\n+\t{\n+\t  misalign = gimple_call_arg (stmt, 2);\n+\t  if (!tree_fits_uhwi_p (misalign))\n+\t    return ptrval;\n+\t  misaligni = tree_to_uhwi (misalign);\n+\t}\n+    }\n+  else\n+    {\n+      /* Get aligni and misaligni from assume_aligned or\n+\t alloc_align attributes.  */\n+      if (TREE_VALUE (attr) == NULL_TREE)\n+\treturn ptrval;\n+      attr = TREE_VALUE (attr);\n+      align = TREE_VALUE (attr);\n+      if (!tree_fits_uhwi_p (align))\n \treturn ptrval;\n+      aligni = tree_to_uhwi (align);\n+      if (alloc_aligned)\n+\t{\n+\t  if (aligni == 0 || aligni > gimple_call_num_args (stmt))\n+\t    return ptrval;\n+\t  align = gimple_call_arg (stmt, aligni - 1);\n+\t  if (!tree_fits_uhwi_p (align))\n+\t    return ptrval;\n+\t  aligni = tree_to_uhwi (align);\n+\t}\n+      else if (TREE_CHAIN (attr) && TREE_VALUE (TREE_CHAIN (attr)))\n+\t{\n+\t  misalign = TREE_VALUE (TREE_CHAIN (attr));\n+\t  if (!tree_fits_uhwi_p (misalign))\n+\t    return ptrval;\n+\t  misaligni = tree_to_uhwi (misalign);\n+\t}\n     }\n+  if (aligni <= 1 || (aligni & (aligni - 1)) != 0 || misaligni >= aligni)\n+    return ptrval;\n+\n   align = build_int_cst_type (type, -aligni);\n   alignval = get_value_for_expr (align, true);\n   bit_value_binop_1 (BIT_AND_EXPR, type, &value, &mask,\n@@ -1708,12 +1759,27 @@ evaluate_stmt (gimple stmt)\n \t      break;\n \n \t    case BUILT_IN_ASSUME_ALIGNED:\n-\t      val = bit_value_assume_aligned (stmt);\n+\t      val = bit_value_assume_aligned (stmt, NULL_TREE, val, false);\n \t      break;\n \n \t    default:;\n \t    }\n \t}\n+      if (is_gimple_call (stmt) && gimple_call_lhs (stmt))\n+\t{\n+\t  tree fntype = gimple_call_fntype (stmt);\n+\t  if (fntype)\n+\t    {\n+\t      tree attrs = lookup_attribute (\"assume_aligned\",\n+\t\t\t\t\t     TYPE_ATTRIBUTES (fntype));\n+\t      if (attrs)\n+\t\tval = bit_value_assume_aligned (stmt, attrs, val, false);\n+\t      attrs = lookup_attribute (\"alloc_align\",\n+\t\t\t\t\tTYPE_ATTRIBUTES (fntype));\n+\t      if (attrs)\n+\t\tval = bit_value_assume_aligned (stmt, attrs, val, true);\n+\t    }\n+\t}\n       is_constant = (val.lattice_val == CONSTANT);\n     }\n "}]}