{"sha": "c4ce68534a192e1b452b70dee5a4bab71f6729e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRjZTY4NTM0YTE5MmUxYjQ1MmI3MGRlZTVhNGJhYjcxZjY3MjllNA==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-03-08T00:12:21Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-03-08T00:12:21Z"}, "message": "sparc.h (MASK_LIVE_G0,TARGET_LIVE_G0): Define.\n\n\t* sparc/sparc.h (MASK_LIVE_G0,TARGET_LIVE_G0): Define.\n\t(TARGET_SWITCHES): Add live-g0.\n\t(FIRST_PSEUDO_REGISTER): Add 1 for %icc (now 101).\n\t(FIXED_REGISTERS,CALL_USED_REGISTERS): Update.\n\t(FIXED_REGISTERS): %g0 is fixed by default.\n\t(SPARC_{FIRST,LAST}_V9_FCC_REG): Define.\n\t(SPARC_{ICC,FCC}_REG): Define.\n\t(CONDITIONAL_REGISTER_USAGE): Don't fix %fcc0 if v8.\n\t(REG_CLASS_CONTENTS): Reg 0 is an int reg, reg 100 is %icc.\n\t(REGNO_REG_CLASS): Rewrite to use global `sparc_regno_reg_class'.\n\t(REG_ALLOC_ORDER,REG_LEAF_ALLOC_ORDER,LEAF_REGISTERS): Add %icc.\n\t(REG_CLASS_FROM_LETTER): Handle 'c' for FPCC_REGS in non-v9 case.\n\t(REGNO_OK_FOR_{BASE,INDEX}_P): Treat %g0 as a normal reg.\n\t(REG_OK_FOR_{BASE,INDEX}_P,EXTRA_CONSTRAINT): Likewise.\n\t(REGISTER_NAMES): Add %icc.\n\t(ADDITIONAL_REGISTER_NAMES): Use SPARC_ICC_REG.\n\t* sparc/sparc.c (leaf_reg_remap): Add %icc=100.\n\t(reg_or_0_operand): Don't allow 0 if TARGET_LIVE_G0.\n\t(fcc_reg_operand): Renamed from ccfp_reg_operand.\n\tUse SPARC_FCC_REG.  Don't treat reg 0 as an fcc reg.  Don't match\n\tmodes if `mode' argument is VOIDmode.\n\t(icc_or_fcc_reg_operand): New function.\n\t(gen_compare_reg): Use SPARC_FCC_REG for v8 fp compares.\n\tUse SPARC_ICC_REG for int compares.\n\t(eligible_for_epilogue_delay): Don't allow anything if TARGET_LIVE_G0.\n\tDelete unnecessary test for %g0.\n\t(emit_move_sequence): Don't emit (set (mem) (const_int 0)) if\n\tTARGET_LIVE_G0.\n\t(output_scc_insn): Label moved to operand 3.  Condition code reg\n\tmoved to operand 2.\n\t(sparc_mode_class): Enum C_MODE renamed to CC_MODE.\n\t(hard_32bit_mode_classes): Set reg 0 to S_MODES.  Add entry for %icc.\n\t(hard_64bit_mode_classes): Set reg 0 to D_MODES.  Add entry for %icc.\n\t(sparc_regno_reg_class): New global.\n\t(sparc_init_modes): Initialize it.\n\t(output_cbranch): Delete fp_cond_reg argument.\n\t(print_operand, MEM op): Don't print \"%g0+\" if TARGET_SPARCLET.\n\t(sparc_flat_eligible_for_epilogue_delay): Don't allow anything if\n\tTARGET_LIVE_G0.\n\t* sparc/sparc.md (live_g0): New attribute.\n\t(*): Integer condition code register is now reg 100.\n\tUse SPARC_ICC_REG instead of hardcoding reg 100 where possible.\n\tNon-v9 floating point condition code register is now reg 96.\n\t(*cmp{sf,df,tf}_{fpe,fp}_sp{32,64}): Combine v9/non-v9 cases.\n\t(*{normal,inverted}_{,fp,fpe}_branch): Update call to output_cbranch.\n\t(*mov{qi,hi,si}_insn): Don't use if TARGET_LIVE_G0.\n\t(*mov{qi,hi,si}_insn_liveg0): New patterns.\n\t(*mov{si,di,sf,df,tf}_ccfp{,e}_sp64): ccfp_reg_operand renamed to\n\tfcc_reg_operand.\n\t(*negdi2_sp32,negsi2,one_cmplsi2,ffssi2): Ensure %%g0 is 0 if\n\tTARGET_LIVE_G0.\n\t(*one_cmpldi2_sp32): Move operand 1 to rs1 and use 0 as rs2.\n\t(patterns that use %g0 in rs2): Use 0 immediate value instead.\n\t(patterns that read %g0): Don't use if TARGET_LIVE_G0.\n\nFrom-SVN: r11494", "tree": {"sha": "3a3d48d7e2df5b02343b034e24da534243bb5496", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a3d48d7e2df5b02343b034e24da534243bb5496"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4ce68534a192e1b452b70dee5a4bab71f6729e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ce68534a192e1b452b70dee5a4bab71f6729e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4ce68534a192e1b452b70dee5a4bab71f6729e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ce68534a192e1b452b70dee5a4bab71f6729e4/comments", "author": null, "committer": null, "parents": [{"sha": "05066d29ea8d6debe362cd48b1921a78078dd185", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05066d29ea8d6debe362cd48b1921a78078dd185", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05066d29ea8d6debe362cd48b1921a78078dd185"}], "stats": {"total": 1014, "additions": 595, "deletions": 419}, "files": [{"sha": "dc6bcbfebcd7a33f337c8587ef65b82c2e13116d", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 114, "deletions": 49, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ce68534a192e1b452b70dee5a4bab71f6729e4/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ce68534a192e1b452b70dee5a4bab71f6729e4/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=c4ce68534a192e1b452b70dee5a4bab71f6729e4", "patch": "@@ -99,7 +99,7 @@ char leaf_reg_remap[] =\n   72, 73, 74, 75, 76, 77, 78, 79,\n   80, 81, 82, 83, 84, 85, 86, 87,\n   88, 89, 90, 91, 92, 93, 94, 95,\n-  96, 97, 98, 99};\n+  96, 97, 98, 99, 100};\n \n #endif\n \n@@ -268,13 +268,19 @@ v9_regcmp_p (code)\n /* Operand constraints.  */\n \n /* Return non-zero only if OP is a register of mode MODE,\n-   or const0_rtx.  */\n+   or const0_rtx.  Don't allow const0_rtx if TARGET_LIVE_G0 because\n+   %g0 may contain anything.  */\n+\n int\n reg_or_0_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (op == const0_rtx || register_operand (op, mode))\n+  if (register_operand (op, mode))\n+    return 1;\n+  if (TARGET_LIVE_G0)\n+    return 0;\n+  if (op == const0_rtx)\n     return 1;\n   if (GET_MODE (op) == VOIDmode && GET_CODE (op) == CONST_DOUBLE\n       && CONST_DOUBLE_HIGH (op) == 0\n@@ -288,6 +294,7 @@ reg_or_0_operand (op, mode)\n }\n \n /* Nonzero if OP is a floating point value with value 0.0.  */\n+\n int\n fp_zero_operand (op)\n      rtx op;\n@@ -312,26 +319,38 @@ intreg_operand (op, mode)\n /* Nonzero if OP is a floating point condition code register.  */\n \n int\n-ccfp_reg_operand (op, mode)\n+fcc_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n   /* This can happen when recog is called from combine.  Op may be a MEM.\n      Fail instead of calling abort in this case.  */\n-  if (GET_CODE (op) != REG || REGNO (op) == 0)\n+  if (GET_CODE (op) != REG)\n     return 0;\n-  if (GET_MODE (op) != mode)\n+  if (mode != VOIDmode && mode != GET_MODE (op))\n     return 0;\n \n-#if 0\t/* ??? ==> 1 when %fcc1-3 are pseudos first.  See gen_compare_reg().  */\n+#if 0\t/* ??? ==> 1 when %fcc0-3 are pseudos first.  See gen_compare_reg().  */\n   if (reg_renumber == 0)\n     return REGNO (op) >= FIRST_PSEUDO_REGISTER;\n   return REGNO_OK_FOR_CCFP_P (REGNO (op));\n #else\n-  return (unsigned) REGNO (op) - 96 < 4;\n+  return (unsigned) REGNO (op) - SPARC_FIRST_V9_FCC_REG < 4;\n #endif\n }\n \n+/* Nonzero if OP is an integer or floating point condition code register.  */\n+\n+int\n+icc_or_fcc_reg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == REG && REGNO (op) == SPARC_ICC_REG)\n+    return 1;\n+  return fcc_reg_operand (op, mode);\n+}\n+\n /* Nonzero if OP can appear as the dest of a RESTORE insn.  */\n int\n restore_operand (op, mode)\n@@ -855,7 +874,7 @@ gen_compare_reg (code, x, y)\n   rtx cc_reg;\n \n   /* ??? We don't have movcc patterns so we cannot generate pseudo regs for the\n-     fpcc regs (cse can't tell they're really call clobbered regs and will\n+     fcc regs (cse can't tell they're really call clobbered regs and will\n      remove a duplicate comparison even if there is an intervening function\n      call - it will then try to reload the cc reg via an int reg which is why\n      we need the movcc patterns).  It is possible to provide the movcc\n@@ -875,8 +894,8 @@ gen_compare_reg (code, x, y)\n     {\n       int reg;\n       /* We cycle through the registers to ensure they're all exercised.  */\n-      static int next_fpcc_reg = 0;\n-      /* Previous x,y for each fpcc reg.  */\n+      static int next_fcc_reg = 0;\n+      /* Previous x,y for each fcc reg.  */\n       static rtx prev_args[4][2];\n \n       /* Scan prev_args for x,y.  */\n@@ -885,18 +904,20 @@ gen_compare_reg (code, x, y)\n \t  break;\n       if (reg == 4)\n \t{\n-\t  reg = next_fpcc_reg;\n+\t  reg = next_fcc_reg;\n \t  prev_args[reg][0] = x;\n \t  prev_args[reg][1] = y;\n-\t  next_fpcc_reg = (next_fpcc_reg + 1) & 3;\n+\t  next_fcc_reg = (next_fcc_reg + 1) & 3;\n \t}\n-      cc_reg = gen_rtx (REG, mode, reg + 96);\n+      cc_reg = gen_rtx (REG, mode, reg + SPARC_FIRST_V9_FCC_REG);\n     }\n #else\n     cc_reg = gen_reg_rtx (mode);\n #endif /* ! experiment */\n+  else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+    cc_reg = gen_rtx (REG, mode, SPARC_FCC_REG);\n   else\n-    cc_reg = gen_rtx (REG, mode, 0);\n+    cc_reg = gen_rtx (REG, mode, SPARC_ICC_REG);\n \n   emit_insn (gen_rtx (SET, VOIDmode, cc_reg,\n \t\t      gen_rtx (COMPARE, mode, x, y)));\n@@ -1062,6 +1083,14 @@ eligible_for_epilogue_delay (trial, slot)\n   if (get_attr_length (trial) != 1)\n     return 0;\n \n+  pat = PATTERN (trial);\n+\n+  /* If %g0 is live, there are lots of things we can't handle.\n+     Rather than trying to find them all now, let's punt and only\n+     optimize things as necessary.  */\n+  if (TARGET_LIVE_G0)\n+    return 0;\n+\n   /* In the case of a true leaf function, anything can go into the delay slot.\n      A delay slot only exists however if the frame size is zero, otherwise\n      we will put an insn to adjust the stack after the return.  */\n@@ -1074,9 +1103,7 @@ eligible_for_epilogue_delay (trial, slot)\n \n   /* Otherwise, only operations which can be done in tandem with\n      a `restore' insn can go into the delay slot.  */\n-  pat = PATTERN (trial);\n   if (GET_CODE (SET_DEST (pat)) != REG\n-      || REGNO (SET_DEST (pat)) == 0\n       || REGNO (SET_DEST (pat)) >= 32\n       || REGNO (SET_DEST (pat)) < 24)\n     return 0;\n@@ -1442,7 +1469,8 @@ emit_move_sequence (operands, mode)\n     }\n   else if (GET_CODE (operand0) == MEM)\n     {\n-      if (register_operand (operand1, mode) || operand1 == const0_rtx)\n+      if (register_operand (operand1, mode)\n+\t  || (operand1 == const0_rtx && ! TARGET_LIVE_G0))\n \t{\n \t  /* Run this case quickly.  */\n \t  emit_insn (gen_rtx (SET, VOIDmode, operand0, operand1));\n@@ -2575,7 +2603,8 @@ output_scc_insn (operands, insn)\n \n   LABEL_NUSES (label) += 1;\n \n-  operands[2] = label;\n+  /* operands[3] is an unused slot.  */\n+  operands[3] = label;\n \n   /* If we are in a delay slot, assume it is the delay slot of an fpcc\n      insn since our type isn't allowed anywhere else.  */\n@@ -2598,17 +2627,17 @@ output_scc_insn (operands, insn)\n   if (final_sequence)\n     {\n       strcpy (string, \"mov 0,%0\\n\\t\");\n-      strcat (string, output_cbranch (operands[1], 0, 2, 0, 1, 0));\n+      strcat (string, output_cbranch (operands[2], 3, 0, 1, 0));\n       strcat (string, \"\\n\\tmov 1,%0\");\n     }\n   else\n     {\n-      strcpy (string, output_cbranch (operands[1], 0, 2, 0, 1, 0));\n+      strcpy (string, output_cbranch (operands[2], 3, 0, 1, 0));\n       strcat (string, \"\\n\\tmov 1,%0\\n\\tmov 0,%0\");\n     }\n \n   if (need_label)\n-    strcat (string, \"\\n%l2:\");\n+    strcat (string, \"\\n%l3:\");\n \n   return string;\n }\n@@ -2623,15 +2652,11 @@ output_scc_insn (operands, insn)\n    mapped into one sparc_mode_class mode.  */\n \n enum sparc_mode_class {\n-  C_MODE, CCFP_MODE,\n   S_MODE, D_MODE, T_MODE, O_MODE,\n-  SF_MODE, DF_MODE, TF_MODE, OF_MODE\n+  SF_MODE, DF_MODE, TF_MODE, OF_MODE,\n+  CC_MODE, CCFP_MODE\n };\n \n-/* Modes for condition codes.  */\n-#define C_MODES ((1 << (int) C_MODE) | (1 << (int) CCFP_MODE))\n-#define CCFP_MODES (1 << (int) CCFP_MODE)\n-\n /* Modes for single-word and smaller quantities.  */\n #define S_MODES ((1 << (int) S_MODE) | (1 << (int) SF_MODE))\n \n@@ -2653,7 +2678,8 @@ enum sparc_mode_class {\n #define DF_MODES64 (SF_MODES | DF_MODE /* | D_MODE*/)\n \n /* Modes for double-float only quantities.  */\n-/* ??? Sparc64 fp regs cannot hold DImode values.  */\n+/* ??? Sparc64 fp regs cannot hold DImode values.\n+   See fix_truncsfdi2.  */\n #define DF_ONLY_MODES ((1 << (int) DF_MODE) /*| (1 << (int) D_MODE)*/)\n \n /* Modes for double-float and larger quantities.  */\n@@ -2665,20 +2691,25 @@ enum sparc_mode_class {\n /* Modes for quad-float and smaller quantities.  */\n #define TF_MODES (DF_MODES | TF_ONLY_MODES)\n \n-/* ??? Sparc64 fp regs cannot hold DImode values.  */\n+/* ??? Sparc64 fp regs cannot hold DImode values.\n+   See fix_truncsfdi2.  */\n #define TF_MODES64 (DF_MODES64 | TF_ONLY_MODES)\n \n+/* Modes for condition codes.  */\n+#define CC_MODES (1 << (int) CC_MODE)\n+#define CCFP_MODES (1 << (int) CCFP_MODE)\n+\n /* Value is 1 if register/mode pair is acceptable on sparc.\n    The funny mixture of D and T modes is because integer operations\n    do not specially operate on tetra quantities, so non-quad-aligned\n    registers can hold quadword quantities (except %o4 and %i4 because\n-   they cross fixed registers.  */\n+   they cross fixed registers).  */\n \n /* This points to either the 32 bit or the 64 bit version.  */\n int *hard_regno_mode_classes;\n \n static int hard_32bit_mode_classes[] = {\n-  C_MODES, S_MODES, T_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n+  S_MODES, S_MODES, T_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n   T_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES, D_MODES, S_MODES,\n   T_MODES, S_MODES, T_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n   T_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES, D_MODES, S_MODES,\n@@ -2696,11 +2727,14 @@ static int hard_32bit_mode_classes[] = {\n   DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n \n   /* %fcc[0123] */\n-  CCFP_MODE, CCFP_MODE, CCFP_MODE, CCFP_MODE\n+  CCFP_MODES, CCFP_MODES, CCFP_MODES, CCFP_MODES,\n+\n+  /* %icc */\n+  CC_MODES\n };\n \n static int hard_64bit_mode_classes[] = {\n-  C_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES,\n+  D_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES,\n   T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES,\n   T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES,\n   T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES,\n@@ -2718,11 +2752,16 @@ static int hard_64bit_mode_classes[] = {\n   DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n \n   /* %fcc[0123] */\n-  CCFP_MODE, CCFP_MODE, CCFP_MODE, CCFP_MODE\n+  CCFP_MODES, CCFP_MODES, CCFP_MODES, CCFP_MODES,\n+\n+  /* %icc */\n+  CC_MODES\n };\n \n int sparc_mode_class [NUM_MACHINE_MODES];\n \n+enum reg_class sparc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n+\n static void\n sparc_init_modes ()\n {\n@@ -2767,7 +2806,7 @@ sparc_init_modes ()\n \t    sparc_mode_class[i] = 1 << (int) CCFP_MODE;\n \t  else if (i == (int) CCmode || i == (int) CC_NOOVmode\n \t\t   || i == (int) CCXmode || i == (int) CCX_NOOVmode)\n-\t    sparc_mode_class[i] = 1 << (int) C_MODE;\n+\t    sparc_mode_class[i] = 1 << (int) CC_MODE;\n \t  else\n \t    sparc_mode_class[i] = 0;\n \t  break;\n@@ -2778,6 +2817,21 @@ sparc_init_modes ()\n     hard_regno_mode_classes = hard_64bit_mode_classes;\n   else\n     hard_regno_mode_classes = hard_32bit_mode_classes;\n+\n+  /* Initialize the array used by REGNO_REG_CLASS.  */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (i < 32)\n+\tsparc_regno_reg_class[i] = GENERAL_REGS;\n+      else if (i < 64)\n+\tsparc_regno_reg_class[i] = FP_REGS;\n+      else if (i < 96)\n+\tsparc_regno_reg_class[i] = EXTRA_FP_REGS;\n+      else if (i < 100)\n+\tsparc_regno_reg_class[i] = FPCC_REGS;\n+      else\n+\tsparc_regno_reg_class[i] = NO_REGS;\n+    }\n }\n \f\n /* Save non call used registers from LOW to HIGH at BASE+OFFSET.\n@@ -3320,11 +3374,9 @@ sparc_builtin_saveregs (arglist)\n #endif /* ! SPARC_ARCH64 */\n \f\n /* Return the string to output a conditional branch to LABEL, which is\n-   the operand number of the label.  OP is the conditional expression.  The\n-   mode of register 0 says what kind of comparison we made.\n-\n-   FP_COND_REG indicates which fp condition code register to use if this is\n-   a floating point branch.\n+   the operand number of the label.  OP is the conditional expression.\n+   XEXP (OP, 0) is assumed to be a condition code register (integer or\n+   floating point) and its mode specifies what kind of comparison we made.\n \n    REVERSED is non-zero if we should reverse the sense of the comparison.\n \n@@ -3333,14 +3385,15 @@ sparc_builtin_saveregs (arglist)\n    NOOP is non-zero if we have to follow this branch by a noop.  */\n \n char *\n-output_cbranch (op, fp_cond_reg, label, reversed, annul, noop)\n-     rtx op, fp_cond_reg;\n+output_cbranch (op, label, reversed, annul, noop)\n+     rtx op;\n      int label;\n      int reversed, annul, noop;\n {\n   static char string[20];\n   enum rtx_code code = GET_CODE (op);\n-  enum machine_mode mode = GET_MODE (XEXP (op, 0));\n+  rtx cc_reg = XEXP (op, 0);\n+  enum machine_mode mode = GET_MODE (cc_reg);\n   static char v8_labelno[] = \" %lX\";\n   static char v9_icc_labelno[] = \" %%icc,%lX\";\n   static char v9_xcc_labelno[] = \" %%xcc,%lX\";\n@@ -3467,7 +3520,7 @@ output_cbranch (op, fp_cond_reg, label, reversed, annul, noop)\n \t  labeloff = 10;\n \t  labelno = v9_fcc_labelno;\n \t  /* Set the char indicating the number of the fcc reg to use.  */\n-\t  labelno[6] = REGNO (fp_cond_reg) - 96 + '0';\n+\t  labelno[6] = REGNO (cc_reg) - SPARC_FIRST_V9_FCC_REG + '0';\n \t}\n       else if (mode == CCXmode || mode == CCX_NOOVmode)\n \tlabelno = v9_xcc_labelno;\n@@ -3930,8 +3983,9 @@ print_operand (file, x, code)\n   else if (GET_CODE (x) == MEM)\n     {\n       fputc ('[', file);\n-      if (CONSTANT_P (XEXP (x, 0)))\n \t/* Poor Sun assembler doesn't understand absolute addressing.  */\n+      if (CONSTANT_P (XEXP (x, 0))\n+\t  && ! TARGET_LIVE_G0)\n \tfputs (\"%g0+\", file);\n       output_address (XEXP (x, 0));\n       fputc (']', file);\n@@ -4847,10 +4901,21 @@ sparc_flat_eligible_for_epilogue_delay (trial, slot)\n      rtx trial;\n      int slot;\n {\n-  if (get_attr_length (trial) == 1\n-      && ! reg_mentioned_p (stack_pointer_rtx, PATTERN (trial))\n-      && ! reg_mentioned_p (frame_pointer_rtx, PATTERN (trial)))\n+  rtx pat = PATTERN (trial);\n+\n+  if (get_attr_length (trial) != 1)\n+    return 0;\n+\n+  /* If %g0 is live, there are lots of things we can't handle.\n+     Rather than trying to find them all now, let's punt and only\n+     optimize things as necessary.  */\n+  if (TARGET_LIVE_G0)\n+    return 0;\n+\n+  if (! reg_mentioned_p (stack_pointer_rtx, pat)\n+      && ! reg_mentioned_p (frame_pointer_rtx, pat))\n     return 1;\n+\n   return 0;\n }\n \f"}, {"sha": "b634957c81d5c060be8c7129b610c94ea2d32f4f", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 61, "deletions": 43, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ce68534a192e1b452b70dee5a4bab71f6729e4/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ce68534a192e1b452b70dee5a4bab71f6729e4/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=c4ce68534a192e1b452b70dee5a4bab71f6729e4", "patch": "@@ -369,6 +369,13 @@ extern int target_flags;\n #define MASK_STACK_BIAS 0x80000\n #define TARGET_STACK_BIAS (target_flags & MASK_STACK_BIAS)\n \n+/* Non-zero means %g0 is a normal register.\n+   We still clobber it as necessary, but we can't rely on it always having\n+   a zero value.\n+   We don't bother to support this in true 64 bit mode.  */\n+#define MASK_LIVE_G0 0x100000\n+#define TARGET_LIVE_G0 (target_flags & MASK_LIVE_G0)\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n@@ -392,6 +399,7 @@ extern int target_flags;\n     {\"no-app-regs\", -MASK_APP_REGS},\t\\\n     {\"hard-quad-float\", MASK_HARD_QUAD}, \\\n     {\"soft-quad-float\", -MASK_HARD_QUAD}, \\\n+    {\"live-g0\", MASK_LIVE_G0},\t\t\\\n     /* ??? These are coerced to -mcpu=.  Delete in 2.9.  */ \\\n     {\"cypress\", 0},\t\t\t\\\n     {\"sparclite\", 0},\t\t\t\\\n@@ -673,18 +681,23 @@ extern struct sparc_cpu_select sparc_select[];\n    accessible.  We still account for them to simplify register computations\n    (eg: in CLASS_MAX_NREGS).  There are also 4 fp condition code registers, so\n    32+32+32+4 == 100.\n-   Register 0 is used as the integer condition code register.  */\n+   Register 100 is used as the integer condition code register.  */\n \n-#define FIRST_PSEUDO_REGISTER 100\n+#define FIRST_PSEUDO_REGISTER 101\n \n /* Additional V9 fp regs.  */\n #define SPARC_FIRST_V9_FP_REG 64\n-#define SPARC_LAST_V9_FP_REG  99\n+#define SPARC_LAST_V9_FP_REG  95\n+/* V9 %fcc[0123].  V8 uses (figuratively) %fcc0.  */\n+#define SPARC_FIRST_V9_FCC_REG 96\n+#define SPARC_LAST_V9_FCC_REG  99\n+/* V8 fcc reg.  */\n+#define SPARC_FCC_REG 96\n+/* Integer CC reg.  We don't distinguish %icc from %xcc.  */\n+#define SPARC_ICC_REG 100\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n-   g0 is used for the condition code and not to represent %g0, which is\n-   hardwired to 0, so reg 0 is *not* fixed.\n    On non-v9 systems:\n    g1 is free to use as temporary.\n    g2-g4 are reserved for applications.  Gcc normally uses them as\n@@ -705,7 +718,7 @@ extern struct sparc_cpu_select sparc_select[];\n */\n \n #define FIXED_REGISTERS  \\\n- {0, 0, 0, 0, 0, 0, 1, 1,\t\\\n+ {1, 0, 0, 0, 0, 0, 1, 1,\t\\\n   0, 0, 0, 0, 0, 0, 1, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 1, 1,\t\\\n@@ -720,7 +733,7 @@ extern struct sparc_cpu_select sparc_select[];\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n \t\t\t\t\\\n-  0, 0, 0, 0}\n+  0, 0, 0, 0, 0}\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -745,10 +758,10 @@ extern struct sparc_cpu_select sparc_select[];\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n \t\t\t\t\\\n-  1, 1, 1, 1}\n+  1, 1, 1, 1, 1}\n \n-/* If !TARGET_FPU, then make the fp registers fixed so that they won't\n-   be allocated.  On v9, also make the fp cc regs fixed.  */\n+/* If !TARGET_FPU, then make the fp registers and fp cc regs fixed so that\n+   they won't be allocated.  */\n \n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\\\n@@ -772,11 +785,16 @@ do\t\t\t\t\t\t\t\t\\\n \t     regno <= SPARC_LAST_V9_FP_REG;\t\t\t\\\n \t     regno++)\t\t\t\t\t\t\\\n \t  fixed_regs[regno] = 1;\t\t\t\t\\\n+\t/* %fcc0 is used by v8 and v9.  */\t\t\t\\\n+\tfor (regno = SPARC_FIRST_V9_FCC_REG + 1;\t\t\\\n+\t     regno <= SPARC_LAST_V9_FCC_REG;\t\t\t\\\n+\t     regno++)\t\t\t\t\t\t\\\n+\t  fixed_regs[regno] = 1;\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n     if (! TARGET_FPU)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tint regno;\t\t\t\t\t\t\\\n-\tfor (regno = 32; regno < FIRST_PSEUDO_REGISTER; regno++) \\\n+\tfor (regno = 32; regno < SPARC_LAST_V9_FCC_REG; regno++) \\\n \t  fixed_regs[regno] = 1;\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n     /* Don't unfix g2-g4 if they were fixed with -ffixed-.  */\t\\\n@@ -982,7 +1000,12 @@ extern int sparc_mode_class[];\n    have a class that is the union of FPCC_REGS with either of the others,\n    it is important that it appear first.  Otherwise the compiler will die\n    trying to compile _fixunsdfsi because fix_truncdfsi2 won't match its\n-   constraints.  */\n+   constraints.\n+\n+   It is important that SPARC_ICC_REG have class NO_REGS.  Otherwise combine\n+   may try to use it to hold an SImode value.  See register_operand.\n+   ??? Should %fcc[0123] be handled similarily?\n+*/\n \n enum reg_class { NO_REGS, FPCC_REGS, GENERAL_REGS, FP_REGS, EXTRA_FP_REGS,\n \t\t GENERAL_OR_FP_REGS, GENERAL_OR_EXTRA_FP_REGS,\n@@ -1001,21 +1024,18 @@ enum reg_class { NO_REGS, FPCC_REGS, GENERAL_REGS, FP_REGS, EXTRA_FP_REGS,\n    of length N_REG_CLASSES.  */\n \n #define REG_CLASS_CONTENTS \\\n-  {{0, 0, 0, 0}, {0, 0, 0, 0xf}, {-2, 0, 0, 0}, \\\n-   {0, -1, 0, 0}, {0, -1, -1, 0}, {-2, -1, 0, 0}, {-2, -1, -1, 0}, \\\n-   {-2, -1, -1, 0xf}}\n+  {{0, 0, 0, 0}, {0, 0, 0, 0xf}, \\\n+   {-1, 0, 0, 0}, {0, -1, 0, 0}, {0, -1, -1, 0}, \\\n+   {-1, -1, 0, 0}, {-1, -1, -1, 0}, {-1, -1, -1, 0x1f}}\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n-#define REGNO_REG_CLASS(REGNO) \\\n-  ((REGNO) == 0 ? NO_REGS\t\t\\\n-   : (REGNO) < 32 ? GENERAL_REGS\t\\\n-   : (REGNO) < 64 ? FP_REGS\t\t\\\n-   : (REGNO) < 96 ? EXTRA_FP_REGS\t\\\n-   : FPCC_REGS)\n+extern enum reg_class sparc_regno_reg_class[];\n+\n+#define REGNO_REG_CLASS(REGNO) sparc_regno_reg_class[(REGNO)]\n \n /* This is the order in which to allocate registers normally.  \n    \n@@ -1040,7 +1060,7 @@ enum reg_class { NO_REGS, FPCC_REGS, GENERAL_REGS, FP_REGS, EXTRA_FP_REGS,\n   64, 65, 66, 67, 68, 69, 70, 71,\t/* %f32-%f39 */ \\\n   72, 73, 74, 75, 76, 77, 78, 79,\t/* %f40-%f47 */ \\\n   32, 33,\t\t\t\t/* %f0,%f1 */   \\\n-  96, 97, 98, 99,\t\t\t/* %fcc0-3 */   \\\n+  96, 97, 98, 99, 100,\t\t\t/* %fcc0-3, %icc */ \\\n   1, 4, 5, 6, 7, 0, 14, 30}\n \n /* This is the order in which to allocate registers for\n@@ -1062,7 +1082,7 @@ enum reg_class { NO_REGS, FPCC_REGS, GENERAL_REGS, FP_REGS, EXTRA_FP_REGS,\n   64, 65, 66, 67, 68, 69, 70, 71,\t\\\n   72, 73, 74, 75, 76, 77, 78, 79,\t\\\n   32, 33,\t\t\t\t\\\n-  96, 97, 98, 99,\t\t\t\\\n+  96, 97, 98, 99, 100,\t\t\t\\\n   1, 4, 5, 6, 7, 0, 14, 30, 31}\n \n #define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()\n@@ -1086,7 +1106,7 @@ enum reg_class { NO_REGS, FPCC_REGS, GENERAL_REGS, FP_REGS, EXTRA_FP_REGS,\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1}\n+  1, 1, 1, 1, 1}\n \n extern char leaf_reg_remap[];\n #define LEAF_REG_REMAP(REGNO) (leaf_reg_remap[REGNO])\n@@ -1110,6 +1130,7 @@ extern char leaf_reg_remap[];\n     : NO_REGS)\t\t\t\\\n  : ((C) == 'f' ? FP_REGS\t\\\n     : (C) == 'e' ? FP_REGS\t\\\n+    : (C) == 'c' ? FPCC_REGS\t\\\n     : NO_REGS))\n \n /* The letters I, J, K, L and M in a register constraint string\n@@ -1624,7 +1645,7 @@ extern int leaf_function;\n #define FUNCTION_PROLOGUE(FILE, SIZE) \\\n   (TARGET_FLAT ? sparc_flat_output_function_prologue (FILE, SIZE) \\\n    : output_function_prologue (FILE, SIZE, leaf_function))\n-\n+\f\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n@@ -1981,7 +2002,7 @@ while(0)\n   asm (\"LSFLGNZVC\" ID \":\");\\\n   asm (\"\tunimp\");\\\n   asm (\"LFLGRET\" ID \":\");\n-\n+\f\n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n    functions that have frame pointers.\n@@ -2136,15 +2157,16 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n    has been allocated, which happens in local-alloc.c.  */\n \n #define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-(((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32) && (REGNO) != 0)\n+((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n #define REGNO_OK_FOR_BASE_P(REGNO) \\\n-(((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32) && (REGNO) != 0)\n+((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n #define REGNO_OK_FOR_FP_P(REGNO) \\\n   (((unsigned) (REGNO) - 32 < (TARGET_V9 ? 64 : 32)) \\\n    || ((unsigned) reg_renumber[REGNO] - 32 < (TARGET_V9 ? 64 : 32)))\n #define REGNO_OK_FOR_CCFP_P(REGNO) \\\n  (TARGET_V9 \\\n-  && ((unsigned) (REGNO) - 96 < 4) || ((unsigned) reg_renumber[REGNO] - 96 < 4))\n+  && (((unsigned) (REGNO) - 96 < 4) \\\n+      || ((unsigned) reg_renumber[REGNO] - 96 < 4)))\n \n /* Now macros that check whether X is a register and also,\n    strictly, whether it is in a specified class.\n@@ -2210,11 +2232,11 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_INDEX_P(X) \\\n-  (((unsigned) REGNO (X)) - 32 >= (FIRST_PSEUDO_REGISTER - 32) && REGNO (X) != 0)\n+  (((unsigned) REGNO (X)) - 32 >= (FIRST_PSEUDO_REGISTER - 32))\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X) \\\n-  (((unsigned) REGNO (X)) - 32 >= (FIRST_PSEUDO_REGISTER - 32) && REGNO (X) != 0)\n+  (((unsigned) REGNO (X)) - 32 >= (FIRST_PSEUDO_REGISTER - 32))\n \n /* 'T', 'U' are for aligned memory loads which aren't needed for v9.  */\n \n@@ -2249,8 +2271,9 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n    : (! TARGET_ARCH64 && (C) == 'U')\t\t\t\\\n    ? (GET_CODE (OP) == REG\t\t\t\t\\\n       && (REGNO (OP) < FIRST_PSEUDO_REGISTER\t\t\\\n-\t  || reg_renumber[REGNO (OP)] > 0)\t\t\\\n-      && register_ok_for_ldd (OP)) : 0)\n+\t  || reg_renumber[REGNO (OP)] >= 0)\t\t\\\n+      && register_ok_for_ldd (OP))\t\t\t\\\n+   : 0)\n #endif\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n@@ -2468,8 +2491,7 @@ extern struct rtx_def *legitimize_pic_address ();\n    We also have two modes to indicate that the relevant condition code is\n    in the floating-point condition code register.  One for comparisons which\n    will generate an exception if the result is unordered (CCFPEmode) and\n-   one for comparisons which will never trap (CCFPmode).  This really should\n-   be a separate register, but we don't want to go to 65 registers.\n+   one for comparisons which will never trap (CCFPmode).\n \n    CCXmode and CCX_NOOVmode are only used by v9.  */\n \n@@ -2703,16 +2725,12 @@ extern struct rtx_def *legitimize_pic_address ();\n  \"%f40\", \"%f41\", \"%f42\", \"%f43\", \"%f44\", \"%f45\", \"%f46\", \"%f47\",\t\\\n  \"%f48\", \"%f49\", \"%f50\", \"%f51\", \"%f52\", \"%f53\", \"%f54\", \"%f55\",\t\\\n  \"%f56\", \"%f57\", \"%f58\", \"%f59\", \"%f60\", \"%f61\", \"%f62\", \"%f63\",\t\\\n- \"%fcc0\", \"%fcc1\", \"%fcc2\", \"%fcc3\"}\n-\n-/* Define additional names for use in asm clobbers and asm declarations.\n+ \"%fcc0\", \"%fcc1\", \"%fcc2\", \"%fcc3\", \"%icc\"}\n \n-   We define the fake Condition Code register as an alias for reg 0 (which\n-   is our `condition code' register), so that condition codes can easily\n-   be clobbered by an asm.  No such register actually exists.  Condition\n-   codes are partly stored in the PSR and partly in the FSR.  */\n+/* Define additional names for use in asm clobbers and asm declarations.  */\n \n-#define ADDITIONAL_REGISTER_NAMES\t{\"ccr\", 0, \"cc\", 0}\n+#define ADDITIONAL_REGISTER_NAMES \\\n+{{\"ccr\", SPARC_ICC_REG}, {\"cc\", SPARC_ICC_REG}}\n \n /* How to renumber registers for dbx and gdb.  */\n "}, {"sha": "fc5279baaa08b1deb51c09907b81d9e22c24d561", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 420, "deletions": 327, "changes": 747, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ce68534a192e1b452b70dee5a4bab71f6729e4/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ce68534a192e1b452b70dee5a4bab71f6729e4/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=c4ce68534a192e1b452b70dee5a4bab71f6729e4", "patch": "@@ -28,6 +28,9 @@\n ;; is a bit of a misnomer as it covers all 64 fp regs.  The corresponding\n ;; constraint letter is 'e'.  To avoid any confusion, 'e' is used instead of\n ;; 'f' for all DF/TFmode values, including those that are specific to the v8.\n+;;\n+;; -mlive-g0 is *not* supported for TARGET_ARCH64, so we don't bother to\n+;; test TARGET_LIVE_G0 if we have TARGET_ARCH64.\n \n ;; Attribute for cpu type.\n ;; These must match the values for enum processor_type in sparc.h.\n@@ -49,6 +52,12 @@\n   (cond [(symbol_ref \"TARGET_ARCH64\") (const_string \"arch64bit\")]\n \t(const_string \"arch32bit\"))))\n \n+;; Whether -mlive-g0 is in effect.\n+(define_attr \"live_g0\" \"no,yes\"\n+ (const\n+  (cond [(symbol_ref \"TARGET_LIVE_G0\") (const_string \"yes\")]\n+\t(const_string \"no\"))))\n+\n ;; Insn type.  Used to default other attribute values.\n \n ;; type \"unary\" insns have one input operand (1) and one output operand (0)\n@@ -282,7 +291,7 @@\n ;; Put cmpsi first among compare insns so it matches two CONST_INT operands.\n \n (define_expand \"cmpsi\"\n-  [(set (reg:CC 0)\n+  [(set (reg:CC 100)\n \t(compare:CC (match_operand:SI 0 \"register_operand\" \"\")\n \t\t    (match_operand:SI 1 \"arith_operand\" \"\")))]\n   \"\"\n@@ -294,7 +303,7 @@\n }\")\n \n (define_expand \"cmpdi\"\n-  [(set (reg:CCX 0)\n+  [(set (reg:CCX 100)\n \t(compare:CCX (match_operand:DI 0 \"register_operand\" \"\")\n \t\t     (match_operand:DI 1 \"arith_double_operand\" \"\")))]\n   \"TARGET_ARCH64\"\n@@ -306,7 +315,8 @@\n }\")\n \n (define_expand \"cmpsf\"\n-  [(set (reg:CCFP 0)\n+  ;; The 96 here isn't ever used by anyone.\n+  [(set (reg:CCFP 96)\n \t(compare:CCFP (match_operand:SF 0 \"register_operand\" \"\")\n \t\t      (match_operand:SF 1 \"register_operand\" \"\")))]\n   \"TARGET_FPU\"\n@@ -318,7 +328,8 @@\n }\")\n \n (define_expand \"cmpdf\"\n-  [(set (reg:CCFP 0)\n+  ;; The 96 here isn't ever used by anyone.\n+  [(set (reg:CCFP 96)\n \t(compare:CCFP (match_operand:DF 0 \"register_operand\" \"\")\n \t\t      (match_operand:DF 1 \"register_operand\" \"\")))]\n   \"TARGET_FPU\"\n@@ -330,7 +341,8 @@\n }\")\n \n (define_expand \"cmptf\"\n-  [(set (reg:CCFP 0)\n+  ;; The 96 here isn't ever used by anyone.\n+  [(set (reg:CCFP 96)\n \t(compare:CCFP (match_operand:TF 0 \"register_operand\" \"\")\n \t\t      (match_operand:TF 1 \"register_operand\" \"\")))]\n   \"TARGET_FPU\"\n@@ -344,115 +356,97 @@\n ;; Now the compare DEFINE_INSNs.\n \n (define_insn \"*cmpsi_insn\"\n-  [(set (reg:CC 0)\n+  [(set (reg:CC 100)\n \t(compare:CC (match_operand:SI 0 \"register_operand\" \"r\")\n \t\t    (match_operand:SI 1 \"arith_operand\" \"rI\")))]\n   \"\"\n   \"cmp %0,%1\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*cmpsf_fpe_sp32\"\n-  [(set (reg:CCFPE 0)\n-\t(compare:CCFPE (match_operand:SF 0 \"register_operand\" \"f\")\n-\t\t       (match_operand:SF 1 \"register_operand\" \"f\")))]\n-  \"! TARGET_V9 && TARGET_FPU\"\n-  \"fcmpes %0,%1\"\n-  [(set_attr \"type\" \"fpcmp\")])\n-\n-(define_insn \"*cmpdf_fpe_sp32\"\n-  [(set (reg:CCFPE 0)\n-\t(compare:CCFPE (match_operand:DF 0 \"register_operand\" \"e\")\n-\t\t       (match_operand:DF 1 \"register_operand\" \"e\")))]\n-  \"! TARGET_V9 && TARGET_FPU\"\n-  \"fcmped %0,%1\"\n-  [(set_attr \"type\" \"fpcmp\")])\n-\n-(define_insn \"*cmptf_fpe_sp32\"\n-  [(set (reg:CCFPE 0)\n-\t(compare:CCFPE (match_operand:TF 0 \"register_operand\" \"e\")\n-\t\t       (match_operand:TF 1 \"register_operand\" \"e\")))]\n-  \"! TARGET_V9 && TARGET_FPU && TARGET_HARD_QUAD\"\n-  \"fcmpeq %0,%1\"\n-  [(set_attr \"type\" \"fpcmp\")])\n-\n-(define_insn \"*cmpsf_fp_sp32\"\n-  [(set (reg:CCFP 0)\n-\t(compare:CCFP (match_operand:SF 0 \"register_operand\" \"f\")\n-\t\t      (match_operand:SF 1 \"register_operand\" \"f\")))]\n-  \"! TARGET_V9 && TARGET_FPU\"\n-  \"fcmps %0,%1\"\n-  [(set_attr \"type\" \"fpcmp\")])\n-\n-(define_insn \"*cmpdf_fp_sp32\"\n-  [(set (reg:CCFP 0)\n-\t(compare:CCFP (match_operand:DF 0 \"register_operand\" \"e\")\n-\t\t      (match_operand:DF 1 \"register_operand\" \"e\")))]\n-  \"! TARGET_V9 && TARGET_FPU\"\n-  \"fcmpd %0,%1\"\n-  [(set_attr \"type\" \"fpcmp\")])\n-\n-(define_insn \"*cmptf_fp_sp32\"\n-  [(set (reg:CCFP 0)\n-\t(compare:CCFP (match_operand:TF 0 \"register_operand\" \"e\")\n-\t\t      (match_operand:TF 1 \"register_operand\" \"e\")))]\n-  \"! TARGET_V9 && TARGET_FPU && TARGET_HARD_QUAD\"\n-  \"fcmpq %0,%1\"\n-  [(set_attr \"type\" \"fpcmp\")])\n-\n (define_insn \"*cmpdi_sp64\"\n-  [(set (reg:CCX 0)\n+  [(set (reg:CCX 100)\n \t(compare:CCX (match_operand:DI 0 \"register_operand\" \"r\")\n \t\t     (match_operand:DI 1 \"arith_double_operand\" \"rHI\")))]\n   \"TARGET_ARCH64\"\n   \"cmp %0,%1\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*cmpsf_fpe_sp64\"\n-  [(set (match_operand:CCFPE 0 \"ccfp_reg_operand\" \"=c\")\n+(define_insn \"*cmpsf_fpe\"\n+  [(set (match_operand:CCFPE 0 \"fcc_reg_operand\" \"=c\")\n \t(compare:CCFPE (match_operand:SF 1 \"register_operand\" \"f\")\n \t\t       (match_operand:SF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_V9 && TARGET_FPU\"\n-  \"fcmpes %0,%1,%2\"\n+  \"TARGET_FPU\"\n+  \"*\n+{\n+  if (TARGET_V9)\n+    return \\\"fcmpes %0,%1,%2\\\";\n+  return \\\"fcmpes %1,%2\\\";\n+}\"\n   [(set_attr \"type\" \"fpcmp\")])\n \n-(define_insn \"*cmpdf_fpe_sp64\"\n-  [(set (match_operand:CCFPE 0 \"ccfp_reg_operand\" \"=c\")\n+(define_insn \"*cmpdf_fpe\"\n+  [(set (match_operand:CCFPE 0 \"fcc_reg_operand\" \"=c\")\n \t(compare:CCFPE (match_operand:DF 1 \"register_operand\" \"e\")\n \t\t       (match_operand:DF 2 \"register_operand\" \"e\")))]\n-  \"TARGET_V9 && TARGET_FPU\"\n-  \"fcmped %0,%1,%2\"\n+  \"TARGET_FPU\"\n+  \"*\n+{\n+  if (TARGET_V9)\n+    return \\\"fcmped %0,%1,%2\\\";\n+  return \\\"fcmped %1,%2\\\";\n+}\"\n   [(set_attr \"type\" \"fpcmp\")])\n \n-(define_insn \"*cmptf_fpe_sp64\"\n-  [(set (match_operand:CCFPE 0 \"ccfp_reg_operand\" \"=c\")\n+(define_insn \"*cmptf_fpe\"\n+  [(set (match_operand:CCFPE 0 \"fcc_reg_operand\" \"=c\")\n \t(compare:CCFPE (match_operand:TF 1 \"register_operand\" \"e\")\n \t\t       (match_operand:TF 2 \"register_operand\" \"e\")))]\n-  \"TARGET_V9 && TARGET_FPU && TARGET_HARD_QUAD\"\n-  \"fcmpeq %0,%1,%2\"\n+  \"TARGET_FPU && TARGET_HARD_QUAD\"\n+  \"*\n+{\n+  if (TARGET_V9)\n+    return \\\"fcmpeq %0,%1,%2\\\";\n+  return \\\"fcmpeq %1,%2\\\";\n+}\"\n   [(set_attr \"type\" \"fpcmp\")])\n \n-(define_insn \"*cmpsf_fp_sp64\"\n-  [(set (match_operand:CCFP 0 \"ccfp_reg_operand\" \"=c\")\n+(define_insn \"*cmpsf_fp\"\n+  [(set (match_operand:CCFP 0 \"fcc_reg_operand\" \"=c\")\n \t(compare:CCFP (match_operand:SF 1 \"register_operand\" \"f\")\n \t\t      (match_operand:SF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_V9 && TARGET_FPU\"\n-  \"fcmps %0,%1,%2\"\n+  \"TARGET_FPU\"\n+  \"*\n+{\n+  if (TARGET_V9)\n+    return \\\"fcmps %0,%1,%2\\\";\n+  return \\\"fcmps %1,%2\\\";\n+}\"\n   [(set_attr \"type\" \"fpcmp\")])\n \n-(define_insn \"*cmpdf_fp_sp64\"\n-  [(set (match_operand:CCFP 0 \"ccfp_reg_operand\" \"=c\")\n+(define_insn \"*cmpdf_fp\"\n+  [(set (match_operand:CCFP 0 \"fcc_reg_operand\" \"=c\")\n \t(compare:CCFP (match_operand:DF 1 \"register_operand\" \"e\")\n \t\t      (match_operand:DF 2 \"register_operand\" \"e\")))]\n-  \"TARGET_V9 && TARGET_FPU\"\n-  \"fcmpd %0,%1,%2\"\n+  \"TARGET_FPU\"\n+  \"*\n+{\n+  if (TARGET_V9)\n+    return \\\"fcmpd %0,%1,%2\\\";\n+  return \\\"fcmpd %1,%2\\\";\n+}\"\n   [(set_attr \"type\" \"fpcmp\")])\n \n-(define_insn \"*cmptf_fp_sp64\"\n-  [(set (match_operand:CCFP 0 \"ccfp_reg_operand\" \"=c\")\n+(define_insn \"*cmptf_fp\"\n+  [(set (match_operand:CCFP 0 \"fcc_reg_operand\" \"=c\")\n \t(compare:CCFP (match_operand:TF 1 \"register_operand\" \"e\")\n \t\t      (match_operand:TF 2 \"register_operand\" \"e\")))]\n-  \"TARGET_V9 && TARGET_FPU && TARGET_HARD_QUAD\"\n-  \"fcmpq %0,%1,%2\"\n+  \"TARGET_FPU && TARGET_HARD_QUAD\"\n+  \"*\n+{\n+  if (TARGET_V9)\n+    return \\\"fcmpq %0,%1,%2\\\";\n+  return \\\"fcmpq %1,%2\\\";\n+}\"\n   [(set_attr \"type\" \"fpcmp\")])\n \f\n ;; Next come the scc insns.  For seq, sne, sgeu, and sltu, we can do this\n@@ -471,8 +465,8 @@\n \t\t(match_operand:SI 2 \"register_operand\" \"\")))\n    (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t\t   (eq:SI (match_dup 3) (const_int 0)))\n-\t      (clobber (reg:CC 0))])]\n-  \"\"\n+\t      (clobber (reg:CC 100))])]\n+  \"! TARGET_LIVE_G0\"\n   \"{ operands[3] = gen_reg_rtx (SImode); }\")\n \n (define_expand \"seqdi_special\"\n@@ -481,7 +475,7 @@\n \t\t(match_operand:DI 2 \"register_operand\" \"\")))\n    (parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t\t   (eq:DI (match_dup 3) (const_int 0)))\n-\t      (clobber (reg:CCX 0))])]\n+\t      (clobber (reg:CCX 100))])]\n   \"TARGET_ARCH64\"\n   \"{ operands[3] = gen_reg_rtx (DImode); }\")\n \n@@ -491,8 +485,8 @@\n \t\t(match_operand:SI 2 \"register_operand\" \"\")))\n    (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t\t   (ne:SI (match_dup 3) (const_int 0)))\n-\t      (clobber (reg:CC 0))])]\n-  \"\"\n+\t      (clobber (reg:CC 100))])]\n+  \"! TARGET_LIVE_G0\"\n   \"{ operands[3] = gen_reg_rtx (SImode); }\")\n \n (define_expand \"snedi_special\"\n@@ -501,7 +495,7 @@\n \t\t(match_operand:DI 2 \"register_operand\" \"\")))\n    (parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t\t   (ne:DI (match_dup 3) (const_int 0)))\n-\t      (clobber (reg:CCX 0))])]\n+\t      (clobber (reg:CCX 100))])]\n   \"TARGET_ARCH64\"\n   \"{ operands[3] = gen_reg_rtx (DImode); }\")\n \n@@ -511,7 +505,7 @@\n \t\t(match_operand:DI 2 \"register_operand\" \"\")))\n    (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t\t   (eq:DI (match_dup 3) (const_int 0)))\n-\t      (clobber (reg:CCX 0))])]\n+\t      (clobber (reg:CCX 100))])]\n   \"TARGET_ARCH64\"\n   \"{ operands[3] = gen_reg_rtx (DImode); }\")\n \n@@ -521,7 +515,7 @@\n \t\t(match_operand:DI 2 \"register_operand\" \"\")))\n    (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t\t   (ne:DI (match_dup 3) (const_int 0)))\n-\t      (clobber (reg:CCX 0))])]\n+\t      (clobber (reg:CCX 100))])]\n   \"TARGET_ARCH64\"\n   \"{ operands[3] = gen_reg_rtx (DImode); }\")\n \n@@ -531,7 +525,7 @@\n \t\t(match_operand:SI 2 \"register_operand\" \"\")))\n    (parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t\t   (eq:SI (match_dup 3) (const_int 0)))\n-\t      (clobber (reg:CC 0))])]\n+\t      (clobber (reg:CC 100))])]\n   \"TARGET_ARCH64\"\n   \"{ operands[3] = gen_reg_rtx (SImode); }\")\n \n@@ -541,7 +535,7 @@\n \t\t(match_operand:SI 2 \"register_operand\" \"\")))\n    (parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t\t   (ne:SI (match_dup 3) (const_int 0)))\n-\t      (clobber (reg:CC 0))])]\n+\t      (clobber (reg:CC 100))])]\n   \"TARGET_ARCH64\"\n   \"{ operands[3] = gen_reg_rtx (SImode); }\")\n \n@@ -550,7 +544,7 @@\n (define_expand \"seq\"\n   [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n \t(eq:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"\n {\n   if (GET_MODE (sparc_compare_op0) == SImode)\n@@ -603,7 +597,7 @@\n (define_expand \"sne\"\n   [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n \t(ne:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"\n {\n   if (GET_MODE (sparc_compare_op0) == SImode)\n@@ -654,7 +648,7 @@\n (define_expand \"sgt\"\n   [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n \t(gt:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"\n {\n   if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n@@ -675,7 +669,7 @@\n (define_expand \"slt\"\n   [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n \t(lt:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"\n {\n   if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n@@ -696,7 +690,7 @@\n (define_expand \"sge\"\n   [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n \t(ge:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"\n {\n   if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n@@ -717,7 +711,7 @@\n (define_expand \"sle\"\n   [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n \t(le:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"\n {\n   if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n@@ -738,7 +732,7 @@\n (define_expand \"sgtu\"\n   [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n \t(gtu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"\n {\n   if (! TARGET_V9)\n@@ -770,7 +764,7 @@\n (define_expand \"sltu\"\n   [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n \t(ltu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"\n {\n   if (TARGET_V9)\n@@ -784,7 +778,7 @@\n (define_expand \"sgeu\"\n   [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n \t(geu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"\n {\n   if (TARGET_V9)\n@@ -798,7 +792,7 @@\n (define_expand \"sleu\"\n   [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n \t(leu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"\n {\n   if (! TARGET_V9)\n@@ -836,8 +830,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t       (const_int 0)))\n-   (clobber (reg:CC 0))]\n-  \"\"\n+   (clobber (reg:CC 100))]\n+  \"! TARGET_LIVE_G0\"\n   \"subcc %%g0,%1,%%g0\\;addx %%g0,0,%0\"\n   [(set_attr \"type\" \"unary\")\n    (set_attr \"length\" \"2\")])\n@@ -846,8 +840,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t       (const_int 0))))\n-   (clobber (reg:CC 0))]\n-  \"\"\n+   (clobber (reg:CC 100))]\n+  \"! TARGET_LIVE_G0\"\n   \"subcc %%g0,%1,%%g0\\;subx %%g0,0,%0\"\n   [(set_attr \"type\" \"unary\")\n    (set_attr \"length\" \"2\")])\n@@ -856,7 +850,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t       (const_int 0)))\n-   (clobber (reg:CC 0))]\n+   (clobber (reg:CC 100))]\n   \"TARGET_ARCH64\"\n   \"subcc %%g0,%1,%%g0\\;addx %%g0,0,%0\"\n   [(set_attr \"type\" \"unary\")\n@@ -866,7 +860,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ne:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t       (const_int 0)))\n-   (clobber (reg:CCX 0))]\n+   (clobber (reg:CCX 100))]\n   \"TARGET_ARCH64\"\n   \"mov 0,%0\\;movrnz %1,1,%0\"\n   [(set_attr \"type\" \"unary\")\n@@ -876,7 +870,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(neg:DI (ne:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t       (const_int 0))))\n-   (clobber (reg:CCX 0))]\n+   (clobber (reg:CCX 100))]\n   \"TARGET_ARCH64\"\n   \"mov 0,%0\\;movrnz %1,-1,%0\"\n   [(set_attr \"type\" \"unary\")\n@@ -886,8 +880,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(ne:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t       (const_int 0)))\n-   (clobber (reg:CCX 0))]\n-  \"! TARGET_ARCH64\"\n+   (clobber (reg:CCX 100))]\n+  \"! TARGET_ARCH64 && ! TARGET_LIVE_G0\"\n   \"xor %1,%R1,%0\\;subcc %%g0,%0,%%g0\\;addx %%g0,0,%0\"\n   [(set_attr \"type\" \"unary\")\n    (set_attr \"length\" \"3\")])\n@@ -896,7 +890,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(ne:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t       (const_int 0)))\n-   (clobber (reg:CCX 0))]\n+   (clobber (reg:CCX 100))]\n   \"TARGET_ARCH64\"\n   \"mov 0,%0\\;movrnz %1,1,%0\"\n   [(set_attr \"type\" \"unary\")\n@@ -906,8 +900,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(eq:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t       (const_int 0)))\n-   (clobber (reg:CC 0))]\n-  \"\"\n+   (clobber (reg:CC 100))]\n+  \"! TARGET_LIVE_G0\"\n   \"subcc %%g0,%1,%%g0\\;subx %%g0,-1,%0\"\n   [(set_attr \"type\" \"unary\")\n    (set_attr \"length\" \"2\")])\n@@ -916,8 +910,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (eq:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t       (const_int 0))))\n-   (clobber (reg:CC 0))]\n-  \"\"\n+   (clobber (reg:CC 100))]\n+  \"! TARGET_LIVE_G0\"\n   \"subcc %%g0,%1,%%g0\\;addx %%g0,-1,%0\"\n   [(set_attr \"type\" \"unary\")\n    (set_attr \"length\" \"2\")])\n@@ -926,7 +920,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(eq:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t       (const_int 0)))\n-   (clobber (reg:CC 0))]\n+   (clobber (reg:CC 100))]\n   \"TARGET_ARCH64\"\n   \"subcc %%g0,%1,%%g0\\;subx %%g0,-1,%0\"\n   [(set_attr \"type\" \"unary\")\n@@ -936,7 +930,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(eq:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t       (const_int 0)))\n-   (clobber (reg:CCX 0))]\n+   (clobber (reg:CCX 100))]\n   \"TARGET_ARCH64\"\n   \"mov 0,%0\\;movrz %1,1,%0\"\n   [(set_attr \"type\" \"unary\")\n@@ -946,7 +940,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(neg:DI (eq:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t       (const_int 0))))\n-   (clobber (reg:CCX 0))]\n+   (clobber (reg:CCX 100))]\n   \"TARGET_ARCH64\"\n   \"mov 0,%0\\;movrz %1,-1,%0\"\n   [(set_attr \"type\" \"unary\")\n@@ -956,8 +950,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(eq:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t       (const_int 0)))\n-   (clobber (reg:CCX 0))]\n-  \"! TARGET_ARCH64\"\n+   (clobber (reg:CCX 100))]\n+  \"! TARGET_ARCH64 && ! TARGET_LIVE_G0\"\n   \"xor %1,%R1,%0\\;subcc %%g0,%0,%%g0\\;subx %%g0,-1,%0\"\n   [(set_attr \"type\" \"unary\")\n    (set_attr \"length\" \"3\")])\n@@ -966,7 +960,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(eq:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t       (const_int 0)))\n-   (clobber (reg:CCX 0))]\n+   (clobber (reg:CCX 100))]\n   \"TARGET_ARCH64\"\n   \"mov 0,%0\\;movrz %1,1,%0\"\n   [(set_attr \"type\" \"unary\")\n@@ -981,8 +975,8 @@\n \t(plus:SI (ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t(const_int 0))\n \t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n-   (clobber (reg:CC 0))]\n-  \"\"\n+   (clobber (reg:CC 100))]\n+  \"! TARGET_LIVE_G0\"\n   \"subcc %%g0,%1,%%g0\\;addx %2,0,%0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -991,8 +985,8 @@\n \t(minus:SI (match_operand:SI 2 \"register_operand\" \"r\")\n \t\t  (ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (const_int 0))))\n-   (clobber (reg:CC 0))]\n-  \"\"\n+   (clobber (reg:CC 100))]\n+  \"! TARGET_LIVE_G0\"\n   \"subcc %%g0,%1,%%g0\\;subx %2,0,%0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -1001,8 +995,8 @@\n \t(plus:SI (eq:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t(const_int 0))\n \t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n-   (clobber (reg:CC 0))]\n-  \"\"\n+   (clobber (reg:CC 100))]\n+  \"! TARGET_LIVE_G0\"\n   \"subcc %%g0,%1,%%g0\\;subx %2,-1,%0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -1011,8 +1005,8 @@\n \t(minus:SI (match_operand:SI 2 \"register_operand\" \"r\")\n \t\t  (eq:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (const_int 0))))\n-   (clobber (reg:CC 0))]\n-  \"\"\n+   (clobber (reg:CC 100))]\n+  \"! TARGET_LIVE_G0\"\n   \"subcc %%g0,%1,%%g0\\;addx %2,-1,%0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -1022,46 +1016,46 @@\n \n (define_insn \"*sltu_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ltu:SI (reg:CC 0) (const_int 0)))]\n-  \"\"\n+\t(ltu:SI (reg:CC 100) (const_int 0)))]\n+  \"! TARGET_LIVE_G0\"\n   \"addx %%g0,0,%0\"\n   [(set_attr \"type\" \"misc\")])\n \n (define_insn \"*neg_sltu_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(neg:SI (ltu:SI (reg:CC 0) (const_int 0))))]\n-  \"\"\n+\t(neg:SI (ltu:SI (reg:CC 100) (const_int 0))))]\n+  \"! TARGET_LIVE_G0\"\n   \"subx %%g0,0,%0\"\n   [(set_attr \"type\" \"misc\")])\n \n ;; ??? Combine should canonicalize these next two to the same pattern.\n (define_insn \"*neg_sltu_minus_x\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (neg:SI (ltu:SI (reg:CC 0) (const_int 0)))\n+\t(minus:SI (neg:SI (ltu:SI (reg:CC 100) (const_int 0)))\n \t\t  (match_operand:SI 1 \"arith_operand\" \"rI\")))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"subx %%g0,%1,%0\"\n   [(set_attr \"type\" \"unary\")])\n \n (define_insn \"*neg_sltu_plus_x\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(neg:SI (plus:SI (ltu:SI (reg:CC 0) (const_int 0))\n+\t(neg:SI (plus:SI (ltu:SI (reg:CC 100) (const_int 0))\n \t\t\t (match_operand:SI 1 \"arith_operand\" \"rI\"))))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"subx %%g0,%1,%0\"\n   [(set_attr \"type\" \"unary\")])\n \n (define_insn \"*sgeu_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(geu:SI (reg:CC 0) (const_int 0)))]\n-  \"\"\n+\t(geu:SI (reg:CC 100) (const_int 0)))]\n+  \"! TARGET_LIVE_G0\"\n   \"subx %%g0,-1,%0\"\n   [(set_attr \"type\" \"misc\")])\n \n (define_insn \"*neg_sgeu_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(neg:SI (geu:SI (reg:CC 0) (const_int 0))))]\n-  \"\"\n+\t(neg:SI (geu:SI (reg:CC 100) (const_int 0))))]\n+  \"! TARGET_LIVE_G0\"\n   \"addx %%g0,-1,%0\"\n   [(set_attr \"type\" \"misc\")])\n \n@@ -1071,15 +1065,15 @@\n \n (define_insn \"*sltu_plus_x\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (ltu:SI (reg:CC 0) (const_int 0))\n+\t(plus:SI (ltu:SI (reg:CC 100) (const_int 0))\n \t\t (match_operand:SI 1 \"arith_operand\" \"rI\")))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"addx %%g0,%1,%0\"\n   [(set_attr \"type\" \"unary\")])\n \n (define_insn \"*sltu_plus_x_plus_y\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (ltu:SI (reg:CC 0) (const_int 0))\n+\t(plus:SI (ltu:SI (reg:CC 100) (const_int 0))\n \t\t (plus:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n \t\t\t  (match_operand:SI 2 \"arith_operand\" \"rI\"))))]\n   \"\"\n@@ -1088,7 +1082,7 @@\n (define_insn \"*x_minus_sltu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t  (ltu:SI (reg:CC 0) (const_int 0))))]\n+\t\t  (ltu:SI (reg:CC 100) (const_int 0))))]\n   \"\"\n   \"subx %1,0,%0\"\n   [(set_attr \"type\" \"unary\")])\n@@ -1098,21 +1092,21 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(minus:SI (minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t    (match_operand:SI 2 \"arith_operand\" \"rI\"))\n-\t\t  (ltu:SI (reg:CC 0) (const_int 0))))]\n+\t\t  (ltu:SI (reg:CC 100) (const_int 0))))]\n   \"\"\n   \"subx %1,%2,%0\")\n \n (define_insn \"*x_minus_sltu_plus_y\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t  (plus:SI (ltu:SI (reg:CC 0) (const_int 0))\n+\t\t  (plus:SI (ltu:SI (reg:CC 100) (const_int 0))\n \t\t\t   (match_operand:SI 2 \"arith_operand\" \"rI\"))))]\n   \"\"\n   \"subx %1,%2,%0\")\n \n (define_insn \"*sgeu_plus_x\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (geu:SI (reg:CC 0) (const_int 0))\n+\t(plus:SI (geu:SI (reg:CC 100) (const_int 0))\n \t\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"subx %1,-1,%0\"\n@@ -1121,7 +1115,7 @@\n (define_insn \"*x_minus_sgeu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t  (geu:SI (reg:CC 0) (const_int 0))))]\n+\t\t  (geu:SI (reg:CC 100) (const_int 0))))]\n   \"\"\n   \"addx %1,-1,%0\"\n   [(set_attr \"type\" \"unary\")])\n@@ -1134,15 +1128,19 @@\n \n (define_insn \"*scc_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operator:SI 1 \"noov_compare_op\" [(reg 0) (const_int 0)]))]\n+\t(match_operator:SI 2 \"noov_compare_op\"\n+\t\t\t   [(match_operand 1 \"icc_or_fcc_reg_operand\" \"\")\n+\t\t\t    (const_int 0)]))]\n   \"\"\n   \"* return output_scc_insn (operands, insn); \"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"3\")])\n \n (define_insn \"*scc_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(match_operator:DI 1 \"noov_compare_op\" [(reg 0) (const_int 0)]))]\n+\t(match_operator:DI 2 \"noov_compare_op\"\n+\t\t\t   [(match_operand 1 \"icc_or_fcc_reg_operand\" \"\")\n+\t\t\t    (const_int 0)]))]\n   \"TARGET_ARCH64\"\n   \"* return output_scc_insn (operands, insn); \"\n   [(set_attr \"type\" \"multi\")\n@@ -1343,13 +1341,13 @@\n (define_insn \"*normal_branch\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"noov_compare_op\"\n-\t\t\t\t      [(reg 0) (const_int 0)])\n+\t\t\t\t      [(reg 100) (const_int 0)])\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n   \"*\n {\n-  return output_cbranch (operands[0], 0, 1, 0,\n+  return output_cbranch (operands[0], 1, 0,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n \t\t\t ! final_sequence);\n }\"\n@@ -1358,77 +1356,77 @@\n (define_insn \"*inverted_branch\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"noov_compare_op\"\n-\t\t\t\t      [(reg 0) (const_int 0)])\n+\t\t\t\t      [(reg 100) (const_int 0)])\n \t\t      (pc)\n \t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n   \"\"\n   \"*\n {\n-  return output_cbranch (operands[0], 0, 1, 1,\n+  return output_cbranch (operands[0], 1, 1,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n \t\t\t ! final_sequence);\n }\"\n   [(set_attr \"type\" \"branch\")])\n \n-(define_insn \"*normal_fp_branch_sp64\"\n+(define_insn \"*normal_fp_branch\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:CCFP 1 \"ccfp_reg_operand\" \"c\")\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t\t      [(match_operand:CCFP 0 \"fcc_reg_operand\" \"c\")\n \t\t\t\t       (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_V9\"\n+  \"\"\n   \"*\n {\n-  return output_cbranch (operands[0], operands[1], 2, 0,\n+  return output_cbranch (operands[1], 2, 0,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n \t\t\t ! final_sequence);\n }\"\n   [(set_attr \"type\" \"branch\")])\n \n-(define_insn \"*inverted_fp_branch_sp64\"\n+(define_insn \"*inverted_fp_branch\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:CCFP 1 \"ccfp_reg_operand\" \"c\")\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t\t      [(match_operand:CCFP 0 \"fcc_reg_operand\" \"c\")\n \t\t\t\t       (const_int 0)])\n \t\t      (pc)\n \t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n-  \"TARGET_V9\"\n+  \"\"\n   \"*\n {\n-  return output_cbranch (operands[0], operands[1], 2, 1,\n+  return output_cbranch (operands[1], 2, 1,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n \t\t\t ! final_sequence);\n }\"\n   [(set_attr \"type\" \"branch\")])\n \n-(define_insn \"*normal_fpe_branch_sp64\"\n+(define_insn \"*normal_fpe_branch\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:CCFPE 1 \"ccfp_reg_operand\" \"c\")\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t\t      [(match_operand:CCFPE 0 \"fcc_reg_operand\" \"c\")\n \t\t\t\t       (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_V9\"\n+  \"\"\n   \"*\n {\n-  return output_cbranch (operands[0], operands[1], 2, 0,\n+  return output_cbranch (operands[1], 2, 0,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n \t\t\t ! final_sequence);\n }\"\n   [(set_attr \"type\" \"branch\")])\n \n-(define_insn \"*inverted_fpe_branch_sp64\"\n+(define_insn \"*inverted_fpe_branch\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:CCFPE 1 \"ccfp_reg_operand\" \"c\")\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t\t      [(match_operand:CCFPE 0 \"fcc_reg_operand\" \"c\")\n \t\t\t\t       (const_int 0)])\n \t\t      (pc)\n \t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n-  \"TARGET_V9\"\n+  \"\"\n   \"*\n {\n-  return output_cbranch (operands[0], operands[1], 2, 1,\n+  return output_cbranch (operands[1], 2, 1,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n \t\t\t ! final_sequence);\n }\"\n@@ -1792,9 +1790,10 @@\n (define_insn \"*movqi_insn\"\n   [(set (match_operand:QI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,Q\")\n \t(match_operand:QI 1 \"move_operand\" \"rI,K,Q,rJ\"))]\n-  \"register_operand (operands[0], QImode)\n-   || register_operand (operands[1], QImode)\n-   || operands[1] == const0_rtx\"\n+  \"! TARGET_LIVE_G0\n+   && (register_operand (operands[0], QImode)\n+       || register_operand (operands[1], QImode)\n+       || operands[1] == const0_rtx)\"\n   \"@\n    mov %1,%0\n    sethi %%hi(%a1),%0\n@@ -1803,6 +1802,22 @@\n   [(set_attr \"type\" \"move,move,load,store\")\n    (set_attr \"length\" \"1\")])\n \n+(define_insn \"*movqi_insn_liveg0\"\n+  [(set (match_operand:QI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,r,r,Q\")\n+\t(match_operand:QI 1 \"move_operand\" \"r,J,I,K,Q,r\"))]\n+  \"TARGET_LIVE_G0\n+   && (register_operand (operands[0], QImode)\n+       || register_operand (operands[1], QImode))\"\n+  \"@\n+   mov %1,%0\n+   and %0,0,%0\n+   and %0,0,%0\\;or %0,%1,%0\n+   sethi %%hi(%a1),%0\n+   ldub %1,%0\n+   stb %1,%0\"\n+  [(set_attr \"type\" \"move,move,move,move,load,store\")\n+   (set_attr \"length\" \"1,1,2,1,1,1\")])\n+\n (define_insn \"*lo_sum_qi\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n \t(subreg:QI (lo_sum:SI (match_operand:QI 1 \"register_operand\" \"r\")\n@@ -1815,7 +1830,8 @@\n   [(set (mem:QI (match_operand:SI 0 \"symbolic_operand\" \"\"))\n \t(match_operand:QI 1 \"reg_or_0_operand\" \"rJ\"))\n    (clobber (match_scratch:SI 2 \"=&r\"))]\n-  \"(reload_completed || reload_in_progress) && ! TARGET_PTR64\"\n+  \"(reload_completed || reload_in_progress)\n+   && ! TARGET_PTR64\"\n   \"sethi %%hi(%a0),%2\\;stb %r1,[%2+%%lo(%a0)]\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"2\")])\n@@ -1833,9 +1849,10 @@\n (define_insn \"*movhi_insn\"\n   [(set (match_operand:HI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,Q\")\n \t(match_operand:HI 1 \"move_operand\" \"rI,K,Q,rJ\"))]\n-  \"register_operand (operands[0], HImode)\n-   || register_operand (operands[1], HImode)\n-   || operands[1] == const0_rtx\"\n+  \"! TARGET_LIVE_G0\n+   && (register_operand (operands[0], HImode)\n+       || register_operand (operands[1], HImode)\n+       || operands[1] == const0_rtx)\"\n   \"@\n    mov %1,%0\n    sethi %%hi(%a1),%0\n@@ -1844,6 +1861,22 @@\n   [(set_attr \"type\" \"move,move,load,store\")\n    (set_attr \"length\" \"1\")])\n \n+(define_insn \"*movhi_insn_liveg0\"\n+  [(set (match_operand:HI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,r,r,Q\")\n+\t(match_operand:HI 1 \"move_operand\" \"r,J,I,K,Q,r\"))]\n+  \"TARGET_LIVE_G0\n+   && (register_operand (operands[0], HImode)\n+       || register_operand (operands[1], HImode))\"\n+  \"@\n+   mov %1,%0\n+   and %0,0,%0\n+   and %0,0,%0\\;or %0,%1,%0\n+   sethi %%hi(%a1),%0\n+   lduh %1,%0\n+   sth %1,%0\"\n+  [(set_attr \"type\" \"move,move,move,move,load,store\")\n+   (set_attr \"length\" \"1,1,2,1,1,1\")])\n+\n (define_insn \"*lo_sum_hi\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(lo_sum:HI (match_operand:HI 1 \"register_operand\" \"r\")\n@@ -1856,7 +1889,8 @@\n   [(set (mem:HI (match_operand:SI 0 \"symbolic_operand\" \"\"))\n \t(match_operand:HI 1 \"reg_or_0_operand\" \"rJ\"))\n    (clobber (match_scratch:SI 2 \"=&r\"))]\n-  \"(reload_completed || reload_in_progress) && ! TARGET_PTR64\"\n+  \"(reload_completed || reload_in_progress)\n+   && ! TARGET_PTR64\"\n   \"sethi %%hi(%a0),%2\\;sth %r1,[%2+%%lo(%a0)]\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"2\")])\n@@ -1882,9 +1916,10 @@\n (define_insn \"*movsi_insn\"\n   [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\" \"=r,f,r,r,f,Q,Q\")\n \t(match_operand:SI 1 \"move_operand\" \"rI,!f,K,Q,!Q,rJ,!f\"))]\n-  \"register_operand (operands[0], SImode)\n-   || register_operand (operands[1], SImode)\n-   || operands[1] == const0_rtx\"\n+  \"! TARGET_LIVE_G0\n+   && (register_operand (operands[0], SImode)\n+       || register_operand (operands[1], SImode)\n+       || operands[1] == const0_rtx)\"\n   \"@\n    mov %1,%0\n    fmovs %1,%0\n@@ -1896,11 +1931,31 @@\n   [(set_attr \"type\" \"move,fp,move,load,fpload,store,fpstore\")\n    (set_attr \"length\" \"1\")])\n \n+(define_insn \"*movsi_insn_liveg0\"\n+  [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,f,r,r,f,Q,Q\")\n+\t(match_operand:SI 1 \"move_operand\" \"r,J,I,!f,K,Q,!Q,r,!f\"))]\n+  \"TARGET_LIVE_G0\n+   && (register_operand (operands[0], SImode)\n+       || register_operand (operands[1], SImode))\"\n+  \"@\n+   mov %1,%0\n+   and %0,0,%0\n+   and %0,0,%0\\;or %0,%1,%0\n+   fmovs %1,%0\n+   sethi %%hi(%a1),%0\n+   ld %1,%0\n+   ld %1,%0\n+   st %1,%0\n+   st %1,%0\"\n+  [(set_attr \"type\" \"move,move,move,fp,move,load,fpload,store,fpstore\")\n+   (set_attr \"length\" \"1,1,2,1,1,1,1,1,1\")])\n+\n (define_insn \"*store_si\"\n   [(set (mem:SI (match_operand:SI 0 \"symbolic_operand\" \"\"))\n \t(match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n    (clobber (match_scratch:SI 2 \"=&r\"))]\n-  \"(reload_completed || reload_in_progress) && ! TARGET_PTR64\"\n+  \"(reload_completed || reload_in_progress)\n+   && ! TARGET_PTR64\"\n   \"sethi %%hi(%a0),%2\\;st %r1,[%2+%%lo(%a0)]\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"2\")])\n@@ -2004,7 +2059,7 @@\n ;\t      (clobber (match_dup 0))\n ;\t      (clobber (match_dup 1))\n ;\t      (clobber (match_scratch:SI 4 \"\"))\n-;\t      (clobber (reg:SI 0))\n+;\t      (clobber (reg:SI 100))\n ;\t      (clobber (reg:SI 1))])]\n ;  \"\"\n ;  \"\n@@ -2030,7 +2085,7 @@\n ;   (clobber (match_dup 0))\n ;   (clobber (match_dup 1))\n ;   (clobber (match_scratch:SI 4 \"=&r\"))\n-;   (clobber (reg:SI 0))\n+;   (clobber (reg:SI 100))\n ;   (clobber (reg:SI 1))]\n ;  \"\"\n ;  \"* return output_block_move (operands);\"\n@@ -2106,7 +2161,8 @@\n   [(set (mem:SF (match_operand:SI 0 \"symbolic_operand\" \"i\"))\n \t(match_operand:SF 1 \"reg_or_0_operand\" \"rfG\"))\n    (clobber (match_scratch:SI 2 \"=&r\"))]\n-  \"(reload_completed || reload_in_progress) && ! TARGET_PTR64\"\n+  \"(reload_completed || reload_in_progress)\n+   && ! TARGET_PTR64\"\n   \"sethi %%hi(%a0),%2\\;st %r1,[%2+%%lo(%a0)]\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"2\")])\n@@ -2217,7 +2273,8 @@\n   [(set (mem:DF (match_operand:SI 0 \"symbolic_operand\" \"i,i\"))\n \t(match_operand:DF 1 \"reg_or_0_operand\" \"re,G\"))\n    (clobber (match_scratch:SI 2 \"=&r,&r\"))]\n-  \"(reload_completed || reload_in_progress) && ! TARGET_PTR64\"\n+  \"(reload_completed || reload_in_progress)\n+   && ! TARGET_PTR64\"\n   \"*\n {\n   output_asm_insn (\\\"sethi %%hi(%a0),%2\\\", operands);\n@@ -2314,7 +2371,8 @@\n   [(set (mem:TF (match_operand:SI 0 \"symbolic_operand\" \"i,i\"))\n \t(match_operand:TF 1 \"reg_or_0_operand\" \"re,G\"))\n    (clobber (match_scratch:SI 2 \"=&r,&r\"))]\n-  \"0 && (reload_completed || reload_in_progress) && ! TARGET_PTR64\"\n+  \"0 && (reload_completed || reload_in_progress)\n+   && ! TARGET_PTR64\"\n   \"*\n {\n   output_asm_insn (\\\"sethi %%hi(%a0),%2\\\", operands);\n@@ -2466,7 +2524,7 @@\n (define_insn \"*movsi_cc_sp64\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(reg:CC 0) (const_int 0)])\n+\t\t\t\t      [(reg:CC 100) (const_int 0)])\n \t\t      (match_operand:SI 2 \"arith11_operand\" \"ri\")\n \t\t      (match_operand:SI 3 \"register_operand\" \"0\")))]\n   \"TARGET_V9\"\n@@ -2476,7 +2534,7 @@\n (define_insn \"*movdi_cc_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(reg:CC 0) (const_int 0)])\n+\t\t\t\t      [(reg:CC 100) (const_int 0)])\n \t\t      (match_operand:DI 2 \"arith11_double_operand\" \"rHI\")\n \t\t      (match_operand:DI 3 \"register_operand\" \"0\")))]\n   \"TARGET_ARCH64\"\n@@ -2486,7 +2544,7 @@\n (define_insn \"*movsi_ccx_sp64\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(reg:CCX 0) (const_int 0)])\n+\t\t\t\t      [(reg:CCX 100) (const_int 0)])\n \t\t      (match_operand:SI 2 \"arith11_operand\" \"ri\")\n \t\t      (match_operand:SI 3 \"register_operand\" \"0\")))]\n   \"TARGET_ARCH64\"\n@@ -2496,7 +2554,7 @@\n (define_insn \"*movdi_ccx_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(reg:CCX 0) (const_int 0)])\n+\t\t\t\t      [(reg:CCX 100) (const_int 0)])\n \t\t      (match_operand:DI 2 \"arith11_double_operand\" \"rHI\")\n \t\t      (match_operand:DI 3 \"register_operand\" \"0\")))]\n   \"TARGET_ARCH64\"\n@@ -2506,7 +2564,7 @@\n (define_insn \"*movsi_ccfp_sp64\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand:CCFP 2 \"ccfp_reg_operand\" \"c\")\n+\t\t\t\t[(match_operand:CCFP 2 \"fcc_reg_operand\" \"c\")\n \t\t\t\t (const_int 0)])\n \t\t      (match_operand:SI 3 \"arith11_operand\" \"ri\")\n \t\t      (match_operand:SI 4 \"register_operand\" \"0\")))]\n@@ -2517,7 +2575,7 @@\n (define_insn \"*movsi_ccfpe_sp64\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand:CCFPE 2 \"ccfp_reg_operand\" \"c\")\n+\t\t\t\t[(match_operand:CCFPE 2 \"fcc_reg_operand\" \"c\")\n \t\t\t\t (const_int 0)])\n \t\t      (match_operand:SI 3 \"arith11_operand\" \"ri\")\n \t\t      (match_operand:SI 4 \"register_operand\" \"0\")))]\n@@ -2528,7 +2586,7 @@\n (define_insn \"*movdi_ccfp_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand:CCFP 2 \"ccfp_reg_operand\" \"c\")\n+\t\t\t\t[(match_operand:CCFP 2 \"fcc_reg_operand\" \"c\")\n \t\t\t\t (const_int 0)])\n \t\t      (match_operand:DI 3 \"arith11_double_operand\" \"rHI\")\n \t\t      (match_operand:DI 4 \"register_operand\" \"0\")))]\n@@ -2539,7 +2597,7 @@\n (define_insn \"*movdi_ccfpe_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand:CCFPE 2 \"ccfp_reg_operand\" \"c\")\n+\t\t\t\t[(match_operand:CCFPE 2 \"fcc_reg_operand\" \"c\")\n \t\t\t\t (const_int 0)])\n \t\t      (match_operand:DI 3 \"arith11_double_operand\" \"rHI\")\n \t\t      (match_operand:DI 4 \"register_operand\" \"0\")))]\n@@ -2605,7 +2663,7 @@\n (define_insn \"*movsf_ccfp_sp64\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand:CCFP 2 \"ccfp_reg_operand\" \"c\")\n+\t\t\t\t[(match_operand:CCFP 2 \"fcc_reg_operand\" \"c\")\n \t\t\t\t (const_int 0)])\n \t\t      (match_operand:SF 3 \"register_operand\" \"f\")\n \t\t      (match_operand:SF 4 \"register_operand\" \"0\")))]\n@@ -2616,7 +2674,7 @@\n (define_insn \"*movsf_ccfpe_sp64\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand:CCFPE 2 \"ccfp_reg_operand\" \"c\")\n+\t\t\t\t[(match_operand:CCFPE 2 \"fcc_reg_operand\" \"c\")\n \t\t\t\t (const_int 0)])\n \t\t      (match_operand:SF 3 \"register_operand\" \"f\")\n \t\t      (match_operand:SF 4 \"register_operand\" \"0\")))]\n@@ -2627,7 +2685,7 @@\n (define_insn \"*movdf_ccfp_sp64\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand:CCFP 2 \"ccfp_reg_operand\" \"c\")\n+\t\t\t\t[(match_operand:CCFP 2 \"fcc_reg_operand\" \"c\")\n \t\t\t\t (const_int 0)])\n \t\t      (match_operand:DF 3 \"register_operand\" \"e\")\n \t\t      (match_operand:DF 4 \"register_operand\" \"0\")))]\n@@ -2638,7 +2696,7 @@\n (define_insn \"*movdf_ccfpe_sp64\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand:CCFPE 2 \"ccfp_reg_operand\" \"c\")\n+\t\t\t\t[(match_operand:CCFPE 2 \"fcc_reg_operand\" \"c\")\n \t\t\t\t (const_int 0)])\n \t\t      (match_operand:DF 3 \"register_operand\" \"e\")\n \t\t      (match_operand:DF 4 \"register_operand\" \"0\")))]\n@@ -2649,7 +2707,7 @@\n (define_insn \"*movtf_ccfp_sp64\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand:CCFP 2 \"ccfp_reg_operand\" \"c\")\n+\t\t\t\t[(match_operand:CCFP 2 \"fcc_reg_operand\" \"c\")\n \t\t\t\t (const_int 0)])\n \t\t      (match_operand:TF 3 \"register_operand\" \"e\")\n \t\t      (match_operand:TF 4 \"register_operand\" \"0\")))]\n@@ -2660,7 +2718,7 @@\n (define_insn \"*movtf_ccfpe_sp64\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand:CCFPE 2 \"ccfp_reg_operand\" \"c\")\n+\t\t\t\t[(match_operand:CCFPE 2 \"fcc_reg_operand\" \"c\")\n \t\t\t\t (const_int 0)])\n \t\t      (match_operand:TF 3 \"register_operand\" \"e\")\n \t\t      (match_operand:TF 4 \"register_operand\" \"0\")))]\n@@ -2671,7 +2729,7 @@\n (define_insn \"*movsf_cc_sp64\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(reg:CC 0) (const_int 0)])\n+\t\t\t\t      [(reg:CC 100) (const_int 0)])\n \t\t      (match_operand:SF 2 \"register_operand\" \"f\")\n \t\t      (match_operand:SF 3 \"register_operand\" \"0\")))]\n   \"TARGET_V9 && TARGET_FPU\"\n@@ -2681,7 +2739,7 @@\n (define_insn \"*movdf_cc_sp64\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(reg:CC 0) (const_int 0)])\n+\t\t\t\t      [(reg:CC 100) (const_int 0)])\n \t\t      (match_operand:DF 2 \"register_operand\" \"e\")\n \t\t      (match_operand:DF 3 \"register_operand\" \"0\")))]\n   \"TARGET_V9 && TARGET_FPU\"\n@@ -2691,7 +2749,7 @@\n (define_insn \"*movtf_cc_sp64\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(reg:CC 0) (const_int 0)])\n+\t\t\t\t      [(reg:CC 100) (const_int 0)])\n \t\t      (match_operand:TF 2 \"register_operand\" \"e\")\n \t\t      (match_operand:TF 3 \"register_operand\" \"0\")))]\n   \"TARGET_V9 && TARGET_FPU\"\n@@ -2701,7 +2759,7 @@\n (define_insn \"*movsf_ccx_sp64\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(reg:CCX 0) (const_int 0)])\n+\t\t\t\t      [(reg:CCX 100) (const_int 0)])\n \t\t      (match_operand:SF 2 \"register_operand\" \"f\")\n \t\t      (match_operand:SF 3 \"register_operand\" \"0\")))]\n   \"TARGET_ARCH64 && TARGET_FPU\"\n@@ -2711,7 +2769,7 @@\n (define_insn \"*movdf_ccx_sp64\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(reg:CCX 0) (const_int 0)])\n+\t\t\t\t      [(reg:CCX 100) (const_int 0)])\n \t\t      (match_operand:DF 2 \"register_operand\" \"e\")\n \t\t      (match_operand:DF 3 \"register_operand\" \"0\")))]\n   \"TARGET_ARCH64 && TARGET_FPU\"\n@@ -2721,7 +2779,7 @@\n (define_insn \"*movtf_ccx_sp64\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(reg:CCX 0) (const_int 0)])\n+\t\t\t\t      [(reg:CCX 100) (const_int 0)])\n \t\t      (match_operand:TF 2 \"register_operand\" \"e\")\n \t\t      (match_operand:TF 3 \"register_operand\" \"0\")))]\n   \"TARGET_ARCH64 && TARGET_FPU\"\n@@ -2863,15 +2921,15 @@\n ;; Simplify comparisons of extended values.\n \n (define_insn \"*cmp_zero_extendqisi2\"\n-  [(set (reg:CC 0)\n+  [(set (reg:CC 100)\n \t(compare:CC (zero_extend:SI (match_operand:QI 0 \"register_operand\" \"r\"))\n \t\t    (const_int 0)))]\n   \"\"\n   \"andcc %0,0xff,%%g0\"\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_zero_extendqisi2_set\"\n-  [(set (reg:CC 0)\n+  [(set (reg:CC 100)\n \t(compare:CC (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"r\"))\n \t\t    (const_int 0)))\n    (set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -2883,15 +2941,15 @@\n ;; Similarly, handle SI->QI mode truncation followed by a compare.\n \n (define_insn \"*cmp_siqi_trunc\"\n-  [(set (reg:CC 0)\n+  [(set (reg:CC 100)\n \t(compare:CC (subreg:QI (match_operand:SI 0 \"register_operand\" \"r\") 0)\n \t\t    (const_int 0)))]\n   \"\"\n   \"andcc %0,0xff,%%g0\"\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_siqi_trunc_set\"\n-  [(set (reg:CC 0)\n+  [(set (reg:CC 100)\n \t(compare:CC (subreg:QI (match_operand:SI 1 \"register_operand\" \"r\") 0)\n \t\t    (const_int 0)))\n    (set (match_operand:QI 0 \"register_operand\" \"=r\")\n@@ -3083,7 +3141,7 @@\n ;; because combine uses this as a canonical form.\n \n (define_insn \"*cmp_zero_extract\"\n-  [(set (reg:CC 0)\n+  [(set (reg:CC 100)\n \t(compare:CC\n \t (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n \t\t\t  (match_operand:SI 1 \"small_int\" \"n\")\n@@ -3101,7 +3159,7 @@\n }\")\n \n (define_insn \"*cmp_zero_extract_sp64\"\n-  [(set (reg:CCX 0)\n+  [(set (reg:CCX 100)\n \t(compare:CCX\n \t (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"r\")\n \t\t\t  (match_operand:SI 1 \"small_int\" \"n\")\n@@ -3461,7 +3519,8 @@\n \t\t\t  gen_rtx (SET, VOIDmode, operands[0],\n \t\t\t\t   gen_rtx (PLUS, DImode, operands[1],\n \t\t\t\t\t\t  operands[2])),\n-\t\t\t  gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 0)))));\n+\t\t\t  gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t   gen_rtx (REG, SImode, SPARC_ICC_REG)))));\n       DONE;\n     }\n }\")\n@@ -3470,7 +3529,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(plus:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n \t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n-   (clobber (reg:SI 0))]\n+   (clobber (reg:SI 100))]\n   \"! TARGET_ARCH64\"\n   \"*\n {\n@@ -3518,7 +3577,7 @@\n   [(set_attr \"type\" \"ialu\")])\n \n (define_insn \"*cmp_cc_plus\"\n-  [(set (reg:CC_NOOV 0)\n+  [(set (reg:CC_NOOV 100)\n \t(compare:CC_NOOV (plus:SI (match_operand:SI 0 \"arith_operand\" \"%r\")\n \t\t\t\t  (match_operand:SI 1 \"arith_operand\" \"rI\"))\n \t\t\t (const_int 0)))]\n@@ -3527,7 +3586,7 @@\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_ccx_plus\"\n-  [(set (reg:CCX_NOOV 0)\n+  [(set (reg:CCX_NOOV 100)\n \t(compare:CCX_NOOV (plus:DI (match_operand:DI 0 \"arith_double_operand\" \"%r\")\n \t\t\t\t   (match_operand:DI 1 \"arith_double_operand\" \"rHI\"))\n \t\t\t  (const_int 0)))]\n@@ -3536,7 +3595,7 @@\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_cc_plus_set\"\n-  [(set (reg:CC_NOOV 0)\n+  [(set (reg:CC_NOOV 100)\n \t(compare:CC_NOOV (plus:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n \t\t\t\t  (match_operand:SI 2 \"arith_operand\" \"rI\"))\n \t\t\t (const_int 0)))\n@@ -3546,7 +3605,7 @@\n   \"addcc %1,%2,%0\")\n \n (define_insn \"*cmp_ccx_plus_set\"\n-  [(set (reg:CCX_NOOV 0)\n+  [(set (reg:CCX_NOOV 100)\n \t(compare:CCX_NOOV (plus:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n \t\t\t\t   (match_operand:DI 2 \"arith_double_operand\" \"rHI\"))\n \t\t\t  (const_int 0)))\n@@ -3568,7 +3627,8 @@\n \t\t\t  gen_rtx (SET, VOIDmode, operands[0],\n \t\t\t\t   gen_rtx (MINUS, DImode, operands[1],\n \t\t\t\t\t\t   operands[2])),\n-\t\t\t  gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 0)))));\n+\t\t\t  gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t   gen_rtx (REG, SImode, SPARC_ICC_REG)))));\n       DONE;\n     }\n }\")\n@@ -3577,7 +3637,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t  (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n-   (clobber (reg:SI 0))]\n+   (clobber (reg:SI 100))]\n   \"! TARGET_ARCH64\"\n   \"*\n {\n@@ -3625,7 +3685,7 @@\n   [(set_attr \"type\" \"ialu\")])\n \n (define_insn \"*cmp_minus_cc\"\n-  [(set (reg:CC_NOOV 0)\n+  [(set (reg:CC_NOOV 100)\n \t(compare:CC_NOOV (minus:SI (match_operand:SI 0 \"register_operand\" \"r\")\n \t\t\t\t   (match_operand:SI 1 \"arith_operand\" \"rI\"))\n \t\t\t (const_int 0)))]\n@@ -3634,7 +3694,7 @@\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_minus_ccx\"\n-  [(set (reg:CCX_NOOV 0)\n+  [(set (reg:CCX_NOOV 100)\n \t(compare:CCX_NOOV (minus:DI (match_operand:DI 0 \"register_operand\" \"r\")\n \t\t\t\t    (match_operand:DI 1 \"arith_double_operand\" \"rHI\"))\n \t\t\t  (const_int 0)))]\n@@ -3643,7 +3703,7 @@\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_minus_cc_set\"\n-  [(set (reg:CC_NOOV 0)\n+  [(set (reg:CC_NOOV 100)\n \t(compare:CC_NOOV (minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t\t   (match_operand:SI 2 \"arith_operand\" \"rI\"))\n \t\t\t (const_int 0)))\n@@ -3653,7 +3713,7 @@\n   \"subcc %1,%2,%0\")\n \n (define_insn \"*cmp_minus_ccx_set\"\n-  [(set (reg:CCX_NOOV 0)\n+  [(set (reg:CCX_NOOV 100)\n \t(compare:CCX_NOOV (minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t\t\t    (match_operand:DI 2 \"arith_double_operand\" \"rHI\"))\n \t\t\t  (const_int 0)))\n@@ -3689,7 +3749,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(mult:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n \t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))\n-   (set (reg:CC_NOOV 0)\n+   (set (reg:CC_NOOV 100)\n \t(compare:CC_NOOV (mult:SI (match_dup 1) (match_dup 2))\n \t\t\t (const_int 0)))]\n   \"TARGET_V8 || TARGET_SPARCLITE || TARGET_DEPRECATED_V8_INSNS\"\n@@ -3865,7 +3925,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(div:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))\n-   (set (reg:CC 0)\n+   (set (reg:CC 100)\n \t(compare:CC (div:SI (match_dup 1) (match_dup 2))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:SI 3 \"=&r\"))]\n@@ -3910,7 +3970,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(udiv:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))\n-   (set (reg:CC 0)\n+   (set (reg:CC 100)\n \t(compare:CC (udiv:SI (match_dup 1) (match_dup 2))\n \t\t    (const_int 0)))]\n   \"TARGET_V8 || TARGET_DEPRECATED_V8_INSNS\"\n@@ -4078,7 +4138,12 @@\n     {\n       int sign = INTVAL (op2);\n       if (sign < 0)\n-\treturn \\\"mov -1,%0\\;or %R1,%2,%R0\\\";\n+\t{\n+\t  if (TARGET_LIVE_G0)\n+\t    return \\\"and %0,0,%0\\;add %0,-1,%0\\;or %R1,%2,%R0\\\";\n+\t  else\n+\t    return \\\"mov -1,%0\\;or %R1,%2,%R0\\\";\n+\t}\n       return \\\"mov %1,%0\\;or %R1,%2,%R0\\\";\n     }\n   else if (GET_CODE (op2) == CONST_DOUBLE)\n@@ -4265,7 +4330,7 @@\n ;; want to set the condition code.  \n \n (define_insn \"*cmp_cc_arith_op\"\n-  [(set (reg:CC 0)\n+  [(set (reg:CC 100)\n \t(compare:CC\n \t (match_operator:SI 2 \"cc_arithop\"\n \t\t\t    [(match_operand:SI 0 \"arith_operand\" \"%r\")\n@@ -4276,7 +4341,7 @@\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_ccx_arith_op\"\n-  [(set (reg:CCX 0)\n+  [(set (reg:CCX 100)\n \t(compare:CCX\n \t (match_operator:DI 2 \"cc_arithop\"\n \t\t\t    [(match_operand:DI 0 \"arith_double_operand\" \"%r\")\n@@ -4287,7 +4352,7 @@\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_cc_arith_op_set\"\n-  [(set (reg:CC 0)\n+  [(set (reg:CC 100)\n \t(compare:CC\n \t (match_operator:SI 3 \"cc_arithop\"\n \t\t\t    [(match_operand:SI 1 \"arith_operand\" \"%r\")\n@@ -4299,7 +4364,7 @@\n   \"%A3cc %1,%2,%0\")\n \n (define_insn \"*cmp_ccx_arith_op_set\"\n-  [(set (reg:CCX 0)\n+  [(set (reg:CCX 100)\n \t(compare:CCX\n \t (match_operator:DI 3 \"cc_arithop\"\n \t\t\t    [(match_operand:DI 1 \"arith_double_operand\" \"%r\")\n@@ -4311,7 +4376,7 @@\n   \"%A3cc %1,%2,%0\")\n \n (define_insn \"*cmp_cc_xor_not\"\n-  [(set (reg:CC 0)\n+  [(set (reg:CC 100)\n \t(compare:CC\n \t (not:SI (xor:SI (match_operand:SI 0 \"reg_or_0_operand\" \"%rJ\")\n \t\t\t (match_operand:SI 1 \"arith_operand\" \"rI\")))\n@@ -4321,7 +4386,7 @@\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_ccx_xor_not\"\n-  [(set (reg:CCX 0)\n+  [(set (reg:CCX 100)\n \t(compare:CCX\n \t (not:DI (xor:DI (match_operand:DI 0 \"reg_or_0_operand\" \"%rJ\")\n \t\t\t (match_operand:DI 1 \"arith_double_operand\" \"rHI\")))\n@@ -4331,7 +4396,7 @@\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_cc_xor_not_set\"\n-  [(set (reg:CC 0)\n+  [(set (reg:CC 100)\n \t(compare:CC\n \t (not:SI (xor:SI (match_operand:SI 1 \"reg_or_0_operand\" \"%rJ\")\n \t\t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))\n@@ -4342,7 +4407,7 @@\n   \"xnorcc %r1,%2,%0\")\n \n (define_insn \"*cmp_ccx_xor_not_set\"\n-  [(set (reg:CCX 0)\n+  [(set (reg:CCX 100)\n \t(compare:CCX\n \t (not:DI (xor:DI (match_operand:DI 1 \"reg_or_0_operand\" \"%rJ\")\n \t\t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n@@ -4353,7 +4418,7 @@\n   \"xnorcc %r1,%2,%0\")\n \n (define_insn \"*cmp_cc_arith_op_not\"\n-  [(set (reg:CC 0)\n+  [(set (reg:CC 100)\n \t(compare:CC\n \t (match_operator:SI 2 \"cc_arithopn\"\n \t\t\t    [(not:SI (match_operand:SI 0 \"arith_operand\" \"rI\"))\n@@ -4364,7 +4429,7 @@\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_ccx_arith_op_not\"\n-  [(set (reg:CCX 0)\n+  [(set (reg:CCX 100)\n \t(compare:CCX\n \t (match_operator:DI 2 \"cc_arithopn\"\n \t\t\t    [(not:DI (match_operand:DI 0 \"arith_double_operand\" \"rHI\"))\n@@ -4375,7 +4440,7 @@\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_cc_arith_op_not_set\"\n-  [(set (reg:CC 0)\n+  [(set (reg:CC 100)\n \t(compare:CC\n \t (match_operator:SI 3 \"cc_arithopn\"\n \t\t\t    [(not:SI (match_operand:SI 1 \"arith_operand\" \"rI\"))\n@@ -4387,7 +4452,7 @@\n   \"%B3cc %r2,%1,%0\")\n \n (define_insn \"*cmp_ccx_arith_op_not_set\"\n-  [(set (reg:CCX 0)\n+  [(set (reg:CCX 100)\n \t(compare:CCX\n \t (match_operator:DI 3 \"cc_arithopn\"\n \t\t\t    [(not:DI (match_operand:DI 1 \"arith_double_operand\" \"rHI\"))\n@@ -4412,18 +4477,25 @@\n       emit_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (2,\n \t\t\t  gen_rtx (SET, VOIDmode, operand0,\n \t\t\t\t   gen_rtx (NEG, DImode, operand1)),\n-\t\t\t  gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 0)))));\n+\t\t\t  gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t   gen_rtx (REG, SImode, SPARC_ICC_REG)))));\n       DONE;\n     }\n }\")\n \n (define_insn \"*negdi2_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(neg:DI (match_operand:DI 1 \"register_operand\" \"r\")))\n-   (clobber (reg:SI 0))]\n+   (clobber (reg:SI 100))]\n   \"! TARGET_ARCH64\"\n-  \"subcc %%g0,%R1,%R0\\;subx %%g0,%1,%0\"\n+  \"*\n+{\n+  if (TARGET_LIVE_G0)\n+    output_asm_insn (\\\"and %%g0,0,%%g0\\\", operands);\n+  return \\\"subcc %%g0,%R1,%R0\\;subx %%g0,%1,%0\\\";\n+}\"\n   [(set_attr \"type\" \"unary\")\n+   ;; ??? This is wrong for TARGET_LIVE_G0 but it's not critical.\n    (set_attr \"length\" \"2\")])\n \n (define_insn \"*negdi2_sp64\"\n@@ -4438,37 +4510,44 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (match_operand:SI 1 \"arith_operand\" \"rI\")))]\n   \"\"\n-  \"sub %%g0,%1,%0\"\n-  [(set_attr \"type\" \"unary\")])\n+  \"*\n+{\n+  if (TARGET_LIVE_G0)\n+    return \\\"and %%g0,0,%%g0\\;sub %%g0,%1,%0\\\";\n+  return \\\"sub %%g0,%1,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"unary\")\n+   (set (attr \"length\")\n+\t(if_then_else (eq_attr \"live_g0\" \"yes\") (const_int 2) (const_int 1)))])\n \n (define_insn \"*cmp_cc_neg\"\n-  [(set (reg:CC_NOOV 0)\n+  [(set (reg:CC_NOOV 100)\n \t(compare:CC_NOOV (neg:SI (match_operand:SI 0 \"arith_operand\" \"rI\"))\n \t\t\t (const_int 0)))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"subcc %%g0,%0,%%g0\"\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_ccx_neg\"\n-  [(set (reg:CCX_NOOV 0)\n+  [(set (reg:CCX_NOOV 100)\n \t(compare:CCX_NOOV (neg:DI (match_operand:DI 0 \"arith_double_operand\" \"rHI\"))\n \t\t\t  (const_int 0)))]\n   \"TARGET_ARCH64\"\n   \"subcc %%g0,%0,%%g0\"\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_cc_set_neg\"\n-  [(set (reg:CC_NOOV 0)\n+  [(set (reg:CC_NOOV 100)\n \t(compare:CC_NOOV (neg:SI (match_operand:SI 1 \"arith_operand\" \"rI\"))\n \t\t\t (const_int 0)))\n    (set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (match_dup 1)))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"subcc %%g0,%1,%0\"\n   [(set_attr \"type\" \"unary\")])\n \n (define_insn \"*cmp_ccx_set_neg\"\n-  [(set (reg:CCX_NOOV 0)\n+  [(set (reg:CCX_NOOV 100)\n \t(compare:CCX_NOOV (neg:DI (match_operand:DI 1 \"arith_double_operand\" \"rHI\"))\n \t\t\t  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -4489,52 +4568,62 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(not:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n   \"! TARGET_ARCH64\"\n-  \"xnor %%g0,%1,%0\\;xnor %%g0,%R1,%R0\"\n+  \"xnor %1,0,%0\\;xnor %R1,0,%R0\"\n   [(set_attr \"type\" \"unary\")\n    (set_attr \"length\" \"2\")])\n \n (define_insn \"*one_cmpldi2_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(not:DI (match_operand:DI 1 \"arith_double_operand\" \"rHI\")))]\n   \"TARGET_ARCH64\"\n-  \"xnor %%g0,%1,%0\"\n+  \"xnor %1,0,%0\"\n   [(set_attr \"type\" \"unary\")])\n \n (define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(not:SI (match_operand:SI 1 \"arith_operand\" \"rI\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(not:SI (match_operand:SI 1 \"arith_operand\" \"r,I\")))]\n   \"\"\n-  \"xnor %%g0,%1,%0\"\n-  [(set_attr \"type\" \"unary\")])\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"xnor %1,0,%0\\\";\n+  if (TARGET_LIVE_G0)\n+    output_asm_insn (\\\"and %%g0,0,%%g0\\\", operands);\n+  return \\\"xnor %%g0,%1,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr_alternative \"length\"\n+     [(const_int 1)\n+      (if_then_else (eq_attr \"live_g0\" \"yes\") (const_int 2) (const_int 1))])])\n \n (define_insn \"*cmp_cc_not\"\n-  [(set (reg:CC 0)\n+  [(set (reg:CC 100)\n \t(compare:CC (not:SI (match_operand:SI 0 \"arith_operand\" \"rI\"))\n \t\t    (const_int 0)))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"xnorcc %%g0,%0,%%g0\"\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_ccx_not\"\n-  [(set (reg:CCX 0)\n+  [(set (reg:CCX 100)\n \t(compare:CCX (not:DI (match_operand:DI 0 \"arith_double_operand\" \"rHI\"))\n \t\t     (const_int 0)))]\n   \"TARGET_ARCH64\"\n   \"xnorcc %%g0,%0,%%g0\"\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_cc_set_not\"\n-  [(set (reg:CC 0)\n+  [(set (reg:CC 100)\n \t(compare:CC (not:SI (match_operand:SI 1 \"arith_operand\" \"rI\"))\n \t\t    (const_int 0)))\n    (set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(not:SI (match_dup 1)))]\n-  \"\"\n+  \"! TARGET_LIVE_G0\"\n   \"xnorcc %%g0,%1,%0\"\n   [(set_attr \"type\" \"unary\")])\n \n (define_insn \"*cmp_ccx_set_not\"\n-  [(set (reg:CCX 0)\n+  [(set (reg:CCX 100)\n \t(compare:CCX (not:DI (match_operand:DI 1 \"arith_double_operand\" \"rHI\"))\n \t\t    (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -4797,7 +4886,7 @@\n }\")\n \n (define_insn \"*cmp_cc_ashift_1\"\n-  [(set (reg:CC_NOOV 0)\n+  [(set (reg:CC_NOOV 100)\n \t(compare:CC_NOOV (ashift:SI (match_operand:SI 0 \"register_operand\" \"r\")\n \t\t\t\t    (const_int 1))\n \t\t\t (const_int 0)))]\n@@ -4806,7 +4895,7 @@\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_cc_set_ashift_1\"\n-  [(set (reg:CC_NOOV 0)\n+  [(set (reg:CC_NOOV 100)\n \t(compare:CC_NOOV (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t\t    (const_int 1))\n \t\t\t (const_int 0)))\n@@ -5379,7 +5468,12 @@\n \t(ffs:SI (match_operand:SI 1 \"register_operand\" \"r\")))\n    (clobber (match_scratch:SI 2 \"=&r\"))]\n   \"TARGET_SPARCLITE || TARGET_SPARCLET\"\n-  \"sub %%g0,%1,%0\\;and %0,%1,%0\\;scan %0,0,%0\\;mov 32,%2\\;sub %2,%0,%0\\;sra %0,31,%2\\;and %2,31,%2\\;add %2,%0,%0\"\n+  \"*\n+{\n+  if (TARGET_LIVE_G0)\n+    output_asm_insn (\\\"and %%g0,0,%%g0\\\", operands);\n+  return \\\"sub %%g0,%1,%0\\;and %0,%1,%0\\;scan %0,0,%0\\;mov 32,%2\\;sub %2,%0,%0\\;sra %0,31,%2\\;and %2,31,%2\\;add %2,%0,%0\\\";\n+}\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"8\")])\n \n@@ -5391,7 +5485,7 @@\n \t(ffs:DI (match_operand:DI 1 \"register_operand\" \"r\")))\n    (clobber (match_scratch:DI 2 \"=&r\"))]\n   \"TARGET_ARCH64\"\n-  \"neg %1,%2\\;not %2,%2\\;xor %1,%2,%2\\;popc %2,%0\\;movrz %1,%%g0,%0\"\n+  \"neg %1,%2\\;not %2,%2\\;xor %1,%2,%2\\;popc %2,%0\\;movrz %1,0,%0\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"5\")])\n \f\n@@ -5502,56 +5596,56 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ne:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t       (const_int 0)))\n-   (clobber (reg:CC 0))]\n+   (clobber (reg:CC 100))]\n   \"\"\n-  [(set (reg:CC_NOOV 0) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t (const_int 0)))\n-   (set (match_dup 0) (ltu:SI (reg:CC 0) (const_int 0)))]\n+  [(set (reg:CC_NOOV 100) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t   (const_int 0)))\n+   (set (match_dup 0) (ltu:SI (reg:CC 100) (const_int 0)))]\n   \"\")\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(neg:SI (ne:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t       (const_int 0))))\n-   (clobber (reg:CC 0))]\n+   (clobber (reg:CC 100))]\n   \"\"\n-  [(set (reg:CC_NOOV 0) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t (const_int 0)))\n-   (set (match_dup 0) (neg:SI (ltu:SI (reg:CC 0) (const_int 0))))]\n+  [(set (reg:CC_NOOV 100) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t   (const_int 0)))\n+   (set (match_dup 0) (neg:SI (ltu:SI (reg:CC 100) (const_int 0))))]\n   \"\")\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(eq:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t       (const_int 0)))\n-   (clobber (reg:CC 0))]\n+   (clobber (reg:CC 100))]\n   \"\"\n-  [(set (reg:CC_NOOV 0) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t (const_int 0)))\n-   (set (match_dup 0) (geu:SI (reg:CC 0) (const_int 0)))]\n+  [(set (reg:CC_NOOV 100) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t   (const_int 0)))\n+   (set (match_dup 0) (geu:SI (reg:CC 100) (const_int 0)))]\n   \"\")\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(neg:SI (eq:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t       (const_int 0))))\n-   (clobber (reg:CC 0))]\n+   (clobber (reg:CC 100))]\n   \"\"\n-  [(set (reg:CC_NOOV 0) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t (const_int 0)))\n-   (set (match_dup 0) (neg:SI (geu:SI (reg:CC 0) (const_int 0))))]\n+  [(set (reg:CC_NOOV 100) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t   (const_int 0)))\n+   (set (match_dup 0) (neg:SI (geu:SI (reg:CC 100) (const_int 0))))]\n   \"\")\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(plus:SI (ne:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t\t(const_int 0))\n \t\t (match_operand:SI 2 \"register_operand\" \"\")))\n-   (clobber (reg:CC 0))]\n+   (clobber (reg:CC 100))]\n   \"\"\n-  [(set (reg:CC_NOOV 0) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t (const_int 0)))\n-   (set (match_dup 0) (plus:SI (ltu:SI (reg:CC 0) (const_int 0))\n+  [(set (reg:CC_NOOV 100) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t   (const_int 0)))\n+   (set (match_dup 0) (plus:SI (ltu:SI (reg:CC 100) (const_int 0))\n \t\t\t       (match_dup 2)))]\n   \"\")\n \n@@ -5560,24 +5654,24 @@\n \t(minus:SI (match_operand:SI 2 \"register_operand\" \"\")\n \t\t  (ne:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t\t (const_int 0))))\n-   (clobber (reg:CC 0))]\n+   (clobber (reg:CC 100))]\n   \"\"\n-  [(set (reg:CC_NOOV 0) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t (const_int 0)))\n+  [(set (reg:CC_NOOV 100) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t   (const_int 0)))\n    (set (match_dup 0) (minus:SI (match_dup 2)\n-\t\t\t\t(ltu:SI (reg:CC 0) (const_int 0))))]\n+\t\t\t\t(ltu:SI (reg:CC 100) (const_int 0))))]\n   \"\")\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(plus:SI (eq:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t\t(const_int 0))\n \t\t (match_operand:SI 2 \"register_operand\" \"\")))\n-   (clobber (reg:CC 0))]\n+   (clobber (reg:CC 100))]\n   \"\"\n-  [(set (reg:CC_NOOV 0) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t (const_int 0)))\n-   (set (match_dup 0) (plus:SI (geu:SI (reg:CC 0) (const_int 0))\n+  [(set (reg:CC_NOOV 100) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t   (const_int 0)))\n+   (set (match_dup 0) (plus:SI (geu:SI (reg:CC 100) (const_int 0))\n \t\t\t       (match_dup 2)))]\n   \"\")\n \n@@ -5586,12 +5680,12 @@\n \t(minus:SI (match_operand:SI 2 \"register_operand\" \"\")\n \t\t  (eq:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t\t (const_int 0))))\n-   (clobber (reg:CC 0))]\n+   (clobber (reg:CC 100))]\n   \"\"\n-  [(set (reg:CC_NOOV 0) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t (const_int 0)))\n+  [(set (reg:CC_NOOV 100) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t   (const_int 0)))\n    (set (match_dup 0) (minus:SI (match_dup 2)\n-\t\t\t\t(geu:SI (reg:CC 0) (const_int 0))))]\n+\t\t\t\t(geu:SI (reg:CC 100) (const_int 0))))]\n   \"\")\n \f\n ;; Peepholes go at the end.\n@@ -5695,25 +5789,25 @@\n (define_peephole\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(match_operand:SI 1 \"register_operand\" \"r\"))\n-   (set (reg:CC 0)\n+   (set (reg:CC 100)\n \t(compare:CC (match_operand:SI 2 \"register_operand\" \"r\")\n \t\t    (const_int 0)))]\n   \"(rtx_equal_p (operands[2], operands[0])\n     || rtx_equal_p (operands[2], operands[1]))\n    && ! FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])\"\n-  \"orcc %1,%%g0,%0\")\n+  \"orcc %1,0,%0\")\n \n (define_peephole\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(match_operand:DI 1 \"register_operand\" \"r\"))\n-   (set (reg:CCX 0)\n+   (set (reg:CCX 100)\n \t(compare:CCX (match_operand:DI 2 \"register_operand\" \"r\")\n \t\t    (const_int 0)))]\n   \"TARGET_ARCH64\n    && (rtx_equal_p (operands[2], operands[0])\n        || rtx_equal_p (operands[2], operands[1]))\n    && ! FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])\"\n-  \"orcc %1,%%g0,%0\")\n+  \"orcc %1,0,%0\")\n \n ;; Do {sign,zero}-extended compares somewhat more efficiently.\n ;; ??? Is this now the Right Way to do this?  Or will SCRATCH\n@@ -5724,44 +5818,44 @@\n \t(match_operand:HI 1 \"memory_operand\" \"\"))\n    (set (match_operand:SI 2 \"register_operand\" \"\")\n \t(sign_extend:SI (match_dup 0)))\n-   (set (reg:CC 0)\n+   (set (reg:CC 100)\n \t(compare:CC (match_dup 2)\n \t\t    (const_int 0)))]\n   \"\"\n-  \"ldsh %1,%0\\;orcc %0,%%g0,%2\")\n+  \"ldsh %1,%0\\;orcc %0,0,%2\")\n \n (define_peephole\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(match_operand:HI 1 \"memory_operand\" \"\"))\n    (set (match_operand:DI 2 \"register_operand\" \"\")\n \t(sign_extend:DI (match_dup 0)))\n-   (set (reg:CCX 0)\n+   (set (reg:CCX 100)\n \t(compare:CCX (match_dup 2)\n \t\t     (const_int 0)))]\n   \"TARGET_ARCH64\"\n-  \"ldsh %1,%0\\;orcc %0,%%g0,%2\")\n+  \"ldsh %1,%0\\;orcc %0,0,%2\")\n \n (define_peephole\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(match_operand:QI 1 \"memory_operand\" \"\"))\n    (set (match_operand:SI 2 \"register_operand\" \"\")\n \t(sign_extend:SI (match_dup 0)))\n-   (set (reg:CC 0)\n+   (set (reg:CC 100)\n \t(compare:CC (match_dup 2)\n \t\t    (const_int 0)))]\n   \"\"\n-  \"ldsb %1,%0\\;orcc %0,%%g0,%2\")\n+  \"ldsb %1,%0\\;orcc %0,0,%2\")\n \n (define_peephole\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(match_operand:QI 1 \"memory_operand\" \"\"))\n    (set (match_operand:DI 2 \"register_operand\" \"\")\n \t(sign_extend:DI (match_dup 0)))\n-   (set (reg:CCX 0)\n+   (set (reg:CCX 100)\n \t(compare:CCX (match_dup 2)\n \t\t     (const_int 0)))]\n   \"TARGET_ARCH64\"\n-  \"ldsb %1,%0\\;orcc %0,%%g0,%2\")\n+  \"ldsb %1,%0\\;orcc %0,0,%2\")\n \n ;; Floating-point move peepholes\n ;; ??? v9: Do we want similar ones?\n@@ -5792,16 +5886,14 @@\n   \"RTX_UNCHANGING_P (operands[1]) && reg_unused_after (operands[0], insn)\"\n   \"ld [%0+%%lo(%a1)],%2\")\n \n-;; Return peepholes.  First the \"normal\" ones\n-\n-;; ??? There are QImode, HImode, and SImode versions of this pattern.\n-;; It might be possible to write one more general pattern instead of three.\n+;; Return peepholes.  First the \"normal\" ones.\n+;; These are necessary to catch insns ending up in the epilogue delay list.\n \n (define_insn \"*return_qi\"\n   [(set (match_operand:QI 0 \"restore_operand\" \"\")\n \t(match_operand:QI 1 \"arith_operand\" \"rI\"))\n    (return)]\n-  \"! TARGET_EPILOGUE\"\n+  \"! TARGET_EPILOGUE && ! TARGET_LIVE_G0\"\n   \"*\n {\n   if (! TARGET_ARCH64 && current_function_returns_struct)\n@@ -5815,7 +5907,7 @@\n   [(set (match_operand:HI 0 \"restore_operand\" \"\")\n \t(match_operand:HI 1 \"arith_operand\" \"rI\"))\n    (return)]\n-  \"! TARGET_EPILOGUE\"\n+  \"! TARGET_EPILOGUE && ! TARGET_LIVE_G0\"\n   \"*\n {\n   if (! TARGET_ARCH64 && current_function_returns_struct)\n@@ -5829,7 +5921,7 @@\n   [(set (match_operand:SI 0 \"restore_operand\" \"\")\n \t(match_operand:SI 1 \"arith_operand\" \"rI\"))\n    (return)]\n-  \"! TARGET_EPILOGUE\"\n+  \"! TARGET_EPILOGUE && ! TARGET_LIVE_G0\"\n   \"*\n {\n   if (! TARGET_ARCH64 && current_function_returns_struct)\n@@ -5846,7 +5938,7 @@\n   [(set (match_operand:SF 0 \"restore_operand\" \"r\")\n \t(match_operand:SF 1 \"register_operand\" \"r\"))\n    (return)]\n-  \"! TARGET_FPU && ! TARGET_EPILOGUE\"\n+  \"! TARGET_FPU && ! TARGET_EPILOGUE && ! TARGET_LIVE_G0\"\n   \"*\n {\n   if (! TARGET_ARCH64 && current_function_returns_struct)\n@@ -5861,7 +5953,7 @@\n \t(plus:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n \t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))\n    (return)]\n-  \"! TARGET_EPILOGUE\"\n+  \"! TARGET_EPILOGUE && ! TARGET_LIVE_G0\"\n   \"*\n {\n   if (! TARGET_ARCH64 && current_function_returns_struct)\n@@ -5951,11 +6043,12 @@\n \n ;; Other miscellaneous peepholes.\n \n+;; (reg:SI 100) is created by the {add,neg,sub}di patterns.\n (define_peephole\n   [(parallel [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t\t   (minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t     (reg:SI 0)))\n-\t      (clobber (reg:CC 0))])\n-   (set (reg:CC 0) (compare (match_dup 0) (const_int 0)))]\n+\t\t\t     (reg:SI 100)))\n+\t      (clobber (reg:CC 100))])\n+   (set (reg:CC 100) (compare (match_dup 0) (const_int 0)))]\n   \"\"\n   \"subxcc %r1,0,%0\")"}]}