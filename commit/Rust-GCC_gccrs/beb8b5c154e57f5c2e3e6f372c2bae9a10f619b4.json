{"sha": "beb8b5c154e57f5c2e3e6f372c2bae9a10f619b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmViOGI1YzE1NGU1N2Y1YzJlM2U2ZjM3MmMyYmFlOWExMGY2MTliNA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-09-01T16:34:29Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-09-01T16:34:29Z"}, "message": "class.c (finish_struct_methods): Done clear DECL_IN_AGGR_P here.\n\n\t* class.c (finish_struct_methods): Done clear DECL_IN_AGGR_P here.\n\tDon't call maybe_warn_about_overly_private_class here.\n\t(warn_hidden): Cleanup declarations and comments.\n\t(type_has_user_provided_constructor): No need to check\n\tCLASSTYPE_METHOD_VEC.\n\t(type_has_user_provided_or_explicit_constructor): Likewise.\n\t(classtype_has_move_assign_or_move_ctor_p): Likewise.\n\t(check_bases_and_members): Don't call finish_struct_methods here.\n\t(finish_struct_1): Call finish_struct_methods and\n\tset_class_bindings immediately after layout.  Clear DECL_IN_AGGR_P\n\there.\n\t(finish_struct): For templates process USING_DECLS and clear\n\tDECL_IN_AGGR_P before calling finish_struct_methods. Call\n\tmaybe_warn_about_overly_private_class here.\n\nFrom-SVN: r251604", "tree": {"sha": "a2ac65fe4063afb49b3d7b389ddbe0ab6457029a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2ac65fe4063afb49b3d7b389ddbe0ab6457029a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/beb8b5c154e57f5c2e3e6f372c2bae9a10f619b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beb8b5c154e57f5c2e3e6f372c2bae9a10f619b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beb8b5c154e57f5c2e3e6f372c2bae9a10f619b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beb8b5c154e57f5c2e3e6f372c2bae9a10f619b4/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e035be33793fa4aef8cff3358c9670a648d5d273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e035be33793fa4aef8cff3358c9670a648d5d273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e035be33793fa4aef8cff3358c9670a648d5d273"}], "stats": {"total": 114, "additions": 55, "deletions": 59}, "files": [{"sha": "bd6c33639acfb0ada2e9d1cdb06c3ba8a72b1268", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beb8b5c154e57f5c2e3e6f372c2bae9a10f619b4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beb8b5c154e57f5c2e3e6f372c2bae9a10f619b4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=beb8b5c154e57f5c2e3e6f372c2bae9a10f619b4", "patch": "@@ -1,5 +1,20 @@\n 2017-09-01  Nathan Sidwell  <nathan@acm.org>\n \n+\t* class.c (finish_struct_methods): Done clear DECL_IN_AGGR_P here.\n+\tDon't call maybe_warn_about_overly_private_class here.\n+\t(warn_hidden): Cleanup declarations and comments.\n+\t(type_has_user_provided_constructor): No need to check\n+\tCLASSTYPE_METHOD_VEC.\n+\t(type_has_user_provided_or_explicit_constructor): Likewise.\n+\t(classtype_has_move_assign_or_move_ctor_p): Likewise.\n+\t(check_bases_and_members): Don't call finish_struct_methods here.\n+\t(finish_struct_1): Call finish_struct_methods and\n+\tset_class_bindings immediately after layout.  Clear DECL_IN_AGGR_P\n+\there.\n+\t(finish_struct): For templates process USING_DECLS and clear\n+\tDECL_IN_AGGR_P before calling finish_struct_methods. Call\n+\tmaybe_warn_about_overly_private_class here.\n+\n \tRevert 2017-08-28  Nathan Sidwell  <nathan@acm.org>\n \tRestore sorted_fields vector.\n \t* cp-tree.h (lang_type): Restore sorted_fields vector."}, {"sha": "25ff9ed4046b6d6d6ad2c682e14ac6bbf3489875", "filename": "gcc/cp/class.c", "status": "modified", "additions": 40, "deletions": 59, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beb8b5c154e57f5c2e3e6f372c2bae9a10f619b4/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beb8b5c154e57f5c2e3e6f372c2bae9a10f619b4/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=beb8b5c154e57f5c2e3e6f372c2bae9a10f619b4", "patch": "@@ -2313,15 +2313,6 @@ finish_struct_methods (tree t)\n   if (!method_vec)\n     return;\n \n-  /* Clear DECL_IN_AGGR_P for all functions.  */\n-  for (tree fn = TYPE_FIELDS (t); fn; fn = DECL_CHAIN (fn))\n-    if (DECL_DECLARES_FUNCTION_P (fn))\n-      DECL_IN_AGGR_P (fn) = false;\n-\n-  /* Issue warnings about private constructors and such.  If there are\n-     no methods, then some public defaults are generated.  */\n-  maybe_warn_about_overly_private_class (t);\n-\n   qsort (method_vec->address (), method_vec->length (),\n \t sizeof (tree), method_name_cmp);\n }\n@@ -2976,16 +2967,12 @@ warn_hidden (tree t)\n   /* We go through each separately named virtual function.  */\n   for (int i = 0; vec_safe_iterate (method_vec, i, &fns); ++i)\n     {\n-      tree fndecl;\n+      tree name = OVL_NAME (fns);\n+      auto_vec<tree, 20> base_fndecls;\n       tree base_binfo;\n       tree binfo;\n       int j;\n \n-      /* All functions in this slot in the CLASSTYPE_METHOD_VEC will\n-\t have the same name.  Figure out what name that is.  */\n-      tree name = OVL_NAME (fns);\n-      /* There are no possibly hidden functions yet.  */\n-      auto_vec<tree, 20> base_fndecls;\n       /* Iterate through all of the base classes looking for possibly\n \t hidden functions.  */\n       for (binfo = TYPE_BINFO (t), j = 0;\n@@ -3002,14 +2989,14 @@ warn_hidden (tree t)\n       /* Remove any overridden functions.  */\n       for (ovl_iterator iter (fns); iter; ++iter)\n \t{\n-\t  fndecl = *iter;\n+\t  tree fndecl = *iter;\n \t  if (TREE_CODE (fndecl) == FUNCTION_DECL\n \t      && DECL_VINDEX (fndecl))\n \t    {\n-\t\t/* If the method from the base class has the same\n-\t\t   signature as the method from the derived class, it\n-\t\t   has been overridden.  */\n-\t\tfor (size_t k = 0; k < base_fndecls.length (); k++)\n+\t      /* If the method from the base class has the same\n+\t\t signature as the method from the derived class, it\n+\t\t has been overridden.  */\n+\t      for (size_t k = 0; k < base_fndecls.length (); k++)\n \t\tif (base_fndecls[k]\n \t\t    && same_signature_p (fndecl, base_fndecls[k]))\n \t\t  base_fndecls[k] = NULL_TREE;\n@@ -4892,11 +4879,6 @@ adjust_clone_args (tree decl)\n static void\n clone_constructors_and_destructors (tree t)\n {\n-  /* If for some reason we don't have a CLASSTYPE_METHOD_VEC, we bail\n-     out now.  */\n-  if (!CLASSTYPE_METHOD_VEC (t))\n-    return;\n-\n   /* While constructors can be via a using declaration, at this point\n      we no longer need to know that.  */\n   for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n@@ -5134,10 +5116,6 @@ type_has_user_provided_constructor (tree t)\n   if (!TYPE_HAS_USER_CONSTRUCTOR (t))\n     return false;\n \n-  /* This can happen in error cases; avoid crashing.  */\n-  if (!CLASSTYPE_METHOD_VEC (t))\n-    return false;\n-\n   for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n     if (user_provided_p (*iter))\n       return true;\n@@ -5156,10 +5134,6 @@ type_has_user_provided_or_explicit_constructor (tree t)\n   if (!TYPE_HAS_USER_CONSTRUCTOR (t))\n     return false;\n \n-  /* This can happen in error cases; avoid crashing.  */\n-  if (!CLASSTYPE_METHOD_VEC (t))\n-    return false;\n-\n   for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n     {\n       tree fn = *iter;\n@@ -5348,9 +5322,6 @@ classtype_has_move_assign_or_move_ctor_p (tree t, bool user_p)\n \t      || (!CLASSTYPE_LAZY_MOVE_CTOR (t)\n \t\t  && !CLASSTYPE_LAZY_MOVE_ASSIGN (t)));\n \n-  if (!CLASSTYPE_METHOD_VEC (t))\n-    return false;\n-\n   if (!CLASSTYPE_LAZY_MOVE_CTOR (t))\n     for (ovl_iterator iter (lookup_fnfields_slot_nolazy (t, ctor_identifier));\n \t iter; ++iter)\n@@ -5840,9 +5811,6 @@ check_bases_and_members (tree t)\n   for (; access_decls; access_decls = TREE_CHAIN (access_decls))\n     handle_using_decl (TREE_VALUE (access_decls), t);\n \n-  /* Build and sort the CLASSTYPE_METHOD_VEC.  */\n-  finish_struct_methods (t);\n-\n   /* Figure out whether or not we will need a cookie when dynamically\n      allocating an array of this type.  */\n   LANG_TYPE_CLASS_CHECK (t)->vec_new_uses_cookie\n@@ -6996,6 +6964,11 @@ finish_struct_1 (tree t)\n \n   /* Layout the class itself.  */\n   layout_class_type (t, &virtuals);\n+  /* COMPLETE_TYPE_P is now true.  */\n+\n+  finish_struct_methods (t);\n+  set_class_bindings (t, TYPE_FIELDS (t));\n+\n   if (CLASSTYPE_AS_BASE (t) != t)\n     /* We use the base type for trivial assignments, and hence it\n        needs a mode.  */\n@@ -7060,20 +7033,21 @@ finish_struct_1 (tree t)\n     }\n \n   finish_struct_bits (t);\n+\n   set_method_tm_attributes (t);\n   if (flag_openmp || flag_openmp_simd)\n     finish_omp_declare_simd_methods (t);\n \n-  /* Complete the rtl for any static member objects of the type we're\n-     working on.  */\n+  /* Clear DECL_IN_AGGR_P for all member functions.  Complete the rtl\n+     for any static member objects of the type we're working on.  */\n   for (x = TYPE_FIELDS (t); x; x = DECL_CHAIN (x))\n-    if (VAR_P (x) && TREE_STATIC (x)\n-        && TREE_TYPE (x) != error_mark_node\n-\t&& same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (x)), t))\n+    if (DECL_DECLARES_FUNCTION_P (x))\n+      DECL_IN_AGGR_P (x) = false;\n+    else if (VAR_P (x) && TREE_STATIC (x)\n+\t     && TREE_TYPE (x) != error_mark_node\n+\t     && same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (x)), t))\n       SET_DECL_MODE (x, TYPE_MODE (t));\n \n-  set_class_bindings (t, TYPE_FIELDS (t));\n-\n   /* Complain if one of the field types requires lower visibility.  */\n   constrain_class_visibility (t);\n \n@@ -7195,9 +7169,25 @@ finish_struct (tree t, tree attributes)\n     {\n       tree x;\n \n-      finish_struct_methods (t);\n+      /* We need to add the target functions of USING_DECLS, so that\n+\t they can be found when the using declaration is not\n+\t instantiated yet.  */\n+      for (x = TYPE_FIELDS (t); x; x = DECL_CHAIN (x))\n+\tif (TREE_CODE (x) == USING_DECL)\n+\t  {\n+\t    tree fn = strip_using_decl (x);\n+  \t    if (OVL_P (fn))\n+\t      for (lkp_iterator iter (fn); iter; ++iter)\n+\t\tadd_method (t, *iter, true);\n+\t  }\n+\telse if (DECL_DECLARES_FUNCTION_P (x))\n+\t  DECL_IN_AGGR_P (x) = false;\n+\n       TYPE_SIZE (t) = bitsize_zero_node;\n       TYPE_SIZE_UNIT (t) = size_zero_node;\n+      /* COMPLETE_TYPE_P is now true.  */\n+\n+      finish_struct_methods (t);\n \n       /* We need to emit an error message if this type was used as a parameter\n \t and it is an abstract type, even if it is a template. We construct\n@@ -7211,18 +7201,6 @@ finish_struct (tree t, tree attributes)\n \tif (TREE_CODE (x) == FUNCTION_DECL && DECL_PURE_VIRTUAL_P (x))\n \t  vec_safe_push (CLASSTYPE_PURE_VIRTUALS (t), x);\n       complete_vars (t);\n-      /* We need to add the target functions to the CLASSTYPE_METHOD_VEC if\n-\t an enclosing scope is a template class, so that this function be\n-\t found by lookup_fnfields_1 when the using declaration is not\n-\t instantiated yet.  */\n-      for (x = TYPE_FIELDS (t); x; x = DECL_CHAIN (x))\n-\tif (TREE_CODE (x) == USING_DECL)\n-\t  {\n-\t    tree fn = strip_using_decl (x);\n-  \t    if (OVL_P (fn))\n-\t      for (lkp_iterator iter (fn); iter; ++iter)\n-\t\tadd_method (t, *iter, true);\n-\t  }\n \n       /* Remember current #pragma pack value.  */\n       TYPE_PRECISION (t) = maximum_field_alignment;\n@@ -7237,7 +7215,10 @@ finish_struct (tree t, tree attributes)\n     }\n   else\n     finish_struct_1 (t);\n+  /* COMPLETE_TYPE_P is now true.  */\n \n+  maybe_warn_about_overly_private_class (t);\n+  \n   if (is_std_init_list (t))\n     {\n       /* People keep complaining that the compiler crashes on an invalid"}]}