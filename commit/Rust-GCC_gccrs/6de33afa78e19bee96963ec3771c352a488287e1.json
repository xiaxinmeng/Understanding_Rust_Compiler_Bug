{"sha": "6de33afa78e19bee96963ec3771c352a488287e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRlMzNhZmE3OGUxOWJlZTk2OTYzZWMzNzcxYzM1MmE0ODgyODdlMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-05-25T22:08:31Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-05-25T22:08:31Z"}, "message": "re PR libgcj/21692 (unexpected java.lang.NoClassDefFoundError)\n\n\tPR libgcj/21692\ncp/\n        * cp-tree.h (make_alias_for): Declare.\n        * decl2.c (build_java_method_aliases): New.\n        (cp_finish_file): Call it.\n        * method.c (make_alias_for): Split out from ...\n        (make_alias_for_thunk): ... here.\n\njava/\n        * Make-lang.in (java/mangle.o): Depend on LANGHOOKS_DEF_H.\n        * class.c (build_class_ref): Set DECL_CLASS_FIELD_P and\n        DECL_CONTEXT; avoid pushdecl_top_level.\n        (build_dtable_decl): Set DECL_VTABLE_P and DECL_CONTEXT.\n        (layout_class): Don't SET_DECL_ASSEMBLER_NAME.\n        (layout_class_method): Likewise.\n        * decl.c (java_mark_cni_decl_local): New.\n        (java_mark_class_local): Use it.\n        * java-tree.h (DECL_LOCAL_CNI_METHOD_P): New.\n        (DECL_CLASS_FIELD_P, DECL_VTABLE_P): New.\n        (struct lang_decl_func): Add local_cni;\n        (struct lang_decl_var): Add class_field, vtable.\n        (java_mangle_decl): Declare.\n        * lang.c (LANG_HOOKS_SET_DECL_ASSEMBLER_NAME): New.\n        * mangle.c: Remove dup obstack.h; include langhooks-def.h.\n        (mangle_obstack_1): New.\n        (java_mangle_decl): Remove obstack argument.  Call mangle_class_field,\n        mangle_vtable, and mangle_local_cni_method_decl.  Fall back to\n        lhd_set_decl_assembler_name for things that don't need mangling.\n        (mangle_class_field): Rename from java_mangle_class_field, make\n        static, don't call init_mangling or finish_mangling.\n        (mangle_vtable): Similarly.\n        (mangle_local_cni_method_decl): New.\n        (init_mangling): Remove obstack argument.  Use &mangle_obstack_1,\n        gcc_assert, and MANGLE_RAW_STRING.\n        (finish_mangling): Use gcc_assert, remove if 0 debugging code.\n\nFrom-SVN: r100171", "tree": {"sha": "047bbcbef9a1b2d83cf20f62170c7df12ca50eff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/047bbcbef9a1b2d83cf20f62170c7df12ca50eff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6de33afa78e19bee96963ec3771c352a488287e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6de33afa78e19bee96963ec3771c352a488287e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6de33afa78e19bee96963ec3771c352a488287e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6de33afa78e19bee96963ec3771c352a488287e1/comments", "author": null, "committer": null, "parents": [{"sha": "81fc305201e8913727cb61303c4812730a95c59c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81fc305201e8913727cb61303c4812730a95c59c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81fc305201e8913727cb61303c4812730a95c59c"}], "stats": {"total": 337, "additions": 254, "deletions": 83}, "files": [{"sha": "25092d7b866513a79f41442536227c51527f4be8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6de33afa78e19bee96963ec3771c352a488287e1", "patch": "@@ -1,3 +1,12 @@\n+2005-05-25  Richard Henderson  <rth@redhat.com>\n+\n+\tPR libgcj/21692\n+\t* cp-tree.h (make_alias_for): Declare.\n+\t* decl2.c (build_java_method_aliases): New.\n+\t(cp_finish_file): Call it.\n+\t* method.c (make_alias_for): Split out from ...\n+\t(make_alias_for_thunk): ... here.\n+\n 2005-05-25  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/21686\n@@ -248,8 +257,8 @@\n \n 2005-05-02  Paolo Bonzini  <bonzini@gnu.org>\n \n-        * semantics.c (finish_call_expr): Call resolve_overloaded_builtin\n-        for BUILT_IN_MD built-ins.\n+\t* semantics.c (finish_call_expr): Call resolve_overloaded_builtin\n+\tfor BUILT_IN_MD built-ins.\n \n 2005-05-02  Michael Matz  <matz@suse.de>\n \n@@ -310,7 +319,7 @@\n 2005-04-22  Per Bothner  <per@bothner.com>\n \n \t* decl.c (make_rtl_for_nonlocal_decl): Don't try get_fileinfo if\n-        input_filename is NULL, as it is for (say) __PRETTY_FUNCTION__.\n+\tinput_filename is NULL, as it is for (say) __PRETTY_FUNCTION__.\n \n 2005-04-22  Alexandre Oliva  <aoliva@redhat.com>\n "}, {"sha": "fc0e20ce37c1eed539a9d9f71ef911b08f6fe7d1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6de33afa78e19bee96963ec3771c352a488287e1", "patch": "@@ -3923,6 +3923,7 @@ extern void synthesize_method (tree);\n extern tree implicitly_declare_fn (special_function_kind, tree, bool);\n extern tree lazily_declare_fn (special_function_kind, tree);\n extern tree skip_artificial_parms_for (tree, tree);\n+extern tree make_alias_for (tree, tree);\n \n /* In optimize.c */\n extern bool maybe_clone_body (tree);"}, {"sha": "732e429a1346964f988def9bed4cdca5a271e09f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6de33afa78e19bee96963ec3771c352a488287e1", "patch": "@@ -2731,6 +2731,50 @@ cxx_callgraph_analyze_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n   return NULL;\n }\n \n+/* Java requires that we be able to reference a local address for a\n+   method, and not be confused by PLT entries.  If hidden aliases are\n+   supported, emit one for each java function that we've emitted.  */\n+\n+static void\n+build_java_method_aliases (void)\n+{\n+  struct cgraph_node *node;\n+\n+#ifndef HAVE_GAS_HIDDEN\n+  return;\n+#endif\n+\n+  for (node = cgraph_nodes; node ; node = node->next)\n+    {\n+      tree fndecl = node->decl;\n+\n+      if (TREE_ASM_WRITTEN (fndecl)\n+\t  && DECL_CONTEXT (fndecl)\n+\t  && TYPE_P (DECL_CONTEXT (fndecl))\n+\t  && TYPE_FOR_JAVA (DECL_CONTEXT (fndecl))\n+\t  && TARGET_USE_LOCAL_THUNK_ALIAS_P (fndecl))\n+\t{\n+\t  /* Mangle the name in a predictable way; we need to reference\n+\t     this from a java compiled object file.  */\n+\t  tree oid, nid, alias;\n+\t  const char *oname;\n+\t  char *nname;\n+\n+\t  oid = DECL_ASSEMBLER_NAME (fndecl);\n+\t  oname = IDENTIFIER_POINTER (oid);\n+\t  gcc_assert (oname[0] == '_' && oname[1] == 'Z');\n+\t  nname = ACONCAT ((\"_ZGA\", oname+2, NULL));\n+\t  nid = get_identifier (nname);\n+\n+\t  alias = make_alias_for (fndecl, nid);\n+\t  TREE_PUBLIC (alias) = 1;\n+\t  DECL_VISIBILITY (alias) = VISIBILITY_HIDDEN;\n+\n+\t  assemble_alias (alias, oid);\n+\t}\n+    }\n+}\n+\n /* This routine is called from the last rule in yyparse ().\n    Its job is to create all the code needed to initialize and\n    destroy the global aggregates.  We do the destruction\n@@ -3062,6 +3106,9 @@ cp_finish_file (void)\n     check_global_declarations (VEC_address (tree, pending_statics),\n \t\t\t       VEC_length (tree, pending_statics));\n \n+  /* Generate hidden aliases for Java.  */\n+  build_java_method_aliases ();\n+\n   finish_repo ();\n \n   /* The entire file is now complete.  If requested, dump everything"}, {"sha": "37822bea78e2e8fef2e965a96c458752fd4b36c6", "filename": "gcc/cp/method.c", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=6de33afa78e19bee96963ec3771c352a488287e1", "patch": "@@ -258,16 +258,10 @@ static GTY (()) int thunk_labelno;\n \n /* Create a static alias to function.  */\n \n-static tree\n-make_alias_for_thunk (tree function)\n+tree\n+make_alias_for (tree function, tree newid)\n {\n-  tree alias;\n-  char buf[256];\n-\n-  ASM_GENERATE_INTERNAL_LABEL (buf, \"LTHUNK\", thunk_labelno);\n-  thunk_labelno++;\n-  alias = build_decl (FUNCTION_DECL, get_identifier (buf),\n-\t\t      TREE_TYPE (function));\n+  tree alias = build_decl (FUNCTION_DECL, newid, TREE_TYPE (function));\n   DECL_LANG_SPECIFIC (alias) = DECL_LANG_SPECIFIC (function);\n   cxx_dup_lang_specific_decl (alias);\n   DECL_CONTEXT (alias) = NULL;\n@@ -296,8 +290,23 @@ make_alias_for_thunk (tree function)\n   TREE_USED (alias) = 1;\n   SET_DECL_ASSEMBLER_NAME (alias, DECL_NAME (alias));\n   TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (alias)) = 1;\n+  return alias;\n+}\n+\n+static tree\n+make_alias_for_thunk (tree function)\n+{\n+  tree alias;\n+  char buf[256];\n+\n+  ASM_GENERATE_INTERNAL_LABEL (buf, \"LTHUNK\", thunk_labelno);\n+  thunk_labelno++;\n+\n+  alias = make_alias_for (function, get_identifier (buf));\n+\n   if (!flag_syntax_only)\n     assemble_alias (alias, DECL_ASSEMBLER_NAME (function));\n+\n   return alias;\n }\n "}, {"sha": "82a2ba8a615f9a7aa825c01f6019782186109d22", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=6de33afa78e19bee96963ec3771c352a488287e1", "patch": "@@ -1,3 +1,33 @@\n+2005-05-25  Richard Henderson  <rth@redhat.com>\n+\n+\tPR libgcj/21692\n+\t* Make-lang.in (java/mangle.o): Depend on LANGHOOKS_DEF_H.\n+\t* class.c (build_class_ref): Set DECL_CLASS_FIELD_P and\n+\tDECL_CONTEXT; avoid pushdecl_top_level.\n+\t(build_dtable_decl): Set DECL_VTABLE_P and DECL_CONTEXT.\n+\t(layout_class): Don't SET_DECL_ASSEMBLER_NAME.\n+\t(layout_class_method): Likewise.\n+\t* decl.c (java_mark_cni_decl_local): New.\n+\t(java_mark_class_local): Use it.\n+\t* java-tree.h (DECL_LOCAL_CNI_METHOD_P): New.\n+\t(DECL_CLASS_FIELD_P, DECL_VTABLE_P): New.\n+\t(struct lang_decl_func): Add local_cni;\n+\t(struct lang_decl_var): Add class_field, vtable.\n+\t(java_mangle_decl): Declare.\n+\t* lang.c (LANG_HOOKS_SET_DECL_ASSEMBLER_NAME): New.\n+\t* mangle.c: Remove dup obstack.h; include langhooks-def.h.\n+\t(mangle_obstack_1): New.\n+\t(java_mangle_decl): Remove obstack argument.  Call mangle_class_field,\n+\tmangle_vtable, and mangle_local_cni_method_decl.  Fall back to\n+\tlhd_set_decl_assembler_name for things that don't need mangling.\n+\t(mangle_class_field): Rename from java_mangle_class_field, make\n+\tstatic, don't call init_mangling or finish_mangling.\n+\t(mangle_vtable): Similarly.\n+\t(mangle_local_cni_method_decl): New.\n+\t(init_mangling): Remove obstack argument.  Use &mangle_obstack_1,\n+\tgcc_assert, and MANGLE_RAW_STRING.\n+\t(finish_mangling): Use gcc_assert, remove if 0 debugging code.\n+\n 2005-05-25  DJ Delorie  <dj@redhat.com>\n \n \t* class.c (set_constant_value): Move warning control from if() to"}, {"sha": "f4831b6fb82c8f2788ef1c1900fa6bddfe7031bb", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=6de33afa78e19bee96963ec3771c352a488287e1", "patch": "@@ -340,7 +340,7 @@ java/lang.o: java/lang.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h input.h \\\n   toplev.h $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(EXPR_H) diagnostic.h \\\n   langhooks.h $(LANGHOOKS_DEF_H) gt-java-lang.h opts.h options.h\n java/mangle.o: java/mangle.c $(CONFIG_H) java/jcf.h $(JAVA_TREE_H) $(SYSTEM_H) \\\n-  coretypes.h $(TM_H) toplev.h $(GGC_H) gt-java-mangle.h\n+  coretypes.h $(TM_H) toplev.h $(GGC_H) gt-java-mangle.h $(LANGHOOKS_DEF_H)\n java/mangle_name.o: java/mangle_name.c $(CONFIG_H) java/jcf.h $(JAVA_TREE_H) \\\n   $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(GGC_H)\n java/resource.o: java/resource.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\"}, {"sha": "88ca1f4935677bba1c15350361063e627e84c782", "filename": "gcc/java/class.c", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=6de33afa78e19bee96963ec3771c352a488287e1", "patch": "@@ -970,10 +970,13 @@ build_class_ref (tree type)\n \t      DECL_ARTIFICIAL (decl) = 1;\n \t      if (is_compiled == 1)\n \t\tDECL_EXTERNAL (decl) = 1;\n-\t      SET_DECL_ASSEMBLER_NAME (decl, \n-\t\t\t\t       java_mangle_class_field\n-\t\t\t\t       (&temporary_obstack, type));\n-\t      pushdecl_top_level (decl);\n+\t      MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n+\t      DECL_CLASS_FIELD_P (decl) = 1;\n+\t      DECL_CONTEXT (decl) = type;\n+\n+\t      /* ??? We want to preserve the DECL_CONTEXT we set just above,\n+\t\t that that means not calling pushdecl_top_level.  */\n+\t      IDENTIFIER_GLOBAL_VALUE (decl_name) = decl;\n \t    }\n \t}\n       else\n@@ -1969,7 +1972,7 @@ is_compiled_class (tree class)\n tree\n build_dtable_decl (tree type)\n {\n-  tree dtype;\n+  tree dtype, decl;\n \n   /* We need to build a new dtable type so that its size is uniquely\n      computed when we're dealing with the class for real and not just\n@@ -2017,8 +2020,12 @@ build_dtable_decl (tree type)\n   else\n     dtype = dtable_type;\n \n-  return build_decl (VAR_DECL, \n-\t\t     java_mangle_vtable (&temporary_obstack, type), dtype);\n+  decl = build_decl (VAR_DECL, get_identifier (\"vt$\"), dtype);\n+  DECL_CONTEXT (decl) = type;\n+  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n+  DECL_VTABLE_P (decl) = 1;\n+\n+  return decl;\n }\n \n /* Pre-pend the TYPE_FIELDS of THIS_CLASS with a dummy FIELD_DECL for the\n@@ -2092,7 +2099,6 @@ void\n layout_class (tree this_class)\n {\n   tree super_class = CLASSTYPE_SUPER (this_class);\n-  tree field;\n \n   class_list = tree_cons (this_class, NULL_TREE, class_list);\n   if (CLASS_BEING_LAIDOUT (this_class))\n@@ -2140,18 +2146,6 @@ layout_class (tree this_class)\n \tpush_super_field (this_class, maybe_super_class);\n     }\n \n-  for (field = TYPE_FIELDS (this_class);\n-       field != NULL_TREE;  field = TREE_CHAIN (field))\n-    {\n-      if (FIELD_STATIC (field))\n-\t{\n-\t  /* Set DECL_ASSEMBLER_NAME to something suitably mangled. */\n-\t  SET_DECL_ASSEMBLER_NAME (field,\n-\t\t\t\t   java_mangle_decl\n-\t\t\t\t   (&temporary_obstack, field));\n-\t}\n-    }\n-\n   layout_type (this_class);\n \n   /* Also recursively load/layout any superinterfaces, but only if\n@@ -2319,11 +2313,6 @@ layout_class_method (tree this_class, tree super_class,\n      compiled into this object file.  */\n   DECL_EXTERNAL (method_decl) = 1;\n \n-  /* This is a good occasion to mangle the method's name */\n-  SET_DECL_ASSEMBLER_NAME (method_decl,\n-\t\t\t   java_mangle_decl (&temporary_obstack, \n-\t\t\t\t\t     method_decl));\n-\n   if (ID_INIT_P (method_name))\n     {\n       const char *p = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (this_class)));"}, {"sha": "a31b668f1bcaa3ff3060e871566822f5e91ebedf", "filename": "gcc/java/decl.c", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=6de33afa78e19bee96963ec3771c352a488287e1", "patch": "@@ -2133,6 +2133,30 @@ java_mark_decl_local (tree decl)\n     make_decl_rtl (decl);\n }\n \n+/* Given appropriate target support, G++ will emit hidden aliases for native\n+   methods.  Using this hidden name is required for proper operation of\n+   _Jv_Method::ncode, but it doesn't hurt to use it everywhere.  Look for\n+   proper target support, then mark the method for aliasing.  */\n+\n+static void\n+java_mark_cni_decl_local (tree decl)\n+{\n+  /* Setting DECL_LOCAL_CNI_METHOD_P changes the behaviour of the mangler.\n+     We expect that we should not yet have referenced this decl in a \n+     context that requires it.  Check this invariant even if we don't have\n+     support for hidden aliases.  */\n+  gcc_assert (!DECL_ASSEMBLER_NAME_SET_P (decl));\n+\n+#if !defined(HAVE_GAS_HIDDEN) || !defined(ASM_OUTPUT_DEF)\n+  return;\n+#endif\n+\n+  DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;\n+  DECL_LOCAL_CNI_METHOD_P (decl) = 1;\n+}\n+\n+/* Use the preceeding two functions and mark all members of the class.  */\n+\n void\n java_mark_class_local (tree class)\n {\n@@ -2143,8 +2167,13 @@ java_mark_class_local (tree class)\n       java_mark_decl_local (t);\n \n   for (t = TYPE_METHODS (class); t ; t = TREE_CHAIN (t))\n-    if (!METHOD_ABSTRACT (t) && (!METHOD_NATIVE (t) || flag_jni))\n-      java_mark_decl_local (t);\n+    if (!METHOD_ABSTRACT (t))\n+      {\n+\tif (METHOD_NATIVE (t) && !flag_jni)\n+\t  java_mark_cni_decl_local (t);\n+        else\n+\t  java_mark_decl_local (t);\n+      }\n }\n \n /* Add a statement to a compound_expr.  */"}, {"sha": "f9197418424f671b5cf76d2d46acb3eabed45d56", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=6de33afa78e19bee96963ec3771c352a488287e1", "patch": "@@ -818,6 +818,9 @@ union lang_tree_node\n #define DECL_FIXED_CONSTRUCTOR_P(DECL) \\\n   (DECL_LANG_SPECIFIC(DECL)->u.f.fixed_ctor)\n \n+#define DECL_LOCAL_CNI_METHOD_P(NODE) \\\n+    (DECL_LANG_SPECIFIC (NODE)->u.f.local_cni)\n+\n /* A constructor that calls this. */\n #define DECL_INIT_CALLS_THIS(DECL) \\\n   (DECL_LANG_SPECIFIC(DECL)->u.f.init_calls_this)\n@@ -931,6 +934,12 @@ union lang_tree_node\n     (DECL_LANG_SPECIFIC (NODE)->u.v.freed)\n #define LOCAL_SLOT_P(NODE) \\\n     (DECL_LANG_SPECIFIC (NODE)->u.v.local_slot)\n+\n+#define DECL_CLASS_FIELD_P(NODE) \\\n+    (DECL_LANG_SPECIFIC (NODE)->u.v.class_field)\n+#define DECL_VTABLE_P(NODE) \\\n+    (DECL_LANG_SPECIFIC (NODE)->u.v.vtable)\n+\n /* Create a DECL_LANG_SPECIFIC if necessary. */\n #define MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC(T)\t\t\t\\\n   if (DECL_LANG_SPECIFIC (T) == NULL)\t\t\t\t\\\n@@ -993,7 +1002,8 @@ struct lang_decl_func GTY(())\n   unsigned int invisible : 1;\t/* Set for methods we generate\n \t\t\t\t   internally but which shouldn't be\n \t\t\t\t   written to the .class file.  */\n-  unsigned int dummy:1;\t\t\n+  unsigned int dummy : 1;\n+  unsigned int local_cni : 1;\t/* Decl needs mangle_local_cni_method.  */\n };\n \n struct treetreehash_entry GTY(())\n@@ -1037,6 +1047,8 @@ struct lang_decl_var GTY(())\n   unsigned int cif : 1;\t\t/* True: decl is a class initialization flag */\n   unsigned int freed : 1;\t\t/* Decl is no longer in scope.  */\n   unsigned int local_slot : 1;\t/* Decl is a temporary in the stack frame.  */\n+  unsigned int class_field : 1; /* Decl needs mangle_class_field.  */\n+  unsigned int vtable : 1;\t/* Decl needs mangle_vtable.  */\n };\n \n /* This is what 'lang_decl' really points to.  */\n@@ -1367,7 +1379,7 @@ extern void init_jcf_parse (void);\n extern void init_src_parse (void);\n \n extern int cxx_keyword_p (const char *, int);\n-extern tree java_mangle_decl (struct obstack *, tree);\n+extern void java_mangle_decl (tree);\n extern tree java_mangle_class_field (struct obstack *, tree);\n extern tree java_mangle_vtable (struct obstack *, tree);\n extern void append_gpp_mangled_name (const char *, int);"}, {"sha": "4ade9364113d55416f95b3c1715c47d62036e5fc", "filename": "gcc/java/lang.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=6de33afa78e19bee96963ec3771c352a488287e1", "patch": "@@ -213,6 +213,9 @@ struct language_function GTY(())\n #undef LANG_HOOKS_CLEAR_BINDING_STACK\n #define LANG_HOOKS_CLEAR_BINDING_STACK java_clear_binding_stack\n \n+#undef LANG_HOOKS_SET_DECL_ASSEMBLER_NAME\n+#define LANG_HOOKS_SET_DECL_ASSEMBLER_NAME java_mangle_decl\n+\n /* Each front end provides its own.  */\n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n "}, {"sha": "22a391839a720a508323112d3a11f60cb4e6ca44", "filename": "gcc/java/mangle.c", "status": "modified", "additions": 83, "deletions": 41, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fjava%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de33afa78e19bee96963ec3771c352a488287e1/gcc%2Fjava%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle.c?ref=6de33afa78e19bee96963ec3771c352a488287e1", "patch": "@@ -35,11 +35,14 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"java-tree.h\"\n #include \"obstack.h\"\n #include \"toplev.h\"\n-#include \"obstack.h\"\n #include \"ggc.h\"\n+#include \"langhooks-def.h\"\n \n+static void mangle_class_field (tree);\n+static void mangle_vtable (tree);\n static void mangle_field_decl (tree);\n static void mangle_method_decl (tree);\n+static void mangle_local_cni_method_decl (tree);\n \n static void mangle_type (tree);\n static void mangle_pointer_type (tree);\n@@ -55,15 +58,15 @@ static void set_type_package_list (tree);\n static int  entry_match_pointer_p (tree, int);\n static void emit_compression_string (int);\n \n-static void init_mangling (struct obstack *);\n+static void init_mangling (void);\n static tree finish_mangling (void);\n static void compression_table_add (tree);\n \n static void mangle_member_name (tree);\n \n-/* We use an incoming obstack, always to be provided to the interface\n-   functions. */\n+static struct obstack mangle_obstack_1;\n struct obstack *mangle_obstack;\n+\n #define MANGLE_RAW_STRING(S) \\\n   obstack_grow (mangle_obstack, (S), sizeof (S)-1)\n \n@@ -73,46 +76,75 @@ static GTY(()) tree atms;\n /* This is the mangling interface: a decl, a class field (.class) and\n    the vtable. */\n \n-tree\n-java_mangle_decl (struct obstack *obstack, tree decl)\n+void\n+java_mangle_decl (tree decl)\n {\n-  init_mangling (obstack);\n-  switch (TREE_CODE (decl))\n+  /* A copy of the check from the beginning of lhd_set_decl_assembler_name.\n+     Only FUNCTION_DECLs and VAR_DECLs for variables with static storage\n+     duration need a real DECL_ASSEMBLER_NAME.  */\n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n+\t      || (TREE_CODE (decl) == VAR_DECL\n+\t\t  && (TREE_STATIC (decl)\n+\t\t      || DECL_EXTERNAL (decl)\n+\t\t      || TREE_PUBLIC (decl))));\n+  \n+  /* Mangling only applies to class members.  */\n+  if (DECL_CONTEXT (decl) && TYPE_P (DECL_CONTEXT (decl)))\n     {\n-    case VAR_DECL:\n-      mangle_field_decl (decl);\n-      break;\n-    case FUNCTION_DECL:\n-      mangle_method_decl (decl);\n-      break;\n-    default:\n-      internal_error (\"can't mangle %s\", tree_code_name [TREE_CODE (decl)]);\n+      init_mangling ();\n+      switch (TREE_CODE (decl))\n+\t{\n+\tcase VAR_DECL:\n+\t  if (DECL_LANG_SPECIFIC (decl))\n+\t    {\n+\t      if (DECL_CLASS_FIELD_P (decl))\n+\t\t{\n+\t\t  mangle_class_field (DECL_CONTEXT (decl));\n+\t\t  break;\n+\t\t}\n+\t      else if (DECL_VTABLE_P (decl))\n+\t\t{\n+\t\t  mangle_vtable (DECL_CONTEXT (decl));\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  mangle_field_decl (decl);\n+\t  break;\n+\n+\tcase FUNCTION_DECL:\n+\t  if (DECL_LANG_SPECIFIC (decl) && DECL_LOCAL_CNI_METHOD_P (decl))\n+\t    mangle_local_cni_method_decl (decl);\n+\t  else\n+\t    mangle_method_decl (decl);\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      SET_DECL_ASSEMBLER_NAME (decl, finish_mangling ());\n     }\n-  return finish_mangling ();\n+  else\n+    lhd_set_decl_assembler_name (decl);\n }\n \n-tree \n-java_mangle_class_field (struct obstack *obstack, tree type)\n+/* Beginning of the helper functions */\n+\n+static void\n+mangle_class_field (tree type)\n {\n-  init_mangling (obstack);\n   mangle_record_type (type, /* for_pointer = */ 0);\n   MANGLE_RAW_STRING (\"6class$\");\n   obstack_1grow (mangle_obstack, 'E');\n-  return finish_mangling ();\n }\n \n-tree\n-java_mangle_vtable (struct obstack *obstack, tree type)\n+static void\n+mangle_vtable (tree type)\n {\n-  init_mangling (obstack);\n   MANGLE_RAW_STRING (\"TV\");\n   mangle_record_type (type, /* for_pointer = */ 0);\n   obstack_1grow (mangle_obstack, 'E');\n-  return finish_mangling ();\n }\n \n-/* Beginning of the helper functions */\n-\n /* This mangles a field decl */\n \n static void\n@@ -167,6 +199,18 @@ mangle_method_decl (tree mdecl)\n     }\n }\n \n+/* This mangles a CNI method for a local class.  If the target supports\n+   hidden aliases, then G++ will have generated one for us.  It is the\n+   responsibility of java_mark_class_local to check target support, since\n+   we need to set DECL_VISIBILITY (or not) much earlier.  */\n+\n+static void\n+mangle_local_cni_method_decl (tree decl)\n+{\n+  MANGLE_RAW_STRING (\"GA\");\n+  mangle_method_decl (decl);\n+}\n+\n /* This mangles a member name, like a function name or a field\n    name. Handle cases were `name' is a C++ keyword.  Return a nonzero\n    value if unicode encoding was required.  */\n@@ -585,17 +629,19 @@ compression_table_add (tree type)\n /* Mangling initialization routine.  */\n \n static void\n-init_mangling (struct obstack *obstack)\n+init_mangling (void)\n {\n-  mangle_obstack = obstack;\n-  if (!compression_table)\n-    compression_table = make_tree_vec (10);\n-  else\n-    /* Mangling already in progress.  */\n-    abort ();\n+  if (!mangle_obstack)\n+    {\n+      mangle_obstack = &mangle_obstack_1;\n+      gcc_obstack_init (mangle_obstack);\n+    }\n+\n+  gcc_assert (compression_table == NULL);\n+  compression_table = make_tree_vec (10);\n \n   /* Mangled name are to be suffixed */\n-  obstack_grow (mangle_obstack, \"_Z\", 2);\n+  MANGLE_RAW_STRING (\"_Z\");\n }\n \n /* Mangling finalization routine. The mangled name is returned as a\n@@ -606,18 +652,14 @@ finish_mangling (void)\n {\n   tree result;\n \n-  if (!compression_table)\n-    /* Mangling already finished.  */\n-    abort ();\n+  gcc_assert (compression_table);\n \n   compression_table = NULL_TREE;\n   compression_next = 0;\n   obstack_1grow (mangle_obstack, '\\0');\n   result = get_identifier (obstack_base (mangle_obstack));\n   obstack_free (mangle_obstack, obstack_base (mangle_obstack));\n-#if 0\n-  printf (\"// %s\\n\", IDENTIFIER_POINTER (result));\n-#endif\n+\n   return result;\n }\n "}]}