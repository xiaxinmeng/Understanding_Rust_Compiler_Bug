{"sha": "46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZkMmI3N2Q3MWMzYzlhMmVhMzI2YWU5YzNhODlhMTlkZTMyNTRjYQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-10-16T20:50:40Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-10-16T20:50:40Z"}, "message": "Add gnu::unique_ptr\n\nThis is a version of the patch posted by Trevor Saunders on 2017-07-31,\nfor which he wrote:\n> For most of the history of this see\n>   https://sourceware.org/ml/gdb-patches/2016-10/msg00223.html\n> The changes are mostly s/gdb/gtl/g\n\nThis version was updated by me (dmalcolm) adding these changes:\n- renaming of \"gtl\" to \"gnu\" (3 letters, and one of the ones Richi\n  proposed, and not a match for \"*tl\")\n- renaming of DEFINE_GDB_UNIQUE_PTR to DEFINE_GNU_UNIQUE_PTR\n- renaming of xfree_deleter to xmalloc_deleter, and making it\n  use \"free\" rather than \"xfree\" (which doesn't exist)\n- added a gcc/unique-ptr-tests.cc\n- implement unique_xmalloc_ptr<T[]> (taken from gdb, but changing\n  \"xfree\" to \"free\", and adding support for pre-C++-11)\n\ngcc/ChangeLog:\n\n\tDavid Malcolm <dmalcolm@redhat.com>\n\n\t* Makefile.in (OBJS): Add unique-ptr-tests.o.\n\t* selftest-run-tests.c (selftest::run_tests): Call\n\tselftest::unique_ptr_tests_cc_tests.\n\t* selftest.h (selftest::unique_ptr_tests_cc_tests): New decl.\n\t* unique-ptr-tests.cc: New file.\n\ninclude/ChangeLog:\n\n\tTrevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\tDavid Malcolm <dmalcolm@redhat.com>\n\n\t* unique-ptr.h: New file.\n\nFrom-SVN: r253797", "tree": {"sha": "e11b3eda93410442b9c1c59e85c5147392d1728b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e11b3eda93410442b9c1c59e85c5147392d1728b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca/comments", "author": null, "committer": null, "parents": [{"sha": "2de3d3c6a62ac4299e9f5a310e4bf8ff28dbd47f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de3d3c6a62ac4299e9f5a310e4bf8ff28dbd47f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2de3d3c6a62ac4299e9f5a310e4bf8ff28dbd47f"}], "stats": {"total": 653, "additions": 653, "deletions": 0}, "files": [{"sha": "933e4e9f0a8a768d1cde38c3803d093e7913aa2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca", "patch": "@@ -1,3 +1,11 @@\n+2017-10-16  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (OBJS): Add unique-ptr-tests.o.\n+\t* selftest-run-tests.c (selftest::run_tests): Call\n+\tselftest::unique_ptr_tests_cc_tests.\n+\t* selftest.h (selftest::unique_ptr_tests_cc_tests): New decl.\n+\t* unique-ptr-tests.cc: New file.\n+\n 2017-10-16  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR sanitizer/82353"}, {"sha": "2809619031b7dbb65cc0695a13e74900c620857e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca", "patch": "@@ -1568,6 +1568,7 @@ OBJS = \\\n \ttree-vrp.o \\\n \ttree.o \\\n \ttyped-splay-tree.o \\\n+\tunique-ptr-tests.o \\\n \tvaltrack.o \\\n \tvalue-prof.o \\\n \tvar-tracking.o \\"}, {"sha": "11bf0cc9cb706b4e47b83fd4bf7a6cb63733e8d7", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca", "patch": "@@ -67,6 +67,7 @@ selftest::run_tests ()\n   sreal_c_tests ();\n   fibonacci_heap_c_tests ();\n   typed_splay_tree_c_tests ();\n+  unique_ptr_tests_cc_tests ();\n \n   /* Mid-level data structures.  */\n   input_c_tests ();"}, {"sha": "6478922cd2ccee022147bf9f4f080c46fd097e1b", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca", "patch": "@@ -195,6 +195,7 @@ extern void store_merging_c_tests ();\n extern void typed_splay_tree_c_tests ();\n extern void tree_c_tests ();\n extern void tree_cfg_c_tests ();\n+extern void unique_ptr_tests_cc_tests ();\n extern void vec_c_tests ();\n extern void wide_int_cc_tests ();\n extern void predict_c_tests ();"}, {"sha": "f5b72a8c15fbfdbf3c1d98cc9a36711b3f6244b1", "filename": "gcc/unique-ptr-tests.cc", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca/gcc%2Funique-ptr-tests.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca/gcc%2Funique-ptr-tests.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funique-ptr-tests.cc?ref=46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca", "patch": "@@ -0,0 +1,234 @@\n+/* Unit tests for unique-ptr.h.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"unique-ptr.h\"\n+#include \"selftest.h\"\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+namespace {\n+\n+/* A class for counting ctor and dtor invocations.  */\n+\n+struct stats\n+{\n+  stats () : ctor_count (0), dtor_count (0) {}\n+\n+  int ctor_count;\n+  int dtor_count;\n+};\n+\n+/* A class that uses \"stats\" to track its ctor and dtor invocations.  */\n+\n+class foo\n+{\n+public:\n+  foo (stats &s) : m_s (s) { ++m_s.ctor_count; }\n+  ~foo () { ++m_s.dtor_count; }\n+\n+  int example_method () const { return 42; }\n+\n+private:\n+  foo (const foo&);\n+  foo & operator= (const foo &);\n+\n+private:\n+  stats &m_s;\n+};\n+\n+/* A struct for testing unique_ptr<T[]>.  */\n+\n+struct has_default_ctor\n+{\n+  has_default_ctor () : m_field (42) {}\n+  int m_field;\n+};\n+\n+/* A dummy struct for testing unique_xmalloc_ptr.  */\n+\n+struct dummy\n+{\n+  int field;\n+};\n+\n+} // anonymous namespace\n+\n+/* Verify that the default ctor inits ptrs to NULL.  */\n+\n+static void\n+test_null_ptr ()\n+{\n+  gnu::unique_ptr<void *> p;\n+  ASSERT_EQ (NULL, p);\n+\n+  gnu::unique_xmalloc_ptr<void *> q;\n+  ASSERT_EQ (NULL, q);\n+}\n+\n+/* Verify that deletion happens when a unique_ptr goes out of scope.  */\n+\n+static void\n+test_implicit_deletion ()\n+{\n+  stats s;\n+  ASSERT_EQ (0, s.ctor_count);\n+  ASSERT_EQ (0, s.dtor_count);\n+\n+  {\n+    gnu::unique_ptr<foo> f (new foo (s));\n+    ASSERT_NE (NULL, f);\n+    ASSERT_EQ (1, s.ctor_count);\n+    ASSERT_EQ (0, s.dtor_count);\n+  }\n+\n+  /* Verify that the foo was implicitly deleted.  */\n+  ASSERT_EQ (1, s.ctor_count);\n+  ASSERT_EQ (1, s.dtor_count);\n+}\n+\n+/* Verify that we can assign to a NULL unique_ptr.  */\n+\n+static void\n+test_overwrite_of_null ()\n+{\n+  stats s;\n+  ASSERT_EQ (0, s.ctor_count);\n+  ASSERT_EQ (0, s.dtor_count);\n+\n+  {\n+    gnu::unique_ptr<foo> f;\n+    ASSERT_EQ (NULL, f);\n+    ASSERT_EQ (0, s.ctor_count);\n+    ASSERT_EQ (0, s.dtor_count);\n+\n+    /* Overwrite with a non-NULL value.  */\n+    f = gnu::unique_ptr<foo> (new foo (s));\n+    ASSERT_EQ (1, s.ctor_count);\n+    ASSERT_EQ (0, s.dtor_count);\n+  }\n+\n+  /* Verify that the foo is implicitly deleted.  */\n+  ASSERT_EQ (1, s.ctor_count);\n+  ASSERT_EQ (1, s.dtor_count);\n+}\n+\n+/* Verify that we can assign to a non-NULL unique_ptr.  */\n+\n+static void\n+test_overwrite_of_non_null ()\n+{\n+  stats s;\n+  ASSERT_EQ (0, s.ctor_count);\n+  ASSERT_EQ (0, s.dtor_count);\n+\n+  {\n+    gnu::unique_ptr<foo> f (new foo (s));\n+    ASSERT_NE (NULL, f);\n+    ASSERT_EQ (1, s.ctor_count);\n+    ASSERT_EQ (0, s.dtor_count);\n+\n+    /* Overwrite with a different value.  */\n+    f = gnu::unique_ptr<foo> (new foo (s));\n+    ASSERT_EQ (2, s.ctor_count);\n+    ASSERT_EQ (1, s.dtor_count);\n+  }\n+\n+  /* Verify that the 2nd foo was implicitly deleted.  */\n+  ASSERT_EQ (2, s.ctor_count);\n+  ASSERT_EQ (2, s.dtor_count);\n+}\n+\n+/* Verify that unique_ptr's overloaded ops work.  */\n+\n+static void\n+test_overloaded_ops ()\n+{\n+  stats s;\n+  gnu::unique_ptr<foo> f (new foo (s));\n+  ASSERT_EQ (42, f->example_method ());\n+  ASSERT_EQ (42, (*f).example_method ());\n+  ASSERT_EQ (f, f);\n+  ASSERT_NE (NULL, f.get ());\n+\n+  gnu::unique_ptr<foo> g (new foo (s));\n+  ASSERT_NE (f, g);\n+}\n+\n+/* Verify that the gnu::unique_ptr specialization for T[] works.  */\n+\n+static void\n+test_array_new ()\n+{\n+  const int num = 10;\n+  gnu::unique_ptr<has_default_ctor[]> p (new has_default_ctor[num]);\n+  ASSERT_NE (NULL, p.get ());\n+  /* Verify that operator[] works, and that the default ctor was called\n+     on each element.  */\n+  for (int i = 0; i < num; i++)\n+    ASSERT_EQ (42, p[i].m_field);\n+}\n+\n+/* Verify that gnu::unique_xmalloc_ptr works.  */\n+\n+static void\n+test_xmalloc ()\n+{\n+  gnu::unique_xmalloc_ptr<dummy> p (XNEW (dummy));\n+  ASSERT_NE (NULL, p.get ());\n+}\n+\n+/* Verify the gnu::unique_xmalloc_ptr specialization for T[].  */\n+\n+static void\n+test_xmalloc_array ()\n+{\n+  const int num = 10;\n+  gnu::unique_xmalloc_ptr<dummy[]> p (XNEWVEC (dummy, num));\n+  ASSERT_NE (NULL, p.get ());\n+\n+  /* Verify that operator[] works.  */\n+  for (int i = 0; i < num; i++)\n+    p[i].field = 42;\n+  for (int i = 0; i < num; i++)\n+    ASSERT_EQ (42, p[i].field);\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+unique_ptr_tests_cc_tests ()\n+{\n+  test_null_ptr ();\n+  test_implicit_deletion ();\n+  test_overwrite_of_null ();\n+  test_overwrite_of_non_null ();\n+  test_overloaded_ops ();\n+  test_array_new ();\n+  test_xmalloc ();\n+  test_xmalloc_array ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* #if CHECKING_P */"}, {"sha": "805e81c0227120ad1c80b091b2443f9ddc56478e", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca", "patch": "@@ -1,3 +1,8 @@\n+2017-10-16  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\t    David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* unique-ptr.h: New file.\n+\n 2017-09-15  Yao Qi  <yao.qi@linaro.org>\n \t    Pedro Alves  <palves@redhat.com>\n "}, {"sha": "c5ca031c2842505e8e816a669e7a5c91dd0f7d19", "filename": "include/unique-ptr.h", "status": "added", "additions": 403, "deletions": 0, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca/include%2Funique-ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca/include%2Funique-ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Funique-ptr.h?ref=46d2b77d71c3c9a2ea326ae9c3a89a19de3254ca", "patch": "@@ -0,0 +1,403 @@\n+/* gnu::unique_ptr, a simple std::unique_ptr replacement for C++03.\n+\n+   Copyright (C) 2007-2016 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* gnu::unique_ptr defines a C++ owning smart pointer that exposes a\n+   subset of the std::unique_ptr API.\n+\n+   In fact, when compiled with a C++11 compiler, gnu::unique_ptr\n+   actually _is_ std::unique_ptr.  When compiled with a C++03 compiler\n+   OTOH, it's an hand coded std::unique_ptr emulation that assumes\n+   code is correct and doesn't try to be too smart.\n+\n+   This supports custom deleters, but not _stateful_ deleters, so you\n+   can't use those in C++11 mode either.  Only the managed pointer is\n+   stored in the smart pointer.  That could be changed; it simply\n+   wasn't found necessary.\n+\n+   At the end of the file you'll find a gnu::unique_ptr partial\n+   specialization that uses a custom (stateless) deleter:\n+   gnu::unique_xmalloc_ptr.  That is used to manage pointers to\n+   objects allocated with xmalloc.\n+\n+   The C++03 version was originally based on GCC 7.0's std::auto_ptr\n+   and then heavily customized to behave more like C++11's\n+   std::unique_ptr, but at this point, it no longer shares much at all\n+   with the original file.  But, that's the history and the reason for\n+   the copyright's starting year.\n+\n+   The C++03 version lets you shoot yourself in the foot, since\n+   similarly to std::auto_ptr, the copy constructor and assignment\n+   operators actually move.  Also, in the name of simplicity, no\n+   effort is spent on using SFINAE to prevent invalid conversions,\n+   etc.  This is not really a problem, because the goal here is to\n+   allow code that would be correct using std::unique_ptr to be\n+   equally correct in C++03 mode, and, just as efficient.  If client\n+   code compiles correctly with a C++11 (or newer) compiler, we know\n+   we're not doing anything invalid by mistake.\n+\n+   Usage notes:\n+\n+   - Putting gnu::unique_ptr in standard containers is not supported,\n+     since C++03 containers are not move-aware (and our emulation\n+     relies on copy actually moving).\n+\n+   - Since there's no nullptr in C++03, gnu::unique_ptr allows\n+     implicit initialization and assignment from NULL instead.\n+\n+   - To check whether there's an associated managed object, all these\n+     work as expected:\n+\n+      if (ptr)\n+      if (!ptr)\n+      if (ptr != NULL)\n+      if (ptr == NULL)\n+      if (NULL != ptr)\n+      if (NULL == ptr)\n+*/\n+\n+#ifndef GNU_UNIQUE_PTR_H\n+#define GNU_UNIQUE_PTR_H 1\n+\n+#include <memory>\n+\n+namespace gnu\n+{\n+\n+#if __cplusplus >= 201103\n+\n+/* In C++11 mode, all we need is import the standard\n+   std::unique_ptr.  */\n+template<typename T> using unique_ptr = std::unique_ptr<T>;\n+\n+/* Pull in move as well.  */\n+using std::move;\n+\n+#else /* C++11 */\n+\n+/* Default destruction policy used by gnu::unique_ptr when no deleter\n+   is specified.  Uses delete.  */\n+\n+template<typename T>\n+struct default_delete\n+{\n+  void operator () (T *ptr) const { delete ptr; }\n+};\n+\n+/* Specialization for arrays.  Uses delete[].  */\n+\n+template<typename T>\n+struct default_delete<T[]>\n+{\n+  void operator () (T *ptr) const { delete [] ptr; }\n+};\n+\n+namespace detail\n+{\n+/* Type used to support implicit construction from NULL:\n+\n+     gnu::unique_ptr<foo> func (....)\n+     {\n+     return NULL;\n+     }\n+\n+   and assignment from NULL:\n+\n+     gnu::unique_ptr<foo> ptr (....);\n+     ...\n+     ptr = NULL;\n+\n+  It is intentionally not defined anywhere.  */\n+struct nullptr_t;\n+\n+/* Base class of our unique_ptr emulation.  Contains code common to\n+   both unique_ptr<T, D> and unique_ptr<T[], D>.  */\n+\n+template<typename T, typename D>\n+class unique_ptr_base\n+{\n+public:\n+  typedef T *pointer;\n+  typedef T element_type;\n+  typedef D deleter_type;\n+\n+  /* Takes ownership of a pointer.  P is a pointer to an object of\n+     element_type type.  Defaults to NULL.  */\n+  explicit unique_ptr_base (element_type *p = NULL) throw () : m_ptr (p) {}\n+\n+  /* The \"move\" constructor.  Really a copy constructor that actually\n+     moves.  Even though std::unique_ptr is not copyable, our little\n+     simpler emulation allows it, because:\n+\n+       - There are no rvalue references in C++03.  Our move emulation\n+       instead relies on copy/assignment moving, like std::auto_ptr.\n+       - RVO/NRVO requires an accessible copy constructor\n+  */\n+  unique_ptr_base (const unique_ptr_base &other) throw ()\n+    : m_ptr (const_cast<unique_ptr_base &> (other).release ()) {}\n+\n+  /* Converting \"move\" constructor.  Really an lvalue ref converting\n+     constructor that actually moves.  This allows constructs such as:\n+\n+      unique_ptr<Derived> func_returning_unique_ptr (.....);\n+      ...\n+      unique_ptr<Base> ptr = func_returning_unique_ptr (.....);\n+  */\n+  template<typename T1, typename D1>\n+  unique_ptr_base (const unique_ptr_base<T1, D1> &other) throw ()\n+    : m_ptr (const_cast<unique_ptr_base<T1, D1> &> (other).release ()) {}\n+\n+  /* The \"move\" assignment operator.  Really an lvalue ref copy\n+     assignment operator that actually moves.  See comments above.  */\n+  unique_ptr_base &operator= (const unique_ptr_base &other) throw ()\n+  {\n+    reset (const_cast<unique_ptr_base &> (other).release ());\n+    return *this;\n+  }\n+\n+  /* Converting \"move\" assignment.  Really an lvalue ref converting\n+     copy assignment operator that moves.  See comments above.  */\n+  template<typename T1, typename D1>\n+  unique_ptr_base &operator= (const unique_ptr_base<T1, D1> &other) throw ()\n+  {\n+    reset (const_cast<unique_ptr_base<T1, D1> &> (other).release ());\n+    return *this;\n+  }\n+\n+  /* std::unique_ptr does not allow assignment, except from nullptr.\n+     nullptr doesn't exist in C++03, so we allow assignment from NULL\n+     instead [ptr = NULL;].\n+  */\n+  unique_ptr_base &operator= (detail::nullptr_t *) throw ()\n+  {\n+    reset ();\n+    return *this;\n+  }\n+\n+  ~unique_ptr_base () { call_deleter (); }\n+\n+  /* \"explicit operator bool ()\" emulation using the safe bool\n+     idiom.  */\n+private:\n+  typedef void (unique_ptr_base::*explicit_operator_bool) () const;\n+  void this_type_does_not_support_comparisons () const {}\n+\n+public:\n+  operator explicit_operator_bool () const\n+  {\n+    return (m_ptr != NULL\n+\t    ? &unique_ptr_base::this_type_does_not_support_comparisons\n+\t    : 0);\n+  }\n+\n+  element_type *get () const throw () { return m_ptr; }\n+\n+  element_type *release () throw ()\n+  {\n+    pointer tmp = m_ptr;\n+    m_ptr = NULL;\n+    return tmp;\n+  }\n+\n+  void reset (element_type *p = NULL) throw ()\n+  {\n+    if (p != m_ptr)\n+      {\n+\tcall_deleter ();\n+\tm_ptr = p;\n+      }\n+  }\n+\n+private:\n+\n+  /* Call the deleter.  Note we assume the deleter is \"stateless\".  */\n+  void call_deleter ()\n+  {\n+    D d;\n+\n+    d (m_ptr);\n+  }\n+\n+  element_type *m_ptr;\n+};\n+\n+} /* namespace detail */\n+\n+/* Macro used to create a unique_ptr_base \"partial specialization\" --\n+   a subclass that uses a specific deleter.  Basically this re-defines\n+   the necessary constructors.  This is necessary because C++03\n+   doesn't support inheriting constructors with \"using\".  While at it,\n+   we inherit the assignment operator.  TYPE is the name of the type\n+   being defined.  Assumes that 'base_type' is a typedef of the\n+   baseclass TYPE is inheriting from.  */\n+#define DEFINE_GNU_UNIQUE_PTR(TYPE)\t\t\t\t\t\t\\\n+public:\t\t\t\t\t\t\t\t\t\\\n+  explicit TYPE (T *p = NULL) throw ()\t\t\t\t\t\\\n+    : base_type (p) {}\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  TYPE (const TYPE &other) throw () : base_type (other) {}\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  TYPE (detail::nullptr_t *) throw () : base_type (NULL) {}\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template<typename T1, typename D1>\t\t\t\t\t\\\n+  TYPE (const detail::unique_ptr_base<T1, D1> &other) throw ()\t\t\\\n+    : base_type (other) {}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  using base_type::operator=;\n+\n+/* Define single-object gnu::unique_ptr.  */\n+\n+template <typename T, typename D = default_delete<T> >\n+class unique_ptr : public detail::unique_ptr_base<T, D>\n+{\n+  typedef detail::unique_ptr_base<T, D> base_type;\n+\n+  DEFINE_GNU_UNIQUE_PTR (unique_ptr)\n+\n+public:\n+  /* Dereferencing.  */\n+  T &operator* () const throw () { return *this->get (); }\n+  T *operator-> () const throw () { return this->get (); }\n+};\n+\n+/* Define gnu::unique_ptr specialization for T[].  */\n+\n+template <typename T, typename D>\n+class unique_ptr<T[], D> : public detail::unique_ptr_base<T, D>\n+{\n+  typedef detail::unique_ptr_base<T, D> base_type;\n+\n+  DEFINE_GNU_UNIQUE_PTR (unique_ptr)\n+\n+public:\n+  /* Indexing operator.  */\n+  T &operator[] (size_t i) const { return this->get ()[i]; }\n+};\n+\n+/* Comparison operators.  */\n+\n+template <typename T, typename D,\n+\t  typename U, typename E>\n+inline bool\n+operator== (const detail::unique_ptr_base<T, D> &x,\n+\t    const detail::unique_ptr_base<U, E> &y)\n+{ return x.get() == y.get(); }\n+\n+template <typename T, typename D,\n+\t  typename U, typename E>\n+inline bool\n+operator!= (const detail::unique_ptr_base<T, D> &x,\n+\t    const detail::unique_ptr_base<U, E> &y)\n+{ return x.get() != y.get(); }\n+\n+template<typename T, typename D,\n+\t typename U, typename E>\n+inline bool\n+operator< (const detail::unique_ptr_base<T, D> &x,\n+\t   const detail::unique_ptr_base<U, E> &y)\n+{ return x.get() < y.get (); }\n+\n+template<typename T, typename D,\n+\t typename U, typename E>\n+inline bool\n+operator<= (const detail::unique_ptr_base<T, D> &x,\n+\t    const detail::unique_ptr_base<U, E> &y)\n+{ return !(y < x); }\n+\n+template<typename T, typename D,\n+\t typename U, typename E>\n+inline bool\n+operator> (const detail::unique_ptr_base<T, D> &x,\n+\t   const detail::unique_ptr_base<U, E> &y)\n+{ return y < x; }\n+\n+template<typename T, typename D,\n+\t typename U, typename E>\n+inline bool\n+operator>= (const detail::unique_ptr_base<T, D> &x,\n+\t    const detail::unique_ptr_base<U, E> &y)\n+{ return !(x < y); }\n+\n+/* std::move \"emulation\".  This is as simple as it can be -- no\n+   attempt is made to emulate rvalue references.  Instead relies on\n+   the fact that gnu::unique_ptr has move semantics like\n+   std::auto_ptr.  I.e., copy/assignment actually moves.  */\n+\n+template<typename T, typename D>\n+unique_ptr<T, D>\n+move (unique_ptr<T, D> v)\n+{\n+  return v;\n+}\n+\n+#endif /* C++11 */\n+\n+/* Define gnu::unique_xmalloc_ptr, a gnu::unique_ptr that manages\n+   xmalloc'ed memory.  */\n+\n+/* The deleter for gnu::unique_xmalloc_ptr.  Uses free.  */\n+template <typename T>\n+struct xmalloc_deleter\n+{\n+  void operator() (T *ptr) const { free (ptr); }\n+};\n+\n+/* Same, for arrays.  */\n+template <typename T>\n+struct xmalloc_deleter<T[]>\n+{\n+  void operator() (T *ptr) const { free (ptr); }\n+};\n+\n+#if __cplusplus >= 201103\n+\n+/* In C++11, we just import the standard unique_ptr to our namespace\n+   with a custom deleter.  */\n+\n+template<typename T> using unique_xmalloc_ptr\n+  = std::unique_ptr<T, xmalloc_deleter<T>>;\n+\n+#else /* C++11 */\n+\n+/* In C++03, we don't have template aliases, so we need to define a\n+   subclass instead, and re-define the constructors, because C++03\n+   doesn't support inheriting constructors either.  */\n+\n+template <typename T>\n+class unique_xmalloc_ptr : public unique_ptr<T, xmalloc_deleter<T> >\n+{\n+  typedef unique_ptr<T, xmalloc_deleter<T> > base_type;\n+\n+  DEFINE_GNU_UNIQUE_PTR (unique_xmalloc_ptr)\n+};\n+\n+/* Define gnu::unique_xmalloc_ptr specialization for T[].  */\n+\n+template <typename T>\n+class unique_xmalloc_ptr<T[]> : public unique_ptr<T[], xmalloc_deleter<T[]> >\n+{\n+  typedef unique_ptr<T[], xmalloc_deleter<T[]> > base_type;\n+\n+  DEFINE_GNU_UNIQUE_PTR (unique_xmalloc_ptr)\n+};\n+\n+#endif /* C++11 */\n+\n+} /* namespace gnu */\n+\n+#endif /* GNU_UNIQUE_PTR_H */"}]}