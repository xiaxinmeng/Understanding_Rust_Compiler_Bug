{"sha": "20bd7bfa3b23a701c35980cf74dd7cc39e3ccc30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBiZDdiZmEzYjIzYTcwMWMzNTk4MGNmNzRkZDdjYzM5ZTNjY2MzMA==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "2000-08-29T19:15:26Z"}, "committer": {"name": "John Wehle", "email": "wehle@gcc.gnu.org", "date": "2000-08-29T19:15:26Z"}, "message": "loop.c (prescan_loop): Don't check unknown_address_altered when deciding if insert_loop_mem is safe.\n\n\t* loop.c (prescan_loop): Don't check unknown_address_altered\n\twhen deciding if insert_loop_mem is safe.  Add BLKmode MEMs\n\tto loop_store_mems as necessary.\n\t(loop_invariant_p): Don't check unknown_address_altered\n\tor unknown_constant_address_altered.\n\nFrom-SVN: r36045", "tree": {"sha": "8beccbbc1f123456fed31e80c336d36cda8370a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8beccbbc1f123456fed31e80c336d36cda8370a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20bd7bfa3b23a701c35980cf74dd7cc39e3ccc30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20bd7bfa3b23a701c35980cf74dd7cc39e3ccc30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20bd7bfa3b23a701c35980cf74dd7cc39e3ccc30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20bd7bfa3b23a701c35980cf74dd7cc39e3ccc30/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "76f941a84733b761b149f527c5c6a2ebc7e024ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76f941a84733b761b149f527c5c6a2ebc7e024ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76f941a84733b761b149f527c5c6a2ebc7e024ed"}], "stats": {"total": 44, "additions": 29, "deletions": 15}, "files": [{"sha": "991af6cc155a460931e844e6ce0ee67d9c3c69ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bd7bfa3b23a701c35980cf74dd7cc39e3ccc30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bd7bfa3b23a701c35980cf74dd7cc39e3ccc30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20bd7bfa3b23a701c35980cf74dd7cc39e3ccc30", "patch": "@@ -1,3 +1,11 @@\n+Tue Aug 29 15:17:54 EDT 2000  John Wehle  (john@feith.com)\n+\n+\t* loop.c (prescan_loop): Don't check unknown_address_altered\n+\twhen deciding if insert_loop_mem is safe.  Add BLKmode MEMs\n+\tto loop_store_mems as necessary.\n+\t(loop_invariant_p): Don't check unknown_address_altered\n+\tor unknown_constant_address_altered.\n+\n 2000-08-29  J. David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* vax.md (sltu, sgeu): Delete sltu and sgeu insn patterns."}, {"sha": "5c70055d26551163aa40e1a8fa10956851f49844", "filename": "gcc/loop.c", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bd7bfa3b23a701c35980cf74dd7cc39e3ccc30/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bd7bfa3b23a701c35980cf74dd7cc39e3ccc30/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=20bd7bfa3b23a701c35980cf74dd7cc39e3ccc30", "patch": "@@ -2451,11 +2451,9 @@ prescan_loop (loop)\n     }\n \n   /* Now, rescan the loop, setting up the LOOP_MEMS array.  */\n-  if (/* We can't tell what MEMs are aliased by what.  */\n-      ! unknown_address_altered\n-      /* An exception thrown by a called function might land us\n+  if (/* An exception thrown by a called function might land us\n \t anywhere.  */\n-      && ! loop_info->has_call\n+      ! loop_info->has_call\n       /* We don't want loads for MEMs moved to a location before the\n \t one at which their stack memory becomes allocated.  (Note\n \t that this is not a problem for malloc, etc., since those\n@@ -2467,6 +2465,23 @@ prescan_loop (loop)\n     for (insn = NEXT_INSN (start); insn != NEXT_INSN (end);\n \t insn = NEXT_INSN (insn))\n       for_each_rtx (&insn, insert_loop_mem, 0);\n+\n+  /* BLKmode MEMs are added to LOOP_STORE_MEM as necessary so\n+     that loop_invariant_p and load_mems can use true_dependence\n+     to determine what is really clobbered.  */\n+  if (unknown_address_altered)\n+    {\n+      rtx mem = gen_rtx_MEM (BLKmode, const0_rtx);\n+\n+      loop_store_mems = gen_rtx_EXPR_LIST (VOIDmode, mem, loop_store_mems);\n+    }\n+  if (unknown_constant_address_altered)\n+    {\n+      rtx mem = gen_rtx_MEM (BLKmode, const0_rtx);\n+\n+      RTX_UNCHANGING_P (mem) = 1;\n+      loop_store_mems = gen_rtx_EXPR_LIST (VOIDmode, mem, loop_store_mems);\n+    }\n }\n \f\n /* LOOP->CONT_DOMINATOR is now the last label between the loop start\n@@ -3136,9 +3151,8 @@ note_set_pseudo_multiple_uses (x, y, data)\n \n    The value is 2 if we refer to something only conditionally invariant.\n \n-   If `unknown_address_altered' is nonzero, no memory ref is invariant.\n-   Otherwise, a memory ref is invariant if it does not conflict with\n-   anything stored in `loop_store_mems'.  */\n+   A memory ref is invariant if it is not volatile and does not conflict\n+   with anything stored in `loop_store_mems'.  */\n \n int\n loop_invariant_p (loop, x)\n@@ -3207,14 +3221,6 @@ loop_invariant_p (loop, x)\n       if (MEM_VOLATILE_P (x))\n \treturn 0;\n \n-      /* If we had a subroutine call, any location in memory could\n-\t have been clobbered.  We used to test here for volatile and\n-\t readonly, but true_dependence knows how to do that better\n-\t than we do.  */\n-      if (RTX_UNCHANGING_P (x)\n-\t  ? unknown_constant_address_altered : unknown_address_altered)\n-\treturn 0;\n-\n       /* See if there is any dependence between a store and this load.  */\n       mem_list_entry = loop_store_mems;\n       while (mem_list_entry)"}]}