{"sha": "88512ba0b895155c90c768ec9f3fbd0f6c7ca06d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg1MTJiYTBiODk1MTU1YzkwYzc2OGVjOWYzZmJkMGY2YzdjYTA2ZA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2007-01-31T03:45:38Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2007-01-31T03:45:38Z"}, "message": "cgraphunit.c, [...]: Fix comment typos.\n\n\t* cgraphunit.c, config/arm/arm.c, config/m68k/m68k.c,\n\tipa-inline.c, tree-profile.c, tree-ssa-live.c,\n\ttree-ssa-math-opts.c, tree-ssanames.c, tree-vect-analyze.c,\n\tvalue-prof.c: Fix comment typos.\n\nFrom-SVN: r121374", "tree": {"sha": "dd7705242a6f3829eaaeda8c5fd84385708e0595", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd7705242a6f3829eaaeda8c5fd84385708e0595"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/comments", "author": null, "committer": null, "parents": [{"sha": "65de695fa500860d057a377fd7da61059dced000", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65de695fa500860d057a377fd7da61059dced000", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65de695fa500860d057a377fd7da61059dced000"}], "stats": {"total": 49, "additions": 28, "deletions": 21}, "files": [{"sha": "64e97e50c5bd82cf9b460366027c1b58a306f309", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88512ba0b895155c90c768ec9f3fbd0f6c7ca06d", "patch": "@@ -1,3 +1,10 @@\n+2007-01-31  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* cgraphunit.c, config/arm/arm.c, config/m68k/m68k.c,\n+\tipa-inline.c, tree-profile.c, tree-ssa-live.c,\n+\ttree-ssa-math-opts.c, tree-ssanames.c, tree-vect-analyze.c,\n+\tvalue-prof.c: Fix comment typos.\n+\n 2007-01-30  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR c++/24745"}, {"sha": "892e952e238d4b035a014f775f5053b63d8d1b0e", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=88512ba0b895155c90c768ec9f3fbd0f6c7ca06d", "patch": "@@ -783,7 +783,7 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n /* Process CGRAPH_NODES_NEEDED queue, analyze each function (and transitively\n    each reachable functions) and build cgraph.\n    The function can be called multiple times after inserting new nodes\n-   into beggining of queue.  Just the new part of queue is re-scanned then.  */\n+   into beginning of queue.  Just the new part of queue is re-scanned then.  */\n \n static void\n cgraph_analyze_functions (void)"}, {"sha": "c342f2fdac2811973b581c9a5be950118b6d6bd3", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=88512ba0b895155c90c768ec9f3fbd0f6c7ca06d", "patch": "@@ -7710,7 +7710,7 @@ get_jump_table_size (rtx insn)\n       switch (modesize)\n \t{\n \tcase 1:\n-\t  /* Round up size of TBB table to a haflword boundary.  */\n+\t  /* Round up size  of TBB table to a halfword boundary.  */\n \t  size = (size + 1) & ~(HOST_WIDE_INT)1;\n \t  break;\n \tcase 2:"}, {"sha": "edf1dc61fe42f4ee121e5b7352c09746d68d37b8", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=88512ba0b895155c90c768ec9f3fbd0f6c7ca06d", "patch": "@@ -1957,7 +1957,7 @@ m68k_rtx_costs (rtx x, int code, int outer_code, int *total)\n     }\n }\n \n-/* Return an instruction to move CONST_INT OPERANDS[1] into data regsiter\n+/* Return an instruction to move CONST_INT OPERANDS[1] into data register\n    OPERANDS[0].  */\n \n static const char *\n@@ -2838,7 +2838,7 @@ notice_update_cc (rtx exp, rtx insn)\n \t codes.  Normal moves _do_ set the condition codes, but not in\n \t a way that is appropriate for comparison with 0, because -0.0\n \t would be treated as a negative nonzero number.  Note that it\n-\t isn't appropriate to conditionalize this restiction on\n+\t isn't appropriate to conditionalize this restriction on\n \t HONOR_SIGNED_ZEROS because that macro merely indicates whether\n \t we care about the difference between -0.0 and +0.0.  */\n       else if (!FP_REG_P (SET_DEST (exp))"}, {"sha": "8b63b51c7f53b4fb989c310561a27918f179cac2", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=88512ba0b895155c90c768ec9f3fbd0f6c7ca06d", "patch": "@@ -91,11 +91,11 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n      maintained by pass manager).  The functions after inlining are early\n      optimized so the early inliner sees unoptimized function itself, but\n      all considered callees are already optimized allowing it to unfold\n-     abstraction penalty on C++ effectivly and cheaply.\n+     abstraction penalty on C++ effectively and cheaply.\n \n    pass_ipa_early_inlining\n \n-     With profiling, the early inlining is also neccesary to reduce\n+     With profiling, the early inlining is also necessary to reduce\n      instrumentation costs on program with high abstraction penalty (doing\n      many redundant calls).  This can't happen in parallel with early\n      optimization and profile instrumentation, because we would end up\n@@ -751,7 +751,7 @@ cgraph_set_inline_failed (struct cgraph_node *node, const char *reason)\n       e->inline_failed = reason;\n }\n \n-/* Given whole compilation unit esitmate of INSNS, compute how large we can\n+/* Given whole compilation unit estimate of INSNS, compute how large we can\n    allow the unit to grow.  */\n static int\n compute_max_insns (int insns)\n@@ -1043,7 +1043,7 @@ cgraph_decide_inlining (void)\n \t\t     e->caller->global.insns);\n \t}\n       /* Inlining self recursive function might introduce new calls to\n-\t thsemselves we didn't see in the loop above.  Fill in the proper\n+\t themselves we didn't see in the loop above.  Fill in the proper\n \t reason why inline failed.  */\n       for (e = node->callers; e; e = e->next_caller)\n \tif (e->inline_failed)\n@@ -1126,7 +1126,7 @@ cgraph_decide_inlining (void)\n    recursive inlining, but as an special case, we want to try harder inline\n    ALWAYS_INLINE functions: consider callgraph a->b->c->b, with a being\n    flatten, b being always inline.  Flattening 'a' will collapse\n-   a->b->c before hitting cycle.  To accomondate always inline, we however\n+   a->b->c before hitting cycle.  To accommodate always inline, we however\n    need to inline a->b->c->b.\n \n    So after hitting cycle first time, we switch into ALWAYS_INLINE mode and\n@@ -1145,7 +1145,7 @@ try_inline (struct cgraph_edge *e, enum inlining_mode mode, int depth)\n \t mode yet.  and the function in question is always_inline.  */\n       if (always_inline && mode != INLINE_ALWAYS_INLINE)\n \tmode = INLINE_ALWAYS_INLINE;\n-      /* Otheriwse it is time to give up.  */\n+      /* Otherwise it is time to give up.  */\n       else\n \t{\n \t  if (dump_file)"}, {"sha": "b819665838521b0d06ea58463858f67d7fb159a3", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=88512ba0b895155c90c768ec9f3fbd0f6c7ca06d", "patch": "@@ -64,7 +64,7 @@ static GTY(()) tree ptr_void;\n \n /* Add code:\n    static gcov*\t__gcov_indirect_call_counters; // pointer to actual counter\n-   static void*\t__gcov_indirect_call_callee; // actual callie addres\n+   static void*\t__gcov_indirect_call_callee; // actual callee address\n */\n static void\n tree_init_ic_make_global_vars (void)\n@@ -269,7 +269,7 @@ tree_gen_one_value_profiler (histogram_value value, unsigned tag, unsigned base)\n \n /* Output instructions as GIMPLE trees for code to find the most\n    common called function in indirect call.  \n-   VALUE is the call expression whose indirect callie is profiled.\n+   VALUE is the call expression whose indirect callee is profiled.\n    TAG is the tag of the section for counters, BASE is offset of the\n    counter position.  */\n \n@@ -308,7 +308,7 @@ tree_gen_ic_profiler (histogram_value value, unsigned tag, unsigned base)\n \n /* Output instructions as GIMPLE trees for code to find the most\n    common called function in indirect call. Insert instructions at the\n-   begining of every possible called function.\n+   beginning of every possible called function.\n   */\n \n static void"}, {"sha": "0113b1b36e7bba19359b741bb4273b2f089a0a3b", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=88512ba0b895155c90c768ec9f3fbd0f6c7ca06d", "patch": "@@ -504,7 +504,7 @@ remove_unused_locals (void)\n \n   /* Remove unused variables from REFERENCED_VARs.  As an special exception\n      keep the variables that are believed to be aliased.  Those can't be\n-     easilly removed from the alias sets and and operand caches.\n+     easily removed from the alias sets and and operand caches.\n      They will be removed shortly after next may_alias pass is performed.  */\n   FOR_EACH_REFERENCED_VAR (t, rvi)\n     if (!is_global_var (t)"}, {"sha": "bb51c3186e64ec6c9dcc7cf8570a7b5aa0a63241", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=88512ba0b895155c90c768ec9f3fbd0f6c7ca06d", "patch": "@@ -521,9 +521,9 @@ struct tree_opt_pass pass_cse_reciprocals =\n   0\t\t\t\t        /* letter */\n };\n \n-/* Records an occurance at statement USE_STMT in the vector of trees\n+/* Records an occurrence at statement USE_STMT in the vector of trees\n    STMTS if it is dominated by *TOP_BB or dominates it or this basic block\n-   is not yet initialized.  Returns true if the occurance was pushed on\n+   is not yet initialized.  Returns true if the occurrence was pushed on\n    the vector.  Adjusts *TOP_BB to be the basic block dominating all\n    statements in the vector.  */\n "}, {"sha": "9c61a3f1c386e36ee9c4bdf29f9c6631c317b172", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=88512ba0b895155c90c768ec9f3fbd0f6c7ca06d", "patch": "@@ -318,7 +318,7 @@ release_dead_ssa_names (void)\n   referenced_var_iterator rvi;\n \n   /* Current defs point to various dead SSA names that in turn points to dead\n-     statements so bunch of dead memory is holded from releasing.  */\n+     statements so bunch of dead memory is held from releasing.  */\n   FOR_EACH_REFERENCED_VAR (t, rvi)\n     set_current_def (t, NULL);\n   /* Now release the freelist.  */\n@@ -328,7 +328,7 @@ release_dead_ssa_names (void)\n       /* Dangling pointers might make GGC to still see dead SSA names, so it is\n  \t important to unlink the list and avoid GGC from seeing all subsequent\n \t SSA names.  In longer run we want to have all dangling pointers here\n-\t removed (since they usually go trhough dead statements that consume\n+\t removed (since they usually go through dead statements that consume\n \t considerable amounts of memory).  */\n       TREE_CHAIN (t) = NULL_TREE;\n       n++;"}, {"sha": "88c937c3fa3bf5f23246b2a6e2cd7e9a2f1e675d", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=88512ba0b895155c90c768ec9f3fbd0f6c7ca06d", "patch": "@@ -164,7 +164,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t\t arguments (e.g. demotion, promotion), vectype will be reset \n \t\t appropriately (later).  Note that we have to visit the smallest \n \t\t datatype in this function, because that determines the VF.  \n-\t\t If the samallest datatype in the loop is present only as the \n+\t\t If the smallest datatype in the loop is present only as the \n \t\t rhs of a promotion operation - we'd miss it here.\n \t\t However, in such a case, that a variable of this datatype\n \t\t does not appear in the lhs anywhere in the loop, it shouldn't\n@@ -1752,7 +1752,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n                   return false; \n                 }\n \n-              /* Check that there is no load-store dependecies for this loads \n+              /* Check that there is no load-store dependencies for this loads \n                  to prevent a case of load-store-load to the same location.  */\n               if (DR_GROUP_READ_WRITE_DEPENDENCE (vinfo_for_stmt (next))\n                   || DR_GROUP_READ_WRITE_DEPENDENCE (vinfo_for_stmt (prev)))"}, {"sha": "0d5f0411e1d1aa0a7e8058cc57b720ba013c8395", "filename": "gcc/value-prof.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88512ba0b895155c90c768ec9f3fbd0f6c7ca06d/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=88512ba0b895155c90c768ec9f3fbd0f6c7ca06d", "patch": "@@ -63,7 +63,7 @@ static struct value_prof_hooks *value_prof_hooks;\n \n    3) Indirect/virtual call specialization. If we can determine most\n       common function callee in indirect/virtual call. We can use this\n-      information to improve code effectivity (espetialy info for\n+      information to improve code effectiveness (especially info for\n       inliner).\n \n    Every such optimization should add its requirements for profiled values to"}]}