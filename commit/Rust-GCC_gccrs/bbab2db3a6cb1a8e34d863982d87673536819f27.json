{"sha": "bbab2db3a6cb1a8e34d863982d87673536819f27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJhYjJkYjNhNmNiMWE4ZTM0ZDg2Mzk4MmQ4NzY3MzUzNjgxOWYyNw==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2020-04-07T05:14:26Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-17T08:14:06Z"}, "message": "[Ada] Implement static expression functions for Ada 202x (AI12-0075)\n\n2020-06-17  Gary Dismukes  <dismukes@adacore.com>\n\ngcc/ada/\n\n\t* aspects.ads (type Aspect_Id): Add Aspect_Static as a Boolean\n\taspect, and update the Is_Representation_Aspect, Aspect_Names,\n\tand Aspect_Delay arrays.\n\t* exp_ch6.adb (Expand_Simple_Function_Return): In the case of a\n\treturn for a static expression function, capture a copy of the\n\texpression of the return statement before it's expanded and\n\treset its Analyzed flags. Then, just before leaving this\n\tprocedure, if the expression was rewritten, set the\n\tOriginal_Node of the rewritten expression to the new copy and\n\talso set the Expression of the associated static expression\n\tfunction to designate that copy. This ensures that later copies\n\tof the expression made via New_Copy_Tree will fully copy all\n\tnodes of the expression tree.\n\t* inline.ads (Inline_Static_Expression_Function_Call): New\n\tprocedure to evaluate and produce the result of a static call to\n\ta static expression function.\n\t* inline.adb: Add with and use for Sem_Res.\n\t(Establish_Actual_Mapping_For_Inlined_Call): New procedure\n\textracted from code in Expand_Inlined_Call that traverses the\n\tactuals and formals of an inlined call and in some cases creates\n\ttemporaries for holding the actuals, plus establishes an\n\tassociation between formals and actuals (via the Renamed_Object\n\tfields of the formals).\n\t(Formal_Is_Used_Once): Function removed from Expand_Inlined_Call\n\tand now nested in the above procedure.\n\t(Expand_Inlined_Call): Code for doing the formal/actual\n\ttraversal is moved to Create_Actual_Temporaries and replaced\n\twith a call to that new procedure.\n\t(Inline_Static_Expression_Function_Call): New procedure to\n\tevaluate a static call to a static expression function,\n\tsubstituting actuals for their corresponding formals and\n\tproducing a fully folded and static result expression. The\n\tfunction has subsidiary functions Replace_Formal and Reset_Sloc\n\tthat take care of doing the mapping of formals to actuals and\n\tresetting the Slocs of subnodes of the mapped expression to that\n\tof the call so errors will be flagged on the call rather than\n\tfunction.\n\t* sem_ch6.adb (Analyze_Expression_Function): In the case of a\n\tstatic expression function, perform an additional preanalysis of\n\tthe function's expression to ensure that it's a potentially\n\tstatic expression (according to the requirements of\n\t6.8(3.2/5-3.4/5)), and issue an error if it's not. The global\n\tflag Checking_Potentially_Static_Expression is set and unset\n\taround this checking.\n\t* sem_ch13.adb (Analyze_Aspect_Static): New procedure to enforce\n\tselected requirements of the new aspect Static on expression\n\tfunctions, including checking that the language version is\n\tAda_2020 and that the entity to which it applies is an\n\texpression function whose formal parameters are of a static\n\tsubtype and have mode 'in', its result subtype is a static\n\tsubtype, and it has no pre- or postcondition aspects. A ???\n\tcomment is added to indicate the need for adding checking that\n\ttype invariants don't apply to the result type if the function\n\tis a boundary entity.\n\t(Analyze_One_Aspect): Call Analyze_Aspect_Static for aspect\n\tStatic.\n\t* sem_elab.adb (Build_Call_Marker): Return without creating a\n\tcall marker when the subprogram is a static expression function,\n\tsince no ABE checking is needed for such functions.\n\t* sem_eval.ads (Checking_Potentially_Static_Expression): New\n\tfunction to return whether the checking for potentially static\n\texpressions is enabled.\n\t(Set_Checking_Potentially_Static_Expression): New procedure to\n\tenable or disable checking of potentially static expressions.\n\t* sem_eval.adb (Checking_For_Potentially_Static_Expression): New\n\tglobal flag for determining whether preanalysis of potentially\n\tstatic expression is being done, which affects the behavior of\n\tcertain static evaluation routines.\n\t(Checking_Potentially_Static_Expression): New function to return\n\twhether the checking for potentially static expressions is\n\tenabled.\n\t(Eval_Call): When evaluating a call within a static expression\n\tfunction with checking of potentially static expression\n\tfunctions enabled, substitutes a static value in place of the\n\tcall to allow folding of the expression.\n\t(Eval_Entity_Name): When evaluating a formal parameter of a\n\tstatic expression function with checking of potentially static\n\texpression functions enabled, substitutes a static value in\n\tplace of the reference to the formal to allow folding of the\n\texpression.\n\t(Set_Checking_Potentially_Static_Expression): New procedure to\n\tenable or disable checking of potentially static expressions.\n\t* sem_res.adb (Resolve_Call): Test for a recursive call\n\toccurring within a static expression function and issue an error\n\tfor such a call. Prevent the establishment of a transient scope\n\tin the case this is a call to a (string-returning) static\n\texpression function. When calling a static expression function,\n\tif no error has been posted on the function, call\n\tInline_Static_Expression_Function_Call to convert the call into\n\tits equivalent static value.\n\t* sem_util.ads (Is_Static_Expression_Function): New function\n\treturning whether the subprogram entity passed to it is a static\n\texpression function.\n\t(Is_Static_Expression_Function_Call): New function to determine\n\twhether the call node passed to it is a static call to a static\n\texpression function.\n\t* sem_util.adb (Compile_Time_Constraint_Error): Suppress\n\tcompile-time Constraint_Error reporting when checking for a\n\tpotentially static expression.\n\t(Is_Static_Expression_Function): New function returning whether\n\tthe subprogram entity passed to it is a static expression\n\tfunction by testing for the presence of aspect Static.\n\t(Has_All_Static_Actuals): New function in\n\tIs_Static_Expression_Function_Call that traverses the actual\n\tparameters of a function call and returns True only when all of\n\tthe actuals are given by static expressions. In the case of a\n\tstring-returning function, we call Resolve on each actual to\n\tensure that their Is_Static_Expression flag properly reflects\n\twhether they're static, to allow suppressing creation of a\n\ttransient scope within Resolve_Call. A prominent ??? comment is\n\tadded to explain this rather unconventional call to Resolve.\n\t(Is_Static_Expression_Function_Call): New function that\n\tdetermines whether a node passed to it is a call to a static\n\texpression function all of whose actual parameters are given by\n\tstatic expressions.", "tree": {"sha": "53865934e6b96f502c8e2c2c42f6d8981ef3da51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53865934e6b96f502c8e2c2c42f6d8981ef3da51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbab2db3a6cb1a8e34d863982d87673536819f27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbab2db3a6cb1a8e34d863982d87673536819f27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbab2db3a6cb1a8e34d863982d87673536819f27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbab2db3a6cb1a8e34d863982d87673536819f27/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22b5aff279b2d0e0c205b753f18f88fceb85df9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22b5aff279b2d0e0c205b753f18f88fceb85df9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22b5aff279b2d0e0c205b753f18f88fceb85df9c"}], "stats": {"total": 1717, "additions": 1162, "deletions": 555}, "files": [{"sha": "e6425a80639e109a8fc662e6378ce68e9c615fd8", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=bbab2db3a6cb1a8e34d863982d87673536819f27", "patch": "@@ -207,6 +207,7 @@ package Aspects is\n       Aspect_Remote_Access_Type,            -- GNAT\n       Aspect_Shared,                        -- GNAT (equivalent to Atomic)\n       Aspect_Simple_Storage_Pool_Type,      -- GNAT\n+      Aspect_Static,\n       Aspect_Suppress_Debug_Info,           -- GNAT\n       Aspect_Suppress_Initialization,       -- GNAT\n       Aspect_Thread_Local_Storage,          -- GNAT\n@@ -554,6 +555,7 @@ package Aspects is\n       Aspect_Remote_Access_Type           => False,\n       Aspect_Shared                       => True,\n       Aspect_Simple_Storage_Pool_Type     => True,\n+      Aspect_Static                       => False,\n       Aspect_Suppress_Debug_Info          => False,\n       Aspect_Suppress_Initialization      => False,\n       Aspect_Thread_Local_Storage         => True,\n@@ -679,6 +681,7 @@ package Aspects is\n       Aspect_Size                         => Name_Size,\n       Aspect_Small                        => Name_Small,\n       Aspect_SPARK_Mode                   => Name_SPARK_Mode,\n+      Aspect_Static                       => Name_Static,\n       Aspect_Static_Predicate             => Name_Static_Predicate,\n       Aspect_Storage_Pool                 => Name_Storage_Pool,\n       Aspect_Storage_Size                 => Name_Storage_Size,\n@@ -934,6 +937,7 @@ package Aspects is\n       Aspect_Refined_State                => Never_Delay,\n       Aspect_Relaxed_Initialization       => Never_Delay,\n       Aspect_SPARK_Mode                   => Never_Delay,\n+      Aspect_Static                       => Never_Delay,\n       Aspect_Synchronization              => Never_Delay,\n       Aspect_Test_Case                    => Never_Delay,\n       Aspect_Unimplemented                => Never_Delay,"}, {"sha": "2d065aa8e146a7d515b4eff8e5b0973b71bb7c15", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=bbab2db3a6cb1a8e34d863982d87673536819f27", "patch": "@@ -7284,9 +7284,33 @@ package body Exp_Ch6 is\n                  Reason => PE_Accessibility_Check_Failed));\n       end Check_Against_Result_Level;\n \n+      --  Local Data\n+\n+      New_Copy_Of_Exp : Node_Id := Empty;\n+\n    --  Start of processing for Expand_Simple_Function_Return\n \n    begin\n+      --  For static expression functions, the expression of the function\n+      --  needs to be available in a form that can be replicated later for\n+      --  calls, but rewriting of the return expression in the body created\n+      --  for expression functions will cause the original expression to no\n+      --  longer be properly copyable via New_Copy_Tree, because the Parent\n+      --  fields of the nodes will now point to nodes in the rewritten tree,\n+      --  and New_Copy_Tree won't copy the deeper nodes of the original tree.\n+      --  So we work around that by making a copy of the expression tree\n+      --  before any rewriting occurs, and replacing the original expression\n+      --  tree with this copy (see the end of this procedure). We also reset\n+      --  the Analyzed flags on the nodes in the tree copy to ensure that\n+      --  later copies of the tree will be fully reanalyzed. This copying\n+      --  is of course rather inelegant, to say the least, and it would be\n+      --  nice if there were a way to avoid it. ???\n+\n+      if Is_Static_Expression_Function (Scope_Id) then\n+         New_Copy_Of_Exp := New_Copy_Tree (Exp);\n+         Reset_Analyzed_Flags (New_Copy_Of_Exp);\n+      end if;\n+\n       if Is_Class_Wide_Type (R_Type)\n         and then not Is_Class_Wide_Type (Exp_Typ)\n         and then Nkind (Exp) /= N_Type_Conversion\n@@ -7997,6 +8021,21 @@ package body Exp_Ch6 is\n          Rewrite (Exp, Convert_To (Utyp, Relocate_Node (Exp)));\n          Analyze_And_Resolve (Exp);\n       end if;\n+\n+      --  If a new copy of a static expression function's expression was made\n+      --  (see the beginning of this procedure's statement part), then we now\n+      --  replace the original expression tree with the copy and also change\n+      --  the Original_Node field of the rewritten expression to point to that\n+      --  copy. It would be nice to find a way to avoid this???\n+\n+      if Present (New_Copy_Of_Exp) then\n+         Set_Expression\n+           (Original_Node (Subprogram_Spec (Scope_Id)), New_Copy_Of_Exp);\n+\n+         if Exp /= Original_Node (Exp) then\n+            Set_Original_Node (Exp, New_Copy_Of_Exp);\n+         end if;\n+      end if;\n    end Expand_Simple_Function_Return;\n \n    -----------------------"}, {"sha": "d1a6ee3760f0c074bb76938b582179db52bf003f", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 723, "deletions": 553, "changes": 1276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=bbab2db3a6cb1a8e34d863982d87673536819f27", "patch": "@@ -47,6 +47,7 @@ with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch10; use Sem_Ch10;\n with Sem_Ch12; use Sem_Ch12;\n with Sem_Prag; use Sem_Prag;\n+with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n@@ -265,6 +266,19 @@ package body Inline is\n    --  Make entry in Inlined table for subprogram E, or return table index\n    --  that already holds E.\n \n+   procedure Establish_Actual_Mapping_For_Inlined_Call\n+     (N                     : Node_Id;\n+      Subp                  : Entity_Id;\n+      Decls                 : List_Id;\n+      Body_Or_Expr_To_Check : Node_Id);\n+   --  Establish a mapping from formals to actuals in the call N for the target\n+   --  subprogram Subp, and create temporaries or renamings when needed for the\n+   --  actuals that are expressions (except for actuals given by simple entity\n+   --  names or literals) or that are scalars that require copying to preserve\n+   --  semantics. Any temporary objects that are created are inserted in Decls.\n+   --  Body_Or_Expr_To_Check indicates the target body (or possibly expression\n+   --  of an expression function), which may be traversed to count formal uses.\n+\n    function Get_Code_Unit_Entity (E : Entity_Id) return Entity_Id;\n    pragma Inline (Get_Code_Unit_Entity);\n    --  Return the entity node for the unit containing E. Always return the spec\n@@ -307,6 +321,10 @@ package body Inline is\n    --    Unmodified\n    --    Unreferenced\n \n+   procedure Reset_Actual_Mapping_For_Inlined_Call (Subp : Entity_Id);\n+   --  Reset the Renamed_Object flags on the formals of Subp, which can be set\n+   --  by a call to Establish_Actual_Mapping_For_Inlined_Call.\n+\n    ------------------------------\n    -- Deferred Cleanup Actions --\n    ------------------------------\n@@ -2791,209 +2809,476 @@ package body Inline is\n       end loop;\n    end Cleanup_Scopes;\n \n-   -------------------------\n-   -- Expand_Inlined_Call --\n-   -------------------------\n-\n-   procedure Expand_Inlined_Call\n-    (N         : Node_Id;\n-     Subp      : Entity_Id;\n-     Orig_Subp : Entity_Id)\n+   procedure Establish_Actual_Mapping_For_Inlined_Call\n+     (N                     : Node_Id;\n+      Subp                  : Entity_Id;\n+      Decls                 : List_Id;\n+      Body_Or_Expr_To_Check : Node_Id)\n    is\n-      Decls     : constant List_Id    := New_List;\n-      Is_Predef : constant Boolean    :=\n-                    Is_Predefined_Unit (Get_Source_Unit (Subp));\n-      Loc       : constant Source_Ptr := Sloc (N);\n-      Orig_Bod  : constant Node_Id    :=\n-                    Body_To_Inline (Unit_Declaration_Node (Subp));\n \n-      Uses_Back_End : constant Boolean :=\n-                        Back_End_Inlining and then Optimization_Level > 0;\n-      --  The back-end expansion is used if the target supports back-end\n-      --  inlining and some level of optimixation is required; otherwise\n-      --  the inlining takes place fully as a tree expansion.\n+      function Formal_Is_Used_Once (Formal : Entity_Id) return Boolean;\n+      --  Determine whether a formal parameter is used only once in\n+      --  Body_Or_Expr_To_Check.\n \n-      Blk      : Node_Id;\n-      Decl     : Node_Id;\n-      Exit_Lab : Entity_Id := Empty;\n-      F        : Entity_Id;\n-      A        : Node_Id;\n-      Lab_Decl : Node_Id   := Empty;\n-      Lab_Id   : Node_Id;\n-      New_A    : Node_Id;\n-      Num_Ret  : Nat       := 0;\n-      Ret_Type : Entity_Id;\n-      Temp     : Entity_Id;\n-      Temp_Typ : Entity_Id;\n+      -------------------------\n+      -- Formal_Is_Used_Once --\n+      -------------------------\n \n-      Is_Unc      : Boolean;\n-      Is_Unc_Decl : Boolean;\n-      --  If the type returned by the function is unconstrained and the call\n-      --  can be inlined, special processing is required.\n+      function Formal_Is_Used_Once (Formal : Entity_Id) return Boolean is\n+         Use_Counter : Int := 0;\n \n-      Return_Object : Entity_Id := Empty;\n-      --  Entity in declaration in an extended_return_statement\n+         function Count_Uses (N : Node_Id) return Traverse_Result;\n+         --  Traverse the tree and count the uses of the formal parameter.\n+         --  In this case, for optimization purposes, we do not need to\n+         --  continue the traversal once more than one use is encountered.\n \n-      Targ : Node_Id := Empty;\n-      --  The target of the call. If context is an assignment statement then\n-      --  this is the left-hand side of the assignment, else it is a temporary\n-      --  to which the return value is assigned prior to rewriting the call.\n+         ----------------\n+         -- Count_Uses --\n+         ----------------\n \n-      Targ1 : Node_Id := Empty;\n-      --  A separate target used when the return type is unconstrained\n+         function Count_Uses (N : Node_Id) return Traverse_Result is\n+         begin\n+            --  The original node is an identifier\n \n-      procedure Declare_Postconditions_Result;\n-      --  When generating C code, declare _Result, which may be used in the\n-      --  inlined _Postconditions procedure to verify the return value.\n+            if Nkind (N) = N_Identifier\n+              and then Present (Entity (N))\n \n-      procedure Make_Exit_Label;\n-      --  Build declaration for exit label to be used in Return statements,\n-      --  sets Exit_Lab (the label node) and Lab_Decl (corresponding implicit\n-      --  declaration). Does nothing if Exit_Lab already set.\n+               --  Original node's entity points to the one in the copied body\n \n-      procedure Make_Loop_Labels_Unique (HSS : Node_Id);\n-      --  When compiling for CCG and performing front-end inlining, replace\n-      --  loop names and references to them so that they do not conflict with\n-      --  homographs in the current subprogram.\n+              and then Nkind (Entity (N)) = N_Identifier\n+              and then Present (Entity (Entity (N)))\n \n-      function Process_Formals (N : Node_Id) return Traverse_Result;\n-      --  Replace occurrence of a formal with the corresponding actual, or the\n-      --  thunk generated for it. Replace a return statement with an assignment\n-      --  to the target of the call, with appropriate conversions if needed.\n+               --  The entity of the copied node is the formal parameter\n \n-      function Process_Formals_In_Aspects (N : Node_Id) return Traverse_Result;\n-      --  Because aspects are linked indirectly to the rest of the tree,\n-      --  replacement of formals appearing in aspect specifications must\n-      --  be performed in a separate pass, using an instantiation of the\n-      --  previous subprogram over aspect specifications reachable from N.\n+              and then Entity (Entity (N)) = Formal\n+            then\n+               Use_Counter := Use_Counter + 1;\n \n-      function Process_Sloc (Nod : Node_Id) return Traverse_Result;\n-      --  If the call being expanded is that of an internal subprogram, set the\n-      --  sloc of the generated block to that of the call itself, so that the\n-      --  expansion is skipped by the \"next\" command in gdb. Same processing\n-      --  for a subprogram in a predefined file, e.g. Ada.Tags. If\n-      --  Debug_Generated_Code is true, suppress this change to simplify our\n-      --  own development. Same in GNATprove mode, to ensure that warnings and\n-      --  diagnostics point to the proper location.\n+               if Use_Counter > 1 then\n \n-      procedure Reset_Dispatching_Calls (N : Node_Id);\n-      --  In subtree N search for occurrences of dispatching calls that use the\n-      --  Ada 2005 Object.Operation notation and the object is a formal of the\n-      --  inlined subprogram. Reset the entity associated with Operation in all\n-      --  the found occurrences.\n+                  --  Denote more than one use and abandon the traversal\n \n-      procedure Rewrite_Function_Call (N : Node_Id; Blk : Node_Id);\n-      --  If the function body is a single expression, replace call with\n-      --  expression, else insert block appropriately.\n+                  Use_Counter := 2;\n+                  return Abandon;\n \n-      procedure Rewrite_Procedure_Call (N : Node_Id; Blk : Node_Id);\n-      --  If procedure body has no local variables, inline body without\n-      --  creating block, otherwise rewrite call with block.\n+               end if;\n+            end if;\n \n-      function Formal_Is_Used_Once (Formal : Entity_Id) return Boolean;\n-      --  Determine whether a formal parameter is used only once in Orig_Bod\n+            return OK;\n+         end Count_Uses;\n \n-      -----------------------------------\n-      -- Declare_Postconditions_Result --\n-      -----------------------------------\n+         procedure Count_Formal_Uses is new Traverse_Proc (Count_Uses);\n \n-      procedure Declare_Postconditions_Result is\n-         Enclosing_Subp : constant Entity_Id := Scope (Subp);\n+      --  Start of processing for Formal_Is_Used_Once\n \n       begin\n-         pragma Assert\n-           (Modify_Tree_For_C\n-             and then Is_Subprogram (Enclosing_Subp)\n-             and then Present (Postconditions_Proc (Enclosing_Subp)));\n+         Count_Formal_Uses (Body_Or_Expr_To_Check);\n+         return Use_Counter = 1;\n+      end Formal_Is_Used_Once;\n \n-         if Ekind (Enclosing_Subp) = E_Function then\n-            if Nkind (First (Parameter_Associations (N))) in\n-                 N_Numeric_Or_String_Literal\n-            then\n-               Append_To (Declarations (Blk),\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier =>\n-                     Make_Defining_Identifier (Loc, Name_uResult),\n-                   Constant_Present    => True,\n-                   Object_Definition   =>\n-                     New_Occurrence_Of (Etype (Enclosing_Subp), Loc),\n-                   Expression          =>\n-                     New_Copy_Tree (First (Parameter_Associations (N)))));\n-            else\n-               Append_To (Declarations (Blk),\n-                 Make_Object_Renaming_Declaration (Loc,\n-                   Defining_Identifier =>\n-                     Make_Defining_Identifier (Loc, Name_uResult),\n-                   Subtype_Mark        =>\n-                     New_Occurrence_Of (Etype (Enclosing_Subp), Loc),\n-                   Name                =>\n-                     New_Copy_Tree (First (Parameter_Associations (N)))));\n-            end if;\n-         end if;\n-      end Declare_Postconditions_Result;\n+      -- Local Data --\n \n-      ---------------------\n-      -- Make_Exit_Label --\n-      ---------------------\n+      F        : Entity_Id;\n+      A        : Node_Id;\n+      Decl     : Node_Id;\n+      Loc      : constant Source_Ptr := Sloc (N);\n+      New_A    : Node_Id;\n+      Temp     : Entity_Id;\n+      Temp_Typ : Entity_Id;\n \n-      procedure Make_Exit_Label is\n-         Lab_Ent : Entity_Id;\n-      begin\n-         if No (Exit_Lab) then\n-            Lab_Ent := Make_Temporary (Loc, 'L');\n-            Lab_Id  := New_Occurrence_Of (Lab_Ent, Loc);\n-            Exit_Lab := Make_Label (Loc, Lab_Id);\n-            Lab_Decl :=\n-              Make_Implicit_Label_Declaration (Loc,\n-                Defining_Identifier => Lab_Ent,\n-                Label_Construct     => Exit_Lab);\n-         end if;\n-      end Make_Exit_Label;\n+   --  Start of processing for Establish_Actual_Mapping_For_Inlined_Call\n \n-      -----------------------------\n-      -- Make_Loop_Labels_Unique --\n-      -----------------------------\n+   begin\n+      F := First_Formal (Subp);\n+      A := First_Actual (N);\n+      while Present (F) loop\n+         if Present (Renamed_Object (F)) then\n \n-      procedure Make_Loop_Labels_Unique (HSS : Node_Id) is\n-         function Process_Loop (N : Node_Id) return Traverse_Result;\n+            --  If expander is active, it is an error to try to inline a\n+            --  recursive program. In GNATprove mode, just indicate that the\n+            --  inlining will not happen, and mark the subprogram as not always\n+            --  inlined.\n \n-         ------------------\n-         -- Process_Loop --\n-         ------------------\n+            if GNATprove_Mode then\n+               Cannot_Inline\n+                 (\"cannot inline call to recursive subprogram?\", N, Subp);\n+               Set_Is_Inlined_Always (Subp, False);\n+            else\n+               Error_Msg_N\n+                 (\"cannot inline call to recursive subprogram\", N);\n+            end if;\n \n-         function Process_Loop (N : Node_Id) return Traverse_Result is\n-            Id  : Entity_Id;\n+            return;\n+         end if;\n \n-         begin\n-            if Nkind (N) = N_Loop_Statement\n-              and then Present (Identifier (N))\n-            then\n-               --  Create new external name for loop and update the\n-               --  corresponding entity.\n+         --  Reset Last_Assignment for any parameters of mode out or in out, to\n+         --  prevent spurious warnings about overwriting for assignments to the\n+         --  formal in the inlined code.\n \n-               Id := Entity (Identifier (N));\n-               Set_Chars (Id, New_External_Name (Chars (Id), 'L', -1));\n-               Set_Chars (Identifier (N), Chars (Id));\n+         if Is_Entity_Name (A) and then Ekind (F) /= E_In_Parameter then\n+            Set_Last_Assignment (Entity (A), Empty);\n+         end if;\n \n-            elsif Nkind (N) = N_Exit_Statement\n-              and then Present (Name (N))\n-            then\n-               --  The exit statement must name an enclosing loop, whose name\n-               --  has already been updated.\n+         --  If the argument may be a controlling argument in a call within\n+         --  the inlined body, we must preserve its class-wide nature to ensure\n+         --  that dynamic dispatching will take place subsequently. If the\n+         --  formal has a constraint, then it must be preserved to retain the\n+         --  semantics of the body.\n \n-               Set_Chars (Name (N), Chars (Entity (Name (N))));\n-            end if;\n+         if Is_Class_Wide_Type (Etype (F))\n+           or else (Is_Access_Type (Etype (F))\n+                     and then Is_Class_Wide_Type (Designated_Type (Etype (F))))\n+         then\n+            Temp_Typ := Etype (F);\n \n-            return OK;\n-         end Process_Loop;\n+         elsif Base_Type (Etype (F)) = Base_Type (Etype (A))\n+           and then Etype (F) /= Base_Type (Etype (F))\n+           and then Is_Constrained (Etype (F))\n+         then\n+            Temp_Typ := Etype (F);\n \n-         procedure Update_Loop_Names is new Traverse_Proc (Process_Loop);\n+         else\n+            Temp_Typ := Etype (A);\n+         end if;\n \n-         --  Local variables\n+         --  If the actual is a simple name or a literal, no need to\n+         --  create a temporary, object can be used directly.\n \n-         Stmt : Node_Id;\n+         --  If the actual is a literal and the formal has its address taken,\n+         --  we cannot pass the literal itself as an argument, so its value\n+         --  must be captured in a temporary. Skip this optimization in\n+         --  GNATprove mode, to make sure any check on a type conversion\n+         --  will be issued.\n \n-      --  Start of processing for Make_Loop_Labels_Unique\n+         if (Is_Entity_Name (A)\n+              and then\n+                (not Is_Scalar_Type (Etype (A))\n+                  or else Ekind (Entity (A)) = E_Enumeration_Literal)\n+              and then not GNATprove_Mode)\n+\n+         --  When the actual is an identifier and the corresponding formal is\n+         --  used only once in the original body, the formal can be substituted\n+         --  directly with the actual parameter. Skip this optimization in\n+         --  GNATprove mode, to make sure any check on a type conversion\n+         --  will be issued.\n+\n+           or else\n+             (Nkind (A) = N_Identifier\n+               and then Formal_Is_Used_Once (F)\n+               and then not GNATprove_Mode)\n+\n+           or else\n+             (Nkind_In (A, N_Real_Literal,\n+                           N_Integer_Literal,\n+                           N_Character_Literal)\n+               and then not Address_Taken (F))\n+         then\n+            if Etype (F) /= Etype (A) then\n+               Set_Renamed_Object\n+                 (F, Unchecked_Convert_To (Etype (F), Relocate_Node (A)));\n+            else\n+               Set_Renamed_Object (F, A);\n+            end if;\n+\n+         else\n+            Temp := Make_Temporary (Loc, 'C');\n+\n+            --  If the actual for an in/in-out parameter is a view conversion,\n+            --  make it into an unchecked conversion, given that an untagged\n+            --  type conversion is not a proper object for a renaming.\n+\n+            --  In-out conversions that involve real conversions have already\n+            --  been transformed in Expand_Actuals.\n+\n+            if Nkind (A) = N_Type_Conversion\n+              and then Ekind (F) /= E_In_Parameter\n+            then\n+               New_A :=\n+                 Make_Unchecked_Type_Conversion (Loc,\n+                   Subtype_Mark => New_Occurrence_Of (Etype (F), Loc),\n+                   Expression   => Relocate_Node (Expression (A)));\n+\n+            --  In GNATprove mode, keep the most precise type of the actual for\n+            --  the temporary variable, when the formal type is unconstrained.\n+            --  Otherwise, the AST may contain unexpected assignment statements\n+            --  to a temporary variable of unconstrained type renaming a local\n+            --  variable of constrained type, which is not expected by\n+            --  GNATprove.\n+\n+            elsif Etype (F) /= Etype (A)\n+              and then (not GNATprove_Mode or else Is_Constrained (Etype (F)))\n+            then\n+               New_A    := Unchecked_Convert_To (Etype (F), Relocate_Node (A));\n+               Temp_Typ := Etype (F);\n+\n+            else\n+               New_A := Relocate_Node (A);\n+            end if;\n+\n+            Set_Sloc (New_A, Sloc (N));\n+\n+            --  If the actual has a by-reference type, it cannot be copied,\n+            --  so its value is captured in a renaming declaration. Otherwise\n+            --  declare a local constant initialized with the actual.\n+\n+            --  We also use a renaming declaration for expressions of an array\n+            --  type that is not bit-packed, both for efficiency reasons and to\n+            --  respect the semantics of the call: in most cases the original\n+            --  call will pass the parameter by reference, and thus the inlined\n+            --  code will have the same semantics.\n+\n+            --  Finally, we need a renaming declaration in the case of limited\n+            --  types for which initialization cannot be by copy either.\n+\n+            if Ekind (F) = E_In_Parameter\n+              and then not Is_By_Reference_Type (Etype (A))\n+              and then not Is_Limited_Type (Etype (A))\n+              and then\n+                (not Is_Array_Type (Etype (A))\n+                  or else not Is_Object_Reference (A)\n+                  or else Is_Bit_Packed_Array (Etype (A)))\n+            then\n+               Decl :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Temp,\n+                   Constant_Present    => True,\n+                   Object_Definition   => New_Occurrence_Of (Temp_Typ, Loc),\n+                   Expression          => New_A);\n+\n+            else\n+               --  In GNATprove mode, make an explicit copy of input\n+               --  parameters when formal and actual types differ, to make\n+               --  sure any check on the type conversion will be issued.\n+               --  The legality of the copy is ensured by calling first\n+               --  Call_Can_Be_Inlined_In_GNATprove_Mode.\n+\n+               if GNATprove_Mode\n+                 and then Ekind (F) /= E_Out_Parameter\n+                 and then not Same_Type (Etype (F), Etype (A))\n+               then\n+                  pragma Assert (not Is_By_Reference_Type (Etype (A)));\n+                  pragma Assert (not Is_Limited_Type (Etype (A)));\n+\n+                  Append_To (Decls,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Make_Temporary (Loc, 'C'),\n+                      Constant_Present    => True,\n+                      Object_Definition   => New_Occurrence_Of (Temp_Typ, Loc),\n+                      Expression          => New_Copy_Tree (New_A)));\n+               end if;\n+\n+               Decl :=\n+                 Make_Object_Renaming_Declaration (Loc,\n+                   Defining_Identifier => Temp,\n+                   Subtype_Mark        => New_Occurrence_Of (Temp_Typ, Loc),\n+                   Name                => New_A);\n+            end if;\n+\n+            Append (Decl, Decls);\n+            Set_Renamed_Object (F, Temp);\n+         end if;\n+\n+         Next_Formal (F);\n+         Next_Actual (A);\n+      end loop;\n+   end Establish_Actual_Mapping_For_Inlined_Call;\n+\n+   -------------------------\n+   -- Expand_Inlined_Call --\n+   -------------------------\n+\n+   procedure Expand_Inlined_Call\n+    (N         : Node_Id;\n+     Subp      : Entity_Id;\n+     Orig_Subp : Entity_Id)\n+   is\n+      Decls     : constant List_Id    := New_List;\n+      Is_Predef : constant Boolean    :=\n+                    Is_Predefined_Unit (Get_Source_Unit (Subp));\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      Orig_Bod  : constant Node_Id    :=\n+                    Body_To_Inline (Unit_Declaration_Node (Subp));\n+\n+      Uses_Back_End : constant Boolean :=\n+                        Back_End_Inlining and then Optimization_Level > 0;\n+      --  The back-end expansion is used if the target supports back-end\n+      --  inlining and some level of optimixation is required; otherwise\n+      --  the inlining takes place fully as a tree expansion.\n+\n+      Blk      : Node_Id;\n+      Decl     : Node_Id;\n+      Exit_Lab : Entity_Id := Empty;\n+      Lab_Decl : Node_Id   := Empty;\n+      Lab_Id   : Node_Id;\n+      Num_Ret  : Nat       := 0;\n+      Ret_Type : Entity_Id;\n+      Temp     : Entity_Id;\n+\n+      Is_Unc      : Boolean;\n+      Is_Unc_Decl : Boolean;\n+      --  If the type returned by the function is unconstrained and the call\n+      --  can be inlined, special processing is required.\n+\n+      Return_Object : Entity_Id := Empty;\n+      --  Entity in declaration in an extended_return_statement\n+\n+      Targ : Node_Id := Empty;\n+      --  The target of the call. If context is an assignment statement then\n+      --  this is the left-hand side of the assignment, else it is a temporary\n+      --  to which the return value is assigned prior to rewriting the call.\n+\n+      Targ1 : Node_Id := Empty;\n+      --  A separate target used when the return type is unconstrained\n+\n+      procedure Declare_Postconditions_Result;\n+      --  When generating C code, declare _Result, which may be used in the\n+      --  inlined _Postconditions procedure to verify the return value.\n+\n+      procedure Make_Exit_Label;\n+      --  Build declaration for exit label to be used in Return statements,\n+      --  sets Exit_Lab (the label node) and Lab_Decl (corresponding implicit\n+      --  declaration). Does nothing if Exit_Lab already set.\n+\n+      procedure Make_Loop_Labels_Unique (HSS : Node_Id);\n+      --  When compiling for CCG and performing front-end inlining, replace\n+      --  loop names and references to them so that they do not conflict with\n+      --  homographs in the current subprogram.\n+\n+      function Process_Formals (N : Node_Id) return Traverse_Result;\n+      --  Replace occurrence of a formal with the corresponding actual, or the\n+      --  thunk generated for it. Replace a return statement with an assignment\n+      --  to the target of the call, with appropriate conversions if needed.\n+\n+      function Process_Formals_In_Aspects (N : Node_Id) return Traverse_Result;\n+      --  Because aspects are linked indirectly to the rest of the tree,\n+      --  replacement of formals appearing in aspect specifications must\n+      --  be performed in a separate pass, using an instantiation of the\n+      --  previous subprogram over aspect specifications reachable from N.\n+\n+      function Process_Sloc (Nod : Node_Id) return Traverse_Result;\n+      --  If the call being expanded is that of an internal subprogram, set the\n+      --  sloc of the generated block to that of the call itself, so that the\n+      --  expansion is skipped by the \"next\" command in gdb. Same processing\n+      --  for a subprogram in a predefined file, e.g. Ada.Tags. If\n+      --  Debug_Generated_Code is true, suppress this change to simplify our\n+      --  own development. Same in GNATprove mode, to ensure that warnings and\n+      --  diagnostics point to the proper location.\n+\n+      procedure Reset_Dispatching_Calls (N : Node_Id);\n+      --  In subtree N search for occurrences of dispatching calls that use the\n+      --  Ada 2005 Object.Operation notation and the object is a formal of the\n+      --  inlined subprogram. Reset the entity associated with Operation in all\n+      --  the found occurrences.\n+\n+      procedure Rewrite_Function_Call (N : Node_Id; Blk : Node_Id);\n+      --  If the function body is a single expression, replace call with\n+      --  expression, else insert block appropriately.\n+\n+      procedure Rewrite_Procedure_Call (N : Node_Id; Blk : Node_Id);\n+      --  If procedure body has no local variables, inline body without\n+      --  creating block, otherwise rewrite call with block.\n+\n+      -----------------------------------\n+      -- Declare_Postconditions_Result --\n+      -----------------------------------\n+\n+      procedure Declare_Postconditions_Result is\n+         Enclosing_Subp : constant Entity_Id := Scope (Subp);\n+\n+      begin\n+         pragma Assert\n+           (Modify_Tree_For_C\n+             and then Is_Subprogram (Enclosing_Subp)\n+             and then Present (Postconditions_Proc (Enclosing_Subp)));\n+\n+         if Ekind (Enclosing_Subp) = E_Function then\n+            if Nkind (First (Parameter_Associations (N))) in\n+                 N_Numeric_Or_String_Literal\n+            then\n+               Append_To (Declarations (Blk),\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier =>\n+                     Make_Defining_Identifier (Loc, Name_uResult),\n+                   Constant_Present    => True,\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (Etype (Enclosing_Subp), Loc),\n+                   Expression          =>\n+                     New_Copy_Tree (First (Parameter_Associations (N)))));\n+            else\n+               Append_To (Declarations (Blk),\n+                 Make_Object_Renaming_Declaration (Loc,\n+                   Defining_Identifier =>\n+                     Make_Defining_Identifier (Loc, Name_uResult),\n+                   Subtype_Mark        =>\n+                     New_Occurrence_Of (Etype (Enclosing_Subp), Loc),\n+                   Name                =>\n+                     New_Copy_Tree (First (Parameter_Associations (N)))));\n+            end if;\n+         end if;\n+      end Declare_Postconditions_Result;\n+\n+      ---------------------\n+      -- Make_Exit_Label --\n+      ---------------------\n+\n+      procedure Make_Exit_Label is\n+         Lab_Ent : Entity_Id;\n+      begin\n+         if No (Exit_Lab) then\n+            Lab_Ent := Make_Temporary (Loc, 'L');\n+            Lab_Id  := New_Occurrence_Of (Lab_Ent, Loc);\n+            Exit_Lab := Make_Label (Loc, Lab_Id);\n+            Lab_Decl :=\n+              Make_Implicit_Label_Declaration (Loc,\n+                Defining_Identifier => Lab_Ent,\n+                Label_Construct     => Exit_Lab);\n+         end if;\n+      end Make_Exit_Label;\n+\n+      -----------------------------\n+      -- Make_Loop_Labels_Unique --\n+      -----------------------------\n+\n+      procedure Make_Loop_Labels_Unique (HSS : Node_Id) is\n+         function Process_Loop (N : Node_Id) return Traverse_Result;\n+\n+         ------------------\n+         -- Process_Loop --\n+         ------------------\n+\n+         function Process_Loop (N : Node_Id) return Traverse_Result is\n+            Id  : Entity_Id;\n+\n+         begin\n+            if Nkind (N) = N_Loop_Statement\n+              and then Present (Identifier (N))\n+            then\n+               --  Create new external name for loop and update the\n+               --  corresponding entity.\n+\n+               Id := Entity (Identifier (N));\n+               Set_Chars (Id, New_External_Name (Chars (Id), 'L', -1));\n+               Set_Chars (Identifier (N), Chars (Id));\n+\n+            elsif Nkind (N) = N_Exit_Statement\n+              and then Present (Name (N))\n+            then\n+               --  The exit statement must name an enclosing loop, whose name\n+               --  has already been updated.\n+\n+               Set_Chars (Name (N), Chars (Entity (Name (N))));\n+            end if;\n+\n+            return OK;\n+         end Process_Loop;\n+\n+         procedure Update_Loop_Names is new Traverse_Proc (Process_Loop);\n+\n+         --  Local variables\n+\n+         Stmt : Node_Id;\n+\n+      --  Start of processing for Make_Loop_Labels_Unique\n \n       begin\n          if Modify_Tree_For_C then\n@@ -3366,104 +3651,48 @@ package body Inline is\n             --  expanded into a procedure call which must be added after the\n             --  object declaration.\n \n-            if Is_Unc_Decl and Back_End_Inlining then\n-               Insert_Action_After (Parent (N), Blk);\n-            else\n-               Set_Expression (Parent (N), Empty);\n-               Insert_After (Parent (N), Blk);\n-            end if;\n-\n-         elsif Is_Unc and then not Back_End_Inlining then\n-            Insert_Before (Parent (N), Blk);\n-         end if;\n-      end Rewrite_Function_Call;\n-\n-      ----------------------------\n-      -- Rewrite_Procedure_Call --\n-      ----------------------------\n-\n-      procedure Rewrite_Procedure_Call (N : Node_Id; Blk : Node_Id) is\n-         HSS  : constant Node_Id := Handled_Statement_Sequence (Blk);\n-\n-      begin\n-         Make_Loop_Labels_Unique (HSS);\n-\n-         --  If there is a transient scope for N, this will be the scope of the\n-         --  actions for N, and the statements in Blk need to be within this\n-         --  scope. For example, they need to have visibility on the constant\n-         --  declarations created for the formals.\n-\n-         --  If N needs no transient scope, and if there are no declarations in\n-         --  the inlined body, we can do a little optimization and insert the\n-         --  statements for the body directly after N, and rewrite N to a\n-         --  null statement, instead of rewriting N into a full-blown block\n-         --  statement.\n-\n-         if not Scope_Is_Transient\n-           and then Is_Empty_List (Declarations (Blk))\n-         then\n-            Insert_List_After (N, Statements (HSS));\n-            Rewrite (N, Make_Null_Statement (Loc));\n-         else\n-            Rewrite (N, Blk);\n-         end if;\n-      end Rewrite_Procedure_Call;\n-\n-      -------------------------\n-      -- Formal_Is_Used_Once --\n-      -------------------------\n-\n-      function Formal_Is_Used_Once (Formal : Entity_Id) return Boolean is\n-         Use_Counter : Int := 0;\n-\n-         function Count_Uses (N : Node_Id) return Traverse_Result;\n-         --  Traverse the tree and count the uses of the formal parameter.\n-         --  In this case, for optimization purposes, we do not need to\n-         --  continue the traversal once more than one use is encountered.\n-\n-         ----------------\n-         -- Count_Uses --\n-         ----------------\n-\n-         function Count_Uses (N : Node_Id) return Traverse_Result is\n-         begin\n-            --  The original node is an identifier\n-\n-            if Nkind (N) = N_Identifier\n-              and then Present (Entity (N))\n-\n-               --  Original node's entity points to the one in the copied body\n-\n-              and then Nkind (Entity (N)) = N_Identifier\n-              and then Present (Entity (Entity (N)))\n-\n-               --  The entity of the copied node is the formal parameter\n-\n-              and then Entity (Entity (N)) = Formal\n-            then\n-               Use_Counter := Use_Counter + 1;\n-\n-               if Use_Counter > 1 then\n+            if Is_Unc_Decl and Back_End_Inlining then\n+               Insert_Action_After (Parent (N), Blk);\n+            else\n+               Set_Expression (Parent (N), Empty);\n+               Insert_After (Parent (N), Blk);\n+            end if;\n \n-                  --  Denote more than one use and abandon the traversal\n+         elsif Is_Unc and then not Back_End_Inlining then\n+            Insert_Before (Parent (N), Blk);\n+         end if;\n+      end Rewrite_Function_Call;\n \n-                  Use_Counter := 2;\n-                  return Abandon;\n+      ----------------------------\n+      -- Rewrite_Procedure_Call --\n+      ----------------------------\n \n-               end if;\n-            end if;\n+      procedure Rewrite_Procedure_Call (N : Node_Id; Blk : Node_Id) is\n+         HSS  : constant Node_Id := Handled_Statement_Sequence (Blk);\n \n-            return OK;\n-         end Count_Uses;\n+      begin\n+         Make_Loop_Labels_Unique (HSS);\n \n-         procedure Count_Formal_Uses is new Traverse_Proc (Count_Uses);\n+         --  If there is a transient scope for N, this will be the scope of the\n+         --  actions for N, and the statements in Blk need to be within this\n+         --  scope. For example, they need to have visibility on the constant\n+         --  declarations created for the formals.\n \n-      --  Start of processing for Formal_Is_Used_Once\n+         --  If N needs no transient scope, and if there are no declarations in\n+         --  the inlined body, we can do a little optimization and insert the\n+         --  statements for the body directly after N, and rewrite N to a\n+         --  null statement, instead of rewriting N into a full-blown block\n+         --  statement.\n \n-      begin\n-         Count_Formal_Uses (Orig_Bod);\n-         return Use_Counter = 1;\n-      end Formal_Is_Used_Once;\n+         if not Scope_Is_Transient\n+           and then Is_Empty_List (Declarations (Blk))\n+         then\n+            Insert_List_After (N, Statements (HSS));\n+            Rewrite (N, Make_Null_Statement (Loc));\n+         else\n+            Rewrite (N, Blk);\n+         end if;\n+      end Rewrite_Procedure_Call;\n \n    --  Start of processing for Expand_Inlined_Call\n \n@@ -3576,316 +3805,125 @@ package body Inline is\n                begin\n                   First_Decl := First (Declarations (Blk));\n \n-                  --  If the body is a single extended return statement,the\n-                  --  resulting block is a nested block.\n-\n-                  if No (First_Decl) then\n-                     First_Decl :=\n-                       First (Statements (Handled_Statement_Sequence (Blk)));\n-\n-                     if Nkind (First_Decl) = N_Block_Statement then\n-                        First_Decl := First (Declarations (First_Decl));\n-                     end if;\n-                  end if;\n-\n-                  --  No front-end inlining possible\n-\n-                  if Nkind (First_Decl) /= N_Object_Declaration then\n-                     return;\n-                  end if;\n-\n-                  if Nkind (Parent (N)) /= N_Assignment_Statement then\n-                     Targ1 := Defining_Identifier (First_Decl);\n-                  else\n-                     Targ1 := Name (Parent (N));\n-                  end if;\n-               end;\n-            end if;\n-         end;\n-\n-      --  New semantics\n-\n-      else\n-         declare\n-            Bod : Node_Id;\n-\n-         begin\n-            --  General case\n-\n-            if not Is_Unc then\n-               Bod :=\n-                 Copy_Generic_Node (Orig_Bod, Empty, Instantiating => True);\n-               Blk :=\n-                 Make_Block_Statement (Loc,\n-                   Declarations               => Declarations (Bod),\n-                   Handled_Statement_Sequence =>\n-                     Handled_Statement_Sequence (Bod));\n-\n-            --  Inline a call to a function that returns an unconstrained type.\n-            --  The semantic analyzer checked that frontend-inlined functions\n-            --  returning unconstrained types have no declarations and have\n-            --  a single extended return statement. As part of its processing\n-            --  the function was split into two subprograms: a procedure P' and\n-            --  a function F' that has a block with a call to procedure P' (see\n-            --  Split_Unconstrained_Function).\n-\n-            else\n-               pragma Assert\n-                 (Nkind\n-                   (First\n-                     (Statements (Handled_Statement_Sequence (Orig_Bod)))) =\n-                                                         N_Block_Statement);\n-\n-               declare\n-                  Blk_Stmt    : constant Node_Id :=\n-                    First (Statements (Handled_Statement_Sequence (Orig_Bod)));\n-                  First_Stmt  : constant Node_Id :=\n-                    First (Statements (Handled_Statement_Sequence (Blk_Stmt)));\n-                  Second_Stmt : constant Node_Id := Next (First_Stmt);\n-\n-               begin\n-                  pragma Assert\n-                    (Nkind (First_Stmt) = N_Procedure_Call_Statement\n-                      and then Nkind (Second_Stmt) = N_Simple_Return_Statement\n-                      and then No (Next (Second_Stmt)));\n-\n-                  Bod :=\n-                    Copy_Generic_Node\n-                      (First\n-                        (Statements (Handled_Statement_Sequence (Orig_Bod))),\n-                       Empty, Instantiating => True);\n-                  Blk := Bod;\n-\n-                  --  Capture the name of the local variable that holds the\n-                  --  result. This must be the first declaration in the block,\n-                  --  because its bounds cannot depend on local variables.\n-                  --  Otherwise there is no way to declare the result outside\n-                  --  of the block. Needless to say, in general the bounds will\n-                  --  depend on the actuals in the call.\n-\n-                  if Nkind (Parent (N)) /= N_Assignment_Statement then\n-                     Targ1 := Defining_Identifier (First (Declarations (Blk)));\n-\n-                  --  If the context is an assignment statement, as is the case\n-                  --  for the expansion of an extended return, the left-hand\n-                  --  side provides bounds even if the return type is\n-                  --  unconstrained.\n-\n-                  else\n-                     Targ1 := Name (Parent (N));\n-                  end if;\n-               end;\n-            end if;\n-\n-            if No (Declarations (Bod)) then\n-               Set_Declarations (Blk, New_List);\n-            end if;\n-         end;\n-      end if;\n-\n-      --  If this is a derived function, establish the proper return type\n-\n-      if Present (Orig_Subp) and then Orig_Subp /= Subp then\n-         Ret_Type := Etype (Orig_Subp);\n-      else\n-         Ret_Type := Etype (Subp);\n-      end if;\n-\n-      --  Create temporaries for the actuals that are expressions, or that are\n-      --  scalars and require copying to preserve semantics.\n-\n-      F := First_Formal (Subp);\n-      A := First_Actual (N);\n-      while Present (F) loop\n-         if Present (Renamed_Object (F)) then\n-\n-            --  If expander is active, it is an error to try to inline a\n-            --  recursive program. In GNATprove mode, just indicate that the\n-            --  inlining will not happen, and mark the subprogram as not always\n-            --  inlined.\n-\n-            if GNATprove_Mode then\n-               Cannot_Inline\n-                 (\"cannot inline call to recursive subprogram?\", N, Subp);\n-               Set_Is_Inlined_Always (Subp, False);\n-            else\n-               Error_Msg_N\n-                 (\"cannot inline call to recursive subprogram\", N);\n-            end if;\n-\n-            return;\n-         end if;\n-\n-         --  Reset Last_Assignment for any parameters of mode out or in out, to\n-         --  prevent spurious warnings about overwriting for assignments to the\n-         --  formal in the inlined code.\n-\n-         if Is_Entity_Name (A) and then Ekind (F) /= E_In_Parameter then\n-            Set_Last_Assignment (Entity (A), Empty);\n-         end if;\n-\n-         --  If the argument may be a controlling argument in a call within\n-         --  the inlined body, we must preserve its classwide nature to insure\n-         --  that dynamic dispatching take place subsequently. If the formal\n-         --  has a constraint it must be preserved to retain the semantics of\n-         --  the body.\n-\n-         if Is_Class_Wide_Type (Etype (F))\n-           or else (Is_Access_Type (Etype (F))\n-                     and then Is_Class_Wide_Type (Designated_Type (Etype (F))))\n-         then\n-            Temp_Typ := Etype (F);\n-\n-         elsif Base_Type (Etype (F)) = Base_Type (Etype (A))\n-           and then Etype (F) /= Base_Type (Etype (F))\n-           and then Is_Constrained (Etype (F))\n-         then\n-            Temp_Typ := Etype (F);\n-\n-         else\n-            Temp_Typ := Etype (A);\n-         end if;\n-\n-         --  If the actual is a simple name or a literal, no need to\n-         --  create a temporary, object can be used directly.\n-\n-         --  If the actual is a literal and the formal has its address taken,\n-         --  we cannot pass the literal itself as an argument, so its value\n-         --  must be captured in a temporary. Skip this optimization in\n-         --  GNATprove mode, to make sure any check on a type conversion\n-         --  will be issued.\n-\n-         if (Is_Entity_Name (A)\n-              and then\n-                (not Is_Scalar_Type (Etype (A))\n-                  or else Ekind (Entity (A)) = E_Enumeration_Literal)\n-              and then not GNATprove_Mode)\n-\n-         --  When the actual is an identifier and the corresponding formal is\n-         --  used only once in the original body, the formal can be substituted\n-         --  directly with the actual parameter. Skip this optimization in\n-         --  GNATprove mode, to make sure any check on a type conversion\n-         --  will be issued.\n-\n-           or else\n-             (Nkind (A) = N_Identifier\n-               and then Formal_Is_Used_Once (F)\n-               and then not GNATprove_Mode)\n-\n-           or else\n-             (Nkind_In (A, N_Real_Literal,\n-                           N_Integer_Literal,\n-                           N_Character_Literal)\n-               and then not Address_Taken (F))\n-         then\n-            if Etype (F) /= Etype (A) then\n-               Set_Renamed_Object\n-                 (F, Unchecked_Convert_To (Etype (F), Relocate_Node (A)));\n-            else\n-               Set_Renamed_Object (F, A);\n-            end if;\n-\n-         else\n-            Temp := Make_Temporary (Loc, 'C');\n-\n-            --  If the actual for an in/in-out parameter is a view conversion,\n-            --  make it into an unchecked conversion, given that an untagged\n-            --  type conversion is not a proper object for a renaming.\n+                  --  If the body is a single extended return statement,the\n+                  --  resulting block is a nested block.\n \n-            --  In-out conversions that involve real conversions have already\n-            --  been transformed in Expand_Actuals.\n+                  if No (First_Decl) then\n+                     First_Decl :=\n+                       First (Statements (Handled_Statement_Sequence (Blk)));\n \n-            if Nkind (A) = N_Type_Conversion\n-              and then Ekind (F) /= E_In_Parameter\n-            then\n-               New_A :=\n-                 Make_Unchecked_Type_Conversion (Loc,\n-                   Subtype_Mark => New_Occurrence_Of (Etype (F), Loc),\n-                   Expression   => Relocate_Node (Expression (A)));\n+                     if Nkind (First_Decl) = N_Block_Statement then\n+                        First_Decl := First (Declarations (First_Decl));\n+                     end if;\n+                  end if;\n \n-            --  In GNATprove mode, keep the most precise type of the actual for\n-            --  the temporary variable, when the formal type is unconstrained.\n-            --  Otherwise, the AST may contain unexpected assignment statements\n-            --  to a temporary variable of unconstrained type renaming a local\n-            --  variable of constrained type, which is not expected by\n-            --  GNATprove.\n+                  --  No front-end inlining possible\n \n-            elsif Etype (F) /= Etype (A)\n-              and then (not GNATprove_Mode or else Is_Constrained (Etype (F)))\n-            then\n-               New_A    := Unchecked_Convert_To (Etype (F), Relocate_Node (A));\n-               Temp_Typ := Etype (F);\n+                  if Nkind (First_Decl) /= N_Object_Declaration then\n+                     return;\n+                  end if;\n \n-            else\n-               New_A := Relocate_Node (A);\n+                  if Nkind (Parent (N)) /= N_Assignment_Statement then\n+                     Targ1 := Defining_Identifier (First_Decl);\n+                  else\n+                     Targ1 := Name (Parent (N));\n+                  end if;\n+               end;\n             end if;\n+         end;\n \n-            Set_Sloc (New_A, Sloc (N));\n+      --  New semantics\n \n-            --  If the actual has a by-reference type, it cannot be copied,\n-            --  so its value is captured in a renaming declaration. Otherwise\n-            --  declare a local constant initialized with the actual.\n+      else\n+         declare\n+            Bod : Node_Id;\n \n-            --  We also use a renaming declaration for expressions of an array\n-            --  type that is not bit-packed, both for efficiency reasons and to\n-            --  respect the semantics of the call: in most cases the original\n-            --  call will pass the parameter by reference, and thus the inlined\n-            --  code will have the same semantics.\n+         begin\n+            --  General case\n \n-            --  Finally, we need a renaming declaration in the case of limited\n-            --  types for which initialization cannot be by copy either.\n+            if not Is_Unc then\n+               Bod :=\n+                 Copy_Generic_Node (Orig_Bod, Empty, Instantiating => True);\n+               Blk :=\n+                 Make_Block_Statement (Loc,\n+                   Declarations               => Declarations (Bod),\n+                   Handled_Statement_Sequence =>\n+                     Handled_Statement_Sequence (Bod));\n \n-            if Ekind (F) = E_In_Parameter\n-              and then not Is_By_Reference_Type (Etype (A))\n-              and then not Is_Limited_Type (Etype (A))\n-              and then\n-                (not Is_Array_Type (Etype (A))\n-                  or else not Is_Object_Reference (A)\n-                  or else Is_Bit_Packed_Array (Etype (A)))\n-            then\n-               Decl :=\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Temp,\n-                   Constant_Present    => True,\n-                   Object_Definition   => New_Occurrence_Of (Temp_Typ, Loc),\n-                   Expression          => New_A);\n+            --  Inline a call to a function that returns an unconstrained type.\n+            --  The semantic analyzer checked that frontend-inlined functions\n+            --  returning unconstrained types have no declarations and have\n+            --  a single extended return statement. As part of its processing\n+            --  the function was split into two subprograms: a procedure P' and\n+            --  a function F' that has a block with a call to procedure P' (see\n+            --  Split_Unconstrained_Function).\n \n             else\n-               --  In GNATprove mode, make an explicit copy of input\n-               --  parameters when formal and actual types differ, to make\n-               --  sure any check on the type conversion will be issued.\n-               --  The legality of the copy is ensured by calling first\n-               --  Call_Can_Be_Inlined_In_GNATprove_Mode.\n+               pragma Assert\n+                 (Nkind\n+                   (First\n+                     (Statements (Handled_Statement_Sequence (Orig_Bod)))) =\n+                                                         N_Block_Statement);\n \n-               if GNATprove_Mode\n-                 and then Ekind (F) /= E_Out_Parameter\n-                 and then not Same_Type (Etype (F), Etype (A))\n-               then\n-                  pragma Assert (not Is_By_Reference_Type (Etype (A)));\n-                  pragma Assert (not Is_Limited_Type (Etype (A)));\n+               declare\n+                  Blk_Stmt    : constant Node_Id :=\n+                    First (Statements (Handled_Statement_Sequence (Orig_Bod)));\n+                  First_Stmt  : constant Node_Id :=\n+                    First (Statements (Handled_Statement_Sequence (Blk_Stmt)));\n+                  Second_Stmt : constant Node_Id := Next (First_Stmt);\n \n-                  Append_To (Decls,\n-                    Make_Object_Declaration (Loc,\n-                      Defining_Identifier => Make_Temporary (Loc, 'C'),\n-                      Constant_Present    => True,\n-                      Object_Definition   => New_Occurrence_Of (Temp_Typ, Loc),\n-                      Expression          => New_Copy_Tree (New_A)));\n-               end if;\n+               begin\n+                  pragma Assert\n+                    (Nkind (First_Stmt) = N_Procedure_Call_Statement\n+                      and then Nkind (Second_Stmt) = N_Simple_Return_Statement\n+                      and then No (Next (Second_Stmt)));\n \n-               Decl :=\n-                 Make_Object_Renaming_Declaration (Loc,\n-                   Defining_Identifier => Temp,\n-                   Subtype_Mark        => New_Occurrence_Of (Temp_Typ, Loc),\n-                   Name                => New_A);\n+                  Bod :=\n+                    Copy_Generic_Node\n+                      (First\n+                        (Statements (Handled_Statement_Sequence (Orig_Bod))),\n+                       Empty, Instantiating => True);\n+                  Blk := Bod;\n+\n+                  --  Capture the name of the local variable that holds the\n+                  --  result. This must be the first declaration in the block,\n+                  --  because its bounds cannot depend on local variables.\n+                  --  Otherwise there is no way to declare the result outside\n+                  --  of the block. Needless to say, in general the bounds will\n+                  --  depend on the actuals in the call.\n+\n+                  if Nkind (Parent (N)) /= N_Assignment_Statement then\n+                     Targ1 := Defining_Identifier (First (Declarations (Blk)));\n+\n+                  --  If the context is an assignment statement, as is the case\n+                  --  for the expansion of an extended return, the left-hand\n+                  --  side provides bounds even if the return type is\n+                  --  unconstrained.\n+\n+                  else\n+                     Targ1 := Name (Parent (N));\n+                  end if;\n+               end;\n             end if;\n \n-            Append (Decl, Decls);\n-            Set_Renamed_Object (F, Temp);\n-         end if;\n+            if No (Declarations (Bod)) then\n+               Set_Declarations (Blk, New_List);\n+            end if;\n+         end;\n+      end if;\n \n-         Next_Formal (F);\n-         Next_Actual (A);\n-      end loop;\n+      --  If this is a derived function, establish the proper return type\n+\n+      if Present (Orig_Subp) and then Orig_Subp /= Subp then\n+         Ret_Type := Etype (Orig_Subp);\n+      else\n+         Ret_Type := Etype (Subp);\n+      end if;\n+\n+      --  Create temporaries for the actuals that are expressions, or that are\n+      --  scalars and require copying to preserve semantics.\n+\n+      Establish_Actual_Mapping_For_Inlined_Call (N, Subp, Decls, Orig_Bod);\n \n       --  Establish target of function call. If context is not assignment or\n       --  declaration, create a temporary as a target. The declaration for the\n@@ -4148,11 +4186,7 @@ package body Inline is\n \n       --  Cleanup mapping between formals and actuals for other expansions\n \n-      F := First_Formal (Subp);\n-      while Present (F) loop\n-         Set_Renamed_Object (F, Empty);\n-         Next_Formal (F);\n-      end loop;\n+      Reset_Actual_Mapping_For_Inlined_Call (Subp);\n    end Expand_Inlined_Call;\n \n    --------------------------\n@@ -4598,6 +4632,128 @@ package body Inline is\n       Backend_Not_Inlined_Subps := No_Elist;\n    end Initialize;\n \n+   --------------------------------------------\n+   -- Inline_Static_Expression_Function_Call --\n+   --------------------------------------------\n+\n+   procedure Inline_Static_Expression_Function_Call\n+     (N : Node_Id; Subp : Entity_Id)\n+   is\n+\n+      function Replace_Formal (N : Node_Id) return Traverse_Result;\n+      --  Replace each occurrence of a formal with the corresponding actual,\n+      --  using the mapping created by Establish_Mapping_For_Inlined_Call.\n+\n+      function Reset_Sloc (Nod : Node_Id) return Traverse_Result;\n+      --  Reset the Sloc of a node to that of the call itself, so that errors\n+      --  will be flagged on the call to the static expression function itself\n+      --  rather than on the expression of the function's declaration.\n+\n+      --------------------\n+      -- Replace_Formal --\n+      --------------------\n+\n+      function Replace_Formal (N : Node_Id) return Traverse_Result is\n+         A   : Entity_Id;\n+         E   : Entity_Id;\n+\n+      begin\n+         if Is_Entity_Name (N) and then Present (Entity (N)) then\n+            E := Entity (N);\n+\n+            if Is_Formal (E) and then Scope (E) = Subp then\n+               A := Renamed_Object (E);\n+\n+               if Nkind (A) = N_Defining_Identifier then\n+                  Rewrite (N, New_Occurrence_Of (A, Sloc (N)));\n+\n+               --  Literal cases\n+\n+               else\n+                  Rewrite (N, New_Copy (A));\n+               end if;\n+            end if;\n+\n+            return Skip;\n+\n+         else\n+            return OK;\n+         end if;\n+      end Replace_Formal;\n+\n+      procedure Replace_Formals is new Traverse_Proc (Replace_Formal);\n+\n+      ------------------\n+      -- Process_Sloc --\n+      ------------------\n+\n+      function Reset_Sloc (Nod : Node_Id) return Traverse_Result is\n+      begin\n+         Set_Sloc (Nod, Sloc (N));\n+         Set_Comes_From_Source (Nod, False);\n+\n+         return OK;\n+      end Reset_Sloc;\n+\n+      procedure Reset_Slocs is new Traverse_Proc (Reset_Sloc);\n+\n+   --  Start of processing for Inline_Static_Expression_Function_Call\n+\n+   begin\n+      pragma Assert (Is_Static_Expression_Function_Call (N));\n+\n+      declare\n+         Decls     : constant List_Id := New_List;\n+         Func_Expr : constant Node_Id :=\n+                       Expression_Of_Expression_Function (Subp);\n+         Expr_Copy : constant Node_Id := New_Copy_Tree (Func_Expr);\n+\n+      begin\n+         --  Create a mapping from formals to actuals, also creating temps in\n+         --  Decls, when needed, to hold the actuals.\n+\n+         Establish_Actual_Mapping_For_Inlined_Call (N, Subp, Decls, Func_Expr);\n+\n+         Insert_Actions (N, Decls);\n+\n+         --  Now substitute actuals for their corresponding formal references\n+         --  within the expression.\n+\n+         Replace_Formals (Expr_Copy);\n+\n+         Reset_Slocs (Expr_Copy);\n+\n+         --  Apply a qualified expression with the function's result subtype,\n+         --  to ensure that we check the expression against any constraint\n+         --  or predicate, which will cause the call to be illegal if the\n+         --  folded expression doesn't satisfy them. (The predicate case\n+         --  might not get checked if the subtype hasn't been frozen yet,\n+         --  which can happen if this static expression happens to be what\n+         --  causes the freezing, because Has_Static_Predicate doesn't get\n+         --  set on the subtype until it's frozen and Build_Predicates is\n+         --  called. It's not clear how to address this case. ???)\n+\n+         Rewrite (Expr_Copy,\n+           Make_Qualified_Expression (Sloc (Expr_Copy),\n+             Subtype_Mark =>\n+               New_Occurrence_Of (Etype (N), Sloc (Expr_Copy)),\n+             Expression =>\n+               Relocate_Node (Expr_Copy)));\n+\n+         Set_Etype (Expr_Copy, Etype (N));\n+\n+         Analyze_And_Resolve (Expr_Copy, Etype (N));\n+\n+         --  Finally rewrite the function call as the folded static result\n+\n+         Rewrite (N, Expr_Copy);\n+\n+         --  Cleanup mapping between formals and actuals for other expansions\n+\n+         Reset_Actual_Mapping_For_Inlined_Call (Subp);\n+      end;\n+   end Inline_Static_Expression_Function_Call;\n+\n    ------------------------\n    -- Instantiate_Bodies --\n    ------------------------\n@@ -5002,4 +5158,18 @@ package body Inline is\n       end loop;\n    end Remove_Dead_Instance;\n \n+   -------------------------------------------\n+   -- Reset_Actual_Mapping_For_Inlined_Call --\n+   -------------------------------------------\n+\n+   procedure Reset_Actual_Mapping_For_Inlined_Call (Subp : Entity_Id) is\n+      F : Entity_Id := First_Formal (Subp);\n+\n+   begin\n+      while Present (F) loop\n+         Set_Renamed_Object (F, Empty);\n+         Next_Formal (F);\n+      end loop;\n+   end Reset_Actual_Mapping_For_Inlined_Call;\n+\n end Inline;"}, {"sha": "a7f4aabfe592e0b681eb26b287250e02a2ea804d", "filename": "gcc/ada/inline.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Finline.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Finline.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.ads?ref=bbab2db3a6cb1a8e34d863982d87673536819f27", "patch": "@@ -227,6 +227,12 @@ package Inline is\n    --  Check a list of statements, Stats, that make inlining of Subp not\n    --  worthwhile, including any tasking statement, nested at any level.\n \n+   procedure Inline_Static_Expression_Function_Call\n+     (N : Node_Id; Subp : Entity_Id);\n+   --  Evaluate static call to a static expression function Subp, substituting\n+   --  actuals in place of references to their corresponding formals and\n+   --  rewriting the call N as a fully folded and static result expression.\n+\n    procedure List_Inlining_Info;\n    --  Generate listing of calls inlined by the frontend plus listing of\n    --  calls to inline subprograms passed to the backend."}, {"sha": "abd482e5e775f8b702e63049d0384d7ac8c44509", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=bbab2db3a6cb1a8e34d863982d87673536819f27", "patch": "@@ -1792,6 +1792,9 @@ package body Sem_Ch13 is\n             procedure Analyze_Aspect_Relaxed_Initialization;\n             --  Perform analysis of aspect Relaxed_Initialization\n \n+            procedure Analyze_Aspect_Static;\n+            --  Ada 202x (AI12-0075): Perform analysis of aspect Static\n+\n             procedure Make_Aitem_Pragma\n               (Pragma_Argument_Associations : List_Id;\n                Pragma_Name                  : Name_Id);\n@@ -2309,6 +2312,129 @@ package body Sem_Ch13 is\n                end if;\n             end Analyze_Aspect_Relaxed_Initialization;\n \n+            ---------------------------\n+            -- Analyze_Aspect_Static --\n+            ---------------------------\n+\n+            procedure Analyze_Aspect_Static is\n+            begin\n+               if Ada_Version < Ada_2020 then\n+                  Error_Msg_N\n+                    (\"aspect % is an Ada 202x feature\", Aspect);\n+                  Error_Msg_N (\"\\compile with -gnat2020\", Aspect);\n+\n+                  return;\n+\n+               --  The aspect applies only to expression functions that\n+               --  statisfy the requirements for a static expression function\n+               --  (such as having an expression that is predicate-static).\n+\n+               elsif not Is_Expression_Function (E) then\n+                  Error_Msg_N\n+                    (\"aspect % requires expression function\", Aspect);\n+\n+                  return;\n+\n+               --  Ada 202x (AI12-0075): Check that the function satisfies\n+               --  several requirements of static expression functions as\n+               --  specified in RM 6.8(5.1-5.8). Note that some of the\n+               --  requirements given there are checked elsewhere.\n+\n+               else\n+                  --  The expression of the expression function must be a\n+                  --  potentially static expression (RM 202x 6.8(3.2-3.4)).\n+                  --  That's checked in Sem_Ch6.Analyze_Expression_Function.\n+\n+                  --  The function must not contain any calls to itself, which\n+                  --  is checked in Sem_Res.Resolve_Call.\n+\n+                  --  Each formal must be of mode in and have a static subtype\n+\n+                  declare\n+                     Formal : Entity_Id := First_Formal (E);\n+                  begin\n+                     while Present (Formal) loop\n+                        if Ekind (Formal) /= E_In_Parameter then\n+                           Error_Msg_N\n+                             (\"aspect % requires formals of mode IN\",\n+                              Aspect);\n+\n+                           return;\n+                        end if;\n+\n+                        if not Is_Static_Subtype (Etype (Formal)) then\n+                           Error_Msg_N\n+                             (\"aspect % requires formals with static subtypes\",\n+                              Aspect);\n+\n+                           return;\n+                        end if;\n+\n+                        Next_Formal (Formal);\n+                     end loop;\n+                  end;\n+\n+                  --  The function's result subtype must be a static subtype\n+\n+                  if not Is_Static_Subtype (Etype (E)) then\n+                     Error_Msg_N\n+                       (\"aspect % requires function with result of \"\n+                        & \"a static subtype\",\n+                        Aspect);\n+\n+                     return;\n+                  end if;\n+\n+                  --  Check that the function does not have any applicable\n+                  --  precondition or postcondition expression.\n+\n+                  for Asp in Pre_Post_Aspects loop\n+                     if Has_Aspect (E, Asp) then\n+                        Error_Msg_N\n+                          (\"this aspect not allowed for static expression \"\n+                             & \"functions\", Find_Aspect (E, Asp));\n+\n+                        return;\n+                     end if;\n+                  end loop;\n+\n+                  --  ??? TBD: Must check that \"for result type R, if the\n+                  --  function is a boundary entity for type R (see 7.3.2),\n+                  --  no type invariant applies to type R; if R has a\n+                  --  component type C, a similar rule applies to C.\"\n+               end if;\n+\n+               --  Preanalyze the expression (if any) when the aspect resides\n+               --  in a generic unit. (Is this generic-related code necessary\n+               --  for this aspect? It's modeled on what's done for aspect\n+               --  Disable_Controlled. ???)\n+\n+               if Inside_A_Generic then\n+                  if Present (Expr) then\n+                     Preanalyze_And_Resolve (Expr, Any_Boolean);\n+                  end if;\n+\n+               --  Otherwise the aspect resides in a nongeneric context\n+\n+               else\n+                  --  When the expression statically evaluates to True, the\n+                  --  expression function is treated as a static function.\n+                  --  Otherwise the aspect appears without an expression and\n+                  --  defaults to True.\n+\n+                  if Present (Expr) then\n+                     Analyze_And_Resolve (Expr, Any_Boolean);\n+\n+                     --  Error if the boolean expression is not static\n+\n+                     if not Is_OK_Static_Expression (Expr) then\n+                        Error_Msg_N\n+                          (\"expression of aspect % must be static\", Aspect);\n+                     end if;\n+                  end if;\n+               end if;\n+            end Analyze_Aspect_Static;\n+\n             -----------------------\n             -- Make_Aitem_Pragma --\n             -----------------------\n@@ -4057,6 +4183,12 @@ package body Sem_Ch13 is\n                   elsif A_Id = Aspect_Disable_Controlled then\n                      Analyze_Aspect_Disable_Controlled;\n                      goto Continue;\n+\n+                  --  Ada 202x (AI12-0075): static expression functions\n+\n+                  elsif A_Id = Aspect_Static then\n+                     Analyze_Aspect_Static;\n+                     goto Continue;\n                   end if;\n \n                   --  Library unit aspects require special handling in the case"}, {"sha": "d0d13dd6ad47308b32daad39a7d5c1ef1ca319c9", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=bbab2db3a6cb1a8e34d863982d87673536819f27", "patch": "@@ -552,6 +552,37 @@ package body Sem_Ch6 is\n                   Check_Limited_Return (Original_Node (N), Expr, Typ);\n                   End_Scope;\n                end if;\n+\n+               --  In the case of an expression function marked with the\n+               --  aspect Static, we need to check the requirement that the\n+               --  function's expression is a potentially static expression.\n+               --  This is done by making a full copy of the expression tree\n+               --  and performing a special preanalysis on that tree with\n+               --  the global flag Checking_Potentially_Static_Expression\n+               --  enabled. If the resulting expression is static, then it's\n+               --  OK, but if not, that means the expression violates the\n+               --  requirements of the Ada 202x RM in 4.9(3.2/5-3.4/5) and\n+               --  we flag an error.\n+\n+               if Is_Static_Expression_Function (Def_Id) then\n+                  if not Is_Static_Expression (Expr) then\n+                     declare\n+                        Exp_Copy : constant Node_Id := New_Copy_Tree (Expr);\n+                     begin\n+                        Set_Checking_Potentially_Static_Expression (True);\n+\n+                        Preanalyze_Formal_Expression (Exp_Copy, Typ);\n+\n+                        if not Is_Static_Expression (Exp_Copy) then\n+                           Error_Msg_N\n+                             (\"static expression function requires \"\n+                                & \"potentially static expression\", Expr);\n+                        end if;\n+\n+                        Set_Checking_Potentially_Static_Expression (False);\n+                     end;\n+                  end if;\n+               end if;\n             end if;\n          end;\n       end if;"}, {"sha": "50f0feb4b8258962f527b5ed5222a9d3663712de", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=bbab2db3a6cb1a8e34d863982d87673536819f27", "patch": "@@ -3685,6 +3685,11 @@ package body Sem_Elab is\n       then\n          return;\n \n+      --  Static expression functions require no ABE processing\n+\n+      elsif Is_Static_Expression_Function (Subp_Id) then\n+         return;\n+\n       --  Source calls to source targets are always considered because they\n       --  reflect the original call graph.\n "}, {"sha": "8fc90a5e74860f43f95162a44892e7f3aaaf1183", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=bbab2db3a6cb1a8e34d863982d87673536819f27", "patch": "@@ -131,6 +131,11 @@ package body Sem_Eval is\n    --  Range membership may either be statically known to be in range or out\n    --  of range, or not statically known. Used for Test_In_Range below.\n \n+   Checking_For_Potentially_Static_Expression : Boolean := False;\n+   --  Global flag that is set True during Analyze_Static_Expression_Function\n+   --  in order to verify that the result expression of a static expression\n+   --  function is a potentially static function (see RM202x 6.8(5.3)).\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -639,6 +644,15 @@ package body Sem_Eval is\n       end if;\n    end Check_String_Literal_Length;\n \n+   --------------------------------------------\n+   -- Checking_Potentially_Static_Expression --\n+   --------------------------------------------\n+\n+   function Checking_Potentially_Static_Expression return Boolean is\n+   begin\n+      return Checking_For_Potentially_Static_Expression;\n+   end Checking_Potentially_Static_Expression;\n+\n    --------------------\n    -- Choice_Matches --\n    --------------------\n@@ -2224,6 +2238,38 @@ package body Sem_Eval is\n \n             Resolve (N, Typ);\n          end if;\n+\n+      --  Ada 202x (AI12-0075): If checking for potentially static expressions\n+      --  is enabled and we have a call to a static expression function,\n+      --  substitute a static value for the call, to allow folding the\n+      --  expression. This supports checking the requirement of RM 6.8(5.3/5)\n+      --  in Analyze_Expression_Function.\n+\n+      elsif Checking_Potentially_Static_Expression\n+        and then Is_Static_Expression_Function_Call (N)\n+      then\n+         if Is_Integer_Type (Typ) then\n+            Fold_Uint (N, Uint_1, Static => True);\n+            return;\n+\n+         elsif Is_Real_Type (Typ) then\n+            Fold_Ureal (N, Ureal_1, Static => True);\n+            return;\n+\n+         elsif Is_Enumeration_Type (Typ) then\n+            Fold_Uint\n+              (N,\n+               Expr_Value (Type_Low_Bound (Base_Type (Typ))),\n+               Static => True);\n+            return;\n+\n+         elsif Is_String_Type (Typ) then\n+            Fold_Str\n+              (N,\n+               Strval (Make_String_Literal (Sloc (N), \"\")),\n+               Static => True);\n+            return;\n+         end if;\n       end if;\n    end Eval_Call;\n \n@@ -2504,6 +2550,39 @@ package body Sem_Eval is\n \n             return;\n          end if;\n+\n+      --  Ada 202x (AI12-0075): If checking for potentially static expressions\n+      --  is enabled and we have a reference to a formal parameter of mode in,\n+      --  substitute a static value for the reference, to allow folding the\n+      --  expression. This supports checking the requirement of RM 6.8(5.3/5)\n+      --  in Analyze_Expression_Function.\n+\n+      elsif Ekind (Def_Id) = E_In_Parameter\n+        and then Checking_Potentially_Static_Expression\n+        and then Is_Static_Expression_Function (Scope (Def_Id))\n+      then\n+         if Is_Integer_Type (Etype (Def_Id)) then\n+            Fold_Uint (N, Uint_1, Static => True);\n+            return;\n+\n+         elsif Is_Real_Type (Etype (Def_Id)) then\n+            Fold_Ureal (N, Ureal_1, Static => True);\n+            return;\n+\n+         elsif Is_Enumeration_Type (Etype (Def_Id)) then\n+            Fold_Uint\n+              (N,\n+               Expr_Value (Type_Low_Bound (Base_Type (Etype (Def_Id)))),\n+               Static => True);\n+            return;\n+\n+         elsif Is_String_Type (Etype (Def_Id)) then\n+            Fold_Str\n+              (N,\n+               Strval (Make_String_Literal (Sloc (N), \"\")),\n+               Static => True);\n+            return;\n+         end if;\n       end if;\n \n       --  Fall through if the name is not static\n@@ -5934,6 +6013,21 @@ package body Sem_Eval is\n       Set_Is_Static_Expression (N, Stat);\n    end Rewrite_In_Raise_CE;\n \n+   ------------------------------------------------\n+   -- Set_Checking_Potentially_Static_Expression --\n+   ------------------------------------------------\n+\n+   procedure Set_Checking_Potentially_Static_Expression (Value : Boolean) is\n+   begin\n+      --  Verify that we're not currently checking for a potentially static\n+      --  expression unless we're disabling such checking.\n+\n+      pragma Assert\n+        (not Checking_For_Potentially_Static_Expression or else not Value);\n+\n+      Checking_For_Potentially_Static_Expression := Value;\n+   end Set_Checking_Potentially_Static_Expression;\n+\n    ---------------------\n    -- String_Type_Len --\n    ---------------------"}, {"sha": "97160ee68acb0496ab6cf77b376d4506edf14cfb", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=bbab2db3a6cb1a8e34d863982d87673536819f27", "patch": "@@ -165,6 +165,14 @@ package Sem_Eval is\n    --  In the former case, if the target type, Ttyp is constrained, then a\n    --  check is made to see if the string literal is of appropriate length.\n \n+   function Checking_Potentially_Static_Expression return Boolean;\n+   --  Returns True if the checking for potentially static expressions is\n+   --  enabled; otherwise returns False.\n+\n+   procedure Set_Checking_Potentially_Static_Expression (Value : Boolean);\n+   --  Enables checking for potentially static expressions if Value is True,\n+   --  and disables such checking if Value is False.\n+\n    type Compare_Result is (LT, LE, EQ, GT, GE, NE, Unknown);\n    subtype Compare_GE is Compare_Result range EQ .. GE;\n    subtype Compare_LE is Compare_Result range LT .. EQ;"}, {"sha": "ee3a9acd83d3cc0d9df24bd29a22ead38e3fd716", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=bbab2db3a6cb1a8e34d863982d87673536819f27", "patch": "@@ -6560,6 +6560,7 @@ package body Sem_Res is\n \n          if Same_Or_Aliased_Subprograms (Nam, Scop)\n            and then not Restriction_Active (No_Recursion)\n+           and then not Is_Static_Expression_Function (Scop)\n            and then Check_Infinite_Recursion (N)\n          then\n             --  Here we detected and flagged an infinite recursion, so we do\n@@ -6577,6 +6578,20 @@ package body Sem_Res is\n             Scope_Loop : while Scop /= Standard_Standard loop\n                if Same_Or_Aliased_Subprograms (Nam, Scop) then\n \n+                  --  Ada 202x (AI12-0075): Static expression function are\n+                  --  never allowed to make a recursive call, as specified\n+                  --  by 6.8(5.4/5).\n+\n+                  if Is_Static_Expression_Function (Scop) then\n+                     Error_Msg_N\n+                       (\"recursive call not allowed in static expression \"\n+                          & \"function\", N);\n+\n+                     Set_Error_Posted (Scop);\n+\n+                     exit Scope_Loop;\n+                  end if;\n+\n                   --  Although in general case, recursion is not statically\n                   --  checkable, the case of calling an immediately containing\n                   --  subprogram is easy to catch.\n@@ -6714,6 +6729,11 @@ package body Sem_Res is\n       --  is already present. It may not be available if e.g. the subprogram is\n       --  declared in a child instance.\n \n+      --  g) If the subprogram is a static expression function and the call is\n+      --  a static call (the actuals are all static expressions), then we never\n+      --  want to create a transient scope (this could occur in the case of a\n+      --  static string-returning call).\n+\n       if Is_Inlined (Nam)\n         and then Has_Pragma_Inline (Nam)\n         and then Nkind (Unit_Declaration_Node (Nam)) = N_Subprogram_Declaration\n@@ -6725,6 +6745,7 @@ package body Sem_Res is\n         or else Is_Build_In_Place_Function (Nam)\n         or else Is_Intrinsic_Subprogram (Nam)\n         or else Is_Inlinable_Expression_Function (Nam)\n+        or else Is_Static_Expression_Function_Call (N)\n       then\n          null;\n \n@@ -6989,12 +7010,26 @@ package body Sem_Res is\n \n       Warn_On_Overlapping_Actuals (Nam, N);\n \n+      --  Ada 202x (AI12-0075): If the call is a static call to a static\n+      --  expression function, then we want to \"inline\" the call, replacing\n+      --  it with the folded static result. This is not done if the checking\n+      --  for a potentially static expression is enabled or if an error has\n+      --  been posted on the call (which may be due to the check for recursive\n+      --  calls, in which case we don't want to fall into infinite recursion\n+      --  when doing the inlining).\n+\n+      if not Checking_Potentially_Static_Expression\n+        and then Is_Static_Expression_Function_Call (N)\n+        and then not Error_Posted (Ultimate_Alias (Nam))\n+      then\n+         Inline_Static_Expression_Function_Call (N, Ultimate_Alias (Nam));\n+\n       --  In GNATprove mode, expansion is disabled, but we want to inline some\n       --  subprograms to facilitate formal verification. Indirect calls through\n       --  a subprogram type or within a generic cannot be inlined. Inlining is\n       --  performed only for calls subject to SPARK_Mode on.\n \n-      if GNATprove_Mode\n+      elsif GNATprove_Mode\n         and then SPARK_Mode = On\n         and then Is_Overloadable (Nam)\n         and then not Inside_A_Generic"}, {"sha": "5f1510785917cba9a8079483927ecbdd614a283d", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=bbab2db3a6cb1a8e34d863982d87673536819f27", "patch": "@@ -5846,7 +5846,14 @@ package body Sem_Util is\n          --  will happen when something is evaluated if it never will be\n          --  evaluated.\n \n-         if not Is_Statically_Unevaluated (N) then\n+         --  Suppress error reporting when checking that the expression of a\n+         --  static expression function is a potentially static expression,\n+         --  because we don't want additional errors being reported during the\n+         --  preanalysis of the expression (see Analyze_Expression_Function).\n+\n+         if not Is_Statically_Unevaluated (N)\n+           and then not Checking_Potentially_Static_Expression\n+         then\n             if Present (Ent) then\n                Error_Msg_NEL (Msgc (1 .. Msgl), N, Ent, Eloc);\n             else\n@@ -18442,6 +18449,73 @@ package body Sem_Util is\n           or else Nkind (N) = N_Procedure_Call_Statement;\n    end Is_Statement;\n \n+   ------------------------------------\n+   --  Is_Static_Expression_Function --\n+   ------------------------------------\n+\n+   function Is_Static_Expression_Function (Subp : Entity_Id) return Boolean is\n+   begin\n+      return Is_Expression_Function (Subp)\n+        and then Has_Aspect (Subp, Aspect_Static)\n+        and then\n+          (No (Find_Value_Of_Aspect (Subp, Aspect_Static))\n+            or else Is_True (Static_Boolean\n+                               (Find_Value_Of_Aspect (Subp, Aspect_Static))));\n+   end Is_Static_Expression_Function;\n+\n+   -----------------------------------------\n+   --  Is_Static_Expression_Function_Call --\n+   -----------------------------------------\n+\n+   function Is_Static_Expression_Function_Call (Call : Node_Id) return Boolean\n+   is\n+\n+      function Has_All_Static_Actuals (Call : Node_Id) return Boolean;\n+      --  Return whether all actual parameters of Call are static expressions\n+\n+      function Has_All_Static_Actuals (Call : Node_Id) return Boolean is\n+         Actual        : Node_Id := First_Actual (Call);\n+         String_Result : constant Boolean :=\n+                           Is_String_Type (Etype (Entity (Name (Call))));\n+\n+      begin\n+         while Present (Actual) loop\n+            if not Is_Static_Expression (Actual) then\n+\n+               --  ??? In the string-returning case we want to avoid a call\n+               --  being made to Establish_Transient_Scope in Resolve_Call,\n+               --  but at the point where that's tested for (which now includes\n+               --  a call to test Is_Static_Expression_Function_Call), the\n+               --  actuals of the call haven't been resolved, so expressions\n+               --  of the actuals may not have been marked Is_Static_Expression\n+               --  yet, so we force them to be resolved here, so we can tell if\n+               --  they're static. Calling Resolve here is admittedly a kludge,\n+               --  and we limit this call to string-returning cases. ???\n+\n+               if String_Result then\n+                  Resolve (Actual);\n+               end if;\n+\n+               --  Test flag again in case it's now True due to above Resolve\n+\n+               if not Is_Static_Expression (Actual) then\n+                  return False;\n+               end if;\n+            end if;\n+\n+            Next_Actual (Actual);\n+         end loop;\n+\n+         return True;\n+      end Has_All_Static_Actuals;\n+\n+   begin\n+      return Nkind (Call) = N_Function_Call\n+        and then Is_Entity_Name (Name (Call))\n+        and then Is_Static_Expression_Function (Entity (Name (Call)))\n+        and then Has_All_Static_Actuals (Call);\n+   end Is_Static_Expression_Function_Call;\n+\n    ----------------------------------------\n    --  Is_Subcomponent_Of_Atomic_Object  --\n    ----------------------------------------"}, {"sha": "caefa05aca01d326a8dfd974bd64276f455b19d6", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbab2db3a6cb1a8e34d863982d87673536819f27/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=bbab2db3a6cb1a8e34d863982d87673536819f27", "patch": "@@ -2070,6 +2070,15 @@ package Sem_Util is\n    --  the N_Statement_Other_Than_Procedure_Call subtype from Sinfo).\n    --  Note that a label is *not* a statement, and will return False.\n \n+   function Is_Static_Expression_Function (Subp : Entity_Id) return Boolean;\n+   --  Determine whether subprogram Subp denotes a static expression function,\n+   --  which is an expression function with the aspect Static with value True.\n+\n+   function Is_Static_Expression_Function_Call (Call : Node_Id) return Boolean;\n+   --  Determine whether Call is a static call to a static expression function,\n+   --  meaning that the name of the call denotes a static expression function\n+   --  and all of the call's actual parameters are given by static expressions.\n+\n    function Is_Subcomponent_Of_Atomic_Object (N : Node_Id) return Boolean;\n    --  Determine whether arbitrary node N denotes a reference to a subcomponent\n    --  of an atomic object as per RM C.6(7)."}]}