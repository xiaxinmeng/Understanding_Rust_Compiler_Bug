{"sha": "a1fdc16da341187846dd0577e96ee00df5f28608", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFmZGMxNmRhMzQxMTg3ODQ2ZGQwNTc3ZTk2ZWUwMGRmNWYyODYwOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-13T10:41:13Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-13T15:04:48Z"}, "message": "Determine access types in ipa-icf-gimple.c\n\nThis patch adds logic to determine access type (normal or memory) for every\noperand.  This makes it possible to compare memory accesses more carefully\nwhich will be implemented in a followup patch.\n\n\t* ipa-icf-gimple.c: Include gimple-walk.h.\n\t(func_checker::compare_ssa_name): Update call of compare_operand.\n\t(func_checker::hash_operand): Fix comment and add variant taking\n\toperand_access_type parameter.\n\t(func_checker::compare_operand): Add operand_access_type parameter.\n\t(func_checker::compare_asm_inputs_outputs): Add\n\toperand_access_type_map parameter; update use of\n\tfunc_checker::compare_operand.\n\t(func_checker::compare_gimple_call): Update use of\n\tfunc_checker::compare_operand.\n\t(func_checker::compare_gimple_assign): Likewise.\n\t(func_checker::compare_gimple_cond): Likewise.\n\t(func_checker::compare_gimple_switch): Likewise.\n\t(func_checker::compare_gimple_return): Likewise.\n\t(func_checker::compare_gimple_goto): Likewise.\n\t(func_checker::compare_gimple_asm): Likewise.\n\t(visit_load_store): New static functio.\n\t(func_checker::classify_operands): New member function.\n\t(func_checker::get_operand_access_type): New member function.\n\t* ipa-icf-gimple.h (func_checker::operand_access_type): New enum\n\t(func_checker::operand_access_type_map): New typedef.\n\t(func_checker::compare_operand): Update prototype.\n\t(func_checker::compare_asm_inputs_outputs): Likewise.\n\t(func_checker::cleassify_operands): Declare.\n\t(func_checker::get_operand_access_type): Declare.\n\t(func_checker::hash_operand): New variant with operand_access_type.\n\t* ipa-icf.c (sem_function::hash_stmt): Update uses of hash_operand.\n\t(sem_function::compare_phi_node): Update use of compare_operand.", "tree": {"sha": "78db15ad478a4d755ad7282e1f824d1c32f9e95f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78db15ad478a4d755ad7282e1f824d1c32f9e95f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1fdc16da341187846dd0577e96ee00df5f28608", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1fdc16da341187846dd0577e96ee00df5f28608", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1fdc16da341187846dd0577e96ee00df5f28608", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1fdc16da341187846dd0577e96ee00df5f28608/comments", "author": null, "committer": null, "parents": [{"sha": "156edf21fab7dd5891c72db7ec58b38ef7d52bfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/156edf21fab7dd5891c72db7ec58b38ef7d52bfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/156edf21fab7dd5891c72db7ec58b38ef7d52bfa"}], "stats": {"total": 166, "additions": 123, "deletions": 43}, "files": [{"sha": "0276b205951af676cbab4304f7e7589bb4e445fb", "filename": "gcc/ipa-icf-gimple.c", "status": "modified", "additions": 88, "deletions": 21, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1fdc16da341187846dd0577e96ee00df5f28608/gcc%2Fipa-icf-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1fdc16da341187846dd0577e96ee00df5f28608/gcc%2Fipa-icf-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.c?ref=a1fdc16da341187846dd0577e96ee00df5f28608", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"cfgloop.h\"\n #include \"attribs.h\"\n+#include \"gimple-walk.h\"\n \n #include \"ipa-icf-gimple.h\"\n \n@@ -109,7 +110,7 @@ func_checker::compare_ssa_name (const_tree t1, const_tree t2)\n       tree b1 = SSA_NAME_VAR (t1);\n       tree b2 = SSA_NAME_VAR (t2);\n \n-      return compare_operand (b1, b2);\n+      return compare_operand (b1, b2, OP_NORMAL);\n     }\n \n   return true;\n@@ -212,8 +213,8 @@ func_checker::compatible_types_p (tree t1, tree t2)\n   return true;\n }\n \n-/* Function compare for equality given trees T1 and T2 which\n-   can be either a constant or a declaration type.  */\n+/* Add hash of ARG to HSTATE. FLAGS have same meaning\n+   as for operand_equal_p.  Works only if operand acces type is OP_NORMAL.  */\n \n void\n func_checker::hash_operand (const_tree arg, inchash::hash &hstate,\n@@ -246,6 +247,16 @@ func_checker::hash_operand (const_tree arg, inchash::hash &hstate,\n   return operand_compare::hash_operand (arg, hstate, flags);\n }\n \n+/* Add hash of ARG accesses according to ACCESS to HSTATE.\n+   FLAGS have same meaning as for operand_equal_p.  */\n+\n+void\n+func_checker::hash_operand (const_tree arg, inchash::hash &hstate,\n+\t\t\t    unsigned int flags, operand_access_type)\n+{\n+  return hash_operand (arg, hstate, flags);\n+}\n+\n bool\n func_checker::operand_equal_p (const_tree t1, const_tree t2,\n \t\t\t       unsigned int flags)\n@@ -291,24 +302,35 @@ func_checker::operand_equal_p (const_tree t1, const_tree t2,\n   return operand_compare::operand_equal_p (t1, t2, flags);\n }\n \n-/* Function responsible for comparison of various operands T1 and T2.\n+/* Function responsible for comparison of various operands T1 and T2\n+   which are accessed as ACCESS.\n    If these components, from functions FUNC1 and FUNC2, are equal, true\n    is returned.  */\n \n bool\n-func_checker::compare_operand (tree t1, tree t2)\n+func_checker::compare_operand (tree t1, tree t2, operand_access_type access)\n {\n   if (!t1 && !t2)\n     return true;\n   else if (!t1 || !t2)\n     return false;\n   if (operand_equal_p (t1, t2, OEP_MATCH_SIDE_EFFECTS))\n     return true;\n-  return return_false_with_msg (\"operand_equal_p failed\");\n+  switch (access)\n+    {\n+    case OP_MEMORY:\n+      return return_false_with_msg\n+\t\t (\"operand_equal_p failed (access == memory)\");\n+    case OP_NORMAL:\n+      return return_false_with_msg\n+\t\t (\"operand_equal_p failed (access == normal)\");\n+    }\n+  gcc_unreachable ();\n }\n \n bool\n-func_checker::compare_asm_inputs_outputs (tree t1, tree t2)\n+func_checker::compare_asm_inputs_outputs (tree t1, tree t2,\n+\t\t\t\t\t  operand_access_type_map *map)\n {\n   gcc_assert (TREE_CODE (t1) == TREE_LIST);\n   gcc_assert (TREE_CODE (t2) == TREE_LIST);\n@@ -318,7 +340,8 @@ func_checker::compare_asm_inputs_outputs (tree t1, tree t2)\n       if (!t2)\n \treturn false;\n \n-      if (!compare_operand (TREE_VALUE (t1), TREE_VALUE (t2)))\n+      if (!compare_operand (TREE_VALUE (t1), TREE_VALUE (t2),\n+\t\t\t    get_operand_access_type (map, t1)))\n \treturn return_false ();\n \n       tree p1 = TREE_PURPOSE (t1);\n@@ -545,9 +568,12 @@ func_checker::compare_gimple_call (gcall *s1, gcall *s2)\n   if (gimple_call_num_args (s1) != gimple_call_num_args (s2))\n     return false;\n \n+  operand_access_type_map map (5);\n+  classify_operands (s1, &map);\n+\n   t1 = gimple_call_fn (s1);\n   t2 = gimple_call_fn (s2);\n-  if (!compare_operand (t1, t2))\n+  if (!compare_operand (t1, t2, get_operand_access_type (&map, t1)))\n     return return_false ();\n \n   /* Compare flags.  */\n@@ -579,7 +605,8 @@ func_checker::compare_gimple_call (gcall *s1, gcall *s2)\n   tree chain2 = gimple_call_chain (s2);\n   if ((chain1 && !chain2)\n       || (!chain1 && chain2)\n-      || !compare_operand (chain1, chain2))\n+      || !compare_operand (chain1, chain2,\n+\t\t\t   get_operand_access_type (&map, chain1)))\n     return return_false_with_msg (\"static call chains are different\");\n \n   /* Checking of argument.  */\n@@ -588,15 +615,15 @@ func_checker::compare_gimple_call (gcall *s1, gcall *s2)\n       t1 = gimple_call_arg (s1, i);\n       t2 = gimple_call_arg (s2, i);\n \n-      if (!compare_operand (t1, t2))\n+      if (!compare_operand (t1, t2, get_operand_access_type (&map, t1)))\n \treturn return_false_with_msg (\"GIMPLE call operands are different\");\n     }\n \n   /* Return value checking.  */\n   t1 = gimple_get_lhs (s1);\n   t2 = gimple_get_lhs (s2);\n \n-  return compare_operand (t1, t2);\n+  return compare_operand (t1, t2, get_operand_access_type (&map, t1));\n }\n \n \n@@ -616,6 +643,9 @@ func_checker::compare_gimple_assign (gimple *s1, gimple *s2)\n   if (code1 != code2)\n     return false;\n \n+  operand_access_type_map map (5);\n+  classify_operands (s1, &map);\n+\n   for (i = 0; i < gimple_num_ops (s1); i++)\n     {\n       arg1 = gimple_op (s1, i);\n@@ -628,7 +658,7 @@ func_checker::compare_gimple_assign (gimple *s1, gimple *s2)\n \t    return return_false_with_msg (\"GIMPLE NOP LHS type mismatch\");\n \t}\n \n-      if (!compare_operand (arg1, arg2))\n+      if (!compare_operand (arg1, arg2, get_operand_access_type (&map, arg1)))\n \treturn return_false_with_msg (\"GIMPLE assignment operands \"\n \t\t\t\t      \"are different\");\n     }\n@@ -655,13 +685,13 @@ func_checker::compare_gimple_cond (gimple *s1, gimple *s2)\n   t1 = gimple_cond_lhs (s1);\n   t2 = gimple_cond_lhs (s2);\n \n-  if (!compare_operand (t1, t2))\n+  if (!compare_operand (t1, t2, OP_NORMAL))\n     return false;\n \n   t1 = gimple_cond_rhs (s1);\n   t2 = gimple_cond_rhs (s2);\n \n-  return compare_operand (t1, t2);\n+  return compare_operand (t1, t2, OP_NORMAL);\n }\n \n /* Verifies for given GIMPLE_LABEL stmts S1 and S2 that\n@@ -700,7 +730,7 @@ func_checker::compare_gimple_switch (const gswitch *g1, const gswitch *g2)\n   tree t1 = gimple_switch_index (g1);\n   tree t2 = gimple_switch_index (g2);\n \n-  if (!compare_operand (t1, t2))\n+  if (!compare_operand (t1, t2, OP_NORMAL))\n     return false;\n \n   for (i = 0; i < lsize1; i++)\n@@ -727,7 +757,7 @@ func_checker::compare_gimple_switch (const gswitch *g1, const gswitch *g2)\n \t  label1 = CASE_LABEL (label1);\n \t  label2 = CASE_LABEL (label2);\n \n-\t  if (!compare_operand (label1, label2))\n+\t  if (!compare_operand (label1, label2, OP_NORMAL))\n \t    return return_false_with_msg (\"switch label_exprs are different\");\n \t}\n       else if (!tree_int_cst_equal (label1, label2))\n@@ -752,7 +782,10 @@ func_checker::compare_gimple_return (const greturn *g1, const greturn *g2)\n   if (t1 == NULL && t2 == NULL)\n     return true;\n   else\n-    return compare_operand (t1, t2);\n+    {\n+      operand_access_type_map map (3);\n+      return compare_operand (t1, t2, get_operand_access_type (&map, t1));\n+    }\n }\n \n /* Verifies for given GIMPLEs S1 and S2 that\n@@ -769,7 +802,7 @@ func_checker::compare_gimple_goto (gimple *g1, gimple *g2)\n   if (TREE_CODE (dest1) != TREE_CODE (dest2) || TREE_CODE (dest1) != SSA_NAME)\n     return false;\n \n-  return compare_operand (dest1, dest2);\n+  return compare_operand (dest1, dest2, OP_NORMAL);\n }\n \n /* Verifies for given GIMPLE_RESX stmts S1 and S2 that\n@@ -813,12 +846,15 @@ func_checker::compare_gimple_asm (const gasm *g1, const gasm *g2)\n   if (strcmp (gimple_asm_string (g1), gimple_asm_string (g2)) != 0)\n     return return_false_with_msg (\"ASM strings are different\");\n \n+  operand_access_type_map map (5);\n+  classify_operands (g1, &map);\n+\n   for (unsigned i = 0; i < gimple_asm_ninputs (g1); i++)\n     {\n       tree input1 = gimple_asm_input_op (g1, i);\n       tree input2 = gimple_asm_input_op (g2, i);\n \n-      if (!compare_asm_inputs_outputs (input1, input2))\n+      if (!compare_asm_inputs_outputs (input1, input2, &map))\n \treturn return_false_with_msg (\"ASM input is different\");\n     }\n \n@@ -827,7 +863,7 @@ func_checker::compare_gimple_asm (const gasm *g1, const gasm *g2)\n       tree output1 = gimple_asm_output_op (g1, i);\n       tree output2 = gimple_asm_output_op (g2, i);\n \n-      if (!compare_asm_inputs_outputs (output1, output2))\n+      if (!compare_asm_inputs_outputs (output1, output2, &map))\n \treturn return_false_with_msg (\"ASM output is different\");\n     }\n \n@@ -844,4 +880,35 @@ func_checker::compare_gimple_asm (const gasm *g1, const gasm *g2)\n   return true;\n }\n \n+/* Helper for func_checker::classify_operands.  Record that T is a load.  */\n+\n+static bool\n+visit_load_store (gimple *, tree, tree t, void *data)\n+{\n+  func_checker::operand_access_type_map *map =\n+    (func_checker::operand_access_type_map *) data;\n+  map->add (t);\n+  return false;\n+}\n+\n+/* Compute hash map determining access types of operands.  */\n+\n+void\n+func_checker::classify_operands (const gimple *stmt,\n+\t\t\t\t operand_access_type_map *map)\n+{\n+  walk_stmt_load_store_ops (const_cast <gimple *> (stmt),\n+\t\t\t    (void *)map, visit_load_store, visit_load_store);\n+}\n+\n+/* Return access type of a given operand.  */\n+\n+func_checker::operand_access_type\n+func_checker::get_operand_access_type (operand_access_type_map *map, tree t)\n+{\n+  if (map->contains (t))\n+    return OP_MEMORY;\n+  return OP_NORMAL;\n+}\n+\n } // ipa_icf_gimple namespace"}, {"sha": "84a0b9deebdcaddb6f941f7b23eaa0fedc2eec7b", "filename": "gcc/ipa-icf-gimple.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1fdc16da341187846dd0577e96ee00df5f28608/gcc%2Fipa-icf-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1fdc16da341187846dd0577e96ee00df5f28608/gcc%2Fipa-icf-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.h?ref=a1fdc16da341187846dd0577e96ee00df5f28608", "patch": "@@ -200,14 +200,19 @@ class func_checker : operand_compare\n   /* Verification function for declaration trees T1 and T2.  */\n   bool compare_decl (const_tree t1, const_tree t2);\n \n+  /* Compute hash map MAP that determines loads and stores of STMT.  */\n+  enum operand_access_type {OP_MEMORY, OP_NORMAL};\n+  typedef hash_set<tree> operand_access_type_map;\n+\n   /* Function responsible for comparison of various operands T1 and T2.\n      If these components, from functions FUNC1 and FUNC2, are equal, true\n      is returned.  */\n-  bool compare_operand (tree t1, tree t2);\n+  bool compare_operand (tree t1, tree t2, operand_access_type type);\n \n   /* Compares GIMPLE ASM inputs (or outputs) where we iterate tree chain\n      and compare both TREE_PURPOSEs and TREE_VALUEs.  */\n-  bool compare_asm_inputs_outputs (tree t1, tree t2);\n+  bool compare_asm_inputs_outputs (tree t1, tree t2,\n+\t\t\t\t   operand_access_type_map *map);\n \n   /* Verifies that trees T1 and T2, representing function declarations\n      are equivalent from perspective of ICF.  */\n@@ -230,7 +235,13 @@ class func_checker : operand_compare\n      first parameter of a function.  */\n   static bool compatible_types_p (tree t1, tree t2);\n \n+  /* Compute hash map determining access types of operands.  */\n+  static void classify_operands (const gimple *stmt,\n+\t\t\t\t operand_access_type_map *map);\n \n+  /* Return access type of a given operand.  */\n+  static operand_access_type get_operand_access_type\n+\t\t (operand_access_type_map *map, tree);\n private:\n   /* Vector mapping source SSA names to target ones.  */\n   vec <int> m_source_ssa_names;\n@@ -272,6 +283,8 @@ class func_checker : operand_compare\n   /* Generate a hash value for an expression.  This can be used iteratively\n      by passing a previous result as the HSTATE argument.  */\n   virtual void hash_operand (const_tree, inchash::hash &, unsigned flags);\n+  void hash_operand (const_tree, inchash::hash &, unsigned flags,\n+\t\t     operand_access_type access);\n };\n \n } // ipa_icf_gimple namespace"}, {"sha": "83f9786b4b2a46d3cd3034b65cf07c1ea361ee28", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1fdc16da341187846dd0577e96ee00df5f28608/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1fdc16da341187846dd0577e96ee00df5f28608/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=a1fdc16da341187846dd0577e96ee00df5f28608", "patch": "@@ -1419,33 +1419,32 @@ sem_function::hash_stmt (gimple *stmt, inchash::hash &hstate)\n     {\n     case GIMPLE_SWITCH:\n       m_checker->hash_operand (gimple_switch_index (as_a <gswitch *> (stmt)),\n-\t\t\t     hstate, 0);\n+\t\t\t       hstate, 0, func_checker::OP_NORMAL);\n       break;\n     case GIMPLE_ASSIGN:\n       hstate.add_int (gimple_assign_rhs_code (stmt));\n-      if (commutative_tree_code (gimple_assign_rhs_code (stmt))\n-\t  || commutative_ternary_tree_code (gimple_assign_rhs_code (stmt)))\n-\t{\n-\t  m_checker->hash_operand (gimple_assign_rhs1 (stmt), hstate, 0);\n-\t  m_checker->hash_operand (gimple_assign_rhs2 (stmt), hstate, 0);\n-\t  if (commutative_ternary_tree_code (gimple_assign_rhs_code (stmt)))\n-\t    m_checker->hash_operand (gimple_assign_rhs3 (stmt), hstate, 0);\n-\t  m_checker->hash_operand (gimple_assign_lhs (stmt), hstate, 0);\n-\t}\n       /* fall through */\n     case GIMPLE_CALL:\n     case GIMPLE_ASM:\n     case GIMPLE_COND:\n     case GIMPLE_GOTO:\n     case GIMPLE_RETURN:\n-      /* All these statements are equivalent if their operands are.  */\n-      for (unsigned i = 0; i < gimple_num_ops (stmt); ++i)\n-\tm_checker->hash_operand (gimple_op (stmt, i), hstate, 0);\n-      /* Consider nocf_check attribute in hash as it affects code\n- \t generation.  */\n-      if (code == GIMPLE_CALL\n-\t  && flag_cf_protection & CF_BRANCH)\n-\thstate.add_flag (gimple_call_nocf_check_p (as_a <gcall *> (stmt)));\n+      {\n+\tfunc_checker::operand_access_type_map map (5);\n+\tfunc_checker::classify_operands (stmt, &map);\n+\n+\t/* All these statements are equivalent if their operands are.  */\n+\tfor (unsigned i = 0; i < gimple_num_ops (stmt); ++i)\n+\t  m_checker->hash_operand (gimple_op (stmt, i), hstate, 0,\n+\t\t\t\t   func_checker::get_operand_access_type\n+\t\t\t\t\t(&map, gimple_op (stmt, i)));\n+\t/* Consider nocf_check attribute in hash as it affects code\n+\t   generation.  */\n+\tif (code == GIMPLE_CALL\n+\t    && flag_cf_protection & CF_BRANCH)\n+\t  hstate.add_flag (gimple_call_nocf_check_p (as_a <gcall *> (stmt)));\n+      }\n+      break;\n     default:\n       break;\n     }\n@@ -1534,7 +1533,8 @@ sem_function::compare_phi_node (basic_block bb1, basic_block bb2)\n       tree phi_result1 = gimple_phi_result (phi1);\n       tree phi_result2 = gimple_phi_result (phi2);\n \n-      if (!m_checker->compare_operand (phi_result1, phi_result2))\n+      if (!m_checker->compare_operand (phi_result1, phi_result2,\n+\t\t\t\t       func_checker::OP_NORMAL))\n \treturn return_false_with_msg (\"PHI results are different\");\n \n       size1 = gimple_phi_num_args (phi1);\n@@ -1548,7 +1548,7 @@ sem_function::compare_phi_node (basic_block bb1, basic_block bb2)\n \t  t1 = gimple_phi_arg (phi1, i)->def;\n \t  t2 = gimple_phi_arg (phi2, i)->def;\n \n-\t  if (!m_checker->compare_operand (t1, t2))\n+\t  if (!m_checker->compare_operand (t1, t2, func_checker::OP_NORMAL))\n \t    return return_false ();\n \n \t  e1 = gimple_phi_arg_edge (phi1, i);"}]}