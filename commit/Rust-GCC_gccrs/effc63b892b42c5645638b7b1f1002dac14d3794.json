{"sha": "effc63b892b42c5645638b7b1f1002dac14d3794", "node_id": "C_kwDOANBUbNoAKGVmZmM2M2I4OTJiNDJjNTY0NTYzOGI3YjFmMTAwMmRhYzE0ZDM3OTQ", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-05-12T10:05:31Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-05-12T10:05:31Z"}, "message": "optional: Allow the creation of Optional<T&>\n\nSadly, this requires specializing the class to keep the underlying pointer of\nthe reference.", "tree": {"sha": "312ba00e8c003c5cae34f0c54bbf72e7129176dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/312ba00e8c003c5cae34f0c54bbf72e7129176dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/effc63b892b42c5645638b7b1f1002dac14d3794", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/effc63b892b42c5645638b7b1f1002dac14d3794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/effc63b892b42c5645638b7b1f1002dac14d3794", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/effc63b892b42c5645638b7b1f1002dac14d3794/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4434b511a4e650e95c7a1de6810d8748c5d8a70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4434b511a4e650e95c7a1de6810d8748c5d8a70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4434b511a4e650e95c7a1de6810d8748c5d8a70"}], "stats": {"total": 245, "additions": 193, "deletions": 52}, "files": [{"sha": "3f911ca8e172e7d0b6b4b3a13f54a145f4b40d37", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/effc63b892b42c5645638b7b1f1002dac14d3794/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/effc63b892b42c5645638b7b1f1002dac14d3794/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=effc63b892b42c5645638b7b1f1002dac14d3794", "patch": "@@ -120,6 +120,7 @@ GRS_OBJS = \\\n     rust/rust-compile-pattern.o \\\n     rust/rust-compile-fnparam.o \\\n     rust/rust-base62.o \\\n+    rust/rust-optional-test.o \\\n     rust/rust-compile-item.o \\\n     rust/rust-compile-implitem.o \\\n     rust/rust-compile-expr.o \\"}, {"sha": "9045ac33b0d28b38d4c6508003ca92fc938fc064", "filename": "gcc/rust/util/rust-optional-test.cc", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/effc63b892b42c5645638b7b1f1002dac14d3794/gcc%2Frust%2Futil%2Frust-optional-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/effc63b892b42c5645638b7b1f1002dac14d3794/gcc%2Frust%2Futil%2Frust-optional-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-optional-test.cc?ref=effc63b892b42c5645638b7b1f1002dac14d3794", "patch": "@@ -0,0 +1,104 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-optional.h\"\n+\n+#include \"config.h\"\n+#include \"selftest.h\"\n+\n+static void\n+rust_optional_create ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+\n+  ASSERT_TRUE (opt.is_some ());\n+  ASSERT_EQ (opt.get (), 15);\n+\n+  Rust::Optional<int> const_opt = Rust::Optional<int>::some (15);\n+  const int &value = const_opt.get ();\n+\n+  ASSERT_EQ (value, 15);\n+}\n+\n+static void\n+rust_optional_operators ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+\n+  // as bool\n+  ASSERT_TRUE (opt);\n+\n+  // deref\n+  ASSERT_EQ (*opt, 15);\n+\n+  class Methodable\n+  {\n+  public:\n+    int method () { return 15; }\n+  };\n+\n+  auto m_opt = Rust::Optional<Methodable>::some (Methodable ());\n+  ASSERT_EQ (m_opt->method (), 15);\n+}\n+\n+static void\n+rust_optional_take ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+  auto value = opt.take ();\n+\n+  ASSERT_EQ (value, 15);\n+  ASSERT_TRUE (opt.is_none ());\n+}\n+\n+static void\n+rust_optional_map ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+  auto twice = opt.map<int> ([] (int value) { return value * 2; });\n+\n+  ASSERT_FALSE (opt);\n+  ASSERT_TRUE (twice);\n+  ASSERT_EQ (*twice, 30);\n+}\n+\n+static void\n+rust_optional_reference ()\n+{\n+  auto value = std::vector<std::string> ();\n+  value.emplace_back (\"rust\");\n+  value.emplace_back (\"+\");\n+  value.emplace_back (\"gcc\");\n+  value.emplace_back (\"=\");\n+  value.emplace_back (\"<3\");\n+\n+  auto opt = Rust::Optional<std::vector<std::string> &>::some (value);\n+\n+  ASSERT_EQ (opt->at (0), \"rust\");\n+  ASSERT_EQ (opt->at (2), \"gcc\");\n+}\n+\n+void\n+rust_optional_test ()\n+{\n+  rust_optional_create ();\n+  rust_optional_operators ();\n+  rust_optional_take ();\n+  rust_optional_map ();\n+  rust_optional_reference ();\n+}"}, {"sha": "5a39893c5d8ba9d84b61cdcf8f452c0008143e4d", "filename": "gcc/rust/util/rust-optional.h", "status": "modified", "additions": 88, "deletions": 52, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/effc63b892b42c5645638b7b1f1002dac14d3794/gcc%2Frust%2Futil%2Frust-optional.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/effc63b892b42c5645638b7b1f1002dac14d3794/gcc%2Frust%2Futil%2Frust-optional.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-optional.h?ref=effc63b892b42c5645638b7b1f1002dac14d3794", "patch": "@@ -167,74 +167,110 @@ template <typename T> class Optional\n   }\n };\n \n-} // namespace Rust\n+template <typename T> class Optional<T &>\n+{\n+private:\n+  struct Empty\n+  {\n+  };\n \n-#ifdef CHECKING_P\n+  enum Kind\n+  {\n+    Some,\n+    None\n+  } kind;\n \n-static void\n-rust_optional_create ()\n-{\n-  auto opt = Rust::Optional<int>::some (15);\n+  union Content\n+  {\n+    Empty empty;\n+    T *value;\n \n-  ASSERT_TRUE (opt.is_some ());\n-  ASSERT_EQ (opt.get (), 15);\n+    Content () = default;\n+  } content;\n \n-  Rust::Optional<int> const_opt = Rust::Optional<int>::some (15);\n-  const int &value = const_opt.get ();\n+  Optional<T &> (Kind kind, Content content) : kind (kind), content (content) {}\n \n-  ASSERT_EQ (value, 15);\n-}\n+public:\n+  Optional (const Optional &other) = default;\n+  Optional (Optional &&other) = default;\n \n-static void\n-rust_optional_operators ()\n-{\n-  auto opt = Rust::Optional<int>::some (15);\n+  static Optional<T &> some (T &value)\n+  {\n+    Content content;\n+    content.value = &value;\n+\n+    return Optional (Kind::Some, content);\n+  }\n+\n+  static Optional<T &> none ()\n+  {\n+    Content content;\n+    content.empty = Empty ();\n+\n+    return Optional (Kind::None, content);\n+  }\n+\n+  bool is_some () const { return kind == Kind::Some; }\n+  bool is_none () const { return !is_some (); }\n+\n+  // FIXME: Can we factor this in a single class?\n+\n+  /**\n+   * Enable boolean-like comparisons.\n+   */\n+  operator bool () { return is_some (); }\n \n-  // as bool\n-  ASSERT_TRUE (opt);\n+  /**\n+   * Enables dereferencing to access the contained value\n+   */\n+  T &operator* () { return get (); }\n+  const T &operator* () const { return get (); }\n+  T *operator-> () { return &get (); }\n+  const T *operator-> () const { return &get (); }\n \n-  // deref\n-  ASSERT_EQ (*opt, 15);\n+  const T &get () const\n+  {\n+    rust_assert (is_some ());\n+\n+    return *content.value;\n+  }\n \n-  class Methodable\n+  T &get ()\n   {\n-  public:\n-    int method () { return 15; }\n-  };\n+    rust_assert (is_some ());\n \n-  auto m_opt = Rust::Optional<Methodable>::some (Methodable ());\n-  ASSERT_EQ (m_opt->method (), 15);\n-}\n+    return *content.value;\n+  }\n \n-static void\n-rust_optional_take ()\n-{\n-  auto opt = Rust::Optional<int>::some (15);\n-  auto value = opt.take ();\n+  T &take ()\n+  {\n+    rust_assert (is_some ());\n \n-  ASSERT_EQ (value, 15);\n-  ASSERT_TRUE (opt.is_none ());\n-}\n+    auto to_return = std::move (content.value);\n \n-static void\n-rust_optional_map ()\n-{\n-  auto opt = Rust::Optional<int>::some (15);\n-  auto twice = opt.map<int> ([] (int value) { return value * 2; });\n+    content.empty = Empty ();\n+    kind = Kind::None;\n+\n+    return *to_return;\n+  }\n \n-  ASSERT_FALSE (opt);\n-  ASSERT_TRUE (twice);\n-  ASSERT_EQ (*twice, 30);\n-}\n+  template <typename U> Optional<U &> map (std::function<U &(T &)> functor)\n+  {\n+    if (is_none ())\n+      return Optional::none ();\n \n-static void\n-rust_optional_test ()\n-{\n-  rust_optional_create ();\n-  rust_optional_operators ();\n-  rust_optional_take ();\n-  rust_optional_map ();\n-}\n+    auto value = functor (take ());\n+\n+    return Optional::some (value);\n+  }\n+};\n+\n+} // namespace Rust\n+\n+#ifdef CHECKING_P\n+\n+void\n+rust_optional_test ();\n \n #endif // !CHECKING_P\n "}]}