{"sha": "73ea87d76df215c101cf1a6b17bc7739c341f1dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNlYTg3ZDc2ZGYyMTVjMTAxY2YxYTZiMTdiYzc3MzljMzQxZjFkYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-02-27T13:12:17Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-02-27T13:12:17Z"}, "message": "Fix ctor vtable vcall offsets.\n\ncp:\n\tFix ctor vtable vcall offsets.\n\t* class.c (struct vtbl_init_data_s): Add rtti_binfo member.\n\t(build_rtt_vtbl_entries): Lose RTTI_BINFO parameter.\n\t(get_matching_base): Remove.\n\t(get_original_base): New function.\n\t(build_vtbl_initializer): Initialize vid.rtti_binfo.\n\tUse a virtual thunk for a ctor vtable with an index\n\t(add_vcall_offset_vtbl_entries_1): Check if binfo has lost a\n\tprimary base within a constructor vtable. Only set\n\tBV_VCALL_INDEX when not a constructor vtable. Adjust vcall offset\n\twhen primary base has been lost.\n\t* cp-tree.h (BINFO_VIRTUALS): Remove ambiguity from comment.\ntestsuite:\n\t* g++.old-deja/g++.abi/vtable3.h: Check vcall offsets too.\n\nFrom-SVN: r40090", "tree": {"sha": "e1373cb66df659978b6b794e47123159fe6b0acc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1373cb66df659978b6b794e47123159fe6b0acc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73ea87d76df215c101cf1a6b17bc7739c341f1dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73ea87d76df215c101cf1a6b17bc7739c341f1dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73ea87d76df215c101cf1a6b17bc7739c341f1dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73ea87d76df215c101cf1a6b17bc7739c341f1dc/comments", "author": null, "committer": null, "parents": [{"sha": "faa7e81482c1e4127ef3bf6d36e6e10f27f27ed4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faa7e81482c1e4127ef3bf6d36e6e10f27f27ed4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faa7e81482c1e4127ef3bf6d36e6e10f27f27ed4"}], "stats": {"total": 155, "additions": 106, "deletions": 49}, "files": [{"sha": "2d7dace49e53caa5773c408d32ae94f62bcc92af", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ea87d76df215c101cf1a6b17bc7739c341f1dc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ea87d76df215c101cf1a6b17bc7739c341f1dc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=73ea87d76df215c101cf1a6b17bc7739c341f1dc", "patch": "@@ -1,3 +1,18 @@\n+2001-02-27  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tFix ctor vtable vcall offsets.\n+\t* class.c (struct vtbl_init_data_s): Add rtti_binfo member.\n+\t(build_rtt_vtbl_entries): Lose RTTI_BINFO parameter.\n+\t(get_matching_base): Remove.\n+\t(get_original_base): New function.\n+\t(build_vtbl_initializer): Initialize vid.rtti_binfo. \n+\tUse a virtual thunk for a ctor vtable with an index\n+\t(add_vcall_offset_vtbl_entries_1): Check if binfo has lost a\n+\tprimary base within a constructor vtable. Only set\n+\tBV_VCALL_INDEX when not a constructor vtable. Adjust vcall offset\n+\twhen primary base has been lost.\n+\t* cp-tree.h (BINFO_VIRTUALS): Remove ambiguity from comment.\n+\n 2001-02-26  Jeffrey Oldham  <oldham@codesourcery.com>\n \n \t* call.c (joust): Ensure more_specialized()'s argument length"}, {"sha": "8af19c5d31ce5dfa50700a0d8c10dc2b6cc2a32a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 81, "deletions": 41, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ea87d76df215c101cf1a6b17bc7739c341f1dc/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ea87d76df215c101cf1a6b17bc7739c341f1dc/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=73ea87d76df215c101cf1a6b17bc7739c341f1dc", "patch": "@@ -66,8 +66,11 @@ typedef struct vtbl_init_data_s\n {\n   /* The base for which we're building initializers.  */\n   tree binfo;\n-  /* The binfo for the most-derived type.  */\n+  /* The type of the most-derived type.  */\n   tree derived;\n+  /* The binfo for the dynamic type. This will be TYPE_BINFO (derived),\n+     unless ctor_vtbl_p is true.  */\n+  tree rtti_binfo;\n   /* The negative-index vtable initializers built up so far.  These\n      are in order from least negative index to most negative index.  */\n   tree inits;\n@@ -182,7 +185,7 @@ static void accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree, tree));\n static tree dfs_accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree,\n \t\t\t\t\t       tree));\n static void set_vindex PARAMS ((tree, int *));\n-static void build_rtti_vtbl_entries PARAMS ((tree, tree, vtbl_init_data *));\n+static void build_rtti_vtbl_entries PARAMS ((tree, vtbl_init_data *));\n static void build_vcall_and_vbase_vtbl_entries PARAMS ((tree, \n \t\t\t\t\t\t\tvtbl_init_data *));\n static void force_canonical_binfo_r PARAMS ((tree, tree, tree, tree));\n@@ -199,7 +202,7 @@ static tree *build_vtt_inits PARAMS ((tree, tree, tree *, tree *));\n static tree dfs_build_secondary_vptr_vtt_inits PARAMS ((tree, void *));\n static tree dfs_ctor_vtable_bases_queue_p PARAMS ((tree, void *data));\n static tree dfs_fixup_binfo_vtbls PARAMS ((tree, void *));\n-static tree get_matching_base PARAMS ((tree, tree));\n+static tree get_original_base PARAMS ((tree, tree));\n static tree dfs_get_primary_binfo PARAMS ((tree, void*));\n static int record_subobject_offset PARAMS ((tree, tree, splay_tree));\n static int check_subobject_offset PARAMS ((tree, tree, splay_tree));\n@@ -6830,32 +6833,31 @@ build_vtt (t)\n   initialize_array (vtt, inits);\n }\n \n-/* The type corresponding to BINFO is a base class of T, but BINFO is\n-   in the base class hierarchy of a class derived from T.  Return the\n-   base, in T's hierarchy, that corresponds to BINFO.  */\n+/* The type corresponding to BASE_BINFO is a base of the type of BINFO, but\n+   from within some heirarchy which is inherited from the type of BINFO.\n+   Return BASE_BINFO's equivalent binfo from the hierarchy dominated by\n+   BINFO.  */\n \n static tree\n-get_matching_base (binfo, t)\n+get_original_base (base_binfo, binfo)\n+     tree base_binfo;\n      tree binfo;\n-     tree t;\n {\n   tree derived;\n-  int i;\n-\n-  if (same_type_p (BINFO_TYPE (binfo), t))\n+  int ix;\n+  \n+  if (same_type_p (BINFO_TYPE (base_binfo), BINFO_TYPE (binfo)))\n     return binfo;\n-\n-  if (TREE_VIA_VIRTUAL (binfo))\n-    return binfo_for_vbase (BINFO_TYPE (binfo), t);\n-\n-  derived = get_matching_base (BINFO_INHERITANCE_CHAIN (binfo), t);\n-  for (i = 0; i < BINFO_N_BASETYPES (derived); ++i)\n-    if (same_type_p (BINFO_TYPE (BINFO_BASETYPE (derived, i)),\n-\t\t     BINFO_TYPE (binfo)))\n-      return BINFO_BASETYPE (derived, i);\n-\n-  my_friendly_abort (20000628);\n-  return NULL_TREE;\n+  if (TREE_VIA_VIRTUAL (base_binfo))\n+    return binfo_for_vbase (BINFO_TYPE (base_binfo), BINFO_TYPE (binfo));\n+  derived = get_original_base (BINFO_INHERITANCE_CHAIN (base_binfo), binfo);\n+  \n+  for (ix = 0; ix != BINFO_N_BASETYPES (derived); ix++)\n+    if (same_type_p (BINFO_TYPE (base_binfo),\n+                     BINFO_TYPE (BINFO_BASETYPE (derived, ix))))\n+      return BINFO_BASETYPE (derived, ix);\n+  my_friendly_abort (20010223);\n+  return NULL;\n }\n \n /* Recursively build the VTT-initializer for BINFO (which is in the\n@@ -7347,14 +7349,15 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n   memset (&vid, 0, sizeof (vid));\n   vid.binfo = binfo;\n   vid.derived = t;\n+  vid.rtti_binfo = rtti_binfo;\n   vid.last_init = &vid.inits;\n   vid.primary_vtbl_p = (binfo == TYPE_BINFO (t));\n   vid.ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n   /* The first vbase or vcall offset is at index -3 in the vtable.  */\n   vid.index = ssize_int (-3);\n \n   /* Add entries to the vtable for RTTI.  */\n-  build_rtti_vtbl_entries (binfo, rtti_binfo, &vid);\n+  build_rtti_vtbl_entries (binfo, &vid);\n \n   /* Create an array for keeping track of the functions we've\n      processed.  When we see multiple functions with the same\n@@ -7384,7 +7387,8 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n       tree fn;\n       tree pfn;\n       tree init;\n-\n+      int generate_with_vtable_p = BV_GENERATE_THUNK_WITH_VTABLE_P (v);\n+      \n       /* Pull the offset for `this', and the function to call, out of\n \t the list.  */\n       delta = BV_DELTA (v);\n@@ -7394,8 +7398,17 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n \t  vcall_index = BV_VCALL_INDEX (v);\n \t  my_friendly_assert (vcall_index != NULL_TREE, 20000621);\n \t}\n+      else if (vid.ctor_vtbl_p && BV_VCALL_INDEX (v))\n+        {\n+          /* In the original, we did not need to use the vcall index, even\n+             though there was one, but in a ctor vtable things might be\n+             different (a primary virtual base might have moved). Be\n+             conservative and use a vcall adjusting thunk.  */\n+\t  vcall_index = BV_VCALL_INDEX (v);\n+          generate_with_vtable_p = 1;\n+        }\n       else\n-\tvcall_index = NULL_TREE;\n+        vcall_index = NULL_TREE;\n \n       fn = BV_FN (v);\n       my_friendly_assert (TREE_CODE (delta) == INTEGER_CST, 19990727);\n@@ -7413,7 +7426,7 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n       TREE_CONSTANT (pfn) = 1;\n       /* Enter it in the vtable.  */\n       init = build_vtable_entry (delta, vcall_index, pfn,\n-\t\t\t\t BV_GENERATE_THUNK_WITH_VTABLE_P (v));\n+\t\t\t\t generate_with_vtable_p);\n       /* And add it to the chain of initializers.  */\n       vfun_inits = tree_cons (NULL_TREE, init, vfun_inits);\n     }\n@@ -7624,6 +7637,7 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n   tree base_virtuals;\n   tree orig_virtuals;\n   tree binfo_inits;\n+  int lost_primary = 0;\n   /* If BINFO is a primary base, this is the least derived class of\n      BINFO that is not a primary base.  */\n   tree non_primary_binfo;\n@@ -7645,6 +7659,21 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n \t care about its vtable offsets.  */\n       if (TREE_VIA_VIRTUAL (non_primary_binfo))\n \t{\n+\t  if (vid->ctor_vtbl_p)\n+\t    {\n+    \t      tree probe;\n+\t  \n+\t      for (probe = vid->binfo;\n+\t           probe != non_primary_binfo;\n+\t           probe = get_primary_binfo (probe))\n+\t        {\n+                  if (BINFO_LOST_PRIMARY_P (probe))\n+                    {\n+                      lost_primary = 1;\n+                      break;\n+                    }\n+\t        }\n+            }\n \t  non_primary_binfo = vid->binfo;\n \t  break;\n \t}\n@@ -7655,6 +7684,12 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n       non_primary_binfo = b;\n     }\n \n+  if (vid->ctor_vtbl_p)\n+    /* For a ctor vtable we need the equivalent binfo within the hierarchy\n+       where rtti_binfo is the most derived type.  */\n+    non_primary_binfo = get_original_base\n+          (non_primary_binfo, TYPE_BINFO (BINFO_TYPE (vid->rtti_binfo)));\n+\n   /* Make entries for the rest of the virtuals.  */\n   for (base_virtuals = BINFO_VIRTUALS (binfo),\n \t derived_virtuals = BINFO_VIRTUALS (non_primary_binfo),\n@@ -7669,6 +7704,7 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n       tree base;\n       tree base_binfo;\n       size_t i;\n+      tree vcall_offset;\n \n       /* Find the declaration that originally caused this function to\n \t be present.  */\n@@ -7699,8 +7735,9 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n \t      || (DECL_DESTRUCTOR_P (BV_FN (derived_entry))\n \t\t  && DECL_DESTRUCTOR_P (fn)))\n \t    {\n-\t      BV_VCALL_INDEX (derived_virtuals) \n-\t\t= BV_VCALL_INDEX (derived_entry);\n+\t      if (!vid->ctor_vtbl_p)\n+  \t        BV_VCALL_INDEX (derived_virtuals) \n+\t\t  = BV_VCALL_INDEX (derived_entry);\n \t      break;\n \t    }\n \t}\n@@ -7713,12 +7750,16 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n       base_binfo = get_binfo (base, vid->derived, /*protect=*/0);\n \n       /* Compute the vcall offset.  */\n-      *vid->last_init \n-\t= (build_tree_list \n-\t   (NULL_TREE,\n-\t    fold (build1 (NOP_EXPR, vtable_entry_type,\n-\t\t\t  size_diffop (BINFO_OFFSET (base_binfo),\n-\t\t\t\t       BINFO_OFFSET (vid->vbase))))));\n+      vcall_offset = BINFO_OFFSET (vid->vbase);\n+      if (lost_primary)\n+        vcall_offset = size_binop (PLUS_EXPR, vcall_offset,\n+                                   BINFO_OFFSET (vid->binfo));\n+      vcall_offset = size_diffop (BINFO_OFFSET (base_binfo),\n+\t\t                  vcall_offset);\n+      vcall_offset = fold (build1 (NOP_EXPR, vtable_entry_type,\n+    \t\t\t           vcall_offset));\n+      \n+      *vid->last_init = build_tree_list (NULL_TREE, vcall_offset);\n       vid->last_init = &TREE_CHAIN (*vid->last_init);\n \n       /* Keep track of the vtable index where this vcall offset can be\n@@ -7738,12 +7779,11 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n \n /* Return vtbl initializers for the RTTI entries coresponding to the\n    BINFO's vtable.  The RTTI entries should indicate the object given\n-   by RTTI_BINFO.  */\n+   by VID->rtti_binfo.  */\n \n static void\n-build_rtti_vtbl_entries (binfo, rtti_binfo, vid)\n+build_rtti_vtbl_entries (binfo, vid)\n      tree binfo;\n-     tree rtti_binfo;\n      vtbl_init_data *vid;\n {\n   tree b;\n@@ -7754,7 +7794,7 @@ build_rtti_vtbl_entries (binfo, rtti_binfo, vid)\n   tree init;\n \n   basetype = BINFO_TYPE (binfo);\n-  t = BINFO_TYPE (rtti_binfo);\n+  t = BINFO_TYPE (vid->rtti_binfo);\n \n   /* For a COM object there is no RTTI entry.  */\n   if (CLASSTYPE_COM_INTERFACE (basetype))\n@@ -7772,7 +7812,7 @@ build_rtti_vtbl_entries (binfo, rtti_binfo, vid)\n       my_friendly_assert (BINFO_PRIMARY_BASE_OF (primary_base) == b, 20010127);\n       b = primary_base;\n     }\n-  offset = size_diffop (BINFO_OFFSET (rtti_binfo), BINFO_OFFSET (b));\n+  offset = size_diffop (BINFO_OFFSET (vid->rtti_binfo), BINFO_OFFSET (b));\n \n   /* The second entry is the address of the typeinfo object.  */\n   if (flag_rtti)\n@@ -7802,7 +7842,7 @@ build_rtti_vtbl_entries (binfo, rtti_binfo, vid)\n \n /* Build an entry in the virtual function table.  DELTA is the offset\n    for the `this' pointer.  VCALL_INDEX is the vtable index containing\n-   the vcall offset; zero if none.  ENTRY is the virtual function\n+   the vcall offset; NULL_TREE if none.  ENTRY is the virtual function\n    table entry itself.  It's TREE_TYPE must be VFUNC_PTR_TYPE_NODE,\n    but it may not actually be a virtual function table pointer.  (For\n    example, it might be the address of the RTTI object, under the new"}, {"sha": "7459c0610a14c27256b79811d536ffcc97f48a07", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ea87d76df215c101cf1a6b17bc7739c341f1dc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ea87d76df215c101cf1a6b17bc7739c341f1dc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=73ea87d76df215c101cf1a6b17bc7739c341f1dc", "patch": "@@ -136,7 +136,7 @@ Boston, MA 02111-1307, USA.  */\n      does not have a BV_FN; it is just an offset.\n \n      The BV_OVERRIDING_BASE is the binfo for the final overrider for\n-     this function.  (This binfo's BINFO_TYPE will always be the same\n+     this function.  (That binfo's BINFO_TYPE will always be the same\n      as the DECL_CLASS_CONTEXT for the function.)\n \n    BINFO_VTABLE"}, {"sha": "9a6eaf701a2c029c801307a7685268f13141fee9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ea87d76df215c101cf1a6b17bc7739c341f1dc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ea87d76df215c101cf1a6b17bc7739c341f1dc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=73ea87d76df215c101cf1a6b17bc7739c341f1dc", "patch": "@@ -1,3 +1,7 @@\n+2001-02-27  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.old-deja/g++.abi/vtable3.h: Check vcall offsets too.\n+\n 2001-02-26  Will Cohen  <wcohen@redhat.com>\n \n \t* gcc.c-torture/execute/ieee/20010226-1.c: New test."}, {"sha": "4327b5f5ac4655520cde17477e79b2f1b299529e", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable3.h", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ea87d76df215c101cf1a6b17bc7739c341f1dc/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ea87d76df215c101cf1a6b17bc7739c341f1dc/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3.h?ref=73ea87d76df215c101cf1a6b17bc7739c341f1dc", "patch": "@@ -7,18 +7,16 @@\n #include <typeinfo>\n #include <stdio.h>\n \n-// XXX. vcall offsets are still broken, remove this define to re-enable\n-// testing when fixed.\n-#define NO_VCALL_TEST\n-\n int fail;\n+struct A;\n \n template <typename BASE, typename DERIVED>\n int Test (DERIVED *d, int expect)\n {\n   BASE *b = static_cast <BASE *> (d);\n   void *full_b = dynamic_cast <void *> (b);\n   void *full_d = dynamic_cast <void *> (d);\n+  A *ap = static_cast <A *> (b);\n   \n   if (full_b != full_d)\n     {\n@@ -37,8 +35,8 @@ int Test (DERIVED *d, int expect)\n               typeid (BASE).name (), typeid (DERIVED).name ());\n       return 1;\n     }\n-#ifndef NO_VCALL_TEST\n-  b->Baz (static_cast <void *> (b));\n+\n+  b->Baz (static_cast <void *> (ap));\n   \n   int res = b->Foo (static_cast <void *> (d));\n   \n@@ -49,7 +47,7 @@ int Test (DERIVED *d, int expect)\n               typeid (BASE).name (), res, expect);\n       return 1;\n     }\n-#endif\n+\n   return 0;\n }\n "}]}