{"sha": "b36ba79f65f341f556662aea2d2f7c14c4fb1ec5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM2YmE3OWY2NWYzNDFmNTU2NjYyYWVhMmQyZjdjMTRjNGZiMWVjNQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "1999-02-06T04:09:55Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "1999-02-06T04:09:55Z"}, "message": "Support for ARM9\n\nSupport for ARM9\n* config/arm/arm.c (all_procs): Add arm9 and arm9tdmi.\n* config/arm/arm.h ((TARGET_CPU_arm9, TARGET_CPUD_arm9tdmi): Define.\n(TARGET_CPU_DEFAULT): Rework to support ARM9.\n(CPP_CPU_ARCH_SPEC): Likewise.\n(enum processor_type): Likewise.\n* config/arm/arm.md (attr cpu): Add arm9.\nGeneral scheduling changes\n* config/arm/arm.c (MAX_INSNS_SKIPPED): Delete.\n(max_insns_skipped): New variable.\n(arm_override_options): If generating hard floating point code for\nthe FPA, emit code for version 3.\nWhen optimizing for space, don't synthesize constants.\nReword several flags based on the requested processor and optimization\nlevel.\n(use_return_insn): New argument iscond, all callers changed.  Don't\nuse a return insn if it will be conditional and that would be\nexpensive; eg on StrongARM.\n(arm_adjust_cost): Anti- and output- dependencies normally have no\ncost.\n(load_multiple_sequence): Newer ARMs don't benefit from ldm if\nthe sequence is short.\n(final_prescan_insn): Use max_insns_skipped instead of\nMAX_INSNS_SKIPPED.  Note whether we will make a return instruction\nconditional, and aviod this if it would be expensive.\n* config/arm/arm.md (scheduling attributes and function units):\nRewrite to better describe ARM8, 9 and StrongARM.\n* config/arm/arm.md (*movhi_insn_littleend): Make op0 predicate\ns_register_operand.\n(*ifcompare_plus_move): Use arm_rhs_operand in place of\narm_rhsm_operand.  Rework constraints.\n(*if_plus_move): Likewise.\n(*ifcompare_move_plus): Likewise.\n(*if_move_plus): Likewise.\n(*ifcompre_arith_move): Likewise.\n(*if_arith_move): Likewise.\n(*ifcompare_move_arith): Likewise.\n(*if_move_arith): Likewise.\n* config/arm/xm-netbsd.h: Don't include arm/xm-arm.h.\n\nFrom-SVN: r25053", "tree": {"sha": "aee5871e6a231914d436ff68b5140b74e13c8796", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aee5871e6a231914d436ff68b5140b74e13c8796"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b36ba79f65f341f556662aea2d2f7c14c4fb1ec5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b36ba79f65f341f556662aea2d2f7c14c4fb1ec5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b36ba79f65f341f556662aea2d2f7c14c4fb1ec5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b36ba79f65f341f556662aea2d2f7c14c4fb1ec5/comments", "author": null, "committer": null, "parents": [{"sha": "6ea296f8bf495790cf5ebebaef290f2a8810eb83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ea296f8bf495790cf5ebebaef290f2a8810eb83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ea296f8bf495790cf5ebebaef290f2a8810eb83"}], "stats": {"total": 378, "additions": 256, "deletions": 122}, "files": [{"sha": "2c8d22c7e2f9119cedb7882be45bceba7e9057f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36ba79f65f341f556662aea2d2f7c14c4fb1ec5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36ba79f65f341f556662aea2d2f7c14c4fb1ec5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b36ba79f65f341f556662aea2d2f7c14c4fb1ec5", "patch": "@@ -1,3 +1,48 @@\n+Sat Feb  6 11:17:03 1999  Richard Earnshaw <rearnsha@arm.com>\n+\n+\tSupport for ARM9\n+\t* config/arm/arm.c (all_procs): Add arm9 and arm9tdmi.\n+\t* config/arm/arm.h ((TARGET_CPU_arm9, TARGET_CPUD_arm9tdmi): Define.\n+\t(TARGET_CPU_DEFAULT): Rework to support ARM9.\n+\t(CPP_CPU_ARCH_SPEC): Likewise.\n+\t(enum processor_type): Likewise.\n+\t* config/arm/arm.md (attr cpu): Add arm9.\n+\n+\tGeneral scheduling changes \n+\t* config/arm/arm.c (MAX_INSNS_SKIPPED): Delete.\n+\t(max_insns_skipped): New variable.\n+\t(arm_override_options): If generating hard floating point code for\n+\tthe FPA, emit code for version 3.\n+\tWhen optimizing for space, don't synthesize constants.\n+\tReword several flags based on the requested processor and optimization\n+\tlevel.\n+\t(use_return_insn): New argument iscond, all callers changed.  Don't\n+\tuse a return insn if it will be conditional and that would be \n+\texpensive; eg on StrongARM.\n+\t(arm_adjust_cost): Anti- and output- dependencies normally have no\n+\tcost.\n+\t(load_multiple_sequence): Newer ARMs don't benefit from ldm if\n+\tthe sequence is short.\n+\t(final_prescan_insn): Use max_insns_skipped instead of \n+\tMAX_INSNS_SKIPPED.  Note whether we will make a return instruction\n+\tconditional, and aviod this if it would be expensive.\n+\t* config/arm/arm.md (scheduling attributes and function units):\n+ \tRewrite to better describe ARM8, 9 and StrongARM.\n+\n+\t* config/arm/arm.md (*movhi_insn_littleend): Make op0 predicate \n+\ts_register_operand.\n+\t(*ifcompare_plus_move): Use arm_rhs_operand in place of \n+\tarm_rhsm_operand.  Rework constraints.\n+\t(*if_plus_move): Likewise.\n+\t(*ifcompare_move_plus): Likewise.\n+\t(*if_move_plus): Likewise.\n+\t(*ifcompre_arith_move): Likewise.\n+\t(*if_arith_move): Likewise.\n+\t(*ifcompare_move_arith): Likewise.\n+\t(*if_move_arith): Likewise.\n+\n+\t* config/arm/xm-netbsd.h: Don't include arm/xm-arm.h.\n+\t\n 1999-02-05  Michael Meissner  <meissner@cygnus.com>\n \n \t* loop.c (check_dbra_loop): A store using an address giv for which"}, {"sha": "c1a6e570f23eccdc060ddaa4e62a6cd58dc66aec", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 83, "deletions": 16, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36ba79f65f341f556662aea2d2f7c14c4fb1ec5/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36ba79f65f341f556662aea2d2f7c14c4fb1ec5/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=b36ba79f65f341f556662aea2d2f7c14c4fb1ec5", "patch": "@@ -1,8 +1,8 @@\n-/* Output routines for GCC for ARM/RISCiX.\n+/* Output routines for GCC for ARM.\n    Copyright (C) 1991, 93, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.\n    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n    and Martin Simmons (@harleqn.co.uk).\n-   More major hacks by Richard Earnshaw (rwe11@cl.cam.ac.uk)\n+   More major hacks by Richard Earnshaw (rearnsha@arm.com).\n \n This file is part of GNU CC.\n \n@@ -41,7 +41,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* The maximum number of insns skipped which will be conditionalised if\n    possible.  */\n-#define MAX_INSNS_SKIPPED  5\n+static int max_insns_skipped = 5;\n \n /* Some function declarations.  */\n extern FILE *asm_out_file;\n@@ -200,6 +200,11 @@ static struct processors all_procs[] =\n \t\t\t\t | FL_ARCH4)},\n   {\"arm810\",\tPROCESSOR_ARM8, (FL_FAST_MULT | FL_MODE32 | FL_MODE26\n \t\t\t\t | FL_ARCH4)},\n+  /* The next two are the same, but arm9 only exists in the thumb variant */\n+  {\"arm9\",\tPROCESSOR_ARM9, (FL_FAST_MULT | FL_MODE32 | FL_ARCH4\n+\t\t\t\t | FL_THUMB)},\n+  {\"arm9tdmi\",\tPROCESSOR_ARM9, (FL_FAST_MULT | FL_MODE32 | FL_ARCH4\n+\t\t\t\t | FL_THUMB)},\n   {\"strongarm\",\tPROCESSOR_STARM, (FL_FAST_MULT | FL_MODE32 | FL_MODE26\n \t\t\t\t  | FL_ARCH4)},\n   {\"strongarm110\", PROCESSOR_STARM, (FL_FAST_MULT | FL_MODE32 | FL_MODE26\n@@ -362,13 +367,53 @@ arm_override_options ()\n       target_flags &= ~ARM_FLAG_THUMB;\n     }\n \n-  if (TARGET_FPE && arm_fpu != FP_HARD)\n-    arm_fpu = FP_SOFT2;\n+  if (TARGET_FPE && arm_fpu == FP_HARD)\n+    arm_fpu = FP_SOFT3;\n+\n+  /* If optimizing for space, don't synthesize constants */\n+  if (optimize_size)\n+    arm_constant_limit = 1;\n+\n+  /* Override a few things based on the tuning pararmeters.  */\n+  switch (arm_cpu)\n+    {\n+    case PROCESSOR_ARM2:\n+    case PROCESSOR_ARM3:\n+      /* For arm2/3 there is no need to do any scheduling if there is\n+\t only a floating point emulator, or we are doing software\n+\t floating-point.  */\n+      if (TARGET_SOFT_FLOAT || arm_fpu != FP_HARD)\n+\tflag_schedule_insns = flag_schedule_insns_after_reload = 0;\n+      break;\n+\n+    case PROCESSOR_ARM6:\n+    case PROCESSOR_ARM7:\n+      break;\n+\n+    case PROCESSOR_ARM8:\n+    case PROCESSOR_ARM9:\n+      /* For these processors, it never costs more than 2 cycles to load a\n+\t constant, and the load scheduler may well reduce that to 1.  */\n+      arm_constant_limit = 1;\n+      break;\n+\n+    case PROCESSOR_STARM:\n+      /* Same as above */\n+      arm_constant_limit = 1;\n+      /* StrongARM has early execution of branches, a sequence that is worth\n+\t skipping is shorter.  */\n+      max_insns_skipped = 3;\n+      break;\n+\n+    default:\n+      fatal (\"Unknown cpu type selected\");\n+      break;\n+    }\n \n-  /* For arm2/3 there is no need to do any scheduling if there is only\n-     a floating point emulator, or we are doing software floating-point.  */\n-  if ((TARGET_SOFT_FLOAT || arm_fpu != FP_HARD) && arm_cpu == PROCESSOR_ARM2)\n-    flag_schedule_insns = flag_schedule_insns_after_reload = 0;\n+  /* If optimizing for size, bump the number of instructions that we\n+     are prepared to conditionally execute (even on a StrongARM).  */\n+  if (optimize_size)\n+    max_insns_skipped = 6;\n \n   arm_prog_mode = TARGET_APCS_32 ? PROG_MODE_PROG32 : PROG_MODE_PROG26;\n   \n@@ -383,11 +428,11 @@ arm_override_options ()\n     }\n }\n \f\n-\n /* Return 1 if it is possible to return using a single instruction */\n \n int\n-use_return_insn ()\n+use_return_insn (iscond)\n+     int iscond;\n {\n   int regno;\n \n@@ -398,8 +443,12 @@ use_return_insn ()\n     return 0;\n \n   /* Can't be done if interworking with Thumb, and any registers have been\n-     stacked */\n-  if (TARGET_THUMB_INTERWORK)\n+     stacked.  Similarly, on StrongARM, conditional returns are expensive\n+     if they aren't taken and registers have been stacked.  */\n+  if (iscond && arm_cpu == PROCESSOR_STARM && frame_pointer_needed)\n+    return 0;\n+  else if ((iscond && arm_cpu == PROCESSOR_STARM)\n+\t   || TARGET_THUMB_INTERWORK)\n     for (regno = 0; regno < 16; regno++)\n       if (regs_ever_live[regno] && ! call_used_regs[regno])\n \treturn 0;\n@@ -1604,6 +1653,11 @@ arm_adjust_cost (insn, link, dep, cost)\n {\n   rtx i_pat, d_pat;\n \n+  /* XXX This is not strictly true for the FPA. */\n+  if (REG_NOTE_KIND(link) == REG_DEP_ANTI\n+      || REG_NOTE_KIND(link) == REG_DEP_OUTPUT)\n+    return 0;\n+\n   if ((i_pat = single_set (insn)) != NULL\n       && GET_CODE (SET_SRC (i_pat)) == MEM\n       && (d_pat = single_set (dep)) != NULL\n@@ -2537,6 +2591,13 @@ load_multiple_sequence (operands, nops, regs, base, load_offset)\n   if (unsorted_offsets[order[nops - 1]] == -4)\n     return 4; /* ldmdb */\n \n+  /* For ARM8,9 & StrongARM, 2 ldr instructions are faster than an ldm if\n+     the offset isn't small enough */\n+  if (nops == 2\n+      && (arm_cpu == PROCESSOR_ARM8 || arm_cpu == PROCESSOR_ARM9\n+\t  || arm_cpu == PROCESSOR_STARM))\n+    return 0;\n+\n   /* Can't do it without setting up the offset, only do this if it takes\n      no more than one insn.  */\n   return (const_ok_for_arm (unsorted_offsets[order[0]]) \n@@ -5009,7 +5070,7 @@ output_func_epilogue (f, frame_size)\n   int volatile_func = (optimize > 0\n \t\t       && TREE_THIS_VOLATILE (current_function_decl));\n \n-  if (use_return_insn() && return_used_this_function)\n+  if (use_return_insn (FALSE) && return_used_this_function)\n     {\n       if ((frame_size + current_function_outgoing_args_size) != 0\n \t  && !(frame_pointer_needed || TARGET_APCS))\n@@ -5830,7 +5891,7 @@ final_prescan_insn (insn, opvec, noperands)\n \t insns are okay, and the label or unconditional branch to the same\n \t label is not too far away, succeed.  */\n       for (insns_skipped = 0;\n-\t   !fail && !succeed && insns_skipped++ < MAX_INSNS_SKIPPED;)\n+\t   !fail && !succeed && insns_skipped++ < max_insns_skipped;)\n \t{\n \t  rtx scanbody;\n \n@@ -5892,7 +5953,7 @@ final_prescan_insn (insn, opvec, noperands)\n \t\t    this_insn = next_nonnote_insn (this_insn);\n \n \t\t  if (this_insn && this_insn == label\n-\t\t      && insns_skipped < MAX_INSNS_SKIPPED)\n+\t\t      && insns_skipped < max_insns_skipped)\n \t\t    {\n \t\t      if (jump_clobbers)\n \t\t\t{\n@@ -5927,6 +5988,12 @@ final_prescan_insn (insn, opvec, noperands)\n \t\t  else if (GET_CODE (SET_SRC (scanbody)) == IF_THEN_ELSE)\n \t\t    fail = TRUE;\n \t\t}\n+\t      /* Fail if a conditional return is undesirable (eg on a\n+\t\t StrongARM), but still allow this if optimizing for size.  */\n+\t      else if (GET_CODE (scanbody) == RETURN\n+\t\t       && ! use_return_insn (TRUE)\n+\t\t       && ! optimize_size)\n+\t\tfail = TRUE;\n \t      else if (GET_CODE (scanbody) == RETURN\n \t\t       && seeking_return)\n \t        {"}, {"sha": "439ebb6634113042537c4bf85a2194ebf787cab1", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36ba79f65f341f556662aea2d2f7c14c4fb1ec5/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36ba79f65f341f556662aea2d2f7c14c4fb1ec5/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=b36ba79f65f341f556662aea2d2f7c14c4fb1ec5", "patch": "@@ -53,6 +53,8 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_CPU_arm810\t0x0020\n #define TARGET_CPU_strongarm\t0x0040\n #define TARGET_CPU_strongarm110 0x0040\n+#define TARGET_CPU_arm9\t\t0x0080\n+#define TARGET_CPU_arm9tdmi\t0x0080\n /* Configure didn't specify */\n #define TARGET_CPU_generic\t0x8000\n \n@@ -95,7 +97,7 @@ extern int frame_pointer_needed;\n #if TARGET_CPU_DEFAULT == TARGET_CPU_arm7m\n #define CPP_ARCH_DEFAULT_SPEC \"-D__ARM_ARCH_3M__\"\n #else\n-#if TARGET_CPU_DEFAULT == TARGET_CPU_arm7tdmi\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_arm7tdmi || TARGET_CPU_DEFAULT == TARGET_CPU_ARM9\n #define CPP_ARCH_DEFAULT_SPEC \"-D__ARM_ARCH_4T__\"\n #else\n #if TARGET_CPU_DEFAULT == TARGET_CPU_arm8 || TARGET_CPU_DEFAULT == TARGET_CPU_arm810 || TARGET_CPU_DEFAULT == TARGET_CPU_strongarm\n@@ -140,6 +142,8 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n %{march=arm7tdmi:-D__ARM_ARCH_4T__} \\\n %{march=arm8:-D__ARM_ARCH_4__} \\\n %{march=arm810:-D__ARM_ARCH_4__} \\\n+%{march=arm9:-D__ARM_ARCH_4T__} \\\n+%{march=arm9tdmi:-D__ARM_ARCH_4T__} \\\n %{march=strongarm:-D__ARM_ARCH_4__} \\\n %{march=strongarm110:-D__ARM_ARCH_4__} \\\n %{march=armv2:-D__ARM_ARCH_2__} \\\n@@ -167,6 +171,8 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n  %{mcpu=arm7tdmi:-D__ARM_ARCH_4T__} \\\n  %{mcpu=arm8:-D__ARM_ARCH_4__} \\\n  %{mcpu=arm810:-D__ARM_ARCH_4__} \\\n+ %{mcpu=arm9:-D__ARM_ARCH_4T__} \\\n+ %{mcpu=arm9tdmi:-D__ARM_ARCH_4T__} \\\n  %{mcpu=strongarm:-D__ARM_ARCH_4__} \\\n  %{mcpu=strongarm110:-D__ARM_ARCH_4__} \\\n  %{!mcpu*:%{!m6:%{!m2:%{!m3:%(cpp_cpu_arch_default)}}}}} \\\n@@ -427,6 +433,7 @@ enum processor_type\n   PROCESSOR_ARM6,\n   PROCESSOR_ARM7,\n   PROCESSOR_ARM8,\n+  PROCESSOR_ARM9,\n   PROCESSOR_STARM,\n   PROCESSOR_NONE\t/* NOTE: This must be last, since it doesn't\n \t\t\t   appear in the attr_cpu list */\n@@ -1165,7 +1172,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Determine if the epilogue should be output as RTL.\n    You should override this if you define FUNCTION_EXTRA_EPILOGUE.  */\n-#define USE_RETURN_INSN use_return_insn ()\n+#define USE_RETURN_INSN(ISCOND) use_return_insn (ISCOND)\n \n /* Definitions for register eliminations.\n \n@@ -2050,7 +2057,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    fully defined yet.  */\n \n void arm_override_options (/* void */);\n-int use_return_insn (/* void */);\n+int use_return_insn (/* int */);\n int const_ok_for_arm (/* HOST_WIDE_INT */);\n int const_ok_for_op (/* HOST_WIDE_INT, enum rtx_code, \n \t\t\tenum machine_mode */);"}, {"sha": "96843f0c586b6bcddb47f618ae4b8a702058e965", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 118, "deletions": 101, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36ba79f65f341f556662aea2d2f7c14c4fb1ec5/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36ba79f65f341f556662aea2d2f7c14c4fb1ec5/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=b36ba79f65f341f556662aea2d2f7c14c4fb1ec5", "patch": "@@ -1,8 +1,8 @@\n-;;- Machine description for Advanced RISC Machines' ARM for GNU compiler\n+;;- Machine description for ARM for GNU compiler\n ;;  Copyright (C) 1991, 93-98, 1999 Free Software Foundation, Inc.\n ;;  Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n ;;  and Martin Simmons (@harleqn.co.uk).\n-;;  More major hacks by Richard Earnshaw (rwe11@cl.cam.ac.uk)\n+;;  More major hacks by Richard Earnshaw (rearnsha@arm.com).\n \n ;; This file is part of GNU CC.\n \n@@ -45,11 +45,9 @@\n ; by the -mapcs-{32,26} flag, and possibly the -mcpu=... option.\n (define_attr \"prog_mode\" \"prog26,prog32\" (const (symbol_ref \"arm_prog_mode\")))\n \n-; CPU attribute is used to determine whether condition codes are clobbered\n-; by a call insn: on the arm6 they are if in 32-bit addressing mode; on the\n-; arm2 and arm3 the condition codes are restored by the return.\n-\n-(define_attr \"cpu\" \"arm2,arm3,arm6,arm7,arm8,st_arm\"\n+; CPU attribute is used to determine the best instruction mix for performance\n+; on the named processor.\n+(define_attr \"cpu\" \"arm2,arm3,arm6,arm7,arm8,arm9,st_arm\"\n \t(const (symbol_ref \"arm_cpu_attr\")))\n \n ; Floating Point Unit.  If we only have floating point emulation, then there\n@@ -104,7 +102,7 @@\n \n ; Load scheduling, set from the cpu characteristic\n (define_attr \"ldsched\" \"no,yes\"\n-  (if_then_else (eq_attr \"cpu\" \"arm8,st_arm\")\n+  (if_then_else (eq_attr \"cpu\" \"arm8,arm9,st_arm\")\n \t\t(const_string \"yes\")\n \t\t(const_string \"no\")))\n \n@@ -135,6 +133,15 @@\n \t  (const_string \"clob\") (const_string \"nocond\"))\n \t (const_string \"nocond\")))\n \n+; Only model the write buffer for ARM6 and ARM7.  Earlier processors don't\n+; have one.  Later ones, such as StrongARM, have write-back caches, so don't\n+; suffer blockages enough to warrent modelling this (and it can adversely\n+; affect the schedule).\n+(define_attr \"model_wbuf\" \"no,yes\"\n+  (if_then_else (eq_attr \"cpu\" \"arm6,arm7\")\n+\t\t(const_string \"yes\")\n+\t\t(const_string \"no\")))\n+\n (define_attr \"write_conflict\" \"no,yes\"\n   (if_then_else (eq_attr \"type\"\n \t\t \"block,float_em,f_load,f_store,f_mem_r,r_mem_f,call,load\")\n@@ -194,59 +201,85 @@\n (define_function_unit \"fpa_mem\" 1 0 (and (eq_attr \"fpu\" \"fpa\")\n \t\t\t\t\t (eq_attr \"type\" \"f_load\")) 3 1)\n \n-(define_function_unit \"write_buf\" 1 2 (eq_attr \"type\" \"store1\") 5 3)\n-(define_function_unit \"write_buf\" 1 2 (eq_attr \"type\" \"store2\") 7 4)\n-(define_function_unit \"write_buf\" 1 2 (eq_attr \"type\" \"store3\") 9 5)\n-(define_function_unit \"write_buf\" 1 2 (eq_attr \"type\" \"store4\") 11 6)\n-(define_function_unit \"write_buf\" 1 2 (eq_attr \"type\" \"r_mem_f\") 5 3)\n-\n-;; The write_blockage unit models (partially), the fact that writes will stall\n+;;--------------------------------------------------------------------\n+;; Write buffer\n+;;--------------------------------------------------------------------\n+;; Strictly we should model a 4-deep write buffer for ARM7xx based chips\n+(define_function_unit \"write_buf\" 1 2\n+  (and (eq_attr \"model_wbuf\" \"yes\")\n+       (eq_attr \"type\" \"store1,r_mem_f\")) 5 3)\n+(define_function_unit \"write_buf\" 1 2 \n+  (and (eq_attr \"model_wbuf\" \"yes\")\n+       (eq_attr \"type\" \"store2\")) 7 4)\n+(define_function_unit \"write_buf\" 1 2\n+  (and (eq_attr \"model_wbuf\" \"yes\")\n+       (eq_attr \"type\" \"store3\")) 9 5)\n+(define_function_unit \"write_buf\" 1 2\n+  (and (eq_attr \"model_wbuf\" \"yes\")\n+       (eq_attr \"type\" \"store4\")) 11 6)\n+\n+;;--------------------------------------------------------------------\n+;; Write blockage unit\n+;;--------------------------------------------------------------------\n+;; The write_blockage unit models (partially), the fact that reads will stall\n ;; until the write buffer empties.\n-\n-(define_function_unit \"write_blockage\" 1 0 (eq_attr \"type\" \"store1\") 5 5\n-\t[(eq_attr \"write_conflict\" \"yes\")])\n-(define_function_unit \"write_blockage\" 1 0 (eq_attr \"type\" \"store2\") 7 7\n+;; The f_mem_r and r_mem_f could also block, but they are to the stack,\n+;; so we don't model them here\n+(define_function_unit \"write_blockage\" 1 0 (and (eq_attr \"model_wbuf\" \"yes\")\n+\t\t\t\t\t\t(eq_attr \"type\" \"store1\")) 5 5\n \t[(eq_attr \"write_conflict\" \"yes\")])\n-(define_function_unit \"write_blockage\" 1 0 (eq_attr \"type\" \"store3\") 9 9\n+(define_function_unit \"write_blockage\" 1 0 (and (eq_attr \"model_wbuf\" \"yes\")\n+\t\t\t\t\t\t(eq_attr \"type\" \"store2\")) 7 7\n \t[(eq_attr \"write_conflict\" \"yes\")])\n-(define_function_unit \"write_blockage\" 1 0 (eq_attr \"type\" \"store4\") 11 11\n+(define_function_unit \"write_blockage\" 1 0 (and (eq_attr \"model_wbuf\" \"yes\")\n+\t\t\t\t\t\t(eq_attr \"type\" \"store3\")) 9 9\n \t[(eq_attr \"write_conflict\" \"yes\")])\n-(define_function_unit \"write_blockage\" 1 0 (eq_attr \"type\" \"r_mem_f\") 5 5\n+(define_function_unit \"write_blockage\" 1 0\n+\t(and (eq_attr \"model_wbuf\" \"yes\") (eq_attr \"type\" \"store4\")) 11 11\n \t[(eq_attr \"write_conflict\" \"yes\")])\n-(define_function_unit \"write_blockage\" 1 0 \n-\t(eq_attr \"write_conflict\" \"yes\") 1 1)\n-\n+(define_function_unit \"write_blockage\" 1 0\n+\t(and (eq_attr \"model_wbuf\" \"yes\")\n+\t     (eq_attr \"write_conflict\" \"yes\")) 1 1)\n+\n+;;--------------------------------------------------------------------\n+;; Core unit\n+;;--------------------------------------------------------------------\n+;; Everything must spend at least one cycle in the core unit\n+(define_function_unit \"core\" 1 0\n+  (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"type\" \"store1\")) 1 1)\n \n+(define_function_unit \"core\" 1 0\n+  (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"type\" \"load\")) 2 1)\n \n-(define_function_unit \"core\" 1 1 (eq_attr \"core_cycles\" \"single\") 1 1)\n+(define_function_unit \"core\" 1 0\n+  (and (eq_attr \"ldsched\" \"!yes\") (eq_attr \"type\" \"load,store1\")) 2 2)\n \n-(define_function_unit \"core\" 1 1 \n-  (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"type\" \"load\")) 1 1)\n+(define_function_unit \"core\" 1 0\n+  (and (eq_attr \"fpu\" \"fpa\") (eq_attr \"type\" \"f_load\")) 3 3)\n \n-(define_function_unit \"core\" 1 1 \n-  (and (eq_attr \"ldsched\" \"!yes\") (eq_attr \"type\" \"load\")) 2 2)\n+(define_function_unit \"core\" 1 0\n+  (and (eq_attr \"fpu\" \"fpa\") (eq_attr \"type\" \"f_store\")) 4 4)\n \n-(define_function_unit \"core\" 1 1 (eq_attr \"type\" \"mult\") 16 16)\n+(define_function_unit \"core\" 1 0\n+  (and (eq_attr \"fpu\" \"fpa\") (eq_attr \"type\" \"r_mem_f\")) 6 6)\n \n-(define_function_unit \"core\" 1 1 \n-  (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"type\" \"store1\")) 1 1)\n+(define_function_unit \"core\" 1 0\n+  (and (eq_attr \"fpu\" \"fpa\") (eq_attr \"type\" \"f_mem_r\")) 7 7)\n \n-(define_function_unit \"core\" 1 1 \n-  (and (eq_attr \"ldsched\" \"!yes\") (eq_attr \"type\" \"store1\")) 2 2)\n+(define_function_unit \"core\" 1 0\n+  (and (eq_attr \"cpu\" \"!arm8,st_arm\") (eq_attr \"type\" \"mult\")) 16 16)\n \n-(define_function_unit \"core\" 1 1 (eq_attr \"type\" \"store2\") 3 3)\n+(define_function_unit \"core\" 1 0\n+  (and (eq_attr \"cpu\" \"arm8\") (eq_attr \"type\" \"mult\")) 4 4)\n \n-(define_function_unit \"core\" 1 1 (eq_attr \"type\" \"store3\") 4 4)\n+(define_function_unit \"core\" 1 0\n+  (and (eq_attr \"cpu\" \"st_arm\") (eq_attr \"type\" \"mult\")) 3 2)\n \n-(define_function_unit \"core\" 1 1 (eq_attr \"type\" \"store4\") 5 5)\n+(define_function_unit \"core\" 1 0 (eq_attr \"type\" \"store2\") 3 3)\n \n-(define_function_unit \"core\" 1 1\n-  (and (eq_attr \"core_cycles\" \"multi\")\n-       (eq_attr \"type\" \"!mult,load,store2,store3,store4\")) 32 32)\n-\n-(define_function_unit \"loader\" 1 0 \n-  (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"type\" \"load\")) 2 1)\n+(define_function_unit \"core\" 1 0 (eq_attr \"type\" \"store3\") 4 4)\n \n+(define_function_unit \"core\" 1 0 (eq_attr \"type\" \"store4\") 5 5)\n \f\n ;; Note: For DImode insns, there is normally no reason why operands should\n ;; not be in the same register, what we don't want is for something being\n@@ -3048,7 +3081,7 @@\n [(set_attr \"type\" \"*,*,load,store1\")])\n \n (define_insn \"*movhi_insn_littleend\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r,r,r\")\n+  [(set (match_operand:HI 0 \"s_register_operand\" \"=r,r,r\")\n \t(match_operand:HI 1 \"general_operand\"  \"rI,K,m\"))]\n   \"! arm_arch4\n    && ! BYTES_BIG_ENDIAN\n@@ -4252,7 +4285,7 @@\n ;; Often the return insn will be the same as loading from memory, so set attr\n (define_insn \"return\"\n   [(return)]\n-  \"USE_RETURN_INSN\"\n+  \"USE_RETURN_INSN(FALSE)\"\n   \"*\n {\n   extern int arm_ccfsm_state;\n@@ -4272,7 +4305,7 @@\n \t\t       [(match_operand 1 \"cc_register\" \"\") (const_int 0)])\n                       (return)\n                       (pc)))]\n-  \"USE_RETURN_INSN\"\n+  \"USE_RETURN_INSN(TRUE)\"\n   \"*\n {\n   extern int arm_ccfsm_state;\n@@ -4293,7 +4326,7 @@\n \t\t       [(match_operand 1 \"cc_register\" \"\") (const_int 0)])\n                       (pc)\n \t\t      (return)))]\n-  \"USE_RETURN_INSN\"\n+  \"USE_RETURN_INSN(TRUE)\"\n   \"*\n {\n   extern int arm_ccfsm_state;\n@@ -4895,40 +4928,38 @@\n \t\t\t (plus:SI\n \t\t\t  (match_operand:SI 2 \"s_register_operand\" \"r,r\")\n \t\t\t  (match_operand:SI 3 \"arm_add_operand\" \"rIL,rIL\"))\n-\t\t\t (match_operand:SI 1 \"arm_rhsm_operand\" \"0,?rIm\")))\n+\t\t\t (match_operand:SI 1 \"arm_rhs_operand\" \"0,?rI\")))\n    (clobber (reg:CC 24))]\n   \"\"\n   \"#\"\n [(set_attr \"conds\" \"clob\")\n  (set_attr \"length\" \"8,12\")])\n \n (define_insn \"*if_plus_move\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r,r,r,r,r\")\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r,r,r\")\n \t(if_then_else:SI\n \t (match_operator 4 \"comparison_operator\"\n \t  [(match_operand 5 \"cc_register\" \"\") (const_int 0)])\n \t (plus:SI\n-\t  (match_operand:SI 2 \"s_register_operand\" \"r,r,r,r,r,r\")\n-\t  (match_operand:SI 3 \"arm_add_operand\" \"rI,L,rI,L,rI,L\"))\n-\t (match_operand:SI 1 \"arm_rhsm_operand\" \"0,0,?rI,?rI,m,m\")))]\n+\t  (match_operand:SI 2 \"s_register_operand\" \"r,r,r,r\")\n+\t  (match_operand:SI 3 \"arm_add_operand\" \"rI,L,rI,L\"))\n+\t (match_operand:SI 1 \"arm_rhs_operand\" \"0,0,?rI,?rI\")))]\n   \"\"\n   \"@\n    add%d4\\\\t%0, %2, %3\n    sub%d4\\\\t%0, %2, #%n3\n    add%d4\\\\t%0, %2, %3\\;mov%D4\\\\t%0, %1\n-   sub%d4\\\\t%0, %2, #%n3\\;mov%D4\\\\t%0, %1\n-   add%d4\\\\t%0, %2, %3\\;ldr%D4\\\\t%0, %1\n-   sub%d4\\\\t%0, %2, #%n3\\;ldr%D4\\\\t%0, %1\"\n+   sub%d4\\\\t%0, %2, #%n3\\;mov%D4\\\\t%0, %1\"\n [(set_attr \"conds\" \"use\")\n- (set_attr \"length\" \"4,4,8,8,8,8\")\n- (set_attr \"type\" \"*,*,*,*,load,load\")])\n+ (set_attr \"length\" \"4,4,8,8\")\n+ (set_attr \"type\" \"*,*,*,*\")])\n \n (define_insn \"*ifcompare_move_plus\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n \t(if_then_else:SI (match_operator 6 \"comparison_operator\"\n \t\t\t  [(match_operand:SI 4 \"s_register_operand\" \"r,r\")\n \t\t\t   (match_operand:SI 5 \"arm_add_operand\" \"rIL,rIL\")])\n-\t\t\t (match_operand:SI 1 \"arm_rhsm_operand\" \"0,?rIm\")\n+\t\t\t (match_operand:SI 1 \"arm_rhs_operand\" \"0,?rI\")\n \t\t\t (plus:SI\n \t\t\t  (match_operand:SI 2 \"s_register_operand\" \"r,r\")\n \t\t\t  (match_operand:SI 3 \"arm_add_operand\" \"rIL,rIL\"))))\n@@ -4939,25 +4970,23 @@\n  (set_attr \"length\" \"8,12\")])\n \n (define_insn \"*if_move_plus\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r,r,r,r,r\")\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r,r,r\")\n \t(if_then_else:SI\n \t (match_operator 4 \"comparison_operator\"\n \t  [(match_operand 5 \"cc_register\" \"\") (const_int 0)])\n-\t (match_operand:SI 1 \"arm_rhsm_operand\" \"0,0,?rI,?rI,m,m\")\n+\t (match_operand:SI 1 \"arm_rhs_operand\" \"0,0,?rI,?rI\")\n \t (plus:SI\n-\t  (match_operand:SI 2 \"s_register_operand\" \"r,r,r,r,r,r\")\n-\t  (match_operand:SI 3 \"arm_add_operand\" \"rI,L,rI,L,rI,L\"))))]\n+\t  (match_operand:SI 2 \"s_register_operand\" \"r,r,r,r\")\n+\t  (match_operand:SI 3 \"arm_add_operand\" \"rI,L,rI,L\"))))]\n   \"\"\n   \"@\n    add%D4\\\\t%0, %2, %3\n    sub%D4\\\\t%0, %2, #%n3\n    add%D4\\\\t%0, %2, %3\\;mov%d4\\\\t%0, %1\n-   sub%D4\\\\t%0, %2, #%n3\\;mov%d4\\\\t%0, %1\n-   add%D4\\\\t%0, %2, %3\\;ldr%d4\\\\t%0, %1\n-   sub%D4\\\\t%0, %2, #%n3\\;ldr%d4\\\\t%0, %1\"\n+   sub%D4\\\\t%0, %2, #%n3\\;mov%d4\\\\t%0, %1\"\n [(set_attr \"conds\" \"use\")\n- (set_attr \"length\" \"4,4,8,8,8,8\")\n- (set_attr \"type\" \"*,*,*,*,load,load\")])\n+ (set_attr \"length\" \"4,4,8,8\")\n+ (set_attr \"type\" \"*,*,*,*\")])\n \n (define_insn \"*ifcompare_arith_arith\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n@@ -4999,7 +5028,7 @@\n \t\t\t (match_operator:SI 7 \"shiftable_operator\"\n \t\t\t  [(match_operand:SI 4 \"s_register_operand\" \"r,r\")\n \t\t\t   (match_operand:SI 5 \"arm_rhs_operand\" \"rI,rI\")])\n-\t\t\t (match_operand:SI 1 \"arm_rhsm_operand\" \"0,?rIm\")))\n+\t\t\t (match_operand:SI 1 \"arm_rhs_operand\" \"0,?rI\")))\n    (clobber (reg:CC 24))]\n   \"\"\n   \"*\n@@ -5025,40 +5054,34 @@\n     output_asm_insn (\\\"cmp\\\\t%2, %3\\\", operands);\n   output_asm_insn (\\\"%I7%d6\\\\t%0, %4, %5\\\", operands);\n   if (which_alternative != 0)\n-    {\n-      if (GET_CODE (operands[1]) == MEM)\n-\treturn \\\"ldr%D6\\\\t%0, %1\\\";\n-      else\n-\treturn \\\"mov%D6\\\\t%0, %1\\\";\n-    }\n+    return \\\"mov%D6\\\\t%0, %1\\\";\n   return \\\"\\\";\n \"\n [(set_attr \"conds\" \"clob\")\n  (set_attr \"length\" \"8,12\")])\n \n (define_insn \"*if_arith_move\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r,r\")\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n \t(if_then_else:SI (match_operator 4 \"comparison_operator\"\n \t\t\t  [(match_operand 6 \"cc_register\" \"\") (const_int 0)])\n \t\t\t (match_operator:SI 5 \"shiftable_operator\"\n-\t\t\t  [(match_operand:SI 2 \"s_register_operand\" \"r,r,r\")\n-\t\t\t   (match_operand:SI 3 \"arm_rhs_operand\" \"rI,rI,rI\")])\n-\t\t\t (match_operand:SI 1 \"arm_rhsm_operand\" \"0,?rI,m\")))]\n+\t\t\t  [(match_operand:SI 2 \"s_register_operand\" \"r,r\")\n+\t\t\t   (match_operand:SI 3 \"arm_rhs_operand\" \"rI,rI\")])\n+\t\t\t (match_operand:SI 1 \"arm_rhs_operand\" \"0,?rI\")))]\n   \"\"\n   \"@\n    %I5%d4\\\\t%0, %2, %3\n-   %I5%d4\\\\t%0, %2, %3\\;mov%D4\\\\t%0, %1\n-   %I5%d4\\\\t%0, %2, %3\\;ldr%D4\\\\t%0, %1\"\n+   %I5%d4\\\\t%0, %2, %3\\;mov%D4\\\\t%0, %1\"\n [(set_attr \"conds\" \"use\")\n- (set_attr \"length\" \"4,8,8\")\n- (set_attr \"type\" \"*,*,load\")])\n+ (set_attr \"length\" \"4,8\")\n+ (set_attr \"type\" \"*,*\")])\n \n (define_insn \"*ifcompare_move_arith\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n \t(if_then_else:SI (match_operator 6 \"comparison_operator\"\n \t\t\t  [(match_operand:SI 4 \"s_register_operand\" \"r,r\")\n \t\t\t   (match_operand:SI 5 \"arm_add_operand\" \"rIL,rIL\")])\n-\t\t\t (match_operand:SI 1 \"arm_rhsm_operand\" \"0,?rIm\")\n+\t\t\t (match_operand:SI 1 \"arm_rhs_operand\" \"0,?rI\")\n \t\t\t (match_operator:SI 7 \"shiftable_operator\"\n \t\t\t  [(match_operand:SI 2 \"s_register_operand\" \"r,r\")\n \t\t\t   (match_operand:SI 3 \"arm_rhs_operand\" \"rI,rI\")])))\n@@ -5088,34 +5111,28 @@\n     output_asm_insn (\\\"cmp\\\\t%4, %5\\\", operands);\n \n   if (which_alternative != 0)\n-    {\n-      if (GET_CODE (operands[1]) == MEM)\n-\toutput_asm_insn (\\\"ldr%d6\\\\t%0, %1\\\", operands);\n-      else\n-\toutput_asm_insn (\\\"mov%d6\\\\t%0, %1\\\", operands);\n-    }\n+    output_asm_insn (\\\"mov%d6\\\\t%0, %1\\\", operands);\n   return \\\"%I7%D6\\\\t%0, %2, %3\\\";\n \"\n [(set_attr \"conds\" \"clob\")\n  (set_attr \"length\" \"8,12\")])\n \n (define_insn \"*if_move_arith\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r,r\")\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n \t(if_then_else:SI\n \t (match_operator 4 \"comparison_operator\"\n \t  [(match_operand 6 \"cc_register\" \"\") (const_int 0)])\n-\t (match_operand:SI 1 \"arm_rhsm_operand\" \"0,?rI,m\")\n+\t (match_operand:SI 1 \"arm_rhs_operand\" \"0,?rI\")\n \t (match_operator:SI 5 \"shiftable_operator\"\n-\t  [(match_operand:SI 2 \"s_register_operand\" \"r,r,r\")\n-\t   (match_operand:SI 3 \"arm_rhs_operand\" \"rI,rI,rI\")])))]\n+\t  [(match_operand:SI 2 \"s_register_operand\" \"r,r\")\n+\t   (match_operand:SI 3 \"arm_rhs_operand\" \"rI,rI\")])))]\n   \"\"\n   \"@\n    %I5%D4\\\\t%0, %2, %3\n-   %I5%D4\\\\t%0, %2, %3\\;mov%d4\\\\t%0, %1\n-   %I5%D4\\\\t%0, %2, %3\\;ldr%d4\\\\t%0, %1\"\n+   %I5%D4\\\\t%0, %2, %3\\;mov%d4\\\\t%0, %1\"\n [(set_attr \"conds\" \"use\")\n- (set_attr \"length\" \"4,8,8\")\n- (set_attr \"type\" \"*,*,load\")])\n+ (set_attr \"length\" \"4,8\")\n+ (set_attr \"type\" \"*,*\")])\n \n (define_insn \"*ifcompare_move_not\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n@@ -5975,7 +5992,7 @@\n \t\t\t  (match_operand:SI 1 \"general_operand\" \"g\"))\n \t\t    (clobber (reg:SI 14))])\n    (return)]\n-  \"(GET_CODE (operands[0]) == SYMBOL_REF && USE_RETURN_INSN\n+  \"(GET_CODE (operands[0]) == SYMBOL_REF && USE_RETURN_INSN(FALSE)\n     && !get_frame_size () && !current_function_calls_alloca\n     && !frame_pointer_needed && !current_function_args_size)\"\n   \"*\n@@ -6003,7 +6020,7 @@\n \t\t\t (match_operand:SI 2 \"general_operand\" \"g\")))\n \t      (clobber (reg:SI 14))])\n    (return)]\n-  \"(GET_CODE (operands[1]) == SYMBOL_REF && USE_RETURN_INSN\n+  \"(GET_CODE (operands[1]) == SYMBOL_REF && USE_RETURN_INSN(FALSE)\n     && !get_frame_size () && !current_function_calls_alloca\n     && !frame_pointer_needed && !current_function_args_size)\"\n   \"*\n@@ -6035,7 +6052,7 @@\n \t      (clobber (reg:SI 14))])\n    (use (match_dup 0))\n    (return)]\n-  \"(GET_CODE (operands[1]) == SYMBOL_REF && USE_RETURN_INSN\n+  \"(GET_CODE (operands[1]) == SYMBOL_REF && USE_RETURN_INSN(FALSE)\n     && !get_frame_size () && !current_function_calls_alloca\n     && !frame_pointer_needed && !current_function_args_size)\"\n   \"*"}, {"sha": "622709c100629e94235d444ba6928fd9fa952fc7", "filename": "gcc/config/arm/xm-netbsd.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36ba79f65f341f556662aea2d2f7c14c4fb1ec5/gcc%2Fconfig%2Farm%2Fxm-netbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36ba79f65f341f556662aea2d2f7c14c4fb1ec5/gcc%2Fconfig%2Farm%2Fxm-netbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fxm-netbsd.h?ref=b36ba79f65f341f556662aea2d2f7c14c4fb1ec5", "patch": "@@ -1,7 +1,5 @@\n /* Configuration for GCC for ARM running NetBSD as host.  */\n \n-#include <arm/xm-arm.h>\n-\n #ifndef SYS_SIGLIST_DECLARED\n #define SYS_SIGLIST_DECLARED\n #endif"}]}