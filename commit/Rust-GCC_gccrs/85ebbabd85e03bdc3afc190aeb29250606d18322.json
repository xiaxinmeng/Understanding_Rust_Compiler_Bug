{"sha": "85ebbabd85e03bdc3afc190aeb29250606d18322", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVlYmJhYmQ4NWUwM2JkYzNhZmMxOTBhZWIyOTI1MDYwNmQxODMyMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-16T18:30:45Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-16T18:30:45Z"}, "message": "IPA tracking of EAF flags in ipa-modref.\n\nthis patch implements the IPA propagation part of EAF flags handling in\nipa-modref.  It extends the local analysis to collect lattice consisting of\nflags and escape points.  SSA name escapes if it is passed directly or\nindirectly to a function call.\n\nIf useful flags are found for parameter its escape list is stored into escape\nsummaries.  This time each call site is annotated with info on which function\nparameters escape to what argument of function call.\n\nAt IPA time we then perform iterative dataflow and produce final flags.\nipa-modref is still cheaper than pure-const when running on cc1plus (about 2-3%\nthat is what accounts every non-trivial passs) and the dataflow converges in 1\nor 2 iterations.\n\nLocal analysis does some work to avoid streaming escape points when they are\nnot useful to determine final flags (that is, local escape analysis determined\ngood enough flags). For cc1plus there are 225k calls with useful escape\nsummary.\n\n\t* ipa-modref.c (escape_point): New type.\n\t(modref_lattice): New type.\n\t(escape_entry): New type.\n\t(escape_summary): New type.\n\t(escape_summaries_t): New type.\n\t(escape_summaries): New static variable.\n\t(eaf_flags_useful_p): New function.\n\t(modref_summary::useful_p): Add new check_flags\n\tattribute; check eaf_flags for usefulness.\n\t(modref_summary_lto): Add arg_flags.\n\t(modref_summary_lto::useful_p): Add new check_flags\n\tattribute; check eaf_flags for usefulness.\n\t(dump_modref_edge_summaries): New function.\n\t(remove_modref_edge_summaries): New function.\n\t(ignore_retval_p): New predicate.\n\t(ignore_stores_p): Also ignore for const.\n\t(remove_summary): Call remove_modref_edge_summaries.\n\t(modref_lattice::init): New member function.\n\t(modref_lattice::release): New member unction.\n\t(modref_lattice::dump): New member function.\n\t(modref_lattice::add_escape_point): New member function.\n\t(modref_lattice::merge): Two new member functions.\n\t(modref_lattice::merge_deref): New member functions.\n\t(modref_lattice::merge_direct_load): New member function.\n\t(modref_lattice::merge_direct_store): New member function.\n\t(call_lhs_flags): Rename to ...\n\t(merge_call_lhs_flags): ... this one; reimplement using\n\tmodreflattice.\n\t(analyze_ssa_name_flags): Replace KNOWN_FLAGS param by LATTICE;\n\tadd IPA parametr; use modref_lattice.\n\t(analyze_parms): New parameter IPA and SUMMARY_LTO; update for\n\tmodref_lattice; initialize escape_summary.\n\t(analyze_function): Allocate escape_summaries; update uses of useful_p.\n\t(modref_write_escape_summary): New function.\n\t(modref_read_escape_summary): New function.\n\t(modref_write): Write escape summary.\n\t(read_section): Read escape summary.\n\t(modref_read): Initialie escape_summaries.\n\t(remap_arg_flags): New function.\n\t(update_signature): Use it.\n\t(escape_map): New structure.\n\t(update_escape_summary_1, update_escape_summary): New functions.\n\t(ipa_merge_modref_summary_after_inlining): Merge escape summaries.\n\t(propagate_unknown_call): Do not remove useless summaries.\n\t(remove_useless_summaries): Remove them here.\n\t(modref_propagate_in_scc): Update; do not dump scc.\n\t(modref_propagate_dump_scc): New function.\n\t(modref_merge_call_site_flags): New function.\n\t(modref_propagate_flags_in_scc): New function.\n\t(pass_ipa_modref::execute): Use modref_propagate_flags_in_scc\n\tand modref_propagate_dump_scc; delete escape_summaries.\n\t(ipa_modref_c_finalize):  Remove escape_summaries.\n\t* ipa-modref.h (modref_summary): Update prototype of useful_p.\n\t* params.opt (param=modref-max-escape-points): New param.\n\t* doc/invoke.texi (modref-max-escape-points): Document.", "tree": {"sha": "bb5676c1d6481fd778c453c9470920dd9934856c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb5676c1d6481fd778c453c9470920dd9934856c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85ebbabd85e03bdc3afc190aeb29250606d18322", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85ebbabd85e03bdc3afc190aeb29250606d18322", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85ebbabd85e03bdc3afc190aeb29250606d18322", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85ebbabd85e03bdc3afc190aeb29250606d18322/comments", "author": null, "committer": null, "parents": [{"sha": "0c9687d0daa08c33456210b87e4060d6397ff4d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c9687d0daa08c33456210b87e4060d6397ff4d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c9687d0daa08c33456210b87e4060d6397ff4d8"}], "stats": {"total": 1290, "additions": 1092, "deletions": 198}, "files": [{"sha": "e84a3cf422ecd32db59f0e281239d9ea9585b1f4", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85ebbabd85e03bdc3afc190aeb29250606d18322/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85ebbabd85e03bdc3afc190aeb29250606d18322/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=85ebbabd85e03bdc3afc190aeb29250606d18322", "patch": "@@ -13010,9 +13010,12 @@ bigger than @option{--param ipa-modref-max-bases} and @option{--param\n ipa-modref-max-refs}.\n \n @item ipa-modref-max-depth\n-Specified the maximum depth of DFS walk used by modref escape analysis.\n+Specifies the maximum depth of DFS walk used by modref escape analysis.\n Setting to 0 disables the analysis completely.\n \n+@item modref-max-escape-points\n+Specifies the maximum number of escape points tracked by modref per SSA-name.\n+\n @item profile-func-internal-id\n A parameter to control whether to use function internal id in profile\n database lookup. If the value is 0, the compiler uses an id that"}, {"sha": "e6cb4a87b691f3f11a172def6bc1d5ce35641d41", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 1082, "deletions": 195, "changes": 1277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85ebbabd85e03bdc3afc190aeb29250606d18322/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85ebbabd85e03bdc3afc190aeb29250606d18322/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=85ebbabd85e03bdc3afc190aeb29250606d18322", "patch": "@@ -20,8 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Mod/ref pass records summary about loads and stores performed by the\n    function.  This is later used by alias analysis to disambiguate memory\n-   accesses across function calls.  The summary has a form of decision tree\n-   described in ipa-modref-tree.h.\n+   accesses across function calls.\n \n    This file contains a tree pass and an IPA pass.  Both performs the same\n    analysis however tree pass is executed during early and late optimization\n@@ -32,8 +31,27 @@ along with GCC; see the file COPYING3.  If not see\n    LTO mode differs from the local mode by not recording alias sets but types\n    that are translated to alias sets later.  This is necessary in order stream\n    the information because the alias sets are rebuild at stream-in time and may\n-   not correspond to ones seen during analysis.  For this reason part of analysis\n-   is duplicated.  */\n+   not correspond to ones seen during analysis.  For this reason part of\n+   analysis is duplicated.\n+\n+   The following information is computed\n+     1) load/store access tree described in ipa-modref-tree.h\n+\tThis is used by tree-ssa-alias to disambiguate load/dtores\n+     2) EAF flags used by points-to analysis (in tree-ssa-structlias).\n+\tand defined in tree-core.h.\n+   and stored to optimization_summaries.\n+\n+   There are multiple summaries computed and used during the propagation:\n+     - summaries holds summaries from analysis to IPA propagation\n+       time.\n+     - summaries_lto is same as summaries but holds them in a format\n+       that can be streamed (as described above).\n+     - fnspec_summary holds fnspec strings for call.  This is\n+       necessary because gimple_call_fnspec performs additional\n+       analysis except for looking callee fndecl.\n+     - escape_summary holds escape points for given call edge.\n+       That is a vector recording what function parmaeters\n+       may escape to a function call (and with what parameter index).  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -68,8 +86,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"tree-ssanames.h\"\n \n-static int analyze_ssa_name_flags (tree name,\n-\t\t\t\t   vec<unsigned char> &known_flags, int depth);\n+namespace {\n \n /* We record fnspec specifiers for call edges since they depends on actual\n    gimple statements.  */\n@@ -109,6 +126,74 @@ class fnspec_summaries_t : public call_summary <fnspec_summary *>\n \n static fnspec_summaries_t *fnspec_summaries = NULL;\n \n+/* Escape summary holds a vector of param indexes that escape to\n+   a given call.  */\n+struct escape_entry\n+{\n+  /* Parameter that escapes at a given call.  */\n+  unsigned int parm_index;\n+  /* Argument it escapes to.  */\n+  unsigned int arg;\n+  /* Minimal flags known about the argument.  */\n+  char min_flags;\n+  /* Does it escape directly or indirectly?  */\n+  bool direct;\n+};\n+\n+/* Dump EAF flags.  */\n+\n+static void\n+dump_eaf_flags (FILE *out, int flags, bool newline = true)\n+{\n+  if (flags & EAF_DIRECT)\n+    fprintf (out, \" direct\");\n+  if (flags & EAF_NOCLOBBER)\n+    fprintf (out, \" noclobber\");\n+  if (flags & EAF_NOESCAPE)\n+    fprintf (out, \" noescape\");\n+  if (flags & EAF_UNUSED)\n+    fprintf (out, \" unused\");\n+  if (newline)\n+  fprintf (out, \"\\n\");\n+}\n+\n+struct escape_summary\n+{\n+  auto_vec <escape_entry> esc;\n+  void dump (FILE *out)\n+  {\n+    for (unsigned int i = 0; i < esc.length (); i++)\n+      {\n+\tfprintf (out, \"   parm %i arg %i %s min:\",\n+\t\t esc[i].parm_index,\n+\t\t esc[i].arg,\n+\t\t esc[i].direct ? \"(direct)\" : \"(indirect)\");\n+\tdump_eaf_flags (out, esc[i].min_flags, false);\n+      }\n+    fprintf (out, \"\\n\");\n+  }\n+};\n+\n+class escape_summaries_t : public call_summary <escape_summary *>\n+{\n+public:\n+  escape_summaries_t (symbol_table *symtab)\n+      : call_summary <escape_summary *> (symtab) {}\n+  /* Hook that is called by summary when an edge is duplicated.  */\n+  virtual void duplicate (cgraph_edge *,\n+\t\t\t  cgraph_edge *,\n+\t\t\t  escape_summary *src,\n+\t\t\t  escape_summary *dst)\n+  {\n+    dst->esc = src->esc.copy ();\n+  }\n+};\n+\n+static escape_summaries_t *escape_summaries = NULL;\n+\n+}  /* ANON namespace: GTY annotated summaries can not be anonymous.  */\n+\n+\n /* Class (from which there is one global instance) that holds modref summaries\n    for all analyzed functions.  */\n \n@@ -188,15 +273,38 @@ modref_summary::~modref_summary ()\n     ggc_delete (stores);\n }\n \n-/* Return true if summary is potentially useful for optimization.  */\n+/* Return true if FLAGS holds some useful information.  */\n+\n+static bool\n+eaf_flags_useful_p (vec <unsigned char> &flags, int ecf_flags)\n+{\n+  for (unsigned i = 0; i < flags.length (); i++)\n+    if (ecf_flags & ECF_PURE)\n+      {\n+\tif (flags[i] & (EAF_UNUSED | EAF_DIRECT))\n+\t  return true;\n+      }\n+    else\n+      {\n+\tif (flags[i])\n+\t  return true;\n+      }\n+  return false;\n+}\n+\n+/* Return true if summary is potentially useful for optimization.\n+   If CHECK_FLAGS is false assume that arg_flags are useful.  */\n \n bool\n-modref_summary::useful_p (int ecf_flags)\n+modref_summary::useful_p (int ecf_flags, bool check_flags)\n {\n   if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n     return false;\n-  if (arg_flags.length ())\n+  if (arg_flags.length () && !check_flags)\n     return true;\n+  if (check_flags && eaf_flags_useful_p (arg_flags, ecf_flags))\n+    return true;\n+  arg_flags.release ();\n   if (loads && !loads->every_base)\n     return true;\n   if (ecf_flags & ECF_PURE)\n@@ -215,12 +323,13 @@ struct GTY(()) modref_summary_lto\n      more verbose and thus more likely to hit the limits.  */\n   modref_records_lto *loads;\n   modref_records_lto *stores;\n+  auto_vec<unsigned char> GTY((skip)) arg_flags;\n   bool writes_errno;\n \n   modref_summary_lto ();\n   ~modref_summary_lto ();\n   void dump (FILE *);\n-  bool useful_p (int ecf_flags);\n+  bool useful_p (int ecf_flags, bool check_flags = true);\n };\n \n /* Summary for a single function which this pass produces.  */\n@@ -239,13 +348,19 @@ modref_summary_lto::~modref_summary_lto ()\n }\n \n \n-/* Return true if lto summary is potentially useful for optimization.  */\n+/* Return true if lto summary is potentially useful for optimization.\n+   If CHECK_FLAGS is false assume that arg_flags are useful.  */\n \n bool\n-modref_summary_lto::useful_p (int ecf_flags)\n+modref_summary_lto::useful_p (int ecf_flags, bool check_flags)\n {\n   if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n     return false;\n+  if (arg_flags.length () && !check_flags)\n+    return true;\n+  if (check_flags && eaf_flags_useful_p (arg_flags, ecf_flags))\n+    return true;\n+  arg_flags.release ();\n   if (loads && !loads->every_base)\n     return true;\n   if (ecf_flags & ECF_PURE)\n@@ -366,20 +481,62 @@ dump_lto_records (modref_records_lto *tt, FILE *out)\n     }\n }\n \n-/* Dump EAF flags.  */\n+/* Dump all escape points of NODE to OUT.  */\n \n static void\n-dump_eaf_flags (FILE *out, int flags)\n+dump_modref_edge_summaries (FILE *out, cgraph_node *node, int depth)\n {\n-  if (flags & EAF_DIRECT)\n-    fprintf (out, \" direct\");\n-  if (flags & EAF_NOCLOBBER)\n-    fprintf (out, \" noclobber\");\n-  if (flags & EAF_NOESCAPE)\n-    fprintf (out, \" noescape\");\n-  if (flags & EAF_UNUSED)\n-    fprintf (out, \" unused\");\n-  fprintf (out, \"\\n\");\n+  int i = 0;\n+  if (!escape_summaries)\n+    return;\n+  for (cgraph_edge *e = node->indirect_calls; e; e = e->next_callee)\n+    {\n+      class escape_summary *sum = escape_summaries->get (e);\n+      if (sum)\n+\t{\n+\t  fprintf (out, \"%*sIndirect call %i in %s escapes:\",\n+\t\t   depth, \"\", i, node->dump_name ());\n+\t  sum->dump (out);\n+\t}\n+      i++;\n+    }\n+  for (cgraph_edge *e = node->callees; e; e = e->next_callee)\n+    {\n+      if (!e->inline_failed)\n+\tdump_modref_edge_summaries (out, e->callee, depth + 1);\n+      class escape_summary *sum = escape_summaries->get (e);\n+      if (sum)\n+\t{\n+\t  fprintf (out, \"%*sCall %s->%s escapes:\", depth, \"\",\n+\t\t   node->dump_name (), e->callee->dump_name ());\n+\t  sum->dump (out);\n+\t}\n+      class fnspec_summary *fsum = fnspec_summaries->get (e);\n+      if (fsum)\n+\t{\n+\t  fprintf (out, \"%*sCall %s->%s fnspec: %s\\n\", depth, \"\",\n+\t\t   node->dump_name (), e->callee->dump_name (),\n+\t\t   fsum->fnspec);\n+\t}\n+    }\n+}\n+\n+/* Remove all call edge summaries associated with NODE.  */\n+\n+static void\n+remove_modref_edge_summaries (cgraph_node *node)\n+{\n+  if (!escape_summaries)\n+    return;\n+  for (cgraph_edge *e = node->indirect_calls; e; e = e->next_callee)\n+    escape_summaries->remove (e);\n+  for (cgraph_edge *e = node->callees; e; e = e->next_callee)\n+    {\n+      if (!e->inline_failed)\n+\tremove_modref_edge_summaries (e->callee);\n+      escape_summaries->remove (e);\n+      fnspec_summaries->remove (e);\n+    }\n }\n \n /* Dump summary.  */\n@@ -421,6 +578,15 @@ modref_summary_lto::dump (FILE *out)\n   dump_lto_records (stores, out);\n   if (writes_errno)\n     fprintf (out, \"  Writes errno\\n\");\n+  if (arg_flags.length ())\n+    {\n+      for (unsigned int i = 0; i < arg_flags.length (); i++)\n+\tif (arg_flags[i])\n+\t  {\n+\t    fprintf (out, \"  parm %i flags:\", i);\n+\t    dump_eaf_flags (out, arg_flags[i]);\n+\t  }\n+    }\n }\n \n /* Get function summary for FUNC if it exists, return NULL otherwise.  */\n@@ -591,12 +757,23 @@ record_access_p (tree expr)\n   return true;\n }\n \n+/* Return true if ECF flags says that return value can be ignored.  */\n+\n+static bool\n+ignore_retval_p (tree caller, int flags)\n+{\n+  if ((flags & (ECF_NORETURN | ECF_NOTHROW)) == (ECF_NORETURN | ECF_NOTHROW)\n+      || (!opt_for_fn (caller, flag_exceptions) && (flags & ECF_NORETURN)))\n+    return true;\n+  return false;\n+}\n+\n /* Return true if ECF flags says that stores can be ignored.  */\n \n static bool\n ignore_stores_p (tree caller, int flags)\n {\n-  if (flags & ECF_PURE)\n+  if (flags & (ECF_PURE | ECF_CONST | ECF_NOVOPS))\n     return true;\n   if ((flags & (ECF_NORETURN | ECF_NOTHROW)) == (ECF_NORETURN | ECF_NOTHROW)\n       || (!opt_for_fn (caller, flag_exceptions) && (flags & ECF_NORETURN)))\n@@ -1098,6 +1275,7 @@ remove_summary (bool lto, bool nolto, bool ipa)\n \tsummaries->remove (fnode);\n       if (lto)\n \tsummaries_lto->remove (fnode);\n+      remove_modref_edge_summaries (fnode);\n     }\n   if (dump_file)\n     fprintf (dump_file,\n@@ -1138,69 +1316,270 @@ deref_flags (int flags, bool ignore_stores)\n   return ret;\n }\n \n+namespace {\n+\n+/* Description of an escape point.  */\n+\n+struct escape_point\n+{\n+  /* Value escapes to this call.  */\n+  gcall *call;\n+  /* Argument it escapes to.  */\n+  int arg;\n+  /* Flags already known about the argument (this can save us from recording\n+     esape points if local analysis did good job already).  */\n+  char min_flags;\n+  /* Does value escape directly or indiretly?  */\n+  bool direct;\n+};\n+\n+class modref_lattice\n+{\n+public:\n+  /* EAF flags of the SSA name.  */\n+  int flags;\n+  /* DFS bookkkeeping: we don't do real dataflow yet.  */\n+  bool known;\n+  bool open;\n+\n+  /* When doing IPA analysis we can not merge in callee escape points;\n+     Only remember them and do the merging at IPA propagation time.  */\n+  vec <escape_point, va_heap, vl_ptr> escape_points;\n+\n+  void init ();\n+  void release ();\n+  bool merge (const modref_lattice &with);\n+  bool merge (int flags);\n+  bool merge_deref (const modref_lattice &with, bool ignore_stores);\n+  bool merge_direct_load ();\n+  bool merge_direct_store ();\n+  bool add_escape_point (gcall *call, int arg, int min_flags, bool diret);\n+  void dump (FILE *out, int indent = 0) const;\n+};\n+\n+/* Lattices are saved to vectors, so keep them PODs.  */\n+void\n+modref_lattice::init ()\n+{\n+  flags = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE | EAF_UNUSED;\n+  open = true;\n+  known = false;\n+}\n+\n+/* Release memory.  */\n+void\n+modref_lattice::release ()\n+{\n+  escape_points.release ();\n+}\n+\n+/* Dump lattice to OUT; indent with INDENT spaces.  */\n+\n+void\n+modref_lattice::dump (FILE *out, int indent) const\n+{\n+  dump_eaf_flags (out, flags);\n+  if (escape_points.length ())\n+    {\n+      fprintf (out, \"%*sEscapes:\\n\", indent, \"\");\n+      for (unsigned int i = 0; i < escape_points.length (); i++)\n+\t{\n+\t  fprintf (out, \"%*s  Arg %i (%s) min flags\", indent, \"\",\n+\t\t   escape_points[i].arg,\n+\t\t   escape_points[i].direct ? \"direct\" : \"indirect\");\n+\t  dump_eaf_flags (out, flags, false);\n+\t  fprintf (out, \" in call \");\n+\t  print_gimple_stmt (out, escape_points[i].call, 0);\n+\t}\n+    }\n+}\n+\n+/* Add escape point CALL, ARG, MIN_FLAGS, DIRECT.  Return false if such escape\n+   point exists.  */\n+\n+bool\n+modref_lattice::add_escape_point (gcall *call, int arg, int min_flags,\n+\t\t\t\t  bool direct)\n+{\n+  escape_point *ep;\n+  unsigned int i;\n+\n+  /* If we already determined flags to be bad enough,\n+   * we do not need to record.  */\n+  if ((flags & min_flags) == flags)\n+    return false;\n+\n+  FOR_EACH_VEC_ELT (escape_points, i, ep)\n+    if (ep->call == call && ep->arg == arg && ep->direct == direct)\n+      {\n+\tif ((ep->min_flags & min_flags) == min_flags)\n+\t  return false;\n+\tep->min_flags &= min_flags;\n+\treturn true;\n+      }\n+  /* Give up if max escape points is met.  */\n+  if ((int)escape_points.length () > param_modref_max_escape_points)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"--param modref-max-escape-points limit reached\\n\");\n+      merge (0);\n+      return true;\n+    }\n+  escape_point new_ep = {call, arg, min_flags, direct};\n+  escape_points.safe_push (new_ep);\n+  return true;\n+}\n+\n+/* Merge in flags from F.  */\n+bool\n+modref_lattice::merge (int f)\n+{\n+  if ((flags & f) != flags)\n+    {\n+      flags &= f;\n+      /* Only NOCLOBBER or DIRECT flags alone are not useful (see comments\n+\t in tree-ssa-alias.c).  Give up earlier.  */\n+      if ((flags & ~(EAF_DIRECT | EAF_NOCLOBBER)) == 0)\n+\tflags = 0;\n+      if (!flags)\n+\tescape_points.release ();\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Merge in WITH.  Return true if anyting changed.  */\n+\n+bool\n+modref_lattice::merge (const modref_lattice &with)\n+{\n+  if (!with.known)\n+    return merge (0);\n+\n+  bool changed = merge (with.flags);\n+\n+  if (!flags)\n+    return changed;\n+  for (unsigned int i = 0; i < with.escape_points.length (); i++)\n+    changed |= add_escape_point (with.escape_points[i].call,\n+\t\t\t\t with.escape_points[i].arg,\n+\t\t\t\t with.escape_points[i].min_flags,\n+\t\t\t\t with.escape_points[i].direct);\n+  return changed;\n+}\n+\n+/* Merge in deref of WITH.  If IGNORE_STORES is true do not consider\n+   stores.  Return true if anyting changed.  */\n+\n+bool\n+modref_lattice::merge_deref (const modref_lattice &with, bool ignore_stores)\n+{\n+  if (!with.known)\n+    return merge (0);\n+\n+  bool changed = merge (deref_flags (with.flags, ignore_stores));\n+\n+  if (!flags)\n+    return changed;\n+  for (unsigned int i = 0; i < with.escape_points.length (); i++)\n+    changed |= add_escape_point (with.escape_points[i].call,\n+\t\t\t\t with.escape_points[i].arg,\n+\t\t\t\t with.escape_points[i].min_flags,\n+\t\t\t\t false);\n+  return changed;\n+}\n+\n+/* Merge in flags for direct load.  */\n+\n+bool\n+modref_lattice::merge_direct_load ()\n+{\n+  return merge (~EAF_UNUSED);\n+}\n+\n+/* Merge in flags for direct store.  */\n+\n+bool\n+modref_lattice::merge_direct_store ()\n+{\n+  return merge (~(EAF_UNUSED | EAF_NOCLOBBER));\n+}\n+\n+}  /* ANON namespace.  */\n+\n+static void analyze_ssa_name_flags (tree name,\n+\t\t\t\t    vec<modref_lattice> &lattice,\n+\t\t\t\t    int depth, bool ipa);\n+\n /* Call statements may return their parameters.  Consider argument number\n    ARG of USE_STMT and determine flags that can needs to be cleared\n    in case pointer possibly indirectly references from ARG I is returned.\n-   KNOWN_FLAGS and DEPTH are same as in analyze_ssa_name_flags.  */\n+   LATTICE, DEPTH and ipa are same as in analyze_ssa_name_flags.  */\n \n-static int\n-call_lhs_flags (gcall *call, int arg,\n-\t\tvec<unsigned char> &known_flags, int depth)\n+static void\n+merge_call_lhs_flags (gcall *call, int arg, int index, bool deref,\n+\t\t      vec<modref_lattice> &lattice,\n+\t\t      int depth, bool ipa)\n {\n   /* If there is no return value, no flags are affected.  */\n   if (!gimple_call_lhs (call))\n-    return EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE | EAF_UNUSED;\n+    return;\n \n   /* If we know that function returns given argument and it is not ARG\n      we can still be happy.  */\n   int flags = gimple_call_return_flags (call);\n   if ((flags & ERF_RETURNS_ARG)\n       && (flags & ERF_RETURN_ARG_MASK) != arg)\n-    return EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE | EAF_UNUSED;\n+    return;\n \n   /* If return value is SSA name determine its flags.  */\n   if (TREE_CODE (gimple_call_lhs (call)) == SSA_NAME)\n-    return analyze_ssa_name_flags\n-\t\t       (gimple_call_lhs (call), known_flags,\n-\t\t\tdepth + 1);\n+    {\n+      tree lhs = gimple_call_lhs (call);\n+      analyze_ssa_name_flags (lhs, lattice, depth + 1, ipa);\n+      if (deref)\n+\tlattice[index].merge (lattice[SSA_NAME_VERSION (lhs)]);\n+      else\n+\tlattice[index].merge_deref (lattice[SSA_NAME_VERSION (lhs)], false);\n+    }\n   /* In the case of memory store we can do nothing.  */\n   else\n-    return 0;\n+    lattice[index].merge (0);\n }\n \n-/* Analyze EAF flags for SSA name NAME.\n-   KNOWN_FLAGS is a cache for flags we already determined.\n-   DEPTH is a recursion depth used to make debug output prettier.  */\n+/* Analyze EAF flags for SSA name NAME and store result to LATTICE.\n+   LATTICE is an array of modref_lattices.\n+   DEPTH is a recursion depth used to make debug output prettier.\n+   If IPA is true we analyze for IPA propagation (and thus call escape points\n+   are processed later)  */\n \n-static int\n-analyze_ssa_name_flags (tree name, vec<unsigned char> &known_flags, int depth)\n+static void\n+analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n+\t\t\tbool ipa)\n {\n   imm_use_iterator ui;\n   gimple *use_stmt;\n-  int flags = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE | EAF_UNUSED;\n+  int index = SSA_NAME_VERSION (name);\n \n   /* See if value is already computed.  */\n-  if (known_flags[SSA_NAME_VERSION (name)])\n+  if (lattice[index].known)\n+   return;\n+  if (lattice[index].open)\n     {\n-      /* Punt on cycles for now, so we do not need dataflow.  */\n-      if (known_flags[SSA_NAME_VERSION (name)] == 1)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"%*sGiving up on a cycle in SSA graph\\n\", depth * 4, \"\");\n-\t  return 0;\n-\t}\n-      return known_flags[SSA_NAME_VERSION (name)] - 2;\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"%*sGiving up on a cycle in SSA graph\\n\", depth * 4, \"\");\n+      return;\n     }\n   if (depth == param_modref_max_depth)\n     {\n       if (dump_file)\n \tfprintf (dump_file,\n \t\t \"%*sGiving up on max depth\\n\", depth * 4, \"\");\n-      return 0;\n+      return;\n     }\n   /* Recursion guard.  */\n-  known_flags[SSA_NAME_VERSION (name)] = 1;\n+  lattice[index].init ();\n \n   if (dump_file)\n     {\n@@ -1212,7 +1591,7 @@ analyze_ssa_name_flags (tree name, vec<unsigned char> &known_flags, int depth)\n \n   FOR_EACH_IMM_USE_STMT (use_stmt, ui, name)\n     {\n-      if (flags == 0)\n+      if (lattice[index].flags == 0)\n \t{\n \t  BREAK_FROM_IMM_USE_STMT (ui);\n \t}\n@@ -1228,95 +1607,109 @@ analyze_ssa_name_flags (tree name, vec<unsigned char> &known_flags, int depth)\n \t Returning name counts as an use by tree-ssa-structalias.c  */\n       if (greturn *ret = dyn_cast <greturn *> (use_stmt))\n \t{\n-\t  if (memory_access_to (gimple_return_retval (ret), name)\n-\t      || name == gimple_return_retval (ret))\n-\t    flags &= ~EAF_UNUSED;\n+\t  if (gimple_return_retval (ret) == name)\n+\t    lattice[index].merge (~EAF_UNUSED);\n+\t  else if (memory_access_to (gimple_return_retval (ret), name))\n+\t    lattice[index].merge_direct_load ();\n \t}\n       /* Account for LHS store, arg loads and flags from callee function.  */\n       else if (gcall *call = dyn_cast <gcall *> (use_stmt))\n \t{\n \t  tree callee = gimple_call_fndecl (call);\n \n \t  /* Recursion would require bit of propagation; give up for now.  */\n-\t  if (callee && recursive_call_p (current_function_decl, callee))\n-\t    flags = 0;\n+\t  if (callee && !ipa && recursive_call_p (current_function_decl,\n+\t\t\t\t\t\t  callee))\n+\t    lattice[index].merge (0);\n \t  else\n \t    {\n \t      int ecf_flags = gimple_call_flags (call);\n \t      bool ignore_stores = ignore_stores_p (current_function_decl,\n \t\t\t\t\t\t    ecf_flags);\n+\t      bool ignore_retval = ignore_retval_p (current_function_decl,\n+\t\t\t\t\t\t    ecf_flags);\n \n \t      /* Handle *name = func (...).  */\n \t      if (gimple_call_lhs (call)\n \t\t  && memory_access_to (gimple_call_lhs (call), name))\n-\t\tflags &= ~(EAF_UNUSED | EAF_NOCLOBBER);\n+\t\tlattice[index].merge_direct_store ();\n \n \t      /* We do not track accesses to the static chain (we could)\n \t\t so give up.  */\n \t      if (gimple_call_chain (call)\n \t\t  && (gimple_call_chain (call) == name))\n-\t\tflags = 0;\n+\t\tlattice[index].merge (0);\n+\n+\t      /* Process internal functions and right away.  */\n+\t      bool record_ipa = ipa && !gimple_call_internal_p (call);\n \n \t      /* Handle all function parameters.  */\n-\t      for (unsigned i = 0; i < gimple_call_num_args (call); i++)\n+\t      for (unsigned i = 0;\n+\t\t   i < gimple_call_num_args (call) && lattice[index].flags; i++)\n \t\t/* Name is directly passed to the callee.  */\n \t\tif (gimple_call_arg (call, i) == name)\n \t\t  {\n-\t\t    if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n-\t\t      flags &= ignore_stores\n-\t\t\t       ? 0\n-\t\t\t       : call_lhs_flags (call, i, known_flags, depth);\n-\t\t    else\n+\t\t    if (!(ecf_flags & (ECF_CONST | ECF_NOVOPS)))\n \t\t      {\n \t\t\tint call_flags = gimple_call_arg_flags (call, i);\n \t\t\tif (ignore_stores)\n \t\t\t  call_flags |= EAF_NOCLOBBER | EAF_NOESCAPE;\n-\t\t\telse\n-\t\t\t  call_flags &= call_lhs_flags (call, i,\n-\t\t\t\t\t\t\tknown_flags, depth);\n \n-\t\t\tflags &= call_flags;\n+\t\t\tif (!record_ipa)\n+\t\t\t  lattice[index].merge (call_flags);\n+\t\t\tif (record_ipa)\n+\t\t\t  lattice[index].add_escape_point (call, i,\n+\t\t\t     \t\t\t\t   call_flags, true);\n \t\t      }\n+\t\t    if (!ignore_retval)\n+\t\t      merge_call_lhs_flags (call, i, index, false,\n+\t\t\t\t\t    lattice, depth, ipa);\n \t\t  }\n \t\t/* Name is dereferenced and passed to a callee.  */\n \t\telse if (memory_access_to (gimple_call_arg (call, i), name))\n \t\t  {\n \t\t    if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n-\t\t      flags &= ~EAF_UNUSED;\n+\t\t      lattice[index].merge_direct_load ();\n \t\t    else\n-\t\t      flags &= deref_flags (gimple_call_arg_flags (call, i),\n-\t\t\t\t\t    ignore_stores);\n-\t\t    if (!ignore_stores)\n-\t\t      flags &= call_lhs_flags (call, i, known_flags, depth);\n+\t\t      {\n+\t\t\tint call_flags = deref_flags\n+\t\t\t   (gimple_call_arg_flags (call, i), ignore_stores);\n+\t\t\tif (!record_ipa)\n+\t\t\t    lattice[index].merge (call_flags);\n+\t\t\tif (record_ipa)\n+\t\t\t  lattice[index].add_escape_point (call, i,\n+\t\t\t\t\t\t\t   call_flags, false);\n+\t\t      }\n+\t\t    if (!ignore_retval)\n+\t\t      merge_call_lhs_flags (call, i, index, true,\n+\t\t\t\t\t    lattice, depth, ipa);\n \t\t  }\n \t    }\n-\t  /* Only NOCLOBBER or DIRECT flags alone are not useful (see comments\n-\t     in tree-ssa-alias.c).  Give up earlier.  */\n-\t  if ((flags & ~(EAF_DIRECT | EAF_NOCLOBBER)) == 0)\n-\t    flags = 0;\n \t}\n       else if (gimple_assign_load_p (use_stmt))\n \t{\n \t  gassign *assign = as_a <gassign *> (use_stmt);\n \t  /* Memory to memory copy.  */\n \t  if (gimple_store_p (assign))\n \t    {\n-\t      /* Handle *name = *exp.  */\n-\t      if (memory_access_to (gimple_assign_lhs (assign), name))\n-\t\tflags &= ~(EAF_UNUSED | EAF_NOCLOBBER);\n-\n \t      /* Handle *lhs = *name.\n \n \t\t We do not track memory locations, so assume that value\n \t\t is used arbitrarily.  */\n \t      if (memory_access_to (gimple_assign_rhs1 (assign), name))\n-\t\tflags = 0;\n+\t\tlattice[index].merge (0);\n+\t      /* Handle *name = *exp.  */\n+\t      else if (memory_access_to (gimple_assign_lhs (assign), name))\n+\t\tlattice[index].merge_direct_store ();\n \t    }\n \t  /* Handle lhs = *name.  */\n \t  else if (memory_access_to (gimple_assign_rhs1 (assign), name))\n-\t    flags &= deref_flags (analyze_ssa_name_flags\n-\t\t\t\t      (gimple_assign_lhs (assign),\n-\t\t\t\t       known_flags, depth + 1), false);\n+\t    {\n+\t      tree lhs = gimple_assign_lhs (assign);\n+\t      analyze_ssa_name_flags (lhs, lattice, depth + 1, ipa);\n+\t      lattice[index].merge_deref (lattice[SSA_NAME_VERSION (lhs)],\n+\t\t\t\t\t  false);\n+\t    }\n \t}\n       else if (gimple_store_p (use_stmt))\n \t{\n@@ -1328,7 +1721,7 @@ analyze_ssa_name_flags (tree name, vec<unsigned char> &known_flags, int depth)\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"%*s  ssa name saved to memory\\n\",\n \t\t\t depth * 4, \"\");\n-\t      flags = 0;\n+\t      lattice[index].merge (0);\n \t    }\n \t  /* Handle *name = exp.  */\n \t  else if (assign\n@@ -1339,15 +1732,15 @@ analyze_ssa_name_flags (tree name, vec<unsigned char> &known_flags, int depth)\n \t\t do because local optimization passes do not consider clobbers\n \t\t from other functions.  Similar logic is in ipa-pure-const.c.  */\n \t      if (!cfun->after_inlining || !gimple_clobber_p (assign))\n-\t\tflags &= ~(EAF_UNUSED | EAF_NOCLOBBER);\n+\t\tlattice[index].merge_direct_store ();\n \t    }\n \t  /* ASM statements etc.  */\n \t  else if (!assign)\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"%*s  Unhandled store\\n\",\n \t\t\t depth * 4, \"\");\n-\t      flags = 0;\n+\t      lattice[index].merge (0);\n \t    }\n \t}\n       else if (gassign *assign = dyn_cast <gassign *> (use_stmt))\n@@ -1360,15 +1753,17 @@ analyze_ssa_name_flags (tree name, vec<unsigned char> &known_flags, int depth)\n \t      && code != POINTER_DIFF_EXPR\n \t      && (code != POINTER_PLUS_EXPR\n \t\t  || gimple_assign_rhs1 (assign) == name))\n-\t    flags &= analyze_ssa_name_flags\n-\t\t\t       (gimple_assign_lhs (assign), known_flags,\n-\t\t\t\tdepth + 1);\n+\t    {\n+\t      tree lhs = gimple_assign_lhs (assign);\n+\t      analyze_ssa_name_flags (lhs, lattice, depth + 1, ipa);\n+\t      lattice[index].merge (lattice[SSA_NAME_VERSION (lhs)]);\n+\t    }\n \t}\n       else if (gphi *phi = dyn_cast <gphi *> (use_stmt))\n \t{\n-\t  flags &= analyze_ssa_name_flags\n-\t\t\t     (gimple_phi_result (phi), known_flags,\n-\t\t\t      depth + 1);\n+\t  tree result = gimple_phi_result (phi);\n+\t  analyze_ssa_name_flags (result, lattice, depth + 1, ipa);\n+\t  lattice[index].merge (lattice[SSA_NAME_VERSION (result)]);\n \t}\n       /* Conditions are not considered escape points\n \t by tree-ssa-structalias.  */\n@@ -1378,33 +1773,39 @@ analyze_ssa_name_flags (tree name, vec<unsigned char> &known_flags, int depth)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"%*s  Unhandled stmt\\n\", depth * 4, \"\");\n-\t  flags = 0;\n+\t  lattice[index].merge (0);\n \t}\n \n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"%*s  current flags of \", depth * 4, \"\");\n \t  print_generic_expr (dump_file, name);\n-\t  dump_eaf_flags (dump_file, flags);\n+\t  lattice[index].dump (dump_file, depth * 4 + 4);\n \t}\n     }\n   if (dump_file)\n     {\n       fprintf (dump_file, \"%*sflags of ssa name \", depth * 4, \"\");\n       print_generic_expr (dump_file, name);\n-      dump_eaf_flags (dump_file, flags);\n+      lattice[index].dump (dump_file, depth * 4 + 2);\n     }\n-  known_flags[SSA_NAME_VERSION (name)] = flags + 2;\n-  return flags;\n+  lattice[index].open = false;\n+  lattice[index].known = true;\n }\n \n /* Determine EAF flags for function parameters.  */\n \n static void\n-analyze_parms (modref_summary *summary)\n+analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n+\t       bool ipa)\n {\n   unsigned int parm_index = 0;\n   unsigned int count = 0;\n+  int ecf_flags = flags_from_decl_or_type (current_function_decl);\n+\n+  /* For const functions we have nothing to gain by EAF flags.  */\n+  if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n+    return;\n \n   for (tree parm = DECL_ARGUMENTS (current_function_decl); parm;\n        parm = TREE_CHAIN (parm))\n@@ -1413,24 +1814,60 @@ analyze_parms (modref_summary *summary)\n   if (!count)\n     return;\n \n-  auto_vec<unsigned char> known_flags;\n-  known_flags.safe_grow_cleared (num_ssa_names, true);\n+  auto_vec<modref_lattice> lattice;\n+  lattice.safe_grow_cleared (num_ssa_names, true);\n \n   for (tree parm = DECL_ARGUMENTS (current_function_decl); parm; parm_index++,\n        parm = TREE_CHAIN (parm))\n     {\n       tree name = ssa_default_def (cfun, parm);\n       if (!name)\n \tcontinue;\n-      int flags = analyze_ssa_name_flags (name, known_flags, 0);\n+      analyze_ssa_name_flags (name, lattice, 0, ipa);\n+      int flags = lattice[SSA_NAME_VERSION (name)].flags;\n+\n+      /* For pure functions we have implicit NOCLOBBER\n+\t and NOESCAPE.  */\n+      if (ecf_flags & ECF_PURE)\n+\tflags &= ~(EAF_NOCLOBBER | EAF_NOESCAPE);\n \n       if (flags)\n \t{\n-\t  if (parm_index >= summary->arg_flags.length ())\n-\t    summary->arg_flags.safe_grow_cleared (count, true);\n-\t  summary->arg_flags[parm_index] = flags;\n+\t  if (summary)\n+\t    {\n+\t      if (parm_index >= summary->arg_flags.length ())\n+\t\tsummary->arg_flags.safe_grow_cleared (count, true);\n+\t      summary->arg_flags[parm_index] = flags;\n+\t    }\n+\t  else if (summary_lto)\n+\t    {\n+\t      if (parm_index >= summary_lto->arg_flags.length ())\n+\t\tsummary_lto->arg_flags.safe_grow_cleared (count, true);\n+\t      summary_lto->arg_flags[parm_index] = flags;\n+\t    }\n+\t  if (lattice[SSA_NAME_VERSION (name)].escape_points.length ())\n+\t    {\n+\t      escape_point *ep;\n+\t      unsigned int ip;\n+\t      cgraph_node *node = cgraph_node::get (current_function_decl);\n+\n+\t      gcc_checking_assert (ipa);\n+\t      FOR_EACH_VEC_ELT\n+\t\t  (lattice[SSA_NAME_VERSION (name)].escape_points, ip, ep)\n+\t\tif ((ep->min_flags & flags) != flags)\n+\t\t  {\n+\t\t    cgraph_edge *e = node->get_edge (ep->call);\n+\t\t    struct escape_entry ee = {parm_index, ep->arg,\n+\t\t     \t\t\t      ep->min_flags, ep->direct};\n+\n+\t\t    escape_summaries->get_create (e)->esc.safe_push (ee);\n+\t\t  }\n+\t    }\n \t}\n     }\n+  if (ipa)\n+    for (unsigned int i = 0; i < num_ssa_names; i++)\n+      lattice[i].release ();\n }\n \n /* Analyze function F.  IPA indicates whether we're running in local mode\n@@ -1508,6 +1945,8 @@ analyze_function (function *f, bool ipa)\n \t}\n       if (!fnspec_summaries)\n \tfnspec_summaries = new fnspec_summaries_t (symtab);\n+      if (!escape_summaries)\n+\tescape_summaries = new escape_summaries_t (symtab);\n      }\n \n \n@@ -1541,8 +1980,7 @@ analyze_function (function *f, bool ipa)\n       summary_lto->writes_errno = false;\n     }\n \n-  if (!ipa)\n-    analyze_parms (summary);\n+  analyze_parms (summary, summary_lto, ipa);\n \n   int ecf_flags = flags_from_decl_or_type (current_function_decl);\n   auto_vec <gimple *, 32> recursive_calls;\n@@ -1558,8 +1996,9 @@ analyze_function (function *f, bool ipa)\n \t{\n \t  if (!analyze_stmt (summary, summary_lto,\n \t\t\t     gsi_stmt (si), ipa, &recursive_calls)\n-\t      || ((!summary || !summary->useful_p (ecf_flags))\n-\t\t  && (!summary_lto || !summary_lto->useful_p (ecf_flags))))\n+\t      || ((!summary || !summary->useful_p (ecf_flags, false))\n+\t\t  && (!summary_lto\n+\t\t      || !summary_lto->useful_p (ecf_flags, false))))\n \t    {\n \t      collapse_loads (summary, summary_lto);\n \t      collapse_stores (summary, summary_lto);\n@@ -1584,7 +2023,7 @@ analyze_function (function *f, bool ipa)\n \t\t\t\t\t    gimple_call_flags\n \t\t\t\t\t\t (recursive_calls[i])),\n \t\t\t   fnode);\n-\t      if (!summary->useful_p (ecf_flags))\n+\t      if (!summary->useful_p (ecf_flags, false))\n \t\t{\n \t\t  remove_summary (lto, nolto, ipa);\n \t\t  return;\n@@ -1605,6 +2044,8 @@ analyze_function (function *f, bool ipa)\n       summaries_lto->remove (fnode);\n       summary_lto = NULL;\n     }\n+  if (ipa && !summary && !summary_lto)\n+    remove_modref_edge_summaries (fnode);\n \n   if (dump_file)\n     {\n@@ -1613,6 +2054,7 @@ analyze_function (function *f, bool ipa)\n \tsummary->dump (dump_file);\n       if (summary_lto)\n \tsummary_lto->dump (dump_file);\n+      dump_modref_edge_summaries (dump_file, fnode, 2);\n     }\n }\n \n@@ -1947,6 +2389,49 @@ read_modref_records (lto_input_block *ib, struct data_in *data_in,\n     (*nolto_ret)->cleanup ();\n }\n \n+/* Write ESUM to BP.  */\n+\n+static void\n+modref_write_escape_summary (struct bitpack_d *bp, escape_summary *esum)\n+{\n+  if (!esum)\n+    {\n+      bp_pack_var_len_unsigned (bp, 0);\n+      return;\n+    }\n+  bp_pack_var_len_unsigned (bp, esum->esc.length ());\n+  unsigned int i;\n+  escape_entry *ee;\n+  FOR_EACH_VEC_ELT (esum->esc, i, ee)\n+    {\n+      bp_pack_var_len_unsigned (bp, ee->parm_index);\n+      bp_pack_var_len_unsigned (bp, ee->arg);\n+      bp_pack_var_len_unsigned (bp, ee->min_flags);\n+      bp_pack_value (bp, ee->direct, 1);\n+    }\n+}\n+\n+/* Read escape summary for E from BP.  */\n+\n+static void\n+modref_read_escape_summary (struct bitpack_d *bp, cgraph_edge *e)\n+{\n+  unsigned int n = bp_unpack_var_len_unsigned (bp);\n+  if (!n)\n+    return;\n+  escape_summary *esum = escape_summaries->get_create (e);\n+  esum->esc.reserve_exact (n);\n+  for (unsigned int i = 0; i < n; i++)\n+    {\n+      escape_entry ee;\n+      ee.parm_index = bp_unpack_var_len_unsigned (bp);\n+      ee.arg = bp_unpack_var_len_unsigned (bp);\n+      ee.min_flags = bp_unpack_var_len_unsigned (bp);\n+      ee.direct = bp_unpack_value (bp, 1);\n+      esum->esc.quick_push (ee);\n+    }\n+}\n+\n /* Callback for write_summary.  */\n \n static void\n@@ -1993,6 +2478,10 @@ modref_write ()\n \n \t  streamer_write_uhwi (ob, lto_symtab_encoder_encode (encoder, cnode));\n \n+\t  streamer_write_uhwi (ob, r->arg_flags.length ());\n+\t  for (unsigned int i = 0; i < r->arg_flags.length (); i++)\n+\t    streamer_write_char_stream (ob->main_stream, r->arg_flags[i]);\n+\n \t  write_modref_records (r->loads, ob);\n \t  write_modref_records (r->stores, ob);\n \n@@ -2007,13 +2496,17 @@ modref_write ()\n \t\t  bp_pack_value (&bp, sum != NULL, 1);\n \t\t  if (sum)\n \t\t    bp_pack_string (ob, &bp, sum->fnspec, true);\n+\t\t  class escape_summary *esum = escape_summaries->get (e);\n+\t\t  modref_write_escape_summary (&bp,esum);\n \t\t}\n \t      for (cgraph_edge *e = cnode->callees; e; e = e->next_callee)\n \t\t{\n \t\t  class fnspec_summary *sum = fnspec_summaries->get (e);\n \t\t  bp_pack_value (&bp, sum != NULL, 1);\n \t\t  if (sum)\n \t\t    bp_pack_string (ob, &bp, sum->fnspec, true);\n+\t\t  class escape_summary *esum = escape_summaries->get (e);\n+\t\t  modref_write_escape_summary (&bp,esum);\n \t\t}\n \t    }\n \t  streamer_write_bitpack (&bp);\n@@ -2071,6 +2564,19 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n \t\t\t\t  && !modref_sum->stores));\n       gcc_assert (!modref_sum_lto || (!modref_sum_lto->loads\n \t\t\t\t      && !modref_sum_lto->stores));\n+      unsigned int args = streamer_read_uhwi (&ib);\n+      if (args && modref_sum)\n+\tmodref_sum->arg_flags.reserve_exact (args);\n+      if (args && modref_sum_lto)\n+\tmodref_sum_lto->arg_flags.reserve_exact (args);\n+      for (unsigned int i = 0; i < args; i++)\n+\t{\n+\t  unsigned char flags = streamer_read_uchar (&ib);\n+\t  if (modref_sum)\n+\t    modref_sum->arg_flags.quick_push (flags);\n+\t  if (modref_sum_lto)\n+\t    modref_sum_lto->arg_flags.quick_push (flags);\n+\t}\n       read_modref_records (&ib, data_in,\n \t\t\t   modref_sum ? &modref_sum->loads : NULL,\n \t\t\t   modref_sum_lto ? &modref_sum_lto->loads : NULL);\n@@ -2094,6 +2600,7 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n \t\t  class fnspec_summary *sum = fnspec_summaries->get_create (e);\n \t\t  sum->fnspec = xstrdup (bp_unpack_string (data_in, &bp));\n \t\t}\n+\t      modref_read_escape_summary (&bp, e);\n \t    }\n \t  for (cgraph_edge *e = node->callees; e; e = e->next_callee)\n \t    {\n@@ -2102,6 +2609,7 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n \t\t  class fnspec_summary *sum = fnspec_summaries->get_create (e);\n \t\t  sum->fnspec = xstrdup (bp_unpack_string (data_in, &bp));\n \t\t}\n+\t      modref_read_escape_summary (&bp, e);\n \t    }\n \t}\n       if (dump_file)\n@@ -2112,6 +2620,7 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n \t    modref_sum->dump (dump_file);\n \t  if (modref_sum_lto)\n \t    modref_sum_lto->dump (dump_file);\n+\t  dump_modref_edge_summaries (dump_file, node, 4);\n \t}\n     }\n \n@@ -2142,6 +2651,8 @@ modref_read (void)\n \tsummaries = modref_summaries::create_ggc (symtab);\n       if (!fnspec_summaries)\n \tfnspec_summaries = new fnspec_summaries_t (symtab);\n+      if (!escape_summaries)\n+\tescape_summaries = new escape_summaries_t (symtab);\n     }\n \n   while ((file_data = file_data_vec[j++]))\n@@ -2161,6 +2672,34 @@ modref_read (void)\n     }\n }\n \n+/* Recompute arg_flags for param adjustments in INFO.  */\n+\n+static void\n+remap_arg_flags (auto_vec <unsigned char> &arg_flags, clone_info *info)\n+{\n+  auto_vec<unsigned char> old = arg_flags.copy ();\n+  int max = -1;\n+  size_t i;\n+  ipa_adjusted_param *p;\n+\n+  arg_flags.release ();\n+\n+  FOR_EACH_VEC_SAFE_ELT (info->param_adjustments->m_adj_params, i, p)\n+    {\n+      int o = info->param_adjustments->get_original_index (i);\n+      if (o >= 0 && (int)old.length () > o && old[o])\n+\tmax = i;\n+    }\n+  if (max > 0)\n+    arg_flags.safe_grow_cleared (max + 1, true);\n+  FOR_EACH_VEC_SAFE_ELT (info->param_adjustments->m_adj_params, i, p)\n+    {\n+      int o = info->param_adjustments->get_original_index (i);\n+      if (o >= 0 && (int)old.length () > o && old[o])\n+\targ_flags[i] = old[o];\n+    }\n+}\n+\n /* If signature changed, update the summary.  */\n \n static void\n@@ -2180,7 +2719,10 @@ update_signature (struct cgraph_node *node)\n     {\n       fprintf (dump_file, \"Updating summary for %s from:\\n\",\n \t       node->dump_name ());\n-      r->dump (dump_file);\n+      if (r)\n+\tr->dump (dump_file);\n+      if (r_lto)\n+\tr_lto->dump (dump_file);\n     }\n \n   size_t i, max = 0;\n@@ -2208,11 +2750,15 @@ update_signature (struct cgraph_node *node)\n     {\n       r->loads->remap_params (&map);\n       r->stores->remap_params (&map);\n+      if (r->arg_flags.length ())\n+\tremap_arg_flags (r->arg_flags, info);\n     }\n   if (r_lto)\n     {\n       r_lto->loads->remap_params (&map);\n       r_lto->stores->remap_params (&map);\n+      if (r_lto->arg_flags.length ())\n+\tremap_arg_flags (r_lto->arg_flags, info);\n     }\n   if (dump_file)\n     {\n@@ -2380,7 +2926,7 @@ compute_parm_map (cgraph_edge *callee_edge, vec<modref_parm_map> *parm_map)\n \t\t(!(ipa_get_jf_ancestor_offset (jf) & (BITS_PER_UNIT - 1)));\n \t      (*parm_map)[i].parm_offset\n \t\t = ipa_get_jf_ancestor_offset (jf) >> LOG2_BITS_PER_UNIT;\n- \t    }\n+\t    }\n \t  else\n \t    (*parm_map)[i].parm_index = -1;\n \t}\n@@ -2396,6 +2942,65 @@ compute_parm_map (cgraph_edge *callee_edge, vec<modref_parm_map> *parm_map)\n   return false;\n }\n \n+/* Map used to translate escape infos.  */\n+\n+struct escape_map\n+{\n+  int parm_index;\n+  bool direct;\n+};\n+\n+/* Update escape map fo E.  */\n+\n+static void\n+update_escape_summary_1 (cgraph_edge *e,\n+\t\t\t vec <vec <escape_map>> &map)\n+{\n+  escape_summary *sum = escape_summaries->get (e);\n+  if (!sum)\n+    return;\n+  auto_vec <escape_entry> old = sum->esc.copy ();\n+  sum->esc.release ();\n+\n+  unsigned int i;\n+  escape_entry *ee;\n+  FOR_EACH_VEC_ELT (old, i, ee)\n+    {\n+      unsigned int j;\n+      struct escape_map *em;\n+      if (ee->parm_index >= map.length ())\n+\tcontinue;\n+      FOR_EACH_VEC_ELT (map[ee->parm_index], j, em)\n+\t{\n+\t  struct escape_entry entry = {em->parm_index, ee->arg,\n+\t    \t\t\t       ee->min_flags,\n+\t\t\t\t       ee->direct & em->direct};\n+\t  sum->esc.safe_push (entry);\n+\t}\n+    }\n+  if (!sum->esc.length ())\n+    escape_summaries->remove (e);\n+}\n+\n+/* Update escape map fo NODE.  */\n+\n+static void\n+update_escape_summary (cgraph_node *node,\n+\t\t       vec <vec <escape_map>> &map)\n+{\n+  if (!escape_summaries)\n+    return;\n+  for (cgraph_edge *e = node->indirect_calls; e; e = e->next_callee)\n+    update_escape_summary_1 (e, map);\n+  for (cgraph_edge *e = node->callees; e; e = e->next_callee)\n+    {\n+      if (!e->inline_failed)\n+\tupdate_escape_summary (e->callee, map);\n+      else\n+\tupdate_escape_summary_1 (e, map);\n+    }\n+}\n+\n /* Call EDGE was inlined; merge summary from callee to the caller.  */\n \n void\n@@ -2416,6 +3021,7 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n \tsummaries->remove (edge->callee);\n       if (summaries_lto)\n \tsummaries_lto->remove (edge->callee);\n+      remove_modref_edge_summaries (edge->callee);\n       return;\n     }\n \n@@ -2424,45 +3030,104 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n   class modref_summary_lto *callee_info_lto\n \t\t = summaries_lto ? summaries_lto->get (edge->callee) : NULL;\n   int flags = flags_from_decl_or_type (edge->callee->decl);\n+  bool ignore_stores = ignore_stores_p (edge->caller->decl, flags);\n \n   if (!callee_info && to_info)\n     {\n-      if (ignore_stores_p (edge->caller->decl, flags))\n+      if (!(flags & (ECF_CONST | ECF_NOVOPS)))\n \tto_info->loads->collapse ();\n-      else\n-\t{\n-\t  summaries->remove (to);\n-\t  to_info = NULL;\n-\t}\n+      if (ignore_stores)\n+\tto_info->stores->collapse ();\n     }\n   if (!callee_info_lto && to_info_lto)\n     {\n-      if (ignore_stores_p (edge->caller->decl, flags))\n+      if (!(flags & (ECF_CONST | ECF_NOVOPS)))\n \tto_info_lto->loads->collapse ();\n-      else\n-\t{\n-\t  summaries_lto->remove (to);\n-\t  to_info_lto = NULL;\n-\t}\n+      if (ignore_stores)\n+\tto_info_lto->stores->collapse ();\n     }\n   if (callee_info || callee_info_lto)\n     {\n       auto_vec <modref_parm_map, 32> parm_map;\n \n       compute_parm_map (edge, &parm_map);\n \n-      if (!ignore_stores_p (edge->caller->decl, flags))\n+      if (!ignore_stores)\n \t{\n \t  if (to_info && callee_info)\n \t    to_info->stores->merge (callee_info->stores, &parm_map);\n \t  if (to_info_lto && callee_info_lto)\n \t    to_info_lto->stores->merge (callee_info_lto->stores, &parm_map);\n \t}\n-      if (to_info && callee_info)\n-\tto_info->loads->merge (callee_info->loads, &parm_map);\n-      if (to_info_lto && callee_info_lto)\n-\tto_info_lto->loads->merge (callee_info_lto->loads, &parm_map);\n+      if (!(flags & (ECF_CONST | ECF_NOVOPS)))\n+\t{\n+\t  if (to_info && callee_info)\n+\t    to_info->loads->merge (callee_info->loads, &parm_map);\n+\t  if (to_info_lto && callee_info_lto)\n+\t    to_info_lto->loads->merge (callee_info_lto->loads, &parm_map);\n+\t}\n     }\n+\n+  /* Now merge escape summaries.\n+     For every escape to the callee we need to merge calle flags\n+     and remap calees escapes.  */\n+  class escape_summary *sum = escape_summaries->get (edge);\n+  int max_escape = -1;\n+  escape_entry *ee;\n+  unsigned int i;\n+\n+  if (sum && !(flags & (ECF_CONST | ECF_NOVOPS)))\n+    FOR_EACH_VEC_ELT (sum->esc, i, ee)\n+      if ((int)ee->arg > max_escape)\n+\tmax_escape = ee->arg;\n+\n+  auto_vec <vec <struct escape_map>, 32> emap (max_escape + 1);\n+  emap.safe_grow (max_escape + 1, true);\n+  for (i = 0; (int)i < max_escape + 1; i++)\n+    emap[i] = vNULL;\n+\n+  if (sum && !(flags & (ECF_CONST | ECF_NOVOPS)))\n+    FOR_EACH_VEC_ELT (sum->esc, i, ee)\n+      {\n+\tbool needed = false;\n+\tif (to_info && to_info->arg_flags.length () > ee->parm_index)\n+\t  {\n+\t    int flags = callee_info\n+\t\t\t&& callee_info->arg_flags.length () > ee->arg\n+\t\t\t? callee_info->arg_flags[ee->arg] : 0;\n+\t    if (!ee->direct)\n+\t      flags = deref_flags (flags, ignore_stores);\n+\t    else if (ignore_stores)\n+\t      flags |= EAF_NOCLOBBER | EAF_NOESCAPE;\n+\t    flags |= ee->min_flags;\n+\t    to_info->arg_flags[ee->parm_index] &= flags;\n+\t    if (to_info->arg_flags[ee->parm_index])\n+\t      needed = true;\n+\t  }\n+\tif (to_info_lto && to_info_lto->arg_flags.length () > ee->parm_index)\n+\t  {\n+\t    int flags = callee_info_lto\n+\t\t\t&& callee_info_lto->arg_flags.length () > ee->arg\n+\t\t\t? callee_info_lto->arg_flags[ee->arg] : 0;\n+\t    if (!ee->direct)\n+\t      flags = deref_flags (flags, ignore_stores);\n+\t    else if (ignore_stores)\n+\t      flags |= EAF_NOCLOBBER | EAF_NOESCAPE;\n+\t    flags |= ee->min_flags;\n+\t    to_info_lto->arg_flags[ee->parm_index] &= flags;\n+\t    if (to_info_lto->arg_flags[ee->parm_index])\n+\t      needed = true;\n+\t  }\n+\tstruct escape_map entry = {ee->parm_index, ee->direct};\n+\tif (needed)\n+\t  emap[ee->arg].safe_push (entry);\n+      }\n+  update_escape_summary (edge->callee, emap);\n+  for (i = 0; (int)i < max_escape + 1; i++)\n+    emap[i].release ();\n+  if (sum)\n+    escape_summaries->remove (edge);\n+\n   if (summaries)\n     {\n       if (to_info && !to_info->useful_p (flags))\n@@ -2471,6 +3136,7 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n \t    fprintf (dump_file, \"Removed mod-ref summary for %s\\n\",\n \t\t     to->dump_name ());\n \t  summaries->remove (to);\n+\t  to_info = NULL;\n \t}\n       else if (to_info && dump_file)\n \t{\n@@ -2497,10 +3163,13 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n \t    fprintf (dump_file, \"Updated mod-ref summary for %s\\n\",\n \t\t     to->dump_name ());\n \t  to_info_lto->dump (dump_file);\n+\t  to_info_lto = NULL;\n \t}\n       if (callee_info_lto)\n \tsummaries_lto->remove (edge->callee);\n     }\n+  if (!to_info && !to_info_lto)\n+    remove_modref_edge_summaries (to);\n   return;\n }\n \n@@ -2564,13 +3233,10 @@ get_access_for_fnspec (cgraph_edge *e, attr_fnspec &fnspec,\n static bool\n propagate_unknown_call (cgraph_node *node,\n \t\t\tcgraph_edge *e, int ecf_flags,\n-\t\t\tmodref_summary **cur_summary_ptr,\n-\t\t\tmodref_summary_lto **cur_summary_lto_ptr)\n+\t\t\tmodref_summary *cur_summary,\n+\t\t\tmodref_summary_lto *cur_summary_lto)\n {\n   bool changed = false;\n-  modref_summary *cur_summary = cur_summary_ptr ? *cur_summary_ptr : NULL;\n-  modref_summary_lto *cur_summary_lto = cur_summary_lto_ptr\n-\t\t\t\t\t? *cur_summary_lto_ptr : NULL;\n   class fnspec_summary *fnspec_sum = fnspec_summaries->get (e);\n   auto_vec <modref_parm_map, 32> parm_map;\n   if (fnspec_sum\n@@ -2652,26 +3318,42 @@ propagate_unknown_call (cgraph_node *node,\n \t}\n       return changed;\n     }\n-  if (ignore_stores_p (node->decl, ecf_flags))\n+  if (dump_file)\n+    fprintf (dump_file, \"      collapsing loads\\n\");\n+  changed |= collapse_loads (cur_summary, cur_summary_lto);\n+  if (!ignore_stores_p (node->decl, ecf_flags))\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"      collapsing loads\\n\");\n-      return collapse_loads (cur_summary, cur_summary_lto);\n+\tfprintf (dump_file, \"      collapsing stores\\n\");\n+      changed |= collapse_stores (cur_summary, cur_summary_lto);\n     }\n-  if (optimization_summaries)\n-    optimization_summaries->remove (node);\n-  if (summaries_lto)\n-    summaries_lto->remove (node);\n-  if (cur_summary_ptr)\n-    *cur_summary_ptr = NULL;\n-  if (cur_summary_lto_ptr)\n-    *cur_summary_lto_ptr = NULL;\n-  if (dump_file)\n-    fprintf (dump_file, \"    Giving up\\n\");\n-  return true;\n+  return changed;\n }\n \n-/* Perform iterative dataflow on SCC component starting in COMPONENT_NODE.  */\n+/* Maybe remove summaies of NODE pointed to by CUR_SUMMARY_PTR\n+   and CUR_SUMMARY_LTO_PTR if they are useless according to ECF_FLAGS.  */\n+\n+static void\n+remove_useless_summaries (cgraph_node *node,\n+\t\t\t  modref_summary **cur_summary_ptr,\n+\t\t\t  modref_summary_lto **cur_summary_lto_ptr,\n+\t\t\t  int ecf_flags)\n+{\n+  if (*cur_summary_ptr && !(*cur_summary_ptr)->useful_p (ecf_flags, false))\n+    {\n+      optimization_summaries->remove (node);\n+      *cur_summary_ptr = NULL;\n+    }\n+  if (*cur_summary_lto_ptr\n+      && !(*cur_summary_lto_ptr)->useful_p (ecf_flags, false))\n+    {\n+      summaries_lto->remove (node);\n+      *cur_summary_lto_ptr = NULL;\n+    }\n+}\n+\n+/* Perform iterative dataflow on SCC component starting in COMPONENT_NODE\n+   and propagate loads/stores.  */\n \n static void\n modref_propagate_in_scc (cgraph_node *component_node)\n@@ -2696,6 +3378,8 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t  if (!cur_summary && !cur_summary_lto)\n \t    continue;\n \n+\t  int cur_ecf_flags = flags_from_decl_or_type (node->decl);\n+\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  Processing %s%s%s\\n\",\n \t\t     cur->dump_name (),\n@@ -2709,11 +3393,17 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"    Indirect call\"\n \t\t\t \"collapsing loads\\n\");\n-\t      changed |= propagate_unknown_call\n+\t      if (propagate_unknown_call\n \t\t\t   (node, e, e->indirect_info->ecf_flags,\n-\t\t\t    &cur_summary, &cur_summary_lto);\n-\t      if (!cur_summary && !cur_summary_lto)\n-\t\tbreak;\n+\t\t\t    cur_summary, cur_summary_lto))\n+\t\t{\n+\t\t  changed = true;\n+\t\t  remove_useless_summaries (node, &cur_summary,\n+\t\t\t\t\t    &cur_summary_lto,\n+\t\t\t\t\t    cur_ecf_flags);\n+\t\t  if (!cur_summary && !cur_summary_lto)\n+\t\t    break;\n+\t\t}\n \t    }\n \n \t  if (!cur_summary && !cur_summary_lto)\n@@ -2757,7 +3447,7 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t\t     \" or not available\\n\");\n \t\t  changed |= propagate_unknown_call\n \t\t\t       (node, callee_edge, flags,\n-\t\t\t\t&cur_summary, &cur_summary_lto);\n+\t\t\t\tcur_summary, cur_summary_lto);\n \t\t  if (!cur_summary && !cur_summary_lto)\n \t\t    break;\n \t\t  continue;\n@@ -2773,9 +3463,7 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t    fprintf (dump_file, \"      No call target summary\\n\");\n \t\t  changed |= propagate_unknown_call\n \t\t\t       (node, callee_edge, flags,\n-\t\t\t\t&cur_summary, NULL);\n-\t\t  if (!cur_summary && !cur_summary_lto)\n-\t\t    break;\n+\t\t\t\tcur_summary, NULL);\n \t\t}\n \t      if (cur_summary_lto\n \t\t  && !(callee_summary_lto = summaries_lto->get (callee)))\n@@ -2784,9 +3472,7 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t    fprintf (dump_file, \"      No call target summary\\n\");\n \t\t  changed |= propagate_unknown_call\n \t\t\t       (node, callee_edge, flags,\n-\t\t\t\tNULL, &cur_summary_lto);\n-\t\t  if (!cur_summary && !cur_summary_lto)\n-\t\t    break;\n+\t\t\t\tNULL, cur_summary_lto);\n \t\t}\n \n \t      /* We can not safely optimize based on summary of callee if it\n@@ -2839,52 +3525,247 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t\t}\n \t\t    }\n \t\t}\n+\t      if (changed)\n+\t\tremove_useless_summaries (node, &cur_summary,\n+\t\t\t\t\t  &cur_summary_lto,\n+\t\t\t\t\t  cur_ecf_flags);\n+\t      if (!cur_summary && !cur_summary_lto)\n+\t\tbreak;\n \t      if (dump_file && changed)\n \t\t{\n \t\t  if (cur_summary)\n \t\t    cur_summary->dump (dump_file);\n \t\t  if (cur_summary_lto)\n \t\t    cur_summary_lto->dump (dump_file);\n+\t\t  dump_modref_edge_summaries (dump_file, node, 4);\n \t\t}\n \t    }\n \t}\n       iteration++;\n     }\n   if (dump_file)\n+    fprintf (dump_file,\n+\t     \"Propagation finished in %i iterations\\n\", iteration);\n+}\n+\n+/* Dump results of propagation in SCC rooted in COMPONENT_NODE.  */\n+\n+static void\n+modref_propagate_dump_scc (cgraph_node *component_node)\n+{\n+  for (struct cgraph_node *cur = component_node; cur;\n+       cur = ((struct ipa_dfs_info *) cur->aux)->next_cycle)\n+    if (!cur->inlined_to)\n+      {\n+\tmodref_summary *cur_summary = optimization_summaries\n+\t\t\t\t      ? optimization_summaries->get (cur)\n+\t\t\t\t      : NULL;\n+\tmodref_summary_lto *cur_summary_lto = summaries_lto\n+\t\t\t\t\t      ? summaries_lto->get (cur)\n+\t\t\t\t\t      : NULL;\n+\n+\tfprintf (dump_file, \"Propagated modref for %s%s%s\\n\",\n+\t\t cur->dump_name (),\n+\t\t TREE_READONLY (cur->decl) ? \" (const)\" : \"\",\n+\t\t DECL_PURE_P (cur->decl) ? \" (pure)\" : \"\");\n+\tif (optimization_summaries)\n+\t  {\n+\t    if (cur_summary)\n+\t      cur_summary->dump (dump_file);\n+\t    else\n+\t      fprintf (dump_file, \"  Not tracked\\n\");\n+\t  }\n+\tif (summaries_lto)\n+\t  {\n+\t    if (cur_summary_lto)\n+\t      cur_summary_lto->dump (dump_file);\n+\t    else\n+\t      fprintf (dump_file, \"  Not tracked (lto)\\n\");\n+\t  }\n+      }\n+}\n+\n+/* Process escapes in SUM and merge SUMMARY to CUR_SUMMARY\n+   and SUMMARY_LTO to CUR_SUMMARY_LTO.\n+   Return true if something changed.  */\n+\n+static bool\n+modref_merge_call_site_flags (escape_summary *sum,\n+\t\t\t      modref_summary *cur_summary,\n+\t\t\t      modref_summary_lto *cur_summary_lto,\n+\t\t\t      modref_summary *summary,\n+\t\t\t      modref_summary_lto *summary_lto,\n+\t\t\t      bool ignore_stores)\n+{\n+  escape_entry *ee;\n+  unsigned int i;\n+  bool changed = false;\n+\n+  /* If we have no useful info to propagate.  */\n+  if ((!cur_summary || !cur_summary->arg_flags.length ())\n+      && (!cur_summary_lto || !cur_summary_lto->arg_flags.length ()))\n+    return false;\n+\n+  FOR_EACH_VEC_ELT (sum->esc, i, ee)\n     {\n-      fprintf (dump_file,\n-\t       \"Propagation finished in %i iterations\\n\", iteration);\n+      int flags = 0;\n+      int flags_lto = 0;\n+\n+      if (summary && ee->arg < summary->arg_flags.length ())\n+\tflags = summary->arg_flags[ee->arg];\n+      if (summary_lto\n+\t  && ee->arg < summary_lto->arg_flags.length ())\n+\tflags_lto = summary_lto->arg_flags[ee->arg];\n+      if (!ee->direct)\n+\t{\n+\t  flags = deref_flags (flags, ignore_stores);\n+\t  flags_lto = deref_flags (flags_lto, ignore_stores);\n+\t}\n+      else if (ignore_stores)\n+\t{\n+\t  flags |= EAF_NOESCAPE | EAF_NOCLOBBER;\n+\t  flags_lto |= EAF_NOESCAPE | EAF_NOCLOBBER;\n+\t}\n+      flags |= ee->min_flags;\n+      flags_lto |= ee->min_flags;\n+      if (cur_summary && ee->parm_index < cur_summary->arg_flags.length ())\n+\t{\n+\t  int f = cur_summary->arg_flags[ee->parm_index];\n+\t  if ((f & flags) != f)\n+\t    {\n+\t      f = f & flags;\n+\t      if ((f & ~(EAF_DIRECT | EAF_NOCLOBBER)) == 0)\n+\t\tf = 0;\n+\t      cur_summary->arg_flags[ee->parm_index] = f;\n+\t      changed = true;\n+\t    }\n+\t}\n+      if (cur_summary_lto\n+\t  && ee->parm_index < cur_summary_lto->arg_flags.length ())\n+\t{\n+\t  int f = cur_summary_lto->arg_flags[ee->parm_index];\n+\t  if ((f & flags_lto) != f)\n+\t    {\n+\t      f = f & flags;\n+\t      if ((f & ~(EAF_DIRECT | EAF_NOCLOBBER)) == 0)\n+\t\tf = 0;\n+\t      cur_summary_lto->arg_flags[ee->parm_index] = f;\n+\t      changed = true;\n+\t    }\n+\t}\n+    }\n+  return changed;\n+}\n+\n+/* Perform iterative dataflow on SCC component starting in COMPONENT_NODE\n+   and propagate arg flags.  */\n+\n+static void\n+modref_propagate_flags_in_scc (cgraph_node *component_node)\n+{\n+  bool changed = true;\n+  int iteration = 0;\n+\n+  while (changed)\n+    {\n+      changed = false;\n       for (struct cgraph_node *cur = component_node; cur;\n \t   cur = ((struct ipa_dfs_info *) cur->aux)->next_cycle)\n-\tif (!cur->inlined_to)\n-\t  {\n-\t    modref_summary *cur_summary = optimization_summaries\n-\t\t\t\t\t  ? optimization_summaries->get (cur)\n-\t\t\t\t\t  : NULL;\n-\t    modref_summary_lto *cur_summary_lto = summaries_lto\n-\t\t\t\t\t\t  ? summaries_lto->get (cur)\n-\t\t\t\t\t\t  : NULL;\n-\n-\t    fprintf (dump_file, \"Propagated modref for %s%s%s\\n\",\n+\t{\n+\t  cgraph_node *node = cur->inlined_to ? cur->inlined_to : cur;\n+\t  modref_summary *cur_summary = optimization_summaries\n+\t\t\t\t\t? optimization_summaries->get (node)\n+\t\t\t\t\t: NULL;\n+\t  modref_summary_lto *cur_summary_lto = summaries_lto\n+\t\t\t\t\t\t? summaries_lto->get (node)\n+\t\t\t\t\t\t: NULL;\n+\n+\t  if (!cur_summary && !cur_summary_lto)\n+\t    continue;\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"  Processing %s%s%s\\n\",\n \t\t     cur->dump_name (),\n \t\t     TREE_READONLY (cur->decl) ? \" (const)\" : \"\",\n \t\t     DECL_PURE_P (cur->decl) ? \" (pure)\" : \"\");\n-\t    if (optimization_summaries)\n-\t      {\n-\t\tif (cur_summary)\n-\t\t  cur_summary->dump (dump_file);\n-\t\telse\n-\t\t  fprintf (dump_file, \"  Not tracked\\n\");\n-\t      }\n-\t    if (summaries_lto)\n-\t      {\n-\t\tif (cur_summary_lto)\n-\t\t  cur_summary_lto->dump (dump_file);\n-\t\telse\n-\t\t  fprintf (dump_file, \"  Not tracked (lto)\\n\");\n-\t      }\n-\t  }\n-   }\n+\n+\t  for (cgraph_edge *e = cur->indirect_calls; e; e = e->next_callee)\n+\t    {\n+\t      escape_summary *sum = escape_summaries->get (e);\n+\n+\t      if (!sum || (e->indirect_info->ecf_flags\n+\t\t\t   & (ECF_CONST | ECF_NOVOPS)))\n+\t\tcontinue;\n+\n+\t      changed |= modref_merge_call_site_flags\n+\t\t\t\t(sum, cur_summary, cur_summary_lto,\n+\t\t\t\t NULL, NULL, ignore_stores_p (node->decl,\n+\t\t\t\t e->indirect_info->ecf_flags));\n+\t    }\n+\n+\t  if (!cur_summary && !cur_summary_lto)\n+\t    continue;\n+\n+\t  for (cgraph_edge *callee_edge = cur->callees; callee_edge;\n+\t       callee_edge = callee_edge->next_callee)\n+\t    {\n+\t      int flags = flags_from_decl_or_type (callee_edge->callee->decl);\n+\t      modref_summary *callee_summary = NULL;\n+\t      modref_summary_lto *callee_summary_lto = NULL;\n+\t      struct cgraph_node *callee;\n+\n+\t      if (flags & (ECF_CONST | ECF_NOVOPS)\n+\t\t  || !callee_edge->inline_failed)\n+\t\tcontinue;\n+\t      /* Get the callee and its summary.  */\n+\t      enum availability avail;\n+\t      callee = callee_edge->callee->function_or_virtual_thunk_symbol\n+\t\t\t (&avail, cur);\n+\n+\t      /* It is not necessary to re-process calls outside of the\n+\t\t SCC component.  */\n+\t      if (iteration > 0\n+\t\t  && (!callee->aux\n+\t\t      || ((struct ipa_dfs_info *)cur->aux)->scc_no\n+\t\t\t  != ((struct ipa_dfs_info *)callee->aux)->scc_no))\n+\t\tcontinue;\n+\n+\t      escape_summary *sum = escape_summaries->get (callee_edge);\n+\t      if (!sum)\n+\t\tcontinue;\n+\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"    Call to %s\\n\",\n+\t\t\t callee_edge->callee->dump_name ());\n+\n+\t      if (avail <= AVAIL_INTERPOSABLE\n+\t\t  || callee_edge->call_stmt_cannot_inline_p)\n+\t\t;\n+\t      else\n+\t\t{\n+\t\t  if (cur_summary)\n+\t\t    callee_summary = optimization_summaries->get (callee);\n+\t\t  if (cur_summary_lto)\n+\t\t    callee_summary_lto = summaries_lto->get (callee);\n+\t\t}\n+\t      changed |= modref_merge_call_site_flags\n+\t\t\t\t(sum, cur_summary, cur_summary_lto,\n+\t\t\t\t callee_summary, callee_summary_lto,\n+\t\t\t\t ignore_stores_p (node->decl, flags));\n+\t      if (dump_file && changed)\n+\t\t{\n+\t\t  if (cur_summary)\n+\t\t    cur_summary->dump (dump_file);\n+\t\t  if (cur_summary_lto)\n+\t\t    cur_summary_lto->dump (dump_file);\n+\t\t}\n+\t    }\n+\t}\n+      iteration++;\n+    }\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"Propagation of flags finished in %i iterations\\n\", iteration);\n }\n \n /* Run the IPA pass.  This will take a function's summaries and calls and\n@@ -2920,6 +3801,9 @@ pass_ipa_modref::execute (function *)\n \tfprintf (dump_file, \"\\n\\nStart of SCC component\\n\");\n \n       modref_propagate_in_scc (component_node);\n+      modref_propagate_flags_in_scc (component_node);\n+      if (dump_file)\n+\tmodref_propagate_dump_scc (component_node);\n     }\n   cgraph_node *node;\n   FOR_EACH_FUNCTION (node)\n@@ -2930,6 +3814,8 @@ pass_ipa_modref::execute (function *)\n   free (order);\n   delete fnspec_summaries;\n   fnspec_summaries = NULL;\n+  delete escape_summaries;\n+  escape_summaries = NULL;\n   return 0;\n }\n \n@@ -2943,13 +3829,14 @@ ipa_modref_c_finalize ()\n   optimization_summaries = NULL;\n   gcc_checking_assert (!summaries);\n   if (summaries_lto)\n-    {\n-      ggc_delete (summaries_lto);\n-      summaries_lto = NULL;\n-    }\n+    ggc_delete (summaries_lto);\n+  summaries_lto = NULL;\n   if (fnspec_summaries)\n     delete fnspec_summaries;\n   fnspec_summaries = NULL;\n+  if (escape_summaries)\n+    delete escape_summaries;\n+  escape_summaries = NULL;\n }\n \n #include \"gt-ipa-modref.h\""}, {"sha": "7decabd57441c67806730580f16f502188598a10", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85ebbabd85e03bdc3afc190aeb29250606d18322/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85ebbabd85e03bdc3afc190aeb29250606d18322/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=85ebbabd85e03bdc3afc190aeb29250606d18322", "patch": "@@ -30,12 +30,12 @@ struct GTY(()) modref_summary\n   modref_records *loads;\n   modref_records *stores;\n   auto_vec<unsigned char> GTY((skip)) arg_flags;\n+  bool writes_errno;\n \n   modref_summary ();\n   ~modref_summary ();\n   void dump (FILE *);\n-  bool useful_p (int ecf_flags);\n-  bool writes_errno;\n+  bool useful_p (int ecf_flags, bool check_flags = true);\n };\n \n modref_summary *get_modref_function_summary (cgraph_node *func);"}, {"sha": "098e0aae7f91421075992d829733b76862dbdb75", "filename": "gcc/params.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85ebbabd85e03bdc3afc190aeb29250606d18322/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85ebbabd85e03bdc3afc190aeb29250606d18322/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=85ebbabd85e03bdc3afc190aeb29250606d18322", "patch": "@@ -931,6 +931,10 @@ Maximum number of tests performed by modref query.\n Common Joined UInteger Var(param_modref_max_depth) Init(256) Param Optimization\n Maximum depth of DFS walk used by modref escape analysis.\n \n+-param=modref-max-escape-points=\n+Common Joined UInteger Var(param_modref_max_escape_points) Init(256) Param Optimization\n+Maximum number of escape points tracked by modref per SSA-name\n+\n -param=tm-max-aggregate-size=\n Common Joined UInteger Var(param_tm_max_aggregate_size) Init(9) Param Optimization\n Size in bytes after which thread-local aggregates should be instrumented with the logging functions instead of save/restore pairs."}]}