{"sha": "d3fd75d869480044213553000d2c9dc236a4f7af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNmZDc1ZDg2OTQ4MDA0NDIxMzU1MzAwMGQyYzlkYzIzNmE0ZjdhZg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-11-09T23:16:48Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-11-09T23:16:48Z"}, "message": "c++: Consider only relevant template arguments in sat_hasher\n\nA large source of cache misses in satisfy_atom is caused by the identity\nof an (atom,args) pair within the satisfaction cache being determined by\nthe entire set of supplied template arguments rather than by the subset\nof template arguments that the atom actually depends on.  For instance,\nconsider\n\n  template <class T> concept range = range_v<T>;\n  template <class U> void foo () requires range<U>;\n  template <class U, class V> void bar () requires range<U>;\n\nThe associated constraints of foo and bar are equivalent: they both\nconsist of the atom range_v<T> (with mapping T -> U).  But the sat_cache\ncurrently will never reuse a satisfaction value between the two atoms\nbecause foo has one template parameter and bar has two, and the\nsatisfaction cache conservatively assumes that all template parameters\nof the constrained decl are relevant to a satisfaction value of one of\nits atoms.\n\nThis patch eliminates this assumption and makes the sat_cache instead\ncare about just the subset of args of an (atom,args) pair that is\nrelevant to satisfaction.\n\nThis patch additionally fixes a seemingly latent bug that was found when\ntesting against range-v3.  In the testcase concepts-decltype2.C below,\nduring normalization of f's constraints we end up forming a TARGET_EXPR\nwhose _SLOT has a DECL_CONTEXT that points to g instead of f because\ncurrent_function_decl is not updated before we start normalizing.\nThis patch fixes this accordingly, and also adds a sanity check to\nkeep_template_parm to verify each found parameter has a valid index.\n\nWith this patch, compile time and memory usage for the cmcstl2 test\ntest/algorithm/set_symmetric_difference4.cpp drops from 8.5s/1.2GB to\n3.5s/0.4GB.\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (norm_info::norm_info): Initialize orig_decl.\n\t(norm_info::orig_decl): New data member.\n\t(normalize_atom): When caching an atom for the first time,\n\tcompute a list of template parameters used in the targets of the\n\tparameter mapping and store it in the TREE_TYPE of the mapping.\n\t(get_normalized_constraints_from_decl): Set current_function_decl\n\tappropriately when normalizing.  As an optimization, don't\n\tset up a push_nested_class_guard when decl has no constraints.\n\t(sat_hasher::hash): Use this list to hash only the template\n\targuments that are relevant to the atom.\n\t(satisfy_atom): Use this list to compare only the template\n\targuments that are relevant to the atom.\n\t* pt.c (keep_template_parm): Do a sanity check on the parameter's\n\tindex when flag_checking.", "tree": {"sha": "56ab62a333c47f69db56afc1585f64224e17da92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56ab62a333c47f69db56afc1585f64224e17da92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3fd75d869480044213553000d2c9dc236a4f7af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3fd75d869480044213553000d2c9dc236a4f7af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3fd75d869480044213553000d2c9dc236a4f7af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3fd75d869480044213553000d2c9dc236a4f7af/comments", "author": null, "committer": null, "parents": [{"sha": "3d56e969cb1cf44a9e3ffaef891f22ae516fdc85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d56e969cb1cf44a9e3ffaef891f22ae516fdc85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d56e969cb1cf44a9e3ffaef891f22ae516fdc85"}], "stats": {"total": 98, "additions": 92, "deletions": 6}, "files": [{"sha": "8691281d5f17d1bbd570c2e6299204ceb4c7a610", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 70, "deletions": 6, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3fd75d869480044213553000d2c9dc236a4f7af/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3fd75d869480044213553000d2c9dc236a4f7af/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=d3fd75d869480044213553000d2c9dc236a4f7af", "patch": "@@ -616,7 +616,8 @@ struct norm_info : subst_info\n \n   norm_info (tree in_decl, tsubst_flags_t complain)\n     : subst_info (tf_warning_or_error | complain, in_decl),\n-      context (make_context (in_decl))\n+      context (make_context (in_decl)),\n+      orig_decl (in_decl)\n   {}\n \n   bool generate_diagnostics() const\n@@ -647,6 +648,12 @@ struct norm_info : subst_info\n      for that check.  */\n \n   tree context;\n+\n+  /* The declaration whose constraints we're normalizing.  The targets\n+     of the parameter mapping of each atom will be in terms of the\n+     template parameters of ORIG_DECL.  */\n+\n+  tree orig_decl = NULL_TREE;\n };\n \n static tree normalize_expression (tree, tree, norm_info);\n@@ -743,6 +750,28 @@ normalize_atom (tree t, tree args, norm_info info)\n       tree *slot = atom_cache->find_slot (atom, INSERT);\n       if (*slot)\n \treturn *slot;\n+\n+      /* Find all template parameters used in the targets of the parameter\n+\t mapping, and store a list of them in the TREE_TYPE of the mapping.\n+\t This list will be used by sat_hasher to determine the subset of\n+\t supplied template arguments that the satisfaction value of the atom\n+\t depends on.  */\n+      if (map)\n+\t{\n+\t  tree targets = make_tree_vec (list_length (map));\n+\t  int i = 0;\n+\t  for (tree node = map; node; node = TREE_CHAIN (node))\n+\t    {\n+\t      tree target = TREE_PURPOSE (node);\n+\t      TREE_VEC_ELT (targets, i++) = target;\n+\t    }\n+\t  tree ctx_parms = (info.orig_decl\n+\t\t\t    ? DECL_TEMPLATE_PARMS (info.orig_decl)\n+\t\t\t    : current_template_parms);\n+\t  tree target_parms = find_template_parameters (targets, ctx_parms);\n+\t  TREE_TYPE (map) = target_parms;\n+\t}\n+\n       *slot = atom;\n     }\n   return atom;\n@@ -854,10 +883,17 @@ get_normalized_constraints_from_decl (tree d, bool diag = false)\n     if (tree *p = hash_map_safe_get (normalized_map, tmpl))\n       return *p;\n \n-  push_nested_class_guard pncs (DECL_CONTEXT (d));\n+  tree norm = NULL_TREE;\n+  if (tree ci = get_constraints (decl))\n+    {\n+      push_nested_class_guard pncs (DECL_CONTEXT (d));\n+\n+      temp_override<tree> ovr (current_function_decl);\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\tcurrent_function_decl = decl;\n \n-  tree ci = get_constraints (decl);\n-  tree norm = get_normalized_constraints_from_info (ci, tmpl, diag);\n+      norm = get_normalized_constraints_from_info (ci, tmpl, diag);\n+    }\n \n   if (!diag)\n     hash_map_safe_put<hm_ggc> (normalized_map, tmpl, norm);\n@@ -2325,7 +2361,21 @@ struct sat_hasher : ggc_ptr_hash<sat_entry>\n        assumption is violated, that's okay, we'll just get a cache miss.  */\n     hashval_t value = htab_hash_pointer (e->constr);\n \n-    return iterative_hash_template_arg (e->args, value);\n+    if (tree map = ATOMIC_CONSTR_MAP (e->constr))\n+      /* Only the parameters that are used in the targets of the mapping\n+\t affect the satisfaction value of the atom.  So we consider only\n+\t the arguments for these parameters, and ignore the rest.  */\n+      for (tree target_parms = TREE_TYPE (map);\n+\t   target_parms;\n+\t   target_parms = TREE_CHAIN (target_parms))\n+\t{\n+\t  int level, index;\n+\t  tree parm = TREE_VALUE (target_parms);\n+\t  template_parm_level_and_index (parm, &level, &index);\n+\t  tree arg = TMPL_ARG (e->args, level, index);\n+\t  value = iterative_hash_template_arg (arg, value);\n+\t}\n+    return value;\n   }\n \n   static bool equal (sat_entry *e1, sat_entry *e2)\n@@ -2343,7 +2393,21 @@ struct sat_hasher : ggc_ptr_hash<sat_entry>\n \n     if (e1->constr != e2->constr)\n       return false;\n-    return template_args_equal (e1->args, e2->args);\n+\n+    if (tree map = ATOMIC_CONSTR_MAP (e1->constr))\n+      for (tree target_parms = TREE_TYPE (map);\n+\t   target_parms;\n+\t   target_parms = TREE_CHAIN (target_parms))\n+\t{\n+\t  int level, index;\n+\t  tree parm = TREE_VALUE (target_parms);\n+\t  template_parm_level_and_index (parm, &level, &index);\n+\t  tree arg1 = TMPL_ARG (e1->args, level, index);\n+\t  tree arg2 = TMPL_ARG (e2->args, level, index);\n+\t  if (!template_args_equal (arg1, arg2))\n+\t    return false;\n+\t}\n+    return true;\n   }\n };\n "}, {"sha": "a2655a0ff5215918a7c2ae382ce883bf8e08d7ec", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3fd75d869480044213553000d2c9dc236a4f7af/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3fd75d869480044213553000d2c9dc236a4f7af/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d3fd75d869480044213553000d2c9dc236a4f7af", "patch": "@@ -10617,6 +10617,16 @@ keep_template_parm (tree t, void* data)\n   if (!ftpi->parms.add (t))\n     ftpi->parm_list = tree_cons (NULL_TREE, t, ftpi->parm_list);\n \n+  /* Verify the parameter we found has a valid index.  */\n+  if (flag_checking)\n+    {\n+      tree parms = ftpi->ctx_parms;\n+      while (TMPL_PARMS_DEPTH (parms) > level)\n+\tparms = TREE_CHAIN (parms);\n+      if (int len = TREE_VEC_LENGTH (TREE_VALUE (parms)))\n+\tgcc_assert (index < len);\n+    }\n+\n   return 0;\n }\n "}, {"sha": "529dab11fcb3cd26451c5f35e6b3b07daa39b791", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-decltype2.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3fd75d869480044213553000d2c9dc236a4f7af/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-decltype2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3fd75d869480044213553000d2c9dc236a4f7af/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-decltype2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-decltype2.C?ref=d3fd75d869480044213553000d2c9dc236a4f7af", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target c++20 } }\n+\n+template <class T> concept C = requires(T t) { t; };\n+\n+template <class T> using A = decltype((T{}, int{}));\n+\n+template <class T> concept D = C<A<T>>;\n+\n+template <class T> void f() requires D<T>;\n+\n+template <class, class>\n+void g() { f<int>(); }"}]}