{"sha": "4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY2M2RmYzZhZDcwNzFjNzU4YTE1ZWU0MDI4ZGE3ZWYzYTE0YjllMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-07-25T13:24:58Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-07-25T13:24:58Z"}, "message": "lto-symtab.c (lto_cgraph_replace_node): Release function body.\n\n\t* lto-symtab.c (lto_cgraph_replace_node): Release function body.\n\t* cgraph.c (cgraph_remove_node): Do not release function body\n\twhen in cgraph streaming.\n\t* ipa.c (process_references, symtab_remove_unreachable_nodes): Objects\n\tin other partitions are not considered reachable; fix handling of clones.\n\nFrom-SVN: r201242", "tree": {"sha": "14aa9bef47ee98d36445bd25cd1f85866bad036d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14aa9bef47ee98d36445bd25cd1f85866bad036d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1/comments", "author": null, "committer": null, "parents": [{"sha": "e6dcfa183238b81d4e69669cb091a09f116db8e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6dcfa183238b81d4e69669cb091a09f116db8e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6dcfa183238b81d4e69669cb091a09f116db8e7"}], "stats": {"total": 70, "additions": 45, "deletions": 25}, "files": [{"sha": "0561d81f347502e3b6b9653186ab14a854d44e2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1", "patch": "@@ -1,3 +1,11 @@\n+2013-07-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-symtab.c (lto_cgraph_replace_node): Release function body.\n+\t* cgraph.c (cgraph_remove_node): Do not release function body\n+\twhen in cgraph streaming.\n+\t* ipa.c (process_references, symtab_remove_unreachable_nodes): Objects\n+\tin other partitions are not considered reachable; fix handling of clones.\n+\n 2013-07-25  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \t* config/arm/arm.md (*sibcall_insn): Remove unnecessary space."}, {"sha": "c6ade31041884cebe775565efe3e8c26d179672e", "filename": "gcc/cgraph.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1", "patch": "@@ -1384,15 +1384,18 @@ cgraph_remove_node (struct cgraph_node *node)\n      itself is kept in the cgraph even after it is compiled.  Check whether\n      we are done with this body and reclaim it proactively if this is the case.\n      */\n-  n = cgraph_get_node (node->symbol.decl);\n-  if (!n\n-      || (!n->clones && !n->clone_of && !n->global.inlined_to\n-\t  && (cgraph_global_info_ready\n-\t      && (TREE_ASM_WRITTEN (n->symbol.decl)\n-\t\t  || DECL_EXTERNAL (n->symbol.decl)\n-\t\t  || !n->symbol.analyzed\n-\t\t  || n->symbol.in_other_partition))))\n-    cgraph_release_function_body (node);\n+  if (cgraph_state != CGRAPH_LTO_STREAMING)\n+    {\n+      n = cgraph_get_node (node->symbol.decl);\n+      if (!n\n+\t  || (!n->clones && !n->clone_of && !n->global.inlined_to\n+\t      && (cgraph_global_info_ready\n+\t\t  && (TREE_ASM_WRITTEN (n->symbol.decl)\n+\t\t      || DECL_EXTERNAL (n->symbol.decl)\n+\t\t      || !n->symbol.analyzed\n+\t\t      || (!flag_wpa && n->symbol.in_other_partition)))))\n+\tcgraph_release_function_body (node);\n+    }\n \n   node->symbol.decl = NULL;\n   if (node->call_site_hash)"}, {"sha": "e20e561a2a043525996bc72ccbed11d539435f1b", "filename": "gcc/ipa.c", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1", "patch": "@@ -138,7 +138,7 @@ process_references (struct ipa_ref_list *list,\n     {\n       symtab_node node = ref->referred;\n \n-      if (node->symbol.definition\n+      if (node->symbol.definition && !node->symbol.in_other_partition\n \t  && ((!DECL_EXTERNAL (node->symbol.decl) || node->symbol.alias)\n \t      || (before_inlining_p\n \t\t  /* We use variable constructors during late complation for\n@@ -236,6 +236,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n      cgraph_can_remove_if_no_direct_calls_and_refs_p should not be called on them.  */\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (!node->global.inlined_to\n+\t&& !node->symbol.in_other_partition\n \t&& (!cgraph_can_remove_if_no_direct_calls_and_refs_p (node)\n \t    /* Keep around virtual functions for possible devirtualization.  */\n \t    || (before_inlining_p\n@@ -250,7 +251,8 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \n   /* Mark variables that are obviously needed.  */\n   FOR_EACH_DEFINED_VARIABLE (vnode)\n-    if (!varpool_can_remove_if_no_refs (vnode))\n+    if (!varpool_can_remove_if_no_refs (vnode)\n+\t&& !vnode->symbol.in_other_partition)\n       {\n \tpointer_set_insert (reachable, vnode);\n \tenqueue_node ((symtab_node)vnode, &first, reachable);\n@@ -296,6 +298,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t      for (e = cnode->callees; e; e = e->next_callee)\n \t\t{\n \t\t  if (e->callee->symbol.definition\n+\t\t      && !e->callee->symbol.in_other_partition\n \t\t      && (!e->inline_failed\n \t\t\t  || !DECL_EXTERNAL (e->callee->symbol.decl)\n \t\t\t  || e->callee->symbol.alias\n@@ -306,22 +309,20 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \n \t      /* When inline clone exists, mark body to be preserved so when removing\n \t\t offline copy of the function we don't kill it.  */\n-\t      if (!cnode->symbol.alias && cnode->global.inlined_to)\n+\t      if (cnode->global.inlined_to)\n \t        pointer_set_insert (body_needed_for_clonning, cnode->symbol.decl);\n-\t    }\n \n-\t  /* For non-inline clones, force their origins to the boundary and ensure\n-\t     that body is not removed.  */\n-\t  while (cnode->clone_of\n-\t         && !gimple_has_body_p (cnode->symbol.decl))\n-\t    {\n-\t      bool noninline = cnode->clone_of->symbol.decl != cnode->symbol.decl;\n-\t      cnode = cnode->clone_of;\n-\t      if (noninline)\n-\t      \t{\n-\t          pointer_set_insert (body_needed_for_clonning, cnode->symbol.decl);\n-\t\t  enqueue_node ((symtab_node)cnode, &first, reachable);\n-\t\t  break;\n+\t      /* For non-inline clones, force their origins to the boundary and ensure\n+\t\t that body is not removed.  */\n+\t      while (cnode->clone_of)\n+\t\t{\n+\t\t  bool noninline = cnode->clone_of->symbol.decl != cnode->symbol.decl;\n+\t\t  cnode = cnode->clone_of;\n+\t\t  if (noninline)\n+\t\t    {\n+\t\t      pointer_set_insert (body_needed_for_clonning, cnode->symbol.decl);\n+\t\t      enqueue_node ((symtab_node)cnode, &first, reachable);\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -358,6 +359,8 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n         {\n \t  if (!pointer_set_contains (body_needed_for_clonning, node->symbol.decl))\n \t    cgraph_release_function_body (node);\n+\t  else if (!node->clone_of)\n+\t    gcc_assert (DECL_RESULT (node->symbol.decl));\n \t  if (node->symbol.definition)\n \t    {\n \t      if (file)\n@@ -366,6 +369,9 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t      changed = true;\n \t    }\n \t}\n+      else\n+\tgcc_assert (node->clone_of || !cgraph_function_with_gimple_body_p (node)\n+\t\t    || DECL_RESULT (node->symbol.decl));\n     }\n \n   /* Inline clones might be kept around so their materializing allows further"}, {"sha": "f9bf37c7005bead7f3be0f121c7d1ffd58c59756", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=4f63dfc6ad7071c758a15ee4028da7ef3a14b9e1", "patch": "@@ -80,6 +80,9 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n   /* Redirect incomming references.  */\n   ipa_clone_referring ((symtab_node)prevailing_node, &node->symbol.ref_list);\n \n+  if (node->symbol.decl != prevailing_node->symbol.decl)\n+    cgraph_release_function_body (node);\n+\n   /* Finally remove the replaced node.  */\n   cgraph_remove_node (node);\n }"}]}