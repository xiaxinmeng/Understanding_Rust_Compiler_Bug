{"sha": "159440699bf6f97dccc94377d9d69e540a1904dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU5NDQwNjk5YmY2Zjk3ZGNjYzk0Mzc3ZDlkNjllNTQwYTE5MDRkYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-05-23T10:32:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-05-23T10:32:16Z"}, "message": "Fix SLP def type when computing masks (PR85853)\n\nIn this PR, SLP failed to include a comparison node in the SLP\ntree and so marked the node as external.  It then went on to call\nvect_is_simple_use on the comparison with its STMT_VINFO_DEF_TYPE\nstill claiming that it was an internal definition.\n\nWe already avoid that for vect_analyze_stmt by temporarily copying\nthe node's definition type to each STMT_VINFO_DEF_TYPE.  This patch\nextends that to the vector type calculation.  The easiest thing\nseemed to be to split the analysis of the root node out into\na subroutine, so that it's possible to return false early without\nawkward control flow.\n\n2018-05-23  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\tPR tree-optimization/85853\n\t* tree-vect-slp.c (vect_slp_analyze_node_operations): Split out\n\tthe handling of the root of the node to...\n\t(vect_slp_analyze_node_operations_1): ...this new function,\n\tand run the whole thing with the child nodes' def types\n\tset according to their SLP node's def type.\n\ngcc/testsuite/\n\tPR tree-optimization/85853\n\t* gfortran.dg/vect/pr85853.f90: New test.\n\nFrom-SVN: r260601", "tree": {"sha": "e4ecc9d8f4c8a97c32fc8fc6eab46d0fcaac45f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4ecc9d8f4c8a97c32fc8fc6eab46d0fcaac45f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/159440699bf6f97dccc94377d9d69e540a1904dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/159440699bf6f97dccc94377d9d69e540a1904dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/159440699bf6f97dccc94377d9d69e540a1904dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/159440699bf6f97dccc94377d9d69e540a1904dc/comments", "author": null, "committer": null, "parents": [{"sha": "162ea0d3723af727f60438276be15ab8a47210cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/162ea0d3723af727f60438276be15ab8a47210cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/162ea0d3723af727f60438276be15ab8a47210cc"}], "stats": {"total": 134, "additions": 93, "deletions": 41}, "files": [{"sha": "0050748df4f085a196494d86ee11216097af3655", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/159440699bf6f97dccc94377d9d69e540a1904dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/159440699bf6f97dccc94377d9d69e540a1904dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=159440699bf6f97dccc94377d9d69e540a1904dc", "patch": "@@ -1,3 +1,12 @@\n+2018-05-23  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/85853\n+\t* tree-vect-slp.c (vect_slp_analyze_node_operations): Split out\n+\tthe handling of the root of the node to...\n+\t(vect_slp_analyze_node_operations_1): ...this new function,\n+\tand run the whole thing with the child nodes' def types\n+\tset according to their SLP node's def type.\n+\n 2018-05-23  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/85874"}, {"sha": "b40a39132c095e8766dbcbcd9864274f6793bd85", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/159440699bf6f97dccc94377d9d69e540a1904dc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/159440699bf6f97dccc94377d9d69e540a1904dc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=159440699bf6f97dccc94377d9d69e540a1904dc", "patch": "@@ -1,3 +1,8 @@\n+2018-05-23  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/85853\n+\t* gfortran.dg/vect/pr85853.f90: New test.\n+\n 2018-05-23  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* gnat.dg/import2.adb: New testcase."}, {"sha": "68f4a00432494a9b16da14c7528a743227802171", "filename": "gcc/testsuite/gfortran.dg/vect/pr85853.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/159440699bf6f97dccc94377d9d69e540a1904dc/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr85853.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/159440699bf6f97dccc94377d9d69e540a1904dc/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr85853.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr85853.f90?ref=159440699bf6f97dccc94377d9d69e540a1904dc", "patch": "@@ -0,0 +1,26 @@\n+! Taken from execute/where_2.f90, but with special flags.\n+! { dg-do run }\n+! { dg-additional-options \"-fno-tree-loop-vectorize\" }\n+\n+! Program to test the WHERE constructs\n+program where_2\n+   integer temp(10), reduce(10)\n+\n+   temp = 10\n+   reduce(1:3) = -1\n+   reduce(4:6) = 0\n+   reduce(7:8) = 5\n+   reduce(9:10) = 10\n+\n+   WHERE (reduce < 0)\n+      temp = 100\n+   ELSE WHERE (reduce .EQ. 0)\n+      temp = 200 + temp\n+   ELSE WHERE\n+      WHERE (reduce > 6) temp = temp + sum(reduce)\n+      temp = 300 + temp\n+   END WHERE\n+\n+   if (any (temp .ne. (/100, 100, 100, 210, 210, 210, 310, 310, 337, 337/))) &\n+      STOP 1\n+end program"}, {"sha": "508cd9d2fe796a82cae1cd6275ac06de2ded9986", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 53, "deletions": 41, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/159440699bf6f97dccc94377d9d69e540a1904dc/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/159440699bf6f97dccc94377d9d69e540a1904dc/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=159440699bf6f97dccc94377d9d69e540a1904dc", "patch": "@@ -2476,49 +2476,16 @@ _bb_vec_info::~_bb_vec_info ()\n   bb->aux = NULL;\n }\n \n-\n-/* Analyze statements contained in SLP tree NODE after recursively analyzing\n-   the subtree.  NODE_INSTANCE contains NODE and VINFO contains INSTANCE.\n-\n-   Return true if the operations are supported.  */\n+/* Subroutine of vect_slp_analyze_node_operations.  Handle the root of NODE,\n+   given then that child nodes have already been processed, and that\n+   their def types currently match their SLP node's def type.  */\n \n static bool\n-vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n-\t\t\t\t  slp_instance node_instance,\n-\t\t\t\t  scalar_stmts_to_slp_tree_map_t *visited,\n-\t\t\t\t  scalar_stmts_to_slp_tree_map_t *lvisited,\n-\t\t\t\t  stmt_vector_for_cost *cost_vec)\n+vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,\n+\t\t\t\t    slp_instance node_instance,\n+\t\t\t\t    stmt_vector_for_cost *cost_vec)\n {\n-  bool dummy;\n-  int i, j;\n-  gimple *stmt;\n-  slp_tree child;\n-\n-  if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n-    return true;\n-\n-  /* If we already analyzed the exact same set of scalar stmts we're done.\n-     We share the generated vector stmts for those.  */\n-  slp_tree *leader;\n-  if ((leader = visited->get (SLP_TREE_SCALAR_STMTS (node)))\n-      || (leader = lvisited->get (SLP_TREE_SCALAR_STMTS (node))))\n-    {\n-      SLP_TREE_NUMBER_OF_VEC_STMTS (node)\n-\t= SLP_TREE_NUMBER_OF_VEC_STMTS (*leader);\n-      return true;\n-    }\n-\n-  /* The SLP graph is acyclic so not caching whether we failed or succeeded\n-     doesn't result in any issue since we throw away the lvisited set\n-     when we fail.  */\n-  lvisited->put (SLP_TREE_SCALAR_STMTS (node).copy (), node);\n-\n-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (!vect_slp_analyze_node_operations (vinfo, child, node_instance,\n-\t\t\t\t\t   visited, lvisited, cost_vec))\n-      return false;\n-\n-  stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n+  gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   gcc_assert (stmt_info);\n   gcc_assert (STMT_SLP_TYPE (stmt_info) != loop_vect);\n@@ -2545,6 +2512,7 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n \t}\n \n       gimple *sstmt;\n+      unsigned int i;\n       FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, sstmt)\n \tSTMT_VINFO_VECTYPE (vinfo_for_stmt (sstmt)) = vectype;\n     }\n@@ -2572,12 +2540,56 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n \t= vect_get_num_vectors (vf * group_size, vectype);\n     }\n \n+  bool dummy;\n+  return vect_analyze_stmt (stmt, &dummy, node, node_instance, cost_vec);\n+}\n+\n+/* Analyze statements contained in SLP tree NODE after recursively analyzing\n+   the subtree.  NODE_INSTANCE contains NODE and VINFO contains INSTANCE.\n+\n+   Return true if the operations are supported.  */\n+\n+static bool\n+vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n+\t\t\t\t  slp_instance node_instance,\n+\t\t\t\t  scalar_stmts_to_slp_tree_map_t *visited,\n+\t\t\t\t  scalar_stmts_to_slp_tree_map_t *lvisited,\n+\t\t\t\t  stmt_vector_for_cost *cost_vec)\n+{\n+  int i, j;\n+  slp_tree child;\n+\n+  if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n+    return true;\n+\n+  /* If we already analyzed the exact same set of scalar stmts we're done.\n+     We share the generated vector stmts for those.  */\n+  slp_tree *leader;\n+  if ((leader = visited->get (SLP_TREE_SCALAR_STMTS (node)))\n+      || (leader = lvisited->get (SLP_TREE_SCALAR_STMTS (node))))\n+    {\n+      SLP_TREE_NUMBER_OF_VEC_STMTS (node)\n+\t= SLP_TREE_NUMBER_OF_VEC_STMTS (*leader);\n+      return true;\n+    }\n+\n+  /* The SLP graph is acyclic so not caching whether we failed or succeeded\n+     doesn't result in any issue since we throw away the lvisited set\n+     when we fail.  */\n+  lvisited->put (SLP_TREE_SCALAR_STMTS (node).copy (), node);\n+\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    if (!vect_slp_analyze_node_operations (vinfo, child, node_instance,\n+\t\t\t\t\t   visited, lvisited, cost_vec))\n+      return false;\n+\n   /* Push SLP node def-type to stmt operands.  */\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n     if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n       STMT_VINFO_DEF_TYPE (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (child)[0]))\n \t= SLP_TREE_DEF_TYPE (child);\n-  bool res = vect_analyze_stmt (stmt, &dummy, node, node_instance, cost_vec);\n+  bool res = vect_slp_analyze_node_operations_1 (vinfo, node, node_instance,\n+\t\t\t\t\t\t cost_vec);\n   /* Restore def-types.  */\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n     if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)"}]}