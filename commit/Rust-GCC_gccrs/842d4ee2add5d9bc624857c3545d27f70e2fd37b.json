{"sha": "842d4ee2add5d9bc624857c3545d27f70e2fd37b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQyZDRlZTJhZGQ1ZDliYzYyNDg1N2MzNTQ1ZDI3ZjcwZTJmZDM3Yg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-05-06T10:41:03Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-05-06T10:41:03Z"}, "message": "gigi.h (make_packable_type): Declare.\n\n\t* gcc-interface/gigi.h (make_packable_type): Declare.\n\t(make_type_from_size): Likewise.\n\t(relate_alias_sets): Likewise.\n\t(maybe_pad_type): Adjust.\n\t(init_gnat_to_gnu): Delete.\n\t(destroy_gnat_to_gnu): Likewise.\n\t(init_dummy_type): Likewise.\n\t(destroy_dummy_type): Likewise.\n\t(init_gnat_utils): Declare.\n\t(destroy_gnat_utils): Likewise.\n\t(ceil_pow2): New inline function.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Use ceil_pow2.\n\t<object>: Pass True for the final processing of alignment and size.\n\t<E_Subprogram_Type>: Only create the TYPE_DECL for a padded return\n\ttype if necessary.\n\t(round_up_to_align): Delete.\n\t(ceil_alignment): Likewise.\n\t(relate_alias_sets): Move to...\n\t(make_aligning_type): Likewise.\n\t(make_packable_type): Likewise.\n\t(maybe_pad_type): Likewise.\n\t(make_type_from_size): Likewise.\n\t* gcc-interface/utils.c (MAX_BITS_PER_WORD): Delete.\n\t(struct pad_type_hash): New type.\n\t(pad_type_hash_table): New static variable.\n\t(init_gnat_to_gnu): Merge into...\n\t(init_dummy_type): Likewise.\n\t(init_gnat_utils): ...this.  New function.\n\t(destroy_gnat_to_gnu): Merge into...\n\t(destroy_dummy_type): Likewise.\n\t(destroy_gnat_utils): ...this.  New function.\n\t(pad_type_hash_marked_p): New function.\n\t(pad_type_hash_hash): Likewise.\n\t(pad_type_hash_eq): Likewise.\n\t(relate_alias_sets): ...here.\n\t(make_aligning_type): Likewise.\n\t(make_packable_type): Likewise.\n\t(maybe_pad_type): Likewise.  Change same_rm_size parameter into\n\tset_rm_size; do not set TYPE_ADA_SIZE if it is false.  Do not set\n\tnull as Ada size.  Do not set TYPE_VOLATILE on the padded type.  If it\n\tis complete and has constant size, canonicalize it.  Bail out earlier\n\tif a warning need not be issued.\n\t(make_type_from_size): Likewise.\n\t<INTEGER_TYPE>: Bail out if size is too large\n\t(gnat_types_compatible_p): Do not deal with padded types.\n\t(convert): Compare main variants for padded types.\n\t* gcc-interface/trans.c (gigi): Call {init|destroy}_gnat_utils.\n\t(gnat_to_gnu): Do not convert at the end for a call to a function that\n\treturns an unconstrained type with default discriminant.\n\t(Attribute_to_gnu) <Attr_Size>: Simplify handling of padded objects.\n\t* gcc-interface/utils2.c (build_binary_op) <MODIFY_EXPR>: Likewise.\n\tDo not use the padded type if it is BLKmode and the inner type is\n\tnon-BLKmode.\n\nFrom-SVN: r187206", "tree": {"sha": "2b6e941a54364ab5cb9615c2ee43302a788c946f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b6e941a54364ab5cb9615c2ee43302a788c946f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/842d4ee2add5d9bc624857c3545d27f70e2fd37b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/842d4ee2add5d9bc624857c3545d27f70e2fd37b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/842d4ee2add5d9bc624857c3545d27f70e2fd37b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/842d4ee2add5d9bc624857c3545d27f70e2fd37b/comments", "author": null, "committer": null, "parents": [{"sha": "6295740973a67863a7a941c8d3f83d92b117abbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6295740973a67863a7a941c8d3f83d92b117abbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6295740973a67863a7a941c8d3f83d92b117abbc"}], "stats": {"total": 1704, "additions": 948, "deletions": 756}, "files": [{"sha": "345f1937d0cbdf0488ae2e668dc5e927674ff6e2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=842d4ee2add5d9bc624857c3545d27f70e2fd37b", "patch": "@@ -1,3 +1,59 @@\n+2012-05-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (make_packable_type): Declare.\n+\t(make_type_from_size): Likewise.\n+\t(relate_alias_sets): Likewise.\n+\t(maybe_pad_type): Adjust.\n+\t(init_gnat_to_gnu): Delete.\n+\t(destroy_gnat_to_gnu): Likewise.\n+\t(init_dummy_type): Likewise.\n+\t(destroy_dummy_type): Likewise.\n+\t(init_gnat_utils): Declare.\n+\t(destroy_gnat_utils): Likewise.\n+\t(ceil_pow2): New inline function.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Use ceil_pow2.\n+\t<object>: Pass True for the final processing of alignment and size.\n+\t<E_Subprogram_Type>: Only create the TYPE_DECL for a padded return\n+\ttype if necessary.\n+\t(round_up_to_align): Delete.\n+\t(ceil_alignment): Likewise.\n+\t(relate_alias_sets): Move to...\n+\t(make_aligning_type): Likewise.\n+\t(make_packable_type): Likewise.\n+\t(maybe_pad_type): Likewise.\n+\t(make_type_from_size): Likewise.\n+\t* gcc-interface/utils.c (MAX_BITS_PER_WORD): Delete.\n+\t(struct pad_type_hash): New type.\n+\t(pad_type_hash_table): New static variable.\n+\t(init_gnat_to_gnu): Merge into...\n+\t(init_dummy_type): Likewise.\n+\t(init_gnat_utils): ...this.  New function.\n+\t(destroy_gnat_to_gnu): Merge into...\n+\t(destroy_dummy_type): Likewise.\n+\t(destroy_gnat_utils): ...this.  New function.\n+\t(pad_type_hash_marked_p): New function.\n+\t(pad_type_hash_hash): Likewise.\n+\t(pad_type_hash_eq): Likewise.\n+\t(relate_alias_sets): ...here.\n+\t(make_aligning_type): Likewise.\n+\t(make_packable_type): Likewise.\n+\t(maybe_pad_type): Likewise.  Change same_rm_size parameter into\n+\tset_rm_size; do not set TYPE_ADA_SIZE if it is false.  Do not set\n+\tnull as Ada size.  Do not set TYPE_VOLATILE on the padded type.  If it\n+\tis complete and has constant size, canonicalize it.  Bail out earlier\n+\tif a warning need not be issued.\n+\t(make_type_from_size): Likewise.\n+\t<INTEGER_TYPE>: Bail out if size is too large\n+\t(gnat_types_compatible_p): Do not deal with padded types.\n+\t(convert): Compare main variants for padded types.\n+\t* gcc-interface/trans.c (gigi): Call {init|destroy}_gnat_utils.\n+\t(gnat_to_gnu): Do not convert at the end for a call to a function that\n+\treturns an unconstrained type with default discriminant.\n+\t(Attribute_to_gnu) <Attr_Size>: Simplify handling of padded objects.\n+\t* gcc-interface/utils2.c (build_binary_op) <MODIFY_EXPR>: Likewise.\n+\tDo not use the padded type if it is BLKmode and the inner type is\n+\tnon-BLKmode.\n+\n 2012-05-02  Pascal Obry  <obry@adacore.com>\n \n \tRevert"}, {"sha": "ee96dbe454528194dfb6d64fe7f169558f22ddde", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 13, "deletions": 658, "changes": 671, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=842d4ee2add5d9bc624857c3545d27f70e2fd37b", "patch": "@@ -126,15 +126,6 @@ DEF_VEC_ALLOC_O(variant_desc,heap);\n static GTY ((if_marked (\"tree_int_map_marked_p\"),\n \t     param_is (struct tree_int_map))) htab_t annotate_value_cache;\n \n-enum alias_set_op\n-{\n-  ALIAS_SET_COPY,\n-  ALIAS_SET_SUBSET,\n-  ALIAS_SET_SUPERSET\n-};\n-\n-static void relate_alias_sets (tree, tree, enum alias_set_op);\n-\n static bool allocatable_size_p (tree, bool);\n static void prepend_one_attribute_to (struct attrib **,\n \t\t\t\t      enum attr_type, tree, tree, Node_Id);\n@@ -144,7 +135,6 @@ static bool type_has_variable_size (tree);\n static tree elaborate_expression_1 (tree, Entity_Id, tree, bool, bool);\n static tree elaborate_expression_2 (tree, Entity_Id, tree, bool, bool,\n \t\t\t\t    unsigned int);\n-static tree make_packable_type (tree, bool);\n static tree gnat_to_gnu_component_type (Entity_Id, bool, bool);\n static tree gnat_to_gnu_param (Entity_Id, Mechanism_Type, Entity_Id, bool,\n \t\t\t       bool *);\n@@ -165,9 +155,7 @@ static VEC(variant_desc,heap) *build_variant_list (tree,\n \t\t\t\t\t\t   VEC(variant_desc,heap) *);\n static tree validate_size (Uint, tree, Entity_Id, enum tree_code, bool, bool);\n static void set_rm_size (Uint, tree, Entity_Id);\n-static tree make_type_from_size (tree, tree, bool);\n static unsigned int validate_alignment (Uint, Entity_Id, unsigned int);\n-static unsigned int ceil_alignment (unsigned HOST_WIDE_INT);\n static void check_ok_for_atomic (tree, Entity_Id, bool);\n static tree create_field_decl_from (tree, tree, tree, tree, tree,\n \t\t\t\t    VEC(subst_pair,heap) *);\n@@ -838,7 +826,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    else if (compare_tree_int (TYPE_SIZE (gnu_type), align_cap) > 0)\n \t      align = align_cap;\n \t    else\n-\t      align = ceil_alignment (tree_low_cst (TYPE_SIZE (gnu_type), 1));\n+\t      align = ceil_pow2 (tree_low_cst (TYPE_SIZE (gnu_type), 1));\n \n \t    /* But make sure not to under-align the object.  */\n \t    if (align <= TYPE_ALIGN (gnu_type))\n@@ -921,8 +909,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    tree orig_type = gnu_type;\n \n \t    gnu_type = maybe_pad_type (gnu_type, gnu_size, align, gnat_entity,\n-\t\t\t\t       false, false, definition,\n-\t\t\t\t       gnu_size ? true : false);\n+\t\t\t\t       false, false, definition, true);\n \n \t    /* If a padding record was made, declare it now since it will\n \t       never be declared otherwise.  This is necessary to ensure\n@@ -2942,7 +2929,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    = validate_alignment (Alignment (gnat_entity), gnat_entity, 0);\n \telse if (Is_Atomic (gnat_entity))\n \t  TYPE_ALIGN (gnu_type)\n-\t    = esize >= BITS_PER_WORD ? BITS_PER_WORD : ceil_alignment (esize);\n+\t    = esize >= BITS_PER_WORD ? BITS_PER_WORD : ceil_pow2 (esize);\n \t/* If a type needs strict alignment, the minimum size will be the\n \t   type size instead of the RM size (see validate_size).  Cap the\n \t   alignment, lest it causes this type size to become too large.  */\n@@ -4163,6 +4150,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       mechanism to avoid copying too much data when it returns.  */\n \t    if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_return_type)))\n \t      {\n+\t\ttree orig_type = gnu_return_type;\n+\n \t\tgnu_return_type\n \t\t  = maybe_pad_type (gnu_return_type,\n \t\t\t\t    max_size (TYPE_SIZE (gnu_return_type),\n@@ -4172,8 +4161,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t/* Declare it now since it will never be declared otherwise.\n \t\t   This is necessary to ensure that its subtrees are properly\n \t\t   marked.  */\n-\t\tcreate_type_decl (TYPE_NAME (gnu_return_type), gnu_return_type,\n-\t\t\t\t  NULL, true, debug_info_p, gnat_entity);\n+\t\tif (gnu_return_type != orig_type\n+\t\t    && !DECL_P (TYPE_NAME (gnu_return_type)))\n+\t\t  create_type_decl (TYPE_NAME (gnu_return_type),\n+\t\t\t\t    gnu_return_type, NULL, true,\n+\t\t\t\t    debug_info_p, gnat_entity);\n \n \t\treturn_by_invisi_ref_p = true;\n \t      }\n@@ -4700,7 +4692,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t  if (operand_equal_p (TYPE_SIZE (gnu_type), gnu_size, 0)\n \t      && operand_equal_p (rm_size (gnu_type), gnu_size, 0))\n-\t    gnu_size = 0;\n+\t    gnu_size = NULL_TREE;\n \t}\n \n       /* If the alignment hasn't already been processed and this is\n@@ -4763,6 +4755,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    gnu_entity_name = DECL_NAME (gnu_entity_name);\n \t}\n \n+      /* Now set the RM size of the type.  We cannot do it before padding\n+\t because we need to accept arbitrary RM sizes on integral types.  */\n       set_rm_size (RM_Size (gnat_entity), gnu_type, gnat_entity);\n \n       /* If we are at global level, GCC will have applied variable_size to\n@@ -5843,83 +5837,6 @@ elaborate_entity (Entity_Id gnat_entity)\n     }\n }\n \f\n-/* Relate the alias sets of GNU_NEW_TYPE and GNU_OLD_TYPE according to OP.\n-   If this is a multi-dimensional array type, do this recursively.\n-\n-   OP may be\n-   - ALIAS_SET_COPY:     the new set is made a copy of the old one.\n-   - ALIAS_SET_SUPERSET: the new set is made a superset of the old one.\n-   - ALIAS_SET_SUBSET:   the new set is made a subset of the old one.  */\n-\n-static void\n-relate_alias_sets (tree gnu_new_type, tree gnu_old_type, enum alias_set_op op)\n-{\n-  /* Remove any padding from GNU_OLD_TYPE.  It doesn't matter in the case\n-     of a one-dimensional array, since the padding has the same alias set\n-     as the field type, but if it's a multi-dimensional array, we need to\n-     see the inner types.  */\n-  while (TREE_CODE (gnu_old_type) == RECORD_TYPE\n-\t && (TYPE_JUSTIFIED_MODULAR_P (gnu_old_type)\n-\t     || TYPE_PADDING_P (gnu_old_type)))\n-    gnu_old_type = TREE_TYPE (TYPE_FIELDS (gnu_old_type));\n-\n-  /* Unconstrained array types are deemed incomplete and would thus be given\n-     alias set 0.  Retrieve the underlying array type.  */\n-  if (TREE_CODE (gnu_old_type) == UNCONSTRAINED_ARRAY_TYPE)\n-    gnu_old_type\n-      = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_old_type))));\n-  if (TREE_CODE (gnu_new_type) == UNCONSTRAINED_ARRAY_TYPE)\n-    gnu_new_type\n-      = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_new_type))));\n-\n-  if (TREE_CODE (gnu_new_type) == ARRAY_TYPE\n-      && TREE_CODE (TREE_TYPE (gnu_new_type)) == ARRAY_TYPE\n-      && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_new_type)))\n-    relate_alias_sets (TREE_TYPE (gnu_new_type), TREE_TYPE (gnu_old_type), op);\n-\n-  switch (op)\n-    {\n-    case ALIAS_SET_COPY:\n-      /* The alias set shouldn't be copied between array types with different\n-\t aliasing settings because this can break the aliasing relationship\n-\t between the array type and its element type.  */\n-#ifndef ENABLE_CHECKING\n-      if (flag_strict_aliasing)\n-#endif\n-\tgcc_assert (!(TREE_CODE (gnu_new_type) == ARRAY_TYPE\n-\t\t      && TREE_CODE (gnu_old_type) == ARRAY_TYPE\n-\t\t      && TYPE_NONALIASED_COMPONENT (gnu_new_type)\n-\t\t\t != TYPE_NONALIASED_COMPONENT (gnu_old_type)));\n-\n-      TYPE_ALIAS_SET (gnu_new_type) = get_alias_set (gnu_old_type);\n-      break;\n-\n-    case ALIAS_SET_SUBSET:\n-    case ALIAS_SET_SUPERSET:\n-      {\n-\talias_set_type old_set = get_alias_set (gnu_old_type);\n-\talias_set_type new_set = get_alias_set (gnu_new_type);\n-\n-\t/* Do nothing if the alias sets conflict.  This ensures that we\n-\t   never call record_alias_subset several times for the same pair\n-\t   or at all for alias set 0.  */\n-\tif (!alias_sets_conflict_p (old_set, new_set))\n-\t  {\n-\t    if (op == ALIAS_SET_SUBSET)\n-\t      record_alias_subset (old_set, new_set);\n-\t    else\n-\t      record_alias_subset (new_set, old_set);\n-\t  }\n-      }\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  record_component_aliases (gnu_new_type);\n-}\n-\f\n /* Return true if the size represented by GNU_SIZE can be handled by an\n    allocation.  If STATIC_P is true, consider only what can be done with a\n    static allocation.  */\n@@ -6211,471 +6128,6 @@ elaborate_expression_2 (tree gnu_expr, Entity_Id gnat_entity, tree gnu_name,\n \t\tunit_align);\n }\n \f\n-/* Create a record type that contains a SIZE bytes long field of TYPE with a\n-   starting bit position so that it is aligned to ALIGN bits, and leaving at\n-   least ROOM bytes free before the field.  BASE_ALIGN is the alignment the\n-   record is guaranteed to get.  */\n-\n-tree\n-make_aligning_type (tree type, unsigned int align, tree size,\n-\t\t    unsigned int base_align, int room)\n-{\n-  /* We will be crafting a record type with one field at a position set to be\n-     the next multiple of ALIGN past record'address + room bytes.  We use a\n-     record placeholder to express record'address.  */\n-  tree record_type = make_node (RECORD_TYPE);\n-  tree record = build0 (PLACEHOLDER_EXPR, record_type);\n-\n-  tree record_addr_st\n-    = convert (sizetype, build_unary_op (ADDR_EXPR, NULL_TREE, record));\n-\n-  /* The diagram below summarizes the shape of what we manipulate:\n-\n-                    <--------- pos ---------->\n-                {  +------------+-------------+-----------------+\n-      record  =>{  |############|     ...     | field (type)    |\n-                {  +------------+-------------+-----------------+\n-\t\t   |<-- room -->|<- voffset ->|<---- size ----->|\n-\t\t   o            o\n-\t\t   |            |\n-\t\t   record_addr  vblock_addr\n-\n-     Every length is in sizetype bytes there, except \"pos\" which has to be\n-     set as a bit position in the GCC tree for the record.  */\n-  tree room_st = size_int (room);\n-  tree vblock_addr_st = size_binop (PLUS_EXPR, record_addr_st, room_st);\n-  tree voffset_st, pos, field;\n-\n-  tree name = TYPE_NAME (type);\n-\n-  if (TREE_CODE (name) == TYPE_DECL)\n-    name = DECL_NAME (name);\n-  name = concat_name (name, \"ALIGN\");\n-  TYPE_NAME (record_type) = name;\n-\n-  /* Compute VOFFSET and then POS.  The next byte position multiple of some\n-     alignment after some address is obtained by \"and\"ing the alignment minus\n-     1 with the two's complement of the address.   */\n-  voffset_st = size_binop (BIT_AND_EXPR,\n-\t\t\t   fold_build1 (NEGATE_EXPR, sizetype, vblock_addr_st),\n-\t\t\t   size_int ((align / BITS_PER_UNIT) - 1));\n-\n-  /* POS = (ROOM + VOFFSET) * BIT_PER_UNIT, in bitsizetype.  */\n-  pos = size_binop (MULT_EXPR,\n-\t\t    convert (bitsizetype,\n-\t\t\t     size_binop (PLUS_EXPR, room_st, voffset_st)),\n-                    bitsize_unit_node);\n-\n-  /* Craft the GCC record representation.  We exceptionally do everything\n-     manually here because 1) our generic circuitry is not quite ready to\n-     handle the complex position/size expressions we are setting up, 2) we\n-     have a strong simplifying factor at hand: we know the maximum possible\n-     value of voffset, and 3) we have to set/reset at least the sizes in\n-     accordance with this maximum value anyway, as we need them to convey\n-     what should be \"alloc\"ated for this type.\n-\n-     Use -1 as the 'addressable' indication for the field to prevent the\n-     creation of a bitfield.  We don't need one, it would have damaging\n-     consequences on the alignment computation, and create_field_decl would\n-     make one without this special argument, for instance because of the\n-     complex position expression.  */\n-  field = create_field_decl (get_identifier (\"F\"), type, record_type, size,\n-\t\t\t     pos, 1, -1);\n-  TYPE_FIELDS (record_type) = field;\n-\n-  TYPE_ALIGN (record_type) = base_align;\n-  TYPE_USER_ALIGN (record_type) = 1;\n-\n-  TYPE_SIZE (record_type)\n-    = size_binop (PLUS_EXPR,\n-                  size_binop (MULT_EXPR, convert (bitsizetype, size),\n-                              bitsize_unit_node),\n-\t\t  bitsize_int (align + room * BITS_PER_UNIT));\n-  TYPE_SIZE_UNIT (record_type)\n-    = size_binop (PLUS_EXPR, size,\n-\t\t  size_int (room + align / BITS_PER_UNIT));\n-\n-  SET_TYPE_MODE (record_type, BLKmode);\n-  relate_alias_sets (record_type, type, ALIAS_SET_COPY);\n-\n-  /* Declare it now since it will never be declared otherwise.  This is\n-     necessary to ensure that its subtrees are properly marked.  */\n-  create_type_decl (name, record_type, NULL, true, false, Empty);\n-\n-  return record_type;\n-}\n-\f\n-/* Return the result of rounding T up to ALIGN.  */\n-\n-static inline unsigned HOST_WIDE_INT\n-round_up_to_align (unsigned HOST_WIDE_INT t, unsigned int align)\n-{\n-  t += align - 1;\n-  t /= align;\n-  t *= align;\n-  return t;\n-}\n-\n-/* TYPE is a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE that is being used\n-   as the field type of a packed record if IN_RECORD is true, or as the\n-   component type of a packed array if IN_RECORD is false.  See if we can\n-   rewrite it either as a type that has a non-BLKmode, which we can pack\n-   tighter in the packed record case, or as a smaller type.  If so, return\n-   the new type.  If not, return the original type.  */\n-\n-static tree\n-make_packable_type (tree type, bool in_record)\n-{\n-  unsigned HOST_WIDE_INT size = tree_low_cst (TYPE_SIZE (type), 1);\n-  unsigned HOST_WIDE_INT new_size;\n-  tree new_type, old_field, field_list = NULL_TREE;\n-\n-  /* No point in doing anything if the size is zero.  */\n-  if (size == 0)\n-    return type;\n-\n-  new_type = make_node (TREE_CODE (type));\n-\n-  /* Copy the name and flags from the old type to that of the new.\n-     Note that we rely on the pointer equality created here for\n-     TYPE_NAME to look through conversions in various places.  */\n-  TYPE_NAME (new_type) = TYPE_NAME (type);\n-  TYPE_JUSTIFIED_MODULAR_P (new_type) = TYPE_JUSTIFIED_MODULAR_P (type);\n-  TYPE_CONTAINS_TEMPLATE_P (new_type) = TYPE_CONTAINS_TEMPLATE_P (type);\n-  if (TREE_CODE (type) == RECORD_TYPE)\n-    TYPE_PADDING_P (new_type) = TYPE_PADDING_P (type);\n-\n-  /* If we are in a record and have a small size, set the alignment to\n-     try for an integral mode.  Otherwise set it to try for a smaller\n-     type with BLKmode.  */\n-  if (in_record && size <= MAX_FIXED_MODE_SIZE)\n-    {\n-      TYPE_ALIGN (new_type) = ceil_alignment (size);\n-      new_size = round_up_to_align (size, TYPE_ALIGN (new_type));\n-    }\n-  else\n-    {\n-      unsigned HOST_WIDE_INT align;\n-\n-      /* Do not try to shrink the size if the RM size is not constant.  */\n-      if (TYPE_CONTAINS_TEMPLATE_P (type)\n-\t  || !host_integerp (TYPE_ADA_SIZE (type), 1))\n-\treturn type;\n-\n-      /* Round the RM size up to a unit boundary to get the minimal size\n-\t for a BLKmode record.  Give up if it's already the size.  */\n-      new_size = TREE_INT_CST_LOW (TYPE_ADA_SIZE (type));\n-      new_size = round_up_to_align (new_size, BITS_PER_UNIT);\n-      if (new_size == size)\n-\treturn type;\n-\n-      align = new_size & -new_size;\n-      TYPE_ALIGN (new_type) = MIN (TYPE_ALIGN (type), align);\n-    }\n-\n-  TYPE_USER_ALIGN (new_type) = 1;\n-\n-  /* Now copy the fields, keeping the position and size as we don't want\n-     to change the layout by propagating the packedness downwards.  */\n-  for (old_field = TYPE_FIELDS (type); old_field;\n-       old_field = DECL_CHAIN (old_field))\n-    {\n-      tree new_field_type = TREE_TYPE (old_field);\n-      tree new_field, new_size;\n-\n-      if (RECORD_OR_UNION_TYPE_P (new_field_type)\n-\t  && !TYPE_FAT_POINTER_P (new_field_type)\n-\t  && host_integerp (TYPE_SIZE (new_field_type), 1))\n-\tnew_field_type = make_packable_type (new_field_type, true);\n-\n-      /* However, for the last field in a not already packed record type\n-\t that is of an aggregate type, we need to use the RM size in the\n-\t packable version of the record type, see finish_record_type.  */\n-      if (!DECL_CHAIN (old_field)\n-\t  && !TYPE_PACKED (type)\n-\t  && RECORD_OR_UNION_TYPE_P (new_field_type)\n-\t  && !TYPE_FAT_POINTER_P (new_field_type)\n-\t  && !TYPE_CONTAINS_TEMPLATE_P (new_field_type)\n-\t  && TYPE_ADA_SIZE (new_field_type))\n-\tnew_size = TYPE_ADA_SIZE (new_field_type);\n-      else\n-\tnew_size = DECL_SIZE (old_field);\n-\n-      new_field\n-\t= create_field_decl (DECL_NAME (old_field), new_field_type, new_type,\n-\t\t\t     new_size, bit_position (old_field),\n-\t\t\t     TYPE_PACKED (type),\n-\t\t\t     !DECL_NONADDRESSABLE_P (old_field));\n-\n-      DECL_INTERNAL_P (new_field) = DECL_INTERNAL_P (old_field);\n-      SET_DECL_ORIGINAL_FIELD_TO_FIELD (new_field, old_field);\n-      if (TREE_CODE (new_type) == QUAL_UNION_TYPE)\n-\tDECL_QUALIFIER (new_field) = DECL_QUALIFIER (old_field);\n-\n-      DECL_CHAIN (new_field) = field_list;\n-      field_list = new_field;\n-    }\n-\n-  finish_record_type (new_type, nreverse (field_list), 2, false);\n-  relate_alias_sets (new_type, type, ALIAS_SET_COPY);\n-  SET_DECL_PARALLEL_TYPE (TYPE_STUB_DECL (new_type),\n-\t\t\t  DECL_PARALLEL_TYPE (TYPE_STUB_DECL (type)));\n-\n-  /* If this is a padding record, we never want to make the size smaller\n-     than what was specified.  For QUAL_UNION_TYPE, also copy the size.  */\n-  if (TYPE_IS_PADDING_P (type) || TREE_CODE (type) == QUAL_UNION_TYPE)\n-    {\n-      TYPE_SIZE (new_type) = TYPE_SIZE (type);\n-      TYPE_SIZE_UNIT (new_type) = TYPE_SIZE_UNIT (type);\n-      new_size = size;\n-    }\n-  else\n-    {\n-      TYPE_SIZE (new_type) = bitsize_int (new_size);\n-      TYPE_SIZE_UNIT (new_type)\n-\t= size_int ((new_size + BITS_PER_UNIT - 1) / BITS_PER_UNIT);\n-    }\n-\n-  if (!TYPE_CONTAINS_TEMPLATE_P (type))\n-    SET_TYPE_ADA_SIZE (new_type, TYPE_ADA_SIZE (type));\n-\n-  compute_record_mode (new_type);\n-\n-  /* Try harder to get a packable type if necessary, for example\n-     in case the record itself contains a BLKmode field.  */\n-  if (in_record && TYPE_MODE (new_type) == BLKmode)\n-    SET_TYPE_MODE (new_type,\n-\t\t   mode_for_size_tree (TYPE_SIZE (new_type), MODE_INT, 1));\n-\n-  /* If neither the mode nor the size has shrunk, return the old type.  */\n-  if (TYPE_MODE (new_type) == BLKmode && new_size >= size)\n-    return type;\n-\n-  return new_type;\n-}\n-\f\n-/* Ensure that TYPE has SIZE and ALIGN.  Make and return a new padded type\n-   if needed.  We have already verified that SIZE and TYPE are large enough.\n-   GNAT_ENTITY is used to name the resulting record and to issue a warning.\n-   IS_COMPONENT_TYPE is true if this is being done for the component type\n-   of an array.  IS_USER_TYPE is true if we must complete the original type.\n-   DEFINITION is true if this type is being defined.  SAME_RM_SIZE is true\n-   if the RM size of the resulting type is to be set to SIZE too; otherwise,\n-   it's set to the RM size of the original type.  */\n-\n-tree\n-maybe_pad_type (tree type, tree size, unsigned int align,\n-\t\tEntity_Id gnat_entity, bool is_component_type,\n-\t\tbool is_user_type, bool definition, bool same_rm_size)\n-{\n-  tree orig_rm_size = same_rm_size ? NULL_TREE : rm_size (type);\n-  tree orig_size = TYPE_SIZE (type);\n-  tree record, field;\n-\n-  /* If TYPE is a padded type, see if it agrees with any size and alignment\n-     we were given.  If so, return the original type.  Otherwise, strip\n-     off the padding, since we will either be returning the inner type\n-     or repadding it.  If no size or alignment is specified, use that of\n-     the original padded type.  */\n-  if (TYPE_IS_PADDING_P (type))\n-    {\n-      if ((!size\n-\t   || operand_equal_p (round_up (size,\n-\t\t\t\t\t MAX (align, TYPE_ALIGN (type))),\n-\t\t\t       round_up (TYPE_SIZE (type),\n-\t\t\t\t\t MAX (align, TYPE_ALIGN (type))),\n-\t\t\t       0))\n-\t  && (align == 0 || align == TYPE_ALIGN (type)))\n-\treturn type;\n-\n-      if (!size)\n-\tsize = TYPE_SIZE (type);\n-      if (align == 0)\n-\talign = TYPE_ALIGN (type);\n-\n-      type = TREE_TYPE (TYPE_FIELDS (type));\n-      orig_size = TYPE_SIZE (type);\n-    }\n-\n-  /* If the size is either not being changed or is being made smaller (which\n-     is not done here and is only valid for bitfields anyway), show the size\n-     isn't changing.  Likewise, clear the alignment if it isn't being\n-     changed.  Then return if we aren't doing anything.  */\n-  if (size\n-      && (operand_equal_p (size, orig_size, 0)\n-\t  || (TREE_CODE (orig_size) == INTEGER_CST\n-\t      && tree_int_cst_lt (size, orig_size))))\n-    size = NULL_TREE;\n-\n-  if (align == TYPE_ALIGN (type))\n-    align = 0;\n-\n-  if (align == 0 && !size)\n-    return type;\n-\n-  /* If requested, complete the original type and give it a name.  */\n-  if (is_user_type)\n-    create_type_decl (get_entity_name (gnat_entity), type,\n-\t\t      NULL, !Comes_From_Source (gnat_entity),\n-\t\t      !(TYPE_NAME (type)\n-\t\t\t&& TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-\t\t\t&& DECL_IGNORED_P (TYPE_NAME (type))),\n-\t\t      gnat_entity);\n-\n-  /* We used to modify the record in place in some cases, but that could\n-     generate incorrect debugging information.  So make a new record\n-     type and name.  */\n-  record = make_node (RECORD_TYPE);\n-  TYPE_PADDING_P (record) = 1;\n-\n-  if (Present (gnat_entity))\n-    TYPE_NAME (record) = create_concat_name (gnat_entity, \"PAD\");\n-\n-  TYPE_VOLATILE (record)\n-    = Present (gnat_entity) && Treat_As_Volatile (gnat_entity);\n-\n-  TYPE_ALIGN (record) = align;\n-  TYPE_SIZE (record) = size ? size : orig_size;\n-  TYPE_SIZE_UNIT (record)\n-    = convert (sizetype,\n-\t       size_binop (CEIL_DIV_EXPR, TYPE_SIZE (record),\n-\t\t\t   bitsize_unit_node));\n-\n-  /* If we are changing the alignment and the input type is a record with\n-     BLKmode and a small constant size, try to make a form that has an\n-     integral mode.  This might allow the padding record to also have an\n-     integral mode, which will be much more efficient.  There is no point\n-     in doing so if a size is specified unless it is also a small constant\n-     size and it is incorrect to do so if we cannot guarantee that the mode\n-     will be naturally aligned since the field must always be addressable.\n-\n-     ??? This might not always be a win when done for a stand-alone object:\n-     since the nominal and the effective type of the object will now have\n-     different modes, a VIEW_CONVERT_EXPR will be required for converting\n-     between them and it might be hard to overcome afterwards, including\n-     at the RTL level when the stand-alone object is accessed as a whole.  */\n-  if (align != 0\n-      && RECORD_OR_UNION_TYPE_P (type)\n-      && TYPE_MODE (type) == BLKmode\n-      && !TYPE_BY_REFERENCE_P (type)\n-      && TREE_CODE (orig_size) == INTEGER_CST\n-      && !TREE_OVERFLOW (orig_size)\n-      && compare_tree_int (orig_size, MAX_FIXED_MODE_SIZE) <= 0\n-      && (!size\n-\t  || (TREE_CODE (size) == INTEGER_CST\n-\t      && compare_tree_int (size, MAX_FIXED_MODE_SIZE) <= 0)))\n-    {\n-      tree packable_type = make_packable_type (type, true);\n-      if (TYPE_MODE (packable_type) != BLKmode\n-\t  && align >= TYPE_ALIGN (packable_type))\n-        type = packable_type;\n-    }\n-\n-  /* Now create the field with the original size.  */\n-  field  = create_field_decl (get_identifier (\"F\"), type, record, orig_size,\n-\t\t\t      bitsize_zero_node, 0, 1);\n-  DECL_INTERNAL_P (field) = 1;\n-\n-  /* Do not emit debug info until after the auxiliary record is built.  */\n-  finish_record_type (record, field, 1, false);\n-\n-  /* Set the same size for its RM size if requested; otherwise reuse\n-     the RM size of the original type.  */\n-  SET_TYPE_ADA_SIZE (record, same_rm_size ? size : orig_rm_size);\n-\n-  /* Unless debugging information isn't being written for the input type,\n-     write a record that shows what we are a subtype of and also make a\n-     variable that indicates our size, if still variable.  */\n-  if (TREE_CODE (orig_size) != INTEGER_CST\n-      && TYPE_NAME (record)\n-      && TYPE_NAME (type)\n-      && !(TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-\t   && DECL_IGNORED_P (TYPE_NAME (type))))\n-    {\n-      tree marker = make_node (RECORD_TYPE);\n-      tree name = TYPE_NAME (record);\n-      tree orig_name = TYPE_NAME (type);\n-\n-      if (TREE_CODE (name) == TYPE_DECL)\n-\tname = DECL_NAME (name);\n-\n-      if (TREE_CODE (orig_name) == TYPE_DECL)\n-\torig_name = DECL_NAME (orig_name);\n-\n-      TYPE_NAME (marker) = concat_name (name, \"XVS\");\n-      finish_record_type (marker,\n-\t\t\t  create_field_decl (orig_name,\n-\t\t\t\t\t     build_reference_type (type),\n-\t\t\t\t\t     marker, NULL_TREE, NULL_TREE,\n-\t\t\t\t\t     0, 0),\n-\t\t\t  0, true);\n-\n-      add_parallel_type (record, marker);\n-\n-      if (definition && size && TREE_CODE (size) != INTEGER_CST)\n-\tTYPE_SIZE_UNIT (marker)\n-\t  = create_var_decl (concat_name (name, \"XVZ\"), NULL_TREE, sizetype,\n-\t\t\t     TYPE_SIZE_UNIT (record), false, false, false,\n-\t\t\t     false, NULL, gnat_entity);\n-    }\n-\n-  rest_of_record_type_compilation (record);\n-\n-  /* If the size was widened explicitly, maybe give a warning.  Take the\n-     original size as the maximum size of the input if there was an\n-     unconstrained record involved and round it up to the specified alignment,\n-     if one was specified.  But don't do it if we are just annotating types\n-     and the type is tagged, since tagged types aren't fully laid out in this\n-     mode.  */\n-  if (CONTAINS_PLACEHOLDER_P (orig_size))\n-    orig_size = max_size (orig_size, true);\n-\n-  if (align)\n-    orig_size = round_up (orig_size, align);\n-\n-  if (Present (gnat_entity)\n-      && size\n-      && TREE_CODE (size) != MAX_EXPR\n-      && TREE_CODE (size) != COND_EXPR\n-      && !operand_equal_p (size, orig_size, 0)\n-      && !(TREE_CODE (size) == INTEGER_CST\n-\t   && TREE_CODE (orig_size) == INTEGER_CST\n-\t   && (TREE_OVERFLOW (size)\n-\t       || TREE_OVERFLOW (orig_size)\n-\t       || tree_int_cst_lt (size, orig_size)))\n-      && !(type_annotate_only && Is_Tagged_Type (Etype (gnat_entity))))\n-    {\n-      Node_Id gnat_error_node = Empty;\n-\n-      if (Is_Packed_Array_Type (gnat_entity))\n-\tgnat_entity = Original_Array_Type (gnat_entity);\n-\n-      if ((Ekind (gnat_entity) == E_Component\n-\t   || Ekind (gnat_entity) == E_Discriminant)\n-\t  && Present (Component_Clause (gnat_entity)))\n-\tgnat_error_node = Last_Bit (Component_Clause (gnat_entity));\n-      else if (Present (Size_Clause (gnat_entity)))\n-\tgnat_error_node = Expression (Size_Clause (gnat_entity));\n-\n-      /* Generate message only for entities that come from source, since\n-\t if we have an entity created by expansion, the message will be\n-\t generated for some other corresponding source entity.  */\n-      if (Comes_From_Source (gnat_entity))\n-\t{\n-\t  if (Present (gnat_error_node))\n-\t    post_error_ne_tree (\"{^ }bits of & unused?\",\n-\t\t\t\tgnat_error_node, gnat_entity,\n-\t\t\t\tsize_diffop (size, orig_size));\n-\t  else if (is_component_type)\n-\t    post_error_ne_tree (\"component of& padded{ by ^ bits}?\",\n-\t\t\t\tgnat_entity, gnat_entity,\n-\t\t\t\tsize_diffop (size, orig_size));\n-\t}\n-    }\n-\n-  return record;\n-}\n-\f\n /* Given a GNU tree and a GNAT list of choices, generate an expression to test\n    the value passed against the list of choices.  */\n \n@@ -8245,95 +7697,6 @@ set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n     SET_TYPE_ADA_SIZE (gnu_type, size);\n }\n \f\n-/* Given a type TYPE, return a new type whose size is appropriate for SIZE.\n-   If TYPE is the best type, return it.  Otherwise, make a new type.  We\n-   only support new integral and pointer types.  FOR_BIASED is true if\n-   we are making a biased type.  */\n-\n-static tree\n-make_type_from_size (tree type, tree size_tree, bool for_biased)\n-{\n-  unsigned HOST_WIDE_INT size;\n-  bool biased_p;\n-  tree new_type;\n-\n-  /* If size indicates an error, just return TYPE to avoid propagating\n-     the error.  Likewise if it's too large to represent.  */\n-  if (!size_tree || !host_integerp (size_tree, 1))\n-    return type;\n-\n-  size = tree_low_cst (size_tree, 1);\n-\n-  switch (TREE_CODE (type))\n-    {\n-    case INTEGER_TYPE:\n-    case ENUMERAL_TYPE:\n-    case BOOLEAN_TYPE:\n-      biased_p = (TREE_CODE (type) == INTEGER_TYPE\n-\t\t  && TYPE_BIASED_REPRESENTATION_P (type));\n-\n-      /* Integer types with precision 0 are forbidden.  */\n-      if (size == 0)\n-\tsize = 1;\n-\n-      /* Only do something if the type is not a packed array type and\n-\t doesn't already have the proper size.  */\n-      if (TYPE_IS_PACKED_ARRAY_TYPE_P (type)\n-\t  || (TYPE_PRECISION (type) == size && biased_p == for_biased))\n-\tbreak;\n-\n-      biased_p |= for_biased;\n-      if (size > LONG_LONG_TYPE_SIZE)\n-\tsize = LONG_LONG_TYPE_SIZE;\n-\n-      if (TYPE_UNSIGNED (type) || biased_p)\n-\tnew_type = make_unsigned_type (size);\n-      else\n-\tnew_type = make_signed_type (size);\n-      TREE_TYPE (new_type) = TREE_TYPE (type) ? TREE_TYPE (type) : type;\n-      SET_TYPE_RM_MIN_VALUE (new_type,\n-\t\t\t     convert (TREE_TYPE (new_type),\n-\t\t\t\t      TYPE_MIN_VALUE (type)));\n-      SET_TYPE_RM_MAX_VALUE (new_type,\n-\t\t\t     convert (TREE_TYPE (new_type),\n-\t\t\t\t      TYPE_MAX_VALUE (type)));\n-      /* Copy the name to show that it's essentially the same type and\n-\t not a subrange type.  */\n-      TYPE_NAME (new_type) = TYPE_NAME (type);\n-      TYPE_BIASED_REPRESENTATION_P (new_type) = biased_p;\n-      SET_TYPE_RM_SIZE (new_type, bitsize_int (size));\n-      return new_type;\n-\n-    case RECORD_TYPE:\n-      /* Do something if this is a fat pointer, in which case we\n-\t may need to return the thin pointer.  */\n-      if (TYPE_FAT_POINTER_P (type) && size < POINTER_SIZE * 2)\n-\t{\n-\t  enum machine_mode p_mode = mode_for_size (size, MODE_INT, 0);\n-\t  if (!targetm.valid_pointer_mode (p_mode))\n-\t    p_mode = ptr_mode;\n-\t  return\n-\t    build_pointer_type_for_mode\n-\t      (TYPE_OBJECT_RECORD_TYPE (TYPE_UNCONSTRAINED_ARRAY (type)),\n-\t       p_mode, 0);\n-\t}\n-      break;\n-\n-    case POINTER_TYPE:\n-      /* Only do something if this is a thin pointer, in which case we\n-\t may need to return the fat pointer.  */\n-      if (TYPE_IS_THIN_POINTER_P (type) && size >= POINTER_SIZE * 2)\n-\treturn\n-\t  build_pointer_type (TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)));\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return type;\n-}\n-\f\n /* ALIGNMENT is a Uint giving the alignment specified for GNAT_ENTITY,\n    a type or object whose present alignment is ALIGN.  If this alignment is\n    valid, return it.  Otherwise, give an error and return ALIGN.  */\n@@ -8426,14 +7789,6 @@ validate_alignment (Uint alignment, Entity_Id gnat_entity, unsigned int align)\n \n   return align;\n }\n-\n-/* Return the smallest alignment not less than SIZE.  */\n-\n-static unsigned int\n-ceil_alignment (unsigned HOST_WIDE_INT size)\n-{\n-  return (unsigned int) 1 << (floor_log2 (size - 1) + 1);\n-}\n \f\n /* Verify that OBJECT, a type or decl, is something we can implement\n    atomically.  If not, give an error for GNAT_ENTITY.  COMP_P is true"}, {"sha": "e2aac80b66534e1354ae2d6b40c610c6fee1317f", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=842d4ee2add5d9bc624857c3545d27f70e2fd37b", "patch": "@@ -123,18 +123,48 @@ extern tree get_minimal_subprog_decl (Entity_Id gnat_entity);\n extern tree make_aligning_type (tree type, unsigned int align, tree size,\n \t\t\t\tunsigned int base_align, int room);\n \n+/* TYPE is a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE that is being used\n+   as the field type of a packed record if IN_RECORD is true, or as the\n+   component type of a packed array if IN_RECORD is false.  See if we can\n+   rewrite it either as a type that has a non-BLKmode, which we can pack\n+   tighter in the packed record case, or as a smaller type.  If so, return\n+   the new type.  If not, return the original type.  */\n+extern tree make_packable_type (tree type, bool in_record);\n+\n+/* Given a type TYPE, return a new type whose size is appropriate for SIZE.\n+   If TYPE is the best type, return it.  Otherwise, make a new type.  We\n+   only support new integral and pointer types.  FOR_BIASED is true if\n+   we are making a biased type.  */\n+extern tree make_type_from_size (tree type, tree size_tree, bool for_biased);\n+\n /* Ensure that TYPE has SIZE and ALIGN.  Make and return a new padded type\n    if needed.  We have already verified that SIZE and TYPE are large enough.\n    GNAT_ENTITY is used to name the resulting record and to issue a warning.\n-   IS_COMPONENT_TYPE is true if this is being done for the component type\n-   of an array.  IS_USER_TYPE is true if we must complete the original type.\n-   DEFINITION is true if this type is being defined.  SAME_RM_SIZE is true\n-   if the RM size of the resulting type is to be set to SIZE too; otherwise,\n-   it's set to the RM size of the original type.  */\n+   IS_COMPONENT_TYPE is true if this is being done for the component type of\n+   an array.  IS_USER_TYPE is true if the original type needs to be completed.\n+   DEFINITION is true if this type is being defined.  SET_RM_SIZE is true if\n+   the RM size of the resulting type is to be set to SIZE too.  */\n extern tree maybe_pad_type (tree type, tree size, unsigned int align,\n \t\t\t    Entity_Id gnat_entity, bool is_component_type,\n \t\t\t    bool is_user_type, bool definition,\n-\t\t\t    bool same_rm_size);\n+\t\t\t    bool set_rm_size);\n+\n+enum alias_set_op\n+{\n+  ALIAS_SET_COPY,\n+  ALIAS_SET_SUBSET,\n+  ALIAS_SET_SUPERSET\n+};\n+\n+/* Relate the alias sets of GNU_NEW_TYPE and GNU_OLD_TYPE according to OP.\n+   If this is a multi-dimensional array type, do this recursively.\n+\n+   OP may be\n+   - ALIAS_SET_COPY:     the new set is made a copy of the old one.\n+   - ALIAS_SET_SUPERSET: the new set is made a superset of the old one.\n+   - ALIAS_SET_SUBSET:   the new set is made a subset of the old one.  */\n+extern void relate_alias_sets (tree gnu_new_type, tree gnu_old_type,\n+\t\t\t       enum alias_set_op op);\n \n /* Given a GNU tree and a GNAT list of choices, generate an expression to test\n    the value passed against the list of choices.  */\n@@ -497,11 +527,11 @@ extern tree convert_to_index_type (tree expr);\n /* Routines created solely for the tree translator's sake. Their prototypes\n    can be changed as desired.  */\n \n-/* Initialize the association of GNAT nodes to GCC trees.  */\n-extern void init_gnat_to_gnu (void);\n+/* Initialize data structures of the utils.c module.  */\n+extern void init_gnat_utils (void);\n \n-/* Destroy the association of GNAT nodes to GCC trees.  */\n-extern void destroy_gnat_to_gnu (void);\n+/* Destroy data structures of the utils.c module.  */\n+extern void destroy_gnat_utils (void);\n \n /* GNAT_ENTITY is a GNAT tree node for a defining identifier.\n    GNU_DECL is the GCC tree which is to be associated with\n@@ -519,12 +549,6 @@ extern tree get_gnu_tree (Entity_Id gnat_entity);\n /* Return nonzero if a GCC tree has been associated with GNAT_ENTITY.  */\n extern bool present_gnu_tree (Entity_Id gnat_entity);\n \n-/* Initialize the association of GNAT nodes to GCC trees as dummies.  */\n-extern void init_dummy_type (void);\n-\n-/* Destroy the association of GNAT nodes to GCC trees as dummies.  */\n-extern void destroy_dummy_type (void);\n-\n /* Make a dummy type corresponding to GNAT_TYPE.  */\n extern tree make_dummy_type (Entity_Id gnat_type);\n \n@@ -1008,3 +1032,9 @@ extern void enumerate_modes (void (*f) (const char *, int, int, int, int, int,\n \n /* Convenient shortcuts.  */\n #define VECTOR_TYPE_P(TYPE) (TREE_CODE (TYPE) == VECTOR_TYPE)\n+\n+static inline unsigned HOST_WIDE_INT\n+ceil_pow2 (unsigned HOST_WIDE_INT x)\n+{\n+  return (unsigned HOST_WIDE_INT) 1 << (floor_log2 (x - 1) + 1);\n+}"}, {"sha": "fb4a2cd5ffedf7f2dd8dd32c166c1ce218573dee", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 23, "deletions": 39, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=842d4ee2add5d9bc624857c3545d27f70e2fd37b", "patch": "@@ -338,8 +338,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n \n   /* Initialize ourselves.  */\n   init_code_table ();\n-  init_gnat_to_gnu ();\n-  init_dummy_type ();\n+  init_gnat_utils ();\n \n   /* If we are just annotating types, give VOID_TYPE zero sizes to avoid\n      errors.  */\n@@ -685,8 +684,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n     }\n \n   /* Destroy ourselves.  */\n-  destroy_gnat_to_gnu ();\n-  destroy_dummy_type ();\n+  destroy_gnat_utils ();\n \n   /* We cannot track the location of errors past this point.  */\n   error_gnat_node = Empty;\n@@ -1501,34 +1499,25 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t    gnu_type = TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (gnu_type)));\n \t}\n \n-      /* If we're looking for the size of a field, return the field size.\n-\t Otherwise, if the prefix is an object, or if we're looking for\n-\t 'Object_Size or 'Max_Size_In_Storage_Elements, the result is the\n-\t GCC size of the type.  Otherwise, it is the RM size of the type.  */\n+      /* If we're looking for the size of a field, return the field size.  */\n       if (TREE_CODE (gnu_prefix) == COMPONENT_REF)\n \tgnu_result = DECL_SIZE (TREE_OPERAND (gnu_prefix, 1));\n-      else if (TREE_CODE (gnu_prefix) != TYPE_DECL\n+\n+      /* Otherwise, if the prefix is an object, or if we are looking for\n+\t 'Object_Size or 'Max_Size_In_Storage_Elements, the result is the\n+\t GCC size of the type.  We make an exception for padded objects,\n+\t as we do not take into account alignment promotions for the size.\n+\t This is in keeping with the object case of gnat_to_gnu_entity.  */\n+      else if ((TREE_CODE (gnu_prefix) != TYPE_DECL\n+\t\t&& !(TYPE_IS_PADDING_P (gnu_type)\n+\t\t     && TREE_CODE (gnu_expr) == COMPONENT_REF))\n \t       || attribute == Attr_Object_Size\n \t       || attribute == Attr_Max_Size_In_Storage_Elements)\n \t{\n-\t  /* If the prefix is an object of a padded type, the GCC size isn't\n-\t     relevant to the programmer.  Normally what we want is the RM size,\n-\t     which was set from the specified size, but if it was not set, we\n-\t     want the size of the field.  Using the MAX of those two produces\n-\t     the right result in all cases.  Don't use the size of the field\n-\t     if it's self-referential, since that's never what's wanted.  */\n-\t  if (TREE_CODE (gnu_prefix) != TYPE_DECL\n-\t      && TYPE_IS_PADDING_P (gnu_type)\n-\t      && TREE_CODE (gnu_expr) == COMPONENT_REF)\n-\t    {\n-\t      gnu_result = rm_size (gnu_type);\n-\t      if (!CONTAINS_PLACEHOLDER_P\n-\t\t   (DECL_SIZE (TREE_OPERAND (gnu_expr, 1))))\n-\t\tgnu_result\n-\t\t  = size_binop (MAX_EXPR, gnu_result,\n-\t\t\t\tDECL_SIZE (TREE_OPERAND (gnu_expr, 1)));\n-\t    }\n-\t  else if (Nkind (Prefix (gnat_node)) == N_Explicit_Dereference)\n+\t  /* If this is a dereference and we have a special dynamic constrained\n+\t     subtype on the prefix, use it to compute the size; otherwise, use\n+\t     the designated subtype.  */\n+\t  if (Nkind (Prefix (gnat_node)) == N_Explicit_Dereference)\n \t    {\n \t      Node_Id gnat_deref = Prefix (gnat_node);\n \t      Node_Id gnat_actual_subtype\n@@ -1547,12 +1536,12 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t\t\t\t\t\t      get_identifier (\"SIZE\"),\n \t\t\t\t\t\t      false);\n \t\t}\n-\n-\t      gnu_result = TYPE_SIZE (gnu_type);\n \t    }\n-\t  else\n-\t    gnu_result = TYPE_SIZE (gnu_type);\n+\n+\t  gnu_result = TYPE_SIZE (gnu_type);\n \t}\n+\n+      /* Otherwise, the result is the RM size of the type.  */\n       else\n \tgnu_result = rm_size (gnu_type);\n \n@@ -6921,15 +6910,10 @@ gnat_to_gnu (Node_Id gnat_node)\n \n   else if (TREE_CODE (gnu_result) == CALL_EXPR\n \t   && TYPE_IS_PADDING_P (TREE_TYPE (gnu_result))\n+\t   && TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_result)))\n+\t      == gnu_result_type\n \t   && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_result_type)))\n-    {\n-      /* ??? We need to convert if the padded type has fixed size because\n-\t gnat_types_compatible_p will say that padded types are compatible\n-\t but the gimplifier will not and, therefore, will ultimately choke\n-\t if there isn't a conversion added early.  */\n-      if (TREE_CODE (TYPE_SIZE (TREE_TYPE (gnu_result))) == INTEGER_CST)\n-\tgnu_result = convert (gnu_result_type, gnu_result);\n-    }\n+    ;\n \n   else if (TREE_TYPE (gnu_result) != gnu_result_type)\n     gnu_result = convert (gnu_result_type, gnu_result);"}, {"sha": "5d264e01ac3759f03310a2a7d7ac13400166d9be", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 739, "deletions": 37, "changes": 776, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=842d4ee2add5d9bc624857c3545d27f70e2fd37b", "patch": "@@ -58,10 +58,6 @@\n #include \"ada-tree.h\"\n #include \"gigi.h\"\n \n-#ifndef MAX_BITS_PER_WORD\n-#define MAX_BITS_PER_WORD  BITS_PER_WORD\n-#endif\n-\n /* If nonzero, pretend we are allocating at global level.  */\n int force_global;\n \n@@ -215,6 +211,21 @@ static GTY(()) VEC(tree,gc) *global_renaming_pointers;\n /* A chain of unused BLOCK nodes. */\n static GTY((deletable)) tree free_block_chain;\n \n+static int pad_type_hash_marked_p (const void *p);\n+static hashval_t pad_type_hash_hash (const void *p);\n+static int pad_type_hash_eq (const void *p1, const void *p2);\n+\n+/* A hash table of padded types.  It is modelled on the generic type\n+   hash table in tree.c, which must thus be used as a reference.  */\n+struct GTY(()) pad_type_hash {\n+  unsigned long hash;\n+  tree type;\n+};\n+\n+static GTY ((if_marked (\"pad_type_hash_marked_p\"),\n+\t     param_is (struct pad_type_hash)))\n+  htab_t pad_type_hash_table;\n+\n static tree merge_sizes (tree, tree, tree, bool, bool);\n static tree compute_related_constant (tree, tree);\n static tree split_plus (tree, tree *);\n@@ -223,23 +234,43 @@ static tree convert_to_fat_pointer (tree, tree);\n static bool potential_alignment_gap (tree, tree, tree);\n static void process_attributes (tree, struct attrib *);\n \f\n-/* Initialize the association of GNAT nodes to GCC trees.  */\n+/* Initialize data structures of the utils.c module.  */\n \n void\n-init_gnat_to_gnu (void)\n+init_gnat_utils (void)\n {\n+  /* Initialize the association of GNAT nodes to GCC trees.  */\n   associate_gnat_to_gnu = ggc_alloc_cleared_vec_tree (max_gnat_nodes);\n+\n+  /* Initialize the association of GNAT nodes to GCC trees as dummies.  */\n+  dummy_node_table = ggc_alloc_cleared_vec_tree (max_gnat_nodes);\n+\n+  /* Initialize the hash table of padded types.  */\n+  pad_type_hash_table = htab_create_ggc (512, pad_type_hash_hash,\n+\t\t\t\t\t pad_type_hash_eq, 0);\n }\n \n-/* Destroy the association of GNAT nodes to GCC trees.  */\n+/* Destroy data structures of the utils.c module.  */\n \n void\n-destroy_gnat_to_gnu (void)\n+destroy_gnat_utils (void)\n {\n+  /* Destroy the association of GNAT nodes to GCC trees.  */\n   ggc_free (associate_gnat_to_gnu);\n   associate_gnat_to_gnu = NULL;\n-}\n \n+  /* Destroy the association of GNAT nodes to GCC trees as dummies.  */\n+  ggc_free (dummy_node_table);\n+  dummy_node_table = NULL;\n+\n+  /* Destroy the hash table of padded types.  */\n+  htab_delete (pad_type_hash_table);\n+  pad_type_hash_table = NULL;\n+\n+  /* Invalidate the global renaming pointers.   */\n+  invalidate_global_renaming_pointers ();\n+}\n+\f\n /* GNAT_ENTITY is a GNAT tree node for an entity.  Associate GNU_DECL, a GCC\n    tree node, with GNAT_ENTITY.  If GNU_DECL is not a ..._DECL node, abort.\n    If NO_CHECK is true, the latter check is suppressed.\n@@ -281,23 +312,6 @@ present_gnu_tree (Entity_Id gnat_entity)\n   return PRESENT_GNU_TREE (gnat_entity);\n }\n \f\n-/* Initialize the association of GNAT nodes to GCC trees as dummies.  */\n-\n-void\n-init_dummy_type (void)\n-{\n-  dummy_node_table = ggc_alloc_cleared_vec_tree (max_gnat_nodes);\n-}\n-\n-/* Destroy the association of GNAT nodes to GCC trees as dummies.  */\n-\n-void\n-destroy_dummy_type (void)\n-{\n-  ggc_free (dummy_node_table);\n-  dummy_node_table = NULL;\n-}\n-\n /* Make a dummy type corresponding to GNAT_TYPE.  */\n \n tree\n@@ -630,6 +644,702 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n     }\n }\n \f\n+/* Create a record type that contains a SIZE bytes long field of TYPE with a\n+   starting bit position so that it is aligned to ALIGN bits, and leaving at\n+   least ROOM bytes free before the field.  BASE_ALIGN is the alignment the\n+   record is guaranteed to get.  */\n+\n+tree\n+make_aligning_type (tree type, unsigned int align, tree size,\n+\t\t    unsigned int base_align, int room)\n+{\n+  /* We will be crafting a record type with one field at a position set to be\n+     the next multiple of ALIGN past record'address + room bytes.  We use a\n+     record placeholder to express record'address.  */\n+  tree record_type = make_node (RECORD_TYPE);\n+  tree record = build0 (PLACEHOLDER_EXPR, record_type);\n+\n+  tree record_addr_st\n+    = convert (sizetype, build_unary_op (ADDR_EXPR, NULL_TREE, record));\n+\n+  /* The diagram below summarizes the shape of what we manipulate:\n+\n+                    <--------- pos ---------->\n+                {  +------------+-------------+-----------------+\n+      record  =>{  |############|     ...     | field (type)    |\n+                {  +------------+-------------+-----------------+\n+\t\t   |<-- room -->|<- voffset ->|<---- size ----->|\n+\t\t   o            o\n+\t\t   |            |\n+\t\t   record_addr  vblock_addr\n+\n+     Every length is in sizetype bytes there, except \"pos\" which has to be\n+     set as a bit position in the GCC tree for the record.  */\n+  tree room_st = size_int (room);\n+  tree vblock_addr_st = size_binop (PLUS_EXPR, record_addr_st, room_st);\n+  tree voffset_st, pos, field;\n+\n+  tree name = TYPE_NAME (type);\n+\n+  if (TREE_CODE (name) == TYPE_DECL)\n+    name = DECL_NAME (name);\n+  name = concat_name (name, \"ALIGN\");\n+  TYPE_NAME (record_type) = name;\n+\n+  /* Compute VOFFSET and then POS.  The next byte position multiple of some\n+     alignment after some address is obtained by \"and\"ing the alignment minus\n+     1 with the two's complement of the address.   */\n+  voffset_st = size_binop (BIT_AND_EXPR,\n+\t\t\t   fold_build1 (NEGATE_EXPR, sizetype, vblock_addr_st),\n+\t\t\t   size_int ((align / BITS_PER_UNIT) - 1));\n+\n+  /* POS = (ROOM + VOFFSET) * BIT_PER_UNIT, in bitsizetype.  */\n+  pos = size_binop (MULT_EXPR,\n+\t\t    convert (bitsizetype,\n+\t\t\t     size_binop (PLUS_EXPR, room_st, voffset_st)),\n+                    bitsize_unit_node);\n+\n+  /* Craft the GCC record representation.  We exceptionally do everything\n+     manually here because 1) our generic circuitry is not quite ready to\n+     handle the complex position/size expressions we are setting up, 2) we\n+     have a strong simplifying factor at hand: we know the maximum possible\n+     value of voffset, and 3) we have to set/reset at least the sizes in\n+     accordance with this maximum value anyway, as we need them to convey\n+     what should be \"alloc\"ated for this type.\n+\n+     Use -1 as the 'addressable' indication for the field to prevent the\n+     creation of a bitfield.  We don't need one, it would have damaging\n+     consequences on the alignment computation, and create_field_decl would\n+     make one without this special argument, for instance because of the\n+     complex position expression.  */\n+  field = create_field_decl (get_identifier (\"F\"), type, record_type, size,\n+\t\t\t     pos, 1, -1);\n+  TYPE_FIELDS (record_type) = field;\n+\n+  TYPE_ALIGN (record_type) = base_align;\n+  TYPE_USER_ALIGN (record_type) = 1;\n+\n+  TYPE_SIZE (record_type)\n+    = size_binop (PLUS_EXPR,\n+                  size_binop (MULT_EXPR, convert (bitsizetype, size),\n+                              bitsize_unit_node),\n+\t\t  bitsize_int (align + room * BITS_PER_UNIT));\n+  TYPE_SIZE_UNIT (record_type)\n+    = size_binop (PLUS_EXPR, size,\n+\t\t  size_int (room + align / BITS_PER_UNIT));\n+\n+  SET_TYPE_MODE (record_type, BLKmode);\n+  relate_alias_sets (record_type, type, ALIAS_SET_COPY);\n+\n+  /* Declare it now since it will never be declared otherwise.  This is\n+     necessary to ensure that its subtrees are properly marked.  */\n+  create_type_decl (name, record_type, NULL, true, false, Empty);\n+\n+  return record_type;\n+}\n+\n+/* TYPE is a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE that is being used\n+   as the field type of a packed record if IN_RECORD is true, or as the\n+   component type of a packed array if IN_RECORD is false.  See if we can\n+   rewrite it either as a type that has a non-BLKmode, which we can pack\n+   tighter in the packed record case, or as a smaller type.  If so, return\n+   the new type.  If not, return the original type.  */\n+\n+tree\n+make_packable_type (tree type, bool in_record)\n+{\n+  unsigned HOST_WIDE_INT size = tree_low_cst (TYPE_SIZE (type), 1);\n+  unsigned HOST_WIDE_INT new_size;\n+  tree new_type, old_field, field_list = NULL_TREE;\n+  unsigned int align;\n+\n+  /* No point in doing anything if the size is zero.  */\n+  if (size == 0)\n+    return type;\n+\n+  new_type = make_node (TREE_CODE (type));\n+\n+  /* Copy the name and flags from the old type to that of the new.\n+     Note that we rely on the pointer equality created here for\n+     TYPE_NAME to look through conversions in various places.  */\n+  TYPE_NAME (new_type) = TYPE_NAME (type);\n+  TYPE_JUSTIFIED_MODULAR_P (new_type) = TYPE_JUSTIFIED_MODULAR_P (type);\n+  TYPE_CONTAINS_TEMPLATE_P (new_type) = TYPE_CONTAINS_TEMPLATE_P (type);\n+  if (TREE_CODE (type) == RECORD_TYPE)\n+    TYPE_PADDING_P (new_type) = TYPE_PADDING_P (type);\n+\n+  /* If we are in a record and have a small size, set the alignment to\n+     try for an integral mode.  Otherwise set it to try for a smaller\n+     type with BLKmode.  */\n+  if (in_record && size <= MAX_FIXED_MODE_SIZE)\n+    {\n+      align = ceil_pow2 (size);\n+      TYPE_ALIGN (new_type) = align;\n+      new_size = (size + align - 1) & -align;\n+    }\n+  else\n+    {\n+      unsigned HOST_WIDE_INT align;\n+\n+      /* Do not try to shrink the size if the RM size is not constant.  */\n+      if (TYPE_CONTAINS_TEMPLATE_P (type)\n+\t  || !host_integerp (TYPE_ADA_SIZE (type), 1))\n+\treturn type;\n+\n+      /* Round the RM size up to a unit boundary to get the minimal size\n+\t for a BLKmode record.  Give up if it's already the size.  */\n+      new_size = TREE_INT_CST_LOW (TYPE_ADA_SIZE (type));\n+      new_size = (new_size + BITS_PER_UNIT - 1) & -BITS_PER_UNIT;\n+      if (new_size == size)\n+\treturn type;\n+\n+      align = new_size & -new_size;\n+      TYPE_ALIGN (new_type) = MIN (TYPE_ALIGN (type), align);\n+    }\n+\n+  TYPE_USER_ALIGN (new_type) = 1;\n+\n+  /* Now copy the fields, keeping the position and size as we don't want\n+     to change the layout by propagating the packedness downwards.  */\n+  for (old_field = TYPE_FIELDS (type); old_field;\n+       old_field = DECL_CHAIN (old_field))\n+    {\n+      tree new_field_type = TREE_TYPE (old_field);\n+      tree new_field, new_size;\n+\n+      if (RECORD_OR_UNION_TYPE_P (new_field_type)\n+\t  && !TYPE_FAT_POINTER_P (new_field_type)\n+\t  && host_integerp (TYPE_SIZE (new_field_type), 1))\n+\tnew_field_type = make_packable_type (new_field_type, true);\n+\n+      /* However, for the last field in a not already packed record type\n+\t that is of an aggregate type, we need to use the RM size in the\n+\t packable version of the record type, see finish_record_type.  */\n+      if (!DECL_CHAIN (old_field)\n+\t  && !TYPE_PACKED (type)\n+\t  && RECORD_OR_UNION_TYPE_P (new_field_type)\n+\t  && !TYPE_FAT_POINTER_P (new_field_type)\n+\t  && !TYPE_CONTAINS_TEMPLATE_P (new_field_type)\n+\t  && TYPE_ADA_SIZE (new_field_type))\n+\tnew_size = TYPE_ADA_SIZE (new_field_type);\n+      else\n+\tnew_size = DECL_SIZE (old_field);\n+\n+      new_field\n+\t= create_field_decl (DECL_NAME (old_field), new_field_type, new_type,\n+\t\t\t     new_size, bit_position (old_field),\n+\t\t\t     TYPE_PACKED (type),\n+\t\t\t     !DECL_NONADDRESSABLE_P (old_field));\n+\n+      DECL_INTERNAL_P (new_field) = DECL_INTERNAL_P (old_field);\n+      SET_DECL_ORIGINAL_FIELD_TO_FIELD (new_field, old_field);\n+      if (TREE_CODE (new_type) == QUAL_UNION_TYPE)\n+\tDECL_QUALIFIER (new_field) = DECL_QUALIFIER (old_field);\n+\n+      DECL_CHAIN (new_field) = field_list;\n+      field_list = new_field;\n+    }\n+\n+  finish_record_type (new_type, nreverse (field_list), 2, false);\n+  relate_alias_sets (new_type, type, ALIAS_SET_COPY);\n+  SET_DECL_PARALLEL_TYPE (TYPE_STUB_DECL (new_type),\n+\t\t\t  DECL_PARALLEL_TYPE (TYPE_STUB_DECL (type)));\n+\n+  /* If this is a padding record, we never want to make the size smaller\n+     than what was specified.  For QUAL_UNION_TYPE, also copy the size.  */\n+  if (TYPE_IS_PADDING_P (type) || TREE_CODE (type) == QUAL_UNION_TYPE)\n+    {\n+      TYPE_SIZE (new_type) = TYPE_SIZE (type);\n+      TYPE_SIZE_UNIT (new_type) = TYPE_SIZE_UNIT (type);\n+      new_size = size;\n+    }\n+  else\n+    {\n+      TYPE_SIZE (new_type) = bitsize_int (new_size);\n+      TYPE_SIZE_UNIT (new_type)\n+\t= size_int ((new_size + BITS_PER_UNIT - 1) / BITS_PER_UNIT);\n+    }\n+\n+  if (!TYPE_CONTAINS_TEMPLATE_P (type))\n+    SET_TYPE_ADA_SIZE (new_type, TYPE_ADA_SIZE (type));\n+\n+  compute_record_mode (new_type);\n+\n+  /* Try harder to get a packable type if necessary, for example\n+     in case the record itself contains a BLKmode field.  */\n+  if (in_record && TYPE_MODE (new_type) == BLKmode)\n+    SET_TYPE_MODE (new_type,\n+\t\t   mode_for_size_tree (TYPE_SIZE (new_type), MODE_INT, 1));\n+\n+  /* If neither the mode nor the size has shrunk, return the old type.  */\n+  if (TYPE_MODE (new_type) == BLKmode && new_size >= size)\n+    return type;\n+\n+  return new_type;\n+}\n+\n+/* Given a type TYPE, return a new type whose size is appropriate for SIZE.\n+   If TYPE is the best type, return it.  Otherwise, make a new type.  We\n+   only support new integral and pointer types.  FOR_BIASED is true if\n+   we are making a biased type.  */\n+\n+tree\n+make_type_from_size (tree type, tree size_tree, bool for_biased)\n+{\n+  unsigned HOST_WIDE_INT size;\n+  bool biased_p;\n+  tree new_type;\n+\n+  /* If size indicates an error, just return TYPE to avoid propagating\n+     the error.  Likewise if it's too large to represent.  */\n+  if (!size_tree || !host_integerp (size_tree, 1))\n+    return type;\n+\n+  size = tree_low_cst (size_tree, 1);\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case INTEGER_TYPE:\n+    case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n+      biased_p = (TREE_CODE (type) == INTEGER_TYPE\n+\t\t  && TYPE_BIASED_REPRESENTATION_P (type));\n+\n+      /* Integer types with precision 0 are forbidden.  */\n+      if (size == 0)\n+\tsize = 1;\n+\n+      /* Only do something if the type isn't a packed array type and doesn't\n+\t already have the proper size and the size isn't too large.  */\n+      if (TYPE_IS_PACKED_ARRAY_TYPE_P (type)\n+\t  || (TYPE_PRECISION (type) == size && biased_p == for_biased)\n+\t  || size > LONG_LONG_TYPE_SIZE)\n+\tbreak;\n+\n+      biased_p |= for_biased;\n+      if (TYPE_UNSIGNED (type) || biased_p)\n+\tnew_type = make_unsigned_type (size);\n+      else\n+\tnew_type = make_signed_type (size);\n+      TREE_TYPE (new_type) = TREE_TYPE (type) ? TREE_TYPE (type) : type;\n+      SET_TYPE_RM_MIN_VALUE (new_type,\n+\t\t\t     convert (TREE_TYPE (new_type),\n+\t\t\t\t      TYPE_MIN_VALUE (type)));\n+      SET_TYPE_RM_MAX_VALUE (new_type,\n+\t\t\t     convert (TREE_TYPE (new_type),\n+\t\t\t\t      TYPE_MAX_VALUE (type)));\n+      /* Copy the name to show that it's essentially the same type and\n+\t not a subrange type.  */\n+      TYPE_NAME (new_type) = TYPE_NAME (type);\n+      TYPE_BIASED_REPRESENTATION_P (new_type) = biased_p;\n+      SET_TYPE_RM_SIZE (new_type, bitsize_int (size));\n+      return new_type;\n+\n+    case RECORD_TYPE:\n+      /* Do something if this is a fat pointer, in which case we\n+\t may need to return the thin pointer.  */\n+      if (TYPE_FAT_POINTER_P (type) && size < POINTER_SIZE * 2)\n+\t{\n+\t  enum machine_mode p_mode = mode_for_size (size, MODE_INT, 0);\n+\t  if (!targetm.valid_pointer_mode (p_mode))\n+\t    p_mode = ptr_mode;\n+\t  return\n+\t    build_pointer_type_for_mode\n+\t      (TYPE_OBJECT_RECORD_TYPE (TYPE_UNCONSTRAINED_ARRAY (type)),\n+\t       p_mode, 0);\n+\t}\n+      break;\n+\n+    case POINTER_TYPE:\n+      /* Only do something if this is a thin pointer, in which case we\n+\t may need to return the fat pointer.  */\n+      if (TYPE_IS_THIN_POINTER_P (type) && size >= POINTER_SIZE * 2)\n+\treturn\n+\t  build_pointer_type (TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return type;\n+}\n+\n+/* See if the data pointed to by the hash table slot is marked.  */\n+\n+static int\n+pad_type_hash_marked_p (const void *p)\n+{\n+  const_tree const type = ((const struct pad_type_hash *) p)->type;\n+\n+  return ggc_marked_p (type);\n+}\n+\n+/* Return the cached hash value.  */\n+\n+static hashval_t\n+pad_type_hash_hash (const void *p)\n+{\n+  return ((const struct pad_type_hash *) p)->hash;\n+}\n+\n+/* Return 1 iff the padded types are equivalent.  */\n+\n+static int\n+pad_type_hash_eq (const void *p1, const void *p2)\n+{\n+  const struct pad_type_hash *const t1 = (const struct pad_type_hash *) p1;\n+  const struct pad_type_hash *const t2 = (const struct pad_type_hash *) p2;\n+  tree type1, type2;\n+\n+  if (t1->hash != t2->hash)\n+    return 0;\n+\n+  type1 = t1->type;\n+  type2 = t2->type;\n+\n+  /* We consider that the padded types are equivalent if they pad the same\n+     type and have the same size, alignment and RM size.  Taking the mode\n+     into account is redundant since it is determined by the others.  */\n+  return\n+    TREE_TYPE (TYPE_FIELDS (type1)) == TREE_TYPE (TYPE_FIELDS (type2))\n+    && TYPE_SIZE (type1) == TYPE_SIZE (type2)\n+    && TYPE_ALIGN (type1) == TYPE_ALIGN (type2)\n+    && TYPE_ADA_SIZE (type1) == TYPE_ADA_SIZE (type2);\n+}\n+\n+/* Ensure that TYPE has SIZE and ALIGN.  Make and return a new padded type\n+   if needed.  We have already verified that SIZE and TYPE are large enough.\n+   GNAT_ENTITY is used to name the resulting record and to issue a warning.\n+   IS_COMPONENT_TYPE is true if this is being done for the component type of\n+   an array.  IS_USER_TYPE is true if the original type needs to be completed.\n+   DEFINITION is true if this type is being defined.  SET_RM_SIZE is true if\n+   the RM size of the resulting type is to be set to SIZE too.  */\n+\n+tree\n+maybe_pad_type (tree type, tree size, unsigned int align,\n+\t\tEntity_Id gnat_entity, bool is_component_type,\n+\t\tbool is_user_type, bool definition, bool set_rm_size)\n+{\n+  tree orig_size = TYPE_SIZE (type);\n+  tree record, field;\n+\n+  /* If TYPE is a padded type, see if it agrees with any size and alignment\n+     we were given.  If so, return the original type.  Otherwise, strip\n+     off the padding, since we will either be returning the inner type\n+     or repadding it.  If no size or alignment is specified, use that of\n+     the original padded type.  */\n+  if (TYPE_IS_PADDING_P (type))\n+    {\n+      if ((!size\n+\t   || operand_equal_p (round_up (size,\n+\t\t\t\t\t MAX (align, TYPE_ALIGN (type))),\n+\t\t\t       round_up (TYPE_SIZE (type),\n+\t\t\t\t\t MAX (align, TYPE_ALIGN (type))),\n+\t\t\t       0))\n+\t  && (align == 0 || align == TYPE_ALIGN (type)))\n+\treturn type;\n+\n+      if (!size)\n+\tsize = TYPE_SIZE (type);\n+      if (align == 0)\n+\talign = TYPE_ALIGN (type);\n+\n+      type = TREE_TYPE (TYPE_FIELDS (type));\n+      orig_size = TYPE_SIZE (type);\n+    }\n+\n+  /* If the size is either not being changed or is being made smaller (which\n+     is not done here and is only valid for bitfields anyway), show the size\n+     isn't changing.  Likewise, clear the alignment if it isn't being\n+     changed.  Then return if we aren't doing anything.  */\n+  if (size\n+      && (operand_equal_p (size, orig_size, 0)\n+\t  || (TREE_CODE (orig_size) == INTEGER_CST\n+\t      && tree_int_cst_lt (size, orig_size))))\n+    size = NULL_TREE;\n+\n+  if (align == TYPE_ALIGN (type))\n+    align = 0;\n+\n+  if (align == 0 && !size)\n+    return type;\n+\n+  /* If requested, complete the original type and give it a name.  */\n+  if (is_user_type)\n+    create_type_decl (get_entity_name (gnat_entity), type,\n+\t\t      NULL, !Comes_From_Source (gnat_entity),\n+\t\t      !(TYPE_NAME (type)\n+\t\t\t&& TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t\t\t&& DECL_IGNORED_P (TYPE_NAME (type))),\n+\t\t      gnat_entity);\n+\n+  /* We used to modify the record in place in some cases, but that could\n+     generate incorrect debugging information.  So make a new record\n+     type and name.  */\n+  record = make_node (RECORD_TYPE);\n+  TYPE_PADDING_P (record) = 1;\n+\n+  if (Present (gnat_entity))\n+    TYPE_NAME (record) = create_concat_name (gnat_entity, \"PAD\");\n+\n+  TYPE_ALIGN (record) = align;\n+  TYPE_SIZE (record) = size ? size : orig_size;\n+  TYPE_SIZE_UNIT (record)\n+    = convert (sizetype,\n+\t       size_binop (CEIL_DIV_EXPR, TYPE_SIZE (record),\n+\t\t\t   bitsize_unit_node));\n+\n+  /* If we are changing the alignment and the input type is a record with\n+     BLKmode and a small constant size, try to make a form that has an\n+     integral mode.  This might allow the padding record to also have an\n+     integral mode, which will be much more efficient.  There is no point\n+     in doing so if a size is specified unless it is also a small constant\n+     size and it is incorrect to do so if we cannot guarantee that the mode\n+     will be naturally aligned since the field must always be addressable.\n+\n+     ??? This might not always be a win when done for a stand-alone object:\n+     since the nominal and the effective type of the object will now have\n+     different modes, a VIEW_CONVERT_EXPR will be required for converting\n+     between them and it might be hard to overcome afterwards, including\n+     at the RTL level when the stand-alone object is accessed as a whole.  */\n+  if (align != 0\n+      && RECORD_OR_UNION_TYPE_P (type)\n+      && TYPE_MODE (type) == BLKmode\n+      && !TYPE_BY_REFERENCE_P (type)\n+      && TREE_CODE (orig_size) == INTEGER_CST\n+      && !TREE_OVERFLOW (orig_size)\n+      && compare_tree_int (orig_size, MAX_FIXED_MODE_SIZE) <= 0\n+      && (!size\n+\t  || (TREE_CODE (size) == INTEGER_CST\n+\t      && compare_tree_int (size, MAX_FIXED_MODE_SIZE) <= 0)))\n+    {\n+      tree packable_type = make_packable_type (type, true);\n+      if (TYPE_MODE (packable_type) != BLKmode\n+\t  && align >= TYPE_ALIGN (packable_type))\n+        type = packable_type;\n+    }\n+\n+  /* Now create the field with the original size.  */\n+  field  = create_field_decl (get_identifier (\"F\"), type, record, orig_size,\n+\t\t\t      bitsize_zero_node, 0, 1);\n+  DECL_INTERNAL_P (field) = 1;\n+\n+  /* Do not emit debug info until after the auxiliary record is built.  */\n+  finish_record_type (record, field, 1, false);\n+\n+  /* Set the RM size if requested.  */\n+  if (set_rm_size)\n+    {\n+      SET_TYPE_ADA_SIZE (record, size ? size : orig_size);\n+\n+      /* If the padded type is complete and has constant size, we canonicalize\n+\t it by means of the hash table.  This is consistent with the language\n+\t semantics and ensures that gigi and the middle-end have a common view\n+\t of these padded types.  */\n+      if (TREE_CONSTANT (TYPE_SIZE (record)))\n+\t{\n+\t  hashval_t hashcode;\n+\t  struct pad_type_hash in, *h;\n+\t  void **loc;\n+\n+\t  hashcode = iterative_hash_object (TYPE_HASH (type), 0);\n+\t  hashcode = iterative_hash_expr (TYPE_SIZE (record), hashcode);\n+\t  hashcode = iterative_hash_hashval_t (TYPE_ALIGN (record), hashcode);\n+\t  hashcode = iterative_hash_expr (TYPE_ADA_SIZE (record), hashcode);\n+\n+\t  in.hash = hashcode;\n+\t  in.type = record;\n+\t  h = (struct pad_type_hash *)\n+\t\thtab_find_with_hash (pad_type_hash_table, &in, hashcode);\n+\t  if (h)\n+\t    {\n+\t      record = h->type;\n+\t      goto built;\n+\t    }\n+\n+\t  h = ggc_alloc_pad_type_hash ();\n+\t  h->hash = hashcode;\n+\t  h->type = record;\n+\t  loc = htab_find_slot_with_hash (pad_type_hash_table, h, hashcode,\n+\t\t\t\t\t  INSERT);\n+\t  *loc = (void *)h;\n+\t}\n+    }\n+\n+  /* Unless debugging information isn't being written for the input type,\n+     write a record that shows what we are a subtype of and also make a\n+     variable that indicates our size, if still variable.  */\n+  if (TREE_CODE (orig_size) != INTEGER_CST\n+      && TYPE_NAME (record)\n+      && TYPE_NAME (type)\n+      && !(TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t   && DECL_IGNORED_P (TYPE_NAME (type))))\n+    {\n+      tree marker = make_node (RECORD_TYPE);\n+      tree name = TYPE_NAME (record);\n+      tree orig_name = TYPE_NAME (type);\n+\n+      if (TREE_CODE (name) == TYPE_DECL)\n+\tname = DECL_NAME (name);\n+\n+      if (TREE_CODE (orig_name) == TYPE_DECL)\n+\torig_name = DECL_NAME (orig_name);\n+\n+      TYPE_NAME (marker) = concat_name (name, \"XVS\");\n+      finish_record_type (marker,\n+\t\t\t  create_field_decl (orig_name,\n+\t\t\t\t\t     build_reference_type (type),\n+\t\t\t\t\t     marker, NULL_TREE, NULL_TREE,\n+\t\t\t\t\t     0, 0),\n+\t\t\t  0, true);\n+\n+      add_parallel_type (record, marker);\n+\n+      if (definition && size && TREE_CODE (size) != INTEGER_CST)\n+\tTYPE_SIZE_UNIT (marker)\n+\t  = create_var_decl (concat_name (name, \"XVZ\"), NULL_TREE, sizetype,\n+\t\t\t     TYPE_SIZE_UNIT (record), false, false, false,\n+\t\t\t     false, NULL, gnat_entity);\n+    }\n+\n+  rest_of_record_type_compilation (record);\n+\n+built:\n+  /* If the size was widened explicitly, maybe give a warning.  Take the\n+     original size as the maximum size of the input if there was an\n+     unconstrained record involved and round it up to the specified alignment,\n+     if one was specified.  But don't do it if we are just annotating types\n+     and the type is tagged, since tagged types aren't fully laid out in this\n+     mode.  */\n+  if (!size\n+      || TREE_CODE (size) == COND_EXPR\n+      || TREE_CODE (size) == MAX_EXPR\n+      || No (gnat_entity)\n+      || (type_annotate_only && Is_Tagged_Type (Etype (gnat_entity))))\n+    return record;\n+\n+  if (CONTAINS_PLACEHOLDER_P (orig_size))\n+    orig_size = max_size (orig_size, true);\n+\n+  if (align)\n+    orig_size = round_up (orig_size, align);\n+\n+  if (!operand_equal_p (size, orig_size, 0)\n+      && !(TREE_CODE (size) == INTEGER_CST\n+\t   && TREE_CODE (orig_size) == INTEGER_CST\n+\t   && (TREE_OVERFLOW (size)\n+\t       || TREE_OVERFLOW (orig_size)\n+\t       || tree_int_cst_lt (size, orig_size))))\n+    {\n+      Node_Id gnat_error_node = Empty;\n+\n+      if (Is_Packed_Array_Type (gnat_entity))\n+\tgnat_entity = Original_Array_Type (gnat_entity);\n+\n+      if ((Ekind (gnat_entity) == E_Component\n+\t   || Ekind (gnat_entity) == E_Discriminant)\n+\t  && Present (Component_Clause (gnat_entity)))\n+\tgnat_error_node = Last_Bit (Component_Clause (gnat_entity));\n+      else if (Present (Size_Clause (gnat_entity)))\n+\tgnat_error_node = Expression (Size_Clause (gnat_entity));\n+\n+      /* Generate message only for entities that come from source, since\n+\t if we have an entity created by expansion, the message will be\n+\t generated for some other corresponding source entity.  */\n+      if (Comes_From_Source (gnat_entity))\n+\t{\n+\t  if (Present (gnat_error_node))\n+\t    post_error_ne_tree (\"{^ }bits of & unused?\",\n+\t\t\t\tgnat_error_node, gnat_entity,\n+\t\t\t\tsize_diffop (size, orig_size));\n+\t  else if (is_component_type)\n+\t    post_error_ne_tree (\"component of& padded{ by ^ bits}?\",\n+\t\t\t\tgnat_entity, gnat_entity,\n+\t\t\t\tsize_diffop (size, orig_size));\n+\t}\n+    }\n+\n+  return record;\n+}\n+\f\n+/* Relate the alias sets of GNU_NEW_TYPE and GNU_OLD_TYPE according to OP.\n+   If this is a multi-dimensional array type, do this recursively.\n+\n+   OP may be\n+   - ALIAS_SET_COPY:     the new set is made a copy of the old one.\n+   - ALIAS_SET_SUPERSET: the new set is made a superset of the old one.\n+   - ALIAS_SET_SUBSET:   the new set is made a subset of the old one.  */\n+\n+void\n+relate_alias_sets (tree gnu_new_type, tree gnu_old_type, enum alias_set_op op)\n+{\n+  /* Remove any padding from GNU_OLD_TYPE.  It doesn't matter in the case\n+     of a one-dimensional array, since the padding has the same alias set\n+     as the field type, but if it's a multi-dimensional array, we need to\n+     see the inner types.  */\n+  while (TREE_CODE (gnu_old_type) == RECORD_TYPE\n+\t && (TYPE_JUSTIFIED_MODULAR_P (gnu_old_type)\n+\t     || TYPE_PADDING_P (gnu_old_type)))\n+    gnu_old_type = TREE_TYPE (TYPE_FIELDS (gnu_old_type));\n+\n+  /* Unconstrained array types are deemed incomplete and would thus be given\n+     alias set 0.  Retrieve the underlying array type.  */\n+  if (TREE_CODE (gnu_old_type) == UNCONSTRAINED_ARRAY_TYPE)\n+    gnu_old_type\n+      = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_old_type))));\n+  if (TREE_CODE (gnu_new_type) == UNCONSTRAINED_ARRAY_TYPE)\n+    gnu_new_type\n+      = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_new_type))));\n+\n+  if (TREE_CODE (gnu_new_type) == ARRAY_TYPE\n+      && TREE_CODE (TREE_TYPE (gnu_new_type)) == ARRAY_TYPE\n+      && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_new_type)))\n+    relate_alias_sets (TREE_TYPE (gnu_new_type), TREE_TYPE (gnu_old_type), op);\n+\n+  switch (op)\n+    {\n+    case ALIAS_SET_COPY:\n+      /* The alias set shouldn't be copied between array types with different\n+\t aliasing settings because this can break the aliasing relationship\n+\t between the array type and its element type.  */\n+#ifndef ENABLE_CHECKING\n+      if (flag_strict_aliasing)\n+#endif\n+\tgcc_assert (!(TREE_CODE (gnu_new_type) == ARRAY_TYPE\n+\t\t      && TREE_CODE (gnu_old_type) == ARRAY_TYPE\n+\t\t      && TYPE_NONALIASED_COMPONENT (gnu_new_type)\n+\t\t\t != TYPE_NONALIASED_COMPONENT (gnu_old_type)));\n+\n+      TYPE_ALIAS_SET (gnu_new_type) = get_alias_set (gnu_old_type);\n+      break;\n+\n+    case ALIAS_SET_SUBSET:\n+    case ALIAS_SET_SUPERSET:\n+      {\n+\talias_set_type old_set = get_alias_set (gnu_old_type);\n+\talias_set_type new_set = get_alias_set (gnu_new_type);\n+\n+\t/* Do nothing if the alias sets conflict.  This ensures that we\n+\t   never call record_alias_subset several times for the same pair\n+\t   or at all for alias set 0.  */\n+\tif (!alias_sets_conflict_p (old_set, new_set))\n+\t  {\n+\t    if (op == ALIAS_SET_SUBSET)\n+\t      record_alias_subset (old_set, new_set);\n+\t    else\n+\t      record_alias_subset (new_set, old_set);\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  record_component_aliases (gnu_new_type);\n+}\n+\f\n /* Record TYPE as a builtin type for Ada.  NAME is the name of the type.\n    ARTIFICIAL_P is true if it's a type that was generated by the compiler.  */\n \n@@ -2224,14 +2934,6 @@ gnat_types_compatible_p (tree t1, tree t2)\n \t      && gnat_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))))\n     return 1;\n \n-  /* Padding record types are also compatible if they pad the same\n-     type and have the same constant size.  */\n-  if (code == RECORD_TYPE\n-      && TYPE_PADDING_P (t1) && TYPE_PADDING_P (t2)\n-      && TREE_TYPE (TYPE_FIELDS (t1)) == TREE_TYPE (TYPE_FIELDS (t2))\n-      && tree_int_cst_equal (TYPE_SIZE (t1), TYPE_SIZE (t2)))\n-    return 1;\n-\n   return 0;\n }\n \n@@ -3705,7 +4407,7 @@ convert (tree type, tree expr)\n \t   && TYPE_PADDING_P (type) && TYPE_PADDING_P (etype)\n \t   && (!TREE_CONSTANT (TYPE_SIZE (type))\n \t       || !TREE_CONSTANT (TYPE_SIZE (etype))\n-\t       || gnat_types_compatible_p (type, etype)\n+\t       || TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (etype)\n \t       || TYPE_NAME (TREE_TYPE (TYPE_FIELDS (type)))\n \t\t  == TYPE_NAME (TREE_TYPE (TYPE_FIELDS (etype)))))\n     ;\n@@ -3734,8 +4436,8 @@ convert (tree type, tree expr)\n       if (TREE_CODE (expr) == COMPONENT_REF\n \t  && TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (expr, 0)))\n \t  && (!TREE_CONSTANT (TYPE_SIZE (type))\n-\t      || gnat_types_compatible_p (type,\n-\t\t\t\t\t  TREE_TYPE (TREE_OPERAND (expr, 0)))\n+\t      || TYPE_MAIN_VARIANT (type)\n+\t\t == TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (expr, 0)))\n \t      || (ecode == RECORD_TYPE\n \t\t  && TYPE_NAME (etype)\n \t\t     == TYPE_NAME (TREE_TYPE (TYPE_FIELDS (type))))))"}, {"sha": "e104b4f0e34abf2a2f066d5b817589c6db182e19", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=842d4ee2add5d9bc624857c3545d27f70e2fd37b", "patch": "@@ -789,16 +789,28 @@ build_binary_op (enum tree_code op_code, tree result_type,\n       else if (TYPE_IS_PADDING_P (left_type)\n \t       && TREE_CONSTANT (TYPE_SIZE (left_type))\n \t       && ((TREE_CODE (right_operand) == COMPONENT_REF\n-\t\t    && TYPE_IS_PADDING_P\n-\t\t       (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n-\t\t    && gnat_types_compatible_p\n-\t\t       (left_type,\n-\t\t\tTREE_TYPE (TREE_OPERAND (right_operand, 0))))\n+\t\t    && TYPE_MAIN_VARIANT (left_type)\n+\t\t       == TYPE_MAIN_VARIANT\n+\t\t\t  (TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n \t\t   || (TREE_CODE (right_operand) == CONSTRUCTOR\n \t\t       && !CONTAINS_PLACEHOLDER_P\n \t\t\t   (DECL_SIZE (TYPE_FIELDS (left_type)))))\n \t       && !integer_zerop (TYPE_SIZE (right_type)))\n-\toperation_type = left_type;\n+\t{\n+\t  /* We make an exception for a BLKmode type padding a non-BLKmode\n+\t     inner type and do the conversion of the LHS right away, since\n+\t     unchecked_convert wouldn't do it properly.  */\n+\t  if (TYPE_MODE (left_type) == BLKmode\n+\t      && TYPE_MODE (right_type) != BLKmode\n+\t      && TREE_CODE (right_operand) != CONSTRUCTOR)\n+\t    {\n+\t      operation_type = right_type;\n+\t      left_operand = convert (operation_type, left_operand);\n+\t      left_type = operation_type;\n+\t    }\n+\t  else\n+\t    operation_type = left_type;\n+\t}\n \n       /* If we have a call to a function that returns an unconstrained type\n \t with default discriminant on the RHS, use the RHS type (which is"}, {"sha": "8a988c1173adddb6c398c8c9a34ae3e0d45ade04", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=842d4ee2add5d9bc624857c3545d27f70e2fd37b", "patch": "@@ -1,3 +1,8 @@\n+2012-05-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.target/ia64/pr48496.c: New test.\n+\t* gcc.target/ia64/pr52657.c: Likewise.\n+\n 2012-05-05  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR c/43772"}, {"sha": "64d95558e88524ffeac62721d6b63003e6325c8e", "filename": "gcc/testsuite/gnat.dg/discr36.adb", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr36.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr36.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr36.adb?ref=842d4ee2add5d9bc624857c3545d27f70e2fd37b", "patch": "@@ -0,0 +1,19 @@\n+-- { dg-do compile }\n+\n+with Discr36_Pkg;\n+\n+package body Discr36 is\n+\n+  function N return Natural is begin return 0; end;\n+\n+  type Arr is array (1 .. N) of R;\n+\n+  function My_Func is new Discr36_Pkg.Func (Arr);\n+\n+  procedure Proc is\n+    A : constant Arr := My_Func;\n+  begin\n+    null;\n+  end;\n+\n+end Discr36;"}, {"sha": "9e39eb1c7c949543e353028ce08fd2d4f9b6b3f5", "filename": "gcc/testsuite/gnat.dg/discr36.ads", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr36.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr36.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr36.ads?ref=842d4ee2add5d9bc624857c3545d27f70e2fd37b", "patch": "@@ -0,0 +1,12 @@\n+package Discr36 is\r\n+\r\n+  type R (D : Boolean := True) is record\r\n+    case D is\r\n+      when True  => I : Integer;\r\n+      when False => null;\r\n+    end case;\r\n+  end record;\r\n+\r\n+  function N return Natural;\r\n+\r\n+end Discr36;\r"}, {"sha": "5398a22e39d7024917fea3afae3b9590192345af", "filename": "gcc/testsuite/gnat.dg/discr36_pkg.adb", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr36_pkg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr36_pkg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr36_pkg.adb?ref=842d4ee2add5d9bc624857c3545d27f70e2fd37b", "patch": "@@ -0,0 +1,10 @@\n+package body Discr36_Pkg is\r\n+\r\n+  function Func return T is\r\n+    Ret : T;\r\n+    pragma Warnings (Off, Ret);\r\n+  begin\r\n+    return Ret;\r\n+  end;\r\n+\r\n+end Discr36_Pkg;\r"}, {"sha": "49792d4618326a095b06dfa12acf1b718af20278", "filename": "gcc/testsuite/gnat.dg/discr36_pkg.ads", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr36_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842d4ee2add5d9bc624857c3545d27f70e2fd37b/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr36_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr36_pkg.ads?ref=842d4ee2add5d9bc624857c3545d27f70e2fd37b", "patch": "@@ -0,0 +1,7 @@\n+package Discr36_Pkg is\r\n+\r\n+  generic\r\n+    type T is private;\r\n+  function Func return T;\r\n+\r\n+end Discr36_Pkg;\r"}]}