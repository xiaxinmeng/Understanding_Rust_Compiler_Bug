{"sha": "a29e103468238970130eeccec0bc239490a91300", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI5ZTEwMzQ2ODIzODk3MDEzMGVlY2NlYzBiYzIzOTQ5MGE5MTMwMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2002-04-06T16:15:20Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2002-04-06T16:15:20Z"}, "message": "re PR c++/525 (Problem with Multiple Inheritance and -pedantic)\n\n        PR c++/525\n        * init.c (build_member_call): Use build_scoped_ref.\n        (resolve_offset_ref): Likewise.\n        * call.c (build_scoped_method_call): Likewise.\n        * tree.c (maybe_dummy_object): Kludge around current_class_type being\n        wrong.\n        * typeck2.c (build_scoped_ref): Return the binfo via binfo_p parm.\n        * cp-tree.h: Adjust.\n\n        * init.c (push_base_cleanups): Just use build_scoped_method_call.\n\nFrom-SVN: r51956", "tree": {"sha": "b6c3cda163f08bc0122fe499f1ac70867a11fc42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6c3cda163f08bc0122fe499f1ac70867a11fc42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a29e103468238970130eeccec0bc239490a91300", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a29e103468238970130eeccec0bc239490a91300", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a29e103468238970130eeccec0bc239490a91300", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a29e103468238970130eeccec0bc239490a91300/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f62ea15730209b4024837b30e9f0eb7e39fae3d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f62ea15730209b4024837b30e9f0eb7e39fae3d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f62ea15730209b4024837b30e9f0eb7e39fae3d9"}], "stats": {"total": 153, "additions": 76, "deletions": 77}, "files": [{"sha": "524cbeaf3b5bba721bd0a9b4b63f8ff5cb5f8e8c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29e103468238970130eeccec0bc239490a91300/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29e103468238970130eeccec0bc239490a91300/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a29e103468238970130eeccec0bc239490a91300", "patch": "@@ -1,5 +1,16 @@\n 2002-04-06  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/525\n+\t* init.c (build_member_call): Use build_scoped_ref.\n+\t(resolve_offset_ref): Likewise.\n+\t* call.c (build_scoped_method_call): Likewise.\n+\t* tree.c (maybe_dummy_object): Kludge around current_class_type being \n+\twrong.\n+\t* typeck2.c (build_scoped_ref): Return the binfo via binfo_p parm.\n+\t* cp-tree.h: Adjust.\n+\t\n+\t* init.c (push_base_cleanups): Just use build_scoped_method_call.\n+\n \tPR c++/6179\n \t* method.c (implicitly_declare_fn): Pass unqualified type to \n \tsynthesize_exception_spec."}, {"sha": "d341fb080847031fe53316f7814a898eeb825a5b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29e103468238970130eeccec0bc239490a91300/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29e103468238970130eeccec0bc239490a91300/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a29e103468238970130eeccec0bc239490a91300", "patch": "@@ -298,27 +298,10 @@ build_scoped_method_call (exp, basetype, name, parms)\n       return error_mark_node;\n     }\n \n-  if (! binfo)\n-    {\n-      binfo = lookup_base (type, basetype, ba_check, NULL);\n-      if (binfo == error_mark_node)\n-\treturn error_mark_node;\n-      if (! binfo)\n-\terror_not_base_type (basetype, type);\n-    }\n+  decl = build_scoped_ref (exp, basetype, &binfo);\n \n   if (binfo)\n     {\n-      if (TREE_CODE (exp) == INDIRECT_REF)\n-\t{\n-\t  decl = build_base_path (PLUS_EXPR,\n-\t\t\t\t  build_unary_op (ADDR_EXPR, exp, 0),\n-\t\t\t\t  binfo, 1);\n-\t  decl = build_indirect_ref (decl, NULL);\n-\t}\n-      else\n-\tdecl = build_scoped_ref (exp, basetype);\n-\n       /* Call to a destructor.  */\n       if (TREE_CODE (name) == BIT_NOT_EXPR)\n \t{"}, {"sha": "8b3a256d5b74f1b475dce43b55c3d348e5bb3a53", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29e103468238970130eeccec0bc239490a91300/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29e103468238970130eeccec0bc239490a91300/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a29e103468238970130eeccec0bc239490a91300", "patch": "@@ -4387,7 +4387,7 @@ extern int abstract_virtuals_error\t\tPARAMS ((tree, tree));\n \n extern tree store_init_value\t\t\tPARAMS ((tree, tree));\n extern tree digest_init\t\t\t\tPARAMS ((tree, tree, tree *));\n-extern tree build_scoped_ref\t\t\tPARAMS ((tree, tree));\n+extern tree build_scoped_ref\t\t\tPARAMS ((tree, tree, tree *));\n extern tree build_x_arrow\t\t\tPARAMS ((tree));\n extern tree build_m_component_ref\t\tPARAMS ((tree, tree));\n extern tree build_functional_cast\t\tPARAMS ((tree, tree));"}, {"sha": "5caa69cee221cb153d8aee21ad7addd46747a33c", "filename": "gcc/cp/init.c", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29e103468238970130eeccec0bc239490a91300/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29e103468238970130eeccec0bc239490a91300/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a29e103468238970130eeccec0bc239490a91300", "patch": "@@ -1496,20 +1496,13 @@ build_member_call (type, name, parmlist)\n   decl = maybe_dummy_object (type, &basetype_path);\n \n   /* Convert 'this' to the specified type to disambiguate conversion\n-     to the function's context.  Apparently Standard C++ says that we\n-     shouldn't do this.  */\n-  if (decl == current_class_ref\n-      && ! pedantic\n-      && ACCESSIBLY_UNIQUELY_DERIVED_P (type, current_class_type))\n-    {\n-      tree olddecl = current_class_ptr;\n-      tree oldtype = TREE_TYPE (TREE_TYPE (olddecl));\n-      if (oldtype != type)\n-\t{\n-\t  tree newtype = build_qualified_type (type, TYPE_QUALS (oldtype));\n-\t  decl = convert_force (build_pointer_type (newtype), olddecl, 0);\n-\t  decl = build_indirect_ref (decl, NULL);\n-\t}\n+     to the function's context.  */\n+  if (decl == current_class_ref)\n+    {\n+      basetype_path = NULL_TREE;\n+      decl = build_scoped_ref (decl, type, &basetype_path);\n+      if (decl == error_mark_node)\n+\treturn error_mark_node;\n     }\n \n   if (method_name == constructor_name (type)\n@@ -1819,21 +1812,15 @@ resolve_offset_ref (exp)\n   if (TREE_CODE (member) == FIELD_DECL\n       && (base == current_class_ref || is_dummy_object (base)))\n     {\n-      tree binfo = TYPE_BINFO (current_class_type);\n+      tree binfo = NULL_TREE;\n \n       /* Try to get to basetype from 'this'; if that doesn't work,\n          nothing will.  */\n       base = current_class_ref;\n \n       /* First convert to the intermediate base specified, if appropriate.  */\n       if (TREE_CODE (exp) == OFFSET_REF && TREE_CODE (type) == OFFSET_TYPE)\n-\t{\n-\t  binfo = binfo_or_else (TYPE_OFFSET_BASETYPE (type),\n-\t\t\t\t current_class_type);\n-\t  if (!binfo)\n-\t    return error_mark_node;\n-\t  base = build_base_path (PLUS_EXPR, base, binfo, 1);\n-\t}\n+\tbase = build_scoped_ref (base, TYPE_OFFSET_BASETYPE (type), &binfo);\n \n       return build_component_ref (base, member, binfo, 1);\n     }\n@@ -3225,7 +3212,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n /* At the beginning of a destructor, push cleanups that will call the\n    destructors for our base classes and members.\n \n-   Called from setup_vtbl_ptr.  */\n+   Called from begin_destructor_body.  */\n \n void\n push_base_cleanups ()\n@@ -3255,21 +3242,9 @@ push_base_cleanups ()\n \n \t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (base_type))\n \t    {\n-\t      tree base_ptr_type = build_pointer_type (base_type);\n-\t      expr = current_class_ptr;\n-\t          \n-\t      /* Convert to the basetype here, as we know the layout is\n-\t\t fixed. What is more, if we let build_method_call do it,\n-\t\t it will use the vtable, which may have been clobbered\n-\t\t by the deletion of our primary base.  */\n-                  \n-\t      expr = build1 (NOP_EXPR, base_ptr_type, expr);\n-\t      expr = build (PLUS_EXPR, base_ptr_type, expr,\n-\t\t\t    BINFO_OFFSET (vbase));\n-\t      expr = build_indirect_ref (expr, NULL);\n-\t      expr = build_method_call (expr, base_dtor_identifier,\n-\t\t\t\t\tNULL_TREE, vbase,\n-\t\t\t\t\tLOOKUP_NORMAL);\n+\t      expr = build_scoped_method_call (current_class_ref, vbase,\n+\t\t\t\t\t       base_dtor_identifier,\n+\t\t\t\t\t       NULL_TREE);\n \t      expr = build (COND_EXPR, void_type_node, cond,\n \t\t\t    expr, void_zero_node);\n \t      finish_decl_cleanup (NULL_TREE, expr);"}, {"sha": "30a6ddb32355d1fc0552c3e8c1729647063cce92", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29e103468238970130eeccec0bc239490a91300/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29e103468238970130eeccec0bc239490a91300/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a29e103468238970130eeccec0bc239490a91300", "patch": "@@ -5559,7 +5559,11 @@ tsubst_default_argument (fn, type, arg)\n        };\n      \n      we must be careful to do name lookup in the scope of S<T>,\n-     rather than in the current class.  */\n+     rather than in the current class.\n+\n+     ??? current_class_type affects a lot more than name lookup.  This is\n+     very fragile.  Fortunately, it will go away when we do 2-phase name\n+     binding properly.  */\n   if (DECL_CLASS_SCOPE_P (fn))\n     pushclass (DECL_CONTEXT (fn), 2);\n "}, {"sha": "641d82b2400e5d155683bf732ba59c80fb128c9b", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29e103468238970130eeccec0bc239490a91300/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29e103468238970130eeccec0bc239490a91300/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a29e103468238970130eeccec0bc239490a91300", "patch": "@@ -1844,7 +1844,11 @@ maybe_dummy_object (type, binfop)\n   if (binfop)\n     *binfop = binfo;\n   \n-  if (current_class_ref && context == current_class_type)\n+  if (current_class_ref && context == current_class_type\n+      // Kludge: Make sure that current_class_type is actually correct.\n+      // It might not be if we're in the middle of tsubst_default_argument.\n+      && same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (current_class_ref)),\n+\t\t      current_class_type))\n     decl = current_class_ref;\n   else\n     decl = build_dummy_object (context);"}, {"sha": "be07b2e457f3361354dcc43f6199cac2943c0732", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29e103468238970130eeccec0bc239490a91300/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29e103468238970130eeccec0bc239490a91300/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a29e103468238970130eeccec0bc239490a91300", "patch": "@@ -1826,10 +1826,9 @@ build_object_ref (datum, basetype, field)\n     }\n   else if (is_aggr_type (basetype, 1))\n     {\n-      tree binfo = binfo_or_else (basetype, dtype);\n-      if (binfo)\n-\treturn build_x_component_ref (build_scoped_ref (datum, basetype),\n-\t\t\t\t      field, binfo, 1);\n+      tree binfo = NULL_TREE;\n+      datum = build_scoped_ref (datum, basetype, &binfo);\n+      return build_x_component_ref (datum, field, binfo, 1);\n     }\n   return error_mark_node;\n }"}, {"sha": "d7ac3d764be5c2422b5a6d8a28e1f5cd0fd73aca", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29e103468238970130eeccec0bc239490a91300/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29e103468238970130eeccec0bc239490a91300/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=a29e103468238970130eeccec0bc239490a91300", "patch": "@@ -954,7 +954,7 @@ process_init_constructor (type, init, elts)\n \f\n /* Given a structure or union value DATUM, construct and return\n    the structure or union component which results from narrowing\n-   that value by the type specified in BASETYPE.  For example, given the\n+   that value to the base specified in BASETYPE.  For example, given the\n    hierarchy\n \n    class L { int ii; };\n@@ -975,29 +975,36 @@ process_init_constructor (type, init, elts)\n    I used to think that this was nonconformant, that the standard specified\n    that first we look up ii in A, then convert x to an L& and pull out the\n    ii part.  But in fact, it does say that we convert x to an A&; A here\n-   is known as the \"naming class\".  (jason 2000-12-19) */\n+   is known as the \"naming class\".  (jason 2000-12-19)\n+\n+   BINFO_P points to a variable initialized either to NULL_TREE or to the\n+   binfo for the specific base subobject we want to convert to.  */\n \n tree\n-build_scoped_ref (datum, basetype)\n+build_scoped_ref (datum, basetype, binfo_p)\n      tree datum;\n      tree basetype;\n+     tree *binfo_p;\n {\n-  tree ref;\n   tree binfo;\n \n   if (datum == error_mark_node)\n     return error_mark_node;\n-  binfo = lookup_base (TREE_TYPE (datum), basetype, ba_check, NULL);\n+  if (*binfo_p)\n+    binfo = *binfo_p;\n+  else\n+    binfo = lookup_base (TREE_TYPE (datum), basetype, ba_check, NULL);\n \n-  if (binfo == error_mark_node)\n-    return error_mark_node;\n-  if (!binfo)\n-    return error_not_base_type (TREE_TYPE (datum), basetype);\n-  \n-  ref = build_unary_op (ADDR_EXPR, datum, 0);\n-  ref = build_base_path (PLUS_EXPR, ref, binfo, 1);\n+  if (!binfo || binfo == error_mark_node)\n+    {\n+      *binfo_p = NULL_TREE;\n+      if (!binfo)\n+\terror_not_base_type (basetype, TREE_TYPE (datum));\n+      return error_mark_node;\n+    }\n \n-  return build_indirect_ref (ref, \"(compiler error in build_scoped_ref)\");\n+  *binfo_p = binfo;\n+  return build_base_path (PLUS_EXPR, datum, binfo, 1);\n }\n \n /* Build a reference to an object specified by the C++ `->' operator."}, {"sha": "8a3be65581b13489316e427503d42f6099950cd2", "filename": "gcc/testsuite/g++.dg/lookup/disamb1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29e103468238970130eeccec0bc239490a91300/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fdisamb1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29e103468238970130eeccec0bc239490a91300/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fdisamb1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fdisamb1.C?ref=a29e103468238970130eeccec0bc239490a91300", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/525\n+// Bug: With -pedantic, we weren't converting this to D1* for the call.\n+\n+struct A\n+{\n+  void f();\n+};\n+\n+struct B1: public A {};\n+struct B2: public A {};\n+\n+struct C: public B1, public B2\n+{\n+  void g() { B1::f(); };\n+};"}, {"sha": "91e114a9fcb72d4ce26272539dc7f63a0741d011", "filename": "gcc/testsuite/g++.old-deja/g++.jason/access8.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29e103468238970130eeccec0bc239490a91300/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Faccess8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29e103468238970130eeccec0bc239490a91300/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Faccess8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Faccess8.C?ref=a29e103468238970130eeccec0bc239490a91300", "patch": "@@ -25,5 +25,6 @@ void inh::myf(int i) {\n }\n \n void top_t::myf(int i) {\n-        inh::myf(i);\n+        inh::myf(i);\t\t// ERROR - cannot convert to inh\n+\tmel::myf(i);\n }"}]}