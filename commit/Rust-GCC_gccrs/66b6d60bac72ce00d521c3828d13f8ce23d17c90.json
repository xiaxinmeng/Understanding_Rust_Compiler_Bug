{"sha": "66b6d60bac72ce00d521c3828d13f8ce23d17c90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZiNmQ2MGJhYzcyY2UwMGQ1MjFjMzgyOGQxM2Y4Y2UyM2QxN2M5MA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-05-09T22:13:02Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-05-09T22:13:02Z"}, "message": "(NAN): Define for support of Not-a-Number bit patterns.\n\n(make_nan): New function outputs a NaN in requested machine mode.\n(eisnan, eiisnan, enan, einan, eiisinf, eiinfin): New functions.\n(earith, etrunci, etruncui, ereal_negate, ereal_ldexp,\nreal_value_truncate, esub, eadd, emul, ediv, eremain):\nReturn NaN arg back to caller.\n(eroundi, eroundui, ereal_to_int): NaN to integer returns -1\nand a warning.\n(target_isnan): Check for NaN.\n(eneg): No-op if NaN.\n(eisneg, eisinf): False if NaN.\n(emovi, emovo): Handle NaN conversions.\n(esub, eadd): Infinity minus infinity = NaN and INVALID warning.\n(ediv): 0/0, inf/inf = NaN and INVALID warning.\n(emul): 0 * inf = NaN and INVALID warning.\n(e24toe, e53toe, e64toe): Generate e-type NaN for NaN input.\n(etoe24, etoe53, etoe64): Output NaN in appropriate machine mode.\n(ecmp): Unordered compare returns -2.\n(etoasc): NaN produces ASCII string \"NaN\".\n(asctoe): Unrecognizable input produces e-type NaN.\n(eremain): x REM y = NaN if y = 0 or x = infinity.\n\nFrom-SVN: r4401", "tree": {"sha": "34720b801d0dcc635a501f5a44e2738ec3edc6ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34720b801d0dcc635a501f5a44e2738ec3edc6ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66b6d60bac72ce00d521c3828d13f8ce23d17c90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66b6d60bac72ce00d521c3828d13f8ce23d17c90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66b6d60bac72ce00d521c3828d13f8ce23d17c90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66b6d60bac72ce00d521c3828d13f8ce23d17c90/comments", "author": null, "committer": null, "parents": [{"sha": "5ec88efd8236e258640bc1dd8911cfff18c41fc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ec88efd8236e258640bc1dd8911cfff18c41fc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ec88efd8236e258640bc1dd8911cfff18c41fc2"}], "stats": {"total": 717, "additions": 597, "deletions": 120}, "files": [{"sha": "d3dd197261ae430006c8df8c6dc955cf735fb119", "filename": "gcc/real.c", "status": "modified", "additions": 597, "deletions": 120, "changes": 717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b6d60bac72ce00d521c3828d13f8ce23d17c90/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b6d60bac72ce00d521c3828d13f8ce23d17c90/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=66b6d60bac72ce00d521c3828d13f8ce23d17c90", "patch": "@@ -60,13 +60,37 @@ research.att.com: netlib/cephes/ldouble.shar.Z  */\n \n /* Type of computer arithmetic.\n  * Only one of DEC, MIEEE, IBMPC, or UNK should get defined.\n- * The following modification converts gcc macros into the ones\n- * used by ieee.c.\n- *\n- * Note: long double formats differ between IBMPC and MIEEE\n- * by more than just endian-ness.\n  */\n \n+/* `MIEEE' refers generically to big-endian IEEE floating-point data\n+   structure.  This definition should work in SFmode `float' type and\n+   DFmode `double' type on virtually all big-endian IEEE machines.\n+   If LONG_DOUBLE_TYPE_SIZE has been defined to be 96, then MIEEE\n+   also invokes the particular XFmode (`long double' type) data\n+   structure used by the Motorola 680x0 series processors.\n+\n+   `IBMPC' refers generally to little-endian IEEE machines. In this\n+   case, if LONG_DOUBLE_TYPE_SIZE has been defined to be 96, then\n+   IBMPC also invokes the particular XFmode `long double' data\n+   structure used by the Intel 80x86 series processors.\n+\n+   `DEC' refers specifically to the Digital Equipment Corp PDP-11\n+   and VAX floating point data structure.  This model currently\n+   supports no type wider than DFmode.\n+\n+   If LONG_DOUBLE_TYPE_SIZE = 64 (the default, unless tm.h defines it)\n+   then `long double' and `double' are both implemented, but they\n+   both mean DFmode.  In this case, the software floating-point\n+   support available here is activated by writing\n+      #define REAL_ARITHMETIC\n+   in tm.h. \n+\n+   The case LONG_DOUBLE_TYPE_SIZE = 128 activates TFmode support\n+   (Not Yet Implemented) and may deactivate XFmode since\n+   `long double' is used to refer to both modes.    */\n+\n+/* The following converts gcc macros into the ones used by this file.  */\n+\n /* REAL_ARITHMETIC defined means that macros in real.h are\n    defined to call emulator functions.  */\n #ifdef REAL_ARITHMETIC\n@@ -114,11 +138,19 @@ unknown arithmetic type\n \n #endif /* REAL_ARITHMETIC not defined */\n \n-/* Define for support of infinity.  */\n+/* Define INFINITY for support of infinity.\n+   Define NANS for support of Not-a-Number's (NaN's).  */\n #ifndef DEC\n #define INFINITY\n+#define NANS\n #endif\n \n+/* Support of NaNs requires support of infinity. */\n+#ifdef NANS\n+#ifndef INFINITY\n+#define INFINITY\n+#endif\n+#endif\n \n /* ehead.h\n  *\n@@ -255,17 +287,18 @@ do { EMUSHORT w[4];\t\t\\\n \n void warning ();\n extern int extra_warnings;\n-int ecmp (), enormlz (), eshift (), eisneg (), eisinf ();\n+int ecmp (), enormlz (), eshift ();\n+int eisneg (), eisinf (), eisnan (), eiisinf (), eiisnan ();\n void eadd (), esub (), emul (), ediv ();\n void eshup1 (), eshup8 (), eshup6 (), eshdn1 (), eshdn8 (), eshdn6 ();\n void eabs (), eneg (), emov (), eclear (), einfin (), efloor ();\n void eldexp (), efrexp (), eifrac (), euifrac (), ltoe (), ultoe ();\n-void eround (), ereal_to_decimal ();\n+void eround (), ereal_to_decimal (), eiinfin (), einan ();\n void esqrt (), elog (), eexp (), etanh (), epow ();\n void asctoe (), asctoe24 (), asctoe53 (), asctoe64 ();\n void etoasc (), e24toasc (), e53toasc (), e64toasc ();\n void etoe64 (), etoe53 (), etoe24 (), e64toe (), e53toe (), e24toe ();\n-void mtherr ();\n+void mtherr (), make_nan ();\n extern unsigned EMUSHORT ezero[], ehalf[], eone[], etwo[];\n extern unsigned EMUSHORT elog2[], esqrt2[];\n \n@@ -372,6 +405,19 @@ earith (value, icode, r1, r2)\n \n   GET_REAL (r1, d1);\n   GET_REAL (r2, d2);\n+#ifdef NANS\n+/*  Return NaN input back to the caller. */\n+  if (eisnan (d1))\n+    {\n+      PUT_REAL (d1, value);\n+      return;\n+    }\n+  if (eisnan (d2))\n+    {\n+      PUT_REAL (d2, value);\n+      return;\n+    }\n+#endif\n   code = (enum tree_code) icode;\n   switch (code)\n     {\n@@ -390,7 +436,14 @@ earith (value, icode, r1, r2)\n     case RDIV_EXPR:\n #ifndef REAL_INFINITY\n       if (ecmp (d2, ezero) == 0)\n+\t{\n+#ifdef NANS\n+\tenan (v);\n+\tbreak;\n+#else\n \tabort ();\n+#endif\n+\t}\n #endif\n       ediv (d2, d1, v);\t/* d1/d2 */\n       break;\n@@ -417,7 +470,7 @@ PUT_REAL (v, value);\n \n \n /* Truncate REAL_VALUE_TYPE toward zero to signed HOST_WIDE_INT\n- * implements REAL_VALUE_FIX_TRUNCATE (x) (etrunci (x))\n+ * implements REAL_VALUE_RNDZINT (x) (etrunci (x))\n  */\n REAL_VALUE_TYPE \n etrunci (x)\n@@ -428,6 +481,10 @@ etrunci (x)\n   long l;\n \n   GET_REAL (&x, g);\n+#ifdef NANS\n+  if (eisnan (g))\n+    return (x);\n+#endif\n   eifrac (g, &l, f);\n   ltoe (&l, g);\n   PUT_REAL (g, &r);\n@@ -436,7 +493,7 @@ etrunci (x)\n \n \n /* Truncate REAL_VALUE_TYPE toward zero to unsigned HOST_WIDE_INT\n- * implements REAL_VALUE_UNSIGNED_FIX_TRUNCATE (x) (etruncui (x))\n+ * implements REAL_VALUE_UNSIGNED_RNDZINT (x) (etruncui (x))\n  */\n REAL_VALUE_TYPE \n etruncui (x)\n@@ -447,6 +504,10 @@ etruncui (x)\n   unsigned long l;\n \n   GET_REAL (&x, g);\n+#ifdef NANS\n+  if (eisnan (g))\n+    return (x);\n+#endif\n   euifrac (g, &l, f);\n   ultoe (&l, g);\n   PUT_REAL (g, &r);\n@@ -499,6 +560,10 @@ ereal_negate (x)\n   REAL_VALUE_TYPE r;\n \n   GET_REAL (&x, e);\n+#ifdef NANS\n+  if (eisnan (e))\n+    return (x);\n+#endif\n   eneg (e);\n   PUT_REAL (e, &r);\n   return (r);\n@@ -518,6 +583,13 @@ eroundi (x)\n   EMULONG l;\n \n   GET_REAL (&x, f);\n+#ifdef NANS\n+  if (eisnan (f))\n+    {\n+      warning (\"conversion from NaN to int\");\n+      return (-1);\n+    }\n+#endif\n   eround (f, g);\n   eifrac (g, &l, f);\n   return ((int) l);\n@@ -537,6 +609,13 @@ eroundui (x)\n   unsigned EMULONG l;\n \n   GET_REAL (&x, f);\n+#ifdef NANS\n+  if (eisnan (f))\n+    {\n+      warning (\"conversion from NaN to unsigned int\");\n+      return (-1);\n+    }\n+#endif\n   eround (f, g);\n   euifrac (g, &l, f);\n   return ((unsigned int)l);\n@@ -609,6 +688,15 @@ ereal_to_int (low, high, rr)\n   int s;\n \n   GET_REAL (&rr, d);\n+#ifdef NANS\n+  if (eisnan (&rr))\n+    {\n+      warning (\"conversion from NaN to int\");\n+      *low = -1;\n+      *high = -1;\n+      return;\n+    }\n+#endif\n   /* convert positive value */\n   s = 0;\n   if (eisneg (d))\n@@ -644,6 +732,10 @@ ereal_ldexp (x, n)\n   REAL_VALUE_TYPE r;\n \n   GET_REAL (&x, e);\n+#ifdef NANS\n+  if (eisnan (e))\n+    return (x);\n+#endif\n   eldexp (e, n, y);\n   PUT_REAL (y, &r);\n   return (r);\n@@ -669,17 +761,21 @@ target_isinf (x)\n }\n \n \n-/* Check whether an IEEE double precision number is a NaN. */\n+/* Check whether a REAL_VALUE_TYPE item is a NaN. */\n \n int\n target_isnan (x)\n      REAL_VALUE_TYPE x;\n {\n+#ifdef NANS\n+  return (eisnan (&x));\n+#else\n   return (0);\n+#endif\n }\n \n \n-/* Check for a negative IEEE double precision number.\n+/* Check for a negative REAL_VALUE_TYPE number.\n  * this means strictly less than zero, not -0.\n  */\n \n@@ -690,7 +786,7 @@ target_negative (x)\n   unsigned EMUSHORT e[NE];\n \n   GET_REAL (&x, e);\n-  if (ecmp (e, ezero) < 0)\n+  if (ecmp (e, ezero) == -1)\n     return (1);\n   return (0);\n }\n@@ -707,6 +803,10 @@ real_value_truncate (mode, arg)\n   REAL_VALUE_TYPE r;\n \n   GET_REAL (&arg, e);\n+#ifdef NANS\n+  if (eisnan (e))\n+    return (arg);\n+#endif\n   eclear (t);\n   switch (mode)\n     {\n@@ -855,7 +955,8 @@ ereal_isneg (x)\n  *\teabs (e)\t\t\tabsolute value\n  *\teadd (a, b, c)\t\tc = b + a\n  *\teclear (e)\t\te = 0\n- *\tecmp (a, b)\t\tcompare a to b, return 1, 0, or -1\n+ *\tecmp (a, b)\t\tReturns 1 if a > b, 0 if a == b,\n+ *\t\t\t\t-1 if a < b, -2 if either a or b is a NaN.\n  *\tediv (a, b, c)\t\tc = b / a\n  *\tefloor (a, b)\t\ttruncate to integer, toward -infinity\n  *\tefrexp (a, exp, s)\textract exponent and significand\n@@ -878,7 +979,9 @@ ereal_isneg (x)\n  *\tltoe (&l, e)\t\tlong (32 bit) integer to e type\n  *\tultoe (&l, e)\t\tunsigned long (32 bit) integer to e type\n  *      eisneg (e)              1 if sign bit of e != 0, else 0\n- *      eisinf (e)              1 if e has maximum exponent\n+ *      eisinf (e)              1 if e has maximum exponent (non-IEEE)\n+ *\t\t\t\tor is infinite (IEEE)\n+ *      eisnan (e)              1 if e is a NaN\n  *\n  *\n  *\t\tRoutines for internal format numbers\n@@ -902,31 +1005,34 @@ ereal_isneg (x)\n  *\teshup8 (ai)\t\tshift up 8 bits\n  *\teshup6 (ai)\t\tshift up 16 bits\n  *\tesubm (ai, bi)\t\tsubtract significands, bi = bi - ai\n+ *      eiisinf (ai)            1 if infinite\n+ *      eiisnan (ai)            1 if a NaN\n+ *      einan (ai)              set ai = NaN\n+ *      eiinfin (ai)            set ai = infinity\n  *\n  *\n  * The result is always normalized and rounded to NI-4 word precision\n  * after each arithmetic operation.\n  *\n- * Exception flags and NaNs are NOT fully supported.\n- * This arithmetic should never produce a NaN output, but it might\n- * be confused by a NaN input.\n- * Define INFINITY in mconf.h for support of infinity; otherwise a\n+ * Exception flags are NOT fully supported.\n+ *\n+ * Signaling NaN's are NOT supported; they are treated the same\n+ * as quiet NaN's.\n+ *\n+ * Define INFINITY for support of infinity; otherwise a\n  * saturation arithmetic is implemented.\n- * Denormals are always supported here where appropriate (e.g., not\n- * for conversion to DEC numbers).\n  *\n- */\n-\n-/*\n- * Revision history:\n+ * Define NANS for support of Not-a-Number items; otherwise the\n+ * arithmetic will never produce a NaN output, and might be confused\n+ * by a NaN input.\n+ * If NaN's are supported, the output of `ecmp (a,b)' is -2 if\n+ * either a or b is a NaN. This means asking `if (ecmp (a,b) < 0)'\n+ * may not be legitimate. Use `if (ecmp (a,b) == -1)' for `less than'\n+ * if in doubt.\n  *\n- *  5 Jan 84\tPDP-11 assembly language version\n- *  2 Mar 86\tfixed bug in asctoq\n- *  6 Dec 86\tC language version\n- * 30 Aug 88\t100 digit version, improved rounding\n- * 15 May 92    80-bit long double support\n+ * Denormals are always supported here where appropriate (e.g., not\n+ * for conversion to DEC numbers).\n  *\n- * Author:  S. L. Moshier.\n  */\n \n \n@@ -990,6 +1096,7 @@ ereal_isneg (x)\n #define UNDERFLOW\t4\t/* underflow range error */\n #define TLOSS\t\t5\t/* total loss of precision */\n #define PLOSS\t\t6\t/* partial loss of precision */\n+#define INVALID\t\t7\t/* NaN-producing operation */\n \n /*  e type constants used by high precision check routines */\n \n@@ -1148,49 +1255,79 @@ eneg (x)\n      unsigned EMUSHORT x[];\n {\n \n+#ifdef NANS\n+  if (eisnan (x))\n+    return;\n+#endif\n   x[NE - 1] ^= 0x8000;\t\t/* Toggle the sign bit */\n }\n \n \n \n /* Return 1 if external format number is negative,\n- * else return zero.\n+ * else return zero, including when it is a NaN.\n  */\n int \n eisneg (x)\n      unsigned EMUSHORT x[];\n {\n \n+#ifdef NANS\n+  if (eisnan (x))\n+    return (0);\n+#endif\n   if (x[NE - 1] & 0x8000)\n     return (1);\n   else\n     return (0);\n }\n \n \n-/* Return 1 if external format number has maximum possible exponent,\n+/* Return 1 if external format number is infinity.\n  * else return zero.\n  */\n int \n eisinf (x)\n      unsigned EMUSHORT x[];\n {\n \n+#ifdef NANS\n+  if (eisnan (x))\n+    return (0);\n+#endif\n   if ((x[NE - 1] & 0x7fff) == 0x7fff)\n     return (1);\n   else\n     return (0);\n }\n \n \n-/*\n-; Fill entire number, including exponent and significand, with\n-; largest possible number.  These programs implement a saturation\n-; value that is an ordinary, legal number.  A special value\n-; \"infinity\" may also be implemented; this would require tests\n-; for that value and implementation of special rules for arithmetic\n-; operations involving inifinity.\n-*/\n+/* Check if e-type number is not a number.\n+   The bit pattern is one that we defined, so we know for sure how to\n+   detect it.  */\n+\n+int \n+eisnan (x)\n+     unsigned EMUSHORT x[];\n+{\n+\n+#ifdef NANS\n+  int i;\n+/* NaN has maximum exponent */\n+  if ((x[NE - 1] & 0x7fff) != 0x7fff)\n+    return (0);\n+/* ... and non-zero significand field. */\n+  for (i = 0; i < NE - 1; i++)\n+    {\n+      if (*x++ != 0)\n+        return (1);\n+    }\n+#endif\n+  return (0);\n+}\n+\n+/*  Fill external format number with infinity pattern (IEEE)\n+    or largest possible number (non-IEEE). */\n \n void \n einfin (x)\n@@ -1227,6 +1364,22 @@ einfin (x)\n }\n \n \n+/* Output an e-type NaN.\n+   This generates Intel's quiet NaN pattern for extended real.\n+   The exponent is 7fff, the leading mantissa word is c000.  */\n+\n+void \n+enan (x)\n+     register unsigned EMUSHORT *x;\n+{\n+  register int i;\n+\n+  for (i = 0; i < NE - 2; i++)\n+    *x++ = 0;\n+  *x++ = 0xc000;\n+  *x = 0x7fff;\n+}\n+\n \n /* Move in external format number,\n  * converting it to internal format.\n@@ -1251,6 +1404,15 @@ emovi (a, b)\n #ifdef INFINITY\n   if ((*(q - 1) & 0x7fff) == 0x7fff)\n     {\n+#ifdef NANS\n+      if (eisnan (a))\n+\t{\n+\t  *q++ = 0;\n+\t  for (i = 3; i < NI; i++)\n+\t    *q++ = *p--;\n+\t  return;\n+\t}\n+#endif\n       for (i = 2; i < NI; i++)\n \t*q++ = 0;\n       return;\n@@ -1287,8 +1449,15 @@ emovo (a, b)\n #ifdef INFINITY\n   if (*(p - 1) == 0x7fff)\n     {\n+#ifdef NANS\n+      if (eiisnan (a))\n+\t{\n+\t  enan (b);\n+\t  return;\n+\t}\n+#endif\n       einfin (b);\n-      return;\n+\treturn;\n     }\n #endif\n   /* skip over guard word */\n@@ -1344,6 +1513,67 @@ emovz (a, b)\n   *b = 0;\n }\n \n+/* Generate internal format NaN.\n+   The explicit pattern for this is maximum exponent and\n+   top two significand bits set.  */\n+\n+void\n+einan (x)\n+     unsigned EMUSHORT x[];\n+{\n+\n+  ecleaz (x);\n+  x[E] = 0x7fff;\n+  x[M + 1] = 0xc000;\n+}\n+\n+/* Return nonzero if internal format number is a NaN. */\n+\n+int \n+eiisnan (x)\n+     unsigned EMUSHORT x[];\n+{\n+  int i;\n+\n+  if ((x[E] & 0x7fff) == 0x7fff)\n+    {\n+      for (i = M + 1; i < NI; i++)\n+\t{\n+\t  if (x[i] != 0)\n+\t    return (1);\n+\t}\n+    }\n+  return (0);\n+}\n+\n+/* Fill internal format number with infinity pattern.\n+   This has maximum exponent and significand all zeros.  */\n+\n+void\n+eiinfin (x)\n+     unsigned EMUSHORT x[];\n+{\n+\n+  ecleaz (x);\n+  x[E] = 0x7fff;\n+}\n+\n+/* Return nonzero if internal format number is infinite. */\n+\n+int \n+eiisinf (x)\n+     unsigned EMUSHORT x[];\n+{\n+\n+#ifdef NANS\n+  if (eiisnan (x))\n+    return (0);\n+#endif\n+  if ((x[E] & 0x7fff) == 0x7fff)\n+    return (1);\n+  return (0);\n+}\n+\n \n /*\n ;\tCompare significands of numbers in internal format.\n@@ -1979,6 +2209,27 @@ esub (a, b, c)\n      unsigned EMUSHORT *a, *b, *c;\n {\n \n+#ifdef NANS\n+  if (eisnan (a))\n+    {\n+      emov (a, c);\n+      return;\n+    }\n+  if (eisnan (b))\n+    {\n+      emov (b, c);\n+      return;\n+    }\n+/* Infinity minus infinity is a NaN.\n+   Test for subtracting infinities of the same sign. */\n+  if (eisinf (a) && eisinf (b)\n+      && ((eisneg (a) ^ eisneg (b)) == 0))\n+    {\n+      mtherr (\"esub\", INVALID);\n+      enan (c);\n+      return;\n+    }\n+#endif\n   subflg = 1;\n   eadd1 (a, b, c);\n }\n@@ -1995,6 +2246,28 @@ eadd (a, b, c)\n      unsigned EMUSHORT *a, *b, *c;\n {\n \n+#ifdef NANS\n+/* NaN plus anything is a NaN. */\n+  if (eisnan (a))\n+    {\n+      emov (a, c);\n+      return;\n+    }\n+  if (eisnan (b))\n+    {\n+      emov (b, c);\n+      return;\n+    }\n+/* Infinity minus infinity is a NaN.\n+   Test for adding infinities of opposite signs. */\n+  if (eisinf (a) && eisinf (b)\n+      && ((eisneg (a) ^ eisneg (b)) != 0))\n+    {\n+      mtherr (\"esub\", INVALID);\n+      enan (c);\n+      return;\n+    }\n+#endif\n   subflg = 0;\n   eadd1 (a, b, c);\n }\n@@ -2117,6 +2390,28 @@ ediv (a, b, c)\n   int i;\n   EMULONG lt, lta, ltb;\n \n+#ifdef NANS\n+/* Return any NaN input. */\n+  if (eisnan (a))\n+    {\n+    emov (a, c);\n+    return;\n+    }\n+  if (eisnan (b))\n+    {\n+    emov (b, c);\n+    return;\n+    }\n+/* Zero over zero, or infinity over infinity, is a NaN. */\n+  if (((ecmp (a, ezero) == 0) && (ecmp (b, ezero) == 0))\n+      || (eisinf (a) && eisinf (b)))\n+    {\n+    mtherr (\"ediv\", INVALID);\n+    enan (c);\n+    return;\n+    }\n+#endif\n+/* Infinity over anything else is infinity. */\n #ifdef INFINITY\n   if (eisinf (b))\n     {\n@@ -2127,6 +2422,7 @@ ediv (a, b, c)\n       einfin (c);\n       return;\n     }\n+/* Anything else over infinity is zero. */\n   if (eisinf (a))\n     {\n       eclear (c);\n@@ -2166,6 +2462,8 @@ ediv (a, b, c)\n \t*(c + (NE - 1)) = 0;\n       else\n \t*(c + (NE - 1)) = 0x8000;\n+/* Divide by zero is not an invalid operation.\n+   It is a divide-by-zero operation!   */\n       einfin (c);\n       mtherr (\"ediv\", SING);\n       return;\n@@ -2200,6 +2498,28 @@ emul (a, b, c)\n   int i, j;\n   EMULONG lt, lta, ltb;\n \n+#ifdef NANS\n+/* NaN times anything is the same NaN. */\n+  if (eisnan (a))\n+    {\n+    emov (a, c);\n+    return;\n+    }\n+  if (eisnan (b))\n+    {\n+    emov (b, c);\n+    return;\n+    }\n+/* Zero times infinity is a NaN. */\n+  if ((eisinf (a) && (ecmp (b, ezero) == 0))\n+      || (eisinf (b) && (ecmp (a, ezero) == 0)))\n+    {\n+    mtherr (\"emul\", INVALID);\n+    enan (c);\n+    return;\n+    }\n+#endif\n+/* Infinity times anything else is infinity. */\n #ifdef INFINITY\n   if (eisinf (a) || eisinf (b))\n     {\n@@ -2268,20 +2588,21 @@ emul (a, b, c)\n ;\te53toe (&d, x);\n */\n void \n-e53toe (e, y)\n-     unsigned EMUSHORT *e, *y;\n+e53toe (pe, y)\n+     unsigned EMUSHORT *pe, *y;\n {\n #ifdef DEC\n \n-  dectoe (e, y);\t\t/* see etodec.c */\n+  dectoe (pe, y);\t\t/* see etodec.c */\n \n #else\n \n   register unsigned EMUSHORT r;\n-  register unsigned EMUSHORT *p;\n+  register unsigned EMUSHORT *e, *p;\n   unsigned EMUSHORT yy[NI];\n   int denorm, k;\n \n+  e = pe;\n   denorm = 0;\t\t\t/* flag if denormalized number */\n   ecleaz (yy);\n #ifdef IBMPC\n@@ -2296,12 +2617,29 @@ e53toe (e, y)\n #ifdef INFINITY\n   if (r == 0x7ff0)\n     {\n+#ifdef NANS\n+#ifdef IBMPC\n+      if (((pe[3] & 0xf) != 0) || (pe[2] != 0)\n+\t  || (pe[1] != 0) || (pe[0] != 0))\n+\t{\n+\t  enan (y);\n+\t  return;\n+\t}\n+#else\n+      if (((pe[0] & 0xf) != 0) || (pe[1] != 0)\n+\t  || (pe[2] != 0) || (pe[3] != 0))\n+\t{\n+\t  enan (y);\n+\t  return;\n+\t}\n+#endif\n+#endif  /* NANS */\n       einfin (y);\n       if (r & 0x8000)\n \teneg (y);\n       return;\n     }\n-#endif\n+#endif  /* INFINITY */\n   r >>= 4;\n   /* If zero exponent, then the significand is denormalized.\n    * So, take back the understood high significand bit. */\n@@ -2337,13 +2675,14 @@ e53toe (e, y)\n }\n \n void \n-e64toe (e, y)\n-     unsigned EMUSHORT *e, *y;\n+e64toe (pe, y)\n+     unsigned EMUSHORT *pe, *y;\n {\n   unsigned EMUSHORT yy[NI];\n-  unsigned EMUSHORT *p, *q;\n+  unsigned EMUSHORT *e, *p, *q;\n   int i;\n \n+  e = pe;\n   p = yy;\n   for (i = 0; i < NE - 5; i++)\n     *p++ = 0;\n@@ -2367,12 +2706,33 @@ e64toe (e, y)\n #ifdef INFINITY\n   if (*p == 0x7fff)\n     {\n+#ifdef NANS\n+#ifdef IBMPC\n+      for (i = 0; i < 4; i++)\n+\t{\n+\t  if (pe[i] != 0)\n+\t    {\n+\t      enan (y);\n+\t      return;\n+\t    }\n+\t}\n+#else\n+      for (i = 1; i <= 4; i++)\n+\t{\n+\t  if (pe[i] != 0)\n+\t    {\n+\t      enan (y);\n+\t      return;\n+\t    }\n+\t}\n+#endif\n+#endif /* NANS */\n       einfin (y);\n       if (*p & 0x8000)\n \teneg (y);\n       return;\n     }\n-#endif\n+#endif  /* INFINITY */\n   for (i = 0; i < NE; i++)\n     *q++ = *p++;\n }\n@@ -2385,14 +2745,15 @@ e64toe (e, y)\n ;\tdtox (&d, x);\n */\n void \n-e24toe (e, y)\n-     unsigned EMUSHORT *e, *y;\n+e24toe (pe, y)\n+     unsigned EMUSHORT *pe, *y;\n {\n   register unsigned EMUSHORT r;\n-  register unsigned EMUSHORT *p;\n+  register unsigned EMUSHORT *e, *p;\n   unsigned EMUSHORT yy[NI];\n   int denorm, k;\n \n+  e = pe;\n   denorm = 0;\t\t\t/* flag if denormalized number */\n   ecleaz (yy);\n #ifdef IBMPC\n@@ -2410,12 +2771,27 @@ e24toe (e, y)\n #ifdef INFINITY\n   if (r == 0x7f80)\n     {\n+#ifdef NANS\n+#ifdef MIEEE\n+      if (((pe[0] & 0x7f) != 0) || (pe[1] != 0))\n+\t{\n+\t  enan (y);\n+\t  return;\n+\t}\n+#else\n+      if (((pe[1] & 0x7f) != 0) || (pe[0] != 0))\n+\t{\n+\t  enan (y);\n+\t  return;\n+\t}\n+#endif\n+#endif  /* NANS */\n       einfin (y);\n       if (r & 0x8000)\n \teneg (y);\n       return;\n     }\n-#endif\n+#endif  /* INFINITY */\n   r >>= 7;\n   /* If zero exponent, then the significand is denormalized.\n    * So, take back the understood high significand bit. */\n@@ -2457,6 +2833,13 @@ etoe64 (x, e)\n   EMULONG exp;\n   int rndsav;\n \n+#ifdef NANS\n+  if (eisnan (x))\n+    {\n+      make_nan (e, XFmode);\n+      return;\n+    }\n+#endif\n   emovi (x, xi);\n   /* adjust exponent for offset */\n   exp = (EMULONG) xi[E];\n@@ -2481,6 +2864,13 @@ toe64 (a, b)\n   register unsigned EMUSHORT *p, *q;\n   unsigned EMUSHORT i;\n \n+#ifdef NANS\n+  if (eiisnan (a))\n+    {\n+      make_nan (b, XFmode);\n+      return;\n+    }\n+#endif\n   p = a;\n #ifdef MIEEE\n   q = b;\n@@ -2552,6 +2942,13 @@ etoe53 (x, e)\n   EMULONG exp;\n   int rndsav;\n \n+#ifdef NANS\n+  if (eisnan (x))\n+    {\n+      make_nan (e, DFmode);\n+      return;\n+    }\n+#endif\n   emovi (x, xi);\n   /* adjust exponent for offsets */\n   exp = (EMULONG) xi[E] - (EXONE - 0x3ff);\n@@ -2576,7 +2973,13 @@ toe53 (x, y)\n   unsigned EMUSHORT i;\n   unsigned EMUSHORT *p;\n \n-\n+#ifdef NANS\n+  if (eiisnan (x))\n+    {\n+      make_nan (y, DFmode);\n+      return;\n+    }\n+#endif\n   p = &x[0];\n #ifdef IBMPC\n   y += 3;\n@@ -2659,6 +3062,13 @@ etoe24 (x, e)\n   unsigned EMUSHORT xi[NI];\n   int rndsav;\n \n+#ifdef NANS\n+  if (eisnan (x))\n+    {\n+      make_nan (e, SFmode);\n+      return;\n+    }\n+#endif\n   emovi (x, xi);\n   /* adjust exponent for offsets */\n   exp = (EMULONG) xi[E] - (EXONE - 0177);\n@@ -2682,6 +3092,13 @@ toe24 (x, y)\n   unsigned EMUSHORT i;\n   unsigned EMUSHORT *p;\n \n+#ifdef NANS\n+  if (eiisnan (x))\n+    {\n+      make_nan (y, SFmode);\n+      return;\n+    }\n+#endif\n   p = &x[0];\n #ifdef IBMPC\n   y += 1;\n@@ -2759,6 +3176,7 @@ toe24 (x, y)\n  *  returns +1 if a > b\n  *           0 if a == b\n  *          -1 if a < b\n+ *          -2 if either a or b is a NaN.\n  */\n int \n ecmp (a, b)\n@@ -2769,6 +3187,10 @@ ecmp (a, b)\n   register int i;\n   int msign;\n \n+#ifdef NANS\n+  if (eisnan (a)  || eisnan (b))\n+      return (-2);\n+#endif\n   emovi (a, ai);\n   p = ai;\n   emovi (b, bi);\n@@ -3262,24 +3684,6 @@ e24toasc (x, string, ndigs)\n {\n   unsigned EMUSHORT w[NI];\n \n-#ifdef INFINITY\n-#ifdef IBMPC\n-  if ((x[1] & 0x7f80) == 0x7f80)\n-#else\n-  if ((x[0] & 0x7f80) == 0x7f80)\n-#endif\n-    {\n-#ifdef IBMPC\n-      if (x[1] & 0x8000)\n-#else\n-      if (x[0] & 0x8000)\n-#endif\n-        sprintf (string, \" -Infinity \");\n-      else\n-        sprintf (string, \" Infinity \");\n-      return;\n-    }\n-#endif\n   e24toe (x, w);\n   etoasc (w, string, ndigs);\n }\n@@ -3293,24 +3697,6 @@ e53toasc (x, string, ndigs)\n {\n   unsigned EMUSHORT w[NI];\n \n-#ifdef INFINITY\n-#ifdef IBMPC\n-  if ((x[3] & 0x7ff0) == 0x7ff0)\n-#else\n-  if ((x[0] & 0x7ff0) == 0x7ff0)\n-#endif\n-    {\n-#ifdef IBMPC\n-      if (x[3] & 0x8000)\n-#else\n-      if (x[0] & 0x8000)\n-#endif\n-        sprintf (string, \" -Infinity \");\n-      else\n-        sprintf (string, \" Infinity \");\n-      return;\n-    }\n-#endif\n   e53toe (x, w);\n   etoasc (w, string, ndigs);\n }\n@@ -3324,24 +3710,6 @@ e64toasc (x, string, ndigs)\n {\n   unsigned EMUSHORT w[NI];\n \n-#ifdef INFINITY\n-#ifdef IBMPC\n-  if ((x[4] & 0x7fff) == 0x7fff)\n-#else\n-  if ((x[0] & 0x7fff) == 0x7fff)\n-#endif\n-    {\n-#ifdef IBMPC\n-      if (x[4] & 0x8000)\n-#else\n-      if (x[0] & 0x8000)\n-#endif\n-        sprintf (string, \" -Infinity \");\n-      else\n-        sprintf (string, \" Infinity \");\n-      return;\n-    }\n-#endif\n   e64toe (x, w);\n   etoasc (w, string, ndigs);\n }\n@@ -3363,11 +3731,19 @@ etoasc (x, string, ndigs)\n   char *s, *ss;\n   unsigned EMUSHORT m;\n \n+\n+  rndsav = rndprc;\n   ss = string;\n   s = wstring;\n-  while ((*s++ = *ss++) != '\\0')\n-    ;\n-  rndsav = rndprc;\n+  *ss = '\\0';\n+  *s = '\\0';\n+#ifdef NANS\n+  if (eisnan (x))\n+    {\n+      sprintf (wstring, \" NaN \");\n+      goto bxit;\n+    }\n+#endif\n   rndprc = NBITS;\t\t/* set to full precision */\n   emov (x, y);\t\t\t/* retain external format */\n   if (y[NE - 1] & 0x8000)\n@@ -3394,8 +3770,7 @@ etoasc (x, string, ndigs)\n     }\n  tnzro:\n \n-  /* Test for infinity.  Don't bother with illegal infinities.\n-   */\n+  /* Test for infinity. */\n   if (y[NE - 1] == 0x7fff)\n     {\n       if (sign)\n@@ -3420,6 +3795,9 @@ etoasc (x, string, ndigs)\n   if (i == 0)\n     goto isone;\n \n+  if (i == -2)\n+    abort ();\n+\n   if (i < 0)\n     {\t\t\t\t/* Number is greater than 1 */\n       /* Convert significand to an integer and strip trailing decimal zeros. */\n@@ -3452,6 +3830,7 @@ etoasc (x, string, ndigs)\n       emov (eone, t);\n       m = MAXP;\n       p = &etens[0][0];\n+      /* An unordered compare result shouldn't happen here. */\n       while (ecmp (ten, u) <= 0)\n \t{\n \t  if (ecmp (p, u) <= 0)\n@@ -3835,8 +4214,12 @@ asctoeg (ss, y, oprec)\n       goto infinite;\n     default:\n     error:\n+#ifdef NANS\n+      einan (yy);\n+#else\n       mtherr (\"asctoe\", DOMAIN);\n-      eclear (y);\n+      eclear (yy);\n+#endif\n       goto aexit;\n     }\n  donchr:\n@@ -4146,6 +4529,16 @@ eremain (a, b, c)\n {\n   unsigned EMUSHORT den[NI], num[NI];\n \n+#ifdef NANS\n+  if ( eisinf (b)\n+       || (ecmp (a, ezero) == 0)\n+       || eisnan (a)\n+       || eisnan (b))\n+    {\n+      enan (c);\n+      return;\n+    }\n+#endif\n   if (ecmp (a, ezero) == 0)\n     {\n       mtherr (\"eremain\", SING);\n@@ -4223,6 +4616,7 @@ eiremain (den, num)\n  *    UNDERFLOW         4       underflow range error\n  *    TLOSS             5       total loss of precision\n  *    PLOSS             6       partial loss of precision\n+ *    INVALID           7       NaN - producing operation\n  *    EDOM             33       Unix domain error code\n  *    ERANGE           34       Unix range error code\n  *\n@@ -4256,15 +4650,17 @@ Direct inquiries to 30 Frost Street, Cambridge, MA 02140\n  * messages is bound to the error codes defined\n  * in mconf.h.\n  */\n-static char *ermsg[7] =\n+#define NMSGS 8\n+static char *ermsg[NMSGS] =\n {\n   \"unknown\",\t\t\t/* error code 0 */\n   \"domain\",\t\t\t/* error code 1 */\n   \"singularity\",\t\t/* et seq.      */\n   \"overflow\",\n   \"underflow\",\n   \"total loss of precision\",\n-  \"partial loss of precision\"\n+  \"partial loss of precision\",\n+  \"invalid operation\"\n };\n \n int merror = 0;\n@@ -4285,7 +4681,7 @@ mtherr (name, code)\n   /* Display error message defined\n    * by the code argument.\n    */\n-  if ((code <= 0) || (code >= 6))\n+  if ((code <= 0) || (code >= NMSGS))\n     code = 0;\n   sprintf (errstr, \"\\n%s %s error\\n\", name, ermsg[code]);\n   if (extra_warnings)\n@@ -4489,4 +4885,85 @@ todec (x, y)\n \n #endif /* not 0 */\n \n+\n+/* Output a binary NaN bit pattern in the target machine's format.  */\n+\n+/* If special NaN bit patterns are required, define them in tm.h\n+   as arrays of unsigned 16-bit shorts.  Otherwise, use the default\n+   patterns here. */\n+#ifndef TFMODE_NAN\n+#ifdef MIEEE\n+unsigned EMUSHORT TFnan[8] =\n+ {0x7fff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff};\n+#endif\n+#ifdef IBMPC\n+unsigned EMUSHORT TFnan[8] = {0, 0, 0, 0, 0, 0, 0x8000, 0xffff};\n+#endif\n+#endif\n+\n+#ifndef XFMODE_NAN\n+#ifdef MIEEE\n+unsigned EMUSHORT XFnan[6] = {0x7fff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff};\n+#endif\n+#ifdef IBMPC\n+unsigned EMUSHORT XFnan[6] = {0, 0, 0, 0xc000, 0xffff, 0};\n+#endif\n+#endif\n+\n+#ifndef DFMODE_NAN\n+#ifdef MIEEE\n+unsigned EMUSHORT DFnan[4] = {0x7fff, 0xffff, 0xffff, 0xffff};\n+#endif\n+#ifdef IBMPC\n+unsigned EMUSHORT DFnan[4] = {0, 0, 0, 0xfff8};\n+#endif\n+#endif\n+\n+#ifndef SFMODE_NAN\n+#ifdef MIEEE\n+unsigned EMUSHORT SFnan[2] = {0x7fff, 0xffff};\n+#endif\n+#ifdef IBMPC\n+unsigned EMUSHORT SFnan[2] = {0, 0xffc0};\n+#endif\n+#endif\n+\n+\n+void\n+make_nan (nan, mode)\n+unsigned EMUSHORT *nan;\n+enum machine_mode mode;\n+{\n+  int i, n;\n+  unsigned EMUSHORT *p;\n+\n+  switch (mode)\n+    {\n+/* Possibly the `reserved operand' patterns on a VAX can be\n+   used like NaN's, but probably not in the same way as IEEE. */\n+#ifndef DEC\n+    case TFmode:\n+      n = 8;\n+      p = TFnan;\n+      break;\n+    case XFmode:\n+      n = 6;\n+      p = XFnan;\n+      break;\n+    case DFmode:\n+      n = 4;\n+      p = DFnan;\n+      break;\n+    case SFmode:\n+      n = 2;\n+      p = SFnan;\n+      break;\n+#endif\n+    default:\n+      abort ();\n+    }\n+  for (i=0; i < n; i++)\n+    *nan++ = *p++;\n+}\n+\n #endif /* EMU_NON_COMPILE not defined */"}]}