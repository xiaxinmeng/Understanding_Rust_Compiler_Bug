{"sha": "f3a9d1e61de9e54831f8ed5d9f526a5e54af5576", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNhOWQxZTYxZGU5ZTU0ODMxZjhlZDVkOWY1MjZhNWU1NGFmNTU3Ng==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-07-21T22:00:03Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-07-21T22:00:03Z"}, "message": "(output_move_double): Only set highest_first if first reg of dest overlaps memory src address.\n\n(output_move_double): Only set highest_first if first reg\nof dest overlaps memory src address.  Otherwise, if addreg1 set and\nis same as second reg of dest, suppress trailing decrement.\n\nFrom-SVN: r4963", "tree": {"sha": "7a38c99afaef75f451d8cec1dd2a4e2984fe9998", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a38c99afaef75f451d8cec1dd2a4e2984fe9998"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3a9d1e61de9e54831f8ed5d9f526a5e54af5576", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3a9d1e61de9e54831f8ed5d9f526a5e54af5576", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3a9d1e61de9e54831f8ed5d9f526a5e54af5576", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3a9d1e61de9e54831f8ed5d9f526a5e54af5576/comments", "author": null, "committer": null, "parents": [{"sha": "74fb18d0dbe384a254c6badcc06cdc1b1336d11b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74fb18d0dbe384a254c6badcc06cdc1b1336d11b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74fb18d0dbe384a254c6badcc06cdc1b1336d11b"}], "stats": {"total": 24, "additions": 18, "deletions": 6}, "files": [{"sha": "46946dd3f27711bea886c34835e22a0ce7cf5840", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a9d1e61de9e54831f8ed5d9f526a5e54af5576/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a9d1e61de9e54831f8ed5d9f526a5e54af5576/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=f3a9d1e61de9e54831f8ed5d9f526a5e54af5576", "patch": "@@ -1059,6 +1059,7 @@ output_move_double (operands)\n   rtx addreg0 = 0;\n   rtx addreg1 = 0;\n   int highest_first = 0;\n+  int no_addreg1_decrement = 0;\n \n   /* First classify both operands.  */\n \n@@ -1154,22 +1155,33 @@ output_move_double (operands)\n   else if (optype0 == REGOP && optype1 != REGOP\n \t   && reg_overlap_mentioned_p (op0, op1))\n     {\n+      /* If both halves of dest are used in the src memory address,\n+\t add the two regs and put them in the low reg (op0).\n+\t Then it works to load latehalf first.  */\n       if (reg_mentioned_p (op0, XEXP (op1, 0))\n \t  && reg_mentioned_p (latehalf[0], XEXP (op1, 0)))\n \t{\n-\t  /* If both halves of dest are used in the src memory address,\n-\t     add the two regs and put them in the low reg (op0).\n-\t     Then it works to load latehalf first.  */\n \t  rtx xops[2];\n \t  xops[0] = latehalf[0];\n \t  xops[1] = op0;\n \t  output_asm_insn (\"add %1,%0,%1\", xops);\n \t  operands[1] = gen_rtx (MEM, DImode, op0);\n \t  latehalf[1] = adj_offsettable_operand (operands[1], 4);\n \t  addreg1 = 0;\n+\t  highest_first = 1;\n \t}\n-      /* Do the late half first.  */\n-      highest_first = 1;\n+      /* Only one register in the dest is used in the src memory address,\n+\t and this is the first register of the dest, so we want to do\n+\t the late half first here also.  */\n+      else if (! reg_mentioned_p (latehalf[0], XEXP (op1, 0)))\n+\thighest_first = 1;\n+      /* Only one register in the dest is used in the src memory address,\n+\t and this is the second register of the dest, so we want to do\n+\t the late half last.  If addreg1 is set, and addreg1 is the same\n+\t register as latehalf, then we must suppress the trailing decrement,\n+\t because it would clobber the value just loaded.  */\n+      else if (addreg1 && reg_mentioned_p (addreg1, latehalf[0]))\n+\tno_addreg1_decrement = 1;\n     }\n \n   /* Normal case: do the two words, low-numbered first.\n@@ -1190,7 +1202,7 @@ output_move_double (operands)\n   /* Undo the adds we just did.  */\n   if (addreg0)\n     output_asm_insn (\"add %0,-0x4,%0\", &addreg0);\n-  if (addreg1)\n+  if (addreg1 && ! no_addreg1_decrement)\n     output_asm_insn (\"add %0,-0x4,%0\", &addreg1);\n \n   if (highest_first)"}]}