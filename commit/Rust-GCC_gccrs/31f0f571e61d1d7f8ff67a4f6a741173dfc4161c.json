{"sha": "31f0f571e61d1d7f8ff67a4f6a741173dfc4161c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFmMGY1NzFlNjFkMWQ3ZjhmZjY3YTRmNmE3NDExNzNkZmM0MTYxYw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-11-02T13:56:42Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-11-02T13:56:42Z"}, "message": "re PR rtl-optimization/10817 (gcc does not optimize result=0;if(t!=0)result=t; to result=t;)\n\n\n\tPR optimization/10817\n\t* ifcvt.c (noce_emit_move_insn): Improve documentation comment.\n\t(noce_try_move): New function to optimize an if-the-else into an\n\tunconditional move, i.e. \"if (a!=b) x=a; else x=b\" into \"x=a\".\n\t(noce_process_if_block): Attempt simplification with noce_try_move.\n\n\t* simplify-rtx.c (simplify_ternary_operation): Some minor fixes\n\tand improvements to the optimizations of IF_THEN_ELSE expressions.\n\t(simplify_subreg): Silence signed/unsigned comparison warning.\n\n\t* gcc.c-torture/compile/20031102-1.c: New test case.\n\nFrom-SVN: r73200", "tree": {"sha": "3b7c1888d9ed7fad3b4bf1b5208f5a4d7e6b11cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b7c1888d9ed7fad3b4bf1b5208f5a4d7e6b11cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31f0f571e61d1d7f8ff67a4f6a741173dfc4161c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31f0f571e61d1d7f8ff67a4f6a741173dfc4161c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31f0f571e61d1d7f8ff67a4f6a741173dfc4161c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31f0f571e61d1d7f8ff67a4f6a741173dfc4161c/comments", "author": null, "committer": null, "parents": [{"sha": "2077750a864920bb1f80a1b6998142d2b3c80dc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2077750a864920bb1f80a1b6998142d2b3c80dc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2077750a864920bb1f80a1b6998142d2b3c80dc8"}], "stats": {"total": 117, "additions": 105, "deletions": 12}, "files": [{"sha": "25dd9c1e2b9f21b0f5682e229c49be651c559c1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f0f571e61d1d7f8ff67a4f6a741173dfc4161c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f0f571e61d1d7f8ff67a4f6a741173dfc4161c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31f0f571e61d1d7f8ff67a4f6a741173dfc4161c", "patch": "@@ -1,3 +1,15 @@\n+2003-11-02  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR optimization/10817\n+\t* ifcvt.c (noce_emit_move_insn): Improve documentation comment.\n+\t(noce_try_move): New function to optimize an if-the-else into an\n+\tunconditional move, i.e. \"if (a!=b) x=a; else x=b\" into \"x=a\".\n+\t(noce_process_if_block): Attempt simplification with noce_try_move.\n+\n+\t* simplify-rtx.c (simplify_ternary_operation): Some minor fixes\n+\tand improvements to the optimizations of IF_THEN_ELSE expressions.\n+\t(simplify_subreg): Silence signed/unsigned comparison warning.\n+\n 2003-11-02  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* Makefile.in (targhooks.o, reload.o): Update dependencies."}, {"sha": "9844bf4d2b35782a5650aaeb6b5e7a4b13b813c0", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f0f571e61d1d7f8ff67a4f6a741173dfc4161c/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f0f571e61d1d7f8ff67a4f6a741173dfc4161c/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=31f0f571e61d1d7f8ff67a4f6a741173dfc4161c", "patch": "@@ -602,6 +602,7 @@ struct noce_if_info\n };\n \n static rtx noce_emit_store_flag (struct noce_if_info *, rtx, int, int);\n+static int noce_try_move (struct noce_if_info *);\n static int noce_try_store_flag (struct noce_if_info *);\n static int noce_try_addcc (struct noce_if_info *);\n static int noce_try_store_flag_constants (struct noce_if_info *);\n@@ -674,7 +675,9 @@ noce_emit_store_flag (struct noce_if_info *if_info, rtx x, int reversep,\n \t\t\t   || code == GEU || code == GTU), normalize);\n }\n \n-/* Emit instruction to move an rtx into STRICT_LOW_PART.  */\n+/* Emit instruction to move an rtx, possibly into STRICT_LOW_PART.\n+   X is the destination/target and Y is the value to copy.  */\n+\n static void\n noce_emit_move_insn (rtx x, rtx y)\n {\n@@ -697,6 +700,49 @@ noce_emit_move_insn (rtx x, rtx y)\n \t\t   GET_MODE_BITSIZE (inmode));\n }\n \n+/* Convert \"if (a != b) x = a; else x = b\" into \"x = a\" and\n+   \"if (a == b) x = a; else x = b\" into \"x = b\".  */\n+\n+static int\n+noce_try_move (struct noce_if_info *if_info)\n+{\n+  rtx cond = if_info->cond;\n+  enum rtx_code code = GET_CODE (cond);\n+  rtx y, seq;\n+\n+  if (code != NE && code != EQ)\n+    return FALSE;\n+\n+  /* This optimization isn't valid if either A or B could be a NaN\n+     or a signed zero.  */\n+  if (HONOR_NANS (GET_MODE (if_info->x))\n+      || HONOR_SIGNED_ZEROS (GET_MODE (if_info->x)))\n+    return FALSE;\n+\n+  /* Check whether the operands of the comparison are A and in\n+     either order.  */\n+  if ((rtx_equal_p (if_info->a, XEXP (cond, 0))\n+       && rtx_equal_p (if_info->b, XEXP (cond, 1)))\n+      || (rtx_equal_p (if_info->a, XEXP (cond, 1))\n+\t  && rtx_equal_p (if_info->b, XEXP (cond, 0))))\n+    {\n+      y = (code == EQ) ? if_info->a : if_info->b;\n+\n+      /* Avoid generating the move if the source is the destination.  */\n+      if (! rtx_equal_p (if_info->x, y))\n+\t{\n+\t  start_sequence ();\n+\t  noce_emit_move_insn (if_info->x, y);\n+\t  seq = get_insns ();\n+\t  end_sequence ();\n+\t  emit_insn_before_setloc (seq, if_info->jump,\n+\t\t\t\t   INSN_LOCATOR (if_info->insn_a));\n+\t}\n+      return TRUE;\n+    }\n+  return FALSE;\n+}\n+\n /* Convert \"if (test) x = 1; else x = 0\".\n \n    Only try 0 and STORE_FLAG_VALUE here.  Other combinations will be\n@@ -1894,6 +1940,8 @@ noce_process_if_block (struct ce_if_block * ce_info)\n       goto success;\n     }\n \n+  if (noce_try_move (&if_info))\n+    goto success;\n   if (noce_try_store_flag (&if_info))\n     goto success;\n   if (noce_try_minmax (&if_info))"}, {"sha": "bf44b55e765dded038ce581a97f5e1613cd00d2b", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f0f571e61d1d7f8ff67a4f6a741173dfc4161c/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f0f571e61d1d7f8ff67a4f6a741173dfc4161c/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=31f0f571e61d1d7f8ff67a4f6a741173dfc4161c", "patch": "@@ -2821,18 +2821,33 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n       if (GET_CODE (op0) == CONST_INT)\n \treturn op0 != const0_rtx ? op1 : op2;\n \n-      /* Convert a == b ? b : a to \"a\".  */\n-      if (GET_CODE (op0) == NE && ! side_effects_p (op0)\n-\t  && !HONOR_NANS (mode)\n-\t  && rtx_equal_p (XEXP (op0, 0), op1)\n-\t  && rtx_equal_p (XEXP (op0, 1), op2))\n+      /* Convert c ? a : a into \"a\".  */\n+      if (rtx_equal_p (op1, op2) && ! side_effects_p (op0))\n \treturn op1;\n-      else if (GET_CODE (op0) == EQ && ! side_effects_p (op0)\n-\t  && !HONOR_NANS (mode)\n-\t  && rtx_equal_p (XEXP (op0, 1), op1)\n-\t  && rtx_equal_p (XEXP (op0, 0), op2))\n+\n+      /* Convert a != b ? a : b into \"a\".  */\n+      if (GET_CODE (op0) == NE\n+\t  && ! side_effects_p (op0)\n+\t  && ! HONOR_NANS (mode)\n+\t  && ! HONOR_SIGNED_ZEROS (mode)\n+\t  && ((rtx_equal_p (XEXP (op0, 0), op1)\n+\t       && rtx_equal_p (XEXP (op0, 1), op2))\n+\t      || (rtx_equal_p (XEXP (op0, 0), op2)\n+\t\t  && rtx_equal_p (XEXP (op0, 1), op1))))\n+\treturn op1;\n+\n+      /* Convert a == b ? a : b into \"b\".  */\n+      if (GET_CODE (op0) == EQ\n+\t  && ! side_effects_p (op0)\n+\t  && ! HONOR_NANS (mode)\n+\t  && ! HONOR_SIGNED_ZEROS (mode)\n+\t  && ((rtx_equal_p (XEXP (op0, 0), op1)\n+\t       && rtx_equal_p (XEXP (op0, 1), op2))\n+\t      || (rtx_equal_p (XEXP (op0, 0), op2)\n+\t\t  && rtx_equal_p (XEXP (op0, 1), op1))))\n \treturn op2;\n-      else if (GET_RTX_CLASS (GET_CODE (op0)) == '<' && ! side_effects_p (op0))\n+\n+      if (GET_RTX_CLASS (GET_CODE (op0)) == '<' && ! side_effects_p (op0))\n \t{\n \t  enum machine_mode cmp_mode = (GET_MODE (XEXP (op0, 0)) == VOIDmode\n \t\t\t\t\t? GET_MODE (XEXP (op0, 1))\n@@ -2874,6 +2889,7 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n \t    }\n \t}\n       break;\n+\n     case VEC_MERGE:\n       if (GET_MODE (op0) != mode\n \t  || GET_MODE (op1) != mode\n@@ -3286,7 +3302,7 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n      of real and imaginary part.  */\n   if (GET_CODE (op) == CONCAT)\n     {\n-      int is_realpart = byte < GET_MODE_UNIT_SIZE (innermode);\n+      int is_realpart = byte < (unsigned int) GET_MODE_UNIT_SIZE (innermode);\n       rtx part = is_realpart ? XEXP (op, 0) : XEXP (op, 1);\n       unsigned int final_offset;\n       rtx res;"}, {"sha": "1dabd38f85a836fe18040c41132bff8dec7b7c5b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f0f571e61d1d7f8ff67a4f6a741173dfc4161c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f0f571e61d1d7f8ff67a4f6a741173dfc4161c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=31f0f571e61d1d7f8ff67a4f6a741173dfc4161c", "patch": "@@ -1,3 +1,8 @@\n+2003-11-02  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR optimization/10817\n+\t* gcc.c-torture/compile/20031102-1.c: New test case.\n+\n 2003-11-02  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* gcc.c-torture/execute/va-arg-25.c: Enable only if INT_MAX =="}, {"sha": "e32b8bd8612269e201e51c89d2f45853ad1be382", "filename": "gcc/testsuite/gcc.c-torture/compile/20031102-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f0f571e61d1d7f8ff67a4f6a741173dfc4161c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031102-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f0f571e61d1d7f8ff67a4f6a741173dfc4161c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031102-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031102-1.c?ref=31f0f571e61d1d7f8ff67a4f6a741173dfc4161c", "patch": "@@ -0,0 +1,12 @@\n+/* PR optimization/10817.\n+   Check that the following code doesn't cause any problems\n+   for GCC's if-conversion passes.  */\n+\n+int foo(int t)\n+{\n+  int result = 0;\n+  if (t != 0)\n+    result = t;\n+  return result;\n+}\n+"}]}