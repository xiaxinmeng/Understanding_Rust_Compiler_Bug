{"sha": "76f5e2005dad6bad5cc4da4fea55f9c85f1fc370", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZmNWUyMDA1ZGFkNmJhZDVjYzRkYTRmZWE1NWY5Yzg1ZjFmYzM3MA==", "commit": {"author": {"name": "Danny Smith", "email": "dannysmith@gcc.gnu.org", "date": "2007-06-14T02:38:37Z"}, "committer": {"name": "Danny Smith", "email": "dannysmith@gcc.gnu.org", "date": "2007-06-14T02:38:37Z"}, "message": "config.host (*-cygwin* |*-mingw* ): Add crtbegin.o, crtend.o to extra_parts.\n\nChangeLog/libgcc\n\n2007-06-14  Danny Smith  <dannysmith@users.sourceforge.net>\n\n\t* config.host(*-cygwin* |*-mingw* ): Add crtbegin.o, crtend.o to\n\textra_parts. Add config/i386/t-cygming to tmake_file. \n\t* config/i386/t-cygming: New file with rules for crtbegin.o, crtend.o.\n\n\nChangeLog/gcc\n\n2007-06-14  Danny Smith  <dannysmith@users.sourceforge.net>\n\n\t* config/i386/cygming.h (DWARF_FRAME_REGNUM): Define.\n\t(DWARF2_UNWIND_INFO): Override default if configured with\n\tSJLJ EH disabled.\n\t* config/i386/cygwin.h (STARTFILE_SPEC): Add crtbegin.o.\n\t(ENDFILE_SPEC): Add crtend.o.\n\t* config/i386/mingw32.h (STARTFILE_SEC): Add crtbegin.o.\n\t(ENDFILE_SPEC): Add crtend.o.\n\t(TARGET_USE_JCR_SECTION): Define.\n\t(MD_UNWIND_SUPPORT): Define for 32-bit target.\n\n\t* config/i386/cygming-crtbegin.c: New file.\n\t* config/i386/cygming-crtend.c: New file.\n\n2007-06-14  Pascal Obry Pascal Obry  <obry@adacore.com>\n\n\t* config/i386/w32-unwind.h: New file.\n\nFrom-SVN: r125696", "tree": {"sha": "654abed38b0324efc35de124e2281685a7eed705", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/654abed38b0324efc35de124e2281685a7eed705"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/comments", "author": null, "committer": null, "parents": [{"sha": "ab47d43e0174bc528c1da12401a5b329aa33703c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab47d43e0174bc528c1da12401a5b329aa33703c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab47d43e0174bc528c1da12401a5b329aa33703c"}], "stats": {"total": 518, "additions": 509, "deletions": 9}, "files": [{"sha": "ecb6746e2b062aa1e5b771450a7e2d4ecfb6b834", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76f5e2005dad6bad5cc4da4fea55f9c85f1fc370", "patch": "@@ -1,3 +1,22 @@\n+2007-06-14  Danny Smith  <dannysmith@users.sourceforge.net>\n+\n+\t* config/i386/cygming.h (DWARF_FRAME_REGNUM): Define.\n+\t(DWARF2_UNWIND_INFO): Override default if configured with\n+\tSJLJ EH disabled.\n+\t* config/i386/cygwin.h (STARTFILE_SPEC): Add crtbegin.o.\n+\t(ENDFILE_SPEC): Add crtend.o.\n+\t* config/i386/mingw32.h (STARTFILE_SEC): Add crtbegin.o.\n+\t(ENDFILE_SPEC): Add crtend.o.\n+\t(TARGET_USE_JCR_SECTION): Define.\n+\t(MD_UNWIND_SUPPORT): Define for 32-bit target.\n+\n+\t* config/i386/cygming-crtbegin.c: New file.\n+\t* config/i386/cygming-crtend.c: New file.\n+\n+2007-06-14  Pascal Obry Pascal Obry  <obry@adacore.com>\n+\n+\t* config/i386/w32-unwind.h: New file.\n+\n 2007-06-13  Eric Christopher  <echristo@apple.com>\n \n \t* config/i386/darwin.h (PREFERRED_STACK_BOUNDARY): Don't let"}, {"sha": "f44f64a497b4c695e1dd0154aa6eb7c0db8cbdae", "filename": "gcc/config/i386/cygming-crtbegin.c", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/gcc%2Fconfig%2Fi386%2Fcygming-crtbegin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/gcc%2Fconfig%2Fi386%2Fcygming-crtbegin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming-crtbegin.c?ref=76f5e2005dad6bad5cc4da4fea55f9c85f1fc370", "patch": "@@ -0,0 +1,140 @@\n+/* crtbegin object for windows32 targets.\n+   Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+   Contributed by Danny Smith <dannysmith@users.sourceforge.net>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* Target machine header files require this define. */\n+#define IN_LIBGCC2\n+\n+#include \"auto-host.h\"\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"unwind-dw2-fde.h\"\n+\n+#define WIN32_LEAN_AND_MEAN\n+#include <windows.h>\n+\n+#ifndef LIBGCC_SONAME\n+#define LIBGCC_SONAME \"libgcc_s.dll\"\n+#endif\n+\n+#ifndef LIBGCJ_SONAME\n+#define LIBGCJ_SONAME \"libgcj_s.dll\"\n+#endif\n+\n+\n+/* Make the declarations weak.  This is critical for\n+   _Jv_RegisterClasses because it lives in libgcj.a  */\n+extern void __register_frame_info (const void *, struct object *)\n+\t\t\t\t   TARGET_ATTRIBUTE_WEAK;\n+extern void *__deregister_frame_info (const void *)\n+\t\t\t\t      TARGET_ATTRIBUTE_WEAK;\n+extern void _Jv_RegisterClasses (const void *) TARGET_ATTRIBUTE_WEAK;\n+\n+#if defined(HAVE_LD_RO_RW_SECTION_MIXING)\n+# define EH_FRAME_SECTION_CONST const\n+#else\n+# define EH_FRAME_SECTION_CONST\n+#endif\n+\n+/* Stick a label at the beginning of the frame unwind info so we can\n+   register/deregister it with the exception handling library code.  */\n+#if DWARF2_UNWIND_INFO\n+static EH_FRAME_SECTION_CONST char __EH_FRAME_BEGIN__[]\n+  __attribute__((section(EH_FRAME_SECTION_NAME), aligned(4)))\n+  = { };\n+\n+static struct object obj;\n+#endif\n+\n+#if TARGET_USE_JCR_SECTION\n+static void *__JCR_LIST__[]\n+  __attribute__ ((unused, section(JCR_SECTION_NAME), aligned(4)))\n+  = { };\n+#endif\n+\n+/* Pull in references from libgcc.a(unwind-dw2-fde.o) in the\n+   startfile. These are referenced by a ctor and dtor in crtend.o.  */\n+extern void __gcc_register_frame (void);\n+extern void __gcc_deregister_frame (void);\n+\n+void\n+__gcc_register_frame (void)\n+{\n+#if DWARF2_UNWIND_INFO\n+/* Weak undefined symbols won't be pulled in from dlls; hence\n+   we first test if the dll is already loaded and, if so,\n+   get the symbol's address at run-time.  If the dll is not loaded,\n+   fallback to weak linkage to static archive.  */\n+\n+  void (*register_frame_fn) (const void *, struct object *);\n+  HANDLE h = GetModuleHandle (LIBGCC_SONAME);\n+  if (h)\n+    register_frame_fn = (void (*) (const void *, struct object *))\n+\t\t\tGetProcAddress (h, \"__register_frame_info\");\n+  else \n+    register_frame_fn = __register_frame_info;\n+  if (register_frame_fn)\n+     register_frame_fn (__EH_FRAME_BEGIN__, &obj);\n+#endif\n+\n+#if TARGET_USE_JCR_SECTION \n+  if (__JCR_LIST__[0])\n+    {\n+      void (*register_class_fn) (const void *);\n+      HANDLE h = GetModuleHandle (LIBGCJ_SONAME);\n+      if (h)\n+\tregister_class_fn = (void (*) (const void *))\n+\t\t\t     GetProcAddress (h, \"_Jv_RegisterClasses\");\n+      else\n+\tregister_class_fn = _Jv_RegisterClasses;\n+\n+      if (register_class_fn)\n+\tregister_class_fn (__JCR_LIST__);\n+    }\n+#endif\n+}\n+\n+void\n+__gcc_deregister_frame (void)\n+{\n+#if DWARF2_UNWIND_INFO\n+  void *  (*deregister_frame_fn) (const void *);\n+  HANDLE h = GetModuleHandle (LIBGCC_SONAME);\n+  if (h)\n+    deregister_frame_fn = (void* (*) (const void *))\n+\t\t\t  GetProcAddress (h, \"__deregister_frame_info\");\n+  else \n+    deregister_frame_fn = __deregister_frame_info;\n+  if (deregister_frame_fn)\n+     deregister_frame_fn (__EH_FRAME_BEGIN__);\n+#endif\n+}"}, {"sha": "92e133099e443e02385943ef1f4c3837f197964e", "filename": "gcc/config/i386/cygming-crtend.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/gcc%2Fconfig%2Fi386%2Fcygming-crtend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/gcc%2Fconfig%2Fi386%2Fcygming-crtend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming-crtend.c?ref=76f5e2005dad6bad5cc4da4fea55f9c85f1fc370", "patch": "@@ -0,0 +1,86 @@\n+/* crtend object for windows32 targets.\n+   Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+   Contributed by Danny Smith <dannysmith@users.sourceforge.net>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* Target machine header files require this define. */\n+#define IN_LIBGCC2\n+\n+/* auto-host.h is needed by cygming.h for HAVE_GAS_WEAK and here\n+   for HAVE_LD_RO_RW_SECTION_MIXING.  */  \n+#include \"auto-host.h\"\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"unwind-dw2-fde.h\"\n+\n+#if defined(HAVE_LD_RO_RW_SECTION_MIXING)\n+# define EH_FRAME_SECTION_CONST const\n+#else\n+# define EH_FRAME_SECTION_CONST\n+#endif\n+\n+#if DWARF2_UNWIND_INFO\n+/* Terminate the frame unwind info section with a 0 as a sentinel;\n+   this would be the 'length' field in a real FDE.  */\n+\n+static EH_FRAME_SECTION_CONST int __FRAME_END__[]\n+  __attribute__ ((unused,  section(EH_FRAME_SECTION_NAME),\n+\t\t  aligned(4)))\n+  = { 0 };\n+#endif\n+\n+#if TARGET_USE_JCR_SECTION\n+/* Null terminate the .jcr section array.  */\n+static void *__JCR_END__[1] \n+   __attribute__ ((unused, section(JCR_SECTION_NAME),\n+\t\t   aligned(sizeof(void *))))\n+   = { 0 };\n+#endif\n+\n+\n+extern void __gcc_register_frame (void); \n+extern void __gcc_deregister_frame (void);\n+\n+static void register_frame_ctor (void) __attribute__ ((constructor (0)));\n+static void deregister_frame_dtor (void) __attribute__ ((destructor (0)));\n+\n+\n+static void\n+register_frame_ctor (void)\n+{\n+  __gcc_register_frame ();\n+}\n+\n+static void\n+deregister_frame_dtor (void)\n+{\n+  __gcc_deregister_frame ();\n+}"}, {"sha": "3f3ddd7ad68426e6579d99339fe1e3b795e0b933", "filename": "gcc/config/i386/cygming.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/gcc%2Fconfig%2Fi386%2Fcygming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/gcc%2Fconfig%2Fi386%2Fcygming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming.h?ref=76f5e2005dad6bad5cc4da4fea55f9c85f1fc370", "patch": "@@ -51,6 +51,14 @@ Boston, MA 02110-1301, USA.  */\n    : (write_symbols == DWARF2_DEBUG\t\t\t\\\n       ? svr4_dbx_register_map[n] : dbx_register_map[n]))\n \n+\n+/* Map gcc register number to DWARF 2 CFA column number. For 32 bit\n+   target, always use the svr4_dbx_register_map for DWARF .eh_frame\n+   even if we don't use DWARF .debug_frame. */\n+#undef DWARF_FRAME_REGNUM\n+#define DWARF_FRAME_REGNUM(n) TARGET_64BIT \\\n+\t? dbx64_register_map[(n)] : svr4_dbx_register_map[(n)] \n+\n /* Use section relative relocations for debugging offsets.  Unlike\n    other targets that fake this by putting the section VMA at 0, PE\n    won't allow it.  */\n@@ -279,12 +287,15 @@ do {\t\t\t\t\t\t\t\\\n #undef ASM_COMMENT_START\n #define ASM_COMMENT_START \" #\"\n \n-/* DWARF2 Unwinding doesn't work with exception handling yet.  To make\n-   it work, we need to build a libgcc_s.dll, and dcrt0.o should be\n-   changed to call __register_frame_info/__deregister_frame_info.  */\n #ifndef DWARF2_UNWIND_INFO\n+/* If configured with --disable-sjlj-exceptions, use DWARF2, else\n+   default to SJLJ  */\n+#if defined (CONFIG_SJLJ_EXCEPTIONS) && !CONFIG_SJLJ_EXCEPTIONS\n+#define DWARF2_UNWIND_INFO 1\n+#else\n #define DWARF2_UNWIND_INFO 0\n #endif\n+#endif\n \n /* Don't assume anything about the header files.  */\n #define NO_IMPLICIT_EXTERN_C"}, {"sha": "8eb480ec2ae595a739deb4af629535d6b8551a3b", "filename": "gcc/config/i386/cygwin.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/gcc%2Fconfig%2Fi386%2Fcygwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/gcc%2Fconfig%2Fi386%2Fcygwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygwin.h?ref=76f5e2005dad6bad5cc4da4fea55f9c85f1fc370", "patch": "@@ -38,11 +38,12 @@ Boston, MA 02110-1301, USA.  */\n   %{shared|mdll: %{mno-cygwin:dllcrt2%O%s}}\\\n   %{!shared: %{!mdll: %{!mno-cygwin:crt0%O%s} %{mno-cygwin:crt2%O%s}\\\n   %{pg:gcrt0%O%s}}}\\\n-\"\n+  crtbegin.o%s\"\n \n #undef ENDFILE_SPEC\n #define ENDFILE_SPEC \\\n-  \"%{ffast-math|funsafe-math-optimizations:crtfastmath.o%s}\"\n+  \"%{ffast-math|funsafe-math-optimizations:crtfastmath.o%s}\\\n+   crtend.o%s\"\n \n /* Normally, -lgcc is not needed since everything in it is in the DLL, but we\n    want to allow things to be added to it when installing new versions of"}, {"sha": "2b129ecf9e1bbcb37b75c597b47413d592f60226", "filename": "gcc/config/i386/mingw32.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/gcc%2Fconfig%2Fi386%2Fmingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/gcc%2Fconfig%2Fi386%2Fmingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmingw32.h?ref=76f5e2005dad6bad5cc4da4fea55f9c85f1fc370", "patch": "@@ -84,11 +84,13 @@ Boston, MA 02110-1301, USA.  */\n \n #undef STARTFILE_SPEC\n #define STARTFILE_SPEC \"%{shared|mdll:dllcrt2%O%s} \\\n-  %{!shared:%{!mdll:crt2%O%s}} %{pg:gcrt2%O%s}\"\n+  %{!shared:%{!mdll:crt2%O%s}} %{pg:gcrt2%O%s} \\\n+  crtbegin.o%s\"\n \n #undef ENDFILE_SPEC\n #define ENDFILE_SPEC \\\n-  \"%{ffast-math|funsafe-math-optimizations:crtfastmath.o%s}\"\n+  \"%{ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \\\n+  crtend.o%s\"\n \n /* Override startfile prefix defaults.  */\n #ifndef STANDARD_STARTFILE_PREFIX_1\n@@ -141,3 +143,11 @@ do {\t\t\t\t\t\t         \\\n /* mingw32 atexit function is safe to use in shared libraries.  Use it\n    to register C++ static destructors.  */\n #define TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT hook_bool_void_true\n+\n+/* JCR_SECTION works on mingw32.  */\n+#undef TARGET_USE_JCR_SECTION\n+#define TARGET_USE_JCR_SECTION 1\n+\n+#if !TARGET_64BIT\n+#define MD_UNWIND_SUPPORT \"config/i386/w32-unwind.h\"\n+#endif"}, {"sha": "61e42997a61d610085ce1e499de1281a04c27c45", "filename": "gcc/config/i386/w32-unwind.h", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/gcc%2Fconfig%2Fi386%2Fw32-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/gcc%2Fconfig%2Fi386%2Fw32-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fw32-unwind.h?ref=76f5e2005dad6bad5cc4da4fea55f9c85f1fc370", "patch": "@@ -0,0 +1,215 @@\n+/* Definitions for Dwarf2 EH unwind support for Windows32 targets \n+   Copyright (C) 2007\n+   Free Software Foundation, Inc.\n+   Contributed by Pascal Obry  <obry@adacore.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file with other programs, and to distribute\n+those programs without any restriction coming from the use of this\n+file.  (The General Public License restrictions do apply in other\n+respects; for example, they cover modification of the file, and\n+distribution when not linked into another program.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* This file implements the md_fallback_frame_state_for routine for\n+   Windows, triggered when the GCC table based unwinding process hits a\n+   frame for which no unwind info has been registered. This typically\n+   occurs when raising an exception from a signal handler, because the\n+   handler is actually called from the OS kernel.\n+\n+   The basic idea is to detect that we are indeed trying to unwind past a\n+   signal handler and to fill out the GCC internal unwinding structures for\n+   the OS kernel frame as if it had been directly called from the\n+   interrupted context.\n+\n+   This is all assuming that the code to set the handler asked the kernel\n+   to pass a pointer to such context information.\n+\n+   There is three main parts.\n+\n+   1) The first thing to do is to check if we are in a signal context. If\n+      not we can just return as there is nothing to do. We are probably on\n+      some foreign code for which no unwind frame can be found. If this is\n+      a call from the Windows signal handler, then:\n+\n+   2) We must get the signal context information. \n+\n+      * With the standard exception filter:\n+\n+      This is on Windows pointed to by an EXCEPTION_POINTERS. We know that\n+      the signal handle will call an UnhandledExceptionFilter with this\n+      parameter. The spec for this routine is:\n+\n+         LONG WINAPI UnhandledExceptionFilter(struct _EXCEPTION_POINTERS*);\n+\n+      So the pointer to struct _EXCEPTION_POINTERS must be somewhere on the\n+      stack.\n+\n+      This was found experimentally to always be at offset 0 of the context\n+      frame in all cases handled by this implementation.\n+\n+      * With the SEH exception handler:\n+\n+      In this case the signal context is directly on the stack as the SEH\n+      exception handler has the following prototype:\n+\n+         DWORD\n+         SEH_error_handler (PEXCEPTION_RECORD ExceptionRecord,\n+                            PVOID EstablisherFrame,\n+                            PCONTEXT ContextRecord,\n+                            PVOID DispatcherContext)\n+\n+      This was found experimentally to always be at offset 56 of the\n+      context frame in all cases handled by this implementation.\n+\n+   3) When we have the signal context we just have to save some registers\n+      and set the return address based on the program counter (Eip).\n+\n+   Note that this implementation follows closely the same principles as the\n+   GNU/Linux and OSF ones.  */\n+\n+#define WIN32_MEAN_AND_LEAN\n+#include <windows.h>\n+/* Patterns found experimentally to be on a Windows signal handler  */\n+\n+/* In a standard exception filter  */\n+\n+#define SIG_PAT1 \\\n+      (pc_[-2] == 0xff && pc_[-1] == 0xd0     /* call %eax           */ \\\n+      && pc_[0] == 0x83 && pc_[1] == 0xf8)    /* cmp 0xdepl,%eax     */\n+\n+#define SIG_PAT2 \\\n+        (pc_[-5] == 0xe8 && pc_[-4] == 0x68   /* call (depl16)       */ \\\n+         && pc_[0] == 0xc3)                   /* ret                 */\n+\n+/* In a Win32 SEH handler  */\n+\n+#define SIG_SEH1 \\\n+        (pc_[-5] == 0xe8                      /* call addr           */ \\\n+         && pc_[0] == 0x83 && pc_[1] == 0xc4  /* add 0xval,%esp      */ \\\n+         && pc_[3] == 0xb8)                   /* mov 0xval,%eax      */\n+\n+#define SIG_SEH2 \\\n+        (pc_[-5] == 0x8b && pc_[-4] == 0x4d   /* mov depl(%ebp),%ecx */ \\\n+         && pc_[0] == 0x64 && pc_[1] == 0x8b) /* mov %fs:(0),<reg>   */ \\\n+\n+/* In the GCC alloca (stack probing)  */\n+\n+#define SIG_ALLOCA \\\n+          (pc_[-1] == 0x83                    /* orl $0x0,(%ecx)     */ \\\n+\t   && pc_[0] == 0x9 && pc_[1] == 0                              \\\n+\t   && pc_[2] == 0x2d && pc_[3] == 0   /* subl $0x1000,%eax   */ \\\n+\t   && pc_[4] == 0x10 && pc_[5] == 0)\n+\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR i386_w32_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+i386_w32_fallback_frame_state (struct _Unwind_Context *context, \n+\t\t\t       _Unwind_FrameState *fs)\n+\n+{\n+  void * ctx_ra_  = (void *)(context->ra);  /* return address */\n+  void * ctx_cfa_ = (void *)(context->cfa); /* context frame address */\n+  unsigned char * pc_ = (unsigned char *) ctx_ra_;\n+\n+  /* In the test below we look for two specific patterns found\n+     experimentally to be in the Windows signal handler.  */\n+\n+  if (SIG_PAT1 || SIG_PAT2 || SIG_SEH1 || SIG_SEH2)\n+    {\n+      PEXCEPTION_POINTERS weinfo_;\n+      PCONTEXT proc_ctx_;\n+      long new_cfa_;\n+\n+      if (SIG_SEH1) \n+\tproc_ctx_ = (PCONTEXT) (*(int*)(ctx_cfa_ + 56));\n+      else if (SIG_SEH2)\n+\tproc_ctx_ = (PCONTEXT) (*(int*)(ctx_cfa_ + 8));\n+      else\n+\t{\n+\t  weinfo_ = (PEXCEPTION_POINTERS) (*(int*)ctx_cfa_);\n+\t  proc_ctx_ = weinfo_->ContextRecord;\n+\t}\n+\n+      /* The new context frame address is the stack pointer.  */\n+\n+      new_cfa_ = proc_ctx_->Esp;\n+      fs->regs.cfa_how = CFA_REG_OFFSET;\n+      fs->regs.cfa_reg = __builtin_dwarf_sp_column();\n+      fs->regs.cfa_offset = new_cfa_ - (long) ctx_cfa_;\n+\n+      /* Save some registers.  */\n+\n+      fs->regs.reg[0].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[0].loc.offset = (long)&proc_ctx_->Eax - new_cfa_;\n+      fs->regs.reg[3].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[3].loc.offset = (long)&proc_ctx_->Ebx - new_cfa_;\n+      fs->regs.reg[1].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[1].loc.offset = (long)&proc_ctx_->Ecx - new_cfa_;\n+      fs->regs.reg[2].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[2].loc.offset = (long)&proc_ctx_->Edx - new_cfa_;\n+      fs->regs.reg[6].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[6].loc.offset = (long)&proc_ctx_->Esi - new_cfa_;\n+      fs->regs.reg[7].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[7].loc.offset = (long)&proc_ctx_->Edi - new_cfa_;\n+      fs->regs.reg[9].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[9].loc.offset = (long)&proc_ctx_->Eip - new_cfa_;\n+      fs->regs.reg[4].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[4].loc.offset = (long)&proc_ctx_->Ebp - new_cfa_;\n+\n+      /* Set the return address to Eip + 1. As we can be called multiple\n+\t times we use another register for this.  */\n+      \n+      proc_ctx_->Dr0 = proc_ctx_->Eip + 1;\n+      fs->regs.reg[8].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[8].loc.offset = (long)&proc_ctx_->Dr0 - new_cfa_;\n+      fs->retaddr_column = 8;\n+      return _URC_NO_REASON;\n+    }\n+\n+  /* Unwinding through _alloca, propagating from a trap triggered by\n+     one of it's probes prior to the real SP adjustment. The only\n+     operations of interest performed is \"pushl %ecx\", followed by\n+     ecx clobbering.  */\n+\n+  else if (SIG_ALLOCA) \n+    {\n+      /* Only one push between entry in _alloca and the probe trap.  */ \n+      long new_cfa_ = (long) ctx_cfa_ + 4;\n+\n+      fs->regs.cfa_how = CFA_REG_OFFSET;\n+      fs->regs.cfa_reg = __builtin_dwarf_sp_column();\n+      fs->regs.cfa_offset = new_cfa_ - (long) ctx_cfa_;\n+\n+      /* The saved value of %ecx is at CFA - 4 */\n+      fs->regs.reg[1].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[1].loc.offset = -4;\n+\n+      /* and what is stored at the CFA is the return address.  */\n+      fs->retaddr_column = 8;\n+      fs->regs.reg[8].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[8].loc.offset = 0;\n+ \n+      return _URC_NO_REASON;\n+    }\n+  else\n+    return _URC_END_OF_STACK;\n+}"}, {"sha": "9cdf81e8eb8fd2de1342da26f0027462af21bb9b", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=76f5e2005dad6bad5cc4da4fea55f9c85f1fc370", "patch": "@@ -1,3 +1,10 @@\n+2007-06-14  Danny Smith  <dannysmith@users.sourceforge.net>\n+\n+\t* config.host(*-cygwin* |*-mingw* ): Add crtbegin.o, crtend.o to\n+\textra_parts. Add config/i386/t-cygming to tmake_file. \n+\t* config/i386/t-cygming: New file with rules for crtbegin.o, crtend.o.\n+\n+\n 2007-05-29  Zuxy Meng  <zuxy.meng@gmail.com>\n             Danny Smith  <dannysmith@users.sourceforge.net>\n "}, {"sha": "79039abc8e1a58c1c2818376e7aae18d6ee6baef", "filename": "libgcc/config.host", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=76f5e2005dad6bad5cc4da4fea55f9c85f1fc370", "patch": "@@ -370,8 +370,8 @@ i[4567]86-wrs-vxworks|i[4567]86-wrs-vxworksae)\n i[34567]86-*-pe)\n \t;;\n i[34567]86-*-cygwin* | i[34567]86-*-mingw*)\n-\textra_parts=\"crtfastmath.o\"\n-\ttmake_file=\"i386/t-crtfm\"\n+\textra_parts=\"crtbegin.o crtend.o crtfastmath.o\"\n+\ttmake_file=\"i386/t-cygming i386/t-crtfm\"\n \t;;\n x86_64-*-mingw*)\n \t;;"}, {"sha": "048cadbd5a17099cad8c6b9e06d90aaa307d6385", "filename": "libgcc/config/i386/t-cygming", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/libgcc%2Fconfig%2Fi386%2Ft-cygming", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f5e2005dad6bad5cc4da4fea55f9c85f1fc370/libgcc%2Fconfig%2Fi386%2Ft-cygming", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Ft-cygming?ref=76f5e2005dad6bad5cc4da4fea55f9c85f1fc370", "patch": "@@ -0,0 +1,11 @@\n+CUSTOM_CRTSTUFF = yes\n+\n+crtbegin.o: $(gcc_srcdir)/config/i386/cygming-crtbegin.c\n+\t$(crt_compile) -fno-omit-frame-pointer  -c \\\n+\t$(gcc_srcdir)/config/i386/cygming-crtbegin.c\n+\n+# We intentionally use a implementation-reserved init priority of 0,\n+# so allow the warning.\n+crtend.o: $(gcc_srcdir)/config/i386/cygming-crtend.c\n+\t$(crt_compile) -fno-omit-frame-pointer -Wno-error -c \\\n+\t$(gcc_srcdir)/config/i386/cygming-crtend.c"}]}