{"sha": "6c26bac268904dcdf7719bdc073f288a2c06703d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMyNmJhYzI2ODkwNGRjZGY3NzE5YmRjMDczZjI4OGEyYzA2NzAzZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T13:56:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T13:56:11Z"}, "message": "[multiple changes]\n\n2014-07-31  Javier Miranda  <miranda@adacore.com>\n\n\t* debug.adb Remove documentation of -gnatd.k (no longer needed).\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Code cleanup.\n\t* inline.ads (Backend_Inlined_Subps): New\n\tElist.\t(Backend_Not_Inlined_Subps): New Elist.\n\t(Has_Excluded_Declaration): Declaration previously located in\n\t* inline.adb (Has_Excluded_Statement): Declaration previously\n\tlocated in inline.adb\n\t* inline.adb (Has_Single_Return): Moved out of\n\tBuild_Body_To_Inline to avoid having duplicated code.\n\t(Number_Of_Statements): New subprogram.\n\t(Register_Backend_Inlined_Subprogram): New subprogram.\n\t(Register_Backend_Not_Inlined_Subprogram): New subprogram.\n\t(Add_Inlined_Subprogram): Register backend inlined subprograms and\n\talso register subprograms that cannot be inlined by the backend.\n\t(Has_Excluded_Declaration): Moved out of Build_Body_To_Inline\n\tto avoid having duplicated code.  Replace occurrences of\n\tDebug_Flag_Dot_K by Back_End_Inlining.\n\t* sem_res.adb (Resolve_Call): Code cleanup.\n\t* exp_ch6.adb (Expand_Call): Complete previous patch. Replace\n\toccurrence of Debug_Flag_Dot_K by Back_End_Inlining.\n\t(List_Inlining_Info): Add listing of subprograms passed to the\n\tbackend and listing of subprograms that cannot be inlined by\n\tthe backend.\n\t* sem_ch12.adb, sem_ch3.adb Replace occurrences of\n\tDebug_Flag_Dot_K by Back_End_Inlining.\n\n2014-07-31  Robert Dewar  <dewar@adacore.com>\n\n\t* nlists.ads: Minor code fix (remove unwise Inline for\n\tList_Length).\n\nFrom-SVN: r213373", "tree": {"sha": "dc790bc4944cf9c7404983c0805543add2e62e4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc790bc4944cf9c7404983c0805543add2e62e4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c26bac268904dcdf7719bdc073f288a2c06703d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c26bac268904dcdf7719bdc073f288a2c06703d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c26bac268904dcdf7719bdc073f288a2c06703d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c26bac268904dcdf7719bdc073f288a2c06703d/comments", "author": null, "committer": null, "parents": [{"sha": "0c9aebea0f70c507b2eb63dd83c5f0ff3ee55793", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c9aebea0f70c507b2eb63dd83c5f0ff3ee55793", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c9aebea0f70c507b2eb63dd83c5f0ff3ee55793"}], "stats": {"total": 1134, "additions": 620, "deletions": 514}, "files": [{"sha": "e3f2fa39da0980d9f828361566462595e38d9230", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6c26bac268904dcdf7719bdc073f288a2c06703d", "patch": "@@ -1,3 +1,36 @@\n+2014-07-31  Javier Miranda  <miranda@adacore.com>\n+\n+\t* debug.adb Remove documentation of -gnatd.k (no longer needed).\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Code cleanup.\n+\t* inline.ads (Backend_Inlined_Subps): New\n+\tElist.\t(Backend_Not_Inlined_Subps): New Elist.\n+\t(Has_Excluded_Declaration): Declaration previously located in\n+\t* inline.adb (Has_Excluded_Statement): Declaration previously\n+\tlocated in inline.adb\n+\t* inline.adb (Has_Single_Return): Moved out of\n+\tBuild_Body_To_Inline to avoid having duplicated code.\n+\t(Number_Of_Statements): New subprogram.\n+\t(Register_Backend_Inlined_Subprogram): New subprogram.\n+\t(Register_Backend_Not_Inlined_Subprogram): New subprogram.\n+\t(Add_Inlined_Subprogram): Register backend inlined subprograms and\n+\talso register subprograms that cannot be inlined by the backend.\n+\t(Has_Excluded_Declaration): Moved out of Build_Body_To_Inline\n+\tto avoid having duplicated code.  Replace occurrences of\n+\tDebug_Flag_Dot_K by Back_End_Inlining.\n+\t* sem_res.adb (Resolve_Call): Code cleanup.\n+\t* exp_ch6.adb (Expand_Call): Complete previous patch. Replace\n+\toccurrence of Debug_Flag_Dot_K by Back_End_Inlining.\n+\t(List_Inlining_Info): Add listing of subprograms passed to the\n+\tbackend and listing of subprograms that cannot be inlined by\n+\tthe backend.\n+\t* sem_ch12.adb, sem_ch3.adb Replace occurrences of\n+\tDebug_Flag_Dot_K by Back_End_Inlining.\n+\n+2014-07-31  Robert Dewar  <dewar@adacore.com>\n+\n+\t* nlists.ads: Minor code fix (remove unwise Inline for\n+\tList_Length).\n+\n 2014-07-31  Arnaud Charlet  <charlet@adacore.com>\n \n \t* einfo.adb: Remove VMS specific code.\n@@ -14,6 +47,7 @@\n \n \t* gcc-interface/trans.c, gcc-interface/misc.c: Remove references\n \tto VMS. Misc clean ups.\n+\t* gcc-interface/Makefile.in (gnatlib-shared-vms): Remove.\n \n 2014-07-31  Robert Dewar  <dewar@adacore.com>\n "}, {"sha": "94da8ec7db841adabdbb6801995cc90922f51634", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=6c26bac268904dcdf7719bdc073f288a2c06703d", "patch": "@@ -101,7 +101,7 @@ package body Debug is\n    --  d.h\n    --  d.i  Ignore Warnings pragmas\n    --  d.j  Generate listing of frontend inlined calls\n-   --  d.k  Enable new support for frontend inlining\n+   --  d.k\n    --  d.l  Use Ada 95 semantics for limited function returns\n    --  d.m  For -gnatl, print full source only for main unit\n    --  d.n  Print source file names\n@@ -533,10 +533,6 @@ package body Debug is\n    --       to the backend. This is useful to locate skipped calls that must be\n    --       inlined by the frontend.\n \n-   --  d.k  Enable new semantics of frontend inlining. This is useful to test\n-   --       this new feature in all the platforms. What *is* this new semantics\n-   --       which doesn't seem to be documented anywhere???\n-\n    --  d.l  Use Ada 95 semantics for limited function returns. This may be\n    --       used to work around the incompatibility introduced by AI-318-2.\n    --       It is useful only in -gnat05 mode."}, {"sha": "561fdfc5629f422d31184aaba7ee3aa201945a58", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 84, "deletions": 8, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=6c26bac268904dcdf7719bdc073f288a2c06703d", "patch": "@@ -3830,15 +3830,14 @@ package body Exp_Ch6 is\n             return;\n          end if;\n \n-         --  Back end inlining: let the back end handle it\n+         --  Handle inlining. No action needed if the subprogram is not inlined\n \n-         if Back_End_Inlining and then Is_Inlined (Subp) then\n-            Add_Inlined_Body (Subp);\n-            Register_Backend_Call (Call_Node);\n+         if not Is_Inlined (Subp) then\n+            null;\n \n-         --  Handle inlining (old semantics)\n+         --  Handle frontend inlining\n \n-         elsif Is_Inlined (Subp) and then not Debug_Flag_Dot_K then\n+         elsif not Back_End_Inlining then\n             Inlined_Subprogram : declare\n                Bod         : Node_Id;\n                Must_Inline : Boolean := False;\n@@ -3924,9 +3923,22 @@ package body Exp_Ch6 is\n                end if;\n             end Inlined_Subprogram;\n \n-         --  Handle inlining (new semantics)\n+         --  Back end inlining: let the back end handle it\n+\n+         elsif No (Unit_Declaration_Node (Subp))\n+           or else\n+             Nkind (Unit_Declaration_Node (Subp)) /= N_Subprogram_Declaration\n+           or else\n+             No (Body_To_Inline (Unit_Declaration_Node (Subp)))\n+         then\n+            Add_Inlined_Body (Subp);\n+            Register_Backend_Call (Call_Node);\n+\n+         --  Frontend expansion of supported functions returning unconstrained\n+         --  types\n \n-         elsif Is_Inlined (Subp) then\n+         else pragma Assert (Ekind (Subp) = E_Function\n+                               and then Returns_Unconstrained_Type (Subp));\n             declare\n                Spec : constant Node_Id := Unit_Declaration_Node (Subp);\n \n@@ -9720,6 +9732,70 @@ package body Exp_Ch6 is\n             Next_Elmt (Elmt);\n          end loop;\n       end if;\n+\n+      --  Generate listing of subprograms passed to the backend\n+\n+      if Present (Backend_Inlined_Subps)\n+        and then Back_End_Inlining\n+      then\n+         Count := 0;\n+\n+         Elmt := First_Elmt (Backend_Inlined_Subps);\n+         while Present (Elmt) loop\n+            Nod := Node (Elmt);\n+\n+            Count := Count + 1;\n+\n+            if Count = 1 then\n+               Write_Str\n+                 (\"Listing of inlined subprograms passed to the backend\");\n+               Write_Eol;\n+            end if;\n+\n+            Write_Str (\"  \");\n+            Write_Int (Count);\n+            Write_Str (\":\");\n+            Write_Name (Chars (Nod));\n+            Write_Str (\" (\");\n+            Write_Location (Sloc (Nod));\n+            Write_Str (\")\");\n+            Output.Write_Eol;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end if;\n+\n+      --  Generate listing of subprogram that cannot be inlined by the backend\n+\n+      if Present (Backend_Not_Inlined_Subps)\n+        and then Back_End_Inlining\n+      then\n+         Count := 0;\n+\n+         Elmt := First_Elmt (Backend_Not_Inlined_Subps);\n+         while Present (Elmt) loop\n+            Nod := Node (Elmt);\n+\n+            Count := Count + 1;\n+\n+            if Count = 1 then\n+               Write_Str\n+                 (\"Listing of subprograms that cannot inline the backend\");\n+               Write_Eol;\n+            end if;\n+\n+            Write_Str (\"  \");\n+            Write_Int (Count);\n+            Write_Str (\":\");\n+            Write_Name (Chars (Nod));\n+            Write_Str (\" (\");\n+            Write_Location (Sloc (Nod));\n+            Write_Str (\")\");\n+            Output.Write_Eol;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end if;\n    end List_Inlining_Info;\n \n end Exp_Ch6;"}, {"sha": "a2d41b220056518af3f8900ebdcf3806d4c53a49", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 413, "deletions": 440, "changes": 853, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=6c26bac268904dcdf7719bdc073f288a2c06703d", "patch": "@@ -24,7 +24,6 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n@@ -143,36 +142,46 @@ package body Inline is\n    -- Local Subprograms --\n    -----------------------\n \n-   function Get_Code_Unit_Entity (E : Entity_Id) return Entity_Id;\n-   pragma Inline (Get_Code_Unit_Entity);\n-   --  Return the entity node for the unit containing E. Always return the spec\n-   --  for a package.\n-\n-   function In_Main_Unit_Or_Subunit (E : Entity_Id) return Boolean;\n-   --  Return True if E is in the main unit or its spec or in a subunit\n-\n    procedure Add_Call (Called : Entity_Id; Caller : Entity_Id := Empty);\n    --  Make two entries in Inlined table, for an inlined subprogram being\n    --  called, and for the inlined subprogram that contains the call. If\n    --  the call is in the main compilation unit, Caller is Empty.\n \n+   procedure Add_Inlined_Subprogram (Index : Subp_Index);\n+   --  Add the subprogram to the list of inlined subprogram for the unit\n+\n    function Add_Subp (E : Entity_Id) return Subp_Index;\n    --  Make entry in Inlined table for subprogram E, or return table index\n    --  that already holds E.\n \n+   function Get_Code_Unit_Entity (E : Entity_Id) return Entity_Id;\n+   pragma Inline (Get_Code_Unit_Entity);\n+   --  Return the entity node for the unit containing E. Always return the spec\n+   --  for a package.\n+\n    function Has_Initialized_Type (E : Entity_Id) return Boolean;\n    --  If a candidate for inlining contains type declarations for types with\n    --  non-trivial initialization procedures, they are not worth inlining.\n \n+   function Has_Single_Return (N : Node_Id) return Boolean;\n+   --  In general we cannot inline functions that return unconstrained type.\n+   --  However, we can handle such functions if all return statements return\n+   --  a local variable that is the only declaration in the body of the\n+   --  function. In that case the call can be replaced by that local\n+   --  variable as is done for other inlined calls.\n+\n+   function In_Main_Unit_Or_Subunit (E : Entity_Id) return Boolean;\n+   --  Return True if E is in the main unit or its spec or in a subunit\n+\n    function Is_Nested (E : Entity_Id) return Boolean;\n    --  If the function is nested inside some other function, it will always\n    --  be compiled if that function is, so don't add it to the inline list.\n    --  We cannot compile a nested function outside the scope of the containing\n    --  function anyway. This is also the case if the function is defined in a\n    --  task body or within an entry (for example, an initialization procedure).\n \n-   procedure Add_Inlined_Subprogram (Index : Subp_Index);\n-   --  Add the subprogram to the list of inlined subprogram for the unit\n+   function Number_Of_Statements (Stats : List_Id) return Natural;\n+   --  Return the number of statements in the list\n \n    ------------------------------\n    -- Deferred Cleanup Actions --\n@@ -415,6 +424,13 @@ package body Inline is\n       --\n       --  This procedure must be carefully coordinated with the back end.\n \n+      procedure Register_Backend_Inlined_Subprogram (Subp : Entity_Id);\n+      --  Append Subp to the list of subprograms inlined by the backend\n+\n+      procedure Register_Backend_Not_Inlined_Subprogram (Subp : Entity_Id);\n+      --  Append Subp to the list of subprograms that cannot be inlined by\n+      --  the backend\n+\n       ----------------------------\n       -- Back_End_Cannot_Inline --\n       ----------------------------\n@@ -461,6 +477,32 @@ package body Inline is\n          return False;\n       end Back_End_Cannot_Inline;\n \n+      -----------------------------------------\n+      -- Register_Backend_Inlined_Subprogram --\n+      -----------------------------------------\n+\n+      procedure Register_Backend_Inlined_Subprogram (Subp : Entity_Id) is\n+      begin\n+         if Backend_Inlined_Subps = No_Elist then\n+            Backend_Inlined_Subps := New_Elmt_List;\n+         end if;\n+\n+         Append_Elmt (Subp, To => Backend_Inlined_Subps);\n+      end Register_Backend_Inlined_Subprogram;\n+\n+      ---------------------------------------------\n+      -- Register_Backend_Not_Inlined_Subprogram --\n+      ---------------------------------------------\n+\n+      procedure Register_Backend_Not_Inlined_Subprogram (Subp : Entity_Id) is\n+      begin\n+         if Backend_Not_Inlined_Subps = No_Elist then\n+            Backend_Not_Inlined_Subps := New_Elmt_List;\n+         end if;\n+\n+         Append_Elmt (Subp, To => Backend_Not_Inlined_Subps);\n+      end Register_Backend_Not_Inlined_Subprogram;\n+\n    --  Start of processing for Add_Inlined_Subprogram\n \n    begin\n@@ -480,8 +522,11 @@ package body Inline is\n       then\n          if Back_End_Cannot_Inline (E) then\n             Set_Is_Inlined (E, False);\n+            Register_Backend_Not_Inlined_Subprogram (E);\n \n          else\n+            Register_Backend_Inlined_Subprogram (E);\n+\n             if No (Last_Inlined) then\n                Set_First_Inlined_Subprogram (Cunit (Main_Unit), E);\n             else\n@@ -490,6 +535,8 @@ package body Inline is\n \n             Last_Inlined := E;\n          end if;\n+      else\n+         Register_Backend_Not_Inlined_Subprogram (E);\n       end if;\n \n       Inlined.Table (Index).Listed := True;\n@@ -850,9 +897,6 @@ package body Inline is\n       Max_Size        : constant := 10;\n       Stat_Count      : Integer := 0;\n \n-      function Has_Excluded_Declaration (Decls : List_Id) return Boolean;\n-      --  Check for declarations that make inlining not worthwhile\n-\n       function Has_Excluded_Statement   (Stats : List_Id) return Boolean;\n       --  Check for statements that make inlining not worthwhile: any tasking\n       --  statement, nested at any level. Keep track of total number of\n@@ -865,13 +909,6 @@ package body Inline is\n       --  conflict with subsequent inlinings, so that it is unsafe to try to\n       --  inline in such a case.\n \n-      function Has_Single_Return return Boolean;\n-      --  In general we cannot inline functions that return unconstrained type.\n-      --  However, we can handle such functions if all return statements return\n-      --  a local variable that is the only declaration in the body of the\n-      --  function. In that case the call can be replaced by that local\n-      --  variable as is done for other inlined calls.\n-\n       function Has_Single_Return_In_GNATprove_Mode return Boolean;\n       --  This function is called only in GNATprove mode, and it returns\n       --  True if the subprogram has no or a single return statement as\n@@ -888,103 +925,6 @@ package body Inline is\n       --  unconstrained type, the secondary stack is involved, and it\n       --  is not worth inlining.\n \n-      ------------------------------\n-      -- Has_Excluded_Declaration --\n-      ------------------------------\n-\n-      function Has_Excluded_Declaration (Decls : List_Id) return Boolean is\n-         D : Node_Id;\n-\n-         function Is_Unchecked_Conversion (D : Node_Id) return Boolean;\n-         --  Nested subprograms make a given body ineligible for inlining, but\n-         --  we make an exception for instantiations of unchecked conversion.\n-         --  The body has not been analyzed yet, so check the name, and verify\n-         --  that the visible entity with that name is the predefined unit.\n-\n-         -----------------------------\n-         -- Is_Unchecked_Conversion --\n-         -----------------------------\n-\n-         function Is_Unchecked_Conversion (D : Node_Id) return Boolean is\n-            Id   : constant Node_Id := Name (D);\n-            Conv : Entity_Id;\n-\n-         begin\n-            if Nkind (Id) = N_Identifier\n-              and then Chars (Id) = Name_Unchecked_Conversion\n-            then\n-               Conv := Current_Entity (Id);\n-\n-            elsif Nkind_In (Id, N_Selected_Component, N_Expanded_Name)\n-              and then Chars (Selector_Name (Id)) = Name_Unchecked_Conversion\n-            then\n-               Conv := Current_Entity (Selector_Name (Id));\n-            else\n-               return False;\n-            end if;\n-\n-            return Present (Conv)\n-              and then Is_Predefined_File_Name\n-                         (Unit_File_Name (Get_Source_Unit (Conv)))\n-              and then Is_Intrinsic_Subprogram (Conv);\n-         end Is_Unchecked_Conversion;\n-\n-      --  Start of processing for Has_Excluded_Declaration\n-\n-      begin\n-         D := First (Decls);\n-         while Present (D) loop\n-            if Nkind (D) = N_Function_Instantiation\n-              and then not Is_Unchecked_Conversion (D)\n-            then\n-               Cannot_Inline\n-                 (\"cannot inline & (nested function instantiation)?\",\n-                  D, Subp);\n-               return True;\n-\n-            elsif Nkind (D) = N_Protected_Type_Declaration then\n-               Cannot_Inline\n-                 (\"cannot inline & (nested protected type declaration)?\",\n-                  D, Subp);\n-               return True;\n-\n-            elsif Nkind (D) = N_Package_Declaration then\n-               Cannot_Inline\n-                 (\"cannot inline & (nested package declaration)?\",\n-                  D, Subp);\n-               return True;\n-\n-            elsif Nkind (D) = N_Package_Instantiation then\n-               Cannot_Inline\n-                 (\"cannot inline & (nested package instantiation)?\",\n-                  D, Subp);\n-               return True;\n-\n-            elsif Nkind (D) = N_Subprogram_Body then\n-               Cannot_Inline\n-                 (\"cannot inline & (nested subprogram)?\",\n-                  D, Subp);\n-               return True;\n-\n-            elsif Nkind (D) = N_Procedure_Instantiation then\n-               Cannot_Inline\n-                 (\"cannot inline & (nested procedure instantiation)?\",\n-                  D, Subp);\n-               return True;\n-\n-            elsif Nkind (D) = N_Task_Type_Declaration then\n-               Cannot_Inline\n-                 (\"cannot inline & (nested task type declaration)?\",\n-                  D, Subp);\n-               return True;\n-            end if;\n-\n-            Next (D);\n-         end loop;\n-\n-         return False;\n-      end Has_Excluded_Declaration;\n-\n       ----------------------------\n       -- Has_Excluded_Statement --\n       ----------------------------\n@@ -1012,7 +952,7 @@ package body Inline is\n \n             elsif Nkind (S) = N_Block_Statement then\n                if Present (Declarations (S))\n-                 and then Has_Excluded_Declaration (Declarations (S))\n+                 and then Has_Excluded_Declaration (Subp, Declarations (S))\n                then\n                   return True;\n \n@@ -1108,89 +1048,6 @@ package body Inline is\n          return False;\n       end Has_Pending_Instantiation;\n \n-      ------------------------\n-      --  Has_Single_Return --\n-      ------------------------\n-\n-      function Has_Single_Return return Boolean is\n-         Return_Statement : Node_Id := Empty;\n-\n-         function Check_Return (N : Node_Id) return Traverse_Result;\n-\n-         ------------------\n-         -- Check_Return --\n-         ------------------\n-\n-         function Check_Return (N : Node_Id) return Traverse_Result is\n-         begin\n-            if Nkind (N) = N_Simple_Return_Statement then\n-               if Present (Expression (N))\n-                 and then Is_Entity_Name (Expression (N))\n-               then\n-                  if No (Return_Statement) then\n-                     Return_Statement := N;\n-                     return OK;\n-\n-                  elsif Chars (Expression (N)) =\n-                        Chars (Expression (Return_Statement))\n-                  then\n-                     return OK;\n-\n-                  else\n-                     return Abandon;\n-                  end if;\n-\n-               --  A return statement within an extended return is a noop\n-               --  after inlining.\n-\n-               elsif No (Expression (N))\n-                 and then Nkind (Parent (Parent (N))) =\n-                                         N_Extended_Return_Statement\n-               then\n-                  return OK;\n-\n-               else\n-                  --  Expression has wrong form\n-\n-                  return Abandon;\n-               end if;\n-\n-            --  We can only inline a build-in-place function if\n-            --  it has a single extended return.\n-\n-            elsif Nkind (N) = N_Extended_Return_Statement then\n-               if No (Return_Statement) then\n-                  Return_Statement := N;\n-                  return OK;\n-\n-               else\n-                  return Abandon;\n-               end if;\n-\n-            else\n-               return OK;\n-            end if;\n-         end Check_Return;\n-\n-         function Check_All_Returns is new Traverse_Func (Check_Return);\n-\n-      --  Start of processing for Has_Single_Return\n-\n-      begin\n-         if Check_All_Returns (N) /= OK then\n-            return False;\n-\n-         elsif Nkind (Return_Statement) = N_Extended_Return_Statement then\n-            return True;\n-\n-         else\n-            return Present (Declarations (N))\n-              and then Present (First (Declarations (N)))\n-              and then Chars (Expression (Return_Statement)) =\n-                       Chars (Defining_Identifier (First (Declarations (N))));\n-         end if;\n-      end Has_Single_Return;\n-\n       -----------------------------------------\n       -- Has_Single_Return_In_GNATprove_Mode --\n       -----------------------------------------\n@@ -1330,7 +1187,7 @@ package body Inline is\n         and then not Is_Access_Type (Etype (Subp))\n         and then not Is_Constrained (Etype (Subp))\n       then\n-         if not Has_Single_Return then\n+         if not Has_Single_Return (N) then\n             Cannot_Inline\n               (\"cannot inline & (unconstrained return type)?\", N, Subp);\n             return;\n@@ -1348,7 +1205,7 @@ package body Inline is\n       end if;\n \n       if Present (Declarations (N))\n-        and then Has_Excluded_Declaration (Declarations (N))\n+        and then Has_Excluded_Declaration (Subp, Declarations (N))\n       then\n          return;\n       end if;\n@@ -1502,7 +1359,7 @@ package body Inline is\n \n       --  Old semantics\n \n-      if not Debug_Flag_Dot_K then\n+      if not Back_End_Inlining then\n \n          --  Do not emit warning if this is a predefined unit which is not\n          --  the main unit. With validity checks enabled, some predefined\n@@ -1939,19 +1796,10 @@ package body Inline is\n          Subp : Entity_Id) return Boolean\n       is\n          Max_Size   : constant := 10;\n-         Stat_Count : Integer := 0;\n \n          function Has_Excluded_Contract return Boolean;\n          --  Check for contracts that cannot be inlined\n \n-         function Has_Excluded_Declaration (Decls : List_Id) return Boolean;\n-         --  Check for declarations that make inlining not worthwhile\n-\n-         function Has_Excluded_Statement   (Stats : List_Id) return Boolean;\n-         --  Check for statements that make inlining not worthwhile: any\n-         --  tasking statement, nested at any level. Keep track of total\n-         --  number of elementary statements, as a measure of acceptable size.\n-\n          function Has_Pending_Instantiation return Boolean;\n          --  Return True if some enclosing body contains instantiations that\n          --  appear before the corresponding generic body.\n@@ -2046,218 +1894,6 @@ package body Inline is\n             return False;\n          end Has_Excluded_Contract;\n \n-         ------------------------------\n-         -- Has_Excluded_Declaration --\n-         ------------------------------\n-\n-         function Has_Excluded_Declaration (Decls : List_Id) return Boolean is\n-            D : Node_Id;\n-\n-            function Is_Unchecked_Conversion (D : Node_Id) return Boolean;\n-            --  Nested subprograms make a given body ineligible for inlining,\n-            --  but we make an exception for instantiations of unchecked\n-            --  conversion. The body has not been analyzed yet, so check the\n-            --  name, and verify that the visible entity with that name is the\n-            --  predefined unit.\n-\n-            -----------------------------\n-            -- Is_Unchecked_Conversion --\n-            -----------------------------\n-\n-            function Is_Unchecked_Conversion (D : Node_Id) return Boolean is\n-               Id   : constant Node_Id := Name (D);\n-               Conv : Entity_Id;\n-\n-            begin\n-               if Nkind (Id) = N_Identifier\n-                 and then Chars (Id) = Name_Unchecked_Conversion\n-               then\n-                  Conv := Current_Entity (Id);\n-\n-               elsif Nkind_In (Id, N_Selected_Component, N_Expanded_Name)\n-                 and then\n-                   Chars (Selector_Name (Id)) = Name_Unchecked_Conversion\n-               then\n-                  Conv := Current_Entity (Selector_Name (Id));\n-               else\n-                  return False;\n-               end if;\n-\n-               return Present (Conv)\n-                 and then Is_Predefined_File_Name\n-                            (Unit_File_Name (Get_Source_Unit (Conv)))\n-                 and then Is_Intrinsic_Subprogram (Conv);\n-            end Is_Unchecked_Conversion;\n-\n-         --  Start of processing for Has_Excluded_Declaration\n-\n-         begin\n-            D := First (Decls);\n-            while Present (D) loop\n-               if Nkind (D) = N_Function_Instantiation\n-                 and then not Is_Unchecked_Conversion (D)\n-               then\n-                  Cannot_Inline\n-                    (\"cannot inline & (nested function instantiation)?\",\n-                     D, Subp);\n-                  return True;\n-\n-               elsif Nkind (D) = N_Protected_Type_Declaration then\n-                  Cannot_Inline\n-                    (\"cannot inline & (nested protected type declaration)?\",\n-                     D, Subp);\n-                  return True;\n-\n-               elsif Nkind (D) = N_Package_Declaration then\n-                  Cannot_Inline\n-                    (\"cannot inline & (nested package declaration)?\",\n-                     D, Subp);\n-                  return True;\n-\n-               elsif Nkind (D) = N_Package_Instantiation then\n-                  Cannot_Inline\n-                    (\"cannot inline & (nested package instantiation)?\",\n-                     D, Subp);\n-                  return True;\n-\n-               elsif Nkind (D) = N_Subprogram_Body then\n-                  Cannot_Inline\n-                    (\"cannot inline & (nested subprogram)?\",\n-                     D, Subp);\n-                  return True;\n-\n-               elsif Nkind (D) = N_Procedure_Instantiation then\n-                  Cannot_Inline\n-                    (\"cannot inline & (nested procedure instantiation)?\",\n-                     D, Subp);\n-                  return True;\n-\n-               elsif Nkind (D) = N_Task_Type_Declaration then\n-                  Cannot_Inline\n-                    (\"cannot inline & (nested task type declaration)?\",\n-                     D, Subp);\n-                  return True;\n-               end if;\n-\n-               Next (D);\n-            end loop;\n-\n-            return False;\n-         end Has_Excluded_Declaration;\n-\n-         ----------------------------\n-         -- Has_Excluded_Statement --\n-         ----------------------------\n-\n-         function Has_Excluded_Statement (Stats : List_Id) return Boolean is\n-            S : Node_Id;\n-            E : Node_Id;\n-\n-         begin\n-            S := First (Stats);\n-            while Present (S) loop\n-               Stat_Count := Stat_Count + 1;\n-\n-               if Nkind_In (S, N_Abort_Statement,\n-                            N_Asynchronous_Select,\n-                            N_Conditional_Entry_Call,\n-                            N_Delay_Relative_Statement,\n-                            N_Delay_Until_Statement,\n-                            N_Selective_Accept,\n-                            N_Timed_Entry_Call)\n-               then\n-                  Cannot_Inline\n-                    (\"cannot inline & (non-allowed statement)?\", S, Subp);\n-                  return True;\n-\n-               elsif Nkind (S) = N_Block_Statement then\n-                  if Present (Declarations (S))\n-                    and then Has_Excluded_Declaration (Declarations (S))\n-                  then\n-                     return True;\n-\n-                  elsif Present (Handled_Statement_Sequence (S)) then\n-                     if Present\n-                          (Exception_Handlers (Handled_Statement_Sequence (S)))\n-                     then\n-                        Cannot_Inline\n-                          (\"cannot inline& (exception handler)?\",\n-                           First (Exception_Handlers\n-                                    (Handled_Statement_Sequence (S))),\n-                           Subp);\n-                        return True;\n-\n-                     elsif Has_Excluded_Statement\n-                             (Statements (Handled_Statement_Sequence (S)))\n-                     then\n-                        return True;\n-                     end if;\n-                  end if;\n-\n-               elsif Nkind (S) = N_Case_Statement then\n-                  E := First (Alternatives (S));\n-                  while Present (E) loop\n-                     if Has_Excluded_Statement (Statements (E)) then\n-                        return True;\n-                     end if;\n-\n-                     Next (E);\n-                  end loop;\n-\n-               elsif Nkind (S) = N_If_Statement then\n-                  if Has_Excluded_Statement (Then_Statements (S)) then\n-                     return True;\n-                  end if;\n-\n-                  if Present (Elsif_Parts (S)) then\n-                     E := First (Elsif_Parts (S));\n-                     while Present (E) loop\n-                        if Has_Excluded_Statement (Then_Statements (E)) then\n-                           return True;\n-                        end if;\n-                        Next (E);\n-                     end loop;\n-                  end if;\n-\n-                  if Present (Else_Statements (S))\n-                    and then Has_Excluded_Statement (Else_Statements (S))\n-                  then\n-                     return True;\n-                  end if;\n-\n-               elsif Nkind (S) = N_Loop_Statement\n-                 and then Has_Excluded_Statement (Statements (S))\n-               then\n-                  return True;\n-\n-               elsif Nkind (S) = N_Extended_Return_Statement then\n-                  if Present (Handled_Statement_Sequence (S))\n-                    and then\n-                      Has_Excluded_Statement\n-                        (Statements (Handled_Statement_Sequence (S)))\n-                  then\n-                     return True;\n-\n-                  elsif Present (Handled_Statement_Sequence (S))\n-                    and then\n-                      Present (Exception_Handlers\n-                                (Handled_Statement_Sequence (S)))\n-                  then\n-                     Cannot_Inline\n-                       (\"cannot inline& (exception handler)?\",\n-                        First (Exception_Handlers\n-                          (Handled_Statement_Sequence (S))),\n-                        Subp);\n-                     return True;\n-                  end if;\n-               end if;\n-\n-               Next (S);\n-            end loop;\n-\n-            return False;\n-         end Has_Excluded_Statement;\n-\n          -------------------------------\n          -- Has_Pending_Instantiation --\n          -------------------------------\n@@ -2513,7 +2149,8 @@ package body Inline is\n                                     and then ((Optimization_Level > 0\n                                                 and then Ekind (Spec_Id) =\n                                                                    E_Function)\n-                                               or else Front_End_Inlining));\n+                                               or else Front_End_Inlining\n+                                               or else Back_End_Inlining));\n \n          Body_To_Analyze : Node_Id;\n \n@@ -2540,6 +2177,7 @@ package body Inline is\n \n          elsif Assertions_Enabled\n            and then Has_Excluded_Contract\n+           and then not Back_End_Inlining\n          then\n             return False;\n \n@@ -2563,7 +2201,7 @@ package body Inline is\n          --  Check excluded declarations\n \n          if Present (Declarations (N))\n-           and then Has_Excluded_Declaration (Declarations (N))\n+           and then Has_Excluded_Declaration (Subp, Declarations (N))\n          then\n             return False;\n          end if;\n@@ -2581,7 +2219,7 @@ package body Inline is\n                return False;\n \n             elsif Has_Excluded_Statement\n-                    (Statements (Handled_Statement_Sequence (N)))\n+                    (Subp, Statements (Handled_Statement_Sequence (N)))\n             then\n                return False;\n             end if;\n@@ -2595,7 +2233,8 @@ package body Inline is\n          if Front_End_Inlining\n            and then\n              not (Has_Pragma_Inline_Always (Subp) or else GNATprove_Mode)\n-           and then Stat_Count > Max_Size\n+           and then Number_Of_Statements\n+                      (Statements (Handled_Statement_Sequence (N))) > Max_Size\n          then\n             Cannot_Inline (\"cannot inline& (body too large)?\", N, Subp);\n             return False;\n@@ -2663,8 +2302,23 @@ package body Inline is\n                return False;\n \n             elsif Returns_Unconstrained_Type (Subp) then\n-               Cannot_Inline\n-                 (\"cannot inline & (unconstrained return type)?\", N, Subp);\n+\n+               if Back_End_Inlining\n+                 and then Can_Split_Unconstrained_Function (N)\n+               then\n+                  return True;\n+\n+               elsif Has_Single_Return (N) then\n+                  return True;\n+\n+               --  Otherwise the secondary stack is involved, and it is not\n+               --  worth inlining.\n+\n+               else\n+                  Cannot_Inline\n+                    (\"cannot inline & (unconstrained return type)?\", N, Subp);\n+               end if;\n+\n                return False;\n             end if;\n \n@@ -2680,7 +2334,7 @@ package body Inline is\n             --  separately (see Can_Split_Unconstrained_Function).\n \n             elsif Returns_Unconstrained_Type (Subp) then\n-               null;\n+               return True;\n \n             --  Check supported cases\n \n@@ -3084,7 +2738,7 @@ package body Inline is\n                Build_Body_To_Inline (N, Spec_Id);\n                Set_Is_Inlined (Spec_Id);\n             end if;\n-         else\n+         elsif not Back_End_Inlining then\n             Build_Body_To_Inline (N, Spec_Id);\n             Set_Is_Inlined (Spec_Id);\n          end if;\n@@ -3678,14 +3332,14 @@ package body Inline is\n             --  expanded into a procedure call which must be added after the\n             --  object declaration.\n \n-            if Is_Unc_Decl and then Debug_Flag_Dot_K then\n+            if Is_Unc_Decl and then Back_End_Inlining then\n                Insert_Action_After (Parent (N), Blk);\n             else\n                Set_Expression (Parent (N), Empty);\n                Insert_After (Parent (N), Blk);\n             end if;\n \n-         elsif Is_Unc and then not Debug_Flag_Dot_K then\n+         elsif Is_Unc and then not Back_End_Inlining then\n             Insert_Before (Parent (N), Blk);\n          end if;\n       end Rewrite_Function_Call;\n@@ -3780,7 +3434,7 @@ package body Inline is\n    begin\n       --  Initializations for old/new semantics\n \n-      if not Debug_Flag_Dot_K then\n+      if not Back_End_Inlining then\n          Is_Unc      := Is_Array_Type (Etype (Subp))\n                           and then not Is_Constrained (Etype (Subp));\n          Is_Unc_Decl := False;\n@@ -3824,7 +3478,7 @@ package body Inline is\n         and then\n           Nkind (First (Statements (Handled_Statement_Sequence (Orig_Bod))))\n             = N_Extended_Return_Statement\n-        and then not Debug_Flag_Dot_K\n+        and then not Back_End_Inlining\n       then\n          return;\n       end if;\n@@ -3865,7 +3519,7 @@ package body Inline is\n \n       --  Old semantics\n \n-      if not Debug_Flag_Dot_K then\n+      if not Back_End_Inlining then\n          declare\n             Bod : Node_Id;\n \n@@ -4189,7 +3843,7 @@ package body Inline is\n          --  of the result of a call to an inlined function that returns\n          --  an unconstrained type\n \n-         elsif Debug_Flag_Dot_K\n+         elsif Back_End_Inlining\n            and then Nkind (Parent (N)) = N_Object_Declaration\n            and then Is_Unc\n          then\n@@ -4429,6 +4083,224 @@ package body Inline is\n       return Unit;\n    end Get_Code_Unit_Entity;\n \n+   ------------------------------\n+   -- Has_Excluded_Declaration --\n+   ------------------------------\n+\n+   function Has_Excluded_Declaration\n+     (Subp  : Entity_Id;\n+      Decls : List_Id) return Boolean\n+   is\n+      D : Node_Id;\n+\n+      function Is_Unchecked_Conversion (D : Node_Id) return Boolean;\n+      --  Nested subprograms make a given body ineligible for inlining, but\n+      --  we make an exception for instantiations of unchecked conversion.\n+      --  The body has not been analyzed yet, so check the name, and verify\n+      --  that the visible entity with that name is the predefined unit.\n+\n+      -----------------------------\n+      -- Is_Unchecked_Conversion --\n+      -----------------------------\n+\n+      function Is_Unchecked_Conversion (D : Node_Id) return Boolean is\n+         Id   : constant Node_Id := Name (D);\n+         Conv : Entity_Id;\n+\n+      begin\n+         if Nkind (Id) = N_Identifier\n+           and then Chars (Id) = Name_Unchecked_Conversion\n+         then\n+            Conv := Current_Entity (Id);\n+\n+         elsif Nkind_In (Id, N_Selected_Component, N_Expanded_Name)\n+           and then Chars (Selector_Name (Id)) = Name_Unchecked_Conversion\n+         then\n+            Conv := Current_Entity (Selector_Name (Id));\n+         else\n+            return False;\n+         end if;\n+\n+         return Present (Conv)\n+           and then Is_Predefined_File_Name\n+                      (Unit_File_Name (Get_Source_Unit (Conv)))\n+           and then Is_Intrinsic_Subprogram (Conv);\n+      end Is_Unchecked_Conversion;\n+\n+   --  Start of processing for Has_Excluded_Declaration\n+\n+   begin\n+      D := First (Decls);\n+      while Present (D) loop\n+         if Nkind (D) = N_Subprogram_Body then\n+            Cannot_Inline\n+              (\"cannot inline & (nested subprogram)?\",\n+               D, Subp);\n+            return True;\n+\n+         elsif Nkind (D) = N_Task_Type_Declaration\n+           or else Nkind (D) = N_Single_Task_Declaration\n+         then\n+            Cannot_Inline\n+              (\"cannot inline & (nested task type declaration)?\",\n+               D, Subp);\n+            return True;\n+\n+         elsif Nkind (D) = N_Protected_Type_Declaration\n+           or else Nkind (D) = N_Single_Protected_Declaration\n+         then\n+            Cannot_Inline\n+              (\"cannot inline & (nested protected type declaration)?\",\n+               D, Subp);\n+            return True;\n+\n+         elsif Nkind (D) = N_Package_Declaration then\n+            Cannot_Inline\n+              (\"cannot inline & (nested package declaration)?\",\n+               D, Subp);\n+            return True;\n+\n+         elsif Nkind (D) = N_Function_Instantiation\n+           and then not Is_Unchecked_Conversion (D)\n+         then\n+            Cannot_Inline\n+              (\"cannot inline & (nested function instantiation)?\",\n+               D, Subp);\n+            return True;\n+\n+         elsif Nkind (D) = N_Procedure_Instantiation then\n+            Cannot_Inline\n+              (\"cannot inline & (nested procedure instantiation)?\",\n+               D, Subp);\n+            return True;\n+\n+         elsif Nkind (D) = N_Package_Instantiation then\n+            Cannot_Inline\n+              (\"cannot inline & (nested package instantiation)?\",\n+               D, Subp);\n+            return True;\n+         end if;\n+\n+         Next (D);\n+      end loop;\n+\n+      return False;\n+   end Has_Excluded_Declaration;\n+\n+   ----------------------------\n+   -- Has_Excluded_Statement --\n+   ----------------------------\n+\n+   function Has_Excluded_Statement\n+     (Subp  : Entity_Id;\n+      Stats : List_Id) return Boolean\n+   is\n+      S : Node_Id;\n+      E : Node_Id;\n+\n+   begin\n+      S := First (Stats);\n+      while Present (S) loop\n+         if Nkind_In (S, N_Abort_Statement,\n+                         N_Asynchronous_Select,\n+                         N_Conditional_Entry_Call,\n+                         N_Delay_Relative_Statement,\n+                         N_Delay_Until_Statement,\n+                         N_Selective_Accept,\n+                         N_Timed_Entry_Call)\n+         then\n+            Cannot_Inline\n+              (\"cannot inline & (non-allowed statement)?\", S, Subp);\n+            return True;\n+\n+         elsif Nkind (S) = N_Block_Statement then\n+            if Present (Declarations (S))\n+              and then Has_Excluded_Declaration (Subp, Declarations (S))\n+            then\n+               return True;\n+\n+            elsif Present (Handled_Statement_Sequence (S)) then\n+               if Present\n+                    (Exception_Handlers (Handled_Statement_Sequence (S)))\n+               then\n+                  Cannot_Inline\n+                    (\"cannot inline& (exception handler)?\",\n+                     First (Exception_Handlers\n+                              (Handled_Statement_Sequence (S))),\n+                     Subp);\n+                  return True;\n+\n+               elsif Has_Excluded_Statement\n+                       (Subp, Statements (Handled_Statement_Sequence (S)))\n+               then\n+                  return True;\n+               end if;\n+            end if;\n+\n+         elsif Nkind (S) = N_Case_Statement then\n+            E := First (Alternatives (S));\n+            while Present (E) loop\n+               if Has_Excluded_Statement (Subp, Statements (E)) then\n+                  return True;\n+               end if;\n+\n+               Next (E);\n+            end loop;\n+\n+         elsif Nkind (S) = N_If_Statement then\n+            if Has_Excluded_Statement (Subp, Then_Statements (S)) then\n+               return True;\n+            end if;\n+\n+            if Present (Elsif_Parts (S)) then\n+               E := First (Elsif_Parts (S));\n+               while Present (E) loop\n+                  if Has_Excluded_Statement (Subp, Then_Statements (E)) then\n+                     return True;\n+                  end if;\n+\n+                  Next (E);\n+               end loop;\n+            end if;\n+\n+            if Present (Else_Statements (S))\n+              and then Has_Excluded_Statement (Subp, Else_Statements (S))\n+            then\n+               return True;\n+            end if;\n+\n+         elsif Nkind (S) = N_Loop_Statement\n+           and then Has_Excluded_Statement (Subp, Statements (S))\n+         then\n+            return True;\n+\n+         elsif Nkind (S) = N_Extended_Return_Statement then\n+            if Present (Handled_Statement_Sequence (S))\n+              and then\n+                Has_Excluded_Statement\n+                  (Subp, Statements (Handled_Statement_Sequence (S)))\n+            then\n+               return True;\n+\n+            elsif Present (Handled_Statement_Sequence (S))\n+              and then\n+                Present (Exception_Handlers\n+                          (Handled_Statement_Sequence (S)))\n+            then\n+               Cannot_Inline\n+                 (\"cannot inline& (exception handler)?\",\n+                  First (Exception_Handlers (Handled_Statement_Sequence (S))),\n+                  Subp);\n+               return True;\n+            end if;\n+         end if;\n+\n+         Next (S);\n+      end loop;\n+\n+      return False;\n+   end Has_Excluded_Statement;\n+\n    --------------------------\n    -- Has_Initialized_Type --\n    --------------------------\n@@ -4457,6 +4329,89 @@ package body Inline is\n       return False;\n    end Has_Initialized_Type;\n \n+   ------------------------\n+   --  Has_Single_Return --\n+   ------------------------\n+\n+   function Has_Single_Return (N : Node_Id) return Boolean is\n+      Return_Statement : Node_Id := Empty;\n+\n+      function Check_Return (N : Node_Id) return Traverse_Result;\n+\n+      ------------------\n+      -- Check_Return --\n+      ------------------\n+\n+      function Check_Return (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Nkind (N) = N_Simple_Return_Statement then\n+            if Present (Expression (N))\n+              and then Is_Entity_Name (Expression (N))\n+            then\n+               if No (Return_Statement) then\n+                  Return_Statement := N;\n+                  return OK;\n+\n+               elsif Chars (Expression (N)) =\n+                     Chars (Expression (Return_Statement))\n+               then\n+                  return OK;\n+\n+               else\n+                  return Abandon;\n+               end if;\n+\n+            --  A return statement within an extended return is a noop\n+            --  after inlining.\n+\n+            elsif No (Expression (N))\n+              and then\n+                Nkind (Parent (Parent (N))) = N_Extended_Return_Statement\n+            then\n+               return OK;\n+\n+            else\n+               --  Expression has wrong form\n+\n+               return Abandon;\n+            end if;\n+\n+         --  We can only inline a build-in-place function if\n+         --  it has a single extended return.\n+\n+         elsif Nkind (N) = N_Extended_Return_Statement then\n+            if No (Return_Statement) then\n+               Return_Statement := N;\n+               return OK;\n+\n+            else\n+               return Abandon;\n+            end if;\n+\n+         else\n+            return OK;\n+         end if;\n+      end Check_Return;\n+\n+      function Check_All_Returns is new Traverse_Func (Check_Return);\n+\n+   --  Start of processing for Has_Single_Return\n+\n+   begin\n+      if Check_All_Returns (N) /= OK then\n+         return False;\n+\n+      elsif Nkind (Return_Statement) = N_Extended_Return_Statement then\n+         return True;\n+\n+      else\n+         return Present (Declarations (N))\n+           and then Present (First (Declarations (N)))\n+           and then Chars (Expression (Return_Statement)) =\n+                    Chars (Defining_Identifier (First (Declarations (N))));\n+      end if;\n+   end Has_Single_Return;\n+\n    -----------------------------\n    -- In_Main_Unit_Or_Subunit --\n    -----------------------------\n@@ -4613,6 +4568,24 @@ package body Inline is\n       Inlined.Release;\n    end Lock;\n \n+   --------------------------\n+   -- Number_Of_Statements --\n+   --------------------------\n+\n+   function Number_Of_Statements (Stats : List_Id) return Natural is\n+      Stat_Count : Integer := 0;\n+      Stmt       : Node_Id;\n+\n+   begin\n+      Stmt := First (Stats);\n+      while Present (Stmt) loop\n+         Stat_Count := Stat_Count + 1;\n+         Next (Stmt);\n+      end loop;\n+\n+      return Stat_Count;\n+   end Number_Of_Statements;\n+\n    ---------------------------\n    -- Register_Backend_Call --\n    ---------------------------"}, {"sha": "d07a261c2fd617ad0594b8a7cdbd898495380a82", "filename": "gcc/ada/inline.ads", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Finline.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Finline.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.ads?ref=6c26bac268904dcdf7719bdc073f288a2c06703d", "patch": "@@ -132,8 +132,16 @@ package Inline is\n      Table_Name           => \"Pending_Descriptor\");\n \n    Inlined_Calls : Elist_Id := No_Elist;\n+   --  List of frontend inlined calls\n+\n    Backend_Calls : Elist_Id := No_Elist;\n-   --  List of frontend inlined calls and inline calls passed to the backend\n+   --  List of inline calls passed to the backend\n+\n+   Backend_Inlined_Subps : Elist_Id := No_Elist;\n+   --  List of subprograms inlined by the backend\n+\n+   Backend_Not_Inlined_Subps : Elist_Id := No_Elist;\n+   --  List of subprograms that cannot be inlined by the backend\n \n    -----------------\n    -- Subprograms --\n@@ -231,6 +239,17 @@ package Inline is\n    --  expressions in the body must be converted to the desired type (which\n    --  is simply not noted in the tree without inline expansion).\n \n+   function Has_Excluded_Declaration\n+     (Subp  : Entity_Id;\n+      Decls : List_Id) return Boolean;\n+   --  Check for declarations that make inlining not worthwhile inlining Subp\n+\n+   function Has_Excluded_Statement\n+     (Subp  : Entity_Id;\n+      Stats : List_Id) return Boolean;\n+   --  Check for statements that make inlining not worthwhile: any tasking\n+   --  statement, nested at any level.\n+\n    procedure Register_Backend_Call (N : Node_Id);\n    --  Append N to the list Backend_Calls\n "}, {"sha": "9b73bfee17b56209fdd83d6f0938c5a6089ea3e8", "filename": "gcc/ada/nlists.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Fnlists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Fnlists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.ads?ref=6c26bac268904dcdf7719bdc073f288a2c06703d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -149,7 +149,6 @@ package Nlists is\n    --  No_List. (No_List is not considered to be the same as an empty list).\n \n    function List_Length (List : List_Id) return Nat;\n-   pragma Inline (List_Length);\n    --  Returns number of items in the given list. It is an error to call\n    --  this function with No_List (No_List is not considered to be the same\n    --  as an empty list)."}, {"sha": "679518c7ac7c4f30df57bb1a4d5d3a82a32d8cc5", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=6c26bac268904dcdf7719bdc073f288a2c06703d", "patch": "@@ -25,7 +25,6 @@\n \n with Aspects;  use Aspects;\n with Atree;    use Atree;\n-with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n@@ -3877,15 +3876,15 @@ package body Sem_Ch12 is\n               and then Might_Inline_Subp\n               and then not Is_Actual_Pack\n             then\n-               if not Debug_Flag_Dot_K\n+               if not Back_End_Inlining\n                  and then Front_End_Inlining\n                  and then (Is_In_Main_Unit (N)\n                             or else In_Main_Context (Current_Scope))\n                  and then Nkind (Parent (N)) /= N_Compilation_Unit\n                then\n                   Inline_Now := True;\n \n-               elsif Debug_Flag_Dot_K\n+               elsif Back_End_Inlining\n                  and then Must_Inline_Subp\n                  and then (Is_In_Main_Unit (N)\n                             or else In_Main_Context (Current_Scope))"}, {"sha": "a2634acd590a812fffa00201f05b93aec8c036cf", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=6c26bac268904dcdf7719bdc073f288a2c06703d", "patch": "@@ -3514,7 +3514,7 @@ package body Sem_Ch3 is\n          --  declaration without initializing expression and it has been\n          --  analyzed (see Expand_Inlined_Call).\n \n-         if Debug_Flag_Dot_K\n+         if Back_End_Inlining\n            and then Expander_Active\n            and then Nkind (E) = N_Function_Call\n            and then Nkind (Name (E)) in N_Has_Entity"}, {"sha": "b97616b6ec7d3ac7675216dff76dd44c2a600191", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 64, "deletions": 45, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=6c26bac268904dcdf7719bdc073f288a2c06703d", "patch": "@@ -3561,56 +3561,75 @@ package body Sem_Ch6 is\n       --  mode where we want to expand some calls in place, even with expansion\n       --  disabled, since the inlining eases formal verification.\n \n-      --  Old semantics\n+      if not GNATprove_Mode\n+        and then Expander_Active\n+        and then Serious_Errors_Detected = 0\n+        and then Present (Spec_Id)\n+        and then Has_Pragma_Inline (Spec_Id)\n+      then\n+         --  Legacy implementation (relying on frontend inlining)\n \n-      if not Debug_Flag_Dot_K then\n+         if not Back_End_Inlining then\n+            if Has_Pragma_Inline_Always (Spec_Id)\n+                 or else (Has_Pragma_Inline (Spec_Id) and Front_End_Inlining)\n+            then\n+               Build_Body_To_Inline (N, Spec_Id);\n+            end if;\n \n-         --  If the backend inlining is available then at this stage we only\n-         --  have to mark the subprogram as inlined. The expander will take\n-         --  care of registering it in the table of subprograms inlined by\n-         --  the backend a part of processing calls to it (cf. Expand_Call)\n+         --  New implementation (relying on backend inlining). Enabled by\n+         --  debug flag gnatd.z for testing\n \n-         if Present (Spec_Id)\n-           and then Expander_Active\n-           and then Back_End_Inlining\n-         then\n-            Set_Is_Inlined (Spec_Id);\n+         else\n+            if Has_Pragma_Inline_Always (Spec_Id)\n+              or else Optimization_Level > 0\n+            then\n+               --  Handle function returning an unconstrained type\n \n-         elsif Present (Spec_Id)\n-           and then Expander_Active\n-           and then\n-             (Has_Pragma_Inline_Always (Spec_Id)\n-              or else (Has_Pragma_Inline (Spec_Id) and Front_End_Inlining))\n-         then\n-            Build_Body_To_Inline (N, Spec_Id);\n-\n-         --  In GNATprove mode, inline only when there is a separate subprogram\n-         --  declaration for now, as inlining of subprogram bodies acting as\n-         --  declarations, or subprogram stubs, are not supported by frontend\n-         --  inlining. This inlining should occur after analysis of the body,\n-         --  so that it is known whether the value of SPARK_Mode applicable to\n-         --  the body, which can be defined by a pragma inside the body.\n-\n-         elsif GNATprove_Mode\n-           and then Full_Analysis\n-           and then not Inside_A_Generic\n-           and then Present (Spec_Id)\n-           and then\n-             Nkind (Parent (Parent (Spec_Id))) = N_Subprogram_Declaration\n-           and then Can_Be_Inlined_In_GNATprove_Mode (Spec_Id, Body_Id)\n-           and then not Body_Has_Contract\n-         then\n-            Build_Body_To_Inline (N, Spec_Id);\n-         end if;\n+               if Comes_From_Source (Body_Id)\n+                 and then Ekind (Spec_Id) = E_Function\n+                 and then Returns_Unconstrained_Type (Spec_Id)\n+               then\n+                  Check_And_Build_Body_To_Inline (N, Spec_Id, Body_Id);\n+\n+               else\n+                  declare\n+                     Body_Spec : constant Node_Id := Parent (Body_Id);\n+                     Subp_Body : constant Node_Id := Parent (Body_Spec);\n+                     Subp_Decl : constant List_Id := Declarations (Subp_Body);\n \n-      --  New semantics (enabled by debug flag gnatd.k for testing)\n+                  begin\n+                     --  Do not pass inlining to the backend if the subprogram\n+                     --  has declarations or statements which cannot be inlined\n+                     --  by the backend. This check is done here to emit an\n+                     --  error instead of the generic warning message reported\n+                     --  by the GCC backend (ie. \"function might not be\n+                     --  inlinable\").\n+\n+                     if Present (Subp_Decl)\n+                       and then Has_Excluded_Declaration (Spec_Id, Subp_Decl)\n+                     then\n+                        null;\n \n-      elsif Expander_Active\n-        and then Serious_Errors_Detected = 0\n-        and then Present (Spec_Id)\n-        and then Has_Pragma_Inline (Spec_Id)\n-      then\n-         Check_And_Build_Body_To_Inline (N, Spec_Id, Body_Id);\n+                     elsif Has_Excluded_Statement\n+                             (Spec_Id,\n+                              Statements\n+                                (Handled_Statement_Sequence (Subp_Body)))\n+                     then\n+                        null;\n+\n+                     --  If the backend inlining is available then at this\n+                     --  stage we only have to mark the subprogram as inlined.\n+                     --  The expander will take care of registering it in the\n+                     --  table of subprograms inlined by the backend a part of\n+                     --  processing calls to it (cf. Expand_Call)\n+\n+                     else\n+                        Set_Is_Inlined (Spec_Id);\n+                     end if;\n+                  end;\n+               end if;\n+            end if;\n+         end if;\n \n       --  In GNATprove mode, inline only when there is a separate subprogram\n       --  declaration for now, as inlining of subprogram bodies acting as\n@@ -3627,7 +3646,7 @@ package body Sem_Ch6 is\n         and then Can_Be_Inlined_In_GNATprove_Mode (Spec_Id, Body_Id)\n         and then not Body_Has_Contract\n       then\n-         Check_And_Build_Body_To_Inline (N, Spec_Id, Body_Id);\n+         Build_Body_To_Inline (N, Spec_Id);\n       end if;\n \n       --  Ada 2005 (AI-262): In library subprogram bodies, after the analysis"}, {"sha": "ad6478658ae309ad075ca69dc2df03bd077426ca", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c26bac268904dcdf7719bdc073f288a2c06703d/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=6c26bac268904dcdf7719bdc073f288a2c06703d", "patch": "@@ -5935,18 +5935,9 @@ package body Sem_Res is\n       --  check for this by traversing the type in Check_Initialization_Call.\n \n       if Is_Inlined (Nam)\n-        and then Has_Pragma_Inline_Always (Nam)\n-        and then Nkind (Unit_Declaration_Node (Nam)) = N_Subprogram_Declaration\n-        and then Present (Body_To_Inline (Unit_Declaration_Node (Nam)))\n-        and then not Debug_Flag_Dot_K\n-      then\n-         null;\n-\n-      elsif Is_Inlined (Nam)\n         and then Has_Pragma_Inline (Nam)\n         and then Nkind (Unit_Declaration_Node (Nam)) = N_Subprogram_Declaration\n         and then Present (Body_To_Inline (Unit_Declaration_Node (Nam)))\n-        and then Debug_Flag_Dot_K\n       then\n          null;\n "}]}