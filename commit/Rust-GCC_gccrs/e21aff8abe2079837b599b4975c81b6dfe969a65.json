{"sha": "e21aff8abe2079837b599b4975c81b6dfe969a65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTIxYWZmOGFiZTIwNzk4MzdiNTk5YjQ5NzVjODFiNmRmZTk2OWE2NQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-05-17T16:56:32Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-05-17T16:56:32Z"}, "message": "cgraph.h (cgraph_node): Add 'lowered' state.\n\n\n\t* cgraph.h (cgraph_node): Add 'lowered' state.\n\t(cgraph_lower_function): Declare.\n\t* cgraphunit.c (cgraph_finalize_function): Initialize lowered flag.\n\t(cgraph_lower_function): New function.\n\t(cgraph_create_edges): Deal with lowered function bodies.\n\t(verify_cgraph_node): Likewise.\n\t(cgraph_analyze_function): Do lowering job.\n\t(cgraph_build_static_cdtor): Likewise.\n\t* function.h (struct function): Add saved_eh and saved_cfg.\n\t* integrate.c (copy_decl_for_inlining): Kill LABEL_DECL_UID field.\n\t* tree-cfg.c (fold_cond_expr_cond): Export.\n\t* tree-flow.h (fold_cond_expr_cond): Declare.\n\t* tree-inline.c: Include basic-block, ggc, tree-flow, except.h and\n\tpointer-set.\n\t(struct_inline_data): Kill fnd, first_inlined_fn, ret_label,\n\tin_target_cleanup_p, tree_pruner, tsi; add callee, caller and\n\tcallee_cfun, block, eh_region, eh_region_offset.\n\t(inlining_p): New predicate.\n\t(remap_decl): Update for new inline_data; declare newly created inline\n\tvars in low gimple way.\n\t(copy_body_r): Update for new datastructure, simplify some of handling\n\twhen we are in gimple; remap LABEL_DECLs for EH; copy TREE_BLOCK;\n\tdeal with RESX_EXPRs.\n\t(copy_bb): New.\n\t(copy_edges_for_bb): Likewise.\n\t(remap_decl_1): New.\n\t(copy_cfg_body): New.\n\t(copy_generic_body): Rewrite to work on low gimple.\n\t(copy_body): Turn into simple wrapper around copy_cfg_body.\n\t(setup_one_parameter): Insert new statements into given basic block.\n\t(initialize_initialized_parameters): Likewise, reorganize way things are\n\tgimplified.\n\t(declare_return_variable): Update for new inline data datastructure.\n\t(inline_forbidden_p): Work on low gimple.\n\t(estimate_num_insns): Likewise.\n\t(expand_call_inline): Work on CFG.\n\t(push_cfun, pop_cfun): New functions.\n\t(cfun_stack): New stack.\n\t(add_lexical_block): New function.\n\t(gimple_expand_calls_inline): Work on basic block.\n\t(optimize_inline_calls): Likewise.\n\t(clone_body, save_body, unsave_ewpr_now): Update for new\n\tdatastructures.\n\t(declare_inline_vars): Work on block instead of bind_expr.\n\t(inlining_p): New predicate.\n\t* tree-inline.h (push_cfun, pop_cfun): Declare.\n\t* tree-optimize.c: Include except.h\n\t(all_lowering_passes): New variable.\n\t(execute_fixup_cfg, pass_fixup_cfg): New pass.\n\t(init_tree_optimization_passes): Move some to all_lowering_passes.\n\t(tree_lowering_passes): New function.\n\t(tree_rest_of_compilation): Register cfg hooks; save/unsave eh.\n\nCo-Authored-By: Dale Johannesen <dalej@apple.com>\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\nCo-Authored-By: Stuart Hastings <stuart@apple.com>\n\nFrom-SVN: r99840", "tree": {"sha": "7ea47e34b08476d032089225675e12ceab4eed76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ea47e34b08476d032089225675e12ceab4eed76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e21aff8abe2079837b599b4975c81b6dfe969a65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e21aff8abe2079837b599b4975c81b6dfe969a65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e21aff8abe2079837b599b4975c81b6dfe969a65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e21aff8abe2079837b599b4975c81b6dfe969a65/comments", "author": null, "committer": null, "parents": [{"sha": "8f2a14065c60b1ac45c9019de43b73664bc7657d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f2a14065c60b1ac45c9019de43b73664bc7657d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f2a14065c60b1ac45c9019de43b73664bc7657d"}], "stats": {"total": 1374, "additions": 958, "deletions": 416}, "files": [{"sha": "3217a8d0b90358349fcbda47e402957e04c9dca5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e21aff8abe2079837b599b4975c81b6dfe969a65", "patch": "@@ -1,3 +1,61 @@\n+2005-05-17  Steven Bosscher  <stevenb@suse.de>\n+\t    Stuart Hastings <stuart@apple.com>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\t    Dale Johannesen  <dalej@apple.com>\n+\n+\t* cgraph.h (cgraph_node): Add 'lowered' state.\n+\t(cgraph_lower_function): Declare.\n+\t* cgraphunit.c (cgraph_finalize_function): Initialize lowered flag.\n+\t(cgraph_lower_function): New function.\n+\t(cgraph_create_edges): Deal with lowered function bodies.\n+\t(verify_cgraph_node): Likewise.\n+\t(cgraph_analyze_function): Do lowering job.\n+\t(cgraph_build_static_cdtor): Likewise.\n+\t* function.h (struct function): Add saved_eh and saved_cfg.\n+\t* integrate.c (copy_decl_for_inlining): Kill LABEL_DECL_UID field.\n+\t* tree-cfg.c (fold_cond_expr_cond): Export.\n+\t* tree-flow.h (fold_cond_expr_cond): Declare.\n+\t* tree-inline.c: Include basic-block, ggc, tree-flow, except.h and\n+\tpointer-set.\n+\t(struct_inline_data): Kill fnd, first_inlined_fn, ret_label,\n+\tin_target_cleanup_p, tree_pruner, tsi; add callee, caller and\n+\tcallee_cfun, block, eh_region, eh_region_offset.\n+\t(inlining_p): New predicate.\n+\t(remap_decl): Update for new inline_data; declare newly created inline\n+\tvars in low gimple way.\n+\t(copy_body_r): Update for new datastructure, simplify some of handling\n+\twhen we are in gimple; remap LABEL_DECLs for EH; copy TREE_BLOCK;\n+\tdeal with RESX_EXPRs.\n+\t(copy_bb): New.\n+\t(copy_edges_for_bb): Likewise.\n+\t(remap_decl_1): New.\n+\t(copy_cfg_body): New.\n+\t(copy_generic_body): Rewrite to work on low gimple.\n+\t(copy_body): Turn into simple wrapper around copy_cfg_body.\n+\t(setup_one_parameter): Insert new statements into given basic block.\n+\t(initialize_initialized_parameters): Likewise, reorganize way things are\n+\tgimplified.\n+\t(declare_return_variable): Update for new inline data datastructure.\n+\t(inline_forbidden_p): Work on low gimple.\n+\t(estimate_num_insns): Likewise.\n+\t(expand_call_inline): Work on CFG.\n+\t(push_cfun, pop_cfun): New functions.\n+\t(cfun_stack): New stack.\n+\t(add_lexical_block): New function.\n+\t(gimple_expand_calls_inline): Work on basic block.\n+\t(optimize_inline_calls): Likewise.\n+\t(clone_body, save_body, unsave_ewpr_now): Update for new\n+\tdatastructures.\n+\t(declare_inline_vars): Work on block instead of bind_expr.\n+\t(inlining_p): New predicate.\n+\t* tree-inline.h (push_cfun, pop_cfun): Declare.\n+\t* tree-optimize.c: Include except.h\n+\t(all_lowering_passes): New variable.\n+\t(execute_fixup_cfg, pass_fixup_cfg): New pass.\n+\t(init_tree_optimization_passes): Move some to all_lowering_passes.\n+\t(tree_lowering_passes): New function.\n+\t(tree_rest_of_compilation): Register cfg hooks; save/unsave eh.\n+\n 2005-05-17  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* unwind-dw2-fde-darwin.c: Include tsystem.h."}, {"sha": "6f3864cfcad624f81ea5e06a59397da8fb7e0b05", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=e21aff8abe2079837b599b4975c81b6dfe969a65", "patch": "@@ -117,6 +117,8 @@ struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n   /* Set when function is reachable by call from other function\n      that is either reachable or needed.  */\n   bool reachable;\n+  /* Set once the function is lowered (ie it's CFG is built).  */\n+  bool lowered;\n   /* Set once the function has been instantiated and its callee\n      lists created.  */\n   bool analyzed;\n@@ -215,6 +217,7 @@ bool decide_is_variable_needed (struct cgraph_varpool_node *, tree);\n bool cgraph_assemble_pending_functions (void);\n bool cgraph_varpool_assemble_pending_decls (void);\n void cgraph_finalize_function (tree, bool);\n+void cgraph_lower_function (struct cgraph_node *);\n void cgraph_finalize_compilation_unit (void);\n void cgraph_create_edges (struct cgraph_node *, tree);\n void cgraph_optimize (void);"}, {"sha": "548a5fcb17737637926d06381fb8b1485d0c0e69", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 77, "deletions": 5, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e21aff8abe2079837b599b4975c81b6dfe969a65", "patch": "@@ -427,6 +427,7 @@ cgraph_finalize_function (tree decl, bool nested)\n   notice_global_symbol (decl);\n   node->decl = decl;\n   node->local.finalized = true;\n+  node->lowered = DECL_STRUCT_FUNCTION (decl)->cfg != NULL;\n   if (node->nested)\n     lower_nested_functions (decl);\n   gcc_assert (!node->nested);\n@@ -459,6 +460,16 @@ cgraph_finalize_function (tree decl, bool nested)\n     do_warn_unused_parameter (decl);\n }\n \n+void\n+cgraph_lower_function (struct cgraph_node *node)\n+{\n+  if (node->lowered)\n+    return;\n+  tree_lowering_passes (node->decl);\n+  node->lowered = true;\n+}\n+\n+\n /* Walk tree and record all calls.  Called via walk_tree.  */\n static tree\n record_call_1 (tree *tp, int *walk_subtrees, void *data)\n@@ -538,6 +549,43 @@ cgraph_create_edges (struct cgraph_node *node, tree body)\n   /* The nodes we're interested in are never shared, so walk\n      the tree ignoring duplicates.  */\n   visited_nodes = pointer_set_create ();\n+  if (TREE_CODE (body) == FUNCTION_DECL)\n+    {\n+      struct function *this_cfun = DECL_STRUCT_FUNCTION (body);\n+      basic_block this_block;\n+      block_stmt_iterator bsi;\n+      tree step;\n+\n+      /* Reach the trees by walking over the CFG, and note the \n+\t enclosing basic-blocks in the call edges.  */\n+      FOR_EACH_BB_FN (this_block, this_cfun)\n+        for (bsi = bsi_start (this_block); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t  walk_tree (bsi_stmt_ptr (bsi), record_call_1, node, visited_nodes);\n+\n+      /* Walk over any private statics that may take addresses of functions.  */\n+      if (TREE_CODE (DECL_INITIAL (body)) == BLOCK)\n+\t{\n+\t  for (step = BLOCK_VARS (DECL_INITIAL (body));\n+\t       step;\n+\t       step = TREE_CHAIN (step))\n+\t    if (DECL_INITIAL (step))\n+\t      walk_tree (&DECL_INITIAL (step), record_call_1, node, visited_nodes);\n+\t}\n+\n+      /* Also look here for private statics.  */\n+      if (DECL_STRUCT_FUNCTION (body))\n+\tfor (step = DECL_STRUCT_FUNCTION (body)->unexpanded_var_list;\n+\t     step;\n+\t     step = TREE_CHAIN (step))\n+\t  {\n+\t    tree decl = TREE_VALUE (step);\n+\t    if (DECL_INITIAL (decl) && TREE_STATIC (decl))\n+\t      walk_tree (&DECL_INITIAL (decl), record_call_1, node, visited_nodes);\n+\t  }\n+    }\n+  else\n+    walk_tree (&body, record_call_1, node, visited_nodes);\n+    \n   walk_tree (&body, record_call_1, node, visited_nodes);\n   pointer_set_destroy (visited_nodes);\n   visited_nodes = NULL;\n@@ -596,6 +644,9 @@ verify_cgraph_node (struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n   struct cgraph_node *main_clone;\n+  struct function *this_cfun = DECL_STRUCT_FUNCTION (node->decl);\n+  basic_block this_block;\n+  block_stmt_iterator bsi;\n \n   timevar_push (TV_CGRAPH_VERIFY);\n   error_found = false;\n@@ -655,8 +706,23 @@ verify_cgraph_node (struct cgraph_node *node)\n       && DECL_SAVED_TREE (node->decl) && !TREE_ASM_WRITTEN (node->decl)\n       && (!DECL_EXTERNAL (node->decl) || node->global.inlined_to))\n     {\n-      walk_tree_without_duplicates (&DECL_SAVED_TREE (node->decl),\n-\t\t\t\t    verify_cgraph_node_1, node);\n+      if (this_cfun->cfg)\n+\t{\n+\t  /* The nodes we're interested in are never shared, so walk\n+\t     the tree ignoring duplicates.  */\n+\t  visited_nodes = pointer_set_create ();\n+\t  /* Reach the trees by walking over the CFG, and note the\n+\t     enclosing basic-blocks in the call edges.  */\n+\t  FOR_EACH_BB_FN (this_block, this_cfun)\n+\t    for (bsi = bsi_start (this_block); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t      walk_tree (bsi_stmt_ptr (bsi), verify_cgraph_node_1, node, visited_nodes);\n+\t  pointer_set_destroy (visited_nodes);\n+\t  visited_nodes = NULL;\n+\t}\n+      else\n+\t/* No CFG available?!  */\n+\tgcc_unreachable ();\n+\n       for (e = node->callees; e; e = e->next_callee)\n \t{\n \t  if (!e->aux)\n@@ -729,12 +795,14 @@ cgraph_analyze_function (struct cgraph_node *node)\n   struct cgraph_edge *e;\n \n   current_function_decl = decl;\n+  push_cfun (DECL_STRUCT_FUNCTION (decl));\n+  cgraph_lower_function (node);\n \n   /* First kill forward declaration so reverse inlining works properly.  */\n-  cgraph_create_edges (node, DECL_SAVED_TREE (decl));\n+  cgraph_create_edges (node, decl);\n \n   node->local.inlinable = tree_inlinable_function_p (decl);\n-  node->local.self_insns = estimate_num_insns (DECL_SAVED_TREE (decl));\n+  node->local.self_insns = estimate_num_insns (decl);\n   if (node->local.inlinable)\n     node->local.disregard_inline_limits\n       = lang_hooks.tree_inlining.disregard_inline_limits (decl);\n@@ -754,6 +822,7 @@ cgraph_analyze_function (struct cgraph_node *node)\n   node->global.insns = node->local.self_insns;\n \n   node->analyzed = true;\n+  pop_cfun ();\n   current_function_decl = NULL;\n }\n \n@@ -1178,7 +1247,10 @@ cgraph_build_static_cdtor (char which, tree body, int priority)\n \n   /* ??? We will get called LATE in the compilation process.  */\n   if (cgraph_global_info_ready)\n-    tree_rest_of_compilation (decl);\n+    {\n+      tree_lowering_passes (decl);\n+      tree_rest_of_compilation (decl);\n+    }\n   else\n     cgraph_finalize_function (decl, 0);\n   "}, {"sha": "9470cd5997db3b166966ffa1dc40af362a167a39", "filename": "gcc/cp/method.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e21aff8abe2079837b599b4975c81b6dfe969a65", "patch": "@@ -36,6 +36,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n+#include \"tree-pass.h\"\n \n /* Various flags to control the mangling process.  */\n \n@@ -504,7 +505,9 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n       /* Re-enable access control.  */\n       pop_deferring_access_checks ();\n \n-      expand_body (finish_function (0));\n+      thunk_fndecl = finish_function (0);\n+      tree_lowering_passes (thunk_fndecl);\n+      expand_body (thunk_fndecl);\n     }\n \n   pop_from_top_level ();"}, {"sha": "da435b17c220d972bb9069eabe1e117de09eb928", "filename": "gcc/function.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=e21aff8abe2079837b599b4975c81b6dfe969a65", "patch": "@@ -162,19 +162,20 @@ struct expr_status GTY(())\n struct function GTY(())\n {\n   struct eh_status *eh;\n+  struct eh_status *saved_eh;\n   struct expr_status *expr;\n   struct emit_status *emit;\n   struct varasm_status *varasm;\n \n   /* The control flow graph for this function.  */\n   struct control_flow_graph *cfg;\n+  struct control_flow_graph *saved_cfg;\n   bool after_inlining;\n \n   /* For tree-optimize.c.  */\n \n   /* Saved tree and arguments during tree optimization.  Used later for\n      inlining */\n-  tree saved_tree;\n   tree saved_args;\n   tree saved_static_chain_decl;\n "}, {"sha": "0f5cfcf1544d28a86ea33761591a1696f76ffb85", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=e21aff8abe2079837b599b4975c81b6dfe969a65", "patch": "@@ -121,6 +121,7 @@ copy_decl_for_inlining (tree decl, tree from_fn, tree to_fn)\n       if (TREE_CODE (copy) == LABEL_DECL)\n \t{\n \t  TREE_ADDRESSABLE (copy) = 0;\n+          LABEL_DECL_UID (copy) = -1;\n \t}\n     }\n "}, {"sha": "b4b509bfc7e6ebf3eac17c5905bccfb64f052244", "filename": "gcc/testsuite/gcc.dg/20040206-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Ftestsuite%2Fgcc.dg%2F20040206-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Ftestsuite%2Fgcc.dg%2F20040206-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20040206-1.c?ref=e21aff8abe2079837b599b4975c81b6dfe969a65", "patch": "@@ -7,5 +7,5 @@\n     The warning about \"no return statement in function\n     returning non-void\" is PR 13000. */\n \n-static int foo (int a __attribute__((unused)) ) { }\n-int main (void) { return foo (0); } /* { dg-warning \"control may reach end\" } */\n+static int foo (int a __attribute__((unused)) ) { } /* { dg-warning \"control reaches end of non-void\" } */\n+int main (void) { return foo (0); }"}, {"sha": "be7e0f53dbb461670d40b4add16750348e4ff28f", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=e21aff8abe2079837b599b4975c81b6dfe969a65", "patch": "@@ -446,7 +446,7 @@ create_bb (void *h, void *e, basic_block after)\n \n /* Fold COND_EXPR_COND of each COND_EXPR.  */\n \n-static void\n+void\n fold_cond_expr_cond (void)\n {\n   basic_block bb;"}, {"sha": "1bf9d87db16b0ffe829f31b0c209066227d04677", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=e21aff8abe2079837b599b4975c81b6dfe969a65", "patch": "@@ -542,6 +542,7 @@ extern tree gimplify_build2 (block_stmt_iterator *, enum tree_code,\n extern tree gimplify_build3 (block_stmt_iterator *, enum tree_code,\n \t\t\t     tree, tree, tree, tree);\n extern void init_empty_tree_cfg (void);\n+extern void fold_cond_expr_cond (void);\n \n /* In tree-pretty-print.c.  */\n extern void dump_generic_bb (FILE *, basic_block, int, int);"}, {"sha": "950c3859f2cb252ab9608f5ab9a02c27722629c1", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 719, "deletions": 395, "changes": 1114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=e21aff8abe2079837b599b4975c81b6dfe969a65", "patch": "@@ -32,24 +32,58 @@ Boston, MA 02111-1307, USA.  */\n #include \"params.h\"\n #include \"input.h\"\n #include \"insn-config.h\"\n-#include \"integrate.h\"\n #include \"varray.h\"\n #include \"hashtab.h\"\n #include \"splay-tree.h\"\n #include \"langhooks.h\"\n+#include \"basic-block.h\"\n+#include \"tree-iterator.h\"\n #include \"cgraph.h\"\n #include \"intl.h\"\n #include \"tree-mudflap.h\"\n #include \"tree-flow.h\"\n #include \"function.h\"\n+#include \"ggc.h\"\n+#include \"tree-flow.h\"\n #include \"diagnostic.h\"\n+#include \"except.h\"\n #include \"debug.h\"\n+#include \"pointer-set.h\"\n+#include \"integrate.h\"\n \n /* I'm not real happy about this, but we need to handle gimple and\n    non-gimple trees.  */\n-#include \"tree-iterator.h\"\n #include \"tree-gimple.h\"\n \n+/* Inlining, Saving, Cloning\n+\n+   Inlining: a function body is duplicated, but the PARM_DECLs are\n+   remapped into VAR_DECLs, and non-void RETURN_EXPRs become\n+   MODIFY_EXPRs that store to a dedicated returned-value variable.\n+   The duplicated eh_region info of the copy will later be appended\n+   to the info for the caller; the eh_region info in copied throwing\n+   statements and RESX_EXPRs is adjusted accordingly.\n+\n+   Saving: make a semantically-identical copy of the function body.\n+   Necessary when we want to generate code for the body (a destructive\n+   operation), but we expect to need this body in the future (e.g. for\n+   inlining into another function).\n+\n+   Cloning: (only in C++) We have one body for a con/de/structor, and\n+   multiple function decls, each with a unique parameter list.\n+   Duplicate the body, using the given splay tree; some parameters\n+   will become constants (like 0 or 1).\n+\n+   All of these will simultaneously lookup any callgraph edges.  If\n+   we're going to inline the duplicated function body, and the given\n+   function has some cloned callgraph nodes (one for each place this\n+   function will be inlined) those callgraph edges will be duplicated.\n+   If we're saving or cloning the body, those callgraph edges will be\n+   updated to point into the new body.  (Note that the original\n+   callgraph node and edge list will not be altered.)\n+\n+   See the CALL_EXPR handling case in copy_body_r ().  */\n+\n /* 0 if we should not perform inlining.\n    1 if we should expand functions calls inline at the tree level.\n    2 if we should consider *all* functions to be inline\n@@ -73,68 +107,59 @@ int flag_inline_trees = 0;\n \n typedef struct inline_data\n {\n-  /* A stack of the functions we are inlining.  For example, if we are\n-     compiling `f', which calls `g', which calls `h', and we are\n-     inlining the body of `h', the stack will contain, `h', followed\n-     by `g', followed by `f'.  The first few elements of the stack may\n-     contain other functions that we know we should not recurse into,\n-     even though they are not directly being inlined.  */\n-  varray_type fns;\n-  /* The index of the first element of FNS that really represents an\n-     inlined function.  */\n-  unsigned first_inlined_fn;\n-  /* The label to jump to when a return statement is encountered.  If\n-     this value is NULL, then return statements will simply be\n-     remapped as return statements, rather than as jumps.  */\n-  tree ret_label;\n+  /* FUNCTION_DECL for function being inlined.  */\n+  tree callee;\n+  /* FUNCTION_DECL for function being inlined into.  */\n+  tree caller;\n+  /* struct function for function being inlined.  Usually this is the same\n+     as DECL_STRUCT_FUNCTION (callee), but can be different if saved_cfg\n+     and saved_eh are in use.  */\n+  struct function *callee_cfun;\n   /* The VAR_DECL for the return value.  */\n   tree retvar;\n   /* The map from local declarations in the inlined function to\n      equivalents in the function into which it is being inlined.  */\n   splay_tree decl_map;\n-  /* Nonzero if we are currently within the cleanup for a\n-     TARGET_EXPR.  */\n-  int in_target_cleanup_p;\n   /* We use the same mechanism to build clones that we do to perform\n      inlining.  However, there are a few places where we need to\n      distinguish between those two situations.  This flag is true if\n      we are cloning, rather than inlining.  */\n   bool cloning_p;\n   /* Similarly for saving function body.  */\n   bool saving_p;\n-  /* Hash table used to prevent walk_tree from visiting the same node\n-     umpteen million times.  */\n-  htab_t tree_pruner;\n   /* Callgraph node of function we are inlining into.  */\n   struct cgraph_node *node;\n   /* Callgraph node of currently inlined function.  */\n   struct cgraph_node *current_node;\n-  /* Statement iterator.  We need this so we can keep the tree in\n-     gimple form when we insert the inlined function.   It is not\n-     used when we are not dealing with gimple trees.  */\n-  tree_stmt_iterator tsi;\n+  /* Current BLOCK.  */\n+  tree block;\n+  /* Exception region the inlined call lie in.  */\n+  int eh_region;\n+  /* Take region number in the function being copied, add this value and\n+     get eh region number of the duplicate in the function we inline into.  */\n+  int eh_region_offset;\n } inline_data;\n \n /* Prototypes.  */\n \n+static tree declare_return_variable (inline_data *, tree, tree, tree *);\n static tree copy_body_r (tree *, int *, void *);\n-static tree copy_body (inline_data *);\n-static tree expand_call_inline (tree *, int *, void *);\n-static void expand_calls_inline (tree *, inline_data *);\n+static tree copy_generic_body (inline_data *);\n static bool inlinable_function_p (tree);\n static tree remap_decl (tree, inline_data *);\n static tree remap_type (tree, inline_data *);\n-static tree initialize_inlined_parameters (inline_data *, tree,\n-\t\t\t\t\t   tree, tree, tree);\n static void remap_block (tree *, inline_data *);\n+static tree remap_decl (tree, inline_data *);\n static tree remap_decls (tree, inline_data *);\n static void copy_bind_expr (tree *, int *, inline_data *);\n static tree mark_local_for_remap_r (tree *, int *, void *);\n static void unsave_expr_1 (tree);\n static tree unsave_r (tree *, int *, void *);\n-static void declare_inline_vars (tree bind_expr, tree vars);\n+static void declare_inline_vars (tree, tree);\n static void remap_save_expr (tree *, void *, int *);\n \n+static inline bool inlining_p (inline_data *id);\n+\n /* Insert a tree->tree mapping for ID.  Despite the name suggests\n    that the trees should be variables, it is used for more than that.  */\n \n@@ -151,21 +176,28 @@ insert_decl_map (inline_data *id, tree key, tree value)\n \t\t       (splay_tree_value) value);\n }\n \n-/* Remap DECL during the copying of the BLOCK tree for the function.\n-   We are only called to remap local variables in the current function.  */\n+/* Remap DECL during the copying of the BLOCK tree for the function.  */\n \n static tree\n remap_decl (tree decl, inline_data *id)\n {\n-  splay_tree_node n = splay_tree_lookup (id->decl_map, (splay_tree_key) decl);\n-  tree fn = VARRAY_TOP_TREE (id->fns);\n+  splay_tree_node n;\n+  tree fn;\n+\n+  /* We only remap local variables in the current function.  */\n+  fn = id->callee;\n \n-  /* See if we have remapped this declaration.  If we didn't already have an\n-     equivalent for this declaration, create one now.  */\n+  /* See if we have remapped this declaration.  */\n+\n+  n = splay_tree_lookup (id->decl_map, (splay_tree_key) decl);\n+\n+  /* If we didn't already have an equivalent for this declaration,\n+     create one now.  */\n   if (!n)\n     {\n       /* Make a copy of the variable or label.  */\n-      tree t = copy_decl_for_inlining (decl, fn, VARRAY_TREE (id->fns, 0));\n+      tree t;\n+      t = copy_decl_for_inlining (decl, fn, id->caller);\n \n       /* Remember it, so that if we encounter this local entity again\n \t we can reuse this copy.  Do this early because remap_type may\n@@ -214,6 +246,16 @@ remap_decl (tree decl, inline_data *id)\n \t}\n #endif\n \n+      /* If we are inlining and this is a variable (not a label), declare the\n+\t remapped variable in the callers' body.  */\n+      if (inlining_p (id)\n+\t  && (TREE_CODE (t) == VAR_DECL\n+\t      || TREE_CODE (t) == PARM_DECL))\n+\tdeclare_inline_vars (id->block, t);\n+\n+      /* Remember it, so that if we encounter this local entity\n+\t again we can reuse this copy.  */\n+      insert_decl_map (id, decl, t);\n       return t;\n     }\n \n@@ -234,9 +276,8 @@ remap_type (tree type, inline_data *id)\n   if (node)\n     return (tree) node->value;\n \n-  /* The type only needs remapping if it's variably modified by a variable\n-     in the function we are inlining.  */\n-  if (! variably_modified_type_p (type, VARRAY_TOP_TREE (id->fns)))\n+  /* The type only needs remapping if it's variably modified.  */\n+  if (! variably_modified_type_p (type, id->callee))\n     {\n       insert_decl_map (id, type, type);\n       return type;\n@@ -383,7 +424,7 @@ remap_block (tree *block, inline_data *id)\n   /* Remap its variables.  */\n   BLOCK_VARS (new_block) = remap_decls (BLOCK_VARS (old_block), id);\n \n-  fn = VARRAY_TREE (id->fns, 0);\n+  fn = id->caller;\n #if 1\n   /* FIXME!  It shouldn't be so hard to manage blocks.  Rebuilding them in\n      rest_of_compilation is a good start.  */\n@@ -443,51 +484,45 @@ copy_bind_expr (tree *tp, int *walk_subtrees, inline_data *id)\n     BIND_EXPR_VARS (*tp) = remap_decls (BIND_EXPR_VARS (*tp), id);\n }\n \n-/* Called from copy_body via walk_tree.  DATA is really an `inline_data *'.  */\n+/* Called from copy_body_id via walk_tree.  DATA is really an\n+   `inline_data *'.  */\n \n static tree\n copy_body_r (tree *tp, int *walk_subtrees, void *data)\n {\n   inline_data *id = (inline_data *) data;\n-  tree fn = VARRAY_TOP_TREE (id->fns);\n+  tree fn = id->callee;\n \n-#if 0\n-  /* All automatic variables should have a DECL_CONTEXT indicating\n-     what function they come from.  */\n-  if ((TREE_CODE (*tp) == VAR_DECL || TREE_CODE (*tp) == LABEL_DECL)\n-      && DECL_NAMESPACE_SCOPE_P (*tp))\n-    gcc_assert (DECL_EXTERNAL (*tp) || TREE_STATIC (*tp));\n-#endif\n+  /* Begin by recognizing trees that we'll completely rewrite for the\n+     inlining context.  Our output for these trees is completely\n+     different from out input (e.g. RETURN_EXPR is deleted, and morphs\n+     into an edge).  Further down, we'll handle trees that get\n+     duplicated and/or tweaked.  */\n \n-  /* If this is a RETURN_EXPR, change it into a MODIFY_EXPR and a\n-     GOTO_EXPR with the RET_LABEL as its target.  */\n-  if (TREE_CODE (*tp) == RETURN_EXPR && id->ret_label)\n+  /* If this is a RETURN_STMT, change it into an EXPR_STMT and a\n+     GOTO_STMT with the RET_LABEL as its target.  */\n+  if (TREE_CODE (*tp) == RETURN_EXPR && inlining_p (id))\n     {\n-      tree return_stmt = *tp;\n-      tree goto_stmt;\n-\n-      /* Build the GOTO_EXPR.  */\n-      tree assignment = TREE_OPERAND (return_stmt, 0);\n-      goto_stmt = build1 (GOTO_EXPR, void_type_node, id->ret_label);\n-      TREE_USED (id->ret_label) = 1;\n+      tree assignment = TREE_OPERAND (*tp, 0);\n \n       /* If we're returning something, just turn that into an\n-\t assignment into the equivalent of the original\n-\t RESULT_DECL.  */\n-      if (assignment)\n-        {\n-\t  /* Do not create a statement containing a naked RESULT_DECL.  */\n-\t  if (TREE_CODE (assignment) == RESULT_DECL)\n-\t    gimplify_stmt (&assignment);\n-\n-\t  *tp = build (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n-\t  append_to_statement_list (assignment, &BIND_EXPR_BODY (*tp));\n-\t  append_to_statement_list (goto_stmt, &BIND_EXPR_BODY (*tp));\n-        }\n-      /* If we're not returning anything just do the jump.  */\n-      else\n-\t*tp = goto_stmt;\n+\t assignment into the equivalent of the original RESULT_DECL.\n+\t If the \"assignment\" is just the result decl, the result\n+\t decl has already been set (e.g. a recent \"foo (&result_decl,\n+\t ...)\"); just toss the entire RETURN_EXPR.  */\n+      if (assignment && TREE_CODE (assignment) == MODIFY_EXPR)\n+\t{\n+\t  /* Replace the RETURN_EXPR with (a copy of) the\n+\t     MODIFY_EXPR hangning underneath.  */\n+\t  *tp = copy_node (assignment);\n+\t}\n+      else /* Else the RETURN_EXPR returns no value.  */\n+\t{\n+\t  *tp = NULL;\n+\t  return (void *)1;\n+\t}\n     }\n+\n   /* Local variables and labels need to be replaced by equivalent\n      variables.  We don't want to copy static variables; there's only\n      one of those, no matter how many times we inline the containing\n@@ -508,6 +543,9 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n     copy_statement_list (tp);\n   else if (TREE_CODE (*tp) == SAVE_EXPR)\n     remap_save_expr (tp, id->decl_map, walk_subtrees);\n+  else if (TREE_CODE (*tp) == LABEL_DECL)\n+    /* These may need to be remapped for EH handling.  */\n+    remap_decl (*tp, id);\n   else if (TREE_CODE (*tp) == BIND_EXPR)\n     copy_bind_expr (tp, walk_subtrees, id);\n   /* Types may need remapping as well.  */\n@@ -539,6 +577,9 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n     {\n       tree old_node = *tp;\n \n+      /* Here we handle trees that are not completely rewritten.\n+\t First we detect some inlining-induced bogosities for\n+\t discarding.  */\n       if (TREE_CODE (*tp) == MODIFY_EXPR\n \t  && TREE_OPERAND (*tp, 0) == TREE_OPERAND (*tp, 1)\n \t  && (lang_hooks.tree_inlining.auto_var_in_fn_p\n@@ -578,16 +619,29 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t    }\n \t}\n \n+      /* Here is the \"usual case\".  Copy this tree node, and then\n+\t tweak some special cases.  */\n       copy_tree_r (tp, walk_subtrees, NULL);\n+      if (id->block\n+\t  && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (*tp))))\n+\tTREE_BLOCK (*tp) = id->block;\n \n+      /* We're duplicationg a CALL_EXPR.  Find any corresponding\n+\t callgraph edges and update or duplicate them.  */\n       if (TREE_CODE (*tp) == CALL_EXPR && id->node && get_callee_fndecl (*tp))\n \t{\n \t  if (id->saving_p)\n \t    {\n \t      struct cgraph_node *node;\n               struct cgraph_edge *edge;\n \n-\t      for (node = id->node->next_clone; node; node = node->next_clone)\n+\t      /* We're saving a copy of the body, so we'll update the\n+\t\t callgraph nodes in place.  Note that we avoid\n+\t\t altering the original callgraph node; we begin with\n+\t\t the first clone.  */\n+\t      for (node = id->node->next_clone;\n+\t\t   node;\n+\t\t   node = node->next_clone)\n \t\t{\n \t\t  edge = cgraph_edge (node, old_node);\n \t\t  gcc_assert (edge);\n@@ -596,13 +650,20 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t    }\n \t  else\n \t    {\n-              struct cgraph_edge *edge\n-\t\t= cgraph_edge (id->current_node, old_node);\n+              struct cgraph_edge *edge;\n \n+\t      /* We're cloning or inlining this body; duplicate the\n+\t\t associate callgraph nodes.  */\n+\t      edge = cgraph_edge (id->current_node, old_node);\n \t      if (edge)\n-\t        cgraph_clone_edge (edge, id->node, *tp);\n+\t\t cgraph_clone_edge (edge, id->node, *tp);\n \t    }\n \t}\n+      else if (TREE_CODE (*tp) == RESX_EXPR && id->eh_region_offset)\n+\tTREE_OPERAND (*tp, 0) =\n+\t  build_int_cst\n+\t    (NULL_TREE,\n+\t     id->eh_region_offset + TREE_INT_CST_LOW (TREE_OPERAND (*tp, 0)));\n \n       TREE_TYPE (*tp) = remap_type (TREE_TYPE (*tp), id);\n \n@@ -629,25 +690,292 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n   return NULL_TREE;\n }\n \n+/* Copy basic block, scale profile accordingly.  Edges will be taken care of\n+   later  */\n+\n+static basic_block\n+copy_bb (inline_data *id, basic_block bb, int frequency_scale, int count_scale)\n+{\n+  block_stmt_iterator bsi, copy_bsi;\n+  basic_block copy_basic_block;\n+\n+  /* create_basic_block() will append every new block to\n+     basic_block_info automatically.  */\n+  copy_basic_block = create_basic_block (NULL, (void *) 0, bb->prev_bb->aux);\n+  copy_basic_block->count = bb->count * count_scale / REG_BR_PROB_BASE;\n+  copy_basic_block->frequency = (bb->frequency\n+\t\t\t\t     * frequency_scale / REG_BR_PROB_BASE);\n+  copy_bsi = bsi_start (copy_basic_block);\n+\n+  for (bsi = bsi_start (bb);\n+       !bsi_end_p (bsi); bsi_next (&bsi))\n+    {\n+      tree stmt = bsi_stmt (bsi);\n+      tree orig_stmt = stmt;\n+\n+      walk_tree (&stmt, copy_body_r, id, NULL);\n+\n+      /* RETURN_EXPR might be removed,\n+         this is signalled by making stmt pointer NULL.  */\n+      if (stmt)\n+\t{\n+          bsi_insert_after (&copy_bsi, stmt, BSI_NEW_STMT);\n+\t  /* If you think we can abort here, you are wrong.\n+\t     There is no region 0 in tree land.  */\n+\t  gcc_assert (lookup_stmt_eh_region_fn (id->callee_cfun, orig_stmt)\n+\t\t      != 0);\n+\n+\t  if (tree_could_throw_p (stmt))\n+\t    {\n+\t      int region = lookup_stmt_eh_region_fn (id->callee_cfun, orig_stmt);\n+\t      /* Add an entry for the copied tree in the EH hashtable.\n+\t\t When saving or cloning or versioning, use the hashtable in\n+\t\t cfun, and just copy the EH number.  When inlining, use the\n+\t\t hashtable in the caller, and adjust the region number.  */\n+\t      if (region > 0)\n+\t\tadd_stmt_to_eh_region (stmt, region + id->eh_region_offset);\n+\n+\t      /* If this tree doesn't have a region associated with it,\n+\t\t and there is a \"current region,\"\n+\t\t then associate this tree with the current region\n+\t\t and add edges associated with this region.  */\n+\t      if ((lookup_stmt_eh_region_fn (id->callee_cfun,\n+\t\t\t\t\t     orig_stmt) <= 0\n+\t\t   && id->eh_region > 0)\n+\t\t  && tree_could_throw_p (stmt))\n+\t\tadd_stmt_to_eh_region (stmt, id->eh_region);\n+\t    }\n+\t}\n+    }\n+  return copy_basic_block;\n+}\n+\n+/* Copy edges from BB into it's copy constructed ealier, scale profile\n+   accordingly.  Edges will be taken care of\n+   later.  Assume aux pointers to point to the copies of each BB  */\n+static void\n+copy_edges_for_bb (basic_block bb, int count_scale)\n+{\n+  basic_block new_bb = bb->aux;\n+  edge_iterator ei;\n+  edge old_edge;\n+  block_stmt_iterator bsi;\n+  int flags;\n+\n+  /* Use the indices from the original blocks to create edges for the\n+     new ones.  */\n+  FOR_EACH_EDGE (old_edge, ei, bb->succs)\n+    {\n+      edge new;\n+\n+      flags = old_edge->flags;\n+\n+      /* Return edges do get a FALLTHU flag when the get inlined.  */\n+      if (old_edge->dest->index == EXIT_BLOCK && !old_edge->flags\n+\t  && old_edge->dest->aux != EXIT_BLOCK_PTR)\n+\tflags |= EDGE_FALLTHRU;\n+      new = make_edge (new_bb, old_edge->dest->aux, flags);\n+      new->count = old_edge->count * count_scale / REG_BR_PROB_BASE;\n+      new->probability = old_edge->probability;\n+    }\n+\n+  if (bb->index == ENTRY_BLOCK || bb->index == EXIT_BLOCK)\n+    return;\n+\n+  tree_purge_dead_eh_edges (new_bb);\n+  for (bsi = bsi_start (new_bb); !bsi_end_p (bsi);)\n+    {\n+      tree copy_stmt;\n+\n+      copy_stmt = bsi_stmt (bsi);\n+      update_stmt (copy_stmt);\n+      /* Do this before the possible split_block.  */\n+      bsi_next (&bsi);\n+\n+      /* If this tree could throw an exception, there are two\n+         cases where we need to add abnormal edge(s): the\n+         tree wasn't in a region and there is a \"current\n+         region\" in the caller; or the original tree had\n+         EH edges.  In both cases split the block after the tree,\n+         and add abnormal edge(s) as needed; we need both\n+         those from the callee and the caller.\n+         We check whether the copy can throw, because the const\n+         propagation can change an INDIRECT_REF which throws\n+         into a COMPONENT_REF which doesn't.  If the copy\n+         can throw, the original could also throw.  */\n+\n+      if (TREE_CODE (copy_stmt) == RESX_EXPR\n+\t  || (tree_could_throw_p (copy_stmt)\n+\t      && lookup_stmt_eh_region (copy_stmt) > 0))\n+\t{\n+\t  if (!bsi_end_p (bsi))\n+\t    /* Note that bb's predecessor edges aren't necessarily\n+\t       right at this point; split_block doesn't care.  */\n+\t    {\n+\t      edge e = split_block (new_bb, copy_stmt);\n+\t      new_bb = e->dest;\n+\t      bsi = bsi_start (new_bb);\n+\t    }\n+\n+           make_eh_edges (copy_stmt);\n+\t}\n+    }\n+}\n+\n+/* Wrapper for remap_decl so it can be used as a callback.  */\n+static tree\n+remap_decl_1 (tree decl, void *data)\n+{\n+  return remap_decl (decl, data);\n+}\n+\n+/* Make a copy of the body of FN so that it can be inserted inline in\n+   another function.  Walks FN via CFG, returns new fndecl.  */\n+\n+static tree\n+copy_cfg_body (inline_data * id, gcov_type count, int frequency,\n+\t       basic_block entry_block_map, basic_block exit_block_map)\n+{\n+  tree callee_fndecl = id->callee;\n+  /* Original cfun for the callee, doesn't change.  */\n+  struct function *callee_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);\n+  /* Copy, built by this function.  */\n+  struct function *new_cfun;\n+  /* Place to copy from; when a copy of the function was saved off earlier,\n+     use that instead of the main copy.  */\n+  struct function *cfun_to_copy =\n+    (struct function *) ggc_alloc_cleared (sizeof (struct function));\n+  basic_block bb;\n+  tree new_fndecl = NULL;\n+  bool saving_or_cloning;\n+  int count_scale, frequency_scale;\n+\n+  if (ENTRY_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->count)\n+    count_scale = (REG_BR_PROB_BASE * count\n+\t\t   / ENTRY_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->count);\n+  else\n+    count_scale = 1;\n+\n+  if (ENTRY_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->frequency)\n+    frequency_scale = (REG_BR_PROB_BASE * frequency\n+\t\t       /\n+\t\t       ENTRY_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->frequency);\n+  else\n+    frequency_scale = count_scale;\n+\n+  /* Register specific tree functions.  */\n+  tree_register_cfg_hooks ();\n+\n+  /* Must have a CFG here at this point.  */\n+  gcc_assert (ENTRY_BLOCK_PTR_FOR_FUNCTION\n+\t      (DECL_STRUCT_FUNCTION (callee_fndecl)));\n+\n+  *cfun_to_copy = *DECL_STRUCT_FUNCTION (callee_fndecl);\n+\n+  /* If there is a saved_cfg+saved_args lurking in the\n+     struct function, a copy of the callee body was saved there, and\n+     the 'struct cgraph edge' nodes have been fudged to point into the\n+     saved body.  Accordingly, we want to copy that saved body so the\n+     callgraph edges will be recognized and cloned properly.  */\n+  if (cfun_to_copy->saved_cfg)\n+    {\n+      cfun_to_copy->cfg = cfun_to_copy->saved_cfg;\n+      cfun_to_copy->eh = cfun_to_copy->saved_eh;\n+    }\n+  id->callee_cfun = cfun_to_copy;\n+\n+  /* If saving or cloning a function body, create new basic_block_info\n+     and label_to_block_maps.  Otherwise, we're duplicaing a function\n+     body for inlining; insert our new blocks and labels into the\n+     existing varrays.  */\n+  saving_or_cloning = (id->saving_p || id->cloning_p);\n+  if (saving_or_cloning)\n+    {\n+      new_cfun =\n+\t(struct function *) ggc_alloc_cleared (sizeof (struct function));\n+      *new_cfun = *DECL_STRUCT_FUNCTION (callee_fndecl);\n+      new_cfun->cfg = NULL;\n+      new_cfun->decl = new_fndecl = copy_node (callee_fndecl);\n+      new_cfun->ib_boundaries_block = (varray_type) 0;\n+      DECL_STRUCT_FUNCTION (new_fndecl) = new_cfun;\n+      push_cfun (new_cfun);\n+      init_empty_tree_cfg ();\n+\n+      ENTRY_BLOCK_PTR->count =\n+\t(ENTRY_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->count * count_scale /\n+\t REG_BR_PROB_BASE);\n+      ENTRY_BLOCK_PTR->frequency =\n+\t(ENTRY_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->frequency *\n+\t frequency_scale / REG_BR_PROB_BASE);\n+      EXIT_BLOCK_PTR->count =\n+\t(EXIT_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->count * count_scale /\n+\t REG_BR_PROB_BASE);\n+      EXIT_BLOCK_PTR->frequency =\n+\t(EXIT_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->frequency *\n+\t frequency_scale / REG_BR_PROB_BASE);\n+\n+      entry_block_map = ENTRY_BLOCK_PTR;\n+      exit_block_map = EXIT_BLOCK_PTR;\n+    }\n+\n+  ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun_to_copy)->aux = entry_block_map;\n+  EXIT_BLOCK_PTR_FOR_FUNCTION (cfun_to_copy)->aux = exit_block_map;\n+\n+\n+  /* Duplicate any exception-handling regions.  */\n+  if (cfun->eh)\n+    {\n+      if (saving_or_cloning)\n+        init_eh_for_function ();\n+      id->eh_region_offset = duplicate_eh_regions (cfun_to_copy,\n+\t\t     \t\t\t\t   remap_decl_1,\n+\t\t\t\t\t\t   id, id->eh_region);\n+      gcc_assert (inlining_p (id) || !id->eh_region_offset);\n+    }\n+  /* Use aux pointers to map the original blocks to copy.  */\n+  FOR_EACH_BB_FN (bb, cfun_to_copy)\n+    bb->aux = copy_bb (id, bb, frequency_scale, count_scale);\n+  /* Now that we've duplicated the blocks, duplicate their edges.  */\n+  FOR_ALL_BB_FN (bb, cfun_to_copy)\n+    copy_edges_for_bb (bb, count_scale);\n+  FOR_ALL_BB_FN (bb, cfun_to_copy)\n+    bb->aux = NULL;\n+\n+  if (saving_or_cloning)\n+    pop_cfun ();\n+\n+  return new_fndecl;\n+}\n+\n /* Make a copy of the body of FN so that it can be inserted inline in\n    another function.  */\n \n static tree\n-copy_body (inline_data *id)\n+copy_generic_body (inline_data *id)\n {\n   tree body;\n-  tree fndecl = VARRAY_TOP_TREE (id->fns);\n+  tree fndecl = id->callee;\n \n-  if (fndecl == current_function_decl\n-      && cfun->saved_tree)\n-    body = cfun->saved_tree;\n-  else\n-    body = DECL_SAVED_TREE (fndecl);\n+  body = DECL_SAVED_TREE (fndecl);\n   walk_tree (&body, copy_body_r, id, NULL);\n \n   return body;\n }\n \n+static tree\n+copy_body (inline_data *id, gcov_type count, int frequency,\n+\t   basic_block entry_block_map, basic_block exit_block_map)\n+{\n+  tree fndecl = id->callee;\n+  tree body;\n+\n+  /* If this body has a CFG, walk CFG and copy.  */\n+  gcc_assert (ENTRY_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (fndecl)));\n+  body = copy_cfg_body (id, count, frequency, entry_block_map, exit_block_map);\n+\n+  return body;\n+}\n+\n /* Return true if VALUE is an ADDR_EXPR of an automatic variable\n    defined in function FN, or of a data member thereof.  */\n \n@@ -660,16 +988,17 @@ self_inlining_addr_expr (tree value, tree fn)\n     return false;\n \n   var = get_base_address (TREE_OPERAND (value, 0));\n-\t      \n+\n   return var && lang_hooks.tree_inlining.auto_var_in_fn_p (var, fn);\n }\n \n static void\n setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n-\t\t     tree *init_stmts, tree *vars, bool *gimplify_init_stmts_p)\n+\t\t     basic_block bb, tree *vars)\n {\n   tree init_stmt;\n   tree var;\n+  tree var_sub;\n \n   /* If the parameter is never assigned to, we may not need to\n      create a new variable here at all.  Instead, we may be able\n@@ -678,11 +1007,6 @@ setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n       && !TREE_ADDRESSABLE (p)\n       && value && !TREE_SIDE_EFFECTS (value))\n     {\n-      /* We can't risk substituting complex expressions.  They\n-\t might contain variables that will be assigned to later.\n-\t Theoretically, we could check the expression to see if\n-\t all of the variables that determine its value are\n-\t read-only, but we don't bother.  */\n       /* We may produce non-gimple trees by adding NOPs or introduce\n \t invalid sharing when operand is not really constant.\n \t It is not big deal to prohibit constant propagation here as\n@@ -704,12 +1028,25 @@ setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n   /* Make an equivalent VAR_DECL.  Note that we must NOT remap the type\n      here since the type of this decl must be visible to the calling\n      function.  */\n-  var = copy_decl_for_inlining (p, fn, VARRAY_TREE (id->fns, 0));\n+  var = copy_decl_for_inlining (p, fn, id->caller);\n+\n+  /* See if the frontend wants to pass this by invisible reference.  If\n+     so, our new VAR_DECL will have REFERENCE_TYPE, and we need to\n+     replace uses of the PARM_DECL with dereferences.  */\n+  if (TREE_TYPE (var) != TREE_TYPE (p)\n+      && POINTER_TYPE_P (TREE_TYPE (var))\n+      && TREE_TYPE (TREE_TYPE (var)) == TREE_TYPE (p))\n+    {\n+      insert_decl_map (id, var, var);\n+      var_sub = build_fold_indirect_ref (var);\n+    }\n+  else\n+    var_sub = var;\n \n   /* Register the VAR_DECL as the equivalent for the PARM_DECL;\n      that way, when the PARM_DECL is encountered, it will be\n      automatically replaced by the VAR_DECL.  */\n-  insert_decl_map (id, p, var);\n+  insert_decl_map (id, p, var_sub);\n \n   /* Declare this new variable.  */\n   TREE_CHAIN (var) = *vars;\n@@ -735,14 +1072,14 @@ setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n   if (value)\n     {\n       tree rhs = fold_convert (TREE_TYPE (var), value);\n+      block_stmt_iterator bsi = bsi_last (bb);\n \n       if (rhs == error_mark_node)\n \treturn;\n \n       /* We want to use MODIFY_EXPR, not INIT_EXPR here so that we\n \t keep our trees in gimple form.  */\n       init_stmt = build (MODIFY_EXPR, TREE_TYPE (var), var, rhs);\n-      append_to_statement_list (init_stmt, init_stmts);\n \n       /* If we did not create a gimple value and we did not create a gimple\n \t cast of a gimple value, then we will need to gimplify INIT_STMTS\n@@ -752,23 +1089,22 @@ setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n       if (!is_gimple_val (rhs)\n \t  && (!is_gimple_cast (rhs)\n \t      || !is_gimple_val (TREE_OPERAND (rhs, 0))))\n-\t*gimplify_init_stmts_p = true;\n+\tgimplify_stmt (&init_stmt);\n+      bsi_insert_after (&bsi, init_stmt, BSI_NEW_STMT);\n     }\n }\n \n /* Generate code to initialize the parameters of the function at the\n    top of the stack in ID from the ARGS (presented as a TREE_LIST).  */\n \n-static tree\n+static void\n initialize_inlined_parameters (inline_data *id, tree args, tree static_chain,\n-\t\t\t       tree fn, tree bind_expr)\n+\t\t\t       tree fn, basic_block bb)\n {\n-  tree init_stmts = NULL_TREE;\n   tree parms;\n   tree a;\n   tree p;\n   tree vars = NULL_TREE;\n-  bool gimplify_init_stmts_p = false;\n   int argnum = 0;\n \n   /* Figure out what the parameters are.  */\n@@ -789,15 +1125,7 @@ initialize_inlined_parameters (inline_data *id, tree args, tree static_chain,\n       value = lang_hooks.tree_inlining.convert_parm_for_inlining\n \t      (p, a ? TREE_VALUE (a) : NULL_TREE, fn, argnum);\n \n-      setup_one_parameter (id, p, value, fn, &init_stmts, &vars,\n-\t\t\t   &gimplify_init_stmts_p);\n-    }\n-\n-  /* Evaluate trailing arguments.  */\n-  for (; a; a = TREE_CHAIN (a))\n-    {\n-      tree value = TREE_VALUE (a);\n-      append_to_statement_list (value, &init_stmts);\n+      setup_one_parameter (id, p, value, fn, bb, &vars);\n     }\n \n   /* Initialize the static chain.  */\n@@ -809,19 +1137,18 @@ initialize_inlined_parameters (inline_data *id, tree args, tree static_chain,\n       /* No static chain?  Seems like a bug in tree-nested.c.  */\n       gcc_assert (static_chain);\n \n-      setup_one_parameter (id, p, static_chain, fn, &init_stmts, &vars,\n-\t\t\t   &gimplify_init_stmts_p);\n+      setup_one_parameter (id, p, static_chain, fn, bb, &vars);\n     }\n \n-  if (gimplify_init_stmts_p)\n-    gimplify_body (&init_stmts, current_function_decl, false);\n-\n-  declare_inline_vars (bind_expr, vars);\n-  return init_stmts;\n+  declare_inline_vars (id->block, vars);\n }\n \n-/* Declare a return variable to replace the RESULT_DECL for the function we\n-   are calling.  RETURN_SLOT_ADDR, if non-null, was a fake parameter that\n+/* Declare a return variable to replace the RESULT_DECL for the\n+   function we are calling.  An appropriate DECL_STMT is returned.\n+   The USE_STMT is filled to contain a use of the declaration to\n+   indicate the return value of the function.\n+\n+   RETURN_SLOT_ADDR, if non-null, was a fake parameter that\n    took the address of the result.  MODIFY_DEST, if non-null, was the LHS of\n    the MODIFY_EXPR to which this call is the RHS.\n \n@@ -833,8 +1160,8 @@ static tree\n declare_return_variable (inline_data *id, tree return_slot_addr,\n \t\t\t tree modify_dest, tree *use_p)\n {\n-  tree callee = VARRAY_TOP_TREE (id->fns);\n-  tree caller = VARRAY_TREE (id->fns, 0);\n+  tree callee = id->callee;\n+  tree caller = id->caller;\n   tree result = DECL_RESULT (callee);\n   tree callee_type = TREE_TYPE (result);\n   tree caller_type = TREE_TYPE (TREE_TYPE (callee));\n@@ -900,6 +1227,7 @@ declare_return_variable (inline_data *id, tree return_slot_addr,\n   gcc_assert (TREE_CODE (TYPE_SIZE_UNIT (callee_type)) == INTEGER_CST);\n \n   var = copy_decl_for_inlining (result, callee, caller);\n+\n   DECL_SEEN_IN_BIND_EXPR_P (var) = 1;\n   DECL_STRUCT_FUNCTION (caller)->unexpanded_var_list\n     = tree_cons (NULL_TREE, var,\n@@ -1088,9 +1416,20 @@ static tree\n inline_forbidden_p (tree fndecl)\n {\n   location_t saved_loc = input_location;\n-  tree ret = walk_tree_without_duplicates (&DECL_SAVED_TREE (fndecl),\n-\t\t\t\t\t   inline_forbidden_p_1, fndecl);\n+  block_stmt_iterator bsi;\n+  basic_block bb;\n+  tree ret = NULL_TREE;\n+\n+  FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (fndecl))\n+    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      {\n+\tret = walk_tree_without_duplicates (bsi_stmt_ptr (bsi),\n+\t\t\t\t    inline_forbidden_p_1, fndecl);\n+\tif (ret)\n+\t  goto egress;\n+      }\n \n+egress:\n   input_location = saved_loc;\n   return ret;\n }\n@@ -1300,7 +1639,7 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n       if (is_gimple_reg (x))\n \tbreak;\n       /* Otherwise it's a store, so fall through to compute the move cost.  */\n-      \n+\n     case CONSTRUCTOR:\n       *count += estimate_move_cost (TREE_TYPE (x));\n       break;\n@@ -1436,30 +1775,99 @@ int\n estimate_num_insns (tree expr)\n {\n   int num = 0;\n-  walk_tree_without_duplicates (&expr, estimate_num_insns_1, &num);\n+  struct pointer_set_t *visited_nodes;\n+  basic_block bb;\n+  block_stmt_iterator bsi;\n+  struct function *my_function;\n+\n+  /* If we're given an entire function, walk the CFG.  */\n+  if (TREE_CODE (expr) == FUNCTION_DECL)\n+    {\n+      my_function = DECL_STRUCT_FUNCTION (expr);\n+      gcc_assert (my_function && my_function->cfg);\n+      visited_nodes = pointer_set_create ();\n+      FOR_EACH_BB_FN (bb, my_function)\n+\t{\n+\t  for (bsi = bsi_start (bb);\n+\t       !bsi_end_p (bsi);\n+\t       bsi_next (&bsi))\n+\t    {\n+\t      walk_tree (bsi_stmt_ptr (bsi), estimate_num_insns_1,\n+\t\t\t &num, visited_nodes);\n+\t    }\n+\t}\n+      pointer_set_destroy (visited_nodes);\n+    }\n+  else\n+    walk_tree_without_duplicates (&expr, estimate_num_insns_1, &num);\n+\n   return num;\n }\n \n+/* Initialized with NOGC, making this poisonous to the garbage collector.  */\n+static varray_type cfun_stack;\n+\n+void\n+push_cfun (struct function *new_cfun)\n+{\n+  static bool initialized = false;\n+\n+  if (!initialized)\n+    {\n+      VARRAY_GENERIC_PTR_NOGC_INIT (cfun_stack, 20, \"cfun_stack\");\n+      initialized = true;\n+    }\n+  VARRAY_PUSH_GENERIC_PTR (cfun_stack, cfun);\n+  cfun = new_cfun;\n+}\n+\n+void\n+pop_cfun (void)\n+{\n+  cfun = (struct function *)VARRAY_TOP_GENERIC_PTR (cfun_stack);\n+  VARRAY_POP (cfun_stack);\n+}\n+\n+/* Install new lexical TREE_BLOCK underneath 'current_block'.  */\n+static void\n+add_lexical_block (tree current_block, tree new_block)\n+{\n+  tree *blk_p;\n+\n+  /* Walk to the last sub-block.  */\n+  for (blk_p = &BLOCK_SUBBLOCKS (current_block);\n+       *blk_p;\n+       blk_p = &TREE_CHAIN (*blk_p))\n+    ;\n+  *blk_p = new_block;\n+  BLOCK_SUPERCONTEXT (new_block) = current_block;\n+  BLOCK_SUBBLOCKS (new_block) = NULL_TREE;\n+}\n+\n /* If *TP is a CALL_EXPR, replace it with its inline expansion.  */\n \n-static tree\n-expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n+static bool\n+expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n {\n   inline_data *id;\n   tree t;\n-  tree expr;\n-  tree stmt;\n   tree use_retvar;\n   tree fn;\n-  tree arg_inits;\n-  tree *inlined_body;\n   splay_tree st;\n   tree args;\n   tree return_slot_addr;\n   tree modify_dest;\n   location_t saved_location;\n-  struct cgraph_edge *edge;\n+  struct cgraph_edge *cg_edge;\n   const char *reason;\n+  basic_block return_block;\n+  edge e;\n+  block_stmt_iterator bsi, stmt_bsi;\n+  bool successfully_inlined = FALSE;\n+  tree t_step;\n+  tree var;\n+  struct cgraph_node *old_node;\n+  tree decl;\n \n   /* See what we've got.  */\n   id = (inline_data *) data;\n@@ -1471,39 +1879,6 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n   if (EXPR_HAS_LOCATION (t))\n     input_location = EXPR_LOCATION (t);\n \n-  /* Recurse, but letting recursive invocations know that we are\n-     inside the body of a TARGET_EXPR.  */\n-  if (TREE_CODE (*tp) == TARGET_EXPR)\n-    {\n-#if 0\n-      int i, len = TREE_CODE_LENGTH (TARGET_EXPR);\n-\n-      /* We're walking our own subtrees.  */\n-      *walk_subtrees = 0;\n-\n-      /* Actually walk over them.  This loop is the body of\n-\t walk_trees, omitting the case where the TARGET_EXPR\n-\t itself is handled.  */\n-      for (i = 0; i < len; ++i)\n-\t{\n-\t  if (i == 2)\n-\t    ++id->in_target_cleanup_p;\n-\t  walk_tree (&TREE_OPERAND (*tp, i), expand_call_inline, data,\n-\t\t     id->tree_pruner);\n-\t  if (i == 2)\n-\t    --id->in_target_cleanup_p;\n-\t}\n-\n-      goto egress;\n-#endif\n-    }\n-\n-  if (TYPE_P (t))\n-    /* Because types were not copied in copy_body, CALL_EXPRs beneath\n-       them should not be expanded.  This can happen if the type is a\n-       dynamic array type, for example.  */\n-    *walk_subtrees = 0;\n-\n   /* From here on, we're only interested in CALL_EXPRs.  */\n   if (TREE_CODE (t) != CALL_EXPR)\n     goto egress;\n@@ -1534,11 +1909,11 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n   if (!id->current_node->analyzed)\n     goto egress;\n \n-  edge = cgraph_edge (id->current_node, t);\n+  cg_edge = cgraph_edge (id->current_node, t);\n \n   /* Constant propagation on argument done during previous inlining\n      may create new direct call.  Produce an edge for it.  */\n-  if (!edge)\n+  if (!cg_edge)\n     {\n       struct cgraph_node *dest = cgraph_node (fn);\n \n@@ -1554,7 +1929,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n \n   /* Don't try to inline functions that are not well-suited to\n      inlining.  */\n-  if (!cgraph_inline_p (edge, &reason))\n+  if (!cgraph_inline_p (cg_edge, &reason))\n     {\n       if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)))\n \t{\n@@ -1573,21 +1948,45 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n     }\n \n #ifdef ENABLE_CHECKING\n-  if (edge->callee->decl != id->node->decl)\n-    verify_cgraph_node (edge->callee);\n+  if (cg_edge->callee->decl != id->node->decl)\n+    verify_cgraph_node (cg_edge->callee);\n #endif\n \n-  if (! lang_hooks.tree_inlining.start_inlining (fn))\n-    goto egress;\n+  /* We will be inlining this callee.  */\n+\n+  id->eh_region = lookup_stmt_eh_region (stmt);\n+\n+  /* Split the block holding the CALL_EXPR.  */\n+\n+  e = split_block (bb, stmt);\n+  bb = e->src;\n+  return_block = e->dest;\n+  remove_edge (e);\n+\n+  /* split_block splits before the statement, work around this by moving\n+     the call into the first half_bb.  Not pretty, but seems easier than\n+     doing the CFG manipulation by hand when the CALL_EXPR is in the last\n+     statement in BB.  */\n+  stmt_bsi = bsi_last (bb);\n+  bsi = bsi_start (return_block);\n+  if (!bsi_end_p (bsi))\n+    bsi_move_before (&stmt_bsi, &bsi);\n+  else\n+    {\n+      tree stmt = bsi_stmt (stmt_bsi);\n+      bsi_remove (&stmt_bsi);\n+      bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n+    }\n+  stmt_bsi = bsi_start (return_block);\n \n   /* Build a block containing code to initialize the arguments, the\n      actual inline expansion of the body, and a label for the return\n      statements within the function to jump to.  The type of the\n      statement expression is the return type of the function call.  */\n-  stmt = NULL;\n-  expr = build (BIND_EXPR, void_type_node, NULL_TREE,\n-\t\tstmt, make_node (BLOCK));\n-  BLOCK_ABSTRACT_ORIGIN (BIND_EXPR_BLOCK (expr)) = fn;\n+  id->block = make_node (BLOCK);\n+  BLOCK_ABSTRACT_ORIGIN (id->block) = fn;\n+  add_lexical_block (TREE_BLOCK (stmt), id->block);\n+\n \n   /* Local declarations will be replaced by their equivalents in this\n      map.  */\n@@ -1597,52 +1996,27 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n \n   /* Initialize the parameters.  */\n   args = TREE_OPERAND (t, 1);\n-  return_slot_addr = NULL_TREE;\n   if (CALL_EXPR_HAS_RETURN_SLOT_ADDR (t))\n     {\n       return_slot_addr = TREE_VALUE (args);\n       args = TREE_CHAIN (args);\n-      TREE_TYPE (expr) = void_type_node;\n     }\n+  else\n+    return_slot_addr = NULL_TREE;\n \n-  arg_inits = initialize_inlined_parameters (id, args, TREE_OPERAND (t, 2),\n-\t\t\t\t\t     fn, expr);\n-  if (arg_inits)\n-    {\n-      /* Expand any inlined calls in the initializers.  Do this before we\n-\t push FN on the stack of functions we are inlining; we want to\n-\t inline calls to FN that appear in the initializers for the\n-\t parameters.\n-\n-\t Note we need to save and restore the saved tree statement iterator\n-\t to avoid having it clobbered by expand_calls_inline.  */\n-      tree_stmt_iterator save_tsi;\n-\n-      save_tsi = id->tsi;\n-      expand_calls_inline (&arg_inits, id);\n-      id->tsi = save_tsi;\n-\n-      /* And add them to the tree.  */\n-      append_to_statement_list (arg_inits, &BIND_EXPR_BODY (expr));\n-    }\n+  initialize_inlined_parameters (id, args, TREE_OPERAND (t, 2), fn, bb);\n \n-  /* Record the function we are about to inline so that we can avoid\n-     recursing into it.  */\n-  VARRAY_PUSH_TREE (id->fns, fn);\n+  /* Record the function we are about to inline.  */\n+  id->callee = fn;\n \n   /* Return statements in the function body will be replaced by jumps\n      to the RET_LABEL.  */\n-  id->ret_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-  DECL_ARTIFICIAL (id->ret_label) = 1;\n-  DECL_IGNORED_P (id->ret_label) = 1;\n-  DECL_CONTEXT (id->ret_label) = VARRAY_TREE (id->fns, 0);\n-  insert_decl_map (id, id->ret_label, id->ret_label);\n \n   gcc_assert (DECL_INITIAL (fn));\n   gcc_assert (TREE_CODE (DECL_INITIAL (fn)) == BLOCK);\n \n   /* Find the lhs to which the result of this call is assigned.  */\n-  modify_dest = tsi_stmt (id->tsi);\n+  modify_dest = stmt;\n   if (TREE_CODE (modify_dest) == MODIFY_EXPR)\n     {\n       modify_dest = TREE_OPERAND (modify_dest, 0);\n@@ -1660,190 +2034,110 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n     modify_dest = NULL;\n \n   /* Declare the return variable for the function.  */\n-  declare_return_variable (id, return_slot_addr,\n-\t\t\t   modify_dest, &use_retvar);\n+  decl = declare_return_variable (id, return_slot_addr,\n+\t\t\t          modify_dest, &use_retvar);\n+  /* Do this only if declare_return_variable created a new one.  */\n+  if (decl && !return_slot_addr && decl != modify_dest)\n+    declare_inline_vars (id->block, decl);\n \n   /* After we've initialized the parameters, we insert the body of the\n      function itself.  */\n-  {\n-    struct cgraph_node *old_node = id->current_node;\n-    tree copy;\n-\n-    id->current_node = edge->callee;\n-    copy = copy_body (id);\n-\n-    /* If the function uses a return slot, then it may legitimately\n-       fall through while still returning a value, so we have to skip\n-       the warning here.  */\n-    if (warn_return_type\n-\t&& !TREE_NO_WARNING (fn)\n-\t&& !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (fn)))\n-\t&& return_slot_addr == NULL_TREE\n-\t&& block_may_fallthru (copy))\n-      {\n-\twarning (0, \"control may reach end of non-void function %qD being inlined\",\n-\t\t fn);\n-\tTREE_NO_WARNING (fn) = 1;\n-      }\n+  old_node = id->current_node;\n \n-    append_to_statement_list (copy, &BIND_EXPR_BODY (expr));\n-    id->current_node = old_node;\n-  }\n-  inlined_body = &BIND_EXPR_BODY (expr);\n+  /* Anoint the callee-to-be-duplicated as the \"current_node.\"  When\n+     CALL_EXPRs within callee are duplicated, the edges from callee to\n+     callee's callees (caller's grandchildren) will be cloned.  */\n+  id->current_node = cg_edge->callee;\n \n-  /* After the body of the function comes the RET_LABEL.  This must come\n-     before we evaluate the returned value below, because that evaluation\n-     may cause RTL to be generated.  */\n-  if (TREE_USED (id->ret_label))\n-    {\n-      tree label = build1 (LABEL_EXPR, void_type_node, id->ret_label);\n-      append_to_statement_list (label, &BIND_EXPR_BODY (expr));\n-    }\n+  /* This is it.  Duplicate the callee body.  Assume callee is\n+     pre-gimplified.  Note that we must not alter the caller\n+     function in any way before this point, as this CALL_EXPR may be\n+     a self-referential call; if we're calling ourselves, we need to\n+     duplicate our body before altering anything.  */\n+  copy_body (id, bb->count, bb->frequency, bb, return_block);\n+  id->current_node = old_node;\n \n   /* Clean up.  */\n   splay_tree_delete (id->decl_map);\n   id->decl_map = st;\n \n-  /* Although, from the semantic viewpoint, the new expression has\n-     side-effects only if the old one did, it is not possible, from\n-     the technical viewpoint, to evaluate the body of a function\n-     multiple times without serious havoc.  */\n-  TREE_SIDE_EFFECTS (expr) = 1;\n-\n-  tsi_link_before (&id->tsi, expr, TSI_SAME_STMT);\n-\n   /* If the inlined function returns a result that we care about,\n-     then we're going to need to splice in a MODIFY_EXPR.  Otherwise\n-     the call was a standalone statement and we can just replace it\n-     with the BIND_EXPR inline representation of the called function.  */\n-  if (!use_retvar || !modify_dest)\n-    *tsi_stmt_ptr (id->tsi) = build_empty_stmt ();\n+     clobber the CALL_EXPR with a reference to the return variable.  */\n+  if (use_retvar && (TREE_CODE (bsi_stmt (stmt_bsi)) != CALL_EXPR))\n+    {\n+      *tp = use_retvar;\n+      maybe_clean_or_replace_eh_stmt (stmt, stmt);\n+    }\n   else\n-    *tp = use_retvar;\n+    /* We're modifying a TSI owned by gimple_expand_calls_inline();\n+       tsi_delink() will leave the iterator in a sane state.  */\n+    bsi_remove (&stmt_bsi);\n \n-  /* When we gimplify a function call, we may clear TREE_SIDE_EFFECTS on\n-     the call if it is to a \"const\" function.  Thus the copy of\n-     TREE_SIDE_EFFECTS from the CALL_EXPR to the BIND_EXPR above with\n-     result in TREE_SIDE_EFFECTS not being set for the inlined copy of a\n-     \"const\" function.\n+  bsi_next (&bsi);\n+  if (bsi_end_p (bsi))\n+    tree_purge_dead_eh_edges (return_block);\n \n-     Unfortunately, that is wrong as inlining the function can create/expose\n-     interesting side effects (such as setting of a return value).\n+  /* If the value of the new expression is ignored, that's OK.  We\n+     don't warn about this for CALL_EXPRs, so we shouldn't warn about\n+     the equivalent inlined version either.  */\n+  TREE_USED (*tp) = 1;\n \n-     The easiest solution is to simply recalculate TREE_SIDE_EFFECTS for\n-     the toplevel expression.  */\n-  recalculate_side_effects (expr);\n-  \n   /* Output the inlining info for this abstract function, since it has been\n      inlined.  If we don't do this now, we can lose the information about the\n      variables in the function when the blocks get blown away as soon as we\n      remove the cgraph node.  */\n-  (*debug_hooks->outlining_inline_function) (edge->callee->decl);\n+  (*debug_hooks->outlining_inline_function) (cg_edge->callee->decl);\n \n   /* Update callgraph if needed.  */\n-  cgraph_remove_node (edge->callee);\n+  cgraph_remove_node (cg_edge->callee);\n \n-  /* Recurse into the body of the just inlined function.  */\n-  expand_calls_inline (inlined_body, id);\n-  VARRAY_POP (id->fns);\n+  /* Declare the 'auto' variables added with this inlined body.  */\n+  record_vars (BLOCK_VARS (id->block));\n+  id->block = NULL_TREE;\n \n-  /* Don't walk into subtrees.  We've already handled them above.  */\n-  *walk_subtrees = 0;\n-\n-  lang_hooks.tree_inlining.end_inlining (fn);\n+  /* Add local static vars in this inlined callee to caller.  */\n+  for (t_step = id->callee_cfun->unexpanded_var_list;\n+       t_step;\n+       t_step = TREE_CHAIN (t_step))\n+    {\n+      var = TREE_VALUE (t_step);\n+      if (TREE_STATIC (var) && !TREE_ASM_WRITTEN (var))\n+\trecord_vars (var);\n+    }\n+  successfully_inlined = TRUE;\n \n-  /* Keep iterating.  */\n  egress:\n   input_location = saved_location;\n-  return NULL_TREE;\n+  return successfully_inlined;\n }\n \n-static void\n-expand_calls_inline (tree *stmt_p, inline_data *id)\n+/* Expand call statements reachable from STMT_P.\n+   We can only have CALL_EXPRs as the \"toplevel\" tree code or nested\n+   in a MODIFY_EXPR.  See tree-gimple.c:get_call_expr_in().  We can\n+   unfortunately not use that function here because we need a pointer\n+   to the CALL_EXPR, not the tree itself.  */\n+\n+static bool\n+gimple_expand_calls_inline (basic_block bb, inline_data *id)\n {\n-  tree stmt = *stmt_p;\n-  enum tree_code code = TREE_CODE (stmt);\n-  int dummy;\n+  block_stmt_iterator bsi;\n \n-  switch (code)\n+  /* Register specific tree functions.  */\n+  tree_register_cfg_hooks ();\n+  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n     {\n-    case STATEMENT_LIST:\n-      {\n-\ttree_stmt_iterator i;\n-\ttree new;\n-\n-\tfor (i = tsi_start (stmt); !tsi_end_p (i); )\n-\t  {\n-\t    id->tsi = i;\n-\t    expand_calls_inline (tsi_stmt_ptr (i), id);\n-\n-\t    new = tsi_stmt (i);\n-\t    if (TREE_CODE (new) == STATEMENT_LIST)\n-\t      {\n-\t\ttsi_link_before (&i, new, TSI_SAME_STMT);\n-\t\ttsi_delink (&i);\n-\t      }\n-\t    else\n-\t      tsi_next (&i);\n-\t  }\n-      }\n-      break;\n-\n-    case COND_EXPR:\n-      expand_calls_inline (&COND_EXPR_THEN (stmt), id);\n-      expand_calls_inline (&COND_EXPR_ELSE (stmt), id);\n-      break;\n-\n-    case CATCH_EXPR:\n-      expand_calls_inline (&CATCH_BODY (stmt), id);\n-      break;\n-\n-    case EH_FILTER_EXPR:\n-      expand_calls_inline (&EH_FILTER_FAILURE (stmt), id);\n-      break;\n-\n-    case TRY_CATCH_EXPR:\n-    case TRY_FINALLY_EXPR:\n-      expand_calls_inline (&TREE_OPERAND (stmt, 0), id);\n-      expand_calls_inline (&TREE_OPERAND (stmt, 1), id);\n-      break;\n-\n-    case BIND_EXPR:\n-      expand_calls_inline (&BIND_EXPR_BODY (stmt), id);\n-      break;\n-\n-    case COMPOUND_EXPR:\n-      /* We're gimple.  We should have gotten rid of all these.  */\n-      gcc_unreachable ();\n-\n-    case RETURN_EXPR:\n-      stmt_p = &TREE_OPERAND (stmt, 0);\n-      stmt = *stmt_p;\n-      if (!stmt || TREE_CODE (stmt) != MODIFY_EXPR)\n-\tbreak;\n-\n-      /* FALLTHRU */\n-\n-    case MODIFY_EXPR:\n-      stmt_p = &TREE_OPERAND (stmt, 1);\n-      stmt = *stmt_p;\n-      if (TREE_CODE (stmt) == WITH_SIZE_EXPR)\n-\t{\n-\t  stmt_p = &TREE_OPERAND (stmt, 0);\n-\t  stmt = *stmt_p;\n-\t}\n-      if (TREE_CODE (stmt) != CALL_EXPR)\n-\tbreak;\n-\n-      /* FALLTHRU */\n-\n-    case CALL_EXPR:\n-      expand_call_inline (stmt_p, &dummy, id);\n-      break;\n-\n-    default:\n-      break;\n+      tree *expr_p = bsi_stmt_ptr (bsi);\n+      tree stmt = *expr_p;\n+\n+      if (TREE_CODE (*expr_p) == MODIFY_EXPR)\n+\texpr_p = &TREE_OPERAND (*expr_p, 1);\n+      if (TREE_CODE (*expr_p) == WITH_SIZE_EXPR)\n+\texpr_p = &TREE_OPERAND (*expr_p, 0);\n+      if (TREE_CODE (*expr_p) == CALL_EXPR)\n+\tif (expand_call_inline (bb, stmt, expr_p, id))\n+\t  return true;\n     }\n+  return false;\n }\n \n /* Expand calls to inline functions in the body of FN.  */\n@@ -1853,7 +2147,7 @@ optimize_inline_calls (tree fn)\n {\n   inline_data id;\n   tree prev_fn;\n-\n+  basic_block bb;\n   /* There is no point in performing inlining if errors have already\n      occurred -- and we might crash if we try to inline invalid\n      code.  */\n@@ -1864,30 +2158,31 @@ optimize_inline_calls (tree fn)\n   memset (&id, 0, sizeof (id));\n \n   id.current_node = id.node = cgraph_node (fn);\n-  /* Don't allow recursion into FN.  */\n-  VARRAY_TREE_INIT (id.fns, 32, \"fns\");\n-  VARRAY_PUSH_TREE (id.fns, fn);\n+  id.caller = fn;\n   /* Or any functions that aren't finished yet.  */\n   prev_fn = NULL_TREE;\n   if (current_function_decl)\n     {\n-      VARRAY_PUSH_TREE (id.fns, current_function_decl);\n+      id.caller = current_function_decl;\n       prev_fn = current_function_decl;\n     }\n+  push_gimplify_context ();\n \n-  prev_fn = lang_hooks.tree_inlining.add_pending_fn_decls (&id.fns, prev_fn);\n-\n-  /* Keep track of the low-water mark, i.e., the point where the first\n-     real inlining is represented in ID.FNS.  */\n-  id.first_inlined_fn = VARRAY_ACTIVE_SIZE (id.fns);\n+  /* Reach the trees by walking over the CFG, and note the\n+     enclosing basic-blocks in the call edges.  */\n+  /* We walk the blocks going forward, because inlined function bodies\n+     will split id->current_basic_block, and the new blocks will\n+     follow it; we'll trudge through them, processing their CALL_EXPRs\n+     along the way.  */\n+  FOR_EACH_BB (bb)\n+    gimple_expand_calls_inline (bb, &id);\n \n-  /* Replace all calls to inline functions with the bodies of those\n-     functions.  */\n-  id.tree_pruner = htab_create (37, htab_hash_pointer, htab_eq_pointer, NULL);\n-  expand_calls_inline (&DECL_SAVED_TREE (fn), &id);\n \n-  /* Clean up.  */\n-  htab_delete (id.tree_pruner);\n+  pop_gimplify_context (NULL);\n+  /* Renumber the (code) basic_blocks consecutively.  */\n+  compact_blocks ();\n+  /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n+  number_blocks (fn);\n \n #ifdef ENABLE_CHECKING\n     {\n@@ -1900,6 +2195,11 @@ optimize_inline_calls (tree fn)\n \tgcc_assert (e->inline_failed);\n     }\n #endif\n+  /* We need to rescale frequencies again to peak at REG_BR_PROB_BASE\n+     as inlining loops might increase the maximum.  */\n+  if (ENTRY_BLOCK_PTR->count)\n+    counts_to_freqs ();\n+  fold_cond_expr_cond ();\n }\n \n /* FN is a function that has a complete body, and CLONE is a function whose\n@@ -1912,34 +2212,41 @@ clone_body (tree clone, tree fn, void *arg_map)\n   inline_data id;\n \n   /* Clone the body, as if we were making an inline call.  But, remap the\n-     parameters in the callee to the parameters of caller.  If there's an\n-     in-charge parameter, map it to an appropriate constant.  */\n+     parameters in the callee to the parameters of caller.  */\n   memset (&id, 0, sizeof (id));\n-  VARRAY_TREE_INIT (id.fns, 2, \"fns\");\n-  VARRAY_PUSH_TREE (id.fns, clone);\n-  VARRAY_PUSH_TREE (id.fns, fn);\n+  id.caller = clone;\n+  id.callee = fn;\n+  id.callee_cfun = DECL_STRUCT_FUNCTION (fn);\n   id.decl_map = (splay_tree)arg_map;\n \n   /* Cloning is treated slightly differently from inlining.  Set\n      CLONING_P so that it's clear which operation we're performing.  */\n   id.cloning_p = true;\n \n+  /* We're not inside any EH region.  */\n+  id.eh_region = -1;\n+\n   /* Actually copy the body.  */\n-  append_to_statement_list_force (copy_body (&id), &DECL_SAVED_TREE (clone));\n+  append_to_statement_list_force (copy_generic_body (&id), &DECL_SAVED_TREE (clone));\n }\n \n+/* Save duplicate body in FN.  MAP is used to pass around splay tree\n+   used to update argments in restore_body.  */\n+\n /* Make and return duplicate of body in FN.  Put copies of DECL_ARGUMENTS\n    in *arg_copy and of the static chain, if any, in *sc_copy.  */\n \n-tree\n+void\n save_body (tree fn, tree *arg_copy, tree *sc_copy)\n {\n   inline_data id;\n-  tree body, *parg;\n+  tree newdecl, *parg;\n+  basic_block fn_entry_block;\n \n   memset (&id, 0, sizeof (id));\n-  VARRAY_TREE_INIT (id.fns, 1, \"fns\");\n-  VARRAY_PUSH_TREE (id.fns, fn);\n+  id.callee = fn;\n+  id.callee_cfun = DECL_STRUCT_FUNCTION (fn);\n+  id.caller = fn;\n   id.node = cgraph_node (fn);\n   id.saving_p = true;\n   id.decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n@@ -1968,14 +2275,21 @@ save_body (tree fn, tree *arg_copy, tree *sc_copy)\n       *sc_copy = new;\n     }\n \n+  /* We're not inside any EH region.  */\n+  id.eh_region = -1;\n+\n   insert_decl_map (&id, DECL_RESULT (fn), DECL_RESULT (fn));\n \n-  /* Actually copy the body.  */\n-  body = copy_body (&id);\n+  /* Actually copy the body, including a new (struct function *) and CFG.\n+     EH info is also duplicated so its labels point into the copied\n+     CFG, not the original.  */\n+  fn_entry_block = ENTRY_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (fn));\n+  newdecl = copy_body (&id, fn_entry_block->count, fn_entry_block->frequency, NULL, NULL);\n+  DECL_STRUCT_FUNCTION (fn)->saved_cfg = DECL_STRUCT_FUNCTION (newdecl)->cfg;\n+  DECL_STRUCT_FUNCTION (fn)->saved_eh = DECL_STRUCT_FUNCTION (newdecl)->eh;\n \n   /* Clean up.  */\n   splay_tree_delete (id.decl_map);\n-  return body;\n }\n \n /* Passed to walk_tree.  Copies the node pointed to, if appropriate.  */\n@@ -2029,7 +2343,8 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \n /* The SAVE_EXPR pointed to by TP is being copied.  If ST contains\n    information indicating to what new SAVE_EXPR this one should be mapped,\n-   use that one.  Otherwise, create a new node and enter it in ST.  */\n+   use that one.  Otherwise, create a new node and enter it in ST.  FN is\n+   the function into which the copy will be placed.  */\n \n static void\n remap_save_expr (tree *tp, void *st_, int *walk_subtrees)\n@@ -2169,8 +2484,8 @@ unsave_expr_now (tree expr)\n \n   /* Set up ID.  */\n   memset (&id, 0, sizeof (id));\n-  VARRAY_TREE_INIT (id.fns, 1, \"fns\");\n-  VARRAY_PUSH_TREE (id.fns, current_function_decl);\n+  id.callee = current_function_decl;\n+  id.caller = current_function_decl;\n   id.decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n \n   /* Walk the tree once to find local labels.  */\n@@ -2202,15 +2517,24 @@ debug_find_tree (tree top, tree search)\n   return walk_tree_without_duplicates (&top, debug_find_tree_1, search) != 0;\n }\n \n+\n /* Declare the variables created by the inliner.  Add all the variables in\n    VARS to BIND_EXPR.  */\n \n static void\n-declare_inline_vars (tree bind_expr, tree vars)\n+declare_inline_vars (tree block, tree vars)\n {\n   tree t;\n   for (t = vars; t; t = TREE_CHAIN (t))\n     DECL_SEEN_IN_BIND_EXPR_P (t) = 1;\n \n-  add_var_to_bind_expr (bind_expr, vars);\n+  if (block)\n+    BLOCK_VARS (block) = chainon (BLOCK_VARS (block), vars);\n+}\n+\n+/* Returns true if we're inlining.  */\n+static inline bool\n+inlining_p (inline_data *id)\n+{\n+  return (!id->saving_p && !id->cloning_p);\n }"}, {"sha": "1f71c33c9c0c06cae05eaf36e12fa58079475902", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=e21aff8abe2079837b599b4975c81b6dfe969a65", "patch": "@@ -28,8 +28,10 @@ void optimize_inline_calls (tree);\n bool tree_inlinable_function_p (tree);\n tree copy_tree_r (tree *, int *, void *);\n void clone_body (tree, tree, void *);\n-tree save_body (tree, tree *, tree *);\n+void save_body (tree, tree *, tree *);\n int estimate_move_cost (tree type);\n+void push_cfun (struct function *new_cfun);\n+void pop_cfun (void);\n int estimate_num_insns (tree expr);\n \n /* 0 if we should not perform inlining."}, {"sha": "329c06e31823372b26794f8eb924249d8541cf29", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 86, "deletions": 10, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=e21aff8abe2079837b599b4975c81b6dfe969a65", "patch": "@@ -48,14 +48,15 @@ Boston, MA 02111-1307, USA.  */\n #include \"cgraph.h\"\n #include \"graph.h\"\n #include \"cfgloop.h\"\n+#include \"except.h\"\n \n \n /* Global variables used to communicate with passes.  */\n int dump_flags;\n bool in_gimple_form;\n \n /* The root of the compilation pass tree, once constructed.  */\n-static struct tree_opt_pass *all_passes, *all_ipa_passes;\n+static struct tree_opt_pass *all_passes, *all_ipa_passes, * all_lowering_passes;\n \n /* Gate: execute, or not, all of the non-trivial optimizations.  */\n \n@@ -158,6 +159,51 @@ static struct tree_opt_pass pass_free_datastructures =\n   0\t\t\t\t\t/* letter */\n };\n \n+/* Pass: fixup_cfg - IPA passes or compilation of earlier functions might've\n+   changed some properties - such as marged functions nothrow.  Remove now\n+   redundant edges and basic blocks.  */\n+\n+static void\n+execute_fixup_cfg (void)\n+{\n+  basic_block bb;\n+  block_stmt_iterator bsi;\n+\n+  if (cfun->eh)\n+    FOR_EACH_BB (bb)\n+      {\n+\tfor (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t  {\n+\t    tree stmt = bsi_stmt (bsi);\n+\t    tree call = get_call_expr_in (stmt);\n+\n+\t    if (call && call_expr_flags (call) & (ECF_CONST | ECF_PURE))\n+\t      TREE_SIDE_EFFECTS (call) = 0;\n+\t    if (!tree_could_throw_p (stmt) && lookup_stmt_eh_region (stmt))\n+\t      remove_stmt_from_eh_region (stmt);\n+\t  }\n+\ttree_purge_dead_eh_edges (bb);\n+      }\n+    \n+  cleanup_tree_cfg ();\n+}\n+\n+static struct tree_opt_pass pass_fixup_cfg =\n+{\n+  NULL,\t\t\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  execute_fixup_cfg,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_cfg,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0,\t\t\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n \n /* Do the actions required to initialize internal data structures used\n    in tree-ssa optimization passes.  */\n@@ -320,14 +366,21 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_ipa_inline);\n   *p = NULL;\n \n-  p = &all_passes;\n+  /* All passes needed to lower the function into shape optimizers can operate\n+     on.  These passes are performed before interprocedural passes, unlike rest\n+     of local passes (all_passes).  */\n+  p = &all_lowering_passes;\n   NEXT_PASS (pass_remove_useless_stmts);\n   NEXT_PASS (pass_mudflap_1);\n-  NEXT_PASS (pass_lower_cf);\n-  NEXT_PASS (pass_lower_eh);\n-  NEXT_PASS (pass_build_cfg);\n+  NEXT_PASS (pass_lower_cf); \n+  NEXT_PASS (pass_lower_eh); \n+  NEXT_PASS (pass_build_cfg); \n   NEXT_PASS (pass_pre_expand);\n   NEXT_PASS (pass_warn_function_return);\n+  *p = NULL;\n+\n+  p = &all_passes;\n+  NEXT_PASS (pass_fixup_cfg);\n   NEXT_PASS (pass_tree_profile);\n   NEXT_PASS (pass_init_datastructures);\n   NEXT_PASS (pass_all_optimizations);\n@@ -432,6 +485,7 @@ init_tree_optimization_passes (void)\n \n #undef NEXT_PASS\n \n+  register_dump_files (all_lowering_passes, false, 0);\n   register_dump_files (all_passes, false, PROP_gimple_any\n \t\t\t\t\t  | PROP_gimple_lcf\n \t\t\t\t\t  | PROP_gimple_leh\n@@ -606,6 +660,23 @@ execute_pass_list (struct tree_opt_pass *pass)\n   while (pass);\n }\n \n+void\n+tree_lowering_passes (tree fn)\n+{\n+  tree saved_current_function_decl = current_function_decl;\n+\n+  current_function_decl = fn;\n+  push_cfun (DECL_STRUCT_FUNCTION (fn));\n+  tree_register_cfg_hooks ();\n+  bitmap_obstack_initialize (NULL);\n+  execute_pass_list (all_lowering_passes);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  compact_blocks ();\n+  current_function_decl = saved_current_function_decl;\n+  bitmap_obstack_release (NULL);\n+  pop_cfun ();\n+}\n+\n /* Execute all IPA passes.  */\n void\n ipa_passes (void)\n@@ -675,8 +746,7 @@ tree_rest_of_compilation (tree fndecl)\n \t      cgraph_clone_inlined_nodes (e, true);\n \t}\n       cfun->saved_static_chain_decl = cfun->static_chain_decl;\n-      cfun->saved_tree = save_body (fndecl, &cfun->saved_args,\n-\t\t\t\t    &cfun->saved_static_chain_decl);\n+      save_body (fndecl, &cfun->saved_args, &cfun->saved_static_chain_decl);\n     }\n \n   if (flag_inline_trees)\n@@ -712,6 +782,7 @@ tree_rest_of_compilation (tree fndecl)\n   bitmap_obstack_initialize (NULL);\n   bitmap_obstack_initialize (&reg_obstack); /* FIXME, only at RTL generation*/\n   \n+  tree_register_cfg_hooks ();\n   /* Perform all tree transforms and optimizations.  */\n   execute_pass_list (all_passes);\n   \n@@ -721,19 +792,24 @@ tree_rest_of_compilation (tree fndecl)\n   bitmap_obstack_release (NULL);\n   \n   /* Restore original body if still needed.  */\n-  if (cfun->saved_tree)\n+  if (cfun->saved_cfg)\n     {\n-      DECL_SAVED_TREE (fndecl) = cfun->saved_tree;\n       DECL_ARGUMENTS (fndecl) = cfun->saved_args;\n+      cfun->cfg = cfun->saved_cfg;\n+      cfun->eh = cfun->saved_eh;\n+      cfun->saved_cfg = NULL;\n+      cfun->saved_eh = NULL;\n+      cfun->saved_args = NULL_TREE;\n       cfun->static_chain_decl = cfun->saved_static_chain_decl;\n-\n+      cfun->saved_static_chain_decl = NULL;\n       /* When not in unit-at-a-time mode, we must preserve out of line copy\n \t representing node before inlining.  Restore original outgoing edges\n \t using clone we created earlier.  */\n       if (!flag_unit_at_a_time)\n \t{\n \t  struct cgraph_edge *e;\n \n+\t  node = cgraph_node (current_function_decl);\n \t  cgraph_node_remove_callees (node);\n \t  node->callees = saved_node->callees;\n \t  saved_node->callees = NULL;"}, {"sha": "a65df46ccac5e0ea1d649a68153162b3b1c2c7fd", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e21aff8abe2079837b599b4975c81b6dfe969a65/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=e21aff8abe2079837b599b4975c81b6dfe969a65", "patch": "@@ -155,6 +155,7 @@ struct dump_file_info\n   (TODO_verify_ssa | TODO_verify_flow | TODO_verify_stmts)\n \n extern void ipa_passes (void);\n+extern void tree_lowering_passes (tree decl);\n \n extern struct tree_opt_pass pass_mudflap_1;\n extern struct tree_opt_pass pass_mudflap_2;"}]}