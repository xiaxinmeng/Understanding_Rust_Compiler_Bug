{"sha": "34e81b5a0fc58ec481f82ad985b449e344c0206c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRlODFiNWEwZmM1OGVjNDgxZjgyYWQ5ODViNDQ5ZTM0NGMwMjA2Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-11-13T10:47:40Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-11-13T10:47:40Z"}, "message": "Makefile.in (expr.o): Depends on insn-attr.h.\n\n\t* Makefile.in (expr.o): Depends on insn-attr.h.\n\t* expr.c (insn-attr.h): New include.\n\t(force_operand): If INSN_SCHEDULING, deal with paradoxical SUBREG\n\tof MEM.\n\t(highest_pow2_factor, case INTEGER_CST): Handle negative values.\n\t(expand_expr): Remove unneeded mark_temp_addr_taken calls and\n\tclean up related usage in ADDR_EXPR.\n\t(expand_expr_unaligned): Likewise.\n\nFrom-SVN: r46980", "tree": {"sha": "90f87fffe6ea09898357f1426e7030d4c09dd26f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90f87fffe6ea09898357f1426e7030d4c09dd26f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34e81b5a0fc58ec481f82ad985b449e344c0206c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34e81b5a0fc58ec481f82ad985b449e344c0206c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34e81b5a0fc58ec481f82ad985b449e344c0206c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34e81b5a0fc58ec481f82ad985b449e344c0206c/comments", "author": null, "committer": null, "parents": [{"sha": "047cd3df63b491a5dccfad6b6d6319fe5f3d2945", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/047cd3df63b491a5dccfad6b6d6319fe5f3d2945", "html_url": "https://github.com/Rust-GCC/gccrs/commit/047cd3df63b491a5dccfad6b6d6319fe5f3d2945"}], "stats": {"total": 63, "additions": 32, "deletions": 31}, "files": [{"sha": "6ce2759c87f6c5d5deef4106d55997b584c4b346", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e81b5a0fc58ec481f82ad985b449e344c0206c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e81b5a0fc58ec481f82ad985b449e344c0206c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=34e81b5a0fc58ec481f82ad985b449e344c0206c", "patch": "@@ -1404,9 +1404,9 @@ except.o : except.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h hard-reg-set.h $(BASIC_BLOCK_H) output.h \\\n    dwarf2asm.h dwarf2out.h toplev.h $(HASHTAB_H) intl.h $(GGC_H)\n expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h function.h \\\n-   $(REGS_H) $(EXPR_H) $(OPTABS_H) libfuncs.h insn-config.h $(RECOG_H) \\\n-   output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h except.h \\\n-   reload.h $(GGC_H) intl.h $(TM_P_H)\n+   $(REGS_H) $(EXPR_H) $(OPTABS_H) libfuncs.h insn-attr.h insn-config.h \\\n+   $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \\\n+   except.h reload.h $(GGC_H) intl.h $(TM_P_H)\n builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    $(TARGET_H) function.h $(REGS_H) $(EXPR_H) $(OPTABS_H) insn-config.h \\\n    $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \\"}, {"sha": "42372b1aa725286828cbf7242a3e8b2e5ebed7fd", "filename": "gcc/expr.c", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e81b5a0fc58ec481f82ad985b449e344c0206c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e81b5a0fc58ec481f82ad985b449e344c0206c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=34e81b5a0fc58ec481f82ad985b449e344c0206c", "patch": "@@ -31,6 +31,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"except.h\"\n #include \"function.h\"\n #include \"insn-config.h\"\n+#include \"insn-attr.h\"\n /* Include expr.h after insn-config.h so we get HAVE_conditional_move.  */\n #include \"expr.h\"\n #include \"optabs.h\"\n@@ -5653,6 +5654,22 @@ force_operand (value, target)\n       /* We give UNSIGNEDP = 0 to expand_binop\n \t because the only operations we are expanding here are signed ones.  */\n     }\n+\n+#ifdef INSN_SCHEDULING\n+  /* On machines that have insn scheduling, we want all memory reference to be\n+     explicit, so we need to deal with such paradoxical SUBREGs.  */\n+  if (GET_CODE (value) == SUBREG && GET_CODE (SUBREG_REG (value)) == MEM\n+      && (GET_MODE_SIZE (GET_MODE (value))\n+\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (value)))))\n+    value\n+      = simplify_gen_subreg (GET_MODE (value),\n+\t\t\t     force_reg (GET_MODE (SUBREG_REG (value)),\n+\t\t\t\t\tforce_operand (SUBREG_REG (value),\n+\t\t\t\t\t\t       NULL_RTX)),\n+\t\t\t     GET_MODE (SUBREG_REG (value)),\n+\t\t\t     SUBREG_BYTE (value));\n+#endif\n+\n   return value;\n }\n \f\n@@ -5982,15 +5999,15 @@ highest_pow2_factor (exp)\n   switch (TREE_CODE (exp))\n     {\n     case INTEGER_CST:\n-      /* If the integer is expressable in a HOST_WIDE_INT, we can find\n-\t the lowest bit that's a one.  If the result is zero or negative,\n-\t pessimize by returning 1.  This is overly-conservative, but such\n-\t things should not happen in the offset expressions that we are\n-\t called with.  */\n+      /* If the integer is expressable in a HOST_WIDE_INT, we can find the\n+\t lowest bit that's a one.  If the result is zero, pessimize by\n+\t returning 1.  This is overly-conservative, but such things should not\n+\t happen in the offset expressions that we are called with.  */\n       if (host_integerp (exp, 0))\n \t{\n \t  c0 = tree_low_cst (exp, 0);\n-\t  return c0 >= 0 ? c0 & -c0 : 1;\n+\t  c0 = c0 < 0 ? - c0 : c0;\n+\t  return c0 != 0 ? c0 & -c0 : 1;\n \t}\n       break;\n \n@@ -7065,7 +7082,6 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t\t       | TYPE_QUAL_CONST));\n \t\t    rtx memloc = assign_temp (nt, 1, 1, 1);\n \n-\t\t    mark_temp_addr_taken (memloc);\n \t\t    emit_move_insn (memloc, op0);\n \t\t    op0 = memloc;\n \t\t  }\n@@ -8619,10 +8635,6 @@ expand_expr (exp, target, tmode, modifier)\n       return expand_increment (exp, ! ignore, ignore);\n \n     case ADDR_EXPR:\n-      /* If nonzero, TEMP will be set to the address of something that might\n-\t be a MEM corresponding to a stack slot.  */\n-      temp = 0;\n-\n       /* Are we taking the address of a nested function?  */\n       if (TREE_CODE (TREE_OPERAND (exp, 0)) == FUNCTION_DECL\n \t  && decl_function_context (TREE_OPERAND (exp, 0)) != 0\n@@ -8670,12 +8682,6 @@ expand_expr (exp, target, tmode, modifier)\n \t  if (CONSTANT_P (op0))\n \t    op0 = force_const_mem (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))),\n \t\t\t\t   op0);\n-\t  else if (GET_CODE (op0) == MEM)\n-\t    {\n-\t      mark_temp_addr_taken (op0);\n-\t      temp = XEXP (op0, 0);\n-\t    }\n-\n \t  else if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n \t\t   || GET_CODE (op0) == CONCAT || GET_CODE (op0) == ADDRESSOF\n \t\t   || GET_CODE (op0) == PARALLEL)\n@@ -8688,28 +8694,29 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t\t       | TYPE_QUAL_CONST));\n \t      rtx memloc = assign_temp (nt, 1, 1, 1);\n \n-\t      mark_temp_addr_taken (memloc);\n \t      if (GET_CODE (op0) == PARALLEL)\n \t\t/* Handle calls that pass values in multiple non-contiguous\n \t\t   locations.  The Irix 6 ABI has examples of this.  */\n \t\temit_group_store (memloc, op0, int_size_in_bytes (inner_type));\n \t      else\n \t\temit_move_insn (memloc, op0);\n+\n \t      op0 = memloc;\n \t    }\n \n \t  if (GET_CODE (op0) != MEM)\n \t    abort ();\n \n+\t  mark_temp_addr_taken (op0);\n \t  if (modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER)\n \t    {\n-\t      temp = XEXP (op0, 0);\n+\t      op0 = XEXP (op0, 0);\n #ifdef POINTERS_EXTEND_UNSIGNED\n-\t      if (GET_MODE (temp) == Pmode && GET_MODE (temp) != mode\n+\t      if (GET_MODE (op0) == Pmode && GET_MODE (op0) != mode\n \t\t  && mode == ptr_mode)\n-\t\ttemp = convert_memory_address (ptr_mode, temp);\n+\t\top0 = convert_memory_address (ptr_mode, op0);\n #endif\n-\t      return temp;\n+\t      return op0;\n \t    }\n \n \t  op0 = force_operand (XEXP (op0, 0), target);\n@@ -8722,11 +8729,6 @@ expand_expr (exp, target, tmode, modifier)\n \t  && ! REG_USERVAR_P (op0))\n \tmark_reg_pointer (op0, TYPE_ALIGN (TREE_TYPE (type)));\n \n-      /* If we might have had a temp slot, add an equivalent address\n-\t for it.  */\n-      if (temp != 0)\n-\tupdate_temp_slot_address (temp, op0);\n-\n #ifdef POINTERS_EXTEND_UNSIGNED\n       if (GET_MODE (op0) == Pmode && GET_MODE (op0) != mode\n \t  && mode == ptr_mode)\n@@ -9084,7 +9086,6 @@ expand_expr_unaligned (exp, palign)\n \t\t\t\t\t\t | TYPE_QUAL_CONST));\n \t\trtx memloc = assign_temp (nt, 1, 1, 1);\n \n-\t\tmark_temp_addr_taken (memloc);\n \t\temit_move_insn (memloc, op0);\n \t\top0 = memloc;\n \t      }"}]}