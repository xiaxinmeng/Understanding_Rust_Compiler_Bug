{"sha": "7a80182693f336b67212ca927e8d7307dff2f737", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E4MDE4MjY5M2YzMzZiNjcyMTJjYTkyN2U4ZDczMDdkZmYyZjczNw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1997-05-08T22:17:34Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1997-05-08T22:17:34Z"}, "message": "(TARGET_CPU_arm*, TARGET_CPU_strongarm*, TARGET_CPU_generic):\n\ndefine.\n(CPP_ARCH_DEFAULT_SPEC): Set up based on setting of TARGET_CPU_DEFAULT.\n(CPP_SPEC): Split up into sub-rule calls.\n(CPP_CPU_SPEC): Add default definition.\n(CPP_APCS_PC_SPEC, CPP_APCS_PC_DEFAULT_SPEC): Add definitions.\n(CPP_FLOAT_SPEC, CPP_FLOAT_DEFAULT_SPEC): Add definitions.\n(CPP_ENDIAN_SPEC, CPP_ENDIAN_DEFAULT_SPEC): Add definitions.\n(CC1_SPEC): Map legacy -m[236] onto -mcpu=.. and -mapcs-{26,32} as\nappropriate. Similarly for -mbe and -mle to -m{big,little}-endian.\n(EXTRA_SPECS): Define.\n(enum processor_type): New types for arm8 and strongarm.\n(CONDITIONAL_REGISTER_USAGE): Handle flag_pic.\n(LEGITIMIZE_ADDRESS): Likewise.\n(ADJUST_COST): Define.\n(PIC_OFFSET_TABLE_REGNUM): Define.\n(FINALIZE_PIC): Define.\n(LEGITIMATE_PIC_OPERAND_P): Define.\n(OUTPUT_INT_ADDR_CONST): Define.\n(ASM_OUTPUT_MI_THUNK): Delete calls to arm_increase_location.\n(MASK_RETURN_ADDR): Use TARGET_APCS_32 not TARGET_6.\n\nFrom-SVN: r14051", "tree": {"sha": "925b830b7562b4fd276f54f32c237a9617bf8955", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/925b830b7562b4fd276f54f32c237a9617bf8955"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a80182693f336b67212ca927e8d7307dff2f737", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a80182693f336b67212ca927e8d7307dff2f737", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a80182693f336b67212ca927e8d7307dff2f737", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a80182693f336b67212ca927e8d7307dff2f737/comments", "author": null, "committer": null, "parents": [{"sha": "41d891aae027f21aeff5a02cddb698f8dcdac95c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41d891aae027f21aeff5a02cddb698f8dcdac95c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41d891aae027f21aeff5a02cddb698f8dcdac95c"}], "stats": {"total": 256, "additions": 229, "deletions": 27}, "files": [{"sha": "4a566d319fbbd57e9bbed38a171ff305b34b5b32", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 229, "deletions": 27, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a80182693f336b67212ca927e8d7307dff2f737/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a80182693f336b67212ca927e8d7307dff2f737/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=7a80182693f336b67212ca927e8d7307dff2f737", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for Acorn RISC Machine.\n-   Copyright (C) 1991, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n    and Martin Simmons (@harleqn.co.uk).\n    More major hacks by Richard Earnshaw (rwe11@cl.cam.ac.uk)\n@@ -29,7 +29,7 @@ Boston, MA 02111-1307, USA.  */\n    should default to that used by the OS.\n */\n \n-extern void output_func_prologue ();\n+\n extern void output_func_epilogue ();\n extern char *output_add_immediate ();\n extern char *output_call ();\n@@ -51,6 +51,33 @@ extern struct rtx_def *gen_compare_reg ();\n extern struct rtx_def *arm_gen_store_multiple ();\n extern struct rtx_def *arm_gen_load_multiple ();\n extern struct rtx_def *gen_rotated_half_load ();\n+extern int is_pic ();\n+#ifdef AOF_ASSEMBLER\n+extern struct rtx_def *aof_pic_entry ();\n+#endif\n+\n+#define TARGET_CPU_arm2\t\t0x0000\n+#define TARGET_CPU_arm250\t0x0000\n+#define TARGET_CPU_arm3\t\t0x0000\n+#define TARGET_CPU_arm6\t\t0x0001\n+#define TARGET_CPU_arm600\t0x0001\n+#define TARGET_CPU_arm610\t0x0002\n+#define TARGET_CPU_arm7\t\t0x0001\n+#define TARGET_CPU_arm7m\t0x0004\n+#define TARGET_CPU_arm7dm\t0x0004\n+#define TARGET_CPU_arm7dmi\t0x0004\n+#define TARGET_CPU_arm700\t0x0001\n+#define TARGET_CPU_arm710\t0x0002\n+#define TARGET_CPU_arm7100\t0x0002\n+#define TARGET_CPU_arm7500\t0x0002\n+#define TARGET_CPU_arm7500fe\t0x1001\n+#define TARGET_CPU_arm7tdmi\t0x0008\n+#define TARGET_CPU_arm8\t\t0x0010\n+#define TARGET_CPU_arm810\t0x0020\n+#define TARGET_CPU_strongarm\t0x0040\n+#define TARGET_CPU_strongarm110 0x0040\n+/* Configure didn't specify */\n+#define TARGET_CPU_generic\t0x8000\n \n enum arm_cond_code\n {\n@@ -66,25 +93,156 @@ extern char *arm_condition_codes[];\n extern int frame_pointer_needed;\n \n \f\n+/* Just in case configure has failed to define anything. */\n+#ifndef TARGET_CPU_DEFAULT\n+#define TARGET_CPU_DEFAULT TARGET_CPU_generic\n+#endif\n+\n+/* If the configuration file doesn't specify the cpu, the subtarget may\n+   override it.  If it doesn't, then default to an ARM6. */\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_generic\n+#undef TARGET_CPU_DEFAULT\n+#ifdef SUBTARGET_CPU_DEFAULT\n+#define TARGET_CPU_DEFAULT SUBTARGET_CPU_DEFAULT\n+#else\n+#define TARGET_CPU_DEFAULT TARGET_CPU_arm6\n+#endif\n+#endif\n+\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_arm2\n+#define CPP_ARCH_DEFAULT_SPEC \"-D__ARM_ARCH_2__\"\n+#else\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_arm6 || TARGET_CPU_DEFUALT == TARGET_CPU_arm610 || TARGET_CPU_DEFAULT == TARGET_CPU_arm7500fe\n+#define CPP_ARCH_DEFAULT_SPEC \"-D__ARM_ARCH_3__\"\n+#else\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_arm7m\n+#define CPP_ARCH_DEFAULT_SPEC \"-D__ARM_ARCH_3M__\"\n+#else\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_arm7tdmi\n+#define CPP_ARCH_DEFAULT_SPEC \"-D__ARM_ARCH_4T__\"\n+#else\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_arm8 || TARGET_CPU_DEFAULT == TARGET_CPU_arm810 || TARGET_CPU_DEFAULT == TARGET_CPU_strongarm\n+#define CPP_ARCH_DEFAULT_SPEC \"-D__ARM_ARCH_4__\"\n+#else\n+Unrecognized value in TARGET_CPU_DEFAULT.\n+#endif\n+#endif\n+#endif\n+#endif\n+#endif\n+\n #ifndef CPP_PREDEFINES\n #define CPP_PREDEFINES  \"-Darm -Acpu(arm) -Amachine(arm)\"\n #endif\n \n-#ifndef CPP_SPEC\n-#define CPP_SPEC \"%{m6:-D__arm6__} \\\n-%{mcpu-*:-D__%*} \\\n-%{mcpu=*:-D__%*} \\\n-%{mapcs-32:-D__APCS_32__ -U__APCS_26__} \\\n-%{mapcs-26:-D__APCS_26__ -U__APCS_32__} \\\n-%{!mapcs-32: %{!mapcs-26:-D__APCS_26__}} \\\n-%{msoft-float:-D__SOFTFP__} \\\n-%{mhard-float:-U__SOFTFP__} \\\n-%{!mhard-float: %{!msoft-float:-U__SOFTFP__}} \\\n-%{mbig-endian:-D__ARMEB__ %{mwords-little-endian:-D__ARMWEL__}} \\\n-%{mbe:-D__ARMEB__ %{mwords-little-endian:-D__ARMWEL__}} \\\n-%{!mbe: %{!mbig-endian:-D__ARMEL__}} \\\n+#define CPP_SPEC \"%(cpp_cpu_arch) %(cpp_apcs_pc) %(cpp_float) %(cpp_enidan)\"\n+\n+#define CPP_CPU_ARCH_SPEC \"\\\n+%{m2:-D__arm2__ -D__ARM_ARCH_2__} \\\n+%{m3:-D__arm2__ -D__ARM_ARCH_2__} \\\n+%{m6:-D__arm6__ -D__ARM_ARCH_3__} \\\n+%{mcpu=arm2:-D__ARM_ARCH_2__} \\\n+%{mcpu=arm250:-D__ARM_ARCH_2__} \\\n+%{mcpu=arm3:-D__ARM_ARCH_2__} \\\n+%{mcpu=arm6:-D__ARM_ARCH_3__} \\\n+%{mcpu=arm600:-D__ARM_ARCH_3__} \\\n+%{mcpu=arm610:-D__ARM_ARCH_3__} \\\n+%{mcpu=arm7:-D__ARM_ARCH_3__} \\\n+%{mcpu=arm700:-D__ARM_ARCH_3__} \\\n+%{mcpu=arm710:-D__ARM_ARCH_3__} \\\n+%{mcpu=arm7100:-D__ARM_ARCH_3__} \\\n+%{mcpu=arm7500:-D__ARM_ARCH_3__} \\\n+%{mcpu=arm7500fe:-D__ARM_ARCH_3__} \\\n+%{mcpu=arm7m:-D__ARM_ARCH_3M__} \\\n+%{mcpu=arm7dm:-D__ARM_ARCH_3M__} \\\n+%{mcpu=arm7dmi:-D__ARM_ARCH_3M__} \\\n+%{mcpu=arm7tdmi:-D__ARM_ARCH_4T__} \\\n+%{mcpu=arm8:-D__ARM_ARCH_4__} \\\n+%{mcpu=arm810:-D__ARM_ARCH_4__} \\\n+%{mcpu=strongarm:-D__ARM_ARCH_4__} \\\n+%{mcpu=strongarm110:-D__ARM_ARCH_4__} \\\n+%{!mcpu*:%{!m6:%{!m2:%{!m3:%(cpp_cpu_arch_default)}}}} \\\n \"\n-#endif\n+\n+/* Define __APCS_26__ if the PC also contains the PSR */\n+/* This also examines deprecated -m[236] if neither of -mapcs-{26,32} is set,\n+   ??? Delete this for 2.9.  */\n+#define CPP_APCS_PC_SPEC \"\\\n+%{mapcs-32:%{mapcs-26:%e-mapcs-26 and -mapcs-32 may not be used together} \\\n+ -D__APCS_32__} \\\n+%{mapcs-26:-D__APCS_26__} \\\n+%{!mapcs-32: %{!mapcs-26:%{m6:-D__APCS_32__} %{m2:-D__APCS_26__} \\\n+ %{m3:-D__APCS_26__} %{!m6:%{!m3:%{!m2:%(cpp_apcs_pc_default)}}}}} \\\n+\"\n+\n+#define CPP_APCS_PC_DEFAULT_SPEC \"-D__APCS_26__\"\n+\n+#define CPP_FLOAT_SPEC \"\\\n+%{msoft-float:\\\n+  %{mhard-float:%e-msoft-float and -mhard_float may not be used together} \\\n+  -D__SOFTFP__} \\\n+%{!mhard-float:%{!msoft-float:%(cpp_float_default)}} \\\n+\"\n+\n+/* Default is hard float, which doesn't define anything */\n+#define CPP_FLOAT_DEFAULT_SPEC \"\"\n+\n+#define CPP_ENDIAN_SPEC \"\\\n+%{mbig-endian: \\\n+  %{mlittle-endian: \\\n+    %e-mbig-endian and -mlittle-endian may not be used together} \\\n+  -D__ARMEB__ %{mwords-little-endian:-D__ARMWEL__} \\\n+  %{mle: \\\n+    %e-mbig-endian and -mle may not be used together} \\\n+  -D__ARMEB__ %{mwords-little-endian:-D__ARMWEL__}} \\\n+%{mbe: \\\n+  %{mlittle-endian: \\\n+    %e-mbe and -mlittle-endian may not be used together} \\\n+  -D__ARMEB__ %{mwords-little-endian:-D__ARMWEL__} \\\n+  %{mle: \\\n+    %e-mbe and -mle may not be used together} \\\n+  -D__ARMEB__ %{mwords-little-endian:-D__ARMWEL__}} \\\n+%{!mlittle-endian:%{!mbig-endian:%{!mbe:%{!mle:%(cpp_endian_default)}}}} \\\n+\"\n+\n+/* Default is little endian, which doesn't define anything. */\n+#define CPP_ENDIAN_DEFAULT_SPEC \"\"\n+\n+/* Translate (for now) the old -m[236] option into the appropriate -mcpu=...\n+   and -mapcs-xx equivalents. \n+   ??? Remove support for this style in 2.9.\n+   Also handle -mbe and -mle by expanding them into big-endian and\n+   little-endian.  */\n+#define CC1_SPEC \"\\\n+%{m2:-mcpu=arm2 -mapcs-26} \\\n+%{m3:-mcpu=arm3 -mapcs-26} \\\n+%{m6:-mcpu=arm6 -mapcs-32} \\\n+%{mbe:-mbig-endian} \\\n+%{mle:-mlittle-endian} \\\n+\"\n+\n+/* This macro defines names of additional specifications to put in the specs\n+   that can be used in various specifications like CC1_SPEC.  Its definition\n+   is an initializer with a subgrouping for each command option.\n+\n+   Each subgrouping contains a string constant, that defines the\n+   specification name, and a string constant that used by the GNU CC driver\n+   program.\n+\n+   Do not define this macro if it does not need to do anything.  */\n+#define EXTRA_SPECS\t\t\t\t\t\t\\\n+  { \"cpp_cpu_arch\",\t\tCPP_CPU_ARCH_SPEC },\t\t\\\n+  { \"cpp_cpu_arch_default\",\tCPP_ARCH_DEFAULT_SPEC },\t\\\n+  { \"cpp_apcs_pc\",\t\tCPP_APCS_PC_SPEC },\t\t\\\n+  { \"cpp_apcs_pc_default\",\tCPP_APCS_PC_DEFAULT_SPEC },\t\\\n+  { \"cpp_float\",\t\tCPP_FLOAT_SPEC },\t\t\\\n+  { \"cpp_float_default\",\tCPP_FLOAT_DEFAULT_SPEC },\t\\\n+  { \"cpp_endian\",\t\tCPP_ENDIAN_SPEC },\t\t\\\n+  { \"cpp_endian_default\",\tCPP_ENDIAN_DEFAULT_SPEC },\t\\\n+  SUBTARGET_EXTRA_SPECS\n+\n+#define SUBTARGET_EXTRA_SPECS\n+\n \f\n /* Run-time Target Specification.  */\n #ifndef TARGET_VERSION\n@@ -243,7 +401,9 @@ enum processor_type\n   PROCESSOR_ARM2,\n   PROCESSOR_ARM3,\n   PROCESSOR_ARM6,\n-  PROCESSOR_ARM7\n+  PROCESSOR_ARM7,\n+  PROCESSOR_ARM8,\n+  PROCESSOR_STARM\n };\n \n /* Recast the cpu class to be the cpu attribute. */\n@@ -513,6 +673,11 @@ extern int arm_arch4;\n       for (regno = 16; regno < 24; ++regno)\t\t\\\n \tfixed_regs[regno] = call_used_regs[regno] = 1;\t\\\n     }\t\t\t\t\t\t\t\\\n+  if (flag_pic)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n+      call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 0;\t\\\n+    }\t\t\t\t\t\t\t\\\n }\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n@@ -678,12 +843,13 @@ enum reg_class\n    address.  This means that the symbol is in the text segment and can be\n    accessed without using a load. */\n \n-#define EXTRA_CONSTRAINT(OP, C)                                         \\\n-  ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG  \\\n-   : (C) == 'R' ? (GET_CODE (OP) == MEM\t\t\t\t\t\\\n-\t\t   && GET_CODE (XEXP (OP, 0)) == SYMBOL_REF\t\t\\\n-\t\t   && CONSTANT_POOL_ADDRESS_P (XEXP (OP, 0)))\t\t\\\n-   : (C) == 'S' ? (optimize > 0 && CONSTANT_ADDRESS_P (OP)) : 0)\n+#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\t\t    \\\n+  ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG\t    \\\n+   : (C) == 'R' ? (GET_CODE (OP) == MEM\t\t\t\t\t    \\\n+\t\t   && GET_CODE (XEXP (OP, 0)) == SYMBOL_REF\t\t    \\\n+\t\t   && CONSTANT_POOL_ADDRESS_P (XEXP (OP, 0)))\t\t    \\\n+   : (C) == 'S' ? (optimize > 0 && CONSTANT_ADDRESS_P (OP))\t\t    \\\n+   : 0)\n \n /* Constant letter 'G' for the FPU immediate constants. \n    'H' means the same constant negated.  */\n@@ -876,7 +1042,7 @@ enum reg_class\n   output_func_prologue ((STREAM), (SIZE))\n \n /* Call the function profiler with a given profile label.  The Acorn compiler\n-   puts this BEFORE the prolog but gcc pust it afterwards.  The ``mov ip,lr''\n+   puts this BEFORE the prolog but gcc puts it afterwards.  The ``mov ip,lr''\n    seems like a good idea to stick with cc convention.  ``prof'' doesn't seem\n    to mind about this!  */\n #define FUNCTION_PROFILER(STREAM,LABELNO)  \t\t\t\t    \\\n@@ -1082,6 +1248,7 @@ enum reg_class\n     }\t\t\t\t\t\t\t\t\t\\\n }\n #endif\n+\n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n    We have two alternate definitions for each of them.\n@@ -1261,6 +1428,7 @@ do\t\t\t\t\t\t\t\t\t\\\n    On the ARM, try to convert [REG, #BIGCONST]\n    into ADD BASE, REG, #UPPERCONST and [BASE, #VALIDCONST],\n    where VALIDCONST == 0 in case of TImode.  */\n+extern struct rtx_def *legitimize_pic_address ();\n #define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t \\\n {\t\t\t\t\t\t\t\t\t \\\n   if (GET_CODE (X) == PLUS)\t\t\t\t\t\t \\\n@@ -1316,6 +1484,8 @@ do\t\t\t\t\t\t\t\t\t\\\n       if (xop0 != XEXP (X, 0) || xop1 != XEXP (X, 1))\t\t\t \\\n \t(X) = gen_rtx (MINUS, SImode, xop0, xop1);\t\t\t \\\n     }\t\t\t\t\t\t\t\t\t \\\n+  if (flag_pic)\t\t\t\t\t\t\t\t \\\n+    (X) = legitimize_pic_address (OLDX, MODE, NULL_RTX);\t\t \\\n   if (memory_address_p (MODE, X))\t\t\t\t\t \\\n     goto WIN;\t\t\t\t\t\t\t\t \\\n }\n@@ -1468,6 +1638,27 @@ do\t\t\t\t\t\t\t\t\t\\\n /* Try to generate sequences that don't involve branches, we can then use\n    conditional instructions */\n #define BRANCH_COST 4\n+\n+/* A C statement to update the variable COST based on the relationship\n+   between INSN that is dependent on DEP through dependence LINK.  */\n+#define ADJUST_COST(INSN,LINK,DEP,COST) \\\n+  (COST) = arm_adjust_cost ((INSN), (LINK), (DEP), (COST))\n+\f\n+/* Position Independent Code.  */\n+/* We decide which register to use based on the compilation options and\n+   the assembler in use; this is more general than the APCS restriction of\n+   using sb (r9) all the time.  */\n+extern int arm_pic_register;\n+\n+/* The register number of the register used to address a table of static\n+   data addresses in memory.  */\n+#define PIC_OFFSET_TABLE_REGNUM arm_pic_register\n+\n+#define FINALIZE_PIC arm_finalize_pic ()\n+\n+#define LEGITIMATE_PIC_OPERAND_P(X) (! symbol_mentioned_p (X))\n+ \n+\n \f\n /* Condition code information. */\n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n@@ -1690,6 +1881,19 @@ extern int arm_compare_fp;\n   else output_addr_const(STREAM, X);\t\t\t\t\t\\\n }\n \n+/* Handles PIC addr specially */\n+#define OUTPUT_INT_ADDR_CONST(STREAM,X) \\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (flag_pic && GET_CODE(X) == CONST && is_pic(X))\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\toutput_addr_const(STREAM, XEXP (XEXP (XEXP (X, 0), 0), 0));\t\\\n+\tfputs(\" - (\", STREAM);\t\t\t\t\t\t\\\n+\toutput_addr_const(STREAM, XEXP (XEXP (XEXP (X, 0), 1), 0));\t\\\n+\tfputs(\")\", STREAM);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else output_addr_const(STREAM, X);\t\t\t\t\t\\\n+  }\n+\n /* Output code to add DELTA to the first argument, and then jump to FUNCTION.\n    Used for C++ multiple inheritance.  */\n #define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION)\t\\\n@@ -1710,14 +1914,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t\t   mi_op, REGISTER_PREFIX, reg_names[this_regno],\t\\\n \t\t   REGISTER_PREFIX, reg_names[this_regno],\t\t\\\n \t\t   mi_delta & (0xff << shift));\t\t\t\t\\\n-\t  arm_increase_location (4);\t\t\t\t\t\\\n \t  mi_delta &= ~(0xff << shift);\t\t\t\t\t\\\n \t  shift += 8;\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   fprintf (FILE, \"\\tldr\\t%spc, [%spc, #-4]\\n\", REGISTER_PREFIX,\t\t\\\n \t   REGISTER_PREFIX);\t\t\t\t\t\t\\\n-  arm_increase_location (4);\t\t\t\t\t\t\\\n   ASM_OUTPUT_INT (FILE, XEXP (DECL_RTL (FUNCTION), 0));\t\t\t\\\n } while (0)\n \n@@ -1736,4 +1938,4 @@ do {\t\t\t\t\t\t\t\t\t\\\n      in 26 bit mode, the condition codes must be masked out of the\t\\\n      return address.  This does not apply to ARM6 and later processors\t\\\n      when running in 32 bit mode.  */\t\t\t\t\t\\\n-  ((!TARGET_6) ? (GEN_INT (0x03fffffc)) : (GEN_INT (0xffffffff)))\n+  ((!TARGET_APCS_32) ? (GEN_INT (0x03fffffc)) : (GEN_INT (0xffffffff)))"}]}