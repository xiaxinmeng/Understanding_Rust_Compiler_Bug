{"sha": "a929f2662ef33c06ad5b41f2a3df0c0833bbc405", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTkyOWYyNjYyZWYzM2MwNmFkNWI0MWYyYTNkZjBjMDgzM2JiYzQwNQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2016-10-17T22:08:56Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2016-10-17T22:08:56Z"}, "message": "re PR tree-optimization/77916 (ICE in verify_gimple_in_cfg: invalid (pointer) operands to plus/minus)\n\n[gcc]\n\n2016-10-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR tree-optimization/77916\n\t* gimple-ssa-strength-reduction.c (create_add_on_incoming_edge):\n\tDon't allow a MINUS_EXPR for pointer arithmetic for either known\n\tor unknown strides.\n\t(record_increment): Increments of -1 for unknown strides just use\n\ta multiply initializer like other negative values.\n\t(analyze_increments): Remove stopgap solution for -1 increment\n\tapplied to pointer arithmetic.\n\n[gcc/testsuite]\n\n2016-10-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR tree-optimization/77916\n\t* gcc.dg/torture/pr77916.c: New.\n\nFrom-SVN: r241281", "tree": {"sha": "34319a35592833a44e76589fd700c44a0534b9e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34319a35592833a44e76589fd700c44a0534b9e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a929f2662ef33c06ad5b41f2a3df0c0833bbc405", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a929f2662ef33c06ad5b41f2a3df0c0833bbc405", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a929f2662ef33c06ad5b41f2a3df0c0833bbc405", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a929f2662ef33c06ad5b41f2a3df0c0833bbc405/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4acf205523e33923a55d542aca44c2670e970a3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4acf205523e33923a55d542aca44c2670e970a3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4acf205523e33923a55d542aca44c2670e970a3a"}], "stats": {"total": 67, "additions": 53, "deletions": 14}, "files": [{"sha": "89a03e90c51f48383b115e8d8355f4bc42cb506c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a929f2662ef33c06ad5b41f2a3df0c0833bbc405/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a929f2662ef33c06ad5b41f2a3df0c0833bbc405/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a929f2662ef33c06ad5b41f2a3df0c0833bbc405", "patch": "@@ -1,3 +1,14 @@\n+2016-10-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/77916\n+\t* gimple-ssa-strength-reduction.c (create_add_on_incoming_edge):\n+\tDon't allow a MINUS_EXPR for pointer arithmetic for either known\n+\tor unknown strides.\n+\t(record_increment): Increments of -1 for unknown strides just use\n+\ta multiply initializer like other negative values.\n+\t(analyze_increments): Remove stopgap solution for -1 increment\n+\tapplied to pointer arithmetic.\n+\n 2016-10-17  Yuri Rumyantsev  <ysrumyan@gmail.com>\n \n \t* dominance.c (dom_info::dom_info): Add new constructor for region"}, {"sha": "2ef5c482582abce154a6a4020e737e10e732fa3c", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a929f2662ef33c06ad5b41f2a3df0c0833bbc405/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a929f2662ef33c06ad5b41f2a3df0c0833bbc405/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=a929f2662ef33c06ad5b41f2a3df0c0833bbc405", "patch": "@@ -2154,35 +2154,41 @@ create_add_on_incoming_edge (slsr_cand_t c, tree basis_name,\n   basis_type = TREE_TYPE (basis_name);\n   lhs = make_temp_ssa_name (basis_type, NULL, \"slsr\");\n \n+  /* Occasionally people convert integers to pointers without a \n+     cast, leading us into trouble if we aren't careful.  */\n+  enum tree_code plus_code\n+    = POINTER_TYPE_P (basis_type) ? POINTER_PLUS_EXPR : PLUS_EXPR;\n+\n   if (known_stride)\n     {\n       tree bump_tree;\n-      enum tree_code code = PLUS_EXPR;\n+      enum tree_code code = plus_code;\n       widest_int bump = increment * wi::to_widest (c->stride);\n-      if (wi::neg_p (bump))\n+      if (wi::neg_p (bump) && !POINTER_TYPE_P (basis_type))\n \t{\n \t  code = MINUS_EXPR;\n \t  bump = -bump;\n \t}\n \n-      bump_tree = wide_int_to_tree (basis_type, bump);\n+      tree stride_type = POINTER_TYPE_P (basis_type) ? sizetype : basis_type;\n+      bump_tree = wide_int_to_tree (stride_type, bump);\n       new_stmt = gimple_build_assign (lhs, code, basis_name, bump_tree);\n     }\n   else\n     {\n       int i;\n-      bool negate_incr = (!address_arithmetic_p && wi::neg_p (increment));\n+      bool negate_incr = !POINTER_TYPE_P (basis_type) && wi::neg_p (increment);\n       i = incr_vec_index (negate_incr ? -increment : increment);\n       gcc_assert (i >= 0);\n \n       if (incr_vec[i].initializer)\n \t{\n-\t  enum tree_code code = negate_incr ? MINUS_EXPR : PLUS_EXPR;\n+\t  enum tree_code code = negate_incr ? MINUS_EXPR : plus_code;\n \t  new_stmt = gimple_build_assign (lhs, code, basis_name,\n \t\t\t\t\t  incr_vec[i].initializer);\n \t}\n       else if (increment == 1)\n-\tnew_stmt = gimple_build_assign (lhs, PLUS_EXPR, basis_name, c->stride);\n+\tnew_stmt = gimple_build_assign (lhs, plus_code, basis_name, c->stride);\n       else if (increment == -1)\n \tnew_stmt = gimple_build_assign (lhs, MINUS_EXPR, basis_name,\n \t\t\t\t\tc->stride);\n@@ -2500,12 +2506,14 @@ record_increment (slsr_cand_t c, widest_int increment, bool is_phi_adjust)\n       /* Optimistically record the first occurrence of this increment\n \t as providing an initializer (if it does); we will revise this\n \t opinion later if it doesn't dominate all other occurrences.\n-         Exception:  increments of -1, 0, 1 never need initializers;\n-\t and phi adjustments don't ever provide initializers.  */\n+         Exception:  increments of 0, 1 never need initializers;\n+\t and phi adjustments don't ever provide initializers.  Note\n+         that we only will see an increment of -1 here for pointer\n+\t arithmetic (otherwise we will have an initializer).  */\n       if (c->kind == CAND_ADD\n \t  && !is_phi_adjust\n \t  && c->index == increment\n-\t  && (increment > 1 || increment < -1)\n+\t  && (increment > 1 || increment < 0)\n \t  && (gimple_assign_rhs_code (c->cand_stmt) == PLUS_EXPR\n \t      || gimple_assign_rhs_code (c->cand_stmt) == POINTER_PLUS_EXPR))\n \t{\n@@ -2819,11 +2827,6 @@ analyze_increments (slsr_cand_t first_dep, machine_mode mode, bool speed)\n \t\t   && !POINTER_TYPE_P (first_dep->cand_type)))\n \tincr_vec[i].cost = COST_NEUTRAL;\n \n-      /* FIXME: We don't handle pointers with a -1 increment yet.\n-         They are usually unprofitable anyway.  */\n-      else if (incr == -1 && POINTER_TYPE_P (first_dep->cand_type))\n-\tincr_vec[i].cost = COST_INFINITE;\n-      \n       /* FORNOW: If we need to add an initializer, give up if a cast from\n \t the candidate's type to its stride's type can lose precision.\n \t This could eventually be handled better by expressly retaining the"}, {"sha": "ddad6fc9a8925843cc04b9bcab4a59e78eb00411", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a929f2662ef33c06ad5b41f2a3df0c0833bbc405/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a929f2662ef33c06ad5b41f2a3df0c0833bbc405/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a929f2662ef33c06ad5b41f2a3df0c0833bbc405", "patch": "@@ -1,3 +1,8 @@\n+2016-10-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/77916\n+\t* gcc.dg/torture/pr77916.c: New.\n+\n 2016-10-17  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/77978"}, {"sha": "f29f099d58624f61a3285ae10ace4e0271605487", "filename": "gcc/testsuite/gcc.dg/torture/pr77916.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a929f2662ef33c06ad5b41f2a3df0c0833bbc405/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr77916.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a929f2662ef33c06ad5b41f2a3df0c0833bbc405/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr77916.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr77916.c?ref=a929f2662ef33c06ad5b41f2a3df0c0833bbc405", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -Wno-int-conversion\" } */\n+\n+/* PR77916: This failed with \"error: invalid (pointer) operands to plus/minus\"\n+   after SLSR.  */\n+\n+typedef struct\n+{\n+  void *f1;\n+} S;\n+\n+S *a;\n+int b;\n+\n+void\n+fn1 (void)\n+{\n+  for (; b; b++, a++)\n+    a->f1 = b;\n+}"}]}