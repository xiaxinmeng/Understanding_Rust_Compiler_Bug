{"sha": "3520f7cc6987fc79ae688ebe532f6242f743355d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUyMGY3Y2M2OTg3ZmM3OWFlNjg4ZWJlNTMyZjYyNDJmNzQzMzU1ZA==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2013-01-07T15:22:06Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2013-01-07T15:22:06Z"}, "message": "[AARCH64] Add support for vector and scalar floating-point immediate loads.\n\ngcc/\n\n\t* config/aarch64/aarch64-protos.h\n\t(aarch64_const_double_zero_rtx_p): Rename to...\n\t(aarch64_float_const_zero_rtx_p): ...this.\n\t(aarch64_float_const_representable_p): New.\n\t(aarch64_output_simd_mov_immediate): Likewise.\n\t* config/aarch64/aarch64-simd.md (*aarch64_simd_mov<mode>): Refactor\n\tmove immediate case.\n\t* config/aarch64/aarch64.c\n\t(aarch64_const_double_zero_rtx_p): Rename to...\n\t(aarch64_float_const_zero_rtx_p): ...this.\n\t(aarch64_print_operand): Allow printing of new constants.\n\t(aarch64_valid_floating_const): New.\n\t(aarch64_legitimate_constant_p): Check for valid floating-point\n\tconstants.\n\t(aarch64_simd_valid_immediate): Likewise.\n\t(aarch64_vect_float_const_representable_p): New.\n\t(aarch64_float_const_representable_p): Likewise.\n\t(aarch64_simd_imm_zero_p): Also allow for floating-point 0.0.\n\t(aarch64_output_simd_mov_immediate): New.\n\t* config/aarch64/aarch64.md (*movsf_aarch64): Add new alternative.\n\t(*movdf_aarch64): Likewise.\n\t* config/aarch64/constraints.md (Ufc): New.\n\t(Y): call aarch64_float_const_zero_rtx.\n\t* config/aarch64/predicates.md (aarch64_fp_compare_operand): New.\n\ngcc/testsuite/\n\n\t* gcc.target/aarch64/fmovd.c: New.\n\t* gcc.target/aarch64/fmovf.c: Likewise.\n\t* gcc.target/aarch64/fmovd-zero.c: Likewise.\n\t* gcc.target/aarch64/fmovf-zero.c: Likewise.\n\t* gcc.target/aarch64/vect-fmovd.c: Likewise.\n\t* gcc.target/aarch64/vect-fmovf.c: Likewise.\n\t* gcc.target/aarch64/vect-fmovd-zero.c: Likewise.\n\t* gcc.target/aarch64/vect-fmovf-zero.c: Likewise.\n\nFrom-SVN: r194972", "tree": {"sha": "ca823d5616cfead4bce12e22af35db3e1f5ddd9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca823d5616cfead4bce12e22af35db3e1f5ddd9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3520f7cc6987fc79ae688ebe532f6242f743355d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3520f7cc6987fc79ae688ebe532f6242f743355d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3520f7cc6987fc79ae688ebe532f6242f743355d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3520f7cc6987fc79ae688ebe532f6242f743355d/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e167c04d0610b49fe27420e71123d7dbba98bde0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e167c04d0610b49fe27420e71123d7dbba98bde0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e167c04d0610b49fe27420e71123d7dbba98bde0"}], "stats": {"total": 547, "additions": 452, "deletions": 95}, "files": [{"sha": "7933c600f05b14f2b15d6b43e2c2044c585b91a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3520f7cc6987fc79ae688ebe532f6242f743355d", "patch": "@@ -1,3 +1,30 @@\n+2013-01-07  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h\n+\t(aarch64_const_double_zero_rtx_p): Rename to...\n+\t(aarch64_float_const_zero_rtx_p): ...this.\n+\t(aarch64_float_const_representable_p): New.\n+\t(aarch64_output_simd_mov_immediate): Likewise.\n+\t* config/aarch64/aarch64-simd.md (*aarch64_simd_mov<mode>): Refactor\n+\tmove immediate case.\n+\t* config/aarch64/aarch64.c\n+\t(aarch64_const_double_zero_rtx_p): Rename to...\n+\t(aarch64_float_const_zero_rtx_p): ...this.\n+\t(aarch64_print_operand): Allow printing of new constants.\n+\t(aarch64_valid_floating_const): New.\n+\t(aarch64_legitimate_constant_p): Check for valid floating-point\n+\tconstants.\n+\t(aarch64_simd_valid_immediate): Likewise.\n+\t(aarch64_vect_float_const_representable_p): New.\n+\t(aarch64_float_const_representable_p): Likewise.\n+\t(aarch64_simd_imm_zero_p): Also allow for floating-point 0.0.\n+\t(aarch64_output_simd_mov_immediate): New.\n+\t* config/aarch64/aarch64.md (*movsf_aarch64): Add new alternative.\n+\t(*movdf_aarch64): Likewise.\n+\t* config/aarch64/constraints.md (Ufc): New.\n+\t(Y): call aarch64_float_const_zero_rtx.\n+\t* config/aarch64/predicates.md (aarch64_fp_compare_operand): New.\n+\n 2013-01-07  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/55888"}, {"sha": "ba96cd66618acb1404dd1af04e4250b64a99a67b", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=3520f7cc6987fc79ae688ebe532f6242f743355d", "patch": "@@ -136,8 +136,8 @@ struct tune_params\n \n HOST_WIDE_INT aarch64_initial_elimination_offset (unsigned, unsigned);\n bool aarch64_bitmask_imm (HOST_WIDE_INT val, enum machine_mode);\n-bool aarch64_const_double_zero_rtx_p (rtx);\n bool aarch64_constant_address_p (rtx);\n+bool aarch64_float_const_zero_rtx_p (rtx);\n bool aarch64_function_arg_regno_p (unsigned);\n bool aarch64_gen_movmemqi (rtx *);\n bool aarch64_is_extend_from_extract (enum machine_mode, rtx, rtx);\n@@ -215,6 +215,9 @@ void aarch64_split_128bit_move (rtx, rtx);\n \n bool aarch64_split_128bit_move_p (rtx, rtx);\n \n+/* Check for a legitimate floating point constant for FMOV.  */\n+bool aarch64_float_const_representable_p (rtx);\n+\n #if defined (RTX_CODE)\n \n bool aarch64_legitimate_address_p (enum machine_mode, rtx, RTX_CODE, bool);\n@@ -246,4 +249,5 @@ extern void aarch64_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel);\n extern bool\n aarch64_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel);\n \n+char* aarch64_output_simd_mov_immediate (rtx *, enum machine_mode, unsigned);\n #endif /* GCC_AARCH64_PROTOS_H */"}, {"sha": "d4b52c385a71019e07191f729f30d9bdbe339aa6", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 15, "deletions": 61, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=3520f7cc6987fc79ae688ebe532f6242f743355d", "patch": "@@ -394,34 +394,8 @@\n      case 4: return \"ins\\t%0.d[0], %1\";\n      case 5: return \"mov\\t%0, %1\";\n      case 6:\n-       {\n-\tint is_valid;\n-\tunsigned char widthc;\n-\tint width;\n-\tstatic char templ[40];\n-\tint shift = 0, mvn = 0;\n-\tconst char *mnemonic;\n-\tint length = 0;\n-\n-\tis_valid =\n-\t  aarch64_simd_immediate_valid_for_move (operands[1], <MODE>mode,\n-\t\t\t\t\t\t &operands[1], &width, &widthc,\n-\t\t\t\t\t\t &mvn, &shift);\n-\tgcc_assert (is_valid != 0);\n-\n-\tmnemonic = mvn ? \"mvni\" : \"movi\";\n-\tif (widthc != 'd')\n-\t  length += snprintf (templ, sizeof (templ),\n-\t\t\t      \"%s\\t%%0.%d%c, %%1\",\n-\t\t\t      mnemonic, 64 / width, widthc);\n-\telse\n-\t  length += snprintf (templ, sizeof (templ), \"%s\\t%%d0, %%1\", mnemonic);\n-\n-\tif (shift != 0)\n-\t  length += snprintf (templ + length, sizeof (templ) - length,\n-\t\t\t      \", lsl %d\", shift);\n-\treturn templ;\n-       }\n+\treturn aarch64_output_simd_mov_immediate (&operands[1],\n+\t\t\t\t\t\t  <MODE>mode, 64);\n      default: gcc_unreachable ();\n      }\n }\n@@ -438,39 +412,19 @@\n    && (register_operand (operands[0], <MODE>mode)\n        || register_operand (operands[1], <MODE>mode))\"\n {\n-   switch (which_alternative)\n-     {\n-     case 0: return \"ld1\\t{%0.<Vtype>}, %1\";\n-     case 1: return \"st1\\t{%1.<Vtype>}, %0\";\n-     case 2: return \"orr\\t%0.<Vbtype>, %1.<Vbtype>, %1.<Vbtype>\";\n-     case 3: return \"umov\\t%0, %1.d[0]\\;umov\\t%H0, %1.d[1]\";\n-     case 4: return \"ins\\t%0.d[0], %1\\;ins\\t%0.d[1], %H1\";\n-     case 5: return \"#\";\n-     case 6:\n-       {\n-\tint is_valid;\n-\tunsigned char widthc;\n-\tint width;\n-\tstatic char templ[40];\n-\tint shift = 0, mvn = 0;\n-\n-\tis_valid =\n-\t  aarch64_simd_immediate_valid_for_move (operands[1], <MODE>mode,\n-\t\t\t\t\t\t &operands[1], &width, &widthc,\n-\t\t\t\t\t\t &mvn, &shift);\n-\tgcc_assert (is_valid != 0);\n-\tif (shift)\n-\t  snprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, %%1, lsl %d\",\n-\t\t    mvn ? \"mvni\" : \"movi\",\n-\t\t    128 / width, widthc, shift);\n-\telse\n-\t  snprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, %%1\",\n-\t\t    mvn ? \"mvni\" : \"movi\",\n-\t\t    128 / width, widthc);\n-\treturn templ;\n-       }\n-     default: gcc_unreachable ();\n-     }\n+  switch (which_alternative)\n+    {\n+    case 0: return \"ld1\\t{%0.<Vtype>}, %1\";\n+    case 1: return \"st1\\t{%1.<Vtype>}, %0\";\n+    case 2: return \"orr\\t%0.<Vbtype>, %1.<Vbtype>, %1.<Vbtype>\";\n+    case 3: return \"umov\\t%0, %1.d[0]\\;umov\\t%H0, %1.d[1]\";\n+    case 4: return \"ins\\t%0.d[0], %1\\;ins\\t%0.d[1], %H1\";\n+    case 5: return \"#\";\n+    case 6:\n+\treturn aarch64_output_simd_mov_immediate (&operands[1],\n+\t\t\t\t\t\t  <MODE>mode, 128);\n+    default: gcc_unreachable ();\n+    }\n }\n   [(set_attr \"simd_type\" \"simd_load1,simd_store1,simd_move,simd_movgp,simd_insgp,simd_move,simd_move_imm\")\n    (set_attr \"simd_mode\" \"<MODE>\")"}, {"sha": "ba8287ff026a1e2d90ba1be6a22f185ad985405a", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 266, "deletions": 24, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=3520f7cc6987fc79ae688ebe532f6242f743355d", "patch": "@@ -3028,7 +3028,7 @@ aarch64_legitimate_address_p (enum machine_mode mode, rtx x,\n \n /* Return TRUE if rtx X is immediate constant 0.0 */\n bool\n-aarch64_const_double_zero_rtx_p (rtx x)\n+aarch64_float_const_zero_rtx_p (rtx x)\n {\n   REAL_VALUE_TYPE r;\n \n@@ -3369,7 +3369,8 @@ aarch64_print_operand (FILE *f, rtx x, char code)\n     case 'x':\n       /* Print a general register name or the zero register (32-bit or\n          64-bit).  */\n-      if (x == const0_rtx)\n+      if (x == const0_rtx\n+\t  || (CONST_DOUBLE_P (x) && aarch64_float_const_zero_rtx_p (x)))\n \t{\n \t  asm_fprintf (f, \"%s%czr\", REGISTER_PREFIX, code);\n \t  break;\n@@ -3420,11 +3421,46 @@ aarch64_print_operand (FILE *f, rtx x, char code)\n \t  break;\n \n \tcase CONST_VECTOR:\n-\t  gcc_assert (aarch64_const_vec_all_same_int_p (x, HOST_WIDE_INT_MIN,\n-\t\t\t\t\t\t\tHOST_WIDE_INT_MAX));\n-\t  asm_fprintf (f, \"%wd\", INTVAL (CONST_VECTOR_ELT (x, 0)));\n+\t  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_VECTOR_INT)\n+\t    {\n+\t      gcc_assert (aarch64_const_vec_all_same_int_p (x,\n+\t\t\t\t\t\t\t    HOST_WIDE_INT_MIN,\n+\t\t\t\t\t\t\t    HOST_WIDE_INT_MAX));\n+\t      asm_fprintf (f, \"%wd\", INTVAL (CONST_VECTOR_ELT (x, 0)));\n+\t    }\n+\t  else if (aarch64_simd_imm_zero_p (x, GET_MODE (x)))\n+\t    {\n+\t      fputc ('0', f);\n+\t    }\n+\t  else\n+\t    gcc_unreachable ();\n \t  break;\n \n+\tcase CONST_DOUBLE:\n+\t  /* CONST_DOUBLE can represent a double-width integer.\n+\t     In this case, the mode of x is VOIDmode.  */\n+\t  if (GET_MODE (x) == VOIDmode)\n+\t    ; /* Do Nothing.  */\n+\t  else if (aarch64_float_const_zero_rtx_p (x))\n+\t    {\n+\t      fputc ('0', f);\n+\t      break;\n+\t    }\n+\t  else if (aarch64_float_const_representable_p (x))\n+\t    {\n+#define buf_size 20\n+\t      char float_buf[buf_size] = {'\\0'};\n+\t      REAL_VALUE_TYPE r;\n+\t      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+\t      real_to_decimal_for_mode (float_buf, &r,\n+\t\t\t\t\tbuf_size, buf_size,\n+\t\t\t\t\t1, GET_MODE (x));\n+\t      asm_fprintf (asm_out_file, \"%s\", float_buf);\n+\t      break;\n+#undef buf_size\n+\t    }\n+\t  output_operand_lossage (\"invalid constant\");\n+\t  return;\n \tdefault:\n \t  output_operand_lossage (\"invalid operand\");\n \t  return;\n@@ -5006,6 +5042,27 @@ aarch64_legitimate_pic_operand_p (rtx x)\n   return true;\n }\n \n+/* Return true if X holds either a quarter-precision or\n+     floating-point +0.0 constant.  */\n+static bool\n+aarch64_valid_floating_const (enum machine_mode mode, rtx x)\n+{\n+  if (!CONST_DOUBLE_P (x))\n+    return false;\n+\n+  /* TODO: We could handle moving 0.0 to a TFmode register,\n+     but first we would like to refactor the movtf_aarch64\n+     to be more amicable to split moves properly and\n+     correctly gate on TARGET_SIMD.  For now - reject all\n+     constants which are not to SFmode or DFmode registers.  */\n+  if (!(mode == SFmode || mode == DFmode))\n+    return false;\n+\n+  if (aarch64_float_const_zero_rtx_p (x))\n+    return true;\n+  return aarch64_float_const_representable_p (x);\n+}\n+\n static bool\n aarch64_legitimate_constant_p (enum machine_mode mode, rtx x)\n {\n@@ -5019,8 +5076,8 @@ aarch64_legitimate_constant_p (enum machine_mode mode, rtx x)\n   if ((GET_CODE (x) == CONST_VECTOR\n        && aarch64_simd_valid_immediate (x, mode, false,\n \t\t\t\t\tNULL, NULL, NULL, NULL, NULL) != -1)\n-      || CONST_INT_P (x))\n-    return !targetm.cannot_force_const_mem (mode, x);\n+      || CONST_INT_P (x) || aarch64_valid_floating_const (mode, x))\n+\treturn !targetm.cannot_force_const_mem (mode, x);\n \n   if (GET_CODE (x) == HIGH\n       && aarch64_valid_symref (XEXP (x, 0), GET_MODE (XEXP (x, 0))))\n@@ -5975,6 +6032,44 @@ sizetochar (int size)\n     }\n }\n \n+/* Return true iff x is a uniform vector of floating-point\n+   constants, and the constant can be represented in\n+   quarter-precision form.  Note, as aarch64_float_const_representable\n+   rejects both +0.0 and -0.0, we will also reject +0.0 and -0.0.  */\n+static bool\n+aarch64_vect_float_const_representable_p (rtx x)\n+{\n+  int i = 0;\n+  REAL_VALUE_TYPE r0, ri;\n+  rtx x0, xi;\n+\n+  if (GET_MODE_CLASS (GET_MODE (x)) != MODE_VECTOR_FLOAT)\n+    return false;\n+\n+  x0 = CONST_VECTOR_ELT (x, 0);\n+  if (!CONST_DOUBLE_P (x0))\n+    return false;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r0, x0);\n+\n+  for (i = 1; i < CONST_VECTOR_NUNITS (x); i++)\n+    {\n+      xi = CONST_VECTOR_ELT (x, i);\n+      if (!CONST_DOUBLE_P (xi))\n+\treturn false;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (ri, xi);\n+      if (!REAL_VALUES_EQUAL (r0, ri))\n+\treturn false;\n+    }\n+\n+  return aarch64_float_const_representable_p (x0);\n+}\n+\n+/* TODO: This function returns values similar to those\n+   returned by neon_valid_immediate in gcc/config/arm/arm.c\n+   but the API here is different enough that these magic numbers\n+   are not used.  It should be sufficient to return true or false.  */\n static int\n aarch64_simd_valid_immediate (rtx op, enum machine_mode mode, int inverse,\n \t\t\t      rtx *modconst, int *elementwidth,\n@@ -6004,9 +6099,32 @@ aarch64_simd_valid_immediate (rtx op, enum machine_mode mode, int inverse,\n   unsigned int invmask = inverse ? 0xff : 0;\n   int eshift, emvn;\n \n-  /* TODO: Vectors of float constants.  */\n   if (GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n-    return -1;\n+    {\n+      bool simd_imm_zero = aarch64_simd_imm_zero_p (op, mode);\n+      int elem_width = GET_MODE_BITSIZE (GET_MODE (CONST_VECTOR_ELT (op, 0)));\n+\n+      if (!(simd_imm_zero\n+\t    || aarch64_vect_float_const_representable_p (op)))\n+\treturn -1;\n+\n+\tif (modconst)\n+\t  *modconst = CONST_VECTOR_ELT (op, 0);\n+\n+\tif (elementwidth)\n+\t  *elementwidth = elem_width;\n+\n+\tif (elementchar)\n+\t  *elementchar = sizetochar (elem_width);\n+\n+\tif (shift)\n+\t  *shift = 0;\n+\n+\tif (simd_imm_zero)\n+\t  return 19;\n+\telse\n+\t  return 18;\n+    }\n \n   /* Splat vector constant out into a byte vector.  */\n   for (i = 0; i < n_elts; i++)\n@@ -6161,8 +6279,8 @@ aarch64_simd_valid_immediate (rtx op, enum machine_mode mode, int inverse,\n \n /* Return TRUE if rtx X is legal for use as either a AdvSIMD MOVI instruction\n    (or, implicitly, MVNI) immediate.  Write back width per element\n-   to *ELEMENTWIDTH (or zero for float elements), and a modified constant\n-   (whatever should be output for a MOVI instruction) in *MODCONST.  */\n+   to *ELEMENTWIDTH, and a modified constant (whatever should be output\n+   for a MOVI instruction) in *MODCONST.  */\n int\n aarch64_simd_immediate_valid_for_move (rtx op, enum machine_mode mode,\n \t\t\t\t       rtx *modconst, int *elementwidth,\n@@ -6233,22 +6351,13 @@ aarch64_simd_shift_imm_p (rtx x, enum machine_mode mode, bool left)\n     return aarch64_const_vec_all_same_int_p (x, 1, bit_width);\n }\n \n+/* Return true if X is a uniform vector where all elements\n+   are either the floating-point constant 0.0 or the\n+   integer constant 0.  */\n bool\n aarch64_simd_imm_zero_p (rtx x, enum machine_mode mode)\n {\n-  int nunits;\n-  int i;\n-\n- if (GET_CODE (x) != CONST_VECTOR)\n-   return false;\n-\n-  nunits = GET_MODE_NUNITS (mode);\n-\n-  for (i = 0; i < nunits; i++)\n-    if (INTVAL (CONST_VECTOR_ELT (x, i)) != 0)\n-      return false;\n-\n-  return true;\n+  return x == CONST0_RTX (mode);\n }\n \n bool\n@@ -6799,6 +6908,139 @@ aarch64_c_mode_for_suffix (char suffix)\n   return VOIDmode;\n }\n \n+/* We can only represent floating point constants which will fit in\n+   \"quarter-precision\" values.  These values are characterised by\n+   a sign bit, a 4-bit mantissa and a 3-bit exponent.  And are given\n+   by:\n+\n+   (-1)^s * (n/16) * 2^r\n+\n+   Where:\n+     's' is the sign bit.\n+     'n' is an integer in the range 16 <= n <= 31.\n+     'r' is an integer in the range -3 <= r <= 4.  */\n+\n+/* Return true iff X can be represented by a quarter-precision\n+   floating point immediate operand X.  Note, we cannot represent 0.0.  */\n+bool\n+aarch64_float_const_representable_p (rtx x)\n+{\n+  /* This represents our current view of how many bits\n+     make up the mantissa.  */\n+  int point_pos = 2 * HOST_BITS_PER_WIDE_INT - 1;\n+  int sign, exponent;\n+  unsigned HOST_WIDE_INT mantissa, mask;\n+  HOST_WIDE_INT m1, m2;\n+  REAL_VALUE_TYPE r, m;\n+\n+  if (!CONST_DOUBLE_P (x))\n+    return false;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+\n+  /* We cannot represent infinities, NaNs or +/-zero.  We won't\n+     know if we have +zero until we analyse the mantissa, but we\n+     can reject the other invalid values.  */\n+  if (REAL_VALUE_ISINF (r) || REAL_VALUE_ISNAN (r)\n+      || REAL_VALUE_MINUS_ZERO (r))\n+    return false;\n+\n+  /* Extract sign and exponent.  */\n+  sign = REAL_VALUE_NEGATIVE (r) ? 1 : 0;\n+  r = real_value_abs (&r);\n+  exponent = REAL_EXP (&r);\n+\n+  /* For the mantissa, we expand into two HOST_WIDE_INTS, apart from the\n+     highest (sign) bit, with a fixed binary point at bit point_pos.\n+     m1 holds the low part of the mantissa, m2 the high part.\n+     WARNING: If we ever have a representation using more than 2 * H_W_I - 1\n+     bits for the mantissa, this can fail (low bits will be lost).  */\n+  real_ldexp (&m, &r, point_pos - exponent);\n+  REAL_VALUE_TO_INT (&m1, &m2, m);\n+\n+  /* If the low part of the mantissa has bits set we cannot represent\n+     the value.  */\n+  if (m1 != 0)\n+    return false;\n+  /* We have rejected the lower HOST_WIDE_INT, so update our\n+     understanding of how many bits lie in the mantissa and\n+     look only at the high HOST_WIDE_INT.  */\n+  mantissa = m2;\n+  point_pos -= HOST_BITS_PER_WIDE_INT;\n+\n+  /* We can only represent values with a mantissa of the form 1.xxxx.  */\n+  mask = ((unsigned HOST_WIDE_INT)1 << (point_pos - 5)) - 1;\n+  if ((mantissa & mask) != 0)\n+    return false;\n+\n+  /* Having filtered unrepresentable values, we may now remove all\n+     but the highest 5 bits.  */\n+  mantissa >>= point_pos - 5;\n+\n+  /* We cannot represent the value 0.0, so reject it.  This is handled\n+     elsewhere.  */\n+  if (mantissa == 0)\n+    return false;\n+\n+  /* Then, as bit 4 is always set, we can mask it off, leaving\n+     the mantissa in the range [0, 15].  */\n+  mantissa &= ~(1 << 4);\n+  gcc_assert (mantissa <= 15);\n+\n+  /* GCC internally does not use IEEE754-like encoding (where normalized\n+     significands are in the range [1, 2).  GCC uses [0.5, 1) (see real.c).\n+     Our mantissa values are shifted 4 places to the left relative to\n+     normalized IEEE754 so we must modify the exponent returned by REAL_EXP\n+     by 5 places to correct for GCC's representation.  */\n+  exponent = 5 - exponent;\n+\n+  return (exponent >= 0 && exponent <= 7);\n+}\n+\n+char*\n+aarch64_output_simd_mov_immediate (rtx *const_vector,\n+\t\t\t\t   enum machine_mode mode,\n+\t\t\t\t   unsigned width)\n+{\n+  int is_valid;\n+  unsigned char widthc;\n+  int lane_width_bits;\n+  static char templ[40];\n+  int shift = 0, mvn = 0;\n+  const char *mnemonic;\n+  unsigned int lane_count = 0;\n+\n+  is_valid =\n+    aarch64_simd_immediate_valid_for_move (*const_vector, mode,\n+\t\t\t\t\t   const_vector, &lane_width_bits,\n+\t\t\t\t\t   &widthc, &mvn, &shift);\n+  gcc_assert (is_valid);\n+\n+  mode = GET_MODE_INNER (mode);\n+  if (mode == SFmode || mode == DFmode)\n+    {\n+      bool zero_p =\n+\taarch64_float_const_zero_rtx_p (*const_vector);\n+      gcc_assert (shift == 0);\n+      mnemonic = zero_p ? \"movi\" : \"fmov\";\n+    }\n+  else\n+    mnemonic = mvn ? \"mvni\" : \"movi\";\n+\n+  gcc_assert (lane_width_bits != 0);\n+  lane_count = width / lane_width_bits;\n+\n+  if (lane_count == 1)\n+    snprintf (templ, sizeof (templ), \"%s\\t%%d0, %%1\", mnemonic);\n+  else if (shift)\n+    snprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, %%1, lsl %d\",\n+\t      mnemonic, lane_count, widthc, shift);\n+  else\n+    snprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, %%1\",\n+\t      mnemonic, lane_count, widthc);\n+  return templ;\n+}\n+\n /* Split operands into moves from op[1] + op[2] into op[0].  */\n \n void"}, {"sha": "70df659b89e621247837a7c19ebd11bd9906011d", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=3520f7cc6987fc79ae688ebe532f6242f743355d", "patch": "@@ -915,38 +915,44 @@\n )\n \n (define_insn \"*movsf_aarch64\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"= w,?r,w,w,m,r,m ,r\")\n-\t(match_operand:SF 1 \"general_operand\"      \"?rY, w,w,m,w,m,rY,r\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=w, ?r,w,w  ,w,m,r,m ,r\")\n+\t(match_operand:SF 1 \"general_operand\"      \"?rY, w,w,Ufc,m,w,m,rY,r\"))]\n   \"TARGET_FLOAT && (register_operand (operands[0], SFmode)\n     || register_operand (operands[1], SFmode))\"\n   \"@\n    fmov\\\\t%s0, %w1\n    fmov\\\\t%w0, %s1\n    fmov\\\\t%s0, %s1\n+   fmov\\\\t%s0, %1\n    ldr\\\\t%s0, %1\n    str\\\\t%s1, %0\n    ldr\\\\t%w0, %1\n    str\\\\t%w1, %0\n    mov\\\\t%w0, %w1\"\n-  [(set_attr \"v8type\" \"fmovi2f,fmovf2i,fmov,fpsimd_load,fpsimd_store,fpsimd_load,fpsimd_store,fmov\")\n+  [(set_attr \"v8type\" \"fmovi2f,fmovf2i,\\\n+\t\t       fmov,fconst,fpsimd_load,\\\n+\t\t       fpsimd_store,fpsimd_load,fpsimd_store,fmov\")\n    (set_attr \"mode\" \"SF\")]\n )\n \n (define_insn \"*movdf_aarch64\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"= w,?r,w,w,m,r,m ,r\")\n-\t(match_operand:DF 1 \"general_operand\"      \"?rY, w,w,m,w,m,rY,r\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=w, ?r,w,w  ,w,m,r,m ,r\")\n+\t(match_operand:DF 1 \"general_operand\"      \"?rY, w,w,Ufc,m,w,m,rY,r\"))]\n   \"TARGET_FLOAT && (register_operand (operands[0], DFmode)\n     || register_operand (operands[1], DFmode))\"\n   \"@\n    fmov\\\\t%d0, %x1\n    fmov\\\\t%x0, %d1\n    fmov\\\\t%d0, %d1\n+   fmov\\\\t%d0, %1\n    ldr\\\\t%d0, %1\n    str\\\\t%d1, %0\n    ldr\\\\t%x0, %1\n    str\\\\t%x1, %0\n    mov\\\\t%x0, %x1\"\n-  [(set_attr \"v8type\" \"fmovi2f,fmovf2i,fmov,fpsimd_load,fpsimd_store,fpsimd_load,fpsimd_store,move\")\n+  [(set_attr \"v8type\" \"fmovi2f,fmovf2i,\\\n+\t\t       fmov,fconst,fpsimd_load,\\\n+\t\t       fpsimd_store,fpsimd_load,fpsimd_store,move\")\n    (set_attr \"mode\" \"DF\")]\n )\n \n@@ -991,7 +997,6 @@\n    (set_attr \"simd\" \"yes,*,*,*,yes,*,*,*,*,*\")]\n )\n \n-\n ;; Operands 1 and 3 are tied together by the final condition; so we allow\n ;; fairly lax checking on the second memory operation.\n (define_insn \"load_pair<mode>\""}, {"sha": "7e33ec08862c31127b803425eb66539de72b40e5", "filename": "gcc/config/aarch64/constraints.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fconstraints.md?ref=3520f7cc6987fc79ae688ebe532f6242f743355d", "patch": "@@ -69,7 +69,7 @@\n (define_constraint \"Y\"\n   \"Floating point constant zero.\"\n   (and (match_code \"const_double\")\n-       (match_test \"aarch64_const_double_zero_rtx_p (op)\")))\n+       (match_test \"aarch64_float_const_zero_rtx_p (op)\")))\n \n (define_constraint \"Z\"\n   \"Integer constant zero.\"\n@@ -138,6 +138,12 @@\n   (and (match_code \"mem\")\n        (match_test \"aarch64_simd_mem_operand_p (op)\")))\n \n+(define_constraint \"Ufc\"\n+  \"A floating point constant which can be used with an\\\n+   FMOV immediate operation.\"\n+  (and (match_code \"const_double\")\n+       (match_test \"aarch64_float_const_representable_p (op)\")))\n+\n (define_constraint \"Dn\"\n   \"@internal\n  A constraint that matches vector of immediates.\""}, {"sha": "1dbaec10e7d7b7a9d721ae27af4c7d3c7d7bdb25", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=3520f7cc6987fc79ae688ebe532f6242f743355d", "patch": "@@ -41,7 +41,7 @@\n (define_predicate \"aarch64_fp_compare_operand\"\n   (ior (match_operand 0 \"register_operand\")\n        (and (match_code \"const_double\")\n-\t    (match_test \"aarch64_const_double_zero_rtx_p (op)\"))))\n+\t    (match_test \"aarch64_float_const_zero_rtx_p (op)\"))))\n \n (define_predicate \"aarch64_plus_immediate\"\n   (and (match_code \"const_int\")"}, {"sha": "178459ea04e1b1ec690054711efeba2020107815", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3520f7cc6987fc79ae688ebe532f6242f743355d", "patch": "@@ -1,3 +1,14 @@\n+2013-01-07  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* gcc.target/aarch64/fmovd.c: New.\n+\t* gcc.target/aarch64/fmovf.c: Likewise.\n+\t* gcc.target/aarch64/fmovd-zero.c: Likewise.\n+\t* gcc.target/aarch64/fmovf-zero.c: Likewise.\n+\t* gcc.target/aarch64/vect-fmovd.c: Likewise.\n+\t* gcc.target/aarch64/vect-fmovf.c: Likewise.\n+\t* gcc.target/aarch64/vect-fmovd-zero.c: Likewise.\n+\t* gcc.target/aarch64/vect-fmovf-zero.c: Likewise.\n+\n 2013-01-07  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/55888"}, {"sha": "7e4590afe61e36faa917ce9b64b8be558db93821", "filename": "gcc/testsuite/gcc.target/aarch64/fmovd-zero.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ffmovd-zero.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ffmovd-zero.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ffmovd-zero.c?ref=3520f7cc6987fc79ae688ebe532f6242f743355d", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+void\n+foo (double *output)\n+{\n+  *output = 0.0;\n+}\n+\n+/* { dg-final { scan-assembler \"fmov\\\\td\\[0-9\\]+, xzr\" } } */"}, {"sha": "c50e74e3f1305c520a3a959eb1eef154817ab6af", "filename": "gcc/testsuite/gcc.target/aarch64/fmovd.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ffmovd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ffmovd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ffmovd.c?ref=3520f7cc6987fc79ae688ebe532f6242f743355d", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+void\n+foo (double *output)\n+{\n+  *output = 4.25;\n+}\n+\n+/* { dg-final { scan-assembler \"fmov\\\\td\\[0-9\\]+, 4\\\\.25\" } } */"}, {"sha": "5050ac3103855b728ed11f66ab593220c76f41b3", "filename": "gcc/testsuite/gcc.target/aarch64/fmovf-zero.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ffmovf-zero.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ffmovf-zero.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ffmovf-zero.c?ref=3520f7cc6987fc79ae688ebe532f6242f743355d", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+void\n+foo (float *output)\n+{\n+  *output = 0.0;\n+}\n+\n+/* { dg-final { scan-assembler \"fmov\\\\ts\\[0-9\\]+, wzr\" } } */"}, {"sha": "0a9e21517da67a8aa7eb836df0b66b7a2787bda3", "filename": "gcc/testsuite/gcc.target/aarch64/fmovf.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ffmovf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ffmovf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ffmovf.c?ref=3520f7cc6987fc79ae688ebe532f6242f743355d", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+void\n+foo (float *output)\n+{\n+  *output = 4.25;\n+}\n+\n+/* { dg-final { scan-assembler \"fmov\\\\ts\\[0-9\\]+, 4\\\\.25\" } } */"}, {"sha": "667d22745e24f20368e933170e1b16aaf1f019a3", "filename": "gcc/testsuite/gcc.target/aarch64/vect-fmovd-zero.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-fmovd-zero.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-fmovd-zero.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-fmovd-zero.c?ref=3520f7cc6987fc79ae688ebe532f6242f743355d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-all\" } */\n+\n+#define N 32\n+\n+void\n+foo (double *output)\n+{\n+  int i = 0;\n+  /* Vectorizable.  */\n+  for (i = 0; i < N; i++)\n+    output[i] = 0.0;\n+}\n+\n+/* { dg-final { scan-assembler \"movi\\\\tv\\[0-9\\]+\\\\.2d, 0\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a0211c71582511e00303f15226eff5ba769e8d15", "filename": "gcc/testsuite/gcc.target/aarch64/vect-fmovd.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-fmovd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-fmovd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-fmovd.c?ref=3520f7cc6987fc79ae688ebe532f6242f743355d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-all\" } */\n+\n+#define N 32\n+\n+void\n+foo (double *output)\n+{\n+  int i = 0;\n+  /* Vectorizable.  */\n+  for (i = 0; i < N; i++)\n+    output[i] = 4.25;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-assembler \"fmov\\\\tv\\[0-9\\]+\\\\.2d, 4\\\\.25\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "259a9d41f525fde7aae573ec4756b1602668defd", "filename": "gcc/testsuite/gcc.target/aarch64/vect-fmovf-zero.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-fmovf-zero.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-fmovf-zero.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-fmovf-zero.c?ref=3520f7cc6987fc79ae688ebe532f6242f743355d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-all\" } */\n+\n+#define N 32\n+\n+void\n+foo (float *output)\n+{\n+  int i = 0;\n+  /* Vectorizable.  */\n+  for (i = 0; i < N; i++)\n+    output[i] = 0.0;\n+}\n+\n+/* { dg-final { scan-assembler \"movi\\\\tv\\[0-9\\]+\\\\.\\[24\\]s, 0\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "0bd21dc190b1d477003a41270fcc66da3c33d16e", "filename": "gcc/testsuite/gcc.target/aarch64/vect-fmovf.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-fmovf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3520f7cc6987fc79ae688ebe532f6242f743355d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-fmovf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-fmovf.c?ref=3520f7cc6987fc79ae688ebe532f6242f743355d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-all\" } */\n+\n+#define N 32\n+\n+void\n+foo (float *output)\n+{\n+  int i = 0;\n+  /* Vectorizable.  */\n+  for (i = 0; i < N; i++)\n+    output[i] = 4.25;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-assembler \"fmov\\\\tv\\[0-9\\]+\\\\.\\[24\\]s, 4\\\\.25\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}]}