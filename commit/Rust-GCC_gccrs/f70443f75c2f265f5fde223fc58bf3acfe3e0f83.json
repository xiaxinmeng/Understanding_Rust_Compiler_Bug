{"sha": "f70443f75c2f265f5fde223fc58bf3acfe3e0f83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcwNDQzZjc1YzJmMjY1ZjVmZGUyMjNmYzU4YmYzYWNmZTNlMGY4Mw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2002-01-26T06:32:55Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2002-01-26T06:32:55Z"}, "message": "verify.cc (verify_fail): Change from being a top-level function to e method of _Jv_BytecodeVerifier.\n\n\n\t* verify.cc (verify_fail):  Change from being a top-level function\n\tto e method of _Jv_BytecodeVerifier.  Emit current method name.\n\tPass the current verifier to type: and state: methods as needed,\n\tfor better error messages, and for resolve.\n\t(resolve):  Pass current class's loader for Class.forName and\n\t_Jv_FindClassFromSignature, rather than using the default loader.\n\t(various type: and state: methods):  Take _Jv_BytecodeVerifier* arg.\n\t(get_type_val_for_signature):  Make non-static.\n\t(various methods):  Pass start_PC implicitly, not explicitly.\n\nFrom-SVN: r49240", "tree": {"sha": "8c30238d951d397caaf21afdd19b344294ee97ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c30238d951d397caaf21afdd19b344294ee97ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f70443f75c2f265f5fde223fc58bf3acfe3e0f83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f70443f75c2f265f5fde223fc58bf3acfe3e0f83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f70443f75c2f265f5fde223fc58bf3acfe3e0f83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f70443f75c2f265f5fde223fc58bf3acfe3e0f83/comments", "author": null, "committer": null, "parents": [{"sha": "63b3a44f03859984b064a41cf49732e97fd4adfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63b3a44f03859984b064a41cf49732e97fd4adfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63b3a44f03859984b064a41cf49732e97fd4adfe"}], "stats": {"total": 213, "additions": 107, "deletions": 106}, "files": [{"sha": "ac380cbf753128e9e75e721e5bb38cdac9f9298f", "filename": "libjava/verify.cc", "status": "modified", "additions": 107, "deletions": 106, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f70443f75c2f265f5fde223fc58bf3acfe3e0f83/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f70443f75c2f265f5fde223fc58bf3acfe3e0f83/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=f70443f75c2f265f5fde223fc58bf3acfe3e0f83", "patch": "@@ -39,11 +39,6 @@ details.  */\n // * at least one GC problem :-(\n \n \n-// This is global because __attribute__ doesn't seem to work on static\n-// methods.\n-static void verify_fail (char *msg, jint pc = -1)\n-  __attribute__ ((__noreturn__));\n-\n static void debug_print (const char *fmt, ...)\n   __attribute__ ((format (printf, 1, 2)));\n \n@@ -180,7 +175,7 @@ class _Jv_BytecodeVerifier\n \n   // Return the type_val corresponding to a primitive signature\n   // character.  For instance `I' returns `int.class'.\n-  static type_val get_type_val_for_signature (jchar sig)\n+  type_val get_type_val_for_signature (jchar sig)\n   {\n     type_val rt;\n     switch (sig)\n@@ -219,7 +214,7 @@ class _Jv_BytecodeVerifier\n   }\n \n   // Return the type_val corresponding to a primitive class.\n-  static type_val get_type_val_for_signature (jclass k)\n+  type_val get_type_val_for_signature (jclass k)\n   {\n     return get_type_val_for_signature ((jchar) k->method_count);\n   }\n@@ -390,35 +385,36 @@ class _Jv_BytecodeVerifier\n     }\n \n     // If *THIS is an unresolved reference type, resolve it.\n-    void resolve ()\n+    void resolve (_Jv_BytecodeVerifier *verifier)\n     {\n       if (key != unresolved_reference_type\n \t  && key != uninitialized_unresolved_reference_type)\n \treturn;\n \n-      // FIXME: class loader\n       using namespace java::lang;\n+      java::lang::ClassLoader *loader\n+\t= verifier->current_class->getClassLoader();\n       // We might see either kind of name.  Sigh.\n       if (data.name->data[0] == 'L'\n \t  && data.name->data[data.name->length - 1] == ';')\n-\tdata.klass = _Jv_FindClassFromSignature (data.name->data, NULL);\n+\tdata.klass = _Jv_FindClassFromSignature (data.name->data, loader);\n       else\n \tdata.klass = Class::forName (_Jv_NewStringUtf8Const (data.name),\n-\t\t\t\t     false, NULL);\n+\t\t\t\t     false, loader);\n       key = (key == unresolved_reference_type\n \t     ? reference_type\n \t     : uninitialized_reference_type);\n     }\n \n     // Mark this type as the uninitialized result of `new'.\n-    void set_uninitialized (int npc)\n+    void set_uninitialized (int npc, _Jv_BytecodeVerifier *verifier)\n     {\n       if (key == reference_type)\n \tkey = uninitialized_reference_type;\n       else if (key == unresolved_reference_type)\n \tkey = uninitialized_unresolved_reference_type;\n       else\n-\tverify_fail (\"internal error in type::uninitialized\");\n+\tverifier->verify_fail (\"internal error in type::uninitialized\");\n       pc = npc;\n     }\n \n@@ -441,7 +437,7 @@ class _Jv_BytecodeVerifier\n     // of type *THIS.  Handle various special cases too.  Might modify\n     // *THIS or K.  Note however that this does not perform numeric\n     // promotion.\n-    bool compatible (type &k)\n+    bool compatible (type &k, _Jv_BytecodeVerifier *verifier)\n     {\n       // Any type is compatible with the unsuitable type.\n       if (key == unsuitable_type)\n@@ -482,8 +478,8 @@ class _Jv_BytecodeVerifier\n \treturn true;\n \n       // We must resolve both types and check assignability.\n-      resolve ();\n-      k.resolve ();\n+      resolve (verifier);\n+      k.resolve (verifier);\n       return is_assignable_from_slow (data.klass, k.data.klass);\n     }\n \n@@ -515,52 +511,52 @@ class _Jv_BytecodeVerifier\n       return false;\n     }\n \n-    bool isinterface ()\n+    bool isinterface (_Jv_BytecodeVerifier *verifier)\n     {\n-      resolve ();\n+      resolve (verifier);\n       if (key != reference_type)\n \treturn false;\n       return data.klass->isInterface ();\n     }\n \n-    bool isabstract ()\n+    bool isabstract (_Jv_BytecodeVerifier *verifier)\n     {\n-      resolve ();\n+      resolve (verifier);\n       if (key != reference_type)\n \treturn false;\n       using namespace java::lang::reflect;\n       return Modifier::isAbstract (data.klass->getModifiers ());\n     }\n \n     // Return the element type of an array.\n-    type element_type ()\n+    type element_type (_Jv_BytecodeVerifier *verifier)\n     {\n       // FIXME: maybe should do string manipulation here.\n-      resolve ();\n+      resolve (verifier);\n       if (key != reference_type)\n-\tverify_fail (\"programmer error in type::element_type()\");\n+\tverifier->verify_fail (\"programmer error in type::element_type()\", -1);\n \n       jclass k = data.klass->getComponentType ();\n       if (k->isPrimitive ())\n-\treturn type (get_type_val_for_signature (k));\n+\treturn type (verifier->get_type_val_for_signature (k));\n       return type (k);\n     }\n \n     // Return the array type corresponding to an initialized\n     // reference.  We could expand this to work for other kinds of\n     // types, but currently we don't need to.\n-    type to_array ()\n+    type to_array (_Jv_BytecodeVerifier *verifier)\n     {\n       // Resolving isn't ideal, because it might force us to load\n       // another class, but it's easy.  FIXME?\n       if (key == unresolved_reference_type)\n-\tresolve ();\n+\tresolve (verifier);\n \n       if (key == reference_type)\n \treturn type (_Jv_GetArrayClass (data.klass,\n \t\t\t\t\tdata.klass->getClassLoader ()));\n       else\n-\tverify_fail (\"internal error in type::to_array()\");\n+\tverifier->verify_fail (\"internal error in type::to_array()\");\n     }\n \n     bool isreference () const\n@@ -587,7 +583,7 @@ class _Jv_BytecodeVerifier\n \t      || key == uninitialized_reference_type);\n     }\n \n-    void verify_dimensions (int ndims)\n+    void verify_dimensions (int ndims, _Jv_BytecodeVerifier *verifier)\n     {\n       // The way this is written, we don't need to check isarray().\n       if (key == reference_type)\n@@ -608,11 +604,11 @@ class _Jv_BytecodeVerifier\n \t}\n \n       if (ndims > 0)\n-\tverify_fail (\"array type has fewer dimensions than required\");\n+\tverifier->verify_fail (\"array type has fewer dimensions than required\");\n     }\n \n     // Merge OLD_TYPE into this.  On error throw exception.\n-    bool merge (type& old_type, bool local_semantics = false)\n+    bool merge (type& old_type, bool local_semantics, _Jv_BytecodeVerifier *verifier)\n     {\n       bool changed = false;\n       bool refo = old_type.isreference ();\n@@ -627,7 +623,7 @@ class _Jv_BytecodeVerifier\n \t      changed = true;\n \t    }\n \t  else if (isinitialized () != old_type.isinitialized ())\n-\t    verify_fail (\"merging initialized and uninitialized types\");\n+\t    verifier->verify_fail (\"merging initialized and uninitialized types\");\n \t  else\n \t    {\n \t      if (! isinitialized ())\n@@ -637,7 +633,7 @@ class _Jv_BytecodeVerifier\n \t\t  else if (old_type.pc == UNINIT)\n \t\t    ;\n \t\t  else if (pc != old_type.pc)\n-\t\t    verify_fail (\"merging different uninitialized types\");\n+\t\t    verifier->verify_fail (\"merging different uninitialized types\");\n \t\t}\n \n \t      if (! isresolved ()\n@@ -648,8 +644,8 @@ class _Jv_BytecodeVerifier\n \t\t}\n \t      else\n \t\t{\n-\t\t  resolve ();\n-\t\t  old_type.resolve ();\n+\t\t  resolve (verifier);\n+\t\t  old_type.resolve (verifier);\n \n \t\t  jclass k = data.klass;\n \t\t  jclass oldk = old_type.data.klass;\n@@ -708,7 +704,7 @@ class _Jv_BytecodeVerifier\n \t\t}\n \t    }\n \t  else\n-\t    verify_fail (\"unmergeable type\");\n+\t    verifier->verify_fail (\"unmergeable type\");\n \t}\n       return changed;\n     }\n@@ -886,7 +882,7 @@ class _Jv_BytecodeVerifier\n     // state.  Returns true if the new state was in fact changed.\n     // Will throw an exception if the states are not mergeable.\n     bool merge (state *state_old, bool ret_semantics,\n-\t\tint max_locals)\n+\t\tint max_locals, _Jv_BytecodeVerifier *verifier)\n     {\n       bool changed = false;\n \n@@ -908,14 +904,14 @@ class _Jv_BytecodeVerifier\n \t  changed = true;\n \t}\n       else\n-\tverify_fail (\"subroutines merged\");\n+\tverifier->verify_fail (\"subroutines merged\");\n \n       // Merge stacks.\n       if (state_old->stacktop != stacktop)\n-\tverify_fail (\"stack sizes differ\");\n+\tverifier->verify_fail (\"stack sizes differ\");\n       for (int i = 0; i < state_old->stacktop; ++i)\n \t{\n-\t  if (stack[i].merge (state_old->stack[i]))\n+\t  if (stack[i].merge (state_old->stack[i], false, verifier))\n \t    changed = true;\n \t}\n \n@@ -924,7 +920,7 @@ class _Jv_BytecodeVerifier\n \t{\n \t  if (! ret_semantics || local_changed[i])\n \t    {\n-\t      if (locals[i].merge (state_old->locals[i], true))\n+\t      if (locals[i].merge (state_old->locals[i], true, verifier))\n \t\t{\n \t\t  changed = true;\n \t\t  note_variable (i);\n@@ -945,27 +941,28 @@ class _Jv_BytecodeVerifier\n     // whether we're using backwards-branch or exception-handing\n     // semantics.\n     void check_no_uninitialized_objects (int max_locals,\n+\t\t\t\t\t _Jv_BytecodeVerifier *verifier,\n \t\t\t\t\t bool exception_semantics = false)\n     {\n       if (! exception_semantics)\n \t{\n \t  for (int i = 0; i < stacktop; ++i)\n \t    if (stack[i].isreference () && ! stack[i].isinitialized ())\n-\t      verify_fail (\"uninitialized object on stack\");\n+\t      verifier->verify_fail (\"uninitialized object on stack\");\n \t}\n \n       for (int i = 0; i < max_locals; ++i)\n \tif (locals[i].isreference () && ! locals[i].isinitialized ())\n-\t  verify_fail (\"uninitialized object in local variable\");\n+\t  verifier->verify_fail (\"uninitialized object in local variable\");\n \n-      check_this_initialized ();\n+      check_this_initialized (verifier);\n     }\n \n     // Ensure that `this' has been initialized.\n-    void check_this_initialized ()\n+    void check_this_initialized (_Jv_BytecodeVerifier *verifier)\n     {\n       if (this_type.isreference () && ! this_type.isinitialized ())\n-\tverify_fail (\"`this' is uninitialized\");\n+\tverifier->verify_fail (\"`this' is uninitialized\");\n     }\n \n     // Set type of `this'.\n@@ -1028,7 +1025,7 @@ class _Jv_BytecodeVerifier\n   type pop_raw ()\n   {\n     if (current_state->stacktop <= 0)\n-      verify_fail (\"stack empty\", start_PC);\n+      verify_fail (\"stack empty\");\n     type r = current_state->stack[--current_state->stacktop];\n     current_state->stackdepth -= r.depth ();\n     if (current_state->stackdepth < 0)\n@@ -1040,24 +1037,24 @@ class _Jv_BytecodeVerifier\n   {\n     type r = pop_raw ();\n     if (r.iswide ())\n-      verify_fail (\"narrow pop of wide type\", start_PC);\n+      verify_fail (\"narrow pop of wide type\");\n     return r;\n   }\n \n   type pop64 ()\n   {\n     type r = pop_raw ();\n     if (! r.iswide ())\n-      verify_fail (\"wide pop of narrow type\", start_PC);\n+      verify_fail (\"wide pop of narrow type\");\n     return r;\n   }\n \n   type pop_type (type match)\n   {\n     match.promote ();\n     type t = pop_raw ();\n-    if (! match.compatible (t))\n-      verify_fail (\"incompatible type on stack\", start_PC);\n+    if (! match.compatible (t, this))\n+      verify_fail (\"incompatible type on stack\");\n     return t;\n   }\n \n@@ -1066,7 +1063,7 @@ class _Jv_BytecodeVerifier\n   {\n     type t = pop_raw ();\n     if (! t.isreference () && t.key != return_address_type)\n-      verify_fail (\"expected reference or return address on stack\", start_PC);\n+      verify_fail (\"expected reference or return address on stack\");\n     return t;\n   }\n \n@@ -1109,14 +1106,14 @@ class _Jv_BytecodeVerifier\n   {\n     int depth = t.depth ();\n     if (index > current_method->max_locals - depth)\n-      verify_fail (\"invalid local variable\", start_PC);\n-    if (! t.compatible (current_state->locals[index]))\n-      verify_fail (\"incompatible type in local variable\", start_PC);\n+      verify_fail (\"invalid local variable\");\n+    if (! t.compatible (current_state->locals[index], this))\n+      verify_fail (\"incompatible type in local variable\");\n     if (depth == 2)\n       {\n \ttype t (continuation_type);\n-\tif (! current_state->locals[index + 1].compatible (t))\n-\t  verify_fail (\"invalid local variable\", start_PC);\n+\tif (! current_state->locals[index + 1].compatible (t, this))\n+\t  verify_fail (\"invalid local variable\");\n       }\n     return current_state->locals[index];\n   }\n@@ -1128,16 +1125,16 @@ class _Jv_BytecodeVerifier\n     if (! array.isarray ())\n       verify_fail (\"array required\");\n \n-    type t = array.element_type ();\n-    if (! element.compatible (t))\n+    type t = array.element_type (this);\n+    if (! element.compatible (t, this))\n       {\n \t// Special case for byte arrays, which must also be boolean\n \t// arrays.\n \tbool ok = true;\n \tif (element.key == byte_type)\n \t  {\n \t    type e2 (boolean_type);\n-\t    ok = e2.compatible (t);\n+\t    ok = e2.compatible (t, this);\n \t  }\n \tif (! ok)\n \t  verify_fail (\"incompatible array element type\");\n@@ -1217,7 +1214,7 @@ class _Jv_BytecodeVerifier\n \tstates[npc]->print (\" To\", npc, current_method->max_stack,\n \t\t\t    current_method->max_locals);\n \tchanged = states[npc]->merge (nstate, ret_semantics,\n-\t\t\t\t      current_method->max_locals);\n+\t\t\t\t      current_method->max_locals, this);\n \tstates[npc]->print (\"New\", npc, current_method->max_stack,\n \t\t\t    current_method->max_locals);\n       }\n@@ -1235,14 +1232,14 @@ class _Jv_BytecodeVerifier\n   {\n     int npc = compute_jump (offset);\n     if (npc < PC)\n-      current_state->check_no_uninitialized_objects (current_method->max_locals);\n+      current_state->check_no_uninitialized_objects (current_method->max_locals, this);\n     push_jump_merge (npc, current_state);\n   }\n \n   void push_exception_jump (type t, int pc)\n   {\n     current_state->check_no_uninitialized_objects (current_method->max_locals,\n-\t\t\t\t\t\t  true);\n+\t\t\t\t\t\t   this, true);\n     state s (current_state, current_method->max_stack,\n \t     current_method->max_locals);\n     s.set_exception (t, current_method->max_stack);\n@@ -1336,7 +1333,7 @@ class _Jv_BytecodeVerifier\n \t// in the enclosing context.\n \tcurrent_state->subroutine = get_subroutine (subr->pc);\n \tif (subr->pc < PC)\n-\t  current_state->check_no_uninitialized_objects (current_method->max_locals);\n+\t  current_state->check_no_uninitialized_objects (current_method->max_locals, this);\n \tpush_jump_merge (subr->pc, current_state, true);\n       }\n \n@@ -1361,7 +1358,7 @@ class _Jv_BytecodeVerifier\n     int npc = compute_jump (offset);\n \n     if (npc < PC)\n-      current_state->check_no_uninitialized_objects (current_method->max_locals);\n+      current_state->check_no_uninitialized_objects (current_method->max_locals, this);\n     check_nonrecursive_call (current_state->subroutine, npc);\n \n     // Temporarily modify the current state so that it looks like we are\n@@ -1899,8 +1896,8 @@ class _Jv_BytecodeVerifier\n   void check_return_type (type onstack)\n   {\n     type rt = compute_return_type (current_method->self->signature);\n-    if (! rt.compatible (onstack))\n-      verify_fail (\"incompatible return type\", start_PC);\n+    if (! rt.compatible (onstack, this))\n+      verify_fail (\"incompatible return type\");\n   }\n \n   // Initialize the stack for the new method.  Returns true if this\n@@ -1916,7 +1913,7 @@ class _Jv_BytecodeVerifier\n \ttype kurr (current_class);\n \tif (_Jv_equalUtf8Consts (current_method->self->name, gcj::init_name))\n \t  {\n-\t    kurr.set_uninitialized (type::SELF);\n+\t    kurr.set_uninitialized (type::SELF, this);\n \t    is_init = true;\n \t  }\n \tset_variable (0, kurr);\n@@ -1997,7 +1994,7 @@ class _Jv_BytecodeVerifier\n \t\tcurrent_state->print (\"Cur\", PC, current_method->max_stack,\n \t\t\t\t      current_method->max_locals);\n \t\tif (! current_state->merge (states[PC], false,\n-\t\t\t\t\t    current_method->max_locals)\n+\t\t\t\t\t    current_method->max_locals, this)\n \t\t    && ! states[PC]->is_unmerged_ret_state (current_method->max_locals))\n \t\t  {\n \t\t    debug_print (\"== Fall through optimization\\n\");\n@@ -2610,7 +2607,7 @@ class _Jv_BytecodeVerifier\n \t    // We only need to check this when the return type is\n \t    // void, because all instance initializers return void.\n \t    if (this_is_init)\n-\t      current_state->check_this_initialized ();\n+\t      current_state->check_this_initialized (this);\n \t    check_return_type (void_type);\n \t    invalidate_pc ();\n \t    break;\n@@ -2639,7 +2636,7 @@ class _Jv_BytecodeVerifier\n \t      // `this' has not yet been initialized.\n \t      if (! current_state->this_type.isinitialized ()\n \t\t  && current_state->this_type.pc == type::SELF)\n-\t\tklass.set_uninitialized (type::SELF);\n+\t\tklass.set_uninitialized (type::SELF, this);\n \t      pop_type (klass);\n \t    }\n \t    break;\n@@ -2660,26 +2657,22 @@ class _Jv_BytecodeVerifier\n \t\t{\n \t\t  int nargs = get_byte ();\n \t\t  if (nargs == 0)\n-\t\t    verify_fail (\"too few arguments to invokeinterface\",\n-\t\t\t\t start_PC);\n+\t\t    verify_fail (\"too few arguments to invokeinterface\");\n \t\t  if (get_byte () != 0)\n-\t\t    verify_fail (\"invokeinterface dummy byte is wrong\",\n-\t\t\t\t start_PC);\n+\t\t    verify_fail (\"invokeinterface dummy byte is wrong\");\n \t\t  if (nargs - 1 != arg_count)\n-\t\t    verify_fail (\"wrong argument count for invokeinterface\",\n-\t\t\t\t start_PC);\n+\t\t    verify_fail (\"wrong argument count for invokeinterface\");\n \t\t}\n \n \t      bool is_init = false;\n \t      if (_Jv_equalUtf8Consts (method_name, gcj::init_name))\n \t\t{\n \t\t  is_init = true;\n \t\t  if (opcode != op_invokespecial)\n-\t\t    verify_fail (\"can't invoke <init>\", start_PC);\n+\t\t    verify_fail (\"can't invoke <init>\");\n \t\t}\n \t      else if (method_name->data[0] == '<')\n-\t\tverify_fail (\"can't invoke method starting with `<'\",\n-\t\t\t     start_PC);\n+\t\tverify_fail (\"can't invoke method starting with `<'\");\n \n \t      // Pop arguments and check types.\n \t      type arg_types[arg_count];\n@@ -2693,7 +2686,7 @@ class _Jv_BytecodeVerifier\n \t\t  if (is_init)\n \t\t    {\n \t\t      // In this case the PC doesn't matter.\n-\t\t      t.set_uninitialized (type::UNINIT);\n+\t\t      t.set_uninitialized (type::UNINIT, this);\n \t\t    }\n \t\t  t = pop_type (t);\n \t\t  if (is_init)\n@@ -2710,10 +2703,9 @@ class _Jv_BytecodeVerifier\n \t  case op_new:\n \t    {\n \t      type t = check_class_constant (get_ushort ());\n-\t      if (t.isarray () || t.isinterface () || t.isabstract ())\n-\t\tverify_fail (\"type is array, interface, or abstract\",\n-\t\t\t     start_PC);\n-\t      t.set_uninitialized (start_PC);\n+\t      if (t.isarray () || t.isinterface (this) || t.isabstract (this))\n+\t\tverify_fail (\"type is array, interface, or abstract\");\n+\t      t.set_uninitialized (start_PC, this);\n \t      push_type (t);\n \t    }\n \t    break;\n@@ -2731,13 +2723,13 @@ class _Jv_BytecodeVerifier\n \t    break;\n \t  case op_anewarray:\n \t    pop_type (int_type);\n-\t    push_type (check_class_constant (get_ushort ()).to_array ());\n+\t    push_type (check_class_constant (get_ushort ()).to_array (this));\n \t    break;\n \t  case op_arraylength:\n \t    {\n \t      type t = pop_type (reference_type);\n \t      if (! t.isarray ())\n-\t\tverify_fail (\"array type expected\", start_PC);\n+\t\tverify_fail (\"array type expected\");\n \t      push_type (int_type);\n \t    }\n \t    break;\n@@ -2812,7 +2804,7 @@ class _Jv_BytecodeVerifier\n \t      int dim = get_byte ();\n \t      if (dim < 1)\n \t\tverify_fail (\"too few dimensions to multianewarray\", start_PC);\n-\t      atype.verify_dimensions (dim);\n+\t      atype.verify_dimensions (dim, this);\n \t      for (int i = 0; i < dim; ++i)\n \t\tpop_type (int_type);\n \t      push_type (atype);\n@@ -2839,6 +2831,34 @@ class _Jv_BytecodeVerifier\n       }\n   }\n \n+  __attribute__ ((__noreturn__)) void verify_fail (char *s, jint pc = -1)\n+  {\n+    using namespace java::lang;\n+    StringBuffer *buf = new StringBuffer ();\n+\n+    buf->append (JvNewStringLatin1 (\"verification failed\"));\n+    if (pc == -1)\n+      pc = start_PC;\n+    if (pc != -1)\n+      {\n+\tbuf->append (JvNewStringLatin1 (\" at PC \"));\n+\tbuf->append (pc);\n+      }\n+\n+    _Jv_InterpMethod *method = current_method;\n+    buf->append (JvNewStringLatin1 (\" in \"));\n+    buf->append (current_class->getName());\n+    buf->append ((jchar) ':');\n+    buf->append (JvNewStringUTF (method->get_method()->name->data));\n+    buf->append ((jchar) '(');\n+    buf->append (JvNewStringUTF (method->get_method()->signature->data));\n+    buf->append ((jchar) ')');\n+\n+    buf->append (JvNewStringLatin1 (\": \"));\n+    buf->append (JvNewStringLatin1 (s));\n+    throw new java::lang::VerifyError (buf->toString ());\n+  }\n+\n public:\n \n   void verify_instructions ()\n@@ -2889,23 +2909,4 @@ _Jv_VerifyMethod (_Jv_InterpMethod *meth)\n   _Jv_BytecodeVerifier v (meth);\n   v.verify_instructions ();\n }\n-\n-// FIXME: add more info, like PC, when required.\n-static void\n-verify_fail (char *s, jint pc)\n-{\n-  using namespace java::lang;\n-  StringBuffer *buf = new StringBuffer ();\n-\n-  buf->append (JvNewStringLatin1 (\"verification failed\"));\n-  if (pc != -1)\n-    {\n-      buf->append (JvNewStringLatin1 (\" at PC \"));\n-      buf->append (pc);\n-    }\n-  buf->append (JvNewStringLatin1 (\": \"));\n-  buf->append (JvNewStringLatin1 (s));\n-  throw new java::lang::VerifyError (buf->toString ());\n-}\n-\n #endif\t/* INTERPRETER */"}]}