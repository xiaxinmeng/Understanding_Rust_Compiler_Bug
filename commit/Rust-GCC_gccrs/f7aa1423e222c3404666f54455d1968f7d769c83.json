{"sha": "f7aa1423e222c3404666f54455d1968f7d769c83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdhYTE0MjNlMjIyYzM0MDQ2NjZmNTQ0NTVkMTk2OGY3ZDc2OWM4Mw==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-01-26T17:26:33Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-01-26T17:26:33Z"}, "message": "re PR middle-end/16585 (current_function_has_computed_jump incorrectly changed in make_edges)\n\n\tPR middle-end/16585\n\t* cfgbuild.c (make_edges): Do not clear or set\n\tcurrent_function_has_computed_jump.\n\t* function.h (struct function): Remove the has_computed_jump field.\n\t(current_function_has_computed_jump): Do not define.\n\t* sched-rgn.c (is_cfg_nonregular): Return true if a basic block ends\n\tin a computed jump.  Ignore current_function_has_computed_jump.\n\nFrom-SVN: r94269", "tree": {"sha": "01482693087a7300ccd5d02237745f640bf1246e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01482693087a7300ccd5d02237745f640bf1246e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7aa1423e222c3404666f54455d1968f7d769c83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7aa1423e222c3404666f54455d1968f7d769c83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7aa1423e222c3404666f54455d1968f7d769c83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7aa1423e222c3404666f54455d1968f7d769c83/comments", "author": null, "committer": null, "parents": [{"sha": "b929615a7c328c01cc7ebd7010938f504f6356b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b929615a7c328c01cc7ebd7010938f504f6356b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b929615a7c328c01cc7ebd7010938f504f6356b3"}], "stats": {"total": 49, "additions": 17, "deletions": 32}, "files": [{"sha": "51b273e0d9736a452ae4992ac1c367d59f6f854e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7aa1423e222c3404666f54455d1968f7d769c83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7aa1423e222c3404666f54455d1968f7d769c83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7aa1423e222c3404666f54455d1968f7d769c83", "patch": "@@ -1,3 +1,13 @@\n+2005-01-26  Steven Bosscher  <stevenb@suse.de>\n+\n+\tPR middle-end/16585\n+\t* cfgbuild.c (make_edges): Do not clear or set\n+\tcurrent_function_has_computed_jump.\n+\t* function.h (struct function): Remove the has_computed_jump field.\n+\t(current_function_has_computed_jump): Do not define.\n+\t* sched-rgn.c (is_cfg_nonregular): Return true if a basic block ends\n+\tin a computed jump.  Ignore current_function_has_computed_jump.\n+\n 2005-01-26  Richard Henderson  <rth@redhat.com>\n \n \tPR middle-end/19515"}, {"sha": "7f3e72b9ff50486fe560ec4ef73f523fb70612f8", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7aa1423e222c3404666f54455d1968f7d769c83/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7aa1423e222c3404666f54455d1968f7d769c83/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=f7aa1423e222c3404666f54455d1968f7d769c83", "patch": "@@ -227,18 +227,6 @@ make_edges (basic_block min, basic_block max, int update_p)\n   basic_block bb;\n   sbitmap *edge_cache = NULL;\n \n-  /* Assume no computed jump; revise as we create edges.  */\n-  current_function_has_computed_jump = 0;\n-\n-  /* If we are partitioning hot and cold basic blocks into separate\n-     sections, we cannot assume there is no computed jump (partitioning\n-     sometimes requires the use of indirect jumps; see comments about\n-     partitioning at the top of bb-reorder.c:partition_hot_cold_basic_blocks \n-     for complete details).  */\n-\n-  if (flag_reorder_blocks_and_partition)\n-    current_function_has_computed_jump = 1;\n-\n   /* Heavy use of computed goto in machine-generated code can lead to\n      nearly fully-connected CFGs.  In that case we spend a significant\n      amount of time searching the edge lists for duplicates.  */\n@@ -325,8 +313,6 @@ make_edges (basic_block min, basic_block max, int update_p)\n \t     everything on the forced_labels list.  */\n \t  else if (computed_jump_p (insn))\n \t    {\n-\t      current_function_has_computed_jump = 1;\n-\n \t      for (x = forced_labels; x; x = XEXP (x, 1))\n \t\tmake_label_edge (edge_cache, bb, XEXP (x, 0), EDGE_ABNORMAL);\n \t    }"}, {"sha": "1284becb47a6851cf2fc7c47fdb37b2445afcc68", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7aa1423e222c3404666f54455d1968f7d769c83/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7aa1423e222c3404666f54455d1968f7d769c83/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=f7aa1423e222c3404666f54455d1968f7d769c83", "patch": "@@ -375,9 +375,6 @@ struct function GTY(())\n   /* Nonzero if function being compiled contains nested functions.  */\n   unsigned int contains_functions : 1;\n \n-  /* Nonzero if the function being compiled issues a computed jump.  */\n-  unsigned int has_computed_jump : 1;\n-\n   /* Nonzero if the current function is a thunk, i.e., a lightweight\n      function implemented by the output_mi_thunk hook) that just\n      adjusts one of its arguments and forwards to another\n@@ -447,7 +444,6 @@ extern int trampolines_created;\n #define current_function_calls_setjmp (cfun->calls_setjmp)\n #define current_function_calls_alloca (cfun->calls_alloca)\n #define current_function_calls_eh_return (cfun->calls_eh_return)\n-#define current_function_has_computed_jump (cfun->has_computed_jump)\n #define current_function_contains_functions (cfun->contains_functions)\n #define current_function_is_thunk (cfun->is_thunk)\n #define current_function_args_info (cfun->args_info)"}, {"sha": "d5004e4e0327551f563bd8d6b1918b2c2367b091", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7aa1423e222c3404666f54455d1968f7d769c83/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7aa1423e222c3404666f54455d1968f7d769c83/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=f7aa1423e222c3404666f54455d1968f7d769c83", "patch": "@@ -291,7 +291,6 @@ is_cfg_nonregular (void)\n {\n   basic_block b;\n   rtx insn;\n-  RTX_CODE code;\n \n   /* If we have a label that could be the target of a nonlocal goto, then\n      the cfg is not well structured.  */\n@@ -302,11 +301,6 @@ is_cfg_nonregular (void)\n   if (forced_labels)\n     return 1;\n \n-  /* If this function has a computed jump, then we consider the cfg\n-     not well structured.  */\n-  if (current_function_has_computed_jump)\n-    return 1;\n-\n   /* If we have exception handlers, then we consider the cfg not well\n      structured.  ?!?  We should be able to handle this now that flow.c\n      computes an accurate cfg for EH.  */\n@@ -315,24 +309,23 @@ is_cfg_nonregular (void)\n \n   /* If we have non-jumping insns which refer to labels, then we consider\n      the cfg not well structured.  */\n-  /* Check for labels referred to other thn by jumps.  */\n   FOR_EACH_BB (b)\n-    for (insn = BB_HEAD (b); ; insn = NEXT_INSN (insn))\n+    FOR_BB_INSNS (b, insn)\n       {\n-\tcode = GET_CODE (insn);\n-\tif (INSN_P (insn) && code != JUMP_INSN)\n+\t/* Check for labels referred by non-jump insns.  */\n+\tif (NONJUMP_INSN_P (insn) || CALL_P (insn))\n \t  {\n \t    rtx note = find_reg_note (insn, REG_LABEL, NULL_RTX);\n-\n \t    if (note\n \t\t&& ! (JUMP_P (NEXT_INSN (insn))\n \t\t      && find_reg_note (NEXT_INSN (insn), REG_LABEL,\n \t\t\t\t\tXEXP (note, 0))))\n \t      return 1;\n \t  }\n-\n-\tif (insn == BB_END (b))\n-\t  break;\n+\t/* If this function has a computed jump, then we consider the cfg\n+\t   not well structured.  */\n+\telse if (JUMP_P (insn) && computed_jump_p (insn))\n+\t  return 1;\n       }\n \n   /* Unreachable loops with more than one basic block are detected"}]}