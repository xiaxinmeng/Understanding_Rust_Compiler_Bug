{"sha": "d59c53465154c8217f8d5f1fc3e53e78a170ee9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU5YzUzNDY1MTU0YzgyMTdmOGQ1ZjFmYzNlNTNlNzhhMTcwZWU5YQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dan@cgsoftware.com", "date": "2001-08-28T23:43:23Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2001-08-28T23:43:23Z"}, "message": "df.h (struct df): Add rts_order variable.\n\n2001-08-28  Daniel Berlin  <dan@cgsoftware.com>\n\n\t* df.h (struct df): Add rts_order variable.\n\n\t* df.c (df_visit_next_rts): New function.\n\t(df_visit_next): Renamed to df_visit_next_rc\n\t(df_analyse_1): Allocate/compute/free rts_order as well.\n\t(df_rd_global_compute): Use df_visit_next_rc instead of\n\tdf_visit_next.\n\t(df_ru_global_compute): Use df_visit_next_rts instead of\n\tdf_visit_next.\n\n\t* flow.c (flow_reverse_top_sort_order_compute): New function.\n\n\t* basic-block.h: Add prototype.\n\nFrom-SVN: r45246", "tree": {"sha": "09a663683554d8dfc61afec1cf2ad7d6ea9e5cbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09a663683554d8dfc61afec1cf2ad7d6ea9e5cbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d59c53465154c8217f8d5f1fc3e53e78a170ee9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d59c53465154c8217f8d5f1fc3e53e78a170ee9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d59c53465154c8217f8d5f1fc3e53e78a170ee9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d59c53465154c8217f8d5f1fc3e53e78a170ee9a/comments", "author": null, "committer": null, "parents": [{"sha": "e0c39f1bd5bba4eede3377639e00a5cce968291e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0c39f1bd5bba4eede3377639e00a5cce968291e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0c39f1bd5bba4eede3377639e00a5cce968291e"}], "stats": {"total": 114, "additions": 108, "deletions": 6}, "files": [{"sha": "648b5f5cef6ec3bda273584280936fb082166b73", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d59c53465154c8217f8d5f1fc3e53e78a170ee9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d59c53465154c8217f8d5f1fc3e53e78a170ee9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d59c53465154c8217f8d5f1fc3e53e78a170ee9a", "patch": "@@ -1,3 +1,19 @@\n+2001-08-28  Daniel Berlin  <dan@cgsoftware.com>\n+\n+\t* df.h (struct df): Add rts_order variable.\n+\n+\t* df.c (df_visit_next_rts): New function.\n+\t(df_visit_next): Renamed to df_visit_next_rc\n+\t(df_analyse_1): Allocate/compute/free rts_order as well.\n+\t(df_rd_global_compute): Use df_visit_next_rc instead of\n+\tdf_visit_next.\n+\t(df_ru_global_compute): Use df_visit_next_rts instead of\n+\tdf_visit_next.\n+\t\n+\t* flow.c (flow_reverse_top_sort_order_compute): New function.\n+\n+\t* basic-block.h: Add prototype.\n+\n 2001-08-28  Daniel Berlin  <dan@cgsoftware.com>\n \n \t* ssa-ccp.c (ssa_ccp_df_delete_unreachable_insns): For unreachable"}, {"sha": "b8754948fecd8516d85ffb49af46868ca10ed5ec", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d59c53465154c8217f8d5f1fc3e53e78a170ee9a/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d59c53465154c8217f8d5f1fc3e53e78a170ee9a/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=d59c53465154c8217f8d5f1fc3e53e78a170ee9a", "patch": "@@ -310,6 +310,7 @@ extern int flow_delete_block\t\tPARAMS ((basic_block));\n extern void merge_blocks_nomove\t\tPARAMS ((basic_block, basic_block));\n extern void tidy_fallthru_edge\t\tPARAMS ((edge, basic_block,\n \t\t\t\t\t\t basic_block));\n+extern void flow_reverse_top_sort_order_compute\tPARAMS ((int *));\n extern int flow_depth_first_order_compute\tPARAMS ((int *, int *));\n extern void dump_edge_info\t\tPARAMS ((FILE *, edge, int));\n extern void clear_edges\t\t\tPARAMS ((void));"}, {"sha": "177da1051266c28b367fbb64b21986a5054d9e65", "filename": "gcc/df.c", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d59c53465154c8217f8d5f1fc3e53e78a170ee9a/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d59c53465154c8217f8d5f1fc3e53e78a170ee9a/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=d59c53465154c8217f8d5f1fc3e53e78a170ee9a", "patch": "@@ -238,7 +238,8 @@ static void df_insn_refs_record PARAMS((struct df *, basic_block, rtx));\n static void df_bb_refs_record PARAMS((struct df *, basic_block));\n static void df_refs_record PARAMS((struct df *, bitmap));\n \n-static int df_visit_next PARAMS ((struct df *, sbitmap));\n+static int df_visit_next_rc PARAMS ((struct df *, sbitmap));\n+static int df_visit_next_rts PARAMS ((struct df *, sbitmap));\n static void df_bb_reg_def_chain_create PARAMS((struct df *, basic_block));\n static void df_reg_def_chain_create PARAMS((struct df *, bitmap));\n static void df_bb_reg_use_chain_create PARAMS((struct df *, basic_block));\n@@ -1600,11 +1601,11 @@ df_ud_chain_create (df, blocks)\n }\n \f\n \n-/* Use depth first order, and the worklist, to figure out what block\n+/* Use reverse completion order, and the worklist, to figure out what block\n    to look at next.  */\n \n static int\n-df_visit_next (df, blocks)\n+df_visit_next_rc (df, blocks)\n      struct df *df ATTRIBUTE_UNUSED;\n      sbitmap blocks;\n {\n@@ -1615,6 +1616,22 @@ df_visit_next (df, blocks)\n   return sbitmap_first_set_bit (blocks);\n }\n \n+/* Use reverse topsort order, and the worklist, to figure out what block\n+   to look at next.  */\n+\n+static int\n+df_visit_next_rts (df, blocks)\n+     struct df *df ATTRIBUTE_UNUSED;\n+     sbitmap blocks;\n+{\n+  int i=0;\n+  for (i = 0; i < n_basic_blocks; i++)\n+    if (TEST_BIT (blocks, df->rts_order[i]))\n+      return df->rts_order[i];\n+  return sbitmap_first_set_bit (blocks);\n+}\n+\n+\n /* Calculate reaching defs for each basic block in BLOCKS, i.e., the\n    defs that are live at the start of a basic block.  */\n static void\n@@ -1644,7 +1661,7 @@ df_rd_global_compute (df, blocks)\n       bitmap_copy (bb_info->rd_out, bb_info->rd_gen);\n     });\n   \n-  while ((i = df_visit_next (df, worklist)) >= 0)\n+  while ((i = df_visit_next_rc (df, worklist)) >= 0)\n     {\n       struct bb_info *bb_info;\n       edge e;\n@@ -1722,7 +1739,7 @@ df_ru_global_compute (df, blocks)\n     });\n \n \n-  while ((i = df_visit_next (df, worklist)) >= 0)\n+  while ((i = df_visit_next_rts (df, worklist)) >= 0)\n     {\n       struct bb_info *bb_info;\n       edge e;\n@@ -2221,9 +2238,10 @@ df_analyse_1 (df, blocks, flags, update)\n \n   df->dfs_order = xmalloc (sizeof(int) * n_basic_blocks);\n   df->rc_order = xmalloc (sizeof(int) * n_basic_blocks);\n+  df->rts_order = xmalloc (sizeof(int) * n_basic_blocks);\n   \n   flow_depth_first_order_compute (df->dfs_order, df->rc_order);\n-\n+  flow_reverse_top_sort_order_compute (df->rts_order);\n   if (aflags & DF_RD)\n     {\n       /* Compute the sets of gens and kills for the defs of each bb.  */\n@@ -2280,6 +2298,7 @@ df_analyse_1 (df, blocks, flags, update)\n     } \n   free (df->dfs_order);\n   free (df->rc_order);\n+  free (df->rts_order);\n }\n \n "}, {"sha": "c550afaee6721b26b6c38a366b633852e88141d2", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d59c53465154c8217f8d5f1fc3e53e78a170ee9a/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d59c53465154c8217f8d5f1fc3e53e78a170ee9a/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=d59c53465154c8217f8d5f1fc3e53e78a170ee9a", "patch": "@@ -140,6 +140,7 @@ struct df\n   bitmap *dom;\n   int * dfs_order;\n   int * rc_order;\n+  int * rts_order;\n };\n \n "}, {"sha": "8ca087757dd443cebce408db48cc1fa1fb4afb09", "filename": "gcc/flow.c", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d59c53465154c8217f8d5f1fc3e53e78a170ee9a/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d59c53465154c8217f8d5f1fc3e53e78a170ee9a/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=d59c53465154c8217f8d5f1fc3e53e78a170ee9a", "patch": "@@ -9466,6 +9466,71 @@ flow_loop_nodes_find (header, latch, nodes)\n   return num_nodes;\n }\n \n+/* Compute reverse top sort order */\n+void\n+flow_reverse_top_sort_order_compute (rts_order)\n+     int *rts_order;\n+{\n+  edge *stack;\n+  int sp;\n+  int postnum = 0;\n+  sbitmap visited;\n+\n+  /* Allocate stack for back-tracking up CFG.  */\n+  stack = (edge *) xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n+  sp = 0;\n+\n+  /* Allocate bitmap to track nodes that have been visited.  */\n+  visited = sbitmap_alloc (n_basic_blocks);\n+\n+  /* None of the nodes in the CFG have been visited yet.  */\n+  sbitmap_zero (visited);\n+\n+  /* Push the first edge on to the stack.  */\n+  stack[sp++] = ENTRY_BLOCK_PTR->succ;\n+\n+  while (sp)\n+    {\n+      edge e;\n+      basic_block src;\n+      basic_block dest;\n+\n+      /* Look at the edge on the top of the stack.  */\n+      e = stack[sp - 1];\n+      src = e->src;\n+      dest = e->dest;\n+\n+      /* Check if the edge destination has been visited yet.  */\n+      if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index))\n+\t{\n+\t  /* Mark that we have visited the destination.  */\n+\t  SET_BIT (visited, dest->index);\n+\n+\t  if (dest->succ)\n+\t    {\n+\t      /* Since the DEST node has been visited for the first\n+\t\t time, check its successors.  */\n+\t      stack[sp++] = dest->succ;\n+\t    }\n+\t  else\n+\t    rts_order[postnum++] = dest->index;\n+\t}\n+      else\n+\t{\n+\t  if (! e->succ_next && src != ENTRY_BLOCK_PTR)\n+\t   rts_order[postnum++] = src->index;\n+\n+\t  if (e->succ_next)\n+\t    stack[sp - 1] = e->succ_next;\n+\t  else\n+\t    sp--;\n+\t}\n+    }\n+\n+  free (stack);\n+  sbitmap_free (visited);\n+}\n+\n /* Compute the depth first search order and store in the array\n   DFS_ORDER if non-zero, marking the nodes visited in VISITED.  If\n   RC_ORDER is non-zero, return the reverse completion number for each"}]}