{"sha": "0485ce9128f272fe7ccb48672f69d7be6bb26a9c", "node_id": "C_kwDOANBUbNoAKDA0ODVjZTkxMjhmMjcyZmU3Y2NiNDg2NzJmNjlkN2JlNmJiMjZhOWM", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2021-12-04T03:17:18Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2021-12-08T01:14:02Z"}, "message": "[PR103149] detach values through mem only if general regs won't do\n\nWhen hardening compares or conditional branches, we perform redundant\ntests, and to prevent them from being optimized out, we use asm\nstatements that preserve a value used in a compare, but in a way that\nthe compiler can no longer assume it's the same value, so it can't\noptimize the redundant test away.\n\nWe used to use +g, but that requires general regs or mem.  You might\nthink that, if a reg constraint can't be satisfied, the register\nallocator will fall back to memory, but that's not so: we decide on\nmatching MEMs very early on, by using the same addressable operand on\nboth input and output, and only if the constraint does not allow\nregisters.  If it does, we use gimple registers and then pseudos as\ninputs and outputs, and then inputs can be substituted by equivalent\nexpressions, and then, if no register contraint fits (e.g. because\nthat mode won't fit in general regs, or won't fit in regs at all), the\nregister allocator will give up before even trying to allocate some\ntemporary memory to unify input and output.\n\nThis patch arranges for us to create and use the temporary stack slot\nif we can tell the mode requires memory, or won't otherwise fit in\ngeneral regs, and thus to use +m for that asm.\n\n\nfor  gcc/ChangeLog\n\n\tPR middle-end/103149\n\t* gimple-harden-conditionals.cc (detach_value): Use memory if\n\tgeneral regs won't do.\n\nfor  gcc/testsuite/ChangeLog\n\n\tPR middle-end/103149\n\t* gcc.target/aarch64/pr103149.c: New.", "tree": {"sha": "d93e13b124e2130e2a4fd57cd3582b3cd37e0a5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d93e13b124e2130e2a4fd57cd3582b3cd37e0a5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0485ce9128f272fe7ccb48672f69d7be6bb26a9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0485ce9128f272fe7ccb48672f69d7be6bb26a9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0485ce9128f272fe7ccb48672f69d7be6bb26a9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0485ce9128f272fe7ccb48672f69d7be6bb26a9c/comments", "author": null, "committer": null, "parents": [{"sha": "1f6b0003b6601656bef4869d9c724e2a263cb64c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6b0003b6601656bef4869d9c724e2a263cb64c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f6b0003b6601656bef4869d9c724e2a263cb64c"}], "stats": {"total": 81, "additions": 75, "deletions": 6}, "files": [{"sha": "81867d6e4275fcd28657b3bb7e9f638ff4b30369", "filename": "gcc/gimple-harden-conditionals.cc", "status": "modified", "additions": 61, "deletions": 6, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0485ce9128f272fe7ccb48672f69d7be6bb26a9c/gcc%2Fgimple-harden-conditionals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0485ce9128f272fe7ccb48672f69d7be6bb26a9c/gcc%2Fgimple-harden-conditionals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-harden-conditionals.cc?ref=0485ce9128f272fe7ccb48672f69d7be6bb26a9c", "patch": "@@ -22,6 +22,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"backend.h\"\n+#include \"target.h\"\n+#include \"rtl.h\"\n #include \"tree.h\"\n #include \"fold-const.h\"\n #include \"gimple.h\"\n@@ -132,25 +134,78 @@ detach_value (location_t loc, gimple_stmt_iterator *gsip, tree val)\n   tree ret = make_ssa_name (TREE_TYPE (val));\n   SET_SSA_NAME_VAR_OR_IDENTIFIER (ret, SSA_NAME_IDENTIFIER (val));\n \n-  /* Output asm (\"\" : \"=g\" (ret) : \"0\" (val));  */\n+  /* Some modes won't fit in general regs, so we fall back to memory\n+     for them.  ??? It would be ideal to try to identify an alternate,\n+     wider or more suitable register class, and use the corresponding\n+     constraint, but there's no logic to go from register class to\n+     constraint, even if there is a corresponding constraint, and even\n+     if we could enumerate constraints, we can't get to their string\n+     either.  So this will do for now.  */\n+  bool need_memory = true;\n+  enum machine_mode mode = TYPE_MODE (TREE_TYPE (val));\n+  if (mode != BLKmode)\n+    for (int i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+      if (TEST_HARD_REG_BIT (reg_class_contents[GENERAL_REGS], i)\n+\t  && targetm.hard_regno_mode_ok (i, mode))\n+\t{\n+\t  need_memory = false;\n+\t  break;\n+\t}\n+\n+  tree asminput = val;\n+  tree asmoutput = ret;\n+  const char *constraint_out = need_memory ? \"=m\" : \"=g\";\n+  const char *constraint_in = need_memory ? \"m\" : \"0\";\n+\n+  if (need_memory)\n+    {\n+      tree temp = create_tmp_var (TREE_TYPE (val), \"dtch\");\n+      mark_addressable (temp);\n+\n+      gassign *copyin = gimple_build_assign (temp, asminput);\n+      gimple_set_location (copyin, loc);\n+      gsi_insert_before (gsip, copyin, GSI_SAME_STMT);\n+\n+      asminput = asmoutput = temp;\n+    }\n+\n+  /* Output an asm statement with matching input and output.  It does\n+     nothing, but after it the compiler no longer knows the output\n+     still holds the same value as the input.  */\n   vec<tree, va_gc> *inputs = NULL;\n   vec<tree, va_gc> *outputs = NULL;\n   vec_safe_push (outputs,\n \t\t build_tree_list\n \t\t (build_tree_list\n-\t\t  (NULL_TREE, build_string (2, \"=g\")),\n-\t\t  ret));\n+\t\t  (NULL_TREE, build_string (strlen (constraint_out),\n+\t\t\t\t\t    constraint_out)),\n+\t\t  asmoutput));\n   vec_safe_push (inputs,\n \t\t build_tree_list\n \t\t (build_tree_list\n-\t\t  (NULL_TREE, build_string (1, \"0\")),\n-\t\t  val));\n+\t\t  (NULL_TREE, build_string (strlen (constraint_in),\n+\t\t\t\t\t    constraint_in)),\n+\t\t  asminput));\n   gasm *detach = gimple_build_asm_vec (\"\", inputs, outputs,\n \t\t\t\t       NULL, NULL);\n   gimple_set_location (detach, loc);\n   gsi_insert_before (gsip, detach, GSI_SAME_STMT);\n \n-  SSA_NAME_DEF_STMT (ret) = detach;\n+  if (need_memory)\n+    {\n+      gassign *copyout = gimple_build_assign (ret, asmoutput);\n+      gimple_set_location (copyout, loc);\n+      gsi_insert_before (gsip, copyout, GSI_SAME_STMT);\n+      SSA_NAME_DEF_STMT (ret) = copyout;\n+\n+      gassign *clobber = gimple_build_assign (asmoutput,\n+\t\t\t\t\t      build_clobber\n+\t\t\t\t\t      (TREE_TYPE (asmoutput)));\n+      gimple_set_location (clobber, loc);\n+      gsi_insert_before (gsip, clobber, GSI_SAME_STMT);\n+    }\n+  else\n+    SSA_NAME_DEF_STMT (ret) = detach;\n \n   return ret;\n }"}, {"sha": "906bc9ae066122dfc42e594f483679986587fe1c", "filename": "gcc/testsuite/gcc.target/aarch64/pr103149.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0485ce9128f272fe7ccb48672f69d7be6bb26a9c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr103149.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0485ce9128f272fe7ccb48672f69d7be6bb26a9c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr103149.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr103149.c?ref=0485ce9128f272fe7ccb48672f69d7be6bb26a9c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=armv8-a+sve -O2 -fharden-conditional-branches -fno-tree-scev-cprop\" } */\n+\n+/* -fharden-conditional-branches prevents optimization of its redundant\n+   compares by detaching values from the operands with asm statements.  They\n+   used to require GENERAL_REGS, but the vectorized booleans, generated while\n+   vectorizing this function, can't be held in GENERAL_REGS.  */\n+\n+void\n+foo (int *p)\n+{\n+  while (*p < 1)\n+    ++*p;\n+}"}]}