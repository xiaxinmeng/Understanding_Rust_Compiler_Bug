{"sha": "b27cedc6118a669f16a441f2ac287b72e7f8ccac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI3Y2VkYzYxMThhNjY5ZjE2YTQ0MWYyYWMyODdiNzJlN2Y4Y2NhYw==", "commit": {"author": {"name": "James E Wilson", "email": "wilson@specifixinc.com", "date": "2005-10-15T16:34:13Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2005-10-15T16:34:13Z"}, "message": "Fix IA-64 sched-ebb failure due to missing dependencies.\n\nPR target/24232\n* sched-deps.c (add_dependence_list): New arg UNCOND.  Fix all callers.\n(add_dependence_list_and_free): Likewise.\n(sched_analyze_2, case MEM): Delete sched_insns_conditions_mutex_p\ncall.\n\nFrom-SVN: r105437", "tree": {"sha": "f07d6a47496bf0775564a88464e5798b524c1529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f07d6a47496bf0775564a88464e5798b524c1529"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b27cedc6118a669f16a441f2ac287b72e7f8ccac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b27cedc6118a669f16a441f2ac287b72e7f8ccac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b27cedc6118a669f16a441f2ac287b72e7f8ccac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b27cedc6118a669f16a441f2ac287b72e7f8ccac/comments", "author": null, "committer": null, "parents": [{"sha": "2d33a2effdaf3e8405a2fa05c3bf863ce6c4f1ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d33a2effdaf3e8405a2fa05c3bf863ce6c4f1ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d33a2effdaf3e8405a2fa05c3bf863ce6c4f1ee"}], "stats": {"total": 91, "additions": 50, "deletions": 41}, "files": [{"sha": "b4ef9c95b880d031a1518174bc1141e86a2fda52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b27cedc6118a669f16a441f2ac287b72e7f8ccac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b27cedc6118a669f16a441f2ac287b72e7f8ccac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b27cedc6118a669f16a441f2ac287b72e7f8ccac", "patch": "@@ -1,3 +1,11 @@\n+2005-10-15  James E Wilson  <wilson@specifix.com>\n+\n+\tPR target/24232\n+\t* sched-deps.c (add_dependence_list): New arg UNCOND.  Fix all callers.\n+\t(add_dependence_list_and_free): Likewise.\n+\t(sched_analyze_2, case MEM): Delete sched_insns_conditions_mutex_p\n+\tcall.\n+\n 2005-10-15  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR 23141"}, {"sha": "25dccb76dcd2f4d270b93f389fa187e7c5d81b26", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b27cedc6118a669f16a441f2ac287b72e7f8ccac/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b27cedc6118a669f16a441f2ac287b72e7f8ccac/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=b27cedc6118a669f16a441f2ac287b72e7f8ccac", "patch": "@@ -87,8 +87,8 @@ static bitmap_head *forward_dependency_cache;\n #endif\n \n static int deps_may_trap_p (rtx);\n-static void add_dependence_list (rtx, rtx, enum reg_note);\n-static void add_dependence_list_and_free (rtx, rtx *, enum reg_note);\n+static void add_dependence_list (rtx, rtx, int, enum reg_note);\n+static void add_dependence_list_and_free (rtx, rtx *, int, enum reg_note);\n static void delete_all_dependences (rtx);\n static void fixup_sched_groups (rtx);\n \n@@ -346,25 +346,26 @@ add_dependence (rtx insn, rtx elem, enum reg_note dep_type)\n /* A convenience wrapper to operate on an entire list.  */\n \n static void\n-add_dependence_list (rtx insn, rtx list, enum reg_note dep_type)\n+add_dependence_list (rtx insn, rtx list, int uncond, enum reg_note dep_type)\n {\n   for (; list; list = XEXP (list, 1))\n     {\n-      if (! sched_insns_conditions_mutex_p (insn, XEXP (list, 0)))\n+      if (uncond || ! sched_insns_conditions_mutex_p (insn, XEXP (list, 0)))\n \tadd_dependence (insn, XEXP (list, 0), dep_type);\n     }\n }\n \n /* Similar, but free *LISTP at the same time.  */\n \n static void\n-add_dependence_list_and_free (rtx insn, rtx *listp, enum reg_note dep_type)\n+add_dependence_list_and_free (rtx insn, rtx *listp, int uncond,\n+\t\t\t      enum reg_note dep_type)\n {\n   rtx list, next;\n   for (list = *listp, *listp = NULL; list ; list = next)\n     {\n       next = XEXP (list, 1);\n-      if (! sched_insns_conditions_mutex_p (insn, XEXP (list, 0)))\n+      if (uncond || ! sched_insns_conditions_mutex_p (insn, XEXP (list, 0)))\n \tadd_dependence (insn, XEXP (list, 0), dep_type);\n       free_INSN_LIST_node (list);\n     }\n@@ -468,17 +469,17 @@ flush_pending_lists (struct deps *deps, rtx insn, int for_read,\n {\n   if (for_write)\n     {\n-      add_dependence_list_and_free (insn, &deps->pending_read_insns,\n+      add_dependence_list_and_free (insn, &deps->pending_read_insns, 0,\n \t\t\t\t    REG_DEP_ANTI);\n       free_EXPR_LIST_list (&deps->pending_read_mems);\n     }\n \n-  add_dependence_list_and_free (insn, &deps->pending_write_insns,\n+  add_dependence_list_and_free (insn, &deps->pending_write_insns, 0,\n \t\t\t\tfor_read ? REG_DEP_ANTI : REG_DEP_OUTPUT);\n   free_EXPR_LIST_list (&deps->pending_write_mems);\n   deps->pending_lists_length = 0;\n \n-  add_dependence_list_and_free (insn, &deps->last_pending_memory_flush,\n+  add_dependence_list_and_free (insn, &deps->last_pending_memory_flush, 1,\n \t\t\t\tfor_read ? REG_DEP_ANTI : REG_DEP_OUTPUT);\n   deps->last_pending_memory_flush = alloc_INSN_LIST (insn, NULL_RTX);\n   deps->pending_flush_length = 1;\n@@ -595,7 +596,8 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n \t  /* Don't let it cross a call after scheduling if it doesn't\n \t     already cross one.  */\n \t  if (REG_N_CALLS_CROSSED (regno) == 0)\n-\t    add_dependence_list (insn, deps->last_function_call, REG_DEP_ANTI);\n+\t    add_dependence_list (insn, deps->last_function_call, 1,\n+\t\t\t\t REG_DEP_ANTI);\n \t}\n     }\n   else if (MEM_P (dest))\n@@ -648,7 +650,7 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n \t      pending_mem = XEXP (pending_mem, 1);\n \t    }\n \n-\t  add_dependence_list (insn, deps->last_pending_memory_flush,\n+\t  add_dependence_list (insn, deps->last_pending_memory_flush, 1,\n \t\t\t       REG_DEP_ANTI);\n \n \t  add_insn_mem_dependence (deps, &deps->pending_write_insns,\n@@ -791,8 +793,7 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n \t  }\n \n \tfor (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n-\t  if ((! JUMP_P (XEXP (u, 0)) || deps_may_trap_p (x))\n-\t      && ! sched_insns_conditions_mutex_p (insn, XEXP (u, 0)))\n+\t  if (! JUMP_P (XEXP (u, 0)) || deps_may_trap_p (x))\n \t    add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \n \t/* Always add these dependencies to pending_reads, since\n@@ -903,7 +904,7 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t and others know that a value is dead.  Depend on the last call\n \t instruction so that reg-stack won't get confused.  */\n       if (code == CLOBBER)\n-\tadd_dependence_list (insn, deps->last_function_call, REG_DEP_OUTPUT);\n+\tadd_dependence_list (insn, deps->last_function_call, 1, REG_DEP_OUTPUT);\n     }\n   else if (code == PARALLEL)\n     {\n@@ -960,8 +961,8 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t  EXECUTE_IF_SET_IN_REG_SET (&tmp_uses, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n-\t      add_dependence_list (insn, reg_last->sets, REG_DEP_ANTI);\n-\t      add_dependence_list (insn, reg_last->clobbers, REG_DEP_ANTI);\n+\t      add_dependence_list (insn, reg_last->sets, 0, REG_DEP_ANTI);\n+\t      add_dependence_list (insn, reg_last->clobbers, 0, REG_DEP_ANTI);\n \t      reg_last->uses_length++;\n \t      reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);\n \t    }\n@@ -995,7 +996,7 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t      pending_mem = XEXP (pending_mem, 1);\n \t    }\n \n-\t  add_dependence_list (insn, deps->last_pending_memory_flush,\n+\t  add_dependence_list (insn, deps->last_pending_memory_flush, 1,\n \t\t\t       REG_DEP_ANTI);\n \t}\n     }\n@@ -1038,12 +1039,12 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t  EXECUTE_IF_SET_IN_REG_SET (&deps->reg_last_in_use, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n-\t      add_dependence_list (insn, reg_last->uses, REG_DEP_ANTI);\n+\t      add_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);\n \t      add_dependence_list\n-\t\t(insn, reg_last->sets,\n+\t\t(insn, reg_last->sets, 0,\n \t\t reg_pending_barrier == TRUE_BARRIER ? REG_DEP_TRUE : REG_DEP_ANTI);\n \t      add_dependence_list\n-\t\t(insn, reg_last->clobbers,\n+\t\t(insn, reg_last->clobbers, 0,\n \t\t reg_pending_barrier == TRUE_BARRIER ? REG_DEP_TRUE : REG_DEP_ANTI);\n \t    }\n \t}\n@@ -1052,13 +1053,13 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t  EXECUTE_IF_SET_IN_REG_SET (&deps->reg_last_in_use, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n-\t      add_dependence_list_and_free (insn, &reg_last->uses,\n+\t      add_dependence_list_and_free (insn, &reg_last->uses, 0,\n \t\t\t\t\t    REG_DEP_ANTI);\n \t      add_dependence_list_and_free\n-\t\t(insn, &reg_last->sets,\n+\t\t(insn, &reg_last->sets, 0,\n \t\t reg_pending_barrier == TRUE_BARRIER ? REG_DEP_TRUE : REG_DEP_ANTI);\n \t      add_dependence_list_and_free\n-\t\t(insn, &reg_last->clobbers,\n+\t\t(insn, &reg_last->clobbers, 0,\n \t\t reg_pending_barrier == TRUE_BARRIER ? REG_DEP_TRUE : REG_DEP_ANTI);\n \t      reg_last->uses_length = 0;\n \t      reg_last->clobbers_length = 0;\n@@ -1085,25 +1086,25 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n-\t      add_dependence_list (insn, reg_last->sets, REG_DEP_TRUE);\n-\t      add_dependence_list (insn, reg_last->clobbers, REG_DEP_TRUE);\n+\t      add_dependence_list (insn, reg_last->sets, 0, REG_DEP_TRUE);\n+\t      add_dependence_list (insn, reg_last->clobbers, 0, REG_DEP_TRUE);\n \t      reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);\n \t      reg_last->uses_length++;\n \t    }\n \t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_clobbers, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n-\t      add_dependence_list (insn, reg_last->sets, REG_DEP_OUTPUT);\n-\t      add_dependence_list (insn, reg_last->uses, REG_DEP_ANTI);\n+\t      add_dependence_list (insn, reg_last->sets, 0, REG_DEP_OUTPUT);\n+\t      add_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);\n \t      reg_last->clobbers = alloc_INSN_LIST (insn, reg_last->clobbers);\n \t      reg_last->clobbers_length++;\n \t    }\n \t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n-\t      add_dependence_list (insn, reg_last->sets, REG_DEP_OUTPUT);\n-\t      add_dependence_list (insn, reg_last->clobbers, REG_DEP_OUTPUT);\n-\t      add_dependence_list (insn, reg_last->uses, REG_DEP_ANTI);\n+\t      add_dependence_list (insn, reg_last->sets, 0, REG_DEP_OUTPUT);\n+\t      add_dependence_list (insn, reg_last->clobbers, 0, REG_DEP_OUTPUT);\n+\t      add_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);\n \t      reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);\n \t      SET_REGNO_REG_SET (&deps->reg_conditional_sets, i);\n \t    }\n@@ -1113,8 +1114,8 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n-\t      add_dependence_list (insn, reg_last->sets, REG_DEP_TRUE);\n-\t      add_dependence_list (insn, reg_last->clobbers, REG_DEP_TRUE);\n+\t      add_dependence_list (insn, reg_last->sets, 0, REG_DEP_TRUE);\n+\t      add_dependence_list (insn, reg_last->clobbers, 0, REG_DEP_TRUE);\n \t      reg_last->uses_length++;\n \t      reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);\n \t    }\n@@ -1124,32 +1125,32 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t      if (reg_last->uses_length > MAX_PENDING_LIST_LENGTH\n \t\t  || reg_last->clobbers_length > MAX_PENDING_LIST_LENGTH)\n \t\t{\n-\t\t  add_dependence_list_and_free (insn, &reg_last->sets,\n+\t\t  add_dependence_list_and_free (insn, &reg_last->sets, 0,\n \t\t\t\t\t        REG_DEP_OUTPUT);\n-\t\t  add_dependence_list_and_free (insn, &reg_last->uses,\n+\t\t  add_dependence_list_and_free (insn, &reg_last->uses, 0,\n \t\t\t\t\t\tREG_DEP_ANTI);\n-\t\t  add_dependence_list_and_free (insn, &reg_last->clobbers,\n+\t\t  add_dependence_list_and_free (insn, &reg_last->clobbers, 0,\n \t\t\t\t\t\tREG_DEP_OUTPUT);\n \t\t  reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);\n \t\t  reg_last->clobbers_length = 0;\n \t\t  reg_last->uses_length = 0;\n \t\t}\n \t      else\n \t\t{\n-\t\t  add_dependence_list (insn, reg_last->sets, REG_DEP_OUTPUT);\n-\t\t  add_dependence_list (insn, reg_last->uses, REG_DEP_ANTI);\n+\t\t  add_dependence_list (insn, reg_last->sets, 0, REG_DEP_OUTPUT);\n+\t\t  add_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);\n \t\t}\n \t      reg_last->clobbers_length++;\n \t      reg_last->clobbers = alloc_INSN_LIST (insn, reg_last->clobbers);\n \t    }\n \t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n-\t      add_dependence_list_and_free (insn, &reg_last->sets,\n+\t      add_dependence_list_and_free (insn, &reg_last->sets, 0,\n \t\t\t\t\t    REG_DEP_OUTPUT);\n-\t      add_dependence_list_and_free (insn, &reg_last->clobbers,\n+\t      add_dependence_list_and_free (insn, &reg_last->clobbers, 0,\n \t\t\t\t\t    REG_DEP_OUTPUT);\n-\t      add_dependence_list_and_free (insn, &reg_last->uses,\n+\t      add_dependence_list_and_free (insn, &reg_last->uses, 0,\n \t\t\t\t\t    REG_DEP_ANTI);\n \t      reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);\n \t      reg_last->uses_length = 0;\n@@ -1329,7 +1330,7 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n \n \t  /* For each insn which shouldn't cross a call, add a dependence\n \t     between that insn and this call insn.  */\n-\t  add_dependence_list_and_free (insn, &deps->sched_before_next_call,\n+\t  add_dependence_list_and_free (insn, &deps->sched_before_next_call, 1,\n \t\t\t\t\tREG_DEP_ANTI);\n \n \t  sched_analyze_insn (deps, PATTERN (insn), insn, loop_notes);"}]}