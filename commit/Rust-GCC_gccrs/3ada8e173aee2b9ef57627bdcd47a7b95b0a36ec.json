{"sha": "3ada8e173aee2b9ef57627bdcd47a7b95b0a36ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FkYThlMTczYWVlMmI5ZWY1NzYyN2JkY2Q0N2E3Yjk1YjBhMzZlYw==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-03-10T19:08:13Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-03-10T19:08:13Z"}, "message": "(SUBTARGET_SWITCHES): Renamed from ARM_EXTRA_TARGET_SWITCHES.\n\n(TARGET_HARD_FLOAT, TARGET_SOFT_FLOAT): Define.\n(TARGET_SWITCHES): Add -msoft-float, -mhard-float.\n(BYTES_BIG_ENDIAN): Delete #ifndef/#endif.\n(CONDITIONAL_REGISTER_USAGE): If -msoft-float, disable fp regs.\n(FUNCTION_VALUE): R16 is return reg only if !-msoft-float.\n(LIBCALL_VALUE): Likewise.\n\nFrom-SVN: r9161", "tree": {"sha": "bdcbd5bec077a947e24da8c9c9b1f4f19e025af4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdcbd5bec077a947e24da8c9c9b1f4f19e025af4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ada8e173aee2b9ef57627bdcd47a7b95b0a36ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ada8e173aee2b9ef57627bdcd47a7b95b0a36ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ada8e173aee2b9ef57627bdcd47a7b95b0a36ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ada8e173aee2b9ef57627bdcd47a7b95b0a36ec/comments", "author": null, "committer": null, "parents": [{"sha": "b9b7c1c9fd7cdb6717c5f58f80326f518158561f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9b7c1c9fd7cdb6717c5f58f80326f518158561f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9b7c1c9fd7cdb6717c5f58f80326f518158561f"}], "stats": {"total": 53, "additions": 31, "deletions": 22}, "files": [{"sha": "961c7f3c2aa9258013cfda6c36004fdbf1e6a295", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ada8e173aee2b9ef57627bdcd47a7b95b0a36ec/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ada8e173aee2b9ef57627bdcd47a7b95b0a36ec/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=3ada8e173aee2b9ef57627bdcd47a7b95b0a36ec", "patch": "@@ -92,14 +92,17 @@ extern int target_flags;\n    for the arm processor chip, but it is needed for some MMU chips.  */\n #define TARGET_SHORT_BY_BYTES\t(target_flags & 0x200)\n \n-/* ARM_EXTRA_TARGET_SWITCHES is used in riscix.h to define some options which\n-   are passed to the preprocessor and the assembler post-processor.  They\n-   aren't needed in the main pass of the compiler, but if we don't define\n-   them in target switches cc1 complains about them.  For the sake of\n-   argument lets allocate bit 31 of target flags for such options. */\n-\n-#ifndef ARM_EXTRA_TARGET_SWITCHES\n-#define ARM_EXTRA_TARGET_SWITCHES\n+/* Nonzero if GCC should use a floating point library.\n+   GCC will assume the fp regs don't exist and will not emit any fp insns.\n+   Note that this is different than fp emulation which still uses fp regs\n+   and insns - the kernel catches the trap and performs the operation.  */\n+#define TARGET_SOFT_FLOAT\t(target_flags & 0x400)\n+#define TARGET_HARD_FLOAT\t(! TARGET_SOFT_FLOAT)\n+\n+/* SUBTARGET_SWITCHES is used to add flags on a per-config basis.\n+   Bit 31 is reserved.  See riscix.h.  */\n+#ifndef SUBTARGET_SWITCHES\n+#define SUBTARGET_SWITCHES\n #endif\n \n #define TARGET_SWITCHES  \t\t\t\t\\\n@@ -114,7 +117,9 @@ extern int target_flags;\n   {\"no-short-load-bytes\",\t-(0x200)},\t\t\\\n   {\"short-load-words\", \t\t-(0x200)},\t\t\\\n   {\"no-short-load-words\",\t (0x200)},\t\t\\\n-  ARM_EXTRA_TARGET_SWITCHES\t\t\t\t\\\n+  {\"soft-float\",\t\t (0x400)},\t\t\\\n+  {\"hard-float\",\t\t-(0x400)},\t\t\\\n+  SUBTARGET_SWITCHES\t\t\t\t\t\\\n   {\"\",   \t\t \t TARGET_DEFAULT }\t\\\n }\n \n@@ -221,12 +226,10 @@ extern enum floating_point_type arm_fpu;\n #define BITS_BIG_ENDIAN  0\n \n /* Define this if most significant byte of a word is the lowest numbered.  \n-   Most ARM processors are run in little endian mode, but it should now be\n-   possible to build the compiler to support big endian code. (Note: This\n-   is currently a compiler-build-time option, not a run-time one.  */\n-#ifndef BYTES_BIG_ENDIAN\n+   Most ARM processors are run in little endian mode, so that is the default.\n+   If you want to have it run-time selectable, change the definition in a\n+   cover file to be TARGET_BIG_ENDIAN.  */\n #define BYTES_BIG_ENDIAN  0\n-#endif\n \n /* Define this if most significant word of a multiword number is the lowest\n    numbered.  */\n@@ -364,9 +367,15 @@ extern enum floating_point_type arm_fpu;\n    XXX It is a hack, I know.\n    XXX Is this still needed?  */\n #define CONDITIONAL_REGISTER_USAGE  \\\n-{\t\t\t\\\n-  if (obey_regdecls)\t\\\n-    fixed_regs[0] = 1;\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (obey_regdecls)\t\t\t\t\t\\\n+    fixed_regs[0] = 1;\t\t\t\t\t\\\n+  if (TARGET_SOFT_FLOAT)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      int regno;\t\t\t\t\t\\\n+      for (regno = 16; regno < 24; ++regno)\t\t\\\n+\tfixed_regs[regno] = call_used_regs[regno] = 1;\t\\\n+    }\t\t\t\t\t\t\t\\\n }\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n@@ -618,21 +627,21 @@ enum reg_class\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  (GET_MODE_CLASS (TYPE_MODE (VALTYPE)) == MODE_FLOAT  \\\n-   ? gen_rtx (REG, TYPE_MODE (VALTYPE), 16)            \\\n+  (GET_MODE_CLASS (TYPE_MODE (VALTYPE)) == MODE_FLOAT && TARGET_HARD_FLOAT \\\n+   ? gen_rtx (REG, TYPE_MODE (VALTYPE), 16) \\\n    : gen_rtx (REG, TYPE_MODE (VALTYPE), 0))\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n #define LIBCALL_VALUE(MODE)  \\\n-  (GET_MODE_CLASS (MODE) == MODE_FLOAT  \\\n-   ? gen_rtx (REG, MODE, 16)\t\t\\\n+  (GET_MODE_CLASS (MODE) == MODE_FLOAT && TARGET_HARD_FLOAT \\\n+   ? gen_rtx (REG, MODE, 16) \\\n    : gen_rtx (REG, MODE, 0))\n \n /* 1 if N is a possible register number for a function value.\n    On the ARM, only r0 and f0 can return results.  */\n #define FUNCTION_VALUE_REGNO_P(REGNO)  \\\n-  ((REGNO) == 0 || (REGNO) == 16)\n+  ((REGNO) == 0 || ((REGNO) == 16) && TARGET_HARD_FLOAT)\n \n /* Define where to put the arguments to a function.\n    Value is zero to push the argument on the stack,"}]}