{"sha": "398111844b4a03cfde294c14f1f88fa9019cfa76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk4MTExODQ0YjRhMDNjZmRlMjk0YzE0ZjFmODhmYTkwMTljZmE3Ng==", "commit": {"author": {"name": "Josef Zlomek", "email": "zlomekj@suse.cz", "date": "2003-03-10T17:23:44Z"}, "committer": {"name": "Josef Zlomek", "email": "zlomek@gcc.gnu.org", "date": "2003-03-10T17:23:44Z"}, "message": "cfgcleanup.c (outgoing_edges_match): Compare the jump tables.\n\n\t* cfgcleanup.c (outgoing_edges_match): Compare the jump tables.\n\t(try_crossjump_to_edge): Replace refereces to one jump table by\n\treferences to identical jump table.\n\t* loop.c (load_mems): Moved setting the JUMP_LABEL to replace_label.\n\t(replace_label): Moved to rtlanal.c.\n\t(struct rtx_pair): Moved to rtl.h.\n\t* rtl.h (struct rtx_pair): Moved from loop.c.\n\t(replace_label): New extern function.\n\t(subrtx_p): New extern function.\n\t(tablejump_p): New extern function.\n\t* rtlanal.c (replace_label): Moved from loop.c.\n\t(subrtx_p_1): New static function.\n\t(subrtx_p): New function.\n\t(tablejump_p): New function.\n\nFrom-SVN: r64096", "tree": {"sha": "c021b1d48b4b4d70f51f21e7f890c0254cf6de10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c021b1d48b4b4d70f51f21e7f890c0254cf6de10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/398111844b4a03cfde294c14f1f88fa9019cfa76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/398111844b4a03cfde294c14f1f88fa9019cfa76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/398111844b4a03cfde294c14f1f88fa9019cfa76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/398111844b4a03cfde294c14f1f88fa9019cfa76/comments", "author": null, "committer": null, "parents": [{"sha": "8f474219ec2322556328a1d10e7b6cebed055b78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f474219ec2322556328a1d10e7b6cebed055b78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f474219ec2322556328a1d10e7b6cebed055b78"}], "stats": {"total": 268, "additions": 220, "deletions": 48}, "files": [{"sha": "b16ebd3feb2d1cdee4d920db0d13eb6bec7ee471", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398111844b4a03cfde294c14f1f88fa9019cfa76/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398111844b4a03cfde294c14f1f88fa9019cfa76/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=398111844b4a03cfde294c14f1f88fa9019cfa76", "patch": "@@ -1,3 +1,20 @@\n+2003-03-10  Josef Zlomek  <zlomekj@suse.cz>\n+\n+\t* cfgcleanup.c (outgoing_edges_match): Compare the jump tables. \n+\t(try_crossjump_to_edge): Replace refereces to one jump table by\n+\treferences to identical jump table.\n+\t* loop.c (load_mems): Moved setting the JUMP_LABEL to replace_label.\n+\t(replace_label): Moved to rtlanal.c.\n+\t(struct rtx_pair): Moved to rtl.h.\n+\t* rtl.h (struct rtx_pair): Moved from loop.c.  \n+\t(replace_label): New extern function.\n+\t(subrtx_p): New extern function.\n+\t(tablejump_p): New extern function.\n+\t* rtlanal.c (replace_label): Moved from loop.c.  \n+\t(subrtx_p_1): New static function.\n+\t(subrtx_p): New function.\n+\t(tablejump_p): New function.\n+\n Mon Mar 10 15:30:36 CET 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* cfgcleanup.c (merge_blocks): Return where to iterate next."}, {"sha": "6ccc3eeca3e94ac900958b0a5625f07207d83ed0", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 108, "deletions": 3, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398111844b4a03cfde294c14f1f88fa9019cfa76/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398111844b4a03cfde294c14f1f88fa9019cfa76/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=398111844b4a03cfde294c14f1f88fa9019cfa76", "patch": "@@ -1254,10 +1254,83 @@ outgoing_edges_match (mode, bb1, bb2)\n   /* Generic case - we are seeing a computed jump, table jump or trapping\n      instruction.  */\n \n+#ifndef CASE_DROPS_THROUGH\n+  /* Check whether there are tablejumps in the end of BB1 and BB2.\n+     Return true if they are identical.  */\n+    {\n+      rtx label1, label2;\n+      rtx table1, table2;\n+\n+      if (tablejump_p (bb1->end, &label1, &table1)\n+\t  && tablejump_p (bb2->end, &label2, &table2)\n+\t  && GET_CODE (PATTERN (table1)) == GET_CODE (PATTERN (table2)))\n+\t{\n+\t  /* The labels should never be the same rtx.  If they really are same\n+\t     the jump tables are same too. So disable crossjumping of blocks BB1\n+\t     and BB2 because when deleting the common insns in the end of BB1\n+\t     by flow_delete_block () the jump table would be deleted too.  */\n+\t  /* If LABEL2 is contained in BB1->END do not do anything\n+\t     because we would loose information when replacing\n+\t     LABEL1 by LABEL2 and then LABEL2 by LABEL1 in BB1->END.  */\n+\t  if (label1 != label2 && !subrtx_p (label2, bb1->end))\n+\t    {\n+\t      /* Set IDENTICAL to true when the tables are identical.  */\n+\t      bool identical = false;\n+\t      rtx p1, p2;\n+\n+\t      p1 = PATTERN (table1);\n+\t      p2 = PATTERN (table2);\n+\t      if (GET_CODE (p1) == ADDR_VEC && rtx_equal_p (p1, p2))\n+\t\t{\n+\t\t  identical = true;\n+\t\t}\n+\t      else if (GET_CODE (p1) == ADDR_DIFF_VEC\n+\t\t       && (XVECLEN (p1, 1) == XVECLEN (p2, 1))\n+\t\t       && rtx_equal_p (XEXP (p1, 2), XEXP (p2, 2))\n+\t\t       && rtx_equal_p (XEXP (p1, 3), XEXP (p2, 3)))\n+\t\t{\n+\t\t  int i;\n+\n+\t\t  identical = true;\n+\t\t  for (i = XVECLEN (p1, 1) - 1; i >= 0 && identical; i--)\n+\t\t    if (!rtx_equal_p (XVECEXP (p1, 1, i), XVECEXP (p2, 1, i)))\n+\t\t      identical = false;\n+\t\t}\n+\n+\t      if (identical)\n+\t\t{\n+\t\t  rtx_pair rr;\n+\t\t  bool match;\n+\n+\t\t  /* Temporarily replace references to LABEL1 with LABEL2\n+\t\t     in BB1->END so that we could compare the instructions.  */\n+\t\t  rr.r1 = label1;\n+\t\t  rr.r2 = label2;\n+\t\t  for_each_rtx (&bb1->end, replace_label, &rr);\n+\n+\t\t  match = insns_match_p (mode, bb1->end, bb2->end);\n+\t\t  if (rtl_dump_file && match)\n+\t\t    fprintf (rtl_dump_file,\n+\t\t\t     \"Tablejumps in bb %i and %i match.\\n\",\n+\t\t\t     bb1->index, bb2->index);\n+\n+\t\t  /* Set the original label in BB1->END because when deleting\n+\t\t     a block whose end is a tablejump, the tablejump referenced\n+\t\t     from the instruction is deleted too.  */\n+\t\t  rr.r1 = label2;\n+\t\t  rr.r2 = label1;\n+\t\t  for_each_rtx (&bb1->end, replace_label, &rr);\n+\n+\t\t  return match;\n+\t\t}\n+\t    }\n+\t  return false;\n+\t}\n+    }\n+#endif\n+\n   /* First ensure that the instructions match.  There may be many outgoing\n-     edges so this test is generally cheaper.\n-     ??? Currently the tablejumps will never match, as they do have\n-     different tables.  */\n+     edges so this test is generally cheaper.  */\n   if (!insns_match_p (mode, bb1->end, bb2->end))\n     return false;\n \n@@ -1370,6 +1443,38 @@ try_crossjump_to_edge (mode, e1, e2)\n   if (!nmatch)\n     return false;\n \n+#ifndef CASE_DROPS_THROUGH\n+  /* Here we know that the insns in the end of SRC1 which are common with SRC2\n+     will be deleted.\n+     If we have tablejumps in the end of SRC1 and SRC2\n+     they have been already compared for equivalence in outgoing_edges_match ()\n+     so replace the references to TABLE1 by references to TABLE2.  */\n+    {\n+      rtx label1, label2;\n+      rtx table1, table2;\n+\n+      if (tablejump_p (src1->end, &label1, &table1)\n+\t  && tablejump_p (src2->end, &label2, &table2)\n+\t  && label1 != label2)\n+\t{\n+\t  rtx_pair rr;\n+\t  rtx insn;\n+\n+\t  /* Replace references to LABEL1 with LABEL2.  */\n+\t  rr.r1 = label1;\n+\t  rr.r2 = label2;\n+\t  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+\t    {\n+\t      /* Do not replace the label in SRC1->END because when deleting\n+\t\t a block whose end is a tablejump, the tablejump referenced\n+\t\t from the instruction is deleted too.  */\n+\t      if (insn != src1->end)\n+\t\tfor_each_rtx (&insn, replace_label, &rr);\n+\t    }\n+\t}\n+    }\n+#endif\n+  \n   /* Avoid splitting if possible.  */\n   if (newpos2 == src2->head)\n     redirect_to = src2;"}, {"sha": "56012d3ba1641b8daa186b9717702bf6177f6167", "filename": "gcc/loop.c", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398111844b4a03cfde294c14f1f88fa9019cfa76/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398111844b4a03cfde294c14f1f88fa9019cfa76/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=398111844b4a03cfde294c14f1f88fa9019cfa76", "patch": "@@ -338,7 +338,6 @@ static void note_reg_stored PARAMS ((rtx, rtx, void *));\n static void try_copy_prop PARAMS ((const struct loop *, rtx, unsigned int));\n static void try_swap_copy_prop PARAMS ((const struct loop *, rtx,\n \t\t\t\t\t unsigned int));\n-static int replace_label PARAMS ((rtx *, void *));\n static rtx check_insn_for_givs PARAMS((struct loop *, rtx, int, int));\n static rtx check_insn_for_bivs PARAMS((struct loop *, rtx, int, int));\n static rtx gen_add_mult PARAMS ((rtx, rtx, rtx, rtx));\n@@ -363,12 +362,6 @@ void debug_giv PARAMS ((const struct induction *));\n void debug_loop PARAMS ((const struct loop *));\n void debug_loops PARAMS ((const struct loops *));\n \n-typedef struct rtx_pair\n-{\n-  rtx r1;\n-  rtx r2;\n-} rtx_pair;\n-\n typedef struct loop_replace_args\n {\n   rtx match;\n@@ -10151,15 +10144,6 @@ load_mems (loop)\n       for (p = loop->start; p != loop->end; p = NEXT_INSN (p))\n \t{\n \t  for_each_rtx (&p, replace_label, &rr);\n-\n-\t  /* If this is a JUMP_INSN, then we also need to fix the JUMP_LABEL\n-\t     field.  This is not handled by for_each_rtx because it doesn't\n-\t     handle unprinted ('0') fields.  We need to update JUMP_LABEL\n-\t     because the immediately following unroll pass will use it.\n-\t     replace_label would not work anyways, because that only handles\n-\t     LABEL_REFs.  */\n-\t  if (GET_CODE (p) == JUMP_INSN && JUMP_LABEL (p) == end_label)\n-\t    JUMP_LABEL (p) = label;\n \t}\n     }\n \n@@ -10489,35 +10473,6 @@ replace_loop_regs (insn, reg, replacement)\n \n   for_each_rtx (&insn, replace_loop_reg, &args);\n }\n-\n-/* Replace occurrences of the old exit label for the loop with the new\n-   one.  DATA is an rtx_pair containing the old and new labels,\n-   respectively.  */\n-\n-static int\n-replace_label (x, data)\n-     rtx *x;\n-     void *data;\n-{\n-  rtx l = *x;\n-  rtx old_label = ((rtx_pair *) data)->r1;\n-  rtx new_label = ((rtx_pair *) data)->r2;\n-\n-  if (l == NULL_RTX)\n-    return 0;\n-\n-  if (GET_CODE (l) != LABEL_REF)\n-    return 0;\n-\n-  if (XEXP (l, 0) != old_label)\n-    return 0;\n-\n-  XEXP (l, 0) = new_label;\n-  ++LABEL_NUSES (new_label);\n-  --LABEL_NUSES (old_label);\n-\n-  return 0;\n-}\n \f\n /* Emit insn for PATTERN after WHERE_INSN in basic block WHERE_BB\n    (ignored in the interim).  */"}, {"sha": "1076cf5038a7e325ee7f94df3bf608a1ea498e3d", "filename": "gcc/rtl.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398111844b4a03cfde294c14f1f88fa9019cfa76/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398111844b4a03cfde294c14f1f88fa9019cfa76/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=398111844b4a03cfde294c14f1f88fa9019cfa76", "patch": "@@ -1595,6 +1595,13 @@ extern rtx set_unique_reg_note\t\tPARAMS ((rtx, enum reg_note, rtx));\n \t\t       : NULL_RTX)\n #define single_set_1(I) single_set_2 (I, PATTERN (I))\n \n+/* Structure used for passing data to REPLACE_LABEL.  */\n+typedef struct rtx_pair\n+{\n+  rtx r1;\n+  rtx r2;\n+} rtx_pair;\n+\n extern int rtx_addr_can_trap_p\t\tPARAMS ((rtx));\n extern bool nonzero_address_p\t\tPARAMS ((rtx));\n extern int rtx_unstable_p\t\tPARAMS ((rtx));\n@@ -1654,6 +1661,9 @@ extern int inequality_comparisons_p\tPARAMS ((rtx));\n extern rtx replace_rtx\t\t\tPARAMS ((rtx, rtx, rtx));\n extern rtx replace_regs\t\t\tPARAMS ((rtx, rtx *, unsigned int,\n \t\t\t\t\t\t int));\n+extern int replace_label\t\tPARAMS ((rtx *, void *));\n+extern int subrtx_p\t\t\tPARAMS ((rtx, rtx));\n+extern bool tablejump_p\t\t\tPARAMS ((rtx, rtx *, rtx *));\n extern int computed_jump_p\t\tPARAMS ((rtx));\n typedef int (*rtx_function)             PARAMS ((rtx *, void *));\n extern int for_each_rtx                 PARAMS ((rtx *, rtx_function, void *));"}, {"sha": "d4817183c4ed1e0403f4cdfd9d6a06e7ed308c7f", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398111844b4a03cfde294c14f1f88fa9019cfa76/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398111844b4a03cfde294c14f1f88fa9019cfa76/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=398111844b4a03cfde294c14f1f88fa9019cfa76", "patch": "@@ -38,6 +38,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n static int global_reg_mentioned_p_1 PARAMS ((rtx *, void *));\n static void set_of_1\t\tPARAMS ((rtx, rtx, void *));\n static void insn_dependent_p_1\tPARAMS ((rtx, rtx, void *));\n+static int subrtx_p_1\t\tPARAMS ((rtx *, void *));\n static int computed_jump_p_1\tPARAMS ((rtx));\n static void parms_set \t\tPARAMS ((rtx, rtx, void *));\n static bool hoist_test_store\t\tPARAMS ((rtx, rtx, regset));\n@@ -2791,6 +2792,90 @@ replace_regs (x, reg_map, nregs, replace_dest)\n   return x;\n }\n \n+/* Replace occurrences of the old label in *X with the new one.\n+   DATA is an rtx_pair containing the old and new labels, respectively.  */\n+\n+int\n+replace_label (x, data)\n+     rtx *x;\n+     void *data;\n+{\n+  rtx l = *x;\n+  rtx old_label = ((rtx_pair *) data)->r1;\n+  rtx new_label = ((rtx_pair *) data)->r2;\n+\n+  if (l == NULL_RTX)\n+    return 0;\n+\n+  /* If this is a JUMP_INSN, then we also need to fix the JUMP_LABEL\n+     field.  This is not handled by for_each_rtx because it doesn't\n+     handle unprinted ('0') fields.  */\n+  if (GET_CODE (l) == JUMP_INSN && JUMP_LABEL (l) == old_label)\n+    JUMP_LABEL (l) = new_label;\n+  \n+  if (GET_CODE (l) != LABEL_REF)\n+    return 0;\n+\n+  if (XEXP (l, 0) != old_label)\n+    return 0;\n+\n+  XEXP (l, 0) = new_label;\n+  ++LABEL_NUSES (new_label);\n+  --LABEL_NUSES (old_label);\n+\n+  return 0;\n+}\n+\n+/* Return RTX_EQUAL_P (*PX, SUBX).  If *PX and SUBX are not equal\n+   FOR_EACH_RTX continues traversing, if they are equal FOR_EACH_RTX\n+   stops traversing and returns the same value as this function.  */\n+\n+static int\n+subrtx_p_1 (px, subx)\n+     rtx *px;\n+     void *subx;\n+{\n+  return rtx_equal_p (*px, (rtx) subx);\n+}\n+\n+/* Return true if SUBX is equal to some subexpression of X.  */\n+\n+int\n+subrtx_p (subx, x)\n+     rtx subx;\n+     rtx x;\n+{\n+  return for_each_rtx (&x, subrtx_p_1, subx);\n+}\n+\n+/* If INSN is a jump to jumptable insn rturn true and store the label (which\n+   INSN jumps to) to *LABEL and the tablejump insn to *TABLE.\n+   LABEL and TABLE may be NULL.  */\n+\n+bool\n+tablejump_p (insn, label, table)\n+     rtx insn;\n+     rtx *label;\n+     rtx *table;\n+{\n+  rtx l, t;\n+\n+  if (onlyjump_p (insn)\n+      && (l = JUMP_LABEL (insn)) != NULL_RTX\n+      && (t = NEXT_INSN (l)) != NULL_RTX\n+      && GET_CODE (t) == JUMP_INSN\n+      && (GET_CODE (PATTERN (t)) == ADDR_VEC\n+\t  || GET_CODE (PATTERN (t)) == ADDR_DIFF_VEC))\n+    {\n+      if (label)\n+\t*label = l;\n+      if (table)\n+\t*table = t;\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* A subroutine of computed_jump_p, return 1 if X contains a REG or MEM or\n    constant that is not in the constant pool and not in the condition\n    of an IF_THEN_ELSE.  */"}]}