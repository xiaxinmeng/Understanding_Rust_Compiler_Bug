{"sha": "d789cf134b7e04ffd90e9512e3e591bd16dc6655", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc4OWNmMTM0YjdlMDRmZmQ5MGU5NTEyZTNlNTkxYmQxNmRjNjY1NQ==", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2021-02-22T15:32:34Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2021-02-22T15:34:33Z"}, "message": "Add mi_thunk support for vcalls on hppa.\n\ngcc/ChangeLog:\n\n\tPR target/85074\n\t* config/pa/pa.c (TARGET_ASM_CAN_OUTPUT_MI_THUNK): Define as\n\thook_bool_const_tree_hwi_hwi_const_tree_true.\n\t(pa_asm_output_mi_thunk): Add support for nonzero vcall_offset.", "tree": {"sha": "c75234e0f6c0b4534704d0a55aaa6c4fef7ba07a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c75234e0f6c0b4534704d0a55aaa6c4fef7ba07a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d789cf134b7e04ffd90e9512e3e591bd16dc6655", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d789cf134b7e04ffd90e9512e3e591bd16dc6655", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d789cf134b7e04ffd90e9512e3e591bd16dc6655", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d789cf134b7e04ffd90e9512e3e591bd16dc6655/comments", "author": null, "committer": null, "parents": [{"sha": "c49fcfddaa47f2828fe2af11ae857cd67f53e23f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c49fcfddaa47f2828fe2af11ae857cd67f53e23f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c49fcfddaa47f2828fe2af11ae857cd67f53e23f"}], "stats": {"total": 504, "additions": 346, "deletions": 158}, "files": [{"sha": "d7fcd11e50466b635803d39cd43daf7236caca20", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 346, "deletions": 158, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d789cf134b7e04ffd90e9512e3e591bd16dc6655/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d789cf134b7e04ffd90e9512e3e591bd16dc6655/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=d789cf134b7e04ffd90e9512e3e591bd16dc6655", "patch": "@@ -293,7 +293,7 @@ static size_t n_deferred_plabels = 0;\n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK pa_asm_output_mi_thunk\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n-#define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_const_tree_hwi_hwi_const_tree_true\n \n #undef TARGET_ASM_FILE_END\n #define TARGET_ASM_FILE_END pa_file_end\n@@ -8461,12 +8461,15 @@ pa_is_function_label_plus_const (rtx op)\n \t  && GET_CODE (XEXP (op, 1)) == CONST_INT);\n }\n \n-/* Output assembly code for a thunk to FUNCTION.  */\n+/* Output the assembler code for a thunk function.  THUNK_DECL is the\n+   declaration for the thunk function itself, FUNCTION is the decl for\n+   the target function.  DELTA is an immediate constant offset to be\n+   added to THIS.  If VCALL_OFFSET is nonzero, the word at\n+   *(*this + vcall_offset) should be added to THIS.  */\n \n static void\n pa_asm_output_mi_thunk (FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta,\n-\t\t\tHOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED,\n-\t\t\ttree function)\n+\t\t\tHOST_WIDE_INT vcall_offset, tree function)\n {\n   const char *fnname = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (thunk_fndecl));\n   static unsigned int current_thunk_number;\n@@ -8482,201 +8485,386 @@ pa_asm_output_mi_thunk (FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta,\n   assemble_start_function (thunk_fndecl, fnname);\n   final_start_function (emit_barrier (), file, 1);\n \n-  /* Output the thunk.  We know that the function is in the same\n-     translation unit (i.e., the same space) as the thunk, and that\n-     thunks are output after their method.  Thus, we don't need an\n-     external branch to reach the function.  With SOM and GAS,\n-     functions and thunks are effectively in different sections.\n-     Thus, we can always use a IA-relative branch and the linker\n-     will add a long branch stub if necessary.\n-\n-     However, we have to be careful when generating PIC code on the\n-     SOM port to ensure that the sequence does not transfer to an\n-     import stub for the target function as this could clobber the\n-     return value saved at SP-24.  This would also apply to the\n-     32-bit linux port if the multi-space model is implemented.  */\n-  if ((!TARGET_LONG_CALLS && TARGET_SOM && !TARGET_PORTABLE_RUNTIME\n-       && !(flag_pic && TREE_PUBLIC (function))\n-       && (TARGET_GAS || last_address < 262132))\n-      || (!TARGET_LONG_CALLS && !TARGET_SOM && !TARGET_PORTABLE_RUNTIME\n-\t  && ((targetm_common.have_named_sections\n-\t       && DECL_SECTION_NAME (thunk_fndecl) != NULL\n-\t       /* The GNU 64-bit linker has rather poor stub management.\n-\t\t  So, we use a long branch from thunks that aren't in\n-\t\t  the same section as the target function.  */\n-\t       && ((!TARGET_64BIT\n-\t\t    && (DECL_SECTION_NAME (thunk_fndecl)\n-\t\t\t!= DECL_SECTION_NAME (function)))\n-\t\t   || ((DECL_SECTION_NAME (thunk_fndecl)\n-\t\t\t== DECL_SECTION_NAME (function))\n-\t\t       && last_address < 262132)))\n-\t      /* In this case, we need to be able to reach the start of\n-\t\t the stub table even though the function is likely closer\n-\t\t and can be jumped to directly.  */\n-\t      || (targetm_common.have_named_sections\n-\t\t  && DECL_SECTION_NAME (thunk_fndecl) == NULL\n-\t\t  && DECL_SECTION_NAME (function) == NULL\n-\t\t  && total_code_bytes < MAX_PCREL17F_OFFSET)\n-\t      /* Likewise.  */\n-\t      || (!targetm_common.have_named_sections\n-\t\t  && total_code_bytes < MAX_PCREL17F_OFFSET))))\n-    {\n-      if (!val_14)\n-\toutput_asm_insn (\"addil L'%2,%%r26\", xoperands);\n-\n-      output_asm_insn (\"b %0\", xoperands);\n-\n-      if (val_14)\n-\t{\n-\t  output_asm_insn (\"ldo %2(%%r26),%%r26\", xoperands);\n-\t  nbytes += 8;\n+  if (!vcall_offset)\n+    {\n+      /* Output the thunk.  We know that the function is in the same\n+\t translation unit (i.e., the same space) as the thunk, and that\n+\t thunks are output after their method.  Thus, we don't need an\n+\t external branch to reach the function.  With SOM and GAS,\n+\t functions and thunks are effectively in different sections.\n+\t Thus, we can always use a IA-relative branch and the linker\n+\t will add a long branch stub if necessary.\n+\n+\t However, we have to be careful when generating PIC code on the\n+\t SOM port to ensure that the sequence does not transfer to an\n+\t import stub for the target function as this could clobber the\n+\t return value saved at SP-24.  This would also apply to the\n+\t32-bit linux port if the multi-space model is implemented.  */\n+      if ((!TARGET_LONG_CALLS && TARGET_SOM && !TARGET_PORTABLE_RUNTIME\n+\t   && !(flag_pic && TREE_PUBLIC (function))\n+\t   && (TARGET_GAS || last_address < 262132))\n+\t  || (!TARGET_LONG_CALLS && !TARGET_SOM && !TARGET_PORTABLE_RUNTIME\n+\t      && ((targetm_common.have_named_sections\n+\t\t   && DECL_SECTION_NAME (thunk_fndecl) != NULL\n+\t\t   /* The GNU 64-bit linker has rather poor stub management.\n+\t\t      So, we use a long branch from thunks that aren't in\n+\t\t      the same section as the target function.  */\n+\t\t    && ((!TARGET_64BIT\n+\t\t\t && (DECL_SECTION_NAME (thunk_fndecl)\n+\t\t\t     != DECL_SECTION_NAME (function)))\n+\t\t\t|| ((DECL_SECTION_NAME (thunk_fndecl)\n+\t\t\t     == DECL_SECTION_NAME (function))\n+\t\t\t    && last_address < 262132)))\n+\t\t  /* In this case, we need to be able to reach the start of\n+\t\t     the stub table even though the function is likely closer\n+\t\t     and can be jumped to directly.  */\n+\t\t  || (targetm_common.have_named_sections\n+\t\t      && DECL_SECTION_NAME (thunk_fndecl) == NULL\n+\t\t      && DECL_SECTION_NAME (function) == NULL\n+\t\t      && total_code_bytes < MAX_PCREL17F_OFFSET)\n+\t\t  /* Likewise.  */\n+\t\t  || (!targetm_common.have_named_sections\n+\t\t      && total_code_bytes < MAX_PCREL17F_OFFSET))))\n+\t{\n+\t  if (!val_14)\n+\t    output_asm_insn (\"addil L'%2,%%r26\", xoperands);\n+\n+\t  output_asm_insn (\"b %0\", xoperands);\n+\n+\t  if (val_14)\n+\t    {\n+\t      output_asm_insn (\"ldo %2(%%r26),%%r26\", xoperands);\n+\t      nbytes += 8;\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\"ldo R'%2(%%r1),%%r26\", xoperands);\n+\t      nbytes += 12;\n+\t    }\n \t}\n-      else\n+      else if (TARGET_64BIT)\n \t{\n-\t  output_asm_insn (\"ldo R'%2(%%r1),%%r26\", xoperands);\n-\t  nbytes += 12;\n-\t}\n-    }\n-  else if (TARGET_64BIT)\n-    {\n-      rtx xop[4];\n+\t  rtx xop[4];\n+\n+\t  /* We only have one call-clobbered scratch register, so we can't\n+\t     make use of the delay slot if delta doesn't fit in 14 bits.  */\n+\t  if (!val_14)\n+\t    {\n+\t      output_asm_insn (\"addil L'%2,%%r26\", xoperands);\n+\t      output_asm_insn (\"ldo R'%2(%%r1),%%r26\", xoperands);\n+\t    }\n+\n+\t  /* Load function address into %r1.  */\n+\t  xop[0] = xoperands[0];\n+\t  xop[1] = gen_rtx_REG (Pmode, 1);\n+\t  xop[2] = xop[1];\n+\t  pa_output_pic_pcrel_sequence (xop);\n \n-      /* We only have one call-clobbered scratch register, so we can't\n-         make use of the delay slot if delta doesn't fit in 14 bits.  */\n-      if (!val_14)\n+\t  if (val_14)\n+\t    {\n+\t      output_asm_insn (\"bv %%r0(%%r1)\", xoperands);\n+\t      output_asm_insn (\"ldo %2(%%r26),%%r26\", xoperands);\n+\t      nbytes += 20;\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\"bv,n %%r0(%%r1)\", xoperands);\n+\t      nbytes += 24;\n+\t    }\n+\t}\n+      else if (TARGET_PORTABLE_RUNTIME)\n \t{\n-\t  output_asm_insn (\"addil L'%2,%%r26\", xoperands);\n-\t  output_asm_insn (\"ldo R'%2(%%r1),%%r26\", xoperands);\n+\t  output_asm_insn (\"ldil L'%0,%%r1\", xoperands);\n+\t  output_asm_insn (\"ldo R'%0(%%r1),%%r22\", xoperands);\n+\n+\t  if (!val_14)\n+\t    output_asm_insn (\"ldil L'%2,%%r26\", xoperands);\n+\n+\t  output_asm_insn (\"bv %%r0(%%r22)\", xoperands);\n+\n+\t  if (val_14)\n+\t    {\n+\t      output_asm_insn (\"ldo %2(%%r26),%%r26\", xoperands);\n+\t      nbytes += 16;\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\"ldo R'%2(%%r26),%%r26\", xoperands);\n+\t      nbytes += 20;\n+\t    }\n \t}\n+      else if (TARGET_SOM && flag_pic && TREE_PUBLIC (function))\n+\t{\n+\t  /* The function is accessible from outside this module.  The only\n+\t     way to avoid an import stub between the thunk and function is to\n+\t     call the function directly with an indirect sequence similar to\n+\t     that used by $$dyncall.  This is possible because $$dyncall acts\n+\t     as the import stub in an indirect call.  */\n+\t  ASM_GENERATE_INTERNAL_LABEL (label, \"LTHN\", current_thunk_number);\n+\t  xoperands[3] = gen_rtx_SYMBOL_REF (Pmode, label);\n+\t  output_asm_insn (\"addil LT'%3,%%r19\", xoperands);\n+\t  output_asm_insn (\"ldw RT'%3(%%r1),%%r22\", xoperands);\n+\t  output_asm_insn (\"ldw 0(%%sr0,%%r22),%%r22\", xoperands);\n+\t  output_asm_insn (\"bb,>=,n %%r22,30,.+16\", xoperands);\n+\t  output_asm_insn (\"depi 0,31,2,%%r22\", xoperands);\n+\t  output_asm_insn (\"ldw 4(%%sr0,%%r22),%%r19\", xoperands);\n+\t  output_asm_insn (\"ldw 0(%%sr0,%%r22),%%r22\", xoperands);\n+\n+\t  if (!val_14)\n+\t    {\n+\t      output_asm_insn (\"addil L'%2,%%r26\", xoperands);\n+\t      nbytes += 4;\n+\t    }\n \n-      /* Load function address into %r1.  */\n-      xop[0] = xoperands[0];\n-      xop[1] = gen_rtx_REG (Pmode, 1);\n-      xop[2] = xop[1];\n-      pa_output_pic_pcrel_sequence (xop);\n+\t  if (TARGET_PA_20)\n+\t    {\n+\t      output_asm_insn (\"bve (%%r22)\", xoperands);\n+\t      nbytes += 36;\n+\t    }\n+\t  else if (TARGET_NO_SPACE_REGS)\n+\t    {\n+\t      output_asm_insn (\"be 0(%%sr4,%%r22)\", xoperands);\n+\t      nbytes += 36;\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\"ldsid (%%sr0,%%r22),%%r21\", xoperands);\n+\t      output_asm_insn (\"mtsp %%r21,%%sr0\", xoperands);\n+\t      output_asm_insn (\"be 0(%%sr0,%%r22)\", xoperands);\n+\t      nbytes += 44;\n+\t    }\n \n-      if (val_14)\n-\t{\n-\t  output_asm_insn (\"bv %%r0(%%r1)\", xoperands);\n-\t  output_asm_insn (\"ldo %2(%%r26),%%r26\", xoperands);\n-\t  nbytes += 20;\n+\t  if (val_14)\n+\t    output_asm_insn (\"ldo %2(%%r26),%%r26\", xoperands);\n+\t  else\n+\t    output_asm_insn (\"ldo R'%2(%%r1),%%r26\", xoperands);\n \t}\n-      else\n+      else if (flag_pic)\n \t{\n-\t  output_asm_insn (\"bv,n %%r0(%%r1)\", xoperands);\n-\t  nbytes += 24;\n-\t}\n-    }\n-  else if (TARGET_PORTABLE_RUNTIME)\n-    {\n-      output_asm_insn (\"ldil L'%0,%%r1\", xoperands);\n-      output_asm_insn (\"ldo R'%0(%%r1),%%r22\", xoperands);\n+\t  rtx xop[4];\n \n-      if (!val_14)\n-\toutput_asm_insn (\"ldil L'%2,%%r26\", xoperands);\n+\t  /* Load function address into %r22.  */\n+\t  xop[0] = xoperands[0];\n+\t  xop[1] = gen_rtx_REG (Pmode, 1);\n+\t  xop[2] = gen_rtx_REG (Pmode, 22);\n+\t  pa_output_pic_pcrel_sequence (xop);\n \n-      output_asm_insn (\"bv %%r0(%%r22)\", xoperands);\n+\t  if (!val_14)\n+\t    output_asm_insn (\"addil L'%2,%%r26\", xoperands);\n \n-      if (val_14)\n-\t{\n-\t  output_asm_insn (\"ldo %2(%%r26),%%r26\", xoperands);\n-\t  nbytes += 16;\n+\t  output_asm_insn (\"bv %%r0(%%r22)\", xoperands);\n+\n+\t  if (val_14)\n+\t    {\n+\t      output_asm_insn (\"ldo %2(%%r26),%%r26\", xoperands);\n+\t      nbytes += 20;\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\"ldo R'%2(%%r1),%%r26\", xoperands);\n+\t      nbytes += 24;\n+\t    }\n \t}\n       else\n \t{\n-\t  output_asm_insn (\"ldo R'%2(%%r26),%%r26\", xoperands);\n-\t  nbytes += 20;\n+\t  if (!val_14)\n+\t    output_asm_insn (\"addil L'%2,%%r26\", xoperands);\n+\n+\t  output_asm_insn (\"ldil L'%0,%%r22\", xoperands);\n+\t  output_asm_insn (\"be R'%0(%%sr4,%%r22)\", xoperands);\n+\n+\t  if (val_14)\n+\t    {\n+\t      output_asm_insn (\"ldo %2(%%r26),%%r26\", xoperands);\n+\t      nbytes += 12;\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\"ldo R'%2(%%r1),%%r26\", xoperands);\n+\t      nbytes += 16;\n+\t    }\n \t}\n     }\n-  else if (TARGET_SOM && flag_pic && TREE_PUBLIC (function))\n+  else\n     {\n-      /* The function is accessible from outside this module.  The only\n-\t way to avoid an import stub between the thunk and function is to\n-\t call the function directly with an indirect sequence similar to\n-\t that used by $$dyncall.  This is possible because $$dyncall acts\n-\t as the import stub in an indirect call.  */\n-      ASM_GENERATE_INTERNAL_LABEL (label, \"LTHN\", current_thunk_number);\n-      xoperands[3] = gen_rtx_SYMBOL_REF (Pmode, label);\n-      output_asm_insn (\"addil LT'%3,%%r19\", xoperands);\n-      output_asm_insn (\"ldw RT'%3(%%r1),%%r22\", xoperands);\n-      output_asm_insn (\"ldw 0(%%sr0,%%r22),%%r22\", xoperands);\n-      output_asm_insn (\"bb,>=,n %%r22,30,.+16\", xoperands);\n-      output_asm_insn (\"depi 0,31,2,%%r22\", xoperands);\n-      output_asm_insn (\"ldw 4(%%sr0,%%r22),%%r19\", xoperands);\n-      output_asm_insn (\"ldw 0(%%sr0,%%r22),%%r22\", xoperands);\n+      rtx xop[4];\n \n-      if (!val_14)\n+      /* Add DELTA to THIS.  */\n+      if (val_14)\n \t{\n-\t  output_asm_insn (\"addil L'%2,%%r26\", xoperands);\n+\t  output_asm_insn (\"ldo %2(%%r26),%%r26\", xoperands);\n \t  nbytes += 4;\n \t}\n-\n-      if (TARGET_PA_20)\n+      else\n \t{\n-\t  output_asm_insn (\"bve (%%r22)\", xoperands);\n-\t  nbytes += 36;\n+\t  output_asm_insn (\"addil L'%2,%%r26\", xoperands);\n+\t  output_asm_insn (\"ldo R'%2(%%r1),%%r26\", xoperands);\n+\t  nbytes += 8;\n \t}\n-      else if (TARGET_NO_SPACE_REGS)\n+\n+      if (TARGET_64BIT)\n \t{\n-\t  output_asm_insn (\"be 0(%%sr4,%%r22)\", xoperands);\n-\t  nbytes += 36;\n+\t  /* Load *(THIS + DELTA) to %r1.  */\n+\t  output_asm_insn (\"ldd 0(%%r26),%%r1\", xoperands);\n+\n+\t  val_14 = VAL_14_BITS_P (vcall_offset);\n+\t  xoperands[2] = GEN_INT (vcall_offset);\n+\n+\t  /* Load  *(*(THIS + DELTA) + VCALL_OFFSET) to %r1.  */\n+\t  if (val_14)\n+\t    {\n+\t      output_asm_insn (\"ldd %2(%%r1),%%r1\", xoperands);\n+\t      nbytes += 8;\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\"addil L'%2,%%r1\", xoperands);\n+\t      output_asm_insn (\"ldd R'%2(%%r1),%%r1\", xoperands);\n+\t      nbytes += 12;\n+\t    }\n \t}\n       else\n \t{\n-\t  output_asm_insn (\"ldsid (%%sr0,%%r22),%%r21\", xoperands);\n-\t  output_asm_insn (\"mtsp %%r21,%%sr0\", xoperands);\n-\t  output_asm_insn (\"be 0(%%sr0,%%r22)\", xoperands);\n-\t  nbytes += 44;\n-\t}\n+\t  /* Load *(THIS + DELTA) to %r1.  */\n+\t  output_asm_insn (\"ldw 0(%%r26),%%r1\", xoperands);\n \n-      if (val_14)\n-\toutput_asm_insn (\"ldo %2(%%r26),%%r26\", xoperands);\n-      else\n-\toutput_asm_insn (\"ldo R'%2(%%r1),%%r26\", xoperands);\n-    }\n-  else if (flag_pic)\n-    {\n-      rtx xop[4];\n-\n-      /* Load function address into %r22.  */\n-      xop[0] = xoperands[0];\n-      xop[1] = gen_rtx_REG (Pmode, 1);\n-      xop[2] = gen_rtx_REG (Pmode, 22);\n-      pa_output_pic_pcrel_sequence (xop);\n+\t  val_14 = VAL_14_BITS_P (vcall_offset);\n+\t  xoperands[2] = GEN_INT (vcall_offset);\n \n-      if (!val_14)\n-\toutput_asm_insn (\"addil L'%2,%%r26\", xoperands);\n-\n-      output_asm_insn (\"bv %%r0(%%r22)\", xoperands);\n+\t  /* Load  *(*(THIS + DELTA) + VCALL_OFFSET) to %r1.  */\n+\t  if (val_14)\n+\t    {\n+\t      output_asm_insn (\"ldw %2(%%r1),%%r1\", xoperands);\n+\t      nbytes += 8;\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\"addil L'%2,%%r1\", xoperands);\n+\t      output_asm_insn (\"ldw R'%2(%%r1),%%r1\", xoperands);\n+\t      nbytes += 12;\n+\t    }\n+\t}\n \n-      if (val_14)\n+      /* Branch to FUNCTION and add %r1 to THIS in delay slot if possible.  */\n+      if ((!TARGET_LONG_CALLS && TARGET_SOM && !TARGET_PORTABLE_RUNTIME\n+\t   && !(flag_pic && TREE_PUBLIC (function))\n+\t   && (TARGET_GAS || last_address < 262132))\n+\t  || (!TARGET_LONG_CALLS && !TARGET_SOM && !TARGET_PORTABLE_RUNTIME\n+\t      && ((targetm_common.have_named_sections\n+\t\t   && DECL_SECTION_NAME (thunk_fndecl) != NULL\n+\t\t   /* The GNU 64-bit linker has rather poor stub management.\n+\t\t      So, we use a long branch from thunks that aren't in\n+\t\t      the same section as the target function.  */\n+\t\t    && ((!TARGET_64BIT\n+\t\t\t && (DECL_SECTION_NAME (thunk_fndecl)\n+\t\t\t     != DECL_SECTION_NAME (function)))\n+\t\t\t|| ((DECL_SECTION_NAME (thunk_fndecl)\n+\t\t\t     == DECL_SECTION_NAME (function))\n+\t\t\t    && last_address < 262132)))\n+\t\t  /* In this case, we need to be able to reach the start of\n+\t\t     the stub table even though the function is likely closer\n+\t\t     and can be jumped to directly.  */\n+\t\t  || (targetm_common.have_named_sections\n+\t\t      && DECL_SECTION_NAME (thunk_fndecl) == NULL\n+\t\t      && DECL_SECTION_NAME (function) == NULL\n+\t\t      && total_code_bytes < MAX_PCREL17F_OFFSET)\n+\t\t  /* Likewise.  */\n+\t\t  || (!targetm_common.have_named_sections\n+\t\t      && total_code_bytes < MAX_PCREL17F_OFFSET))))\n \t{\n-\t  output_asm_insn (\"ldo %2(%%r26),%%r26\", xoperands);\n-\t  nbytes += 20;\n+\t  nbytes += 4;\n+\t  output_asm_insn (\"b %0\", xoperands);\n+\n+\t  /* Add *(*(THIS + DELTA) + VCALL_OFFSET) to THIS.  */\n+\t  output_asm_insn (\"addl %%r1,%%r26,%%r26\", xoperands);\n \t}\n-      else\n+      else if (TARGET_64BIT)\n \t{\n-\t  output_asm_insn (\"ldo R'%2(%%r1),%%r26\", xoperands);\n-\t  nbytes += 24;\n-\t}\n-    }\n-  else\n-    {\n-      if (!val_14)\n-\toutput_asm_insn (\"addil L'%2,%%r26\", xoperands);\n+\t  /* Add *(*(THIS + DELTA) + VCALL_OFFSET) to THIS.  */\n+\t  output_asm_insn (\"addl %%r1,%%r26,%%r26\", xoperands);\n \n-      output_asm_insn (\"ldil L'%0,%%r22\", xoperands);\n-      output_asm_insn (\"be R'%0(%%sr4,%%r22)\", xoperands);\n+\t  /* Load function address into %r1.  */\n+\t  nbytes += 16;\n+\t  xop[0] = xoperands[0];\n+\t  xop[1] = gen_rtx_REG (Pmode, 1);\n+\t  xop[2] = xop[1];\n+\t  pa_output_pic_pcrel_sequence (xop);\n \n-      if (val_14)\n+\t  output_asm_insn (\"bv,n %%r0(%%r1)\", xoperands);\n+\t}\n+      else if (TARGET_PORTABLE_RUNTIME)\n \t{\n-\t  output_asm_insn (\"ldo %2(%%r26),%%r26\", xoperands);\n+\t  /* Load function address into %r22.  */\n \t  nbytes += 12;\n+\t  output_asm_insn (\"ldil L'%0,%%r22\", xoperands);\n+\t  output_asm_insn (\"ldo R'%0(%%r22),%%r22\", xoperands);\n+\n+\t  output_asm_insn (\"bv %%r0(%%r22)\", xoperands);\n+\n+\t  /* Add *(*(THIS + DELTA) + VCALL_OFFSET) to THIS.  */\n+\t  output_asm_insn (\"addl %%r1,%%r26,%%r26\", xoperands);\n+\t}\n+      else if (TARGET_SOM && flag_pic && TREE_PUBLIC (function))\n+\t{\n+\t  /* Add *(*(THIS + DELTA) + VCALL_OFFSET) to THIS.  */\n+\t  output_asm_insn (\"addl %%r1,%%r26,%%r26\", xoperands);\n+\n+\t  /* The function is accessible from outside this module.  The only\n+\t     way to avoid an import stub between the thunk and function is to\n+\t     call the function directly with an indirect sequence similar to\n+\t     that used by $$dyncall.  This is possible because $$dyncall acts\n+\t     as the import stub in an indirect call.  */\n+\t  ASM_GENERATE_INTERNAL_LABEL (label, \"LTHN\", current_thunk_number);\n+\t  xoperands[3] = gen_rtx_SYMBOL_REF (Pmode, label);\n+\t  output_asm_insn (\"addil LT'%3,%%r19\", xoperands);\n+\t  output_asm_insn (\"ldw RT'%3(%%r1),%%r22\", xoperands);\n+\t  output_asm_insn (\"ldw 0(%%sr0,%%r22),%%r22\", xoperands);\n+\t  output_asm_insn (\"bb,>=,n %%r22,30,.+16\", xoperands);\n+\t  output_asm_insn (\"depi 0,31,2,%%r22\", xoperands);\n+\t  output_asm_insn (\"ldw 4(%%sr0,%%r22),%%r19\", xoperands);\n+\t  output_asm_insn (\"ldw 0(%%sr0,%%r22),%%r22\", xoperands);\n+\n+\t  if (TARGET_PA_20)\n+\t    {\n+\t      output_asm_insn (\"bve,n (%%r22)\", xoperands);\n+\t      nbytes += 32;\n+\t    }\n+\t  else if (TARGET_NO_SPACE_REGS)\n+\t    {\n+\t      output_asm_insn (\"be,n 0(%%sr4,%%r22)\", xoperands);\n+\t      nbytes += 32;\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\"ldsid (%%sr0,%%r22),%%r21\", xoperands);\n+\t      output_asm_insn (\"mtsp %%r21,%%sr0\", xoperands);\n+\t      output_asm_insn (\"be,n 0(%%sr0,%%r22)\", xoperands);\n+\t      nbytes += 40;\n+\t    }\n \t}\n-      else\n+      else if (flag_pic)\n \t{\n-\t  output_asm_insn (\"ldo R'%2(%%r1),%%r26\", xoperands);\n+\t  /* Add *(*(THIS + DELTA) + VCALL_OFFSET) to THIS.  */\n+\t  output_asm_insn (\"addl %%r1,%%r26,%%r26\", xoperands);\n+\n+\t  /* Load function address into %r1.  */\n \t  nbytes += 16;\n+\t  xop[0] = xoperands[0];\n+\t  xop[1] = gen_rtx_REG (Pmode, 1);\n+\t  xop[2] = xop[1];\n+\t  pa_output_pic_pcrel_sequence (xop);\n+\n+\t  output_asm_insn (\"bv,n %%r0(%%r1)\", xoperands);\n+\t}\n+      else\n+\t{\n+\t  /* Load function address into %r22.  */\n+\t  nbytes += 8;\n+\t  output_asm_insn (\"ldil L'%0,%%r22\", xoperands);\n+\t  output_asm_insn (\"be R'%0(%%sr4,%%r22)\", xoperands);\n+\n+\t  /* Add *(*(THIS + DELTA) + VCALL_OFFSET) to THIS.  */\n+\t  output_asm_insn (\"addl %%r1,%%r26,%%r26\", xoperands);\n \t}\n     }\n "}]}