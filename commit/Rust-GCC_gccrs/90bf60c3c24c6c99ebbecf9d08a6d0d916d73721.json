{"sha": "90bf60c3c24c6c99ebbecf9d08a6d0d916d73721", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBiZjYwYzNjMjRjNmM5OWViYmVjZjlkMDhhNmQwZDkxNmQ3MzcyMQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-02-12T17:38:57Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-11-20T19:56:10Z"}, "message": "libstdc++: _Rb_tree code cleanup, remove lambdas\n\nUse new template parameters to replace usage of lambdas to move or not\ntree values on copy.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/move.h (_GLIBCXX_FWDREF): New.\n\t* include/bits/stl_tree.h: Adapt to use latter.\n\t(_Rb_tree<>::_M_clone_node): Add _MoveValue template parameter.\n\t(_Rb_tree<>::_M_mbegin): New.\n\t(_Rb_tree<>::_M_begin): Use latter.\n\t(_Rb_tree<>::_M_copy): Add _MoveValues template parameter.\n\t* testsuite/23_containers/map/allocator/move_cons.cc: New test.\n\t* testsuite/23_containers/multimap/allocator/move_cons.cc: New test.\n\t* testsuite/23_containers/multiset/allocator/move_cons.cc: New test.\n\t* testsuite/23_containers/set/allocator/move_cons.cc: New test.", "tree": {"sha": "f61dafb1ed2fdbb99e39b15e1ba3a08822737e35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f61dafb1ed2fdbb99e39b15e1ba3a08822737e35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721/comments", "author": null, "committer": null, "parents": [{"sha": "d1081010a1addfcf156b7042f581f0698ea25f61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1081010a1addfcf156b7042f581f0698ea25f61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1081010a1addfcf156b7042f581f0698ea25f61"}], "stats": {"total": 290, "additions": 250, "deletions": 40}, "files": [{"sha": "b33c22a4374a7e404c61511ba638ac20f5048f0e", "filename": "libstdc++-v3/include/bits/move.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmove.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmove.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmove.h?ref=90bf60c3c24c6c99ebbecf9d08a6d0d916d73721", "patch": "@@ -158,9 +158,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /// @} group utilities\n \n+#define _GLIBCXX_FWDREF(_Tp) _Tp&&\n #define _GLIBCXX_MOVE(__val) std::move(__val)\n #define _GLIBCXX_FORWARD(_Tp, __val) std::forward<_Tp>(__val)\n #else\n+#define _GLIBCXX_FWDREF(_Tp) const _Tp&\n #define _GLIBCXX_MOVE(__val) (__val)\n #define _GLIBCXX_FORWARD(_Tp, __val) (__val)\n #endif"}, {"sha": "a51d6da4ae864391d8c7ccf09bdcd288c61864da", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=90bf60c3c24c6c99ebbecf9d08a6d0d916d73721", "patch": "@@ -478,11 +478,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n \ttemplate<typename _Arg>\n \t  _Link_type\n-#if __cplusplus < 201103L\n-\t  operator()(const _Arg& __arg)\n-#else\n-\t  operator()(_Arg&& __arg)\n-#endif\n+\t  operator()(_GLIBCXX_FWDREF(_Arg) __arg)\n \t  {\n \t    _Link_type __node = static_cast<_Link_type>(_M_extract());\n \t    if (__node)\n@@ -544,11 +540,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n \ttemplate<typename _Arg>\n \t  _Link_type\n-#if __cplusplus < 201103L\n-\t  operator()(const _Arg& __arg) const\n-#else\n-\t  operator()(_Arg&& __arg) const\n-#endif\n+\t  operator()(_GLIBCXX_FWDREF(_Arg) __arg) const\n \t  { return _M_t._M_create_node(_GLIBCXX_FORWARD(_Arg, __arg)); }\n \n       private:\n@@ -655,11 +647,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_put_node(__p);\n       }\n \n-      template<typename _NodeGen>\n+      template<bool _MoveValue, typename _NodeGen>\n \t_Link_type\n-\t_M_clone_node(_Const_Link_type __x, _NodeGen& __node_gen)\n+\t_M_clone_node(_Link_type __x, _NodeGen& __node_gen)\n \t{\n-\t  _Link_type __tmp = __node_gen(*__x->_M_valptr());\n+#if __cplusplus >= 201103L\n+\t  using _Vp = typename conditional<_MoveValue,\n+\t\t\t\t\t   value_type&&,\n+\t\t\t\t\t   const value_type&>::type;\n+#endif\n+\t  _Link_type __tmp\n+\t    = __node_gen(_GLIBCXX_FORWARD(_Vp, *__x->_M_valptr()));\n \t  __tmp->_M_color = __x->_M_color;\n \t  __tmp->_M_left = 0;\n \t  __tmp->_M_right = 0;\n@@ -748,9 +746,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return this->_M_impl._M_header._M_right; }\n \n       _Link_type\n-      _M_begin() _GLIBCXX_NOEXCEPT\n+      _M_mbegin() const _GLIBCXX_NOEXCEPT\n       { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }\n \n+      _Link_type\n+      _M_begin() _GLIBCXX_NOEXCEPT\n+      { return _M_mbegin(); }\n+\n       _Const_Link_type\n       _M_begin() const _GLIBCXX_NOEXCEPT\n       {\n@@ -889,15 +891,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_insert_equal_lower(const value_type& __x);\n #endif\n \n-      template<typename _NodeGen>\n+      enum { __as_lvalue, __as_rvalue };\n+\n+      template<bool _MoveValues, typename _NodeGen>\n \t_Link_type\n-\t_M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen&);\n+\t_M_copy(_Link_type, _Base_ptr, _NodeGen&);\n \n-      template<typename _NodeGen>\n+      template<bool _MoveValues, typename _NodeGen>\n \t_Link_type\n \t_M_copy(const _Rb_tree& __x, _NodeGen& __gen)\n \t{\n-\t  _Link_type __root = _M_copy(__x._M_begin(), _M_end(), __gen);\n+\t  _Link_type __root =\n+\t    _M_copy<_MoveValues>(__x._M_mbegin(), _M_end(), __gen);\n \t  _M_leftmost() = _S_minimum(__root);\n \t  _M_rightmost() = _S_maximum(__root);\n \t  _M_impl._M_node_count = __x._M_impl._M_node_count;\n@@ -908,7 +913,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_copy(const _Rb_tree& __x)\n       {\n \t_Alloc_node __an(*this);\n-\treturn _M_copy(__x, __an);\n+\treturn _M_copy<__as_lvalue>(__x, __an);\n       }\n \n       void\n@@ -1655,13 +1660,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       else\n \t{\n \t  _Alloc_node __an(*this);\n-\t  auto __lbd =\n-\t    [&__an](const value_type& __cval)\n-\t    {\n-\t      auto& __val = const_cast<value_type&>(__cval);\n-\t      return __an(std::move_if_noexcept(__val));\n-\t    };\n-\t  _M_root() = _M_copy(__x, __lbd);\n+\t  _M_root() =\n+\t    _M_copy<!__move_if_noexcept_cond<value_type>::value>(__x, __an);\n \t}\n     }\n \n@@ -1693,13 +1693,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_impl._M_reset();\n       if (__x._M_root() != nullptr)\n \t{\n-\t  auto __lbd =\n-\t    [&__roan](const value_type& __cval)\n-\t    {\n-\t      auto& __val = const_cast<value_type&>(__cval);\n-\t      return __roan(std::move(__val));\n-\t    };\n-\t  _M_root() = _M_copy(__x, __lbd);\n+\t  _M_root() = _M_copy<__as_rvalue>(__x, __roan);\n \t  __x.clear();\n \t}\n     }\n@@ -1773,7 +1767,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_impl._M_reset();\n \t  _M_impl._M_key_compare = __x._M_impl._M_key_compare;\n \t  if (__x._M_root() != 0)\n-\t    _M_root() = _M_copy(__x, __roan);\n+\t    _M_root() = _M_copy<__as_lvalue>(__x, __roan);\n \t}\n \n       return *this;\n@@ -1859,29 +1853,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Key, typename _Val, typename _KoV,\n \t   typename _Compare, typename _Alloc>\n-    template<typename _NodeGen>\n+    template<bool _MoveValues, typename _NodeGen>\n       typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type\n       _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::\n-      _M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen& __node_gen)\n+      _M_copy(_Link_type __x, _Base_ptr __p, _NodeGen& __node_gen)\n       {\n \t// Structural copy. __x and __p must be non-null.\n-\t_Link_type __top = _M_clone_node(__x, __node_gen);\n+\t_Link_type __top = _M_clone_node<_MoveValues>(__x, __node_gen);\n \t__top->_M_parent = __p;\n \n \t__try\n \t  {\n \t    if (__x->_M_right)\n-\t      __top->_M_right = _M_copy(_S_right(__x), __top, __node_gen);\n+\t      __top->_M_right =\n+\t\t_M_copy<_MoveValues>(_S_right(__x), __top, __node_gen);\n \t    __p = __top;\n \t    __x = _S_left(__x);\n \n \t    while (__x != 0)\n \t      {\n-\t\t_Link_type __y = _M_clone_node(__x, __node_gen);\n+\t\t_Link_type __y = _M_clone_node<_MoveValues>(__x, __node_gen);\n \t\t__p->_M_left = __y;\n \t\t__y->_M_parent = __p;\n \t\tif (__x->_M_right)\n-\t\t  __y->_M_right = _M_copy(_S_right(__x), __y, __node_gen);\n+\t\t  __y->_M_right = _M_copy<_MoveValues>(_S_right(__x),\n+\t\t\t\t\t\t       __y, __node_gen);\n \t\t__p = __y;\n \t\t__x = _S_left(__x);\n \t      }"}, {"sha": "08a14a42d6a17e24b945733650fb47c61130443f", "filename": "libstdc++-v3/testsuite/23_containers/map/allocator/move_cons.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove_cons.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove_cons.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove_cons.cc?ref=90bf60c3c24c6c99ebbecf9d08a6d0d916d73721", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <map>\n+#include <string>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using Cmp = std::less<int>;\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  typedef uneq_allocator<std::pair<const int, std::string>> alloc_type;\n+  typedef std::map<int, std::string, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  const char* str = \"A long enough string to require dynamic allocation\";\n+  v1 = { { 1, str } };\n+\n+  alloc_type a2(2);\n+  test_type v2(std::move(v1), a2);\n+\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+\n+  VERIFY( v1[1].empty() );\n+  VERIFY( v2[1] == str );\n+}\n+\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "4fbd85d665cef95ac58cc188591fa67f17e0f073", "filename": "libstdc++-v3/testsuite/23_containers/multimap/allocator/move_cons.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove_cons.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove_cons.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove_cons.cc?ref=90bf60c3c24c6c99ebbecf9d08a6d0d916d73721", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <map>\n+#include <string>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using Cmp = std::less<int>;\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  typedef uneq_allocator<std::pair<const int, std::string>> alloc_type;\n+  typedef std::multimap<int, std::string, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  const char* str = \"A long enough string to require dynamic allocation\";\n+  v1 = { { 1, str } };\n+\n+  alloc_type a2(2);\n+  test_type v2(std::move(v1), a2);\n+\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+\n+  VERIFY( v1.begin()->second.empty() );\n+  VERIFY( v2.begin()->second == str );\n+}\n+\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "bc7356be0aeaf9ddeb63c8ae16d7c997f6f04c88", "filename": "libstdc++-v3/testsuite/23_containers/multiset/allocator/move_cons.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove_cons.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove_cons.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove_cons.cc?ref=90bf60c3c24c6c99ebbecf9d08a6d0d916d73721", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <set>\n+#include <string>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using Cmp = std::less<std::string>;\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  typedef uneq_allocator<std::string> alloc_type;\n+  typedef std::multiset<std::string, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  const char* str = \"A long enough string to require dynamic allocation\";\n+  v1 = { str };\n+\n+  alloc_type a2(2);\n+  test_type v2(std::move(v1), a2);\n+\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+\n+  VERIFY( v1.count(str) == 0 );\n+  VERIFY( v2.count(str) == 1 );\n+}\n+\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "137d50d4ee8b845947ee922ff2dce7012316f253", "filename": "libstdc++-v3/testsuite/23_containers/set/allocator/move_cons.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove_cons.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove_cons.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove_cons.cc?ref=90bf60c3c24c6c99ebbecf9d08a6d0d916d73721", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <set>\n+#include <string>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using Cmp = std::less<std::string>;\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  typedef uneq_allocator<std::string> alloc_type;\n+  typedef std::set<std::string, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  const char* str = \"A long enough string to require dynamic allocation\";\n+  v1 = { str };\n+\n+  alloc_type a2(2);\n+  test_type v2(std::move(v1), a2);\n+\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+\n+  VERIFY( v1.count(str) == 0 );\n+  VERIFY( v2.count(str) == 1 );\n+}\n+\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}