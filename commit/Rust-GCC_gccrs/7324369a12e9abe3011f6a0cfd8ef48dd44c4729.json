{"sha": "7324369a12e9abe3011f6a0cfd8ef48dd44c4729", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMyNDM2OWExMmU5YWJlMzAxMWY2YTBjZmQ4ZWY0OGRkNDRjNDcyOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-10-28T07:02:39Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-10-28T07:02:39Z"}, "message": "target.c (struct gomp_coalesce_buf): New type.\n\n\t* target.c (struct gomp_coalesce_buf): New type.\n\t(MAX_COALESCE_BUF_SIZE, MAX_COALESCE_BUF_GAP): Define.\n\t(gomp_coalesce_buf_add, gomp_to_device_kind_p): New functions.\n\t(gomp_copy_host2dev): Add CBUF argument, if copying into\n\tthe cached ranges, memcpy into buffer instead of copying\n\tinto device.\n\t(gomp_map_vars_existing, gomp_map_pointer, gomp_map_fields_existing):\n\tAdd CBUF argument, pass it through to other calls.\n\t(gomp_map_vars): Aggregate copies from host to device if small enough\n\tand with small enough gaps in between into memcpy into a buffer and\n\tfewer host to device copies from the buffer.\n\t(gomp_update): Adjust gomp_copy_host2dev caller.\n\nFrom-SVN: r254194", "tree": {"sha": "4508f21797eab3eccc7a20d91a4d188d55e33f78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4508f21797eab3eccc7a20d91a4d188d55e33f78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7324369a12e9abe3011f6a0cfd8ef48dd44c4729", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7324369a12e9abe3011f6a0cfd8ef48dd44c4729", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7324369a12e9abe3011f6a0cfd8ef48dd44c4729", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7324369a12e9abe3011f6a0cfd8ef48dd44c4729/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fdfcd5ecc51dc8e7252af21115f10946d490c55b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdfcd5ecc51dc8e7252af21115f10946d490c55b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdfcd5ecc51dc8e7252af21115f10946d490c55b"}], "stats": {"total": 241, "additions": 207, "deletions": 34}, "files": [{"sha": "39e98c735c7f33498cc372d680a601dc12f1996e", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324369a12e9abe3011f6a0cfd8ef48dd44c4729/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324369a12e9abe3011f6a0cfd8ef48dd44c4729/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=7324369a12e9abe3011f6a0cfd8ef48dd44c4729", "patch": "@@ -1,3 +1,18 @@\n+2017-10-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* target.c (struct gomp_coalesce_buf): New type.\n+\t(MAX_COALESCE_BUF_SIZE, MAX_COALESCE_BUF_GAP): Define.\n+\t(gomp_coalesce_buf_add, gomp_to_device_kind_p): New functions.\n+\t(gomp_copy_host2dev): Add CBUF argument, if copying into\n+\tthe cached ranges, memcpy into buffer instead of copying\n+\tinto device.\n+\t(gomp_map_vars_existing, gomp_map_pointer, gomp_map_fields_existing):\n+\tAdd CBUF argument, pass it through to other calls.\n+\t(gomp_map_vars): Aggregate copies from host to device if small enough\n+\tand with small enough gaps in between into memcpy into a buffer and\n+\tfewer host to device copies from the buffer.\n+\t(gomp_update): Adjust gomp_copy_host2dev caller.\n+\n 2017-10-17  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* testsuite/libgomp.oacc-fortran/declare-1.f90: Restore \"dg-do"}, {"sha": "8ac05e8c6415c692a3ed55d13877cb436318d2e5", "filename": "libgomp/target.c", "status": "modified", "additions": 192, "deletions": 34, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324369a12e9abe3011f6a0cfd8ef48dd44c4729/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324369a12e9abe3011f6a0cfd8ef48dd44c4729/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=7324369a12e9abe3011f6a0cfd8ef48dd44c4729", "patch": "@@ -177,10 +177,122 @@ gomp_device_copy (struct gomp_device_descr *devicep,\n     }\n }\n \n+/* Infrastructure for coalescing adjacent or nearly adjacent (in device addresses)\n+   host to device memory transfers.  */\n+\n+struct gomp_coalesce_buf\n+{\n+  /* Buffer into which gomp_copy_host2dev will memcpy data and from which\n+     it will be copied to the device.  */\n+  void *buf;\n+  struct target_mem_desc *tgt;\n+  /* Array with offsets, chunks[2 * i] is the starting offset and\n+     chunks[2 * i + 1] ending offset relative to tgt->tgt_start device address\n+     of chunks which are to be copied to buf and later copied to device.  */\n+  size_t *chunks;\n+  /* Number of chunks in chunks array, or -1 if coalesce buffering should not\n+     be performed.  */\n+  long chunk_cnt;\n+  /* During construction of chunks array, how many memory regions are within\n+     the last chunk.  If there is just one memory region for a chunk, we copy\n+     it directly to device rather than going through buf.  */\n+  long use_cnt;\n+};\n+\n+/* Maximum size of memory region considered for coalescing.  Larger copies\n+   are performed directly.  */\n+#define MAX_COALESCE_BUF_SIZE\t(32 * 1024)\n+\n+/* Maximum size of a gap in between regions to consider them being copied\n+   within the same chunk.  All the device offsets considered are within\n+   newly allocated device memory, so it isn't fatal if we copy some padding\n+   in between from host to device.  The gaps come either from alignment\n+   padding or from memory regions which are not supposed to be copied from\n+   host to device (e.g. map(alloc:), map(from:) etc.).  */\n+#define MAX_COALESCE_BUF_GAP\t(4 * 1024)\n+\n+/* Add region with device tgt_start relative offset and length to CBUF.  */\n+\n+static inline void\n+gomp_coalesce_buf_add (struct gomp_coalesce_buf *cbuf, size_t start, size_t len)\n+{\n+  if (len > MAX_COALESCE_BUF_SIZE || len == 0)\n+    return;\n+  if (cbuf->chunk_cnt)\n+    {\n+      if (cbuf->chunk_cnt < 0)\n+\treturn;\n+      if (start < cbuf->chunks[2 * cbuf->chunk_cnt - 1])\n+\t{\n+\t  cbuf->chunk_cnt = -1;\n+\t  return;\n+\t}\n+      if (start < cbuf->chunks[2 * cbuf->chunk_cnt - 1] + MAX_COALESCE_BUF_GAP)\n+\t{\n+\t  cbuf->chunks[2 * cbuf->chunk_cnt - 1] = start + len;\n+\t  cbuf->use_cnt++;\n+\t  return;\n+\t}\n+      /* If the last chunk is only used by one mapping, discard it,\n+\t as it will be one host to device copy anyway and\n+\t memcpying it around will only waste cycles.  */\n+      if (cbuf->use_cnt == 1)\n+\tcbuf->chunk_cnt--;\n+    }\n+  cbuf->chunks[2 * cbuf->chunk_cnt] = start;\n+  cbuf->chunks[2 * cbuf->chunk_cnt + 1] = start + len;\n+  cbuf->chunk_cnt++;\n+  cbuf->use_cnt = 1;\n+}\n+\n+/* Return true for mapping kinds which need to copy data from the\n+   host to device for regions that weren't previously mapped.  */\n+\n+static inline bool\n+gomp_to_device_kind_p (int kind)\n+{\n+  switch (kind)\n+    {\n+    case GOMP_MAP_ALLOC:\n+    case GOMP_MAP_FROM:\n+    case GOMP_MAP_FORCE_ALLOC:\n+    case GOMP_MAP_ALWAYS_FROM:\n+      return false;\n+    default:\n+      return true;\n+    }\n+}\n+\n static void\n gomp_copy_host2dev (struct gomp_device_descr *devicep,\n-\t\t    void *d, const void *h, size_t sz)\n+\t\t    void *d, const void *h, size_t sz,\n+\t\t    struct gomp_coalesce_buf *cbuf)\n {\n+  if (cbuf)\n+    {\n+      uintptr_t doff = (uintptr_t) d - cbuf->tgt->tgt_start;\n+      if (doff < cbuf->chunks[2 * cbuf->chunk_cnt - 1])\n+\t{\n+\t  long first = 0;\n+\t  long last = cbuf->chunk_cnt - 1;\n+\t  while (first <= last)\n+\t    {\n+\t      long middle = (first + last) >> 1;\n+\t      if (cbuf->chunks[2 * middle + 1] <= doff)\n+\t\tfirst = middle + 1;\n+\t      else if (cbuf->chunks[2 * middle] <= doff)\n+\t\t{\n+\t\t  if (doff + sz > cbuf->chunks[2 * middle + 1])\n+\t\t    gomp_fatal (\"internal libgomp cbuf error\");\n+\t\t  memcpy ((char *) cbuf->buf + (doff - cbuf->chunks[0]),\n+\t\t\t  h, sz);\n+\t\t  return;\n+\t\t}\n+\t      else\n+\t\tlast = middle - 1;\n+\t    }\n+\t}\n+    }\n   gomp_device_copy (devicep, devicep->host2dev_func, \"dev\", d, \"host\", h, sz);\n }\n \n@@ -208,7 +320,7 @@ gomp_free_device_memory (struct gomp_device_descr *devicep, void *devptr)\n static inline void\n gomp_map_vars_existing (struct gomp_device_descr *devicep, splay_tree_key oldn,\n \t\t\tsplay_tree_key newn, struct target_var_desc *tgt_var,\n-\t\t\tunsigned char kind)\n+\t\t\tunsigned char kind, struct gomp_coalesce_buf *cbuf)\n {\n   tgt_var->key = oldn;\n   tgt_var->copy_from = GOMP_MAP_COPY_FROM_P (kind);\n@@ -232,7 +344,7 @@ gomp_map_vars_existing (struct gomp_device_descr *devicep, splay_tree_key oldn,\n \t\t\t(void *) (oldn->tgt->tgt_start + oldn->tgt_offset\n \t\t\t\t  + newn->host_start - oldn->host_start),\n \t\t\t(void *) newn->host_start,\n-\t\t\tnewn->host_end - newn->host_start);\n+\t\t\tnewn->host_end - newn->host_start, cbuf);\n \n   if (oldn->refcount != REFCOUNT_INFINITY)\n     oldn->refcount++;\n@@ -247,7 +359,8 @@ get_kind (bool short_mapkind, void *kinds, int idx)\n \n static void\n gomp_map_pointer (struct target_mem_desc *tgt, uintptr_t host_ptr,\n-\t\t  uintptr_t target_offset, uintptr_t bias)\n+\t\t  uintptr_t target_offset, uintptr_t bias,\n+\t\t  struct gomp_coalesce_buf *cbuf)\n {\n   struct gomp_device_descr *devicep = tgt->device_descr;\n   struct splay_tree_s *mem_map = &devicep->mem_map;\n@@ -257,11 +370,10 @@ gomp_map_pointer (struct target_mem_desc *tgt, uintptr_t host_ptr,\n   if (cur_node.host_start == (uintptr_t) NULL)\n     {\n       cur_node.tgt_offset = (uintptr_t) NULL;\n-      /* FIXME: see comment about coalescing host/dev transfers below.  */\n       gomp_copy_host2dev (devicep,\n \t\t\t  (void *) (tgt->tgt_start + target_offset),\n \t\t\t  (void *) &cur_node.tgt_offset,\n-\t\t\t  sizeof (void *));\n+\t\t\t  sizeof (void *), cbuf);\n       return;\n     }\n   /* Add bias to the pointer value.  */\n@@ -280,15 +392,15 @@ gomp_map_pointer (struct target_mem_desc *tgt, uintptr_t host_ptr,\n      array section.  Now subtract bias to get what we want\n      to initialize the pointer with.  */\n   cur_node.tgt_offset -= bias;\n-  /* FIXME: see comment about coalescing host/dev transfers below.  */\n   gomp_copy_host2dev (devicep, (void *) (tgt->tgt_start + target_offset),\n-\t\t      (void *) &cur_node.tgt_offset, sizeof (void *));\n+\t\t      (void *) &cur_node.tgt_offset, sizeof (void *), cbuf);\n }\n \n static void\n gomp_map_fields_existing (struct target_mem_desc *tgt, splay_tree_key n,\n \t\t\t  size_t first, size_t i, void **hostaddrs,\n-\t\t\t  size_t *sizes, void *kinds)\n+\t\t\t  size_t *sizes, void *kinds,\n+\t\t\t  struct gomp_coalesce_buf *cbuf)\n {\n   struct gomp_device_descr *devicep = tgt->device_descr;\n   struct splay_tree_s *mem_map = &devicep->mem_map;\n@@ -306,7 +418,7 @@ gomp_map_fields_existing (struct target_mem_desc *tgt, splay_tree_key n,\n       && n2->host_start - n->host_start == n2->tgt_offset - n->tgt_offset)\n     {\n       gomp_map_vars_existing (devicep, n2, &cur_node,\n-\t\t\t      &tgt->list[i], kind & typemask);\n+\t\t\t      &tgt->list[i], kind & typemask, cbuf);\n       return;\n     }\n   if (sizes[i] == 0)\n@@ -322,7 +434,7 @@ gomp_map_fields_existing (struct target_mem_desc *tgt, splay_tree_key n,\n \t\t == n2->tgt_offset - n->tgt_offset)\n \t    {\n \t      gomp_map_vars_existing (devicep, n2, &cur_node, &tgt->list[i],\n-\t\t\t\t      kind & typemask);\n+\t\t\t\t      kind & typemask, cbuf);\n \t      return;\n \t    }\n \t}\n@@ -334,7 +446,7 @@ gomp_map_fields_existing (struct target_mem_desc *tgt, splay_tree_key n,\n \t  && n2->host_start - n->host_start == n2->tgt_offset - n->tgt_offset)\n \t{\n \t  gomp_map_vars_existing (devicep, n2, &cur_node, &tgt->list[i],\n-\t\t\t\t  kind & typemask);\n+\t\t\t\t  kind & typemask, cbuf);\n \t  return;\n \t}\n     }\n@@ -381,6 +493,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n   tgt->list_count = mapnum;\n   tgt->refcount = pragma_kind == GOMP_MAP_VARS_ENTER_DATA ? 0 : 1;\n   tgt->device_descr = devicep;\n+  struct gomp_coalesce_buf cbuf, *cbufp = NULL;\n \n   if (mapnum == 0)\n     {\n@@ -391,11 +504,25 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \n   tgt_align = sizeof (void *);\n   tgt_size = 0;\n+  cbuf.chunks = NULL;\n+  cbuf.chunk_cnt = -1;\n+  cbuf.use_cnt = 0;\n+  cbuf.buf = NULL;\n+  if (mapnum > 1 || pragma_kind == GOMP_MAP_VARS_TARGET)\n+    {\n+      cbuf.chunks\n+\t= (size_t *) gomp_alloca ((2 * mapnum + 2) * sizeof (size_t));\n+      cbuf.chunk_cnt = 0;\n+    }\n   if (pragma_kind == GOMP_MAP_VARS_TARGET)\n     {\n       size_t align = 4 * sizeof (void *);\n       tgt_align = align;\n       tgt_size = mapnum * sizeof (void *);\n+      cbuf.chunk_cnt = 1;\n+      cbuf.use_cnt = 1 + (mapnum > 1);\n+      cbuf.chunks[0] = 0;\n+      cbuf.chunks[1] = tgt_size;\n     }\n \n   gomp_mutex_lock (&devicep->lock);\n@@ -449,19 +576,26 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t      size_t align = (size_t) 1 << (kind >> rshift);\n \t      if (tgt_align < align)\n \t\ttgt_align = align;\n-\t      tgt_size -= (uintptr_t) hostaddrs[first]\n-\t\t\t  - (uintptr_t) hostaddrs[i];\n+\t      tgt_size -= (uintptr_t) hostaddrs[first] - cur_node.host_start;\n \t      tgt_size = (tgt_size + align - 1) & ~(align - 1);\n-\t      tgt_size += cur_node.host_end - (uintptr_t) hostaddrs[i];\n+\t      tgt_size += cur_node.host_end - cur_node.host_start;\n \t      not_found_cnt += last - i;\n \t      for (i = first; i <= last; i++)\n-\t\ttgt->list[i].key = NULL;\n+\t\t{\n+\t\t  tgt->list[i].key = NULL;\n+\t\t  if (gomp_to_device_kind_p (get_kind (short_mapkind, kinds, i)\n+\t\t\t\t\t     & typemask))\n+\t\t    gomp_coalesce_buf_add (&cbuf,\n+\t\t\t\t\t   tgt_size - cur_node.host_end\n+\t\t\t\t\t   + (uintptr_t) hostaddrs[i],\n+\t\t\t\t\t   sizes[i]);\n+\t\t}\n \t      i--;\n \t      continue;\n \t    }\n \t  for (i = first; i <= last; i++)\n \t    gomp_map_fields_existing (tgt, n, first, i, hostaddrs,\n-\t\t\t\t      sizes, kinds);\n+\t\t\t\t      sizes, kinds, NULL);\n \t  i--;\n \t  continue;\n \t}\n@@ -485,6 +619,8 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t  if (tgt_align < align)\n \t    tgt_align = align;\n \t  tgt_size = (tgt_size + align - 1) & ~(align - 1);\n+\t  gomp_coalesce_buf_add (&cbuf, tgt_size,\n+\t\t\t\t cur_node.host_end - cur_node.host_start);\n \t  tgt_size += cur_node.host_end - cur_node.host_start;\n \t  has_firstprivate = true;\n \t  continue;\n@@ -504,7 +640,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \tn = splay_tree_lookup (mem_map, &cur_node);\n       if (n && n->refcount != REFCOUNT_LINK)\n \tgomp_map_vars_existing (devicep, n, &cur_node, &tgt->list[i],\n-\t\t\t\tkind & typemask);\n+\t\t\t\tkind & typemask, NULL);\n       else\n \t{\n \t  tgt->list[i].key = NULL;\n@@ -514,6 +650,9 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t  if (tgt_align < align)\n \t    tgt_align = align;\n \t  tgt_size = (tgt_size + align - 1) & ~(align - 1);\n+\t  if (gomp_to_device_kind_p (kind & typemask))\n+\t    gomp_coalesce_buf_add (&cbuf, tgt_size,\n+\t\t\t\t   cur_node.host_end - cur_node.host_start);\n \t  tgt_size += cur_node.host_end - cur_node.host_start;\n \t  if ((kind & typemask) == GOMP_MAP_TO_PSET)\n \t    {\n@@ -562,6 +701,19 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n       tgt->tgt_start = (uintptr_t) tgt->to_free;\n       tgt->tgt_start = (tgt->tgt_start + tgt_align - 1) & ~(tgt_align - 1);\n       tgt->tgt_end = tgt->tgt_start + tgt_size;\n+\n+      if (cbuf.use_cnt == 1)\n+\tcbuf.chunk_cnt--;\n+      if (cbuf.chunk_cnt > 0)\n+\t{\n+\t  cbuf.buf\n+\t    = malloc (cbuf.chunks[2 * cbuf.chunk_cnt - 1] - cbuf.chunks[0]);\n+\t  if (cbuf.buf)\n+\t    {\n+\t      cbuf.tgt = tgt;\n+\t      cbufp = &cbuf;\n+\t    }\n+\t}\n     }\n   else\n     {\n@@ -600,7 +752,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\tlen = sizes[i];\n \t\tgomp_copy_host2dev (devicep,\n \t\t\t\t    (void *) (tgt->tgt_start + tgt_size),\n-\t\t\t\t    (void *) hostaddrs[i], len);\n+\t\t\t\t    (void *) hostaddrs[i], len, cbufp);\n \t\ttgt_size += len;\n \t\tcontinue;\n \t      case GOMP_MAP_FIRSTPRIVATE_INT:\n@@ -633,7 +785,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t  }\n \t\tfor (i = first; i <= last; i++)\n \t\t  gomp_map_fields_existing (tgt, n, first, i, hostaddrs,\n-\t\t\t\t\t    sizes, kinds);\n+\t\t\t\t\t    sizes, kinds, cbufp);\n \t\ti--;\n \t\tcontinue;\n \t      case GOMP_MAP_ALWAYS_POINTER:\n@@ -658,7 +810,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t\t\t\t      + cur_node.host_start\n \t\t\t\t\t      - n->host_start),\n \t\t\t\t    (void *) &cur_node.tgt_offset,\n-\t\t\t\t    sizeof (void *));\n+\t\t\t\t    sizeof (void *), cbufp);\n \t\tcur_node.tgt_offset = n->tgt->tgt_start + n->tgt_offset\n \t\t\t\t      + cur_node.host_start - n->host_start;\n \t\tcontinue;\n@@ -674,7 +826,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t    splay_tree_key n = splay_tree_lookup (mem_map, k);\n \t    if (n && n->refcount != REFCOUNT_LINK)\n \t      gomp_map_vars_existing (devicep, n, k, &tgt->list[i],\n-\t\t\t\t      kind & typemask);\n+\t\t\t\t      kind & typemask, cbufp);\n \t    else\n \t      {\n \t\tk->link_key = NULL;\n@@ -725,26 +877,22 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t  case GOMP_MAP_FORCE_TOFROM:\n \t\t  case GOMP_MAP_ALWAYS_TO:\n \t\t  case GOMP_MAP_ALWAYS_TOFROM:\n-\t\t    /* FIXME: Perhaps add some smarts, like if copying\n-\t\t       several adjacent fields from host to target, use some\n-\t\t       host buffer to avoid sending each var individually.  */\n \t\t    gomp_copy_host2dev (devicep,\n \t\t\t\t\t(void *) (tgt->tgt_start\n \t\t\t\t\t\t  + k->tgt_offset),\n \t\t\t\t\t(void *) k->host_start,\n-\t\t\t\t\tk->host_end - k->host_start);\n+\t\t\t\t\tk->host_end - k->host_start, cbufp);\n \t\t    break;\n \t\t  case GOMP_MAP_POINTER:\n \t\t    gomp_map_pointer (tgt, (uintptr_t) *(void **) k->host_start,\n-\t\t\t\t      k->tgt_offset, sizes[i]);\n+\t\t\t\t      k->tgt_offset, sizes[i], cbufp);\n \t\t    break;\n \t\t  case GOMP_MAP_TO_PSET:\n-\t\t    /* FIXME: see above FIXME comment.  */\n \t\t    gomp_copy_host2dev (devicep,\n \t\t\t\t\t(void *) (tgt->tgt_start\n \t\t\t\t\t\t  + k->tgt_offset),\n \t\t\t\t\t(void *) k->host_start,\n-\t\t\t\t\tk->host_end - k->host_start);\n+\t\t\t\t\tk->host_end - k->host_start, cbufp);\n \n \t\t    for (j = i + 1; j < mapnum; j++)\n \t\t      if (!GOMP_MAP_POINTER_P (get_kind (short_mapkind, kinds,\n@@ -767,7 +915,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t\t\t\t    k->tgt_offset\n \t\t\t\t\t    + ((uintptr_t) hostaddrs[j]\n \t\t\t\t\t       - k->host_start),\n-\t\t\t\t\t    sizes[j]);\n+\t\t\t\t\t    sizes[j], cbufp);\n \t\t\t  i++;\n \t\t\t}\n \t\t    break;\n@@ -795,7 +943,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t\t\t\t(void *) (tgt->tgt_start\n \t\t\t\t\t\t  + k->tgt_offset),\n \t\t\t\t\t(void *) k->host_start,\n-\t\t\t\t\tsizeof (void *));\n+\t\t\t\t\tsizeof (void *), cbufp);\n \t\t    break;\n \t\t  default:\n \t\t    gomp_mutex_unlock (&devicep->lock);\n@@ -822,13 +970,23 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n       for (i = 0; i < mapnum; i++)\n \t{\n \t  cur_node.tgt_offset = gomp_map_val (tgt, hostaddrs, i);\n-\t  /* FIXME: see above FIXME comment.  */\n \t  gomp_copy_host2dev (devicep,\n \t\t\t      (void *) (tgt->tgt_start + i * sizeof (void *)),\n-\t\t\t      (void *) &cur_node.tgt_offset, sizeof (void *));\n+\t\t\t      (void *) &cur_node.tgt_offset, sizeof (void *),\n+\t\t\t      cbufp);\n \t}\n     }\n \n+  if (cbufp)\n+    {\n+      long c = 0;\n+      for (c = 0; c < cbuf.chunk_cnt; ++c)\n+\tgomp_copy_host2dev (devicep, (void *) (tgt->tgt_start + cbuf.chunks[2 * c]),\n+\t\t\t    (char *) cbuf.buf + (cbuf.chunks[2 * c] - cbuf.chunks[0]),\n+\t\t\t    cbuf.chunks[2 * c + 1] - cbuf.chunks[2 * c], NULL);\n+      free (cbuf.buf);\n+    }\n+\n   /* If the variable from \"omp target enter data\" map-list was already mapped,\n      tgt is not needed.  Otherwise tgt will be freed by gomp_unmap_vars or\n      gomp_exit_data.  */\n@@ -970,7 +1128,7 @@ gomp_update (struct gomp_device_descr *devicep, size_t mapnum, void **hostaddrs,\n \t    size_t size = cur_node.host_end - cur_node.host_start;\n \n \t    if (GOMP_MAP_COPY_TO_P (kind & typemask))\n-\t      gomp_copy_host2dev (devicep, devaddr, hostaddr, size);\n+\t      gomp_copy_host2dev (devicep, devaddr, hostaddr, size, NULL);\n \t    if (GOMP_MAP_COPY_FROM_P (kind & typemask))\n \t      gomp_copy_dev2host (devicep, hostaddr, devaddr, size);\n \t  }"}]}