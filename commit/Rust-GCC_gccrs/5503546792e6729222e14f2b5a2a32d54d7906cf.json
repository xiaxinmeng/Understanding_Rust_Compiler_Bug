{"sha": "5503546792e6729222e14f2b5a2a32d54d7906cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUwMzU0Njc5MmU2NzI5MjIyZTE0ZjJiNWEyYTMyZDU0ZDc5MDZjZg==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2007-09-13T00:07:54Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2007-09-13T00:07:54Z"}, "message": "dfp-bit.c (dfp_conversion_exception): New function.\n\n\t* config/dfp-bit.c (dfp_conversion_exception): New function.\n\t(DFP_TO_DFP) Add new variants to use direct conversions in decNumber.\n\t(DFP_TO_INT): Ditto.\n\t(INT_TO_DFP): Ditto.\n\t* config/dfp-bit.h (DEC_FLOAT_FROM_INT, DEC_FLOAT_TO_INT): New.\n\nFrom-SVN: r128449", "tree": {"sha": "806b29595982609937fea860164e9c49e87671e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/806b29595982609937fea860164e9c49e87671e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5503546792e6729222e14f2b5a2a32d54d7906cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5503546792e6729222e14f2b5a2a32d54d7906cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5503546792e6729222e14f2b5a2a32d54d7906cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5503546792e6729222e14f2b5a2a32d54d7906cf/comments", "author": null, "committer": null, "parents": [{"sha": "5e11f978edb440183b510ee5ead717a03d6fcc6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e11f978edb440183b510ee5ead717a03d6fcc6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e11f978edb440183b510ee5ead717a03d6fcc6a"}], "stats": {"total": 249, "additions": 209, "deletions": 40}, "files": [{"sha": "18f97aeef3a3b33130bf66abf24ba3c3025898bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5503546792e6729222e14f2b5a2a32d54d7906cf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5503546792e6729222e14f2b5a2a32d54d7906cf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5503546792e6729222e14f2b5a2a32d54d7906cf", "patch": "@@ -1,3 +1,11 @@\n+2007-09-12  Janis Johnson  <janis187@us.ibm.com\n+\n+\t* config/dfp-bit.c (dfp_conversion_exception): New function.\n+\t(DFP_TO_DFP) Add new variants to use direct conversions in decNumber.\n+\t(DFP_TO_INT): Ditto.\n+\t(INT_TO_DFP): Ditto.\n+\t* config/dfp-bit.h (DEC_FLOAT_FROM_INT, DEC_FLOAT_TO_INT): New.\n+\n 2007-09-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/32338"}, {"sha": "ac574434dfbfab13670a38b5ac2370c35ee3f6f4", "filename": "gcc/config/dfp-bit.c", "status": "modified", "additions": 187, "deletions": 40, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5503546792e6729222e14f2b5a2a32d54d7906cf/gcc%2Fconfig%2Fdfp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5503546792e6729222e14f2b5a2a32d54d7906cf/gcc%2Fconfig%2Fdfp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdfp-bit.c?ref=5503546792e6729222e14f2b5a2a32d54d7906cf", "patch": "@@ -348,45 +348,169 @@ DFP_GE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n \n #define BUFMAX 128\n \n-#if defined (L_sd_to_dd) || defined (L_sd_to_td) || defined (L_dd_to_sd) \\\n- || defined (L_dd_to_td) || defined (L_td_to_sd) || defined (L_td_to_dd)\n-DFP_C_TYPE_TO\n-DFP_TO_DFP (DFP_C_TYPE f_from)\n-{\n-  DFP_C_TYPE_TO f_to;\n-  IEEE_TYPE s_from;\n-  IEEE_TYPE_TO s_to;\n-  decNumber d;\n+/* Check for floating point exceptions that are relevant for conversions\n+   between decimal float values and handle them.  */\n+static inline void\n+dfp_conversion_exceptions (const int status)\n+{\n+  /* decNumber exception flags we care about here.  */\n+  int ieee_flags;\n+  int dec_flags = DEC_IEEE_854_Inexact | DEC_IEEE_854_Invalid_operation\n+\t\t  | DEC_IEEE_854_Overflow;\n+  dec_flags &= status;\n+  ieee_flags = DFP_IEEE_FLAGS (dec_flags);\n+  if (ieee_flags != 0)\n+    DFP_HANDLE_EXCEPTIONS (ieee_flags);\n+}\n+\n+#if defined (L_sd_to_dd)\n+/* Use decNumber to convert directly from _Decimal32 to _Decimal64.  */\n+_Decimal64\n+DFP_TO_DFP (_Decimal32 f_from)\n+{\n+  union { _Decimal32 c; decSingle f; } from;\n+  union { _Decimal64 c; decDouble f; } to;\n+\n+  from.c = f_from;\n+  to.f = *decSingleToWider (&from.f, &to.f);\n+  return to.c;\n+}\n+#endif\n+\n+#if defined (L_sd_to_td)\n+/* Use decNumber to convert directly from _Decimal32 to _Decimal128.  */\n+_Decimal128\n+DFP_TO_DFP (_Decimal32 f_from)\n+{\n+  union { _Decimal32 c; decSingle f; } from;\n+  union { _Decimal128 c; decQuad f; } to;\n+  decDouble temp;\n+\n+  from.c = f_from;\n+  temp = *decSingleToWider (&from.f, &temp);\n+  to.f = *decDoubleToWider (&temp, &to.f);\n+  return to.c;\n+}\n+#endif\n+\n+#if defined (L_dd_to_td)\n+/* Use decNumber to convert directly from _Decimal64 to _Decimal128.  */\n+_Decimal128\n+DFP_TO_DFP (_Decimal64 f_from)\n+{\n+  union { _Decimal64 c; decDouble f; } from;\n+  union { _Decimal128 c; decQuad f; } to;\n+\n+  from.c = f_from;\n+  to.f = *decDoubleToWider (&from.f, &to.f);\n+  return to.c;\n+}\n+#endif\n+\n+#if defined (L_dd_to_sd)\n+/* Use decNumber to convert directly from _Decimal64 to _Decimal32.  */\n+_Decimal32\n+DFP_TO_DFP (_Decimal64 f_from)\n+{\n+  union { _Decimal32 c; decSingle f; } to;\n+  union { _Decimal64 c; decDouble f; } from;\n   decContext context;\n \n   decContextDefault (&context, CONTEXT_INIT);\n   DFP_INIT_ROUNDMODE (context.round);\n+  from.c = f_from;\n+  to.f = *decSingleFromWider (&to.f, &from.f, &context);\n+  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n+    dfp_conversion_exceptions (context.status);\n+  return to.c;\n+}\n+#endif\n \n-  HOST_TO_IEEE (f_from, &s_from);\n-  TO_INTERNAL (&s_from, &d);\n-  TO_ENCODED_TO (&s_to, &d, &context);\n+#if defined (L_td_to_sd)\n+/* Use decNumber to convert directly from _Decimal128 to _Decimal32.  */\n+_Decimal32\n+DFP_TO_DFP (_Decimal128 f_from)\n+{\n+  union { _Decimal32 c; decSingle f; } to;\n+  union { _Decimal128 c; decQuad f; } from;\n+  decDouble temp;\n+  decContext context;\n \n+  decContextDefault (&context, CONTEXT_INIT);\n+  DFP_INIT_ROUNDMODE (context.round);\n+  from.c = f_from;\n+  temp = *decDoubleFromWider (&temp, &from.f, &context);\n+  to.f = *decSingleFromWider (&to.f, &temp, &context);\n   if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n-    {\n-      /* decNumber exception flags we care about here.  */\n-      int ieee_flags;\n-      int dec_flags = DEC_IEEE_854_Inexact | DEC_IEEE_854_Invalid_operation\n-\t\t      | DEC_IEEE_854_Overflow;\n-      dec_flags &= context.status;\n-      ieee_flags = DFP_IEEE_FLAGS (dec_flags);\n-      if (ieee_flags != 0)\n-        DFP_HANDLE_EXCEPTIONS (ieee_flags);\n-    }\n+    dfp_conversion_exceptions (context.status);\n+  return to.c;\n+}\n+#endif\n+\n+#if defined (L_td_to_dd)\n+/* Use decNumber to convert directly from _Decimal128 to _Decimal64.  */\n+_Decimal64\n+DFP_TO_DFP (_Decimal128 f_from)\n+{\n+  union { _Decimal64 c; decDouble f; } to;\n+  union { _Decimal128 c; decQuad f; } from;\n+  decContext context;\n \n-  IEEE_TO_HOST_TO (s_to, &f_to);\n-  return f_to;\n+  decContextDefault (&context, CONTEXT_INIT);\n+  DFP_INIT_ROUNDMODE (context.round);\n+  from.c = f_from;\n+  to.f = *decDoubleFromWider (&to.f, &from.f, &context);\n+  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n+    dfp_conversion_exceptions (context.status);\n+  return to.c;\n }\n #endif\n \n-#if defined (L_sd_to_si) || defined (L_dd_to_si) || defined (L_td_to_si) \\\n-  || defined (L_sd_to_di) || defined (L_dd_to_di) || defined (L_td_to_di) \\\n-  || defined (L_sd_to_usi) || defined (L_dd_to_usi) || defined (L_td_to_usi) \\\n+#if defined (L_dd_to_si) || defined (L_td_to_si) \\\n+  || defined (L_dd_to_usi) || defined (L_td_to_usi)\n+/* Use decNumber to convert directly from decimal float to integer types.  */\n+INT_TYPE\n+DFP_TO_INT (DFP_C_TYPE x)\n+{\n+  union { DFP_C_TYPE c; decFloat f; } u;\n+  decContext context;\n+  INT_TYPE i;\n+\n+  decContextDefault (&context, DEC_INIT_DECIMAL128);\n+  context.round = DEC_ROUND_DOWN;\n+  u.c = x;\n+  i = DEC_FLOAT_TO_INT (&u.f, &context, context.round);\n+  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n+    dfp_conversion_exceptions (context.status);\n+  return i;\n+}\n+#endif\n+\n+#if defined (L_sd_to_si) || (L_sd_to_usi)\n+/* Use decNumber to convert directly from decimal float to integer types.  */\n+INT_TYPE\n+DFP_TO_INT (_Decimal32 x)\n+{\n+  union { _Decimal32 c; decSingle f; } u32;\n+  decDouble f64;\n+  decContext context;\n+  INT_TYPE i;\n+\n+  decContextDefault (&context, DEC_INIT_DECIMAL128);\n+  context.round = DEC_ROUND_DOWN;\n+  u32.c = x;\n+  f64 = *decSingleToWider (&u32.f, &f64);\n+  i = DEC_FLOAT_TO_INT (&f64, &context, context.round);\n+  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n+    dfp_conversion_exceptions (context.status);\n+  return i;\n+}\n+#endif\n+\n+#if defined (L_sd_to_di) || defined (L_dd_to_di) || defined (L_td_to_di) \\\n   || defined (L_sd_to_udi) || defined (L_dd_to_udi) || defined (L_td_to_udi)\n+/* decNumber doesn't provide support for conversions to 64-bit integer\n+   types, so do it the hard way.  */\n INT_TYPE\n DFP_TO_INT (DFP_C_TYPE x)\n {\n@@ -426,10 +550,42 @@ DFP_TO_INT (DFP_C_TYPE x)\n }\n #endif\n \n-#if defined (L_si_to_sd) || defined (L_si_to_dd) || defined (L_si_to_td) \\\n-  || defined (L_di_to_sd) || defined (L_di_to_dd) || defined (L_di_to_td) \\\n-  || defined (L_usi_to_sd) || defined (L_usi_to_dd) || defined (L_usi_to_td) \\\n+#if defined (L_si_to_dd) || defined (L_si_to_td) \\\n+  || defined (L_usi_to_dd) || defined (L_usi_to_td)\n+/* Use decNumber to convert directly from integer to decimal float types.  */\n+DFP_C_TYPE\n+INT_TO_DFP (INT_TYPE i)\n+{\n+  union { DFP_C_TYPE c; decFloat f; } u;\n+\n+  u.f = *DEC_FLOAT_FROM_INT (&u.f, i);\n+  return u.c;\n+}\n+#endif\n+\n+#if defined (L_si_to_sd) || defined (L_usi_to_sd)\n+_Decimal32\n+/* Use decNumber to convert directly from integer to decimal float types.  */\n+INT_TO_DFP (INT_TYPE i)\n+{\n+  union { _Decimal32 c; decSingle f; } u32;\n+  decDouble f64;\n+  decContext context;\n+\n+  decContextDefault (&context, DEC_INIT_DECIMAL128);\n+  context.round = DEC_ROUND_DOWN;\n+  f64 = *DEC_FLOAT_FROM_INT (&f64, i);\n+  u32.f = *decSingleFromWider (&u32.f, &f64, &context);\n+  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n+    dfp_conversion_exceptions (context.status);\n+  return u32.c;\n+}\n+#endif\n+\n+#if defined (L_di_to_sd) || defined (L_di_to_dd) || defined (L_di_to_td) \\\n   || defined (L_udi_to_sd) || defined (L_udi_to_dd) || defined (L_udi_to_td)\n+/* decNumber doesn't provide support for conversions from 64-bit integer\n+   types, so do it the hard way.  */\n DFP_C_TYPE\n INT_TO_DFP (INT_TYPE i)\n {\n@@ -448,16 +604,7 @@ INT_TO_DFP (INT_TYPE i)\n   IEEE_TO_HOST (s, &f);\n \n   if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n-    {\n-      /* decNumber exception flags we care about here.  */\n-      int ieee_flags;\n-      int dec_flags = DEC_IEEE_854_Inexact | DEC_IEEE_854_Invalid_operation\n-\t\t      | DEC_IEEE_854_Overflow;\n-      dec_flags &= context.status;\n-      ieee_flags = DFP_IEEE_FLAGS (dec_flags);\n-      if (ieee_flags != 0)\n-        DFP_HANDLE_EXCEPTIONS (ieee_flags);\n-    }\n+    dfp_conversion_exceptions (context.status);\n \n   return f;\n }"}, {"sha": "c02535bc462ff30639ee6be026a06a4df7f241d4", "filename": "gcc/config/dfp-bit.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5503546792e6729222e14f2b5a2a32d54d7906cf/gcc%2Fconfig%2Fdfp-bit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5503546792e6729222e14f2b5a2a32d54d7906cf/gcc%2Fconfig%2Fdfp-bit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdfp-bit.h?ref=5503546792e6729222e14f2b5a2a32d54d7906cf", "patch": "@@ -431,40 +431,54 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #if INT_KIND == 1\n #define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatsisd,__bid_floatsisd)\n #define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixsdsi,__bid_fixsdsi)\n+#define DEC_FLOAT_FROM_INT decDoubleFromInt32\n+#define DEC_FLOAT_TO_INT   decDoubleToInt32\n #elif INT_KIND == 2\n #define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatdisd,__bid_floatdisd)\n #define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixsddi,__bid_fixsddi)\n #elif INT_KIND == 3\n #define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunssisd,__bid_floatunssisd)\n #define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunssdsi,__bid_fixunssdsi)\n+#define DEC_FLOAT_FROM_INT decDoubleFromUInt32\n+#define DEC_FLOAT_TO_INT   decDoubleToUInt32\n #elif INT_KIND == 4\n #define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunsdisd,__bid_floatunsdisd)\n #define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunssddi,__bid_fixunssddi)\n #endif\n #elif WIDTH == 64\n+#define decFloat\tdecDouble\n #if INT_KIND == 1\n #define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatsidd,__bid_floatsidd)\n #define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixddsi,__bid_fixddsi)\n+#define DEC_FLOAT_FROM_INT decDoubleFromInt32\n+#define DEC_FLOAT_TO_INT   decDoubleToInt32\n #elif INT_KIND == 2\n #define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatdidd,__bid_floatdidd)\n #define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixdddi,__bid_fixdddi)\n #elif INT_KIND == 3\n #define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunssidd,__bid_floatunssidd)\n #define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunsddsi,__bid_fixunsddsi)\n+#define DEC_FLOAT_FROM_INT decDoubleFromUInt32\n+#define DEC_FLOAT_TO_INT   decDoubleToUInt32\n #elif INT_KIND == 4\n #define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunsdidd,__bid_floatunsdidd)\n #define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunsdddi,__bid_fixunsdddi)\n #endif\n #elif WIDTH == 128\n+#define decFloat\tdecQuad\n #if INT_KIND == 1\n #define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatsitd,__bid_floatsitd)\n #define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixtdsi,__bid_fixtdsi)\n+#define DEC_FLOAT_FROM_INT decQuadFromInt32\n+#define DEC_FLOAT_TO_INT   decQuadToInt32\n #elif INT_KIND == 2\n #define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatditd,__bid_floatditd)\n #define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixtddi,__bid_fixtddi)\n #elif INT_KIND == 3\n #define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunssitd,__bid_floatunssitd)\n #define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunstdsi,__bid_fixunstdsi)\n+#define DEC_FLOAT_FROM_INT decQuadFromUInt32\n+#define DEC_FLOAT_TO_INT   decQuadToUInt32\n #elif INT_KIND == 4\n #define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunsditd,__bid_floatunsditd)\n #define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunstddi,__bid_fixunstddi)"}]}