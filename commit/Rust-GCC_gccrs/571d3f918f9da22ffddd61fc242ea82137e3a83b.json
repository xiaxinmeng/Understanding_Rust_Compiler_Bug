{"sha": "571d3f918f9da22ffddd61fc242ea82137e3a83b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTcxZDNmOTE4ZjlkYTIyZmZkZGQ2MWZjMjQyZWE4MjEzN2UzYTgzYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-06-24T22:11:12Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-06-24T22:11:12Z"}, "message": "compiler: Add support for method values.\n\nFrom-SVN: r200379", "tree": {"sha": "575c45d989d9a3d57adb0bb10d9de3696a89c252", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/575c45d989d9a3d57adb0bb10d9de3696a89c252"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/571d3f918f9da22ffddd61fc242ea82137e3a83b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/571d3f918f9da22ffddd61fc242ea82137e3a83b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/571d3f918f9da22ffddd61fc242ea82137e3a83b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/571d3f918f9da22ffddd61fc242ea82137e3a83b/comments", "author": null, "committer": null, "parents": [{"sha": "39953c79725971061079d2d8c1c9c7c64a73aced", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39953c79725971061079d2d8c1c9c7c64a73aced", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39953c79725971061079d2d8c1c9c7c64a73aced"}], "stats": {"total": 860, "additions": 699, "deletions": 161}, "files": [{"sha": "1e40882ecad72da8c91f466bb47f3e5f13daab09", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 525, "deletions": 56, "changes": 581, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d3f918f9da22ffddd61fc242ea82137e3a83b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d3f918f9da22ffddd61fc242ea82137e3a83b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=571d3f918f9da22ffddd61fc242ea82137e3a83b", "patch": "@@ -1090,6 +1090,15 @@ Set_and_use_temporary_expression::do_type()\n   return this->statement_->type();\n }\n \n+// Determine the type of the expression.\n+\n+void\n+Set_and_use_temporary_expression::do_determine_type(\n+    const Type_context* context)\n+{\n+  this->expr_->determine_type(context);\n+}\n+\n // Take the address.\n \n void\n@@ -6626,28 +6635,64 @@ Bound_method_expression::do_traverse(Traverse* traverse)\n   return Expression::traverse(&this->expr_, traverse);\n }\n \n+// Lower the expression.  If this is a method value rather than being\n+// called, and the method is accessed via a pointer, we may need to\n+// add nil checks.  Introduce a temporary variable so that those nil\n+// checks do not cause multiple evaluation.\n+\n+Expression*\n+Bound_method_expression::do_lower(Gogo*, Named_object*,\n+\t\t\t\t  Statement_inserter* inserter, int)\n+{\n+  // For simplicity we use a temporary for every call to an embedded\n+  // method, even though some of them might be pure value methods and\n+  // not require a temporary.\n+  if (this->expr_->var_expression() == NULL\n+      && this->expr_->temporary_reference_expression() == NULL\n+      && this->expr_->set_and_use_temporary_expression() == NULL\n+      && (this->method_->field_indexes() != NULL\n+\t  || (this->method_->is_value_method()\n+\t      && this->expr_->type()->points_to() != NULL)))\n+    {\n+      Temporary_statement* temp =\n+\tStatement::make_temporary(this->expr_->type(), NULL, this->location());\n+      inserter->insert(temp);\n+      this->expr_ = Expression::make_set_and_use_temporary(temp, this->expr_,\n+\t\t\t\t\t\t\t   this->location());\n+    }\n+  return this;\n+}\n+\n // Return the type of a bound method expression.  The type of this\n-// object is really the type of the method with no receiver.  We\n-// should be able to get away with just returning the type of the\n-// method.\n+// object is simply the type of the method with no receiver.\n \n Type*\n Bound_method_expression::do_type()\n {\n-  if (this->method_->is_function())\n-    return this->method_->func_value()->type();\n-  else if (this->method_->is_function_declaration())\n-    return this->method_->func_declaration_value()->type();\n+  Named_object* fn = this->method_->named_object();\n+  Function_type* fntype;\n+  if (fn->is_function())\n+    fntype = fn->func_value()->type();\n+  else if (fn->is_function_declaration())\n+    fntype = fn->func_declaration_value()->type();\n   else\n     return Type::make_error_type();\n+  return fntype->copy_without_receiver();\n }\n \n // Determine the types of a method expression.\n \n void\n Bound_method_expression::do_determine_type(const Type_context*)\n {\n-  Function_type* fntype = this->type()->function_type();\n+  Named_object* fn = this->method_->named_object();\n+  Function_type* fntype;\n+  if (fn->is_function())\n+    fntype = fn->func_value()->type();\n+  else if (fn->is_function_declaration())\n+    fntype = fn->func_declaration_value()->type();\n+  else\n+    fntype = NULL;\n   if (fntype == NULL || !fntype->is_method())\n     this->expr_->determine_type_no_context();\n   else\n@@ -6662,31 +6707,278 @@ Bound_method_expression::do_determine_type(const Type_context*)\n void\n Bound_method_expression::do_check_types(Gogo*)\n {\n-  if (!this->method_->is_function()\n-      && !this->method_->is_function_declaration())\n-    this->report_error(_(\"object is not a method\"));\n+  Named_object* fn = this->method_->named_object();\n+  if (!fn->is_function() && !fn->is_function_declaration())\n+    {\n+      this->report_error(_(\"object is not a method\"));\n+      return;\n+    }\n+\n+  Function_type* fntype;\n+  if (fn->is_function())\n+    fntype = fn->func_value()->type();\n+  else if (fn->is_function_declaration())\n+    fntype = fn->func_declaration_value()->type();\n+  else\n+    go_unreachable();\n+  Type* rtype = fntype->receiver()->type()->deref();\n+  Type* etype = (this->expr_type_ != NULL\n+\t\t ? this->expr_type_\n+\t\t : this->expr_->type());\n+  etype = etype->deref();\n+  if (!Type::are_identical(rtype, etype, true, NULL))\n+    this->report_error(_(\"method type does not match object type\"));\n+}\n+\n+// If a bound method expression is not simply called, then it is\n+// represented as a closure.  The closure will hold a single variable,\n+// the receiver to pass to the method.  The function will be a simple\n+// thunk that pulls that value from the closure and calls the method\n+// with the remaining arguments.\n+//\n+// Because method values are not common, we don't build all thunks for\n+// every methods, but instead only build them as we need them.  In\n+// particular, we even build them on demand for methods defined in\n+// other packages.\n+\n+Bound_method_expression::Method_value_thunks\n+  Bound_method_expression::method_value_thunks;\n+\n+// Find or create the thunk for METHOD.\n+\n+Named_object*\n+Bound_method_expression::create_thunk(Gogo* gogo, const Method* method,\n+\t\t\t\t      Named_object* fn)\n+{\n+  std::pair<Named_object*, Named_object*> val(fn, NULL);\n+  std::pair<Method_value_thunks::iterator, bool> ins =\n+    Bound_method_expression::method_value_thunks.insert(val);\n+  if (!ins.second)\n+    {\n+      // We have seen this method before.\n+      go_assert(ins.first->second != NULL);\n+      return ins.first->second;\n+    }\n+\n+  Location loc = fn->location();\n+\n+  Function_type* orig_fntype;\n+  if (fn->is_function())\n+    orig_fntype = fn->func_value()->type();\n+  else if (fn->is_function_declaration())\n+    orig_fntype = fn->func_declaration_value()->type();\n+  else\n+    orig_fntype = NULL;\n+\n+  if (orig_fntype == NULL || !orig_fntype->is_method())\n+    {\n+      ins.first->second = Named_object::make_erroneous_name(Gogo::thunk_name());\n+      return ins.first->second;\n+    }\n+\n+  Struct_field_list* sfl = new Struct_field_list();\n+  // The type here is wrong--it should be new_fntype.  But we don't\n+  // have new_fntype yet, and it doesn't really matter.\n+  Type* vt = Type::make_pointer_type(Type::make_void_type());\n+  sfl->push_back(Struct_field(Typed_identifier(\"fn.0\", vt, loc)));\n+  sfl->push_back(Struct_field(Typed_identifier(\"val.1\",\n+\t\t\t\t\t       orig_fntype->receiver()->type(),\n+\t\t\t\t\t       loc)));\n+  Type* closure_type = Type::make_struct_type(sfl, loc);\n+  closure_type = Type::make_pointer_type(closure_type);\n+\n+  Function_type* new_fntype = orig_fntype->copy_with_closure(closure_type);\n+\n+  Named_object* new_no = gogo->start_function(Gogo::thunk_name(), new_fntype,\n+\t\t\t\t\t      false, loc);\n+\n+  gogo->start_block(loc);\n+\n+  Named_object* cp = gogo->lookup(\"closure.0\", NULL);\n+  go_assert(cp != NULL\n+\t    && cp->is_variable()\n+\t    && cp->var_value()->is_parameter());\n+\n+  // Field 0 of the closure is the function code pointer, field 1 is\n+  // the value on which to invoke the method.\n+  Expression* arg = Expression::make_var_reference(cp, loc);\n+  arg = Expression::make_unary(OPERATOR_MULT, arg, loc);\n+  arg = Expression::make_field_reference(arg, 1, loc);\n+\n+  Expression* bme = Expression::make_bound_method(arg, method, fn, loc);\n+\n+  const Typed_identifier_list* orig_params = orig_fntype->parameters();\n+  Expression_list* args;\n+  if (orig_params == NULL || orig_params->empty())\n+    args = NULL;\n   else\n     {\n-      Type* rtype = this->type()->function_type()->receiver()->type()->deref();\n-      Type* etype = (this->expr_type_ != NULL\n-\t\t     ? this->expr_type_\n-\t\t     : this->expr_->type());\n-      etype = etype->deref();\n-      if (!Type::are_identical(rtype, etype, true, NULL))\n-\tthis->report_error(_(\"method type does not match object type\"));\n+      const Typed_identifier_list* new_params = new_fntype->parameters();\n+      args = new Expression_list();\n+      for (Typed_identifier_list::const_iterator p = new_params->begin();\n+\t   p + 1 != new_params->end();\n+\t   ++p)\n+\t{\n+\t  Named_object* p_no = gogo->lookup(p->name(), NULL);\n+\t  go_assert(p_no != NULL\n+\t\t    && p_no->is_variable()\n+\t\t    && p_no->var_value()->is_parameter());\n+\t  args->push_back(Expression::make_var_reference(p_no, loc));\n+\t}\n+    }\n+\n+  Call_expression* call = Expression::make_call(bme, args,\n+\t\t\t\t\t\torig_fntype->is_varargs(),\n+\t\t\t\t\t\tloc);\n+  call->set_varargs_are_lowered();\n+\n+  Statement* s = Statement::make_return_from_call(call, loc);\n+  gogo->add_statement(s);\n+  Block* b = gogo->finish_block(loc);\n+  gogo->add_block(b, loc);\n+  gogo->lower_block(new_no, b);\n+  gogo->finish_function(loc);\n+\n+  ins.first->second = new_no;\n+  return new_no;\n+}\n+\n+// Return an expression to check *REF for nil while dereferencing\n+// according to FIELD_INDEXES.  Update *REF to build up the field\n+// reference.  This is a static function so that we don't have to\n+// worry about declaring Field_indexes in expressions.h.\n+\n+static Expression*\n+bme_check_nil(const Method::Field_indexes* field_indexes, Location loc,\n+\t      Expression** ref)\n+{\n+  if (field_indexes == NULL)\n+    return Expression::make_boolean(false, loc);\n+  Expression* cond = bme_check_nil(field_indexes->next, loc, ref);\n+  Struct_type* stype = (*ref)->type()->deref()->struct_type();\n+  go_assert(stype != NULL\n+\t    && field_indexes->field_index < stype->field_count());\n+  if ((*ref)->type()->struct_type() == NULL)\n+    {\n+      go_assert((*ref)->type()->points_to() != NULL);\n+      Expression* n = Expression::make_binary(OPERATOR_EQEQ, *ref,\n+\t\t\t\t\t      Expression::make_nil(loc),\n+\t\t\t\t\t      loc);\n+      cond = Expression::make_binary(OPERATOR_OROR, cond, n, loc);\n+      *ref = Expression::make_unary(OPERATOR_MULT, *ref, loc);\n+      go_assert((*ref)->type()->struct_type() == stype);\n     }\n+  *ref = Expression::make_field_reference(*ref, field_indexes->field_index,\n+\t\t\t\t\t  loc);\n+  return cond;\n }\n \n-// Get the tree for a method expression.  There is no standard tree\n-// representation for this.  The only places it may currently be used\n-// are in a Call_expression or a Go_statement, which will take it\n-// apart directly.  So this has nothing to do at present.\n+// Get the tree for a method value.\n \n tree\n-Bound_method_expression::do_get_tree(Translate_context*)\n+Bound_method_expression::do_get_tree(Translate_context* context)\n {\n-  error_at(this->location(), \"reference to method other than calling it\");\n-  return error_mark_node;\n+  Named_object* thunk = Bound_method_expression::create_thunk(context->gogo(),\n+\t\t\t\t\t\t\t      this->method_,\n+\t\t\t\t\t\t\t      this->function_);\n+  if (thunk->is_erroneous())\n+    {\n+      go_assert(saw_errors());\n+      return error_mark_node;\n+    }\n+\n+  // FIXME: We should lower this earlier, but we can't lower it in the\n+  // lowering pass because at that point we don't know whether we need\n+  // to create the thunk or not.  If the expression is called, we\n+  // don't need the thunk.\n+\n+  Location loc = this->location();\n+\n+  // If the method expects a value, and we have a pointer, we need to\n+  // dereference the pointer.\n+\n+  Named_object* fn = this->method_->named_object();\n+  Function_type* fntype;\n+  if (fn->is_function())\n+    fntype = fn->func_value()->type();\n+  else if (fn->is_function_declaration())\n+    fntype = fn->func_declaration_value()->type();\n+  else\n+    go_unreachable();\n+\n+  Expression* val = this->expr_;\n+  if (fntype->receiver()->type()->points_to() == NULL\n+      && val->type()->points_to() != NULL)\n+    val = Expression::make_unary(OPERATOR_MULT, val, loc);\n+\n+  // Note that we are ignoring this->expr_type_ here.  The thunk will\n+  // expect a closure whose second field has type this->expr_type_ (if\n+  // that is not NULL).  We are going to pass it a closure whose\n+  // second field has type this->expr_->type().  Since\n+  // this->expr_type_ is only not-NULL for pointer types, we can get\n+  // away with this.\n+\n+  Struct_field_list* fields = new Struct_field_list();\n+  fields->push_back(Struct_field(Typed_identifier(\"fn.0\",\n+\t\t\t\t\t\t  thunk->func_value()->type(),\n+\t\t\t\t\t\t  loc)));\n+  fields->push_back(Struct_field(Typed_identifier(\"val.1\", val->type(), loc)));\n+  Struct_type* st = Type::make_struct_type(fields, loc);\n+\n+  Expression_list* vals = new Expression_list();\n+  vals->push_back(Expression::make_func_code_reference(thunk, loc));\n+  vals->push_back(val);\n+\n+  Expression* ret = Expression::make_struct_composite_literal(st, vals, loc);\n+  ret = Expression::make_heap_composite(ret, loc);\n+\n+  tree ret_tree = ret->get_tree(context);\n+\n+  Expression* nil_check = NULL;\n+\n+  // See whether the expression or any embedded pointers are nil.\n+\n+  Expression* expr = this->expr_;\n+  if (this->method_->field_indexes() != NULL)\n+    {\n+      // Note that we are evaluating this->expr_ twice, but that is OK\n+      // because in the lowering pass we forced it into a temporary\n+      // variable.\n+      Expression* ref = expr;\n+      nil_check = bme_check_nil(this->method_->field_indexes(), loc, &ref);\n+      expr = ref;\n+    }\n+\n+  if (this->method_->is_value_method() && expr->type()->points_to() != NULL)\n+    {\n+      Expression* n = Expression::make_binary(OPERATOR_EQEQ, expr,\n+\t\t\t\t\t      Expression::make_nil(loc),\n+\t\t\t\t\t      loc);\n+      if (nil_check == NULL)\n+\tnil_check = n;\n+      else\n+\tnil_check = Expression::make_binary(OPERATOR_OROR, nil_check, n, loc);\n+    }\n+\n+  if (nil_check != NULL)\n+    {\n+      tree nil_check_tree = nil_check->get_tree(context);\n+      tree crash =\n+\tcontext->gogo()->runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE, loc);\n+      if (ret_tree == error_mark_node\n+\t  || nil_check_tree == error_mark_node\n+\t  || crash == error_mark_node)\n+\treturn error_mark_node;\n+\n+      ret_tree = fold_build2_loc(loc.gcc_location(), COMPOUND_EXPR,\n+\t\t\t\t TREE_TYPE(ret_tree),\n+\t\t\t\t build3_loc(loc.gcc_location(), COND_EXPR,\n+\t\t\t\t\t    void_type_node, nil_check_tree,\n+\t\t\t\t\t    crash, NULL_TREE),\n+\t\t\t\t ret_tree);\n+    }\n+\n+  return ret_tree;\n }\n \n // Dump ast representation of a bound method expression.\n@@ -6705,16 +6997,16 @@ Bound_method_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n       ast_dump_context->ostream() << \")\";\n     }\n     \n-  ast_dump_context->ostream() << \".\" << this->method_->name();\n+  ast_dump_context->ostream() << \".\" << this->function_->name();\n }\n \n // Make a method expression.\n \n Bound_method_expression*\n-Expression::make_bound_method(Expression* expr, Named_object* method,\n-\t\t\t      Location location)\n+Expression::make_bound_method(Expression* expr, const Method* method,\n+\t\t\t      Named_object* function, Location location)\n {\n-  return new Bound_method_expression(expr, method, location);\n+  return new Bound_method_expression(expr, method, function, location);\n }\n \n // Class Builtin_call_expression.  This is used for a call to a\n@@ -8921,7 +9213,7 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function,\n   Bound_method_expression* bme = this->fn_->bound_method_expression();\n   if (bme != NULL)\n     {\n-      Named_object* method = bme->method();\n+      Named_object* methodfn = bme->function();\n       Expression* first_arg = bme->first_argument();\n \n       // We always pass a pointer when calling a method.\n@@ -8962,7 +9254,7 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function,\n       // old arguments, because we may be traversing them up in some\n       // caller.  FIXME.\n       this->args_ = new_args;\n-      this->fn_ = Expression::make_func_reference(method, NULL,\n+      this->fn_ = Expression::make_func_reference(methodfn, NULL,\n \t\t\t\t\t\t  bme->location());\n     }\n \n@@ -11158,6 +11450,28 @@ Interface_field_reference_expression::do_traverse(Traverse* traverse)\n   return Expression::traverse(&this->expr_, traverse);\n }\n \n+// Lower the expression.  If this expression is not called, we need to\n+// evaluate the expression twice when converting to the backend\n+// interface.  So introduce a temporary variable if necessary.\n+\n+Expression*\n+Interface_field_reference_expression::do_lower(Gogo*, Named_object*,\n+\t\t\t\t\t       Statement_inserter* inserter,\n+\t\t\t\t\t       int)\n+{\n+  if (this->expr_->var_expression() == NULL\n+      && this->expr_->temporary_reference_expression() == NULL\n+      && this->expr_->set_and_use_temporary_expression() == NULL)\n+    {\n+      Temporary_statement* temp =\n+\tStatement::make_temporary(this->expr_->type(), NULL, this->location());\n+      inserter->insert(temp);\n+      this->expr_ = Expression::make_set_and_use_temporary(temp, this->expr_,\n+\t\t\t\t\t\t\t   this->location());\n+    }\n+  return this;\n+}\n+\n // Return the type of an interface field reference.\n \n Type*\n@@ -11218,18 +11532,188 @@ Interface_field_reference_expression::do_check_types(Gogo*)\n     }\n }\n \n-// Get a tree for a reference to a field in an interface.  There is no\n-// standard tree type representation for this: it's a function\n-// attached to its first argument, like a Bound_method_expression.\n-// The only places it may currently be used are in a Call_expression\n-// or a Go_statement, which will take it apart directly.  So this has\n-// nothing to do at present.\n+// If an interface field reference is not simply called, then it is\n+// represented as a closure.  The closure will hold a single variable,\n+// the value of the interface on which the method should be called.\n+// The function will be a simple thunk that pulls the value from the\n+// closure and calls the method with the remaining arguments.\n+\n+// Because method values are not common, we don't build all thunks for\n+// all possible interface methods, but instead only build them as we\n+// need them.  In particular, we even build them on demand for\n+// interface methods defined in other packages.\n+\n+Interface_field_reference_expression::Interface_method_thunks\n+  Interface_field_reference_expression::interface_method_thunks;\n+\n+// Find or create the thunk to call method NAME on TYPE.\n+\n+Named_object*\n+Interface_field_reference_expression::create_thunk(Gogo* gogo,\n+\t\t\t\t\t\t   Interface_type* type,\n+\t\t\t\t\t\t   const std::string& name)\n+{\n+  std::pair<Interface_type*, Method_thunks*> val(type, NULL);\n+  std::pair<Interface_method_thunks::iterator, bool> ins =\n+    Interface_field_reference_expression::interface_method_thunks.insert(val);\n+  if (ins.second)\n+    {\n+      // This is the first time we have seen this interface.\n+      ins.first->second = new Method_thunks();\n+    }\n+\n+  for (Method_thunks::const_iterator p = ins.first->second->begin();\n+       p != ins.first->second->end();\n+       p++)\n+    if (p->first == name)\n+      return p->second;\n+\n+  Location loc = type->location();\n+\n+  const Typed_identifier* method_id = type->find_method(name);\n+  if (method_id == NULL)\n+    return Named_object::make_erroneous_name(Gogo::thunk_name());\n+\n+  Function_type* orig_fntype = method_id->type()->function_type();\n+  if (orig_fntype == NULL)\n+    return Named_object::make_erroneous_name(Gogo::thunk_name());\n+\n+  Struct_field_list* sfl = new Struct_field_list();\n+  // The type here is wrong--it should be new_fntype.  But we don't\n+  // have new_fntype yet, and it doesn't really matter.\n+  Type* vt = Type::make_pointer_type(Type::make_void_type());\n+  sfl->push_back(Struct_field(Typed_identifier(\"fn.0\", vt, loc)));\n+  sfl->push_back(Struct_field(Typed_identifier(\"val.1\", type, loc)));\n+  Type* closure_type = Type::make_struct_type(sfl, loc);\n+  closure_type = Type::make_pointer_type(closure_type);\n+\n+  Function_type* new_fntype = orig_fntype->copy_with_closure(closure_type);\n+\n+  Named_object* new_no = gogo->start_function(Gogo::thunk_name(), new_fntype,\n+\t\t\t\t\t      false, loc);\n+\n+  gogo->start_block(loc);\n+\n+  Named_object* cp = gogo->lookup(\"closure.0\", NULL);\n+  go_assert(cp != NULL\n+\t    && cp->is_variable()\n+\t    && cp->var_value()->is_parameter());\n+\n+  // Field 0 of the closure is the function code pointer, field 1 is\n+  // the value on which to invoke the method.\n+  Expression* arg = Expression::make_var_reference(cp, loc);\n+  arg = Expression::make_unary(OPERATOR_MULT, arg, loc);\n+  arg = Expression::make_field_reference(arg, 1, loc);\n+\n+  Expression *ifre = Expression::make_interface_field_reference(arg, name,\n+\t\t\t\t\t\t\t\tloc);\n+\n+  const Typed_identifier_list* orig_params = orig_fntype->parameters();\n+  Expression_list* args;\n+  if (orig_params == NULL || orig_params->empty())\n+    args = NULL;\n+  else\n+    {\n+      const Typed_identifier_list* new_params = new_fntype->parameters();\n+      args = new Expression_list();\n+      for (Typed_identifier_list::const_iterator p = new_params->begin();\n+\t   p + 1 != new_params->end();\n+\t   ++p)\n+\t{\n+\t  Named_object* p_no = gogo->lookup(p->name(), NULL);\n+\t  go_assert(p_no != NULL\n+\t\t    && p_no->is_variable()\n+\t\t    && p_no->var_value()->is_parameter());\n+\t  args->push_back(Expression::make_var_reference(p_no, loc));\n+\t}\n+    }\n+\n+  Call_expression* call = Expression::make_call(ifre, args,\n+\t\t\t\t\t\torig_fntype->is_varargs(),\n+\t\t\t\t\t\tloc);\n+  call->set_varargs_are_lowered();\n+\n+  Statement* s = Statement::make_return_from_call(call, loc);\n+  gogo->add_statement(s);\n+  Block* b = gogo->finish_block(loc);\n+  gogo->add_block(b, loc);\n+  gogo->lower_block(new_no, b);\n+  gogo->finish_function(loc);\n+\n+  ins.first->second->push_back(std::make_pair(name, new_no));\n+  return new_no;\n+}\n+\n+// Get a tree for a method value.\n \n tree\n-Interface_field_reference_expression::do_get_tree(Translate_context*)\n+Interface_field_reference_expression::do_get_tree(Translate_context* context)\n {\n-  error_at(this->location(), \"reference to method other than calling it\");\n-  return error_mark_node;\n+  Interface_type* type = this->expr_->type()->interface_type();\n+  if (type == NULL)\n+    {\n+      go_assert(saw_errors());\n+      return error_mark_node;\n+    }\n+\n+  Named_object* thunk =\n+    Interface_field_reference_expression::create_thunk(context->gogo(),\n+\t\t\t\t\t\t       type, this->name_);\n+  if (thunk->is_erroneous())\n+    {\n+      go_assert(saw_errors());\n+      return error_mark_node;\n+    }\n+\n+  // FIXME: We should lower this earlier, but we can't it lower it in\n+  // the lowering pass because at that point we don't know whether we\n+  // need to create the thunk or not.  If the expression is called, we\n+  // don't need the thunk.\n+\n+  Location loc = this->location();\n+\n+  Struct_field_list* fields = new Struct_field_list();\n+  fields->push_back(Struct_field(Typed_identifier(\"fn.0\",\n+\t\t\t\t\t\t  thunk->func_value()->type(),\n+\t\t\t\t\t\t  loc)));\n+  fields->push_back(Struct_field(Typed_identifier(\"val.1\",\n+\t\t\t\t\t\t  this->expr_->type(),\n+\t\t\t\t\t\t  loc)));\n+  Struct_type* st = Type::make_struct_type(fields, loc);\n+\n+  Expression_list* vals = new Expression_list();\n+  vals->push_back(Expression::make_func_code_reference(thunk, loc));\n+  vals->push_back(this->expr_);\n+\n+  Expression* expr = Expression::make_struct_composite_literal(st, vals, loc);\n+  expr = Expression::make_heap_composite(expr, loc);\n+\n+  tree closure_tree = expr->get_tree(context);\n+\n+  // Note that we are evaluating this->expr_ twice, but that is OK\n+  // because in the lowering pass we forced it into a temporary\n+  // variable.\n+  tree expr_tree = this->expr_->get_tree(context);\n+  tree nil_check_tree = Expression::comparison_tree(context,\n+\t\t\t\t\t\t    Type::lookup_bool_type(),\n+\t\t\t\t\t\t    OPERATOR_EQEQ,\n+\t\t\t\t\t\t    this->expr_->type(),\n+\t\t\t\t\t\t    expr_tree,\n+\t\t\t\t\t\t    Type::make_nil_type(),\n+\t\t\t\t\t\t    null_pointer_node,\n+\t\t\t\t\t\t    loc);\n+  tree crash = context->gogo()->runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE,\n+\t\t\t\t\t      loc);\n+  if (closure_tree == error_mark_node\n+      || nil_check_tree == error_mark_node\n+      || crash == error_mark_node)\n+    return error_mark_node;\n+  return fold_build2_loc(loc.gcc_location(), COMPOUND_EXPR,\n+\t\t\t TREE_TYPE(closure_tree),\n+\t\t\t build3_loc(loc.gcc_location(), COND_EXPR,\n+\t\t\t\t    void_type_node, nil_check_tree, crash,\n+\t\t\t\t    NULL_TREE),\n+\t\t\t closure_tree);\n }\n \n // Dump ast representation for an interface field reference.\n@@ -11485,22 +11969,7 @@ Selector_expression::lower_method_expression(Gogo* gogo)\n \t\t\t\t\t\tmethod_type->is_varargs(),\n \t\t\t\t\t\tlocation);\n \n-  size_t count = call->result_count();\n-  Statement* s;\n-  if (count == 0)\n-    s = Statement::make_statement(call, true);\n-  else\n-    {\n-      Expression_list* retvals = new Expression_list();\n-      if (count <= 1)\n-\tretvals->push_back(call);\n-      else\n-\t{\n-\t  for (size_t i = 0; i < count; ++i)\n-\t    retvals->push_back(Expression::make_call_result(call, i));\n-\t}\n-      s = Statement::make_return_statement(retvals, location);\n-    }\n+  Statement* s = Statement::make_return_from_call(call, location);\n   gogo->add_statement(s);\n \n   Block* b = gogo->finish_block(location);"}, {"sha": "67a4bb985e66f52efd7646c10c4ffe6e762f5fff", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 52, "deletions": 13, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d3f918f9da22ffddd61fc242ea82137e3a83b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d3f918f9da22ffddd61fc242ea82137e3a83b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=571d3f918f9da22ffddd61fc242ea82137e3a83b", "patch": "@@ -16,6 +16,7 @@ class Translate_context;\n class Traverse;\n class Statement_inserter;\n class Type;\n+class Method;\n struct Type_context;\n class Integer_type;\n class Float_type;\n@@ -224,9 +225,11 @@ class Expression\n   make_call_result(Call_expression*, unsigned int index);\n \n   // Make an expression which is a method bound to its first\n-  // parameter.\n+  // parameter.  METHOD is the method being called, FUNCTION is the\n+  // function to call.\n   static Bound_method_expression*\n-  make_bound_method(Expression* object, Named_object* method, Location);\n+  make_bound_method(Expression* object, const Method* method,\n+\t\t    Named_object* function, Location);\n \n   // Make an index or slice expression.  This is a parser expression\n   // which represents LEFT[START:END].  END may be NULL, meaning an\n@@ -1079,8 +1082,7 @@ class Set_and_use_temporary_expression : public Expression\n   do_type();\n \n   void\n-  do_determine_type(const Type_context*)\n-  { }\n+  do_determine_type(const Type_context*);\n \n   Expression*\n   do_copy()\n@@ -1852,10 +1854,10 @@ class Map_index_expression : public Expression\n class Bound_method_expression : public Expression\n {\n  public:\n-  Bound_method_expression(Expression* expr, Named_object* method,\n-\t\t\t  Location location)\n+  Bound_method_expression(Expression* expr, const Method *method,\n+\t\t\t  Named_object* function, Location location)\n     : Expression(EXPRESSION_BOUND_METHOD, location),\n-      expr_(expr), expr_type_(NULL), method_(method)\n+      expr_(expr), expr_type_(NULL), method_(method), function_(function)\n   { }\n \n   // Return the object which is the first argument.\n@@ -1870,20 +1872,33 @@ class Bound_method_expression : public Expression\n   first_argument_type() const\n   { return this->expr_type_; }\n \n-  // Return the method function.\n-  Named_object*\n-  method()\n+  // Return the method.\n+  const Method*\n+  method() const\n   { return this->method_; }\n \n+  // Return the function to call.\n+  Named_object*\n+  function() const\n+  { return this->function_; }\n+\n   // Set the implicit type of the expression.\n   void\n   set_first_argument_type(Type* type)\n   { this->expr_type_ = type; }\n \n+  // Create a thunk to call FUNCTION, for METHOD, when it is used as\n+  // part of a method value.\n+  static Named_object*\n+  create_thunk(Gogo*, const Method* method, Named_object* function);\n+\n  protected:\n   int\n   do_traverse(Traverse*);\n \n+  Expression*\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n+\n   Type*\n   do_type();\n \n@@ -1897,7 +1912,7 @@ class Bound_method_expression : public Expression\n   do_copy()\n   {\n     return new Bound_method_expression(this->expr_->copy(), this->method_,\n-\t\t\t\t       this->location());\n+\t\t\t\t       this->function_, this->location());\n   }\n \n   tree\n@@ -1907,15 +1922,24 @@ class Bound_method_expression : public Expression\n   do_dump_expression(Ast_dump_context*) const;\n \n  private:\n+  // A mapping from method functions to the thunks we have created for\n+  // them.\n+  typedef Unordered_map(Named_object*, Named_object*) Method_value_thunks;\n+  static Method_value_thunks method_value_thunks;\n+\n   // The object used to find the method.  This is passed to the method\n   // as the first argument.\n   Expression* expr_;\n   // The implicit type of the object to pass to the method.  This is\n   // NULL in the normal case, non-NULL when using a method from an\n   // anonymous field which does not require a stub.\n   Type* expr_type_;\n-  // The method itself.\n-  Named_object* method_;\n+  // The method.\n+  const Method* method_;\n+  // The function to call.  This is not the same as\n+  // method_->named_object() when the method has a stub.  This will be\n+  // the real function rather than the stub.\n+  Named_object* function_;\n };\n \n // A reference to a field in a struct.\n@@ -2031,6 +2055,11 @@ class Interface_field_reference_expression : public Expression\n   name() const\n   { return this->name_; }\n \n+  // Create a thunk to call the method NAME in TYPE when it is used as\n+  // part of a method value.\n+  static Named_object*\n+  create_thunk(Gogo*, Interface_type* type, const std::string& name);\n+\n   // Return a tree for the pointer to the function to call, given a\n   // tree for the expression.\n   tree\n@@ -2046,6 +2075,9 @@ class Interface_field_reference_expression : public Expression\n   int\n   do_traverse(Traverse* traverse);\n \n+  Expression*\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n+\n   Type*\n   do_type();\n \n@@ -2070,6 +2102,13 @@ class Interface_field_reference_expression : public Expression\n   do_dump_expression(Ast_dump_context*) const;\n \n  private:\n+  // A mapping from interface types to a list of thunks we have\n+  // created for methods.\n+  typedef std::vector<std::pair<std::string, Named_object*> > Method_thunks;\n+  typedef Unordered_map(Interface_type*, Method_thunks*)\n+    Interface_method_thunks;\n+  static Interface_method_thunks interface_method_thunks;\n+\n   // The expression for the interface object.  This should have a type\n   // of interface or pointer to interface.\n   Expression* expr_;"}, {"sha": "24f890cdef98529c69c74d2d08d1a058fb75be04", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 34, "deletions": 71, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d3f918f9da22ffddd61fc242ea82137e3a83b/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d3f918f9da22ffddd61fc242ea82137e3a83b/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=571d3f918f9da22ffddd61fc242ea82137e3a83b", "patch": "@@ -1795,11 +1795,36 @@ Create_function_descriptors::expression(Expression** pexpr)\n       return TRAVERSE_CONTINUE;\n     }\n \n+  Bound_method_expression* bme = expr->bound_method_expression();\n+  if (bme != NULL)\n+    {\n+      // We would not get here for a call to this method, so this is a\n+      // method value.  We need to create a thunk.\n+      Bound_method_expression::create_thunk(this->gogo_, bme->method(),\n+\t\t\t\t\t    bme->function());\n+      return TRAVERSE_CONTINUE;\n+    }\n+\n+  Interface_field_reference_expression* ifre =\n+    expr->interface_field_reference_expression();\n+  if (ifre != NULL)\n+    {\n+      // We would not get here for a call to this interface method, so\n+      // this is a method value.  We need to create a thunk.\n+      Interface_type* type = ifre->expr()->type()->interface_type();\n+      if (type != NULL)\n+\tInterface_field_reference_expression::create_thunk(this->gogo_, type,\n+\t\t\t\t\t\t\t   ifre->name());\n+      return TRAVERSE_CONTINUE;\n+    }\n+\n   Call_expression* ce = expr->call_expression();\n   if (ce != NULL)\n     {\n       Expression* fn = ce->fn();\n-      if (fn->func_expression() != NULL)\n+      if (fn->func_expression() != NULL\n+\t  || fn->bound_method_expression() != NULL\n+\t  || fn->interface_field_reference_expression() != NULL)\n \t{\n \t  // Traverse the arguments but not the function.\n \t  Expression_list* args = ce->args();\n@@ -2806,22 +2831,7 @@ Build_recover_thunks::function(Named_object* orig_no)\n   // Any varargs call has already been lowered.\n   call->set_varargs_are_lowered();\n \n-  Statement* s;\n-  if (orig_fntype->results() == NULL || orig_fntype->results()->empty())\n-    s = Statement::make_statement(call, true);\n-  else\n-    {\n-      Expression_list* vals = new Expression_list();\n-      size_t rc = orig_fntype->results()->size();\n-      if (rc == 1)\n-\tvals->push_back(call);\n-      else\n-\t{\n-\t  for (size_t i = 0; i < rc; ++i)\n-\t    vals->push_back(Expression::make_call_result(call, i));\n-\t}\n-      s = Statement::make_return_statement(vals, location);\n-    }\n+  Statement* s = Statement::make_return_from_call(call, location);\n   s->determine_types();\n   gogo->add_statement(s);\n \n@@ -3557,42 +3567,8 @@ Function::make_descriptor_wrapper(Gogo* gogo, Named_object* no,\n {\n   Location loc = no->location();\n \n-  Typed_identifier_list* new_params = new Typed_identifier_list();\n-  const Typed_identifier_list* orig_params = orig_fntype->parameters();\n-  if (orig_params != NULL && !orig_params->empty())\n-    {\n-      static int count;\n-      char buf[50];\n-      for (Typed_identifier_list::const_iterator p = orig_params->begin();\n-\t   p != orig_params->end();\n-\t   ++p)\n-\t{\n-\t  snprintf(buf, sizeof buf, \"pt.%u\", count);\n-\t  ++count;\n-\t  new_params->push_back(Typed_identifier(buf, p->type(),\n-\t\t\t\t\t\t p->location()));\n-\t}\n-    }\n   Type* vt = Type::make_pointer_type(Type::make_void_type());\n-  new_params->push_back(Typed_identifier(\"closure.0\", vt, loc));\n-\n-  const Typed_identifier_list* orig_results = orig_fntype->results();\n-  Typed_identifier_list* new_results;\n-  if (orig_results == NULL || orig_results->empty())\n-    new_results = NULL;\n-  else\n-    {\n-      new_results = new Typed_identifier_list();\n-      for (Typed_identifier_list::const_iterator p = orig_results->begin();\n-\t   p != orig_results->end();\n-\t   ++p)\n-\tnew_results->push_back(Typed_identifier(\"\", p->type(),\n-\t\t\t\t\t\tp->location()));\n-    }\n-\n-  Function_type* new_fntype = Type::make_function_type(NULL, new_params,\n-\t\t\t\t\t\t       new_results,\n-\t\t\t\t\t\t       loc);\n+  Function_type* new_fntype = orig_fntype->copy_with_closure(vt);\n \n   std::string name = no->name() + \"$descriptorfn\";\n   Named_object* dno = gogo->start_function(name, new_fntype, false, loc);\n@@ -3602,13 +3578,16 @@ Function::make_descriptor_wrapper(Gogo* gogo, Named_object* no,\n \n   Expression* fn = Expression::make_func_reference(no, NULL, loc);\n \n-  // Call the wrapper function, passing all of the arguments except\n-  // for the last one (the last argument is the ignored closure).\n+  // Call the function begin wrapped, passing all of the arguments\n+  // except for the last one (the last argument is the ignored\n+  // closure).\n+  const Typed_identifier_list* orig_params = orig_fntype->parameters();\n   Expression_list* args;\n   if (orig_params == NULL || orig_params->empty())\n     args = NULL;\n   else\n     {\n+      const Typed_identifier_list* new_params = new_fntype->parameters();\n       args = new Expression_list();\n       for (Typed_identifier_list::const_iterator p = new_params->begin();\n \t   p + 1 != new_params->end();\n@@ -3627,23 +3606,7 @@ Function::make_descriptor_wrapper(Gogo* gogo, Named_object* no,\n \t\t\t\t\t\tloc);\n   call->set_varargs_are_lowered();\n \n-  Statement* s;\n-  if (orig_results == NULL || orig_results->empty())\n-    s = Statement::make_statement(call, true);\n-  else\n-    {\n-      Expression_list* vals = new Expression_list();\n-      size_t rc = orig_results->size();\n-      if (rc == 1)\n-\tvals->push_back(call);\n-      else\n-\t{\n-\t  for (size_t i = 0; i < rc; ++i)\n-\t    vals->push_back(Expression::make_call_result(call, i));\n-\t}\n-      s = Statement::make_return_statement(vals, loc);\n-    }\n-\n+  Statement* s = Statement::make_return_from_call(call, loc);\n   gogo->add_statement(s);\n   Block* b = gogo->finish_block(loc);\n   gogo->add_block(b, loc);"}, {"sha": "880d5c8b6d54fa222b91f5dbc7e08c1b912e8644", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d3f918f9da22ffddd61fc242ea82137e3a83b/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d3f918f9da22ffddd61fc242ea82137e3a83b/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=571d3f918f9da22ffddd61fc242ea82137e3a83b", "patch": "@@ -2815,6 +2815,28 @@ Statement::make_return_statement(Expression_list* vals,\n   return new Return_statement(vals, location);\n }\n \n+// Make a statement that returns the result of a call expression.\n+\n+Statement*\n+Statement::make_return_from_call(Call_expression* call, Location location)\n+{\n+  size_t rc = call->result_count();\n+  if (rc == 0)\n+    return Statement::make_statement(call, true);\n+  else\n+    {\n+      Expression_list* vals = new Expression_list();\n+      if (rc == 1)\n+\tvals->push_back(call);\n+      else\n+\t{\n+\t  for (size_t i = 0; i < rc; ++i)\n+\t    vals->push_back(Expression::make_call_result(call, i));\n+\t}\n+      return Statement::make_return_statement(vals, location);\n+    }\n+}\n+\n // A break or continue statement.\n \n class Bc_statement : public Statement"}, {"sha": "fb2ae334293c8753706ea9f97fe66a7cdd039871", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d3f918f9da22ffddd61fc242ea82137e3a83b/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d3f918f9da22ffddd61fc242ea82137e3a83b/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=571d3f918f9da22ffddd61fc242ea82137e3a83b", "patch": "@@ -207,6 +207,13 @@ class Statement\n   static Return_statement*\n   make_return_statement(Expression_list*, Location);\n \n+  // Make a statement that returns the result of a call expression.\n+  // If the call does not return any results, this just returns the\n+  // call expression as a statement, assuming that the function will\n+  // end immediately afterward.\n+  static Statement*\n+  make_return_from_call(Call_expression*, Location);\n+\n   // Make a break statement.\n   static Statement*\n   make_break_statement(Unnamed_label* label, Location);"}, {"sha": "3fe20904493b6e152660224b6beac415960fb76d", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 53, "deletions": 21, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d3f918f9da22ffddd61fc242ea82137e3a83b/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d3f918f9da22ffddd61fc242ea82137e3a83b/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=571d3f918f9da22ffddd61fc242ea82137e3a83b", "patch": "@@ -3396,7 +3396,8 @@ Function_type::do_get_backend(Gogo* gogo)\n   // passed when invoking the function indirectly, via the struct.\n \n   Location loc = this->location();\n-  Btype* struct_type = gogo->backend()->placeholder_struct_type(\"\", loc);\n+  Btype* struct_type =\n+    gogo->backend()->placeholder_struct_type(\"__go_descriptor\", loc);\n   Btype* ptr_struct_type = gogo->backend()->pointer_type(struct_type);\n \n   Backend::Btyped_identifier breceiver;\n@@ -3835,6 +3836,49 @@ Function_type::copy_with_receiver(Type* receiver_type) const\n   return ret;\n }\n \n+// Make a copy of a function type ignoring any receiver and adding a\n+// closure parameter.\n+\n+Function_type*\n+Function_type::copy_with_closure(Type* closure_type) const\n+{\n+  Typed_identifier_list* new_params = new Typed_identifier_list();\n+  const Typed_identifier_list* orig_params = this->parameters_;\n+  if (orig_params != NULL && !orig_params->empty())\n+    {\n+      static int count;\n+      char buf[50];\n+      for (Typed_identifier_list::const_iterator p = orig_params->begin();\n+\t   p != orig_params->end();\n+\t   ++p)\n+\t{\n+\t  snprintf(buf, sizeof buf, \"pt.%u\", count);\n+\t  ++count;\n+\t  new_params->push_back(Typed_identifier(buf, p->type(),\n+\t\t\t\t\t\t p->location()));\n+\t}\n+    }\n+  new_params->push_back(Typed_identifier(\"closure.0\", closure_type,\n+\t\t\t\t\t this->location_));\n+\n+  const Typed_identifier_list* orig_results = this->results_;\n+  Typed_identifier_list* new_results;\n+  if (orig_results == NULL || orig_results->empty())\n+    new_results = NULL;\n+  else\n+    {\n+      new_results = new Typed_identifier_list();\n+      for (Typed_identifier_list::const_iterator p = orig_results->begin();\n+\t   p != orig_results->end();\n+\t   ++p)\n+\tnew_results->push_back(Typed_identifier(\"\", p->type(),\n+\t\t\t\t\t\tp->location()));\n+    }\n+\n+  return Type::make_function_type(NULL, new_params, new_results,\n+\t\t\t\t  this->location());\n+}\n+\n // Make a function type.\n \n Function_type*\n@@ -7580,7 +7624,7 @@ Method::bind_method(Expression* expr, Location location) const\n       // the child class.\n       return this->do_bind_method(expr, location);\n     }\n-  return Expression::make_bound_method(expr, this->stub_, location);\n+  return Expression::make_bound_method(expr, this, this->stub_, location);\n }\n \n // Return the named object associated with a method.  This may only be\n@@ -7623,8 +7667,8 @@ Expression*\n Named_method::do_bind_method(Expression* expr, Location location) const\n {\n   Named_object* no = this->named_object_;\n-  Bound_method_expression* bme = Expression::make_bound_method(expr, no,\n-\t\t\t\t\t\t\t       location);\n+  Bound_method_expression* bme = Expression::make_bound_method(expr, this,\n+\t\t\t\t\t\t\t       no, location);\n   // If this is not a local method, and it does not use a stub, then\n   // the real method expects a different type.  We need to cast the\n   // first argument.\n@@ -9002,28 +9046,16 @@ Type::build_one_stub_method(Gogo* gogo, Method* method,\n   Call_expression* call = Expression::make_call(func, arguments, is_varargs,\n \t\t\t\t\t\tlocation);\n   call->set_hidden_fields_are_ok();\n-  size_t count = call->result_count();\n-  if (count == 0)\n-    gogo->add_statement(Statement::make_statement(call, true));\n-  else\n-    {\n-      Expression_list* retvals = new Expression_list();\n-      if (count <= 1)\n-\tretvals->push_back(call);\n-      else\n-\t{\n-\t  for (size_t i = 0; i < count; ++i)\n-\t    retvals->push_back(Expression::make_call_result(call, i));\n-\t}\n-      Return_statement* retstat = Statement::make_return_statement(retvals,\n-\t\t\t\t\t\t\t\t   location);\n \n+  Statement* s = Statement::make_return_from_call(call, location);\n+  Return_statement* retstat = s->return_statement();\n+  if (retstat != NULL)\n+    {\n       // We can return values with hidden fields from a stub.  This is\n       // necessary if the method is itself hidden.\n       retstat->set_hidden_fields_are_ok();\n-\n-      gogo->add_statement(retstat);\n     }\n+  gogo->add_statement(s);\n }\n \n // Apply FIELD_INDEXES to EXPR.  The field indexes have to be applied"}, {"sha": "56626f1960e2a84e38ef85a292c00b7b5a6f636c", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d3f918f9da22ffddd61fc242ea82137e3a83b/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d3f918f9da22ffddd61fc242ea82137e3a83b/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=571d3f918f9da22ffddd61fc242ea82137e3a83b", "patch": "@@ -1789,6 +1789,12 @@ class Function_type : public Type\n   Function_type*\n   copy_with_receiver(Type*) const;\n \n+  // Return a copy of this type ignoring any receiver and adding a\n+  // final closure parameter of type CLOSURE_TYPE.  This is used when\n+  // creating descriptors.\n+  Function_type*\n+  copy_with_closure(Type* closure_type) const;\n+\n   static Type*\n   make_function_type_descriptor_type();\n "}]}