{"sha": "d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJhZjhjYzZmMTQ2M2VhMDk4YjJkOWZiYWM4MmYwZjNjODViOGU3Yg==", "commit": {"author": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2014-10-11T16:57:32Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2014-10-11T16:57:32Z"}, "message": "re PR fortran/48979 (FRACTION und EXPONENT return invalid results for infinity/NaN)\n\n\tPR fortran/48979\n\n\t* simplify.c (gfc_simplify_atan): Use mpfr_zero_p to check for zeros.\n\t(gfc_simplify_log): Likewise.\n\t(gfc_simplify_scale): Likewise.\n\t(gfc_simplify_exponent): Handle infinities and NaNs.\n\t(gfc_simplify_fraction): Handle infinities.\n\t(gfc_simplify_rrspacing): Handle signed zeros and NaNs.\n\t(gfc_simplify_set_exponent): Handle infinities and NaNs.\n\t(gfc_simplify_spacing): Handle zeros, infinities and NaNs.\n\n\t* gfortran.dg/ieee/intrinsics_1.f90: New test.\n\nFrom-SVN: r216120", "tree": {"sha": "2b3f28f90b67f144acb6a1a5932060e2f869c5be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b3f28f90b67f144acb6a1a5932060e2f869c5be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3ca7111fb5fd4810c784f9887c50e45849fc7ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3ca7111fb5fd4810c784f9887c50e45849fc7ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3ca7111fb5fd4810c784f9887c50e45849fc7ec"}], "stats": {"total": 167, "additions": 148, "deletions": 19}, "files": [{"sha": "e6ffc27bb9b327421c4dac45c76709b1cf694d5e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b", "patch": "@@ -1,3 +1,15 @@\n+2014-10-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/48979\n+\t* simplify.c (gfc_simplify_atan): Use mpfr_zero_p to check for zeros.\n+\t(gfc_simplify_log): Likewise.\n+\t(gfc_simplify_scale): Likewise.\n+\t(gfc_simplify_exponent): Handle infinities and NaNs.\n+\t(gfc_simplify_fraction): Handle infinities.\n+\t(gfc_simplify_rrspacing): Handle signed zeros and NaNs.\n+\t(gfc_simplify_set_exponent): Handle infinities and NaNs.\n+\t(gfc_simplify_spacing): Handle zeros, infinities and NaNs.\n+\n 2014-10-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/59488"}, {"sha": "92b72ba2d8c81944f795b199a96b36c65892beb4", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 70, "deletions": 18, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b", "patch": "@@ -1169,7 +1169,7 @@ gfc_simplify_atan2 (gfc_expr *y, gfc_expr *x)\n   if (x->expr_type != EXPR_CONSTANT || y->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (mpfr_sgn (y->value.real) == 0 && mpfr_sgn (x->value.real) == 0)\n+  if (mpfr_zero_p (y->value.real) && mpfr_zero_p (x->value.real))\n     {\n       gfc_error (\"If first argument of ATAN2 %L is zero, then the \"\n \t\t \"second argument must not be zero\", &x->where);\n@@ -2191,7 +2191,7 @@ gfc_simplify_exp (gfc_expr *x)\n gfc_expr *\n gfc_simplify_exponent (gfc_expr *x)\n {\n-  int i;\n+  long int val;\n   gfc_expr *result;\n \n   if (x->expr_type != EXPR_CONSTANT)\n@@ -2200,16 +2200,25 @@ gfc_simplify_exponent (gfc_expr *x)\n   result = gfc_get_constant_expr (BT_INTEGER, gfc_default_integer_kind,\n \t\t\t\t  &x->where);\n \n-  gfc_set_model (x->value.real);\n+  /* EXPONENT(inf) = EXPONENT(nan) = HUGE(0) */\n+  if (mpfr_inf_p (x->value.real) || mpfr_nan_p (x->value.real))\n+    {\n+      int i = gfc_validate_kind (BT_INTEGER, gfc_default_integer_kind, false);\n+      mpz_set (result->value.integer, gfc_integer_kinds[i].huge);\n+      return result;\n+    }\n \n-  if (mpfr_sgn (x->value.real) == 0)\n+  /* EXPONENT(+/- 0.0) = 0  */\n+  if (mpfr_zero_p (x->value.real))\n     {\n       mpz_set_ui (result->value.integer, 0);\n       return result;\n     }\n \n-  i = (int) mpfr_get_exp (x->value.real);\n-  mpz_set_si (result->value.integer, i);\n+  gfc_set_model (x->value.real);\n+\n+  val = (long int) mpfr_get_exp (x->value.real);\n+  mpz_set_si (result->value.integer, val);\n \n   return range_check (result, \"EXPONENT\");\n }\n@@ -2373,6 +2382,13 @@ gfc_simplify_fraction (gfc_expr *x)\n \n   result = gfc_get_constant_expr (BT_REAL, x->ts.kind, &x->where);\n \n+  /* FRACTION(inf) = NaN.  */\n+  if (mpfr_inf_p (x->value.real))\n+    {\n+      mpfr_set_nan (result->value.real);\n+      return result;\n+    }\n+\n #if MPFR_VERSION < MPFR_VERSION_NUM(3,1,0)\n \n   /* MPFR versions before 3.1.0 do not include mpfr_frexp.  \n@@ -2403,6 +2419,7 @@ gfc_simplify_fraction (gfc_expr *x)\n \n #else\n \n+  /* mpfr_frexp() correctly handles zeros and NaNs.  */\n   mpfr_frexp (&e, result->value.real, x->value.real, GFC_RND_MODE);\n \n #endif\n@@ -3809,8 +3826,8 @@ gfc_simplify_log (gfc_expr *x)\n       break;\n \n     case BT_COMPLEX:\n-      if ((mpfr_sgn (mpc_realref (x->value.complex)) == 0)\n-\t  && (mpfr_sgn (mpc_imagref (x->value.complex)) == 0))\n+      if (mpfr_zero_p (mpc_realref (x->value.complex))\n+\t  && mpfr_zero_p (mpc_imagref (x->value.complex)))\n \t{\n \t  gfc_error (\"Complex argument of LOG at %L cannot be zero\",\n \t\t     &x->where);\n@@ -5191,16 +5208,30 @@ gfc_simplify_rrspacing (gfc_expr *x)\n   i = gfc_validate_kind (x->ts.type, x->ts.kind, false);\n \n   result = gfc_get_constant_expr (BT_REAL, x->ts.kind, &x->where);\n-  mpfr_abs (result->value.real, x->value.real, GFC_RND_MODE);\n \n-  /* Special case x = -0 and 0.  */\n-  if (mpfr_sgn (result->value.real) == 0)\n+  /* RRSPACING(+/- 0.0) = 0.0  */\n+  if (mpfr_zero_p (x->value.real))\n     {\n       mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n       return result;\n     }\n \n+  /* RRSPACING(inf) = NaN  */\n+  if (mpfr_inf_p (x->value.real))\n+    {\n+      mpfr_set_nan (result->value.real);\n+      return result;\n+    }\n+\n+  /* RRSPACING(NaN) = same NaN  */\n+  if (mpfr_nan_p (x->value.real))\n+    {\n+      mpfr_set (result->value.real, x->value.real, GFC_RND_MODE);\n+      return result;\n+    }\n+\n   /* | x * 2**(-e) | * 2**p.  */\n+  mpfr_abs (result->value.real, x->value.real, GFC_RND_MODE);\n   e = - (long int) mpfr_get_exp (x->value.real);\n   mpfr_mul_2si (result->value.real, result->value.real, e, GFC_RND_MODE);\n \n@@ -5223,7 +5254,7 @@ gfc_simplify_scale (gfc_expr *x, gfc_expr *i)\n \n   result = gfc_get_constant_expr (BT_REAL, x->ts.kind, &x->where);\n \n-  if (mpfr_sgn (x->value.real) == 0)\n+  if (mpfr_zero_p (x->value.real))\n     {\n       mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n       return result;\n@@ -5591,9 +5622,18 @@ gfc_simplify_set_exponent (gfc_expr *x, gfc_expr *i)\n \n   result = gfc_get_constant_expr (BT_REAL, x->ts.kind, &x->where);\n \n-  if (mpfr_sgn (x->value.real) == 0)\n+  /* SET_EXPONENT (+/-0.0, I) = +/- 0.0\n+     SET_EXPONENT (NaN) = same NaN  */\n+  if (mpfr_zero_p (x->value.real) || mpfr_nan_p (x->value.real))\n     {\n-      mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n+      mpfr_set (result->value.real, x->value.real, GFC_RND_MODE);\n+      return result;\n+    }\n+\n+  /* SET_EXPONENT (inf) = NaN  */\n+  if (mpfr_inf_p (x->value.real))\n+    {\n+      mpfr_set_nan (result->value.real);\n       return result;\n     }\n \n@@ -5979,17 +6019,29 @@ gfc_simplify_spacing (gfc_expr *x)\n     return NULL;\n \n   i = gfc_validate_kind (x->ts.type, x->ts.kind, false);\n-\n   result = gfc_get_constant_expr (BT_REAL, x->ts.kind, &x->where);\n \n-  /* Special case x = 0 and -0.  */\n-  mpfr_abs (result->value.real, x->value.real, GFC_RND_MODE);\n-  if (mpfr_sgn (result->value.real) == 0)\n+  /* SPACING(+/- 0.0) = SPACING(TINY(0.0)) = TINY(0.0)  */\n+  if (mpfr_zero_p (x->value.real))\n     {\n       mpfr_set (result->value.real, gfc_real_kinds[i].tiny, GFC_RND_MODE);\n       return result;\n     }\n \n+  /* SPACING(inf) = NaN  */\n+  if (mpfr_inf_p (x->value.real))\n+    {\n+      mpfr_set_nan (result->value.real);\n+      return result;\n+    }\n+\n+  /* SPACING(NaN) = same NaN  */\n+  if (mpfr_nan_p (x->value.real))\n+    {\n+      mpfr_set (result->value.real, x->value.real, GFC_RND_MODE);\n+      return result;\n+    }\n+\n   /* In the Fortran 95 standard, the result is b**(e - p) where b, e, and p\n      are the radix, exponent of x, and precision.  This excludes the\n      possibility of subnormal numbers.  Fortran 2003 states the result is"}, {"sha": "6a63e33ab93f538deb1f35b08f3d4c5a58788427", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b", "patch": "@@ -1,8 +1,13 @@\n+2014-10-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/48979\n+\t* gfortran.dg/ieee/intrinsics_1.f90: New test.\n+\n 2014-10-11  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* lib/target-supports.exp (check_effective_target_shared): New\n \tfunction.\n-        * g++.dg/ipa/devirt-28a.C: Check if -shared is supported.\n+\t* g++.dg/ipa/devirt-28a.C: Check if -shared is supported.\n \n 2014-10-10  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "6a9abdd670b94b3ccc5e6194f6bd56e1a7ef758b", "filename": "gcc/testsuite/gfortran.dg/ieee/intrinsics_1.f90", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fintrinsics_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fintrinsics_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fintrinsics_1.f90?ref=d2af8cc6f1463ea098b2d9fbac82f0f3c85b8e7b", "patch": "@@ -0,0 +1,60 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fno-range-check\" }\n+!\n+! Check compile-time simplification of functions FRACTION, EXPONENT,\n+! SPACING, RRSPACING and SET_EXPONENT for special values.\n+\n+program test\n+  implicit none\n+  real, parameter :: inf = 2 * huge(0.)\n+  real, parameter :: nan = 0. / 0.\n+\n+  call check_positive_zero(fraction(0.))\n+  call check_negative_zero(fraction(-0.))\n+  if (.not. isnan(fraction(inf))) call abort\n+  if (.not. isnan(fraction(-inf))) call abort\n+  if (.not. isnan(fraction(nan))) call abort\n+\n+  if (exponent(0.) /= 0) call abort\n+  if (exponent(-0.) /= 0) call abort\n+  if (exponent(inf) /= huge(0)) call abort\n+  if (exponent(-inf) /= huge(0)) call abort\n+  if (exponent(nan) /= huge(0)) call abort\n+\n+  if (spacing(0.) /= spacing(tiny(0.))) call abort\n+  if (spacing(-0.) /= spacing(tiny(0.))) call abort\n+  if (.not. isnan(spacing(inf))) call abort\n+  if (.not. isnan(spacing(-inf))) call abort\n+  if (.not. isnan(spacing(nan))) call abort\n+\n+  call check_positive_zero(rrspacing(0.))\n+  call check_positive_zero(rrspacing(-0.))\n+  if (.not. isnan(rrspacing(inf))) call abort\n+  if (.not. isnan(rrspacing(-inf))) call abort\n+  if (.not. isnan(rrspacing(nan))) call abort\n+\n+  call check_positive_zero(set_exponent(0.,42))\n+  call check_negative_zero(set_exponent(-0.,42))\n+  if (.not. isnan(set_exponent(inf, 42))) call abort\n+  if (.not. isnan(set_exponent(-inf, 42))) call abort\n+  if (.not. isnan(set_exponent(nan, 42))) call abort\n+\n+contains\n+\n+  subroutine check_positive_zero(x)\n+    use ieee_arithmetic\n+    implicit none\n+    real, value :: x\n+\n+    if (ieee_class (x) /= ieee_positive_zero) call abort\n+  end\n+\n+  subroutine check_negative_zero(x)\n+    use ieee_arithmetic\n+    implicit none\n+    real, value :: x\n+\n+    if (ieee_class (x) /= ieee_negative_zero) call abort\n+  end\n+\n+end"}]}