{"sha": "0de4184baca19cdd4ebc2d8aa2d538330cae51ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRlNDE4NGJhY2ExOWNkZDRlYmMyZDhhYTJkNTM4MzMwY2FlNTFlZQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-09-20T10:13:31Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-09-20T10:13:31Z"}, "message": "Fortran/OpenMP: unconstrained/reproducible ordered modifier\n\ngcc/fortran/ChangeLog:\n\n\t* gfortran.h (gfc_omp_clauses): Add order_unconstrained.\n\t* dump-parse-tree.c (show_omp_clauses): Dump it.\n\t* openmp.c (gfc_match_omp_clauses): Match unconstrained/reproducible\n\tmodifiers to ordered(concurrent).\n\t(OMP_DISTRIBUTE_CLAUSES): Accept ordered clause.\n\t(resolve_omp_clauses): Reject ordered + order on same directive.\n\t* trans-openmp.c (gfc_trans_omp_clauses, gfc_split_omp_clauses): Pass\n\ton unconstrained modifier of ordered(concurrent).\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/gomp/order-5.f90: New test.\n\t* gfortran.dg/gomp/order-6.f90: New test.\n\t* gfortran.dg/gomp/order-7.f90: New test.\n\t* gfortran.dg/gomp/order-8.f90: New test.\n\t* gfortran.dg/gomp/order-9.f90: New test.", "tree": {"sha": "ecc54fa767818f38c668f288e38bfaf62fa1c5c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecc54fa767818f38c668f288e38bfaf62fa1c5c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0de4184baca19cdd4ebc2d8aa2d538330cae51ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0de4184baca19cdd4ebc2d8aa2d538330cae51ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0de4184baca19cdd4ebc2d8aa2d538330cae51ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24f99147b9264f8f7d9cfb2fa6bd431edfa252d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24f99147b9264f8f7d9cfb2fa6bd431edfa252d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24f99147b9264f8f7d9cfb2fa6bd431edfa252d2"}], "stats": {"total": 762, "additions": 756, "deletions": 6}, "files": [{"sha": "28eb09e261d77ba1c536296db9581743abd80554", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=0de4184baca19cdd4ebc2d8aa2d538330cae51ee", "patch": "@@ -1630,7 +1630,12 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n   if (omp_clauses->independent)\n     fputs (\" INDEPENDENT\", dumpfile);\n   if (omp_clauses->order_concurrent)\n-    fputs (\" ORDER(CONCURRENT)\", dumpfile);\n+    {\n+      fputs (\" ORDER(\", dumpfile);\n+      if (omp_clauses->order_unconstrained)\n+\tfputs (\"UNCONSTRAINED:\", dumpfile);\n+      fputs (\"CONCURRENT)\", dumpfile);\n+    }\n   if (omp_clauses->ordered)\n     {\n       if (omp_clauses->orderedc)"}, {"sha": "8b91225d6593fb18f5f642512a618b83a634447b", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=0de4184baca19cdd4ebc2d8aa2d538330cae51ee", "patch": "@@ -1491,7 +1491,8 @@ typedef struct gfc_omp_clauses\n   unsigned inbranch:1, notinbranch:1, nogroup:1;\n   unsigned sched_simd:1, sched_monotonic:1, sched_nonmonotonic:1;\n   unsigned simd:1, threads:1, depend_source:1, destroy:1, order_concurrent:1;\n-  unsigned capture:1, grainsize_strict:1, num_tasks_strict:1;\n+  unsigned order_unconstrained:1, capture:1, grainsize_strict:1;\n+  unsigned num_tasks_strict:1;\n   ENUM_BITFIELD (gfc_omp_sched_kind) sched_kind:3;\n   ENUM_BITFIELD (gfc_omp_device_type) device_type:2;\n   ENUM_BITFIELD (gfc_omp_memorder) memorder:3;"}, {"sha": "9ee52d6b0eaa0ea805bff0f38a8b291a5d2cfbde", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=0de4184baca19cdd4ebc2d8aa2d538330cae51ee", "patch": "@@ -2369,9 +2369,23 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t  break;\n \tcase 'o':\n \t  if ((mask & OMP_CLAUSE_ORDER)\n-\t      && !c->order_concurrent\n-\t      && gfc_match (\"order ( concurrent )\") == MATCH_YES)\n+\t      && (m = gfc_match_dupl_check (!c->order_concurrent, \"order (\"))\n+\t\t != MATCH_NO)\n \t    {\n+\t      if (m == MATCH_ERROR)\n+\t\tgoto error;\n+\t      if (gfc_match (\" reproducible : concurrent )\") == MATCH_YES\n+\t\t  || gfc_match (\" concurrent )\") == MATCH_YES)\n+\t\t;\n+\t      else if (gfc_match (\" unconstrained : concurrent )\") == MATCH_YES)\n+\t\tc->order_unconstrained = true;\n+\t      else\n+\t\t{\n+\t\t  gfc_error (\"Expected ORDER(CONCURRENT) at %C \"\n+\t\t\t     \"with optional %<reproducible%> or \"\n+\t\t\t     \"%<unconstrained%> modifier\");\n+\t\t  goto error;\n+\t\t}\n \t      c->order_concurrent = true;\n \t      continue;\n \t    }\n@@ -3475,7 +3489,8 @@ gfc_match_oacc_routine (void)\n    | OMP_CLAUSE_SHARED | OMP_CLAUSE_REDUCTION)\n #define OMP_DISTRIBUTE_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE\t\t\\\n-   | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_COLLAPSE | OMP_CLAUSE_DIST_SCHEDULE)\n+   | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_COLLAPSE | OMP_CLAUSE_DIST_SCHEDULE \\\n+   | OMP_CLAUSE_ORDER)\n #define OMP_SINGLE_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE)\n #define OMP_ORDERED_CLAUSES \\\n@@ -5643,7 +5658,9 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n   if (omp_clauses->orderedc && omp_clauses->orderedc < omp_clauses->collapse)\n     gfc_error (\"ORDERED clause parameter is less than COLLAPSE at %L\",\n \t       &code->loc);\n-\n+  if (omp_clauses->order_concurrent && omp_clauses->ordered)\n+    gfc_error (\"ORDER clause must not be used together ORDERED at %L\",\n+\t       &code->loc);\n   if (omp_clauses->if_expr)\n     {\n       gfc_expr *expr = omp_clauses->if_expr;"}, {"sha": "4ca2c3f9e7fcc878dc70ab7d4972c301e41d40df", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=0de4184baca19cdd4ebc2d8aa2d538330cae51ee", "patch": "@@ -3803,6 +3803,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n   if (clauses->order_concurrent)\n     {\n       c = build_omp_clause (gfc_get_location (&where), OMP_CLAUSE_ORDER);\n+      OMP_CLAUSE_ORDER_UNCONSTRAINED (c) = clauses->order_unconstrained;\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n@@ -5892,6 +5893,8 @@ gfc_split_omp_clauses (gfc_code *code,\n \t    = code->ext.omp_clauses->collapse;\n \t  clausesa[GFC_OMP_SPLIT_DISTRIBUTE].order_concurrent\n \t    = code->ext.omp_clauses->order_concurrent;\n+\t  clausesa[GFC_OMP_SPLIT_DISTRIBUTE].order_unconstrained\n+\t    = code->ext.omp_clauses->order_unconstrained;\n \t}\n       if (mask & GFC_OMP_MASK_PARALLEL)\n \t{\n@@ -5946,6 +5949,8 @@ gfc_split_omp_clauses (gfc_code *code,\n \t    = code->ext.omp_clauses->collapse;\n \t  clausesa[GFC_OMP_SPLIT_DO].order_concurrent\n \t    = code->ext.omp_clauses->order_concurrent;\n+\t  clausesa[GFC_OMP_SPLIT_DO].order_unconstrained\n+\t    = code->ext.omp_clauses->order_unconstrained;\n \t}\n       if (mask & GFC_OMP_MASK_SIMD)\n \t{\n@@ -5962,6 +5967,8 @@ gfc_split_omp_clauses (gfc_code *code,\n \t    = code->ext.omp_clauses->if_exprs[OMP_IF_SIMD];\n \t  clausesa[GFC_OMP_SPLIT_SIMD].order_concurrent\n \t    = code->ext.omp_clauses->order_concurrent;\n+\t  clausesa[GFC_OMP_SPLIT_SIMD].order_unconstrained\n+\t    = code->ext.omp_clauses->order_unconstrained;\n \t  /* And this is copied to all.  */\n \t  clausesa[GFC_OMP_SPLIT_SIMD].if_expr\n \t    = code->ext.omp_clauses->if_expr;"}, {"sha": "4d9e33642afb569be801af6f3f45fc10a5ca40b4", "filename": "gcc/testsuite/gfortran.dg/gomp/order-5.f90", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-5.f90?ref=0de4184baca19cdd4ebc2d8aa2d538330cae51ee", "patch": "@@ -0,0 +1,129 @@\n+! { dg-additional-options \"-fdump-tree-original\" }\n+\n+subroutine f1 (a)\n+  integer :: a(*), i\n+  !$omp do order(reproducible:concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp simd order ( reproducible : concurrent )\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp do simd order(reproducible :concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+end\n+\n+subroutine f2 (a)\n+  integer :: a(*), i\n+  !$omp parallel do order(reproducible: concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp parallel do simd order (reproducible:concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp teams distribute parallel do order(reproducible:concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp teams distribute parallel do simd order(reproducible:concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp teams distribute order(reproducible:concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp teams\n+    !$omp distribute parallel do order(reproducible:concurrent)\n+    do i = 1, 128\n+      a(i) = a(i) + 1\n+    end do\n+    !$omp distribute parallel do simd order(reproducible:concurrent)\n+    do i = 1, 128\n+      a(i) = a(i) + 1\n+    end do\n+    !$omp distribute order(reproducible:concurrent)\n+    do i = 1, 128\n+      a(i) = a(i) + 1\n+    end do\n+  !$omp end teams\n+  !$omp taskloop simd order (reproducible:concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+end\n+\n+subroutine f3 (a)\n+  integer :: a(*), i\n+  !$omp do order(unconstrained:concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp simd order ( unconstrained : concurrent )\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp do simd order(unconstrained :concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+end\n+\n+subroutine f4 (a)\n+  integer :: a(*), i\n+  !$omp parallel do order(unconstrained: concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp parallel do simd order (unconstrained:concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp teams distribute parallel do order(unconstrained:concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp teams distribute parallel do simd order(unconstrained:concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp teams distribute order(unconstrained:concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp teams\n+    !$omp distribute parallel do order(unconstrained:concurrent)\n+    do i = 1, 128\n+      a(i) = a(i) + 1\n+    end do\n+    !$omp distribute parallel do simd order(unconstrained:concurrent)\n+    do i = 1, 128\n+      a(i) = a(i) + 1\n+    end do\n+    !$omp distribute order(unconstrained:concurrent)\n+    do i = 1, 128\n+      a(i) = a(i) + 1\n+    end do\n+  !$omp end teams\n+  !$omp taskloop simd order (unconstrained:concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+end\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp distribute order\\\\(concurrent\\\\)\" 6 \"original\"} }\n+! { dg-final { scan-tree-dump-times \"#pragma omp distribute order\\\\(unconstrained:concurrent\\\\)\" 6 \"original\"} }\n+! { dg-final { scan-tree-dump-times \"#pragma omp for nowait order\\\\(concurrent\\\\)\" 6 \"original\"} }\n+! { dg-final { scan-tree-dump-times \"#pragma omp for nowait order\\\\(unconstrained:concurrent\\\\)\" 6 \"original\"} }\n+! { dg-final { scan-tree-dump-times \"#pragma omp for order\\\\(concurrent\\\\)\" 2 \"original\"} }\n+! { dg-final { scan-tree-dump-times \"#pragma omp for order\\\\(unconstrained:concurrent\\\\)\" 2 \"original\"} }\n+! { dg-final { scan-tree-dump-times \"#pragma omp parallel\" 12 \"original\"} }\n+! { dg-final { scan-tree-dump-times \"#pragma omp simd linear\\\\(i:1\\\\) order\\\\(concurrent\\\\)\" 6 \"original\"} }\n+! { dg-final { scan-tree-dump-times \"#pragma omp simd linear\\\\(i:1\\\\) order\\\\(unconstrained:concurrent\\\\)\" 6 \"original\"} }\n+! { dg-final { scan-tree-dump-times \"#pragma omp taskloop\" 2 \"original\"} }\n+! { dg-final { scan-tree-dump-times \"#pragma omp teams\" 8 \"original\"} }"}, {"sha": "c8aeecb6f27e91d0dfba395321239e86a94f4251", "filename": "gcc/testsuite/gfortran.dg/gomp/order-6.f90", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-6.f90?ref=0de4184baca19cdd4ebc2d8aa2d538330cae51ee", "patch": "@@ -0,0 +1,436 @@\n+module m\n+  use iso_c_binding\n+  implicit none (type, external)\n+  interface\n+    subroutine foo()\n+    end subroutine foo\n+    integer function omp_get_thread_num ()\n+    end\n+    integer function omp_get_num_threads ()\n+    end\n+    integer function omp_target_is_present (x, i)\n+      import :: c_ptr\n+      type(c_ptr) :: x\n+      integer, value :: i\n+    end\n+    integer function omp_get_cancellation ()\n+    end\n+  end interface\n+  integer :: v\n+contains\n+subroutine f1 (a)\n+  integer, target :: a(*)\n+  integer :: i\n+  !$omp simd order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp parallel\t\t! { dg-error \"OpenMP constructs other than 'ordered simd', 'simd', 'loop' or 'atomic' may not be nested inside 'simd' region\" }\n+      call foo ()\n+      !$omp end parallel\n+  end do\n+  !$omp simd order(reproducible:concurrent)\n+  do i = 1, 64\n+    block\n+      integer j\n+      !$omp simd\n+      do j = 1, 64\n+        a(64 * i + j) = i + j\n+      end do\n+    end block\n+  end do\n+  !$omp simd order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp critical\t\t! { dg-error \"OpenMP constructs other than 'ordered simd', 'simd', 'loop' or 'atomic' may not be nested inside 'simd' region\" }\n+      call foo ()\n+      !$omp end critical\n+  end do\n+  !$omp simd order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp ordered simd\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      call foo ()\n+      !$omp end ordered\n+  end do\n+  !$omp simd order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp atomic\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      v = v + 1\n+  end do\n+  !$omp simd order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp atomic read\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      a(i) = v\n+  end do\n+  !$omp simd order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp atomic write\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      v = a(i)\n+  end do\n+  !$omp simd order(reproducible:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_thread_num ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_thread_num\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp simd order(reproducible:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_num_threads ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_num_threads\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp simd order(reproducible:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_target_is_present (c_loc (a(i)), 0)  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_target_is_present\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp simd order(reproducible:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_cancellation ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_cancellation\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+end\n+\n+subroutine f2 (a)\n+  integer, target :: a(*)\n+  integer :: i\n+  !$omp do simd order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp parallel\t\t! { dg-error \"OpenMP constructs other than 'ordered simd', 'simd', 'loop' or 'atomic' may not be nested inside 'simd' region\" }\n+      call foo ()\n+      !$omp end parallel\n+  end do\n+  !$omp do simd order(reproducible:concurrent)\n+  do i = 1, 64\n+    block\n+      integer j\n+      !$omp simd\n+      do j = 1, 64\n+        a(64 * i + j) = i + j\n+      end do\n+    end block\n+  end do\n+  !$omp do simd order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp critical\t\t! { dg-error \"OpenMP constructs other than 'ordered simd', 'simd', 'loop' or 'atomic' may not be nested inside 'simd' region\" }\n+      call foo ()\n+      !$omp end critical\n+  end do\n+  !$omp do simd order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp ordered simd\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      call foo ()\n+      !$omp end ordered\n+  end do\n+  !$omp do simd order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp atomic\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      v = v + 1\n+  end do\n+  !$omp do simd order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp atomic read\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      a(i) = v\n+  end do\n+  !$omp do simd order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp atomic write\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      v = a(i)\n+  end do\n+  !$omp do simd order(reproducible:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_thread_num ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_thread_num\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp do simd order(reproducible:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_num_threads () ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_num_threads\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp do simd order(reproducible:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_target_is_present (c_loc(a(i)), 0)  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_target_is_present\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp do simd order(reproducible:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_cancellation ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_cancellation\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+end\n+\n+subroutine f3 (a)\n+  integer, target :: a(*)\n+  integer :: i\n+  !$omp do order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp parallel\n+      call foo ()\n+      !$omp end parallel\n+  end do\n+  !$omp do order(reproducible:concurrent)\n+  do i = 1, 64\n+    block\n+      integer j\n+      !$omp simd\n+      do j = 1, 64\n+        a(64 * i + j) = i + j\n+      end do\n+    end block\n+  end do\n+  !$omp do order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp critical\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      call foo ()\n+      !$omp end critical\n+  end do\n+  !$omp do order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp ordered simd\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      call foo ()\n+      !$omp end ordered\n+  end do\n+  !$omp do order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp atomic\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      v = v + 1\n+  end do\n+  !$omp do order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp atomic read\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      a(i) = v\n+  end do\n+  !$omp do order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp atomic write\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      v = a(i)\n+  end do\n+  !$omp do order(reproducible:concurrent)\n+  do i = 1, 64\n+      !$omp task\t\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      a(i) = a(i) + 1\n+      !$omp end task\n+  end do\n+  !$omp do order(reproducible:concurrent)\n+  do i = 1, 64\n+    block\n+      integer j\n+      !$omp taskloop\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      do j = 1, 64\n+        a(64 * i + j) = i + j\n+      end do\n+    end block\n+  end do\n+  !$omp do order(reproducible:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_thread_num ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_thread_num\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp do order(reproducible:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_num_threads ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_num_threads\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp do order(reproducible:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_target_is_present (c_loc (a(i)), 0)  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_target_is_present\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp do order(reproducible:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_cancellation ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_cancellation\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+end\n+\n+subroutine f4 (a)\n+  integer, target :: a(*)\n+  integer :: i\n+  !$omp simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp parallel\t\t! { dg-error \"OpenMP constructs other than 'ordered simd', 'simd', 'loop' or 'atomic' may not be nested inside 'simd' region\" }\n+      call foo ()\n+      !$omp end parallel\n+  end do\n+  !$omp simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+    block\n+      integer j\n+      !$omp simd\n+      do j = 1, 64\n+        a(64 * i + j) = i + j\n+      end do\n+    end block\n+  end do\n+  !$omp simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp critical\t\t! { dg-error \"OpenMP constructs other than 'ordered simd', 'simd', 'loop' or 'atomic' may not be nested inside 'simd' region\" }\n+      call foo ()\n+      !$omp end critical\n+  end do\n+  !$omp simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp ordered simd\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      call foo ()\n+      !$omp end ordered\n+  end do\n+  !$omp simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp atomic\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      v = v + 1\n+  end do\n+  !$omp simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp atomic read\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      a(i) = v\n+  end do\n+  !$omp simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp atomic write\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      v = a(i)\n+  end do\n+  !$omp simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_thread_num ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_thread_num\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_num_threads ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_num_threads\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_target_is_present (c_loc (a(i)), 0)  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_target_is_present\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_cancellation ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_cancellation\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+end\n+\n+subroutine f5 (a)\n+  integer, target :: a(*)\n+  integer :: i\n+  !$omp do simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp parallel\t\t! { dg-error \"OpenMP constructs other than 'ordered simd', 'simd', 'loop' or 'atomic' may not be nested inside 'simd' region\" }\n+      call foo ()\n+      !$omp end parallel\n+  end do\n+  !$omp do simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+    block\n+      integer j\n+      !$omp simd\n+      do j = 1, 64\n+        a(64 * i + j) = i + j\n+      end do\n+    end block\n+  end do\n+  !$omp do simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp critical\t\t! { dg-error \"OpenMP constructs other than 'ordered simd', 'simd', 'loop' or 'atomic' may not be nested inside 'simd' region\" }\n+      call foo ()\n+      !$omp end critical\n+  end do\n+  !$omp do simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp ordered simd\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      call foo ()\n+      !$omp end ordered\n+  end do\n+  !$omp do simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp atomic\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      v = v + 1\n+  end do\n+  !$omp do simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp atomic read\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      a(i) = v\n+  end do\n+  !$omp do simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp atomic write\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      v = a(i)\n+  end do\n+  !$omp do simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_thread_num ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_thread_num\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp do simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_num_threads ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_num_threads\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp do simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_target_is_present (c_loc (a(i)), 0)  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_target_is_present\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp do simd order(unconstrained:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_cancellation ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_cancellation\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+end\n+\n+subroutine f6 (a)\n+  integer, target :: a(*)\n+  integer :: i\n+  !$omp do order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp parallel\n+      call foo ()\n+      !$omp end parallel\n+  end do\n+  !$omp do order(unconstrained:concurrent)\n+  do i = 1, 64\n+    block\n+      integer j\n+      !$omp simd\n+      do j = 1, 64\n+        a(64 * i + j) = i + j\n+      end do\n+    end block\n+  end do\n+  !$omp do order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp critical\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      call foo ()\n+      !$omp end critical\n+  end do\n+  !$omp do order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp ordered simd\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      call foo ()\n+      !$omp end ordered\n+  end do\n+  !$omp do order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp atomic\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      v = v + 1\n+  end do\n+  !$omp do order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp atomic read\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      a(i) = v\n+  end do\n+  !$omp do order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp atomic write\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      v = a(i)\n+  end do\n+  !$omp do order(unconstrained:concurrent)\n+  do i = 1, 64\n+      !$omp task\t\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      a(i) = a(i) + 1\n+      !$omp end task\n+  end do\n+  !$omp do order(unconstrained:concurrent)\n+  do i = 1, 64\n+    block\n+      integer j\n+      !$omp taskloop\t\t! { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" }\n+      do j = 1, 64\n+        a(64 * i + j) = i + j\n+      end do\n+    end block\n+  end do\n+  !$omp do order(unconstrained:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_thread_num ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_thread_num\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp do order(unconstrained:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_num_threads ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_num_threads\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp do order(unconstrained:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_target_is_present (c_loc (a(i)), 0)  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_target_is_present\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+  !$omp do order(unconstrained:concurrent)\n+  do i = 1, 64\n+    a(i) = a(i) + omp_get_cancellation ()  ! { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_cancellation\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" }\n+  end do\n+end\n+end module m"}, {"sha": "4be8ab3723314d7c4592571e5bd680668841cfce", "filename": "gcc/testsuite/gfortran.dg/gomp/order-7.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-7.f90?ref=0de4184baca19cdd4ebc2d8aa2d538330cae51ee", "patch": "@@ -0,0 +1,59 @@\n+subroutine f1 (a)\n+  integer :: a(*)\n+  integer i\n+  !$omp do order(concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp simd order ( concurrent )\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp do simd order(concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+end\n+\n+subroutine f2 (a)\n+  integer :: a(*)\n+  integer i\n+  !$omp parallel do order(concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp parallel do simd order (concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp teams distribute parallel do order(concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp teams distribute parallel do simd order(concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp teams distribute order(concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp teams\n+    !$omp distribute parallel do order(concurrent)\n+    do i = 1, 128\n+      a(i) = a(i) + 1\n+    end do\n+    !$omp distribute parallel do simd order(concurrent)\n+    do i = 1, 128\n+      a(i) = a(i) + 1\n+    end do\n+    !$omp distribute order(concurrent)\n+    do i = 1, 128\n+      a(i) = a(i) + 1\n+    end do\n+  !$omp end teams\n+  !$omp taskloop simd order (concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+end"}, {"sha": "c753886d621e433ccc3b6344dff15fae23f312f4", "filename": "gcc/testsuite/gfortran.dg/gomp/order-8.f90", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-8.f90?ref=0de4184baca19cdd4ebc2d8aa2d538330cae51ee", "patch": "@@ -0,0 +1,61 @@\n+subroutine f1 (a)\n+  integer :: a(*)\n+  integer i\n+  !$omp do order\t\t\t\t! { dg-error \"Failed to match clause\" }\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp do simd order :\t\t\t! { dg-error \"Failed to match clause\" }\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp simd order ( foobar )\t\t! { dg-error \"Expected ORDER\\\\(CONCURRENT\\\\) at .1. with optional 'reproducible' or 'unconstrained' modifier\" }\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp do simd order( concurrent\t! { dg-error \"Expected ORDER\\\\(CONCURRENT\\\\) at .1. with optional 'reproducible' or 'unconstrained' modifier\" }\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp do simd order( concurrent : foo )! { dg-error \"Expected ORDER\\\\(CONCURRENT\\\\) at .1. with optional 'reproducible' or 'unconstrained' modifier\" }\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+end\n+\n+subroutine f2 (a)\n+  integer :: a(*)\n+  integer i\n+  !$omp teams\n+  !$omp distribute order(concurrent)\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp end teams\n+  !$omp taskloop order (concurrent)\t! { dg-error \"Failed to match clause\" }\n+  do i = 1, 128\n+    a(i) = a(i) + 1\n+  end do\n+  !$omp do order(concurrent) ordered\t! { dg-error \"ORDER clause must not be used together ORDERED\" }\n+  do i = 1, 128\n+      !$omp ordered\n+      a(i) = a(i) + 1\n+      !$omp end ordered\n+  end do\n+  !$omp do ordered order(concurrent)\t! { dg-error \"ORDER clause must not be used together ORDERED\" }\n+  do i = 1, 128\n+      !$omp ordered\n+      a(i) = a(i) + 1\n+      !$omp end ordered\n+  end do\n+  !$omp do ordered (1) order(concurrent)\t! { dg-error \"ORDER clause must not be used together ORDERED\" }\n+  do i = 1, 128\n+      !$omp ordered depend (sink: i - 1)\n+      !$omp ordered depend (source)\n+  end do\n+  !$omp do order(concurrent)ordered (1)\t! { dg-error \"ORDER clause must not be used together ORDERED\" }\n+  do i = 1, 128\n+      !$omp ordered depend (sink: i - 1)\n+      !$omp ordered depend (source)\n+  end do\n+end"}, {"sha": "c7695114cde2a7effa566aa7f2e2254b707521cd", "filename": "gcc/testsuite/gfortran.dg/gomp/order-9.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de4184baca19cdd4ebc2d8aa2d538330cae51ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-9.f90?ref=0de4184baca19cdd4ebc2d8aa2d538330cae51ee", "patch": "@@ -0,0 +1,35 @@\n+subroutine foo\n+  !$omp do schedule(static) order(concurrent) order(concurrent) ! { dg-error \"Duplicated 'order \\\\(' clause\" }\n+  do i = 1, 8\n+    call f0 ()\n+  end do\n+  !$omp do schedule(static) order(reproducible:concurrent) order(unconstrained:concurrent)      ! { dg-error \"Duplicated 'order \\\\(' clause\" }\n+  do i = 1, 8\n+    call f0 ()\n+  end do\n+\n+  !$omp loop bind(thread) order(concurrent) order(concurrent)    ! { dg-error \"Duplicated 'order \\\\(' clause\" }\n+  do i = 1, 8\n+    call f0 ()\n+  end do\n+  !$omp loop bind(thread) order(reproducible:concurrent) order(unconstrained:concurrent) ! { dg-error \"Duplicated 'order \\\\(' clause\" }\n+  do i = 1, 8\n+    call f0 ()\n+  end do\n+  !$omp simd order(concurrent) order(concurrent) ! { dg-error \"Duplicated 'order \\\\(' clause\" }\n+  do i = 1, 8\n+    call f0 ()\n+  end do\n+  !$omp simd order(reproducible:concurrent) order(unconstrained:concurrent)      ! { dg-error \"Duplicated 'order \\\\(' clause\" }\n+  do i = 1, 8\n+    call f0 ()\n+  end do\n+  !$omp distribute dist_schedule(static) order(concurrent) order(concurrent)     ! { dg-error \"Duplicated 'order \\\\(' clause\" }\n+  do i = 1, 8\n+    call f0 ()\n+  end do\n+  !$omp loop bind(thread) order(reproducible:concurrent) order(unconstrained:concurrent) ! { dg-error \"Duplicated 'order \\\\(' clause\" }\n+  do i = 1, 8\n+    call f0 ()\n+  end do\n+end"}]}