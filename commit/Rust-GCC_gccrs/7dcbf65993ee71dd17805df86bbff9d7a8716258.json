{"sha": "7dcbf65993ee71dd17805df86bbff9d7a8716258", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RjYmY2NTk5M2VlNzFkZDE3ODA1ZGY4NmJiZmY5ZDdhODcxNjI1OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-07-31T09:12:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-07-31T09:12:34Z"}, "message": "output.h (enum section_category): Export from varasm.c\n\n\n\t* output.h (enum section_category): Export from varasm.c\n\t(categorize_decl_for_section): Likewise.\n\t* varasm.c (enum section_category): Kill.\n\t(categorize_decl_for_section): Make global.\n\t* i386-protos.h (x86_output_aligned_bss, x86_elf_aligned_common):\n\tDeclare.\n\t* i386.c (ix86_section_threshold): New static variable.\n\t(ix86_in_large_data_p, ix86_encode_section_info,\n\tx86_64_elf_unique_section,\n\tx86_64_elf_select_section): New functions.\n\t(TARGET_ENCODE_SECTION_INFO): Define\n\t(override_options): Enable medium model for PIC.\n\t(ix86_expand_prologue): Expand gen_set_got_rex64.\n\t(legitimate_constant_p): Handle new UNSPECs.\n\t(legitimate_pic_address_disp_p): Likewise.\n\t(legitimize_pic_address): Lower MEDIUM model addressing.\n\t* i386.h (PIC_OFFSET_TABLE_REGNUM): Set for medium model PIC.\n\t(enum cmodel): Add MEDIUM_PIC.\n\t(SYMBOL_REF_FAR_ADDR_P): New macro.\n\t(SYMBOL_FLAG_FAR_ADDR): New flag.\n\t* i386.md (movdi): Support medium model.\n\t(set_got_rex64): New pattern.\n\t* i386.opt (mlarge-data-threshold): New flag.\n\t* predicates.md (zext_operand/sext_operand): Deal with medium model.\n\t* x86-64.h (ASM_OUTPUT_ALIGNED_BSS): Use x86_output_aligned_bss.\n\t(ASM_OUTPUT_ALIGNED_COMMON, TARGET_ASM_SELECT_SECTION,\n\tTARGET_ASM_UNIQUE_SECTION): New.\n\n\t* invoke.texi (-mlarge_data_threshold): Document\n\nFrom-SVN: r102606", "tree": {"sha": "87b4af46aac16d4fea8bf9447284ab5f9c4ceba0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87b4af46aac16d4fea8bf9447284ab5f9c4ceba0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7dcbf65993ee71dd17805df86bbff9d7a8716258", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dcbf65993ee71dd17805df86bbff9d7a8716258", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dcbf65993ee71dd17805df86bbff9d7a8716258", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dcbf65993ee71dd17805df86bbff9d7a8716258/comments", "author": null, "committer": null, "parents": [{"sha": "3601aa8ab0cb341d65b608937d781a5e3c8c5b9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3601aa8ab0cb341d65b608937d781a5e3c8c5b9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3601aa8ab0cb341d65b608937d781a5e3c8c5b9b"}], "stats": {"total": 466, "additions": 410, "deletions": 56}, "files": [{"sha": "967a610e24d65b1c77ed0923dc4d92396225963d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7dcbf65993ee71dd17805df86bbff9d7a8716258", "patch": "@@ -1,3 +1,35 @@\n+2005-07-31  Jan Hubicka  <jh@suse.cz>\n+\n+\t* output.h (enum section_category): Export from varasm.c\n+\t(categorize_decl_for_section): Likewise.\n+\t* varasm.c (enum section_category): Kill.\n+\t(categorize_decl_for_section): Make global.\n+\t* i386-protos.h (x86_output_aligned_bss, x86_elf_aligned_common):\n+\tDeclare.\n+\t* i386.c (ix86_section_threshold): New static variable.\n+\t(ix86_in_large_data_p, ix86_encode_section_info,\n+\tx86_64_elf_unique_section,\n+\tx86_64_elf_select_section): New functions.\n+\t(TARGET_ENCODE_SECTION_INFO): Define\n+\t(override_options): Enable medium model for PIC.\n+\t(ix86_expand_prologue): Expand gen_set_got_rex64.\n+\t(legitimate_constant_p): Handle new UNSPECs.\n+\t(legitimate_pic_address_disp_p): Likewise.\n+\t(legitimize_pic_address): Lower MEDIUM model addressing.\n+\t* i386.h (PIC_OFFSET_TABLE_REGNUM): Set for medium model PIC.\n+\t(enum cmodel): Add MEDIUM_PIC.\n+\t(SYMBOL_REF_FAR_ADDR_P): New macro.\n+\t(SYMBOL_FLAG_FAR_ADDR): New flag.\n+\t* i386.md (movdi): Support medium model.\n+\t(set_got_rex64): New pattern.\n+\t* i386.opt (mlarge-data-threshold): New flag.\n+\t* predicates.md (zext_operand/sext_operand): Deal with medium model.\n+\t* x86-64.h (ASM_OUTPUT_ALIGNED_BSS): Use x86_output_aligned_bss.\n+\t(ASM_OUTPUT_ALIGNED_COMMON, TARGET_ASM_SELECT_SECTION,\n+\tTARGET_ASM_UNIQUE_SECTION): New.\n+\n+\t* invoke.texi (-mlarge_data_threshold): Document\n+\n 2005-07-31  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-outof-ssa.c (coalesce_ssa_name): Use coalesce_cost."}, {"sha": "94cecdc9ca22d08c78bcaa75e371125ce0532811", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=7dcbf65993ee71dd17805df86bbff9d7a8716258", "patch": "@@ -259,6 +259,10 @@ struct ix86_address\n \n extern int ix86_decompose_address (rtx, struct ix86_address *);\n extern int memory_address_length (rtx addr);\n+extern void x86_output_aligned_bss (FILE *, tree, const char *,\n+\t\t\t\t    unsigned HOST_WIDE_INT, int);\n+extern void x86_elf_aligned_common (FILE *, const char *,\n+\t\t\t\t    unsigned HOST_WIDE_INT, int);\n \n #ifdef RTX_CODE\n extern void ix86_fp_comparison_codes (enum rtx_code code, enum rtx_code *,"}, {"sha": "94648b1d38f2d4e6158c1d3955fac7393b9d7843", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 286, "deletions": 7, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7dcbf65993ee71dd17805df86bbff9d7a8716258", "patch": "@@ -812,6 +812,11 @@ unsigned int ix86_preferred_stack_boundary;\n /* Values 1-5: see jump.c */\n int ix86_branch_cost;\n \n+/* Variables which are this size or smaller are put in the data/bss\n+   or ldata/lbss sections.  */\n+\n+int ix86_section_threshold = 65536;\n+\n /* Prefix built by ASM_GENERATE_INTERNAL_LABEL.  */\n char internal_label_prefix[16];\n int internal_label_prefix_len;\n@@ -945,6 +950,12 @@ static const char * const x86_64_reg_class_name[] = {\n static REAL_VALUE_TYPE ext_80387_constants_table [5];\n static bool ext_80387_constants_init = 0;\n static void init_ext_80387_constants (void);\n+static bool ix86_in_large_data_p (tree);\n+static void ix86_encode_section_info (tree, rtx, int);\n+static void x86_64_elf_unique_section (tree decl, int reloc) ATTRIBUTE_UNUSED;\n+static void x86_64_elf_select_section (tree decl, int reloc,\n+\t\t\t\t       unsigned HOST_WIDE_INT align)\n+\t\t\t\t      ATTRIBUTE_UNUSED;\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ATTRIBUTE_TABLE\n@@ -965,6 +976,9 @@ static void init_ext_80387_constants (void);\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE ix86_output_function_epilogue\n \n+#undef TARGET_ENCODE_SECTION_INFO\n+#define TARGET_ENCODE_SECTION_INFO ix86_encode_section_info\n+\n #undef TARGET_ASM_OPEN_PAREN\n #define TARGET_ASM_OPEN_PAREN \"\"\n #undef TARGET_ASM_CLOSE_PAREN\n@@ -1291,14 +1305,14 @@ override_options (void)\n     {\n       if (!strcmp (ix86_cmodel_string, \"small\"))\n \tix86_cmodel = flag_pic ? CM_SMALL_PIC : CM_SMALL;\n+      else if (!strcmp (ix86_cmodel_string, \"medium\"))\n+\tix86_cmodel = flag_pic ? CM_MEDIUM_PIC : CM_MEDIUM;\n       else if (flag_pic)\n \tsorry (\"code model %s not supported in PIC mode\", ix86_cmodel_string);\n       else if (!strcmp (ix86_cmodel_string, \"32\"))\n \tix86_cmodel = CM_32;\n       else if (!strcmp (ix86_cmodel_string, \"kernel\") && !flag_pic)\n \tix86_cmodel = CM_KERNEL;\n-      else if (!strcmp (ix86_cmodel_string, \"medium\") && !flag_pic)\n-\tix86_cmodel = CM_MEDIUM;\n       else if (!strcmp (ix86_cmodel_string, \"large\") && !flag_pic)\n \tix86_cmodel = CM_LARGE;\n       else\n@@ -1502,6 +1516,14 @@ override_options (void)\n       else\n \tix86_branch_cost = i;\n     }\n+  if (ix86_section_threshold_string)\n+    {\n+      i = atoi (ix86_section_threshold_string);\n+      if (i < 0)\n+\terror (\"-mlarge-data-threshold=%d is negative\", i);\n+      else\n+\tix86_section_threshold = i;\n+    }\n \n   if (ix86_tls_dialect_string)\n     {\n@@ -1641,6 +1663,175 @@ override_options (void)\n     flag_schedule_insns_after_reload = flag_schedule_insns = 0;\n }\n \f\n+/* switch to the appropriate section for output of DECL.\n+   DECL is either a `VAR_DECL' node or a constant of some sort.\n+   RELOC indicates whether forming the initial value of DECL requires\n+   link-time relocations.  */\n+\n+static void\n+x86_64_elf_select_section (tree decl, int reloc,\n+\t\t         unsigned HOST_WIDE_INT align)\n+{\n+  if ((ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_MEDIUM_PIC)\n+      && ix86_in_large_data_p (decl))\n+    {\n+      const char *sname = NULL;\n+      switch (categorize_decl_for_section (decl, reloc, flag_pic))\n+\t{\n+\tcase SECCAT_DATA:\n+\t  sname = \".ldata\";\n+\t  break;\n+\tcase SECCAT_DATA_REL:\n+\t  sname = \".ldata.rel\";\n+\t  break;\n+\tcase SECCAT_DATA_REL_LOCAL:\n+\t  sname = \".ldata.rel.local\";\n+\t  break;\n+\tcase SECCAT_DATA_REL_RO:\n+\t  sname = \".ldata.rel.ro\";\n+\t  break;\n+\tcase SECCAT_DATA_REL_RO_LOCAL:\n+\t  sname = \".ldata.rel.ro.local\";\n+\t  break;\n+\tcase SECCAT_BSS:\n+\t  sname = \".lbss\";\n+\t  break;\n+\tcase SECCAT_RODATA:\n+\tcase SECCAT_RODATA_MERGE_STR:\n+\tcase SECCAT_RODATA_MERGE_STR_INIT:\n+\tcase SECCAT_RODATA_MERGE_CONST:\n+\t  sname = \".lrodata\";\n+\t  break;\n+\tcase SECCAT_SRODATA:\n+\tcase SECCAT_SDATA:\n+\tcase SECCAT_SBSS:\n+\t  gcc_unreachable ();\n+\tcase SECCAT_TEXT:\n+\tcase SECCAT_TDATA:\n+\tcase SECCAT_TBSS:\n+\t  /* We don't split these for medium model.  Place them into\n+\t     default sections and hope for best.  */\n+\t  break;\n+\t}\n+      if (sname)\n+\t{\n+          named_section (decl, sname, reloc);\n+\t  return;\n+\t}\n+    }\n+  default_elf_select_section (decl, reloc, align);\n+}\n+\n+/* Build up a unique section name, expressed as a\n+   STRING_CST node, and assign it to DECL_SECTION_NAME (decl).\n+   RELOC indicates whether the initial value of EXP requires\n+   link-time relocations.  */\n+\n+static void\n+x86_64_elf_unique_section (tree decl, int reloc)\n+{\n+  if ((ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_MEDIUM_PIC)\n+      && ix86_in_large_data_p (decl))\n+    {\n+      const char *prefix = NULL;\n+      /* We only need to use .gnu.linkonce if we don't have COMDAT groups.  */\n+      bool one_only = DECL_ONE_ONLY (decl) && !HAVE_COMDAT_GROUP;\n+\n+      switch (categorize_decl_for_section (decl, reloc, flag_pic))\n+\t{\n+\tcase SECCAT_DATA:\n+\tcase SECCAT_DATA_REL:\n+\tcase SECCAT_DATA_REL_LOCAL:\n+\tcase SECCAT_DATA_REL_RO:\n+\tcase SECCAT_DATA_REL_RO_LOCAL:\n+          prefix = one_only ? \".gnu.linkonce.ld.\" : \".ldata.\";\n+\t  break;\n+\tcase SECCAT_BSS:\n+          prefix = one_only ? \".gnu.linkonce.lb.\" : \".lbss.\";\n+\t  break;\n+\tcase SECCAT_RODATA:\n+\tcase SECCAT_RODATA_MERGE_STR:\n+\tcase SECCAT_RODATA_MERGE_STR_INIT:\n+\tcase SECCAT_RODATA_MERGE_CONST:\n+          prefix = one_only ? \".gnu.linkonce.lr.\" : \".lrodata.\";\n+\t  break;\n+\tcase SECCAT_SRODATA:\n+\tcase SECCAT_SDATA:\n+\tcase SECCAT_SBSS:\n+\t  gcc_unreachable ();\n+\tcase SECCAT_TEXT:\n+\tcase SECCAT_TDATA:\n+\tcase SECCAT_TBSS:\n+\t  /* We don't split these for medium model.  Place them into\n+\t     default sections and hope for best.  */\n+\t  break;\n+\t}\n+      if (prefix)\n+\t{\n+\t  const char *name;\n+\t  size_t nlen, plen;\n+\t  char *string;\n+\t  plen = strlen (prefix);\n+\n+\t  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\t  name = targetm.strip_name_encoding (name);\n+\t  nlen = strlen (name);\n+\n+\t  string = alloca (nlen + plen + 1);\n+\t  memcpy (string, prefix, plen);\n+\t  memcpy (string + plen, name, nlen + 1);\n+\n+\t  DECL_SECTION_NAME (decl) = build_string (nlen + plen, string);\n+\t  return;\n+\t}\n+    }\n+  default_unique_section (decl, reloc);\n+}\n+\n+/* This says how to output assembler code to declare an\n+   uninitialized external linkage data object.\n+\n+   For medim model x86-64 we need to use .largecomm opcode for\n+   large objects.  */\n+void\n+x86_elf_aligned_common (FILE *file,\n+\t\t\tconst char *name, unsigned HOST_WIDE_INT size,\n+\t\t\tint align)\n+{\n+  if ((ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_MEDIUM_PIC)\n+      && size > (unsigned int)ix86_section_threshold)\n+    fprintf (file, \".largecomm\\t\");\n+  else\n+    fprintf (file, \"%s\", COMMON_ASM_OP);\n+  assemble_name (file, name);\n+  fprintf (file, \",\"HOST_WIDE_INT_PRINT_UNSIGNED\",%u\\n\",\n+\t   size, align / BITS_PER_UNIT);\n+}\n+\n+/* Utility function for targets to use in implementing\n+   ASM_OUTPUT_ALIGNED_BSS.  */\n+\n+void\n+x86_output_aligned_bss (FILE *file, tree decl ATTRIBUTE_UNUSED,\n+\t\t\tconst char *name, unsigned HOST_WIDE_INT size,\n+\t\t\tint align)\n+{\n+  if ((ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_MEDIUM_PIC)\n+      && size > (unsigned int)ix86_section_threshold)\n+    named_section (decl, \".lbss\", 0);\n+  else\n+    bss_section ();\n+  ASM_OUTPUT_ALIGN (file, floor_log2 (align / BITS_PER_UNIT));\n+#ifdef ASM_DECLARE_OBJECT_NAME\n+  last_assemble_variable_decl = decl;\n+  ASM_DECLARE_OBJECT_NAME (file, name, decl);\n+#else\n+  /* Standard thing is just output label for the object.  */\n+  ASM_OUTPUT_LABEL (file, name);\n+#endif /* ASM_DECLARE_OBJECT_NAME */\n+  ASM_OUTPUT_SKIP (file, size ? size : 1);\n+}\n+\f\n void\n optimization_options (int level, int size ATTRIBUTE_UNUSED)\n {\n@@ -4644,7 +4835,10 @@ ix86_expand_prologue (void)\n \n   if (pic_reg_used)\n     {\n-      insn = emit_insn (gen_set_got (pic_offset_table_rtx));\n+      if (TARGET_64BIT)\n+        insn = emit_insn (gen_set_got_rex64 (pic_offset_table_rtx));\n+      else\n+        insn = emit_insn (gen_set_got (pic_offset_table_rtx));\n \n       /* Even with accurate pre-reload life analysis, we can wind up\n \t deleting all references to the pic register after reload.\n@@ -5173,6 +5367,8 @@ legitimate_constant_p (rtx x)\n       if (GET_CODE (x) == UNSPEC)\n \tswitch (XINT (x, 1))\n \t  {\n+\t  case UNSPEC_GOTOFF:\n+\t    return TARGET_64BIT;\n \t  case UNSPEC_TPOFF:\n \t  case UNSPEC_NTPOFF:\n \t    return local_exec_symbolic_operand (XVECEXP (x, 0, 0), Pmode);\n@@ -5232,11 +5428,16 @@ legitimate_pic_operand_p (rtx x)\n     {\n     case CONST:\n       inner = XEXP (x, 0);\n+      if (GET_CODE (inner) == PLUS\n+\t  && GET_CODE (XEXP (inner, 1)) == CONST_INT)\n+\tinner = XEXP (inner, 0);\n \n       /* Only some unspecs are valid as \"constants\".  */\n       if (GET_CODE (inner) == UNSPEC)\n \tswitch (XINT (inner, 1))\n \t  {\n+\t  case UNSPEC_GOTOFF:\n+\t    return TARGET_64BIT;\n \t  case UNSPEC_TPOFF:\n \t    return local_exec_symbolic_operand (XVECEXP (inner, 0, 0), Pmode);\n \t  default:\n@@ -5269,7 +5470,7 @@ legitimate_pic_address_disp_p (rtx disp)\n       if (tls_symbolic_operand (disp, GET_MODE (disp)))\n \treturn 0;\n       if (GET_CODE (disp) == SYMBOL_REF\n-\t  && ix86_cmodel == CM_SMALL_PIC\n+\t  && !SYMBOL_REF_FAR_ADDR_P (disp)\n \t  && SYMBOL_REF_LOCAL_P (disp))\n \treturn 1;\n       if (GET_CODE (disp) == LABEL_REF)\n@@ -5284,7 +5485,7 @@ legitimate_pic_address_disp_p (rtx disp)\n \t  if (tls_symbolic_operand (op0, GET_MODE (op0)))\n \t    return 0;\n \t  if (((GET_CODE (op0) == SYMBOL_REF\n-\t\t&& ix86_cmodel == CM_SMALL_PIC\n+\t\t&& !SYMBOL_REF_FAR_ADDR_P (op0)\n \t\t&& SYMBOL_REF_LOCAL_P (op0))\n \t       || GET_CODE (op0) == LABEL_REF)\n \t      && GET_CODE (op1) == CONST_INT\n@@ -5302,7 +5503,8 @@ legitimate_pic_address_disp_p (rtx disp)\n       /* We are unsafe to allow PLUS expressions.  This limit allowed distance\n          of GOT tables.  We should not need these anyway.  */\n       if (GET_CODE (disp) != UNSPEC\n-\t  || XINT (disp, 1) != UNSPEC_GOTPCREL)\n+\t  || (XINT (disp, 1) != UNSPEC_GOTPCREL\n+\t      && XINT (disp, 1) != UNSPEC_GOTOFF))\n \treturn 0;\n \n       if (GET_CODE (XVECEXP (disp, 0, 0)) != SYMBOL_REF\n@@ -5632,6 +5834,40 @@ legitimize_pic_address (rtx orig, rtx reg)\n \n   if (TARGET_64BIT && legitimate_pic_address_disp_p (addr))\n     new = addr;\n+  else if (TARGET_64BIT\n+\t   && ix86_cmodel != CM_SMALL_PIC\n+\t   && local_symbolic_operand (addr, Pmode))\n+    {\n+      rtx tmpreg;\n+      /* This symbol may be referenced via a displacement from the PIC\n+\t base address (@GOTOFF).  */\n+\n+      if (reload_in_progress)\n+\tregs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+      if (GET_CODE (addr) == CONST)\n+\taddr = XEXP (addr, 0);\n+      if (GET_CODE (addr) == PLUS)\n+\t  {\n+            new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, XEXP (addr, 0)), UNSPEC_GOTOFF);\n+\t    new = gen_rtx_PLUS (Pmode, new, XEXP (addr, 1));\n+\t  }\n+\telse\n+          new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTOFF);\n+      new = gen_rtx_CONST (Pmode, new);\n+      if (!reg)\n+        tmpreg = gen_reg_rtx (Pmode);\n+      else\n+\ttmpreg = reg;\n+      emit_move_insn (tmpreg, new);\n+\n+      if (reg != 0)\n+\t{\n+\t  new = expand_simple_binop (Pmode, PLUS, reg, pic_offset_table_rtx,\n+\t\t\t\t     tmpreg, 1, OPTAB_DIRECT);\n+\t  new = reg;\n+\t}\n+      else new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, tmpreg);\n+    }\n   else if (!TARGET_64BIT && local_symbolic_operand (addr, Pmode))\n     {\n       /* This symbol may be referenced via a displacement from the PIC\n@@ -7884,7 +8120,7 @@ ix86_expand_move (enum machine_mode mode, rtx operands[])\n #else\n       if (GET_CODE (op0) == MEM)\n \top1 = force_reg (Pmode, op1);\n-      else\n+      else \n \top1 = legitimize_address (op1, op1, Pmode);\n #endif /* TARGET_MACHO */\n     }\n@@ -17525,6 +17761,49 @@ ix86_md_asm_clobbers (tree outputs ATTRIBUTE_UNUSED,\n   return clobbers;\n }\n \n+/* Return true if this goes in small data/bss.  */\n+\n+static bool\n+ix86_in_large_data_p (tree exp)\n+{\n+  if (ix86_cmodel != CM_MEDIUM && ix86_cmodel != CM_MEDIUM_PIC)\n+    return false;\n+\n+  /* Functions are never large data.  */\n+  if (TREE_CODE (exp) == FUNCTION_DECL)\n+    return false;\n+\n+  if (TREE_CODE (exp) == VAR_DECL && DECL_SECTION_NAME (exp))\n+    {\n+      const char *section = TREE_STRING_POINTER (DECL_SECTION_NAME (exp));\n+      if (strcmp (section, \".ldata\") == 0\n+\t  || strcmp (section, \".lbss\") == 0)\n+\treturn true;\n+      return false;\n+    }\n+  else\n+    {\n+      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));\n+\n+      /* If this is an incomplete type with size 0, then we can't put it\n+\t in data because it might be too big when completed.  */\n+      if (!size || size > ix86_section_threshold)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+static void\n+ix86_encode_section_info (tree decl, rtx rtl, int first)\n+{\n+  default_encode_section_info (decl, rtl, first);\n+\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl))\n+      && ix86_in_large_data_p (decl))\n+    SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_FAR_ADDR;\n+}\n+\n /* Worker function for REVERSE_CONDITION.  */\n \n enum rtx_code"}, {"sha": "d1f5dd95f563a350f6b38ea797122530c3a33c86", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=7dcbf65993ee71dd17805df86bbff9d7a8716258", "patch": "@@ -961,7 +961,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define REAL_PIC_OFFSET_TABLE_REGNUM  3\n \n #define PIC_OFFSET_TABLE_REGNUM\t\t\t\t\\\n-  (TARGET_64BIT || !flag_pic ? INVALID_REGNUM\t\t\\\n+  ((TARGET_64BIT && ix86_cmodel == CM_SMALL_PIC)\t\\\n+   || !flag_pic ? INVALID_REGNUM\t\t\t\\\n    : reload_completed ? REGNO (pic_offset_table_rtx)\t\\\n    : REAL_PIC_OFFSET_TABLE_REGNUM)\n \n@@ -2143,7 +2144,8 @@ enum cmodel {\n   CM_KERNEL,\t/* Assumes all code and data fits in the high 31 bits.  */\n   CM_MEDIUM,\t/* Assumes code fits in the low 31 bits; data unlimited.  */\n   CM_LARGE,\t/* No assumptions.  */\n-  CM_SMALL_PIC\t/* Assumes code+data+got/plt fits in a 31 bit region.  */\n+  CM_SMALL_PIC,\t/* Assumes code+data+got/plt fits in a 31 bit region.  */\n+  CM_MEDIUM_PIC\t/* Assumes code+got/plt fits in a 31 bit region.  */\n };\n \n extern enum cmodel ix86_cmodel;\n@@ -2160,7 +2162,7 @@ enum asm_dialect {\n \n extern enum asm_dialect ix86_asm_dialect;\n extern unsigned int ix86_preferred_stack_boundary;\n-extern int ix86_branch_cost;\n+extern int ix86_branch_cost, ix86_section_threshold;\n \n /* Smallest class containing REGNO.  */\n extern enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER];\n@@ -2281,6 +2283,10 @@ struct machine_function GTY(())\n #define X86_FILE_START_VERSION_DIRECTIVE false\n #define X86_FILE_START_FLTUSED false\n \n+/* Flag to mark data that is in the large address area.  */\n+#define SYMBOL_FLAG_FAR_ADDR\t\t(SYMBOL_FLAG_MACH_DEP << 0)\n+#define SYMBOL_REF_FAR_ADDR_P(X)\t\\\n+\t((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_FAR_ADDR) != 0)\n /*\n Local variables:\n version-control: t"}, {"sha": "d533408b7700cf06cfc7c412c1e7b2f5b1aa3b4c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=7dcbf65993ee71dd17805df86bbff9d7a8716258", "patch": "@@ -13788,6 +13788,14 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"12\")])\n \n+(define_insn \"set_got_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(const_int 0)] UNSPEC_SET_GOT))]\n+  \"TARGET_64BIT\"\n+  \"lea{q}\\t_GLOBAL_OFFSET_TABLE_(%%rip), %0\"\n+  [(set_attr \"type\" \"lea\")\n+   (set_attr \"length\" \"6\")])\n+\n (define_expand \"epilogue\"\n   [(const_int 1)]\n   \"\""}, {"sha": "2a51fcbedbbb60bac4db80e404f319785b0541f7", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=7dcbf65993ee71dd17805df86bbff9d7a8716258", "patch": "@@ -87,6 +87,10 @@ mbranch-cost=\n Target RejectNegative Joined Var(ix86_branch_cost_string)\n Branches are this expensive (1-5, arbitrary units)\n \n+mlarge-data-threshold=\n+Target RejectNegative Joined Var(ix86_section_threshold_string)\n+Data greater than given threshold will go into .ldata section in x86-64 medium model\n+\n mcmodel=\n Target RejectNegative Joined Var(ix86_cmodel_string)\n Use given x86-64 code model"}, {"sha": "f8ff8049d0f37294d5d5be52b8672397758ba88b", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=7dcbf65993ee71dd17805df86bbff9d7a8716258", "patch": "@@ -110,7 +110,8 @@\n       /* TLS symbols are not constant.  */\n       if (tls_symbolic_operand (op, Pmode))\n \treturn false;\n-      return (ix86_cmodel == CM_SMALL || ix86_cmodel == CM_KERNEL);\n+      return (ix86_cmodel == CM_SMALL || ix86_cmodel == CM_KERNEL\n+\t      || (ix86_cmodel == CM_MEDIUM && !SYMBOL_REF_FAR_ADDR_P (op)));\n \n     case LABEL_REF:\n       /* For certain code models, the code is near as well.  */\n@@ -150,7 +151,9 @@\n \t\t end of 31bits boundary.  We may also accept pretty\n \t\t large negative constants knowing that all objects are\n \t\t in the positive half of address space.  */\n-\t      if (ix86_cmodel == CM_SMALL\n+\t      if ((ix86_cmodel == CM_SMALL\n+\t\t   || (ix86_cmodel == CM_MEDIUM\n+\t\t       && !SYMBOL_REF_FAR_ADDR_P (op1)))\n \t\t  && offset < 16*1024*1024\n \t\t  && trunc_int_for_mode (offset, SImode) == offset)\n \t\treturn 1;\n@@ -224,7 +227,9 @@\n       /* TLS symbols are not constant.  */\n       if (tls_symbolic_operand (op, Pmode))\n \treturn false;\n-      return ix86_cmodel == CM_SMALL;\n+      return (ix86_cmodel == CM_SMALL\n+\t      || (ix86_cmodel == CM_MEDIUM\n+\t\t  && !SYMBOL_REF_FAR_ADDR_P (op)));\n \n     case LABEL_REF:\n       /* For certain code models, the code is near as well.  */\n@@ -247,7 +252,9 @@\n \t\t offsets, since one bit is available for free.  Negative\n \t\t offsets are limited by the size of NULL pointer area\n \t\t specified by the ABI.  */\n-\t      if (ix86_cmodel == CM_SMALL\n+\t      if ((ix86_cmodel == CM_SMALL\n+\t\t   || (ix86_cmodel == CM_MEDIUM\n+\t\t       && !SYMBOL_REF_FAR_ADDR_P (op1)))\n \t\t  && GET_CODE (op2) == CONST_INT\n \t\t  && trunc_int_for_mode (INTVAL (op2), DImode) > -0x10000\n \t\t  && trunc_int_for_mode (INTVAL (op2), SImode) == INTVAL (op2))"}, {"sha": "b0e6947e86311af428ef007f1db7b053da4858a5", "filename": "gcc/config/i386/x86-64.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fconfig%2Fi386%2Fx86-64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fconfig%2Fi386%2Fx86-64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-64.h?ref=7dcbf65993ee71dd17805df86bbff9d7a8716258", "patch": "@@ -52,7 +52,11 @@ Boston, MA 02110-1301, USA.  */\n  %{Wa,*:%*} %{m32:--32} %{m64:--64}\"\n \n #define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \\\n-  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)\n+  x86_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)\n+\n+#undef  ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n+  x86_elf_aligned_common (FILE, NAME, SIZE, ALIGN);\n \n /* This is used to align code labels according to Intel recommendations.  */\n \n@@ -75,3 +79,9 @@ Boston, MA 02110-1301, USA.  */\n \n #undef PREFERRED_DEBUGGING_TYPE\n #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+\n+#undef TARGET_ASM_SELECT_SECTION\n+#define TARGET_ASM_SELECT_SECTION  x86_64_elf_select_section\n+\n+#undef TARGET_ASM_UNIQUE_SECTION\n+#define TARGET_ASM_UNIQUE_SECTION  x86_64_elf_unique_section"}, {"sha": "399083de5c136de9b5babe561582b270af6bf7e6", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=7dcbf65993ee71dd17805df86bbff9d7a8716258", "patch": "@@ -521,7 +521,7 @@ Objective-C and Objective-C++ Dialects}.\n -m96bit-long-double  -mregparm=@var{num}  -msseregparm @gol\n -momit-leaf-frame-pointer  -mno-red-zone -mno-tls-direct-seg-refs @gol\n -mcmodel=@var{code-model} @gol\n--m32  -m64}\n+-m32  -m64 -mlarge-data-threshold=@var{num}}\n \n @emph{IA-64 Options}\n @gccoptlist{-mbig-endian  -mlittle-endian  -mgnu-as  -mgnu-ld  -mno-pic @gol\n@@ -9046,6 +9046,11 @@ their size as well as function calling convention for function taking\n @code{long double} will be modified.  Hence they will not be binary\n compatible with arrays or structures in code compiled without that switch.\n \n+@item -mmlarge-data-threshold=@var{number}\n+@opindex mlarge-data-threshold=@var{number}\n+When @option{-mcmodel=medium} is specified, the data greater than\n+@var{threshold} are placed in large data section.  This value must be the\n+same across all object linked into the binarry and defaults to 65535.\n \n @item -msvr3-shlib\n @itemx -mno-svr3-shlib"}, {"sha": "c0dfb5fd1c432035506c07146683f70323b69fb8", "filename": "gcc/output.h", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=7dcbf65993ee71dd17805df86bbff9d7a8716258", "patch": "@@ -500,6 +500,44 @@ extern void no_asm_to_stream (FILE *);\n #define SECTION_NOTYPE\t 0x80000\t/* don't output @progbits */\n #define SECTION_MACH_DEP 0x100000\t/* subsequent bits reserved for target */\n \n+/* A helper function for default_elf_select_section and\n+   default_elf_unique_section.  Categorizes the DECL.  */\n+\n+enum section_category\n+{\n+  SECCAT_TEXT,\n+\n+  SECCAT_RODATA,\n+  SECCAT_RODATA_MERGE_STR,\n+  SECCAT_RODATA_MERGE_STR_INIT,\n+  SECCAT_RODATA_MERGE_CONST,\n+  SECCAT_SRODATA,\n+\n+  SECCAT_DATA,\n+\n+  /* To optimize loading of shared programs, define following subsections\n+     of data section:\n+\t_REL\tContains data that has relocations, so they get grouped\n+\t\ttogether and dynamic linker will visit fewer pages in memory.\n+\t_RO\tContains data that is otherwise read-only.  This is useful\n+\t\twith prelinking as most relocations won't be dynamically\n+\t\tlinked and thus stay read only.\n+\t_LOCAL\tMarks data containing relocations only to local objects.\n+\t\tThese relocations will get fully resolved by prelinking.  */\n+  SECCAT_DATA_REL,\n+  SECCAT_DATA_REL_LOCAL,\n+  SECCAT_DATA_REL_RO,\n+  SECCAT_DATA_REL_RO_LOCAL,\n+\n+  SECCAT_SDATA,\n+  SECCAT_TDATA,\n+\n+  SECCAT_BSS,\n+  SECCAT_SBSS,\n+  SECCAT_TBSS\n+};\n+\n+\n extern bool set_named_section_flags (const char *, unsigned int);\n #define named_section_flags(NAME, FLAGS) \\\n   named_section_real((NAME), (FLAGS), /*decl=*/NULL_TREE)\n@@ -510,6 +548,7 @@ extern unsigned int default_section_type_flags_1 (tree, const char *, int, int);\n \n extern void default_no_named_section (const char *, unsigned int, tree);\n extern void default_elf_asm_named_section (const char *, unsigned int, tree);\n+extern enum section_category categorize_decl_for_section (tree, int, int);\n extern void default_coff_asm_named_section (const char *, unsigned int, tree);\n extern void default_pe_asm_named_section (const char *, unsigned int, tree);\n "}, {"sha": "6c5a5333024566f0de84d495e03b574211aedf3f", "filename": "gcc/varasm.c", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcbf65993ee71dd17805df86bbff9d7a8716258/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=7dcbf65993ee71dd17805df86bbff9d7a8716258", "patch": "@@ -5017,47 +5017,7 @@ default_select_section (tree decl, int reloc,\n     data_section ();\n }\n \n-/* A helper function for default_elf_select_section and\n-   default_elf_unique_section.  Categorizes the DECL.  */\n-\n enum section_category\n-{\n-  SECCAT_TEXT,\n-\n-  SECCAT_RODATA,\n-  SECCAT_RODATA_MERGE_STR,\n-  SECCAT_RODATA_MERGE_STR_INIT,\n-  SECCAT_RODATA_MERGE_CONST,\n-  SECCAT_SRODATA,\n-\n-  SECCAT_DATA,\n-\n-  /* To optimize loading of shared programs, define following subsections\n-     of data section:\n-\t_REL\tContains data that has relocations, so they get grouped\n-\t\ttogether and dynamic linker will visit fewer pages in memory.\n-\t_RO\tContains data that is otherwise read-only.  This is useful\n-\t\twith prelinking as most relocations won't be dynamically\n-\t\tlinked and thus stay read only.\n-\t_LOCAL\tMarks data containing relocations only to local objects.\n-\t\tThese relocations will get fully resolved by prelinking.  */\n-  SECCAT_DATA_REL,\n-  SECCAT_DATA_REL_LOCAL,\n-  SECCAT_DATA_REL_RO,\n-  SECCAT_DATA_REL_RO_LOCAL,\n-\n-  SECCAT_SDATA,\n-  SECCAT_TDATA,\n-\n-  SECCAT_BSS,\n-  SECCAT_SBSS,\n-  SECCAT_TBSS\n-};\n-\n-static enum section_category\n-categorize_decl_for_section (tree, int, int);\n-\n-static enum section_category\n categorize_decl_for_section (tree decl, int reloc, int shlib)\n {\n   enum section_category ret;"}]}