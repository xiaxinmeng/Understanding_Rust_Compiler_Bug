{"sha": "b89a63b916340ef29aa94710e43dced8b2fcf129", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg5YTYzYjkxNjM0MGVmMjlhYTk0NzEwZTQzZGNlZDhiMmZjZjEyOQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-09-21T18:40:21Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-09-21T18:40:21Z"}, "message": "re PR fortran/52832 ([F03] ASSOCIATE construct with proc-pointer selector is rejected)\n\n2017-09-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/52832\n\t* match.c (gfc_match_associate): Before failing the association\n\ttry again, allowing a proc pointer selector.\n\n\tPR fortran/80120\n\tPR fortran/81903\n\tPR fortran/82121\n\t* primary.c (gfc_match_varspec): Introduce 'tgt_expr', which\n\tpoints to the associate selector, if any. Go through selector\n\treferences, after resolution for variables, to catch any full\n\tor section array references. If a class associate name does\n\tnot have the same declared type as the selector, resolve the\n\tselector and copy the declared type to the associate name.\n\tBefore throwing a no implicit type error, resolve all allowed\n\tselector expressions, and copy the resulting typespec.\n\n\tPR fortran/67543\n\t* resolve.c (resolve_assoc_var): Selector must cannot be the\n\tNULL expression and it must have a type.\n\n\tPR fortran/78152\n\t* resolve.c (resolve_symbol): Allow associate names to be\n\tcoarrays.\n\n2017-09-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/78512\n\t* gfortran.dg/associate_26.f90 : New test.\n\n\tPR fortran/80120\n\t* gfortran.dg/associate_27.f90 : New test.\n\n\tPR fortran/81903\n\t* gfortran.dg/associate_28.f90 : New test.\n\n\tPR fortran/82121\n\t* gfortran.dg/associate_29.f90 : New test.\n\n\tPR fortran/67543\n\t* gfortran.dg/associate_30.f90 : New test.\n\n\tPR fortran/52832\n\t* gfortran.dg/associate_31.f90 : New test.\n\nFrom-SVN: r253077", "tree": {"sha": "3c511b271a1280d31765510df2c68660e8f25fa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c511b271a1280d31765510df2c68660e8f25fa7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b89a63b916340ef29aa94710e43dced8b2fcf129", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b89a63b916340ef29aa94710e43dced8b2fcf129", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b89a63b916340ef29aa94710e43dced8b2fcf129", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b89a63b916340ef29aa94710e43dced8b2fcf129/comments", "author": null, "committer": null, "parents": [{"sha": "2bc668c2749292460764d0474707ece913038fbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bc668c2749292460764d0474707ece913038fbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bc668c2749292460764d0474707ece913038fbc"}], "stats": {"total": 328, "additions": 306, "deletions": 22}, "files": [{"sha": "32d3b217a98c55423e4f954f366652e6a5af0e36", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b89a63b916340ef29aa94710e43dced8b2fcf129", "patch": "@@ -1,3 +1,29 @@\n+2017-09-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/52832\n+\t* match.c (gfc_match_associate): Before failing the association\n+\ttry again, allowing a proc pointer selector.\n+\n+\tPR fortran/80120\n+\tPR fortran/81903\n+\tPR fortran/82121\n+\t* primary.c (gfc_match_varspec): Introduce 'tgt_expr', which\n+\tpoints to the associate selector, if any. Go through selector\n+\treferences, after resolution for variables, to catch any full\n+\tor section array references. If a class associate name does\n+\tnot have the same declared type as the selector, resolve the\n+\tselector and copy the declared type to the associate name.\n+\tBefore throwing a no implicit type error, resolve all allowed\n+\tselector expressions, and copy the resulting typespec.\n+\n+\tPR fortran/67543\n+\t* resolve.c (resolve_assoc_var): Selector must cannot be the\n+\tNULL expression and it must have a type.\n+\n+\tPR fortran/78152\n+\t* resolve.c (resolve_symbol): Allow associate names to be\n+\tcoarrays.\n+\n 2017-09-21  Cesar Philippidis  <cesar@codesourcery.com>\n \n \t* openmp.c (gfc_match_oacc_wait): Don't restrict wait directive"}, {"sha": "4d657e0bc345ccef6e4b1bb0e3ca0d3ac1969800", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=b89a63b916340ef29aa94710e43dced8b2fcf129", "patch": "@@ -1885,8 +1885,15 @@ gfc_match_associate (void)\n       if (gfc_match (\" %n => %e\", newAssoc->name, &newAssoc->target)\n \t    != MATCH_YES)\n \t{\n-\t  gfc_error (\"Expected association at %C\");\n-\t  goto assocListError;\n+\t  /* Have another go, allowing for procedure pointer selectors.  */\n+\t  gfc_matching_procptr_assignment = 1;\n+\t  if (gfc_match (\" %n => %e\", newAssoc->name, &newAssoc->target)\n+ \t      != MATCH_YES)\n+ \t    {\n+ \t      gfc_error (\"Expected association at %C\");\n+ \t      goto assocListError;\n+ \t    }\n+\t  gfc_matching_procptr_assignment = 0;\n \t}\n       newAssoc->where = gfc_current_locus;\n "}, {"sha": "8537d9305d5b20fbd8f329427f99dd990eb87a4d", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 50, "deletions": 19, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=b89a63b916340ef29aa94710e43dced8b2fcf129", "patch": "@@ -1937,6 +1937,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n   gfc_ref *substring, *tail, *tmp;\n   gfc_component *component;\n   gfc_symbol *sym = primary->symtree->n.sym;\n+  gfc_expr *tgt_expr = NULL;\n   match m;\n   bool unknown;\n   char sep;\n@@ -1965,6 +1966,9 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t}\n     }\n \n+  if (sym->assoc && sym->assoc->target)\n+    tgt_expr = sym->assoc->target;\n+\n   /* For associate names, we may not yet know whether they are arrays or not.\n      If the selector expression is unambiguously an array; eg. a full array\n      or an array section, then the associate name must be an array and we can\n@@ -1976,26 +1980,43 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n       && sym->ts.type != BT_CLASS\n       && !sym->attr.dimension)\n     {\n-      if ((!sym->assoc->dangling\n-\t   && sym->assoc->target\n-\t   && sym->assoc->target->ref\n-\t   && sym->assoc->target->ref->type == REF_ARRAY\n-\t   && (sym->assoc->target->ref->u.ar.type == AR_FULL\n-\t       || sym->assoc->target->ref->u.ar.type == AR_SECTION))\n-\t  ||\n-\t   (!(sym->assoc->dangling || sym->ts.type == BT_CHARACTER)\n-\t    && sym->assoc->st\n-\t   && sym->assoc->st->n.sym\n-\t    && sym->assoc->st->n.sym->attr.dimension == 0))\n-\t{\n-    sym->attr.dimension = 1;\n-\t  if (sym->as == NULL && sym->assoc\n+      gfc_ref *ref = NULL;\n+\n+      if (!sym->assoc->dangling && tgt_expr)\n+\t{\n+\t   if (tgt_expr->expr_type == EXPR_VARIABLE)\n+\t     gfc_resolve_expr (tgt_expr);\n+\n+\t   ref = tgt_expr->ref;\n+\t   for (; ref; ref = ref->next)\n+\t      if (ref->type == REF_ARRAY\n+\t\t  && (ref->u.ar.type == AR_FULL\n+\t\t      || ref->u.ar.type == AR_SECTION))\n+\t\tbreak;\n+\t}\n+\n+      if (ref || (!(sym->assoc->dangling || sym->ts.type == BT_CHARACTER)\n+\t\t  && sym->assoc->st\n+\t\t  && sym->assoc->st->n.sym\n+\t\t  && sym->assoc->st->n.sym->attr.dimension == 0))\n+\t{\n+\t  sym->attr.dimension = 1;\n+\t  if (sym->as == NULL\n \t      && sym->assoc->st\n \t      && sym->assoc->st->n.sym\n \t      && sym->assoc->st->n.sym->as)\n \t    sym->as = gfc_copy_array_spec (sym->assoc->st->n.sym->as);\n \t}\n     }\n+  else if (sym->ts.type == BT_CLASS\n+\t   && tgt_expr\n+\t   && tgt_expr->expr_type == EXPR_VARIABLE\n+\t   && sym->ts.u.derived != tgt_expr->ts.u.derived)\n+    {\n+      gfc_resolve_expr (tgt_expr);\n+      if (tgt_expr->rank)\n+\tsym->ts.u.derived = tgt_expr->ts.u.derived;\n+    }\n \n   if ((equiv_flag && gfc_peek_ascii_char () == '(')\n       || gfc_peek_ascii_char () == '[' || sym->attr.codimension\n@@ -2055,14 +2076,24 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n       && gfc_get_default_type (sym->name, sym->ns)->type == BT_DERIVED)\n     gfc_set_default_type (sym, 0, sym->ns);\n \n-  /* Before throwing an error try resolving the target expression of\n-     associate names. This should resolve function calls, for example.  */\n+  /* See if there is a usable typespec in the \"no IMPLICIT type\" error.  */\n   if (sym->ts.type == BT_UNKNOWN && m == MATCH_YES)\n     {\n-      if (sym->assoc && sym->assoc->target)\n+      bool permissible;\n+\n+      /* These target expressions can ge resolved at any time.  */\n+      permissible = tgt_expr && tgt_expr->symtree && tgt_expr->symtree->n.sym\n+\t\t    && (tgt_expr->symtree->n.sym->attr.use_assoc\n+\t\t\t|| tgt_expr->symtree->n.sym->attr.host_assoc\n+\t\t\t|| tgt_expr->symtree->n.sym->attr.if_source\n+\t\t\t\t\t\t\t\t== IFSRC_DECL);\n+      permissible = permissible\n+\t\t    || (tgt_expr && tgt_expr->expr_type == EXPR_OP);\n+\n+      if (permissible)\n \t{\n-\t  gfc_resolve_expr (sym->assoc->target);\n-\t  sym->ts = sym->assoc->target->ts;\n+\t  gfc_resolve_expr (tgt_expr);\n+\t  sym->ts = tgt_expr->ts;\n \t}\n \n       if (sym->ts.type == BT_UNKNOWN)"}, {"sha": "a3a62deb6d125047818cd620bfe19d3c53c18fe1", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=b89a63b916340ef29aa94710e43dced8b2fcf129", "patch": "@@ -8396,11 +8396,23 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n \tsym->attr.subref_array_pointer = 1;\n     }\n \n+  if (target->expr_type == EXPR_NULL)\n+    {\n+      gfc_error (\"Selector at %L cannot be NULL()\", &target->where);\n+      return;\n+    }\n+  else if (target->ts.type == BT_UNKNOWN)\n+    {\n+      gfc_error (\"Selector at %L has no type\", &target->where);\n+      return;\n+    }\n+\n   /* Get type if this was not already set.  Note that it can be\n      some other type than the target in case this is a SELECT TYPE\n      selector!  So we must not update when the type is already there.  */\n   if (sym->ts.type == BT_UNKNOWN)\n     sym->ts = target->ts;\n+\n   gcc_assert (sym->ts.type != BT_UNKNOWN);\n \n   /* See if this is a valid association-to-variable.  */\n@@ -11926,6 +11938,7 @@ deferred_requirements (gfc_symbol *sym)\n   if (sym->ts.deferred\n       && !(sym->attr.pointer\n \t   || sym->attr.allocatable\n+\t   || sym->attr.associate_var\n \t   || sym->attr.omp_udr_artificial_var))\n     {\n       gfc_error (\"Entity %qs at %L has a deferred type parameter and \"\n@@ -14763,6 +14776,7 @@ resolve_symbol (gfc_symbol *sym)\n   if (class_attr.codimension\n       && !(class_attr.allocatable || sym->attr.dummy || sym->attr.save\n \t   || sym->attr.select_type_temporary\n+\t   || sym->attr.associate_var\n \t   || (sym->ns->save_all && !sym->attr.automatic)\n \t   || sym->ns->proc_name->attr.flavor == FL_MODULE\n \t   || sym->ns->proc_name->attr.is_main_program"}, {"sha": "7b4805218c012fa131dfc78bc72155f4c8de76b1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b89a63b916340ef29aa94710e43dced8b2fcf129", "patch": "@@ -1,3 +1,23 @@\n+2017-09-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/78512\n+\t* gfortran.dg/associate_26.f90 : New test.\n+\n+\tPR fortran/80120\n+\t* gfortran.dg/associate_27.f90 : New test.\n+\n+\tPR fortran/81903\n+\t* gfortran.dg/associate_28.f90 : New test.\n+\n+\tPR fortran/82121\n+\t* gfortran.dg/associate_29.f90 : New test.\n+\n+\tPR fortran/67543\n+\t* gfortran.dg/associate_30.f90 : New test.\n+\n+\tPR fortran/52832\n+\t* gfortran.dg/associate_31.f90 : New test.\n+\n 2017-09-21  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/discr48.adb: New test.\n@@ -42,7 +62,7 @@\n \t    Jeff Law  <law@redhat.com>\n \n \t* gcc.dg/stack-check-5.c:  Add argument for s390.\n-\t* lib/target-supports.exp: \n+\t* lib/target-supports.exp:\n \t(check_effective_target_supports_stack_clash_protection): Enable for\n \ts390/s390x targets.\n "}, {"sha": "ae19acaf777401b7e493833cbaf9022a3fda4a21", "filename": "gcc/testsuite/gfortran.dg/associate_26.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_26.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_26.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_26.f90?ref=b89a63b916340ef29aa94710e43dced8b2fcf129", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! Test the fix for PR78152\n+!\n+! Contributed by <physiker@toast2.net>\n+!\n+program co_assoc\n+  implicit none\n+  integer, parameter :: p = 5\n+  real, allocatable :: a(:,:)[:,:]\n+  allocate (a(p,p)[2,*])\n+    associate (i => a(1:p, 1:p))\n+  end associate\n+end program co_assoc"}, {"sha": "6fcb8a990fd62c2d7f7600a389d8bb1d1c567258", "filename": "gcc/testsuite/gfortran.dg/associate_27.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_27.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_27.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_27.f90?ref=b89a63b916340ef29aa94710e43dced8b2fcf129", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR80120\n+!\n+! Contributed by Marco Restelli  <mrestelli@gmail.com>\n+!\n+program p\n+ implicit none\n+\n+ type :: t\n+  character(len=25) :: text(2)\n+ end type t\n+ type(t) :: x\n+\n+ x%text(1) = \"ABC\"\n+ x%text(2) = \"defgh\"\n+\n+ associate( c => x%text )\n+   if (c(1)(:maxval(len_trim(c))) .ne. trim (x%text(1))) call abort\n+   if (c(2)(:maxval(len_trim(c))) .ne. trim (x%text(2))) call abort\n+ end associate\n+\n+end program p"}, {"sha": "8715472799e53a12de528d238de33af53b3a5a27", "filename": "gcc/testsuite/gfortran.dg/associate_28.f90", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_28.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_28.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_28.f90?ref=b89a63b916340ef29aa94710e43dced8b2fcf129", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR81903\n+!\n+! Contributed by Karl May  <karl.may0@freenet.de>\n+!\n+Module TestMod_A\n+  Type :: TestType_A\n+    Real, Allocatable :: a(:,:)\n+  End type TestType_A\n+End Module TestMod_A\n+Module TestMod_B\n+  Type :: TestType_B\n+   Real, Pointer, contiguous :: a(:,:)\n+  End type TestType_B\n+End Module TestMod_B\n+Module TestMod_C\n+  use TestMod_A\n+  use TestMod_B\n+  Implicit None\n+  Type :: TestType_C\n+    Class(TestType_A), Pointer :: TT_A(:)\n+    Type(TestType_B), Allocatable :: TT_B(:)\n+  contains\n+    Procedure, Pass :: SetPt => SubSetPt\n+  End type TestType_C\n+  Interface\n+    Module Subroutine SubSetPt(this)\n+      class(TestType_C), Intent(InOut), Target :: this\n+    End Subroutine\n+  End Interface\n+End Module TestMod_C\n+Submodule(TestMod_C) SetPt\n+contains\n+  Module Procedure SubSetPt\n+    Implicit None\n+    integer :: i\n+    integer :: sum_a = 0\n+    outer:block\n+      associate(x=>this%TT_B,y=>this%TT_A)\n+        Do i=1,size(x)\n+          x(i)%a=>y(i)%a\n+          sum_a = sum_a + sum (int (x(i)%a))\n+        End Do\n+      end associate\n+    End block outer\n+    if (sum_a .ne. 30) call abort\n+  End Procedure\n+End Submodule SetPt\n+Program Test\n+  use TestMod_C\n+  use TestMod_A\n+  Implicit None\n+  Type(TestType_C) :: tb\n+  Type(TestType_A), allocatable, Target :: ta(:)\n+  integer :: i\n+  real :: src(2,2) = reshape ([(real(i), i = 1,4)],[2,2])\n+  allocate(ta(2),tb%tt_b(2))\n+  do i=1,size(ta)\n+    allocate(ta(i)%a(2,2), source = src*real(i))\n+  End do\n+  tb%TT_A=>ta\n+  call tb%setpt()\n+End Program Test"}, {"sha": "786e3c52e8b5bfaceef020c05664e6c7b300d8c9", "filename": "gcc/testsuite/gfortran.dg/associate_29.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_29.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_29.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_29.f90?ref=b89a63b916340ef29aa94710e43dced8b2fcf129", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do compile }\n+!\n+! Test the fix for PR82121\n+!\n+! Contributed by Iain Miller  <iain.miller@ecmwf.int>\n+!\n+MODULE YOMCDDH\n+  IMPLICIT NONE\n+  SAVE\n+  TYPE :: TCDDH\n+    CHARACTER(len=12),ALLOCATABLE :: CADHTLS(:)\n+  END TYPE TCDDH\n+  CHARACTER(len=12),ALLOCATABLE :: CADHTTS(:)\n+  TYPE(TCDDH), POINTER :: YRCDDH => NULL()\n+END MODULE YOMCDDH\n+\n+\n+SUBROUTINE SUCDDH()\n+  USE YOMCDDH  , ONLY : YRCDDH,CADHTTS\n+  IMPLICIT NONE\n+  ALLOCATE (YRCDDH%CADHTLS(20))\n+  ALLOCATE (CADHTTS(20))\n+  ASSOCIATE(CADHTLS=>YRCDDH%CADHTLS, NORMCHAR=>CADHTTS)\n+! Direct reference to character array compiled correctly\n+!    YRCDDH%CADHTLS(1)='SVGTLF'\n+! Reference to associated variable name failed to compile\n+    CADHTLS(2)='SVGTLT'\n+    NORMCHAR(1)='SVLTTC'\n+  END ASSOCIATE\n+END SUBROUTINE SUCDDH"}, {"sha": "ad15d8bf576f36a9ee6875b0cce5beeb76a3ae12", "filename": "gcc/testsuite/gfortran.dg/associate_30.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_30.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_30.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_30.f90?ref=b89a63b916340ef29aa94710e43dced8b2fcf129", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+!\n+! Test the fix for PR67543\n+!\n+! Contributed by Gerhard Steinmetz  <gerhard.steinmetz.fortran@t-online.de>\n+!\n+   subroutine s1\n+      associate (x => null())   ! { dg-error \"cannot be NULL()\" }\n+      end associate\n+   end subroutine\n+\n+   subroutine s2\n+      associate (x => [null()]) ! { dg-error \"has no type\" }\n+      end associate\n+   end subroutine"}, {"sha": "aa0b44c5ad67125bc7ce6b43c59acac652ab704a", "filename": "gcc/testsuite/gfortran.dg/associate_31.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_31.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89a63b916340ef29aa94710e43dced8b2fcf129/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_31.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_31.f90?ref=b89a63b916340ef29aa94710e43dced8b2fcf129", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR52832\n+!\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+  subroutine testSub()\n+    interface\n+      integer function fcn1 (arg)\n+        integer :: arg\n+      end function\n+      integer function fcn2 (arg)\n+        integer :: arg\n+      end function\n+    end interface\n+\n+    procedure(fcn1), pointer :: r\n+    r => fcn2\n+    associate (k => r)\n+      if (r(42) .ne. 84) call abort\n+    end associate\n+    r => fcn1\n+    associate (k => r)\n+      if (r(42) .ne. 42) call abort\n+    end associate\n+  end subroutine testSub\n+\n+  integer function fcn1 (arg)\n+    integer :: arg;\n+    fcn2 = arg\n+  end function\n+\n+  integer function fcn2 (arg)\n+    integer :: arg;\n+    fcn2 = arg*2\n+  end function\n+\n+  call testSub\n+end"}]}