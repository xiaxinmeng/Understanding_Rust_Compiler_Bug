{"sha": "9bb86f403f3085d0d9b344127f7603d4559370a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJiODZmNDAzZjMwODVkMGQ5YjM0NDEyN2Y3NjAzZDQ1NTkzNzBhNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-06-26T20:03:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-06-26T20:03:35Z"}, "message": "predict-12.c: New testcase.\n\n\n\t* gcc.dg/predict-12.c: New testcase.\n\n\t* predict.c: Include gimple-pretty-print.h\n\t(predicted_by_loop_heuristics_p): Check also\n\tPRED_LOOP_EXIT_WITH_RECURSION\n\t(predict_loops): Find self recursive calls and use special purpose\n\tpredictors for them; dump log about decisions.\n\t(pass_profile::execute): Dump info about #of iterations.\n\t* predict.def (PRED_LOOP_EXIT_WITH_RECURSION,\n\t(PRED_LOOP_GUARD_WITH_RECURSION): New predictors.\n\nFrom-SVN: r237791", "tree": {"sha": "758291fab73082c64f9ab653eec592aa1da221c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/758291fab73082c64f9ab653eec592aa1da221c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bb86f403f3085d0d9b344127f7603d4559370a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb86f403f3085d0d9b344127f7603d4559370a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bb86f403f3085d0d9b344127f7603d4559370a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb86f403f3085d0d9b344127f7603d4559370a5/comments", "author": null, "committer": null, "parents": [{"sha": "445f9a500ddf8fd6673e87b525c8f38cd742af26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/445f9a500ddf8fd6673e87b525c8f38cd742af26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/445f9a500ddf8fd6673e87b525c8f38cd742af26"}], "stats": {"total": 167, "additions": 149, "deletions": 18}, "files": [{"sha": "e153a890e1db9799c033d29cf011c3d344170a60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb86f403f3085d0d9b344127f7603d4559370a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb86f403f3085d0d9b344127f7603d4559370a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9bb86f403f3085d0d9b344127f7603d4559370a5", "patch": "@@ -1,3 +1,14 @@\n+2016-06-26  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* predict.c: Include gimple-pretty-print.h\n+\t(predicted_by_loop_heuristics_p): Check also\n+\tPRED_LOOP_EXIT_WITH_RECURSION\n+\t(predict_loops): Find self recursive calls and use special purpose\n+\tpredictors for them; dump log about decisions.\n+\t(pass_profile::execute): Dump info about #of iterations.\n+\t* predict.def (PRED_LOOP_EXIT_WITH_RECURSION,\n+\t(PRED_LOOP_GUARD_WITH_RECURSION): New predictors.\n+\n 2016-06-26  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* config/pa/pa.c (pa_output_indirect_call): Rework to combine"}, {"sha": "01f5cfcf9e1f52509b7717517100fbd063daeaea", "filename": "gcc/predict.c", "status": "modified", "additions": 103, "deletions": 15, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb86f403f3085d0d9b344127f7603d4559370a5/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb86f403f3085d0d9b344127f7603d4559370a5/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=9bb86f403f3085d0d9b344127f7603d4559370a5", "patch": "@@ -55,6 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-loop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"ipa-utils.h\"\n+#include \"gimple-pretty-print.h\"\n \n /* Enum with reasons why a predictor is ignored.  */\n \n@@ -1407,6 +1408,7 @@ predicted_by_loop_heuristics_p (basic_block bb)\n \t|| i->ep_predictor == PRED_LOOP_ITERATIONS_MAX\n \t|| i->ep_predictor == PRED_LOOP_ITERATIONS\n \t|| i->ep_predictor == PRED_LOOP_EXIT\n+\t|| i->ep_predictor == PRED_LOOP_EXIT_WITH_RECURSION\n \t|| i->ep_predictor == PRED_LOOP_EXTRA_EXIT)\n       return true;\n   return false;\n@@ -1686,6 +1688,24 @@ static void\n predict_loops (void)\n {\n   struct loop *loop;\n+  basic_block bb;\n+  hash_set <struct loop *> with_recursion(10);\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      gimple_stmt_iterator gsi;\n+      tree decl;\n+\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\tif (is_gimple_call (gsi_stmt (gsi))\n+\t    && (decl = gimple_call_fndecl (gsi_stmt (gsi))) != NULL\n+\t    && recursive_call_p (current_function_decl, decl))\n+\t  {\n+\t    loop = bb->loop_father;\n+\t    while (loop && !with_recursion.add (loop))\n+\t      loop = loop_outer (loop);\n+\t  }\n+    }\n \n   /* Try to predict out blocks in a loop that are not part of a\n      natural loop.  */\n@@ -1702,6 +1722,7 @@ predict_loops (void)\n       tree loop_bound_var = NULL;\n       tree loop_iv_base = NULL;\n       gcond *stmt = NULL;\n+      bool recursion = with_recursion.contains (loop);\n \n       exits = get_loop_exit_edges (loop);\n       FOR_EACH_VEC_ELT (exits, j, ex)\n@@ -1713,6 +1734,23 @@ predict_loops (void)\n \t  continue;\n \t}\n \n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Predicting loop %i%s with %i exits.\\n\",\n+\t\t loop->num, recursion ? \" (with recursion)\":\"\", n_exits);\n+      if (dump_file && (dump_flags & TDF_DETAILS)\n+\t  && max_loop_iterations_int (loop) >= 0)\n+\t{\n+\t  fprintf (dump_file,\n+\t\t   \"Loop %d iterates at most %i times.\\n\", loop->num,\n+\t\t   (int)max_loop_iterations_int (loop));\n+\t}\n+      if (dump_file && (dump_flags & TDF_DETAILS)\n+\t  && likely_max_loop_iterations_int (loop) >= 0)\n+\t{\n+\t  fprintf (dump_file, \"Loop %d likely iterates at most %i times.\\n\",\n+\t\t   loop->num, (int)likely_max_loop_iterations_int (loop));\n+\t}\n+\n       FOR_EACH_VEC_ELT (exits, j, ex)\n \t{\n \t  tree niter = NULL;\n@@ -1727,13 +1765,28 @@ predict_loops (void)\n \t  /* Loop heuristics do not expect exit conditional to be inside\n \t     inner loop.  We predict from innermost to outermost loop.  */\n \t  if (predicted_by_loop_heuristics_p (ex->src))\n-\t    continue;\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Skipping exit %i->%i because \"\n+\t\t\t \"it is already predicted.\\n\",\n+\t\t\t ex->src->index, ex->dest->index);\n+\t      continue;\n+\t    }\n \t  predict_extra_loop_exits (ex);\n \n \t  if (number_of_iterations_exit (loop, ex, &niter_desc, false, false))\n \t    niter = niter_desc.niter;\n \t  if (!niter || TREE_CODE (niter_desc.niter) != INTEGER_CST)\n \t    niter = loop_niter_by_eval (loop, ex);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS)\n+\t      && TREE_CODE (niter) == INTEGER_CST)\n+\t    {\n+\t      fprintf (dump_file, \"Exit %i->%i %d iterates \",\n+\t\t       ex->src->index, ex->dest->index,\n+\t\t       loop->num);\n+\t      print_generic_expr (dump_file, niter, TDF_SLIM);\n+\t      fprintf (dump_file, \" times.\\n\");\n+\t    }\n \n \t  if (TREE_CODE (niter) == INTEGER_CST)\n \t    {\n@@ -1766,14 +1819,24 @@ predict_loops (void)\n \t\t\t\t RDIV (REG_BR_PROB_BASE,\n \t\t\t\t       REG_BR_PROB_BASE\n \t\t\t\t\t - predictor_info\n-\t\t\t\t\t\t [PRED_LOOP_EXIT].hitrate)))\n+\t\t\t\t\t\t [recursion\n+\t\t\t\t\t\t  ? PRED_LOOP_EXIT_WITH_RECURSION\n+\t\t\t\t\t\t  : PRED_LOOP_EXIT].hitrate)))\n \t    {\n \t      nitercst = nit.to_shwi ();\n \t      predictor = PRED_LOOP_ITERATIONS_MAX;\n \t    }\n \t  else\n-\t    continue;\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Nothing known about exit %i->%i.\\n\",\n+\t\t\t ex->src->index, ex->dest->index);\n+\t      continue;\n+\t    }\n \n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Recording prediction to %i iterations by %s.\\n\",\n+\t\t     (int)nitercst, predictor_info[predictor].name);\n \t  /* If the prediction for number of iterations is zero, do not\n \t     predict the exit edges.  */\n \t  if (nitercst == 0)\n@@ -1807,7 +1870,6 @@ predict_loops (void)\n \n       for (j = 0; j < loop->num_nodes; j++)\n \t{\n-\t  int header_found = 0;\n \t  edge e;\n \t  edge_iterator ei;\n \n@@ -1818,14 +1880,16 @@ predict_loops (void)\n \t     in the source language and are better to be handled\n \t     separately.  */\n \t  if (predicted_by_p (bb, PRED_CONTINUE))\n-\t    continue;\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"BB %i predicted by continue.\\n\",\n+\t\t\t bb->index);\n+\t      continue;\n+\t    }\n \n-\t  /* Loop exit heuristics - predict an edge exiting the loop if the\n-\t     conditional has no loop header successors as not taken.  */\n-\t  if (!header_found\n-\t      /* If we already used more reliable loop exit predictors, do not\n-\t\t bother with PRED_LOOP_EXIT.  */\n-\t      && !predicted_by_loop_heuristics_p (bb))\n+\t  /* If we already used more reliable loop exit predictors, do not\n+\t     bother with PRED_LOOP_EXIT.  */\n+\t  if (!predicted_by_loop_heuristics_p (bb))\n \t    {\n \t      /* For loop with many exits we don't want to predict all exits\n \t         with the pretty large probability, because if all exits are\n@@ -1842,14 +1906,25 @@ predict_loops (void)\n \t\t a wide loop.  */\n \n \t      int probability = ((REG_BR_PROB_BASE\n-\t\t                  - predictor_info [(int) PRED_LOOP_EXIT].hitrate)\n+\t\t                  - predictor_info\n+\t\t\t\t     [recursion\n+\t\t\t\t      ? PRED_LOOP_EXIT_WITH_RECURSION\n+\t\t\t\t      : PRED_LOOP_EXIT].hitrate)\n \t\t\t\t / n_exits);\n \t      if (probability < HITRATE (2))\n \t\tprobability = HITRATE (2);\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n \t\tif (e->dest->index < NUM_FIXED_BLOCKS\n \t\t    || !flow_bb_inside_loop_p (loop, e->dest))\n-\t\t  predict_edge (e, PRED_LOOP_EXIT, probability);\n+\t\t  {\n+\t\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t      fprintf (dump_file,\n+\t\t\t       \"Predicting exit %i->%i with prob %i.\\n\",\n+\t\t\t       e->src->index, e->dest->index, probability);\n+\t\t    predict_edge (e,\n+\t\t\t\t  recursion ? PRED_LOOP_EXIT_WITH_RECURSION\n+\t\t\t          : PRED_LOOP_EXIT, probability);\n+\t\t  }\n \t    }\n \t  if (loop_bound_var)\n \t    predict_iv_comparison (loop, bb, loop_bound_var, loop_iv_base,\n@@ -1910,7 +1985,9 @@ predict_loops (void)\n \t      if (!dominated_by_p (CDI_DOMINATORS,\n \t\t\t\t   loop_outer (loop)->latch, loop->header))\n \t\tpredict_paths_leading_to_edge (loop_preheader_edge (loop),\n-\t\t\t\t\t       PRED_LOOP_GUARD,\n+\t\t\t\t\t       recursion\n+\t\t\t\t\t       ? PRED_LOOP_GUARD_WITH_RECURSION\n+\t\t\t\t\t       : PRED_LOOP_GUARD,\n \t\t\t\t\t       NOT_TAKEN,\n \t\t\t\t\t       loop_outer (loop));\n \t    }\n@@ -1919,7 +1996,9 @@ predict_loops (void)\n \t      if (!dominated_by_p (CDI_DOMINATORS,\n \t\t\t\t   loop_outer (loop)->latch, bb))\n \t\tpredict_paths_leading_to (bb,\n-\t\t\t\t\t  PRED_LOOP_GUARD,\n+\t\t\t\t\t  recursion\n+\t\t\t\t\t  ? PRED_LOOP_GUARD_WITH_RECURSION\n+\t\t\t\t\t  : PRED_LOOP_GUARD,\n \t\t\t\t\t  NOT_TAKEN,\n \t\t\t\t\t  loop_outer (loop));\n \t    }\n@@ -3367,6 +3446,15 @@ pass_profile::execute (function *fun)\n     gimple_dump_cfg (dump_file, dump_flags);\n  if (profile_status_for_fn (fun) == PROFILE_ABSENT)\n     profile_status_for_fn (fun) = PROFILE_GUESSED;\n+ if (dump_file && (dump_flags & TDF_DETAILS))\n+   {\n+     struct loop *loop;\n+     FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n+       if (loop->header->frequency)\n+         fprintf (dump_file, \"Loop got predicted %d to iterate %i times.\\n\",\n+       \t   loop->num,\n+       \t   (int)expected_loop_iterations_unbounded (loop));\n+   }\n   return 0;\n }\n "}, {"sha": "511920410c2c5f549e465bade9b819673b0a2153", "filename": "gcc/predict.def", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb86f403f3085d0d9b344127f7603d4559370a5/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb86f403f3085d0d9b344127f7603d4559370a5/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=9bb86f403f3085d0d9b344127f7603d4559370a5", "patch": "@@ -92,6 +92,10 @@ DEF_PREDICTOR (PRED_COLD_FUNCTION, \"cold function call\", PROB_VERY_LIKELY,\n DEF_PREDICTOR (PRED_LOOP_EXIT, \"loop exit\", HITRATE (85),\n \t       PRED_FLAG_FIRST_MATCH)\n \n+/* Same as LOOP_EXIT but for loops containing recursive call.  */\n+DEF_PREDICTOR (PRED_LOOP_EXIT_WITH_RECURSION, \"loop exit with recursion\",\n+\t       HITRATE (72), PRED_FLAG_FIRST_MATCH)\n+\n /* Edge causing loop to terminate by computing value used by later\n    conditional.  */\n DEF_PREDICTOR (PRED_LOOP_EXTRA_EXIT, \"extra loop exit\", HITRATE (83),\n@@ -105,14 +109,17 @@ DEF_PREDICTOR (PRED_TREE_POINTER, \"pointer (on trees)\", HITRATE (70), 0)\n DEF_PREDICTOR (PRED_OPCODE_POSITIVE, \"opcode values positive\", HITRATE (64), 0)\n DEF_PREDICTOR (PRED_OPCODE_NONEQUAL, \"opcode values nonequal\", HITRATE (66), 0)\n DEF_PREDICTOR (PRED_FPOPCODE, \"fp_opcode\", HITRATE (90), 0)\n-DEF_PREDICTOR (PRED_TREE_OPCODE_POSITIVE, \"opcode values positive (on trees)\", HITRATE (64), 0)\n-DEF_PREDICTOR (PRED_TREE_OPCODE_NONEQUAL, \"opcode values nonequal (on trees)\", HITRATE (66), 0)\n+DEF_PREDICTOR (PRED_TREE_OPCODE_POSITIVE, \"opcode values positive (on trees)\",\n+\t       HITRATE (64), 0)\n+DEF_PREDICTOR (PRED_TREE_OPCODE_NONEQUAL, \"opcode values nonequal (on trees)\",\n+\t       HITRATE (66), 0)\n DEF_PREDICTOR (PRED_TREE_FPOPCODE, \"fp_opcode (on trees)\", HITRATE (90), 0)\n \n /* Branch guarding call is probably taken.  */\n DEF_PREDICTOR (PRED_CALL, \"call\", HITRATE (67), 0)\n \n-/* Recursive calls are usually not taken or the function will recurse indefinitely.  */\n+/* Recursive calls are usually not taken or the function will recurse\n+   indefinitely.  */\n DEF_PREDICTOR (PRED_RECURSIVE_CALL, \"recursive call\", HITRATE (75), 0)\n \n /* Branch causing function to terminate is probably not taken. \n@@ -159,6 +166,10 @@ DEF_PREDICTOR (PRED_LOOP_IV_COMPARE, \"loop iv compare\", PROB_VERY_LIKELY,\n    guess that cond is unlikely.  */\n DEF_PREDICTOR (PRED_LOOP_GUARD, \"loop guard\", HITRATE (66), 0)\n \n+/* Same but for loops containing recursion.  */\n+DEF_PREDICTOR (PRED_LOOP_GUARD_WITH_RECURSION, \"loop guard with recursion\",\n+\t       HITRATE (85), 0)\n+\n /* Branches to hot labels are likely.  */\n DEF_PREDICTOR (PRED_HOT_LABEL, \"hot label\", HITRATE (85), 0)\n "}, {"sha": "3842e7ba2e7188bdebf052020b39cd66a2a001c3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb86f403f3085d0d9b344127f7603d4559370a5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb86f403f3085d0d9b344127f7603d4559370a5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9bb86f403f3085d0d9b344127f7603d4559370a5", "patch": "@@ -1,3 +1,7 @@\n+2016-06-26  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/predict-12.c: New testcase.\n+\n 2016-06-25  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/71649"}, {"sha": "1fd4d67c60ec7cc33eccf4bc8fb1986f7ecd9df3", "filename": "gcc/testsuite/gcc.dg/predict-12.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb86f403f3085d0d9b344127f7603d4559370a5/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb86f403f3085d0d9b344127f7603d4559370a5/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-12.c?ref=9bb86f403f3085d0d9b344127f7603d4559370a5", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+int *a,n,m;\n+void test(void);\n+void\n+t(void)\n+{\n+  int i,j;\n+  for (i=0;i<n;i++)\n+    if (a[i])\n+      for (j=0;j<m;j++)\n+\tif (a[i+j])\n+\t  t();\n+}\n+/* { dg-final { scan-tree-dump-times \"loop guard with recursion\" 1 \"profile_estimate\"} } */\n+/* { dg-final { scan-tree-dump-times \"loop exit with recursion\" 2 \"profile_estimate\"} } */\n+/* { dg-final { scan-tree-dump-times \"recursive call\" 1 \"profile_estimate\"} } */"}]}