{"sha": "e89268b691f4bab762a18c8056b2df87c93bc484", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg5MjY4YjY5MWY0YmFiNzYyYTE4YzgwNTZiMmRmODdjOTNiYzQ4NA==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@waitaki.otago.ac.nz", "date": "2002-03-25T01:13:20Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2002-03-25T01:13:20Z"}, "message": "* java/io/PushbackReader.java: Reformat.\n\nFrom-SVN: r51291", "tree": {"sha": "008cd13912e3d3ab63b0b983ee16901353dc884f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/008cd13912e3d3ab63b0b983ee16901353dc884f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e89268b691f4bab762a18c8056b2df87c93bc484", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89268b691f4bab762a18c8056b2df87c93bc484", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e89268b691f4bab762a18c8056b2df87c93bc484", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89268b691f4bab762a18c8056b2df87c93bc484/comments", "author": null, "committer": null, "parents": [{"sha": "1bd6476f2eacdfdda0bc413f404b4b8bd778f802", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bd6476f2eacdfdda0bc413f404b4b8bd778f802", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bd6476f2eacdfdda0bc413f404b4b8bd778f802"}], "stats": {"total": 736, "additions": 340, "deletions": 396}, "files": [{"sha": "322b39afa2265b3b28f817da9b048633190117f0", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89268b691f4bab762a18c8056b2df87c93bc484/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89268b691f4bab762a18c8056b2df87c93bc484/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=e89268b691f4bab762a18c8056b2df87c93bc484", "patch": "@@ -1,3 +1,7 @@\n+2002-03-24  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\t* java/io/PushbackReader.java: Reformat.\n+\n 2002-03-24  Tom Tromey  <tromey@redhat.com>\n \n \t* java/awt/TextComponent.java (TextComponent): Editable by"}, {"sha": "80e949a170ae55c1becbada940d9ad9460553c11", "filename": "libjava/java/io/PushbackReader.java", "status": "modified", "additions": 336, "deletions": 396, "changes": 732, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89268b691f4bab762a18c8056b2df87c93bc484/libjava%2Fjava%2Fio%2FPushbackReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89268b691f4bab762a18c8056b2df87c93bc484/libjava%2Fjava%2Fio%2FPushbackReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPushbackReader.java?ref=e89268b691f4bab762a18c8056b2df87c93bc484", "patch": "@@ -39,402 +39,342 @@\n package java.io;\n \n /**\n-  * This subclass of <code>FilterReader</code> provides the ability to \n-  * unread data from a stream.  It maintains an internal buffer of unread\n-  * data that is supplied to the next read operation.  This is conceptually\n-  * similar to mark/reset functionality, except that in this case the \n-  * position to reset the stream to does not need to be known in advance.\n-  * <p>\n-  * The default pushback buffer size one char, but this can be overridden\n-  * by the creator of the stream.\n-  *\n-  * @version 0.0\n-  *\n-  * @author Aaron M. Renn (arenn@urbanophile.com)\n-  * @author Warren Levy <warrenl@cygnus.com>\n-  */\n-public class PushbackReader extends FilterReader\n-{\n-\n-/*************************************************************************/\n-\n-/*\n- * Class Variables\n- */\n-\n-/**\n-  * This is the default buffer size\n-  */\n-private static final int DEFAULT_BUFFER_SIZE = 1;\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Variables\n- */\n-\n-/**\n-  * This is the buffer that is used to store the pushed back data\n-  */\n-private char[] buf;\n-\n-/**\n-  * This is the position in the buffer from which the next char will be\n-  * read.  Bytes are stored in reverse order in the buffer, starting from\n-  * <code>buf[buf.length - 1]</code> to <code>buf[0]</code>.  Thus when \n-  * <code>pos</code> is 0 the buffer is full and <code>buf.length</code> when \n-  * it is empty\n-  */\n-private int pos;\n-\n-/*************************************************************************/\n-\n-/*\n- * Constructors\n- */\n-\n-/**\n-  * This method initializes a <code>PushbackReader</code> to read from the\n-  * specified subordinate <code>Reader</code> with a default pushback buffer \n-  * size of 1.\n-  *\n-  * @code in The subordinate stream to read from\n-  */\n-public\n-PushbackReader(Reader in)\n-{\n-  this(in, DEFAULT_BUFFER_SIZE);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method initializes a <code>PushbackReader</code> to read from the\n-  * specified subordinate <code>Reader</code> with the specified buffer\n-  * size\n-  *\n-  * @param in The subordinate <code>Reader</code> to read from\n-  * @param bufsize The pushback buffer size to use\n-  */\n-public\n-PushbackReader(Reader in, int bufsize)\n-{\n-  super(in);\n-\n-  if (bufsize < 0)\n-    throw new IllegalArgumentException(\"buffer size must be positive\");\n-\n-  buf = new char[bufsize];\n-  pos = bufsize;\n-}\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Methods\n+ * This subclass of <code>FilterReader</code> provides the ability to \n+ * unread data from a stream.  It maintains an internal buffer of unread\n+ * data that is supplied to the next read operation.  This is conceptually\n+ * similar to mark/reset functionality, except that in this case the \n+ * position to reset the stream to does not need to be known in advance.\n+ * <p>\n+ * The default pushback buffer size one char, but this can be overridden\n+ * by the creator of the stream.\n+ *\n+ * @version 0.0\n+ *\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n+ * @author Warren Levy <warrenl@cygnus.com>\n  */\n-\n-/**\n-  * This method closes the stream and frees any associated resources.\n-  *\n-  * @exception IOException If an error occurs.\n-  */\n-public void\n-close() throws IOException\n-{\n-  synchronized (lock)\n-    {\n-      buf = null;\n-      super.close();\n-    }\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method throws an exception when called since this class does\n-  * not support mark/reset.\n-  *\n-  * @param read_limit Not used.\n-  *\n-  * @exception IOException Always thrown to indicate mark/reset not supported.\n-  */\n-public void\n-mark(int read_limit) throws IOException\n-{\n-  throw new IOException(\"mark not supported in this class\");\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method returns <code>false</code> to indicate that it does not support\n-  * mark/reset functionality.\n-  *\n-  * @return This method returns <code>false</code> to indicate that this class does not support mark/reset functionality\n-  *\n-  */\n-public boolean\n-markSupported()\n-{\n-  return(false);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method always throws an IOException in this class because\n-  * mark/reset functionality is not supported.\n-  *\n-  * @exception IOException Always thrown for this class\n-  */\n-public void\n-reset() throws IOException\n-{\n-  throw new IOException(\"reset not supported in this class\");\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method determines whether or not this stream is ready to be read.\n-  * If it returns <code>false</code> to indicate that the stream is not\n-  * ready, any attempt to read from the stream could (but is not\n-  * guaranteed to) block.\n-  * <p>\n-  * This stream is ready to read if there are either chars waiting to be\n-  * read in the pushback buffer or if the underlying stream is ready to\n-  * be read.\n-  *\n-  * @return <code>true</code> if this stream is ready to be read, <code>false</code> otherwise\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public boolean\n-ready() throws IOException\n-{\n-  synchronized (lock)\n-    {\n-      if (buf == null)\n-\tthrow new IOException (\"stream closed\");\n-\n-      if (((buf.length - pos) > 0) || super.ready())\n-\treturn(true);\n-      else\n-\treturn(false);\n-    }\n-}\n-\n-/*************************************************************************/\n-\n-// Don't delete this method just because the spec says it shouldn't be there!\n-// See the CVS log for details.\n-/**\n-  * This method skips the specified number of chars in the stream.  It\n-  * returns the actual number of chars skipped, which may be less than the\n-  * requested amount.\n-  * <p>\n-  * This method first discards chars from the buffer, then calls the\n-  * <code>skip</code> method on the underlying <code>Reader</code> to \n-  * skip additional chars if necessary.\n-  *\n-  * @param num_chars The requested number of chars to skip\n-  *\n-  * @return The actual number of chars skipped.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public long\n-skip(long num_chars) throws IOException\n-{\n-  synchronized (lock)\n-    {\n-      if (num_chars <= 0)\n-\treturn(0);\n-\n-      if ((buf.length - pos) >= num_chars)\n-\t{\n-\t  pos += num_chars;\n-\t  return(num_chars);\n-\t}\n-\n-      int chars_discarded = buf.length - pos;\n-      pos = buf.length;\n-\n-      long chars_skipped = in.skip(num_chars - chars_discarded);\n-\n-      return(chars_discarded + chars_skipped);\n-    } // synchronized\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads an unsigned char from the input stream and returns it\n-  * as an int in the range of 0-65535.  This method also will return -1 if\n-  * the end of the stream has been reached.  The char returned will be read\n-  * from the pushback buffer, unless the buffer is empty, in which case\n-  * the char will be read from the underlying stream.\n-  * <p>\n-  * This method will block until the char can be read.\n-  *\n-  * @return The char read or -1 if end of stream\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public int\n-read() throws IOException\n-{\n-  synchronized (lock)\n-    {\n-      if (buf == null)\n-        throw new IOException(\"stream closed\");\n-\n-      if (pos == buf.length)\n-\treturn(super.read());\n-\n-      ++pos;\n-      return((buf[pos - 1] & 0xFFFF));\n-    }\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method read chars from a stream and stores them into a caller\n-  * supplied buffer.  It starts storing the data at index <code>offset</code> into\n-  * the buffer and attempts to read <code>len</code> chars.  This method can\n-  * return before reading the number of chars requested.  The actual number\n-  * of chars read is returned as an int.  A -1 is returned to indicate the\n-  * end of the stream.\n-  *  <p>\n-  * This method will block until some data can be read.\n-  * <p>\n-  * This method first reads chars from the pushback buffer in order to \n-  * satisfy the read request.  If the pushback buffer cannot provide all\n-  * of the chars requested, the remaining chars are read from the \n-  * underlying stream.\n-  *\n-  * @param buf The array into which the chars read should be stored\n-  * @param offset The offset into the array to start storing chars\n-  * @param len The requested number of chars to read\n-  *\n-  * @return The actual number of chars read, or -1 if end of stream.\n-  *\n-  * @exception IOException If an error occurs.\n-  */\n-public synchronized int\n-read(char[] b, int offset, int len) throws IOException\n-{\n-  synchronized (lock)\n-    {\n-      if (buf == null)\n-        throw new IOException(\"stream closed\");\n-\n-      if (offset < 0 || len < 0 || offset + len > b.length)\n-        throw new ArrayIndexOutOfBoundsException();\n-\n-      int numBytes = Math.min(buf.length - pos, len);\n-      if (numBytes > 0)\n-\t{\n-\t  System.arraycopy (buf, pos, b, offset, numBytes);\n-\t  pos += numBytes;\n-\t  return numBytes;\n-\t}\n-\n-      return super.read(b, offset, len);\n-    }\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method pushes a single char of data into the pushback buffer.\n-  * The char pushed back is the one that will be returned as the first char\n-  * of the next read.\n-  * <p>\n-  * If the pushback buffer is full, this method throws an exception.\n-  * <p>\n-  * The argument to this method is an <code>int</code>.  Only the low eight bits\n-  * of this value are pushed back.\n-  *\n-  * @param b The char to be pushed back, passed as an int\n-  *\n-  * @exception IOException If the pushback buffer is full.\n-  */\n-public void\n-unread(int b) throws IOException\n-{\n-  synchronized (lock)\n-    {\n-      if (buf == null)\n-\tthrow new IOException(\"stream closed\");\n-      if (pos == 0)\n-\tthrow new IOException(\"Pushback buffer is full\");\n-\n-      --pos;\n-      buf[pos] = (char)(b & 0xFFFF);\n-    } // synchronized\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method pushes all of the chars in the passed char array into \n-  * the pushback buffer.  These chars are pushed in reverse order so that\n-  * the next char read from the stream after this operation will be\n-  * <code>buf[0]</code> followed by <code>buf[1]</code>, etc.\n-  * <p>\n-  * If the pushback buffer cannot hold all of the requested chars, an\n-  * exception is thrown.\n-  *\n-  * @param buf The char array to be pushed back\n-  *\n-  * @exception IOException If the pushback buffer is full\n-  */\n-public synchronized void\n-unread(char[] buf) throws IOException\n-{\n-  unread(buf, 0, buf.length);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method pushed back chars from the passed in array into the pushback\n-  * buffer.  The chars from <code>buf[offset]</code> to <code>buf[offset + len]</code>\n-  * are pushed in reverse order so that the next char read from the stream\n-  * after this operation will be <code>buf[offset]</code> followed by\n-  * <code>buf[offset + 1]</code>, etc.\n-  * <p>\n-  * If the pushback buffer cannot hold all of the requested chars, an\n-  * exception is thrown.\n-  *\n-  * @param buf The char array to be pushed back\n-  * @param offset The index into the array where the chars to be push start\n-  * @param len The number of chars to be pushed.\n-  *\n-  * @exception IOException If the pushback buffer is full\n-  */\n-public synchronized void\n-unread(char[] b, int offset, int len) throws IOException\n+public class PushbackReader extends FilterReader\n {\n-  synchronized (lock)\n-    {\n-      if (buf == null)\n-        throw new IOException(\"stream closed\");\n-      if (pos < len)\n-\tthrow new IOException(\"Pushback buffer is full\");\n-\n-      // Note the order that these chars are being added is the opposite\n-      // of what would be done if they were added to the buffer one at a time.\n-      // See the Java Class Libraries book p. 1397.\n-      System.arraycopy(b, offset, buf, pos - len, len);\n-\n-      // Don't put this into the arraycopy above, an exception might be thrown\n-      // and in that case we don't want to modify pos.\n-      pos -= len;\n-    }\n+  /**\n+   * This is the default buffer size\n+   */\n+  private static final int DEFAULT_BUFFER_SIZE = 1;\n+\n+  /**\n+   * This is the buffer that is used to store the pushed back data\n+   */\n+  private char[] buf;\n+\n+  /**\n+   * This is the position in the buffer from which the next char will be\n+   * read.  Bytes are stored in reverse order in the buffer, starting from\n+   * <code>buf[buf.length - 1]</code> to <code>buf[0]</code>.  Thus when \n+   * <code>pos</code> is 0 the buffer is full and <code>buf.length</code> when \n+   * it is empty\n+   */\n+  private int pos;\n+\n+  /**\n+   * This method initializes a <code>PushbackReader</code> to read from the\n+   * specified subordinate <code>Reader</code> with a default pushback buffer \n+   * size of 1.\n+   *\n+   * @code in The subordinate stream to read from\n+   */\n+  public PushbackReader(Reader in)\n+  {\n+    this(in, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  /**\n+   * This method initializes a <code>PushbackReader</code> to read from the\n+   * specified subordinate <code>Reader</code> with the specified buffer\n+   * size\n+   *\n+   * @param in The subordinate <code>Reader</code> to read from\n+   * @param bufsize The pushback buffer size to use\n+   */\n+  public PushbackReader(Reader in, int bufsize)\n+  {\n+    super(in);\n+\n+    if (bufsize < 0)\n+      throw new IllegalArgumentException(\"buffer size must be positive\");\n+\n+    buf = new char[bufsize];\n+    pos = bufsize;\n+  }\n+\n+  /**\n+   * This method closes the stream and frees any associated resources.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n+  public void close() throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tbuf = null;\n+\tsuper.close();\n+      }\n+  }\n+\n+  /**\n+   * This method throws an exception when called since this class does\n+   * not support mark/reset.\n+   *\n+   * @param read_limit Not used.\n+   *\n+   * @exception IOException Always thrown to indicate mark/reset not supported.\n+   */\n+  public void mark(int read_limit) throws IOException\n+  {\n+    throw new IOException(\"mark not supported in this class\");\n+  }\n+\n+  /**\n+   * This method returns <code>false</code> to indicate that it does not support\n+   * mark/reset functionality.\n+   *\n+   * @return This method returns <code>false</code> to indicate that this class does not support mark/reset functionality\n+   *\n+   */\n+  public boolean markSupported()\n+  {\n+    return(false);\n+  }\n+\n+  /**\n+   * This method always throws an IOException in this class because\n+   * mark/reset functionality is not supported.\n+   *\n+   * @exception IOException Always thrown for this class\n+   */\n+  public void reset() throws IOException\n+  {\n+    throw new IOException(\"reset not supported in this class\");\n+  }\n+\n+  /**\n+   * This method determines whether or not this stream is ready to be read.\n+   * If it returns <code>false</code> to indicate that the stream is not\n+   * ready, any attempt to read from the stream could (but is not\n+   * guaranteed to) block.\n+   * <p>\n+   * This stream is ready to read if there are either chars waiting to be\n+   * read in the pushback buffer or if the underlying stream is ready to\n+   * be read.\n+   *\n+   * @return <code>true</code> if this stream is ready to be read, <code>false</code> otherwise\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public boolean ready() throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tif (buf == null)\n+\t  throw new IOException (\"stream closed\");\n+\n+\tif (((buf.length - pos) > 0) || super.ready())\n+\t  return(true);\n+\telse\n+\t  return(false);\n+      }\n+  }\n+\n+  // Don't delete this method just because the spec says it shouldn't be there!\n+  // See the CVS log for details.\n+  /**\n+    * This method skips the specified number of chars in the stream.  It\n+    * returns the actual number of chars skipped, which may be less than the\n+    * requested amount.\n+    * <p>\n+    * This method first discards chars from the buffer, then calls the\n+    * <code>skip</code> method on the underlying <code>Reader</code> to \n+    * skip additional chars if necessary.\n+    *\n+    * @param num_chars The requested number of chars to skip\n+    *\n+    * @return The actual number of chars skipped.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public long skip(long num_chars) throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tif (num_chars <= 0)\n+\t  return(0);\n+\n+\tif ((buf.length - pos) >= num_chars)\n+\t  {\n+\t    pos += num_chars;\n+\t    return(num_chars);\n+\t  }\n+\n+\tint chars_discarded = buf.length - pos;\n+\tpos = buf.length;\n+\n+\tlong chars_skipped = in.skip(num_chars - chars_discarded);\n+\n+\treturn(chars_discarded + chars_skipped);\n+      }\n+  }\n+\n+  /**\n+   * This method reads an unsigned char from the input stream and returns it\n+   * as an int in the range of 0-65535.  This method also will return -1 if\n+   * the end of the stream has been reached.  The char returned will be read\n+   * from the pushback buffer, unless the buffer is empty, in which case\n+   * the char will be read from the underlying stream.\n+   * <p>\n+   * This method will block until the char can be read.\n+   *\n+   * @return The char read or -1 if end of stream\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public int read() throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tif (buf == null)\n+          throw new IOException(\"stream closed\");\n+\n+\tif (pos == buf.length)\n+\t  return(super.read());\n+\n+\t++pos;\n+\treturn((buf[pos - 1] & 0xFFFF));\n+      }\n+  }\n+\n+  /**\n+   * This method read chars from a stream and stores them into a caller\n+   * supplied buffer.  It starts storing the data at index <code>offset</code> into\n+   * the buffer and attempts to read <code>len</code> chars.  This method can\n+   * return before reading the number of chars requested.  The actual number\n+   * of chars read is returned as an int.  A -1 is returned to indicate the\n+   * end of the stream.\n+   *  <p>\n+   * This method will block until some data can be read.\n+   * <p>\n+   * This method first reads chars from the pushback buffer in order to \n+   * satisfy the read request.  If the pushback buffer cannot provide all\n+   * of the chars requested, the remaining chars are read from the \n+   * underlying stream.\n+   *\n+   * @param buf The array into which the chars read should be stored\n+   * @param offset The offset into the array to start storing chars\n+   * @param len The requested number of chars to read\n+   *\n+   * @return The actual number of chars read, or -1 if end of stream.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n+  public synchronized int read(char[] b, int offset, int len) throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tif (buf == null)\n+          throw new IOException(\"stream closed\");\n+\n+\tif (offset < 0 || len < 0 || offset + len > b.length)\n+          throw new ArrayIndexOutOfBoundsException();\n+\n+\tint numBytes = Math.min(buf.length - pos, len);\n+\tif (numBytes > 0)\n+\t  {\n+\t    System.arraycopy (buf, pos, b, offset, numBytes);\n+\t    pos += numBytes;\n+\t    return numBytes;\n+\t  }\n+\n+\treturn super.read(b, offset, len);\n+      }\n+  }\n+\n+  /**\n+   * This method pushes a single char of data into the pushback buffer.\n+   * The char pushed back is the one that will be returned as the first char\n+   * of the next read.\n+   * <p>\n+   * If the pushback buffer is full, this method throws an exception.\n+   * <p>\n+   * The argument to this method is an <code>int</code>.  Only the low eight bits\n+   * of this value are pushed back.\n+   *\n+   * @param b The char to be pushed back, passed as an int\n+   *\n+   * @exception IOException If the pushback buffer is full.\n+   */\n+  public void unread(int b) throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tif (buf == null)\n+\t  throw new IOException(\"stream closed\");\n+\tif (pos == 0)\n+\t  throw new IOException(\"Pushback buffer is full\");\n+\n+\t--pos;\n+\tbuf[pos] = (char)(b & 0xFFFF);\n+      }\n+  }\n+\n+  /**\n+   * This method pushes all of the chars in the passed char array into \n+   * the pushback buffer.  These chars are pushed in reverse order so that\n+   * the next char read from the stream after this operation will be\n+   * <code>buf[0]</code> followed by <code>buf[1]</code>, etc.\n+   * <p>\n+   * If the pushback buffer cannot hold all of the requested chars, an\n+   * exception is thrown.\n+   *\n+   * @param buf The char array to be pushed back\n+   *\n+   * @exception IOException If the pushback buffer is full\n+   */\n+  public synchronized void unread(char[] buf) throws IOException\n+  {\n+    unread(buf, 0, buf.length);\n+  }\n+\n+  /**\n+   * This method pushed back chars from the passed in array into the pushback\n+   * buffer.  The chars from <code>buf[offset]</code> to <code>buf[offset + len]</code>\n+   * are pushed in reverse order so that the next char read from the stream\n+   * after this operation will be <code>buf[offset]</code> followed by\n+   * <code>buf[offset + 1]</code>, etc.\n+   * <p>\n+   * If the pushback buffer cannot hold all of the requested chars, an\n+   * exception is thrown.\n+   *\n+   * @param buf The char array to be pushed back\n+   * @param offset The index into the array where the chars to be push start\n+   * @param len The number of chars to be pushed.\n+   *\n+   * @exception IOException If the pushback buffer is full\n+   */\n+  public synchronized void unread(char[] b, int offset, int len)\n+    throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tif (buf == null)\n+          throw new IOException(\"stream closed\");\n+\tif (pos < len)\n+\t  throw new IOException(\"Pushback buffer is full\");\n+\n+\t// Note the order that these chars are being added is the opposite\n+\t// of what would be done if they were added to the buffer one at a time.\n+\t// See the Java Class Libraries book p. 1397.\n+\tSystem.arraycopy(b, offset, buf, pos - len, len);\n+\n+\t// Don't put this into the arraycopy above, an exception might be thrown\n+\t// and in that case we don't want to modify pos.\n+\tpos -= len;\n+      }\n+  }\n }\n-\n-} // class PushbackReader"}]}