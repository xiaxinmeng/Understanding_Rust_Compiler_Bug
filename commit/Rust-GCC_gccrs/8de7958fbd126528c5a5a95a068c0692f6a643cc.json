{"sha": "8de7958fbd126528c5a5a95a068c0692f6a643cc", "node_id": "C_kwDOANBUbNoAKDhkZTc5NThmYmQxMjY1MjhjNWE1YTk1YTA2OGMwNjkyZjZhNjQzY2M", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-30T09:52:28Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-30T09:52:28Z"}, "message": "vect: Use code_helper when building SLP nodes\n\nThis patch uses code_helper to represent the common (and\nalternative) operations when building an SLP node.  It's not\nmuch of a saving on its own, but it helps with later patches.\n\ngcc/\n\t* tree-vect-slp.c (vect_build_slp_tree_1): Use code_helper\n\tto record the operations performed by statements, only using\n\tCALL_EXPR for things that don't map to built-in or internal\n\tfunctions.  For shifts, require all shift amounts to be equal\n\tif optab_vector is not supported but optab_scalar is.", "tree": {"sha": "6143646e01e77f6bfb687c2fe138dd8553e0abee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6143646e01e77f6bfb687c2fe138dd8553e0abee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8de7958fbd126528c5a5a95a068c0692f6a643cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8de7958fbd126528c5a5a95a068c0692f6a643cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8de7958fbd126528c5a5a95a068c0692f6a643cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8de7958fbd126528c5a5a95a068c0692f6a643cc/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bb81b3c4945dbae8d490e7a4054ddeb5a3b506c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bb81b3c4945dbae8d490e7a4054ddeb5a3b506c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bb81b3c4945dbae8d490e7a4054ddeb5a3b506c"}], "stats": {"total": 77, "additions": 26, "deletions": 51}, "files": [{"sha": "410e5862d6a98700916644cffb7a2116034bfab9", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 26, "deletions": 51, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de7958fbd126528c5a5a95a068c0692f6a643cc/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de7958fbd126528c5a5a95a068c0692f6a643cc/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=8de7958fbd126528c5a5a95a068c0692f6a643cc", "patch": "@@ -876,17 +876,13 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n {\n   unsigned int i;\n   stmt_vec_info first_stmt_info = stmts[0];\n-  enum tree_code first_stmt_code = ERROR_MARK;\n-  enum tree_code alt_stmt_code = ERROR_MARK;\n-  enum tree_code rhs_code = ERROR_MARK;\n-  enum tree_code first_cond_code = ERROR_MARK;\n+  code_helper first_stmt_code = ERROR_MARK;\n+  code_helper alt_stmt_code = ERROR_MARK;\n+  code_helper rhs_code = ERROR_MARK;\n+  code_helper first_cond_code = ERROR_MARK;\n   tree lhs;\n   bool need_same_oprnds = false;\n   tree vectype = NULL_TREE, first_op1 = NULL_TREE;\n-  optab optab;\n-  int icode;\n-  machine_mode optab_op2_mode;\n-  machine_mode vec_mode;\n   stmt_vec_info first_load = NULL, prev_first_load = NULL;\n   bool first_stmt_load_p = false, load_p = false;\n   bool first_stmt_phi_p = false, phi_p = false;\n@@ -966,13 +962,16 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n       gcall *call_stmt = dyn_cast <gcall *> (stmt);\n       if (call_stmt)\n \t{\n-\t  rhs_code = CALL_EXPR;\n+\t  combined_fn cfn = gimple_call_combined_fn (call_stmt);\n+\t  if (cfn != CFN_LAST)\n+\t    rhs_code = cfn;\n+\t  else\n+\t    rhs_code = CALL_EXPR;\n \n-\t  if (gimple_call_internal_p (stmt, IFN_MASK_LOAD))\n+\t  if (cfn == CFN_MASK_LOAD)\n \t    load_p = true;\n-\t  else if ((gimple_call_internal_p (call_stmt)\n-\t\t    && (!vectorizable_internal_fn_p\n-\t\t\t(gimple_call_internal_fn (call_stmt))))\n+\t  else if ((internal_fn_p (cfn)\n+\t\t    && !vectorizable_internal_fn_p (as_internal_fn (cfn)))\n \t\t   || gimple_call_tail_p (call_stmt)\n \t\t   || gimple_call_noreturn_p (call_stmt)\n \t\t   || gimple_call_chain (call_stmt))\n@@ -1013,32 +1012,11 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t      || rhs_code == LROTATE_EXPR\n \t      || rhs_code == RROTATE_EXPR)\n \t    {\n-\t      vec_mode = TYPE_MODE (vectype);\n-\n \t      /* First see if we have a vector/vector shift.  */\n-\t      optab = optab_for_tree_code (rhs_code, vectype,\n-\t\t\t\t\t   optab_vector);\n-\n-\t      if (!optab\n-\t\t  || optab_handler (optab, vec_mode) == CODE_FOR_nothing)\n+\t      if (!directly_supported_p (rhs_code, vectype, optab_vector))\n \t\t{\n \t\t  /* No vector/vector shift, try for a vector/scalar shift.  */\n-\t\t  optab = optab_for_tree_code (rhs_code, vectype,\n-\t\t\t\t\t       optab_scalar);\n-\n-\t\t  if (!optab)\n-\t\t    {\n-\t\t      if (dump_enabled_p ())\n-\t\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t\t \"Build SLP failed: no optab.\\n\");\n-\t\t      if (is_a <bb_vec_info> (vinfo) && i != 0)\n-\t\t\tcontinue;\n-\t\t      /* Fatal mismatch.  */\n-\t\t      matches[0] = false;\n-\t\t      return false;\n-\t\t    }\n-\t\t  icode = (int) optab_handler (optab, vec_mode);\n-\t\t  if (icode == CODE_FOR_nothing)\n+\t\t  if (!directly_supported_p (rhs_code, vectype, optab_scalar))\n \t\t    {\n \t\t      if (dump_enabled_p ())\n \t\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1050,12 +1028,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\t      matches[0] = false;\n \t\t      return false;\n \t\t    }\n-\t\t  optab_op2_mode = insn_data[icode].operand[2].mode;\n-\t\t  if (!VECTOR_MODE_P (optab_op2_mode))\n-\t\t    {\n-\t\t      need_same_oprnds = true;\n-\t\t      first_op1 = gimple_assign_rhs2 (stmt);\n-\t\t    }\n+\t\t  need_same_oprnds = true;\n+\t\t  first_op1 = gimple_assign_rhs2 (stmt);\n \t\t}\n \t    }\n \t  else if (rhs_code == WIDEN_LSHIFT_EXPR)\n@@ -1081,8 +1055,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\t  return false;\n \t\t}\n \t    }\n-\t  else if (call_stmt\n-\t\t   && gimple_call_internal_p (call_stmt, IFN_DIV_POW2))\n+\t  else if (rhs_code == CFN_DIV_POW2)\n \t    {\n \t      need_same_oprnds = true;\n \t      first_op1 = gimple_call_arg (call_stmt, 1);\n@@ -1139,10 +1112,10 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t      continue;\n \t    }\n \n-\t  if (!load_p && rhs_code == CALL_EXPR)\n+\t  if (!load_p && call_stmt)\n \t    {\n \t      if (!compatible_calls_p (as_a <gcall *> (stmts[0]->stmt),\n-\t\t\t\t       as_a <gcall *> (stmt)))\n+\t\t\t\t       call_stmt))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1243,10 +1216,11 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \n \t  /* Not memory operation.  */\n \t  if (!phi_p\n-\t      && TREE_CODE_CLASS (rhs_code) != tcc_binary\n-\t      && TREE_CODE_CLASS (rhs_code) != tcc_unary\n-\t      && TREE_CODE_CLASS (rhs_code) != tcc_expression\n-\t      && TREE_CODE_CLASS (rhs_code) != tcc_comparison\n+\t      && rhs_code.is_tree_code ()\n+\t      && TREE_CODE_CLASS (tree_code (rhs_code)) != tcc_binary\n+\t      && TREE_CODE_CLASS (tree_code (rhs_code)) != tcc_unary\n+\t      && TREE_CODE_CLASS (tree_code (rhs_code)) != tcc_expression\n+\t      && TREE_CODE_CLASS (tree_code (rhs_code)) != tcc_comparison\n \t      && rhs_code != VIEW_CONVERT_EXPR\n \t      && rhs_code != CALL_EXPR\n \t      && rhs_code != BIT_FIELD_REF)\n@@ -1308,7 +1282,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n   /* If we allowed a two-operation SLP node verify the target can cope\n      with the permute we are going to use.  */\n   if (alt_stmt_code != ERROR_MARK\n-      && TREE_CODE_CLASS (alt_stmt_code) != tcc_reference)\n+      && (!alt_stmt_code.is_tree_code ()\n+\t  || TREE_CODE_CLASS (tree_code (alt_stmt_code)) != tcc_reference))\n     {\n       *two_operators = true;\n     }"}]}