{"sha": "e6477eaa4d5524e7d05975188e27e7b1a148df3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY0NzdlYWE0ZDU1MjRlN2QwNTk3NTE4OGUyN2U3YjFhMTQ4ZGYzYg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2008-04-17T12:27:31Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2008-04-17T12:27:31Z"}, "message": "re PR target/35907 (64-bit power6 glibc miscompilation)\n\n\tPR target/35907\n\t* config/rs6000/rs6000.c (rs6000_emit_epilogue): Restore vr and vrsave\n\tregs before frame pop when needed.  If use_backchain_to_restore_sp\n\tthen load backchain into a temp reg to restore vr and vrsave.  Add\n\tcode to restore vr after frame pop if possible.\n\nFrom-SVN: r134387", "tree": {"sha": "37c1643662d5b851e6cdb077881cdd7a1320b4c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37c1643662d5b851e6cdb077881cdd7a1320b4c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6477eaa4d5524e7d05975188e27e7b1a148df3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6477eaa4d5524e7d05975188e27e7b1a148df3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6477eaa4d5524e7d05975188e27e7b1a148df3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6477eaa4d5524e7d05975188e27e7b1a148df3b/comments", "author": null, "committer": null, "parents": [{"sha": "35485e124cb43114a6c634ce37d8a8c709000cc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35485e124cb43114a6c634ce37d8a8c709000cc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35485e124cb43114a6c634ce37d8a8c709000cc3"}], "stats": {"total": 109, "additions": 97, "deletions": 12}, "files": [{"sha": "d1b9a4ca76a7491bb790cbb6b027ebbf06ec18de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6477eaa4d5524e7d05975188e27e7b1a148df3b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6477eaa4d5524e7d05975188e27e7b1a148df3b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6477eaa4d5524e7d05975188e27e7b1a148df3b", "patch": "@@ -1,3 +1,11 @@\n+2008-04-17  Alan Modra  <amodra@bigpond.net.au>\n+\n+\tPR target/35907\n+\t* config/rs6000/rs6000.c (rs6000_emit_epilogue): Restore vr and vrsave\n+\tregs before frame pop when needed.  If use_backchain_to_restore_sp\n+\tthen load backchain into a temp reg to restore vr and vrsave.  Add\n+\tcode to restore vr after frame pop if possible.\n+\n 2008-04-17  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-vn.c (expressions_equal_p): Do not check type"}, {"sha": "024c140b27454b462e16ecb550eb4cb33979736a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 89, "deletions": 12, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6477eaa4d5524e7d05975188e27e7b1a148df3b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6477eaa4d5524e7d05975188e27e7b1a148df3b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e6477eaa4d5524e7d05975188e27e7b1a148df3b", "patch": "@@ -16370,11 +16370,23 @@ rs6000_emit_epilogue (int sibcall)\n   if (info->push_p)\n     sp_offset = info->total_size;\n \n-  /* Restore AltiVec registers if needed.  */\n-  if (TARGET_ALTIVEC_ABI && info->altivec_size != 0)\n+  /* Restore AltiVec registers if we must do so before adjusting the\n+     stack.  */\n+  if (TARGET_ALTIVEC_ABI\n+      && info->altivec_size != 0\n+      && DEFAULT_ABI != ABI_V4\n+      && info->altivec_save_offset < (TARGET_32BIT ? -220 : -288))\n     {\n       int i;\n \n+      if (use_backchain_to_restore_sp)\n+\t{\n+\t  frame_reg_rtx = gen_rtx_REG (Pmode, 11);\n+\t  emit_move_insn (frame_reg_rtx,\n+\t\t\t  gen_rtx_MEM (Pmode, sp_reg_rtx));\n+\t  sp_offset = 0;\n+\t}\n+\n       for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n \tif (info->vrsave_mask & ALTIVEC_REG_BIT (i))\n \t  {\n@@ -16394,19 +16406,54 @@ rs6000_emit_epilogue (int sibcall)\n \t  }\n     }\n \n+  /* Restore VRSAVE if we must do so before adjusting the stack.  */\n+  if (TARGET_ALTIVEC\n+      && TARGET_ALTIVEC_VRSAVE\n+      && info->vrsave_mask != 0\n+      && DEFAULT_ABI != ABI_V4\n+      && info->vrsave_save_offset < (TARGET_32BIT ? -220 : -288))\n+    {\n+      rtx addr, mem, reg;\n+\n+      if (use_backchain_to_restore_sp\n+\t  && frame_reg_rtx == sp_reg_rtx)\n+\t{\n+\t  frame_reg_rtx = gen_rtx_REG (Pmode, 11);\n+\t  emit_move_insn (frame_reg_rtx,\n+\t\t\t  gen_rtx_MEM (Pmode, sp_reg_rtx));\n+\t  sp_offset = 0;\n+\t}\n+\n+      addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t   GEN_INT (info->vrsave_save_offset + sp_offset));\n+      mem = gen_frame_mem (SImode, addr);\n+      reg = gen_rtx_REG (SImode, 12);\n+      emit_move_insn (reg, mem);\n+\n+      emit_insn (generate_set_vrsave (reg, info, 1));\n+    }\n+\n   /* If we have a frame pointer, a call to alloca,  or a large stack\n      frame, restore the old stack pointer using the backchain.  Otherwise,\n      we know what size to update it with.  */\n   if (use_backchain_to_restore_sp)\n     {\n-      /* Under V.4, don't reset the stack pointer until after we're done\n-\t loading the saved registers.  */\n-      if (DEFAULT_ABI == ABI_V4)\n-\tframe_reg_rtx = gen_rtx_REG (Pmode, 11);\n+      if (frame_reg_rtx != sp_reg_rtx)\n+\t{\n+\t  emit_move_insn (sp_reg_rtx, frame_reg_rtx);\n+\t  frame_reg_rtx = sp_reg_rtx;\n+\t}\n+      else\n+\t{\n+\t  /* Under V.4, don't reset the stack pointer until after we're done\n+\t     loading the saved registers.  */\n+\t  if (DEFAULT_ABI == ABI_V4)\n+\t    frame_reg_rtx = gen_rtx_REG (Pmode, 11);\n \n-      emit_move_insn (frame_reg_rtx,\n-\t\t      gen_rtx_MEM (Pmode, sp_reg_rtx));\n-      sp_offset = 0;\n+\t  emit_move_insn (frame_reg_rtx,\n+\t\t\t  gen_rtx_MEM (Pmode, sp_reg_rtx));\n+\t  sp_offset = 0;\n+\t}\n     }\n   else if (info->push_p\n \t   && DEFAULT_ABI != ABI_V4\n@@ -16420,9 +16467,39 @@ rs6000_emit_epilogue (int sibcall)\n       sp_offset = 0;\n     }\n \n-  /* Restore VRSAVE if needed.  */\n-  if (TARGET_ALTIVEC && TARGET_ALTIVEC_VRSAVE\n-      && info->vrsave_mask != 0)\n+  /* Restore AltiVec registers if we have not done so already.  */\n+  if (TARGET_ALTIVEC_ABI\n+      && info->altivec_size != 0\n+      && (DEFAULT_ABI == ABI_V4\n+\t  || info->altivec_save_offset >= (TARGET_32BIT ? -220 : -288)))\n+    {\n+      int i;\n+\n+      for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n+\tif (info->vrsave_mask & ALTIVEC_REG_BIT (i))\n+\t  {\n+\t    rtx addr, areg, mem;\n+\n+\t    areg = gen_rtx_REG (Pmode, 0);\n+\t    emit_move_insn\n+\t      (areg, GEN_INT (info->altivec_save_offset\n+\t\t\t      + sp_offset\n+\t\t\t      + 16 * (i - info->first_altivec_reg_save)));\n+\n+\t    /* AltiVec addressing mode is [reg+reg].  */\n+\t    addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, areg);\n+\t    mem = gen_frame_mem (V4SImode, addr);\n+\n+\t    emit_move_insn (gen_rtx_REG (V4SImode, i), mem);\n+\t  }\n+    }\n+\n+  /* Restore VRSAVE if we have not done so already.  */\n+  if (TARGET_ALTIVEC\n+      && TARGET_ALTIVEC_VRSAVE\n+      && info->vrsave_mask != 0\n+      && (DEFAULT_ABI == ABI_V4\n+\t  || info->vrsave_save_offset >= (TARGET_32BIT ? -220 : -288)))\n     {\n       rtx addr, mem, reg;\n "}]}