{"sha": "8974754f6f12f2f032d4122b06d26319545ced00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk3NDc1NGY2ZjEyZjJmMDMyZDQxMjJiMDZkMjYzMTk1NDVjZWQwMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-05-27T18:00:15Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-05-27T18:00:15Z"}, "message": "expr.h (array_at_struct_end_p): Move to...\n\n\t* expr.h (array_at_struct_end_p): Move to...\n\t(array_ref_element_size): Likewise.\n\t(component_ref_field_offset): Likewise.\n\t* tree.h (array_ref_element_size): ...here.\n\t(array_at_struct_end_p): Likewise.\n\t(component_ref_field_offset): Likewise.\n\t* expr.c (array_ref_element_size): Move to...\n\t(array_ref_low_bound): Likewise.\n\t(array_at_struct_end_p): Likewise.\n\t(array_ref_up_bound): Likewise.\n\t(component_ref_field_offset): Likewise.\n\t* tree.c (array_ref_element_size): ...here.\n\t(array_ref_low_bound): Likewise.\n\t(array_ref_up_bound): Likewise.\n\t(array_at_struct_end_p): Likewise.\n\t(component_ref_field_offset): Likewise.\n\nFrom-SVN: r223768", "tree": {"sha": "400932ae2cd83549d10a0b94fb453c26608f0409", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/400932ae2cd83549d10a0b94fb453c26608f0409"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8974754f6f12f2f032d4122b06d26319545ced00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8974754f6f12f2f032d4122b06d26319545ced00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8974754f6f12f2f032d4122b06d26319545ced00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8974754f6f12f2f032d4122b06d26319545ced00/comments", "author": null, "committer": null, "parents": [{"sha": "e590690ef23053ddbd5b32c119f403f418a02d6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e590690ef23053ddbd5b32c119f403f418a02d6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e590690ef23053ddbd5b32c119f403f418a02d6a"}], "stats": {"total": 337, "additions": 182, "deletions": 155}, "files": [{"sha": "6920846f50c269ba7b6c5d9ee8124a3cd0968aa8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8974754f6f12f2f032d4122b06d26319545ced00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8974754f6f12f2f032d4122b06d26319545ced00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8974754f6f12f2f032d4122b06d26319545ced00", "patch": "@@ -1,3 +1,22 @@\n+2015-05-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* expr.h (array_at_struct_end_p): Move to...\n+\t(array_ref_element_size): Likewise.\n+\t(component_ref_field_offset): Likewise.\n+\t* tree.h (array_ref_element_size): ...here.\n+\t(array_at_struct_end_p): Likewise.\n+\t(component_ref_field_offset): Likewise.\n+\t* expr.c (array_ref_element_size): Move to...\n+\t(array_ref_low_bound): Likewise.\n+\t(array_at_struct_end_p): Likewise.\n+\t(array_ref_up_bound): Likewise.\n+\t(component_ref_field_offset): Likewise.\n+\t* tree.c (array_ref_element_size): ...here.\n+\t(array_ref_low_bound): Likewise.\n+\t(array_ref_up_bound): Likewise.\n+\t(array_at_struct_end_p): Likewise.\n+\t(component_ref_field_offset): Likewise.\n+\n 2015-05-27  Gregor Richards  <gregor.richards@uwaterloo.ca>\n \t    Szabolcs Nagy  <szabolcs.nagy@arm.com>\n "}, {"sha": "5a931dc35ae7148b03e5ec6c7d0d0cd4be3e976c", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8974754f6f12f2f032d4122b06d26319545ced00/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8974754f6f12f2f032d4122b06d26319545ced00/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8974754f6f12f2f032d4122b06d26319545ced00", "patch": "@@ -7025,139 +7025,6 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n   return exp;\n }\n \n-/* Return a tree of sizetype representing the size, in bytes, of the element\n-   of EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */\n-\n-tree\n-array_ref_element_size (tree exp)\n-{\n-  tree aligned_size = TREE_OPERAND (exp, 3);\n-  tree elmt_type = TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-  location_t loc = EXPR_LOCATION (exp);\n-\n-  /* If a size was specified in the ARRAY_REF, it's the size measured\n-     in alignment units of the element type.  So multiply by that value.  */\n-  if (aligned_size)\n-    {\n-      /* ??? tree_ssa_useless_type_conversion will eliminate casts to\n-\t sizetype from another type of the same width and signedness.  */\n-      if (TREE_TYPE (aligned_size) != sizetype)\n-\taligned_size = fold_convert_loc (loc, sizetype, aligned_size);\n-      return size_binop_loc (loc, MULT_EXPR, aligned_size,\n-\t\t\t     size_int (TYPE_ALIGN_UNIT (elmt_type)));\n-    }\n-\n-  /* Otherwise, take the size from that of the element type.  Substitute\n-     any PLACEHOLDER_EXPR that we have.  */\n-  else\n-    return SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (elmt_type), exp);\n-}\n-\n-/* Return a tree representing the lower bound of the array mentioned in\n-   EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */\n-\n-tree\n-array_ref_low_bound (tree exp)\n-{\n-  tree domain_type = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-\n-  /* If a lower bound is specified in EXP, use it.  */\n-  if (TREE_OPERAND (exp, 2))\n-    return TREE_OPERAND (exp, 2);\n-\n-  /* Otherwise, if there is a domain type and it has a lower bound, use it,\n-     substituting for a PLACEHOLDER_EXPR as needed.  */\n-  if (domain_type && TYPE_MIN_VALUE (domain_type))\n-    return SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_MIN_VALUE (domain_type), exp);\n-\n-  /* Otherwise, return a zero of the appropriate type.  */\n-  return build_int_cst (TREE_TYPE (TREE_OPERAND (exp, 1)), 0);\n-}\n-\n-/* Returns true if REF is an array reference to an array at the end of\n-   a structure.  If this is the case, the array may be allocated larger\n-   than its upper bound implies.  */\n-\n-bool\n-array_at_struct_end_p (tree ref)\n-{\n-  if (TREE_CODE (ref) != ARRAY_REF\n-      && TREE_CODE (ref) != ARRAY_RANGE_REF)\n-    return false;\n-\n-  while (handled_component_p (ref))\n-    {\n-      /* If the reference chain contains a component reference to a\n-         non-union type and there follows another field the reference\n-\t is not at the end of a structure.  */\n-      if (TREE_CODE (ref) == COMPONENT_REF\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (ref, 0))) == RECORD_TYPE)\n-\t{\n-\t  tree nextf = DECL_CHAIN (TREE_OPERAND (ref, 1));\n-\t  while (nextf && TREE_CODE (nextf) != FIELD_DECL)\n-\t    nextf = DECL_CHAIN (nextf);\n-\t  if (nextf)\n-\t    return false;\n-\t}\n-\n-      ref = TREE_OPERAND (ref, 0);\n-    }\n-\n-  /* If the reference is based on a declared entity, the size of the array\n-     is constrained by its given domain.  */\n-  if (DECL_P (ref))\n-    return false;\n-\n-  return true;\n-}\n-\n-/* Return a tree representing the upper bound of the array mentioned in\n-   EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */\n-\n-tree\n-array_ref_up_bound (tree exp)\n-{\n-  tree domain_type = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-\n-  /* If there is a domain type and it has an upper bound, use it, substituting\n-     for a PLACEHOLDER_EXPR as needed.  */\n-  if (domain_type && TYPE_MAX_VALUE (domain_type))\n-    return SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_MAX_VALUE (domain_type), exp);\n-\n-  /* Otherwise fail.  */\n-  return NULL_TREE;\n-}\n-\n-/* Return a tree representing the offset, in bytes, of the field referenced\n-   by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */\n-\n-tree\n-component_ref_field_offset (tree exp)\n-{\n-  tree aligned_offset = TREE_OPERAND (exp, 2);\n-  tree field = TREE_OPERAND (exp, 1);\n-  location_t loc = EXPR_LOCATION (exp);\n-\n-  /* If an offset was specified in the COMPONENT_REF, it's the offset measured\n-     in units of DECL_OFFSET_ALIGN / BITS_PER_UNIT.  So multiply by that\n-     value.  */\n-  if (aligned_offset)\n-    {\n-      /* ??? tree_ssa_useless_type_conversion will eliminate casts to\n-\t sizetype from another type of the same width and signedness.  */\n-      if (TREE_TYPE (aligned_offset) != sizetype)\n-\taligned_offset = fold_convert_loc (loc, sizetype, aligned_offset);\n-      return size_binop_loc (loc, MULT_EXPR, aligned_offset,\n-\t\t\t     size_int (DECL_OFFSET_ALIGN (field)\n-\t\t\t\t       / BITS_PER_UNIT));\n-    }\n-\n-  /* Otherwise, take the offset from that of the field.  Substitute\n-     any PLACEHOLDER_EXPR that we have.  */\n-  else\n-    return SUBSTITUTE_PLACEHOLDER_IN_EXPR (DECL_FIELD_OFFSET (field), exp);\n-}\n-\n /* Alignment in bits the TARGET of an assignment may be assumed to have.  */\n \n static unsigned HOST_WIDE_INT"}, {"sha": "8cf9720484a1c65e11bf3b9e002a2fd8c2389c4e", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8974754f6f12f2f032d4122b06d26319545ced00/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8974754f6f12f2f032d4122b06d26319545ced00/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=8974754f6f12f2f032d4122b06d26319545ced00", "patch": "@@ -281,19 +281,10 @@ rtx get_personality_function (tree);\n extern int can_move_by_pieces (unsigned HOST_WIDE_INT, unsigned int);\n \n extern unsigned HOST_WIDE_INT highest_pow2_factor (const_tree);\n-bool array_at_struct_end_p (tree);\n-\n-/* Return a tree of sizetype representing the size, in bytes, of the element\n-   of EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */\n-extern tree array_ref_element_size (tree);\n \n extern bool categorize_ctor_elements (const_tree, HOST_WIDE_INT *,\n \t\t\t\t      HOST_WIDE_INT *, bool *);\n \n-/* Return a tree representing the offset, in bytes, of the field referenced\n-   by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */\n-extern tree component_ref_field_offset (tree);\n-\n extern void expand_operands (tree, tree, rtx, rtx*, rtx*,\n \t\t\t     enum expand_modifier);\n "}, {"sha": "c22fa765f4c9b4306028f8de804e5e71a8714e6d", "filename": "gcc/tree.c", "status": "modified", "additions": 135, "deletions": 2, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8974754f6f12f2f032d4122b06d26319545ced00/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8974754f6f12f2f032d4122b06d26319545ced00/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=8974754f6f12f2f032d4122b06d26319545ced00", "patch": "@@ -24,8 +24,8 @@ along with GCC; see the file COPYING3.  If not see\n    tables index by tree code that describe how to take apart\n    nodes of that code.\n \n-   It is intended to be language-independent, but occasionally\n-   calls language-dependent routines defined (for C) in typecheck.c.  */\n+   It is intended to be language-independent but can occasionally\n+   calls language-dependent routines.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -12453,6 +12453,139 @@ get_base_address (tree t)\n   return t;\n }\n \n+/* Return a tree of sizetype representing the size, in bytes, of the element\n+   of EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */\n+\n+tree\n+array_ref_element_size (tree exp)\n+{\n+  tree aligned_size = TREE_OPERAND (exp, 3);\n+  tree elmt_type = TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+  location_t loc = EXPR_LOCATION (exp);\n+\n+  /* If a size was specified in the ARRAY_REF, it's the size measured\n+     in alignment units of the element type.  So multiply by that value.  */\n+  if (aligned_size)\n+    {\n+      /* ??? tree_ssa_useless_type_conversion will eliminate casts to\n+\t sizetype from another type of the same width and signedness.  */\n+      if (TREE_TYPE (aligned_size) != sizetype)\n+\taligned_size = fold_convert_loc (loc, sizetype, aligned_size);\n+      return size_binop_loc (loc, MULT_EXPR, aligned_size,\n+\t\t\t     size_int (TYPE_ALIGN_UNIT (elmt_type)));\n+    }\n+\n+  /* Otherwise, take the size from that of the element type.  Substitute\n+     any PLACEHOLDER_EXPR that we have.  */\n+  else\n+    return SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (elmt_type), exp);\n+}\n+\n+/* Return a tree representing the lower bound of the array mentioned in\n+   EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */\n+\n+tree\n+array_ref_low_bound (tree exp)\n+{\n+  tree domain_type = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\n+  /* If a lower bound is specified in EXP, use it.  */\n+  if (TREE_OPERAND (exp, 2))\n+    return TREE_OPERAND (exp, 2);\n+\n+  /* Otherwise, if there is a domain type and it has a lower bound, use it,\n+     substituting for a PLACEHOLDER_EXPR as needed.  */\n+  if (domain_type && TYPE_MIN_VALUE (domain_type))\n+    return SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_MIN_VALUE (domain_type), exp);\n+\n+  /* Otherwise, return a zero of the appropriate type.  */\n+  return build_int_cst (TREE_TYPE (TREE_OPERAND (exp, 1)), 0);\n+}\n+\n+/* Return a tree representing the upper bound of the array mentioned in\n+   EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */\n+\n+tree\n+array_ref_up_bound (tree exp)\n+{\n+  tree domain_type = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\n+  /* If there is a domain type and it has an upper bound, use it, substituting\n+     for a PLACEHOLDER_EXPR as needed.  */\n+  if (domain_type && TYPE_MAX_VALUE (domain_type))\n+    return SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_MAX_VALUE (domain_type), exp);\n+\n+  /* Otherwise fail.  */\n+  return NULL_TREE;\n+}\n+\n+/* Returns true if REF is an array reference to an array at the end of\n+   a structure.  If this is the case, the array may be allocated larger\n+   than its upper bound implies.  */\n+\n+bool\n+array_at_struct_end_p (tree ref)\n+{\n+  if (TREE_CODE (ref) != ARRAY_REF\n+      && TREE_CODE (ref) != ARRAY_RANGE_REF)\n+    return false;\n+\n+  while (handled_component_p (ref))\n+    {\n+      /* If the reference chain contains a component reference to a\n+         non-union type and there follows another field the reference\n+\t is not at the end of a structure.  */\n+      if (TREE_CODE (ref) == COMPONENT_REF\n+\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (ref, 0))) == RECORD_TYPE)\n+\t{\n+\t  tree nextf = DECL_CHAIN (TREE_OPERAND (ref, 1));\n+\t  while (nextf && TREE_CODE (nextf) != FIELD_DECL)\n+\t    nextf = DECL_CHAIN (nextf);\n+\t  if (nextf)\n+\t    return false;\n+\t}\n+\n+      ref = TREE_OPERAND (ref, 0);\n+    }\n+\n+  /* If the reference is based on a declared entity, the size of the array\n+     is constrained by its given domain.  */\n+  if (DECL_P (ref))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return a tree representing the offset, in bytes, of the field referenced\n+   by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */\n+\n+tree\n+component_ref_field_offset (tree exp)\n+{\n+  tree aligned_offset = TREE_OPERAND (exp, 2);\n+  tree field = TREE_OPERAND (exp, 1);\n+  location_t loc = EXPR_LOCATION (exp);\n+\n+  /* If an offset was specified in the COMPONENT_REF, it's the offset measured\n+     in units of DECL_OFFSET_ALIGN / BITS_PER_UNIT.  So multiply by that\n+     value.  */\n+  if (aligned_offset)\n+    {\n+      /* ??? tree_ssa_useless_type_conversion will eliminate casts to\n+\t sizetype from another type of the same width and signedness.  */\n+      if (TREE_TYPE (aligned_offset) != sizetype)\n+\taligned_offset = fold_convert_loc (loc, sizetype, aligned_offset);\n+      return size_binop_loc (loc, MULT_EXPR, aligned_offset,\n+\t\t\t     size_int (DECL_OFFSET_ALIGN (field)\n+\t\t\t\t       / BITS_PER_UNIT));\n+    }\n+\n+  /* Otherwise, take the offset from that of the field.  Substitute\n+     any PLACEHOLDER_EXPR that we have.  */\n+  else\n+    return SUBSTITUTE_PLACEHOLDER_IN_EXPR (DECL_FIELD_OFFSET (field), exp);\n+}\n+\n /* Return the machine mode of T.  For vectors, returns the mode of the\n    inner type.  The main use case is to feed the result to HONOR_NANS,\n    avoiding the BLKmode that a direct TYPE_MODE (T) might return.  */"}, {"sha": "732a61c21319d39d23159dc47d6233c78aa02f4a", "filename": "gcc/tree.h", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8974754f6f12f2f032d4122b06d26319545ced00/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8974754f6f12f2f032d4122b06d26319545ced00/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8974754f6f12f2f032d4122b06d26319545ced00", "patch": "@@ -4564,8 +4564,34 @@ extern tree walk_tree_without_duplicates_1 (tree*, walk_tree_fn, void*,\n #define walk_tree_without_duplicates(a,b,c) \\\n \twalk_tree_without_duplicates_1 (a, b, c, NULL)\n \n-extern tree get_base_address (tree t);\n extern tree drop_tree_overflow (tree);\n+\n+/* Given a memory reference expression T, return its base address.\n+   The base address of a memory reference expression is the main\n+   object being referenced.  */\n+extern tree get_base_address (tree t);\n+\n+/* Return a tree of sizetype representing the size, in bytes, of the element\n+   of EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */\n+extern tree array_ref_element_size (tree);\n+\n+/* Return a tree representing the upper bound of the array mentioned in\n+   EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */\n+extern tree array_ref_up_bound (tree);\n+\n+/* Return a tree representing the lower bound of the array mentioned in\n+   EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */\n+extern tree array_ref_low_bound (tree);\n+\n+/* Returns true if REF is an array reference to an array at the end of\n+   a structure.  If this is the case, the array may be allocated larger\n+   than its upper bound implies.  */\n+extern bool array_at_struct_end_p (tree);\n+\n+/* Return a tree representing the offset, in bytes, of the field referenced\n+   by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */\n+extern tree component_ref_field_offset (tree);\n+\n extern int tree_map_base_eq (const void *, const void *);\n extern unsigned int tree_map_base_hash (const void *);\n extern int tree_map_base_marked_p (const void *);\n@@ -5052,23 +5078,14 @@ tree_int_cst_compare (const_tree t1, const_tree t2)\n extern void set_decl_rtl (tree, rtx);\n extern bool complete_ctor_at_level_p (const_tree, HOST_WIDE_INT, const_tree);\n \n-/* Return a tree representing the upper bound of the array mentioned in\n-   EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */\n-extern tree array_ref_up_bound (tree);\n-\n-extern tree build_personality_function (const char *);\n-\n /* Given an expression EXP that is a handled_component_p,\n    look for the ultimate containing object, which is returned and specify\n    the access position and size.  */\n extern tree get_inner_reference (tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n \t\t\t\t tree *, machine_mode *, int *, int *,\n \t\t\t\t bool);\n \n-/* Return a tree representing the lower bound of the array mentioned in\n-   EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */\n-extern tree array_ref_low_bound (tree);\n-\n+extern tree build_personality_function (const char *);\n \n struct GTY(()) int_n_trees_t {\n   /* These parts are initialized at runtime */"}]}