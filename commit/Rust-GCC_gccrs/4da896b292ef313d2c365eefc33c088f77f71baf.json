{"sha": "4da896b292ef313d2c365eefc33c088f77f71baf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRhODk2YjI5MmVmMzEzZDJjMzY1ZWVmYzMzYzA4OGY3N2Y3MWJhZg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-08T04:56:18Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-08T04:56:18Z"}, "message": "cse.c (delete_trivially_dead_insns): Replace alloca with xmalloc/xcalloc.\n\n\t* cse.c (delete_trivially_dead_insns): Replace alloca with\n\txmalloc/xcalloc.\n\t* except.c (update_rethrow_references): Likewise.\n\t(init_eh_nesting_info): Likewise.\n\t* function.c (identify_blocks): Likewise.\n\t* gcse.c (dump_hash_table): Likewise.\n\t* graph.c (print_rtl_graph_with_bb): Likewise.\n\t* loop.c (combine_movables): Likewise.\n\t(move_movables): Likewise.\n\t(count_loop_regs_set): Likewise.\n\t(strength_reduce): Likewise.\n\t* profile.c (compute_branch_probabilities): New function, split\n\tout from ...\n\t(branch_prob): Here.  Replace alloca with xmalloc/xcalloc.\n\t* regclass.c (regclass): Likewise.\n\t* regmove.c (regmove_optimize): Likewise.\n\t* toplev.c (compile_file): Likewise.\n\t(main): Don't mess with the stack rlimit.\n\nFrom-SVN: r30445", "tree": {"sha": "208424c6ec3b805174618dc54704dbe65bd2d6fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/208424c6ec3b805174618dc54704dbe65bd2d6fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4da896b292ef313d2c365eefc33c088f77f71baf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4da896b292ef313d2c365eefc33c088f77f71baf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4da896b292ef313d2c365eefc33c088f77f71baf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4da896b292ef313d2c365eefc33c088f77f71baf/comments", "author": null, "committer": null, "parents": [{"sha": "8d170590175c07873ad68a42c5cc98457edba4d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d170590175c07873ad68a42c5cc98457edba4d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d170590175c07873ad68a42c5cc98457edba4d9"}], "stats": {"total": 831, "additions": 449, "deletions": 382}, "files": [{"sha": "417fc38eb8ba063c97e53063f1c42a06562c5e63", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4da896b292ef313d2c365eefc33c088f77f71baf", "patch": "@@ -1,3 +1,24 @@\n+Sun Nov  7 20:55:14 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cse.c (delete_trivially_dead_insns): Replace alloca with\n+\txmalloc/xcalloc.\n+\t* except.c (update_rethrow_references): Likewise.\n+\t(init_eh_nesting_info): Likewise.\n+\t* function.c (identify_blocks): Likewise.\n+\t* gcse.c (dump_hash_table): Likewise.\n+\t* graph.c (print_rtl_graph_with_bb): Likewise.\n+\t* loop.c (combine_movables): Likewise.\n+\t(move_movables): Likewise.\n+\t(count_loop_regs_set): Likewise.\n+\t(strength_reduce): Likewise.\n+\t* profile.c (compute_branch_probabilities): New function, split\n+\tout from ...\n+\t(branch_prob): Here.  Replace alloca with xmalloc/xcalloc.\n+\t* regclass.c (regclass): Likewise.\n+\t* regmove.c (regmove_optimize): Likewise.\n+\t* toplev.c (compile_file): Likewise.\n+\t(main): Don't mess with the stack rlimit.\n+\t\n Sun Nov  7 19:41:17 1999  Catherine Moore  <clm@cygnus.com>\n \n         * config/elfos.h (ASM_DECLARE_FUNCTION_NAME): Conditionally define."}, {"sha": "2071bd2aef57318f81e83a0c07d684fffbaa76c1", "filename": "gcc/cse.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=4da896b292ef313d2c365eefc33c088f77f71baf", "patch": "@@ -7364,7 +7364,7 @@ delete_trivially_dead_insns (insns, nreg)\n      rtx insns;\n      int nreg;\n {\n-  int *counts = (int *) alloca (nreg * sizeof (int));\n+  int *counts;\n   rtx insn, prev;\n #ifdef HAVE_cc0\n   rtx tem;\n@@ -7373,7 +7373,7 @@ delete_trivially_dead_insns (insns, nreg)\n   int in_libcall = 0, dead_libcall = 0;\n \n   /* First count the number of times each register is used.  */\n-  bzero ((char *) counts, sizeof (int) * nreg);\n+  counts = (int *) xcalloc (nreg, sizeof (int));\n   for (insn = next_real_insn (insns); insn; insn = next_real_insn (insn))\n     count_reg_usage (insn, counts, NULL_RTX, 1);\n \n@@ -7508,4 +7508,7 @@ delete_trivially_dead_insns (insns, nreg)\n \t  dead_libcall = 0;\n \t}\n     }\n+\n+  /* Clean up.  */\n+  free (counts);\n }"}, {"sha": "15bd28d8d131959348a6ebfcf9ca4f88b5cb90e6", "filename": "gcc/except.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=4da896b292ef313d2c365eefc33c088f77f71baf", "patch": "@@ -2703,10 +2703,8 @@ update_rethrow_references ()\n   if (!flag_new_exceptions)\n     return;\n \n-  saw_region = (int *) alloca (current_func_eh_entry * sizeof (int));\n-  saw_rethrow = (int *) alloca (current_func_eh_entry * sizeof (int));\n-  bzero ((char *) saw_region, (current_func_eh_entry * sizeof (int)));\n-  bzero ((char *) saw_rethrow, (current_func_eh_entry * sizeof (int)));\n+  saw_region = (int *) xcalloc (current_func_eh_entry, sizeof (int));\n+  saw_rethrow = (int *) xcalloc (current_func_eh_entry, sizeof (int));\n \n   /* Determine what regions exist, and whether there are any rethrows\n      to those regions or not.  */\n@@ -2735,6 +2733,10 @@ update_rethrow_references ()\n   for (x = 0; x < current_func_eh_entry; x++)\n     if (saw_region[x])\n       function_eh_regions[x].rethrow_ref = saw_rethrow[x];\n+\n+  /* Clean up.  */\n+  free (saw_region);\n+  free (saw_rethrow);\n }\n \f\n /* Various hooks for the DWARF 2 __throw routine.  */\n@@ -3155,9 +3157,7 @@ init_eh_nesting_info ()\n \n   info = (eh_nesting_info *) xmalloc (sizeof (eh_nesting_info));\n   info->region_index = (int *) xcalloc ((max_label_num () + 1), sizeof (int));\n-\n-  nested_eh_region = (int *) alloca ((max_label_num () + 1) * sizeof (int));\n-  bzero ((char *) nested_eh_region, (max_label_num () + 1) * sizeof (int));\n+  nested_eh_region = (int *) xcalloc (max_label_num () + 1, sizeof (int));\n \n   /* Create the nested_eh_region list.  If indexed with a block number, it \n      returns the block number of the next outermost region, if any. \n@@ -3189,6 +3189,7 @@ init_eh_nesting_info ()\n     {\n       free (info->region_index);\n       free (info);\n+      free (nested_eh_region);\n       return NULL;\n     }\n \n@@ -3205,6 +3206,10 @@ init_eh_nesting_info ()\n \tprocess_nestinfo (x, info, nested_eh_region);\n     }\n   info->region_count = region_count;\n+\n+  /* Clean up.  */\n+  free (nested_eh_region);\n+\n   return info;\n }\n "}, {"sha": "edf979fa2adb57e78721ccd4435a978397310bc8", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=4da896b292ef313d2c365eefc33c088f77f71baf", "patch": "@@ -5558,7 +5558,7 @@ identify_blocks (block, insns)\n   block_vector = (tree *) xmalloc (n_blocks * sizeof (tree));\n   all_blocks (block, block_vector);\n \n-  block_stack = (tree *) alloca (n_blocks * sizeof (tree));\n+  block_stack = (tree *) xmalloc (n_blocks * sizeof (tree));\n \n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == NOTE)\n@@ -5594,6 +5594,7 @@ identify_blocks (block, insns)\n     abort ();\n \n   free (block_vector);\n+  free (block_stack);\n }\n \n /* Given a revised instruction chain, rebuild the tree structure of"}, {"sha": "6aace8f4edcef3397bf330cfbabe33d7796c7de8", "filename": "gcc/gcse.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=4da896b292ef313d2c365eefc33c088f77f71baf", "patch": "@@ -2067,10 +2067,13 @@ dump_hash_table (file, name, table, table_size, total_size)\n {\n   int i;\n   /* Flattened out table, so it's printed in proper order.  */\n-  struct expr **flat_table = (struct expr **) alloca (total_size * sizeof (struct expr *));\n-  unsigned int *hash_val = (unsigned int *) alloca (total_size * sizeof (unsigned int));\n+  struct expr **flat_table;\n+  unsigned int *hash_val;\n+\n+  flat_table \n+    = (struct expr **) xcalloc (total_size, sizeof (struct expr *));\n+  hash_val = (unsigned int *) xmalloc (total_size * sizeof (unsigned int));\n \n-  bzero ((char *) flat_table, total_size * sizeof (struct expr *));\n   for (i = 0; i < table_size; i++)\n     {\n       struct expr *expr;\n@@ -2096,6 +2099,10 @@ dump_hash_table (file, name, table, table_size, total_size)\n     }\n \n   fprintf (file, \"\\n\");\n+\n+  /* Clean up.  */\n+  free (flat_table);\n+  free (hash_val);\n }\n \n /* Record register first/last/block set information for REGNO in INSN."}, {"sha": "705cbd301e2f63de47fb204c3a13a19c908e13e5", "filename": "gcc/graph.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=4da896b292ef313d2c365eefc33c088f77f71baf", "patch": "@@ -284,10 +284,10 @@ print_rtl_graph_with_bb (base, suffix, rtx_first)\n       int i;\n       enum bb_state { NOT_IN_BB, IN_ONE_BB, IN_MULTIPLE_BB };\n       int max_uid = get_max_uid ();\n-      int *start = (int *) alloca (max_uid * sizeof (int));\n-      int *end = (int *) alloca (max_uid * sizeof (int));\n+      int *start = (int *) xmalloc (max_uid * sizeof (int));\n+      int *end = (int *) xmalloc (max_uid * sizeof (int));\n       enum bb_state *in_bb_p = (enum bb_state *)\n-\talloca (max_uid * sizeof (enum bb_state));\n+\txmalloc (max_uid * sizeof (enum bb_state));\n       basic_block bb;\n \n       for (i = 0; i < max_uid; ++i)\n@@ -410,6 +410,11 @@ print_rtl_graph_with_bb (base, suffix, rtx_first)\n       dump_for_graph = 0;\n \n       end_fct (fp);\n+\n+      /* Clean up.  */\n+      free (start);\n+      free (end);\n+      free (in_bb_p);\n     }\n \n   fclose (fp);"}, {"sha": "3f61671a9aa13f14ab40d7e33ba8eceeef3af923", "filename": "gcc/loop.c", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=4da896b292ef313d2c365eefc33c088f77f71baf", "patch": "@@ -1449,7 +1449,7 @@ combine_movables (movables, nregs)\n      int nregs;\n {\n   register struct movable *m;\n-  char *matched_regs = (char *) alloca (nregs);\n+  char *matched_regs = (char *) xmalloc (nregs);\n   enum machine_mode mode;\n \n   /* Regs that are set more than once are not allowed to match\n@@ -1552,6 +1552,9 @@ combine_movables (movables, nregs)\n \t  overlap: ;\n \t  }\n     }\n+\n+  /* Clean up.  */\n+  free (matched_regs);\n }\n \f\n /* Return 1 if regs X and Y will become the same if moved.  */\n@@ -1753,11 +1756,8 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n   /* Map of pseudo-register replacements to handle combining\n      when we move several insns that load the same value\n      into different pseudo-registers.  */\n-  rtx *reg_map = (rtx *) alloca (nregs * sizeof (rtx));\n-  char *already_moved = (char *) alloca (nregs);\n-\n-  bzero (already_moved, nregs);\n-  bzero ((char *) reg_map, nregs * sizeof (rtx));\n+  rtx *reg_map = (rtx *) xcalloc (nregs, sizeof (rtx));\n+  char *already_moved = (char *) xcalloc (nregs, sizeof (char));\n \n   num_movables = 0;\n \n@@ -2240,6 +2240,10 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \treplace_regs (REG_NOTES (p), reg_map, nregs, 0);\n \tINSN_CODE (p) = -1;\n       }\n+\n+  /* Clean up.  */\n+  free (reg_map);\n+  free (already_moved);\n }\n \f\n #if 0\n@@ -3580,11 +3584,10 @@ count_loop_regs_set (from, to, may_not_move, single_usage, count_ptr, nregs)\n      int *count_ptr;\n      int nregs;\n {\n-  register rtx *last_set = (rtx *) alloca (nregs * sizeof (rtx));\n+  register rtx *last_set = (rtx *) xcalloc (nregs, sizeof (rtx));\n   register rtx insn;\n   register int count = 0;\n \n-  bzero ((char *) last_set, nregs * sizeof (rtx));\n   for (insn = from; insn != to; insn = NEXT_INSN (insn))\n     {\n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n@@ -3614,6 +3617,9 @@ count_loop_regs_set (from, to, may_not_move, single_usage, count_ptr, nregs)\n \tbzero ((char *) last_set, nregs * sizeof (rtx));\n     }\n   *count_ptr = count;\n+\n+  /* Clean up.  */\n+  free (last_set);\n }\n \f\n /* Given a loop that is bounded by LOOP_START and LOOP_END\n@@ -3770,7 +3776,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   /* ??? could set this to last value of threshold in move_movables */\n   int threshold = (loop_info->has_call ? 1 : 2) * (3 + n_non_fixed_regs);\n   /* Map of pseudo-register replacements.  */\n-  rtx *reg_map;\n+  rtx *reg_map = NULL;\n   int reg_map_size;\n   int call_seen;\n   rtx test;\n@@ -3787,9 +3793,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   VARRAY_INT_INIT (reg_iv_type, max_reg_before_loop, \"reg_iv_type\");\n   VARRAY_GENERIC_PTR_INIT (reg_iv_info, max_reg_before_loop, \"reg_iv_info\");\n   reg_biv_class = (struct iv_class **)\n-    alloca (max_reg_before_loop * sizeof (struct iv_class *));\n-  bzero ((char *) reg_biv_class, (max_reg_before_loop\n-\t\t\t\t  * sizeof (struct iv_class *)));\n+    xcalloc (max_reg_before_loop, sizeof (struct iv_class *));\n \n   loop_iv_list = 0;\n   addr_placeholder = gen_reg_rtx (Pmode);\n@@ -4676,8 +4680,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n      Some givs might have been made from biv increments, so look at\n      reg_iv_type for a suitable size.  */\n   reg_map_size = reg_iv_type->num_elements;\n-  reg_map = (rtx *) alloca (reg_map_size * sizeof (rtx));\n-  bzero ((char *) reg_map, reg_map_size * sizeof (rtx));\n+  reg_map = (rtx *) xcalloc (reg_map_size, sizeof (rtx));\n \n   /* Examine each iv class for feasibility of strength reduction/induction\n      variable elimination.  */\n@@ -5300,6 +5303,9 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n egress:\n   VARRAY_FREE (reg_iv_type);\n   VARRAY_FREE (reg_iv_info);\n+  free (reg_biv_class);\n+  if (reg_map)\n+    free (reg_map);\n }\n \f\n /* Return 1 if X is a valid source for an initial value (or as value being"}, {"sha": "1e8bdf2f9d09edab1788b5164d797f37c5bddbf0", "filename": "gcc/profile.c", "status": "modified", "additions": 355, "deletions": 335, "changes": 690, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=4da896b292ef313d2c365eefc33c088f77f71baf", "patch": "@@ -160,6 +160,7 @@ static void output_arc_profiler PROTO((int, rtx));\n static void instrument_arcs PROTO((rtx, int, FILE *));\n static void output_gcov_string PROTO((const char *, long));\n static int tablejump_entry_p PROTO((rtx, rtx));\n+static void compute_branch_probabilities PROTO((int, FILE *));\n \n #ifndef LONG_TYPE_SIZE\n #define LONG_TYPE_SIZE BITS_PER_WORD\n@@ -437,6 +438,293 @@ tablejump_entry_p (insn, label)\n   return 0;\n }\n \n+/* Compute the branch probabilities for the various branches.\n+   Annotate them accordingly.  */\n+\n+static void\n+compute_branch_probabilities (num_blocks, dump_file)\n+     int num_blocks;\n+     FILE *dump_file;\n+{\n+  int i;\n+  int bad_counts = 0;\n+  int num_arcs;\n+  int changes;\n+  int passes;\n+  int prob;\n+  int total;\n+  int num_branches;\n+  int num_never_executed;\n+  int hist_br_prob[20];\n+  struct adj_list *arcptr;\n+\n+  /* For each arc not on the spanning tree, set its execution count from\n+     the .da file.  */\n+\n+  /* The first count in the .da file is the number of times that the function\n+     was entered.  This is the exec_count for block zero.  */\n+\n+  num_arcs = 0;\n+  for (i = 0; i < num_blocks; i++)\n+    for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n+      if (! arcptr->on_tree)\n+\t{\n+\t  num_arcs++;\n+\t  if (da_file)\n+\t    {\n+\t      long value;\n+\t      __read_long (&value, da_file, 8);\n+\t      ARC_COUNT (arcptr) = value;\n+\t    }\n+\t  else\n+\t    ARC_COUNT (arcptr) = 0;\n+\t  arcptr->count_valid = 1;\n+\t  bb_graph[i].succ_count--;\n+\t  bb_graph[ARC_TARGET (arcptr)].pred_count--;\n+\t}\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"%d arc counts read\\n\", num_arcs);\n+\n+  /* For every block in the file,\n+     - if every exit/entrance arc has a known count, then set the block count\n+     - if the block count is known, and every exit/entrance arc but one has\n+       a known execution count, then set the count of the remaining arc\n+\n+     As arc counts are set, decrement the succ/pred count, but don't delete\n+     the arc, that way we can easily tell when all arcs are known, or only\n+     one arc is unknown.  */\n+\n+  /* The order that the basic blocks are iterated through is important.\n+     Since the code that finds spanning trees starts with block 0, low numbered\n+     arcs are put on the spanning tree in preference to high numbered arcs.\n+     Hence, most instrumented arcs are at the end.  Graph solving works much\n+     faster if we propagate numbers from the end to the start.\n+     \n+     This takes an average of slightly more than 3 passes.  */\n+\n+  changes = 1;\n+  passes = 0;\n+  while (changes)\n+    {\n+      passes++;\n+      changes = 0;\n+\n+      for (i = num_blocks - 1; i >= 0; i--)\n+\t{\n+\t  struct bb_info *binfo = &bb_graph[i];\n+\t  if (! binfo->count_valid)\n+\t    {\n+\t      if (binfo->succ_count == 0)\n+\t\t{\n+\t\t  total = 0;\n+\t\t  for (arcptr = binfo->succ; arcptr;\n+\t\t       arcptr = arcptr->succ_next)\n+\t\t    total += ARC_COUNT (arcptr);\n+\t\t  binfo->exec_count = total;\n+\t\t  binfo->count_valid = 1;\n+\t\t  changes = 1;\n+\t\t}\n+\t      else if (binfo->pred_count == 0)\n+\t\t{\n+\t\t  total = 0;\n+\t\t  for (arcptr = binfo->pred; arcptr;\n+\t\t       arcptr = arcptr->pred_next)\n+\t\t    total += ARC_COUNT (arcptr);\n+\t\t  binfo->exec_count = total;\n+\t\t  binfo->count_valid = 1;\n+\t\t  changes = 1;\n+\t\t}\n+\t    }\n+\t  if (binfo->count_valid)\n+\t    {\n+\t      if (binfo->succ_count == 1)\n+\t\t{\n+\t\t  total = 0;\n+\t\t  /* One of the counts will be invalid, but it is zero,\n+\t\t     so adding it in also doesn't hurt.  */\n+\t\t  for (arcptr = binfo->succ; arcptr;\n+\t\t       arcptr = arcptr->succ_next)\n+\t\t    total += ARC_COUNT (arcptr);\n+\t\t  /* Calculate count for remaining arc by conservation.  */\n+\t\t  total = binfo->exec_count - total;\n+\t\t  /* Search for the invalid arc, and set its count.  */\n+\t\t  for (arcptr = binfo->succ; arcptr;\n+\t\t       arcptr = arcptr->succ_next)\n+\t\t    if (! arcptr->count_valid)\n+\t\t      break;\n+\t\t  if (! arcptr)\n+\t\t    abort ();\n+\t\t  arcptr->count_valid = 1;\n+\t\t  ARC_COUNT (arcptr) = total;\n+\t\t  binfo->succ_count--;\n+\t\t  \n+\t\t  bb_graph[ARC_TARGET (arcptr)].pred_count--;\n+\t\t  changes = 1;\n+\t\t}\n+\t      if (binfo->pred_count == 1)\n+\t\t{\n+\t\t  total = 0;\n+\t\t  /* One of the counts will be invalid, but it is zero,\n+\t\t     so adding it in also doesn't hurt.  */\n+\t\t  for (arcptr = binfo->pred; arcptr;\n+\t\t       arcptr = arcptr->pred_next)\n+\t\t    total += ARC_COUNT (arcptr);\n+\t\t  /* Calculate count for remaining arc by conservation.  */\n+\t\t  total = binfo->exec_count - total;\n+\t\t  /* Search for the invalid arc, and set its count.  */\n+\t\t  for (arcptr = binfo->pred; arcptr;\n+\t\t       arcptr = arcptr->pred_next)\n+\t\t    if (! arcptr->count_valid)\n+\t\t      break;\n+\t\t  if (! arcptr)\n+\t\t    abort ();\n+\t\t  arcptr->count_valid = 1;\n+\t\t  ARC_COUNT (arcptr) = total;\n+\t\t  binfo->pred_count--;\n+\t\t  \n+\t\t  bb_graph[ARC_SOURCE (arcptr)].succ_count--;\n+\t\t  changes = 1;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  total_num_passes += passes;\n+  if (dump_file)\n+    fprintf (dump_file, \"Graph solving took %d passes.\\n\\n\", passes);\n+\n+  /* If the graph has been correctly solved, every block will have a\n+     succ and pred count of zero.  */\n+  for (i = 0; i < num_blocks; i++)\n+    {\n+      struct bb_info *binfo = &bb_graph[i];\n+      if (binfo->succ_count || binfo->pred_count)\n+\tabort ();\n+    }\n+\n+  /* For every arc, calculate its branch probability and add a reg_note\n+     to the branch insn to indicate this.  */\n+\n+  for (i = 0; i < 20; i++)\n+    hist_br_prob[i] = 0;\n+  num_never_executed = 0;\n+  num_branches = 0;\n+\n+  for (i = 0; i < num_blocks; i++)\n+    {\n+      struct bb_info *binfo = &bb_graph[i];\n+\n+      total = binfo->exec_count;\n+      for (arcptr = binfo->succ; arcptr; arcptr = arcptr->succ_next)\n+\t{\n+\t  if (arcptr->branch_insn)\n+\t    {\n+\t      /* This calculates the branch probability as an integer between\n+\t\t 0 and REG_BR_PROB_BASE, properly rounded to the nearest\n+\t\t integer.  Perform the arithmetic in double to avoid\n+\t\t overflowing the range of ints.  */\n+\n+\t      if (total == 0)\n+\t\tprob = -1;\n+\t      else\n+\t\t{\n+\t\t  rtx pat = PATTERN (arcptr->branch_insn);\n+\t\t  \n+\t\t  prob = (((double)ARC_COUNT (arcptr) * REG_BR_PROB_BASE)\n+\t\t\t  + (total >> 1)) / total;\n+\t\t  if (prob < 0 || prob > REG_BR_PROB_BASE)\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"bad count: prob for %d-%d thought to be %d (forcibly normalized)\\n\",\n+\t\t\t\t ARC_SOURCE (arcptr), ARC_TARGET (arcptr),\n+\t\t\t\t prob);\n+\n+\t\t      bad_counts = 1;\n+\t\t      prob = REG_BR_PROB_BASE / 2;\n+\t\t    }\n+\t\t  \n+\t\t  /* Match up probability with JUMP pattern.  */\n+\n+\t\t  if (GET_CODE (pat) == SET\n+\t\t      && GET_CODE (SET_SRC (pat)) == IF_THEN_ELSE)\n+\t\t    {\n+\t\t      if (ARC_TARGET (arcptr) == ARC_SOURCE (arcptr) + 1)\n+\t\t\t{\n+\t\t\t  /* A fall through arc should never have a\n+\t\t\t     branch insn.  */\n+\t\t\t  abort ();\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  /* This is the arc for the taken branch.  */\n+\t\t\t  if (GET_CODE (XEXP (SET_SRC (pat), 2)) != PC)\n+\t\t\t    prob = REG_BR_PROB_BASE - prob;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      \n+\t      if (prob == -1)\n+\t\tnum_never_executed++;\n+\t      else\n+\t\t{\n+\t\t  int index = prob * 20 / REG_BR_PROB_BASE;\n+\t\t  if (index == 20)\n+\t\t    index = 19;\n+\t\t  hist_br_prob[index]++;\n+\t\t}\n+\t      num_branches++;\n+\t      \n+\t      REG_NOTES (arcptr->branch_insn)\n+\t\t= gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (prob),\n+\t\t\t\t     REG_NOTES (arcptr->branch_insn));\n+\t    }\n+\t}\n+\n+      /* Add a REG_EXEC_COUNT note to the first instruction of this block.  */\n+      if (! binfo->first_insn \n+\t  || GET_RTX_CLASS (GET_CODE (binfo->first_insn)) != 'i')\n+\t{\n+\t  /* Block 0 is a fake block representing function entry, and does\n+\t     not have a real first insn.  The second last block might not\n+\t     begin with a real insn.  */\n+\t  if (i == num_blocks - 1)\n+\t    return_label_execution_count = total;\n+\t  else if (i != 0 && i != num_blocks - 2)\n+\t    abort ();\n+\t}\n+      else\n+\t{\n+\t  REG_NOTES (binfo->first_insn)\n+\t    = gen_rtx_EXPR_LIST (REG_EXEC_COUNT, GEN_INT (total),\n+\t\t\t\t REG_NOTES (binfo->first_insn));\n+\t  if (i == num_blocks - 1)\n+\t    return_label_execution_count = total;\n+\t}\n+    }\n+  \n+  /* This should never happen.  */\n+  if (bad_counts)\n+    warning (\"Arc profiling: some arc counts were bad.\");\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"%d branches\\n\", num_branches);\n+      fprintf (dump_file, \"%d branches never executed\\n\",\n+\t       num_never_executed);\n+      if (num_branches)\n+\tfor (i = 0; i < 10; i++)\n+\t  fprintf (dump_file, \"%d%% branches in range %d-%d%%\\n\",\n+\t\t   (hist_br_prob[i]+hist_br_prob[19-i])*100/num_branches,\n+\t\t   5*i, 5*i+5);\n+\n+      total_num_branches += num_branches;\n+      total_num_never_executed += num_never_executed;\n+      for (i = 0; i < 20; i++)\n+\ttotal_hist_br_prob[i] += hist_br_prob[i];\n+    }\n+}\n+\n /* Instrument and/or analyze program behavior based on program flow graph.\n    In either case, this function builds a flow graph for the function being\n    compiled.  The flow graph is stored in BB_GRAPH.\n@@ -460,11 +748,7 @@ branch_prob (f, dump_file)\n {\n   int i, num_blocks;\n   struct adj_list *arcptr;\n-  int num_arcs, changes, passes;\n-  int total, prob;\n-  int hist_br_prob[20], num_never_executed, num_branches;\n-  /* Set to non-zero if we got bad count information.  */\n-  int bad_counts = 0;\n+  int num_arcs;\n \n   /* start of a function.  */\n   if (flag_test_coverage)\n@@ -620,8 +904,8 @@ branch_prob (f, dump_file)\n   /* Create and initialize the arrays that will hold bb_graph\n      and execution count info.  */\n \n-  bb_graph = (struct bb_info *) alloca (num_blocks * sizeof (struct bb_info));\n-  bzero ((char *) bb_graph, (sizeof (struct bb_info) * num_blocks));\n+  bb_graph = (struct bb_info *) xcalloc (num_blocks, \n+\t\t\t\t\t sizeof (struct bb_info));\n \n   {\n     /* Scan the insns again:\n@@ -886,354 +1170,90 @@ branch_prob (f, dump_file)\n \t    num_arcs++;\n \t  }\n \t  \n-\t/* This may not be a real insn, but that should not cause a problem.  */\n-\tbb_graph[i+1].first_insn = get_last_insn ();\n-      }\n-\n-    /* There is always a fake arc from the last block of the function\n-       to the function exit block.  */\n-    arcptr = (struct adj_list *) alloca (sizeof (struct adj_list));\n-    init_arc (arcptr, num_blocks-2, num_blocks-1, 0);\n-    arcptr->fake = 1;\n-    num_arcs++;\n-  }\n-\n-  total_num_arcs += num_arcs;\n-  if (dump_file)\n-    fprintf (dump_file, \"%d arcs\\n\", num_arcs);\n-\n-  /* Create spanning tree from basic block graph, mark each arc that is\n-     on the spanning tree.  */\n-\n-  /* To reduce the instrumentation cost, make two passes over the tree.\n-     First, put as many must-split (crowded and fake) arcs on the tree as\n-     possible, then on the second pass fill in the rest of the tree.\n-     Note that the spanning tree is considered undirected, so that as many\n-     must-split arcs as possible can be put on it.\n-\n-     Fallthrough arcs which are crowded should not be chosen on the first\n-     pass, since they do not require creating a new basic block.  These\n-     arcs will have fall_through set.  */\n-\n-  find_spanning_tree (num_blocks);\n-\n-  /* Create a .bbg file from which gcov can reconstruct the basic block\n-     graph.  First output the number of basic blocks, and then for every\n-     arc output the source and target basic block numbers.\n-     NOTE: The format of this file must be compatible with gcov.  */\n-\n-  if (flag_test_coverage)\n-    {\n-      int flag_bits;\n-\n-      __write_long (num_blocks, bbg_file, 4);\n-      __write_long (num_arcs, bbg_file, 4);\n-\n-      for (i = 0; i < num_blocks; i++)\n-\t{\n-\t  long count = 0;\n-\t  for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n-\t    count++;\n-\t  __write_long (count, bbg_file, 4);\n-\n-\t  for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n-\t    {\n-\t      flag_bits = 0;\n-\t      if (arcptr->on_tree)\n-\t\tflag_bits |= 0x1;\n-\t      if (arcptr->fake)\n-\t\tflag_bits |= 0x2;\n-\t      if (arcptr->fall_through)\n-\t\tflag_bits |= 0x4;\n-\n-\t      __write_long (ARC_TARGET (arcptr), bbg_file, 4);\n-\t      __write_long (flag_bits, bbg_file, 4);\n-\t    }\n-\t}\n-\n-      /* Emit a -1 to separate the list of all arcs from the list of\n-\t loop back edges that follows.  */\n-      __write_long (-1, bbg_file, 4);\n-    }\n-\n-  /* For each arc not on the spanning tree, add counting code as rtl.  */\n-\n-  if (profile_arc_flag)\n-    {\n-      instrument_arcs (f, num_blocks, dump_file);\n-      allocate_reg_info (max_reg_num (), FALSE, FALSE);\n-    }\n-\n-  /* Execute the rest only if doing branch probabilities.  */\n-  if (! flag_branch_probabilities)\n-    return;\n-\n-  /* For each arc not on the spanning tree, set its execution count from\n-     the .da file.  */\n-\n-  /* The first count in the .da file is the number of times that the function\n-     was entered.  This is the exec_count for block zero.  */\n-\n-  num_arcs = 0;\n-  for (i = 0; i < num_blocks; i++)\n-    for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n-      if (! arcptr->on_tree)\n-\t{\n-\t  num_arcs++;\n-\t  if (da_file)\n-\t    {\n-\t      long value;\n-\t      __read_long (&value, da_file, 8);\n-\t      ARC_COUNT (arcptr) = value;\n-\t    }\n-\t  else\n-\t    ARC_COUNT (arcptr) = 0;\n-\t  arcptr->count_valid = 1;\n-\t  bb_graph[i].succ_count--;\n-\t  bb_graph[ARC_TARGET (arcptr)].pred_count--;\n-\t}\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"%d arc counts read\\n\", num_arcs);\n-\n-  /* For every block in the file,\n-     - if every exit/entrance arc has a known count, then set the block count\n-     - if the block count is known, and every exit/entrance arc but one has\n-       a known execution count, then set the count of the remaining arc\n-\n-     As arc counts are set, decrement the succ/pred count, but don't delete\n-     the arc, that way we can easily tell when all arcs are known, or only\n-     one arc is unknown.  */\n-\n-  /* The order that the basic blocks are iterated through is important.\n-     Since the code that finds spanning trees starts with block 0, low numbered\n-     arcs are put on the spanning tree in preference to high numbered arcs.\n-     Hence, most instrumented arcs are at the end.  Graph solving works much\n-     faster if we propagate numbers from the end to the start.\n-     \n-     This takes an average of slightly more than 3 passes.  */\n-\n-  changes = 1;\n-  passes = 0;\n-  while (changes)\n-    {\n-      passes++;\n-      changes = 0;\n+\t/* This may not be a real insn, but that should not cause a problem.  */\n+\tbb_graph[i+1].first_insn = get_last_insn ();\n+      }\n \n-      for (i = num_blocks - 1; i >= 0; i--)\n-\t{\n-\t  struct bb_info *binfo = &bb_graph[i];\n-\t  if (! binfo->count_valid)\n-\t    {\n-\t      if (binfo->succ_count == 0)\n-\t\t{\n-\t\t  total = 0;\n-\t\t  for (arcptr = binfo->succ; arcptr;\n-\t\t       arcptr = arcptr->succ_next)\n-\t\t    total += ARC_COUNT (arcptr);\n-\t\t  binfo->exec_count = total;\n-\t\t  binfo->count_valid = 1;\n-\t\t  changes = 1;\n-\t\t}\n-\t      else if (binfo->pred_count == 0)\n-\t\t{\n-\t\t  total = 0;\n-\t\t  for (arcptr = binfo->pred; arcptr;\n-\t\t       arcptr = arcptr->pred_next)\n-\t\t    total += ARC_COUNT (arcptr);\n-\t\t  binfo->exec_count = total;\n-\t\t  binfo->count_valid = 1;\n-\t\t  changes = 1;\n-\t\t}\n-\t    }\n-\t  if (binfo->count_valid)\n-\t    {\n-\t      if (binfo->succ_count == 1)\n-\t\t{\n-\t\t  total = 0;\n-\t\t  /* One of the counts will be invalid, but it is zero,\n-\t\t     so adding it in also doesn't hurt.  */\n-\t\t  for (arcptr = binfo->succ; arcptr;\n-\t\t       arcptr = arcptr->succ_next)\n-\t\t    total += ARC_COUNT (arcptr);\n-\t\t  /* Calculate count for remaining arc by conservation.  */\n-\t\t  total = binfo->exec_count - total;\n-\t\t  /* Search for the invalid arc, and set its count.  */\n-\t\t  for (arcptr = binfo->succ; arcptr;\n-\t\t       arcptr = arcptr->succ_next)\n-\t\t    if (! arcptr->count_valid)\n-\t\t      break;\n-\t\t  if (! arcptr)\n-\t\t    abort ();\n-\t\t  arcptr->count_valid = 1;\n-\t\t  ARC_COUNT (arcptr) = total;\n-\t\t  binfo->succ_count--;\n-\t\t  \n-\t\t  bb_graph[ARC_TARGET (arcptr)].pred_count--;\n-\t\t  changes = 1;\n-\t\t}\n-\t      if (binfo->pred_count == 1)\n-\t\t{\n-\t\t  total = 0;\n-\t\t  /* One of the counts will be invalid, but it is zero,\n-\t\t     so adding it in also doesn't hurt.  */\n-\t\t  for (arcptr = binfo->pred; arcptr;\n-\t\t       arcptr = arcptr->pred_next)\n-\t\t    total += ARC_COUNT (arcptr);\n-\t\t  /* Calculate count for remaining arc by conservation.  */\n-\t\t  total = binfo->exec_count - total;\n-\t\t  /* Search for the invalid arc, and set its count.  */\n-\t\t  for (arcptr = binfo->pred; arcptr;\n-\t\t       arcptr = arcptr->pred_next)\n-\t\t    if (! arcptr->count_valid)\n-\t\t      break;\n-\t\t  if (! arcptr)\n-\t\t    abort ();\n-\t\t  arcptr->count_valid = 1;\n-\t\t  ARC_COUNT (arcptr) = total;\n-\t\t  binfo->pred_count--;\n-\t\t  \n-\t\t  bb_graph[ARC_SOURCE (arcptr)].succ_count--;\n-\t\t  changes = 1;\n-\t\t}\n-\t    }\n-\t}\n-    }\n+    /* There is always a fake arc from the last block of the function\n+       to the function exit block.  */\n+    arcptr = (struct adj_list *) alloca (sizeof (struct adj_list));\n+    init_arc (arcptr, num_blocks-2, num_blocks-1, 0);\n+    arcptr->fake = 1;\n+    num_arcs++;\n+  }\n \n-  total_num_passes += passes;\n+  total_num_arcs += num_arcs;\n   if (dump_file)\n-    fprintf (dump_file, \"Graph solving took %d passes.\\n\\n\", passes);\n+    fprintf (dump_file, \"%d arcs\\n\", num_arcs);\n \n-  /* If the graph has been correctly solved, every block will have a\n-     succ and pred count of zero.  */\n-  for (i = 0; i < num_blocks; i++)\n-    {\n-      struct bb_info *binfo = &bb_graph[i];\n-      if (binfo->succ_count || binfo->pred_count)\n-\tabort ();\n-    }\n+  /* Create spanning tree from basic block graph, mark each arc that is\n+     on the spanning tree.  */\n \n-  /* For every arc, calculate its branch probability and add a reg_note\n-     to the branch insn to indicate this.  */\n+  /* To reduce the instrumentation cost, make two passes over the tree.\n+     First, put as many must-split (crowded and fake) arcs on the tree as\n+     possible, then on the second pass fill in the rest of the tree.\n+     Note that the spanning tree is considered undirected, so that as many\n+     must-split arcs as possible can be put on it.\n \n-  for (i = 0; i < 20; i++)\n-    hist_br_prob[i] = 0;\n-  num_never_executed = 0;\n-  num_branches = 0;\n+     Fallthrough arcs which are crowded should not be chosen on the first\n+     pass, since they do not require creating a new basic block.  These\n+     arcs will have fall_through set.  */\n \n-  for (i = 0; i < num_blocks; i++)\n+  find_spanning_tree (num_blocks);\n+\n+  /* Create a .bbg file from which gcov can reconstruct the basic block\n+     graph.  First output the number of basic blocks, and then for every\n+     arc output the source and target basic block numbers.\n+     NOTE: The format of this file must be compatible with gcov.  */\n+\n+  if (flag_test_coverage)\n     {\n-      struct bb_info *binfo = &bb_graph[i];\n+      int flag_bits;\n \n-      total = binfo->exec_count;\n-      for (arcptr = binfo->succ; arcptr; arcptr = arcptr->succ_next)\n-\t{\n-\t  if (arcptr->branch_insn)\n-\t    {\n-\t      /* This calculates the branch probability as an integer between\n-\t\t 0 and REG_BR_PROB_BASE, properly rounded to the nearest\n-\t\t integer.  Perform the arithmetic in double to avoid\n-\t\t overflowing the range of ints.  */\n+      __write_long (num_blocks, bbg_file, 4);\n+      __write_long (num_arcs, bbg_file, 4);\n \n-\t      if (total == 0)\n-\t\tprob = -1;\n-\t      else\n-\t\t{\n-\t\t  rtx pat = PATTERN (arcptr->branch_insn);\n-\t\t  \n-\t\t  prob = (((double)ARC_COUNT (arcptr) * REG_BR_PROB_BASE)\n-\t\t\t  + (total >> 1)) / total;\n-\t\t  if (prob < 0 || prob > REG_BR_PROB_BASE)\n-\t\t    {\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file, \"bad count: prob for %d-%d thought to be %d (forcibly normalized)\\n\",\n-\t\t\t\t ARC_SOURCE (arcptr), ARC_TARGET (arcptr),\n-\t\t\t\t prob);\n+      for (i = 0; i < num_blocks; i++)\n+\t{\n+\t  long count = 0;\n+\t  for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n+\t    count++;\n+\t  __write_long (count, bbg_file, 4);\n \n-\t\t      bad_counts = 1;\n-\t\t      prob = REG_BR_PROB_BASE / 2;\n-\t\t    }\n-\t\t  \n-\t\t  /* Match up probability with JUMP pattern.  */\n+\t  for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n+\t    {\n+\t      flag_bits = 0;\n+\t      if (arcptr->on_tree)\n+\t\tflag_bits |= 0x1;\n+\t      if (arcptr->fake)\n+\t\tflag_bits |= 0x2;\n+\t      if (arcptr->fall_through)\n+\t\tflag_bits |= 0x4;\n \n-\t\t  if (GET_CODE (pat) == SET\n-\t\t      && GET_CODE (SET_SRC (pat)) == IF_THEN_ELSE)\n-\t\t    {\n-\t\t      if (ARC_TARGET (arcptr) == ARC_SOURCE (arcptr) + 1)\n-\t\t\t{\n-\t\t\t  /* A fall through arc should never have a\n-\t\t\t     branch insn.  */\n-\t\t\t  abort ();\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  /* This is the arc for the taken branch.  */\n-\t\t\t  if (GET_CODE (XEXP (SET_SRC (pat), 2)) != PC)\n-\t\t\t    prob = REG_BR_PROB_BASE - prob;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t      \n-\t      if (prob == -1)\n-\t\tnum_never_executed++;\n-\t      else\n-\t\t{\n-\t\t  int index = prob * 20 / REG_BR_PROB_BASE;\n-\t\t  if (index == 20)\n-\t\t    index = 19;\n-\t\t  hist_br_prob[index]++;\n-\t\t}\n-\t      num_branches++;\n-\t      \n-\t      REG_NOTES (arcptr->branch_insn)\n-\t\t= gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (prob),\n-\t\t\t\t     REG_NOTES (arcptr->branch_insn));\n+\t      __write_long (ARC_TARGET (arcptr), bbg_file, 4);\n+\t      __write_long (flag_bits, bbg_file, 4);\n \t    }\n \t}\n \n-      /* Add a REG_EXEC_COUNT note to the first instruction of this block.  */\n-      if (! binfo->first_insn \n-\t  || GET_RTX_CLASS (GET_CODE (binfo->first_insn)) != 'i')\n-\t{\n-\t  /* Block 0 is a fake block representing function entry, and does\n-\t     not have a real first insn.  The second last block might not\n-\t     begin with a real insn.  */\n-\t  if (i == num_blocks - 1)\n-\t    return_label_execution_count = total;\n-\t  else if (i != 0 && i != num_blocks - 2)\n-\t    abort ();\n-\t}\n-      else\n-\t{\n-\t  REG_NOTES (binfo->first_insn)\n-\t    = gen_rtx_EXPR_LIST (REG_EXEC_COUNT, GEN_INT (total),\n-\t\t\t\t REG_NOTES (binfo->first_insn));\n-\t  if (i == num_blocks - 1)\n-\t    return_label_execution_count = total;\n-\t}\n+      /* Emit a -1 to separate the list of all arcs from the list of\n+\t loop back edges that follows.  */\n+      __write_long (-1, bbg_file, 4);\n     }\n-  \n-  /* This should never happen.  */\n-  if (bad_counts)\n-    warning (\"Arc profiling: some arc counts were bad.\");\n \n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"%d branches\\n\", num_branches);\n-      fprintf (dump_file, \"%d branches never executed\\n\",\n-\t       num_never_executed);\n-      if (num_branches)\n-\tfor (i = 0; i < 10; i++)\n-\t  fprintf (dump_file, \"%d%% branches in range %d-%d%%\\n\",\n-\t\t   (hist_br_prob[i]+hist_br_prob[19-i])*100/num_branches,\n-\t\t   5*i, 5*i+5);\n+  /* For each arc not on the spanning tree, add counting code as rtl.  */\n \n-      total_num_branches += num_branches;\n-      total_num_never_executed += num_never_executed;\n-      for (i = 0; i < 20; i++)\n-\ttotal_hist_br_prob[i] += hist_br_prob[i];\n+  if (profile_arc_flag)\n+    {\n+      instrument_arcs (f, num_blocks, dump_file);\n+      allocate_reg_info (max_reg_num (), FALSE, FALSE);\n     }\n \n+  /* Execute the rest only if doing branch probabilities.  */\n+  if (flag_branch_probabilities)\n+    compute_branch_probabilities (num_blocks, dump_file);\n+\n+  /* Clean up.  */\n+  free (bb_graph);\n }\n \f\n /* Initialize a new arc."}, {"sha": "d495fdc5572d511c7603232629d96fcc8835a76a", "filename": "gcc/regclass.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=4da896b292ef313d2c365eefc33c088f77f71baf", "patch": "@@ -965,7 +965,7 @@ regclass (f, nregs)\n \n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \n-  in_inc_dec = (char *) alloca (nregs);\n+  in_inc_dec = (char *) xmalloc (nregs);\n \n   /* Initialize information about which register classes can be used for\n      pseudos that are auto-incremented or auto-decremented.  It would\n@@ -1109,6 +1109,9 @@ regclass (f, nregs)\n \t}\n     }\n \n+#ifdef FORBIDDEN_INC_DEC_CLASSES\n+  free (in_inc_dec);\n+#endif\n   free (costs);\n }\n \f"}, {"sha": "8b047ea972bdcb609eadb39738dead5e91537c19", "filename": "gcc/regmove.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=4da896b292ef313d2c365eefc33c088f77f71baf", "patch": "@@ -1099,10 +1099,10 @@ regmove_optimize (f, nregs, regmove_dump_file)\n      can supress some optimizations in those zones.  */\n   mark_flags_life_zones (discover_flags_reg ());\n \n-  regno_src_regno = (int *)alloca (sizeof *regno_src_regno * nregs);\n+  regno_src_regno = (int *) xmalloc (sizeof *regno_src_regno * nregs);\n   for (i = nregs; --i >= 0; ) regno_src_regno[i] = -1;\n \n-  regmove_bb_head = (int *)alloca (sizeof (int) * (old_max_uid + 1));\n+  regmove_bb_head = (int *) xmalloc (sizeof (int) * (old_max_uid + 1));\n   for (i = old_max_uid; i >= 0; i--) regmove_bb_head[i] = -1;\n   for (i = 0; i < n_basic_blocks; i++)\n     regmove_bb_head[INSN_UID (BLOCK_HEAD (i))] = i;\n@@ -1114,7 +1114,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n   for (pass = 0; pass <= 2; pass++)\n     {\n       if (! flag_regmove && pass >= flag_expensive_optimizations)\n-\treturn;\n+\tgoto done;\n \n       if (regmove_dump_file)\n \tfprintf (regmove_dump_file, \"Starting %s pass...\\n\",\n@@ -1574,6 +1574,11 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \tnew = next, next = NEXT_INSN (new);\n       BLOCK_END (i) = new;\n     }\n+\n+ done:\n+  /* Clean up.  */\n+  free (regno_src_regno);\n+  free (regmove_bb_head);\n }\n \n /* Returns nonzero if INSN's pattern has matching constraints for any operand."}, {"sha": "ef5a1fcdca7728e024a416ddd600e94334656b46", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da896b292ef313d2c365eefc33c088f77f71baf/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=4da896b292ef313d2c365eefc33c088f77f71baf", "patch": "@@ -3240,7 +3240,7 @@ compile_file (name)\n \n   {\n     int len = list_length (globals);\n-    tree *vec = (tree *) alloca (sizeof (tree) * len);\n+    tree *vec = (tree *) xmalloc (sizeof (tree) * len);\n     int i;\n     tree decl;\n \n@@ -3267,6 +3267,9 @@ compile_file (name)\n     output_exception_table ();\n \n     check_global_declarations (vec, len);\n+\n+    /* Clean up.  */\n+    free (vec);\n   }\n \n   /* Write out any pending weak symbol declarations.  */\n@@ -5289,18 +5292,6 @@ main (argc, argv)\n     --p;\n   progname = p;\n \n-#if defined (RLIMIT_STACK) && defined (HAVE_GETRLIMIT) && defined (HAVE_SETRLIMIT)\n-  /* Get rid of any avoidable limit on stack size.  */\n-  {\n-    struct rlimit rlim;\n-\n-    /* Set the stack limit huge so that alloca does not fail.  */\n-    getrlimit (RLIMIT_STACK, &rlim);\n-    rlim.rlim_cur = rlim.rlim_max;\n-    setrlimit (RLIMIT_STACK, &rlim);\n-  }\n-#endif\n-\n #ifdef HAVE_LC_MESSAGES\n   setlocale (LC_MESSAGES, \"\");\n #endif"}]}