{"sha": "e7d6beb0f868d4feeefea469278b4e07ec3fee8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdkNmJlYjBmODY4ZDRmZWVlZmVhNDY5Mjc4YjRlMDdlYzNmZWU4Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-06-02T10:59:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-06-02T10:59:00Z"}, "message": "cgraph.c (dump_cgraph_node): Print new flags.\n\n\n\t* cgraph.c (dump_cgraph_node): Print new flags.\n\t(dump_cgraph_varpool_node): Likewise.\n\t(decide_variable_is_needed): Initialize externally_visible flag.\n\t* cgraph.h (cgraph_local_info): Add externally_visible flag.\n\t(cgraph_varpool_node): Likewise.\n\t(cgraph_function_flags_ready): Declare.\n\t* cgraph.c (cgraph_mark_local_functions): Rename to ...\n\t(cgraph_function_and_variable_visibility) ... this one; handle\n\texternally_visible flags.\n\t(decide_is_function_needed): Set externally_visible flag.\n\t(cgraph_finalize_function): Deal properly with early cleanups.\n\t(cgraph_optimize): Update call of\n\tcgraph_function_and_variable_visibility.\n\nFrom-SVN: r100491", "tree": {"sha": "4f4dc9e478b4edd68765ff38a1348129dc516dae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f4dc9e478b4edd68765ff38a1348129dc516dae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7d6beb0f868d4feeefea469278b4e07ec3fee8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7d6beb0f868d4feeefea469278b4e07ec3fee8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7d6beb0f868d4feeefea469278b4e07ec3fee8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7d6beb0f868d4feeefea469278b4e07ec3fee8f/comments", "author": null, "committer": null, "parents": [{"sha": "75c702541afe8c4bb21341be284d02c401782622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75c702541afe8c4bb21341be284d02c401782622", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75c702541afe8c4bb21341be284d02c401782622"}], "stats": {"total": 110, "additions": 89, "deletions": 21}, "files": [{"sha": "fb286bbcb0fb3d450c8439a055b828c6941b1c46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d6beb0f868d4feeefea469278b4e07ec3fee8f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d6beb0f868d4feeefea469278b4e07ec3fee8f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7d6beb0f868d4feeefea469278b4e07ec3fee8f", "patch": "@@ -1,3 +1,19 @@\n+2005-06-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (dump_cgraph_node): Print new flags.\n+\t(dump_cgraph_varpool_node): Likewise.\n+\t(decide_variable_is_needed): Initialize externally_visible flag.\n+\t* cgraph.h (cgraph_local_info): Add externally_visible flag.\n+\t(cgraph_varpool_node): Likewise.\n+\t(cgraph_function_flags_ready): Declare.\n+\t* cgraph.c (cgraph_mark_local_functions): Rename to ...\n+\t(cgraph_function_and_variable_visibility) ... this one; handle\n+\texternally_visible flags.\n+\t(decide_is_function_needed): Set externally_visible flag.\n+\t(cgraph_finalize_function): Deal properly with early cleanups.\n+\t(cgraph_optimize): Update call of\n+\tcgraph_function_and_variable_visibility.\n+\n 2005-06-02 Steven Bosscher  <stevenb@suse.de>\n \t   Mostafa Hagog <mustafa@il.ibm.com>\n "}, {"sha": "04711910fe02b016140cf5af519649e7517198ba", "filename": "gcc/cgraph.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d6beb0f868d4feeefea469278b4e07ec3fee8f/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d6beb0f868d4feeefea469278b4e07ec3fee8f/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=e7d6beb0f868d4feeefea469278b4e07ec3fee8f", "patch": "@@ -582,10 +582,16 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \" output\");\n   if (node->local.local)\n     fprintf (f, \" local\");\n+  if (node->local.externally_visible)\n+    fprintf (f, \" externally_visible\");\n+  if (node->local.finalized)\n+    fprintf (f, \" finalized\");\n   if (node->local.disregard_inline_limits)\n     fprintf (f, \" always_inline\");\n   else if (node->local.inlinable)\n     fprintf (f, \" inlinable\");\n+  if (node->local.redefined_extern_inline)\n+    fprintf (f, \" redefined_extern_inline\");\n   if (TREE_ASM_WRITTEN (node->decl))\n     fprintf (f, \" asm_written\");\n \n@@ -639,6 +645,8 @@ dump_cgraph_varpool_node (FILE *f, struct cgraph_varpool_node *node)\n     fprintf (f, \" finalized\");\n   if (node->output)\n     fprintf (f, \" output\");\n+  if (node->externally_visible)\n+    fprintf (f, \" externally_visible\");\n   fprintf (f, \"\\n\");\n }\n \n@@ -786,8 +794,8 @@ decide_is_variable_needed (struct cgraph_varpool_node *node, tree decl)\n   if (node->needed)\n     return true;\n \n-  /* Externally visible functions must be output.  The exception is\n-     COMDAT functions that must be output only when they are needed.  */\n+  /* Externally visible variables must be output.  The exception is\n+     COMDAT variables that must be output only when they are needed.  */\n   if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n     return true;\n \n@@ -824,6 +832,11 @@ cgraph_varpool_finalize_decl (tree decl)\n \n   if (decide_is_variable_needed (node, decl))\n     cgraph_varpool_mark_needed_node (node);\n+  /* Since we reclaim unrechable nodes at the end of every language\n+     level unit, we need to be conservative about possible entry points\n+     there.  */\n+  if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n+    cgraph_varpool_mark_needed_node (node);\n   if (cgraph_global_info_ready || !flag_unit_at_a_time)\n     cgraph_varpool_assemble_pending_decls ();\n }"}, {"sha": "96e382a4a4310aa811b6ce2c5d903064d510c112", "filename": "gcc/cgraph.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d6beb0f868d4feeefea469278b4e07ec3fee8f/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d6beb0f868d4feeefea469278b4e07ec3fee8f/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=e7d6beb0f868d4feeefea469278b4e07ec3fee8f", "patch": "@@ -36,6 +36,9 @@ struct cgraph_local_info GTY(())\n      and its address is never taken.  */\n   bool local;\n \n+  /* Set when function is visible by other units.  */\n+  bool externally_visible;\n+\n   /* Set once it has been finalized so we consider it to be output.  */\n   bool finalized;\n \n@@ -177,6 +180,8 @@ struct cgraph_varpool_node GTY(())\n   bool finalized;\n   /* Set when function is scheduled to be assembled.  */\n   bool output;\n+  /* Set when function is visible by other units.  */\n+  bool externally_visible;\n   /* Set for aliases once they got through assemble_alias.  */\n   bool alias;\n };\n@@ -185,6 +190,7 @@ extern GTY(()) struct cgraph_node *cgraph_nodes;\n extern GTY(()) int cgraph_n_nodes;\n extern GTY(()) int cgraph_max_uid;\n extern bool cgraph_global_info_ready;\n+extern bool cgraph_function_flags_ready;\n extern GTY(()) struct cgraph_node *cgraph_nodes_queue;\n \n extern GTY(()) struct cgraph_varpool_node *cgraph_varpool_first_unanalyzed_node;"}, {"sha": "b10679d59ee3d2b411e652f3a8637f684468fcaa", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 52, "deletions": 19, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d6beb0f868d4feeefea469278b4e07ec3fee8f/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d6beb0f868d4feeefea469278b4e07ec3fee8f/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e7d6beb0f868d4feeefea469278b4e07ec3fee8f", "patch": "@@ -170,7 +170,6 @@ static void cgraph_expand_all_functions (void);\n static void cgraph_mark_functions_to_output (void);\n static void cgraph_expand_function (struct cgraph_node *);\n static tree record_reference (tree *, int *, void *);\n-static void cgraph_mark_local_functions (void);\n static void cgraph_analyze_function (struct cgraph_node *node);\n \n /* Records tree nodes seen in record_reference.  Simply using\n@@ -191,6 +190,17 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n {\n   tree origin;\n \n+  /* If the user told us it is used, then it must be so.  */\n+  if (lookup_attribute (\"used\", DECL_ATTRIBUTES (decl)))\n+    return true;\n+\n+  /* ??? If the assembler name is set by hand, it is possible to assemble\n+     the name later after finalizing the function and the fact is noticed\n+     in assemble_name then.  This is arguably a bug.  */\n+  if (DECL_ASSEMBLER_NAME_SET_P (decl)\n+      && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n+    return true;\n+\n   /* If we decided it was needed before, but at the time we didn't have\n      the body of the function available, then it's still needed.  We have\n      to go back and re-check its dependencies now.  */\n@@ -207,17 +217,6 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n   if (DECL_STATIC_CONSTRUCTOR (decl) || DECL_STATIC_DESTRUCTOR (decl))\n     return true;\n \n-  /* If the user told us it is used, then it must be so.  */\n-  if (lookup_attribute (\"used\", DECL_ATTRIBUTES (decl)))\n-    return true;\n-\n-  /* ??? If the assembler name is set by hand, it is possible to assemble\n-     the name later after finalizing the function and the fact is noticed\n-     in assemble_name then.  This is arguably a bug.  */\n-  if (DECL_ASSEMBLER_NAME_SET_P (decl)\n-      && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-    return true;\n-\n   if (flag_unit_at_a_time)\n     return false;\n \n@@ -422,6 +421,12 @@ cgraph_finalize_function (tree decl, bool nested)\n   if (decide_is_function_needed (node, decl))\n     cgraph_mark_needed_node (node);\n \n+  /* Since we reclaim unrechable nodes at the end of every language\n+     level unit, we need to be conservative about possible entry points\n+     there.  */\n+  if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n+    cgraph_mark_reachable_node (node);\n+\n   /* If not unit at a time, go ahead and emit everything we've found\n      to be reachable at this time.  */\n   if (!nested)\n@@ -1016,34 +1021,62 @@ cgraph_expand_all_functions (void)\n   free (order);\n }\n \n-/* Mark all local functions.\n+/* Mark visibility of all functions.\n    \n    A local function is one whose calls can occur only in the current\n    compilation unit and all its calls are explicit, so we can change\n    its calling convention.  We simply mark all static functions whose\n-   address is not taken as local.  */\n+   address is not taken as local.\n+\n+   We also change the TREE_PUBLIC flag of all declarations that are public\n+   in language point of view but we want to overwrite this default\n+   via visibilities for the backend point of view.  */\n \n static void\n-cgraph_mark_local_functions (void)\n+cgraph_function_and_variable_visibility (void)\n {\n   struct cgraph_node *node;\n+  struct cgraph_varpool_node *vnode;\n \n-  /* Figure out functions we want to assemble.  */\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n+      if (node->reachable\n+\t  && (DECL_COMDAT (node->decl)\n+\t      || (TREE_PUBLIC (node->decl) && !DECL_EXTERNAL (node->decl))))\n+\tnode->local.externally_visible = 1;\n       node->local.local = (!node->needed\n-\t\t           && DECL_SAVED_TREE (node->decl)\n-\t\t           && !TREE_PUBLIC (node->decl));\n+\t\t\t   && node->analyzed\n+\t\t\t   && node->local.externally_visible);\n+    }\n+  for (vnode = cgraph_varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n+    {\n+      if (vnode->needed\n+\t  && (DECL_COMDAT (vnode->decl) || TREE_PUBLIC (vnode->decl)))\n+\tvnode->externally_visible = 1;\n+     gcc_assert (TREE_STATIC (vnode->decl));\n     }\n \n+  /* Because we have to be conservative on the boundaries of source\n+     level units, it is possible that we marked some functions in\n+     reachable just because they might be used later via external\n+     linkage, but after making them local they are really unreachable\n+     now.  */\n+  cgraph_remove_unreachable_nodes (true, cgraph_dump_file);\n+\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"\\nMarking local functions:\");\n       for (node = cgraph_nodes; node; node = node->next)\n \tif (node->local.local)\n \t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (cgraph_dump_file, \"\\n\\n\");\n+      fprintf (cgraph_dump_file, \"\\nMarking externally visible functions:\");\n+      for (node = cgraph_nodes; node; node = node->next)\n+\tif (node->local.externally_visible)\n+\t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n+      fprintf (cgraph_dump_file, \"\\n\\n\");\n     }\n+  cgraph_function_flags_ready = true;\n }\n \n /* Return true when function body of DECL still needs to be kept around\n@@ -1088,7 +1121,7 @@ cgraph_optimize (void)\n   if (!quiet_flag)\n     fprintf (stderr, \"Performing intraprocedural optimizations\\n\");\n \n-  cgraph_mark_local_functions ();\n+  cgraph_function_and_variable_visibility ();\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Marked \");"}]}