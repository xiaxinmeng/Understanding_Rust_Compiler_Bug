{"sha": "2f418289ef423ac29034f93e705115f9f9e84711", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY0MTgyODllZjQyM2FjMjkwMzRmOTNlNzA1MTE1ZjlmOWU4NDcxMQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@waitaki.otago.ac.nz", "date": "2002-03-28T04:28:22Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2002-03-28T04:28:22Z"}, "message": "re PR java/5993 (crashes on Hello World)\n\n\tFix for PR java/5993:\n\t* parse.y (resolve_package): Return the decl if resolution was\n\tsuccessful. Don't special case \"java.lang\" and \"java.lang.reflect\"\n\tpackages. Set type_name to the merged identifier.\n\t(resolved_qualified_expression_name): Print error using \"name\" if\n\tresolve_package returns NULL_TREE.\n\nFrom-SVN: r51497", "tree": {"sha": "6b33609807fa19fdb85b3a4e412763711270da53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b33609807fa19fdb85b3a4e412763711270da53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f418289ef423ac29034f93e705115f9f9e84711", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f418289ef423ac29034f93e705115f9f9e84711", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f418289ef423ac29034f93e705115f9f9e84711", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f418289ef423ac29034f93e705115f9f9e84711/comments", "author": null, "committer": null, "parents": [{"sha": "96adcacb9fbc80b23bb48060baed22498027e533", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96adcacb9fbc80b23bb48060baed22498027e533", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96adcacb9fbc80b23bb48060baed22498027e533"}], "stats": {"total": 56, "additions": 24, "deletions": 32}, "files": [{"sha": "20c11cc1adf1a127d8a56c3938beef5a63d4c574", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f418289ef423ac29034f93e705115f9f9e84711/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f418289ef423ac29034f93e705115f9f9e84711/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=2f418289ef423ac29034f93e705115f9f9e84711", "patch": "@@ -1,3 +1,12 @@\n+2002-03-28  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\tFix for PR java/5993:\n+\t* parse.y (resolve_package): Return the decl if resolution was\n+\tsuccessful. Don't special case \"java.lang\" and \"java.lang.reflect\" \n+\tpackages. Set type_name to the merged identifier.\n+\t(resolved_qualified_expression_name): Print error using \"name\" if\n+\tresolve_package returns NULL_TREE.\n+\n 2002-03-27  Tom Tromey  <tromey@redhat.com>\n \n \t* expr.c (expand_invoke): Don't generate null pointer check if"}, {"sha": "3625dbabecdac9d6c35f176a16837ddf0bc38263", "filename": "gcc/java/parse.y", "status": "modified", "additions": 15, "deletions": 32, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f418289ef423ac29034f93e705115f9f9e84711/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f418289ef423ac29034f93e705115f9f9e84711/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=2f418289ef423ac29034f93e705115f9f9e84711", "patch": "@@ -104,7 +104,7 @@ static void find_in_imports PARAMS ((tree, tree));\n static void check_inner_class_access PARAMS ((tree, tree, tree));\n static int check_pkg_class_access PARAMS ((tree, tree, bool));\n static void register_package PARAMS ((tree));\n-static tree resolve_package PARAMS ((tree, tree *));\n+static tree resolve_package PARAMS ((tree, tree *, tree *));\n static tree lookup_package_type PARAMS ((const char *, int));\n static tree resolve_class PARAMS ((tree, tree, tree, tree));\n static void declare_local_variables PARAMS ((int, tree, tree));\n@@ -7031,57 +7031,39 @@ register_package (name)\n }\n \n static tree\n-resolve_package (pkg, next)\n-     tree pkg, *next;\n+resolve_package (pkg, next, type_name)\n+     tree pkg, *next, *type_name;\n {\n-  tree current, acc;\n-  tree type_name = NULL_TREE;\n-  const char *name = IDENTIFIER_POINTER (EXPR_WFL_NODE (pkg));\n+  tree current, decl;\n+  *type_name = NULL_TREE;\n \n   /* The trick is to determine when the package name stops and were\n      the name of something contained in the package starts. Then we\n      return a fully qualified name of what we want to get. */\n \n-  /* Do a quick search on well known package names */\n-  if (!strncmp (name, \"java.lang.reflect\", 17))\n-    {\n-      *next = \n-\tTREE_CHAIN (TREE_CHAIN (TREE_CHAIN (EXPR_WFL_QUALIFICATION (pkg))));\n-      type_name = lookup_package_type (name, 17);\n-    }\n-  else if (!strncmp (name, \"java.lang\", 9))\n-    {\n-      *next = TREE_CHAIN (TREE_CHAIN (EXPR_WFL_QUALIFICATION (pkg)));\n-      type_name = lookup_package_type (name, 9);\n-    }\n-\n-  /* If we found something here, return */\n-  if (type_name)\n-    return type_name; \n-\n   *next = EXPR_WFL_QUALIFICATION (pkg);\n \n   /* Try to progressively construct a type name */\n   if (TREE_CODE (pkg) == EXPR_WITH_FILE_LOCATION)\n-    for (acc = NULL_TREE, current = EXPR_WFL_QUALIFICATION (pkg); \n+    for (current = EXPR_WFL_QUALIFICATION (pkg); \n \t current; current = TREE_CHAIN (current))\n       {\n \t/* If we don't have what we're expecting, exit now. TYPE_NAME\n \t   will be null and the error caught later. */\n \tif (TREE_CODE (QUAL_WFL (current)) != EXPR_WITH_FILE_LOCATION)\n \t  break;\n-\tacc = merge_qualified_name (acc, EXPR_WFL_NODE (QUAL_WFL (current)));\n-\tif ((type_name = resolve_no_layout (acc, NULL_TREE)))\n+\t*type_name = \n+\t  merge_qualified_name (*type_name, EXPR_WFL_NODE (QUAL_WFL (current)));\n+\tif ((decl = resolve_no_layout (*type_name, NULL_TREE)))\n \t  {\n-\t    type_name = acc;\n \t    /* resolve_package should be used in a loop, hence we\n \t       point at this one to naturally process the next one at\n \t       the next iteration. */\n \t    *next = current;\n \t    break;\n \t  }\n       }\n-  return type_name;\n+  return decl;\n }\n \n static tree\n@@ -9677,11 +9659,12 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t assume a variable/class name was meant. */\n       if (RESOLVE_PACKAGE_NAME_P (qual_wfl))\n \t{\n-\t  tree name = resolve_package (wfl, &q);\n-\t  if (name)\n+\t  tree name;\n+\t  if ((decl = resolve_package (wfl, &q, &name)))\n \t    {\n \t      tree list;\n-\t      *where_found = decl = resolve_no_layout (name, qual_wfl);\n+\t      *where_found = decl;\n+\n \t      /* We want to be absolutely sure that the class is laid\n                  out. We're going to search something inside it. */\n \t      *type_found = type = TREE_TYPE (decl);\n@@ -9711,7 +9694,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t      else\n \t\tparse_error_context\n \t\t  (qual_wfl, \"Undefined variable or class name: `%s'\",\n-\t\t   IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)));\n+\t\t   IDENTIFIER_POINTER (name));\n \t      return 1;\n \t    }\n \t}"}]}