{"sha": "272e119d97217562803b42384db546e86b511d11", "node_id": "C_kwDOANBUbNoAKDI3MmUxMTlkOTcyMTc1NjI4MDNiNDIzODRkYjU0NmU4NmI1MTFkMTE", "commit": {"author": {"name": "Ju-Zhe Zhong", "email": "juzhe.zhong@rivai.ai", "date": "2023-02-14T09:24:04Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2023-02-15T13:41:51Z"}, "message": "RISC-V: Finish all integer C/C++ intrinsics\n\ngcc/ChangeLog:\n\n\t* config/riscv/predicates.md: Refine codes.\n\t* config/riscv/riscv-protos.h (RVV_VUNDEF): New macro.\n\t* config/riscv/riscv-v.cc: Refine codes.\n\t* config/riscv/riscv-vector-builtins-bases.cc (enum ternop_type): New\n\tenum.\n\t(class imac): New class.\n\t(enum widen_ternop_type): New enum.\n\t(class iwmac): New class.\n\t(BASE): New class.\n\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n\t* config/riscv/riscv-vector-builtins-functions.def (vmacc): Ditto.\n\t(vnmsac): Ditto.\n\t(vmadd): Ditto.\n\t(vnmsub): Ditto.\n\t(vwmacc): Ditto.\n\t(vwmaccu): Ditto.\n\t(vwmaccsu): Ditto.\n\t(vwmaccus): Ditto.\n\t* config/riscv/riscv-vector-builtins.cc\n\t(function_builder::apply_predication): Adjust for multiply-add support.\n\t(function_expander::add_vundef_operand): Refine codes.\n\t(function_expander::use_ternop_insn): New function.\n\t(function_expander::use_widen_ternop_insn): Ditto.\n\t* config/riscv/riscv-vector-builtins.h: New function.\n\t* config/riscv/vector.md (@pred_mul_<optab><mode>): New pattern.\n\t(pred_mul_<optab><mode>_undef_merge): Ditto.\n\t(*pred_<madd_nmsub><mode>): Ditto.\n\t(*pred_<macc_nmsac><mode>): Ditto.\n\t(*pred_mul_<optab><mode>): Ditto.\n\t(@pred_mul_<optab><mode>_scalar): Ditto.\n\t(*pred_mul_<optab><mode>_undef_merge_scalar): Ditto.\n\t(*pred_<madd_nmsub><mode>_scalar): Ditto.\n\t(*pred_<macc_nmsac><mode>_scalar): Ditto.\n\t(*pred_mul_<optab><mode>_scalar): Ditto.\n\t(*pred_mul_<optab><mode>_undef_merge_extended_scalar): Ditto.\n\t(*pred_<madd_nmsub><mode>_extended_scalar): Ditto.\n\t(*pred_<macc_nmsac><mode>_extended_scalar): Ditto.\n\t(*pred_mul_<optab><mode>_extended_scalar): Ditto.\n\t(@pred_widen_mul_plus<su><mode>): Ditto.\n\t(@pred_widen_mul_plus<su><mode>_scalar): Ditto.\n\t(@pred_widen_mul_plussu<mode>): Ditto.\n\t(@pred_widen_mul_plussu<mode>_scalar): Ditto.\n\t(@pred_widen_mul_plusus<mode>_scalar): Ditto.", "tree": {"sha": "f08930673eab41bd87954aa149a1a8d086e63fd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f08930673eab41bd87954aa149a1a8d086e63fd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/272e119d97217562803b42384db546e86b511d11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/272e119d97217562803b42384db546e86b511d11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/272e119d97217562803b42384db546e86b511d11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/272e119d97217562803b42384db546e86b511d11/comments", "author": {"login": "zhongjuzhe", "id": 66454988, "node_id": "MDQ6VXNlcjY2NDU0OTg4", "avatar_url": "https://avatars.githubusercontent.com/u/66454988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongjuzhe", "html_url": "https://github.com/zhongjuzhe", "followers_url": "https://api.github.com/users/zhongjuzhe/followers", "following_url": "https://api.github.com/users/zhongjuzhe/following{/other_user}", "gists_url": "https://api.github.com/users/zhongjuzhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongjuzhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongjuzhe/subscriptions", "organizations_url": "https://api.github.com/users/zhongjuzhe/orgs", "repos_url": "https://api.github.com/users/zhongjuzhe/repos", "events_url": "https://api.github.com/users/zhongjuzhe/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongjuzhe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a75fa2518d4ad997cb11145f625b4aebac5b9293", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a75fa2518d4ad997cb11145f625b4aebac5b9293", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a75fa2518d4ad997cb11145f625b4aebac5b9293"}], "stats": {"total": 1099, "additions": 1079, "deletions": 20}, "files": [{"sha": "7bc7c0b4f4d7a3de5cb6eafd1f8ee916dee14bef", "filename": "gcc/config/riscv/predicates.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fpredicates.md?ref=272e119d97217562803b42384db546e86b511d11", "patch": "@@ -292,8 +292,7 @@\n        (match_operand 0 \"vector_all_trues_mask_operand\")))\n \n (define_predicate \"vector_undef_operand\"\n-  (match_test \"GET_CODE (op) == UNSPEC\n-\t\t    && (XINT (op, 1) == UNSPEC_VUNDEF)\"))\n+  (match_test \"rtx_equal_p (op, RVV_VUNDEF (GET_MODE (op)))\"))\n \n (define_predicate \"vector_merge_operand\"\n   (ior (match_operand 0 \"register_operand\")"}, {"sha": "9d8b0b78a06d99229f82800d0181b2a08bdea58a", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=272e119d97217562803b42384db546e86b511d11", "patch": "@@ -121,6 +121,8 @@ extern void riscv_run_selftests (void);\n \n namespace riscv_vector {\n #define RVV_VLMAX gen_rtx_REG (Pmode, X0_REGNUM)\n+#define RVV_VUNDEF(MODE)                                                       \\\n+  gen_rtx_UNSPEC (MODE, gen_rtvec (1, const0_rtx), UNSPEC_VUNDEF)\n enum vlmul_type\n {\n   LMUL_1 = 0,"}, {"sha": "600b2e6ecadba99c28190298362bb65d7f051848", "filename": "gcc/config/riscv/riscv-v.cc", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-v.cc?ref=272e119d97217562803b42384db546e86b511d11", "patch": "@@ -67,9 +67,7 @@ template <int MAX_OPERANDS> class insn_expander\n   }\n   void add_vundef_operand (machine_mode mode)\n   {\n-    add_input_operand (gen_rtx_UNSPEC (mode, gen_rtvec (1, const0_rtx),\n-\t\t\t\t       UNSPEC_VUNDEF),\n-\t\t       mode);\n+    add_input_operand (RVV_VUNDEF (mode), mode);\n   }\n   void add_policy_operand (enum tail_policy vta, enum mask_policy vma)\n   {"}, {"sha": "ba7014827281fe1e966a014fb3bfd7b1ceb0257d", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.cc", "status": "modified", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc?ref=272e119d97217562803b42384db546e86b511d11", "patch": "@@ -539,6 +539,132 @@ class icmp : public function_base\n   }\n };\n \n+/* Enumerates types of ternary operations.\n+   We have 2 types ternop:\n+     - 1. accumulator is vd:\n+        vmacc.vv vd,vs1,vs2 # vd = vs1 * vs2 + vd.\n+     - 2. accumulator is vs2:\n+        vmadd.vv vd,vs1,vs2 # vd = vs1 * vd + vs2.  */\n+enum ternop_type\n+{\n+  TERNOP_VMACC,\n+  TERNOP_VNMSAC,\n+  TERNOP_VMADD,\n+  TERNOP_VNMSUB,\n+};\n+\n+/* Implements vmacc/vnmsac/vmadd/vnmsub.  */\n+template<ternop_type TERNOP_TYPE>\n+class imac : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (TERNOP_TYPE)\n+      {\n+      case TERNOP_VMACC:\n+\tif (e.op_info->op == OP_TYPE_vx)\n+\t  return e.use_ternop_insn (\n+\t    true, code_for_pred_mul_scalar (PLUS, e.vector_mode ()));\n+\tif (e.op_info->op == OP_TYPE_vv)\n+\t  return e.use_ternop_insn (true,\n+\t\t\t\t    code_for_pred_mul (PLUS, e.vector_mode ()));\n+\tbreak;\n+      case TERNOP_VNMSAC:\n+\tif (e.op_info->op == OP_TYPE_vx)\n+\t  return e.use_ternop_insn (\n+\t    true, code_for_pred_mul_scalar (MINUS, e.vector_mode ()));\n+\tif (e.op_info->op == OP_TYPE_vv)\n+\t  return e.use_ternop_insn (true, code_for_pred_mul (MINUS,\n+\t\t\t\t\t\t\t     e.vector_mode ()));\n+\tbreak;\n+      case TERNOP_VMADD:\n+\tif (e.op_info->op == OP_TYPE_vx)\n+\t  return e.use_ternop_insn (\n+\t    false, code_for_pred_mul_scalar (PLUS, e.vector_mode ()));\n+\tif (e.op_info->op == OP_TYPE_vv)\n+\t  return e.use_ternop_insn (false,\n+\t\t\t\t    code_for_pred_mul (PLUS, e.vector_mode ()));\n+\tbreak;\n+      case TERNOP_VNMSUB:\n+\tif (e.op_info->op == OP_TYPE_vx)\n+\t  return e.use_ternop_insn (\n+\t    false, code_for_pred_mul_scalar (MINUS, e.vector_mode ()));\n+\tif (e.op_info->op == OP_TYPE_vv)\n+\t  return e.use_ternop_insn (false,\n+\t\t\t\t    code_for_pred_mul (MINUS,\n+\t\t\t\t\t\t       e.vector_mode ()));\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+    gcc_unreachable ();\n+  }\n+};\n+\n+/* Enumerates types of widen ternary operations.\n+   We have 4 types ternop:\n+     - 1. vwmacc.\n+     - 2. vwmaccu.\n+     - 3. vwmaccsu.\n+     - 4. vwmaccus.  */\n+enum widen_ternop_type\n+{\n+  WIDEN_TERNOP_VWMACC,\n+  WIDEN_TERNOP_VWMACCU,\n+  WIDEN_TERNOP_VWMACCSU,\n+  WIDEN_TERNOP_VWMACCUS,\n+};\n+\n+/* Implements vwmacc<su><su>.  */\n+template<widen_ternop_type WIDEN_TERNOP_TYPE>\n+class iwmac : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (WIDEN_TERNOP_TYPE)\n+      {\n+      case WIDEN_TERNOP_VWMACC:\n+\tif (e.op_info->op == OP_TYPE_vx)\n+\t  return e.use_widen_ternop_insn (\n+\t    code_for_pred_widen_mul_plus_scalar (SIGN_EXTEND,\n+\t\t\t\t\t\t e.vector_mode ()));\n+\tif (e.op_info->op == OP_TYPE_vv)\n+\t  return e.use_widen_ternop_insn (\n+\t    code_for_pred_widen_mul_plus (SIGN_EXTEND, e.vector_mode ()));\n+\tbreak;\n+      case WIDEN_TERNOP_VWMACCU:\n+\tif (e.op_info->op == OP_TYPE_vx)\n+\t  return e.use_widen_ternop_insn (\n+\t    code_for_pred_widen_mul_plus_scalar (ZERO_EXTEND,\n+\t\t\t\t\t\t e.vector_mode ()));\n+\tif (e.op_info->op == OP_TYPE_vv)\n+\t  return e.use_widen_ternop_insn (\n+\t    code_for_pred_widen_mul_plus (ZERO_EXTEND, e.vector_mode ()));\n+\tbreak;\n+      case WIDEN_TERNOP_VWMACCSU:\n+\tif (e.op_info->op == OP_TYPE_vx)\n+\t  return e.use_widen_ternop_insn (\n+\t    code_for_pred_widen_mul_plussu_scalar (e.vector_mode ()));\n+\tif (e.op_info->op == OP_TYPE_vv)\n+\t  return e.use_widen_ternop_insn (\n+\t    code_for_pred_widen_mul_plussu (e.vector_mode ()));\n+\tbreak;\n+      case WIDEN_TERNOP_VWMACCUS:\n+\treturn e.use_widen_ternop_insn (\n+\t  code_for_pred_widen_mul_plusus_scalar (e.vector_mode ()));\n+      default:\n+\tbreak;\n+      }\n+    gcc_unreachable ();\n+  }\n+};\n+\n static CONSTEXPR const vsetvl<false> vsetvl_obj;\n static CONSTEXPR const vsetvl<true> vsetvlmax_obj;\n static CONSTEXPR const loadstore<false, LST_UNIT_STRIDE, false> vle_obj;\n@@ -616,6 +742,14 @@ static CONSTEXPR const icmp<LTU> vmsltu_obj;\n static CONSTEXPR const icmp<GTU> vmsgtu_obj;\n static CONSTEXPR const icmp<LEU> vmsleu_obj;\n static CONSTEXPR const icmp<GEU> vmsgeu_obj;\n+static CONSTEXPR const imac<TERNOP_VMACC> vmacc_obj;\n+static CONSTEXPR const imac<TERNOP_VNMSAC> vnmsac_obj;\n+static CONSTEXPR const imac<TERNOP_VMADD> vmadd_obj;\n+static CONSTEXPR const imac<TERNOP_VNMSUB> vnmsub_obj;\n+static CONSTEXPR const iwmac<WIDEN_TERNOP_VWMACC> vwmacc_obj;\n+static CONSTEXPR const iwmac<WIDEN_TERNOP_VWMACCU> vwmaccu_obj;\n+static CONSTEXPR const iwmac<WIDEN_TERNOP_VWMACCSU> vwmaccsu_obj;\n+static CONSTEXPR const iwmac<WIDEN_TERNOP_VWMACCUS> vwmaccus_obj;\n static CONSTEXPR const binop<SS_PLUS> vsadd_obj;\n static CONSTEXPR const binop<SS_MINUS> vssub_obj;\n static CONSTEXPR const binop<US_PLUS> vsaddu_obj;\n@@ -712,6 +846,14 @@ BASE (vmsltu)\n BASE (vmsgtu)\n BASE (vmsleu)\n BASE (vmsgeu)\n+BASE (vmacc)\n+BASE (vnmsac)\n+BASE (vmadd)\n+BASE (vnmsub)\n+BASE (vwmacc)\n+BASE (vwmaccu)\n+BASE (vwmaccsu)\n+BASE (vwmaccus)\n BASE (vsadd)\n BASE (vssub)\n BASE (vsaddu)"}, {"sha": "cb36f1f26996a856b120425d0e46ec7a9d9aefbb", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h?ref=272e119d97217562803b42384db546e86b511d11", "patch": "@@ -101,6 +101,14 @@ extern const function_base *const vmsltu;\n extern const function_base *const vmsgtu;\n extern const function_base *const vmsleu;\n extern const function_base *const vmsgeu;\n+extern const function_base *const vmacc;\n+extern const function_base *const vnmsac;\n+extern const function_base *const vmadd;\n+extern const function_base *const vnmsub;\n+extern const function_base *const vwmacc;\n+extern const function_base *const vwmaccu;\n+extern const function_base *const vwmaccsu;\n+extern const function_base *const vwmaccus;\n extern const function_base *const vsadd;\n extern const function_base *const vssub;\n extern const function_base *const vsaddu;"}, {"sha": "22271273655b90350577a326d05019d2a7797b13", "filename": "gcc/config/riscv/riscv-vector-builtins-functions.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def?ref=272e119d97217562803b42384db546e86b511d11", "patch": "@@ -177,6 +177,21 @@ DEF_RVV_FUNCTION (vmsltu, return_mask, none_m_mu_preds, u_mvx_ops)\n DEF_RVV_FUNCTION (vmsgtu, return_mask, none_m_mu_preds, u_mvx_ops)\n DEF_RVV_FUNCTION (vmsleu, return_mask, none_m_mu_preds, u_mvx_ops)\n DEF_RVV_FUNCTION (vmsgeu, return_mask, none_m_mu_preds, u_mvx_ops)\n+DEF_RVV_FUNCTION (vmacc, alu, full_preds, iu_vvvv_ops)\n+DEF_RVV_FUNCTION (vnmsac, alu, full_preds, iu_vvvv_ops)\n+DEF_RVV_FUNCTION (vmadd, alu, full_preds, iu_vvvv_ops)\n+DEF_RVV_FUNCTION (vnmsub, alu, full_preds, iu_vvvv_ops)\n+DEF_RVV_FUNCTION (vmacc, alu, full_preds, iu_vvxv_ops)\n+DEF_RVV_FUNCTION (vnmsac, alu, full_preds, iu_vvxv_ops)\n+DEF_RVV_FUNCTION (vmadd, alu, full_preds, iu_vvxv_ops)\n+DEF_RVV_FUNCTION (vnmsub, alu, full_preds, iu_vvxv_ops)\n+DEF_RVV_FUNCTION (vwmacc, alu, full_preds, i_wwvv_ops)\n+DEF_RVV_FUNCTION (vwmacc, alu, full_preds, i_wwxv_ops)\n+DEF_RVV_FUNCTION (vwmaccu, alu, full_preds, u_wwvv_ops)\n+DEF_RVV_FUNCTION (vwmaccu, alu, full_preds, u_wwxv_ops)\n+DEF_RVV_FUNCTION (vwmaccsu, alu, full_preds, i_su_wwvv_ops)\n+DEF_RVV_FUNCTION (vwmaccsu, alu, full_preds, i_su_wwxv_ops)\n+DEF_RVV_FUNCTION (vwmaccus, alu, full_preds, i_us_wwxv_ops)\n /* 12. Vector Fixed-Point Arithmetic Instructions. */\n DEF_RVV_FUNCTION (vsadd, alu, full_preds, i_vvv_ops)\n DEF_RVV_FUNCTION (vssub, alu, full_preds, i_vvv_ops)"}, {"sha": "1047bd29fd69dc6dedb7606f5147040625b8d1e1", "filename": "gcc/config/riscv/riscv-vector-builtins.cc", "status": "modified", "additions": 238, "deletions": 5, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc?ref=272e119d97217562803b42384db546e86b511d11", "patch": "@@ -314,6 +314,18 @@ static CONSTEXPR const rvv_arg_type_info vv_args[]\n   = {rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info (RVV_BASE_vector),\n      rvv_arg_type_info_end};\n \n+/* A list of args for vector_type func (vector_type, vector_type, vector_type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info vvv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, vector_type, vector_type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info vxv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info (RVV_BASE_scalar),\n+     rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info_end};\n+\n /* A list of args for vector_type func (vector_type, vector_type, mask_type)\n  * function.  */\n static CONSTEXPR const rvv_arg_type_info vvm_args[]\n@@ -378,6 +390,44 @@ static CONSTEXPR const rvv_arg_type_info wvv_args[]\n   = {rvv_arg_type_info (RVV_BASE_double_trunc_vector),\n      rvv_arg_type_info (RVV_BASE_double_trunc_vector), rvv_arg_type_info_end};\n \n+/* A list of args for vector_type func (vector_type, double demote type, double\n+ * demote type) function.  */\n+static CONSTEXPR const rvv_arg_type_info wwvv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, double demote type, double\n+ * demote type) function.  */\n+static CONSTEXPR const rvv_arg_type_info wwxv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_scalar),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, double demote type, double\n+ * demote type) function.  */\n+static CONSTEXPR const rvv_arg_type_info su_wwvv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_unsigned_vector),\n+     rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, double demote type, double\n+ * demote type) function.  */\n+static CONSTEXPR const rvv_arg_type_info su_wwxv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_scalar),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_unsigned_vector),\n+     rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type, double demote type, double\n+ * demote type) function.  */\n+static CONSTEXPR const rvv_arg_type_info us_wwxv_args[]\n+  = {rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_unsigned_scalar),\n+     rvv_arg_type_info (RVV_BASE_double_trunc_vector),\n+     rvv_arg_type_info_end};\n+\n /* A list of args for vector_type func (signed double demote type,\n  * unsigneddouble demote type) function.  */\n static CONSTEXPR const rvv_arg_type_info su_wvv_args[]\n@@ -577,6 +627,22 @@ static CONSTEXPR const rvv_op_info iu_vvv_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      vv_args /* Args */};\n \n+/* A static operand information for vector_type func (vector_type, vector_type,\n+ * vector_type) function registration. */\n+static CONSTEXPR const rvv_op_info iu_vvvv_ops\n+  = {iu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vvv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, scalar_type,\n+ * vector_type) function registration. */\n+static CONSTEXPR const rvv_op_info iu_vvxv_ops\n+  = {iu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vxv_args /* Args */};\n+\n /* A static operand information for vector_type func (vector_type, vector_type,\n  * mask_type) function registration. */\n static CONSTEXPR const rvv_op_info iu_vvvm_ops\n@@ -882,6 +948,62 @@ static CONSTEXPR const rvv_op_info i_wvv_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      wvv_args /* Args */};\n \n+/* A static operand information for vector_type func (vector_type, double demote\n+ * type, double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info i_wwvv_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wwvv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double demote\n+ * scalar_type, double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info i_wwxv_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wwxv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double demote\n+ * type, double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info u_wwvv_ops\n+  = {wextu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wwvv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double demote\n+ * scalar_type, double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info u_wwxv_ops\n+  = {wextu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wwxv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double demote\n+ * type, double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info i_su_wwvv_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     su_wwvv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double demote\n+ * scalar_type, double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info i_su_wwxv_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     su_wwxv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double demote\n+ * scalar_type, double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info i_us_wwxv_ops\n+  = {wexti_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vx,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     us_wwxv_args /* Args */};\n+\n /* A static operand information for vector_type func (signed double demote type,\n  * unsigned double demote type) function registration. */\n static CONSTEXPR const rvv_op_info i_su_wvv_ops\n@@ -1617,9 +1739,10 @@ function_builder::apply_predication (const function_instance &instance,\n \t\t\t\t     vec<tree> &argument_types) const\n {\n   /* These predication types need to apply merge type.  */\n-  if (instance.pred == PRED_TYPE_tu || instance.pred == PRED_TYPE_tum\n-      || instance.pred == PRED_TYPE_tumu || instance.pred == PRED_TYPE_mu)\n-    argument_types.quick_insert (0, return_type);\n+  if (instance.base->has_merge_operand_p ())\n+    if (instance.pred == PRED_TYPE_tu || instance.pred == PRED_TYPE_tum\n+\t|| instance.pred == PRED_TYPE_tumu || instance.pred == PRED_TYPE_mu)\n+      argument_types.quick_insert (0, return_type);\n \n   /* These predication types need to apply mask type.  */\n   tree mask_type = builtin_types[mask_types[instance.type.index]].vector;\n@@ -1816,8 +1939,7 @@ function_expander::add_input_operand (unsigned argno)\n void\n function_expander::add_vundef_operand (machine_mode mode)\n {\n-  rtx vundef = gen_rtx_UNSPEC (mode, gen_rtvec (1, const0_rtx), UNSPEC_VUNDEF);\n-  add_input_operand (mode, vundef);\n+  add_input_operand (mode, RVV_VUNDEF (mode));\n }\n \n /* Add a memory operand with mode MODE and address ADDR.  */\n@@ -1979,6 +2101,117 @@ function_expander::use_compare_insn (rtx_code rcode, insn_code icode)\n   return generate_insn (icode);\n }\n \n+/* Implement the call using instruction ICODE, with a 1:1 mapping between\n+   arguments and input operands.  */\n+rtx\n+function_expander::use_ternop_insn (bool vd_accum_p, insn_code icode)\n+{\n+  machine_mode mode = TYPE_MODE (builtin_types[type.index].vector);\n+  tree mask_type = builtin_types[mask_types[type.index]].vector;\n+  machine_mode mask_mode = TYPE_MODE (mask_type);\n+\n+  /* Record the offset to get the argument.  */\n+  int arg_offset = 0;\n+\n+  if (use_real_mask_p (pred))\n+    add_input_operand (arg_offset++);\n+  else\n+    add_all_one_mask_operand (mask_mode);\n+\n+  rtx vd = expand_normal (CALL_EXPR_ARG (exp, arg_offset++));\n+  rtx vs1 = expand_normal (CALL_EXPR_ARG (exp, arg_offset++));\n+  rtx vs2 = expand_normal (CALL_EXPR_ARG (exp, arg_offset++));\n+  rtx merge = use_real_merge_p (pred) ? vd : RVV_VUNDEF (mode);\n+\n+  if (VECTOR_MODE_P (GET_MODE (vs1)))\n+    {\n+      if (!vd_accum_p)\n+\tadd_input_operand (mode, vd);\n+      add_input_operand (mode, vs1);\n+      add_input_operand (mode, vs2);\n+      if (vd_accum_p)\n+\tadd_input_operand (mode, vd);\n+      add_input_operand (mode, merge);\n+    }\n+  else\n+    {\n+      add_input_operand (GET_MODE_INNER (mode), vs1);\n+      if (vd_accum_p)\n+\t{\n+\t  add_input_operand (mode, vs2);\n+\t  add_input_operand (mode, vd);\n+\t}\n+      else\n+\t{\n+\t  add_input_operand (mode, vd);\n+\t  add_input_operand (mode, vs2);\n+\t}\n+      add_input_operand (mode, merge);\n+    }\n+\n+  for (int argno = arg_offset; argno < call_expr_nargs (exp); argno++)\n+    add_input_operand (argno);\n+\n+  add_input_operand (Pmode, get_tail_policy_for_pred (pred));\n+  add_input_operand (Pmode, get_mask_policy_for_pred (pred));\n+  add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n+\n+  /* See optabs.cc, the maximum nops is 9 for using 'maybe_gen_insn'.\n+     We temporarily use GCN directly. We will change it back it we\n+     can support nops >= 10.  */\n+  gcc_assert (maybe_legitimize_operands (icode, 0, opno, m_ops));\n+  rtx_insn *pat = GEN_FCN (\n+    icode) (m_ops[0].value, m_ops[1].value, m_ops[2].value, m_ops[3].value,\n+\t    m_ops[4].value, m_ops[5].value, m_ops[6].value, m_ops[7].value,\n+\t    m_ops[8].value, m_ops[9].value);\n+  emit_insn (pat);\n+  return m_ops[0].value;\n+}\n+\n+/* Implement the call using instruction ICODE, with a 1:1 mapping between\n+   arguments and input operands.  */\n+rtx\n+function_expander::use_widen_ternop_insn (insn_code icode)\n+{\n+  machine_mode mode = TYPE_MODE (builtin_types[type.index].vector);\n+  tree mask_type = builtin_types[mask_types[type.index]].vector;\n+  machine_mode mask_mode = TYPE_MODE (mask_type);\n+\n+  /* Record the offset to get the argument.  */\n+  int arg_offset = 0;\n+\n+  if (use_real_mask_p (pred))\n+    add_input_operand (arg_offset++);\n+  else\n+    add_all_one_mask_operand (mask_mode);\n+\n+  rtx merge = RVV_VUNDEF (mode);\n+  if (use_real_merge_p (pred))\n+    merge = expand_normal (CALL_EXPR_ARG (exp, arg_offset));\n+\n+  for (int argno = arg_offset; argno < call_expr_nargs (exp); argno++)\n+    {\n+      if (argno == call_expr_nargs (exp) - 1)\n+\tadd_input_operand (mode, merge);\n+      add_input_operand (argno);\n+    }\n+\n+  add_input_operand (Pmode, get_tail_policy_for_pred (pred));\n+  add_input_operand (Pmode, get_mask_policy_for_pred (pred));\n+  add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n+\n+  /* See optabs.cc, the maximum nops is 9 for using 'maybe_gen_insn'.\n+     We temporarily use GCN directly. We will change it back it we\n+     can support nops >= 10.  */\n+  gcc_assert (maybe_legitimize_operands (icode, 0, opno, m_ops));\n+  rtx_insn *pat = GEN_FCN (\n+    icode) (m_ops[0].value, m_ops[1].value, m_ops[2].value, m_ops[3].value,\n+\t    m_ops[4].value, m_ops[5].value, m_ops[6].value, m_ops[7].value,\n+\t    m_ops[8].value, m_ops[9].value);\n+  emit_insn (pat);\n+  return m_ops[0].value;\n+}\n+\n /* Generate instruction ICODE, given that its operands have already\n    been added to M_OPS.  Return the value of the first operand.  */\n rtx"}, {"sha": "b9d736707892371d049f79437dffcfbe2d8ab227", "filename": "gcc/config/riscv/riscv-vector-builtins.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h?ref=272e119d97217562803b42384db546e86b511d11", "patch": "@@ -348,6 +348,8 @@ class function_expander : public function_call_info\n   rtx use_contiguous_load_insn (insn_code);\n   rtx use_contiguous_store_insn (insn_code);\n   rtx use_compare_insn (rtx_code, insn_code);\n+  rtx use_ternop_insn (bool, insn_code);\n+  rtx use_widen_ternop_insn (insn_code);\n   rtx generate_insn (insn_code);\n \n   /* The function call expression.  */"}, {"sha": "2d8179f948c8b4323b07ed14bf8d7913218fbe9b", "filename": "gcc/config/riscv/vector.md", "status": "modified", "additions": 670, "deletions": 10, "changes": 680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272e119d97217562803b42384db546e86b511d11/gcc%2Fconfig%2Friscv%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector.md?ref=272e119d97217562803b42384db546e86b511d11", "patch": "@@ -146,7 +146,7 @@\n \t\t\t  vialu,vshift,vicmp,vimul,vidiv,vsalu,\\\n \t\t\t  vext,viwalu,viwmul,vicalu,vnshift,\\\n \t\t\t  vimuladd,vimerge,vaalu,vsmul,vsshift,\\\n-\t\t\t  vnclip,viminmax\")\n+\t\t\t  vnclip,viminmax,viwmuladd\")\n \t   (const_int INVALID_ATTRIBUTE)\n \t (eq_attr \"mode\" \"VNx1QI,VNx1BI\")\n \t   (symbol_ref \"riscv_vector::get_ratio(E_VNx1QImode)\")\n@@ -198,11 +198,14 @@\n (define_attr \"merge_op_idx\" \"\"\n \t(cond [(eq_attr \"type\" \"vlde,vimov,vfmov,vldm,vlds,vmalu,vldux,vldox,vicmp,\\\n \t\t\t\tvialu,vshift,viminmax,vimul,vidiv,vsalu,vext,viwalu,\\\n-\t\t\t\tviwmul,vnshift,vimuladd,vaalu,vsmul,vsshift,vnclip\")\n+\t\t\t\tviwmul,vnshift,vaalu,vsmul,vsshift,vnclip\")\n \t       (const_int 2)\n \n \t       (eq_attr \"type\" \"vimerge\")\n-\t       (const_int 1)]\n+\t       (const_int 1)\n+\n+\t       (eq_attr \"type\" \"vimuladd,viwmuladd\")\n+\t       (const_int 5)]\n \t(const_int INVALID_ATTRIBUTE)))\n \n ;; The index of operand[] to get the avl op.\n@@ -219,11 +222,14 @@\n              (const_int 4))\n \n \t (eq_attr \"type\" \"vldux,vldox,vialu,vshift,viminmax,vimul,vidiv,vsalu,\\\n-\t\t\t  viwalu,viwmul,vnshift,vimuladd,vimerge,vaalu,vsmul,\\\n+\t\t\t  viwalu,viwmul,vnshift,vimerge,vaalu,vsmul,\\\n \t\t\t  vsshift,vnclip\")\n \t   (const_int 5)\n \n \t (eq_attr \"type\" \"vicmp\")\n+\t   (const_int 6)\n+\n+\t (eq_attr \"type\" \"vimuladd,viwmuladd\")\n \t   (const_int 6)]\n   (const_int INVALID_ATTRIBUTE)))\n \n@@ -240,9 +246,12 @@\n \t     (symbol_ref \"riscv_vector::get_ta(operands[5])\"))\n \n \t (eq_attr \"type\" \"vldux,vldox,vialu,vshift,viminmax,vimul,vidiv,vsalu,\\\n-\t\t\t  viwalu,viwmul,vnshift,vimuladd,vimerge,vaalu,vsmul,\\\n+\t\t\t  viwalu,viwmul,vnshift,vimerge,vaalu,vsmul,\\\n \t\t\t  vsshift,vnclip\")\n-\t   (symbol_ref \"riscv_vector::get_ta(operands[6])\")]\n+\t   (symbol_ref \"riscv_vector::get_ta(operands[6])\")\n+\n+\t (eq_attr \"type\" \"vimuladd,viwmuladd\")\n+\t   (symbol_ref \"riscv_vector::get_ta(operands[7])\")]\n \t(const_int INVALID_ATTRIBUTE)))\n \n ;; The mask policy op value.\n@@ -258,9 +267,12 @@\n \t     (symbol_ref \"riscv_vector::get_ma(operands[6])\"))\n \n \t (eq_attr \"type\" \"vldux,vldox,vialu,vshift,viminmax,vimul,vidiv,vsalu,\\\n-\t\t\t  viwalu,viwmul,vnshift,vimuladd,vaalu,vsmul,vsshift,\\\n+\t\t\t  viwalu,viwmul,vnshift,vaalu,vsmul,vsshift,\\\n \t\t\t  vnclip,vicmp\")\n-\t   (symbol_ref \"riscv_vector::get_ma(operands[7])\")]\n+\t   (symbol_ref \"riscv_vector::get_ma(operands[7])\")\n+\n+\t (eq_attr \"type\" \"vimuladd,viwmuladd\")\n+\t   (symbol_ref \"riscv_vector::get_ma(operands[8])\")]\n \t(const_int INVALID_ATTRIBUTE)))\n \n ;; The avl type value.\n@@ -282,7 +294,10 @@\n \t\t\t  vnclip,vicmp\")\n \t   (symbol_ref \"INTVAL (operands[8])\")\n \t (eq_attr \"type\" \"vstux,vstox\")\n-\t   (symbol_ref \"INTVAL (operands[5])\")]\n+\t   (symbol_ref \"INTVAL (operands[5])\")\n+\n+\t (eq_attr \"type\" \"vimuladd,viwmuladd\")\n+\t   (symbol_ref \"INTVAL (operands[9])\")]\n \t(const_int INVALID_ATTRIBUTE)))\n \n ;; -----------------------------------------------------------------\n@@ -3948,7 +3963,7 @@\n   \"TARGET_VECTOR\"\n {\n   enum rtx_code code = GET_CODE (operands[3]);\n-  rtx undef = gen_rtx_UNSPEC (<VM>mode, gen_rtvec (1, const0_rtx), UNSPEC_VUNDEF);\n+  rtx undef = RVV_VUNDEF (<VM>mode);\n   if (code == GEU && rtx_equal_p (operands[5], const0_rtx))\n     {\n       /* If vmsgeu with 0 immediate, expand it to vmset.  */\n@@ -4035,6 +4050,651 @@\n   DONE;\n })\n \n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated integer ternary operations\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 11.13 Vector Single-Width Integer Multiply-Add Instructions\n+;; -------------------------------------------------------------------------------\n+\n+(define_expand \"@pred_mul_<optab><mode>\"\n+  [(set (match_operand:VI 0 \"register_operand\")\n+\t(if_then_else:VI\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (match_operand 9 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VI\n+\t    (mult:VI\n+\t      (match_operand:VI 2 \"register_operand\")\n+\t      (match_operand:VI 3 \"register_operand\"))\n+\t    (match_operand:VI 4 \"register_operand\"))\n+\t  (match_operand:VI 5 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+{\n+  /* Swap the multiplication operands if the fallback value is the\n+     second of the two.  */\n+  if (rtx_equal_p (operands[3], operands[5]))\n+    std::swap (operands[2], operands[3]);\n+})\n+\n+(define_insn \"pred_mul_<optab><mode>_undef_merge\"\n+  [(set (match_operand:VI 0 \"register_operand\"           \"=vd, vr, vd, vr, ?&vr\")\n+\t(if_then_else:VI\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1, vm,Wc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"    \" rK, rK, rK, rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i,  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"  i,  i,  i,  i,    i\")\n+\t     (match_operand 9 \"const_int_operand\"        \"  i,  i,  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VI\n+\t    (mult:VI\n+\t      (match_operand:VI 2 \"register_operand\"     \" %0,  0, vr, vr,   vr\")\n+\t      (match_operand:VI 3 \"register_operand\"     \" vr, vr, vr, vr,   vr\"))\n+\t    (match_operand:VI 4 \"register_operand\"       \" vr, vr,  0,  0,   vr\"))\n+\t  (match_operand:VI 5 \"vector_undef_operand\"     \" vu, vu, vu, vu,   vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   v<madd_nmsub>.vv\\t%0,%3,%4%p1\n+   v<madd_nmsub>.vv\\t%0,%3,%4%p1\n+   v<macc_nmsac>.vv\\t%0,%2,%3%p1\n+   v<macc_nmsac>.vv\\t%0,%2,%3%p1\n+   vmv.v.v\\t%0,%4\\;v<macc_nmsac>.vv\\t%0,%2,%3%p1\"\n+  [(set_attr \"type\" \"vimuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*pred_<madd_nmsub><mode>\"\n+  [(set (match_operand:VI 0 \"register_operand\"           \"=vd, vr, ?&vr\")\n+\t(if_then_else:VI\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1,vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"    \" rK, rK,   rK\")\n+\t     (match_operand 6 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VI\n+\t    (mult:VI\n+\t      (match_operand:VI 2 \"register_operand\"     \"  0,  0,   vr\")\n+\t      (match_operand:VI 3 \"register_operand\"     \" vr, vr,   vr\"))\n+\t    (match_operand:VI 4 \"register_operand\"       \" vr, vr,   vr\"))\n+\t  (match_dup 2)))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   v<madd_nmsub>.vv\\t%0,%3,%4%p1\n+   v<madd_nmsub>.vv\\t%0,%3,%4%p1\n+   vmv.v.v\\t%0,%2\\;v<madd_nmsub>.vv\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"vimuladd\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"merge_op_idx\" \"4\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"ta\") (symbol_ref \"riscv_vector::get_ta(operands[6])\"))\n+   (set (attr \"ma\") (symbol_ref \"riscv_vector::get_ma(operands[7])\"))\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[8])\"))])\n+\n+(define_insn \"*pred_<macc_nmsac><mode>\"\n+  [(set (match_operand:VI 0 \"register_operand\"           \"=vd, vr, ?&vr\")\n+\t(if_then_else:VI\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1,vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"    \" rK, rK,   rK\")\n+\t     (match_operand 6 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VI\n+\t    (mult:VI\n+\t      (match_operand:VI 2 \"register_operand\"     \" vr, vr,   vr\")\n+\t      (match_operand:VI 3 \"register_operand\"     \" vr, vr,   vr\"))\n+\t    (match_operand:VI 4 \"register_operand\"       \"  0,  0,   vr\"))\n+\t  (match_dup 4)))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   v<macc_nmsac>.vv\\t%0,%2,%3%p1\n+   v<macc_nmsac>.vv\\t%0,%2,%3%p1\n+   vmv.v.v\\t%0,%4\\;v<macc_nmsac>.vv\\t%0,%2,%3%p1\"\n+  [(set_attr \"type\" \"vimuladd\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"merge_op_idx\" \"2\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"ta\") (symbol_ref \"riscv_vector::get_ta(operands[6])\"))\n+   (set (attr \"ma\") (symbol_ref \"riscv_vector::get_ma(operands[7])\"))\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[8])\"))])\n+\n+(define_insn_and_rewrite \"*pred_mul_<optab><mode>\"\n+  [(set (match_operand:VI 0 \"register_operand\"            \"=&vr,?&vr, ?&vr, ?&vr,  ?&vr\")\n+\t(if_then_else:VI\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \"vmWc1,vmWc1,vmWc1,vmWc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"    \"   rK,   rK,   rK,   rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"        \"    i,    i,    i,    i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"    i,    i,    i,    i,    i\")\n+\t     (match_operand 9 \"const_int_operand\"        \"    i,    i,    i,    i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VI\n+\t    (mult:VI\n+\t      (match_operand:VI 2 \"register_operand\"     \"   vr,   vr,   vi,   vr,   vr\")\n+\t      (match_operand:VI 3 \"register_operand\"     \"   vr,   vr,   vr,   vi,   vr\"))\n+\t    (match_operand:VI 4 \"vector_arith_operand\"   \"   vr,   vi,   vr,   vr,   vr\"))\n+\t  (match_operand:VI 5 \"register_operand\"         \"    0,   vr,   vr,   vr,   vr\")))]\n+  \"TARGET_VECTOR\n+   && !rtx_equal_p (operands[2], operands[5])\n+   && !rtx_equal_p (operands[3], operands[5])\n+   && !rtx_equal_p (operands[4], operands[5])\"\n+  \"@\n+   vmv.v.v\\t%0,%4\\;v<macc_nmsac>.vv\\t%0,%2,%3%p1\n+   #\n+   #\n+   #\n+   #\"\n+  \"&& reload_completed\n+   && !rtx_equal_p (operands[0], operands[5])\"\n+  {\n+    if (satisfies_constraint_vi (operands[3]))\n+      std::swap (operands[2], operands[3]);\n+\n+    if (satisfies_constraint_vi (operands[2]))\n+      {\n+        emit_insn (gen_pred_merge<mode> (operands[0], RVV_VUNDEF (<MODE>mode),\n+                \toperands[5], operands[2], operands[1], operands[6],\n+\t\t\toperands[7], operands[9]));\n+        operands[5] = operands[2] = operands[0];\n+      }\n+    else\n+      {\n+        emit_insn (gen_pred_merge<mode> (operands[0], RVV_VUNDEF (<MODE>mode),\n+                \toperands[5], operands[4], operands[1], operands[6], \n+\t\t\toperands[7], operands[9]));\n+        operands[5] = operands[4] = operands[0];\n+      }\n+  }\n+  [(set_attr \"type\" \"vimuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_expand \"@pred_mul_<optab><mode>_scalar\"\n+  [(set (match_operand:VI_QHS 0 \"register_operand\")\n+\t(if_then_else:VI_QHS\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (match_operand 9 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VI_QHS\n+\t    (mult:VI_QHS\n+\t      (vec_duplicate:VI_QHS\n+\t        (match_operand:<VEL> 2 \"reg_or_int_operand\"))\n+\t      (match_operand:VI_QHS 3 \"register_operand\"))\n+\t    (match_operand:VI_QHS 4 \"register_operand\"))\n+\t  (match_operand:VI_QHS 5 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+{\n+  operands[2] = force_reg (<VEL>mode, operands[2]);\n+})\n+\n+(define_insn \"*pred_mul_<optab><mode>_undef_merge_scalar\"\n+  [(set (match_operand:VI 0 \"register_operand\"             \"=vd, vr, vd, vr, ?&vr\")\n+\t(if_then_else:VI\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"   \" vm,Wc1, vm,Wc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"      \" rK, rK, rK, rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"          \"  i,  i,  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"          \"  i,  i,  i,  i,    i\")\n+\t     (match_operand 9 \"const_int_operand\"          \"  i,  i,  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VI\n+\t    (mult:VI\n+\t      (vec_duplicate:VI\n+\t        (match_operand:<VEL> 2 \"register_operand\" \"   r,  r,  r,  r,    r\"))\n+\t      (match_operand:VI 3 \"register_operand\"       \"  0,  0, vr, vr,   vr\"))\n+\t    (match_operand:VI 4 \"register_operand\"         \" vr, vr,  0,  0,   vr\"))\n+\t  (match_operand:VI 5 \"vector_undef_operand\"       \" vu, vu, vu, vu,   vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   v<madd_nmsub>.vx\\t%0,%2,%4%p1\n+   v<madd_nmsub>.vx\\t%0,%2,%4%p1\n+   v<macc_nmsac>.vx\\t%0,%2,%3%p1\n+   v<macc_nmsac>.vx\\t%0,%2,%3%p1\n+   vmv.v.v\\t%0,%4\\;v<macc_nmsac>.vx\\t%0,%2,%3%p1\"\n+  [(set_attr \"type\" \"vimuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*pred_<madd_nmsub><mode>_scalar\"\n+  [(set (match_operand:VI 0 \"register_operand\"            \"=vd, vr, ?&vr\")\n+\t(if_then_else:VI\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"  \" vm,Wc1,vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"     \" rK, rK,   rK\")\n+\t     (match_operand 6 \"const_int_operand\"         \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"         \"  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"         \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VI\n+\t    (mult:VI\n+\t      (vec_duplicate:VI\n+\t        (match_operand:<VEL> 2 \"register_operand\" \"  r,  r,   vr\"))\n+\t      (match_operand:VI 3 \"register_operand\"      \"  0,  0,   vr\"))\n+\t    (match_operand:VI 4 \"register_operand\"        \" vr, vr,   vr\"))\n+\t  (match_dup 3)))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   v<madd_nmsub>.vx\\t%0,%2,%4%p1\n+   v<madd_nmsub>.vx\\t%0,%2,%4%p1\n+   vmv.v.v\\t%0,%2\\;v<madd_nmsub>.vx\\t%0,%2,%4%p1\"\n+  [(set_attr \"type\" \"vimuladd\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"merge_op_idx\" \"4\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"ta\") (symbol_ref \"riscv_vector::get_ta(operands[6])\"))\n+   (set (attr \"ma\") (symbol_ref \"riscv_vector::get_ma(operands[7])\"))\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[8])\"))])\n+\n+(define_insn \"*pred_<macc_nmsac><mode>_scalar\"\n+  [(set (match_operand:VI 0 \"register_operand\"            \"=vd, vr, ?&vr\")\n+\t(if_then_else:VI\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"  \" vm,Wc1,vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"     \" rK, rK,   rK\")\n+\t     (match_operand 6 \"const_int_operand\"         \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"         \"  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"         \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VI\n+\t    (mult:VI\n+\t      (vec_duplicate:VI\n+\t        (match_operand:<VEL> 2 \"register_operand\" \"  r,  r,   vr\"))\n+\t      (match_operand:VI 3 \"register_operand\"      \" vr, vr,   vr\"))\n+\t    (match_operand:VI 4 \"register_operand\"        \"  0,  0,   vr\"))\n+\t  (match_dup 4)))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   v<macc_nmsac>.vx\\t%0,%2,%3%p1\n+   v<macc_nmsac>.vx\\t%0,%2,%3%p1\n+   vmv.v.v\\t%0,%4\\;v<macc_nmsac>.vx\\t%0,%2,%3%p1\"\n+  [(set_attr \"type\" \"vimuladd\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"merge_op_idx\" \"2\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"ta\") (symbol_ref \"riscv_vector::get_ta(operands[6])\"))\n+   (set (attr \"ma\") (symbol_ref \"riscv_vector::get_ma(operands[7])\"))\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[8])\"))])\n+\n+(define_insn_and_rewrite \"*pred_mul_<optab><mode>_scalar\"\n+  [(set (match_operand:VI 0 \"register_operand\"            \"=&vr, ?&vr, ?&vr, ?&vr\")\n+\t(if_then_else:VI\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \"vmWc1,vmWc1,vmWc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"    \"   rK,   rK,   rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"        \"    i,    i,    i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"    i,    i,    i,    i\")\n+\t     (match_operand 9 \"const_int_operand\"        \"    i,    i,    i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VI\n+\t    (mult:VI\n+\t      (vec_duplicate:VI\n+\t        (match_operand:<VEL> 2 \"register_operand\" \"    r,    r,    r,    r\"))\n+\t      (match_operand:VI 3 \"register_operand\"      \"   vr,   vr,   vi,   vr\"))\n+\t    (match_operand:VI 4 \"vector_arith_operand\"    \"   vr,   vi,   vr,   vr\"))\n+\t  (match_operand:VI 5 \"register_operand\"          \"    0,   vr,   vr,   vr\")))]\n+  \"TARGET_VECTOR\n+   && !rtx_equal_p (operands[3], operands[5])\n+   && !rtx_equal_p (operands[4], operands[5])\"\n+  \"@\n+   vmv.v.v\\t%0,%4\\;v<macc_nmsac>.vx\\t%0,%2,%3%p1\n+   #\n+   #\n+   #\"\n+  \"&& reload_completed\n+   && !rtx_equal_p (operands[0], operands[5])\"\n+  {\n+    if (satisfies_constraint_vi (operands[3]))\n+      {\n+        emit_insn (gen_pred_merge<mode> (operands[0], RVV_VUNDEF (<MODE>mode),\n+                \toperands[5], operands[3], operands[1], operands[6],\n+\t\t\toperands[7], operands[9]));\n+        operands[5] = operands[3] = operands[0];\n+      }\n+    else\n+      {\n+        emit_insn (gen_pred_merge<mode> (operands[0], RVV_VUNDEF (<MODE>mode),\n+                \toperands[5], operands[4], operands[1], operands[6],\n+\t\t\toperands[7], operands[9]));\n+        operands[5] = operands[4] = operands[0];\n+      }\n+  }\n+  [(set_attr \"type\" \"vimuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_expand \"@pred_mul_<optab><mode>_scalar\"\n+  [(set (match_operand:VI_D 0 \"register_operand\")\n+\t(if_then_else:VI_D\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (match_operand 9 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VI_D\n+\t    (mult:VI_D\n+\t      (vec_duplicate:VI_D\n+\t        (match_operand:<VEL> 2 \"reg_or_int_operand\"))\n+\t      (match_operand:VI_D 3 \"register_operand\"))\n+\t    (match_operand:VI_D 4 \"register_operand\"))\n+\t  (match_operand:VI_D 5 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+{\n+  if (!TARGET_64BIT)\n+    {\n+      rtx v = gen_reg_rtx (<MODE>mode);\n+\n+      if (riscv_vector::simm32_p (operands[2]))\n+        operands[2] = gen_rtx_SIGN_EXTEND (<VEL>mode,\n+      \t\tforce_reg (Pmode, operands[2]));\n+      else\n+        {\n+          if (CONST_INT_P (operands[2]))\n+            operands[2] = force_reg (<VEL>mode, operands[2]);\n+\n+\t  riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n+\t\t\tv, operands[2], operands[6], <VM>mode);\n+\t  emit_insn (gen_pred_mul_<optab><mode> (operands[0], operands[1],\n+\t\t\tv, operands[3], operands[4], operands[5], operands[6],\n+\t\t\toperands[7], operands[8], operands[9]));\n+\t  DONE;\n+\t}\n+    }\n+   else\n+    operands[2] = force_reg (<VEL>mode, operands[2]);\n+})\n+\n+(define_insn \"*pred_mul_<optab><mode>_undef_merge_extended_scalar\"\n+  [(set (match_operand:VI_D 0 \"register_operand\"               \"=vd, vr, vd, vr, ?&vr\")\n+\t(if_then_else:VI_D\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"       \" vm,Wc1, vm,Wc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"          \" rK, rK, rK, rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"              \"  i,  i,  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"              \"  i,  i,  i,  i,    i\")\n+\t     (match_operand 9 \"const_int_operand\"              \"  i,  i,  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VI_D\n+\t    (mult:VI_D\n+\t      (vec_duplicate:VI_D\n+\t        (sign_extend:<VEL>\n+\t          (match_operand:<VSUBEL> 2 \"register_operand\" \"  r,  r,  r,  r,    r\")))\n+\t      (match_operand:VI_D 3 \"register_operand\"         \"  0,  0, vr, vr,   vr\"))\n+\t    (match_operand:VI_D 4 \"register_operand\"           \" vr, vr,  0,  0,   vr\"))\n+\t  (match_operand:VI_D 5 \"vector_undef_operand\"         \" vu, vu, vu, vu,   vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   v<madd_nmsub>.vx\\t%0,%2,%4%p1\n+   v<madd_nmsub>.vx\\t%0,%2,%4%p1\n+   v<macc_nmsac>.vx\\t%0,%2,%3%p1\n+   v<macc_nmsac>.vx\\t%0,%2,%3%p1\n+   vmv.v.v\\t%0,%4\\;v<macc_nmsac>.vx\\t%0,%2,%3%p1\"\n+  [(set_attr \"type\" \"vimuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*pred_<madd_nmsub><mode>_extended_scalar\"\n+  [(set (match_operand:VI_D 0 \"register_operand\"               \"=vd, vr, ?&vr\")\n+\t(if_then_else:VI_D\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"       \" vm,Wc1,vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"          \" rK, rK,   rK\")\n+\t     (match_operand 6 \"const_int_operand\"              \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"              \"  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"              \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VI_D\n+\t    (mult:VI_D\n+\t      (vec_duplicate:VI_D\n+\t        (sign_extend:<VEL>\n+\t          (match_operand:<VSUBEL> 2 \"register_operand\" \"  r,  r,   vr\")))\n+\t      (match_operand:VI_D 3 \"register_operand\"         \"  0,  0,   vr\"))\n+\t    (match_operand:VI_D 4 \"register_operand\"           \" vr, vr,   vr\"))\n+\t  (match_dup 3)))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   v<madd_nmsub>.vx\\t%0,%2,%4%p1\n+   v<madd_nmsub>.vx\\t%0,%2,%4%p1\n+   vmv.v.v\\t%0,%2\\;v<madd_nmsub>.vx\\t%0,%2,%4%p1\"\n+  [(set_attr \"type\" \"vimuladd\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"merge_op_idx\" \"4\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"ta\") (symbol_ref \"riscv_vector::get_ta(operands[6])\"))\n+   (set (attr \"ma\") (symbol_ref \"riscv_vector::get_ma(operands[7])\"))\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[8])\"))])\n+\n+(define_insn \"*pred_<macc_nmsac><mode>_extended_scalar\"\n+  [(set (match_operand:VI_D 0 \"register_operand\"               \"=vd, vr, ?&vr\")\n+\t(if_then_else:VI_D\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"       \" vm,Wc1,vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"          \" rK, rK,   rK\")\n+\t     (match_operand 6 \"const_int_operand\"              \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"              \"  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"              \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VI_D\n+\t    (mult:VI_D\n+\t      (vec_duplicate:VI_D\n+\t        (sign_extend:<VEL>\n+\t          (match_operand:<VSUBEL> 2 \"register_operand\" \"  r,  r,   vr\")))\n+\t      (match_operand:VI_D 3 \"register_operand\"         \" vr, vr,   vr\"))\n+\t    (match_operand:VI_D 4 \"register_operand\"           \"  0,  0,   vr\"))\n+\t  (match_dup 4)))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   v<macc_nmsac>.vx\\t%0,%2,%3%p1\n+   v<macc_nmsac>.vx\\t%0,%2,%3%p1\n+   vmv.v.v\\t%0,%4\\;v<macc_nmsac>.vx\\t%0,%2,%3%p1\"\n+  [(set_attr \"type\" \"vimuladd\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"merge_op_idx\" \"2\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"ta\") (symbol_ref \"riscv_vector::get_ta(operands[6])\"))\n+   (set (attr \"ma\") (symbol_ref \"riscv_vector::get_ma(operands[7])\"))\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[8])\"))])\n+\n+(define_insn_and_rewrite \"*pred_mul_<optab><mode>_extended_scalar\"\n+  [(set (match_operand:VI_D 0 \"register_operand\"                \"=&vr, ?&vr, ?&vr, ?&vr\")\n+\t(if_then_else:VI_D\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"       \"vmWc1,vmWc1,vmWc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"          \"   rK,   rK,   rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"              \"    i,    i,    i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"              \"    i,    i,    i,    i\")\n+\t     (match_operand 9 \"const_int_operand\"              \"    i,    i,    i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VI_D\n+\t    (mult:VI_D\n+\t      (vec_duplicate:VI_D\n+\t        (sign_extend:<VEL>\n+\t          (match_operand:<VSUBEL> 2 \"register_operand\" \"    r,    r,    r,    r\")))\n+\t      (match_operand:VI_D 3 \"register_operand\"         \"   vr,   vr,   vr,   vr\"))\n+\t    (match_operand:VI_D 4 \"vector_arith_operand\"       \"   vr,   vr,   vr,   vr\"))\n+\t  (match_operand:VI_D 5 \"register_operand\"             \"    0,   vr,   vr,   vr\")))]\n+  \"TARGET_VECTOR\n+   && !rtx_equal_p (operands[3], operands[5])\n+   && !rtx_equal_p (operands[4], operands[5])\"\n+  \"@\n+   vmv.v.v\\t%0,%4\\;v<macc_nmsac>.vx\\t%0,%2,%3%p1\n+   #\n+   #\n+   #\"\n+  \"&& reload_completed\n+   && !rtx_equal_p (operands[0], operands[5])\"\n+  {\n+    if (satisfies_constraint_vi (operands[3]))\n+      {\n+        emit_insn (gen_pred_merge<mode> (operands[0], RVV_VUNDEF (<MODE>mode),\n+                \toperands[5], operands[3], operands[1], operands[6],\n+\t\t\toperands[7], operands[9]));\n+        operands[5] = operands[3] = operands[0];\n+      }\n+    else\n+      {\n+        emit_insn (gen_pred_merge<mode> (operands[0], RVV_VUNDEF (<MODE>mode),\n+                \toperands[5], operands[4], operands[1], operands[6],\n+\t\t\toperands[7], operands[9]));\n+        operands[5] = operands[4] = operands[0];\n+      }\n+  }\n+  [(set_attr \"type\" \"vimuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated integer ternary operations\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 11.14 Vector Widening Integer Multiply-Add Instructions\n+;; -------------------------------------------------------------------------------\n+\n+(define_insn \"@pred_widen_mul_plus<su><mode>\"\n+  [(set (match_operand:VWEXTI 0 \"register_operand\"                    \"=&vr\")\n+\t(if_then_else:VWEXTI\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"             \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"                \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"                    \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"                    \"    i\")\n+\t     (match_operand 9 \"const_int_operand\"                    \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus:VWEXTI\n+\t    (mult:VWEXTI\n+\t      (any_extend:VWEXTI\n+\t        (match_operand:<V_DOUBLE_TRUNC> 3 \"register_operand\" \"   vr\"))\n+\t      (any_extend:VWEXTI\n+\t        (match_operand:<V_DOUBLE_TRUNC> 4 \"register_operand\" \"   vr\")))\n+\t    (match_operand:VWEXTI 2 \"register_operand\"               \"    0\"))\n+\t  (match_operand:VWEXTI 5 \"vector_merge_operand\"             \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vwmacc<u>.vv\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"viwmuladd\")\n+   (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n+\n+(define_insn \"@pred_widen_mul_plus<su><mode>_scalar\"\n+  [(set (match_operand:VWEXTI 0 \"register_operand\"                    \"=&vr\")\n+\t(if_then_else:VWEXTI\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"             \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"                \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"                    \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"                    \"    i\")\n+\t     (match_operand 9 \"const_int_operand\"                    \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus:VWEXTI\n+\t    (mult:VWEXTI\n+\t      (any_extend:VWEXTI\n+\t        (vec_duplicate:<V_DOUBLE_TRUNC>\n+\t          (match_operand:<VSUBEL> 3 \"register_operand\"       \"    r\")))\n+\t      (any_extend:VWEXTI\n+\t        (match_operand:<V_DOUBLE_TRUNC> 4 \"register_operand\" \"   vr\")))\n+\t    (match_operand:VWEXTI 2 \"register_operand\"               \"    0\"))\n+\t  (match_operand:VWEXTI 5 \"vector_merge_operand\"             \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vwmacc<u>.vx\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"viwmuladd\")\n+   (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n+\n+(define_insn \"@pred_widen_mul_plussu<mode>\"\n+  [(set (match_operand:VWEXTI 0 \"register_operand\"                    \"=&vr\")\n+\t(if_then_else:VWEXTI\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"             \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"                \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"                    \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"                    \"    i\")\n+\t     (match_operand 9 \"const_int_operand\"                    \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus:VWEXTI\n+\t    (mult:VWEXTI\n+\t      (sign_extend:VWEXTI\n+\t        (match_operand:<V_DOUBLE_TRUNC> 3 \"register_operand\" \"   vr\"))\n+\t      (zero_extend:VWEXTI\n+\t        (match_operand:<V_DOUBLE_TRUNC> 4 \"register_operand\" \"   vr\")))\n+\t    (match_operand:VWEXTI 2 \"register_operand\"               \"    0\"))\n+\t  (match_operand:VWEXTI 5 \"vector_merge_operand\"             \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vwmaccsu.vv\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"viwmuladd\")\n+   (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n+\n+(define_insn \"@pred_widen_mul_plussu<mode>_scalar\"\n+  [(set (match_operand:VWEXTI 0 \"register_operand\"                    \"=&vr\")\n+\t(if_then_else:VWEXTI\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"             \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"                \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"                    \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"                    \"    i\")\n+\t     (match_operand 9 \"const_int_operand\"                    \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus:VWEXTI\n+\t    (mult:VWEXTI\n+\t      (sign_extend:VWEXTI\n+\t        (vec_duplicate:<V_DOUBLE_TRUNC>\n+\t          (match_operand:<VSUBEL> 3 \"register_operand\"       \"    r\")))\n+\t      (zero_extend:VWEXTI\n+\t        (match_operand:<V_DOUBLE_TRUNC> 4 \"register_operand\" \"   vr\")))\n+\t    (match_operand:VWEXTI 2 \"register_operand\"               \"    0\"))\n+\t  (match_operand:VWEXTI 5 \"vector_merge_operand\"             \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vwmaccsu.vx\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"viwmuladd\")\n+   (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n+\n+(define_insn \"@pred_widen_mul_plusus<mode>_scalar\"\n+  [(set (match_operand:VWEXTI 0 \"register_operand\"                    \"=&vr\")\n+\t(if_then_else:VWEXTI\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"             \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"                \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"                    \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"                    \"    i\")\n+\t     (match_operand 9 \"const_int_operand\"                    \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus:VWEXTI\n+\t    (mult:VWEXTI\n+\t      (zero_extend:VWEXTI\n+\t        (vec_duplicate:<V_DOUBLE_TRUNC>\n+\t          (match_operand:<VSUBEL> 3 \"register_operand\"       \"    r\")))\n+\t      (sign_extend:VWEXTI\n+\t        (match_operand:<V_DOUBLE_TRUNC> 4 \"register_operand\" \"   vr\")))\n+\t    (match_operand:VWEXTI 2 \"register_operand\"               \"    0\"))\n+\t  (match_operand:VWEXTI 5 \"vector_merge_operand\"             \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vwmaccus.vx\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"viwmuladd\")\n+   (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n+\n ;; -------------------------------------------------------------------------------\n ;; ---- Predicated BOOL mask operations\n ;; -------------------------------------------------------------------------------"}]}