{"sha": "39c61276fd8577bec79eff31da4080398a373a24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzljNjEyNzZmZDg1NzdiZWM3OWVmZjMxZGE0MDgwMzk4YTM3M2EyNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-10-22T11:03:17Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-10-22T11:03:17Z"}, "message": "utils.c (unchecked_convert): Use local variables for the biased and reverse SSO attributes of both types.\n\n\t* gcc-interface/utils.c (unchecked_convert): Use local variables for\n\tthe biased and reverse SSO attributes of both types.\n\tFurther extend the processing of integral types in the presence of\n\treverse SSO to all scalar types.\n\nFrom-SVN: r265381", "tree": {"sha": "31b807b3b2ffeae973e2c61ccf6bfd7edd998317", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31b807b3b2ffeae973e2c61ccf6bfd7edd998317"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39c61276fd8577bec79eff31da4080398a373a24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39c61276fd8577bec79eff31da4080398a373a24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39c61276fd8577bec79eff31da4080398a373a24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39c61276fd8577bec79eff31da4080398a373a24/comments", "author": null, "committer": null, "parents": [{"sha": "9e4cacfab2d836d4dabc0b2aac095e635288bd27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e4cacfab2d836d4dabc0b2aac095e635288bd27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e4cacfab2d836d4dabc0b2aac095e635288bd27"}], "stats": {"total": 203, "additions": 168, "deletions": 35}, "files": [{"sha": "73666129f555cb3bcca520c8603b3295fe25b238", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c61276fd8577bec79eff31da4080398a373a24/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c61276fd8577bec79eff31da4080398a373a24/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=39c61276fd8577bec79eff31da4080398a373a24", "patch": "@@ -1,3 +1,10 @@\n+2018-10-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils.c (unchecked_convert): Use local variables for\n+\tthe biased and reverse SSO attributes of both types.\n+\tFurther extend the processing of integral types in the presence of\n+\treverse SSO to all scalar types.\n+\n 2018-10-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Pragma_to_gnu) <Pragma_Inspection_Point>: Use"}, {"sha": "e7dfb41d1415750b3fab744b903a3213eedf3a10", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 52, "deletions": 35, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c61276fd8577bec79eff31da4080398a373a24/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c61276fd8577bec79eff31da4080398a373a24/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=39c61276fd8577bec79eff31da4080398a373a24", "patch": "@@ -5092,8 +5092,16 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n   tree etype = TREE_TYPE (expr);\n   enum tree_code ecode = TREE_CODE (etype);\n   enum tree_code code = TREE_CODE (type);\n+  const bool ebiased\n+    = (ecode == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (etype));\n+  const bool biased\n+    = (code == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (type));\n+  const bool ereverse\n+    = (AGGREGATE_TYPE_P (etype) && TYPE_REVERSE_STORAGE_ORDER (etype));\n+  const bool reverse\n+    = (AGGREGATE_TYPE_P (type) && TYPE_REVERSE_STORAGE_ORDER (type));\n   tree tem;\n-  int c;\n+  int c = 0;\n \n   /* If the expression is already of the right type, we are done.  */\n   if (etype == type)\n@@ -5109,15 +5117,15 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \t   || (ecode == RECORD_TYPE && TYPE_JUSTIFIED_MODULAR_P (etype))))\n       || code == UNCONSTRAINED_ARRAY_TYPE)\n     {\n-      if (ecode == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (etype))\n+      if (ebiased)\n \t{\n \t  tree ntype = copy_type (etype);\n \t  TYPE_BIASED_REPRESENTATION_P (ntype) = 0;\n \t  TYPE_MAIN_VARIANT (ntype) = ntype;\n \t  expr = build1 (NOP_EXPR, ntype, expr);\n \t}\n \n-      if (code == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (type))\n+      if (biased)\n \t{\n \t  tree rtype = copy_type (type);\n \t  TYPE_BIASED_REPRESENTATION_P (rtype) = 0;\n@@ -5146,30 +5154,35 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n      Finally, for the sake of consistency, we do the unchecked conversion\n      to an integral type with reverse storage order as soon as the source\n      type is an aggregate type with reverse storage order, even if there\n-     are no considerations of precision or size involved.  */\n-  else if (INTEGRAL_TYPE_P (type)\n-\t   && TYPE_RM_SIZE (type)\n-\t   && (tree_int_cst_compare (TYPE_RM_SIZE (type),\n-\t\t\t\t     TYPE_SIZE (type)) < 0\n-\t       || (AGGREGATE_TYPE_P (etype)\n-\t\t   && TYPE_REVERSE_STORAGE_ORDER (etype))))\n+     are no considerations of precision or size involved.  Ultimately, we\n+     further extend this processing to any scalar type.  */\n+  else if ((INTEGRAL_TYPE_P (type)\n+\t    && TYPE_RM_SIZE (type)\n+\t    && ((c = tree_int_cst_compare (TYPE_RM_SIZE (type),\n+\t\t\t\t\t   TYPE_SIZE (type))) < 0\n+\t\t|| ereverse))\n+\t   || (SCALAR_FLOAT_TYPE_P (type) && ereverse))\n     {\n       tree rec_type = make_node (RECORD_TYPE);\n-      unsigned HOST_WIDE_INT prec = TREE_INT_CST_LOW (TYPE_RM_SIZE (type));\n       tree field_type, field;\n \n-      if (AGGREGATE_TYPE_P (etype))\n-\tTYPE_REVERSE_STORAGE_ORDER (rec_type)\n-\t  = TYPE_REVERSE_STORAGE_ORDER (etype);\n+      TYPE_REVERSE_STORAGE_ORDER (rec_type) = ereverse;\n \n-      if (type_unsigned_for_rm (type))\n-\tfield_type = make_unsigned_type (prec);\n+      if (c < 0)\n+\t{\n+\t  const unsigned HOST_WIDE_INT prec\n+\t    = TREE_INT_CST_LOW (TYPE_RM_SIZE (type));\n+\t  if (type_unsigned_for_rm (type))\n+\t    field_type = make_unsigned_type (prec);\n+\t  else\n+\t    field_type = make_signed_type (prec);\n+\t  SET_TYPE_RM_SIZE (field_type, TYPE_RM_SIZE (type));\n+\t}\n       else\n-\tfield_type = make_signed_type (prec);\n-      SET_TYPE_RM_SIZE (field_type, TYPE_RM_SIZE (type));\n+\tfield_type = type;\n \n       field = create_field_decl (get_identifier (\"OBJ\"), field_type, rec_type,\n-\t\t\t\t NULL_TREE, bitsize_zero_node, 1, 0);\n+\t\t\t\t NULL_TREE, bitsize_zero_node, c < 0, 0);\n \n       finish_record_type (rec_type, field, 1, false);\n \n@@ -5184,31 +5197,35 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \n      The same considerations as above apply if the target type is an aggregate\n      type with reverse storage order and we also proceed similarly.  */\n-  else if (INTEGRAL_TYPE_P (etype)\n-\t   && TYPE_RM_SIZE (etype)\n-\t   && (tree_int_cst_compare (TYPE_RM_SIZE (etype),\n-\t\t\t\t     TYPE_SIZE (etype)) < 0\n-\t       || (AGGREGATE_TYPE_P (type)\n-\t\t   && TYPE_REVERSE_STORAGE_ORDER (type))))\n+  else if ((INTEGRAL_TYPE_P (etype)\n+\t    && TYPE_RM_SIZE (etype)\n+\t    && ((c = tree_int_cst_compare (TYPE_RM_SIZE (etype),\n+\t\t\t\t\t   TYPE_SIZE (etype))) < 0\n+\t\t|| reverse))\n+\t   || (SCALAR_FLOAT_TYPE_P (etype) && reverse))\n     {\n       tree rec_type = make_node (RECORD_TYPE);\n-      unsigned HOST_WIDE_INT prec = TREE_INT_CST_LOW (TYPE_RM_SIZE (etype));\n       vec<constructor_elt, va_gc> *v;\n       vec_alloc (v, 1);\n       tree field_type, field;\n \n-      if (AGGREGATE_TYPE_P (type))\n-\tTYPE_REVERSE_STORAGE_ORDER (rec_type)\n-\t  = TYPE_REVERSE_STORAGE_ORDER (type);\n+      TYPE_REVERSE_STORAGE_ORDER (rec_type) = reverse;\n \n-      if (type_unsigned_for_rm (etype))\n-\tfield_type = make_unsigned_type (prec);\n+      if (c < 0)\n+\t{\n+\t  const unsigned HOST_WIDE_INT prec\n+\t    = TREE_INT_CST_LOW (TYPE_RM_SIZE (etype));\n+\t  if (type_unsigned_for_rm (etype))\n+\t    field_type = make_unsigned_type (prec);\n+\t  else\n+\t    field_type = make_signed_type (prec);\n+\t  SET_TYPE_RM_SIZE (field_type, TYPE_RM_SIZE (etype));\n+\t}\n       else\n-\tfield_type = make_signed_type (prec);\n-      SET_TYPE_RM_SIZE (field_type, TYPE_RM_SIZE (etype));\n+\tfield_type = etype;\n \n       field = create_field_decl (get_identifier (\"OBJ\"), field_type, rec_type,\n-\t\t\t\t NULL_TREE, bitsize_zero_node, 1, 0);\n+\t\t\t\t NULL_TREE, bitsize_zero_node, c < 0, 0);\n \n       finish_record_type (rec_type, field, 1, false);\n \n@@ -5308,8 +5325,8 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n      signed and have the same precision.  */\n   tree type_rm_size;\n   if (!notrunc_p\n+      && !biased\n       && INTEGRAL_TYPE_P (type)\n-      && !(code == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (type))\n       && (type_rm_size = TYPE_RM_SIZE (type))\n       && tree_int_cst_compare (type_rm_size, TYPE_SIZE (type)) < 0\n       && !(INTEGRAL_TYPE_P (etype)"}, {"sha": "fa4247ac1651672efc2cd94ea3ed8753b1f84b1e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c61276fd8577bec79eff31da4080398a373a24/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c61276fd8577bec79eff31da4080398a373a24/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=39c61276fd8577bec79eff31da4080398a373a24", "patch": "@@ -1,3 +1,8 @@\n+2018-10-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/sso14.adb: New test.\n+\t* gnat.dg/sso15.adb: Likewise.\n+\n 2018-10-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/warn19.ad[sb]: New test."}, {"sha": "6c50f15252473e748d9f213c4ab900a3ce0d0c6b", "filename": "gcc/testsuite/gnat.dg/sso14.adb", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c61276fd8577bec79eff31da4080398a373a24/gcc%2Ftestsuite%2Fgnat.dg%2Fsso14.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c61276fd8577bec79eff31da4080398a373a24/gcc%2Ftestsuite%2Fgnat.dg%2Fsso14.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso14.adb?ref=39c61276fd8577bec79eff31da4080398a373a24", "patch": "@@ -0,0 +1,52 @@\n+--  { dg-do run }\n+--  { dg-options \"-gnatws\" }\n+\n+with System;\n+with Ada.Unchecked_Conversion;\n+\n+procedure SSO14 is\n+\n+   type Arr is array (1 .. Integer'Size) of Boolean;\n+   pragma Pack (Arr);\n+   for Arr'Scalar_Storage_Order use System.High_Order_First;\n+\n+   function From_Float is new Ada.Unchecked_Conversion (Float, Arr);\n+   function From_Int is new Ada.Unchecked_Conversion (Integer, Arr);\n+\n+   type R_Float is record\n+     F : Float;\n+   end record;\n+   for R_Float'Bit_Order use System.High_Order_First;\n+   for R_Float'Scalar_Storage_Order use System.High_Order_First;\n+\n+   type R_Int is record\n+     I : Integer;\n+   end record;\n+   for R_Int'Bit_Order use System.High_Order_First;\n+   for R_Int'Scalar_Storage_Order use System.High_Order_First;\n+\n+   F1 : Float := 1.234567;\n+   FA : Arr;\n+   F2 : R_Float;\n+   for F2'Address use FA'Address;\n+   pragma Import (Ada, F2);\n+\n+   I1 : Integer := 1234567;\n+   IA : Arr;\n+   I2 : R_Int;\n+   for I2'Address use IA'Address;\n+   pragma Import (Ada, I2);\n+\n+begin\n+   -- Check that converting a FP value yields a big-endian array\n+   FA := From_Float (F1);\n+   if F2.F /= F1 then\n+      raise Program_Error;\n+   end if;\n+\n+   -- Check that converting an integer value yields a big-endian array.\n+   IA := From_Int (I1);\n+   if I2.I /= I1 then\n+      raise Program_Error;\n+   end if;\n+end;"}, {"sha": "19d255a639516565959a3a00cb4f2591a789863e", "filename": "gcc/testsuite/gnat.dg/sso15.adb", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c61276fd8577bec79eff31da4080398a373a24/gcc%2Ftestsuite%2Fgnat.dg%2Fsso15.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c61276fd8577bec79eff31da4080398a373a24/gcc%2Ftestsuite%2Fgnat.dg%2Fsso15.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso15.adb?ref=39c61276fd8577bec79eff31da4080398a373a24", "patch": "@@ -0,0 +1,52 @@\n+--  { dg-do run }\n+--  { dg-options \"-gnatws\" }\n+\n+with System;\n+with Ada.Unchecked_Conversion;\n+\n+procedure SSO15 is\n+\n+   type Arr is array (1 .. Integer'Size) of Boolean;\n+   pragma Pack (Arr);\n+   for Arr'Scalar_Storage_Order use System.High_Order_First;\n+\n+   function To_Float is new Ada.Unchecked_Conversion (Arr, Float);\n+   function To_Int is new Ada.Unchecked_Conversion (Arr, Integer);\n+\n+   type R_Float is record\n+     F : Float;\n+   end record;\n+   for R_Float'Bit_Order use System.High_Order_First;\n+   for R_Float'Scalar_Storage_Order use System.High_Order_First;\n+\n+   type R_Int is record\n+     I : Integer;\n+   end record;\n+   for R_Int'Bit_Order use System.High_Order_First;\n+   for R_Int'Scalar_Storage_Order use System.High_Order_First;\n+\n+   A : Arr := (1 .. 2 => True, others => False);\n+\n+   F1 : Float;\n+   F2 : R_Float;\n+   for F2'Address use A'Address;\n+   pragma Import (Ada, F2);\n+\n+   I1 : Integer;\n+   I2 : R_Int;\n+   for I2'Address use A'Address;\n+   pragma Import (Ada, I2);\n+\n+begin\n+   -- Check that converting to FP yields a big-endian value.\n+   F1 := To_Float (A);\n+   if F2.F /= F1 then\n+      raise Program_Error;\n+   end if;\n+\n+   -- Check that converting to integer yields a big-endian value.\n+   I1 := To_Int (A);\n+   if I2.I /= I1 then\n+      raise Program_Error;\n+   end if;\n+end;"}]}