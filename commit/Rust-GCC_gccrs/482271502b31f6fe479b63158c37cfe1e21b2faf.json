{"sha": "482271502b31f6fe479b63158c37cfe1e21b2faf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgyMjcxNTAyYjMxZjZmZTQ3OWI2MzE1OGMzN2NmZTFlMjFiMmZhZg==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1991-12-26T10:05:42Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1991-12-26T10:05:42Z"}, "message": "Initial revision\n\nFrom-SVN: r142", "tree": {"sha": "9d830b14dc0b1dab3fb2577a9f05241d7621865b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d830b14dc0b1dab3fb2577a9f05241d7621865b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/482271502b31f6fe479b63158c37cfe1e21b2faf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/482271502b31f6fe479b63158c37cfe1e21b2faf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/482271502b31f6fe479b63158c37cfe1e21b2faf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/482271502b31f6fe479b63158c37cfe1e21b2faf/comments", "author": null, "committer": null, "parents": [{"sha": "c0f940efefa53e8992d6a86bd759433f68ab37ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0f940efefa53e8992d6a86bd759433f68ab37ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0f940efefa53e8992d6a86bd759433f68ab37ef"}], "stats": {"total": 1938, "additions": 1938, "deletions": 0}, "files": [{"sha": "f69fd9f5ab00256a3a0f39c43a127e9ad9f8d2f7", "filename": "gcc/reg-stack.c", "status": "added", "additions": 1938, "deletions": 0, "changes": 1938, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482271502b31f6fe479b63158c37cfe1e21b2faf/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482271502b31f6fe479b63158c37cfe1e21b2faf/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=482271502b31f6fe479b63158c37cfe1e21b2faf", "patch": "@@ -0,0 +1,1938 @@\n+/* Register to Stack convert for GNU compiler.\n+   Copyright (C) 1990 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* This pass converts stack-like registers from the \"flat register\n+   file\" model that gcc uses, to a stack convention that the 387 uses.\n+\n+   * The form of the input:\n+\n+   On input, the function consists of insn that have had their\n+   registers fully allocated to a set of \"virtual\" registers.  Note that\n+   the word \"virtual\" is used differently here than elsewhere in gcc: for\n+   each virtual stack reg, there is a hard reg, but the mapping between\n+   them is not known until this pass is run.  On output, hard register\n+   numbers have been substituted, and various pop and exchange insns have\n+   been emitted.  The hard register numbers and the virtual register\n+   numbers completely overlap - before this pass, all stack register\n+   numbers are virtual, and afterward they are all hard, with the\n+   exception of ASM_OPERANDS, which are discussed below.\n+\n+   The virtual registers can be manipulated normally by gcc, and their\n+   semantics are the same as for normal registers.  After the hard\n+   register numbers are substituted, the semantics of an insn containing\n+   stack-like regs are not the same as for an insn with normal regs: for\n+   instance, it is not safe to delete an insn that appears to be a no-op\n+   move.  In general, no insn containing hard regs should be changed\n+   after this pass is done.\n+\n+   * The form of the output:\n+\n+   After this pass, hard register numbers represent the distance from\n+   the current top of stack to the desired register.  A reference to\n+   FIRST_STACK_REG references the top of stack, FIRST_STACK_REG + 1,\n+   represents the register just below that, and so forth.  Also, REG_DEAD\n+   notes indicate whether or not a stack register should be popped.\n+\n+   A \"swap\" insn looks like a parallel of two patterns, where each\n+   pattern is a SET: one sets A to B, the other B to A.\n+\n+   A \"push\" or \"load\" insn is a SET whose SET_DEST is FIRST_STACK_REG\n+   and whose SET_DEST is REG or MEM.  Any other SET_DEST, such as PLUS,\n+   will replace the existing stack top, not push a new value.\n+\n+   A store insn is a SET whose SET_DEST is FIRST_STACK_REG, and whose\n+   SET_SRC is REG or MEM.\n+\n+   The case where both the SET_SRC and SET_DEST FIRST_STACK_REG\n+   appears ambiguous.  As a special case, the presence of a REG_DEAD note\n+   for FIRST_STACK_REG differentiates between a load insn and a pop.\n+\n+   If a REG_DEAD is present, the insn represents a \"pop\" that discards\n+   the top of the register stack.  If there is no REG_DEAD note, then the\n+   insn represents a \"dup\" or a push of the current top of stack onto the\n+   stack.\n+\n+   * Methodology:\n+\n+   Existing REG_DEAD and REG_UNUSED notes for stack registers are\n+   deleted and recreated from scratch.  REG_DEAD is never created for a\n+   SET_DEST, only REG_UNUSED.\n+\n+   Before life analysis, the mode of each insn is set based on whether\n+   or not any stack registers are mentioned within that insn.  VOIDmode\n+   means that no regs are mentioned anyway, and QImode means that at\n+   least one pattern within the insn mentions stack registers.  This\n+   information is valid until after reg_to_stack returns, and is used\n+   from jump_optimize.\n+\n+   * Limitations:\n+\n+   Inline assembly isn't handled yet. */\n+\f\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+\n+#ifdef STACK_REGS\n+\n+#define REG_STACK_SIZE (LAST_STACK_REG - FIRST_STACK_REG + 1)\n+\n+/* True if the current function returns a real value. */\n+static int current_function_returns_real;\n+\n+/* This is the basic stack record.  TOP is an index into REG[] such\n+   that REG[TOP] is the top of stack.  If TOP is -1 the stack is empty.\n+\n+   If TOP is -2 the stack is not yet initialized: reg_set indicates\n+   which registers are live.  Stack initialization consists of placing\n+   each live reg in array `reg' and setting `top' appropriately. */\n+\n+typedef struct stack_def\n+{\n+  int top;\t\t\t/* index to top stack element */\n+  HARD_REG_SET reg_set;\t\t/* set of live registers */\n+  char reg[REG_STACK_SIZE];\t/* register - stack mapping */\n+} *stack;\n+\n+/* highest instruction uid */\n+static int max_uid = 0;\n+\n+/* Number of basic blocks in the current function.  */\n+static int blocks;\n+\n+/* Element N is first insn in basic block N.\n+   This info lasts until we finish compiling the function.  */\n+static rtx *block_begin;\n+\n+/* Element N is last insn in basic block N.\n+   This info lasts until we finish compiling the function.  */\n+static rtx *block_end;\n+\n+/* Element N is nonzero if control can drop into basic block N */\n+static char *block_drops_in;\n+\n+/* Element N says all about the stack at entry block N */\n+static stack block_stack_in;\n+\n+/* Element N says all about the stack life at the end of block N */\n+static HARD_REG_SET *block_out_reg_set;\n+\n+/* This is where the BLOCK_NUM values are really stored.  This is set\n+   up by find_blocks and used there and in life_analysis.  It can be used\n+   later, but only to look up an insn that is the head or tail of some\n+   block.  life_analysis and the stack register conversion process can\n+   add insns within a block. */\n+static short *block_number;\n+\n+/* This is the register file for all register after conversion */\n+static rtx SFmode_reg[FIRST_PSEUDO_REGISTER];\n+static rtx DFmode_reg[FIRST_PSEUDO_REGISTER];\n+\n+/* ??? set of register to delete after ASM_OPERAND */\n+HARD_REG_SET asm_regs;\n+\n+/* Get the basic block number of an insn.  See note at block_number\n+   definition are validity of this information. */\n+\n+#define BLOCK_NUM(INSN)  \\\n+  (((INSN_UID (INSN) > max_uid)\t\\\n+    ? (short *)(abort() , 0)\t\t\\\n+    : block_number)[INSN_UID (INSN)])\n+\n+extern rtx gen_jump ();\n+extern rtx gen_movdf ();\n+extern rtx find_regno_note ();\n+extern rtx emit_jump_insn_before ();\n+extern rtx emit_label_after ();\n+\n+extern rtx dconst0_rtx;\n+\n+/* Forward declarations */\n+\n+static void find_blocks ();\n+static void stack_reg_life_analysis ();\n+static void convert_regs ();\n+static void dump_stack_info ();\n+static void fatal_for_asm ();\n+\f\n+\f\n+/* Return non-zero if any stack register is mentioned somewhere within\n+   PAT. */\n+\n+static int\n+stack_regs_mentioned_p (pat)\n+     register rtx pat;\n+{\n+  register char *fmt;\n+  register int i;\n+\n+  if (STACK_REG_P (pat))\n+    return 1;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (pat));\n+  for (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\n+\t  for (j = XVECLEN (pat, i) - 1; j >= 0; j--)\n+\t    if (stack_regs_mentioned_p (XVECEXP (pat, i, j)))\n+\t      return 1;\n+\t}\n+      else if (fmt[i] == 'e' && stack_regs_mentioned_p (XEXP (pat, i)))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\f\n+/* Convert register usage from \"flat\" register file usage to a \"stack\n+   register file.  FIRST is the first insn in the function, FILE is the\n+   dump file, if used.\n+\n+   First compute the beginning and end of each basic block.  Do a\n+   register life analysis on the stack registers, recording the result\n+   for the head and tail of each basic block.  The convert each insn one\n+   by one.  Run a last jump_optimize() pass, if optimizing, to eliminate\n+   any cross-jumping created when the converter inserts pop insns.*/\n+\n+void\n+reg_to_stack (first, file)\n+     rtx first;\n+     FILE *file;\n+{\n+  register rtx insn;\n+  register int i;\n+  int stack_reg_seen = 0;\n+\n+  current_function_returns_real\n+    = TREE_CODE (TREE_TYPE (DECL_RESULT (current_function_decl))) == REAL_TYPE;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      SFmode_reg[i] = gen_rtx (REG, SFmode, i);\n+      DFmode_reg[i] = gen_rtx (REG, DFmode, i);\n+    }\n+\n+  /* Count the basic blocks.  Also find maximum insn uid.  */\n+  {\n+    register RTX_CODE prev_code = JUMP_INSN;\n+    register RTX_CODE code;\n+\n+    max_uid = 0;\n+    blocks = 0;\n+    for (insn = first; insn; insn = NEXT_INSN (insn))\n+      {\n+\t/* Note that this loop must select the same block boundaries\n+\t   as code in find_blocks. */\n+\n+\tif (INSN_UID (insn) > max_uid)\n+\t  max_uid = INSN_UID (insn);\n+\n+\tcode = GET_CODE (insn);\n+\n+\tif (code == CODE_LABEL\n+\t    || (prev_code != INSN\n+\t\t&& prev_code != CALL_INSN\n+\t\t&& prev_code != CODE_LABEL\n+\t\t&& (code == INSN || code == CALL_INSN || code == JUMP_INSN)))\n+\t  blocks++;\n+\n+\t/* Remember whether or not this insn mentions an FP regs.\n+\t   Check JUMP_INSNs too, in case someone creates a funny PARALLEL. */\n+\n+\tif ((GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN\n+\t     || GET_CODE (insn) == JUMP_INSN)\n+\t    && stack_regs_mentioned_p (PATTERN (insn)))\n+\t  {\n+\t    stack_reg_seen = 1;\n+\t    PUT_MODE (insn, QImode);\n+\t  }\n+\telse\n+\t  PUT_MODE (insn, VOIDmode);\n+\n+\tif (code != NOTE)\n+\t  prev_code = code;\n+      }\n+  }\n+\n+  /* If no stack register reference exists in this insn, there isn't\n+     anything to convert.  */\n+\n+  if (! stack_reg_seen)\n+    return;\n+\n+  /* If there are stack registers, there must be at least one block. */\n+\n+  if (! blocks)\n+    abort ();\n+\n+  /* Allocate some tables that last till end of compiling this function\n+     and some needed only in find_blocks and life_analysis. */\n+\n+  block_begin = (rtx *) alloca (blocks * sizeof (rtx));\n+  block_end = (rtx *) alloca (blocks * sizeof (rtx));\n+  block_drops_in = (char *) alloca (blocks);\n+\n+  block_stack_in = (stack) alloca (blocks * sizeof (struct stack_def));\n+  block_out_reg_set = (HARD_REG_SET *) alloca (blocks * sizeof (HARD_REG_SET));\n+  bzero (block_stack_in, blocks * sizeof (struct stack_def));\n+  bzero (block_out_reg_set, blocks * sizeof (HARD_REG_SET));\n+\n+  block_number = (short *) alloca ((max_uid + 1) * sizeof (short));\n+\n+  find_blocks (first);\n+  stack_reg_life_analysis (first);\n+\n+  /* Dump the life analysis debug information before jump\n+     optimization, as that will destroy the LABEL_REFS we keep the\n+     information in. */\n+\n+  if (file)\n+    dump_stack_info (file);\n+\n+  convert_regs ();\n+\n+  if (optimize)\n+    jump_optimize (first, 2, 0, 0);\n+}\n+\f\n+/* Check PAT, which is in INSN, for LABEL_REFs.  Add INSN to the\n+   label's chain of references, and note which insn contains each\n+   reference. */\n+\n+static void\n+record_label_references (insn, pat)\n+     rtx insn, pat;\n+{\n+  register enum rtx_code code = GET_CODE (pat);\n+  register int i;\n+  register char *fmt;\n+\n+  if (code == LABEL_REF)\n+    {\n+      register rtx label = XEXP (pat, 0);\n+      register rtx ref;\n+\n+      if (GET_CODE (label) != CODE_LABEL)\n+\tabort ();\n+\n+      /* Don't make a duplicate in the code_label's chain. */\n+\n+      for (ref = LABEL_REFS (label); ref != label; ref = LABEL_NEXTREF (ref))\n+\tif (CONTAINING_INSN (ref) == insn)\n+\t  return;\n+\n+      CONTAINING_INSN (pat) = insn;\n+      LABEL_NEXTREF (pat) = LABEL_REFS (label);\n+      LABEL_REFS (label) = pat;\n+\n+      return;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\trecord_label_references (insn, XEXP (pat, i));\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\t  for (j = 0; j < XVECLEN (pat, i); j++)\n+\t    record_label_references (insn, XVECEXP (pat, i, j));\n+\t}\n+    }\n+}\n+\f\n+/* Return a pointer to the REG expression within PAT.  If PAT is not a\n+   REG, possible enclosed by a conversion rtx, return the inner part of\n+   PAT that stopped the search. */\n+\n+static rtx *\n+get_true_reg (pat)\n+     rtx *pat;\n+{\n+  while (GET_CODE (*pat) == SUBREG\n+\t || GET_CODE (*pat) == FLOAT\n+\t || GET_CODE (*pat) == FIX\n+\t || GET_CODE (*pat) == FLOAT_EXTEND\n+\t || GET_CODE (*pat) == FLOAT_TRUNCATE)\n+    pat = & XEXP (*pat, 0);\n+\n+  return pat;\n+}\n+\n+/* If REG is a stack register that is marked dead in REGSTACK, then\n+   record that it is now live. If REG is not DEST, add a death note to\n+   INSN if there isn't one already.  If DEST is not a reg, it is safe to\n+   assume that it does not mention a reg anywhere within. */\n+\n+static void\n+record_note_if_dead (insn, regstack, reg, dest)\n+     rtx insn;\n+     stack regstack;\n+     rtx reg, dest;\n+{\n+  reg = * get_true_reg (& reg);\n+\n+  if (STACK_REG_P (reg))\n+    {\n+      if (! TEST_HARD_REG_BIT (regstack->reg_set, REGNO (reg)))\n+\t{\n+\t  if ((! REG_P (dest) || REGNO (dest) != REGNO (reg))\n+\t      && ! find_regno_note (insn, REG_DEAD, REGNO (reg)))\n+\t    REG_NOTES (insn) = gen_rtx (EXPR_LIST,\n+\t\t\t\t\tREG_DEAD, reg, REG_NOTES (insn));\n+\n+\t  SET_HARD_REG_BIT (regstack->reg_set, REGNO (reg));\n+\t}\n+    }\n+  else\n+    if (stack_regs_mentioned_p (reg))\n+      abort ();\n+}\n+\f\n+/* Scan PAT, which is part of INSN, and record the life & death of\n+   stack registers in REGSTACK.  If a register was dead, but is an input\n+   operand in this insn, then mark the register live and record a death\n+   note.\n+\n+   If a register is dead after this insn, but is an output operand in\n+   this insn, record a REG_UNUSED note.\n+\n+   This function does not know about SET_DESTs that are both input and\n+   output (such as ZERO_EXTRACT) - this cannot happen on a 387. */\n+\n+static void\n+record_reg_life_pat (insn, regstack, pat)\n+     rtx insn;\n+     stack regstack;\n+     rtx pat;\n+{\n+  rtx src, dest;\n+\n+  if (GET_CODE (pat) == CLOBBER\n+      && GET_CODE (PATTERN (insn)) == PARALLEL\n+      && GET_CODE (SET_SRC (XVECEXP (PATTERN (insn), 0, 0))) == ASM_OPERANDS)\n+    {\n+      if (STACK_REG_P (XEXP (pat, 0)))\n+\tabort ();\n+      return;\n+    }\n+\n+  if (GET_CODE (pat) != SET)\n+    return;\n+\n+  dest = * get_true_reg (& SET_DEST (pat));\n+\n+  /* The destination is dead before this insn.  If the destination is\n+     not used after this insn, record this with REG_UNUSED. */\n+\n+  if (STACK_REG_P (dest))\n+    {\n+      /* ??? This check is unnecessary. */\n+\n+      if (find_regno_note (insn, REG_UNUSED, REGNO (dest)))\n+\tabort ();\n+\n+      if (! TEST_HARD_REG_BIT (regstack->reg_set, REGNO (dest)))\n+\tREG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_UNUSED, dest,\n+\t\t\t\t    REG_NOTES (insn));\n+\n+      CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (dest));\n+    }\n+  else\n+    if (dest != cc0_rtx && stack_regs_mentioned_p (dest))\n+      abort ();\n+\n+  src = * get_true_reg (& SET_SRC (pat));\n+\n+  switch (GET_CODE (src))\n+    {\n+      /* ??? get_true_reg will make some of these cases redundant. */\n+\n+    case PLUS:\n+    case MINUS:\n+    case MULT:\n+    case DIV:\n+    case COMPARE:\n+      record_note_if_dead (insn, regstack, XEXP (src, 0), dest);\n+      record_note_if_dead (insn, regstack, XEXP (src, 1), dest);\n+      break;\n+\n+    case ABS:\n+    case NEG:\n+    case SQRT:\n+    case FLOAT_EXTEND:\n+    case FLOAT_TRUNCATE:\n+    case FLOAT:\n+    case UNSIGNED_FLOAT:\n+      record_note_if_dead (insn, regstack, XEXP (src, 0), dest);\n+      break;\n+\n+    case UNSIGNED_FIX:\n+    case FIX:\n+      src = XEXP (src, 0);\n+      if (GET_CODE (src) == FIX)\n+\trecord_note_if_dead (insn, regstack, XEXP (src, 0), dest);\n+      else\n+\trecord_note_if_dead (insn, regstack, src, dest);\n+      break;\n+\n+    case ASM_OPERANDS:\n+      {\n+\tregister int j;\n+\n+\t/* ??? This needs much improvement */\n+\n+\tif (stack_regs_mentioned_p (pat))\n+\t  abort ();\n+\n+\tfor (j = 0; j < XVECLEN (src, 3); j++)\n+\t  record_note_if_dead (insn, regstack, XVECEXP (src, 3, j), dest);\n+      }\n+      break;\n+\n+    case REG:\n+      record_note_if_dead (insn, regstack, src, dest);\n+      break;\n+\n+    default:\n+      /* If a stack register appears in the src RTL, it is a bug, and\n+\t code should be added above to handle it. */\n+\n+      if (stack_regs_mentioned_p (src))\n+\tabort ();\n+    }\n+}\n+\f\n+/* Scan INSN, which is in BLOCK, and record the life & death of stack\n+   registers in REGSTACK.  This function is called to process insns from\n+   the last insn in a block to the first.  The actual scanning is done in\n+   record_reg_life_pat.\n+\n+   If a register is live after a CALL_INSN, but is not a value return\n+   register for that CALL_INSN, then code is emitted to initialize that\n+   register.  The block_end[] data is kept accurate.\n+\n+   Existing death and unset notes for stack registers are deleted\n+   before processing the insn. */\n+\n+static void\n+record_reg_life (insn, block, regstack)\n+     rtx insn;\n+     int block;\n+     stack regstack;\n+{\n+  rtx note, *note_link;\n+\n+  if ((GET_CODE (insn) != INSN && GET_CODE (insn) != CALL_INSN)\n+      || INSN_DELETED_P (insn))\n+    return;\n+\n+  /* Strip death notes for stack regs from this insn */\n+\n+  note_link = &REG_NOTES(insn);\n+  for (note = *note_link; note; note = XEXP (note, 1))\n+    if (STACK_REG_P (XEXP (note, 0))\n+\t&& (REG_NOTE_KIND (note) == REG_DEAD\n+\t    || REG_NOTE_KIND (note) == REG_UNUSED))\n+      *note_link = XEXP (note, 1);\n+    else\n+      note_link = &XEXP (note, 1);\n+\n+  /* Process all patterns in the insn. */\n+\n+  if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+    {\n+      register int i;\n+\n+      for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n+\trecord_reg_life_pat (insn, regstack, XVECEXP (PATTERN (insn), 0, i));\n+    }\n+  else if (GET_MODE (insn) == QImode)\n+    record_reg_life_pat (insn, regstack, PATTERN (insn));\n+\n+  /* There might be a reg that is live after a function call.\n+     Initialize it to zero so that the program does not crash.  See comment\n+     towards the end of stack_reg_life_analysis(). */\n+\n+  if (GET_CODE (insn) == CALL_INSN)\n+    {\n+      int reg = FIRST_FLOAT_REG;\n+\n+      /* If a stack reg is mentioned in a CALL_INSN, it must be as the\n+\t return value; conversely, if a float is returned, a stack reg\n+\t must be mentioned. */\n+\n+      if (stack_regs_mentioned_p (PATTERN (insn)))\n+\treg++;\n+\n+      for (; reg <= LAST_STACK_REG; reg++)\n+\tif (TEST_HARD_REG_BIT (regstack->reg_set, reg))\n+\t  {\n+\t    rtx init, pat;\n+\n+\t    /* The insn will use virtual register numbers, and so\n+\t       convert_regs is expected to process these.  But BLOCK_NUM\n+\t       cannot be used on these insns, because they do not appear in\n+\t       block_number[]. */\n+\n+\t    pat = gen_rtx (SET, VOIDmode, DFmode_reg[reg], dconst0_rtx);\n+\t    init = emit_insn_after (pat, insn);\n+\t    PUT_MODE (init, QImode);\n+\n+\t    CLEAR_HARD_REG_BIT (regstack->reg_set, reg);\n+\n+\t    /* If the CALL_INSN was the end of a block, move the\n+\t       block_end to point to the new insn. */\n+\n+\t    if (block_end[block] == insn)\n+\t      block_end[block] = init;\n+\t  }\n+\n+      /* Some regs do not survive a CALL */\n+\n+      AND_COMPL_HARD_REG_SET (regstack->reg_set, call_used_reg_set);\n+    }\n+}\n+\f\n+/* Find all basic blocks of the function, which starts with FIRST.\n+   For each JUMP_INSN, build the chain of LABEL_REFS on each CODE_LABEL. */\n+\n+static void\n+find_blocks (first)\n+     rtx first;\n+{\n+  register rtx insn;\n+  register int block;\n+  register RTX_CODE prev_code = BARRIER;\n+  register RTX_CODE code;\n+\n+  /* Record where all the blocks start and end.\n+     Record which basic blocks control can drop in to. */\n+\n+  block = -1;\n+  for (insn = first; insn; insn = NEXT_INSN (insn))\n+    {\n+      /* Note that this loop must select the same block boundaries\n+\t as code in reg_to_stack. */\n+\n+      code = GET_CODE (insn);\n+\n+      if (code == CODE_LABEL\n+\t  || (prev_code != INSN\n+\t      && prev_code != CALL_INSN\n+\t      && prev_code != CODE_LABEL\n+\t      && (code == INSN || code == CALL_INSN || code == JUMP_INSN)))\n+\t{\n+\t  block_begin[++block] = insn;\n+\t  block_end[block] = insn;\n+\t  block_drops_in[block] = prev_code != BARRIER;\n+\t}\n+      else if (code == INSN || code == CALL_INSN || code == JUMP_INSN)\n+\tblock_end[block] = insn;\n+\n+      BLOCK_NUM (insn) = block;\n+\n+      if (code == CODE_LABEL)\n+\tLABEL_REFS (insn) = insn; /* delete old chain */\n+\n+      if (code != NOTE)\n+\tprev_code = code;\n+    }\n+\n+  if (block + 1 != blocks)\n+    abort ();\n+\n+  /* generate all label references to the correspondending jump insn */\n+  for (block = 0; block < blocks; block++)\n+    {\n+      insn = block_end[block];\n+\n+      if (GET_CODE (insn) == JUMP_INSN)\n+\trecord_label_references (insn, PATTERN (insn));\n+    }\n+}\n+\f\n+/* Determine the which registers are live at the start of each basic\n+   block of the function whose first insn is FIRST.\n+\n+   First, if the function returns a real_type, mark the function\n+   return type as live at each return point, as the RTL may not give any\n+   hint that the register is live.\n+\n+   Then, start with the last block and work back to the first block.\n+   Similarly, work backwards within each block, insn by insn, recording\n+   which regs are die and which are used (and therefore live) in the\n+   hard reg set of block_stack_in[].\n+\n+   After processing each basic block, if there is a label at the start\n+   of the block, propagate the live registers to all jumps to this block.\n+\n+   As a special case, if there are regs live in this block, that are\n+   not live in a block containing a jump to this label, and the block\n+   containing the jump has already been processed, we must propagate this\n+   block's entry register life back to the block containing the jump, and\n+   restart life analysis from there.\n+\n+   In the worst case, this function may traverse the insns\n+   REG_STACK_SIZE times.  This is necessary, since a jump towards the end\n+   of the insns may not know that a reg is live at a target that is early\n+   in the insns.  So we back up and start over with the new reg live.\n+\n+   If there are registers that are live at the start of the function,\n+   insns are emitted to initialize these registers.  Something similar is\n+   done after CALL_INSNs in record_reg_life. */\n+\n+static void\n+stack_reg_life_analysis (first)\n+     rtx first;\n+{\n+  int reg, block;\n+  struct stack_def regstack;\n+\n+  if (current_function_returns_real)\n+    {\n+      /* Find all RETURN insns and mark them. */\n+\n+      for (block = blocks - 1; block >= 0; block--)\n+\tif (GET_CODE (block_end[block]) == JUMP_INSN\n+\t    && GET_CODE (PATTERN (block_end[block])) == RETURN)\n+\t  SET_HARD_REG_BIT (block_out_reg_set[block], FIRST_STACK_REG);\n+\n+      /* Mark of the end of last block if we \"fall off\" the end of the\n+\t function into the epilogue. */\n+\n+      if (GET_CODE (block_end[blocks-1]) != JUMP_INSN\n+\t  || GET_CODE (PATTERN (block_end[blocks-1])) == RETURN)\n+\tSET_HARD_REG_BIT (block_out_reg_set[blocks-1], FIRST_STACK_REG);\n+    }\n+\n+  /* now scan all blocks backward for stack register use */\n+\n+  block = blocks - 1;\n+  while (block >= 0)\n+    {\n+      register rtx insn, prev;\n+\n+      /* current register status at last instruction */\n+\n+      COPY_HARD_REG_SET (regstack.reg_set, block_out_reg_set[block]);\n+\n+      prev = block_end[block];\n+      do\n+\t{\n+\t  insn = prev;\n+\t  prev = PREV_INSN (insn);\n+\n+\t  /* If the insn is a CALL_INSN, we need to ensure that\n+\t     everything dies.  But otherwise don't process unless there\n+\t     are some stack regs present. */\n+\n+\t  if (GET_MODE (insn) == QImode || GET_CODE (insn) == CALL_INSN)\n+\t    record_reg_life (insn, block, &regstack);\n+\n+\t} while (insn != block_begin[block]);\n+\n+      /* Set the state at the start of the block.  Mark that no\n+\t register mapping information known yet. */\n+\n+      COPY_HARD_REG_SET (block_stack_in[block].reg_set, regstack.reg_set);\n+      block_stack_in[block].top = -2;\n+\n+      /* If there is a label, propagate our register life to all jumps\n+\t to this label. */\n+\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\t{\n+\t  register rtx label;\n+\t  int must_restart = 0;\n+\n+\t  for (label = LABEL_REFS (insn); label != insn;\n+\t       label = LABEL_NEXTREF (label))\n+\t    {\n+\t      int jump_block = BLOCK_NUM (CONTAINING_INSN (label));\n+\n+\t      if (jump_block < block)\n+\t\tIOR_HARD_REG_SET (block_out_reg_set[jump_block],\n+\t\t\t\t  block_stack_in[block].reg_set);\n+\t      else\n+\t\t{\n+\t\t  /* The block containing the jump has already been\n+\t\t     processed.  If there are registers that were not known\n+\t\t     to be live then, but are live now, we must back up\n+\t\t     and restart life analysis from that point with the new\n+\t\t     life information. */\n+\n+\t\t  GO_IF_HARD_REG_SUBSET (block_stack_in[block].reg_set,\n+\t\t\t\t\t block_out_reg_set[jump_block],\n+\t\t\t\t\t win);\n+\n+\t\t  IOR_HARD_REG_SET (block_out_reg_set[jump_block],\n+\t\t\t\t    block_stack_in[block].reg_set);\n+\n+\t\t  block = jump_block;\n+\t\t  must_restart = 1;\n+\n+\t\twin:\n+\t\t  ;\n+\t\t}\n+\t    }\n+\t  if (must_restart)\n+\t    continue;\n+\t}\n+\n+      if (block_drops_in[block])\n+\tIOR_HARD_REG_SET (block_out_reg_set[block-1],\n+\t\t\t  block_stack_in[block].reg_set);\n+\n+      block -= 1;\n+    }\n+\n+  {\n+    /* If any reg is live at the start of the first block of a\n+       function, then we must guarantee that the reg holds some value by\n+       generating our own \"load\" of that register.  Otherwise a 387 would\n+       fault trying to access an empty register. */\n+\n+    HARD_REG_SET empty_regs;\n+    CLEAR_HARD_REG_SET (empty_regs);\n+    GO_IF_HARD_REG_SUBSET (block_stack_in[0].reg_set, empty_regs,\n+\t\t\t   no_live_regs);\n+  }\n+\n+  /* Load zero into each live register.  The fact that a register\n+     appears live at the function start does not necessarily imply an error\n+     in the user program: it merely means that we could not determine that\n+     there wasn't such an error, just as -Wunused sometimes gives\n+     \"incorrect\" warnings.  In those cases, these initializations will do\n+     no harm.\n+\n+     Note that we are inserting virtual register references here:\n+     these insns must be processed by convert_regs later.  Also, these\n+     insns will not be in block_number, so BLOCK_NUM() will fail for them. */\n+\n+  for (reg = LAST_STACK_REG; reg >= FIRST_STACK_REG; reg--)\n+    if (TEST_HARD_REG_BIT (block_stack_in[0].reg_set, reg))\n+      {\n+\trtx init_rtx;\n+\n+\tinit_rtx = gen_rtx (SET, VOIDmode, DFmode_reg[reg], dconst0_rtx);\n+\tblock_begin[0] = emit_insn_after (init_rtx, first);\n+\tPUT_MODE (block_begin[0], QImode);\n+\n+\tCLEAR_HARD_REG_BIT (block_stack_in[0].reg_set, reg);\n+      }\n+\n+ no_live_regs:\n+  ;\n+}\n+\f\n+/*****************************************************************************\n+   This section deals with stack register substition, and forms the second\n+   pass over the RTL.\n+ *****************************************************************************/\n+\n+/* Replace REG, which is a pointer to a stack reg RTX, with an RTX for\n+   the desired hard REGNO. */\n+\n+static void\n+replace_reg (reg, regno)\n+     rtx *reg;\n+     int regno;\n+{\n+  if (regno < FIRST_STACK_REG || regno > LAST_STACK_REG\n+      || ! STACK_REG_P (*reg))\n+    abort ();\n+\n+  if (GET_MODE (*reg) == DFmode)\n+    *reg = DFmode_reg[regno];\n+  else if (GET_MODE (*reg) == SFmode)\n+    *reg = SFmode_reg[regno];\n+  else\n+    abort ();\n+}\n+\n+/* Remove a note of type NOTE, which must be found, for register\n+   number REGNO from INSN.  Remove only one such note. */\n+\n+static void\n+remove_regno_note (insn, note, regno)\n+     rtx insn;\n+     enum reg_note note;\n+     int regno;\n+{\n+  register rtx *note_link, this;\n+\n+  note_link = &REG_NOTES(insn);\n+  for (this = *note_link; this; this = XEXP (this, 1))\n+    if (REG_NOTE_KIND (this) == note\n+\t&& REG_P (XEXP (this, 0)) && REGNO (XEXP (this, 0)) == regno)\n+      {\n+\t*note_link = XEXP (this, 1);\n+\treturn;\n+      }\n+    else\n+      note_link = &XEXP (this, 1);\n+\n+  abort ();\n+}\n+\n+/* Find the hard register number of virtual register REG in REGSTACK.\n+   The hard register number is relative to the top of the stack.  -1 is\n+   returned if the register is not found. */\n+\n+static int\n+get_hard_regnum (regstack, reg)\n+     stack regstack;\n+     rtx reg;\n+{\n+  int i;\n+\n+  if (! STACK_REG_P (reg))\n+    abort ();\n+\n+  for (i = regstack->top; i >= 0; i--)\n+    if (regstack->reg[i] == REGNO (reg))\n+      break;\n+\n+  return i >= 0 ? (FIRST_STACK_REG + regstack->top - i) : -1;\n+}\n+\n+/* Delete INSN from the RTL.  Mark the insn, but don't remove it from\n+   the chain of insns.  Doing so could confuse block_begin and block_end\n+   if this were the only insn in the block. */\n+\n+static void\n+delete_insn_for_stacker (insn)\n+     rtx insn;\n+{\n+  PUT_CODE (insn, NOTE);\n+  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+  NOTE_SOURCE_FILE (insn) = 0;\n+  INSN_DELETED_P (insn) = 1;\n+}\n+\f\n+/* Emit an insn to pop virtual register REG before or after INSN.\n+   REGSTACK is the stack state after INSN and is updated to reflect this\n+   pop.  WHEN is either emit_insn_before or emit_insn_after.  A pop insn\n+   is represented as a SET whose destination is the register to be popped\n+   and source is the top of stack.  A death note for the top of stack\n+   cases the movdf pattern to pop. */\n+\n+static rtx\n+emit_pop_insn (insn, regstack, reg, when)\n+     rtx insn;\n+     stack regstack;\n+     rtx reg;\n+     rtx (*when)();\n+{\n+  rtx pop_insn, pop_rtx;\n+  int hard_regno;\n+\n+  hard_regno = get_hard_regnum (regstack, reg);\n+\n+  if (hard_regno < FIRST_STACK_REG)\n+    abort ();\n+\n+  pop_rtx = gen_rtx (SET, VOIDmode, DFmode_reg[hard_regno],\n+\t\t     DFmode_reg[FIRST_STACK_REG]);\n+\n+  pop_insn = (*when) (pop_rtx, insn);\n+  PUT_MODE (pop_insn, VOIDmode);\n+\n+  REG_NOTES (pop_insn) = gen_rtx (EXPR_LIST,\n+\t\t\t\t  REG_DEAD, DFmode_reg[FIRST_STACK_REG],\n+\t\t\t\t  REG_NOTES (pop_insn));\n+\n+  regstack->reg[regstack->top - (hard_regno - FIRST_STACK_REG)]\n+    = regstack->reg[regstack->top];\n+  regstack->top -= 1;\n+  CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (reg));\n+\n+  return pop_insn;\n+}\n+\f\n+/* Emit an insn before or after INSN to swap virtual register REG with the\n+   top of stack.  WHEN should be `emit_insn_before' or `emit_insn_before'\n+   REGSTACK is the stack state before the swap, and is updated to reflect\n+   the swap.  A swap insn is represented as a PARALLEL of two patterns:\n+   each pattern moves one reg to the other.\n+\n+   If REG is already at the top of the stack, no insn is emitted. */\n+\n+static void\n+emit_hard_swap_insn (insn, regstack, hard_regno, when)\n+     rtx insn;\n+     stack regstack;\n+     int hard_regno;\n+     rtx (*when)();\n+{\n+  rtx gen_swapdf();\n+  rtx swap_rtx, swap_insn;\n+  int tmp, other;\n+\n+  if (hard_regno == FIRST_STACK_REG)\n+    return;\n+\n+  swap_rtx = gen_swapdf (DFmode_reg[hard_regno], DFmode_reg[FIRST_STACK_REG]);\n+  swap_insn = (*when) (swap_rtx, insn);\n+  PUT_MODE (swap_insn, VOIDmode);\n+\n+  other = regstack->top - (hard_regno - FIRST_STACK_REG);\n+\n+  tmp = regstack->reg[other];\n+  regstack->reg[other] = regstack->reg[regstack->top];\n+  regstack->reg[regstack->top] = tmp;\n+}\n+\n+/* Emit an insn before or after INSN to swap virtual register REG with the\n+   top of stack.  See comments before emit_hard_swap_insn. */\n+\n+static void\n+emit_swap_insn (insn, regstack, reg, when)\n+     rtx insn;\n+     stack regstack;\n+     rtx reg;\n+     rtx (*when)();\n+{\n+  int hard_regno;\n+\n+  hard_regno = get_hard_regnum (regstack, reg);\n+\n+  emit_hard_swap_insn (insn, regstack, hard_regno, when);\n+}\n+\f\n+/* Handle a move to or from a stack register in PAT, which is in INSN.\n+   REGSTACK is the current stack. */\n+\n+static void\n+move_for_stack_reg (insn, regstack, pat)\n+     rtx insn;\n+     stack regstack;\n+     rtx pat;\n+{\n+  rtx *src =  get_true_reg (&SET_SRC (pat));\n+  rtx *dest = get_true_reg (&SET_DEST (pat));\n+  rtx note;\n+\n+  if (STACK_REG_P (*src) && STACK_REG_P (*dest))\n+    {\n+      /* Write from one stack reg to another.  If SRC dies here, then\n+\t just change the register mapping and delete the insn. */\n+\n+      note = find_regno_note (insn, REG_DEAD, REGNO (*src));\n+      if (note)\n+\t{\n+\t  int i;\n+\n+\t  /* If this is a no-op move, there must not be a REG_DEAD note. */\n+\t  if (REGNO (*src) == REGNO (*dest))\n+\t    abort ();\n+\n+\t  for (i = regstack->top; i >= 0; i--)\n+\t    if (regstack->reg[i] == REGNO (*src))\n+\t      break;\n+\n+\t  /* The source must be live, and the dest must be dead. */\n+\t  if (i < 0 || get_hard_regnum (regstack, *dest) >= FIRST_STACK_REG)\n+\t    abort ();\n+\n+\t  /* It is possible that the dest is unused after this insn.\n+\t     If so, just pop the src. */\n+\n+\t  if (find_regno_note (insn, REG_UNUSED, REGNO (*dest)))\n+\t    {\n+\t      emit_pop_insn (insn, regstack, *src, emit_insn_after);\n+\n+\t      delete_insn_for_stacker (insn);\n+\t      return;\n+\t    }\n+\n+\t  regstack->reg[i] = REGNO (*dest);\n+\n+\t  SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\t  CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (*src));\n+\n+\t  delete_insn_for_stacker (insn);\n+\n+\t  return;\n+\t}\n+\n+      /* The source reg does not die. */\n+\n+      /* If this appears to be a no-op move, delete it, or else it\n+\t will confuse the machine description output patterns. But if\n+\t it is REG_UNUSED, we must pop the reg now, as per-insn processing\n+\t for REG_UNUSED will not work for deleted insns. */\n+\n+      if (REGNO (*src) == REGNO (*dest))\n+\t{\n+\t  if (find_regno_note (insn, REG_UNUSED, REGNO (*dest)))\n+\t    emit_pop_insn (insn, regstack, *dest, emit_insn_after);\n+\n+\t  delete_insn_for_stacker (insn);\n+\t  return;\n+\t}\n+\n+      /* The destination ought to be dead */\n+      if (get_hard_regnum (regstack, *dest) >= FIRST_STACK_REG)\n+\tabort ();\n+\n+      replace_reg (src, get_hard_regnum (regstack, *src));\n+\n+      regstack->reg[++regstack->top] = REGNO (*dest);\n+      SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+      replace_reg (dest, FIRST_STACK_REG);\n+    }\n+  else if (STACK_REG_P (*src))\n+    {\n+      /* Save from a stack reg to MEM, or possibly integer reg.  Since\n+\t only top of stack may be saved, emit an exchange first if\n+\t needs be. */\n+\n+      emit_swap_insn (insn, regstack, *src, emit_insn_before);\n+\n+      note = find_regno_note (insn, REG_DEAD, REGNO (*src));\n+      if (note)\n+\t{\n+\t  replace_reg (&XEXP (note, 0), FIRST_STACK_REG);\n+\t  regstack->top--;\n+\t  CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (*src));\n+\t}\n+\n+      replace_reg (src, FIRST_STACK_REG);\n+    }\n+  else if (STACK_REG_P (*dest))\n+    {\n+      /* Load from MEM, or possibly integer REG or constant, into the\n+\t stack regs.  The actual target is always the top of the\n+\t stack. The stack mapping is changed to reflect that DEST is\n+\t now at top of stack.  */\n+\n+      /* The destination ought to be dead */\n+      if (get_hard_regnum (regstack, *dest) >= FIRST_STACK_REG)\n+\tabort ();\n+\n+      if (regstack->top >= REG_STACK_SIZE)\n+\tabort ();\n+\n+      regstack->reg[++regstack->top] = REGNO (*dest);\n+      SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+      replace_reg (dest, FIRST_STACK_REG);\n+    }\n+  else\n+    abort ();\n+}\n+\f\n+/* Handle a comparison.  Special care needs to be taken to avoid\n+   causing comparisons that a 387 cannot do correctly, such as EQ.\n+\n+   Also, a pop insn may need to be emitted.  The 387 does have an\n+   `fcompp' insn that can pop two regs, but it is sometimes too expensive\n+   to do this - a `fcomp' followed by a `fstpl %st(0)' may be easier to\n+   set up. */\n+\n+static void\n+compare_for_stack_reg (insn, regstack, pat)\n+     rtx insn;\n+     stack regstack;\n+     rtx pat;\n+{\n+  rtx *src1, *src2;\n+  rtx src1_note, src2_note;\n+\n+  src1 = get_true_reg (&XEXP (SET_SRC (pat), 0));\n+  src2 = get_true_reg (&XEXP (SET_SRC (pat), 1));\n+\n+  /* The first argument must always be a stack reg. */\n+  /* ??? why? */\n+\n+  if (! STACK_REG_P (*src1))\n+    abort ();\n+\n+  /* We will fix any death note later. */\n+\n+  src1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n+\n+  if (STACK_REG_P (*src2))\n+    src2_note = find_regno_note (insn, REG_DEAD, REGNO (*src2));\n+  else\n+    src2_note = 0;\n+\n+  emit_swap_insn (insn, regstack, *src1, emit_insn_before);\n+\n+  replace_reg (src1, FIRST_STACK_REG);\n+\n+  if (STACK_REG_P (*src2))\n+    replace_reg (src2, get_hard_regnum (regstack, *src2));\n+\n+  if (src1_note)\n+    {\n+      CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (XEXP (src1_note, 0)));\n+      replace_reg (&XEXP (src1_note, 0), FIRST_STACK_REG);\n+      regstack->top--;\n+    }\n+\n+  /* If the second operand dies, handle that.  But if the operands are\n+     the same stack register, don't bother, because only one death is\n+     needed, and it was just handled. */\n+\n+  if (src2_note\n+      && ! (STACK_REG_P (*src1)\n+\t    && STACK_REG_P (*src2)\n+\t    && REGNO (*src1) == REGNO (*src2)))\n+    {\n+      /* As a special case, two regs may die in this insn if src2 is\n+\t next to top of stack and the top of stack also dies.  Since\n+\t we have already popped src1, \"next to top of stack\" is really\n+\t at top (FIRST_STACK_REG) now. */\n+\n+      if (get_hard_regnum (regstack, XEXP (src2_note, 0)) == FIRST_STACK_REG\n+\t  && src1_note)\n+\t{\n+\t  CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (XEXP (src2_note, 0)));\n+\t  replace_reg (&XEXP (src2_note, 0), FIRST_STACK_REG + 1);\n+\t  regstack->top--;\n+\t}\n+      else\n+\t{\n+\t  /* The 386 can only represent death of the first operand in\n+\t     the case handled above.  In all other cases, emit a separate\n+\t     pop and remove the death note from here. */\n+\n+\t  remove_regno_note (insn, REG_DEAD, REGNO (XEXP (src2_note, 0)));\n+\n+\t  emit_pop_insn (insn, regstack, XEXP (src2_note, 0),\n+\t\t\t emit_insn_after);\n+\t}\n+    }\n+}\n+\f\n+/* Substitute new registers in PAT, which is part of INSN.  REGSTACK\n+   is the current register layout. */\n+\n+static void\n+subst_stack_regs_pat (insn, regstack, pat)\n+     rtx insn;\n+     stack regstack;\n+     rtx pat;\n+{\n+  rtx *dest, *src;\n+  rtx *src1 = 0, *src2;\n+  rtx src1_note, src2_note;\n+\n+  if (GET_CODE (pat) != SET)\n+    return;\n+\n+  dest = get_true_reg (&SET_DEST (pat));\n+  src  = get_true_reg (&SET_SRC (pat));\n+\n+  /* See if this is a `movM' pattern, and handle elsewhere if so. */\n+\n+  if (*dest != cc0_rtx\n+      && (STACK_REG_P (*src)\n+\t  || (STACK_REG_P (*dest)\n+\t      && (GET_CODE (*src) == REG || GET_CODE (*src) == MEM\n+\t\t  || GET_CODE (*src) == CONST_DOUBLE))))\n+    move_for_stack_reg (insn, regstack, pat);\n+  else\n+    switch (GET_CODE (SET_SRC (pat)))\n+      {\n+      case COMPARE:\n+\tcompare_for_stack_reg (insn, regstack, pat);\n+\tbreak;\n+\n+      case CALL:\n+\tregstack->reg[++regstack->top] = REGNO (*dest);\n+\tSET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\treplace_reg (dest, FIRST_STACK_REG);\n+\tbreak;\n+\n+      case REG:\n+\t/* This is a `tstM2' case. */\n+\tif (*dest != cc0_rtx)\n+\t  abort ();\n+\n+\tsrc1 = src;\n+\n+\t/* Fall through. */\n+\n+      case SQRT:\n+      case ABS:\n+      case NEG:\n+\t/* These insns only operate on the top of the stack. DEST might\n+\t   be cc0_rtx if we're processing a tstM pattern. Also, it's\n+\t   possible that the tstM case results in a REG_DEAD note on the\n+\t   source.  */\n+\n+\tif (src1 == 0)\n+\t  src1 = get_true_reg (&XEXP (SET_SRC (pat), 0));\n+\n+\temit_swap_insn (insn, regstack, *src1, emit_insn_before);\n+\n+\tsrc1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n+\n+\tif (STACK_REG_P (*dest))\n+\t  replace_reg (dest, FIRST_STACK_REG);\n+\n+\tif (src1_note)\n+\t  {\n+\t    replace_reg (&XEXP (src1_note, 0), FIRST_STACK_REG);\n+\t    regstack->top--;\n+\t    CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (*src1));\n+\t  }\n+\n+\treplace_reg (src1, FIRST_STACK_REG);\n+\n+\tbreak;\n+\n+      case MINUS:\n+      case DIV:\n+\t/* On i386, reversed forms of subM3 and divM3 exist for\n+\t   MODE_FLOAT, so the same code that works for addM3 and mulM3\n+\t   can be used. */\n+      case MULT:\n+      case PLUS:\n+\t/* These insns can accept the top of stack as a destination\n+\t   from a stack reg or mem, or can use the top of stack as a\n+\t   source and some other stack register (possibly top of stack)\n+\t   as a destination. */\n+\n+\tsrc1 = get_true_reg (&XEXP (SET_SRC (pat), 0));\n+\tsrc2 = get_true_reg (&XEXP (SET_SRC (pat), 1));\n+\n+\t/* We will fix any death note later. */\n+\n+\tif (STACK_REG_P (*src1))\n+\t  src1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n+\telse\n+\t  src1_note = 0;\n+\tif (STACK_REG_P (*src2))\n+\t  src2_note = find_regno_note (insn, REG_DEAD, REGNO (*src2));\n+\telse\n+\t  src2_note = 0;\n+\n+\t/* If either operand is not a stack register, then the dest\n+\t   must be top of stack. */\n+\n+\tif (! STACK_REG_P (*src1) || ! STACK_REG_P (*src2))\n+\t  emit_swap_insn (insn, regstack, *dest, emit_insn_before);\n+\telse\n+\t  {\n+\t    /* Both operands are REG.  If neither operand is already\n+\t       at the top of stack, choose to make the one that is the dest\n+\t       the new top of stack.\n+\n+\t       ??? A later optimization here would be to look forward\n+\t       in the insns and see which source reg will be needed at top\n+\t       of stack soonest. */\n+\n+\t    int src1_hard_regnum, src2_hard_regnum;\n+\n+\t    src1_hard_regnum = get_hard_regnum (regstack, *src1);\n+\t    src2_hard_regnum = get_hard_regnum (regstack, *src2);\n+\t    if (src1_hard_regnum == -1 || src2_hard_regnum == -1)\n+\t      abort ();\n+\n+\t    if (src1_hard_regnum != FIRST_STACK_REG\n+\t\t&& src2_hard_regnum != FIRST_STACK_REG)\n+\t      emit_swap_insn (insn, regstack, *dest, emit_insn_before);\n+\t  }\n+\n+\tif (STACK_REG_P (*src1))\n+\t  replace_reg (src1, get_hard_regnum (regstack, *src1));\n+\tif (STACK_REG_P (*src2))\n+\t  replace_reg (src2, get_hard_regnum (regstack, *src2));\n+\n+\tif (src1_note)\n+\t  {\n+\t    /* If the register that dies is at the top of stack, then\n+\t       the destination is somewhere else - merely substitute it.\n+\t       But if the reg that dies is not at top of stack, then\n+\t       move the top of stack to the dead reg, as though we had\n+\t       done the insn and then a store-with-pop. */\n+\n+\t    if (REGNO (XEXP (src1_note, 0)) == regstack->reg[regstack->top])\n+\t      {\n+\t\tSET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\t\treplace_reg (dest, get_hard_regnum (regstack, *dest));\n+\t      }\n+\t    else\n+\t      {\n+\t\tint regno = get_hard_regnum (regstack, XEXP (src1_note, 0));\n+\n+\t\tSET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\t\treplace_reg (dest, regno);\n+\n+\t\tregstack->reg[regstack->top - (regno - FIRST_STACK_REG)]\n+\t\t  = regstack->reg[regstack->top];\n+\t      }\n+\n+\t    CLEAR_HARD_REG_BIT (regstack->reg_set,\n+\t\t\t\tREGNO (XEXP (src1_note, 0)));\n+\t    replace_reg (&XEXP (src1_note, 0), FIRST_STACK_REG);\n+\t    regstack->top--;\n+\t  }\n+\telse if (src2_note)\n+\t  {\n+\t    if (REGNO (XEXP (src2_note, 0)) == regstack->reg[regstack->top])\n+\t      {\n+\t\tSET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\t\treplace_reg (dest, get_hard_regnum (regstack, *dest));\n+\t      }\n+\t    else\n+\t      {\n+\t\tint regno = get_hard_regnum (regstack, XEXP (src2_note, 0));\n+\n+\t\tSET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\t\treplace_reg (dest, regno);\n+\n+\t\tregstack->reg[regstack->top - (regno - FIRST_STACK_REG)]\n+\t\t  = regstack->reg[regstack->top];\n+\t      }\n+\n+\t    CLEAR_HARD_REG_BIT (regstack->reg_set,\n+\t\t\t\tREGNO (XEXP (src2_note, 0)));\n+\t    replace_reg (&XEXP (src2_note, 0), FIRST_STACK_REG);\n+\t    regstack->top--;\n+\t  }\n+\telse\n+\t  {\n+\t    SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\t    replace_reg (dest, get_hard_regnum (regstack, *dest));\n+\t  }\n+\n+\tbreak;\n+\n+      default:\n+\tabort ();\n+      }\n+}\n+\f\n+/* Substitute stack hard reg numbers for stack virtual registers in\n+   INSN.  Non-stack register numbers are not changed.  REGSTACK is the\n+   current stack content.  Insns may be emitted as needed to arrange the\n+   stack for the 387 based on the contents of the insn. */\n+\n+static void\n+subst_stack_regs (insn, regstack)\n+     rtx insn;\n+     stack regstack;\n+{\n+  register rtx *note_link, note;\n+  register int i;\n+\n+  if ((GET_CODE (insn) != INSN && GET_CODE (insn) != CALL_INSN)\n+      || INSN_DELETED_P (insn))\n+    return;\n+\n+  /* The stack should be empty at a call. */\n+\n+  if (GET_CODE (insn) == CALL_INSN)\n+    for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n+      if (TEST_HARD_REG_BIT (regstack->reg_set, i))\n+\tabort ();\n+\n+  /* Do the actual substitution if any stack regs are mentioned.\n+     Since we only record whether entire insn mentions stack regs, and\n+     subst_stack_regs_pat only works for patterns that contain stack regs,\n+     we must check each pattern in a parallel here.  A call_value_pop could\n+     fail otherwise. */\n+\n+  if (GET_MODE (insn) == QImode)\n+    {\n+      if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+\tfor (i = 0; i < XVECLEN (PATTERN (insn) , 0); i++)\n+\t  {\n+\t    if (stack_regs_mentioned_p (XVECEXP (PATTERN (insn), 0, i)))\n+\t      subst_stack_regs_pat (insn, regstack,\n+\t\t\t\t    XVECEXP (PATTERN (insn), 0, i));\n+\t  }\n+      else\n+\tsubst_stack_regs_pat (insn, regstack, PATTERN (insn));\n+    }\n+\n+  /* subst_stack_regs_pat may have deleted a no-op insn.  If so, any\n+     REG_UNUSED will already have been dealt with, so just return. */\n+\n+  if (INSN_DELETED_P (insn))\n+    return;\n+\n+  /* If there is a REG_UNUSED note on a stack register on this insn,\n+     the indicated reg must be popped.  The REG_UNUSED note is removed,\n+     since the form of the newly emitted pop insn references the reg,\n+     making it no longer `unset'. */\n+\n+  note_link = &REG_NOTES(insn);\n+  for (note = *note_link; note; note = XEXP (note, 1))\n+    if (REG_NOTE_KIND (note) == REG_UNUSED && STACK_REG_P (XEXP (note, 0)))\n+      {\n+\t*note_link = XEXP (note, 1);\n+\temit_pop_insn (insn, regstack, XEXP (note, 0),\n+\t\t       emit_insn_after);\n+      }\n+    else\n+      note_link = &XEXP (note, 1);\n+}\n+\f\n+/* Change the organization of the stack so that it fits a new basic\n+   block.  Some registers might have to be popped, but there can never be\n+   a register live in the new block that is not now live.\n+\n+   Insert any needed insns after INSN.  OLD is the original stack\n+   layout, and NEW is the desired form.  OLD is updated to reflect the\n+   code emitted, ie, it will be the same as NEW upon return.\n+\n+   This function will not preserve block_end[].  But that information\n+   is no longer needed once this has executed. */\n+\n+static void\n+change_stack (insn, old, new)\n+     rtx insn;\n+     stack old;\n+     stack new;\n+{\n+  int reg;\n+\n+  /* We will be inserting new insns after INSN, by first finding the\n+     next insn, and inserting before it. */\n+\n+  insn = NEXT_INSN (insn);\n+\n+  /* Pop any registers that are not needed in the new block. */\n+\n+  for (reg = old->top; reg >= 0; reg--)\n+    if (! TEST_HARD_REG_BIT (new->reg_set, old->reg[reg]))\n+      emit_pop_insn (insn, old, DFmode_reg[old->reg[reg]],\n+\t\t     emit_insn_before);\n+\n+  if (new->top == -2)\n+    {\n+      /* If the new block has never been processed, then it can inherit\n+\t the old stack order. */\n+\n+      new->top = old->top;\n+      bcopy (old->reg, new->reg, sizeof (new->reg));\n+    }\n+  else\n+    {\n+      /* This block has been entered before, and we must match the\n+\t previously selected stack order. */\n+\n+      /* By now, the only difference should be the order of the stack,\n+\t not their depth or liveliness. */\n+\n+      GO_IF_HARD_REG_EQUAL (old->reg_set, new->reg_set, win);\n+\n+      abort ();\n+\n+    win:\n+\n+      if (old->top != new->top)\n+\tabort ();\n+\n+      /* Loop here emitting swaps until the stack is correct.  The\n+\t worst case number of swaps emitted is N + 2, where N is the\n+\t depth of the stack.  In some cases, the reg at the top of\n+\t stack may be correct, but swapped anyway in order to fix\n+\t other regs.  But since we never swap any other reg away from\n+\t its correct slot, this algorithm will converge. */\n+\n+      do\n+\t{\n+\t  /* Swap the reg at top of stack into the position it is\n+\t     supposed to be in, until the correct top of stack appears. */\n+\n+\t  while (old->reg[old->top] != new->reg[new->top])\n+\t    {\n+\t      for (reg = new->top; reg >= 0; reg--)\n+\t\tif (new->reg[reg] == old->reg[old->top])\n+\t\t  break;\n+\n+\t      if (reg == -1)\n+\t\tabort ();\n+\n+\t      emit_swap_insn (insn, old, DFmode_reg[old->reg[reg]],\n+\t\t\t      emit_insn_before);\n+\t    }\n+\n+\t  /* See if any regs remain incorrect.  If so, bring an\n+\t     incorrect reg to the top of stack, and let the while loop\n+\t     above fix it. */\n+\n+\t  for (reg = new->top; reg >= 0; reg--)\n+\t    if (new->reg[reg] != old->reg[reg])\n+\t      {\n+\t\temit_swap_insn (insn, old, DFmode_reg[old->reg[reg]],\n+\t\t\t\temit_insn_before);\n+\t\tbreak;\n+\t      }\n+\t} while (reg >= 0);\n+\n+      /* At this point there must be no differences. */\n+\n+      for (reg = old->top; reg >= 0; reg--)\n+\tif (old->reg[reg] != new->reg[reg])\n+\t  abort ();\n+    }\n+}\n+\f\n+/* Check PAT, which points to RTL in INSN, for a LABEL_REF.  If it is\n+   found, ensure that a jump from INSN to the code_label to which the\n+   label_ref points ends up with the same stack as that at the\n+   code_label.  Do this by inserting insns just before the code_label to\n+   pop and rotate the stack until it is in the correct order.  REGSTACK\n+   is the order of the register stack in INSN.\n+\n+   Any code that is emitted here must not be later processed as part\n+   of any block, as it will already contain hard register numbers. */\n+\n+static void\n+goto_block_pat (insn, regstack, pat)\n+     rtx insn;\n+     stack regstack;\n+     rtx pat;\n+{\n+  rtx label;\n+  rtx new_jump, new_label, new_barrier;\n+  rtx *ref;\n+  stack label_stack;\n+  struct stack_def temp_stack;\n+  int reg;\n+\n+  if (GET_CODE (pat) != LABEL_REF)\n+    {\n+      int i, j;\n+      char *fmt = GET_RTX_FORMAT (GET_CODE (pat));\n+\n+      for (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0; i--)\n+\t{\n+\t  if (fmt[i] == 'e')\n+\t    goto_block_pat (insn, regstack, XEXP (pat, i));\n+\t  if (fmt[i] == 'E')\n+\t    for (j = 0; j < XVECLEN (pat, i); j++)\n+\t      goto_block_pat (insn, regstack, XVECEXP (pat, i, j));\n+\t}\n+      return;\n+    }\n+\n+  label = XEXP (pat, 0);\n+  if (GET_CODE (label) != CODE_LABEL)\n+    abort ();\n+\n+  /* First, see if in fact anything needs to be done to the stack at all. */\n+\n+  label_stack = &block_stack_in[BLOCK_NUM (label)];\n+\n+  if (label_stack->top == -2)\n+    {\n+      /* If the target block hasn't had a stack order selected, then\n+\t we need merely ensure that no pops are needed. */\n+\n+      for (reg = regstack->top; reg >= 0; reg--)\n+\tif (! TEST_HARD_REG_BIT (label_stack->reg_set, regstack->reg[reg]))\n+\t  break;\n+\n+      if (reg == -1)\n+\t{\n+\t  /* change_stack will not emit any code in this case. */\n+\n+\t  change_stack (label, regstack, label_stack);\n+\t  return;\n+\t}\n+    }\n+  else if (label_stack->top == regstack->top)\n+    {\n+      for (reg = label_stack->top; reg >= 0; reg--)\n+\tif (label_stack->reg[reg] != regstack->reg[reg])\n+\t  break;\n+\n+      if (reg == -1)\n+\treturn;\n+    }\n+\n+  /* At least one insn will need to be inserted before label.  Insert\n+     a jump around the code we are about to emit.  Emit a label for the new\n+     code, and point the original insn at this new label. We can't use\n+     redirect_jump here, because we're using fld[4] of the code labels as\n+     LABEL_REF chains, no NUSES counters. */\n+\n+  new_jump = emit_jump_insn_before (gen_jump (label), label);\n+  record_label_references (new_jump, PATTERN (new_jump));\n+  JUMP_LABEL (new_jump) = label;\n+\n+  new_barrier = emit_barrier_after (new_jump);\n+\n+  new_label = gen_label_rtx ();\n+  emit_label_after (new_label, new_barrier);\n+  LABEL_REFS (new_label) = new_label;\n+\n+  /* The old label_ref will no longer point to the code_label if now uses,\n+     so strip the label_ref from the code_label's chain of references. */\n+\n+  for (ref = &LABEL_REFS (label); *ref != label; ref = &LABEL_NEXTREF (*ref))\n+    if (*ref == pat)\n+      break;\n+\n+  if (*ref == label)\n+    abort ();\n+\n+  *ref = LABEL_NEXTREF (*ref);\n+\n+  XEXP (pat, 0) = new_label;\n+  record_label_references (insn, PATTERN (insn));\n+\n+  if (JUMP_LABEL (insn) == label)\n+    JUMP_LABEL (insn) = new_label;\n+\n+  /* Now emit the needed code. */\n+\n+  temp_stack = *regstack;\n+\n+  change_stack (new_label, &temp_stack, label_stack);\n+}\n+\f\n+/* Traverse all basic blocks in a function, converting the register\n+   refereces in each insn from the \"flat\" register file that gcc uses, to\n+   the stack-like registers the 387 uses. */\n+\n+static void\n+convert_regs ()\n+{\n+  register int block, reg;\n+  register rtx insn, next;\n+  struct stack_def regstack;\n+\n+  for (block = 0; block < blocks; block++)\n+    {\n+      if (block_stack_in[block].top == -2)\n+\t{\n+\t  /* This block has not been previously encountered.  Choose a\n+\t     default mapping for any stack regs live on entry */\n+\n+\t  block_stack_in[block].top = -1;\n+\n+\t  for (reg = LAST_STACK_REG; reg >= FIRST_STACK_REG; reg--)\n+\t    if (TEST_HARD_REG_BIT (block_stack_in[block].reg_set, reg))\n+\t      block_stack_in[block].reg[++block_stack_in[block].top] = reg;\n+\t}\n+\n+      /* Process all insns in this block.  Keep track of `next' here,\n+\t so that we don't process any insns emitted while making\n+\t substitutions in INSN. */\n+\n+      next = block_begin[block];\n+      regstack = block_stack_in[block];\n+      do\n+\t{\n+\t  insn = next;\n+\t  next = NEXT_INSN (insn);\n+\n+\t  /* Don't bother processing unless there is a stack reg\n+\t     mentioned.\n+\n+\t     ??? For now, process CALL_INSNs too to make sure that the\n+\t     stack regs are dead after a call.  Remove this eventually. */\n+\n+\t  if (GET_MODE (insn) == QImode || GET_CODE (insn) == CALL_INSN)\n+\t    subst_stack_regs (insn, &regstack);\n+\n+\t} while (insn != block_end[block]);\n+\n+      /* Something failed if the stack life doesn't match. */\n+\n+      GO_IF_HARD_REG_EQUAL (regstack.reg_set, block_out_reg_set[block], win);\n+\n+      abort ();\n+\n+    win:\n+\n+      /* Adjust the stack of this block on exit to match the stack of\n+\t the target block, or copy stack information into stack of\n+\t jump target if the target block's stack order hasn't been set\n+\t yet. */\n+\n+      if (GET_CODE (insn) == JUMP_INSN)\n+\tgoto_block_pat (insn, &regstack, PATTERN (insn));\n+\n+      /* Likewise handle the case where we fall into the next block. */\n+\n+      if ((block < blocks - 1) && block_drops_in[block+1])\n+\tchange_stack (insn, &regstack, &block_stack_in[block+1]);\n+    }\n+\n+  /* If the last basic block is the end of a loop, and that loop has\n+     regs live at its start, then the last basic block will have regs live\n+     at its end that need to be popped before the function returns. */\n+\n+  for (reg = regstack.top; reg >= 0; reg--)\n+    if (! current_function_returns_real\n+\t|| regstack.reg[reg] != FIRST_STACK_REG)\n+      insn = emit_pop_insn (insn, &regstack, DFmode_reg[regstack.reg[reg]],\n+\t\t\t    emit_insn_after);\n+}\n+\f\n+/* Check expression PAT, which is in INSN, for label references.  if\n+   one is found, print the block number of destination to FILE. */\n+\n+static void\n+print_blocks (file, insn, pat)\n+     FILE *file;\n+     rtx insn, pat;\n+{\n+  register RTX_CODE code = GET_CODE (pat);\n+  register int i;\n+  register char *fmt;\n+\n+  if (code == LABEL_REF)\n+    {\n+      register rtx label = XEXP (pat, 0);\n+\n+      if (GET_CODE (label) != CODE_LABEL)\n+\tabort ();\n+\n+      fprintf (file, \" %d\", BLOCK_NUM (label));\n+\n+      return;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tprint_blocks (file, insn, XEXP (pat, i));\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\t  for (j = 0; j < XVECLEN (pat, i); j++)\n+\t    print_blocks (file, insn, XVECEXP (pat, i, j));\n+\t}\n+    }\n+}\n+\f\n+/* Write information about stack registers and stack blocks into FILE.\n+   This is part of making a debugging dump.  */\n+static void\n+dump_stack_info (file)\n+     FILE *file;\n+{\n+  register int block;\n+\n+  fprintf (file, \"\\n%d stack blocks.\\n\", blocks);\n+  for (block = 0; block < blocks; block++)\n+    {\n+      register rtx head, jump, end;\n+      register int regno;\n+\n+      fprintf (file, \"\\nStack block %d: first insn %d, last %d.\\n\",\n+\t       block, INSN_UID (block_begin[block]),\n+\t       INSN_UID (block_end[block]));\n+\n+      head = block_begin[block];\n+\n+      fprintf (file, \"Reached from blocks: \");\n+      if (GET_CODE (head) == CODE_LABEL)\n+\tfor (jump = LABEL_REFS (head);\n+\t     jump != head;\n+\t     jump = LABEL_NEXTREF (jump))\n+\t  {\n+\t    register int from_block = BLOCK_NUM (CONTAINING_INSN (jump));\n+\t    fprintf (file, \" %d\", from_block);\n+\t  }\n+      if (block_drops_in[block])\n+\tfprintf (file, \" previous\");\n+\n+      fprintf (file, \"\\nlive stack registers on block entry: \");\n+      for (regno = FIRST_STACK_REG; regno <= LAST_STACK_REG ; regno++)\n+\t{\n+\t  if (TEST_HARD_REG_BIT (block_stack_in[block].reg_set, regno))\n+\t    fprintf (file, \"%d \", regno);\n+\t}\n+\n+      fprintf (file, \"\\nlive stack registers on block exit: \");\n+      for (regno = FIRST_STACK_REG; regno <= LAST_STACK_REG ; regno++)\n+\t{\n+\t  if (TEST_HARD_REG_BIT (block_out_reg_set[block], regno))\n+\t    fprintf (file, \"%d \", regno);\n+\t}\n+\n+      end = block_end[block];\n+\n+      fprintf (file, \"\\nJumps to blocks: \");\n+      if (GET_CODE (end) == JUMP_INSN)\n+\tprint_blocks (file, end, PATTERN (end));\n+\n+      if (block + 1 < blocks && block_drops_in[block+1])\n+\tfprintf (file, \" next\");\n+      else if (block + 1 == blocks\n+\t       || (GET_CODE (end) == JUMP_INSN\n+\t\t   && GET_CODE (PATTERN (end)) == RETURN))\n+\tfprintf (file, \" return\");\n+\n+      fprintf (file, \"\\n\");\n+    }\n+}\n+\f\n+/* Report an error at line LINE of file FILE.\n+   S is a string and an arg for `printf'.  */\n+\n+/* Report an fatal error at the line number of the insn INSN (ASM_OPERAND).\n+   S1, S2 is a string and an arg for `printf'. */\n+\n+static void\n+fatal_for_asm (insn, s1, s2)\n+     rtx insn;\n+     char *s1, *s2;\n+{\n+  char *filename;\n+  int line;\n+  rtx body = PATTERN (insn);\n+  rtx asmop = 0;\n+\n+  /* Find the (or one of the) ASM_OPERANDS in the insn.  */\n+  if (GET_CODE (body) == SET && GET_CODE (SET_SRC (body)) == ASM_OPERANDS)\n+    asmop = SET_SRC (body);\n+  else if (GET_CODE (body) == ASM_OPERANDS)\n+    asmop = body;\n+  else if (GET_CODE (body) == PARALLEL\n+\t   && GET_CODE (XVECEXP (body, 0, 0)) == SET)\n+    asmop = SET_SRC (XVECEXP (body, 0, 0));\n+  else if (GET_CODE (body) == PARALLEL\n+\t   && GET_CODE (XVECEXP (body, 0, 0)) == ASM_OPERANDS)\n+    asmop = XVECEXP (body, 0, 0);\n+  else\n+    abort ();\n+\n+  filename = ASM_OPERANDS_SOURCE_FILE (asmop);\n+  line = ASM_OPERANDS_SOURCE_LINE (asmop);\n+\n+  fprintf (stderr, s1);\n+  debug_rtx (insn);\n+\n+  error_with_file_and_line (filename, line, s2, NULL, NULL);\n+  exit (34);\n+}\n+#endif /* STACK_REGS */"}]}