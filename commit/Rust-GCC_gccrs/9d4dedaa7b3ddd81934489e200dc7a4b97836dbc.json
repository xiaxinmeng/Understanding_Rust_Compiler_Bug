{"sha": "9d4dedaa7b3ddd81934489e200dc7a4b97836dbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ0ZGVkYWE3YjNkZGQ4MTkzNDQ4OWUyMDBkYzdhNGI5NzgzNmRiYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-10-18T00:25:30Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2011-10-18T00:25:30Z"}, "message": "Add sparc vec_perm patterns when VIS2.\n\n\t* config/sparc/sparc.md (vec_perm_constv8qi, vec_perm<mode>): New\n\tpatterns.\n\t* config/sparc/sparc.c (sparc_expand_vec_perm_bmask): New function.\n\t* config/sparc/sparc-protos.h (sparc_expand_vec_perm_bmask): Declare.\n\nFrom-SVN: r180119", "tree": {"sha": "32465a9b088684ba8f1a7b99016a67ca224d3026", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32465a9b088684ba8f1a7b99016a67ca224d3026"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d4dedaa7b3ddd81934489e200dc7a4b97836dbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d4dedaa7b3ddd81934489e200dc7a4b97836dbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d4dedaa7b3ddd81934489e200dc7a4b97836dbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d4dedaa7b3ddd81934489e200dc7a4b97836dbc/comments", "author": null, "committer": null, "parents": [{"sha": "d62fc6ed20e07d90b9548c25a6ca38dd347f8c81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d62fc6ed20e07d90b9548c25a6ca38dd347f8c81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d62fc6ed20e07d90b9548c25a6ca38dd347f8c81"}], "stats": {"total": 150, "additions": 150, "deletions": 0}, "files": [{"sha": "ddc5149027fa355f3be21ae8f9f9ac8b543a8fe8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d4dedaa7b3ddd81934489e200dc7a4b97836dbc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d4dedaa7b3ddd81934489e200dc7a4b97836dbc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9d4dedaa7b3ddd81934489e200dc7a4b97836dbc", "patch": "@@ -53,6 +53,11 @@\n \t* config/sparc/sparc.md: Use register_or_zero_operand where rJ\n \tis the constraint.\n \n+\t* config/sparc/sparc.md (vec_perm_constv8qi, vec_perm<mode>): New\n+\tpatterns.\n+\t* config/sparc/sparc.c (sparc_expand_vec_perm_bmask): New function.\n+\t* config/sparc/sparc-protos.h (sparc_expand_vec_perm_bmask): Declare.\n+\n 2011-10-17  David S. Miller  <davem@davemloft.net>\n \n \t* config/sparc/sparc-modes.def: Add single entry vector modes for"}, {"sha": "4b15b82c07a33ece84a3ed65a6b36f85a825520c", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d4dedaa7b3ddd81934489e200dc7a4b97836dbc/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d4dedaa7b3ddd81934489e200dc7a4b97836dbc/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=9d4dedaa7b3ddd81934489e200dc7a4b97836dbc", "patch": "@@ -107,6 +107,7 @@ extern rtx gen_df_reg (rtx, int);\n extern void sparc_expand_compare_and_swap_12 (rtx, rtx, rtx, rtx);\n extern const char *output_v8plus_mult (rtx, rtx *, const char *);\n extern void sparc_expand_vector_init (rtx, rtx);\n+extern void sparc_expand_vec_perm_bmask(enum machine_mode, rtx);\n #endif /* RTX_CODE */\n \n #endif /* __SPARC_PROTOS_H__ */"}, {"sha": "a6601def3be8e754afb7640002a9ace57cb9f5be", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d4dedaa7b3ddd81934489e200dc7a4b97836dbc/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d4dedaa7b3ddd81934489e200dc7a4b97836dbc/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=9d4dedaa7b3ddd81934489e200dc7a4b97836dbc", "patch": "@@ -10863,6 +10863,113 @@ sparc_expand_compare_and_swap_12 (rtx result, rtx mem, rtx oldval, rtx newval)\n   emit_move_insn (result, gen_lowpart (GET_MODE (result), res));\n }\n \n+void\n+sparc_expand_vec_perm_bmask (enum machine_mode vmode, rtx sel)\n+{\n+  rtx t_1, t_2, t_3;\n+\n+  sel = gen_lowpart (DImode, sel);\n+  switch (vmode)\n+    {\n+    case V2SImode:\n+      /* inp = xxxxxxxAxxxxxxxB */\n+      t_1 = expand_simple_binop (DImode, LSHIFTRT, sel, GEN_INT (16),\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      /* t_1 = ....xxxxxxxAxxx. */\n+      sel = expand_simple_binop (SImode, AND, gen_lowpart (SImode, sel),\n+\t\t\t\t GEN_INT (3), NULL_RTX, 1, OPTAB_DIRECT);\n+      t_1 = expand_simple_binop (SImode, AND, gen_lowpart (SImode, t_1),\n+\t\t\t\t GEN_INT (0x30000), NULL_RTX, 1, OPTAB_DIRECT);\n+      /* sel = .......B */\n+      /* t_1 = ...A.... */\n+      sel = expand_simple_binop (SImode, IOR, sel, t_1, sel, 1, OPTAB_DIRECT);\n+      /* sel = ...A...B */\n+      sel = expand_mult (SImode, sel, GEN_INT (0x4444), sel, 1);\n+      /* sel = AAAABBBB * 4 */\n+      t_1 = force_reg (SImode, GEN_INT (0x01230123));\n+      /* sel = { A*4, A*4+1, A*4+2, ... } */\n+      break;\n+\n+    case V4HImode:\n+      /* inp = xxxAxxxBxxxCxxxD */\n+      t_1 = expand_simple_binop (DImode, LSHIFTRT, sel, GEN_INT (8),\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      t_2 = expand_simple_binop (DImode, LSHIFTRT, sel, GEN_INT (16),\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      t_3 = expand_simple_binop (DImode, LSHIFTRT, sel, GEN_INT (24),\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      /* t_1 = ..xxxAxxxBxxxCxx */\n+      /* t_2 = ....xxxAxxxBxxxC */\n+      /* t_3 = ......xxxAxxxBxx */\n+      sel = expand_simple_binop (SImode, AND, gen_lowpart (SImode, sel),\n+\t\t\t\t GEN_INT (0x07),\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      t_1 = expand_simple_binop (SImode, AND, gen_lowpart (SImode, t_1),\n+\t\t\t\t GEN_INT (0x0700),\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      t_2 = expand_simple_binop (SImode, AND, gen_lowpart (SImode, t_2),\n+\t\t\t\t GEN_INT (0x070000),\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      t_3 = expand_simple_binop (SImode, AND, gen_lowpart (SImode, t_3),\n+\t\t\t\t GEN_INT (0x07000000),\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      /* sel = .......D */\n+      /* t_1 = .....C.. */\n+      /* t_2 = ...B.... */\n+      /* t_3 = .A...... */\n+      sel = expand_simple_binop (SImode, IOR, sel, t_1, sel, 1, OPTAB_DIRECT);\n+      t_2 = expand_simple_binop (SImode, IOR, t_2, t_3, t_2, 1, OPTAB_DIRECT);\n+      sel = expand_simple_binop (SImode, IOR, sel, t_2, sel, 1, OPTAB_DIRECT);\n+      /* sel = .A.B.C.D */\n+      sel = expand_mult (SImode, sel, GEN_INT (0x22), sel, 1);\n+      /* sel = AABBCCDD * 2 */\n+      t_1 = force_reg (SImode, GEN_INT (0x01010101));\n+      /* sel = { A*2, A*2+1, B*2, B*2+1, ... } */\n+      break;\n+  \n+    case V8QImode:\n+      /* input = xAxBxCxDxExFxGxH */\n+      sel = expand_simple_binop (DImode, AND, sel,\n+\t\t\t\t GEN_INT ((HOST_WIDE_INT)0x0f0f0f0f << 32\n+\t\t\t\t\t  | 0x0f0f0f0f),\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      /* sel = .A.B.C.D.E.F.G.H */\n+      t_1 = expand_simple_binop (DImode, LSHIFTRT, sel, GEN_INT (4),\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      /* t_1 = ..A.B.C.D.E.F.G. */\n+      sel = expand_simple_binop (DImode, IOR, sel, t_1,\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      /* sel = .AABBCCDDEEFFGGH */\n+      sel = expand_simple_binop (DImode, AND, sel,\n+\t\t\t\t GEN_INT ((HOST_WIDE_INT)0xff00ff << 32\n+\t\t\t\t\t  | 0xff00ff),\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      /* sel = ..AB..CD..EF..GH */\n+      t_1 = expand_simple_binop (DImode, LSHIFTRT, sel, GEN_INT (8),\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      /* t_1 = ....AB..CD..EF.. */\n+      sel = expand_simple_binop (DImode, IOR, sel, t_1,\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      /* sel = ..ABABCDCDEFEFGH */\n+      sel = expand_simple_binop (DImode, AND, sel,\n+\t\t\t\t GEN_INT ((HOST_WIDE_INT)0xffff << 32 | 0xffff),\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      /* sel = ....ABCD....EFGH */\n+      t_1 = expand_simple_binop (DImode, LSHIFTRT, sel, GEN_INT (16),\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      /* t_1 = ........ABCD.... */\n+      sel = gen_lowpart (SImode, sel);\n+      t_1 = gen_lowpart (SImode, t_1);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Always perform the final addition/merge within the bmask insn.  */\n+  emit_insn (gen_bmasksi_vis (gen_reg_rtx (SImode), sel, t_1));\n+}\n+\n /* Implement TARGET_FRAME_POINTER_REQUIRED.  */\n \n static bool"}, {"sha": "d89f6f93b58b8e760a9c094728f3ddc429d5209a", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d4dedaa7b3ddd81934489e200dc7a4b97836dbc/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d4dedaa7b3ddd81934489e200dc7a4b97836dbc/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=9d4dedaa7b3ddd81934489e200dc7a4b97836dbc", "patch": "@@ -8350,6 +8350,43 @@\n   [(set_attr \"type\" \"fga\")\n    (set_attr \"fptype\" \"double\")])\n \n+;; The rtl expanders will happily convert constant permutations on other\n+;; modes down to V8QI.  Rely on this to avoid the complexity of the byte\n+;; order of the permutation.\n+(define_expand \"vec_perm_constv8qi\"\n+  [(match_operand:V8QI 0 \"register_operand\" \"\")\n+   (match_operand:V8QI 1 \"register_operand\" \"\")\n+   (match_operand:V8QI 2 \"register_operand\" \"\")\n+   (match_operand:V8QI 3 \"\" \"\")]\n+  \"TARGET_VIS2\"\n+{\n+  unsigned int i, mask;\n+  rtx sel = operands[3];\n+\n+  for (i = mask = 0; i < 8; ++i)\n+    mask |= (INTVAL (XVECEXP (sel, 0, i)) & 0xf) << (28 - i*4);\n+  sel = force_reg (SImode, gen_int_mode (mask, SImode));\n+\n+  emit_insn (gen_bmasksi_vis (gen_reg_rtx (SImode), sel, const0_rtx));\n+  emit_insn (gen_bshufflev8qi_vis (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+;; Unlike constant permutation, we can vastly simplify the compression of\n+;; the 64-bit selector input to the 32-bit %gsr value by knowing what the\n+;; width of the input is.\n+(define_expand \"vec_perm<mode>\"\n+  [(match_operand:VM64 0 \"register_operand\" \"\")\n+   (match_operand:VM64 1 \"register_operand\" \"\")\n+   (match_operand:VM64 2 \"register_operand\" \"\")\n+   (match_operand:VM64 3 \"register_operand\" \"\")]\n+  \"TARGET_VIS2\"\n+{\n+  sparc_expand_vec_perm_bmask (<MODE>mode, operands[3]);\n+  emit_insn (gen_bshuffle<mode>_vis (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n ;; VIS 2.0 adds edge variants which do not set the condition codes\n (define_insn \"edge8n<P:mode>_vis\"\n   [(set (match_operand:P 0 \"register_operand\" \"=r\")"}]}