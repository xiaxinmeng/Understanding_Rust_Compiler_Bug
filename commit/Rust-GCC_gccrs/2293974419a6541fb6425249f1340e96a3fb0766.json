{"sha": "2293974419a6541fb6425249f1340e96a3fb0766", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI5Mzk3NDQxOWE2NTQxZmI2NDI1MjQ5ZjEzNDBlOTZhM2ZiMDc2Ng==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-09-29T20:06:55Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-09-29T20:06:55Z"}, "message": "re PR target/40457 (use stm and ldm to access consecutive memory words)\n\n\tPR target/40457\n\t* postreload.c (move2add_use_add2_insn): Use full_costs for\n\tcomparison.\n\t(move2add_use_add3_insn): Likewise.\n\t(reload_cse_move2add): Likewise.\n\t* rtlanal.c (get_full_rtx_cost): New function.\n\t* rtl.h (struct full_rtx_costs): New.\n\t(init_costs_to_max, init_costs_to_zero, costs_lt_p,\n\tcosts_add_n_insns): New inline functions.\n\t(get_full_rtx_cost): Declare.\n\ntestsuite/\n\tPR target/40457\n\t* gcc.target/arm/pr40457-3.c: New test.\n\nFrom-SVN: r164732", "tree": {"sha": "8cdfbb3965dc10b464f100060d3e2a0a64d4bd57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cdfbb3965dc10b464f100060d3e2a0a64d4bd57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2293974419a6541fb6425249f1340e96a3fb0766", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2293974419a6541fb6425249f1340e96a3fb0766", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2293974419a6541fb6425249f1340e96a3fb0766", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2293974419a6541fb6425249f1340e96a3fb0766/comments", "author": null, "committer": null, "parents": [{"sha": "0f23bc16605864cf7f41fab13a522004c3ee8c3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f23bc16605864cf7f41fab13a522004c3ee8c3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f23bc16605864cf7f41fab13a522004c3ee8c3a"}], "stats": {"total": 203, "additions": 157, "deletions": 46}, "files": [{"sha": "0c3f9ce9ff731b13a1d54fa950d9ea4e62ef2355", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2293974419a6541fb6425249f1340e96a3fb0766/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2293974419a6541fb6425249f1340e96a3fb0766/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2293974419a6541fb6425249f1340e96a3fb0766", "patch": "@@ -1,3 +1,16 @@\n+2010-09-29  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR target/40457\n+\t* postreload.c (move2add_use_add2_insn): Use full_costs for\n+\tcomparison.\n+\t(move2add_use_add3_insn): Likewise.\n+\t(reload_cse_move2add): Likewise.\n+\t* rtlanal.c (get_full_rtx_cost): New function.\n+\t* rtl.h (struct full_rtx_costs): New.\n+\t(init_costs_to_max, init_costs_to_zero, costs_lt_p,\n+\tcosts_add_n_insns): New inline functions.\n+\t(get_full_rtx_cost): Declare.\n+\n 2010-09-29  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* config/i386/mingw32.h (TARGET_64BIT): replaced by"}, {"sha": "1fc9bfc50f621bcb96541d004cd509efd50c9e3a", "filename": "gcc/postreload.c", "status": "modified", "additions": 70, "deletions": 46, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2293974419a6541fb6425249f1340e96a3fb0766/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2293974419a6541fb6425249f1340e96a3fb0766/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=2293974419a6541fb6425249f1340e96a3fb0766", "patch": "@@ -1645,39 +1645,45 @@ move2add_use_add2_insn (rtx reg, rtx sym, rtx off, rtx insn)\n       if (INTVAL (off) == reg_offset [regno])\n \tchanged = validate_change (insn, &SET_SRC (pat), reg, 0);\n     }\n-  else if (rtx_cost (new_src, PLUS, speed) < rtx_cost (src, SET, speed)\n-\t   && have_add2_insn (reg, new_src))\n+  else\n     {\n+      struct full_rtx_costs oldcst, newcst;\n       rtx tem = gen_rtx_PLUS (GET_MODE (reg), reg, new_src);\n-      changed = validate_change (insn, &SET_SRC (pat), tem, 0);\n-    }\n-  else if (sym == NULL_RTX && GET_MODE (reg) != BImode)\n-    {\n-      enum machine_mode narrow_mode;\n-      for (narrow_mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t   narrow_mode != VOIDmode\n-\t     && narrow_mode != GET_MODE (reg);\n-\t   narrow_mode = GET_MODE_WIDER_MODE (narrow_mode))\n+\n+      get_full_rtx_cost (pat, SET, &oldcst);\n+      SET_SRC (pat) = tem;\n+      get_full_rtx_cost (pat, SET, &newcst);\n+      SET_SRC (pat) = src;\n+\n+      if (costs_lt_p (&newcst, &oldcst, speed)\n+\t  && have_add2_insn (reg, new_src))\n+\tchanged = validate_change (insn, &SET_SRC (pat), tem, 0);\t\n+      else if (sym == NULL_RTX && GET_MODE (reg) != BImode)\n \t{\n-\t  if (have_insn_for (STRICT_LOW_PART, narrow_mode)\n-\t      && ((reg_offset[regno]\n-\t\t   & ~GET_MODE_MASK (narrow_mode))\n-\t\t  == (INTVAL (off)\n-\t\t      & ~GET_MODE_MASK (narrow_mode))))\n+\t  enum machine_mode narrow_mode;\n+\t  for (narrow_mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t       narrow_mode != VOIDmode\n+\t\t && narrow_mode != GET_MODE (reg);\n+\t       narrow_mode = GET_MODE_WIDER_MODE (narrow_mode))\n \t    {\n-\t      rtx narrow_reg = gen_rtx_REG (narrow_mode,\n-\t\t\t\t\t    REGNO (reg));\n-\t      rtx narrow_src = gen_int_mode (INTVAL (off),\n-\t\t\t\t\t     narrow_mode);\n-\t      rtx new_set =\n-\t\tgen_rtx_SET (VOIDmode,\n-\t\t\t     gen_rtx_STRICT_LOW_PART (VOIDmode,\n-\t\t\t\t\t\t      narrow_reg),\n-\t\t\t     narrow_src);\n-\t      changed = validate_change (insn, &PATTERN (insn),\n-\t\t\t\t\t new_set, 0);\n-\t      if (changed)\n-\t\tbreak;\n+\t      if (have_insn_for (STRICT_LOW_PART, narrow_mode)\n+\t\t  && ((reg_offset[regno] & ~GET_MODE_MASK (narrow_mode))\n+\t\t      == (INTVAL (off) & ~GET_MODE_MASK (narrow_mode))))\n+\t\t{\n+\t\t  rtx narrow_reg = gen_rtx_REG (narrow_mode,\n+\t\t\t\t\t\tREGNO (reg));\n+\t\t  rtx narrow_src = gen_int_mode (INTVAL (off),\n+\t\t\t\t\t\t narrow_mode);\n+\t\t  rtx new_set\n+\t\t    = gen_rtx_SET (VOIDmode,\n+\t\t\t\t   gen_rtx_STRICT_LOW_PART (VOIDmode,\n+\t\t\t\t\t\t\t    narrow_reg),\n+\t\t\t\t   narrow_src);\n+\t\t  changed = validate_change (insn, &PATTERN (insn),\n+\t\t\t\t\t     new_set, 0);\n+\t\t  if (changed)\n+\t\t    break;\n+\t\t}\n \t    }\n \t}\n     }\n@@ -1705,11 +1711,18 @@ move2add_use_add3_insn (rtx reg, rtx sym, rtx off, rtx insn)\n   rtx pat = PATTERN (insn);\n   rtx src = SET_SRC (pat);\n   int regno = REGNO (reg);\n-  int min_cost = INT_MAX;\n   int min_regno = 0;\n   bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n   int i;\n   bool changed = false;\n+  struct full_rtx_costs oldcst, newcst, mincst;\n+  rtx plus_expr;\n+\n+  init_costs_to_max (&mincst);\n+  get_full_rtx_cost (pat, SET, &oldcst);\n+\n+  plus_expr = gen_rtx_PLUS (GET_MODE (reg), reg, const0_rtx);\n+  SET_SRC (pat) = plus_expr;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (reg_set_luid[i] > move2add_last_label_luid\n@@ -1728,22 +1741,25 @@ move2add_use_add3_insn (rtx reg, rtx sym, rtx off, rtx insn)\n \t   no-op moves.  */\n \tif (new_src == const0_rtx)\n \t  {\n-\t    min_cost = 0;\n+\t    init_costs_to_zero (&mincst);\n \t    min_regno = i;\n \t    break;\n \t  }\n \telse\n \t  {\n-\t    int cost = rtx_cost (new_src, PLUS, speed);\n-\t    if (cost < min_cost)\n+\t    XEXP (plus_expr, 1) = new_src;\n+\t    get_full_rtx_cost (pat, SET, &newcst);\n+\n+\t    if (costs_lt_p (&newcst, &mincst, speed))\n \t      {\n-\t\tmin_cost = cost;\n+\t\tmincst = newcst;\n \t\tmin_regno = i;\n \t      }\n \t  }\n       }\n+  SET_SRC (pat) = src;\n \n-  if (min_cost < rtx_cost (src, SET, speed))\n+  if (costs_lt_p (&mincst, &oldcst, speed))\n     {\n       rtx tem;\n \n@@ -1879,18 +1895,26 @@ reload_cse_move2add (rtx first)\n \t\t\t/* See above why we create (set (reg) (reg)) here.  */\n \t\t\tsuccess\n \t\t\t  = validate_change (next, &SET_SRC (set), reg, 0);\n-\t\t      else if ((rtx_cost (new_src, PLUS, speed)\n-\t\t\t\t< COSTS_N_INSNS (1) + rtx_cost (src3, SET, speed))\n-\t\t\t       && have_add2_insn (reg, new_src))\n+\t\t      else\n \t\t\t{\n-\t\t\t  rtx newpat = gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t\t    reg,\n-\t\t\t\t\t\t    gen_rtx_PLUS (GET_MODE (reg),\n-\t\t\t\t\t\t \t\t  reg,\n-\t\t\t\t\t\t\t\t  new_src));\n-\t\t\t  success\n-\t\t\t    = validate_change (next, &PATTERN (next),\n-\t\t\t\t\t       newpat, 0);\n+\t\t\t  rtx old_src = SET_SRC (set);\n+\t\t\t  struct full_rtx_costs oldcst, newcst;\n+\t\t\t  rtx tem = gen_rtx_PLUS (GET_MODE (reg), reg, new_src);\n+\n+\t\t\t  get_full_rtx_cost (set, SET, &oldcst);\n+\t\t\t  SET_SRC (set) = tem;\n+\t\t\t  get_full_rtx_cost (tem, SET, &newcst);\n+\t\t\t  SET_SRC (set) = old_src;\n+\t\t\t  costs_add_n_insns (&oldcst, 1);\n+\n+\t\t\t  if (costs_lt_p (&newcst, &oldcst, speed)\n+\t\t\t      && have_add2_insn (reg, new_src))\n+\t\t\t    {\n+\t\t\t      rtx newpat = gen_rtx_SET (VOIDmode, reg, tem);\n+\t\t\t      success\n+\t\t\t\t= validate_change (next, &PATTERN (next),\n+\t\t\t\t\t\t   newpat, 0);\n+\t\t\t    }\n \t\t\t}\n \t\t      if (success)\n \t\t\tdelete_insn (insn);"}, {"sha": "1f13f2a84eb8ab3485f364213b67adb717a470bb", "filename": "gcc/rtl.h", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2293974419a6541fb6425249f1340e96a3fb0766/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2293974419a6541fb6425249f1340e96a3fb0766/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=2293974419a6541fb6425249f1340e96a3fb0766", "patch": "@@ -1123,9 +1123,57 @@ rhs_regno (const_rtx x)\n    not to use an rtx with this cost under any circumstances.  */\n #define MAX_COST INT_MAX\n \n+/* A structure to hold all available cost information about an rtl\n+   expression.  */\n+struct full_rtx_costs\n+{\n+  int speed;\n+  int size;\n+};\n+\n+/* Initialize a full_rtx_costs structure C to the maximum cost.  */\n+static inline void\n+init_costs_to_max (struct full_rtx_costs *c)\n+{\n+  c->speed = MAX_COST;\n+  c->size = MAX_COST;\n+}\n+\n+/* Initialize a full_rtx_costs structure C to zero cost.  */\n+static inline void\n+init_costs_to_zero (struct full_rtx_costs *c)\n+{\n+  c->speed = 0;\n+  c->size = 0;\n+}\n+\n+/* Compare two full_rtx_costs structures A and B, returning true\n+   if A < B when optimizing for speed.  */\n+static inline bool\n+costs_lt_p (struct full_rtx_costs *a, struct full_rtx_costs *b,\n+\t    bool speed)\n+{\n+  if (speed)\n+    return (a->speed < b->speed\n+\t    || (a->speed == b->speed && a->size < b->size));\n+  else\n+    return (a->size < b->size\n+\t    || (a->size == b->size && a->speed < b->speed));\n+}\n+\n+/* Increase both members of the full_rtx_costs structure C by the\n+   cost of N insns.  */\n+static inline void\n+costs_add_n_insns (struct full_rtx_costs *c, int n)\n+{\n+  c->speed += COSTS_N_INSNS (n);\n+  c->size += COSTS_N_INSNS (n);\n+}\n+\n extern void init_rtlanal (void);\n extern int rtx_cost (rtx, enum rtx_code, bool);\n extern int address_cost (rtx, enum machine_mode, addr_space_t, bool);\n+extern void get_full_rtx_cost (rtx, enum rtx_code, struct full_rtx_costs *);\n extern unsigned int subreg_lsb (const_rtx);\n extern unsigned int subreg_lsb_1 (enum machine_mode, enum machine_mode,\n \t\t\t\t  unsigned int);"}, {"sha": "930828ac2eb2c73488c0a036dfb9fcac3262fef2", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2293974419a6541fb6425249f1340e96a3fb0766/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2293974419a6541fb6425249f1340e96a3fb0766/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=2293974419a6541fb6425249f1340e96a3fb0766", "patch": "@@ -3589,6 +3589,17 @@ rtx_cost (rtx x, enum rtx_code outer_code ATTRIBUTE_UNUSED, bool speed)\n \n   return total;\n }\n+\n+/* Fill in the structure C with information about both speed and size rtx\n+   costs for X, with outer code OUTER.  */\n+\n+void\n+get_full_rtx_cost (rtx x, enum rtx_code outer, struct full_rtx_costs *c)\n+{\n+  c->speed = rtx_cost (x, outer, true);\n+  c->size = rtx_cost (x, outer, false);\n+}\n+\n \f\n /* Return cost of address expression X.\n    Expect that X is properly formed address reference."}, {"sha": "2a5b94f69038ee2eca1d2db6780601d2f7888e3f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2293974419a6541fb6425249f1340e96a3fb0766/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2293974419a6541fb6425249f1340e96a3fb0766/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2293974419a6541fb6425249f1340e96a3fb0766", "patch": "@@ -1,3 +1,8 @@\n+2010-09-29  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR target/40457\n+\t* gcc.target/arm/pr40457-3.c: New test.\n+\n 2010-09-29  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* lib/target-supports-dg.exp (dg-require-ifunc): Remove extraneous"}, {"sha": "9bd5a17befeb2257d48b2a87b4c8d4cdf4c57ddd", "filename": "gcc/testsuite/gcc.target/arm/pr40457-3.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2293974419a6541fb6425249f1340e96a3fb0766/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr40457-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2293974419a6541fb6425249f1340e96a3fb0766/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr40457-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr40457-3.c?ref=2293974419a6541fb6425249f1340e96a3fb0766", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-options \"-Os\" }  */\n+/* { dg-do compile } */\n+\n+void foo(int* p)\n+{\n+  p[0] = 1;\n+  p[1] = 0;\n+}\n+\n+/* { dg-final { scan-assembler \"stm\" } } */"}]}