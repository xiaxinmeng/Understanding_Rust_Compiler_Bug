{"sha": "a177473334c4f427428326747b97656a0af049fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE3NzQ3MzMzNGM0ZjQyNzQyODMyNjc0N2I5NzY1NmEwYWYwNDlmYQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "1998-04-09T20:36:47Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "1998-04-09T20:36:47Z"}, "message": "cp-tree.h (start_decl): Update prototype.\n\nd\nThu Apr  9 22:16:57 1998  Per Bothner  <bothner@cygnus.com>\n        * cp-tree.h (start_decl):  Update prototype.\n        * decl.c (start_decl):  Like the C version, new parameters\n        for the attributes.  Call cplus_decl_attributes here,\n        (pushdecl):  Like C version, do build_type_copy if TYPE_DECL,\n        (grokdeclarator):  Pass NULL for new start_decl arguments.\n        * pt.c (tsubst_expr):  Likewise.\n        * parse.y:  Merge cplus_decl_attribute calls into start_decl calls.\n\t* typeck.c (common_type): Check TYPE_MAIN_VARIANT.\n\t* lex.c (build_lang_decl): Add lang_name_java.\n\t* class.c (push_lang_context): Add lang_name_java.\n\t* method.c (build_mangled_name): Check for is_java_type.\nThu Apr  9 22:16:57 1998  Benjamin Kosnik  <bkoz@loony.cygnus.com>\n\t* decl.c (grokdeclarator): Check TYPE_MAIN_VARIANT.\n\t* call.c (build_scoped_method_call): Check for TREE_CODE for\n\tVOID_TYPE instead of type ==  void_type_node.\n\t(build_method_call): Ditto.\n\t* decl.c (lookup_name_real): Ditto.\n\t(grokdeclarator): Ditto.\n\t(start_decl): Ditto.\n\t(grokparms): Ditto.\n\t(start_function): Ditto.\n\t(finish_function): Ditto.\n\t(start_method): Ditto.\nalso fixes g++/15415\n\nFrom-SVN: r19071", "tree": {"sha": "0e8230f205b2727e79d4de2d86417a1e2e57a1e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e8230f205b2727e79d4de2d86417a1e2e57a1e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a177473334c4f427428326747b97656a0af049fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a177473334c4f427428326747b97656a0af049fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a177473334c4f427428326747b97656a0af049fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a177473334c4f427428326747b97656a0af049fa/comments", "author": null, "committer": null, "parents": [{"sha": "2e076ddffc120f909669aefa24d872968264c6c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e076ddffc120f909669aefa24d872968264c6c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e076ddffc120f909669aefa24d872968264c6c7"}], "stats": {"total": 176, "additions": 117, "deletions": 59}, "files": [{"sha": "1c50b7eed4cb9843162ed5db213ca73a10951394", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a177473334c4f427428326747b97656a0af049fa/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a177473334c4f427428326747b97656a0af049fa/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a177473334c4f427428326747b97656a0af049fa", "patch": "@@ -382,11 +382,12 @@ build_scoped_method_call (exp, basetype, name, parms)\n      and template parms.  */\n   if (TREE_CODE (name) == BIT_NOT_EXPR && ! IS_AGGR_TYPE (basetype))\n     {\n-      if (type != basetype)\n+      if (TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (basetype))\n \tcp_error (\"type of `%E' does not match destructor type `%T' (type was `%T')\",\n \t\t  exp, basetype, type);\n       name = TREE_OPERAND (name, 0);\n-      if (basetype != name && basetype != get_type_value (name))\n+      if (TYPE_MAIN_VARIANT (basetype) != name \n+\t  && basetype != get_type_value (name))\n \tcp_error (\"qualified type `%T' does not match destructor name `~%T'\",\n \t\t  basetype, name);\n       return cp_convert (void_type_node, exp);\n@@ -630,7 +631,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       basetype = TREE_TYPE (instance);\n       if (TREE_CODE (basetype) == REFERENCE_TYPE)\n \tbasetype = TREE_TYPE (basetype);\n-      if (! (name == basetype\n+      if (! (name == TYPE_MAIN_VARIANT (basetype)\n \t     || (IS_AGGR_TYPE (basetype)\n \t\t && name == constructor_name (basetype))\n \t     || basetype == get_type_value (name)))"}, {"sha": "5c4be24268afdbae5e337af48d3cf90742361d2d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a177473334c4f427428326747b97656a0af049fa/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a177473334c4f427428326747b97656a0af049fa/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a177473334c4f427428326747b97656a0af049fa", "patch": "@@ -131,7 +131,7 @@ tree *current_lang_base, *current_lang_stack;\n int current_lang_stacksize;\n \n /* Names of languages we recognize.  */\n-tree lang_name_c, lang_name_cplusplus;\n+tree lang_name_c, lang_name_cplusplus, lang_name_java;\n tree current_lang_name;\n \n /* When layout out an aggregate type, the size of the\n@@ -4886,7 +4886,7 @@ push_lang_context (name)\n       current_lang_stacksize += 10;\n     }\n \n-  if (name == lang_name_cplusplus)\n+  if (name == lang_name_cplusplus || name == lang_name_java)\n     {\n       strict_prototype = strict_prototypes_lang_cplusplus;\n       current_lang_name = name;"}, {"sha": "a71a768ceda37394eb4bca8db569193555579df1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 46, "deletions": 36, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a177473334c4f427428326747b97656a0af049fa/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a177473334c4f427428326747b97656a0af049fa/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a177473334c4f427428326747b97656a0af049fa", "patch": "@@ -3286,22 +3286,25 @@ pushdecl (x)\n       else if (DECL_FUNCTION_TEMPLATE_P (x) && DECL_CONTEXT (x) == NULL_TREE)\n \treturn push_overloaded_decl (x, 0);\n \n-      /* If declaring a type as a typedef, and the type has no known\n-\t typedef name, install this TYPE_DECL as its typedef name.  */\n+      /* If declaring a type as a typedef, copy the type (unless we're\n+\t at line 0), and install this TYPE_DECL as the new type's typedef\n+\t name.  See the extensive comment in ../c-decl.c (pushdecl). */\n       if (TREE_CODE (x) == TYPE_DECL)\n \t{\n \t  tree type = TREE_TYPE (x);\n-\t  tree name = (type != error_mark_node) ? TYPE_NAME (type) : x;\n-\n-\t  if (name == NULL_TREE || TREE_CODE (name) != TYPE_DECL)\n-\t    {\n-\t      /* If these are different names, and we're at the global\n-\t\t binding level, make two equivalent definitions.  */\n-              name = x;\n-              if (global_bindings_p ())\n-                TYPE_NAME (type) = x;\n-\t    }\n-\t  my_friendly_assert (TREE_CODE (name) == TYPE_DECL, 140);\n+          if (DECL_SOURCE_LINE (x) == 0)\n+            {\n+\t      if (TYPE_NAME (type) == 0)\n+\t        TYPE_NAME (type) = x;\n+            }\n+          else if (type != error_mark_node && TYPE_NAME (type) != x)\n+            {\n+\t      DECL_ORIGINAL_TYPE (x) = type;\n+              type = build_type_copy (type);\n+\t      TYPE_STUB_DECL (type) = TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (x));\n+              TYPE_NAME (type) = x;\n+              TREE_TYPE (x) = type;\n+            }\n \n \t  if (type != error_mark_node\n \t      && TYPE_NAME (type)\n@@ -4615,7 +4618,7 @@ lookup_name_real (name, prefer_type, nonclass)\n \n \t  type = complete_type (type);\n \n-\t  if (type == void_type_node)\n+\t  if (TREE_CODE (type) == VOID_TYPE)\n \t    val = IDENTIFIER_GLOBAL_VALUE (name);\n \t  else if (TREE_CODE (type) == NAMESPACE_DECL)\n \t    {\n@@ -4954,6 +4957,7 @@ init_decl_processing ()\n   /* Have to make these distinct before we try using them.  */\n   lang_name_cplusplus = get_identifier (\"C++\");\n   lang_name_c = get_identifier (\"C\");\n+  lang_name_java = get_identifier (\"Java\");\n \n   /* enter the global namespace */\n   my_friendly_assert (global_namespace == NULL_TREE, 375);\n@@ -5862,9 +5866,10 @@ groktypename (typename)\n int debug_temp_inits = 1;\n \n tree\n-start_decl (declarator, declspecs, initialized)\n+start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n      tree declarator, declspecs;\n      int initialized;\n+     tree attributes, prefix_attributes;\n {\n   register tree decl;\n   register tree type, tem;\n@@ -5887,7 +5892,7 @@ start_decl (declarator, declspecs, initialized)\n \n   decl = grokdeclarator (declarator, declspecs, NORMAL, initialized,\n \t\t\t NULL_TREE);\n-  if (decl == NULL_TREE || decl == void_type_node)\n+  if (decl == NULL_TREE || TREE_CODE (decl) == VOID_TYPE)\n     return NULL_TREE;\n \n   type = TREE_TYPE (decl);\n@@ -6029,6 +6034,9 @@ start_decl (declarator, declspecs, initialized)\n       pushclass (context, 2);\n     }\n \n+  /* Set attributes here so if duplicate decl, will have proper attributes.  */\n+  cplus_decl_attributes (decl, attributes, prefix_attributes);\n+\n   /* Add this decl to the current binding level, but not if it\n      comes from another scope, e.g. a static member variable.\n      TEM may equal DECL or it may be a previous decl of the same name.  */\n@@ -7825,7 +7833,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t*next = TREE_OPERAND (decl, 0);\n \t\tinit = TREE_OPERAND (decl, 1);\n \n-\t\tdecl = start_decl (declarator, declspecs, 1);\n+\t\tdecl = start_decl (declarator, declspecs, 1, NULL_TREE, NULL_TREE);\n \t\t/* Look for __unused__ attribute */\n \t\tif (TREE_USED (TREE_TYPE (decl)))\n \t\t  TREE_USED (decl) = 1;\n@@ -8387,7 +8395,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n   constp = !! RIDBIT_SETP (RID_CONST, specbits) + TYPE_READONLY (type);\n   volatilep = !! RIDBIT_SETP (RID_VOLATILE, specbits) + TYPE_VOLATILE (type);\n-  type = TYPE_MAIN_VARIANT (type);\n+  type = build_type_variant (type, 0, 0);\n   staticp = 0;\n   inlinep = !! RIDBIT_SETP (RID_INLINE, specbits);\n   virtualp = RIDBIT_SETP (RID_VIRTUAL, specbits);\n@@ -8642,7 +8650,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t    /* Check for some types that there cannot be arrays of.  */\n \n-\t    if (TYPE_MAIN_VARIANT (type) == void_type_node)\n+\t    if (TREE_CODE (type) == VOID_TYPE)\n \t      {\n \t\tcp_error (\"declaration of `%D' as array of voids\", dname);\n \t\ttype = error_mark_node;\n@@ -9081,7 +9089,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (TYPE_MAIN_VARIANT (type) == void_type_node)\n+\t\t  if (TREE_CODE (type) == VOID_TYPE)\n \t\t    error (\"invalid type: `void &'\");\n \t\t  else\n \t\t    type = build_reference_type (type);\n@@ -9354,6 +9362,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  if (IS_SIGNATURE (current_class_type) && opaque_typedef)\n \t    SIGNATURE_HAS_OPAQUE_TYPEDECLS (current_class_type) = 1;\n \t}\n+      else if (current_lang_name == lang_name_java)\n+\tdecl = build_lang_decl (TYPE_DECL, declarator, type);\n       else\n \tdecl = build_decl (TYPE_DECL, declarator, type);\n \n@@ -9495,7 +9505,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n      We don't complain about parms either, but that is because\n      a better error message can be made later.  */\n \n-  if (TYPE_MAIN_VARIANT (type) == void_type_node && decl_context != PARM)\n+  if (TREE_CODE (type) == VOID_TYPE && decl_context != PARM)\n     {\n       if (! declarator)\n \terror (\"unnamed variable or field declared void\");\n@@ -9537,7 +9547,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  type = build_pointer_type (type);\n \telse if (TREE_CODE (type) == OFFSET_TYPE)\n \t  type = build_pointer_type (type);\n-\telse if (type == void_type_node && declarator)\n+\telse if (TREE_CODE (type) == VOID_TYPE && declarator)\n \t  {\n \t    error (\"declaration of `%s' as void\", name);\n \t    return NULL_TREE;\n@@ -10116,7 +10126,7 @@ grokparms (first_parm, funcdef_flag)\n     }\n   else if (first_parm != NULL_TREE\n \t   && TREE_CODE (TREE_VALUE (first_parm)) != TREE_LIST\n-\t   && TREE_VALUE (first_parm) != void_type_node)\n+\t   && TREE_CODE (TREE_VALUE (first_parm)) != VOID_TYPE)\n     my_friendly_abort (145);\n   else\n     {\n@@ -10138,7 +10148,8 @@ grokparms (first_parm, funcdef_flag)\n \n \t      chain = TREE_CHAIN (parm);\n \t      /* @@ weak defense against parse errors.  */\n-\t      if (decl != void_type_node && TREE_CODE (decl) != TREE_LIST)\n+\t      if (TREE_CODE (decl) != VOID_TYPE \n+\t\t  && TREE_CODE (decl) != TREE_LIST)\n \t\t{\n \t\t  /* Give various messages as the need arises.  */\n \t\t  if (TREE_CODE (decl) == STRING_CST)\n@@ -10148,7 +10159,7 @@ grokparms (first_parm, funcdef_flag)\n \t\t  continue;\n \t\t}\n \n-\t      if (decl != void_type_node)\n+\t      if (TREE_CODE (decl) != VOID_TYPE)\n \t\t{\n \t\t  decl = grokdeclarator (TREE_VALUE (decl),\n \t\t\t\t\t TREE_PURPOSE (decl),\n@@ -10157,7 +10168,7 @@ grokparms (first_parm, funcdef_flag)\n \t\t  if (! decl)\n \t\t    continue;\n \t\t  type = TREE_TYPE (decl);\n-\t\t  if (TYPE_MAIN_VARIANT (type) == void_type_node)\n+\t\t  if (TREE_CODE (type) == VOID_TYPE)\n \t\t    decl = void_type_node;\n \t\t  else if (TREE_CODE (type) == METHOD_TYPE)\n \t\t    {\n@@ -10197,7 +10208,7 @@ grokparms (first_parm, funcdef_flag)\n                     }\n \t\t}\n \n-\t      if (decl == void_type_node)\n+\t      if (TREE_CODE (decl) == VOID_TYPE)\n \t\t{\n \t\t  if (result == NULL_TREE)\n \t\t    {\n@@ -10516,7 +10527,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t\tcp_error (\"`%D' must be either a non-static member function or a non-member function\", decl);\n \n \t      if (p)\n-\t\tfor (; TREE_VALUE (p) != void_type_node ; p = TREE_CHAIN (p))\n+\t\tfor (; TREE_CODE (TREE_VALUE (p)) != VOID_TYPE ; p = TREE_CHAIN (p))\n \t\t  {\n \t\t    tree arg = TREE_VALUE (p);\n \t\t    if (TREE_CODE (arg) == REFERENCE_TYPE)\n@@ -11364,7 +11375,7 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n   int doing_friend = 0;\n \n   /* Sanity check.  */\n-  my_friendly_assert (TREE_VALUE (void_list_node) == void_type_node, 160);\n+  my_friendly_assert (TREE_CODE (TREE_VALUE (void_list_node)) == VOID_TYPE, 160);\n   my_friendly_assert (TREE_CHAIN (void_list_node) == NULL_TREE, 161);\n \n   /* Assume, until we see it does.  */\n@@ -11539,7 +11550,7 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n   /* Effective C++ rule 15.  See also c_expand_return.  */\n   if (warn_ecpp\n       && DECL_NAME (decl1) == ansi_opname[(int) MODIFY_EXPR]\n-      && TREE_TYPE (fntype) == void_type_node)\n+      && TREE_CODE (TREE_TYPE (fntype)) == VOID_TYPE)\n     cp_warning (\"`operator=' should return a reference to `*this'\");\n \n   /* Make the init_value nonzero so pushdecl knows this is not tentative.\n@@ -11797,7 +11808,7 @@ store_parm_decls ()\n \t\t{\n \t\t  pushdecl (parm);\n \t\t}\n-\t      else if (TYPE_MAIN_VARIANT (TREE_TYPE (parm)) == void_type_node)\n+\t      else if (TREE_CODE (TREE_TYPE (parm)) == VOID_TYPE)\n \t\tcp_error (\"parameter `%D' declared void\", parm);\n \t      else\n \t\t{\n@@ -12250,8 +12261,7 @@ finish_function (lineno, call_poplevel, nested)\n \t\t}\n \t      c_expand_return (current_class_ptr);\n \t    }\n-\t  else if (TYPE_MAIN_VARIANT (TREE_TYPE (\n-\t\t\t\t\t\t DECL_RESULT (current_function_decl))) != void_type_node\n+\t  else if (TREE_CODE (TREE_TYPE (DECL_RESULT (current_function_decl))) != VOID_TYPE\n \t\t   && return_label != NULL_RTX)\n \t    no_return_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n \n@@ -12490,7 +12500,7 @@ finish_function (lineno, call_poplevel, nested)\n \tcp_warning (\"`noreturn' function `%D' does return\", fndecl);\n       else if ((warn_return_type || pedantic)\n \t       && current_function_returns_null\n-\t       && TYPE_MAIN_VARIANT (TREE_TYPE (fntype)) != void_type_node)\n+\t       && TREE_CODE (TREE_TYPE (fntype)) != VOID_TYPE)\n \t{\n \t  /* If this function returns non-void and control can drop through,\n \t     complain.  */\n@@ -12582,7 +12592,7 @@ start_method (declspecs, declarator)\n     return NULL_TREE;\n \n   /* Pass friends other than inline friend functions back.  */\n-  if (TYPE_MAIN_VARIANT (fndecl) == void_type_node)\n+  if (fndecl == void_type_node)\n     return fndecl;\n \n   if (TREE_CODE (fndecl) != FUNCTION_DECL)\n@@ -12673,7 +12683,7 @@ finish_method (decl)\n \n   register tree link;\n \n-  if (TYPE_MAIN_VARIANT (decl) == void_type_node)\n+  if (decl == void_type_node)\n     return decl;\n \n   old_initial = DECL_INITIAL (fndecl);"}, {"sha": "74f05191f76eacd7bac2f19c263c0239cea2fdad", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a177473334c4f427428326747b97656a0af049fa/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a177473334c4f427428326747b97656a0af049fa/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=a177473334c4f427428326747b97656a0af049fa", "patch": "@@ -4373,6 +4373,8 @@ build_lang_decl (code, name, type)\n     DECL_LANGUAGE (t) = lang_cplusplus;\n   else if (current_lang_name == lang_name_c)\n     DECL_LANGUAGE (t) = lang_c;\n+  else if (current_lang_name == lang_name_java)\n+    DECL_LANGUAGE (t) = lang_java;\n   else my_friendly_abort (64);\n \n   SET_DECL_NAMESPACE (t, current_namespace);"}, {"sha": "6e20848102eec153cc93c884341cf73cc97230d3", "filename": "gcc/cp/method.c", "status": "modified", "additions": 54, "deletions": 8, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a177473334c4f427428326747b97656a0af049fa/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a177473334c4f427428326747b97656a0af049fa/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=a177473334c4f427428326747b97656a0af049fa", "patch": "@@ -1044,7 +1044,8 @@ build_mangled_name (parmtypes, begin, end)\n               /* Every argument gets counted.  */\n               typevec[maxtype++] = parmtype;\n \n-              if (TREE_USED (parmtype) && parmtype == typevec[maxtype-2])\n+              if (TREE_USED (parmtype) && parmtype == typevec[maxtype-2]\n+\t\t  && ! is_java_type (parmtype))\n                 {\n                   Nrepeats++;\n                   continue;\n@@ -1067,9 +1068,10 @@ build_mangled_name (parmtypes, begin, end)\n                 }\n \n               /* Only cache types which take more than one character.  */\n-              if (parmtype != TYPE_MAIN_VARIANT (parmtype)\n-                  || (TREE_CODE (parmtype) != INTEGER_TYPE\n-                      && TREE_CODE (parmtype) != REAL_TYPE))\n+              if ((parmtype != TYPE_MAIN_VARIANT (parmtype)\n+\t\t   || (TREE_CODE (parmtype) != INTEGER_TYPE\n+\t\t       && TREE_CODE (parmtype) != REAL_TYPE))\n+\t\t  && ! is_java_type (parmtype))\n                 TREE_USED (parmtype) = 1;\n             }\n         if (TYPE_PTRMEMFUNC_P (parmtype))\n@@ -1113,14 +1115,34 @@ process_modifiers (parmtype)\n \n   if (TREE_READONLY (parmtype))\n     OB_PUTC ('C');\n-  if (TREE_CODE (parmtype) == INTEGER_TYPE && \n-             TYPE_MAIN_VARIANT (parmtype) == \n-                            unsigned_type (TYPE_MAIN_VARIANT (parmtype)))\n-    OB_PUTC ('U');\n+  if (TREE_CODE (parmtype) == INTEGER_TYPE\n+      && (TYPE_MAIN_VARIANT (parmtype)\n+\t  == unsigned_type (TYPE_MAIN_VARIANT (parmtype)))\n+      && ! is_java_type (parmtype))\n+    {\n+      OB_PUTC ('U');\n+    }\n   if (TYPE_VOLATILE (parmtype))\n     OB_PUTC ('V');\n }\n \n+/* True iff TYPE was declared as a \"Java\" type (inside extern \"Java\"). */\n+\n+int\n+is_java_type (type)\n+     tree type;\n+{\n+  if (TYPE_NAME (type) != NULL_TREE)\n+    {\n+      tree decl = TYPE_NAME (type);\n+      if (TREE_CODE (decl) == TYPE_DECL\n+\t  && DECL_LANG_SPECIFIC (decl) != NULL\n+\t  && DECL_LANGUAGE (decl) == lang_java)\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n /* Check to see if a tree node has been entered into the Bcode typelist \n    if not, add it. Otherwise emit the code and return TRUE */\n static int \n@@ -1292,6 +1314,30 @@ process_overload_item (parmtype, extra_Gcode)\n       }\n \n     case INTEGER_TYPE:\n+      /* \"Java\" integer types should mangle the same on all platforms,\n+\t and only depend on precision, not target 'int' size. */\n+      if (is_java_type (parmtype))\n+\t{\n+\t  if (TREE_UNSIGNED (parmtype))\n+\t    {\n+\t      switch (TYPE_PRECISION (parmtype))\n+\t\t{\n+\t\tcase  8:  OB_PUTC ('b');  return;\n+\t\tcase 16:  OB_PUTC ('w');  return;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      switch (TYPE_PRECISION (parmtype))\n+\t\t{\n+\t\tcase  8:  OB_PUTC ('c');  return;\n+\t\tcase 16:  OB_PUTC ('s');  return;\n+\t\tcase 32:  OB_PUTC ('i');  return;\n+\t\tcase 64:  OB_PUTC ('x');  return;\n+\t\t}\n+\t    }\n+\t}\n+\n       parmtype = TYPE_MAIN_VARIANT (parmtype);\n       if (parmtype == integer_type_node\n           || parmtype == unsigned_type_node)"}, {"sha": "7e79685eb7695ec1c57e0f6f51bce9136eec04da", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a177473334c4f427428326747b97656a0af049fa/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a177473334c4f427428326747b97656a0af049fa/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=a177473334c4f427428326747b97656a0af049fa", "patch": "@@ -318,8 +318,8 @@ parse_decl(declarator, specs_attrs, attributes, initialized, decl)\n       used_extern_spec = 1;\n     }\n   sm = suspend_momentary ();\n-  *decl = start_decl (declarator, current_declspecs, initialized);\n-  cplus_decl_attributes (*decl, attributes, prefix_attributes);\n+  *decl = start_decl (declarator, current_declspecs, initialized,\n+\t\t      attributes, prefix_attributes);\n   return sm;\n }\n %}\n@@ -942,9 +942,8 @@ condition:\n \t\t  }\n \t\t  current_declspecs = $1.t;\n \t\t  $<itype>5 = suspend_momentary ();\n-\t\t  $<ttype>$ = start_decl ($<ttype>2, current_declspecs, 1);\n-\t\t  cplus_decl_attributes ($<ttype>$, $4,\n-\t\t\t\t\t /*prefix_attributes*/ NULL_TREE);\n+\t\t  $<ttype>$ = start_decl ($<ttype>2, current_declspecs, 1,\n+\t\t\t\t\t  $4, /*prefix_attributes*/ NULL_TREE);\n \t\t}\n \t  init\n \t\t{ \n@@ -1769,14 +1768,14 @@ maybeasm:\n \n initdcl:\n \t  declarator maybeasm maybe_attribute '='\n-\t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1);\n-\t\t  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes); }\n+\t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1,\n+\t\t\t\t\t  $3, prefix_attributes); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n \t\t{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING); }\n \t| declarator maybeasm maybe_attribute\n-\t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 0);\n-\t\t  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes);\n+\t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 0,\n+\t\t\t\t\t  $3, prefix_attributes);\n \t\t  cp_finish_decl ($<ttype>$, NULL_TREE, $2, 1, 0); }\n \t;\n "}, {"sha": "4a7512ed844665100e943c6411c3a45e12b080b3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a177473334c4f427428326747b97656a0af049fa/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a177473334c4f427428326747b97656a0af049fa/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a177473334c4f427428326747b97656a0af049fa", "patch": "@@ -5014,7 +5014,7 @@ tsubst_expr (t, args, in_decl)\n \tdcl = start_decl\n \t  (tsubst (TREE_OPERAND (t, 0), args, in_decl),\n \t   tsubst (TREE_OPERAND (t, 1), args, in_decl),\n-\t   TREE_OPERAND (t, 2) != 0);\n+\t   TREE_OPERAND (t, 2) != 0, NULL_TREE, NULL_TREE);\n \tinit = tsubst_expr (TREE_OPERAND (t, 2), args, in_decl);\n \tcp_finish_decl\n \t  (dcl, init, NULL_TREE, 1, /*init ? LOOKUP_ONLYCONVERTING :*/ 0);"}]}