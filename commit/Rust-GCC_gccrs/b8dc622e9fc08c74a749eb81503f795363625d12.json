{"sha": "b8dc622e9fc08c74a749eb81503f795363625d12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhkYzYyMmU5ZmMwOGM3NGE3NDllYjgxNTAzZjc5NTM2MzYyNWQxMg==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2006-02-15T09:43:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:43:54Z"}, "message": "sem_attr.adb (Analyze_Attribute): In case of 'Class applied to an abstract interface type call...\n\n2006-02-13  Javier Miranda  <miranda@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute): In case of 'Class applied to an\n\tabstract interface type call analyze_and_resolve to expand the type\n\tconversion into the corresponding displacement of the\n\treference to the base of the object.\n\t(Eval_Attribute, case Width): For systems where IEEE extended precision\n\tis supported, the maximum exponent occupies 4 decimal digits.\n\t(Accessibility_Message): Add '\\' in 2-line warning message.\n\t(Resolve_Attribute): Likewise.\n\t(case Attribute_Access): Significantly revise checks\n\tfor illegal access-to-subprogram Access attributes to properly enforce\n\tthe rules of 3.10.2(32/2).\n\tDiagnose use of current instance with an illegal attribute.\n\n        * sem_util.ads, sem_util.adb (Enclosing_Generic_Body): Change formal\n        to a Node_Id.\n        (Enclosing_Generic_Unit): New function to return a node's innermost\n        enclosing generic declaration node.\n        (Compile_Time_Constraint_Error): Remove '!' in warning messages.\n        (Type_Access_Level): The accessibility level of anonymous acccess types\n        associated with discriminants is that of the current instance of the\n        type, and that's deeper than the type itself (AARM 3.10.2 (12.3.21)).\n        (Compile_Time_Constraint_Error): Handle case of conditional expression.\n        (Kill_Current_Values_For_Entity): New function\n        (Enter_Name): Change formal type to Entity_Id\n\nFrom-SVN: r111089", "tree": {"sha": "1d16e0eebddebf22d1b363d9903009b9a5270825", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d16e0eebddebf22d1b363d9903009b9a5270825"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8dc622e9fc08c74a749eb81503f795363625d12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8dc622e9fc08c74a749eb81503f795363625d12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8dc622e9fc08c74a749eb81503f795363625d12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8dc622e9fc08c74a749eb81503f795363625d12/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b96e234f8e646b43bafda4670770276f94b07bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b96e234f8e646b43bafda4670770276f94b07bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b96e234f8e646b43bafda4670770276f94b07bc"}], "stats": {"total": 410, "additions": 321, "deletions": 89}, "files": [{"sha": "1a72883677e55bef42774c61248ddad265db7857", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 163, "deletions": 49, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8dc622e9fc08c74a749eb81503f795363625d12/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8dc622e9fc08c74a749eb81503f795363625d12/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=b8dc622e9fc08c74a749eb81503f795363625d12", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -56,7 +56,6 @@ with Sem_Util; use Sem_Util;\n with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n-with Stand;\n with Stringt;  use Stringt;\n with Targparm; use Targparm;\n with Ttypes;   use Ttypes;\n@@ -1151,7 +1150,7 @@ package body Sem_Attr is\n                end if;\n \n                if Ekind (Typ) = E_Incomplete_Type\n-                 and then not Present (Full_View (Typ))\n+                 and then No (Full_View (Typ))\n                then\n                   Error_Attr\n                     (\"prefix of % attribute cannot be an incomplete type\", P);\n@@ -1665,11 +1664,45 @@ package body Sem_Attr is\n          if Is_Entity_Name (P)\n            and then Present (Entity (P))\n            and then Is_Type (Entity (P))\n-           and then Ekind (Entity (P)) = E_Incomplete_Type\n          then\n-            P_Type := Get_Full_View (P_Type);\n-            Set_Entity (P, P_Type);\n-            Set_Etype  (P, P_Type);\n+            if Ekind (Entity (P)) = E_Incomplete_Type then\n+               P_Type := Get_Full_View (P_Type);\n+               Set_Entity (P, P_Type);\n+               Set_Etype  (P, P_Type);\n+\n+            elsif Entity (P) = Current_Scope\n+              and then Is_Record_Type (Entity (P))\n+            then\n+\n+               --  Use of current instance within the type. Verify that if the\n+               --  attribute appears within a constraint, it  yields an access\n+               --  type, other uses are illegal.\n+\n+               declare\n+                  Par : Node_Id;\n+\n+               begin\n+                  Par := Parent (N);\n+                  while Present (Par)\n+                    and then Nkind (Parent (Par)) /= N_Component_Definition\n+                  loop\n+                     Par := Parent (Par);\n+                  end loop;\n+\n+                  if Present (Par)\n+                    and then Nkind (Par) = N_Subtype_Indication\n+                  then\n+                     if Attr_Id /= Attribute_Access\n+                       and then Attr_Id /= Attribute_Unchecked_Access\n+                       and then Attr_Id /= Attribute_Unrestricted_Access\n+                     then\n+                        Error_Msg_N\n+                          (\"in a constraint the current instance can only\"\n+                             & \" be used with an access attribute\", N);\n+                     end if;\n+                  end if;\n+               end;\n+            end if;\n          end if;\n \n          if P_Type = Any_Type then\n@@ -2274,6 +2307,8 @@ package body Sem_Attr is\n       -----------\n \n       when Attribute_Class => Class : declare\n+         P : constant Entity_Id := Prefix (N);\n+\n       begin\n          Check_Restriction (No_Dispatch, N);\n          Check_Either_E0_Or_E1;\n@@ -2288,12 +2323,22 @@ package body Sem_Attr is\n               Make_Type_Conversion (Loc,\n                 Subtype_Mark =>\n                   Make_Attribute_Reference (Loc,\n-                    Prefix => Prefix (N),\n+                    Prefix => P,\n                     Attribute_Name => Name_Class),\n                 Expression => Relocate_Node (E1)));\n \n             Save_Interps (E1, Expression (N));\n-            Analyze (N);\n+\n+            if not Is_Interface (Etype (P)) then\n+               Analyze (N);\n+\n+            --  Ada 2005 (AI-251): In case of abstract interfaces we have to\n+            --  analyze and resolve the type conversion to generate the code\n+            --  that displaces the reference to the base of the object.\n+\n+            else\n+               Analyze_And_Resolve (N, Etype (P));\n+            end if;\n \n          --  Otherwise we just need to find the proper type\n \n@@ -4725,10 +4770,10 @@ package body Sem_Attr is\n       then\n          P_Type := Etype (P_Entity);\n \n-         --  If the entity is an array constant with an unconstrained\n-         --  nominal subtype then get the type from the initial value.\n-         --  If the value has been expanded into assignments, the expression\n-         --  is not present and the attribute reference remains dynamic.\n+         --  If the entity is an array constant with an unconstrained nominal\n+         --  subtype then get the type from the initial value. If the value has\n+         --  been expanded into assignments, there is no expression and the\n+         --  attribute reference remains dynamic.\n          --  We could do better here and retrieve the type ???\n \n          if Ekind (P_Entity) = E_Constant\n@@ -6447,7 +6492,8 @@ package body Sem_Attr is\n \n                   --  nnn is set to 2 for Short_Float and Float (32 bit\n                   --  floats), and 3 for Long_Float and Long_Long_Float.\n-                  --  This is not quite right, but is good enough.\n+                  --  For machines where Long_Long_Float is the IEEE\n+                  --  extended precision type, the exponent takes 4 digits.\n \n                   declare\n                      Len : Int :=\n@@ -6456,8 +6502,10 @@ package body Sem_Attr is\n                   begin\n                      if Esize (P_Type) <= 32 then\n                         Len := Len + 6;\n-                     else\n+                     elsif Esize (P_Type) = 64 then\n                         Len := Len + 7;\n+                     else\n+                        Len := Len + 8;\n                      end if;\n \n                      Fold_Uint (N, UI_From_Int (Len), True);\n@@ -6782,7 +6830,7 @@ package body Sem_Attr is\n             Error_Msg_N\n               (\"?non-local pointer cannot point to local object\", P);\n             Error_Msg_N\n-              (\"?Program_Error will be raised at run time\", P);\n+              (\"\\?Program_Error will be raised at run time\", P);\n             Rewrite (N,\n               Make_Raise_Program_Error (Loc,\n                 Reason => PE_Accessibility_Check_Failed));\n@@ -6953,49 +7001,115 @@ package body Sem_Attr is\n                   elsif Aname = Name_Unrestricted_Access then\n                      null;  --  Nothing to check\n \n-                  --  Check the static accessibility rule of 3.10.2(32)\n-                  --  In an instance body, if subprogram and type are both\n-                  --  local, other rules prevent dangling references, and no\n-                  --  warning  is needed.\n+                  --  Check the static accessibility rule of 3.10.2(32).\n+                  --  This rule also applies within the private part of an\n+                  --  instantiation. This rule does not apply to anonymous\n+                  --  access-to-subprogram types (Ada 2005).\n \n                   elsif Attr_Id = Attribute_Access\n+                    and then not In_Instance_Body\n                     and then Subprogram_Access_Level (Entity (P)) >\n                                Type_Access_Level (Btyp)\n                     and then Ekind (Btyp) /=\n                                E_Anonymous_Access_Subprogram_Type\n                     and then Ekind (Btyp) /=\n                                E_Anonymous_Access_Protected_Subprogram_Type\n                   then\n-                     if not In_Instance_Body then\n-                        Error_Msg_N\n-                          (\"subprogram must not be deeper than access type\",\n-                            P);\n-\n-                     elsif Scope (Entity (P)) /= Scope (Btyp) then\n-                        Error_Msg_N\n-                          (\"subprogram must not be deeper than access type?\",\n-                             P);\n-                        Error_Msg_N\n-                          (\"Constraint_Error will be raised ?\", P);\n-                        Set_Raises_Constraint_Error (N);\n-                     end if;\n-\n-                  --  Check the restriction of 3.10.2(32) that disallows\n-                  --  the type of the access attribute to be declared\n-                  --  outside a generic body when the subprogram is declared\n-                  --  within that generic body.\n-\n-                  --  Ada2005: If the expected type is for an access\n-                  --  parameter, this clause does not apply.\n+                     Error_Msg_N\n+                       (\"subprogram must not be deeper than access type\", P);\n+\n+                  --  Check the restriction of 3.10.2(32) that disallows the\n+                  --  access attribute within a generic body when the ultimate\n+                  --  ancestor of the type of the attribute is declared outside\n+                  --  of the generic unit and the subprogram is declared within\n+                  --  that generic unit. This includes any such attribute that\n+                  --  occurs within the body of a generic unit that is a child\n+                  --  of the generic unit where the subprogram is declared.\n+                  --  The rule also prohibits applying the attibute when the\n+                  --  access type is a generic formal access type (since the\n+                  --  level of the actual type is not known). This restriction\n+                  --  does not apply when the attribute type is an anonymous\n+                  --  access-to-subprogram type. Note that this check was\n+                  --  revised by AI-229, because the originally Ada 95 rule\n+                  --  was too lax. The original rule only applied when the\n+                  --  subprogram was declared within the body of the generic,\n+                  --  which allowed the possibility of dangling references).\n+                  --  The rule was also too strict in some case, in that it\n+                  --  didn't permit the access to be declared in the generic\n+                  --  spec, whereas the revised rule does (as long as it's not\n+                  --  a formal type).\n+\n+                  --  There are a couple of subtleties of the test for applying\n+                  --  the check that are worth noting. First, we only apply it\n+                  --  when the levels of the subprogram and access type are the\n+                  --  same (the case where the subprogram is statically deeper\n+                  --  was applied above, and the case where the type is deeper\n+                  --  is always safe). Second, we want the check to apply\n+                  --  within nested generic bodies and generic child unit\n+                  --  bodies, but not to apply to an attribute that appears in\n+                  --  the generic unit's specification. This is done by testing\n+                  --  that the attribute's innermost enclosing generic body is\n+                  --  not the same as the innermost generic body enclosing the\n+                  --  generic unit where the subprogram is declared (we don't\n+                  --  want the check to apply when the access attribute is in\n+                  --  the spec and there's some other generic body enclosing\n+                  --  generic). Finally, there's no point applying the check\n+                  --  when within an instance, because any violations will\n+                  --  have been caught by the compilation of the generic unit.\n \n-                  elsif Present (Enclosing_Generic_Body (Entity (P)))\n-                    and then Enclosing_Generic_Body (Entity (P)) /=\n-                             Enclosing_Generic_Body (Btyp)\n-                    and then\n-                      Ekind (Btyp) /= E_Anonymous_Access_Subprogram_Type\n+                  elsif Attr_Id = Attribute_Access\n+                    and then not In_Instance\n+                    and then Present (Enclosing_Generic_Unit (Entity (P)))\n+                    and then Present (Enclosing_Generic_Body (N))\n+                    and then Enclosing_Generic_Body (N) /=\n+                               Enclosing_Generic_Body\n+                                 (Enclosing_Generic_Unit (Entity (P)))\n+                    and then Subprogram_Access_Level (Entity (P)) =\n+                               Type_Access_Level (Btyp)\n+                    and then Ekind (Btyp) /=\n+                               E_Anonymous_Access_Subprogram_Type\n+                    and then Ekind (Btyp) /=\n+                               E_Anonymous_Access_Protected_Subprogram_Type\n                   then\n-                     Error_Msg_N\n-                       (\"access type must not be outside generic body\", P);\n+                     --  The attribute type's ultimate ancestor must be\n+                     --  declared within the same generic unit as the\n+                     --  subprogram is declared. The error message is\n+                     --  specialized to say \"ancestor\" for the case where\n+                     --  the access type is not its own ancestor, since\n+                     --  saying simply \"access type\" would be very confusing.\n+\n+                     if Enclosing_Generic_Unit (Entity (P)) /=\n+                          Enclosing_Generic_Unit (Root_Type (Btyp))\n+                     then\n+                        if Root_Type (Btyp) = Btyp then\n+                           Error_Msg_N\n+                             (\"access type must not be outside generic unit\",\n+                              N);\n+                        else\n+                           Error_Msg_N\n+                             (\"ancestor access type must not be outside \" &\n+                              \"generic unit\", N);\n+                        end if;\n+\n+                     --  If the ultimate ancestor of the attribute's type is\n+                     --  a formal type, then the attribute is illegal because\n+                     --  the actual type might be declared at a higher level.\n+                     --  The error message is specialized to say \"ancestor\"\n+                     --  for the case where the access type is not its own\n+                     --  ancestor, since saying simply \"access type\" would be\n+                     --  very confusing.\n+\n+                     elsif Is_Generic_Type (Root_Type (Btyp)) then\n+                        if Root_Type (Btyp) = Btyp then\n+                           Error_Msg_N\n+                             (\"access type must not be a generic formal type\",\n+                              N);\n+                        else\n+                           Error_Msg_N\n+                             (\"ancestor access type must not be a generic \" &\n+                              \"formal type\", N);\n+                        end if;\n+                     end if;\n                   end if;\n                end if;\n \n@@ -7095,7 +7209,7 @@ package body Sem_Attr is\n                      Error_Msg_N\n                        (\"?non-local pointer cannot point to local object\", P);\n                      Error_Msg_N\n-                       (\"?Program_Error will be raised at run time\", P);\n+                       (\"\\?Program_Error will be raised at run time\", P);\n                      Rewrite (N,\n                        Make_Raise_Program_Error (Loc,\n                          Reason => PE_Accessibility_Check_Failed));"}, {"sha": "a9b64c70136fd7f5fadfb1ef8cdda26da9274817", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 139, "deletions": 32, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8dc622e9fc08c74a749eb81503f795363625d12/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8dc622e9fc08c74a749eb81503f795363625d12/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b8dc622e9fc08c74a749eb81503f795363625d12", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -138,8 +138,8 @@ package body Sem_Util is\n          Rtyp := Typ;\n       end if;\n \n-      Discard_Node (\n-        Compile_Time_Constraint_Error (N, Msg, Ent, Loc, Warn => Warn));\n+      Discard_Node\n+        (Compile_Time_Constraint_Error (N, Msg, Ent, Loc, Warn => Warn));\n \n       if not Rep then\n          return;\n@@ -1103,6 +1103,7 @@ package body Sem_Util is\n       Msgl : Natural;\n       Wmsg : Boolean;\n       P    : Node_Id;\n+      OldP : Node_Id;\n       Msgs : Boolean;\n       Eloc : Source_Ptr;\n \n@@ -1157,28 +1158,72 @@ package body Sem_Util is\n          --  Should we generate a warning? The answer is not quite yes. The\n          --  very annoying exception occurs in the case of a short circuit\n          --  operator where the left operand is static and decisive. Climb\n-         --  parents to see if that is the case we have here.\n+         --  parents to see if that is the case we have here. Conditional\n+         --  expressions with decisive conditions are a similar situation.\n \n          Msgs := True;\n          P := N;\n-\n          loop\n+            OldP := P;\n             P := Parent (P);\n \n-            if (Nkind (P) = N_And_Then\n-                and then Compile_Time_Known_Value (Left_Opnd (P))\n-                and then Is_False (Expr_Value (Left_Opnd (P))))\n-              or else (Nkind (P) = N_Or_Else\n-                and then Compile_Time_Known_Value (Left_Opnd (P))\n-                and then Is_True (Expr_Value (Left_Opnd (P))))\n+            --  And then with False as left operand\n+\n+            if Nkind (P) = N_And_Then\n+              and then Compile_Time_Known_Value (Left_Opnd (P))\n+              and then Is_False (Expr_Value (Left_Opnd (P)))\n             then\n                Msgs := False;\n                exit;\n \n+            --  OR ELSE with True as left operand\n+\n+            elsif Nkind (P) = N_Or_Else\n+              and then Compile_Time_Known_Value (Left_Opnd (P))\n+              and then Is_True (Expr_Value (Left_Opnd (P)))\n+            then\n+               Msgs := False;\n+               exit;\n+\n+            --  Conditional expression\n+\n+            elsif Nkind (P) = N_Conditional_Expression then\n+               declare\n+                  Cond : constant Node_Id := First (Expressions (P));\n+                  Texp : constant Node_Id := Next (Cond);\n+                  Fexp : constant Node_Id := Next (Texp);\n+\n+               begin\n+                  if Compile_Time_Known_Value (Cond) then\n+\n+                     --  Condition is True and we are in the right operand\n+\n+                     if Is_True (Expr_Value (Cond))\n+                       and then OldP = Fexp\n+                     then\n+                        Msgs := False;\n+                        exit;\n+\n+                     --  Condition is False and we are in the left operand\n+\n+                     elsif Is_False (Expr_Value (Cond))\n+                       and then OldP = Texp\n+                     then\n+                        Msgs := False;\n+                        exit;\n+                     end if;\n+                  end if;\n+               end;\n+\n+            --  Special case for component association in aggregates, where\n+            --  we want to keep climbing up to the parent aggregate.\n+\n             elsif Nkind (P) = N_Component_Association\n               and then Nkind (Parent (P)) = N_Aggregate\n             then\n-               null;  --   Keep going.\n+               null;\n+\n+            --  Keep going if within subexpression\n \n             else\n                exit when Nkind (P) not in N_Subexpr;\n@@ -1195,11 +1240,11 @@ package body Sem_Util is\n             if Wmsg then\n                if Inside_Init_Proc then\n                   Error_Msg_NEL\n-                    (\"\\& will be raised for objects of this type!?\",\n+                    (\"\\?& will be raised for objects of this type\",\n                      N, Standard_Constraint_Error, Eloc);\n                else\n                   Error_Msg_NEL\n-                    (\"\\& will be raised at run time!?\",\n+                    (\"\\?& will be raised at run time\",\n                      N, Standard_Constraint_Error, Eloc);\n                end if;\n             else\n@@ -1536,15 +1581,14 @@ package body Sem_Util is\n    ----------------------------\n \n    function Enclosing_Generic_Body\n-     (E : Entity_Id) return Node_Id\n+     (N : Node_Id) return Node_Id\n    is\n       P    : Node_Id;\n       Decl : Node_Id;\n       Spec : Node_Id;\n \n    begin\n-      P := Parent (E);\n-\n+      P := Parent (N);\n       while Present (P) loop\n          if Nkind (P) = N_Package_Body\n            or else Nkind (P) = N_Subprogram_Body\n@@ -1568,6 +1612,47 @@ package body Sem_Util is\n       return Empty;\n    end Enclosing_Generic_Body;\n \n+   ----------------------------\n+   -- Enclosing_Generic_Unit --\n+   ----------------------------\n+\n+   function Enclosing_Generic_Unit\n+     (N : Node_Id) return Node_Id\n+   is\n+      P    : Node_Id;\n+      Decl : Node_Id;\n+      Spec : Node_Id;\n+\n+   begin\n+      P := Parent (N);\n+      while Present (P) loop\n+         if Nkind (P) = N_Generic_Package_Declaration\n+           or else Nkind (P) = N_Generic_Subprogram_Declaration\n+         then\n+            return P;\n+\n+         elsif Nkind (P) = N_Package_Body\n+           or else Nkind (P) = N_Subprogram_Body\n+         then\n+            Spec := Corresponding_Spec (P);\n+\n+            if Present (Spec) then\n+               Decl := Unit_Declaration_Node (Spec);\n+\n+               if Nkind (Decl) = N_Generic_Package_Declaration\n+                 or else Nkind (Decl) = N_Generic_Subprogram_Declaration\n+               then\n+                  return Decl;\n+               end if;\n+            end if;\n+         end if;\n+\n+         P := Parent (P);\n+      end loop;\n+\n+      return Empty;\n+   end Enclosing_Generic_Unit;\n+\n    -------------------------------\n    -- Enclosing_Lib_Unit_Entity --\n    -------------------------------\n@@ -1660,7 +1745,7 @@ package body Sem_Util is\n    -- Enter_Name --\n    ----------------\n \n-   procedure Enter_Name (Def_Id : Node_Id) is\n+   procedure Enter_Name (Def_Id : Entity_Id) is\n       C : constant Entity_Id := Current_Entity (Def_Id);\n       E : constant Entity_Id := Current_Entity_In_Scope (Def_Id);\n       S : constant Entity_Id := Current_Scope;\n@@ -2450,7 +2535,7 @@ package body Sem_Util is\n       Atyp : Entity_Id;\n \n    begin\n-      if not Present (Utyp) then\n+      if No (Utyp) then\n          Utyp := Typ;\n       end if;\n \n@@ -5054,6 +5139,20 @@ package body Sem_Util is\n    -- Kill_Current_Values --\n    -------------------------\n \n+   procedure Kill_Current_Values (Ent : Entity_Id) is\n+   begin\n+      if Is_Object (Ent) then\n+         Kill_Checks (Ent);\n+         Set_Current_Value (Ent, Empty);\n+\n+         if not Can_Never_Be_Null (Ent) then\n+            Set_Is_Known_Non_Null (Ent, False);\n+         end if;\n+\n+         Set_Is_Known_Null (Ent, False);\n+      end if;\n+   end Kill_Current_Values;\n+\n    procedure Kill_Current_Values is\n       S : Entity_Id;\n \n@@ -5066,18 +5165,10 @@ package body Sem_Util is\n \n       procedure Kill_Current_Values_For_Entity_Chain (E : Entity_Id) is\n          Ent : Entity_Id;\n-\n       begin\n          Ent := E;\n          while Present (Ent) loop\n-            if Is_Object (Ent) then\n-               Set_Current_Value (Ent, Empty);\n-\n-               if not Can_Never_Be_Null (Ent) then\n-                  Set_Is_Known_Non_Null (Ent, False);\n-               end if;\n-            end if;\n-\n+            Kill_Current_Values (Ent);\n             Next_Entity (Ent);\n          end loop;\n       end Kill_Current_Values_For_Entity_Chain;\n@@ -5570,6 +5661,7 @@ package body Sem_Util is\n                   --  side effects have been removed.\n \n                   Exp := Prefix (Expression (Parent (Entity (P))));\n+                  goto Continue;\n \n                else\n                   return;\n@@ -5581,36 +5673,39 @@ package body Sem_Util is\n            or else Nkind (Exp) = N_Unchecked_Type_Conversion\n          then\n             Exp := Expression (Exp);\n+            goto Continue;\n \n          elsif     Nkind (Exp) = N_Slice\n            or else Nkind (Exp) = N_Indexed_Component\n            or else Nkind (Exp) = N_Selected_Component\n          then\n             Exp := Prefix (Exp);\n+            goto Continue;\n \n          else\n             return;\n-\n          end if;\n \n          --  Now look for entity being referenced\n \n          if Present (Ent) then\n-\n             if Is_Object (Ent) then\n                if Comes_From_Source (Exp)\n                  or else Modification_Comes_From_Source\n                then\n                   Set_Never_Set_In_Source (Ent, False);\n                end if;\n \n-               Set_Is_True_Constant    (Ent, False);\n-               Set_Current_Value       (Ent, Empty);\n+               Set_Is_True_Constant (Ent, False);\n+               Set_Current_Value    (Ent, Empty);\n+               Set_Is_Known_Null    (Ent, False);\n \n                if not Can_Never_Be_Null (Ent) then\n                   Set_Is_Known_Non_Null (Ent, False);\n                end if;\n \n+               --  Follow renaming chain\n+\n                if (Ekind (Ent) = E_Variable or else Ekind (Ent) = E_Constant)\n                  and then Present (Renamed_Object (Ent))\n                then\n@@ -6746,6 +6841,18 @@ package body Sem_Util is\n          end if;\n \n          Btyp := Root_Type (Btyp);\n+\n+         --  The accessibility level of anonymous acccess types associated with\n+         --  discriminants is that of the current instance of the type, and\n+         --  that's deeper than the type itself (AARM 3.10.2 (12.3.21)).\n+\n+         if Ekind (Typ) = E_Anonymous_Access_Type\n+           and then Present (Associated_Node_For_Itype (Typ))\n+           and then Nkind (Associated_Node_For_Itype (Typ)) =\n+                                                 N_Discriminant_Specification\n+         then\n+            return Scope_Depth (Enclosing_Dynamic_Scope (Btyp)) + 1;\n+         end if;\n       end if;\n \n       return Scope_Depth (Enclosing_Dynamic_Scope (Btyp));"}, {"sha": "c6f847b11ae33431e1baaf1c6a7a6dee55410065", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8dc622e9fc08c74a749eb81503f795363625d12/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8dc622e9fc08c74a749eb81503f795363625d12/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=b8dc622e9fc08c74a749eb81503f795363625d12", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -136,11 +136,12 @@ package Sem_Util is\n       Ent  : Entity_Id  := Empty;\n       Loc  : Source_Ptr := No_Location;\n       Warn : Boolean    := False) return Node_Id;\n-   --  Subsidiary to Apply_Compile_Time_Constraint_Error and Checks routines.\n-   --  Does not modify any nodes, but generates a warning (or error) message.\n-   --  For convenience, the function always returns its first argument. The\n-   --  message is a warning if the message ends with ?, or we are operating\n-   --  in Ada 83 mode, or if the Warn parameter is set to True.\n+   --  This is similar to Apply_Compile_Time_Constraint_Error in that it\n+   --  generates a warning (or error) message in the same manner, but it does\n+   --  not replace any nodes. For convenience, the function always returns its\n+   --  first argument. The message is a warning if the message ends with ?, or\n+   --  we are operating in Ada 83 mode, or if the Warn parameter is set to\n+   --  True.\n \n    procedure Conditional_Delay (New_Ent, Old_Ent : Entity_Id);\n    --  Sets the Has_Delayed_Freeze flag of New if the Delayed_Freeze flag\n@@ -194,10 +195,15 @@ package Sem_Util is\n    --  an expanded name, a defining program unit name or an identifier\n \n    function Enclosing_Generic_Body\n-     (E : Entity_Id) return Node_Id;\n+     (N : Node_Id) return Node_Id;\n    --  Returns the Node_Id associated with the innermost enclosing\n    --  generic body, if any. If none, then returns Empty.\n \n+   function Enclosing_Generic_Unit\n+     (N : Node_Id) return Node_Id;\n+   --  Returns the Node_Id associated with the innermost enclosing\n+   --  generic unit, if any. If none, then returns Empty.\n+\n    function Enclosing_Lib_Unit_Entity return Entity_Id;\n    --  Returns the entity of enclosing N_Compilation_Unit Node which is the\n    --  root of the current scope (which must not be Standard_Standard, and\n@@ -216,7 +222,7 @@ package Sem_Util is\n    --  build and initialize a new freeze node and set Has_Delayed_Freeze\n    --  true for entity E.\n \n-   procedure Enter_Name (Def_Id : Node_Id);\n+   procedure Enter_Name (Def_Id : Entity_Id);\n    --  Insert new name in symbol table of current scope with check for\n    --  duplications (error message is issued if a conflict is found)\n    --  Note: Enter_Name is not used for overloadable entities, instead\n@@ -627,6 +633,11 @@ package Sem_Util is\n    --  Is_Known_Non_Null flags in variables, constants or parameters\n    --  since these are also not known to be valid.\n \n+   procedure Kill_Current_Values (Ent : Entity_Id);\n+   --  This performs the same processing as described above for the form with\n+   --  no argument, but for the specific entity given. The call has no effect\n+   --  if the entity Ent is not for an object.\n+\n    procedure Kill_Size_Check_Code (E : Entity_Id);\n    --  Called when an address clause or pragma Import is applied to an\n    --  entity. If the entity is a variable or a constant, and size check"}]}