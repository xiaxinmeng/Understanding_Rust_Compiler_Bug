{"sha": "10303118b35501a5e2f26fdaf91a3732e10cd9d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAzMDMxMThiMzU1MDFhNWUyZjI2ZmRhZjkxYTM3MzJlMTBjZDlkNw==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2007-12-19T16:22:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-19T16:22:40Z"}, "message": "atree.ads, atree.adb (Traverse_Func): Walk Field2 last, and eliminate the resulting tail recursion by hand.\n\n2007-12-19  Bob Duff  <duff@adacore.com>\n\n\t* atree.ads, atree.adb (Traverse_Func): Walk Field2 last, and eliminate\n\tthe resulting tail recursion by hand. This prevents running out of\n\tmemory on deeply nested concatenations, since Field2 is where the left\n\toperand of concatenations is stored.\n\tFix bug (was returning OK_Orig in some cases). Fix return subtype to\n\tclarify that it can only return OK or Abandon.\n\n\t* sem_res.adb (Resolve_Op_Concat): Replace the recursion on the left\n\toperand by iteration, in order to avoid running out of memory on\n\tdeeply-nested concatenations. Use the Parent pointer to get back up the\n\ttree.\n\t(Resolve_Op_Concat_Arg, Resolve_Op_Concat_First,\n\t Resolve_Op_Concat_Rest): New procedures split out of\n\tResolve_Op_Concat, so the iterative algorithm in Resolve_Op_Concat is\n\tclearer.\n\n\t* checks.adb (Remove_Checks): Use Traverse_Proc instead of\n\tTraverse_Func, because the former already takes care of discarding the\n\tresult.\n\n\t* errout.adb (First_Node): Use Traverse_Proc instead of Traverse_Func,\n\tbecause the former already takes care of discarding the result.\n\t(Remove_Warning_Messages): Use appropriate subtype for Status and\n\tDiscard\n\nFrom-SVN: r131070", "tree": {"sha": "332b098dbd6b86d59d72a861304c31b6b5b32d63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/332b098dbd6b86d59d72a861304c31b6b5b32d63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10303118b35501a5e2f26fdaf91a3732e10cd9d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10303118b35501a5e2f26fdaf91a3732e10cd9d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10303118b35501a5e2f26fdaf91a3732e10cd9d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10303118b35501a5e2f26fdaf91a3732e10cd9d7/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "160df9790776eba4c811b18c96c8e7e83d02835e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/160df9790776eba4c811b18c96c8e7e83d02835e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/160df9790776eba4c811b18c96c8e7e83d02835e"}], "stats": {"total": 404, "additions": 232, "deletions": 172}, "files": [{"sha": "414fd62d734c07d14e1b2dc2e7a98973ddccfc36", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10303118b35501a5e2f26fdaf91a3732e10cd9d7/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10303118b35501a5e2f26fdaf91a3732e10cd9d7/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=10303118b35501a5e2f26fdaf91a3732e10cd9d7", "patch": "@@ -2624,12 +2624,12 @@ package body Atree is\n    -- Traverse_Func --\n    -------------------\n \n-   function Traverse_Func (Node : Node_Id) return Traverse_Result is\n+   function Traverse_Func (Node : Node_Id) return Traverse_Final_Result is\n \n       function Traverse_Field\n         (Nod : Node_Id;\n          Fld : Union_Id;\n-         FN  : Field_Num) return Traverse_Result;\n+         FN  : Field_Num) return Traverse_Final_Result;\n       --  Fld is one of the fields of Nod. If the field points to syntactic\n       --  node or list, then this node or list is traversed, and the result is\n       --  the result of this traversal. Otherwise a value of True is returned\n@@ -2642,7 +2642,7 @@ package body Atree is\n       function Traverse_Field\n         (Nod : Node_Id;\n          Fld : Union_Id;\n-         FN  : Field_Num) return Traverse_Result\n+         FN  : Field_Num) return Traverse_Final_Result\n       is\n       begin\n          if Fld = Union_Id (Empty) then\n@@ -2697,52 +2697,59 @@ package body Atree is\n          end if;\n       end Traverse_Field;\n \n+      Cur_Node : Node_Id := Node;\n+\n    --  Start of processing for Traverse_Func\n \n    begin\n-      case Process (Node) is\n+      --  We walk Field2 last, and if it is a node, we eliminate the tail\n+      --  recursion by jumping back to this label. This is because Field2 is\n+      --  where the Left_Opnd field of N_Op_Concat is stored, and in practice\n+      --  concatenations are sometimes deeply nested, as in X1&X2&...&XN. This\n+      --  trick prevents us from running out of memory in that case. We don't\n+      --  bother eliminating the tail recursion if Field2 is a list.\n+\n+      <<Tail_Recurse>>\n+\n+      case Process (Cur_Node) is\n          when Abandon =>\n             return Abandon;\n \n          when Skip =>\n             return OK;\n \n          when OK =>\n-            if Traverse_Field (Node, Union_Id (Field1 (Node)), 1) = Abandon\n-                 or else\n-               Traverse_Field (Node, Union_Id (Field2 (Node)), 2) = Abandon\n-                 or else\n-               Traverse_Field (Node, Union_Id (Field3 (Node)), 3) = Abandon\n-                 or else\n-               Traverse_Field (Node, Union_Id (Field4 (Node)), 4) = Abandon\n-                 or else\n-               Traverse_Field (Node, Union_Id (Field5 (Node)), 5) = Abandon\n-            then\n-               return Abandon;\n-            else\n-               return OK;\n-            end if;\n+            null;\n \n          when OK_Orig =>\n-            declare\n-               Onod : constant Node_Id := Original_Node (Node);\n-            begin\n-               if Traverse_Field (Onod, Union_Id (Field1 (Onod)), 1) = Abandon\n-                    or else\n-                  Traverse_Field (Onod, Union_Id (Field2 (Onod)), 2) = Abandon\n-                    or else\n-                  Traverse_Field (Onod, Union_Id (Field3 (Onod)), 3) = Abandon\n-                    or else\n-                  Traverse_Field (Onod, Union_Id (Field4 (Onod)), 4) = Abandon\n-                    or else\n-                  Traverse_Field (Onod, Union_Id (Field5 (Onod)), 5) = Abandon\n-               then\n-                  return Abandon;\n-               else\n-                  return OK_Orig;\n-               end if;\n-            end;\n+            Cur_Node := Original_Node (Cur_Node);\n       end case;\n+\n+      if Traverse_Field (Cur_Node, Field1 (Cur_Node), 1) = Abandon\n+           or else  --  skip Field2 here\n+         Traverse_Field (Cur_Node, Field3 (Cur_Node), 3) = Abandon\n+           or else\n+         Traverse_Field (Cur_Node, Field4 (Cur_Node), 4) = Abandon\n+           or else\n+         Traverse_Field (Cur_Node, Field5 (Cur_Node), 5) = Abandon\n+      then\n+         return Abandon;\n+      end if;\n+\n+      if Field2 (Cur_Node) not in Node_Range then\n+         return Traverse_Field (Cur_Node, Field2 (Cur_Node), 2);\n+      elsif Is_Syntactic_Field (Nkind (Cur_Node), 2) and then\n+        Field2 (Cur_Node) /= Empty_List_Or_Node\n+      then\n+         --  Here is the tail recursion step, we reset Cur_Node and jump\n+         --  back to the start of the procedure, which has the same\n+         --  semantic effect as a call.\n+\n+         Cur_Node := Node_Id (Field2 (Cur_Node));\n+         goto Tail_Recurse;\n+      end if;\n+\n+      return OK;\n    end Traverse_Func;\n \n    -------------------\n@@ -2751,7 +2758,7 @@ package body Atree is\n \n    procedure Traverse_Proc (Node : Node_Id) is\n       function Traverse is new Traverse_Func (Process);\n-      Discard : Traverse_Result;\n+      Discard : Traverse_Final_Result;\n       pragma Warnings (Off, Discard);\n    begin\n       Discard := Traverse (Node);"}, {"sha": "ab9fdb4bf1faa6602556b137b30540c66c20ad15", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10303118b35501a5e2f26fdaf91a3732e10cd9d7/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10303118b35501a5e2f26fdaf91a3732e10cd9d7/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=10303118b35501a5e2f26fdaf91a3732e10cd9d7", "patch": "@@ -503,18 +503,22 @@ package Atree is\n    --  function is used only by Sinfo.CN to change nodes into their\n    --  corresponding entities.\n \n-   type Traverse_Result is (OK, OK_Orig, Skip, Abandon);\n+   type Traverse_Result is (Abandon, OK, OK_Orig, Skip);\n    --  This is the type of the result returned by the Process function passed\n-   --  to Traverse_Func and Traverse_Proc and also the type of the result of\n-   --  Traverse_Func itself. See descriptions below for details.\n+   --  to Traverse_Func and Traverse_Proc. See below for details.\n+\n+   subtype Traverse_Final_Result is Traverse_Result range Abandon .. OK;\n+   --  This is the type of the final result returned Traverse_Func, based on\n+   --  the results of Process calls. See below for details.\n \n    generic\n      with function Process (N : Node_Id) return Traverse_Result is <>;\n-   function Traverse_Func (Node : Node_Id) return Traverse_Result;\n+   function Traverse_Func (Node : Node_Id) return Traverse_Final_Result;\n    --  This is a generic function that, given the parent node for a subtree,\n    --  traverses all syntactic nodes of this tree, calling the given function\n-   --  Process on each one. The traversal is controlled as follows by the\n-   --  result returned by Process:\n+   --  Process on each one, in pre order (i.e. top-down). The order of\n+   --  traversing subtrees is arbitrary. The traversal is controlled as follows\n+   --  by the result returned by Process:\n \n    --    OK       The traversal continues normally with the syntactic\n    --             children of the node just processed.\n@@ -537,7 +541,7 @@ package Atree is\n      with function Process (N : Node_Id) return Traverse_Result is <>;\n    procedure Traverse_Proc (Node : Node_Id);\n    pragma Inline (Traverse_Proc);\n-   --  This is similar to Traverse_Func except that no result is returned,\n+   --  This is the same as Traverse_Func except that no result is returned,\n    --  i.e. Traverse_Func is called and the result is simply discarded.\n \n    ---------------------------"}, {"sha": "b179fff325df55b24f7b89a14ef8b39b8028f4de", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10303118b35501a5e2f26fdaf91a3732e10cd9d7/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10303118b35501a5e2f26fdaf91a3732e10cd9d7/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=10303118b35501a5e2f26fdaf91a3732e10cd9d7", "patch": "@@ -2360,7 +2360,6 @@ package body Checks is\n          Analyze_And_Resolve (N, Typ);\n          return;\n       end if;\n-\n    end Apply_Universal_Integer_Attribute_Checks;\n \n    -------------------------------\n@@ -5366,14 +5365,11 @@ package body Checks is\n    -------------------\n \n    procedure Remove_Checks (Expr : Node_Id) is\n-      Discard : Traverse_Result;\n-      pragma Warnings (Off, Discard);\n-\n       function Process (N : Node_Id) return Traverse_Result;\n       --  Process a single node during the traversal\n \n-      function Traverse is new Traverse_Func (Process);\n-      --  The traversal function itself\n+      procedure Traverse is new Traverse_Proc (Process);\n+      --  The traversal procedure itself\n \n       -------------\n       -- Process --\n@@ -5389,7 +5385,7 @@ package body Checks is\n \n          case Nkind (N) is\n             when N_And_Then =>\n-               Discard := Traverse (Left_Opnd (N));\n+               Traverse (Left_Opnd (N));\n                return Skip;\n \n             when N_Attribute_Reference =>\n@@ -5425,7 +5421,7 @@ package body Checks is\n                end case;\n \n             when N_Or_Else =>\n-               Discard := Traverse (Left_Opnd (N));\n+               Traverse (Left_Opnd (N));\n                return Skip;\n \n             when N_Selected_Component =>\n@@ -5446,7 +5442,7 @@ package body Checks is\n    --  Start of processing for Remove_Checks\n \n    begin\n-      Discard := Traverse (Expr);\n+      Traverse (Expr);\n    end Remove_Checks;\n \n    ----------------------------"}, {"sha": "e0f649222d6d5ebb120371cd557626d2d50fffb8", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10303118b35501a5e2f26fdaf91a3732e10cd9d7/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10303118b35501a5e2f26fdaf91a3732e10cd9d7/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=10303118b35501a5e2f26fdaf91a3732e10cd9d7", "patch": "@@ -1235,15 +1235,12 @@ package body Errout is\n       Sfile    : constant Source_File_Index := Get_Source_File_Index (L);\n       Earliest : Node_Id;\n       Eloc     : Source_Ptr;\n-      Discard  : Traverse_Result;\n-\n-      pragma Warnings (Off, Discard);\n \n       function Test_Earlier (N : Node_Id) return Traverse_Result;\n       --  Function applied to every node in the construct\n \n-      function Search_Tree_First is new Traverse_Func (Test_Earlier);\n-      --  Create traversal function\n+      procedure Search_Tree_First is new Traverse_Proc (Test_Earlier);\n+      --  Create traversal procedure\n \n       ------------------\n       -- Test_Earlier --\n@@ -1273,7 +1270,7 @@ package body Errout is\n    begin\n       Earliest := Original_Node (C);\n       Eloc := Sloc (Earliest);\n-      Discard := Search_Tree_First (Original_Node (C));\n+      Search_Tree_First (Original_Node (C));\n       return Earliest;\n    end First_Node;\n \n@@ -1982,7 +1979,7 @@ package body Errout is\n             --  to the tree is harmless.\n \n             declare\n-               Status : Traverse_Result;\n+               Status : Traverse_Final_Result;\n \n             begin\n                if Is_List_Member (N) then\n@@ -2006,7 +2003,7 @@ package body Errout is\n    begin\n       if Warnings_Detected /= 0 then\n          declare\n-            Discard : Traverse_Result;\n+            Discard : Traverse_Final_Result;\n             pragma Warnings (Off, Discard);\n \n          begin"}, {"sha": "a741c4676480d2d6a16b904c54bd6e70f0912522", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 167, "deletions": 111, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10303118b35501a5e2f26fdaf91a3732e10cd9d7/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10303118b35501a5e2f26fdaf91a3732e10cd9d7/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=10303118b35501a5e2f26fdaf91a3732e10cd9d7", "patch": "@@ -131,6 +131,23 @@ package body Sem_Res is\n    --  of the task, it must be replaced with a reference to the discriminant\n    --  of the task being called.\n \n+   procedure Resolve_Op_Concat_Arg\n+     (N       : Node_Id;\n+      Arg     : Node_Id;\n+      Typ     : Entity_Id;\n+      Is_Comp : Boolean);\n+   --  Internal procedure for Resolve_Op_Concat to resolve one operand of\n+   --  concatenation operator.  The operand is either of the array type or of\n+   --  the component type. If the operand is an aggregate, and the component\n+   --  type is composite, this is ambiguous if component type has aggregates.\n+\n+   procedure Resolve_Op_Concat_First (N : Node_Id; Typ : Entity_Id);\n+   --  Does the first part of the work of Resolve_Op_Concat\n+\n+   procedure Resolve_Op_Concat_Rest (N : Node_Id; Typ : Entity_Id);\n+   --  Does the \"rest\" of the work of Resolve_Op_Concat, after the left operand\n+   --  has been resolved. See Resolve_Op_Concat for details.\n+\n    procedure Resolve_Allocator                 (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Arithmetic_Op             (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Call                      (N : Node_Id; Typ : Entity_Id);\n@@ -6354,116 +6371,167 @@ package body Sem_Res is\n    -----------------------\n \n    procedure Resolve_Op_Concat (N : Node_Id; Typ : Entity_Id) is\n-      Btyp : constant Entity_Id := Base_Type (Typ);\n-      Op1  : constant Node_Id := Left_Opnd (N);\n-      Op2  : constant Node_Id := Right_Opnd (N);\n \n-      procedure Resolve_Concatenation_Arg (Arg : Node_Id; Is_Comp : Boolean);\n-      --  Internal procedure to resolve one operand of concatenation operator.\n-      --  The operand is either of the array type or of the component type.\n-      --  If the operand is an aggregate, and the component type is composite,\n-      --  this is ambiguous if component type has aggregates.\n+      --  We wish to avoid deep recursion, because concatenations are often\n+      --  deeply nested, as in A&B&...&Z. Therefore, we walk down the left\n+      --  operands nonrecursively until we find something that is not a simple\n+      --  concatenation (A in this case). We resolve that, and then walk back\n+      --  up the tree following Parent pointers, calling Resolve_Op_Concat_Rest\n+      --  to do the rest of the work at each level. The Parent pointers allow\n+      --  us to avoid recursion, and thus avoid running out of memory. See also\n+      --  Sem_Ch4.Analyze_Concatenation, where a similar hack is used.\n \n-      -------------------------------\n-      -- Resolve_Concatenation_Arg --\n-      -------------------------------\n-\n-      procedure Resolve_Concatenation_Arg (Arg : Node_Id; Is_Comp : Boolean) is\n-      begin\n-         if In_Instance then\n-            if Is_Comp\n-              or else (not Is_Overloaded (Arg)\n-               and then Etype (Arg) /= Any_Composite\n-               and then Covers (Component_Type (Typ), Etype (Arg)))\n-            then\n-               Resolve (Arg, Component_Type (Typ));\n-            else\n-               Resolve (Arg, Btyp);\n-            end if;\n+      NN  : Node_Id := N;\n+      Op1 : Node_Id;\n \n-         elsif Has_Compatible_Type (Arg, Component_Type (Typ)) then\n+   begin\n+      --  The following code is equivalent to:\n \n-            if Nkind (Arg) = N_Aggregate\n-              and then Is_Composite_Type (Component_Type (Typ))\n-            then\n-               if Is_Private_Type (Component_Type (Typ)) then\n-                  Resolve (Arg, Btyp);\n+      --    Resolve_Op_Concat_First (NN, Typ);\n+      --    Resolve_Op_Concat_Arg (N, ...);\n+      --    Resolve_Op_Concat_Rest (N, Typ);\n \n-               else\n-                  Error_Msg_N (\"ambiguous aggregate must be qualified\", Arg);\n-                  Set_Etype (Arg, Any_Type);\n-               end if;\n+      --  where the Resolve_Op_Concat_Arg call recurses back here if the left\n+      --  operand is a concatenation.\n \n-            else\n-               if Is_Overloaded (Arg)\n-                 and then Has_Compatible_Type (Arg, Typ)\n-                 and then Etype (Arg) /= Any_Type\n-               then\n+      --  Walk down left operands\n \n-                  declare\n-                     I    : Interp_Index;\n-                     It   : Interp;\n-                     Func : Entity_Id;\n+      loop\n+         Resolve_Op_Concat_First (NN, Typ);\n+         Op1 := Left_Opnd (NN);\n+         exit when not (Nkind (Op1) = N_Op_Concat\n+                         and then not Is_Array_Type (Component_Type (Typ))\n+                         and then Entity (Op1) = Entity (NN));\n+         NN := Op1;\n+      end loop;\n \n-                  begin\n-                     Get_First_Interp (Arg, I, It);\n-                     Func := It.Nam;\n-                     Get_Next_Interp (I, It);\n+      --  Now (given the above example) NN is A&B and Op1 is A\n \n-                     --  Special-case the error message when the overloading\n-                     --  is caused by a function that yields and array and\n-                     --  can be called without parameters.\n+      --  First resolve Op1 ...\n \n-                     if It.Nam = Func then\n-                        Error_Msg_Sloc := Sloc (Func);\n-                        Error_Msg_N (\"ambiguous call to function#\", Arg);\n-                        Error_Msg_NE\n-                          (\"\\\\interpretation as call yields&\", Arg, Typ);\n-                        Error_Msg_NE\n-                          (\"\\\\interpretation as indexing of call yields&\",\n-                            Arg, Component_Type (Typ));\n+      Resolve_Op_Concat_Arg (NN, Op1, Typ, Is_Component_Left_Opnd  (NN));\n \n-                     else\n-                        Error_Msg_N\n-                          (\"ambiguous operand for concatenation!\", Arg);\n-                        Get_First_Interp (Arg, I, It);\n-                        while Present (It.Nam) loop\n-                           Error_Msg_Sloc := Sloc (It.Nam);\n+      --  ... then walk NN back up until we reach N (where we started), calling\n+      --  Resolve_Op_Concat_Rest along the way.\n \n-                           if Base_Type (It.Typ) = Base_Type (Typ)\n-                             or else Base_Type (It.Typ) =\n-                               Base_Type (Component_Type (Typ))\n-                           then\n-                              Error_Msg_N (\"\\\\possible interpretation#\", Arg);\n-                           end if;\n+      loop\n+         Resolve_Op_Concat_Rest (NN, Typ);\n+         exit when NN = N;\n+         NN := Parent (NN);\n+      end loop;\n+   end Resolve_Op_Concat;\n \n-                           Get_Next_Interp (I, It);\n-                        end loop;\n-                     end if;\n-                  end;\n-               end if;\n+   ---------------------------\n+   -- Resolve_Op_Concat_Arg --\n+   ---------------------------\n \n-               Resolve (Arg, Component_Type (Typ));\n+   procedure Resolve_Op_Concat_Arg\n+     (N       : Node_Id;\n+      Arg     : Node_Id;\n+      Typ     : Entity_Id;\n+      Is_Comp : Boolean)\n+   is\n+      Btyp : constant Entity_Id := Base_Type (Typ);\n \n-               if Nkind (Arg) = N_String_Literal then\n-                  Set_Etype (Arg, Component_Type (Typ));\n-               end if;\n+   begin\n+      if In_Instance then\n+         if Is_Comp\n+           or else (not Is_Overloaded (Arg)\n+                     and then Etype (Arg) /= Any_Composite\n+                     and then Covers (Component_Type (Typ), Etype (Arg)))\n+         then\n+            Resolve (Arg, Component_Type (Typ));\n+         else\n+            Resolve (Arg, Btyp);\n+         end if;\n \n-               if Arg = Left_Opnd (N) then\n-                  Set_Is_Component_Left_Opnd (N);\n-               else\n-                  Set_Is_Component_Right_Opnd (N);\n-               end if;\n+      elsif Has_Compatible_Type (Arg, Component_Type (Typ)) then\n+         if Nkind (Arg) = N_Aggregate\n+           and then Is_Composite_Type (Component_Type (Typ))\n+         then\n+            if Is_Private_Type (Component_Type (Typ)) then\n+               Resolve (Arg, Btyp);\n+            else\n+               Error_Msg_N (\"ambiguous aggregate must be qualified\", Arg);\n+               Set_Etype (Arg, Any_Type);\n             end if;\n \n          else\n-            Resolve (Arg, Btyp);\n+            if Is_Overloaded (Arg)\n+              and then Has_Compatible_Type (Arg, Typ)\n+              and then Etype (Arg) /= Any_Type\n+            then\n+               declare\n+                  I    : Interp_Index;\n+                  It   : Interp;\n+                  Func : Entity_Id;\n+\n+               begin\n+                  Get_First_Interp (Arg, I, It);\n+                  Func := It.Nam;\n+                  Get_Next_Interp (I, It);\n+\n+                  --  Special-case the error message when the overloading is\n+                  --  caused by a function that yields an array and can be\n+                  --  called without parameters.\n+\n+                  if It.Nam = Func then\n+                     Error_Msg_Sloc := Sloc (Func);\n+                     Error_Msg_N (\"ambiguous call to function#\", Arg);\n+                     Error_Msg_NE\n+                       (\"\\\\interpretation as call yields&\", Arg, Typ);\n+                     Error_Msg_NE\n+                       (\"\\\\interpretation as indexing of call yields&\",\n+                         Arg, Component_Type (Typ));\n+\n+                  else\n+                     Error_Msg_N\n+                       (\"ambiguous operand for concatenation!\", Arg);\n+                     Get_First_Interp (Arg, I, It);\n+                     while Present (It.Nam) loop\n+                        Error_Msg_Sloc := Sloc (It.Nam);\n+\n+                        if Base_Type (It.Typ) = Base_Type (Typ)\n+                          or else Base_Type (It.Typ) =\n+                            Base_Type (Component_Type (Typ))\n+                        then\n+                           Error_Msg_N (\"\\\\possible interpretation#\", Arg);\n+                        end if;\n+\n+                        Get_Next_Interp (I, It);\n+                     end loop;\n+                  end if;\n+               end;\n+            end if;\n+\n+            Resolve (Arg, Component_Type (Typ));\n+\n+            if Nkind (Arg) = N_String_Literal then\n+               Set_Etype (Arg, Component_Type (Typ));\n+            end if;\n+\n+            if Arg = Left_Opnd (N) then\n+               Set_Is_Component_Left_Opnd (N);\n+            else\n+               Set_Is_Component_Right_Opnd (N);\n+            end if;\n          end if;\n \n-         Check_Unset_Reference (Arg);\n-      end Resolve_Concatenation_Arg;\n+      else\n+         Resolve (Arg, Btyp);\n+      end if;\n \n-   --  Start of processing for Resolve_Op_Concat\n+      Check_Unset_Reference (Arg);\n+   end Resolve_Op_Concat_Arg;\n+\n+   -----------------------------\n+   -- Resolve_Op_Concat_First --\n+   -----------------------------\n+\n+   procedure Resolve_Op_Concat_First (N : Node_Id; Typ : Entity_Id) is\n+      Btyp : constant Entity_Id := Base_Type (Typ);\n+      Op1  : constant Node_Id := Left_Opnd (N);\n+      Op2  : constant Node_Id := Right_Opnd (N);\n \n    begin\n       --  The parser folds an enormous sequence of concatenations of string\n@@ -6488,30 +6556,18 @@ package body Sem_Res is\n          Error_Msg_N (\"concatenation not available for limited array\", N);\n          Explain_Limited_Type (Btyp, N);\n       end if;\n+   end Resolve_Op_Concat_First;\n \n-      --  If the operands are themselves concatenations, resolve them as such\n-      --  directly. This removes several layers of recursion and allows GNAT to\n-      --  handle larger multiple concatenations.\n+   ----------------------------\n+   -- Resolve_Op_Concat_Rest --\n+   ----------------------------\n \n-      if Nkind (Op1) = N_Op_Concat\n-        and then not Is_Array_Type (Component_Type (Typ))\n-        and then Entity (Op1) = Entity (N)\n-      then\n-         Resolve_Op_Concat (Op1, Typ);\n-      else\n-         Resolve_Concatenation_Arg\n-           (Op1,  Is_Component_Left_Opnd  (N));\n-      end if;\n+   procedure Resolve_Op_Concat_Rest (N : Node_Id; Typ : Entity_Id) is\n+      Op1  : constant Node_Id := Left_Opnd (N);\n+      Op2  : constant Node_Id := Right_Opnd (N);\n \n-      if Nkind (Op2) = N_Op_Concat\n-        and then not Is_Array_Type (Component_Type (Typ))\n-        and then Entity (Op2) = Entity (N)\n-      then\n-         Resolve_Op_Concat (Op2, Typ);\n-      else\n-         Resolve_Concatenation_Arg\n-           (Op2, Is_Component_Right_Opnd  (N));\n-      end if;\n+   begin\n+      Resolve_Op_Concat_Arg (N, Op2, Typ, Is_Component_Right_Opnd  (N));\n \n       Generate_Operator_Reference (N, Typ);\n \n@@ -6520,7 +6576,7 @@ package body Sem_Res is\n       end if;\n \n       --  If this is not a static concatenation, but the result is a\n-      --  string type (and not an array of strings) insure that static\n+      --  string type (and not an array of strings) ensure that static\n       --  string operands have their subtypes properly constructed.\n \n       if Nkind (N) /= N_String_Literal\n@@ -6529,7 +6585,7 @@ package body Sem_Res is\n          Set_String_Literal_Subtype (Op1, Typ);\n          Set_String_Literal_Subtype (Op2, Typ);\n       end if;\n-   end Resolve_Op_Concat;\n+   end Resolve_Op_Concat_Rest;\n \n    ----------------------\n    -- Resolve_Op_Expon --"}]}