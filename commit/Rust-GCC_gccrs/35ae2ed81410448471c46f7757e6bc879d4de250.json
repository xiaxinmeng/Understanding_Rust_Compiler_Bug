{"sha": "35ae2ed81410448471c46f7757e6bc879d4de250", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVhZTJlZDgxNDEwNDQ4NDcxYzQ2Zjc3NTdlNmJjODc5ZDRkZTI1MA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-07-20T10:26:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-07-20T10:26:51Z"}, "message": "[multiple changes]\n\n2004-07-20  Olivier Hainque  <hainque@act-europe.fr>\n\n\t* a-elchha.adb (Last_Chance_Handler): Remove the bogus buffer dynamic\n\tallocation and potentially overflowing update with\n\tTailored_Exception_Information. Use the sec-stack free procedural\n\tinterface to output Exception_Information instead.\n\n\t* a-except.adb (To_Stderr): New subprogram for character, and string\n\tversion moved from a-exextr to be visible from other separate units.\n\t(Tailored_Exception_Information): Remove the procedural version,\n\tpreviously used by the default Last_Chance_Handler and not any more.\n\tAdjust various comments.\n\n\t* a-exexda.adb: Generalize the exception information procedural\n\tinterface, to minimize the use of secondary stack and the need for\n\tlocal buffers when the info is to be output to stderr:\n\t(Address_Image): Removed.\n\t(Append_Info_Character): New subprogram, checking for overflows and\n\toutputing to stderr if buffer to fill is of length 0.\n\t(Append_Info_String): Output to stderr if buffer to fill is of length 0.\n\t(Append_Info_Address, Append_Info_Exception_Name,\n\tAppend_Info_Exception_Message, Append_Info_Basic_Exception_Information,\n\tAppend_Info_Basic_Exception_Traceback,\n\tAppend_Info_Exception_Information): New subprograms.\n\t(Append_Info_Nat, Append_Info_NL): Use Append_Info_Character.\n\t(Basic_Exception_Info_Maxlength, Basic_Exception_Tback_Maxlength,\n\tException_Info_Maxlength, Exception_Name_Length,\n\tException_Message_Length): New subprograms.\n\t(Exception_Information): Use Append_Info_Exception_Information.\n\t(Tailored_Exception_Information): Use\n\tAppend_Info_Basic_Exception_Information.\n\tExport services for the default Last_Chance_Handler.\n\n\t* a-exextr.adb (To_Stderr): Remove. Now in a-except to be usable by\n\tother separate units.\n\n2004-07-20  Vincent Celier  <celier@gnat.com>\n\n\t* clean.adb, mlib-utl.adb, osint.adb, makegpr.adb: Minor reformatting.\n\n2004-07-20  Ed Schonberg  <schonberg@gnat.com>\n\n\t* freeze.adb (Freeze_Entity): If entity is a discriminated record type,\n\temit itype references for the designated types of component types that\n\tare declared outside of the full record declaration, and that may\n\tdenote a partial view of that record type.\n\n2004-07-20  Ed Schonberg  <schonberg@gnat.com>\n\n\tPR ada/15607\n\t* sem_ch3.adb (Build_Discriminated_Subtype): Do not attach a subtype\n\twhich is the designated type in an access component declaration, to the\n\tlist of incomplete dependents of the parent type, to avoid elaboration\n\tissues with out-of-scope subtypes.\n\t(Complete_Private_Subtype): Recompute Has_Unknown_Discriminants from the\n\tfull view of the parent.\n\n2004-07-20  Ed Schonberg  <schonberg@gnat.com>\n\n\tPR ada/15610\n\t* sem_ch8.adb (Find_Expanded_Name): If name is overloaded, reject\n\tentities that are hidden, such as references to generic actuals\n\toutside an instance.\n\n2004-07-20  Javier Miranda  <miranda@gnat.com>\n\n\t* sem_ch4.adb (Try_Object_Operation): New subprogram that gives\n\tsupport to the new notation.\n\t(Analyze_Selected_Component): Add call to Try_Object_Operation.\n\n2004-07-20  Jose Ruiz  <ruiz@act-europe.fr>\n\n\t* s-taprob.adb: Adding the elaboration code required for initializing\n\tthe tasking soft links that are common to the full and the restricted\n\trun times.\n\n\t* s-tarest.adb (Init_RTS): Tasking soft links that are shared with the\n\trestricted run time has been moved to the package\n\tSystem.Soft_Links.Tasking.\n\n\t* s-tasini.adb (Init_RTS): Tasking soft links that are shared with the\n\trestricted run time has been moved to the package\n\tSystem.Soft_Links.Tasking.\n\n\t* Makefile.rtl: Add entry for s-solita.o in run-time library list.\n\n\t* s-solita.ads, s-solita.adb: New files.\n\n2004-07-20  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* trans.c (Identifier_to_gnu, Pragma_to_gnu, Attribute_to_gnu,\n\tCase_Statement_to_gnu): Split off from gnat_to_gnu.\n\t(Loop_Statement_to_gnu, Subprogram_Body_to_gnu, call_to_gnu,\n\tHandled_Sequence_Of_Statements_to_gnu, Exception_Handler_to_gnu_sjlj,\n\tException_Handler_to_gnu_zcx): Likewise.\n\nFrom-SVN: r84948", "tree": {"sha": "238119d8dcbfc65df92cc128baf647ad882d0617", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/238119d8dcbfc65df92cc128baf647ad882d0617"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35ae2ed81410448471c46f7757e6bc879d4de250", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35ae2ed81410448471c46f7757e6bc879d4de250", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35ae2ed81410448471c46f7757e6bc879d4de250", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35ae2ed81410448471c46f7757e6bc879d4de250/comments", "author": null, "committer": null, "parents": [{"sha": "a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977"}], "stats": {"total": 5952, "additions": 3319, "deletions": 2633}, "files": [{"sha": "28445a82c8f98a5014d1a23d77d9ca4e1b2512ec", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -1,3 +1,99 @@\n+2004-07-20  Olivier Hainque  <hainque@act-europe.fr>\n+\n+\t* a-elchha.adb (Last_Chance_Handler): Remove the bogus buffer dynamic\n+\tallocation and potentially overflowing update with\n+\tTailored_Exception_Information. Use the sec-stack free procedural\n+\tinterface to output Exception_Information instead.\n+\n+\t* a-except.adb (To_Stderr): New subprogram for character, and string\n+\tversion moved from a-exextr to be visible from other separate units.\n+\t(Tailored_Exception_Information): Remove the procedural version,\n+\tpreviously used by the default Last_Chance_Handler and not any more.\n+\tAdjust various comments.\n+\n+\t* a-exexda.adb: Generalize the exception information procedural\n+\tinterface, to minimize the use of secondary stack and the need for\n+\tlocal buffers when the info is to be output to stderr:\n+\t(Address_Image): Removed.\n+\t(Append_Info_Character): New subprogram, checking for overflows and\n+\toutputing to stderr if buffer to fill is of length 0.\n+\t(Append_Info_String): Output to stderr if buffer to fill is of length 0.\n+\t(Append_Info_Address, Append_Info_Exception_Name,\n+\tAppend_Info_Exception_Message, Append_Info_Basic_Exception_Information,\n+\tAppend_Info_Basic_Exception_Traceback,\n+\tAppend_Info_Exception_Information): New subprograms.\n+\t(Append_Info_Nat, Append_Info_NL): Use Append_Info_Character.\n+\t(Basic_Exception_Info_Maxlength, Basic_Exception_Tback_Maxlength,\n+\tException_Info_Maxlength, Exception_Name_Length,\n+\tException_Message_Length): New subprograms.\n+\t(Exception_Information): Use Append_Info_Exception_Information.\n+\t(Tailored_Exception_Information): Use\n+\tAppend_Info_Basic_Exception_Information.\n+\tExport services for the default Last_Chance_Handler.\n+\n+\t* a-exextr.adb (To_Stderr): Remove. Now in a-except to be usable by\n+\tother separate units.\n+\n+2004-07-20  Vincent Celier  <celier@gnat.com>\n+\n+\t* clean.adb, mlib-utl.adb, osint.adb, makegpr.adb: Minor reformatting.\n+\n+2004-07-20  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* freeze.adb (Freeze_Entity): If entity is a discriminated record type,\n+\temit itype references for the designated types of component types that\n+\tare declared outside of the full record declaration, and that may\n+\tdenote a partial view of that record type.\n+\n+2004-07-20  Ed Schonberg  <schonberg@gnat.com>\n+\n+\tPR ada/15607\n+\t* sem_ch3.adb (Build_Discriminated_Subtype): Do not attach a subtype\n+\twhich is the designated type in an access component declaration, to the\n+\tlist of incomplete dependents of the parent type, to avoid elaboration\n+\tissues with out-of-scope subtypes.\n+\t(Complete_Private_Subtype): Recompute Has_Unknown_Discriminants from the\n+\tfull view of the parent.\n+\n+2004-07-20  Ed Schonberg  <schonberg@gnat.com>\n+\n+\tPR ada/15610\n+\t* sem_ch8.adb (Find_Expanded_Name): If name is overloaded, reject\n+\tentities that are hidden, such as references to generic actuals\n+\toutside an instance.\n+\n+2004-07-20  Javier Miranda  <miranda@gnat.com>\n+\n+\t* sem_ch4.adb (Try_Object_Operation): New subprogram that gives\n+\tsupport to the new notation.\n+\t(Analyze_Selected_Component): Add call to Try_Object_Operation.\n+\n+2004-07-20  Jose Ruiz  <ruiz@act-europe.fr>\n+\n+\t* s-taprob.adb: Adding the elaboration code required for initializing\n+\tthe tasking soft links that are common to the full and the restricted\n+\trun times.\n+\n+\t* s-tarest.adb (Init_RTS): Tasking soft links that are shared with the\n+\trestricted run time has been moved to the package\n+\tSystem.Soft_Links.Tasking.\n+\n+\t* s-tasini.adb (Init_RTS): Tasking soft links that are shared with the\n+\trestricted run time has been moved to the package\n+\tSystem.Soft_Links.Tasking.\n+\n+\t* Makefile.rtl: Add entry for s-solita.o in run-time library list.\n+\n+\t* s-solita.ads, s-solita.adb: New files.\n+\n+2004-07-20  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* trans.c (Identifier_to_gnu, Pragma_to_gnu, Attribute_to_gnu,\n+\tCase_Statement_to_gnu): Split off from gnat_to_gnu.\n+\t(Loop_Statement_to_gnu, Subprogram_Body_to_gnu, call_to_gnu,\n+\tHandled_Sequence_Of_Statements_to_gnu, Exception_Handler_to_gnu_sjlj,\n+\tException_Handler_to_gnu_zcx): Likewise.\n+\n 2004-07-17  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* gigi.h (builtin_function): Declare."}, {"sha": "10031f8e07d498b7bb494a8803f5ae23b1d88ded", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -46,6 +46,7 @@ GNATRTL_TASKING_OBJS= \\\n   s-intman$(objext) \\\n   s-osinte$(objext) \\\n   s-proinf$(objext) \\\n+  s-solita$(objext) \\\n   s-taenca$(objext) \\\n   s-taprob$(objext) \\\n   s-taprop$(objext) \\"}, {"sha": "e7eb65c3ea544699b4415bcf7518500d86adf79a", "filename": "gcc/ada/a-elchha.adb", "status": "modified", "additions": 29, "deletions": 71, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fa-elchha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fa-elchha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-elchha.adb?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2003 Free Software Foundation, Inc.            --\n+--           Copyright (C) 2003-2004 Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -45,83 +45,43 @@ is\n    pragma Import (C, Unhandled_Terminate, \"__gnat_unhandled_terminate\");\n    --  Perform system dependent shutdown code\n \n-   function Tailored_Exception_Information\n-     (X : Exception_Occurrence) return String;\n-   --  Exception information to be output in the case of automatic tracing\n-   --  requested through GNAT.Exception_Traces.\n-   --\n-   --  This is the same as Exception_Information if no backtrace decorator\n-   --  is currently in place. Otherwise, this is Exception_Information with\n-   --  the call chain raw addresses replaced by the result of a call to the\n-   --  current decorator provided with the call chain addresses.\n+   function Exception_Message_Length\n+     (X : Exception_Occurrence) return Natural;\n+   pragma Import (Ada, Exception_Message_Length, \"__gnat_exception_msg_len\");\n \n+   procedure Append_Info_Exception_Message\n+     (X : Exception_Occurrence; Info : in out String; Ptr : in out Natural);\n    pragma Import\n-     (Ada, Tailored_Exception_Information,\n-        \"__gnat_tailored_exception_information\");\n+     (Ada, Append_Info_Exception_Message, \"__gnat_append_info_e_msg\");\n \n-   procedure Tailored_Exception_Information\n-     (X    : Exception_Occurrence;\n-      Buff : in out String;\n-      Last : in out Integer);\n-   --  Procedural version of the above function. Instead of returning the\n-   --  result, this one is put in Buff (Buff'first .. Buff'first + Last)\n+   procedure Append_Info_Exception_Information\n+     (X : Exception_Occurrence; Info : in out String; Ptr : in out Natural);\n+   pragma Import\n+     (Ada, Append_Info_Exception_Information, \"__gnat_append_info_e_info\");\n \n    procedure To_Stderr (S : String);\n    pragma Import (Ada, To_Stderr, \"__gnat_to_stderr\");\n    --  Little routine to output string to stderr\n \n+   Ptr   : Natural := 0;\n+   Nobuf : String (1 .. 0);\n+\n    Nline : constant String := String'(1 => ASCII.LF);\n    --  Convenient shortcut\n \n-   Msg : constant String := Except.Msg (1 .. Except.Msg_Length);\n-\n-   Max_Static_Exc_Info : constant := 1024;\n-   --  This should be enough for most exception information cases\n-   --  even though tailoring introduces some uncertainty.  The\n-   --  name+message should not exceed 320 chars, so that leaves at\n-   --  least 35 backtrace slots (each slot needs 19 chars for\n-   --  representing a 64 bit address).\n-\n-   subtype Exc_Info_Type is String (1 .. Max_Static_Exc_Info);\n-   type Str_Ptr is access Exc_Info_Type;\n-   Exc_Info : Str_Ptr;\n-   Exc_Info_Last : Natural := 0;\n-   --  Buffer that is allocated to store the tailored exception\n-   --  information while Adafinal is run. This buffer is allocated\n-   --  on the heap only when it is needed. It is better to allocate\n-   --  on the heap than on the stack since stack overflows are more\n-   --  common than heap overflows.\n-\n-   procedure Tailored_Exception_Information\n-     (X    : Exception_Occurrence;\n-      Buff : in out String;\n-      Last : in out Integer)\n-   is\n-      Info : constant String := Tailored_Exception_Information (X);\n-   begin\n-      Last := Info'Last;\n-      Buff (1 .. Last) := Info;\n-   end Tailored_Exception_Information;\n-\n begin\n-   --  First allocate & store the exception info in a buffer when\n-   --  we know it will be needed. This needs to be done before\n-   --  Adafinal because it implicitly uses the secondary stack.\n-\n-   if Except.Id.Full_Name.all (1) /= '_'\n-     and then Except.Num_Tracebacks /= 0\n-   then\n-      Exc_Info := new Exc_Info_Type;\n-      if Exc_Info /= null then\n-         Tailored_Exception_Information\n-           (Except, Exc_Info.all, Exc_Info_Last);\n-      end if;\n-   end if;\n+   --  Let's shutdown the runtime now. The rest of the procedure needs to be\n+   --  careful not to use anything that would require runtime support. In\n+   --  particular, functions returning strings are banned since the sec stack\n+   --  is no longer functional. This is particularly important to note for the\n+   --  Exception_Information output. We used to allow the tailored version to\n+   --  show up here, which turned out to be a bad idea as it might involve a\n+   --  traceback decorator the length of which we don't control. Potentially\n+   --  heavy primary/secondary stack use or dynamic allocations right before\n+   --  this point are not welcome, moving the output before the finalization\n+   --  raises order of outputs concerns, and decorators are intended to only\n+   --  be used with exception traces, which should have been issued already.\n \n-   --  Let's shutdown the runtime now. The rest of the procedure\n-   --  needs to be careful not to use anything that would require\n-   --  runtime support. In particular, functions returning strings\n-   --  are banned since the sec stack is no longer functional.\n    System.Standard_Library.Adafinal;\n \n    --  Check for special case of raising _ABORT_SIGNAL, which is not\n@@ -142,23 +102,21 @@ begin\n       To_Stderr (\"raised \");\n       To_Stderr (Except.Id.Full_Name.all (1 .. Except.Id.Name_Length - 1));\n \n-      if Msg'Length /= 0 then\n+      if Exception_Message_Length (Except) /= 0 then\n          To_Stderr (\" : \");\n-         To_Stderr (Msg);\n+         Append_Info_Exception_Message (Except, Nobuf, Ptr);\n       end if;\n \n       To_Stderr (Nline);\n \n    --  Traceback exists\n \n    else\n-      --  Note we can have this whole information output twice if\n-      --  this occurrence gets reraised up to here.\n-\n       To_Stderr (Nline);\n       To_Stderr (\"Execution terminated by unhandled exception\");\n       To_Stderr (Nline);\n-      To_Stderr (Exc_Info (1 .. Exc_Info_Last));\n+\n+      Append_Info_Exception_Information (Except, Nobuf, Ptr);\n    end if;\n \n    Unhandled_Terminate;"}, {"sha": "2da9de23fb1da55346670fbed6e6631af3ab6e74", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 65, "deletions": 45, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -120,6 +120,17 @@ package body Ada.Exceptions is\n    --  Raise_From_Signal_Handler. The origin of the call is indicated by the\n    --  From_Signal_Handler argument.\n \n+   procedure To_Stderr (S : String);\n+   pragma Export (Ada, To_Stderr, \"__gnat_to_stderr\");\n+   --  Little routine to output string to stderr that is also used\n+   --  in the tasking run time.\n+\n+   procedure To_Stderr (C : Character);\n+   pragma Inline (To_Stderr);\n+   pragma Export (Ada, To_Stderr, \"__gnat_to_stderr_char\");\n+   --  Little routine to output a character to stderr, used by some of\n+   --  the separate units below.\n+\n    package Exception_Data is\n \n       ---------------------------------\n@@ -154,34 +165,40 @@ package body Ada.Exceptions is\n       function Exception_Information (X : Exception_Occurrence) return String;\n       --  The format of the exception information is as follows:\n       --\n-      --    exception name (as in Exception_Name)\n-      --    message (or a null line if no message)\n-      --    PID=nnnn\n-      --    0xyyyyyyyy 0xyyyyyyyy ...\n+      --    Exception_Name: <exception name> (as in Exception_Name)\n+      --    Message: <message> (only if Exception_Message is empty)\n+      --    PID=nnnn (only if != 0)\n+      --    Call stack traceback locations:  (only if at least one location)\n+      --    <0xyyyyyyyy 0xyyyyyyyy ...>      (is recorded)\n       --\n-      --  The lines are separated by a ASCII.LF character\n+      --  The lines are separated by a ASCII.LF character.\n       --  The nnnn is the partition Id given as decimal digits.\n-      --  The 0x... line represents traceback program counter locations,\n-      --  in order with the first one being the exception location.\n+      --  The 0x... line represents traceback program counter locations, in\n+      --  execution order with the first one being the exception location. It\n+      --  is present only\n+      --\n+      --  The Exception_Name and Message lines are omitted in the abort\n+      --  signal case, since this is not really an exception.\n+\n+      --  !! If the format of the generated string is changed, please note\n+      --  !! that an equivalent modification to the routine String_To_EO must\n+      --  !! be made to preserve proper functioning of the stream attributes.\n \n       ---------------------------------------\n       -- Exception backtracing subprograms --\n       ---------------------------------------\n \n-      --  What is automatically output when exception tracing is on basically\n-      --  corresponds to the usual exception information, but with the call\n-      --  chain backtrace possibly tailored by a backtrace decorator. Modifying\n-      --  Exception_Information itself is not a good idea because the decorated\n-      --  output is completely out of control and would break all our code\n-      --  related to the streaming of exceptions.\n-      --\n-      --  We then provide an alternative function to Exception_Information to\n-      --  compute the possibly tailored output, which is equivalent if no\n-      --  decorator is currently set.\n+      --  What is automatically output when exception tracing is on is the\n+      --  usual exception information with the call chain backtrace possibly\n+      --  tailored by a backtrace decorator. Modifying Exception_Information\n+      --  itself is not a good idea because the decorated output is completely\n+      --  out of control and would break all our code related to the streaming\n+      --  of exceptions.  We then provide an alternative function to compute\n+      --  the possibly tailored output, which is equivalent if no decorator is\n+      --  currently set:\n \n       function Tailored_Exception_Information\n-        (X    : Exception_Occurrence)\n-        return String;\n+        (X : Exception_Occurrence) return String;\n       --  Exception information to be output in the case of automatic tracing\n       --  requested through GNAT.Exception_Traces.\n       --\n@@ -193,28 +210,7 @@ package body Ada.Exceptions is\n       pragma Export\n         (Ada, Tailored_Exception_Information,\n            \"__gnat_tailored_exception_information\");\n-      --  This function is used within this package but also from within\n-      --  System.Tasking.Stages.\n-      --\n-      --  The output of Exception_Information and\n-      --  Tailored_Exception_Information share a common part which was\n-      --  formerly built using local procedures within\n-      --  Exception_Information. These procedures have been extracted\n-      --  from their original place to be available to\n-      --  Tailored_Exception_Information also.\n-      --\n-      --  Each of these procedures appends some input to an\n-      --  information string currently being built. The Ptr argument\n-      --  represents the last position in this string at which a\n-      --  character has been written.\n-\n-      procedure Tailored_Exception_Information\n-        (X    : Exception_Occurrence;\n-         Buff : in out String;\n-         Last : in out Integer);\n-      --  Procedural version of the above function. Instead of returning the\n-      --  result, this one is put in Buff (Buff'first .. Buff'first + Last)\n-      --  And what happens on overflow ???\n+      --  This is currently used by System.Tasking.Stages.\n \n    end Exception_Data;\n \n@@ -234,14 +230,14 @@ package body Ada.Exceptions is\n       --  routine when the GCC 3 mechanism is used.\n \n       procedure Notify_Handled_Exception;\n-      pragma Export (C, Notify_Handled_Exception,\n-                       \"__gnat_notify_handled_exception\");\n+      pragma Export\n+        (C, Notify_Handled_Exception, \"__gnat_notify_handled_exception\");\n       --  This routine is called for a handled occurrence is about to be\n       --  propagated.\n \n       procedure Notify_Unhandled_Exception;\n-      pragma Export (C, Notify_Unhandled_Exception,\n-                       \"__gnat_notify_unhandled_exception\");\n+      pragma Export\n+        (C, Notify_Unhandled_Exception, \"__gnat_notify_unhandled_exception\");\n       --  This routine is called when an unhandled occurrence is about to be\n       --  propagated.\n \n@@ -1309,6 +1305,30 @@ package body Ada.Exceptions is\n       Raise_Current_Excep (E);\n    end Raise_Exception_No_Defer;\n \n+   ---------------\n+   -- To_Stderr --\n+   ---------------\n+\n+   procedure To_Stderr (C : Character) is\n+\n+      type int is new Integer;\n+\n+      procedure put_char_stderr (C : int);\n+      pragma Import (C, put_char_stderr, \"put_char_stderr\");\n+\n+   begin\n+      put_char_stderr (Character'Pos (C));\n+   end To_Stderr;\n+\n+   procedure To_Stderr (S : String) is\n+   begin\n+      for J in S'Range loop\n+         if S (J) /= ASCII.CR then\n+            To_Stderr (S (J));\n+         end if;\n+      end loop;\n+   end To_Stderr;\n+\n    ---------\n    -- ZZZ --\n    ---------"}, {"sha": "63085f65a11796ad56417ec6ae872b88f9b2b8b5", "filename": "gcc/ada/a-exexda.adb", "status": "modified", "additions": 384, "deletions": 193, "changes": 577, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fa-exexda.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fa-exexda.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexda.adb?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,39 +36,153 @@ with System.Storage_Elements; use System.Storage_Elements;\n separate (Ada.Exceptions)\n package body Exception_Data is\n \n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n+   --  This unit implements the Exception_Information related services for\n+   --  both the Ada standard requirements and the GNAT.Exception_Traces\n+   --  facility.\n+\n+   --  There are common parts between the contents of Exception_Information\n+   --  (the regular Ada interface) and Tailored_Exception_Information (what\n+   --  the automatic backtracing output includes). The overall structure is\n+   --  sketched below:\n \n-   function Address_Image (A : System.Address) return String;\n-   --  Returns at string of the form 0xhhhhhhhhh for an address, with\n-   --  leading zeros suppressed. Hex characters a-f are in lower case.\n+   --\n+   --                      Exception_Information\n+   --                               |\n+   --                       +-------+--------+\n+   --                       |                |\n+   --                Basic_Exc_Info & Basic_Exc_Tback\n+   --                    (B_E_I)          (B_E_TB)\n+\n+   --           o--\n+   --  (B_E_I)  |  Exception_Name: <exception name> (as in Exception_Name)\n+   --           |  Message: <message> (or a null line if no message)\n+   --           |  PID=nnnn (if != 0)\n+   --           o--\n+   --  (B_E_TB) |  Call stack traceback locations:\n+   --           |  <0xyyyyyyyy 0xyyyyyyyy ...>\n+   --           o--\n+\n+   --                  Tailored_Exception_Information\n+   --                               |\n+   --                    +----------+----------+\n+   --                    |                     |\n+   --             Basic_Exc_Info    &  Tailored_Exc_Tback\n+   --                                          |\n+   --                              +-----------+------------+\n+   --                              |                        |\n+   --                       Basic_Exc_Tback    Or    Tback_Decorator\n+   --                     if no decorator set           otherwise\n+\n+   --  Functions returning String imply secondary stack use, which is a heavy\n+   --  mechanism requiring run-time support. Besides, some of the routines we\n+   --  provide here are to be used by the default Last_Chance_Handler, at the\n+   --  critical point where the runtime is about to be finalized. Since most\n+   --  of the items we have at hand are of bounded length, we also provide a\n+   --  procedural interface able to incrementally append the necessary bits to\n+   --  a preallocated buffer or output them straight to stderr.\n+\n+   --  The procedural interface is composed of two major sections: a neutral\n+   --  section for basic types like Address, Character, Natural or String, and\n+   --  an exception oriented section for the e.g. Basic_Exception_Information.\n+   --  This is the Append_Info family of procedures below.\n+\n+   --  Output to stderr is commanded by passing an empty buffer to update, and\n+   --  care is taken not to overflow otherwise.\n+\n+   --------------------------------------------\n+   -- Procedural Interface - Neutral section --\n+   --------------------------------------------\n+\n+   procedure Append_Info_Address\n+     (A    : Address;\n+      Info : in out String;\n+      Ptr  : in out Natural);\n+\n+   procedure Append_Info_Character\n+     (C    : Character;\n+      Info : in out String;\n+      Ptr  : in out Natural);\n \n    procedure Append_Info_Nat\n      (N    : Natural;\n       Info : in out String;\n       Ptr  : in out Natural);\n-   --  Append the image of N at the end of the provided information string\n \n    procedure Append_Info_NL\n      (Info : in out String;\n       Ptr  : in out Natural);\n-   --  Append a LF at the end of the provided information string\n+   pragma Inline (Append_Info_NL);\n \n    procedure Append_Info_String\n      (S    : String;\n       Info : in out String;\n       Ptr  : in out Natural);\n-   --  Append a string at the end of the provided information string\n \n-   --  To build Exception_Information and Tailored_Exception_Information,\n-   --  we then use three intermediate functions :\n+   -------------------------------------------------------\n+   -- Procedural Interface - Exception oriented section --\n+   -------------------------------------------------------\n \n-   function Basic_Exception_Information\n-     (X : Exception_Occurrence) return String;\n-   --  Returns the basic exception information string associated with a\n-   --  given exception occurrence. This is the common part shared by both\n-   --  Exception_Information and Tailored_Exception_Infomation.\n+   procedure Append_Info_Exception_Name\n+     (Id   : Exception_Id;\n+      Info : in out String;\n+      Ptr  : in out Natural);\n+\n+   procedure Append_Info_Exception_Name\n+     (X    : Exception_Occurrence;\n+      Info : in out String;\n+      Ptr  : in out Natural);\n+\n+   procedure Append_Info_Exception_Message\n+     (X    : Exception_Occurrence;\n+      Info : in out String;\n+      Ptr  : in out Natural);\n+\n+   procedure Append_Info_Basic_Exception_Information\n+     (X    : Exception_Occurrence;\n+      Info : in out String;\n+      Ptr  : in out Natural);\n+\n+   procedure Append_Info_Basic_Exception_Traceback\n+     (X    : Exception_Occurrence;\n+      Info : in out String;\n+      Ptr  : in out Natural);\n+\n+   procedure Append_Info_Exception_Information\n+     (X    : Exception_Occurrence;\n+      Info : in out String;\n+      Ptr  : in out Natural);\n+\n+\n+   --  The \"functional\" interface to the exception information not involving\n+   --  a traceback decorator uses preallocated intermediate buffers to avoid\n+   --  the use of secondary stack. Preallocation requires preliminary length\n+   --  computation, for which a series of functions are introduced:\n+\n+   ---------------------------------\n+   -- Length evaluation utilities --\n+   ---------------------------------\n+\n+   function Basic_Exception_Info_Maxlength\n+     (X : Exception_Occurrence) return Natural;\n+\n+   function Basic_Exception_Tback_Maxlength\n+     (X : Exception_Occurrence) return Natural;\n+\n+   function Exception_Info_Maxlength\n+     (X : Exception_Occurrence) return Natural;\n+\n+   function Exception_Name_Length\n+     (Id : Exception_Id) return Natural;\n+\n+   function Exception_Name_Length\n+     (X : Exception_Occurrence) return Natural;\n+\n+   function Exception_Message_Length\n+     (X : Exception_Occurrence) return Natural;\n+\n+   --------------------------\n+   -- Functional Interface --\n+   --------------------------\n \n    function Basic_Exception_Traceback\n      (X : Exception_Occurrence) return String;\n@@ -82,32 +196,28 @@ package body Exception_Data is\n    --  exception occurrence, either in its basic form if no decorator is\n    --  in place, or as formatted by the decorator otherwise.\n \n-   --  The overall organization of the exception information related code\n-   --  is summarized below :\n-   --\n-   --           Exception_Information\n-   --                    |\n-   --            +-------+--------+\n-   --            |                |\n-   --     Basic_Exc_Info & Basic_Exc_Tback\n-   --\n-   --\n-   --       Tailored_Exception_Information\n-   --                    |\n-   --         +----------+----------+\n-   --         |                     |\n-   --  Basic_Exc_Info    &  Tailored_Exc_Tback\n-   --                               |\n-   --                   +-----------+------------+\n-   --                   |                        |\n-   --            Basic_Exc_Tback    Or    Tback_Decorator\n-   --          if no decorator set           otherwise\n+   -----------------------------------------------------------------------\n+   -- Services for the default Last_Chance_Handler and the task wrapper --\n+   -----------------------------------------------------------------------\n \n-   -------------------\n-   -- Address_Image --\n-   -------------------\n+   pragma Export\n+     (Ada, Append_Info_Exception_Message, \"__gnat_append_info_e_msg\");\n \n-   function Address_Image (A : Address) return String is\n+   pragma Export\n+     (Ada, Append_Info_Exception_Information, \"__gnat_append_info_e_info\");\n+\n+   pragma Export\n+     (Ada, Exception_Message_Length, \"__gnat_exception_msg_len\");\n+\n+   -------------------------\n+   -- Append_Info_Address --\n+   -------------------------\n+\n+   procedure Append_Info_Address\n+     (A    : Address;\n+      Info : in out String;\n+      Ptr  : in out Natural)\n+   is\n       S : String (1 .. 18);\n       P : Natural;\n       N : Integer_Address;\n@@ -126,8 +236,27 @@ package body Exception_Data is\n \n       S (P - 1) := '0';\n       S (P) := 'x';\n-      return S (P - 1 .. S'Last);\n-   end Address_Image;\n+\n+      Append_Info_String (S (P - 1 .. S'Last), Info, Ptr);\n+   end Append_Info_Address;\n+\n+   ---------------------------\n+   -- Append_Info_Character --\n+   ---------------------------\n+\n+   procedure Append_Info_Character\n+     (C    : Character;\n+      Info : in out String;\n+      Ptr  : in out Natural)\n+   is\n+   begin\n+      if Info'Length = 0 then\n+         To_Stderr (C);\n+      elsif Ptr < Info'Last then\n+         Ptr := Ptr + 1;\n+         Info (Ptr) := C;\n+      end if;\n+   end Append_Info_Character;\n \n    ---------------------\n    -- Append_Info_Nat --\n@@ -143,8 +272,8 @@ package body Exception_Data is\n          Append_Info_Nat (N / 10, Info, Ptr);\n       end if;\n \n-      Ptr := Ptr + 1;\n-      Info (Ptr) := Character'Val (Character'Pos ('0') + N mod 10);\n+      Append_Info_Character\n+        (Character'Val (Character'Pos ('0') + N mod 10), Info, Ptr);\n    end Append_Info_Nat;\n \n    --------------------\n@@ -156,8 +285,7 @@ package body Exception_Data is\n       Ptr  : in out Natural)\n    is\n    begin\n-      Ptr := Ptr + 1;\n-      Info (Ptr) := ASCII.LF;\n+      Append_Info_Character (ASCII.LF, Info, Ptr);\n    end Append_Info_NL;\n \n    ------------------------\n@@ -169,181 +297,259 @@ package body Exception_Data is\n       Info : in out String;\n       Ptr  : in out Natural)\n    is\n-      Last : constant Natural := Integer'Min (Ptr + S'Length, Info'Last);\n-\n    begin\n-      Info (Ptr + 1 .. Last) := S;\n-      Ptr := Last;\n+      if Info'Length = 0 then\n+         To_Stderr (S);\n+      else\n+         declare\n+            Last : constant Natural :=\n+              Integer'Min (Ptr + S'Length, Info'Last);\n+         begin\n+            Info (Ptr + 1 .. Last) := S;\n+            Ptr := Last;\n+         end;\n+      end if;\n    end Append_Info_String;\n \n-   ---------------------------------\n-   -- Basic_Exception_Information --\n-   ---------------------------------\n+   ---------------------------------------------\n+   -- Append_Info_Basic_Exception_Information --\n+   ---------------------------------------------\n \n-   function Basic_Exception_Information\n-     (X : Exception_Occurrence) return String\n+   --  To ease the maximum length computation, we define and pull out a couple\n+   --  of string constants:\n+\n+   BEI_Name_Header : constant String := \"Exception name: \";\n+   BEI_Msg_Header  : constant String := \"Message: \";\n+   BEI_PID_Header  : constant String := \"PID: \";\n+\n+   procedure Append_Info_Basic_Exception_Information\n+     (X    : Exception_Occurrence;\n+      Info : in out String;\n+      Ptr  : in out Natural)\n    is\n-      Name : constant String := Exception_Name (X);\n-      Msg  : constant String := Exception_Message (X);\n-      --  Exception name and message that are going to be included in the\n-      --  information to return, if not empty.\n-\n-      Name_Len : constant Natural := Name'Length;\n-      Msg_Len  : constant Natural := Msg'Length;\n-      --  Length of these strings, useful to compute the size of the string\n-      --  we have to allocate for the complete result as well as in the body\n-      --  of this procedure.\n-\n-      Info_Maxlen : constant Natural := 50 + Name_Len + Msg_Len;\n-      --  Maximum length of the information string we will build, with :\n-      --\n-      --  50 =    16 + 2   for the text associated with the name\n-      --        +  9 + 2   for the text associated with the message\n-      --        +  5 + 2   for the text associated with the pid\n-      --        + 14       for the text image of the pid itself and a margin.\n-      --\n-      --  This is indeed a maximum since some data may not appear at all if\n-      --  not relevant. For example, nothing related to the exception message\n-      --  will be there if this message is empty.\n-      --\n-      --  WARNING : Do not forget to update these numbers if anything\n-      --  involved in the computation changes.\n-\n-      Info : String (1 .. Info_Maxlen);\n-      --  Information string we are going to build, containing the common\n-      --  part shared by Exc_Info and Tailored_Exc_Info.\n-\n-      Ptr  : Natural := 0;\n+      Name : String (1 .. Exception_Name_Length (X));\n+      --  Bufer in which to fetch the exception name, in order to check\n+      --  whether this is an internal _ABORT_SIGNAL or a regular occurrence.\n+\n+      Name_Ptr : Natural := Name'First - 1;\n \n    begin\n       --  Output exception name and message except for _ABORT_SIGNAL, where\n-      --  these two lines are omitted (see discussion above).\n+      --  these two lines are omitted.\n \n-      if Name (1) /= '_' then\n-         Append_Info_String (\"Exception name: \", Info, Ptr);\n+      Append_Info_Exception_Name (X, Name, Name_Ptr);\n+\n+      if Name (Name'First) /= '_' then\n+         Append_Info_String (BEI_Name_Header, Info, Ptr);\n          Append_Info_String (Name, Info, Ptr);\n          Append_Info_NL (Info, Ptr);\n \n-         if Msg_Len /= 0 then\n-            Append_Info_String (\"Message: \", Info, Ptr);\n-            Append_Info_String (Msg, Info, Ptr);\n+         if Exception_Message_Length (X) /= 0 then\n+            Append_Info_String (BEI_Msg_Header, Info, Ptr);\n+            Append_Info_Exception_Message  (X, Info, Ptr);\n             Append_Info_NL (Info, Ptr);\n          end if;\n       end if;\n \n       --  Output PID line if non-zero\n \n       if X.Pid /= 0 then\n-         Append_Info_String (\"PID: \", Info, Ptr);\n+         Append_Info_String (BEI_PID_Header, Info, Ptr);\n          Append_Info_Nat (X.Pid, Info, Ptr);\n          Append_Info_NL (Info, Ptr);\n       end if;\n+   end Append_Info_Basic_Exception_Information;\n \n-      return Info (1 .. Ptr);\n-   end Basic_Exception_Information;\n+   -------------------------------------------\n+   -- Basic_Exception_Information_Maxlength --\n+   -------------------------------------------\n \n-   -------------------------------\n-   -- Basic_Exception_Traceback --\n-   -------------------------------\n+   function Basic_Exception_Info_Maxlength\n+     (X : Exception_Occurrence) return Natural is\n+   begin\n+      return\n+        BEI_Name_Header'Length + Exception_Name_Length (X) + 1\n+        + BEI_Msg_Header'Length + Exception_Message_Length (X) + 1\n+        + BEI_PID_Header'Length + 15;\n+   end Basic_Exception_Info_Maxlength;\n \n-   function Basic_Exception_Traceback\n-     (X : Exception_Occurrence) return String\n+   -------------------------------------------\n+   -- Append_Info_Basic_Exception_Traceback --\n+   -------------------------------------------\n+\n+   --  As for Basic_Exception_Information:\n+\n+   BETB_Header : constant String := \"Call stack traceback locations:\";\n+\n+   procedure Append_Info_Basic_Exception_Traceback\n+     (X    : Exception_Occurrence;\n+      Info : in out String;\n+      Ptr  : in out Natural)\n    is\n-      Info_Maxlen : constant Natural := 35 + X.Num_Tracebacks * 19;\n-      --  Maximum length of the information string we are building, with :\n-      --  33 = 31 + 4      for the text before and after the traceback, and\n-      --  19 =  2 + 16 + 1 for each address (\"0x\" + HHHH + \" \")\n-      --\n-      --  WARNING : Do not forget to update these numbers if anything\n-      --  involved in the computation changes.\n+   begin\n+      if X.Num_Tracebacks <= 0 then\n+         return;\n+      end if;\n+\n+      Append_Info_String (BETB_Header, Info, Ptr);\n+      Append_Info_NL (Info, Ptr);\n \n-      Info : String (1 .. Info_Maxlen);\n-      --  Information string we are going to build, containing an image\n-      --  of the call chain associated with the exception occurrence in its\n-      --  most basic form, that is as a sequence of binary addresses.\n+      for J in 1 .. X.Num_Tracebacks loop\n+         Append_Info_Address (TBE.PC_For (X.Tracebacks (J)), Info, Ptr);\n+         exit when J = X.Num_Tracebacks;\n+         Append_Info_Character (' ', Info, Ptr);\n+      end loop;\n \n-      Ptr  : Natural := 0;\n+      Append_Info_NL (Info, Ptr);\n+   end Append_Info_Basic_Exception_Traceback;\n \n+   -----------------------------------------\n+   -- Basic_Exception_Traceback_Maxlength --\n+   -----------------------------------------\n+\n+   function Basic_Exception_Tback_Maxlength\n+     (X : Exception_Occurrence) return Natural is\n    begin\n-      if X.Num_Tracebacks > 0 then\n-         Append_Info_String (\"Call stack traceback locations:\", Info, Ptr);\n-         Append_Info_NL (Info, Ptr);\n+      return BETB_Header'Length + 1 + X.Num_Tracebacks * 19 + 1;\n+      --  19 =  2 + 16 + 1 for each address (\"0x\" + HHHH + \" \")\n+   end Basic_Exception_Tback_Maxlength;\n \n-         for J in 1 .. X.Num_Tracebacks loop\n-            Append_Info_String\n-              (Address_Image (TBE.PC_For (X.Tracebacks (J))), Info, Ptr);\n-            exit when J = X.Num_Tracebacks;\n-            Append_Info_String (\" \", Info, Ptr);\n-         end loop;\n+   ---------------------------------------\n+   -- Append_Info_Exception_Information --\n+   ---------------------------------------\n \n-         Append_Info_NL (Info, Ptr);\n-      end if;\n+   procedure Append_Info_Exception_Information\n+     (X    : Exception_Occurrence;\n+      Info : in out String;\n+      Ptr  : in out Natural)\n+   is\n+   begin\n+      Append_Info_Basic_Exception_Information (X, Info, Ptr);\n+      Append_Info_Basic_Exception_Traceback   (X, Info, Ptr);\n+   end Append_Info_Exception_Information;\n \n-      return Info (1 .. Ptr);\n-   end Basic_Exception_Traceback;\n+   ------------------------------\n+   -- Exception_Info_Maxlength --\n+   ------------------------------\n \n-   ---------------------------\n-   -- Exception_Information --\n-   ---------------------------\n+   function Exception_Info_Maxlength\n+     (X : Exception_Occurrence) return Natural is\n+   begin\n+      return\n+        Basic_Exception_Info_Maxlength (X)\n+        + Basic_Exception_Tback_Maxlength (X);\n+   end Exception_Info_Maxlength;\n \n-   --  The format of the string is:\n+   -----------------------------------\n+   -- Append_Info_Exception_Message --\n+   -----------------------------------\n \n-   --    Exception_Name: nnnnn\n-   --    Message: mmmmm\n-   --    PID: ppp\n-   --    Call stack traceback locations:\n-   --    0xhhhh 0xhhhh 0xhhhh ... 0xhhh\n+   procedure Append_Info_Exception_Message\n+     (X    : Exception_Occurrence;\n+      Info : in out String;\n+      Ptr  : in out Natural) is\n+   begin\n+      if X.Id = Null_Id then\n+         raise Constraint_Error;\n+      end if;\n \n-   --  where\n+      declare\n+         Len : constant Natural := Exception_Message_Length (X);\n+         Msg : constant String (1 .. Len) := X.Msg (1 .. Len);\n+      begin\n+         Append_Info_String (Msg, Info, Ptr);\n+      end;\n+   end Append_Info_Exception_Message;\n \n-   --    nnnn is the fully qualified name of the exception in all upper\n-   --    case letters. This line is always present.\n+   --------------------------------\n+   -- Append_Info_Exception_Name --\n+   --------------------------------\n \n-   --    mmmm is the message (this line present only if message is non-null)\n+   procedure Append_Info_Exception_Name\n+     (Id   : Exception_Id;\n+      Info : in out String;\n+      Ptr  : in out Natural)\n+   is\n+   begin\n+      if Id = Null_Id then\n+         raise Constraint_Error;\n+      end if;\n \n-   --    ppp is the Process Id value as a decimal integer (this line is\n-   --    present only if the Process Id is non-zero). Currently we are\n-   --    not making use of this field.\n+      declare\n+         Len  : constant Natural := Exception_Name_Length (Id);\n+         Name : constant String (1 .. Len) := Id.Full_Name (1 .. Len);\n+      begin\n+         Append_Info_String (Name, Info, Ptr);\n+      end;\n+   end Append_Info_Exception_Name;\n \n-   --    The Call stack traceback locations line and the following values\n-   --    are present only if at least one traceback location was recorded.\n-   --    the values are given in C style format, with lower case letters\n-   --    for a-f, and only as many digits present as are necessary.\n+   procedure Append_Info_Exception_Name\n+     (X    : Exception_Occurrence;\n+      Info : in out String;\n+      Ptr  : in out Natural)\n+   is\n+   begin\n+      Append_Info_Exception_Name (X.Id, Info, Ptr);\n+   end Append_Info_Exception_Name;\n \n-   --  The line terminator sequence at the end of each line, including the\n-   --  last line is a CR-LF sequence (16#0D# followed by 16#0A#).\n+   ---------------------------\n+   -- Exception_Name_Length --\n+   ---------------------------\n \n-   --  The Exception_Name and Message lines are omitted in the abort\n-   --  signal case, since this is not really an exception, and the only\n-   --  use of this routine is internal for printing termination output.\n+   function Exception_Name_Length\n+     (Id : Exception_Id) return Natural is\n+   begin\n+      --  What is stored in the internal Name buffer includes a terminating\n+      --  null character that we never care about.\n \n-   --  WARNING: if the format of the generated string is changed, please note\n-   --  that an equivalent modification to the routine String_To_EO must be\n-   --  made to preserve proper functioning of the stream attributes.\n+      return Id.Name_Length - 1;\n+   end Exception_Name_Length;\n \n-   function Exception_Information (X : Exception_Occurrence) return String is\n+   function Exception_Name_Length\n+     (X : Exception_Occurrence) return Natural is\n+   begin\n+      return Exception_Name_Length (X.Id);\n+   end Exception_Name_Length;\n \n-      --  This information is now built using the circuitry introduced in\n-      --  association with the support of traceback decorators, as the\n-      --  catenation of the exception basic information and the call chain\n-      --  backtrace in its basic form.\n+   ------------------------------\n+   -- Exception_Message_Length --\n+   ------------------------------\n \n-      Basic_Info : constant String  := Basic_Exception_Information (X);\n-      Tback_Info : constant String  := Basic_Exception_Traceback (X);\n+   function Exception_Message_Length\n+     (X : Exception_Occurrence) return Natural is\n+   begin\n+      return X.Msg_Length;\n+   end Exception_Message_Length;\n \n-      Basic_Len  : constant Natural := Basic_Info'Length;\n-      Tback_Len  : constant Natural := Tback_Info'Length;\n+   -------------------------------\n+   -- Basic_Exception_Traceback --\n+   -------------------------------\n \n-      Info : String (1 .. Basic_Len + Tback_Len);\n-      Ptr  : Natural := 0;\n+   function Basic_Exception_Traceback\n+     (X : Exception_Occurrence) return String\n+   is\n+      Info : aliased String (1 .. Basic_Exception_Tback_Maxlength (X));\n+      Ptr  : Natural := Info'First - 1;\n \n    begin\n-      Append_Info_String (Basic_Info, Info, Ptr);\n-      Append_Info_String (Tback_Info, Info, Ptr);\n+      Append_Info_Basic_Exception_Traceback (X, Info, Ptr);\n+      return Info (Info'First .. Ptr);\n+   end Basic_Exception_Traceback;\n \n-      return Info;\n-   end Exception_Information;\n+   ---------------------------\n+   -- Exception_Information --\n+   ---------------------------\n+\n+   function Exception_Information\n+     (X : Exception_Occurrence) return String\n+   is\n+      Info : String (1 .. Exception_Info_Maxlength (X));\n+      Ptr  : Natural := Info'First - 1;\n \n+   begin\n+      Append_Info_Exception_Information (X, Info, Ptr);\n+      return Info (Info'First .. Ptr);\n+   end Exception_Information;\n \n    -------------------------\n    -- Set_Exception_C_Msg --\n@@ -457,11 +663,10 @@ package body Exception_Data is\n    function Tailored_Exception_Traceback\n      (X : Exception_Occurrence) return String\n    is\n-      --  We indeed reference the decorator *wrapper* from here and not the\n-      --  decorator itself. The purpose of the local variable Wrapper is to\n-      --  prevent a potential crash by race condition in the code below. The\n-      --  atomicity of this assignment is enforced by pragma Atomic in\n-      --  System.Soft_Links.\n+      --  We reference the decorator *wrapper* here and not the decorator\n+      --  itself. The purpose of the local variable Wrapper is to prevent a\n+      --  potential race condition in the code below. The atomicity of this\n+      --  assignment is enforced by pragma Atomic in System.Soft_Links.\n \n       --  The potential race condition here, if no local variable was used,\n       --  relates to the test upon the wrapper's value and the call, which\n@@ -487,33 +692,19 @@ package body Exception_Data is\n    function Tailored_Exception_Information\n      (X : Exception_Occurrence) return String\n    is\n-      --  The tailored exception information is simply the basic information\n+      --  The tailored exception information is the basic information\n       --  associated with the tailored call chain backtrace.\n \n-      Basic_Info : constant String  := Basic_Exception_Information (X);\n       Tback_Info : constant String  := Tailored_Exception_Traceback (X);\n-\n-      Basic_Len  : constant Natural := Basic_Info'Length;\n       Tback_Len  : constant Natural := Tback_Info'Length;\n \n-      Info : String (1 .. Basic_Len + Tback_Len);\n-      Ptr  : Natural := 0;\n+      Info : String (1 .. Basic_Exception_Info_Maxlength (X) + Tback_Len);\n+      Ptr  : Natural := Info'First - 1;\n \n    begin\n-      Append_Info_String (Basic_Info, Info, Ptr);\n+      Append_Info_Basic_Exception_Information (X, Info, Ptr);\n       Append_Info_String (Tback_Info, Info, Ptr);\n-\n-      return Info;\n-   end Tailored_Exception_Information;\n-\n-   procedure Tailored_Exception_Information\n-     (X    : Exception_Occurrence;\n-      Buff : in out String;\n-      Last : in out Integer)\n-   is\n-   begin\n-      Append_Info_String (Basic_Exception_Information (X), Buff, Last);\n-      Append_Info_String (Tailored_Exception_Traceback (X), Buff, Last);\n+      return Info (Info'First .. Ptr);\n    end Tailored_Exception_Information;\n \n end Exception_Data;"}, {"sha": "835c2cb526865f3d5a846814bb986d293f1204c4", "filename": "gcc/ada/a-exextr.adb", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fa-exextr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fa-exextr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exextr.adb?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -57,8 +57,7 @@ package body Exception_Traces is\n \n    procedure Last_Chance_Handler\n      (Except :  Exception_Occurrence);\n-   pragma Import\n-     (C, Last_Chance_Handler, \"__gnat_last_chance_handler\");\n+   pragma Import (C, Last_Chance_Handler, \"__gnat_last_chance_handler\");\n    pragma No_Return (Last_Chance_Handler);\n    --  Users can replace the default version of this routine,\n    --  Ada.Exceptions.Last_Chance_Handler.\n@@ -76,11 +75,6 @@ package body Exception_Traces is\n    --  latter case because Notify_Handled_Exception may be called for an\n    --  actually unhandled occurrence in the Front-End-SJLJ case.\n \n-   procedure To_Stderr (S : String);\n-   pragma Export (Ada, To_Stderr, \"__gnat_to_stderr\");\n-   --  Little routine to output string to stderr that is also used\n-   --  in the tasking run time.\n-\n    ---------------------------------\n    -- Debugger Interface Routines --\n    ---------------------------------\n@@ -185,8 +179,6 @@ package body Exception_Traces is\n    -- Unhandled_Exception_Terminate --\n    -----------------------------------\n \n-   type int is new Integer;\n-\n    procedure Unhandled_Exception_Terminate is\n       Excep : constant EOA := Save_Occurrence (Get_Current_Excep.all.all);\n       --  This occurrence will be used to display a message after finalization.\n@@ -198,22 +190,6 @@ package body Exception_Traces is\n       Last_Chance_Handler (Excep.all);\n    end Unhandled_Exception_Terminate;\n \n-   ---------------\n-   -- To_Stderr --\n-   ---------------\n-\n-   procedure To_Stderr (S : String) is\n-      procedure put_char_stderr (C : int);\n-      pragma Import (C, put_char_stderr, \"put_char_stderr\");\n-\n-   begin\n-      for J in 1 .. S'Length loop\n-         if S (J) /= ASCII.CR then\n-            put_char_stderr (Character'Pos (S (J)));\n-         end if;\n-      end loop;\n-   end To_Stderr;\n-\n \n    ------------------------------------\n    -- Handling GNAT.Exception_Traces --"}, {"sha": "3f8293780679c82b063e4fa9b33a4152286a7ad8", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -1065,7 +1065,7 @@ package body Clean is\n    begin\n       --  Do the necessary initializations\n \n-      Initialize;\n+      Clean.Initialize;\n \n       --  Parse the command line, getting the switches and the executable names\n "}, {"sha": "c017d6d9929b91cf028cb3a5f31db6902902ec69", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -3088,6 +3088,44 @@ package body Freeze is\n          else\n             Append (F_Node, Result);\n          end if;\n+\n+         --  A final pass over record types with discriminants. If the type\n+         --  has an incomplete declaration, there may be constrained access\n+         --  subtypes declared elsewhere, which do not depend on the discrimi-\n+         --  nants of the type, and which are used as component types (i.e.\n+         --  the full view is a recursive type). The designated types of these\n+         --  subtypes can only be elaborated after the type itself, and they\n+         --  need an itype reference.\n+\n+         if Ekind (E) = E_Record_Type\n+           and then Has_Discriminants (E)\n+         then\n+            declare\n+               Comp : Entity_Id;\n+               IR   : Node_Id;\n+               Typ  : Entity_Id;\n+\n+            begin\n+               Comp := First_Component (E);\n+\n+               while Present (Comp) loop\n+                  Typ  := Etype (Comp);\n+\n+                  if Ekind (Comp) = E_Component\n+                    and then Is_Access_Type (Typ)\n+                    and then Scope (Typ) /= E\n+                    and then Base_Type (Designated_Type (Typ)) = E\n+                    and then Is_Itype (Designated_Type (Typ))\n+                  then\n+                     IR := Make_Itype_Reference (Sloc (Comp));\n+                     Set_Itype (IR, Designated_Type (Typ));\n+                     Append (IR, Result);\n+                  end if;\n+\n+                  Next_Component (Comp);\n+               end loop;\n+            end;\n+         end if;\n       end if;\n \n       --  When a type is frozen, the first subtype of the type is frozen as"}, {"sha": "7f39b00469f1009234e919c386c9463d83c99be9", "filename": "gcc/ada/makegpr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fmakegpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fmakegpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakegpr.adb?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -2938,7 +2938,7 @@ package body Makegpr is\n \n    procedure Gprmake is\n    begin\n-      Initialize;\n+      Makegpr.Initialize;\n \n       if Verbose_Mode then\n          Write_Eol;"}, {"sha": "328d5a506e8b31dbce52919657f9b31c210cf2c9", "filename": "gcc/ada/mlib-utl.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fmlib-utl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fmlib-utl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-utl.adb?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -66,7 +66,7 @@ package body MLib.Utl is\n       Line_Length : Natural := 0;\n \n    begin\n-      Initialize;\n+      Utl.Initialize;\n \n       Arguments :=\n         new String_List (1 .. 1 + Ar_Options'Length + Objects'Length);\n@@ -177,7 +177,7 @@ package body MLib.Utl is\n \n       Driver  : String_Access;\n    begin\n-      Initialize;\n+      Utl.Initialize;\n \n       if Driver_Name = No_Name then\n          Driver := Gcc_Exec;"}, {"sha": "0b6a238aaba3912b221145d4ef813147c13973cf", "filename": "gcc/ada/osint.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fosint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fosint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.adb?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -2820,7 +2820,7 @@ begin\n       Lib_Search_Directories.Set_Last (Primary_Directory);\n       Lib_Search_Directories.Table (Primary_Directory) := new String'(\"\");\n \n-      Initialize;\n+      Osint.Initialize;\n    end Initialization;\n \n end Osint;"}, {"sha": "4144acc34074356d21274f5c266dc1638d9d50f5", "filename": "gcc/ada/s-solita.adb", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fs-solita.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fs-solita.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-solita.adb?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -0,0 +1,164 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--             S Y S T E M . S O F T _ L I N K S . T A S K I N G            --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the tasking versions soft links.\n+\n+pragma Style_Checks (All_Checks);\n+--  Turn off subprogram alpha ordering check, since we group soft link\n+--  bodies and dummy soft link bodies together separately in this unit.\n+\n+pragma Polling (Off);\n+--  Turn polling off for this package. We don't need polling during any\n+--  of the routines in this package, and more to the point, if we try\n+--  to poll it can cause infinite loops.\n+\n+with System.Task_Primitives.Operations;\n+--  Used for Self\n+--           Timed_Delay\n+\n+package body System.Soft_Links.Tasking is\n+\n+   package STPO renames System.Task_Primitives.Operations;\n+   package SSL  renames System.Soft_Links;\n+\n+   ----------------\n+   -- Local Data --\n+   ----------------\n+\n+   Initialized : Boolean := False;\n+   --  Boolean flag that indicates whether the tasking soft links have\n+   --  already been set.\n+\n+   ----------------------------------------------------------------------\n+   -- Tasking versions of some services needed by non-tasking programs --\n+   ----------------------------------------------------------------------\n+\n+   function  Get_Jmpbuf_Address return  Address;\n+   procedure Set_Jmpbuf_Address (Addr : Address);\n+   --  Get/Set Jmpbuf_Address for current task\n+\n+   function  Get_Sec_Stack_Addr return  Address;\n+   procedure Set_Sec_Stack_Addr (Addr : Address);\n+   --  Get/Set location of current task's secondary stack\n+\n+   function  Get_Machine_State_Addr return Address;\n+   procedure Set_Machine_State_Addr (Addr : Address);\n+   --  Get/Set the address for storing the current task's machine state\n+\n+   function Get_Current_Excep return SSL.EOA;\n+   --  Task-safe version of SSL.Get_Current_Excep\n+\n+   procedure Timed_Delay_T (Time : Duration; Mode : Integer);\n+   --  Task-safe version of SSL.Timed_Delay\n+\n+   ----------------------\n+   -- Soft-Link Bodies --\n+   ----------------------\n+\n+   function Get_Current_Excep return SSL.EOA is\n+   begin\n+      return STPO.Self.Common.Compiler_Data.Current_Excep'Access;\n+   end Get_Current_Excep;\n+\n+   function Get_Jmpbuf_Address return  Address is\n+   begin\n+      return STPO.Self.Common.Compiler_Data.Jmpbuf_Address;\n+   end Get_Jmpbuf_Address;\n+\n+   function Get_Machine_State_Addr return Address is\n+   begin\n+      return STPO.Self.Common.Compiler_Data.Machine_State_Addr;\n+   end Get_Machine_State_Addr;\n+\n+   function Get_Sec_Stack_Addr return  Address is\n+   begin\n+      return STPO.Self.Common.Compiler_Data.Sec_Stack_Addr;\n+   end Get_Sec_Stack_Addr;\n+\n+   procedure Set_Jmpbuf_Address (Addr : Address) is\n+   begin\n+      STPO.Self.Common.Compiler_Data.Jmpbuf_Address := Addr;\n+   end Set_Jmpbuf_Address;\n+\n+   procedure Set_Machine_State_Addr (Addr : Address) is\n+   begin\n+      STPO.Self.Common.Compiler_Data.Machine_State_Addr := Addr;\n+   end Set_Machine_State_Addr;\n+\n+   procedure Set_Sec_Stack_Addr (Addr : Address) is\n+   begin\n+      STPO.Self.Common.Compiler_Data.Sec_Stack_Addr := Addr;\n+   end Set_Sec_Stack_Addr;\n+\n+   procedure Timed_Delay_T (Time : Duration; Mode : Integer) is\n+   begin\n+      STPO.Timed_Delay (STPO.Self, Time, Mode);\n+   end Timed_Delay_T;\n+\n+   -----------------------------\n+   -- Init_Tasking_Soft_Links --\n+   -----------------------------\n+\n+   procedure Init_Tasking_Soft_Links is\n+   begin\n+      --  If the tasking soft links have already been initialized do not\n+      --  repeat it.\n+\n+      if not Initialized then\n+         --  Mark tasking soft links as initialized\n+\n+         Initialized := True;\n+\n+         --  The application being executed uses tasking so that the tasking\n+         --  version of the following soft links need to be used.\n+\n+         SSL.Get_Jmpbuf_Address     := Get_Jmpbuf_Address'Access;\n+         SSL.Set_Jmpbuf_Address     := Set_Jmpbuf_Address'Access;\n+         SSL.Get_Sec_Stack_Addr     := Get_Sec_Stack_Addr'Access;\n+         SSL.Set_Sec_Stack_Addr     := Set_Sec_Stack_Addr'Access;\n+         SSL.Get_Machine_State_Addr := Get_Machine_State_Addr'Access;\n+         SSL.Set_Machine_State_Addr := Set_Machine_State_Addr'Access;\n+         SSL.Get_Current_Excep      := Get_Current_Excep'Access;\n+         SSL.Timed_Delay            := Timed_Delay_T'Access;\n+\n+         --  No need to create a new Secondary Stack, since we will use the\n+         --  default one created in s-secsta.adb\n+\n+         SSL.Set_Sec_Stack_Addr     (SSL.Get_Sec_Stack_Addr_NT);\n+         SSL.Set_Jmpbuf_Address     (SSL.Get_Jmpbuf_Address_NT);\n+         SSL.Set_Machine_State_Addr (SSL.Get_Machine_State_Addr_NT);\n+      end if;\n+\n+   end Init_Tasking_Soft_Links;\n+\n+end System.Soft_Links.Tasking;"}, {"sha": "1b9dae4396b59145cc8eeada8bcd211a9efbd267", "filename": "gcc/ada/s-solita.ads", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fs-solita.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fs-solita.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-solita.ads?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -0,0 +1,46 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--             S Y S T E M . S O F T _ L I N K S . T A S K I N G            --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2004, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the tasking versions soft links that are common\n+--  to the full and the restricted run times. The rest of the required soft\n+--  links are set by System.Tasking.Initialization and System.Tasking.Stages\n+--  (full run time) or System.Tasking.Restricted.Stages (restricted run\n+--  time).\n+\n+package System.Soft_Links.Tasking is\n+\n+   procedure Init_Tasking_Soft_Links;\n+   --  Set the tasking soft links that are common to the full and the\n+   --  restricted run times.\n+\n+end System.Soft_Links.Tasking;"}, {"sha": "4a5b6af4bfc3cfe8d0e8da84119bb233cf2cbb04", "filename": "gcc/ada/s-taprob.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fs-taprob.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fs-taprob.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprob.adb?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -7,7 +7,7 @@\n --                                  B o d y                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2003, Ada Core Technologies               --\n+--             Copyright (C) 1995-2004, Ada Core Technologies               --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,6 +46,9 @@ with System.Parameters;\n with System.Traces;\n --  used for Send_Trace_Info\n \n+with System.Soft_Links.Tasking;\n+--  Used for Init_Tasking_Soft_Links\n+\n package body System.Tasking.Protected_Objects is\n \n    use System.Task_Primitives.Operations;\n@@ -137,4 +140,8 @@ package body System.Tasking.Protected_Objects is\n       end if;\n    end Unlock;\n \n+begin\n+   --  Ensure that tasking soft links are set when using protected objects\n+\n+   System.Soft_Links.Tasking.Init_Tasking_Soft_Links;\n end System.Tasking.Protected_Objects;"}, {"sha": "17c3ba6dffaf6185b6dbd9c5032f7ae63192af37", "filename": "gcc/ada/s-tarest.adb", "status": "modified", "additions": 9, "deletions": 82, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fs-tarest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fs-tarest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tarest.adb?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -67,6 +67,9 @@ with System.Soft_Links;\n --  The GNARL must call these to be sure that all non-tasking\n --  Ada constructs will work.\n \n+with System.Soft_Links.Tasking;\n+--  Used for Init_Tasking_Soft_Links\n+\n with System.Secondary_Stack;\n --  used for SS_Init;\n \n@@ -105,21 +108,6 @@ package body System.Tasking.Restricted.Stages is\n    --  all nested locks must be released before other tasks competing for the\n    --  tasking lock are released.\n \n-   --  See s-tasini.adb for more information on the following functions.\n-\n-   function Get_Jmpbuf_Address return Address;\n-   procedure Set_Jmpbuf_Address (Addr : Address);\n-\n-   function Get_Sec_Stack_Addr return Address;\n-   procedure Set_Sec_Stack_Addr (Addr : Address);\n-\n-   function  Get_Machine_State_Addr return Address;\n-   procedure Set_Machine_State_Addr (Addr : Address);\n-\n-   function Get_Current_Excep return SSL.EOA;\n-\n-   procedure Timed_Delay_T (Time : Duration; Mode : Integer);\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -158,45 +146,6 @@ package body System.Tasking.Restricted.Stages is\n       STPO.Unlock (Global_Task_Lock'Access, Global_Lock => True);\n    end Task_Unlock;\n \n-   ----------------------\n-   -- Soft-Link Bodies --\n-   ----------------------\n-\n-   function Get_Current_Excep return SSL.EOA is\n-   begin\n-      return STPO.Self.Common.Compiler_Data.Current_Excep'Access;\n-   end Get_Current_Excep;\n-\n-   function Get_Jmpbuf_Address return  Address is\n-   begin\n-      return STPO.Self.Common.Compiler_Data.Jmpbuf_Address;\n-   end Get_Jmpbuf_Address;\n-\n-   function Get_Machine_State_Addr return Address is\n-   begin\n-      return STPO.Self.Common.Compiler_Data.Machine_State_Addr;\n-   end Get_Machine_State_Addr;\n-\n-   function Get_Sec_Stack_Addr return  Address is\n-   begin\n-      return STPO.Self.Common.Compiler_Data.Sec_Stack_Addr;\n-   end Get_Sec_Stack_Addr;\n-\n-   procedure Set_Jmpbuf_Address (Addr : Address) is\n-   begin\n-      STPO.Self.Common.Compiler_Data.Jmpbuf_Address := Addr;\n-   end Set_Jmpbuf_Address;\n-\n-   procedure Set_Machine_State_Addr (Addr : Address) is\n-   begin\n-      STPO.Self.Common.Compiler_Data.Machine_State_Addr := Addr;\n-   end Set_Machine_State_Addr;\n-\n-   procedure Set_Sec_Stack_Addr (Addr : Address) is\n-   begin\n-      STPO.Self.Common.Compiler_Data.Sec_Stack_Addr := Addr;\n-   end Set_Sec_Stack_Addr;\n-\n    ------------------\n    -- Task_Wrapper --\n    ------------------\n@@ -262,15 +211,6 @@ package body System.Tasking.Restricted.Stages is\n       end;\n    end Task_Wrapper;\n \n-   -------------------\n-   -- Timed_Delay_T --\n-   -------------------\n-\n-   procedure Timed_Delay_T (Time : Duration; Mode : Integer) is\n-   begin\n-      STPO.Timed_Delay (STPO.Self, Time, Mode);\n-   end Timed_Delay_T;\n-\n    -----------------------\n    -- Restricted GNARLI --\n    -----------------------\n@@ -566,27 +506,14 @@ package body System.Tasking.Restricted.Stages is\n       --  Notify that the tasking run time has been elaborated so that\n       --  the tasking version of the soft links can be used.\n \n-      SSL.Lock_Task              := Task_Lock'Access;\n-      SSL.Unlock_Task            := Task_Unlock'Access;\n-\n-      SSL.Get_Jmpbuf_Address     := Get_Jmpbuf_Address'Access;\n-      SSL.Set_Jmpbuf_Address     := Set_Jmpbuf_Address'Access;\n-      SSL.Get_Machine_State_Addr := Get_Machine_State_Addr'Access;\n-      SSL.Set_Machine_State_Addr := Set_Machine_State_Addr'Access;\n-      SSL.Get_Current_Excep      := Get_Current_Excep'Access;\n-      SSL.Set_Jmpbuf_Address     (SSL.Get_Jmpbuf_Address_NT);\n-      SSL.Set_Machine_State_Addr (SSL.Get_Machine_State_Addr_NT);\n-\n-      SSL.Get_Sec_Stack_Addr     := Get_Sec_Stack_Addr'Access;\n-      SSL.Set_Sec_Stack_Addr     := Set_Sec_Stack_Addr'Access;\n-\n-      --  No need to create a new Secondary Stack, since we will use the\n-      --  default one created in s-secsta.adb\n+      SSL.Lock_Task   := Task_Lock'Access;\n+      SSL.Unlock_Task := Task_Unlock'Access;\n+      SSL.Adafinal    := Finalize_Global_Tasks'Access;\n \n-      Set_Sec_Stack_Addr (SSL.Get_Sec_Stack_Addr_NT);\n+      --  Initialize the tasking soft links (if not done yet) that are common\n+      --  to the full and the restricted run times.\n \n-      SSL.Timed_Delay            := Timed_Delay_T'Access;\n-      SSL.Adafinal               := Finalize_Global_Tasks'Access;\n+      SSL.Tasking.Init_Tasking_Soft_Links;\n    end Init_RTS;\n \n begin"}, {"sha": "871b2d035d57b1cceea425c3dd94e7f2662e7482", "filename": "gcc/ada/s-tasini.adb", "status": "modified", "additions": 21, "deletions": 85, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fs-tasini.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fs-tasini.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasini.adb?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -60,6 +60,9 @@ with System.Soft_Links;\n --  used for the non-tasking routines (*_NT) that refer to global data.\n --  They are needed here before the tasking run time has been elaborated.\n \n+with System.Soft_Links.Tasking;\n+--  Used for Init_Tasking_Soft_Links\n+\n with System.Tasking.Debug;\n --  used for Trace\n \n@@ -87,9 +90,9 @@ package body System.Tasking.Initialization is\n      (Ada, Current_Target_Exception, \"__gnat_current_target_exception\");\n    --  Import this subprogram from the private part of Ada.Exceptions.\n \n-   -----------------------------------------------------------------\n-   -- Tasking versions of services needed by non-tasking programs --\n-   -----------------------------------------------------------------\n+   ----------------------------------------------------------------------\n+   -- Tasking versions of some services needed by non-tasking programs --\n+   ----------------------------------------------------------------------\n \n    procedure Task_Lock;\n    --  Locks out other tasks. Preceding a section of code by Task_Lock and\n@@ -104,31 +107,13 @@ package body System.Tasking.Initialization is\n    --  all nested locks must be released before other tasks competing for the\n    --  tasking lock are released.\n \n-   function  Get_Jmpbuf_Address return  Address;\n-   procedure Set_Jmpbuf_Address (Addr : Address);\n-   --  Get/Set Jmpbuf_Address for current task\n-\n-   function  Get_Sec_Stack_Addr return  Address;\n-   procedure Set_Sec_Stack_Addr (Addr : Address);\n-   --  Get/Set location of current task's secondary stack\n-\n    function  Get_Exc_Stack_Addr return Address;\n    --  Get the exception stack for the current task\n \n    procedure Set_Exc_Stack_Addr (Self_ID : Address; Addr : Address);\n    --  Self_ID is the Task_Id of the task that gets the exception stack.\n    --  For Self_ID = Null_Address, the current task gets the exception stack.\n \n-   function  Get_Machine_State_Addr return Address;\n-   procedure Set_Machine_State_Addr (Addr : Address);\n-   --  Get/Set the address for storing the current task's machine state\n-\n-   function Get_Current_Excep return SSL.EOA;\n-   --  Task-safe version of SSL.Get_Current_Excep\n-\n-   procedure Timed_Delay_T (Time : Duration; Mode : Integer);\n-   --  Task-safe version of SSL.Timed_Delay\n-\n    function Get_Stack_Info return Stack_Checking.Stack_Access;\n    --  Get access to the current task's Stack_Info\n \n@@ -404,30 +389,21 @@ package body System.Tasking.Initialization is\n          SSL.Abort_Undefer := Undefer_Abortion'Access;\n       end if;\n \n-      SSL.Update_Exception       := Update_Exception'Access;\n-      SSL.Lock_Task              := Task_Lock'Access;\n-      SSL.Unlock_Task            := Task_Unlock'Access;\n-      SSL.Get_Jmpbuf_Address     := Get_Jmpbuf_Address'Access;\n-      SSL.Set_Jmpbuf_Address     := Set_Jmpbuf_Address'Access;\n-      SSL.Get_Sec_Stack_Addr     := Get_Sec_Stack_Addr'Access;\n-      SSL.Set_Sec_Stack_Addr     := Set_Sec_Stack_Addr'Access;\n-      SSL.Get_Exc_Stack_Addr     := Get_Exc_Stack_Addr'Access;\n-      SSL.Set_Exc_Stack_Addr     := Set_Exc_Stack_Addr'Access;\n-      SSL.Get_Machine_State_Addr := Get_Machine_State_Addr'Access;\n-      SSL.Set_Machine_State_Addr := Set_Machine_State_Addr'Access;\n-      SSL.Get_Current_Excep      := Get_Current_Excep'Access;\n-      SSL.Timed_Delay            := Timed_Delay_T'Access;\n-      SSL.Check_Abort_Status     := Check_Abort_Status'Access;\n-      SSL.Get_Stack_Info         := Get_Stack_Info'Access;\n-      SSL.Task_Name              := Task_Name'Access;\n-\n-      --  No need to create a new Secondary Stack, since we will use the\n-      --  default one created in s-secsta.adb\n-\n-      SSL.Set_Sec_Stack_Addr     (SSL.Get_Sec_Stack_Addr_NT);\n-      SSL.Set_Exc_Stack_Addr     (Null_Address, SSL.Get_Exc_Stack_Addr_NT);\n-      SSL.Set_Jmpbuf_Address     (SSL.Get_Jmpbuf_Address_NT);\n-      SSL.Set_Machine_State_Addr (SSL.Get_Machine_State_Addr_NT);\n+      SSL.Update_Exception   := Update_Exception'Access;\n+      SSL.Lock_Task          := Task_Lock'Access;\n+      SSL.Unlock_Task        := Task_Unlock'Access;\n+      SSL.Get_Exc_Stack_Addr := Get_Exc_Stack_Addr'Access;\n+      SSL.Set_Exc_Stack_Addr := Set_Exc_Stack_Addr'Access;\n+      SSL.Check_Abort_Status := Check_Abort_Status'Access;\n+      SSL.Get_Stack_Info     := Get_Stack_Info'Access;\n+      SSL.Task_Name          := Task_Name'Access;\n+\n+      SSL.Set_Exc_Stack_Addr (Null_Address, SSL.Get_Exc_Stack_Addr_NT);\n+\n+      --  Initialize the tasking soft links (if not done yet) that are common\n+      --  to the full and the restricted run times.\n+\n+      SSL.Tasking.Init_Tasking_Soft_Links;\n \n       --  Install tasking locks in the GCC runtime.\n \n@@ -920,31 +896,11 @@ package body System.Tasking.Initialization is\n    -- Soft-Link Bodies --\n    ----------------------\n \n-   function Get_Current_Excep return SSL.EOA is\n-   begin\n-      return STPO.Self.Common.Compiler_Data.Current_Excep'Access;\n-   end Get_Current_Excep;\n-\n    function Get_Exc_Stack_Addr return Address is\n    begin\n       return STPO.Self.Common.Compiler_Data.Exc_Stack_Addr;\n    end Get_Exc_Stack_Addr;\n \n-   function Get_Jmpbuf_Address return  Address is\n-   begin\n-      return STPO.Self.Common.Compiler_Data.Jmpbuf_Address;\n-   end Get_Jmpbuf_Address;\n-\n-   function Get_Machine_State_Addr return Address is\n-   begin\n-      return STPO.Self.Common.Compiler_Data.Machine_State_Addr;\n-   end Get_Machine_State_Addr;\n-\n-   function Get_Sec_Stack_Addr return  Address is\n-   begin\n-      return STPO.Self.Common.Compiler_Data.Sec_Stack_Addr;\n-   end Get_Sec_Stack_Addr;\n-\n    function Get_Stack_Info return Stack_Checking.Stack_Access is\n    begin\n       return STPO.Self.Common.Compiler_Data.Pri_Stack_Info'Access;\n@@ -960,26 +916,6 @@ package body System.Tasking.Initialization is\n       Me.Common.Compiler_Data.Exc_Stack_Addr := Addr;\n    end Set_Exc_Stack_Addr;\n \n-   procedure Set_Jmpbuf_Address (Addr : Address) is\n-   begin\n-      STPO.Self.Common.Compiler_Data.Jmpbuf_Address := Addr;\n-   end Set_Jmpbuf_Address;\n-\n-   procedure Set_Machine_State_Addr (Addr : Address) is\n-   begin\n-      STPO.Self.Common.Compiler_Data.Machine_State_Addr := Addr;\n-   end Set_Machine_State_Addr;\n-\n-   procedure Set_Sec_Stack_Addr (Addr : Address) is\n-   begin\n-      STPO.Self.Common.Compiler_Data.Sec_Stack_Addr := Addr;\n-   end Set_Sec_Stack_Addr;\n-\n-   procedure Timed_Delay_T (Time : Duration; Mode : Integer) is\n-   begin\n-      STPO.Timed_Delay (STPO.Self, Time, Mode);\n-   end Timed_Delay_T;\n-\n    -----------------------\n    -- Soft-Link Dummies --\n    -----------------------"}, {"sha": "73c6b33a9e70d6a8cd7878cd256169af2d59fda1", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -6075,11 +6075,22 @@ package body Sem_Ch3 is\n          Set_Ekind (Def_Id, E_Class_Wide_Subtype);\n \n       else\n-         --  Incomplete type. Attach subtype to list of dependents, to be\n-         --  completed with full view of parent type.\n+         --  Incomplete type.  attach subtype to list of dependents, to be\n+         --  completed with full view of parent type,  unless is it the\n+         --  designated subtype of a record component within an init_proc.\n+         --  This last case arises for a component of an access type whose\n+         --  designated type is incomplete (e.g. a Taft Amendment type).\n+         --  The designated subtype is within an inner scope, and needs no\n+         --  elaboration, because only the access type is needed in the\n+         --  initialization procedure.\n \n          Set_Ekind (Def_Id, Ekind (T));\n-         Append_Elmt (Def_Id, Private_Dependents (T));\n+\n+         if For_Access and then Within_Init_Proc then\n+            null;\n+         else\n+            Append_Elmt (Def_Id, Private_Dependents (T));\n+         end if;\n       end if;\n \n       Set_Etype             (Def_Id, T);\n@@ -6831,6 +6842,12 @@ package body Sem_Ch3 is\n          if Has_Discriminants (Full_Base) then\n             Set_Discriminant_Constraint\n               (Full, Discriminant_Constraint (Full_Base));\n+\n+            --  The partial view may have been indefinite, the full view\n+            --  might not be.\n+\n+            Set_Has_Unknown_Discriminants\n+              (Full, Has_Unknown_Discriminants (Full_Base));\n          end if;\n       end if;\n "}, {"sha": "3831b6735da5ed418a06dca1298a23b8446632ee", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -28,6 +28,7 @@ with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n@@ -233,6 +234,9 @@ package body Sem_Ch4 is\n    --  to a subprogram, and the call F (X)  interpreted as F.all (X). In\n    --  this case the call may be overloaded with both interpretations.\n \n+   function Try_Object_Operation (N : Node_Id) return Boolean;\n+   --  Ada 2005 (AI-252): Give support to the object operation notation\n+\n    ------------------------\n    -- Ambiguous_Operands --\n    ------------------------\n@@ -2677,6 +2681,15 @@ package body Sem_Ch4 is\n             Next_Entity (Comp);\n          end loop;\n \n+         --  Ada 2005 (AI-252)\n+\n+         if Ada_Version >= Ada_05\n+           and then Is_Tagged_Type (Prefix_Type)\n+           and then Try_Object_Operation (N)\n+         then\n+            return;\n+         end if;\n+\n       elsif Is_Private_Type (Prefix_Type) then\n \n          --  Allow access only to discriminants of the type. If the\n@@ -4635,4 +4648,309 @@ package body Sem_Ch4 is\n \n    end Try_Indexed_Call;\n \n+   --------------------------\n+   -- Try_Object_Operation --\n+   --------------------------\n+\n+   function Try_Object_Operation (N : Node_Id) return Boolean is\n+      Obj        : constant Node_Id := Prefix (N);\n+      Obj_Type   : Entity_Id;\n+      Actual     : Node_Id;\n+      Last_Node  : Node_Id;\n+      --  Last_Node is used to free all the nodes generated while trying the\n+      --  alternatives. NOTE: This must be removed because it is considered\n+      --  too low level\n+      use Atree_Private_Part;\n+\n+      function Try_Replacement\n+        (New_Prefix : Entity_Id;\n+         New_Subprg : Node_Id;\n+         New_Formal : Node_Id;\n+         Nam_Ent    : Entity_Id) return Boolean;\n+      --  Replace the node with the Object.Operation notation by the\n+      --  equivalent node with the Package.Operation (Object, ...) notation\n+      --\n+      --  Nam_Ent is the entity that provides the formals against which\n+      --  the actuals are checked. If the actuals are compatible with\n+      --  Ent_Nam, this function returns true.\n+\n+      function Try_Primitive_Operations\n+        (New_Prefix : Entity_Id;\n+         New_Subprg : Node_Id;\n+         Obj        : Node_Id;\n+         Obj_Type   : Entity_Id) return Boolean;\n+      --  Traverse the list of primitive subprograms to look for the\n+      --  subprogram.\n+\n+      function Try_Class_Wide_Operation\n+        (New_Subprg : Node_Id;\n+         Obj        : Node_Id;\n+         Obj_Type   : Entity_Id) return Boolean;\n+      --  Traverse all the ancestor types to look for a class-wide\n+      --  subprogram\n+\n+      ------------------------------\n+      -- Try_Primitive_Operations --\n+      ------------------------------\n+\n+      function Try_Primitive_Operations\n+        (New_Prefix : Entity_Id;\n+         New_Subprg : Node_Id;\n+         Obj        : Node_Id;\n+         Obj_Type   : Entity_Id) return Boolean\n+      is\n+         Deref      : Node_Id;\n+         Elmt       : Elmt_Id;\n+         Prim_Op    : Entity_Id;\n+\n+      begin\n+         --  Look for the subprogram in the list of primitive operations.\n+         --  This case is simple because all the primitive operations are\n+         --  implicitly inherited and thus we have a candidate as soon as\n+         --  we find a primitive subprogram with the same name. The latter\n+         --  analysis after the node replacement will resolve it.\n+\n+         Elmt := First_Elmt (Primitive_Operations (Obj_Type));\n+\n+         while Present (Elmt) loop\n+            Prim_Op := Node (Elmt);\n+\n+            if Chars (Prim_Op) = Chars (New_Subprg) then\n+               if Try_Replacement (New_Prefix => New_Prefix,\n+                                   New_Subprg => New_Subprg,\n+                                   New_Formal => Obj,\n+                                   Nam_Ent    => Prim_Op)\n+               then\n+                  return True;\n+\n+               --  Try the implicit dereference in case of access type\n+\n+               elsif Is_Access_Type (Etype (Obj)) then\n+                  Deref := Make_Explicit_Dereference (Sloc (Obj), Obj);\n+                  Set_Etype (Deref, Obj_Type);\n+\n+                  if Try_Replacement (New_Prefix => New_Prefix,\n+                                      New_Subprg => New_Subprg,\n+                                      New_Formal => Deref,\n+                                      Nam_Ent    => Prim_Op)\n+                  then\n+                     return True;\n+                  end if;\n+               end if;\n+            end if;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n+\n+         return False;\n+      end Try_Primitive_Operations;\n+\n+      ------------------------------\n+      -- Try_Class_Wide_Operation --\n+      ------------------------------\n+\n+      function Try_Class_Wide_Operation\n+        (New_Subprg : Node_Id;\n+         Obj        : Node_Id;\n+         Obj_Type   : Entity_Id) return Boolean\n+      is\n+         Deref      : Node_Id;\n+         Hom        : Entity_Id;\n+         Typ        : Entity_Id;\n+\n+      begin\n+         Typ := Obj_Type;\n+\n+         loop\n+            --  For each parent subtype we traverse all the homonym chain\n+            --  looking for a candidate class-wide subprogram\n+\n+            Hom := Current_Entity (New_Subprg);\n+\n+            while Present (Hom) loop\n+               if (Ekind (Hom) = E_Procedure\n+                     or else Ekind (Hom) = E_Function)\n+                   and then Present (First_Entity (Hom))\n+                   and then Etype (First_Entity (Hom)) = Class_Wide_Type (Typ)\n+               then\n+                  if Try_Replacement\n+                    (New_Prefix => Scope (Hom),\n+                     New_Subprg => Make_Identifier (Sloc (N), Chars (Hom)),\n+                     New_Formal => Obj,\n+                     Nam_Ent    => Hom)\n+                  then\n+                     return True;\n+\n+                  --  Try the implicit dereference in case of access type\n+\n+                  elsif Is_Access_Type (Etype (Obj)) then\n+                     Deref := Make_Explicit_Dereference (Sloc (Obj), Obj);\n+                     Set_Etype (Deref, Obj_Type);\n+\n+                     if Try_Replacement\n+                       (New_Prefix => Scope (Hom),\n+                        New_Subprg => Make_Identifier (Sloc (N), Chars (Hom)),\n+                        New_Formal => Deref,\n+                        Nam_Ent    => Hom)\n+                     then\n+                        return True;\n+                     end if;\n+                  end if;\n+               end if;\n+\n+               Hom := Homonym (Hom);\n+            end loop;\n+\n+            exit when Etype (Typ) = Typ;\n+\n+            Typ := Etype (Typ); --  Climb to the ancestor type\n+         end loop;\n+\n+         return False;\n+      end Try_Class_Wide_Operation;\n+\n+      ---------------------\n+      -- Try_Replacement --\n+      ---------------------\n+\n+      function Try_Replacement\n+        (New_Prefix : Entity_Id;\n+         New_Subprg : Node_Id;\n+         New_Formal : Node_Id;\n+         Nam_Ent    : Entity_Id) return Boolean\n+      is\n+         Loc             : constant Source_Ptr := Sloc (N);\n+         Call_Node       : Node_Id;\n+         New_Name        : Node_Id;\n+         New_Actuals     : List_Id;\n+         Node_To_Replace : Node_Id;\n+         Success         : Boolean;\n+\n+      begin\n+         --  Step 1. Build the replacement node: a subprogram call node\n+         --  with the object as its first actual parameter\n+\n+         New_Name := Make_Selected_Component (Loc,\n+                       Prefix        => New_Reference_To (New_Prefix, Loc),\n+                       Selector_Name => New_Copy_Tree (New_Subprg));\n+\n+         New_Actuals := New_List (New_Copy_Tree (New_Formal));\n+\n+         if (Nkind (Parent (N)) = N_Procedure_Call_Statement\n+               or else Nkind (Parent (N)) = N_Function_Call)\n+             and then N /= First (Parameter_Associations (Parent (N)))\n+               --  Protect against recursive call; It occurs in \"..:= F (O.P)\"\n+         then\n+            Node_To_Replace := Parent (N);\n+\n+            Append_List_To\n+              (New_Actuals,\n+               New_Copy_List (Parameter_Associations (Node_To_Replace)));\n+\n+            if Nkind (Node_To_Replace) = N_Procedure_Call_Statement then\n+               Call_Node :=\n+                 Make_Procedure_Call_Statement (Loc, New_Name, New_Actuals);\n+\n+            else pragma Assert (Nkind (Node_To_Replace) = N_Function_Call);\n+               Call_Node :=\n+                 Make_Function_Call (Loc, New_Name, New_Actuals);\n+            end if;\n+\n+         --  Case of a function without parameters\n+\n+         else\n+            Node_To_Replace := N;\n+\n+            Call_Node :=\n+              Make_Function_Call (Loc, New_Name, New_Actuals);\n+         end if;\n+\n+         --  Step 2. Analyze the candidate replacement node. If it was\n+         --  successfully analyzed then replace the original node and\n+         --  carry out the full analysis to verify that there is no\n+         --  conflict with overloaded subprograms.\n+\n+         --  To properly analyze the candidate we must initialize the type\n+         --  of the result node of the call to the error type; it will be\n+         --  reset if the type is successfully resolved.\n+\n+         Set_Etype (Call_Node, Any_Type);\n+\n+         Analyze_One_Call\n+           (N       => Call_Node,\n+            Nam     => Nam_Ent,\n+            Report  => False,  -- do not post errors\n+            Success => Success);\n+\n+         if Success then\n+            --  Previous analysis transformed the node with the name\n+            --  and we have to reset it to properly re-analyze it.\n+\n+            New_Name := Make_Selected_Component (Loc,\n+                          Prefix        => New_Reference_To (New_Prefix, Loc),\n+                          Selector_Name => New_Copy_Tree (New_Subprg));\n+            Set_Name (Call_Node, New_Name);\n+\n+            Set_Analyzed (Call_Node, False);\n+            Set_Parent (Call_Node, Parent (Node_To_Replace));\n+            Replace (Node_To_Replace, Call_Node);\n+            Analyze (Node_To_Replace);\n+            return True;\n+\n+         --  Free all the nodes used for this test and return\n+         else\n+            Nodes.Set_Last (Last_Node);\n+            return False;\n+         end if;\n+      end Try_Replacement;\n+\n+   --  Start of processing for Try_Object_Operation\n+\n+   begin\n+      --  Find the type of the object\n+\n+      Obj_Type := Etype (Obj);\n+\n+      if Is_Access_Type (Obj_Type) then\n+         Obj_Type := Designated_Type (Obj_Type);\n+      end if;\n+\n+      if Ekind (Obj_Type) = E_Private_Subtype then\n+         Obj_Type := Base_Type (Obj_Type);\n+      end if;\n+\n+      if Is_Class_Wide_Type (Obj_Type) then\n+         Obj_Type := Etype (Class_Wide_Type (Obj_Type));\n+      end if;\n+\n+      --  Analyze the actuals\n+\n+      if (Nkind (Parent (N)) = N_Procedure_Call_Statement\n+            or else Nkind (Parent (N)) = N_Function_Call)\n+          and then N /= First (Parameter_Associations (Parent (N)))\n+            --  Protects against recursive call in case of \"..:= F (O.Proc)\"\n+      then\n+         Actual := First (Parameter_Associations (Parent (N)));\n+\n+         while Present (Actual) loop\n+            Analyze (Actual);\n+            Check_Parameterless_Call (Actual);\n+            Next_Actual (Actual);\n+         end loop;\n+      end if;\n+\n+      Last_Node := Last_Node_Id;\n+\n+      return Try_Primitive_Operations\n+               (New_Prefix => Scope (Obj_Type),\n+                New_Subprg => Selector_Name (N),\n+                Obj        => Obj,\n+                Obj_Type   => Obj_Type)\n+           or else\n+             Try_Class_Wide_Operation\n+               (New_Subprg => Selector_Name (N),\n+                Obj        => Obj,\n+                Obj_Type   => Obj_Type);\n+   end Try_Object_Operation;\n+\n end Sem_Ch4;"}, {"sha": "eeff99475b7265091ff3d4e764fae079f532c8c0", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=35ae2ed81410448471c46f7757e6bc879d4de250", "patch": "@@ -3592,7 +3592,11 @@ package body Sem_Ch8 is\n \n          begin\n             while Present (H) loop\n-               if Scope (H) = Scope (Id) then\n+               if Scope (H) = Scope (Id)\n+                 and then\n+                   (not Is_Hidden (H)\n+                      or else Is_Immediately_Visible (H))\n+               then\n                   Collect_Interps (N);\n                   exit;\n                end if;"}, {"sha": "6b7a174c3693eec38eadb7c8ff17162c552d08e6", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 2108, "deletions": 2121, "changes": 4229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ae2ed81410448471c46f7757e6bc879d4de250/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=35ae2ed81410448471c46f7757e6bc879d4de250"}]}