{"sha": "cdeed45ae6332ad98f220653878c11e6208a267f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RlZWQ0NWFlNjMzMmFkOThmMjIwNjUzODc4YzExZTYyMDhhMjY3Zg==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2009-05-12T22:41:54Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2009-05-12T22:41:54Z"}, "message": "sh-protos.h (sh_legitimate_index_p): Declare.\n\n\t* config/sh/sh-protos.h (sh_legitimate_index_p): Declare.\n\t(sh_legitimate_address_p): Likewise.\n\t* config/sh/sh.c (sh_legitimate_index_p): New.\n\t(sh_legitimate_address_p): Likewise.\n\t* config/sh/sh.h (REG_OK_FOR_BASE_P): Add STRICT parameter.\n\t(REG_OK_FOR_INDEX_P, SUBREG_OK_FOR_INDEX_P): Likewise.\n\t(MODE_DISP_OK_4, MODE_DISP_OK_8): Remove.\n\t(MAYBE_BASE_REGISTER_RTX_P): New macro.\n\t(MAYBE_INDEX_REGISTER_RTX_P): Likewise.\n\t(BASE_REGISTER_RTX_P): Use MAYBE_BASE_REGISTER_RTX_P.\n\t(INDEX_REGISTER_RTX_P): Use MAYBE_INDEX_REGISTER_RTX_P.\n\t(GO_IF_LEGITIMATE_INDEX): Use sh_legitimate_index_p.\n\t(GO_IF_LEGITIMATE_ADDRESS): Use sh_legitimate_address_p.\n\nFrom-SVN: r147450", "tree": {"sha": "b112c515e96cb3fc7c38e8b52a67d03c6f1e859c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b112c515e96cb3fc7c38e8b52a67d03c6f1e859c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdeed45ae6332ad98f220653878c11e6208a267f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdeed45ae6332ad98f220653878c11e6208a267f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdeed45ae6332ad98f220653878c11e6208a267f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdeed45ae6332ad98f220653878c11e6208a267f/comments", "author": null, "committer": null, "parents": [{"sha": "1195342643fe340155fe865f734e679552b751c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1195342643fe340155fe865f734e679552b751c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1195342643fe340155fe865f734e679552b751c6"}], "stats": {"total": 355, "additions": 191, "deletions": 164}, "files": [{"sha": "cb8074fdf64c5ec63b4191b26b67f4a27766ff29", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdeed45ae6332ad98f220653878c11e6208a267f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdeed45ae6332ad98f220653878c11e6208a267f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cdeed45ae6332ad98f220653878c11e6208a267f", "patch": "@@ -1,3 +1,19 @@\n+2009-05-12  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* config/sh/sh-protos.h (sh_legitimate_index_p): Declare.\n+\t(sh_legitimate_address_p): Likewise.\n+\t* config/sh/sh.c (sh_legitimate_index_p): New.\n+\t(sh_legitimate_address_p): Likewise.\n+\t* config/sh/sh.h (REG_OK_FOR_BASE_P): Add STRICT parameter.\n+\t(REG_OK_FOR_INDEX_P, SUBREG_OK_FOR_INDEX_P): Likewise.\n+\t(MODE_DISP_OK_4, MODE_DISP_OK_8): Remove.\n+\t(MAYBE_BASE_REGISTER_RTX_P): New macro.\n+\t(MAYBE_INDEX_REGISTER_RTX_P): Likewise.\n+\t(BASE_REGISTER_RTX_P): Use MAYBE_BASE_REGISTER_RTX_P.\n+\t(INDEX_REGISTER_RTX_P): Use MAYBE_INDEX_REGISTER_RTX_P.\n+\t(GO_IF_LEGITIMATE_INDEX): Use sh_legitimate_index_p.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Use sh_legitimate_address_p.\n+\n 2009-05-12  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-inline.c (estimate_operator_cost): Add operands;"}, {"sha": "fb896819b34ae8c53ca472b2df8f16360dca8f6f", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdeed45ae6332ad98f220653878c11e6208a267f/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdeed45ae6332ad98f220653878c11e6208a267f/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=cdeed45ae6332ad98f220653878c11e6208a267f", "patch": "@@ -58,6 +58,8 @@ extern int fp_zero_operand (rtx);\n extern int fp_one_operand (rtx);\n extern int fp_int_operand (rtx);\n extern rtx get_fpscr_rtx (void);\n+extern bool sh_legitimate_index_p (enum machine_mode, rtx);\n+extern bool sh_legitimate_address_p (enum machine_mode, rtx, bool);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n extern int nonpic_symbol_mentioned_p (rtx);\n extern void emit_sf_insn (rtx);"}, {"sha": "79343bfdfd2934239498ddb0b94be2e6ef7c018e", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdeed45ae6332ad98f220653878c11e6208a267f/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdeed45ae6332ad98f220653878c11e6208a267f/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=cdeed45ae6332ad98f220653878c11e6208a267f", "patch": "@@ -8950,6 +8950,124 @@ sh_insn_length_adjustment (rtx insn)\n   return 0;\n }\n \f\n+/* Return TRUE for a valid displacement for the REG+disp addressing\n+   with MODE.  */\n+\n+/* ??? The SH2e does not have the REG+disp addressing mode when loading values\n+   into the FRx registers.  We implement this by setting the maximum offset\n+   to zero when the value is SFmode.  This also restricts loading of SFmode\n+   values into the integer registers, but that can't be helped.  */\n+\n+/* The SH allows a displacement in a QI or HI amode, but only when the\n+   other operand is R0. GCC doesn't handle this very well, so we forgot\n+   all of that.\n+\n+   A legitimate index for a QI or HI is 0, SI can be any number 0..63,\n+   DI can be any number 0..60.  */\n+\n+bool\n+sh_legitimate_index_p (enum machine_mode mode, rtx op)\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      if (TARGET_SHMEDIA)\n+\t{\n+\t  int size;\n+\n+\t  /* Check if this the address of an unaligned load / store.  */\n+\t  if (mode == VOIDmode)\n+\t    return CONST_OK_FOR_I06 (INTVAL (op));\n+\n+\t  size = GET_MODE_SIZE (mode);\n+\t  return (!(INTVAL (op) & (size - 1))\n+\t\t  && INTVAL (op) >= -512 * size\n+\t\t  && INTVAL (op) < 512 * size);\n+\t}\n+\n+      if (TARGET_SH2A)\n+\t{\n+\t  if (GET_MODE_SIZE (mode) == 1\n+\t\t&& (unsigned) INTVAL (op) < 4096)\n+\t    return true;\n+\t}\n+\n+      if ((GET_MODE_SIZE (mode) == 4\n+\t   && (unsigned) INTVAL (op) < 64\n+\t   && !(INTVAL (op) & 3)\n+\t   && !(TARGET_SH2E && mode == SFmode))\n+\t  || (GET_MODE_SIZE (mode) == 4\n+\t      && (unsigned) INTVAL (op) < 16383\n+\t      && !(INTVAL (op) & 3) && TARGET_SH2A))\n+\treturn true;\n+\n+      if ((GET_MODE_SIZE (mode) == 8\n+\t   && (unsigned) INTVAL (op) < 60\n+\t   && !(INTVAL (op) & 3)\n+\t   && !((TARGET_SH4 || TARGET_SH2A) && mode == DFmode))\n+\t  || ((GET_MODE_SIZE (mode)==8)\n+\t      && (unsigned) INTVAL (op) < 8192\n+\t      && !(INTVAL (op) & (TARGET_SH2A_DOUBLE ? 7 : 3))\n+\t      && (TARGET_SH2A && mode == DFmode)))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Recognize an RTL expression that is a valid memory address for\n+   an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+   Allow  REG\n+\t  REG+disp\n+\t  REG+r0\n+\t  REG++\n+\t  --REG  */\n+\n+bool\n+sh_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+{\n+  if (MAYBE_BASE_REGISTER_RTX_P (x, strict))\n+    return true;\n+  else if ((GET_CODE (x) == POST_INC || GET_CODE (x) == PRE_DEC)\n+\t   && ! TARGET_SHMEDIA\n+\t   && MAYBE_BASE_REGISTER_RTX_P (XEXP (x, 0), strict))\n+    return true;\n+  else if (GET_CODE (x) == PLUS\n+\t   && (mode != PSImode || reload_completed))\n+    {\n+      rtx xop0 = XEXP (x, 0);\n+      rtx xop1 = XEXP (x, 1);\n+\n+      if (GET_MODE_SIZE (mode) <= 8\n+\t  && MAYBE_BASE_REGISTER_RTX_P (xop0, strict)\n+\t  && sh_legitimate_index_p (mode, xop1))\n+\treturn true;\n+\n+      if ((ALLOW_INDEXED_ADDRESS || GET_MODE (x) == DImode\n+\t   || ((xop0 == stack_pointer_rtx\n+\t\t|| xop0 == hard_frame_pointer_rtx)\n+\t       && REG_P (xop1) && REGNO (xop1) == R0_REG)\n+\t   || ((xop1 == stack_pointer_rtx\n+\t\t|| xop1 == hard_frame_pointer_rtx)\n+\t       && REG_P (xop0) && REGNO (xop0) == R0_REG))\n+\t  && ((!TARGET_SHMEDIA && GET_MODE_SIZE (mode) <= 4)\n+\t      || (TARGET_SHMEDIA && GET_MODE_SIZE (mode) <= 8)\n+\t      || ((TARGET_SH4 || TARGET_SH2A_DOUBLE)\n+\t\t  && TARGET_FMOVD && mode == DFmode)))\n+\t{\n+\t  if (MAYBE_BASE_REGISTER_RTX_P (xop1, strict)\n+\t      && MAYBE_INDEX_REGISTER_RTX_P (xop0, strict))\n+\t    return true;\n+\t  if (MAYBE_INDEX_REGISTER_RTX_P (xop1, strict)\n+\t      && MAYBE_BASE_REGISTER_RTX_P (xop0, strict))\n+\t    return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\f\n /* Return TRUE if X references a SYMBOL_REF or LABEL_REF whose symbol\n    isn't protected by a PIC unspec.  */\n int"}, {"sha": "0b6294a6ce6819ce0ab10a87d953b8f13cab259d", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 55, "deletions": 164, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdeed45ae6332ad98f220653878c11e6208a267f/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdeed45ae6332ad98f220653878c11e6208a267f/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=cdeed45ae6332ad98f220653878c11e6208a267f", "patch": "@@ -2191,45 +2191,25 @@ struct sh_args {\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) \\\n-  (GENERAL_OR_AP_REGISTER_P (REGNO (X)) || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) \\\n-  ((TARGET_SHMEDIA ? GENERAL_REGISTER_P (REGNO (X)) \\\n-    : REGNO (X) == R0_REG) || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-\n-/* Nonzero if X/OFFSET is a hard reg that can be used as an index\n-   or if X is a pseudo reg.  */\n-#define SUBREG_OK_FOR_INDEX_P(X, OFFSET) \\\n-  ((TARGET_SHMEDIA ? GENERAL_REGISTER_P (REGNO (X)) \\\n-    : REGNO (X) == R0_REG && OFFSET == 0) || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) \\\n-  REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) \\\n-  REGNO_OK_FOR_INDEX_P (REGNO (X))\n-\n-/* Nonzero if X/OFFSET is a hard reg that can be used as an index.  */\n-#define SUBREG_OK_FOR_INDEX_P(X, OFFSET) \\\n-  (REGNO_OK_FOR_INDEX_P (REGNO (X)) && (OFFSET) == 0)\n-\n-#endif\n+   The suitable hard regs are always accepted and all pseudo regs\n+   are also accepted if STRICT is not set.  */\n+\n+/* Nonzero if X is a reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X, STRICT)\t\t\t\\\n+  (GENERAL_OR_AP_REGISTER_P (REGNO (X))\t\t\t\\\n+   || (!STRICT && REGNO (X) >= FIRST_PSEUDO_REGISTER))\n+\n+/* Nonzero if X is a reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X, STRICT)\t\t\t\\\n+  ((TARGET_SHMEDIA ? GENERAL_REGISTER_P (REGNO (X))\t\\\n+    : REGNO (X) == R0_REG)\t\t\t\t\\\n+   || (!STRICT && REGNO (X) >= FIRST_PSEUDO_REGISTER))\n+\n+/* Nonzero if X/OFFSET is a reg that can be used as an index.  */\n+#define SUBREG_OK_FOR_INDEX_P(X, OFFSET, STRICT)\t\\\n+  ((TARGET_SHMEDIA ? GENERAL_REGISTER_P (REGNO (X))\t\\\n+    : REGNO (X) == R0_REG && OFFSET == 0)\t\t\\\n+   || (!STRICT && REGNO (X) >= FIRST_PSEUDO_REGISTER))\n \n /* Macros for extra constraints.  */\n \n@@ -2305,144 +2285,55 @@ struct sh_args {\n       || PCREL_SYMOFF_P (OP)) \\\n    : NON_PIC_REFERENCE_P (OP))\n \f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.  */\n-\n-#define MODE_DISP_OK_4(X,MODE) \\\n-(GET_MODE_SIZE (MODE) == 4 && (unsigned) INTVAL (X) < 64\t\\\n- && ! (INTVAL (X) & 3) && ! (TARGET_SH2E && (MODE) == SFmode))\n-\n-#define MODE_DISP_OK_8(X,MODE) \\\n-((GET_MODE_SIZE(MODE)==8) && ((unsigned)INTVAL(X)<60)\t\\\n- && ! (INTVAL(X) & 3) && ! (TARGET_SH4 && (MODE) == DFmode))\n-\n-#undef MODE_DISP_OK_4\n-#define MODE_DISP_OK_4(X,MODE) \\\n-((GET_MODE_SIZE (MODE) == 4 && (unsigned) INTVAL (X) < 64\t\\\n-  && ! (INTVAL (X) & 3) && ! (TARGET_SH2E && (MODE) == SFmode)) \\\n-  || ((GET_MODE_SIZE(MODE)==4) && ((unsigned)INTVAL(X)<16383)\t\\\n-  && ! (INTVAL(X) & 3) && TARGET_SH2A))\n-\n-#undef MODE_DISP_OK_8\n-#define MODE_DISP_OK_8(X,MODE) \\\n-(((GET_MODE_SIZE(MODE)==8) && ((unsigned)INTVAL(X)<60)\t\\\n-  && ! (INTVAL(X) & 3) && ! ((TARGET_SH4 || TARGET_SH2A) && (MODE) == DFmode)) \\\n- || ((GET_MODE_SIZE(MODE)==8) && ((unsigned)INTVAL(X)<8192)\t\\\n-  && ! (INTVAL(X) & (TARGET_SH2A_DOUBLE ? 7 : 3)) && (TARGET_SH2A && (MODE) == DFmode)))\n-\n-#define BASE_REGISTER_RTX_P(X)\t\t\t\t\\\n-  ((GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\\\n-   || (GET_CODE (X) == SUBREG\t\t\t\t\\\n-       && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (GET_MODE ((X))), \\\n+#define MAYBE_BASE_REGISTER_RTX_P(X, STRICT)\t\t\t\\\n+  ((GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X, STRICT))\t\\\n+   || (GET_CODE (X) == SUBREG\t\t\t\t\t\\\n+       && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (GET_MODE ((X))),\t\\\n \t\t\t\t GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (X)))) \\\n-       && GET_CODE (SUBREG_REG (X)) == REG\t\t\\\n-       && REG_OK_FOR_BASE_P (SUBREG_REG (X))))\n+       && GET_CODE (SUBREG_REG (X)) == REG\t\t\t\\\n+       && REG_OK_FOR_BASE_P (SUBREG_REG (X), STRICT)))\n \n /* Since this must be r0, which is a single register class, we must check\n    SUBREGs more carefully, to be sure that we don't accept one that extends\n    outside the class.  */\n-#define INDEX_REGISTER_RTX_P(X)\t\t\t\t\\\n-  ((GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\t\\\n-   || (GET_CODE (X) == SUBREG\t\t\t\t\\\n+#define MAYBE_INDEX_REGISTER_RTX_P(X, STRICT)\t\t\t\t\\\n+  ((GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X, STRICT))\t\\\n+   || (GET_CODE (X) == SUBREG\t\t\t\t\t\\\n        && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (GET_MODE ((X))), \\\n \t\t\t\t GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (X)))) \\\n        && GET_CODE (SUBREG_REG (X)) == REG\t\t\\\n-       && SUBREG_OK_FOR_INDEX_P (SUBREG_REG (X), SUBREG_BYTE (X))))\n-\n-/* Jump to LABEL if X is a valid address RTX.  This must also take\n-   REG_OK_STRICT into account when deciding about valid registers, but it uses\n-   the above macros so we are in luck.\n+       && SUBREG_OK_FOR_INDEX_P (SUBREG_REG (X), SUBREG_BYTE (X), STRICT)))\n \n-   Allow  REG\n-\t  REG+disp\n-\t  REG+r0\n-\t  REG++\n-\t  --REG  */\n-\n-/* ??? The SH2e does not have the REG+disp addressing mode when loading values\n-   into the FRx registers.  We implement this by setting the maximum offset\n-   to zero when the value is SFmode.  This also restricts loading of SFmode\n-   values into the integer registers, but that can't be helped.  */\n-\n-/* The SH allows a displacement in a QI or HI amode, but only when the\n-   other operand is R0. GCC doesn't handle this very well, so we forgo\n-   all of that.\n-\n-   A legitimate index for a QI or HI is 0, SI can be any number 0..63,\n-   DI can be any number 0..60.  */\n-\n-#define GO_IF_LEGITIMATE_INDEX(MODE, OP, LABEL)  \t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (GET_CODE (OP) == CONST_INT) \t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tif (TARGET_SHMEDIA)\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    int MODE_SIZE;\t\t\t\t\t\t\\\n-\t    /* Check if this the address of an unaligned load / store.  */\\\n-\t    if ((MODE) == VOIDmode)\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tif (CONST_OK_FOR_I06 (INTVAL (OP)))\t\t\t\\\n-\t\t  goto LABEL;\t\t\t\t\t\t\\\n-\t\tbreak;\t\t\t\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    MODE_SIZE = GET_MODE_SIZE (MODE);\t\t\t\t\\\n-\t    if (! (INTVAL (OP) & (MODE_SIZE - 1))\t\t\t\\\n-\t\t&& INTVAL (OP) >= -512 * MODE_SIZE\t\t\t\\\n-\t\t&& INTVAL (OP) < 512 * MODE_SIZE)\t\t\t\\\n-\t      goto LABEL;\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      break;\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tif (TARGET_SH2A)\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_MODE_SIZE (MODE) == 1\t\t\t\t\\\n-\t\t&& (unsigned) INTVAL (OP) < 4096)\t\t\t\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tif (MODE_DISP_OK_4 ((OP), (MODE)))  goto LABEL;\t\t      \t\\\n-\tif (MODE_DISP_OK_8 ((OP), (MODE)))  goto LABEL;\t\t      \t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while(0)\n+#ifdef REG_OK_STRICT\n+#define BASE_REGISTER_RTX_P(X) MAYBE_BASE_REGISTER_RTX_P(X, true)\n+#define INDEX_REGISTER_RTX_P(X) MAYBE_INDEX_REGISTER_RTX_P(X, true)\n+#else\n+#define BASE_REGISTER_RTX_P(X) MAYBE_BASE_REGISTER_RTX_P(X, false)\n+#define INDEX_REGISTER_RTX_P(X) MAYBE_INDEX_REGISTER_RTX_P(X, false)\n+#endif\n \n #define ALLOW_INDEXED_ADDRESS \\\n   ((!TARGET_SHMEDIA32 && !TARGET_SHCOMPACT) || TARGET_ALLOW_INDEXED_ADDRESS)\n \n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (BASE_REGISTER_RTX_P (X))\t\t\t\t\t\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\t\\\n-  else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == PRE_DEC)\t\\\n-\t   && ! TARGET_SHMEDIA\t\t\t\t\t\t\\\n-\t   && BASE_REGISTER_RTX_P (XEXP ((X), 0)))\t\t\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-\t   && ((MODE) != PSImode || reload_completed))\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx xop0 = XEXP ((X), 0);\t\t\t\t\t\t\\\n-      rtx xop1 = XEXP ((X), 1);\t\t\t\t\t\t\\\n-      if (GET_MODE_SIZE (MODE) <= 8 && BASE_REGISTER_RTX_P (xop0))\t\\\n-\tGO_IF_LEGITIMATE_INDEX ((MODE), xop1, LABEL);\t\t\t\\\n-      if ((ALLOW_INDEXED_ADDRESS || GET_MODE (X) == DImode\t\t\\\n-\t   || ((xop0 == stack_pointer_rtx\t\t\t\t\\\n-\t\t|| xop0 == hard_frame_pointer_rtx)\t\t\t\\\n-\t       && REG_P (xop1) && REGNO (xop1) == R0_REG)\t\t\\\n-\t   || ((xop1 == stack_pointer_rtx\t\t\t\t\\\n-\t\t|| xop1 == hard_frame_pointer_rtx)\t\t\t\\\n-\t       && REG_P (xop0) && REGNO (xop0) == R0_REG))\t\t\\\n-\t  && ((!TARGET_SHMEDIA && GET_MODE_SIZE (MODE) <= 4)\t\t\\\n-\t      || (TARGET_SHMEDIA && GET_MODE_SIZE (MODE) <= 8)\t\t\\\n-\t      || ((TARGET_SH4 || TARGET_SH2A_DOUBLE)\t\t\t\\\n-\t\t  && TARGET_FMOVD && MODE == DFmode)))\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (BASE_REGISTER_RTX_P (xop1) && INDEX_REGISTER_RTX_P (xop0))\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\\\n-\t  if (INDEX_REGISTER_RTX_P (xop1) && BASE_REGISTER_RTX_P (xop0))\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n+#define GO_IF_LEGITIMATE_INDEX(MODE, OP, WIN)\t\\\n+  do {\t\t\t\t\t\t\\\n+    if (sh_legitimate_index_p ((MODE), (OP)))\t\\\n+      goto WIN;\t\t\t\t\t\\\n+  } while (0)\n+\n+#ifdef REG_OK_STRICT\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    if (sh_legitimate_address_p ((MODE), (X), true))\t\\\n+      goto LABEL;\t\t\t\t\t\\\n+  } while (0)\n+#else\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    if (sh_legitimate_address_p ((MODE), (X), false))\t\\\n+      goto LABEL;\t\t\t\t\t\\\n+  } while (0)\n+#endif\n \f\n /* A C compound statement that attempts to replace X, which is an address\n    that needs reloading, with a valid memory address for an operand of"}]}