{"sha": "9b14fc3326e087975653b1af8ac54114041cde51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIxNGZjMzMyNmUwODc5NzU2NTNiMWFmOGFjNTQxMTQwNDFjZGU1MQ==", "commit": {"author": {"name": "Feng Xue", "email": "fxue@os.amperecomputing.com", "date": "2019-12-02T06:37:30Z"}, "committer": {"name": "Feng Xue", "email": "fxue@gcc.gnu.org", "date": "2019-12-02T06:37:30Z"}, "message": "Enable recursive function versioning\n\n2019-12-02  Feng Xue <fxue@os.amperecomputing.com>\n\n        PR ipa/92133\n        * doc/invoke.texi (ipa-cp-max-recursive-depth): Document new option.\n        (ipa-cp-min-recursive-probability): Likewise.\n        * params.opt (ipa-cp-max-recursive-depth): New.\n        (ipa-cp-min-recursive-probability): Likewise.\n        * ipa-cp.c (ipcp_lattice<valtype>::add_value): Add two new parameters\n        val_p and unlimited.\n        (self_recursively_generated_p): New function.\n        (get_val_across_arith_op): Likewise.\n        (propagate_vals_across_arith_jfunc): Add constant propagation for\n        self-recursive function.\n        (incorporate_penalties): Do not penalize pure self-recursive function.\n        (good_cloning_opportunity_p): Dump node_is_self_scc flag.\n        (propagate_constants_topo): Set node_is_self_scc flag for cgraph node.\n        (get_info_about_necessary_edges): Relax hotness check for edge to\n        self-recursive function.\n        * ipa-prop.h (ipa_node_params): Add new field node_is_self_scc.\n\n2019-12-02  Feng Xue  <fxue@os.amperecomputing.com>\n\n        PR ipa/92133\n        * gcc.dg/ipa/ipa-clone-2.c: New test.\n\nFrom-SVN: r278893", "tree": {"sha": "7898f1998d7895c9f2958982aae053a808ebc318", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7898f1998d7895c9f2958982aae053a808ebc318"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b14fc3326e087975653b1af8ac54114041cde51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b14fc3326e087975653b1af8ac54114041cde51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b14fc3326e087975653b1af8ac54114041cde51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b14fc3326e087975653b1af8ac54114041cde51/comments", "author": {"login": "feng-xue-ampere", "id": 95893536, "node_id": "U_kgDOBbc4IA", "avatar_url": "https://avatars.githubusercontent.com/u/95893536?v=4", "gravatar_id": "", "url": "https://api.github.com/users/feng-xue-ampere", "html_url": "https://github.com/feng-xue-ampere", "followers_url": "https://api.github.com/users/feng-xue-ampere/followers", "following_url": "https://api.github.com/users/feng-xue-ampere/following{/other_user}", "gists_url": "https://api.github.com/users/feng-xue-ampere/gists{/gist_id}", "starred_url": "https://api.github.com/users/feng-xue-ampere/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/feng-xue-ampere/subscriptions", "organizations_url": "https://api.github.com/users/feng-xue-ampere/orgs", "repos_url": "https://api.github.com/users/feng-xue-ampere/repos", "events_url": "https://api.github.com/users/feng-xue-ampere/events{/privacy}", "received_events_url": "https://api.github.com/users/feng-xue-ampere/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4569f8b3652ae1e5ca353c24148b50c786b36c8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4569f8b3652ae1e5ca353c24148b50c786b36c8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4569f8b3652ae1e5ca353c24148b50c786b36c8b"}], "stats": {"total": 310, "additions": 283, "deletions": 27}, "files": [{"sha": "0765ee2be1201be8d72fd7079cea43591a1ea4c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b14fc3326e087975653b1af8ac54114041cde51/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b14fc3326e087975653b1af8ac54114041cde51/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b14fc3326e087975653b1af8ac54114041cde51", "patch": "@@ -1,3 +1,23 @@\n+2019-12-02  Feng Xue <fxue@os.amperecomputing.com>\n+\n+\tPR ipa/92133\n+\t* doc/invoke.texi (ipa-cp-max-recursive-depth): Document new option.\n+\t(ipa-cp-min-recursive-probability): Likewise.\n+\t* params.opt (ipa-cp-max-recursive-depth): New.\n+\t(ipa-cp-min-recursive-probability): Likewise.\n+\t* ipa-cp.c (ipcp_lattice<valtype>::add_value): Add two new parameters\n+\tval_p and unlimited.\n+\t(self_recursively_generated_p): New function.\n+\t(get_val_across_arith_op): Likewise.\n+\t(propagate_vals_across_arith_jfunc): Add constant propagation for\n+\tself-recursive function.\n+\t(incorporate_penalties): Do not penalize pure self-recursive function.\n+\t(good_cloning_opportunity_p): Dump node_is_self_scc flag.\n+\t(propagate_constants_topo): Set node_is_self_scc flag for cgraph node.\n+\t(get_info_about_necessary_edges): Relax hotness check for edge to\n+\tself-recursive function.\n+\t* ipa-prop.h (ipa_node_params): Add new field node_is_self_scc.\n+\n 2019-12-01  Sandra Loosemore  <sandra@codesourcery.com>\n \n \tPR target/92499"}, {"sha": "d165f31a865245770c324ef84671612471de0d48", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b14fc3326e087975653b1af8ac54114041cde51/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b14fc3326e087975653b1af8ac54114041cde51/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=9b14fc3326e087975653b1af8ac54114041cde51", "patch": "@@ -12035,6 +12035,13 @@ IPA-CP calculates its own score of cloning profitability heuristics\n and performs those cloning opportunities with scores that exceed\n @option{ipa-cp-eval-threshold}.\n \n+@item ipa-cp-max-recursive-depth\n+Maximum depth of recursive cloning for self-recursive function.\n+\n+@item ipa-cp-min-recursive-probability\n+Recursive cloning only when the probability of call being executed exceeds\n+the parameter.\n+\n @item ipa-cp-recursion-penalty\n Percentage penalty the recursive functions will receive when they\n are evaluated for cloning."}, {"sha": "693c7a2fdc51b1e1688e422d12b0e00f0f0071d0", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 194, "deletions": 27, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b14fc3326e087975653b1af8ac54114041cde51/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b14fc3326e087975653b1af8ac54114041cde51/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=9b14fc3326e087975653b1af8ac54114041cde51", "patch": "@@ -228,7 +228,9 @@ struct ipcp_lattice\n   inline bool set_contains_variable ();\n   bool add_value (valtype newval, cgraph_edge *cs,\n \t\t  ipcp_value<valtype> *src_val = NULL,\n-\t\t  int src_idx = 0, HOST_WIDE_INT offset = -1);\n+\t\t  int src_idx = 0, HOST_WIDE_INT offset = -1,\n+\t\t  ipcp_value<valtype> **val_p = NULL,\n+\t\t  bool unlimited = false);\n   void print (FILE * f, bool dump_sources, bool dump_benefits);\n };\n \n@@ -1817,22 +1819,32 @@ allocate_and_init_ipcp_value (ipa_polymorphic_call_context source)\n /* Try to add NEWVAL to LAT, potentially creating a new ipcp_value for it.  CS,\n    SRC_VAL SRC_INDEX and OFFSET are meant for add_source and have the same\n    meaning.  OFFSET -1 means the source is scalar and not a part of an\n-   aggregate.  */\n+   aggregate.  If non-NULL, VAL_P records address of existing or newly added\n+   ipcp_value.  UNLIMITED means whether value count should not exceed the limit\n+   given by PARAM_IPA_CP_VALUE_LIST_SIZE.  */\n \n template <typename valtype>\n bool\n ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n \t\t\t\t  ipcp_value<valtype> *src_val,\n-\t\t\t\t  int src_idx, HOST_WIDE_INT offset)\n+\t\t\t\t  int src_idx, HOST_WIDE_INT offset,\n+\t\t\t\t  ipcp_value<valtype> **val_p,\n+\t\t\t\t  bool unlimited)\n {\n-  ipcp_value<valtype> *val;\n+  ipcp_value<valtype> *val, *last_val = NULL;\n+\n+  if (val_p)\n+    *val_p = NULL;\n \n   if (bottom)\n     return false;\n \n-  for (val = values; val; val = val->next)\n+  for (val = values; val; last_val = val, val = val->next)\n     if (values_equal_for_ipcp_p (val->value, newval))\n       {\n+\tif (val_p)\n+\t  *val_p = val;\n+\n \tif (ipa_edge_within_scc (cs))\n \t  {\n \t    ipcp_value_source<valtype> *s;\n@@ -1847,7 +1859,7 @@ ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n \treturn false;\n       }\n \n-  if (values_count == param_ipa_cp_value_list_size)\n+  if (!unlimited && values_count == param_ipa_cp_value_list_size)\n     {\n       /* We can only free sources, not the values themselves, because sources\n \t of other values in this SCC might point to them.   */\n@@ -1860,19 +1872,88 @@ ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n \t      ipcp_sources_pool.remove ((ipcp_value_source<tree>*)src);\n \t    }\n \t}\n-\n       values = NULL;\n       return set_to_bottom ();\n     }\n \n   values_count++;\n   val = allocate_and_init_ipcp_value (newval);\n   val->add_source (cs, src_val, src_idx, offset);\n-  val->next = values;\n-  values = val;\n+  val->next = NULL;\n+\n+  /* Add the new value to end of value list, which can reduce iterations\n+     of propagation stage for recursive function.  */\n+  if (last_val)\n+    last_val->next = val;\n+  else\n+    values = val;\n+\n+  if (val_p)\n+    *val_p = val;\n+\n+  return true;\n+}\n+\n+/* Return true, if a ipcp_value VAL is orginated from parameter value of\n+   self-feeding recursive function by applying non-passthrough arithmetic\n+   transformation.  */\n+\n+static bool\n+self_recursively_generated_p (ipcp_value<tree> *val)\n+{\n+  class ipa_node_params *info = NULL;\n+\n+  for (ipcp_value_source<tree> *src = val->sources; src; src = src->next)\n+    {\n+      cgraph_edge *cs = src->cs;\n+\n+      if (!src->val || cs->caller != cs->callee->function_symbol ()\n+\t  || src->val == val)\n+\treturn false;\n+\n+      if (!info)\n+\tinfo = IPA_NODE_REF (cs->caller);\n+\n+      class ipcp_param_lattices *plats = ipa_get_parm_lattices (info,\n+\t\t\t\t\t\t\t\tsrc->index);\n+      ipcp_lattice<tree> *src_lat = src->offset == -1 ? &plats->itself\n+\t\t\t\t\t\t      : plats->aggs;\n+      ipcp_value<tree> *src_val;\n+\n+      for (src_val = src_lat->values; src_val; src_val = src_val->next)\n+\tif (src_val == val)\n+\t  break;\n+\n+      if (!src_val)\n+\treturn false;\n+    }\n+\n   return true;\n }\n \n+/* A helper function that returns result of operation specified by OPCODE on\n+   the value of SRC_VAL.  If non-NULL, OPND1_TYPE is expected type for the\n+   value of SRC_VAL.  If the operation is binary, OPND2 is a constant value\n+   acting as its second operand.  If non-NULL, RES_TYPE is expected type of\n+   the result.  */\n+\n+static tree\n+get_val_across_arith_op (enum tree_code opcode,\n+\t\t\t tree opnd1_type,\n+\t\t\t tree opnd2,\n+\t\t\t ipcp_value<tree> *src_val,\n+\t\t\t tree res_type)\n+{\n+  tree opnd1 = src_val->value;\n+\n+  /* Skip source values that is incompatible with specified type.  */\n+  if (opnd1_type\n+      && !useless_type_conversion_p (opnd1_type, TREE_TYPE (opnd1)))\n+    return NULL_TREE;\n+\n+  return ipa_get_jf_arith_result (opcode, opnd1, opnd2, res_type);\n+}\n+\n /* Propagate values through an arithmetic transformation described by a jump\n    function associated with edge CS, taking values from SRC_LAT and putting\n    them into DEST_LAT.  OPND1_TYPE is expected type for the values in SRC_LAT.\n@@ -1896,24 +1977,76 @@ propagate_vals_across_arith_jfunc (cgraph_edge *cs,\n   ipcp_value<tree> *src_val;\n   bool ret = false;\n \n-  /* Do not create new values when propagating within an SCC because if there\n-     are arithmetic functions with circular dependencies, there is infinite\n-     number of them and we would just make lattices bottom.  If this condition\n-     is ever relaxed we have to detect self-feeding recursive calls in\n-     cgraph_edge_brings_value_p in a smarter way.  */\n+  /* Due to circular dependencies, propagating within an SCC through arithmetic\n+     transformation would create infinite number of values.  But for\n+     self-feeding recursive function, we could allow propagation in a limited\n+     count, and this can enable a simple kind of recursive function versioning.\n+     For other scenario, we would just make lattices bottom.  */\n   if (opcode != NOP_EXPR && ipa_edge_within_scc (cs))\n-    ret = dest_lat->set_contains_variable ();\n+    {\n+      int i;\n+\n+      if (src_lat != dest_lat || param_ipa_cp_max_recursive_depth < 1)\n+\treturn dest_lat->set_contains_variable ();\n+\n+      /* No benefit if recursive execution is in low probability.  */\n+      if (cs->sreal_frequency () * 100\n+\t  <= ((sreal) 1) * param_ipa_cp_min_recursive_probability)\n+\treturn dest_lat->set_contains_variable ();\n+\n+      auto_vec<ipcp_value<tree> *, 8> val_seeds;\n+\n+      for (src_val = src_lat->values; src_val; src_val = src_val->next)\n+\t{\n+\t  /* Now we do not use self-recursively generated value as propagation\n+\t     source, this is absolutely conservative, but could avoid explosion\n+\t     of lattice's value space, especially when one recursive function\n+\t     calls another recursive.  */\n+\t  if (self_recursively_generated_p (src_val))\n+\t    {\n+\t      ipcp_value_source<tree> *s;\n+\n+\t      /* If the lattice has already been propagated for the call site,\n+\t\t no need to do that again.  */\n+\t      for (s = src_val->sources; s; s = s->next)\n+\t\tif (s->cs == cs)\n+\t\t  return dest_lat->set_contains_variable ();\n+\t    }\n+\t  else\n+\t    val_seeds.safe_push (src_val);\n+\t}\n+\n+      /* Recursively generate lattice values with a limited count.  */\n+      FOR_EACH_VEC_ELT (val_seeds, i, src_val)\n+\t{\n+\t  for (int j = 1; j < param_ipa_cp_max_recursive_depth; j++)\n+\t    {\n+\t      tree cstval = get_val_across_arith_op (opcode, opnd1_type, opnd2,\n+\t\t\t\t\t\t     src_val, res_type);\n+\t      if (!cstval)\n+\t\tbreak;\n+\n+\t      ret |= dest_lat->add_value (cstval, cs, src_val, src_idx,\n+\t\t\t\t\t  src_offset, &src_val, true);\n+\t      gcc_checking_assert (src_val);\n+\t    }\n+\t}\n+      ret |= dest_lat->set_contains_variable ();\n+    }\n   else\n     for (src_val = src_lat->values; src_val; src_val = src_val->next)\n       {\n-\ttree opnd1 = src_val->value;\n-\ttree cstval = NULL_TREE;\n-\n-\t/* Skip source values that is incompatible with specified type.  */\n-\tif (!opnd1_type\n-\t    || useless_type_conversion_p (opnd1_type, TREE_TYPE (opnd1)))\n-\t  cstval = ipa_get_jf_arith_result (opcode, opnd1, opnd2, res_type);\n+\t/* Now we do not use self-recursively generated value as propagation\n+\t   source, otherwise it is easy to make value space of normal lattice\n+\t   overflow.  */\n+\tif (self_recursively_generated_p (src_val))\n+\t  {\n+\t    ret |= dest_lat->set_contains_variable ();\n+\t    continue;\n+\t  }\n \n+\ttree cstval = get_val_across_arith_op (opcode, opnd1_type, opnd2,\n+\t\t\t\t\t       src_val, res_type);\n \tif (cstval)\n \t  ret |= dest_lat->add_value (cstval, cs, src_val, src_idx,\n \t\t\t\t      src_offset);\n@@ -3038,7 +3171,7 @@ hint_time_bonus (ipa_hints hints)\n static inline int64_t\n incorporate_penalties (ipa_node_params *info, int64_t evaluation)\n {\n-  if (info->node_within_scc)\n+  if (info->node_within_scc && !info->node_is_self_scc)\n     evaluation = (evaluation\n \t\t  * (100 - param_ipa_cp_recursion_penalty)) / 100;\n \n@@ -3082,7 +3215,8 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n \t  count_sum.dump (dump_file);\n \t  fprintf (dump_file, \"%s%s) -> evaluation: \" \"%\" PRId64\n \t\t \", threshold: %i\\n\",\n-\t\t info->node_within_scc ? \", scc\" : \"\",\n+\t\t info->node_within_scc\n+\t\t   ? (info->node_is_self_scc ? \", self_scc\" : \", scc\") : \"\",\n \t\t info->node_calling_single_call ? \", single_call\" : \"\",\n \t\t evaluation, param_ipa_cp_eval_threshold);\n \t}\n@@ -3100,7 +3234,8 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n \t\t \"size: %i, freq_sum: %i%s%s) -> evaluation: \"\n \t\t \"%\" PRId64 \", threshold: %i\\n\",\n \t\t time_benefit, size_cost, freq_sum,\n-\t\t info->node_within_scc ? \", scc\" : \"\",\n+\t\t info->node_within_scc\n+\t\t   ? (info->node_is_self_scc ? \", self_scc\" : \", scc\") : \"\",\n \t\t info->node_calling_single_call ? \", single_call\" : \"\",\n \t\t evaluation, param_ipa_cp_eval_threshold);\n \n@@ -3594,14 +3729,30 @@ propagate_constants_topo (class ipa_topo_info *topo)\n       while (v)\n \t{\n \t  struct cgraph_edge *cs;\n+\t  class ipa_node_params *info = NULL;\n+\t  bool self_scc = true;\n \n \t  for (cs = v->callees; cs; cs = cs->next_callee)\n \t    if (ipa_edge_within_scc (cs))\n \t      {\n-\t\tIPA_NODE_REF (v)->node_within_scc = true;\n+\t\tcgraph_node *callee = cs->callee->function_symbol ();\n+\n+\t\tif (v != callee)\n+\t\t  self_scc = false;\n+\n+\t\tif (!info)\n+\t\t  {\n+\t\t    info = IPA_NODE_REF (v);\n+\t\t    info->node_within_scc = true;\n+\t\t  }\n+\n \t\tif (propagate_constants_across_call (cs))\n-\t\t  push_node_to_stack (topo, cs->callee->function_symbol ());\n+\t\t  push_node_to_stack (topo, callee);\n \t      }\n+\n+\t  if (info)\n+\t    info->node_is_self_scc = self_scc;\n+\n \t  v = pop_node_from_stack (topo);\n \t}\n \n@@ -3983,6 +4134,9 @@ get_info_about_necessary_edges (ipcp_value<valtype> *val, cgraph_node *dest,\n \t      hot |= cs->maybe_hot_p ();\n \t      if (cs->caller != dest)\n \t\tnon_self_recursive = true;\n+\t      else if (src->val)\n+\t\tgcc_assert (values_equal_for_ipcp_p (src->val->value,\n+\t\t\t\t\t\t     val->value));\n \t    }\n \t  cs = get_next_cgraph_edge_clone (cs);\n \t}\n@@ -3996,6 +4150,19 @@ get_info_about_necessary_edges (ipcp_value<valtype> *val, cgraph_node *dest,\n   *freq_sum = freq;\n   *count_sum = cnt;\n   *caller_count = count;\n+\n+  if (!hot && IPA_NODE_REF (dest)->node_within_scc)\n+    {\n+      struct cgraph_edge *cs;\n+\n+      /* Cold non-SCC source edge could trigger hot recursive execution of\n+\t function. Consider the case as hot and rely on following cost model\n+\t computation to further select right one.  */\n+      for (cs = dest->callers; cs; cs = cs->next_caller)\n+\tif (cs->caller == dest && cs->maybe_hot_p ())\n+\t  return true;\n+    }\n+\n   return hot;\n }\n "}, {"sha": "1958e1ee9cc37490f4871802ca6aff5846be2624", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b14fc3326e087975653b1af8ac54114041cde51/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b14fc3326e087975653b1af8ac54114041cde51/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=9b14fc3326e087975653b1af8ac54114041cde51", "patch": "@@ -497,6 +497,8 @@ class GTY((for_user)) ipa_node_params\n   unsigned node_dead : 1;\n   /* Node is involved in a recursion, potentionally indirect.  */\n   unsigned node_within_scc : 1;\n+  /* Node contains only direct recursion.  */\n+  unsigned node_is_self_scc : 1;\n   /* Node is calling a private function called only once.  */\n   unsigned node_calling_single_call : 1;\n   /* False when there is something makes versioning impossible.  */"}, {"sha": "d88ae0c468b57975f4ed348243bfc64b63912542", "filename": "gcc/params.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b14fc3326e087975653b1af8ac54114041cde51/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b14fc3326e087975653b1af8ac54114041cde51/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=9b14fc3326e087975653b1af8ac54114041cde51", "patch": "@@ -198,6 +198,14 @@ Threshold ipa-cp opportunity evaluation that is still considered beneficial to c\n Common Joined UInteger Var(param_ipa_cp_loop_hint_bonus) Init(64) Param\n Compile-time bonus IPA-CP assigns to candidates which make loop bounds or strides known.\n \n+-param=ipa-cp-max-recursive-depth=\n+Common Joined UInteger Var(param_ipa_cp_max_recursive_depth) Init(8) Param\n+Maximum depth of recursive cloning for self-recursive function.\n+\n+-param=ipa-cp-min-recursive-probability=\n+Common Joined UInteger Var(param_ipa_cp_min_recursive_probability) Init(2) Param\n+Recursive cloning only when the probability of call being executed exceeds the parameter.\n+\n -param=ipa-cp-recursion-penalty=\n Common Joined UInteger Var(param_ipa_cp_recursion_penalty) Init(40) IntegerRange(0, 100) Param\n Percentage penalty the recursive functions will receive when they are evaluated for cloning."}, {"sha": "bb36544cfe4383d0f3cb16997190e71600a847db", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b14fc3326e087975653b1af8ac54114041cde51/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b14fc3326e087975653b1af8ac54114041cde51/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9b14fc3326e087975653b1af8ac54114041cde51", "patch": "@@ -1,3 +1,8 @@\n+2019-12-02  Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\tPR ipa/92133\n+\t* gcc.dg/ipa/ipa-clone-2.c: New test.\n+\n 2019-12-01  Sandra Loosemore  <sandra@codesourcery.com>\n \n \tPR target/92499"}, {"sha": "d513020ee8bcacbfef01c63a15ac2eade77a6cc1", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-clone-2.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b14fc3326e087975653b1af8ac54114041cde51/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-clone-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b14fc3326e087975653b1af8ac54114041cde51/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-clone-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-clone-2.c?ref=9b14fc3326e087975653b1af8ac54114041cde51", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-ipa-cp-details -fno-early-inlining --param ipa-cp-max-recursive-depth=8\" } */\n+\n+int fn();\n+\n+int data[100];\n+\n+int recur_fn (int i)\n+{\n+  int j;\n+   \n+  if (i == 6)\n+    {\n+      fn();\n+      fn();\n+      fn();\n+      fn();\n+      fn();\n+      fn();\n+      fn();\n+      fn();\n+      fn();\n+      fn();\n+      fn();\n+      fn();\n+      return 10;\n+    }\n+\n+  data[i] = i; \n+\n+  for (j = 0; j < 100; j++)\n+    recur_fn (i + 1);\n+\n+  return i; \n+}\n+\n+int main ()\n+{\n+  int i;\n+\n+  for (i = 0; i < 100; i++)\n+    recur_fn (1) + recur_fn (-5);\n+\n+  return 1;\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of recur_fn/\\[0-9\\]*\\\\.\" 12 \"cp\" } } */"}]}