{"sha": "9350b3733aef7c93ccd3b50d610e2831016db02b", "node_id": "C_kwDOANBUbNoAKDkzNTBiMzczM2FlZjdjOTNjY2QzYjUwZDYxMGUyODMxMDE2ZGIwMmI", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-08-09T11:39:34Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:27Z"}, "message": "rust constexpr: conttinue porting cxx_eval_builtin_function_call\n\nSigned-off-by: Faisal Abbas <90.abbasfaisal@gmail.com>", "tree": {"sha": "fa06f838eabaaeb0ce7f251095884625d4c7ba93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa06f838eabaaeb0ce7f251095884625d4c7ba93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9350b3733aef7c93ccd3b50d610e2831016db02b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9350b3733aef7c93ccd3b50d610e2831016db02b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9350b3733aef7c93ccd3b50d610e2831016db02b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9350b3733aef7c93ccd3b50d610e2831016db02b/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c53bc4fc8f687bc44f26b1dfd51a6e4745ef09c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c53bc4fc8f687bc44f26b1dfd51a6e4745ef09c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c53bc4fc8f687bc44f26b1dfd51a6e4745ef09c"}], "stats": {"total": 235, "additions": 232, "deletions": 3}, "files": [{"sha": "e41d184cf711b395d99c6e24356be32e93414371", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9350b3733aef7c93ccd3b50d610e2831016db02b/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9350b3733aef7c93ccd3b50d610e2831016db02b/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=9350b3733aef7c93ccd3b50d610e2831016db02b", "patch": "@@ -32,6 +32,7 @@\n #include \"vec.h\"\n #include \"rust-target.h\"\n #include \"function.h\"\n+#include \"builtins.h\"\n \n #define VERIFY_CONSTANT(X)                                                     \\\n   do                                                                           \\"}, {"sha": "7f622cbbeb5cb417e222d1475272e689d4780e8e", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 209, "deletions": 3, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9350b3733aef7c93ccd3b50d610e2831016db02b/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9350b3733aef7c93ccd3b50d610e2831016db02b/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=9350b3733aef7c93ccd3b50d610e2831016db02b", "patch": "@@ -4883,7 +4883,7 @@ fold_builtin_source_location (location_t loc)\n   return build_fold_addr_expr_with_type_loc (loc, var, const_ptr_type_node);\n }\n \n-// forked from gcc/c-family.c-common.cc braced_lists_to_strings\n+// forked from gcc/c-family/c-common.cc braced_lists_to_strings\n \n /* Attempt to convert a braced array initializer list CTOR for array\n    TYPE into a STRING_CST for convenience and efficiency.  Return\n@@ -4986,7 +4986,7 @@ braced_list_to_string (tree type, tree ctor, bool member)\n   return res;\n }\n \n-// forked from gcc/c-family.c-common.cc braced_lists_to_strings\n+// forked from gcc/c-family/c-common.cc braced_lists_to_strings\n \n /* Implementation of the two-argument braced_lists_to_string withe\n    the same arguments plus MEMBER which is set for struct members\n@@ -5037,7 +5037,7 @@ braced_lists_to_strings (tree type, tree ctor, bool member)\n   return ctor;\n }\n \n-// forked from gcc/c-family.c-common.cc braced_lists_to_strings\n+// forked from gcc/c-family/c-common.cc braced_lists_to_strings\n \n /* Attempt to convert a CTOR containing braced array initializer lists\n    for array TYPE into one containing STRING_CSTs, for convenience and\n@@ -5051,4 +5051,210 @@ braced_lists_to_strings (tree type, tree ctor)\n   return braced_lists_to_strings (type, ctor, false);\n }\n \n+/*---------------------------------------------------------------------------\n+\t\t\tConstraint satisfaction\n+---------------------------------------------------------------------------*/\n+\n+// forked from gcc/cp/constraint.cc satisfying_constraint\n+\n+/* True if we are currently satisfying a failed_type_completions.  */\n+\n+static bool satisfying_constraint;\n+\n+// forked from gcc/cp/constraint.cc satisfying_constraint\n+\n+/* A vector of incomplete types (and of declarations with undeduced return\n+   type), appended to by note_failed_type_completion_for_satisfaction.  The\n+   satisfaction caches use this in order to keep track of \"potentially unstable\"\n+   satisfaction results.\n+\n+   Since references to entries in this vector are stored only in the\n+   GC-deletable sat_cache, it's safe to make this deletable as well.  */\n+\n+static GTY ((deletable)) vec<tree, va_gc> *failed_type_completions;\n+\n+// forked from gcc/cp/constraint.cc note_failed_type_completion_for_satisfaction\n+\n+/* Called whenever a type completion (or return type deduction) failure occurs\n+   that definitely affects the meaning of the program, by e.g. inducing\n+   substitution failure.  */\n+\n+void\n+note_failed_type_completion_for_satisfaction (tree t)\n+{\n+  if (satisfying_constraint)\n+    {\n+      gcc_checking_assert ((TYPE_P (t) && !COMPLETE_TYPE_P (t))\n+\t\t\t   || (DECL_P (t) && undeduced_auto_decl (t)));\n+      vec_safe_push (failed_type_completions, t);\n+    }\n+}\n+\n+// forked from gcc/cp/typeck.cc complete_type\n+\n+/* Try to complete TYPE, if it is incomplete.  For example, if TYPE is\n+   a template instantiation, do the instantiation.  Returns TYPE,\n+   whether or not it could be completed, unless something goes\n+   horribly wrong, in which case the error_mark_node is returned.  */\n+\n+tree\n+complete_type (tree type)\n+{\n+  if (type == NULL_TREE)\n+    /* Rather than crash, we return something sure to cause an error\n+       at some point.  */\n+    return error_mark_node;\n+\n+  if (type == error_mark_node || COMPLETE_TYPE_P (type))\n+    ;\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      tree t = complete_type (TREE_TYPE (type));\n+      unsigned int needs_constructing, has_nontrivial_dtor;\n+      if (COMPLETE_TYPE_P (t))\n+\tlayout_type (type);\n+      needs_constructing = TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (t));\n+      has_nontrivial_dtor\n+\t= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TYPE_MAIN_VARIANT (t));\n+      for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n+\t{\n+\t  TYPE_NEEDS_CONSTRUCTING (t) = needs_constructing;\n+\t  TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) = has_nontrivial_dtor;\n+\t}\n+    }\n+\n+  return type;\n+}\n+\n+// forked from gcc/cp/typeck.cc complete_type_or_maybe_complain\n+\n+/* Like complete_type, but issue an error if the TYPE cannot be completed.\n+   VALUE is used for informative diagnostics.\n+   Returns NULL_TREE if the type cannot be made complete.  */\n+\n+tree\n+complete_type_or_maybe_complain (tree type, tree value, tsubst_flags_t complain)\n+{\n+  type = complete_type (type);\n+  if (type == error_mark_node)\n+    /* We already issued an error.  */\n+    return NULL_TREE;\n+  else if (!COMPLETE_TYPE_P (type))\n+    {\n+      if (complain & tf_error)\n+\tcxx_incomplete_type_diagnostic (value, type, DK_ERROR);\n+      note_failed_type_completion_for_satisfaction (type);\n+      return NULL_TREE;\n+    }\n+  else\n+    return type;\n+}\n+\n+// forked from gcc/cp/typeck.cc complete_type_or_else\n+\n+tree\n+complete_type_or_else (tree type, tree value)\n+{\n+  return complete_type_or_maybe_complain (type, value, tf_warning_or_error);\n+}\n+\n+// forked from gcc/cp/tree.cc std_layout_type_p\n+\n+/* Returns true iff T is a standard-layout type, as defined in\n+   [basic.types].  */\n+\n+bool\n+std_layout_type_p (const_tree t)\n+{\n+  t = strip_array_types (CONST_CAST_TREE (t));\n+\n+  if (CLASS_TYPE_P (t))\n+    return !CLASSTYPE_NON_STD_LAYOUT (t);\n+  else\n+    return scalarish_type_p (t);\n+}\n+\n+// forked from /gcc/cp/semantics.cc first_nonstatic_data_member_p\n+\n+/* Helper function for fold_builtin_is_pointer_inverconvertible_with_class,\n+   return true if MEMBERTYPE is the type of the first non-static data member\n+   of TYPE or for unions of any members.  */\n+static bool\n+first_nonstatic_data_member_p (tree type, tree membertype)\n+{\n+  for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+    {\n+      if (TREE_CODE (field) != FIELD_DECL)\n+\tcontinue;\n+      if (DECL_FIELD_IS_BASE (field) && is_empty_field (field))\n+\tcontinue;\n+      if (DECL_FIELD_IS_BASE (field))\n+\treturn first_nonstatic_data_member_p (TREE_TYPE (field), membertype);\n+      if (ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n+\t{\n+\t  if ((TREE_CODE (TREE_TYPE (field)) == UNION_TYPE\n+\t       || std_layout_type_p (TREE_TYPE (field)))\n+\t      && first_nonstatic_data_member_p (TREE_TYPE (field), membertype))\n+\t    return true;\n+\t}\n+      else if (same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (field),\n+\t\t\t\t\t\t\t  membertype))\n+\treturn true;\n+      if (TREE_CODE (type) != UNION_TYPE)\n+\treturn false;\n+    }\n+  return false;\n+}\n+\n+// forked from gcc/cp/semantics.cc\n+// fold_builtin_is_pointer_inverconvertible_with_class\n+\n+/* Fold __builtin_is_pointer_interconvertible_with_class call.  */\n+\n+tree\n+fold_builtin_is_pointer_inverconvertible_with_class (location_t loc, int nargs,\n+\t\t\t\t\t\t     tree *args)\n+{\n+  /* Unless users call the builtin directly, the following 3 checks should be\n+     ensured from std::is_pointer_interconvertible_with_class function\n+     template.  */\n+  if (nargs != 1)\n+    {\n+      error_at (loc, \"%<__builtin_is_pointer_interconvertible_with_class%> \"\n+\t\t     \"needs a single argument\");\n+      return boolean_false_node;\n+    }\n+  tree arg = args[0];\n+  if (error_operand_p (arg))\n+    return boolean_false_node;\n+  if (!TYPE_PTRMEM_P (TREE_TYPE (arg)))\n+    {\n+      error_at (loc, \"%<__builtin_is_pointer_interconvertible_with_class%> \"\n+\t\t     \"argument is not pointer to member\");\n+      return boolean_false_node;\n+    }\n+\n+  if (!TYPE_PTRDATAMEM_P (TREE_TYPE (arg)))\n+    return boolean_false_node;\n+\n+  tree membertype = TREE_TYPE (TREE_TYPE (arg));\n+  tree basetype = TYPE_OFFSET_BASETYPE (TREE_TYPE (arg));\n+  if (!complete_type_or_else (basetype, NULL_TREE))\n+    return boolean_false_node;\n+\n+  if (TREE_CODE (basetype) != UNION_TYPE && !std_layout_type_p (basetype))\n+    return boolean_false_node;\n+\n+  if (!first_nonstatic_data_member_p (basetype, membertype))\n+    return boolean_false_node;\n+\n+  if (integer_nonzerop (arg))\n+    return boolean_false_node;\n+  if (integer_zerop (arg))\n+    return boolean_true_node;\n+\n+  return fold_build2 (EQ_EXPR, boolean_type_node, arg,\n+\t\t      build_zero_cst (TREE_TYPE (arg)));\n+}\n+\n } // namespace Rust"}, {"sha": "3fd9484d47d4b45b54e38e16a702e29bd5655736", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9350b3733aef7c93ccd3b50d610e2831016db02b/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9350b3733aef7c93ccd3b50d610e2831016db02b/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=9350b3733aef7c93ccd3b50d610e2831016db02b", "patch": "@@ -1297,6 +1297,28 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n    if an initializer has been.  */\n #define DECL_IN_AGGR_P(NODE) (DECL_LANG_FLAG_3 (NODE))\n \n+/* Nonzero means that this class type is a non-standard-layout class.  */\n+#define CLASSTYPE_NON_STD_LAYOUT(NODE)                                         \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->non_std_layout)\n+\n+/* Nonzero for FIELD_DECL node means that this field is a base class\n+   of the parent object, as opposed to a member field.  */\n+#define DECL_FIELD_IS_BASE(NODE) DECL_LANG_FLAG_6 (FIELD_DECL_CHECK (NODE))\n+\n+/* Nonzero if TYPE is an anonymous union type.  */\n+#define ANON_UNION_TYPE_P(NODE)                                                \\\n+  (TREE_CODE (NODE) == UNION_TYPE && ANON_AGGR_TYPE_P (NODE))\n+\n+/* For an ANON_AGGR_TYPE_P the single FIELD_DECL it is used with.  */\n+#define ANON_AGGR_TYPE_FIELD(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->typeinfo_var)\n+\n+/* Nonzero if TYPE is an anonymous union or struct type.  We have to use a\n+   flag for this because \"A union for which objects or pointers are\n+   declared is not an anonymous union\" [class.union].  */\n+#define ANON_AGGR_TYPE_P(NODE)                                                 \\\n+  (CLASS_TYPE_P (NODE) && LANG_TYPE_CLASS_CHECK (NODE)->anon_aggr)\n+#define SET_ANON_AGGR_TYPE_P(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->anon_aggr = 1)\n+\n #if defined ENABLE_TREE_CHECKING\n \n #define LANG_DECL_MIN_CHECK(NODE)                                              \\"}]}