{"sha": "adf39f8f5f2e1c877fe6b02654e673875c34ddac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRmMzlmOGY1ZjJlMWM4NzdmZTZiMDI2NTRlNjczODc1YzM0ZGRhYw==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2004-08-12T17:40:02Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-08-12T17:40:02Z"}, "message": "s390.c (struct s390_frame_layout): New struct as element of struct machine_function.\n\n2004-08-12  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* config/s390/s390.c (struct s390_frame_layout): New struct as element\n\tof struct machine_function.\n\t(cfun->machine->frame_size): Moved into cfun->machine->frame_layout and\n\tchanged all uses.\n\t(cfun->machine->save_fprs_p): Replaced by cfun_save_high_fprs and\n\tchanged all uses.\n\t(cfun_frame_layout, cfun_save_high_fprs_p, cfun_gprs_save_area_size)\n\t(cfun_set_fpr_bit, cfun_fpr_bit_p): New macros.\n\t(s390_frame_area, s390_register_info): New functions.\n\t(s390_optimize_prolog): Renamed to s390_optimize_prologue.  Added check\n\tfor base register.\n\t(s390_return_addr_rtx, s390_return_address_offset)\n\t(s390_va_start, s390_gimplify_va_arg)\n\t(s390_emit_prologue, s390_emit_epilogue): Adjusted for new stack\n\tlayouts.\n\t(s390_frame_info): Functionality partly moved to s390_register_info.\n\tMade adaptions for new stack layout.\n\t(save_gprs, restore_gprs): Changed meaning of second parameter and\n\tadapted all callers.\n\n\t* config/s390/s390.h (s390_backchain_string): New global variable.\n\t(MASK_BACKCHAIN): Removed definition.\n\t(TARGET_BACKCHAIN): Changed check.\n\t(TARGET_KERNEL_BACKCHAIN): New macro.\n\t(TARGET_SWITCHES): Removed entries of \"backchain\" and \"no-backchain\".\n\t(TARGET_OPTIONS): Added \"backchain\", \"no-backchain\" and\n\t\"kernel-backchain\".\n\t(DYNAMIC_CHAIN_ADDRESS): Adjusted for new stack layouts.\n\n\t* config/s390/s390.md (\"allocate_stack\"): Added TARGET_KERNEL_BACKCHAIN\n\tas condition.  Adjusted for new stack layout.\n\n\t* doc/invoke.texi: Added documentation for new option\n\t\"-mkernel-backchain\" and adjusted documentation of \"-mbackchain\" and\n\t\"-mno-backchain\".\n\nFrom-SVN: r85882", "tree": {"sha": "e8ce9fc539d0dad49e39d09c25cb74577820e859", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8ce9fc539d0dad49e39d09c25cb74577820e859"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adf39f8f5f2e1c877fe6b02654e673875c34ddac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adf39f8f5f2e1c877fe6b02654e673875c34ddac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adf39f8f5f2e1c877fe6b02654e673875c34ddac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adf39f8f5f2e1c877fe6b02654e673875c34ddac/comments", "author": null, "committer": null, "parents": [{"sha": "faa03cf1b40e800415540d92b100ad1e545c0d56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faa03cf1b40e800415540d92b100ad1e545c0d56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faa03cf1b40e800415540d92b100ad1e545c0d56"}], "stats": {"total": 784, "additions": 567, "deletions": 217}, "files": [{"sha": "6881fa6a5ec529779435c5aed8c0958c32470a95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf39f8f5f2e1c877fe6b02654e673875c34ddac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf39f8f5f2e1c877fe6b02654e673875c34ddac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=adf39f8f5f2e1c877fe6b02654e673875c34ddac", "patch": "@@ -1,3 +1,41 @@\n+2004-08-12  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* config/s390/s390.c (struct s390_frame_layout): New struct as element\n+\tof struct machine_function.\n+\t(cfun->machine->frame_size): Moved into cfun->machine->frame_layout and\n+\tchanged all uses.\n+\t(cfun->machine->save_fprs_p): Replaced by cfun_save_high_fprs and\n+\tchanged all uses.\n+\t(cfun_frame_layout, cfun_save_high_fprs_p, cfun_gprs_save_area_size)\n+\t(cfun_set_fpr_bit, cfun_fpr_bit_p): New macros.\n+\t(s390_frame_area, s390_register_info): New functions.\n+\t(s390_optimize_prolog): Renamed to s390_optimize_prologue.  Added check\n+\tfor base register.\n+\t(s390_return_addr_rtx, s390_return_address_offset)\n+\t(s390_va_start, s390_gimplify_va_arg)\n+\t(s390_emit_prologue, s390_emit_epilogue): Adjusted for new stack\n+\tlayouts.\n+\t(s390_frame_info): Functionality partly moved to s390_register_info.\n+\tMade adaptions for new stack layout.\n+\t(save_gprs, restore_gprs): Changed meaning of second parameter and\n+\tadapted all callers.\n+\n+\t* config/s390/s390.h (s390_backchain_string): New global variable.\n+\t(MASK_BACKCHAIN): Removed definition.\n+\t(TARGET_BACKCHAIN): Changed check.\n+\t(TARGET_KERNEL_BACKCHAIN): New macro.\n+\t(TARGET_SWITCHES): Removed entries of \"backchain\" and \"no-backchain\".\n+\t(TARGET_OPTIONS): Added \"backchain\", \"no-backchain\" and\n+\t\"kernel-backchain\".\n+\t(DYNAMIC_CHAIN_ADDRESS): Adjusted for new stack layouts.\n+\n+\t* config/s390/s390.md (\"allocate_stack\"): Added TARGET_KERNEL_BACKCHAIN\n+\tas condition.  Adjusted for new stack layout.\n+\n+\t* doc/invoke.texi: Added documentation for new option\n+\t\"-mkernel-backchain\" and adjusted documentation of \"-mbackchain\" and\n+\t\"-mno-backchain\".\n+\n 2004-08-12  Paul Brook  <paul@codesourcery.com>\n \n \t* config/arm/lib1funcs.asm (ARM_FUNC_ALIAS): Also alias _L__name."}, {"sha": "be3aeae59b4edaac0ccf1b456e308763f30d9486", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 480, "deletions": 201, "changes": 681, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf39f8f5f2e1c877fe6b02654e673875c34ddac/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf39f8f5f2e1c877fe6b02654e673875c34ddac/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=adf39f8f5f2e1c877fe6b02654e673875c34ddac", "patch": "@@ -200,24 +200,54 @@ enum processor_flags s390_arch_flags;\n const char *s390_tune_string;\t\t/* for -mtune=<xxx> */\n const char *s390_arch_string;\t\t/* for -march=<xxx> */\n \n-/* Define the structure for the machine field in struct function.  */\n-\n-struct machine_function GTY(())\n-{\n-  /* Set, if some of the fprs 8-15 need to be saved (64 bit abi).  */\n-  int save_fprs_p;\n-\n-  /* Set if return address needs to be saved.  */\n-  bool save_return_addr_p;\n-\n+/* String to specify backchain mode.  */\n+const char *s390_backchain_string = \"\"; /* \"\" no-backchain ,\"1\" backchain,\n+\t\t\t\t\t   \"2\" kernel-backchain */\n+\n+/* The following structure is embedded in the machine \n+   specific part of struct function.  */\n+\n+struct s390_frame_layout GTY (())\n+{\n+  /* Offset within stack frame.  */\n+  HOST_WIDE_INT gprs_offset;\n+  HOST_WIDE_INT f0_offset;\n+  HOST_WIDE_INT f4_offset;\n+  HOST_WIDE_INT f8_offset;\n+  HOST_WIDE_INT backchain_offset;\n+  \n   /* Number of first and last gpr to be saved, restored.  */\n   int first_save_gpr;\n   int first_restore_gpr;\n   int last_save_gpr;\n   int last_restore_gpr;\n \n+  /* Bits standing for floating point registers. Set, if the \n+     respective register has to be saved. Starting with reg 16 (f0) \n+     at the rightmost bit.\n+     Bit 15 -  8  7  6  5  4  3  2  1  0\n+     fpr 15 -  8  7  5  3  1  6  4  2  0\n+     reg 31 - 24 23 22 21 20 19 18 17 16  */\n+  unsigned int fpr_bitmap;\n+\n+  /* Number of floating point registers f8-f15 which must be saved.  */\n+  int high_fprs;\n+\n+  /* Set if return address needs to be saved.  */\n+  bool save_return_addr_p;\n+\n+  /* Set if backchain needs to be saved.  */\n+  bool save_backchain_p;\n+\n   /* Size of stack frame.  */\n   HOST_WIDE_INT frame_size;\n+};\n+\n+/* Define the structure for the machine field in struct function.  */\n+\n+struct machine_function GTY(())\n+{\n+  struct s390_frame_layout frame_layout;\n \n   /* Literal pool base register.  */\n   rtx base_reg;\n@@ -226,6 +256,17 @@ struct machine_function GTY(())\n   const char *some_ld_name;\n };\n \n+/* Few accessor macros for struct cfun->machine->s390_frame_layout.  */\n+\n+#define cfun_frame_layout (cfun->machine->frame_layout)\n+#define cfun_save_high_fprs_p (!!cfun_frame_layout.high_fprs)\n+#define cfun_gprs_save_area_size ((cfun_frame_layout.last_save_gpr -           \\\n+  cfun_frame_layout.first_save_gpr + 1) * UNITS_PER_WORD)\n+#define cfun_set_fpr_bit(BITNUM) (cfun->machine->frame_layout.fpr_bitmap |=    \\\n+  (1 << (BITNUM)))\n+#define cfun_fpr_bit_p(BITNUM) (!!(cfun->machine->frame_layout.fpr_bitmap &    \\\n+  (1 << (BITNUM))))\n+\n static int s390_match_ccmode_set (rtx, enum machine_mode);\n static int s390_branch_condition_mask (rtx);\n static const char *s390_branch_condition_mnemonic (rtx, int);\n@@ -246,8 +287,10 @@ static void find_constant_pool_ref (rtx, rtx *);\n static void replace_constant_pool_ref (rtx *, rtx, rtx);\n static rtx find_ltrel_base (rtx);\n static void replace_ltrel_base (rtx *);\n-static void s390_optimize_prolog (bool);\n+static void s390_optimize_prologue (bool);\n static int find_unused_clobbered_reg (void);\n+static void s390_frame_area (int *, int *);\n+static void s390_register_info (int, int);\n static void s390_frame_info (int, int);\n static rtx save_fpr (rtx, int, int);\n static rtx restore_fpr (rtx, int, int);\n@@ -4168,7 +4211,7 @@ s390_split_branches (void)\n \n       /* We are going to use the return register as scratch register,\n \t make sure it will be saved/restored by the prologue/epilogue.  */\n-      cfun->machine->save_return_addr_p = 1;\n+      cfun_frame_layout.save_return_addr_p = 1;\n \n       if (!flag_pic)\n \t{\n@@ -5333,33 +5376,33 @@ s390_output_pool_entry (rtx exp, enum machine_mode mode, unsigned int align)\n }\n \n \n-/* Rework the prolog/epilog to avoid saving/restoring\n+/* Rework the prologue/epilogue to avoid saving/restoring\n    registers unnecessarily.  BASE_USED specifies whether\n    the literal pool base register needs to be saved.  */\n \n static void\n-s390_optimize_prolog (bool base_used)\n+s390_optimize_prologue (bool base_used)\n {\n   rtx insn, new_insn, next_insn;\n \n   /* Do a final recompute of the frame-related data.  */\n \n-  s390_frame_info (base_used, cfun->machine->save_return_addr_p);\n+  s390_register_info (base_used, cfun_frame_layout.save_return_addr_p);\n   regs_ever_live[BASE_REGNUM] = base_used;\n-  regs_ever_live[RETURN_REGNUM] = cfun->machine->save_return_addr_p;\n-  regs_ever_live[STACK_POINTER_REGNUM] = cfun->machine->frame_size > 0;\n+  regs_ever_live[RETURN_REGNUM] = cfun_frame_layout.save_return_addr_p;\n+  regs_ever_live[STACK_POINTER_REGNUM] = cfun_frame_layout.frame_size > 0;\n \n   /* If all special registers are in fact used, there's nothing we\n      can do, so no point in walking the insn list.  */\n \n-  if (cfun->machine->first_save_gpr <= BASE_REGNUM \n-      && cfun->machine->last_save_gpr >= BASE_REGNUM\n+  if (cfun_frame_layout.first_save_gpr <= BASE_REGNUM \n+      && cfun_frame_layout.last_save_gpr >= BASE_REGNUM\n       && (TARGET_CPU_ZARCH \n-          || (cfun->machine->first_save_gpr <= RETURN_REGNUM \n-              && cfun->machine->last_save_gpr >= RETURN_REGNUM)))\n+          || (cfun_frame_layout.first_save_gpr <= RETURN_REGNUM \n+              && cfun_frame_layout.last_save_gpr >= RETURN_REGNUM)))\n     return;\n \n-  /* Search for prolog/epilog insns and replace them.  */\n+  /* Search for prologue/epilogue insns and replace them.  */\n \n   for (insn = get_insns (); insn; insn = next_insn)\n     {\n@@ -5379,17 +5422,23 @@ s390_optimize_prolog (bool base_used)\n \t  last = first + XVECLEN (PATTERN (insn), 0) - 1;\n \t  offset = const0_rtx;\n \t  base = eliminate_constant_term (XEXP (SET_DEST (set), 0), &offset);\n-\t  off = INTVAL (offset) - first * UNITS_PER_WORD;\n+\t  off = INTVAL (offset);\n \n \t  if (GET_CODE (base) != REG || off < 0)\n \t    continue;\n+\t  if (REGNO (base) != STACK_POINTER_REGNUM\n+\t      && REGNO (base) != HARD_FRAME_POINTER_REGNUM)\n+\t    continue;\n \t  if (first > BASE_REGNUM || last < BASE_REGNUM)\n \t    continue;\n \n-\t  if (cfun->machine->first_save_gpr != -1)\n+\t  if (cfun_frame_layout.first_save_gpr != -1)\n \t    {\n-\t      new_insn = save_gprs (base, off, cfun->machine->first_save_gpr,\n-\t\t\t\t    cfun->machine->last_save_gpr);\n+\t      new_insn \t= save_gprs (base, \n+\t\t\t\t     off + (cfun_frame_layout.first_save_gpr\n+\t\t\t\t\t    - first) * UNITS_PER_WORD, \n+\t\t\t\t     cfun_frame_layout.first_save_gpr,\n+\t\t\t\t     cfun_frame_layout.last_save_gpr);\n \t      new_insn = emit_insn_before (new_insn, insn);\n \t      INSN_ADDRESSES_NEW (new_insn, -1);\n \t    }\n@@ -5406,15 +5455,20 @@ s390_optimize_prolog (bool base_used)\n \t  set = PATTERN (insn);\n \t  offset = const0_rtx;\n \t  base = eliminate_constant_term (XEXP (SET_DEST (set), 0), &offset);\n-\t  off = INTVAL (offset) - BASE_REGNUM * UNITS_PER_WORD;\n+\t  off = INTVAL (offset);\n \n \t  if (GET_CODE (base) != REG || off < 0)\n \t    continue;\n-\n-\t  if (cfun->machine->first_save_gpr != -1)\n+\t  if (REGNO (base) != STACK_POINTER_REGNUM\n+\t      && REGNO (base) != HARD_FRAME_POINTER_REGNUM)\n+\t    continue;\n+\t  if (cfun_frame_layout.first_save_gpr != -1)\n \t    {\n-\t      new_insn = save_gprs (base, off, cfun->machine->first_save_gpr,\n-\t\t\t\t    cfun->machine->last_save_gpr);\n+\t      new_insn = save_gprs (base, \n+\t\t\t\t    off + (cfun_frame_layout.first_save_gpr \n+\t\t\t\t\t   - BASE_REGNUM) * UNITS_PER_WORD, \n+\t\t\t\t    cfun_frame_layout.first_save_gpr,\n+\t\t\t\t    cfun_frame_layout.last_save_gpr);\n \t      new_insn = emit_insn_before (new_insn, insn);\n \t      INSN_ADDRESSES_NEW (new_insn, -1);\n \t    }\n@@ -5431,17 +5485,23 @@ s390_optimize_prolog (bool base_used)\n \t  last = first + XVECLEN (PATTERN (insn), 0) - 1;\n \t  offset = const0_rtx;\n \t  base = eliminate_constant_term (XEXP (SET_SRC (set), 0), &offset);\n-\t  off = INTVAL (offset) - first * UNITS_PER_WORD;\n+\t  off = INTVAL (offset);\n \n \t  if (GET_CODE (base) != REG || off < 0)\n \t    continue;\n+\t  if (REGNO (base) != STACK_POINTER_REGNUM\n+\t      && REGNO (base) != HARD_FRAME_POINTER_REGNUM)\n+\t    continue;\n \t  if (first > BASE_REGNUM || last < BASE_REGNUM)\n \t    continue;\n \n-\t  if (cfun->machine->first_restore_gpr != -1)\n+\t  if (cfun_frame_layout.first_restore_gpr != -1)\n \t    {\n-\t      new_insn = restore_gprs (base, off, cfun->machine->first_restore_gpr,\n-\t\t\t\t       cfun->machine->last_restore_gpr);\n+\t      new_insn = restore_gprs (base, \n+\t\t\t\t       off + (cfun_frame_layout.first_restore_gpr\n+\t\t\t\t\t      - first) * UNITS_PER_WORD, \n+\t\t\t\t       cfun_frame_layout.first_restore_gpr,\n+\t\t\t\t       cfun_frame_layout.last_restore_gpr);\n \t      new_insn = emit_insn_before (new_insn, insn);\n \t      INSN_ADDRESSES_NEW (new_insn, -1);\n \t    }\n@@ -5458,15 +5518,20 @@ s390_optimize_prolog (bool base_used)\n \t  set = PATTERN (insn);\n \t  offset = const0_rtx;\n \t  base = eliminate_constant_term (XEXP (SET_SRC (set), 0), &offset);\n-\t  off = INTVAL (offset) - BASE_REGNUM * UNITS_PER_WORD;\n+\t  off = INTVAL (offset);\n \n \t  if (GET_CODE (base) != REG || off < 0)\n \t    continue;\n-\n-\t  if (cfun->machine->first_restore_gpr != -1)\n+\t  if (REGNO (base) != STACK_POINTER_REGNUM\n+\t      && REGNO (base) != HARD_FRAME_POINTER_REGNUM)\n+\t    continue;\n+\t  if (cfun_frame_layout.first_restore_gpr != -1)\n \t    {\n-\t      new_insn = restore_gprs (base, off, cfun->machine->first_restore_gpr,\n-\t\t\t\t       cfun->machine->last_restore_gpr);\n+\t      new_insn = restore_gprs (base, \n+\t\t\t\t       off + (cfun_frame_layout.first_restore_gpr \n+\t\t\t\t\t      - BASE_REGNUM) * UNITS_PER_WORD,\n+\t\t\t\t       cfun_frame_layout.first_restore_gpr,\n+\t\t\t\t       cfun_frame_layout.last_restore_gpr);\n \t      new_insn = emit_insn_before (new_insn, insn);\n \t      INSN_ADDRESSES_NEW (new_insn, -1);\n \t    }\n@@ -5567,7 +5632,7 @@ s390_reorg (void)\n       break;\n     }\n \n-  s390_optimize_prolog (base_used);\n+  s390_optimize_prologue (base_used);\n }\n \n \n@@ -5578,23 +5643,29 @@ s390_reorg (void)\n rtx\n s390_return_addr_rtx (int count, rtx frame ATTRIBUTE_UNUSED)\n {\n+  int offset;\n   rtx addr;\n \n   /* Without backchain, we fail for all but the current frame.  */\n \n-  if (!TARGET_BACKCHAIN && count > 0)\n+  if (!TARGET_BACKCHAIN && !TARGET_KERNEL_BACKCHAIN && count > 0)\n     return NULL_RTX;\n \n   /* For the current frame, we need to make sure the initial\n      value of RETURN_REGNUM is actually saved.  */\n \n   if (count == 0)\n     {\n-      cfun->machine->save_return_addr_p = true;\n+      cfun_frame_layout.save_return_addr_p = true;\n       return gen_rtx_MEM (Pmode, return_address_pointer_rtx);\n     }\n \n-  addr = plus_constant (frame, RETURN_REGNUM * UNITS_PER_WORD);\n+  if (TARGET_BACKCHAIN)\n+    offset = RETURN_REGNUM * UNITS_PER_WORD;\n+  else\n+    offset = -2 * UNITS_PER_WORD;\n+\n+  addr = plus_constant (frame, offset);\n   addr = memory_address (Pmode, addr);\n   return gen_rtx_MEM (Pmode, addr);\n }\n@@ -5613,41 +5684,69 @@ find_unused_clobbered_reg (void)\n   return 0;\n }\n \n-/* Fill cfun->machine with info about frame of current function.  \n-   BASE_USED and RETURN_ADDR_USED specify whether we assume the\n+/* Determine the frame area which actually has to be accessed \n+   in the function epilogue. The values are stored at the \n+   given pointers AREA_BOTTOM (address of the lowest used stack\n+   address) and AREA_TOP (address of the first item which does \n+   not belong to the stack frame).  */\n+\n+static void\n+s390_frame_area (int *area_bottom, int *area_top)\n+{\n+  int b, t;\n+  int i;\n+\n+  b = INT_MAX;\n+  t = INT_MIN;\n+\n+  if (cfun_frame_layout.first_restore_gpr != -1)\n+    {\n+      b = (cfun_frame_layout.gprs_offset\n+\t   + cfun_frame_layout.first_restore_gpr * UNITS_PER_WORD);\n+      t = b + (cfun_frame_layout.last_restore_gpr\n+\t       - cfun_frame_layout.first_restore_gpr + 1) * UNITS_PER_WORD;\n+    }\n+\n+  if (TARGET_64BIT && cfun_save_high_fprs_p)\n+    {\n+      b = MIN (b, cfun_frame_layout.f8_offset);\n+      t = MAX (t, (cfun_frame_layout.f8_offset\n+\t\t   + cfun_frame_layout.high_fprs * 8));\n+    }\n+\n+  if (!TARGET_64BIT)\n+    for (i = 2; i < 4; i++)\n+      if (cfun_fpr_bit_p (i))\n+\t{\n+\t  b = MIN (b, cfun_frame_layout.f4_offset + (i - 2) * 8);\n+\t  t = MAX (t, cfun_frame_layout.f4_offset + (i - 1) * 8);\n+\t}\n+  \n+  *area_bottom = b;\n+  *area_top = t;\n+}\n+\n+/* Fill cfun->machine with info about register usage of current \n+   function. BASE_USED and RETURN_ADDR_USED specify whether we assume the\n    base and return address register will need to be saved.  */\n \n static void\n-s390_frame_info (int base_used, int return_addr_used)\n+s390_register_info (int base_used, int return_addr_used)\n {\n   int live_regs[16];\n   int i, j;\n-  HOST_WIDE_INT fsize = get_frame_size ();\n-\n-  if (!TARGET_64BIT && fsize > 0x7fff0000)\n-    fatal_error (\"Total size of local variables exceeds architecture limit.\");\n \n-  /* fprs 8 - 15 are caller saved for 64 Bit ABI.  */\n-  cfun->machine->save_fprs_p = 0;\n+  /* fprs 8 - 15 are call saved for 64 Bit ABI.  */\n+  cfun_frame_layout.fpr_bitmap = 0;\n+  cfun_frame_layout.high_fprs = 0;\n   if (TARGET_64BIT)\n     for (i = 24; i < 32; i++)\n       if (regs_ever_live[i] && !global_regs[i])\n \t{\n-          cfun->machine->save_fprs_p = 1;\n-\t  break;\n+\t  cfun_set_fpr_bit (i - 16);\n+\t  cfun_frame_layout.high_fprs++;\n \t}\n \n-  cfun->machine->frame_size = fsize + cfun->machine->save_fprs_p * 64;\n-\n-  /* Does function need to setup frame and save area.  */\n-\n-  if (!current_function_is_leaf\n-      || TARGET_TPF_PROFILING\n-      || cfun->machine->frame_size > 0\n-      || current_function_calls_alloca\n-      || current_function_stdarg)\n-    cfun->machine->frame_size += STARTING_FRAME_OFFSET;\n-\n   /* Find first and last gpr to be saved.  We trust regs_ever_live\n      data, except that we don't save and restore global registers.\n \n@@ -5663,8 +5762,13 @@ s390_frame_info (int base_used, int return_addr_used)\n \n   live_regs[BASE_REGNUM] = base_used;\n   live_regs[RETURN_REGNUM] = return_addr_used;\n-  live_regs[STACK_POINTER_REGNUM] = cfun->machine->frame_size > 0;\n-\n+  live_regs[STACK_POINTER_REGNUM] = (!current_function_is_leaf\n+\t\t\t\t     || TARGET_TPF_PROFILING\n+\t\t\t\t     || cfun_save_high_fprs_p\n+\t\t\t\t     || get_frame_size () > 0\n+\t\t\t\t     || current_function_calls_alloca\n+\t\t\t\t     || current_function_stdarg);\n+  \n   for (i = 6; i < 16; i++)\n     if (live_regs[i])\n       break;\n@@ -5675,30 +5779,147 @@ s390_frame_info (int base_used, int return_addr_used)\n   if (i == 16)\n     {\n       /* Nothing to save/restore.  */\n-      cfun->machine->first_save_gpr = -1;\n-      cfun->machine->first_restore_gpr = -1;\n-      cfun->machine->last_save_gpr = -1;\n-      cfun->machine->last_restore_gpr = -1;\n+      cfun_frame_layout.first_save_gpr = -1;\n+      cfun_frame_layout.first_restore_gpr = -1;\n+      cfun_frame_layout.last_save_gpr = -1;\n+      cfun_frame_layout.last_restore_gpr = -1;\n     }\n   else\n     {\n       /* Save / Restore from gpr i to j.  */\n-      cfun->machine->first_save_gpr = i;\n-      cfun->machine->first_restore_gpr = i;\n-      cfun->machine->last_save_gpr = j;\n-      cfun->machine->last_restore_gpr = j;\n+      cfun_frame_layout.first_save_gpr = i;\n+      cfun_frame_layout.first_restore_gpr = i;\n+      cfun_frame_layout.last_save_gpr = j;\n+      cfun_frame_layout.last_restore_gpr = j;\n     }\n \n-  /* Varargs functions need to save gprs 2 to 6.  */\n   if (current_function_stdarg)\n     {\n-      if (cfun->machine->first_save_gpr == -1\n-          || cfun->machine->first_save_gpr > 2)\n-        cfun->machine->first_save_gpr = 2;\n+      /* Varargs functions need to save gprs 2 to 6.  */\n+      if (cfun_frame_layout.first_save_gpr == -1\n+          || cfun_frame_layout.first_save_gpr > 2)\n+        cfun_frame_layout.first_save_gpr = 2;\n+\n+      if (cfun_frame_layout.last_save_gpr == -1\n+          || cfun_frame_layout.last_save_gpr < 6)\n+        cfun_frame_layout.last_save_gpr = 6;\n+\n+      /* Mark f0, f2 for 31 bit and f0-f4 for 64 bit to be saved.  */\n+      for (i = 0; i < (TARGET_64BIT ? 4 : 2); i++)\n+\tcfun_set_fpr_bit (i);\n+    }\n+\n+  if (!TARGET_64BIT)\n+    for (i = 2; i < 4; i++)\n+      if (regs_ever_live[i + 16] && !global_regs[i + 16])\n+\tcfun_set_fpr_bit (i);\n+}\n+\n+/* Fill cfun->machine with info about frame of current \n+   function. BASE_USED and RETURN_ADDR_USED specify whether we assume the\n+   base and return address register will need to be saved.  */\n+\n+static void\n+s390_frame_info (int base_used, int return_addr_used)\n+{\n+  int i;\n+\n+  cfun_frame_layout.frame_size = get_frame_size ();\n+\n+  s390_register_info (base_used, return_addr_used);\n+\n+  if (!TARGET_64BIT && cfun_frame_layout.frame_size > 0x7fff0000)\n+    fatal_error (\"Total size of local variables exceeds architecture limit.\");\n+  \n+  cfun_frame_layout.save_backchain_p = (TARGET_BACKCHAIN \n+\t\t\t\t\t|| TARGET_KERNEL_BACKCHAIN);\n+\n+  if (TARGET_BACKCHAIN)\n+    {\n+      cfun_frame_layout.backchain_offset = 0;\n+      cfun_frame_layout.f0_offset = 16 * UNITS_PER_WORD;\n+      cfun_frame_layout.f4_offset = cfun_frame_layout.f0_offset + 2 * 8;\n+      cfun_frame_layout.f8_offset = -cfun_frame_layout.high_fprs * 8;\n+      cfun_frame_layout.gprs_offset = (cfun_frame_layout.first_save_gpr\n+\t\t\t\t       * UNITS_PER_WORD);\n+    }\n+  else if (TARGET_KERNEL_BACKCHAIN)\n+    {\n+      cfun_frame_layout.backchain_offset = (STACK_POINTER_OFFSET\n+\t\t\t\t\t    - UNITS_PER_WORD);\n+      cfun_frame_layout.gprs_offset \n+\t= (cfun_frame_layout.backchain_offset \n+\t   - (STACK_POINTER_REGNUM - cfun_frame_layout.first_save_gpr + 1)\n+\t   * UNITS_PER_WORD);\n+\t  \n+      if (TARGET_64BIT)\n+\t{\n+\t  cfun_frame_layout.f4_offset \n+\t    = (cfun_frame_layout.gprs_offset\n+\t       - 8 * (cfun_fpr_bit_p (2) + cfun_fpr_bit_p (3)));\n+\t  \n+\t  cfun_frame_layout.f0_offset \n+\t    = (cfun_frame_layout.f4_offset \n+\t       - 8 * (cfun_fpr_bit_p (0) + cfun_fpr_bit_p (1)));\n+\t}\n+      else\n+\t{\n+\t  cfun_frame_layout.f0_offset \n+\t    = (cfun_frame_layout.gprs_offset\n+\t       - 8 * (cfun_fpr_bit_p (0) + cfun_fpr_bit_p (1)));\n+\t  \n+\t  cfun_frame_layout.f4_offset \n+\t    = (cfun_frame_layout.f0_offset\n+\t       - 8 * (cfun_fpr_bit_p (2) + cfun_fpr_bit_p (3)));\n+\t}\n+    }\n+  else /* no backchain */\n+    {\n+      cfun_frame_layout.f4_offset \n+\t= (STACK_POINTER_OFFSET\n+\t   - 8 * (cfun_fpr_bit_p (2) + cfun_fpr_bit_p (3)));\n+      \n+      cfun_frame_layout.f0_offset \n+\t= (cfun_frame_layout.f4_offset\n+\t   - 8 * (cfun_fpr_bit_p (0) + cfun_fpr_bit_p (1)));\n+      \n+      cfun_frame_layout.gprs_offset \n+\t= cfun_frame_layout.f0_offset - cfun_gprs_save_area_size;\n+    }\n+\n+  if (current_function_is_leaf\n+      && !TARGET_TPF_PROFILING\n+      && cfun_frame_layout.frame_size == 0\n+      && !cfun_save_high_fprs_p\n+      && !current_function_calls_alloca\n+      && !current_function_stdarg)\n+    return;\n+\n+  if (TARGET_BACKCHAIN)\n+    cfun_frame_layout.frame_size += (STARTING_FRAME_OFFSET\n+\t\t\t\t     + cfun_frame_layout.high_fprs * 8);\n+  else\n+    {\n+      cfun_frame_layout.frame_size += (cfun_frame_layout.save_backchain_p\n+\t\t\t\t       * UNITS_PER_WORD);\n+      \n+      cfun_frame_layout.f8_offset = (MIN (MIN (cfun_frame_layout.f0_offset,\n+\t\t\t\t\t       cfun_frame_layout.f4_offset),\n+\t\t\t\t\t  cfun_frame_layout.gprs_offset)\n+\t\t\t\t     - cfun_frame_layout.high_fprs * 8);\n+\n+      cfun_frame_layout.frame_size += cfun_frame_layout.high_fprs * 8;\n+\n+      for (i = 0; i < 8; i++)\n+\tif (cfun_fpr_bit_p (i))\n+\t  cfun_frame_layout.frame_size += 8;\n+      \n+      cfun_frame_layout.frame_size += cfun_gprs_save_area_size;\n+      cfun_frame_layout.frame_size = ((cfun_frame_layout.frame_size +\n+\t\t\t\t       STACK_BOUNDARY / BITS_PER_UNIT - 1)\n+\t\t\t\t      & ~(STACK_BOUNDARY / BITS_PER_UNIT - 1));\n \n-      if (cfun->machine->last_save_gpr == -1\n-          || cfun->machine->last_save_gpr < 6)\n-        cfun->machine->last_save_gpr = 6;\n+      cfun_frame_layout.frame_size += current_function_outgoing_args_size;\n     }\n }\n \n@@ -5713,10 +5934,11 @@ s390_arg_frame_offset (void)\n   int return_addr_used = !current_function_is_leaf\n \t\t\t || TARGET_TPF_PROFILING\n \t\t\t || regs_ever_live[RETURN_REGNUM]\n-\t\t\t || cfun->machine->save_return_addr_p;\n+\t\t\t || cfun_frame_layout.save_return_addr_p;\n \n   s390_frame_info (1, !TARGET_CPU_ZARCH || return_addr_used);\n-  return cfun->machine->frame_size + STACK_POINTER_OFFSET;\n+\n+  return cfun_frame_layout.frame_size + STACK_POINTER_OFFSET;\n }\n \n /* Return offset between return address pointer (location of r14\n@@ -5727,7 +5949,11 @@ s390_return_address_offset (void)\n {\n   s390_frame_info (1, 1);\n \n-  return cfun->machine->frame_size + RETURN_REGNUM * UNITS_PER_WORD;\n+  if (cfun_frame_layout.last_save_gpr < RETURN_REGNUM)\n+    abort ();\n+\n+  return (cfun_frame_layout.frame_size + cfun_frame_layout.gprs_offset\n+\t  + (RETURN_REGNUM - cfun_frame_layout.first_save_gpr) * UNITS_PER_WORD);\n }\n \n /* Emit insn to save fpr REGNUM at offset OFFSET relative\n@@ -5766,7 +5992,7 @@ save_gprs (rtx base, int offset, int first, int last)\n   rtx addr, insn, note;\n   int i;\n \n-  addr = plus_constant (base, offset + first * UNITS_PER_WORD);\n+  addr = plus_constant (base, offset);\n   addr = gen_rtx_MEM (Pmode, addr);\n   set_mem_alias_set (addr, s390_sr_alias_set);\n \n@@ -5812,7 +6038,7 @@ save_gprs (rtx base, int offset, int first, int last)\n     }\n   else if (last >= 6)\n     {\n-      addr = plus_constant (base, offset + 6 * UNITS_PER_WORD);\n+      addr = plus_constant (base, offset + (6 - first) * UNITS_PER_WORD);\n       note = gen_store_multiple (gen_rtx_MEM (Pmode, addr),\n \t\t\t\t gen_rtx_REG (Pmode, 6),\n \t\t\t\t GEN_INT (last - 6 + 1));\n@@ -5841,7 +6067,7 @@ restore_gprs (rtx base, int offset, int first, int last)\n {\n   rtx addr, insn;\n \n-  addr = plus_constant (base, offset + first * UNITS_PER_WORD);\n+  addr = plus_constant (base, offset);\n   addr = gen_rtx_MEM (Pmode, addr);\n   set_mem_alias_set (addr, s390_sr_alias_set);\n \n@@ -5913,6 +6139,8 @@ s390_emit_prologue (void)\n   rtx insn, addr;\n   rtx temp_reg;\n   int i;\n+  int offset;\n+  int next_fpr = 0;\n \n   /* At this point, we decide whether we'll need to save/restore the\n      return address register.  This decision is final on zSeries machines;\n@@ -5921,7 +6149,7 @@ s390_emit_prologue (void)\n   if (!current_function_is_leaf\n       || TARGET_TPF_PROFILING\n       || regs_ever_live[RETURN_REGNUM])\n-    cfun->machine->save_return_addr_p = 1;\n+    cfun_frame_layout.save_return_addr_p = 1;\n \n   /* Decide which register to use as literal pool base.  In small leaf \n      functions, try to use an unused call-clobbered register as base \n@@ -5937,17 +6165,18 @@ s390_emit_prologue (void)\n   /* Compute frame info.  Note that at this point, we assume the base \n      register and -on S/390- the return register always need to be saved.\n      This is done because the usage of these registers might change even \n-     after the prolog was emitted.  If it turns out later that we really \n-     don't need them, the prolog/epilog code is modified again.  */\n+     after the prologue was emitted.  If it turns out later that we really \n+     don't need them, the prologue/epilogue code is modified again.  */\n \n-  s390_frame_info (1, !TARGET_CPU_ZARCH || cfun->machine->save_return_addr_p);\n+  s390_frame_info (1, !TARGET_CPU_ZARCH\n+\t\t   || cfun_frame_layout.save_return_addr_p);\n \n   /* We need to update regs_ever_live to avoid data-flow problems.  */\n \n   regs_ever_live[BASE_REGNUM] = 1;\n-  regs_ever_live[RETURN_REGNUM] = !TARGET_CPU_ZARCH \n-\t\t\t\t  || cfun->machine->save_return_addr_p;\n-  regs_ever_live[STACK_POINTER_REGNUM] = cfun->machine->frame_size > 0;\n+  regs_ever_live[RETURN_REGNUM] = (!TARGET_CPU_ZARCH \n+\t\t\t\t   || cfun_frame_layout.save_return_addr_p);\n+  regs_ever_live[STACK_POINTER_REGNUM] = cfun_frame_layout.frame_size > 0;\n \n   /* Annotate all constant pool references to let the scheduler know\n      they implicitly use the base register.  */\n@@ -5963,57 +6192,93 @@ s390_emit_prologue (void)\n   /* Choose best register to use for temp use within prologue.\n      See below for why TPF must use the register 1.  */\n \n-  if (!current_function_is_leaf\n-      && !TARGET_TPF_PROFILING)\n+  if (!current_function_is_leaf && !TARGET_TPF_PROFILING)\n     temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n   else\n     temp_reg = gen_rtx_REG (Pmode, 1);\n \n   /* Save call saved gprs.  */\n-\n-  insn = save_gprs (stack_pointer_rtx, 0,\n-\t\t    cfun->machine->first_save_gpr, cfun->machine->last_save_gpr);\n+  if (cfun_frame_layout.first_save_gpr != -1)\n+    insn = save_gprs (stack_pointer_rtx, \n+\t\t      cfun_frame_layout.gprs_offset,\n+\t\t      cfun_frame_layout.first_save_gpr, \n+\t\t      cfun_frame_layout.last_save_gpr);\n   emit_insn (insn);\n \n   /* Dummy insn to mark literal pool slot.  */\n \n   emit_insn (gen_main_pool (cfun->machine->base_reg));\n \n-  /* Save fprs for variable args.  */\n+  offset = cfun_frame_layout.f0_offset;\n \n-  if (current_function_stdarg)\n-    for (i = 16; i < (TARGET_64BIT ? 20 : 18); i++)\n-      save_fpr (stack_pointer_rtx, 16*UNITS_PER_WORD + 8*(i-16), i);\n-\n-  /* Save fprs 4 and 6 if used (31 bit ABI).  */\n+  /* Save f0 and f2.  */\n+  for (i = 0; i < 2; i++)\n+    {\n+      if (cfun_fpr_bit_p (i))\n+\t{\n+\t  save_fpr (stack_pointer_rtx, offset, i + 16);\n+\t  offset += 8;\n+\t}\n+      else if (TARGET_BACKCHAIN)\n+\t  offset += 8;\n+    }\n \n-  if (!TARGET_64BIT)\n-    for (i = 18; i < 20; i++)\n-      if (regs_ever_live[i] && !global_regs[i])\n+  /* Save f4 and f6.  */\n+  offset = cfun_frame_layout.f4_offset;\n+  for (i = 2; i < 4; i++)\n+    {\n+      if (cfun_fpr_bit_p (i))\n \t{\n-\t  insn = save_fpr (stack_pointer_rtx, 16*UNITS_PER_WORD + 8*(i-16), i);\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  insn = save_fpr (stack_pointer_rtx, offset, i + 16);\n+\t  offset += 8;\n+\n+\t  /* If f4 and f6 are call clobbered they are saved due to stdargs and\n+\t     therefore are not frame related.  */\n+\t  if (!call_really_used_regs[i + 16])\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n+      else if (TARGET_BACKCHAIN)\n+\toffset += 8;\n+    }\n+\n+  if (!TARGET_BACKCHAIN \n+      && cfun_save_high_fprs_p\n+      && cfun_frame_layout.f8_offset + cfun_frame_layout.high_fprs * 8 > 0)\n+    {\n+      offset = (cfun_frame_layout.f8_offset\n+\t\t+ (cfun_frame_layout.high_fprs - 1) * 8);\n+\n+      for (i = 15; i > 7 && offset >= 0; i--)\n+\tif (cfun_fpr_bit_p (i))\n+\t  {\n+\t    insn = save_fpr (stack_pointer_rtx, offset, i + 16);\n+\t    \t       \n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t    offset -= 8;\n+\t  }\n+      if (offset >= cfun_frame_layout.f8_offset)\n+\tnext_fpr = i + 16;\n+    }\n+  \n+  if (TARGET_BACKCHAIN)\n+    next_fpr = cfun_save_high_fprs_p ? 31 : 0;\n \n   /* Decrement stack pointer.  */\n \n-  if (cfun->machine->frame_size > 0)\n+  if (cfun_frame_layout.frame_size > 0)\n     {\n-      rtx frame_off = GEN_INT (-cfun->machine->frame_size);\n+      rtx frame_off = GEN_INT (-cfun_frame_layout.frame_size);\n \n       /* Save incoming stack pointer into temp reg.  */\n-\n-      if (TARGET_BACKCHAIN || cfun->machine->save_fprs_p)\n-\t{\n-\t  insn = emit_insn (gen_move_insn (temp_reg, stack_pointer_rtx));\n-\t}\n+      if (cfun_frame_layout.save_backchain_p || next_fpr)\n+\tinsn = emit_insn (gen_move_insn (temp_reg, stack_pointer_rtx));\n \n       /* Subtract frame size from stack pointer.  */\n \n       if (DISP_IN_RANGE (INTVAL (frame_off)))\n \t{\n \t  insn = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t      gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t      gen_rtx_PLUS (Pmode, stack_pointer_rtx, \n \t\t\t\t\t    frame_off));\n \t  insn = emit_insn (insn);\n \t}\n@@ -6030,15 +6295,20 @@ s390_emit_prologue (void)\n       REG_NOTES (insn) =\n \tgen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n \t\t\t   gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t\t   gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t           GEN_INT (-cfun->machine->frame_size))),\n+\t\t\t     gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t       GEN_INT (-cfun_frame_layout.frame_size))),\n \t\t\t   REG_NOTES (insn));\n \n       /* Set backchain.  */\n \n-      if (TARGET_BACKCHAIN)\n+      if (cfun_frame_layout.save_backchain_p)\n \t{\n-\t  addr = gen_rtx_MEM (Pmode, stack_pointer_rtx);\n+\t  if (cfun_frame_layout.backchain_offset)\n+\t    addr = gen_rtx_MEM (Pmode, \n+\t\t\t\tplus_constant (stack_pointer_rtx, \n+\t\t\t\t  cfun_frame_layout.backchain_offset));\n+\t  else\n+\t    addr = gen_rtx_MEM (Pmode, stack_pointer_rtx);  \n \t  set_mem_alias_set (addr, s390_sr_alias_set);\n \t  insn = emit_insn (gen_move_insn (addr, temp_reg));\n \t}\n@@ -6047,7 +6317,7 @@ s390_emit_prologue (void)\n \t we need to make sure the backchain pointer is set up\n \t before any possibly trapping memory access.  */\n \n-      if (TARGET_BACKCHAIN && flag_non_call_exceptions)\n+      if (cfun_frame_layout.save_backchain_p && flag_non_call_exceptions)\n \t{\n \t  addr = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode));\n \t  emit_insn (gen_rtx_CLOBBER (VOIDmode, addr));\n@@ -6056,24 +6326,30 @@ s390_emit_prologue (void)\n \n   /* Save fprs 8 - 15 (64 bit ABI).  */\n \n-  if (cfun->machine->save_fprs_p)\n+  if (cfun_save_high_fprs_p && next_fpr)\n     {\n-      insn = emit_insn (gen_add2_insn (temp_reg, GEN_INT(-64)));\n+      insn = emit_insn (gen_add2_insn (temp_reg, \n+\t\t\t\t       GEN_INT (cfun_frame_layout.f8_offset)));\n \n-      for (i = 24; i < 32; i++)\n-\tif (regs_ever_live[i] && !global_regs[i])\n+      offset = 0;\n+\n+      for (i = 24; i <= next_fpr; i++)\n+\tif (cfun_fpr_bit_p (i - 16))\n \t  {\n \t    rtx addr = plus_constant (stack_pointer_rtx,\n-\t\t\t\t      cfun->machine->frame_size - 64 + (i-24)*8);\n-\n-\t    insn = save_fpr (temp_reg, (i-24)*8, i);\n+\t\t\t\t      cfun_frame_layout.frame_size\n+\t\t\t\t      + cfun_frame_layout.f8_offset\n+\t\t\t\t      + offset);\n+\t    \n+\t    insn = save_fpr (temp_reg, offset, i);\n+\t    offset += 8;\n \t    RTX_FRAME_RELATED_P (insn) = 1;\n \t    REG_NOTES (insn) =\n \t      gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\tgen_rtx_SET (VOIDmode,\n-\t\t\t     gen_rtx_MEM (DFmode, addr),\n-\t\t\t     gen_rtx_REG (DFmode, i)),\n-\t\tREG_NOTES (insn));\n+\t\t\t\t gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t      gen_rtx_MEM (DFmode, addr),\n+\t\t\t\t\t      gen_rtx_REG (DFmode, i)),\n+\t\t\t\t REG_NOTES (insn));\n \t  }\n     }\n \n@@ -6122,6 +6398,7 @@ s390_emit_epilogue (bool sibcall)\n {\n   rtx frame_pointer, return_reg;\n   int area_bottom, area_top, offset = 0;\n+  int next_offset;\n   rtvec p;\n   int i;\n \n@@ -6141,43 +6418,10 @@ s390_emit_epilogue (bool sibcall)\n \n   /* Check whether to use frame or stack pointer for restore.  */\n \n-  frame_pointer = frame_pointer_needed ?\n-    hard_frame_pointer_rtx : stack_pointer_rtx;\n+  frame_pointer = (frame_pointer_needed \n+\t\t   ? hard_frame_pointer_rtx : stack_pointer_rtx);\n \n-  /* Compute which parts of the save area we need to access.  */\n-\n-  if (cfun->machine->first_restore_gpr != -1)\n-    {\n-      area_bottom = cfun->machine->first_restore_gpr * UNITS_PER_WORD;\n-      area_top = (cfun->machine->last_restore_gpr + 1) * UNITS_PER_WORD;\n-    }\n-  else\n-    {\n-      area_bottom = INT_MAX;\n-      area_top = INT_MIN;\n-    }\n-\n-  if (TARGET_64BIT)\n-    {\n-      if (cfun->machine->save_fprs_p)\n-\t{\n-\t  if (area_bottom > -64)\n-\t    area_bottom = -64;\n-\t  if (area_top < 0)\n-\t    area_top = 0;\n-\t}\n-    }\n-  else\n-    {\n-      for (i = 18; i < 20; i++)\n-\tif (regs_ever_live[i] && !global_regs[i])\n-\t  {\n-\t    if (area_bottom > 16*UNITS_PER_WORD + 8*(i-16))\n-\t      area_bottom = 16*UNITS_PER_WORD + 8*(i-16);\n-\t    if (area_top < 16*UNITS_PER_WORD + 8*(i-16) + 8)\n-\t      area_top = 16*UNITS_PER_WORD + 8*(i-16) + 8;\n-\t  }\n-    }\n+  s390_frame_area (&area_bottom, &area_top);\n \n   /* Check whether we can access the register save area.\n      If not, increment the frame pointer as required.  */\n@@ -6186,18 +6430,18 @@ s390_emit_epilogue (bool sibcall)\n     {\n       /* Nothing to restore.  */\n     }\n-  else if (DISP_IN_RANGE (cfun->machine->frame_size + area_bottom)\n-           && DISP_IN_RANGE (cfun->machine->frame_size + area_top-1))\n+  else if (DISP_IN_RANGE (cfun_frame_layout.frame_size + area_bottom)\n+           && DISP_IN_RANGE (cfun_frame_layout.frame_size + area_top - 1))\n     {\n       /* Area is in range.  */\n-      offset = cfun->machine->frame_size;\n+      offset = cfun_frame_layout.frame_size;\n     }\n   else\n     {\n       rtx insn, frame_off;\n \n       offset = area_bottom < 0 ? -area_bottom : 0;\n-      frame_off = GEN_INT (cfun->machine->frame_size - offset);\n+      frame_off = GEN_INT (cfun_frame_layout.frame_size - offset);\n \n       if (DISP_IN_RANGE (INTVAL (frame_off)))\n \t{\n@@ -6219,18 +6463,36 @@ s390_emit_epilogue (bool sibcall)\n \n   if (TARGET_64BIT)\n     {\n-      if (cfun->machine->save_fprs_p)\n-\tfor (i = 24; i < 32; i++)\n-\t  if (regs_ever_live[i] && !global_regs[i])\n-\t    restore_fpr (frame_pointer,\n-\t\t\t offset - 64 + (i-24) * 8, i);\n+      if (cfun_save_high_fprs_p)\n+\t{\n+\t  next_offset = cfun_frame_layout.f8_offset;\n+\t  for (i = 24; i < 32; i++)\n+\t    {\n+\t      if (cfun_fpr_bit_p (i - 16))\n+\t\t{\n+\t\t  restore_fpr (frame_pointer,\n+\t\t\t       offset + next_offset, i);\n+\t\t  next_offset += 8;\n+\t\t}\n+\t    }\n+\t}\n+\t      \n     }\n   else\n     {\n+      next_offset = cfun_frame_layout.f4_offset;\n       for (i = 18; i < 20; i++)\n-\tif (regs_ever_live[i] && !global_regs[i])\n-\t  restore_fpr (frame_pointer,\n-\t\t       offset + 16*UNITS_PER_WORD + 8*(i-16), i);\n+\t{\n+\t  if (cfun_fpr_bit_p (i - 16))\n+\t    {\n+\t      restore_fpr (frame_pointer,\n+\t\t\t   offset + next_offset, i);\n+\t      next_offset += 8;\n+\t    }\n+\t  else if (TARGET_BACKCHAIN)\n+\t    next_offset += 8;\n+\t}\n+      \n     }\n \n   /* Return register.  */\n@@ -6239,16 +6501,16 @@ s390_emit_epilogue (bool sibcall)\n \n   /* Restore call saved gprs.  */\n \n-  if (cfun->machine->first_restore_gpr != -1)\n+  if (cfun_frame_layout.first_restore_gpr != -1)\n     {\n       rtx insn, addr;\n       int i;\n \n       /* Check for global register and save them\n \t to stack location from where they get restored.  */\n \n-      for (i = cfun->machine->first_restore_gpr;\n-\t   i <= cfun->machine->last_restore_gpr;\n+      for (i = cfun_frame_layout.first_restore_gpr;\n+\t   i <= cfun_frame_layout.last_restore_gpr;\n \t   i++)\n \t{\n \t  /* These registers are special and need to be\n@@ -6262,7 +6524,9 @@ s390_emit_epilogue (bool sibcall)\n \t  if (global_regs[i])\n \t    {\n \t      addr = plus_constant (frame_pointer,\n-\t\t     offset + i * UNITS_PER_WORD);\n+\t\t\t\t    offset + cfun_frame_layout.gprs_offset \n+\t\t\t\t    + (i - cfun_frame_layout.first_save_gpr)\n+\t\t\t\t    * UNITS_PER_WORD);\n \t      addr = gen_rtx_MEM (Pmode, addr);\n \t      set_mem_alias_set (addr, s390_sr_alias_set);\n \t      emit_move_insn (addr, gen_rtx_REG (Pmode, i));\n@@ -6274,26 +6538,33 @@ s390_emit_epilogue (bool sibcall)\n \t  /* Fetch return address from stack before load multiple,\n \t     this will do good for scheduling.  */\n \n-\t  if (cfun->machine->save_return_addr_p\n-\t      || (cfun->machine->first_restore_gpr < BASE_REGNUM\n-\t\t  && cfun->machine->last_restore_gpr > RETURN_REGNUM))\n+\t  if (cfun_frame_layout.save_return_addr_p\n+\t      || (cfun_frame_layout.first_restore_gpr < BASE_REGNUM\n+\t\t  && cfun_frame_layout.last_restore_gpr > RETURN_REGNUM))\n \t    {\n \t      int return_regnum = find_unused_clobbered_reg();\n \t      if (!return_regnum)\n \t\treturn_regnum = 4;\n \t      return_reg = gen_rtx_REG (Pmode, return_regnum);\n \n \t      addr = plus_constant (frame_pointer,\n-\t\t\t\t    offset + RETURN_REGNUM * UNITS_PER_WORD);\n+\t\t\t\t    offset + cfun_frame_layout.gprs_offset\n+\t\t\t\t    + (RETURN_REGNUM \n+\t\t\t\t       - cfun_frame_layout.first_save_gpr)\n+\t\t\t\t    * UNITS_PER_WORD);\n \t      addr = gen_rtx_MEM (Pmode, addr);\n \t      set_mem_alias_set (addr, s390_sr_alias_set);\n \t      emit_move_insn (return_reg, addr);\n \t    }\n \t}\n \n-      insn = restore_gprs (frame_pointer, offset,\n-\t\t\t   cfun->machine->first_restore_gpr,\n-\t\t\t   cfun->machine->last_restore_gpr);\n+      insn = restore_gprs (frame_pointer,\n+\t\t\t   offset + cfun_frame_layout.gprs_offset\n+\t\t\t   + (cfun_frame_layout.first_restore_gpr \n+\t\t\t      - cfun_frame_layout.first_save_gpr)\n+\t\t\t   * UNITS_PER_WORD,\n+\t\t\t   cfun_frame_layout.first_restore_gpr,\n+\t\t\t   cfun_frame_layout.last_restore_gpr);\n       emit_insn (insn);\n     }\n \n@@ -6681,9 +6952,15 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   /* Find the register save area.  */\n-  t = make_tree (TREE_TYPE (sav), virtual_incoming_args_rtx);\n-  t = build (PLUS_EXPR, TREE_TYPE (sav), t,\n-\t     build_int_2 (-STACK_POINTER_OFFSET, -1));\n+  t = make_tree (TREE_TYPE (sav), return_address_pointer_rtx);\n+  if (TARGET_KERNEL_BACKCHAIN)\n+    t = build (PLUS_EXPR, TREE_TYPE (sav), t,\n+\t       build_int_2 (-(RETURN_REGNUM - 2) * UNITS_PER_WORD\n+\t\t\t    - (TARGET_64BIT ? 4 : 2) * 8, -1));\n+  else\n+    t = build (PLUS_EXPR, TREE_TYPE (sav), t,\n+\t       build_int_2 (-RETURN_REGNUM * UNITS_PER_WORD, -1));\n+\n   t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -6747,7 +7024,8 @@ s390_gimplify_va_arg (tree valist, tree type, tree *pre_p,\n       indirect_p = 1;\n       reg = gpr;\n       n_reg = 1;\n-      sav_ofs = 2 * UNITS_PER_WORD;\n+      sav_ofs = (TARGET_KERNEL_BACKCHAIN\n+\t\t ? (TARGET_64BIT ? 4 : 2) * 8 : 2 * UNITS_PER_WORD);\n       sav_scale = UNITS_PER_WORD;\n       size = UNITS_PER_WORD;\n       max_reg = 4;\n@@ -6764,7 +7042,7 @@ s390_gimplify_va_arg (tree valist, tree type, tree *pre_p,\n       indirect_p = 0;\n       reg = fpr;\n       n_reg = 1;\n-      sav_ofs = 16 * UNITS_PER_WORD;\n+      sav_ofs = TARGET_KERNEL_BACKCHAIN ? 0 : 16 * UNITS_PER_WORD;\n       sav_scale = 8;\n       /* TARGET_64BIT has up to 4 parameter in fprs */\n       max_reg = TARGET_64BIT ? 3 : 1;\n@@ -6781,7 +7059,8 @@ s390_gimplify_va_arg (tree valist, tree type, tree *pre_p,\n       indirect_p = 0;\n       reg = gpr;\n       n_reg = (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-      sav_ofs = 2 * UNITS_PER_WORD;\n+      sav_ofs = TARGET_KERNEL_BACKCHAIN ? \n+\t(TARGET_64BIT ? 4 : 2) * 8 : 2*UNITS_PER_WORD;\n \n       if (size < UNITS_PER_WORD)\n \tsav_ofs += UNITS_PER_WORD - size;"}, {"sha": "eae2d65c95391a4798b434cfaf95a8569dff0dd7", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf39f8f5f2e1c877fe6b02654e673875c34ddac/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf39f8f5f2e1c877fe6b02654e673875c34ddac/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=adf39f8f5f2e1c877fe6b02654e673875c34ddac", "patch": "@@ -60,6 +60,8 @@ extern enum processor_type s390_arch;\n extern enum processor_flags s390_arch_flags;\n extern const char *s390_arch_string;\n \n+extern const char *s390_backchain_string;\n+\n #define TARGET_CPU_IEEE_FLOAT \\\n \t(s390_arch_flags & PF_IEEE_FLOAT)\n #define TARGET_CPU_ZARCH \\\n@@ -89,7 +91,6 @@ extern const char *s390_arch_string;\n extern int target_flags;\n \n #define MASK_HARD_FLOAT            0x01\n-#define MASK_BACKCHAIN             0x02\n #define MASK_SMALL_EXEC            0x04\n #define MASK_DEBUG_ARG             0x08\n #define MASK_64BIT                 0x10\n@@ -100,7 +101,6 @@ extern int target_flags;\n \n #define TARGET_HARD_FLOAT          (target_flags & MASK_HARD_FLOAT)\n #define TARGET_SOFT_FLOAT          (!(target_flags & MASK_HARD_FLOAT))\n-#define TARGET_BACKCHAIN           (target_flags & MASK_BACKCHAIN)\n #define TARGET_SMALL_EXEC          (target_flags & MASK_SMALL_EXEC)\n #define TARGET_DEBUG_ARG           (target_flags & MASK_DEBUG_ARG)\n #define TARGET_64BIT               (target_flags & MASK_64BIT)\n@@ -110,6 +110,9 @@ extern int target_flags;\n #define TARGET_NO_FUSED_MADD       (target_flags & MASK_NO_FUSED_MADD)\n #define TARGET_FUSED_MADD\t   (! TARGET_NO_FUSED_MADD)\n \n+#define TARGET_BACKCHAIN           (s390_backchain_string[0] == '1')\n+#define TARGET_KERNEL_BACKCHAIN    (s390_backchain_string[0] == '2')\n+\n /* ??? Once this actually works, it could be made a runtime option.  */\n #define TARGET_IBM_FLOAT           0\n #define TARGET_IEEE_FLOAT          1\n@@ -123,8 +126,6 @@ extern int target_flags;\n #define TARGET_SWITCHES                                                  \\\n { { \"hard-float\",      1, N_(\"Use hardware fp\")},                        \\\n   { \"soft-float\",     -1, N_(\"Don't use hardware fp\")},                  \\\n-  { \"backchain\",       2, N_(\"Set backchain\")},                          \\\n-  { \"no-backchain\",   -2, N_(\"Don't set backchain (faster, but debug harder\")},\\\n   { \"small-exec\",      4, N_(\"Use bras for executable < 64k\")},          \\\n   { \"no-small-exec\",  -4, N_(\"Don't use bras\")},                         \\\n   { \"debug\",           8, N_(\"Additional debug prints\")},                \\\n@@ -146,6 +147,12 @@ extern int target_flags;\n     N_(\"Schedule code for given CPU\"), 0},                      \\\n   { \"arch=\",            &s390_arch_string,                      \\\n     N_(\"Generate code for given CPU\"), 0},                      \\\n+  { \"backchain\",        &s390_backchain_string,                 \\\n+    N_(\"Set backchain\"), \"1\"},                                  \\\n+  { \"no-backchain\",     &s390_backchain_string,                 \\\n+    N_(\"Do not set backchain\"), \"\"},                            \\\n+  { \"kernel-backchain\", &s390_backchain_string,                 \\\n+    N_(\"Set backchain appropriate for the linux kernel\"), \"2\"}, \\\n }\n \n /* Support for configure-time defaults.  */\n@@ -559,9 +566,13 @@ extern int current_function_outgoing_args_size;\n    For frames farther back, we use the stack slot where\n    the corresponding RETURN_REGNUM register was saved.  */\n \n-#define DYNAMIC_CHAIN_ADDRESS(FRAME)\t\t\t\t\t\t\\\n-  ((FRAME) != hard_frame_pointer_rtx ? (FRAME) :\t\t\t\t\\\n-   plus_constant (arg_pointer_rtx, -STACK_POINTER_OFFSET))\n+#define DYNAMIC_CHAIN_ADDRESS(FRAME)                                            \\\n+  (TARGET_BACKCHAIN ?                                                           \\\n+   ((FRAME) != hard_frame_pointer_rtx ? (FRAME) :\t\t\t\t\\\n+    plus_constant (arg_pointer_rtx, -STACK_POINTER_OFFSET)) :                   \\\n+    ((FRAME) != hard_frame_pointer_rtx ?                                        \\\n+     plus_constant ((FRAME), STACK_POINTER_OFFSET - UNITS_PER_WORD) :           \\\n+     plus_constant (arg_pointer_rtx, -UNITS_PER_WORD)))\n \n #define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t\t\\\n   s390_return_addr_rtx ((COUNT), DYNAMIC_CHAIN_ADDRESS ((FRAME)))"}, {"sha": "53d122022eb8494ce5b994114c897b3f1d7d2d4d", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf39f8f5f2e1c877fe6b02654e673875c34ddac/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf39f8f5f2e1c877fe6b02654e673875c34ddac/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=adf39f8f5f2e1c877fe6b02654e673875c34ddac", "patch": "@@ -7217,11 +7217,19 @@\n         (plus (reg 15) (match_operand 1 \"general_operand\" \"\")))\n    (set (match_operand 0 \"general_operand\" \"\")\n         (reg 15))]\n- \"TARGET_BACKCHAIN\"\n+ \"TARGET_BACKCHAIN || TARGET_KERNEL_BACKCHAIN\"\n {\n     rtx stack = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n-    rtx chain = gen_rtx_MEM (Pmode, stack);\n-    rtx temp = gen_reg_rtx (Pmode);\n+    rtx chain;\n+    rtx temp;\n+\n+    if (TARGET_KERNEL_BACKCHAIN)\n+      chain = plus_constant (stack, STACK_POINTER_OFFSET - UNITS_PER_WORD);\n+    else\n+      chain = stack;\n+\n+    chain = gen_rtx_MEM (Pmode, chain);\n+    temp = gen_reg_rtx (Pmode);\n \n     emit_move_insn (temp, chain);\n "}, {"sha": "0cc00780498e83e811fbd3f956293ffb2dfe5620", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf39f8f5f2e1c877fe6b02654e673875c34ddac/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf39f8f5f2e1c877fe6b02654e673875c34ddac/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=adf39f8f5f2e1c877fe6b02654e673875c34ddac", "patch": "@@ -617,7 +617,7 @@ See RS/6000 and PowerPC Options.\n \n @emph{S/390 and zSeries Options}\n @gccoptlist{-mtune=@var{cpu-type}  -march=@var{cpu-type} @gol\n--mhard-float  -msoft-float  -mbackchain  -mno-backchain @gol\n+-mhard-float  -msoft-float  -mbackchain  -mno-backchain -mkernel-backchain @gol\n -msmall-exec  -mno-small-exec  -mmvcle -mno-mvcle @gol\n -m64  -m31  -mdebug  -mno-debug  -mesa  -mzarch @gol\n -mtpf-trace -mno-tpf-trace  -mfused-madd  -mno-fused-madd}\n@@ -10454,13 +10454,27 @@ generates IEEE floating-point instructions.  This is the default.\n \n @item -mbackchain\n @itemx -mno-backchain\n+@itemx -mkernel-backchain\n @opindex mbackchain\n @opindex mno-backchain\n-Generate (or do not generate) code which maintains an explicit\n-backchain within the stack frame that points to the caller's frame.\n-This may be needed to allow debugging using tools that do not understand\n-DWARF-2 call frame information.  The default is not to generate the\n-backchain.\n+@opindex mkernel-backchain\n+In order to provide a backchain the address of the caller's frame\n+is stored within the callee's stack frame.\n+A backchain may be needed to allow debugging using tools that do not understand\n+DWARF-2 call frame information.\n+For @option{-mno-backchain} no backchain is maintained at all which is the \n+default. \n+If one of the other options is present the backchain pointer is placed either \n+on top of the stack frame  (@option{-mkernel-backchain}) or on\n+the bottom (@option{-mbackchain}).\n+Beside the different backchain location @option{-mkernel-backchain}\n+also changes stack frame layout breaking the ABI. This option\n+is intended to be used for code which internally needs a backchain but has\n+to get by with a limited stack size e.g. the linux kernel. \n+Internal unwinding code not using DWARF-2 info has to be able to locate the\n+return address of a function. That will be eased be the fact that\n+the return address of a function is placed two words below the backchain \n+pointer.\n \n @item -msmall-exec\n @itemx -mno-small-exec"}]}