{"sha": "22063dbc90d0eb8a7cc7939e0941899f90b403db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIwNjNkYmM5MGQwZWI4YTdjYzc5MzllMDk0MTg5OWY5MGI0MDNkYg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-08-10T13:11:42Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-08-10T13:11:42Z"}, "message": "Cherry-pick fprofile-generate-atomic from google/gcc-4_9\n\n\tCherry picked (and modified) from google-4_7 branch\n\t2012-12-26  Rong Xu  <xur@google.com>\n\t* common.opt (fprofile-update): Add new flag.\n\t* coretypes.h: Define enum profile_update.\n\t* doc/invoke.texi: Document -fprofile-update.\n\t* gcov-io.h: Declare GCOV_TYPE_ATOMIC_FETCH_ADD and\n\tGCOV_TYPE_ATOMIC_FETCH_ADD_FN.\n\t* tree-profile.c (gimple_init_edge_profiler): Generate\n\talso atomic profiler update.\n\t(gimple_gen_edge_profiler): Likewise.\n\t* g++.dg/gcov/gcov-threads-1.C: New test.\n\nFrom-SVN: r239323", "tree": {"sha": "bca16f60942cfafd651fca3cbf08a464365e76b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bca16f60942cfafd651fca3cbf08a464365e76b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22063dbc90d0eb8a7cc7939e0941899f90b403db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22063dbc90d0eb8a7cc7939e0941899f90b403db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22063dbc90d0eb8a7cc7939e0941899f90b403db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22063dbc90d0eb8a7cc7939e0941899f90b403db/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a39e998c8a89b26a74b9fb0b5bc17fa8b55d274", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a39e998c8a89b26a74b9fb0b5bc17fa8b55d274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a39e998c8a89b26a74b9fb0b5bc17fa8b55d274"}], "stats": {"total": 155, "additions": 137, "deletions": 18}, "files": [{"sha": "cdf8b7740bd498c2352acbcddc683b5bd29603c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22063dbc90d0eb8a7cc7939e0941899f90b403db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22063dbc90d0eb8a7cc7939e0941899f90b403db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22063dbc90d0eb8a7cc7939e0941899f90b403db", "patch": "@@ -1,3 +1,16 @@\n+2016-08-10  Martin Liska  <mliska@suse.cz>\n+\n+\tCherry picked (and modified) from google-4_7 branch\n+\t2012-12-26  Rong Xu  <xur@google.com>\n+\t* common.opt (fprofile-update): Add new flag.\n+\t* coretypes.h: Define enum profile_update.\n+\t* doc/invoke.texi: Document -fprofile-update.\n+\t* gcov-io.h: Declare GCOV_TYPE_ATOMIC_FETCH_ADD and\n+\tGCOV_TYPE_ATOMIC_FETCH_ADD_FN.\n+\t* tree-profile.c (gimple_init_edge_profiler): Generate\n+\talso atomic profiler update.\n+\t(gimple_gen_edge_profiler): Likewise.\n+\n 2016-08-10  David Malcolm  <dmalcolm@redhat.com>\n \n \t* toplev.c (finalize): Set aux_info_file, asm_out_file, and"}, {"sha": "44adae89a23ec0f91c5fa638b19efe4300c40688", "filename": "gcc/common.opt", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22063dbc90d0eb8a7cc7939e0941899f90b403db/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22063dbc90d0eb8a7cc7939e0941899f90b403db/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=22063dbc90d0eb8a7cc7939e0941899f90b403db", "patch": "@@ -1916,6 +1916,19 @@ fprofile-correction\n Common Report Var(flag_profile_correction)\n Enable correction of flow inconsistent profile data input.\n \n+fprofile-update=\n+Common Joined RejectNegative Enum(profile_update) Var(flag_profile_update) Init(PROFILE_UPDATE_SINGLE)\n+-fprofile-update=[single|atomic]\tSet the profile update method.\n+\n+Enum\n+Name(profile_update) Type(enum profile_update) UnknownError(unknown profile update method %qs)\n+\n+EnumValue\n+Enum(profile_update) String(single) Value(PROFILE_UPDATE_SINGLE)\n+\n+EnumValue\n+Enum(profile_update) String(atomic) Value(PROFILE_UPDATE_ATOMIC)\n+\n fprofile-generate\n Common\n Enable common options for generating profile info for profile feedback directed optimizations."}, {"sha": "fe1e984311cdad337d62b249924011a94ab80771", "filename": "gcc/coretypes.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22063dbc90d0eb8a7cc7939e0941899f90b403db/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22063dbc90d0eb8a7cc7939e0941899f90b403db/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=22063dbc90d0eb8a7cc7939e0941899f90b403db", "patch": "@@ -174,6 +174,12 @@ enum offload_abi {\n   OFFLOAD_ABI_ILP32\n };\n \n+/* Types of profile update methods.  */\n+enum profile_update {\n+  PROFILE_UPDATE_SINGLE,\n+  PROFILE_UPDATE_ATOMIC\n+};\n+\n /* Types of unwind/exception handling info that can be generated.  */\n \n enum unwind_info_type"}, {"sha": "1cfaae73a989cb7c161a8132349c92049e5ce74f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22063dbc90d0eb8a7cc7939e0941899f90b403db/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22063dbc90d0eb8a7cc7939e0941899f90b403db/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=22063dbc90d0eb8a7cc7939e0941899f90b403db", "patch": "@@ -9933,6 +9933,18 @@ the profile feedback data files. See @option{-fprofile-dir}.\n To optimize the program based on the collected profile information, use\n @option{-fprofile-use}.  @xref{Optimize Options}, for more information.\n \n+@item -fprofile-update=@var{method}\n+@opindex fprofile-update\n+\n+Alter the update method for an application instrumented for profile\n+feedback based optimization.  The @var{method} argument should be one of\n+@samp{single} or @samp{atomic}.  The first one is useful for single-threaded\n+applications, while the second one prevents profile corruption by emitting\n+thread-safe code.\n+\n+@strong{Warning:} When an application does not properly join all threads\n+(or creates an detached thread), a profile file can be still corrupted.\n+\n @item -fsanitize=address\n @opindex fsanitize=address\n Enable AddressSanitizer, a fast memory error detector."}, {"sha": "afd00acb866ee6efea6568d2e586da3f5de2dcf8", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22063dbc90d0eb8a7cc7939e0941899f90b403db/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22063dbc90d0eb8a7cc7939e0941899f90b403db/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=22063dbc90d0eb8a7cc7939e0941899f90b403db", "patch": "@@ -164,6 +164,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #ifndef GCC_GCOV_IO_H\n #define GCC_GCOV_IO_H\n \n+#if LONG_LONG_TYPE_SIZE > 32\n+#define GCOV_TYPE_ATOMIC_FETCH_ADD_FN __atomic_fetch_add_8\n+#define GCOV_TYPE_ATOMIC_FETCH_ADD BUILT_IN_ATOMIC_FETCH_ADD_8\n+#else\n+#define GCOV_TYPE_ATOMIC_FETCH_ADD_FN __atomic_fetch_add_4\n+#define GCOV_TYPE_ATOMIC_FETCH_ADD BUILT_IN_ATOMIC_FETCH_ADD_4\n+#endif\n+\n #ifndef IN_LIBGCOV\n /* About the host */\n "}, {"sha": "20bd72a0dbc0c13e0df56f5ba413abd440f1677d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22063dbc90d0eb8a7cc7939e0941899f90b403db/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22063dbc90d0eb8a7cc7939e0941899f90b403db/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=22063dbc90d0eb8a7cc7939e0941899f90b403db", "patch": "@@ -1,3 +1,7 @@\n+2016-08-10  Martin Liska  <mliska@suse.cz>\n+\n+\t* g++.dg/gcov/gcov-threads-1.C: New test.\n+\n 2016-08-10  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>\n \n \tPR target/71873"}, {"sha": "a4a6f0a6ae388304827dad269a528ca12d36d8aa", "filename": "gcc/testsuite/g++.dg/gcov/gcov-threads-1.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22063dbc90d0eb8a7cc7939e0941899f90b403db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgcov%2Fgcov-threads-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22063dbc90d0eb8a7cc7939e0941899f90b403db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgcov%2Fgcov-threads-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgcov%2Fgcov-threads-1.C?ref=22063dbc90d0eb8a7cc7939e0941899f90b403db", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-options \"-fprofile-arcs -ftest-coverage -pthread -fprofile-update=atomic\" } */\n+/* { dg-do run { target native } } */\n+\n+#include <stdint.h>\n+#include <pthread.h>\n+#include <assert.h>\n+\n+#define NR 5\n+\n+pthread_mutex_t cndMs[NR];\n+static void *ContentionNoDeadlock_thread(void *start)\n+{\n+  for (uint32_t k = 0; k < 100000; ++k)\t\t/* count(500005) */\n+    {\n+      int starti = *(int*)start;\t\t/* count(500000) */\n+      for (uint32_t i = starti; i < NR; ++i) \n+\tpthread_mutex_lock (&cndMs[i]);\n+      for (int32_t i = NR - 1; i >= starti; --i)\n+\tpthread_mutex_unlock (&cndMs[i]);\n+  }\n+}\n+int main(int argc, char **argv) {\n+  for (unsigned i = 0; i < NR; i++)\n+    cndMs[i] = PTHREAD_MUTEX_INITIALIZER;\n+\n+  pthread_t t[NR];\n+  int ids[NR];\n+\n+  for (int i = 0; i < NR; i++)\n+  {\n+    ids[i] = i;\n+    int r = pthread_create (&t[i], NULL, ContentionNoDeadlock_thread, &ids[i]);\n+    assert (r == 0);\t\t\t\t/* count(5) */\n+  }\n+\n+  int ret;\n+  for (int i = 0; i < NR; i++)\n+    {\n+      int r = pthread_join (t[i], (void**)&ret);\n+      assert (r == 0);\t\t\t\t/* count(5) */\n+    }\n+\n+  return 0;\t\t\t\t\t/* count(1) */\n+}\n+\n+/* { dg-final { run-gcov gcov-threads-1.C } } */"}, {"sha": "740f7ab7d5a56d06c195dfe93cba81ae0ebb3955", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22063dbc90d0eb8a7cc7939e0941899f90b403db/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22063dbc90d0eb8a7cc7939e0941899f90b403db/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=22063dbc90d0eb8a7cc7939e0941899f90b403db", "patch": "@@ -127,6 +127,7 @@ gimple_init_edge_profiler (void)\n   tree ic_profiler_fn_type;\n   tree average_profiler_fn_type;\n   tree time_profiler_fn_type;\n+  const char *profiler_fn_name;\n \n   if (!gcov_type_node)\n     {\n@@ -180,11 +181,12 @@ gimple_init_edge_profiler (void)\n \t\t\t\t\t  gcov_type_node,\n \t\t\t\t\t  ptr_void,\n \t\t\t\t\t  NULL_TREE);\n+      profiler_fn_name = \"__gcov_indirect_call_profiler_v2\";\n+      if (PARAM_VALUE (PARAM_INDIR_CALL_TOPN_PROFILE))\n+\tprofiler_fn_name = \"__gcov_indirect_call_topn_profiler\";\n+\n       tree_indirect_call_profiler_fn\n-\t      = build_fn_decl ( (PARAM_VALUE (PARAM_INDIR_CALL_TOPN_PROFILE) ?\n-\t\t\t\t \"__gcov_indirect_call_topn_profiler\":\n-\t\t\t\t \"__gcov_indirect_call_profiler_v2\"),\n-\t\t\t       ic_profiler_fn_type);\n+\t      = build_fn_decl (profiler_fn_name, ic_profiler_fn_type);\n \n       TREE_NOTHROW (tree_indirect_call_profiler_fn) = 1;\n       DECL_ATTRIBUTES (tree_indirect_call_profiler_fn)\n@@ -241,22 +243,37 @@ gimple_init_edge_profiler (void)\n void\n gimple_gen_edge_profiler (int edgeno, edge e)\n {\n-  tree ref, one, gcov_type_tmp_var;\n-  gassign *stmt1, *stmt2, *stmt3;\n+  tree one;\n \n-  ref = tree_coverage_counter_ref (GCOV_COUNTER_ARCS, edgeno);\n   one = build_int_cst (gcov_type_node, 1);\n-  gcov_type_tmp_var = make_temp_ssa_name (gcov_type_node,\n-\t\t\t\t\t  NULL, \"PROF_edge_counter\");\n-  stmt1 = gimple_build_assign (gcov_type_tmp_var, ref);\n-  gcov_type_tmp_var = make_temp_ssa_name (gcov_type_node,\n-\t\t\t\t\t  NULL, \"PROF_edge_counter\");\n-  stmt2 = gimple_build_assign (gcov_type_tmp_var, PLUS_EXPR,\n-\t\t\t       gimple_assign_lhs (stmt1), one);\n-  stmt3 = gimple_build_assign (unshare_expr (ref), gimple_assign_lhs (stmt2));\n-  gsi_insert_on_edge (e, stmt1);\n-  gsi_insert_on_edge (e, stmt2);\n-  gsi_insert_on_edge (e, stmt3);\n+\n+  if (flag_profile_update == PROFILE_UPDATE_ATOMIC)\n+    {\n+      /* __atomic_fetch_add (&counter, 1, MEMMODEL_RELAXED); */\n+      tree addr = tree_coverage_counter_addr (GCOV_COUNTER_ARCS, edgeno);\n+      gcall *stmt\n+\t= gimple_build_call (builtin_decl_explicit (GCOV_TYPE_ATOMIC_FETCH_ADD),\n+\t\t\t     3, addr, one,\n+\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t    MEMMODEL_RELAXED));\n+      gsi_insert_on_edge (e, stmt);\n+    }\n+  else\n+    {\n+      tree ref = tree_coverage_counter_ref (GCOV_COUNTER_ARCS, edgeno);\n+      tree gcov_type_tmp_var = make_temp_ssa_name (gcov_type_node,\n+\t\t\t\t\t\t   NULL, \"PROF_edge_counter\");\n+      gassign *stmt1 = gimple_build_assign (gcov_type_tmp_var, ref);\n+      gcov_type_tmp_var = make_temp_ssa_name (gcov_type_node,\n+\t\t\t\t\t      NULL, \"PROF_edge_counter\");\n+      gassign *stmt2 = gimple_build_assign (gcov_type_tmp_var, PLUS_EXPR,\n+\t\t\t\t\t    gimple_assign_lhs (stmt1), one);\n+      gassign *stmt3 = gimple_build_assign (unshare_expr (ref),\n+\t\t\t\t\t    gimple_assign_lhs (stmt2));\n+      gsi_insert_on_edge (e, stmt1);\n+      gsi_insert_on_edge (e, stmt2);\n+      gsi_insert_on_edge (e, stmt3);\n+    }\n }\n \n /* Emits code to get VALUE to instrument at GSI, and returns the"}]}