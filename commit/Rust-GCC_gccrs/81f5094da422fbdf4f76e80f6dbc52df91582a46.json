{"sha": "81f5094da422fbdf4f76e80f6dbc52df91582a46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFmNTA5NGRhNDIyZmJkZjRmNzZlODBmNmRiYzUyZGY5MTU4MmE0Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-11-20T21:35:03Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-11-20T21:35:03Z"}, "message": "re PR middle-end/29215 (extra store for memcpy)\n\n\tPR middle-end/29215\n\t* builtins.c (SLOW_UNALIGNED_ACCESS): Define if not defined.\n\t(fold_builtin_memory_op): Handle even the case where just one\n\tof src and dest is an address of a var decl component, using\n\tTYPE_REF_CAN_ALIAS_ALL pointers.  Remove is_gimple_min_invariant\n\tand readonly_data_expr src check.\n\t* tree-ssa-sccvn.c (DFS): Use clear_and_done_ssa_iter to shut\n\tup warnings.\n\n\t* trans-array.c (trans_array_constructor_value,\n\tgfc_build_constant_array_constructor): Fill in TREE_PURPOSE.\n\n\t* gfortran.dg/array_memcpy_3.f90: Adjust pattern to match even\n\tmemcpy optimized into ref-all store.\n\t* gcc.dg/pr29215.c: New test.\n\nFrom-SVN: r142061", "tree": {"sha": "0cc48991865f78326414c0d9ce7c0db3f4e962e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cc48991865f78326414c0d9ce7c0db3f4e962e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81f5094da422fbdf4f76e80f6dbc52df91582a46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81f5094da422fbdf4f76e80f6dbc52df91582a46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81f5094da422fbdf4f76e80f6dbc52df91582a46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81f5094da422fbdf4f76e80f6dbc52df91582a46/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1fd8faf0599d4054a7a6118c35fc0ef6c2db5e4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fd8faf0599d4054a7a6118c35fc0ef6c2db5e4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fd8faf0599d4054a7a6118c35fc0ef6c2db5e4a"}], "stats": {"total": 183, "additions": 148, "deletions": 35}, "files": [{"sha": "5ef81903a9f64775eb02b1e8ce704491e22f11e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f5094da422fbdf4f76e80f6dbc52df91582a46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f5094da422fbdf4f76e80f6dbc52df91582a46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81f5094da422fbdf4f76e80f6dbc52df91582a46", "patch": "@@ -1,5 +1,14 @@\n 2008-11-20  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/29215\n+\t* builtins.c (SLOW_UNALIGNED_ACCESS): Define if not defined.\n+\t(fold_builtin_memory_op): Handle even the case where just one\n+\tof src and dest is an address of a var decl component, using\n+\tTYPE_REF_CAN_ALIAS_ALL pointers.  Remove is_gimple_min_invariant\n+\tand readonly_data_expr src check.\n+\t* tree-ssa-sccvn.c (DFS): Use clear_and_done_ssa_iter to shut\n+\tup warnings.\n+\n \tPR rtl-optimization/36998\n \t* dwarf2out.c (stack_adjust_offset): Add cur_args_size and cur_offset\n \targuments.  Handle sp = reg and (set (foo) (mem (pre_inc (reg sp))))."}, {"sha": "0e5b834fde4531557ebc84e82f5c3359b4d49f54", "filename": "gcc/builtins.c", "status": "modified", "additions": 88, "deletions": 31, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f5094da422fbdf4f76e80f6dbc52df91582a46/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f5094da422fbdf4f76e80f6dbc52df91582a46/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=81f5094da422fbdf4f76e80f6dbc52df91582a46", "patch": "@@ -51,6 +51,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"value-prof.h\"\n #include \"diagnostic.h\"\n \n+#ifndef SLOW_UNALIGNED_ACCESS\n+#define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) STRICT_ALIGNMENT\n+#endif\n+\n #ifndef PAD_VARARGS_DOWN\n #define PAD_VARARGS_DOWN BYTES_BIG_ENDIAN\n #endif\n@@ -8824,10 +8828,12 @@ fold_builtin_memory_op (tree dest, tree src, tree len, tree type, bool ignore, i\n   else\n     {\n       tree srctype, desttype;\n+      int src_align, dest_align;\n+\n       if (endp == 3)\n \t{\n-          int src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n-          int dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+\t  src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n+\t  dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n \n \t  /* Both DEST and SRC must be pointer types. \n \t     ??? This is what old code did.  Is the testing for pointer types\n@@ -8862,44 +8868,95 @@ fold_builtin_memory_op (tree dest, tree src, tree len, tree type, bool ignore, i\n \t  || !TYPE_SIZE_UNIT (srctype)\n \t  || !TYPE_SIZE_UNIT (desttype)\n \t  || TREE_CODE (TYPE_SIZE_UNIT (srctype)) != INTEGER_CST\n-\t  || TREE_CODE (TYPE_SIZE_UNIT (desttype)) != INTEGER_CST\n-\t  || !tree_int_cst_equal (TYPE_SIZE_UNIT (srctype), len)\n-\t  || !tree_int_cst_equal (TYPE_SIZE_UNIT (desttype), len))\n+\t  || TREE_CODE (TYPE_SIZE_UNIT (desttype)) != INTEGER_CST)\n \treturn NULL_TREE;\n \n-      if (get_pointer_alignment (dest, BIGGEST_ALIGNMENT) \n-\t  < (int) TYPE_ALIGN (desttype)\n-\t  || (get_pointer_alignment (src, BIGGEST_ALIGNMENT) \n-\t      < (int) TYPE_ALIGN (srctype)))\n+      src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n+      dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+      if (dest_align < (int) TYPE_ALIGN (desttype)\n+\t  || src_align < (int) TYPE_ALIGN (srctype))\n \treturn NULL_TREE;\n \n       if (!ignore)\n         dest = builtin_save_expr (dest);\n \n-      srcvar = build_fold_indirect_ref (src);\n-      if (TREE_THIS_VOLATILE (srcvar))\n-\treturn NULL_TREE;\n-      if (!tree_int_cst_equal (lang_hooks.expr_size (srcvar), len))\n-\treturn NULL_TREE;\n-      /* With memcpy, it is possible to bypass aliasing rules, so without\n-         this check i.e. execute/20060930-2.c would be misoptimized, because\n-\t it use conflicting alias set to hold argument for the memcpy call.\n-\t This check is probably unnecessary with -fno-strict-aliasing.\n-\t Similarly for destvar.  See also PR29286.  */\n-      if (!var_decl_component_p (srcvar)\n-\t  /* Accept: memcpy (*char_var, \"test\", 1); that simplify\n-\t     to char_var='t';  */\n-\t  || is_gimple_min_invariant (srcvar)\n-\t  || readonly_data_expr (src))\n+      srcvar = NULL_TREE;\n+      if (tree_int_cst_equal (TYPE_SIZE_UNIT (srctype), len))\n+\t{\n+\t  srcvar = build_fold_indirect_ref (src);\n+\t  if (TREE_THIS_VOLATILE (srcvar))\n+\t    srcvar = NULL_TREE;\n+\t  else if (!tree_int_cst_equal (lang_hooks.expr_size (srcvar), len))\n+\t    srcvar = NULL_TREE;\n+\t  /* With memcpy, it is possible to bypass aliasing rules, so without\n+\t     this check i.e. execute/20060930-2.c would be misoptimized,\n+\t     because it use conflicting alias set to hold argument for the\n+\t     memcpy call.  This check is probably unnecessary with\n+\t     -fno-strict-aliasing.  Similarly for destvar.  See also\n+\t     PR29286.  */\n+\t  else if (!var_decl_component_p (srcvar))\n+\t    srcvar = NULL_TREE;\n+\t}\n+\n+      destvar = NULL_TREE;\n+      if (tree_int_cst_equal (TYPE_SIZE_UNIT (desttype), len))\n+\t{\n+\t  destvar = build_fold_indirect_ref (dest);\n+\t  if (TREE_THIS_VOLATILE (destvar))\n+\t    destvar = NULL_TREE;\n+\t  else if (!tree_int_cst_equal (lang_hooks.expr_size (destvar), len))\n+\t    destvar = NULL_TREE;\n+\t  else if (!var_decl_component_p (destvar))\n+\t    destvar = NULL_TREE;\n+\t}\n+\n+      if (srcvar == NULL_TREE && destvar == NULL_TREE)\n \treturn NULL_TREE;\n \n-      destvar = build_fold_indirect_ref (dest);\n-      if (TREE_THIS_VOLATILE (destvar))\n-\treturn NULL_TREE;\n-      if (!tree_int_cst_equal (lang_hooks.expr_size (destvar), len))\n-\treturn NULL_TREE;\n-      if (!var_decl_component_p (destvar))\n-\treturn NULL_TREE;\n+      if (srcvar == NULL_TREE)\n+\t{\n+\t  tree srcptype;\n+\t  if (TREE_ADDRESSABLE (TREE_TYPE (destvar)))\n+\t    return NULL_TREE;\n+\n+\t  srctype = desttype;\n+\t  if (src_align < (int) TYPE_ALIGN (srctype))\n+\t    {\n+\t      if (AGGREGATE_TYPE_P (srctype)\n+\t\t  || SLOW_UNALIGNED_ACCESS (TYPE_MODE (srctype), src_align))\n+\t\treturn NULL_TREE;\n+\n+\t      srctype = build_variant_type_copy (srctype);\n+\t      TYPE_ALIGN (srctype) = src_align;\n+\t      TYPE_USER_ALIGN (srctype) = 1;\n+\t      TYPE_PACKED (srctype) = 1;\n+\t    }\n+\t  srcptype = build_pointer_type_for_mode (srctype, ptr_mode, true);\n+\t  src = fold_convert (srcptype, src);\n+\t  srcvar = build_fold_indirect_ref (src);\n+\t}\n+      else if (destvar == NULL_TREE)\n+\t{\n+\t  tree destptype;\n+\t  if (TREE_ADDRESSABLE (TREE_TYPE (srcvar)))\n+\t    return NULL_TREE;\n+\n+\t  desttype = srctype;\n+\t  if (dest_align < (int) TYPE_ALIGN (desttype))\n+\t    {\n+\t      if (AGGREGATE_TYPE_P (desttype)\n+\t\t  || SLOW_UNALIGNED_ACCESS (TYPE_MODE (desttype), dest_align))\n+\t\treturn NULL_TREE;\n+\n+\t      desttype = build_variant_type_copy (desttype);\n+\t      TYPE_ALIGN (desttype) = dest_align;\n+\t      TYPE_USER_ALIGN (desttype) = 1;\n+\t      TYPE_PACKED (desttype) = 1;\n+\t    }\n+\t  destptype = build_pointer_type_for_mode (desttype, ptr_mode, true);\n+\t  dest = fold_convert (destptype, dest);\n+\t  destvar = build_fold_indirect_ref (dest);\n+\t}\n \n       if (srctype == desttype\n \t  || (gimple_in_ssa_p (cfun)"}, {"sha": "941186fcbd57eed1218644b7d579bdde38ebe03a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f5094da422fbdf4f76e80f6dbc52df91582a46/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f5094da422fbdf4f76e80f6dbc52df91582a46/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=81f5094da422fbdf4f76e80f6dbc52df91582a46", "patch": "@@ -1,5 +1,9 @@\n 2008-11-20  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/29215\n+\t* trans-array.c (trans_array_constructor_value,\n+\tgfc_build_constant_array_constructor): Fill in TREE_PURPOSE.\n+\n \t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc): Use\n \tgfc_index_one_node.\n \t(gfc_conv_intrinsic_size): Use gfc_index_{zero,one}_node."}, {"sha": "1385409808e4d64f4c72dcd52aaf6709933de118", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f5094da422fbdf4f76e80f6dbc52df91582a46/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f5094da422fbdf4f76e80f6dbc52df91582a46/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=81f5094da422fbdf4f76e80f6dbc52df91582a46", "patch": "@@ -1235,6 +1235,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t      tree init;\n \t      tree bound;\n \t      tree tmptype;\n+\t      HOST_WIDE_INT idx = 0;\n \n \t      p = c;\n \t      list = NULL_TREE;\n@@ -1253,7 +1254,8 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t\t\t\t(gfc_get_pchar_type (p->expr->ts.kind),\n \t\t\t\t se.expr);\n \n-\t\t  list = tree_cons (NULL_TREE, se.expr, list);\n+\t\t  list = tree_cons (build_int_cst (gfc_array_index_type,\n+\t\t\t\t\t\t   idx++), se.expr, list);\n \t\t  c = p;\n \t\t  p = p->next;\n \t\t}\n@@ -1619,7 +1621,8 @@ gfc_build_constant_array_constructor (gfc_expr * expr, tree type)\n       if (c->expr->ts.type == BT_CHARACTER && POINTER_TYPE_P (type))\n \tse.expr = gfc_build_addr_expr (gfc_get_pchar_type (c->expr->ts.kind),\n \t\t\t\t       se.expr);\n-      list = tree_cons (NULL_TREE, se.expr, list);\n+      list = tree_cons (build_int_cst (gfc_array_index_type, nelem),\n+\t\t\tse.expr, list);\n       c = c->next;\n       nelem++;\n     }"}, {"sha": "3a767f1d0ba8ae6d5616229bb3b3af9010f518da", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f5094da422fbdf4f76e80f6dbc52df91582a46/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f5094da422fbdf4f76e80f6dbc52df91582a46/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=81f5094da422fbdf4f76e80f6dbc52df91582a46", "patch": "@@ -1,3 +1,10 @@\n+2008-11-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/29215\n+\t* gfortran.dg/array_memcpy_3.f90: Adjust pattern to match even\n+\tmemcpy optimized into ref-all store.\n+\t* gcc.dg/pr29215.c: New test.\n+\n 2008-11-19  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/38151"}, {"sha": "aa3f82ce0e1497fc768e880a9bc208f61e4a1768", "filename": "gcc/testsuite/gcc.dg/pr29215.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f5094da422fbdf4f76e80f6dbc52df91582a46/gcc%2Ftestsuite%2Fgcc.dg%2Fpr29215.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f5094da422fbdf4f76e80f6dbc52df91582a46/gcc%2Ftestsuite%2Fgcc.dg%2Fpr29215.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr29215.c?ref=81f5094da422fbdf4f76e80f6dbc52df91582a46", "patch": "@@ -0,0 +1,33 @@\n+/* PR middle-end/29215 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-gimple\" } */\n+\n+char buf[5 * sizeof (int) + 1] __attribute__((aligned (__alignof__ (int))));\n+\n+static void\n+foo (int arg1, int arg2, int arg3, int arg4, int arg5)\n+{\n+  __builtin_memcpy (buf, &arg1, sizeof (int));\n+  __builtin_memcpy (buf + sizeof (int), &arg2, sizeof (int));\n+  __builtin_memcpy (buf + 2 * sizeof (int), &arg3, sizeof (int));\n+  __builtin_memcpy (buf + 3 * sizeof (int), &arg4, sizeof (int));\n+  __builtin_memcpy (buf + 4 * sizeof (int), &arg5, sizeof (int));\n+}\n+\n+int\n+main (void)\n+{\n+  union { char buf[4]; int i; } u;\n+  u.i = 0;\n+  u.buf[0] = 'a';\n+  u.buf[1] = 'b';\n+  u.buf[2] = 'c';\n+  u.buf[3] = 'd';\n+  foo (u.i, u.i, u.i, u.i, u.i);\n+  buf[5 * sizeof (int)] = '\\0';\n+  __builtin_puts (buf);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"memcpy\" \"gimple\" } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "df6bd49ef26efca7a9507e09348e68a9fbbe9be0", "filename": "gcc/testsuite/gfortran.dg/array_memcpy_3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f5094da422fbdf4f76e80f6dbc52df91582a46/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f5094da422fbdf4f76e80f6dbc52df91582a46/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_3.f90?ref=81f5094da422fbdf4f76e80f6dbc52df91582a46", "patch": "@@ -11,5 +11,5 @@ subroutine bar(x)\n   x = (/ 3, 1, 4, 1 /)\n end subroutine\n \n-! { dg-final { scan-tree-dump-times \"memcpy\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"memcpy|ref-all\" 2 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "e40681f935546c05b2eb7bd0204ac2b60d505e96", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f5094da422fbdf4f76e80f6dbc52df91582a46/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f5094da422fbdf4f76e80f6dbc52df91582a46/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=81f5094da422fbdf4f76e80f6dbc52df91582a46", "patch": "@@ -2654,7 +2654,7 @@ DFS (tree name)\n \tusep = op_iter_init_use (&iter, defstmt, SSA_OP_ALL_USES);\n     }\n   else\n-    iter.done = true;\n+    clear_and_done_ssa_iter (&iter);\n \n   while (1)\n     {"}]}