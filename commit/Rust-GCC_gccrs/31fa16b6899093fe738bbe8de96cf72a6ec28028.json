{"sha": "31fa16b6899093fe738bbe8de96cf72a6ec28028", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFmYTE2YjY4OTkwOTNmZTczOGJiZThkZTk2Y2Y3MmE2ZWMyODAyOA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2005-09-10T08:28:32Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2005-09-10T08:28:32Z"}, "message": "arm.c (arm_gen_rotated_half_load): Delete.\n\n\t* arm.c (arm_gen_rotated_half_load): Delete.\n\t(vfp_emit_fstmx, arm_set_return_address): Use gen_frame_mem.\n\t(emit_multi_reg_push, emit_sfm, arm_expand_prologue)\n\t(thumb_set_return_address): Likewise.\n\t(thumb_load_double_from_address): Use adjust_address.\n\t* arm.md (splits calling arm_gen_rotated_half_load): Delete.\n\t(extendhsisi2_mem, movhi_bytes): Use change_address.\n\t(movhi): Use widen_memory_access.\n\t(reload_out_df): Use replace_equiv_address.\n\t* arm-protos.h (arm_gen_rotated_half_load): Delete prototype.\n\nFrom-SVN: r104124", "tree": {"sha": "7863788d63e63518c26e8820f1d3be1f71a6c79f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7863788d63e63518c26e8820f1d3be1f71a6c79f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31fa16b6899093fe738bbe8de96cf72a6ec28028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31fa16b6899093fe738bbe8de96cf72a6ec28028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31fa16b6899093fe738bbe8de96cf72a6ec28028", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31fa16b6899093fe738bbe8de96cf72a6ec28028/comments", "author": null, "committer": null, "parents": [{"sha": "072dd139adddaa96f6740023544230ea054c2994", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/072dd139adddaa96f6740023544230ea054c2994", "html_url": "https://github.com/Rust-GCC/gccrs/commit/072dd139adddaa96f6740023544230ea054c2994"}], "stats": {"total": 191, "additions": 58, "deletions": 133}, "files": [{"sha": "fc8466f020b1ac87683a7a7031e6c0d69ae9b724", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31fa16b6899093fe738bbe8de96cf72a6ec28028/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31fa16b6899093fe738bbe8de96cf72a6ec28028/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31fa16b6899093fe738bbe8de96cf72a6ec28028", "patch": "@@ -1,3 +1,16 @@\n+2005-09-10  Richard Earnshaw  <richard.earnshaw@arm.com>\n+\n+\t* arm.c (arm_gen_rotated_half_load): Delete.\n+\t(vfp_emit_fstmx, arm_set_return_address): Use gen_frame_mem.\n+\t(emit_multi_reg_push, emit_sfm, arm_expand_prologue)\n+\t(thumb_set_return_address): Likewise.\n+\t(thumb_load_double_from_address): Use adjust_address.\n+\t* arm.md (splits calling arm_gen_rotated_half_load): Delete.\n+\t(extendhsisi2_mem, movhi_bytes): Use change_address.\n+\t(movhi): Use widen_memory_access.\n+\t(reload_out_df): Use replace_equiv_address.\n+\t* arm-protos.h (arm_gen_rotated_half_load): Delete prototype.\n+\n 2005-09-09  Richard Henderson  <rth@redhat.com>\n \n \tPR debug/20998"}, {"sha": "b8913a1cf595b74b837a8cf92bd3d53889325221", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31fa16b6899093fe738bbe8de96cf72a6ec28028/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31fa16b6899093fe738bbe8de96cf72a6ec28028/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=31fa16b6899093fe738bbe8de96cf72a6ec28028", "patch": "@@ -87,7 +87,6 @@ extern rtx arm_gen_load_multiple (int, int, rtx, int, int,\n extern rtx arm_gen_store_multiple (int, int, rtx, int, int,\n \t\t\t\t   rtx, HOST_WIDE_INT *);\n extern int arm_gen_movmemqi (rtx *);\n-extern rtx arm_gen_rotated_half_load (rtx);\n extern enum machine_mode arm_select_cc_mode (RTX_CODE, rtx, rtx);\n extern enum machine_mode arm_select_dominance_cc_mode (rtx, rtx,\n \t\t\t\t\t\t       HOST_WIDE_INT);"}, {"sha": "60acf36d1f1ebe4374f6b9f5539545de3b405d47", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 36, "deletions": 60, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31fa16b6899093fe738bbe8de96cf72a6ec28028/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31fa16b6899093fe738bbe8de96cf72a6ec28028/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=31fa16b6899093fe738bbe8de96cf72a6ec28028", "patch": "@@ -6117,30 +6117,6 @@ arm_gen_movmemqi (rtx *operands)\n    into the top 16 bits of the word.  We can assume that the address is\n    known to be alignable and of the form reg, or plus (reg, const).  */\n \n-rtx\n-arm_gen_rotated_half_load (rtx memref)\n-{\n-  HOST_WIDE_INT offset = 0;\n-  rtx base = XEXP (memref, 0);\n-\n-  if (GET_CODE (base) == PLUS)\n-    {\n-      offset = INTVAL (XEXP (base, 1));\n-      base = XEXP (base, 0);\n-    }\n-\n-  /* If we aren't allowed to generate unaligned addresses, then fail.  */\n-  if ((BYTES_BIG_ENDIAN ? 1 : 0) ^ ((offset & 2) == 0))\n-    return NULL;\n-\n-  base = gen_rtx_MEM (SImode, plus_constant (base, offset & ~2));\n-\n-  if ((BYTES_BIG_ENDIAN ? 1 : 0) ^ ((offset & 2) == 2))\n-    return base;\n-\n-  return gen_rtx_ROTATE (SImode, base, GEN_INT (16));\n-}\n-\n /* Select a dominance comparison mode if possible for a test of the general\n    form (OP (COND_OR (X) (Y)) (const_int 0)).  We support three forms.\n    COND_OR == DOM_CC_X_AND_Y => (X && Y)\n@@ -8128,8 +8104,9 @@ vfp_emit_fstmx (int base_reg, int count)\n \n   XVECEXP (par, 0, 0)\n     = gen_rtx_SET (VOIDmode,\n-\t\t   gen_rtx_MEM (BLKmode,\n-\t\t\t\tgen_rtx_PRE_DEC (BLKmode, stack_pointer_rtx)),\n+\t\t   gen_frame_mem (BLKmode,\n+\t\t\t\t  gen_rtx_PRE_DEC (BLKmode,\n+\t\t\t\t\t\t   stack_pointer_rtx)),\n \t\t   gen_rtx_UNSPEC (BLKmode,\n \t\t\t\t   gen_rtvec (1, reg),\n \t\t\t\t   UNSPEC_PUSH_MULT));\n@@ -8141,7 +8118,7 @@ vfp_emit_fstmx (int base_reg, int count)\n   XVECEXP (dwarf, 0, 0) = tmp;\n \n   tmp = gen_rtx_SET (VOIDmode,\n-\t\t     gen_rtx_MEM (DFmode, stack_pointer_rtx),\n+\t\t     gen_frame_mem (DFmode, stack_pointer_rtx),\n \t\t     reg);\n   RTX_FRAME_RELATED_P (tmp) = 1;\n   XVECEXP (dwarf, 0, 1) = tmp;\n@@ -8153,10 +8130,10 @@ vfp_emit_fstmx (int base_reg, int count)\n       XVECEXP (par, 0, i) = gen_rtx_USE (VOIDmode, reg);\n \n       tmp = gen_rtx_SET (VOIDmode,\n-\t\t\t gen_rtx_MEM (DFmode,\n-\t\t\t\t      gen_rtx_PLUS (SImode,\n-\t\t\t\t\t\t    stack_pointer_rtx,\n-\t\t\t\t\t\t    GEN_INT (i * 8))),\n+\t\t\t gen_frame_mem (DFmode,\n+\t\t\t\t\tgen_rtx_PLUS (SImode,\n+\t\t\t\t\t\t      stack_pointer_rtx,\n+\t\t\t\t\t\t      GEN_INT (i * 8))),\n \t\t\t reg);\n       RTX_FRAME_RELATED_P (tmp) = 1;\n       XVECEXP (dwarf, 0, i + 1) = tmp;\n@@ -9851,17 +9828,17 @@ emit_multi_reg_push (unsigned long mask)\n \n \t  XVECEXP (par, 0, 0)\n \t    = gen_rtx_SET (VOIDmode,\n-\t\t\t   gen_rtx_MEM (BLKmode,\n-\t\t\t\t\tgen_rtx_PRE_DEC (BLKmode,\n-\t\t\t\t\t\t\t stack_pointer_rtx)),\n+\t\t\t   gen_frame_mem (BLKmode,\n+\t\t\t\t\t  gen_rtx_PRE_DEC (BLKmode,\n+\t\t\t\t\t\t\t   stack_pointer_rtx)),\n \t\t\t   gen_rtx_UNSPEC (BLKmode,\n \t\t\t\t\t   gen_rtvec (1, reg),\n \t\t\t\t\t   UNSPEC_PUSH_MULT));\n \n \t  if (i != PC_REGNUM)\n \t    {\n \t      tmp = gen_rtx_SET (VOIDmode,\n-\t\t\t\t gen_rtx_MEM (SImode, stack_pointer_rtx),\n+\t\t\t\t gen_frame_mem (SImode, stack_pointer_rtx),\n \t\t\t\t reg);\n \t      RTX_FRAME_RELATED_P (tmp) = 1;\n \t      XVECEXP (dwarf, 0, dwarf_par_index) = tmp;\n@@ -9882,11 +9859,12 @@ emit_multi_reg_push (unsigned long mask)\n \n \t  if (i != PC_REGNUM)\n \t    {\n-\t      tmp = gen_rtx_SET (VOIDmode,\n-\t\t\t\t gen_rtx_MEM (SImode,\n+\t      tmp\n+\t\t= gen_rtx_SET (VOIDmode,\n+\t\t\t       gen_frame_mem (SImode,\n \t\t\t\t\t      plus_constant (stack_pointer_rtx,\n \t\t\t\t\t\t\t     4 * j)),\n-\t\t\t\t reg);\n+\t\t\t       reg);\n \t      RTX_FRAME_RELATED_P (tmp) = 1;\n \t      XVECEXP (dwarf, 0, dwarf_par_index++) = tmp;\n \t    }\n@@ -9939,13 +9917,14 @@ emit_sfm (int base_reg, int count)\n \n   XVECEXP (par, 0, 0)\n     = gen_rtx_SET (VOIDmode,\n-\t\t   gen_rtx_MEM (BLKmode,\n-\t\t\t\tgen_rtx_PRE_DEC (BLKmode, stack_pointer_rtx)),\n+\t\t   gen_frame_mem (BLKmode,\n+\t\t\t\t  gen_rtx_PRE_DEC (BLKmode,\n+\t\t\t\t\t\t   stack_pointer_rtx)),\n \t\t   gen_rtx_UNSPEC (BLKmode,\n \t\t\t\t   gen_rtvec (1, reg),\n \t\t\t\t   UNSPEC_PUSH_MULT));\n   tmp = gen_rtx_SET (VOIDmode,\n-\t\t     gen_rtx_MEM (XFmode, stack_pointer_rtx), reg);\n+\t\t     gen_frame_mem (XFmode, stack_pointer_rtx), reg);\n   RTX_FRAME_RELATED_P (tmp) = 1;\n   XVECEXP (dwarf, 0, 1) = tmp;\n \n@@ -9955,9 +9934,9 @@ emit_sfm (int base_reg, int count)\n       XVECEXP (par, 0, i) = gen_rtx_USE (VOIDmode, reg);\n \n       tmp = gen_rtx_SET (VOIDmode,\n-\t\t\t gen_rtx_MEM (XFmode,\n-\t\t\t\t      plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t     i * 12)),\n+\t\t\t gen_frame_mem (XFmode,\n+\t\t\t\t\tplus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t       i * 12)),\n \t\t\t reg);\n       RTX_FRAME_RELATED_P (tmp) = 1;\n       XVECEXP (dwarf, 0, i + 1) = tmp;\n@@ -10309,7 +10288,7 @@ arm_expand_prologue (void)\n \t    {\n \t      rtx dwarf;\n \t      insn = gen_rtx_PRE_DEC (SImode, stack_pointer_rtx);\n-\t      insn = gen_rtx_MEM (SImode, insn);\n+\t      insn = gen_frame_mem (SImode, insn);\n \t      insn = gen_rtx_SET (VOIDmode, insn, ip_rtx);\n \t      insn = emit_insn (insn);\n \n@@ -10398,7 +10377,7 @@ arm_expand_prologue (void)\n       if (regs_ever_live[reg] && ! call_used_regs [reg])\n \t{\n \t  insn = gen_rtx_PRE_DEC (V2SImode, stack_pointer_rtx);\n-\t  insn = gen_rtx_MEM (V2SImode, insn);\n+\t  insn = gen_frame_mem (V2SImode, insn);\n \t  insn = emit_insn (gen_rtx_SET (VOIDmode, insn,\n \t\t\t\t\t gen_rtx_REG (V2SImode, reg)));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n@@ -10417,7 +10396,7 @@ arm_expand_prologue (void)\n \t    if (regs_ever_live[reg] && !call_used_regs[reg])\n \t      {\n \t\tinsn = gen_rtx_PRE_DEC (XFmode, stack_pointer_rtx);\n-\t\tinsn = gen_rtx_MEM (XFmode, insn);\n+\t\tinsn = gen_frame_mem (XFmode, insn);\n \t\tinsn = emit_insn (gen_rtx_SET (VOIDmode, insn,\n \t\t\t\t\t       gen_rtx_REG (XFmode, reg)));\n \t\tRTX_FRAME_RELATED_P (insn) = 1;\n@@ -10497,7 +10476,7 @@ arm_expand_prologue (void)\n \t    {\n \t      insn = gen_rtx_PLUS (SImode, hard_frame_pointer_rtx,\n \t\t\t\t   GEN_INT (4));\n-\t      insn = gen_rtx_MEM (SImode, insn);\n+\t      insn = gen_frame_mem (SImode, insn);\n \t    }\n \n \t  emit_insn (gen_rtx_SET (SImode, ip_rtx, insn));\n@@ -13716,9 +13695,8 @@ thumb_load_double_from_address (rtx *operands)\n   switch (GET_CODE (addr))\n     {\n     case REG:\n-      operands[2] = gen_rtx_MEM (SImode,\n-\t\t\t\t plus_constant (XEXP (operands[1], 0), 4));\n-\n+      operands[2] = adjust_address (operands[1], SImode, 4);\n+      \n       if (REGNO (operands[0]) == REGNO (addr))\n \t{\n \t  output_asm_insn (\"ldr\\t%H0, %2\", operands);\n@@ -13733,9 +13711,8 @@ thumb_load_double_from_address (rtx *operands)\n \n     case CONST:\n       /* Compute <address> + 4 for the high order load.  */\n-      operands[2] = gen_rtx_MEM (SImode,\n-\t\t\t\t plus_constant (XEXP (operands[1], 0), 4));\n-\n+      operands[2] = adjust_address (operands[1], SImode, 4);\n+      \n       output_asm_insn (\"ldr\\t%0, %1\", operands);\n       output_asm_insn (\"ldr\\t%H0, %2\", operands);\n       break;\n@@ -13776,8 +13753,8 @@ thumb_load_double_from_address (rtx *operands)\n       else\n \t{\n \t  /* Compute <address> + 4 for the high order load.  */\n-\t  operands[2] = gen_rtx_MEM (SImode,\n-\t\t\t\t     plus_constant (XEXP (operands[1], 0), 4));\n+\t  operands[2] = adjust_address (operands[1], SImode, 4);\n+\t  \n \n \t  /* If the computed address is held in the low order register\n \t     then load the high order register first, otherwise always\n@@ -13798,8 +13775,7 @@ thumb_load_double_from_address (rtx *operands)\n     case LABEL_REF:\n       /* With no registers to worry about we can just load the value\n          directly.  */\n-      operands[2] = gen_rtx_MEM (SImode,\n-\t\t\t\t plus_constant (XEXP (operands[1], 0), 4));\n+      operands[2] = adjust_address (operands[1], SImode, 4);\n \n       output_asm_insn (\"ldr\\t%H0, %2\", operands);\n       output_asm_insn (\"ldr\\t%0, %1\", operands);\n@@ -14694,7 +14670,7 @@ arm_set_return_address (rtx source, rtx scratch)\n \n \t  addr = plus_constant (addr, delta);\n \t}\n-      emit_move_insn (gen_rtx_MEM (Pmode, addr), source);\n+      emit_move_insn (gen_frame_mem (Pmode, addr), source);\n     }\n }\n \n@@ -14744,7 +14720,7 @@ thumb_set_return_address (rtx source, rtx scratch)\n       else\n \taddr = plus_constant (addr, delta);\n \n-      emit_move_insn (gen_rtx_MEM (Pmode, addr), source);\n+      emit_move_insn (gen_frame_mem (Pmode, addr), source);\n     }\n   else\n     emit_move_insn (gen_rtx_REG (Pmode, LR_REGNUM), source);"}, {"sha": "5d72af924ef8566b7c3698cc62742acd0bde6b2a", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 9, "deletions": 72, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31fa16b6899093fe738bbe8de96cf72a6ec28028/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31fa16b6899093fe738bbe8de96cf72a6ec28028/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=31fa16b6899093fe738bbe8de96cf72a6ec28028", "patch": "@@ -3390,36 +3390,6 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-(define_split\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(zero_extend:SI (match_operand:HI 1 \"alignable_memory_operand\" \"\")))\n-   (clobber (match_operand:SI 2 \"s_register_operand\" \"\"))]\n-  \"TARGET_ARM && (!arm_arch4)\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (lshiftrt:SI (match_dup 2) (const_int 16)))]\n-  \"\n-  if ((operands[1] = arm_gen_rotated_half_load (operands[1])) == NULL)\n-    FAIL;\n-  \"\n-)\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(match_operator:SI 3 \"shiftable_operator\"\n-\t [(zero_extend:SI (match_operand:HI 1 \"alignable_memory_operand\" \"\"))\n-\t  (match_operand:SI 4 \"s_register_operand\" \"\")]))\n-   (clobber (match_operand:SI 2 \"s_register_operand\" \"\"))]\n-  \"TARGET_ARM && (!arm_arch4)\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0)\n-\t(match_op_dup 3\n-\t [(lshiftrt:SI (match_dup 2) (const_int 16)) (match_dup 4)]))]\n-  \"\n-  if ((operands[1] = arm_gen_rotated_half_load (operands[1])) == NULL)\n-    FAIL;\n-  \"\n-)\n-\n (define_expand \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n@@ -3721,10 +3691,8 @@\n     rtx mem1, mem2;\n     rtx addr = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n \n-    mem1 = gen_rtx_MEM (QImode, addr);\n-    MEM_COPY_ATTRIBUTES (mem1, operands[1]);\n-    mem2 = gen_rtx_MEM (QImode, plus_constant (addr, 1));\n-    MEM_COPY_ATTRIBUTES (mem2, operands[1]);\n+    mem1 = change_address (operands[1], QImode, addr);\n+    mem2 = change_address (operands[1], QImode, plus_constant (addr, 1));\n     operands[0] = gen_lowpart (SImode, operands[0]);\n     operands[1] = mem1;\n     operands[2] = gen_reg_rtx (SImode);\n@@ -3777,35 +3745,6 @@\n   \"sxtah%?\\\\t%0, %2, %1\"\n )\n \n-(define_split\n-  [(set (match_operand:SI                 0 \"s_register_operand\" \"\")\n-\t(sign_extend:SI (match_operand:HI 1 \"alignable_memory_operand\" \"\")))\n-   (clobber (match_operand:SI             2 \"s_register_operand\" \"\"))]\n-  \"TARGET_ARM && (!arm_arch4)\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (ashiftrt:SI (match_dup 2) (const_int 16)))]\n-  \"\n-  if ((operands[1] = arm_gen_rotated_half_load (operands[1])) == NULL)\n-    FAIL;\n-  \"\n-)\n-\n-(define_split\n-  [(set (match_operand:SI                   0 \"s_register_operand\" \"\")\n-\t(match_operator:SI                  3 \"shiftable_operator\"\n-\t [(sign_extend:SI (match_operand:HI 1 \"alignable_memory_operand\" \"\"))\n-\t  (match_operand:SI                 4 \"s_register_operand\" \"\")]))\n-   (clobber (match_operand:SI               2 \"s_register_operand\" \"\"))]\n-  \"TARGET_ARM && (!arm_arch4)\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0)\n-\t(match_op_dup 3\n-\t [(ashiftrt:SI (match_dup 2) (const_int 16)) (match_dup 4)]))]\n-  \"if ((operands[1] = arm_gen_rotated_half_load (operands[1])) == NULL)\n-     FAIL;\n-  \"\n-)\n-\n (define_expand \"extendqihi2\"\n   [(set (match_dup 2)\n \t(ashift:SI (match_operand:QI 1 \"general_operand\" \"\")\n@@ -4750,12 +4689,11 @@\n \t\t\t   && GET_CODE (base = XEXP (base, 0)) == REG))\n \t\t      && REGNO_POINTER_ALIGN (REGNO (base)) >= 32)\n \t\t    {\n-\t\t      HOST_WIDE_INT new_offset = INTVAL (offset) & ~3;\n \t\t      rtx new;\n \n-\t\t      new = gen_rtx_MEM (SImode,\n-\t\t\t\t\t plus_constant (base, new_offset));\n-\t              MEM_COPY_ATTRIBUTES (new, operands[1]);\n+\t\t      new = widen_memory_access (operands[1], SImode,\n+\t\t\t\t\t\t ((INTVAL (offset) & ~3)\n+\t\t\t\t\t\t  - INTVAL (offset)));\n \t\t      emit_insn (gen_movsi (reg, new));\n \t\t      if (((INTVAL (offset) & 2) != 0)\n \t\t\t  ^ (BYTES_BIG_ENDIAN ? 1 : 0))\n@@ -4882,10 +4820,8 @@\n     rtx mem1, mem2;\n     rtx addr = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n \n-    mem1 = gen_rtx_MEM (QImode, addr);\n-    MEM_COPY_ATTRIBUTES (mem1, operands[1]);\n-    mem2 = gen_rtx_MEM (QImode, plus_constant (addr, 1));\n-    MEM_COPY_ATTRIBUTES (mem2, operands[1]);\n+    mem1 = change_address (operands[1], QImode, addr);\n+    mem2 = change_address (operands[1], QImode, plus_constant (addr, 1));\n     operands[0] = gen_lowpart (SImode, operands[0]);\n     operands[1] = mem1;\n     operands[2] = gen_reg_rtx (SImode);\n@@ -5233,7 +5169,8 @@\n       emit_insn (gen_addsi3 (operands[2], XEXP (XEXP (operands[0], 0), 0),\n \t\t\t     XEXP (XEXP (operands[0], 0), 1)));\n \n-    emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_MEM (DFmode, operands[2]),\n+    emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t    replace_equiv_address (operands[0], operands[2]),\n \t\t\t    operands[1]));\n \n     if (code == POST_DEC)"}]}