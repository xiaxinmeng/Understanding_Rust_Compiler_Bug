{"sha": "537e035c48955b3ea88dcb3a4b0ff03ef4bb2e31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM3ZTAzNWM0ODk1NWIzZWE4OGRjYjNhNGIwZmYwM2VmNGJiMmUzMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-08-13T10:26:40Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-08-13T10:26:40Z"}, "message": "utils2.c (build_atomic_load): Do a mere view-conversion to the original type before converting to the result type.\n\n\t* gcc-interface/utils2.c (build_atomic_load): Do a mere view-conversion\n\tto the original type before converting to the result type.\n\t(build_atomic_store): First do a conversion to the original type before\n\tview-converting to the effective type, but deal with a padded type\n\tspecially.\n\nFrom-SVN: r201682", "tree": {"sha": "fb3c96501d1d6d6055e09aec228353590a1c90e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb3c96501d1d6d6055e09aec228353590a1c90e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/537e035c48955b3ea88dcb3a4b0ff03ef4bb2e31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/537e035c48955b3ea88dcb3a4b0ff03ef4bb2e31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/537e035c48955b3ea88dcb3a4b0ff03ef4bb2e31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/537e035c48955b3ea88dcb3a4b0ff03ef4bb2e31/comments", "author": null, "committer": null, "parents": [{"sha": "3944d88d35e71f0aaf58c2c82bc7cf34414cb6ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3944d88d35e71f0aaf58c2c82bc7cf34414cb6ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3944d88d35e71f0aaf58c2c82bc7cf34414cb6ac"}], "stats": {"total": 40, "additions": 31, "deletions": 9}, "files": [{"sha": "e8d538980ff9e474bf6fed6b996ca0cabe6c3383", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/537e035c48955b3ea88dcb3a4b0ff03ef4bb2e31/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/537e035c48955b3ea88dcb3a4b0ff03ef4bb2e31/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=537e035c48955b3ea88dcb3a4b0ff03ef4bb2e31", "patch": "@@ -1,3 +1,11 @@\n+2013-08-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils2.c (build_atomic_load): Do a mere view-conversion\n+\tto the original type before converting to the result type.\n+\t(build_atomic_store): First do a conversion to the original type before\n+\tview-converting to the effective type, but deal with a padded type\n+\tspecially.\n+\n 2013-08-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/Makefile.in (TOOLS_LIBS): Pick C object files from the"}, {"sha": "64f7564a75d008fff92d7640cea98d68ac556370", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/537e035c48955b3ea88dcb3a4b0ff03ef4bb2e31/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/537e035c48955b3ea88dcb3a4b0ff03ef4bb2e31/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=537e035c48955b3ea88dcb3a4b0ff03ef4bb2e31", "patch": "@@ -648,11 +648,11 @@ build_atomic_load (tree src)\n       (build_qualified_type (void_type_node, TYPE_QUAL_VOLATILE));\n   tree mem_model = build_int_cst (integer_type_node, MEMMODEL_SEQ_CST);\n   tree orig_src = src;\n-  tree type = TREE_TYPE (src);\n-  tree t, val;\n+  tree t, addr, val;\n   unsigned int size;\n   int fncode;\n \n+  /* Remove conversions to get the address of the underlying object.  */\n   src = remove_conversions (src, false);\n   size = resolve_atomic_size (TREE_TYPE (src));\n   if (size == 0)\n@@ -661,10 +661,13 @@ build_atomic_load (tree src)\n   fncode = (int) BUILT_IN_ATOMIC_LOAD_N + exact_log2 (size) + 1;\n   t = builtin_decl_implicit ((enum built_in_function) fncode);\n \n-  src = build_unary_op (ADDR_EXPR, ptr_type, src);\n-  val = build_call_expr (t, 2, src, mem_model);\n+  addr = build_unary_op (ADDR_EXPR, ptr_type, src);\n+  val = build_call_expr (t, 2, addr, mem_model);\n \n-  return unchecked_convert (type, val, true);\n+  /* First reinterpret the loaded bits in the original type of the load,\n+     then convert to the expected result type.  */\n+  t = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (src), val);\n+  return convert (TREE_TYPE (orig_src), t);\n }\n \n /* Build an atomic store from SRC to the underlying atomic object in DEST.  */\n@@ -677,10 +680,11 @@ build_atomic_store (tree dest, tree src)\n       (build_qualified_type (void_type_node, TYPE_QUAL_VOLATILE));\n   tree mem_model = build_int_cst (integer_type_node, MEMMODEL_SEQ_CST);\n   tree orig_dest = dest;\n-  tree t, int_type;\n+  tree t, int_type, addr;\n   unsigned int size;\n   int fncode;\n \n+  /* Remove conversions to get the address of the underlying object.  */\n   dest = remove_conversions (dest, false);\n   size = resolve_atomic_size (TREE_TYPE (dest));\n   if (size == 0)\n@@ -690,10 +694,20 @@ build_atomic_store (tree dest, tree src)\n   t = builtin_decl_implicit ((enum built_in_function) fncode);\n   int_type = gnat_type_for_size (BITS_PER_UNIT * size, 1);\n \n-  dest = build_unary_op (ADDR_EXPR, ptr_type, dest);\n-  src = unchecked_convert (int_type, src, true);\n+  /* First convert the bits to be stored to the original type of the store,\n+     then reinterpret them in the effective type.  But if the original type\n+     is a padded type with the same size, convert to the inner type instead,\n+     as we don't want to artificially introduce a CONSTRUCTOR here.  */\n+  if (TYPE_IS_PADDING_P (TREE_TYPE (dest))\n+      && TYPE_SIZE (TREE_TYPE (dest))\n+\t == TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (dest)))))\n+    src = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (dest))), src);\n+  else\n+    src = convert (TREE_TYPE (dest), src);\n+  src = fold_build1 (VIEW_CONVERT_EXPR, int_type, src);\n+  addr = build_unary_op (ADDR_EXPR, ptr_type, dest);\n \n-  return build_call_expr (t, 3, dest, src, mem_model);\n+  return build_call_expr (t, 3, addr, src, mem_model);\n }\n \f\n /* Make a binary operation of kind OP_CODE.  RESULT_TYPE is the type"}]}