{"sha": "2c16dfe6268eeeb4b7924ff423e274fa00894a4d", "node_id": "C_kwDOANBUbNoAKDJjMTZkZmU2MjY4ZWVlYjRiNzkyNGZmNDIzZTI3NGZhMDA4OTRhNGQ", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-01-11T20:57:39Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-01-12T14:59:08Z"}, "message": "analyzer: complain about tainted sizes with \"access\" attribute [PR103940]\n\nGCC 10 gained the \"access\" function and type attribute, which\noptionally can take a size-index param:\n  https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html\n\n-fanalyzer in trunk (for GCC 12) has gained a -Wanalyzer-tainted-size to\ncomplain about attacker-controlled size values, but this was only being\nused deep inside the region-model code when handling the hardcoded known\nbehavior of certain functions (memset, IIRC).\n\nThis patch extends -Wanalyzer-tainted-size to also complain about\nunsanitized attacker-controlled values being passed to function\nparameters marked as a size via the \"access\" attribute.\n\nNote that -fanalyzer-checker=taint is currently required in\naddition to -fanalyzer to use this warning, due to scaling issues\n(see bug 103533).\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/103940\n\t* engine.cc (impl_sm_context::impl_sm_context): Add\n\t\"unknown_side_effects\" param and use it to initialize\n\tnew m_unknown_side_effects field.\n\t(impl_sm_context::unknown_side_effects_p): New.\n\t(impl_sm_context::m_unknown_side_effects): New.\n\t(exploded_node::on_stmt): Pass unknown_side_effects to sm_ctxt\n\tctor.\n\t* sm-taint.cc: Include \"stringpool.h\" and \"attribs.h\".\n\t(tainted_size::tainted_size): Drop \"dir\" param.\n\t(tainted_size::get_kind): Drop \"FINAL\".\n\t(tainted_size::emit): Likewise.\n\t(tainted_size::m_dir): Drop unused field.\n\t(class tainted_access_attrib_size): New subclass.\n\t(taint_state_machine::on_stmt): Call check_for_tainted_size_arg on\n\texternal functions with unknown side effects.\n\t(taint_state_machine::check_for_tainted_size_arg): New.\n\t(region_model::check_region_for_taint): Drop \"dir\" param from\n\ttainted_size ctor.\n\t* sm.h (sm_context::unknown_side_effects_p): New.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/103940\n\t* gcc.dg/analyzer/taint-size-access-attr-1.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "268cddf77cc4ebc624d37b9b7641439b0db2f90c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/268cddf77cc4ebc624d37b9b7641439b0db2f90c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c16dfe6268eeeb4b7924ff423e274fa00894a4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c16dfe6268eeeb4b7924ff423e274fa00894a4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c16dfe6268eeeb4b7924ff423e274fa00894a4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c16dfe6268eeeb4b7924ff423e274fa00894a4d/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "758b3a5f8f4fe3058d30306eb765decc1da8c1e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/758b3a5f8f4fe3058d30306eb765decc1da8c1e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/758b3a5f8f4fe3058d30306eb765decc1da8c1e6"}], "stats": {"total": 199, "additions": 187, "deletions": 12}, "files": [{"sha": "8b6f4c83f0f066a047892544ea761c0d3ec85a49", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c16dfe6268eeeb4b7924ff423e274fa00894a4d/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c16dfe6268eeeb4b7924ff423e274fa00894a4d/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=2c16dfe6268eeeb4b7924ff423e274fa00894a4d", "patch": "@@ -293,14 +293,16 @@ class impl_sm_context : public sm_context\n \t\t   const sm_state_map *old_smap,\n \t\t   sm_state_map *new_smap,\n \t\t   path_context *path_ctxt,\n-\t\t   stmt_finder *stmt_finder = NULL)\n+\t\t   stmt_finder *stmt_finder = NULL,\n+\t\t   bool unknown_side_effects = false)\n   : sm_context (sm_idx, sm),\n     m_logger (eg.get_logger ()),\n     m_eg (eg), m_enode_for_diag (enode_for_diag),\n     m_old_state (old_state), m_new_state (new_state),\n     m_old_smap (old_smap), m_new_smap (new_smap),\n     m_path_ctxt (path_ctxt),\n-    m_stmt_finder (stmt_finder)\n+    m_stmt_finder (stmt_finder),\n+    m_unknown_side_effects (unknown_side_effects)\n   {\n   }\n \n@@ -490,6 +492,11 @@ class impl_sm_context : public sm_context\n     return m_path_ctxt;\n   }\n \n+  bool unknown_side_effects_p () const FINAL OVERRIDE\n+  {\n+    return m_unknown_side_effects;\n+  }\n+\n   log_user m_logger;\n   exploded_graph &m_eg;\n   exploded_node *m_enode_for_diag;\n@@ -499,6 +506,9 @@ class impl_sm_context : public sm_context\n   sm_state_map *m_new_smap;\n   path_context *m_path_ctxt;\n   stmt_finder *m_stmt_finder;\n+\n+  /* Are we handling an external function with unknown side effects?  */\n+  bool m_unknown_side_effects;\n };\n \n /* Subclass of stmt_finder for finding the best stmt to report the leak at,\n@@ -1304,7 +1314,8 @@ exploded_node::on_stmt (exploded_graph &eg,\n \t= old_state.m_checker_states[sm_idx];\n       sm_state_map *new_smap = state->m_checker_states[sm_idx];\n       impl_sm_context sm_ctxt (eg, sm_idx, sm, this, &old_state, state,\n-\t\t\t       old_smap, new_smap, path_ctxt);\n+\t\t\t       old_smap, new_smap, path_ctxt, NULL,\n+\t\t\t       unknown_side_effects);\n \n       /* Allow the state_machine to handle the stmt.  */\n       if (sm.on_stmt (&sm_ctxt, snode, stmt))"}, {"sha": "54c7e6015ab50697e0fb4f1db4927a95de0a5d1a", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 107, "deletions": 9, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c16dfe6268eeeb4b7924ff423e274fa00894a4d/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c16dfe6268eeeb4b7924ff423e274fa00894a4d/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=2c16dfe6268eeeb4b7924ff423e274fa00894a4d", "patch": "@@ -41,6 +41,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"cfg.h\"\n #include \"digraph.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n #include \"analyzer/supergraph.h\"\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n@@ -102,6 +104,13 @@ class taint_state_machine : public state_machine\n \n   state_t combine_states (state_t s0, state_t s1) const;\n \n+private:\n+  void check_for_tainted_size_arg (sm_context *sm_ctxt,\n+\t\t\t\t   const supernode *node,\n+\t\t\t\t   const gcall *call,\n+\t\t\t\t   tree callee_fndecl) const;\n+\n+public:\n   /* State for a \"tainted\" value: unsanitized data potentially under an\n      attacker's control.  */\n   state_t m_tainted;\n@@ -338,15 +347,13 @@ class tainted_size : public taint_diagnostic\n {\n public:\n   tainted_size (const taint_state_machine &sm, tree arg,\n-\t\tenum bounds has_bounds,\n-\t\tenum access_direction dir)\n-  : taint_diagnostic (sm, arg, has_bounds),\n-    m_dir (dir)\n+\t\tenum bounds has_bounds)\n+  : taint_diagnostic (sm, arg, has_bounds)\n   {}\n \n-  const char *get_kind () const FINAL OVERRIDE { return \"tainted_size\"; }\n+  const char *get_kind () const OVERRIDE { return \"tainted_size\"; }\n \n-  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  bool emit (rich_location *rich_loc) OVERRIDE\n   {\n     diagnostic_metadata m;\n     m.add_cwe (129);\n@@ -395,9 +402,44 @@ class tainted_size : public taint_diagnostic\n \t\t\t\t   m_arg);\n       }\n   }\n+};\n+\n+/* Subclass of tainted_size for reporting on tainted size values\n+   passed to an external function annotated with attribute \"access\".  */\n+\n+class tainted_access_attrib_size : public tainted_size\n+{\n+public:\n+  tainted_access_attrib_size (const taint_state_machine &sm, tree arg,\n+\t\t\t      enum bounds has_bounds, tree callee_fndecl,\n+\t\t\t      unsigned size_argno, const char *access_str)\n+  : tainted_size (sm, arg, has_bounds),\n+    m_callee_fndecl (callee_fndecl),\n+    m_size_argno (size_argno), m_access_str (access_str)\n+  {\n+  }\n+\n+  const char *get_kind () const OVERRIDE\n+  {\n+    return \"tainted_access_attrib_size\";\n+  }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    bool warned = tainted_size::emit (rich_loc);\n+    if (warned)\n+      {\n+\tinform (DECL_SOURCE_LOCATION (m_callee_fndecl),\n+\t\t\"parameter %i of %qD marked as a size via attribute %qs\",\n+\t\tm_size_argno + 1, m_callee_fndecl, m_access_str);\n+      }\n+    return warned;\n+  }\n \n private:\n-  enum access_direction m_dir;\n+  tree m_callee_fndecl;\n+  unsigned m_size_argno;\n+  const char *m_access_str;\n };\n \n /* Concrete taint_diagnostic subclass for reporting attacker-controlled\n@@ -679,6 +721,10 @@ taint_state_machine::on_stmt (sm_context *sm_ctxt,\n \t\t\t\t      m_start, m_tainted);\n \t    return true;\n \t  }\n+\n+\t/* External function with \"access\" attribute. */\n+\tif (sm_ctxt->unknown_side_effects_p ())\n+\t  check_for_tainted_size_arg (sm_ctxt, node, call, callee_fndecl);\n       }\n   // TODO: ...etc; many other sources of untrusted data\n \n@@ -826,6 +872,58 @@ taint_state_machine::combine_states (state_t s0, state_t s1) const\n   gcc_unreachable ();\n }\n \n+/* Check for calls to external functions marked with\n+   __attribute__((access)) with a size-index: complain about\n+   tainted values passed as a size to such a function.  */\n+\n+void\n+taint_state_machine::check_for_tainted_size_arg (sm_context *sm_ctxt,\n+\t\t\t\t\t\t const supernode *node,\n+\t\t\t\t\t\t const gcall *call,\n+\t\t\t\t\t\t tree callee_fndecl) const\n+{\n+  tree fntype = TREE_TYPE (callee_fndecl);\n+  if (!fntype)\n+    return;\n+\n+  if (!TYPE_ATTRIBUTES (fntype))\n+    return;\n+\n+  /* Initialize a map of attribute access specifications for arguments\n+     to the function function call.  */\n+  rdwr_map rdwr_idx;\n+  init_attr_rdwr_indices (&rdwr_idx, TYPE_ATTRIBUTES (fntype));\n+\n+  unsigned argno = 0;\n+\n+  for (tree iter = TYPE_ARG_TYPES (fntype); iter;\n+       iter = TREE_CHAIN (iter), ++argno)\n+    {\n+      const attr_access* access = rdwr_idx.get (argno);\n+      if (!access)\n+\tcontinue;\n+\n+      if (access->sizarg == UINT_MAX)\n+\tcontinue;\n+\n+      tree size_arg = gimple_call_arg (call, access->sizarg);\n+\n+      state_t state = sm_ctxt->get_state (call, size_arg);\n+      enum bounds b;\n+      if (get_taint (state, TREE_TYPE (size_arg), &b))\n+\t{\n+\t  const char* const access_str =\n+\t    TREE_STRING_POINTER (access->to_external_string ());\n+\t  tree diag_size = sm_ctxt->get_diagnostic_tree (size_arg);\n+\t  sm_ctxt->warn (node, call, size_arg,\n+\t\t\t new tainted_access_attrib_size (*this, diag_size, b,\n+\t\t\t\t\t\t\t callee_fndecl,\n+\t\t\t\t\t\t\t access->sizarg,\n+\t\t\t\t\t\t\t access_str));\n+\t}\n+    }\n+}\n+\n } // anonymous namespace\n \n /* Internal interface to this file. */\n@@ -841,7 +939,7 @@ make_taint_state_machine (logger *logger)\n \n void\n region_model::check_region_for_taint (const region *reg,\n-\t\t\t\t      enum access_direction dir,\n+\t\t\t\t      enum access_direction,\n \t\t\t\t      region_model_context *ctxt) const\n {\n   gcc_assert (reg);\n@@ -931,7 +1029,7 @@ region_model::check_region_for_taint (const region *reg,\n \t    if (taint_sm.get_taint (state, size_sval->get_type (), &b))\n \t      {\n \t\ttree arg = get_representative_tree (size_sval);\n-\t\tctxt->warn (new tainted_size (taint_sm, arg, b, dir));\n+\t\tctxt->warn (new tainted_size (taint_sm, arg, b));\n \t      }\n \t  }\n \t  break;"}, {"sha": "fccfc882bf15b0014536b9711e06d90e76d3c0d1", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c16dfe6268eeeb4b7924ff423e274fa00894a4d/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c16dfe6268eeeb4b7924ff423e274fa00894a4d/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=2c16dfe6268eeeb4b7924ff423e274fa00894a4d", "patch": "@@ -271,6 +271,9 @@ class sm_context\n     return NULL;\n   }\n \n+  /* Are we handling an external function with unknown side effects?  */\n+  virtual bool unknown_side_effects_p () const { return false; }\n+\n protected:\n   sm_context (int sm_idx, const state_machine &sm)\n   : m_sm_idx (sm_idx), m_sm (sm) {}"}, {"sha": "724679a8cf308b8a309b78fb26aa453d3211b952", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-size-access-attr-1.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c16dfe6268eeeb4b7924ff423e274fa00894a4d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-size-access-attr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c16dfe6268eeeb4b7924ff423e274fa00894a4d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-size-access-attr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-size-access-attr-1.c?ref=2c16dfe6268eeeb4b7924ff423e274fa00894a4d", "patch": "@@ -0,0 +1,63 @@\n+/* Passing tainted sizes to external functions with attribute ((access)) with\n+   a size-index.  */\n+\n+// TODO: remove need for this option:\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+#include \"analyzer-decls.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+struct foo\n+{\n+  size_t sz;\n+};\n+\n+char buf[100];\n+\n+extern void extern_fn_read_only (void *p, size_t sz) /* { dg-message \"parameter 2 of 'extern_fn_read_only' marked as a size via attribute 'access \\\\(read_only, 1, 2\\\\)'\" } */\n+  __attribute__ ((access (read_only, 1, 2)));\n+\n+void test_fn_read_only (FILE *f, void *p)\n+{\n+  struct foo tmp;\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) { /* { dg-message \"\\\\(\\[0-9\\]+\\\\) 'tmp' gets an unchecked value here\" \"event: tmp gets unchecked value\" { xfail *-*-* } } */\n+                                             /* { dg-message \"\\\\(\\[0-9\\]+\\\\) following 'true' branch\\\\.\\\\.\\\\.\" \"event: following true branch\" { target *-*-* } .-1 } */\n+    __analyzer_dump_state (\"taint\", tmp.sz); /* { dg-warning \"state: 'tainted'\" } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) \\\\.\\\\.\\\\.to here\" \"event: to here\" { target *-*-* } .-1 } */\n+\n+    extern_fn_read_only (p, tmp.sz); /* { dg-warning \"use of attacker-controlled value 'tmp.sz' as size without upper-bounds checking\" } */\n+  }\n+}\n+\n+/* We shouldn't complain if the value has been sanitized.  */\n+\n+void test_fn_sanitized (FILE *f, void *p)\n+{\n+  struct foo tmp;\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    __analyzer_dump_state (\"taint\", tmp.sz); /* { dg-warning \"state: 'tainted'\" } */\n+\n+    if (tmp.sz > 100)\n+      return;\n+\n+    __analyzer_dump_state (\"taint\", tmp.sz); /* { dg-warning \"state: 'has_ub'\" } */\n+    \n+    extern_fn_read_only (p, tmp.sz); /* { dg-bogus \"use of attacker-controlled value\" } */\n+  }\n+}\n+\n+/* We shouldn't complain if there was no size annotation.  */\n+\n+extern void extern_fn_no_size (void *p)\n+  __attribute__ ((access (read_only, 1)));\n+\n+void test_fn_no_size (FILE *f, void *p)\n+{\n+  struct foo tmp;\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n+    __analyzer_dump_state (\"taint\", tmp.sz); /* { dg-warning \"state: 'tainted'\" } */\n+    extern_fn_no_size (p);\n+  }\n+}"}]}