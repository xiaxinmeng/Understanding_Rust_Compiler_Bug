{"sha": "21e8fb22580939c384699b75bcc0d7490beba819", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFlOGZiMjI1ODA5MzljMzg0Njk5Yjc1YmNjMGQ3NDkwYmViYTgxOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-07-11T13:42:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-07-11T13:42:55Z"}, "message": "re PR middle-end/61473 (register sized memmove not inlined)\n\n2014-07-11  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/61473\n\t* builtins.c (fold_builtin_memory_op): Inline memory moves\n\tthat can be implemented with a single load followed by a\n\tsingle store.\n\t(c_strlen): Only warn when only_value is not 2.\n\n\t* gcc.dg/memmove-4.c: New testcase.\n\t* gcc.dg/strlenopt-8.c: XFAIL.\n\t* gfortran.dg/coarray_lib_realloc_1.f90: Adjust.\n\nFrom-SVN: r212452", "tree": {"sha": "62b95556dd83989e21bbd9636f8b6f7f203b1e98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62b95556dd83989e21bbd9636f8b6f7f203b1e98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21e8fb22580939c384699b75bcc0d7490beba819", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21e8fb22580939c384699b75bcc0d7490beba819", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21e8fb22580939c384699b75bcc0d7490beba819", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21e8fb22580939c384699b75bcc0d7490beba819/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "53f5803e4deafeeff6db1020df703e57eee2c108", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53f5803e4deafeeff6db1020df703e57eee2c108", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53f5803e4deafeeff6db1020df703e57eee2c108"}], "stats": {"total": 97, "additions": 86, "deletions": 11}, "files": [{"sha": "6fe9bfdb71974ff3a4843279b58cc6f13d92bf6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21e8fb22580939c384699b75bcc0d7490beba819/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21e8fb22580939c384699b75bcc0d7490beba819/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21e8fb22580939c384699b75bcc0d7490beba819", "patch": "@@ -1,3 +1,11 @@\n+2014-07-11  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/61473\n+\t* builtins.c (fold_builtin_memory_op): Inline memory moves\n+\tthat can be implemented with a single load followed by a\n+\tsingle store.\n+\t(c_strlen): Only warn when only_value is not 2.\n+\n 2014-07-11  Evgeny Stupachenko  <evstupac@gmail.com>\n \n \t* config/i386/i386.c (expand_vec_perm_pblendv): Disable for AVX."}, {"sha": "cc94302d0cf5fbced5df7204bbe9847fca45a017", "filename": "gcc/builtins.c", "status": "modified", "additions": 56, "deletions": 8, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21e8fb22580939c384699b75bcc0d7490beba819/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21e8fb22580939c384699b75bcc0d7490beba819/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=21e8fb22580939c384699b75bcc0d7490beba819", "patch": "@@ -535,6 +535,10 @@ get_pointer_alignment (tree exp)\n    len = c_strlen (src, 1); if (len) expand_expr (len, ...); would not\n    evaluate the side-effects.\n \n+   If ONLY_VALUE is two then we do not emit warnings about out-of-bound\n+   accesses.  Note that this implies the result is not going to be emitted\n+   into the instruction stream.\n+\n    The value returned is of type `ssizetype'.\n \n    Unfortunately, string_constant can't access the values of const char\n@@ -606,7 +610,8 @@ c_strlen (tree src, int only_value)\n \n   /* If the offset is known to be out of bounds, warn, and call strlen at\n      runtime.  */\n-  if (offset < 0 || offset > max)\n+  if (only_value != 2\n+      && (offset < 0 || offset > max))\n     {\n      /* Suppress multiple warnings for propagated constant strings.  */\n       if (! TREE_NO_WARNING (src))\n@@ -8637,11 +8642,57 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n       unsigned int src_align, dest_align;\n       tree off0;\n \n+      /* Build accesses at offset zero with a ref-all character type.  */\n+      off0 = build_int_cst (build_pointer_type_for_mode (char_type_node,\n+\t\t\t\t\t\t\t ptr_mode, true), 0);\n+\n+      /* If we can perform the copy efficiently with first doing all loads\n+         and then all stores inline it that way.  Currently efficiently\n+\t means that we can load all the memory into a single integer\n+\t register which is what MOVE_MAX gives us.  */\n+      src_align = get_pointer_alignment (src);\n+      dest_align = get_pointer_alignment (dest);\n+      if (tree_fits_uhwi_p (len)\n+\t  && compare_tree_int (len, MOVE_MAX) <= 0\n+\t  /* ???  Don't transform copies from strings with known length this\n+\t     confuses the tree-ssa-strlen.c.  This doesn't handle\n+\t     the case in gcc.dg/strlenopt-8.c which is XFAILed for that\n+\t     reason.  */\n+\t  && !c_strlen (src, 2))\n+\t{\n+\t  unsigned ilen = tree_to_uhwi (len);\n+\t  if (exact_log2 (ilen) != -1)\n+\t    {\n+\t      tree type = lang_hooks.types.type_for_size (ilen * 8, 1);\n+\t      if (type\n+\t\t  && TYPE_MODE (type) != BLKmode\n+\t\t  && (GET_MODE_SIZE (TYPE_MODE (type)) * BITS_PER_UNIT\n+\t\t      == ilen * 8)\n+\t\t  /* If the pointers are not aligned we must be able to\n+\t\t     emit an unaligned load.  */\n+\t\t  && ((src_align >= GET_MODE_ALIGNMENT (TYPE_MODE (type))\n+\t\t       && dest_align >= GET_MODE_ALIGNMENT (TYPE_MODE (type)))\n+\t\t      || !SLOW_UNALIGNED_ACCESS (TYPE_MODE (type),\n+\t\t\t\t\t\t MIN (src_align, dest_align))))\n+\t\t{\n+\t\t  tree srctype = type;\n+\t\t  tree desttype = type;\n+\t\t  if (src_align < GET_MODE_ALIGNMENT (TYPE_MODE (type)))\n+\t\t    srctype = build_aligned_type (type, src_align);\n+\t\t  if (dest_align < GET_MODE_ALIGNMENT (TYPE_MODE (type)))\n+\t\t    desttype = build_aligned_type (type, dest_align);\n+\t\t  if (!ignore)\n+\t\t    dest = builtin_save_expr (dest);\n+\t\t  expr = build2 (MODIFY_EXPR, type,\n+\t\t\t\t fold_build2 (MEM_REF, desttype, dest, off0),\n+\t\t\t\t fold_build2 (MEM_REF, srctype, src, off0));\n+\t\t  goto done;\n+\t\t}\n+\t    }\n+\t}\n+\n       if (endp == 3)\n \t{\n-\t  src_align = get_pointer_alignment (src);\n-\t  dest_align = get_pointer_alignment (dest);\n-\n \t  /* Both DEST and SRC must be pointer types.\n \t     ??? This is what old code did.  Is the testing for pointer types\n \t     really mandatory?\n@@ -8818,10 +8869,6 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n       if (!ignore)\n         dest = builtin_save_expr (dest);\n \n-      /* Build accesses at offset zero with a ref-all character type.  */\n-      off0 = build_int_cst (build_pointer_type_for_mode (char_type_node,\n-\t\t\t\t\t\t\t ptr_mode, true), 0);\n-\n       destvar = dest;\n       STRIP_NOPS (destvar);\n       if (TREE_CODE (destvar) == ADDR_EXPR\n@@ -8888,6 +8935,7 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n       expr = build2 (MODIFY_EXPR, TREE_TYPE (destvar), destvar, srcvar);\n     }\n \n+done:\n   if (ignore)\n     return expr;\n "}, {"sha": "324db9063630a1bdc446f3dc6f5d33bf458b0534", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21e8fb22580939c384699b75bcc0d7490beba819/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21e8fb22580939c384699b75bcc0d7490beba819/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=21e8fb22580939c384699b75bcc0d7490beba819", "patch": "@@ -1,3 +1,10 @@\n+2014-07-11  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/61473\n+\t* gcc.dg/memmove-4.c: New testcase.\n+\t* gcc.dg/strlenopt-8.c: XFAIL.\n+\t* gfortran.dg/coarray_lib_realloc_1.f90: Adjust.\n+\n 2014-07-11  Marat Zakirov  <m.zakirov@samsung.com>\n \n \tPR target/61561"}, {"sha": "120a4db219e3b28f1dca666c995de0bb9f763f3c", "filename": "gcc/testsuite/gcc.dg/memmove-4.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21e8fb22580939c384699b75bcc0d7490beba819/gcc%2Ftestsuite%2Fgcc.dg%2Fmemmove-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21e8fb22580939c384699b75bcc0d7490beba819/gcc%2Ftestsuite%2Fgcc.dg%2Fmemmove-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemmove-4.c?ref=21e8fb22580939c384699b75bcc0d7490beba819", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+typedef int w __attribute__((mode(word)));\n+\n+void b(char *a, char *b, int i)\n+{\n+  __builtin_memmove (&a[i], &b[i], sizeof(w));\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"memmove\" \"optimized\" { xfail { ! non_strict_align } } } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "3f9ad511263f16ce2696481ea93d173633e78a59", "filename": "gcc/testsuite/gcc.dg/strlenopt-8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21e8fb22580939c384699b75bcc0d7490beba819/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21e8fb22580939c384699b75bcc0d7490beba819/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-8.c?ref=21e8fb22580939c384699b75bcc0d7490beba819", "patch": "@@ -43,8 +43,8 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" { xfail *-*-* } } } */\n /* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */"}, {"sha": "4fd0e9b899fba6f31fe13456af720448d07a1fd9", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_realloc_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21e8fb22580939c384699b75bcc0d7490beba819/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_realloc_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21e8fb22580939c384699b75bcc0d7490beba819/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_realloc_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_realloc_1.f90?ref=21e8fb22580939c384699b75bcc0d7490beba819", "patch": "@@ -30,6 +30,6 @@ subroutine foo()\n ! { dg-final { scan-tree-dump-times \"__builtin_malloc\" 1 \"original\" } }\n \n ! But copy \"ii\" and \"CAF\":\n-! { dg-final { scan-tree-dump-times \"__builtin_memcpy\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_memcpy|= MEM\" 2 \"original\" } }\n \n ! { dg-final { cleanup-tree-dump \"original\" } }"}]}