{"sha": "85093b9c593b3c2b704b2b73176d6e2437516832", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUwOTNiOWM1OTNiM2MyYjcwNGIyYjczMTc2ZDZlMjQzNzUxNjgzMg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-06T02:37:42Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-06T02:37:42Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r911", "tree": {"sha": "722c91e14a4fb363d57fe6d5b39f0445721d3c3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/722c91e14a4fb363d57fe6d5b39f0445721d3c3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85093b9c593b3c2b704b2b73176d6e2437516832", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85093b9c593b3c2b704b2b73176d6e2437516832", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85093b9c593b3c2b704b2b73176d6e2437516832", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85093b9c593b3c2b704b2b73176d6e2437516832/comments", "author": null, "committer": null, "parents": [{"sha": "81fd4c6eb33f08e6a62680fbb178ef3bc0b2d948", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81fd4c6eb33f08e6a62680fbb178ef3bc0b2d948", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81fd4c6eb33f08e6a62680fbb178ef3bc0b2d948"}], "stats": {"total": 172, "additions": 133, "deletions": 39}, "files": [{"sha": "d0d1c0c4dbbf0839ec34e904eea8d8fa97365a4e", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 133, "deletions": 39, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85093b9c593b3c2b704b2b73176d6e2437516832/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85093b9c593b3c2b704b2b73176d6e2437516832/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=85093b9c593b3c2b704b2b73176d6e2437516832", "patch": "@@ -239,7 +239,7 @@ static char *alternative_name;\n /* Simplify an expression.  Only call the routine if there is something to\n    simplify.  */\n #define SIMPLIFY_TEST_EXP(EXP,INSN_CODE,INSN_INDEX)\t\\\n-  (RTX_UNCHANGING_P (EXP) ? (EXP)\t\t\t\\\n+  (RTX_UNCHANGING_P (EXP) || MEM_IN_STRUCT_P (EXP) ? (EXP)\t\t\\\n    : simplify_test_exp (EXP, INSN_CODE, INSN_INDEX))\n   \n /* These are referenced by rtlanal.c and hence need to be defined somewhere.\n@@ -2080,7 +2080,8 @@ insert_right_side (code, exp, term, insn_code, insn_index)\n    If so, we can optimize.  Similarly for IOR's of EQ_ATTR.\n \n    This routine is passed an expression and either AND or IOR.  It returns a\n-   bitmask indicating which alternatives are present.  */\n+   bitmask indicating which alternatives are present.\n+   ??? What does \"present\" mean?  */\n \n static int\n compute_alternative_mask (exp, code)\n@@ -2448,7 +2449,7 @@ simplify_test_exp (exp, insn_code, insn_index)\n     do_nothing ();\n \n   /* Don't re-simplify something we already simplified.  */\n-  if (RTX_UNCHANGING_P (exp))\n+  if (RTX_UNCHANGING_P (exp) || MEM_IN_STRUCT_P (exp))\n     return exp;\n \n   switch (GET_CODE (exp))\n@@ -2490,15 +2491,12 @@ simplify_test_exp (exp, insn_code, insn_index)\n \t}\n       else if (left == true_rtx)\n \t{\n-\t  obstack_free (rtl_obstack, spacer);\n-\t  return SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n+\t  return right;\n \t}\n       else if (right == true_rtx)\n \t{\n-\t  obstack_free (rtl_obstack, spacer);\n-\t  return SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n+\t  return left;\n \t}\n-\n       /* See if all or all but one of the insn's alternatives are specified\n \t in this tree.  Optimize if so.  */\n \n@@ -2557,13 +2555,11 @@ simplify_test_exp (exp, insn_code, insn_index)\n \t}\n       else if (left == false_rtx)\n \t{\n-\t  obstack_free (rtl_obstack, spacer);\n-\t  return SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n+\t  return right;\n \t}\n       else if (right == false_rtx)\n \t{\n-\t  obstack_free (rtl_obstack, spacer);\n-\t  return SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n+\t  return left;\n \t}\n \n       /* Test for simple cases where the distributive law is useful.  I.e.,\n@@ -2705,36 +2701,130 @@ optimize_attrs ()\n   struct insn_ent *ie, *nextie;\n   rtx newexp;\n   int something_changed = 1;\n+  int i;\n+  struct attr_value_list { struct attr_value *av;\n+\t\t\t   struct insn_ent *ie;\n+\t\t\t   struct attr_desc * attr;\n+\t\t\t   struct attr_value_list *next; };\n+  struct attr_value_list **insn_code_values;\n+  struct attr_value_list *iv;\n+\n+  /* For each insn code, make a list of all the insn_ent's for it,\n+     for all values for all attributes.  */\n+\n+  /* Make 2 extra elements, for \"code\" values -2 and -1.  */\n+  insn_code_values\n+    = (struct attr_value_list **) alloca ((insn_code_number + 2)\n+\t\t\t\t\t  * sizeof (struct attr_value_list *));\n+  bzero (insn_code_values,\n+\t (insn_code_number + 2) * sizeof (struct attr_value_list *));\n+  /* Offset the table address so we can index by -2 or -1.  */\n+  insn_code_values += 2;\n+\n+  for (attr = attrs; attr; attr = attr->next)\n+    for (av = attr->first_value; av; av = av->next)\n+      for (ie = av->first_insn; ie; ie = ie->next)\n+\t{\n+\t  iv = ((struct attr_value_list *)\n+\t\talloca (sizeof (struct attr_value_list)));\n+\t  iv->attr = attr;\n+\t  iv->av = av;\n+\t  iv->ie = ie;\n+\t  iv->next = insn_code_values[ie->insn_code];\n+\t  insn_code_values[ie->insn_code] = iv;\n+\t}\n \n   /* Loop until nothing changes for one iteration.  */\n   while (something_changed)\n     {\n       something_changed = 0;\n-      for (attr = attrs; attr; attr = attr->next)\n-\tfor (av = attr->first_value; av; av = av->next)\n-\t    for (ie = av->first_insn; ie; ie = nextie)\n-\t      {\n-\t\tstruct obstack *old = rtl_obstack;\n-\t\tchar *spacer = (char *) obstack_finish (temp_obstack);\n-\n-\t\tnextie = ie->next;\n-\t\tif (GET_CODE (av->value) != COND)\n-\t\t  continue;\n-\n-\t\trtl_obstack = temp_obstack;\n-\t\tnewexp = simplify_cond (av->value, ie->insn_code,\n-\t\t\t\t\tie->insn_index);\n-\t\trtl_obstack = old;\n-\t\tif (newexp != av->value)\n-\t\t  {\n-\t\t    newexp = attr_copy_rtx (newexp);\n-\t\t    remove_insn_ent (av, ie);\n-\t\t    insert_insn_ent (get_attr_value (newexp, attr,\n-\t\t\t\t\t\t     ie->insn_code), ie);\n-\t\t    something_changed = 1;\n-\t\t  }\n-\t\tobstack_free (temp_obstack, spacer);\n-\t      }\n+      /* Process one insn code at a time.  */\n+      for (i = -2; i < insn_code_number; i++)\n+\t{\n+\t  /* Clear the MEM_IN_STRUCT_P flag everywhere relevant.\n+\t     We use it to mean \"already simplified for this insn\".  */\n+\t  for (iv = insn_code_values[i]; iv; iv = iv->next)\n+\t    clear_struct_flag (iv->av->value);\n+\t\t  \n+\t  for (iv = insn_code_values[i]; iv; iv = iv->next)\n+\t    {\n+\t      struct obstack *old = rtl_obstack;\n+\t      char *spacer = (char *) obstack_finish (temp_obstack);\n+\n+\t      attr = iv->attr;\n+\t      av = iv->av;\n+\t      ie = iv->ie;\n+\t      if (GET_CODE (av->value) != COND)\n+\t\tcontinue;\n+\n+\t      rtl_obstack = temp_obstack;\n+\t      newexp = simplify_cond (av->value, ie->insn_code,\n+\t\t\t\t      ie->insn_index);\n+\t      rtl_obstack = old;\n+\t      if (newexp != av->value)\n+\t\t{\n+\t\t  newexp = attr_copy_rtx (newexp);\n+\t\t  remove_insn_ent (av, ie);\n+\t\t  av = get_attr_value (newexp, attr, ie->insn_code);\n+\t\t  iv->av = av;\n+\t\t  insert_insn_ent (av, ie);\n+\t\t  something_changed = 1;\n+\t\t}\n+\t      obstack_free (temp_obstack, spacer);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Clear the MEM_IN_STRUCT_P flag in EXP and its subexpressions.  */\n+\n+clear_struct_flag (x)\n+     rtx x;\n+{\n+  register int i;\n+  register int j;\n+  register enum rtx_code code;\n+  register char *fmt;\n+\n+  MEM_IN_STRUCT_P (x) = 0;\n+  if (RTX_UNCHANGING_P (x))\n+    return;\n+\n+  code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case REG:\n+    case QUEUED:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+    case EQ_ATTR:\n+      return;\n+    }\n+\n+  /* Compare the elements.  If any pair of corresponding elements\n+     fail to match, return 0 for the whole things.  */\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'V':\n+\tcase 'E':\n+\t  /* And the corresponding elements must match.  */\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    clear_struct_flag (XVECEXP (x, i, j));\n+\t  break;\n+\n+\tcase 'e':\n+\t  clear_struct_flag (XEXP (x, i));\n+\t  break;\n+\t}\n     }\n }\n \f\n@@ -4118,11 +4208,14 @@ copy_rtx_unchanging (orig)\n   register rtx copy;\n   register RTX_CODE code;\n \n-  if (RTX_UNCHANGING_P (orig))\n+  if (RTX_UNCHANGING_P (orig) || MEM_IN_STRUCT_P (orig))\n     return orig;\n \n-  code = GET_CODE (orig);\n+  MEM_IN_STRUCT_P (orig) = 1;\n+  return orig;\n \n+#if 0\n+  code = GET_CODE (orig);\n   switch (code)\n     {\n     case CONST_INT:\n@@ -4139,6 +4232,7 @@ copy_rtx_unchanging (orig)\n   bcopy (&XEXP (orig, 0), &XEXP (copy, 0),\n \t GET_RTX_LENGTH (GET_CODE (copy)) * sizeof (rtx));\n   return copy;\n+#endif\n }\n \n static void"}]}