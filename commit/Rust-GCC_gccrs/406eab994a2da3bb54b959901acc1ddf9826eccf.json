{"sha": "406eab994a2da3bb54b959901acc1ddf9826eccf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA2ZWFiOTk0YTJkYTNiYjU0Yjk1OTkwMWFjYzFkZGY5ODI2ZWNjZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-11-29T00:59:25Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-11-29T00:59:25Z"}, "message": "tree-ssa-alias.c (compute_points_to_and_addr_escapes): Remove special code for assigning to non-pointer.\n\n\t* tree-ssa-alias.c (compute_points_to_and_addr_escapes): Remove\n\tspecial code for assigning to non-pointer.\n\t(is_escape_site): If RHS is a conversion between pointer and integer\n\ttypes,\tthis is an escape site.\n\nFrom-SVN: r91448", "tree": {"sha": "f2a50aeaf9e314f376464708965b246331bd2f9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2a50aeaf9e314f376464708965b246331bd2f9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/406eab994a2da3bb54b959901acc1ddf9826eccf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/406eab994a2da3bb54b959901acc1ddf9826eccf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/406eab994a2da3bb54b959901acc1ddf9826eccf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/406eab994a2da3bb54b959901acc1ddf9826eccf/comments", "author": null, "committer": null, "parents": [{"sha": "b16aa8a5d930f7247ab56facac3adc67f7aebfa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b16aa8a5d930f7247ab56facac3adc67f7aebfa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b16aa8a5d930f7247ab56facac3adc67f7aebfa3"}], "stats": {"total": 34, "additions": 17, "deletions": 17}, "files": [{"sha": "87d29bc7e01be7bb1b1158227683f599b783fa4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/406eab994a2da3bb54b959901acc1ddf9826eccf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/406eab994a2da3bb54b959901acc1ddf9826eccf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=406eab994a2da3bb54b959901acc1ddf9826eccf", "patch": "@@ -1,5 +1,10 @@\n 2004-11-28  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* tree-ssa-alias.c (compute_points_to_and_addr_escapes): Remove\n+\tspecial code for assigning to non-pointer.\n+\t(is_escape_site): If RHS is a conversion between pointer and integer\n+\ttypes,\tthis is an escape site.\n+\n \t* gcse.c (insert_store): Error if try to insert store on abnormal edge.\n \t(store_motion): Don't move store if any edge we'd want to move it\n \tto is abnormal."}, {"sha": "3fce93a8001437234a604590f9941022d9fc0d93", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/406eab994a2da3bb54b959901acc1ddf9826eccf/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/406eab994a2da3bb54b959901acc1ddf9826eccf/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=406eab994a2da3bb54b959901acc1ddf9826eccf", "patch": "@@ -195,7 +195,8 @@ tree global_var;\n    The concept of 'escaping' is the same one used in the Java world.  When\n    a pointer or an ADDR_EXPR escapes, it means that it has been exposed\n    outside of the current function.  So, assignment to global variables,\n-   function arguments and returning a pointer are all escape sites.\n+   function arguments and returning a pointer are all escape sites, as are\n+   conversions between pointers and integers.\n \n    This is where we are currently limited.  Since not everything is renamed\n    into SSA, we lose track of escape properties when a pointer is stashed\n@@ -662,22 +663,6 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t  if (stmt_escapes_p)\n \t    block_ann->has_escape_site = 1;\n \n-\t  /* Special case for silly ADDR_EXPR tricks\n-\t     (gcc.c-torture/unsorted/pass.c).  If this statement is an\n-\t     assignment to a non-pointer variable and the RHS takes the\n-\t     address of a variable, assume that the variable on the RHS is\n-\t     call-clobbered.  We could add the LHS to the list of\n-\t     \"pointers\" and follow it to see if it really escapes, but it's\n-\t     not worth the pain.  */\n-\t  if (addr_taken\n-\t      && TREE_CODE (stmt) == MODIFY_EXPR\n-\t      && !POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (stmt, 0))))\n-\t    EXECUTE_IF_SET_IN_BITMAP (addr_taken, 0, i, bi)\n-\t      {\n-\t\ttree var = referenced_var (i);\n-\t\tmark_call_clobbered (var);\n-\t      }\n-\n \t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n \t    {\n \t      var_ann_t v_ann = var_ann (SSA_NAME_VAR (op));\n@@ -2049,6 +2034,16 @@ is_escape_site (tree stmt, size_t *num_calls_p)\n       if (lhs == NULL_TREE)\n \treturn true;\n \n+      /* If the RHS is a conversion between a pointer and an integer, the\n+\t pointer escapes since we can't track the integer.  */\n+      if ((TREE_CODE (TREE_OPERAND (stmt, 1)) == NOP_EXPR\n+\t   || TREE_CODE (TREE_OPERAND (stmt, 1)) == CONVERT_EXPR\n+\t   || TREE_CODE (TREE_OPERAND (stmt, 1)) == VIEW_CONVERT_EXPR)\n+\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND\n+\t\t\t\t\t(TREE_OPERAND (stmt, 1), 0)))\n+\t  && !POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (stmt, 1))))\n+\treturn true;\n+\n       /* If the LHS is an SSA name, it can't possibly represent a non-local\n \t memory store.  */\n       if (TREE_CODE (lhs) == SSA_NAME)"}]}