{"sha": "b8e42321fb18771c9b259b8c21d683cd9acafa21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhlNDIzMjFmYjE4NzcxYzliMjU5YjhjMjFkNjgzY2Q5YWNhZmEyMQ==", "commit": {"author": {"name": "John David Anglin", "email": "dave@hiauly1.hia.nrc.ca", "date": "2001-11-10T00:22:52Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2001-11-10T00:22:52Z"}, "message": "pa.c (emit_move_sequence): Use cint_ok_for_move to check whether a constant can be loaded in a single...\n\n\t* pa.c (emit_move_sequence): Use cint_ok_for_move to check whether a\n\tconstant can be loaded in a single instruction to a register.  When\n\tloading immediate constants, use PLUS instead of HIGH/LO_SUM.  Use\n\tdepdi for insertion of most significant 32-bits on 64-bit hosts.\n\t* pa.h (LEGITIMATE_CONSTANT_P): Accept constants that can be built\n\twith ldil/ldo/depdi instruction sequence on 64-bit hosts.\n\t* pa.md: New addmove pattern for adding constant_int to HImode\n\tregister and moving result to HImode register.  Remove HImode HIGH\n\tand LO_SUM patterns.\n\nFrom-SVN: r46908", "tree": {"sha": "79a5af00c32d7c55a013dc57aa81ba569b45c19b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79a5af00c32d7c55a013dc57aa81ba569b45c19b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8e42321fb18771c9b259b8c21d683cd9acafa21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8e42321fb18771c9b259b8c21d683cd9acafa21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8e42321fb18771c9b259b8c21d683cd9acafa21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8e42321fb18771c9b259b8c21d683cd9acafa21/comments", "author": null, "committer": null, "parents": [{"sha": "5d69f816bcfd32f2171b31e09249a8e03acedd5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d69f816bcfd32f2171b31e09249a8e03acedd5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d69f816bcfd32f2171b31e09249a8e03acedd5e"}], "stats": {"total": 94, "additions": 64, "deletions": 30}, "files": [{"sha": "783c2de91b13f4e038d5442fbad79f8dba30f4c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8e42321fb18771c9b259b8c21d683cd9acafa21/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8e42321fb18771c9b259b8c21d683cd9acafa21/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8e42321fb18771c9b259b8c21d683cd9acafa21", "patch": "@@ -1,3 +1,15 @@\n+2001-11-09  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n+\n+\t* pa.c (emit_move_sequence): Use cint_ok_for_move to check whether a\n+\tconstant can be loaded in a single instruction to a register.  When\n+\tloading immediate constants, use PLUS instead of HIGH/LO_SUM.  Use\n+\tdepdi for insertion of most significant 32-bits on 64-bit hosts.\n+\t* pa.h (LEGITIMATE_CONSTANT_P): Accept constants that can be built\n+\twith ldil/ldo/depdi instruction sequence on 64-bit hosts.\n+\t* pa.md: New addmove pattern for adding constant_int to HImode\n+\tregister and moving result to HImode register.  Remove HImode HIGH\n+\tand LO_SUM patterns.\n+\n 2001-11-09  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* Makefile.in: Update."}, {"sha": "4a7e7dce3490d0aa24469d22c6a6fd797779fae6", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 45, "deletions": 16, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8e42321fb18771c9b259b8c21d683cd9acafa21/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8e42321fb18771c9b259b8c21d683cd9acafa21/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=b8e42321fb18771c9b259b8c21d683cd9acafa21", "patch": "@@ -1394,7 +1394,8 @@ emit_move_sequence (operands, mode, scratch_reg)\n   else if (register_operand (operand0, mode))\n     {\n       if (register_operand (operand1, mode)\n-\t  || (GET_CODE (operand1) == CONST_INT && INT_14_BITS (operand1))\n+\t  || (GET_CODE (operand1) == CONST_INT\n+\t      && cint_ok_for_move (INTVAL (operand1)))\n \t  || (operand1 == CONST0_RTX (mode))\n \t  || (GET_CODE (operand1) == HIGH\n \t      && !symbolic_operand (XEXP (operand1, 0), VOIDmode))\n@@ -1596,8 +1597,8 @@ emit_move_sequence (operands, mode, scratch_reg)\n       else if (GET_CODE (operand1) != CONST_INT\n \t       || ! cint_ok_for_move (INTVAL (operand1)))\n \t{\n+\t  rtx extend = NULL_RTX;\n \t  rtx temp;\n-\t  int need_zero_extend = 0;\n \n \t  if (TARGET_64BIT && GET_CODE (operand1) == CONST_INT\n \t      && HOST_BITS_PER_WIDE_INT > 32\n@@ -1606,15 +1607,18 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t      HOST_WIDE_INT val = INTVAL (operand1);\n \t      HOST_WIDE_INT nval;\n \n-\t      /* If the value is the same after a 32->64bit sign\n-\t\t extension, then we can use it as-is.  Else we will\n-\t\t need to sign extend the constant from 32->64bits\n-\t\t then zero extend the result from 32->64bits.  */\n+\t      /* Extract the low order 32 bits of the value and sign extend.\n+\t\t If the new value is the same as the original value, we can\n+\t\t can use the original value as-is.  If the new value is\n+\t\t different, we use it and insert the most-significant 32-bits\n+\t\t of the original value into the final result.  */\n \t      nval = ((val & (((HOST_WIDE_INT) 2 << 31) - 1))\n \t\t      ^ ((HOST_WIDE_INT) 1 << 31)) - ((HOST_WIDE_INT) 1 << 31);\n \t      if (val != nval)\n \t\t{\n-\t\t  need_zero_extend = 1;\n+#if HOST_BITS_PER_WIDE_INT > 32\n+\t\t  extend = GEN_INT (val >> 32);\n+#endif\n \t\t  operand1 = GEN_INT (nval);\n \t\t}\n \t    }\n@@ -1624,19 +1628,44 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t  else\n \t    temp = gen_reg_rtx (mode);\n \n-\t  emit_insn (gen_rtx_SET (VOIDmode, temp,\n-\t\t\t\t  gen_rtx_HIGH (mode, operand1)));\n-\t  operands[1] = gen_rtx_LO_SUM (mode, temp, operand1);\n-\t  emit_move_insn (operands[0], operands[1]);\n+\t  if (GET_CODE (operand1) == CONST_INT)\n+\t    {\n+\t      /* Directly break constant into low and high parts.  This\n+\t\t provides better optimization opportunities because various\n+\t\t passes recognize constants split with PLUS but not LO_SUM.\n+\t\t We use a 14-bit signed low part except when the addition\n+\t\t of 0x4000 to the high part might change the sign of the\n+\t\t high part.  */\n+\t      HOST_WIDE_INT value = INTVAL (operand1);\n+\t      HOST_WIDE_INT low = value & 0x3fff;\n+\t      HOST_WIDE_INT high = value & ~ 0x3fff;\n+\n+\t      if (low >= 0x2000)\n+\t\t{\n+\t\t  if (high == 0x7fffc000 || (mode == HImode && high == 0x4000))\n+\t\t    high += 0x2000;\n+\t\t  else\n+\t\t    high += 0x4000;\n+\t\t}\n \n-\t  if (need_zero_extend)\n+\t      low = value - high;\n+\n+\t      emit_insn (gen_rtx_SET (VOIDmode, temp, GEN_INT (high)));\n+\t      operands[1] = gen_rtx_PLUS (mode, temp, GEN_INT (low));\n+\t    }\n+\t  else\n \t    {\n-\t      emit_insn (gen_zero_extendsidi2 (operands[0],\n-\t\t\t\t\t       gen_rtx_SUBREG (SImode,\n-\t\t\t\t\t\t\t       operands[0],\n-\t\t\t\t\t\t\t       4)));\n+\t      emit_insn (gen_rtx_SET (VOIDmode, temp,\n+\t\t\t\t      gen_rtx_HIGH (mode, operand1)));\n+\t      operands[1] = gen_rtx_LO_SUM (mode, temp, operand1);\n \t    }\n \n+\t  emit_move_insn (operands[0], operands[1]);\n+\n+\t  if (extend != NULL_RTX)\n+\t    emit_insn (gen_insv (operands[0], GEN_INT (32), const0_rtx,\n+\t\t\t\t extend));\n+\n \t  return 1;\n \t}\n     }"}, {"sha": "7abded2b7494e4a4906c31c13a40e26ba76b3a4a", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8e42321fb18771c9b259b8c21d683cd9acafa21/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8e42321fb18771c9b259b8c21d683cd9acafa21/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=b8e42321fb18771c9b259b8c21d683cd9acafa21", "patch": "@@ -1106,8 +1106,8 @@ extern int may_call_alloca;\n    && !(TARGET_64BIT && GET_CODE (X) == CONST_DOUBLE)\t\t\\\n    && !(TARGET_64BIT && GET_CODE (X) == CONST_INT\t\t\\\n \t&& !(HOST_BITS_PER_WIDE_INT <= 32\t\t\t\\\n-\t     || (INTVAL (X) >= (HOST_WIDE_INT) -1 << 31\t\t\\\n-\t\t && INTVAL (X) < (HOST_WIDE_INT) 1 << 32)\t\\\n+\t     || (INTVAL (X) >= (HOST_WIDE_INT) -32 << 31\t\\\n+\t\t && INTVAL (X) < (HOST_WIDE_INT) 32 << 31)\t\\\n \t     || cint_ok_for_move (INTVAL (X))))\t\t\t\\\n    && !function_label_operand (X, VOIDmode))\n "}, {"sha": "3c86b27f33b99935196c379a5ecb0108f3a039cf", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8e42321fb18771c9b259b8c21d683cd9acafa21/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8e42321fb18771c9b259b8c21d683cd9acafa21/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=b8e42321fb18771c9b259b8c21d683cd9acafa21", "patch": "@@ -2604,19 +2604,12 @@\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(high:HI (match_operand 1 \"const_int_operand\" \"\")))]\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t (match_operand 2 \"const_int_operand\" \"J\")))]\n   \"\"\n-  \"ldil L'%G1,%0\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(lo_sum:HI (match_operand:HI 1 \"register_operand\" \"r\")\n-\t\t   (match_operand 2 \"const_int_operand\" \"\")))]\n-  \"\"\n-  \"ldo R'%G2(%1),%0\"\n-  [(set_attr \"type\" \"move\")\n+  \"ldo %2(%1),%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n    (set_attr \"length\" \"4\")])\n \n (define_expand \"movqi\""}]}