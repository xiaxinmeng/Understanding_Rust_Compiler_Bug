{"sha": "df741be17ee09974ad46750ebbbacf55f8e108a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY3NDFiZTE3ZWUwOTk3NGFkNDY3NTBlYmJiYWNmNTVmOGUxMDhhOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-28T17:31:18Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-06-03T10:41:20Z"}, "message": "Fix signedness issue in DWARF functions (2)\n\nThe compiler can synthesize DWARF functions to describe the location and\nsize of components in discriminated record types with variant part in Ada,\nbut in peculiar cases the compiler drops expressions on the floor, for\nexample in the divide case:\n\n     case ROUND_DIV_EXPR:\n     case TRUNC_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n      if (TYPE_UNSIGNED (TREE_TYPE (loc)))\n        return 0;\n       op = DW_OP_div;\n       goto do_binop;\n\nNow sizetype and bitsizetype are unsigned types, which means that any divide\nexpression in them is dropped.\n\ngcc/\n\t* dwarf2out.c (mem_loc_descriptor) <UDIV>: Fix typo.\n\t(typed_binop_from_tree): New function.\n\t(loc_list_from_tree_1) <EXACT_DIV_EXPR>: For an unsigned type,\n\tturn a divide by a power of 2 into a shift.\n\t<CEIL_DIV_EXPR>: For an unsigned type, use a signed divide if the\n\tsize of the mode is lower than DWARF2_ADDR_SIZE; otherwise, do a\n\ttyped divide by calling typed_binop_from_tree.", "tree": {"sha": "518f4b3aa4f5e605a38770cb75ad70f0b7cae70b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/518f4b3aa4f5e605a38770cb75ad70f0b7cae70b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df741be17ee09974ad46750ebbbacf55f8e108a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df741be17ee09974ad46750ebbbacf55f8e108a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df741be17ee09974ad46750ebbbacf55f8e108a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df741be17ee09974ad46750ebbbacf55f8e108a8/comments", "author": null, "committer": null, "parents": [{"sha": "e26b748a62e5bc59f6671faab75f737503c87319", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e26b748a62e5bc59f6671faab75f737503c87319", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e26b748a62e5bc59f6671faab75f737503c87319"}], "stats": {"total": 92, "additions": 88, "deletions": 4}, "files": [{"sha": "523735e1521957f995715e50a45d70c97f56d859", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 88, "deletions": 4, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df741be17ee09974ad46750ebbbacf55f8e108a8/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df741be17ee09974ad46750ebbbacf55f8e108a8/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=df741be17ee09974ad46750ebbbacf55f8e108a8", "patch": "@@ -16407,11 +16407,13 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n       if ((!dwarf_strict || dwarf_version >= 5)\n \t  && is_a <scalar_int_mode> (mode, &int_mode))\n \t{\n-\t  if (GET_MODE_SIZE (int_mode) > DWARF2_ADDR_SIZE)\n+\t  /* We can use a signed divide if the sign bit is not set.  */\n+\t  if (GET_MODE_SIZE (int_mode) < DWARF2_ADDR_SIZE)\n \t    {\n \t      op = DW_OP_div;\n \t      goto do_binop;\n \t    }\n+\n \t  mem_loc_result = typed_binop (DW_OP_div, rtl,\n \t\t\t\t\tbase_type_for_mode (int_mode, 1),\n \t\t\t\t\tint_mode, mem_mode);\n@@ -18503,6 +18505,48 @@ function_to_dwarf_procedure (tree fndecl)\n   return dwarf_proc_die;\n }\n \n+/* Helper function for loc_list_from_tree.  Perform OP binary op,\n+   but after converting arguments to type_die, afterwards convert\n+   back to unsigned.  */\n+\n+static dw_loc_list_ref\n+typed_binop_from_tree (enum dwarf_location_atom op, tree loc,\n+\t\t       dw_die_ref type_die, scalar_int_mode mode,\n+\t\t       struct loc_descr_context *context)\n+{\n+  dw_loc_list_ref op0, op1;\n+  dw_loc_descr_ref cvt, binop;\n+\n+  if (type_die == NULL)\n+    return NULL;\n+\n+  op0 = loc_list_from_tree (TREE_OPERAND (loc, 0), 0, context);\n+  op1 = loc_list_from_tree (TREE_OPERAND (loc, 1), 0, context);\n+  if (op0 == NULL || op1 == NULL)\n+    return NULL;\n+\n+  cvt = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);\n+  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+  add_loc_descr_to_each (op0, cvt);\n+\n+  cvt = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);\n+  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+  add_loc_descr_to_each (op1, cvt);\n+\n+  add_loc_list (&op0, op1);\n+  if (op0 == NULL)\n+    return NULL;\n+\n+  binop = new_loc_descr (op, 0, 0);\n+  convert_descriptor_to_mode (mode, binop);\n+  add_loc_descr_to_each (op0, binop);\n+\n+  return op0;\n+}\n \n /* Generate Dwarf location list representing LOC.\n    If WANT_ADDRESS is false, expression computing LOC will be computed\n@@ -19096,13 +19140,53 @@ loc_list_from_tree_1 (tree loc, int want_address,\n       op = DW_OP_or;\n       goto do_binop;\n \n+    case EXACT_DIV_EXPR:\n     case FLOOR_DIV_EXPR:\n+    case TRUNC_DIV_EXPR:\n+      /* Turn a divide by a power of 2 into a shift when possible.  */\n+      if (TYPE_UNSIGNED (TREE_TYPE (loc))\n+\t  && tree_fits_uhwi_p (TREE_OPERAND (loc, 1)))\n+\t{\n+\t  const int log2 = exact_log2 (tree_to_uhwi (TREE_OPERAND (loc, 1)));\n+\t  if (log2 > 0)\n+\t    {\n+\t      list_ret\n+\t\t= loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 0, context);\n+\t      if (list_ret == 0)\n+\t\treturn 0;\n+\n+\t      add_loc_descr_to_each (list_ret, uint_loc_descriptor (log2));\n+\t      add_loc_descr_to_each (list_ret,\n+\t\t\t\t     new_loc_descr (DW_OP_shr, 0, 0));\n+\t      break;\n+\t    }\n+\t}\n+\n+      /* fall through */\n+\n     case CEIL_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n-    case TRUNC_DIV_EXPR:\n-    case EXACT_DIV_EXPR:\n       if (TYPE_UNSIGNED (TREE_TYPE (loc)))\n-\treturn 0;\n+\t{\n+\t  enum machine_mode mode = TYPE_MODE (TREE_TYPE (loc));\n+\t  scalar_int_mode int_mode;\n+\n+\t  if ((dwarf_strict && dwarf_version < 5)\n+\t      || !is_a <scalar_int_mode> (mode, &int_mode))\n+\t    return 0;\n+\n+\t  /* We can use a signed divide if the sign bit is not set.  */\n+\t  if (GET_MODE_SIZE (int_mode) < DWARF2_ADDR_SIZE)\n+\t    {\n+\t      op = DW_OP_div;\n+\t      goto do_binop;\n+\t    }\n+\n+\t  list_ret = typed_binop_from_tree (DW_OP_div, loc,\n+\t\t\t\t\t    base_type_for_mode (int_mode, 1),\n+\t\t\t\t\t    int_mode, context);\n+\t  break;\n+\t}\n       op = DW_OP_div;\n       goto do_binop;\n "}]}