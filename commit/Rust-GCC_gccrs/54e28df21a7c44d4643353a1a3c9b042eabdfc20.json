{"sha": "54e28df21a7c44d4643353a1a3c9b042eabdfc20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRlMjhkZjIxYTdjNDRkNDY0MzM1M2ExYTNjOWIwNDJlYWJkZmMyMA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2013-10-14T12:34:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-14T12:34:33Z"}, "message": "aspects.adb: Add an entry in table Canonical_Aspect for Initializes.\n\n2013-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb: Add an entry in table Canonical_Aspect for\n\tInitializes.\n\t* aspects.ads: Add entries in tables Aspect_Id, Aspect_Argument,\n\tAspect_Names and Aspect_Delay for Initializes.\n\t* atree.ads, atree.adb (Ekind_In): New seven argument versions of the\n\troutines.\n\t* einfo.adb: Remove Refined_State_Pragma from the list of node\n\tusage. Finalizer is now at position 28.\n\t(Contract): Package\n\tand package bodies now have a contract.\n\t(Finalizer): Update\n\tthe assertion and node usage.\n\t(Get_Pragma): Update the Is_CDG\n\tflag to include Abstract_State, Initializes and Refined_State.\n\t(Refined_State_Pragma): Removed.\n\t(Set_Contract): Package and\n\tpackage bodies now have a contract.\n\t(Set_Finalizer): Update the\n\tassertion and node usage.\n\t(Set_Refined_State_Pragma): Removed.\n\t(Write_Field8_Name): Remove the output for Refined_State_Pragma.\n\t(Write_Field24_Name): Remove the output for Finalizer. Package\n\tand package bodies now have a contract.\n\t(Write_Field28_Name):\n\tAdd output for Finalizer.\n\t* einfo.ads: Update the documentation and usage in entities\n\tof attribute Contract. Update the node position and usage in\n\tentities of attribute Finalizer. Remove the documentation\n\tand usage in entities for attribute Refined_State_Pragma.\n\t(Refined_State_Pragma): Removed along with pragma Inline.\n\t(Set_Refined_State_Pragma): Removed along with pragma Inline.\n\t* par-prag.adb: Add Initializes to the pragmas that do not\n\trequire special processing by the parser.\n\t* sem_ch3.adb (Analyze_Declarations): Add local variable\n\tPrag. Update the retrieval of pragma Refined_State. Analyze\n\taspect/pragma Initializes at the end of the visible declarations\n\tof the related package.\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Contract):\n\tAdd local variables Ref_Depends and Ref_Global. Analyze\n\tpragmas Refined_Global and Refined_Depends in that order.\n\t(Analyze_Subprogram_Contract): Add local variables Depends and\n\tGlobal. Analyze pragmas Global and Depends in that order.\n\t* sem_ch7.adb (Analyze_Package_Body_Helper): Package\n\tbodies now have a contract. Move the analysis of the aspect\n\tspecifications after the defining entity has been decorated.\n\t(Analyze_Package_Declaration): Packages now have a contract. Move\n\tthe analysis of the aspect specifications after the defining\n\tentity has been decorated.\n\t* sem_ch12.adb (Analyze_Generic_Package_Declaration): Packages\n\tnow have contracts.\n\t* sem_ch13.adb (Analyze_Pragma): Code cleanup for aspect\n\tAbstract_State. Add processing for aspect Initializes.\n\t(Check_Aspect_At_Freeze_Point): Add an entry for Initializes.\n\t* sem_prag.adb: Use Get_Pragma_Arg to extract the expression\n\tof a pragma argument. Add an entry in table Sig_Flags for\n\tInitializes.\n\t(Analyze_Initializes_In_Decl_Part): New routine.\n\t(Analyze_Pragma): Check the declaration order of pragmas\n\tAbstract_State and Initializes. Abstract_State is now part of\n\tthe package contract. Analyze pragma Initializes. Check for\n\tduplicate Refined_State pragma. Refined_State is now part of\n\tthe package contract.\n\t(Check_Declaration_Order): New routine.\n\t(Check_Test_Case): Alphabetized.\n\t* sem_prag.ads (Analyze_Initializes_In_Decl_Part): New routine.\n\t* sem_util.adb (Add_Contract_Item): Rename formal Subp_Id\n\tto Id. This routine can now support contracts on packages and\n\tpackage bodies.\n\t* sem_util.ads (Add_Contract_Item): Rename formal Subp_Id to\n\tId. Update comment on usage.\n\t* sinfo.ads: Update the usage of N_Contract nodes.\n\t* snames.ads-tmpl: Add predefined name Initializes. Add new\n\tpragma id for Initializes.\n\nFrom-SVN: r203522", "tree": {"sha": "156b5dedcb53330b9e3b1d674951b1f6178c1af4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/156b5dedcb53330b9e3b1d674951b1f6178c1af4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54e28df21a7c44d4643353a1a3c9b042eabdfc20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54e28df21a7c44d4643353a1a3c9b042eabdfc20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54e28df21a7c44d4643353a1a3c9b042eabdfc20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54e28df21a7c44d4643353a1a3c9b042eabdfc20/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "83fd5d110eadec9102981082459e9fa5513b5124", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83fd5d110eadec9102981082459e9fa5513b5124", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83fd5d110eadec9102981082459e9fa5513b5124"}], "stats": {"total": 1188, "additions": 1013, "deletions": 175}, "files": [{"sha": "f9c6ace636c397258e7e88e211e61ee702ae0dc9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -1,3 +1,79 @@\n+2013-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb: Add an entry in table Canonical_Aspect for\n+\tInitializes.\n+\t* aspects.ads: Add entries in tables Aspect_Id, Aspect_Argument,\n+\tAspect_Names and Aspect_Delay for Initializes.\n+\t* atree.ads, atree.adb (Ekind_In): New seven argument versions of the\n+\troutines.\n+\t* einfo.adb: Remove Refined_State_Pragma from the list of node\n+\tusage. Finalizer is now at position 28.\n+\t(Contract): Package\n+\tand package bodies now have a contract.\n+\t(Finalizer): Update\n+\tthe assertion and node usage.\n+\t(Get_Pragma): Update the Is_CDG\n+\tflag to include Abstract_State, Initializes and Refined_State.\n+\t(Refined_State_Pragma): Removed.\n+\t(Set_Contract): Package and\n+\tpackage bodies now have a contract.\n+\t(Set_Finalizer): Update the\n+\tassertion and node usage.\n+\t(Set_Refined_State_Pragma): Removed.\n+\t(Write_Field8_Name): Remove the output for Refined_State_Pragma.\n+\t(Write_Field24_Name): Remove the output for Finalizer. Package\n+\tand package bodies now have a contract.\n+\t(Write_Field28_Name):\n+\tAdd output for Finalizer.\n+\t* einfo.ads: Update the documentation and usage in entities\n+\tof attribute Contract. Update the node position and usage in\n+\tentities of attribute Finalizer. Remove the documentation\n+\tand usage in entities for attribute Refined_State_Pragma.\n+\t(Refined_State_Pragma): Removed along with pragma Inline.\n+\t(Set_Refined_State_Pragma): Removed along with pragma Inline.\n+\t* par-prag.adb: Add Initializes to the pragmas that do not\n+\trequire special processing by the parser.\n+\t* sem_ch3.adb (Analyze_Declarations): Add local variable\n+\tPrag. Update the retrieval of pragma Refined_State. Analyze\n+\taspect/pragma Initializes at the end of the visible declarations\n+\tof the related package.\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Contract):\n+\tAdd local variables Ref_Depends and Ref_Global. Analyze\n+\tpragmas Refined_Global and Refined_Depends in that order.\n+\t(Analyze_Subprogram_Contract): Add local variables Depends and\n+\tGlobal. Analyze pragmas Global and Depends in that order.\n+\t* sem_ch7.adb (Analyze_Package_Body_Helper): Package\n+\tbodies now have a contract. Move the analysis of the aspect\n+\tspecifications after the defining entity has been decorated.\n+\t(Analyze_Package_Declaration): Packages now have a contract. Move\n+\tthe analysis of the aspect specifications after the defining\n+\tentity has been decorated.\n+\t* sem_ch12.adb (Analyze_Generic_Package_Declaration): Packages\n+\tnow have contracts.\n+\t* sem_ch13.adb (Analyze_Pragma): Code cleanup for aspect\n+\tAbstract_State. Add processing for aspect Initializes.\n+\t(Check_Aspect_At_Freeze_Point): Add an entry for Initializes.\n+\t* sem_prag.adb: Use Get_Pragma_Arg to extract the expression\n+\tof a pragma argument. Add an entry in table Sig_Flags for\n+\tInitializes.\n+\t(Analyze_Initializes_In_Decl_Part): New routine.\n+\t(Analyze_Pragma): Check the declaration order of pragmas\n+\tAbstract_State and Initializes. Abstract_State is now part of\n+\tthe package contract. Analyze pragma Initializes. Check for\n+\tduplicate Refined_State pragma. Refined_State is now part of\n+\tthe package contract.\n+\t(Check_Declaration_Order): New routine.\n+\t(Check_Test_Case): Alphabetized.\n+\t* sem_prag.ads (Analyze_Initializes_In_Decl_Part): New routine.\n+\t* sem_util.adb (Add_Contract_Item): Rename formal Subp_Id\n+\tto Id. This routine can now support contracts on packages and\n+\tpackage bodies.\n+\t* sem_util.ads (Add_Contract_Item): Rename formal Subp_Id to\n+\tId. Update comment on usage.\n+\t* sinfo.ads: Update the usage of N_Contract nodes.\n+\t* snames.ads-tmpl: Add predefined name Initializes. Add new\n+\tpragma id for Initializes.\n+\n 2013-10-13  Nicolas Roche  <roche@adacore.com>\n             Eric Botcazou  <ebotcazou@adacore.com>\n "}, {"sha": "b9f1a56af6c93ab80bfcdb680e8d4f987f87e9a3", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -440,6 +440,7 @@ package body Aspects is\n     Aspect_Independent_Components       => Aspect_Independent_Components,\n     Aspect_Inline                       => Aspect_Inline,\n     Aspect_Inline_Always                => Aspect_Inline,\n+    Aspect_Initializes                  => Aspect_Initializes,\n     Aspect_Input                        => Aspect_Input,\n     Aspect_Interrupt_Handler            => Aspect_Interrupt_Handler,\n     Aspect_Interrupt_Priority           => Aspect_Priority,"}, {"sha": "2325d9703838e304bfc448227db2f07e93a5be46", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -96,6 +96,7 @@ package Aspects is\n       Aspect_External_Tag,\n       Aspect_Global,                        -- GNAT\n       Aspect_Implicit_Dereference,\n+      Aspect_Initializes,                   -- GNAT\n       Aspect_Input,\n       Aspect_Interrupt_Priority,\n       Aspect_Invariant,                     -- GNAT\n@@ -309,6 +310,7 @@ package Aspects is\n       Aspect_External_Tag            => Expression,\n       Aspect_Global                  => Expression,\n       Aspect_Implicit_Dereference    => Name,\n+      Aspect_Initializes             => Expression,\n       Aspect_Input                   => Name,\n       Aspect_Interrupt_Priority      => Expression,\n       Aspect_Invariant               => Expression,\n@@ -398,6 +400,7 @@ package Aspects is\n       Aspect_Independent_Components       => Name_Independent_Components,\n       Aspect_Inline                       => Name_Inline,\n       Aspect_Inline_Always                => Name_Inline_Always,\n+      Aspect_Initializes                  => Name_Initializes,\n       Aspect_Input                        => Name_Input,\n       Aspect_Interrupt_Handler            => Name_Interrupt_Handler,\n       Aspect_Interrupt_Priority           => Name_Interrupt_Priority,\n@@ -597,6 +600,7 @@ package Aspects is\n       Aspect_Independent_Components       => Always_Delay,\n       Aspect_Inline                       => Always_Delay,\n       Aspect_Inline_Always                => Always_Delay,\n+      Aspect_Initializes                  => Always_Delay,\n       Aspect_Input                        => Always_Delay,\n       Aspect_Interrupt_Handler            => Always_Delay,\n       Aspect_Interrupt_Priority           => Always_Delay,"}, {"sha": "a44a247b89606eba37c83549e08b4d6649eb021b", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -978,6 +978,26 @@ package body Atree is\n              T = V6;\n    end Ekind_In;\n \n+   function Ekind_In\n+     (T  : Entity_Kind;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind;\n+      V5 : Entity_Kind;\n+      V6 : Entity_Kind;\n+      V7 : Entity_Kind) return Boolean\n+   is\n+   begin\n+      return T = V1 or else\n+             T = V2 or else\n+             T = V3 or else\n+             T = V4 or else\n+             T = V5 or else\n+             T = V6 or else\n+             T = V7;\n+   end Ekind_In;\n+\n    function Ekind_In\n      (E  : Entity_Id;\n       V1 : Entity_Kind;\n@@ -1033,6 +1053,20 @@ package body Atree is\n       return Ekind_In (Ekind (E), V1, V2, V3, V4, V5, V6);\n    end Ekind_In;\n \n+   function Ekind_In\n+     (E  : Entity_Id;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind;\n+      V5 : Entity_Kind;\n+      V6 : Entity_Kind;\n+      V7 : Entity_Kind) return Boolean\n+   is\n+   begin\n+      return Ekind_In (Ekind (E), V1, V2, V3, V4, V5, V6, V7);\n+   end Ekind_In;\n+\n    ------------------------\n    -- Set_Reporting_Proc --\n    ------------------------"}, {"sha": "54655545dbdd68cc400a5b4a134ce7c7a2fec392", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -735,6 +735,16 @@ package Atree is\n       V5 : Entity_Kind;\n       V6 : Entity_Kind) return Boolean;\n \n+   function Ekind_In\n+     (E  : Entity_Id;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind;\n+      V5 : Entity_Kind;\n+      V6 : Entity_Kind;\n+      V7 : Entity_Kind) return Boolean;\n+\n    function Ekind_In\n      (T  : Entity_Kind;\n       V1 : Entity_Kind;\n@@ -770,6 +780,16 @@ package Atree is\n       V5 : Entity_Kind;\n       V6 : Entity_Kind) return Boolean;\n \n+   function Ekind_In\n+     (T  : Entity_Kind;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind;\n+      V5 : Entity_Kind;\n+      V6 : Entity_Kind;\n+      V7 : Entity_Kind) return Boolean;\n+\n    pragma Inline (Ekind_In);\n    --  Inline all above functions\n "}, {"sha": "2c1a094a4bb06a6a7b4531cf86b398bf2794c45e", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 38, "deletions": 40, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -80,7 +80,6 @@ package body Einfo is\n    --    Mechanism                       Uint8 (but returns Mechanism_Type)\n    --    Normalized_First_Bit            Uint8\n    --    Postcondition_Proc              Node8\n-   --    Refined_State_Pragma            Node8\n    --    Refinement_Constituents         Elist8\n    --    Return_Applies_To               Node8\n    --    First_Exit_Statement            Node8\n@@ -213,7 +212,6 @@ package body Einfo is\n    --    Protection_Object               Node23\n    --    Stored_Constraint               Elist23\n \n-   --    Finalizer                       Node24\n    --    Related_Expression              Node24\n    --    Contract                        Node24\n \n@@ -238,6 +236,7 @@ package body Einfo is\n    --    Wrapped_Entity                  Node27\n \n    --    Extra_Formals                   Node28\n+   --    Finalizer                       Node28\n    --    Initialization_Statements       Node28\n    --    Underlying_Record_View          Node28\n \n@@ -1068,9 +1067,14 @@ package body Einfo is\n    function Contract (Id : E) return N is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Entry, E_Entry_Family, E_Subprogram_Body)\n-          or else Is_Subprogram (Id)\n-          or else Is_Generic_Subprogram (Id));\n+        (Ekind_In (Id, E_Entry,\n+                       E_Entry_Family,\n+                       E_Generic_Package,\n+                       E_Package,\n+                       E_Package_Body,\n+                       E_Subprogram_Body)\n+          or else Is_Generic_Subprogram (Id)\n+          or else Is_Subprogram (Id));\n       return Node24 (Id);\n    end Contract;\n \n@@ -1180,10 +1184,8 @@ package body Einfo is\n \n    function Finalizer (Id : E) return E is\n    begin\n-      pragma Assert\n-        (Ekind (Id) = E_Package\n-          or else Ekind (Id) = E_Package_Body);\n-      return Node24 (Id);\n+      pragma Assert (Ekind_In (Id, E_Package, E_Package_Body));\n+      return Node28 (Id);\n    end Finalizer;\n \n    function First_Entity (Id : E) return E is\n@@ -2656,12 +2658,6 @@ package body Einfo is\n       return Node10 (Id);\n    end Refined_State;\n \n-   function Refined_State_Pragma (Id : E) return N is\n-   begin\n-      pragma Assert (Ekind (Id) = E_Package_Body);\n-      return Node8 (Id);\n-   end Refined_State_Pragma;\n-\n    function Refinement_Constituents (Id : E) return L is\n    begin\n       pragma Assert (Ekind (Id) = E_Abstract_State);\n@@ -3666,9 +3662,15 @@ package body Einfo is\n    procedure Set_Contract (Id : E; V : N) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Entry, E_Entry_Family, E_Subprogram_Body, E_Void)\n-          or else Is_Subprogram (Id)\n-          or else Is_Generic_Subprogram (Id));\n+        (Ekind_In (Id, E_Entry,\n+                       E_Entry_Family,\n+                       E_Generic_Package,\n+                       E_Package,\n+                       E_Package_Body,\n+                       E_Subprogram_Body,\n+                       E_Void)\n+          or else Is_Generic_Subprogram (Id)\n+          or else Is_Subprogram (Id));\n       Set_Node24 (Id, V);\n    end Set_Contract;\n \n@@ -3779,10 +3781,8 @@ package body Einfo is\n \n    procedure Set_Finalizer (Id : E; V : E) is\n    begin\n-      pragma Assert\n-        (Ekind (Id) = E_Package\n-          or else Ekind (Id) = E_Package_Body);\n-      Set_Node24 (Id, V);\n+      pragma Assert (Ekind_In (Id, E_Package, E_Package_Body));\n+      Set_Node28 (Id, V);\n    end Set_Finalizer;\n \n    procedure Set_First_Entity (Id : E; V : E) is\n@@ -5328,12 +5328,6 @@ package body Einfo is\n       Set_Node10 (Id, V);\n    end Set_Refined_State;\n \n-   procedure Set_Refined_State_Pragma (Id : E; V : N) is\n-   begin\n-      pragma Assert (Ekind (Id) = E_Package_Body);\n-      Set_Node8 (Id, V);\n-   end Set_Refined_State_Pragma;\n-\n    procedure Set_Refinement_Constituents (Id : E; V : L) is\n    begin\n       pragma Assert (Ekind (Id) = E_Abstract_State);\n@@ -6293,15 +6287,18 @@ package body Einfo is\n \n    function Get_Pragma (E : Entity_Id; Id : Pragma_Id) return Node_Id is\n       Is_CDG  : constant Boolean :=\n+                  Id = Pragma_Abstract_State  or else\n                   Id = Pragma_Depends         or else\n                   Id = Pragma_Global          or else\n+                  Id = Pragma_Initializes     or else\n                   Id = Pragma_Refined_Depends or else\n-                  Id = Pragma_Refined_Global;\n+                  Id = Pragma_Refined_Global  or else\n+                  Id = Pragma_Refined_State;\n       Is_CTC : constant Boolean :=\n                   Id = Pragma_Contract_Cases  or else\n                   Id = Pragma_Test_Case;\n       Is_PPC : constant Boolean :=\n-                  Id = Pragma_Precondition     or else\n+                  Id = Pragma_Precondition    or else\n                   Id = Pragma_Postcondition;\n \n       In_Contract : constant Boolean := Is_CDG or Is_CTC or Is_PPC;\n@@ -8339,9 +8336,6 @@ package body Einfo is\n          when E_Procedure                                  =>\n             Write_Str (\"Postcondition_Proc\");\n \n-         when E_Package_Body                               =>\n-            Write_Str (\"Refined_State_Pragma\");\n-\n          when E_Abstract_State                             =>\n             Write_Str (\"Refinement_Constituents\");\n \n@@ -9055,20 +9049,19 @@ package body Einfo is\n    procedure Write_Field24_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when E_Package                                    |\n-              E_Package_Body                               =>\n-            Write_Str (\"Finalizer\");\n-\n          when E_Constant                                   |\n               E_Variable                                   |\n               Type_Kind                                    =>\n             Write_Str (\"Related_Expression\");\n \n          when E_Entry                                      |\n               E_Entry_Family                               |\n+              E_Generic_Package                            |\n+              E_Package                                    |\n+              E_Package_Body                               |\n               E_Subprogram_Body                            |\n-              Subprogram_Kind                              |\n-              Generic_Subprogram_Kind                      =>\n+              Generic_Subprogram_Kind                      |\n+              Subprogram_Kind                              =>\n             Write_Str (\"Contract\");\n \n          when others                                       =>\n@@ -9202,7 +9195,12 @@ package body Einfo is\n               E_Subprogram_Type                            =>\n             Write_Str (\"Extra_Formals\");\n \n-         when E_Constant | E_Variable =>\n+         when E_Package                                    |\n+              E_Package_Body                               =>\n+            Write_Str (\"Finalizer\");\n+\n+         when E_Constant                                   |\n+              E_Variable                                   =>\n             Write_Str (\"Initialization_Statements\");\n \n          when E_Record_Type =>"}, {"sha": "489576310e9a1ae6decf2485a92d7d3e343a2c76", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -1022,9 +1022,10 @@ package Einfo is\n --       'COUNT when it applies to a family member.\n \n --    Contract (Node24)\n---       Defined in entry and entry family entities, subprogram body entities,\n---       subprograms, and generic subprograms. Points to the contract of the\n---       entity, holding both preconditions, postconditions, and test cases.\n+--       Defined in entry, entry family, package, package body, subprogram and\n+--       subprogram body entities as well as their respective generic forms.\n+--       Points to the contract of the entity, holding various assertion items\n+--       and data classifiers.\n \n --    Entry_Parameters_Type (Node15)\n --       Defined in entries. Points to the access-to-record type that is\n@@ -1181,7 +1182,7 @@ package Einfo is\n --       the Finalize_Storage_Only pragma is required at each level of\n --       derivation.\n \n---    Finalizer (Node24)\n+--    Finalizer (Node28)\n --       Applies to package declarations and bodies. Contains the entity of the\n --       library-level program which finalizes all package-level controlled\n --       objects.\n@@ -3541,10 +3542,6 @@ package Einfo is\n --       Defined in abstract states and variables. Contains the entity of an\n --       ancestor state whose refinement mentions this item.\n \n---    Refined_State_Pragma (Node8)\n---       Defined in [generic] package bodies. Contains the pragma that refines\n---       all abstract states defined in the corresponding package declaration.\n-\n --    Refinement_Constituents (Elist8)\n --       Present in abstract state entities. Contains all the constituents that\n --       refine the state, in other words, all the hidden states that appear in\n@@ -5626,10 +5623,11 @@ package Einfo is\n    --    Generic_Renamings                   (Elist23)  (for an instance)\n    --    Inner_Instances                     (Elist23)  (generic case only)\n    --    Limited_View                        (Node23)   (non-generic/instance)\n-   --    Finalizer                           (Node24)   (non-generic case only)\n+   --    Contract                            (Node24)\n    --    Abstract_States                     (Elist25)\n    --    Package_Instantiation               (Node26)\n    --    Current_Use_Clause                  (Node27)\n+   --    Finalizer                           (Node28)   (non-generic case only)\n    --    SPARK_Mode_Pragmas                  (Node32)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Body_Needed_For_SAL                 (Flag40)\n@@ -5655,14 +5653,14 @@ package Einfo is\n    --    Scope_Depth                         (synth)\n \n    --  E_Package_Body\n-   --    Refined_State_Pragma                (Node8)\n    --    Handler_Records                     (List10)   (non-generic case only)\n    --    Related_Instance                    (Node15)   (non-generic case only)\n    --    First_Entity                        (Node17)\n    --    Spec_Entity                         (Node19)\n    --    Last_Entity                         (Node20)\n    --    Scope_Depth_Value                   (Uint22)\n-   --    Finalizer                           (Node24)   (non-generic case only)\n+   --    Contract                            (Node24)\n+   --    Finalizer                           (Node28)   (non-generic case only)\n    --    SPARK_Mode_Pragmas                  (Node32)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Has_Anonymous_Master                (Flag253)\n@@ -6553,7 +6551,6 @@ package Einfo is\n    function Referenced_As_LHS                   (Id : E) return B;\n    function Referenced_As_Out_Parameter         (Id : E) return B;\n    function Refined_State                       (Id : E) return E;\n-   function Refined_State_Pragma                (Id : E) return E;\n    function Refinement_Constituents             (Id : E) return L;\n    function Register_Exception_Call             (Id : E) return N;\n    function Related_Array_Object                (Id : E) return E;\n@@ -7173,7 +7170,6 @@ package Einfo is\n    procedure Set_Referenced_As_LHS               (Id : E; V : B := True);\n    procedure Set_Referenced_As_Out_Parameter     (Id : E; V : B := True);\n    procedure Set_Refined_State                   (Id : E; V : E);\n-   procedure Set_Refined_State_Pragma            (Id : E; V : N);\n    procedure Set_Refinement_Constituents         (Id : E; V : L);\n    procedure Set_Register_Exception_Call         (Id : E; V : N);\n    procedure Set_Related_Array_Object            (Id : E; V : E);\n@@ -7931,7 +7927,6 @@ package Einfo is\n    pragma Inline (Referenced_As_LHS);\n    pragma Inline (Referenced_As_Out_Parameter);\n    pragma Inline (Refined_State);\n-   pragma Inline (Refined_State_Pragma);\n    pragma Inline (Refinement_Constituents);\n    pragma Inline (Register_Exception_Call);\n    pragma Inline (Related_Array_Object);\n@@ -8349,7 +8344,6 @@ package Einfo is\n    pragma Inline (Set_Referenced_As_LHS);\n    pragma Inline (Set_Referenced_As_Out_Parameter);\n    pragma Inline (Set_Refined_State);\n-   pragma Inline (Set_Refined_State_Pragma);\n    pragma Inline (Set_Refinement_Constituents);\n    pragma Inline (Set_Register_Exception_Call);\n    pragma Inline (Set_Related_Array_Object);"}, {"sha": "22e79d78921e807b2e0b2bb019b7bfa403f7bc6b", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -1186,6 +1186,7 @@ begin\n            Pragma_Independent                    |\n            Pragma_Independent_Components         |\n            Pragma_Initialize_Scalars             |\n+           Pragma_Initializes                    |\n            Pragma_Inline                         |\n            Pragma_Inline_Always                  |\n            Pragma_Inline_Generic                 |"}, {"sha": "d5c5ce7c595a2adece96dc45e548d1c35fc22c05", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -3022,20 +3022,22 @@ package body Sem_Ch12 is\n       Id := Defining_Entity (N);\n       Generate_Definition (Id);\n \n+      --  Expansion is not applied to generic units\n+\n+      Start_Generic;\n+\n+      Enter_Name (Id);\n+      Set_Ekind    (Id, E_Generic_Package);\n+      Set_Etype    (Id, Standard_Void_Type);\n+      Set_Contract (Id, Make_Contract (Sloc (Id)));\n+\n       --  Analyze aspects now, so that generated pragmas appear in the\n       --  declarations before building and analyzing the generic copy.\n \n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, Id);\n       end if;\n \n-      --  Expansion is not applied to generic units\n-\n-      Start_Generic;\n-\n-      Enter_Name (Id);\n-      Set_Ekind (Id, E_Generic_Package);\n-      Set_Etype (Id, Standard_Void_Type);\n       Push_Scope (Id);\n       Enter_Generic_Scope (Id);\n       Set_Inner_Instances (Id, New_Elmt_List);\n@@ -3124,7 +3126,7 @@ package body Sem_Ch12 is\n             Aspects : constant List_Id := Aspect_Specifications (N);\n          begin\n             Set_Has_Aspects (N, False);\n-            Move_Aspects (New_N, N);\n+            Move_Aspects (New_N, To => N);\n             Set_Has_Aspects (Original_Node (N), False);\n             Set_Aspect_Specifications (Original_Node (N), Aspects);\n          end;\n@@ -4756,7 +4758,7 @@ package body Sem_Ch12 is\n          --  pre/postconditions on the instance are analyzed below, in a\n          --  separate step.\n \n-         Move_Aspects (Act_Tree, Act_Decl);\n+         Move_Aspects (Act_Tree, To => Act_Decl);\n          Set_Categorization_From_Pragmas (Act_Decl);\n \n          if Parent_Installed then"}, {"sha": "29fc1c79382751593a85e0075a15950d22fd0893", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 46, "deletions": 9, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -1883,22 +1883,20 @@ package body Sem_Ch13 is\n \n                --  Abstract_State\n \n+               --  Aspect Abstract_State introduces implicit declarations for\n+               --  all state abstraction entities it defines. To emulate this\n+               --  behavior, insert the pragma at the beginning of the visible\n+               --  declarations of the related package so that it is analyzed\n+               --  immediately.\n+\n                when Aspect_Abstract_State => Abstract_State : declare\n                   Decls : List_Id;\n-                  Spec  : Node_Id;\n \n                begin\n-                  --  Aspect Abstract_State introduces implicit declarations\n-                  --  for all state abstraction entities it defines. To emulate\n-                  --  this behavior, insert the pragma at the beginning of the\n-                  --  visible declarations of the related package so that it is\n-                  --  analyzed immediately.\n-\n                   if Nkind_In (N, N_Generic_Package_Declaration,\n                                   N_Package_Declaration)\n                   then\n-                     Spec  := Specification (N);\n-                     Decls := Visible_Declarations (Spec);\n+                     Decls := Visible_Declarations (Specification (N));\n \n                      Make_Aitem_Pragma\n                        (Pragma_Argument_Associations => New_List (\n@@ -1959,6 +1957,44 @@ package body Sem_Ch13 is\n                   Insert_Delayed_Pragma (Aitem);\n                   goto Continue;\n \n+               --  Initializes\n+\n+               --  Aspect Initializes coverts the visible declarations of a\n+               --  package. As such, it must be evaluated at the end of the\n+               --  said declarations.\n+\n+               when Aspect_Initializes => Initializes : declare\n+                  Decls : List_Id;\n+\n+               begin\n+                  if Nkind_In (N, N_Generic_Package_Declaration,\n+                                  N_Package_Declaration)\n+                  then\n+                     Decls := Visible_Declarations (Specification (N));\n+\n+                     Make_Aitem_Pragma\n+                       (Pragma_Argument_Associations => New_List (\n+                          Make_Pragma_Argument_Association (Loc,\n+                            Expression => Relocate_Node (Expr))),\n+                        Pragma_Name                  => Name_Initializes);\n+                     Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+\n+                     if No (Decls) then\n+                        Decls := New_List;\n+                        Set_Visible_Declarations (N, Decls);\n+                     end if;\n+\n+                     Prepend_To (Decls, Aitem);\n+\n+                  else\n+                     Error_Msg_NE\n+                       (\"aspect & must apply to a package declaration\",\n+                        Aspect, Id);\n+                  end if;\n+\n+                  goto Continue;\n+               end Initializes;\n+\n                --  SPARK_Mode\n \n                when Aspect_SPARK_Mode =>\n@@ -7708,6 +7744,7 @@ package body Sem_Ch13 is\n               Aspect_Dimension            |\n               Aspect_Dimension_System     |\n               Aspect_Implicit_Dereference |\n+              Aspect_Initializes          |\n               Aspect_Post                 |\n               Aspect_Postcondition        |\n               Aspect_Pre                  |"}, {"sha": "b2e2a9263cb43a889c7344450339c02cd5bb2b1e", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -2086,6 +2086,7 @@ package body Sem_Ch3 is\n       Context     : Node_Id;\n       Freeze_From : Entity_Id := Empty;\n       Next_Decl   : Node_Id;\n+      Prag        : Node_Id;\n       Spec_Id     : Entity_Id;\n \n    --  Start of processing for Analyze_Declarations\n@@ -2196,24 +2197,38 @@ package body Sem_Ch3 is\n          Decl := Next_Decl;\n       end loop;\n \n-      --  Analyze the state refinements within a package body now, after all\n-      --  hidden states have been encountered and freely visible. Refinements\n-      --  must be processed before pragmas Refined_Depends and Refined_Global\n-      --  because the last two may mention constituents.\n-\n       if Present (L) then\n          Context := Parent (L);\n \n-         if Nkind (Context) = N_Package_Body then\n+         --  Analyze aspect/pragma Initializes of a package at the end of the\n+         --  visible declarations as the aspect/pragma has visibility over the\n+         --  said region.\n+\n+         if Nkind (Context) = N_Package_Specification\n+           and then L = Visible_Declarations (Context)\n+         then\n+            Spec_Id := Defining_Entity (Parent (Context));\n+            Prag    := Get_Pragma (Spec_Id, Pragma_Initializes);\n+\n+            if Present (Prag) then\n+               Analyze_Initializes_In_Decl_Part (Prag);\n+            end if;\n+\n+         --  Analyze the state refinements within a package body now, after\n+         --  all hidden states have been encountered and freely visible.\n+         --  Refinements must be processed before pragmas Refined_Depends and\n+         --  Refined_Global because the last two may mention constituents.\n+\n+         elsif Nkind (Context) = N_Package_Body then\n             Body_Id := Defining_Entity (Context);\n             Spec_Id := Corresponding_Spec (Context);\n+            Prag    := Get_Pragma (Body_Id, Pragma_Refined_State);\n \n             --  The analysis of pragma Refined_State detects whether the spec\n             --  has abstract states available for refinement.\n \n-            if Present (Refined_State_Pragma (Body_Id)) then\n-               Analyze_Refined_State_In_Decl_Part\n-                 (Refined_State_Pragma (Body_Id));\n+            if Present (Prag) then\n+               Analyze_Refined_State_In_Decl_Part (Prag);\n \n             --  State refinement is required when the package declaration has\n             --  abstract states. Null states are not considered."}, {"sha": "34d0a8853b1e2d79ca2584271d194c42344a8f9b", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -1976,11 +1976,11 @@ package body Sem_Ch6 is\n    --------------------------------------\n \n    procedure Analyze_Subprogram_Body_Contract (Body_Id : Entity_Id) is\n-      Body_Decl : constant Node_Id   := Parent (Parent (Body_Id));\n-      Spec_Id   : constant Entity_Id := Corresponding_Spec (Body_Decl);\n-      Prag      : Node_Id;\n-\n-      Has_Refined_Global : Boolean := False;\n+      Body_Decl   : constant Node_Id   := Parent (Parent (Body_Id));\n+      Spec_Id     : constant Entity_Id := Corresponding_Spec (Body_Decl);\n+      Prag        : Node_Id;\n+      Ref_Depends : Node_Id := Empty;\n+      Ref_Global  : Node_Id := Empty;\n \n    begin\n       --  When a subprogram body declaration is erroneous, its defining entity\n@@ -1991,22 +1991,30 @@ package body Sem_Ch6 is\n          return;\n       end if;\n \n+      --  Locate and store pragmas Refined_Depends and Refined_Global since\n+      --  their order of analysis matters.\n+\n       Prag := Classifications (Contract (Body_Id));\n       while Present (Prag) loop\n          if Pragma_Name (Prag) = Name_Refined_Depends then\n-            Analyze_Refined_Depends_In_Decl_Part (Prag);\n+            Ref_Depends := Prag;\n          elsif Pragma_Name (Prag) = Name_Refined_Global then\n-            Has_Refined_Global := True;\n-            Analyze_Refined_Global_In_Decl_Part (Prag);\n+            Ref_Global := Prag;\n          end if;\n \n          Prag := Next_Pragma (Prag);\n       end loop;\n \n+      --  Analyze Refined_Global first as Refined_Depends may mention items\n+      --  classified in the global refinement.\n+\n+      if Present (Ref_Global) then\n+         Analyze_Refined_Global_In_Decl_Part (Ref_Global);\n+\n       --  When the corresponding Global aspect/pragma references a state with\n       --  visible refinement, the body requires Refined_Global.\n \n-      if not Has_Refined_Global and then Present (Spec_Id) then\n+      elsif Present (Spec_Id) then\n          Prag := Get_Pragma (Spec_Id, Pragma_Global);\n \n          if Present (Prag) and then Contains_Refined_State (Prag) then\n@@ -2015,6 +2023,13 @@ package body Sem_Ch6 is\n                Body_Decl, Spec_Id);\n          end if;\n       end if;\n+\n+      --  Refined_Depends must be analyzed after Refined_Global in order to see\n+      --  the modes of all global refinements.\n+\n+      if Present (Ref_Depends) then\n+         Analyze_Refined_Depends_In_Decl_Part (Ref_Depends);\n+      end if;\n    end Analyze_Subprogram_Body_Contract;\n \n    ------------------------------------\n@@ -3570,17 +3585,16 @@ package body Sem_Ch6 is\n       --  Local variables\n \n       Items       : constant Node_Id := Contract (Subp);\n-      Error_CCase : Node_Id;\n-      Error_Post  : Node_Id;\n+      Depends     : Node_Id := Empty;\n+      Error_CCase : Node_Id := Empty;\n+      Error_Post  : Node_Id := Empty;\n+      Global      : Node_Id := Empty;\n       Nam         : Name_Id;\n       Prag        : Node_Id;\n \n    --  Start of processing for Analyze_Subprogram_Contract\n \n    begin\n-      Error_CCase := Empty;\n-      Error_Post  := Empty;\n-\n       if Present (Items) then\n \n          --  Analyze pre- and postconditions\n@@ -3635,14 +3649,27 @@ package body Sem_Ch6 is\n             Nam := Pragma_Name (Prag);\n \n             if Nam = Name_Depends then\n-               Analyze_Depends_In_Decl_Part (Prag);\n-            else\n-               pragma Assert (Nam = Name_Global);\n-               Analyze_Global_In_Decl_Part (Prag);\n+               Depends := Prag;\n+            else pragma Assert (Nam = Name_Global);\n+               Global := Prag;\n             end if;\n \n             Prag := Next_Pragma (Prag);\n          end loop;\n+\n+         --  Analyze Global first as Depends may mention items classified in\n+         --  the global categorization.\n+\n+         if Present (Global) then\n+            Analyze_Global_In_Decl_Part (Global);\n+         end if;\n+\n+         --  Depends must be analyzed after Global in order to see the modes of\n+         --  all global items.\n+\n+         if Present (Depends) then\n+            Analyze_Depends_In_Decl_Part (Depends);\n+         end if;\n       end if;\n \n       --  Emit an error when none of the postconditions or contract-cases"}, {"sha": "d15add3bf534844a23942a624fec0869aec30944", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -224,15 +224,10 @@ package body Sem_Ch7 is\n \n       Body_Id := Defining_Entity (N);\n \n-      if Has_Aspects (N) then\n-         Analyze_Aspect_Specifications (N, Body_Id);\n-      end if;\n+      --  Body is body of package instantiation. Corresponding spec has already\n+      --  been set.\n \n       if Present (Corresponding_Spec (N)) then\n-\n-         --  Body is body of package instantiation. Corresponding spec has\n-         --  already been set.\n-\n          Spec_Id := Corresponding_Spec (N);\n          Pack_Decl := Unit_Declaration_Node (Spec_Id);\n \n@@ -315,6 +310,7 @@ package body Sem_Ch7 is\n       Set_Ekind (Body_Id, E_Package_Body);\n       Set_Body_Entity (Spec_Id, Body_Id);\n       Set_Spec_Entity (Body_Id, Spec_Id);\n+      Set_Contract    (Body_Id, Make_Contract (Sloc (Body_Id)));\n \n       --  Defining name for the package body is not a visible entity: Only the\n       --  defining name for the declaration is visible.\n@@ -338,6 +334,10 @@ package body Sem_Ch7 is\n       Set_Has_Completion (Spec_Id);\n       Last_Spec_Entity := Last_Entity (Spec_Id);\n \n+      if Has_Aspects (N) then\n+         Analyze_Aspect_Specifications (N, Body_Id);\n+      end if;\n+\n       Push_Scope (Spec_Id);\n \n       Set_Categorization_From_Pragmas (N);\n@@ -770,6 +770,21 @@ package body Sem_Ch7 is\n       --  True when this package declaration is not a nested declaration\n \n    begin\n+      if Debug_Flag_C then\n+         Write_Str (\"==> package spec \");\n+         Write_Name (Chars (Id));\n+         Write_Str (\" from \");\n+         Write_Location (Sloc (N));\n+         Write_Eol;\n+         Indent;\n+      end if;\n+\n+      Generate_Definition (Id);\n+      Enter_Name (Id);\n+      Set_Ekind    (Id, E_Package);\n+      Set_Etype    (Id, Standard_Void_Type);\n+      Set_Contract (Id, Make_Contract (Sloc (Id)));\n+\n       --  Analyze aspect specifications immediately, since we need to recognize\n       --  things like Pure early enough to diagnose violations during analysis.\n \n@@ -788,20 +803,6 @@ package body Sem_Ch7 is\n          return;\n       end if;\n \n-      if Debug_Flag_C then\n-         Write_Str (\"==> package spec \");\n-         Write_Name (Chars (Id));\n-         Write_Str (\" from \");\n-         Write_Location (Sloc (N));\n-         Write_Eol;\n-         Indent;\n-      end if;\n-\n-      Generate_Definition (Id);\n-      Enter_Name (Id);\n-      Set_Ekind (Id, E_Package);\n-      Set_Etype (Id, Standard_Void_Type);\n-\n       Push_Scope (Id);\n \n       PF := Is_Pure (Enclosing_Lib_Unit_Entity);"}, {"sha": "070d7cbb48b300c45ee91d666aa8f6e2da4bd7d0", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 589, "deletions": 28, "changes": 617, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -412,7 +412,7 @@ package body Sem_Prag is\n \n       Subp_Decl := Find_Related_Subprogram (N);\n       Subp_Id   := Defining_Unit_Name (Specification (Subp_Decl));\n-      All_Cases := Expression (First (Pragma_Argument_Associations (N)));\n+      All_Cases := Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n \n       --  Multiple contract cases appear in aggregate form\n \n@@ -1243,7 +1243,7 @@ package body Sem_Prag is\n \n       Subp_Decl := Find_Related_Subprogram (N);\n       Subp_Id   := Defining_Unit_Name (Specification (Subp_Decl));\n-      Clause    := Expression (First (Pragma_Argument_Associations (N)));\n+      Clause    := Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n \n       --  Empty dependency list\n \n@@ -1701,7 +1701,7 @@ package body Sem_Prag is\n \n       Subp_Decl := Find_Related_Subprogram (N);\n       Subp_Id   := Defining_Unit_Name (Specification (Subp_Decl));\n-      List      := Expression (First (Pragma_Argument_Associations (N)));\n+      List      := Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n \n       --  There is nothing to be done for a null global list\n \n@@ -1731,6 +1731,337 @@ package body Sem_Prag is\n       end if;\n    end Analyze_Global_In_Decl_Part;\n \n+   --------------------------------------\n+   -- Analyze_Initializes_In_Decl_Part --\n+   --------------------------------------\n+\n+   procedure Analyze_Initializes_In_Decl_Part (N : Node_Id) is\n+      Pack_Spec : constant Node_Id   := Parent (N);\n+      Pack_Id   : constant Entity_Id := Defining_Entity (Parent (Pack_Spec));\n+\n+      Items_Seen : Elist_Id := No_Elist;\n+      --  A list of all initialization items processed so far. This list is\n+      --  used to detect duplicate items.\n+\n+      Non_Null_Seen : Boolean := False;\n+      Null_Seen     : Boolean := False;\n+      --  Flags used to check the legality of a null initialization list\n+\n+      States_And_Vars : Elist_Id := No_Elist;\n+      --  A list of all abstract states and variables declared in the visible\n+      --  declarations of the related package. This list is used to detect the\n+      --  legality of initialization items.\n+\n+      procedure Analyze_Initialization_Item (Item : Node_Id);\n+      --  Verify the legality of a single initialization item\n+\n+      procedure Analyze_Initialization_Item_With_Inputs (Item : Node_Id);\n+      --  Verify the legality of a single initialization item followed by a\n+      --  list of input items.\n+\n+      procedure Collect_States_And_Variables;\n+      --  Inspect the visible declarations of the related package and gather\n+      --  the entities of all abstract states and variables in States_And_Vars.\n+\n+      ---------------------------------\n+      -- Analyze_Initialization_Item --\n+      ---------------------------------\n+\n+      procedure Analyze_Initialization_Item (Item : Node_Id) is\n+         Item_Id : Entity_Id;\n+\n+      begin\n+         --  A package with null initialization list is not allowed to have\n+         --  additional initializations.\n+\n+         if Null_Seen then\n+            Error_Msg_NE (\"package & has null initialization\", Item, Pack_Id);\n+\n+         --  Null initialization list\n+\n+         elsif Nkind (Item) = N_Null then\n+\n+            --  Catch a case where a null initialization item appears in a list\n+            --  of non-null items.\n+\n+            if Non_Null_Seen then\n+               Error_Msg_NE\n+                 (\"package & has non-null initialization\", Item, Pack_Id);\n+            else\n+               Null_Seen := True;\n+            end if;\n+\n+         --  Initialization item\n+\n+         else\n+            Non_Null_Seen := True;\n+\n+            Analyze (Item);\n+\n+            if Is_Entity_Name (Item) then\n+               Item_Id := Entity (Item);\n+\n+               if Ekind_In (Item_Id, E_Abstract_State, E_Variable) then\n+\n+                  --  The state or variable must be declared in the visible\n+                  --  declarations of the package.\n+\n+                  if not Contains (States_And_Vars, Item_Id) then\n+                     Error_Msg_Name_1 := Chars (Pack_Id);\n+                     Error_Msg_NE\n+                       (\"initialization item & must appear in the visible \"\n+                        & \"declarations of package %\", Item, Item_Id);\n+\n+                  --  Detect a duplicate use of the same initialization item\n+\n+                  elsif Contains (Items_Seen, Item_Id) then\n+                     Error_Msg_N (\"duplicate initialization item\", Item);\n+\n+                  --  The item is legal, add it to the list of processed states\n+                  --  and variables.\n+\n+                  else\n+                     Add_Item (Item_Id, Items_Seen);\n+                  end if;\n+\n+               --  The item references something that is not a state or a\n+               --  variable.\n+\n+               else\n+                  Error_Msg_N\n+                    (\"initialization item must denote variable or state\",\n+                     Item);\n+               end if;\n+\n+            --  Some form of illegal construct masquerading as a name\n+\n+            else\n+               Error_Msg_N\n+                 (\"initialization item must denote variable or state\", Item);\n+            end if;\n+         end if;\n+      end Analyze_Initialization_Item;\n+\n+      ---------------------------------------------\n+      -- Analyze_Initialization_Item_With_Inputs --\n+      ---------------------------------------------\n+\n+      procedure Analyze_Initialization_Item_With_Inputs (Item : Node_Id) is\n+         Inputs_Seen : Elist_Id := No_Elist;\n+         --  A list of all inputs processed so far. This list is used to detect\n+         --  duplicate uses of an input.\n+\n+         Non_Null_Seen : Boolean := False;\n+         Null_Seen     : Boolean := False;\n+         --  Flags used to check the legality of an input list\n+\n+         procedure Analyze_Input_Item (Input : Node_Id);\n+         --  Verify the legality of a single input item\n+\n+         ------------------------\n+         -- Analyze_Input_Item --\n+         ------------------------\n+\n+         procedure Analyze_Input_Item (Input : Node_Id) is\n+            Input_Id : Entity_Id;\n+\n+         begin\n+            --  An initialization item with null inputs is not allowed to have\n+            --  assitional inputs.\n+\n+            if Null_Seen then\n+               Error_Msg_N (\"item has null input list\", Item);\n+\n+            --  Null input list\n+\n+            elsif Nkind (Input) = N_Null then\n+\n+               --  Catch a case where a null input appears in a list of non-\n+               --  null inpits.\n+\n+               if Non_Null_Seen then\n+                  Error_Msg_N (\"item has non-null input list\", Item);\n+               else\n+                  Null_Seen := True;\n+               end if;\n+\n+            --  Input item\n+\n+            else\n+               Non_Null_Seen := True;\n+\n+               Analyze (Input);\n+\n+               if Is_Entity_Name (Input) then\n+                  Input_Id := Entity (Input);\n+\n+                  if Ekind_In (Input_Id, E_Abstract_State, E_Variable) then\n+\n+                     --  The input cannot denote states or variables declared\n+                     --  within the visible declarations of the package.\n+\n+                     if Contains (States_And_Vars, Input_Id) then\n+                        Error_Msg_Name_1 := Chars (Pack_Id);\n+                        Error_Msg_NE\n+                          (\"input item & cannot denote a visible variable or \"\n+                           & \"state of package %\", Input, Input_Id);\n+\n+                     --  Detect a duplicate use of the same input item\n+\n+                     elsif Contains (Inputs_Seen, Input_Id) then\n+                        Error_Msg_N (\"duplicate input item\", Input);\n+\n+                     --  The input is legal, add it to the list of processed\n+                     --  inputs.\n+\n+                     else\n+                        Add_Item (Input_Id, Inputs_Seen);\n+                     end if;\n+\n+                  --  The input references something that is not a state or a\n+                  --  variable.\n+\n+                  else\n+                     Error_Msg_N\n+                       (\"input item must denote variable or state\", Input);\n+                  end if;\n+\n+               --  Some form of illegal construct masquerading as a name\n+\n+               else\n+                  Error_Msg_N\n+                    (\"input item must denote variable or state\", Input);\n+               end if;\n+            end if;\n+         end Analyze_Input_Item;\n+\n+         --  Local variables\n+\n+         Inputs : constant Node_Id := Expression (Item);\n+         Elmt   : Node_Id;\n+         Input  : Node_Id;\n+\n+         Name_Seen : Boolean := False;\n+         --  A flag used to detect multiple item names\n+\n+      --  Start of processing for Analyze_Initialization_Item_With_Inputs\n+\n+      begin\n+         --  Inspect the name of an item with inputs\n+\n+         Elmt := First (Choices (Item));\n+         while Present (Elmt) loop\n+            if Name_Seen then\n+               Error_Msg_N (\"only one item allowed in initialization\", Elmt);\n+\n+            else\n+               Name_Seen := True;\n+               Analyze_Initialization_Item (Elmt);\n+            end if;\n+\n+            Next (Elmt);\n+         end loop;\n+\n+         --  Multiple input items appear as an aggregate\n+\n+         if Nkind (Inputs) = N_Aggregate then\n+            if Present (Expressions (Inputs)) then\n+               Input := First (Expressions (Inputs));\n+               while Present (Input) loop\n+                  Analyze_Input_Item (Input);\n+\n+                  Next (Input);\n+               end loop;\n+            end if;\n+\n+            if Present (Component_Associations (Inputs)) then\n+               Error_Msg_N\n+                 (\"inputs must appear in named association form\", Inputs);\n+            end if;\n+\n+         --  Single input item\n+\n+         else\n+            Analyze_Input_Item (Inputs);\n+         end if;\n+      end Analyze_Initialization_Item_With_Inputs;\n+\n+      ----------------------------------\n+      -- Collect_States_And_Variables --\n+      ----------------------------------\n+\n+      procedure Collect_States_And_Variables is\n+         Decl : Node_Id;\n+\n+      begin\n+         --  Collect the abstract states defined in the package (if any)\n+\n+         if Present (Abstract_States (Pack_Id)) then\n+            States_And_Vars := New_Copy_Elist (Abstract_States (Pack_Id));\n+         end if;\n+\n+         --  Collect all variables the appear in the visible declarations of\n+         --  the related package.\n+\n+         if Present (Visible_Declarations (Pack_Spec)) then\n+            Decl := First (Visible_Declarations (Pack_Spec));\n+            while Present (Decl) loop\n+               if Nkind (Decl) = N_Object_Declaration\n+                 and then Ekind (Defining_Entity (Decl)) = E_Variable\n+                 and then Comes_From_Source (Decl)\n+               then\n+                  Add_Item (Defining_Entity (Decl), States_And_Vars);\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+         end if;\n+      end Collect_States_And_Variables;\n+\n+      --  Local variables\n+\n+      Inits : constant Node_Id :=\n+                Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n+      Init  : Node_Id;\n+\n+   --  Start of processing for Analyze_Initializes_In_Decl_Part\n+\n+   begin\n+      Set_Analyzed (N);\n+\n+      --  Initialize the various lists used during analysis\n+\n+      Collect_States_And_Variables;\n+\n+      --  Multiple initialization clauses appear as an aggregate\n+\n+      if Nkind (Inits) = N_Aggregate then\n+         if Present (Expressions (Inits)) then\n+            Init := First (Expressions (Inits));\n+            while Present (Init) loop\n+               Analyze_Initialization_Item (Init);\n+\n+               Next (Init);\n+            end loop;\n+         end if;\n+\n+         if Present (Component_Associations (Inits)) then\n+            Init := First (Component_Associations (Inits));\n+            while Present (Init) loop\n+               Analyze_Initialization_Item_With_Inputs (Init);\n+\n+               Next (Init);\n+            end loop;\n+         end if;\n+\n+      --  Various forms of a single initialization clause. Note that these may\n+      --  include malformed initializations.\n+\n+      else\n+         Analyze_Initialization_Item (Inits);\n+      end if;\n+   end Analyze_Initializes_In_Decl_Part;\n+\n    --------------------\n    -- Analyze_Pragma --\n    --------------------\n@@ -1887,16 +2218,11 @@ package body Sem_Prag is\n       --  UU_Typ is the related Unchecked_Union type. Flag In_Variant_Part\n       --  should be set when Comp comes from a record variant.\n \n-      procedure Check_Test_Case;\n-      --  Called to process a test-case pragma. It starts with checking pragma\n-      --  arguments, and the rest of the treatment is similar to the one for\n-      --  pre- and postcondition in Check_Precondition_Postcondition, except\n-      --  the placement rules for the test-case pragma are stricter. These\n-      --  pragmas may only occur after a subprogram spec declared directly\n-      --  in a package spec unit. In this case, the pragma is chained to the\n-      --  subprogram in question (using Contract_Test_Cases and Next_Pragma)\n-      --  and analysis of the pragma is delayed till the end of the spec. In\n-      --  all other cases, an error message for bad placement is given.\n+      procedure Check_Declaration_Order (States : Node_Id; Inits : Node_Id);\n+      --  Subsidiary routine to the analysis of pragmas Abstract_State and\n+      --  Initializes. Determine whether aspect/pragma Abstract_State denoted\n+      --  by States is defined earlier than aspect/pragma Initializes denoted\n+      --  by Inits.\n \n       procedure Check_Duplicate_Pragma (E : Entity_Id);\n       --  Check if a rep item of the same name as the current pragma is already\n@@ -2013,6 +2339,17 @@ package body Sem_Prag is\n       --  that the constraint is static as required by the restrictions for\n       --  Unchecked_Union.\n \n+      procedure Check_Test_Case;\n+      --  Called to process a test-case pragma. It starts with checking pragma\n+      --  arguments, and the rest of the treatment is similar to the one for\n+      --  pre- and postcondition in Check_Precondition_Postcondition, except\n+      --  the placement rules for the test-case pragma are stricter. These\n+      --  pragmas may only occur after a subprogram spec declared directly\n+      --  in a package spec unit. In this case, the pragma is chained to the\n+      --  subprogram in question (using Contract_Test_Cases and Next_Pragma)\n+      --  and analysis of the pragma is delayed till the end of the spec. In\n+      --  all other cases, an error message for bad placement is given.\n+\n       procedure Check_Valid_Configuration_Pragma;\n       --  Legality checks for placement of a configuration pragma\n \n@@ -2907,6 +3244,109 @@ package body Sem_Prag is\n          end if;\n       end Check_Component;\n \n+      -----------------------------\n+      -- Check_Declaration_Order --\n+      -----------------------------\n+\n+      procedure Check_Declaration_Order (States : Node_Id; Inits : Node_Id) is\n+         procedure Check_Aspect_Specification_Order;\n+         --  Inspect the aspect specifications of the context to determine the\n+         --  proper order.\n+\n+         --------------------------------------\n+         -- Check_Aspect_Specification_Order --\n+         --------------------------------------\n+\n+         procedure Check_Aspect_Specification_Order is\n+            Asp_I : constant Node_Id := Corresponding_Aspect (Inits);\n+            Asp_S : constant Node_Id := Corresponding_Aspect (States);\n+            Asp   : Node_Id;\n+\n+            States_Seen : Boolean := False;\n+\n+         begin\n+            --  Both aspects must be part of the same aspect specification list\n+\n+            pragma Assert (List_Containing (Asp_I) = List_Containing (Asp_S));\n+\n+            Asp := First (List_Containing (Asp_I));\n+            while Present (Asp) loop\n+               if Get_Aspect_Id (Asp) = Aspect_Abstract_State then\n+                  States_Seen := True;\n+\n+               elsif Get_Aspect_Id (Asp) = Aspect_Initializes then\n+                  if not States_Seen then\n+                     Error_Msg_N\n+                       (\"aspect % must come before aspect %\", States);\n+                  end if;\n+\n+                  exit;\n+               end if;\n+\n+               Next (Asp);\n+            end loop;\n+         end Check_Aspect_Specification_Order;\n+\n+         --  Local variables\n+\n+         Stmt : Node_Id;\n+\n+      --  Start of processing for Check_Declaration_Order\n+\n+      begin\n+         --  Cannot check the order if one of the pragmas is missing\n+\n+         if No (States) or else No (Inits) then\n+            return;\n+         end if;\n+\n+         --  Set up the error names in case the order is incorrect\n+\n+         Error_Msg_Name_1 := Name_Abstract_State;\n+         Error_Msg_Name_2 := Name_Initializes;\n+\n+         if From_Aspect_Specification (States) then\n+\n+            --  Both pragmas are actually aspects, check their declaration\n+            --  order in the associated aspect specification list. Otherwise\n+            --  States is an aspect and Inits a source pragma.\n+\n+            if From_Aspect_Specification (Inits) then\n+               Check_Aspect_Specification_Order;\n+            end if;\n+\n+         --  Abstract_States is a source pragma\n+\n+         else\n+            if From_Aspect_Specification (Inits) then\n+               Error_Msg_N (\"pragma % cannot come after aspect %\", States);\n+\n+            --  Both pragmas are source constructs. Try to reach States from\n+            --  Inits by traversing the declarations backwards.\n+\n+            else\n+               Stmt := Prev (Inits);\n+               while Present (Stmt) loop\n+\n+                  --  The order is ok, Abstract_States is first followed by\n+                  --  Initializes.\n+\n+                  if Nkind (Stmt) = N_Pragma\n+                    and then Pragma_Name (Stmt) = Name_Abstract_State\n+                  then\n+                     return;\n+                  end if;\n+\n+                  Prev (Stmt);\n+               end loop;\n+\n+               --  If we get here, then the pragmas are out of order\n+\n+               Error_Msg_N (\"pragma % cannot come after pragma %\", States);\n+            end if;\n+         end if;\n+      end Check_Declaration_Order;\n+\n       ----------------------------\n       -- Check_Duplicate_Pragma --\n       ----------------------------\n@@ -8655,7 +9095,16 @@ package body Sem_Prag is\n             end if;\n \n             Pack_Id := Defining_Entity (Context);\n-            State   := Expression (Arg1);\n+            Add_Contract_Item (N, Pack_Id);\n+\n+            --  Verify the declaration order of aspects/pragmas Abstract_State\n+            --  and Initializes.\n+\n+            Check_Declaration_Order\n+              (States => N,\n+               Inits  => Get_Pragma (Pack_Id, Pragma_Initializes));\n+\n+            State := Expression (Arg1);\n \n             --  Multiple abstract states appear as an aggregate\n \n@@ -12744,6 +13193,91 @@ package body Sem_Prag is\n                Initialize_Scalars := True;\n             end if;\n \n+         -----------------\n+         -- Initializes --\n+         -----------------\n+\n+         --  pragma Initializes (INITIALIZATION_SPEC);\n+\n+         --  INITIALIZATION_SPEC ::= null | INITIALIZATION_LIST\n+\n+         --  INITIALIZATION_LIST ::=\n+         --    INITIALIZATION_ITEM\n+         --    | (INITIALIZATION_ITEM {, INITIALIZATION_ITEM})\n+\n+         --  INITIALIZATION_ITEM ::= name [=> INPUT_LIST]\n+\n+         --  INPUT_LIST ::=\n+         --    null\n+         --    | INPUT\n+         --    | (INPUT {, INPUT})\n+\n+         --  INPUT ::= name\n+\n+         when Pragma_Initializes => Initializes : declare\n+            Context : constant Node_Id := Parent (Parent (N));\n+            Pack_Id : Entity_Id;\n+            Stmt    : Node_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            S14_Pragma;\n+            Check_Arg_Count (1);\n+\n+            --  Ensure the proper placement of the pragma. Initializes must be\n+            --  associated with a package declaration.\n+\n+            if not Nkind_In (Context, N_Generic_Package_Declaration,\n+                                      N_Package_Declaration)\n+            then\n+               Pragma_Misplaced;\n+               return;\n+            end if;\n+\n+            Stmt := Prev (N);\n+            while Present (Stmt) loop\n+\n+               --  Skip prior pragmas, but check for duplicates\n+\n+               if Nkind (Stmt) = N_Pragma then\n+                  if Pragma_Name (Stmt) = Pname then\n+                     Error_Msg_Name_1 := Pname;\n+                     Error_Msg_Sloc   := Sloc (Stmt);\n+                     Error_Msg_N (\"pragma % duplicates pragma declared #\", N);\n+                  end if;\n+\n+               --  Skip internally generated code\n+\n+               elsif not Comes_From_Source (Stmt) then\n+                  null;\n+\n+                  --  The pragma does not apply to a legal construct, issue an\n+                  --  error and stop the analysis.\n+\n+               else\n+                  Pragma_Misplaced;\n+                  return;\n+               end if;\n+\n+               Stmt := Prev (Stmt);\n+            end loop;\n+\n+            --  The pragma must be analyzed at the end of the visible\n+            --  declarations of the related package. Save the pragma for later\n+            --  (see Analyze_Initializes_In_Decl_Part) by adding it to the\n+            --  contract of the package.\n+\n+            Pack_Id := Defining_Entity (Context);\n+            Add_Contract_Item (N, Pack_Id);\n+\n+            --  Verify the declaration order of aspects/pragmas Abstract_State\n+            --  and Initializes.\n+\n+            Check_Declaration_Order\n+              (States => Get_Pragma (Pack_Id, Pragma_Abstract_State),\n+               Inits  => N);\n+         end Initializes;\n+\n          ------------\n          -- Inline --\n          ------------\n@@ -16177,6 +16711,7 @@ package body Sem_Prag is\n          when Pragma_Refined_State => Refined_State : declare\n             Context : constant Node_Id := Parent (N);\n             Spec_Id : Entity_Id;\n+            Stmt    : Node_Id;\n \n          begin\n             GNAT_Pragma;\n@@ -16191,6 +16726,34 @@ package body Sem_Prag is\n                return;\n             end if;\n \n+            Stmt := Prev (N);\n+            while Present (Stmt) loop\n+\n+               --  Skip prior pragmas, but check for duplicates\n+\n+               if Nkind (Stmt) = N_Pragma then\n+                  if Pragma_Name (Stmt) = Pname then\n+                     Error_Msg_Name_1 := Pname;\n+                     Error_Msg_Sloc   := Sloc (Stmt);\n+                     Error_Msg_N (\"pragma % duplicates pragma declared #\", N);\n+                  end if;\n+\n+               --  Skip internally generated code\n+\n+               elsif not Comes_From_Source (Stmt) then\n+                  null;\n+\n+                  --  The pragma does not apply to a legal construct, issue an\n+                  --  error and stop the analysis.\n+\n+               else\n+                  Pragma_Misplaced;\n+                  return;\n+               end if;\n+\n+               Stmt := Prev (Stmt);\n+            end loop;\n+\n             --  State refinement is allowed only when the corresponding package\n             --  declaration has a non-null aspect/pragma Abstract_State.\n \n@@ -16207,9 +16770,10 @@ package body Sem_Prag is\n \n             --  The pragma must be analyzed at the end of the declarations as\n             --  it has visibility over the whole declarative region. Save the\n-            --  pragma for later (see Analyze_Refined_Depends_In_Decl_Part).\n+            --  pragma for later (see Analyze_Refined_Depends_In_Decl_Part) by\n+            --  adding it to the contract of the package body.\n \n-            Set_Refined_State_Pragma (Defining_Entity (Context), N);\n+            Add_Contract_Item (N, Defining_Entity (Context));\n          end Refined_State;\n \n          -----------------------\n@@ -19647,9 +20211,9 @@ package body Sem_Prag is\n       procedure Analyze_Refinement_Clause (Clause : Node_Id);\n       --  Perform full analysis of a single refinement clause\n \n-      function Collect_Hidden_States return Elist_Id;\n+      procedure Collect_Hidden_States;\n       --  Gather the entities of all hidden states that appear in the spec and\n-      --  body of the related package.\n+      --  body of the related package in Hidden_States.\n \n       procedure Report_Unrefined_States;\n       --  Emit errors for all abstract states that have not been refined by\n@@ -19938,9 +20502,7 @@ package body Sem_Prag is\n       -- Collect_Hidden_States --\n       ---------------------------\n \n-      function Collect_Hidden_States return Elist_Id is\n-         Result : Elist_Id := No_Elist;\n-\n+      procedure Collect_Hidden_States is\n          procedure Collect_Hidden_States_In_Decls (Decls : List_Id);\n          --  Find all hidden states that appear in declarative list Decls and\n          --  append their entities to Result.\n@@ -19963,7 +20525,7 @@ package body Sem_Prag is\n             begin\n                State_Elmt := First_Elmt (States);\n                while Present (State_Elmt) loop\n-                  Add_Item (Node (State_Elmt), Result);\n+                  Add_Item (Node (State_Elmt), Hidden_States);\n \n                   Next_Elmt (State_Elmt);\n                end loop;\n@@ -19985,7 +20547,7 @@ package body Sem_Prag is\n                  and then Ekind (Defining_Entity (Decl)) = E_Variable\n                  and then Comes_From_Source (Decl)\n                then\n-                  Add_Item (Defining_Entity (Decl), Result);\n+                  Add_Item (Defining_Entity (Decl), Hidden_States);\n \n                --  Gather the abstract states of a package along with all\n                --  hidden states in its visible declarations.\n@@ -20014,8 +20576,6 @@ package body Sem_Prag is\n \n          Collect_Hidden_States_In_Decls (Private_Declarations (Pack_Spec));\n          Collect_Hidden_States_In_Decls (Declarations (Pack_Body));\n-\n-         return Result;\n       end Collect_Hidden_States;\n \n       -----------------------------\n@@ -20080,7 +20640,7 @@ package body Sem_Prag is\n       --  Local declarations\n \n       Clauses : constant Node_Id :=\n-                  Expression (First (Pragma_Argument_Associations (N)));\n+                  Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n       Clause  : Node_Id;\n \n    --  Start of processing for Analyze_Refined_State_In_Decl_Part\n@@ -20090,8 +20650,8 @@ package body Sem_Prag is\n \n       --  Initialize the various lists used during analysis\n \n-      Abstr_States  := New_Copy_Elist (Abstract_States (Spec_Id));\n-      Hidden_States := Collect_Hidden_States;\n+      Abstr_States := New_Copy_Elist (Abstract_States (Spec_Id));\n+      Collect_Hidden_States;\n \n       --  Multiple state refinements appear as an aggregate\n \n@@ -20814,6 +21374,7 @@ package body Sem_Prag is\n       Pragma_Independent                    =>  0,\n       Pragma_Independent_Components         =>  0,\n       Pragma_Initialize_Scalars             => -1,\n+      Pragma_Initializes                    => -1,\n       Pragma_Inline                         =>  0,\n       Pragma_Inline_Always                  =>  0,\n       Pragma_Inline_Generic                 =>  0,"}, {"sha": "cef28caf8031f7cf2cee59e5f574095fb607e3fd", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -62,6 +62,9 @@ package Sem_Prag is\n    procedure Analyze_Global_In_Decl_Part (N : Node_Id);\n    --  Perform full analysis of delayed pragma Global\n \n+   procedure Analyze_Initializes_In_Decl_Part (N : Node_Id);\n+   --  Perform full analysis of delayed pragma Initializes\n+\n    procedure Analyze_Pre_Post_Condition_In_Decl_Part\n      (Prag    : Node_Id;\n       Subp_Id : Entity_Id);"}, {"sha": "a5a6f7b35faf0f58b1554ce4fc18f45e3154f2d9", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 56, "deletions": 11, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -212,24 +212,27 @@ package body Sem_Util is\n    -- Add_Contract_Item --\n    -----------------------\n \n-   procedure Add_Contract_Item (Prag : Node_Id; Subp_Id : Entity_Id) is\n-      Items : constant Node_Id := Contract (Subp_Id);\n+   procedure Add_Contract_Item (Prag : Node_Id; Id : Entity_Id) is\n+      Items : constant Node_Id := Contract (Id);\n       Nam   : Name_Id;\n       N     : Node_Id;\n \n    begin\n-      --  The related subprogram [body] must have a contract and the item to be\n-      --  added must be a pragma.\n+      --  The related context must have a contract and the item to be added\n+      --  must be a pragma.\n \n       pragma Assert (Present (Items));\n       pragma Assert (Nkind (Prag) = N_Pragma);\n \n       Nam := Original_Aspect_Name (Prag);\n \n-      --  Contract items related to subprogram bodies\n+      --  Contract items related to [generic] packages. The applicable pragmas\n+      --  are:\n+      --    Abstract_States\n+      --    Initializes\n \n-      if Ekind (Subp_Id) = E_Subprogram_Body then\n-         if Nam_In (Nam, Name_Refined_Depends, Name_Refined_Global) then\n+      if Ekind_In (Id, E_Generic_Package, E_Package) then\n+         if Nam_In (Nam, Name_Abstract_State, Name_Initializes) then\n             Set_Next_Pragma (Prag, Classifications (Items));\n             Set_Classifications (Items, Prag);\n \n@@ -239,9 +242,35 @@ package body Sem_Util is\n             raise Program_Error;\n          end if;\n \n-      --  Contract items related to subprogram declarations\n+      --  Contract items related to package bodies. The applicable pragmas are:\n+      --    Refined_States\n \n-      else\n+      elsif Ekind (Id) = E_Package_Body then\n+         if Nam = Name_Refined_State then\n+            Set_Next_Pragma (Prag, Classifications (Items));\n+            Set_Classifications (Items, Prag);\n+\n+         --  The pragma is not a proper contract item\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+\n+      --  Contract items related to subprogram or entry declarations. The\n+      --  applicable pragmas are:\n+      --    Contract_Cases\n+      --    Depends\n+      --    Global\n+      --    Post\n+      --    Postcondition\n+      --    Pre\n+      --    Precondition\n+      --    Test_Case\n+\n+      elsif Ekind_In (Id, E_Entry, E_Entry_Family)\n+        or else Is_Generic_Subprogram (Id)\n+        or else Is_Subprogram (Id)\n+      then\n          if Nam_In (Nam, Name_Precondition,\n                          Name_Postcondition,\n                          Name_Pre,\n@@ -251,7 +280,7 @@ package body Sem_Util is\n          then\n             --  Before we add a precondition or postcondition to the list,\n             --  make sure we do not have a disallowed duplicate, which can\n-            --  happen if we use a pragma for Pre{_Class] or Post[_Class]\n+            --  happen if we use a pragma for Pre[_Class] or Post[_Class]\n             --  instead of the corresponding aspect.\n \n             if not From_Aspect_Specification (Prag)\n@@ -269,7 +298,7 @@ package body Sem_Util is\n                   then\n                      Error_Msg_Sloc := Sloc (N);\n                      Error_Msg_NE\n-                       (\"duplication of aspect for & given#\", Prag, Subp_Id);\n+                       (\"duplication of aspect for & given#\", Prag, Id);\n                      return;\n                   else\n                      N := Next_Pragma (N);\n@@ -290,6 +319,22 @@ package body Sem_Util is\n \n          --  The pragma is not a proper contract item\n \n+         else\n+            raise Program_Error;\n+         end if;\n+\n+      --  Contract items related to subprogram bodies. The applicable pragmas\n+      --  are:\n+      --    Refined_Depends\n+      --    Refined_Global\n+\n+      elsif Ekind (Id) = E_Subprogram_Body then\n+         if Nam_In (Nam, Name_Refined_Depends, Name_Refined_Global) then\n+            Set_Next_Pragma (Prag, Classifications (Items));\n+            Set_Classifications (Items, Prag);\n+\n+         --  The pragma is not a proper contract item\n+\n          else\n             raise Program_Error;\n          end if;"}, {"sha": "d19ba57710c927c30f304d01cbb61864d07a0da2", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -43,16 +43,19 @@ package Sem_Util is\n    --  Add A to the list of access types to process when expanding the\n    --  freeze node of E.\n \n-   procedure Add_Contract_Item (Prag : Node_Id; Subp_Id : Entity_Id);\n-   --  Add one of the following contract item to the contract of a subprogram.\n-   --  Prag denotes a pragma and Subp_Id is the related subprogram [body].\n+   procedure Add_Contract_Item (Prag : Node_Id; Id : Entity_Id);\n+   --  Add pragma Prag to the contract of an entry, a package [body] or a\n+   --  subprogram [body] denoted by Id. The following are valid pragmas:\n+   --    Abstract_States\n    --    Contract_Cases\n    --    Depends\n    --    Global\n+   --    Initializes\n    --    Postcondition\n    --    Precondition\n    --    Refined_Depends\n    --    Refined_Global\n+   --    Refined_States\n    --    Test_Case\n \n    procedure Add_Global_Declaration (N : Node_Id);"}, {"sha": "5abe92243879bd80fd3929ffa29c749486dfe378", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -7151,9 +7151,14 @@ package Sinfo is\n       -- Contract --\n       --------------\n \n-      --  This node is used to hold the various parts of an entry or subprogram\n-      --  [body] contract, consisting of precondition, postconditions, contract\n-      --  cases, test cases and global dependencies.\n+      --  This node is used to hold the various parts of an entry, subprogram\n+      --  [body] or package [body] contract, in particular:\n+      --     Abstract states declared by a package declaration\n+      --     Contract cases that apply to a subprogram\n+      --     Dependency relations of inputs and output of a subprogram\n+      --     Global annotations classifying data as input or output\n+      --     Initialization sequences for a package declaration\n+      --     Pre- and postconditions that apply to a subprogram\n \n       --  The node appears in an entry and [generic] subprogram [body] entity.\n \n@@ -7170,8 +7175,13 @@ package Sinfo is\n       --  Pre_Post_Conditions contains a collection of pragmas that correspond\n       --  to pre- and postconditions associated with an entry or a subprogram\n       --  [body or stub]. The pragmas can either come from source or be the\n-      --  byproduct of aspect expansion. The ordering in the list is in LIFO\n-      --  fashion.\n+      --  byproduct of aspect expansion. Currently the following pragmas appear\n+      --  in this list:\n+      --    Post\n+      --    Postcondition\n+      --    Pre\n+      --    Precondition\n+      --  The ordering in the list is in LIFO fashion.\n \n       --  Note that there might be multiple preconditions or postconditions\n       --  in this list, either because they come from separate pragmas in the\n@@ -7182,10 +7192,17 @@ package Sinfo is\n       --  to aspects/pragmas Contract_Cases and Test_Case. The ordering in the\n       --  list is in LIFO fashion.\n \n-      --  Classifications contains pragmas that either categorize subprogram\n-      --  inputs and outputs or establish dependencies between them. Currently\n-      --  pragmas Depends, Global, Refined_Depends and Refined_Global are\n-      --  stored in this list. The ordering is in LIFO fashion.\n+      --  Classifications contains pragmas that either declare, categorize or\n+      --  establish dependencies between subprogram or package inputs and\n+      --  outputs. Currently the following pragmas appear in this list:\n+      --    Abstract_States\n+      --    Depends\n+      --    Global\n+      --    Initializes\n+      --    Refined_Depends\n+      --    Refined_Global\n+      --    Refined_States\n+      --  The ordering is in LIFO fashion.\n \n       -------------------\n       -- Expanded_Name --"}, {"sha": "0a5d9460e36510f3944bbb369fbedb248aefa398", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e28df21a7c44d4643353a1a3c9b042eabdfc20/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=54e28df21a7c44d4643353a1a3c9b042eabdfc20", "patch": "@@ -511,6 +511,7 @@ package Snames is\n    Name_Import_Valued_Procedure        : constant Name_Id := N + $; -- GNAT\n    Name_Independent                    : constant Name_Id := N + $; -- Ada 12\n    Name_Independent_Components         : constant Name_Id := N + $; -- Ada 12\n+   Name_Initializes                    : constant Name_Id := N + $; -- GNAT\n    Name_Inline                         : constant Name_Id := N + $;\n    Name_Inline_Always                  : constant Name_Id := N + $; -- GNAT\n    Name_Inline_Generic                 : constant Name_Id := N + $; -- GNAT\n@@ -587,9 +588,6 @@ package Snames is\n    Name_Refined_Global                 : constant Name_Id := N + $; -- GNAT\n    Name_Refined_Post                   : constant Name_Id := N + $; -- GNAT\n    Name_Refined_Pre                    : constant Name_Id := N + $; -- GNAT\n-\n-   --  Kirchev\n-\n    Name_Refined_State                  : constant Name_Id := N + $; -- GNAT\n    Name_Relative_Deadline              : constant Name_Id := N + $; -- Ada 05\n    Name_Remote_Access_Type             : constant Name_Id := N + $; -- GNAT\n@@ -1831,6 +1829,7 @@ package Snames is\n       Pragma_Import_Valued_Procedure,\n       Pragma_Independent,\n       Pragma_Independent_Components,\n+      Pragma_Initializes,\n       Pragma_Inline,\n       Pragma_Inline_Always,\n       Pragma_Inline_Generic,"}]}