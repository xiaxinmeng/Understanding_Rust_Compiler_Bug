{"sha": "3633cc54284450433b81f0340483e15df1a49a3c", "node_id": "C_kwDOANBUbNoAKDM2MzNjYzU0Mjg0NDUwNDMzYjgxZjAzNDA0ODNlMTVkZjFhNDlhM2M", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-01-05T14:25:37Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-01-05T14:43:01Z"}, "message": "libstdc++: Implement P1328 \"Making std::type_info::operator== constexpr\"\n\nThis feature is present in the C++23 draft.\n\nWith Jakub's recent front-end changes we can implement constexpr\nequality by comparing the addresses of std::type_info objects. We do not\nneed string comparisons, because for constant evaluation cases we know\nwe aren't dealing with std::type_info objects defined in other\ntranslation units.\n\nThe ARM EABI requires that the type_info::operator== function can be\ndefined out-of-line (and suggests that should be the default), but to be\na constexpr function it must be defined inline (at least for C++23\nmode). To meet these conflicting requirements we make the inline version\nof operator== call a new __equal function when called at runtime. That\nis an alias for the non-inline definition of operator== defined in\nlibsupc++.\n\nlibstdc++-v3/ChangeLog:\n\n\t* config/abi/pre/gnu.ver (GLIBCXX_3.4.30): Export new symbol for\n\tARM EABI.\n\t* include/bits/c++config (_GLIBCXX23_CONSTEXPR): Define.\n\t* include/std/version (__cpp_lib_constexpr_typeinfo): Define.\n\t* libsupc++/tinfo.cc: Add #error to ensure non-inline definition\n\tis emitted.\n\t(type_info::__equal): Define alias symbol.\n\t* libsupc++/typeinfo (type_info::before): Combine different\n\timplementations into one.\n\t(type_info::operator==): Likewise. Use address equality for\n\tconstant evaluation. Call __equal for targets that require the\n\tdefinition to be non-inline.\n\t* testsuite/18_support/type_info/constexpr.cc: New test.", "tree": {"sha": "8999cf5da81331352168bc23b5c930a1e90822d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8999cf5da81331352168bc23b5c930a1e90822d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3633cc54284450433b81f0340483e15df1a49a3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3633cc54284450433b81f0340483e15df1a49a3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3633cc54284450433b81f0340483e15df1a49a3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3633cc54284450433b81f0340483e15df1a49a3c/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "096228d84e9238d97fe115623126373f5b67bdc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/096228d84e9238d97fe115623126373f5b67bdc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/096228d84e9238d97fe115623126373f5b67bdc1"}], "stats": {"total": 165, "additions": 131, "deletions": 34}, "files": [{"sha": "afd242b32aaf7bc72aa8cb4acf662a2418bbecf4", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3633cc54284450433b81f0340483e15df1a49a3c/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3633cc54284450433b81f0340483e15df1a49a3c/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=3633cc54284450433b81f0340483e15df1a49a3c", "patch": "@@ -2424,6 +2424,9 @@ GLIBCXX_3.4.30 {\n     # std::__timepunct<char>::_M_am_pm_format(const char**)\n     _ZNKSt11__timepunctI[cw]E15_M_am_pm_formatEPPK[cw];\n \n+    # Only defined #if ! __GXX_TYPEINFO_EQUALITY_INLINE\n+    _ZNKSt9type_info7__equalERKS_;\n+\n } GLIBCXX_3.4.29;\n \n # Symbols in the support library (libsupc++) have their own tag."}, {"sha": "c64b61b3c90ace32d92f8d649a5670585c1e630f", "filename": "libstdc++-v3/include/bits/c++config", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3633cc54284450433b81f0340483e15df1a49a3c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3633cc54284450433b81f0340483e15df1a49a3c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=3633cc54284450433b81f0340483e15df1a49a3c", "patch": "@@ -175,13 +175,21 @@\n #endif\n \n #ifndef _GLIBCXX20_CONSTEXPR\n-# if __cplusplus > 201703L\n+# if __cplusplus >= 202002L\n #  define _GLIBCXX20_CONSTEXPR constexpr\n # else\n #  define _GLIBCXX20_CONSTEXPR\n # endif\n #endif\n \n+#ifndef _GLIBCXX23_CONSTEXPR\n+# if __cplusplus >= 202100L\n+#  define _GLIBCXX23_CONSTEXPR constexpr\n+# else\n+#  define _GLIBCXX23_CONSTEXPR\n+# endif\n+#endif\n+\n #ifndef _GLIBCXX17_INLINE\n # if __cplusplus >= 201703L\n #  define _GLIBCXX17_INLINE inline"}, {"sha": "f421056964e2d6219f9ecab0a84cde41ddb5c771", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3633cc54284450433b81f0340483e15df1a49a3c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3633cc54284450433b81f0340483e15df1a49a3c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=3633cc54284450433b81f0340483e15df1a49a3c", "patch": "@@ -295,6 +295,7 @@\n // c++2b\n #define __cpp_lib_adaptor_iterator_pair_constructor 202106L\n #define __cpp_lib_byteswap 202110L\n+#define __cpp_lib_constexpr_typeinfo 202106L\n #define __cpp_lib_invoke_r 202106L\n #define __cpp_lib_ios_noreplace 202200L\n #define __cpp_lib_is_scoped_enum 202011L"}, {"sha": "ef13dd3306400128bb881f8b76e898ff8ba5f4b3", "filename": "libstdc++-v3/libsupc++/tinfo.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3633cc54284450433b81f0340483e15df1a49a3c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3633cc54284450433b81f0340483e15df1a49a3c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.cc?ref=3633cc54284450433b81f0340483e15df1a49a3c", "patch": "@@ -32,6 +32,10 @@ std::type_info::\n \n #if !__GXX_TYPEINFO_EQUALITY_INLINE\n \n+#if __cplusplus > 202002L\n+# error \"this file must be compiled with C++20 or older to define operator==\"\n+#endif\n+\n // We can't rely on common symbols being shared between shared objects.\n bool std::type_info::\n operator== (const std::type_info& arg) const _GLIBCXX_NOEXCEPT\n@@ -47,6 +51,9 @@ operator== (const std::type_info& arg) const _GLIBCXX_NOEXCEPT\n #endif\n }\n \n+bool\n+std::type_info::__equal (const std::type_info& arg) const _GLIBCXX_NOEXCEPT\n+__attribute__((alias(\"_ZNKSt9type_infoeqERKS_\")));\n #endif\n \n namespace std {"}, {"sha": "3018a510fd5f8634ec5e7fc98958e0eb232a9183", "filename": "libstdc++-v3/libsupc++/typeinfo", "status": "modified", "additions": 63, "deletions": 33, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3633cc54284450433b81f0340483e15df1a49a3c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftypeinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3633cc54284450433b81f0340483e15df1a49a3c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftypeinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftypeinfo?ref=3633cc54284450433b81f0340483e15df1a49a3c", "patch": "@@ -38,6 +38,10 @@\n \n #pragma GCC visibility push(default)\n \n+#if __cplusplus >= 202100L\n+# define __cpp_lib_constexpr_typeinfo 202106L\n+#endif\n+\n extern \"C++\" {\n \n namespace __cxxabiv1\n@@ -99,40 +103,12 @@ namespace std\n     const char* name() const _GLIBCXX_NOEXCEPT\n     { return __name[0] == '*' ? __name + 1 : __name; }\n \n-#if !__GXX_TYPEINFO_EQUALITY_INLINE\n-    // In old abi, or when weak symbols are not supported, there can\n-    // be multiple instances of a type_info object for one\n-    // type. Uniqueness must use the _name value, not object address.\n-    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT;\n-    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT;\n-#else\n-  #if !__GXX_MERGED_TYPEINFO_NAMES\n-    /** Returns true if @c *this precedes @c __arg in the implementation's\n+    /** Returns true if `*this` precedes `__arg` in the implementation's\n      *  collation order.  */\n-    // Even with the new abi, on systems that support dlopen\n-    // we can run into cases where type_info names aren't merged,\n-    // so we still need to do string comparison.\n-    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n-    { return (__name[0] == '*' && __arg.__name[0] == '*')\n-\t? __name < __arg.__name\n-\t: __builtin_strcmp (__name, __arg.__name) < 0; }\n-\n-    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n-    {\n-      return ((__name == __arg.__name)\n-\t      || (__name[0] != '*' &&\n-\t\t  __builtin_strcmp (__name, __arg.__name) == 0));\n-    }\n-  #else\n-    // On some targets we can rely on type_info's NTBS being unique,\n-    // and therefore address comparisons are sufficient.\n-    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n-    { return __name < __arg.__name; }\n+    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT;\n \n-    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n-    { return __name == __arg.__name; }\n-  #endif\n-#endif\n+    _GLIBCXX23_CONSTEXPR\n+    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT;\n \n #if __cpp_impl_three_way_comparison < 201907L\n     bool operator!=(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n@@ -176,11 +152,65 @@ namespace std\n     explicit type_info(const char *__n): __name(__n) { }\n \n   private:\n-    /// Assigning type_info is not supported.\n+    // type_info objects cannot be copied.\n+#if __cplusplus >= 201103L\n+    type_info& operator=(const type_info&) = delete;\n+    type_info(const type_info&) = delete;\n+#else\n     type_info& operator=(const type_info&);\n     type_info(const type_info&);\n+#endif\n+\n+#if ! __GXX_TYPEINFO_EQUALITY_INLINE\n+    bool __equal(const type_info&) const _GLIBCXX_NOEXCEPT;\n+#endif\n   };\n \n+#if __GXX_TYPEINFO_EQUALITY_INLINE\n+  inline bool\n+  type_info::before(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n+  {\n+#if !__GXX_MERGED_TYPEINFO_NAMES\n+    // Even with the new abi, on systems that support dlopen\n+    // we can run into cases where type_info names aren't merged,\n+    // so we still need to do string comparison.\n+    if (__name[0] != '*' || __arg.__name[0] != '*')\n+      return __builtin_strcmp (__name, __arg.__name) < 0;\n+#else\n+    // On some targets we can rely on type_info's NTBS being unique,\n+    // and therefore address comparisons are sufficient.\n+#endif\n+\n+    // In old abi, or when weak symbols are not supported, there can\n+    // be multiple instances of a type_info object for one\n+    // type. Uniqueness must use the __name value, not object address.\n+    return __name < __arg.__name;\n+  }\n+#endif\n+\n+#if __GXX_TYPEINFO_EQUALITY_INLINE || __cplusplus > 202002L\n+  _GLIBCXX23_CONSTEXPR inline bool\n+  type_info::operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n+  {\n+    if (std::__is_constant_evaluated())\n+      return this == &__arg;\n+\n+    if (__name == __arg.__name)\n+      return true;\n+\n+#if !__GXX_TYPEINFO_EQUALITY_INLINE\n+    // ABI requires comparisons to be non-inline.\n+    return __equal(__arg);\n+#elif !__GXX_MERGED_TYPEINFO_NAMES\n+    // Need to do string comparison.\n+    return __name[0] != '*' && __builtin_strcmp (__name, __arg.name()) == 0;\n+#else\n+    return false;\n+#endif\n+  }\n+# endif\n+\n+\n   /**\n    *  @brief  Thrown during incorrect typecasting.\n    *  @ingroup exceptions"}, {"sha": "07f4fb651f4d5805e51e36017f9f88001810b9fb", "filename": "libstdc++-v3/testsuite/18_support/type_info/constexpr.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3633cc54284450433b81f0340483e15df1a49a3c/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Ftype_info%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3633cc54284450433b81f0340483e15df1a49a3c/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Ftype_info%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Ftype_info%2Fconstexpr.cc?ref=3633cc54284450433b81f0340483e15df1a49a3c", "patch": "@@ -0,0 +1,48 @@\n+// { dg-options \"-std=gnu++23 -frtti\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <typeinfo>\n+\n+#ifndef __cpp_lib_constexpr_typeinfo\n+# error \"Feature-test macro for constexpr typeinfo missing in <typeinfo>\"\n+#elif __cpp_lib_constexpr_typeinfo != 202106L\n+# error \"Feature-test macro for constexpr typeinfo has wrong value in <typeinfo>\"\n+#endif\n+\n+struct X { };\n+\n+constexpr bool\n+test01()\n+{\n+  if (typeid(int) == typeid(long))\n+    return false;\n+\n+  if (typeid(int) != typeid(int))\n+    return false;\n+\n+  struct X { virtual ~X() { } };\n+\n+  if (typeid(X) != typeid(X))\n+    return false;\n+\n+  if (typeid(X) == typeid(::X))\n+    return false;\n+\n+  if (typeid(X) == typeid(int))\n+    return false;\n+\n+  const auto& ti_x = typeid(X);\n+  if (ti_x != ti_x)\n+    return false;\n+\n+  if (ti_x != typeid(X))\n+    return false;\n+\n+  struct Y { };\n+  if (ti_x == typeid(Y))\n+    return false;\n+\n+  return true;\n+}\n+\n+static_assert( test01() );"}]}