{"sha": "162c7cd92dae4c0504dd653b948369a3f593ca32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYyYzdjZDkyZGFlNGMwNTA0ZGQ2NTNiOTQ4MzY5YTNmNTkzY2EzMg==", "commit": {"author": {"name": "Stephen M. Webb", "email": "stephen@bregmasoft.com", "date": "2002-11-26T00:53:12Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-11-26T00:53:12Z"}, "message": "testsuite_allocator.h: New file.\n\n\n2002-11-25  Stephen M. Webb  <stephen@bregmasoft.com>\n\n        * testsuite/testsuite_allocator.h: New file.\n        * testsuite/testsuite_allocator.cc: New file.\n        * testsuite/Makefile.am: Added testsuite_allocator to test library.\n        * testsuite/testsuite_hooks.h: Added more detailed tracker objects\n        gnu_copy_constructor, gnu_assignment_operator, and gnu_destructor.\n        * testsuite/testsuite_hooks.cc: Added new static objects definitions.\n        * testsuite/23_containers/vector_capacity.cc: Added reserve() tests.\n        * testsuite/23_containers/vector_ctor.cc: Added a plethora of tests.\n        * testsuite/23_containers/deque_ctor.cc: Added a slew of new tests.\n\nFrom-SVN: r59484", "tree": {"sha": "e4baea16bf1eec7ffd7ac2c84641d07feb071158", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4baea16bf1eec7ffd7ac2c84641d07feb071158"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/162c7cd92dae4c0504dd653b948369a3f593ca32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/162c7cd92dae4c0504dd653b948369a3f593ca32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/162c7cd92dae4c0504dd653b948369a3f593ca32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/162c7cd92dae4c0504dd653b948369a3f593ca32/comments", "author": null, "committer": null, "parents": [{"sha": "83bbd9b6c01f1a7a9c954783e58f760b1c2dca95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83bbd9b6c01f1a7a9c954783e58f760b1c2dca95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83bbd9b6c01f1a7a9c954783e58f760b1c2dca95"}], "stats": {"total": 4066, "additions": 2762, "deletions": 1304}, "files": [{"sha": "57c188c56f25dce41b8bee5d8d6d5e37891b0122", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=162c7cd92dae4c0504dd653b948369a3f593ca32", "patch": "@@ -1,3 +1,15 @@\n+2002-11-25  Stephen M. Webb  <stephen@bregmasoft.com>\n+\n+  \t* testsuite/testsuite_allocator.h: New file.\n+\t* testsuite/testsuite_allocator.cc: New file.\n+\t* testsuite/Makefile.am: Added testsuite_allocator to test library.\n+\t* testsuite/testsuite_hooks.h: Added more detailed tracker objects\n+\tgnu_copy_constructor, gnu_assignment_operator, and gnu_destructor.\n+\t* testsuite/testsuite_hooks.cc: Added new static objects definitions.\n+\t* testsuite/23_containers/vector_capacity.cc: Added reserve() tests.\n+\t* testsuite/23_containers/vector_ctor.cc: Added a plethora of tests.\n+\t* testsuite/23_containers/deque_ctor.cc: Added a slew of new tests.\n+\n 2002-11-25  Mark Mitchell  <mark@codesourcery.com>\n \n \t* libsupc++/Makefile.am (sources): Add guard.cc."}, {"sha": "e42653992d8ddb0bed3d087f056c418cd0da11c4", "filename": "libstdc++-v3/aclocal.m4", "status": "modified", "additions": 5, "deletions": 37, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Faclocal.m4?ref=162c7cd92dae4c0504dd653b948369a3f593ca32", "patch": "@@ -1,4 +1,4 @@\n-dnl aclocal.m4 generated automatically by aclocal 1.4-p6\n+dnl aclocal.m4 generated automatically by aclocal 1.4-p5\n \n dnl Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n dnl This file is free software; the Free Software Foundation\n@@ -2262,16 +2262,14 @@ AC_MSG_RESULT($enable_symvers)\n ])\n \n \n-# isc-posix.m4 serial 2 (gettext-0.11.2)\n+# isc-posix.m4 serial 1 (gettext-0.10.40)\n dnl Copyright (C) 1995-2002 Free Software Foundation, Inc.\n dnl This file is free software, distributed under the terms of the GNU\n dnl General Public License.  As a special exception to the GNU General\n dnl Public License, this file may be distributed as part of a program\n dnl that contains a configuration script generated by Autoconf, under\n dnl the same distribution terms as the rest of that program.\n \n-# This file is not needed with autoconf-2.53 and newer.  Remove it in 2005.\n-\n # This test replaces the one in autoconf.\n # Currently this macro should have the same name as the autoconf macro\n # because gettext's gettext.m4 (distributed in the automake package)\n@@ -2332,8 +2330,7 @@ dnl Usage:\n dnl AM_INIT_AUTOMAKE(package,version, [no-define])\n \n AC_DEFUN([AM_INIT_AUTOMAKE],\n-[AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n-AC_REQUIRE([AC_PROG_INSTALL])\n+[AC_REQUIRE([AC_PROG_INSTALL])\n PACKAGE=[$1]\n AC_SUBST(PACKAGE)\n VERSION=[$2]\n@@ -2349,42 +2346,13 @@ AC_REQUIRE([AM_SANITY_CHECK])\n AC_REQUIRE([AC_ARG_PROGRAM])\n dnl FIXME This is truly gross.\n missing_dir=`cd $ac_aux_dir && pwd`\n-AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version}, $missing_dir)\n+AM_MISSING_PROG(ACLOCAL, aclocal, $missing_dir)\n AM_MISSING_PROG(AUTOCONF, autoconf, $missing_dir)\n-AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version}, $missing_dir)\n+AM_MISSING_PROG(AUTOMAKE, automake, $missing_dir)\n AM_MISSING_PROG(AUTOHEADER, autoheader, $missing_dir)\n AM_MISSING_PROG(MAKEINFO, makeinfo, $missing_dir)\n AC_REQUIRE([AC_PROG_MAKE_SET])])\n \n-# Copyright 2002  Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-\n-# AM_AUTOMAKE_VERSION(VERSION)\n-# ----------------------------\n-# Automake X.Y traces this macro to ensure aclocal.m4 has been\n-# generated from the m4 files accompanying Automake X.Y.\n-AC_DEFUN([AM_AUTOMAKE_VERSION],[am__api_version=\"1.4\"])\n-\n-# AM_SET_CURRENT_AUTOMAKE_VERSION\n-# -------------------------------\n-# Call AM_AUTOMAKE_VERSION so it can be traced.\n-# This function is AC_REQUIREd by AC_INIT_AUTOMAKE.\n-AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-\t [AM_AUTOMAKE_VERSION([1.4-p6])])\n-\n #\n # Check to make sure that the build environment is sane.\n #"}, {"sha": "6ac56fdae35403205528b653e84e5cabd70c8890", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=162c7cd92dae4c0504dd653b948369a3f593ca32", "patch": "@@ -3,9 +3,6 @@\n /* Define if you have a working `mmap' system call.  */\n #undef HAVE_MMAP\n \n-/* Define if you need to in order for stat and other things to work.  */\n-#undef _POSIX_SOURCE\n-\n // Define if GCC supports weak symbols.\n #undef _GLIBCPP_SUPPORTS_WEAK\n "}, {"sha": "b0adf66f28095e35b1d2fa01f598179ff618b6e4", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 1286, "deletions": 1232, "changes": 2518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=162c7cd92dae4c0504dd653b948369a3f593ca32"}, {"sha": "7df103405ebd88ab3b6fcd98a173f04b4daf0891", "filename": "libstdc++-v3/testsuite/23_containers/deque_ctor.cc", "status": "modified", "additions": 488, "deletions": 3, "changes": 491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque_ctor.cc?ref=162c7cd92dae4c0504dd653b948369a3f593ca32", "patch": "@@ -1,6 +1,6 @@\n // 2001-12-27 pme\n //\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -21,12 +21,16 @@\n // 23.2.1.1 deque constructors, copy, and assignment\n \n #include <deque>\n+#include <iterator>\n+#include <sstream>\n+#include <testsuite_allocator.h>\n #include <testsuite_hooks.h>\n \n typedef std::deque<gnu_counting_struct>   gdeque;\n \n+bool test = true;\n \n-// basic alloc/dealloc sanity check\n+// see http://gcc.gnu.org/ml/libstdc++/2001-11/msg00139.html\n void\n test01()\n {\n@@ -38,9 +42,490 @@ test01()\n   assert_count (0);\n }\n \n+\n+// 23.2.1     required types\n+//\n+// A missing required type will cause a compile failure.\n+//\n+void\n+requiredTypesCheck()\n+{\n+  typedef int             T;\n+  typedef std::deque<T>   X;\n+\n+  typedef X::reference              reference;\n+  typedef X::const_reference        const_reference;\n+  typedef X::iterator               iterator;\n+  typedef X::const_iterator         const_iterator;\n+  typedef X::size_type              size_type;\n+  typedef X::difference_type        difference_type;\n+  typedef X::value_type             value_type;\n+  typedef X::allocator_type         allocator_type;\n+  typedef X::pointer                pointer;\n+  typedef X::const_pointer          const_pointer;\n+  typedef X::reverse_iterator       reverse_iterator;\n+  typedef X::const_reverse_iterator const_reverse_iterator;\n+}\n+\n+\n+// @fn defaultConstructorCheck\n+// Explicitly checks the default deque constructor and destructor for both\n+// trivial and non-trivial types.  In addition, the size() and empty()\n+// member functions are explicitly checked here since it should be their\n+// first use. Checking those functions means checking the begin() and\n+// end() and their const brethren functions as well.\n+//\n+// @verbatim\n+// 23.2.1.1   default ctor/dtor\n+//  effects:\n+//    23.2.1.1        constructs an empty deque using the specified allocator\n+//  postconditions:\n+//    23.1 table 65   u.size() == 0\n+//  throws:\n+//  complexity:\n+//    23.1 table 65   constant\n+//\n+// 23.2.1.2   bool empty() const\n+//  semantics:\n+//    23.1 table 65   a.size() == 0\n+//    23.1 (7)        a.begin() == a.end()\n+//  throws:\n+//  complexity:\n+//    23.1 table 65   constant\n+//\n+// 23.2.1.2   size_type size() const\n+//  semantics:\n+//    23.1 table 65   a.end() - a.begin()\n+//  throws:\n+//  complexity:\n+//    23.1 table 65(A) should be constant\n+//\n+// 23.2.1     iterator begin()\n+//            const_iterator begin() const\n+//            iterator end() \n+//            const_iterator end() const\n+//  throws:\n+//    23.1 (10) pt. 4 does not throw\n+//  complexity:\n+//    23.1 table 65   constant\n+// @endverbatim\n+void\n+defaultConstructorCheckPOD()\n+{\n+  // setup\n+  typedef int             T;\n+  typedef std::deque<T>   X;\n+\n+  // run test\n+  X u;\n+\n+  // assert postconditions\n+  VERIFY(u.empty());\n+  VERIFY(0 == u.size());\n+  VERIFY(u.begin() == u.end());\n+  VERIFY(0 == std::distance(u.begin(), u.end()));\n+\n+  // teardown\n+}\n+\n+\n+void\n+defaultConstructorCheck()\n+{\n+  // setup\n+  typedef gnu_copy_tracker  T;\n+  typedef std::deque<T>     X;\n+\n+  gnu_copy_tracker::reset();\n+\n+  // run test\n+  const X u;\n+\n+  // assert postconditions\n+  VERIFY(u.empty());\n+  VERIFY(0 == u.size());\n+  VERIFY(u.begin() == u.end());\n+  VERIFY(0 == std::distance(u.begin(), u.end()));\n+\n+  // teardown\n+}\n+\n+\n+// @fn copyConstructorCheck()\n+// Explicitly checks the deque copy constructor.  Continues verificaton of\n+// ancillary member functions documented under defaultConstructorCheck().\n+//\n+// This check also tests the push_back() member function.\n+//\n+// @verbatim\n+// 23.2.1     copy constructor\n+//  effects:\n+//  postconditions:\n+//    22.1.1 table 65 a == X(a)\n+//                    u == a\n+//  throws:\n+//  complexity:\n+//    22.1.1 table 65 linear\n+// @endverbatim\n+void\n+copyConstructorCheck()\n+{\n+  // setup\n+  typedef gnu_copy_tracker  T;\n+  typedef std::deque<T>     X;\n+\n+  const int copyBaseSize = 17;  // arbitrary\n+\n+  X a;\n+  for (int i = 0; i < copyBaseSize; ++i)\n+    a.push_back(i);\n+  gnu_copy_tracker::reset();\n+\n+  // assert preconditions\n+  VERIFY(!a.empty());\n+  VERIFY(copyBaseSize == a.size());\n+  VERIFY(a.begin() != a.end());\n+  VERIFY(copyBaseSize == std::distance(a.begin(), a.end()));\n+\n+  // run test\n+  X u = a;\n+\n+  // assert postconditions\n+  VERIFY(u == a);\n+  VERIFY(copyBaseSize == gnu_copy_constructor::count());\n+\n+  // teardown\n+}\n+\n+\n+// @fn fillConstructorCheck()\n+// This test explicitly verifies the basic fill constructor.  Like the default\n+// constructor, later tests depend on the fill constructor working correctly.\n+// That means this explicit test should preceed the later tests so the error\n+// message given on assertion failure can be more helpful n tracking the\n+// problem.\n+// \n+// 23.2.1.1   fill constructor\n+//  complexity:\n+//    23.2.1.1        linear in N\n+void\n+fillConstructorCheck()\n+{\n+  // setup\n+  typedef gnu_copy_tracker  T;\n+  typedef std::deque<T>   X;\n+\n+  const X::size_type  n(23);  \n+  const X::value_type t(111);\n+\n+  gnu_copy_tracker::reset();\n+\n+  // run test\n+  X a(n, t);\n+\n+  // assert postconditions\n+  VERIFY(n == a.size());\n+  VERIFY(n == gnu_copy_constructor::count());\n+\n+  // teardown\n+}\n+\n+\n+// @fn fillConstructorCheck2()\n+// Explicit check for fill constructors masqueraded as range constructors as\n+// elucidated in clause 23.1.1 paragraph 9 of the standard.\n+//\n+// 23.1.1 (9) fill constructor looking like a range constructor\n+void\n+fillConstructorCheck2()\n+{\n+  typedef gnu_copy_tracker  T;\n+  typedef std::deque<T>   X;\n+\n+  const int f = 23;  \n+  const int l = 111;\n+\n+  gnu_copy_tracker::reset();\n+\n+  X a(f, l);\n+\n+  VERIFY(f == a.size());\n+  VERIFY(f == gnu_copy_constructor::count());\n+}\n+\n+\n+// @fn rangeConstructorCheckForwardIterator()\n+// This test copies from one deque to another to force the copy\n+// constructor for T to be used because the compiler will kindly\n+// elide copies if the default constructor can be used with\n+// type conversions.  Trust me.\n+//\n+// 23.2.1.1   range constructor, forward iterators\n+void\n+rangeConstructorCheckForwardIterator()\n+{\n+  // setup\n+  typedef gnu_copy_tracker  T;\n+  typedef std::deque<T>   X;\n+\n+  const X::size_type  n(726); \n+  const X::value_type t(307);\n+  X source(n, t);\n+  X::iterator i = source.begin();\n+  X::iterator j = source.end();\n+  X::size_type rangeSize = std::distance(i, j);\n+\n+  gnu_copy_tracker::reset();\n+\n+  // test\n+  X a(i, j);\n+\n+  // assert postconditions\n+  VERIFY(rangeSize == a.size());\n+  VERIFY(gnu_copy_constructor::count() <= rangeSize);\n+}\n+\n+\n+// @fn rangeConstructorCheckInputIterator()\n+// An explicit check for range construction on an input iterator\n+// range, which the standard expounds upon as having a different\n+// complexity than forward iterators.\n+//\n+// 23.2.1.1   range constructor, input iterators\n+void\n+rangeConstructorCheckInputIterator()\n+{\n+  typedef gnu_copy_tracker  T;\n+  typedef std::deque<T>     X;\n+\n+  std::istringstream ibuf(\"1234567890123456789\");\n+  const X::size_type rangeSize = ibuf.str().size();  \n+  std::istream_iterator<char>  i(ibuf);\n+  std::istream_iterator<char>  j;\n+\n+  gnu_copy_tracker::reset();\n+\n+  X a(i, j);\n+\n+  VERIFY(rangeSize == a.size());\n+  VERIFY(gnu_copy_constructor::count() <= (2 * rangeSize));\n+}\n+\n+\n+// 23.2.1     copy assignment\n+void\n+copyAssignmentCheck()\n+{\n+  typedef gnu_copy_tracker  T;\n+  typedef std::deque<T>     X;\n+\n+  const X::size_type  n(18);  \n+  const X::value_type t(1023);\n+  X a(n, t);\n+  X r;\n+\n+  gnu_copy_tracker::reset();\n+\n+  r = a;\n+\n+  VERIFY(r == a);\n+  VERIFY(n == gnu_copy_constructor::count());\n+}\n+\n+\n+// 23.2.1.1   fill assignment\n+//\n+// The complexity check must check dtors+copyAssign and\n+// copyCtor+copyAssign because that's the way the SGI implementation\n+// works.  Dunno if it's true standard compliant (which specifies fill\n+// assignment in terms of erase and insert only), but it should work\n+// as (most) users expect and is more efficient.\n+void\n+fillAssignmentCheck()\n+{\n+  typedef gnu_copy_tracker  T;\n+  typedef std::deque<T>   X;\n+\n+  const X::size_type  starting_size(10);  \n+  const X::value_type starting_value(66);\n+  const X::size_type  n(23);  \n+  const X::value_type t(111);\n+\n+  X a(starting_size, starting_value);\n+  gnu_copy_tracker::reset();\n+\n+  // preconditions\n+  VERIFY(starting_size == a.size());\n+\n+  // test\n+  a.assign(n, t);\n+\n+  // postconditions\n+  VERIFY(n == a.size());\n+  VERIFY(n == (gnu_copy_constructor::count() + gnu_assignment_operator::count()));\n+  VERIFY(starting_size == (gnu_destructor::count() + gnu_assignment_operator::count()));\n+}\n+\n+\n+// @verbatim\n+// 23.2.1     range assignment\n+// 23.2.1.1   deque constructors, copy, and assignment\n+//  effects:\n+//  Constructs a deque equal to the range [first, last), using the\n+//  specified allocator.\n+//\n+//      template<typename InputIterator>\n+//        assign(InputIterator first, InputIterator last);\n+//      \n+//    is equivalent to\n+//\n+//      erase(begin(), end());\n+//      insert(begin(), first, last);\n+//\n+//  postconditions:\n+//  throws:\n+//  complexity:\n+//    forward iterators: N calls to the copy constructor, 0 reallocations\n+//    input iterators:   2N calls to the copy constructor, log(N) reallocations\n+// @endverbatim\n+void\n+rangeAssignmentCheck()\n+{\n+  typedef gnu_copy_tracker  T;\n+  typedef std::deque<T>   X;\n+\n+  const X::size_type  source_size(726); \n+  const X::value_type source_value(307);\n+  const X::size_type  starting_size(10);  \n+  const X::value_type starting_value(66);\n+\n+  X source(source_size, source_value);\n+  X::iterator i = source.begin();\n+  X::iterator j = source.end();\n+  X::size_type rangeSize = std::distance(i, j);\n+\n+  X a(starting_size, starting_value);\n+  VERIFY(starting_size == a.size());\n+\n+  gnu_copy_tracker::reset();\n+\n+  a.assign(i, j);\n+\n+  VERIFY(source == a);\n+  VERIFY(rangeSize == (gnu_copy_constructor::count() + gnu_assignment_operator::count()));\n+  VERIFY(starting_size == (gnu_destructor::count() + gnu_assignment_operator::count()));\n+}\n+\n+\n+// 23.1 (10)  range assignment\n+// 23.2.1.3   with exception\n+void\n+rangeAssignmentCheckWithException()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::deque<T>    X;\n+\n+  // test\n+  // What does \"no effects\" mean?\n+}\n+\n+\n+// 23.1.1 (9) fill assignment looking like a range assignment\n+void\n+fillAssignmentCheck2()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::deque<T>    X;\n+\n+  // test\n+  // What does \"no effects\" mean?\n+}\n+\n+// Verify that the default deque constructor offers the basic exception\n+// guarantee.\n+void\n+test_default_ctor_exception_safety()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::deque<T, gnu_new_allocator<T> > X;\n+\n+  T::reset();\n+  gnu_copy_constructor::throw_on(3);\n+  gnu_allocator_tracker::resetCounts();\n+\n+  // test\n+  try\n+  {\n+    X a(7);\n+    VERIFY((\"no exception thrown\", false));\n+  }\n+  catch (...)\n+  {\n+  }\n+\n+  // assert postconditions\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+\n+  // teardown\n+}\n+\n+// Verify that the copy constructor offers the basic exception guarantee.\n+void\n+test_copy_ctor_exception_safety()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::deque<T, gnu_new_allocator<T> > X;\n+\n+  gnu_allocator_tracker::resetCounts();\n+  {\n+    X a(7);\n+    T::reset();\n+    gnu_copy_constructor::throw_on(3);\n+\n+\n+    // test\n+    try\n+    {\n+      X u(a);\n+      VERIFY((\"no exception thrown\", false));\n+    }\n+    catch (...)\n+    {\n+    }\n+  }\n+\n+  // assert postconditions\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+\n+  // teardown\n+}\n+\n+\n int main()\n {\n+  // basic functionality and standard conformance checks\n+  requiredTypesCheck();\n+  defaultConstructorCheckPOD();\n+  defaultConstructorCheck();\n+  test_default_ctor_exception_safety();\n+  copyConstructorCheck();\n+  test_copy_ctor_exception_safety();\n+  fillConstructorCheck();\n+  fillConstructorCheck2();\n+  rangeConstructorCheckInputIterator();\n+  rangeConstructorCheckForwardIterator();\n+  copyAssignmentCheck();\n+  fillAssignmentCheck();\n+  fillAssignmentCheck2();\n+  rangeAssignmentCheck();\n+  rangeAssignmentCheckWithException();\n+\n+  // specific bug fix checks\n   test01();\n \n-  return 0;\n+  return !test;\n }"}, {"sha": "621ef7e373fa1fde5a965ebd6d38425d69a40b23", "filename": "libstdc++-v3/testsuite/23_containers/vector_capacity.cc", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_capacity.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_capacity.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_capacity.cc?ref=162c7cd92dae4c0504dd653b948369a3f593ca32", "patch": "@@ -23,6 +23,7 @@\n \n #include <vector>\n #include <stdexcept>\n+#include <testsuite_allocator.h>\n #include <testsuite_hooks.h>\n \n template<typename T>\n@@ -119,10 +120,72 @@ void test03()\n   VERIFY( test );\n }\n \n+// Verifies basic functionality of reserve() with forced reallocation.\n+void\n+test_reserve()\n+{\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  gnu_allocator_tracker::resetCounts();\n+  {\n+    X a(3);\n+    const X::size_type old_size     = a.size();\n+    const X::size_type old_capacity = a.capacity();\n+    const X::size_type new_capacity = old_capacity + 10;\n+    T::reset();\n+    \n+    a.reserve(new_capacity);\n+\n+    // [23.2.4.1 (2)]\n+    VERIFY(new_capacity <= a.capacity());\n+    // [23.2.4.1 (3)]\n+    VERIFY(old_size == a.size());\n+    VERIFY(gnu_copy_constructor::count() <= old_size);\n+    VERIFY(gnu_destructor::count() <= old_size);\n+  }\n+  // check for memory leaks\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+}\n+\n+// Verifies that reserve() with reallocation offers the strong\n+// exception guarantee.\n+void\n+test_reserve_exception_guarantee()\n+{\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  gnu_allocator_tracker::resetCounts();\n+  {\n+    X a(7);\n+    const X::size_type old_size     = a.size();\n+    const X::size_type old_capacity = a.capacity();\n+    const X::size_type new_capacity = old_capacity + 10;\n+    T::reset();\n+    gnu_copy_constructor::throw_on(3);\n+    \n+    try\n+    {\n+      a.reserve(new_capacity);\n+      VERIFY((\"no exception thrown\", false));\n+    }\n+    catch (...)\n+    {\n+    }\n+\n+    VERIFY(old_capacity == a.capacity());\n+    VERIFY(gnu_copy_constructor::count() == gnu_destructor::count()+1);\n+  }\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+}\n+\n int main()\n {\n   test01();\n   test02();\n   test03();\n+  test_reserve();\n+  test_reserve_exception_guarantee();\n   return 0;\n }"}, {"sha": "d8789f57146de35846940c4d811d5b0befea02db", "filename": "libstdc++-v3/testsuite/23_containers/vector_ctor.cc", "status": "modified", "additions": 540, "deletions": 1, "changes": 541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_ctor.cc?ref=162c7cd92dae4c0504dd653b948369a3f593ca32", "patch": "@@ -1,6 +1,6 @@\n // 1999-06-29 bkoz\n \n-// Copyright (C) 1999-2001 Free Software Foundation, Inc.\n+// Copyright (C) 1999-2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -22,6 +22,7 @@\n \n #include <vector>\n #include <string>\n+#include <testsuite_allocator.h>\n #include <testsuite_hooks.h>\n \n template<typename T>\n@@ -94,12 +95,550 @@ void test04()\n #endif\n }\n \n+\n+// @fn test_default_ctor_exception_gurantee This test verifies that if\n+// one of the vector's contained objects throws an exception from its\n+// constructor while the vector is being constructed and filled with\n+// default values, all memory is returned to the allocator whence it\n+// came.\n+void\n+test_default_ctor_exception_gurantee()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  gnu_copy_tracker::reset();\n+  gnu_copy_constructor::throw_on(3);\n+  gnu_allocator_tracker::resetCounts();\n+\n+  // run test\n+  try\n+  {\n+    X a(7);\n+    VERIFY((\"no exception thrown\", false));\n+  }\n+  catch (...)\n+  {\n+  }\n+\n+  // assert postconditions\n+  VERIFY((\"memory leak detected:\",\n+          gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal()));\n+\n+  // teardown\n+}\n+\n+// @fn test_copy_ctor_exception_gurantee This test verifies that if\n+// one of the vector's contained objects throws an exception from its\n+// constructor while the vector is being copy constructed, all memory\n+// is returned to the allocator whence it came.\n+void\n+test_copy_ctor_exception_gurantee()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  gnu_allocator_tracker::resetCounts();\n+  {\n+    X a(7);\n+    gnu_copy_tracker::reset();\n+    gnu_copy_constructor::throw_on(3);\n+\n+    // run test\n+    try\n+    {\n+      X u(a);\n+      VERIFY((\"no exception thrown\", false));\n+    }\n+    catch (...)\n+    {\n+    }\n+  }\n+\n+  // assert postconditions\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+\n+  // teardown\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+}\n+\n+// operator=()\n+//\n+// case 1: lhs.size() > rhs.size()\n+// case 2: lhs.size() < rhs.size() < lhs.capacity()\n+// case 3: lhs.capacity() < rhs.size()\n+//\n+void\n+test_assignment_operator_1()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  X r(9);\n+  X a(r.size() - 2);\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+\n+  // preconditions\n+  VERIFY(r.size() > a.size());\n+\n+  // run test\n+  r = a;\n+\n+  // assert postconditions\n+  VERIFY(r == a);\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == 0);\n+\n+  // teardown\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+}\n+\n+void\n+test_assignment_operator_2()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  X r(1);\n+  r.reserve(17);\n+  X a(r.size() + 7);\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+\n+  // preconditions\n+  VERIFY(r.size() < a.size());\n+  VERIFY(a.size() < r.capacity());\n+\n+  // run test\n+  r = a;\n+\n+  // assert postconditions\n+  VERIFY(r == a);\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == 0);\n+\n+  // teardown\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+}\n+\n+void\n+test_assignment_operator_3()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  gnu_allocator_tracker::resetCounts();\n+  {\n+    X r(1);\n+    X a(r.capacity() + 7);\n+    gnu_copy_tracker::reset();\n+\n+    // preconditions\n+    VERIFY(r.capacity() < a.size());\n+\n+    // run test\n+    r = a;\n+\n+    // assert postconditions\n+    VERIFY(r == a);\n+  }\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+\n+  // teardown\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+}\n+\n+void\n+test_assignment_operator_3_exception_guarantee()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  gnu_allocator_tracker::resetCounts();\n+  {\n+    X r(1);\n+    X a(r.capacity() + 7);\n+    gnu_copy_tracker::reset();\n+    gnu_copy_constructor::throw_on(3);\n+\n+    // preconditions\n+    VERIFY(r.capacity() < a.size());\n+\n+    // run test\n+    try\n+    {\n+      r = a;\n+      VERIFY((\"no exception thrown\", false));\n+    }\n+    catch (...)\n+    {\n+    }\n+  }\n+\n+  // assert postconditions\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+\n+  // teardown\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+}\n+\n+// fill assign()\n+//\n+// case 1: [23.2.4.1 (3)] n <= size()\n+// case 2: [23.2.4.1 (3)] size() < n <= capacity()\n+// case 3: [23.2.4.1 (3)] n > capacity()\n+// case 4: [23.2.4.1 (3)] n > capacity(), exception guarantees\n+// case 5: [23.1.1 (9)] fill assign disguised as a range assign\n+//\n+void\n+test_fill_assign_1()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  X a(7);\n+  X::size_type old_size = a.size();\n+  X::size_type new_size = old_size - 2;\n+  const T t;\n+\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+\n+  // run test\n+  a.assign(new_size, t);\n+\n+  // assert postconditions\n+  VERIFY(a.size() == new_size);\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == 0);\n+\n+  // teardown\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+}\n+\n+void\n+test_fill_assign_2()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  X a(7);\n+  a.reserve(11);\n+  X::size_type old_size     = a.size();\n+  X::size_type old_capacity = a.capacity();\n+  X::size_type new_size     = old_size + 2;\n+  const T t;\n+\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+\n+  // assert preconditions\n+  VERIFY(old_size < new_size);\n+  VERIFY(new_size <= old_capacity);\n+\n+  // run test\n+  a.assign(new_size, t);\n+\n+  // assert postconditions\n+  VERIFY(a.size() == new_size);\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == 0);\n+\n+  // teardown\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+}\n+\n+void\n+test_fill_assign_3()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  gnu_allocator_tracker::resetCounts();\n+  {\n+    X a(7);\n+    X::size_type old_size     = a.size();\n+    X::size_type old_capacity = a.capacity();\n+    X::size_type new_size     = old_capacity + 4;\n+    const T t;\n+\n+    gnu_copy_tracker::reset();\n+\n+    // assert preconditions\n+    VERIFY(new_size > old_capacity);\n+\n+    // run test\n+    a.assign(new_size, t);\n+\n+    // assert postconditions\n+    VERIFY(a.size() == new_size);\n+  }\n+\n+  VERIFY(gnu_allocator_tracker::allocationTotal() > 0);\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+\n+  // teardown\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+}\n+\n+void\n+test_fill_assign_3_exception_guarantee()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  gnu_allocator_tracker::resetCounts();\n+  {\n+    X a(7);\n+    X::size_type old_size     = a.size();\n+    X::size_type old_capacity = a.capacity();\n+    X::size_type new_size     = old_capacity + 4;\n+    const T t;\n+\n+    gnu_copy_tracker::reset();\n+    gnu_copy_constructor::throw_on(3);\n+\n+    // assert preconditions\n+    VERIFY(new_size > old_capacity);\n+\n+    // run test\n+    try\n+    {\n+      a.assign(new_size, t);\n+      VERIFY((\"no exception thrown\", false));\n+    }\n+    catch (...)\n+    {\n+    }\n+\n+    // assert postconditions\n+    VERIFY(a.size() == old_size);\n+    VERIFY(a.capacity() == old_capacity);\n+  }\n+\n+  VERIFY(gnu_allocator_tracker::allocationTotal() > 0);\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+\n+  // teardown\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+}\n+\n+void\n+test_fill_assign_4()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  X a(7);\n+  X::size_type old_size  = a.size();\n+  X::size_type new_size  = old_size - 2;\n+  X::size_type new_value = 117;\n+\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+\n+  // run test\n+  a.assign(new_size, new_value);\n+\n+  // assert postconditions\n+  VERIFY(a.size() == new_size);\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == 0);\n+\n+  // teardown\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+}\n+\n+// range assign()\n+//\n+// case 1: [23.2.4.1 (2)] input iterator\n+// case 2: [23.2.4.1 (2)] forward iterator, distance(first, last) <= size()\n+// case 3: [23.2.4.1 (2)] \n+//         forward iterator, size() < distance(first, last) <= capacity()\n+// case 4: [23.2.4.1 (2)] forward iterator, distance(first, last) > capacity()\n+// case 5: [23.2.4.1 (2)] \n+//         forward iterator, distance(first, last) > capacity(), \n+//         exception guarantees\n+void\n+test_range_assign_1()\n+{\n+  // @TODO\n+}\n+\n+void\n+test_range_assign_2()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  X a(7);\n+  X b(3);\n+  X::size_type old_size = a.size();\n+\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+\n+  // assert preconditions\n+  VERIFY(b.size() < a.capacity());\n+\n+  // run test\n+  a.assign(b.begin(), b.end());\n+\n+  // assert postconditions\n+  VERIFY(a.size() == b.size());\n+  VERIFY(a == b);\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == 0);\n+\n+  // teardown\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+}\n+\n+void\n+test_range_assign_3()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  X a(7);\n+  a.reserve(a.size() + 7);\n+  X b(a.size() + 3);\n+  X::size_type old_size = a.size();\n+\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+\n+  // assert preconditions\n+  VERIFY(a.size() < b.size());\n+  VERIFY(b.size() < a.capacity());\n+\n+  // run test\n+  a.assign(b.begin(), b.end());\n+\n+  // assert postconditions\n+  VERIFY(a.size() == b.size());\n+  VERIFY(a == b);\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == 0);\n+\n+  // teardown\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+}\n+\n+void\n+test_range_assign_4()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  gnu_allocator_tracker::resetCounts();\n+  {\n+    X a(7);\n+    X b(a.capacity() + 7);\n+    X::size_type old_size = a.size();\n+\n+    gnu_copy_tracker::reset();\n+\n+    // assert preconditions\n+    VERIFY(b.size() > a.capacity());\n+\n+    // run test\n+    a.assign(b.begin(), b.end());\n+\n+    // assert postconditions\n+    VERIFY(a.size() == b.size());\n+    VERIFY(a == b);\n+  }\n+  VERIFY(gnu_allocator_tracker::allocationTotal() > 0);\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+\n+  // teardown\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+}\n+\n+void\n+test_range_assign_4_exception_guarantee()\n+{\n+  // setup\n+  typedef gnu_copy_tracker T;\n+  typedef std::vector<T, gnu_new_allocator<T> > X;\n+\n+  gnu_allocator_tracker::resetCounts();\n+  {\n+    X a(7);\n+    X b(a.capacity() + 7);\n+    X::size_type old_size = a.size();\n+\n+    gnu_copy_tracker::reset();\n+    gnu_copy_constructor::throw_on(3);\n+\n+    // assert preconditions\n+    VERIFY(b.size() > a.capacity());\n+\n+    // run test\n+    try\n+    {\n+      a.assign(b.begin(), b.end());\n+      VERIFY((\"no exception thrown\", false));\n+    }\n+    catch (...)\n+    {\n+    }\n+  }\n+\n+  // assert postconditions\n+  VERIFY(gnu_allocator_tracker::allocationTotal() > 0);\n+  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+\n+  // teardown\n+  gnu_copy_tracker::reset();\n+  gnu_allocator_tracker::resetCounts();\n+}\n+\n+\n int main()\n {\n   test01();\n   test02(); \n   test03();\n   test04();\n+  test_default_ctor_exception_gurantee();\n+  test_copy_ctor_exception_gurantee();\n+  test_assignment_operator_1();\n+  test_assignment_operator_2();\n+  test_assignment_operator_3();\n+  test_assignment_operator_3_exception_guarantee();\n+  test_fill_assign_1();\n+  test_fill_assign_2();\n+  test_fill_assign_3();\n+  test_fill_assign_3_exception_guarantee();\n+  test_fill_assign_4();\n+  test_range_assign_1();\n+  test_range_assign_2();\n+  test_range_assign_3();\n+  test_range_assign_4();\n+  test_range_assign_4_exception_guarantee();\n \n   return 0;\n }"}, {"sha": "d85fae7d8d94579a0a47b7e81ed8c2385a2a88e4", "filename": "libstdc++-v3/testsuite/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.am?ref=162c7cd92dae4c0504dd653b948369a3f593ca32", "patch": "@@ -51,7 +51,7 @@ INCLUDES = \\\n \n ## Build support library.\n noinst_LIBRARIES = libv3test.a\n-libv3test_a_SOURCES = testsuite_hooks.cc\n+libv3test_a_SOURCES = testsuite_hooks.cc testsuite_allocator.cc\n \n ## Build support utilities.\n ## Only build this as native, as need to find startup files and libc to link."}, {"sha": "f3d94e4b9b64a0139244b843c3725f0cea0dc77d", "filename": "libstdc++-v3/testsuite/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in?ref=162c7cd92dae4c0504dd653b948369a3f593ca32", "patch": "@@ -162,7 +162,7 @@ INCLUDES = \\\n \n \n noinst_LIBRARIES = libv3test.a\n-libv3test_a_SOURCES = testsuite_hooks.cc\n+libv3test_a_SOURCES = testsuite_hooks.cc testsuite_allocator.cc\n @GLIBCPP_BUILD_ABI_CHECK_TRUE@noinst_PROGRAMS = @GLIBCPP_BUILD_ABI_CHECK_TRUE@abi_check\n @GLIBCPP_BUILD_ABI_CHECK_FALSE@noinst_PROGRAMS = \n abi_check_SOURCES = abi_check.cc\n@@ -177,7 +177,8 @@ CPPFLAGS = @CPPFLAGS@\n LDFLAGS = @LDFLAGS@\n LIBS = @LIBS@\n libv3test_a_LIBADD = \n-libv3test_a_OBJECTS =  testsuite_hooks.$(OBJEXT)\n+libv3test_a_OBJECTS =  testsuite_hooks.$(OBJEXT) \\\n+testsuite_allocator.$(OBJEXT)\n @GLIBCPP_BUILD_ABI_CHECK_FALSE@noinst_PROGRAMS = \n PROGRAMS =  $(noinst_PROGRAMS)\n "}, {"sha": "a4f287e008b4bb81c57aab31cd1845cf9d5dc42f", "filename": "libstdc++-v3/testsuite/testsuite_allocator.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.cc?ref=162c7cd92dae4c0504dd653b948369a3f593ca32", "patch": "@@ -0,0 +1,35 @@\n+//\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <testsuite_allocator.h>\n+\n+gnu_allocator_tracker::size_type gnu_allocator_tracker::allocationTotal_   = 0;\n+gnu_allocator_tracker::size_type gnu_allocator_tracker::deallocationTotal_ = 0;\n+int                              gnu_allocator_tracker::constructCount_    = 0;\n+int                              gnu_allocator_tracker::destructCount_     = 0;\n+"}, {"sha": "1387b5af0ec804b09ff14c5df0dfcdd047aa528a", "filename": "libstdc++-v3/testsuite/testsuite_allocator.h", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.h?ref=162c7cd92dae4c0504dd653b948369a3f593ca32", "patch": "@@ -0,0 +1,181 @@\n+// Testing allocator for the C++ library testsuite.\n+//\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// This file provides an test instrumentation allocator that can be\n+// used to verify allocation functionality of standard library\n+// containers.  2002.11.25 smw\n+\n+#ifndef _GLIBCPP_TESTSUITE_ALLOCATOR_H\n+#define _GLIBCPP_TESTSUITE_ALLOCATOR_H\n+\n+#include <cstddef>\n+#include <limits>\n+\n+class gnu_allocator_tracker\n+{\n+ public:\n+  typedef std::size_t    size_type; \n+  \n+  static void*\n+  allocate(size_type blocksize)\n+  {\n+    allocationTotal_ += blocksize;\n+    return ::operator new(blocksize);\n+  }\n+\n+  static void\n+  construct()\n+  { constructCount_++; }\n+\n+  static void\n+  destroy()\n+  { destructCount_++; }\n+\n+  static void\n+  deallocate(void* p, size_type blocksize)\n+  {\n+    ::operator delete(p);\n+    deallocationTotal_ += blocksize;\n+  }\n+\n+  static size_type\n+  allocationTotal() \n+  { return allocationTotal_; }\n+\n+  static size_type\n+  deallocationTotal()\n+  { return deallocationTotal_; }\n+\n+  static int\n+  constructCount() \n+  { return constructCount_; }\n+\n+  static int\n+  destructCount() \n+  { return destructCount_; }\n+    \n+  static void\n+  resetCounts()\n+  {\n+    allocationTotal_ = 0;\n+    deallocationTotal_ = 0;\n+    constructCount_ = 0;\n+    destructCount_ = 0;\n+  }\n+\n+ private:\n+  static size_type  allocationTotal_;\n+  static size_type  deallocationTotal_;\n+  static int        constructCount_;\n+  static int        destructCount_;\n+};\n+\n+// A simple basic allocator that just forwards to the\n+// gnu_allocator_tracker to fulfill memory requests.  This class is\n+// templated on the target object type, but gnu_allocator_tracker\n+// isn't.\n+template<class T>\n+  class gnu_new_allocator\n+  {\n+  public:\n+    typedef T              value_type;\n+    typedef T*             pointer;\n+    typedef const T*       const_pointer;\n+    typedef T&             reference;\n+    typedef const T&       const_reference;\n+    typedef std::size_t    size_type; \n+    typedef std::ptrdiff_t difference_type; \n+    \n+    template<class U> struct rebind { typedef gnu_new_allocator<U> other; };\n+    \n+    pointer\n+    address(reference value) const\n+    { return &value; }\n+    \n+    const_pointer\n+    address(const_reference value) const\n+    { return &value; }\n+    \n+    gnu_new_allocator() throw()\n+    { }\n+\n+    gnu_new_allocator(const gnu_new_allocator&) throw()\n+    { }\n+\n+    template<class U>\n+      gnu_new_allocator(const gnu_new_allocator<U>&) throw()\n+      { }\n+\n+    ~gnu_new_allocator() throw()\n+    { }\n+\n+    size_type\n+    max_size() const throw()\n+    { return std::numeric_limits<std::size_t>::max() / sizeof(T); }\n+\n+    pointer\n+    allocate(size_type num, const void* = 0)\n+    { \n+      return static_cast<pointer>(gnu_allocator_tracker::allocate(num * \n+\t\t\t\t\t\t\t\t  sizeof(T))); \n+    }\n+\n+    void\n+    construct(pointer p, const T& value)\n+    {\n+      new (p) T(value);\n+      gnu_allocator_tracker::construct();\n+    }\n+\n+    void\n+    destroy(pointer p)\n+    {\n+      p->~T();\n+      gnu_allocator_tracker::destroy();\n+    }\n+\n+    void\n+    deallocate(pointer p, size_type num)\n+    { gnu_allocator_tracker::deallocate(p, num * sizeof(T)); }\n+  };\n+\n+template<class T1, class T2>\n+  bool\n+  operator==(const gnu_new_allocator<T1>&, \n+\t     const gnu_new_allocator<T2>&) throw()\n+  { return true; }\n+\n+template<class T1, class T2>\n+  bool\n+  operator!=(const gnu_new_allocator<T1>&, \n+\t     const gnu_new_allocator<T2>&) throw()\n+  { return false; }\n+\n+#endif // _GLIBCPP_TESTSUITE_ALLOCATOR_H\n+"}, {"sha": "931dd378193019a59277943b3c379f79e4b38a76", "filename": "libstdc++-v3/testsuite/testsuite_hooks.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.cc?ref=162c7cd92dae4c0504dd653b948369a3f593ca32", "patch": "@@ -78,6 +78,10 @@ __set_testsuite_memlimit(float) { }\n \n gnu_counting_struct::size_type  gnu_counting_struct::count = 0;\n \n-int gnu_copy_tracker::itsCopyCount = 0;\n-int gnu_copy_tracker::itsDtorCount = 0;\n+unsigned int gnu_copy_constructor::count_ = 0;\n+unsigned int gnu_copy_constructor::throw_on_ = 0;\n+unsigned int gnu_assignment_operator::count_ = 0;\n+unsigned int gnu_assignment_operator::throw_on_ = 0;\n+unsigned int gnu_destructor::count_ = 0;\n+int gnu_copy_tracker::next_id_ = 0;\n "}, {"sha": "9f89b03a77200a5f4b97c47611c4b2a781d608be", "filename": "libstdc++-v3/testsuite/testsuite_hooks.h", "status": "modified", "additions": 142, "deletions": 23, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162c7cd92dae4c0504dd653b948369a3f593ca32/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.h?ref=162c7cd92dae4c0504dd653b948369a3f593ca32", "patch": "@@ -100,58 +100,177 @@ struct gnu_counting_struct\n \n #define assert_count(n)   VERIFY(gnu_counting_struct::count == n)\n \n+// A (static) class for counting copy constructors and possibly throwing an\n+// exception on a desired count.\n+class gnu_copy_constructor\n+{\n+public:\n+  static unsigned int\n+  count()\n+  { return count_; }\n+\n+  static void\n+  mark_call()\n+  {\n+    count_++;\n+    if (count_ == throw_on_)\n+    {\n+      __throw_exception_again \"copy constructor exception\";\n+    }\n+  }\n+\n+  static void\n+  reset()\n+  {\n+    count_ = 0;\n+    throw_on_ = 0;\n+  }\n+\n+  static void\n+  throw_on(unsigned int count)\n+  { throw_on_ = count; }\n+\n+private:\n+  static unsigned int count_;\n+  static unsigned int throw_on_;\n+};\n+\n+// A (static) class for counting assignment operator calls and possibly\n+// throwing an exception on a desired count.\n+class gnu_assignment_operator\n+{\n+public:\n+  static unsigned int\n+  count()\n+  { return count_; }\n+\n+  static void\n+  mark_call()\n+  {\n+    count_++;\n+    if (count_ == throw_on_)\n+    {\n+      __throw_exception_again \"assignment operator exception\";\n+    }\n+  }\n+\n+  static void\n+  reset()\n+  {\n+    count_ = 0;\n+    throw_on_ = 0;\n+  }\n+\n+  static void\n+  throw_on(unsigned int count)\n+  { throw_on_ = count; }\n+\n+private:\n+  static unsigned int count_;\n+  static unsigned int throw_on_;\n+};\n+\n+// A (static) class for tracking calls to an object's destructor.\n+class gnu_destructor\n+{\n+public:\n+  static unsigned int\n+  count()\n+  { return count_; }\n+\n+  static void\n+  mark_call()\n+  { count_++; }\n+\n+  static void\n+  reset()\n+  { count_ = 0; }\n+\n+private:\n+  static unsigned int count_;\n+};\n \n+// An class of objects that can be used for validating various behaviours and\n+// guarantees of containers and algorithms defined in the standard library.\n class gnu_copy_tracker\n {\n   public:\n-    // Cannot be explicit.  Conversion ctor used by list_modifiers.cc's\n-    // test03(), \"range fill at beginning\".\n-    gnu_copy_tracker (int anId, bool throwOnDemand = false)\n-    : itsId(anId), willThrow(throwOnDemand)\n-    {}\n-\n-    gnu_copy_tracker (const gnu_copy_tracker& rhs)\n-    : itsId(rhs.id()), willThrow(rhs.willThrow)\n+    // Creates a copy-tracking object with the given ID number.\n+    // If \"throw_on_copy\" is set, an exception will be thrown if\n+    // an attempt is made to copy this object.\n+    gnu_copy_tracker(int id = next_id_--, bool throw_on_copy = false)\n+    : id_(id)\n+    , throw_on_copy_(throw_on_copy)\n     {\n-      ++itsCopyCount;\n-      if (willThrow) \n-\t__throw_exception_again \"copy tracker exception\";\n     }\n \n-    gnu_copy_tracker& operator=(const gnu_copy_tracker& rhs)\n+    // Copy-constructs the object, marking a call to the copy\n+    // constructor and forcing an exception if indicated.\n+    gnu_copy_tracker(const gnu_copy_tracker& rhs)\n+    : id_(rhs.id()), throw_on_copy_(rhs.throw_on_copy_)\n     {\n-      itsId = rhs.id();\n-      // willThrow must obviously already be false to get this far\n+      int kkk = throw_on_copy_;\n+      if (throw_on_copy_)\n+      {\n+        gnu_copy_constructor::throw_on(gnu_copy_constructor::count() + 1);\n+      }\n+      gnu_copy_constructor::mark_call();\n     }\n \n-    ~gnu_copy_tracker() { ++itsDtorCount; }\n+    // Assigns the value of another object to this one, tracking the\n+    // number of times this member function has been called and if the\n+    // other object is supposed to throw an exception when it is\n+    // copied, well, make it so.\n+    gnu_copy_tracker&\n+    operator=(const gnu_copy_tracker& rhs)\n+    { \n+      id_ = rhs.id();\n+      if (rhs.throw_on_copy_)\n+      {\n+        gnu_assignment_operator::throw_on(gnu_assignment_operator::count() \n+\t\t\t\t\t  + 1);\n+      }\n+      gnu_assignment_operator::mark_call();\n+    }\n+\n+    ~gnu_copy_tracker()\n+    { gnu_destructor::mark_call(); }\n \n     int\n     id() const\n-    { return itsId; }\n+    { return id_; }\n \n   private:\n-          int   itsId;\n-    const bool  willThrow;\n+    int   id_;\n+    const bool  throw_on_copy_;\n \n   public:\n     static void\n     reset()\n-    { itsCopyCount = 0; itsDtorCount = 0; }\n+    {\n+      gnu_copy_constructor::reset();\n+      gnu_assignment_operator::reset();\n+      gnu_destructor::reset();\n+    }\n \n+    // for backwards-compatibility\n     static int\n     copyCount() \n-    { return itsCopyCount; }\n+    { return gnu_copy_constructor::count(); }\n \n+    // for backwards-compatibility\n     static int\n     dtorCount() \n-    { return itsDtorCount; }\n+    { return gnu_destructor::count(); }\n \n   private:\n-    static int itsCopyCount;\n-    static int itsDtorCount;\n+    static int next_id_;\n };\n \n+inline bool\n+operator==(const gnu_copy_tracker& lhs, const gnu_copy_tracker& rhs)\n+{ return lhs.id() == rhs.id(); }\n+\n struct gnu_char\n {\n   unsigned long c;"}]}