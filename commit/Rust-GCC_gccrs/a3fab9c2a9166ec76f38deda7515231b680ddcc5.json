{"sha": "a3fab9c2a9166ec76f38deda7515231b680ddcc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNmYWI5YzJhOTE2NmVjNzZmMzhkZWRhNzUxNTIzMWI2ODBkZGNjNQ==", "commit": {"author": {"name": "Rainer Orth", "email": "ro@CeBiTec.Uni-Bielefeld.DE", "date": "2011-06-01T14:46:24Z"}, "committer": {"name": "Rainer Orth", "email": "ro@gcc.gnu.org", "date": "2011-06-01T14:46:24Z"}, "message": "gmon-sol2.c: Reindent.\n\n\t* config/gmon-sol2.c: Reindent.\n\tCleanup comments.\n\tRemove, correct casts.\n\tUse STDERR_FILENO, NULL.\n\t(BASEADDRESS): Remove.\n\t(minbrk): Remove.\n\t(errno, sbrk): Remove declarations.\n\t(monstartup) [hp300]: Remove.\n\t(mcount): Remove.\n\nFrom-SVN: r174531", "tree": {"sha": "38681cb5b7dd08ca0fcf2b99fc5be61cad49e200", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38681cb5b7dd08ca0fcf2b99fc5be61cad49e200"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3fab9c2a9166ec76f38deda7515231b680ddcc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3fab9c2a9166ec76f38deda7515231b680ddcc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3fab9c2a9166ec76f38deda7515231b680ddcc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3fab9c2a9166ec76f38deda7515231b680ddcc5/comments", "author": {"login": "rorth", "id": 3930951, "node_id": "MDQ6VXNlcjM5MzA5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/3930951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rorth", "html_url": "https://github.com/rorth", "followers_url": "https://api.github.com/users/rorth/followers", "following_url": "https://api.github.com/users/rorth/following{/other_user}", "gists_url": "https://api.github.com/users/rorth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rorth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rorth/subscriptions", "organizations_url": "https://api.github.com/users/rorth/orgs", "repos_url": "https://api.github.com/users/rorth/repos", "events_url": "https://api.github.com/users/rorth/events{/privacy}", "received_events_url": "https://api.github.com/users/rorth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca24c5ad7371a5b1947ccd01d4b163d666179669", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca24c5ad7371a5b1947ccd01d4b163d666179669", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca24c5ad7371a5b1947ccd01d4b163d666179669"}], "stats": {"total": 806, "additions": 363, "deletions": 443}, "files": [{"sha": "7aa390477b97566af8be3cc301829b886ae67868", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3fab9c2a9166ec76f38deda7515231b680ddcc5/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3fab9c2a9166ec76f38deda7515231b680ddcc5/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=a3fab9c2a9166ec76f38deda7515231b680ddcc5", "patch": "@@ -1,3 +1,15 @@\n+2011-06-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* config/gmon-sol2.c: Reindent.\n+\tCleanup comments.\n+\tRemove, correct casts.\n+\tUse STDERR_FILENO, NULL.\n+\t(BASEADDRESS): Remove.\n+\t(minbrk): Remove.\n+\t(errno, sbrk): Remove declarations.\n+\t(monstartup) [hp300]: Remove.\n+\t(mcount): Remove.\n+\n 2011-06-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* Makefile.in (cpu_type): Define."}, {"sha": "7d6149665d0c3fa989f46fb34cba2b6632bddfbb", "filename": "libgcc/config/gmon-sol2.c", "status": "modified", "additions": 351, "deletions": 443, "changes": 794, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3fab9c2a9166ec76f38deda7515231b680ddcc5/libgcc%2Fconfig%2Fgmon-sol2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3fab9c2a9166ec76f38deda7515231b680ddcc5/libgcc%2Fconfig%2Fgmon-sol2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fgmon-sol2.c?ref=a3fab9c2a9166ec76f38deda7515231b680ddcc5", "patch": "@@ -28,60 +28,39 @@\n  * SUCH DAMAGE.\n  */\n \n-/* FIXME: Check comment.  */\n-/* Mangled into a form that works on SPARC Solaris 2 by Mark Eichin\n+/* Mangled into a form that works on Solaris 2/SPARC by Mark Eichin\n  * for Cygnus Support, July 1992.\n  *\n- * This is a modified gmon.c by J.W.Hawtin <oolon@ankh.org>,\n- * 14/8/96 based on the original gmon.c in GCC and the hacked version\n- * solaris 2 sparc version (config/sparc/gmon-sol.c) by Mark Eichin. To do\n- * process profiling on solaris 2.X X86\n+ * Modified to support Solaris 2/x86 by J.W.Hawtin <oolon@ankh.org>, 14/8/96.\n  *\n- * It must be used in conjunction with sol2-gc1.asm, which is used to start\n+ * It must be used in conjunction with sol2-gc1.S, which is used to start\n  * and stop process monitoring.\n- *\n- * Differences.\n- *\n- * On Solaris 2 _mcount is called by library functions not mcount, so support\n- * has been added for both.\n- *\n- * Also the prototype for profil() is different\n- *\n- * Solaris 2 does not seem to have char *minbrk whcih allows the setting of\n- * the minimum SBRK region so this code has been removed and lets pray malloc\n- * does not mess it up.\n- *\n- * Notes\n- *\n- * This code could easily be integrated with the original gmon.c and perhaps\n- * should be.\n  */\n+\n #include \"tconfig.h\"\n #include \"tsystem.h\"\n-#include <fcntl.h> /* for creat() */\n+#include <fcntl.h>\t\t/* For creat.  */\n \n-#ifdef DEBUG\n-#include <stdio.h>\n-#endif\n-\n-static void moncontrol (int);\n extern void monstartup (char *, char *);\n extern void _mcleanup (void);\n+#ifdef __i386__\n+static void internal_mcount (void) __attribute__ ((used));\n+#else\n+static void internal_mcount (char *, unsigned short *) __attribute__ ((used));\n+#endif\n+static void moncontrol (int);\n \n struct phdr {\n   char *lpc;\n   char *hpc;\n   int ncnt;\n };\n \n-\n-#define HISTFRACTION 2\n-#define HISTCOUNTER unsigned short\n-#define HASHFRACTION 1\n-#define ARCDENSITY 2\n-#define MINARCS 50\n-#define BASEADDRESS 0x8000000 /* On Solaris 2 X86 all executables start here\n-\t\t\t\t and not at 0 */ \n+#define HISTFRACTION\t2\n+#define HISTCOUNTER\tunsigned short\n+#define HASHFRACTION\t1\n+#define ARCDENSITY\t2\n+#define MINARCS\t\t50\n \n struct tostruct {\n   char *selfpc;\n@@ -90,447 +69,376 @@ struct tostruct {\n };\n \n struct rawarc {\n-    unsigned long       raw_frompc;\n-    unsigned long       raw_selfpc;\n-    long                raw_count;\n+  unsigned long raw_frompc;\n+  unsigned long raw_selfpc;\n+  long raw_count;\n };\n-#define ROUNDDOWN(x,y)  (((x)/(y))*(y))\n-#define ROUNDUP(x,y)    ((((x)+(y)-1)/(y))*(y))\n-\n-/* extern mcount() asm (\"mcount\"); */\n-/*extern*/ char *minbrk /* asm (\"minbrk\") */;\n-typedef __SIZE_TYPE__ size_t;\n-typedef __PTRDIFF_TYPE__ intptr_t;\n-\n-extern int errno;\n-\n-extern void *sbrk (intptr_t);\n-\n-    /*\n-     *\tfroms is actually a bunch of unsigned shorts indexing tos\n-     */\n-static int\t\tprofiling = 3;\n-static unsigned short\t*froms;\n-static struct tostruct\t*tos = 0;\n-static long\t\ttolimit = 0;\n-static char\t\t*s_lowpc = 0;\n-static char\t\t*s_highpc = 0;\n-static size_t\t\ts_textsize = 0;\n-\n-static int\tssiz;\n-static char\t*sbuf;\n-static int\ts_scale;\n-    /* see profil(2) where this is describe (incorrectly) */\n-#define\t\tSCALE_1_TO_1\t0x10000L\n \n-#define\tMSG \"No space for profiling buffer(s)\\n\"\n+#define ROUNDDOWN(x, y)\t(((x) / (y)) * (y))\n+#define ROUNDUP(x, y)\t((((x) + (y) - 1) / (y)) * (y))\n \n-static void moncontrol (int);\n-extern void monstartup (char *, char *);\n-extern void _mcleanup (void);\n+/* froms is actually a bunch of unsigned shorts indexing tos.  */\n+static int profiling = 3;\n+static unsigned short *froms;\n+static struct tostruct *tos = NULL;\n+static long tolimit = 0;\n+static char *s_lowpc = NULL;\n+static char *s_highpc = NULL;\n+static size_t s_textsize = 0;\n \n-void monstartup(char *lowpc, char *highpc)\n+static int ssiz;\n+static char *sbuf;\n+static int s_scale;\n+/* See profil(2) where this is describe (incorrectly).  */\n+#define\tSCALE_1_TO_1\t0x10000L\n+\n+#define\tMSG \"No space for profiling buffer(s)\\n\"\n+\n+void\n+monstartup (char *lowpc, char *highpc)\n {\n-    size_t\t\tmonsize;\n-    char\t\t*buffer;\n-    register size_t\to;\n-\n-\t/*\n-\t *\tround lowpc and highpc to multiples of the density we're using\n-\t *\tso the rest of the scaling (here and in gprof) stays in ints.\n-\t */\n-    lowpc = (char *)\n-\t    ROUNDDOWN((size_t)lowpc, HISTFRACTION*sizeof(HISTCOUNTER));\n-    s_lowpc = lowpc;\n-    highpc = (char *)\n-\t    ROUNDUP((size_t)highpc, HISTFRACTION*sizeof(HISTCOUNTER));\n-    s_highpc = highpc;\n-    s_textsize = highpc - lowpc;\n-    monsize = (s_textsize / HISTFRACTION) + sizeof(struct phdr);\n-    buffer = (char *) sbrk( monsize );\n-    if ( buffer == (char *) -1 ) {\n-\twrite( 2 , MSG , sizeof(MSG) );\n-\treturn;\n-    }\n-    froms = (unsigned short *) sbrk( s_textsize / HASHFRACTION );\n-    if ( froms == (unsigned short *) -1 ) {\n-\twrite( 2 , MSG , sizeof(MSG) );\n-\tfroms = 0;\n-\treturn;\n-    }\n-    tolimit = s_textsize * ARCDENSITY / 100;\n-    if ( tolimit < MINARCS ) {\n-\ttolimit = MINARCS;\n-    } else if ( tolimit > 65534 ) {\n-\ttolimit = 65534;\n-    }\n-    tos = (struct tostruct *) sbrk( tolimit * sizeof( struct tostruct ) );\n-    if ( tos == (struct tostruct *) -1 ) {\n-\twrite( 2 , MSG , sizeof(MSG) );\n-\tfroms = 0;\n-\ttos = 0;\n-\treturn;\n-    }\n-    minbrk = sbrk(0);\n-    tos[0].link = 0;\n-    sbuf = buffer;\n-    ssiz = monsize;\n-    ( (struct phdr *) buffer ) -> lpc = lowpc;\n-    ( (struct phdr *) buffer ) -> hpc = highpc;\n-    ( (struct phdr *) buffer ) -> ncnt = ssiz;\n-    monsize -= sizeof(struct phdr);\n-    if ( monsize <= 0 )\n-\treturn;\n-    o = highpc - lowpc;\n-    if( monsize < o )\n-#ifndef hp300\n-\ts_scale = ( (float) monsize / o ) * SCALE_1_TO_1;\n-#else /* avoid floating point */\n-    {\n-\tint quot = o / monsize;\n-\n-\tif (quot >= 0x10000)\n-\t\ts_scale = 1;\n-\telse if (quot >= 0x100)\n-\t\ts_scale = 0x10000 / quot;\n-\telse if (o >= 0x800000)\n-\t\ts_scale = 0x1000000 / (o / (monsize >> 8));\n-\telse\n-\t\ts_scale = 0x1000000 / ((o << 8) / monsize);\n-    }\n-#endif\n-    else\n-\ts_scale = SCALE_1_TO_1;\n-    moncontrol(1);\n+  size_t monsize;\n+  char *buffer;\n+  size_t o;\n+\n+  /* Round lowpc and highpc to multiples of the density we're using\n+     so the rest of the scaling (here and in gprof) stays in ints.  */\n+  lowpc = (char *) ROUNDDOWN ((size_t) lowpc,\n+\t\t\t      HISTFRACTION * sizeof (HISTCOUNTER));\n+  s_lowpc = lowpc;\n+  highpc = (char *) ROUNDUP ((size_t) highpc,\n+\t\t\t     HISTFRACTION * sizeof (HISTCOUNTER));\n+  s_highpc = highpc;\n+  s_textsize = highpc - lowpc;\n+  monsize = (s_textsize / HISTFRACTION) + sizeof (struct phdr);\n+  buffer = sbrk (monsize);\n+  if (buffer == (void *) -1) {\n+    write (STDERR_FILENO, MSG, sizeof (MSG));\n+    return;\n+  }\n+  froms = sbrk (s_textsize / HASHFRACTION);\n+  if (froms == (void *) -1) {\n+    write (STDERR_FILENO, MSG, sizeof (MSG));\n+    froms = NULL;\n+    return;\n+  }\n+  tolimit = s_textsize * ARCDENSITY / 100;\n+  if (tolimit < MINARCS) {\n+    tolimit = MINARCS;\n+  } else if (tolimit > 65534) {\n+    tolimit = 65534;\n+  }\n+  tos = sbrk (tolimit * sizeof (struct tostruct));\n+  if (tos == (void *) -1) {\n+    write (STDERR_FILENO, MSG, sizeof (MSG));\n+    froms = NULL;\n+    tos = NULL;\n+    return;\n+  }\n+  tos[0].link = 0;\n+  sbuf = buffer;\n+  ssiz = monsize;\n+  ((struct phdr *) buffer)->lpc = lowpc;\n+  ((struct phdr *) buffer)->hpc = highpc;\n+  ((struct phdr *) buffer)->ncnt = ssiz;\n+  monsize -= sizeof (struct phdr);\n+  if (monsize <= 0)\n+    return;\n+  o = highpc - lowpc;\n+  if(monsize < o)\n+    s_scale = ((float) monsize / o) * SCALE_1_TO_1;\n+  else\n+    s_scale = SCALE_1_TO_1;\n+  moncontrol (1);\n }\n \n void\n-_mcleanup(void)\n+_mcleanup (void)\n {\n-    int\t\t\tfd;\n-    int\t\t\tfromindex;\n-    int\t\t\tendfrom;\n-    char\t\t*frompc;\n-    int\t\t\ttoindex;\n-    struct rawarc\trawarc;\n-    char\t\t*profdir;\n-    const char\t\t*proffile;\n-    char\t\t*progname;\n-    char\t\t buf[PATH_MAX];\n-    extern char\t       **___Argv;\n-\n-    moncontrol(0);\n-\n-    if ((profdir = getenv(\"PROFDIR\")) != NULL) {\n-\t/* If PROFDIR contains a null value, no profiling output is produced */\n-\tif (*profdir == '\\0') {\n-\t    return;\n-\t}\n-\n-\tprogname=strrchr(___Argv[0], '/');\n-\tif (progname == NULL)\n-\t    progname=___Argv[0];\n-\telse\n-\t    progname++;\n-\n-\tsprintf(buf, \"%s/%ld.%s\", profdir, (long) getpid(), progname);\n-\tproffile = buf;\n-    } else {\n-\tproffile = \"gmon.out\";\n+  int fd;\n+  int fromindex;\n+  int endfrom;\n+  char *frompc;\n+  int toindex;\n+  struct rawarc\trawarc;\n+  char *profdir;\n+  const char *proffile;\n+  char *progname;\n+  char buf[PATH_MAX];\n+  extern char **___Argv;\n+\n+  moncontrol (0);\n+\n+  if ((profdir = getenv (\"PROFDIR\")) != NULL) {\n+    /* If PROFDIR contains a null value, no profiling output is produced.  */\n+    if (*profdir == '\\0') {\n+      return;\n     }\n \n-    fd = creat( proffile, 0666 );\n-    if ( fd < 0 ) {\n-\tperror( proffile );\n-\treturn;\n+    progname = strrchr (___Argv[0], '/');\n+    if (progname == NULL)\n+      progname = ___Argv[0];\n+    else\n+      progname++;\n+\n+    sprintf (buf, \"%s/%ld.%s\", profdir, (long) getpid (), progname);\n+    proffile = buf;\n+  } else {\n+    proffile = \"gmon.out\";\n+  }\n+\n+  fd = creat (proffile, 0666);\n+  if (fd < 0) {\n+    perror (proffile);\n+    return;\n+  }\n+#ifdef DEBUG\n+  fprintf (stderr, \"[mcleanup] sbuf %#x ssiz %d\\n\", sbuf, ssiz);\n+#endif /* DEBUG */\n+\n+  write (fd, sbuf, ssiz);\n+  endfrom = s_textsize / (HASHFRACTION * sizeof (*froms));\n+  for (fromindex = 0; fromindex < endfrom; fromindex++) {\n+    if (froms[fromindex] == 0) {\n+      continue;\n     }\n-#   ifdef DEBUG\n-\tfprintf( stderr , \"[mcleanup] sbuf %#x ssiz %d\\n\" , sbuf , ssiz );\n-#   endif /* DEBUG */\n-\n-    write( fd , sbuf , ssiz );\n-    endfrom = s_textsize / (HASHFRACTION * sizeof(*froms));\n-    for ( fromindex = 0 ; fromindex < endfrom ; fromindex++ ) {\n-\tif ( froms[fromindex] == 0 ) {\n-\t    continue;\n-\t}\n-\tfrompc = s_lowpc + (fromindex * HASHFRACTION * sizeof(*froms));\n-\tfor (toindex=froms[fromindex]; toindex!=0; toindex=tos[toindex].link) {\n-#\t    ifdef DEBUG\n-\t\tfprintf( stderr ,\n-\t\t\t\"[mcleanup] frompc %#x selfpc %#x count %d\\n\" ,\n-\t\t\tfrompc , tos[toindex].selfpc , tos[toindex].count );\n-#\t    endif /* DEBUG */\n-\t    rawarc.raw_frompc = (unsigned long) frompc;\n-\t    rawarc.raw_selfpc = (unsigned long) tos[toindex].selfpc;\n-\t    rawarc.raw_count = tos[toindex].count;\n-\t    write( fd , &rawarc , sizeof rawarc );\n-\t}\n+    frompc = s_lowpc + (fromindex * HASHFRACTION * sizeof (*froms));\n+    for (toindex = froms[fromindex];\n+\t toindex != 0;\n+\t toindex = tos[toindex].link) {\n+#ifdef DEBUG\n+      fprintf (stderr, \"[mcleanup] frompc %#x selfpc %#x count %d\\n\",\n+\t       frompc, tos[toindex].selfpc, tos[toindex].count);\n+#endif /* DEBUG */\n+      rawarc.raw_frompc = (unsigned long) frompc;\n+      rawarc.raw_selfpc = (unsigned long) tos[toindex].selfpc;\n+      rawarc.raw_count = tos[toindex].count;\n+      write (fd, &rawarc, sizeof (rawarc));\n     }\n-    close( fd );\n+  }\n+  close (fd);\n }\n \n-#ifdef __sparc__\n-/*\n- * The SPARC stack frame is only held together by the frame pointers\n- * in the register windows. According to the SVR4 SPARC ABI\n- * Supplement, Low Level System Information/Operating System\n- * Interface/Software Trap Types, a type 3 trap will flush all of the\n- * register windows to the stack, which will make it possible to walk\n- * the frames and find the return addresses.\n- * \tHowever, it seems awfully expensive to incur a trap (system\n- * call) for every function call. It turns out that \"call\" simply puts\n- * the return address in %o7 expecting the \"save\" in the procedure to\n- * shift it into %i7; this means that before the \"save\" occurs, %o7\n- * contains the address of the call to mcount, and %i7 still contains\n- * the caller above that. The asm mcount here simply saves those\n- * registers in argument registers and branches to internal_mcount,\n- * simulating a call with arguments.\n- * \tKludges:\n- * \t1) the branch to internal_mcount is hard coded; it should be\n- * possible to tell asm to use the assembler-name of a symbol.\n- * \t2) in theory, the function calling mcount could have saved %i7\n- * somewhere and reused the register; in practice, I *think* this will\n- * break longjmp (and maybe the debugger) but I'm not certain. (I take\n- * some comfort in the knowledge that it will break the native mcount\n- * as well.)\n- * \t3) if builtin_return_address worked, this could be portable.\n- * However, it would really have to be optimized for arguments of 0\n- * and 1 and do something like what we have here in order to avoid the\n- * trap per function call performance hit. \n- * \t4) the atexit and monsetup calls prevent this from simply\n- * being a leaf routine that doesn't do a \"save\" (and would thus have\n- * access to %o7 and %i7 directly) but the call to write() at the end\n- * would have also prevented this.\n- *\n- * -- [eichin:19920702.1107EST]\n- */\n-\n-static void internal_mcount (char *, unsigned short *) __attribute__ ((used));\n-\n-/* i7 == last ret, -> frompcindex */\n-/* o7 == current ret, -> selfpc */\n /* Solaris 2 libraries use _mcount.  */\n-asm(\".global _mcount; _mcount: mov %i7,%o1; mov %o7,%o0;b,a internal_mcount\");\n-/* This is for compatibility with old versions of gcc which used mcount.  */\n-asm(\".global mcount; mcount: mov %i7,%o1; mov %o7,%o0;b,a internal_mcount\");\n+#if defined __i386__\n+asm(\".globl _mcount\\n\"\n+    \"_mcount:\\n\"\n+    \"\tjmp\tinternal_mcount\\n\");\n #elif defined __x86_64__\n-extern void internal_mcount (char *, unsigned short *);\n-\n /* See GLIBC for additional information about this technique.  */\n asm(\".globl _mcount\\n\" \n-    \"\\t.type\\t_mcount, @function\\n\"\n+    \"\t.type\t_mcount, @function\\n\"\n     \"_mcount:\\n\"\n     /* The compiler calls _mcount after the prologue, and does not\n        save any of the registers.  Therefore we must preserve all\n        seven registers which may contain function arguments.  */\n-    \"\\tsubq\\t$0x38,%rsp\\n\"\n-    \"\\tmovq\\t%rax,(%rsp)\\n\"\n-    \"\\tmovq\\t%rcx,0x08(%rsp)\\n\"\n-    \"\\tmovq\\t%rdx,0x10(%rsp)\\n\"\n-    \"\\tmovq\\t%rsi,0x18(%rsp)\\n\"\n-    \"\\tmovq\\t%rdi,0x20(%rsp)\\n\"\n-    \"\\tmovq\\t%r8,0x28(%rsp)\\n\"\n-    \"\\tmovq\\t%r9,0x30(%rsp)\\n\"\n+    \"\tsubq\t$0x38, %rsp\\n\"\n+    \"\tmovq\t%rax, (%rsp)\\n\"\n+    \"\tmovq\t%rcx, 0x08(%rsp)\\n\"\n+    \"\tmovq\t%rdx, 0x10(%rsp)\\n\"\n+    \"\tmovq\t%rsi, 0x18(%rsp)\\n\"\n+    \"\tmovq\t%rdi, 0x20(%rsp)\\n\"\n+    \"\tmovq\t%r8, 0x28(%rsp)\\n\"\n+    \"\tmovq\t%r9, 0x30(%rsp)\\n\"\n     /* Get SELFPC (pushed by the call to this function) and\n-       FROMPCINDEX (via the frame pointer.  */\n-    \"\\tmovq\\t0x38(%rsp),%rdi\\n\"\n-    \"\\tmovq\\t0x8(%rbp),%rsi\\n\"\n-    \"\\tcall\\tinternal_mcount\\n\"\n+       FROMPCINDEX (via the frame pointer).  */\n+    \"\tmovq\t0x38(%rsp), %rdi\\n\"\n+    \"\tmovq\t0x8(%rbp), %rsi\\n\"\n+    \"\tcall\tinternal_mcount\\n\"\n     /* Restore the saved registers.  */\n-    \"\\tmovq\\t0x30(%rsp),%r9\\n\"\n-    \"\\tmovq\\t0x28(%rsp),%r8\\n\"\n-    \"\\tmovq\\t0x20(%rsp),%rdi\\n\"\n-    \"\\tmovq\\t0x18(%rsp),%rsi\\n\"\n-    \"\\tmovq\\t0x10(%rsp),%rdx\\n\"\n-    \"\\tmovq\\t0x08(%rsp),%rcx\\n\"\n-    \"\\tmovq\\t(%rsp),%rax\\n\"\n-    \"\\taddq\\t$0x38,%rsp\\n\"\n-    \"\\tretq\\n\"\n-    );\n-#else\n-extern void internal_mcount (void);\n-\n- /* Solaris 2 libraries use _mcount.  */\n-asm(\".globl _mcount; _mcount: jmp internal_mcount\");\n- /* This is for compatibility with old versions of gcc which used mcount.  */\n-asm(\".globl mcount; mcount: jmp internal_mcount\");\n+    \"\tmovq\t0x30(%rsp), %r9\\n\"\n+    \"\tmovq\t0x28(%rsp), %r8\\n\"\n+    \"\tmovq\t0x20(%rsp), %rdi\\n\"\n+    \"\tmovq\t0x18(%rsp), %rsi\\n\"\n+    \"\tmovq\t0x10(%rsp), %rdx\\n\"\n+    \"\tmovq\t0x08(%rsp), %rcx\\n\"\n+    \"\tmovq\t(%rsp), %rax\\n\"\n+    \"\taddq\t$0x38, %rsp\\n\"\n+    \"\tretq\\n\");\n+#elif defined __sparc__\n+/* The SPARC stack frame is only held together by the frame pointers\n+   in the register windows. According to the SVR4 SPARC ABI\n+   Supplement, Low Level System Information/Operating System\n+   Interface/Software Trap Types, a type 3 trap will flush all of the\n+   register windows to the stack, which will make it possible to walk\n+   the frames and find the return addresses.\n+\tHowever, it seems awfully expensive to incur a trap (system\n+   call) for every function call. It turns out that \"call\" simply puts\n+   the return address in %o7 expecting the \"save\" in the procedure to\n+   shift it into %i7; this means that before the \"save\" occurs, %o7\n+   contains the address of the call to mcount, and %i7 still contains\n+   the caller above that. The asm mcount here simply saves those\n+   registers in argument registers and branches to internal_mcount,\n+   simulating a call with arguments.\n+\tKludges:\n+\t1) the branch to internal_mcount is hard coded; it should be\n+   possible to tell asm to use the assembler-name of a symbol.\n+\t2) in theory, the function calling mcount could have saved %i7\n+   somewhere and reused the register; in practice, I *think* this will\n+   break longjmp (and maybe the debugger) but I'm not certain. (I take\n+   some comfort in the knowledge that it will break the native mcount\n+   as well.)\n+\t3) if builtin_return_address worked, this could be portable.\n+   However, it would really have to be optimized for arguments of 0\n+   and 1 and do something like what we have here in order to avoid the\n+   trap per function call performance hit. \n+\t4) the atexit and monsetup calls prevent this from simply\n+   being a leaf routine that doesn't do a \"save\" (and would thus have\n+   access to %o7 and %i7 directly) but the call to write() at the end\n+   would have also prevented this.\n+\n+   -- [eichin:19920702.1107EST]  */\n+asm(\".global _mcount\\n\"\n+    \"_mcount:\\n\"\n+    /* i7 == last ret, -> frompcindex.  */\n+    \"\tmov\t%i7, %o1\\n\"\n+    /* o7 == current ret, -> selfpc.  */\n+    \"\tmov\t%o7, %o0\\n\"\n+    \"\tb,a\tinternal_mcount\\n\");\n #endif\n \n-#ifdef __sparc__\n-static\n-#endif\n-void\n-internal_mcount (\n-#if defined __sparc__ || defined __x86_64__\n-\t\t char *selfpc,\n-\t\t unsigned short *frompcindex\n+static void\n+#ifdef __i386__\n+internal_mcount (void)\n #else\n-\t\t void\n+internal_mcount (char *selfpc, unsigned short *frompcindex)\n #endif\n-\t\t )\n {\n-#if !defined __sparc__ && !defined __x86_64__\n-\tregister char\t\t\t*selfpc;\n-\tregister unsigned short\t\t*frompcindex;\n-#endif\n-\tregister struct tostruct\t*top;\n-\tregister struct tostruct\t*prevtop;\n-\tregister long\t\t\ttoindex;\n-\tstatic char already_setup;\n-\n-#if !defined __sparc__ && !defined __x86_64__\n-\t/*\n-\t *\tfind the return address for mcount,\n-\t *\tand the return address for mcount's caller.\n-\t */\n-\n-\t/* selfpc = pc pushed by mcount call.\n-\t   This identifies the function that was just entered.  */\n-\tselfpc = (void *) __builtin_return_address (0);\n-\t/* frompcindex = pc in preceding frame.\n-\t   This identifies the caller of the function just entered.  */\n-\tfrompcindex = (void *) __builtin_return_address (1);\n-#endif\n+  struct tostruct *top;\n+  struct tostruct *prevtop;\n+  long toindex;\n+  static char already_setup;\n+\n+#ifdef __i386__\n+  char *selfpc;\n+  unsigned short *frompcindex;\n \n-\tif(!already_setup) {\n-          extern char etext[];\n-#ifdef __sparc__\n-\t  extern char _start[];\n-\t  extern char _init[];\n+  /* Find the return address for mcount and the return address for mcount's\n+     caller.  */\n+\n+  /* selfpc = pc pushed by mcount call.\n+     This identifies the function that was just entered.  */\n+  selfpc = (void *) __builtin_return_address (0);\n+  /* frompcindex = pc in preceding frame.\n+     This identifies the caller of the function just entered.  */\n+  frompcindex = (void *) __builtin_return_address (1);\n #endif\n-\t  already_setup = 1;\n-#if defined __sparc__\n-\t  monstartup(_start < _init ? _start : _init, etext);\n+\n+  if(!already_setup) {\n+    extern char etext[];\n+\n+    already_setup = 1;\n+\n+#if defined __i386__\n+    /* <sys/vmparam.h> USERSTACK.  */\n+    monstartup ((char *) 0x8048000, etext);\n #elif defined __x86_64__\n-\t  monstartup(0, etext);\n-#else\n-\t  monstartup((char*)0x08040000, etext);\n-#endif\n-#ifdef USE_ONEXIT\n-\t  on_exit(_mcleanup, 0);\n-#else\n-\t  atexit(_mcleanup);\n+    monstartup (NULL, etext);\n+#elif defined __sparc__\n+    {\n+      extern char _start[];\n+      extern char _init[];\n+\n+      monstartup (_start < _init ? _start : _init, etext);\n+    }\n #endif\n-\t}\n-\t/*\n-\t *\tcheck that we are profiling\n-\t *\tand that we aren't recursively invoked.\n-\t */\n-\tif (profiling) {\n-\t\tgoto out;\n-\t}\n-\tprofiling++;\n-\t/*\n-\t *\tcheck that frompcindex is a reasonable pc value.\n-\t *\tfor example:\tsignal catchers get called from the stack,\n-\t *\t\t\tnot from text space.  too bad.\n-\t */\n-\tfrompcindex = (unsigned short *)((long)frompcindex - (long)s_lowpc);\n-\tif ((unsigned long)frompcindex > s_textsize) {\n-\t\tgoto done;\n-\t}\n-\tfrompcindex =\n-\t    &froms[((long)frompcindex) / (HASHFRACTION * sizeof(*froms))];\n-\ttoindex = *frompcindex;\n-\tif (toindex == 0) {\n-\t\t/*\n-\t\t *\tfirst time traversing this arc\n-\t\t */\n-\t\ttoindex = ++tos[0].link;\n-\t\tif (toindex >= tolimit) {\n-\t\t\tgoto overflow;\n-\t\t}\n-\t\t*frompcindex = toindex;\n-\t\ttop = &tos[toindex];\n-\t\ttop->selfpc = selfpc;\n-\t\ttop->count = 1;\n-\t\ttop->link = 0;\n-\t\tgoto done;\n-\t}\n-\ttop = &tos[toindex];\n-\tif (top->selfpc == selfpc) {\n-\t\t/*\n-\t\t *\tarc at front of chain; usual case.\n-\t\t */\n-\t\ttop->count++;\n-\t\tgoto done;\n-\t}\n-\t/*\n-\t *\thave to go looking down chain for it.\n-\t *\ttop points to what we are looking at,\n-\t *\tprevtop points to previous top.\n-\t *\twe know it is not at the head of the chain.\n-\t */\n-\tfor (; /* goto done */; ) {\n-\t\tif (top->link == 0) {\n-\t\t\t/*\n-\t\t\t *\ttop is end of the chain and none of the chain\n-\t\t\t *\thad top->selfpc == selfpc.\n-\t\t\t *\tso we allocate a new tostruct\n-\t\t\t *\tand link it to the head of the chain.\n-\t\t\t */\n-\t\t\ttoindex = ++tos[0].link;\n-\t\t\tif (toindex >= tolimit) {\n-\t\t\t\tgoto overflow;\n-\t\t\t}\n-\t\t\ttop = &tos[toindex];\n-\t\t\ttop->selfpc = selfpc;\n-\t\t\ttop->count = 1;\n-\t\t\ttop->link = *frompcindex;\n-\t\t\t*frompcindex = toindex;\n-\t\t\tgoto done;\n-\t\t}\n-\t\t/*\n-\t\t *\totherwise, check the next arc on the chain.\n-\t\t */\n-\t\tprevtop = top;\n-\t\ttop = &tos[top->link];\n-\t\tif (top->selfpc == selfpc) {\n-\t\t\t/*\n-\t\t\t *\tthere it is.\n-\t\t\t *\tincrement its count\n-\t\t\t *\tmove it to the head of the chain.\n-\t\t\t */\n-\t\t\ttop->count++;\n-\t\t\ttoindex = prevtop->link;\n-\t\t\tprevtop->link = top->link;\n-\t\t\ttop->link = *frompcindex;\n-\t\t\t*frompcindex = toindex;\n-\t\t\tgoto done;\n-\t\t}\n-\n-\t}\n-done:\n-\tprofiling--;\n-\t/* and fall through */\n-out:\n-\treturn;\t\t/* normal return restores saved registers */\n-\n-overflow:\n-\tprofiling++; /* halt further profiling */\n-#   define\tTOLIMIT\t\"mcount: tos overflow\\n\"\n-\twrite(2, TOLIMIT, sizeof(TOLIMIT));\n-\tgoto out;\n+    atexit (_mcleanup);\n+  }\n+  /* Check that we are profiling and that we aren't recursively invoked.  */\n+  if (profiling) {\n+    goto out;\n+  }\n+  profiling++;\n+  /* Check that frompcindex is a reasonable pc value.  For example: signal\n+     catchers get called from the stack, not from text space.  too bad.  */\n+  frompcindex = (unsigned short *) ((long) frompcindex - (long) s_lowpc);\n+  if ((unsigned long) frompcindex > s_textsize) {\n+    goto done;\n+  }\n+  frompcindex = &froms[((long) frompcindex) / (HASHFRACTION * sizeof (*froms))];\n+  toindex = *frompcindex;\n+  if (toindex == 0) {\n+    /* First time traversing this arc.  */\n+    toindex = ++tos[0].link;\n+    if (toindex >= tolimit) {\n+      goto overflow;\n+    }\n+    *frompcindex = toindex;\n+    top = &tos[toindex];\n+    top->selfpc = selfpc;\n+    top->count = 1;\n+    top->link = 0;\n+    goto done;\n+  }\n+  top = &tos[toindex];\n+  if (top->selfpc == selfpc) {\n+    /* arc at front of chain; usual case.  */\n+    top->count++;\n+    goto done;\n+  }\n+  /* Have to go looking down chain for it.  Top points to what we are\n+     looking at, prevtop points to previous top.  We know it is not at the\n+     head of the chain.  */\n+  for (; /* goto done */; ) {\n+    if (top->link == 0) {\n+      /* top is end of the chain and none of the chain had top->selfpc ==\n+\t selfpc, so we allocate a new tostruct and link it to the head of\n+\t the chain.  */\n+      toindex = ++tos[0].link;\n+      if (toindex >= tolimit) {\n+\tgoto overflow;\n+      }\n+      top = &tos[toindex];\n+      top->selfpc = selfpc;\n+      top->count = 1;\n+      top->link = *frompcindex;\n+      *frompcindex = toindex;\n+      goto done;\n+    }\n+    /* Otherwise, check the next arc on the chain.  */\n+    prevtop = top;\n+    top = &tos[top->link];\n+    if (top->selfpc == selfpc) {\n+      /* There it is.  Increment its count move it to the head of the\n+\t chain.  */\n+      top->count++;\n+      toindex = prevtop->link;\n+      prevtop->link = top->link;\n+      top->link = *frompcindex;\n+      *frompcindex = toindex;\n+      goto done;\n+    }\n+\n+  }\n+ done:\n+  profiling--;\n+  /* ... and fall through. */\n+ out:\n+  /* Normal return restores saved registers.  */\n+  return;\n+\n+ overflow:\n+  /* Halt further profiling.  */\n+  profiling++;\n+\n+#define\tTOLIMIT\t\"mcount: tos overflow\\n\"\n+  write (STDERR_FILENO, TOLIMIT, sizeof (TOLIMIT));\n+  goto out;\n }\n \n-/*\n- * Control profiling\n- *\tprofiling is what mcount checks to see if\n- *\tall the data structures are ready.\n- */\n-static void moncontrol(int mode)\n+/* Control profiling.  Profiling is what mcount checks to see if all the\n+   data structures are ready.  */\n+static void\n+moncontrol (int mode)\n {\n-    if (mode) {\n-\t/* start */\n-\tprofil((unsigned short *)(sbuf + sizeof(struct phdr)),\n-\t       ssiz - sizeof(struct phdr),\n-\t       (size_t)s_lowpc, s_scale);\n-\n-\tprofiling = 0;\n-    } else {\n-\t/* stop */\n-\tprofil((unsigned short *)0, 0, 0, 0);\n-\tprofiling = 3;\n-    }\n+  if (mode) {\n+    /* Start.  */\n+    profil ((unsigned short *) (sbuf + sizeof (struct phdr)),\n+\t    ssiz - sizeof (struct phdr), (size_t) s_lowpc, s_scale);\n+    profiling = 0;\n+  } else {\n+    /* Stop.  */\n+    profil ((unsigned short *) 0, 0, 0, 0);\n+    profiling = 3;\n+  }\n }"}]}