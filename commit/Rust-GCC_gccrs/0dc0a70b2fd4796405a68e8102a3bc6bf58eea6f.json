{"sha": "0dc0a70b2fd4796405a68e8102a3bc6bf58eea6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRjMGE3MGIyZmQ0Nzk2NDA1YTY4ZTgxMDJhM2JjNmJmNThlZWE2Zg==", "commit": {"author": {"name": "Dorit Naishlos", "email": "dorit@il.ibm.com", "date": "2004-11-04T05:26:53Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2004-11-04T05:26:53Z"}, "message": "re PR tree-optimization/18009 (ICE in vect_transform_stmt, at tree-vectorizer.c:2625 (testcase included))\n\n        PR tree-optimization/18009\n        * tree-vectorizer.h (enum dr_alignment_support): New type.\n        (MAX_NUMBER_OF_UNALIGNED_DATA_REFS): Removed.\n        (LOOP_UNALIGNED_DR): replaced with LOOP_VINFO_UNALIGNED_DR and holds a\n        single data_reference (instead of a varray of references).\n        * tree-vectorizer.c (new_loop_vec_info): Likewise.\n        (vect_gen_niters_for_prolog_loop): Likewise.\n        (vect_update_inits_of_drs): Likewise.\n\n        (vect_update_inits_of_drs): Setting of DR_MISALIGNMENT moved to\n        vect_enhance_data_refs_alignment.\n        (vect_do_peeling_for_alignment): Likewise.\n        (vect_enhance_data_refs_alignment): Decide if and by how much to peel;\n        this functionality used to be in vect_analyze_data_refs_alignment.\n        Also update DR_MISALIGNMENT due to peeling; this functionality used to\n        be in vect_update_inits_of_drs and vect_do_peeling_for_alignment).\n        (vect_analyze_data_refs_alignment): Decision on whether and by how much\n        to peel moved to vect_enhance_data_refs_alignment. Call\n        vect_supportable_dr_alignment.\n\n        (vect_compute_data_ref_alignment): Set STMT_VINFO_VECTYPE.\n        (vect_compute_data_refs_alignment): Return bool. Consider return value\n        of vect_compute_data_ref_alignment and return true/false accordingly.\n        (vect_enhance_data_refs_alignment): Consider return value of\n        vect_compute_data_refs_alignment and return true/false accordingly.\n\n        (vect_supportable_dr_alignment): New function.\n        (vectorizable_store): Call vect_supportable_dr_alignment.\n        (vectorizable_load): Call vect_supportable_dr_alignment. Alignment\n        support checks moved from here to vect_supportable_dr_alignment.\n\n        (vect_transform_loop): Avoid 80 columns overflow.\n\nFrom-SVN: r90051", "tree": {"sha": "cfb61a2c8e695f14942532b1eb861820533d36f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfb61a2c8e695f14942532b1eb861820533d36f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dc0a70b2fd4796405a68e8102a3bc6bf58eea6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dc0a70b2fd4796405a68e8102a3bc6bf58eea6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dc0a70b2fd4796405a68e8102a3bc6bf58eea6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dc0a70b2fd4796405a68e8102a3bc6bf58eea6f/comments", "author": null, "committer": null, "parents": [{"sha": "89106ed51e2ed3714572fb7e1bb3f389de04d15f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89106ed51e2ed3714572fb7e1bb3f389de04d15f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89106ed51e2ed3714572fb7e1bb3f389de04d15f"}], "stats": {"total": 305, "additions": 215, "deletions": 90}, "files": [{"sha": "d558a9250590dc87a51050da7739fe29c8debe78", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc0a70b2fd4796405a68e8102a3bc6bf58eea6f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc0a70b2fd4796405a68e8102a3bc6bf58eea6f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0dc0a70b2fd4796405a68e8102a3bc6bf58eea6f", "patch": "@@ -1,3 +1,38 @@\n+2004-11-03  Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\tPR tree-optimization/18009\n+\t* tree-vectorizer.h (enum dr_alignment_support): New type.\n+\t(MAX_NUMBER_OF_UNALIGNED_DATA_REFS): Removed.\n+\t(LOOP_UNALIGNED_DR): replaced with LOOP_VINFO_UNALIGNED_DR and holds a\n+\tsingle data_reference (instead of a varray of references).\n+\t* tree-vectorizer.c (new_loop_vec_info): Likewise.\n+\t(vect_gen_niters_for_prolog_loop): Likewise.\n+\t(vect_update_inits_of_drs): Likewise.\n+\n+\t(vect_update_inits_of_drs): Setting of DR_MISALIGNMENT moved to\n+\tvect_enhance_data_refs_alignment.\n+\t(vect_do_peeling_for_alignment): Likewise.\n+\t(vect_enhance_data_refs_alignment): Decide if and by how much to peel;\n+\tthis functionality used to be in vect_analyze_data_refs_alignment.\n+\tAlso update DR_MISALIGNMENT due to peeling; this functionality used to\n+\tbe in vect_update_inits_of_drs and vect_do_peeling_for_alignment).\n+\t(vect_analyze_data_refs_alignment): Decision on whether and by how much\n+\tto peel moved to vect_enhance_data_refs_alignment. Call \n+\tvect_supportable_dr_alignment.\n+\n+\t(vect_compute_data_ref_alignment): Set STMT_VINFO_VECTYPE.\n+\t(vect_compute_data_refs_alignment): Return bool. Consider return value\n+\tof vect_compute_data_ref_alignment and return true/false accordingly.\n+\t(vect_enhance_data_refs_alignment): Consider return value of \n+\tvect_compute_data_refs_alignment and return true/false accordingly.\n+\n+\t(vect_supportable_dr_alignment): New function.\n+\t(vectorizable_store): Call vect_supportable_dr_alignment.\n+\t(vectorizable_load): Call vect_supportable_dr_alignment. Alignment\n+\tsupport checks moved from here to vect_supportable_dr_alignment.\n+\n+\t(vect_transform_loop): Avoid 80 columns overflow.\n+\n 2004-11-03  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* timevar.c (timevar_enable): Change from"}, {"sha": "2d75a557c9c2f339dcff359315abb58d9e1ec194", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 170, "deletions": 87, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc0a70b2fd4796405a68e8102a3bc6bf58eea6f/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc0a70b2fd4796405a68e8102a3bc6bf58eea6f/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=0dc0a70b2fd4796405a68e8102a3bc6bf58eea6f", "patch": "@@ -154,7 +154,7 @@ static bool vect_mark_stmts_to_be_vectorized (loop_vec_info);\n static bool vect_analyze_scalar_cycles (loop_vec_info);\n static bool vect_analyze_data_ref_accesses (loop_vec_info);\n static bool vect_analyze_data_refs_alignment (loop_vec_info);\n-static void vect_compute_data_refs_alignment (loop_vec_info);\n+static bool vect_compute_data_refs_alignment (loop_vec_info);\n static bool vect_analyze_operations (loop_vec_info);\n \n /* Main code transformation functions.  */\n@@ -165,6 +165,8 @@ static bool vectorizable_load (tree, block_stmt_iterator *, tree *);\n static bool vectorizable_store (tree, block_stmt_iterator *, tree *);\n static bool vectorizable_operation (tree, block_stmt_iterator *, tree *);\n static bool vectorizable_assignment (tree, block_stmt_iterator *, tree *);\n+static enum dr_alignment_support vect_supportable_dr_alignment\n+  (struct data_reference *);\n static void vect_align_data_ref (tree);\n static void vect_enhance_data_refs_alignment (loop_vec_info);\n \n@@ -1118,9 +1120,8 @@ new_loop_vec_info (struct loop *loop)\n \t\t\t   \"loop_write_datarefs\");\n   VARRAY_GENERIC_PTR_INIT (LOOP_VINFO_DATAREF_READS (res), 20,\n \t\t\t   \"loop_read_datarefs\");\n+  LOOP_VINFO_UNALIGNED_DR (res) = NULL;\n \n-  for (i=0; i<MAX_NUMBER_OF_UNALIGNED_DATA_REFS; i++)\n-    LOOP_UNALIGNED_DR (res, i) = NULL;\n   return res;\n }\n \n@@ -2327,10 +2328,12 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree op;\n   tree vec_oprnd1;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n   enum machine_mode vec_mode;\n   tree dummy;\n+  enum dr_alignment_support alignment_support_cheme;\n \n   /* Is vectorizable store? */\n \n@@ -2371,6 +2374,10 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"transform store\");\n \n+  alignment_support_cheme = vect_supportable_dr_alignment (dr);\n+  gcc_assert (alignment_support_cheme);\n+  gcc_assert (alignment_support_cheme = dr_aligned);  /* FORNOW */\n+\n   /* Handle use - get the vectorized def from the defining stmt.  */\n   vec_oprnd1 = vect_get_vec_def_for_operand (op, stmt);\n \n@@ -2414,7 +2421,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   basic_block new_bb;\n   struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n   edge pe = loop_preheader_edge (loop);\n-  bool software_pipeline_loads_p = false;\n+  enum dr_alignment_support alignment_support_cheme;\n \n   /* Is vectorizable load? */\n \n@@ -2443,22 +2450,6 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       return false;\n     }\n \n-  if (!aligned_access_p (dr))\n-    {\n-      if (vec_realign_load_optab->handlers[mode].insn_code != CODE_FOR_nothing\n-\t  && (!targetm.vectorize.builtin_mask_for_load\n-\t      || targetm.vectorize.builtin_mask_for_load ()))\n-\tsoftware_pipeline_loads_p = true;\n-      else if (!targetm.vectorize.misaligned_mem_ok (mode))\n-\t{\n-\t  /* Possibly unaligned access, and can't software pipeline the loads.\n-\t   */\n-\t  if (vect_debug_details (loop))\n-\t    fprintf (dump_file, \"Arbitrary load not supported.\");\n-\t  return false;\n-\t}\n-    }\n-\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = load_vec_info_type;\n@@ -2470,7 +2461,11 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"transform load.\");\n \n-  if (!software_pipeline_loads_p)\n+  alignment_support_cheme = vect_supportable_dr_alignment (dr);\n+  gcc_assert (alignment_support_cheme);\n+\n+  if (alignment_support_cheme == dr_aligned\n+      || alignment_support_cheme == dr_unaligned_supported)\n     {\n       /* Create:\n          p = initial_addr;\n@@ -2500,7 +2495,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       TREE_OPERAND (new_stmt, 0) = new_temp;\n       vect_finish_stmt_generation (stmt, new_stmt, bsi);\n     }\n-  else /* software-pipeline the loads  */\n+  else if (alignment_support_cheme == dr_unaligned_software_pipeline)\n     {\n       /* Create:\n \t p1 = initial_addr;\n@@ -2593,12 +2588,47 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       TREE_OPERAND (new_stmt, 0) = new_temp;\n       vect_finish_stmt_generation (stmt, new_stmt, bsi);\n     }\n+  else\n+    gcc_unreachable ();\n \n   *vec_stmt = new_stmt;\n   return true;\n }\n \n \n+/* Function vect_supportable_dr_alignment\n+\n+   Return whether the data reference DR is supported with respect to its\n+   alignment.  */\n+\n+static enum dr_alignment_support\n+vect_supportable_dr_alignment (struct data_reference *dr)\n+{\n+  tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (DR_STMT (dr)));\n+  enum machine_mode mode = (int) TYPE_MODE (vectype);\n+\n+  if (aligned_access_p (dr))\n+    return dr_aligned;\n+\n+  /* Possibly unaligned access.  */\n+  \n+  if (DR_IS_READ (dr))\n+    {\n+      if (vec_realign_load_optab->handlers[mode].insn_code != CODE_FOR_nothing\n+\t  && (!targetm.vectorize.builtin_mask_for_load\n+\t      || targetm.vectorize.builtin_mask_for_load ()))\n+\treturn dr_unaligned_software_pipeline;\n+\n+      if (targetm.vectorize.misaligned_mem_ok (mode))\n+\t/* Can't software pipeline the loads.  */\n+\treturn dr_unaligned_supported;\n+    }\n+\n+  /* Unsupported.  */\n+  return dr_unaligned_unsupported;\n+}\n+\n+\n /* Function vect_transform_stmt.\n \n    Create a vectorized stmt to replace STMT, and insert it at BSI.  */\n@@ -3013,14 +3043,14 @@ vect_transform_for_unknown_loop_bound (loop_vec_info loop_vinfo, tree * ratio,\n \n    Set the number of iterations for the loop represented by LOOP_VINFO\n    to the minimum between NITERS (the original iteration count of the loop)\n-   and the misalignment DR  - the first data reference in the list\n-   LOOP_UNALIGNED_DR (LOOP_VINFO). As a result, after the execution of this\n-   loop, the data reference DR will refer to an aligned location.  */\n+   and the misalignment of DR - the first data reference recorded in\n+   LOOP_VINFO_UNALIGNED_DR (LOOP_VINFO).  As a result, after the execution of \n+   this loop, the data reference DR will refer to an aligned location.  */\n \n static tree \n vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree niters)\n {\n-  struct data_reference *dr = LOOP_UNALIGNED_DR (loop_vinfo, 0);\n+  struct data_reference *dr = LOOP_VINFO_UNALIGNED_DR (loop_vinfo);\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree var, stmt;\n@@ -3146,7 +3176,6 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n     {\n       struct data_reference *dr = VARRAY_GENERIC_PTR (loop_read_datarefs, i);\n       vect_update_inits_of_dr (dr, loop, niters);\n-      DR_MISALIGNMENT (dr) = -1; \n     }\n }\n \n@@ -3157,14 +3186,13 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n    'niters' is set to the misalignment of one of the data references in the\n    loop, thereby forcing it to refer to an aligned location at the beginning\n    of the execution of this loop.  The data reference for which we are\n-   peeling is chosen from LOOP_UNALIGNED_DR.  */\n+   peeling is recorded in LOOP_VINFO_UNALIGNED_DR.  */\n \n static void\n vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree niters_of_prolog_loop, ni_name;\n-  struct data_reference *dr = LOOP_UNALIGNED_DR (loop_vinfo, 0);\n \n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"\\n<<vect_do_peeling_for_alignment>>\\n\");\n@@ -3177,10 +3205,6 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n   tree_duplicate_loop_to_edge (loop, loops, loop_preheader_edge(loop), \n \t\t\t\t  niters_of_prolog_loop, ni_name, false); \n \n-\n-  /* Update stmt info of dr according to which we peeled.  */\n-  DR_MISALIGNMENT (dr) = 0; \n-  \n   /* Update number of times loop executes.  */\n   vect_update_niters_after_peeling (loop_vinfo, niters_of_prolog_loop);\n \n@@ -3284,8 +3308,9 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n #ifdef ENABLE_CHECKING\n \t  /* FORNOW: Verify that all stmts operate on the same number of\n \t             units and no inner unrolling is necessary.  */\n-\t  gcc_assert (GET_MODE_NUNITS (TYPE_MODE (STMT_VINFO_VECTYPE (stmt_info)))\n-\t\t      == vectorization_factor);\n+\t  gcc_assert \n+\t\t(GET_MODE_NUNITS (TYPE_MODE (STMT_VINFO_VECTYPE (stmt_info)))\n+\t\t == vectorization_factor);\n #endif\n \t  /* -------- vectorize statement ------------ */\n \t  if (vect_debug_details (NULL))\n@@ -4073,6 +4098,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr,\n       /* It is not possible to vectorize this data reference.  */\n       return false;\n     }\n+  STMT_VINFO_VECTYPE (stmt_info) = vectype;\n   gcc_assert (TREE_CODE (ref) == ARRAY_REF || TREE_CODE (ref) == INDIRECT_REF);\n   \n   if (TREE_CODE (ref) == ARRAY_REF)\n@@ -4261,7 +4287,7 @@ vect_compute_array_ref_alignment (struct data_reference *dr,\n    FOR NOW: No analysis is actually performed. Misalignment is calculated\n    only for trivial cases. TODO.  */\n \n-static void\n+static bool\n vect_compute_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n   varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n@@ -4271,14 +4297,18 @@ vect_compute_data_refs_alignment (loop_vec_info loop_vinfo)\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n     {\n       struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n-      vect_compute_data_ref_alignment (dr, loop_vinfo);\n+      if (!vect_compute_data_ref_alignment (dr, loop_vinfo))\n+\treturn false;\n     }\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_datarefs); i++)\n     {\n       struct data_reference *dr = VARRAY_GENERIC_PTR (loop_read_datarefs, i);\n-      vect_compute_data_ref_alignment (dr, loop_vinfo);\n+      if (!vect_compute_data_ref_alignment (dr, loop_vinfo))\n+\treturn false;\n     }\n+\n+  return true;\n }\n \n \n@@ -4295,8 +4325,13 @@ vect_compute_data_refs_alignment (loop_vec_info loop_vinfo)\n    FOR NOW: No transformation is actually performed. TODO.  */\n \n static void\n-vect_enhance_data_refs_alignment (loop_vec_info loop_info ATTRIBUTE_UNUSED)\n+vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n+  varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n+  varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  unsigned int i;\n+\n   /*\n      This pass will require a cost model to guide it whether to apply peeling \n      or versioning or a combination of the two. For example, the scheme that\n@@ -4379,6 +4414,76 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_info ATTRIBUTE_UNUSED)\n      (whether to generate regular loads/stores, or with special handling for \n      misalignment). \n    */\n+\n+  /* (1) Peeling to force alignment.  */\n+\n+  /* (1.1) Decide whether to perform peeling, and how many iterations to peel:\n+     Considerations:\n+     + How many accesses will become aligned due to the peeling\n+     - How many accesses will become unaligned due to the peeling,\n+       and the cost of misaligned accesses.\n+     - The cost of peeling (the extra runtime checks, the increase \n+       in code size).\n+\n+     The scheme we use FORNOW: peel to force the alignment of the first\n+     misaliged store in the loop.\n+     Rationale: misaligned store are not yet supported.\n+\n+     TODO: Use a better cost model.  */\n+\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n+    {\n+      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n+      if (!aligned_access_p (dr))\n+        {\n+          LOOP_VINFO_UNALIGNED_DR (loop_vinfo) = dr;\n+          LOOP_DO_PEELING_FOR_ALIGNMENT (loop_vinfo) = true;\n+\t  break;\n+        }\n+    }\n+\n+  if (!LOOP_VINFO_UNALIGNED_DR (loop_vinfo))\n+    {\n+      if (vect_debug_details (loop))\n+\tfprintf (dump_file, \"Peeling for alignment will not be applied.\");\n+      return;\n+    }\n+  else\n+    if (vect_debug_details (loop))\n+      fprintf (dump_file, \"Peeling for alignment will be applied.\");\n+\n+\n+  /* (1.2) Update the alignment info according to the peeling factor.\n+\t   If the misalignment of the DR we peel for is M, then the\n+\t   peeling factor is VF - M, and the misalignment of each access DR_i\n+\t   in the loop is DR_MISALIGNMENT (DR_i) + VF - M.\n+\t   If the misalignment of the DR we peel for is unknown, then the \n+\t   misalignment of each access DR_i in the loop is also unknown.\n+\n+\t   FORNOW: set the misalignment of the accesses to unknown even\n+\t           if the peeling factor is known at compile time.\n+\n+\t   TODO: - if the peeling factor is known at compile time, use that\n+\t\t   when updating the misalignment info of the loop DRs.\n+\t\t - consider accesses that are known to have the same \n+\t\t   alignment, even if that alignment is unknown.  */\n+   \n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n+    {\n+      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n+      if (dr == LOOP_VINFO_UNALIGNED_DR (loop_vinfo))\n+\tDR_MISALIGNMENT (dr) = 0;\n+      else\n+\tDR_MISALIGNMENT (dr) = -1;\n+    }\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_datarefs); i++)\n+    {\n+      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_read_datarefs, i);\n+      if (dr == LOOP_VINFO_UNALIGNED_DR (loop_vinfo))\n+\tDR_MISALIGNMENT (dr) = 0;\n+      else\n+\tDR_MISALIGNMENT (dr) = -1;\n+    }\n }\n \n \n@@ -4392,12 +4497,11 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_info ATTRIBUTE_UNUSED)\n static bool\n vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n+  varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n   varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  /*varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);*/\n-\n+  enum dr_alignment_support supportable_dr_alignment;\n   unsigned int i;\n-  unsigned int decide_peeling_count = 0;\n \n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"\\n<<vect_analyze_data_refs_alignment>>\\n\");\n@@ -4406,67 +4510,46 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n   /* This pass may take place at function granularity instead of at loop\n      granularity.  */\n \n-  vect_compute_data_refs_alignment (loop_vinfo);\n+  if (!vect_compute_data_refs_alignment (loop_vinfo))\n+    {\n+      if (vect_debug_details (loop) || vect_debug_stats (loop))\n+\tfprintf (dump_file, \n+\t\t \"not vectorized: can't calculate alignment for data ref.\");\n+      return false;\n+    }\n \n \n-  /* This pass will use loop versioning and loop peeling in order to enhance\n-     the alignment of data references in the loop.\n-     FOR NOW: we assume that whatever versioning/peeling took place, the \n-     original loop is to be vectorized. Any other loops that were created by\n-     the transformations performed in this pass - are not supposed to be \n-     vectorized. This restriction will be relaxed.  */\n+  /* This pass will decide on using loop versioning and/or loop peeling in \n+     order to enhance the alignment of data references in the loop.  */\n \n   vect_enhance_data_refs_alignment (loop_vinfo);\n \n \n-  /* Finally, check that loop can be vectorized. \n-     FOR NOW: Until support for misaligned stores is in place, only if all\n-     stores are aligned can the loop be vectorized.  This restriction will be \n-     relaxed.  In the meantime, we can force the alignment of on of the\n-     data-references in the loop using peeling.  We currently use a heuristic \n-     that peels the first misaligned store, but we plan to develop a \n-     better cost model to guide the decision on which data-access to peel for.\n-   */\n+  /* Finally, check that all the data references in the loop can be\n+     handled with respect to their alignment.  */\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_datarefs); i++)\n     {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n-      if (!aligned_access_p (dr))\n+      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_read_datarefs, i);\n+      supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n+      if (!supportable_dr_alignment)\n \t{\n-\t  /* Decide here whether we need peeling for alignment.  */\n-\t  decide_peeling_count++;\n-\t  if (decide_peeling_count > MAX_NUMBER_OF_UNALIGNED_DATA_REFS)\n-\t    {\n-\t      if (vect_debug_stats (loop) || vect_debug_details (loop))\n-\t\tfprintf (dump_file, \n-\t\t\t \"not vectorized: multiple misaligned stores.\");\n-\t      return false;\n-\t    }\n-\t  else\n-\t    {\n-\t      LOOP_UNALIGNED_DR (loop_vinfo, decide_peeling_count - 1) = dr;\n-\t      LOOP_DO_PEELING_FOR_ALIGNMENT (loop_vinfo) = true;\n-\t    }\n+\t  if (vect_debug_details (loop) || vect_debug_stats (loop))\n+\t    fprintf (dump_file, \"not vectorized: unsupported unaligned load.\");\n+\t  return false;\n \t}\n     }\n-\n-  /* The vectorizer now supports misaligned loads, so we don't fail anymore\n-     in the presence of a misaligned read dataref.  For some targets however\n-     it may be preferable not to vectorize in such a case as misaligned\n-     accesses are very costly.  This should be considered in the future.  */\n-/*\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_datarefs); i++)\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n     {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_read_datarefs, i);\n-      if (!aligned_access_p (dr))\n+      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n+      supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n+      if (!supportable_dr_alignment)\n \t{\n-\t  if (vect_debug_stats (LOOP_VINFO_LOOP (loop_vinfo))\n-\t      || vect_debug_details (LOOP_VINFO_LOOP (loop_vinfo)))\n-\t    fprintf (dump_file, \"not vectorized: unaligned load.\");\n+\t  if (vect_debug_details (loop) || vect_debug_stats (loop))\n+\t    fprintf (dump_file, \"not vectorized: unsupported unaligned store.\");\n \t  return false;\n \t}\n     }\n-*/\n \n   return true;\n }"}, {"sha": "20563afc625b600621047dfc70bf8637b5728208", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc0a70b2fd4796405a68e8102a3bc6bf58eea6f/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc0a70b2fd4796405a68e8102a3bc6bf58eea6f/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=0dc0a70b2fd4796405a68e8102a3bc6bf58eea6f", "patch": "@@ -34,6 +34,14 @@ enum operation_type {\n   binary_op\n };\n \n+/* Define type of available alignment support.  */\n+enum dr_alignment_support {\n+  dr_unaligned_unsupported,\n+  dr_unaligned_supported,\n+  dr_unaligned_software_pipeline,\n+  dr_aligned\n+};\n+\n /*-----------------------------------------------------------------*/\n /* Info on vectorized defs.                                        */\n /*-----------------------------------------------------------------*/\n@@ -121,7 +129,6 @@ vinfo_for_stmt (tree stmt)\n \n /* The misalignment of the memory access in bytes.  */\n #define DR_MISALIGNMENT(DR)   (DR)->aux\n-#define MAX_NUMBER_OF_UNALIGNED_DATA_REFS 1\n \n static inline bool\n aligned_access_p (struct data_reference *data_ref_info)\n@@ -163,7 +170,7 @@ typedef struct _loop_vec_info {\n   int vectorization_factor;\n \n   /* Unknown DRs according to which loop was peeled.  */\n-  struct data_reference *unaligned_drs [MAX_NUMBER_OF_UNALIGNED_DATA_REFS];\n+  struct data_reference *unaligned_dr;\n \n   /* If true, loop is peeled.\n    unaligned_drs show in this case DRs used for peeling.  */\n@@ -187,7 +194,7 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_DATAREF_READS(L)  (L)->data_ref_reads\n #define LOOP_VINFO_INT_NITERS(L) (TREE_INT_CST_LOW ((L)->num_iters))       \n #define LOOP_DO_PEELING_FOR_ALIGNMENT(L) (L)->do_peeling_for_alignment\n-#define LOOP_UNALIGNED_DR(L, I)      (L)->unaligned_drs[(I)] \n+#define LOOP_VINFO_UNALIGNED_DR(L)       (L)->unaligned_dr\n   \n \n #define LOOP_VINFO_NITERS_KNOWN_P(L)                     \\"}]}