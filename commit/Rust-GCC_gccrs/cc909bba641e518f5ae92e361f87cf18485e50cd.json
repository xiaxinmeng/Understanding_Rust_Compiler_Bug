{"sha": "cc909bba641e518f5ae92e361f87cf18485e50cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M5MDliYmE2NDFlNTE4ZjVhZTkyZTM2MWY4N2NmMTg0ODVlNTBjZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-11T18:17:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-11T18:17:25Z"}, "message": "mn10300: Emit the movm stores in the correct order.\n\nFrom-SVN: r168671", "tree": {"sha": "5e764fef329e6fc657843ddc30e1005474f0198c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e764fef329e6fc657843ddc30e1005474f0198c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc909bba641e518f5ae92e361f87cf18485e50cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc909bba641e518f5ae92e361f87cf18485e50cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc909bba641e518f5ae92e361f87cf18485e50cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc909bba641e518f5ae92e361f87cf18485e50cd/comments", "author": null, "committer": null, "parents": [{"sha": "e3b5c2f3eaf597e07230115244718b99f6ed050b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3b5c2f3eaf597e07230115244718b99f6ed050b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3b5c2f3eaf597e07230115244718b99f6ed050b"}], "stats": {"total": 117, "additions": 62, "deletions": 55}, "files": [{"sha": "46f5023a1200268868361a1eb9064e70b0ba064b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc909bba641e518f5ae92e361f87cf18485e50cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc909bba641e518f5ae92e361f87cf18485e50cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc909bba641e518f5ae92e361f87cf18485e50cd", "patch": "@@ -1,5 +1,11 @@\n 2011-01-11  Richard Henderson  <rth@redhat.com>\n \n+\t* config/mn10300/mn10300.c (mn10300_gen_multiple_store): Make static.\n+\tEmit register stores with the same offsets as the hardware.\n+\t(mn10300_store_multiple_operation): Don't check that the register\n+\tsave offsets are monotonic.\n+\t* config/mn10300/mn10300-protos.h: Update.\n+\n \t* config/mn10300/mn10300.h (ASM_PN_FORMAT): Delete.\n \n \t* config/mn10300/mn10300.h (INCOMING_RETURN_ADDR_RTX): Define"}, {"sha": "d787dcbfa4fdc16675891a19b9150b4c3b89816b", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc909bba641e518f5ae92e361f87cf18485e50cd/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc909bba641e518f5ae92e361f87cf18485e50cd/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=cc909bba641e518f5ae92e361f87cf18485e50cd", "patch": "@@ -27,7 +27,6 @@\n extern rtx   mn10300_legitimize_pic_address (rtx, rtx);\n extern int   mn10300_legitimate_pic_operand_p (rtx);\n extern bool  mn10300_function_value_regno_p (const unsigned int);\n-extern void  mn10300_gen_multiple_store (int);\n extern int   mn10300_get_live_callee_saved_regs (void);\n extern bool  mn10300_hard_regno_mode_ok (unsigned int, Mmode);\n extern bool  mn10300_legitimate_constant_p (rtx);"}, {"sha": "534ddaf48d322ca174921b58c1597abfcdc64bed", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 56, "deletions": 54, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc909bba641e518f5ae92e361f87cf18485e50cd/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc909bba641e518f5ae92e361f87cf18485e50cd/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=cc909bba641e518f5ae92e361f87cf18485e50cd", "patch": "@@ -689,51 +689,61 @@ F (rtx r)\n \t                       (const_int -N*4)))\n \t      (reg:SI R1))) */\n \n-void\n-mn10300_gen_multiple_store (int mask)\n+static void\n+mn10300_gen_multiple_store (unsigned int mask)\n {\n-  if (mask != 0)\n+  /* The order in which registers are stored, from SP-4 through SP-N*4.  */\n+  static const unsigned int store_order[8] = {\n+    /* e2, e3: never saved */\n+    FIRST_EXTENDED_REGNUM + 4,\n+    FIRST_EXTENDED_REGNUM + 5,\n+    FIRST_EXTENDED_REGNUM + 6,\n+    FIRST_EXTENDED_REGNUM + 7,\n+    /* e0, e1, mdrq, mcrh, mcrl, mcvf: never saved. */\n+    FIRST_DATA_REGNUM + 2,\n+    FIRST_DATA_REGNUM + 3,\n+    FIRST_ADDRESS_REGNUM + 2,\n+    FIRST_ADDRESS_REGNUM + 3,\n+    /* d0, d1, a0, a1, mdr, lir, lar: never saved.  */\n+  };\n+\n+  rtx x, elts[9];\n+  unsigned int i;\n+  int count;\n+\n+  if (mask == 0)\n+    return;\n+\n+  for (i = count = 0; i < ARRAY_SIZE(store_order); ++i)\n     {\n-      int i;\n-      int count;\n-      rtx par;\n-      int pari;\n-\n-      /* Count how many registers need to be saved.  */\n-      count = 0;\n-      for (i = 0; i <= LAST_EXTENDED_REGNUM; i++)\n-\tif ((mask & (1 << i)) != 0)\n-\t  count += 1;\n-\n-      /* We need one PARALLEL element to update the stack pointer and\n-\t an additional element for each register that is stored.  */\n-      par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + 1));\n-\n-      /* Create the instruction that updates the stack pointer.  */\n-      XVECEXP (par, 0, 0)\n-\t= F (gen_rtx_SET (SImode,\n-\t\t\t  stack_pointer_rtx,\n-\t\t\t  gen_rtx_PLUS (SImode,\n-\t\t\t\t\tstack_pointer_rtx,\n-\t\t\t\t\tGEN_INT (-count * 4))));\n-\n-      /* Create each store.  */\n-      pari = 1;\n-      for (i = LAST_EXTENDED_REGNUM; i >= 0; i--)\n-\tif ((mask & (1 << i)) != 0)\n-\t  {\n-\t    rtx address = gen_rtx_PLUS (SImode,\n-\t\t\t\t\tstack_pointer_rtx,\n-\t\t\t\t\tGEN_INT (-pari * 4));\n-\t    XVECEXP(par, 0, pari)\n-\t      = F (gen_rtx_SET (VOIDmode,\n-\t\t\t\tgen_rtx_MEM (SImode, address),\n-\t\t\t\tgen_rtx_REG (SImode, i)));\n-\t    pari += 1;\n-\t  }\n+      unsigned regno = store_order[i];\n+\n+      if (((mask >> regno) & 1) == 0)\n+\tcontinue;\n+\n+      ++count;\n+      x = plus_constant (stack_pointer_rtx, count * -4);\n+      x = gen_frame_mem (SImode, x);\n+      x = gen_rtx_SET (VOIDmode, x, gen_rtx_REG (SImode, regno));\n+      elts[count] = F(x);\n \n-      F (emit_insn (par));\n+      /* Remove the register from the mask so that... */\n+      mask &= ~(1u << regno);\n     }\n+\n+  /* ... we can make sure that we didn't try to use a register\n+     not listed in the store order.  */\n+  gcc_assert (mask == 0);\n+\n+  /* Create the instruction that updates the stack pointer.  */\n+  x = plus_constant (stack_pointer_rtx, count * -4);\n+  x = gen_rtx_SET (VOIDmode, stack_pointer_rtx, x);\n+  elts[0] = F(x);\n+\n+  /* We need one PARALLEL element to update the stack pointer and\n+     an additional element for each register that is stored.  */\n+  x = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (count + 1, elts));\n+  F (emit_insn (x));\n }\n \n void\n@@ -1273,27 +1283,19 @@ mn10300_store_multiple_operation (rtx op,\n       || INTVAL (XEXP (elt, 1)) != -(count - 1) * 4)\n     return 0;\n \n-  /* Now go through the rest of the vector elements.  They must be\n-     ordered so that the first instruction stores the highest-numbered\n-     register to the highest stack slot and that subsequent instructions\n-     store a lower-numbered register to the slot below.\n-\n-     LAST keeps track of the smallest-numbered register stored so far.\n-     MASK is the set of stored registers.  */\n-  last = LAST_EXTENDED_REGNUM + 1;\n   mask = 0;\n   for (i = 1; i < count; i++)\n     {\n-      /* Check that element i is a (set (mem M) R) and that R is valid.  */\n+      /* Check that element i is a (set (mem M) R).  */\n+      /* ??? Validate the register order a-la mn10300_gen_multiple_store.\n+\t Remember: the ordering is *not* monotonic.  */\n       elt = XVECEXP (op, 0, i);\n       if (GET_CODE (elt) != SET\n \t  || (! MEM_P (SET_DEST (elt)))\n-\t  || (! REG_P (SET_SRC (elt)))\n-\t  || REGNO (SET_SRC (elt)) >= last)\n+\t  || (! REG_P (SET_SRC (elt))))\n \treturn 0;\n \n-      /* R was OK, so provisionally add it to MASK.  We return 0 in any\n-\t case if the rest of the instruction has a flaw.  */\n+      /* Remember which registers are to be saved.  */\n       last = REGNO (SET_SRC (elt));\n       mask |= (1 << last);\n "}]}