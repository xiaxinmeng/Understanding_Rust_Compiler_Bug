{"sha": "11e74ea6c6c709e8e6329bdfe7d121bfa100cf29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFlNzRlYTZjNmM3MDllOGU2MzI5YmRmZTdkMTIxYmZhMTAwY2YyOQ==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2001-10-13T13:24:34Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2001-10-13T13:24:34Z"}, "message": "cp-tree.h (TYPE_BINFO): Update comment.\n\n\t* cp-tree.h (TYPE_BINFO): Update comment.\n\t(BOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK): New macro.\n\t(TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO): Use template_info.\n\t(TYPENAME_TYPE_FULLNAME): Use TYPE_FIELDS.\n\t(copy_type): Prototype new function.\n\t* lex.c (copy_lang_decl): Gather tree node statistics.\n\t(copy_lang_type): New function.\n\t(copy_type): Likewise.\n\t(cp_make_lang_type): Create lang_type for\n\tBOUND_TEMPLATE_TEMPLATE_PARM.  Set TYPE_BINFO for TYPENAME_TYPE\n\tand BOUND_TEMPLATE_TEMPLATE_PARM.\n\t* pt.c (tsubst): Use copy_type instead of copy_node.\n\t* search.c (lookup_field_1): Ignore TYPENAME_TYPE.\n\nFrom-SVN: r46244", "tree": {"sha": "8f939dad1cc78f6389ec45ed623f2d6ea2c80aa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f939dad1cc78f6389ec45ed623f2d6ea2c80aa6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29/comments", "author": null, "committer": null, "parents": [{"sha": "f5d47abdf7cebc497d2ee475dfc2e00e8125e879", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5d47abdf7cebc497d2ee475dfc2e00e8125e879", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5d47abdf7cebc497d2ee475dfc2e00e8125e879"}], "stats": {"total": 130, "additions": 112, "deletions": 18}, "files": [{"sha": "2b1b453526cb0cceb724c7d7844bfc386f480d93", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=11e74ea6c6c709e8e6329bdfe7d121bfa100cf29", "patch": "@@ -1,3 +1,19 @@\n+2001-10-12  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\t* cp-tree.h (TYPE_BINFO): Update comment.\n+\t(BOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK): New macro.\n+\t(TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO): Use template_info.\n+\t(TYPENAME_TYPE_FULLNAME): Use TYPE_FIELDS.\n+\t(copy_type): Prototype new function.\n+\t* lex.c (copy_lang_decl): Gather tree node statistics.\n+\t(copy_lang_type): New function.\n+\t(copy_type): Likewise.\n+\t(cp_make_lang_type): Create lang_type for\n+\tBOUND_TEMPLATE_TEMPLATE_PARM.  Set TYPE_BINFO for TYPENAME_TYPE\n+\tand BOUND_TEMPLATE_TEMPLATE_PARM.\n+\t* pt.c (tsubst): Use copy_type instead of copy_node.\n+\t* search.c (lookup_field_1): Ignore TYPENAME_TYPE.\n+\n 2001-10-12  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \t* pt.c (determine_specialization): Ignore functions without"}, {"sha": "34ef95a493a4da50b68acfeecfe3c1247f5d720b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=11e74ea6c6c709e8e6329bdfe7d121bfa100cf29", "patch": "@@ -114,9 +114,6 @@ Boston, MA 02111-1307, USA.  */\n \n    TYPE_BINFO\n      For an ENUMERAL_TYPE, this is ENUM_TEMPLATE_INFO.\n-     For a TYPENAME_TYPE, this is TYPENAME_TYPE_FULLNAME.\n-     For a TEMPLATE_TEMPLATE_PARM or BOUND_TEMPLATE_TEMPLATE_PARM,\n-     this is TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n      For a FUNCTION_TYPE or METHOD_TYPE, this is TYPE_RAISES_EXCEPTIONS\n \n   BINFO_VIRTUALS\n@@ -193,6 +190,14 @@ Boston, MA 02111-1307, USA.  */\n \t\t\t __FUNCTION__);\t\t\t\t\\\n     __t; })\n \n+#define BOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK(NODE)\t\t\\\n+({  const tree __t = NODE;\t\t\t\t\t\\\n+    enum tree_code __c = TREE_CODE(__t);\t\t\t\\\n+    if (__c != BOUND_TEMPLATE_TEMPLATE_PARM)\t\t\t\\\n+      tree_check_failed (__t, BOUND_TEMPLATE_TEMPLATE_PARM,\t\\\n+\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n+    __t; })\n+\n #else /* not ENABLE_TREE_CHECKING, or not gcc */\n \n #define VAR_OR_FUNCTION_DECL_CHECK(NODE)\tNODE\n@@ -2147,8 +2152,10 @@ struct lang_decl\n    non-type template parameters.  */\n #define ENUM_TEMPLATE_INFO(NODE) (TYPE_BINFO (ENUMERAL_TYPE_CHECK (NODE)))\n \n-/* Template information for a bound template template parameter.  */\n-#define TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO(NODE) (TYPE_BINFO (NODE))\n+/* Template information for a template template parameter.  */\n+#define TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO(NODE) \\\n+  (TYPE_LANG_SPECIFIC(BOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK (NODE)) \\\n+   ->template_info)\n \n /* Template information for an ENUMERAL_, RECORD_, or UNION_TYPE.  */\n #define TYPE_TEMPLATE_INFO(NODE)\t\t\t\\\n@@ -2311,7 +2318,7 @@ struct lang_decl\n    this is an IDENTIFIER_NODE, and the same as the DECL_NAME on the\n    corresponding TYPE_DECL.  However, this may also be a\n    TEMPLATE_ID_EXPR if we had something like `typename X::Y<T>'.  */\n-#define TYPENAME_TYPE_FULLNAME(NODE) TYPE_BINFO (NODE)\n+#define TYPENAME_TYPE_FULLNAME(NODE) (TYPE_FIELDS (NODE))\n \n /* Nonzero if NODE is an implicit typename.  */\n #define IMPLICIT_TYPENAME_P(NODE) \\\n@@ -3859,6 +3866,7 @@ extern tree identifier_typedecl_value\t\tPARAMS ((tree));\n extern tree build_lang_decl\t\t\tPARAMS ((enum tree_code, tree, tree));\n extern void retrofit_lang_decl\t\t\tPARAMS ((tree));\n extern tree copy_decl                           PARAMS ((tree));\n+extern tree copy_type                           PARAMS ((tree));\n extern tree cp_make_lang_type\t\t\tPARAMS ((enum tree_code));\n extern tree make_aggr_type\t\t\tPARAMS ((enum tree_code));\n extern void compiler_error\t\t\tPARAMS ((const char *, ...))"}, {"sha": "ec445663ddfd3f89c1d04c440b623eee63197b28", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=11e74ea6c6c709e8e6329bdfe7d121bfa100cf29", "patch": "@@ -1552,6 +1552,11 @@ copy_lang_decl (node)\n   ld = (struct lang_decl *) ggc_alloc (size);\n   memcpy (ld, DECL_LANG_SPECIFIC (node), size);\n   DECL_LANG_SPECIFIC (node) = ld;\n+\n+#ifdef GATHER_STATISTICS\n+  tree_node_counts[(int)lang_decl] += 1;\n+  tree_node_sizes[(int)lang_decl] += size;\n+#endif\n }\n \n /* Copy DECL, including any language-specific parts.  */\n@@ -1567,33 +1572,75 @@ copy_decl (decl)\n   return copy;\n }\n \n+/* Replace the shared language-specific parts of NODE with a new copy.  */\n+\n+void\n+copy_lang_type (node)\n+     tree node;\n+{\n+  int size;\n+  struct lang_type *lt;\n+\n+  if (! TYPE_LANG_SPECIFIC (node))\n+    return;\n+\n+  size = sizeof (struct lang_type);\n+  lt = (struct lang_type *) ggc_alloc (size);\n+  memcpy (lt, TYPE_LANG_SPECIFIC (node), size);\n+  TYPE_LANG_SPECIFIC (node) = lt;\n+\n+#ifdef GATHER_STATISTICS\n+  tree_node_counts[(int)lang_type] += 1;\n+  tree_node_sizes[(int)lang_type] += size;\n+#endif\n+}\n+\n+/* Copy TYPE, including any language-specific parts.  */\n+\n+tree\n+copy_type (type)\n+     tree type;\n+{\n+  tree copy;\n+\n+  copy = copy_node (type);\n+  copy_lang_type (copy);\n+  return copy;\n+}\n+\n tree\n cp_make_lang_type (code)\n      enum tree_code code;\n {\n   register tree t = make_node (code);\n \n-  /* Set up some flags that give proper default behavior.  */\n-  if (IS_AGGR_TYPE_CODE (code))\n+  /* Create lang_type structure.  */\n+  if (IS_AGGR_TYPE_CODE (code)\n+      || code == BOUND_TEMPLATE_TEMPLATE_PARM)\n     {\n       struct lang_type *pi;\n \n       pi = ((struct lang_type *)\n \t    ggc_alloc_cleared (sizeof (struct lang_type)));\n \n       TYPE_LANG_SPECIFIC (t) = pi;\n+\n+#ifdef GATHER_STATISTICS\n+      tree_node_counts[(int)lang_type] += 1;\n+      tree_node_sizes[(int)lang_type] += sizeof (struct lang_type);\n+#endif\n+    }\n+\n+  /* Set up some flags that give proper default behavior.  */\n+  if (IS_AGGR_TYPE_CODE (code))\n+    {\n       SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, interface_unknown);\n       CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n \n       /* Make sure this is laid out, for ease of use later.  In the\n \t presence of parse errors, the normal was of assuring this\n \t might not ever get executed, so we lay it out *immediately*.  */\n       build_pointer_type (t);\n-\n-#ifdef GATHER_STATISTICS\n-      tree_node_counts[(int)lang_type] += 1;\n-      tree_node_sizes[(int)lang_type] += sizeof (struct lang_type);\n-#endif\n     }\n   else\n     /* We use TYPE_ALIAS_SET for the CLASSTYPE_MARKED bits.  But,\n@@ -1605,7 +1652,9 @@ cp_make_lang_type (code)\n      since they can be virtual base types, and we then need a\n      canonical binfo for them.  Ideally, this would be done lazily for\n      all types.  */\n-  if (IS_AGGR_TYPE_CODE (code) || code == TEMPLATE_TYPE_PARM)\n+  if (IS_AGGR_TYPE_CODE (code) || code == TEMPLATE_TYPE_PARM\n+      || code == BOUND_TEMPLATE_TEMPLATE_PARM\n+      || code == TYPENAME_TYPE)\n     TYPE_BINFO (t) = make_binfo (size_zero_node, t, NULL_TREE, NULL_TREE);\n \n   return t;"}, {"sha": "cd68629ab9284060124d8d57d991883489ae88ba", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=11e74ea6c6c709e8e6329bdfe7d121bfa100cf29", "patch": "@@ -6429,7 +6429,7 @@ tsubst (t, args, complain, in_decl)\n \t      }\n \t    else\n \t      {\n-\t\tr = copy_node (t);\n+\t\tr = copy_type (t);\n \t\tTEMPLATE_TYPE_PARM_INDEX (r)\n \t\t  = reduce_template_parm_level (TEMPLATE_TYPE_PARM_INDEX (t),\n \t\t\t\t\t\tr, levels);"}, {"sha": "4c3249b2fffd9f4bdf0dda4ee3993d545b0b984f", "filename": "gcc/cp/search.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=11e74ea6c6c709e8e6329bdfe7d121bfa100cf29", "patch": "@@ -564,11 +564,14 @@ lookup_field_1 (type, name)\n   register tree field;\n \n   if (TREE_CODE (type) == TEMPLATE_TYPE_PARM\n-      || TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM)\n-    /* The TYPE_FIELDS of a TEMPLATE_TYPE_PARM are not fields at all;\n+      || TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM\n+      || TREE_CODE (type) == TYPENAME_TYPE)\n+    /* The TYPE_FIELDS of a TEMPLATE_TYPE_PARM and \n+       BOUND_TEMPLATE_TEMPLATE_PARM are not fields at all;\n        instead TYPE_FIELDS is the TEMPLATE_PARM_INDEX.  (Miraculously,\n        the code often worked even when we treated the index as a list\n-       of fields!)  */\n+       of fields!)\n+       The TYPE_FIELDS of TYPENAME_TYPE is its TYPENAME_TYPE_FULLNAME.  */\n     return NULL_TREE;\n \n   if (TYPE_NAME (type)"}, {"sha": "7b323028ec508e297bdfd708d38f3aef607c1b5e", "filename": "gcc/testsuite/g++.dg/template/ttp1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp1.C?ref=11e74ea6c6c709e8e6329bdfe7d121bfa100cf29", "patch": "@@ -0,0 +1,9 @@\n+// Origin: Volker Reichelt <reichelt@igpm.rwth-aachen.de>\n+// { dg-do compile }\n+\n+template <template <typename T> class A >\n+class B : virtual A<void>\n+{\n+\ttypedef int INT;\n+\tINT i;\n+};"}, {"sha": "86658c5f995e783bda8fac666dd1d14b1fc17a2d", "filename": "gcc/testsuite/g++.dg/template/typename1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11e74ea6c6c709e8e6329bdfe7d121bfa100cf29/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename1.C?ref=11e74ea6c6c709e8e6329bdfe7d121bfa100cf29", "patch": "@@ -0,0 +1,9 @@\n+// Origin: Volker Reichelt <reichelt@igpm.rwth-aachen.de>\n+// { dg-do compile }\n+\n+template <class T>\n+class B : virtual T::A\n+{\n+\ttypedef int INT;\n+\tINT i;\n+};"}]}