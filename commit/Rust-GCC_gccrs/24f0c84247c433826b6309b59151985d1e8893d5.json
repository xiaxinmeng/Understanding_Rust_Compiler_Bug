{"sha": "24f0c84247c433826b6309b59151985d1e8893d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRmMGM4NDI0N2M0MzM4MjZiNjMwOWI1OTE1MTk4NWQxZTg4OTNkNQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-02-26T17:27:36Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-02-26T17:27:36Z"}, "message": "Remove a legacy lto-symtab.c file.\n\n2019-02-26  Martin Liska  <mliska@suse.cz>\n\n\t* lto-symtab.c: Remove.\n\nFrom-SVN: r269220", "tree": {"sha": "01a90dc3632a16096c36cc2627f5ff9b34d0adf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01a90dc3632a16096c36cc2627f5ff9b34d0adf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24f0c84247c433826b6309b59151985d1e8893d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24f0c84247c433826b6309b59151985d1e8893d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24f0c84247c433826b6309b59151985d1e8893d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24f0c84247c433826b6309b59151985d1e8893d5/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "062937663cd60daaf67599a7f8fcbed21636b111", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/062937663cd60daaf67599a7f8fcbed21636b111", "html_url": "https://github.com/Rust-GCC/gccrs/commit/062937663cd60daaf67599a7f8fcbed21636b111"}], "stats": {"total": 363, "additions": 4, "deletions": 359}, "files": [{"sha": "8ddccbecf38465eebb4e9e43423cb39c93b4c0df", "filename": "lto-plugin/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24f0c84247c433826b6309b59151985d1e8893d5/lto-plugin%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24f0c84247c433826b6309b59151985d1e8893d5/lto-plugin%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2FChangeLog?ref=24f0c84247c433826b6309b59151985d1e8893d5", "patch": "@@ -1,3 +1,7 @@\n+2019-02-26  Martin Liska  <mliska@suse.cz>\n+\n+\t* lto-symtab.c: Remove.\n+\n 2019-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "22b3af6027b819508d64227801551bce87e73ca0", "filename": "lto-plugin/lto-symtab.c", "status": "removed", "additions": 0, "deletions": 359, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062937663cd60daaf67599a7f8fcbed21636b111/lto-plugin%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062937663cd60daaf67599a7f8fcbed21636b111/lto-plugin%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2Flto-symtab.c?ref=062937663cd60daaf67599a7f8fcbed21636b111", "patch": "@@ -1,359 +0,0 @@\n-/* Program to read the IL symbol table.\n-   Copyright (C) 2008-2019 Free Software Foundation, Inc.\n-   Contributed by Rafael Avila de Espindola (espindola@google.com).\n-\n-This program is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3 of the License, or\n-(at your option) any later version.\n-\n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; if not, write to the Free Software\n-Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */\n-\n-#include <fcntl.h>\n-#include <assert.h>\n-#include <dlfcn.h>\n-#include <stdio.h>\n-#include <inttypes.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#include \"plugin-api.h\"\n-#include \"../gcc/lto/common.h\"\n-\n-/* The presence of gelf.h is checked by the toplevel configure script.  */\n-# include <gelf.h>\n-\n-static ld_plugin_claim_file_handler claim_file_handler;\n-static ld_plugin_all_symbols_read_handler all_symbols_read_handler;\n-static ld_plugin_cleanup_handler cleanup_handler;\n-static void *plugin_handle;\n-\n-struct file_handle {\n-  unsigned nsyms;\n-  struct ld_plugin_symbol *syms;\n-};\n-\n-static struct file_handle **all_file_handles = NULL;\n-static unsigned int num_file_handles;\n-\n-/* Write NSYMS symbols from file HANDLE in SYMS. */\n-\n-static enum ld_plugin_status\n-get_symbols (const void *handle, int nsyms, struct ld_plugin_symbol *syms)\n-{\n-  unsigned i;\n-  struct file_handle *h = (struct file_handle *) handle;\n-  assert (h->nsyms == nsyms);\n-\n-  for (i = 0; i < nsyms; i++)\n-    syms[i] = h->syms[i];\n-\n-  return LDPS_OK;\n-}\n-\n-/* Register HANDLER as the callback for notifying the plugin that all symbols\n-   have been read. */\n-\n-static enum ld_plugin_status\n-register_all_symbols_read (ld_plugin_all_symbols_read_handler handler)\n-{\n-  all_symbols_read_handler = handler;\n-  return LDPS_OK;\n-}\n-\n-/* Register HANDLER as the callback for claiming a file. */\n-\n-static enum ld_plugin_status\n-register_claim_file(ld_plugin_claim_file_handler handler)\n-{\n-  claim_file_handler = handler;\n-  return LDPS_OK;\n-}\n-\n-/* Register HANDLER as the callback to removing temporary files. */\n-\n-static enum ld_plugin_status\n-register_cleanup (ld_plugin_cleanup_handler handler)\n-{\n-  cleanup_handler = handler;\n-  return LDPS_OK;\n-}\n-\n-/* For a file identified by HANDLE, add NSYMS symbols from SYMS. */\n-\n-static enum ld_plugin_status\n-add_symbols (void *handle, int nsyms,\n-\t     const struct ld_plugin_symbol *syms)\n-{\n-  int i;\n-  struct file_handle *h = (struct file_handle *) handle;\n-  h->nsyms = nsyms;\n-  h->syms = calloc (nsyms, sizeof (struct ld_plugin_symbol));\n-  assert (h->syms);\n-\n-  for (i = 0; i < nsyms; i++)\n-    {\n-      h->syms[i] = syms[i];\n-      h->syms[i].name = strdup (h->syms[i].name);\n-      if (h->syms[i].version)\n-\th->syms[i].version = strdup (h->syms[i].version);\n-      if (h->syms[i].comdat_key)\n-\th->syms[i].comdat_key = strdup (h->syms[i].comdat_key);\n-    }\n-\n-  return LDPS_OK;\n-}\n-\n-struct ld_plugin_tv tv[] = {\n-  {LDPT_REGISTER_CLAIM_FILE_HOOK,\n-   {.tv_register_claim_file = register_claim_file}\n-  },\n-  {LDPT_ADD_SYMBOLS,\n-   {.tv_add_symbols = add_symbols}\n-  },\n-\n-  {LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK,\n-   {.tv_register_all_symbols_read = register_all_symbols_read}\n-  },\n-  {LDPT_GET_SYMBOLS,\n-   {.tv_get_symbols = get_symbols}\n-  },\n-  {LDPT_REGISTER_CLEANUP_HOOK,\n-   {.tv_register_cleanup = register_cleanup}\n-  },\n-  {0, {0}}\n-};\n-\n-/* Load a plugin from a file named NAME. */\n-\n-static void\n-load_plugin (const char *name)\n-{\n-  ld_plugin_onload onload;\n-  plugin_handle = dlopen (name, RTLD_LAZY);\n-\n-  assert (plugin_handle != NULL);\n-  onload = dlsym (plugin_handle, \"onload\");\n-  assert (onload);\n-  onload (tv);\n-  assert (claim_file_handler);\n-}\n-\n-/* Send object to the plugin. The file (archive or object) name is NAME.\n-   FD is an open file descriptor. The object data starts at OFFSET and is\n-   FILESIZE bytes long. */\n-\n-static void\n-register_object (const char *name, int fd, off_t offset, off_t filesize)\n-{\n-  int claimed;\n-  struct ld_plugin_input_file file;\n-  void *handle;\n-\n-  num_file_handles++;\n-  all_file_handles = realloc (all_file_handles, num_file_handles\n-\t\t\t      * sizeof (struct file_handle *));\n-  assert (all_file_handles);\n-\n-  all_file_handles[num_file_handles - 1] = calloc (1,\n-\t\t\t\t\t\t   sizeof (struct file_handle));\n-  handle = all_file_handles[num_file_handles - 1];\n-  assert (handle);\n-\n-  file.name = (char *) name;\n-  file.fd = fd;\n-  file.offset = offset;\n-  file.filesize = filesize;\n-\n-  file.handle = handle;\n-\n-  claim_file_handler (&file, &claimed);\n-}\n-\n-/* Send file named NAME to the plugin. */\n-\n-static void\n-register_file (const char *name)\n-{\n- int fd = open (name, O_RDONLY);\n- Elf *elf;\n-\n- assert (fd >= 0);\n-\n- elf = elf_begin (fd, ELF_C_READ, NULL);\n- assert (elf);\n-\n- Elf_Kind kind = elf_kind (elf);\n-\n- assert (kind == ELF_K_ELF || kind == ELF_K_AR);\n-\n- if (kind == ELF_K_AR)\n-   {\n-     Elf *member = elf_begin (fd, ELF_C_READ, elf);\n-     while (member)\n-       {\n-\t Elf_Arhdr *h = elf_getarhdr (member);\n-\t assert (h);\n-\n-\t if (h->ar_name[0] != '/')\n-\t   {\n-\t     off_t offset = elf_getbase (member);\n-\t     register_object (name, fd, offset, h->ar_size);\n-\t   }\n-\n-\t Elf_Cmd cmd = elf_next (member);\n-\t elf_end (member);\n-\t member = elf_begin (fd, cmd, elf);\n-       }\n-   }\n- else /* Single File */\n-   register_object (name, fd, 0, 0);\n-\n- elf_end (elf);\n-}\n-\n-/* Fake symbol resolution for testing. */\n-\n-static void\n-resolve (void)\n-{\n-  unsigned j;\n-  for (j = 0; j < num_file_handles; j++)\n-    {\n-      struct file_handle *handle = all_file_handles[j];\n-      unsigned int nsyms = handle->nsyms;\n-      struct ld_plugin_symbol *syms = handle->syms;\n-      unsigned i;\n-      for (i = 0; i < nsyms; i++)\n-\t{\n-\t  switch (syms[i].def)\n-\t    {\n-\t    case LDPK_DEF:\n-\t    case LDPK_WEAKDEF:\n-\t    case LDPK_COMMON:\n-\t      syms[i].resolution =  LDPR_PREVAILING_DEF;\n-\t      break;\n-\t    case LDPK_UNDEF:\n-\t    case LDPK_WEAKUNDEF:\n-\t      syms[i].resolution =  LDPR_RESOLVED_IR;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Print all symbol information. */\n-\n-static void\n-print (void)\n-{\n-  unsigned j;\n-  for (j = 0; j < num_file_handles; j++)\n-    {\n-      struct file_handle *handle = all_file_handles[j];\n-      unsigned int nsyms = handle->nsyms;\n-      struct ld_plugin_symbol *syms = handle->syms;\n-      unsigned i;\n-      for (i = 0; i < nsyms; i++)\n-\t{\n-\t  printf(\"name: %s; \", syms[i].name);\n-\t  if (syms[i].version)\n-\t     printf(\"version: %s;\", syms[i].version);\n-\t  else\n-\t    printf(\"not versioned; \");\n-\t  printf(\"kind: %s; \", lto_kind_str[syms[i].def]);\n-\t  printf(\"visibility: %s; \", lto_visibility_str[syms[i].visibility]);\n-\t  printf(\"size: %\" PRId64 \"; \", syms[i].size);\n-\t  if (syms[i].comdat_key)\n-\t    printf(\"comdat_key: %s; \", syms[i].comdat_key);\n-\t  else\n-\t    printf(\"no comdat_key; \");\n-\t  printf (\"resolution: %s\\n\", lto_resolution_str[syms[i].resolution]);\n-\t}\n-    }\n-}\n-\n-/* Unload the plugin. */\n-\n-static void\n-unload_plugin (void)\n-{\n-  unsigned err = dlclose (plugin_handle);\n-  assert (err == 0);\n-  claim_file_handler = 0;\n-  all_symbols_read_handler = 0;\n-}\n-\n-/* Free all memory allocated by us that hasn't been freed yet. */\n-\n-static void\n-free_all (void)\n-{\n-  unsigned j;\n-  for (j = 0; j < num_file_handles; j++)\n-    {\n-      struct file_handle *handle = all_file_handles[j];\n-      unsigned int nsyms = handle->nsyms;\n-      struct ld_plugin_symbol *syms = handle->syms;\n-      unsigned i;\n-      for (i = 0; i < nsyms; i++)\n-\t{\n-\t  free (syms[i].name);\n-\t  syms[i].name = 0;\n-\t  if (syms[i].version)\n-\t    {\n-\t      free (syms[i].version);\n-\t      syms[i].version = 0;\n-\t    }\n-\t  if (syms[i].comdat_key)\n-\t    {\n-\t      free (syms[i].comdat_key);\n-\t      syms[i].comdat_key = 0;\n-\t    }\n-\t}\n-      free (syms);\n-      handle->syms = NULL;\n-      handle->nsyms = 0;\n-      free (all_file_handles[j]);\n-      all_file_handles[j] = NULL;\n-    }\n-\n-  free (all_file_handles);\n-  all_file_handles = NULL;\n-  num_file_handles = 0;\n-}\n-\n-int\n-main(int argc, char *argv[])\n-{\n-  const char *plugin;\n-  unsigned int i;\n-  assert (argc >= 3);\n-  plugin = argv[1];\n-\n-  load_plugin (plugin);\n-\n-  for (i = 2; i < argc; i++)\n-    register_file (argv[i]);\n-\n-  resolve ();\n-\n-  print ();\n-\n-  all_symbols_read_handler ();\n-\n-  free_all ();\n-\n-  cleanup_handler ();\n-\n-  unload_plugin ();\n-\n-  return 0;\n-}"}]}