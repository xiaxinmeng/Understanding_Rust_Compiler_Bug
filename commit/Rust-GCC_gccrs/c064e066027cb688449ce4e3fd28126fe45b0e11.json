{"sha": "c064e066027cb688449ce4e3fd28126fe45b0e11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA2NGUwNjYwMjdjYjY4ODQ0OWNlNGUzZmQyODEyNmZlNDViMGUxMQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T17:51:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:51:20Z"}, "message": "treepr.adb: Use new subtype N_Membership_Test\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* treepr.adb: Use new subtype N_Membership_Test\n\n        * checks.ads, checks.adb: Add definition for Validity_Check\n        (Range_Or_Validity_Checks_Suppressed): New function\n        (Ensure_Valid): Test Validity_Check suppressed\n        (Insert_Valid_Check): Test Validity_Check suppressed\n        (Insert_Valid_Check): Preserve Do_Range_Check flag\n\t(Validity_Check_Range): New procedure\n\t(Expr_Known_Valid): Result of membership test is always valid\n\t(Selected_Range_Checks): Range checks cannot be applied to discriminants\n\tby themselves. Disabling those checks must also be done for task types,\n\twhere discriminants may be used for the bounds of entry families.\n\t(Apply_Address_Clause_Check): Remove side-effects if address expression\n\tis non-static and is not the name of a declared constant.\n\t(Null_Exclusion_Static_Checks): Extend to handle Function_Specification.\n\tCode cleanup and new error messages.\n\t(Enable_Range_Check): Test for some cases of suppressed checks\n\t(Generate_Index_Checks): Suppress index checks if index checks are\n\tsuppressed for array object or array type.\n\t(Apply_Selected_Length_Checks): Give warning for compile-time detected\n\tlength check failure, even if checks are off.\n\t(Ensure_Valid): Do not generate a check on an indexed component whose\n\tprefix is a packed boolean array.\n\t* checks.adb: (Alignment_Checks_Suppressed): New function\n\t(Apply_Address_Clause_Check): New procedure, this is a completely\n\trewritten replacement for Apply_Alignment_Check\n\t(Get_E_Length/Get_E_First_Or_Last): Add missing barrier to ensure that\n\twe request a discriminal value only in case of discriminants.\n\t(Apply_Discriminant_Check): For Ada_05, only call Get_Actual_Subtype for\n\tassignments where the target subtype is unconstrained and the target\n\tobject is a parameter or dereference (other aliased cases are known\n\tto be unconstrained).\n\nFrom-SVN: r118248", "tree": {"sha": "8695b73eb0545f93e05e9fec3f16298bdbf07da0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8695b73eb0545f93e05e9fec3f16298bdbf07da0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c064e066027cb688449ce4e3fd28126fe45b0e11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c064e066027cb688449ce4e3fd28126fe45b0e11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c064e066027cb688449ce4e3fd28126fe45b0e11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c064e066027cb688449ce4e3fd28126fe45b0e11/comments", "author": null, "committer": null, "parents": [{"sha": "ff9625b0fa07810acdae6d36dbaca8f5afef9d05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff9625b0fa07810acdae6d36dbaca8f5afef9d05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff9625b0fa07810acdae6d36dbaca8f5afef9d05"}], "stats": {"total": 829, "additions": 610, "deletions": 219}, "files": [{"sha": "b5b30f79180c41a9a4db3a654a95047c5c18cec9", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 587, "deletions": 202, "changes": 789, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c064e066027cb688449ce4e3fd28126fe45b0e11/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c064e066027cb688449ce4e3fd28126fe45b0e11/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=c064e066027cb688449ce4e3fd28126fe45b0e11", "patch": "@@ -268,6 +268,10 @@ package body Checks is\n    --  of the enclosing protected operation). This clumsy transformation is\n    --  needed because privals are created too late and their actual subtypes\n    --  are not available when analysing the bodies of the protected operations.\n+   --  This function is called whenever the bound is an entity and the scope\n+   --  indicates a protected operation. If the bound is an in-parameter of\n+   --  a protected operation that is not a prival, the function returns the\n+   --  bound itself.\n    --  To be cleaned up???\n \n    function Guard_Access\n@@ -282,6 +286,12 @@ package body Checks is\n    --  Called by Apply_{Length,Range}_Checks to rewrite the tree with the\n    --  Constraint_Error node.\n \n+   function Range_Or_Validity_Checks_Suppressed\n+     (Expr : Node_Id) return Boolean;\n+   --  Returns True if either range or validity checks or both are suppressed\n+   --  for the type of the given expression, or, if the expression is the name\n+   --  of an entity, if these checks are suppressed for the entity.\n+\n    function Selected_Length_Checks\n      (Ck_Node    : Node_Id;\n       Target_Typ : Entity_Id;\n@@ -326,6 +336,19 @@ package body Checks is\n       end if;\n    end Accessibility_Checks_Suppressed;\n \n+   ---------------------------------\n+   -- Alignment_Checks_Suppressed --\n+   ---------------------------------\n+\n+   function Alignment_Checks_Suppressed (E : Entity_Id) return Boolean is\n+   begin\n+      if Present (E) and then Checks_May_Be_Suppressed (E) then\n+         return Is_Check_Suppressed (E, Alignment_Check);\n+      else\n+         return Scope_Suppress (Alignment_Check);\n+      end if;\n+   end Alignment_Checks_Suppressed;\n+\n    -------------------------\n    -- Append_Range_Checks --\n    -------------------------\n@@ -449,49 +472,153 @@ package body Checks is\n       end if;\n    end Apply_Accessibility_Check;\n \n-   ---------------------------\n-   -- Apply_Alignment_Check --\n-   ---------------------------\n+   --------------------------------\n+   -- Apply_Address_Clause_Check --\n+   --------------------------------\n+\n+   procedure Apply_Address_Clause_Check (E : Entity_Id; N : Node_Id) is\n+      AC   : constant Node_Id    := Address_Clause (E);\n+      Loc  : constant Source_Ptr := Sloc (AC);\n+      Typ  : constant Entity_Id  := Etype (E);\n+      Aexp : constant Node_Id    := Expression (AC);\n \n-   procedure Apply_Alignment_Check (E : Entity_Id; N : Node_Id) is\n-      AC   : constant Node_Id   := Address_Clause (E);\n-      Typ  : constant Entity_Id := Etype (E);\n       Expr : Node_Id;\n-      Loc  : Source_Ptr;\n+      --  Address expression (not necessarily the same as Aexp, for example\n+      --  when Aexp is a reference to a constant, in which case Expr gets\n+      --  reset to reference the value expression of the constant.\n+\n+      Size_Warning_Output : Boolean := False;\n+      --  If we output a size warning we set this True, to stop generating\n+      --  what is likely to be an unuseful redundant alignment warning.\n+\n+      procedure Compile_Time_Bad_Alignment;\n+      --  Post error warnings when alignment is known to be incompatible. Note\n+      --  that we do not go as far as inserting a raise of Program_Error since\n+      --  this is an erroneous case, and it may happen that we are lucky and an\n+      --  underaligned address turns out to be OK after all. Also this warning\n+      --  is suppressed if we already complained about the size.\n+\n+      --------------------------------\n+      -- Compile_Time_Bad_Alignment --\n+      --------------------------------\n+\n+      procedure Compile_Time_Bad_Alignment is\n+      begin\n+         if not Size_Warning_Output\n+           and then Address_Clause_Overlay_Warnings\n+         then\n+            Error_Msg_FE\n+              (\"?specified address for& may be inconsistent with alignment \",\n+               Aexp, E);\n+            Error_Msg_FE\n+              (\"\\?program execution may be erroneous ('R'M 13.3(27))\",\n+               Aexp, E);\n+         end if;\n+      end Compile_Time_Bad_Alignment;\n \n-      Alignment_Required : constant Boolean := Maximum_Alignment > 1;\n-      --  Constant to show whether target requires alignment checks\n+   --  Start of processing for Apply_Address_Check\n \n    begin\n-      --  See if check needed. Note that we never need a check if the\n-      --  maximum alignment is one, since the check will always succeed\n+      --  First obtain expression from address clause\n \n-      if No (AC)\n-        or else not Check_Address_Alignment (AC)\n-        or else not Alignment_Required\n+      Expr := Expression (AC);\n+\n+      --  The following loop digs for the real expression to use in the check\n+\n+      loop\n+         --  For constant, get constant expression\n+\n+         if Is_Entity_Name (Expr)\n+           and then Ekind (Entity (Expr)) = E_Constant\n+         then\n+            Expr := Constant_Value (Entity (Expr));\n+\n+         --  For unchecked conversion, get result to convert\n+\n+         elsif Nkind (Expr) = N_Unchecked_Type_Conversion then\n+            Expr := Expression (Expr);\n+\n+         --  For (common case) of To_Address call, get argument\n+\n+         elsif Nkind (Expr) = N_Function_Call\n+           and then Is_Entity_Name (Name (Expr))\n+           and then Is_RTE (Entity (Name (Expr)), RE_To_Address)\n+         then\n+            Expr := First (Parameter_Associations (Expr));\n+\n+            if Nkind (Expr) = N_Parameter_Association then\n+               Expr := Explicit_Actual_Parameter (Expr);\n+            end if;\n+\n+         --  We finally have the real expression\n+\n+         else\n+            exit;\n+         end if;\n+      end loop;\n+\n+      --  Output a warning if we have the situation of\n+\n+      --      for X'Address use Y'Address\n+\n+      --  and X and Y both have known object sizes, and Y is smaller than X\n+\n+      if Nkind (Expr) = N_Attribute_Reference\n+        and then Attribute_Name (Expr) = Name_Address\n+        and then Is_Entity_Name (Prefix (Expr))\n       then\n-         return;\n+         declare\n+            Exp_Ent  : constant Entity_Id := Entity (Prefix (Expr));\n+            Obj_Size : Uint := No_Uint;\n+            Exp_Size : Uint := No_Uint;\n+\n+         begin\n+            if Known_Esize (E) then\n+               Obj_Size := Esize (E);\n+            elsif Known_Esize (Etype (E)) then\n+               Obj_Size := Esize (Etype (E));\n+            end if;\n+\n+            if Known_Esize (Exp_Ent) then\n+               Exp_Size := Esize (Exp_Ent);\n+            elsif Known_Esize (Etype (Exp_Ent)) then\n+               Exp_Size := Esize (Etype (Exp_Ent));\n+            end if;\n+\n+            if Obj_Size /= No_Uint\n+              and then Exp_Size /= No_Uint\n+              and then Obj_Size > Exp_Size\n+              and then not Warnings_Off (E)\n+            then\n+               if Address_Clause_Overlay_Warnings then\n+                  Error_Msg_FE\n+                    (\"?& overlays smaller object\", Aexp, E);\n+                  Error_Msg_FE\n+                    (\"\\?program execution may be erroneous\", Aexp, E);\n+                  Size_Warning_Output := True;\n+               end if;\n+            end if;\n+         end;\n       end if;\n \n-      Loc  := Sloc (AC);\n-      Expr := Expression (AC);\n+      --  See if alignment check needed. Note that we never need a check if the\n+      --  maximum alignment is one, since the check will always succeed.\n \n-      if Nkind (Expr) = N_Unchecked_Type_Conversion then\n-         Expr := Expression (Expr);\n+      --  Note: we do not check for checks suppressed here, since that check\n+      --  was done in Sem_Ch13 when the address clause was proceeds. We are\n+      --  only called if checks were not suppressed. The reason for this is\n+      --  that we have to delay the call to Apply_Alignment_Check till freeze\n+      --  time (so that all types etc are elaborated), but we have to check\n+      --  the status of check suppressing at the point of the address clause.\n \n-      elsif Nkind (Expr) = N_Function_Call\n-        and then Is_Entity_Name (Name (Expr))\n-        and then Is_RTE (Entity (Name (Expr)), RE_To_Address)\n+      if No (AC)\n+        or else not Check_Address_Alignment (AC)\n+        or else Maximum_Alignment = 1\n       then\n-         Expr := First (Parameter_Associations (Expr));\n-\n-         if Nkind (Expr) = N_Parameter_Association then\n-            Expr := Explicit_Actual_Parameter (Expr);\n-         end if;\n+         return;\n       end if;\n \n-      --  Here Expr is the address value. See if we know that the\n-      --  value is unacceptable at compile time.\n+      --  See if we know that Expr is a bad alignment at compile time\n \n       if Compile_Time_Known_Value (Expr)\n         and then (Known_Alignment (E) or else Known_Alignment (Typ))\n@@ -508,48 +635,83 @@ package body Checks is\n             end if;\n \n             if Expr_Value (Expr) mod AL /= 0 then\n-               Insert_Action (N,\n-                  Make_Raise_Program_Error (Loc,\n-                    Reason => PE_Misaligned_Address_Value));\n-               Error_Msg_NE\n-                 (\"?specified address for& not \" &\n-                  \"consistent with alignment ('R'M 13.3(27))\", Expr, E);\n+               Compile_Time_Bad_Alignment;\n+            else\n+               return;\n             end if;\n          end;\n \n-      --  Here we do not know if the value is acceptable, generate\n-      --  code to raise PE if alignment is inappropriate.\n+      --  If the expression has the form X'Address, then we can find out if\n+      --  the object X has an alignment that is compatible with the object E.\n \n-      else\n-         --  Skip generation of this code if we don't want elab code\n+      elsif Nkind (Expr) = N_Attribute_Reference\n+        and then Attribute_Name (Expr) = Name_Address\n+      then\n+         declare\n+            AR : constant Alignment_Result :=\n+                   Has_Compatible_Alignment (E, Prefix (Expr));\n+         begin\n+            if AR = Known_Compatible then\n+               return;\n+            elsif AR = Known_Incompatible then\n+               Compile_Time_Bad_Alignment;\n+            end if;\n+         end;\n+      end if;\n \n-         if not Restriction_Active (No_Elaboration_Code) then\n-            Insert_After_And_Analyze (N,\n-              Make_Raise_Program_Error (Loc,\n-                Condition =>\n-                  Make_Op_Ne (Loc,\n-                    Left_Opnd =>\n-                      Make_Op_Mod (Loc,\n-                        Left_Opnd =>\n-                          Unchecked_Convert_To\n-                           (RTE (RE_Integer_Address),\n-                            Duplicate_Subexpr_No_Checks (Expr)),\n-                        Right_Opnd =>\n-                          Make_Attribute_Reference (Loc,\n-                            Prefix => New_Occurrence_Of (E, Loc),\n-                            Attribute_Name => Name_Alignment)),\n-                    Right_Opnd => Make_Integer_Literal (Loc, Uint_0)),\n-                Reason => PE_Misaligned_Address_Value),\n-              Suppress => All_Checks);\n+      --  Here we do not know if the value is acceptable. Stricly we don't have\n+      --  to do anything, since if the alignment is bad, we have an erroneous\n+      --  program. However we are allowed to check for erroneous conditions and\n+      --  we decide to do this by default if the check is not suppressed.\n+\n+      --  However, don't do the check if elaboration code is unwanted\n+\n+      if Restriction_Active (No_Elaboration_Code) then\n+         return;\n+\n+      --  Generate a check to raise PE if alignment may be inappropriate\n+\n+      else\n+         --  If the original expression is a non-static constant, use the\n+         --  name of the constant itself rather than duplicating its\n+         --  defining expression, which was extracted above..\n+\n+         if Is_Entity_Name (Expression (AC))\n+           and then Ekind (Entity (Expression (AC))) = E_Constant\n+           and then\n+             Nkind (Parent (Entity (Expression (AC)))) = N_Object_Declaration\n+         then\n+            Expr := New_Copy_Tree (Expression (AC));\n+         else\n+            Remove_Side_Effects (Expr);\n          end if;\n-      end if;\n \n-      return;\n+         Insert_After_And_Analyze (N,\n+           Make_Raise_Program_Error (Loc,\n+             Condition =>\n+               Make_Op_Ne (Loc,\n+                 Left_Opnd =>\n+                   Make_Op_Mod (Loc,\n+                     Left_Opnd =>\n+                       Unchecked_Convert_To\n+                         (RTE (RE_Integer_Address), Expr),\n+                     Right_Opnd =>\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix => New_Occurrence_Of (E, Loc),\n+                         Attribute_Name => Name_Alignment)),\n+                 Right_Opnd => Make_Integer_Literal (Loc, Uint_0)),\n+             Reason => PE_Misaligned_Address_Value),\n+           Suppress => All_Checks);\n+         return;\n+      end if;\n \n    exception\n+      --  If we have some missing run time component in configurable run time\n+      --  mode then just skip the check (it is not required in any case).\n+\n       when RE_Not_Available =>\n          return;\n-   end Apply_Alignment_Check;\n+   end Apply_Address_Clause_Check;\n \n    -------------------------------------\n    -- Apply_Arithmetic_Overflow_Check --\n@@ -1125,15 +1287,26 @@ package body Checks is\n          end if;\n       end if;\n \n-      --  If an assignment target is present, then we need to generate\n-      --  the actual subtype if the target is a parameter or aliased\n-      --  object with an unconstrained nominal subtype.\n+      --  If an assignment target is present, then we need to generate the\n+      --  actual subtype if the target is a parameter or aliased object with\n+      --  an unconstrained nominal subtype.\n+\n+      --  Ada 2005 (AI-363): For Ada 2005, we limit the building of the actual\n+      --  subtype to the parameter and dereference cases, since other aliased\n+      --  objects are unconstrained (unless the nominal subtype is explicitly\n+      --  constrained). (But we also need to test for renamings???)\n \n       if Present (Lhs)\n         and then (Present (Param_Entity (Lhs))\n-                   or else (not Is_Constrained (T_Typ)\n+                   or else (Ada_Version < Ada_05\n+                             and then not Is_Constrained (T_Typ)\n                              and then Is_Aliased_View (Lhs)\n-                             and then not Is_Aliased_Unconstrained_Component))\n+                             and then not Is_Aliased_Unconstrained_Component)\n+                   or else (Ada_Version >= Ada_05\n+                             and then not Is_Constrained (T_Typ)\n+                             and then Nkind (Lhs) = N_Explicit_Dereference\n+                             and then Nkind (Original_Node (Lhs)) /=\n+                                        N_Function_Call))\n       then\n          T_Typ := Get_Actual_Subtype (Lhs);\n       end if;\n@@ -1360,7 +1533,7 @@ package body Checks is\n                  Make_Raise_Constraint_Error (Loc,\n                    Condition =>\n                      Make_Op_Eq (Loc,\n-                       Left_Opnd => Duplicate_Subexpr_Move_Checks (Right),\n+                       Left_Opnd  => Duplicate_Subexpr_Move_Checks (Right),\n                        Right_Opnd => Make_Integer_Literal (Loc, 0)),\n                    Reason => CE_Divide_By_Zero));\n             end if;\n@@ -1950,13 +2123,27 @@ package body Checks is\n          then\n             Cond := Condition (R_Cno);\n \n-            if not Has_Dynamic_Length_Check (Ck_Node)\n-              and then Checks_On\n-            then\n-               Insert_Action (Ck_Node, R_Cno);\n+            --  Case where node does not now have a dynamic check\n \n-               if not Do_Static then\n-                  Set_Has_Dynamic_Length_Check (Ck_Node);\n+            if not Has_Dynamic_Length_Check (Ck_Node) then\n+\n+               --  If checks are on, just insert the check\n+\n+               if Checks_On then\n+                  Insert_Action (Ck_Node, R_Cno);\n+\n+                  if not Do_Static then\n+                     Set_Has_Dynamic_Length_Check (Ck_Node);\n+                  end if;\n+\n+               --  If checks are off, then analyze the length check after\n+               --  temporarily attaching it to the tree in case the relevant\n+               --  condition can be evaluted at compile time. We still want a\n+               --  compile time warning in this case.\n+\n+               else\n+                  Set_Parent (R_Cno, Ck_Node);\n+                  Analyze (R_Cno);\n                end if;\n             end if;\n \n@@ -2599,65 +2786,74 @@ package body Checks is\n    ----------------------------------\n \n    procedure Null_Exclusion_Static_Checks (N : Node_Id) is\n-      K                  : constant Node_Kind := Nkind (N);\n-      Typ                : Entity_Id;\n-      Related_Nod        : Node_Id;\n-      Has_Null_Exclusion : Boolean := False;\n+      Error_Node : Node_Id;\n+      Expr       : Node_Id;\n+      Has_Null   : constant Boolean := Has_Null_Exclusion (N);\n+      K          : constant Node_Kind := Nkind (N);\n+      Typ        : Entity_Id;\n \n    begin\n-      pragma Assert (K = N_Parameter_Specification\n-                       or else K = N_Object_Declaration\n-                       or else K = N_Discriminant_Specification\n-                       or else K = N_Component_Declaration);\n-\n-      Typ := Etype (Defining_Identifier (N));\n-\n-      pragma Assert (Is_Access_Type (Typ)\n-        or else (K = N_Object_Declaration and then Is_Array_Type (Typ)));\n+      pragma Assert\n+        (K = N_Component_Declaration\n+           or else K = N_Discriminant_Specification\n+           or else K = N_Function_Specification\n+           or else K = N_Object_Declaration\n+           or else K = N_Parameter_Specification);\n+\n+      if K = N_Function_Specification then\n+         Typ := Etype (Defining_Entity (N));\n+      else\n+         Typ := Etype (Defining_Identifier (N));\n+      end if;\n \n       case K is\n-         when N_Parameter_Specification =>\n-            Related_Nod        := Parameter_Type (N);\n-            Has_Null_Exclusion := Null_Exclusion_Present (N);\n-\n-         when N_Object_Declaration =>\n-            Related_Nod        := Object_Definition (N);\n-            Has_Null_Exclusion := Null_Exclusion_Present (N);\n-\n-         when N_Discriminant_Specification =>\n-            Related_Nod        := Discriminant_Type (N);\n-            Has_Null_Exclusion := Null_Exclusion_Present (N);\n-\n          when N_Component_Declaration =>\n             if Present (Access_Definition (Component_Definition (N))) then\n-               Related_Nod := Component_Definition (N);\n-               Has_Null_Exclusion :=\n-                 Null_Exclusion_Present\n-                   (Access_Definition (Component_Definition (N)));\n+               Error_Node := Component_Definition (N);\n             else\n-               Related_Nod :=\n-                 Subtype_Indication (Component_Definition (N));\n-               Has_Null_Exclusion :=\n-                 Null_Exclusion_Present (Component_Definition (N));\n+               Error_Node := Subtype_Indication (Component_Definition (N));\n             end if;\n \n+         when N_Discriminant_Specification =>\n+            Error_Node    := Discriminant_Type (N);\n+\n+         when N_Function_Specification =>\n+            Error_Node    := Result_Definition (N);\n+\n+         when N_Object_Declaration =>\n+            Error_Node    := Object_Definition (N);\n+\n+         when N_Parameter_Specification =>\n+            Error_Node    := Parameter_Type (N);\n+\n          when others =>\n             raise Program_Error;\n       end case;\n \n-      --  Enforce legality rule 3.10 (14/1): A null_exclusion is only allowed\n-      --  of the access subtype does not exclude null.\n+      if Has_Null then\n \n-      if Has_Null_Exclusion\n-        and then Can_Never_Be_Null (Typ)\n+         --  Enforce legality rule 3.10 (13): A null exclusion can only be\n+         --  applied to an access [sub]type.\n \n-         --  No need to check itypes that have the null-excluding attribute\n-         --  because they were checked at their point of creation\n+         if not Is_Access_Type (Typ) then\n+            Error_Msg_N\n+              (\"null-exclusion must be applied to an access type\",\n+               Error_Node);\n \n-        and then not Is_Itype (Typ)\n-      then\n-         Error_Msg_N\n-           (\"(Ada 2005) already a null-excluding type\", Related_Nod);\n+         --  Enforce legality rule 3.10 (14/1): A null exclusion can only\n+         --  be applied to a [sub]type that does not exclude null already.\n+\n+         elsif Can_Never_Be_Null (Typ)\n+\n+            --  No need to check itypes that have a null exclusion because\n+            --  they are already examined at their point of creation.\n+\n+           and then not Is_Itype (Typ)\n+         then\n+            Error_Msg_N\n+              (\"null-exclusion cannot be applied to a null excluding type\",\n+               Error_Node);\n+         end if;\n       end if;\n \n       --  Check that null-excluding objects are always initialized\n@@ -2678,46 +2874,44 @@ package body Checks is\n             Reason => CE_Null_Not_Allowed);\n       end if;\n \n-      --  Check that the null value is not used as a single expression to\n-      --  assignate a value to a null-excluding component, formal or object;\n-      --  otherwise generate a warning message at the sloc of Related_Nod and\n-      --  replace Expression (N) by an N_Contraint_Error node.\n+      --  Check that a null-excluding component, formal or object is not\n+      --  being assigned a null value. Otherwise generate a warning message\n+      --  and replace Expression (N) by a N_Contraint_Error node.\n \n-      declare\n-         Expr : constant Node_Id := Expression (N);\n+      if K /= N_Function_Specification then\n+         Expr := Expression (N);\n \n-      begin\n          if Present (Expr)\n            and then Nkind (Expr) = N_Null\n          then\n             case K is\n-               when N_Discriminant_Specification  |\n-                    N_Component_Declaration      =>\n+               when N_Component_Declaration      |\n+                    N_Discriminant_Specification =>\n                   Apply_Compile_Time_Constraint_Error\n-                     (N      => Expr,\n-                      Msg    => \"(Ada 2005) NULL not allowed in\"\n-                                  & \" null-excluding components?\",\n-                      Reason => CE_Null_Not_Allowed);\n+                    (N      => Expr,\n+                     Msg    => \"(Ada 2005) NULL not allowed \" &\n+                               \"in null-excluding components?\",\n+                     Reason => CE_Null_Not_Allowed);\n \n-               when N_Parameter_Specification =>\n+               when N_Object_Declaration =>\n                   Apply_Compile_Time_Constraint_Error\n-                     (N      => Expr,\n-                      Msg    => \"(Ada 2005) NULL not allowed in\"\n-                                  & \" null-excluding formals?\",\n-                      Reason => CE_Null_Not_Allowed);\n+                    (N      => Expr,\n+                     Msg    => \"(Ada 2005) NULL not allowed \" &\n+                               \"in null-excluding objects?\",\n+                     Reason => CE_Null_Not_Allowed);\n \n-               when N_Object_Declaration =>\n+               when N_Parameter_Specification =>\n                   Apply_Compile_Time_Constraint_Error\n-                     (N      => Expr,\n-                      Msg    => \"(Ada 2005) NULL not allowed in\"\n-                                  & \" null-excluding objects?\",\n-                      Reason => CE_Null_Not_Allowed);\n+                    (N      => Expr,\n+                     Msg    => \"(Ada 2005) NULL not allowed \" &\n+                               \"in null-excluding formals?\",\n+                     Reason => CE_Null_Not_Allowed);\n \n                when others =>\n                   null;\n             end case;\n          end if;\n-      end;\n+      end if;\n    end Null_Exclusion_Static_Checks;\n \n    ----------------------------------\n@@ -3461,6 +3655,41 @@ package body Checks is\n          return;\n       end if;\n \n+      --  Check for various cases where we should suppress the range check\n+\n+      --  No check if range checks suppressed for type of node\n+\n+      if Present (Etype (N))\n+        and then Range_Checks_Suppressed (Etype (N))\n+      then\n+         return;\n+\n+      --  No check if node is an entity name, and range checks are suppressed\n+      --  for this entity, or for the type of this entity.\n+\n+      elsif Is_Entity_Name (N)\n+        and then (Range_Checks_Suppressed (Entity (N))\n+                    or else Range_Checks_Suppressed (Etype (Entity (N))))\n+      then\n+         return;\n+\n+      --  No checks if index of array, and index checks are suppressed for\n+      --  the array object or the type of the array.\n+\n+      elsif Nkind (Parent (N)) = N_Indexed_Component then\n+         declare\n+            Pref : constant Node_Id := Prefix (Parent (N));\n+         begin\n+            if Is_Entity_Name (Pref)\n+              and then Index_Checks_Suppressed (Entity (Pref))\n+            then\n+               return;\n+            elsif Index_Checks_Suppressed (Etype (Pref)) then\n+               return;\n+            end if;\n+         end;\n+      end if;\n+\n       --  Debug trace output\n \n       if Debug_Flag_CC then\n@@ -3655,11 +3884,9 @@ package body Checks is\n       if not Validity_Checks_On then\n          return;\n \n-      --  Ignore call if range checks suppressed on entity in question\n+      --  Ignore call if range or validity checks suppressed on entity or type\n \n-      elsif Is_Entity_Name (Expr)\n-        and then Range_Checks_Suppressed (Entity (Expr))\n-      then\n+      elsif Range_Or_Validity_Checks_Suppressed (Expr) then\n          return;\n \n       --  No check required if expression is from the expander, we assume\n@@ -3683,11 +3910,6 @@ package body Checks is\n       elsif Expr_Known_Valid (Expr) then\n          return;\n \n-      --  No check required if checks off\n-\n-      elsif Range_Checks_Suppressed (Typ) then\n-         return;\n-\n       --  Ignore case of enumeration with holes where the flag is set not\n       --  to worry about holes, since no special validity check is needed\n \n@@ -3713,6 +3935,22 @@ package body Checks is\n       then\n          return;\n \n+      --  If the expression denotes a component of a packed boolean arrray,\n+      --  no possible check applies. We ignore the old ACATS chestnuts that\n+      --  involve Boolean range True..True.\n+\n+      --  Note: validity checks are generated for expressions that yield a\n+      --  scalar type, when it is possible to create a value that is outside of\n+      --  the type. If this is a one-bit boolean no such value exists. This is\n+      --  an optimization, and it also prevents compiler blowing up during the\n+      --  elaboration of improperly expanded packed array references.\n+\n+      elsif Nkind (Expr) = N_Indexed_Component\n+        and then Is_Bit_Packed_Array (Etype (Prefix (Expr)))\n+        and then Root_Type (Etype (Expr)) = Standard_Boolean\n+      then\n+         return;\n+\n       --  An annoying special case. If this is an out parameter of a scalar\n       --  type, then the value is not going to be accessed, therefore it is\n       --  inappropriate to do any validity check at the call site.\n@@ -3771,7 +4009,6 @@ package body Checks is\n \n                      F := First_Formal (E);\n                      A := First (L);\n-\n                      while Present (F) loop\n                         if Ekind (F) = E_Out_Parameter and then A = N then\n                            return;\n@@ -3786,10 +4023,7 @@ package body Checks is\n          end if;\n       end if;\n \n-      --  If we fall through, a validity check is required. Note that it would\n-      --  not be good to set Do_Range_Check, even in contexts where this is\n-      --  permissible, since this flag causes checking against the target type,\n-      --  not the source type in contexts such as assignments\n+      --  If we fall through, a validity check is required\n \n       Insert_Valid_Check (Expr);\n    end Ensure_Valid;\n@@ -3835,6 +4069,17 @@ package body Checks is\n       then\n          return True;\n \n+      --  References to discriminants are always considered valid. The value\n+      --  of a discriminant gets checked when the object is built. Within the\n+      --  record, we consider it valid, and it is important to do so, since\n+      --  otherwise we can try to generate bogus validity checks which\n+      --  reference discriminants out of scope.\n+\n+      elsif Is_Entity_Name (Expr)\n+        and then Ekind (Entity (Expr)) = E_Discriminant\n+      then\n+         return True;\n+\n       --  If the type is one for which all values are known valid, then\n       --  we are sure that the value is valid except in the slightly odd\n       --  case where the expression is a reference to a variable whose size\n@@ -3873,9 +4118,7 @@ package body Checks is\n       --  on floating-point operations, we must also check when the operation\n       --  is the right-hand side of an assignment, or is an actual in a call.\n \n-      elsif\n-        Nkind (Expr) in N_Binary_Op or else Nkind (Expr) in N_Unary_Op\n-      then\n+      elsif Nkind (Expr) in N_Op then\n          if Is_Floating_Point_Type (Typ)\n             and then Validity_Check_Floating_Point\n             and then\n@@ -3888,6 +4131,12 @@ package body Checks is\n             return True;\n          end if;\n \n+      --  The result of a membership test is always valid, since it is true\n+      --  or false, there are no other possibilities.\n+\n+      elsif Nkind (Expr) in N_Membership_Test then\n+         return True;\n+\n       --  For all other cases, we do not know the expression is valid\n \n       else\n@@ -4200,6 +4449,16 @@ package body Checks is\n       Num : List_Id;\n \n    begin\n+      --  Ignore call if index checks suppressed for array object or type\n+\n+      if (Is_Entity_Name (A) and then Index_Checks_Suppressed (Entity (A)))\n+        or else Index_Checks_Suppressed (Etype (A))\n+      then\n+         return;\n+      end if;\n+\n+      --  Generate the checks\n+\n       Sub := First (Expressions (N));\n       Ind := 1;\n       while Present (Sub) loop\n@@ -4594,6 +4853,13 @@ package body Checks is\n          end if;\n       end if;\n \n+      --  The bound can be a bona fide parameter of a protected operation,\n+      --  rather than a prival encoded as an in-parameter.\n+\n+      if No (Discriminal_Link (Entity (Bound))) then\n+         return Bound;\n+      end if;\n+\n       D := First_Discriminant (Sc);\n \n       while Present (D)\n@@ -4739,8 +5005,8 @@ package body Checks is\n    begin\n       --  Do not insert if checks off, or if not checking validity\n \n-      if Range_Checks_Suppressed (Etype (Expr))\n-        or else (not Validity_Checks_On)\n+      if not Validity_Checks_On\n+        or else Range_Or_Validity_Checks_Suppressed (Expr)\n       then\n          return;\n       end if;\n@@ -4754,46 +5020,67 @@ package body Checks is\n          Exp := Expression (Exp);\n       end loop;\n \n-      --  Insert the validity check. Note that we do this with validity\n-      --  checks turned off, to avoid recursion, we do not want validity\n-      --  checks on the validity checking code itself!\n-\n-      Validity_Checks_On := False;\n-      Insert_Action\n-        (Expr,\n-         Make_Raise_Constraint_Error (Loc,\n-           Condition =>\n-             Make_Op_Not (Loc,\n-               Right_Opnd =>\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix =>\n-                     Duplicate_Subexpr_No_Checks (Exp, Name_Req => True),\n-                   Attribute_Name => Name_Valid)),\n-           Reason => CE_Invalid_Data),\n-         Suppress => All_Checks);\n-\n-      --  If the expression is a a reference to an element of a bit-packed\n-      --  array, it is rewritten as a renaming declaration. If the expression\n-      --  is an actual in a call, it has not been expanded, waiting for the\n-      --  proper point at which to do it. The same happens with renamings, so\n-      --  that we have to force the expansion now. This non-local complication\n-      --  is due to code in exp_ch2,adb, exp_ch4.adb and exp_ch6.adb.\n-\n-      if Is_Entity_Name (Exp)\n-        and then Nkind (Parent (Entity (Exp))) = N_Object_Renaming_Declaration\n-      then\n-         declare\n-            Old_Exp : constant Node_Id := Name (Parent (Entity (Exp)));\n-         begin\n-            if Nkind (Old_Exp) = N_Indexed_Component\n-              and then Is_Bit_Packed_Array (Etype (Prefix (Old_Exp)))\n-            then\n-               Expand_Packed_Element_Reference (Old_Exp);\n-            end if;\n-         end;\n-      end if;\n+      --  We are about to insert the validity check for Exp. We save and\n+      --  reset the Do_Range_Check flag over this validity check, and then\n+      --  put it back for the final original reference (Exp may be rewritten).\n+\n+      declare\n+         DRC : constant Boolean := Do_Range_Check (Exp);\n \n-      Validity_Checks_On := True;\n+      begin\n+         Set_Do_Range_Check (Exp, False);\n+\n+         --  Insert the validity check. Note that we do this with validity\n+         --  checks turned off, to avoid recursion, we do not want validity\n+         --  checks on the validity checking code itself!\n+\n+         Insert_Action\n+           (Expr,\n+            Make_Raise_Constraint_Error (Loc,\n+              Condition =>\n+                Make_Op_Not (Loc,\n+                  Right_Opnd =>\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix =>\n+                        Duplicate_Subexpr_No_Checks (Exp, Name_Req => True),\n+                      Attribute_Name => Name_Valid)),\n+              Reason => CE_Invalid_Data),\n+            Suppress => Validity_Check);\n+\n+         --  If the expression is a a reference to an element of a bit-packed\n+         --  array, then it is rewritten as a renaming declaration. If the\n+         --  expression is an actual in a call, it has not been expanded,\n+         --  waiting for the proper point at which to do it. The same happens\n+         --  with renamings, so that we have to force the expansion now. This\n+         --  non-local complication is due to code in exp_ch2,adb, exp_ch4.adb\n+         --  and exp_ch6.adb.\n+\n+         if Is_Entity_Name (Exp)\n+           and then Nkind (Parent (Entity (Exp))) =\n+                      N_Object_Renaming_Declaration\n+         then\n+            declare\n+               Old_Exp : constant Node_Id := Name (Parent (Entity (Exp)));\n+            begin\n+               if Nkind (Old_Exp) = N_Indexed_Component\n+                 and then Is_Bit_Packed_Array (Etype (Prefix (Old_Exp)))\n+               then\n+                  Expand_Packed_Element_Reference (Old_Exp);\n+               end if;\n+            end;\n+         end if;\n+\n+         --  Put back the Do_Range_Check flag on the resulting (possibly\n+         --  rewritten) expression.\n+\n+         --  Note: it might be thought that a validity check is not required\n+         --  when a range check is present, but that's not the case, because\n+         --  the back end is allowed to assume for the range check that the\n+         --  operand is within its declared range (an assumption that validity\n+         --  checking is all about NOT assuming!)\n+\n+         Set_Do_Range_Check (Exp, DRC);\n+      end;\n    end Insert_Valid_Check;\n \n    ----------------------------------\n@@ -5002,6 +5289,66 @@ package body Checks is\n       return Scope_Suppress (Range_Check);\n    end Range_Checks_Suppressed;\n \n+   -----------------------------------------\n+   -- Range_Or_Validity_Checks_Suppressed --\n+   -----------------------------------------\n+\n+   --  Note: the coding would be simpler here if we simply made appropriate\n+   --  calls to Range/Validity_Checks_Suppressed, but that would result in\n+   --  duplicated checks which we prefer to avoid.\n+\n+   function Range_Or_Validity_Checks_Suppressed\n+     (Expr : Node_Id) return Boolean\n+   is\n+   begin\n+      --  Immediate return if scope checks suppressed for either check\n+\n+      if Scope_Suppress (Range_Check) or Scope_Suppress (Validity_Check) then\n+         return True;\n+      end if;\n+\n+      --  If no expression, that's odd, decide that checks are suppressed,\n+      --  since we don't want anyone trying to do checks in this case, which\n+      --  is most likely the result of some other error.\n+\n+      if No (Expr) then\n+         return True;\n+      end if;\n+\n+      --  Expression is present, so perform suppress checks on type\n+\n+      declare\n+         Typ : constant Entity_Id := Etype (Expr);\n+      begin\n+         if Vax_Float (Typ) then\n+            return True;\n+         elsif Checks_May_Be_Suppressed (Typ)\n+           and then (Is_Check_Suppressed (Typ, Range_Check)\n+                       or else\n+                     Is_Check_Suppressed (Typ, Validity_Check))\n+         then\n+            return True;\n+         end if;\n+      end;\n+\n+      --  If expression is an entity name, perform checks on this entity\n+\n+      if Is_Entity_Name (Expr) then\n+         declare\n+            Ent : constant Entity_Id := Entity (Expr);\n+         begin\n+            if Checks_May_Be_Suppressed (Ent) then\n+               return Is_Check_Suppressed (Ent, Range_Check)\n+                 or else Is_Check_Suppressed (Ent, Validity_Check);\n+            end if;\n+         end;\n+      end if;\n+\n+      --  If we fall through, no checks suppressed\n+\n+      return False;\n+   end Range_Or_Validity_Checks_Suppressed;\n+\n    -------------------\n    -- Remove_Checks --\n    -------------------\n@@ -6164,12 +6511,20 @@ package body Checks is\n                   --  in a constraint of a component, and nothing can be\n                   --  checked here. The check will be emitted within the\n                   --  init proc. Before then, the discriminal has no real\n-                  --  meaning.\n+                  --  meaning. Similarly, if the entity is a discriminal,\n+                  --  there is no check to perform yet.\n+\n+                  --  The same holds within a discriminated synchronized\n+                  --  type, where the discriminant may constrain a component\n+                  --  or an entry family.\n \n                   if Nkind (LB) = N_Identifier\n-                    and then Ekind (Entity (LB)) = E_Discriminant\n+                    and then Denotes_Discriminant (LB, True)\n                   then\n-                     if Current_Scope = Scope (Entity (LB)) then\n+                     if Current_Scope = Scope (Entity (LB))\n+                       or else Is_Concurrent_Type (Current_Scope)\n+                       or else Ekind (Entity (LB)) /= E_Discriminant\n+                     then\n                         return Ret_Result;\n                      else\n                         LB :=\n@@ -6178,9 +6533,12 @@ package body Checks is\n                   end if;\n \n                   if Nkind (HB) = N_Identifier\n-                    and then Ekind (Entity (HB)) = E_Discriminant\n+                    and then Denotes_Discriminant (HB, True)\n                   then\n-                     if Current_Scope = Scope (Entity (HB)) then\n+                     if Current_Scope = Scope (Entity (HB))\n+                       or else Is_Concurrent_Type (Current_Scope)\n+                       or else Ekind (Entity (HB)) /= E_Discriminant\n+                     then\n                         return Ret_Result;\n                      else\n                         HB :=\n@@ -6499,4 +6857,31 @@ package body Checks is\n       return Scope_Suppress (Tag_Check);\n    end Tag_Checks_Suppressed;\n \n+   --------------------------\n+   -- Validity_Check_Range --\n+   --------------------------\n+\n+   procedure Validity_Check_Range (N : Node_Id) is\n+   begin\n+      if Validity_Checks_On and Validity_Check_Operands then\n+         if Nkind (N) = N_Range then\n+            Ensure_Valid (Low_Bound (N));\n+            Ensure_Valid (High_Bound (N));\n+         end if;\n+      end if;\n+   end Validity_Check_Range;\n+\n+   --------------------------------\n+   -- Validity_Checks_Suppressed --\n+   --------------------------------\n+\n+   function Validity_Checks_Suppressed (E : Entity_Id) return Boolean is\n+   begin\n+      if Present (E) and then Checks_May_Be_Suppressed (E) then\n+         return Is_Check_Suppressed (E, Validity_Check);\n+      else\n+         return Scope_Suppress (Validity_Check);\n+      end if;\n+   end Validity_Checks_Suppressed;\n+\n end Checks;"}, {"sha": "bc7e947595a012e88b7a0772d683e3d3e01b866d", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c064e066027cb688449ce4e3fd28126fe45b0e11/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c064e066027cb688449ce4e3fd28126fe45b0e11/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=c064e066027cb688449ce4e3fd28126fe45b0e11", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,6 +47,7 @@ package Checks is\n \n    function Access_Checks_Suppressed        (E : Entity_Id) return Boolean;\n    function Accessibility_Checks_Suppressed (E : Entity_Id) return Boolean;\n+   function Alignment_Checks_Suppressed     (E : Entity_Id) return Boolean;\n    function Discriminant_Checks_Suppressed  (E : Entity_Id) return Boolean;\n    function Division_Checks_Suppressed      (E : Entity_Id) return Boolean;\n    function Elaboration_Checks_Suppressed   (E : Entity_Id) return Boolean;\n@@ -56,13 +57,13 @@ package Checks is\n    function Range_Checks_Suppressed         (E : Entity_Id) return Boolean;\n    function Storage_Checks_Suppressed       (E : Entity_Id) return Boolean;\n    function Tag_Checks_Suppressed           (E : Entity_Id) return Boolean;\n-   --  These functions check to see if the named check is suppressed,\n-   --  either by an active scope suppress setting, or because the check\n-   --  has been specifically suppressed for the given entity. If no entity\n-   --  is relevant for the current check, then Empty is used as an argument.\n-   --  Note: the reason we insist on specifying Empty is to force the\n-   --  caller to think about whether there is any relevant entity that\n-   --  should be checked.\n+   function Validity_Checks_Suppressed      (E : Entity_Id) return Boolean;\n+   --  These functions check to see if the named check is suppressed, either\n+   --  by an active scope suppress setting, or because the check has been\n+   --  specifically suppressed for the given entity. If no entity is relevant\n+   --  for the current check, then Empty is used as an argument. Note: the\n+   --  reason we insist on specifying Empty is to force the caller to think\n+   --  about whether there is any relevant entity that should be checked.\n \n    --  General note on following checks. These checks are always active if\n    --  Expander_Active and not Inside_A_Generic. They are inactive and have\n@@ -80,12 +81,14 @@ package Checks is\n    --  the object denoted by the access parameter is not deeper than the\n    --  level of the type Typ. Program_Error is raised if the check fails.\n \n-   procedure Apply_Alignment_Check (E : Entity_Id; N : Node_Id);\n-   --  E is the entity for an object. If there is an address clause for\n-   --  this entity, and checks are enabled, then this procedure generates\n-   --  a check that the specified address has an alignment consistent with\n-   --  the alignment of the object, raising PE if this is not the case. The\n-   --  resulting check (if one is generated) is inserted before node N.\n+   procedure Apply_Address_Clause_Check (E : Entity_Id; N : Node_Id);\n+   --  E is the entity for an object which has an address clause. If checks\n+   --  are enabled, then this procedure generates a check that the specified\n+   --  address has an alignment consistent with the alignment of the object,\n+   --  raising PE if this is not the case. The resulting check (if one is\n+   --  generated) is inserted before node N. check is also made for the case of\n+   --  a clear overlay situation that the size of the overlaying object is not\n+   --  larger than the overlaid object.\n \n    procedure Apply_Array_Size_Check (N : Node_Id; Typ : Entity_Id);\n    --  N is the node for an object declaration that declares an object of\n@@ -625,6 +628,10 @@ package Checks is\n    --  conditionally (on the right side of And Then/Or Else. This call\n    --  removes only embedded checks (Do_Range_Check, Do_Overflow_Check).\n \n+   procedure Validity_Check_Range (N : Node_Id);\n+   --  If N is an N_Range node, then Ensure_Valid is called on its bounds,\n+   --  if validity checking of operands is enabled.\n+\n private\n \n    type Check_Result is array (Positive range 1 .. 2) of Node_Id;"}, {"sha": "492451c60c8f810cae0f21896e76175de5e125b8", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c064e066027cb688449ce4e3fd28126fe45b0e11/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c064e066027cb688449ce4e3fd28126fe45b0e11/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=c064e066027cb688449ce4e3fd28126fe45b0e11", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -886,9 +886,8 @@ package body Treepr is\n \n          if Nkind (N) in N_Op\n            or else Nkind (N) = N_And_Then\n-           or else Nkind (N) = N_In\n-           or else Nkind (N) = N_Not_In\n            or else Nkind (N) = N_Or_Else\n+           or else Nkind (N) in N_Membership_Test\n          then\n             --  Print Left_Opnd if present\n "}]}