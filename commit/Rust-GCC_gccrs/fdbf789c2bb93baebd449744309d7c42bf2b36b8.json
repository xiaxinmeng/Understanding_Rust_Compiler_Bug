{"sha": "fdbf789c2bb93baebd449744309d7c42bf2b36b8", "node_id": "C_kwDOANBUbNoAKGZkYmY3ODljMmJiOTNiYWViZDQ0OTc0NDMwOWQ3YzQyYmYyYjM2Yjg", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-18T15:28:49Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-19T20:59:00Z"}, "message": "Redo coercion site code\n\nThis gets rid of the old visitor method and brings us much closer to the\nRustc rules which from the algo mentioned in the comment's do the checks\nin a very specific order which we need to match.", "tree": {"sha": "cb4de70f42cb25876ff40cafa1ed7907b866eb25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb4de70f42cb25876ff40cafa1ed7907b866eb25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdbf789c2bb93baebd449744309d7c42bf2b36b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdbf789c2bb93baebd449744309d7c42bf2b36b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdbf789c2bb93baebd449744309d7c42bf2b36b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdbf789c2bb93baebd449744309d7c42bf2b36b8/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f039ff9f6f18d15e32ddb54e3a6124802c45b7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f039ff9f6f18d15e32ddb54e3a6124802c45b7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f039ff9f6f18d15e32ddb54e3a6124802c45b7f"}], "stats": {"total": 2283, "additions": 413, "deletions": 1870}, "files": [{"sha": "4c20933cafc7760ca3aa08bc360c6dc07e0b65d7", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=fdbf789c2bb93baebd449744309d7c42bf2b36b8", "patch": "@@ -48,7 +48,6 @@ class HIRCompileBase\n \t\t       Location rvalue_locus);\n \n   tree coerce_to_dyn_object (tree compiled_ref, const TyTy::BaseType *actual,\n-\t\t\t     const TyTy::BaseType *expected,\n \t\t\t     const TyTy::DynamicObjectType *ty, Location locus);\n \n   tree compute_address_for_trait_item (\n@@ -78,6 +77,12 @@ class HIRCompileBase\n   tree resolve_unsized_adjustment (Resolver::Adjustment &adjustment,\n \t\t\t\t   tree expression, Location locus);\n \n+  tree resolve_unsized_slice_adjustment (Resolver::Adjustment &adjustment,\n+\t\t\t\t\t tree expression, Location locus);\n+\n+  tree resolve_unsized_dyn_adjustment (Resolver::Adjustment &adjustment,\n+\t\t\t\t       tree expression, Location locus);\n+\n   static void setup_fndecl (tree fndecl, bool is_main_entry_point,\n \t\t\t    bool is_generic_fn, HIR::Visibility &visibility,\n \t\t\t    const HIR::FunctionQualifiers &qualifiers,"}, {"sha": "cf82cf4bcc2206e1d9e23700776e6a7bc789b6d6", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=fdbf789c2bb93baebd449744309d7c42bf2b36b8", "patch": "@@ -1773,6 +1773,27 @@ HIRCompileBase::resolve_indirection_adjustment (\n tree\n HIRCompileBase::resolve_unsized_adjustment (Resolver::Adjustment &adjustment,\n \t\t\t\t\t    tree expression, Location locus)\n+{\n+  bool expect_slice\n+    = adjustment.get_expected ()->get_kind () == TyTy::TypeKind::SLICE;\n+  bool expect_dyn\n+    = adjustment.get_expected ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n+\n+  // assumes this is an array\n+  tree expr_type = TREE_TYPE (expression);\n+  if (expect_slice)\n+    {\n+      rust_assert (TREE_CODE (expr_type) == ARRAY_TYPE);\n+      return resolve_unsized_slice_adjustment (adjustment, expression, locus);\n+    }\n+\n+  rust_assert (expect_dyn);\n+  return resolve_unsized_dyn_adjustment (adjustment, expression, locus);\n+}\n+\n+tree\n+HIRCompileBase::resolve_unsized_slice_adjustment (\n+  Resolver::Adjustment &adjustment, tree expression, Location locus)\n {\n   // assumes this is an array\n   tree expr_type = TREE_TYPE (expression);\n@@ -1802,6 +1823,25 @@ HIRCompileBase::resolve_unsized_adjustment (Resolver::Adjustment &adjustment,\n \t\t\t\t\t\t      {data, size}, -1, locus);\n }\n \n+tree\n+HIRCompileBase::resolve_unsized_dyn_adjustment (\n+  Resolver::Adjustment &adjustment, tree expression, Location locus)\n+{\n+  tree rvalue = expression;\n+  Location rvalue_locus = locus;\n+\n+  const TyTy::BaseType *actual = adjustment.get_actual ();\n+  const TyTy::BaseType *expected = adjustment.get_expected ();\n+\n+  const TyTy::DynamicObjectType *dyn\n+    = static_cast<const TyTy::DynamicObjectType *> (expected);\n+\n+  rust_debug (\"resolve_unsized_dyn_adjustment actual={%s} dyn={%s}\",\n+\t      actual->debug_str ().c_str (), dyn->debug_str ().c_str ());\n+\n+  return coerce_to_dyn_object (rvalue, actual, dyn, rvalue_locus);\n+}\n+\n void\n CompileExpr::visit (HIR::RangeFromToExpr &expr)\n {"}, {"sha": "bf34bb620ba8e5bc9ad1c4950b05695915b47f08", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=fdbf789c2bb93baebd449744309d7c42bf2b36b8", "patch": "@@ -312,13 +312,6 @@ HIRCompileBase::coercion_site1 (tree rvalue, const TyTy::BaseType *rval,\n \t\t\t\t    lvalue_locus, rvalue_locus))\n \treturn error_mark_node;\n     }\n-  else if (expected->get_kind () == TyTy::TypeKind::DYNAMIC\n-\t   && actual->get_kind () != TyTy::TypeKind::DYNAMIC)\n-    {\n-      const TyTy::DynamicObjectType *dyn\n-\t= static_cast<const TyTy::DynamicObjectType *> (expected);\n-      return coerce_to_dyn_object (rvalue, actual, expected, dyn, rvalue_locus);\n-    }\n   else if (expected->get_kind () == TyTy::TypeKind::SLICE)\n     {\n       // bad coercion\n@@ -333,7 +326,7 @@ HIRCompileBase::coercion_site1 (tree rvalue, const TyTy::BaseType *rval,\n \n       // return an unsized coercion\n       Resolver::Adjustment unsize_adj (\n-\tResolver::Adjustment::AdjustmentType::UNSIZE, expected);\n+\tResolver::Adjustment::AdjustmentType::UNSIZE, actual, expected);\n       return resolve_unsized_adjustment (unsize_adj, rvalue, rvalue_locus);\n     }\n \n@@ -343,7 +336,6 @@ HIRCompileBase::coercion_site1 (tree rvalue, const TyTy::BaseType *rval,\n tree\n HIRCompileBase::coerce_to_dyn_object (tree compiled_ref,\n \t\t\t\t      const TyTy::BaseType *actual,\n-\t\t\t\t      const TyTy::BaseType *expected,\n \t\t\t\t      const TyTy::DynamicObjectType *ty,\n \t\t\t\t      Location locus)\n {"}, {"sha": "423f8e4709b5c06dd0319bf298acf347230776a9", "filename": "gcc/rust/typecheck/rust-autoderef.cc", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc?ref=fdbf789c2bb93baebd449744309d7c42bf2b36b8", "patch": "@@ -79,7 +79,7 @@ Adjuster::try_deref_type (const TyTy::BaseType *ty,\n       break;\n     }\n \n-  return Adjustment::get_op_overload_deref_adjustment (adjustment_type,\n+  return Adjustment::get_op_overload_deref_adjustment (adjustment_type, ty,\n \t\t\t\t\t\t       ref_base, fn, impl_item,\n \t\t\t\t\t\t       requires_ref_adjustment);\n }\n@@ -95,7 +95,7 @@ Adjuster::try_raw_deref_type (const TyTy::BaseType *ty)\n     = static_cast<const TyTy::ReferenceType *> (ty);\n   auto infered = ref_base->get_base ()->clone ();\n \n-  return Adjustment (Adjustment::AdjustmentType::INDIRECTION, infered);\n+  return Adjustment (Adjustment::AdjustmentType::INDIRECTION, ty, infered);\n }\n \n Adjustment\n@@ -116,7 +116,7 @@ Adjuster::try_unsize_type (const TyTy::BaseType *ty)\n \t\t\t   TyTy::TyVar (slice_elem->get_ref ()));\n   context->insert_implicit_type (slice);\n \n-  return Adjustment (Adjustment::AdjustmentType::UNSIZE, slice);\n+  return Adjustment (Adjustment::AdjustmentType::UNSIZE, ty, slice);\n }\n \n static bool\n@@ -373,7 +373,8 @@ AutoderefCycle::try_autoderefed (const TyTy::BaseType *r)\n   TyTy::ReferenceType *r1\n     = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n \t\t\t       Mutability::Imm);\n-  adjustments.push_back (Adjustment (Adjustment::AdjustmentType::IMM_REF, r1));\n+  adjustments.push_back (\n+    Adjustment (Adjustment::AdjustmentType::IMM_REF, r, r1));\n   if (select (*r1))\n     return true;\n \n@@ -383,7 +384,8 @@ AutoderefCycle::try_autoderefed (const TyTy::BaseType *r)\n   TyTy::ReferenceType *r2\n     = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n \t\t\t       Mutability::Mut);\n-  adjustments.push_back (Adjustment (Adjustment::AdjustmentType::MUT_REF, r2));\n+  adjustments.push_back (\n+    Adjustment (Adjustment::AdjustmentType::MUT_REF, r, r2));\n   if (select (*r2))\n     return true;\n "}, {"sha": "2f8d64b97e65f7dc3a90fe644d531a2afb154062", "filename": "gcc/rust/typecheck/rust-autoderef.h", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h?ref=fdbf789c2bb93baebd449744309d7c42bf2b36b8", "patch": "@@ -40,21 +40,25 @@ class Adjustment\n   };\n \n   // ctor for all adjustments except derefs\n-  Adjustment (AdjustmentType type, const TyTy::BaseType *expected)\n-    : Adjustment (type, expected, nullptr, nullptr, AdjustmentType::ERROR)\n+  Adjustment (AdjustmentType type, const TyTy::BaseType *actual,\n+\t      const TyTy::BaseType *expected)\n+    : Adjustment (type, actual, expected, nullptr, nullptr,\n+\t\t  AdjustmentType::ERROR)\n   {}\n \n   static Adjustment get_op_overload_deref_adjustment (\n-    AdjustmentType type, const TyTy::BaseType *expected, TyTy::FnType *fn,\n-    HIR::ImplItem *deref_item,\n+    AdjustmentType type, const TyTy::BaseType *actual,\n+    const TyTy::BaseType *expected, TyTy::FnType *fn, HIR::ImplItem *deref_item,\n     Adjustment::AdjustmentType requires_ref_adjustment)\n   {\n     rust_assert (type == DEREF || type == DEREF_MUT);\n-    return Adjustment (type, expected, fn, deref_item, requires_ref_adjustment);\n+    return Adjustment (type, actual, expected, fn, deref_item,\n+\t\t       requires_ref_adjustment);\n   }\n \n   AdjustmentType get_type () const { return type; }\n \n+  const TyTy::BaseType *get_actual () const { return actual; }\n   const TyTy::BaseType *get_expected () const { return expected; }\n \n   std::string as_string () const\n@@ -86,7 +90,7 @@ class Adjustment\n     return \"\";\n   }\n \n-  static Adjustment get_error () { return Adjustment{ERROR, nullptr}; }\n+  static Adjustment get_error () { return Adjustment{ERROR, nullptr, nullptr}; }\n \n   bool is_error () const { return type == ERROR; }\n \n@@ -106,14 +110,17 @@ class Adjustment\n   HIR::ImplItem *get_deref_hir_item () const { return deref_item; }\n \n private:\n-  Adjustment (AdjustmentType type, const TyTy::BaseType *expected,\n-\t      TyTy::FnType *deref_operator_fn, HIR::ImplItem *deref_item,\n+  Adjustment (AdjustmentType type, const TyTy::BaseType *actual,\n+\t      const TyTy::BaseType *expected, TyTy::FnType *deref_operator_fn,\n+\t      HIR::ImplItem *deref_item,\n \t      Adjustment::AdjustmentType requires_ref_adjustment)\n-    : type (type), expected (expected), deref_operator_fn (deref_operator_fn),\n-      deref_item (deref_item), requires_ref_adjustment (requires_ref_adjustment)\n+    : type (type), actual (actual), expected (expected),\n+      deref_operator_fn (deref_operator_fn), deref_item (deref_item),\n+      requires_ref_adjustment (requires_ref_adjustment)\n   {}\n \n   AdjustmentType type;\n+  const TyTy::BaseType *actual;\n   const TyTy::BaseType *expected;\n \n   // - only used for deref operator_overloads"}, {"sha": "b7ef6774afd47a5deed4e3809db819d2710ba294", "filename": "gcc/rust/typecheck/rust-coercion.cc", "status": "modified", "additions": 276, "deletions": 30, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc?ref=fdbf789c2bb93baebd449744309d7c42bf2b36b8", "patch": "@@ -22,59 +22,276 @@ namespace Rust {\n namespace Resolver {\n \n AutoderefTypeCoercion::CoercionResult\n-AutoderefTypeCoercion::Coerce (const TyTy::BaseType *receiver,\n-\t\t\t       const TyTy::BaseType *expected, Location locus)\n+AutoderefTypeCoercion::Coerce (TyTy::BaseType *receiver,\n+\t\t\t       TyTy::BaseType *expected, Location locus)\n {\n   AutoderefTypeCoercion resolver (expected, locus);\n-  bool ok = resolver.cycle (receiver);\n+  bool ok = resolver.do_coercion (receiver);\n   return ok ? resolver.try_result : CoercionResult::get_error ();\n }\n \n-AutoderefTypeCoercion::AutoderefTypeCoercion (const TyTy::BaseType *expected,\n+AutoderefTypeCoercion::AutoderefTypeCoercion (TyTy::BaseType *expected,\n \t\t\t\t\t      Location locus)\n   : AutoderefCycle (false), mappings (Analysis::Mappings::get ()),\n     context (TypeCheckContext::get ()), expected (expected), locus (locus),\n     try_result (CoercionResult::get_error ())\n {}\n \n bool\n-AutoderefTypeCoercion::cycle (const TyTy::BaseType *receiver)\n+AutoderefTypeCoercion::do_coercion (TyTy::BaseType *receiver)\n {\n   // FIXME this is not finished and might be super simplified\n   // see:\n   // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/coercion.rs\n \n-  if (receiver->get_kind () == TyTy::TypeKind::REF\n-      && expected->get_kind () == TyTy::TypeKind::REF)\n+  // unsize\n+  bool unsafe_error = false;\n+  CoercionResult unsize_coercion\n+    = coerce_unsized (receiver, expected, unsafe_error);\n+  bool valid_unsize_coercion = !unsize_coercion.is_error ();\n+  if (valid_unsize_coercion)\n     {\n-      // if we expect to get a mutable pointer we can't get that from an\n-      // immutable one so we have to be careful\n-\n-      const auto &receiver_ref\n-\t= static_cast<const TyTy::ReferenceType &> (*receiver);\n-      const auto &expected_ref\n-\t= static_cast<const TyTy::ReferenceType &> (*expected);\n-\n-      // we can allow for mutability changes here by casting down from\n-      // mutability eg:  mut vs const, we cant take a mutable reference from a\n-      // const eg:  const vs mut we can take a const reference from a mutable\n-      // one\n-\n-      bool mutability_ok\n-\t= !expected_ref.is_mutable ()\n-\t  || (expected_ref.is_mutable () == receiver_ref.is_mutable ());\n-      if (!mutability_ok)\n+      try_result = unsize_coercion;\n+      return true;\n+    }\n+  else if (unsafe_error)\n+    {\n+      // Location lhs = mappings->lookup_location (receiver->get_ref ());\n+      // Location rhs = mappings->lookup_location (expected->get_ref ());\n+      // object_unsafe_error (locus, lhs, rhs);\n+      return false;\n+    }\n+\n+  // pointers\n+  switch (expected->get_kind ())\n+    {\n+      case TyTy::TypeKind::POINTER: {\n+\tTyTy::PointerType *ptr = static_cast<TyTy::PointerType *> (expected);\n+\ttry_result = coerce_unsafe_ptr (receiver, ptr, ptr->mutability ());\n+\treturn !try_result.is_error ();\n+      }\n+\n+      case TyTy::TypeKind::REF: {\n+\tTyTy::ReferenceType *ptr\n+\t  = static_cast<TyTy::ReferenceType *> (expected);\n+\ttry_result\n+\t  = coerce_borrowed_pointer (receiver, ptr, ptr->mutability ());\n+\treturn !try_result.is_error ();\n+      }\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return !try_result.is_error ();\n+}\n+\n+AutoderefTypeCoercion::CoercionResult\n+AutoderefTypeCoercion::coerce_unsafe_ptr (TyTy::BaseType *receiver,\n+\t\t\t\t\t  TyTy::PointerType *expected,\n+\t\t\t\t\t  Mutability to_mutbl)\n+{\n+  rust_debug (\"coerce_unsafe_ptr(a={%s}, b={%s})\",\n+\t      receiver->debug_str ().c_str (), expected->debug_str ().c_str ());\n+\n+  Mutability from_mutbl = Mutability::Imm;\n+  TyTy::BaseType *element = nullptr;\n+  switch (receiver->get_kind ())\n+    {\n+      case TyTy::TypeKind::REF: {\n+\tTyTy::ReferenceType *ref\n+\t  = static_cast<TyTy::ReferenceType *> (receiver);\n+\tfrom_mutbl = ref->mutability ();\n+\telement = ref->get_base ();\n+      }\n+      break;\n+\n+      case TyTy::TypeKind::POINTER: {\n+\tTyTy::PointerType *ref = static_cast<TyTy::PointerType *> (receiver);\n+\tfrom_mutbl = ref->mutability ();\n+\telement = ref->get_base ();\n+      }\n+      break;\n+\n+      default: {\n+\tTyTy::BaseType *result = receiver->unify (expected);\n+\treturn CoercionResult{{}, result};\n+      }\n+    }\n+\n+  if (!coerceable_mutability (from_mutbl, to_mutbl))\n+    {\n+      Location lhs = mappings->lookup_location (receiver->get_ref ());\n+      Location rhs = mappings->lookup_location (expected->get_ref ());\n+      mismatched_mutability_error (locus, lhs, rhs);\n+      return AutoderefTypeCoercion::CoercionResult::get_error ();\n+    }\n+\n+  TyTy::PointerType *result\n+    = new TyTy::PointerType (receiver->get_ref (),\n+\t\t\t     TyTy::TyVar (element->get_ref ()), to_mutbl);\n+  return CoercionResult{{}, result};\n+}\n+\n+/// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n+/// To match `A` with `B`, autoderef will be performed,\n+/// calling `deref`/`deref_mut` where necessary.\n+AutoderefTypeCoercion::CoercionResult\n+AutoderefTypeCoercion::coerce_borrowed_pointer (TyTy::BaseType *receiver,\n+\t\t\t\t\t\tTyTy::ReferenceType *expected,\n+\t\t\t\t\t\tMutability to_mutbl)\n+{\n+  rust_debug (\"coerce_borrowed_pointer(a={%s}, b={%s})\",\n+\t      receiver->debug_str ().c_str (), expected->debug_str ().c_str ());\n+\n+  Mutability from_mutbl = Mutability::Imm;\n+  switch (receiver->get_kind ())\n+    {\n+      case TyTy::TypeKind::REF: {\n+\tTyTy::ReferenceType *ref\n+\t  = static_cast<TyTy::ReferenceType *> (receiver);\n+\tfrom_mutbl = ref->mutability ();\n+      }\n+      break;\n+\n+      default: {\n+\tTyTy::BaseType *result = receiver->unify (expected);\n+\treturn CoercionResult{{}, result};\n+      }\n+    }\n+\n+  if (!coerceable_mutability (from_mutbl, to_mutbl))\n+    {\n+      Location lhs = mappings->lookup_location (receiver->get_ref ());\n+      Location rhs = mappings->lookup_location (expected->get_ref ());\n+      mismatched_mutability_error (locus, lhs, rhs);\n+      return AutoderefTypeCoercion::CoercionResult::get_error ();\n+    }\n+\n+  AutoderefCycle::cycle (receiver);\n+  return try_result;\n+}\n+\n+// &[T; n] or &mut [T; n] -> &[T]\n+// or &mut [T; n] -> &mut [T]\n+// or &Concrete -> &Trait, etc.\n+AutoderefTypeCoercion::CoercionResult\n+AutoderefTypeCoercion::coerce_unsized (TyTy::BaseType *source,\n+\t\t\t\t       TyTy::BaseType *target,\n+\t\t\t\t       bool &unsafe_error)\n+{\n+  rust_debug (\"coerce_unsized(source={%s}, target={%s})\",\n+\t      source->debug_str ().c_str (), target->debug_str ().c_str ());\n+\n+  bool source_is_ref = source->get_kind () == TyTy::TypeKind::REF;\n+  bool target_is_ref = target->get_kind () == TyTy::TypeKind::REF;\n+  bool target_is_ptr = target->get_kind () == TyTy::TypeKind::POINTER;\n+\n+  bool needs_reborrow = false;\n+  TyTy::BaseType *ty_a = source;\n+  TyTy::BaseType *ty_b = target;\n+  Mutability expected_mutability = Mutability::Imm;\n+  if (source_is_ref && target_is_ref)\n+    {\n+      TyTy::ReferenceType *source_ref\n+\t= static_cast<TyTy::ReferenceType *> (source);\n+      TyTy::ReferenceType *target_ref\n+\t= static_cast<TyTy::ReferenceType *> (target);\n+\n+      Mutability from_mutbl = source_ref->mutability ();\n+      Mutability to_mutbl = target_ref->mutability ();\n+      if (!coerceable_mutability (from_mutbl, to_mutbl))\n+\t{\n+\t  unsafe_error = true;\n+\t  Location lhs = mappings->lookup_location (source->get_ref ());\n+\t  Location rhs = mappings->lookup_location (target->get_ref ());\n+\t  mismatched_mutability_error (locus, lhs, rhs);\n+\t  return AutoderefTypeCoercion::CoercionResult::get_error ();\n+\t}\n+\n+      ty_a = source_ref->get_base ();\n+      ty_b = target_ref->get_base ();\n+      needs_reborrow = true;\n+      expected_mutability = to_mutbl;\n+\n+      adjustments.push_back (\n+\tAdjustment (Adjustment::AdjustmentType::INDIRECTION, source_ref, ty_a));\n+    }\n+  else if (source_is_ref && target_is_ptr)\n+    {\n+      TyTy::ReferenceType *source_ref\n+\t= static_cast<TyTy::ReferenceType *> (source);\n+      TyTy::PointerType *target_ref = static_cast<TyTy::PointerType *> (target);\n+\n+      Mutability from_mutbl = source_ref->mutability ();\n+      Mutability to_mutbl = target_ref->mutability ();\n+      if (!coerceable_mutability (from_mutbl, to_mutbl))\n+\t{\n+\t  unsafe_error = true;\n+\t  Location lhs = mappings->lookup_location (source->get_ref ());\n+\t  Location rhs = mappings->lookup_location (target->get_ref ());\n+\t  mismatched_mutability_error (locus, lhs, rhs);\n+\t  return AutoderefTypeCoercion::CoercionResult::get_error ();\n+\t}\n+\n+      ty_a = source_ref->get_base ();\n+      ty_b = target_ref->get_base ();\n+      needs_reborrow = true;\n+      expected_mutability = to_mutbl;\n+\n+      adjustments.push_back (\n+\tAdjustment (Adjustment::AdjustmentType::INDIRECTION, source_ref, ty_a));\n+    }\n+\n+  // FIXME\n+  // there is a bunch of code to ensure something is coerce able to a dyn trait\n+  // we need to support but we need to support a few more lang items for that\n+  // see:\n+  // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/coercion.rs#L582\n+\n+  const auto a = ty_a;\n+  const auto b = ty_b;\n+\n+  bool expect_dyn = b->get_kind () == TyTy::TypeKind::DYNAMIC;\n+  bool need_unsize = a->get_kind () != TyTy::TypeKind::DYNAMIC;\n+\n+  if (expect_dyn && need_unsize)\n+    {\n+      bool bounds_compatible = b->bounds_compatible (*a, locus, true);\n+      if (!bounds_compatible)\n+\t{\n+\t  unsafe_error = true;\n+\t  return AutoderefTypeCoercion::CoercionResult::get_error ();\n+\t}\n+\n+      // return the unsize coercion\n+      TyTy::BaseType *result = b->clone ();\n+      // result->set_ref (a->get_ref ());\n+\n+      // append a dyn coercion adjustment\n+      adjustments.push_back (Adjustment (Adjustment::UNSIZE, a, result));\n+\n+      // reborrow if needed\n+      if (needs_reborrow)\n \t{\n-\t  RichLocation r (locus);\n-\t  r.add_range (mappings->lookup_location (receiver_ref.get_ref ()));\n-\t  r.add_range (mappings->lookup_location (expected_ref.get_ref ()));\n-\t  rust_error_at (r, \"mismatched mutability\");\n+\t  TyTy::ReferenceType *reborrow\n+\t    = new TyTy::ReferenceType (source->get_ref (),\n+\t\t\t\t       TyTy::TyVar (result->get_ref ()),\n+\t\t\t\t       expected_mutability);\n \n-\t  return false;\n+\t  Adjustment::AdjustmentType borrow_type\n+\t    = expected_mutability == Mutability::Imm ? Adjustment::IMM_REF\n+\t\t\t\t\t\t     : Adjustment::MUT_REF;\n+\t  adjustments.push_back (Adjustment (borrow_type, result, reborrow));\n+\t  result = reborrow;\n \t}\n+\n+      return CoercionResult{adjustments, result};\n     }\n \n-  return AutoderefCycle::cycle (receiver);\n+  adjustments.clear ();\n+  return AutoderefTypeCoercion::CoercionResult::get_error ();\n }\n \n bool\n@@ -88,5 +305,34 @@ AutoderefTypeCoercion::select (const TyTy::BaseType &autoderefed)\n   return false;\n }\n \n+/// Coercing a mutable reference to an immutable works, while\n+/// coercing `&T` to `&mut T` should be forbidden.\n+bool\n+AutoderefTypeCoercion::coerceable_mutability (Mutability from_mutbl,\n+\t\t\t\t\t      Mutability to_mutbl)\n+{\n+  return to_mutbl == Mutability::Imm || (from_mutbl == to_mutbl);\n+}\n+\n+void\n+AutoderefTypeCoercion::mismatched_mutability_error (Location expr_locus,\n+\t\t\t\t\t\t    Location lhs, Location rhs)\n+{\n+  RichLocation r (expr_locus);\n+  r.add_range (lhs);\n+  r.add_range (rhs);\n+  rust_error_at (r, \"mismatched mutability\");\n+}\n+\n+void\n+AutoderefTypeCoercion::object_unsafe_error (Location expr_locus, Location lhs,\n+\t\t\t\t\t    Location rhs)\n+{\n+  RichLocation r (expr_locus);\n+  r.add_range (lhs);\n+  r.add_range (rhs);\n+  rust_error_at (r, \"unsafe unsize coercion\");\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "f2f440afd8b0095498d2d8a8176b690448257658", "filename": "gcc/rust/typecheck/rust-coercion.h", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-coercion.h?ref=fdbf789c2bb93baebd449744309d7c42bf2b36b8", "patch": "@@ -41,23 +41,42 @@ class AutoderefTypeCoercion : protected AutoderefCycle\n     static CoercionResult get_error () { return CoercionResult{{}, nullptr}; }\n   };\n \n-  static CoercionResult Coerce (const TyTy::BaseType *receiver,\n-\t\t\t\tconst TyTy::BaseType *expected, Location locus);\n+  static CoercionResult Coerce (TyTy::BaseType *receiver,\n+\t\t\t\tTyTy::BaseType *expected, Location locus);\n \n-protected:\n-  AutoderefTypeCoercion (const TyTy::BaseType *expected, Location locus);\n+  CoercionResult coerce_unsafe_ptr (TyTy::BaseType *receiver,\n+\t\t\t\t    TyTy::PointerType *expected,\n+\t\t\t\t    Mutability mutability);\n+\n+  CoercionResult coerce_borrowed_pointer (TyTy::BaseType *receiver,\n+\t\t\t\t\t  TyTy::ReferenceType *expected,\n+\t\t\t\t\t  Mutability mutability);\n+\n+  CoercionResult coerce_unsized (TyTy::BaseType *receiver,\n+\t\t\t\t TyTy::BaseType *expected, bool &unsafe_error);\n+\n+  static bool coerceable_mutability (Mutability from_mutbl,\n+\t\t\t\t     Mutability to_mutbl);\n \n-  bool cycle (const TyTy::BaseType *receiver) override;\n+  static void mismatched_mutability_error (Location expr_locus, Location lhs,\n+\t\t\t\t\t   Location rhs);\n+  static void object_unsafe_error (Location expr_locus, Location lhs,\n+\t\t\t\t   Location rhs);\n+\n+protected:\n+  AutoderefTypeCoercion (TyTy::BaseType *expected, Location locus);\n \n   bool select (const TyTy::BaseType &autoderefed) override;\n \n+  bool do_coercion (TyTy::BaseType *receiver);\n+\n private:\n   // context info\n   Analysis::Mappings *mappings;\n   TypeCheckContext *context;\n \n   // search\n-  const TyTy::BaseType *expected;\n+  TyTy::BaseType *expected;\n   Location locus;\n \n   // mutable fields"}, {"sha": "f7b21ea60d995f779a10c7bc51af14ae1c280e24", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.cc", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc?ref=fdbf789c2bb93baebd449744309d7c42bf2b36b8", "patch": "@@ -334,21 +334,29 @@ TyTy::BaseType *\n TypeCheckBase::coercion_site (HirId id, TyTy::BaseType *expected,\n \t\t\t      TyTy::BaseType *expr, Location locus)\n {\n+  rust_debug (\"coercion_site id={%u} expected={%s} expr={%s}\", id,\n+\t      expected->debug_str ().c_str (), expr->debug_str ().c_str ());\n+\n   auto context = TypeCheckContext::get ();\n   if (expected->get_kind () == TyTy::TypeKind::ERROR\n       || expr->get_kind () == TyTy::TypeKind::ERROR)\n     return expr;\n \n   // can we autoderef it?\n   auto result = AutoderefTypeCoercion::Coerce (expr, expected, locus);\n+\n+  // the result needs to be unified\n+  TyTy::BaseType *receiver = expr;\n   if (!result.is_error ())\n     {\n-      // save any adjustments\n-      context->insert_autoderef_mappings (id, std::move (result.adjustments));\n-      return expected->coerce (result.tyty);\n+      receiver = result.tyty;\n     }\n \n-  return expected->coerce (expr);\n+  rust_debug (\"coerce_default_unify(a={%s}, b={%s})\",\n+\t      receiver->debug_str ().c_str (), expected->debug_str ().c_str ());\n+  TyTy::BaseType *coerced = expected->unify (receiver);\n+  context->insert_autoderef_mappings (id, std::move (result.adjustments));\n+  return coerced;\n }\n \n void\n@@ -374,7 +382,8 @@ TypeCheckBase::resolve_generic_params (\n \t      {\n \t\tauto expr_type = TypeCheckExpr::Resolve (\n \t\t  param->get_default_expression ().get ());\n-\t\tspecified_type->coerce (expr_type);\n+\n+\t\tspecified_type->unify (expr_type);\n \t      }\n \n \t    context->insert_type (generic_param->get_mappings (),"}, {"sha": "b2261e8cdb36977bca1d247b0c35c7d096d1bcd1", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc?ref=fdbf789c2bb93baebd449744309d7c42bf2b36b8", "patch": "@@ -58,7 +58,7 @@ TypeCheckStructExpr::resolve (HIR::StructExprStructFields &struct_expr)\n       TyTy::BaseType *base_resolved\n \t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get ());\n       struct_def = static_cast<TyTy::ADTType *> (\n-\tstruct_path_resolved->coerce (base_resolved));\n+\tstruct_path_resolved->unify (base_resolved));\n       if (struct_def == nullptr)\n \t{\n \t  rust_fatal_error (struct_expr.struct_base->base_struct->get_locus (),"}, {"sha": "1ce82c943f5709e7ed64bfc337405481fb5ea32d", "filename": "gcc/rust/typecheck/rust-tyty-call.cc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc?ref=fdbf789c2bb93baebd449744309d7c42bf2b36b8", "patch": "@@ -136,8 +136,6 @@ TypeCheckCallExpr::visit (FnType &type)\n \t    }\n \t}\n \n-      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n-\n       i++;\n     }\n \n@@ -189,8 +187,6 @@ TypeCheckCallExpr::visit (FnPtr &type)\n \t  return;\n \t}\n \n-      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n-\n       i++;\n     }\n \n@@ -247,8 +243,6 @@ TypeCheckMethodCallExpr::visit (FnType &type)\n \t  return;\n \t}\n \n-      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n-\n       i++;\n     }\n "}, {"sha": "ed1636593c53059e71fc5da4d16522e407a3319c", "filename": "gcc/rust/typecheck/rust-tyty-coercion.h", "status": "removed", "additions": 0, "deletions": 1601, "changes": 1601, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f039ff9f6f18d15e32ddb54e3a6124802c45b7f/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f039ff9f6f18d15e32ddb54e3a6124802c45b7f/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h?ref=4f039ff9f6f18d15e32ddb54e3a6124802c45b7f", "patch": "@@ -1,1601 +0,0 @@\n-// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_TYTY_COERCION_RULES\n-#define RUST_TYTY_COERCION_RULES\n-\n-#include \"rust-diagnostics.h\"\n-#include \"rust-tyty.h\"\n-#include \"rust-tyty-visitor.h\"\n-#include \"rust-hir-map.h\"\n-#include \"rust-hir-type-check.h\"\n-#include \"rust-hir-type-bounds.h\"\n-\n-extern ::Backend *\n-rust_get_backend ();\n-\n-namespace Rust {\n-namespace TyTy {\n-\n-class BaseCoercionRules : public TyVisitor\n-{\n-public:\n-  virtual ~BaseCoercionRules () {}\n-\n-  virtual BaseType *coerce (BaseType *other)\n-  {\n-    if (other->get_kind () == TypeKind::PARAM)\n-      {\n-\tParamType *p = static_cast<ParamType *> (other);\n-\tif (p->can_resolve ())\n-\t  {\n-\t    other = p->resolve ();\n-\t  }\n-      }\n-    else if (other->get_kind () == TypeKind::PLACEHOLDER)\n-      {\n-\tPlaceholderType *p = static_cast<PlaceholderType *> (other);\n-\tif (p->can_resolve ())\n-\t  {\n-\t    other = p->resolve ();\n-\t    return get_base ()->coerce (other);\n-\t  }\n-      }\n-    else if (other->get_kind () == TypeKind::PROJECTION)\n-      {\n-\tProjectionType *p = static_cast<ProjectionType *> (other);\n-\tother = p->get ();\n-\treturn get_base ()->coerce (other);\n-      }\n-\n-    other->accept_vis (*this);\n-    if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n-      return resolved;\n-\n-    resolved->append_reference (get_base ()->get_ref ());\n-    resolved->append_reference (other->get_ref ());\n-    for (auto ref : get_base ()->get_combined_refs ())\n-      resolved->append_reference (ref);\n-    for (auto ref : other->get_combined_refs ())\n-      resolved->append_reference (ref);\n-\n-    bool result_resolved = resolved->get_kind () != TyTy::TypeKind::INFER;\n-    bool result_is_infer_var = resolved->get_kind () == TyTy::TypeKind::INFER;\n-    bool results_is_non_general_infer_var\n-      = (result_is_infer_var\n-\t && (static_cast<InferType *> (resolved))->get_infer_kind ()\n-\t      != TyTy::InferType::GENERAL);\n-    if (result_resolved || results_is_non_general_infer_var)\n-      {\n-\tfor (auto &ref : resolved->get_combined_refs ())\n-\t  {\n-\t    TyTy::BaseType *ref_tyty = nullptr;\n-\t    bool ok = context->lookup_type (ref, &ref_tyty);\n-\t    if (!ok)\n-\t      continue;\n-\n-\t    // if any of the types are inference variables lets fix them\n-\t    if (ref_tyty->get_kind () == TyTy::TypeKind::INFER)\n-\t      {\n-\t\tcontext->insert_type (\n-\t\t  Analysis::NodeMapping (mappings->get_current_crate (),\n-\t\t\t\t\t UNKNOWN_NODEID, ref,\n-\t\t\t\t\t UNKNOWN_LOCAL_DEFID),\n-\t\t  resolved->clone ());\n-\t      }\n-\t  }\n-      }\n-    return resolved;\n-  }\n-\n-  virtual void visit (TupleType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (ADTType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (InferType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (FnType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (FnPtr &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (ArrayType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (SliceType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (BoolType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (IntType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (UintType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (USizeType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (ISizeType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (FloatType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (ErrorType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (CharType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (ReferenceType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (PointerType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (ParamType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (StrType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (NeverType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (PlaceholderType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (ProjectionType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (DynamicObjectType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (ClosureType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"expected [%s] got [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-protected:\n-  BaseCoercionRules (BaseType *base)\n-    : mappings (Analysis::Mappings::get ()),\n-      context (Resolver::TypeCheckContext::get ()),\n-      resolved (new ErrorType (base->get_ref (), base->get_ref ()))\n-  {}\n-\n-  Analysis::Mappings *mappings;\n-  Resolver::TypeCheckContext *context;\n-\n-  /* Temporary storage for the result of a unification.\n-     We could return the result directly instead of storing it in the rule\n-     object, but that involves modifying the visitor pattern to accommodate\n-     the return value, which is too complex. */\n-  BaseType *resolved;\n-\n-private:\n-  /* Returns a pointer to the ty that created this rule. */\n-  virtual BaseType *get_base () = 0;\n-};\n-\n-class InferCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  InferCoercionRules (InferType *base) : BaseCoercionRules (base), base (base)\n-  {}\n-\n-  void visit (BoolType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-  void visit (IntType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind ()\n-\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-  void visit (UintType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind ()\n-\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-  void visit (USizeType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind ()\n-\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-  void visit (ISizeType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind ()\n-\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-  void visit (FloatType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-  void visit (ArrayType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-  void visit (SliceType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-  void visit (ADTType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-  void visit (TupleType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    switch (base->get_infer_kind ())\n-      {\n-      case InferType::InferTypeKind::GENERAL:\n-\tresolved = type.clone ();\n-\treturn;\n-\n-\tcase InferType::InferTypeKind::INTEGRAL: {\n-\t  if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n-\t    {\n-\t      resolved = type.clone ();\n-\t      return;\n-\t    }\n-\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n-\t    {\n-\t      resolved = base->clone ();\n-\t      return;\n-\t    }\n-\t}\n-\tbreak;\n-\n-\tcase InferType::InferTypeKind::FLOAT: {\n-\t  if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-\t    {\n-\t      resolved = type.clone ();\n-\t      return;\n-\t    }\n-\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n-\t    {\n-\t      resolved = base->clone ();\n-\t      return;\n-\t    }\n-\t}\n-\tbreak;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-  void visit (CharType &type) override\n-  {\n-    {\n-      bool is_valid\n-\t= (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-      if (is_valid)\n-\t{\n-\t  resolved = type.clone ();\n-\t  return;\n-\t}\n-\n-      BaseCoercionRules::visit (type);\n-    }\n-  }\n-\n-  void visit (ReferenceType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-  void visit (PointerType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-  void visit (ParamType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-  void visit (DynamicObjectType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-  void visit (ClosureType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  InferType *base;\n-};\n-\n-class FnCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  FnCoercionRules (FnType *base) : BaseCoercionRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (FnType &type) override\n-  {\n-    if (base->num_params () != type.num_params ())\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    for (size_t i = 0; i < base->num_params (); i++)\n-      {\n-\tauto a = base->param_at (i).second;\n-\tauto b = type.param_at (i).second;\n-\n-\tauto unified_param = a->unify (b);\n-\tif (unified_param == nullptr)\n-\t  {\n-\t    BaseCoercionRules::visit (type);\n-\t    return;\n-\t  }\n-      }\n-\n-    auto unified_return\n-      = base->get_return_type ()->unify (type.get_return_type ());\n-    if (unified_return == nullptr)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  FnType *base;\n-};\n-\n-class FnptrCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  FnptrCoercionRules (FnPtr *base) : BaseCoercionRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (FnPtr &type) override\n-  {\n-    auto this_ret_type = base->get_return_type ();\n-    auto other_ret_type = type.get_return_type ();\n-    auto unified_result = this_ret_type->unify (other_ret_type);\n-    if (unified_result == nullptr\n-\t|| unified_result->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    if (base->num_params () != type.num_params ())\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    for (size_t i = 0; i < base->num_params (); i++)\n-      {\n-\tauto this_param = base->param_at (i);\n-\tauto other_param = type.param_at (i);\n-\tauto unified_param = this_param->unify (other_param);\n-\tif (unified_param == nullptr\n-\t    || unified_param->get_kind () == TypeKind::ERROR)\n-\t  {\n-\t    BaseCoercionRules::visit (type);\n-\t    return;\n-\t  }\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (FnType &type) override\n-  {\n-    auto this_ret_type = base->get_return_type ();\n-    auto other_ret_type = type.get_return_type ();\n-    auto unified_result = this_ret_type->unify (other_ret_type);\n-    if (unified_result == nullptr\n-\t|| unified_result->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    if (base->num_params () != type.num_params ())\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    for (size_t i = 0; i < base->num_params (); i++)\n-      {\n-\tauto this_param = base->param_at (i);\n-\tauto other_param = type.param_at (i).second;\n-\tauto unified_param = this_param->unify (other_param);\n-\tif (unified_param == nullptr\n-\t    || unified_param->get_kind () == TypeKind::ERROR)\n-\t  {\n-\t    BaseCoercionRules::visit (type);\n-\t    return;\n-\t  }\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  FnPtr *base;\n-};\n-\n-class ClosureCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  ClosureCoercionRules (ClosureType *base)\n-    : BaseCoercionRules (base), base (base)\n-  {}\n-\n-  // TODO\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ClosureType *base;\n-};\n-\n-class ArrayCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  ArrayCoercionRules (ArrayType *base) : BaseCoercionRules (base), base (base)\n-  {}\n-\n-  void visit (ArrayType &type) override\n-  {\n-    // check base type\n-    auto base_resolved\n-      = base->get_element_type ()->unify (type.get_element_type ());\n-    if (base_resolved == nullptr)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved\n-      = new ArrayType (type.get_ref (), type.get_ty_ref (),\n-\t\t       type.get_ident ().locus, type.get_capacity_expr (),\n-\t\t       TyVar (base_resolved->get_ref ()));\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ArrayType *base;\n-};\n-\n-class SliceCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  SliceCoercionRules (SliceType *base) : BaseCoercionRules (base), base (base)\n-  {}\n-\n-  void visit (SliceType &type) override\n-  {\n-    // check base type\n-    auto base_resolved\n-      = base->get_element_type ()->unify (type.get_element_type ());\n-    if (base_resolved == nullptr)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = new SliceType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t      type.get_ident ().locus,\n-\t\t\t      TyVar (base_resolved->get_ref ()));\n-  }\n-\n-  void visit (ArrayType &type) override\n-  {\n-    // check base type\n-    auto base_resolved\n-      = base->get_element_type ()->unify (type.get_element_type ());\n-    if (base_resolved == nullptr)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = new SliceType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t      type.get_ident ().locus,\n-\t\t\t      TyVar (base_resolved->get_ref ()));\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  SliceType *base;\n-};\n-\n-class BoolCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  BoolCoercionRules (BoolType *base) : BaseCoercionRules (base), base (base) {}\n-\n-  void visit (BoolType &type) override\n-  {\n-    resolved = new BoolType (type.get_ref (), type.get_ty_ref ());\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    switch (type.get_infer_kind ())\n-      {\n-      case InferType::InferTypeKind::GENERAL:\n-\tresolved = base->clone ();\n-\tbreak;\n-\n-      default:\n-\tBaseCoercionRules::visit (type);\n-\tbreak;\n-      }\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  BoolType *base;\n-};\n-\n-class IntCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  IntCoercionRules (IntType *base) : BaseCoercionRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    // cant assign a float inference variable\n-    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (IntType &type) override\n-  {\n-    if (type.get_int_kind () != base->get_int_kind ())\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved\n-      = new IntType (type.get_ref (), type.get_ty_ref (), type.get_int_kind ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  IntType *base;\n-};\n-\n-class UintCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  UintCoercionRules (UintType *base) : BaseCoercionRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    // cant assign a float inference variable\n-    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (UintType &type) override\n-  {\n-    if (type.get_uint_kind () != base->get_uint_kind ())\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = new UintType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t     type.get_uint_kind ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  UintType *base;\n-};\n-\n-class FloatCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  FloatCoercionRules (FloatType *base) : BaseCoercionRules (base), base (base)\n-  {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (FloatType &type) override\n-  {\n-    if (type.get_float_kind () != base->get_float_kind ())\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = new FloatType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t      type.get_float_kind ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  FloatType *base;\n-};\n-\n-class ADTCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  ADTCoercionRules (ADTType *base) : BaseCoercionRules (base), base (base) {}\n-\n-  void visit (ADTType &type) override\n-  {\n-    if (base->get_adt_kind () != type.get_adt_kind ())\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    if (base->number_of_variants () != type.number_of_variants ())\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    for (size_t i = 0; i < type.number_of_variants (); ++i)\n-      {\n-\tTyTy::VariantDef *a = base->get_variants ().at (i);\n-\tTyTy::VariantDef *b = type.get_variants ().at (i);\n-\n-\tif (a->num_fields () != b->num_fields ())\n-\t  {\n-\t    BaseCoercionRules::visit (type);\n-\t    return;\n-\t  }\n-\n-\tfor (size_t j = 0; j < a->num_fields (); j++)\n-\t  {\n-\t    TyTy::StructFieldType *base_field = a->get_field_at_index (j);\n-\t    TyTy::StructFieldType *other_field = b->get_field_at_index (j);\n-\n-\t    TyTy::BaseType *this_field_ty = base_field->get_field_type ();\n-\t    TyTy::BaseType *other_field_ty = other_field->get_field_type ();\n-\n-\t    BaseType *unified_ty = this_field_ty->unify (other_field_ty);\n-\t    if (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t      return;\n-\t  }\n-      }\n-\n-    // generic args for the unit-struct case\n-    if (type.is_unit () && base->is_unit ())\n-      {\n-\trust_assert (type.get_num_substitutions ()\n-\t\t     == base->get_num_substitutions ());\n-\n-\tfor (size_t i = 0; i < type.get_num_substitutions (); i++)\n-\t  {\n-\t    auto &a = base->get_substs ().at (i);\n-\t    auto &b = type.get_substs ().at (i);\n-\n-\t    auto pa = a.get_param_ty ();\n-\t    auto pb = b.get_param_ty ();\n-\n-\t    auto res = pa->unify (pb);\n-\t    if (res->get_kind () == TyTy::TypeKind::ERROR)\n-\t      {\n-\t\treturn;\n-\t      }\n-\t  }\n-      }\n-\n-    resolved = type.clone ();\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ADTType *base;\n-};\n-\n-class TupleCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  TupleCoercionRules (TupleType *base) : BaseCoercionRules (base), base (base)\n-  {}\n-\n-  void visit (TupleType &type) override\n-  {\n-    if (base->num_fields () != type.num_fields ())\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    std::vector<TyVar> fields;\n-    for (size_t i = 0; i < base->num_fields (); i++)\n-      {\n-\tBaseType *bo = base->get_field (i);\n-\tBaseType *fo = type.get_field (i);\n-\n-\tBaseType *unified_ty = bo->unify (fo);\n-\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n-\n-\tfields.push_back (TyVar (unified_ty->get_ref ()));\n-      }\n-\n-    resolved = new TyTy::TupleType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t\t    type.get_ident ().locus, fields);\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  TupleType *base;\n-};\n-\n-class USizeCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  USizeCoercionRules (USizeType *base) : BaseCoercionRules (base), base (base)\n-  {}\n-\n-  void visit (InferType &type) override\n-  {\n-    // cant assign a float inference variable\n-    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (USizeType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  USizeType *base;\n-};\n-\n-class ISizeCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  ISizeCoercionRules (ISizeType *base) : BaseCoercionRules (base), base (base)\n-  {}\n-\n-  void visit (InferType &type) override\n-  {\n-    // cant assign a float inference variable\n-    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (ISizeType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ISizeType *base;\n-};\n-\n-class CharCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  CharCoercionRules (CharType *base) : BaseCoercionRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (CharType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  CharType *base;\n-};\n-\n-class ReferenceCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  ReferenceCoercionRules (ReferenceType *base)\n-    : BaseCoercionRules (base), base (base)\n-  {}\n-\n-  void visit (ReferenceType &type) override\n-  {\n-    auto base_type = base->get_base ();\n-    auto other_base_type = type.get_base ();\n-\n-    TyTy::BaseType *base_resolved = base_type->coerce (other_base_type);\n-    if (base_resolved == nullptr\n-\t|| base_resolved->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    // we can allow for mutability changes here by casting down from mutability\n-    // eg:  mut vs const, we cant take a mutable reference from a const\n-    // eg:  const vs mut we can take a const reference from a mutable one\n-    if (!base->is_mutable () || (base->is_mutable () == type.is_mutable ()))\n-      {\n-\tresolved = new ReferenceType (base->get_ref (), base->get_ty_ref (),\n-\t\t\t\t      TyVar (base_resolved->get_ref ()),\n-\t\t\t\t      base->mutability ());\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ReferenceType *base;\n-};\n-\n-class PointerCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  PointerCoercionRules (PointerType *base)\n-    : BaseCoercionRules (base), base (base)\n-  {}\n-\n-  void visit (ReferenceType &type) override\n-  {\n-    auto base_type = base->get_base ();\n-    auto other_base_type = type.get_base ();\n-\n-    TyTy::BaseType *base_resolved = base_type->unify (other_base_type);\n-    if (base_resolved == nullptr\n-\t|| base_resolved->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    // we can allow for mutability changes here by casting down from mutability\n-    // eg:  mut vs const, we cant take a mutable pointer from a const\n-    // eg:  const vs mut we can take a const reference from a mutable one\n-    if (!base->is_mutable () || (base->is_mutable () == type.is_mutable ()))\n-      {\n-\tresolved = new PointerType (base->get_ref (), base->get_ty_ref (),\n-\t\t\t\t    TyVar (base_resolved->get_ref ()),\n-\t\t\t\t    base->mutability ());\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-  void visit (PointerType &type) override\n-  {\n-    auto base_type = base->get_base ();\n-    auto other_base_type = type.get_base ();\n-\n-    TyTy::BaseType *base_resolved = base_type->unify (other_base_type);\n-    if (base_resolved == nullptr\n-\t|| base_resolved->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    // we can allow for mutability changes here by casting down from mutability\n-    // eg:  mut vs const, we cant take a mutable pointer from a const one\n-    // eg:  const vs mut we can take a const reference from a mutable one\n-    if (!base->is_mutable () || (base->is_mutable () == type.is_mutable ()))\n-      {\n-\tresolved = new PointerType (base->get_ref (), base->get_ty_ref (),\n-\t\t\t\t    TyVar (base_resolved->get_ref ()),\n-\t\t\t\t    base->mutability ());\n-\treturn;\n-      }\n-\n-    BaseCoercionRules::visit (type);\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  PointerType *base;\n-};\n-\n-class ParamCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  ParamCoercionRules (ParamType *base) : BaseCoercionRules (base), base (base)\n-  {}\n-\n-  // param types are a placeholder we shouldn't have cases where we unify\n-  // against it. eg: struct foo<T> { a: T }; When we invoke it we can do either:\n-  //\n-  // foo<i32>{ a: 123 }.\n-  // Then this enforces the i32 type to be referenced on the\n-  // field via an hirid.\n-  //\n-  // rust also allows for a = foo{a:123}; Where we can use an Inference Variable\n-  // to handle the typing of the struct\n-  BaseType *coerce (BaseType *other) override final\n-  {\n-    if (!base->can_resolve ())\n-      return BaseCoercionRules::coerce (other);\n-\n-    auto lookup = base->resolve ();\n-    return lookup->unify (other);\n-  }\n-\n-  void visit (ParamType &type) override\n-  {\n-    if (base->get_symbol ().compare (type.get_symbol ()) != 0)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = type.clone ();\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ParamType *base;\n-};\n-\n-class StrCoercionRules : public BaseCoercionRules\n-{\n-  // FIXME we will need a enum for the StrType like ByteBuf etc..\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  StrCoercionRules (StrType *base) : BaseCoercionRules (base), base (base) {}\n-\n-  void visit (StrType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  StrType *base;\n-};\n-\n-class NeverCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  NeverCoercionRules (NeverType *base) : BaseCoercionRules (base), base (base)\n-  {}\n-\n-  virtual void visit (NeverType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  NeverType *base;\n-};\n-\n-class PlaceholderCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  PlaceholderCoercionRules (PlaceholderType *base)\n-    : BaseCoercionRules (base), base (base)\n-  {}\n-\n-  BaseType *coerce (BaseType *other) override final\n-  {\n-    if (!base->can_resolve ())\n-      return BaseCoercionRules::coerce (other);\n-\n-    BaseType *lookup = base->resolve ();\n-    return lookup->unify (other);\n-  }\n-\n-  void visit (PlaceholderType &type) override\n-  {\n-    if (base->get_symbol ().compare (type.get_symbol ()) != 0)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = type.clone ();\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  PlaceholderType *base;\n-};\n-\n-class DynamicCoercionRules : public BaseCoercionRules\n-{\n-  using Rust::TyTy::BaseCoercionRules::visit;\n-\n-public:\n-  DynamicCoercionRules (DynamicObjectType *base)\n-    : BaseCoercionRules (base), base (base)\n-  {}\n-\n-  void visit (DynamicObjectType &type) override\n-  {\n-    if (base->num_specified_bounds () != type.num_specified_bounds ())\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    if (!base->bounds_compatible (type, ref_locus, true))\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-  }\n-\n-  void visit (ADTType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    bool ok = base->bounds_compatible (type, ref_locus, true);\n-    if (!ok)\n-      return;\n-\n-    resolved = base->clone ();\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  DynamicObjectType *base;\n-};\n-\n-} // namespace TyTy\n-} // namespace Rust\n-\n-#endif // RUST_TYTY_COERCION_RULES"}, {"sha": "24969dbdac68faf3705d9e370c4fb6f43c58b2a0", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 3, "deletions": 169, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=fdbf789c2bb93baebd449744309d7c42bf2b36b8", "patch": "@@ -23,7 +23,6 @@\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-tyty-rules.h\"\n #include \"rust-tyty-cmp.h\"\n-#include \"rust-tyty-coercion.h\"\n #include \"rust-tyty-cast.h\"\n #include \"rust-hir-map.h\"\n #include \"rust-substitution-mapper.h\"\n@@ -418,13 +417,6 @@ InferType::can_eq (const BaseType *other, bool emit_errors) const\n   return r.can_eq (other);\n }\n \n-BaseType *\n-InferType::coerce (BaseType *other)\n-{\n-  InferCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n InferType::cast (BaseType *other)\n {\n@@ -526,12 +518,6 @@ ErrorType::can_eq (const BaseType *other, bool emit_errors) const\n   return get_kind () == other->get_kind ();\n }\n \n-BaseType *\n-ErrorType::coerce (BaseType *other)\n-{\n-  return this;\n-}\n-\n BaseType *\n ErrorType::cast (BaseType *other)\n {\n@@ -998,13 +984,6 @@ ADTType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-ADTType::coerce (BaseType *other)\n-{\n-  ADTCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n ADTType::cast (BaseType *other)\n {\n@@ -1212,13 +1191,6 @@ TupleType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-TupleType::coerce (BaseType *other)\n-{\n-  TupleCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n TupleType::cast (BaseType *other)\n {\n@@ -1333,13 +1305,6 @@ FnType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-FnType::coerce (BaseType *other)\n-{\n-  FnCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n FnType::cast (BaseType *other)\n {\n@@ -1578,13 +1543,6 @@ FnPtr::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-FnPtr::coerce (BaseType *other)\n-{\n-  FnptrCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n FnPtr::cast (BaseType *other)\n {\n@@ -1678,18 +1636,12 @@ ClosureType::can_eq (const BaseType *other, bool emit_errors) const\n   return r.can_eq (other);\n }\n \n-BaseType *\n-ClosureType::coerce (BaseType *other)\n-{\n-  ClosureCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n ClosureType::cast (BaseType *other)\n {\n-  ClosureCoercionRules r (this);\n-  return r.coerce (other);\n+  // FIXME\n+  gcc_unreachable ();\n+  return nullptr;\n }\n \n bool\n@@ -1744,13 +1696,6 @@ ArrayType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-ArrayType::coerce (BaseType *other)\n-{\n-  ArrayCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n ArrayType::cast (BaseType *other)\n {\n@@ -1841,13 +1786,6 @@ SliceType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-SliceType::coerce (BaseType *other)\n-{\n-  SliceCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n SliceType::cast (BaseType *other)\n {\n@@ -1938,13 +1876,6 @@ BoolType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-BoolType::coerce (BaseType *other)\n-{\n-  BoolCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n BoolType::cast (BaseType *other)\n {\n@@ -2010,13 +1941,6 @@ IntType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-IntType::coerce (BaseType *other)\n-{\n-  IntCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n IntType::cast (BaseType *other)\n {\n@@ -2093,13 +2017,6 @@ UintType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-UintType::coerce (BaseType *other)\n-{\n-  UintCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n UintType::cast (BaseType *other)\n {\n@@ -2170,13 +2087,6 @@ FloatType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-FloatType::coerce (BaseType *other)\n-{\n-  FloatCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n FloatType::cast (BaseType *other)\n {\n@@ -2239,13 +2149,6 @@ USizeType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-USizeType::coerce (BaseType *other)\n-{\n-  USizeCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n USizeType::cast (BaseType *other)\n {\n@@ -2297,13 +2200,6 @@ ISizeType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-ISizeType::coerce (BaseType *other)\n-{\n-  ISizeCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n ISizeType::cast (BaseType *other)\n {\n@@ -2355,13 +2251,6 @@ CharType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-CharType::coerce (BaseType *other)\n-{\n-  CharCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n CharType::cast (BaseType *other)\n {\n@@ -2414,13 +2303,6 @@ ReferenceType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-ReferenceType::coerce (BaseType *other)\n-{\n-  ReferenceCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n ReferenceType::cast (BaseType *other)\n {\n@@ -2511,13 +2393,6 @@ PointerType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-PointerType::coerce (BaseType *other)\n-{\n-  PointerCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n PointerType::cast (BaseType *other)\n {\n@@ -2622,13 +2497,6 @@ ParamType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-ParamType::coerce (BaseType *other)\n-{\n-  ParamCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n ParamType::cast (BaseType *other)\n {\n@@ -2768,13 +2636,6 @@ StrType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-StrType::coerce (BaseType *other)\n-{\n-  StrCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n StrType::cast (BaseType *other)\n {\n@@ -2820,13 +2681,6 @@ NeverType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-NeverType::coerce (BaseType *other)\n-{\n-  NeverCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n NeverType::cast (BaseType *other)\n {\n@@ -2881,13 +2735,6 @@ PlaceholderType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-PlaceholderType::coerce (BaseType *other)\n-{\n-  PlaceholderCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n PlaceholderType::cast (BaseType *other)\n {\n@@ -2992,12 +2839,6 @@ ProjectionType::unify (BaseType *other)\n   return base->unify (other);\n }\n \n-BaseType *\n-ProjectionType::coerce (BaseType *other)\n-{\n-  return base->coerce (other);\n-}\n-\n BaseType *\n ProjectionType::cast (BaseType *other)\n {\n@@ -3128,13 +2969,6 @@ DynamicObjectType::can_eq (const BaseType *other, bool emit_errors) const\n   return r.can_eq (other);\n }\n \n-BaseType *\n-DynamicObjectType::coerce (BaseType *other)\n-{\n-  DynamicCoercionRules r (this);\n-  return r.coerce (other);\n-}\n-\n BaseType *\n DynamicObjectType::cast (BaseType *other)\n {"}, {"sha": "56a0e05cd94183dd4b17bd349d7e79169f291d07", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbf789c2bb93baebd449744309d7c42bf2b36b8/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=fdbf789c2bb93baebd449744309d7c42bf2b36b8", "patch": "@@ -180,9 +180,6 @@ class BaseType : public TypeBoundsMappings\n   // checks\n   virtual bool can_eq (const BaseType *other, bool emit_errors) const = 0;\n \n-  // this is the base coercion interface for types\n-  virtual BaseType *coerce (BaseType *other) = 0;\n-\n   // this is the cast interface for TypeCastExpr\n   virtual BaseType *cast (BaseType *other) = 0;\n \n@@ -350,7 +347,6 @@ class InferType : public BaseType\n \n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n@@ -390,7 +386,7 @@ class ErrorType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n@@ -434,7 +430,7 @@ class ParamType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n@@ -534,7 +530,7 @@ class TupleType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1363,7 +1359,7 @@ class ADTType : public BaseType, public SubstitutionRef\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1500,7 +1496,7 @@ class FnType : public BaseType, public SubstitutionRef\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1622,7 +1618,7 @@ class FnPtr : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1696,7 +1692,7 @@ class ClosureType : public BaseType, public SubstitutionRef\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1762,7 +1758,7 @@ class ArrayType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1812,7 +1808,7 @@ class SliceType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1859,7 +1855,7 @@ class BoolType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n@@ -1905,7 +1901,7 @@ class IntType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   IntKind get_int_kind () const { return int_kind; }\n@@ -1958,7 +1954,7 @@ class UintType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   UintKind get_uint_kind () const { return uint_kind; }\n@@ -2009,7 +2005,7 @@ class FloatType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   FloatKind get_float_kind () const { return float_kind; }\n@@ -2050,7 +2046,7 @@ class USizeType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n@@ -2084,7 +2080,7 @@ class ISizeType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n@@ -2118,7 +2114,7 @@ class CharType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n@@ -2152,7 +2148,7 @@ class StrType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -2197,7 +2193,7 @@ class ReferenceType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -2285,7 +2281,7 @@ class PointerType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -2374,7 +2370,7 @@ class NeverType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n@@ -2416,7 +2412,7 @@ class PlaceholderType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n@@ -2492,7 +2488,7 @@ class ProjectionType : public BaseType, public SubstitutionRef\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n@@ -2550,7 +2546,7 @@ class DynamicObjectType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *cast (BaseType *other) override;\n   bool is_equal (const BaseType &other) const override;\n "}]}