{"sha": "6728ee79872ffd3dbcf858dab076c96c71ec95e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcyOGVlNzk4NzJmZmQzZGJjZjg1OGRhYjA3NmM5NmM3MWVjOTVlNQ==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2009-10-08T16:03:11Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2009-10-08T16:03:11Z"}, "message": "re PR middle-end/41573 (segfault in trunk related to strings)\n\n\tPR middle-end/41573\n\t* builtins.c (fold_builtin_isascii): Use fold_build2.\n\t(fold_builtin_isdigit): Ditto.\n\t* except.c (duplicate_eh_regions_1): Tolerate NULL labels.\n\t* tree-cfg.c (struct rus_data, remove_useless_stmts_warn_notreached,\n\tremove_useless_stmts_cond, remove_useless_stmts_tf,\n\tremove_useless_stmts_tc, remove_useless_stmts_bind,\n\tremove_useless_stmts_goto, remove_useless_stmts_label,\n\tremove_useless_stmts_1, remove_useless_stmts,\n\tpass_remove_useless_stmts): Remove.\n\t* tree-pass.h (pass_remove_useless_stmts): Don't declare.\n\t* passes.c (init_optimization_passes): Don't add\n\tpass_remove_useless_stmts.\n\t* tree-eh.c (lower_eh_constructs_2): Handle empty cleanups.\n\t* tree.c (free_lang_data_in_decl): Don't clear DECL_INITIAL of\n\tstatic constants.\n\t* lto-symtab.c (lto_symtab_register_decl): Accepts DECL_INITIAL\n\tfor static constants.\n\t* lto-streamer-out.c (output_gimple_stmt): Handle GIMPLE_NOP.\n\t* lto-streamer-in.c (input_gimple_stmt): Handle GIMPLE_NOP.\n\ntestsuite/\n\t* gcc.dg/tree-ssa/foldstring-1.c: Use fre dump.\n\t* gcc.dg/tree-ssa/useless-1.c: Use gimple dump.\n\t* gcc.dg/pr41573.c: New test.\n\nFrom-SVN: r152563", "tree": {"sha": "dfbfdde0ac425b160f559d82eab975a3ba3e115a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfbfdde0ac425b160f559d82eab975a3ba3e115a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6728ee79872ffd3dbcf858dab076c96c71ec95e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6728ee79872ffd3dbcf858dab076c96c71ec95e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6728ee79872ffd3dbcf858dab076c96c71ec95e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6728ee79872ffd3dbcf858dab076c96c71ec95e5/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0d0bfe1795ba93c2af0fca2ca68a025c5cd4c82b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d0bfe1795ba93c2af0fca2ca68a025c5cd4c82b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d0bfe1795ba93c2af0fca2ca68a025c5cd4c82b"}], "stats": {"total": 718, "additions": 88, "deletions": 630}, "files": [{"sha": "b21fbc2b4beedd32e6b12f1022ed6e73122dbefb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6728ee79872ffd3dbcf858dab076c96c71ec95e5", "patch": "@@ -1,3 +1,26 @@\n+2009-10-08  Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/41573\n+\t* builtins.c (fold_builtin_isascii): Use fold_build2.\n+\t(fold_builtin_isdigit): Ditto.\n+\t* except.c (duplicate_eh_regions_1): Tolerate NULL labels.\n+\t* tree-cfg.c (struct rus_data, remove_useless_stmts_warn_notreached,\n+\tremove_useless_stmts_cond, remove_useless_stmts_tf,\n+\tremove_useless_stmts_tc, remove_useless_stmts_bind,\n+\tremove_useless_stmts_goto, remove_useless_stmts_label,\n+\tremove_useless_stmts_1, remove_useless_stmts,\n+\tpass_remove_useless_stmts): Remove.\n+\t* tree-pass.h (pass_remove_useless_stmts): Don't declare.\n+\t* passes.c (init_optimization_passes): Don't add\n+\tpass_remove_useless_stmts.\n+\t* tree-eh.c (lower_eh_constructs_2): Handle empty cleanups.\n+\t* tree.c (free_lang_data_in_decl): Don't clear DECL_INITIAL of\n+\tstatic constants.\n+\t* lto-symtab.c (lto_symtab_register_decl): Accepts DECL_INITIAL\n+\tfor static constants.\n+\t* lto-streamer-out.c (output_gimple_stmt): Handle GIMPLE_NOP.\n+\t* lto-streamer-in.c (input_gimple_stmt): Handle GIMPLE_NOP.\n+\n 2009-10-08  Richard Guenther  <rguenther@suse.de>\n \n \t* gimple.c (free_gimple_type_tables): New function."}, {"sha": "55228d22c40ffa24296df651b92a61d3b3009642", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=6728ee79872ffd3dbcf858dab076c96c71ec95e5", "patch": "@@ -9238,9 +9238,9 @@ fold_builtin_isascii (location_t loc, tree arg)\n   else\n     {\n       /* Transform isascii(c) -> ((c & ~0x7f) == 0).  */\n-      arg = build2 (BIT_AND_EXPR, integer_type_node, arg,\n-\t\t    build_int_cst (NULL_TREE,\n-\t\t\t\t   ~ (unsigned HOST_WIDE_INT) 0x7f));\n+      arg = fold_build2 (BIT_AND_EXPR, integer_type_node, arg,\n+\t\t\t build_int_cst (NULL_TREE,\n+\t\t\t\t\t~ (unsigned HOST_WIDE_INT) 0x7f));\n       return fold_build2_loc (loc, EQ_EXPR, integer_type_node,\n \t\t\t  arg, integer_zero_node);\n     }\n@@ -9278,8 +9278,8 @@ fold_builtin_isdigit (location_t loc, tree arg)\n \treturn NULL_TREE;\n \n       arg = fold_convert_loc (loc, unsigned_type_node, arg);\n-      arg = build2 (MINUS_EXPR, unsigned_type_node, arg,\n-\t\t    build_int_cst (unsigned_type_node, target_digit0));\n+      arg = fold_build2 (MINUS_EXPR, unsigned_type_node, arg,\n+\t\t\t build_int_cst (unsigned_type_node, target_digit0));\n       return fold_build2_loc (loc, LE_EXPR, integer_type_node, arg,\n \t\t\t  build_int_cst (unsigned_type_node, 9));\n     }"}, {"sha": "b25e48b6c9bcebedbadd8ef13096f8d8bccaf394", "filename": "gcc/except.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=6728ee79872ffd3dbcf858dab076c96c71ec95e5", "patch": "@@ -552,8 +552,11 @@ duplicate_eh_regions_1 (struct duplicate_eh_regions_data *data,\n \n     case ERT_ALLOWED_EXCEPTIONS:\n       new_r->u.allowed.type_list = old_r->u.allowed.type_list;\n-      new_r->u.allowed.label\n-\t= data->label_map (old_r->u.allowed.label, data->label_map_data);\n+      if (old_r->u.allowed.label)\n+\tnew_r->u.allowed.label\n+\t    = data->label_map (old_r->u.allowed.label, data->label_map_data);\n+      else\n+\tnew_r->u.allowed.label = NULL_TREE;\n       break;\n \n     case ERT_MUST_NOT_THROW:"}, {"sha": "f41aa75b8238447dd01ee32dd91a6389a1adb680", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=6728ee79872ffd3dbcf858dab076c96c71ec95e5", "patch": "@@ -942,6 +942,7 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n \t}\n       break;\n \n+    case GIMPLE_NOP:\n     case GIMPLE_PREDICT:\n       break;\n "}, {"sha": "499734f4988c5cc1a0eb35835424b5e9a6867596", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=6728ee79872ffd3dbcf858dab076c96c71ec95e5", "patch": "@@ -1692,6 +1692,7 @@ output_gimple_stmt (struct output_block *ob, gimple stmt)\n \t}\n       break;\n \n+    case GIMPLE_NOP:\n     case GIMPLE_PREDICT:\n       break;\n "}, {"sha": "2a0783a12beddf3d90a333aae6ddd09a898228ee", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=6728ee79872ffd3dbcf858dab076c96c71ec95e5", "patch": "@@ -323,8 +323,10 @@ lto_symtab_register_decl (tree decl,\n \t      && (TREE_CODE (decl) == VAR_DECL\n \t\t  || TREE_CODE (decl) == FUNCTION_DECL)\n \t      && DECL_ASSEMBLER_NAME_SET_P (decl));\n-  if (TREE_CODE (decl) == VAR_DECL)\n-    gcc_assert (!(DECL_EXTERNAL (decl) && DECL_INITIAL (decl)));\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && DECL_INITIAL (decl))\n+    gcc_assert (!DECL_EXTERNAL (decl)\n+\t\t|| (TREE_STATIC (decl) && TREE_READONLY (decl)));\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     gcc_assert (!DECL_ABSTRACT (decl));\n "}, {"sha": "5ed120607390787543179ef5469bd288954f88be", "filename": "gcc/passes.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=6728ee79872ffd3dbcf858dab076c96c71ec95e5", "patch": "@@ -683,7 +683,6 @@ init_optimization_passes (void)\n   p = &all_lowering_passes;\n   NEXT_PASS (pass_warn_unused_result);\n   NEXT_PASS (pass_diagnose_omp_blocks);\n-  NEXT_PASS (pass_remove_useless_stmts);\n   NEXT_PASS (pass_mudflap_1);\n   NEXT_PASS (pass_lower_omp);\n   NEXT_PASS (pass_lower_cf);"}, {"sha": "bf7e5ba08f4d2ca8ea59a58814144014369cecc8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6728ee79872ffd3dbcf858dab076c96c71ec95e5", "patch": "@@ -1,3 +1,10 @@\n+2009-10-08  Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/41573\n+\t* gcc.dg/tree-ssa/foldstring-1.c: Use fre dump.\n+\t* gcc.dg/tree-ssa/useless-1.c: Use gimple dump.\n+\t* gcc.dg/pr41573.c: New test.\n+\n 2009-10-07  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/41182"}, {"sha": "52961db8f2214fecac39d40e481fe1b655812137", "filename": "gcc/testsuite/gcc.dg/pr41573.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41573.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41573.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41573.c?ref=6728ee79872ffd3dbcf858dab076c96c71ec95e5", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+__inline __attribute__ ((__always_inline__)) char *\n+strcpy (char *__dest, __const char *__src)\n+{\n+  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));\n+}\n+\n+const char* get_attr(unsigned attr)\n+{\n+    static char tmp[256];\n+\n+    strcpy(tmp, \"\");\n+    return tmp;\n+}"}, {"sha": "fa64ae14cc42449e98349420b87b55bd2afc034e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/foldstring-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldstring-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldstring-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldstring-1.c?ref=6728ee79872ffd3dbcf858dab076c96c71ec95e5", "patch": "@@ -1,11 +1,11 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-useless\" } */\n+/* { dg-options \"-O1 -fdump-tree-fre\" } */\n \n void\n arf ()\n {\n   if (\"\"[0] == 0)\n     blah ();\n }\n-/* { dg-final { scan-tree-dump-times \"= 0;\" 1 \"useless\"} } */ \n-/* { dg-final { cleanup-tree-dump \"useless\" } } */\n+/* { dg-final { scan-tree-dump-times \"= 0;\" 1 \"fre\"} } */ \n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "68eab70046ca161c0cf55d8a33a670a2954d84bb", "filename": "gcc/testsuite/gcc.dg/tree-ssa/useless-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fuseless-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fuseless-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fuseless-1.c?ref=6728ee79872ffd3dbcf858dab076c96c71ec95e5", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-useless\" } */\n+/* { dg-options \"-O1 -fdump-tree-gimple\" } */\n \n void\n foo (void)\n@@ -13,5 +13,5 @@ foo (void)\n    in the loop exit condition, it would be re-introduced during\n    GIMPLE lowering, at the cost of an extra statement, label,\n    and basic block.  */\n-/* { dg-final { scan-tree-dump-times \"goto\" 3 \"useless\"} } */ \n-/* { dg-final { cleanup-tree-dump \"useless\" } } */\n+/* { dg-final { scan-tree-dump-times \"goto\" 3 \"gimple\"} } */ \n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "1c820a3e3c567a46df8a0e5b709da92345df5190", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 0, "deletions": 599, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=6728ee79872ffd3dbcf858dab076c96c71ec95e5", "patch": "@@ -1715,423 +1715,6 @@ single_noncomplex_succ (basic_block bb)\n   return bb;\n }\n \n-\n-/* Walk the function tree removing unnecessary statements.\n-\n-     * Empty statement nodes are removed\n-\n-     * Unnecessary TRY_FINALLY and TRY_CATCH blocks are removed\n-\n-     * Unnecessary COND_EXPRs are removed\n-\n-     * Some unnecessary BIND_EXPRs are removed\n-\n-     * GOTO_EXPRs immediately preceding destination are removed.\n-\n-   Clearly more work could be done.  The trick is doing the analysis\n-   and removal fast enough to be a net improvement in compile times.\n-\n-   Note that when we remove a control structure such as a COND_EXPR\n-   BIND_EXPR, or TRY block, we will need to repeat this optimization pass\n-   to ensure we eliminate all the useless code.  */\n-\n-struct rus_data\n-{\n-  bool repeat;\n-  bool may_throw;\n-  bool may_branch;\n-  bool has_label;\n-  bool last_was_goto;\n-  gimple_stmt_iterator last_goto_gsi;\n-};\n-\n-\n-static void remove_useless_stmts_1 (gimple_stmt_iterator *gsi, struct rus_data *);\n-\n-/* Given a statement sequence, find the first executable statement with\n-   location information, and warn that it is unreachable.  When searching,\n-   descend into containers in execution order.  */\n-\n-static bool\n-remove_useless_stmts_warn_notreached (gimple_seq stmts)\n-{\n-  gimple_stmt_iterator gsi;\n-\n-  for (gsi = gsi_start (stmts); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple stmt = gsi_stmt (gsi);\n-\n-      if (gimple_no_warning_p (stmt)) return false;\n-\n-      if (gimple_has_location (stmt))\n-        {\n-          location_t loc = gimple_location (stmt);\n-          if (LOCATION_LINE (loc) > 0)\n-\t    {\n-              warning_at (loc, OPT_Wunreachable_code, \"will never be executed\");\n-              return true;\n-            }\n-        }\n-\n-      switch (gimple_code (stmt))\n-        {\n-        /* Unfortunately, we need the CFG now to detect unreachable\n-           branches in a conditional, so conditionals are not handled here.  */\n-\n-        case GIMPLE_TRY:\n-          if (remove_useless_stmts_warn_notreached (gimple_try_eval (stmt)))\n-            return true;\n-          if (remove_useless_stmts_warn_notreached (gimple_try_cleanup (stmt)))\n-            return true;\n-          break;\n-\n-        case GIMPLE_CATCH:\n-          return remove_useless_stmts_warn_notreached (gimple_catch_handler (stmt));\n-\n-        case GIMPLE_EH_FILTER:\n-          return remove_useless_stmts_warn_notreached (gimple_eh_filter_failure (stmt));\n-\n-        case GIMPLE_BIND:\n-          return remove_useless_stmts_warn_notreached (gimple_bind_body (stmt));\n-\n-        default:\n-          break;\n-        }\n-    }\n-\n-  return false;\n-}\n-\n-/* Helper for remove_useless_stmts_1.  Handle GIMPLE_COND statements.  */\n-\n-static void\n-remove_useless_stmts_cond (gimple_stmt_iterator *gsi, struct rus_data *data)\n-{\n-  gimple stmt = gsi_stmt (*gsi);\n-\n-  /* The folded result must still be a conditional statement.  */\n-  fold_stmt (gsi);\n-  gcc_assert (gsi_stmt (*gsi) == stmt);\n-\n-  data->may_branch = true;\n-\n-  /* Replace trivial conditionals with gotos. */\n-  if (gimple_cond_true_p (stmt))\n-    {\n-      /* Goto THEN label.  */\n-      tree then_label = gimple_cond_true_label (stmt);\n-\n-      gsi_replace (gsi, gimple_build_goto (then_label), false);\n-      data->last_goto_gsi = *gsi;\n-      data->last_was_goto = true;\n-      data->repeat = true;\n-    }\n-  else if (gimple_cond_false_p (stmt))\n-    {\n-      /* Goto ELSE label.  */\n-      tree else_label = gimple_cond_false_label (stmt);\n-\n-      gsi_replace (gsi, gimple_build_goto (else_label), false);\n-      data->last_goto_gsi = *gsi;\n-      data->last_was_goto = true;\n-      data->repeat = true;\n-    }\n-  else\n-    {\n-      tree then_label = gimple_cond_true_label (stmt);\n-      tree else_label = gimple_cond_false_label (stmt);\n-\n-      if (then_label == else_label)\n-        {\n-          /* Goto common destination.  */\n-          gsi_replace (gsi, gimple_build_goto (then_label), false);\n-          data->last_goto_gsi = *gsi;\n-          data->last_was_goto = true;\n-\t  data->repeat = true;\n-\t}\n-    }\n-\n-  gsi_next (gsi);\n-\n-  data->last_was_goto = false;\n-}\n-\n-/* Helper for remove_useless_stmts_1. \n-   Handle the try-finally case for GIMPLE_TRY statements.  */\n-\n-static void\n-remove_useless_stmts_tf (gimple_stmt_iterator *gsi, struct rus_data *data)\n-{\n-  bool save_may_branch, save_may_throw;\n-  bool this_may_branch, this_may_throw;\n-\n-  gimple_seq eval_seq, cleanup_seq;\n-  gimple_stmt_iterator eval_gsi, cleanup_gsi;\n-\n-  gimple stmt = gsi_stmt (*gsi);\n-\n-  /* Collect may_branch and may_throw information for the body only.  */\n-  save_may_branch = data->may_branch;\n-  save_may_throw = data->may_throw;\n-  data->may_branch = false;\n-  data->may_throw = false;\n-  data->last_was_goto = false;\n-\n-  eval_seq = gimple_try_eval (stmt);\n-  eval_gsi = gsi_start (eval_seq);\n-  remove_useless_stmts_1 (&eval_gsi, data);\n-\n-  this_may_branch = data->may_branch;\n-  this_may_throw = data->may_throw;\n-  data->may_branch |= save_may_branch;\n-  data->may_throw |= save_may_throw;\n-  data->last_was_goto = false;\n-\n-  cleanup_seq = gimple_try_cleanup (stmt);\n-  cleanup_gsi = gsi_start (cleanup_seq);\n-  remove_useless_stmts_1 (&cleanup_gsi, data);\n-\n-  /* If the body is empty, then we can emit the FINALLY block without\n-     the enclosing TRY_FINALLY_EXPR.  */\n-  if (gimple_seq_empty_p (eval_seq))\n-    {\n-      gsi_insert_seq_before (gsi, cleanup_seq, GSI_SAME_STMT);\n-      gsi_remove (gsi, false);\n-      data->repeat = true;\n-    }\n-\n-  /* If the handler is empty, then we can emit the TRY block without\n-     the enclosing TRY_FINALLY_EXPR.  */\n-  else if (gimple_seq_empty_p (cleanup_seq))\n-    {\n-      gsi_insert_seq_before (gsi, eval_seq, GSI_SAME_STMT);\n-      gsi_remove (gsi, false);\n-      data->repeat = true;\n-    }\n-\n-  /* If the body neither throws, nor branches, then we can safely\n-     string the TRY and FINALLY blocks together.  */\n-  else if (!this_may_branch && !this_may_throw)\n-    {\n-      gsi_insert_seq_before (gsi, eval_seq, GSI_SAME_STMT);\n-      gsi_insert_seq_before (gsi, cleanup_seq, GSI_SAME_STMT);\n-      gsi_remove (gsi, false);\n-      data->repeat = true;\n-    }\n-  else\n-    gsi_next (gsi);\n-}\n-\n-/* Helper for remove_useless_stmts_1. \n-   Handle the try-catch case for GIMPLE_TRY statements.  */\n-\n-static void\n-remove_useless_stmts_tc (gimple_stmt_iterator *gsi, struct rus_data *data)\n-{\n-  bool save_may_throw, this_may_throw;\n-\n-  gimple_seq eval_seq, cleanup_seq, handler_seq, failure_seq;\n-  gimple_stmt_iterator eval_gsi, cleanup_gsi, handler_gsi, failure_gsi;\n-\n-  gimple stmt = gsi_stmt (*gsi);\n-\n-  /* Collect may_throw information for the body only.  */\n-  save_may_throw = data->may_throw;\n-  data->may_throw = false;\n-  data->last_was_goto = false;\n-\n-  eval_seq = gimple_try_eval (stmt);\n-  eval_gsi = gsi_start (eval_seq);\n-  remove_useless_stmts_1 (&eval_gsi, data);\n-\n-  this_may_throw = data->may_throw;\n-  data->may_throw = save_may_throw;\n-\n-  cleanup_seq = gimple_try_cleanup (stmt);\n-\n-  /* If the body cannot throw, then we can drop the entire TRY_CATCH_EXPR.  */\n-  if (!this_may_throw)\n-    {\n-      if (warn_notreached)\n-        {\n-          remove_useless_stmts_warn_notreached (cleanup_seq);\n-        }\n-      gsi_insert_seq_before (gsi, eval_seq, GSI_SAME_STMT);\n-      gsi_remove (gsi, false);\n-      data->repeat = true;\n-      return;\n-    }\n-\n-  /* Process the catch clause specially.  We may be able to tell that\n-     no exceptions propagate past this point.  */\n-\n-  this_may_throw = true;\n-  cleanup_gsi = gsi_start (cleanup_seq);\n-  stmt = gsi_stmt (cleanup_gsi);\n-  data->last_was_goto = false;\n-\n-  switch (gimple_code (stmt))\n-    {\n-    case GIMPLE_CATCH:\n-      /* If the first element is a catch, they all must be.  */\n-      while (!gsi_end_p (cleanup_gsi))\n-        {\n-\t  stmt = gsi_stmt (cleanup_gsi);\n-\t  /* If we catch all exceptions, then the body does not\n-\t     propagate exceptions past this point.  */\n-\t  if (gimple_catch_types (stmt) == NULL)\n-\t    this_may_throw = false;\n-\t  data->last_was_goto = false;\n-          handler_seq = gimple_catch_handler (stmt);\n-          handler_gsi = gsi_start (handler_seq);\n-\t  remove_useless_stmts_1 (&handler_gsi, data);\n-          gsi_next (&cleanup_gsi);\n-\t}\n-      gsi_next (gsi);\n-      break;\n-\n-    case GIMPLE_EH_FILTER:\n-      if (gimple_eh_filter_types (stmt) == NULL)\n-\tthis_may_throw = false;\n-      failure_seq = gimple_eh_filter_failure (stmt);\n-      failure_gsi = gsi_start (failure_seq);\n-      remove_useless_stmts_1 (&failure_gsi, data);\n-      gsi_next (gsi);\n-      break;\n-\n-    case GIMPLE_EH_MUST_NOT_THROW:\n-      this_may_throw = false;\n-      gsi_next (gsi);\n-      break;\n-\n-    default:\n-      /* Otherwise this is a list of cleanup statements.  */\n-      remove_useless_stmts_1 (&cleanup_gsi, data);\n-\n-      /* If the cleanup is empty, then we can emit the TRY block without\n-\t the enclosing TRY_CATCH_EXPR.  */\n-      if (gimple_seq_empty_p (cleanup_seq))\n-\t{\n-          gsi_insert_seq_before (gsi, eval_seq, GSI_SAME_STMT);\n-          gsi_remove(gsi, false);\n-\t  data->repeat = true;\n-\t}\n-      else\n-        gsi_next (gsi);\n-      break;\n-    }\n-\n-  data->may_throw |= this_may_throw;\n-}\n-\n-/* Helper for remove_useless_stmts_1.  Handle GIMPLE_BIND statements.  */\n-\n-static void\n-remove_useless_stmts_bind (gimple_stmt_iterator *gsi, struct rus_data *data ATTRIBUTE_UNUSED)\n-{\n-  tree block;\n-  gimple_seq body_seq, fn_body_seq;\n-  gimple_stmt_iterator body_gsi;\n-\n-  gimple stmt = gsi_stmt (*gsi);\n-\n-  /* First remove anything underneath the BIND_EXPR.  */\n-  \n-  body_seq = gimple_bind_body (stmt);\n-  body_gsi = gsi_start (body_seq);\n-  remove_useless_stmts_1 (&body_gsi, data);\n-\n-  /* If the GIMPLE_BIND has no variables, then we can pull everything\n-     up one level and remove the GIMPLE_BIND, unless this is the toplevel\n-     GIMPLE_BIND for the current function or an inlined function.\n-\n-     When this situation occurs we will want to apply this\n-     optimization again.  */\n-  block = gimple_bind_block (stmt);\n-  fn_body_seq = gimple_body (current_function_decl);\n-  if (gimple_bind_vars (stmt) == NULL_TREE\n-      && (gimple_seq_empty_p (fn_body_seq)\n-          || stmt != gimple_seq_first_stmt (fn_body_seq))\n-      && (! block\n-\t  || ! BLOCK_ABSTRACT_ORIGIN (block)\n-\t  || (TREE_CODE (BLOCK_ABSTRACT_ORIGIN (block))\n-\t      != FUNCTION_DECL)))\n-    {\n-      tree var = NULL_TREE;\n-      /* Even if there are no gimple_bind_vars, there might be other\n-\t decls in BLOCK_VARS rendering the GIMPLE_BIND not useless.  */\n-      if (block && !BLOCK_NUM_NONLOCALIZED_VARS (block))\n-\tfor (var = BLOCK_VARS (block); var; var = TREE_CHAIN (var))\n-\t  if (TREE_CODE (var) == IMPORTED_DECL)\n-\t    break;\n-      if (var || (block && BLOCK_NUM_NONLOCALIZED_VARS (block)))\n-\tgsi_next (gsi);\n-      else\n-\t{\n-\t  gsi_insert_seq_before (gsi, body_seq, GSI_SAME_STMT);\n-\t  gsi_remove (gsi, false);\n-\t  data->repeat = true;\n-\t}\n-    }\n-  else\n-    gsi_next (gsi);\n-}\n-\n-/* Helper for remove_useless_stmts_1.  Handle GIMPLE_GOTO statements.  */\n-\n-static void\n-remove_useless_stmts_goto (gimple_stmt_iterator *gsi, struct rus_data *data)\n-{\n-  gimple stmt = gsi_stmt (*gsi);\n-\n-  tree dest = gimple_goto_dest (stmt);\n-\n-  data->may_branch = true;\n-  data->last_was_goto = false;\n-\n-  /* Record iterator for last goto expr, so that we can delete it if unnecessary.  */\n-  if (TREE_CODE (dest) == LABEL_DECL)\n-    {\n-      data->last_goto_gsi = *gsi;\n-      data->last_was_goto = true;\n-    }\n-\n-  gsi_next(gsi);\n-}\n-\n-/* Helper for remove_useless_stmts_1.  Handle GIMPLE_LABEL statements.  */\n-\n-static void\n-remove_useless_stmts_label (gimple_stmt_iterator *gsi, struct rus_data *data)\n-{\n-  gimple stmt = gsi_stmt (*gsi);\n-\n-  tree label = gimple_label_label (stmt);\n-\n-  data->has_label = true;\n-\n-  /* We do want to jump across non-local label receiver code.  */\n-  if (DECL_NONLOCAL (label))\n-    data->last_was_goto = false;\n-\n-  else if (data->last_was_goto\n-           && gimple_goto_dest (gsi_stmt (data->last_goto_gsi)) == label)\n-    {\n-      /* Replace the preceding GIMPLE_GOTO statement with\n-         a GIMPLE_NOP, which will be subsequently removed.\n-         In this way, we avoid invalidating other iterators\n-         active on the statement sequence.  */\n-      gsi_replace(&data->last_goto_gsi, gimple_build_nop(), false);\n-      data->last_was_goto = false;\n-      data->repeat = true;\n-    }\n-\n-  /* ??? Add something here to delete unused labels.  */\n-\n-  gsi_next (gsi);\n-}\n-\n-\n /* T is CALL_EXPR.  Set current_function_calls_* flags.  */\n \n void\n@@ -2156,188 +1739,6 @@ clear_special_calls (void)\n   cfun->calls_setjmp = false;\n }\n \n-/* Remove useless statements from a statement sequence, and perform\n-   some preliminary simplifications.  */\n-\n-static void\n-remove_useless_stmts_1 (gimple_stmt_iterator *gsi, struct rus_data *data)\n-{\n-  while (!gsi_end_p (*gsi))\n-    {\n-      gimple stmt = gsi_stmt (*gsi);\n-\n-      switch (gimple_code (stmt))\n-        {\n-        case GIMPLE_COND:\n-          remove_useless_stmts_cond (gsi, data);\n-          break;\n-\n-        case GIMPLE_GOTO:\n-          remove_useless_stmts_goto (gsi, data);\n-          break;\n-\n-        case GIMPLE_LABEL:\n-          remove_useless_stmts_label (gsi, data);\n-          break;\n-\n-        case GIMPLE_ASSIGN:\n-          fold_stmt (gsi);\n-          stmt = gsi_stmt (*gsi);\n-          data->last_was_goto = false;\n-          if (stmt_could_throw_p (stmt))\n-            data->may_throw = true;\n-          gsi_next (gsi);\n-          break;\n-\n-        case GIMPLE_ASM:\n-          fold_stmt (gsi);\n-          data->last_was_goto = false;\n-          gsi_next (gsi);\n-          break;\n-\n-        case GIMPLE_CALL:\n-          fold_stmt (gsi);\n-          stmt = gsi_stmt (*gsi);\n-          data->last_was_goto = false;\n-          if (is_gimple_call (stmt))\n-            notice_special_calls (stmt);\n-\n-          /* We used to call update_gimple_call_flags here,\n-             which copied side-effects and nothrows status\n-             from the function decl to the call.  In the new\n-             tuplified GIMPLE, the accessors for this information\n-             always consult the function decl, so this copying\n-             is no longer necessary.  */\n-          if (stmt_could_throw_p (stmt))\n-            data->may_throw = true;\n-          gsi_next (gsi);\n-          break;\n-\n-        case GIMPLE_RETURN:\n-          fold_stmt (gsi);\n-          data->last_was_goto = false;\n-          data->may_branch = true;\n-          gsi_next (gsi);\n-          break;\n-\n-        case GIMPLE_BIND:\n-          remove_useless_stmts_bind (gsi, data);\n-          break;\n-\n-        case GIMPLE_TRY:\n-          if (gimple_try_kind (stmt) == GIMPLE_TRY_CATCH)\n-            remove_useless_stmts_tc (gsi, data);\n-          else if (gimple_try_kind (stmt) == GIMPLE_TRY_FINALLY)\n-            remove_useless_stmts_tf (gsi, data);\n-          else\n-            gcc_unreachable ();\n-          break;\n-\n-        case GIMPLE_CATCH:\n-          gcc_unreachable ();\n-          break;\n-\n-        case GIMPLE_NOP:\n-          gsi_remove (gsi, false);\n-          break;\n-\n-        case GIMPLE_OMP_FOR:\n-          {\n-            gimple_seq pre_body_seq = gimple_omp_for_pre_body (stmt);\n-            gimple_stmt_iterator pre_body_gsi = gsi_start (pre_body_seq);\n-\n-            remove_useless_stmts_1 (&pre_body_gsi, data);\n-\t    data->last_was_goto = false;\n-          }\n-          /* FALLTHROUGH */\n-        case GIMPLE_OMP_CRITICAL:\n-        case GIMPLE_OMP_CONTINUE:\n-        case GIMPLE_OMP_MASTER:\n-        case GIMPLE_OMP_ORDERED:\n-        case GIMPLE_OMP_SECTION:\n-        case GIMPLE_OMP_SECTIONS:\n-        case GIMPLE_OMP_SINGLE:\n-          {\n-            gimple_seq body_seq = gimple_omp_body (stmt);\n-            gimple_stmt_iterator body_gsi = gsi_start (body_seq);\n-\n-            remove_useless_stmts_1 (&body_gsi, data);\n-\t    data->last_was_goto = false;\n-\t    gsi_next (gsi);\n-          }\n-          break;\n-\n-        case GIMPLE_OMP_PARALLEL:\n-\tcase GIMPLE_OMP_TASK:\n-          {\n-\t    /* Make sure the outermost GIMPLE_BIND isn't removed\n-\t       as useless.  */\n-            gimple_seq body_seq = gimple_omp_body (stmt);\n-            gimple bind = gimple_seq_first_stmt (body_seq);\n-            gimple_seq bind_seq = gimple_bind_body (bind);\n-            gimple_stmt_iterator bind_gsi = gsi_start (bind_seq);\n-\n-            remove_useless_stmts_1 (&bind_gsi, data);\n-\t    data->last_was_goto = false;\n-\t    gsi_next (gsi);\n-          }\n-          break;\n-\n-        default:\n-          data->last_was_goto = false;\n-          gsi_next (gsi);\n-          break;\n-        }\n-    }\n-}\n-\n-/* Walk the function tree, removing useless statements and performing\n-   some preliminary simplifications.  */\n-\n-static unsigned int\n-remove_useless_stmts (void)\n-{\n-  struct rus_data data;\n-\n-  clear_special_calls ();\n-\n-  do\n-    {\n-      gimple_stmt_iterator gsi;\n-\n-      gsi = gsi_start (gimple_body (current_function_decl));\n-      memset (&data, 0, sizeof (data));\n-      remove_useless_stmts_1 (&gsi, &data);\n-    }\n-  while (data.repeat);\n-\n-#ifdef ENABLE_TYPES_CHECKING\n-  verify_types_in_gimple_seq (gimple_body (current_function_decl));\n-#endif\n-\n-  return 0;\n-}\n-\n-\n-struct gimple_opt_pass pass_remove_useless_stmts =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"useless\",\t\t\t\t/* name */\n-  NULL,\t\t\t\t\t/* gate */\n-  remove_useless_stmts,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_gimple_any,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func\t\t\t/* todo_flags_finish */\n- }\n-};\n-\n /* Remove PHI nodes associated with basic block BB and all edges out of BB.  */\n \n static void"}, {"sha": "e782738b6d2e5788c2ae30c52e53731fcfdca3b6", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=6728ee79872ffd3dbcf858dab076c96c71ec95e5", "patch": "@@ -1919,21 +1919,27 @@ lower_eh_constructs_2 (struct leh_state *state, gimple_stmt_iterator *gsi)\n       else\n \t{\n \t  x = gimple_seq_first_stmt (gimple_try_cleanup (stmt));\n-\t  switch (gimple_code (x))\n+\t  if (!x)\n \t    {\n-\t    case GIMPLE_CATCH:\n-\t      replace = lower_catch (state, stmt);\n-\t      break;\n-\t    case GIMPLE_EH_FILTER:\n-\t      replace = lower_eh_filter (state, stmt);\n-\t      break;\n-\t    case GIMPLE_EH_MUST_NOT_THROW:\n-\t      replace = lower_eh_must_not_throw (state, stmt);\n-\t      break;\n-\t    default:\n-\t      replace = lower_cleanup (state, stmt);\n-\t      break;\n+\t      replace = gimple_try_eval (stmt);\n+\t      lower_eh_constructs_1 (state, replace);\n \t    }\n+\t  else\n+\t    switch (gimple_code (x))\n+\t      {\n+\t\tcase GIMPLE_CATCH:\n+\t\t    replace = lower_catch (state, stmt);\n+\t\t    break;\n+\t\tcase GIMPLE_EH_FILTER:\n+\t\t    replace = lower_eh_filter (state, stmt);\n+\t\t    break;\n+\t\tcase GIMPLE_EH_MUST_NOT_THROW:\n+\t\t    replace = lower_eh_must_not_throw (state, stmt);\n+\t\t    break;\n+\t\tdefault:\n+\t\t    replace = lower_cleanup (state, stmt);\n+\t\t    break;\n+\t      }\n \t}\n \n       /* Remove the old stmt and insert the transformed sequence"}, {"sha": "b829cee08b331eb13e8e153f8e368be3bf484537", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=6728ee79872ffd3dbcf858dab076c96c71ec95e5", "patch": "@@ -333,7 +333,6 @@ extern void tree_lowering_passes (tree decl);\n \n extern struct gimple_opt_pass pass_mudflap_1;\n extern struct gimple_opt_pass pass_mudflap_2;\n-extern struct gimple_opt_pass pass_remove_useless_stmts;\n extern struct gimple_opt_pass pass_lower_cf;\n extern struct gimple_opt_pass pass_refactor_eh;\n extern struct gimple_opt_pass pass_lower_eh;"}, {"sha": "4c3f52bd7b76e9424f0f1b2b59f3558ed8a2f1f3", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6728ee79872ffd3dbcf858dab076c96c71ec95e5/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=6728ee79872ffd3dbcf858dab076c96c71ec95e5", "patch": "@@ -4438,7 +4438,8 @@ free_lang_data_in_decl (tree decl)\n \t  && !TREE_STATIC (expr) && !DECL_EXTERNAL (expr))\n \tSET_DECL_DEBUG_EXPR (decl, NULL_TREE);\n \n-      if (DECL_EXTERNAL (decl))\n+      if (DECL_EXTERNAL (decl)\n+\t  && (!TREE_STATIC (decl) || !TREE_READONLY (decl)))\n \tDECL_INITIAL (decl) = NULL_TREE;\n     }\n   else if (TREE_CODE (decl) == TYPE_DECL)"}]}