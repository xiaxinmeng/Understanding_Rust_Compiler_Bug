{"sha": "ac1774315cb7ebc781ade2f9fd99de1c258b9221", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMxNzc0MzE1Y2I3ZWJjNzgxYWRlMmY5ZmQ5OWRlMWMyNThiOTIyMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-06-30T00:50:57Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-06-30T00:50:57Z"}, "message": "Machinery to support implicit delete/move.\n\n\t* cp-tree.h: (struct lang_type_class): Add lazy_move_assign,\n\thas_complex_move_ctor, has_complex_move_assign bitfields.\n\t(CLASSTYPE_LAZY_MOVE_ASSIGN): New.\n\t(TYPE_HAS_COMPLEX_MOVE_ASSIGN): New.\n\t(TYPE_HAS_COMPLEX_MOVE_CTOR): New.\n\t(enum special_function_kind): Add sfk_move_assignment.\n\t(LOOKUP_SPECULATIVE): New.\n\t* call.c (build_over_call): Return early if it's set.\n\t(build_over_call): Use trivial_fn_p.\n\t* class.c (check_bases): If the base has no default constructor,\n\tthe derived one is non-trivial.  Handle move ctor/op=.\n\t(check_field_decl): Likewise.\n\t(check_bases_and_members): Handle move ctor/op=.\n\t(add_implicitly_declared_members): Handle CLASSTYPE_LAZY_MOVE_ASSIGN.\n\t(type_has_move_constructor, type_has_move_assign): New.\n\t* decl.c (grok_special_member_properties): Handle move ctor/op=.\n\t* method.c (type_has_trivial_fn, type_set_nontrivial_flag): New.\n\t(trivial_fn_p): New.\n\t(do_build_copy_constructor): Use it.\n\t(do_build_assign_ref): Likewise.  Handle move assignment.\n\t(build_stub_type, build_stub_object, locate_fn_flags): New.\n\t(locate_ctor): Use locate_fn_flags.\n\t(locate_copy, locate_dtor): Remove.\n\t(get_dtor, get_default_ctor, get_copy_ctor, get_copy_assign): New.\n\t(process_subob_fn, synthesized_method_walk): New.\n\t(maybe_explain_implicit_delete): New.\n\t(implicitly_declare_fn): Use synthesized_method_walk,\n\ttype_has_trivial_fn, and type_set_nontrivial_flag.\n\t(defaulted_late_check): Set DECL_DELETED_FN.\n\t(defaultable_fn_check): Handle sfk_move_assignment.\n\t(lazily_declare_fn): Clear CLASSTYPE_LAZY_* early.  Don't declare\n\timplicitly deleted move ctor/op=.\n\t* search.c (lookup_fnfields_1): Handle sfk_move_assignment.\n\t(lookup_fnfields_slot): New.\n\t* semantics.c (omp_clause_info_fndecl): Remove.\n\t(cxx_omp_create_clause_info): Use get_default_ctor, get_copy_ctor,\n\tget_copy_assign, trivial_fn_p.\n\t(trait_expr_value): Adjust call to locate_ctor.\n\t* tree.c (special_function_p): Handle sfk_move_assignment.\n\nFrom-SVN: r161579", "tree": {"sha": "0e8e64d29daa126b9fc1f87bfe35a0967270da6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e8e64d29daa126b9fc1f87bfe35a0967270da6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac1774315cb7ebc781ade2f9fd99de1c258b9221", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac1774315cb7ebc781ade2f9fd99de1c258b9221", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac1774315cb7ebc781ade2f9fd99de1c258b9221", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac1774315cb7ebc781ade2f9fd99de1c258b9221/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4640884658bae7ba9ff09068efcbe4b7e94baf8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4640884658bae7ba9ff09068efcbe4b7e94baf8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4640884658bae7ba9ff09068efcbe4b7e94baf8d"}], "stats": {"total": 1097, "additions": 822, "deletions": 275}, "files": [{"sha": "a8df2336db76826e1e4088f14e5c83217ca35d59", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ac1774315cb7ebc781ade2f9fd99de1c258b9221", "patch": "@@ -1,5 +1,46 @@\n 2010-06-29  Jason Merrill  <jason@redhat.com>\n \n+\tMachinery to support implicit delete/move.\n+\t* cp-tree.h: (struct lang_type_class): Add lazy_move_assign,\n+\thas_complex_move_ctor, has_complex_move_assign bitfields.\n+\t(CLASSTYPE_LAZY_MOVE_ASSIGN): New.\n+\t(TYPE_HAS_COMPLEX_MOVE_ASSIGN): New.\n+\t(TYPE_HAS_COMPLEX_MOVE_CTOR): New.\n+\t(enum special_function_kind): Add sfk_move_assignment.\n+\t(LOOKUP_SPECULATIVE): New.\n+\t* call.c (build_over_call): Return early if it's set.\n+\t(build_over_call): Use trivial_fn_p.\n+\t* class.c (check_bases): If the base has no default constructor,\n+\tthe derived one is non-trivial.  Handle move ctor/op=.\n+\t(check_field_decl): Likewise.\n+\t(check_bases_and_members): Handle move ctor/op=.\n+\t(add_implicitly_declared_members): Handle CLASSTYPE_LAZY_MOVE_ASSIGN.\n+\t(type_has_move_constructor, type_has_move_assign): New.\n+\t* decl.c (grok_special_member_properties): Handle move ctor/op=.\n+\t* method.c (type_has_trivial_fn, type_set_nontrivial_flag): New.\n+\t(trivial_fn_p): New.\n+\t(do_build_copy_constructor): Use it.\n+\t(do_build_assign_ref): Likewise.  Handle move assignment.\n+\t(build_stub_type, build_stub_object, locate_fn_flags): New.\n+\t(locate_ctor): Use locate_fn_flags.\n+\t(locate_copy, locate_dtor): Remove.\n+\t(get_dtor, get_default_ctor, get_copy_ctor, get_copy_assign): New.\n+\t(process_subob_fn, synthesized_method_walk): New.\n+\t(maybe_explain_implicit_delete): New.\n+\t(implicitly_declare_fn): Use synthesized_method_walk,\n+\ttype_has_trivial_fn, and type_set_nontrivial_flag.\n+\t(defaulted_late_check): Set DECL_DELETED_FN.\n+\t(defaultable_fn_check): Handle sfk_move_assignment.\n+\t(lazily_declare_fn): Clear CLASSTYPE_LAZY_* early.  Don't declare\n+\timplicitly deleted move ctor/op=.\n+\t* search.c (lookup_fnfields_1): Handle sfk_move_assignment.\n+\t(lookup_fnfields_slot): New.\n+\t* semantics.c (omp_clause_info_fndecl): Remove.\n+\t(cxx_omp_create_clause_info): Use get_default_ctor, get_copy_ctor,\n+\tget_copy_assign, trivial_fn_p.\n+\t(trait_expr_value): Adjust call to locate_ctor.\n+\t* tree.c (special_function_p): Handle sfk_move_assignment.\n+\n \t* class.c (type_has_virtual_destructor): New.\n \t* cp-tree.h: Declare it.\n \t* semantics.c (trait_expr_value): Use it."}, {"sha": "9f4a520a5a8497a57e770c2a7a11057ebbf2a035", "filename": "gcc/cp/call.c", "status": "modified", "additions": 41, "deletions": 13, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=ac1774315cb7ebc781ade2f9fd99de1c258b9221", "patch": "@@ -5613,6 +5613,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \n   if (DECL_FUNCTION_MEMBER_P (fn))\n     {\n+      tree access_fn;\n       /* If FN is a template function, two cases must be considered.\n \t For example:\n \n@@ -5640,10 +5641,41 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t different access.  */\n       if (DECL_TEMPLATE_INFO (fn)\n \t  && DECL_MEMBER_TEMPLATE_P (DECL_TI_TEMPLATE (fn)))\n-\tperform_or_defer_access_check (cand->access_path,\n-\t\t\t\t       DECL_TI_TEMPLATE (fn), fn);\n+\taccess_fn = DECL_TI_TEMPLATE (fn);\n       else\n-\tperform_or_defer_access_check (cand->access_path, fn, fn);\n+\taccess_fn = fn;\n+      if (flags & LOOKUP_SPECULATIVE)\n+\t{\n+\t  /* If we're checking for implicit delete, we don't want access\n+\t     control errors.  */\n+\t  if (!accessible_p (cand->access_path, access_fn, true))\n+\t    {\n+\t      /* Unless we're under maybe_explain_implicit_delete.  */\n+\t      if (flags & LOOKUP_COMPLAIN)\n+\t\tenforce_access (cand->access_path, access_fn, fn);\n+\t      return error_mark_node;\n+\t    }\n+\t}\n+      else\n+\tperform_or_defer_access_check (cand->access_path, access_fn, fn);\n+    }\n+\n+  /* If we're checking for implicit delete, don't bother with argument\n+     conversions.  */\n+  if (flags & LOOKUP_SPECULATIVE)\n+    {\n+      if (DECL_DELETED_FN (fn))\n+\t{\n+\t  if (flags & LOOKUP_COMPLAIN)\n+\t    mark_used (fn);\n+\t  return error_mark_node;\n+\t}\n+      if (cand->viable == 1)\n+\treturn fn;\n+      else if (!(flags & LOOKUP_COMPLAIN))\n+\t/* Reject bad conversions now.  */\n+\treturn error_mark_node;\n+      /* else continue to get conversion error.  */\n     }\n \n   /* Find maximum size of vector to hold converted arguments.  */\n@@ -5824,6 +5856,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       tree targ;\n       tree arg = argarray[num_artificial_parms_for (fn)];\n       tree fa;\n+      bool trivial = trivial_fn_p (fn);\n \n       /* Pull out the real argument, disregarding const-correctness.  */\n       targ = arg;\n@@ -5848,13 +5881,12 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       if (TREE_CODE (arg) == TARGET_EXPR\n \t  && TARGET_EXPR_LIST_INIT_P (arg))\n \t{\n-\t  /* Copy-list-initialization doesn't require the copy constructor\n+\t  /* Copy-list-initialization doesn't require the constructor\n \t     to be defined.  */\n \t}\n       /* [class.copy]: the copy constructor is implicitly defined even if\n \t the implementation elided its use.  */\n-      else if (TYPE_HAS_COMPLEX_COPY_CTOR (DECL_CONTEXT (fn))\n-\t       || move_fn_p (fn))\n+      else if (!trivial)\n \t{\n \t  mark_used (fn);\n \t  already_used = true;\n@@ -5872,13 +5904,10 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t{\n \t  if (TREE_CODE (arg) == TARGET_EXPR)\n \t    return arg;\n-\t  else if (TYPE_HAS_TRIVIAL_COPY_CTOR (DECL_CONTEXT (fn))\n-\t\t   && !move_fn_p (fn))\n+\t  else if (trivial)\n \t    return build_target_expr_with_type (arg, DECL_CONTEXT (fn));\n \t}\n-      else if (TREE_CODE (arg) == TARGET_EXPR\n-\t       || (TYPE_HAS_TRIVIAL_COPY_CTOR (DECL_CONTEXT (fn))\n-\t\t   && !move_fn_p (fn)))\n+      else if (TREE_CODE (arg) == TARGET_EXPR || trivial)\n \t{\n \t  tree to = stabilize_reference (cp_build_indirect_ref (fa, RO_NULL,\n \t\t\t\t\t\t\t\tcomplain));\n@@ -5888,8 +5917,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t}\n     }\n   else if (DECL_OVERLOADED_OPERATOR_P (fn) == NOP_EXPR\n-\t   && copy_fn_p (fn)\n-\t   && TYPE_HAS_TRIVIAL_COPY_ASSIGN (DECL_CONTEXT (fn)))\n+\t   && trivial_fn_p (fn))\n     {\n       tree to = stabilize_reference\n \t(cp_build_indirect_ref (argarray[0], RO_NULL, complain));"}, {"sha": "6f6aab6d63fc41429fa64b52b1a56af08d288174", "filename": "gcc/cp/class.c", "status": "modified", "additions": 62, "deletions": 2, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=ac1774315cb7ebc781ade2f9fd99de1c258b9221", "patch": "@@ -1314,10 +1314,14 @@ check_bases (tree t,\n       TYPE_HAS_COMPLEX_COPY_ASSIGN (t)\n \t|= TYPE_HAS_COMPLEX_COPY_ASSIGN (basetype);\n       TYPE_HAS_COMPLEX_COPY_CTOR (t) |= TYPE_HAS_COMPLEX_COPY_CTOR (basetype);\n+      TYPE_HAS_COMPLEX_MOVE_ASSIGN (t)\n+\t|= TYPE_HAS_COMPLEX_MOVE_ASSIGN (basetype);\n+      TYPE_HAS_COMPLEX_MOVE_CTOR (t) |= TYPE_HAS_COMPLEX_MOVE_CTOR (basetype);\n       TYPE_POLYMORPHIC_P (t) |= TYPE_POLYMORPHIC_P (basetype);\n       CLASSTYPE_CONTAINS_EMPTY_CLASS_P (t)\n \t|= CLASSTYPE_CONTAINS_EMPTY_CLASS_P (basetype);\n-      TYPE_HAS_COMPLEX_DFLT (t) |= TYPE_HAS_COMPLEX_DFLT (basetype);      \n+      TYPE_HAS_COMPLEX_DFLT (t) |= (!TYPE_HAS_DEFAULT_CONSTRUCTOR (basetype)\n+\t\t\t\t    || TYPE_HAS_COMPLEX_DFLT (basetype));\n \n       /*  A standard-layout class is a class that:\n \t  ...\n@@ -2670,6 +2674,7 @@ add_implicitly_declared_members (tree t,\n      a virtual function from a base class.  */\n   if (TYPE_POLYMORPHIC_P (t)\n       && (CLASSTYPE_LAZY_COPY_ASSIGN (t)\n+\t  || CLASSTYPE_LAZY_MOVE_ASSIGN (t)\n \t  || CLASSTYPE_LAZY_DESTRUCTOR (t)))\n     {\n       tree binfo = TYPE_BINFO (t);\n@@ -2686,6 +2691,8 @@ add_implicitly_declared_members (tree t,\n \t\t{\n \t\t  if (CLASSTYPE_LAZY_COPY_ASSIGN (t))\n \t\t    lazily_declare_fn (sfk_copy_assignment, t);\n+\t\t  if (CLASSTYPE_LAZY_MOVE_ASSIGN (t))\n+\t\t    lazily_declare_fn (sfk_move_assignment, t);\n \t\t}\n \t      else if (DECL_DESTRUCTOR_P (fn)\n \t\t       && CLASSTYPE_LAZY_DESTRUCTOR (t))\n@@ -2848,6 +2855,8 @@ check_field_decl (tree field,\n \t  if (TYPE_HAS_COMPLEX_COPY_ASSIGN (type))\n \t    error (\"member %q+#D with copy assignment operator not allowed in union\",\n \t\t   field);\n+\t  /* Don't bother diagnosing move assop now; C++0x has more\n+\t     flexible unions.  */\n \t}\n       else\n \t{\n@@ -2856,7 +2865,10 @@ check_field_decl (tree field,\n \t    |= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type);\n \t  TYPE_HAS_COMPLEX_COPY_ASSIGN (t) |= TYPE_HAS_COMPLEX_COPY_ASSIGN (type);\n \t  TYPE_HAS_COMPLEX_COPY_CTOR (t) |= TYPE_HAS_COMPLEX_COPY_CTOR (type);\n-\t  TYPE_HAS_COMPLEX_DFLT (t) |= TYPE_HAS_COMPLEX_DFLT (type);\n+\t  TYPE_HAS_COMPLEX_MOVE_ASSIGN (t) |= TYPE_HAS_COMPLEX_MOVE_ASSIGN (type);\n+\t  TYPE_HAS_COMPLEX_MOVE_CTOR (t) |= TYPE_HAS_COMPLEX_MOVE_CTOR (type);\n+\t  TYPE_HAS_COMPLEX_DFLT (t) |= (!TYPE_HAS_DEFAULT_CONSTRUCTOR (type)\n+\t\t\t\t\t|| TYPE_HAS_COMPLEX_DFLT (type));\n \t}\n \n       if (!TYPE_HAS_CONST_COPY_CTOR (type))\n@@ -3022,6 +3034,7 @@ check_field_decls (tree t, tree *access_decls,\n \t     only way to initialize nonstatic const and reference\n \t     members.  */\n \t  TYPE_HAS_COMPLEX_COPY_ASSIGN (t) = 1;\n+\t  TYPE_HAS_COMPLEX_MOVE_ASSIGN (t) = 1;\n \t}\n \n       type = strip_array_types (type);\n@@ -3108,6 +3121,7 @@ check_field_decls (tree t, tree *access_decls,\n \t     only way to initialize nonstatic const and reference\n \t     members.  */\n \t  TYPE_HAS_COMPLEX_COPY_ASSIGN (t) = 1;\n+\t  TYPE_HAS_COMPLEX_MOVE_ASSIGN (t) = 1;\n \t}\n       /* A field that is pseudo-const makes the structure likewise.  */\n       else if (CLASS_TYPE_P (type))\n@@ -4277,6 +4291,50 @@ type_has_virtual_destructor (tree type)\n   return (dtor && DECL_VIRTUAL_P (dtor));\n }\n \n+/* Returns true iff class T has a move constructor.  */\n+\n+bool\n+type_has_move_constructor (tree t)\n+{\n+  tree fns;\n+\n+  if (CLASSTYPE_LAZY_MOVE_CTOR (t))\n+    {\n+      gcc_assert (COMPLETE_TYPE_P (t));\n+      lazily_declare_fn (sfk_move_constructor, t);\n+    }\n+\n+  if (!CLASSTYPE_METHOD_VEC (t))\n+    return false;\n+\n+  for (fns = CLASSTYPE_CONSTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n+    if (move_fn_p (OVL_CURRENT (fns)))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Returns true iff class T has a move assignment operator.  */\n+\n+bool\n+type_has_move_assign (tree t)\n+{\n+  tree fns;\n+\n+  if (CLASSTYPE_LAZY_MOVE_ASSIGN (t))\n+    {\n+      gcc_assert (COMPLETE_TYPE_P (t));\n+      lazily_declare_fn (sfk_move_assignment, t);\n+    }\n+\n+  for (fns = lookup_fnfields_slot (t, ansi_assopname (NOP_EXPR));\n+       fns; fns = OVL_NEXT (fns))\n+    if (move_fn_p (OVL_CURRENT (fns)))\n+      return true;\n+\n+  return false;\n+}\n+\n /* Remove all zero-width bit-fields from T.  */\n \n static void\n@@ -4411,6 +4469,7 @@ check_bases_and_members (tree t)\n   /* Do some bookkeeping that will guide the generation of implicitly\n      declared member functions.  */\n   TYPE_HAS_COMPLEX_COPY_CTOR (t) |= TYPE_CONTAINS_VPTR_P (t);\n+  TYPE_HAS_COMPLEX_MOVE_CTOR (t) |= TYPE_CONTAINS_VPTR_P (t);\n   /* We need to call a constructor for this class if it has a\n      user-provided constructor, or if the default constructor is going\n      to initialize the vptr.  (This is not an if-and-only-if;\n@@ -4434,6 +4493,7 @@ check_bases_and_members (tree t)\n \t|| saved_nontrivial_dtor || saved_complex_asn_ref);\n   CLASSTYPE_NON_STD_LAYOUT (t) |= TYPE_CONTAINS_VPTR_P (t);\n   TYPE_HAS_COMPLEX_COPY_ASSIGN (t) |= TYPE_CONTAINS_VPTR_P (t);\n+  TYPE_HAS_COMPLEX_MOVE_ASSIGN (t) |= TYPE_CONTAINS_VPTR_P (t);\n   TYPE_HAS_COMPLEX_DFLT (t) |= TYPE_CONTAINS_VPTR_P (t);\n \n   /* If the class has no user-declared constructor, but does have"}, {"sha": "1d9077cdaf1768771ce55b581f2be775592fa6e2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ac1774315cb7ebc781ade2f9fd99de1c258b9221", "patch": "@@ -1307,18 +1307,21 @@ struct GTY(()) lang_type_class {\n   unsigned has_complex_dflt : 1;\n   unsigned has_list_ctor : 1;\n   unsigned non_std_layout : 1;\n-  unsigned lazy_move_ctor : 1;\n-\n   unsigned is_literal : 1;\n \n+  unsigned lazy_move_ctor : 1;\n+  unsigned lazy_move_assign : 1;\n+  unsigned has_complex_move_ctor : 1;\n+  unsigned has_complex_move_assign : 1;\n+\n   /* When adding a flag here, consider whether or not it ought to\n      apply to a template instance if it applies to the template.  If\n      so, make sure to copy it in instantiate_class_template!  */\n \n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 7;\n+  unsigned dummy : 4;\n \n   tree primary_base;\n   VEC(tree_pair_s,gc) *vcall_indices;\n@@ -1416,6 +1419,11 @@ struct GTY((variable_size)) lang_type {\n #define CLASSTYPE_LAZY_COPY_ASSIGN(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->lazy_copy_assign)\n \n+/* Nonzero means that NODE (a class type) has an assignment operator\n+   -- but that it has not yet been declared.  */\n+#define CLASSTYPE_LAZY_MOVE_ASSIGN(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->lazy_move_assign)\n+\n /* Nonzero means that NODE (a class type) has a destructor -- but that\n    it has not yet been declared.  */\n #define CLASSTYPE_LAZY_DESTRUCTOR(NODE) \\\n@@ -3166,6 +3174,12 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n /* Nonzero if there is a non-trivial X::X(cv X&) for this class.  */\n #define TYPE_HAS_COMPLEX_COPY_CTOR(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_copy_ctor)\n \n+/* Nonzero if there is a non-trivial X::op=(X&&) for this class.  */\n+#define TYPE_HAS_COMPLEX_MOVE_ASSIGN(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_move_assign)\n+\n+/* Nonzero if there is a non-trivial X::X(X&&) for this class.  */\n+#define TYPE_HAS_COMPLEX_MOVE_CTOR(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_move_ctor)\n+\n /* Nonzero if there is a non-trivial default constructor for this class.  */\n #define TYPE_HAS_COMPLEX_DFLT(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_dflt)\n \n@@ -3869,6 +3883,7 @@ typedef enum special_function_kind {\n   sfk_copy_constructor,    /* A copy constructor.  */\n   sfk_move_constructor,    /* A move constructor.  */\n   sfk_copy_assignment,     /* A copy assignment operator.  */\n+  sfk_move_assignment,     /* A move assignment operator.  */\n   sfk_destructor,\t   /* A destructor.  */\n   sfk_complete_destructor, /* A destructor for complete objects.  */\n   sfk_base_destructor,     /* A destructor for base subobjects.  */\n@@ -4163,12 +4178,21 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n /* We're inside an init-list, so narrowing conversions are ill-formed.  */\n #define LOOKUP_NO_NARROWING (LOOKUP_PREFER_RVALUE << 1)\n /* Avoid user-defined conversions for the first parameter of a copy\n-   constructor.  */\n+   constructor (or move constructor).  */\n #define LOOKUP_NO_COPY_CTOR_CONVERSION (LOOKUP_NO_NARROWING << 1)\n /* This is the first parameter of a copy constructor.  */\n #define LOOKUP_COPY_PARM (LOOKUP_NO_COPY_CTOR_CONVERSION << 1)\n /* We only want to consider list constructors.  */\n #define LOOKUP_LIST_ONLY (LOOKUP_COPY_PARM << 1)\n+/* Return after determining which function to call and checking access.\n+   Used by sythesized_method_walk to determine which functions will\n+   be called to initialize subobjects, in order to determine exception\n+   specification and possible implicit delete.\n+   This is kind of a hack, but since access control doesn't respect SFINAE\n+   we can't just use tf_none to avoid access control errors, we need\n+   another mechanism.  Exiting early also avoids problems with trying\n+   to perform argument conversions when the class isn't complete yet.  */\n+#define LOOKUP_SPECULATIVE (LOOKUP_LIST_ONLY << 1)\n \n #define LOOKUP_NAMESPACES_ONLY(F)  \\\n   (((F) & LOOKUP_PREFER_NAMESPACES) && !((F) & LOOKUP_PREFER_TYPES))\n@@ -4656,6 +4680,8 @@ extern bool user_provided_p\t\t\t(tree);\n extern bool type_has_user_provided_constructor  (tree);\n extern bool type_has_user_provided_default_constructor (tree);\n extern bool type_has_virtual_destructor\t\t(tree);\n+extern bool type_has_move_constructor\t\t(tree);\n+extern bool type_has_move_assign\t\t(tree);\n extern void defaulted_late_check\t\t(tree);\n extern bool defaultable_fn_check\t\t(tree);\n extern void fixup_type_variants\t\t\t(tree);\n@@ -4921,15 +4947,19 @@ extern void init_method\t\t\t\t(void);\n extern tree make_thunk\t\t\t\t(tree, bool, tree, tree);\n extern void finish_thunk\t\t\t(tree);\n extern void use_thunk\t\t\t\t(tree, bool);\n+extern bool trivial_fn_p\t\t\t(tree);\n+extern bool maybe_explain_implicit_delete\t(tree);\n extern void synthesize_method\t\t\t(tree);\n extern tree lazily_declare_fn\t\t\t(special_function_kind,\n \t\t\t\t\t\t tree);\n extern tree skip_artificial_parms_for\t\t(const_tree, tree);\n extern int num_artificial_parms_for\t\t(const_tree);\n extern tree make_alias_for\t\t\t(tree, tree);\n-extern tree locate_copy\t\t\t\t(tree, void *);\n-extern tree locate_ctor\t\t\t\t(tree, void *);\n-extern tree locate_dtor\t\t\t\t(tree, void *);\n+extern tree get_copy_ctor\t\t\t(tree);\n+extern tree get_copy_assign\t\t\t(tree);\n+extern tree get_default_ctor\t\t\t(tree);\n+extern tree get_dtor\t\t\t\t(tree);\n+extern tree locate_ctor\t\t\t\t(tree);\n \n /* In optimize.c */\n extern bool maybe_clone_body\t\t\t(tree);\n@@ -5070,6 +5100,7 @@ extern int accessible_p\t\t\t\t(tree, tree, bool);\n extern tree lookup_field_1\t\t\t(tree, tree, bool);\n extern tree lookup_field\t\t\t(tree, tree, int, bool);\n extern int lookup_fnfields_1\t\t\t(tree, tree);\n+extern tree lookup_fnfields_slot\t\t(tree, tree);\n extern int class_method_index_for_fn\t\t(tree, tree);\n extern tree lookup_fnfields\t\t\t(tree, tree, int);\n extern tree lookup_member\t\t\t(tree, tree, int, bool);"}, {"sha": "153bd539d588d11a91b8c9464a6b1bf223a46d51", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ac1774315cb7ebc781ade2f9fd99de1c258b9221", "patch": "@@ -10273,6 +10273,8 @@ grok_special_member_properties (tree decl)\n \t  if (user_provided_p (decl))\n \t    TYPE_HAS_COMPLEX_DFLT (class_type) = 1;\n \t}\n+      else if (move_fn_p (decl) && user_provided_p (decl))\n+\tTYPE_HAS_COMPLEX_MOVE_CTOR (class_type) = 1;\n       else if (is_list_ctor (decl))\n \tTYPE_HAS_LIST_CTOR (class_type) = 1;\n     }\n@@ -10294,6 +10296,8 @@ grok_special_member_properties (tree decl)\n \t  if (assop != 1)\n \t    TYPE_HAS_CONST_COPY_ASSIGN (class_type) = 1;\n \t}\n+      else if (move_fn_p (decl) && user_provided_p (decl))\n+\tTYPE_HAS_COMPLEX_MOVE_ASSIGN (class_type) = 1;\n     }\n   /* Destructors are handled in check_methods.  */\n }"}, {"sha": "64f7b7f041b91c4512fcd5793a03edaabbfc11a1", "filename": "gcc/cp/method.c", "status": "modified", "additions": 598, "deletions": 159, "changes": 757, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=ac1774315cb7ebc781ade2f9fd99de1c258b9221", "patch": "@@ -59,7 +59,6 @@ typedef enum mangling_flags mangling_flags;\n \n static void do_build_copy_assign (tree);\n static void do_build_copy_constructor (tree);\n-static tree synthesize_exception_spec (tree, tree (*) (tree, void *), void *);\n static tree make_alias_for_thunk (tree);\n \n /* Called once to initialize method.c.  */\n@@ -400,21 +399,90 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \f\n /* Code for synthesizing methods which have default semantics defined.  */\n \n+/* True iff CTYPE has a trivial SFK.  */\n+\n+static bool\n+type_has_trivial_fn (tree ctype, special_function_kind sfk)\n+{\n+  switch (sfk)\n+    {\n+    case sfk_constructor:\n+      return !TYPE_HAS_COMPLEX_DFLT (ctype);\n+    case sfk_copy_constructor:\n+      return !TYPE_HAS_COMPLEX_COPY_CTOR (ctype);\n+    case sfk_move_constructor:\n+      return !TYPE_HAS_COMPLEX_MOVE_CTOR (ctype);\n+    case sfk_copy_assignment:\n+      return !TYPE_HAS_COMPLEX_COPY_ASSIGN (ctype);\n+    case sfk_move_assignment:\n+      return !TYPE_HAS_COMPLEX_MOVE_ASSIGN (ctype);\n+    case sfk_destructor:\n+      return !TYPE_HAS_NONTRIVIAL_DESTRUCTOR (ctype);\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Note that CTYPE has a non-trivial SFK even though we previously thought\n+   it was trivial.  */\n+\n+static void\n+type_set_nontrivial_flag (tree ctype, special_function_kind sfk)\n+{\n+  switch (sfk)\n+    {\n+    case sfk_constructor:\n+      TYPE_HAS_COMPLEX_DFLT (ctype) = true;\n+      return;\n+    case sfk_copy_constructor:\n+      TYPE_HAS_COMPLEX_COPY_CTOR (ctype) = true;\n+      return;\n+    case sfk_move_constructor:\n+      TYPE_HAS_COMPLEX_MOVE_CTOR (ctype) = true;\n+      return;\n+    case sfk_copy_assignment:\n+      TYPE_HAS_COMPLEX_COPY_ASSIGN (ctype) = true;\n+      return;\n+    case sfk_move_assignment:\n+      TYPE_HAS_COMPLEX_MOVE_ASSIGN (ctype) = true;\n+      return;\n+    case sfk_destructor:\n+      TYPE_HAS_NONTRIVIAL_DESTRUCTOR (ctype) = true;\n+      return;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* True iff FN is a trivial defaulted member function ([cd]tor, op=).  */\n+\n+bool\n+trivial_fn_p (tree fn)\n+{\n+  if (!DECL_DEFAULTED_FN (fn))\n+    return false;\n+\n+  /* If fn is a clone, get the primary variant.  */\n+  fn = DECL_ORIGIN (fn);\n+  return type_has_trivial_fn (DECL_CONTEXT (fn), special_function_p (fn));\n+}\n+\n /* Generate code for default X(X&) or X(X&&) constructor.  */\n \n static void\n do_build_copy_constructor (tree fndecl)\n {\n   tree parm = FUNCTION_FIRST_USER_PARM (fndecl);\n   bool move_p = DECL_MOVE_CONSTRUCTOR_P (fndecl);\n+  bool trivial = trivial_fn_p (fndecl);\n \n   parm = convert_from_reference (parm);\n \n-  if (TYPE_HAS_TRIVIAL_COPY_CTOR (current_class_type)\n+  if (trivial\n       && is_empty_class (current_class_type))\n     /* Don't copy the padding byte; it might not have been allocated\n        if *this is a base subobject.  */;\n-  else if (TYPE_HAS_TRIVIAL_COPY_CTOR (current_class_type))\n+  else if (trivial)\n     {\n       tree t = build2 (INIT_EXPR, void_type_node, current_class_ref, parm);\n       finish_expr_stmt (t);\n@@ -512,15 +580,17 @@ do_build_copy_assign (tree fndecl)\n {\n   tree parm = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n   tree compound_stmt;\n+  bool move_p = move_fn_p (fndecl);\n+  bool trivial = trivial_fn_p (fndecl);\n \n   compound_stmt = begin_compound_stmt (0);\n   parm = convert_from_reference (parm);\n \n-  if (TYPE_HAS_TRIVIAL_COPY_ASSIGN (current_class_type)\n+  if (trivial\n       && is_empty_class (current_class_type))\n     /* Don't copy the padding byte; it might not have been allocated\n        if *this is a base subobject.  */;\n-  else if (TYPE_HAS_TRIVIAL_COPY_ASSIGN (current_class_type))\n+  else if (trivial)\n     {\n       tree t = build2 (MODIFY_EXPR, void_type_node, current_class_ref, parm);\n       finish_expr_stmt (t);\n@@ -542,6 +612,8 @@ do_build_copy_assign (tree fndecl)\n \t  /* We must convert PARM directly to the base class\n \t     explicitly since the base class may be ambiguous.  */\n \t  converted_parm = build_base_path (PLUS_EXPR, parm, base_binfo, 1);\n+\t  if (move_p)\n+\t    converted_parm = move (converted_parm);\n \t  /* Call the base class assignment operator.  */\n \t  parmvec = make_tree_vector_single (converted_parm);\n \t  finish_expr_stmt\n@@ -604,6 +676,8 @@ do_build_copy_assign (tree fndecl)\n \t  expr_type = cp_build_qualified_type (expr_type, quals);\n \n \t  init = build3 (COMPONENT_REF, expr_type, init, field, NULL_TREE);\n+\t  if (move_p && TREE_CODE (expr_type) != REFERENCE_TYPE)\n+\t    init = move (init);\n \n \t  if (DECL_NAME (field))\n \t    init = cp_build_modify_expr (comp, NOP_EXPR, init, \n@@ -695,163 +769,505 @@ synthesize_method (tree fndecl)\n \t    fndecl);\n }\n \n-/* Use EXTRACTOR to locate the relevant function called for each base &\n-   class field of TYPE. CLIENT allows additional information to be passed\n-   to EXTRACTOR.  Generates the union of all exceptions generated by those\n-   functions.  Note that we haven't updated TYPE_FIELDS and such of any\n-   variants yet, so we need to look at the main one.  */\n+/* Build a reference to type TYPE with cv-quals QUALS, which is an\n+   rvalue if RVALUE is true.  */\n \n static tree\n-synthesize_exception_spec (tree type, tree (*extractor) (tree, void*),\n-\t\t\t   void *client)\n+build_stub_type (tree type, int quals, bool rvalue)\n {\n-  tree raises = empty_except_spec;\n-  tree fields = TYPE_FIELDS (type);\n-  tree binfo, base_binfo;\n-  int i;\n+  tree argtype = cp_build_qualified_type (type, quals);\n+  return cp_build_reference_type (argtype, rvalue);\n+}\n \n-  for (binfo = TYPE_BINFO (type), i = 0;\n-       BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n-    {\n-      tree fn = (*extractor) (BINFO_TYPE (base_binfo), client);\n-      if (fn)\n-\t{\n-\t  tree fn_raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n+/* Build a dummy glvalue from dereferencing a dummy reference of type\n+   REFTYPE.  */\n \n-\t  raises = merge_exception_specifiers (raises, fn_raises);\n-\t}\n-    }\n-  for (; fields; fields = TREE_CHAIN (fields))\n-    {\n-      tree type = TREE_TYPE (fields);\n-      tree fn;\n+static tree\n+build_stub_object (tree reftype)\n+{\n+  tree stub = build1 (NOP_EXPR, reftype, integer_one_node);\n+  return convert_from_reference (stub);\n+}\n \n-      if (TREE_CODE (fields) != FIELD_DECL || DECL_ARTIFICIAL (fields))\n-\tcontinue;\n-      while (TREE_CODE (type) == ARRAY_TYPE)\n-\ttype = TREE_TYPE (type);\n-      if (!CLASS_TYPE_P (type))\n-\tcontinue;\n+/* Determine which function will be called when looking up NAME in TYPE,\n+   called with a single ARGTYPE argument, or no argument if ARGTYPE is\n+   null.  FLAGS and COMPLAIN are as for build_new_method_call.\n \n-      fn = (*extractor) (type, client);\n-      if (fn)\n-\t{\n-\t  tree fn_raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n+   Returns a FUNCTION_DECL if all is well.\n+   Returns NULL_TREE if overload resolution failed.\n+   Returns error_mark_node if the chosen function cannot be called.  */\n \n-\t  raises = merge_exception_specifiers (raises, fn_raises);\n-\t}\n+static tree\n+locate_fn_flags (tree type, tree name, tree argtype, int flags,\n+\t\t tsubst_flags_t complain)\n+{\n+  tree ob, fn, fns, binfo, rval;\n+  VEC(tree,gc) *args;\n+\n+  if (TYPE_P (type))\n+    binfo = TYPE_BINFO (type);\n+  else\n+    {\n+      binfo = type;\n+      type = BINFO_TYPE (binfo);\n+    }\n+\n+  ob = build_stub_object (cp_build_reference_type (type, false));\n+  args = make_tree_vector ();\n+  if (argtype)\n+    {\n+      tree arg = build_stub_object (argtype);\n+      VEC_quick_push (tree, args, arg);\n     }\n-  return raises;\n+\n+  fns = lookup_fnfields (binfo, name, 0);\n+  rval = build_new_method_call (ob, fns, &args, binfo, flags, &fn, complain);\n+\n+  release_tree_vector (args);\n+  if (fn && rval == error_mark_node)\n+    return rval;\n+  else\n+    return fn;\n }\n \n /* Locate the dtor of TYPE.  */\n \n tree\n-locate_dtor (tree type, void *client ATTRIBUTE_UNUSED)\n+get_dtor (tree type)\n {\n-  return CLASSTYPE_DESTRUCTORS (type);\n+  tree fn = locate_fn_flags (type, complete_dtor_identifier, NULL_TREE,\n+\t\t\t     LOOKUP_NORMAL, tf_warning_or_error);\n+  if (fn == error_mark_node)\n+    return NULL_TREE;\n+  return fn;\n }\n \n /* Locate the default ctor of TYPE.  */\n \n tree\n-locate_ctor (tree type, void *client ATTRIBUTE_UNUSED)\n+locate_ctor (tree type)\n {\n-  tree fns;\n+  tree fn = locate_fn_flags (type, complete_ctor_identifier, NULL_TREE,\n+\t\t\t     LOOKUP_SPECULATIVE, tf_none);\n+  if (fn == error_mark_node)\n+    return NULL_TREE;\n+  return fn;\n+}\n+\n+/* Likewise, but give any appropriate errors.  */\n \n-  if (!TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n+tree\n+get_default_ctor (tree type)\n+{\n+  tree fn = locate_fn_flags (type, complete_ctor_identifier, NULL_TREE,\n+\t\t\t     LOOKUP_NORMAL, tf_warning_or_error);\n+  if (fn == error_mark_node)\n+    return NULL_TREE;\n+  return fn;\n+}\n+\n+/* Locate the copy ctor of TYPE.  */\n+\n+tree\n+get_copy_ctor (tree type)\n+{\n+  int quals = (TYPE_HAS_CONST_COPY_CTOR (type)\n+\t       ? TYPE_QUAL_CONST : TYPE_UNQUALIFIED);\n+  tree argtype = build_stub_type (type, quals, false);\n+  tree fn = locate_fn_flags (type, complete_ctor_identifier, argtype,\n+\t\t\t     LOOKUP_NORMAL, tf_warning_or_error);\n+  if (fn == error_mark_node)\n     return NULL_TREE;\n+  return fn;\n+}\n \n-  /* Call lookup_fnfields_1 to create the constructor declarations, if\n-     necessary.  */\n-  if (CLASSTYPE_LAZY_DEFAULT_CTOR (type))\n-    return lazily_declare_fn (sfk_constructor, type);\n+/* Locate the copy assignment operator of TYPE.  */\n \n-  for (fns = CLASSTYPE_CONSTRUCTORS (type); fns; fns = OVL_NEXT (fns))\n+tree\n+get_copy_assign (tree type)\n+{\n+  int quals = (TYPE_HAS_CONST_COPY_ASSIGN (type)\n+\t       ? TYPE_QUAL_CONST : TYPE_UNQUALIFIED);\n+  tree argtype = build_stub_type (type, quals, false);\n+  tree fn = locate_fn_flags (type, ansi_assopname (NOP_EXPR), argtype,\n+\t\t\t     LOOKUP_NORMAL, tf_warning_or_error);\n+  if (fn == error_mark_node)\n+    return NULL_TREE;\n+  return fn;\n+}\n+\n+/* Subroutine of synthesized_method_walk.  Update SPEC_P, TRIVIAL_P and\n+   DELETED_P or give an error message MSG with argument ARG.  */\n+\n+static void\n+process_subob_fn (tree fn, bool move_p, tree *spec_p, bool *trivial_p,\n+\t\t  bool *deleted_p, const char *msg, tree arg)\n+{\n+  if (!fn || fn == error_mark_node)\n+    goto bad;\n+\n+  if (spec_p)\n     {\n-      tree fn = OVL_CURRENT (fns);\n-      tree parms = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+      tree raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n+      *spec_p = merge_exception_specifiers (*spec_p, raises);\n+    }\n \n-      parms = skip_artificial_parms_for (fn, parms);\n+  if (trivial_p && !trivial_fn_p (fn))\n+    *trivial_p = false;\n \n-      if (sufficient_parms_p (parms))\n-\treturn fn;\n+  if (move_p && !move_fn_p (fn) && !trivial_fn_p (fn))\n+    {\n+      if (msg)\n+\terror (msg, arg);\n+      goto bad;\n     }\n-  gcc_unreachable ();\n+\n+  return;\n+\n+ bad:\n+  if (deleted_p)\n+    *deleted_p = true;\n }\n \n-struct copy_data\n+/* The caller wants to generate an implicit declaration of SFK for CTYPE\n+   which is const if relevant and CONST_P is set.  If spec_p, trivial_p and\n+   deleted_p are non-null, set their referent appropriately.  If diag is\n+   true, we're being called from maybe_explain_implicit_delete to give\n+   errors.  */\n+\n+static void\n+synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n+\t\t\t tree *spec_p, bool *trivial_p, bool *deleted_p,\n+\t\t\t bool diag)\n {\n-  tree name;\n-  int quals;\n-};\n+  tree binfo, base_binfo, field, scope, fnname, rval, argtype;\n+  bool move_p, copy_arg_p, assign_p, expected_trivial, check_vdtor;\n+  VEC(tree,gc) *vbases;\n+  int i, quals, flags;\n+  tsubst_flags_t complain;\n+  const char *msg;\n+\n+  if (spec_p)\n+    *spec_p = (cxx_dialect >= cxx0x\n+\t       ? noexcept_true_spec : empty_except_spec);\n+\n+  if (deleted_p)\n+    {\n+      /* \"The closure type associated with a lambda-expression has a deleted\n+\t default constructor and a deleted copy assignment operator.\"\n+         This is diagnosed in maybe_explain_implicit_delete.  */\n+      if (LAMBDA_TYPE_P (ctype)\n+\t  && (sfk == sfk_constructor\n+\t      || sfk == sfk_copy_assignment))\n+\t{\n+\t  *deleted_p = true;\n+\t  return;\n+\t}\n \n-/* Locate the copy ctor or copy assignment of TYPE. CLIENT_\n-   points to a COPY_DATA holding the name (NULL for the ctor)\n-   and desired qualifiers of the source operand.  */\n+      *deleted_p = false;\n+    }\n \n-tree\n-locate_copy (tree type, void *client_)\n-{\n-  struct copy_data *client = (struct copy_data *)client_;\n-  tree fns;\n-  tree best = NULL_TREE;\n-  bool excess_p = false;\n+  move_p = false;\n+  switch (sfk)\n+    {\n+    case sfk_constructor:\n+    case sfk_destructor:\n+      copy_arg_p = false;\n+      break;\n+\n+    case sfk_move_constructor:\n+    case sfk_move_assignment:\n+      move_p = true;\n+    case sfk_copy_constructor:\n+    case sfk_copy_assignment:\n+      copy_arg_p = true;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  expected_trivial = type_has_trivial_fn (ctype, sfk);\n+  if (trivial_p)\n+    *trivial_p = expected_trivial;\n+\n+#ifndef ENABLE_CHECKING\n+  /* The TYPE_HAS_COMPLEX_* flags tell us about constraints from base\n+     class versions and other properties of the type.  But a subobject\n+     class can be trivially copyable and yet have overload resolution\n+     choose a template constructor for initialization, depending on\n+     rvalueness and cv-quals.  So we can't exit early for copy/move\n+     methods in C++0x.  */\n+  if (expected_trivial\n+      && (!copy_arg_p || cxx_dialect < cxx0x))\n+    return;\n+#endif\n \n-  if (client->name)\n+  assign_p = false;\n+  switch (sfk)\n     {\n-      int ix;\n-      ix = lookup_fnfields_1 (type, client->name);\n-      if (ix < 0)\n-\treturn NULL_TREE;\n-      fns = VEC_index (tree, CLASSTYPE_METHOD_VEC (type), ix);\n+    case sfk_move_assignment:\n+    case sfk_copy_assignment:\n+      assign_p = true;\n+      fnname = ansi_assopname (NOP_EXPR);\n+      break;\n+\n+    case sfk_destructor:\n+      check_vdtor = true;\n+      /* The synthesized method will call base dtors, but check complete\n+\t here to avoid having to deal with VTT.  */\n+      fnname = complete_dtor_identifier;\n+      break;\n+\n+    case sfk_constructor:\n+    case sfk_move_constructor:\n+    case sfk_copy_constructor:\n+      fnname = complete_ctor_identifier;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  else if (TYPE_HAS_COPY_CTOR (type))\n+\n+  ++cp_unevaluated_operand;\n+  ++c_inhibit_evaluation_warnings;\n+\n+  scope = push_scope (ctype);\n+\n+  if (diag)\n     {\n-      /* If construction of the copy constructor was postponed, create\n-\t it now.  */\n-      if (CLASSTYPE_LAZY_COPY_CTOR (type))\n-\tlazily_declare_fn (sfk_copy_constructor, type);\n-      if (CLASSTYPE_LAZY_MOVE_CTOR (type))\n-\tlazily_declare_fn (sfk_move_constructor, type);\n-      fns = CLASSTYPE_CONSTRUCTORS (type);\n+      flags = LOOKUP_NORMAL|LOOKUP_SPECULATIVE;\n+      complain = tf_warning_or_error;\n     }\n   else\n-    return NULL_TREE;\n-  for (; fns; fns = OVL_NEXT (fns))\n     {\n-      tree fn = OVL_CURRENT (fns);\n-      tree parms = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-      tree src_type;\n-      int excess;\n-      int quals;\n-\n-      parms = skip_artificial_parms_for (fn, parms);\n-      if (!parms)\n-\tcontinue;\n-      src_type = non_reference (TREE_VALUE (parms));\n+      flags = LOOKUP_PROTECT|LOOKUP_SPECULATIVE;\n+      complain = tf_none;\n+    }\n \n-      if (src_type == error_mark_node)\n-        return NULL_TREE;\n+  if (const_p)\n+    quals = TYPE_QUAL_CONST;\n+  else\n+    quals = TYPE_UNQUALIFIED;\n+  argtype = NULL_TREE;\n \n-      if (!same_type_ignoring_top_level_qualifiers_p (src_type, type))\n-\tcontinue;\n-      if (!sufficient_parms_p (TREE_CHAIN (parms)))\n+  for (binfo = TYPE_BINFO (ctype), i = 0;\n+       BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n+    {\n+      tree basetype = BINFO_TYPE (base_binfo);\n+      if (copy_arg_p)\n+\targtype = build_stub_type (basetype, quals, move_p);\n+      rval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n+\n+      if (!diag)\n+\tmsg = NULL;\n+      else if (assign_p)\n+\tmsg = (\"base %qT does not have a move assignment operator or trivial \"\n+\t       \"copy assignment operator\");\n+      else\n+\tmsg = (\"base %qT does not have a move constructor or trivial \"\n+\t       \"copy constructor\");\n+\n+      process_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n+\t\t\tmsg, BINFO_TYPE (base_binfo));\n+\n+      if (check_vdtor && type_has_virtual_destructor (basetype))\n+\t{\n+\t  rval = locate_fn_flags (ctype, ansi_opname (DELETE_EXPR),\n+\t\t\t\t  ptr_type_node, flags, complain);\n+\t  /* Unlike for base ctor/op=/dtor, for operator delete it's fine\n+\t     to have a null rval (no class-specific op delete).  */\n+\t  if (rval && rval == error_mark_node && deleted_p)\n+\t    *deleted_p = true;\n+\t}\n+    }\n+\n+  vbases = CLASSTYPE_VBASECLASSES (ctype);\n+  if (vbases && assign_p && move_p)\n+    {\n+      /* Should the spec be changed to allow vbases that only occur once?  */\n+      if (diag)\n+\terror (\"%qT has virtual bases, default move assignment operator \"\n+\t       \"cannot be generated\", ctype);\n+      else if (deleted_p)\n+\t*deleted_p = true;\n+    }\n+  else if (!assign_p)\n+    for (i = 0; VEC_iterate (tree, vbases, i, base_binfo); ++i)\n+      {\n+\tif (copy_arg_p)\n+\t  argtype = build_stub_type (BINFO_TYPE (base_binfo), quals, move_p);\n+\trval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n+\n+\tif (!diag)\n+\t  msg = NULL;\n+\telse if (assign_p)\n+\t  msg = (\"virtual base %qT does not have a move assignment \"\n+\t\t \"operator or trivial copy assignment operator\");\n+\telse\n+\t  msg = (\"virtual base %qT does not have a move constructor \"\n+\t\t \"or trivial copy constructor\");\n+\n+\tprocess_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n+\t\t\t  msg, BINFO_TYPE (base_binfo));\n+      }\n+\n+  for (field = TYPE_FIELDS (ctype); field; field = TREE_CHAIN (field))\n+    {\n+      tree mem_type;\n+\n+      if (TREE_CODE (field) != FIELD_DECL\n+\t  || DECL_ARTIFICIAL (field))\n \tcontinue;\n-      quals = cp_type_quals (src_type);\n-      if (client->quals & ~quals)\n+\n+      mem_type = strip_array_types (TREE_TYPE (field));\n+      if (assign_p)\n+\t{\n+\t  bool bad = true;\n+\t  if (CP_TYPE_CONST_P (mem_type) && !CLASS_TYPE_P (mem_type))\n+\t    {\n+\t      if (diag)\n+\t\terror (\"non-static const member %q#D, can't use default \"\n+\t\t       \"assignment operator\", field);\n+\t    }\n+\t  else if (TREE_CODE (mem_type) == REFERENCE_TYPE)\n+\t    {\n+\t      if (diag)\n+\t\terror (\"non-static reference member %q#D, can't use \"\n+\t\t       \"default assignment operator\", field);\n+\t    }\n+\t  else\n+\t    bad = false;\n+\n+\t  if (bad && deleted_p)\n+\t    *deleted_p = true;\n+\t}\n+      else if (sfk == sfk_constructor)\n+\t{\n+\t  bool bad = true;\n+\t  if (CP_TYPE_CONST_P (mem_type)\n+\t      && (!CLASS_TYPE_P (mem_type)\n+\t\t  || !type_has_user_provided_default_constructor (mem_type)))\n+\t    {\n+\t      if (diag)\n+\t\terror (\"uninitialized non-static const member %q#D\",\n+\t\t       field);\n+\t    }\n+\t  else if (TREE_CODE (mem_type) == REFERENCE_TYPE)\n+\t    {\n+\t      if (diag)\n+\t\terror (\"uninitialized non-static reference member %q#D\",\n+\t\t       field);\n+\t    }\n+\t  else\n+\t    bad = false;\n+\n+\t  if (bad && deleted_p)\n+\t    *deleted_p = true;\n+\t}\n+\n+      if (!CLASS_TYPE_P (mem_type)\n+\t  || ANON_AGGR_TYPE_P (mem_type))\n \tcontinue;\n-      excess = quals & ~client->quals;\n-      if (!best || (excess_p && !excess))\n+\n+      if (copy_arg_p)\n \t{\n-\t  best = fn;\n-\t  excess_p = excess;\n+\t  int mem_quals = cp_type_quals (mem_type) | quals;\n+\t  if (DECL_MUTABLE_P (field))\n+\t    mem_quals &= ~TYPE_QUAL_CONST;\n+\t  argtype = build_stub_type (mem_type, mem_quals, move_p);\n \t}\n+\n+      rval = locate_fn_flags (mem_type, fnname, argtype, flags, complain);\n+\n+      if (!diag)\n+\tmsg = NULL;\n+      else if (assign_p)\n+\tmsg = (\"non-static data member %qD does not have a move \"\n+\t       \"assignment operator or trivial copy assignment operator\");\n       else\n-\t/* Ambiguous */\n-\treturn NULL_TREE;\n+\tmsg = (\"non-static data member %qD does not have a move \"\n+\t       \"constructor or trivial copy constructor\");\n+\n+      process_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n+\t\t\tmsg, field);\n     }\n-  return best;\n+\n+  pop_scope (scope);\n+\n+  --cp_unevaluated_operand;\n+  --c_inhibit_evaluation_warnings;\n+\n+#ifdef ENABLE_CHECKING\n+  /* If we expected this to be trivial but it isn't, then either we're in\n+     C++0x mode and this is a copy/move ctor/op= or there's an error.  */\n+  gcc_assert (!(trivial_p && expected_trivial && !*trivial_p)\n+\t      || (copy_arg_p && cxx_dialect >= cxx0x)\n+\t      || errorcount);\n+#endif\n+}\n+\n+/* DECL is a deleted function.  If it's implicitly deleted, explain why and\n+   return true; else return false.  */\n+\n+bool\n+maybe_explain_implicit_delete (tree decl)\n+{\n+  /* If decl is a clone, get the primary variant.  */\n+  decl = DECL_ORIGIN (decl);\n+  gcc_assert (DECL_DELETED_FN (decl));\n+  if (DECL_DEFAULTED_FN (decl)\n+      && DECL_INITIAL (decl) == NULL_TREE)\n+    {\n+      /* Not marked GTY; it doesn't need to be GC'd or written to PCH.  */\n+      static htab_t explained_htab;\n+      void **slot;\n+\n+      special_function_kind sfk;\n+      location_t loc;\n+      bool informed;\n+      tree ctype;\n+\n+      if (!explained_htab)\n+\texplained_htab = htab_create (37, htab_hash_pointer,\n+\t\t\t\t      htab_eq_pointer, NULL);\n+      slot = htab_find_slot (explained_htab, decl, INSERT);\n+      if (*slot)\n+\treturn true;\n+      *slot = decl;\n+\n+      sfk = special_function_p (decl);\n+      ctype = DECL_CONTEXT (decl);\n+      loc = input_location;\n+      input_location = DECL_SOURCE_LOCATION (decl);\n+\n+      informed = false;\n+      if (LAMBDA_TYPE_P (ctype))\n+\t{\n+\t  informed = true;\n+\t  if (sfk == sfk_constructor)\n+\t    error (\"a lambda closure type has a deleted default constructor\");\n+\t  else if (sfk == sfk_copy_assignment)\n+\t    error (\"a lambda closure type has a deleted copy assignment operator\");\n+\t  else\n+\t    informed = false;\n+\t}\n+      if (!informed)\n+\t{\n+\t  tree parm_type = TREE_VALUE (FUNCTION_FIRST_USER_PARMTYPE (decl));\n+\t  bool const_p = CP_TYPE_CONST_P (non_reference (parm_type));\n+\t  tree scope = push_scope (ctype);\n+\t  error (\"%qD is implicitly deleted because the default \"\n+\t\t \"definition would be ill-formed:\", decl);\n+\t  pop_scope (scope);\n+\t  synthesized_method_walk (ctype, sfk, const_p,\n+\t\t\t\t   NULL, NULL, NULL, true);\n+\t}\n+\n+      input_location = loc;\n+      return true;\n+    }\n+  return false;\n }\n \n /* Implicitly declare the special function indicated by KIND, as a\n@@ -872,6 +1288,8 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n   tree this_parm;\n   tree name;\n   HOST_WIDE_INT saved_processing_template_decl;\n+  bool deleted_p;\n+  bool trivial_p;\n \n   /* Because we create declarations for implicitly declared functions\n      lazily, we may be creating the declaration for a member of TYPE\n@@ -903,50 +1321,49 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n     case sfk_destructor:\n       /* Destructor.  */\n       name = constructor_name (type);\n-      raises = synthesize_exception_spec (type, &locate_dtor, 0);\n       break;\n \n     case sfk_constructor:\n       /* Default constructor.  */\n       name = constructor_name (type);\n-      raises = synthesize_exception_spec (type, &locate_ctor, 0);\n       break;\n \n     case sfk_copy_constructor:\n     case sfk_copy_assignment:\n     case sfk_move_constructor:\n+    case sfk_move_assignment:\n     {\n-      struct copy_data data;\n-\n-      data.name = NULL;\n-      data.quals = 0;\n-      if (kind == sfk_copy_assignment)\n+      bool move_p;\n+      if (kind == sfk_copy_assignment\n+\t  || kind == sfk_move_assignment)\n \t{\n \t  return_type = build_reference_type (type);\n \t  name = ansi_assopname (NOP_EXPR);\n-\t  data.name = name;\n \t}\n       else\n \tname = constructor_name (type);\n \n       if (const_p)\n-\t{\n-\t  data.quals = TYPE_QUAL_CONST;\n-\t  rhs_parm_type = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n-\t}\n+\trhs_parm_type = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n       else\n \trhs_parm_type = type;\n-      rhs_parm_type\n-\t= cp_build_reference_type (rhs_parm_type,\n-\t\t\t\t   kind == sfk_move_constructor);\n+      move_p = (kind == sfk_move_assignment\n+\t\t|| kind == sfk_move_constructor);\n+      rhs_parm_type = cp_build_reference_type (rhs_parm_type, move_p);\n+\n       parameter_types = tree_cons (NULL_TREE, rhs_parm_type, parameter_types);\n-      raises = synthesize_exception_spec (type, &locate_copy, &data);\n       break;\n     }\n     default:\n       gcc_unreachable ();\n     }\n \n+  synthesized_method_walk (type, kind, const_p, &raises, &trivial_p,\n+\t\t\t   &deleted_p, false);\n+\n+  if (!trivial_p && type_has_trivial_fn (type, kind))\n+    type_set_nontrivial_flag (type, kind);\n+\n   /* Create the function.  */\n   fn_type = build_method_type_directly (type, return_type, parameter_types);\n   if (raises)\n@@ -1031,6 +1448,9 @@ defaulted_late_check (tree fn)\n       tree eh_spec = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (implicit_fn));\n       TREE_TYPE (fn) = build_exception_variant (TREE_TYPE (fn), eh_spec);\n     }\n+\n+  if (DECL_DELETED_FN (implicit_fn))\n+    DECL_DELETED_FN (fn) = 1;\n }\n \n /* Returns true iff FN can be explicitly defaulted, and gives any\n@@ -1055,9 +1475,13 @@ defaultable_fn_check (tree fn)\n   else if (DECL_DESTRUCTOR_P (fn))\n     kind = sfk_destructor;\n   else if (DECL_ASSIGNMENT_OPERATOR_P (fn)\n-\t   && DECL_OVERLOADED_OPERATOR_P (fn) == NOP_EXPR\n-\t   && copy_fn_p (fn))\n-    kind = sfk_copy_assignment;\n+\t   && DECL_OVERLOADED_OPERATOR_P (fn) == NOP_EXPR)\n+    {\n+      if (copy_fn_p (fn))\n+\tkind = sfk_copy_assignment;\n+      else if (move_fn_p (fn))\n+\tkind = sfk_move_assignment;\n+    }\n \n   if (kind == sfk_none)\n     {\n@@ -1103,21 +1527,48 @@ tree\n lazily_declare_fn (special_function_kind sfk, tree type)\n {\n   tree fn;\n-  bool const_p;\n-\n-  /* Figure out whether or not the argument has a const reference\n-     type.  */\n-  if (sfk == sfk_copy_constructor)\n-    const_p = TYPE_HAS_CONST_COPY_CTOR (type);\n-  else if (sfk == sfk_copy_assignment)\n-    const_p = TYPE_HAS_CONST_COPY_ASSIGN (type);\n-  else\n-    /* In this case, CONST_P will be ignored.  */\n-    const_p = false;\n+  /* Whether or not the argument has a const reference type.  */\n+  bool const_p = false;\n+\n+  switch (sfk)\n+    {\n+    case sfk_constructor:\n+      CLASSTYPE_LAZY_DEFAULT_CTOR (type) = 0;\n+      break;\n+    case sfk_copy_constructor:\n+      const_p = TYPE_HAS_CONST_COPY_CTOR (type);\n+      CLASSTYPE_LAZY_COPY_CTOR (type) = 0;\n+      break;\n+    case sfk_move_constructor:\n+      CLASSTYPE_LAZY_MOVE_CTOR (type) = 0;\n+      break;\n+    case sfk_copy_assignment:\n+      const_p = TYPE_HAS_CONST_COPY_ASSIGN (type);\n+      CLASSTYPE_LAZY_COPY_ASSIGN (type) = 0;\n+      break;\n+    case sfk_move_assignment:\n+      CLASSTYPE_LAZY_MOVE_ASSIGN (type) = 0;\n+      break;\n+    case sfk_destructor:\n+      CLASSTYPE_LAZY_DESTRUCTOR (type) = 0;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n   /* Declare the function.  */\n   fn = implicitly_declare_fn (sfk, type, const_p);\n+\n+  /* For move variants, rather than declare them as deleted we just\n+     don't declare them at all.  */\n+  if (DECL_DELETED_FN (fn)\n+      && (sfk == sfk_move_constructor\n+\t  || sfk == sfk_move_assignment))\n+    return NULL_TREE;\n+\n   /* A destructor may be virtual.  */\n   if (sfk == sfk_destructor\n+      || sfk == sfk_move_assignment\n       || sfk == sfk_copy_assignment)\n     check_for_override (fn, type);\n   /* Add it to CLASSTYPE_METHOD_VEC.  */\n@@ -1143,22 +1594,10 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n       TYPE_METHODS (type) = fn;\n     }\n   maybe_add_class_template_decl_list (type, fn, /*friend_p=*/0);\n-  if (sfk == sfk_copy_assignment)\n-    CLASSTYPE_LAZY_COPY_ASSIGN (type) = 0;\n-  else\n-    {\n-      /* Remember that the function has been created.  */\n-      if (sfk == sfk_constructor)\n-\tCLASSTYPE_LAZY_DEFAULT_CTOR (type) = 0;\n-      else if (sfk == sfk_copy_constructor)\n-\tCLASSTYPE_LAZY_COPY_CTOR (type) = 0;\n-      else if (sfk == sfk_move_constructor)\n-\tCLASSTYPE_LAZY_MOVE_CTOR (type) = 0;\n-      else if (sfk == sfk_destructor)\n-\tCLASSTYPE_LAZY_DESTRUCTOR (type) = 0;\n-      /* Create appropriate clones.  */\n-      clone_function_decl (fn, /*update_method_vec=*/true);\n-    }\n+  if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (fn)\n+      || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn))\n+    /* Create appropriate clones.  */\n+    clone_function_decl (fn, /*update_method_vec=*/true);\n \n   return fn;\n }"}, {"sha": "9dbefd3c5bc7727888d22da4b364edd2c59677fc", "filename": "gcc/cp/search.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=ac1774315cb7ebc781ade2f9fd99de1c258b9221", "patch": "@@ -1335,7 +1335,7 @@ lookup_conversion_operator (tree class_type, tree type)\n }\n \n /* TYPE is a class type. Return the index of the fields within\n-   the method vector with name NAME, or -1 is no such field exists.  */\n+   the method vector with name NAME, or -1 if no such field exists.  */\n \n int\n lookup_fnfields_1 (tree type, tree name)\n@@ -1361,9 +1361,13 @@ lookup_fnfields_1 (tree type, tree name)\n \t  if (CLASSTYPE_LAZY_MOVE_CTOR (type))\n \t    lazily_declare_fn (sfk_move_constructor, type);\n \t}\n-      else if (name == ansi_assopname(NOP_EXPR)\n-\t       && CLASSTYPE_LAZY_COPY_ASSIGN (type))\n-\tlazily_declare_fn (sfk_copy_assignment, type);\n+      else if (name == ansi_assopname (NOP_EXPR))\n+\t{\n+\t  if (CLASSTYPE_LAZY_COPY_ASSIGN (type))\n+\t    lazily_declare_fn (sfk_copy_assignment, type);\n+\t  if (CLASSTYPE_LAZY_MOVE_ASSIGN (type))\n+\t    lazily_declare_fn (sfk_move_assignment, type);\n+\t}\n       else if ((name == dtor_identifier\n \t\t|| name == base_dtor_identifier\n \t\t|| name == complete_dtor_identifier\n@@ -1441,6 +1445,18 @@ lookup_fnfields_1 (tree type, tree name)\n   return -1;\n }\n \n+/* TYPE is a class type. Return the field within the method vector with\n+   name NAME, or NULL_TREE if no such field exists.  */\n+\n+tree\n+lookup_fnfields_slot (tree type, tree name)\n+{\n+  int ix = lookup_fnfields_1 (type, name);\n+  if (ix < 0)\n+    return NULL_TREE;\n+  return VEC_index (tree, CLASSTYPE_METHOD_VEC (type), ix);\n+}\n+\n /* Like lookup_fnfields_1, except that the name is extracted from\n    FUNCTION, which is a FUNCTION_DECL or a TEMPLATE_DECL.  */\n \n@@ -1889,6 +1905,7 @@ check_final_overrider (tree overrider, tree basefn)\n \t{\n \t  error (\"deleted function %q+D\", overrider);\n \t  error (\"overriding non-deleted function %q+D\", basefn);\n+\t  maybe_explain_implicit_delete (overrider);\n \t}\n       else\n \t{"}, {"sha": "156f278e17142daa7e0d83eab899d96d2a0c70e2", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 11, "deletions": 89, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=ac1774315cb7ebc781ade2f9fd99de1c258b9221", "patch": "@@ -3527,31 +3527,6 @@ finalize_nrv (tree *tp, tree var, tree result)\n   htab_delete (data.visited);\n }\n \f\n-/* Return the declaration for the function called by CALL_EXPR T,\n-   TYPE is the class type of the clause decl.  */\n-\n-static tree\n-omp_clause_info_fndecl (tree t, tree type)\n-{\n-  tree ret = get_callee_fndecl (t);\n-\n-  if (ret)\n-    return ret;\n-\n-  gcc_assert (TREE_CODE (t) == CALL_EXPR);\n-  t = CALL_EXPR_FN (t);\n-  STRIP_NOPS (t);\n-  if (TREE_CODE (t) == OBJ_TYPE_REF)\n-    {\n-      t = cp_fold_obj_type_ref (t, type);\n-      if (TREE_CODE (t) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (t, 0)) == FUNCTION_DECL)\n-\treturn TREE_OPERAND (t, 0);\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Create CP_OMP_CLAUSE_INFO for clause C.  Returns true if it is invalid.  */\n \n bool\n@@ -3569,80 +3544,27 @@ cxx_omp_create_clause_info (tree c, tree type, bool need_default_ctor,\n   info = make_tree_vec (3);\n   CP_OMP_CLAUSE_INFO (c) = info;\n \n-  if (need_default_ctor\n-      || (need_copy_ctor && !TYPE_HAS_TRIVIAL_COPY_CTOR (type)))\n+  if (need_default_ctor || need_copy_ctor)\n     {\n-      VEC(tree,gc) *vec;\n-\n       if (need_default_ctor)\n-\tvec = NULL;\n+\tt = get_default_ctor (type);\n       else\n-\t{\n-\t  t = build_int_cst (build_pointer_type (type), 0);\n-\t  t = build1 (INDIRECT_REF, type, t);\n-\t  vec = make_tree_vector_single (t);\n-\t}\n-      t = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n-\t\t\t\t     &vec, type, LOOKUP_NORMAL,\n-\t\t\t\t     tf_warning_or_error);\n+\tt = get_copy_ctor (type);\n \n-      if (vec != NULL)\n-\trelease_tree_vector (vec);\n-\n-      if (targetm.cxx.cdtor_returns_this () || errorcount)\n-\t/* Because constructors and destructors return this,\n-\t   the call will have been cast to \"void\".  Remove the\n-\t   cast here.  We would like to use STRIP_NOPS, but it\n-\t   wouldn't work here because TYPE_MODE (t) and\n-\t   TYPE_MODE (TREE_OPERAND (t, 0)) are different.\n-\t   They are VOIDmode and Pmode, respectively.  */\n-\tif (TREE_CODE (t) == NOP_EXPR)\n-\t  t = TREE_OPERAND (t, 0);\n-\n-      TREE_VEC_ELT (info, 0) = get_callee_fndecl (t);\n+      if (t && !trivial_fn_p (t))\n+\tTREE_VEC_ELT (info, 0) = t;\n     }\n \n   if ((need_default_ctor || need_copy_ctor)\n       && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n-    {\n-      t = build_int_cst (build_pointer_type (type), 0);\n-      t = build1 (INDIRECT_REF, type, t);\n-      t = build_special_member_call (t, complete_dtor_identifier,\n-\t\t\t\t     NULL, type, LOOKUP_NORMAL,\n-\t\t\t\t     tf_warning_or_error);\n+    TREE_VEC_ELT (info, 1) = get_dtor (type);\n \n-      if (targetm.cxx.cdtor_returns_this () || errorcount)\n-\t/* Because constructors and destructors return this,\n-\t   the call will have been cast to \"void\".  Remove the\n-\t   cast here.  We would like to use STRIP_NOPS, but it\n-\t   wouldn't work here because TYPE_MODE (t) and\n-\t   TYPE_MODE (TREE_OPERAND (t, 0)) are different.\n-\t   They are VOIDmode and Pmode, respectively.  */\n-\tif (TREE_CODE (t) == NOP_EXPR)\n-\t  t = TREE_OPERAND (t, 0);\n-\n-      TREE_VEC_ELT (info, 1) = omp_clause_info_fndecl (t, type);\n-    }\n-\n-  if (need_copy_assignment && !TYPE_HAS_TRIVIAL_COPY_ASSIGN (type))\n+  if (need_copy_assignment)\n     {\n-      VEC(tree,gc) *vec;\n-\n-      t = build_int_cst (build_pointer_type (type), 0);\n-      t = build1 (INDIRECT_REF, type, t);\n-      vec = make_tree_vector_single (t);\n-      t = build_special_member_call (t, ansi_assopname (NOP_EXPR),\n-\t\t\t\t     &vec, type, LOOKUP_NORMAL,\n-\t\t\t\t     tf_warning_or_error);\n-      release_tree_vector (vec);\n-\n-      /* We'll have called convert_from_reference on the call, which\n-\t may well have added an indirect_ref.  It's unneeded here,\n-\t and in the way, so kill it.  */\n-      if (TREE_CODE (t) == INDIRECT_REF)\n-\tt = TREE_OPERAND (t, 0);\n+      t = get_copy_assign (type);\n \n-      TREE_VEC_ELT (info, 2) = omp_clause_info_fndecl (t, type);\n+      if (t && !trivial_fn_p (t))\n+\tTREE_VEC_ELT (info, 2) = t;\n     }\n \n   return errorcount != save_errorcount;\n@@ -5076,7 +4998,7 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n       type1 = strip_array_types (type1);\n       return (trait_expr_value (CPTK_HAS_TRIVIAL_CONSTRUCTOR, type1, type2) \n \t      || (CLASS_TYPE_P (type1)\n-\t\t  && (t = locate_ctor (type1, NULL))\n+\t\t  && (t = locate_ctor (type1))\n \t\t  && TYPE_NOTHROW_P (TREE_TYPE (t))));\n \n     case CPTK_HAS_TRIVIAL_CONSTRUCTOR:"}, {"sha": "3367a093d36b0e1d5d340c8eb5f2936846bb0801", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1774315cb7ebc781ade2f9fd99de1c258b9221/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=ac1774315cb7ebc781ade2f9fd99de1c258b9221", "patch": "@@ -2847,7 +2847,12 @@ special_function_p (const_tree decl)\n   if (DECL_CONSTRUCTOR_P (decl))\n     return sfk_constructor;\n   if (DECL_OVERLOADED_OPERATOR_P (decl) == NOP_EXPR)\n-    return sfk_copy_assignment;\n+    {\n+      if (copy_fn_p (decl))\n+\treturn sfk_copy_assignment;\n+      if (move_fn_p (decl))\n+\treturn sfk_move_assignment;\n+    }\n   if (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (decl))\n     return sfk_destructor;\n   if (DECL_COMPLETE_DESTRUCTOR_P (decl))"}]}