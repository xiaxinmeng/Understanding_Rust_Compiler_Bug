{"sha": "3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RjYzY4YTQ0YTAwNWNkNmQyODAyZmVkM2M2MmU1YTNmODk3YTFjNQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2001-12-17T16:46:11Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2001-12-17T16:46:11Z"}, "message": "Implement MODE_BASE_REG_CLASS\n\nFrom-SVN: r48104", "tree": {"sha": "abc7579f7c4d9b9f1797f4d5240635fb9e483b13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abc7579f7c4d9b9f1797f4d5240635fb9e483b13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/comments", "author": null, "committer": null, "parents": [{"sha": "bc8224a5e956cd863d4506b372f2663a0e0e3c26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc8224a5e956cd863d4506b372f2663a0e0e3c26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc8224a5e956cd863d4506b372f2663a0e0e3c26"}], "stats": {"total": 135, "additions": 90, "deletions": 45}, "files": [{"sha": "1e6e6349aa140183dc9e8b5e533ae00ab6a4af74", "filename": "gcc/caller-save.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5", "patch": "@@ -151,7 +151,9 @@ init_caller_save ()\n      that register in every mode we will use to save registers.  */\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (TEST_HARD_REG_BIT (reg_class_contents[(int) BASE_REG_CLASS], i))\n+    if (TEST_HARD_REG_BIT\n+\t(reg_class_contents\n+\t [(int) MODE_BASE_REG_CLASS (regno_save_mode [i][1])], i))\n       break;\n \n   if (i == FIRST_PSEUDO_REGISTER)"}, {"sha": "85fea19560a1f0aa58cfcab82c3724f9fbe12cfc", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5", "patch": "@@ -256,6 +256,10 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n %{!mthumb-interwork:%{!mno-thumb-interwork:%(cpp_interwork_default)}}\t\\\n \"\n \n+#ifndef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"\"\n+#endif\n+\n #ifndef CC1_SPEC\n #define CC1_SPEC \"\"\n #endif\n@@ -1099,6 +1103,13 @@ enum reg_class\n #define INDEX_REG_CLASS  (TARGET_THUMB ? LO_REGS : GENERAL_REGS)\n #define BASE_REG_CLASS   (TARGET_THUMB ? BASE_REGS : GENERAL_REGS)\n \n+/* For the Thumb the high registers cannot be used as base\n+   registers when addressing quanitities in QI or HI mode.  */\n+#define MODE_BASE_REG_CLASS(MODE)\t\t\t\t\t\\\n+    (TARGET_ARM ? BASE_REGS :\t\t\t\t\t\t\\\n+     (((MODE) == QImode || (MODE) == HImode || (MODE) == VOIDmode)\t\\\n+     ? LO_REGS : BASE_REGS))\n+\n /* When SMALL_REGISTER_CLASSES is nonzero, the compiler allows\n    registers explicitly used in the rtl to be used as spill registers\n    but prevents the compiler from extending the lifetime of these"}, {"sha": "2a7c567297fa7da296fa76ce1638a6f40776a17c", "filename": "gcc/defaults.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5", "patch": "@@ -450,4 +450,11 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #define FUNCTION_ARG_REG_LITTLE_ENDIAN 0\n #endif\n \n+/* Determine the register class for registers suitable to be the base\n+   address register in a MEM.  Allow the choice to be dependent upon\n+   the mode of the memory access.  */\n+#ifndef MODE_BASE_REG_CLASS\n+#define MODE_BASE_REG_CLASS(MODE) BASE_REG_CLASS\n+#endif\n+\n #endif  /* ! GCC_DEFAULTS_H */"}, {"sha": "30c94eee8dd4f689ac2b4756dcdd8ad5d3472b6f", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5", "patch": "@@ -2203,6 +2203,13 @@ A macro whose definition is the name of the class to which a valid\n base register must belong.  A base register is one used in an address\n which is the register value plus a displacement.\n \n+@findex MODE_BASE_REG_CLASS\n+@item MODE_BASE_REG_CLASS (@var{mode})\n+This is a variation of the @code{BASE_REG_CLASS} macro which allows\n+the selection of a base register in a mode depenedent manner.  If\n+@var{mode} is VOIDmode then it should return the same value as\n+@code{BASE_REG_CLASS}.\n+\n @findex INDEX_REG_CLASS\n @item INDEX_REG_CLASS\n A macro whose definition is the name of the class to which a valid"}, {"sha": "652038a62f02e8965679bc7b69f1a7620dceaa0f", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5", "patch": "@@ -2244,7 +2244,8 @@ preprocess_constraints ()\n \n \t\tcase 'p':\n \t\t  op_alt[j].is_address = 1;\n-\t\t  op_alt[j].class = reg_class_subunion[(int) op_alt[j].class][(int) BASE_REG_CLASS];\n+\t\t  op_alt[j].class = reg_class_subunion[(int) op_alt[j].class]\n+\t\t    [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n \t\t  break;\n \n \t\tcase 'g': case 'r':"}, {"sha": "9bdb2b0ea497e27be8c3928055d333a0610d9457", "filename": "gcc/regclass.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5", "patch": "@@ -1005,10 +1005,10 @@ record_operand_costs (insn, op_costs, reg_pref)\n \n       if (GET_CODE (recog_data.operand[i]) == MEM)\n \trecord_address_regs (XEXP (recog_data.operand[i], 0),\n-\t\t\t     BASE_REG_CLASS, frequency * 2);\n+\t\t\t     MODE_BASE_REG_CLASS (modes[i]), frequency * 2);\n       else if (constraints[i][0] == 'p')\n \trecord_address_regs (recog_data.operand[i],\n-\t\t\t     BASE_REG_CLASS, frequency * 2);\n+\t\t\t     MODE_BASE_REG_CLASS (modes[i]), frequency * 2);\n     }\n \n   /* Check for commutative in a separate loop so everything will\n@@ -1086,7 +1086,7 @@ scan_one_insn (insn, pass)\n \t\t\t      GENERAL_REGS, 1)\n \t    * frequency);\n       record_address_regs (XEXP (SET_SRC (set), 0),\n-\t\t\t   BASE_REG_CLASS, frequency * 2);\n+\t\t\t   MODE_BASE_REG_CLASS (VOIDmode), frequency * 2);\n       return insn;\n     }\n \n@@ -1228,15 +1228,15 @@ regclass (f, nregs, dump)\n \n \t\t  if ((0\n #ifdef SECONDARY_RELOAD_CLASS\n-\t\t       || (SECONDARY_RELOAD_CLASS (BASE_REG_CLASS, m, r)\n+\t\t       || (SECONDARY_RELOAD_CLASS (MODE_BASE_REG_CLASS (VOIDmode), m, r)\n \t\t\t   != NO_REGS)\n #else\n #ifdef SECONDARY_INPUT_RELOAD_CLASS\n-\t\t       || (SECONDARY_INPUT_RELOAD_CLASS (BASE_REG_CLASS, m, r)\n+\t\t       || (SECONDARY_INPUT_RELOAD_CLASS (MODE_BASE_REG_CLASS (VOIDmode), m, r)\n \t\t\t   != NO_REGS)\n #endif\n #ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n-\t\t       || (SECONDARY_OUTPUT_RELOAD_CLASS (BASE_REG_CLASS, m, r)\n+\t\t       || (SECONDARY_OUTPUT_RELOAD_CLASS (MODE_BASE_REG_CLASS (VOIDmode), m, r)\n \t\t\t   != NO_REGS)\n #endif\n #endif\n@@ -1609,7 +1609,7 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n \t\t   address, ie BASE_REG_CLASS.  */\n \t\tclasses[i]\n \t\t  = reg_class_subunion[(int) classes[i]]\n-\t\t    [(int) BASE_REG_CLASS];\n+\t\t    [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n \t\tbreak;\n \n \t      case 'm':  case 'o':  case 'V':\n@@ -2016,7 +2016,7 @@ record_address_regs (x, class, scale)\n \t   as well as in the tests below, that all addresses are in \n \t   canonical form.  */\n \n-\telse if (INDEX_REG_CLASS == BASE_REG_CLASS)\n+\telse if (INDEX_REG_CLASS == MODE_BASE_REG_CLASS (VOIDmode))\n \t  {\n \t    record_address_regs (arg0, class, scale);\n \t    if (! CONSTANT_P (arg1))\n@@ -2045,14 +2045,14 @@ record_address_regs (x, class, scale)\n \t\t && (REG_OK_FOR_BASE_P (arg0) || REG_OK_FOR_INDEX_P (arg0)))\n \t  record_address_regs (arg1,\n \t\t\t       REG_OK_FOR_BASE_P (arg0)\n-\t\t\t       ? INDEX_REG_CLASS : BASE_REG_CLASS,\n+\t\t\t       ? INDEX_REG_CLASS : MODE_BASE_REG_CLASS (VOIDmode),\n \t\t\t       scale);\n \telse if (code0 == REG && code1 == REG\n \t\t && REGNO (arg1) < FIRST_PSEUDO_REGISTER\n \t\t && (REG_OK_FOR_BASE_P (arg1) || REG_OK_FOR_INDEX_P (arg1)))\n \t  record_address_regs (arg0,\n \t\t\t       REG_OK_FOR_BASE_P (arg1)\n-\t\t\t       ? INDEX_REG_CLASS : BASE_REG_CLASS,\n+\t\t\t       ? INDEX_REG_CLASS : MODE_BASE_REG_CLASS (VOIDmode),\n \t\t\t       scale);\n #endif\n \n@@ -2063,24 +2063,26 @@ record_address_regs (x, class, scale)\n \telse if ((code0 == REG && REG_POINTER (arg0))\n \t\t || code1 == MULT)\n \t  {\n-\t    record_address_regs (arg0, BASE_REG_CLASS, scale);\n+\t    record_address_regs (arg0, MODE_BASE_REG_CLASS (VOIDmode), scale);\n \t    record_address_regs (arg1, INDEX_REG_CLASS, scale);\n \t  }\n \telse if ((code1 == REG && REG_POINTER (arg1))\n \t\t || code0 == MULT)\n \t  {\n \t    record_address_regs (arg0, INDEX_REG_CLASS, scale);\n-\t    record_address_regs (arg1, BASE_REG_CLASS, scale);\n+\t    record_address_regs (arg1, MODE_BASE_REG_CLASS (VOIDmode), scale);\n \t  }\n \n \t/* Otherwise, count equal chances that each might be a base\n \t   or index register.  This case should be rare.  */\n \n \telse\n \t  {\n-\t    record_address_regs (arg0, BASE_REG_CLASS, scale / 2);\n+\t    record_address_regs (arg0, MODE_BASE_REG_CLASS (VOIDmode),\n+\t\t\t\t scale / 2);\n \t    record_address_regs (arg0, INDEX_REG_CLASS, scale / 2);\n-\t    record_address_regs (arg1, BASE_REG_CLASS, scale / 2);\n+\t    record_address_regs (arg1, MODE_BASE_REG_CLASS (VOIDmode),\n+\t\t\t\t scale / 2);\n \t    record_address_regs (arg1, INDEX_REG_CLASS, scale / 2);\n \t  }\n       }\n@@ -2091,7 +2093,8 @@ record_address_regs (x, class, scale)\n \t if it ends up in the wrong place.  */\n     case POST_MODIFY:\n     case PRE_MODIFY:\n-      record_address_regs (XEXP (x, 0), BASE_REG_CLASS, 2 * scale);\n+      record_address_regs (XEXP (x, 0), MODE_BASE_REG_CLASS (VOIDmode),\n+\t\t\t   2 * scale);\n       if (REG_P (XEXP (XEXP (x, 1), 1)))\n \trecord_address_regs (XEXP (XEXP (x, 1), 1),\n \t\t\t     INDEX_REG_CLASS, 2 * scale);"}, {"sha": "fca249e99e8178eeccaec65d9f2d08a1366d38f6", "filename": "gcc/regrename.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5", "patch": "@@ -611,7 +611,7 @@ scan_rtx_address (insn, loc, class, action, mode)\n \tif (locI)\n \t  scan_rtx_address (insn, locI, INDEX_REG_CLASS, action, mode);\n \tif (locB)\n-\t  scan_rtx_address (insn, locB, BASE_REG_CLASS, action, mode);\n+\t  scan_rtx_address (insn, locB, MODE_BASE_REG_CLASS (mode), action, mode);\n \treturn;\n       }\n \n@@ -629,7 +629,8 @@ scan_rtx_address (insn, loc, class, action, mode)\n       break;\n \n     case MEM:\n-      scan_rtx_address (insn, &XEXP (x, 0), BASE_REG_CLASS, action,\n+      scan_rtx_address (insn, &XEXP (x, 0),\n+\t\t\tMODE_BASE_REG_CLASS (GET_MODE (x)), action,\n \t\t\tGET_MODE (x));\n       return;\n \n@@ -683,7 +684,8 @@ scan_rtx (insn, loc, class, action, type, earlyclobber)\n       return;\n \n     case MEM:\n-      scan_rtx_address (insn, &XEXP (x, 0), BASE_REG_CLASS, action,\n+      scan_rtx_address (insn, &XEXP (x, 0),\n+\t\t\tMODE_BASE_REG_CLASS (GET_MODE (x)), action,\n \t\t\tGET_MODE (x));\n       return;\n \n@@ -1376,8 +1378,9 @@ replace_oldest_value_addr (loc, class, mode, insn, vd)\n \t  changed |= replace_oldest_value_addr (locI, INDEX_REG_CLASS, mode,\n \t\t\t\t\t        insn, vd);\n \tif (locB)\n-\t  changed |= replace_oldest_value_addr (locB, BASE_REG_CLASS, mode,\n-\t\t\t\t\t        insn, vd);\n+\t  changed |= replace_oldest_value_addr (locB,\n+\t\t\t\t\t\tMODE_BASE_REG_CLASS (mode),\n+\t\t\t\t\t\tmode, insn, vd);\n \treturn changed;\n       }\n \n@@ -1422,7 +1425,8 @@ replace_oldest_value_mem (x, insn, vd)\n      rtx insn;\n      struct value_data *vd;\n {\n-  return replace_oldest_value_addr (&XEXP (x, 0), BASE_REG_CLASS,\n+  return replace_oldest_value_addr (&XEXP (x, 0),\n+\t\t\t\t    MODE_BASE_REG_CLASS (GET_MODE (x)),\n \t\t\t\t    GET_MODE (x), insn, vd);\n }\n "}, {"sha": "579cb1b9f70cad328e3283b8b3ac8aa21013d12a", "filename": "gcc/reload.c", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5", "patch": "@@ -3029,7 +3029,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      case 'p':\n \t\t/* All necessary reloads for an address_operand\n \t\t   were handled in find_reloads_address.  */\n-\t\tthis_alternative[i] = (int) BASE_REG_CLASS;\n+\t\tthis_alternative[i] = (int) MODE_BASE_REG_CLASS (VOIDmode);\n \t\twin = 1;\n \t\tbreak;\n \n@@ -3686,7 +3686,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    operand_reloadnum[i]\n \t      = push_reload (XEXP (recog_data.operand[i], 0), NULL_RTX,\n \t\t\t     &XEXP (recog_data.operand[i], 0), (rtx*)0,\n-\t\t\t     BASE_REG_CLASS,\n+\t\t\t     MODE_BASE_REG_CLASS (VOIDmode),\n \t\t\t     GET_MODE (XEXP (recog_data.operand[i], 0)),\n \t\t\t     VOIDmode, 0, 0, i, RELOAD_FOR_INPUT);\n \t    rld[operand_reloadnum[i]].inc\n@@ -4617,7 +4617,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \treturn 0;\n \n       /* If we do not have one of the cases above, we must do the reload.  */\n-      push_reload (ad, NULL_RTX, loc, (rtx*)0, BASE_REG_CLASS,\n+      push_reload (ad, NULL_RTX, loc, (rtx*)0, MODE_BASE_REG_CLASS (mode),\n \t\t   GET_MODE (ad), VOIDmode, 0, 0, opnum, type);\n       return 1;\n     }\n@@ -4718,7 +4718,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t  /* Must use TEM here, not AD, since it is the one that will\n \t     have any subexpressions reloaded, if needed.  */\n \t  push_reload (tem, NULL_RTX, loc, (rtx*)0,\n-\t\t       BASE_REG_CLASS, GET_MODE (tem),\n+\t\t       MODE_BASE_REG_CLASS (mode), GET_MODE (tem),\n \t\t       VOIDmode, 0,\n \t\t       0, opnum, type);\n \t  return ! removed_and;\n@@ -4764,7 +4764,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t  /* If the sum of two regs is not necessarily valid,\n \t     reload the sum into a base reg.\n \t     That will at least work.  */\n-\t  find_reloads_address_part (ad, loc, BASE_REG_CLASS,\n+\t  find_reloads_address_part (ad, loc, MODE_BASE_REG_CLASS (mode),\n \t\t\t\t     Pmode, opnum, type, ind_levels);\n \t}\n       return ! removed_and;\n@@ -4807,7 +4807,8 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t\t\t\tplus_constant (XEXP (XEXP (ad, 0), 0),\n \t\t\t\t\t       INTVAL (XEXP (ad, 1))),\n \t\t\t\tXEXP (XEXP (ad, 0), 1));\n-      find_reloads_address_part (XEXP (ad, 0), &XEXP (ad, 0), BASE_REG_CLASS,\n+      find_reloads_address_part (XEXP (ad, 0), &XEXP (ad, 0),\n+\t\t\t\t MODE_BASE_REG_CLASS (mode),\n \t\t\t\t GET_MODE (ad), opnum, type, ind_levels);\n       find_reloads_address_1 (mode, XEXP (ad, 1), 1, &XEXP (ad, 1), opnum,\n \t\t\t      type, 0, insn);\n@@ -4831,7 +4832,8 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t\t\t\tXEXP (XEXP (ad, 0), 0),\n \t\t\t\tplus_constant (XEXP (XEXP (ad, 0), 1),\n \t\t\t\t\t       INTVAL (XEXP (ad, 1))));\n-      find_reloads_address_part (XEXP (ad, 1), &XEXP (ad, 1), BASE_REG_CLASS,\n+      find_reloads_address_part (XEXP (ad, 1), &XEXP (ad, 1),\n+\t\t\t\t MODE_BASE_REG_CLASS (mode),\n \t\t\t\t GET_MODE (ad), opnum, type, ind_levels);\n       find_reloads_address_1 (mode, XEXP (ad, 0), 1, &XEXP (ad, 0), opnum,\n \t\t\t      type, 0, insn);\n@@ -4877,8 +4879,8 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t    loc = &XEXP (*loc, 0);\n \t}\n \n-      find_reloads_address_part (ad, loc, BASE_REG_CLASS, Pmode, opnum, type,\n-\t\t\t\t ind_levels);\n+      find_reloads_address_part (ad, loc, MODE_BASE_REG_CLASS (mode),\n+\t\t\t\t Pmode, opnum, type, ind_levels);\n       return ! removed_and;\n     }\n \n@@ -5303,7 +5305,8 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t    /* Then reload the memory location into a base\n \t\t       register.  */\n \t\t    reloadnum = push_reload (tem, tem, &XEXP (x, 0),\n-\t\t\t\t\t     &XEXP (op1, 0), BASE_REG_CLASS,\n+\t\t\t\t\t     &XEXP (op1, 0),\n+\t\t\t\t\t     MODE_BASE_REG_CLASS (mode),\n \t\t\t\t\t     GET_MODE (x), GET_MODE (x), 0,\n \t\t\t\t\t     0, opnum, RELOAD_OTHER);\n \n@@ -5320,7 +5323,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t      {\n \t\treloadnum = push_reload (XEXP (op1, 0), XEXP (x, 0),\n \t\t\t\t\t &XEXP (op1, 0), &XEXP (x, 0),\n-\t\t\t\t\t BASE_REG_CLASS,\n+\t\t\t\t\t MODE_BASE_REG_CLASS (mode),\n \t\t\t\t\t GET_MODE (x), GET_MODE (x), 0, 0,\n \t\t\t\t\t opnum, RELOAD_OTHER);\n \n@@ -5421,15 +5424,17 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t  x = XEXP (x, 0);\n \t\t  reloadnum\n \t\t    = push_reload (x, x, loc, loc,\n-\t\t\t\t   (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n+\t\t\t\t   (context ? INDEX_REG_CLASS :\n+\t\t\t\t    MODE_BASE_REG_CLASS (mode)),\n \t\t\t\t   GET_MODE (x), GET_MODE (x), 0, 0,\n \t\t\t\t   opnum, RELOAD_OTHER);\n \t\t}\n \t      else\n \t\t{\n \t\t  reloadnum\n \t\t    = push_reload (x, NULL_RTX, loc, (rtx*)0,\n-\t\t\t\t   (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n+\t\t\t\t   (context ? INDEX_REG_CLASS :\n+\t\t\t\t    MODE_BASE_REG_CLASS (mode)),\n \t\t\t\t   GET_MODE (x), GET_MODE (x), 0, 0,\n \t\t\t\t   opnum, type);\n \t\t  rld[reloadnum].inc\n@@ -5469,7 +5474,8 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t\t\topnum, type, ind_levels, insn);\n \n \t  reloadnum = push_reload (x, NULL_RTX, loc, (rtx*)0,\n-\t\t\t\t   (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n+\t\t\t\t   (context ? INDEX_REG_CLASS :\n+\t\t\t\t    MODE_BASE_REG_CLASS (mode)),\n \t\t\t\t   GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t  rld[reloadnum].inc\n \t    = find_inc_amount (PATTERN (this_insn), XEXP (x, 0));\n@@ -5498,7 +5504,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n       find_reloads_address (GET_MODE (x), loc, XEXP (x, 0), &XEXP (x, 0),\n \t\t\t    opnum, ADDR_TYPE (type), ind_levels, insn);\n       push_reload (*loc, NULL_RTX, loc, (rtx*)0,\n-\t\t   (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n+\t\t   (context ? INDEX_REG_CLASS : MODE_BASE_REG_CLASS (mode)),\n \t\t   GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n       return 1;\n \n@@ -5509,7 +5515,8 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \tif (reg_equiv_constant[regno] != 0)\n \t  {\n \t    find_reloads_address_part (reg_equiv_constant[regno], loc,\n-\t\t\t\t       (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n+\t\t\t\t       (context ? INDEX_REG_CLASS :\n+\t\t\t\t\tMODE_BASE_REG_CLASS (mode)),\n \t\t\t\t       GET_MODE (x), opnum, type, ind_levels);\n \t    return 1;\n \t  }\n@@ -5519,7 +5526,8 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \tif (reg_equiv_mem[regno] != 0)\n \t  {\n \t    push_reload (reg_equiv_mem[regno], NULL_RTX, loc, (rtx*)0,\n-\t\t\t (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n+\t\t\t (context ? INDEX_REG_CLASS :\n+\t\t\t  MODE_BASE_REG_CLASS (mode)),\n \t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t    return 1;\n \t  }\n@@ -5547,7 +5555,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t  : REGNO_MODE_OK_FOR_BASE_P (regno, mode))))\n \t  {\n \t    push_reload (x, NULL_RTX, loc, (rtx*)0,\n-\t\t\t (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n+\t\t\t (context ? INDEX_REG_CLASS : MODE_BASE_REG_CLASS (mode)),\n \t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t    return 1;\n \t  }\n@@ -5559,7 +5567,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \tif (regno_clobbered_p (regno, this_insn, GET_MODE (x), 0))\n \t  {\n \t    push_reload (x, NULL_RTX, loc, (rtx*)0,\n-\t\t\t (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n+\t\t\t (context ? INDEX_REG_CLASS : MODE_BASE_REG_CLASS (mode)),\n \t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t    return 1;\n \t  }\n@@ -5580,7 +5588,8 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t     : REGNO_MODE_OK_FOR_BASE_P (regno, mode)))\n \t\t{\n \t\t  push_reload (x, NULL_RTX, loc, (rtx*)0,\n-\t\t\t       (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n+\t\t\t       (context ? INDEX_REG_CLASS :\n+\t\t\t\tMODE_BASE_REG_CLASS (mode)),\n \t\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t\t  return 1;\n \t\t}\n@@ -5590,7 +5599,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t  else\n \t    {\n \t      enum reg_class class = (context ? INDEX_REG_CLASS\n-\t\t\t\t      : BASE_REG_CLASS);\n+\t\t\t\t      : MODE_BASE_REG_CLASS (mode));\n \t      if (CLASS_MAX_NREGS (class, GET_MODE (SUBREG_REG (x)))\n \t\t  > reg_class_size[class])\n \t\t{"}, {"sha": "0f41718efe4195671e19f400ab2cbca678985250", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=3dcc68a44a005cd6d2802fed3c62e5a3f897a1c5", "patch": "@@ -1363,7 +1363,8 @@ maybe_fix_stack_asms ()\n \t\t  break;\n \n \t\tcase 'p':\n-\t\t  cls = (int) reg_class_subunion[cls][(int) BASE_REG_CLASS];\n+\t\t  cls = (int) reg_class_subunion[cls]\n+\t\t    [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n \t\t  break;\n \n \t\tcase 'g':"}]}