{"sha": "8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMxOGExNjVlMmViYjgyMTIxYTBjYWUxNWU1MGMwYWM3NGJkMzNjMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-04T13:45:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-04T13:45:01Z"}, "message": "[multiple changes]\n\n2011-11-04  Yannick Moy  <moy@adacore.com>\n\n\t* atree.adb, atree.ads (Set_Original_Node): New set procedure.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications/Pre_Post_Aspects):\n\tIn ASIS mode, no splitting of aspects between conjuncts.\n\t(Analyze_Aspect_Specifications/Aspect_Test_Case): Make pragma\n\texpressions refer to the original aspect expressions through\n\tthe Original_Node link. This is used in semantic analysis for\n\tASIS mode, so that the original expression also gets analyzed.\n\t* sem_prag.adb (Preanalyze_TC_Args,\n\tCheck_Precondition_Postcondition,\n\tAnalyze_Pragma/Pragma_Test_Case): In ASIS mode, for a pragma\n\tgenerated from a source aspect, also analyze the original aspect\n\texpression.\n\t(Check_Expr_Is_Static_Expression): New procedure\n\tsimilar to existing procedure Check_Arg_Is_Static_Expression,\n\texcept called on expression inside pragma.\n\n2011-11-04  Tristan Gingold  <gingold@adacore.com>\n\n\t* prj-env.adb, prj-env.ads (Find_Name_In_Path): New function, from\n\tFind_Project.Try_Path_Name.\n\t(Find_Project): Use Find_Name_In_Path to implement Try_Path_Name.\n\n2011-11-04  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* s-atocou.ads (Atomic_Counter): Remove redundant pragma Volatile.\n\n2011-11-04  Pascal Obry  <obry@adacore.com>\n\n\t* projects.texi: Add short description for qualifiers aggregate\n\tand aggregate library.\n\n2011-11-04  Matthew Heaney  <heaney@adacore.com>\n\n\t* Makefile.rtl, impunit.adb: Added a-cogeso.ad[sb]\n\t* a-cgaaso.adb: Replaced implementation with instantiation\n\tof Generic_Sort.\n\t* a-cogeso.ad[sb] This is the new Ada 2012 unit\n\tAda.Containers.Generic_Sort\n\nFrom-SVN: r180948", "tree": {"sha": "1ed84f104093c2e1fdc9849a02ea2ea880616996", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ed84f104093c2e1fdc9849a02ea2ea880616996"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/comments", "author": null, "committer": null, "parents": [{"sha": "872b942a5b8626fbfa1c9692e0e9fb5a590cf333", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/872b942a5b8626fbfa1c9692e0e9fb5a590cf333", "html_url": "https://github.com/Rust-GCC/gccrs/commit/872b942a5b8626fbfa1c9692e0e9fb5a590cf333"}], "stats": {"total": 700, "additions": 470, "deletions": 230}, "files": [{"sha": "9041f3d27256f13a4358f9c280382d936b3eb95c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "patch": "@@ -1,3 +1,44 @@\n+2011-11-04  Yannick Moy  <moy@adacore.com>\n+\n+\t* atree.adb, atree.ads (Set_Original_Node): New set procedure.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications/Pre_Post_Aspects):\n+\tIn ASIS mode, no splitting of aspects between conjuncts.\n+\t(Analyze_Aspect_Specifications/Aspect_Test_Case): Make pragma\n+\texpressions refer to the original aspect expressions through\n+\tthe Original_Node link. This is used in semantic analysis for\n+\tASIS mode, so that the original expression also gets analyzed.\n+\t* sem_prag.adb (Preanalyze_TC_Args,\n+\tCheck_Precondition_Postcondition,\n+\tAnalyze_Pragma/Pragma_Test_Case): In ASIS mode, for a pragma\n+\tgenerated from a source aspect, also analyze the original aspect\n+\texpression.\n+\t(Check_Expr_Is_Static_Expression): New procedure\n+\tsimilar to existing procedure Check_Arg_Is_Static_Expression,\n+\texcept called on expression inside pragma.\n+\n+2011-11-04  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* prj-env.adb, prj-env.ads (Find_Name_In_Path): New function, from\n+\tFind_Project.Try_Path_Name.\n+\t(Find_Project): Use Find_Name_In_Path to implement Try_Path_Name.\n+\n+2011-11-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* s-atocou.ads (Atomic_Counter): Remove redundant pragma Volatile.\n+\n+2011-11-04  Pascal Obry  <obry@adacore.com>\n+\n+\t* projects.texi: Add short description for qualifiers aggregate\n+\tand aggregate library.\n+\n+2011-11-04  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* Makefile.rtl, impunit.adb: Added a-cogeso.ad[sb]\n+\t* a-cgaaso.adb: Replaced implementation with instantiation\n+\tof Generic_Sort.\n+\t* a-cogeso.ad[sb] This is the new Ada 2012 unit\n+\tAda.Containers.Generic_Sort\n+\n 2011-11-04  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch2.adb (Expand_Entity_Reference): Do not set"}, {"sha": "50e8a96a3d3d84f1a0fb506661f4496b14d298e1", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "patch": "@@ -122,6 +122,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-ciormu$(objext) \\\n   a-ciorse$(objext) \\\n   a-clrefi$(objext) \\\n+  a-cogeso$(objext) \\\n   a-cohama$(objext) \\\n   a-cohase$(objext) \\\n   a-cohata$(objext) \\"}, {"sha": "12763f12a6759d70131b954fc3bee4fcbfbc8906", "filename": "gcc/ada/a-cgaaso.adb", "status": "modified", "additions": 11, "deletions": 93, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fa-cgaaso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fa-cgaaso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cgaaso.adb?ref=8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,103 +27,21 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n---  This algorithm was adapted from GNAT.Heap_Sort (see g-heasor.ad[sb])\n+--  This unit was originally a GNAT-specific addition to Ada 2005. A unit\n+--  providing the same feature, Ada.Containers.Generic_Sort, was defined for\n+--  Ada 2012.  We retain Generic_Anonymous_Array_Sort for compatibility, but\n+--  implement it in terms of the official unit, Generic_Sort.\n \n-with System;\n+with Ada.Containers.Generic_Sort;\n \n procedure Ada.Containers.Generic_Anonymous_Array_Sort\n   (First, Last : Index_Type'Base)\n is\n-   type T is range System.Min_Int .. System.Max_Int;\n-\n-   function To_Index (J : T) return Index_Type;\n-   pragma Inline (To_Index);\n-\n-   function Lt (J, K : T) return Boolean;\n-   pragma Inline (Lt);\n-\n-   procedure Xchg (J, K : T);\n-   pragma Inline (Xchg);\n-\n-   procedure Sift (S : T);\n-\n-   --------------\n-   -- To_Index --\n-   --------------\n-\n-   function To_Index (J : T) return Index_Type is\n-      K : constant T'Base := Index_Type'Pos (First) + J - T'(1);\n-   begin\n-      return Index_Type'Val (K);\n-   end To_Index;\n-\n-   --------\n-   -- Lt --\n-   --------\n-\n-   function Lt (J, K : T) return Boolean is\n-   begin\n-      return Less (To_Index (J), To_Index (K));\n-   end Lt;\n-\n-   ----------\n-   -- Xchg --\n-   ----------\n-\n-   procedure Xchg (J, K : T) is\n-   begin\n-      Swap (To_Index (J), To_Index (K));\n-   end Xchg;\n-\n-   Max : T := Index_Type'Pos (Last) - Index_Type'Pos (First) + T'(1);\n-\n-   ----------\n-   -- Sift --\n-   ----------\n-\n-   procedure Sift (S : T) is\n-      C      : T := S;\n-      Son    : T;\n-      Father : T;\n-\n-   begin\n-      loop\n-         Son := C + C;\n-\n-         if Son < Max then\n-            if Lt (Son, Son + 1) then\n-               Son := Son + 1;\n-            end if;\n-         elsif Son > Max then\n-            exit;\n-         end if;\n-\n-         Xchg (Son, C);\n-         C := Son;\n-      end loop;\n-\n-      while C /= S loop\n-         Father := C / 2;\n-\n-         if Lt (Father, C) then\n-            Xchg (Father, C);\n-            C := Father;\n-         else\n-            exit;\n-         end if;\n-      end loop;\n-   end Sift;\n-\n---  Start of processing for Generic_Anonymous_Array_Sort\n+   procedure Sort is new Ada.Containers.Generic_Sort\n+     (Index_Type => Index_Type,\n+      Before     => Less,\n+      Swap       => Swap);\n \n begin\n-   for J in reverse 1 .. Max / 2 loop\n-      Sift (J);\n-   end loop;\n-\n-   while Max > 1 loop\n-      Xchg (1, Max);\n-      Max := Max - 1;\n-      Sift (1);\n-   end loop;\n+   Sort (First, Last);\n end Ada.Containers.Generic_Anonymous_Array_Sort;"}, {"sha": "fc2198cb4b1938d56b3dc544f89532ee02b248e3", "filename": "gcc/ada/a-cogeso.adb", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fa-cogeso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fa-cogeso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cogeso.adb?ref=8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "patch": "@@ -0,0 +1,127 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                       ADA.CONTAINERS.GENERIC_SORT                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+--  This algorithm was adapted from GNAT.Heap_Sort (see g-heasor.ad[sb])\n+\n+with System;\n+\n+procedure Ada.Containers.Generic_Sort (First, Last : Index_Type'Base) is\n+   type T is range System.Min_Int .. System.Max_Int;\n+\n+   function To_Index (J : T) return Index_Type;\n+   pragma Inline (To_Index);\n+\n+   function Lt (J, K : T) return Boolean;\n+   pragma Inline (Lt);\n+\n+   procedure Xchg (J, K : T);\n+   pragma Inline (Xchg);\n+\n+   procedure Sift (S : T);\n+\n+   --------------\n+   -- To_Index --\n+   --------------\n+\n+   function To_Index (J : T) return Index_Type is\n+      K : constant T'Base := Index_Type'Pos (First) + J - T'(1);\n+   begin\n+      return Index_Type'Val (K);\n+   end To_Index;\n+\n+   --------\n+   -- Lt --\n+   --------\n+\n+   function Lt (J, K : T) return Boolean is\n+   begin\n+      return Before (To_Index (J), To_Index (K));\n+   end Lt;\n+\n+   ----------\n+   -- Xchg --\n+   ----------\n+\n+   procedure Xchg (J, K : T) is\n+   begin\n+      Swap (To_Index (J), To_Index (K));\n+   end Xchg;\n+\n+   Max : T := Index_Type'Pos (Last) - Index_Type'Pos (First) + T'(1);\n+\n+   ----------\n+   -- Sift --\n+   ----------\n+\n+   procedure Sift (S : T) is\n+      C      : T := S;\n+      Son    : T;\n+      Father : T;\n+\n+   begin\n+      loop\n+         Son := C + C;\n+\n+         if Son < Max then\n+            if Lt (Son, Son + 1) then\n+               Son := Son + 1;\n+            end if;\n+         elsif Son > Max then\n+            exit;\n+         end if;\n+\n+         Xchg (Son, C);\n+         C := Son;\n+      end loop;\n+\n+      while C /= S loop\n+         Father := C / 2;\n+\n+         if Lt (Father, C) then\n+            Xchg (Father, C);\n+            C := Father;\n+         else\n+            exit;\n+         end if;\n+      end loop;\n+   end Sift;\n+\n+--  Start of processing for Generic_Sort\n+\n+begin\n+   for J in reverse 1 .. Max / 2 loop\n+      Sift (J);\n+   end loop;\n+\n+   while Max > 1 loop\n+      Xchg (1, Max);\n+      Max := Max - 1;\n+      Sift (1);\n+   end loop;\n+end Ada.Containers.Generic_Sort;"}, {"sha": "ebf805ab79f4ffca8a4678b37c665b1a9c783957", "filename": "gcc/ada/a-cogeso.ads", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fa-cogeso.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fa-cogeso.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cogeso.ads?ref=8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "patch": "@@ -0,0 +1,40 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                       ADA.CONTAINERS.GENERIC_SORT                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+--  Allows an anonymous array (or array-like container) to be sorted. Generic\n+--  formal Before returns the result of comparing the elements designated by\n+--  the indexes, and generic formal Swap exchanges the designated elements.\n+\n+generic\n+   type Index_Type is (<>);\n+   with function Before (Left, Right : Index_Type) return Boolean;\n+   with procedure Swap (Left, Right : Index_Type);\n+\n+procedure Ada.Containers.Generic_Sort (First, Last : Index_Type'Base);\n+pragma Pure (Ada.Containers.Generic_Sort);"}, {"sha": "793da138861731d88c05e341eb7784a7b9808596", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "patch": "@@ -1797,6 +1797,15 @@ package body Atree is\n       Nodes.Table (N).Has_Aspects := Val;\n    end Set_Has_Aspects;\n \n+   -----------------------\n+   -- Set_Original_Node --\n+   -----------------------\n+\n+   procedure Set_Original_Node (N : Node_Id; Val : Node_Id) is\n+   begin\n+      Orig_Nodes.Table (N) := Val;\n+   end Set_Original_Node;\n+\n    ---------------------\n    -- Set_Paren_Count --\n    ---------------------"}, {"sha": "b5bbff4d7434046bc16a7ecdd5638af298633ab4", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "patch": "@@ -761,6 +761,9 @@ package Atree is\n    procedure Set_Has_Aspects (N : Node_Id; Val : Boolean := True);\n    pragma Inline (Set_Has_Aspects);\n \n+   procedure Set_Original_Node (N : Node_Id; Val : Node_Id);\n+   pragma Inline (Set_Original_Node);\n+\n    ------------------------------\n    -- Entity Update Procedures --\n    ------------------------------"}, {"sha": "63ab92569536fa4359eddd00ca75bef1fe1a1a8d", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "patch": "@@ -494,6 +494,7 @@ package body Impunit is\n       --  Note: strictly the following should be Ada 2012 units, but it seems\n       --  harmless (and useful) to make then available in Ada 2005 mode.\n \n+    (\"a-cogeso\", T),  -- Ada.Containers.Generic_Sort\n     (\"a-secain\", T),  -- Ada.Strings.Equal_Case_Insensitive\n     (\"a-shcain\", T),  -- Ada.Strings.Hash_Case_Insensitive\n     (\"a-slcain\", T),  -- Ada.Strings.Less_Case_Insensitive"}, {"sha": "2e6fe4a255c3cc1bf7067fef2466c1792c127102", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 79, "deletions": 75, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "patch": "@@ -2058,6 +2058,75 @@ package body Prj.Env is\n       Projects_Paths.Reset (Self.Cache);\n    end Set_Path;\n \n+   -----------------------\n+   -- Find_Name_In_Path --\n+   -----------------------\n+\n+   function Find_Name_In_Path (Self : Project_Search_Path;\n+                               Path : String) return String_Access is\n+      First  : Natural;\n+      Last   : Natural;\n+\n+   begin\n+      if Current_Verbosity = High then\n+         Debug_Output (\"Trying \" & Path);\n+      end if;\n+\n+      if Is_Absolute_Path (Path) then\n+         if Check_Filename (Path) then\n+            return new String'(Path);\n+         else\n+            return null;\n+         end if;\n+\n+      else\n+         --  Because we don't want to resolve symbolic links, we cannot use\n+         --  Locate_Regular_File. So, we try each possible path\n+         --  successively.\n+\n+         First := Self.Path'First;\n+         while First <= Self.Path'Last loop\n+            while First <= Self.Path'Last\n+              and then Self.Path (First) = Path_Separator\n+            loop\n+               First := First + 1;\n+            end loop;\n+\n+            exit when First > Self.Path'Last;\n+\n+            Last := First;\n+            while Last < Self.Path'Last\n+              and then Self.Path (Last + 1) /= Path_Separator\n+            loop\n+               Last := Last + 1;\n+            end loop;\n+\n+            Name_Len := 0;\n+\n+            if not Is_Absolute_Path (Self.Path (First .. Last)) then\n+               Add_Str_To_Name_Buffer (Get_Current_Dir);  -- ??? System call\n+               Add_Char_To_Name_Buffer (Directory_Separator);\n+            end if;\n+\n+            Add_Str_To_Name_Buffer (Self.Path (First .. Last));\n+            Add_Char_To_Name_Buffer (Directory_Separator);\n+            Add_Str_To_Name_Buffer (Path);\n+\n+            if Current_Verbosity = High then\n+               Debug_Output (\"Testing file \" & Name_Buffer (1 .. Name_Len));\n+            end if;\n+\n+            if Check_Filename (Name_Buffer (1 .. Name_Len)) then\n+               return new String'(Name_Buffer (1 .. Name_Len));\n+            end if;\n+\n+            First := Last + 1;\n+         end loop;\n+      end if;\n+\n+      return null;\n+   end Find_Name_In_Path;\n+\n    ------------------\n    -- Find_Project --\n    ------------------\n@@ -2072,77 +2141,9 @@ package body Prj.Env is\n       --  Have to do a copy, in case the parameter is Name_Buffer, which we\n       --  modify below\n \n-      function Try_Path_Name (Path : String) return String_Access;\n-      pragma Inline (Try_Path_Name);\n-      --  Try the specified Path\n-\n-      -------------------\n-      -- Try_Path_Name --\n-      -------------------\n-\n-      function Try_Path_Name (Path : String) return String_Access is\n-         First  : Natural;\n-         Last   : Natural;\n-         Result : String_Access := null;\n-\n-      begin\n-         if Current_Verbosity = High then\n-            Debug_Output (\"Trying \" & Path);\n-         end if;\n-\n-         if Is_Absolute_Path (Path) then\n-            if Is_Regular_File (Path) then\n-               Result := new String'(Path);\n-            end if;\n-\n-         else\n-            --  Because we don't want to resolve symbolic links, we cannot use\n-            --  Locate_Regular_File. So, we try each possible path\n-            --  successively.\n-\n-            First := Self.Path'First;\n-            while First <= Self.Path'Last loop\n-               while First <= Self.Path'Last\n-                 and then Self.Path (First) = Path_Separator\n-               loop\n-                  First := First + 1;\n-               end loop;\n-\n-               exit when First > Self.Path'Last;\n-\n-               Last := First;\n-               while Last < Self.Path'Last\n-                 and then Self.Path (Last + 1) /= Path_Separator\n-               loop\n-                  Last := Last + 1;\n-               end loop;\n-\n-               Name_Len := 0;\n-\n-               if not Is_Absolute_Path (Self.Path (First .. Last)) then\n-                  Add_Str_To_Name_Buffer (Get_Current_Dir);  -- ??? System call\n-                  Add_Char_To_Name_Buffer (Directory_Separator);\n-               end if;\n-\n-               Add_Str_To_Name_Buffer (Self.Path (First .. Last));\n-               Add_Char_To_Name_Buffer (Directory_Separator);\n-               Add_Str_To_Name_Buffer (Path);\n-\n-               if Current_Verbosity = High then\n-                  Debug_Output (\"Testing file \" & Name_Buffer (1 .. Name_Len));\n-               end if;\n-\n-               if Is_Regular_File (Name_Buffer (1 .. Name_Len)) then\n-                  Result := new String'(Name_Buffer (1 .. Name_Len));\n-                  exit;\n-               end if;\n-\n-               First := Last + 1;\n-            end loop;\n-         end if;\n-\n-         return Result;\n-      end Try_Path_Name;\n+      function Try_Path_Name is new Find_Name_In_Path\n+        (Check_Filename => Is_Regular_File);\n+      --  Find a file in the project search path.\n \n       --  Local Declarations\n \n@@ -2194,27 +2195,30 @@ package body Prj.Env is\n \n          if not Has_Dot then\n             Result := Try_Path_Name\n-              (Directory & Directory_Separator &\n+              (Self,\n+               Directory & Directory_Separator &\n                File & Project_File_Extension);\n          end if;\n \n          --  Then we try <directory>/<file_name>\n \n          if Result = null then\n-            Result := Try_Path_Name (Directory & Directory_Separator & File);\n+            Result := Try_Path_Name\n+              (Self,\n+               Directory & Directory_Separator & File);\n          end if;\n       end if;\n \n       --  Then we try <file_name>.<extension>\n \n       if Result = null and then not Has_Dot then\n-         Result := Try_Path_Name (File & Project_File_Extension);\n+         Result := Try_Path_Name (Self, File & Project_File_Extension);\n       end if;\n \n       --  Then we try <file_name>\n \n       if Result = null then\n-         Result := Try_Path_Name (File);\n+         Result := Try_Path_Name (Self, File);\n       end if;\n \n       --  If we cannot find the project file, we return an empty string"}, {"sha": "fd19a061a0f7f266b7ca995b8f190dd6a98cb9fd", "filename": "gcc/ada/prj-env.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "patch": "@@ -210,6 +210,16 @@ package Prj.Env is\n    --  Override the value of the project path. This also removes the implicit\n    --  default search directories.\n \n+   generic\n+      with function Check_Filename (Name : String) return Boolean;\n+   function Find_Name_In_Path (Self : Project_Search_Path;\n+                               Path : String) return String_Access;\n+   --  Find a name in the project search path of Self. Check_Filename is\n+   --  the predicate to valid the search.  If Path is an absolute filename,\n+   --  simply calls the predicate with Path. Otherwise, calls the predicate\n+   --  for each component of the path. Stops as soon as the predicate\n+   --  returns True and returns the name, or returns null in case of failure.\n+\n    procedure Find_Project\n      (Self               : in out Project_Search_Path;\n       Project_File_Name  : String;"}, {"sha": "6970733bdaf600a471ed8442bf1c8a6b0a2c5299", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "patch": "@@ -2915,8 +2915,10 @@ The current list of qualifiers is:\n   qualified abstract project.\n @item @b{standard}: a standard project is a non library project with sources.\n   This is the default (implicit) qualifier.\n-@item @b{aggregate}: for future extension\n-@item @b{aggregate library}: for future extension\n+@item @b{aggregate}: a project whose sources are aggregated from other\n+project files.\n+@item @b{aggregate library}: a library whose sources are aggregated\n+from other project or library project files.\n @item @b{library}: a library project must declare both attributes\n   @code{Library_Name} and @code{Library_Dir}.\n @item @b{configuration}: a configuration project cannot be in a project tree."}, {"sha": "cad18d29896e883232a0c1648c88f34a702cdbf1", "filename": "gcc/ada/s-atocou.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fs-atocou.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fs-atocou.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-atocou.ads?ref=8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "patch": "@@ -72,7 +72,6 @@ private\n    type Atomic_Counter is limited record\n       Value : aliased Unsigned_32 := 1;\n       pragma Atomic (Value);\n-      pragma Volatile (Value);\n    end record;\n \n end System.Atomic_Counters;"}, {"sha": "acfb989dc3ce9d64850e636d52e88b12b4d18afc", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "patch": "@@ -1231,8 +1231,13 @@ package body Sem_Ch13 is\n                   --  We do not do this for Pre'Class, since we have to put\n                   --  these conditions together in a complex OR expression\n \n-                  if Pname = Name_Postcondition\n-                    or else not Class_Present (Aspect)\n+                  --  We do not do this in ASIS mode, as ASIS relies on the\n+                  --  original node representing the complete expression, when\n+                  --  retrieving it through the source aspect table.\n+\n+                  if not ASIS_Mode\n+                    and then (Pname = Name_Postcondition\n+                               or else not Class_Present (Aspect))\n                   then\n                      while Nkind (Expr) = N_And_Then loop\n                         Insert_After (Aspect,\n@@ -1385,6 +1390,7 @@ package body Sem_Ch13 is\n                   Args      : List_Id;\n                   Comp_Expr : Node_Id;\n                   Comp_Assn : Node_Id;\n+                  New_Expr  : Node_Id;\n \n                begin\n                   Args := New_List;\n@@ -1401,11 +1407,18 @@ package body Sem_Ch13 is\n                      goto Continue;\n                   end if;\n \n+                  --  Make pragma expressions refer to the original aspect\n+                  --  expressions through the Original_Node link. This is used\n+                  --  in semantic analysis for ASIS mode, so that the original\n+                  --  expression also gets analyzed.\n+\n                   Comp_Expr := First (Expressions (Expr));\n                   while Present (Comp_Expr) loop\n+                     New_Expr := Relocate_Node (Comp_Expr);\n+                     Set_Original_Node (New_Expr, Comp_Expr);\n                      Append\n                        (Make_Pragma_Argument_Association (Sloc (Comp_Expr),\n-                          Expression => Relocate_Node (Comp_Expr)),\n+                          Expression => New_Expr),\n                        Args);\n                      Next (Comp_Expr);\n                   end loop;\n@@ -1421,10 +1434,12 @@ package body Sem_Ch13 is\n                         goto Continue;\n                      end if;\n \n+                     New_Expr := Relocate_Node (Expression (Comp_Assn));\n+                     Set_Original_Node (New_Expr, Expression (Comp_Assn));\n                      Append (Make_Pragma_Argument_Association (\n                        Sloc       => Sloc (Comp_Assn),\n                        Chars      => Chars (First (Choices (Comp_Assn))),\n-                       Expression => Relocate_Node (Expression (Comp_Assn))),\n+                       Expression => New_Expr),\n                        Args);\n                      Next (Comp_Assn);\n                   end loop;\n@@ -8732,8 +8747,8 @@ package body Sem_Ch13 is\n             Source : constant Entity_Id  := T.Source;\n             Target : constant Entity_Id  := T.Target;\n \n-            Source_Siz    : Uint;\n-            Target_Siz    : Uint;\n+            Source_Siz : Uint;\n+            Target_Siz : Uint;\n \n          begin\n             --  This validation check, which warns if we have unequal sizes for"}, {"sha": "cf49379588053d3639b4bfdd1f7287443f65a7fb", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 123, "deletions": 53, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c18a165e2ebb82121a0cae15e50c0ac74bd33c3/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=8c18a165e2ebb82121a0cae15e50c0ac74bd33c3", "patch": "@@ -181,7 +181,7 @@ package body Sem_Prag is\n    --  original one, following the renaming chain) is returned. Otherwise the\n    --  entity is returned unchanged. Should be in Einfo???\n \n-   procedure Preanalyze_TC_Args (Arg_Req, Arg_Ens : Node_Id);\n+   procedure Preanalyze_TC_Args (N, Arg_Req, Arg_Ens : Node_Id);\n    --  Preanalyze the boolean expressions in the Requires and Ensures arguments\n    --  of a Test_Case pragma if present (possibly Empty). We treat these as\n    --  spec expressions (i.e. similar to a default expression).\n@@ -260,8 +260,17 @@ package body Sem_Prag is\n       --  Preanalyze the boolean expression, we treat this as a spec expression\n       --  (i.e. similar to a default expression).\n \n-      Preanalyze_Spec_Expression\n-        (Get_Pragma_Arg (Arg1), Standard_Boolean);\n+      Preanalyze_Spec_Expression (Get_Pragma_Arg (Arg1), Standard_Boolean);\n+\n+      --  In ASIS mode, for a pragma generated from a source aspect, also\n+      --  analyze the original aspect expression.\n+\n+      if ASIS_Mode\n+        and then Present (Corresponding_Aspect (N))\n+      then\n+         Preanalyze_Spec_Expression\n+           (Expression (Corresponding_Aspect (N)), Standard_Boolean);\n+      end if;\n \n       --  For a class-wide condition, a reference to a controlling formal must\n       --  be interpreted as having the class-wide type (or an access to such)\n@@ -518,6 +527,15 @@ package body Sem_Prag is\n       --  This procedure checks for possible duplications if this is the export\n       --  case, and if found, issues an appropriate error message.\n \n+      procedure Check_Expr_Is_Static_Expression\n+        (Argx : Node_Id;\n+         Typ  : Entity_Id := Empty);\n+      --  Check the specified expression Argx to make sure that it is a static\n+      --  expression of the given type (i.e. it will be analyzed and resolved\n+      --  using this type, which can be any valid argument to Resolve, e.g.\n+      --  Any_Integer is OK). If not, given error and raise Pragma_Exit. If\n+      --  Typ is left Empty, then any static expression is allowed.\n+\n       procedure Check_First_Subtype (Arg : Node_Id);\n       --  Checks that Arg, whose expression is an entity name, references a\n       --  first subtype.\n@@ -1197,55 +1215,9 @@ package body Sem_Prag is\n \n       procedure Check_Arg_Is_Static_Expression\n         (Arg : Node_Id;\n-         Typ : Entity_Id := Empty)\n-      is\n-         Argx : constant Node_Id := Get_Pragma_Arg (Arg);\n-\n+         Typ : Entity_Id := Empty) is\n       begin\n-         if Present (Typ) then\n-            Analyze_And_Resolve (Argx, Typ);\n-         else\n-            Analyze_And_Resolve (Argx);\n-         end if;\n-\n-         if Is_OK_Static_Expression (Argx) then\n-            return;\n-\n-         elsif Etype (Argx) = Any_Type then\n-            raise Pragma_Exit;\n-\n-         --  An interesting special case, if we have a string literal and we\n-         --  are in Ada 83 mode, then we allow it even though it will not be\n-         --  flagged as static. This allows the use of Ada 95 pragmas like\n-         --  Import in Ada 83 mode. They will of course be flagged with\n-         --  warnings as usual, but will not cause errors.\n-\n-         elsif Ada_Version = Ada_83\n-           and then Nkind (Argx) = N_String_Literal\n-         then\n-            return;\n-\n-         --  Static expression that raises Constraint_Error. This has already\n-         --  been flagged, so just exit from pragma processing.\n-\n-         elsif Is_Static_Expression (Argx) then\n-            raise Pragma_Exit;\n-\n-         --  Finally, we have a real error\n-\n-         else\n-            Error_Msg_Name_1 := Pname;\n-\n-            declare\n-               Msg : String :=\n-                       \"argument for pragma% must be a static expression!\";\n-            begin\n-               Fix_Error (Msg);\n-               Flag_Non_Static_Expr (Msg, Argx);\n-            end;\n-\n-            raise Pragma_Exit;\n-         end if;\n+         Check_Expr_Is_Static_Expression (Get_Pragma_Arg (Arg), Typ);\n       end Check_Arg_Is_Static_Expression;\n \n       ------------------------------------------\n@@ -1478,6 +1450,60 @@ package body Sem_Prag is\n          end if;\n       end Check_Duplicated_Export_Name;\n \n+      -------------------------------------\n+      -- Check_Expr_Is_Static_Expression --\n+      -------------------------------------\n+\n+      procedure Check_Expr_Is_Static_Expression\n+        (Argx : Node_Id;\n+         Typ  : Entity_Id := Empty) is\n+      begin\n+         if Present (Typ) then\n+            Analyze_And_Resolve (Argx, Typ);\n+         else\n+            Analyze_And_Resolve (Argx);\n+         end if;\n+\n+         if Is_OK_Static_Expression (Argx) then\n+            return;\n+\n+         elsif Etype (Argx) = Any_Type then\n+            raise Pragma_Exit;\n+\n+         --  An interesting special case, if we have a string literal and we\n+         --  are in Ada 83 mode, then we allow it even though it will not be\n+         --  flagged as static. This allows the use of Ada 95 pragmas like\n+         --  Import in Ada 83 mode. They will of course be flagged with\n+         --  warnings as usual, but will not cause errors.\n+\n+         elsif Ada_Version = Ada_83\n+           and then Nkind (Argx) = N_String_Literal\n+         then\n+            return;\n+\n+         --  Static expression that raises Constraint_Error. This has already\n+         --  been flagged, so just exit from pragma processing.\n+\n+         elsif Is_Static_Expression (Argx) then\n+            raise Pragma_Exit;\n+\n+         --  Finally, we have a real error\n+\n+         else\n+            Error_Msg_Name_1 := Pname;\n+\n+            declare\n+               Msg : String :=\n+                       \"argument for pragma% must be a static expression!\";\n+            begin\n+               Fix_Error (Msg);\n+               Flag_Non_Static_Expr (Msg, Argx);\n+            end;\n+\n+            raise Pragma_Exit;\n+         end if;\n+      end Check_Expr_Is_Static_Expression;\n+\n       -------------------------\n       -- Check_First_Subtype --\n       -------------------------\n@@ -1980,6 +2006,16 @@ package body Sem_Prag is\n \n                Preanalyze_Spec_Expression\n                  (Get_Pragma_Arg (Arg1), Standard_Boolean);\n+\n+               --  In ASIS mode, for a pragma generated from a source aspect,\n+               --  also analyze the original aspect expression.\n+\n+               if ASIS_Mode\n+                 and then Present (Corresponding_Aspect (N))\n+               then\n+                  Preanalyze_Spec_Expression\n+                    (Expression (Corresponding_Aspect (N)), Standard_Boolean);\n+               end if;\n             end if;\n \n             In_Body := True;\n@@ -13678,6 +13714,17 @@ package body Sem_Prag is\n \n             Check_Optional_Identifier (Arg1, Name_Name);\n             Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n+\n+            --  In ASIS mode, for a pragma generated from a source aspect, also\n+            --  analyze the original aspect expression.\n+\n+            if ASIS_Mode\n+              and then Present (Corresponding_Aspect (N))\n+            then\n+               Check_Expr_Is_Static_Expression\n+                 (Original_Node (Get_Pragma_Arg (Arg1)), Standard_String);\n+            end if;\n+\n             Check_Optional_Identifier (Arg2, Name_Mode);\n             Check_Arg_Is_One_Of (Arg2, Name_Nominal, Name_Robustness);\n \n@@ -14566,7 +14613,8 @@ package body Sem_Prag is\n       --  Preanalyze the boolean expressions, we treat these as spec\n       --  expressions (i.e. similar to a default expression).\n \n-      Preanalyze_TC_Args (Get_Requires_From_Test_Case_Pragma (N),\n+      Preanalyze_TC_Args (N,\n+                          Get_Requires_From_Test_Case_Pragma (N),\n                           Get_Ensures_From_Test_Case_Pragma (N));\n \n       --  Remove the subprogram from the scope stack now that the pre-analysis\n@@ -15086,19 +15134,41 @@ package body Sem_Prag is\n    -- Preanalyze_TC_Args --\n    ------------------------\n \n-   procedure Preanalyze_TC_Args (Arg_Req, Arg_Ens : Node_Id) is\n+   procedure Preanalyze_TC_Args (N, Arg_Req, Arg_Ens : Node_Id) is\n    begin\n       --  Preanalyze the boolean expressions, we treat these as spec\n       --  expressions (i.e. similar to a default expression).\n \n       if Present (Arg_Req) then\n+\n          Preanalyze_Spec_Expression\n            (Get_Pragma_Arg (Arg_Req), Standard_Boolean);\n+\n+         --  In ASIS mode, for a pragma generated from a source aspect, also\n+         --  analyze the original aspect expression.\n+\n+         if ASIS_Mode\n+           and then Present (Corresponding_Aspect (N))\n+         then\n+            Preanalyze_Spec_Expression\n+              (Original_Node (Get_Pragma_Arg (Arg_Req)), Standard_Boolean);\n+         end if;\n       end if;\n \n       if Present (Arg_Ens) then\n+\n          Preanalyze_Spec_Expression\n            (Get_Pragma_Arg (Arg_Ens), Standard_Boolean);\n+\n+         --  In ASIS mode, for a pragma generated from a source aspect, also\n+         --  analyze the original aspect expression.\n+\n+         if ASIS_Mode\n+           and then Present (Corresponding_Aspect (N))\n+         then\n+            Preanalyze_Spec_Expression\n+              (Original_Node (Get_Pragma_Arg (Arg_Ens)), Standard_Boolean);\n+         end if;\n       end if;\n    end Preanalyze_TC_Args;\n "}]}