{"sha": "437a710df01fbb24c920c80ee65803612c2b5ce2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM3YTcxMGRmMDFmYmIyNGM5MjBjODBlZTY1ODAzNjEyYzJiNWNlMg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-10-07T00:13:49Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-07T00:13:49Z"}, "message": "caller-save.c (restore_referenced_regs): Lose mode argument.\n\n\t* caller-save.c (restore_referenced_regs): Lose mode argument.\n\t(insert_save): Lose mode argument.\n\t(insert_restore): Lose mode argument.\n\t(insert_one_insn): Lose mode argument.\n\t(save_call_clobbered_regs): Lose mode argument.\n\t(setup_save_areas): Take no argument and return void.  All callers\n\tchanged.\n\tDon't verify validity of memory addresses.\n\t* reload.h (setup_save_ares): Adjust prototype.\n\t(save_call_clobbered_regs): Likewise.\n\t* reload1.c (delete_caller_save_insns): New function.\n\t(caller_save_spill_class): Delete variable.\n\t(caller_save_group_size): Delete variable.\n\t(reload): Call setup_save_areas and save_call_clobbered_regs\n\tin the main loop, before calling calculate_needs_all_insns.\n\tDon't call save_call_clobbered_regs after the loop.\n\tCall delete_caller_save_insns at the end of an iteration if\n\tsomething changed.\n\tDelete code to manage caller_save_spill_class.\n\tEmit the final note before setting reload_first_uid.\n\tSimplify test that determines whether reload_as_needed gets run.\n\t(calculate_needs): Delete code to manage caller_save_spill_class.\n\nFrom-SVN: r22876", "tree": {"sha": "e5259015e97877779228c9060cf35c3201199c17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5259015e97877779228c9060cf35c3201199c17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/437a710df01fbb24c920c80ee65803612c2b5ce2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/437a710df01fbb24c920c80ee65803612c2b5ce2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/437a710df01fbb24c920c80ee65803612c2b5ce2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/437a710df01fbb24c920c80ee65803612c2b5ce2/comments", "author": null, "committer": null, "parents": [{"sha": "a4c3ddd83ae219749907c77f23787ffe085ed8c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4c3ddd83ae219749907c77f23787ffe085ed8c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4c3ddd83ae219749907c77f23787ffe085ed8c4"}], "stats": {"total": 317, "additions": 122, "deletions": 195}, "files": [{"sha": "826efc80de2886e939653c66b63ae88f403fa8a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437a710df01fbb24c920c80ee65803612c2b5ce2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437a710df01fbb24c920c80ee65803612c2b5ce2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=437a710df01fbb24c920c80ee65803612c2b5ce2", "patch": "@@ -1,3 +1,28 @@\n+Wed Oct  7 01:08:43 1998  Bernd Schmidt <crux@Pool.Informatik.RWTH-Aachen.DE>\n+\n+\t* caller-save.c (restore_referenced_regs): Lose mode argument.\n+\t(insert_save): Lose mode argument.\n+\t(insert_restore): Lose mode argument.\n+\t(insert_one_insn): Lose mode argument.\n+\t(save_call_clobbered_regs): Lose mode argument.\n+\t(setup_save_areas): Take no argument and return void.  All callers\n+\tchanged.\n+\tDon't verify validity of memory addresses.\n+\t* reload.h (setup_save_ares): Adjust prototype.\n+\t(save_call_clobbered_regs): Likewise.\n+\t* reload1.c (delete_caller_save_insns): New function.\n+\t(caller_save_spill_class): Delete variable.\n+\t(caller_save_group_size): Delete variable.\n+\t(reload): Call setup_save_areas and save_call_clobbered_regs\n+\tin the main loop, before calling calculate_needs_all_insns.\n+\tDon't call save_call_clobbered_regs after the loop.\n+\tCall delete_caller_save_insns at the end of an iteration if\n+\tsomething changed.\n+\tDelete code to manage caller_save_spill_class.\n+\tEmit the final note before setting reload_first_uid.\n+\tSimplify test that determines whether reload_as_needed gets run.\n+\t(calculate_needs): Delete code to manage caller_save_spill_class.\n+\n Tue Oct  6 15:42:27 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* collect2.c (main): Initialize ld_file_name."}, {"sha": "03fceaebe65410ea771c959aad9a890941a5e0f9", "filename": "gcc/caller-save.c", "status": "modified", "additions": 30, "deletions": 62, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437a710df01fbb24c920c80ee65803612c2b5ce2/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437a710df01fbb24c920c80ee65803612c2b5ce2/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=437a710df01fbb24c920c80ee65803612c2b5ce2", "patch": "@@ -82,14 +82,11 @@ int n_regs_saved;\n \n static void set_reg_live\t\tPROTO((rtx, rtx));\n static void clear_reg_live\t\tPROTO((rtx));\n-static void restore_referenced_regs\tPROTO((rtx, rtx, enum machine_mode,\n-\t\t\t\t\t       int));\n-static int insert_restore\t\tPROTO((rtx, int, int,\n-\t\t\t\t\t       enum machine_mode, int, int));\n-static int insert_save\t\t\tPROTO((rtx, int, int,\n-\t\t\t\t\t       enum machine_mode, int));\n+static void restore_referenced_regs\tPROTO((rtx, rtx, int));\n+static int insert_restore\t\tPROTO((rtx, int, int, int, int));\n+static int insert_save\t\t\tPROTO((rtx, int, int, int));\n static void insert_one_insn\t\tPROTO((rtx, int, enum rtx_code,\n-\t\t\t\t\t       enum machine_mode, rtx, int));\n+\t\t\t\t\t       rtx, int));\n \f\n /* Initialize for caller-save.\n \n@@ -234,13 +231,6 @@ init_save_areas ()\n    overestimate slightly (especially if some of these registers are later\n    used as spill registers), but it should not be significant.\n \n-   Then perform register elimination in the addresses of the save area\n-   locations; return 1 if all eliminated addresses are strictly valid.\n-   We assume that our caller has set up the elimination table to the\n-   worst (largest) possible offsets.\n-\n-   Set *PCHANGED to 1 if we had to allocate some memory for the save area.  \n-\n    Future work:\n \n      In the fallback case we should iterate backwards across all possible\n@@ -253,14 +243,11 @@ init_save_areas ()\n      machine independent since they might be saving non-consecutive \n      registers. (imagine caller-saving d0,d1,a0,a1 on the 68k) */\n \n-int\n-setup_save_areas (pchanged)\n-     int *pchanged;\n+void\n+setup_save_areas ()\n {\n   int i, j, k;\n   HARD_REG_SET hard_regs_used;\n-  int ok = 1;\n-\n \n   /* Allocate space in the save area for the largest multi-register\n      pseudos first, then work backwards to single register\n@@ -334,28 +321,16 @@ setup_save_areas (pchanged)\n \t\tregno_save_mem[i+k][1] \n \t\t  = adj_offsettable_operand (temp, k * UNITS_PER_WORD);\n \t      }\n-\t    *pchanged = 1;\n \t  }\n       }\n \n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    for (j = 1; j <= MOVE_MAX / UNITS_PER_WORD; j++)\n-      if (regno_save_mem[i][j] != 0)\n-\tok &= strict_memory_address_p (GET_MODE (regno_save_mem[i][j]),\n-\t\t\t\t       XEXP (eliminate_regs (regno_save_mem[i][j], 0, NULL_RTX), 0));\n-\n-  return ok;\n+  return;\n }\n \f\n-/* Find the places where hard regs are live across calls and save them.\n-\n-   INSN_MODE is the mode to assign to any insns that we add.  This is used\n-   by reload to determine whether or not reloads or register eliminations\n-   need be done on these insns.  */\n+/* Find the places where hard regs are live across calls and save them.  */\n \n void\n-save_call_clobbered_regs (insn_mode)\n-     enum machine_mode insn_mode;\n+save_call_clobbered_regs ()\n {\n   rtx insn;\n   int b;\n@@ -403,7 +378,7 @@ save_call_clobbered_regs (insn_mode)\n \t\t any of them.  We must restore them before the insn if so.  */\n \n \t      if (n_regs_saved)\n-\t\trestore_referenced_regs (PATTERN (insn), insn, insn_mode, b);\n+\t\trestore_referenced_regs (PATTERN (insn), insn, b);\n \n \t      /* NB: the normal procedure is to first enliven any\n \t\t registers set by insn, then deaden any registers that\n@@ -453,7 +428,7 @@ save_call_clobbered_regs (insn_mode)\n \t\t\t/* It must not be set by this instruction.  */\n \t\t        && ! TEST_HARD_REG_BIT (this_call_sets, regno)\n \t\t        && ! TEST_HARD_REG_BIT (hard_regs_saved, regno))\n-\t\t      regno += insert_save (insn, 1, regno, insn_mode, b);\n+\t\t      regno += insert_save (insn, 1, regno, b);\n \n \t\t  /* Put the information for this CALL_INSN on top of what\n \t\t     we already had.  */\n@@ -493,7 +468,7 @@ save_call_clobbered_regs (insn_mode)\n \tfor (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t  if (TEST_HARD_REG_BIT (hard_regs_need_restore, regno))\n \t    regno += insert_restore (insn, GET_CODE (insn) == JUMP_INSN,\n-\t\t\t\t     regno, insn_mode,\n+\t\t\t\t     regno,\n \t\t\t\t     MOVE_MAX / UNITS_PER_WORD, b);\n     }\n }\n@@ -557,14 +532,13 @@ clear_reg_live (reg)\n }      \n \f\n /* If any register currently residing in the save area is referenced in X,\n-   which is part of INSN, emit code to restore the register in front of INSN.\n-   INSN_MODE is the mode to assign to any insns that we add.  */\n+   which is part of INSN, emit code to restore the register in front of\n+   INSN.  */\n \n static void\n-restore_referenced_regs (x, insn, insn_mode, block)\n+restore_referenced_regs (x, insn, block)\n      rtx x;\n      rtx insn;\n-     enum machine_mode insn_mode;\n      int block;\n {\n   enum rtx_code code = GET_CODE (x);\n@@ -584,11 +558,11 @@ restore_referenced_regs (x, insn, insn_mode, block)\n       if (regno >= FIRST_PSEUDO_REGISTER\n \t  && reg_equiv_mem[regno] != 0)\n \trestore_referenced_regs (XEXP (reg_equiv_mem[regno], 0),\n-\t\t\t\t insn, insn_mode, block);\n+\t\t\t\t insn, block);\n       else if (regno >= FIRST_PSEUDO_REGISTER\n \t       && reg_equiv_address[regno] != 0)\n \trestore_referenced_regs (reg_equiv_address[regno],\n-\t\t\t\t insn, insn_mode, block);\n+\t\t\t\t insn, block);\n \n       /* Otherwise if this is a hard register, restore any piece of it that\n \t is currently saved.  */\n@@ -603,7 +577,7 @@ restore_referenced_regs (x, insn, insn_mode, block)\n \n \t  for (i = regno; i < endregno; i++)\n \t    if (TEST_HARD_REG_BIT (hard_regs_need_restore, i))\n-\t      i += insert_restore (insn, 1, i, insn_mode, saveregs, block);\n+\t      i += insert_restore (insn, 1, i, saveregs, block);\n \t}\n \n       return;\n@@ -613,18 +587,17 @@ restore_referenced_regs (x, insn, insn_mode, block)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\trestore_referenced_regs (XEXP (x, i), insn, insn_mode, block);\n+\trestore_referenced_regs (XEXP (x, i), insn, block);\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  restore_referenced_regs (XVECEXP (x, i, j), insn, insn_mode, block);\n+\t  restore_referenced_regs (XVECEXP (x, i, j), insn, block);\n     }\n }\n \f\n /* Insert a sequence of insns to restore REGNO.  Place these insns in front\n-   of or after INSN (determined by BEFORE_P).  INSN_MODE is the mode\n-   to assign to these insns.   MAXRESTORE is the maximum number of registers\n-   which should be restored during this call.  It should never be less than\n-   1 since we only work with entire registers.\n+   of or after INSN (determined by BEFORE_P).   MAXRESTORE is the maximum\n+   number of registers which should be restored during this call.  It should\n+   never be less than 1 since we only work with entire registers.\n \n    Note that we have verified in init_caller_save that we can do this\n    with a simple SET, so use it.  Set INSN_CODE to what we save there\n@@ -635,11 +608,10 @@ restore_referenced_regs (x, insn, insn_mode, block)\n    Return the extra number of registers saved.  */\n \n static int\n-insert_restore (insn, before_p, regno, insn_mode, maxrestore, block)\n+insert_restore (insn, before_p, regno, maxrestore, block)\n      rtx insn;\n      int before_p;\n      int regno;\n-     enum machine_mode insn_mode;\n      int maxrestore;\n      int block;\n {\n@@ -697,19 +669,18 @@ insert_restore (insn, before_p, regno, insn_mode, maxrestore, block)\n       break;\n     }\n \n-  insert_one_insn (insn, before_p, code, insn_mode, pat, block);\n+  insert_one_insn (insn, before_p, code, pat, block);\n \n   /* Tell our callers how many extra registers we saved/restored */\n   return numregs - 1;\n }\n \n /* Like insert_restore, but emit code to save REGNO.  */\n static int\n-insert_save (insn, before_p, regno, insn_mode, block)\n+insert_save (insn, before_p, regno, block)\n      rtx insn;\n      int before_p;\n      int regno;\n-     enum machine_mode insn_mode;\n      int block;\n {\n   rtx pat = NULL_RTX;\n@@ -767,20 +738,18 @@ insert_save (insn, before_p, regno, insn_mode, block)\n       break;\n     }\n \n-  insert_one_insn (insn, before_p, code, insn_mode, pat, block);\n+  insert_one_insn (insn, before_p, code, pat, block);\n \n   /* Tell our callers how many extra registers we saved/restored */\n   return numregs - 1;\n }\n \n-/* Emit one insn, set the code and mode, and update basic block\n-   boundaries.  */\n+/* Emit one insn, set the code, and update basic block boundaries.  */\n static void\n-insert_one_insn (insn, before_p, code, mode, pat, block)\n+insert_one_insn (insn, before_p, code, pat, block)\n      rtx insn;\n      int before_p;\n      enum rtx_code code;\n-     enum machine_mode mode;\n      rtx pat;\n      int block;\n {\n@@ -811,7 +780,6 @@ insert_one_insn (insn, before_p, code, mode, pat, block)\n       if (insert_point == basic_block_end[block])\n \tbasic_block_end[block] = new;\n     }\n-    \n-  PUT_MODE (new, mode);\n+\n   INSN_CODE (new) = code;\n }"}, {"sha": "e86296cb87c4d7aeeb33c09dee8b5b56162a7467", "filename": "gcc/reload.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437a710df01fbb24c920c80ee65803612c2b5ce2/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437a710df01fbb24c920c80ee65803612c2b5ce2/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=437a710df01fbb24c920c80ee65803612c2b5ce2", "patch": "@@ -327,7 +327,7 @@ extern void init_caller_save PROTO((void));\n extern void init_save_areas PROTO((void));\n \n /* Allocate save areas for any hard registers that might need saving.  */\n-extern int setup_save_areas PROTO((int *));\n+extern void setup_save_areas PROTO((void));\n \n /* Find the places where hard regs are live across calls and save them.  */\n-extern void save_call_clobbered_regs PROTO((enum machine_mode));\n+extern void save_call_clobbered_regs PROTO((void));"}, {"sha": "cea782188a86444b44e11d8a8f15bc07571ed582", "filename": "gcc/reload1.c", "status": "modified", "additions": 65, "deletions": 131, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437a710df01fbb24c920c80ee65803612c2b5ce2/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437a710df01fbb24c920c80ee65803612c2b5ce2/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=437a710df01fbb24c920c80ee65803612c2b5ce2", "patch": "@@ -371,6 +371,7 @@ static void count_possible_groups\tPROTO((int *, enum machine_mode *,\n static int modes_equiv_for_class_p\tPROTO((enum machine_mode,\n \t\t\t\t\t       enum machine_mode,\n \t\t\t\t\t       enum reg_class));\n+static void delete_caller_save_insns\tPROTO((rtx));\n static void spill_failure\t\tPROTO((rtx));\n static int new_spill_reg\t\tPROTO((int, int, int *, int *, int,\n \t\t\t\t\t       FILE *));\n@@ -566,10 +567,6 @@ static int something_needs_reloads;\n /* Set during calculate_needs if an insn needs register elimination.  */\n static int something_needs_elimination;\n \n-/* Indicate whether caller saves need a spill register.  */\n-static enum reg_class caller_save_spill_class = NO_REGS;\n-static int caller_save_group_size = 1;\n-\n /* For each class, number of reload regs needed in that class.\n    This is the maximum over all insns of the needs in that class\n    of the individual insn.  */\n@@ -644,12 +641,13 @@ reload (first, global, dumpfile)\n \n   reload_firstobj = (char *) obstack_alloc (&reload_obstack, 0);\n \n+  /* Make sure that the last insn in the chain\n+     is not something that needs reloading.  */\n+  emit_note (NULL_PTR, NOTE_INSN_DELETED);\n+\n   /* Enable find_equiv_reg to distinguish insns made by reload.  */\n   reload_first_uid = get_max_uid ();\n \n-  caller_save_spill_class = NO_REGS;\n-  caller_save_group_size = 1;\n-\n   for (i = 0; i < N_REG_CLASSES; i++)\n     basic_block_needs[i] = 0;\n \n@@ -687,10 +685,6 @@ reload (first, global, dumpfile)\n \t  regs_ever_live[i] = 1;\n       }\n \n-  /* Make sure that the last insn in the chain\n-     is not something that needs reloading.  */\n-  emit_note (NULL_PTR, NOTE_INSN_DELETED);\n-\n   /* Find all the pseudo registers that didn't get hard regs\n      but do have known equivalent constants or memory slots.\n      These include parameters (known equivalent to parameter slots)\n@@ -986,18 +980,26 @@ reload (first, global, dumpfile)\n \t      }\n \t  }\n \n+      /* Insert code to save and restore call-clobbered hard regs\n+\t around calls.  Tell if what mode to use so that we will process\n+\t those insns in reload_as_needed if we have to.  */\n+\n+      if (caller_save_needed)\n+\tsetup_save_areas ();\n+\n+      if (starting_frame_size != get_frame_size ())\n+\tsomething_changed = 1;\n+\n       /* If we allocated another pseudo to the stack, redo elimination\n \t bookkeeping.  */\n       if (something_changed)\n \tcontinue;\n \n-      /* If caller-saves needs a group, initialize the group to include\n-\t the size and mode required for caller-saves.  */\n-\n-      if (caller_save_group_size > 1)\n+      if (caller_save_needed)\n \t{\n-\t  group_mode[(int) caller_save_spill_class] = Pmode;\n-\t  group_size[(int) caller_save_spill_class] = caller_save_group_size;\n+\t  save_call_clobbered_regs ();\n+\t  /* That might have allocated new insn_chain structures.  */\n+\t  reload_firstobj = (char *) obstack_alloc (&reload_obstack, 0);\n \t}\n \n       something_changed |= calculate_needs_all_insns (first, global);\n@@ -1010,32 +1012,6 @@ reload (first, global, dumpfile)\n       if (dumpfile)\n \tdump_needs (dumpfile);\n \n-      /* If we have caller-saves, set up the save areas and see if caller-save\n-\t will need a spill register.  */\n-\n-      if (caller_save_needed)\n-\t{\n-\t  /* Set the offsets for setup_save_areas.  */\n-\t  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n-\t       ep++)\n-\t    ep->previous_offset = ep->max_offset;\n-\n-\t  if ( ! setup_save_areas (&something_changed)\n-\t      && caller_save_spill_class  == NO_REGS)\n-\t    {\n-\t      /* The class we will need depends on whether the machine\n-\t\t supports the sum of two registers for an address; see\n-\t      find_address_reloads for details.  */\n-\n-\t      caller_save_spill_class\n-\t\t= (double_reg_address_ok ? reload_address_index_reg_class\n-\t\t   : reload_address_base_reg_class);\n-\t      caller_save_group_size\n-\t\t= CLASS_MAX_NREGS (caller_save_spill_class, Pmode);\n-\t      something_changed = 1;\n-\t    }\n-\t}\n-\n       {\n \tHARD_REG_SET to_spill;\n \tCLEAR_HARD_REG_SET (to_spill);\n@@ -1098,6 +1074,9 @@ reload (first, global, dumpfile)\n       something_changed |= find_reload_regs (global, dumpfile);\n       if (failure)\n \tgoto failed;\n+\n+      if (something_changed)\n+\tdelete_caller_save_insns (first);\n     }\n \n   /* If global-alloc was run, notify it of any register eliminations we have\n@@ -1107,15 +1086,6 @@ reload (first, global, dumpfile)\n       if (ep->can_eliminate)\n \tmark_elimination (ep->from, ep->to);\n \n-  /* Insert code to save and restore call-clobbered hard regs\n-     around calls.  Tell if what mode to use so that we will process\n-     those insns in reload_as_needed if we have to.  */\n-\n-  if (caller_save_needed)\n-    save_call_clobbered_regs (num_eliminable ? QImode\n-\t\t\t      : caller_save_spill_class != NO_REGS ? HImode\n-\t\t\t      : VOIDmode);\n-\n   /* If a pseudo has no hard reg, delete the insns that made the equivalence.\n      If that insn didn't set the register (i.e., it copied the register to\n      memory), just delete that insn instead of the equivalencing insn plus\n@@ -1141,9 +1111,7 @@ reload (first, global, dumpfile)\n      by generating move instructions to move the must-be-register\n      values into or out of the reload registers.  */\n \n-  if (something_needs_reloads || something_needs_elimination\n-      || (caller_save_needed && num_eliminable)\n-      || caller_save_spill_class != NO_REGS)\n+  if (something_needs_reloads || something_needs_elimination)\n     reload_as_needed (first, global);\n \n   /* If we were able to eliminate the frame pointer, show that it is no\n@@ -1384,13 +1352,7 @@ calculate_needs_all_insns (first, global)\n \t      something_needs_elimination = 1;\n \t    }\n \n-\t  /* If this insn has no reloads, we need not do anything except\n-\t     in the case of a CALL_INSN when we have caller-saves and\n-\t     caller-save needs reloads.  */\n-\n-\t  if (n_reloads != 0\n-\t      || (GET_CODE (insn) == CALL_INSN\n-\t\t  && caller_save_spill_class != NO_REGS))\n+\t  if (n_reloads != 0)\n \t    something_changed |= calculate_needs (this_block, insn,\n \t\t\t\t\t\t  avoid_return_reg, global);\n \t}\n@@ -1650,75 +1612,6 @@ calculate_needs (this_block, insn, avoid_return_reg, global)\n \t\tinsn_needs.other_addr.groups[i]);\n     }\n \n-  /* If this is a CALL_INSN and caller-saves will need\n-     a spill register, act as if the spill register is\n-     needed for this insn.   However, the spill register\n-     can be used by any reload of this insn, so we only\n-     need do something if no need for that class has\n-     been recorded.\n-\n-     The assumption that every CALL_INSN will trigger a\n-     caller-save is highly conservative, however, the number\n-     of cases where caller-saves will need a spill register but\n-     a block containing a CALL_INSN won't need a spill register\n-     of that class should be quite rare.\n-\n-     If a group is needed, the size and mode of the group will\n-     have been set up at the beginning of this loop.  */\n-\n-  if (GET_CODE (insn) == CALL_INSN\n-      && caller_save_spill_class != NO_REGS)\n-    {\n-      int j;\n-      /* See if this register would conflict with any reload that\n-\t needs a group or any reload that needs a nongroup.  */\n-      int nongroup_need = 0;\n-      int *caller_save_needs;\n-\n-      for (j = 0; j < n_reloads; j++)\n-\tif (reg_classes_intersect_p (caller_save_spill_class,\n-\t\t\t\t     reload_reg_class[j])\n-\t    && ((CLASS_MAX_NREGS\n-\t\t (reload_reg_class[j],\n-\t\t  (GET_MODE_SIZE (reload_outmode[j])\n-\t\t   > GET_MODE_SIZE (reload_inmode[j]))\n-\t\t  ? reload_outmode[j] : reload_inmode[j])\n-\t\t > 1)\n-\t\t|| reload_nongroup[j]))\n-\t  {\n-\t    nongroup_need = 1;\n-\t    break;\n-\t  }\n-\n-      caller_save_needs \n-\t= (caller_save_group_size > 1\n-\t   ? insn_needs.other.groups\n-\t   : insn_needs.other.regs[nongroup_need]); \n-\n-      if (caller_save_needs[(int) caller_save_spill_class] == 0)\n-\t{\n-\t  register enum reg_class *p\n-\t    = reg_class_superclasses[(int) caller_save_spill_class];\n-\n-\t  caller_save_needs[(int) caller_save_spill_class]++;\n-\n-\t  while (*p != LIM_REG_CLASSES)\n-\t    caller_save_needs[(int) *p++] += 1;\n-\t}\n-\n-      /* Show that this basic block will need a register of\n-\t this class.  */\n-\n-      if (global\n-\t  && ! (basic_block_needs[(int) caller_save_spill_class]\n-\t\t[this_block]))\n-\t{\n-\t  basic_block_needs[(int) caller_save_spill_class]\n-\t    [this_block] = 1;\n-\t  something_changed = 1;\n-\t}\n-    }\n-\n   /* If this insn stores the value of a function call,\n      and that value is in a register that has been spilled,\n      and if the insn needs a reload in a class\n@@ -2166,6 +2059,47 @@ dump_needs (dumpfile)\n     }\n }\n \f\n+/* Delete all insns that were inserted by emit_caller_save_insns during\n+   this iteration.  */\n+static void\n+delete_caller_save_insns (first)\n+     rtx first;\n+{\n+  rtx insn = first;\n+  int b = -1;\n+\n+  while (insn != 0)\n+    {\n+      if (b + 1 != n_basic_blocks\n+\t  && basic_block_head[b + 1] == insn)\n+\tb++;\n+\n+      while (insn != 0 && INSN_UID (insn) >= reload_first_uid)\n+\t{\n+\t  rtx next = NEXT_INSN (insn);\n+\t  rtx prev = PREV_INSN (insn);\n+\n+\t  if (insn == basic_block_head[b])\n+\t    basic_block_head[b] = next;\n+\t  if (insn == basic_block_end[b])\n+\t    basic_block_end[b] = prev;\n+\n+\t  if (next != 0)\n+\t    PREV_INSN (next) = prev;\n+\t  if (prev != 0)\n+\t    NEXT_INSN (prev) = next;\n+\n+\t  insn = next;\n+\n+\t  if (b + 1 != n_basic_blocks\n+\t      && basic_block_head[b + 1] == insn)\n+\t    b++;\n+\t}\n+      if (insn != 0)\n+\tinsn = NEXT_INSN (insn);\n+    }\n+}\n+\f\n /* Nonzero if, after spilling reg REGNO for non-groups,\n    it will still be possible to find a group if we still need one.  */\n "}]}