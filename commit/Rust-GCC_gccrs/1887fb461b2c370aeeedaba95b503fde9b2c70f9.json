{"sha": "1887fb461b2c370aeeedaba95b503fde9b2c70f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg4N2ZiNDYxYjJjMzcwYWVlZWRhYmE5NWI1MDNmZGU5YjJjNzBmOQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-09-06T13:14:16Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-09-06T13:14:16Z"}, "message": "name-lookup.c (count_fields): Rename to ...\n\n\t* name-lookup.c (count_fields): Rename to ...\n\t(count_class_fields): ... here.  Take a class, don't count\n\tNULL-named fields.\n\t(add_fields_to_record_type): Rename to ...\n\t(field_vec_append_class_fields): ... here.  Take a class, don't\n\tadd NULL-named fields.\n\t(add_enum_fields_to_record_type): Rename to ...\n\t(field_vec_append_enum_values): ... here.\n\t(set_class_bindings): Adjust, assert we added expected number.\n\t(insert_late_enum_def_bindings): Reimplement.  Create vector if\n\tthere are now sufficient entries.\n\nFrom-SVN: r251794", "tree": {"sha": "bf7b0ec203b91be64eb795c20318ebcee22c7571", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf7b0ec203b91be64eb795c20318ebcee22c7571"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1887fb461b2c370aeeedaba95b503fde9b2c70f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1887fb461b2c370aeeedaba95b503fde9b2c70f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1887fb461b2c370aeeedaba95b503fde9b2c70f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1887fb461b2c370aeeedaba95b503fde9b2c70f9/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4269edf01cc14cd15853692d966daf2fb92e2adc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4269edf01cc14cd15853692d966daf2fb92e2adc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4269edf01cc14cd15853692d966daf2fb92e2adc"}], "stats": {"total": 124, "additions": 73, "deletions": 51}, "files": [{"sha": "ed98902fd42154872c17e686ed79f8fe0866636c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1887fb461b2c370aeeedaba95b503fde9b2c70f9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1887fb461b2c370aeeedaba95b503fde9b2c70f9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1887fb461b2c370aeeedaba95b503fde9b2c70f9", "patch": "@@ -1,5 +1,17 @@\n 2017-09-06  Nathan Sidwell  <nathan@acm.org>\n \n+\t* name-lookup.c (count_fields): Rename to ...\n+\t(count_class_fields): ... here.  Take a class, don't count\n+\tNULL-named fields.\n+\t(add_fields_to_record_type): Rename to ...\n+\t(field_vec_append_class_fields): ... here.  Take a class, don't\n+\tadd NULL-named fields.\n+\t(add_enum_fields_to_record_type): Rename to ...\n+\t(field_vec_append_enum_values): ... here.\n+\t(set_class_bindings): Adjust, assert we added expected number.\n+\t(insert_late_enum_def_bindings): Reimplement.  Create vector if\n+\tthere are now sufficient entries.\n+\n \t* name-lookup.h (lookup_fnfields_slot_nolazy,\n \tlookup_fnfields_slot): Rename to ...\n \t(get_class_binding_direct, get_class_binding): ... here."}, {"sha": "ccfb630e4dd2d2a3e2beb020bf591bf939c21a0f", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 61, "deletions": 51, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1887fb461b2c370aeeedaba95b503fde9b2c70f9/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1887fb461b2c370aeeedaba95b503fde9b2c70f9/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=1887fb461b2c370aeeedaba95b503fde9b2c70f9", "patch": "@@ -1452,59 +1452,57 @@ sorted_fields_type_new (int n)\n   return sft;\n }\n \n-/* Subroutine of insert_into_classtype_sorted_fields.  Recursively\n-   count the number of fields in TYPE, including anonymous union\n-   members.  */\n+/* Recursively count the number of fields in KLASS, including anonymous\n+   union members.  */\n \n-static int\n-count_fields (tree fields)\n+static unsigned\n+count_class_fields (tree klass)\n {\n-  tree x;\n-  int n_fields = 0;\n-  for (x = fields; x; x = DECL_CHAIN (x))\n-    {\n-      if (DECL_DECLARES_FUNCTION_P (x))\n-\t/* Functions are dealt with separately.  */;\n-      else if (TREE_CODE (x) == FIELD_DECL && ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n-\tn_fields += count_fields (TYPE_FIELDS (TREE_TYPE (x)));\n-      else\n-\tn_fields += 1;\n-    }\n+  unsigned n_fields = 0;\n+\n+  for (tree fields = TYPE_FIELDS (klass); fields; fields = DECL_CHAIN (fields))\n+    if (DECL_DECLARES_FUNCTION_P (fields))\n+      /* Functions are dealt with separately.  */;\n+    else if (TREE_CODE (fields) == FIELD_DECL\n+\t     && ANON_AGGR_TYPE_P (TREE_TYPE (fields)))\n+      n_fields += count_class_fields (TREE_TYPE (fields));\n+    else if (DECL_NAME (fields))\n+      n_fields += 1;\n+\n   return n_fields;\n }\n \n-/* Subroutine of insert_into_classtype_sorted_fields.  Recursively add\n-   all the fields in the TREE_LIST FIELDS to the SORTED_FIELDS_TYPE\n-   elts, starting at offset IDX.  */\n+/* Append all the nonfunction members fields of KLASS to FIELD_VEC\n+   starting at IDX. Recurse for anonymous members.  The array must\n+   have space.  Returns the next available index.  */\n \n-static int\n-add_fields_to_record_type (tree fields, struct sorted_fields_type *field_vec,\n-\t\t\t   int idx)\n+static unsigned\n+field_vec_append_class_fields (struct sorted_fields_type *field_vec,\n+\t\t\t       tree klass, unsigned idx)\n {\n-  tree x;\n-  for (x = fields; x; x = DECL_CHAIN (x))\n-    {\n-      if (DECL_DECLARES_FUNCTION_P (x))\n-\t/* Functions are handled separately.  */;\n-      else if (TREE_CODE (x) == FIELD_DECL && ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n-\tidx = add_fields_to_record_type (TYPE_FIELDS (TREE_TYPE (x)), field_vec, idx);\n-      else\n-\tfield_vec->elts[idx++] = x;\n-    }\n+  for (tree fields = TYPE_FIELDS (klass); fields; fields = DECL_CHAIN (fields))\n+    if (DECL_DECLARES_FUNCTION_P (fields))\n+      /* Functions are handled separately.  */;\n+    else if (TREE_CODE (fields) == FIELD_DECL\n+\t     && ANON_AGGR_TYPE_P (TREE_TYPE (fields)))\n+      idx = field_vec_append_class_fields (field_vec, TREE_TYPE (fields), idx);\n+    else if (DECL_NAME (fields))\n+      field_vec->elts[idx++] = fields;\n+\n   return idx;\n }\n \n-/* Add all of the enum values of ENUMTYPE, to the FIELD_VEC elts,\n-   starting at offset IDX.  */\n+/* Append all of the enum values of ENUMTYPE to FIELD_VEC starting at IDX.\n+   FIELD_VEC must have space.  */\n \n-static int\n-add_enum_fields_to_record_type (tree enumtype,\n-\t\t\t\tstruct sorted_fields_type *field_vec,\n-\t\t\t\tint idx)\n+static unsigned\n+field_vec_append_enum_values (struct sorted_fields_type *field_vec,\n+\t\t\t      tree enumtype, unsigned idx)\n {\n-  tree values;\n-  for (values = TYPE_VALUES (enumtype); values; values = TREE_CHAIN (values))\n+  for (tree values = TYPE_VALUES (enumtype);\n+       values; values = TREE_CHAIN (values))\n     field_vec->elts[idx++] = TREE_VALUE (values);\n+\n   return idx;\n }\n \n@@ -1518,12 +1516,12 @@ set_class_bindings (tree klass)\n     qsort (method_vec->address (), method_vec->length (),\n \t   sizeof (tree), method_name_cmp);\n \n-  tree fields = TYPE_FIELDS (klass);\n-  int n_fields = count_fields (fields);\n+  int n_fields = count_class_fields (klass);\n   if (n_fields >= 8)\n     {\n       struct sorted_fields_type *field_vec = sorted_fields_type_new (n_fields);\n-      add_fields_to_record_type (fields, field_vec, 0);\n+      unsigned idx = field_vec_append_class_fields (field_vec, klass, 0);\n+      gcc_assert (idx == unsigned (field_vec->len));\n       qsort (field_vec->elts, n_fields, sizeof (tree), field_decl_cmp);\n       CLASSTYPE_SORTED_FIELDS (klass) = field_vec;\n     }\n@@ -1534,19 +1532,31 @@ set_class_bindings (tree klass)\n void\n insert_late_enum_def_bindings (tree klass, tree enumtype)\n {\n+  unsigned n_fields;\n   struct sorted_fields_type *sorted_fields = CLASSTYPE_SORTED_FIELDS (klass);\n+\n+  /* The enum values will already be on the TYPE_FIELDS, so don't\n+     count them twice.  */\n   if (sorted_fields)\n+    n_fields = list_length (TYPE_VALUES (enumtype)) + sorted_fields->len;\n+  else\n+    n_fields = count_class_fields (klass);\n+\n+  if (n_fields >= 8)\n     {\n-      int i;\n-      int n_fields\n-\t= list_length (TYPE_VALUES (enumtype)) + sorted_fields->len;\n       struct sorted_fields_type *field_vec = sorted_fields_type_new (n_fields);\n-      \n-      for (i = 0; i < sorted_fields->len; ++i)\n-\tfield_vec->elts[i] = sorted_fields->elts[i];\n+      unsigned idx;\n+\n+      if (sorted_fields)\n+\t{\n+\t  for (idx = 0; idx < unsigned (sorted_fields->len); ++idx)\n+\t    field_vec->elts[idx] = sorted_fields->elts[idx];\n \n-      add_enum_fields_to_record_type (enumtype, field_vec,\n-\t\t\t\t      sorted_fields->len);\n+\t  idx = field_vec_append_enum_values (field_vec, enumtype, idx);\n+\t}\n+      else\n+\tidx = field_vec_append_class_fields (field_vec, klass, 0);\n+      gcc_assert (idx == unsigned (field_vec->len));\n       qsort (field_vec->elts, n_fields, sizeof (tree), field_decl_cmp);\n       CLASSTYPE_SORTED_FIELDS (klass) = field_vec;\n     }"}]}