{"sha": "05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "node_id": "C_kwDOANBUbNoAKDA1NjUyYWM0ZThiODY4NWZlMGMwZjRlZTJmNzU1MTZkMjhiYmY4OTI", "commit": {"author": {"name": "Gaius Mulley", "email": "gaiusmod2@gmail.com", "date": "2023-02-25T16:28:19Z"}, "committer": {"name": "Gaius Mulley", "email": "gaiusmod2@gmail.com", "date": "2023-02-25T16:28:19Z"}, "message": "modula-2 module registration process seems to fail with shared libraries [PR108261]\n\nThe commit adds pathnames to modula-2 which in turn appears in any\nexternal symbol.  This is necessary to allow different dialects of\nlibraries to coexist (different implementations of SYSTEM and Storage\nfor example in libm2pim and libm2iso).  It also makes it easier to\ndebug as the library name forms part of the external mangled name.\nBy default pathnames are not user facing.  This commit fixes\nPR108261.\n\ngcc/ChangeLog:\n\n\tPR modula2/108261\n\t* doc/gm2.texi (-fm2-pathname): New option documented.\n\t(-fm2-pathnameI): New option documented.\n\t(-fm2-prefix=): New option documented.\n\t(-fruntime-modules=): Update default module list.\n\ngcc/m2/ChangeLog:\n\n\tPR modula2/108261\n\t* Make-lang.in (GM2-COMP-BOOT-DEFS): DynamicStringPath.def\n\tremove.  DynamicPath.def add.\n\t(GM2-COMP-BOOT-MODS): DynamicStringPath.mod remove.\n\tDynamicPath.mod add.\n\t* Make-maintainer.in (BUILD-BOOT-PPG-H): New dependency.\n\t(m2/gm2-ppg-boot/$(SRC_PREFIX)%.o): $(BUILD-BOOT-PPG-H) Add\n\tdependency.\n\t(PGE-DEF): New definition.\n\t(BUILD-BOOT-PG-H): New dependency.\n\t(m2/gm2-pg-boot/$(SRC_PREFIX)%.o): $(BUILD-BOOT-PG-H) Add\n\tdependency.\n\t(BUILD-BOOT-PGE-H): New dependency.\n\t(m2/gm2-pge-boot/$(SRC_PREFIX)%.o): $(BUILD-BOOT-PGE-H) Add\n\tdependency.\n\t(GM2PATH): Add pathname entries.\n\t(m2/boot-bin/mc-devel$(exeext)): Add m2/mc-boot-ch/Gm2rtsdummy.o\n\tdependency.\n\t(m2/boot-bin/mc-opt$(exeext)): Fix -I path.\n\t* gm2-compiler/DynamicStringPath.def: Renamed module to\n\tDynamicPath.\n\t(GetUserPath): Remove.\n\t(GetSystemPath): Remove.\n\t(SetUserPath): Remove.\n\t(SetSystemPath): Remove.\n\t(DumpPath): New procedure definition.\n\t* gm2-compiler/DynamicStringPath.mod: Renamed module to\n\tDynamicPath.\n\t(GetUserPath): Remove.\n\t(GetSystemPath): Remove.\n\t(SetUserPath): Remove.\n\t(SetSystemPath): Remove.\n\t(DumpPath): Remove Debugging conditional.\n\t* gm2-compiler/M2AsmUtil.mod: Import EqualArray, NulName and\n\tGetLibName.\n\t(Debugging): New declaration.\n\t(GetFullSymName): Re-implemented to prefix (mange) libname\n\tto any extern variable/procedure which is IsExportQualified.\n\t* gm2-compiler/M2Comp.mod (qprintLibName): New procedure.\n\t* gm2-compiler/M2Graph.mod (resolveImports): Add libname.\n\t* gm2-compiler/M2Options.def (SetM2Prefix): New procedure.\n\t(GetM2Prefix): New procedure function.\n\t(SetM2PathName): New procedure.\n\t(GetM2PathName): New procedure function.\n\t* gm2-compiler/M2Options.mod: (SetM2Prefix): New procedure implemented.\n\t(GetM2Prefix): New procedure function implemented.\n\t(SetM2PathName): New procedure implemented.\n\t(GetM2PathName): New procedure function implemented.\n\t(RuntimeModuleOverride): Set to DefaultRuntimeModuleOverride.\n\t* gm2-compiler/M2Quads.mod: Import GetLibName.\n\t(SafeRequestSym) Pass result of GetLibName to RequestDependant.\n\t(callRequestDependant): Add libname as a parameter.\n\t(BuildM2InitFunction): Add libname as a parameter.\n\t(BuildM2FiniFunction): Add libname as a parameter.\n\t(BuildM2CtorFunction): Add libname as a parameter.\n\t* gm2-compiler/M2Scaffold.mod (LookupModuleSym): Set LibName\n\tif a definition source was found.\n\t* gm2-compiler/M2Search.def (FindSourceFile): Add named library parameter.\n\t(FindSourceDefFile): Add named library parameter.\n\t(FindSourceModFile): Add named library parameter.\n\t* gm2-compiler/M2Search.mod (FindSourceFile): Reimplement.\n\t(FindSourceDefFile): Add named library parameter.\n\t(FindSourceModFile): Add named library parameter.\n\t* gm2-compiler/SymbolTable.def (MakeProcedureCtorExtern): Add\n\tlibname parameter.\n\t(PutLibName): New procedure.\n\t(GetLibName): New procedure function.\n\t* gm2-compiler/SymbolTable.mod (MakeProcedureCtorExtern): Add\n\tlibname parameter.\n\t(GenName): Add libname parameter.\n\t(InitCtorFields): Add moduleSym as a parameter.\n\t(PutCtorExtern): Add libname parameter to GenName.\n\t* gm2-gcc/init.cc (_M2_DynamicStringPath_init): Rename function...\n\t(_M2_DynamicPath_init): ...to this.\n\t(_M2_PathName_init): Added.\n\t* gm2-gcc/m2decl.cc (m2decl_DeclareM2linkStaticInitialization):\n\tAdd m2pim as the manged component of the exported symbol.\n\t(m2decl_DeclareM2linkForcedModuleInitOrder): Add m2pim mangle prefix.\n\t* gm2-gcc/m2options.h (M2Options_SetM2Prefix): New function.\n\t(M2Options_GetM2Prefix): New function.\n\t(M2Options_SetM2PathName): New function.\n\t(M2Options_GetM2PathName): New function.\n\t* gm2-lang.cc (push_back_Ipath): New function.\n\t(add_one_import_path): New function.\n\t(gm2_langhook_handle_option): Record -I component.  Call\n\tSetM2PathName when -fm2-pathname= is seen.  Record -fm2-pathnameI\n\tcomponent.  Call SetM2Prefix when -fm2-prefix= is seen.\n\t(gm2_langhook_post_options): Iterative over pathname entries\n\tand call SetM2PathName, SetSearchPath as appropriate.\n\t* gm2-libs-iso/M2RTS.def (ConstructModules): Add libname parameter.\n\t(DeconstructModules): Add libname parameter.\n\t(RegisterModule): Add libname parameter.\n\t(RequestDependant): Add libname parameter.\n\t* gm2-libs-iso/M2RTS.mod (ConstructModules): Add libname parameter.\n\t(DeconstructModules): Add libname parameter.\n\t(RegisterModule): Add libname parameter.\n\t(RequestDependant): Add libname parameter.\n\t* gm2-libs-min/M2RTS.def (ConstructModules): Add libname parameter.\n\t(DeconstructModules): Add libname parameter.\n\t(RegisterModule): Add libname parameter.\n\t(RequestDependant): Add libname parameter.\n\t* gm2-libs-min/M2RTS.mod (ConstructModules): Add libname parameter.\n\t(DeconstructModules): Add libname parameter.\n\t(RegisterModule): Add libname parameter.\n\t(RequestDependant): Add libname parameter.\n\t* gm2-libs/M2Dependent.def (ConstructModules): Add libname parameter.\n\t(DeconstructModules): Add libname parameter.\n\t(RegisterModule): Add libname parameter.\n\t(RequestDependant): Add libname parameter.\n\t* gm2-libs/M2Dependent.mod (ConstructModules): Add libname parameter.\n\t(DeconstructModules): Add libname parameter.\n\t(RegisterModule): Add libname parameter.\n\t(RequestDependant): Add libname parameter.\n\t* gm2-libs/M2RTS.def (ConstructModules): Add libname parameter.\n\t(DeconstructModules): Add libname parameter.\n\t(RegisterModule): Add libname parameter.\n\t(RequestDependant): Add libname parameter.\n\t* gm2-libs/M2RTS.mod (ConstructModules): Add libname parameter.\n\t(DeconstructModules): Add libname parameter.\n\t(RegisterModule): Add libname parameter.\n\t(RequestDependant): Add libname parameter.\n\t* gm2-libs/RTint.mod (FindVector): Rename variables.\n\t(initInputVector): Rename variables.\n\t(initOutputVector): Rename variables.\n\t(InitTimeVector): Rename variables.\n\t(FindVectorNo): Rename variables.\n\t(FindPendingVector): Rename variables.\n\t(ReArmTimeVector): Rename variables.\n\t(GetTimeVector): Rename variables.\n\t(AttachVector): Rename variables.\n\t(AttachVector): Rename variables.\n\t(IncludeVector): Rename variables.\n\t(ExcludeVector): Rename variables.\n\t(AddFd): Rename variables.\n\t(AddFd): Rename variables.\n\t(DumpPendingQueue): Rename variables.\n\t(stop): Remove.\n\t(activatePending): Rename variables.\n\t(Listen): Rename variables.\n\t* gm2-libs/libc.def (snprintf): New function.\n\t* gm2-libs/sckt.def: Change all exported identifiers to be\n\texport qualified.\n\t* gm2spec.cc (push_back_Ipath): New function.\n\t(add_m2_I_path): New function.\n\t(lang_specific_driver): Skip -fm2-pathname= and remember pathname.\n\tSkip -I and record the path and current pathname.  Call add_m2_I_path.\n\t* lang-specs.h: Replace %{I*} with %{fm2-pathname*}.\n\t* lang.opt (-fm2-pathname=): New entry.\n\t(-fm2-pathname): New entry.\n\t(-fm2-prefix=): New entry.\n\t* mc-boot-ch/GUnixArgs.cc (_M2_UnixArgs_dep): New function.\n\t(_M2_UnixArgs_ctor::_M2_UnixArgs_ctor): New method.\n\t* mc-boot-ch/Glibc.c (libc_snprintf): New function.\n\t* mc-boot-ch/m2rts.h (M2RTS_RequestDependant): Changed prototype.\n\t(M2RTS_RegisterModule): Changed prototype.\n\t* mc-boot/GDynamicStrings.c: Rebuild.\n\t* mc-boot/GFIO.c: Rebuild.\n\t* mc-boot/GIndexing.c: Rebuild.\n\t* mc-boot/GM2Dependent.c: Rebuild.\n\t* mc-boot/GM2Dependent.h: Rebuild.\n\t* mc-boot/GM2EXCEPTION.c: Rebuild.\n\t* mc-boot/GM2RTS.c: Rebuild.\n\t* mc-boot/GM2RTS.h: Rebuild.\n\t* mc-boot/GPushBackInput.c: Rebuild.\n\t* mc-boot/GRTExceptions.c: Rebuild.\n\t* mc-boot/GRTint.c: Rebuild.\n\t* mc-boot/GStdIO.c: Rebuild.\n\t* mc-boot/GStringConvert.c: Rebuild.\n\t* mc-boot/GSysStorage.c: Rebuild.\n\t* mc-boot/Gdecl.c: Rebuild.\n\t* mc-boot/Gkeyc.c: Rebuild.\n\t* mc-boot/Glibc.h: Rebuild.\n\t* mc-boot/GmcComment.c: Rebuild.\n\t* mc-boot/GmcComp.c: Rebuild.\n\t* mc-boot/GmcDebug.c: Rebuild.\n\t* mc-boot/GmcMetaError.c: Rebuild.\n\t* mc-boot/GmcStack.c: Rebuild.\n\t* mc-boot/GnameKey.c: Rebuild.\n\t* mc-boot/GsymbolKey.c: Rebuild.\n\t* pge-boot/GASCII.c: Rebuild.\n\t* pge-boot/GArgs.c: Rebuild.\n\t* pge-boot/GAssertion.c: Rebuild.\n\t* pge-boot/GDebug.c: Rebuild.\n\t* pge-boot/GDynamicStrings.c: Rebuild.\n\t* pge-boot/GFIO.c: Rebuild.\n\t* pge-boot/GIO.c: Rebuild.\n\t* pge-boot/GIndexing.c: Rebuild.\n\t* pge-boot/GLists.c: Rebuild.\n\t* pge-boot/GM2Dependent.c: Rebuild.\n\t* pge-boot/GM2Dependent.h: Rebuild.\n\t* pge-boot/GM2EXCEPTION.c: Rebuild.\n\t* pge-boot/GM2RTS.c: Rebuild.\n\t* pge-boot/GM2RTS.h: Rebuild.\n\t* pge-boot/GNameKey.c: Rebuild.\n\t* pge-boot/GNumberIO.c: Rebuild.\n\t* pge-boot/GOutput.c: Rebuild.\n\t* pge-boot/GPushBackInput.c: Rebuild.\n\t* pge-boot/GRTExceptions.c: Rebuild.\n\t* pge-boot/GSFIO.c: Rebuild.\n\t* pge-boot/GStdIO.c: Rebuild.\n\t* pge-boot/GStorage.c: Rebuild.\n\t* pge-boot/GStrCase.c: Rebuild.\n\t* pge-boot/GStrIO.c: Rebuild.\n\t* pge-boot/GStrLib.c: Rebuild.\n\t* pge-boot/GSymbolKey.c: Rebuild.\n\t* pge-boot/GSysExceptions.c (_M2_SysExceptions_finish): Rename this...\n\t(_M2_SysExceptions_fini): ... to this.\n\t* pge-boot/GSysStorage.c: Rebuild.\n\t(_M2_SysStorage_finish): Rename this...\n\t(_M2_SysStorage_fini): ... to this.\n\t* pge-boot/GUnixArgs.cc: New file.\n\t* pge-boot/Gbnflex.c (_M2_bnflex_finish): Rename this...\n\t(_M2_bnflex_fini): ... to this.\n\t* pge-boot/Gerrno.c (_M2_errno_finish): Rename this...\n\t(_M2_errno_fini): ... to this.\n\t* pge-boot/Glibc.c (libc_snprintf): New function.\n\t* pge-boot/Glibc.h (libc_snprintf): New prototype.\n\t* pge-boot/Gpge.c (_M2_pge_finish): Rename this...\n\t(_M2_pge_fini): ... to this.\n\t* pge-boot/Gtermios.cc (_M2_termios_finish): Rename this...\n\t(_M2_termios_fini): ... to this.\n\t* pge-boot/main.c (_M2_RTExceptions_finish): Rename this...\n\t(_M2_RTExceptions_fini): ... to this.\n\t(_M2_M2EXCEPTION_finish): Rename this...\n\t(_M2_M2EXCEPTION_fini): ... to this.\n\t(_M2_M2RTS_finish): Rename this...\n\t(_M2_M2RTS_fini): ... to this.\n\t(_M2_SysExceptions_finish): Rename this...\n\t(_M2_SysExceptions_fini): ... to this.\n\t(_M2_StrLib_finish): Rename this...\n\t(_M2_StrLib_fini): ... to this.\n\t(_M2_errno_finish): Rename this...\n\t(_M2_errno_fini): ... to this.\n\t(_M2_termios_finish): Rename this...\n\t(_M2_termios_fini): ... to this.\n\t(_M2_IO_finish): Rename this...\n\t(_M2_IO_fini): ... to this.\n\t(_M2_StdIO_finish): Rename this...\n\t(_M2_StdIO_fini): ... to this.\n\t(_M2_Debug_finish): Rename this...\n\t(_M2_Debug_fini): ... to this.\n\t(_M2_SysStorage_finish): Rename this...\n\t(_M2_SysStorage_fini): ... to this.\n\t(_M2_Storage_finish): Rename this...\n\t(_M2_Storage_fini): ... to this.\n\t(_M2_StrIO_finish): Rename this...\n\t(_M2_StrIO_fini): ... to this.\n\t(_M2_DynamicStrings_finish): Rename this...\n\t(_M2_DynamicStrings_fini): ... to this.\n\t(_M2_Assertion_finish): Rename this...\n\t(_M2_Assertion_fini): ... to this.\n\t(_M2_Indexing_finish): Rename this...\n\t(_M2_Indexing_fini): ... to this.\n\t(_M2_NameKey_finish): Rename this...\n\t(_M2_NameKey_fini): ... to this.\n\t(_M2_NumberIO_finish): Rename this...\n\t(_M2_NumberIO_fini): ... to this.\n\t(_M2_PushBackInput_finish): Rename this...\n\t(_M2_PushBackInput_fini): ... to this.\n\t(_M2_SymbolKey_finish): Rename this...\n\t(_M2_SymbolKey_fini): ... to this.\n\t(_M2_UnixArgs_finish): Rename this...\n\t(_M2_UnixArgs_fini): ... to this.\n\t(_M2_FIO_finish): Rename this...\n\t(_M2_FIO_fini): ... to this.\n\t(_M2_SFIO_finish): Rename this...\n\t(_M2_SFIO_fini): ... to this.\n\t(_M2_StrCase_finish): Rename this...\n\t(_M2_StrCase_fini): ... to this.\n\t(_M2_bnflex_finish): Rename this...\n\t(_M2_bnflex_fini): ... to this.\n\t(_M2_Lists_finish): Rename this...\n\t(_M2_Lists_fini): ... to this.\n\t(_M2_Args_finish): Rename this...\n\t(_M2_Args_fini): ... to this.\n\t(_M2_Output_finish): Rename this...\n\t(_M2_Output_fini): ... to this.\n\t(_M2_pge_finish): Rename this...\n\t(_M2_pge_fini): ... to this.\n\t* plugin/m2rte.cc (m2_runtime_error_calls): Change all runtime\n\tprocedure names to their name mangled counterparts.\n\t* gm2-libs-iso/wrapsock.c: Removed.\n\t* gm2-libs-iso/wraptime.c: Removed.\n\t* mc-boot/Gpth.h: Removed.\n\t* gm2-compiler/PathName.def: New file.\n\t* gm2-compiler/PathName.mod: New file.\n\nlibgm2/ChangeLog:\n\n\tPR modula2/108261\n\t* libm2cor/KeyBoardLEDs.cc (EXPORT): New define.\n\t(M2EXPORT): New define.\n\t(M2LIBNAME): New define.\n\t(KeyBoardLEDs_SwitchScroll): EXPORT.\n\t(KeyBoardLEDs_SwitchNum): EXPORT.\n\t(KeyBoardLEDs_SwitchCaps): EXPORT.\n\t(KeyBoardLEDs_SwitchLeds): EXPORT.\n\t(_M2_KeyBoardLEDs_init): M2EXPORT.\n\t(_M2_KeyBoardLEDs_finish): M2EXPORT.\n\t(_M2_KeyBoardLEDs_dep): M2EXPORT.\n\t* libm2cor/Makefile.am (libm2cor_la_M2FLAGS): Define\n\tpath names.\n\t* libm2cor/Makefile.in: Rebuild.\n\t* libm2iso/ErrnoCategory.cc (EXPORT): New define.\n\t(M2EXPORT): New define.\n\t(M2LIBNAME): New define.\n\t(ErrnoCategory_IsErrnoHard): EXPORT.\n\t(ErrnoCategory_IsErrnoSoft): EXPORT.\n\t(ErrnoCategory_UnAvailable): EXPORT.\n\t(ErrnoCategory_GetOpenResults): EXPORT.\n\t(_M2_ErrnoCategory_init): M2EXPORT.\n\t(_M2_ErrnoCategory_fini): M2EXPORT.\n\t(_M2_ErrnoCategory_dep): M2EXPORT.\n\t(_M2_ErrnoCategory_ctor): M2EXPORT.\n\t* libm2iso/Makefile.am (libm2iso_la_M2FLAGS): Define\n\tpath names.\n\t* libm2iso/Makefile.in: Rebuild.\n\t* libm2iso/RTco.cc (EXPORT): New define.\n\t(M2EXPORT): New define.\n\t(M2LIBNAME): New define.\n\t(newSem): Add module libname prefix to HaltC.\n\t(currentThread): Remove variable and replace with a function.\n\t(never): Add module libname prefix to HaltC.\n\t(initThread): Add module libname prefix to HaltC.\n\t* libm2iso/m2rts.h (str): New define.\n\t(M2RTS_RequestDependant): Change to the mangled name equivalent.\n\t(M2RTS_RegisterModule): Change to the mangled name equivalent.\n\t(m2iso_M2RTS_RequestDependant): Add libname parameter.\n\t(m2iso_M2RTS_RegisterModule): Add libname parameter.\n\t(m2pim_M2RTS_RegisterModule): Add libname parameter.\n\t(_M2_M2RTS_init): Rename this...\n\t(m2iso_M2_M2RTS_init): ...to this.\n\t(M2RTS_ConstructModules): Change to the mangled name equivalent.\n\t(M2RTS_Terminate): Change to the mangled name equivalent.\n\t(M2RTS_DeconstructModules): Change to the mangled name equivalent.\n\t(m2iso_M2RTS_ConstructModules): Add libname parameter.\n\t(m2iso_M2RTS_Terminate): Add libname parameter.\n\t(m2iso_M2RTS_DeconstructModules): Add libname parameter.\n\t(M2RTS_HaltC): Rename this...\n\t(m2iso_M2RTS_HaltC): ...to this.\n\t* libm2iso/wrapsock.c (EXPORT): New define.\n\t(IMPORT): New define.\n\t(M2EXPORT): New define.\n\t(M2LIBNAME): New define.\n\t(m2iso_M2RTS_RequestDependant): Add prototype.\n\t(wrapsock_clientOpen): EXPORT.\n\t(wrapsock_clientOpenIP): EXPORT.\n\t(wrapsock_getClientPortNo): EXPORT.\n\t(wrapsock_getClientHostname): EXPORT.\n\t(wrapsock_getClientSocketFd): EXPORT.\n\t(wrapsock_getClientIP): EXPORT.\n\t(wrapsock_getPushBackChar): EXPORT.\n\t(wrapsock_setPushBackChar): EXPORT.\n\t(wrapsock_getSizeOfClientInfo): EXPORT.\n\t(_M2_wrapsock_init): M2EXPORT.\n\t(_M2_wrapsock_fini): M2EXPORT.\n\t(ctor): M2EXPORT.  New function.\n\t* libm2iso/wraptime.c: Rename to...\n\t* libm2iso/wraptime.cc: ...this.\n\t(EXPORT): New define.\n\t(M2EXPORT): New define.\n\t(M2LIBNAME): New define.\n\t(wraptime_InitTimeval): EXPORT.\n\t(wraptime_KillTimeval): EXPORT.\n\t(wraptime_InitTimezone): EXPORT.\n\t(wraptime_KillTimezone): EXPORT.\n\t(wraptime_InitTM): EXPORT.\n\t(wraptime_KillTM): EXPORT.\n\t(wraptime_gettimeofday): EXPORT.\n\t(wraptime_settimeofday): EXPORT.\n\t(wraptime_GetFractions): EXPORT.\n\t(wraptime_localtime_r): EXPORT.\n\t(wraptime_GetYear): EXPORT.\n\t(wraptime_GetMonth): EXPORT.\n\t(wraptime_GetDay): EXPORT.\n\t(wraptime_GetHour): EXPORT.\n\t(wraptime_GetMinute): EXPORT.\n\t(wraptime_GetSecond): EXPORT.\n\t(wraptime_GetSummerTime): EXPORT.\n\t(wraptime_GetDST): EXPORT.\n\t(wraptime_SetTimezone): EXPORT.\n\t(wraptime_SetTimeval): EXPORT.\n\t(_M2_wraptime_init): M2EXPORT.\n\t(_M2_wraptime_fini): M2EXPORT.\n\t(ctor): M2EXPORT.  New function.\n\t* libm2log/Makefile.am (libm2log_la_M2FLAGS): Define\n\tpath names.\n\t* libm2log/Makefile.in:\n\t* libm2min/Makefile.am (libm2min_la_M2FLAGS): Define\n\tpath names.\n\t* libm2min/Makefile.in:\n\t* libm2pim/Makefile.am (libm2pim_la_M2FLAGS): Define\n\tpath names.\n\t* libm2pim/Makefile.in:\n\t* libm2pim/Selective.cc (EXPORT): New define.\n\t(M2EXPORT): New define.\n\t(M2LIBNAME): New define.\n\t(Selective_Select): EXPORT.\n\t(Selective_InitTime): EXPORT.\n\t(Selective_GetTime): EXPORT.\n\t(Selective_SetTime): EXPORT.\n\t(Selective_KillTime): EXPORT.\n\t(Selective_InitSet): EXPORT.\n\t(Selective_KillSet): EXPORT.\n\t(Selective_FdZero): EXPORT.\n\t(Selective_FdSet): EXPORT.\n\t(Selective_FdClr): EXPORT.\n\t(Selective_FdIsSet): EXPORT.\n\t(Selective_GetTimeOfDay): EXPORT.\n\t(Selective_MaxFdsPlusOne): EXPORT.\n\t(Selective_WriteCharRaw): EXPORT.\n\t(Selective_ReadCharRaw): EXPORT.\n\t(_M2_Selective_init): M2EXPORT.\n\t(_M2_Selective_fini): M2EXPORT.\n\t(_M2_Selective_dep): M2EXPORT.\n\t(_M2_Selective_ctor): M2EXPORT.\n\t* libm2pim/SysExceptions.cc (EXPORT): New define.\n\t(M2EXPORT): New define.\n\t(M2LIBNAME): New define.\n\t(SysExceptions_InitExceptionHandlers): EXPORT.\n\t(_M2_SysExceptions_init): M2EXPORT.\n\t(_M2_SysExceptions_fini): M2EXPORT.\n\t(_M2_SysExceptions_dep): M2EXPORT.\n\t(_M2_SysExceptions_ctor): M2EXPORT.\n\t* libm2pim/UnixArgs.cc (EXPORT): New define.\n\t(M2EXPORT): New define.\n\t(M2LIBNAME): New define.\n\t(UnixArgs_GetArgC): EXPORT.\n\t(UnixArgs_GetArgV): EXPORT.\n\t(UnixArgs_GetEnvV): EXPORT.\n\t(_M2_UnixArgs_init): M2EXPORT.\n\t(_M2_UnixArgs_fini): M2EXPORT.\n\t(_M2_UnixArgs_dep): M2EXPORT.\n\t(_M2_UnixArgs_ctor): M2EXPORT.\n\t* libm2pim/cgetopt.cc (EXPORT): New define.\n\t(M2EXPORT): New define.\n\t(M2LIBNAME): New define.\n\t(cgetopt_getopt): EXPORT.\n\t(cgetopt_getopt_long): EXPORT.\n\t(cgetopt_getopt_long_only): EXPORT.\n\t(cgetopt_InitOptions): EXPORT.\n\t(cgetopt_KillOptions): EXPORT.\n\t(cgetopt_SetOption): EXPORT.\n\t(cgetopt_GetLongOptionArray): EXPORT.\n\t(_M2_cgetopt_init): M2EXPORT.\n\t(_M2_cgetopt_fini): M2EXPORT.\n\t(_M2_cgetopt_dep): M2EXPORT.\n\t(_M2_cgetopt_ctor): M2EXPORT.\n\t* libm2pim/dtoa.cc (EXPORT): New define.\n\t(M2EXPORT): New define.\n\t(M2LIBNAME): New define.\n\t(dtoa_strtod): EXPORT.\n\t(dtoa_calcmaxsig): EXPORT.\n\t(dtoa_calcdecimal): EXPORT.\n\t(dtoa_calcsign): EXPORT.\n\t(dtoa_dtoa): EXPORT.\n\t(_M2_dtoa_init): M2EXPORT.\n\t(_M2_dtoa_fini): M2EXPORT.\n\t(_M2_dtoa_dep): M2EXPORT.\n\t(_M2_dtoa_ctor): M2EXPORT.\n\t* libm2pim/errno.cc (EXPORT): New define.\n\t(M2EXPORT): New define.\n\t(M2LIBNAME): New define.\n\t(errno_geterrno): EXPORT.\n\t(_M2_errno_init): M2EXPORT.\n\t(_M2_errno_fini): M2EXPORT.\n\t(_M2_errno_dep): M2EXPORT.\n\t(_M2_errno_ctor): M2EXPORT.\n\t* libm2pim/ldtoa.cc (EXPORT): New define.\n\t(IMPORT): New define.\n\t(M2EXPORT): New define.\n\t(M2LIBNAME): New define.\n\t(dtoa_calcmaxsig): EXPORT.\n\t(dtoa_calcdecimal): EXPORT.\n\t(dtoa_calcsign): EXPORT.\n\t(ldtoa_strtold): EXPORT.\n\t(ldtoa_ldtoa): EXPORT.\n\t(_M2_ldtoa_init): M2EXPORT.\n\t(_M2_ldtoa_fini): M2EXPORT.\n\t(_M2_ldtoa_dep): M2EXPORT.\n\t(_M2_ldtoa_ctor): M2EXPORT.\n\t* libm2pim/sckt.cc (EXPORT): New define.\n\t(M2EXPORT): New define.\n\t(M2LIBNAME): New define.\n\t(tcpServerEstablishPort): EXPORT.\n\t(tcpServerEstablish): EXPORT.\n\t(tcpServerAccept): EXPORT.\n\t(tcpServerPortNo): EXPORT.\n\t(tcpServerSocketFd): EXPORT.\n\t(getLocalIP): EXPORT.\n\t(tcpServerIP): EXPORT.\n\t(tcpServerClientIP): EXPORT.\n\t(tcpServerClientPortNo): EXPORT.\n\t(tcpClientSocket): EXPORT.\n\t(tcpClientSocketIP): EXPORT.\n\t(tcpClientConnect): EXPORT.\n\t(tcpClientPortNo): EXPORT.\n\t(tcpClientSocketFd): EXPORT.\n\t(tcpClientIP): EXPORT.\n\t(_M2_sckt_init): M2EXPORT.\n\t(_M2_sckt_finish): M2EXPORT.\n\t(_M2_sckt_dep): M2EXPORT.\n\t(_M2_sckt_ctor): M2EXPORT.\n\t* libm2pim/termios.cc (EXPORT): New define.\n\t(M2EXPORT): New define.\n\t(M2LIBNAME): New define.\n\t(_M2_termios_init): M2EXPORT.\n\t(_M2_termios_fini): M2EXPORT.\n\t(_M2_termios_dep): M2EXPORT.\n\t(_M2_termios_ctor): M2EXPORT.\n\t* libm2pim/wrapc.c (EXPORT): New define.\n\t(M2EXPORT): New define.\n\t(M2LIBNAME): New define.\n\t(wrapc_strtime): EXPORT.\n\t(wrapc_filesize): EXPORT.\n\t(wrapc_filemtime): EXPORT.\n\t(wrapc_fileinode): EXPORT.\n\t(wrapc_getrand): EXPORT.\n\t(wrapc_getusername): EXPORT.\n\t(wrapc_getnameuidgid): EXPORT.\n\t(wrapc_signbit): EXPORT.\n\t(wrapc_signbitl): EXPORT.\n\t(wrapc_signbitf): EXPORT.\n\t(wrapc_isfinite): EXPORT.\n\t(wrapc_isfinitel): EXPORT.\n\t(wrapc_isfinitef): EXPORT.\n\t(_M2_wrapc_init): M2EXPORT.\n\t(_M2_wrapc_fini): M2EXPORT.\n\t(_M2_wrapc_ctor): M2EXPORT.\n\ngcc/testsuite/ChangeLog:\n\n\tPR modula2/108261\n\t* gm2/examples/callingC/pass/examples-callingC-pass.exp: Tidy up\n\tvariable access.\n\t* gm2/examples/callingC/run/pass/examples-callingC-run-pass.exp: Tidy up\n\tvariable access.\n\t* gm2/examples/cpp/pass/examples-cpp-pass.exp: Tidy up\n\tvariable access.\n\t* gm2/examples/cppDef/pass/examples-cppDef-pass.exp: Tidy up\n\tvariable access.\n\t* gm2/examples/hello/pass/examples-hello-pass.exp: Tidy up\n\tvariable access.\n\t* gm2/examples/map/pass/examples-map-pass.exp: Tidy up\n\tvariable access.\n\t* gm2/iso/check/fail/iso-check-fail.exp: Add pathname.\n\t* gm2/link/externalscaffold/pass/link-externalscaffold-pass.exp:\n\tAdd pathname.\n\t* gm2/link/externalscaffold/pass/scaffold.c: Add mangled export name.\n\t* gm2/pimlib/base/run/pass/FIO.mod: Updated test code.\n\t* gm2/pimlib/base/run/pass/StrLib.mod: Updated test code.\n\t* gm2/pimlib/base/run/pass/pimlib-base-run-pass.exp: Remove path.\n\t* gm2/projects/pim/run/pass/random/projects-pim-run-pass-random.exp:\n\tTidy up variable access.\n\t* gm2/switches/auto-init/fail/switches-auto-init-fail.exp: Add pathname.\n\t* gm2/switches/check-all/pim2/fail/switches-check-all-pim2-fail.exp:\n\tAdd pathname.\n\t* gm2/switches/makeall/fail/switches-makeall-fail.exp: Remove -fmakeall.\n\t* gm2/switches/makeall/pass/switches-makeall-pass.exp: Remove -fmakeall.\n\t* lib/gm2-simple.exp (gm2_keep_executable): New global variable.\n\t(gm2_simple_execute): Keep executable if global is true.\n\t* lib/gm2-torture.exp: Add ; after global variable access.\n\t* lib/gm2.exp: Set up pathnames.\n\t* gm2/projects/pim/run/pass/tower/AdvCmd.def: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvCmd.mod: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvIntroduction.def: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvIntroduction.mod: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvMap.def: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvMap.mod: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvMath.def: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvMath.mod: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvParse.bnf: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvParse.def: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvParse.mod: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvSound.def: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvSound.mod: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvSystem.def: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvSystem.mod: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvTreasure.def: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvTreasure.mod: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvUtil.def: New test.\n\t* gm2/projects/pim/run/pass/tower/AdvUtil.mod: New test.\n\t* gm2/projects/pim/run/pass/tower/DrawG.def: New test.\n\t* gm2/projects/pim/run/pass/tower/DrawG.mod: New test.\n\t* gm2/projects/pim/run/pass/tower/DrawL.def: New test.\n\t* gm2/projects/pim/run/pass/tower/DrawL.mod: New test.\n\t* gm2/projects/pim/run/pass/tower/Dungeon.mod: New test.\n\t* gm2/projects/pim/run/pass/tower/Lock.def: New test.\n\t* gm2/projects/pim/run/pass/tower/Lock.mod: New test.\n\t* gm2/projects/pim/run/pass/tower/ProcArgs.def: New test.\n\t* gm2/projects/pim/run/pass/tower/ProcArgs.mod: New test.\n\t* gm2/projects/pim/run/pass/tower/Screen.def: New test.\n\t* gm2/projects/pim/run/pass/tower/Screen.mod: New test.\n\t* gm2/projects/pim/run/pass/tower/SocketControl.c: New test.\n\t* gm2/projects/pim/run/pass/tower/SocketControl.def: New test.\n\t* gm2/projects/pim/run/pass/tower/Window.def: New test.\n\t* gm2/projects/pim/run/pass/tower/Window.mod: New test.\n\t* gm2/projects/pim/run/pass/tower/adv.flex: New test.\n\t* gm2/projects/pim/run/pass/tower/advflex.c: New test.\n\t* gm2/projects/pim/run/pass/tower/advflex.def: New test.\n\t* gm2/projects/pim/run/pass/tower/projects-pim-run-pass-tower.exp:\n\tNew test.\n\t* gm2/projects/pim/run/pass/tower/star: New test.\n\nSigned-off-by: Gaius Mulley <gaiusmod2@gmail.com>", "tree": {"sha": "37d3bf0f0a89774a4733b706ddaf3cff5447b182", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37d3bf0f0a89774a4733b706ddaf3cff5447b182"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/comments", "author": null, "committer": null, "parents": [{"sha": "461d3c84a0e5ad045ee54631901cc953d6befa20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/461d3c84a0e5ad045ee54631901cc953d6befa20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/461d3c84a0e5ad045ee54631901cc953d6befa20"}], "stats": {"total": 16773, "additions": 14335, "deletions": 2438}, "files": [{"sha": "07729f84e7b5500b53f1e2d98e737ec471b82c21", "filename": "gcc/doc/gm2.texi", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fdoc%2Fgm2.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fdoc%2Fgm2.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgm2.texi?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -484,9 +484,21 @@ where multiple @code{END} keywords are mapped onto a sequence of\n @item -fm2-lower-case\n render keywords in error messages using lower case.\n \n+@item -fm2-pathname=\n+specify the module mangled prefix name for all modules in the\n+following include paths.\n+\n+@item -fm2-pathnameI\n+for internal use only: used by the driver to copy the user facing -I\n+option.\n+\n @item -fm2-plugin\n insert plugin to identify run time errors at compile time (default on).\n \n+@item -fm2-prefix=\n+specify the module mangled prefix name.  All exported symbols from a\n+definition module will have the prefix name.\n+\n @item -fm2-statistics\n generates quadruple information: number of quadruples generated,\n number of quadruples remaining after optimization and number of source\n@@ -567,12 +579,13 @@ via @samp{-fno-return}.\n @item -fruntime-modules=\n specify, using a comma separated list, the run time modules and their\n order.  These modules will initialized first before any other modules\n-in the application dependency.  By default the run time modules list is\n-set to @code{Storage,SYSTEM,M2RTS,RTExceptions,IOLink}.  Note that\n-these modules will only be linked into your executable if they are\n-required.  So adding a long list of dependent modules will not effect\n-the size of the executable it merely states the initialization order\n-should they be required.\n+in the application dependency.  By default the run time modules list\n+is set to @code{m2iso:RTentity,m2iso:Storage,m2iso:SYSTEM,}\n+@code{m2iso:M2RTS,m2iso:RTExceptions,m2iso:IOLink}.  Note that these\n+modules will only be linked into your executable if they are required.\n+Adding a long list of dependent modules will not effect the size of\n+the executable it merely states the initialization order should they\n+be required.\n \n @item -fscaffold-dynamic\n the option ensures that @samp{gm2} will generate a dynamic scaffold\n@@ -740,6 +753,8 @@ value   | meaning\n =================\n all     | turn on all flags below\n module  | trace modules as they register themselves\n+hex     | display the hex address of the init/fini functions\n+warning | show any warnings\n pre     | generate module list prior to dependency resolution\n dep     | trace module dependency resolution\n post    | generate module list after dependency resolution"}, {"sha": "92a413b86be00e777a687ab47061236c78cbef1e", "filename": "gcc/m2/Make-lang.in", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2FMake-lang.in?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -714,7 +714,8 @@ GM2-COMP-BOOT-DEFS = \\\n    M2DebugStack.def \\\n    M2Defaults.def \\\n    M2DriverOptions.def \\\n-   DynamicStringPath.def \\\n+   DynamicPath.def \\\n+   PathName.def \\\n    M2Emit.def \\\n    M2Error.def \\\n    M2EvalSym.def \\\n@@ -786,7 +787,8 @@ GM2-COMP-BOOT-MODS = \\\n    M2DebugStack.mod \\\n    M2Defaults.mod \\\n    M2DriverOptions.mod \\\n-   DynamicStringPath.mod \\\n+   DynamicPath.mod \\\n+   PathName.mod \\\n    M2Emit.mod \\\n    M2Error.mod \\\n    M2FileName.mod \\\n@@ -991,7 +993,8 @@ GM2-COMP-DEFS = \\\n    M2DebugStack.def \\\n    M2Defaults.def \\\n    M2DriverOptions.def \\\n-   DynamicStringPath.def \\\n+   DynamicPath.def \\\n+   PathName.def \\\n    M2Emit.def \\\n    M2Error.def \\\n    M2FileName.def \\\n@@ -1059,7 +1062,8 @@ GM2-COMP-MODS = \\\n    M2DebugStack.mod \\\n    M2Defaults.mod \\\n    M2DriverOptions.mod \\\n-   DynamicStringPath.mod \\\n+   DynamicPath.mod \\\n+   PathName.mod \\\n    M2Emit.mod \\\n    M2Error.mod \\\n    M2FileName.mod \\"}, {"sha": "f6b12ac59f60b71220d0234f73b8e3ae1ca6cc2e", "filename": "gcc/m2/Make-maintainer.in", "status": "modified", "additions": 79, "deletions": 18, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2FMake-maintainer.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2FMake-maintainer.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2FMake-maintainer.in?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -95,26 +95,30 @@ BUILD-PPG-LIBS-H = $(PPG-LIB-DEFS:%.def=m2/gm2-ppg-boot/$(SRC_PREFIX)%.h)\n \n BUILD-PPG-H = m2/boot-bin/mc$(exeext) $(BUILD-PPG-LIBS-H)\n \n+BUILD-BOOT-PPG-H: $(BUILD-BOOT-H) \\\n+                 m2/gm2-ppg-boot/$(SRC_PREFIX)M2RTS.h \\\n+                 m2/gm2-ppg-boot/$(SRC_PREFIX)M2Dependent.h\n+\n m2/gm2-ppg-boot/$(SRC_PREFIX)%.h: $(srcdir)/m2/gm2-libs/%.def $(MCDEPS)\n \t-test -d m2/gm2-ppg-boot || $(mkinstalldirs) m2/gm2-ppg-boot\n \t$(MCC) -o=$@ $(srcdir)/m2/gm2-libs/$*.def\n \n-m2/gm2-ppg-boot/$(SRC_PREFIX)%.o: m2/mc-boot-ch/$(SRC_PREFIX)%.c m2/gm2-libs/gm2-libs-host.h\n+m2/gm2-ppg-boot/$(SRC_PREFIX)%.o: m2/mc-boot-ch/$(SRC_PREFIX)%.c m2/gm2-libs/gm2-libs-host.h $(BUILD-BOOT-PPG-H)\n \t-test -d m2/gm2-ppg-boot || $(mkinstalldirs) m2/gm2-ppg-boot\n \t$(CXX) -I. -I$(srcdir)/../include -I$(srcdir) -I$(srcdir)/m2/mc-boot-ch -Im2/gm2-libs $(INCLUDES) -g -c $< -o $@\n \n-m2/gm2-ppg-boot/$(SRC_PREFIX)%.o: m2/mc-boot-ch/$(SRC_PREFIX)%.cc m2/gm2-libs/gm2-libs-host.h\n+m2/gm2-ppg-boot/$(SRC_PREFIX)%.o: m2/mc-boot-ch/$(SRC_PREFIX)%.cc m2/gm2-libs/gm2-libs-host.h $(BUILD-BOOT-PPG-H)\n \t-test -d m2/gm2-ppg-boot || $(mkinstalldirs) m2/gm2-ppg-boot\n \t$(CXX) -I. -I$(srcdir)/../include -I$(srcdir) -I$(srcdir)/m2/mc-boot-ch -Im2/gm2-libs $(INCLUDES) -g -c $< -o $@\n \n-m2/gm2-ppg-boot/$(SRC_PREFIX)%.o: $(srcdir)/m2/gm2-libs/%.mod $(MCDEPS) $(BUILD-BOOT-H)\n+m2/gm2-ppg-boot/$(SRC_PREFIX)%.o: $(srcdir)/m2/gm2-libs/%.mod $(MCDEPS) $(BUILD-BOOT-PPG-H)\n \t-test -d m2/gm2-ppg-boot || $(mkinstalldirs) m2/gm2-ppg-boot\n \t$(MCC) -o=m2/gm2-ppg-boot/$(SRC_PREFIX)$*.c $(srcdir)/m2/gm2-libs/$*.mod\n \t$(CXX) -I. -I$(srcdir)/../include -I$(srcdir) \\\n               -Im2/gm2-ppg-boot -I$(srcdir)/m2/mc-boot -Im2/gm2-libs-boot \\\n               -I$(srcdir)/m2/mc-boot-ch $(INCLUDES) -g -c m2/gm2-ppg-boot/$(SRC_PREFIX)$*.c -o $@\n \n-m2/gm2-ppg-boot/$(SRC_PREFIX)%.o: $(srcdir)/m2/gm2-compiler/%.mod $(MCDEPS) $(BUILD-BOOT-H)\n+m2/gm2-ppg-boot/$(SRC_PREFIX)%.o: $(srcdir)/m2/gm2-compiler/%.mod $(MCDEPS) $(BUILD-BOOT-PPG-H)\n \t-test -d m2/gm2-ppg-boot || $(mkinstalldirs) m2/gm2-ppg-boot\n \t$(MCC) -o=m2/gm2-ppg-boot/$(SRC_PREFIX)$*.c $(srcdir)/m2/gm2-compiler/$*.mod\n \t$(CXX) -I. -I$(srcdir)/../include -I$(srcdir) \\\n@@ -142,40 +146,89 @@ m2/gm2-auto:\n # without error recovery\n \n PG-SRC = pg.mod\n+PGE-DEF = ASCII.def \\\n+   Args.def \\\n+   Assertion.def \\\n+   Break.def  \\\n+   COROUTINES.def \\\n+   CmdArgs.def \\\n+   Debug.def \\\n+   DynamicStrings.def \\\n+   Environment.def \\\n+   FIO.def \\\n+   FormatStrings.def \\\n+   FpuIO.def \\\n+   IO.def \\\n+   M2Dependent.def \\\n+   M2EXCEPTION.def \\\n+   M2LINK.def \\\n+   M2RTS.def \\\n+   MemUtils.def \\\n+   NumberIO.def \\\n+   PushBackInput.def \\\n+   RTExceptions.def \\\n+   RTco.def \\\n+   RTentity.def \\\n+   RTint.def \\\n+   SArgs.def \\\n+   SFIO.def \\\n+   SYSTEM.def \\\n+   Selective.def \\\n+   StdIO.def \\\n+   Storage.def \\\n+   StrCase.def \\\n+   StrIO.def \\\n+   StrLib.def \\\n+   StringConvert.def \\\n+   SysExceptions.def \\\n+   SysStorage.def \\\n+   TimeString.def \\\n+   UnixArgs.def \\\n+   dtoa.def \\\n+   errno.def \\\n+   ldtoa.def \\\n+   libc.def \\\n+   libm.def \\\n+   termios.def \\\n+   wrapc.def \\\n \n BUILD-PG-O = $(PPG-INTERFACE-C:%.c=m2/gm2-pg-boot/$(SRC_PREFIX)%.o) \\\n              $(PPG-INTERFACE-CC:%.cc=m2/gm2-pg-boot/$(SRC_PREFIX)%.o) \\\n              $(PPG-MODS:%.mod=m2/gm2-pg-boot/$(SRC_PREFIX)%.o) \\\n              $(PPG-LIB-MODS:%.mod=m2/gm2-pg-boot/$(SRC_PREFIX)%.o) \\\n              $(PG-SRC:%.mod=m2/gm2-pg-boot/$(SRC_PREFIX)%.o)\n \n+BUILD-BOOT-PG-H: $(BUILD-BOOT-H) \\\n+                 m2/gm2-pg-boot/$(SRC_PREFIX)M2RTS.h \\\n+                 m2/gm2-pg-boot/$(SRC_PREFIX)M2Dependent.h\n+\n m2/gm2-pg-boot/$(SRC_PREFIX)%.h: $(srcdir)/m2/gm2-libs/%.def $(MCDEPS)\n \t-test -d m2/gm2-pg-boot || $(mkinstalldirs) m2/gm2-pg-boot\n \t$(MCC) -o=$@ $(srcdir)/m2/gm2-libs/$*.def\n \n-m2/gm2-pg-boot/$(SRC_PREFIX)%.o: m2/mc-boot-ch/$(SRC_PREFIX)%.c m2/gm2-libs/gm2-libs-host.h\n+m2/gm2-pg-boot/$(SRC_PREFIX)%.o: m2/mc-boot-ch/$(SRC_PREFIX)%.c m2/gm2-libs/gm2-libs-host.h $(BUILD-BOOT-PG-H)\n \t-test -d m2/gm2-pg-boot || $(mkinstalldirs) m2/gm2-pg-boot\n \t$(CXX) -I. -I$(srcdir)/../include -I$(srcdir) -I$(srcdir)/m2/mc-boot-ch -Im2/gm2-libs $(INCLUDES) -g -c $< -o $@\n \n-m2/gm2-pg-boot/$(SRC_PREFIX)%.o: m2/mc-boot-ch/$(SRC_PREFIX)%.cc m2/gm2-libs/gm2-libs-host.h\n+m2/gm2-pg-boot/$(SRC_PREFIX)%.o: m2/mc-boot-ch/$(SRC_PREFIX)%.cc m2/gm2-libs/gm2-libs-host.h $(BUILD-BOOT-PG-H)\n \t-test -d m2/gm2-pg-boot || $(mkinstalldirs) m2/gm2-pg-boot\n \t$(CXX) -I. -I$(srcdir)/../include -I$(srcdir) -I$(srcdir)/m2/mc-boot-ch -Im2/gm2-libs $(INCLUDES) -g -c $< -o $@\n \n-m2/gm2-pg-boot/$(SRC_PREFIX)%.o: $(srcdir)/m2/gm2-libs/%.mod $(MCDEPS) $(BUILD-BOOT-H)\n+m2/gm2-pg-boot/$(SRC_PREFIX)%.o: $(srcdir)/m2/gm2-libs/%.mod $(MCDEPS) $(BUILD-BOOT-PG-H)\n \t-test -d m2/gm2-pg-boot || $(mkinstalldirs) m2/gm2-pg-boot\n \t$(MCC) -o=m2/gm2-pg-boot/$(SRC_PREFIX)$*.c $(srcdir)/m2/gm2-libs/$*.mod\n \t$(CXX) -I. -I$(srcdir)/../include -I$(srcdir) -Im2/gm2-pg-boot\t-I$(srcdir)/m2/mc-boot \\\n                -I$(srcdir)/m2/mc-boot-ch \\\n                -Im2/gm2-libs-boot $(INCLUDES) \\\n               -g -c m2/gm2-pg-boot/$(SRC_PREFIX)$*.c -o $@\n \n-m2/gm2-pg-boot/$(SRC_PREFIX)%.o: $(srcdir)/m2/gm2-compiler/%.mod $(MCDEPS) $(BUILD-BOOT-H)\n+m2/gm2-pg-boot/$(SRC_PREFIX)%.o: $(srcdir)/m2/gm2-compiler/%.mod $(MCDEPS) $(BUILD-BOOT-PG-H)\n \t-test -d m2/gm2-pg-boot || $(mkinstalldirs) m2/gm2-pg-boot\n \t$(MCC) -o=m2/gm2-pg-boot/$(SRC_PREFIX)$*.c $(srcdir)/m2/gm2-compiler/$*.mod\n \t$(CXX) -I. -I$(srcdir)/../include -I$(srcdir) -Im2/mc-boot -Im2/gm2-compiler-boot -Im2/gm2-libs-boot \\\n               -I$(srcdir)/m2/mc-boot-ch $(INCLUDES) -g -c m2/gm2-pg-boot/$(SRC_PREFIX)$*.c -o $@\n \n-m2/gm2-pg-boot/$(SRC_PREFIX)pg.o:  m2/gm2-auto/pg.mod $(MCDEPS) $(BUILD-BOOT-H)\n+m2/gm2-pg-boot/$(SRC_PREFIX)pg.o:  m2/gm2-auto/pg.mod $(MCDEPS) $(BUILD-BOOT-PG-H)\n \t-test -d m2/gm2-pg-boot || $(mkinstalldirs) m2/gm2-pg-boot\n \t$(MCC) -o=m2/gm2-pg-boot/$(SRC_PREFIX)pg.c m2/gm2-auto/pg.mod\n \t$(CXX) -I. -I$(srcdir)/../include -I$(srcdir) -Im2/mc-boot -Im2/gm2-compiler-boot -Im2/gm2-libs-boot \\\n@@ -227,6 +280,9 @@ BUILD-PGE-O = $(PPG-INTERFACE-C:%.c=m2/gm2-pge-boot/$(SRC_PREFIX)%.o) \\\n               $(PPG-LIB-MODS:%.mod=m2/gm2-pge-boot/$(SRC_PREFIX)%.o) \\\n               $(PGE-SRC:%.mod=m2/gm2-pge-boot/$(SRC_PREFIX)%.o)\n \n+BUILD-BOOT-PGE-H: $(BUILD-BOOT-H) $(PGE-DEF:%.def=m2/gm2-pge-boot/$(SRC_PREFIX)%.h) \\\n+                  m2/gm2-pge-boot/GM2RTS.h m2/gm2-pge-boot/GM2Dependent.h\n+\n m2/gm2-auto/pge.mod: m2/pg$(exeext)\n \t-test -d m2/gm2-auto || $(mkinstalldirs) m2/gm2-auto\n \t$(SHELL) $(srcdir)/m2/tools-src/buildpg $(srcdir)/m2/gm2-compiler/ppg.mod pge > m2/gm2-auto/pge.bnf\n@@ -272,29 +328,29 @@ m2/gm2-pge-boot/$(SRC_PREFIX)wrapc.o:  $(srcdir)/m2/mc-boot-ch/Gwrapc.c m2/gm2-l\n \t-test -d m2/gm2-pge-boot || $(mkinstalldirs) m2/gm2-pge-boot\n \t$(CXX) -I. -I$(srcdir)/../include -I$(srcdir) -I$(srcdir)/m2/mc-boot-ch -Im2/gm2-libs $(INCLUDES) -g -c $< -o $@\n \n-m2/gm2-pge-boot/$(SRC_PREFIX)SYSTEM.o:  $(srcdir)/m2/mc-boot-ch/GSYSTEM.c\n+m2/gm2-pge-boot/$(SRC_PREFIX)SYSTEM.o:  $(srcdir)/m2/mc-boot-ch/GSYSTEM.c $(BUILD-BOOT-PGE-H)\n \t-test -d m2/gm2-pge-boot || $(mkinstalldirs) m2/gm2-pge-boot\n \t$(CXX) -I. -I$(srcdir)/../include -I$(srcdir) -I$(srcdir)/m2/mc-boot-ch $(INCLUDES) -g -c $< -o $@\n \n m2/gm2-pge-boot/$(SRC_PREFIX)errno.o:  $(srcdir)/m2/mc-boot-ch/Gerrno.c\n \t-test -d m2/gm2-pge-boot || $(mkinstalldirs) m2/gm2-pge-boot\n \t$(CXX) -I. -I$(srcdir)/../include -I$(srcdir) -I$(srcdir)/m2/mc-boot-ch $(INCLUDES) -g -c $< -o $@\n \n-m2/gm2-pge-boot/$(SRC_PREFIX)%.o: $(srcdir)/m2/gm2-libs/%.mod $(MCDEPS) $(BUILD-BOOT-H)\n+m2/gm2-pge-boot/$(SRC_PREFIX)%.o: $(srcdir)/m2/gm2-libs/%.mod $(MCDEPS) $(BUILD-BOOT-PGE-H)\n \t-test -d m2/gm2-pge-boot || $(mkinstalldirs) m2/gm2-pge-boot\n \t$(MCC) -o=m2/gm2-pge-boot/$(SRC_PREFIX)$*.c $(srcdir)/m2/gm2-libs/$*.mod\n \t$(CXX) -I. -I$(srcdir)/../include -I$(srcdir) -Im2/gm2-pge-boot -I$(srcdir)/m2/mc-boot \\\n               -I$(srcdir)/m2/mc-boot-ch -Im2/gm2-libs-boot \\\n               $(INCLUDES) -g -c m2/gm2-pge-boot/$(SRC_PREFIX)$*.c -o $@\n \n-m2/gm2-pge-boot/$(SRC_PREFIX)%.o: $(srcdir)/m2/gm2-compiler/%.mod $(MCDEPS) $(BUILD-BOOT-H)\n+m2/gm2-pge-boot/$(SRC_PREFIX)%.o: $(srcdir)/m2/gm2-compiler/%.mod $(MCDEPS) $(BUILD-BOOT-PGE-H)\n \t-test -d m2/gm2-pge-boot || $(mkinstalldirs) m2/gm2-pge-boot\n \t$(MCC) -o=m2/gm2-pge-boot/$(SRC_PREFIX)$*.c $(srcdir)/m2/gm2-compiler/$*.mod\n \t$(CXX) -I. -I$(srcdir)/../include -I$(srcdir) -Im2/mc-boot -Im2/gm2-compiler-boot \\\n               -Im2/gm2-libs-boot \\\n               -I$(srcdir)/m2/mc-boot-ch $(INCLUDES) -g -c m2/gm2-pge-boot/$(SRC_PREFIX)$*.c -o $@\n \n-m2/gm2-pge-boot/$(SRC_PREFIX)pge.o:  m2/gm2-auto/pge.mod $(MCDEPS) $(BUILD-BOOT-H)\n+m2/gm2-pge-boot/$(SRC_PREFIX)pge.o:  m2/gm2-auto/pge.mod $(MCDEPS) $(BUILD-BOOT-PGE-H)\n \t-test -d m2/gm2-pge-boot || $(mkinstalldirs) m2/gm2-pge-boot\n \t$(MCC) -o=m2/gm2-pge-boot/$(SRC_PREFIX)pge.c m2/gm2-auto/pge.mod\n \t$(CXX) -I. -I$(srcdir)/../include -I$(srcdir) \\\n@@ -409,8 +465,11 @@ MCLINK=-g     # use -g -fmodules -c if you are debugging and wish to see missing\n # This is only needed in maintainer mode by 'make mc-maintainer' when regenerating the C\n # version of mc.  We need a working Modula-2 compiler to run mc-maintainer.\n \n-GM2SYS=${HOME}/opt/lib/gcc/x86_64-pc-linux-gnu/12.0.0/m2/m2pim\n-GM2PATH=-I$(srcdir)/m2/mc -I$(GM2SYS) -I$(srcdir)/m2 -Im2/gm2-auto -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-libs-iso\n+# GM2SYS=${HOME}/opt/lib/gcc/x86_64-pc-linux-gnu/13.0.0/m2/m2pim\n+GM2PATH=-I$(srcdir)/m2/mc \\\n+        -I$(srcdir)/m2 -Im2/gm2-auto \\\n+        -fm2-pathname=m2pim -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/gm2-libs-ch \\\n+        -fm2-pathname=m2iso -I$(srcdir)/m2/gm2-libs-iso -fm2-pathname=-\n \n mc: mc-clean mc-devel\n \n@@ -479,7 +538,8 @@ m2/boot-bin/mc-devel$(exeext): m2/mc-obj/mcp1.mod \\\n                                m2/mc-obj/mcp4.mod \\\n                                m2/mc-obj/mcp5.mod \\\n                                mcflex.c \\\n-                               m2/mc-boot-ch/Gabort.o\n+                               m2/mc-boot-ch/Gabort.o \\\n+                               m2/mc-boot-ch/Gm2rtsdummy.o\n \t$(RM) -rf mc-obj\n \t$(mkinstalldirs) mc-obj\n \t$(CC) -I$(srcdir)/m2/mc -c -g mcflex.c -o mc-obj/mcflex.o\n@@ -515,7 +575,8 @@ m2/boot-bin/mc-devel$(exeext): m2/mc-obj/mcp1.mod \\\n \t$(BOOTGM2) $(MCLINK) -I. -fscaffold-static -fscaffold-main $(GM2PATH) \\\n             -fuse-list=$(srcdir)/m2/init/mcinit $(srcdir)/m2/mc/top.mod -o mc \\\n             m2/gm2-libs-boot/RTcodummy.o \\\n-            m2/gm2-libs-boot/dtoa.o m2/gm2-libs-boot/ldtoa.o mc-obj/*o m2/mc-boot-ch/Gabort.o\n+            m2/gm2-libs-boot/dtoa.o m2/gm2-libs-boot/ldtoa.o mc-obj/*o \\\n+            m2/mc-boot-ch/Gabort.o m2/mc-boot-ch/Gm2rtsdummy.o\n \n m2/boot-bin/mc-opt$(exeext): m2/mc-obj/mcp1.mod \\\n                              m2/mc-obj/mcp2.mod \\\n@@ -525,7 +586,7 @@ m2/boot-bin/mc-opt$(exeext): m2/mc-obj/mcp1.mod \\\n                              mcflex.c\n \t-test -d m2/boot-bin || $(mkinstalldirs) m2/boot-bin\n \tg++ -I$(srcdir)/m2/mc -c -g mcflex.c\n-\t$(BOOTGM2) -fsources -fm2-whole-program -g -I$(srcdir)/m2/mc:$(objdir)/m2/mc-obj -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/mc $(srcdir)/m2/mc/top.mod\n+\t$(BOOTGM2) -fsources -fm2-whole-program -g -I$(srcdir)/m2/mc -I$(objdir)/m2/mc-obj -I$(srcdir)/m2/gm2-libs -I$(srcdir)/m2/mc $(srcdir)/m2/mc/top.mod\n \n m2/mc/decl.o:  $(srcdir)/m2/mc/decl.mod\n \t-test -d m2/mc || $(mkinstalldirs) m2/mc"}, {"sha": "f3bc85adacaee3158ba3bb2805a7a3c4623eebd3", "filename": "gcc/m2/gm2-compiler/DynamicPath.def", "status": "renamed", "additions": 10, "deletions": 35, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FDynamicPath.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FDynamicPath.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FDynamicPath.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -1,4 +1,4 @@\n-(* DynamicStringPath.def implements a path for DynamicStrings.\n+(* DynamicPath.def implements a path for DynamicStrings.\n \n Copyright (C) 2001-2023 Free Software Foundation, Inc.\n Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n@@ -24,42 +24,14 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  *)\n \n-DEFINITION MODULE DynamicStringPath ;  (*!m2iso+gm2*)\n+DEFINITION MODULE DynamicPath ;  (*!m2iso+gm2*)\n \n FROM DynamicStrings IMPORT String ;\n \n TYPE\n    PathList ;\n \n \n-(*\n-   GetUserPath - returns the current UserPath.\n-*)\n-\n-PROCEDURE GetUserPath () : PathList ;\n-\n-\n-(*\n-   GetSystemPath - returns the current SystemPath.\n-*)\n-\n-PROCEDURE GetSystemPath () : PathList ;\n-\n-\n-(*\n-   SetUserPath - assigns UserPath to pl.\n-*)\n-\n-PROCEDURE SetUserPath (pl: PathList) ;\n-\n-\n-(*\n-   SetSystemPath - assigns SystemPath to pl.\n-*)\n-\n-PROCEDURE SetSystemPath (pl: PathList) ;\n-\n-\n (*\n    InitPathList - creates a new empty path list.\n *)\n@@ -86,10 +58,6 @@ PROCEDURE Cons (pl: PathList; str: String) : PathList ;\n \n (*\n    ConsList - concatenates path list left and right together.\n-              It always returns NIL which should be assigned\n-              to the callers right parameter after ConsList\n-              has been completed signifying that right should\n-              no longer be accessed.\n *)\n \n PROCEDURE ConsList (left, right: PathList) : PathList ;\n@@ -110,4 +78,11 @@ PROCEDURE Stash (VAR pl: PathList) : PathList ;\n PROCEDURE FindFileName (filename: String; pl: PathList) : String ;\n \n \n-END DynamicStringPath.\n+(*\n+   DumpPath - debugging dump of the pathlist.\n+*)\n+\n+PROCEDURE DumpPath (name: String; pl: PathList) ;\n+\n+\n+END DynamicPath.", "previous_filename": "gcc/m2/gm2-compiler/DynamicStringPath.def"}, {"sha": "3eba52f5ffc6fba2698f246ad750bd2826cc81af", "filename": "gcc/m2/gm2-compiler/DynamicPath.mod", "status": "renamed", "additions": 14, "deletions": 68, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FDynamicPath.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FDynamicPath.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FDynamicPath.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -1,4 +1,4 @@\n-(* DynamicStringPath.def implements a path for DynamicStrings.\n+(* DynamicPath.mod implements a path for DynamicStrings.\n \n Copyright (C) 2001-2023 Free Software Foundation, Inc.\n Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n@@ -24,11 +24,11 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  *)\n \n-IMPLEMENTATION MODULE DynamicStringPath ;  (*!m2iso+gm2*)\n+IMPLEMENTATION MODULE DynamicPath ;  (*!m2iso+gm2*)\n \n FROM Storage IMPORT ALLOCATE, DEALLOCATE ;\n FROM DynamicStrings IMPORT InitString, ConCat, ConCatChar, char, Dup,\n-                           KillString, Length ;\n+                           KillString, Length, EqualArray ;\n FROM SFIO IMPORT Exists ;\n FROM FIO IMPORT StdErr ;\n FROM M2Printf IMPORT fprintf0, fprintf1 ;\n@@ -46,51 +46,7 @@ TYPE\n \n \n VAR\n-   FreeList,\n-   DefaultUserPath,\n-   DefaultSystemPath: PathList ;\n-\n-\n-(*\n-   GetUserPath - returns the current UserPath.\n-*)\n-\n-PROCEDURE GetUserPath () : PathList ;\n-BEGIN\n-   RETURN DefaultUserPath\n-END GetUserPath ;\n-\n-\n-(*\n-   GetSystemPath - returns the current SystemPath.\n-*)\n-\n-PROCEDURE GetSystemPath () : PathList ;\n-BEGIN\n-   RETURN DefaultSystemPath\n-END GetSystemPath ;\n-\n-\n-(*\n-   SetUserPath - assigns UserPath to pl.\n-*)\n-\n-PROCEDURE SetUserPath (pl: PathList) ;\n-BEGIN\n-   DefaultUserPath := pl ;\n-   DumpPath ('DefaultUserPath', DefaultUserPath)\n-END SetUserPath ;\n-\n-\n-(*\n-   SetSystemPath - assigns SystemPath to pl.\n-*)\n-\n-PROCEDURE SetSystemPath (pl: PathList) ;\n-BEGIN\n-   DefaultSystemPath := pl ;\n-   DumpPath ('DefaultSystemPath', DefaultSystemPath)\n-END SetSystemPath ;\n+   FreeList: PathList ;\n \n \n (*\n@@ -148,10 +104,6 @@ END Cons ;\n \n (*\n    ConsList - concatenates path list left and right together.\n-              It always returns NIL which should be assigned\n-              to the callers right parameter after ConsList\n-              has been completed signifying that right should\n-              no longer be accessed.\n *)\n \n PROCEDURE ConsList (left, right: PathList) : PathList ;\n@@ -241,25 +193,19 @@ END FindFileName ;\n    DumpPath - debugging dump of the pathlist.\n *)\n \n-PROCEDURE DumpPath (name: ARRAY OF CHAR; pl: PathList) ;\n+PROCEDURE DumpPath (name: String; pl: PathList) ;\n BEGIN\n-   IF Debugging\n-   THEN\n-      fprintf0 (StdErr, name) ;\n-      fprintf0 (StdErr, \":\") ;\n-      WHILE pl # NIL DO\n-         fprintf0 (StdErr, \" {\") ;\n-         fprintf1 (StdErr, \"%s\", pl^.entry) ;\n-         fprintf0 (StdErr, \"}\") ;\n-         pl := pl^.next\n-      END ;\n-      fprintf0 (StdErr, \"\\n\")\n-   END\n+   fprintf1 (StdErr, \"%s:\", name) ;\n+   WHILE pl # NIL DO\n+      fprintf0 (StdErr, \" {\") ;\n+      fprintf1 (StdErr, \"%s\", pl^.entry) ;\n+      fprintf0 (StdErr, \"}\") ;\n+      pl := pl^.next\n+   END ;\n+   fprintf0 (StdErr, \"\\n\")\n END DumpPath ;\n \n \n BEGIN\n-   DefaultSystemPath := NIL ;\n-   DefaultUserPath := NIL ;\n    FreeList := NIL\n-END DynamicStringPath.\n+END DynamicPath.", "previous_filename": "gcc/m2/gm2-compiler/DynamicStringPath.mod"}, {"sha": "85bbceba3ea51e5467ec7bfc8892d7fec494807d", "filename": "gcc/m2/gm2-compiler/M2AsmUtil.mod", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2AsmUtil.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2AsmUtil.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2AsmUtil.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -24,14 +24,15 @@ IMPLEMENTATION MODULE M2AsmUtil ;\n \n FROM SFIO IMPORT WriteS ;\n FROM FIO IMPORT StdOut ;\n-FROM DynamicStrings IMPORT String, string, ConCat, KillString, InitString, Mark, InitStringCharStar, ConCatChar ;\n+FROM DynamicStrings IMPORT String, string, ConCat, KillString, InitString, Mark, InitStringCharStar, ConCatChar, EqualArray ;\n FROM StdIO IMPORT Write ;\n FROM StrIO IMPORT WriteString ;\n-FROM NameKey IMPORT WriteKey, GetKey, MakeKey, makekey, KeyToCharStar ;\n+FROM NameKey IMPORT WriteKey, GetKey, MakeKey, makekey, KeyToCharStar, NulName ;\n FROM M2Options IMPORT WholeProgram ;\n+FROM M2Printf IMPORT printf1 ;\n \n FROM SymbolTable IMPORT NulSym,\n-                        GetSymName,\n+                        GetSymName, GetLibName,\n                         GetScope,\n                         GetBaseModule,\n                         IsInnerModule,\n@@ -47,6 +48,10 @@ FROM M2Error IMPORT InternalError ;\n FROM m2configure IMPORT UseUnderscoreForC ;\n \n \n+CONST\n+   Debugging = FALSE ;\n+\n+\n (*\n    StringToKey - returns a Name, from a string and destroys the string.\n *)\n@@ -97,16 +102,45 @@ END GetFullScopeAsmName ;\n \n PROCEDURE GetFullSymName (sym: CARDINAL) : Name ;\n VAR\n-   module: String ;\n-   scope : CARDINAL ;\n+   libname,\n+   fullsymname,\n+   module     : String ;\n+   scope      : CARDINAL ;\n BEGIN\n    IF IsProcedure (sym) AND IsMonoName (sym)\n    THEN\n       RETURN GetSymName (sym)\n    ELSE\n       scope := GetScope (sym) ;\n       module := GetModulePrefix (InitString (''), sym, scope) ;\n-      RETURN StringToKey (ConCat (module, InitStringCharStar (KeyToCharStar (GetSymName (sym)))))\n+      fullsymname := ConCat (module, InitStringCharStar (KeyToCharStar (GetSymName (sym)))) ;\n+      IF (IsVar (sym) OR IsProcedure (sym)) AND IsExportQualified (sym)\n+      THEN\n+         WHILE NOT IsDefImp (scope) DO\n+            scope := GetScope (scope)\n+         END ;\n+         IF GetLibName (scope) # NulName\n+         THEN\n+            IF Debugging\n+            THEN\n+               printf1 (\"before sym = %s  , \", fullsymname)\n+            END ;\n+            libname := InitStringCharStar (KeyToCharStar (GetLibName (scope))) ;\n+            IF NOT EqualArray (libname, '')\n+            THEN\n+               IF Debugging\n+               THEN\n+                  printf1 (\"libname = %s  , \", libname)\n+               END ;\n+               fullsymname := ConCat (ConCatChar (libname, '_'), fullsymname) ;\n+            END ;\n+            IF Debugging\n+            THEN\n+               printf1 (\"after sym = %s\\n\", fullsymname)\n+            END\n+         END\n+      END ;\n+      RETURN StringToKey (fullsymname)\n    END\n END GetFullSymName ;\n "}, {"sha": "a2a7797397d16d146ceea6fb1fc93f3df24003fd", "filename": "gcc/m2/gm2-compiler/M2Comp.mod", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2Comp.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2Comp.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Comp.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -59,14 +59,17 @@ FROM M2Batch IMPORT GetSource, GetModuleNo, GetDefinitionModuleFile, GetModuleFi\n FROM SymbolTable IMPORT GetSymName, IsDefImp, NulSym,\n                         IsHiddenTypeDeclared, GetFirstUsed, GetMainModule, SetMainModule,\n                         ResolveConstructorTypes, SanityCheckConstants, IsDefinitionForC,\n-                        IsBuiltinInModule, PutModLink, IsDefLink, IsModLink ;\n+                        IsBuiltinInModule, PutModLink, IsDefLink, IsModLink,\n+                        PutLibName ;\n \n FROM FIO IMPORT StdErr, StdOut ;\n FROM NameKey IMPORT Name, GetKey, KeyToCharStar, makekey ;\n FROM M2Printf IMPORT fprintf1 ;\n FROM M2Quiet IMPORT qprintf0, qprintf1, qprintf2 ;\n-FROM DynamicStrings IMPORT String, InitString, KillString, InitStringCharStar, Dup, Mark, string ;\n-FROM M2Options IMPORT Verbose ;\n+FROM DynamicStrings IMPORT String, InitString, KillString, InitStringCharStar, Dup, Mark, EqualArray, string ;\n+FROM M2Options IMPORT Verbose, GetM2Prefix ;\n+FROM PathName IMPORT DumpPathName ;\n+\n \n CONST\n    Debugging = FALSE ;\n@@ -225,6 +228,19 @@ BEGIN\n END PeepInto ;\n \n \n+(*\n+   qprintLibName - print the libname\n+*)\n+\n+PROCEDURE qprintLibName (LibName: String) ;\n+BEGIN\n+   IF (LibName # NIL) AND (NOT EqualArray (LibName, ''))\n+   THEN\n+      qprintf1 (' [%s]', LibName)\n+   END\n+END qprintLibName ;\n+\n+\n (*\n    DoPass0 -\n *)\n@@ -236,6 +252,7 @@ VAR\n    i       : CARDINAL ;\n    SymName,\n    FileName,\n+   LibName,\n    PPSource: String ;\n BEGIN\n    P0Init ;\n@@ -251,27 +268,34 @@ BEGIN\n    i := 1 ;\n    Sym := GetModuleNo(i) ;\n    qprintf1('Compiling: %s\\n', PPSource) ;\n+   IF Debugging\n+   THEN\n+      DumpPathName ('DoPass0')\n+   END ;\n    IF Verbose\n    THEN\n-      fprintf1(StdOut, 'Compiling: %s\\n', PPSource) ;\n+      fprintf1 (StdOut, 'Compiling: %s\\n', PPSource)\n    END ;\n    qprintf0('Pass 0: lexical analysis, parsing, modules and associated filenames\\n') ;\n    WHILE Sym#NulSym DO\n-      SymName := InitStringCharStar(KeyToCharStar(GetSymName(Sym))) ;\n-      IF IsDefImp(Sym)\n+      SymName := InitStringCharStar (KeyToCharStar (GetSymName (Sym))) ;\n+      IF IsDefImp (Sym)\n       THEN\n-         IF FindSourceDefFile(SymName, FileName)\n+         LibName := NIL ;\n+         IF FindSourceDefFile (SymName, FileName, LibName)\n          THEN\n             ModuleType := Definition ;\n-            IF OpenSource(AssociateDefinition(PreprocessModule(FileName, FALSE), Sym))\n+            IF OpenSource (AssociateDefinition (PreprocessModule (FileName, FALSE), Sym))\n             THEN\n-               IF NOT P0SyntaxCheck.CompilationUnit()\n+               IF NOT P0SyntaxCheck.CompilationUnit ()\n                THEN\n-                  WriteFormat0('compilation failed') ;\n+                  WriteFormat0 ('compilation failed') ;\n                   CloseSource ;\n                   RETURN\n                END ;\n                qprintf2 ('   Module %-20s : %s', SymName, FileName) ;\n+               qprintLibName (LibName) ;\n+               PutLibName (Sym, makekey (string (LibName))) ;\n                IF IsDefinitionForC (Sym)\n                THEN\n                   qprintf0 (' (for C)')\n@@ -298,13 +322,17 @@ BEGIN\n       IF (Main=Sym) OR NeedToParseImplementation(Sym)\n       THEN\n          (* only need to read implementation module if hidden types are declared or it is the main module *)\n+         LibName := NIL ;\n          IF Main=Sym\n          THEN\n-            FileName := Dup (PPSource)\n+            FileName := Dup (PPSource) ;\n+            LibName := InitStringCharStar (GetM2Prefix ()) ;\n+            PutLibName (Sym, makekey (string (LibName)))\n          ELSE\n-            IF FindSourceModFile (SymName, FileName)\n+            IF FindSourceModFile (SymName, FileName, LibName)\n             THEN\n-               FileName := PreprocessModule (FileName, FALSE)\n+               FileName := PreprocessModule (FileName, FALSE) ;\n+               PutLibName (Sym, makekey (string (LibName)))\n             END\n          END ;\n          IF FileName#NIL\n@@ -318,6 +346,7 @@ BEGIN\n                   RETURN\n                END ;\n                qprintf2 ('   Module %-20s : %s', SymName, FileName) ;\n+               qprintLibName (LibName) ;\n                IF IsModLink (Sym)\n                THEN\n                   qprintf0 (' (linking)')\n@@ -343,9 +372,13 @@ BEGIN\n          THEN\n             (* The implementation is only useful if -fgen-module-list= is\n                used and we do not insist upon it.  *)\n-            IF FindSourceModFile (SymName, FileName)\n+            LibName := NIL ;\n+            IF FindSourceModFile (SymName, FileName, LibName)\n             THEN\n-               qprintf2 ('   Module %-20s : %s (linking)\\n', SymName, FileName) ;\n+               PutLibName (Sym, makekey (string (LibName))) ;\n+               qprintf2 ('   Module %-20s : %s' , SymName, FileName) ;\n+               qprintLibName (LibName) ;\n+               qprintf0 (' (linking)\\n') ;\n                IF OpenSource (AssociateModule (PreprocessModule (FileName, FALSE), Sym))\n                THEN\n                   PutModLink (Sym, TRUE) ;   (* This source is only used to determine link time info.  *)\n@@ -362,6 +395,7 @@ BEGIN\n       END ;\n       SymName := KillString (SymName) ;\n       FileName := KillString (FileName) ;\n+      LibName := KillString (LibName) ;\n       INC (i) ;\n       Sym := GetModuleNo (i)\n    END ;"}, {"sha": "f574981f5fc3a99be990745265eba2a60a149e6c", "filename": "gcc/m2/gm2-compiler/M2Graph.mod", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2Graph.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2Graph.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Graph.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -29,8 +29,8 @@ FROM StrIO IMPORT WriteString, WriteLn ;\n FROM NameKey IMPORT Name, WriteKey ;\n FROM Lists IMPORT InitList, KillList, IncludeItemIntoList, RemoveItemFromList ;\n FROM Indexing IMPORT Index, HighIndice, IncludeIndiceIntoIndex, InitIndex, KillIndex, GetIndice ;\n-FROM M2Printf IMPORT printf0, printf1, printf2 ;\n-FROM SymbolTable IMPORT GetSymName, IsDefinitionForC, IsModule ;\n+FROM M2Printf IMPORT printf0, printf1, printf2, printf3 ;\n+FROM SymbolTable IMPORT GetSymName, GetLibName, IsDefinitionForC, IsModule ;\n \n \n CONST\n@@ -189,18 +189,20 @@ END SortGraph ;\n \n PROCEDURE resolveImports (sorted: List; nptr: node) ;\n VAR\n-     i, n: CARDINAL ;\n-  name: Name ;\n+   i, n: CARDINAL ;\n+   libname,\n+   name   : Name ;\n BEGIN\n    IF nptr^.nstate = initial\n    THEN\n       nptr^.nstate := started ;\n       name := GetSymName (nptr^.moduleSym) ;\n+      libname := GetLibName (nptr^.moduleSym) ;\n       i := 1 ;\n       n := HighIndice (nptr^.deps) ;\n       IF Debugging\n       THEN\n-         printf2 (\"resolving %a  %d dependents\\n\", name, n)\n+         printf3 (\"resolving %a [%a] %d dependents\\n\", name, libname, n)\n       END ;\n       WHILE i <= n DO\n          resolveImports (sorted, GetIndice (nptr^.deps, i)) ;"}, {"sha": "67b92fa46f6cd84ab2830c3ad1280a48ebb8e710", "filename": "gcc/m2/gm2-compiler/M2Options.def", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2Options.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2Options.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Options.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -94,7 +94,8 @@ EXPORT QUALIFIED SetReturnCheck, SetNilCheck, SetCaseCheck,\n                  SetRuntimeModuleOverride, GetRuntimeModuleOverride,\n                  SetGenModuleList, GetGenModuleFilename, SharedFlag,\n                  SetB, GetB, SetMD, GetMD, SetMMD, GetMMD, SetObj, GetObj,\n-                 GetMQ, SetMQ ;\n+                 GetMQ, SetMQ, SetM2Prefix, GetM2Prefix,\n+                 SetM2PathName, GetM2PathName ;\n \n \n VAR\n@@ -177,6 +178,35 @@ VAR\n    Coding,\n    Profiling               : BOOLEAN ;\n \n+\n+(*\n+   SetM2Prefix - assign arg to M2Prefix.\n+*)\n+\n+PROCEDURE SetM2Prefix (arg: ADDRESS) ;\n+\n+\n+(*\n+   GetM2Prefix - return M2Prefix as a C string.\n+*)\n+\n+PROCEDURE GetM2Prefix () : ADDRESS ;\n+\n+\n+(*\n+   SetM2PathName - assign arg to M2PathName.\n+*)\n+\n+PROCEDURE SetM2PathName (arg: ADDRESS) ;\n+\n+\n+(*\n+   GetM2PathName - return M2PathName as a C string.\n+*)\n+\n+PROCEDURE GetM2PathName () : ADDRESS ;\n+\n+\n (*\n    SetPPOnly - set the PPonly to value (on E, M, MM).\n *)"}, {"sha": "95dc6070330122e62da7dc4285cc72a9a58c1f28", "filename": "gcc/m2/gm2-compiler/M2Options.mod", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2Options.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2Options.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Options.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -25,14 +25,15 @@ IMPLEMENTATION MODULE M2Options ;\n IMPORT CmdArgs ;\n FROM SArgs IMPORT GetArg, Narg ;\n FROM M2Search IMPORT SetDefExtension, SetModExtension ;\n-FROM DynamicStringPath IMPORT Cons, GetUserPath, SetUserPath, Cons ;\n+FROM PathName IMPORT DumpPathName, AddInclude ;\n FROM M2Printf IMPORT printf0, printf1, fprintf1 ;\n FROM FIO IMPORT StdErr ;\n FROM libc IMPORT exit ;\n FROM Debug IMPORT Halt ;\n FROM m2linemap IMPORT location_t ;\n FROM m2configure IMPORT FullPathCPP ;\n \n+\n FROM DynamicStrings IMPORT String, Length, InitString, Mark, Slice, EqualArray,\n                            InitStringCharStar, ConCatChar, ConCat, KillString,\n                            Dup, string,\n@@ -51,8 +52,11 @@ FROM DynamicStrings IMPORT String, Length, InitString, Mark, Slice, EqualArray,\n \n CONST\n    Debugging = FALSE ;\n+   DefaultRuntimeModuleOverride = \"m2iso:RTentity,m2iso:Storage,m2iso:SYSTEM,m2iso:M2RTS,m2iso:RTExceptions,m2iso:IOLink\" ;\n \n VAR\n+   M2Prefix,\n+   M2PathName,\n    Barg,\n    MDarg,\n    MMDarg,\n@@ -116,6 +120,49 @@ END DSdbExit ;\n *)\n \n \n+(*\n+   SetM2Prefix - assign arg to M2Prefix.\n+*)\n+\n+PROCEDURE SetM2Prefix (arg: ADDRESS) ;\n+BEGIN\n+   M2Prefix := KillString (M2Prefix) ;\n+   M2Prefix := InitStringCharStar (arg)\n+END SetM2Prefix ;\n+\n+\n+(*\n+   GetM2Prefix - return M2Prefix as a C string.\n+*)\n+\n+PROCEDURE GetM2Prefix () : ADDRESS ;\n+BEGIN\n+   RETURN string (M2Prefix)\n+END GetM2Prefix ;\n+\n+\n+(*\n+   SetM2PathName - assign arg to M2PathName.\n+*)\n+\n+PROCEDURE SetM2PathName (arg: ADDRESS) ;\n+BEGIN\n+   M2PathName := KillString (M2PathName) ;\n+   M2PathName := InitStringCharStar (arg) ;\n+   (* fprintf1 (StdErr, \"M2PathName = %s\\n\", M2PathName)  *)\n+END SetM2PathName ;\n+\n+\n+(*\n+   GetM2PathName - return M2PathName as a C string.\n+*)\n+\n+PROCEDURE GetM2PathName () : ADDRESS ;\n+BEGIN\n+   RETURN string (M2PathName)\n+END GetM2PathName ;\n+\n+\n (*\n    SetB - assigns Barg to arg.\n *)\n@@ -900,12 +947,12 @@ PROCEDURE SetSearchPath (arg: ADDRESS) ;\n VAR\n    s: String ;\n BEGIN\n-   s := InitStringCharStar(arg) ;\n+   s := InitStringCharStar (arg) ;\n+   AddInclude (M2PathName, s) ;\n    IF Debugging\n    THEN\n-      fprintf1 (StdErr, \"M2Search.SetSearchPath setting search path to: %s\\n\", s)\n+      DumpPathName (\"path name entries: \")\n    END ;\n-   SetUserPath (Cons (GetUserPath (), s)) ;\n    s := KillString (s)\n END SetSearchPath ;\n \n@@ -1315,7 +1362,7 @@ END SetShared ;\n \n BEGIN\n    cflag                        := FALSE ;  (* -c.  *)\n-   RuntimeModuleOverride        := NIL ;\n+   RuntimeModuleOverride        := InitString (DefaultRuntimeModuleOverride) ;\n    CppArgs                      := InitString ('') ;\n    Pim                          :=  TRUE ;\n    Pim2                         := FALSE ;\n@@ -1382,5 +1429,7 @@ BEGIN\n    MMDarg                       := NIL ;\n    MQarg                        := NIL ;\n    SaveTempsDir                 := NIL ;\n-   DumpDir                      := NIL\n+   DumpDir                      := NIL ;\n+   M2Prefix                     := InitString ('') ;\n+   M2PathName                   := InitString ('')\n END M2Options."}, {"sha": "3802b99b44381da0297f40d3d0c6c75602b0ec62", "filename": "gcc/m2/gm2-compiler/M2Quads.mod", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2Quads.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2Quads.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Quads.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -126,7 +126,7 @@ FROM SymbolTable IMPORT ModeOfAddr, GetMode, PutMode, GetSymName, IsUnknown,\n                         GetUnboundedHighOffset,\n \n                         ForeachFieldEnumerationDo, ForeachLocalSymDo,\n-                        GetExported, PutImported, GetSym,\n+                        GetExported, PutImported, GetSym, GetLibName,\n                         IsUnused,\n                         NulSym ;\n \n@@ -2259,7 +2259,8 @@ END SafeRequestSym ;\n \n (*\n    callRequestDependant - create a call:\n-                          RequestDependant (GetSymName (modulesym), GetSymName (depModuleSym));\n+                          RequestDependant (GetSymName (modulesym), GetLibName (modulesym),\n+                                            GetSymName (depModuleSym), GetLibName (depModuleSym));\n *)\n \n PROCEDURE callRequestDependant (tokno: CARDINAL;\n@@ -2273,17 +2274,28 @@ BEGIN\n    PushT (1) ;\n    BuildAdrFunction ;\n \n+   PushTF (Adr, Address) ;\n+   PushTtok (MakeConstLitString (tokno, GetLibName (moduleSym)), tokno) ;\n+   PushT (1) ;\n+   BuildAdrFunction ;\n+\n    IF depModuleSym = NulSym\n    THEN\n+      PushTF (Nil, Address) ;\n       PushTF (Nil, Address)\n    ELSE\n       PushTF (Adr, Address) ;\n       PushTtok (MakeConstLitString (tokno, GetSymName (depModuleSym)), tokno) ;\n       PushT (1) ;\n+      BuildAdrFunction ;\n+\n+      PushTF (Adr, Address) ;\n+      PushTtok (MakeConstLitString (tokno, GetLibName (depModuleSym)), tokno) ;\n+      PushT (1) ;\n       BuildAdrFunction\n    END ;\n \n-   PushT (2) ;\n+   PushT (4) ;\n    BuildProcedureCall (tokno)\n END callRequestDependant ;\n \n@@ -2344,8 +2356,8 @@ END ForeachImportedModuleDo ;\n                         static void\n                         dependencies (void)\n                         {\n-                           M2RTS_RequestDependant (module_name, \"b\");\n-                           M2RTS_RequestDependant (module_name, NULL);\n+                           M2RTS_RequestDependant (module_name, libname, \"b\", \"b libname\");\n+                           M2RTS_RequestDependant (module_name, libname, NULL, NULL);\n                         }\n *)\n \n@@ -2519,7 +2531,7 @@ BEGIN\n       (* int\n          _M2_init (int argc, char *argv[], char *envp[])\n          {\n-            M2RTS_ConstructModules (module_name, argc, argv, envp);\n+            M2RTS_ConstructModules (module_name, libname, argc, argv, envp);\n          }  *)\n       PushT (initFunction) ;\n       BuildProcedureStart ;\n@@ -2549,10 +2561,15 @@ BEGIN\n             PushT(1) ;\n             BuildAdrFunction ;\n \n+            PushTF(Adr, Address) ;\n+            PushTtok (MakeConstLitString (tok, GetLibName (moduleSym)), tok) ;\n+            PushT(1) ;\n+            BuildAdrFunction ;\n+\n             PushTtok (SafeRequestSym (tok, MakeKey (\"argc\")), tok) ;\n             PushTtok (SafeRequestSym (tok, MakeKey (\"argv\")), tok) ;\n             PushTtok (SafeRequestSym (tok, MakeKey (\"envp\")), tok) ;\n-            PushT (4) ;\n+            PushT (5) ;\n             BuildProcedureCall (tok) ;\n          END\n       ELSIF ScaffoldStatic\n@@ -2604,10 +2621,15 @@ BEGIN\n             PushT(1) ;\n             BuildAdrFunction ;\n \n+            PushTF(Adr, Address) ;\n+            PushTtok (MakeConstLitString (tok, GetLibName (moduleSym)), tok) ;\n+            PushT(1) ;\n+            BuildAdrFunction ;\n+\n             PushTtok (SafeRequestSym (tok, MakeKey (\"argc\")), tok) ;\n             PushTtok (SafeRequestSym (tok, MakeKey (\"argv\")), tok) ;\n             PushTtok (SafeRequestSym (tok, MakeKey (\"envp\")), tok) ;\n-            PushT (4) ;\n+            PushT (5) ;\n             BuildProcedureCall (tok)\n          END\n       ELSIF ScaffoldStatic\n@@ -2630,7 +2652,7 @@ END BuildM2FiniFunction ;\n                          void\n                          ctorFunction ()\n                          {\n-                           M2RTS_RegisterModule (GetSymName (moduleSym),\n+                           M2RTS_RegisterModule (GetSymName (moduleSym), GetLibName (moduleSym),\n                                                  init, fini, dependencies);\n                          }\n *)\n@@ -2663,10 +2685,15 @@ BEGIN\n             PushT (1) ;\n             BuildAdrFunction ;\n \n+            PushTF (Adr, Address) ;\n+            PushTtok (MakeConstLitString (tok, GetLibName (moduleSym)), tok) ;\n+            PushT (1) ;\n+            BuildAdrFunction ;\n+\n             PushTtok (init, tok) ;\n             PushTtok (fini, tok) ;\n             PushTtok (dep, tok) ;\n-            PushT (4) ;\n+            PushT (5) ;\n             BuildProcedureCall (tok)\n          END ;\n          EndScope ;"}, {"sha": "c0f0efd6bb79a3db0a0ccb7f4d065bda6c04f56e", "filename": "gcc/m2/gm2-compiler/M2Scaffold.mod", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2Scaffold.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2Scaffold.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Scaffold.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -35,7 +35,8 @@ FROM SymbolTable IMPORT NulSym, MakeProcedure, PutFunction,\n                         GetSymName, StartScope, EndScope,\n                         GetModuleDefImportStatementList,\n                         GetModuleModImportStatementList,\n-                        GetImportModule, GetImportStatementList ;\n+                        GetImportModule, GetImportStatementList,\n+                        PutLibName ;\n \n FROM NameKey IMPORT NulName, Name, MakeKey, makekey, KeyToCharStar ;\n FROM M2Base IMPORT Integer, Cardinal ;\n@@ -44,9 +45,11 @@ FROM M2LexBuf IMPORT GetTokenNo ;\n FROM Assertion IMPORT Assert ;\n FROM Lists IMPORT List, InitList, IncludeItemIntoList, NoOfItemsInList, GetItemFromList, KillList, IsItemInList ;\n FROM M2MetaError IMPORT MetaErrorT0, MetaErrorStringT0 ;\n+FROM M2Search IMPORT FindSourceDefFile ;\n \n FROM SFIO IMPORT OpenToWrite, WriteS, ReadS, OpenToRead, Exists ;\n FROM FIO IMPORT File, EOF, IsNoError, Close ;\n+FROM FormatStrings IMPORT Sprintf1 ;\n \n FROM M2Options IMPORT GetUselist, ScaffoldStatic, ScaffoldDynamic, GenModuleList,\n                       GetGenModuleFilename, GetUselistFilename, GetUselist, cflag,\n@@ -84,14 +87,14 @@ VAR\n \n static void _M2_init (int argc, char *argv[], char *envp[])\n {\n-  M2RTS_ConstructModules (module_name, argc, argv, envp);\n+  M2RTS_ConstructModules (module_name, libname, argc, argv, envp);\n }\n \n \n static void _M2_fini (int argc, char *argv[], char *envp[])\n {\n   M2RTS_Terminate ();\n-  M2RTS_DeconstructModules (module_name, argc, argv, envp);\n+  M2RTS_DeconstructModules (module_name, libname, argc, argv, envp);\n }\n \n \n@@ -244,16 +247,29 @@ END PopulateCtorArray ;\n \n PROCEDURE LookupModuleSym (tok: CARDINAL; name: Name) : CARDINAL ;\n VAR\n-   sym: CARDINAL ;\n+   sym     : CARDINAL ;\n+   FileName,\n+   LibName : String ;\n BEGIN\n    sym := Get (name) ;\n    IF sym = NulSym\n    THEN\n-      sym := MakeDefImp (tok, name)\n-   END ;\n-   IF sym # GetMainModule ()\n-   THEN\n-      PutModuleCtorExtern (tok, sym, NOT WholeProgram)\n+      LibName := NIL ;\n+      FileName := NIL ;\n+      IF FindSourceDefFile (InitStringCharStar (KeyToCharStar (name)),\n+                            FileName, LibName)\n+      THEN\n+         sym := MakeDefImp (tok, name) ;\n+         PutLibName (sym, makekey (string (LibName))) ;\n+         IF sym # GetMainModule ()\n+         THEN\n+            PutModuleCtorExtern (tok, sym, NOT WholeProgram)\n+         END\n+      ELSE\n+         MetaErrorStringT0 (tok,\n+                            Sprintf1 (InitString ('the definition module file for {%%1a} cannot be found'),\n+                                      name))\n+      END\n    END ;\n    RETURN sym\n END LookupModuleSym ;"}, {"sha": "e77c75477ee688aa5e6bbc709cbd3791d48ead36", "filename": "gcc/m2/gm2-compiler/M2Search.def", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2Search.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2Search.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Search.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -42,11 +42,13 @@ FROM DynamicStrings IMPORT String ;\n                     FullPath will be totally overwritten and should\n                     not be initialized by InitString before this function\n                     is called.\n+                    FullPath is set to NIL if this function returns FALSE.\n                     FindSourceFile sets FullPath to a new string if successful.\n+                    The string FileName is not altered.\n *)\n \n PROCEDURE FindSourceFile (FileName: String;\n-                          VAR FullPath: String) : BOOLEAN ;\n+                          VAR FullPath, named: String) : BOOLEAN ;\n \n \n (*\n@@ -56,7 +58,7 @@ PROCEDURE FindSourceFile (FileName: String;\n                        then FALSE is returned and FullPath is set to NIL.\n *)\n \n-PROCEDURE FindSourceDefFile (Stem: String; VAR FullPath: String) : BOOLEAN ;\n+PROCEDURE FindSourceDefFile (Stem: String; VAR FullPath, named: String) : BOOLEAN ;\n \n \n (*\n@@ -66,7 +68,7 @@ PROCEDURE FindSourceDefFile (Stem: String; VAR FullPath: String) : BOOLEAN ;\n                        then FALSE is returned and FullPath is set to NIL.\n *)\n \n-PROCEDURE FindSourceModFile (Stem: String; VAR FullPath: String) : BOOLEAN ;\n+PROCEDURE FindSourceModFile (Stem: String; VAR FullPath, named: String) : BOOLEAN ;\n \n \n (*\n@@ -87,4 +89,6 @@ PROCEDURE SetDefExtension (ext: String) ;\n PROCEDURE SetModExtension (ext: String) ;\n \n \n+\n+\n END M2Search."}, {"sha": "80806bf8084f63997b889ffb992c3b36323256c9", "filename": "gcc/m2/gm2-compiler/M2Search.mod", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2Search.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FM2Search.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Search.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -24,7 +24,7 @@ IMPLEMENTATION MODULE M2Search ;\n \n FROM M2FileName IMPORT CalculateFileName ;\n FROM Assertion IMPORT Assert ;\n-FROM DynamicStringPath IMPORT GetUserPath, GetSystemPath, FindFileName ;\n+FROM PathName IMPORT FindNamedPathFile ;\n \n FROM DynamicStrings IMPORT InitString, InitStringChar,\n                            KillString, ConCat, ConCatChar, Index, Slice,\n@@ -55,7 +55,9 @@ VAR\n (*\n    doDSdbEnter - called when compiled with -fcpp to enable runtime garbage\n                  collection debugging.\n+*)\n \n+(*\n PROCEDURE doDSdbEnter ;\n BEGIN\n    PushAllocation\n@@ -67,7 +69,9 @@ END doDSdbEnter ;\n    doDSdbExit - called when compiled with -fcpp to enable runtime garbage\n                 collection debugging.  The parameter string s is exempt from\n                 garbage collection analysis.\n+*)\n \n+(*\n PROCEDURE doDSdbExit (s: String) ;\n BEGIN\n    (* Check to see whether no strings have been lost since the PushAllocation.  *)\n@@ -120,17 +124,13 @@ END DSdbExit ;\n                     is called.\n                     FullPath is set to NIL if this function returns FALSE.\n                     FindSourceFile sets FullPath to a new string if successful.\n-                    The string, FileName, is not altered.\n+                    The string FileName is not altered.\n *)\n \n PROCEDURE FindSourceFile (FileName: String;\n-                          VAR FullPath: String) : BOOLEAN ;\n+                          VAR FullPath, named: String) : BOOLEAN ;\n BEGIN\n-   FullPath := FindFileName (FileName, GetUserPath ()) ;\n-   IF FullPath = NIL\n-   THEN\n-      FullPath := FindFileName (FileName, GetSystemPath ())\n-   END ;\n+   FullPath := FindNamedPathFile (FileName, named) ;\n    RETURN FullPath # NIL\n END FindSourceFile ;\n \n@@ -142,22 +142,22 @@ END FindSourceFile ;\n                        then FALSE is returned and FullPath is set to NIL.\n *)\n \n-PROCEDURE FindSourceDefFile (Stem: String; VAR FullPath: String) : BOOLEAN ;\n+PROCEDURE FindSourceDefFile (Stem: String; VAR FullPath, named: String) : BOOLEAN ;\n VAR\n    f: String ;\n BEGIN\n    IF Def # NIL\n    THEN\n       f := CalculateFileName (Stem, Def) ;\n-      IF FindSourceFile (f, FullPath)\n+      IF FindSourceFile (f, FullPath, named)\n       THEN\n          RETURN TRUE\n       END ;\n       f := KillString (f)\n    END ;\n    (* Try the GNU Modula-2 default extension.  *)\n-   f := CalculateFileName (Stem, Mark(InitString ('def'))) ;\n-   RETURN FindSourceFile (f, FullPath)\n+   f := CalculateFileName (Stem, Mark (InitString ('def'))) ;\n+   RETURN FindSourceFile (f, FullPath, named)\n END FindSourceDefFile ;\n \n \n@@ -168,22 +168,22 @@ END FindSourceDefFile ;\n                        then FALSE is returned and FullPath is set to NIL.\n *)\n \n-PROCEDURE FindSourceModFile (Stem: String; VAR FullPath: String) : BOOLEAN ;\n+PROCEDURE FindSourceModFile (Stem: String; VAR FullPath, named: String) : BOOLEAN ;\n VAR\n    f: String ;\n BEGIN\n    IF Mod#NIL\n    THEN\n       f := CalculateFileName (Stem, Mod) ;\n-      IF FindSourceFile (f, FullPath)\n+      IF FindSourceFile (f, FullPath, named)\n       THEN\n          RETURN TRUE\n       END ;\n       f := KillString (f)\n    END ;\n    (* Try the GNU Modula-2 default extension.  *)\n-   f := CalculateFileName (Stem, Mark(InitString ('mod'))) ;\n-   RETURN FindSourceFile (f, FullPath)\n+   f := CalculateFileName (Stem, Mark (InitString ('mod'))) ;\n+   RETURN FindSourceFile (f, FullPath, named)\n END FindSourceModFile ;\n \n \n@@ -195,8 +195,8 @@ END FindSourceModFile ;\n \n PROCEDURE SetDefExtension (ext: String) ;\n BEGIN\n-   Def := KillString(Def) ;\n-   Def := Dup(ext)\n+   Def := KillString (Def) ;\n+   Def := Dup (ext)\n END SetDefExtension ;\n \n \n@@ -208,8 +208,8 @@ END SetDefExtension ;\n \n PROCEDURE SetModExtension (ext: String) ;\n BEGIN\n-   Mod := KillString(Mod) ;\n-   Mod := Dup(ext)\n+   Mod := KillString (Mod) ;\n+   Mod := Dup (ext)\n END SetModExtension ;\n \n "}, {"sha": "39d9b15bb3a1aabf1ae4cd69d4240a01d8fdcf95", "filename": "gcc/m2/gm2-compiler/PathName.def", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FPathName.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FPathName.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FPathName.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,104 @@\n+DEFINITION MODULE PathName ;\n+\n+(*\n+    Title      : PathName\n+    Author     : Gaius Mulley\n+    System     : GNU Modula-2\n+    Date       : Wed Feb  8 09:59:46 2023\n+    Revision   : $Version$\n+    Description: maintains a dictionary of named paths.\n+*)\n+\n+FROM DynamicStrings IMPORT String ;\n+FROM DynamicPath IMPORT PathList ;\n+\n+\n+TYPE\n+   NamedPath ;\n+\n+\n+(*\n+   FindNamedPathFile - returns NIL if a file cannot be found otherwise\n+                       it returns the path including the filename.\n+                       It also returns the name of the path.\n+*)\n+\n+PROCEDURE FindNamedPathFile (filename: String; VAR name: String) : String ;\n+\n+\n+(*\n+   AddInclude - adds include path to the named path.  If named path\n+                is the same as the previous call then the include path\n+                is appended to the named path PathList otherwise a new\n+                named path is created and placed at the end of the\n+                named path list.\n+\n+                However if named is NIL or empty string then this is treated\n+                as a user path and it will be appended to the first user\n+                named list entry.  The user entry will always be the\n+                first node in the dictionary of named paths.\n+*)\n+\n+PROCEDURE AddInclude (named, directory: String) ;\n+\n+\n+(*\n+   InitNamedPath - creates a new path name with an associated pathlist.\n+*)\n+\n+PROCEDURE InitNamedPath (name: String; pl: PathList) : NamedPath ;\n+\n+\n+(*\n+   KillNamedPath - places list np onto the freelist.\n+                   Postcondition: np will be NIL.\n+*)\n+\n+PROCEDURE KillNamedPath (VAR np: NamedPath) ;\n+\n+\n+(*\n+   Cons - appends pl to the end of a named path.\n+          If np is NIL a new list is created and returned\n+          containing named and pl.\n+*)\n+\n+PROCEDURE Cons (np: NamedPath; named: String; pl: PathList) : NamedPath ;\n+\n+\n+(*\n+   ConsList - concatenates named path left and right together.\n+*)\n+\n+PROCEDURE ConsList (left, right: NamedPath) : NamedPath ;\n+\n+\n+(*\n+   Stash - returns np before setting np to NIL.\n+*)\n+\n+PROCEDURE Stash (VAR np: NamedPath) : NamedPath ;\n+\n+\n+(*\n+   SetNamedPath - assigns the named path to the default path.\n+*)\n+\n+PROCEDURE SetNamedPath (named: NamedPath) ;\n+\n+\n+(*\n+   GetNamedPath - returns the default named path.\n+*)\n+\n+PROCEDURE GetNamedPath () : NamedPath ;\n+\n+\n+(*\n+   DumpPathName - display the dictionary of names and all path entries.\n+*)\n+\n+PROCEDURE DumpPathName (name: ARRAY OF CHAR) ;\n+\n+\n+END PathName."}, {"sha": "6fc7612d08f34adc07eb42170ced9cabb0bb1f95", "filename": "gcc/m2/gm2-compiler/PathName.mod", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FPathName.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FPathName.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FPathName.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,279 @@\n+IMPLEMENTATION MODULE PathName ;\n+\n+FROM Storage IMPORT ALLOCATE, DEALLOCATE ;\n+FROM DynamicStrings IMPORT InitString, ConCat, ConCatChar, char, Dup,\n+                           KillString, Length, EqualArray, Equal, Mark ;\n+FROM SFIO IMPORT Exists ;\n+FROM FIO IMPORT StdErr ;\n+FROM M2Printf IMPORT fprintf0, fprintf1, fprintf2 ;\n+FROM FormatStrings IMPORT Sprintf1 ;\n+\n+FROM DynamicPath IMPORT InitPathList, FindFileName ;\n+\n+IMPORT DynamicPath ;\n+\n+\n+CONST\n+   Debugging = FALSE ;\n+\n+TYPE\n+   NamedPath = POINTER TO RECORD\n+                             pathList: PathList ;\n+                             name    : String ;\n+                             tail,\n+                             next    : NamedPath ;\n+                          END ;\n+\n+\n+VAR\n+   FreeList,\n+   NamedPathHead: NamedPath ;\n+\n+\n+\n+(*\n+   AddSystem -\n+*)\n+\n+PROCEDURE AddSystem (named, directory: String) ;\n+BEGIN\n+   IF NamedPathHead = NIL\n+   THEN\n+      (* Empty dictionary add single entry.  *)\n+      SetNamedPath (InitNamedPath (named, InitPathList (directory)))\n+   ELSIF Equal (NamedPathHead^.tail^.name, named)\n+   THEN\n+      NamedPathHead^.tail^.pathList := DynamicPath.Cons (NamedPathHead^.tail^.pathList,\n+                                                         directory)\n+   ELSE\n+      SetNamedPath (ConsList (NamedPathHead,\n+                              InitNamedPath (named, InitPathList (directory))))\n+   END\n+END AddSystem ;\n+\n+\n+(*\n+   AddUser -\n+*)\n+\n+PROCEDURE AddUser (named, directory: String) ;\n+BEGIN\n+   IF NamedPathHead = NIL\n+   THEN\n+      (* Empty dictionary add single entry.  *)\n+      SetNamedPath (InitNamedPath (named, InitPathList (directory)))\n+   ELSIF EqualArray (NamedPathHead^.name, '')\n+   THEN\n+      (* Found user node.  *)\n+      NamedPathHead^.pathList := DynamicPath.Cons (NamedPathHead^.pathList,\n+                                                   directory)\n+   ELSE\n+      (* No user node yet, so we will create one.  *)\n+      NamedPathHead := ConsList (InitNamedPath (named, InitPathList (directory)),\n+                                 NamedPathHead) ;\n+      SetNamedPath (NamedPathHead)\n+   END\n+END AddUser ;\n+\n+\n+(*\n+   AddInclude - adds include path to the named path.  If named path\n+                is the same as the previous call then the include path\n+                is appended to the named path PathList otherwise a new\n+                named path is created and placed at the end of the\n+                named path list.\n+*)\n+\n+PROCEDURE AddInclude (named, directory: String) ;\n+BEGIN\n+   IF Debugging\n+   THEN\n+      fprintf2 (StdErr, \"named = %s, directory =%s\\n\",\n+                named, directory)\n+   END ;\n+   IF (named = NIL) OR EqualArray (named, '')\n+   THEN\n+      AddUser (named, directory) ;\n+      IF Debugging\n+      THEN\n+         DumpPathName ('User pathname')\n+      END\n+   ELSE\n+      AddSystem (named, directory) ;\n+      IF Debugging\n+      THEN\n+         DumpPathName ('System pathname')\n+      END\n+   END\n+END AddInclude ;\n+\n+\n+(*\n+   SetNamedPath - assigns the named path to the default path.\n+*)\n+\n+PROCEDURE SetNamedPath (named: NamedPath) ;\n+BEGIN\n+   NamedPathHead := named\n+END SetNamedPath ;\n+\n+\n+(*\n+   GetNamedPath - returns the default named path.\n+*)\n+\n+PROCEDURE GetNamedPath () : NamedPath ;\n+BEGIN\n+   RETURN NamedPathHead\n+END GetNamedPath ;\n+\n+\n+(*\n+   KillNamedPath - places list np onto the freelist.\n+                   Postcondition: np will be NIL.\n+*)\n+\n+PROCEDURE KillNamedPath (VAR np: NamedPath) ;\n+BEGIN\n+   IF np # NIL\n+   THEN\n+      np^.tail^.next := FreeList ;\n+      FreeList := np ;\n+      np := NIL\n+   END\n+END KillNamedPath ;\n+\n+\n+(*\n+   ConsList - concatenates named path left and right together.\n+*)\n+\n+PROCEDURE ConsList (left, right: NamedPath) : NamedPath ;\n+BEGIN\n+   IF right # NIL\n+   THEN\n+      left^.tail^.next := right ;\n+      left^.tail := right^.tail\n+   END ;\n+   RETURN left\n+END ConsList ;\n+\n+\n+(*\n+   Cons - appends pl to the end of a named path.\n+          If np is NIL a new list is created and returned\n+          containing named and pl.\n+*)\n+\n+PROCEDURE Cons (np: NamedPath; named: String; pl: PathList) : NamedPath ;\n+BEGIN\n+   IF np = NIL\n+   THEN\n+      np := InitNamedPath (named, pl)\n+   ELSE\n+      np := ConsList (np, InitNamedPath (named, pl))\n+   END ;\n+   RETURN np\n+END Cons ;\n+\n+\n+(*\n+   Stash - returns np before setting np to NIL.\n+*)\n+\n+PROCEDURE Stash (VAR np: NamedPath) : NamedPath ;\n+VAR\n+   old: NamedPath ;\n+BEGIN\n+   old := np ;\n+   np := NIL ;\n+   RETURN old\n+END Stash ;\n+\n+\n+(*\n+   InitNamedPath - creates a new path name with an associated pathlist.\n+*)\n+\n+PROCEDURE InitNamedPath (name: String; pl: PathList) : NamedPath ;\n+VAR\n+   np: NamedPath ;\n+BEGIN\n+   NEW (np) ;\n+   IF np = NIL\n+   THEN\n+      HALT\n+   ELSE\n+      np^.pathList := pl ;\n+      np^.name := Dup (name) ;\n+      np^.next := NIL ;\n+      np^.tail := np\n+   END ;\n+   RETURN np\n+END InitNamedPath ;\n+\n+\n+(*\n+   FindNamedPathFile - Post-condition: returns NIL if a file cannot be found otherwise\n+                       it returns the path including the filename.\n+                       It also returns a new string the name of the path.\n+                       Pre-condition: if name = NIL then it searches\n+                                          user path first, followed by any\n+                                          named path.\n+                                      elsif name = ''\n+                                      then\n+                                         search user path\n+                                      else\n+                                         search named path\n+                                      fi\n+*)\n+\n+PROCEDURE FindNamedPathFile (filename: String; VAR name: String) : String ;\n+VAR\n+   foundFile: String ;\n+   np       : NamedPath ;\n+BEGIN\n+   np := NamedPathHead ;\n+   WHILE np # NIL DO\n+      IF (name = NIL) OR Equal (np^.name, name)\n+      THEN\n+         foundFile := FindFileName (filename, np^.pathList) ;\n+         IF foundFile # NIL\n+         THEN\n+            name := Dup (np^.name) ;\n+            RETURN foundFile\n+         END\n+      END ;\n+      np := np^.next\n+   END ;\n+   name := NIL ;\n+   RETURN NIL\n+END FindNamedPathFile ;\n+\n+\n+(*\n+   DumpPathName - display the dictionary of names and all path entries.\n+*)\n+\n+PROCEDURE DumpPathName (name: ARRAY OF CHAR) ;\n+VAR\n+   np    : NamedPath ;\n+   leader: String ;\n+BEGIN\n+   fprintf0 (StdErr, name) ;\n+   fprintf0 (StdErr, \" = {\\n\") ;\n+   np := NamedPathHead ;\n+   WHILE np # NIL DO\n+      leader := Sprintf1 (Mark (InitString (\"  %s\")), np^.name) ;\n+      DynamicPath.DumpPath (leader, np^.pathList) ;\n+      leader := KillString (leader) ;\n+      np := np^.next\n+   END ;\n+   fprintf0 (StdErr, \"}\\n\")\n+END DumpPathName ;\n+\n+\n+BEGIN\n+   NamedPathHead := NIL ;\n+   FreeList := NIL\n+END PathName."}, {"sha": "c7f584bfb09de9e33a234b1ad9c12c942322f1ec", "filename": "gcc/m2/gm2-compiler/SymbolTable.def", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FSymbolTable.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FSymbolTable.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FSymbolTable.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -336,6 +336,7 @@ EXPORT QUALIFIED NulSym,\n                  PutModuleContainsBuiltin, IsBuiltinInModule,\n \t\t HasVarParameters,\n                  GetErrorScope,\n+                 GetLibName, PutLibName,\n \n                  IsSizeSolved,\n                  IsOffsetSolved,\n@@ -588,7 +589,21 @@ PROCEDURE MakeProcedure (tok: CARDINAL; ProcedureName: Name) : CARDINAL ;\n    MakeProcedureCtorExtern - creates an extern ctor procedure\n *)\n \n-PROCEDURE MakeProcedureCtorExtern (tokenno: CARDINAL; modulename: Name) : CARDINAL ;\n+PROCEDURE MakeProcedureCtorExtern (tokenno: CARDINAL; libname, modulename: Name) : CARDINAL ;\n+\n+\n+(*\n+   PutLibName - places libname into defimp or module sym.\n+*)\n+\n+PROCEDURE PutLibName (sym: CARDINAL; libname: Name) ;\n+\n+\n+(*\n+   GetLibName - returns libname associated with a defimp or module sym.\n+*)\n+\n+PROCEDURE GetLibName (sym: CARDINAL) : Name ;\n \n \n (*"}, {"sha": "92f1f1e83f797d9d244a9b1c5c5256fbac6c5de3", "filename": "gcc/m2/gm2-compiler/SymbolTable.mod", "status": "modified", "additions": 75, "deletions": 12, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FSymbolTable.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-compiler%2FSymbolTable.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FSymbolTable.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -615,6 +615,7 @@ TYPE\n             RECORD\n                name          : Name ;       (* Index into name array, name   *)\n                                             (* of record field.              *)\n+               libname       : Name ;       (* Library (dialect) with module *)\n                ctors         : ModuleCtor ; (* All the ctor functions.       *)\n                DefListOfDep,\n                ModListOfDep  : List ;       (* Vector of SymDependency.      *)\n@@ -714,6 +715,7 @@ TYPE\n             RECORD\n                name          : Name ;       (* Index into name array, name   *)\n                                             (* of record field.              *)\n+               libname       : Name ;       (* Library (dialect) with module *)\n                ctors         : ModuleCtor ; (* All the ctor functions.       *)\n                ModListOfDep  : List ;       (* Vector of SymDependency.      *)\n                LocalSymbols  : SymbolTree ; (* The LocalSymbols hold all the *)\n@@ -3030,11 +3032,11 @@ END IsImplicityExported ;\n    MakeProcedureCtorExtern - creates an extern ctor procedure\n *)\n \n-PROCEDURE MakeProcedureCtorExtern (tokenno: CARDINAL; modulename: Name) : CARDINAL ;\n+PROCEDURE MakeProcedureCtorExtern (tokenno: CARDINAL; libname, modulename: Name) : CARDINAL ;\n VAR\n    ctor: CARDINAL ;\n BEGIN\n-   ctor := MakeProcedure (tokenno, GenName ('_M2_', modulename, '_ctor')) ;\n+   ctor := MakeProcedure (tokenno, GenName (libname, '_M2_', modulename, '_ctor')) ;\n    PutExtern (ctor, TRUE) ;\n    RETURN ctor\n END MakeProcedureCtorExtern ;\n@@ -3044,12 +3046,13 @@ END MakeProcedureCtorExtern ;\n    GenName - returns a new name consisting of pre, name, post concatenation.\n *)\n \n-PROCEDURE GenName (pre: ARRAY OF CHAR; name: Name; post: ARRAY OF CHAR) : Name ;\n+PROCEDURE GenName (libname: Name; pre: ARRAY OF CHAR; name: Name; post: ARRAY OF CHAR) : Name ;\n VAR\n    str   : String ;\n    result: Name ;\n BEGIN\n-   str := InitString (pre) ;\n+   str := InitStringCharStar (KeyToCharStar (libname)) ;\n+   str := ConCat (str, Mark (InitString (pre))) ;\n    str := ConCat (str, Mark (InitStringCharStar (KeyToCharStar (name)))) ;\n    str := ConCat (str, InitString (post)) ;\n    result := makekey (string (str)) ;\n@@ -3086,10 +3089,12 @@ BEGIN\n    IF IsDefImp (moduleSym)\n    THEN\n       InitCtorFields (moduleTok, beginTok, finallyTok,\n+                      moduleSym,\n                       pSym^.DefImp.ctors, GetSymName (moduleSym),\n                       FALSE, TRUE)\n    ELSE\n       InitCtorFields (moduleTok, beginTok, finallyTok,\n+                      moduleSym,\n                       pSym^.Module.ctors, GetSymName (moduleSym),\n                       IsInnerModule (moduleSym), TRUE)\n    END\n@@ -3102,32 +3107,41 @@ END MakeModuleCtor ;\n *)\n \n PROCEDURE InitCtorFields (moduleTok, beginTok, finallyTok: CARDINAL;\n+                          moduleSym: CARDINAL;\n                           VAR ctor: ModuleCtor; name: Name;\n                           inner, pub: BOOLEAN) ;\n BEGIN\n    IF ScaffoldDynamic AND (NOT inner)\n    THEN\n       (* The ctor procedure must be public.  *)\n-      ctor.ctor := MakeProcedure (moduleTok, GenName (\"_M2_\", name, \"_ctor\")) ;\n+      ctor.ctor := MakeProcedure (moduleTok,\n+                                  GenName (GetLibName (moduleSym),\n+                                           \"_M2_\", name, \"_ctor\")) ;\n       PutCtor (ctor.ctor, TRUE) ;\n       Assert (pub) ;\n       PutPublic (ctor.ctor, pub) ;\n       PutExtern (ctor.ctor, NOT pub) ;\n       PutMonoName (ctor.ctor, TRUE) ;\n       (* The dep procedure is local to the module.  *)\n-      ctor.dep := MakeProcedure (moduleTok, GenName (\"_M2_\", name, \"_dep\")) ;\n+      ctor.dep := MakeProcedure (moduleTok,\n+                                 GenName (GetLibName (moduleSym),\n+                                          \"_M2_\", name, \"_dep\")) ;\n       PutMonoName (ctor.dep, TRUE)\n    ELSE\n       ctor.ctor := NulSym ;\n       ctor.dep := NulSym\n    END ;\n    (* The init/fini procedures must be public.  *)\n-   ctor.init := MakeProcedure (beginTok, GenName (\"_M2_\", name, \"_init\")) ;\n+   ctor.init := MakeProcedure (beginTok,\n+                               GenName (GetLibName (moduleSym),\n+                                        \"_M2_\", name, \"_init\")) ;\n    PutPublic (ctor.init, pub) ;\n    PutExtern (ctor.init, NOT pub) ;\n    PutMonoName (ctor.init, NOT inner) ;\n    DeclareArgEnvParams (beginTok, ctor.init) ;\n-   ctor.fini := MakeProcedure (finallyTok, GenName (\"_M2_\", name, \"_fini\")) ;\n+   ctor.fini := MakeProcedure (finallyTok,\n+                               GenName (GetLibName (moduleSym),\n+                                        \"_M2_\", name, \"_fini\")) ;\n    PutPublic (ctor.fini, pub) ;\n    PutExtern (ctor.fini, NOT pub) ;\n    PutMonoName (ctor.fini, NOT inner) ;\n@@ -3190,6 +3204,7 @@ BEGIN\n       WITH Module DO\n          name := ModuleName ;               (* Index into name array, name   *)\n                                             (* of record field.              *)\n+         libname := NulName ;               (* Library association.          *)\n          InitCtor (ctors) ;                 (* Init all ctor functions.      *)\n          InitList(ModListOfDep) ;           (* Vector of SymDependency.      *)\n          InitTree(LocalSymbols) ;           (* The LocalSymbols hold all the *)\n@@ -3456,6 +3471,7 @@ BEGIN\n          WITH Module DO\n             name := ModuleName ;            (* Index into name array, name   *)\n                                             (* of record field.              *)\n+            libname := NulName ;            (* Library association.          *)\n             InitCtor (ctors) ;              (* Init all ctor functions.      *)\n             InitTree(LocalSymbols) ;        (* The LocalSymbols hold all the *)\n                                             (* variables declared local to   *)\n@@ -3551,6 +3567,7 @@ BEGIN\n       WITH DefImp DO\n          name := DefImpName ;         (* Index into name array, name   *)\n                                       (* of record field.              *)\n+         libname := NulName ;         (* Library association.          *)\n          InitCtor (ctors) ;\n                                       (* Init all ctor functions.      *)\n          InitList(DefListOfDep) ;     (* Vector of SymDependency.      *)\n@@ -3653,6 +3670,52 @@ BEGIN\n END MakeDefImp ;\n \n \n+(*\n+   PutLibName - places libname into defimp or module sym.\n+*)\n+\n+PROCEDURE PutLibName (sym: CARDINAL; libname: Name) ;\n+VAR\n+   pSym: PtrToSymbol ;\n+BEGIN\n+   Assert (IsModule (sym) OR IsDefImp (sym)) ;\n+   pSym := GetPsym (sym) ;\n+   WITH pSym^ DO\n+      CASE SymbolType OF\n+\n+      DefImpSym:  DefImp.libname := libname |\n+      ModuleSym:  Module.libname := libname\n+\n+      ELSE\n+         InternalError ('expecting DefImp or Module symbol')\n+      END\n+   END\n+END PutLibName ;\n+\n+\n+(*\n+   GetLibName - returns libname associated with a defimp or module sym.\n+*)\n+\n+PROCEDURE GetLibName (sym: CARDINAL) : Name ;\n+VAR\n+   pSym: PtrToSymbol ;\n+BEGIN\n+   Assert (IsModule (sym) OR IsDefImp (sym)) ;\n+   pSym := GetPsym (sym) ;\n+   WITH pSym^ DO\n+      CASE SymbolType OF\n+\n+      DefImpSym:  RETURN DefImp.libname |\n+      ModuleSym:  RETURN Module.libname\n+\n+      ELSE\n+         InternalError ('expecting DefImp or Module symbol')\n+      END\n+   END\n+END GetLibName ;\n+\n+\n (*\n    PutProcedureExternPublic - if procedure is not NulSym set extern\n                               and public booleans.\n@@ -3678,29 +3741,29 @@ BEGIN\n    (* If the ctor does not exist then make it extern/ (~extern) public.  *)\n    IF ctor.ctor = NulSym\n    THEN\n-      ctor.ctor := MakeProcedure (tok, GenName (\"_M2_\", GetSymName (sym), \"_ctor\")) ;\n+      ctor.ctor := MakeProcedure (tok, GenName (GetLibName (sym), \"_M2_\", GetSymName (sym), \"_ctor\")) ;\n       PutMonoName (ctor.ctor, TRUE)\n    END ;\n    PutProcedureExternPublic (ctor.ctor, extern, NOT extern) ;\n    PutCtor (ctor.ctor, TRUE) ;\n    (* If the ctor does not exist then make it extern/ (~extern) public.  *)\n    IF ctor.dep = NulSym\n    THEN\n-      ctor.dep := MakeProcedure (tok, GenName (\"_M2_\", GetSymName (sym), \"_dep\")) ;\n+      ctor.dep := MakeProcedure (tok, GenName (GetLibName (sym), \"_M2_\", GetSymName (sym), \"_dep\")) ;\n       PutMonoName (ctor.dep, TRUE)\n    END ;\n    PutProcedureExternPublic (ctor.dep, extern, NOT extern) ;\n    (* If init/fini do not exist then create them.  *)\n    IF ctor.init = NulSym\n    THEN\n-      ctor.init := MakeProcedure (tok, GenName (\"_M2_\", GetSymName (sym), \"_init\")) ;\n+      ctor.init := MakeProcedure (tok, GenName (GetLibName (sym), \"_M2_\", GetSymName (sym), \"_init\")) ;\n       DeclareArgEnvParams (tok, ctor.init) ;\n       PutMonoName (ctor.init, NOT IsInnerModule (sym))\n    END ;\n    PutProcedureExternPublic (ctor.init, extern, NOT extern) ;\n    IF ctor.fini = NulSym\n    THEN\n-      ctor.fini := MakeProcedure (tok, GenName (\"_M2_\", GetSymName (sym), \"_fini\")) ;\n+      ctor.fini := MakeProcedure (tok, GenName (GetLibName (sym), \"_M2_\", GetSymName (sym), \"_fini\")) ;\n       DeclareArgEnvParams (tok, ctor.fini) ;\n       PutMonoName (ctor.fini, NOT IsInnerModule (sym))\n    END ;"}, {"sha": "834a84e1cf76876f0f2f9699bdba1f66cbd4a019", "filename": "gcc/m2/gm2-gcc/init.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-gcc%2Finit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-gcc%2Finit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-gcc%2Finit.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -55,7 +55,8 @@ EXTERN void _M2_CmdArgs_init (int argc, char *argv[], char *envp[]);\n EXTERN void _M2_M2Preprocess_init (int argc, char *argv[], char *envp[]);\n EXTERN void _M2_M2Error_init (int argc, char *argv[], char *envp[]);\n EXTERN void _M2_M2Search_init (int argc, char *argv[], char *envp[]);\n-EXTERN void _M2_DynamicStringPath_init (int argc, char *argv[], char *envp[]);\n+EXTERN void _M2_DynamicPath_init (int argc, char *argv[], char *envp[]);\n+EXTERN void _M2_PathName_init (int argc, char *argv[], char *envp[]);\n EXTERN void _M2_Indexing_init (int argc, char *argv[], char *envp[]);\n EXTERN void _M2_NameKey_init (int argc, char *argv[], char *envp[]);\n EXTERN void _M2_NumberIO_init (int argc, char *argv[], char *envp[]);\n@@ -142,7 +143,8 @@ init_FrontEndInit (void)\n   _M2_StrLib_init (0, NULL, NULL);\n   _M2_dtoa_init (0, NULL, NULL);\n   _M2_ldtoa_init (0, NULL, NULL);\n-  _M2_DynamicStringPath_init (0, NULL, NULL);\n+  _M2_DynamicPath_init (0, NULL, NULL);\n+  _M2_PathName_init (0, NULL, NULL);\n   _M2_M2Search_init (0, NULL, NULL);\n   _M2_M2Options_init (0, NULL, NULL);\n }"}, {"sha": "eb3d98d0783fda0e4a96316eab694f0d00514261", "filename": "gcc/m2/gm2-gcc/m2decl.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-gcc%2Fm2decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-gcc%2Fm2decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-gcc%2Fm2decl.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -48,7 +48,7 @@ m2decl_DeclareM2linkStaticInitialization (location_t location,\n   m2block_pushGlobalScope ();\n   /* Generate: int M2LINK_StaticInitialization = ScaffoldStatic;  */\n   tree init = m2decl_BuildIntegerConstant (ScaffoldStatic);\n-  tree static_init = m2decl_DeclareKnownVariable (location, \"M2LINK_StaticInitialization\",\n+  tree static_init = m2decl_DeclareKnownVariable (location, \"m2pim_M2LINK_StaticInitialization\",\n \t\t\t\t\t\t  integer_type_node,\n \t\t\t\t\t\t  TRUE, FALSE, FALSE, TRUE, NULL_TREE, init);\n   m2block_popGlobalScope ();\n@@ -65,7 +65,7 @@ m2decl_DeclareM2linkForcedModuleInitOrder (location_t location,\n   tree ptr_to_char = build_pointer_type (char_type_node);\n   TYPE_READONLY (ptr_to_char) = TRUE;\n   tree init = m2decl_BuildPtrToTypeString (location, RuntimeOverride, ptr_to_char);\n-  tree forced_order = m2decl_DeclareKnownVariable (location, \"M2LINK_ForcedModuleInitOrder\",\n+  tree forced_order = m2decl_DeclareKnownVariable (location, \"m2pim_M2LINK_ForcedModuleInitOrder\",\n \t\t\t\t\t\t   ptr_to_char,\n \t\t\t\t\t\t   TRUE, FALSE, FALSE, TRUE, NULL_TREE, init);\n   m2block_popGlobalScope ();"}, {"sha": "7f5173ca474bccef7faaead30ea6f8e22075b6b7", "filename": "gcc/m2/gm2-gcc/m2options.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-gcc%2Fm2options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-gcc%2Fm2options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-gcc%2Fm2options.h?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -132,6 +132,10 @@ EXTERN void M2Options_SetMQ (const char *arg);\n EXTERN char *M2Options_GetMQ (void);\n EXTERN void M2Options_SetObj (const char *arg);\n EXTERN char *M2Options_GetObj (void);\n+EXTERN void M2Options_SetM2Prefix (const char *arg);\n+EXTERN char *M2Options_GetM2Prefix (void);\n+EXTERN void M2Options_SetM2PathName (const char *arg);\n+EXTERN char *M2Options_GetM2PathName (void);\n \n #undef EXTERN\n #endif /* m2options_h.  */"}, {"sha": "162baf75c3fe0176ef73a07324ad6b0f972d6a25", "filename": "gcc/m2/gm2-lang.cc", "status": "modified", "additions": 58, "deletions": 4, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-lang.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -49,12 +49,18 @@ static int insideCppArgs = FALSE;\n /* We default to pim in the absence of fiso.  */\n static bool iso = false;\n \n+typedef struct named_path_s {\n+  std::vector<const char*>path;\n+  const char *name;\n+} named_path;\n+\n+\n /* The language include paths are based on the libraries in use.  */\n static bool allow_libraries = true;\n static const char *flibs = nullptr;\n static const char *iprefix = nullptr;\n static const char *imultilib = nullptr;\n-static std::vector<const char*>Ipaths;\n+static std::vector<named_path>Ipaths;\n static std::vector<const char*>isystem;\n static std::vector<const char*>iquote;\n \n@@ -319,6 +325,31 @@ is_cpp_filename (unsigned int i)\n   return filename_cpp[i];\n }\n \n+static void\n+push_back_Ipath (const char *arg)\n+{\n+  if (Ipaths.empty ())\n+    {\n+      named_path np;\n+      np.path.push_back (arg);\n+      np.name = xstrdup (M2Options_GetM2PathName ());\n+      Ipaths.push_back (np);\n+    }\n+  else\n+    {\n+      if (strcmp (Ipaths.back ().name,\n+\t\t  M2Options_GetM2PathName ()) == 0)\n+\tIpaths.back ().path.push_back (arg);\n+      else\n+\t{\n+\t  named_path np;\n+\t  np.path.push_back (arg);\n+\t  np.name = xstrdup (M2Options_GetM2PathName ());\n+\t  Ipaths.push_back (np);\n+\t}\n+    }\n+}\n+\n /* Handle gm2 specific options.  Return 0 if we didn't do anything.  */\n \n bool\n@@ -337,7 +368,7 @@ gm2_langhook_handle_option (\n   switch (code)\n     {\n     case OPT_I:\n-      Ipaths.push_back (arg);\n+      push_back_Ipath (arg);\n       return 1;\n     case OPT_fiso:\n       M2Options_SetISO (value);\n@@ -517,6 +548,24 @@ gm2_langhook_handle_option (\n       M2Options_SetM2g (value);\n       return 1;\n       break;\n+    case OPT_fm2_pathname_:\n+      if (strcmp (arg, \"-\") == 0)\n+\tM2Options_SetM2PathName (\"\");\n+      else\n+\tM2Options_SetM2PathName (arg);\n+      return 1;\n+      break;\n+    case OPT_fm2_pathnameI:\n+      push_back_Ipath (arg);\n+      return 1;\n+      break;\n+    case OPT_fm2_prefix_:\n+      if (strcmp (arg, \"-\") == 0)\n+\tM2Options_SetM2Prefix (\"\");\n+      else\n+\tM2Options_SetM2Prefix (arg);\n+      return 1;\n+      break;\n     case OPT_iprefix:\n       iprefix = arg;\n       return 1;\n@@ -608,6 +657,7 @@ add_one_import_path (const char *libname)\n   strcat (lib, \"m2\");\n   strcat (lib, dir_sep);\n   strcat (lib, libname);\n+  M2Options_SetM2PathName (libname);\n   M2Options_SetSearchPath (lib);\n }\n \n@@ -669,8 +719,12 @@ gm2_langhook_post_options (const char **pfilename)\n   for (auto *s : iquote)\n     M2Options_SetSearchPath (s);\n   iquote.clear();\n-  for (auto *s : Ipaths)\n-    M2Options_SetSearchPath (s);\n+  for (auto np : Ipaths)\n+    {\n+      M2Options_SetM2PathName (np.name);\n+      for (auto *s : np.path)\n+\tM2Options_SetSearchPath (s);\n+    }\n   Ipaths.clear();\n   for (auto *s : isystem)\n     M2Options_SetSearchPath (s);"}, {"sha": "343dab7fd20e2b81e1ba26022ee25df8ab789abb", "filename": "gcc/m2/gm2-libs-iso/M2RTS.def", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs-iso%2FM2RTS.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs-iso%2FM2RTS.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-iso%2FM2RTS.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -33,10 +33,10 @@ TYPE\n    ArgCVEnvP = PROCEDURE (INTEGER, ADDRESS, ADDRESS) ;\n \n \n-PROCEDURE ConstructModules (applicationmodule: ADDRESS;\n+PROCEDURE ConstructModules (applicationmodule, libname: ADDRESS;\n                             argc: INTEGER; argv, envp: ADDRESS) ;\n \n-PROCEDURE DeconstructModules (applicationmodule: ADDRESS;\n+PROCEDURE DeconstructModules (applicationmodule, libname: ADDRESS;\n                               argc: INTEGER; argv, envp: ADDRESS) ;\n \n \n@@ -46,7 +46,7 @@ PROCEDURE DeconstructModules (applicationmodule: ADDRESS;\n                     explored to determine initialization order.\n *)\n \n-PROCEDURE RegisterModule (name: ADDRESS;\n+PROCEDURE RegisterModule (name, libname: ADDRESS;\n                           init, fini:  ArgCVEnvP;\n                           dependencies: PROC) ;\n \n@@ -56,7 +56,8 @@ PROCEDURE RegisterModule (name: ADDRESS;\n                       module dependantmodule.\n *)\n \n-PROCEDURE RequestDependant (modulename, dependantmodule: ADDRESS) ;\n+PROCEDURE RequestDependant (modulename, libname,\n+                            dependantmodule, dependantlibname: ADDRESS) ;\n \n \n (*"}, {"sha": "a59735a0c323bb7ecbaa677358a786c3995d0fd0", "filename": "gcc/m2/gm2-libs-iso/M2RTS.mod", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs-iso%2FM2RTS.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs-iso%2FM2RTS.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-iso%2FM2RTS.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -71,10 +71,11 @@ VAR\n                       module constructor in turn.\n *)\n \n-PROCEDURE ConstructModules (applicationmodule: ADDRESS;\n+PROCEDURE ConstructModules (applicationmodule, libname: ADDRESS;\n                             argc: INTEGER; argv, envp: ADDRESS) ;\n BEGIN\n-   M2Dependent.ConstructModules (applicationmodule, argc, argv, envp)\n+   M2Dependent.ConstructModules (applicationmodule, libname,\n+                                 argc, argv, envp)\n END ConstructModules ;\n \n \n@@ -83,10 +84,11 @@ END ConstructModules ;\n                         module constructor in turn.\n *)\n \n-PROCEDURE DeconstructModules (applicationmodule: ADDRESS;\n+PROCEDURE DeconstructModules (applicationmodule, libname: ADDRESS;\n                               argc: INTEGER; argv, envp: ADDRESS) ;\n BEGIN\n-   M2Dependent.DeconstructModules (applicationmodule, argc, argv, envp)\n+   M2Dependent.DeconstructModules (applicationmodule, libname,\n+                                   argc, argv, envp)\n END DeconstructModules ;\n \n \n@@ -96,11 +98,11 @@ END DeconstructModules ;\n                     explored to determine initialization order.\n *)\n \n-PROCEDURE RegisterModule (name: ADDRESS;\n+PROCEDURE RegisterModule (name, libname: ADDRESS;\n                           init, fini:  ArgCVEnvP;\n                           dependencies: PROC) ;\n BEGIN\n-   M2Dependent.RegisterModule (name, init, fini, dependencies)\n+   M2Dependent.RegisterModule (name, libname, init, fini, dependencies)\n END RegisterModule ;\n \n \n@@ -109,9 +111,11 @@ END RegisterModule ;\n                       module dependantmodule.\n *)\n \n-PROCEDURE RequestDependant (modulename, dependantmodule: ADDRESS) ;\n+PROCEDURE RequestDependant (modulename, libname,\n+                            dependantmodule, dependantlibname: ADDRESS) ;\n BEGIN\n-   M2Dependent.RequestDependant (modulename, dependantmodule)\n+   M2Dependent.RequestDependant (modulename, libname,\n+                                 dependantmodule, dependantlibname)\n END RequestDependant ;\n \n "}, {"sha": "6d032ee446cd47976d1ddd274f8712c6fed0b6c4", "filename": "gcc/m2/gm2-libs-iso/wrapsock.c", "status": "removed", "additions": 0, "deletions": 260, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461d3c84a0e5ad045ee54631901cc953d6befa20/gcc%2Fm2%2Fgm2-libs-iso%2Fwrapsock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461d3c84a0e5ad045ee54631901cc953d6befa20/gcc%2Fm2%2Fgm2-libs-iso%2Fwrapsock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-iso%2Fwrapsock.c?ref=461d3c84a0e5ad045ee54631901cc953d6befa20", "patch": "@@ -1,260 +0,0 @@\n-/* wrapsock.c implements access to low level client socket primitives.\n-\n-Copyright (C) 2008-2023 Free Software Foundation, Inc.\n-Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n-\n-This file is part of GNU Modula-2.\n-\n-GNU Modula-2 is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GNU Modula-2 is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include <p2c/p2c.h>\n-\n-#if defined(HAVE_SYS_TYPES_H)\n-#   include <sys/types.h>\n-#endif\n-\n-#if defined(HAVE_SYS_SOCKET_H)\n-#   include <sys/socket.h>\n-#endif\n-\n-#include <netinet/in.h>\n-#include <netdb.h>\n-\n-#if defined(HAVE_UNISTD_H)\n-#  include <unistd.h>\n-#endif\n-\n-#if defined(HAVE_SIGNAL_H)\n-#  include <signal.h>\n-#endif\n-\n-#if defined(HAVE_SYS_ERRNO_H)\n-#  include <sys/errno.h>\n-#endif\n-\n-#if defined(HAVE_ERRNO_H)\n-#  include <errno.h>\n-#endif\n-\n-#if defined(HAVE_MALLOC_H)\n-#  include <malloc.h>\n-#endif\n-\n-#if defined(HAVE_SIGNAL_H)\n-#  include <signal.h>\n-#endif\n-\n-#if defined(HAVE_STRING_H)\n-#  include <string.h>\n-#endif\n-\n-#if defined(HAVE_STDLIB_H)\n-#  include <stdlib.h>\n-#endif\n-\n-#if !defined(TRUE)\n-#  define TRUE  (1==1)\n-#endif\n-#if !defined(FALSE)\n-#  define FALSE (1==0)\n-#endif\n-\n-#include \"ChanConsts.h\"\n-\n-#define MAXHOSTNAME 1024\n-#define MAXPBBUF    1024\n-\n-\n-typedef struct {\n-  char                hostname[MAXHOSTNAME];\n-  struct hostent     *hp;\n-  struct sockaddr_in  sa;\n-  int                 sockFd;\n-  int                 portNo;\n-  int                 hasChar;\n-  char                pbChar[MAXPBBUF];\n-} clientInfo;\n-\n-static openResults clientConnect (clientInfo *c);\n-\n-\n-/*\n- *  clientOpen - returns an ISO Modula-2 OpenResult.\n- *               It attempts to connect to:  hostname:portNo.\n- *               If successful then the data structure, c,\n- *               will have its fields initialized.\n- */\n-\n-openResults wrapsock_clientOpen (clientInfo *c, char *hostname,\n-\t\t\t\t unsigned int length, int portNo)\n-{\n-  /* remove SIGPIPE which is raised on the server if the client is killed */\n-  signal(SIGPIPE, SIG_IGN);\n-\n-  c->hp = gethostbyname(hostname);\n-  if (c->hp == NULL)\n-    return noSuchFile;\n-\n-  memset((void *)&c->sa, 0, sizeof(c->sa));\n-  c->sa.sin_family = AF_INET;\n-  memcpy((void *)&c->sa.sin_addr, (void *)c->hp->h_addr, c->hp->h_length);\n-  c->portNo        = portNo;\n-  c->sa.sin_port   = htons(portNo);\n-  c->hasChar       = 0;\n-  /*\n-   *  Open a TCP socket (an Internet stream socket)\n-   */\n-\n-  c->sockFd = socket(c->hp->h_addrtype, SOCK_STREAM, 0);\n-  return clientConnect(c);\n-}\n-\n-/*\n- *  clientOpenIP - returns an ISO Modula-2 OpenResult.\n- *                 It attempts to connect to:  ipaddress:portNo.\n- *                 If successful then the data structure, c,\n- *                 will have its fields initialized.\n- */\n-\n-openResults wrapsock_clientOpenIP (clientInfo *c, unsigned int ip, int portNo)\n-{\n-  /* remove SIGPIPE which is raised on the server if the client is killed */\n-  signal(SIGPIPE, SIG_IGN);\n-\n-  memset((void *)&c->sa, 0, sizeof(c->sa));\n-  c->sa.sin_family = AF_INET;\n-  memcpy((void *)&c->sa.sin_addr, (void *)&ip, sizeof(ip));\n-  c->portNo        = portNo;\n-  c->sa.sin_port   = htons(portNo);\n-\n-  /*\n-   * Open a TCP socket (an Internet stream socket)\n-   */\n-\n-  c->sockFd = socket(PF_INET, SOCK_STREAM, 0);\n-  return clientConnect(c);\n-}\n-\n-/*\n- *  clientConnect - returns an ISO Modula-2 OpenResult\n- *                  once a connect has been performed.\n- *                  If successful the clientInfo will\n- *                  include the file descriptor ready\n- *                  for read/write operations.\n- */\n-\n-static openResults clientConnect (clientInfo *c)\n-{\n-  if (connect(c->sockFd, (struct sockaddr *)&c->sa, sizeof(c->sa)) < 0)\n-    return noSuchFile;\n-\n-  return opened;\n-}\n-\n-/*\n- *  getClientPortNo - returns the portNo from structure, c.\n- */\n-\n-int wrapsock_getClientPortNo (clientInfo *c)\n-{\n-  return c->portNo;\n-}\n-\n-/*\n- *  getClientHostname - fills in the hostname of the server\n- *                      the to which the client is connecting.\n- */\n-\n-void wrapsock_getClientHostname (clientInfo *c,\n-\t\t\t\t char *hostname, unsigned int high)\n-{\n-  strncpy(hostname, c->hostname, high+1);\n-}\n-\n-/*\n- *  getClientSocketFd - returns the sockFd from structure, c.\n- */\n-\n-int wrapsock_getClientSocketFd (clientInfo *c)\n-{\n-  return c->sockFd;\n-}\n-\n-/*\n- *  getClientIP - returns the sockFd from structure, s.\n- */\n-\n-unsigned int wrapsock_getClientIP (clientInfo *c)\n-{\n-#if 0\n-  printf(\"client ip = %s\\n\", inet_ntoa (c->sa.sin_addr.s_addr));\n-#endif\n-  return c->sa.sin_addr.s_addr;\n-}\n-\n-/*\n- *  getPushBackChar - returns TRUE if a pushed back character\n- *                    is available.\n- */\n-\n-unsigned int wrapsock_getPushBackChar (clientInfo *c, char *ch)\n-{\n-  if (c->hasChar > 0) {\n-    c->hasChar--;\n-    *ch = c->pbChar[c->hasChar];\n-    return TRUE;\n-  }\n-  return FALSE;\n-}\n-\n-/*\n- *  setPushBackChar - returns TRUE if it is able to push back a\n- *                    character.\n- */\n-\n-unsigned int wrapsock_setPushBackChar (clientInfo *c, char ch)\n-{\n-  if (c->hasChar == MAXPBBUF)\n-    return FALSE;\n-  c->pbChar[c->hasChar] = ch;\n-  c->hasChar++;\n-  return TRUE;\n-}\n-\n-/*\n- *  getSizeOfClientInfo - returns the sizeof (opaque data type).\n- */\n-\n-unsigned int wrapsock_getSizeOfClientInfo (void)\n-{\n-  return sizeof (clientInfo);\n-}\n-\n-/*\n- *  GNU Modula-2 link fodder.\n- */\n-\n-void _M2_wrapsock_init (void)\n-{\n-}\n-\n-void _M2_wrapsock_finish (void)\n-{\n-}"}, {"sha": "dafdb665ed5fdb0f5748c0d7687d8b1879f2f36e", "filename": "gcc/m2/gm2-libs-iso/wraptime.c", "status": "removed", "additions": 0, "deletions": 292, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461d3c84a0e5ad045ee54631901cc953d6befa20/gcc%2Fm2%2Fgm2-libs-iso%2Fwraptime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461d3c84a0e5ad045ee54631901cc953d6befa20/gcc%2Fm2%2Fgm2-libs-iso%2Fwraptime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-iso%2Fwraptime.c?ref=461d3c84a0e5ad045ee54631901cc953d6befa20", "patch": "@@ -1,292 +0,0 @@\n-/* wraptime.c provides access to time functions.\n-\n-Copyright (C) 2009-2023 Free Software Foundation, Inc.\n-Contributed by Gaius Mulley <gaius@glam.ac.uk>.\n-\n-This file is part of GNU Modula-2.\n-\n-GNU Modula-2 is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GNU Modula-2 is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"gm2-libs-host.h\"\n-\n-#if defined(HAVE_SYS_TYPES_H)\n-#   include <sys/types.h>\n-#endif\n-\n-#if defined(HAVE_SYS_TIME_H)\n-#   include <sys/time.h>\n-#endif\n-\n-#if defined(HAVE_TIME_H)\n-#   include <time.h>\n-#endif\n-\n-#if defined(HAVE_MALLOC_H)\n-#  include <malloc.h>\n-#endif\n-\n-#if !defined(TRUE)\n-#  define TRUE  (1==1)\n-#endif\n-#if !defined(FALSE)\n-#  define FALSE (1==0)\n-#endif\n-\n-/* InitTimeval returns a newly created opaque type.  */\n-\n-struct timeval *\n-wraptime_InitTimeval (void)\n-{\n-#if defined(HAVE_TIMEVAL)\n-  return (struct timeval *) malloc (sizeof (struct timeval));\n-#else\n-  return NULL;\n-#endif\n-}\n-\n-/* KillTimeval deallocates the memory associated with an\n-   opaque type.  */\n-\n-struct timeval *\n-wraptime_KillTimeval (void *tv)\n-{\n-  free (tv);\n-  return NULL;\n-}\n-\n-/* InitTimezone returns a newly created opaque type.  */\n-\n-struct timezone *\n-wraptime_InitTimezone (void)\n-{\n-  return (struct timezone *) malloc (sizeof (struct timezone));\n-}\n-\n-/* KillTimezone deallocates the memory associated with an\n-   opaque type.  */\n-\n-struct timezone *\n-wraptime_KillTimezone (struct timezone *tv)\n-{\n-  free (tv);\n-  return NULL;\n-}\n-\n-/* InitTM returns a newly created opaque type.  */\n-\n-struct tm *\n-wraptime_InitTM (void)\n-{\n-  return (struct tm *) malloc (sizeof (struct tm));\n-}\n-\n-/* KillTM deallocates the memory associated with an opaque type.  */\n-\n-struct tm *\n-wraptime_KillTM (struct tm *tv)\n-{\n-  free (tv);\n-  return NULL;\n-}\n-\n-/* gettimeofday calls gettimeofday(2) with the same parameters, tv,\n-   and, tz.  It returns 0 on success.  */\n-\n-int\n-wraptime_gettimeofday (void *tv, struct timezone *tz)\n-{\n-  return gettimeofday (tv, tz);\n-}\n-\n-/* settimeofday calls settimeofday(2) with the same parameters, tv,\n-   and, tz.  It returns 0 on success.  */\n-\n-int\n-wraptime_settimeofday (void *tv, struct timezone *tz)\n-{\n-  return settimeofday (tv, tz);\n-}\n-\n-/* wraptime_GetFractions returns the tv_usec field inside the timeval\n-   structure.  */\n-\n-#if defined(HAVE_TIMEVAL)\n-unsigned int\n-wraptime_GetFractions (struct timeval *tv)\n-{\n-  return (unsigned int) tv->tv_usec;\n-}\n-#else\n-unsigned int\n-wraptime_GetFractions (void *tv)\n-{\n-  return 0;\n-}\n-#endif\n-\n-/* localtime_r returns the tm parameter, m, after it has been assigned\n-   with appropriate contents determined by, tv.  Notice that this\n-   procedure function expects, timeval, as its first parameter and not\n-   a time_t (as expected by the posix equivalent).  */\n-\n-#if defined(HAVE_TIMEVAL)\n-struct tm *\n-wraptime_localtime_r (struct timeval *tv, struct tm *m)\n-{\n-  return localtime_r (&tv->tv_sec, m);\n-}\n-#else\n-struct tm *\n-wraptime_localtime_r (void *tv, struct tm *m)\n-{\n-  return m;\n-}\n-#endif\n-\n-/* wraptime_GetYear returns the year from the structure, m.  */\n-\n-unsigned int\n-wraptime_GetYear (struct tm *m)\n-{\n-  return m->tm_year;\n-}\n-\n-/* wraptime_GetMonth returns the month from the structure, m.  */\n-\n-unsigned int\n-wraptime_GetMonth (struct tm *m)\n-{\n-  return m->tm_mon;\n-}\n-\n-/* wraptime_GetDay returns the day of the month from the structure, m.  */\n-\n-unsigned int\n-wraptime_GetDay (struct tm *m)\n-{\n-  return m->tm_mday;\n-}\n-\n-/* wraptime_GetHour returns the hour of the day from the structure, m.  */\n-\n-unsigned int\n-wraptime_GetHour (struct tm *m)\n-{\n-  return m->tm_hour;\n-}\n-\n-/* wraptime_GetMinute returns the minute within the hour from the structure, m.  */\n-\n-unsigned int\n-wraptime_GetMinute (struct tm *m)\n-{\n-  return m->tm_min;\n-}\n-\n-/* wraptime_GetSecond returns the seconds in the minute from the\n-   structure, m.  The return value will always be in the range 0..59.\n-   A leap minute of value 60 will be truncated to 59.  */\n-\n-unsigned int\n-wraptime_GetSecond (struct tm *m)\n-{\n-  if (m->tm_sec == 60)\n-    return 59;\n-  else\n-    return m->tm_sec;\n-}\n-\n-/* wraptime_GetSummerTime returns true if summer time is in effect.  */\n-\n-unsigned int\n-wraptime_GetSummerTime (struct timezone *tz)\n-{\n-  return tz->tz_dsttime != 0;\n-}\n-\n-/* wraptime_GetDST returns the number of minutes west of GMT.  */\n-\n-int\n-wraptime_GetDST (struct timezone *tz)\n-{\n-  return tz->tz_minuteswest;\n-}\n-\n-/* SetTimezone set the timezone field inside timeval, tv.  */\n-\n-void\n-wraptime_SetTimezone (struct timezone *tz,\n-\t\t      int zone, int minuteswest)\n-{\n-  tz->tz_dsttime = zone;\n-  tz->tz_minuteswest = minuteswest;\n-}\n-\n-/* SetTimeval sets the fields in tm, t, with:\n-   second, minute, hour, day, month, year, fractions.  */\n-\n-#if defined(HAVE_TIMEVAL)\n-void\n-wraptime_SetTimeval (struct tm *t,\n-\t\t     unsigned int second,\n-\t\t     unsigned int minute,\n-\t\t     unsigned int hour,\n-\t\t     unsigned int day,\n-\t\t     unsigned int month,\n-\t\t     unsigned int year,\n-\t\t     unsigned int yday,\n-\t\t     unsigned int wday,\n-\t\t     unsigned int isdst)\n-{\n-  t->tm_sec = second;\n-  t->tm_min = minute;\n-  t->tm_hour = hour;\n-  t->tm_mday = day;\n-  t->tm_mon = month;\n-  t->tm_year = year;\n-  t->tm_yday = yday;\n-  t->tm_wday = wday;\n-  t->tm_isdst = isdst;\n-}\n-#else\n-wraptime_SetTimeval (void *t,\n-\t\t     unsigned int second,\n-\t\t     unsigned int minute,\n-\t\t     unsigned int hour,\n-\t\t     unsigned int day,\n-\t\t     unsigned int month,\n-\t\t     unsigned int year,\n-\t\t     unsigned int yday,\n-\t\t     unsigned int wday,\n-\t\t     unsigned int isdst)\n-{\n-  return t;\n-}\n-#endif\n-\n-/* init/finish functions for the module.  */\n-\n-void\n-_M2_wraptime_init ()\n-{}\n-\n-void\n-_M2_wraptime_finish ()\n-{}"}, {"sha": "1952d9107f6929175a271b764123c27096ca4806", "filename": "gcc/m2/gm2-libs-min/M2RTS.def", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs-min%2FM2RTS.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs-min%2FM2RTS.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-min%2FM2RTS.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -34,18 +34,36 @@ FROM SYSTEM IMPORT ADDRESS ;\n TYPE\n    ArgCVEnvP = PROCEDURE (INTEGER, ADDRESS, ADDRESS) ;\n \n+\n (*\n    all these procedures do nothing except satisfy the linker.\n *)\n \n-PROCEDURE ConstructModules (applicationmodule: ADDRESS;\n+PROCEDURE ConstructModules (applicationmodule, libname: ADDRESS;\n                             argc: INTEGER; argv, envp: ADDRESS) ;\n-PROCEDURE DeconstructModules (applicationmodule: ADDRESS;\n+\n+PROCEDURE DeconstructModules (applicationmodule, libname: ADDRESS;\n                               argc: INTEGER; argv, envp: ADDRESS) ;\n-PROCEDURE RegisterModule (name: ADDRESS;\n+\n+\n+(*\n+   RegisterModule - adds module name to the list of outstanding\n+                    modules which need to have their dependencies\n+                    explored to determine initialization order.\n+*)\n+\n+PROCEDURE RegisterModule (name, libname: ADDRESS;\n                           init, fini:  ArgCVEnvP;\n                           dependencies: PROC) ;\n-PROCEDURE RequestDependant (modulename, dependantmodule: ADDRESS) ;\n+\n+(*\n+   RequestDependant - used to specify that modulename is dependant upon\n+                      module dependantmodule.\n+*)\n+\n+PROCEDURE RequestDependant (modulename, libname,\n+                            dependantmodule, dependantlibname: ADDRESS) ;\n+\n PROCEDURE ExecuteTerminationProcedures ;\n PROCEDURE ExecuteInitialProcedures ;\n PROCEDURE HALT <* noreturn *> ;"}, {"sha": "1765531ce85fb7b6e3c41861817c63d5b3b56080", "filename": "gcc/m2/gm2-libs-min/M2RTS.mod", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs-min%2FM2RTS.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs-min%2FM2RTS.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-min%2FM2RTS.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -30,18 +30,31 @@ IMPORT libc, SYSTEM ;\n (* we reference these to ensure they are dragged in to the link *)\n \n \n-PROCEDURE ConstructModules (applicationmodule: ADDRESS;\n+PROCEDURE ConstructModules (applicationmodule, libname: ADDRESS;\n                             argc: INTEGER; argv, envp: ADDRESS) ;\n BEGIN\n END ConstructModules ;\n \n \n-PROCEDURE DeconstructModules (applicationmodule: ADDRESS;\n+PROCEDURE DeconstructModules (applicationmodule, libname: ADDRESS;\n                               argc: INTEGER; argv, envp: ADDRESS) ;\n BEGIN\n END DeconstructModules ;\n \n \n+(*\n+   RegisterModule - adds module name to the list of outstanding\n+                    modules which need to have their dependencies\n+                    explored to determine initialization order.\n+*)\n+\n+PROCEDURE RegisterModule (name, libname: ADDRESS;\n+                          init, fini:  ArgCVEnvP;\n+                          dependencies: PROC) ;\n+BEGIN\n+END RegisterModule ;\n+\n+\n (* all these procedures do nothing except satisfy the linker.  *)\n \n PROCEDURE ExecuteTerminationProcedures ;\n@@ -65,27 +78,15 @@ BEGIN\n END NoException ;\n \n \n-PROCEDURE RequestDependant (modulename, dependantmodule: ADDRESS) ;\n-BEGIN\n-END RequestDependant ;\n-\n+(*\n+   RequestDependant - used to specify that modulename is dependant upon\n+                      module dependantmodule.\n+*)\n \n-PROCEDURE ConstructModules (applicationmodule: ADDRESS;\n-                            argc: INTEGER; argv, envp: ADDRESS) ;\n+PROCEDURE RequestDependant (modulename, libname,\n+                            dependantmodule, dependantlibname: ADDRESS) ;\n BEGIN\n-END ConstructModules ;\n-\n-\n-PROCEDURE DeconstructModules (applicationmodule: ADDRESS;\n-                              argc: INTEGER; argv, envp: ADDRESS) ;\n-BEGIN\n-END DeconstructModules ;\n-\n+END RequestDependant ;\n \n-PROCEDURE RegisterModule (name: ADDRESS;\n-                          init, fini:  ArgCVEnvP;\n-                          dependencies: PROC) ;\n-BEGIN\n-END RegisterModule ;\n \n END M2RTS."}, {"sha": "4b77a0704c97d53336a3addc7777ebc458899649", "filename": "gcc/m2/gm2-libs/M2Dependent.def", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs%2FM2Dependent.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs%2FM2Dependent.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2FM2Dependent.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -33,10 +33,10 @@ TYPE\n    ArgCVEnvP = PROCEDURE (INTEGER, ADDRESS, ADDRESS) ;\n \n \n-PROCEDURE ConstructModules (applicationmodule: ADDRESS;\n+PROCEDURE ConstructModules (applicationmodule, libname: ADDRESS;\n                             argc: INTEGER; argv, envp: ADDRESS) ;\n \n-PROCEDURE DeconstructModules (applicationmodule: ADDRESS;\n+PROCEDURE DeconstructModules (applicationmodule, libname: ADDRESS;\n                               argc: INTEGER; argv, envp: ADDRESS) ;\n \n \n@@ -46,17 +46,19 @@ PROCEDURE DeconstructModules (applicationmodule: ADDRESS;\n                     explored to determine initialization order.\n *)\n \n-PROCEDURE RegisterModule (name: ADDRESS;\n+PROCEDURE RegisterModule (modulename, libname: ADDRESS;\n                           init, fini:  ArgCVEnvP;\n                           dependencies: PROC) ;\n \n \n (*\n-   RequestDependant - used to specify that modulename is dependant upon\n-                      module dependantmodule.\n+   RequestDependant - used to specify that modulename:libname\n+                      is dependant upon\n+                      module dependantmodule:dependantlibname\n *)\n \n-PROCEDURE RequestDependant (modulename, dependantmodule: ADDRESS) ;\n+PROCEDURE RequestDependant (modulename, libname,\n+                            dependantmodule, dependantlibname: ADDRESS) ;\n \n \n END M2Dependent."}, {"sha": "cc7e9cf3703d51080245db7b88723d10ea059968", "filename": "gcc/m2/gm2-libs/M2Dependent.mod", "status": "modified", "additions": 289, "deletions": 92, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs%2FM2Dependent.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs%2FM2Dependent.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2FM2Dependent.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -27,11 +27,11 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n IMPLEMENTATION MODULE M2Dependent ;\n \n \n-FROM libc IMPORT abort, exit, write, getenv, printf ;\n+FROM libc IMPORT abort, exit, write, getenv, printf, snprintf, strncpy ;\n (* FROM Builtins IMPORT strncmp, strcmp ;  not available during bootstrap.  *)\n FROM M2LINK IMPORT ForcedModuleInitOrder, StaticInitialization, PtrToChar ;\n FROM ASCII IMPORT nul, nl ;\n-FROM SYSTEM IMPORT ADR ;\n+FROM SYSTEM IMPORT ADR, SIZE ;\n FROM Storage IMPORT ALLOCATE ;\n FROM StrLib IMPORT StrCopy, StrLen, StrEqual ;\n \n@@ -52,7 +52,8 @@ TYPE\n                     END ;\n \n    ModuleChain = POINTER TO RECORD\n-                               name      : ADDRESS ;\n+                               name,\n+                               libname   : ADDRESS ;\n                                init,\n                                fini      : ArgCVEnvP ;\n                                dependency: DependencyList ;\n@@ -63,7 +64,9 @@ TYPE\n VAR\n    Modules        : ARRAY DependencyState OF ModuleChain ;\n    Initialized,\n+   WarningTrace,\n    ModuleTrace,\n+   HexTrace,\n    DependencyTrace,\n    PreTrace,\n    PostTrace,\n@@ -75,20 +78,27 @@ VAR\n                   ModuleChain.\n *)\n \n-PROCEDURE CreateModule (name: ADDRESS;\n+PROCEDURE CreateModule (name, libname: ADDRESS;\n                         init, fini:  ArgCVEnvP;\n                         dependencies: PROC) : ModuleChain ;\n VAR\n-   mptr: ModuleChain ;\n+   mptr  : ModuleChain ;\n+   p0, p1: ADDRESS ;\n BEGIN\n    NEW (mptr) ;\n    mptr^.name := name ;\n+   mptr^.libname := libname ;\n    mptr^.init := init ;\n    mptr^.fini := fini ;\n    mptr^.dependency.proc := dependencies ;\n    mptr^.dependency.state := unregistered ;\n    mptr^.prev := NIL ;\n    mptr^.next := NIL ;\n+   IF HexTrace\n+   THEN\n+      printf (\"   (init: %p  fini: %p\", init, fini) ;\n+      printf (\"  dep: %p)\", dependencies)\n+   END ;\n    RETURN mptr\n END CreateModule ;\n \n@@ -157,20 +167,54 @@ END onChain ;\n \n \n (*\n-   LookupModuleN - lookup module from the state list.  The string is limited\n-                   to nchar.\n+   max -\n+*)\n+\n+PROCEDURE max (a, b: CARDINAL) : CARDINAL ;\n+BEGIN\n+   IF a > b\n+   THEN\n+      RETURN a\n+   ELSE\n+      RETURN b\n+   END\n+END max ;\n+\n+\n+(*\n+   min -\n+*)\n+\n+PROCEDURE min (a, b: CARDINAL) : CARDINAL ;\n+BEGIN\n+   IF a < b\n+   THEN\n+      RETURN a\n+   ELSE\n+      RETURN b\n+   END\n+END min ;\n+\n+\n+(*\n+   LookupModuleN - lookup module from the state list.\n+                   The strings lengths are known.\n *)\n \n PROCEDURE LookupModuleN (state: DependencyState;\n-                         name: ADDRESS; nchar: CARDINAL) : ModuleChain ;\n+                         name: ADDRESS; namelen: CARDINAL;\n+                         libname: ADDRESS; libnamelen: CARDINAL) : ModuleChain ;\n VAR\n    ptr: ModuleChain ;\n BEGIN\n    IF Modules[state] # NIL\n    THEN\n       ptr := Modules[state] ;\n       REPEAT\n-         IF strncmp (ptr^.name, name, nchar) = 0\n+         IF (strncmp (ptr^.name, name,\n+                      max (namelen, strlen (ptr^.name))) = 0) AND\n+            (strncmp (ptr^.libname, libname,\n+                      max (libnamelen, strlen (ptr^.libname))) = 0)\n          THEN\n             RETURN ptr\n          END ;\n@@ -186,9 +230,11 @@ END LookupModuleN ;\n                   module name from a particular list.\n *)\n \n-PROCEDURE LookupModule (state: DependencyState; name: ADDRESS) : ModuleChain ;\n+PROCEDURE LookupModule (state: DependencyState; name, libname: ADDRESS) : ModuleChain ;\n BEGIN\n-   RETURN LookupModuleN (state, name, strlen (name))\n+   RETURN LookupModuleN (state,\n+                         name, strlen (name),\n+                         libname, strlen (libname))\n END LookupModule ;\n \n \n@@ -254,7 +300,10 @@ END strcmp ;\n \n PROCEDURE strncmp (a, b: PtrToChar; n: CARDINAL) : INTEGER ;\n BEGIN\n-   IF (a # NIL) AND (b # NIL) AND (n > 0)\n+   IF n = 0\n+   THEN\n+      RETURN 0\n+   ELSIF (a # NIL) AND (b # NIL)\n    THEN\n       IF a = b\n       THEN\n@@ -316,15 +365,49 @@ END traceprintf ;\n *)\n \n PROCEDURE traceprintf2 (flag: BOOLEAN; str: ARRAY OF CHAR; arg: ADDRESS) ;\n+VAR\n+   ch: CHAR ;\n BEGIN\n    IF flag\n    THEN\n       toCString (str) ;\n+      IF arg = NIL\n+      THEN\n+         ch := 0C ;\n+         arg := ADR (ch)\n+      END ;\n       printf (str, arg)\n    END\n END traceprintf2 ;\n \n \n+(*\n+   traceprintf3 - wrap printf with a boolean flag.\n+*)\n+\n+PROCEDURE traceprintf3 (flag: BOOLEAN; str: ARRAY OF CHAR;\n+                        arg1, arg2: ADDRESS) ;\n+VAR\n+   ch: CHAR ;\n+BEGIN\n+   IF flag\n+   THEN\n+      toCString (str) ;\n+      IF arg1 = NIL\n+      THEN\n+         ch := 0C ;\n+         arg1 := ADR (ch)\n+      END ;\n+      IF arg2 = NIL\n+      THEN\n+         ch := 0C ;\n+         arg2 := ADR (ch)\n+      END ;\n+      printf (str, arg1, arg2)\n+   END\n+END traceprintf3 ;\n+\n+\n (*\n    moveTo - moves mptr to the new list determined by newstate.\n             It updates the mptr state appropriately.\n@@ -345,22 +428,24 @@ END moveTo ;\n    ResolveDependant -\n *)\n \n-PROCEDURE ResolveDependant (mptr: ModuleChain; currentmodule: ADDRESS) ;\n+PROCEDURE ResolveDependant (mptr: ModuleChain; currentmodule, libname: ADDRESS) ;\n BEGIN\n    IF mptr = NIL\n    THEN\n-      traceprintf (DependencyTrace, \"   module has not been registered via a global constructor\\n\");\n+      traceprintf3 (DependencyTrace,\n+                    \"   module %s [%s] has not been registered via a global constructor\\n\",\n+                    currentmodule, libname);\n    ELSE\n       IF onChain (started, mptr)\n       THEN\n          traceprintf (DependencyTrace, \"   processing...\\n\");\n       ELSE\n          moveTo (started, mptr) ;\n-         traceprintf2 (DependencyTrace, \"   starting: %s\\n\",\n-                       currentmodule);\n+         traceprintf3 (DependencyTrace, \"   starting: %s [%s]\\n\",\n+                       currentmodule, libname);\n          mptr^.dependency.proc ;  (* Invoke and process the dependency graph.  *)\n-         traceprintf2 (DependencyTrace, \"   finished: %s\\n\",\n-                       currentmodule);\n+         traceprintf3 (DependencyTrace, \"   finished: %s [%s]\\n\",\n+                       currentmodule, libname);\n          moveTo (ordered, mptr)\n       END\n    END\n@@ -373,12 +458,14 @@ END ResolveDependant ;\n                       if we are not using StaticInitialization.\n *)\n \n-PROCEDURE RequestDependant (modulename, dependantmodule: ADDRESS) ;\n+PROCEDURE RequestDependant (modulename, libname,\n+                            dependantmodule, dependantlibname: ADDRESS) ;\n BEGIN\n    CheckInitialized ;\n    IF NOT StaticInitialization\n    THEN\n-      PerformRequestDependant (modulename, dependantmodule)\n+      PerformRequestDependant (modulename, libname,\n+                               dependantmodule, dependantlibname)\n    END\n END RequestDependant ;\n \n@@ -390,66 +477,73 @@ END RequestDependant ;\n                              resolved.\n *)\n \n-PROCEDURE PerformRequestDependant (modulename, dependantmodule: ADDRESS) ;\n+PROCEDURE PerformRequestDependant (modulename, libname,\n+                                   dependantmodule, dependantlibname: ADDRESS) ;\n VAR\n    mptr: ModuleChain ;\n BEGIN\n-   traceprintf2 (DependencyTrace, \"  module %s\", modulename) ;\n+   traceprintf3 (DependencyTrace, \"  module %s [%s]\", modulename, libname) ;\n    IF dependantmodule = NIL\n    THEN\n-      traceprintf2 (DependencyTrace, \" has finished its import graph\\n\", modulename) ;\n-      mptr := LookupModule (unordered, modulename) ;\n+      traceprintf (DependencyTrace, \" has finished its import graph\\n\") ;\n+      mptr := LookupModule (unordered, modulename, libname) ;\n       IF mptr # NIL\n       THEN\n-         traceprintf2 (DependencyTrace, \"  module %s is now ordered\\n\", modulename) ;\n+         traceprintf3 (DependencyTrace, \"  module %s [%s] is now ordered\\n\",\n+                       modulename, libname) ;\n          moveTo (ordered, mptr)\n       END\n    ELSE\n-      traceprintf2 (DependencyTrace, \" imports from %s\\n\", dependantmodule) ;\n-      mptr := LookupModule (ordered, dependantmodule) ;\n+      traceprintf3 (DependencyTrace, \" imports from %s [%s]\\n\",\n+                    dependantmodule, dependantlibname) ;\n+      mptr := LookupModule (ordered, dependantmodule, dependantlibname) ;\n       IF mptr = NIL\n       THEN\n-         traceprintf2 (DependencyTrace, \"  module %s is not ordered\\n\", dependantmodule) ;\n-         mptr := LookupModule (unordered, dependantmodule) ;\n+         traceprintf3 (DependencyTrace, \"  module %s [%s] is not ordered\\n\",\n+                       dependantmodule, dependantlibname) ;\n+         mptr := LookupModule (unordered, dependantmodule, dependantlibname) ;\n          IF mptr = NIL\n          THEN\n-            traceprintf2 (DependencyTrace, \"  module %s is not unordered\\n\", dependantmodule) ;\n-            mptr := LookupModule (started, dependantmodule) ;\n+            traceprintf3 (DependencyTrace, \"  module %s [%s] is not unordered\\n\",\n+                          dependantmodule, dependantlibname) ;\n+            mptr := LookupModule (started, dependantmodule, dependantlibname) ;\n             IF mptr = NIL\n             THEN\n-               traceprintf2 (DependencyTrace, \"  module %s has not started\\n\", dependantmodule) ;\n-               traceprintf2 (DependencyTrace, \"  module %s attempting to import from\",\n-                             modulename) ;\n-               traceprintf2 (DependencyTrace, \" %s which has not registered itself via a constructor\\n\",\n-                             dependantmodule)\n+               traceprintf3 (DependencyTrace, \"  module %s [%s] has not started\\n\",\n+                             dependantmodule, dependantlibname) ;\n+               traceprintf3 (DependencyTrace, \"  module %s [%s] attempting to import from\",\n+                             modulename, libname) ;\n+               traceprintf3 (DependencyTrace, \" %s [%s] which has not registered itself via a constructor\\n\",\n+                             dependantmodule, dependantlibname)\n             ELSE\n-               traceprintf2 (DependencyTrace, \"  module %s has registered itself and has started\\n\", dependantmodule)\n+               traceprintf3 (DependencyTrace, \"  module %s [%s] has registered itself and has started\\n\",\n+                             dependantmodule, dependantlibname)\n             END\n          ELSE\n-            traceprintf2 (DependencyTrace, \"  module %s resolving\\n\", dependantmodule) ;\n-            ResolveDependant (mptr, dependantmodule)\n+            traceprintf3 (DependencyTrace, \"  module %s [%s] resolving\\n\", dependantmodule, dependantlibname) ;\n+            ResolveDependant (mptr, dependantmodule, dependantlibname)\n          END\n       ELSE\n-         traceprintf2 (DependencyTrace, \"  module %s \", modulename) ;\n-         traceprintf2 (DependencyTrace, \" dependant %s is ordered\\n\", dependantmodule)\n+         traceprintf3 (DependencyTrace, \"  module %s [%s]\", modulename, libname) ;\n+         traceprintf3 (DependencyTrace, \" dependant %s [%s] is ordered\\n\", dependantmodule, dependantlibname)\n       END\n    END\n END PerformRequestDependant ;\n \n \n (*\n-   ResolveDependencies - resolve dependencies for currentmodule.\n+   ResolveDependencies - resolve dependencies for currentmodule, libname.\n *)\n \n-PROCEDURE ResolveDependencies (currentmodule: ADDRESS) ;\n+PROCEDURE ResolveDependencies (currentmodule, libname: ADDRESS) ;\n VAR\n    mptr: ModuleChain ;\n BEGIN\n-   mptr := LookupModule (unordered, currentmodule) ;\n+   mptr := LookupModule (unordered, currentmodule, libname) ;\n    WHILE mptr # NIL DO\n-      traceprintf2 (DependencyTrace, \"   attempting to resolve the dependants for %s\\n\",\n-                    currentmodule);\n-      ResolveDependant (mptr, currentmodule) ;\n+      traceprintf3 (DependencyTrace, \"   attempting to resolve the dependants for %s [%s]\\n\",\n+                    currentmodule, libname);\n+      ResolveDependant (mptr, currentmodule, libname) ;\n       mptr := Modules[unordered]\n    END\n END ResolveDependencies ;\n@@ -459,18 +553,23 @@ END ResolveDependencies ;\n    DisplayModuleInfo - displays all module in the state.\n *)\n \n-PROCEDURE DisplayModuleInfo (state: DependencyState; name: ARRAY OF CHAR) ;\n+PROCEDURE DisplayModuleInfo (state: DependencyState; desc: ARRAY OF CHAR) ;\n VAR\n    mptr : ModuleChain ;\n    count: CARDINAL ;\n BEGIN\n    IF Modules[state] # NIL\n    THEN\n-      printf (\"%s modules\\n\", ADR (name)) ;\n+      printf (\"%s modules\\n\", ADR (desc)) ;\n       mptr := Modules[state] ;\n       count := 0 ;\n       REPEAT\n-         printf (\"  %d  %s\", count, mptr^.name) ;\n+         IF mptr^.name = NIL\n+         THEN\n+            printf (\"  %d  %s []\", count, mptr^.name)\n+         ELSE\n+            printf (\"  %d  %s [%s]\", count, mptr^.name, mptr^.libname)\n+         END ;\n          INC (count) ;\n          IF mptr^.dependency.appl\n          THEN\n@@ -528,49 +627,99 @@ BEGIN\n END combine ;\n \n \n+(*\n+   tracemodule -\n+*)\n+\n+PROCEDURE tracemodule (flag: BOOLEAN; modname: ADDRESS; modlen: CARDINAL; libname: ADDRESS; liblen: CARDINAL) ;\n+VAR\n+   buffer: ARRAY [0..100] OF CHAR ;\n+   len   : CARDINAL ;\n+BEGIN\n+   IF flag\n+   THEN\n+      len := min (modlen, SIZE (buffer)-1) ;\n+      strncpy (ADR(buffer), modname, len) ;\n+      buffer[len] := 0C ;\n+      printf (\"%s \", ADR (buffer)) ;\n+      len := min (liblen, SIZE (buffer)-1) ;\n+      strncpy (ADR(buffer), libname, len) ;\n+      buffer[len] := 0C ;\n+      printf (\" [%s]\", ADR (buffer))\n+   END\n+END tracemodule ;\n+\n+\n+(*\n+   ForceModule -\n+*)\n+\n+PROCEDURE ForceModule (modname: ADDRESS; modlen: CARDINAL;\n+                       libname: ADDRESS; liblen: CARDINAL) ;\n+VAR\n+   mptr: ModuleChain ;\n+BEGIN\n+   traceprintf (ForceTrace, \"forcing module: \") ;\n+   tracemodule (ForceTrace, modname, modlen, libname, liblen) ;\n+   traceprintf (ForceTrace, \"\\n\") ;\n+   mptr := LookupModuleN (ordered, modname, modlen, libname, liblen) ;\n+   IF mptr # NIL\n+   THEN\n+      mptr^.dependency.forced := TRUE ;\n+      moveTo (user, mptr)\n+   END\n+END ForceModule ;\n+\n+\n (*\n    ForceDependencies - if the user has specified a forced order then we override\n                        the dynamic ordering with the preference.\n *)\n \n PROCEDURE ForceDependencies ;\n VAR\n-   mptr,\n-   userChain: ModuleChain ;\n-   count    : CARDINAL ;\n+   len,\n+   modlen,\n+   liblen   : CARDINAL ;\n+   modname,\n+   libname,\n    pc, start: PtrToChar ;\n BEGIN\n    IF ForcedModuleInitOrder # NIL\n    THEN\n-      userChain := NIL ;\n+      traceprintf2 (ForceTrace, \"user forcing order: %s\\n\", ForcedModuleInitOrder) ;\n       pc := ForcedModuleInitOrder ;\n       start := pc ;\n-      count := 0 ;\n+      len := 0 ;\n+      modname := NIL ;\n+      modlen := 0 ;\n+      libname := NIL ;\n+      liblen := 0 ;\n       WHILE pc^ # nul DO\n-         IF pc^ = ','\n-         THEN\n-            mptr := LookupModuleN (ordered, start, count) ;\n-            IF mptr # NIL\n-            THEN\n-               mptr^.dependency.forced := TRUE ;\n-               moveTo (user, mptr)\n-            END ;\n-            INC (pc) ;\n-            start := pc ;\n-            count := 0\n+         CASE pc^ OF\n+\n+         ':':  libname := start ;\n+               liblen := len ;\n+               len := 0 ;\n+               INC (pc) ;\n+               start := pc |\n+         ',':  modname := start ;\n+               modlen := len ;\n+               ForceModule (modname, modlen, libname, liblen) ;\n+               libname := NIL ;\n+               liblen := 0 ;\n+               modlen := 0 ;\n+               len := 0 ;\n+               INC (pc) ;\n+               start := pc\n          ELSE\n             INC (pc) ;\n-            INC (count)\n+            INC (len)\n          END\n       END ;\n       IF start # pc\n       THEN\n-         mptr := LookupModuleN (ordered, start, count) ;\n-         IF mptr # NIL\n-         THEN\n-            mptr^.dependency.forced := TRUE ;\n-            moveTo (user, mptr)\n-         END\n+         ForceModule (start, len, libname, liblen)\n       END ;\n       combine (user, ordered)\n    END\n@@ -601,7 +750,8 @@ BEGIN\n       UNTIL (appl # NIL) OR (mptr=Modules[ordered]) ;\n       IF appl # NIL\n       THEN\n-         Modules[ordered] := appl^.next\n+         RemoveModule (Modules[ordered], appl) ;\n+         AppendModule (Modules[ordered], appl)\n       END\n    END\n END CheckApplication ;\n@@ -612,22 +762,23 @@ END CheckApplication ;\n                       module constructor in turn.\n *)\n \n-PROCEDURE ConstructModules (applicationmodule: ADDRESS;\n+PROCEDURE ConstructModules (applicationmodule, libname: ADDRESS;\n                             argc: INTEGER; argv, envp: ADDRESS) ;\n VAR\n    mptr: ModuleChain ;\n    nulp: ArgCVEnvP ;\n BEGIN\n    CheckInitialized ;\n-   traceprintf2 (ModuleTrace, \"application module: %s\\n\", applicationmodule);\n-   mptr := LookupModule (unordered, applicationmodule) ;\n+   traceprintf3 (ModuleTrace, \"application module: %s [%s]\\n\",\n+                 applicationmodule, libname);\n+   mptr := LookupModule (unordered, applicationmodule, libname) ;\n    IF mptr # NIL\n    THEN\n       mptr^.dependency.appl := TRUE\n    END ;\n    traceprintf (PreTrace, \"Pre resolving dependents\\n\");\n    DumpModuleData (PreTrace) ;\n-   ResolveDependencies (applicationmodule) ;\n+   ResolveDependencies (applicationmodule, libname) ;\n    traceprintf (PreTrace, \"Post resolving dependents\\n\");\n    DumpModuleData (PostTrace) ;\n    ForceDependencies ;\n@@ -638,7 +789,8 @@ BEGIN\n    DumpModuleData (ForceTrace) ;\n    IF Modules[ordered] = NIL\n    THEN\n-      traceprintf2 (ModuleTrace, \"  module: %s has not registered itself using a global constructor\\n\", applicationmodule);\n+      traceprintf3 (ModuleTrace, \"  module: %s [%s] has not registered itself using a global constructor\\n\",\n+                    applicationmodule, libname);\n       traceprintf2 (ModuleTrace, \"  hint try compile and linking using: gm2 %s.mod\\n\", applicationmodule);\n       traceprintf2 (ModuleTrace, \"  or try using: gm2 -fscaffold-static %s.mod\\n\",\n       applicationmodule);\n@@ -647,13 +799,13 @@ BEGIN\n       REPEAT\n          IF mptr^.dependency.forc\n          THEN\n-            traceprintf2 (ModuleTrace, \"initializing module: %s for C\\n\", mptr^.name);\n+            traceprintf3 (ModuleTrace, \"initializing module: %s [%s] for C\\n\", mptr^.name, mptr^.libname)\n          ELSE\n-            traceprintf2 (ModuleTrace, \"initializing module: %s\\n\", mptr^.name);\n+            traceprintf3 (ModuleTrace, \"initializing module: %s [%s]\\n\", mptr^.name, mptr^.libname);\n          END ;\n          IF mptr^.dependency.appl\n          THEN\n-            traceprintf2 (ModuleTrace, \"application module: %s\\n\", mptr^.name);\n+            traceprintf3 (ModuleTrace, \"application module: %s [%s]\\n\", mptr^.name, mptr^.libname);\n             traceprintf (ModuleTrace, \"  calling M2RTS_ExecuteInitialProcedures\\n\");\n             M2RTS.ExecuteInitialProcedures ;\n             traceprintf (ModuleTrace, \"  calling application module\\n\");\n@@ -670,12 +822,13 @@ END ConstructModules ;\n                         module constructor in turn.\n *)\n \n-PROCEDURE DeconstructModules (applicationmodule: ADDRESS;\n+PROCEDURE DeconstructModules (applicationmodule, libname: ADDRESS;\n                               argc: INTEGER; argv, envp: ADDRESS) ;\n VAR\n    mptr: ModuleChain ;\n BEGIN\n-   traceprintf2 (ModuleTrace, \"application module finishing: %s\\n\", applicationmodule);\n+   traceprintf3 (ModuleTrace, \"application module finishing: %s [%s]\\n\",\n+                 applicationmodule, libname);\n    IF Modules[ordered] = NIL\n    THEN\n       traceprintf (ModuleTrace, \"  no ordered modules found during finishing\\n\")\n@@ -687,9 +840,11 @@ BEGIN\n       REPEAT\n          IF mptr^.dependency.forc\n          THEN\n-            traceprintf2 (ModuleTrace, \"finalizing module: %s for C\\n\", mptr^.name);\n+            traceprintf3 (ModuleTrace, \"finalizing module: %s [%s] for C\\n\",\n+                          mptr^.name, mptr^.libname)\n          ELSE\n-            traceprintf2 (ModuleTrace, \"finalizing module: %s\\n\", mptr^.name);\n+            traceprintf3 (ModuleTrace, \"finalizing module: %s [%s]\\n\",\n+                          mptr^.name, mptr^.libname)\n          END ;\n          mptr^.fini (argc, argv, envp) ;\n          mptr := mptr^.prev\n@@ -698,23 +853,52 @@ BEGIN\n END DeconstructModules ;\n \n \n+(*\n+   warning3 - write format arg1 arg2 to stderr.\n+*)\n+\n+PROCEDURE warning3 (format: ARRAY OF CHAR; arg1, arg2: ADDRESS) ;\n+VAR\n+   buffer: ARRAY [0..4096] OF CHAR ;\n+   len   : INTEGER ;\n+BEGIN\n+   IF WarningTrace\n+   THEN\n+      len := snprintf (ADR (buffer), SIZE (buffer), \"warning: \") ;\n+      write (2, ADR (buffer), len) ;\n+      len := snprintf (ADR (buffer), SIZE (buffer), format, arg1, arg2) ;\n+      write (2, ADR (buffer), len)\n+   END\n+END warning3 ;\n+\n+\n (*\n    RegisterModule - adds module name to the list of outstanding\n                     modules which need to have their dependencies\n                     explored to determine initialization order.\n *)\n \n-PROCEDURE RegisterModule (name: ADDRESS;\n+PROCEDURE RegisterModule (modulename, libname: ADDRESS;\n                           init, fini:  ArgCVEnvP;\n                           dependencies: PROC) ;\n+VAR\n+   mptr: ModuleChain ;\n BEGIN\n    CheckInitialized ;\n    IF NOT StaticInitialization\n    THEN\n-      traceprintf2 (ModuleTrace, \"module: %s registering\\n\",\n-                    name);\n-      moveTo (unordered,\n-              CreateModule (name, init, fini, dependencies))\n+      mptr := LookupModule (unordered, modulename, libname) ;\n+      IF mptr = NIL\n+      THEN\n+         traceprintf3 (ModuleTrace, \"module: %s [%s] registering\",\n+                       modulename, libname);\n+         moveTo (unordered,\n+                 CreateModule (modulename, libname, init, fini, dependencies)) ;\n+         traceprintf (ModuleTrace, \"\\n\") ;\n+      ELSE\n+         warning3 (\"module: %s [%s] (ignoring duplicate registration)\\n\",\n+                   modulename, libname)\n+      END\n    END\n END RegisterModule ;\n \n@@ -733,11 +917,12 @@ END equal ;\n    SetupDebugFlags - By default assigns ModuleTrace, DependencyTrace,\n                      DumpPostInit to FALSE.  It checks the environment\n                      GCC_M2LINK_RTFLAG which can contain\n-                     \"all,module,pre,post,dep,force\".  all turns them all on.\n+                     \"all,module,hex,pre,post,dep,force\".  all turns them all on.\n                      The flag meanings are as follows and flags the are in\n                      execution order.\n \n                      module   generate trace info as the modules are registered.\n+                     hex      dump the modules ctor functions address in hex.\n                      pre      generate a list of all modules seen prior to having\n                               their dependancies resolved.\n                      dep      display a trace as the modules are resolved.\n@@ -756,6 +941,8 @@ BEGIN\n    PostTrace := FALSE ;\n    PreTrace := FALSE ;\n    ForceTrace := FALSE ;\n+   HexTrace := FALSE ;\n+   WarningTrace := FALSE ;\n    pc := getenv (ADR (\"GCC_M2LINK_RTFLAG\")) ;\n    WHILE (pc # NIL) AND (pc^ # nul) DO\n       IF equal (pc, \"all\")\n@@ -765,11 +952,21 @@ BEGIN\n          PreTrace := TRUE ;\n          PostTrace := TRUE ;\n          ForceTrace := TRUE ;\n+         HexTrace := TRUE ;\n+         WarningTrace := TRUE ;\n          INC (pc, 3)\n       ELSIF equal (pc, \"module\")\n       THEN\n          ModuleTrace := TRUE ;\n          INC (pc, 6)\n+      ELSIF equal (pc, \"warning\")\n+      THEN\n+         WarningTrace := TRUE ;\n+         INC (pc, 7)\n+      ELSIF equal (pc, \"hex\")\n+      THEN\n+         HexTrace := TRUE ;\n+         INC (pc, 3)\n       ELSIF equal (pc, \"dep\")\n       THEN\n          DependencyTrace := TRUE ;"}, {"sha": "ca6010b42c30f18fc4f22e93efd46c7beb2a240c", "filename": "gcc/m2/gm2-libs/M2RTS.def", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs%2FM2RTS.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs%2FM2RTS.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2FM2RTS.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -33,10 +33,10 @@ TYPE\n    ArgCVEnvP = PROCEDURE (INTEGER, ADDRESS, ADDRESS) ;\n \n \n-PROCEDURE ConstructModules (applicationmodule: ADDRESS;\n+PROCEDURE ConstructModules (applicationmodule, libname: ADDRESS;\n                             argc: INTEGER; argv, envp: ADDRESS) ;\n \n-PROCEDURE DeconstructModules (applicationmodule: ADDRESS;\n+PROCEDURE DeconstructModules (applicationmodule, libname: ADDRESS;\n                               argc: INTEGER; argv, envp: ADDRESS) ;\n \n \n@@ -46,7 +46,7 @@ PROCEDURE DeconstructModules (applicationmodule: ADDRESS;\n                     explored to determine initialization order.\n *)\n \n-PROCEDURE RegisterModule (name: ADDRESS;\n+PROCEDURE RegisterModule (name, libname: ADDRESS;\n                           init, fini:  ArgCVEnvP;\n                           dependencies: PROC) ;\n \n@@ -56,7 +56,8 @@ PROCEDURE RegisterModule (name: ADDRESS;\n                       module dependantmodule.\n *)\n \n-PROCEDURE RequestDependant (modulename, dependantmodule: ADDRESS) ;\n+PROCEDURE RequestDependant (modulename, libname,\n+                            dependantmodule, dependantlibname: ADDRESS) ;\n \n \n (*"}, {"sha": "d01f6a68f9205cd2cba598980ef89ec0012deb10", "filename": "gcc/m2/gm2-libs/M2RTS.mod", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs%2FM2RTS.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs%2FM2RTS.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2FM2RTS.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -70,10 +70,11 @@ VAR\n                       module constructor in turn.\n *)\n \n-PROCEDURE ConstructModules (applicationmodule: ADDRESS;\n+PROCEDURE ConstructModules (applicationmodule, libname: ADDRESS;\n                             argc: INTEGER; argv, envp: ADDRESS) ;\n BEGIN\n-   M2Dependent.ConstructModules (applicationmodule, argc, argv, envp)\n+   M2Dependent.ConstructModules (applicationmodule, libname,\n+                                 argc, argv, envp)\n END ConstructModules ;\n \n \n@@ -82,10 +83,11 @@ END ConstructModules ;\n                         module constructor in turn.\n *)\n \n-PROCEDURE DeconstructModules (applicationmodule: ADDRESS;\n+PROCEDURE DeconstructModules (applicationmodule, libname: ADDRESS;\n                               argc: INTEGER; argv, envp: ADDRESS) ;\n BEGIN\n-   M2Dependent.DeconstructModules (applicationmodule, argc, argv, envp)\n+   M2Dependent.DeconstructModules (applicationmodule, libname,\n+                                   argc, argv, envp)\n END DeconstructModules ;\n \n \n@@ -95,11 +97,11 @@ END DeconstructModules ;\n                     explored to determine initialization order.\n *)\n \n-PROCEDURE RegisterModule (name: ADDRESS;\n+PROCEDURE RegisterModule (name, libname: ADDRESS;\n                           init, fini:  ArgCVEnvP;\n                           dependencies: PROC) ;\n BEGIN\n-   M2Dependent.RegisterModule (name, init, fini, dependencies)\n+   M2Dependent.RegisterModule (name, libname, init, fini, dependencies)\n END RegisterModule ;\n \n \n@@ -108,9 +110,11 @@ END RegisterModule ;\n                       module dependantmodule.\n *)\n \n-PROCEDURE RequestDependant (modulename, dependantmodule: ADDRESS) ;\n+PROCEDURE RequestDependant (modulename, libname,\n+                            dependantmodule, dependantlibname: ADDRESS) ;\n BEGIN\n-   M2Dependent.RequestDependant (modulename, dependantmodule)\n+   M2Dependent.RequestDependant (modulename, libname,\n+                                 dependantmodule, dependantlibname)\n END RequestDependant ;\n \n "}, {"sha": "97fdee24760e64c7b9dc6729ff7713bf86138cca", "filename": "gcc/m2/gm2-libs/RTint.mod", "status": "modified", "additions": 199, "deletions": 200, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs%2FRTint.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs%2FRTint.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2FRTint.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -97,21 +97,21 @@ END Min ;\n \n \n (*\n-   FindVector - searches the exists list for a vector of type, t,\n+   FindVector - searches the exists list for a vector of type\n                 which is associated with file descriptor, fd.\n *)\n \n-PROCEDURE FindVector (fd: INTEGER; t: VectorType) : Vector ;\n+PROCEDURE FindVector (fd: INTEGER; type: VectorType) : Vector ;\n VAR\n-   v: Vector ;\n+   vec: Vector ;\n BEGIN\n-   v := Exists ;\n-   WHILE v#NIL DO\n-      IF (v^.type=t) AND (v^.File=fd)\n+   vec := Exists ;\n+   WHILE vec#NIL DO\n+      IF (vec^.type=type) AND (vec^.File=fd)\n       THEN\n-         RETURN v\n+         RETURN vec\n       END ;\n-      v := v^.exists\n+      vec := vec^.exists\n    END ;\n    RETURN NIL\n END FindVector ;\n@@ -124,19 +124,19 @@ END FindVector ;\n \n PROCEDURE InitInputVector (fd: INTEGER; pri: CARDINAL) : CARDINAL ;\n VAR\n-   v: Vector ;\n+   vptr: Vector ;\n BEGIN\n    IF Debugging\n    THEN\n       printf(\"InitInputVector fd = %d priority = %d\\n\", fd, pri)\n    END ;\n    wait (lock) ;\n-   v := FindVector(fd, input) ;\n-   IF v=NIL\n+   vptr := FindVector(fd, input) ;\n+   IF vptr = NIL\n    THEN\n-      NEW(v) ;\n-      INC(VecNo) ;\n-      WITH v^ DO\n+      NEW (vptr) ;\n+      INC (VecNo) ;\n+      WITH vptr^ DO\n          type     := input ;\n          priority := pri ;\n          arg      := NIL ;\n@@ -145,12 +145,12 @@ BEGIN\n          no       := VecNo ;\n          File     := fd\n       END ;\n-      Exists := v ;\n+      Exists := vptr ;\n       signal (lock) ;\n       RETURN VecNo\n    ELSE\n       signal (lock) ;\n-      RETURN v^.no\n+      RETURN vptr^.no\n    END\n END InitInputVector ;\n \n@@ -162,19 +162,19 @@ END InitInputVector ;\n \n PROCEDURE InitOutputVector (fd: INTEGER; pri: CARDINAL) : CARDINAL ;\n VAR\n-   v: Vector ;\n+   vptr: Vector ;\n BEGIN\n    wait (lock) ;\n-   v := FindVector (fd, output) ;\n-   IF v=NIL\n+   vptr := FindVector (fd, output) ;\n+   IF vptr = NIL\n    THEN\n-      NEW (v) ;\n-      IF v = NIL\n+      NEW (vptr) ;\n+      IF vptr = NIL\n       THEN\n          HALT\n       ELSE\n          INC (VecNo) ;\n-         WITH v^ DO\n+         WITH vptr^ DO\n             type     := output ;\n             priority := pri ;\n             arg      := NIL ;\n@@ -183,13 +183,13 @@ BEGIN\n             no       := VecNo ;\n             File     := fd\n          END ;\n-         Exists := v ;\n+         Exists := vptr ;\n          signal (lock) ;\n          RETURN VecNo\n       END\n    ELSE\n       signal (lock) ;\n-      RETURN v^.no\n+      RETURN vptr^.no\n    END\n END InitOutputVector ;\n \n@@ -201,47 +201,47 @@ END InitOutputVector ;\n \n PROCEDURE InitTimeVector (micro, secs: CARDINAL; pri: CARDINAL) : CARDINAL ;\n VAR\n-   v: Vector ;\n+   vptr: Vector ;\n BEGIN\n    wait (lock) ;\n-   NEW (v) ;\n-   IF v = NIL\n+   NEW (vptr) ;\n+   IF vptr = NIL\n    THEN\n       HALT\n    ELSE\n       INC (VecNo) ;\n       Assert (micro<Microseconds) ;\n-      WITH v^ DO\n+      WITH vptr^ DO\n          type     := time ;\n          priority := pri ;\n          arg      := NIL ;\n          pending  := NIL ;\n          exists   := Exists ;\n          no       := VecNo ;\n-         rel      := InitTime(secs+DebugTime, micro) ;\n-         abs      := InitTime(0, 0) ;\n+         rel      := InitTime (secs+DebugTime, micro) ;\n+         abs      := InitTime (0, 0) ;\n          queued   := FALSE\n       END ;\n-      Exists := v\n+      Exists := vptr\n    END ;\n    signal (lock) ;\n    RETURN VecNo\n END InitTimeVector ;\n \n \n (*\n-   FindVectorNo - searches the Exists list for vector, vec.\n+   FindVectorNo - searches the Exists list for vector vec.\n *)\n \n PROCEDURE FindVectorNo (vec: CARDINAL) : Vector ;\n VAR\n-   v: Vector ;\n+   vptr: Vector ;\n BEGIN\n-   v := Exists ;\n-   WHILE (v#NIL) AND (v^.no#vec) DO\n-      v := v^.exists\n+   vptr := Exists ;\n+   WHILE (vptr#NIL) AND (vptr^.no#vec) DO\n+      vptr := vptr^.exists\n    END ;\n-   RETURN v\n+   RETURN vptr\n END FindVectorNo ;\n \n \n@@ -251,17 +251,17 @@ END FindVectorNo ;\n \n PROCEDURE FindPendingVector (vec: CARDINAL) : Vector ;\n VAR\n-   i: CARDINAL ;\n-   v: Vector ;\n+   pri : CARDINAL ;\n+   vptr: Vector ;\n BEGIN\n-   FOR i := MIN(PROTECTION) TO MAX(PROTECTION) DO\n-      v := Pending[i] ;\n-      WHILE (v#NIL) AND (v^.no#vec) DO\n-         v := v^.pending\n+   FOR pri := MIN(PROTECTION) TO MAX(PROTECTION) DO\n+      vptr := Pending[pri] ;\n+      WHILE (vptr#NIL) AND (vptr^.no#vec) DO\n+         vptr := vptr^.pending\n       END ;\n-      IF (v#NIL) AND (v^.no=vec)\n+      IF (vptr#NIL) AND (vptr^.no=vec)\n       THEN\n-         RETURN v\n+         RETURN vptr\n       END\n    END ;\n    RETURN NIL\n@@ -276,17 +276,17 @@ END FindPendingVector ;\n PROCEDURE ReArmTimeVector (vec: CARDINAL;\n                            micro, secs: CARDINAL) ;\n VAR\n-   v: Vector ;\n+   vptr: Vector ;\n BEGIN\n-   Assert(micro<Microseconds) ;\n+   Assert (micro<Microseconds) ;\n    wait (lock) ;\n-   v := FindVectorNo(vec) ;\n-   IF v=NIL\n+   vptr := FindVectorNo (vec) ;\n+   IF vptr = NIL\n    THEN\n-      Halt(__FILE__, __LINE__, __FUNCTION__,\n-           'cannot find vector supplied')\n+      Halt (__FILE__, __LINE__, __FUNCTION__,\n+            'cannot find vector supplied')\n    ELSE\n-      WITH v^ DO\n+      WITH vptr^ DO\n          SetTime (rel, secs + DebugTime, micro)\n       END\n    END ;\n@@ -303,16 +303,16 @@ END ReArmTimeVector ;\n \n PROCEDURE GetTimeVector (vec: CARDINAL; VAR micro, secs: CARDINAL) ;\n VAR\n-   v: Vector ;\n+   vptr: Vector ;\n BEGIN\n    wait (lock) ;\n-   v := FindVectorNo (vec) ;\n-   IF v=NIL\n+   vptr := FindVectorNo (vec) ;\n+   IF vptr=NIL\n    THEN\n-      Halt(__FILE__, __LINE__, __FUNCTION__,\n-           'cannot find vector supplied')\n+      Halt (__FILE__, __LINE__, __FUNCTION__,\n+            'cannot find vector supplied')\n    ELSE\n-      WITH v^ DO\n+      WITH vptr^ DO\n          GetTime (rel, secs, micro) ;\n          Assert (micro < Microseconds)\n       END\n@@ -322,31 +322,31 @@ END GetTimeVector ;\n \n \n (*\n-   AttachVector - adds the pointer, p, to be associated with the interrupt\n+   AttachVector - adds the pointer ptr to be associated with the interrupt\n                   vector. It returns the previous value attached to this\n                   vector.\n *)\n \n-PROCEDURE AttachVector (vec: CARDINAL; p: ADDRESS) : ADDRESS ;\n+PROCEDURE AttachVector (vec: CARDINAL; ptr: ADDRESS) : ADDRESS ;\n VAR\n-   v: Vector ;\n-   l: ADDRESS ;\n+   vptr   : Vector ;\n+   prevArg: ADDRESS ;\n BEGIN\n    wait (lock) ;\n-   v := FindVectorNo (vec) ;\n-   IF v=NIL\n+   vptr := FindVectorNo (vec) ;\n+   IF vptr = NIL\n    THEN\n       Halt (__FILE__, __LINE__, __FUNCTION__, 'cannot find vector supplied')\n    ELSE\n-      l := v^.arg ;\n-      v^.arg := p ;\n+      prevArg := vptr^.arg ;\n+      vptr^.arg := ptr ;\n       IF Debugging\n       THEN\n-         printf (\"AttachVector %d with 0x%x\\n\", vec, p);\n+         printf (\"AttachVector %d with %p\\n\", vec, ptr);\n          DumpPendingQueue ;\n       END ;\n       signal (lock) ;\n-      RETURN l\n+      RETURN prevArg\n    END\n END AttachVector ;\n \n@@ -358,42 +358,41 @@ END AttachVector ;\n \n PROCEDURE IncludeVector (vec: CARDINAL) ;\n VAR\n-   v   : Vector ;\n-   m, s: CARDINAL ;\n-   r   : INTEGER ;\n+   vptr      : Vector ;\n+   micro, sec: CARDINAL ;\n+   result    : INTEGER ;\n BEGIN\n    wait (lock) ;\n-   v := FindPendingVector (vec) ;\n-   IF v=NIL\n+   vptr := FindPendingVector (vec) ;\n+   IF vptr = NIL\n    THEN\n-      v := FindVectorNo (vec) ;\n-      IF v = NIL\n+      vptr := FindVectorNo (vec) ;\n+      IF vptr = NIL\n       THEN\n          Halt (__FILE__, __LINE__, __FUNCTION__,\n                'cannot find vector supplied') ;\n       ELSE\n          (* printf('including vector %d  (fd = %d)\\n', vec, v^.File) ; *)\n-         v^.pending := Pending[v^.priority] ;\n-         Pending[v^.priority] := v ;\n-         IF (v^.type = time) AND (NOT v^.queued)\n+         vptr^.pending := Pending[vptr^.priority] ;\n+         Pending[vptr^.priority] := vptr ;\n+         IF (vptr^.type = time) AND (NOT vptr^.queued)\n          THEN\n-            v^.queued := TRUE ;\n-            r := GetTimeOfDay (v^.abs) ;\n-            Assert (r=0) ;\n-            GetTime (v^.abs, s, m) ;\n-            Assert (m<Microseconds) ;\n-            AddTime (v^.abs, v^.rel) ;\n-            GetTime (v^.abs, s, m) ;\n-            Assert (m<Microseconds)\n+            vptr^.queued := TRUE ;\n+            result := GetTimeOfDay (vptr^.abs) ;\n+            Assert (result=0) ;\n+            GetTime (vptr^.abs, sec, micro) ;\n+            Assert (micro<Microseconds) ;\n+            AddTime (vptr^.abs, vptr^.rel) ;\n+            GetTime (vptr^.abs, sec, micro) ;\n+            Assert (micro<Microseconds)\n          END\n       END\n    ELSE\n       IF Debugging\n       THEN\n-         printf ('odd vector (%d) type (%d) arg (0x%x) is already attached to the pending queue\\n',\n-                 vec, v^.type, v^.arg)\n-      END ;\n-      stop\n+         printf ('odd vector (%d) type (%d) arg (%p) is already attached to the pending queue\\n',\n+                 vec, vptr^.type, vptr^.arg)\n+      END\n    END ;\n    signal (lock)\n END IncludeVector ;\n@@ -406,48 +405,48 @@ END IncludeVector ;\n \n PROCEDURE ExcludeVector (vec: CARDINAL) ;\n VAR\n-   v, u: Vector ;\n+   vptr, uptr: Vector ;\n BEGIN\n    wait (lock) ;\n-   v := FindPendingVector(vec) ;\n-   IF v=NIL\n+   vptr := FindPendingVector (vec) ;\n+   IF vptr = NIL\n    THEN\n       Halt (__FILE__, __LINE__, __FUNCTION__,\n             'cannot find pending vector supplied')\n    ELSE\n       (* printf('excluding vector %d\\n', vec) ; *)\n-      IF Pending[v^.priority]=v\n+      IF Pending[vptr^.priority] = vptr\n       THEN\n-         Pending[v^.priority] := Pending[v^.priority]^.pending\n+         Pending[vptr^.priority] := Pending[vptr^.priority]^.pending\n       ELSE\n-         u := Pending[v^.priority] ;\n-         WHILE u^.pending#v DO\n-            u := u^.pending\n+         uptr := Pending[vptr^.priority] ;\n+         WHILE uptr^.pending#vptr DO\n+            uptr := uptr^.pending\n          END ;\n-         u^.pending := v^.pending\n+         uptr^.pending := vptr^.pending\n       END ;\n-      IF v^.type=time\n+      IF vptr^.type=time\n       THEN\n-         v^.queued := FALSE\n+         vptr^.queued := FALSE\n       END\n    END ;\n    signal (lock)\n END ExcludeVector ;\n \n \n (*\n-   AddFd - adds the file descriptor, fd, to set, s, updating, max.\n+   AddFd - adds the file descriptor fd to set updating max.\n *)\n \n-PROCEDURE AddFd (VAR s: SetOfFd; VAR max: INTEGER; fd: INTEGER) ;\n+PROCEDURE AddFd (VAR set: SetOfFd; VAR max: INTEGER; fd: INTEGER) ;\n BEGIN\n    max := Max (fd, max) ;\n-   IF s = NIL\n+   IF set = NIL\n    THEN\n-      s := InitSet () ;\n-      FdZero (s)\n+      set := InitSet () ;\n+      FdZero (set)\n    END ;\n-   FdSet (fd, s)\n+   FdSet (fd, set)\n    (* printf('%d, ', fd) *)\n END AddFd ;\n \n@@ -458,36 +457,33 @@ END AddFd ;\n \n PROCEDURE DumpPendingQueue ;\n VAR\n-   p   : PROTECTION ;\n-   v   : Vector ;\n-   s, m: CARDINAL ;\n+   pri  : PROTECTION ;\n+   vptr : Vector ;\n+   sec,\n+   micro: CARDINAL ;\n BEGIN\n    printf (\"Pending queue\\n\");\n-   FOR p := MIN (PROTECTION) TO MAX (PROTECTION) DO\n-      printf (\"[%d]  \", p);\n-      v := Pending[p] ;\n-      WHILE v#NIL DO\n-         IF (v^.type=input) OR (v^.type=output)\n+   FOR pri := MIN (PROTECTION) TO MAX (PROTECTION) DO\n+      printf (\"[%d]  \", pri);\n+      vptr := Pending[pri] ;\n+      WHILE vptr # NIL DO\n+         IF (vptr^.type=input) OR (vptr^.type=output)\n          THEN\n-            printf (\"(fd=%d) (vec=%d)\", v^.File, v^.no)\n-         ELSIF v^.type=time\n+            printf (\"(fd=%d) (vec=%d)\", vptr^.File, vptr^.no)\n+         ELSIF vptr^.type=time\n          THEN\n-            GetTime(v^.rel, s, m) ;\n-            Assert (m<Microseconds) ;\n-            printf (\"time (%u.%06u secs) (arg = 0x%x)\\n\", s, m, v^.arg)\n+            GetTime (vptr^.rel, sec, micro) ;\n+            Assert (micro < Microseconds) ;\n+            printf (\"time (%u.%06u secs) (arg = %p)\\n\",\n+                    sec, micro, vptr^.arg)\n          END ;\n-         v := v^.pending\n+         vptr := vptr^.pending\n       END ;\n       printf (\" \\n\")\n    END\n END DumpPendingQueue ;\n \n \n-PROCEDURE stop ;\n-BEGIN\n-END stop ;\n-\n-\n (*\n    AddTime - t1 := t1 + t2\n *)\n@@ -565,63 +561,64 @@ END SubTime ;\n *)\n \n PROCEDURE activatePending (untilInterrupt: BOOLEAN; call: DispatchVector; pri: CARDINAL;\n-                           maxFd: INTEGER; VAR i, o: SetOfFd; VAR t: Timeval; b4, after: Timeval) : BOOLEAN ;\n+                           maxFd: INTEGER; VAR inSet, outSet: SetOfFd; VAR timeval: Timeval; b4, after: Timeval) : BOOLEAN ;\n VAR\n-   r   : INTEGER ;\n-   p   : CARDINAL ;\n-   v   : Vector ;\n+   result: INTEGER ;\n+   p     : CARDINAL ;\n+   vec   : Vector ;\n    b4s,\n    b4m,\n    afs,\n    afm,\n-   s, m: CARDINAL ;\n+   sec,\n+   micro : CARDINAL ;\n BEGIN\n    wait (lock) ;\n    p := MAX (PROTECTION) ;\n    WHILE p > pri DO\n-      v := Pending[p] ;\n-      WHILE v # NIL DO\n-         WITH v^ DO\n+      vec := Pending[p] ;\n+      WHILE vec # NIL DO\n+         WITH vec^ DO\n             CASE type OF\n \n-            input :  IF (File < maxFd) AND (i # NIL) AND FdIsSet (File, i)\n+            input :  IF (File < maxFd) AND (inSet # NIL) AND FdIsSet (File, inSet)\n                      THEN\n                         IF Debugging\n                         THEN\n                            printf ('read (fd=%d) is ready (vec=%d)\\n', File, no) ;\n                            DumpPendingQueue\n                         END ;\n-                        FdClr (File, i) ;  (* so we dont activate this again from our select.  *)\n+                        FdClr (File, inSet) ;  (* so we dont activate this again from our select.  *)\n                         signal (lock) ;\n                         call (no, priority, arg) ;\n                         RETURN TRUE\n                      END |\n-            output:  IF (File < maxFd) AND (o#NIL) AND FdIsSet (File, o)\n+            output:  IF (File < maxFd) AND (outSet#NIL) AND FdIsSet (File, outSet)\n                      THEN\n                         IF Debugging\n                         THEN\n                            printf ('write (fd=%d) is ready (vec=%d)\\n', File, no) ;\n                            DumpPendingQueue\n                         END ;\n-                        FdClr (File, o) ;  (* so we dont activate this again from our select.  *)\n+                        FdClr (File, outSet) ;  (* so we dont activate this again from our select.  *)\n                         signal (lock) ;\n                         call (no, priority, arg) ;\n                         RETURN TRUE\n                      END |\n-            time  :  IF untilInterrupt AND (t # NIL)\n+            time  :  IF untilInterrupt AND (timeval # NIL)\n                      THEN\n-                        r := GetTimeOfDay (after) ;\n-                        Assert (r=0) ;\n+                        result := GetTimeOfDay (after) ;\n+                        Assert (result=0) ;\n                         IF Debugging\n                         THEN\n-                           GetTime (t, s, m) ;\n-                           Assert (m < Microseconds) ;\n+                           GetTime (timeval, sec, micro) ;\n+                           Assert (micro < Microseconds) ;\n                            GetTime (after, afs, afm) ;\n                            Assert (afm < Microseconds) ;\n                            GetTime (b4, b4s, b4m) ;\n                            Assert (b4m < Microseconds) ;\n                            printf (\"waited %u.%06u + %u.%06u now is %u.%06u\\n\",\n-                                   s, m, b4s, b4m, afs, afm) ;\n+                                   sec, micro, b4s, b4m, afs, afm) ;\n                         END ;\n                         IF IsGreaterEqual (after, abs)\n                         THEN\n@@ -630,7 +627,7 @@ BEGIN\n                               DumpPendingQueue ;\n                               printf (\"time has expired calling dispatcher\\n\")\n                            END ;\n-                           t := KillTime (t) ;  (* so we dont activate this again from our select.  *)\n+                           timeval := KillTime (timeval) ;  (* so we dont activate this again from our select.  *)\n                            signal (lock) ;\n                            IF Debugging\n                            THEN\n@@ -645,7 +642,7 @@ BEGIN\n                      END\n             END\n          END ;\n-         v := v^.pending\n+         vec := vec^.pending\n       END ;\n       DEC (p)\n    END ;\n@@ -667,20 +664,22 @@ PROCEDURE Listen (untilInterrupt: BOOLEAN;\n                   call: DispatchVector;\n                   pri: CARDINAL) ;\n VAR\n-   found: BOOLEAN ;\n-   r    : INTEGER ;\n+   found  : BOOLEAN ;\n+   result : INTEGER ;\n    after,\n    b4,\n-   t    : Timeval ;\n-   v    : Vector ;\n-   i, o : SetOfFd ;\n+   timeval: Timeval ;\n+   vec    : Vector ;\n+   inSet,\n+   outSet : SetOfFd ;\n    b4s,\n    b4m,\n    afs,\n    afm,\n-   s, m : CARDINAL ;\n-   maxFd: INTEGER ;\n-   p    : CARDINAL ;\n+   sec,\n+   micro  : CARDINAL ;\n+   maxFd  : INTEGER ;\n+   p      : CARDINAL ;\n BEGIN\n    wait (lock) ;\n    IF pri < MAX (PROTECTION)\n@@ -690,120 +689,120 @@ BEGIN\n          DumpPendingQueue\n       END ;\n       maxFd := -1 ;\n-      t := NIL ;\n-      i := NIL ;\n-      o := NIL ;\n-      t := InitTime (MAX (INTEGER), 0) ;\n+      timeval := NIL ;\n+      inSet := NIL ;\n+      outSet := NIL ;\n+      timeval := InitTime (MAX (INTEGER), 0) ;\n       p := MAX (PROTECTION) ;\n       found := FALSE ;\n       WHILE p>pri DO\n-         v := Pending[p] ;\n-         WHILE v#NIL DO\n-            WITH v^ DO\n+         vec := Pending[p] ;\n+         WHILE vec#NIL DO\n+            WITH vec^ DO\n                CASE type OF\n \n-               input :  AddFd (i, maxFd, File) |\n-               output:  AddFd (o, maxFd, File) |\n-               time  :  IF IsGreaterEqual (t, abs)\n+               input :  AddFd (inSet, maxFd, File) |\n+               output:  AddFd (outSet, maxFd, File) |\n+               time  :  IF IsGreaterEqual (timeval, abs)\n                         THEN\n-                           GetTime (abs, s, m) ;\n-                           Assert (m<Microseconds) ;\n+                           GetTime (abs, sec, micro) ;\n+                           Assert (micro < Microseconds) ;\n                            IF Debugging\n                            THEN\n-                              printf (\"shortest delay is %u.%06u\\n\", s, m)\n+                              printf (\"shortest delay is %u.%06u\\n\", sec, micro)\n                            END ;\n-                           SetTime (t, s, m) ;\n+                           SetTime (timeval, sec, micro) ;\n                            found := TRUE\n                         END\n \n                END\n             END ;\n-            v := v^.pending\n+            vec := vec^.pending\n          END ;\n          DEC (p)\n       END ;\n       IF NOT untilInterrupt\n       THEN\n-         SetTime (t, 0, 0)\n+         SetTime (timeval, 0, 0)\n       END ;\n-      IF untilInterrupt AND (i=NIL) AND (o=NIL) AND (NOT found)\n+      IF untilInterrupt AND (inSet=NIL) AND (outSet=NIL) AND (NOT found)\n       THEN\n          Halt (__FILE__, __LINE__, __FUNCTION__,\n                'deadlock found, no more processes to run and no interrupts active')\n       END ;\n-      (* printf('timeval = 0x%x\\n', t) ; *)\n+      (* printf('timeval = 0x%x\\n', timeval) ; *)\n       (* printf('}\\n') ; *)\n-      IF (NOT found) AND (maxFd=-1) AND (i=NIL) AND (o=NIL)\n+      IF (NOT found) AND (maxFd=-1) AND (inSet=NIL) AND (outSet=NIL)\n       THEN\n          (* no file descriptors to be selected upon.  *)\n-         t := KillTime (t) ;\n+         timeval := KillTime (timeval) ;\n          signal (lock) ;\n          RETURN\n       ELSE\n-         GetTime (t, s, m) ;\n-         Assert (m<Microseconds) ;\n+         GetTime (timeval, sec, micro) ;\n+         Assert (micro < Microseconds) ;\n          b4 := InitTime (0, 0) ;\n          after := InitTime (0, 0) ;\n-         r := GetTimeOfDay (b4) ;\n-         Assert (r=0) ;\n-         SubTime (s, m, t, b4) ;\n-         SetTime (t, s, m) ;\n+         result := GetTimeOfDay (b4) ;\n+         Assert (result=0) ;\n+         SubTime (sec, micro, timeval, b4) ;\n+         SetTime (timeval, sec, micro) ;\n          IF Debugging\n          THEN\n-            printf (\"select waiting for %u.%06u seconds\\n\", s, m)\n+            printf (\"select waiting for %u.%06u seconds\\n\", sec, micro)\n          END ;\n          signal (lock) ;\n          REPEAT\n             IF Debugging\n             THEN\n-               printf (\"select (.., .., .., %u.%06u)\\n\", s, m)\n+               printf (\"select (.., .., .., %u.%06u)\\n\", sec, micro)\n             END ;\n-            r := select (maxFd+1, i, o, NIL, t) ;\n-            IF r=-1\n+            result := select (maxFd+1, inSet, outSet, NIL, timeval) ;\n+            IF result=-1\n             THEN\n                perror (\"select\") ;\n-               r := select (maxFd+1, i, o, NIL, NIL) ;\n-               IF r=-1\n+               result := select (maxFd+1, inSet, outSet, NIL, NIL) ;\n+               IF result=-1\n                THEN\n                   perror (\"select timeout argument is faulty\")\n                END ;\n-               r := select (maxFd+1, i, NIL, NIL, t) ;\n-               IF r=-1\n+               result := select (maxFd+1, inSet, NIL, NIL, timeval) ;\n+               IF result=-1\n                THEN\n                   perror (\"select output fd argument is faulty\")\n                END ;\n-               r := select (maxFd+1, NIL, o, NIL, t) ;\n-               IF r=-1\n+               result := select (maxFd+1, NIL, outSet, NIL, timeval) ;\n+               IF result=-1\n                THEN\n                   perror (\"select input fd argument is faulty\")\n                ELSE\n                   perror (\"select maxFD+1 argument is faulty\")\n                END\n             END\n-         UNTIL r#-1\n+         UNTIL result#-1\n       END ;\n       WHILE activatePending (untilInterrupt, call, pri,\n-                             maxFd+1, i, o, t, b4, after) DO\n+                             maxFd+1, inSet, outSet, timeval, b4, after) DO\n       END ;\n-      IF t#NIL\n+      IF timeval#NIL\n       THEN\n-         t := KillTime (t)\n+         timeval := KillTime (timeval)\n       END ;\n       IF after#NIL\n       THEN\n-         t := KillTime (after)\n+         after := KillTime (after)\n       END ;\n       IF b4#NIL\n       THEN\n-         t := KillTime (b4)\n+         b4 := KillTime (b4)\n       END ;\n-      IF i#NIL\n+      IF inSet#NIL\n       THEN\n-         i := KillSet (i)\n+         inSet := KillSet (inSet)\n       END ;\n-      IF o#NIL\n+      IF outSet#NIL\n       THEN\n-         o := KillSet (o)\n+         outSet := KillSet (outSet)\n       END\n    END ;\n    signal (lock)"}, {"sha": "21c790edd2494e83baa47a8238ade7c08190286a", "filename": "gcc/m2/gm2-libs/libc.def", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs%2Flibc.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs%2Flibc.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2Flibc.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -42,7 +42,8 @@ EXPORT UNQUALIFIED time_t, timeb, tm, ptrToTM,\n                    memcpy, memset, memmove, printf, realloc,\n                    rand, srand,\n                    time, localtime, ftime,\n-                   shutdown, rename, setjmp, longjmp, atexit,\n+                   shutdown, snprintf,\n+                   rename, setjmp, longjmp, atexit,\n                    ttyname, sleep, execv ;\n \n \n@@ -360,6 +361,13 @@ PROCEDURE memmove (dest, src: ADDRESS; size: CSIZE_T) : [ ADDRESS ] ;\n PROCEDURE printf (format: ARRAY OF CHAR; ...) : [ INTEGER ] ;\n \n \n+(*\n+   int snprintf(char *str, size_t size, const char *format, ...);\n+*)\n+\n+PROCEDURE snprintf (dest: ADDRESS; size: CSIZE_T;\n+                    format: ARRAY OF CHAR; ...) : [ INTEGER ] ;\n+\n (*\n    setenv - sets environment variable, name, to value.\n             It will overwrite an existing value if, overwrite,"}, {"sha": "ac5111025fb031c554894db4172ab7ebf51a31ba", "filename": "gcc/m2/gm2-libs/sckt.def", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs%2Fsckt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2-libs%2Fsckt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2Fsckt.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -27,14 +27,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n DEFINITION MODULE sckt ;\n \n FROM SYSTEM IMPORT ADDRESS ;\n-EXPORT UNQUALIFIED tcpServerState,\n-                   tcpServerEstablish, tcpServerEstablishPort,\n-                   tcpServerAccept, getLocalIP,\n-                   tcpServerPortNo, tcpServerIP, tcpServerSocketFd,\n-                   tcpServerClientIP, tcpServerClientPortNo,\n-                   tcpClientState,\n-                   tcpClientSocket, tcpClientSocketIP, tcpClientConnect,\n-                   tcpClientPortNo, tcpClientIP, tcpClientSocketFd ;\n+EXPORT QUALIFIED tcpServerState,\n+                 tcpServerEstablish, tcpServerEstablishPort,\n+                 tcpServerAccept, getLocalIP,\n+                 tcpServerPortNo, tcpServerIP, tcpServerSocketFd,\n+                 tcpServerClientIP, tcpServerClientPortNo,\n+                 tcpClientState,\n+                 tcpClientSocket, tcpClientSocketIP, tcpClientConnect,\n+                 tcpClientPortNo, tcpClientIP, tcpClientSocketFd ;\n \n TYPE\n    tcpServerState = ADDRESS ;"}, {"sha": "a118a8818f61fa9daad66899e4ba736dd7b0dae9", "filename": "gcc/m2/gm2spec.cc", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2spec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fgm2spec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2spec.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -31,6 +31,8 @@ along with GNU Modula-2; see the file COPYING3.  If not see\n #include \"gcc.h\"\n #include \"opts.h\"\n #include \"vec.h\"\n+#include <vector>\n+#include <string>\n \n #include \"m2/gm2config.h\"\n \n@@ -149,7 +151,40 @@ static void append_arg (const struct cl_decoded_option *);\n static unsigned int gm2_newargc;\n static struct cl_decoded_option *gm2_new_decoded_options;\n static const char *libraries = NULL;  /* Abbreviated libraries.  */\n+static const char *m2_path_name = \"\";\n \n+typedef struct named_path_s {\n+  std::vector<const char*>path;\n+  const char *name;\n+} named_path;\n+\n+static std::vector<named_path>Ipaths;\n+\n+\n+static void\n+push_back_Ipath (const char *arg)\n+{\n+  if (Ipaths.empty ())\n+    {\n+      named_path np;\n+      np.path.push_back (arg);\n+      np.name = m2_path_name;\n+      Ipaths.push_back (np);\n+    }\n+  else\n+    {\n+      if (strcmp (Ipaths.back ().name,\n+\t\t  m2_path_name) == 0)\n+\tIpaths.back ().path.push_back (arg);\n+      else\n+\t{\n+\t  named_path np;\n+\t  np.path.push_back (arg);\n+\t  np.name = m2_path_name;\n+\t  Ipaths.push_back (np);\n+\t}\n+    }\n+}\n \n /* Return whether strings S1 and S2 are both NULL or both the same\n    string.  */\n@@ -342,6 +377,24 @@ convert_abbreviations (const char *libraries)\n   return full_libraries;\n }\n \n+/* add_m2_I_path appends -fm2-pathname and -fm2-pathnameI options to\n+   the command line which are contructed in the saved Ipaths.  */\n+\n+static void\n+add_m2_I_path (void)\n+{\n+  for (auto np : Ipaths)\n+    {\n+      if (strcmp (np.name, \"\") == 0)\n+\tappend_option (OPT_fm2_pathname_, safe_strdup (\"-\"), 1);\n+      else\n+\t  append_option (OPT_fm2_pathname_, safe_strdup (np.name), 1);\n+      for (auto *s : np.path)\n+\tappend_option (OPT_fm2_pathnameI, safe_strdup (s), 1);\n+    }\n+  Ipaths.clear();\n+}\n+\n \n void\n lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n@@ -429,6 +482,7 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n   fprintf (stderr, \"\\n\");\n #endif\n \n+  // add_spec_function (\"m2I\", add_m2_I_path);\n   gm2_xargc = argc;\n   gm2_x_decoded_options = decoded_options;\n   gm2_newargc = 0;\n@@ -514,7 +568,14 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n \t  seen_uselist = true;\n \t  uselist = decoded_options[i].value;\n \t  break;\n-\n+\tcase OPT_fm2_pathname_:\n+\t  args[i] |= SKIPOPT; /* We will add the option if it is needed.  */\n+\t  m2_path_name = decoded_options[i].arg;\n+\t  break;\n+\tcase OPT_I:\n+\t  args[i] |= SKIPOPT; /* We will add the option if it is needed.  */\n+\t  push_back_Ipath (decoded_options[i].arg);\n+\t  break;\n \tcase OPT_nostdlib:\n \tcase OPT_nostdlib__:\n \tcase OPT_nodefaultlibs:\n@@ -670,6 +731,7 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n #endif\n     }\n \n+  add_m2_I_path ();\n   /* We now add in extra arguments to facilitate a successful link.\n      Note that the libraries are added to the end of the link here\n      and also placed earlier into the link by lang-specs.h.  Possibly"}, {"sha": "a564779d2e724b79e75b7e8a5d6f50e56c93721b", "filename": "gcc/m2/lang-specs.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Flang-specs.h?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -41,16 +41,17 @@ along with GCC; see the file COPYING3.  If not see\n   {\"@modula-2\",\n    /* For preprocessing we use cc1 but wrap it in cc1gm2.  */\n    \"%{E|M|MM:\\\n-      cc1gm2 \" M2CPP \" %{!fcpp:-fcpp;:%{fcpp}} %{I*} %i } \\\n+      cc1gm2 \" M2CPP \" %{!fcpp:-fcpp;:%{fcpp}} %{fm2-pathname*} %i } \\\n     %{!E:%{!M:%{!MM:\\\n-      cc1gm2 \" M2CPP \" %(cc1_options) %{I*} %i %{c} \\\n+      cc1gm2 \" M2CPP \" %(cc1_options) %{fm2-pathname*} %i %{c} \\\n       %{!fcpp:%{MD|MMD|MF*: \\\n \t\t%eto generate dependencies you must specify '-fcpp' }} \\\n       %{!fsyntax-only:%(invoke_as)} \\\n     }}}\", 0, 0, 0},\n   {\".m2i\", \"@modula-2-cpp-output\", 0, 0, 0},\n   {\"@modula-2-cpp-output\",\n    \"%{!M:%{!MM:%{!E: \\\n-      cc1gm2 %<fcpp %(cc1_options) %{v} %I -fmod=.mod.m2i -fdef=.def.m2i %{I*} \\\n+      cc1gm2 %<fcpp %(cc1_options) %{v} %I -fmod=.mod.m2i -fdef=.def.m2i \\\n+        %{fm2-pathname*} \\\n \t-fpreprocessed %i %{c} \\\n     %{!fsyntax-only:%(invoke_as)}}}}\", 0, 0, 0},"}, {"sha": "691a75f2e4e0f24c5bd92feaffafb72d502962d2", "filename": "gcc/m2/lang.opt", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Flang.opt?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -134,9 +134,21 @@ fm2-lower-case\n Modula-2\n generate error messages which render keywords in lower case\n \n+fm2-pathname=\n+Modula-2 Joined\n+specify the module mangled prefix name for all modules in the following include paths\n+\n+fm2-pathnameI\n+Modula-2 Joined\n+; For internal use only: used by the driver to copy the user facing -I option\n+\n fm2-plugin\n Modula-2\n-insert plugin to identify runtime errors at compiletime (default on)\n+insert plugin to identify runtime errors at compiletime\n+\n+fm2-prefix=\n+Modula-2 Joined\n+specify the module mangled prefix name\n \n fm2-statistics\n Modula-2"}, {"sha": "815abc3b37174928095beaa8031a7ffcb5706578", "filename": "gcc/m2/mc-boot-ch/GUnixArgs.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot-ch%2FGUnixArgs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot-ch%2FGUnixArgs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGUnixArgs.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -25,7 +25,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include <config.h>\n-#include \"m2rts.h\"\n+// #include \"m2rts.h\"\n \n \n extern \"C\" int UnixArgs_GetArgC (void);\n@@ -82,10 +82,12 @@ _M2_UnixArgs_dep (void)\n {\n }\n \n+#if 0\n struct _M2_UnixArgs_ctor { _M2_UnixArgs_ctor (); } _M2_UnixArgs_ctor;\n \n _M2_UnixArgs_ctor::_M2_UnixArgs_ctor (void)\n {\n   M2RTS_RegisterModule (\"UnixArgs\", _M2_UnixArgs_init, _M2_UnixArgs_fini,\n \t\t\t_M2_UnixArgs_dep);\n }\n+#endif"}, {"sha": "b94aae3322ae27f44a3fc39e9f378c4b9ac1af99", "filename": "gcc/m2/mc-boot-ch/Glibc.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot-ch%2FGlibc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot-ch%2FGlibc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGlibc.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -125,7 +125,43 @@ libc_printf (char *_format, unsigned int _format_high, ...)\n   va_start (arg, _format_high);\n   done = vfprintf (stdout, format, arg);\n   va_end (arg);\n+  return done;\n+}\n+\n+EXTERN\n+int\n+libc_snprintf (char *dest, size_t length, char *_format, unsigned int _format_high, ...)\n+{\n+  va_list arg;\n+  int done;\n+  char format[_format_high + 1];\n+  unsigned int i = 0;\n+  unsigned int j = 0;\n+  char *c;\n+\n+  do\n+    {\n+      c = index (&_format[i], '\\\\');\n+      if (c == NULL)\n+        strcpy (&format[j], &_format[i]);\n+      else\n+        {\n+          memcpy (&format[j], &_format[i], (c - _format) - i);\n+          i = c - _format;\n+          j += c - _format;\n+          if (_format[i + 1] == 'n')\n+            format[j] = '\\n';\n+          else\n+            format[j] = _format[i + 1];\n+          j++;\n+          i += 2;\n+        }\n+    }\n+  while (c != NULL);\n \n+  va_start (arg, _format_high);\n+  done = vsnprintf (dest, length, format, arg);\n+  va_end (arg);\n   return done;\n }\n "}, {"sha": "d9f3be4a09b00c1a7d6ea69caabc6be168d0912a", "filename": "gcc/m2/mc-boot-ch/m2rts.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot-ch%2Fm2rts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot-ch%2Fm2rts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2Fm2rts.h?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -28,8 +28,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n typedef void (*proc_con) (int, char **, char **);\n typedef void (*proc_dep) (void);\n \n-extern \"C\" void M2RTS_RequestDependant (const char *modulename, const char *dependancy);\n-extern \"C\" void M2RTS_RegisterModule (const char *modulename,\n+extern \"C\" void M2RTS_RequestDependant (const char *modulename, const char *libname,\n+\t\t\t\t\tconst char *dependancy, const char *deplib);\n+extern \"C\" void M2RTS_RegisterModule (const char *modulename, const char *libname,\n \t\t\t\t      proc_con init, proc_con fini, proc_dep dependencies);\n extern \"C\" void _M2_M2RTS_init (void);\n "}, {"sha": "2099c2b420b32b238cf4a9da028895eb3155dccd", "filename": "gcc/m2/mc-boot/GDynamicStrings.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGDynamicStrings.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGDynamicStrings.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGDynamicStrings.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -1214,7 +1214,7 @@ static void ConcatContents (DynamicStrings_Contents *c, const char *a_, unsigned\n       (*c).next->contents.next = NULL;\n       ConcatContents (&(*c).next->contents, (const char *) a, _a_high, h, o);\n       AddDebugInfo ((*c).next);\n-      (*c).next = AssignDebug ((*c).next, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 722, (const char *) \"ConcatContents\", 14);\n+      (*c).next = AssignDebug ((*c).next, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 722, (const char *) \"ConcatContents\", 14);\n     }\n   else\n     {\n@@ -1312,7 +1312,7 @@ static void ConcatContentsAddress (DynamicStrings_Contents *c, void * a, unsigne\n       AddDebugInfo ((*c).next);\n       if (TraceOn)\n         {\n-          (*c).next = AssignDebug ((*c).next, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 917, (const char *) \"ConcatContentsAddress\", 21);\n+          (*c).next = AssignDebug ((*c).next, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 917, (const char *) \"ConcatContentsAddress\", 21);\n         }\n     }\n   else\n@@ -1537,7 +1537,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_InitString (const char *a_, unsi\n   AddDebugInfo (s);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 758, (const char *) \"InitString\", 10);\n+      s = AssignDebug (s, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 758, (const char *) \"InitString\", 10);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -1640,7 +1640,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_InitStringCharStar (void * a)\n   AddDebugInfo (s);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 957, (const char *) \"InitStringCharStar\", 18);\n+      s = AssignDebug (s, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 957, (const char *) \"InitStringCharStar\", 18);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -1665,7 +1665,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_InitStringChar (char ch)\n   s = DynamicStrings_InitString ((const char *) &a.array[0], 1);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 977, (const char *) \"InitStringChar\", 14);\n+      s = AssignDebug (s, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 977, (const char *) \"InitStringChar\", 14);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -1823,7 +1823,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_Dup (DynamicStrings_String s)\n   s = DynamicStrings_Assign (DynamicStrings_InitString ((const char *) \"\", 0), s);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1173, (const char *) \"Dup\", 3);\n+      s = AssignDebug (s, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1173, (const char *) \"Dup\", 3);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -1845,7 +1845,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_Add (DynamicStrings_String a, Dy\n   a = DynamicStrings_ConCat (DynamicStrings_ConCat (DynamicStrings_InitString ((const char *) \"\", 0), a), b);\n   if (TraceOn)\n     {\n-      a = AssignDebug (a, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1193, (const char *) \"Add\", 3);\n+      a = AssignDebug (a, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1193, (const char *) \"Add\", 3);\n     }\n   return a;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -1910,7 +1910,7 @@ extern \"C\" unsigned int DynamicStrings_EqualCharStar (DynamicStrings_String s, v\n   t = DynamicStrings_InitStringCharStar (a);\n   if (TraceOn)\n     {\n-      t = AssignDebug (t, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1250, (const char *) \"EqualCharStar\", 13);\n+      t = AssignDebug (t, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1250, (const char *) \"EqualCharStar\", 13);\n     }\n   t = AddToGarbage (t, s);\n   if (DynamicStrings_Equal (t, s))\n@@ -1948,7 +1948,7 @@ extern \"C\" unsigned int DynamicStrings_EqualArray (DynamicStrings_String s, cons\n   t = DynamicStrings_InitString ((const char *) a, _a_high);\n   if (TraceOn)\n     {\n-      t = AssignDebug (t, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1280, (const char *) \"EqualArray\", 10);\n+      t = AssignDebug (t, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1280, (const char *) \"EqualArray\", 10);\n     }\n   t = AddToGarbage (t, s);\n   if (DynamicStrings_Equal (t, s))\n@@ -1986,7 +1986,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_Mult (DynamicStrings_String s, u\n     }\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1312, (const char *) \"Mult\", 4);\n+      s = AssignDebug (s, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1312, (const char *) \"Mult\", 4);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -2065,7 +2065,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_Slice (DynamicStrings_String s,\n                       AddDebugInfo (t->contents.next);\n                       if (TraceOn)\n                         {\n-                          t->contents.next = AssignDebug (t->contents.next, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1380, (const char *) \"Slice\", 5);\n+                          t->contents.next = AssignDebug (t->contents.next, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1380, (const char *) \"Slice\", 5);\n                         }\n                     }\n                   t = t->contents.next;\n@@ -2083,7 +2083,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_Slice (DynamicStrings_String s,\n     }\n   if (TraceOn)\n     {\n-      d = AssignDebug (d, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1397, (const char *) \"Slice\", 5);\n+      d = AssignDebug (d, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1397, (const char *) \"Slice\", 5);\n     }\n   return d;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -2211,7 +2211,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_RemoveComment (DynamicStrings_St\n     }\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1509, (const char *) \"RemoveComment\", 13);\n+      s = AssignDebug (s, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1509, (const char *) \"RemoveComment\", 13);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -2236,7 +2236,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_RemoveWhitePrefix (DynamicString\n   s = DynamicStrings_Slice (s, (int ) (i), 0);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1621, (const char *) \"RemoveWhitePrefix\", 17);\n+      s = AssignDebug (s, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1621, (const char *) \"RemoveWhitePrefix\", 17);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -2261,7 +2261,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_RemoveWhitePostfix (DynamicStrin\n   s = DynamicStrings_Slice (s, 0, i+1);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1643, (const char *) \"RemoveWhitePostfix\", 18);\n+      s = AssignDebug (s, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1643, (const char *) \"RemoveWhitePostfix\", 18);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -2630,7 +2630,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_PopAllocationExemption (unsigned\n         {\n           stop ();\n           /* writeString (\"mismatched number of PopAllocation's compared to PushAllocation's\")  */\n-          M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 176, (const char *) \"PopAllocationExemption\", 22, (const char *) \"mismatched number of PopAllocation's compared to PushAllocation's\", 65);\n+          M2RTS_Halt ((const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 176, (const char *) \"PopAllocationExemption\", 22, (const char *) \"mismatched number of PopAllocation's compared to PushAllocation's\", 65);\n         }\n       else\n         {"}, {"sha": "4a6056f35e33e148debd073689a9577a52b06b96", "filename": "gcc/m2/mc-boot/GFIO.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGFIO.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGFIO.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGFIO.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -555,7 +555,7 @@ static FIO_File GetNextFreeDescriptor (void)\n         return f;  /* create new slot  */\n       }\n   }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/FIO.def\", 25, 1);\n+  ReturnException (\"../../gcc/m2/gm2-libs/FIO.def\", 25, 1);\n   __builtin_unreachable ();\n }\n \n@@ -726,7 +726,7 @@ static int ReadFromBuffer (FIO_File f, void * a, unsigned int nBytes)\n                   (*p) = static_cast<unsigned char> ((*fd->buffer->contents).array[fd->buffer->position]);\n                   fd->buffer->left -= 1;  /* remove consumed bytes  */\n                   fd->buffer->position += 1;  /* move onwards n bytes  */\n-                  nBytes = 0;  /* reduce the amount for future direct  */\n+                  nBytes = 0;\n                   /* read  */\n                   return 1;\n                 }\n@@ -821,7 +821,6 @@ static int BufferedRead (FIO_File f, unsigned int nBytes, void * a)\n \n   if (f != Error)\n     {\n-      /* avoid dangling else.  */\n       fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n       total = 0;  /* how many bytes have we read  */\n       if (fd != NULL)  /* how many bytes have we read  */\n@@ -891,16 +890,9 @@ static int BufferedRead (FIO_File f, unsigned int nBytes, void * a)\n                 }\n               return total;\n             }\n-          else\n-            {\n-              return -1;\n-            }\n         }\n     }\n-  else\n-    {\n-      return -1;\n-    }\n+  return -1;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n   __builtin_unreachable ();\n }\n@@ -2266,7 +2258,8 @@ extern \"C\" void * FIO_getFileName (FIO_File f)\n           return fd->name.address;\n         }\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/FIO.def\", 25, 1);\n+  return NULL;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n   __builtin_unreachable ();\n }\n \n@@ -2293,7 +2286,8 @@ extern \"C\" unsigned int FIO_getFileNameLength (FIO_File f)\n           return fd->name.size;\n         }\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/FIO.def\", 25, 1);\n+  return 0;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n   __builtin_unreachable ();\n }\n "}, {"sha": "f6ec58272c058afe659026414cff148c63855490", "filename": "gcc/m2/mc-boot/GIndexing.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGIndexing.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGIndexing.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGIndexing.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -222,7 +222,7 @@ extern \"C\" unsigned int Indexing_InBounds (Indexing_Index i, unsigned int n)\n     {\n       return (n >= i->Low) && (n <= i->High);\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/Indexing.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/Indexing.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -242,7 +242,7 @@ extern \"C\" unsigned int Indexing_HighIndice (Indexing_Index i)\n     {\n       return i->High;\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/Indexing.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/Indexing.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -262,7 +262,7 @@ extern \"C\" unsigned int Indexing_LowIndice (Indexing_Index i)\n     {\n       return i->Low;\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/Indexing.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/Indexing.def\", 20, 1);\n   __builtin_unreachable ();\n }\n "}, {"sha": "64441fff6429e31566956946208c10c3cbd62784", "filename": "gcc/m2/mc-boot/GM2Dependent.c", "status": "modified", "additions": 348, "deletions": 102, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGM2Dependent.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGM2Dependent.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGM2Dependent.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -83,6 +83,7 @@ struct M2Dependent_DependencyList_r {\n struct M2Dependent__T3_a { M2Dependent_ModuleChain array[M2Dependent_user-M2Dependent_unregistered+1]; };\n struct M2Dependent__T2_r {\n                            void *name;\n+                           void *libname;\n                            M2Dependent_ArgCVEnvP init;\n                            M2Dependent_ArgCVEnvP fini;\n                            M2Dependent_DependencyList dependency;\n@@ -92,7 +93,9 @@ struct M2Dependent__T2_r {\n \n static M2Dependent__T3 Modules;\n static unsigned int Initialized;\n+static unsigned int WarningTrace;\n static unsigned int ModuleTrace;\n+static unsigned int HexTrace;\n static unsigned int DependencyTrace;\n static unsigned int PreTrace;\n static unsigned int PostTrace;\n@@ -103,37 +106,37 @@ static unsigned int ForceTrace;\n                       module constructor in turn.\n */\n \n-extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n+extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n \n /*\n    DeconstructModules - resolve dependencies and then call each\n                         module constructor in turn.\n */\n \n-extern \"C\" void M2Dependent_DeconstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n+extern \"C\" void M2Dependent_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n \n /*\n    RegisterModule - adds module name to the list of outstanding\n                     modules which need to have their dependencies\n                     explored to determine initialization order.\n */\n \n-extern \"C\" void M2Dependent_RegisterModule (void * name, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies);\n+extern \"C\" void M2Dependent_RegisterModule (void * modulename, void * libname, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies);\n \n /*\n    RequestDependant - used to specify that modulename is dependant upon\n                       module dependantmodule.  It only takes effect\n                       if we are not using StaticInitialization.\n */\n \n-extern \"C\" void M2Dependent_RequestDependant (void * modulename, void * dependantmodule);\n+extern \"C\" void M2Dependent_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname);\n \n /*\n    CreateModule - creates a new module entry and returns the\n                   ModuleChain.\n */\n \n-static M2Dependent_ModuleChain CreateModule (void * name, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies);\n+static M2Dependent_ModuleChain CreateModule (void * name, void * libname, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies);\n \n /*\n    AppendModule - append chain to end of the list.\n@@ -154,18 +157,30 @@ static void RemoveModule (M2Dependent_ModuleChain *head, M2Dependent_ModuleChain\n static unsigned int onChain (M2Dependent_DependencyState state, M2Dependent_ModuleChain mptr);\n \n /*\n-   LookupModuleN - lookup module from the state list.  The string is limited\n-                   to nchar.\n+   max -\n */\n \n-static M2Dependent_ModuleChain LookupModuleN (M2Dependent_DependencyState state, void * name, unsigned int nchar);\n+static unsigned int max (unsigned int a, unsigned int b);\n+\n+/*\n+   min -\n+*/\n+\n+static unsigned int min (unsigned int a, unsigned int b);\n+\n+/*\n+   LookupModuleN - lookup module from the state list.\n+                   The strings lengths are known.\n+*/\n+\n+static M2Dependent_ModuleChain LookupModuleN (M2Dependent_DependencyState state, void * name, unsigned int namelen, void * libname, unsigned int libnamelen);\n \n /*\n    LookupModule - lookup and return the ModuleChain pointer containing\n                   module name from a particular list.\n */\n \n-static M2Dependent_ModuleChain LookupModule (M2Dependent_DependencyState state, void * name);\n+static M2Dependent_ModuleChain LookupModule (M2Dependent_DependencyState state, void * name, void * libname);\n \n /*\n    toCString - replace any character sequence \n@@ -206,6 +221,12 @@ static void traceprintf (unsigned int flag, const char *str_, unsigned int _str_\n \n static void traceprintf2 (unsigned int flag, const char *str_, unsigned int _str_high, void * arg);\n \n+/*\n+   traceprintf3 - wrap printf with a boolean flag.\n+*/\n+\n+static void traceprintf3 (unsigned int flag, const char *str_, unsigned int _str_high, void * arg1, void * arg2);\n+\n /*\n    moveTo - moves mptr to the new list determined by newstate.\n             It updates the mptr state appropriately.\n@@ -217,7 +238,7 @@ static void moveTo (M2Dependent_DependencyState newstate, M2Dependent_ModuleChai\n    ResolveDependant -\n */\n \n-static void ResolveDependant (M2Dependent_ModuleChain mptr, void * currentmodule);\n+static void ResolveDependant (M2Dependent_ModuleChain mptr, void * currentmodule, void * libname);\n \n /*\n    PerformRequestDependant - the current modulename has a dependancy upon\n@@ -226,19 +247,19 @@ static void ResolveDependant (M2Dependent_ModuleChain mptr, void * currentmodule\n                              resolved.\n */\n \n-static void PerformRequestDependant (void * modulename, void * dependantmodule);\n+static void PerformRequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname);\n \n /*\n-   ResolveDependencies - resolve dependencies for currentmodule.\n+   ResolveDependencies - resolve dependencies for currentmodule, libname.\n */\n \n-static void ResolveDependencies (void * currentmodule);\n+static void ResolveDependencies (void * currentmodule, void * libname);\n \n /*\n    DisplayModuleInfo - displays all module in the state.\n */\n \n-static void DisplayModuleInfo (M2Dependent_DependencyState state, const char *name_, unsigned int _name_high);\n+static void DisplayModuleInfo (M2Dependent_DependencyState state, const char *desc_, unsigned int _desc_high);\n \n /*\n    DumpModuleData -\n@@ -255,6 +276,18 @@ static void DumpModuleData (unsigned int flag);\n \n static void combine (M2Dependent_DependencyState src, M2Dependent_DependencyState dest);\n \n+/*\n+   tracemodule -\n+*/\n+\n+static void tracemodule (unsigned int flag, void * modname, unsigned int modlen, void * libname, unsigned int liblen);\n+\n+/*\n+   ForceModule -\n+*/\n+\n+static void ForceModule (void * modname, unsigned int modlen, void * libname, unsigned int liblen);\n+\n /*\n    ForceDependencies - if the user has specified a forced order then we override\n                        the dynamic ordering with the preference.\n@@ -269,6 +302,12 @@ static void ForceDependencies (void);\n \n static void CheckApplication (void);\n \n+/*\n+   warning3 - write format arg1 arg2 to stderr.\n+*/\n+\n+static void warning3 (const char *format_, unsigned int _format_high, void * arg1, void * arg2);\n+\n /*\n    equal - return TRUE if C string cstr is equal to str.\n */\n@@ -279,11 +318,12 @@ static unsigned int equal (void * cstr, const char *str_, unsigned int _str_high\n    SetupDebugFlags - By default assigns ModuleTrace, DependencyTrace,\n                      DumpPostInit to FALSE.  It checks the environment\n                      GCC_M2LINK_RTFLAG which can contain\n-                     \"all,module,pre,post,dep,force\".  all turns them all on.\n+                     \"all,module,hex,pre,post,dep,force\".  all turns them all on.\n                      The flag meanings are as follows and flags the are in\n                      execution order.\n \n                      module   generate trace info as the modules are registered.\n+                     hex      dump the modules ctor functions address in hex.\n                      pre      generate a list of all modules seen prior to having\n                               their dependancies resolved.\n                      dep      display a trace as the modules are resolved.\n@@ -316,18 +356,26 @@ static void CheckInitialized (void);\n                   ModuleChain.\n */\n \n-static M2Dependent_ModuleChain CreateModule (void * name, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies)\n+static M2Dependent_ModuleChain CreateModule (void * name, void * libname, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies)\n {\n   M2Dependent_ModuleChain mptr;\n+  void * p0;\n+  void * p1;\n \n   Storage_ALLOCATE ((void **) &mptr, sizeof (M2Dependent__T2));\n   mptr->name = name;\n+  mptr->libname = libname;\n   mptr->init = init;\n   mptr->fini = fini;\n   mptr->dependency.proc = dependencies;\n   mptr->dependency.state = M2Dependent_unregistered;\n   mptr->prev = NULL;\n   mptr->next = NULL;\n+  if (HexTrace)\n+    {\n+      libc_printf ((const char *) \"   (init: %p  fini: %p\", 22, init, fini);\n+      libc_printf ((const char *) \"  dep: %p)\", 10, dependencies);\n+    }\n   return mptr;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n   __builtin_unreachable ();\n@@ -404,19 +452,57 @@ static unsigned int onChain (M2Dependent_DependencyState state, M2Dependent_Modu\n \n \n /*\n-   LookupModuleN - lookup module from the state list.  The string is limited\n-                   to nchar.\n+   max -\n+*/\n+\n+static unsigned int max (unsigned int a, unsigned int b)\n+{\n+  if (a > b)\n+    {\n+      return a;\n+    }\n+  else\n+    {\n+      return b;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   min -\n */\n \n-static M2Dependent_ModuleChain LookupModuleN (M2Dependent_DependencyState state, void * name, unsigned int nchar)\n+static unsigned int min (unsigned int a, unsigned int b)\n+{\n+  if (a < b)\n+    {\n+      return a;\n+    }\n+  else\n+    {\n+      return b;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   LookupModuleN - lookup module from the state list.\n+                   The strings lengths are known.\n+*/\n+\n+static M2Dependent_ModuleChain LookupModuleN (M2Dependent_DependencyState state, void * name, unsigned int namelen, void * libname, unsigned int libnamelen)\n {\n   M2Dependent_ModuleChain ptr;\n \n   if (Modules.array[state-M2Dependent_unregistered] != NULL)\n     {\n       ptr = Modules.array[state-M2Dependent_unregistered];\n       do {\n-        if ((strncmp (reinterpret_cast<M2LINK_PtrToChar> (ptr->name), reinterpret_cast<M2LINK_PtrToChar> (name), nchar)) == 0)\n+        if (((strncmp (reinterpret_cast<M2LINK_PtrToChar> (ptr->name), reinterpret_cast<M2LINK_PtrToChar> (name), max (namelen, static_cast<unsigned int> (strlen_ (reinterpret_cast<M2LINK_PtrToChar> (ptr->name)))))) == 0) && ((strncmp (reinterpret_cast<M2LINK_PtrToChar> (ptr->libname), reinterpret_cast<M2LINK_PtrToChar> (libname), max (libnamelen, static_cast<unsigned int> (strlen_ (reinterpret_cast<M2LINK_PtrToChar> (ptr->libname)))))) == 0))\n           {\n             return ptr;\n           }\n@@ -434,9 +520,9 @@ static M2Dependent_ModuleChain LookupModuleN (M2Dependent_DependencyState state,\n                   module name from a particular list.\n */\n \n-static M2Dependent_ModuleChain LookupModule (M2Dependent_DependencyState state, void * name)\n+static M2Dependent_ModuleChain LookupModule (M2Dependent_DependencyState state, void * name, void * libname)\n {\n-  return LookupModuleN (state, name, static_cast<unsigned int> (strlen_ (reinterpret_cast<M2LINK_PtrToChar> (name))));\n+  return LookupModuleN (state, name, static_cast<unsigned int> (strlen_ (reinterpret_cast<M2LINK_PtrToChar> (name))), libname, static_cast<unsigned int> (strlen_ (reinterpret_cast<M2LINK_PtrToChar> (libname))));\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n   __builtin_unreachable ();\n }\n@@ -515,9 +601,13 @@ static int strcmp (M2LINK_PtrToChar a, M2LINK_PtrToChar b)\n \n static int strncmp (M2LINK_PtrToChar a, M2LINK_PtrToChar b, unsigned int n)\n {\n-  if (((a != NULL) && (b != NULL)) && (n > 0))\n+  if (n == 0)\n     {\n-      /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+      return 0;\n+    }\n+  else if ((a != NULL) && (b != NULL))\n+    {\n+      /* avoid dangling else.  */\n       if (a == b)\n         {\n           return 0;\n@@ -594,6 +684,7 @@ static void traceprintf (unsigned int flag, const char *str_, unsigned int _str_\n \n static void traceprintf2 (unsigned int flag, const char *str_, unsigned int _str_high, void * arg)\n {\n+  char ch;\n   char str[_str_high+1];\n \n   /* make a local copy of each unbounded array.  */\n@@ -602,11 +693,46 @@ static void traceprintf2 (unsigned int flag, const char *str_, unsigned int _str\n   if (flag)\n     {\n       toCString ((char *) str, _str_high);\n+      if (arg == NULL)\n+        {\n+          ch = (char) 0;\n+          arg = &ch;\n+        }\n       libc_printf ((const char *) str, _str_high, arg);\n     }\n }\n \n \n+/*\n+   traceprintf3 - wrap printf with a boolean flag.\n+*/\n+\n+static void traceprintf3 (unsigned int flag, const char *str_, unsigned int _str_high, void * arg1, void * arg2)\n+{\n+  char ch;\n+  char str[_str_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (str, str_, _str_high+1);\n+\n+  if (flag)\n+    {\n+      toCString ((char *) str, _str_high);\n+      if (arg1 == NULL)\n+        {\n+          ch = (char) 0;\n+          arg1 = &ch;\n+        }\n+      if (arg2 == NULL)\n+        {\n+          ch = (char) 0;\n+          arg2 = &ch;\n+        }\n+      libc_printf ((const char *) str, _str_high, arg1, arg2);\n+    }\n+}\n+\n+\n /*\n    moveTo - moves mptr to the new list determined by newstate.\n             It updates the mptr state appropriately.\n@@ -627,11 +753,11 @@ static void moveTo (M2Dependent_DependencyState newstate, M2Dependent_ModuleChai\n    ResolveDependant -\n */\n \n-static void ResolveDependant (M2Dependent_ModuleChain mptr, void * currentmodule)\n+static void ResolveDependant (M2Dependent_ModuleChain mptr, void * currentmodule, void * libname)\n {\n   if (mptr == NULL)\n     {\n-      traceprintf (DependencyTrace, (const char *) \"   module has not been registered via a global constructor\\\\n\", 60);\n+      traceprintf3 (DependencyTrace, (const char *) \"   module %s [%s] has not been registered via a global constructor\\\\n\", 68, currentmodule, libname);\n     }\n   else\n     {\n@@ -642,9 +768,9 @@ static void ResolveDependant (M2Dependent_ModuleChain mptr, void * currentmodule\n       else\n         {\n           moveTo (M2Dependent_started, mptr);\n-          traceprintf2 (DependencyTrace, (const char *) \"   starting: %s\\\\n\", 17, currentmodule);\n+          traceprintf3 (DependencyTrace, (const char *) \"   starting: %s [%s]\\\\n\", 22, currentmodule, libname);\n           (*mptr->dependency.proc.proc) ();  /* Invoke and process the dependency graph.  */\n-          traceprintf2 (DependencyTrace, (const char *) \"   finished: %s\\\\n\", 17, currentmodule);  /* Invoke and process the dependency graph.  */\n+          traceprintf3 (DependencyTrace, (const char *) \"   finished: %s [%s]\\\\n\", 22, currentmodule, libname);  /* Invoke and process the dependency graph.  */\n           moveTo (M2Dependent_ordered, mptr);\n         }\n     }\n@@ -658,73 +784,73 @@ static void ResolveDependant (M2Dependent_ModuleChain mptr, void * currentmodule\n                              resolved.\n */\n \n-static void PerformRequestDependant (void * modulename, void * dependantmodule)\n+static void PerformRequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname)\n {\n   M2Dependent_ModuleChain mptr;\n \n-  traceprintf2 (DependencyTrace, (const char *) \"  module %s\", 11, modulename);\n+  traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s]\", 16, modulename, libname);\n   if (dependantmodule == NULL)\n     {\n       /* avoid dangling else.  */\n-      traceprintf2 (DependencyTrace, (const char *) \" has finished its import graph\\\\n\", 32, modulename);\n-      mptr = LookupModule (M2Dependent_unordered, modulename);\n+      traceprintf (DependencyTrace, (const char *) \" has finished its import graph\\\\n\", 32);\n+      mptr = LookupModule (M2Dependent_unordered, modulename, libname);\n       if (mptr != NULL)\n         {\n-          traceprintf2 (DependencyTrace, (const char *) \"  module %s is now ordered\\\\n\", 28, modulename);\n+          traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] is now ordered\\\\n\", 33, modulename, libname);\n           moveTo (M2Dependent_ordered, mptr);\n         }\n     }\n   else\n     {\n-      traceprintf2 (DependencyTrace, (const char *) \" imports from %s\\\\n\", 18, dependantmodule);\n-      mptr = LookupModule (M2Dependent_ordered, dependantmodule);\n+      traceprintf3 (DependencyTrace, (const char *) \" imports from %s [%s]\\\\n\", 23, dependantmodule, dependantlibname);\n+      mptr = LookupModule (M2Dependent_ordered, dependantmodule, dependantlibname);\n       if (mptr == NULL)\n         {\n-          traceprintf2 (DependencyTrace, (const char *) \"  module %s is not ordered\\\\n\", 28, dependantmodule);\n-          mptr = LookupModule (M2Dependent_unordered, dependantmodule);\n+          traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] is not ordered\\\\n\", 33, dependantmodule, dependantlibname);\n+          mptr = LookupModule (M2Dependent_unordered, dependantmodule, dependantlibname);\n           if (mptr == NULL)\n             {\n-              traceprintf2 (DependencyTrace, (const char *) \"  module %s is not unordered\\\\n\", 30, dependantmodule);\n-              mptr = LookupModule (M2Dependent_started, dependantmodule);\n+              traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] is not unordered\\\\n\", 35, dependantmodule, dependantlibname);\n+              mptr = LookupModule (M2Dependent_started, dependantmodule, dependantlibname);\n               if (mptr == NULL)\n                 {\n-                  traceprintf2 (DependencyTrace, (const char *) \"  module %s has not started\\\\n\", 29, dependantmodule);\n-                  traceprintf2 (DependencyTrace, (const char *) \"  module %s attempting to import from\", 37, modulename);\n-                  traceprintf2 (DependencyTrace, (const char *) \" %s which has not registered itself via a constructor\\\\n\", 55, dependantmodule);\n+                  traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] has not started\\\\n\", 34, dependantmodule, dependantlibname);\n+                  traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] attempting to import from\", 42, modulename, libname);\n+                  traceprintf3 (DependencyTrace, (const char *) \" %s [%s] which has not registered itself via a constructor\\\\n\", 60, dependantmodule, dependantlibname);\n                 }\n               else\n                 {\n-                  traceprintf2 (DependencyTrace, (const char *) \"  module %s has registered itself and has started\\\\n\", 51, dependantmodule);\n+                  traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] has registered itself and has started\\\\n\", 56, dependantmodule, dependantlibname);\n                 }\n             }\n           else\n             {\n-              traceprintf2 (DependencyTrace, (const char *) \"  module %s resolving\\\\n\", 23, dependantmodule);\n-              ResolveDependant (mptr, dependantmodule);\n+              traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] resolving\\\\n\", 28, dependantmodule, dependantlibname);\n+              ResolveDependant (mptr, dependantmodule, dependantlibname);\n             }\n         }\n       else\n         {\n-          traceprintf2 (DependencyTrace, (const char *) \"  module %s \", 12, modulename);\n-          traceprintf2 (DependencyTrace, (const char *) \" dependant %s is ordered\\\\n\", 26, dependantmodule);\n+          traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s]\", 16, modulename, libname);\n+          traceprintf3 (DependencyTrace, (const char *) \" dependant %s [%s] is ordered\\\\n\", 31, dependantmodule, dependantlibname);\n         }\n     }\n }\n \n \n /*\n-   ResolveDependencies - resolve dependencies for currentmodule.\n+   ResolveDependencies - resolve dependencies for currentmodule, libname.\n */\n \n-static void ResolveDependencies (void * currentmodule)\n+static void ResolveDependencies (void * currentmodule, void * libname)\n {\n   M2Dependent_ModuleChain mptr;\n \n-  mptr = LookupModule (M2Dependent_unordered, currentmodule);\n+  mptr = LookupModule (M2Dependent_unordered, currentmodule, libname);\n   while (mptr != NULL)\n     {\n-      traceprintf2 (DependencyTrace, (const char *) \"   attempting to resolve the dependants for %s\\\\n\", 48, currentmodule);\n-      ResolveDependant (mptr, currentmodule);\n+      traceprintf3 (DependencyTrace, (const char *) \"   attempting to resolve the dependants for %s [%s]\\\\n\", 53, currentmodule, libname);\n+      ResolveDependant (mptr, currentmodule, libname);\n       mptr = Modules.array[M2Dependent_unordered-M2Dependent_unregistered];\n     }\n }\n@@ -734,22 +860,29 @@ static void ResolveDependencies (void * currentmodule)\n    DisplayModuleInfo - displays all module in the state.\n */\n \n-static void DisplayModuleInfo (M2Dependent_DependencyState state, const char *name_, unsigned int _name_high)\n+static void DisplayModuleInfo (M2Dependent_DependencyState state, const char *desc_, unsigned int _desc_high)\n {\n   M2Dependent_ModuleChain mptr;\n   unsigned int count;\n-  char name[_name_high+1];\n+  char desc[_desc_high+1];\n \n   /* make a local copy of each unbounded array.  */\n-  memcpy (name, name_, _name_high+1);\n+  memcpy (desc, desc_, _desc_high+1);\n \n   if (Modules.array[state-M2Dependent_unregistered] != NULL)\n     {\n-      libc_printf ((const char *) \"%s modules\\\\n\", 12, &name);\n+      libc_printf ((const char *) \"%s modules\\\\n\", 12, &desc);\n       mptr = Modules.array[state-M2Dependent_unregistered];\n       count = 0;\n       do {\n-        libc_printf ((const char *) \"  %d  %s\", 8, count, mptr->name);\n+        if (mptr->name == NULL)\n+          {\n+            libc_printf ((const char *) \"  %d  %s []\", 11, count, mptr->name);\n+          }\n+        else\n+          {\n+            libc_printf ((const char *) \"  %d  %s [%s]\", 13, count, mptr->name, mptr->libname);\n+          }\n         count += 1;\n         if (mptr->dependency.appl)\n           {\n@@ -808,53 +941,111 @@ static void combine (M2Dependent_DependencyState src, M2Dependent_DependencyStat\n }\n \n \n+/*\n+   tracemodule -\n+*/\n+\n+static void tracemodule (unsigned int flag, void * modname, unsigned int modlen, void * libname, unsigned int liblen)\n+{\n+  typedef struct tracemodule__T4_a tracemodule__T4;\n+\n+  struct tracemodule__T4_a { char array[100+1]; };\n+  tracemodule__T4 buffer;\n+  unsigned int len;\n+\n+  if (flag)\n+    {\n+      len = min (modlen, sizeof (buffer)-1);\n+      libc_strncpy (&buffer, modname, len);\n+      buffer.array[len] = (char) 0;\n+      libc_printf ((const char *) \"%s \", 3, &buffer);\n+      len = min (liblen, sizeof (buffer)-1);\n+      libc_strncpy (&buffer, libname, len);\n+      buffer.array[len] = (char) 0;\n+      libc_printf ((const char *) \" [%s]\", 5, &buffer);\n+    }\n+}\n+\n+\n+/*\n+   ForceModule -\n+*/\n+\n+static void ForceModule (void * modname, unsigned int modlen, void * libname, unsigned int liblen)\n+{\n+  M2Dependent_ModuleChain mptr;\n+\n+  traceprintf (ForceTrace, (const char *) \"forcing module: \", 16);\n+  tracemodule (ForceTrace, modname, modlen, libname, liblen);\n+  traceprintf (ForceTrace, (const char *) \"\\\\n\", 2);\n+  mptr = LookupModuleN (M2Dependent_ordered, modname, modlen, libname, liblen);\n+  if (mptr != NULL)\n+    {\n+      mptr->dependency.forced = TRUE;\n+      moveTo (M2Dependent_user, mptr);\n+    }\n+}\n+\n+\n /*\n    ForceDependencies - if the user has specified a forced order then we override\n                        the dynamic ordering with the preference.\n */\n \n static void ForceDependencies (void)\n {\n-  M2Dependent_ModuleChain mptr;\n-  M2Dependent_ModuleChain userChain;\n-  unsigned int count;\n+  unsigned int len;\n+  unsigned int modlen;\n+  unsigned int liblen;\n+  M2LINK_PtrToChar modname;\n+  M2LINK_PtrToChar libname;\n   M2LINK_PtrToChar pc;\n   M2LINK_PtrToChar start;\n \n   if (M2LINK_ForcedModuleInitOrder != NULL)\n     {\n-      userChain = NULL;\n+      traceprintf2 (ForceTrace, (const char *) \"user forcing order: %s\\\\n\", 24, reinterpret_cast<void *> (M2LINK_ForcedModuleInitOrder));\n       pc = M2LINK_ForcedModuleInitOrder;\n       start = pc;\n-      count = 0;\n+      len = 0;\n+      modname = NULL;\n+      modlen = 0;\n+      libname = NULL;\n+      liblen = 0;\n       while ((*pc) != ASCII_nul)\n         {\n-          if ((*pc) == ',')\n-            {\n-              mptr = LookupModuleN (M2Dependent_ordered, reinterpret_cast<void *> (start), count);\n-              if (mptr != NULL)\n-                {\n-                  mptr->dependency.forced = TRUE;\n-                  moveTo (M2Dependent_user, mptr);\n-                }\n-              pc += 1;\n-              start = pc;\n-              count = 0;\n-            }\n-          else\n+          switch ((*pc))\n             {\n-              pc += 1;\n-              count += 1;\n+              case ':':\n+                libname = start;\n+                liblen = len;\n+                len = 0;\n+                pc += 1;\n+                start = pc;\n+                break;\n+\n+              case ',':\n+                modname = start;\n+                modlen = len;\n+                ForceModule (reinterpret_cast<void *> (modname), modlen, reinterpret_cast<void *> (libname), liblen);\n+                libname = NULL;\n+                liblen = 0;\n+                modlen = 0;\n+                len = 0;\n+                pc += 1;\n+                start = pc;\n+                break;\n+\n+\n+              default:\n+                pc += 1;\n+                len += 1;\n+                break;\n             }\n         }\n       if (start != pc)\n         {\n-          mptr = LookupModuleN (M2Dependent_ordered, reinterpret_cast<void *> (start), count);\n-          if (mptr != NULL)\n-            {\n-              mptr->dependency.forced = TRUE;\n-              moveTo (M2Dependent_user, mptr);\n-            }\n+          ForceModule (reinterpret_cast<void *> (start), len, reinterpret_cast<void *> (libname), liblen);\n         }\n       combine (M2Dependent_user, M2Dependent_ordered);\n     }\n@@ -887,12 +1078,39 @@ static void CheckApplication (void)\n       } while (! ((appl != NULL) || (mptr == Modules.array[M2Dependent_ordered-M2Dependent_unregistered])));\n       if (appl != NULL)\n         {\n-          Modules.array[M2Dependent_ordered-M2Dependent_unregistered] = appl->next;\n+          RemoveModule (&Modules.array[M2Dependent_ordered-M2Dependent_unregistered], appl);\n+          AppendModule (&Modules.array[M2Dependent_ordered-M2Dependent_unregistered], appl);\n         }\n     }\n }\n \n \n+/*\n+   warning3 - write format arg1 arg2 to stderr.\n+*/\n+\n+static void warning3 (const char *format_, unsigned int _format_high, void * arg1, void * arg2)\n+{\n+  typedef struct warning3__T5_a warning3__T5;\n+\n+  struct warning3__T5_a { char array[4096+1]; };\n+  warning3__T5 buffer;\n+  int len;\n+  char format[_format_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (format, format_, _format_high+1);\n+\n+  if (WarningTrace)\n+    {\n+      len = libc_snprintf (&buffer, static_cast<size_t> (sizeof (buffer)), (const char *) \"warning: \", 9);\n+      libc_write (2, &buffer, static_cast<size_t> (len));\n+      len = libc_snprintf (&buffer, static_cast<size_t> (sizeof (buffer)), (const char *) format, _format_high, arg1, arg2);\n+      libc_write (2, &buffer, static_cast<size_t> (len));\n+    }\n+}\n+\n+\n /*\n    equal - return TRUE if C string cstr is equal to str.\n */\n@@ -914,11 +1132,12 @@ static unsigned int equal (void * cstr, const char *str_, unsigned int _str_high\n    SetupDebugFlags - By default assigns ModuleTrace, DependencyTrace,\n                      DumpPostInit to FALSE.  It checks the environment\n                      GCC_M2LINK_RTFLAG which can contain\n-                     \"all,module,pre,post,dep,force\".  all turns them all on.\n+                     \"all,module,hex,pre,post,dep,force\".  all turns them all on.\n                      The flag meanings are as follows and flags the are in\n                      execution order.\n \n                      module   generate trace info as the modules are registered.\n+                     hex      dump the modules ctor functions address in hex.\n                      pre      generate a list of all modules seen prior to having\n                               their dependancies resolved.\n                      dep      display a trace as the modules are resolved.\n@@ -939,6 +1158,8 @@ static void SetupDebugFlags (void)\n   PostTrace = FALSE;\n   PreTrace = FALSE;\n   ForceTrace = FALSE;\n+  HexTrace = FALSE;\n+  WarningTrace = FALSE;\n   pc = static_cast<SetupDebugFlags__T1> (libc_getenv (const_cast<void*> (reinterpret_cast<const void*>(\"GCC_M2LINK_RTFLAG\"))));\n   while ((pc != NULL) && ((*pc) != ASCII_nul))\n     {\n@@ -949,6 +1170,8 @@ static void SetupDebugFlags (void)\n           PreTrace = TRUE;\n           PostTrace = TRUE;\n           ForceTrace = TRUE;\n+          HexTrace = TRUE;\n+          WarningTrace = TRUE;\n           pc += 3;\n         }\n       else if (equal (reinterpret_cast<void *> (pc), (const char *) \"module\", 6))\n@@ -957,6 +1180,18 @@ static void SetupDebugFlags (void)\n           ModuleTrace = TRUE;\n           pc += 6;\n         }\n+      else if (equal (reinterpret_cast<void *> (pc), (const char *) \"warning\", 7))\n+        {\n+          /* avoid dangling else.  */\n+          WarningTrace = TRUE;\n+          pc += 7;\n+        }\n+      else if (equal (reinterpret_cast<void *> (pc), (const char *) \"hex\", 3))\n+        {\n+          /* avoid dangling else.  */\n+          HexTrace = TRUE;\n+          pc += 3;\n+        }\n       else if (equal (reinterpret_cast<void *> (pc), (const char *) \"dep\", 3))\n         {\n           /* avoid dangling else.  */\n@@ -1028,21 +1263,21 @@ static void CheckInitialized (void)\n                       module constructor in turn.\n */\n \n-extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, int argc, void * argv, void * envp)\n+extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp)\n {\n   M2Dependent_ModuleChain mptr;\n   M2Dependent_ArgCVEnvP nulp;\n \n   CheckInitialized ();\n-  traceprintf2 (ModuleTrace, (const char *) \"application module: %s\\\\n\", 24, applicationmodule);\n-  mptr = LookupModule (M2Dependent_unordered, applicationmodule);\n+  traceprintf3 (ModuleTrace, (const char *) \"application module: %s [%s]\\\\n\", 29, applicationmodule, libname);\n+  mptr = LookupModule (M2Dependent_unordered, applicationmodule, libname);\n   if (mptr != NULL)\n     {\n       mptr->dependency.appl = TRUE;\n     }\n   traceprintf (PreTrace, (const char *) \"Pre resolving dependents\\\\n\", 26);\n   DumpModuleData (PreTrace);\n-  ResolveDependencies (applicationmodule);\n+  ResolveDependencies (applicationmodule, libname);\n   traceprintf (PreTrace, (const char *) \"Post resolving dependents\\\\n\", 27);\n   DumpModuleData (PostTrace);\n   ForceDependencies ();\n@@ -1053,7 +1288,7 @@ extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, int argc\n   DumpModuleData (ForceTrace);\n   if (Modules.array[M2Dependent_ordered-M2Dependent_unregistered] == NULL)\n     {\n-      traceprintf2 (ModuleTrace, (const char *) \"  module: %s has not registered itself using a global constructor\\\\n\", 67, applicationmodule);\n+      traceprintf3 (ModuleTrace, (const char *) \"  module: %s [%s] has not registered itself using a global constructor\\\\n\", 72, applicationmodule, libname);\n       traceprintf2 (ModuleTrace, (const char *) \"  hint try compile and linking using: gm2 %s.mod\\\\n\", 50, applicationmodule);\n       traceprintf2 (ModuleTrace, (const char *) \"  or try using: gm2 -fscaffold-static %s.mod\\\\n\", 46, applicationmodule);\n     }\n@@ -1063,15 +1298,15 @@ extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, int argc\n       do {\n         if (mptr->dependency.forc)\n           {\n-            traceprintf2 (ModuleTrace, (const char *) \"initializing module: %s for C\\\\n\", 31, mptr->name);\n+            traceprintf3 (ModuleTrace, (const char *) \"initializing module: %s [%s] for C\\\\n\", 36, mptr->name, mptr->libname);\n           }\n         else\n           {\n-            traceprintf2 (ModuleTrace, (const char *) \"initializing module: %s\\\\n\", 25, mptr->name);\n+            traceprintf3 (ModuleTrace, (const char *) \"initializing module: %s [%s]\\\\n\", 30, mptr->name, mptr->libname);\n           }\n         if (mptr->dependency.appl)\n           {\n-            traceprintf2 (ModuleTrace, (const char *) \"application module: %s\\\\n\", 24, mptr->name);\n+            traceprintf3 (ModuleTrace, (const char *) \"application module: %s [%s]\\\\n\", 29, mptr->name, mptr->libname);\n             traceprintf (ModuleTrace, (const char *) \"  calling M2RTS_ExecuteInitialProcedures\\\\n\", 42);\n             M2RTS_ExecuteInitialProcedures ();\n             traceprintf (ModuleTrace, (const char *) \"  calling application module\\\\n\", 30);\n@@ -1088,11 +1323,11 @@ extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, int argc\n                         module constructor in turn.\n */\n \n-extern \"C\" void M2Dependent_DeconstructModules (void * applicationmodule, int argc, void * argv, void * envp)\n+extern \"C\" void M2Dependent_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp)\n {\n   M2Dependent_ModuleChain mptr;\n \n-  traceprintf2 (ModuleTrace, (const char *) \"application module finishing: %s\\\\n\", 34, applicationmodule);\n+  traceprintf3 (ModuleTrace, (const char *) \"application module finishing: %s [%s]\\\\n\", 39, applicationmodule, libname);\n   if (Modules.array[M2Dependent_ordered-M2Dependent_unregistered] == NULL)\n     {\n       traceprintf (ModuleTrace, (const char *) \"  no ordered modules found during finishing\\\\n\", 45);\n@@ -1106,11 +1341,11 @@ extern \"C\" void M2Dependent_DeconstructModules (void * applicationmodule, int ar\n       do {\n         if (mptr->dependency.forc)\n           {\n-            traceprintf2 (ModuleTrace, (const char *) \"finalizing module: %s for C\\\\n\", 29, mptr->name);\n+            traceprintf3 (ModuleTrace, (const char *) \"finalizing module: %s [%s] for C\\\\n\", 34, mptr->name, mptr->libname);\n           }\n         else\n           {\n-            traceprintf2 (ModuleTrace, (const char *) \"finalizing module: %s\\\\n\", 23, mptr->name);\n+            traceprintf3 (ModuleTrace, (const char *) \"finalizing module: %s [%s]\\\\n\", 28, mptr->name, mptr->libname);\n           }\n         (*mptr->fini.proc) (argc, argv, envp);\n         mptr = mptr->prev;\n@@ -1125,13 +1360,24 @@ extern \"C\" void M2Dependent_DeconstructModules (void * applicationmodule, int ar\n                     explored to determine initialization order.\n */\n \n-extern \"C\" void M2Dependent_RegisterModule (void * name, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies)\n+extern \"C\" void M2Dependent_RegisterModule (void * modulename, void * libname, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies)\n {\n+  M2Dependent_ModuleChain mptr;\n+\n   CheckInitialized ();\n   if (! M2LINK_StaticInitialization)\n     {\n-      traceprintf2 (ModuleTrace, (const char *) \"module: %s registering\\\\n\", 24, name);\n-      moveTo (M2Dependent_unordered, CreateModule (name, init, fini, dependencies));\n+      mptr = LookupModule (M2Dependent_unordered, modulename, libname);\n+      if (mptr == NULL)\n+        {\n+          traceprintf3 (ModuleTrace, (const char *) \"module: %s [%s] registering\", 27, modulename, libname);\n+          moveTo (M2Dependent_unordered, CreateModule (modulename, libname, init, fini, dependencies));\n+          traceprintf (ModuleTrace, (const char *) \"\\\\n\", 2);\n+        }\n+      else\n+        {\n+          warning3 ((const char *) \"module: %s [%s] (ignoring duplicate registration)\\\\n\", 51, modulename, libname);\n+        }\n     }\n }\n \n@@ -1142,12 +1388,12 @@ extern \"C\" void M2Dependent_RegisterModule (void * name, M2Dependent_ArgCVEnvP i\n                       if we are not using StaticInitialization.\n */\n \n-extern \"C\" void M2Dependent_RequestDependant (void * modulename, void * dependantmodule)\n+extern \"C\" void M2Dependent_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname)\n {\n   CheckInitialized ();\n   if (! M2LINK_StaticInitialization)\n     {\n-      PerformRequestDependant (modulename, dependantmodule);\n+      PerformRequestDependant (modulename, libname, dependantmodule, dependantlibname);\n     }\n }\n "}, {"sha": "068bbfe3f7c24d5b24470129eba91223de2d62b7", "filename": "gcc/m2/mc-boot/GM2Dependent.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGM2Dependent.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGM2Dependent.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGM2Dependent.h?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -53,23 +53,24 @@ typedef struct M2Dependent_ArgCVEnvP_p M2Dependent_ArgCVEnvP;\n typedef void (*M2Dependent_ArgCVEnvP_t) (int, void *, void *);\n struct M2Dependent_ArgCVEnvP_p { M2Dependent_ArgCVEnvP_t proc; };\n \n-EXTERN void M2Dependent_ConstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n-EXTERN void M2Dependent_DeconstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n+EXTERN void M2Dependent_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n+EXTERN void M2Dependent_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n \n /*\n    RegisterModule - adds module name to the list of outstanding\n                     modules which need to have their dependencies\n                     explored to determine initialization order.\n */\n \n-EXTERN void M2Dependent_RegisterModule (void * name, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies);\n+EXTERN void M2Dependent_RegisterModule (void * modulename, void * libname, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies);\n \n /*\n-   RequestDependant - used to specify that modulename is dependant upon\n-                      module dependantmodule.\n+   RequestDependant - used to specify that modulename:libname\n+                      is dependant upon\n+                      module dependantmodule:dependantlibname\n */\n \n-EXTERN void M2Dependent_RequestDependant (void * modulename, void * dependantmodule);\n+EXTERN void M2Dependent_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname);\n #   ifdef __cplusplus\n }\n #   endif"}, {"sha": "a7b8865285853f2b38f79985b31c0d2a43f63753", "filename": "gcc/m2/mc-boot/GM2EXCEPTION.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGM2EXCEPTION.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGM2EXCEPTION.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGM2EXCEPTION.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -57,13 +57,13 @@ extern \"C\" M2EXCEPTION_M2Exceptions M2EXCEPTION_M2Exception (void)\n   n = RTExceptions_GetNumber (e);\n   if (n == (UINT_MAX))\n     {\n-      RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_exException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/M2EXCEPTION.mod\")), 47, 6, const_cast<void*> (reinterpret_cast<const void*>(\"M2Exception\")), const_cast<void*> (reinterpret_cast<const void*>(\"current coroutine is not in the exceptional execution state\")));\n+      RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_exException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/M2EXCEPTION.mod\")), 47, 6, const_cast<void*> (reinterpret_cast<const void*>(\"M2Exception\")), const_cast<void*> (reinterpret_cast<const void*>(\"current coroutine is not in the exceptional execution state\")));\n     }\n   else\n     {\n       return (M2EXCEPTION_M2Exceptions) (n);\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/M2EXCEPTION.def\", 25, 1);\n+  ReturnException (\"../../gcc/m2/gm2-libs/M2EXCEPTION.def\", 25, 1);\n   __builtin_unreachable ();\n }\n "}, {"sha": "2e8680ccb960e79b164e0e54fa761256ac7618c1", "filename": "gcc/m2/mc-boot/GM2RTS.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGM2RTS.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGM2RTS.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGM2RTS.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -96,29 +96,29 @@ static unsigned int Initialized;\n                       module constructor in turn.\n */\n \n-extern \"C\" void M2RTS_ConstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n+extern \"C\" void M2RTS_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n \n /*\n    DeconstructModules - resolve dependencies and then call each\n                         module constructor in turn.\n */\n \n-extern \"C\" void M2RTS_DeconstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n+extern \"C\" void M2RTS_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n \n /*\n    RegisterModule - adds module name to the list of outstanding\n                     modules which need to have their dependencies\n                     explored to determine initialization order.\n */\n \n-extern \"C\" void M2RTS_RegisterModule (void * name, M2RTS_ArgCVEnvP init, M2RTS_ArgCVEnvP fini, PROC dependencies);\n+extern \"C\" void M2RTS_RegisterModule (void * name, void * libname, M2RTS_ArgCVEnvP init, M2RTS_ArgCVEnvP fini, PROC dependencies);\n \n /*\n    RequestDependant - used to specify that modulename is dependant upon\n                       module dependantmodule.\n */\n \n-extern \"C\" void M2RTS_RequestDependant (void * modulename, void * dependantmodule);\n+extern \"C\" void M2RTS_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname);\n \n /*\n    InstallTerminationProcedure - installs a procedure, p, which will\n@@ -434,9 +434,9 @@ static void CheckInitialized (void)\n                       module constructor in turn.\n */\n \n-extern \"C\" void M2RTS_ConstructModules (void * applicationmodule, int argc, void * argv, void * envp)\n+extern \"C\" void M2RTS_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp)\n {\n-  M2Dependent_ConstructModules (applicationmodule, argc, argv, envp);\n+  M2Dependent_ConstructModules (applicationmodule, libname, argc, argv, envp);\n }\n \n \n@@ -445,9 +445,9 @@ extern \"C\" void M2RTS_ConstructModules (void * applicationmodule, int argc, void\n                         module constructor in turn.\n */\n \n-extern \"C\" void M2RTS_DeconstructModules (void * applicationmodule, int argc, void * argv, void * envp)\n+extern \"C\" void M2RTS_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp)\n {\n-  M2Dependent_DeconstructModules (applicationmodule, argc, argv, envp);\n+  M2Dependent_DeconstructModules (applicationmodule, libname, argc, argv, envp);\n }\n \n \n@@ -457,9 +457,9 @@ extern \"C\" void M2RTS_DeconstructModules (void * applicationmodule, int argc, vo\n                     explored to determine initialization order.\n */\n \n-extern \"C\" void M2RTS_RegisterModule (void * name, M2RTS_ArgCVEnvP init, M2RTS_ArgCVEnvP fini, PROC dependencies)\n+extern \"C\" void M2RTS_RegisterModule (void * name, void * libname, M2RTS_ArgCVEnvP init, M2RTS_ArgCVEnvP fini, PROC dependencies)\n {\n-  M2Dependent_RegisterModule (name, (M2Dependent_ArgCVEnvP) {(M2Dependent_ArgCVEnvP_t) init.proc}, (M2Dependent_ArgCVEnvP) {(M2Dependent_ArgCVEnvP_t) fini.proc}, dependencies);\n+  M2Dependent_RegisterModule (name, libname, (M2Dependent_ArgCVEnvP) {(M2Dependent_ArgCVEnvP_t) init.proc}, (M2Dependent_ArgCVEnvP) {(M2Dependent_ArgCVEnvP_t) fini.proc}, dependencies);\n }\n \n \n@@ -468,9 +468,9 @@ extern \"C\" void M2RTS_RegisterModule (void * name, M2RTS_ArgCVEnvP init, M2RTS_A\n                       module dependantmodule.\n */\n \n-extern \"C\" void M2RTS_RequestDependant (void * modulename, void * dependantmodule)\n+extern \"C\" void M2RTS_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname)\n {\n-  M2Dependent_RequestDependant (modulename, dependantmodule);\n+  M2Dependent_RequestDependant (modulename, libname, dependantmodule, dependantlibname);\n }\n \n "}, {"sha": "eb1025c7922c9b36d10256b08ebee11ac2531580", "filename": "gcc/m2/mc-boot/GM2RTS.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGM2RTS.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGM2RTS.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGM2RTS.h?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -53,23 +53,23 @@ typedef struct M2RTS_ArgCVEnvP_p M2RTS_ArgCVEnvP;\n typedef void (*M2RTS_ArgCVEnvP_t) (int, void *, void *);\n struct M2RTS_ArgCVEnvP_p { M2RTS_ArgCVEnvP_t proc; };\n \n-EXTERN void M2RTS_ConstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n-EXTERN void M2RTS_DeconstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n+EXTERN void M2RTS_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n+EXTERN void M2RTS_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n \n /*\n    RegisterModule - adds module name to the list of outstanding\n                     modules which need to have their dependencies\n                     explored to determine initialization order.\n */\n \n-EXTERN void M2RTS_RegisterModule (void * name, M2RTS_ArgCVEnvP init, M2RTS_ArgCVEnvP fini, PROC dependencies);\n+EXTERN void M2RTS_RegisterModule (void * name, void * libname, M2RTS_ArgCVEnvP init, M2RTS_ArgCVEnvP fini, PROC dependencies);\n \n /*\n    RequestDependant - used to specify that modulename is dependant upon\n                       module dependantmodule.\n */\n \n-EXTERN void M2RTS_RequestDependant (void * modulename, void * dependantmodule);\n+EXTERN void M2RTS_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname);\n \n /*\n    InstallTerminationProcedure - installs a procedure, p, which will"}, {"sha": "895130edb308b3126c541ecdec3d92bd4e78297e", "filename": "gcc/m2/mc-boot/GPushBackInput.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGPushBackInput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGPushBackInput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGPushBackInput.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -274,7 +274,7 @@ extern \"C\" char PushBackInput_PutCh (char ch)\n     }\n   else\n     {\n-      Debug_Halt ((const char *) \"max push back stack exceeded, increase MaxPushBackStack\", 55, 150, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/PushBackInput.mod\", 54);\n+      Debug_Halt ((const char *) \"max push back stack exceeded, increase MaxPushBackStack\", 55, 150, (const char *) \"../../gcc/m2/gm2-libs/PushBackInput.mod\", 39);\n     }\n   return ch;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -300,7 +300,7 @@ extern \"C\" void PushBackInput_PutString (const char *a_, unsigned int _a_high)\n       l -= 1;\n       if ((PushBackInput_PutCh (a[l])) != a[l])\n         {\n-          Debug_Halt ((const char *) \"assert failed\", 13, 132, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/PushBackInput.mod\", 54);\n+          Debug_Halt ((const char *) \"assert failed\", 13, 132, (const char *) \"../../gcc/m2/gm2-libs/PushBackInput.mod\", 39);\n         }\n     }\n }\n@@ -321,7 +321,7 @@ extern \"C\" void PushBackInput_PutStr (DynamicStrings_String s)\n       i -= 1;\n       if ((PushBackInput_PutCh (DynamicStrings_char (s, static_cast<int> (i)))) != (DynamicStrings_char (s, static_cast<int> (i))))\n         {\n-          Debug_Halt ((const char *) \"assert failed\", 13, 113, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/PushBackInput.mod\", 54);\n+          Debug_Halt ((const char *) \"assert failed\", 13, 113, (const char *) \"../../gcc/m2/gm2-libs/PushBackInput.mod\", 39);\n         }\n     }\n }"}, {"sha": "f78a3cb7ab8bcb46290415e6e3d3bd7b42d9e698", "filename": "gcc/m2/mc-boot/GRTExceptions.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGRTExceptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGRTExceptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGRTExceptions.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -721,7 +721,7 @@ static void AddHandler (RTExceptions_EHBlock e, RTExceptions_Handler h)\n \n static void indexf (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_indexException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 613, 9, const_cast<void*> (reinterpret_cast<const void*>(\"indexf\")), const_cast<void*> (reinterpret_cast<const void*>(\"array index out of bounds\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_indexException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 613, 9, const_cast<void*> (reinterpret_cast<const void*>(\"indexf\")), const_cast<void*> (reinterpret_cast<const void*>(\"array index out of bounds\")));\n }\n \n \n@@ -731,7 +731,7 @@ static void indexf (void * a)\n \n static void range (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 625, 9, const_cast<void*> (reinterpret_cast<const void*>(\"range\")), const_cast<void*> (reinterpret_cast<const void*>(\"assignment out of range\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 625, 9, const_cast<void*> (reinterpret_cast<const void*>(\"range\")), const_cast<void*> (reinterpret_cast<const void*>(\"assignment out of range\")));\n }\n \n \n@@ -741,7 +741,7 @@ static void range (void * a)\n \n static void casef (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_caseSelectException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 637, 9, const_cast<void*> (reinterpret_cast<const void*>(\"casef\")), const_cast<void*> (reinterpret_cast<const void*>(\"case selector out of range\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_caseSelectException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 637, 9, const_cast<void*> (reinterpret_cast<const void*>(\"casef\")), const_cast<void*> (reinterpret_cast<const void*>(\"case selector out of range\")));\n }\n \n \n@@ -751,7 +751,7 @@ static void casef (void * a)\n \n static void invalidloc (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_invalidLocation)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 649, 9, const_cast<void*> (reinterpret_cast<const void*>(\"invalidloc\")), const_cast<void*> (reinterpret_cast<const void*>(\"invalid address referenced\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_invalidLocation)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 649, 9, const_cast<void*> (reinterpret_cast<const void*>(\"invalidloc\")), const_cast<void*> (reinterpret_cast<const void*>(\"invalid address referenced\")));\n }\n \n \n@@ -761,7 +761,7 @@ static void invalidloc (void * a)\n \n static void function (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_functionException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 661, 9, const_cast<void*> (reinterpret_cast<const void*>(\"function\")), const_cast<void*> (reinterpret_cast<const void*>(\"... function ... \")));  /* --fixme-- what has happened ?  */\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_functionException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 661, 9, const_cast<void*> (reinterpret_cast<const void*>(\"function\")), const_cast<void*> (reinterpret_cast<const void*>(\"... function ... \")));  /* --fixme-- what has happened ?  */\n }\n \n \n@@ -771,7 +771,7 @@ static void function (void * a)\n \n static void wholevalue (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 673, 9, const_cast<void*> (reinterpret_cast<const void*>(\"wholevalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal whole value exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 673, 9, const_cast<void*> (reinterpret_cast<const void*>(\"wholevalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal whole value exception\")));\n }\n \n \n@@ -781,7 +781,7 @@ static void wholevalue (void * a)\n \n static void wholediv (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 685, 9, const_cast<void*> (reinterpret_cast<const void*>(\"wholediv\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal whole value exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 685, 9, const_cast<void*> (reinterpret_cast<const void*>(\"wholediv\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal whole value exception\")));\n }\n \n \n@@ -791,7 +791,7 @@ static void wholediv (void * a)\n \n static void realvalue (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_realValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 697, 9, const_cast<void*> (reinterpret_cast<const void*>(\"realvalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal real value exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_realValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 697, 9, const_cast<void*> (reinterpret_cast<const void*>(\"realvalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal real value exception\")));\n }\n \n \n@@ -801,7 +801,7 @@ static void realvalue (void * a)\n \n static void realdiv (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_realDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 709, 9, const_cast<void*> (reinterpret_cast<const void*>(\"realdiv\")), const_cast<void*> (reinterpret_cast<const void*>(\"real number division by zero exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_realDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 709, 9, const_cast<void*> (reinterpret_cast<const void*>(\"realdiv\")), const_cast<void*> (reinterpret_cast<const void*>(\"real number division by zero exception\")));\n }\n \n \n@@ -811,7 +811,7 @@ static void realdiv (void * a)\n \n static void complexvalue (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_complexValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 721, 9, const_cast<void*> (reinterpret_cast<const void*>(\"complexvalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal complex value exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_complexValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 721, 9, const_cast<void*> (reinterpret_cast<const void*>(\"complexvalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal complex value exception\")));\n }\n \n \n@@ -821,7 +821,7 @@ static void complexvalue (void * a)\n \n static void complexdiv (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_complexDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 733, 9, const_cast<void*> (reinterpret_cast<const void*>(\"complexdiv\")), const_cast<void*> (reinterpret_cast<const void*>(\"complex number division by zero exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_complexDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 733, 9, const_cast<void*> (reinterpret_cast<const void*>(\"complexdiv\")), const_cast<void*> (reinterpret_cast<const void*>(\"complex number division by zero exception\")));\n }\n \n \n@@ -831,7 +831,7 @@ static void complexdiv (void * a)\n \n static void protection (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_protException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 745, 9, const_cast<void*> (reinterpret_cast<const void*>(\"protection\")), const_cast<void*> (reinterpret_cast<const void*>(\"protection exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_protException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 745, 9, const_cast<void*> (reinterpret_cast<const void*>(\"protection\")), const_cast<void*> (reinterpret_cast<const void*>(\"protection exception\")));\n }\n \n \n@@ -841,7 +841,7 @@ static void protection (void * a)\n \n static void systemf (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_sysException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 757, 9, const_cast<void*> (reinterpret_cast<const void*>(\"systemf\")), const_cast<void*> (reinterpret_cast<const void*>(\"system exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_sysException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 757, 9, const_cast<void*> (reinterpret_cast<const void*>(\"systemf\")), const_cast<void*> (reinterpret_cast<const void*>(\"system exception\")));\n }\n \n \n@@ -851,7 +851,7 @@ static void systemf (void * a)\n \n static void coroutine (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_coException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 769, 9, const_cast<void*> (reinterpret_cast<const void*>(\"coroutine\")), const_cast<void*> (reinterpret_cast<const void*>(\"coroutine exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_coException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 769, 9, const_cast<void*> (reinterpret_cast<const void*>(\"coroutine\")), const_cast<void*> (reinterpret_cast<const void*>(\"coroutine exception\")));\n }\n \n \n@@ -861,7 +861,7 @@ static void coroutine (void * a)\n \n static void exception (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_exException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 781, 9, const_cast<void*> (reinterpret_cast<const void*>(\"exception\")), const_cast<void*> (reinterpret_cast<const void*>(\"exception exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_exException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 781, 9, const_cast<void*> (reinterpret_cast<const void*>(\"exception\")), const_cast<void*> (reinterpret_cast<const void*>(\"exception exception\")));\n }\n \n \n@@ -1180,13 +1180,13 @@ extern \"C\" RTExceptions_EHBlock RTExceptions_GetBaseExceptionBlock (void)\n {\n   if (currentEHB == NULL)\n     {\n-      M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\", 53, 599, (const char *) \"GetBaseExceptionBlock\", 21, (const char *) \"currentEHB has not been initialized yet\", 39);\n+      M2RTS_Halt ((const char *) \"../../gcc/m2/gm2-libs/RTExceptions.mod\", 38, 599, (const char *) \"GetBaseExceptionBlock\", 21, (const char *) \"currentEHB has not been initialized yet\", 39);\n     }\n   else\n     {\n       return currentEHB;\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.def\", 25, 1);\n+  ReturnException (\"../../gcc/m2/gm2-libs/RTExceptions.def\", 25, 1);\n   __builtin_unreachable ();\n }\n "}, {"sha": "65c8c8af06f245560f98686e301e45e6d0d4678b", "filename": "gcc/m2/mc-boot/GRTint.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGRTint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGRTint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGRTint.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -595,7 +595,7 @@ static unsigned int activatePending (unsigned int untilInterrupt, RTint_Dispatch\n \n \n               default:\n-                CaseException (\"../../gcc-read-write/gcc/m2/gm2-libs/RTint.def\", 25, 1);\n+                CaseException (\"../../gcc/m2/gm2-libs/RTint.def\", 25, 1);\n                 __builtin_unreachable ();\n             }\n           v = v->pending;\n@@ -708,7 +708,7 @@ extern \"C\" unsigned int RTint_InitOutputVector (int fd, unsigned int pri)\n       RTco_signal (lock);\n       return v->no;\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/RTint.def\", 25, 1);\n+  ReturnException (\"../../gcc/m2/gm2-libs/RTint.def\", 25, 1);\n   __builtin_unreachable ();\n }\n \n@@ -765,7 +765,7 @@ extern \"C\" void RTint_ReArmTimeVector (unsigned int vec, unsigned int micro, uns\n   v = FindVectorNo (vec);\n   if (v == NULL)\n     {\n-      M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 286, (const char *) \"ReArmTimeVector\", 15, (const char *) \"cannot find vector supplied\", 27);\n+      M2RTS_Halt ((const char *) \"../../gcc/m2/gm2-libs/RTint.mod\", 31, 286, (const char *) \"ReArmTimeVector\", 15, (const char *) \"cannot find vector supplied\", 27);\n     }\n   else\n     {\n@@ -790,7 +790,7 @@ extern \"C\" void RTint_GetTimeVector (unsigned int vec, unsigned int *micro, unsi\n   v = FindVectorNo (vec);\n   if (v == NULL)\n     {\n-      M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 312, (const char *) \"GetTimeVector\", 13, (const char *) \"cannot find vector supplied\", 27);\n+      M2RTS_Halt ((const char *) \"../../gcc/m2/gm2-libs/RTint.mod\", 31, 312, (const char *) \"GetTimeVector\", 13, (const char *) \"cannot find vector supplied\", 27);\n     }\n   else\n     {\n@@ -816,7 +816,7 @@ extern \"C\" void * RTint_AttachVector (unsigned int vec, void * p)\n   v = FindVectorNo (vec);\n   if (v == NULL)\n     {\n-      M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 339, (const char *) \"AttachVector\", 12, (const char *) \"cannot find vector supplied\", 27);\n+      M2RTS_Halt ((const char *) \"../../gcc/m2/gm2-libs/RTint.mod\", 31, 339, (const char *) \"AttachVector\", 12, (const char *) \"cannot find vector supplied\", 27);\n     }\n   else\n     {\n@@ -830,7 +830,7 @@ extern \"C\" void * RTint_AttachVector (unsigned int vec, void * p)\n       RTco_signal (lock);\n       return l;\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/RTint.def\", 25, 1);\n+  ReturnException (\"../../gcc/m2/gm2-libs/RTint.def\", 25, 1);\n   __builtin_unreachable ();\n }\n \n@@ -855,7 +855,7 @@ extern \"C\" void RTint_IncludeVector (unsigned int vec)\n       v = FindVectorNo (vec);\n       if (v == NULL)\n         {\n-          M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 372, (const char *) \"IncludeVector\", 13, (const char *) \"cannot find vector supplied\", 27);\n+          M2RTS_Halt ((const char *) \"../../gcc/m2/gm2-libs/RTint.mod\", 31, 372, (const char *) \"IncludeVector\", 13, (const char *) \"cannot find vector supplied\", 27);\n         }\n       else\n         {\n@@ -902,7 +902,7 @@ extern \"C\" void RTint_ExcludeVector (unsigned int vec)\n   v = FindPendingVector (vec);\n   if (v == NULL)\n     {\n-      M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 415, (const char *) \"ExcludeVector\", 13, (const char *) \"cannot find pending vector supplied\", 35);\n+      M2RTS_Halt ((const char *) \"../../gcc/m2/gm2-libs/RTint.mod\", 31, 415, (const char *) \"ExcludeVector\", 13, (const char *) \"cannot find pending vector supplied\", 35);\n     }\n   else\n     {\n@@ -1003,7 +1003,7 @@ extern \"C\" void RTint_Listen (unsigned int untilInterrupt, RTint_DispatchVector\n \n \n                   default:\n-                    CaseException (\"../../gcc-read-write/gcc/m2/gm2-libs/RTint.def\", 25, 1);\n+                    CaseException (\"../../gcc/m2/gm2-libs/RTint.def\", 25, 1);\n                     __builtin_unreachable ();\n                 }\n               v = v->pending;\n@@ -1016,7 +1016,7 @@ extern \"C\" void RTint_Listen (unsigned int untilInterrupt, RTint_DispatchVector\n         }\n       if (((untilInterrupt && (i == NULL)) && (o == NULL)) && ! found)\n         {\n-          M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 731, (const char *) \"Listen\", 6, (const char *) \"deadlock found, no more processes to run and no interrupts active\", 65);\n+          M2RTS_Halt ((const char *) \"../../gcc/m2/gm2-libs/RTint.mod\", 31, 731, (const char *) \"Listen\", 6, (const char *) \"deadlock found, no more processes to run and no interrupts active\", 65);\n         }\n       /* printf('}\n       ') ;  */"}, {"sha": "e5cc572be9e7c7bc36491f56cd72e92e9bcf9af6", "filename": "gcc/m2/mc-boot/GStdIO.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGStdIO.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGStdIO.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGStdIO.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -193,7 +193,7 @@ extern \"C\" StdIO_ProcWrite StdIO_GetCurrentOutput (void)\n       M2RTS_HALT (-1);\n       __builtin_unreachable ();\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/StdIO.def\", 25, 1);\n+  ReturnException (\"../../gcc/m2/gm2-libs/StdIO.def\", 25, 1);\n   __builtin_unreachable ();\n }\n \n@@ -252,7 +252,7 @@ extern \"C\" StdIO_ProcRead StdIO_GetCurrentInput (void)\n       M2RTS_HALT (-1);\n       __builtin_unreachable ();\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/StdIO.def\", 25, 1);\n+  ReturnException (\"../../gcc/m2/gm2-libs/StdIO.def\", 25, 1);\n   __builtin_unreachable ();\n }\n "}, {"sha": "8858afc7a1ce9959a00bf09846b10765ad959c3d", "filename": "gcc/m2/mc-boot/GStringConvert.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGStringConvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGStringConvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGStringConvert.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -1916,7 +1916,7 @@ extern \"C\" DynamicStrings_String StringConvert_ToSigFig (DynamicStrings_String s\n   int point;\n   unsigned int poTen;\n \n-  Assert ((IsDigit (DynamicStrings_char (s, 0))) || ((DynamicStrings_char (s, 0)) == '.'), (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/StringConvert.mod\", 54, 1222, (const char *) \"ToSigFig\", 8);\n+  Assert ((IsDigit (DynamicStrings_char (s, 0))) || ((DynamicStrings_char (s, 0)) == '.'), (const char *) \"../../gcc/m2/gm2-libs/StringConvert.mod\", 39, 1222, (const char *) \"ToSigFig\", 8);\n   point = DynamicStrings_Index (s, '.', 0);\n   if (point < 0)\n     {\n@@ -1968,7 +1968,7 @@ extern \"C\" DynamicStrings_String StringConvert_ToDecimalPlaces (DynamicStrings_S\n {\n   int point;\n \n-  Assert ((IsDigit (DynamicStrings_char (s, 0))) || ((DynamicStrings_char (s, 0)) == '.'), (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/StringConvert.mod\", 54, 1069, (const char *) \"ToDecimalPlaces\", 15);\n+  Assert ((IsDigit (DynamicStrings_char (s, 0))) || ((DynamicStrings_char (s, 0)) == '.'), (const char *) \"../../gcc/m2/gm2-libs/StringConvert.mod\", 39, 1069, (const char *) \"ToDecimalPlaces\", 15);\n   point = DynamicStrings_Index (s, '.', 0);\n   if (point < 0)\n     {"}, {"sha": "3d37ecf95180a102ffb1b91ac51d9403473c0278", "filename": "gcc/m2/mc-boot/GSysStorage.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGSysStorage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGSysStorage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGSysStorage.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -93,7 +93,7 @@ extern \"C\" void SysStorage_ALLOCATE (void * *a, unsigned int size)\n   (*a) = libc_malloc (static_cast<size_t> (size));\n   if ((*a) == NULL)\n     {\n-      Debug_Halt ((const char *) \"out of memory error\", 19, 50, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/SysStorage.mod\", 51);\n+      Debug_Halt ((const char *) \"out of memory error\", 19, 50, (const char *) \"../../gcc/m2/gm2-libs/SysStorage.mod\", 36);\n     }\n   if (enableTrace && trace)\n     {\n@@ -118,7 +118,7 @@ extern \"C\" void SysStorage_DEALLOCATE (void * *a, unsigned int size)\n         }\n       if ((libc_memset ((*a), 0, static_cast<size_t> (size))) != (*a))\n         {\n-          Debug_Halt ((const char *) \"memset should have returned the first parameter\", 47, 76, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/SysStorage.mod\", 51);\n+          Debug_Halt ((const char *) \"memset should have returned the first parameter\", 47, 76, (const char *) \"../../gcc/m2/gm2-libs/SysStorage.mod\", 36);\n         }\n     }\n   if (enableDeallocation)\n@@ -163,7 +163,7 @@ extern \"C\" void SysStorage_REALLOCATE (void * *a, unsigned int size)\n       (*a) = libc_realloc ((*a), static_cast<size_t> (size));\n       if ((*a) == NULL)\n         {\n-          Debug_Halt ((const char *) \"out of memory error\", 19, 119, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/SysStorage.mod\", 51);\n+          Debug_Halt ((const char *) \"out of memory error\", 19, 119, (const char *) \"../../gcc/m2/gm2-libs/SysStorage.mod\", 36);\n         }\n       if (enableTrace && trace)\n         {"}, {"sha": "08eba89167a466c8478e997814e900f88393be72", "filename": "gcc/m2/mc-boot/Gdecl.c", "status": "modified", "additions": 71, "deletions": 70, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGdecl.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -1027,10 +1027,10 @@ extern \"C\" void SYSTEM_ShiftRight (unsigned int *s, unsigned int _s_high, unsign\n extern \"C\" void SYSTEM_RotateVal (unsigned int *s, unsigned int _s_high, unsigned int *d, unsigned int _d_high, unsigned int SetSizeInBits, int RotateCount);\n extern \"C\" void SYSTEM_RotateLeft (unsigned int *s, unsigned int _s_high, unsigned int *d, unsigned int _d_high, unsigned int SetSizeInBits, unsigned int RotateCount);\n extern \"C\" void SYSTEM_RotateRight (unsigned int *s, unsigned int _s_high, unsigned int *d, unsigned int _d_high, unsigned int SetSizeInBits, unsigned int RotateCount);\n-extern \"C\" void M2RTS_ConstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n-extern \"C\" void M2RTS_DeconstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n-extern \"C\" void M2RTS_RegisterModule (void * name, M2RTS_ArgCVEnvP init, M2RTS_ArgCVEnvP fini, PROC dependencies);\n-extern \"C\" void M2RTS_RequestDependant (void * modulename, void * dependantmodule);\n+extern \"C\" void M2RTS_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n+extern \"C\" void M2RTS_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n+extern \"C\" void M2RTS_RegisterModule (void * name, void * libname, M2RTS_ArgCVEnvP init, M2RTS_ArgCVEnvP fini, PROC dependencies);\n+extern \"C\" void M2RTS_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname);\n extern \"C\" unsigned int M2RTS_InstallTerminationProcedure (PROC p);\n extern \"C\" void M2RTS_ExecuteInitialProcedures (void);\n extern \"C\" unsigned int M2RTS_InstallInitialProcedure (PROC p);\n@@ -2782,6 +2782,7 @@ extern \"C\" void * libc_memcpy (void * dest, void * src, size_t size);\n extern \"C\" void * libc_memset (void * s, int c, size_t size);\n extern \"C\" void * libc_memmove (void * dest, void * src, size_t size);\n extern \"C\" int libc_printf (const char *format_, unsigned int _format_high, ...);\n+extern \"C\" int libc_snprintf (void * dest, size_t size, const char *format_, unsigned int _format_high, ...);\n extern \"C\" int libc_setenv (void * name, void * value, int overwrite);\n extern \"C\" void libc_srand (int seed);\n extern \"C\" int libc_rand (void);\n@@ -6679,7 +6680,7 @@ static decl_node newNode (decl_nodeT k)\n       d->at.firstUsed = 0;\n       return d;\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -7039,7 +7040,7 @@ static decl_node addToScope (decl_node n)\n     }\n   M2RTS_HALT (-1);\n   __builtin_unreachable ();\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -7117,7 +7118,7 @@ static void setUnary (decl_node u, decl_nodeT k, decl_node a, decl_node t)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -7400,7 +7401,7 @@ static void putFieldVarient (decl_node f, decl_node v)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   switch (f->kind)\n@@ -7411,7 +7412,7 @@ static void putFieldVarient (decl_node f, decl_node v)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -7462,7 +7463,7 @@ static decl_node putFieldRecord (decl_node r, nameKey_Name tag, decl_node type,\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   /* fill in, n.  */\n@@ -7520,7 +7521,7 @@ static void putVarientTag (decl_node v, decl_node tag)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -7544,7 +7545,7 @@ static decl_node getParent (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -7572,7 +7573,7 @@ static decl_node getRecord (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -7752,7 +7753,7 @@ static unsigned int getConstExpComplete (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -7857,7 +7858,7 @@ static decl_node makeVal (decl_node params)\n       M2RTS_HALT (-1);\n       __builtin_unreachable ();\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -7878,7 +7879,7 @@ static decl_node makeCast (decl_node c, decl_node p)\n       M2RTS_HALT (-1);\n       __builtin_unreachable ();\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -8388,7 +8389,7 @@ static decl_node makeUnary (decl_nodeT k, decl_node e, decl_node res)\n \n \n           default:\n-            CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+            CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n             __builtin_unreachable ();\n         }\n     }\n@@ -8482,7 +8483,7 @@ static DynamicStrings_String getStringContents (decl_node n)\n     }\n   M2RTS_HALT (-1);\n   __builtin_unreachable ();\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -8618,7 +8619,7 @@ static decl_node doMakeBinary (decl_nodeT k, decl_node l, decl_node r, decl_node\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   return n;\n@@ -9218,12 +9219,12 @@ static decl_node doGetExprType (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   M2RTS_HALT (-1);\n   __builtin_unreachable ();\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -9362,12 +9363,12 @@ static decl_node getSymScope (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   M2RTS_HALT (-1);\n   __builtin_unreachable ();\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -9679,7 +9680,7 @@ static unsigned int needsParen (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   return TRUE;\n@@ -9788,7 +9789,7 @@ static void doPolyBinary (mcPretty_pretty p, decl_nodeT op, decl_node left, decl\n \n \n           default:\n-            CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+            CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n             __builtin_unreachable ();\n         }\n     }\n@@ -9814,7 +9815,7 @@ static void doPolyBinary (mcPretty_pretty p, decl_nodeT op, decl_node left, decl\n \n \n           default:\n-            CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+            CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n             __builtin_unreachable ();\n         }\n     }\n@@ -10092,7 +10093,7 @@ static decl_node doGetLastOp (decl_node a, decl_node b)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -10732,7 +10733,7 @@ static void doExprC (mcPretty_pretty p, decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -10937,7 +10938,7 @@ static void doExprM2 (mcPretty_pretty p, decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -11109,7 +11110,7 @@ static DynamicStrings_String replaceChar (DynamicStrings_String s, char ch, cons\n         return s;\n       }\n   }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -11169,7 +11170,7 @@ static unsigned int countChar (DynamicStrings_String s, char ch)\n         return c;\n       }\n   }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -12228,7 +12229,7 @@ static decl_node doMin (decl_node n)\n       M2RTS_HALT (-1);  /* finish the cacading elsif statement.  */\n       __builtin_unreachable ();\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -12309,7 +12310,7 @@ static decl_node doMax (decl_node n)\n       M2RTS_HALT (-1);  /* finish the cacading elsif statement.  */\n       __builtin_unreachable ();\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -12598,7 +12599,7 @@ static void doBaseC (mcPretty_pretty p, decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   mcPretty_setNeedSpace (p);\n@@ -12688,7 +12689,7 @@ static void doSystemC (mcPretty_pretty p, decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -16042,7 +16043,7 @@ static void doCreal (mcPretty_pretty p, decl_node t)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -16073,7 +16074,7 @@ static void doCimag (mcPretty_pretty p, decl_node t)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -16204,7 +16205,7 @@ static void doIntrinsicC (mcPretty_pretty p, decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   outText (p, (const char *) \";\", 1);\n@@ -17366,7 +17367,7 @@ static void dbs (decl_dependentState s, decl_node n)\n \n \n           default:\n-            CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+            CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n             __builtin_unreachable ();\n         }\n       if (n != NULL)\n@@ -18259,10 +18260,10 @@ static decl_dependentState doDependants (alists_alist l, decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -18359,7 +18360,7 @@ static void visitIntrinsicFunction (alists_alist v, decl_node n, decl_nodeProced\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -19358,7 +19359,7 @@ static void visitDependants (alists_alist v, decl_node n, decl_nodeProcedure p)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -19705,12 +19706,12 @@ static DynamicStrings_String genKind (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   M2RTS_HALT (-1);\n   __builtin_unreachable ();\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -20885,7 +20886,7 @@ static void doBaseM2 (mcPretty_pretty p, decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   mcPretty_setNeedSpace (p);\n@@ -20911,7 +20912,7 @@ static void doSystemM2 (mcPretty_pretty p, decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -22122,10 +22123,10 @@ static decl_node doDupExpr (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -22455,7 +22456,7 @@ extern \"C\" unsigned int decl_isVisited (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -22485,7 +22486,7 @@ extern \"C\" void decl_unsetVisited (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -22513,7 +22514,7 @@ extern \"C\" void decl_setVisited (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -22541,7 +22542,7 @@ extern \"C\" void decl_setEnumsComplete (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -22569,7 +22570,7 @@ extern \"C\" unsigned int decl_getEnumsComplete (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -22790,7 +22791,7 @@ extern \"C\" decl_node decl_lookupInScope (decl_node scope, nameKey_Name n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -23165,12 +23166,12 @@ extern \"C\" decl_node decl_getType (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   M2RTS_HALT (-1);\n   __builtin_unreachable ();\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -23564,7 +23565,7 @@ extern \"C\" decl_node decl_getScope (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -24219,7 +24220,7 @@ extern \"C\" decl_node decl_makeVarient (decl_node r)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   return n;\n@@ -24686,7 +24687,7 @@ extern \"C\" nameKey_Name decl_getSymName (decl_node n)\n         __builtin_unreachable ();\n         break;\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -24724,7 +24725,7 @@ extern \"C\" decl_node decl_import (decl_node m, decl_node n)\n \n \n           default:\n-            CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+            CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n             __builtin_unreachable ();\n         }\n       importEnumFields (m, n);\n@@ -24853,7 +24854,7 @@ extern \"C\" void decl_setSource (decl_node n, nameKey_Name s)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -24881,7 +24882,7 @@ extern \"C\" nameKey_Name decl_getSource (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -25324,7 +25325,7 @@ extern \"C\" void decl_addParameter (decl_node proc, decl_node param)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -25417,7 +25418,7 @@ extern \"C\" decl_node decl_makeBinaryTok (mcReserved_toktype op, decl_node l, dec\n       M2RTS_HALT (-1);  /* most likely op needs a clause as above.  */\n       __builtin_unreachable ();\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -25449,7 +25450,7 @@ extern \"C\" decl_node decl_makeUnaryTok (mcReserved_toktype op, decl_node e)\n       M2RTS_HALT (-1);  /* most likely op needs a clause as above.  */\n       __builtin_unreachable ();\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -25887,7 +25888,7 @@ extern \"C\" void decl_setConstExpComplete (decl_node n)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -26252,7 +26253,7 @@ extern \"C\" void decl_putBegin (decl_node b, decl_node s)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -26279,7 +26280,7 @@ extern \"C\" void decl_putFinally (decl_node b, decl_node s)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n }\n@@ -26907,7 +26908,7 @@ extern \"C\" void decl_out (void)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/decl.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/decl.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   closeOutput ();"}, {"sha": "4adcf300abb3c4703015fcd8abb820eb98d5c252", "filename": "gcc/m2/mc-boot/Gkeyc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGkeyc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGkeyc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGkeyc.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -908,7 +908,7 @@ static unsigned int mangleN (nameKey_Name n, DynamicStrings_String *m, unsigned\n         return TRUE;\n       }\n   }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/keyc.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/keyc.def\", 20, 1);\n   __builtin_unreachable ();\n }\n "}, {"sha": "8c6cfd83a54fac47b0b158d942359f16381b5219", "filename": "gcc/m2/mc-boot/Glibc.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGlibc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGlibc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGlibc.h?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -305,6 +305,7 @@ EXTERN void * libc_memset (void * s, int c, size_t size);\n \n EXTERN void * libc_memmove (void * dest, void * src, size_t size);\n EXTERN int libc_printf (const char *format_, unsigned int _format_high, ...);\n+EXTERN int libc_snprintf (void * dest, size_t size, const char *format_, unsigned int _format_high, ...);\n \n /*\n    setenv - sets environment variable, name, to value."}, {"sha": "c14beb177141b841490d85d023113b32ca326690", "filename": "gcc/m2/mc-boot/GmcComment.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGmcComment.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGmcComment.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcComment.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -257,7 +257,7 @@ static void dumpComment (mcComment_commentDesc cd)\n \n \n       default:\n-        CaseException (\"../../gcc-read-write/gcc/m2/mc/mcComment.def\", 20, 1);\n+        CaseException (\"../../gcc/m2/mc/mcComment.def\", 20, 1);\n         __builtin_unreachable ();\n     }\n   if (cd->used)"}, {"sha": "9362f90f5a3f8be0861880fe9e432d1f27b2ee3a", "filename": "gcc/m2/mc-boot/GmcComp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGmcComp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGmcComp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcComp.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -294,7 +294,7 @@ static decl_node examineCompilationUnit (void)\n     }\n   mcflex_mcError (DynamicStrings_string (DynamicStrings_InitString ((const char *) \"failed to find module name\", 26)));\n   libc_exit (1);\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/mcComp.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/mcComp.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -324,7 +324,7 @@ static decl_node peepInto (DynamicStrings_String s)\n       mcPrintf_fprintf1 (FIO_StdErr, (const char *) \"failed to open %s\\\\n\", 19, (const unsigned char *) &s, (sizeof (s)-1));\n       libc_exit (1);\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/mcComp.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/mcComp.def\", 20, 1);\n   __builtin_unreachable ();\n }\n "}, {"sha": "26d8efd8d38986644c996f06bb25eb67a709f090", "filename": "gcc/m2/mc-boot/GmcDebug.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGmcDebug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGmcDebug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcDebug.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -54,7 +54,7 @@ extern \"C\" void mcDebug_assert (unsigned int q)\n {\n   if (! q)\n     {\n-      mcError_internalError ((const char *) \"assert failed\", 13, (const char *) \"../../gcc-read-write/gcc/m2/mc/mcDebug.mod\", 42, 35);\n+      mcError_internalError ((const char *) \"assert failed\", 13, (const char *) \"../../gcc/m2/mc/mcDebug.mod\", 27, 35);\n     }\n }\n "}, {"sha": "e56cad7868bd5a8ea977cbee8b51b1a5bda2496e", "filename": "gcc/m2/mc-boot/GmcMetaError.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGmcMetaError.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGmcMetaError.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcMetaError.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -408,7 +408,7 @@ static void internalFormat (DynamicStrings_String s, int i, const char *m_, unsi\n   s = DynamicStrings_ConCatChar (s, '^');\n   s = SFIO_WriteS (FIO_StdOut, s);\n   FIO_WriteLine (FIO_StdOut);\n-  mcError_internalError ((const char *) m, _m_high, (const char *) \"../../gcc-read-write/gcc/m2/mc/mcMetaError.mod\", 46, 97);\n+  mcError_internalError ((const char *) m, _m_high, (const char *) \"../../gcc/m2/mc/mcMetaError.mod\", 31, 97);\n }\n \n \n@@ -420,7 +420,7 @@ static DynamicStrings_String x (DynamicStrings_String a, DynamicStrings_String b\n {\n   if (a != b)\n     {\n-      mcError_internalError ((const char *) \"different string returned\", 25, (const char *) \"../../gcc-read-write/gcc/m2/mc/mcMetaError.mod\", 46, 109);\n+      mcError_internalError ((const char *) \"different string returned\", 25, (const char *) \"../../gcc/m2/mc/mcMetaError.mod\", 31, 109);\n     }\n   return a;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -734,7 +734,7 @@ static mcError_error doError (mcError_error e, mcMetaError_errorType t, unsigned\n       case mcMetaError_chained:\n         if (e == NULL)\n           {\n-            mcError_internalError ((const char *) \"should not be chaining an error onto an empty error note\", 56, (const char *) \"../../gcc-read-write/gcc/m2/mc/mcMetaError.mod\", 46, 355);\n+            mcError_internalError ((const char *) \"should not be chaining an error onto an empty error note\", 56, (const char *) \"../../gcc/m2/mc/mcMetaError.mod\", 31, 355);\n           }\n         else\n           {\n@@ -758,7 +758,7 @@ static mcError_error doError (mcError_error e, mcMetaError_errorType t, unsigned\n \n \n       default:\n-        mcError_internalError ((const char *) \"unexpected enumeration value\", 28, (const char *) \"../../gcc-read-write/gcc/m2/mc/mcMetaError.mod\", 46, 369);\n+        mcError_internalError ((const char *) \"unexpected enumeration value\", 28, (const char *) \"../../gcc/m2/mc/mcMetaError.mod\", 31, 369);\n         break;\n     }\n   return e;"}, {"sha": "146c79d61c0893dbce614d7f41425c2f280bca51", "filename": "gcc/m2/mc-boot/GmcStack.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGmcStack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGmcStack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcStack.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -165,7 +165,7 @@ extern \"C\" void * mcStack_pop (mcStack_stack s)\n       Indexing_DeleteIndice (s->list, Indexing_HighIndice (s->list));\n       return a;\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/mcStack.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/mcStack.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -215,7 +215,7 @@ extern \"C\" void * mcStack_access (mcStack_stack s, unsigned int i)\n     {\n       return Indexing_GetIndice (s->list, i);\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/mcStack.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/mcStack.def\", 20, 1);\n   __builtin_unreachable ();\n }\n "}, {"sha": "7bb1e8fe76f9028b7bc16e36b5d7efeea034657c", "filename": "gcc/m2/mc-boot/GnameKey.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGnameKey.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGnameKey.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGnameKey.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -323,7 +323,7 @@ extern \"C\" nameKey_Name nameKey_makeKey (const char *a_, unsigned int _a_high)\n       (*p) = ASCII_nul;\n       return doMakeKey (n, higha);\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/nameKey.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/nameKey.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -373,7 +373,7 @@ extern \"C\" nameKey_Name nameKey_makekey (void * a)\n           return doMakeKey (n, higha);\n         }\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/mc/nameKey.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/mc/nameKey.def\", 20, 1);\n   __builtin_unreachable ();\n }\n "}, {"sha": "7619d7d55e08f8b4759e5a41efdb8f311652538b", "filename": "gcc/m2/mc-boot/Gpth.h", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461d3c84a0e5ad045ee54631901cc953d6befa20/gcc%2Fm2%2Fmc-boot%2FGpth.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461d3c84a0e5ad045ee54631901cc953d6befa20/gcc%2Fm2%2Fmc-boot%2FGpth.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGpth.h?ref=461d3c84a0e5ad045ee54631901cc953d6befa20", "patch": "@@ -1,43 +0,0 @@\n-\n-\n-#if !defined (_pth_H)\n-#   define _pth_H\n-\n-#   ifdef __cplusplus\n-extern \"C\" {\n-#   endif\n-#   if !defined (PROC_D)\n-#      define PROC_D\n-       typedef void (*PROC_t) (void);\n-       typedef struct { PROC_t proc; } PROC;\n-#   endif\n-\n-#   include \"GSYSTEM.h\"\n-\n-#   if defined (_pth_C)\n-#      define EXTERN\n-#   else\n-#      define EXTERN extern\n-#   endif\n-\n-typedef struct pth_proc_p pth_proc;\n-\n-typedef unsigned int pth_size_t;\n-\n-typedef void *pth_pth_uctx_t;\n-\n-typedef void (*pth_proc_t) (void *);\n-struct pth_proc_p { pth_proc_t proc; };\n-\n-EXTERN int pth_pth_select (int p1, void * p2, void * p3, void * p4, void * p5);\n-EXTERN int pth_pth_uctx_create (void * p);\n-EXTERN int pth_pth_uctx_make (pth_pth_uctx_t p1, void * p2, pth_size_t p3, void * p4, pth_proc p5, void * p6, pth_pth_uctx_t p7);\n-EXTERN int pth_pth_uctx_save (pth_pth_uctx_t p1);\n-EXTERN int pth_pth_uctx_switch (pth_pth_uctx_t p1, pth_pth_uctx_t p2);\n-EXTERN int pth_pth_init (void);\n-#   ifdef __cplusplus\n-}\n-#   endif\n-\n-#   undef EXTERN\n-#endif"}, {"sha": "c993097dff000d534c9633e777f56dad23a2a515", "filename": "gcc/m2/mc-boot/GsymbolKey.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGsymbolKey.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fmc-boot%2FGsymbolKey.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGsymbolKey.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -142,7 +142,7 @@ static void findNodeAndParentInTree (symbolKey_symbolTree t, nameKey_Name n, sym\n   (*father) = t;\n   if (t == NULL)\n     {\n-      Debug_Halt ((const char *) \"parameter t should never be NIL\", 31, 203, (const char *) \"../../gcc-read-write/gcc/m2/mc/symbolKey.mod\", 44);\n+      Debug_Halt ((const char *) \"parameter t should never be NIL\", 31, 203, (const char *) \"../../gcc/m2/mc/symbolKey.mod\", 29);\n     }\n   (*child) = t->left;\n   if ((*child) != NULL)\n@@ -285,7 +285,7 @@ extern \"C\" void symbolKey_putSymKey (symbolKey_symbolTree t, nameKey_Name name,\n     }\n   else\n     {\n-      Debug_Halt ((const char *) \"symbol already stored\", 21, 119, (const char *) \"../../gcc-read-write/gcc/m2/mc/symbolKey.mod\", 44);\n+      Debug_Halt ((const char *) \"symbol already stored\", 21, 119, (const char *) \"../../gcc/m2/mc/symbolKey.mod\", 29);\n     }\n }\n \n@@ -352,7 +352,7 @@ extern \"C\" void symbolKey_delSymKey (symbolKey_symbolTree t, nameKey_Name name)\n     }\n   else\n     {\n-      Debug_Halt ((const char *) \"trying to delete a symbol that is not in the tree - the compiler never expects this to occur\", 92, 186, (const char *) \"../../gcc-read-write/gcc/m2/mc/symbolKey.mod\", 44);\n+      Debug_Halt ((const char *) \"trying to delete a symbol that is not in the tree - the compiler never expects this to occur\", 92, 186, (const char *) \"../../gcc/m2/mc/symbolKey.mod\", 29);\n     }\n }\n "}, {"sha": "077cdffb61363729ef991547c61b8b35440a0b62", "filename": "gcc/m2/pge-boot/GASCII.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGASCII.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGASCII.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGASCII.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -79,6 +79,6 @@ extern \"C\" void _M2_ASCII_init (__attribute__((unused)) int argc,__attribute__((\n {\n }\n \n-extern \"C\" void _M2_ASCII_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_ASCII_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "819a46f2806228f53762f413f4bc2bccf27e5bbc", "filename": "gcc/m2/pge-boot/GArgs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGArgs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGArgs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGArgs.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -113,6 +113,6 @@ extern \"C\" void _M2_Args_init (__attribute__((unused)) int argc,__attribute__((u\n {\n }\n \n-extern \"C\" void _M2_Args_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_Args_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "5088db4068da248b9acf2a84deaa44f1dc17c07b", "filename": "gcc/m2/pge-boot/GAssertion.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGAssertion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGAssertion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGAssertion.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -64,6 +64,6 @@ extern \"C\" void _M2_Assertion_init (__attribute__((unused)) int argc,__attribute\n {\n }\n \n-extern \"C\" void _M2_Assertion_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_Assertion_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "431068492ee4a6b41b5b7d1cd6b9887b8cfd651b", "filename": "gcc/m2/pge-boot/GDebug.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGDebug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGDebug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGDebug.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -163,6 +163,6 @@ extern \"C\" void _M2_Debug_init (__attribute__((unused)) int argc,__attribute__((\n {\n }\n \n-extern \"C\" void _M2_Debug_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_Debug_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "ed917cfae2e275e0121d29478e8dca4a29e39695", "filename": "gcc/m2/pge-boot/GDynamicStrings.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGDynamicStrings.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGDynamicStrings.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGDynamicStrings.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -1217,7 +1217,7 @@ static void ConcatContents (DynamicStrings_Contents *c, const char *a_, unsigned\n       (*c).next->contents.next = NULL;\n       ConcatContents (&(*c).next->contents, (const char *) a, _a_high, h, o);\n       AddDebugInfo ((*c).next);\n-      (*c).next = AssignDebug ((*c).next, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 722, (const char *) \"ConcatContents\", 14);\n+      (*c).next = AssignDebug ((*c).next, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 722, (const char *) \"ConcatContents\", 14);\n     }\n   else\n     {\n@@ -1315,7 +1315,7 @@ static void ConcatContentsAddress (DynamicStrings_Contents *c, void * a, unsigne\n       AddDebugInfo ((*c).next);\n       if (TraceOn)\n         {\n-          (*c).next = AssignDebug ((*c).next, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 917, (const char *) \"ConcatContentsAddress\", 21);\n+          (*c).next = AssignDebug ((*c).next, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 917, (const char *) \"ConcatContentsAddress\", 21);\n         }\n     }\n   else\n@@ -1540,7 +1540,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_InitString (const char *a_, unsi\n   AddDebugInfo (s);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 758, (const char *) \"InitString\", 10);\n+      s = AssignDebug (s, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 758, (const char *) \"InitString\", 10);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -1643,7 +1643,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_InitStringCharStar (void * a)\n   AddDebugInfo (s);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 957, (const char *) \"InitStringCharStar\", 18);\n+      s = AssignDebug (s, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 957, (const char *) \"InitStringCharStar\", 18);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -1668,7 +1668,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_InitStringChar (char ch)\n   s = DynamicStrings_InitString ((const char *) &a.array[0], 1);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 977, (const char *) \"InitStringChar\", 14);\n+      s = AssignDebug (s, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 977, (const char *) \"InitStringChar\", 14);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -1826,7 +1826,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_Dup (DynamicStrings_String s)\n   s = DynamicStrings_Assign (DynamicStrings_InitString ((const char *) \"\", 0), s);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1173, (const char *) \"Dup\", 3);\n+      s = AssignDebug (s, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1173, (const char *) \"Dup\", 3);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -1848,7 +1848,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_Add (DynamicStrings_String a, Dy\n   a = DynamicStrings_ConCat (DynamicStrings_ConCat (DynamicStrings_InitString ((const char *) \"\", 0), a), b);\n   if (TraceOn)\n     {\n-      a = AssignDebug (a, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1193, (const char *) \"Add\", 3);\n+      a = AssignDebug (a, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1193, (const char *) \"Add\", 3);\n     }\n   return a;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -1913,7 +1913,7 @@ extern \"C\" unsigned int DynamicStrings_EqualCharStar (DynamicStrings_String s, v\n   t = DynamicStrings_InitStringCharStar (a);\n   if (TraceOn)\n     {\n-      t = AssignDebug (t, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1250, (const char *) \"EqualCharStar\", 13);\n+      t = AssignDebug (t, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1250, (const char *) \"EqualCharStar\", 13);\n     }\n   t = AddToGarbage (t, s);\n   if (DynamicStrings_Equal (t, s))\n@@ -1951,7 +1951,7 @@ extern \"C\" unsigned int DynamicStrings_EqualArray (DynamicStrings_String s, cons\n   t = DynamicStrings_InitString ((const char *) a, _a_high);\n   if (TraceOn)\n     {\n-      t = AssignDebug (t, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1280, (const char *) \"EqualArray\", 10);\n+      t = AssignDebug (t, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1280, (const char *) \"EqualArray\", 10);\n     }\n   t = AddToGarbage (t, s);\n   if (DynamicStrings_Equal (t, s))\n@@ -1989,7 +1989,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_Mult (DynamicStrings_String s, u\n     }\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1312, (const char *) \"Mult\", 4);\n+      s = AssignDebug (s, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1312, (const char *) \"Mult\", 4);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -2068,7 +2068,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_Slice (DynamicStrings_String s,\n                       AddDebugInfo (t->contents.next);\n                       if (TraceOn)\n                         {\n-                          t->contents.next = AssignDebug (t->contents.next, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1380, (const char *) \"Slice\", 5);\n+                          t->contents.next = AssignDebug (t->contents.next, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1380, (const char *) \"Slice\", 5);\n                         }\n                     }\n                   t = t->contents.next;\n@@ -2086,7 +2086,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_Slice (DynamicStrings_String s,\n     }\n   if (TraceOn)\n     {\n-      d = AssignDebug (d, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1397, (const char *) \"Slice\", 5);\n+      d = AssignDebug (d, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1397, (const char *) \"Slice\", 5);\n     }\n   return d;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -2214,7 +2214,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_RemoveComment (DynamicStrings_St\n     }\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1509, (const char *) \"RemoveComment\", 13);\n+      s = AssignDebug (s, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1509, (const char *) \"RemoveComment\", 13);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -2239,7 +2239,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_RemoveWhitePrefix (DynamicString\n   s = DynamicStrings_Slice (s, (int ) (i), 0);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1621, (const char *) \"RemoveWhitePrefix\", 17);\n+      s = AssignDebug (s, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1621, (const char *) \"RemoveWhitePrefix\", 17);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -2264,7 +2264,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_RemoveWhitePostfix (DynamicStrin\n   s = DynamicStrings_Slice (s, 0, i+1);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1643, (const char *) \"RemoveWhitePostfix\", 18);\n+      s = AssignDebug (s, (const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 1643, (const char *) \"RemoveWhitePostfix\", 18);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -2633,7 +2633,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_PopAllocationExemption (unsigned\n         {\n           stop ();\n           /* writeString (\"mismatched number of PopAllocation's compared to PushAllocation's\")  */\n-          M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 176, (const char *) \"PopAllocationExemption\", 22, (const char *) \"mismatched number of PopAllocation's compared to PushAllocation's\", 65);\n+          M2RTS_Halt ((const char *) \"../../gcc/m2/gm2-libs/DynamicStrings.mod\", 40, 176, (const char *) \"PopAllocationExemption\", 22, (const char *) \"mismatched number of PopAllocation's compared to PushAllocation's\", 65);\n         }\n       else\n         {\n@@ -2674,6 +2674,6 @@ extern \"C\" void _M2_DynamicStrings_init (__attribute__((unused)) int argc,__attr\n   Init ();\n }\n \n-extern \"C\" void _M2_DynamicStrings_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_DynamicStrings_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "d3e6b4dacc6b2ef34bc534f008b72b34020278cc", "filename": "gcc/m2/pge-boot/GFIO.c", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGFIO.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGFIO.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGFIO.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -558,7 +558,7 @@ static FIO_File GetNextFreeDescriptor (void)\n         return f;  /* create new slot  */\n       }\n   }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/FIO.def\", 25, 1);\n+  ReturnException (\"../../gcc/m2/gm2-libs/FIO.def\", 25, 1);\n   __builtin_unreachable ();\n }\n \n@@ -729,7 +729,7 @@ static int ReadFromBuffer (FIO_File f, void * a, unsigned int nBytes)\n                   (*p) = static_cast<unsigned char> ((*fd->buffer->contents).array[fd->buffer->position]);\n                   fd->buffer->left -= 1;  /* remove consumed bytes  */\n                   fd->buffer->position += 1;  /* move onwards n bytes  */\n-                  nBytes = 0;  /* reduce the amount for future direct  */\n+                  nBytes = 0;\n                   /* read  */\n                   return 1;\n                 }\n@@ -824,7 +824,6 @@ static int BufferedRead (FIO_File f, unsigned int nBytes, void * a)\n \n   if (f != Error)\n     {\n-      /* avoid dangling else.  */\n       fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n       total = 0;  /* how many bytes have we read  */\n       if (fd != NULL)  /* how many bytes have we read  */\n@@ -894,16 +893,9 @@ static int BufferedRead (FIO_File f, unsigned int nBytes, void * a)\n                 }\n               return total;\n             }\n-          else\n-            {\n-              return -1;\n-            }\n         }\n     }\n-  else\n-    {\n-      return -1;\n-    }\n+  return -1;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n   __builtin_unreachable ();\n }\n@@ -2269,7 +2261,8 @@ extern \"C\" void * FIO_getFileName (FIO_File f)\n           return fd->name.address;\n         }\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/FIO.def\", 25, 1);\n+  return NULL;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n   __builtin_unreachable ();\n }\n \n@@ -2296,7 +2289,8 @@ extern \"C\" unsigned int FIO_getFileNameLength (FIO_File f)\n           return fd->name.size;\n         }\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/FIO.def\", 25, 1);\n+  return 0;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n   __builtin_unreachable ();\n }\n \n@@ -2325,7 +2319,7 @@ extern \"C\" void _M2_FIO_init (__attribute__((unused)) int argc,__attribute__((un\n   Init ();\n }\n \n-extern \"C\" void _M2_FIO_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_FIO_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n   FIO_FlushOutErr ();\n }"}, {"sha": "1d670569c2a7857a49e971660ad630db58426ec4", "filename": "gcc/m2/pge-boot/GIO.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGIO.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGIO.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGIO.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -474,6 +474,6 @@ extern \"C\" void _M2_IO_init (__attribute__((unused)) int argc,__attribute__((unu\n   Init ();\n }\n \n-extern \"C\" void _M2_IO_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_IO_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "428f22bfce179c78e3899b709a6571577f1d4fd2", "filename": "gcc/m2/pge-boot/GIndexing.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGIndexing.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGIndexing.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGIndexing.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -227,7 +227,7 @@ extern \"C\" unsigned int Indexing_InBounds (Indexing_Index i, unsigned int n)\n     {\n       return (n >= i->Low) && (n <= i->High);\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/Indexing.def\", 25, 1);\n+  ReturnException (\"../../gcc/m2/gm2-libs/Indexing.def\", 25, 1);\n   __builtin_unreachable ();\n }\n \n@@ -247,7 +247,7 @@ extern \"C\" unsigned int Indexing_HighIndice (Indexing_Index i)\n     {\n       return i->High;\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/Indexing.def\", 25, 1);\n+  ReturnException (\"../../gcc/m2/gm2-libs/Indexing.def\", 25, 1);\n   __builtin_unreachable ();\n }\n \n@@ -267,7 +267,7 @@ extern \"C\" unsigned int Indexing_LowIndice (Indexing_Index i)\n     {\n       return i->Low;\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/Indexing.def\", 25, 1);\n+  ReturnException (\"../../gcc/m2/gm2-libs/Indexing.def\", 25, 1);\n   __builtin_unreachable ();\n }\n \n@@ -488,6 +488,6 @@ extern \"C\" void _M2_Indexing_init (__attribute__((unused)) int argc,__attribute_\n {\n }\n \n-extern \"C\" void _M2_Indexing_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_Indexing_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "45f0ffcb3d3294d60e06bd11a6c31084e8537a9d", "filename": "gcc/m2/pge-boot/GLists.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGLists.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGLists.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGLists.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -422,6 +422,6 @@ extern \"C\" void _M2_Lists_init (__attribute__((unused)) int argc,__attribute__((\n {\n }\n \n-extern \"C\" void _M2_Lists_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_Lists_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "0e0e3eadcc3d027cfa92f323444a1a5c370da6bd", "filename": "gcc/m2/pge-boot/GM2Dependent.c", "status": "modified", "additions": 351, "deletions": 103, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGM2Dependent.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGM2Dependent.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGM2Dependent.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -42,7 +42,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <stddef.h>\n #include <string.h>\n #include <limits.h>\n+#include <stdlib.h>\n #   include \"GStorage.h\"\n+#include <unistd.h>\n #if defined(__cplusplus)\n #   undef NULL\n #   define NULL 0\n@@ -84,6 +86,7 @@ struct M2Dependent_DependencyList_r {\n struct M2Dependent__T3_a { M2Dependent_ModuleChain array[M2Dependent_user-M2Dependent_unregistered+1]; };\n struct M2Dependent__T2_r {\n                            void *name;\n+                           void *libname;\n                            M2Dependent_ArgCVEnvP init;\n                            M2Dependent_ArgCVEnvP fini;\n                            M2Dependent_DependencyList dependency;\n@@ -93,7 +96,9 @@ struct M2Dependent__T2_r {\n \n static M2Dependent__T3 Modules;\n static unsigned int Initialized;\n+static unsigned int WarningTrace;\n static unsigned int ModuleTrace;\n+static unsigned int HexTrace;\n static unsigned int DependencyTrace;\n static unsigned int PreTrace;\n static unsigned int PostTrace;\n@@ -104,37 +109,37 @@ static unsigned int ForceTrace;\n                       module constructor in turn.\n */\n \n-extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n+extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n \n /*\n    DeconstructModules - resolve dependencies and then call each\n                         module constructor in turn.\n */\n \n-extern \"C\" void M2Dependent_DeconstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n+extern \"C\" void M2Dependent_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n \n /*\n    RegisterModule - adds module name to the list of outstanding\n                     modules which need to have their dependencies\n                     explored to determine initialization order.\n */\n \n-extern \"C\" void M2Dependent_RegisterModule (void * name, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies);\n+extern \"C\" void M2Dependent_RegisterModule (void * modulename, void * libname, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies);\n \n /*\n    RequestDependant - used to specify that modulename is dependant upon\n                       module dependantmodule.  It only takes effect\n                       if we are not using StaticInitialization.\n */\n \n-extern \"C\" void M2Dependent_RequestDependant (void * modulename, void * dependantmodule);\n+extern \"C\" void M2Dependent_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname);\n \n /*\n    CreateModule - creates a new module entry and returns the\n                   ModuleChain.\n */\n \n-static M2Dependent_ModuleChain CreateModule (void * name, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies);\n+static M2Dependent_ModuleChain CreateModule (void * name, void * libname, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies);\n \n /*\n    AppendModule - append chain to end of the list.\n@@ -155,18 +160,30 @@ static void RemoveModule (M2Dependent_ModuleChain *head, M2Dependent_ModuleChain\n static unsigned int onChain (M2Dependent_DependencyState state, M2Dependent_ModuleChain mptr);\n \n /*\n-   LookupModuleN - lookup module from the state list.  The string is limited\n-                   to nchar.\n+   max -\n */\n \n-static M2Dependent_ModuleChain LookupModuleN (M2Dependent_DependencyState state, void * name, unsigned int nchar);\n+static unsigned int max (unsigned int a, unsigned int b);\n+\n+/*\n+   min -\n+*/\n+\n+static unsigned int min (unsigned int a, unsigned int b);\n+\n+/*\n+   LookupModuleN - lookup module from the state list.\n+                   The strings lengths are known.\n+*/\n+\n+static M2Dependent_ModuleChain LookupModuleN (M2Dependent_DependencyState state, void * name, unsigned int namelen, void * libname, unsigned int libnamelen);\n \n /*\n    LookupModule - lookup and return the ModuleChain pointer containing\n                   module name from a particular list.\n */\n \n-static M2Dependent_ModuleChain LookupModule (M2Dependent_DependencyState state, void * name);\n+static M2Dependent_ModuleChain LookupModule (M2Dependent_DependencyState state, void * name, void * libname);\n \n /*\n    toCString - replace any character sequence \n@@ -207,6 +224,12 @@ static void traceprintf (unsigned int flag, const char *str_, unsigned int _str_\n \n static void traceprintf2 (unsigned int flag, const char *str_, unsigned int _str_high, void * arg);\n \n+/*\n+   traceprintf3 - wrap printf with a boolean flag.\n+*/\n+\n+static void traceprintf3 (unsigned int flag, const char *str_, unsigned int _str_high, void * arg1, void * arg2);\n+\n /*\n    moveTo - moves mptr to the new list determined by newstate.\n             It updates the mptr state appropriately.\n@@ -218,7 +241,7 @@ static void moveTo (M2Dependent_DependencyState newstate, M2Dependent_ModuleChai\n    ResolveDependant -\n */\n \n-static void ResolveDependant (M2Dependent_ModuleChain mptr, void * currentmodule);\n+static void ResolveDependant (M2Dependent_ModuleChain mptr, void * currentmodule, void * libname);\n \n /*\n    PerformRequestDependant - the current modulename has a dependancy upon\n@@ -227,19 +250,19 @@ static void ResolveDependant (M2Dependent_ModuleChain mptr, void * currentmodule\n                              resolved.\n */\n \n-static void PerformRequestDependant (void * modulename, void * dependantmodule);\n+static void PerformRequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname);\n \n /*\n-   ResolveDependencies - resolve dependencies for currentmodule.\n+   ResolveDependencies - resolve dependencies for currentmodule, libname.\n */\n \n-static void ResolveDependencies (void * currentmodule);\n+static void ResolveDependencies (void * currentmodule, void * libname);\n \n /*\n    DisplayModuleInfo - displays all module in the state.\n */\n \n-static void DisplayModuleInfo (M2Dependent_DependencyState state, const char *name_, unsigned int _name_high);\n+static void DisplayModuleInfo (M2Dependent_DependencyState state, const char *desc_, unsigned int _desc_high);\n \n /*\n    DumpModuleData -\n@@ -256,6 +279,18 @@ static void DumpModuleData (unsigned int flag);\n \n static void combine (M2Dependent_DependencyState src, M2Dependent_DependencyState dest);\n \n+/*\n+   tracemodule -\n+*/\n+\n+static void tracemodule (unsigned int flag, void * modname, unsigned int modlen, void * libname, unsigned int liblen);\n+\n+/*\n+   ForceModule -\n+*/\n+\n+static void ForceModule (void * modname, unsigned int modlen, void * libname, unsigned int liblen);\n+\n /*\n    ForceDependencies - if the user has specified a forced order then we override\n                        the dynamic ordering with the preference.\n@@ -270,6 +305,12 @@ static void ForceDependencies (void);\n \n static void CheckApplication (void);\n \n+/*\n+   warning3 - write format arg1 arg2 to stderr.\n+*/\n+\n+static void warning3 (const char *format_, unsigned int _format_high, void * arg1, void * arg2);\n+\n /*\n    equal - return TRUE if C string cstr is equal to str.\n */\n@@ -280,11 +321,12 @@ static unsigned int equal (void * cstr, const char *str_, unsigned int _str_high\n    SetupDebugFlags - By default assigns ModuleTrace, DependencyTrace,\n                      DumpPostInit to FALSE.  It checks the environment\n                      GCC_M2LINK_RTFLAG which can contain\n-                     \"all,module,pre,post,dep,force\".  all turns them all on.\n+                     \"all,module,hex,pre,post,dep,force\".  all turns them all on.\n                      The flag meanings are as follows and flags the are in\n                      execution order.\n \n                      module   generate trace info as the modules are registered.\n+                     hex      dump the modules ctor functions address in hex.\n                      pre      generate a list of all modules seen prior to having\n                               their dependancies resolved.\n                      dep      display a trace as the modules are resolved.\n@@ -317,18 +359,26 @@ static void CheckInitialized (void);\n                   ModuleChain.\n */\n \n-static M2Dependent_ModuleChain CreateModule (void * name, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies)\n+static M2Dependent_ModuleChain CreateModule (void * name, void * libname, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies)\n {\n   M2Dependent_ModuleChain mptr;\n+  void * p0;\n+  void * p1;\n \n   Storage_ALLOCATE ((void **) &mptr, sizeof (M2Dependent__T2));\n   mptr->name = name;\n+  mptr->libname = libname;\n   mptr->init = init;\n   mptr->fini = fini;\n   mptr->dependency.proc = dependencies;\n   mptr->dependency.state = M2Dependent_unregistered;\n   mptr->prev = NULL;\n   mptr->next = NULL;\n+  if (HexTrace)\n+    {\n+      libc_printf ((const char *) \"   (init: %p  fini: %p\", 22, init, fini);\n+      libc_printf ((const char *) \"  dep: %p)\", 10, dependencies);\n+    }\n   return mptr;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n   __builtin_unreachable ();\n@@ -405,19 +455,57 @@ static unsigned int onChain (M2Dependent_DependencyState state, M2Dependent_Modu\n \n \n /*\n-   LookupModuleN - lookup module from the state list.  The string is limited\n-                   to nchar.\n+   max -\n+*/\n+\n+static unsigned int max (unsigned int a, unsigned int b)\n+{\n+  if (a > b)\n+    {\n+      return a;\n+    }\n+  else\n+    {\n+      return b;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   min -\n */\n \n-static M2Dependent_ModuleChain LookupModuleN (M2Dependent_DependencyState state, void * name, unsigned int nchar)\n+static unsigned int min (unsigned int a, unsigned int b)\n+{\n+  if (a < b)\n+    {\n+      return a;\n+    }\n+  else\n+    {\n+      return b;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   LookupModuleN - lookup module from the state list.\n+                   The strings lengths are known.\n+*/\n+\n+static M2Dependent_ModuleChain LookupModuleN (M2Dependent_DependencyState state, void * name, unsigned int namelen, void * libname, unsigned int libnamelen)\n {\n   M2Dependent_ModuleChain ptr;\n \n   if (Modules.array[state-M2Dependent_unregistered] != NULL)\n     {\n       ptr = Modules.array[state-M2Dependent_unregistered];\n       do {\n-        if ((strncmp (reinterpret_cast<M2LINK_PtrToChar> (ptr->name), reinterpret_cast<M2LINK_PtrToChar> (name), nchar)) == 0)\n+        if (((strncmp (reinterpret_cast<M2LINK_PtrToChar> (ptr->name), reinterpret_cast<M2LINK_PtrToChar> (name), max (namelen, static_cast<unsigned int> (strlen_ (reinterpret_cast<M2LINK_PtrToChar> (ptr->name)))))) == 0) && ((strncmp (reinterpret_cast<M2LINK_PtrToChar> (ptr->libname), reinterpret_cast<M2LINK_PtrToChar> (libname), max (libnamelen, static_cast<unsigned int> (strlen_ (reinterpret_cast<M2LINK_PtrToChar> (ptr->libname)))))) == 0))\n           {\n             return ptr;\n           }\n@@ -435,9 +523,9 @@ static M2Dependent_ModuleChain LookupModuleN (M2Dependent_DependencyState state,\n                   module name from a particular list.\n */\n \n-static M2Dependent_ModuleChain LookupModule (M2Dependent_DependencyState state, void * name)\n+static M2Dependent_ModuleChain LookupModule (M2Dependent_DependencyState state, void * name, void * libname)\n {\n-  return LookupModuleN (state, name, static_cast<unsigned int> (strlen_ (reinterpret_cast<M2LINK_PtrToChar> (name))));\n+  return LookupModuleN (state, name, static_cast<unsigned int> (strlen_ (reinterpret_cast<M2LINK_PtrToChar> (name))), libname, static_cast<unsigned int> (strlen_ (reinterpret_cast<M2LINK_PtrToChar> (libname))));\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n   __builtin_unreachable ();\n }\n@@ -516,9 +604,13 @@ static int strcmp (M2LINK_PtrToChar a, M2LINK_PtrToChar b)\n \n static int strncmp (M2LINK_PtrToChar a, M2LINK_PtrToChar b, unsigned int n)\n {\n-  if (((a != NULL) && (b != NULL)) && (n > 0))\n+  if (n == 0)\n     {\n-      /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+      return 0;\n+    }\n+  else if ((a != NULL) && (b != NULL))\n+    {\n+      /* avoid dangling else.  */\n       if (a == b)\n         {\n           return 0;\n@@ -595,6 +687,7 @@ static void traceprintf (unsigned int flag, const char *str_, unsigned int _str_\n \n static void traceprintf2 (unsigned int flag, const char *str_, unsigned int _str_high, void * arg)\n {\n+  char ch;\n   char str[_str_high+1];\n \n   /* make a local copy of each unbounded array.  */\n@@ -603,11 +696,46 @@ static void traceprintf2 (unsigned int flag, const char *str_, unsigned int _str\n   if (flag)\n     {\n       toCString ((char *) str, _str_high);\n+      if (arg == NULL)\n+        {\n+          ch = (char) 0;\n+          arg = &ch;\n+        }\n       libc_printf ((const char *) str, _str_high, arg);\n     }\n }\n \n \n+/*\n+   traceprintf3 - wrap printf with a boolean flag.\n+*/\n+\n+static void traceprintf3 (unsigned int flag, const char *str_, unsigned int _str_high, void * arg1, void * arg2)\n+{\n+  char ch;\n+  char str[_str_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (str, str_, _str_high+1);\n+\n+  if (flag)\n+    {\n+      toCString ((char *) str, _str_high);\n+      if (arg1 == NULL)\n+        {\n+          ch = (char) 0;\n+          arg1 = &ch;\n+        }\n+      if (arg2 == NULL)\n+        {\n+          ch = (char) 0;\n+          arg2 = &ch;\n+        }\n+      libc_printf ((const char *) str, _str_high, arg1, arg2);\n+    }\n+}\n+\n+\n /*\n    moveTo - moves mptr to the new list determined by newstate.\n             It updates the mptr state appropriately.\n@@ -628,11 +756,11 @@ static void moveTo (M2Dependent_DependencyState newstate, M2Dependent_ModuleChai\n    ResolveDependant -\n */\n \n-static void ResolveDependant (M2Dependent_ModuleChain mptr, void * currentmodule)\n+static void ResolveDependant (M2Dependent_ModuleChain mptr, void * currentmodule, void * libname)\n {\n   if (mptr == NULL)\n     {\n-      traceprintf (DependencyTrace, (const char *) \"   module has not been registered via a global constructor\\\\n\", 60);\n+      traceprintf3 (DependencyTrace, (const char *) \"   module %s [%s] has not been registered via a global constructor\\\\n\", 68, currentmodule, libname);\n     }\n   else\n     {\n@@ -643,9 +771,9 @@ static void ResolveDependant (M2Dependent_ModuleChain mptr, void * currentmodule\n       else\n         {\n           moveTo (M2Dependent_started, mptr);\n-          traceprintf2 (DependencyTrace, (const char *) \"   starting: %s\\\\n\", 17, currentmodule);\n+          traceprintf3 (DependencyTrace, (const char *) \"   starting: %s [%s]\\\\n\", 22, currentmodule, libname);\n           (*mptr->dependency.proc.proc) ();  /* Invoke and process the dependency graph.  */\n-          traceprintf2 (DependencyTrace, (const char *) \"   finished: %s\\\\n\", 17, currentmodule);  /* Invoke and process the dependency graph.  */\n+          traceprintf3 (DependencyTrace, (const char *) \"   finished: %s [%s]\\\\n\", 22, currentmodule, libname);  /* Invoke and process the dependency graph.  */\n           moveTo (M2Dependent_ordered, mptr);\n         }\n     }\n@@ -659,73 +787,73 @@ static void ResolveDependant (M2Dependent_ModuleChain mptr, void * currentmodule\n                              resolved.\n */\n \n-static void PerformRequestDependant (void * modulename, void * dependantmodule)\n+static void PerformRequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname)\n {\n   M2Dependent_ModuleChain mptr;\n \n-  traceprintf2 (DependencyTrace, (const char *) \"  module %s\", 11, modulename);\n+  traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s]\", 16, modulename, libname);\n   if (dependantmodule == NULL)\n     {\n       /* avoid dangling else.  */\n-      traceprintf2 (DependencyTrace, (const char *) \" has finished its import graph\\\\n\", 32, modulename);\n-      mptr = LookupModule (M2Dependent_unordered, modulename);\n+      traceprintf (DependencyTrace, (const char *) \" has finished its import graph\\\\n\", 32);\n+      mptr = LookupModule (M2Dependent_unordered, modulename, libname);\n       if (mptr != NULL)\n         {\n-          traceprintf2 (DependencyTrace, (const char *) \"  module %s is now ordered\\\\n\", 28, modulename);\n+          traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] is now ordered\\\\n\", 33, modulename, libname);\n           moveTo (M2Dependent_ordered, mptr);\n         }\n     }\n   else\n     {\n-      traceprintf2 (DependencyTrace, (const char *) \" imports from %s\\\\n\", 18, dependantmodule);\n-      mptr = LookupModule (M2Dependent_ordered, dependantmodule);\n+      traceprintf3 (DependencyTrace, (const char *) \" imports from %s [%s]\\\\n\", 23, dependantmodule, dependantlibname);\n+      mptr = LookupModule (M2Dependent_ordered, dependantmodule, dependantlibname);\n       if (mptr == NULL)\n         {\n-          traceprintf2 (DependencyTrace, (const char *) \"  module %s is not ordered\\\\n\", 28, dependantmodule);\n-          mptr = LookupModule (M2Dependent_unordered, dependantmodule);\n+          traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] is not ordered\\\\n\", 33, dependantmodule, dependantlibname);\n+          mptr = LookupModule (M2Dependent_unordered, dependantmodule, dependantlibname);\n           if (mptr == NULL)\n             {\n-              traceprintf2 (DependencyTrace, (const char *) \"  module %s is not unordered\\\\n\", 30, dependantmodule);\n-              mptr = LookupModule (M2Dependent_started, dependantmodule);\n+              traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] is not unordered\\\\n\", 35, dependantmodule, dependantlibname);\n+              mptr = LookupModule (M2Dependent_started, dependantmodule, dependantlibname);\n               if (mptr == NULL)\n                 {\n-                  traceprintf2 (DependencyTrace, (const char *) \"  module %s has not started\\\\n\", 29, dependantmodule);\n-                  traceprintf2 (DependencyTrace, (const char *) \"  module %s attempting to import from\", 37, modulename);\n-                  traceprintf2 (DependencyTrace, (const char *) \" %s which has not registered itself via a constructor\\\\n\", 55, dependantmodule);\n+                  traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] has not started\\\\n\", 34, dependantmodule, dependantlibname);\n+                  traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] attempting to import from\", 42, modulename, libname);\n+                  traceprintf3 (DependencyTrace, (const char *) \" %s [%s] which has not registered itself via a constructor\\\\n\", 60, dependantmodule, dependantlibname);\n                 }\n               else\n                 {\n-                  traceprintf2 (DependencyTrace, (const char *) \"  module %s has registered itself and has started\\\\n\", 51, dependantmodule);\n+                  traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] has registered itself and has started\\\\n\", 56, dependantmodule, dependantlibname);\n                 }\n             }\n           else\n             {\n-              traceprintf2 (DependencyTrace, (const char *) \"  module %s resolving\\\\n\", 23, dependantmodule);\n-              ResolveDependant (mptr, dependantmodule);\n+              traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] resolving\\\\n\", 28, dependantmodule, dependantlibname);\n+              ResolveDependant (mptr, dependantmodule, dependantlibname);\n             }\n         }\n       else\n         {\n-          traceprintf2 (DependencyTrace, (const char *) \"  module %s \", 12, modulename);\n-          traceprintf2 (DependencyTrace, (const char *) \" dependant %s is ordered\\\\n\", 26, dependantmodule);\n+          traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s]\", 16, modulename, libname);\n+          traceprintf3 (DependencyTrace, (const char *) \" dependant %s [%s] is ordered\\\\n\", 31, dependantmodule, dependantlibname);\n         }\n     }\n }\n \n \n /*\n-   ResolveDependencies - resolve dependencies for currentmodule.\n+   ResolveDependencies - resolve dependencies for currentmodule, libname.\n */\n \n-static void ResolveDependencies (void * currentmodule)\n+static void ResolveDependencies (void * currentmodule, void * libname)\n {\n   M2Dependent_ModuleChain mptr;\n \n-  mptr = LookupModule (M2Dependent_unordered, currentmodule);\n+  mptr = LookupModule (M2Dependent_unordered, currentmodule, libname);\n   while (mptr != NULL)\n     {\n-      traceprintf2 (DependencyTrace, (const char *) \"   attempting to resolve the dependants for %s\\\\n\", 48, currentmodule);\n-      ResolveDependant (mptr, currentmodule);\n+      traceprintf3 (DependencyTrace, (const char *) \"   attempting to resolve the dependants for %s [%s]\\\\n\", 53, currentmodule, libname);\n+      ResolveDependant (mptr, currentmodule, libname);\n       mptr = Modules.array[M2Dependent_unordered-M2Dependent_unregistered];\n     }\n }\n@@ -735,22 +863,29 @@ static void ResolveDependencies (void * currentmodule)\n    DisplayModuleInfo - displays all module in the state.\n */\n \n-static void DisplayModuleInfo (M2Dependent_DependencyState state, const char *name_, unsigned int _name_high)\n+static void DisplayModuleInfo (M2Dependent_DependencyState state, const char *desc_, unsigned int _desc_high)\n {\n   M2Dependent_ModuleChain mptr;\n   unsigned int count;\n-  char name[_name_high+1];\n+  char desc[_desc_high+1];\n \n   /* make a local copy of each unbounded array.  */\n-  memcpy (name, name_, _name_high+1);\n+  memcpy (desc, desc_, _desc_high+1);\n \n   if (Modules.array[state-M2Dependent_unregistered] != NULL)\n     {\n-      libc_printf ((const char *) \"%s modules\\\\n\", 12, &name);\n+      libc_printf ((const char *) \"%s modules\\\\n\", 12, &desc);\n       mptr = Modules.array[state-M2Dependent_unregistered];\n       count = 0;\n       do {\n-        libc_printf ((const char *) \"  %d  %s\", 8, count, mptr->name);\n+        if (mptr->name == NULL)\n+          {\n+            libc_printf ((const char *) \"  %d  %s []\", 11, count, mptr->name);\n+          }\n+        else\n+          {\n+            libc_printf ((const char *) \"  %d  %s [%s]\", 13, count, mptr->name, mptr->libname);\n+          }\n         count += 1;\n         if (mptr->dependency.appl)\n           {\n@@ -809,53 +944,111 @@ static void combine (M2Dependent_DependencyState src, M2Dependent_DependencyStat\n }\n \n \n+/*\n+   tracemodule -\n+*/\n+\n+static void tracemodule (unsigned int flag, void * modname, unsigned int modlen, void * libname, unsigned int liblen)\n+{\n+  typedef struct tracemodule__T4_a tracemodule__T4;\n+\n+  struct tracemodule__T4_a { char array[100+1]; };\n+  tracemodule__T4 buffer;\n+  unsigned int len;\n+\n+  if (flag)\n+    {\n+      len = min (modlen, sizeof (buffer)-1);\n+      libc_strncpy (&buffer, modname, len);\n+      buffer.array[len] = (char) 0;\n+      libc_printf ((const char *) \"%s \", 3, &buffer);\n+      len = min (liblen, sizeof (buffer)-1);\n+      libc_strncpy (&buffer, libname, len);\n+      buffer.array[len] = (char) 0;\n+      libc_printf ((const char *) \" [%s]\", 5, &buffer);\n+    }\n+}\n+\n+\n+/*\n+   ForceModule -\n+*/\n+\n+static void ForceModule (void * modname, unsigned int modlen, void * libname, unsigned int liblen)\n+{\n+  M2Dependent_ModuleChain mptr;\n+\n+  traceprintf (ForceTrace, (const char *) \"forcing module: \", 16);\n+  tracemodule (ForceTrace, modname, modlen, libname, liblen);\n+  traceprintf (ForceTrace, (const char *) \"\\\\n\", 2);\n+  mptr = LookupModuleN (M2Dependent_ordered, modname, modlen, libname, liblen);\n+  if (mptr != NULL)\n+    {\n+      mptr->dependency.forced = TRUE;\n+      moveTo (M2Dependent_user, mptr);\n+    }\n+}\n+\n+\n /*\n    ForceDependencies - if the user has specified a forced order then we override\n                        the dynamic ordering with the preference.\n */\n \n static void ForceDependencies (void)\n {\n-  M2Dependent_ModuleChain mptr;\n-  M2Dependent_ModuleChain userChain;\n-  unsigned int count;\n+  unsigned int len;\n+  unsigned int modlen;\n+  unsigned int liblen;\n+  M2LINK_PtrToChar modname;\n+  M2LINK_PtrToChar libname;\n   M2LINK_PtrToChar pc;\n   M2LINK_PtrToChar start;\n \n   if (M2LINK_ForcedModuleInitOrder != NULL)\n     {\n-      userChain = NULL;\n+      traceprintf2 (ForceTrace, (const char *) \"user forcing order: %s\\\\n\", 24, reinterpret_cast<void *> (M2LINK_ForcedModuleInitOrder));\n       pc = M2LINK_ForcedModuleInitOrder;\n       start = pc;\n-      count = 0;\n+      len = 0;\n+      modname = NULL;\n+      modlen = 0;\n+      libname = NULL;\n+      liblen = 0;\n       while ((*pc) != ASCII_nul)\n         {\n-          if ((*pc) == ',')\n-            {\n-              mptr = LookupModuleN (M2Dependent_ordered, reinterpret_cast<void *> (start), count);\n-              if (mptr != NULL)\n-                {\n-                  mptr->dependency.forced = TRUE;\n-                  moveTo (M2Dependent_user, mptr);\n-                }\n-              pc += 1;\n-              start = pc;\n-              count = 0;\n-            }\n-          else\n+          switch ((*pc))\n             {\n-              pc += 1;\n-              count += 1;\n+              case ':':\n+                libname = start;\n+                liblen = len;\n+                len = 0;\n+                pc += 1;\n+                start = pc;\n+                break;\n+\n+              case ',':\n+                modname = start;\n+                modlen = len;\n+                ForceModule (reinterpret_cast<void *> (modname), modlen, reinterpret_cast<void *> (libname), liblen);\n+                libname = NULL;\n+                liblen = 0;\n+                modlen = 0;\n+                len = 0;\n+                pc += 1;\n+                start = pc;\n+                break;\n+\n+\n+              default:\n+                pc += 1;\n+                len += 1;\n+                break;\n             }\n         }\n       if (start != pc)\n         {\n-          mptr = LookupModuleN (M2Dependent_ordered, reinterpret_cast<void *> (start), count);\n-          if (mptr != NULL)\n-            {\n-              mptr->dependency.forced = TRUE;\n-              moveTo (M2Dependent_user, mptr);\n-            }\n+          ForceModule (reinterpret_cast<void *> (start), len, reinterpret_cast<void *> (libname), liblen);\n         }\n       combine (M2Dependent_user, M2Dependent_ordered);\n     }\n@@ -888,12 +1081,39 @@ static void CheckApplication (void)\n       } while (! ((appl != NULL) || (mptr == Modules.array[M2Dependent_ordered-M2Dependent_unregistered])));\n       if (appl != NULL)\n         {\n-          Modules.array[M2Dependent_ordered-M2Dependent_unregistered] = appl->next;\n+          RemoveModule (&Modules.array[M2Dependent_ordered-M2Dependent_unregistered], appl);\n+          AppendModule (&Modules.array[M2Dependent_ordered-M2Dependent_unregistered], appl);\n         }\n     }\n }\n \n \n+/*\n+   warning3 - write format arg1 arg2 to stderr.\n+*/\n+\n+static void warning3 (const char *format_, unsigned int _format_high, void * arg1, void * arg2)\n+{\n+  typedef struct warning3__T5_a warning3__T5;\n+\n+  struct warning3__T5_a { char array[4096+1]; };\n+  warning3__T5 buffer;\n+  int len;\n+  char format[_format_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (format, format_, _format_high+1);\n+\n+  if (WarningTrace)\n+    {\n+      len = libc_snprintf (&buffer, static_cast<size_t> (sizeof (buffer)), (const char *) \"warning: \", 9);\n+      libc_write (2, &buffer, static_cast<size_t> (len));\n+      len = libc_snprintf (&buffer, static_cast<size_t> (sizeof (buffer)), (const char *) format, _format_high, arg1, arg2);\n+      libc_write (2, &buffer, static_cast<size_t> (len));\n+    }\n+}\n+\n+\n /*\n    equal - return TRUE if C string cstr is equal to str.\n */\n@@ -915,11 +1135,12 @@ static unsigned int equal (void * cstr, const char *str_, unsigned int _str_high\n    SetupDebugFlags - By default assigns ModuleTrace, DependencyTrace,\n                      DumpPostInit to FALSE.  It checks the environment\n                      GCC_M2LINK_RTFLAG which can contain\n-                     \"all,module,pre,post,dep,force\".  all turns them all on.\n+                     \"all,module,hex,pre,post,dep,force\".  all turns them all on.\n                      The flag meanings are as follows and flags the are in\n                      execution order.\n \n                      module   generate trace info as the modules are registered.\n+                     hex      dump the modules ctor functions address in hex.\n                      pre      generate a list of all modules seen prior to having\n                               their dependancies resolved.\n                      dep      display a trace as the modules are resolved.\n@@ -940,6 +1161,8 @@ static void SetupDebugFlags (void)\n   PostTrace = FALSE;\n   PreTrace = FALSE;\n   ForceTrace = FALSE;\n+  HexTrace = FALSE;\n+  WarningTrace = FALSE;\n   pc = static_cast<SetupDebugFlags__T1> (libc_getenv (const_cast<void*> (reinterpret_cast<const void*>(\"GCC_M2LINK_RTFLAG\"))));\n   while ((pc != NULL) && ((*pc) != ASCII_nul))\n     {\n@@ -950,6 +1173,8 @@ static void SetupDebugFlags (void)\n           PreTrace = TRUE;\n           PostTrace = TRUE;\n           ForceTrace = TRUE;\n+          HexTrace = TRUE;\n+          WarningTrace = TRUE;\n           pc += 3;\n         }\n       else if (equal (reinterpret_cast<void *> (pc), (const char *) \"module\", 6))\n@@ -958,6 +1183,18 @@ static void SetupDebugFlags (void)\n           ModuleTrace = TRUE;\n           pc += 6;\n         }\n+      else if (equal (reinterpret_cast<void *> (pc), (const char *) \"warning\", 7))\n+        {\n+          /* avoid dangling else.  */\n+          WarningTrace = TRUE;\n+          pc += 7;\n+        }\n+      else if (equal (reinterpret_cast<void *> (pc), (const char *) \"hex\", 3))\n+        {\n+          /* avoid dangling else.  */\n+          HexTrace = TRUE;\n+          pc += 3;\n+        }\n       else if (equal (reinterpret_cast<void *> (pc), (const char *) \"dep\", 3))\n         {\n           /* avoid dangling else.  */\n@@ -1029,21 +1266,21 @@ static void CheckInitialized (void)\n                       module constructor in turn.\n */\n \n-extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, int argc, void * argv, void * envp)\n+extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp)\n {\n   M2Dependent_ModuleChain mptr;\n   M2Dependent_ArgCVEnvP nulp;\n \n   CheckInitialized ();\n-  traceprintf2 (ModuleTrace, (const char *) \"application module: %s\\\\n\", 24, applicationmodule);\n-  mptr = LookupModule (M2Dependent_unordered, applicationmodule);\n+  traceprintf3 (ModuleTrace, (const char *) \"application module: %s [%s]\\\\n\", 29, applicationmodule, libname);\n+  mptr = LookupModule (M2Dependent_unordered, applicationmodule, libname);\n   if (mptr != NULL)\n     {\n       mptr->dependency.appl = TRUE;\n     }\n   traceprintf (PreTrace, (const char *) \"Pre resolving dependents\\\\n\", 26);\n   DumpModuleData (PreTrace);\n-  ResolveDependencies (applicationmodule);\n+  ResolveDependencies (applicationmodule, libname);\n   traceprintf (PreTrace, (const char *) \"Post resolving dependents\\\\n\", 27);\n   DumpModuleData (PostTrace);\n   ForceDependencies ();\n@@ -1054,7 +1291,7 @@ extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, int argc\n   DumpModuleData (ForceTrace);\n   if (Modules.array[M2Dependent_ordered-M2Dependent_unregistered] == NULL)\n     {\n-      traceprintf2 (ModuleTrace, (const char *) \"  module: %s has not registered itself using a global constructor\\\\n\", 67, applicationmodule);\n+      traceprintf3 (ModuleTrace, (const char *) \"  module: %s [%s] has not registered itself using a global constructor\\\\n\", 72, applicationmodule, libname);\n       traceprintf2 (ModuleTrace, (const char *) \"  hint try compile and linking using: gm2 %s.mod\\\\n\", 50, applicationmodule);\n       traceprintf2 (ModuleTrace, (const char *) \"  or try using: gm2 -fscaffold-static %s.mod\\\\n\", 46, applicationmodule);\n     }\n@@ -1064,15 +1301,15 @@ extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, int argc\n       do {\n         if (mptr->dependency.forc)\n           {\n-            traceprintf2 (ModuleTrace, (const char *) \"initializing module: %s for C\\\\n\", 31, mptr->name);\n+            traceprintf3 (ModuleTrace, (const char *) \"initializing module: %s [%s] for C\\\\n\", 36, mptr->name, mptr->libname);\n           }\n         else\n           {\n-            traceprintf2 (ModuleTrace, (const char *) \"initializing module: %s\\\\n\", 25, mptr->name);\n+            traceprintf3 (ModuleTrace, (const char *) \"initializing module: %s [%s]\\\\n\", 30, mptr->name, mptr->libname);\n           }\n         if (mptr->dependency.appl)\n           {\n-            traceprintf2 (ModuleTrace, (const char *) \"application module: %s\\\\n\", 24, mptr->name);\n+            traceprintf3 (ModuleTrace, (const char *) \"application module: %s [%s]\\\\n\", 29, mptr->name, mptr->libname);\n             traceprintf (ModuleTrace, (const char *) \"  calling M2RTS_ExecuteInitialProcedures\\\\n\", 42);\n             M2RTS_ExecuteInitialProcedures ();\n             traceprintf (ModuleTrace, (const char *) \"  calling application module\\\\n\", 30);\n@@ -1089,11 +1326,11 @@ extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, int argc\n                         module constructor in turn.\n */\n \n-extern \"C\" void M2Dependent_DeconstructModules (void * applicationmodule, int argc, void * argv, void * envp)\n+extern \"C\" void M2Dependent_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp)\n {\n   M2Dependent_ModuleChain mptr;\n \n-  traceprintf2 (ModuleTrace, (const char *) \"application module finishing: %s\\\\n\", 34, applicationmodule);\n+  traceprintf3 (ModuleTrace, (const char *) \"application module finishing: %s [%s]\\\\n\", 39, applicationmodule, libname);\n   if (Modules.array[M2Dependent_ordered-M2Dependent_unregistered] == NULL)\n     {\n       traceprintf (ModuleTrace, (const char *) \"  no ordered modules found during finishing\\\\n\", 45);\n@@ -1107,11 +1344,11 @@ extern \"C\" void M2Dependent_DeconstructModules (void * applicationmodule, int ar\n       do {\n         if (mptr->dependency.forc)\n           {\n-            traceprintf2 (ModuleTrace, (const char *) \"finalizing module: %s for C\\\\n\", 29, mptr->name);\n+            traceprintf3 (ModuleTrace, (const char *) \"finalizing module: %s [%s] for C\\\\n\", 34, mptr->name, mptr->libname);\n           }\n         else\n           {\n-            traceprintf2 (ModuleTrace, (const char *) \"finalizing module: %s\\\\n\", 23, mptr->name);\n+            traceprintf3 (ModuleTrace, (const char *) \"finalizing module: %s [%s]\\\\n\", 28, mptr->name, mptr->libname);\n           }\n         (*mptr->fini.proc) (argc, argv, envp);\n         mptr = mptr->prev;\n@@ -1126,13 +1363,24 @@ extern \"C\" void M2Dependent_DeconstructModules (void * applicationmodule, int ar\n                     explored to determine initialization order.\n */\n \n-extern \"C\" void M2Dependent_RegisterModule (void * name, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies)\n+extern \"C\" void M2Dependent_RegisterModule (void * modulename, void * libname, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies)\n {\n+  M2Dependent_ModuleChain mptr;\n+\n   CheckInitialized ();\n   if (! M2LINK_StaticInitialization)\n     {\n-      traceprintf2 (ModuleTrace, (const char *) \"module: %s registering\\\\n\", 24, name);\n-      moveTo (M2Dependent_unordered, CreateModule (name, init, fini, dependencies));\n+      mptr = LookupModule (M2Dependent_unordered, modulename, libname);\n+      if (mptr == NULL)\n+        {\n+          traceprintf3 (ModuleTrace, (const char *) \"module: %s [%s] registering\", 27, modulename, libname);\n+          moveTo (M2Dependent_unordered, CreateModule (modulename, libname, init, fini, dependencies));\n+          traceprintf (ModuleTrace, (const char *) \"\\\\n\", 2);\n+        }\n+      else\n+        {\n+          warning3 ((const char *) \"module: %s [%s] (ignoring duplicate registration)\\\\n\", 51, modulename, libname);\n+        }\n     }\n }\n \n@@ -1143,12 +1391,12 @@ extern \"C\" void M2Dependent_RegisterModule (void * name, M2Dependent_ArgCVEnvP i\n                       if we are not using StaticInitialization.\n */\n \n-extern \"C\" void M2Dependent_RequestDependant (void * modulename, void * dependantmodule)\n+extern \"C\" void M2Dependent_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname)\n {\n   CheckInitialized ();\n   if (! M2LINK_StaticInitialization)\n     {\n-      PerformRequestDependant (modulename, dependantmodule);\n+      PerformRequestDependant (modulename, libname, dependantmodule, dependantlibname);\n     }\n }\n \n@@ -1157,6 +1405,6 @@ extern \"C\" void _M2_M2Dependent_init (__attribute__((unused)) int argc,__attribu\n   CheckInitialized ();\n }\n \n-extern \"C\" void _M2_M2Dependent_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_M2Dependent_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "c820ae14a8f25728c93818dcc91e4fd8f9460405", "filename": "gcc/m2/pge-boot/GM2Dependent.h", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGM2Dependent.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGM2Dependent.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGM2Dependent.h?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -29,8 +29,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #if !defined (_M2Dependent_H)\n #   define _M2Dependent_H\n \n-#include \"config.h\"\n-#include \"system.h\"\n #   ifdef __cplusplus\n extern \"C\" {\n #   endif\n@@ -53,23 +51,24 @@ typedef struct M2Dependent_ArgCVEnvP_p M2Dependent_ArgCVEnvP;\n typedef void (*M2Dependent_ArgCVEnvP_t) (int, void *, void *);\n struct M2Dependent_ArgCVEnvP_p { M2Dependent_ArgCVEnvP_t proc; };\n \n-EXTERN void M2Dependent_ConstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n-EXTERN void M2Dependent_DeconstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n+EXTERN void M2Dependent_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n+EXTERN void M2Dependent_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n \n /*\n    RegisterModule - adds module name to the list of outstanding\n                     modules which need to have their dependencies\n                     explored to determine initialization order.\n */\n \n-EXTERN void M2Dependent_RegisterModule (void * name, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies);\n+EXTERN void M2Dependent_RegisterModule (void * modulename, void * libname, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies);\n \n /*\n-   RequestDependant - used to specify that modulename is dependant upon\n-                      module dependantmodule.\n+   RequestDependant - used to specify that modulename:libname\n+                      is dependant upon\n+                      module dependantmodule:dependantlibname\n */\n \n-EXTERN void M2Dependent_RequestDependant (void * modulename, void * dependantmodule);\n+EXTERN void M2Dependent_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname);\n #   ifdef __cplusplus\n }\n #   endif"}, {"sha": "10de9b98d643a91797d373d51de74c2ed4717685", "filename": "gcc/m2/pge-boot/GM2EXCEPTION.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGM2EXCEPTION.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGM2EXCEPTION.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGM2EXCEPTION.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -56,13 +56,13 @@ extern \"C\" M2EXCEPTION_M2Exceptions M2EXCEPTION_M2Exception (void)\n   n = RTExceptions_GetNumber (e);\n   if (n == (UINT_MAX))\n     {\n-      RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_exException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/M2EXCEPTION.mod\")), 47, 6, const_cast<void*> (reinterpret_cast<const void*>(\"M2Exception\")), const_cast<void*> (reinterpret_cast<const void*>(\"current coroutine is not in the exceptional execution state\")));\n+      RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_exException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/M2EXCEPTION.mod\")), 47, 6, const_cast<void*> (reinterpret_cast<const void*>(\"M2Exception\")), const_cast<void*> (reinterpret_cast<const void*>(\"current coroutine is not in the exceptional execution state\")));\n     }\n   else\n     {\n       return (M2EXCEPTION_M2Exceptions) (n);\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/M2EXCEPTION.def\", 25, 1);\n+  ReturnException (\"../../gcc/m2/gm2-libs/M2EXCEPTION.def\", 25, 1);\n   __builtin_unreachable ();\n }\n \n@@ -83,6 +83,6 @@ extern \"C\" void _M2_M2EXCEPTION_init (__attribute__((unused)) int argc,__attribu\n   RTExceptions_SetExceptionBlock (RTExceptions_InitExceptionBlock ());\n }\n \n-extern \"C\" void _M2_M2EXCEPTION_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_M2EXCEPTION_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "c6eb399bba41b7b49de06fb3df7429f3a57c85f1", "filename": "gcc/m2/pge-boot/GM2RTS.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGM2RTS.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGM2RTS.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGM2RTS.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -99,29 +99,29 @@ static unsigned int Initialized;\n                       module constructor in turn.\n */\n \n-extern \"C\" void M2RTS_ConstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n+extern \"C\" void M2RTS_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n \n /*\n    DeconstructModules - resolve dependencies and then call each\n                         module constructor in turn.\n */\n \n-extern \"C\" void M2RTS_DeconstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n+extern \"C\" void M2RTS_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n \n /*\n    RegisterModule - adds module name to the list of outstanding\n                     modules which need to have their dependencies\n                     explored to determine initialization order.\n */\n \n-extern \"C\" void M2RTS_RegisterModule (void * name, M2RTS_ArgCVEnvP init, M2RTS_ArgCVEnvP fini, PROC dependencies);\n+extern \"C\" void M2RTS_RegisterModule (void * name, void * libname, M2RTS_ArgCVEnvP init, M2RTS_ArgCVEnvP fini, PROC dependencies);\n \n /*\n    RequestDependant - used to specify that modulename is dependant upon\n                       module dependantmodule.\n */\n \n-extern \"C\" void M2RTS_RequestDependant (void * modulename, void * dependantmodule);\n+extern \"C\" void M2RTS_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname);\n \n /*\n    InstallTerminationProcedure - installs a procedure, p, which will\n@@ -191,7 +191,7 @@ extern \"C\" void M2RTS_Halt (const char *filename_, unsigned int _filename_high,\n            to stderr and calls exit (1).\n */\n \n-extern \"C\" void M2RTS_HaltC (void * filename, unsigned int line, void * function, void * description);\n+extern \"C\" void M2RTS_HaltC (void * filename, unsigned int line, void * function, void * description) __attribute__ ((noreturn));\n \n /*\n    ExitOnHalt - if HALT is executed then call exit with the exit code, e.\n@@ -212,30 +212,30 @@ extern \"C\" void M2RTS_ErrorMessage (const char *message_, unsigned int _message_\n */\n \n extern \"C\" unsigned int M2RTS_Length (const char *a_, unsigned int _a_high);\n-extern \"C\" void M2RTS_AssignmentException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_ReturnException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_IncException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_DecException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_InclException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_ExclException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_ShiftException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_RotateException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_StaticArraySubscriptException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_DynamicArraySubscriptException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_ForLoopBeginException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_ForLoopToException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_ForLoopEndException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_PointerNilException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_NoReturnException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_CaseException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_WholeNonPosDivException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_WholeNonPosModException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_WholeZeroDivException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_WholeZeroRemException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_WholeValueException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_RealValueException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_ParameterException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-extern \"C\" void M2RTS_NoException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n+extern \"C\" void M2RTS_AssignmentException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_ReturnException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_IncException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_DecException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_InclException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_ExclException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_ShiftException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_RotateException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_StaticArraySubscriptException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_DynamicArraySubscriptException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_ForLoopBeginException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_ForLoopToException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_ForLoopEndException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_PointerNilException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_NoReturnException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_CaseException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_WholeNonPosDivException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_WholeNonPosModException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_WholeZeroDivException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_WholeZeroRemException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_WholeValueException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_RealValueException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_ParameterException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_NoException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n \n /*\n    ExecuteReverse - execute the procedure associated with procptr\n@@ -437,9 +437,9 @@ static void CheckInitialized (void)\n                       module constructor in turn.\n */\n \n-extern \"C\" void M2RTS_ConstructModules (void * applicationmodule, int argc, void * argv, void * envp)\n+extern \"C\" void M2RTS_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp)\n {\n-  M2Dependent_ConstructModules (applicationmodule, argc, argv, envp);\n+  M2Dependent_ConstructModules (applicationmodule, libname, argc, argv, envp);\n }\n \n \n@@ -448,9 +448,9 @@ extern \"C\" void M2RTS_ConstructModules (void * applicationmodule, int argc, void\n                         module constructor in turn.\n */\n \n-extern \"C\" void M2RTS_DeconstructModules (void * applicationmodule, int argc, void * argv, void * envp)\n+extern \"C\" void M2RTS_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp)\n {\n-  M2Dependent_DeconstructModules (applicationmodule, argc, argv, envp);\n+  M2Dependent_DeconstructModules (applicationmodule, libname, argc, argv, envp);\n }\n \n \n@@ -460,9 +460,9 @@ extern \"C\" void M2RTS_DeconstructModules (void * applicationmodule, int argc, vo\n                     explored to determine initialization order.\n */\n \n-extern \"C\" void M2RTS_RegisterModule (void * name, M2RTS_ArgCVEnvP init, M2RTS_ArgCVEnvP fini, PROC dependencies)\n+extern \"C\" void M2RTS_RegisterModule (void * name, void * libname, M2RTS_ArgCVEnvP init, M2RTS_ArgCVEnvP fini, PROC dependencies)\n {\n-  M2Dependent_RegisterModule (name, (M2Dependent_ArgCVEnvP) {(M2Dependent_ArgCVEnvP_t) init.proc}, (M2Dependent_ArgCVEnvP) {(M2Dependent_ArgCVEnvP_t) fini.proc}, dependencies);\n+  M2Dependent_RegisterModule (name, libname, (M2Dependent_ArgCVEnvP) {(M2Dependent_ArgCVEnvP_t) init.proc}, (M2Dependent_ArgCVEnvP) {(M2Dependent_ArgCVEnvP_t) fini.proc}, dependencies);\n }\n \n \n@@ -471,9 +471,9 @@ extern \"C\" void M2RTS_RegisterModule (void * name, M2RTS_ArgCVEnvP init, M2RTS_A\n                       module dependantmodule.\n */\n \n-extern \"C\" void M2RTS_RequestDependant (void * modulename, void * dependantmodule)\n+extern \"C\" void M2RTS_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname)\n {\n-  M2Dependent_RequestDependant (modulename, dependantmodule);\n+  M2Dependent_RequestDependant (modulename, libname, dependantmodule, dependantlibname);\n }\n \n \n@@ -817,6 +817,6 @@ extern \"C\" void _M2_M2RTS_init (__attribute__((unused)) int argc,__attribute__((\n   CheckInitialized ();\n }\n \n-extern \"C\" void _M2_M2RTS_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_M2RTS_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "37cbb1a13d74a8b024b718e4b3de3988307cd86e", "filename": "gcc/m2/pge-boot/GM2RTS.h", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGM2RTS.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGM2RTS.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGM2RTS.h?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -29,8 +29,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #if !defined (_M2RTS_H)\n #   define _M2RTS_H\n \n-#include \"config.h\"\n-#include \"system.h\"\n #   ifdef __cplusplus\n extern \"C\" {\n #   endif\n@@ -53,23 +51,23 @@ typedef struct M2RTS_ArgCVEnvP_p M2RTS_ArgCVEnvP;\n typedef void (*M2RTS_ArgCVEnvP_t) (int, void *, void *);\n struct M2RTS_ArgCVEnvP_p { M2RTS_ArgCVEnvP_t proc; };\n \n-EXTERN void M2RTS_ConstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n-EXTERN void M2RTS_DeconstructModules (void * applicationmodule, int argc, void * argv, void * envp);\n+EXTERN void M2RTS_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n+EXTERN void M2RTS_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n \n /*\n    RegisterModule - adds module name to the list of outstanding\n                     modules which need to have their dependencies\n                     explored to determine initialization order.\n */\n \n-EXTERN void M2RTS_RegisterModule (void * name, M2RTS_ArgCVEnvP init, M2RTS_ArgCVEnvP fini, PROC dependencies);\n+EXTERN void M2RTS_RegisterModule (void * name, void * libname, M2RTS_ArgCVEnvP init, M2RTS_ArgCVEnvP fini, PROC dependencies);\n \n /*\n    RequestDependant - used to specify that modulename is dependant upon\n                       module dependantmodule.\n */\n \n-EXTERN void M2RTS_RequestDependant (void * modulename, void * dependantmodule);\n+EXTERN void M2RTS_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname);\n \n /*\n    InstallTerminationProcedure - installs a procedure, p, which will\n@@ -126,10 +124,19 @@ EXTERN void M2RTS_HALT (int exitcode) __attribute__ ((noreturn));\n \n /*\n    Halt - provides a more user friendly version of HALT, which takes\n-          four parameters to aid debugging.\n+           four parameters to aid debugging.  It writes an error message\n+           to stderr and calls exit (1).\n */\n \n-EXTERN void M2RTS_Halt (const char *file_, unsigned int _file_high, unsigned int line, const char *function_, unsigned int _function_high, const char *description_, unsigned int _description_high) __attribute__ ((noreturn));\n+EXTERN void M2RTS_Halt (const char *filename_, unsigned int _filename_high, unsigned int line, const char *function_, unsigned int _function_high, const char *description_, unsigned int _description_high) __attribute__ ((noreturn));\n+\n+/*\n+   HaltC - provides a more user friendly version of HALT, which takes\n+           four parameters to aid debugging.  It writes an error message\n+           to stderr and calls exit (1).\n+*/\n+\n+EXTERN void M2RTS_HaltC (void * filename, unsigned int line, void * function, void * description) __attribute__ ((noreturn));\n \n /*\n    ExitOnHalt - if HALT is executed then call exit with the exit code, e.\n@@ -141,7 +148,7 @@ EXTERN void M2RTS_ExitOnHalt (int e);\n    ErrorMessage - emits an error message to stderr and then calls exit (1).\n */\n \n-EXTERN void M2RTS_ErrorMessage (const char *message_, unsigned int _message_high, const char *file_, unsigned int _file_high, unsigned int line, const char *function_, unsigned int _function_high) __attribute__ ((noreturn));\n+EXTERN void M2RTS_ErrorMessage (const char *message_, unsigned int _message_high, const char *filename_, unsigned int _filename_high, unsigned int line, const char *function_, unsigned int _function_high) __attribute__ ((noreturn));\n \n /*\n    Length - returns the length of a string, a. This is called whenever\n@@ -150,30 +157,30 @@ EXTERN void M2RTS_ErrorMessage (const char *message_, unsigned int _message_high\n */\n \n EXTERN unsigned int M2RTS_Length (const char *a_, unsigned int _a_high);\n-EXTERN void M2RTS_AssignmentException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_ReturnException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_IncException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_DecException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_InclException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_ExclException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_ShiftException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_RotateException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_StaticArraySubscriptException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_DynamicArraySubscriptException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_ForLoopBeginException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_ForLoopToException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_ForLoopEndException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_PointerNilException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_NoReturnException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_CaseException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_WholeNonPosDivException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_WholeNonPosModException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_WholeZeroDivException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_WholeZeroRemException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_WholeValueException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_RealValueException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_ParameterException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n-EXTERN void M2RTS_NoException (void * filename, unsigned int line, unsigned int column, void * scope, void * message);\n+EXTERN void M2RTS_AssignmentException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_ReturnException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_IncException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_DecException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_InclException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_ExclException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_ShiftException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_RotateException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_StaticArraySubscriptException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_DynamicArraySubscriptException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_ForLoopBeginException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_ForLoopToException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_ForLoopEndException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_PointerNilException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_NoReturnException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_CaseException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_WholeNonPosDivException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_WholeNonPosModException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_WholeZeroDivException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_WholeZeroRemException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_WholeValueException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_RealValueException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_ParameterException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+EXTERN void M2RTS_NoException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n #   ifdef __cplusplus\n }\n #   endif"}, {"sha": "37d8c961e498a2307caa9dabbf2cc00b3c9c8793", "filename": "gcc/m2/pge-boot/GNameKey.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGNameKey.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGNameKey.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGNameKey.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -330,7 +330,7 @@ extern \"C\" NameKey_Name NameKey_MakeKey (const char *a_, unsigned int _a_high)\n       (*p) = ASCII_nul;\n       return DoMakeKey (n, higha);\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-compiler/NameKey.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/gm2-compiler/NameKey.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -380,7 +380,7 @@ extern \"C\" NameKey_Name NameKey_makekey (void * a)\n           return DoMakeKey (n, higha);\n         }\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-compiler/NameKey.def\", 20, 1);\n+  ReturnException (\"../../gcc/m2/gm2-compiler/NameKey.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -607,6 +607,6 @@ extern \"C\" void _M2_NameKey_init (__attribute__((unused)) int argc,__attribute__\n   BinaryTree->Left = NULL;\n }\n \n-extern \"C\" void _M2_NameKey_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_NameKey_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "0e058df5d647a1219ee59b72dc5335020f365310", "filename": "gcc/m2/pge-boot/GNumberIO.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGNumberIO.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGNumberIO.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGNumberIO.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -772,6 +772,6 @@ extern \"C\" void _M2_NumberIO_init (__attribute__((unused)) int argc,__attribute_\n {\n }\n \n-extern \"C\" void _M2_NumberIO_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_NumberIO_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "22ec0e7b8cf72ca059d26f13f50a7999e805e0d5", "filename": "gcc/m2/pge-boot/GOutput.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGOutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGOutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGOutput.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -310,6 +310,6 @@ extern \"C\" void _M2_Output_init (__attribute__((unused)) int argc,__attribute__(\n   outputFile = FIO_StdOut;\n }\n \n-extern \"C\" void _M2_Output_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_Output_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "612e94a6b6ad1e778efb365a54601038ed655199", "filename": "gcc/m2/pge-boot/GPushBackInput.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGPushBackInput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGPushBackInput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGPushBackInput.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -275,7 +275,7 @@ extern \"C\" char PushBackInput_PutCh (char ch)\n     }\n   else\n     {\n-      Debug_Halt ((const char *) \"max push back stack exceeded, increase MaxPushBackStack\", 55, 150, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/PushBackInput.mod\", 54);\n+      Debug_Halt ((const char *) \"max push back stack exceeded, increase MaxPushBackStack\", 55, 150, (const char *) \"../../gcc/m2/gm2-libs/PushBackInput.mod\", 39);\n     }\n   return ch;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -301,7 +301,7 @@ extern \"C\" void PushBackInput_PutString (const char *a_, unsigned int _a_high)\n       l -= 1;\n       if ((PushBackInput_PutCh (a[l])) != a[l])\n         {\n-          Debug_Halt ((const char *) \"assert failed\", 13, 132, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/PushBackInput.mod\", 54);\n+          Debug_Halt ((const char *) \"assert failed\", 13, 132, (const char *) \"../../gcc/m2/gm2-libs/PushBackInput.mod\", 39);\n         }\n     }\n }\n@@ -322,7 +322,7 @@ extern \"C\" void PushBackInput_PutStr (DynamicStrings_String s)\n       i -= 1;\n       if ((PushBackInput_PutCh (DynamicStrings_char (s, static_cast<int> (i)))) != (DynamicStrings_char (s, static_cast<int> (i))))\n         {\n-          Debug_Halt ((const char *) \"assert failed\", 13, 113, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/PushBackInput.mod\", 54);\n+          Debug_Halt ((const char *) \"assert failed\", 13, 113, (const char *) \"../../gcc/m2/gm2-libs/PushBackInput.mod\", 39);\n         }\n     }\n }\n@@ -484,6 +484,6 @@ extern \"C\" void _M2_PushBackInput_init (__attribute__((unused)) int argc,__attri\n   Init ();\n }\n \n-extern \"C\" void _M2_PushBackInput_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_PushBackInput_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "8c2d35d8880ea829d02c11a231b5fe20c9386e04", "filename": "gcc/m2/pge-boot/GRTExceptions.c", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGRTExceptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGRTExceptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGRTExceptions.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -107,7 +107,7 @@ static void * currentSource;\n            and message in the EHBlock for later use.\n */\n \n-extern \"C\" void RTExceptions_Raise (unsigned int number, void * file, unsigned int line, unsigned int column, void * function, void * message);\n+extern \"C\" void RTExceptions_Raise (unsigned int number, void * file, unsigned int line, unsigned int column, void * function, void * message) __attribute__ ((noreturn));\n \n /*\n    SetExceptionBlock - sets, source, as the active EHB.\n@@ -242,7 +242,7 @@ static RTExceptions_Handler findHandler (RTExceptions_EHBlock e, unsigned int nu\n                    exception in the active EHB.\n */\n \n-static void InvokeHandler (void);\n+static void InvokeHandler (void) __attribute__ ((noreturn));\n \n /*\n    DoThrow - throw the exception number in the exception block.\n@@ -488,6 +488,8 @@ static void InvokeHandler (void)\n   else\n     {\n       (*h->p.proc) ();\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n     }\n }\n \n@@ -722,7 +724,7 @@ static void AddHandler (RTExceptions_EHBlock e, RTExceptions_Handler h)\n \n static void indexf (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_indexException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 612, 9, const_cast<void*> (reinterpret_cast<const void*>(\"indexf\")), const_cast<void*> (reinterpret_cast<const void*>(\"array index out of bounds\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_indexException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 613, 9, const_cast<void*> (reinterpret_cast<const void*>(\"indexf\")), const_cast<void*> (reinterpret_cast<const void*>(\"array index out of bounds\")));\n }\n \n \n@@ -732,7 +734,7 @@ static void indexf (void * a)\n \n static void range (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 624, 9, const_cast<void*> (reinterpret_cast<const void*>(\"range\")), const_cast<void*> (reinterpret_cast<const void*>(\"assignment out of range\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 625, 9, const_cast<void*> (reinterpret_cast<const void*>(\"range\")), const_cast<void*> (reinterpret_cast<const void*>(\"assignment out of range\")));\n }\n \n \n@@ -742,7 +744,7 @@ static void range (void * a)\n \n static void casef (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_caseSelectException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 636, 9, const_cast<void*> (reinterpret_cast<const void*>(\"casef\")), const_cast<void*> (reinterpret_cast<const void*>(\"case selector out of range\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_caseSelectException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 637, 9, const_cast<void*> (reinterpret_cast<const void*>(\"casef\")), const_cast<void*> (reinterpret_cast<const void*>(\"case selector out of range\")));\n }\n \n \n@@ -752,7 +754,7 @@ static void casef (void * a)\n \n static void invalidloc (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_invalidLocation)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 648, 9, const_cast<void*> (reinterpret_cast<const void*>(\"invalidloc\")), const_cast<void*> (reinterpret_cast<const void*>(\"invalid address referenced\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_invalidLocation)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 649, 9, const_cast<void*> (reinterpret_cast<const void*>(\"invalidloc\")), const_cast<void*> (reinterpret_cast<const void*>(\"invalid address referenced\")));\n }\n \n \n@@ -762,7 +764,7 @@ static void invalidloc (void * a)\n \n static void function (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_functionException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 660, 9, const_cast<void*> (reinterpret_cast<const void*>(\"function\")), const_cast<void*> (reinterpret_cast<const void*>(\"... function ... \")));  /* --fixme-- what has happened ?  */\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_functionException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 661, 9, const_cast<void*> (reinterpret_cast<const void*>(\"function\")), const_cast<void*> (reinterpret_cast<const void*>(\"... function ... \")));  /* --fixme-- what has happened ?  */\n }\n \n \n@@ -772,7 +774,7 @@ static void function (void * a)\n \n static void wholevalue (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 672, 9, const_cast<void*> (reinterpret_cast<const void*>(\"wholevalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal whole value exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 673, 9, const_cast<void*> (reinterpret_cast<const void*>(\"wholevalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal whole value exception\")));\n }\n \n \n@@ -782,7 +784,7 @@ static void wholevalue (void * a)\n \n static void wholediv (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 684, 9, const_cast<void*> (reinterpret_cast<const void*>(\"wholediv\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal whole value exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 685, 9, const_cast<void*> (reinterpret_cast<const void*>(\"wholediv\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal whole value exception\")));\n }\n \n \n@@ -792,7 +794,7 @@ static void wholediv (void * a)\n \n static void realvalue (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_realValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 696, 9, const_cast<void*> (reinterpret_cast<const void*>(\"realvalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal real value exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_realValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 697, 9, const_cast<void*> (reinterpret_cast<const void*>(\"realvalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal real value exception\")));\n }\n \n \n@@ -802,7 +804,7 @@ static void realvalue (void * a)\n \n static void realdiv (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_realDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 708, 9, const_cast<void*> (reinterpret_cast<const void*>(\"realdiv\")), const_cast<void*> (reinterpret_cast<const void*>(\"real number division by zero exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_realDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 709, 9, const_cast<void*> (reinterpret_cast<const void*>(\"realdiv\")), const_cast<void*> (reinterpret_cast<const void*>(\"real number division by zero exception\")));\n }\n \n \n@@ -812,7 +814,7 @@ static void realdiv (void * a)\n \n static void complexvalue (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_complexValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 720, 9, const_cast<void*> (reinterpret_cast<const void*>(\"complexvalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal complex value exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_complexValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 721, 9, const_cast<void*> (reinterpret_cast<const void*>(\"complexvalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal complex value exception\")));\n }\n \n \n@@ -822,7 +824,7 @@ static void complexvalue (void * a)\n \n static void complexdiv (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_complexDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 732, 9, const_cast<void*> (reinterpret_cast<const void*>(\"complexdiv\")), const_cast<void*> (reinterpret_cast<const void*>(\"complex number division by zero exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_complexDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 733, 9, const_cast<void*> (reinterpret_cast<const void*>(\"complexdiv\")), const_cast<void*> (reinterpret_cast<const void*>(\"complex number division by zero exception\")));\n }\n \n \n@@ -832,7 +834,7 @@ static void complexdiv (void * a)\n \n static void protection (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_protException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 744, 9, const_cast<void*> (reinterpret_cast<const void*>(\"protection\")), const_cast<void*> (reinterpret_cast<const void*>(\"protection exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_protException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 745, 9, const_cast<void*> (reinterpret_cast<const void*>(\"protection\")), const_cast<void*> (reinterpret_cast<const void*>(\"protection exception\")));\n }\n \n \n@@ -842,7 +844,7 @@ static void protection (void * a)\n \n static void systemf (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_sysException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 756, 9, const_cast<void*> (reinterpret_cast<const void*>(\"systemf\")), const_cast<void*> (reinterpret_cast<const void*>(\"system exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_sysException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 757, 9, const_cast<void*> (reinterpret_cast<const void*>(\"systemf\")), const_cast<void*> (reinterpret_cast<const void*>(\"system exception\")));\n }\n \n \n@@ -852,7 +854,7 @@ static void systemf (void * a)\n \n static void coroutine (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_coException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 768, 9, const_cast<void*> (reinterpret_cast<const void*>(\"coroutine\")), const_cast<void*> (reinterpret_cast<const void*>(\"coroutine exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_coException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 769, 9, const_cast<void*> (reinterpret_cast<const void*>(\"coroutine\")), const_cast<void*> (reinterpret_cast<const void*>(\"coroutine exception\")));\n }\n \n \n@@ -862,7 +864,7 @@ static void coroutine (void * a)\n \n static void exception (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_exException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 780, 9, const_cast<void*> (reinterpret_cast<const void*>(\"exception\")), const_cast<void*> (reinterpret_cast<const void*>(\"exception exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_exException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc/m2/gm2-libs/RTExceptions.mod\")), 781, 9, const_cast<void*> (reinterpret_cast<const void*>(\"exception\")), const_cast<void*> (reinterpret_cast<const void*>(\"exception exception\")));\n }\n \n \n@@ -1181,13 +1183,13 @@ extern \"C\" RTExceptions_EHBlock RTExceptions_GetBaseExceptionBlock (void)\n {\n   if (currentEHB == NULL)\n     {\n-      M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\", 53, 598, (const char *) \"GetBaseExceptionBlock\", 21, (const char *) \"currentEHB has not been initialized yet\", 39);\n+      M2RTS_Halt ((const char *) \"../../gcc/m2/gm2-libs/RTExceptions.mod\", 38, 599, (const char *) \"GetBaseExceptionBlock\", 21, (const char *) \"currentEHB has not been initialized yet\", 39);\n     }\n   else\n     {\n       return currentEHB;\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.def\", 25, 1);\n+  ReturnException (\"../../gcc/m2/gm2-libs/RTExceptions.def\", 25, 1);\n   __builtin_unreachable ();\n }\n \n@@ -1218,7 +1220,7 @@ extern \"C\" void _M2_RTExceptions_init (__attribute__((unused)) int argc,__attrib\n   Init ();\n }\n \n-extern \"C\" void _M2_RTExceptions_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_RTExceptions_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n   TidyUp ();\n }"}, {"sha": "4ecfec8e9d2e2a578f5559dbee3c41edc8331b6b", "filename": "gcc/m2/pge-boot/GSFIO.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGSFIO.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGSFIO.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGSFIO.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -210,6 +210,6 @@ extern \"C\" void _M2_SFIO_init (__attribute__((unused)) int argc,__attribute__((u\n {\n }\n \n-extern \"C\" void _M2_SFIO_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_SFIO_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "8b551aa5b970732a176a20c552add3aa979bee66", "filename": "gcc/m2/pge-boot/GStdIO.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGStdIO.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGStdIO.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGStdIO.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -191,7 +191,7 @@ extern \"C\" StdIO_ProcWrite StdIO_GetCurrentOutput (void)\n       M2RTS_HALT (-1);\n       __builtin_unreachable ();\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/StdIO.def\", 25, 1);\n+  ReturnException (\"../../gcc/m2/gm2-libs/StdIO.def\", 25, 1);\n   __builtin_unreachable ();\n }\n \n@@ -250,7 +250,7 @@ extern \"C\" StdIO_ProcRead StdIO_GetCurrentInput (void)\n       M2RTS_HALT (-1);\n       __builtin_unreachable ();\n     }\n-  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/StdIO.def\", 25, 1);\n+  ReturnException (\"../../gcc/m2/gm2-libs/StdIO.def\", 25, 1);\n   __builtin_unreachable ();\n }\n \n@@ -262,6 +262,6 @@ extern \"C\" void _M2_StdIO_init (__attribute__((unused)) int argc,__attribute__((\n   StdIO_PushInput ((StdIO_ProcRead) {(StdIO_ProcRead_t) IO_Read});\n }\n \n-extern \"C\" void _M2_StdIO_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_StdIO_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "d3b8776d5250ef63e7f91bcad6c6bf8d005751d4", "filename": "gcc/m2/pge-boot/GStorage.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGStorage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGStorage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGStorage.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -67,6 +67,6 @@ extern \"C\" void _M2_Storage_init (__attribute__((unused)) int argc,__attribute__\n {\n }\n \n-extern \"C\" void _M2_Storage_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_Storage_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "0e6b5bee012c60ed83e8b8f5b2f21eba3317f58a", "filename": "gcc/m2/pge-boot/GStrCase.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGStrCase.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGStrCase.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGStrCase.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -170,6 +170,6 @@ extern \"C\" void _M2_StrCase_init (__attribute__((unused)) int argc,__attribute__\n {\n }\n \n-extern \"C\" void _M2_StrCase_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_StrCase_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "b8c42ac162a368014684268569fa71609e49adfa", "filename": "gcc/m2/pge-boot/GStrIO.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGStrIO.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGStrIO.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGStrIO.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -272,6 +272,6 @@ extern \"C\" void _M2_StrIO_init (__attribute__((unused)) int argc,__attribute__((\n   IsATTY = FALSE;\n }\n \n-extern \"C\" void _M2_StrIO_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_StrIO_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "d5ae7249d893f68ece73559beb275c95d0f685a8", "filename": "gcc/m2/pge-boot/GStrLib.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGStrLib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGStrLib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGStrLib.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -341,6 +341,6 @@ extern \"C\" void _M2_StrLib_init (__attribute__((unused)) int argc,__attribute__(\n {\n }\n \n-extern \"C\" void _M2_StrLib_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_StrLib_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "51df5fce89ddd06d7edcc9ef4f9efa607c09a26c", "filename": "gcc/m2/pge-boot/GSymbolKey.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGSymbolKey.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGSymbolKey.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGSymbolKey.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -183,7 +183,7 @@ static void FindNodeParentInTree (SymbolKey_SymbolTree t, NameKey_Name n, Symbol\n   (*parent) = t;\n   if (t == NULL)\n     {\n-      Debug_Halt ((const char *) \"parameter t should never be NIL\", 31, 240, (const char *) \"../../gcc-read-write/gcc/m2/gm2-compiler/SymbolKey.mod\", 54);\n+      Debug_Halt ((const char *) \"parameter t should never be NIL\", 31, 240, (const char *) \"../../gcc/m2/gm2-compiler/SymbolKey.mod\", 39);\n     }\n   Assertion_Assert (t->Right == NULL);\n   (*child) = t->Left;\n@@ -392,7 +392,7 @@ extern \"C\" void SymbolKey_PutSymKey (SymbolKey_SymbolTree t, NameKey_Name NameKe\n     }\n   else\n     {\n-      Debug_Halt ((const char *) \"symbol already stored\", 21, 156, (const char *) \"../../gcc-read-write/gcc/m2/gm2-compiler/SymbolKey.mod\", 54);\n+      Debug_Halt ((const char *) \"symbol already stored\", 21, 156, (const char *) \"../../gcc/m2/gm2-compiler/SymbolKey.mod\", 39);\n     }\n }\n \n@@ -459,7 +459,7 @@ extern \"C\" void SymbolKey_DelSymKey (SymbolKey_SymbolTree t, NameKey_Name NameKe\n     }\n   else\n     {\n-      Debug_Halt ((const char *) \"trying to delete a symbol that is not in the tree - the compiler never expects this to occur\", 92, 223, (const char *) \"../../gcc-read-write/gcc/m2/gm2-compiler/SymbolKey.mod\", 54);\n+      Debug_Halt ((const char *) \"trying to delete a symbol that is not in the tree - the compiler never expects this to occur\", 92, 223, (const char *) \"../../gcc/m2/gm2-compiler/SymbolKey.mod\", 39);\n     }\n }\n \n@@ -551,6 +551,6 @@ extern \"C\" void _M2_SymbolKey_init (__attribute__((unused)) int argc,__attribute\n {\n }\n \n-extern \"C\" void _M2_SymbolKey_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_SymbolKey_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "4e600565fe8799ce8ab8ee251d706ababa42eef1", "filename": "gcc/m2/pge-boot/GSysExceptions.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGSysExceptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGSysExceptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGSysExceptions.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -232,6 +232,6 @@ _M2_SysExceptions_init (void)\n \n EXTERN\n void\n-_M2_SysExceptions_finish (void)\n+_M2_SysExceptions_fini (void)\n {\n }"}, {"sha": "e008d91d0e84476290acbc7a231a94b1a8bda857", "filename": "gcc/m2/pge-boot/GSysStorage.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGSysStorage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGSysStorage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGSysStorage.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -93,7 +93,7 @@ extern \"C\" void SysStorage_ALLOCATE (void * *a, unsigned int size)\n   (*a) = libc_malloc (static_cast<size_t> (size));\n   if ((*a) == NULL)\n     {\n-      Debug_Halt ((const char *) \"out of memory error\", 19, 50, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/SysStorage.mod\", 51);\n+      Debug_Halt ((const char *) \"out of memory error\", 19, 50, (const char *) \"../../gcc/m2/gm2-libs/SysStorage.mod\", 36);\n     }\n   if (enableTrace && trace)\n     {\n@@ -118,7 +118,7 @@ extern \"C\" void SysStorage_DEALLOCATE (void * *a, unsigned int size)\n         }\n       if ((libc_memset ((*a), 0, static_cast<size_t> (size))) != (*a))\n         {\n-          Debug_Halt ((const char *) \"memset should have returned the first parameter\", 47, 76, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/SysStorage.mod\", 51);\n+          Debug_Halt ((const char *) \"memset should have returned the first parameter\", 47, 76, (const char *) \"../../gcc/m2/gm2-libs/SysStorage.mod\", 36);\n         }\n     }\n   if (enableDeallocation)\n@@ -163,7 +163,7 @@ extern \"C\" void SysStorage_REALLOCATE (void * *a, unsigned int size)\n       (*a) = libc_realloc ((*a), static_cast<size_t> (size));\n       if ((*a) == NULL)\n         {\n-          Debug_Halt ((const char *) \"out of memory error\", 19, 119, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/SysStorage.mod\", 51);\n+          Debug_Halt ((const char *) \"out of memory error\", 19, 119, (const char *) \"../../gcc/m2/gm2-libs/SysStorage.mod\", 36);\n         }\n       if (enableTrace && trace)\n         {\n@@ -244,6 +244,6 @@ extern \"C\" void _M2_SysStorage_init (__attribute__((unused)) int argc,__attribut\n     }\n }\n \n-extern \"C\" void _M2_SysStorage_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_SysStorage_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "29b8ec273232316ed9b5622c9963fc94053ba94f", "filename": "gcc/m2/pge-boot/GUnixArgs.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGUnixArgs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGUnixArgs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGUnixArgs.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -73,7 +73,7 @@ _M2_UnixArgs_init (int argc, char *argv[], char *envp[])\n }\n \n extern \"C\" void\n-_M2_UnixArgs_finish (int argc, char *argv[], char *envp[])\n+_M2_UnixArgs_fini (int argc, char *argv[], char *envp[])\n {\n }\n \n@@ -86,6 +86,6 @@ struct _M2_UnixArgs_ctor { _M2_UnixArgs_ctor (); } _M2_UnixArgs_ctor;\n \n _M2_UnixArgs_ctor::_M2_UnixArgs_ctor (void)\n {\n-  M2RTS_RegisterModule (\"UnixArgs\", _M2_UnixArgs_init, _M2_UnixArgs_finish,\n+  M2RTS_RegisterModule (\"UnixArgs\", _M2_UnixArgs_init, _M2_UnixArgs_fini,\n \t\t\t_M2_UnixArgs_dep);\n }"}, {"sha": "7f78b5d250baeee2b62f8fa2b029ef7d502fd716", "filename": "gcc/m2/pge-boot/Gbnflex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGbnflex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGbnflex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGbnflex.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -597,6 +597,6 @@ extern \"C\" void _M2_bnflex_init (__attribute__((unused)) int argc,__attribute__(\n   Init ();\n }\n \n-extern \"C\" void _M2_bnflex_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_bnflex_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "c65c48630afce3e388aab42999dacef69c833094", "filename": "gcc/m2/pge-boot/Gerrno.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGerrno.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGerrno.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGerrno.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -45,7 +45,7 @@ _M2_errno_init (int argc, char *p)\n /* finish deconstructor for the module.  */\n \n void\n-_M2_errno_finish (int argc, char *p)\n+_M2_errno_fini (int argc, char *p)\n {\n }\n "}, {"sha": "e9395651e90815e75cb5d78f3aec84f1b9b261a2", "filename": "gcc/m2/pge-boot/Glibc.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGlibc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGlibc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGlibc.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -115,6 +115,43 @@ libc_printf (char *_format, unsigned int _format_high, ...)\n   return done;\n }\n \n+EXTERN\n+int\n+libc_snprintf (char *dest, size_t length, char *_format, unsigned int _format_high, ...)\n+{\n+  va_list arg;\n+  int done;\n+  char format[_format_high + 1];\n+  unsigned int i = 0;\n+  unsigned int j = 0;\n+  char *c;\n+\n+  do\n+    {\n+      c = index (&_format[i], '\\\\');\n+      if (c == NULL)\n+        strcpy (&format[j], &_format[i]);\n+      else\n+        {\n+          memcpy (&format[j], &_format[i], (c - _format) - i);\n+          i = c - _format;\n+          j += c - _format;\n+          if (_format[i + 1] == 'n')\n+            format[j] = '\\n';\n+          else\n+            format[j] = _format[i + 1];\n+          j++;\n+          i += 2;\n+        }\n+    }\n+  while (c != NULL);\n+\n+  va_start (arg, _format_high);\n+  done = vsnprintf (dest, length, format, arg);\n+  va_end (arg);\n+  return done;\n+}\n+\n EXTERN\n void *\n libc_malloc (unsigned int size)"}, {"sha": "f4e769187d3ba73dd332af0e8e173e81f6fe1289", "filename": "gcc/m2/pge-boot/Glibc.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGlibc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGlibc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGlibc.h?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -305,6 +305,7 @@ EXTERN void * libc_memset (void * s, int c, size_t size);\n \n EXTERN void * libc_memmove (void * dest, void * src, size_t size);\n EXTERN int libc_printf (const char *format_, unsigned int _format_high, ...);\n+EXTERN int libc_snprintf (void *dest, size_t length, const char *format_, unsigned int _format_high, ...);\n \n /*\n    setenv - sets environment variable, name, to value."}, {"sha": "e889236b9483de2c64d7a3a8dd1f85d73499829b", "filename": "gcc/m2/pge-boot/Gpge.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGpge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGpge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGpge.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -9748,6 +9748,6 @@ extern \"C\" void _M2_pge_init (__attribute__((unused)) int argc,__attribute__((un\n   Init ();\n }\n \n-extern \"C\" void _M2_pge_finish (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+extern \"C\" void _M2_pge_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n {\n }"}, {"sha": "5660f97b62f07bf7910584efdd7797223913c3d0", "filename": "gcc/m2/pge-boot/Gtermios.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGtermios.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2FGtermios.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGtermios.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -1938,7 +1938,7 @@ _M2_termios_init (void)\n }\n \n void\n-_M2_termios_finish (void)\n+_M2_termios_fini (void)\n {\n }\n "}, {"sha": "b6f29f628f740e8d25a5dfa531c12a686d9bd09d", "filename": "gcc/m2/pge-boot/main.c", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2Fmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fpge-boot%2Fmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2Fmain.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -1,61 +1,61 @@\n extern \"C\" void _M2_RTExceptions_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_RTExceptions_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_RTExceptions_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_M2EXCEPTION_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_M2EXCEPTION_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_M2EXCEPTION_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_M2RTS_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_M2RTS_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_M2RTS_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_SysExceptions_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_SysExceptions_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_SysExceptions_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_StrLib_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_StrLib_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_StrLib_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_errno_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_errno_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_errno_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_termios_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_termios_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_termios_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_IO_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_IO_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_IO_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_StdIO_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_StdIO_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_StdIO_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_Debug_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_Debug_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_Debug_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_SysStorage_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_SysStorage_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_SysStorage_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_Storage_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_Storage_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_Storage_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_StrIO_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_StrIO_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_StrIO_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_DynamicStrings_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_DynamicStrings_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_DynamicStrings_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_Assertion_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_Assertion_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_Assertion_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_Indexing_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_Indexing_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_Indexing_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_NameKey_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_NameKey_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_NameKey_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_NumberIO_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_NumberIO_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_NumberIO_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_PushBackInput_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_PushBackInput_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_PushBackInput_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_SymbolKey_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_SymbolKey_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_SymbolKey_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_UnixArgs_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_UnixArgs_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_UnixArgs_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_FIO_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_FIO_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_FIO_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_SFIO_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_SFIO_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_SFIO_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_StrCase_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_StrCase_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_StrCase_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_bnflex_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_bnflex_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_bnflex_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_Lists_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_Lists_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_Lists_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_Args_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_Args_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_Args_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_Output_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_Output_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_Output_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _M2_pge_init (int argc, char *argv[], char *envp[]);\n-extern \"C\" void _M2_pge_finish (int argc, char *argv[], char *envp[]);\n+extern \"C\" void _M2_pge_fini (int argc, char *argv[], char *envp[]);\n extern \"C\" void _exit(int);\n \n \n@@ -90,34 +90,34 @@ int main(int argc, char *argv[], char *envp[])\n    _M2_Args_init (argc, argv, envp);\n    _M2_Output_init (argc, argv, envp);\n    _M2_pge_init (argc, argv, envp);\n-   _M2_pge_finish (argc, argv, envp);\n-   _M2_Output_finish (argc, argv, envp);\n-   _M2_Args_finish (argc, argv, envp);\n-   _M2_Lists_finish (argc, argv, envp);\n-   _M2_bnflex_finish (argc, argv, envp);\n-   _M2_StrCase_finish (argc, argv, envp);\n-   _M2_SFIO_finish (argc, argv, envp);\n-   _M2_FIO_finish (argc, argv, envp);\n-   _M2_UnixArgs_finish (argc, argv, envp);\n-   _M2_SymbolKey_finish (argc, argv, envp);\n-   _M2_PushBackInput_finish (argc, argv, envp);\n-   _M2_NumberIO_finish (argc, argv, envp);\n-   _M2_NameKey_finish (argc, argv, envp);\n-   _M2_Indexing_finish (argc, argv, envp);\n-   _M2_Assertion_finish (argc, argv, envp);\n-   _M2_DynamicStrings_finish (argc, argv, envp);\n-   _M2_StrIO_finish (argc, argv, envp);\n-   _M2_Storage_finish (argc, argv, envp);\n-   _M2_SysStorage_finish (argc, argv, envp);\n-   _M2_Debug_finish (argc, argv, envp);\n-   _M2_StdIO_finish (argc, argv, envp);\n-   _M2_IO_finish (argc, argv, envp);\n-   _M2_termios_finish (argc, argv, envp);\n-   _M2_errno_finish (argc, argv, envp);\n-   _M2_StrLib_finish (argc, argv, envp);\n-   _M2_SysExceptions_finish (argc, argv, envp);\n-   _M2_M2RTS_finish (argc, argv, envp);\n-   _M2_M2EXCEPTION_finish (argc, argv, envp);\n-   _M2_RTExceptions_finish (argc, argv, envp);\n+   _M2_pge_fini (argc, argv, envp);\n+   _M2_Output_fini (argc, argv, envp);\n+   _M2_Args_fini (argc, argv, envp);\n+   _M2_Lists_fini (argc, argv, envp);\n+   _M2_bnflex_fini (argc, argv, envp);\n+   _M2_StrCase_fini (argc, argv, envp);\n+   _M2_SFIO_fini (argc, argv, envp);\n+   _M2_FIO_fini (argc, argv, envp);\n+   _M2_UnixArgs_fini (argc, argv, envp);\n+   _M2_SymbolKey_fini (argc, argv, envp);\n+   _M2_PushBackInput_fini (argc, argv, envp);\n+   _M2_NumberIO_fini (argc, argv, envp);\n+   _M2_NameKey_fini (argc, argv, envp);\n+   _M2_Indexing_fini (argc, argv, envp);\n+   _M2_Assertion_fini (argc, argv, envp);\n+   _M2_DynamicStrings_fini (argc, argv, envp);\n+   _M2_StrIO_fini (argc, argv, envp);\n+   _M2_Storage_fini (argc, argv, envp);\n+   _M2_SysStorage_fini (argc, argv, envp);\n+   _M2_Debug_fini (argc, argv, envp);\n+   _M2_StdIO_fini (argc, argv, envp);\n+   _M2_IO_fini (argc, argv, envp);\n+   _M2_termios_fini (argc, argv, envp);\n+   _M2_errno_fini (argc, argv, envp);\n+   _M2_StrLib_fini (argc, argv, envp);\n+   _M2_SysExceptions_fini (argc, argv, envp);\n+   _M2_M2RTS_fini (argc, argv, envp);\n+   _M2_M2EXCEPTION_fini (argc, argv, envp);\n+   _M2_RTExceptions_fini (argc, argv, envp);\n    return(0);\n }"}, {"sha": "dcb9c6de42cc65a03ebc5eed22c2838a915f353d", "filename": "gcc/m2/plugin/m2rte.cc", "status": "modified", "additions": 49, "deletions": 24, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fplugin%2Fm2rte.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Fm2%2Fplugin%2Fm2rte.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fplugin%2Fm2rte.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -55,30 +55,55 @@ void debug_tree (tree);\n    basic block of a reachable function.  */\n \n static const char *m2_runtime_error_calls[] = {\n-  \"M2RTS_AssignmentException\",\n-  \"M2RTS_ReturnException\",\n-  \"M2RTS_IncException\",\n-  \"M2RTS_DecException\",\n-  \"M2RTS_InclException\",\n-  \"M2RTS_ExclException\",\n-  \"M2RTS_ShiftException\",\n-  \"M2RTS_RotateException\",\n-  \"M2RTS_StaticArraySubscriptException\",\n-  \"M2RTS_DynamicArraySubscriptException\",\n-  \"M2RTS_ForLoopBeginException\",\n-  \"M2RTS_ForLoopToException\",\n-  \"M2RTS_ForLoopEndException\",\n-  \"M2RTS_PointerNilException\",\n-  \"M2RTS_NoReturnException\",\n-  \"M2RTS_CaseException\",\n-  \"M2RTS_WholeNonPosDivException\",\n-  \"M2RTS_WholeNonPosModException\",\n-  \"M2RTS_WholeZeroDivException\",\n-  \"M2RTS_WholeZeroRemException\",\n-  \"M2RTS_WholeValueException\",\n-  \"M2RTS_RealValueException\",\n-  \"M2RTS_ParameterException\",\n-  \"M2RTS_NoException\",\n+  \"m2pim_M2RTS_AssignmentException\",\n+  \"m2pim_M2RTS_ReturnException\",\n+  \"m2pim_M2RTS_IncException\",\n+  \"m2pim_M2RTS_DecException\",\n+  \"m2pim_M2RTS_InclException\",\n+  \"m2pim_M2RTS_ExclException\",\n+  \"m2pim_M2RTS_ShiftException\",\n+  \"m2pim_M2RTS_RotateException\",\n+  \"m2pim_M2RTS_StaticArraySubscriptException\",\n+  \"m2pim_M2RTS_DynamicArraySubscriptException\",\n+  \"m2pim_M2RTS_ForLoopBeginException\",\n+  \"m2pim_M2RTS_ForLoopToException\",\n+  \"m2pim_M2RTS_ForLoopEndException\",\n+  \"m2pim_M2RTS_PointerNilException\",\n+  \"m2pim_M2RTS_NoReturnException\",\n+  \"m2pim_M2RTS_CaseException\",\n+  \"m2pim_M2RTS_WholeNonPosDivException\",\n+  \"m2pim_M2RTS_WholeNonPosModException\",\n+  \"m2pim_M2RTS_WholeZeroDivException\",\n+  \"m2pim_M2RTS_WholeZeroRemException\",\n+  \"m2pim_M2RTS_WholeValueException\",\n+  \"m2pim_M2RTS_RealValueException\",\n+  \"m2pim_M2RTS_ParameterException\",\n+  \"m2pim_M2RTS_NoException\",\n+\n+  \"m2iso_M2RTS_AssignmentException\",\n+  \"m2iso_M2RTS_ReturnException\",\n+  \"m2iso_M2RTS_IncException\",\n+  \"m2iso_M2RTS_DecException\",\n+  \"m2iso_M2RTS_InclException\",\n+  \"m2iso_M2RTS_ExclException\",\n+  \"m2iso_M2RTS_ShiftException\",\n+  \"m2iso_M2RTS_RotateException\",\n+  \"m2iso_M2RTS_StaticArraySubscriptException\",\n+  \"m2iso_M2RTS_DynamicArraySubscriptException\",\n+  \"m2iso_M2RTS_ForLoopBeginException\",\n+  \"m2iso_M2RTS_ForLoopToException\",\n+  \"m2iso_M2RTS_ForLoopEndException\",\n+  \"m2iso_M2RTS_PointerNilException\",\n+  \"m2iso_M2RTS_NoReturnException\",\n+  \"m2iso_M2RTS_CaseException\",\n+  \"m2iso_M2RTS_WholeNonPosDivException\",\n+  \"m2iso_M2RTS_WholeNonPosModException\",\n+  \"m2iso_M2RTS_WholeZeroDivException\",\n+  \"m2iso_M2RTS_WholeZeroRemException\",\n+  \"m2iso_M2RTS_WholeValueException\",\n+  \"m2iso_M2RTS_RealValueException\",\n+  \"m2iso_M2RTS_ParameterException\",\n+  \"m2iso_M2RTS_NoException\",\n   NULL,\n };\n "}, {"sha": "9e2e9f46f93c26bf1f9d92162f9f1e6f5dcc9a7d", "filename": "gcc/testsuite/gm2/examples/callingC/pass/examples-callingC-pass.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fexamples%2FcallingC%2Fpass%2Fexamples-callingC-pass.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fexamples%2FcallingC%2Fpass%2Fexamples-callingC-pass.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fexamples%2FcallingC%2Fpass%2Fexamples-callingC-pass.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -25,7 +25,7 @@ if $tracelevel then {\n # load support procs\n load_lib gm2-torture.exp\n \n-gm2_init_pim \"$srcdir/$subdir\"\n+gm2_init_pim \"${srcdir}/${subdir}\"\n \n foreach testcase [lsort [glob -nocomplain $srcdir/$subdir/*.mod]] {\n     # If we're only testing specific files and this isn't one of them, skip it."}, {"sha": "0b5dea9355e3716a5841c47d0c84d3a16a482f00", "filename": "gcc/testsuite/gm2/examples/callingC/run/pass/examples-callingC-run-pass.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fexamples%2FcallingC%2Frun%2Fpass%2Fexamples-callingC-run-pass.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fexamples%2FcallingC%2Frun%2Fpass%2Fexamples-callingC-run-pass.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fexamples%2FcallingC%2Frun%2Fpass%2Fexamples-callingC-run-pass.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -27,7 +27,7 @@ load_lib gm2-torture.exp\n \n set gm2src ${srcdir}/../m2\n \n-gm2_init_iso \"$srcdir/$subdir\"\n+gm2_init_iso \"${srcdir}/${subdir}\"\n gm2_link_obj \"c.o\"\n \n set output [target_compile $srcdir/$subdir/c.c c.o object \"-g\"]"}, {"sha": "3f3c0c5a85c541480e516aa107b44b89177e69e6", "filename": "gcc/testsuite/gm2/examples/cpp/pass/examples-cpp-pass.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fexamples%2Fcpp%2Fpass%2Fexamples-cpp-pass.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fexamples%2Fcpp%2Fpass%2Fexamples-cpp-pass.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fexamples%2Fcpp%2Fpass%2Fexamples-cpp-pass.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -25,7 +25,7 @@ if $tracelevel then {\n # load support procs\n load_lib gm2-torture.exp\n \n-gm2_init_pim \"$srcdir/$subdir/\" -fcpp\n+gm2_init_pim \"${srcdir}/${subdir}/\" -fcpp\n \n foreach testcase [lsort [glob -nocomplain $srcdir/$subdir/*.mod]] {\n     # If we're only testing specific files and this isn't one of them, skip it."}, {"sha": "d4b3c62a71b94598420903163e3f93bf4bc7ab11", "filename": "gcc/testsuite/gm2/examples/cppDef/pass/examples-cppDef-pass.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fexamples%2FcppDef%2Fpass%2Fexamples-cppDef-pass.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fexamples%2FcppDef%2Fpass%2Fexamples-cppDef-pass.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fexamples%2FcppDef%2Fpass%2Fexamples-cppDef-pass.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -25,7 +25,7 @@ if $tracelevel then {\n # load support procs\n load_lib gm2-torture.exp\n \n-gm2_init_pim \"$srcdir/$subdir/\" -DVALUE=999 -fcpp\n+gm2_init_pim \"${srcdir}/${subdir}/\" -DVALUE=999 -fcpp\n \n foreach testcase [lsort [glob -nocomplain $srcdir/$subdir/*.mod]] {\n     # If we're only testing specific files and this isn't one of them, skip it."}, {"sha": "449c19e04c4b6dab434ffeb886c4e7dc78e62eb9", "filename": "gcc/testsuite/gm2/examples/hello/pass/examples-hello-pass.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fexamples%2Fhello%2Fpass%2Fexamples-hello-pass.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fexamples%2Fhello%2Fpass%2Fexamples-hello-pass.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fexamples%2Fhello%2Fpass%2Fexamples-hello-pass.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -25,7 +25,7 @@ if $tracelevel then {\n # load support procs\n load_lib gm2-torture.exp\n \n-gm2_init_pim \"$srcdir/$subdir\"\n+gm2_init_pim \"${srcdir}/${subdir}\"\n \n foreach testcase [lsort [glob -nocomplain $srcdir/$subdir/*.mod]] {\n     # If we're only testing specific files and this isn't one of them, skip it."}, {"sha": "ae29ed7c2a5fad9987a79a014819be45f9b7edd7", "filename": "gcc/testsuite/gm2/examples/map/pass/examples-map-pass.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fexamples%2Fmap%2Fpass%2Fexamples-map-pass.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fexamples%2Fmap%2Fpass%2Fexamples-map-pass.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fexamples%2Fmap%2Fpass%2Fexamples-map-pass.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -25,7 +25,7 @@ if $tracelevel then {\n # load support procs\n load_lib gm2-torture.exp\n \n-gm2_init_pim \"$srcdir/$subdir\"\n+gm2_init_pim \"${srcdir}/${subdir}\"\n \n # We should be able to compile, link or run in 30 seconds.\n gm2_push_timeout 30"}, {"sha": "836760d6c6667b76a9c706751af631599c79749b", "filename": "gcc/testsuite/gm2/iso/check/fail/iso-check-fail.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fiso%2Fcheck%2Ffail%2Fiso-check-fail.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fiso%2Fcheck%2Ffail%2Fiso-check-fail.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fiso%2Fcheck%2Ffail%2Fiso-check-fail.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -44,7 +44,7 @@ set TORTURE_OPTIONS [list \\\n \t\t\t { -O3 -fsoft-check-all } \\\n \t\t         { -O3 -g -fsoft-check-all } ]\n \n-gm2_init_iso \"${srcdir}/gm2/iso/check/fail\"\n+gm2_init_iso \"${srcdir}/gm2/iso/check/fail\" -fm2-pathname=- -I${srcdir}/gm2/iso/check/fail\n \n foreach testcase [lsort [glob -nocomplain $srcdir/$subdir/*.mod]] {\n     # If we're only testing specific files and this isn't one of them, skip it."}, {"sha": "81ee8e2dfe6e49343a75b63401daae0785fd9732", "filename": "gcc/testsuite/gm2/link/externalscaffold/pass/link-externalscaffold-pass.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Flink%2Fexternalscaffold%2Fpass%2Flink-externalscaffold-pass.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Flink%2Fexternalscaffold%2Fpass%2Flink-externalscaffold-pass.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Flink%2Fexternalscaffold%2Fpass%2Flink-externalscaffold-pass.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -25,7 +25,7 @@ if $tracelevel then {\n # load support procs\n load_lib gm2-torture.exp\n \n-gm2_init_pim \"${srcdir}/gm2/pim/pass\" -fscaffold-main -fno-scaffold-dynamic\n+gm2_init_pim \"${srcdir}/gm2/pim/pass\" -fscaffold-main -fno-scaffold-dynamic -fm2-pathname=- -I${srcdir}/gm2/pim/pass\n gm2_link_obj scaffold.o\n set output [target_compile $srcdir/$subdir/scaffold.c scaffold.o object \"-g\"]\n "}, {"sha": "2bd3587f6c715158258a2f602df76b37d531dab2", "filename": "gcc/testsuite/gm2/link/externalscaffold/pass/scaffold.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Flink%2Fexternalscaffold%2Fpass%2Fscaffold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Flink%2Fexternalscaffold%2Fpass%2Fscaffold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Flink%2Fexternalscaffold%2Fpass%2Fscaffold.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -1,31 +1,31 @@\n extern  void exit (int);\n \n-extern  void _M2_SYSTEM_init (int argc, char *argv[]);\n-extern  void _M2_SYSTEM_fini (void);\n-extern  void _M2_M2RTS_init (int argc, char *argv[]);\n-extern  void _M2_M2RTS_fini (void);\n-extern  void _M2_RTExceptions_init (int argc, char *argv[]);\n-extern  void _M2_RTExceptions_fini (void);\n+extern  void m2pim_M2_SYSTEM_init (int argc, char *argv[]);\n+extern  void m2pim_M2_SYSTEM_fini (void);\n+extern  void m2pim_M2_M2RTS_init (int argc, char *argv[]);\n+extern  void m2pim_M2_M2RTS_fini (void);\n+extern  void m2pim_M2_RTExceptions_init (int argc, char *argv[]);\n+extern  void m2pim_M2_RTExceptions_fini (void);\n extern  void _M2_hello_init (int argc, char *argv[]);\n extern  void _M2_hello_fini (void);\n \n extern  void M2RTS_Terminate (void);\n \n static void init (int argc, char *argv[])\n {\n-  _M2_SYSTEM_init (argc, argv);\n-  _M2_M2RTS_init (argc, argv);\n-  _M2_RTExceptions_init (argc, argv);\n+  m2pim_M2_SYSTEM_init (argc, argv);\n+  m2pim_M2_M2RTS_init (argc, argv);\n+  m2pim_M2_RTExceptions_init (argc, argv);\n   _M2_hello_init (argc, argv);\n }\n \n static void finish (void)\n {\n-  M2RTS_Terminate ();\n+  m2pim_M2RTS_Terminate ();\n   _M2_hello_fini ();\n-  _M2_RTExceptions_fini ();\n-  _M2_M2RTS_fini ();\n-  _M2_SYSTEM_fini ();\n+  m2pim_M2_RTExceptions_fini ();\n+  m2pim_M2_M2RTS_fini ();\n+  m2pim_M2_SYSTEM_fini ();\n   exit (0);\n }\n "}, {"sha": "94a183301c3928be0eb3354c58f6c70a8eca53b9", "filename": "gcc/testsuite/gm2/pimlib/base/run/pass/FIO.mod", "status": "modified", "additions": 90, "deletions": 91, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fpimlib%2Fbase%2Frun%2Fpass%2FFIO.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fpimlib%2Fbase%2Frun%2Fpass%2FFIO.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fpimlib%2Fbase%2Frun%2Fpass%2FFIO.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -1,21 +1,28 @@\n-(* Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n-                 2010\n-                 Free Software Foundation, Inc. *)\n-(* This file is part of GNU Modula-2.\n-\n-This library is free software; you can redistribute it and/or\n-modify it under the terms of the GNU Lesser General Public\n-License as published by the Free Software Foundation; either\n-version 2.1 of the License, or (at your option) any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n+(* FIO.mod provides a simple buffered file input/output library.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-Lesser General Public License for more details.\n+General Public License for more details.\n \n-You should have received a copy of the GNU Lesser General Public\n-License along with this library; if not, write to the Free Software\n-Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA *)\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  *)\n \n IMPLEMENTATION MODULE FIO ;\n \n@@ -83,22 +90,6 @@ TYPE\n                                                            (* bufstart above.                  *)\n    PtrToChar         = POINTER TO CHAR ;\n \n-(* we only need forward directives for the p2c bootstrapping tool *)\n-\n-(* %%%FORWARD%%%\n-PROCEDURE SetEndOfLine (f: File; ch: CHAR) ; FORWARD ;\n-PROCEDURE FormatError (a: ARRAY OF CHAR) ; FORWARD ;\n-PROCEDURE FormatError1 (a: ARRAY OF CHAR; w: ARRAY OF BYTE) ; FORWARD ;\n-PROCEDURE CheckAccess (f: File; use: FileUsage; towrite: BOOLEAN) ; FORWARD ;\n-PROCEDURE BufferedRead (f: File; nBytes: CARDINAL; a: ADDRESS) : INTEGER ; FORWARD ;\n-PROCEDURE InitializeFile (f: File; fname: ADDRESS; flength: CARDINAL;\n-                          fstate: FileStatus; use: FileUsage; towrite: BOOLEAN; buflength: CARDINAL) : File ; FORWARD ;\n-PROCEDURE ConnectToUnix (f: File; towrite, newfile: BOOLEAN) ; FORWARD ;\n-PROCEDURE SetState (f: File; s: FileStatus) ; FORWARD ;\n-PROCEDURE PreInitialize (f: File; fname: ARRAY OF CHAR;\n-                         state: FileStatus; use: FileUsage;\n-                         towrite: BOOLEAN; osfd: INTEGER; bufsize: CARDINAL) ; FORWARD ;\n-   %%%FORWARD%%% *)\n \n VAR\n    FileInfo: Index ;\n@@ -543,7 +534,7 @@ END Close ;\n *)\n \n PROCEDURE ReadFromBuffer (f: File; a: ADDRESS; nBytes: CARDINAL) : INTEGER ;\n-VAR \n+VAR\n    t     : ADDRESS ;\n    result: INTEGER ;\n    total,\n@@ -635,32 +626,32 @@ END ReadFromBuffer ;\n \n \n (*\n-   ReadNBytes - reads nBytes of a file into memory area, a, returning\n+   ReadNBytes - reads nBytes of a file into memory area, dest, returning\n                 the number of bytes actually read.\n                 This function will consume from the buffer and then\n                 perform direct libc reads. It is ideal for large reads.\n *)\n \n-PROCEDURE ReadNBytes (f: File; nBytes: CARDINAL; a: ADDRESS) : CARDINAL ;\n+PROCEDURE ReadNBytes (f: File; nBytes: CARDINAL; dest: ADDRESS) : CARDINAL ;\n VAR\n    n: INTEGER ;\n    p: POINTER TO CHAR ;\n BEGIN\n-   IF f#Error\n+   IF f # Error\n    THEN\n-      CheckAccess(f, openedforread, FALSE) ;\n-      n := ReadFromBuffer(f, a, nBytes) ;\n-      IF n<0\n+      CheckAccess (f, openedforread, FALSE) ;\n+      n := ReadFromBuffer (f, dest, nBytes) ;\n+      IF n <= 0\n       THEN\n-         RETURN( 0 )\n+         RETURN 0\n       ELSE\n-         p := a ;\n-         INC(p, n) ;\n-         SetEndOfLine(f, p^) ;\n-         RETURN( n )\n+         p := dest ;\n+         INC (p, n-1) ;\n+         SetEndOfLine (f, p^) ;\n+         RETURN n\n       END\n    ELSE\n-      RETURN( 0 )\n+      RETURN 0\n    END\n END ReadNBytes ;\n \n@@ -674,7 +665,7 @@ END ReadNBytes ;\n *)\n \n PROCEDURE BufferedRead (f: File; nBytes: CARDINAL; a: ADDRESS) : INTEGER ;\n-VAR \n+VAR\n    t     : ADDRESS ;\n    result: INTEGER ;\n    total,\n@@ -747,14 +738,11 @@ BEGIN\n                   END\n                END ;\n                RETURN( total )\n-            ELSE\n-               RETURN( -1 )\n             END\n          END\n       END\n-   ELSE\n-      RETURN( -1 )\n-   END\n+   END ;\n+   RETURN( -1 )\n END BufferedRead ;\n \n \n@@ -825,6 +813,8 @@ VAR\n BEGIN\n    HighSrc := StrLen(src) ;\n    HighDest := HIGH(dest) ;\n+   p := NIL ;\n+   c := 0 ;\n    i := 0 ;\n    j := 0 ;\n    WHILE (i<HighSrc) AND (src[i]#nul) AND (j<HighDest) AND (src[i]#'%') DO\n@@ -892,39 +882,41 @@ END StringFormat1 ;\n \n PROCEDURE FormatError (a: ARRAY OF CHAR) ;\n BEGIN\n-   WriteString(StdErr, a)\n+   WriteString (StdErr, a)\n END FormatError ;\n \n \n (*\n-   FormatError1 - fairly generic error procedure.\n+   FormatError1 - generic error procedure taking standard format string\n+                  and single parameter.\n *)\n \n PROCEDURE FormatError1 (a: ARRAY OF CHAR; w: ARRAY OF BYTE) ;\n VAR\n    s: ARRAY [0..MaxErrorString] OF CHAR ;\n BEGIN\n-   StringFormat1(s, a, w) ;\n-   FormatError(s)\n+   StringFormat1 (s, a, w) ;\n+   FormatError (s)\n END FormatError1 ;\n \n \n (*\n-   FormatError2 - fairly generic error procedure.\n+   FormatError2 - generic error procedure taking standard format string\n+                  and two parameters.\n *)\n \n PROCEDURE FormatError2 (a: ARRAY OF CHAR;\n                         w1, w2: ARRAY OF BYTE) ;\n VAR\n    s: ARRAY [0..MaxErrorString] OF CHAR ;\n BEGIN\n-   StringFormat1(s, a, w1) ;\n-   FormatError1(s, w2)\n+   StringFormat1 (s, a, w1) ;\n+   FormatError1 (s, w2)\n END FormatError2 ;\n \n \n (*\n-   CheckAccess - checks to see whether a file, f, has been\n+   CheckAccess - checks to see whether a file f has been\n                  opened for read/write.\n *)\n \n@@ -934,20 +926,20 @@ VAR\n BEGIN\n    IF f#Error\n    THEN\n-      fd := GetIndice(FileInfo, f) ;\n+      fd := GetIndice (FileInfo, f) ;\n       IF fd=NIL\n       THEN\n          IF f#StdErr\n          THEN\n-            FormatError('this file has probably been closed and not reopened successfully or alternatively never opened\\n')\n+            FormatError ('this file has probably been closed and not reopened successfully or alternatively never opened\\n')\n          END ;\n          HALT\n       ELSE\n          WITH fd^ DO\n             IF (use=openedforwrite) AND (usage=openedforread)\n             THEN\n-               FormatError1('this file (%s) has been opened for reading but is now being written\\n',\n-                            name.address) ;\n+               FormatError1 ('this file (%s) has been opened for reading but is now being written\\n',\n+                             name.address) ;\n                HALT\n             ELSIF (use=openedforread) AND (usage=openedforwrite)\n             THEN\n@@ -982,7 +974,7 @@ END CheckAccess ;\n \n \n (*\n-   ReadChar - returns a character read from file, f.\n+   ReadChar - returns a character read from file f.\n               Sensible to check with IsNoError or EOF after calling\n               this function.\n *)\n@@ -991,19 +983,19 @@ PROCEDURE ReadChar (f: File) : CHAR ;\n VAR\n    ch: CHAR ;\n BEGIN\n-   CheckAccess(f, openedforread, FALSE) ;\n-   IF BufferedRead(f, SIZE(ch), ADR(ch)) = INTEGER (SIZE(ch))\n+   CheckAccess (f, openedforread, FALSE) ;\n+   IF BufferedRead (f, SIZE (ch), ADR (ch)) = VAL (INTEGER, SIZE (ch))\n    THEN\n-      SetEndOfLine(f, ch) ;\n-      RETURN( ch )\n+      SetEndOfLine (f, ch) ;\n+      RETURN ch\n    ELSE\n-      RETURN( nul )\n+      RETURN nul\n    END\n END ReadChar ;\n \n \n (*\n-   SetEndOfLine - \n+   SetEndOfLine -\n *)\n \n PROCEDURE SetEndOfLine (f: File; ch: CHAR) ;\n@@ -1018,21 +1010,26 @@ BEGIN\n          IF ch=nl\n          THEN\n             state := endofline\n+         ELSE\n+            state := successful\n          END\n       END\n    END\n END SetEndOfLine ;\n \n \n (*\n-   UnReadChar - replaces a character, ch, back into file, f.\n+   UnReadChar - replaces a character, ch, back into file f.\n                 This character must have been read by ReadChar\n                 and it does not allow successive calls.  It may\n                 only be called if the previous read was successful\n                 or end of file was seen.\n+                If the state was previously endoffile then it\n+                is altered to successful.\n+                Otherwise it is left alone.\n *)\n \n-PROCEDURE UnReadChar (f: File ; ch: CHAR) ;\n+PROCEDURE UnReadChar (f: File; ch: CHAR) ;\n VAR\n    fd  : FileDescriptor ;\n    n   : CARDINAL ;\n@@ -1061,7 +1058,6 @@ BEGIN\n                      DEC(position) ;\n                      INC(left) ;\n                      contents^[position] := ch ;\n-                     SetEndOfLine(f, ch)\n                   ELSE\n                      (* position=0 *)\n                      (* if possible make room and store ch *)\n@@ -1075,7 +1071,6 @@ BEGIN\n                         a := memcpy(a, b, n) ;\n                         INC(filled) ;\n                         contents^[position] := ch ;\n-                        SetEndOfLine(f, ch)\n                      END\n                   END\n                END\n@@ -1097,7 +1092,7 @@ END UnReadChar ;\n PROCEDURE ReadAny (f: File; VAR a: ARRAY OF BYTE) ;\n BEGIN\n    CheckAccess(f, openedforread, FALSE) ;\n-   IF BufferedRead(f, HIGH(a), ADR(a)) = INTEGER (HIGH(a))\n+   IF BufferedRead (f, HIGH (a), ADR (a)) = VAL (INTEGER, HIGH (a))\n    THEN\n       SetEndOfLine(f, a[HIGH(a)])\n    END\n@@ -1145,10 +1140,10 @@ BEGIN\n       fd := GetIndice(FileInfo, f) ;\n       IF fd#NIL\n       THEN\n-         IF fd^.state=successful\n+         IF (fd^.state=successful) OR (fd^.state=endofline)\n          THEN\n             ch := ReadChar(f) ;\n-            IF fd^.state=successful\n+            IF (fd^.state=successful) OR (fd^.state=endofline)\n             THEN\n                UnReadChar(f, ch)\n             END ;\n@@ -1190,14 +1185,14 @@ END WriteLine ;\n \n \n (*\n-   WriteNBytes - writes nBytes of a file into memory area, a, returning\n-                 the number of bytes actually written.\n+   WriteNBytes - writes nBytes from memory area src to a file\n+                 returning the number of bytes actually written.\n                  This function will flush the buffer and then\n                  write the nBytes using a direct write from libc.\n                  It is ideal for large writes.\n *)\n \n-PROCEDURE WriteNBytes (f: File; nBytes: CARDINAL; a: ADDRESS) : CARDINAL ;\n+PROCEDURE WriteNBytes (f: File; nBytes: CARDINAL; src: ADDRESS) : CARDINAL ;\n VAR\n    total: INTEGER ;\n    fd   : FileDescriptor ;\n@@ -1210,7 +1205,7 @@ BEGIN\n       IF fd#NIL\n       THEN\n          WITH fd^ DO\n-            total := write(unixfd, a, INTEGER(nBytes)) ;\n+            total := write(unixfd, src, INTEGER(nBytes)) ;\n             IF total<0\n             THEN\n                state := failed ;\n@@ -1239,7 +1234,7 @@ END WriteNBytes ;\n *)\n \n PROCEDURE BufferedWrite (f: File; nBytes: CARDINAL; a: ADDRESS) : INTEGER ;\n-VAR \n+VAR\n    t     : ADDRESS ;\n    result: INTEGER ;\n    total,\n@@ -1284,7 +1279,7 @@ BEGIN\n                         END\n                      ELSE\n                         FlushBuffer(f) ;\n-                        IF state#successful\n+                        IF (state#successful) AND (state#endofline)\n                         THEN\n                            nBytes := 0\n                         END\n@@ -1343,8 +1338,8 @@ END FlushBuffer ;\n \n PROCEDURE WriteAny (f: File; VAR a: ARRAY OF BYTE) ;\n BEGIN\n-   CheckAccess(f, openedforwrite, TRUE) ;\n-   IF BufferedWrite (f, HIGH(a), ADR(a)) = INTEGER (HIGH(a))\n+   CheckAccess (f, openedforwrite, TRUE) ;\n+   IF BufferedWrite (f, HIGH (a), ADR (a)) = VAL (INTEGER, HIGH (a))\n    THEN\n    END\n END WriteAny ;\n@@ -1356,8 +1351,8 @@ END WriteAny ;\n \n PROCEDURE WriteChar (f: File; ch: CHAR) ;\n BEGIN\n-   CheckAccess(f, openedforwrite, TRUE) ;\n-   IF BufferedWrite(f, SIZE(ch), ADR(ch)) = INTEGER (SIZE(ch))\n+   CheckAccess (f, openedforwrite, TRUE) ;\n+   IF BufferedWrite (f, SIZE (ch), ADR (ch)) = VAL (INTEGER, SIZE (ch))\n    THEN\n    END\n END WriteChar ;\n@@ -1608,7 +1603,8 @@ BEGIN\n       ELSE\n          RETURN fd^.name.address\n       END\n-   END\n+   END ;\n+   RETURN NIL\n END getFileName ;\n \n \n@@ -1630,7 +1626,8 @@ BEGIN\n       ELSE\n          RETURN fd^.name.size\n       END\n-   END\n+   END ;\n+   RETURN 0\n END getFileNameLength ;\n \n \n@@ -1666,8 +1663,10 @@ END PreInitialize ;\n \n \n (*\n-   FlushOutErr - called when the application calls M2RTS.Terminate (automatically\n-                 placed in program modules by GM2.\n+   FlushOutErr - flushes, StdOut, and, StdErr.\n+                 It is also called when the application calls M2RTS.Terminate.\n+                 (which is automatically placed in program modules by the GM2\n+                 scaffold).\n *)\n \n PROCEDURE FlushOutErr ;"}, {"sha": "f85040ccacde44ce47b7755eb2bc8e06179d1b1e", "filename": "gcc/testsuite/gm2/pimlib/base/run/pass/StrLib.mod", "status": "modified", "additions": 51, "deletions": 48, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fpimlib%2Fbase%2Frun%2Fpass%2FStrLib.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fpimlib%2Fbase%2Frun%2Fpass%2FStrLib.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fpimlib%2Fbase%2Frun%2Fpass%2FStrLib.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -1,33 +1,33 @@\n-(* Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n-   Free Software Foundation, Inc. *)\n-(* This file is part of GNU Modula-2.\n+(* StrLib.mod provides string manipulation procedures.\n \n-This library is free software; you can redistribute it and/or\n-modify it under the terms of the GNU Lesser General Public\n-License as published by the Free Software Foundation; either\n-version 2.1 of the License, or (at your option) any later version.\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-Lesser General Public License for more details.\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n \n-You should have received a copy of the GNU Lesser General Public\n-License along with this library; if not, write to the Free Software\n-Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA *)\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  *)\n \n IMPLEMENTATION MODULE StrLib ;\n \n FROM ASCII IMPORT nul, tab ;\n \n-(* %%%FORWARD%%%\n-PROCEDURE StrEqual (a, b: ARRAY OF CHAR) : BOOLEAN ; FORWARD ;\n-PROCEDURE StrLen (a: ARRAY OF CHAR) : CARDINAL ; FORWARD ;\n-PROCEDURE StrCopy (a: ARRAY OF CHAR ; VAR b: ARRAY OF CHAR) ; FORWARD ;\n-PROCEDURE StrConCat (a: ARRAY OF CHAR ; b: ARRAY OF CHAR ; VAR c: ARRAY OF CHAR) ; FORWARD ;\n-PROCEDURE IsSubString (a, b: ARRAY OF CHAR) : BOOLEAN ; FORWARD ;\n-   %%%FORWARD%%% *)\n-\n \n (*\n    StrConCat - combines a and b into c.\n@@ -88,24 +88,21 @@ END StrLess ;\n PROCEDURE StrEqual (a, b: ARRAY OF CHAR) : BOOLEAN ;\n VAR\n    i,\n-   Higha,\n-   Highb: CARDINAL ;\n-   Equal: BOOLEAN ;\n+   higha,\n+   highb: CARDINAL ;\n BEGIN\n-   Higha := StrLen(a) ;\n-   Highb := StrLen(b) ;\n-   IF Higha=Highb\n-   THEN\n-      Equal := TRUE ;\n-      i := 0 ;\n-      WHILE Equal AND (i<Higha) DO\n-         Equal := (a[i]=b[i]) ;\n-         INC(i)\n+   higha := HIGH(a) ;\n+   highb := HIGH(b) ;\n+   i := 0 ;\n+   WHILE (i<=higha) AND (i<=highb) AND (a[i]#nul) AND (b[i]#nul) DO\n+      IF a[i]#b[i]\n+      THEN\n+         RETURN( FALSE )\n       END ;\n-      RETURN( Equal )\n-   ELSE\n-      RETURN( FALSE )\n-   END\n+      INC(i)\n+   END ;\n+   RETURN NOT (((i<=higha) AND (a[i]#nul)) OR\n+               ((i<=highb) AND (b[i]#nul)))\n END StrEqual ;\n \n \n@@ -123,22 +120,28 @@ BEGIN\n END StrLen ;\n \n \n-PROCEDURE StrCopy (a: ARRAY OF CHAR ; VAR b: ARRAY OF CHAR) ;\n+(*\n+   StrCopy - copy string src into string dest providing dest is large enough.\n+             If dest is smaller than a then src then the string is truncated when\n+             dest is full.  Add a nul character if there is room in dest.\n+*)\n+\n+PROCEDURE StrCopy (src: ARRAY OF CHAR ; VAR dest: ARRAY OF CHAR) ;\n VAR\n-   Higha,\n-   Highb,\n-   n    : CARDINAL ;\n+   HighSrc,\n+   HighDest,\n+   n       : CARDINAL ;\n BEGIN\n    n := 0 ;\n-   Higha := StrLen(a) ;\n-   Highb := HIGH(b) ;\n-   WHILE (n<Higha) AND (n<=Highb) DO\n-      b[n] := a[n] ;\n-      INC(n)\n+   HighSrc := StrLen (src) ;\n+   HighDest := HIGH (dest) ;\n+   WHILE (n < HighSrc) AND (n <= HighDest) DO\n+      dest[n] := src[n] ;\n+      INC (n)\n    END ;\n-   IF n<=Highb\n+   IF n <= HighDest\n    THEN\n-      b[n] := nul\n+      dest[n] := nul\n    END\n END StrCopy ;\n "}, {"sha": "79640c2db4d9f9cd579dc48e351406e7dd6ccdee", "filename": "gcc/testsuite/gm2/pimlib/base/run/pass/pimlib-base-run-pass.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fpimlib%2Fbase%2Frun%2Fpass%2Fpimlib-base-run-pass.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fpimlib%2Fbase%2Frun%2Fpass%2Fpimlib-base-run-pass.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fpimlib%2Fbase%2Frun%2Fpass%2Fpimlib-base-run-pass.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -27,7 +27,7 @@ load_lib gm2-torture.exp\n \n set gm2src ${srcdir}/../m2\n \n-gm2_init_pim \"${srcdir}/gm2/pimlib/base/run/pass\"\n+gm2_init_pim \"\"\n \n # We should be able to compile, link or run in 20 seconds.\n gm2_push_timeout 20"}, {"sha": "8fa3bee8bf7af07d2fcd0a4a9238f8f8f000b9cd", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/random/projects-pim-run-pass-random.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Frandom%2Fprojects-pim-run-pass-random.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Frandom%2Fprojects-pim-run-pass-random.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Frandom%2Fprojects-pim-run-pass-random.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -25,7 +25,7 @@ if $tracelevel then {\n # load support procs\n load_lib gm2-torture.exp\n \n-gm2_init_pim \"$srcdir/$subdir\" -g\n+gm2_init_pim \"${srcdir}/${subdir}\" -g\n gm2_link_obj \"WriteMap.o AdvMap.o BoxMap.o Chance.o Geometry.o MakeBoxes.o MapOptions.o Options.o RoomMap.o StoreCoords.o\"\n \n # If we want these to be re-built for each torture option we need some different "}, {"sha": "166824e67e4177b836b62bd21ca0d20967831271", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvCmd.def", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvCmd.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvCmd.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvCmd.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,10 @@\n+DEFINITION MODULE AdvCmd ;\n+\n+\n+EXPORT QUALIFIED ExecuteCommand ;\n+\n+\n+PROCEDURE ExecuteCommand (ch: CHAR ; VAR Dead: BOOLEAN) ;\n+\n+\n+END AdvCmd."}, {"sha": "bc9a5bb4b66c5517caad049a79e0cf14e15069a3", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvCmd.mod", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvCmd.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvCmd.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvCmd.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,294 @@\n+IMPLEMENTATION MODULE AdvCmd ;\n+\n+\n+FROM ASCII IMPORT ff, esc ;\n+FROM Storage IMPORT ALLOCATE ;\n+\n+FROM AdvMap IMPORT IncPosition ;\n+FROM DrawG IMPORT DrawMan, EraseMan ;\n+FROM AdvTreasure IMPORT GetTreasure, DropTreasure, UseTreasure ;\n+FROM ProcArgs IMPORT SetArgs ;\n+\n+FROM AdvSystem IMPORT ArrowArgs,\n+                      Player, TypeOfDeath, PlayerNo,\n+                      GetWriteAccessToPlayer,\n+                      ReleaseWriteAccessToPlayer,\n+                      GetReadAccessToPlayer,\n+                      ReleaseReadAccessToPlayer,\n+                      GetAccessToScreenNo,\n+                      ReleaseAccessToScreenNo ;\n+\n+FROM AdvMath IMPORT UpDateWoundsAndFatigue,\n+                    StrengthToFireArrow,\n+                    StrengthToFireMagic ;\n+\n+FROM AdvUtil IMPORT MoveMan, Exit, InitialDisplay,\n+                    OpenDoor, CloseDoor, ExamineDoor, HideDoor,\n+                    Attack, Thrust, Parry,\n+                    Speak ;\n+\n+FROM Screen IMPORT Height, Width, WriteTime, ClearScreen, Pause,\n+                   WriteString,\n+                   WriteCommentLine1,\n+                   DelCommentLine1,\n+                   WriteArrows, WriteMagicArrows ;\n+\n+\n+CONST\n+   MaxCard = 65535 ;\n+   CtrlL   =    ff ;\n+\n+\n+(* Adventure Commands! - Interpreted *)\n+\n+\n+PROCEDURE ExecuteCommand (ch: CHAR ; VAR Dead: BOOLEAN) ;\n+VAR\n+   p: CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      GetWriteAccessToPlayer ;\n+      Dead := DeathType#living ;\n+      IF Dead\n+      THEN\n+         RoomOfMan := 0 ;\n+         Xman := MaxCard-Width ;\n+         Yman := MaxCard-Height ;\n+         ReleaseWriteAccessToPlayer\n+      ELSE\n+         WriteTime (p) ;  (* always start by displaying the current time.  *)\n+\n+         ReleaseWriteAccessToPlayer ;\n+         GetAccessToScreenNo(p) ;\n+         UpDateWoundsAndFatigue(p) ;\n+         ReleaseAccessToScreenNo(p) ;\n+\n+         CASE ch OF\n+\n+         'h'  : Help |\n+         'v'  : ValtTurn |\n+         'r'  : RightTurn |\n+         'l'  : LeftTurn |\n+         '0'..'9' : MoveMan( ORD(ch)-ORD('0') ) |\n+         'f'  : FireNormalArrow |\n+         'm'  : FireMagicArrow |\n+         'p'  : Parry |\n+         't'  : Thrust |\n+         'a'  : Attack |\n+         'o'  : OpenDoor |\n+         'c'  : CloseDoor |\n+         'e'  : ExamineDoor |\n+         'g'  : GetTreasure |\n+         'd'  : DropTreasure |\n+         'u'  : UseTreasure |\n+         's'  : Speak |\n+         'w'  : |\n+\n+         CtrlL: RedrawScreen |\n+\n+         esc  : Exit ;\n+                DeathType := exitdungeon\n+\n+         ELSE\n+         END ;\n+         GetWriteAccessToPlayer ;\n+         Dead := DeathType#living ;\n+         IF Dead\n+         THEN\n+            Xman := MaxCard-Width ;\n+            Yman := MaxCard-Height ;\n+            RoomOfMan := 0\n+         END ;\n+         ReleaseWriteAccessToPlayer\n+      END\n+   END\n+END ExecuteCommand ;\n+\n+\n+PROCEDURE Help ;\n+VAR\n+   p: CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   GetAccessToScreenNo(p) ;\n+   ClearScreen(p) ;\n+   WriteString(p, 'Key commands are:') ;\n+   WriteString(p, '') ;\n+   WriteString(p, \"'1'..'9'   move 1..9 squares forward\") ;\n+   WriteString(p, \"'r'        turn right\") ;\n+   WriteString(p, \"'l'        turn left\") ;\n+   WriteString(p, \"'v'        vault turn\") ;\n+   WriteString(p, \"'f'        fire normal arrow\") ;\n+   WriteString(p, \"'m'        fire magic arrow\") ;\n+   WriteString(p, \"'o'        open door in front of you\") ;\n+   WriteString(p, \"'c'        close door in front of you\") ;\n+   WriteString(p, \"'e'        examine wall for secret door in front of you\") ;\n+   WriteString(p, \"'p'        parry with sword\") ;\n+   WriteString(p, \"'a'        attack with sword\") ;\n+   WriteString(p, \"'t'        thrust with sword\") ;\n+   WriteString(p, \"'g'        get treasure in front of you\") ;\n+   WriteString(p, \"'d' <no>   drop treasure in front of you\") ;\n+   WriteString(p, \"'u' <no>   use treasure\") ;\n+   ReleaseAccessToScreenNo(p) ;\n+   Pause(p) ;\n+   RedrawScreen\n+END Help ;\n+\n+\n+PROCEDURE ValtTurn ;\n+VAR\n+   p: CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   GetWriteAccessToPlayer ;\n+   EraseMan(p) ;\n+   WITH Player[p] DO\n+      Direction := (Direction+2) MOD 4 ;\n+   END ;\n+   DrawMan( p ) ;\n+   ReleaseWriteAccessToPlayer\n+END ValtTurn ;\n+\n+\n+PROCEDURE RightTurn ;\n+VAR\n+   p: CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   GetWriteAccessToPlayer ;\n+   EraseMan(p) ;\n+   WITH Player[p] DO\n+      Direction := (Direction+3) MOD 4 ;\n+   END ;\n+   DrawMan(p) ;\n+   ReleaseWriteAccessToPlayer\n+END RightTurn ;\n+\n+\n+PROCEDURE LeftTurn ;\n+VAR\n+   p: CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   GetWriteAccessToPlayer ;\n+   EraseMan(p) ;\n+   WITH Player[p] DO\n+      Direction := (Direction+1) MOD 4 ;\n+   END ;\n+   DrawMan( p ) ;\n+   ReleaseWriteAccessToPlayer\n+END LeftTurn ;\n+\n+\n+PROCEDURE SendFireToProcess (p, r, x, y, d: CARDINAL; magic: BOOLEAN) ;\n+VAR\n+   aa: ArrowArgs ;\n+BEGIN\n+   NEW(aa) ;\n+   WITH aa^ DO\n+      ArrowPlayer := p ;\n+      ArrowRoom := r ;\n+      ArrowX := x ;\n+      ArrowY := y ;\n+      ArrowDir := d ;\n+      IsMagic := FALSE\n+   END ;\n+   WITH Player[p] DO\n+      IF magic\n+      THEN\n+         aa := SetArgs(MagicProcArgs, aa)\n+      ELSE\n+         aa := SetArgs(NormalProcArgs, aa)\n+      END\n+   END\n+END SendFireToProcess ;\n+\n+\n+PROCEDURE FireMagicArrow ;\n+VAR\n+   r,\n+   x, y, p,\n+   Dir    : CARDINAL ;\n+   yes    : BOOLEAN ;\n+BEGIN\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      GetWriteAccessToPlayer ;\n+      StrengthToFireMagic(yes) ;\n+      IF yes\n+      THEN\n+         IF NoOfMagic>0\n+         THEN\n+            DEC(NoOfMagic) ;\n+            Dir := Direction ;\n+            x := Xman ;\n+            y := Yman ;\n+            r := RoomOfMan ;\n+            ReleaseWriteAccessToPlayer ;\n+            IncPosition(x, y, Dir) ;\n+            SendFireToProcess(p, r, x, y, Dir, TRUE) ;\n+            GetAccessToScreenNo(p) ;\n+            WriteMagicArrows(p, NoOfMagic) ;\n+            ReleaseAccessToScreenNo(p)\n+         ELSE\n+            ReleaseWriteAccessToPlayer ;\n+            GetAccessToScreenNo(p) ;\n+            DelCommentLine1(p) ;\n+            WriteCommentLine1(p, 'None left') ;\n+            ReleaseAccessToScreenNo(p)\n+         END\n+      ELSE\n+         ReleaseWriteAccessToPlayer\n+      END\n+   END\n+END FireMagicArrow ;\n+\n+\n+PROCEDURE FireNormalArrow ;\n+VAR\n+   r,\n+   x, y, p,\n+   Dir    : CARDINAL ;\n+   yes    : BOOLEAN ;\n+BEGIN\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      GetWriteAccessToPlayer ;\n+      StrengthToFireArrow(yes) ;\n+      IF yes\n+      THEN\n+         IF NoOfNormal>0\n+         THEN\n+            DEC(NoOfNormal) ;\n+            Dir := Direction ;\n+            x := Xman ;\n+            y := Yman ;\n+            r := RoomOfMan ;\n+            ReleaseWriteAccessToPlayer ;\n+            IncPosition(x, y, Dir) ;\n+            SendFireToProcess(p, r, x, y, Dir, FALSE) ;\n+            GetAccessToScreenNo(p) ;\n+            DelCommentLine1(p) ;\n+            WriteArrows(p, NoOfNormal) ;\n+            ReleaseAccessToScreenNo(p)\n+         ELSE\n+            ReleaseWriteAccessToPlayer ;\n+            GetAccessToScreenNo(p) ;\n+            WriteCommentLine1(p, 'None left') ;\n+            ReleaseAccessToScreenNo(p)\n+         END\n+      ELSE\n+         ReleaseWriteAccessToPlayer\n+      END\n+   END\n+END FireNormalArrow ;\n+\n+\n+PROCEDURE RedrawScreen ;\n+BEGIN\n+   InitialDisplay\n+END RedrawScreen ;\n+\n+\n+END AdvCmd."}, {"sha": "834ebac49ea2b4cd0f8cf226518aee24b5ecdb0e", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvIntroduction.def", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvIntroduction.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvIntroduction.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvIntroduction.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,7 @@\n+DEFINITION MODULE AdvIntroduction ;\n+\n+EXPORT QUALIFIED StartGame ;\n+\n+PROCEDURE StartGame ;\n+\n+END AdvIntroduction."}, {"sha": "3174764287467fbe85159adff070e3a625de4888", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvIntroduction.mod", "status": "added", "additions": 275, "deletions": 0, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvIntroduction.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvIntroduction.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvIntroduction.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,275 @@\n+(* Copyright (C) 2003\n+                 Free Software Foundation, Inc. *)\n+(* This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License along\n+with gm2; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)\n+\n+IMPLEMENTATION MODULE AdvIntroduction ;\n+\n+FROM SYSTEM IMPORT ADR, SIZE ;\n+FROM ASCII IMPORT lf, cr, nul ;\n+FROM StrLib IMPORT StrLen ;\n+FROM SocketControl IMPORT nonBlocking, ignoreSignals ;\n+\n+FROM Executive IMPORT WaitForIO, InitProcess, InitSemaphore, Wait, Signal, Resume,\n+                      Suspend, DESCRIPTOR, SEMAPHORE, KillProcess ;\n+\n+FROM RTint IMPORT InitInputVector ;\n+FROM COROUTINES IMPORT PROTECTION ;\n+FROM sckt IMPORT tcpServerState, tcpServerEstablish, tcpServerAccept, tcpServerSocketFd ;\n+FROM libc IMPORT printf, read, write ;\n+FROM AdvUtil IMPORT Positioning, TestIfLastLivePlayer ;\n+\n+FROM AdvSystem IMPORT Player, TypeOfDeath, StartPlayer, PlayerNo,\n+                      ClientRead, DefaultWrite, UnAssign,\n+                      ReadString, GetReadAccessToPlayer,\n+                      ReleaseReadAccessToPlayer,\n+                      GetAccessToScreen, ReleaseAccessToScreen ;\n+\n+FROM AdvTreasure IMPORT DisplayEnemy, Grenade ;\n+FROM AdvUtil IMPORT InitialDisplay ;\n+FROM AdvCmd IMPORT ExecuteCommand ;\n+FROM Screen IMPORT WriteCommand, ClearScreen, WriteString, PromptString, Pause, Quit ;\n+FROM AdvSound IMPORT EnterGame ;\n+FROM StdIO IMPORT PushOutput ;\n+\n+\n+CONST\n+   Meg       = 1024*1024 ;\n+   StackSize = 30 * Meg ;\n+\n+VAR\n+   ToBeTaken: SEMAPHORE ;\n+   NextFd   : INTEGER ;\n+\n+\n+PROCEDURE theServer ;\n+VAR\n+   fd: INTEGER ;\n+   v : CARDINAL ;\n+   ch: CHAR ;\n+   r : INTEGER ;\n+BEGIN\n+   fd := NextFd ;\n+   Signal(ToBeTaken) ;\n+   v := InitInputVector(fd, MAX(PROTECTION)) ;\n+   r := printf(\"inside `theServer' using fd=%d\\n\", fd);\n+   StartPlayer(fd) ;\n+   Copyleft ;\n+   Title ;\n+   Knight ;\n+   WITH Player[PlayerNo()] DO\n+      fd := -1 ;\n+      PlayerProcess := NIL ;\n+   END ;\n+   UnAssign ;\n+   KillProcess\n+END theServer ;\n+\n+\n+PROCEDURE StartGame ;\n+VAR\n+   r   : INTEGER ;\n+   v   : CARDINAL ;\n+   fd  : INTEGER ;\n+   s   : tcpServerState ;\n+   g, p: DESCRIPTOR ;\n+BEGIN\n+   ignoreSignals ;\n+   PushOutput(DefaultWrite) ;\n+   g := Resume(InitProcess(Grenade, StackSize, 'grenade')) ;\n+   s := tcpServerEstablish() ;\n+   ToBeTaken := InitSemaphore(1, 'ToBeTaken') ;\n+   v := InitInputVector(tcpServerSocketFd(s), MAX(PROTECTION)) ;\n+   LOOP\n+      r := printf(\"before WaitForIO\\n\");\n+      WaitForIO(v) ;\n+      fd := tcpServerAccept(s) ;\n+      r := nonBlocking(fd) ;\n+      r := printf(\"before InitProcess\\n\");\n+      p := InitProcess(theServer, StackSize, 'theServer') ;\n+      NextFd := fd ;\n+      r := printf(\"before Resume\\n\");\n+      p := Resume(p) ;\n+      Wait(ToBeTaken)\n+   END\n+END StartGame ;\n+\n+\n+PROCEDURE Knight ;\n+VAR\n+   Dead: BOOLEAN ;\n+   ch  : CHAR ;\n+   p   : CARDINAL ;\n+BEGIN\n+   EquipKnight ;\n+   SetUpKnight ;\n+   InitialDisplay ;\n+   p := PlayerNo() ;\n+   EnterGame(p) ;\n+   Dead := FALSE ;\n+   REPEAT\n+      IF ClientRead(ch)\n+      THEN\n+         WriteCommand(p, ch) ;\n+         ExecuteCommand(ch, Dead)\n+      ELSE\n+         Dead := TRUE\n+      END\n+   UNTIL Dead ;\n+   GiveResults\n+END Knight ;\n+\n+\n+PROCEDURE Copyleft ;\n+VAR\n+   p: CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   ClearScreen(p) ;\n+   WriteString(p, 'Written whilst on holiday during the rainy months of\\n') ;\n+   WriteString(p, 'August 85, August 86 and ported to GNU/linux during July/August 2005\\n\\n') ;\n+   WriteString(p, '\\n') ;\n+   WriteString(p, 'A multiplayer game inspired by two single player Commodore PET\\n') ;\n+   WriteString(p, 'game of circa 1979 (Morloc Tower and Temple of Apshai)\\n') ;\n+   WriteString(p, '\\n') ;\n+   WriteString(p, 'This game is rather different (similar key commands) and\\n') ;\n+   WriteString(p, 'in retrospect a very very poor persons multiplayer doom!\\n') ;\n+   Pause(p)\n+END Copyleft ;\n+\n+\n+PROCEDURE Title ;\n+VAR\n+   p: CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   ClearScreen(p) ;\n+   WriteString(p, '...set in a time of long ago, when life hast no value and\\n') ;\n+   WriteString(p, '   death sometimes, hadst a price. Thou needst to be quick\\n') ;\n+   WriteString(p, '   with thy sword and fast with thy bow, for only the best\\n') ;\n+   WriteString(p, '   survived...\\n\\n\\n')\n+END Title ;\n+\n+\n+PROCEDURE EquipKnight ;\n+VAR\n+   p: CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   PromptString(p, 'What is thy name? ') ;\n+   WITH Player[PlayerNo()] DO\n+      ReadString(ManName)\n+   END ;\n+   WriteString(p, '\\n')\n+END EquipKnight ;\n+\n+\n+PROCEDURE SetUpKnight ;\n+BEGIN\n+   WITH Player[PlayerNo()] DO\n+      NoOfMagic := 1 ;\n+      NoOfNormal := 7\n+   END ;\n+   Positioning\n+END SetUpKnight ;\n+\n+\n+PROCEDURE GiveResults ;\n+VAR\n+   yes: BOOLEAN ;\n+   p  : CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   Pause(p) ;\n+   GetReadAccessToPlayer ;\n+   GetAccessToScreen ;\n+   ClearScreen(p) ;\n+   WITH Player[p] DO\n+      IF Wounds=0\n+      THEN\n+         WriteString(p, 'Thou art slain...') ;\n+         GiveDescriptionOfDeath(p, DeathType)\n+      ELSE\n+         TestIfLastLivePlayer(yes) ;\n+         IF yes\n+         THEN\n+            WriteString(p, 'Thou art the conqueror of the dungeon')\n+         ELSE\n+            WriteString(p, 'Thou art the coward of the dungeon')\n+         END ;\n+         Wounds := 0\n+      END ;\n+      WriteString(p, '\\n\\n\\n')\n+   END ;\n+   ReleaseAccessToScreen ;\n+   ReleaseReadAccessToPlayer ;\n+   Pause(p) ;\n+   Quit(p)\n+END GiveResults ;\n+\n+\n+PROCEDURE GiveDescriptionOfDeath (p: CARDINAL; Dt: TypeOfDeath) ;\n+BEGIN\n+   WriteString(p, '\\n\\n\\n\\nThou expired from life after :\\n\\n') ;\n+   CASE Dt OF\n+\n+   sword       : WriteString(p, 'being slain with a sword') |\n+   magicarrow  : WriteString(p, 'being pierced by a magic arrow') |\n+   fireball    : WriteString(p, 'thou wast struck by a fireball burning thy body fatally') |\n+   normalarrow : WriteString(p, 'thou wast struck a deadly blow caused by an arrow') |\n+   explosion   : WriteString(p, 'having thy guts blown all over the dungeon') |\n+   exitdungeon : WriteString(p, 'thou crawlest out of the dungeon and expired')\n+\n+   END\n+END GiveDescriptionOfDeath ;\n+\n+\n+(* Monitor allows a dead player to look around the dungeon unaffecting *)\n+(* the current game.                                                   *)\n+\n+PROCEDURE Monitor ;\n+VAR\n+   p : CARDINAL ;\n+   ch: CHAR ;\n+BEGIN\n+   p := PlayerNo() ;\n+   REPEAT\n+      ClearScreen(p) ;\n+      WriteString(p, 'Monitor --- Look at other players\\n\\n\\n\\n') ;\n+      WriteString(p, 'Commands:\\n') ;\n+      WriteString(p, '1)  Look at other players\\n') ;\n+      WriteString(p, '2)  Exit\\n\\n') ;\n+      WriteString(p, 'Option:') ;\n+      IF ClientRead(ch)\n+      THEN\n+         DefaultWrite(ch) ;\n+         IF ch='1'\n+         THEN\n+            DisplayEnemy\n+         END\n+      ELSE\n+         RETURN\n+      END\n+   UNTIL ch='2'\n+END Monitor ;\n+\n+\n+END AdvIntroduction.\n+(*\n+ * Local variables:\n+ *  compile-command: \"make\"\n+ * End:\n+ *)"}, {"sha": "57b079abdd260c620b93862253b2e5e08c99bc3e", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvMap.def", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvMap.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvMap.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvMap.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,82 @@\n+DEFINITION MODULE AdvMap ;\n+\n+FROM AdvMath IMPORT MaxNoOfTreasures ;\n+\n+EXPORT QUALIFIED Rooms, Line, DoorStatus, Door, Room, Treasure,\n+                 ActualNoOfRooms, MaxNoOfRooms,\n+                 WallsPerRoom, DoorsPerRoom,\n+                 NoOfRoomsToHidePlayers, NoOfRoomsToSpring,\n+                 NoOfRoomsToHideCoal, NoOfRoomsToHideGrenade,\n+                 TreasureKind,\n+                 Adjacent, IncPosition,\n+                 FileName, MaxLengthOfFileName ;\n+\n+\n+CONST\n+   MaxNoOfRooms           = 350 ;  (* An upper limit *)\n+   WallsPerRoom           =  12 ;  (* An upper limit *)\n+   DoorsPerRoom           =   8 ;  (* An upper limit *)\n+\n+   MaxLengthOfFileName    =  11 ;\n+   NoOfRoomsToHidePlayers =  50 ;\n+   NoOfRoomsToSpring      =  50 ;\n+   NoOfRoomsToHideCoal    =  50 ;\n+   NoOfRoomsToHideGrenade =  50 ;\n+\n+\n+TYPE\n+   Line         = RECORD\n+                     X1 : CARDINAL ;\n+                     Y1 : CARDINAL ;\n+                     X2 : CARDINAL ;\n+                     Y2 : CARDINAL\n+                  END ;\n+\n+   DoorStatus   = (Open, Closed, Secret) ;\n+\n+   Door         = RECORD\n+                     Position    : Line ;\n+                     StateOfDoor : DoorStatus ;\n+                     LeadsTo     : CARDINAL\n+                  END ;\n+\n+   TreasureKind = (unused, respawnnormal, respawnmagic,\n+                   onperson, onfloor, normal, magic) ;\n+\n+   TreasureInfo = RECORD\n+                     Xpos         : CARDINAL ;\n+                     Ypos         : CARDINAL ;\n+                     Rm           : CARDINAL ;\n+                     Tweight      : CARDINAL ;\n+                     TreasureName : ARRAY [0..12] OF CHAR ;\n+                     kind         : TreasureKind ;\n+                     amount       : CARDINAL ;  (* number of arrows.  *)\n+                  END ;\n+\n+   Room         = RECORD\n+                     NoOfWalls   : CARDINAL ;\n+                     NoOfDoors   : CARDINAL ;\n+                     Walls       : ARRAY [1..WallsPerRoom] OF Line ;\n+                     Doors       : ARRAY [1..DoorsPerRoom] OF Door ;\n+                     Treasures   : BITSET ;\n+                  END ;\n+\n+\n+VAR\n+   ActualNoOfRooms : CARDINAL ;\n+   Treasure        : ARRAY [1..MaxNoOfTreasures] OF TreasureInfo ;\n+   Rooms           : ARRAY [1..MaxNoOfRooms] OF Room ;\n+   FileName        : ARRAY [0..MaxLengthOfFileName] OF CHAR ;\n+\n+\n+(* Tests to see if two rooms are Adjacent to each other.                *)\n+\n+PROCEDURE Adjacent (R1, R2: CARDINAL) : BOOLEAN ;\n+\n+\n+(* Increments the position of x, y by the direction that are facing     *)\n+\n+PROCEDURE IncPosition (VAR x, y: CARDINAL ; Dir: CARDINAL) ;\n+\n+\n+END AdvMap."}, {"sha": "73336fe3945086238ef3f4cec6a68ea665a17bde", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvMap.mod", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvMap.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvMap.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvMap.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,57 @@\n+IMPLEMENTATION MODULE AdvMap ;\n+\n+\n+(* IncPosition increments the x,y coordinates according  *)\n+(* the Direction sent.                                   *)\n+\n+PROCEDURE IncPosition (VAR x, y: CARDINAL ; Dir: CARDINAL) ;\n+BEGIN\n+   IF (Dir=0) AND (y>0)\n+   THEN\n+      DEC(y)\n+   ELSIF Dir=3\n+   THEN\n+      INC(x)\n+   ELSIF Dir=2\n+   THEN\n+      INC(y)\n+   ELSIF x>0\n+   THEN\n+      DEC(x)\n+   END\n+END IncPosition ;\n+\n+\n+\n+(* Adjacent tests whether two rooms R1 & R2 are adjacent *)\n+(* Assume that access to map has been granted.           *)\n+\n+PROCEDURE Adjacent (R1, R2: CARDINAL) : BOOLEAN ;\n+VAR\n+   i, r1, r2 : CARDINAL ;\n+   ok: BOOLEAN ;\n+BEGIN\n+   WITH Rooms[R1] DO\n+      i := NoOfDoors ;\n+      ok := FALSE ;\n+      WHILE (i>0) AND (NOT ok) DO\n+         IF Doors[i].LeadsTo=R2\n+         THEN\n+            ok := TRUE\n+         ELSE\n+            DEC (i)\n+         END\n+      END\n+   END ;\n+   RETURN ok\n+END Adjacent ;\n+\n+\n+BEGIN\n+   ActualNoOfRooms := 0\n+END AdvMap.\n+(*\n+ * Local variables:\n+ *  compile-command: \"make\"\n+ * End:\n+ *)"}, {"sha": "c6ec3e209d357cf10e6d54ac6be2475b2e614ae9", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvMath.def", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvMath.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvMath.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvMath.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,120 @@\n+DEFINITION MODULE AdvMath ;\n+\n+EXPORT QUALIFIED RequiredToParry,\n+                 RequiredToAttack,\n+                 RequiredToThrust,\n+                 RequiredToFireArrow,\n+                 RequiredToFireMagic,\n+                 RequiredToMove,\n+                 RequiredToMagicShoes,\n+                 RequiredToMagicParry,\n+                 RequiredToMagicAttack,\n+                 RequiredToMagicThrust,\n+\n+                 DammageByParry,\n+                 DammageByAttack,\n+                 DammageByThrust,\n+                 DammageByFireArrow,\n+                 DammageByFireMagic,\n+                 DammageByHandGrenade,\n+                 DammageByHotIron,\n+                 DammageByMagicParry,\n+                 DammageByMagicAttack,\n+                 DammageByMagicThrust,\n+\n+                 MagicKey,\n+                 CrystalBall,\n+                 MagicSpring,\n+                 SackOfCoal1,\n+                 SackOfCoal2,\n+                 HotIron,\n+                 HandGrenade,\n+                 MagicSword,\n+                 MagicShoes,\n+                 SleepPotion,\n+                 LumpOfIron,\n+                 TreasTrove,\n+                 SpeedPotion,\n+                 MagicShield,\n+                 VisionChest,\n+                 QuiverNormal,\n+                 QuiverMagic,\n+                 HealingPotion,\n+                 LowFreePool,\n+                 HighFreePool,\n+                 MaxNoOfTreasures,\n+\n+                 UpDateWoundsAndFatigue,\n+                 StrengthToParry,\n+                 StrengthToAttack,\n+                 StrengthToThrust,\n+                 StrengthToFireArrow,\n+                 StrengthToFireMagic,\n+                 StrengthToMove ;\n+\n+\n+CONST\n+   RequiredToParry       =   3 ;\n+   RequiredToAttack      =   5 ;\n+   RequiredToThrust      =   9 ;\n+   RequiredToFireArrow   =  10 ;\n+   RequiredToFireMagic   =  15 ;\n+   RequiredToMove        =   6 ;  (* For 9 squares *)\n+   RequiredToMagicShoes  =   3 ;  (* For 9 squares *)\n+   RequiredToMagicParry  =   1 ;\n+   RequiredToMagicAttack =   3 ;\n+   RequiredToMagicThrust =   6 ;\n+\n+   DammageByParry        =   7 ;\n+   DammageByAttack       =  13 ;\n+   DammageByThrust       =  17 ;\n+   DammageByFireArrow    =  23 ;\n+   DammageByFireMagic    =  74 ;\n+   DammageByHandGrenade  =  69 ;\n+   DammageByHotIron      =  19 ;\n+   DammageByMagicParry   =   8 ;\n+   DammageByMagicAttack  =  14 ;\n+   DammageByMagicThrust  =  18 ;\n+\n+   MagicKey              =   1 ;  (* Treasure Numbers *)\n+   CrystalBall           =   2 ;\n+   MagicSpring           =   3 ;\n+   SackOfCoal1           =   4 ;\n+   SackOfCoal2           =   5 ;\n+   HotIron               =   6 ;\n+   HandGrenade           =   7 ;\n+   MagicSword            =   8 ;\n+   MagicShoes            =   9 ;\n+   SleepPotion           =  10 ;\n+   LumpOfIron            =  11 ;\n+   TreasTrove            =  12 ;\n+   SpeedPotion           =  13 ;\n+   MagicShield           =  14 ;\n+   VisionChest           =  15 ;\n+   QuiverNormal          =  16 ;\n+   QuiverMagic           =  17 ;\n+   HealingPotion         =  18 ;\n+\n+   MaxNoOfTreasures      =  31 ;  (* An upper limit *)\n+   HighFreePool          = MaxNoOfTreasures ;\n+   LowFreePool           =  19 ;  (* start of dynamic treasures. (see AdvMath.def for static list).  *)\n+\n+TYPE\n+   FreePool     = [LowFreePool..HighFreePool] ;\n+\n+PROCEDURE UpDateWoundsAndFatigue (p: CARDINAL) ;\n+\n+PROCEDURE StrengthToParry (VAR ok: BOOLEAN) ;\n+\n+PROCEDURE StrengthToAttack (VAR ok: BOOLEAN) ;\n+\n+PROCEDURE StrengthToThrust (VAR ok: BOOLEAN) ;\n+\n+PROCEDURE StrengthToFireArrow (VAR ok: BOOLEAN) ;\n+\n+PROCEDURE StrengthToFireMagic (VAR ok: BOOLEAN) ;\n+\n+PROCEDURE StrengthToMove (n: CARDINAL ; VAR ok: BOOLEAN) ;\n+\n+\n+END AdvMath."}, {"sha": "d620665fa30f29cc10d54049fa7145a6d4fee9b4", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvMath.mod", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvMath.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvMath.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvMath.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,220 @@\n+IMPLEMENTATION MODULE AdvMath ;\n+\n+\n+FROM TimerHandler IMPORT TicksPerSecond, GetTicks ;\n+\n+FROM AdvSystem IMPORT Player, ManWeight,\n+                      PlayerNo,\n+                      TimeMinSec,\n+                      GetAccessToScreenNo, ReleaseAccessToScreenNo ;\n+\n+FROM Screen IMPORT WriteWounds, WriteFatigue, WriteCommentLine1 ;\n+\n+\n+(* No access lock on anything ! *)\n+\n+PROCEDURE UpDateWoundsAndFatigue (p: CARDINAL) ;\n+VAR\n+   HalfSecs,\n+   sec, tsec: CARDINAL ;\n+BEGIN\n+   TimeMinSec(sec) ;\n+   HalfSecs := GetTicks() DIV (TicksPerSecond DIV 2) ;    (* we want half seconds *)\n+   WITH Player[p] DO\n+      IF HalfSecs>LastSecFatigue\n+      THEN\n+         tsec := HalfSecs-LastSecFatigue ;\n+         IF Fatigue<100\n+         THEN\n+            Fatigue := Fatigue+tsec ;\n+            IF Fatigue>100\n+            THEN\n+               Fatigue := 100\n+            END ;\n+            WriteFatigue(p, Fatigue)\n+         END ;\n+         LastSecFatigue := HalfSecs\n+      END ;\n+      IF sec>LastSecWounds\n+      THEN\n+         tsec := sec-LastSecWounds ;\n+         IF tsec>5\n+         THEN\n+            LastSecWounds := sec\n+         END ;\n+         IF Wounds<100\n+         THEN\n+            Wounds := Wounds+(tsec DIV 6) ;\n+            IF Wounds>100\n+            THEN\n+               Wounds := 100\n+            END ;\n+            WriteWounds(p, Wounds)\n+         END ;\n+         LastSecWounds := sec\n+      END\n+   END\n+END UpDateWoundsAndFatigue ;\n+\n+\n+(* The following routines do use AccessToScreen when needed *)\n+\n+PROCEDURE StrengthToParry (VAR ok: BOOLEAN) ;\n+VAR\n+   p, t : CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      IF MagicSword IN TreasureOwn      (* Magic Sword *)\n+      THEN\n+         t := (Weight * RequiredToMagicParry) DIV ManWeight\n+      ELSE\n+         t := (Weight * RequiredToParry) DIV ManWeight\n+      END ;\n+      GetAccessToScreenNo( p ) ;\n+      IF t>Fatigue\n+      THEN\n+         WriteCommentLine1(p, 'too tired') ;\n+         ok := FALSE\n+      ELSE\n+         DEC( Fatigue, t ) ;\n+         WriteFatigue(p, Fatigue) ;\n+         ok := TRUE\n+      END ;\n+      ReleaseAccessToScreenNo( p )\n+   END\n+END StrengthToParry ;\n+\n+\n+PROCEDURE StrengthToAttack (VAR ok: BOOLEAN) ;\n+VAR\n+   p, t : CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      IF MagicSword IN TreasureOwn      (* Magic Sword *)\n+      THEN\n+         t := (Weight * RequiredToMagicAttack) DIV ManWeight\n+      ELSE\n+         t := (Weight * RequiredToAttack) DIV ManWeight\n+      END ;\n+      GetAccessToScreenNo( p ) ;\n+      IF t>Fatigue\n+      THEN\n+         WriteCommentLine1(p, 'too tired') ;\n+         ok := FALSE\n+      ELSE\n+         DEC( Fatigue, t ) ;\n+         WriteFatigue(p, Fatigue) ;\n+         ok := TRUE\n+      END ;\n+      ReleaseAccessToScreenNo( p )\n+   END\n+END StrengthToAttack ;\n+\n+\n+\n+PROCEDURE StrengthToThrust (VAR ok: BOOLEAN) ;\n+VAR\n+   p, t : CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      IF MagicSword IN TreasureOwn      (* Magic Sword *)\n+      THEN\n+         t := (Weight * RequiredToMagicThrust) DIV ManWeight\n+      ELSE\n+         t := (Weight * RequiredToThrust) DIV ManWeight\n+      END ;\n+      GetAccessToScreenNo( p ) ;\n+      IF t>Fatigue\n+      THEN\n+         WriteCommentLine1(p, 'too tired') ;\n+         ok := FALSE\n+      ELSE\n+         DEC( Fatigue, t ) ;\n+         WriteFatigue(p, Fatigue) ;\n+         ok := TRUE\n+      END ;\n+      ReleaseAccessToScreenNo( p )\n+   END\n+END StrengthToThrust ;\n+\n+\n+PROCEDURE StrengthToFireArrow (VAR ok: BOOLEAN) ;\n+VAR\n+   p, t : CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      t := (Weight * RequiredToFireArrow) DIV ManWeight ;\n+      GetAccessToScreenNo( p ) ;\n+      IF t>Fatigue\n+      THEN\n+         WriteCommentLine1(p, 'too tired') ;\n+         ok := FALSE\n+      ELSE\n+         DEC( Fatigue, t ) ;\n+         WriteFatigue(p, Fatigue) ;\n+         ok := TRUE\n+      END ;\n+      ReleaseAccessToScreenNo( p )\n+   END\n+END StrengthToFireArrow ;\n+\n+\n+PROCEDURE StrengthToFireMagic (VAR ok: BOOLEAN) ;\n+VAR\n+   p, t : CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      t := (Weight * RequiredToFireMagic) DIV ManWeight ;\n+      GetAccessToScreenNo( p ) ;\n+      IF t>Fatigue\n+      THEN\n+         WriteCommentLine1(p, 'too tired') ;\n+         ok := FALSE\n+      ELSE\n+         DEC( Fatigue, t ) ;\n+         WriteFatigue(p, Fatigue) ;\n+         ok := TRUE\n+      END ;\n+      ReleaseAccessToScreenNo( p )\n+   END\n+END StrengthToFireMagic ;\n+\n+\n+PROCEDURE StrengthToMove (n: CARDINAL ; VAR ok: BOOLEAN) ;\n+VAR\n+   p, t : CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      IF MagicShoes IN TreasureOwn      (* Magic Shoes *)\n+      THEN\n+         t := (((Weight * RequiredToMagicShoes) DIV 9) * n) DIV ManWeight\n+      ELSE\n+         t := (((Weight * RequiredToMove) DIV 9) * n) DIV ManWeight\n+      END ;\n+      GetAccessToScreenNo( p ) ;\n+      IF t>Fatigue\n+      THEN\n+         WriteCommentLine1(p, 'too tired') ;\n+         ok := FALSE\n+      ELSE\n+         DEC( Fatigue, t ) ;\n+         WriteFatigue(p, Fatigue) ;\n+         ok := TRUE\n+      END ;\n+      ReleaseAccessToScreenNo( p )\n+   END\n+END StrengthToMove ;\n+\n+\n+END AdvMath.\n+(*\n+ * Local variables:\n+ *  compile-command: \"make\"\n+ * End:\n+ *)"}, {"sha": "07802d0a23d9f200027502bbf2f3b2ce2558e3be", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvParse.bnf", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvParse.bnf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvParse.bnf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvParse.bnf?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,379 @@\n+% module AdvParse begin\n+IMPLEMENTATION MODULE AdvParse ;\n+\n+(*\n+   Author     : Gaius Mulley\n+   Title      : AdvParse\n+   Date       : 16/7/2005\n+   SYSTEM     : GNU Modula-2\n+   Description: parses maps.\n+*)\n+\n+FROM libc IMPORT printf ;\n+FROM SYSTEM IMPORT ADDRESS ;\n+FROM DynamicStrings IMPORT String, string, InitStringCharStar, KillString,\n+                           InitString, ConCat, ConCatChar, Mark ;\n+FROM StringConvert IMPORT stoi ;\n+FROM advflex IMPORT toktype, OpenSource, CloseSource, error, GetToken,\n+                    currenttoken, currentinteger ;\n+FROM AdvMap IMPORT Rooms, Line, DoorStatus, Door, Room, Treasure,\n+                   ActualNoOfRooms, MaxNoOfTreasures, MaxNoOfRooms,\n+                   WallsPerRoom, DoorsPerRoom, TreasureKind ;\n+FROM AdvUtil IMPORT HideTreasure ;\n+\n+\n+CONST\n+   Debugging = TRUE ;\n+\n+TYPE\n+   BITSET = SET OF toktype ;\n+\n+VAR\n+   LastInt,\n+   ExitValue     : INTEGER ;\n+\n+   CurDoor,\n+   CurWall,\n+   CurRoom       : CARDINAL ;\n+\n+\n+(*\n+   Min -\n+*)\n+\n+PROCEDURE Min (a, b: INTEGER) : INTEGER ;\n+BEGIN\n+   IF a<b\n+   THEN\n+      RETURN( a )\n+   ELSE\n+      RETURN( b )\n+   END\n+END Min ;\n+\n+\n+(*\n+   Max -\n+*)\n+\n+PROCEDURE Max (a, b: INTEGER) : INTEGER ;\n+BEGIN\n+   IF a>b\n+   THEN\n+      RETURN( a )\n+   ELSE\n+      RETURN( b )\n+   END\n+END Max ;\n+\n+\n+(*\n+   OpenFile - attempts to open a file, mapfile.\n+*)\n+\n+PROCEDURE OpenFile (mapfile: ADDRESS) : INTEGER ;\n+VAR\n+   r: INTEGER ;\n+BEGIN\n+   ExitValue := 0 ;\n+   IF OpenSource(mapfile)\n+   THEN\n+      RETURN( 0 )\n+   ELSE\n+      r := printf(\"cannot open file: %s\\n\", mapfile) ;\n+      RETURN( 1 )\n+   END ;\n+END OpenFile ;\n+\n+\n+(*\n+   CloseFile -\n+*)\n+\n+PROCEDURE CloseFile ;\n+BEGIN\n+   CloseSource\n+END CloseFile ;\n+\n+% declaration AdvParse begin\n+\n+\n+(*\n+   ErrorArray -\n+*)\n+\n+PROCEDURE ErrorArray (a: ARRAY OF CHAR) ;\n+BEGIN\n+   ErrorString(InitString(a))\n+END ErrorArray ;\n+\n+\n+(*\n+   ErrorString -\n+*)\n+\n+PROCEDURE ErrorString (s: String) ;\n+BEGIN\n+   error(string(s)) ;\n+   ExitValue := 1\n+END ErrorString ;\n+\n+\n+(*\n+   SyntaxError - after a syntax error we skip all tokens up until we reach\n+                 a stop symbol.\n+*)\n+\n+PROCEDURE SyntaxError (stopset: BITSET) ;\n+VAR\n+   r: INTEGER ;\n+BEGIN\n+   DescribeError(stopset) ;\n+   IF Debugging\n+   THEN\n+      r := printf('\\nskipping token *** ')\n+   END ;\n+   WHILE NOT (currenttoken IN stopset)\n+   DO\n+      GetToken\n+   END ;\n+   IF Debugging\n+   THEN\n+      r := printf(' ***\\n')\n+   END ;\n+   ExitValue := 1\n+END SyntaxError ;\n+\n+\n+(*\n+   SyntaxCheck -\n+*)\n+\n+PROCEDURE SyntaxCheck (stopset: BITSET) ;\n+BEGIN\n+   IF NOT (currenttoken IN stopset)\n+   THEN\n+      SyntaxError(stopset)\n+   END\n+END SyntaxCheck ;\n+\n+\n+(*\n+   WarnMissingToken - generates a warning message about a missing token, t.\n+*)\n+\n+PROCEDURE WarnMissingToken (t: toktype) ;\n+VAR\n+   s  : BITSET ;\n+   str: String ;\n+BEGIN\n+   s := BITSET{t} ;\n+   str := DescribeStop(s) ;\n+\n+   str := ConCat(InitString('syntax error,'), Mark(str)) ;\n+   ErrorString(str)\n+END WarnMissingToken ;\n+\n+\n+(*\n+   MissingToken - generates a warning message about a missing token, t.\n+*)\n+\n+PROCEDURE MissingToken (t: toktype) ;\n+VAR\n+   r: INTEGER ;\n+BEGIN\n+   WarnMissingToken(t)\n+END MissingToken ;\n+\n+\n+(*\n+   InStopSet\n+*)\n+\n+PROCEDURE InStopSet (t: toktype; stopset: BITSET) : BOOLEAN ;\n+BEGIN\n+   RETURN t IN stopset\n+END InStopSet ;\n+\n+\n+(*\n+   Expect -\n+*)\n+\n+PROCEDURE Expect (t: toktype; stopset: BITSET) ;\n+BEGIN\n+   IF currenttoken=t\n+   THEN\n+      GetToken\n+   ELSE\n+      MissingToken(t)\n+   END ;\n+   SyntaxCheck(stopset)\n+END Expect ;\n+\n+\n+PROCEDURE ParseMap (a: ADDRESS) : INTEGER ;\n+VAR\n+   r: INTEGER ;\n+BEGIN\n+   r := OpenFile(a) ;\n+   IF r=0\n+   THEN\n+      GetToken ;\n+      FileUnit(BITSET{eoftok}) ;\n+      CloseFile ;\n+      RETURN( ExitValue )\n+   ELSE\n+      RETURN( r )\n+   END\n+END ParseMap ;\n+\n+\n+(*\n+   Integer -\n+*)\n+\n+PROCEDURE Integer (stopset: BITSET) ;\n+BEGIN\n+   LastInt := currentinteger ;\n+   Expect(integertok, stopset)\n+END Integer ;\n+\n+\n+% module AdvParse end\n+\n+\n+END AdvParse.\n+% rules\n+error       'ErrorArray' 'ErrorString'\n+tokenfunc   'currenttoken'\n+\n+token   ''                eoftok      -- internal token\n+token   'ROOM'            roomtok\n+token   'DOOR'            doortok\n+token   'WALL'            walltok\n+token   'TREASURE'        treasuretok\n+token   'AT'              attok\n+token   'LEADS'           leadstok\n+token   'TO'              totok\n+token   'STATUS'          statustok\n+token   \"CLOSED\"          closedtok\n+token   \"OPEN\"            opentok\n+token   \"SECRET\"          secrettok\n+token   'IS'              istok\n+token   'END'             endtok\n+token   'END.'            enddottok\n+token   'integer number'  integertok\n+token   'RANDOMIZE'       randomizetok\n+\n+special Integer           first { < integertok > } follow { }\n+\n+BNF\n+\n+FileUnit := RoomDesc { RoomDesc } [ RandomTreasure ] \"END.\" =:\n+\n+RoomDesc := 'ROOM' Integer                            % VAR r: INTEGER ; %\n+                                                      % CurRoom := LastInt ;\n+                                                        ActualNoOfRooms := Max(CurRoom,\n+                                                                               ActualNoOfRooms) ;\n+                                                        WITH Rooms[CurRoom] DO\n+                                                           NoOfWalls := 0 ;\n+                                                           NoOfDoors := 0 ;\n+                                                           Treasures := {}\n+                                                        END ;\n+                                                        IF Debugging\n+                                                        THEN\n+                                                           r := printf('reading room %d\\n', CurRoom)\n+                                                        END %\n+        { WallDesc | DoorDesc | TreasureDesc } 'END' =:\n+\n+WallDesc := 'WALL' WallCoords { WallCoords } =:\n+\n+WallCoords :=                                         % WITH Rooms[CurRoom] DO\n+                                                           INC(NoOfWalls) ;\n+                                                           IF NoOfWalls>WallsPerRoom\n+                                                           THEN\n+                                                              ErrorArray('too many walls') ;\n+                                                              NoOfWalls := WallsPerRoom\n+                                                           END ;\n+                                                           CurWall := NoOfWalls\n+                                                        END %\n+              Integer                                 % VAR x1, y1, x2, y2: INTEGER ; %\n+                                                      % x1 := LastInt %\n+                      Integer                         % y1 := LastInt %\n+\n+                              Integer                 % x2 := LastInt %\n+\n+                                      Integer         % y2 := LastInt ;\n+                                                        WITH Rooms[CurRoom].Walls[CurWall] DO\n+                                                           X1 := Min(x1, x2) ;\n+                                                           Y1 := Min(y1, y2) ;\n+                                                           X2 := Max(x1, x2) ;\n+                                                           Y2 := Max(y1, y2) ;\n+                                                           IF (X1#X2) AND (Y1#Y2)\n+                                                           THEN\n+                                                              error(string(InitString(\"not allowed diagonal wall\")))\n+                                                           END\n+                                                        END %\n+           =:\n+\n+DoorDesc := 'DOOR' DoorCoords { DoorCoords } =:\n+\n+DoorCoords :=                                         % WITH Rooms[CurRoom] DO\n+                                                           INC(NoOfDoors) ;\n+                                                           IF NoOfDoors>DoorsPerRoom\n+                                                           THEN\n+                                                              ErrorArray('too many doors') ;\n+                                                              NoOfDoors := DoorsPerRoom\n+                                                           END ;\n+                                                           CurDoor := NoOfDoors\n+                                                        END %\n+              Integer                                 % VAR x1, y1, x2, y2: INTEGER ; %\n+                                                      % x1 := LastInt %\n+                      Integer                         % y1 := LastInt %\n+\n+                              Integer                 % x2 := LastInt %\n+\n+                                      Integer         % y2 := LastInt ;\n+                                                        WITH Rooms[CurRoom].Doors[CurDoor].Position DO\n+                                                           X1 := Min(x1, x2) ;\n+                                                           Y1 := Min(y1, y2) ;\n+                                                           X2 := Max(x1, x2) ;\n+                                                           Y2 := Max(y1, y2) ;\n+                                                           IF (X1#X2) AND (Y1#Y2)\n+                                                           THEN\n+                                                              error(string(InitString(\"not allowed diagonal door\")))\n+                                                           END\n+\n+                                                        END %\n+\n+              Status\n+              'LEADS' 'TO' Integer                    % Rooms[CurRoom].Doors[CurDoor].LeadsTo := LastInt %\n+           =:\n+\n+Status := 'STATUS' ( 'OPEN'                           % Rooms[CurRoom].Doors[CurDoor].StateOfDoor := Open %\n+                      | 'CLOSED'                      % Rooms[CurRoom].Doors[CurDoor].StateOfDoor := Closed %\n+                      | 'SECRET'                      % Rooms[CurRoom].Doors[CurDoor].StateOfDoor := Secret %\n+                   )\n+       =:\n+\n+TreasureDesc := 'TREASURE' 'AT' Integer\n+                                                      % VAR x, y: INTEGER ; %\n+                                                      % x := LastInt %\n+                            Integer                   % y := LastInt %\n+                       'IS' Integer                   % WITH Treasure[LastInt] DO\n+                                                           Xpos := x ;\n+                                                           Ypos := y ;\n+                                                           Rm := CurRoom ;\n+                                                           kind := onfloor\n+                                                        END ;\n+                                                        INCL(Rooms[CurRoom].Treasures, LastInt) %\n+          =:\n+\n+RandomTreasure := 'RANDOMIZE' 'TREASURE' Integer      % HideTreasure(LastInt) %\n+                   { Integer                          % HideTreasure(LastInt) %\n+                             }\n+               =:\n+\n+FNB"}, {"sha": "696e1d27693ab0546bcb727b24db83acdb37e567", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvParse.def", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvParse.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvParse.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvParse.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,18 @@\n+DEFINITION MODULE AdvParse ;\n+\n+(*\n+    Title      : AdvParse\n+    Author     : Gaius Mulley\n+    System     : GNU Modula-2\n+    Date       : Sun Jul 17 14:26:41 2005\n+    Revision   : $Version$ \n+    Description: provides a simple interface to the parser.\n+*)\n+\n+FROM SYSTEM IMPORT ADDRESS ;\n+EXPORT QUALIFIED ParseMap ;\n+\n+PROCEDURE ParseMap (a: ADDRESS) : INTEGER ;\n+\n+\n+END AdvParse."}, {"sha": "6a5ca4c9f4a2ea0b586dce7c9c2053c1eee79605", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvParse.mod", "status": "added", "additions": 873, "deletions": 0, "changes": 873, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvParse.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvParse.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvParse.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,873 @@\n+(* it is advisable not to edit this file as it was automatically generated from the grammer file AdvParse.bnf *)\n+# 2 \"AdvParse.bnf\"\n+\n+IMPLEMENTATION MODULE AdvParse ;\n+\n+(*\n+   Author     : Gaius Mulley\n+   Title      : AdvParse\n+   Date       : 16/7/2005\n+   SYSTEM     : GNU Modula-2\n+   Description: parses maps.\n+*)\n+\n+FROM libc IMPORT printf ;\n+FROM SYSTEM IMPORT ADDRESS ;\n+FROM DynamicStrings IMPORT String, string, InitStringCharStar, KillString,\n+                           InitString, ConCat, ConCatChar, Mark ;\n+FROM StringConvert IMPORT stoi ;\n+FROM advflex IMPORT toktype, OpenSource, CloseSource, error, GetToken,\n+                    currenttoken, currentinteger ;\n+FROM AdvMap IMPORT Rooms, Line, DoorStatus, Door, Room, Treasure,\n+                   ActualNoOfRooms, MaxNoOfRooms,\n+                   WallsPerRoom, DoorsPerRoom, TreasureKind ;\n+FROM AdvUtil IMPORT HideTreasure ;\n+\n+FROM AdvMath IMPORT MaxNoOfTreasures ;\n+\n+\n+CONST\n+   Debugging = TRUE ;\n+\n+TYPE\n+   SetOfTok = SET OF toktype ;\n+\n+VAR\n+   LastInt,\n+   ExitValue     : INTEGER ;\n+\n+   CurDoor,\n+   CurWall,\n+   CurRoom       : CARDINAL ;\n+\n+\n+(*\n+   Min -\n+*)\n+\n+PROCEDURE Min (a, b: INTEGER) : INTEGER ;\n+BEGIN\n+   IF a<b\n+   THEN\n+      RETURN( a )\n+   ELSE\n+      RETURN( b )\n+   END\n+END Min ;\n+\n+\n+(*\n+   Max -\n+*)\n+\n+PROCEDURE Max (a, b: INTEGER) : INTEGER ;\n+BEGIN\n+   IF a>b\n+   THEN\n+      RETURN( a )\n+   ELSE\n+      RETURN( b )\n+   END\n+END Max ;\n+\n+\n+(*\n+   OpenFile - attempts to open a file, mapfile.\n+*)\n+\n+PROCEDURE OpenFile (mapfile: ADDRESS) : INTEGER ;\n+VAR\n+   r: INTEGER ;\n+BEGIN\n+   ExitValue := 0 ;\n+   IF OpenSource (mapfile)\n+   THEN\n+      RETURN 0\n+   ELSE\n+      r := printf (\"cannot open file: %s\\n\", mapfile) ;\n+      RETURN 1\n+   END ;\n+END OpenFile ;\n+\n+\n+(*\n+   CloseFile -\n+*)\n+\n+PROCEDURE CloseFile ;\n+BEGIN\n+   CloseSource\n+END CloseFile ;\n+\n+(*\n+   expecting token set defined as an enumerated type\n+   (eoftok, roomtok, doortok, walltok, treasuretok, attok, leadstok, totok, statustok, closedtok, opentok, secrettok, istok, endtok, enddottok, integertok, randomizetok) ;\n+*)\n+\n+(* %%%FORWARD%%%\n+PROCEDURE Integer (stopset: SetOfTok) ; FORWARD ;\n+PROCEDURE FileUnit (stopset: SetOfTok) ; FORWARD ;\n+PROCEDURE RoomDesc (stopset: SetOfTok) ; FORWARD ;\n+PROCEDURE WallDesc (stopset: SetOfTok) ; FORWARD ;\n+PROCEDURE WallCoords (stopset: SetOfTok) ; FORWARD ;\n+PROCEDURE DoorDesc (stopset: SetOfTok) ; FORWARD ;\n+PROCEDURE DoorCoords (stopset: SetOfTok) ; FORWARD ;\n+PROCEDURE Status (stopset: SetOfTok) ; FORWARD ;\n+PROCEDURE TreasureDesc (stopset: SetOfTok) ; FORWARD ;\n+PROCEDURE RandomTreasure (stopset: SetOfTok) ; FORWARD ;\n+   %%%FORWARD%%% *)\n+\n+(*\n+   DescribeStop - issues a message explaining what tokens were expected\n+*)\n+\n+PROCEDURE DescribeStop (stopset: SetOfTok) : String ;\n+VAR\n+   n      : CARDINAL ;\n+   str,\n+   message: String ;\n+BEGIN\n+   n := 0 ;\n+   message := InitString('') ;\n+   IF randomizetok IN stopset\n+   THEN\n+      message := ConCat(ConCatChar(message, ' '), Mark(InitString(\"`RANDOMIZE'\"))) ; INC(n)\n+   END ;\n+   IF integertok IN stopset\n+   THEN\n+      message := ConCat(ConCatChar(message, ' '), Mark(InitString(\"`integer number'\"))) ; INC(n)\n+   END ;\n+   IF enddottok IN stopset\n+   THEN\n+      message := ConCat(ConCatChar(message, ' '), Mark(InitString(\"`END.'\"))) ; INC(n)\n+   END ;\n+   IF endtok IN stopset\n+   THEN\n+      message := ConCat(ConCatChar(message, ' '), Mark(InitString(\"`END'\"))) ; INC(n)\n+   END ;\n+   IF istok IN stopset\n+   THEN\n+      message := ConCat(ConCatChar(message, ' '), Mark(InitString(\"`IS'\"))) ; INC(n)\n+   END ;\n+   IF secrettok IN stopset\n+   THEN\n+      message := ConCat(ConCatChar(message, ' '), Mark(InitString(\"`SECRET'\"))) ; INC(n)\n+   END ;\n+   IF opentok IN stopset\n+   THEN\n+      message := ConCat(ConCatChar(message, ' '), Mark(InitString(\"`OPEN'\"))) ; INC(n)\n+   END ;\n+   IF closedtok IN stopset\n+   THEN\n+      message := ConCat(ConCatChar(message, ' '), Mark(InitString(\"`CLOSED'\"))) ; INC(n)\n+   END ;\n+   IF statustok IN stopset\n+   THEN\n+      message := ConCat(ConCatChar(message, ' '), Mark(InitString(\"`STATUS'\"))) ; INC(n)\n+   END ;\n+   IF totok IN stopset\n+   THEN\n+      message := ConCat(ConCatChar(message, ' '), Mark(InitString(\"`TO'\"))) ; INC(n)\n+   END ;\n+   IF leadstok IN stopset\n+   THEN\n+      message := ConCat(ConCatChar(message, ' '), Mark(InitString(\"`LEADS'\"))) ; INC(n)\n+   END ;\n+   IF attok IN stopset\n+   THEN\n+      message := ConCat(ConCatChar(message, ' '), Mark(InitString(\"`AT'\"))) ; INC(n)\n+   END ;\n+   IF treasuretok IN stopset\n+   THEN\n+      message := ConCat(ConCatChar(message, ' '), Mark(InitString(\"`TREASURE'\"))) ; INC(n)\n+   END ;\n+   IF walltok IN stopset\n+   THEN\n+      message := ConCat(ConCatChar(message, ' '), Mark(InitString(\"`WALL'\"))) ; INC(n)\n+   END ;\n+   IF doortok IN stopset\n+   THEN\n+      message := ConCat(ConCatChar(message, ' '), Mark(InitString(\"`DOOR'\"))) ; INC(n)\n+   END ;\n+   IF roomtok IN stopset\n+   THEN\n+      message := ConCat(ConCatChar(message, ' '), Mark(InitString(\"`ROOM'\"))) ; INC(n)\n+   END ;\n+   IF eoftok IN stopset\n+   THEN\n+      (* eoftok has no token name (needed to generate error messages) *)\n+   END ;\n+\n+   IF n=0\n+   THEN\n+      str := InitString(' syntax error') ;\n+      message := KillString(message) ;\n+   ELSIF n=1\n+   THEN\n+      str := ConCat(message, Mark(InitString(' missing '))) ;\n+   ELSE\n+      str := ConCat(InitString(' expecting one of'), message) ;\n+      message := KillString(message) ;\n+   END ;\n+   RETURN( str )\n+END DescribeStop ;\n+\n+\n+(*\n+   DescribeError - issues a message explaining what tokens were expected\n+*)\n+\n+PROCEDURE DescribeError (stopset: SetOfTok) ;\n+VAR\n+   str: String ;\n+BEGIN\n+   str := InitString('') ;\n+   CASE currenttoken OF\n+\n+   randomizetok: str := ConCat(InitString(\"syntax error, found `RANDOMIZE'\"), Mark(str)) |\n+   integertok: str := ConCat(InitString(\"syntax error, found `integer number'\"), Mark(str)) |\n+   enddottok: str := ConCat(InitString(\"syntax error, found `END.'\"), Mark(str)) |\n+   endtok: str := ConCat(InitString(\"syntax error, found `END'\"), Mark(str)) |\n+   istok: str := ConCat(InitString(\"syntax error, found `IS'\"), Mark(str)) |\n+   secrettok: str := ConCat(InitString(\"syntax error, found `SECRET'\"), Mark(str)) |\n+   opentok: str := ConCat(InitString(\"syntax error, found `OPEN'\"), Mark(str)) |\n+   closedtok: str := ConCat(InitString(\"syntax error, found `CLOSED'\"), Mark(str)) |\n+   statustok: str := ConCat(InitString(\"syntax error, found `STATUS'\"), Mark(str)) |\n+   totok: str := ConCat(InitString(\"syntax error, found `TO'\"), Mark(str)) |\n+   leadstok: str := ConCat(InitString(\"syntax error, found `LEADS'\"), Mark(str)) |\n+   attok: str := ConCat(InitString(\"syntax error, found `AT'\"), Mark(str)) |\n+   treasuretok: str := ConCat(InitString(\"syntax error, found `TREASURE'\"), Mark(str)) |\n+   walltok: str := ConCat(InitString(\"syntax error, found `WALL'\"), Mark(str)) |\n+   doortok: str := ConCat(InitString(\"syntax error, found `DOOR'\"), Mark(str)) |\n+   roomtok: str := ConCat(InitString(\"syntax error, found `ROOM'\"), Mark(str)) |\n+   eoftok: str := ConCat(InitString(\"syntax error, found `'\"), Mark(str))\n+   ELSE\n+   END ;\n+   ErrorString(str) ;\n+END DescribeError ;\n+# 99 \"AdvParse.bnf\"\n+\n+\n+\n+(*\n+   ErrorArray -\n+*)\n+\n+PROCEDURE ErrorArray (a: ARRAY OF CHAR) ;\n+BEGIN\n+   ErrorString(InitString(a))\n+END ErrorArray ;\n+\n+\n+(*\n+   ErrorString -\n+*)\n+\n+PROCEDURE ErrorString (s: String) ;\n+BEGIN\n+   error(string(s)) ;\n+   ExitValue := 1\n+END ErrorString ;\n+\n+\n+(*\n+   SyntaxError - after a syntax error we skip all tokens up until we reach\n+                 a stop symbol.\n+*)\n+\n+PROCEDURE SyntaxError (stopset: SetOfTok) ;\n+VAR\n+   r: INTEGER ;\n+BEGIN\n+   DescribeError(stopset) ;\n+   IF Debugging\n+   THEN\n+      r := printf('\\nskipping token *** ')\n+   END ;\n+   WHILE NOT (currenttoken IN stopset)\n+   DO\n+      GetToken\n+   END ;\n+   IF Debugging\n+   THEN\n+      r := printf(' ***\\n')\n+   END ;\n+   ExitValue := 1\n+END SyntaxError ;\n+\n+\n+(*\n+   SyntaxCheck -\n+*)\n+\n+PROCEDURE SyntaxCheck (stopset: SetOfTok) ;\n+BEGIN\n+   IF NOT (currenttoken IN stopset)\n+   THEN\n+      SyntaxError(stopset)\n+   END\n+END SyntaxCheck ;\n+\n+\n+(*\n+   WarnMissingToken - generates a warning message about a missing token, t.\n+*)\n+\n+PROCEDURE WarnMissingToken (t: toktype) ;\n+VAR\n+   s  : SetOfTok ;\n+   str: String ;\n+BEGIN\n+   s := SetOfTok{t} ;\n+   str := DescribeStop(s) ;\n+\n+   str := ConCat(InitString('syntax error,'), Mark(str)) ;\n+   ErrorString(str)\n+END WarnMissingToken ;\n+\n+\n+(*\n+   MissingToken - generates a warning message about a missing token, t.\n+*)\n+\n+PROCEDURE MissingToken (t: toktype) ;\n+VAR\n+   r: INTEGER ;\n+BEGIN\n+   WarnMissingToken(t)\n+END MissingToken ;\n+\n+\n+(*\n+   InStopSet\n+*)\n+\n+PROCEDURE InStopSet (t: toktype; stopset: SetOfTok) : BOOLEAN ;\n+BEGIN\n+   RETURN t IN stopset\n+END InStopSet ;\n+\n+\n+(*\n+   Expect -\n+*)\n+\n+PROCEDURE Expect (t: toktype; stopset: SetOfTok) ;\n+BEGIN\n+   IF currenttoken=t\n+   THEN\n+      GetToken\n+   ELSE\n+      MissingToken(t)\n+   END ;\n+   SyntaxCheck(stopset)\n+END Expect ;\n+\n+\n+PROCEDURE ParseMap (a: ADDRESS) : INTEGER ;\n+VAR\n+   r: INTEGER ;\n+BEGIN\n+   r := OpenFile(a) ;\n+   IF r=0\n+   THEN\n+      GetToken ;\n+      FileUnit(SetOfTok{eoftok}) ;\n+      CloseFile ;\n+      RETURN( ExitValue )\n+   ELSE\n+      RETURN( r )\n+   END\n+END ParseMap ;\n+\n+\n+(*\n+   Integer -\n+*)\n+\n+PROCEDURE Integer (stopset: SetOfTok) ;\n+BEGIN\n+   LastInt := currentinteger ;\n+   Expect(integertok, stopset)\n+END Integer ;\n+\n+\n+(*\n+   Integer :=\n+\n+   first  symbols:integertok\n+\n+   cannot reachend\n+*)\n+(*\n+   FileUnit := RoomDesc { RoomDesc  } [ RandomTreasure  ] 'END.'\n+\n+   first  symbols:roomtok\n+\n+   cannot reachend\n+*)\n+\n+# 274 \"AdvParse.bnf\"\n+PROCEDURE FileUnit (stopset: SetOfTok) ;\n+# 274 \"AdvParse.bnf\"\n+BEGIN\n+# 274 \"AdvParse.bnf\"\n+   RoomDesc(stopset + SetOfTok{enddottok, roomtok, randomizetok}) ;\n+# 274 \"AdvParse.bnf\"\n+   WHILE currenttoken=roomtok DO\n+      RoomDesc(stopset + SetOfTok{enddottok, randomizetok, roomtok}) ;\n+   END (* while *) ;\n+# 274 \"AdvParse.bnf\"\n+   IF currenttoken=randomizetok\n+   THEN\n+      RandomTreasure(stopset + SetOfTok{enddottok}) ;\n+   END ;\n+# 274 \"AdvParse.bnf\"\n+   Expect(enddottok, stopset) ;\n+END FileUnit ;\n+\n+\n+(*\n+   RoomDesc := 'ROOM' Integer\n+               % VAR r: INTEGER ;  %\n+\n+               % CurRoom := LastInt ;\n+                 ActualNoOfRooms := Max(CurRoom,\n+                                        ActualNoOfRooms) ;\n+                 WITH Rooms[CurRoom] DO\n+                    NoOfWalls := 0 ;\n+                    NoOfDoors := 0 ;\n+                    Treasures := {}\n+                 END ;\n+                 IF Debugging\n+                 THEN\n+                    r := printf('reading room %d\\n', CurRoom)\n+                 END  %\n+               { WallDesc  | DoorDesc  | TreasureDesc  } 'END'\n+\n+   first  symbols:roomtok\n+\n+   cannot reachend\n+*)\n+\n+# 276 \"AdvParse.bnf\"\n+PROCEDURE RoomDesc (stopset: SetOfTok) ;\n+VAR\n+ r: INTEGER ;\n+# 276 \"AdvParse.bnf\"\n+BEGIN\n+# 276 \"AdvParse.bnf\"\n+   Expect(roomtok, stopset + SetOfTok{integertok}) ;\n+# 276 \"AdvParse.bnf\"\n+   Integer(stopset + SetOfTok{endtok, walltok, doortok, treasuretok}) ;\n+# 276 \"AdvParse.bnf\"\n+# 277 \"AdvParse.bnf\"\n+# 288 \"AdvParse.bnf\"\n+   CurRoom := LastInt ;\n+   ActualNoOfRooms := Max(CurRoom,\n+                          ActualNoOfRooms) ;\n+   WITH Rooms[CurRoom] DO\n+      NoOfWalls := 0 ;\n+      NoOfDoors := 0 ;\n+      Treasures := {}\n+   END ;\n+   IF Debugging\n+   THEN\n+      r := printf('reading room %d\\n', CurRoom)\n+   END  ;\n+# 289 \"AdvParse.bnf\"\n+   IF (currenttoken IN SetOfTok{treasuretok, doortok, walltok})\n+   THEN\n+      (* seen optional { | } expression *)\n+      WHILE (currenttoken IN SetOfTok{treasuretok, doortok, walltok}) DO\n+# 289 \"AdvParse.bnf\"\n+         IF currenttoken=walltok\n+         THEN\n+            WallDesc(stopset + SetOfTok{endtok, treasuretok, doortok, walltok}) ;\n+# 289 \"AdvParse.bnf\"\n+         ELSIF currenttoken=doortok\n+         THEN\n+            DoorDesc(stopset + SetOfTok{endtok, treasuretok, doortok, walltok}) ;\n+# 289 \"AdvParse.bnf\"\n+         ELSIF currenttoken=treasuretok\n+         THEN\n+            TreasureDesc(stopset + SetOfTok{endtok, treasuretok, doortok, walltok}) ;\n+         END ;\n+         (* end of optional { | } expression *)\n+      END ;\n+   END ;\n+# 289 \"AdvParse.bnf\"\n+Expect(endtok, stopset) ;\n+END RoomDesc ;\n+\n+\n+(*\n+   WallDesc := 'WALL' WallCoords { WallCoords  }\n+\n+   first  symbols:walltok\n+\n+   cannot reachend\n+*)\n+\n+# 291 \"AdvParse.bnf\"\n+PROCEDURE WallDesc (stopset: SetOfTok) ;\n+# 291 \"AdvParse.bnf\"\n+BEGIN\n+# 291 \"AdvParse.bnf\"\n+   Expect(walltok, stopset + SetOfTok{integertok}) ;\n+# 291 \"AdvParse.bnf\"\n+   WallCoords(stopset + SetOfTok{integertok}) ;\n+# 291 \"AdvParse.bnf\"\n+   WHILE currenttoken=integertok DO\n+      WallCoords(stopset + SetOfTok{integertok}) ;\n+   END (* while *) ;\n+END WallDesc ;\n+\n+\n+(*\n+   WallCoords :=\n+                 % WITH Rooms[CurRoom] DO\n+                      INC(NoOfWalls) ;\n+                      IF NoOfWalls>WallsPerRoom\n+                      THEN\n+                         ErrorArray('too many walls') ;\n+                         NoOfWalls := WallsPerRoom\n+                      END ;\n+                      CurWall := NoOfWalls\n+                   END  %\n+                 Integer\n+                 % VAR x1, y1, x2, y2: INTEGER ;  %\n+\n+                 % x1 := LastInt  %\n+                 Integer\n+                 % y1 := LastInt  %\n+                 Integer\n+                 % x2 := LastInt  %\n+                 Integer\n+                 % y2 := LastInt ;\n+                   WITH Rooms[CurRoom].Walls[CurWall] DO\n+                      X1 := Min(x1, x2) ;\n+                      Y1 := Min(y1, y2) ;\n+                      X2 := Max(x1, x2) ;\n+                      Y2 := Max(y1, y2) ;\n+                      IF (X1#X2) AND (Y1#Y2)\n+                      THEN\n+                         error(string(InitString(\"not allowed diagonal wall\")))\n+                      END\n+                   END  %\n+\n+\n+   first  symbols:integertok\n+\n+   cannot reachend\n+*)\n+\n+# 293 \"AdvParse.bnf\"\n+PROCEDURE WallCoords (stopset: SetOfTok) ;\n+VAR\n+ x1, y1, x2, y2: INTEGER ;\n+# 293 \"AdvParse.bnf\"\n+BEGIN\n+# 293 \"AdvParse.bnf\"\n+# 301 \"AdvParse.bnf\"\n+   WITH Rooms[CurRoom] DO\n+      INC(NoOfWalls) ;\n+      IF NoOfWalls>WallsPerRoom\n+      THEN\n+         ErrorArray('too many walls') ;\n+         NoOfWalls := WallsPerRoom\n+      END ;\n+      CurWall := NoOfWalls\n+   END  ;\n+# 302 \"AdvParse.bnf\"\n+   Integer(stopset + SetOfTok{integertok}) ;\n+# 302 \"AdvParse.bnf\"\n+# 303 \"AdvParse.bnf\"\n+   x1 := LastInt  ;\n+# 304 \"AdvParse.bnf\"\n+   Integer(stopset + SetOfTok{integertok}) ;\n+# 304 \"AdvParse.bnf\"\n+   y1 := LastInt  ;\n+# 306 \"AdvParse.bnf\"\n+   Integer(stopset + SetOfTok{integertok}) ;\n+# 306 \"AdvParse.bnf\"\n+   x2 := LastInt  ;\n+# 308 \"AdvParse.bnf\"\n+   Integer(stopset) ;\n+# 308 \"AdvParse.bnf\"\n+# 318 \"AdvParse.bnf\"\n+   y2 := LastInt ;\n+   WITH Rooms[CurRoom].Walls[CurWall] DO\n+      X1 := Min(x1, x2) ;\n+      Y1 := Min(y1, y2) ;\n+      X2 := Max(x1, x2) ;\n+      Y2 := Max(y1, y2) ;\n+      IF (X1#X2) AND (Y1#Y2)\n+      THEN\n+         error(string(InitString(\"not allowed diagonal wall\")))\n+      END\n+   END  ;\n+END WallCoords ;\n+\n+\n+(*\n+   DoorDesc := 'DOOR' DoorCoords { DoorCoords  }\n+\n+   first  symbols:doortok\n+\n+   cannot reachend\n+*)\n+\n+# 321 \"AdvParse.bnf\"\n+PROCEDURE DoorDesc (stopset: SetOfTok) ;\n+# 321 \"AdvParse.bnf\"\n+BEGIN\n+# 321 \"AdvParse.bnf\"\n+   Expect(doortok, stopset + SetOfTok{integertok}) ;\n+# 321 \"AdvParse.bnf\"\n+   DoorCoords(stopset + SetOfTok{integertok}) ;\n+# 321 \"AdvParse.bnf\"\n+   WHILE currenttoken=integertok DO\n+      DoorCoords(stopset + SetOfTok{integertok}) ;\n+   END (* while *) ;\n+END DoorDesc ;\n+\n+\n+(*\n+   DoorCoords :=\n+                 % WITH Rooms[CurRoom] DO\n+                      INC(NoOfDoors) ;\n+                      IF NoOfDoors>DoorsPerRoom\n+                      THEN\n+                         ErrorArray('too many doors') ;\n+                         NoOfDoors := DoorsPerRoom\n+                      END ;\n+                      CurDoor := NoOfDoors\n+                   END  %\n+                 Integer\n+                 % VAR x1, y1, x2, y2: INTEGER ;  %\n+\n+                 % x1 := LastInt  %\n+                 Integer\n+                 % y1 := LastInt  %\n+                 Integer\n+                 % x2 := LastInt  %\n+                 Integer\n+                 % y2 := LastInt ;\n+                   WITH Rooms[CurRoom].Doors[CurDoor].Position DO\n+                      X1 := Min(x1, x2) ;\n+                      Y1 := Min(y1, y2) ;\n+                      X2 := Max(x1, x2) ;\n+                      Y2 := Max(y1, y2) ;\n+                      IF (X1#X2) AND (Y1#Y2)\n+                      THEN\n+                         error(string(InitString(\"not allowed diagonal door\")))\n+                      END\n+\n+                   END  %\n+                 Status 'LEADS' 'TO' Integer\n+                 % Rooms[CurRoom].Doors[CurDoor].LeadsTo := LastInt  %\n+\n+\n+   first  symbols:integertok\n+\n+   cannot reachend\n+*)\n+\n+# 323 \"AdvParse.bnf\"\n+PROCEDURE DoorCoords (stopset: SetOfTok) ;\n+VAR\n+ x1, y1, x2, y2: INTEGER ;\n+# 323 \"AdvParse.bnf\"\n+BEGIN\n+# 323 \"AdvParse.bnf\"\n+# 331 \"AdvParse.bnf\"\n+   WITH Rooms[CurRoom] DO\n+      INC(NoOfDoors) ;\n+      IF NoOfDoors>DoorsPerRoom\n+      THEN\n+         ErrorArray('too many doors') ;\n+         NoOfDoors := DoorsPerRoom\n+      END ;\n+      CurDoor := NoOfDoors\n+   END  ;\n+# 332 \"AdvParse.bnf\"\n+   Integer(stopset + SetOfTok{integertok}) ;\n+# 332 \"AdvParse.bnf\"\n+# 333 \"AdvParse.bnf\"\n+   x1 := LastInt  ;\n+# 334 \"AdvParse.bnf\"\n+   Integer(stopset + SetOfTok{integertok}) ;\n+# 334 \"AdvParse.bnf\"\n+   y1 := LastInt  ;\n+# 336 \"AdvParse.bnf\"\n+   Integer(stopset + SetOfTok{integertok}) ;\n+# 336 \"AdvParse.bnf\"\n+   x2 := LastInt  ;\n+# 338 \"AdvParse.bnf\"\n+   Integer(stopset + SetOfTok{statustok}) ;\n+# 338 \"AdvParse.bnf\"\n+# 349 \"AdvParse.bnf\"\n+   y2 := LastInt ;\n+   WITH Rooms[CurRoom].Doors[CurDoor].Position DO\n+      X1 := Min(x1, x2) ;\n+      Y1 := Min(y1, y2) ;\n+      X2 := Max(x1, x2) ;\n+      Y2 := Max(y1, y2) ;\n+      IF (X1#X2) AND (Y1#Y2)\n+      THEN\n+         error(string(InitString(\"not allowed diagonal door\")))\n+      END\n+\n+   END  ;\n+# 352 \"AdvParse.bnf\"\n+   Status(stopset + SetOfTok{leadstok}) ;\n+# 352 \"AdvParse.bnf\"\n+   Expect(leadstok, stopset + SetOfTok{totok}) ;\n+# 352 \"AdvParse.bnf\"\n+   Expect(totok, stopset + SetOfTok{integertok}) ;\n+# 352 \"AdvParse.bnf\"\n+   Integer(stopset) ;\n+# 352 \"AdvParse.bnf\"\n+   Rooms[CurRoom].Doors[CurDoor].LeadsTo := LastInt  ;\n+END DoorCoords ;\n+\n+\n+(*\n+   Status := 'STATUS' ( 'OPEN'\n+                        % Rooms[CurRoom].Doors[CurDoor].StateOfDoor := Open  %\n+                         | 'CLOSED'\n+                        % Rooms[CurRoom].Doors[CurDoor].StateOfDoor := Closed  %\n+                         | 'SECRET'\n+                        % Rooms[CurRoom].Doors[CurDoor].StateOfDoor := Secret  %\n+                         )\n+\n+   first  symbols:statustok\n+\n+   cannot reachend\n+*)\n+\n+# 355 \"AdvParse.bnf\"\n+PROCEDURE Status (stopset: SetOfTok) ;\n+# 355 \"AdvParse.bnf\"\n+BEGIN\n+# 355 \"AdvParse.bnf\"\n+   Expect(statustok, stopset + SetOfTok{opentok, closedtok, secrettok}) ;\n+# 355 \"AdvParse.bnf\"\n+   IF currenttoken=opentok\n+   THEN\n+      Expect(opentok, stopset) ;\n+# 355 \"AdvParse.bnf\"\n+      Rooms[CurRoom].Doors[CurDoor].StateOfDoor := Open  ;\n+# 356 \"AdvParse.bnf\"\n+   ELSIF currenttoken=closedtok\n+   THEN\n+      Expect(closedtok, stopset) ;\n+# 356 \"AdvParse.bnf\"\n+      Rooms[CurRoom].Doors[CurDoor].StateOfDoor := Closed  ;\n+# 357 \"AdvParse.bnf\"\n+   ELSIF currenttoken=secrettok\n+   THEN\n+      Expect(secrettok, stopset) ;\n+# 357 \"AdvParse.bnf\"\n+      Rooms[CurRoom].Doors[CurDoor].StateOfDoor := Secret  ;\n+   ELSE\n+      ErrorArray('expecting one of: SECRET CLOSED OPEN')\n+   END ;\n+END Status ;\n+\n+\n+(*\n+   TreasureDesc := 'TREASURE' 'AT' Integer\n+                   % VAR x, y: INTEGER ;  %\n+\n+                   % x := LastInt  %\n+                   Integer\n+                   % y := LastInt  %\n+                   'IS' Integer\n+                   % WITH Treasure[LastInt] DO\n+                        Xpos := x ;\n+                        Ypos := y ;\n+                        Rm := CurRoom\n+                     END ;\n+                     INCL(Rooms[CurRoom].Treasures, LastInt)  %\n+\n+\n+   first  symbols:treasuretok\n+\n+   cannot reachend\n+*)\n+\n+# 361 \"AdvParse.bnf\"\n+PROCEDURE TreasureDesc (stopset: SetOfTok) ;\n+VAR\n+ x, y: INTEGER ;\n+# 361 \"AdvParse.bnf\"\n+BEGIN\n+# 361 \"AdvParse.bnf\"\n+   Expect(treasuretok, stopset + SetOfTok{attok}) ;\n+# 361 \"AdvParse.bnf\"\n+   Expect(attok, stopset + SetOfTok{integertok}) ;\n+# 362 \"AdvParse.bnf\"\n+   Integer(stopset + SetOfTok{integertok}) ;\n+# 362 \"AdvParse.bnf\"\n+# 363 \"AdvParse.bnf\"\n+   x := LastInt  ;\n+# 364 \"AdvParse.bnf\"\n+   Integer(stopset + SetOfTok{istok}) ;\n+# 364 \"AdvParse.bnf\"\n+   y := LastInt  ;\n+# 365 \"AdvParse.bnf\"\n+   Expect(istok, stopset + SetOfTok{integertok}) ;\n+# 365 \"AdvParse.bnf\"\n+   Integer(stopset) ;\n+# 365 \"AdvParse.bnf\"\n+# 370 \"AdvParse.bnf\"\n+   WITH Treasure[LastInt] DO\n+      Xpos := x ;\n+      Ypos := y ;\n+      Rm := CurRoom ;\n+      kind := onfloor\n+   END ;\n+   INCL(Rooms[CurRoom].Treasures, VAL(CARDINAL, LastInt))\n+END TreasureDesc ;\n+\n+\n+(*\n+   RandomTreasure := 'RANDOMIZE' 'TREASURE' Integer\n+                     % HideTreasure(LastInt)  %\n+                     { Integer\n+                       % HideTreasure(LastInt)  %\n+                        }\n+\n+   first  symbols:randomizetok\n+\n+   cannot reachend\n+*)\n+\n+# 373 \"AdvParse.bnf\"\n+PROCEDURE RandomTreasure (stopset: SetOfTok) ;\n+# 373 \"AdvParse.bnf\"\n+BEGIN\n+# 373 \"AdvParse.bnf\"\n+   Expect(randomizetok, stopset + SetOfTok{treasuretok}) ;\n+# 373 \"AdvParse.bnf\"\n+   Expect(treasuretok, stopset + SetOfTok{integertok}) ;\n+# 373 \"AdvParse.bnf\"\n+   Integer(stopset + SetOfTok{integertok}) ;\n+# 373 \"AdvParse.bnf\"\n+   HideTreasure(LastInt)  ;\n+# 374 \"AdvParse.bnf\"\n+   WHILE currenttoken=integertok DO\n+      Integer(stopset + SetOfTok{integertok}) ;\n+# 374 \"AdvParse.bnf\"\n+      HideTreasure(LastInt)  ;\n+   END (* while *) ;\n+END RandomTreasure ;\n+\n+\n+# 245 \"AdvParse.bnf\"\n+\n+\n+\n+END AdvParse."}, {"sha": "d59ee025e2a796e2d03ba337c4589054ee78c2c5", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvSound.def", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvSound.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvSound.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvSound.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,70 @@\n+(* Copyright (C) 2003\n+                 Free Software Foundation, Inc. *)\n+(* This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License along\n+with gm2; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)\n+\n+DEFINITION MODULE AdvSound ;\n+\n+(*\n+    Title      : AdvSound\n+    Author     : Gaius Mulley\n+    System     : GNU Modula-2\n+    Date       : Mon Jul 11 21:40:59 2005\n+    Revision   : $Version$ \n+    Description: provides a simple set of routines to generate\n+                 sound.\n+*)\n+\n+EXPORT QUALIFIED EnterGame, Explode, Swish, Miss, Hit ;\n+\n+\n+(*\n+   EnterGame - play the enter game sound to player, p.\n+*)\n+\n+PROCEDURE EnterGame (p: CARDINAL) ;\n+\n+\n+(*\n+   Explode - play the explosion for each player in room, r, and adjacent\n+             rooms.\n+*)\n+\n+PROCEDURE Explode (r: CARDINAL; pulled: CARDINAL; hit: BOOLEAN) ;\n+\n+\n+(*\n+   Swish - play the arrow swish sound to each player in room, r.\n+*)\n+\n+PROCEDURE Swish (r: CARDINAL) ;\n+\n+\n+(*\n+   Miss - play the arrow miss sound to each player in room, r.\n+*)\n+\n+PROCEDURE Miss (r: CARDINAL) ;\n+\n+\n+(*\n+   Hit - play the arrow hit sound to player, p.\n+*)\n+\n+PROCEDURE Hit (p: CARDINAL) ;\n+\n+\n+END AdvSound."}, {"sha": "1acad8b3df17857d559fcc5489f0aa39dd6de67e", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvSound.mod", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvSound.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvSound.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvSound.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,143 @@\n+IMPLEMENTATION MODULE AdvSound ;\n+\n+\n+FROM AdvMap IMPORT Adjacent ;\n+IMPORT StrIO ;\n+FROM AdvSystem IMPORT GetAccessToScreenNo, ReleaseAccessToScreenNo,\n+                      Player, PlayerNo,\n+                      NextFreePlayer,\n+                      IsPlayerActive,\n+                      GetReadAccessToPlayer,\n+                      ReleaseReadAccessToPlayer ;\n+\n+\n+PROCEDURE EnterGame (p: CARDINAL) ;\n+BEGIN\n+   GetAccessToScreenNo(p) ;\n+   StrIO.WriteString('pS start') ; StrIO.WriteLn ;\n+   ReleaseAccessToScreenNo(p)\n+END EnterGame ;\n+\n+\n+(*\n+   Explode - play the explosion for each player in room, r, and adjacent\n+             rooms.\n+*)\n+\n+PROCEDURE Explode (r: CARDINAL; pulled: CARDINAL; hit: BOOLEAN) ;\n+VAR\n+   p: CARDINAL ;\n+BEGIN\n+   GetReadAccessToPlayer ;\n+   FOR p := 0 TO NextFreePlayer-1 DO\n+      IF IsPlayerActive(p)\n+      THEN\n+         WITH Player[p] DO\n+            IF p=pulled\n+            THEN\n+               IF r=RoomOfMan\n+               THEN\n+                  GetAccessToScreenNo(p) ;\n+                  StrIO.WriteString('pS ohnoexplode') ; StrIO.WriteLn ;\n+                  ReleaseAccessToScreenNo(p)\n+               ELSIF Adjacent(r, RoomOfMan)\n+               THEN\n+                  IF hit\n+                  THEN\n+                     GetAccessToScreenNo(p) ;\n+                     StrIO.WriteString('pS laughexplode') ; StrIO.WriteLn ;\n+                     ReleaseAccessToScreenNo(p)\n+                  ELSE\n+                     GetAccessToScreenNo(p) ;\n+                     StrIO.WriteString('pS handgrenade') ; StrIO.WriteLn ;\n+                     ReleaseAccessToScreenNo(p)\n+                  END\n+               END\n+            ELSE\n+               GetAccessToScreenNo(p) ;\n+               StrIO.WriteString('pS handgrenade') ; StrIO.WriteLn ;\n+               ReleaseAccessToScreenNo(p)\n+            END\n+         END\n+      END\n+   END ;\n+   ReleaseReadAccessToPlayer\n+END Explode ;\n+\n+\n+(*\n+   ForeachIn - \n+*)\n+\n+PROCEDURE ForeachIn (r: CARDINAL; sound: ARRAY OF CHAR) ;\n+VAR\n+   p: CARDINAL ;\n+BEGIN\n+   GetReadAccessToPlayer ;\n+   FOR p := 0 TO NextFreePlayer-1 DO\n+      IF IsPlayerActive(p)\n+      THEN\n+         WITH Player[p] DO\n+            IF r=RoomOfMan\n+            THEN\n+               GetAccessToScreenNo(p) ;\n+               StrIO.WriteString(sound) ; StrIO.WriteLn ;\n+               ReleaseAccessToScreenNo(p)\n+            END\n+         END\n+      END\n+   END ;\n+   ReleaseReadAccessToPlayer\n+END ForeachIn ;\n+\n+\n+(*\n+   Swish - play the arrow swish sound to each player in room, r.\n+*)\n+\n+PROCEDURE Swish (r: CARDINAL) ;\n+BEGIN\n+   ForeachIn(r, 'pS arrowswish')\n+END Swish ;\n+\n+\n+(*\n+   Miss - play the arrow miss sound to each player in room, r.\n+*)\n+\n+PROCEDURE Miss (r: CARDINAL) ;\n+BEGIN\n+   ForeachIn(r, 'pS brokenglass')\n+END Miss ;\n+\n+\n+(*\n+   OhNo - play the OhNo sound to player, p.\n+*)\n+\n+PROCEDURE OhNo (p: CARDINAL) ;\n+BEGIN\n+   GetAccessToScreenNo(p) ;\n+   StrIO.WriteString('pS ohno') ; StrIO.WriteLn ;\n+   ReleaseAccessToScreenNo(p)\n+END OhNo ;\n+\n+\n+(*\n+   Hit - play the arrow hit sound to player, p.\n+*)\n+\n+PROCEDURE Hit (p: CARDINAL) ;\n+BEGIN\n+   GetAccessToScreenNo(p) ;\n+   StrIO.WriteString('pS applause') ; StrIO.WriteLn ;\n+   ReleaseAccessToScreenNo(p)\n+END Hit ;\n+\n+\n+END AdvSound.\n+(*\n+ * Local variables:\n+ *  compile-command: \"make\"\n+ * End:\n+ *)"}, {"sha": "52a3e7bb812d361770c066fd18fdf44f63271644", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvSystem.def", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvSystem.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvSystem.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvSystem.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,189 @@\n+DEFINITION MODULE AdvSystem ;\n+\n+\n+FROM Executive IMPORT SEMAPHORE, DESCRIPTOR ;\n+FROM ProcArgs IMPORT ProcessArgs ;\n+\n+\n+EXPORT QUALIFIED ManWeight,\n+                 MaxNoOfPlayers,\n+                 Man,\n+                 TypeOfDeath,\n+                 Player,\n+                 PlayerSet,\n+                 PlayerNo,\n+                 ArrowArgs,\n+                 StartPlayer,\n+                 TimeMinSec,\n+                 RandomNumber,\n+                 ClientRead,\n+                 DefaultWrite,\n+                 ReadString,\n+                 NextFreePlayer,\n+                 IsPlayerActive,\n+                 AssignOutputTo,\n+                 UnAssign,\n+\n+                 GetReadAccessToPlayer,\n+                 GetWriteAccessToPlayer,\n+                 ReleaseReadAccessToPlayer,\n+                 ReleaseWriteAccessToPlayer,\n+\n+                 GetReadAccessToDoor,\n+                 GetWriteAccessToDoor,\n+                 ReleaseReadAccessToDoor,\n+                 ReleaseWriteAccessToDoor,\n+\n+                 GetReadAccessToTreasure,\n+                 GetWriteAccessToTreasure,\n+                 ReleaseReadAccessToTreasure,\n+                 ReleaseWriteAccessToTreasure,\n+\n+                 GetAccessToScreen,\n+                 ReleaseAccessToScreen,\n+                 GetAccessToScreenNo,\n+                 ReleaseAccessToScreenNo ;\n+\n+\n+CONST\n+   ManWeight      = 70 ;      (* Kgs                               *)\n+   MaxNoOfPlayers = 100 ;\n+\n+TYPE\n+   TypeOfDeath = (living, normalarrow, magicarrow,\n+                  exitdungeon, explosion, sword, fireball) ;\n+\n+   PlayerSet = SET OF [0..MaxNoOfPlayers] ;\n+\n+   ArrowArgs = POINTER TO RECORD\n+                             ArrowPlayer: CARDINAL ;\n+                             ArrowRoom  : CARDINAL ;\n+                             ArrowX     : CARDINAL ;  (* X coord of Arrow   *)\n+                             ArrowY     : CARDINAL ;  (* Y coord of Arrow   *)\n+                             ArrowDir   : INTEGER ;   (* Direction of Arrow *)\n+                             IsMagic    : BOOLEAN ;\n+                          END ;\n+\n+   Man = RECORD\n+            ManName         : ARRAY [0..9] OF CHAR ;\n+            DeathType       : TypeOfDeath ;(* How man died!        *)\n+            Weight          : CARDINAL ;   (* Mans Weight in lbs   *)\n+            Wounds          : CARDINAL ;   (* 0..100  0= Dead!     *)\n+            Fatigue         : CARDINAL ;   (* 0..100  0= V Tired   *)\n+            TreasureOwn     : BITSET ;     (* Treasures that own   *)\n+            NoOfMagic       : CARDINAL ;   (* No Of Magic Arrows   *)\n+            NoOfNormal      : CARDINAL ;   (* No Of Normal Arrows  *)\n+            Xman            : CARDINAL ;   (* X coord of Man       *)\n+            Yman            : CARDINAL ;   (* Y coord of Man       *)\n+            Direction       : CARDINAL ;   (* Direction of Man 0.4 *)\n+            ScreenX         : CARDINAL ;   (* Top Right of screen  *)\n+            ScreenY         : CARDINAL ;   (* ditto                *)\n+            RoomOfMan       : CARDINAL ;   (* Room Man Current in  *)\n+            NormalProcArgs  : ProcessArgs ;\n+            MagicProcArgs   : ProcessArgs ;\n+            MagicP,\n+            NormalP         : DESCRIPTOR ;\n+            LastSecWounds   : CARDINAL ;   (* Last updated Wounds  *)\n+            LastSecFatigue  : CARDINAL ;   (* Last updated Fatigue *)\n+            PlayerProcess   : DESCRIPTOR ; (* process of player    *)\n+            fd              : INTEGER ;    (* socket file desc     *)\n+         END ;\n+\n+\n+VAR\n+   Player        : ARRAY [0..MaxNoOfPlayers] OF Man ;\n+   NextFreePlayer: CARDINAL ;   (* 0..NextFreePlayer-1 are potentially playing *)\n+\n+\n+PROCEDURE ClientRead (VAR ch: CHAR) : BOOLEAN ;\n+PROCEDURE DefaultWrite (ch: CHAR) ;\n+PROCEDURE ReadString (VAR s: ARRAY OF CHAR) ;\n+\n+\n+(*\n+   AssignOutputTo - assigns the current process to be associated with\n+                    player, p.\n+*)\n+\n+PROCEDURE AssignOutputTo (p: CARDINAL) ;\n+\n+\n+(*\n+   UnAssign - unassign the current process from any player.\n+*)\n+\n+PROCEDURE UnAssign ;\n+\n+\n+(*\n+   IsPlayerActive - returns TRUE if player, p, is still playing\n+*)\n+\n+PROCEDURE IsPlayerActive (p: CARDINAL) : BOOLEAN ;\n+\n+\n+(* PlayerNo - returns the Player number of the current man calling *)\n+\n+PROCEDURE PlayerNo () : CARDINAL ;\n+\n+\n+PROCEDURE StartPlayer (f: INTEGER) ;\n+\n+\n+(* Returns Minutes and seconds in Seconds.                      *)\n+\n+PROCEDURE TimeMinSec (VAR MinSec: CARDINAL) ;\n+\n+\n+(* RandomNumber delivers a random number in r which is in the   *)\n+(* range 0..n-1. However n must be in the range 1..256          *)\n+\n+PROCEDURE RandomNumber (VAR r: CARDINAL ; n: CARDINAL) ;\n+\n+\n+(* The rules which govern the allocation of these resourses are *)\n+\n+(* 1)  One may claim multiple resourses in the following order: *)\n+(*        AccessPlayer                                          *)\n+(*        AccessDoor                                            *)\n+(*        AccessTreasure                                        *)\n+(*        AccessScreen                                          *)\n+(*                                                              *)\n+(*                          All r/w  -  doesn't matter.         *)\n+(* 2)  Must never reverse this claiming or DEADLOCK may occur.  *)\n+(*                                                              *)\n+(* 3)  Must claim players in order ie 0 1 2                     *)\n+\n+\n+(* All Player access commands                                   *)\n+\n+PROCEDURE GetReadAccessToPlayer ;\n+PROCEDURE GetWriteAccessToPlayer ;\n+PROCEDURE ReleaseReadAccessToPlayer ;\n+PROCEDURE ReleaseWriteAccessToPlayer ;\n+\n+(* All Door access commands                                     *)\n+\n+PROCEDURE GetReadAccessToDoor ;\n+PROCEDURE GetWriteAccessToDoor ;\n+PROCEDURE ReleaseReadAccessToDoor ;\n+PROCEDURE ReleaseWriteAccessToDoor ;\n+\n+\n+(* All Treasure access commands                                 *)\n+\n+PROCEDURE GetReadAccessToTreasure ;\n+PROCEDURE GetWriteAccessToTreasure ;\n+PROCEDURE ReleaseReadAccessToTreasure ;\n+PROCEDURE ReleaseWriteAccessToTreasure ;\n+\n+\n+(* All Screen access commands                                   *)\n+\n+PROCEDURE GetAccessToScreen ;\n+PROCEDURE ReleaseAccessToScreen ;\n+PROCEDURE GetAccessToScreenNo (Sn: CARDINAL) ;\n+PROCEDURE ReleaseAccessToScreenNo (Sn: CARDINAL) ;\n+\n+\n+END AdvSystem."}, {"sha": "fc21516654910960354d8bfdf5b71a3962291854", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvSystem.mod", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvSystem.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvSystem.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvSystem.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,574 @@\n+IMPLEMENTATION MODULE AdvSystem ;\n+\n+FROM ASCII IMPORT nul, cr, lf, bs ;\n+FROM StdIO IMPORT PushOutput, PopOutput ;\n+FROM libc IMPORT printf, write, read ;\n+FROM StrLib IMPORT StrLen ;\n+FROM SYSTEM IMPORT ADR ;\n+FROM Debug IMPORT Halt ;\n+FROM TimerHandler IMPORT GetTicks, TicksPerSecond ;\n+FROM RTint IMPORT InitInputVector, InitOutputVector ;\n+FROM COROUTINES IMPORT PROTECTION ;\n+\n+FROM Executive IMPORT GetCurrentProcess, DESCRIPTOR, SEMAPHORE,\n+                      Resume, InitProcess, InitSemaphore, Wait, Signal,\n+                      WaitForIO ;\n+\n+FROM Lock IMPORT InitLock, GetReadAccess, GetWriteAccess, LOCK,\n+                 ReleaseReadAccess, ReleaseWriteAccess ;\n+FROM ProcArgs IMPORT ProcessArgs, InitArgs, SetArgs, CollectArgs ;\n+FROM Storage IMPORT ALLOCATE, DEALLOCATE ;\n+FROM AdvUtil IMPORT NormalArrow, MagicArrow ;\n+\n+\n+CONST\n+   MaxNoOfProcesses = MaxNoOfPlayers*3 + 1 ;\n+   ArrowProcessSize = 30 * 1024 * 1024 ;\n+\n+TYPE\n+   ProcPlayer = RECORD\n+                   process : DESCRIPTOR ;\n+                   playerId: CARDINAL ;\n+                END ;\n+\n+VAR\n+   GlobalFd      : INTEGER ;\n+   ScreenQ       : SEMAPHORE ;\n+   PlayerLock    : LOCK ;\n+   DoorLock      : LOCK ;\n+   TreasureLock  : LOCK ;\n+   AccessToRandom: SEMAPHORE ;\n+   RandomCount   : CARDINAL ;\n+   ProcToPlay    : ARRAY [0..MaxNoOfPlayers] OF ProcPlayer ;\n+   PArgs         : ProcessArgs ;\n+\n+(*\n+   AssignOutputTo - assigns the current process to be associated with\n+                    player, p.\n+*)\n+\n+PROCEDURE AssignOutputTo (p: CARDINAL) ;\n+VAR\n+   i: CARDINAL ;\n+BEGIN\n+   i := 0 ;\n+   WHILE i<MaxNoOfProcesses DO\n+      WITH ProcToPlay[i] DO\n+         IF process=NIL\n+         THEN\n+            process := GetCurrentProcess() ;\n+            playerId := p ;\n+            RETURN\n+         ELSIF process=GetCurrentProcess()\n+         THEN\n+            playerId := p ;\n+            RETURN\n+         END\n+      END ;\n+      INC(i)\n+   END ;\n+   Halt(__FILE__, __LINE__, __FUNCTION__, 'increase MaxNoOfProcesses')\n+END AssignOutputTo ;\n+\n+\n+(*\n+   UnAssign - unassign the current process from any player.\n+*)\n+\n+PROCEDURE UnAssign ;\n+VAR\n+   i: CARDINAL ;\n+BEGIN\n+   i := 0 ;\n+   WHILE i<MaxNoOfProcesses DO\n+      WITH ProcToPlay[i] DO\n+         IF process=GetCurrentProcess()\n+         THEN\n+            process := NIL ;\n+            RETURN\n+         END\n+      END ;\n+      INC(i)\n+   END\n+END UnAssign ;\n+\n+\n+(*\n+   ProcessToPlayer - returns the player associated with the current process.\n+*)\n+\n+PROCEDURE ProcessToPlayer () : CARDINAL ;\n+VAR\n+   i: CARDINAL ;\n+BEGIN\n+   i := 0 ;\n+   WHILE i<MaxNoOfProcesses DO\n+      WITH ProcToPlay[i] DO\n+         IF process=GetCurrentProcess()\n+         THEN\n+            RETURN( playerId )\n+         END\n+      END ;\n+      INC(i)\n+   END ;\n+   Halt(__FILE__, __LINE__, __FUNCTION__,\n+        'process has never has a player assigned to its output')\n+END ProcessToPlayer ;\n+\n+\n+(*\n+   checkStatus -\n+*)\n+\n+PROCEDURE checkStatus (r: INTEGER) ;\n+VAR\n+   p: CARDINAL ;\n+BEGIN\n+   IF r<1\n+   THEN\n+      r := printf(\"WriteS client has gone away - tidying up\\n\") ;\n+      p := ProcessToPlayer() ;\n+      WITH Player[p] DO\n+         fd := -1 ;\n+         IF DeathType=living\n+         THEN\n+            DeathType := exitdungeon\n+         END\n+      END\n+   END\n+END checkStatus ;\n+\n+\n+PROCEDURE localWrite (fd: INTEGER; ch: CHAR) ;\n+VAR\n+   r: INTEGER ;\n+BEGIN\n+   IF fd>=0\n+   THEN\n+      WaitForIO(InitOutputVector(fd, MAX(PROTECTION))) ;\n+      checkStatus(write(fd, ADR(ch), SIZE(ch)))\n+   END\n+END localWrite ;\n+\n+\n+PROCEDURE localWriteS (fd: INTEGER; s: ARRAY OF CHAR) ;\n+VAR\n+   r: INTEGER ;\n+BEGIN\n+   IF fd>=0\n+   THEN\n+      checkStatus(write(fd, ADR(s), StrLen(s)))\n+   END\n+END localWriteS ;\n+\n+\n+PROCEDURE ReadString (VAR s: ARRAY OF CHAR) ;\n+VAR\n+   r: INTEGER ;\n+   h: CARDINAL ;\n+BEGIN\n+   h := 0 ;\n+   WHILE h<HIGH(s) DO\n+      IF ClientRead(s[h])\n+      THEN\n+         IF (s[h]=lf) OR (s[h]=cr) OR (s[h]=nul)\n+         THEN\n+            s[h] := nul ;\n+            RETURN\n+         ELSIF s[h]=bs\n+         THEN\n+            IF h>0\n+            THEN\n+               WriteChar(bs) ;\n+               DEC(h)\n+            END\n+         ELSE\n+            WriteChar(s[h]) ;\n+            INC(h)\n+         END\n+      ELSE\n+         s[h] := nul ;\n+         RETURN\n+      END\n+   END ;\n+   IF (s[h]=lf) OR (s[h]=cr)\n+   THEN\n+      s[h] := nul\n+   END\n+END ReadString ;\n+\n+\n+(*\n+   DefaultWrite - writes to the default (local) file descriptor.\n+*)\n+\n+PROCEDURE DefaultWrite (ch: CHAR) ;\n+VAR\n+   p: CARDINAL ;\n+BEGIN\n+   p := ProcessToPlayer() ;\n+   localWrite(Player[p].fd, ch)\n+END DefaultWrite ;\n+\n+\n+PROCEDURE ClientRead (VAR ch: CHAR) : BOOLEAN ;\n+VAR\n+   r: INTEGER ;\n+BEGIN\n+   WITH Player[PlayerNo()] DO\n+      IF fd>=0\n+      THEN\n+         WaitForIO(InitInputVector(fd, MAX(PROTECTION))) ;\n+         r := read(fd, ADR(ch), SIZE(ch)) ;\n+         checkStatus(r) ;\n+         RETURN( r=1 )\n+      ELSE\n+         RETURN( FALSE )\n+      END\n+   END ;\n+END ClientRead ;\n+\n+\n+PROCEDURE WriteChar (ch: CHAR) ;\n+VAR\n+   r: INTEGER ;\n+BEGIN\n+   WITH Player[PlayerNo()] DO\n+      IF fd>=0\n+      THEN\n+         IF ch=bs\n+         THEN\n+            localWriteS(fd, 'eC')\n+         ELSE\n+            localWriteS(fd, 'dC ') ;\n+            localWrite(fd, ch)\n+         END ;\n+         localWrite(fd, lf)\n+      END\n+   END ;\n+END WriteChar ;\n+\n+\n+PROCEDURE PlayerNo () : CARDINAL ;\n+VAR\n+   i: CARDINAL ;\n+BEGIN\n+   FOR i := 0 TO NextFreePlayer-1 DO\n+      IF GetCurrentProcess()=Player[i].PlayerProcess\n+      THEN\n+         RETURN( i )\n+      END\n+   END ;\n+   Halt(__FILE__, __LINE__, __FUNCTION__,\n+        'process calling is not a player process')\n+END PlayerNo ;\n+\n+\n+(*\n+   IsaPlayer -\n+*)\n+\n+PROCEDURE IsaPlayer (d: DESCRIPTOR) : BOOLEAN ;\n+VAR\n+   i: CARDINAL ;\n+BEGIN\n+   FOR i := 0 TO NextFreePlayer-1 DO\n+      IF Player[i].PlayerProcess=d\n+      THEN\n+         RETURN( TRUE )\n+      END\n+   END ;\n+   RETURN( FALSE )\n+END IsaPlayer ;\n+\n+\n+(*\n+   FindFreePlayer -\n+*)\n+\n+PROCEDURE FindFreePlayer () : INTEGER ;\n+VAR\n+   i : INTEGER ;\n+   pc: POINTER TO CARDINAL ;\n+BEGIN\n+   IF NextFreePlayer<=MaxNoOfPlayers\n+   THEN\n+      IF NextFreePlayer>0\n+      THEN\n+         (* reuse an old player who has left the game *)\n+         FOR i := 0 TO NextFreePlayer-1 DO\n+            WITH Player[i] DO\n+               IF fd=-1\n+               THEN\n+                  Weight := ManWeight ;\n+                  TreasureOwn := {} ;\n+                  RETURN( i )\n+               END\n+            END\n+         END\n+      END ;\n+      i := NextFreePlayer ;\n+      INC(NextFreePlayer) ;\n+      WITH Player[i] DO\n+         Weight := ManWeight ;\n+         TreasureOwn := {} ;\n+         NormalProcArgs := InitArgs() ;\n+         MagicProcArgs := InitArgs() ;\n+         NEW(pc) ;\n+         pc^ := i ;\n+         MagicP := Resume(InitProcess(MagicArrowP, ArrowProcessSize, 'Magic Arrow')) ;\n+         pc := SetArgs(PArgs, pc) ;\n+         NormalP := Resume(InitProcess(NormalArrowP, ArrowProcessSize, 'Normal Arrow')) ;\n+         NEW(pc) ;\n+         pc^ := i ;\n+         pc := SetArgs(PArgs, pc)\n+      END ;\n+      RETURN( i )\n+   ELSE\n+      RETURN( -1 )\n+   END\n+END FindFreePlayer ;\n+\n+\n+(*\n+   IsPlayerActive - returns TRUE if player, p, is still playing\n+*)\n+\n+PROCEDURE IsPlayerActive (p: CARDINAL) : BOOLEAN ;\n+BEGIN\n+   RETURN( (p<NextFreePlayer) AND (Player[p].fd#-1) )\n+END IsPlayerActive ;\n+\n+\n+PROCEDURE NormalArrowP ;\n+VAR\n+   pc: POINTER TO CARDINAL ;\n+BEGIN\n+   pc := CollectArgs(PArgs) ;\n+   LOOP\n+      NormalArrow(pc^)\n+   END\n+END NormalArrowP ;\n+\n+\n+PROCEDURE MagicArrowP ;\n+VAR\n+   pc: POINTER TO CARDINAL ;\n+BEGIN\n+   pc := CollectArgs(PArgs) ;\n+   LOOP\n+      MagicArrow(pc^)\n+   END\n+END MagicArrowP ;\n+\n+\n+PROCEDURE StartPlayer (f: INTEGER) ;\n+VAR\n+   i : INTEGER ;\n+BEGIN\n+   i := FindFreePlayer() ;\n+   IF i=-1\n+   THEN\n+      (* write an error message to fd *)\n+   ELSE\n+      WITH Player[i] DO\n+         fd := f ;\n+         PlayerProcess := GetCurrentProcess() ;\n+         DeathType := living ;\n+         Wounds := 100 ;\n+         Fatigue := 100 ;\n+         Direction := 0 ;\n+         TimeMinSec(LastSecWounds) ;\n+         LastSecFatigue := GetTicks() DIV (TicksPerSecond DIV 2)\n+      END\n+   END\n+END StartPlayer ;\n+\n+\n+PROCEDURE Init ;\n+BEGIN\n+   PlayerLock := InitLock('player lock') ;\n+   ScreenQ := InitSemaphore(1, 'ScreenQ') ;\n+   DoorLock := InitLock('DoorLock') ;\n+   TreasureLock := InitLock('TreasureLock') ;\n+   AccessToRandom := InitSemaphore(1, 'AccessToRandom') ;\n+   PArgs := InitArgs() ;\n+   TimeMinSec (RandomCount) ;\n+   NextFreePlayer := 0 ;\n+   PushOutput (DefaultWrite)\n+END Init ;\n+\n+\n+PROCEDURE TimeMinSec (VAR MinSec: CARDINAL) ;\n+BEGIN\n+   MinSec := GetTicks() DIV TicksPerSecond\n+END TimeMinSec ;\n+\n+\n+PROCEDURE RandomNumber (VAR r: CARDINAL; n: CARDINAL) ;\n+VAR\n+   ms: CARDINAL ;\n+BEGIN\n+   IF n=1\n+   THEN\n+      r := 0\n+   ELSE\n+      Wait( AccessToRandom ) ;\n+      r := RandomCount MOD n ;\n+\n+      ms := RandomCount MOD 256 ;\n+      RandomCount := ms*256+ms ;   (* multiply by 257 *)\n+\n+      IF (MAX(CARDINAL)-RandomCount) >= 0ABCDH  (* Add 0ABCDH *)\n+      THEN\n+         INC( RandomCount, 0ABCDH )\n+      ELSE\n+         DEC( RandomCount, (MAX(CARDINAL)-0ABCDH) )\n+      END ;\n+\n+      Signal( AccessToRandom ) ;\n+\n+      (* Returns a number 1..n  *)\n+   END\n+END RandomNumber ;\n+\n+\n+\n+(* The rules which govern the allocation of these resourses are *)\n+\n+(* 1)  One may claim multiple resourses in the following order: *)\n+(*        AccessPlayer                                          *)\n+(*        AccessDoor                                            *)\n+(*        AccessTreasure                                        *)\n+(*        AccessScreen                                          *)\n+(*        GetTime - Procedure NOT lock!                         *)\n+(*                                                              *)\n+(*                          All r/w  -  doesn't matter!         *)\n+(*                                                              *)\n+(* 2)  Must never reverse this claiming or DEADLOCK may occur.  *)\n+(*                                                              *)\n+(* 3)  Must access players in order ie 0 1 2                    *)\n+\n+\n+\n+(*\n+ * Access To Players\n+ *)\n+\n+PROCEDURE GetReadAccessToPlayer ;\n+BEGIN\n+   GetReadAccess(PlayerLock)\n+END GetReadAccessToPlayer ;\n+\n+\n+PROCEDURE GetWriteAccessToPlayer ;\n+BEGIN\n+   GetWriteAccess(PlayerLock)\n+END GetWriteAccessToPlayer ;\n+\n+\n+PROCEDURE ReleaseReadAccessToPlayer ;\n+BEGIN\n+   ReleaseReadAccess(PlayerLock)\n+END ReleaseReadAccessToPlayer ;\n+\n+\n+PROCEDURE ReleaseWriteAccessToPlayer ;\n+BEGIN\n+   ReleaseWriteAccess(PlayerLock)\n+END ReleaseWriteAccessToPlayer ;\n+\n+\n+(*\n+ * Access To Doors\n+ *)\n+\n+PROCEDURE GetReadAccessToDoor ;\n+BEGIN\n+   GetReadAccess(DoorLock)\n+END GetReadAccessToDoor ;\n+\n+\n+PROCEDURE GetWriteAccessToDoor ;\n+BEGIN\n+   GetWriteAccess(DoorLock)\n+END GetWriteAccessToDoor ;\n+\n+\n+PROCEDURE ReleaseReadAccessToDoor ;\n+BEGIN\n+   ReleaseReadAccess(DoorLock)\n+END ReleaseReadAccessToDoor ;\n+\n+\n+PROCEDURE ReleaseWriteAccessToDoor ;\n+BEGIN\n+   ReleaseWriteAccess(DoorLock)\n+END ReleaseWriteAccessToDoor ;\n+\n+\n+(*\n+ * Access To Treasures\n+ *)\n+\n+PROCEDURE GetReadAccessToTreasure ;\n+BEGIN\n+   GetReadAccess(TreasureLock)\n+END GetReadAccessToTreasure ;\n+\n+\n+PROCEDURE GetWriteAccessToTreasure ;\n+BEGIN\n+   GetWriteAccess(TreasureLock)\n+END GetWriteAccessToTreasure ;\n+\n+\n+PROCEDURE ReleaseReadAccessToTreasure ;\n+BEGIN\n+   ReleaseReadAccess(TreasureLock)\n+END ReleaseReadAccessToTreasure ;\n+\n+\n+PROCEDURE ReleaseWriteAccessToTreasure ;\n+BEGIN\n+   ReleaseWriteAccess(TreasureLock)\n+END ReleaseWriteAccessToTreasure ;\n+\n+\n+(*\n+ *  Access To Screen\n+ *)\n+\n+PROCEDURE GetAccessToScreen ;\n+BEGIN\n+   GetAccessToScreenNo(PlayerNo())\n+END GetAccessToScreen ;\n+\n+\n+PROCEDURE ReleaseAccessToScreen ;\n+BEGIN\n+   ReleaseAccessToScreenNo(PlayerNo())\n+END ReleaseAccessToScreen ;\n+\n+\n+PROCEDURE GetAccessToScreenNo (p: CARDINAL) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   Wait(ScreenQ)\n+END GetAccessToScreenNo ;\n+\n+\n+PROCEDURE ReleaseAccessToScreenNo (p: CARDINAL) ;\n+BEGIN\n+   Signal(ScreenQ)\n+END ReleaseAccessToScreenNo ;\n+\n+\n+BEGIN\n+   Init\n+END AdvSystem.\n+(*\n+ * Local variables:\n+ *  compile-command: \"make\"\n+ * End:\n+ *)"}, {"sha": "47e9f8c051931c80fa35795210a538e7c1971853", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvTreasure.def", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvTreasure.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvTreasure.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvTreasure.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,22 @@\n+DEFINITION MODULE AdvTreasure ;\n+\n+FROM AdvMap IMPORT TreasureKind ;\n+\n+EXPORT QUALIFIED GetTreasure, DropTreasure, UseTreasure,\n+                 Grenade, DisplayEnemy, ScatterTreasures,\n+                 RespawnTreasure, RespawnArrow ;\n+\n+\n+PROCEDURE GetTreasure ;\n+PROCEDURE DropTreasure ;\n+PROCEDURE UseTreasure ;\n+PROCEDURE Grenade ;\n+PROCEDURE DisplayEnemy ;\n+PROCEDURE ScatterTreasures (p, r: CARDINAL) ;\n+PROCEDURE RespawnTreasure (seedRoom: CARDINAL; tno: CARDINAL; ticks: CARDINAL) ;\n+PROCEDURE RespawnArrow (seedRoom: CARDINAL; tno: CARDINAL;\n+                        spawnKind, arrowKind: TreasureKind;\n+                        amount: CARDINAL; ticks: CARDINAL) ;\n+\n+\n+END AdvTreasure."}, {"sha": "f5df8fcda04d030f0f2faff716b199f98d7a72db", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvTreasure.mod", "status": "added", "additions": 1632, "deletions": 0, "changes": 1632, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvTreasure.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvTreasure.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvTreasure.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,1632 @@\n+IMPLEMENTATION MODULE AdvTreasure ;\n+\n+\n+FROM libc IMPORT printf ;\n+FROM Executive IMPORT GetCurrentProcess, InitSemaphore, SEMAPHORE,\n+                      Wait, Signal, InitProcess, Resume, DESCRIPTOR ;\n+FROM TimerHandler IMPORT Sleep, TicksPerSecond, EVENT, ReArmEvent, ArmEvent, WaitOn, Cancel ;\n+\n+FROM ASCII IMPORT cr ;\n+FROM StrLib IMPORT StrCopy, StrConCat, StrLen ;\n+FROM NumberIO IMPORT CardToStr, WriteCard ;\n+FROM Storage IMPORT ALLOCATE ;\n+FROM Assertion IMPORT Assert ;\n+\n+FROM AdvSystem IMPORT MaxNoOfPlayers,\n+                      ManWeight,\n+                      Man,\n+                      TypeOfDeath,\n+                      Player,\n+                      PlayerSet,\n+                      PlayerNo,\n+                      ArrowArgs,\n+                      StartPlayer,\n+                      TimeMinSec,\n+                      RandomNumber,\n+                      ClientRead,\n+                      DefaultWrite,\n+                      ReadString,\n+                      NextFreePlayer,\n+                      IsPlayerActive,\n+                      AssignOutputTo,\n+\n+                      GetReadAccessToPlayer,\n+                      GetWriteAccessToPlayer,\n+                      ReleaseReadAccessToPlayer,\n+                      ReleaseWriteAccessToPlayer,\n+\n+                      GetReadAccessToDoor,\n+                      GetWriteAccessToDoor,\n+                      ReleaseReadAccessToDoor,\n+                      ReleaseWriteAccessToDoor,\n+\n+                      GetReadAccessToTreasure,\n+                      GetWriteAccessToTreasure,\n+                      ReleaseReadAccessToTreasure,\n+                      ReleaseWriteAccessToTreasure,\n+\n+                      GetAccessToScreen,\n+                      ReleaseAccessToScreen,\n+                      GetAccessToScreenNo,\n+                      ReleaseAccessToScreenNo ;\n+\n+FROM AdvMap IMPORT Treasure, Rooms, DoorStatus, IncPosition,\n+                   NoOfRoomsToSpring,\n+                   NoOfRoomsToHideCoal, NoOfRoomsToHideGrenade,\n+                   TreasureKind, Treasure,\n+                   ActualNoOfRooms ;\n+\n+FROM AdvMath IMPORT MaxNoOfTreasures, LowFreePool, HighFreePool ;\n+\n+FROM Screen IMPORT Width, Height,\n+                   ClearScreen,\n+                   InitScreen,\n+                   WriteWounds,\n+                   WriteWeight,\n+                   WriteString,\n+                   WriteCommentLine1,\n+                   WriteCommentLine2,\n+                   WriteCommentLine3,\n+                   DelCommentLine1,\n+                   DelCommentLine2,\n+                   DelCommentLine3,\n+                   WriteArrows, WriteMagicArrows ;\n+\n+FROM AdvMath IMPORT MagicKey,\n+                    CrystalBall,\n+                    MagicSpring,\n+                    SackOfCoal1,\n+                    SackOfCoal2,\n+                    HotIron,\n+                    HandGrenade,\n+                    MagicSword,\n+                    MagicShoes,\n+                    SleepPotion,\n+                    LumpOfIron,\n+                    TreasTrove,\n+                    SpeedPotion,\n+                    MagicShield,\n+                    VisionChest,\n+                    QuiverNormal,\n+                    QuiverMagic,\n+                    HealingPotion,\n+\n+                    UpDateWoundsAndFatigue,\n+                    DammageByHandGrenade,\n+                    DammageByHotIron ;\n+\n+\n+FROM DrawG IMPORT DrawTreasure, EraseTreasure, EraseMan, DrawMan ;\n+FROM DrawL IMPORT DrawRoom, DrawAllPlayers ;\n+FROM AdvSound IMPORT Explode ;\n+\n+FROM AdvUtil IMPORT PointOnWall, GetDoorOnPoint, PointOnTreasure,\n+                    HideDoor, RandomRoom, PositionInRoom, InitialDisplay,\n+                    FreeOfPlayersAndTreasure, Dead ;\n+\n+\n+\n+(* Treasure routines.                                                *)\n+(*                                                                   *)\n+(* The treasures are as follows:                                     *)\n+(*                                                                   *)\n+(* 1:  Magic Key           - This treasures allows one to make a     *)\n+(*                           closed door into a secret door          *)\n+(*                                                                   *)\n+(* 2:  Crystal Ball        - This treasure allows one to get the     *)\n+(*                           direction and Room No of the other      *)\n+(*                           players                                 *)\n+(*                                                                   *)\n+(* 3:  Magic Spring        - When Grabbed, it springs one to another *)\n+(*                           random picked room                      *)\n+(*                                                                   *)\n+(* 4:  Sack Of Coal        - When Grabbed, it insists that it must   *)\n+(*                           be taken to a randomly picked room      *)\n+(*                           before it can be dropped                *)\n+(*                                                                   *)\n+(* 5:  Sack Of Coal        - Ditto                                   *)\n+(*                                                                   *)\n+(* 6:  Hot Iron            - Scolds one if picked up                 *)\n+(*                                                                   *)\n+(* 7:  Hand Grenade        - If used will blow up whole room in      *)\n+(*                           25 seconds                              *)\n+(*                                                                   *)\n+(* 8:  Magic Sword         - Enables one to fight with ease          *)\n+(*                                                                   *)\n+(* 9:  Magic Shoes         - Enable one to run with minimal effort   *)\n+(*                                                                   *)\n+(* 10: Sleep Potion        - Makes one fall to sleep for 24 seconds  *)\n+(*                                                                   *)\n+(* 11: Lump Of Iron        - When picked up scatters all treasure in *)\n+(*                           current room.                           *)\n+(*                                                                   *)\n+(* 12: Treasure Trove      - Tells one where or who has the          *)\n+(*                           treasures.                              *)\n+(*                                                                   *)\n+(* 13: Speed Potion        - Increases ones responce time.           *)\n+(*                                                                   *)\n+(* 14: Magic Shield        - Repels Normal Arrows.                   *)\n+(*                                                                   *)\n+(* 15: Vision Chest        - Allows one to see enemies screen.       *)\n+\n+\n+CONST\n+   respawnStack          = 10 * 1024 * 1024 ;\n+   RespawnArrowTime      = 13 ;   (* seconds delay between respawning more arrow treasures 16/17.    *)\n+   RespawnArrowInventory = 20 ;   (* seconds delay between respawning inventory arrows after death.  *)\n+   RespawnMagicInventory = 30 ;   (* seconds delay between respawning inventory magic arrows after death.  *)\n+\n+TYPE\n+   QDesc = POINTER TO RECORD\n+                         right: QDesc ;\n+                         Rm,\n+                         tno   : CARDINAL ;\n+                         kind  : TreasureKind ;\n+                         amount,\n+                         ticks : CARDINAL ;\n+                      END ;\n+\n+\n+\n+\n+VAR\n+   Tmessage         : ARRAY [0..13] OF CHAR ;\n+   SackOfCoal       : ARRAY [0..1] OF CARDINAL ;\n+   PinPulled        : SEMAPHORE ;\n+   PinHasBeenPulled : BOOLEAN ;\n+   PlayerPulled     : CARDINAL ;\n+   qHead,\n+   freeDesc         : QDesc ;\n+   armedTimer       : EVENT ;\n+   qAvailable,\n+   qMutex           : SEMAPHORE ;\n+   qThread          : DESCRIPTOR ;\n+\n+\n+PROCEDURE GetTreasure ;\n+VAR\n+   p, r : CARDINAL ;\n+   died : BOOLEAN ;\n+   Tno  : CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   GetWriteAccessToPlayer ;\n+   Tno := GetTreasure1(p) ;\n+   (* Only way so far to die directly from getting treasures.         *)\n+   died := (Player[p].DeathType=fireball) ;\n+   r := Player[p].RoomOfMan ;\n+   ReleaseWriteAccessToPlayer ;\n+   IF Tno=SleepPotion\n+   THEN\n+      (* must not sleep holding the lock.  *)\n+      Sleep(24*TicksPerSecond)\n+   END ;\n+   IF died\n+   THEN\n+      Dead(p, r)\n+   END\n+END GetTreasure ;\n+\n+\n+PROCEDURE GetTreasure1 (p: CARDINAL) : CARDINAL ;\n+VAR\n+   x, y, d,\n+   r,\n+   TreasNo: CARDINAL ;\n+   ReDraw,\n+   ok     : BOOLEAN ;\n+BEGIN\n+   ReDraw := FALSE ;\n+   WITH Player[p] DO\n+      d := Direction ;\n+      r := RoomOfMan ;\n+      x := Xman ;\n+      y := Yman ;\n+      IncPosition(x, y, d) ;\n+      GetWriteAccessToTreasure ;\n+      PointOnTreasure(r, x, y, TreasNo, ok) ;\n+      IF ok\n+      THEN\n+         IF TreasNo>9\n+         THEN\n+            Tmessage[12] := '1' ;\n+            Tmessage[13] := CHR((TreasNo MOD 10)+ORD('0'))\n+         ELSE\n+            Tmessage[12] := ' ' ;\n+            Tmessage[13] := CHR(TreasNo+ORD('0'))\n+         END ;\n+         GetAccessToScreenNo(p) ;\n+         WriteCommentLine1(p, Tmessage) ;\n+         WriteCommentLine2(p, Treasure[TreasNo].TreasureName) ;\n+         DelCommentLine3(p) ;\n+         ReleaseAccessToScreenNo(p) ;\n+         PickUpTreasure(p, r, TreasNo, x, y, ReDraw)\n+      ELSE\n+         GetAccessToScreenNo(p) ;\n+         WriteCommentLine1(p, 'thou canst') ;\n+         DelCommentLine2(p) ;\n+         DelCommentLine3(p) ;\n+         ReleaseAccessToScreenNo(p)\n+      END ;\n+      ReleaseWriteAccessToTreasure ;\n+      IF ReDraw\n+      THEN\n+         InitScreen(p) ;\n+         DrawRoom\n+      END\n+   END ;\n+   RETURN( TreasNo )\n+END GetTreasure1 ;\n+\n+\n+(*\n+   RandomDrop -\n+*)\n+\n+PROCEDURE RandomDrop (VAR r, x, y: CARDINAL) : BOOLEAN ;\n+VAR\n+   roomCount: CARDINAL ;\n+   ok       : BOOLEAN ;\n+BEGIN\n+   REPEAT\n+      RandomNumber (roomCount, ActualNoOfRooms) ;\n+      INC (roomCount) ;\n+      RandomRoom (roomCount, NoOfRoomsToSpring, r) ;\n+      PositionInRoom (r, x, y, ok)\n+   UNTIL ok ;\n+   RETURN TRUE\n+END RandomDrop ;\n+\n+\n+(*\n+   IsTreasureArrow - returns TRUE if treasure, i, is an arrow (normal or magic)\n+                     it can be a respawnable treasure or an item dropped after\n+                     death.\n+*)\n+\n+PROCEDURE IsTreasureArrow (i: CARDINAL) : BOOLEAN ;\n+BEGIN\n+   RETURN (i = QuiverNormal) OR (i = QuiverMagic) OR (i >= LowFreePool)\n+END IsTreasureArrow ;\n+\n+\n+PROCEDURE PickUpTreasure (p, r, TreasNo, tx, ty: CARDINAL ;\n+                          VAR ReDraw: BOOLEAN) ;\n+VAR\n+   tr, i: CARDINAL ;\n+   ok   : BOOLEAN ;\n+   a    : ARRAY [0..14] OF CHAR ;\n+   b    : ARRAY [0..4] OF CHAR ;\n+BEGIN\n+   WITH Player[p] DO\n+      (* Magic Spring CANNOT be Grabbed AND neither can Lump Of Iron *)\n+      IF (TreasNo#MagicSpring) AND (TreasNo#LumpOfIron) AND\n+         (NOT IsTreasureArrow (TreasNo))\n+      THEN\n+         pickUp (p, r, TreasNo) ;\n+         GetAccessToScreenNo (p) ;\n+         WriteWeight (p, Weight) ;\n+         ReleaseAccessToScreenNo (p) ;\n+      END ;\n+      EXCL (Rooms[r].Treasures, TreasNo) ; (* Room no longer has treasure *)\n+      EraseTreasure(r, tx, ty) ;\n+\n+      IF TreasNo=MagicSpring\n+      THEN\n+         (* Magic Spring - Springs treasure and player into different      *)\n+         (*                rooms.                                          *)\n+\n+         EraseMan(p) ;\n+         REPEAT\n+            RandomNumber(r, ActualNoOfRooms) ;  (* r>=0 & r<=ActualNoOfRooms-1 *)\n+            INC(r) ;\n+            RandomRoom(r, NoOfRoomsToSpring, tr) ;\n+            PositionInRoom(tr, tx, ty, ok)\n+         UNTIL ok ;\n+         RoomOfMan := tr ;\n+         Xman := tx ;\n+         Yman := ty ;\n+         ScreenX := tx-(tx MOD Width) ;\n+         ScreenY := ty-(ty MOD Height) ;\n+         DrawMan(p) ;\n+         IF RandomDrop (tr, tx, ty)\n+         THEN\n+            WITH Treasure[TreasNo] DO\n+               Rm := tr ;\n+               Xpos := tx ;\n+               Ypos := ty\n+            END\n+         END ;\n+         INCL(Rooms[tr].Treasures, TreasNo) ; (* Room has treasure *)\n+         DrawTreasure(tr, tx, ty) ;\n+         ReDraw := TRUE\n+      ELSIF (TreasNo=SackOfCoal1) OR (TreasNo=SackOfCoal2)  (* Sacks Of Coal *)\n+      THEN\n+         RandomNumber(r, ActualNoOfRooms) ;\n+         INC(r) ;\n+         RandomRoom(r, NoOfRoomsToHideCoal, tr) ;\n+         SackOfCoal[TreasNo-SackOfCoal1] := tr ;\n+         StrCopy('to room ', a ) ;\n+         CardToStr(tr, 4, b) ;\n+         StrConCat(a, b, a) ;\n+         GetAccessToScreenNo(p) ;\n+         WriteCommentLine3(p, a) ;\n+         ReleaseAccessToScreenNo(p)\n+      ELSIF TreasNo=HotIron             (* Hot iron      *)\n+      THEN\n+         GetAccessToScreenNo(p) ;\n+         WriteCommentLine1(p, 'ouch') ;\n+         WriteCommentLine2(p, 'fire ball') ;\n+         WriteCommentLine3(p, 'hit thee') ;\n+         IF DammageByHotIron>Wounds\n+         THEN\n+            Wounds := 0 ;\n+            DeathType := fireball\n+         ELSE\n+            DEC(Wounds, DammageByHotIron)\n+         END ;\n+         WriteWounds(p, Wounds) ;\n+         ReleaseAccessToScreenNo(p)\n+      ELSIF TreasNo=LumpOfIron\n+      THEN\n+         ScatterAllTreasures(p, RoomOfMan)\n+      ELSIF TreasNo=SpeedPotion\n+      THEN\n+         (* PutPriority(CurrentProcess, User, 4) *)\n+      ELSIF (TreasNo=QuiverNormal) OR (TreasNo=QuiverMagic)\n+      THEN\n+         IF TreasNo=QuiverNormal\n+         THEN\n+            INC (NoOfNormal, 6) ;\n+            GetAccessToScreenNo (p) ;\n+            WriteArrows (p, NoOfNormal) ;\n+            WriteCommentLine1 (p, '6 normal') ;\n+            WriteCommentLine2 (p, 'arrows') ;\n+            ReleaseAccessToScreenNo (p) ;\n+            Treasure[TreasNo].kind := respawnnormal\n+         ELSE\n+            INC (NoOfMagic, 1) ;\n+            GetAccessToScreenNo (p) ;\n+            WriteMagicArrows (p, NoOfMagic) ;\n+            WriteCommentLine1 (p, 'a magic') ;\n+            WriteCommentLine2 (p, 'arrow') ;\n+            ReleaseAccessToScreenNo (p) ;\n+            Treasure[TreasNo].kind := respawnmagic\n+         END ;\n+         RespawnTreasure (tr, TreasNo, RespawnArrowTime * TicksPerSecond) ;\n+      ELSIF IsTreasureArrow (TreasNo)\n+      THEN\n+         GetAccessToScreenNo (p) ;\n+         IF Treasure[TreasNo].kind = normal\n+         THEN\n+            INC (NoOfNormal, Treasure[TreasNo].amount) ;\n+            WriteArrows (p, NoOfNormal) ;\n+         ELSIF Treasure[TreasNo].kind = magic\n+         THEN\n+            INC (NoOfMagic, Treasure[TreasNo].amount) ;\n+            WriteMagicArrows (p, NoOfMagic) ;\n+         END ;\n+         Treasure[TreasNo].amount := 0 ;\n+         Treasure[TreasNo].Rm := 0 ;\n+         Treasure[TreasNo].kind := unused ;\n+         ReleaseAccessToScreenNo (p)\n+      END\n+   END\n+END PickUpTreasure ;\n+\n+\n+PROCEDURE ScatterAllTreasures (p, r: CARDINAL) ;\n+VAR\n+   tp, tr,\n+   x, y, i : CARDINAL ;\n+   ok      : BOOLEAN ;\n+BEGIN\n+   FOR i := 1 TO MaxNoOfTreasures DO\n+      FOR tp := 0 TO NextFreePlayer-1 DO\n+         IF IsPlayerActive(tp)\n+         THEN\n+            WITH Player[tp] DO\n+               IF (i IN TreasureOwn) AND (r=RoomOfMan)\n+               THEN\n+                  REPEAT\n+                     RandomRoom(r, NoOfRoomsToSpring, tr) ;\n+                     PositionInRoom(tr, x, y, ok)\n+                  UNTIL ok ;\n+                  putDown (tp, tr, i, x, y) ;\n+                  printf (\"treasure %d is in room %d at %d,%d\\n\", i, tr, x, y)\n+               END\n+            END\n+         END\n+      END ;\n+      IF Treasure[i].Rm=r\n+      THEN\n+         REPEAT\n+            RandomRoom(r, NoOfRoomsToSpring, tr) ;\n+            PositionInRoom(tr, x, y, ok)\n+         UNTIL ok ;\n+         printf (\"treasure %d is in room %d at %d,%d\\n\", i, tr, x, y) ;\n+         WITH Treasure[i] DO\n+            EraseTreasure (Rm, Xpos, Ypos) ;\n+            EXCL (Rooms[Rm].Treasures, i) ;\n+            Xpos := x ;\n+            Ypos := y ;\n+            Rm := tr\n+         END ;\n+         INCL (Rooms[tr].Treasures, i)\n+      END ;\n+      WITH Treasure[i] DO\n+         DrawTreasure (Rm, Xpos, Ypos)\n+      END\n+   END ;\n+   FOR tp := 0 TO NextFreePlayer-1 DO\n+      IF IsPlayerActive(tp)\n+      THEN\n+         WITH Player[tp] DO\n+            IF (TreasureOwn#{}) AND (RoomOfMan=r)\n+            THEN\n+               (* Now undo treasures which have an automatic effect *)\n+               IF SpeedPotion IN TreasureOwn\n+               THEN\n+                  (* PutPriority(PlayerProcess(p), User, 3) *)\n+               END ;\n+\n+               TreasureOwn := {} ;\n+               GetAccessToScreenNo(tp) ;\n+\n+               WriteWeight(p, Weight) ;\n+               WriteCommentLine1(p, 'thy burdens') ;\n+               WriteCommentLine2(p, 'hast been') ;\n+               WriteCommentLine3(p, 'lifted') ;\n+\n+               ReleaseAccessToScreenNo(tp)\n+            END\n+         END\n+      END\n+   END\n+END ScatterAllTreasures ;\n+\n+\n+PROCEDURE ScatterTreasures (p, r: CARDINAL) ;\n+VAR\n+   c       : INTEGER ;\n+   x, y, i : CARDINAL ;\n+   ok      : BOOLEAN ;\n+BEGIN\n+   WITH Player[p] DO\n+      FOR i := 1 TO MaxNoOfTreasures DO\n+         IF i IN TreasureOwn\n+         THEN\n+            (* Now undo treasures which have an automatic effect *)\n+            IF SpeedPotion IN TreasureOwn\n+            THEN\n+               (* PutPriority(PlayerProcess(p), User, 3) *)\n+            END ;\n+\n+            REPEAT\n+               PositionInRoom(r, x, y, ok) ;\n+               IF ok\n+               THEN\n+                  WITH Treasure[i] DO\n+                     DEC(Weight, Tweight) ;\n+                     Xpos := x ;\n+                     Ypos := y ;\n+                     Rm := r\n+                  END ;\n+                  DrawTreasure(r, x, y) ;\n+                  INCL(Rooms[r].Treasures, i) ;\n+               ELSE\n+                  c := printf('trying another room\\n') ;\n+                  RandomRoom(r, 1, x) ;\n+                  r := x\n+               END\n+            UNTIL ok\n+         END\n+      END ;\n+      TreasureOwn := {} ;\n+      (* and respawn arrows.  *)\n+      RespawnArrow (r, 0, respawnmagic, magic, NoOfMagic, TicksPerSecond * RespawnMagicInventory) ;\n+      RespawnArrow (r, 0, respawnnormal, normal, NoOfNormal, TicksPerSecond * RespawnArrowInventory) ;\n+      GetAccessToScreenNo(p) ;\n+      WriteWeight(p, Weight) ;\n+      ReleaseAccessToScreenNo(p)\n+   END\n+END ScatterTreasures ;\n+\n+\n+PROCEDURE DropTreasure ;\n+VAR\n+   ok        : BOOLEAN ;\n+   p, TreasNo: CARDINAL ;\n+   ch,\n+   units,\n+   tens      : CHAR ;\n+BEGIN\n+   p := PlayerNo() ;\n+   GetAccessToScreenNo(p) ;\n+   WriteCommentLine2(p, 'which one?') ;\n+   ReleaseAccessToScreenNo(p) ;\n+   ch := ' ' ;\n+   units := ' ' ;\n+   tens := ' ' ;\n+   REPEAT\n+      tens := units ;\n+      units := ch ;\n+      ok := ClientRead(ch)\n+   UNTIL (NOT ok) OR (ch=cr) ;\n+   IF ok\n+   THEN\n+      IF (units>='0') AND (units<='9')\n+      THEN\n+         TreasNo := ORD(units)-ORD('0') ;\n+         IF (tens>='0') AND (tens<='9')\n+         THEN\n+            TreasNo := TreasNo+10*(ORD(tens)-ORD('0'))\n+         END\n+      END ;\n+      IF (TreasNo<1) OR (TreasNo>MaxNoOfTreasures)\n+      THEN\n+         GetAccessToScreenNo(p) ;\n+         WriteCommentLine1(p, 'thou canst') ;\n+         DelCommentLine2(p) ;\n+         DelCommentLine3(p);\n+         ReleaseAccessToScreenNo(p)\n+      ELSE\n+         GetWriteAccessToPlayer ;\n+         DropTreasure1(p, TreasNo) ;\n+         ReleaseWriteAccessToPlayer\n+      END\n+   END\n+END DropTreasure ;\n+\n+\n+PROCEDURE DropTreasure1(p, TreasNo: CARDINAL) ;\n+VAR\n+   x, y, d,\n+   r, z   : CARDINAL ;\n+   ok     : BOOLEAN ;\n+BEGIN\n+   WITH Player[p] DO\n+      IF TreasNo IN TreasureOwn\n+      THEN\n+         d := Direction ;\n+         r := RoomOfMan ;\n+         x := Xman ;\n+         y := Yman ;\n+         IncPosition(x, y, d) ;\n+         PointOnWall(r, x, y, ok) ;\n+         IF NOT ok\n+         THEN\n+            GetDoorOnPoint(r, x, y, z, ok) ;\n+            IF NOT ok\n+            THEN\n+               GetWriteAccessToTreasure ;\n+               FreeOfPlayersAndTreasure(r, x, y, ok) ;\n+               IF ok\n+               THEN\n+                  IF TreasNo>9\n+                  THEN\n+                     Tmessage[12] := '1' ;\n+                     Tmessage[13] := CHR((TreasNo MOD 10)+ORD('0'))\n+                  ELSE\n+                     Tmessage[12] := ' ' ;\n+                     Tmessage[13] := CHR(TreasNo+ORD('0'))\n+                  END ;\n+                  GetAccessToScreenNo(p) ;\n+                  WriteCommentLine1(p, Tmessage) ;\n+                  WriteCommentLine2(p, Treasure[TreasNo].TreasureName) ;\n+                  ReleaseAccessToScreenNo( p ) ;\n+                  PutDownTreasure(p, r, TreasNo, x, y)\n+               ELSE\n+                  GetAccessToScreenNo(p) ;\n+                  WriteCommentLine1(p, 'thou canst') ;\n+                  DelCommentLine2(p) ;\n+                  DelCommentLine3(p) ;\n+                  ReleaseAccessToScreenNo(p)\n+               END ;\n+               ReleaseWriteAccessToTreasure\n+            ELSE\n+               GetAccessToScreenNo(p) ;\n+               WriteCommentLine1(p, 'thou canst') ;\n+               DelCommentLine2(p) ;\n+               DelCommentLine3(p) ;\n+               ReleaseAccessToScreenNo(p)\n+            END\n+         ELSE\n+            GetAccessToScreenNo(p) ;\n+            WriteCommentLine1(p, 'thou canst') ;\n+            DelCommentLine2(p) ;\n+            DelCommentLine3(p) ;\n+            ReleaseAccessToScreenNo(p)\n+         END\n+      ELSE\n+         GetAccessToScreenNo(p) ;\n+         WriteCommentLine1(p, 'thou canst') ;\n+         DelCommentLine2(p) ;\n+         DelCommentLine3(p) ;\n+         ReleaseAccessToScreenNo(p)\n+      END\n+   END\n+END DropTreasure1 ;\n+\n+\n+(*\n+   putDown -\n+*)\n+\n+PROCEDURE putDown (p, r, TreasNo, tx, ty: CARDINAL) ;\n+BEGIN\n+   WITH Player[p] DO\n+      DEC (Weight, Treasure[TreasNo].Tweight) ;\n+      Treasure[TreasNo].Rm := r ;    (* Put in this Room *)\n+      Treasure[TreasNo].Xpos := tx ;\n+      Treasure[TreasNo].Ypos := ty ;\n+      Treasure[TreasNo].kind := onfloor ;\n+      INCL (Rooms[r].Treasures, TreasNo) ; (* Room has treasure             *)\n+      EXCL (TreasureOwn, TreasNo) ;  (* Player no longer has treasure *)\n+   END\n+END putDown ;\n+\n+\n+(*\n+   pickUp -\n+*)\n+\n+PROCEDURE pickUp (p, r, TreasNo: CARDINAL) ;\n+BEGIN\n+   WITH Player[p] DO\n+      INC (Weight, Treasure[TreasNo].Tweight) ;\n+      Treasure[TreasNo].Rm := 0 ; (* No longer in a Room *)\n+      Treasure[TreasNo].kind := onperson ; (* No longer in a Room *)\n+      INCL (TreasureOwn, TreasNo)\n+   END\n+END pickUp ;\n+\n+\n+PROCEDURE PutDownTreasure (p, r, TreasNo, tx, ty: CARDINAL) ;\n+VAR\n+   tr, i: CARDINAL ;\n+   ok   : BOOLEAN ;\n+   a    : ARRAY [0..14] OF CHAR ;\n+   b    : ARRAY [0..4] OF CHAR ;\n+BEGIN\n+   WITH Player[p] DO\n+      IF (TreasNo=SackOfCoal1) OR (TreasNo=SackOfCoal2)  (* Sacks Of Coal *)\n+      THEN\n+         IF r=SackOfCoal[TreasNo-SackOfCoal1]\n+         THEN\n+            GetAccessToScreenNo(p) ;\n+            WriteWeight(p, Weight) ;\n+            WriteCommentLine3(p, 'dropped') ;\n+            ReleaseAccessToScreenNo(p) ;\n+            putDown (p, r, TreasNo, tx, ty) ;\n+            DrawTreasure(r, tx, ty)\n+         ELSE\n+            StrCopy('to room ', a) ;\n+            CardToStr(SackOfCoal[TreasNo-SackOfCoal1], 4, b) ;\n+            StrConCat(a, b, a) ;\n+            GetAccessToScreenNo(p) ;\n+            WriteCommentLine3(p, a) ;\n+            ReleaseAccessToScreenNo(p)\n+         END\n+      ELSE\n+         IF TreasNo=SpeedPotion\n+         THEN\n+            (* PutPriority(CurrentProcess, User, 3) *)\n+         END ;\n+         putDown (p, r, TreasNo, tx, ty) ;\n+         GetAccessToScreenNo(p) ;\n+         WriteCommentLine3(p, 'dropped') ;\n+         WriteWeight(p, Weight) ;\n+         ReleaseAccessToScreenNo(p) ;\n+         DrawTreasure(r, tx, ty)\n+      END\n+   END\n+END PutDownTreasure ;\n+\n+\n+PROCEDURE UseTreasure ;\n+VAR\n+   x, y, d,\n+   r, p,\n+   TreasNo: CARDINAL ;\n+   ok     : BOOLEAN ;\n+   ch,\n+   units,\n+   tens   : CHAR ;\n+BEGIN\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      GetAccessToScreenNo(p) ;\n+      WriteCommentLine2(p, 'which one?') ;\n+      ReleaseAccessToScreenNo(p) ;\n+      ch := ' ' ;\n+      units := ' ' ;\n+      tens := ' ' ;\n+      REPEAT\n+         tens := units ;\n+         units := ch ;\n+         ok := ClientRead(ch)\n+      UNTIL (NOT ok) OR (ch=cr) ;\n+      IF ok\n+      THEN\n+         IF (units>='0') AND (units<='9')\n+         THEN\n+            TreasNo := ORD(units)-ORD('0') ;\n+            IF (tens>='0') AND (tens<='9')\n+            THEN\n+               TreasNo := TreasNo+10*(ORD(tens)-ORD('0'))\n+            END\n+         END ;\n+         GetReadAccessToPlayer ;\n+         IF (TreasNo<1) OR (TreasNo>MaxNoOfTreasures)\n+         THEN\n+            ReleaseReadAccessToPlayer ;\n+            GetAccessToScreenNo(p) ;\n+            WriteCommentLine1(p, 'thou canst') ;\n+            DelCommentLine2(p) ;\n+            DelCommentLine3(p) ;\n+            ReleaseAccessToScreenNo(p)\n+         ELSIF TreasNo IN TreasureOwn\n+         THEN\n+            ReleaseReadAccessToPlayer ;\n+            IF TreasNo>9\n+            THEN\n+               Tmessage[12] := tens ;\n+               Tmessage[13] := units\n+            ELSE\n+               Tmessage[12] := ' ' ;\n+               Tmessage[13] := units\n+            END ;\n+            GetAccessToScreenNo(p) ;\n+            WriteCommentLine1(p, 'using') ;\n+            WriteCommentLine2(p, Tmessage) ;\n+            WriteCommentLine3(p, Treasure[TreasNo].TreasureName) ;\n+            ReleaseAccessToScreenNo(p) ;\n+            IF TreasNo=MagicKey        (* Magic Key *)\n+            THEN\n+               HideDoor\n+            ELSIF TreasNo=CrystalBall  (* Crystal Ball *)\n+            THEN\n+               UseCrystalBall\n+            ELSIF TreasNo=HandGrenade  (* Hand Grenade *)\n+            THEN\n+               PullPin\n+            ELSIF TreasNo=TreasTrove\n+            THEN\n+               DisplayTreasures\n+            ELSIF TreasNo=VisionChest\n+            THEN\n+               DisplayEnemy\n+            END\n+         ELSE\n+            ReleaseReadAccessToPlayer ;\n+            GetAccessToScreenNo(p) ;\n+            WriteCommentLine1(p, 'thou canst') ;\n+            DelCommentLine2(p) ;\n+            DelCommentLine3(p) ;\n+            ReleaseAccessToScreenNo(p)\n+         END\n+      END\n+   END\n+END UseTreasure ;\n+\n+\n+PROCEDURE UseCrystalBall ;\n+VAR\n+   p, x, y,\n+   px, py,\n+   r, i : CARDINAL ;\n+   a    : ARRAY [0..14] OF CHAR ;\n+   b    : ARRAY [0..4]  OF CHAR ;\n+   who  : ARRAY [0..1] OF CARDINAL ;\n+   first: BOOLEAN ;\n+   ch   : CHAR ;\n+BEGIN\n+(*\n+   p := PlayerNo() ;\n+   first := TRUE ;\n+   FOR i := 0 TO MaxNoOfPlayers DO\n+      IF i#p\n+      THEN\n+         IF first\n+         THEN\n+            who[0] := i ;\n+            first := FALSE\n+         ELSE\n+            who[1] := i\n+         END\n+      END\n+   END ;\n+   GetReadAccessToPlayerNo( p ) ;\n+   WITH Player[p] DO\n+      px := Xman ;\n+      py := Yman\n+   END ;\n+   ReleaseReadAccessToPlayerNo( p ) ;\n+   GetReadAccessToPlayerNo( who[0] ) ;\n+   StrConCat('1: ', Player[who[0]].ManName, a ) ;\n+   ReleaseReadAccessToPlayerNo( who[0] ) ;\n+   GetAccessToScreenNo( p ) ;\n+   WriteCommentLine1(p, a) ;\n+   ReleaseAccessToScreenNo( p ) ;\n+   GetReadAccessToPlayerNo( who[1] ) ;\n+   StrConCat('2: ', Player[who[1]].ManName, a ) ;\n+   ReleaseReadAccessToPlayerNo( who[1] ) ;\n+   GetAccessToScreenNo( p ) ;\n+   WriteCommentLine2(p, a) ;\n+   WriteCommentLine3(p, 'peer at ?') ;\n+   ReleaseAccessToScreenNo( p ) ;\n+   REPEAT\n+      Read( ch ) ;\n+      IF (ch='1') OR (ch='2')\n+      THEN\n+         i := ORD(ch)-ORD('1') ;\n+         GetReadAccessToPlayerNo( who[i] ) ;\n+         WITH Player[who[i]] DO\n+            x := Xman ;\n+            y := Yman ;\n+            r := RoomOfMan\n+         END ;\n+         ReleaseReadAccessToPlayerNo( who[i] ) ;\n+         IF r=0\n+         THEN\n+            StrCopy('is slain: ', a )\n+         ELSE\n+            StrCopy('room', a) ;\n+            CardToStr( r, 4, b ) ;\n+            StrConCat( a, b, a ) ;\n+            StrConCat( a, ' ', a )\n+         END ;\n+         IF y>py\n+         THEN\n+            StrConCat( a, 'S', a )\n+         END ;\n+         IF y<py\n+         THEN\n+            StrConCat( a, 'N', a )\n+         END ;\n+         IF x>px\n+         THEN\n+            StrConCat( a, 'E', a )\n+         END ;\n+         IF x<px\n+         THEN\n+            StrConCat( a, 'W', a )\n+         END ;\n+         GetAccessToScreenNo( p ) ;\n+         IF ch='1'\n+         THEN\n+            WriteCommentLine1(p, a)\n+         ELSE\n+            WriteCommentLine2(p, a)\n+         END ;\n+         ReleaseAccessToScreenNo( p )\n+      END\n+   UNTIL (ch#'1') AND (ch#'2') ;\n+   GetAccessToScreenNo( p ) ;\n+   DelCommentLine1(p) ;\n+   DelCommentLine2(p) ;\n+   DelCommentLine3(p) ;\n+   ReleaseAccessToScreenNo( p )\n+*)\n+END UseCrystalBall ;\n+\n+(*\n+PROCEDURE DisplayWounds ;\n+VAR\n+   p, w,\n+   r, i : CARDINAL ;\n+   b    : ARRAY [0..4]  OF CHAR ;\n+   a    : ARRAY [0..14] OF CHAR ;\n+   who  : ARRAY [0..1] OF CARDINAL ;\n+   first: BOOLEAN ;\n+   ch   : CHAR ;\n+BEGIN\n+   p := PlayerNo() ;\n+   first := TRUE ;\n+   FOR i := 0 TO MaxNoOfPlayers DO\n+      IF i#p\n+      THEN\n+         IF first\n+         THEN\n+            who[0] := i ;\n+            first := FALSE\n+         ELSE\n+            who[1] := i\n+         END\n+      END\n+   END ;\n+   GetReadAccessToPlayerNo( who[0] ) ;\n+   StrConCat('1: ', Player[who[0]].ManName, a ) ;\n+   ReleaseReadAccessToPlayerNo( who[0] ) ;\n+   GetAccessToScreenNo( p ) ;\n+   WriteCommentLine1(p, a) ;\n+   ReleaseAccessToScreenNo( p ) ;\n+   GetReadAccessToPlayerNo( who[1] ) ;\n+   StrConCat('2: ', Player[who[1]].ManName, a ) ;\n+   ReleaseReadAccessToPlayerNo( who[1] ) ;\n+   GetAccessToScreenNo( p ) ;\n+   WriteCommentLine2(p, a) ;\n+   WriteCommentLine3(p, 'peer at ?') ;\n+   ReleaseAccessToScreenNo( p ) ;\n+   REPEAT\n+      Read( ch ) ;\n+      IF (ch='1') OR (ch='2')\n+      THEN\n+         i := ORD(ch)-ORD('1') ;\n+         GetReadAccessToPlayerNo( who[i] ) ;\n+         WITH Player[who[i]] DO\n+            w := Wounds ;\n+            r := RoomOfMan\n+         END ;\n+         ReleaseReadAccessToPlayerNo( who[i] ) ;\n+         IF r=0\n+         THEN\n+            StrCopy('is slain: ', a )\n+         ELSE\n+            StrCopy('Wounds ', a) ;\n+            CardToStr( w, 4, b ) ;\n+            StrConCat( a, b, a ) ;\n+            StrConCat( a, ' ', a )\n+         END ;\n+         GetAccessToScreenNo( p ) ;\n+         IF ch='1'\n+         THEN\n+            WriteCommentLine1(p, a)\n+         ELSE\n+            WriteCommentLine2(p, a)\n+         END ;\n+         ReleaseAccessToScreenNo( p )\n+      END\n+   UNTIL (ch#'1') AND (ch#'2') ;\n+   GetAccessToScreenNo( p ) ;\n+   DelCommentLine1(p) ;\n+   DelCommentLine2(p) ;\n+   DelCommentLine3(p) ;\n+   ReleaseAccessToScreenNo( p )\n+END DisplayWounds ;\n+*)\n+\n+PROCEDURE DisplayEnemy ;\n+VAR\n+   p,\n+   r, i : CARDINAL ;\n+   who  : ARRAY [0..1] OF CARDINAL ;\n+   a    : ARRAY [0..14] OF CHAR ;\n+   first: BOOLEAN ;\n+   ch   : CHAR ;\n+BEGIN\n+(*\n+   p := PlayerNo() ;\n+   first := TRUE ;\n+   FOR i := 0 TO MaxNoOfPlayers DO\n+      IF i#p\n+      THEN\n+         IF first\n+         THEN\n+            who[0] := i ;\n+            first := FALSE\n+         ELSE\n+            who[1] := i\n+         END\n+      END\n+   END ;\n+   REPEAT\n+      GetReadAccessToPlayerNo( who[0] ) ;\n+      StrConCat('1: ', Player[who[0]].ManName, a ) ;\n+      ReleaseReadAccessToPlayerNo( who[0] ) ;\n+      GetAccessToScreenNo( p ) ;\n+      WriteCommentLine1(p, a) ;\n+      ReleaseAccessToScreenNo( p ) ;\n+      GetReadAccessToPlayerNo( who[1] ) ;\n+      StrConCat('2: ', Player[who[1]].ManName, a ) ;\n+      ReleaseReadAccessToPlayerNo( who[1] ) ;\n+      GetAccessToScreenNo( p ) ;\n+      WriteCommentLine2(p, a) ;\n+      WriteCommentLine3(p, 'peer at ?') ;\n+      ReleaseAccessToScreenNo( p ) ;\n+      Read( ch ) ;\n+      IF (ch='1') OR (ch='2')\n+      THEN\n+         i := ORD(ch)-ORD('1') ;\n+         GetReadAccessToPlayerNo( who[i] ) ;\n+         WITH Player[who[i]] DO\n+            r := RoomOfMan\n+         END ;\n+         ReleaseReadAccessToPlayerNo( who[i] ) ;\n+         IF r=0\n+         THEN\n+            GetAccessToScreenNo( p ) ;\n+            IF ch='1'\n+            THEN\n+               WriteCommentLine1(p, 'is slain:')\n+            ELSE\n+               WriteCommentLine2(p, 'is slain:')\n+            END ;\n+            ReleaseAccessToScreenNo( p )\n+         ELSE\n+            DisplayEn( p, who[i] )\n+         END\n+      END\n+   UNTIL (ch#'1') AND (ch#'2') ;\n+   GetAccessToScreenNo( p ) ;\n+   DelCommentLine1(p) ;\n+   DelCommentLine2(p) ;\n+   DelCommentLine3(p) ;\n+   ReleaseAccessToScreenNo( p )\n+*)\n+END DisplayEnemy ;\n+\n+\n+PROCEDURE DisplayEn (p, e: CARDINAL) ;\n+VAR\n+   OldMan: Man ;\n+   ch    : CHAR ;\n+BEGIN\n+(* ******************\n+   (* Save player p man first *)\n+   GetWriteAccessToAllPlayers ;\n+   OldMan := Player[p] ;\n+   Player[p] := Player[e] ;\n+   (* Now draw Screen etc *)\n+   InitScreen ;\n+   DrawRoom ;\n+   DrawAllPlayers ;\n+   Player[p] := OldMan ;\n+   ReleaseWriteAccessToAllPlayers ;\n+   Read( ch ) ;\n+   IF Player[p].RoomOfMan#0   (* So alive - or just killed hopefully... *)\n+   THEN\n+      InitialDisplay\n+   END\n+********************** *)\n+END DisplayEn ;\n+\n+\n+PROCEDURE DisplayTreasures ;\n+VAR\n+   p, tp,\n+   i, j : CARDINAL ;\n+   ok   : BOOLEAN ;\n+   ch   : CHAR ;\n+   no   : ARRAY [0..3] OF CHAR ;\n+   line : ARRAY [0..80] OF CHAR ;\n+BEGIN\n+   p := PlayerNo() ;\n+   GetReadAccessToPlayer ;\n+   GetReadAccessToTreasure ;\n+   GetAccessToScreenNo(p) ;\n+   ClearScreen(p) ;\n+   FOR i := 1 TO MaxNoOfTreasures DO\n+      ok := FALSE ;\n+      FOR tp := 0 TO MaxNoOfPlayers DO\n+         IF IsPlayerActive(tp)\n+         THEN\n+            WITH Player[tp] DO\n+               IF i IN TreasureOwn\n+               THEN\n+                  StrCopy(ManName, line) ;\n+                  StrConCat(line, ' ', line) ;\n+                  ok := TRUE\n+               END\n+            END\n+         END\n+      END ;\n+      IF (Treasure[i].Rm # 0) AND (Treasure[i].kind = onfloor)\n+      THEN\n+         IF (NOT ok)\n+         THEN\n+            CardToStr(Treasure[i].Rm, 6, line) ;\n+            StrConCat(' ', line, line) ;\n+            StrConCat('Room Number', line, line) ;\n+         END ;\n+         StrConCat(line, ' has Treasure No ', line) ;\n+         CardToStr(i, 0, no) ;\n+         StrConCat(line, no, line) ;\n+         StrConCat(line, ' The ', line) ;\n+         StrConCat(line, Treasure[i].TreasureName, line) ;\n+         WriteString(p, line)\n+      END\n+   END ;\n+   ReleaseReadAccessToPlayer ;\n+   ReleaseReadAccessToTreasure ;\n+   ReleaseAccessToScreenNo(p) ;\n+   IF ClientRead(ch)\n+   THEN\n+   END ;\n+   InitialDisplay\n+END DisplayTreasures ;\n+\n+\n+PROCEDURE PullPin ;\n+VAR\n+   p: CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   GetWriteAccessToTreasure ;\n+   IF PinHasBeenPulled\n+   THEN\n+      ReleaseWriteAccessToTreasure ;\n+      GetAccessToScreen ;\n+      WriteCommentLine1(p, 'pin has been') ;\n+      WriteCommentLine2(p, 'pulled') ;\n+      DelCommentLine3(p) ;\n+      ReleaseAccessToScreen\n+   ELSE\n+      PinHasBeenPulled := TRUE ;\n+      PlayerPulled := p ;\n+      ReleaseWriteAccessToTreasure ;\n+      Signal(PinPulled)\n+   END\n+END PullPin ;\n+\n+\n+PROCEDURE Grenade ;\n+VAR\n+   pulled,\n+   RoomOfExplosion,\n+   sec, i,\n+   start : CARDINAL ;\n+   hit,\n+   ok    : BOOLEAN ;\n+   SlainP: PlayerSet ;\n+BEGIN\n+   LOOP\n+      Wait(PinPulled) ;\n+      pulled := PlayerPulled ;\n+      Sleep(25*TicksPerSecond) ;\n+\n+      (* Ok now explode! *)\n+\n+      hit := FALSE ;\n+      GetWriteAccessToPlayer ;\n+      GetWriteAccessToTreasure ;\n+\n+      (* Find out where grenade is! *)\n+\n+      WITH Treasure[HandGrenade] DO\n+         IF Rm=0\n+         THEN\n+            i := 0 ;\n+            RoomOfExplosion := 0 ;\n+            REPEAT\n+               IF IsPlayerActive(i)\n+               THEN\n+                  WITH Player[i] DO\n+                     IF HandGrenade IN TreasureOwn\n+                     THEN\n+                        RoomOfExplosion := RoomOfMan ;\n+                        DEC(Weight, Tweight) ;\n+                        EXCL(TreasureOwn, HandGrenade) ;\n+                        GetAccessToScreenNo(i) ;\n+                        WriteWeight(i, Weight) ;\n+                        ReleaseAccessToScreenNo(i)\n+                     END\n+                  END\n+               END ;\n+               INC(i)\n+            UNTIL (RoomOfExplosion#0) OR (i=NextFreePlayer)\n+         ELSE\n+            RoomOfExplosion := Rm ;\n+            EXCL(Rooms[Rm].Treasures, HandGrenade) ;\n+            EraseTreasure(Rm, Xpos, Ypos)\n+         END\n+      END ;\n+\n+      IF RoomOfExplosion # 0\n+      THEN\n+         SlainP := PlayerSet{} ;\n+         FOR i := 0 TO NextFreePlayer-1 DO\n+            IF IsPlayerActive(i)\n+            THEN\n+               WITH Player[i] DO\n+                  IF RoomOfExplosion=RoomOfMan\n+                  THEN\n+                     hit := TRUE ;\n+                     GetAccessToScreenNo(i) ;\n+                     UpDateWoundsAndFatigue(i) ;\n+                     WriteCommentLine1(i, 'boooommm') ;\n+                     DelCommentLine2(i) ;\n+                     DelCommentLine3(i) ;\n+                     IF Wounds>DammageByHandGrenade\n+                     THEN\n+                        DEC(Wounds, DammageByHandGrenade) ;\n+                     ELSE\n+                        INCL(SlainP, i) ;\n+                        Wounds := 0 ;\n+                        DeathType := explosion\n+                     END ;\n+                     WriteWounds(i, Wounds) ;\n+                     ReleaseAccessToScreenNo(i)\n+                  END\n+               END\n+            END\n+         END\n+      END ;\n+      ReleaseWriteAccessToTreasure ;\n+      ReleaseWriteAccessToPlayer ;\n+      IF RoomOfExplosion # 0\n+      THEN\n+         Explode(RoomOfExplosion, pulled, hit) ;\n+         FOR i := 0 TO MaxNoOfPlayers DO\n+            IF i IN SlainP\n+            THEN\n+               Dead(i, RoomOfExplosion)\n+            END\n+         END\n+      END ;\n+\n+      (* and hide the grenade again.  *)\n+      GetWriteAccessToPlayer ;\n+      GetWriteAccessToTreasure ;\n+      WITH Treasure[HandGrenade] DO\n+         REPEAT\n+            RandomRoom(RoomOfExplosion, NoOfRoomsToHideGrenade, Rm) ;\n+            PositionInRoom(Rm, Xpos, Ypos, ok)\n+         UNTIL ok ;\n+         INCL(Rooms[Rm].Treasures, HandGrenade) ;\n+         DrawTreasure(Rm, Xpos, Ypos)\n+      END ;\n+      PinHasBeenPulled := FALSE ;\n+      ReleaseWriteAccessToTreasure ;\n+      ReleaseWriteAccessToPlayer ;\n+   END\n+END Grenade ;\n+\n+\n+(*\n+   newQDesc -\n+*)\n+\n+PROCEDURE newQDesc (Rm, tno: CARDINAL; kind: TreasureKind; amount, ticks: CARDINAL) : QDesc ;\n+VAR\n+   d: QDesc ;\n+BEGIN\n+   IF freeDesc = NIL\n+   THEN\n+      NEW (d)\n+   ELSE\n+      d := freeDesc ;\n+      freeDesc := freeDesc^.right\n+   END ;\n+   d^.Rm := Rm ;\n+   d^.tno := tno ;\n+   d^.kind := kind ;\n+   d^.amount := amount ;\n+   d^.ticks := ticks ;\n+   d^.right := NIL ;\n+   RETURN d\n+END newQDesc ;\n+\n+\n+(*\n+   freeQ - return the head desc to the freeQ.\n+*)\n+\n+PROCEDURE freeQ ;\n+VAR\n+   desc: QDesc ;\n+BEGIN\n+   desc := qHead ;\n+   qHead := qHead^.right ;\n+   desc^.right := freeDesc ;\n+   freeDesc := desc\n+END freeQ ;\n+\n+\n+(*\n+   respawnThread -\n+*)\n+\n+PROCEDURE respawnThread ;\n+VAR\n+   desc: QDesc ;\n+BEGIN\n+   LOOP\n+      printf (\"respawnThread\\n\");\n+      Wait (qAvailable) ;\n+      REPEAT\n+         Wait (qMutex) ;\n+         armedTimer := ArmEvent (qHead^.ticks) ;\n+         Signal (qMutex) ;\n+      UNTIL NOT WaitOn (armedTimer) ;\n+      printf (\"respawnThread has waited\\n\");\n+      Wait (qMutex) ;\n+      IF qHead # NIL\n+      THEN\n+         WITH qHead^ DO\n+            IF tno < LowFreePool\n+            THEN\n+               RespawnTreasure (Rm, tno, 0)\n+            ELSE\n+               (* as the time is zero there is no need for a respawn kind.  *)\n+               RespawnArrow (Rm, tno, kind, kind, amount, 0)\n+            END\n+         END\n+      END ;\n+      freeQ ;\n+      Signal (qMutex)\n+   END\n+END respawnThread ;\n+\n+\n+(*\n+   relativeAdd -\n+*)\n+\n+PROCEDURE relativeAdd (desc: QDesc) ;\n+VAR\n+   s, t: QDesc ;\n+   sum : CARDINAL ;\n+BEGIN\n+(* works - ish...\n+   qHead := desc ;\n+   desc^.right := NIL ;\n+   RETURN ;\n+*)\n+   IF qHead = NIL\n+   THEN\n+      (* simple as the queue is empty (relative=absolute).  *)\n+      qHead := desc ;\n+      desc^.right := NIL\n+   ELSE\n+      (* at the end of the while loop sum will contain the total of all\n+         events up to but not including, t.\n+         If the value of sum is <  e^.NoOfTicks then e must be placed at the end\n+                                >= e^.NoOfTicks then e needs to be placed in the middle\n+      *)\n+\n+      sum := qHead^.ticks ;\n+      s := qHead ;\n+      t := qHead^.right ;      (* second event *)\n+      WHILE (sum < desc^.ticks) AND (t # NIL) DO\n+         INC (sum, t^.ticks) ;\n+         s := t ;\n+         t := t^.right\n+      END ;\n+      IF sum < desc^.ticks\n+      THEN\n+         (* desc will occur after all the current qHead has expired therefore\n+            we must add it to the end of the qHead. *)\n+         DEC (desc^.ticks, sum) ;\n+         s^.right:= desc ;\n+         desc^.right := NIL\n+      ELSE\n+         (* as sum >= desc^.ticks we know that desc is scheduled to occur\n+            in the middle of the queue but after, s.\n+         *)\n+         Assert (sum >= s^.ticks) ;\n+         DEC (desc^.ticks, sum - s^.ticks) ;\n+         desc^.right := t ;\n+         s^.right := desc\n+      END ;\n+      (* the first event after desc must have its relative ticks altered.  *)\n+      IF desc^.right # NIL\n+      THEN\n+         DEC (desc^.right^.ticks, desc^.ticks)\n+      END\n+   END\n+END relativeAdd ;\n+\n+\n+(*\n+   addToQueue -\n+*)\n+\n+PROCEDURE addToQueue (seedRoom: CARDINAL; tno: CARDINAL; kind: TreasureKind;\n+                      amount: CARDINAL; ticks: CARDINAL) ;\n+VAR\n+   desc: QDesc ;\n+BEGIN\n+   Wait (qMutex) ;\n+   desc := newQDesc (seedRoom, tno, kind, amount, ticks) ;\n+   relativeAdd (desc) ;\n+   IF armedTimer = NIL\n+   THEN\n+      armedTimer := ArmEvent (desc^.ticks)\n+   ELSE\n+      IF Cancel (armedTimer)\n+      THEN\n+      END ;\n+      armedTimer := ArmEvent (desc^.ticks)\n+   END ;\n+   Signal (qAvailable) ;\n+   Signal (qMutex) ;\n+   IF qThread = NIL\n+   THEN\n+      qThread := Resume (InitProcess (respawnThread, respawnStack, \"respawnThread\"))\n+   END\n+END addToQueue ;\n+\n+\n+PROCEDURE RespawnTreasure (seedRoom: CARDINAL; tno: CARDINAL; ticks: CARDINAL) ;\n+VAR\n+   x, y: CARDINAL ;\n+BEGIN\n+   IF ticks = 0\n+   THEN\n+      randomPlace (seedRoom, tno, onfloor)\n+   ELSE\n+      addToQueue (seedRoom, tno, onfloor, 0, ticks)\n+   END\n+END RespawnTreasure ;\n+\n+\n+(*\n+   findSpareTreasure -\n+*)\n+\n+PROCEDURE findSpareTreasure (newkind: TreasureKind) : CARDINAL ;\n+VAR\n+   i: CARDINAL ;\n+BEGIN\n+   i := LowFreePool ;\n+   WHILE i <= HighFreePool DO\n+      IF Treasure[i].kind = unused\n+      THEN\n+         Treasure[i].kind := newkind ;\n+         RETURN i\n+      END ;\n+      INC (i)\n+   END ;\n+   RETURN 0\n+END findSpareTreasure ;\n+\n+\n+(*\n+   randomPlace -\n+*)\n+\n+PROCEDURE randomPlace (seedRoom: CARDINAL; tno: CARDINAL; k: TreasureKind) ;\n+VAR\n+   x, y: CARDINAL ;\n+BEGIN\n+   IF RandomDrop (seedRoom, x, y)\n+   THEN\n+      WITH Treasure[tno] DO\n+         Rm := seedRoom ;\n+         Xpos := x ;\n+         Ypos := y ;\n+         kind := k ;\n+      END ;\n+      IF (tno >= LowFreePool) AND (tno <= HighFreePool)\n+      THEN\n+         IF k = magic\n+         THEN\n+            StrCopy ('Magic Arrows', Treasure[tno].TreasureName)\n+         ELSIF k = normal\n+         THEN\n+            StrCopy ('Arrow Quiver', Treasure[tno].TreasureName)\n+         END\n+      END ;\n+      INCL (Rooms[seedRoom].Treasures, tno) ;\n+      WITH Treasure[tno] DO\n+         IF (kind = onfloor) AND (Rm # 0)\n+         THEN\n+            DrawTreasure (Rm, Xpos, Ypos)\n+         END\n+      END\n+   END\n+END randomPlace ;\n+\n+\n+PROCEDURE RespawnArrow (seedRoom: CARDINAL; tno: CARDINAL;\n+                        spawnKind, arrowKind: TreasureKind;\n+                        amount: CARDINAL; ticks: CARDINAL) ;\n+BEGIN\n+   IF amount > 0\n+   THEN\n+      IF tno = 0\n+      THEN\n+         tno := findSpareTreasure (spawnKind) ;\n+      END ;\n+      IF tno # 0\n+      THEN\n+         (* this should nearly always be true, but if we did run out of slots then\n+            we forget the dynamic arrow treasure.  *)\n+         IF ticks = 0\n+         THEN\n+            randomPlace (seedRoom, tno, arrowKind)\n+         ELSE\n+            addToQueue (seedRoom, tno, arrowKind, amount, ticks)\n+         END\n+      END\n+   END\n+END RespawnArrow ;\n+\n+\n+(*\n+   initPool - initialise a treasure so that it might be dynamically allocated\n+              as items on the floor.\n+*)\n+\n+PROCEDURE initPool (i: CARDINAL) ;\n+BEGIN\n+   WITH Treasure[i] DO\n+      Xpos := 0 ;\n+      Ypos := 0 ;\n+      Rm := 0 ;\n+      Tweight := 0 ;\n+      StrCopy ('', TreasureName) ;\n+      kind := unused ;\n+      amount := 0\n+   END\n+END initPool ;\n+\n+\n+(*\n+   initTreasure - initialize weight and kind.\n+*)\n+\n+PROCEDURE initTreasure (i: CARDINAL; weight: CARDINAL; kind: TreasureKind) ;\n+BEGIN\n+   Treasure[i].Tweight := weight ;\n+   Treasure[i].kind := kind ;\n+END initTreasure ;\n+\n+\n+PROCEDURE Init ;\n+VAR\n+   i: CARDINAL ;\n+BEGIN\n+   FOR i := 1 TO MaxNoOfTreasures DO\n+      initPool (i)\n+   END ;\n+\n+   PinPulled := InitSemaphore(0, 'PinPulled') ;\n+   PinHasBeenPulled := FALSE ;\n+\n+   StrCopy('Magic Key'   , Treasure[MagicKey   ].TreasureName ) ;\n+   StrCopy('Crystal Ball', Treasure[CrystalBall].TreasureName ) ;\n+   StrCopy('Magic Spring', Treasure[MagicSpring].TreasureName ) ;\n+   StrCopy('Sack Of Coal', Treasure[SackOfCoal1].TreasureName ) ;\n+   StrCopy('Sack Of Coal', Treasure[SackOfCoal2].TreasureName ) ;\n+   StrCopy('Hot Iron'    , Treasure[HotIron    ].TreasureName ) ;\n+   StrCopy('Hand Grenade', Treasure[HandGrenade].TreasureName ) ;\n+   StrCopy('Magic Sword' , Treasure[MagicSword ].TreasureName ) ;\n+   StrCopy('Magic Shoes' , Treasure[MagicShoes ].TreasureName ) ;\n+   StrCopy('Sleep Potion', Treasure[SleepPotion].TreasureName ) ;\n+   StrCopy('Lump Of Iron', Treasure[LumpOfIron ].TreasureName ) ;\n+   StrCopy('Treas. Trove', Treasure[TreasTrove ].TreasureName ) ;\n+   StrCopy('Speed Potion', Treasure[SpeedPotion].TreasureName ) ;\n+   StrCopy('Magic Shield', Treasure[MagicShield].TreasureName ) ;\n+   StrCopy('Vision Chest', Treasure[VisionChest].TreasureName ) ;\n+   StrCopy('Arrow Quiver', Treasure[QuiverNormal].TreasureName ) ;\n+   StrCopy('Magic Arrows', Treasure[QuiverMagic].TreasureName ) ;\n+   StrCopy('Salve       ', Treasure[HealingPotion].TreasureName ) ;\n+\n+   initTreasure (MagicKey   ,   0, unused) ;\n+   initTreasure (CrystalBall,  33, unused) ;\n+   initTreasure (MagicSpring,   0, unused) ;\n+   initTreasure (SackOfCoal1, 100, unused) ;\n+   initTreasure (SackOfCoal2, 100, unused) ;\n+   initTreasure (HotIron    ,   4, unused) ;   (* was   4 *)\n+   initTreasure (HandGrenade,   3, unused) ;   (* was   3 *)\n+   initTreasure (MagicSword ,   1, unused) ;   (* was   1 *)\n+   initTreasure (MagicShoes ,   0, unused) ;   (* was   0 *)\n+   initTreasure (SleepPotion,   5, unused) ;   (* was   5 *)\n+   initTreasure (LumpOfIron ,   0, unused) ;   (* was   0 *)\n+   initTreasure (TreasTrove ,  53, unused) ;   (* was  43 *)\n+   initTreasure (SpeedPotion,   0, unused) ;   (* was   0 *)\n+   initTreasure (MagicShield,   2, unused) ;   (* was   2 *)\n+   initTreasure (VisionChest, 120, unused) ;   (* was 150 *)\n+   initTreasure (HealingPotion, 0, unused) ;\n+\n+   StrCopy('Treasure No xx', Tmessage ) ;\n+   armedTimer := NIL ;\n+   qMutex := InitSemaphore (1, \"qMutex\") ;\n+   qAvailable := InitSemaphore (0, \"qAvailable\") ;\n+   qHead := NIL ;\n+   freeDesc := NIL ;\n+   qThread := NIL\n+END Init ;\n+\n+\n+BEGIN\n+   Init\n+END AdvTreasure.\n+(*\n+ * Local variables:\n+ *  compile-command: \"make\"\n+ * End:\n+ *)"}, {"sha": "e9ba40170801ca106776c44f7ec6dfa26ee5b23b", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvUtil.def", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvUtil.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvUtil.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvUtil.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,57 @@\n+DEFINITION MODULE AdvUtil ;\n+\n+\n+EXPORT QUALIFIED InitialDisplay, TestIfLastLivePlayer,\n+                 GetDoorOnPoint, PointOnWall, PointOnTreasure,\n+                 Positioning, RandomRoom, PositionInRoom,\n+                 FreeOfPlayersAndTreasure,\n+                 MoveMan, Dead, Exit,\n+                 OpenDoor, CloseDoor, ExamineDoor, HideDoor,\n+                 MagicArrow, NormalArrow, HideTreasure,\n+                 Parry, Thrust, Attack,\n+                 Speak ;\n+\n+\n+PROCEDURE InitialDisplay ;\n+PROCEDURE Positioning ;\n+PROCEDURE Dead (p, room: CARDINAL) ;\n+PROCEDURE TestIfLastLivePlayer (VAR yes: BOOLEAN) ;\n+PROCEDURE PointOnWall (RoomNo, x, y: CARDINAL ; VAR Success: BOOLEAN) ;\n+\n+PROCEDURE GetDoorOnPoint (RoomNo, x, y: CARDINAL ;\n+                          VAR DoorNo: CARDINAL ; VAR Success: BOOLEAN) ;\n+\n+PROCEDURE PointOnTreasure (RoomNo, x, y: CARDINAL ;\n+                           VAR TreasNo: CARDINAL ; VAR Success: BOOLEAN) ;\n+\n+PROCEDURE FreeOfPlayersAndTreasure (room, x, y: CARDINAL ;\n+                                    VAR Success: BOOLEAN) ;\n+\n+PROCEDURE RandomRoom (CurrentRoom, NoOfRoomsApart: CARDINAL ;\n+                      VAR room: CARDINAL) ;\n+\n+(*\n+   HideTreasure - hides treasure, t, which is assummed to be absent from the\n+                  data structures when this procedure is called.\n+*)\n+\n+PROCEDURE HideTreasure (t: CARDINAL) ;\n+\n+PROCEDURE PositionInRoom (room: CARDINAL ;\n+                          VAR x, y: CARDINAL ; VAR Success: BOOLEAN) ;\n+\n+PROCEDURE MoveMan (n: CARDINAL) ;\n+PROCEDURE MagicArrow (p: CARDINAL) ;\n+PROCEDURE NormalArrow (p: CARDINAL) ;\n+PROCEDURE OpenDoor ;\n+PROCEDURE CloseDoor ;\n+PROCEDURE ExamineDoor ;\n+PROCEDURE HideDoor ;\n+PROCEDURE Parry ;\n+PROCEDURE Attack ;\n+PROCEDURE Thrust ;\n+PROCEDURE Speak ;\n+PROCEDURE Exit ;\n+\n+\n+END AdvUtil."}, {"sha": "f8a84f5d693af50829b0497adc86fa590cb74304", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/AdvUtil.mod", "status": "added", "additions": 1573, "deletions": 0, "changes": 1573, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvUtil.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvUtil.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FAdvUtil.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,1573 @@\n+IMPLEMENTATION MODULE AdvUtil ;\n+\n+\n+FROM libc IMPORT printf ;\n+FROM AdvSystem IMPORT PlayerSet ;\n+FROM ASCII IMPORT cr, lf, nul, bs, del, nak ;\n+FROM Screen IMPORT WriteString ;\n+FROM Storage IMPORT ALLOCATE, DEALLOCATE ;\n+FROM Assertion IMPORT Assert ;\n+FROM AdvSound IMPORT Miss, Swish, Hit ;\n+\n+FROM AdvSystem IMPORT Player, PlayerNo, IsPlayerActive,\n+                      MaxNoOfPlayers,\n+                      ArrowArgs,\n+                      NextFreePlayer,\n+                      TypeOfDeath,\n+                      RandomNumber,\n+                      DefaultWrite,\n+\n+                      GetReadAccessToPlayer,\n+                      ReleaseReadAccessToPlayer,\n+                      GetWriteAccessToPlayer,\n+                      ReleaseWriteAccessToPlayer,\n+\n+                      GetReadAccessToTreasure,\n+                      ReleaseReadAccessToTreasure,\n+                      GetWriteAccessToTreasure,\n+                      ReleaseWriteAccessToTreasure,\n+\n+                      GetReadAccessToDoor,\n+                      ReleaseReadAccessToDoor,\n+                      GetWriteAccessToDoor,\n+                      ReleaseWriteAccessToDoor,\n+\n+                      GetAccessToScreen,\n+                      ReleaseAccessToScreen,\n+                      GetAccessToScreenNo,\n+                      ReleaseAccessToScreenNo,\n+                      ClientRead ;\n+\n+FROM AdvMath IMPORT MaxNoOfTreasures ;\n+\n+FROM AdvMap IMPORT Treasure, Rooms, DoorStatus, TreasureKind,\n+                   NoOfRoomsToHidePlayers,\n+                   ActualNoOfRooms,\n+                   IncPosition ;\n+\n+FROM Executive IMPORT GetCurrentProcess, Wait, Signal ;\n+FROM TimerHandler IMPORT Sleep, TicksPerSecond, GetTicks ;\n+FROM ProcArgs IMPORT ProcessArgs, CollectArgs ;\n+\n+FROM Screen IMPORT InitScreen,\n+                   WriteWounds,\n+                   WriteRoom, WriteWeight,\n+                   WriteCommentLine1, DelCommentLine1,\n+                   WriteCommentLine2, DelCommentLine2,\n+                   WriteCommentLine3, DelCommentLine3,\n+                   InnerX, OuterX, InnerY, OuterY, OffX, OffY,\n+                   Height, Width ;\n+\n+FROM AdvMath IMPORT DammageByParry,\n+                    DammageByAttack,\n+                    DammageByThrust,\n+                    DammageByFireArrow,\n+                    DammageByFireMagic,\n+                    DammageByMagicParry,\n+                    DammageByMagicAttack,\n+                    DammageByMagicThrust,\n+\n+                    MagicSword,\n+                    MagicShield,\n+\n+                    StrengthToParry,\n+                    StrengthToAttack,\n+                    StrengthToThrust,\n+                    StrengthToFireArrow,\n+                    StrengthToFireMagic,\n+                    StrengthToMove,\n+                    UpDateWoundsAndFatigue ;\n+\n+FROM DrawL IMPORT DrawAllPlayers, DrawRoom, ClearRoom ;\n+\n+FROM DrawG IMPORT DrawMan, EraseMan, DrawDoor, DrawArrow, EraseArrow,\n+                  DisplayMessage, DrawTreasure ;\n+\n+FROM AdvTreasure IMPORT ScatterTreasures, RespawnTreasure ;\n+\n+\n+CONST\n+   SquaresPerSecond =    25 ;    (* speed of arrows *)\n+   DelayPerSquare   = TicksPerSecond DIV SquaresPerSecond ;\n+\n+\n+PROCEDURE Max (a, b: CARDINAL) : CARDINAL ;\n+BEGIN\n+   IF a>b\n+   THEN\n+      RETURN( a )\n+   ELSE\n+      RETURN( b )\n+   END\n+END Max ;\n+\n+\n+PROCEDURE PointOnLine (x, y, x1, y1, x2, y2: CARDINAL ; VAR ok: BOOLEAN) ;\n+BEGIN\n+   IF (x=x1) AND (y>=y1) AND (y<=y2)\n+   THEN\n+      ok := TRUE\n+   ELSIF (y=y1) AND (x>=x1) AND (x<=x2)\n+   THEN\n+      ok := TRUE\n+   ELSE\n+      ok := FALSE\n+   END\n+END PointOnLine ;\n+\n+\n+(* All the following routines assume that the calling process has gained *)\n+(* access to map, if needed!                                             *)\n+\n+PROCEDURE ChangeStatusOfDoor (RoomNo, DoorNo: CARDINAL ; ds: DoorStatus) ;\n+VAR\n+   r,i,x1,x2,y1,y2: CARDINAL ;\n+BEGIN\n+   WITH Rooms[RoomNo].Doors[DoorNo] DO\n+      r := LeadsTo ;\n+      StateOfDoor := ds ;\n+      x1 := Position.X1 ;\n+      y1 := Position.Y1 ;\n+      x2 := Position.X2 ;\n+      y2 := Position.Y2\n+   END ;\n+   DrawDoor( RoomNo, DoorNo ) ;\n+   IF r#0\n+   THEN\n+      GetDoorIndex( r, x1, y1, x2, y2, i ) ;\n+      Rooms[r].Doors[i].StateOfDoor := ds ;\n+      DrawDoor( r, i )\n+   END\n+END ChangeStatusOfDoor ;\n+\n+\n+PROCEDURE GetDoorIndex (RoomNo,\n+                        x1, y1, x2, y2: CARDINAL ;\n+                        VAR i: CARDINAL) ;\n+VAR\n+   Max : CARDINAL ;\n+   ok  : BOOLEAN ;\n+BEGIN\n+   i := 1 ;\n+   ok := TRUE ;\n+   Max := Rooms[RoomNo].NoOfDoors ;\n+   WITH Rooms[RoomNo] DO\n+      WHILE (i<=NoOfDoors) AND ok DO\n+         WITH Doors[i].Position DO\n+            IF (x1=X1) AND (y1=Y1) AND\n+               (x2=X2) AND (y2=Y2)\n+            THEN\n+               ok := FALSE\n+            ELSE\n+               INC( i )\n+            END\n+         END\n+      END\n+   END\n+END GetDoorIndex ;\n+\n+\n+PROCEDURE GetDoorOnPoint (RoomNo, x, y: CARDINAL ;\n+                          VAR DoorNo: CARDINAL ; VAR Success: BOOLEAN) ;\n+VAR\n+   Max : CARDINAL ;\n+BEGIN\n+   Max := Rooms[RoomNo].NoOfDoors ;\n+   DoorNo := 1 ;\n+   Success := FALSE ;\n+   WITH Rooms[RoomNo] DO\n+      WHILE (NOT Success) AND (DoorNo<=Max) DO\n+         WITH Doors[DoorNo].Position DO\n+            PointOnLine( x, y, X1, Y1, X2, Y2, Success ) ;\n+            IF NOT Success\n+            THEN\n+               INC( DoorNo )\n+            END\n+         END\n+      END\n+   END\n+END GetDoorOnPoint ;\n+\n+\n+PROCEDURE OpenToClosedDoor (VAR Success: BOOLEAN) ;\n+VAR\n+   x, y, DoorNo: CARDINAL ;\n+BEGIN\n+   WITH Player[PlayerNo()] DO\n+      x := Xman ;\n+      y := Yman ;\n+      IncPosition( x, y, Direction ) ;\n+      GetDoorOnPoint( RoomOfMan, x, y, DoorNo, Success ) ;\n+      IF Success\n+      THEN\n+         IF Rooms[RoomOfMan].Doors[DoorNo].StateOfDoor=Open\n+         THEN\n+            ChangeStatusOfDoor( RoomOfMan, DoorNo, Closed )\n+         ELSE\n+            Success := FALSE\n+         END\n+      END\n+   END\n+END OpenToClosedDoor ;\n+\n+\n+PROCEDURE ClosedToOpenDoor (VAR Success: BOOLEAN) ;\n+VAR\n+   x, y, DoorNo: CARDINAL ;\n+BEGIN\n+   WITH Player[PlayerNo()] DO\n+      x := Xman ;\n+      y := Yman ;\n+      IncPosition(x, y, Direction) ;\n+      GetDoorOnPoint( RoomOfMan, x, y, DoorNo, Success ) ;\n+      IF Success\n+      THEN\n+         IF Rooms[RoomOfMan].Doors[DoorNo].StateOfDoor=Closed\n+         THEN\n+            ChangeStatusOfDoor( RoomOfMan, DoorNo, Open )\n+         ELSE\n+            Success := FALSE\n+         END\n+      END\n+   END\n+END ClosedToOpenDoor ;\n+\n+\n+PROCEDURE ClosedToSecretDoor (VAR Success: BOOLEAN) ;\n+VAR\n+   x, y, DoorNo: CARDINAL ;\n+BEGIN\n+   WITH Player[PlayerNo()] DO\n+      x := Xman ;\n+      y := Yman ;\n+      IncPosition( x, y, Direction ) ;\n+      GetDoorOnPoint( RoomOfMan, x, y, DoorNo, Success ) ;\n+      IF Success\n+      THEN\n+         IF Rooms[RoomOfMan].Doors[DoorNo].StateOfDoor=Closed\n+         THEN\n+            ChangeStatusOfDoor( RoomOfMan, DoorNo, Secret )\n+         ELSE\n+            Success := FALSE\n+         END\n+      END\n+   END\n+END ClosedToSecretDoor ;\n+\n+\n+PROCEDURE SecretToClosedDoor (VAR Success: BOOLEAN) ;\n+VAR\n+   x, y, DoorNo: CARDINAL ;\n+BEGIN\n+   WITH Player[PlayerNo()] DO\n+      x := Xman ;\n+      y := Yman ;\n+      IncPosition( x, y, Direction ) ;\n+      GetDoorOnPoint( RoomOfMan, x, y, DoorNo, Success ) ;\n+      IF Success\n+      THEN\n+         IF Rooms[RoomOfMan].Doors[DoorNo].StateOfDoor=Secret\n+         THEN\n+            ChangeStatusOfDoor( RoomOfMan, DoorNo, Closed )\n+         ELSE\n+            Success := FALSE\n+         END\n+      END\n+   END\n+END SecretToClosedDoor ;\n+\n+\n+PROCEDURE PointOnWall (RoomNo, x, y: CARDINAL ;\n+                       VAR Success: BOOLEAN) ;\n+VAR\n+   Max,\n+   WallNo : CARDINAL ;\n+BEGIN\n+   Max := Rooms[RoomNo].NoOfWalls ;\n+   WallNo := 1 ;\n+   Success := FALSE ;\n+   WHILE (NOT Success) AND (WallNo<=Max) DO\n+      WITH Rooms[RoomNo].Walls[WallNo] DO\n+         PointOnLine( x, y, X1, Y1, X2, Y2, Success ) ;\n+         IF NOT Success\n+         THEN\n+            INC( WallNo )\n+         END\n+      END\n+   END\n+END PointOnWall ;\n+\n+\n+PROCEDURE PointOnTreasure (RoomNo, x, y: CARDINAL ;\n+                           VAR TreasNo: CARDINAL ; VAR Success: BOOLEAN) ;\n+BEGIN\n+   TreasNo := 1 ;\n+   Success := FALSE ;\n+   WHILE (NOT Success) AND (TreasNo<=MaxNoOfTreasures) DO\n+      WITH Treasure[TreasNo] DO\n+         IF (Rm = RoomNo) AND (kind = onfloor)\n+         THEN\n+            IF (Xpos=x) AND (Ypos=y)\n+            THEN\n+               Success := TRUE\n+            ELSE\n+               INC( TreasNo )\n+            END\n+         ELSE\n+            INC( TreasNo )\n+         END\n+      END\n+   END\n+END PointOnTreasure ;\n+\n+\n+(* This routine finds out if a point is upon a player. It does use *)\n+(* GetReadAccessToPlayer & ReleaseReadAccessToPlayer. This routine *)\n+(* returns Success if the point was on a player and also sets      *)\n+(* PlayNo to tell which player is upon this square.                *)\n+\n+PROCEDURE PointOnPlayer (RoomNo, x, y: CARDINAL ;\n+                         VAR PlayNo: CARDINAL ; VAR Success: BOOLEAN) ;\n+BEGIN\n+   PlayNo := 0 ;\n+   Success := FALSE ;\n+   GetReadAccessToPlayer ;\n+   WHILE (NOT Success) AND (PlayNo<NextFreePlayer) DO\n+      WITH Player[PlayNo] DO\n+         IF IsPlayerActive(PlayNo) AND (Xman=x) AND (Yman=y)\n+         THEN\n+            Success := TRUE\n+         ELSE\n+            INC(PlayNo)\n+         END\n+      END\n+   END ;\n+   ReleaseReadAccessToPlayer\n+END PointOnPlayer ;\n+\n+\n+PROCEDURE TestIfLastLivePlayer (VAR yes: BOOLEAN) ;\n+VAR\n+   p, i: CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   i := 0 ;\n+   yes := TRUE ;\n+   WHILE (i<NextFreePlayer) AND yes DO\n+      IF p#i\n+      THEN\n+         IF (Player[i].DeathType=living) AND IsPlayerActive(i)\n+         THEN\n+            yes := FALSE\n+         END\n+      END ;\n+      INC( i )\n+   END\n+END TestIfLastLivePlayer ;\n+\n+PROCEDURE ReceiveFireFromProcess (p: CARDINAL;\n+                                  VAR r, x, y, d: CARDINAL; magic: BOOLEAN) ;\n+VAR\n+   aa: ArrowArgs ;\n+BEGIN\n+   IF magic\n+   THEN\n+      aa := CollectArgs(Player[p].MagicProcArgs)\n+   ELSE\n+      aa := CollectArgs(Player[p].NormalProcArgs)\n+   END ;\n+   WITH aa^ DO\n+      Assert(p=ArrowPlayer) ;\n+      r := ArrowRoom ;\n+      x := ArrowX ;\n+      y := ArrowY ;\n+      d := ArrowDir\n+   END ;\n+   DISPOSE(aa)\n+END ReceiveFireFromProcess ;\n+\n+\n+PROCEDURE NormalArrow (p: CARDINAL) ;\n+VAR\n+   x, y, r,\n+   d,\n+   player : CARDINAL ;\n+   hit,\n+   done,\n+   SlainP : BOOLEAN ;\n+BEGIN\n+   WITH Player[p] DO\n+      LOOP\n+         SlainP := FALSE ;\n+         ReceiveFireFromProcess(p, r, x, y, d, FALSE) ;\n+         REPEAT\n+            FireArrow(p, r, x, y, d, hit, player) ;\n+            IF hit\n+            THEN\n+               GetReadAccessToPlayer ;\n+               WITH Player[player] DO\n+                  IF MagicShield IN TreasureOwn\n+                  THEN\n+                     done := FALSE ;\n+                     d := (d+2) MOD 4 ;\n+                     x := Xman ;\n+                     y := Yman ;\n+                     r := RoomOfMan ;\n+                     IncPosition(x, y, d)\n+                  ELSE\n+                     done := TRUE\n+                  END\n+               END ;\n+               ReleaseReadAccessToPlayer\n+            ELSE\n+               done := TRUE\n+            END\n+         UNTIL done ;\n+         IF hit\n+         THEN\n+            WITH Player[player] DO\n+               GetWriteAccessToPlayer ;\n+\n+               GetAccessToScreenNo(player) ;\n+               UpDateWoundsAndFatigue(player) ;\n+               IF Wounds<=DammageByFireArrow\n+               THEN\n+                  r := RoomOfMan ;\n+                  SlainP := TRUE ;\n+                  Wounds := 0 ;\n+                  DeathType := normalarrow ;\n+               ELSE\n+                  DEC( Wounds, DammageByFireArrow )\n+               END ;\n+               WriteWounds(player, Wounds) ;\n+               WriteCommentLine1(player, 'struck thee') ;\n+               DelCommentLine2(player) ;\n+               DelCommentLine3(player) ;\n+               ReleaseAccessToScreenNo(player) ;\n+\n+               GetAccessToScreenNo(p) ;\n+               IF Wounds=0\n+               THEN\n+                  DelCommentLine1(p) ;\n+                  WriteCommentLine2(p, 'slain') ;\n+                  WriteCommentLine3(p,  ManName )\n+               ELSE\n+                  WriteCommentLine1(p, 'thwunk') ;\n+                  DelCommentLine2(p) ;\n+                  DelCommentLine3(p)\n+               END ;\n+               ReleaseAccessToScreenNo(p) ;\n+               ReleaseWriteAccessToPlayer\n+            END\n+         ELSE\n+            GetAccessToScreenNo(p) ;\n+            WriteCommentLine1(p, 'swish') ;\n+            DelCommentLine2(p) ;\n+            DelCommentLine3(p) ;\n+            ReleaseAccessToScreenNo(p)\n+         END ;\n+         IF SlainP\n+         THEN\n+            Dead(player, r)\n+         END\n+      END\n+   END\n+END NormalArrow ;\n+\n+\n+PROCEDURE MagicArrow (p: CARDINAL) ;\n+VAR\n+   x, y, r,\n+   d,\n+   player : CARDINAL ;\n+   hit,\n+   SlainP : BOOLEAN ;\n+BEGIN\n+   WITH Player[p] DO\n+      LOOP\n+         SlainP := FALSE ;\n+         ReceiveFireFromProcess(p, r, x, y, d, TRUE) ;\n+         FireArrow(p, r, x, y, d, hit, player) ;\n+         IF hit\n+         THEN\n+            WITH Player[player] DO\n+               GetWriteAccessToPlayer ;\n+\n+               GetAccessToScreenNo(player) ;\n+               UpDateWoundsAndFatigue(player) ;\n+               IF Wounds<=DammageByFireMagic\n+               THEN\n+                  r := RoomOfMan ;\n+                  SlainP := TRUE ;\n+                  DeathType := magicarrow ;\n+                  Wounds := 0\n+               ELSE\n+                  DEC(Wounds, DammageByFireMagic)\n+               END ;\n+               WriteWounds(player, Wounds) ;\n+               WriteCommentLine1(player, 'struck thee') ;\n+               DelCommentLine2(player) ;\n+               DelCommentLine3(player) ;\n+               ReleaseAccessToScreenNo(player) ;\n+\n+               GetAccessToScreenNo(p) ;\n+\n+               IF Wounds=0\n+               THEN\n+                  DelCommentLine1(p) ;\n+                  WriteCommentLine2(p, 'slain') ;\n+                  WriteCommentLine3(p,  ManName)\n+               ELSE\n+                  WriteCommentLine1(p, 'thwunk') ;\n+                  DelCommentLine2(p) ;\n+                  DelCommentLine3(p)\n+               END ;\n+               ReleaseAccessToScreenNo(p) ;\n+               ReleaseWriteAccessToPlayer\n+            END\n+         ELSE\n+            GetAccessToScreenNo(p) ;\n+\n+            WriteCommentLine1(p, 'swish') ;\n+            DelCommentLine2(p) ;\n+            DelCommentLine3(p) ;\n+            ReleaseAccessToScreenNo(p)\n+         END ;\n+         IF SlainP\n+         THEN\n+            Dead(player, r)\n+         END\n+      END\n+   END\n+END MagicArrow ;\n+\n+\n+PROCEDURE FireArrow (p, r, x, y, d: CARDINAL ;\n+                     VAR hit: BOOLEAN ; VAR player: CARDINAL) ;\n+VAR\n+   t           : INTEGER ;\n+   NotCont     : BOOLEAN ;\n+   door,\n+   X, Y,\n+   i, j        : CARDINAL ;\n+   playerscreen: PlayerSet ;\n+   LastTime,\n+   DelayTime   : CARDINAL ;\n+BEGIN\n+   i := x ;   (* old x & y         *)\n+   j := y ;\n+   playerscreen := PlayerSet{} ;\n+   Swish(r) ;\n+   REPEAT\n+      LastTime := GetTicks() ;\n+      PointOnPlayer(r, x, y, player, NotCont) ;\n+      hit := NotCont ;\n+      IF NOT NotCont\n+      THEN\n+         GetReadAccessToDoor ;\n+         GetDoorOnPoint(r, x, y, door, NotCont) ;\n+         IF NotCont\n+         THEN\n+            WITH Rooms[r].Doors[door] DO\n+               IF (StateOfDoor=Open) AND (LeadsTo#0)\n+               THEN\n+                  NotCont := FALSE ;\n+                  r := LeadsTo\n+               END\n+            END ;\n+            ReleaseReadAccessToDoor ;\n+         ELSE\n+            ReleaseReadAccessToDoor ;\n+            PointOnWall(r, x, y, NotCont) ;\n+            IF NOT NotCont\n+            THEN\n+               GetReadAccessToTreasure ;\n+               PointOnTreasure(r, x, y, door, NotCont) ;\n+               ReleaseReadAccessToTreasure ;\n+               IF NOT NotCont\n+               THEN\n+                  GetReadAccessToPlayer ;\n+                  EraseArrow(i, j, playerscreen, FALSE) ;\n+                  DrawArrow(r, x, y, d, playerscreen) ;\n+                  ReleaseReadAccessToPlayer ;\n+                  i := x ;\n+                  j := y\n+               END\n+            END\n+         END\n+      END ;\n+      IncPosition(x, y, d) ;\n+      (* now we regulate a constant velocity arrow! *)\n+      DelayTime := GetTicks() - LastTime ;\n+      IF DelayTime<DelayPerSquare\n+      THEN\n+         (* t := printf(\"before Sleep for %d ticks\\n\", DelayPerSquare-DelayTime) ; *)\n+         Sleep(DelayPerSquare-DelayTime)\n+         (* ; t := printf(\"after Sleep\\n\") ; *)\n+      END\n+   UNTIL NotCont ;\n+   IF hit\n+   THEN\n+      Hit(p)\n+   ELSE\n+      Miss(r)\n+   END ;\n+   IF (X#i) OR (Y#j)\n+   THEN\n+      GetReadAccessToPlayer ;\n+      EraseArrow(i, j, playerscreen, TRUE) ;\n+      ReleaseReadAccessToPlayer\n+   END\n+END FireArrow ;\n+\n+\n+PROCEDURE Exit ;\n+VAR\n+   p  : CARDINAL ;\n+   yes: BOOLEAN ;\n+BEGIN\n+   p := PlayerNo() ;\n+   GetReadAccessToPlayer ;\n+   TestIfLastLivePlayer(yes) ;\n+   ReleaseReadAccessToPlayer ;\n+   IF NOT yes\n+   THEN\n+      Dead(p, Player[p].RoomOfMan)\n+   END\n+END Exit ;\n+\n+\n+(* MoveMan moves the man forward n squares, providing these squares   *)\n+(* are free from a WALL, DOOR (closed, secret), TREASURE and MAN.     *)\n+\n+PROCEDURE MoveMan (n: CARDINAL) ;\n+VAR\n+   p   : CARDINAL ;\n+   yes : BOOLEAN ;\n+BEGIN\n+   IF n>0\n+   THEN\n+      p := PlayerNo() ;\n+      GetWriteAccessToPlayer ;\n+      MoveMan1(n, p) ;\n+      ReleaseWriteAccessToPlayer ;\n+      IF Player[p].DeathType=exitdungeon\n+      THEN\n+         TestIfLastLivePlayer(yes) ;\n+         IF NOT yes\n+         THEN\n+            Dead(p, Player[0].RoomOfMan)\n+         END\n+      END\n+   END\n+END MoveMan ;\n+\n+\n+PROCEDURE MoveMan1 (n, p: CARDINAL) ;\n+VAR\n+   x, y,\n+   i, j, s,\n+   r,  dir,\n+   tr, z,\n+   Sx, Sy,\n+   DoorNo : CARDINAL ;\n+   hit    : BOOLEAN ;\n+BEGIN\n+   StrengthToMove(n, hit) ;\n+   IF hit\n+   THEN\n+      WITH Player[p] DO\n+         EraseMan(p) ;\n+         dir := Direction ;\n+         tr := RoomOfMan ;\n+         x := Xman ;\n+         y := Yman ;\n+         Sx := ScreenX ;\n+         Sy := ScreenY ;\n+         hit := FALSE ;\n+         s := 1 ;\n+         i := x ;\n+         j := y ;\n+         r := tr ;\n+         WHILE (s<=n) AND (NOT hit) DO\n+            IncPosition(i, j, dir) ;\n+            GetReadAccessToDoor ;\n+            GetDoorOnPoint(r, i, j, DoorNo, hit) ;\n+            IF hit\n+            THEN\n+               IF Rooms[r].Doors[DoorNo].StateOfDoor=Open\n+               THEN\n+                  z := Rooms[r].Doors[DoorNo].LeadsTo ;\n+                  ReleaseReadAccessToDoor ;\n+                  IF z=0\n+                  THEN\n+                     DeathType := exitdungeon\n+                  ELSE\n+                     IncPosition(i, j, dir) ;\n+                     TakenPointInRoom(z, i, j, hit) ;\n+                     IF NOT hit  (* Empty Point In Room *)\n+                     THEN\n+                        INC(s) ;\n+                        x := i ;\n+                        y := j ;\n+                        r := z  (* Ok so changed room *)\n+                     END\n+                  END\n+               ELSE\n+                  ReleaseReadAccessToDoor\n+               END ;\n+            ELSE\n+               ReleaseReadAccessToDoor ;\n+               PointOnWall(r, i, j, hit) ;\n+               IF NOT hit\n+               THEN\n+                  GetReadAccessToTreasure ;\n+                  PointOnTreasure(r, i, j, z, hit) ;\n+                  ReleaseReadAccessToTreasure ;\n+                  IF NOT hit\n+                  THEN\n+                     PointOnOtherPlayer(i, j, z, hit) ;\n+                     IF NOT hit\n+                     THEN\n+                        x := i ;\n+                        y := j ;\n+                        INC(s)\n+                     END\n+                  END\n+               END\n+            END\n+         END ;\n+         IF (x#Xman) OR (y#Yman)\n+         THEN\n+            Xman := x ;\n+            Yman := y ;\n+            ScaleSights(x, y, Sx, Sy, hit) ;\n+            ScreenX := Sx ;\n+            ScreenY := Sy ;\n+            RoomOfMan := r ;\n+            IF r#0\n+            THEN\n+               IF (tr#r) OR hit\n+               THEN\n+                  IF hit\n+                  THEN\n+                     InitScreen(p)\n+                  ELSE\n+                     GetAccessToScreenNo(p) ;\n+                     WriteRoom(p, r) ;\n+                     ReleaseAccessToScreenNo(p)\n+                  END ;\n+                  ClearRoom(tr) ;\n+                  DrawRoom\n+               END ;\n+               DrawMan(p)\n+            END\n+         ELSE\n+            DrawMan(p)\n+         END\n+      END\n+   END\n+END MoveMan1 ;\n+\n+\n+PROCEDURE TakenPointInRoom (room, x, y: CARDINAL ; VAR ok: BOOLEAN) ;\n+VAR\n+   z: CARDINAL ;\n+BEGIN\n+   PointOnWall( room, x, y, ok ) ;\n+   IF NOT ok\n+   THEN\n+      GetReadAccessToDoor ;\n+      GetDoorOnPoint(room, x, y, z, ok) ;\n+      ReleaseReadAccessToDoor ;\n+      IF NOT ok\n+      THEN\n+\n+         (* No need to get Read Access To Player 's since taken care of *)\n+         (* in the called routine.                                      *)\n+\n+         PointOnOtherPlayer(x, y, z, ok) ;\n+         IF NOT ok\n+         THEN\n+            GetReadAccessToTreasure ;\n+            PointOnTreasure(room, x, y, z, ok) ;\n+            ReleaseReadAccessToTreasure\n+         END\n+      END\n+   END\n+END TakenPointInRoom ;\n+\n+\n+(* ScaleSights scales the sights of the ScreenX and ScreenY      *)\n+(* coordinates according to whether the player is off the        *)\n+(* screen or off the boundary. It returns Done if the routine    *)\n+(* has altered Sx, Sy.                                           *)\n+\n+PROCEDURE ScaleSights (x, y: CARDINAL ; VAR Sx, Sy: CARDINAL ;\n+                       VAR Done: BOOLEAN) ;\n+VAR\n+   sx, sy: CARDINAL ;\n+BEGIN\n+   sx := Sx ;\n+   sy := Sy ;\n+   IF Sx+InnerX>x\n+   THEN\n+      Dec(Sx, OffX)\n+   ELSIF Sx+OuterX < x\n+   THEN\n+      Inc(Sx, OffX)\n+   END ;\n+   IF Sy+InnerY>y\n+   THEN\n+      Dec(Sy, OffY)\n+   ELSIF Sy+OuterY<y\n+   THEN\n+      Inc(Sy, OffY)\n+   END ;\n+   Done := (sx#Sx) OR (sy#Sy)\n+END ScaleSights ;\n+\n+\n+PROCEDURE Inc (VAR s: CARDINAL ; c: CARDINAL) ;\n+BEGIN\n+   IF (c DIV 2) + (s DIV 2) < 32768\n+   THEN\n+      INC(s, c)\n+   END\n+END Inc ;\n+\n+\n+PROCEDURE Dec (VAR s: CARDINAL ; c: CARDINAL) ;\n+BEGIN\n+   IF c<=s\n+   THEN\n+      DEC(s, c)\n+   ELSIF s>0\n+   THEN\n+      s := 0\n+   END\n+END Dec ;\n+\n+\n+PROCEDURE Parry ;\n+VAR\n+   p, r, x, y, Pn : CARDINAL ;\n+   hit, SlainP    : BOOLEAN ;\n+BEGIN\n+   SlainP := FALSE ;\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      GetWriteAccessToPlayer ;\n+      StrengthToParry(hit) ;\n+      IF hit\n+      THEN\n+         ReleaseWriteAccessToPlayer ;\n+         GetReadAccessToPlayer ;\n+         x := Xman ;\n+         y := Yman ;\n+         IncPosition(x, y, Direction) ;\n+         PointOnOtherPlayer(x, y, Pn, hit) ;\n+         ReleaseReadAccessToPlayer ;\n+         IF hit\n+         THEN\n+            WITH Player[Pn] DO\n+               GetWriteAccessToPlayer ;\n+\n+               GetAccessToScreenNo(Pn) ;\n+               UpDateWoundsAndFatigue(Pn) ;\n+               ReleaseAccessToScreenNo(Pn) ;\n+\n+               IF MagicSword IN Player[p].TreasureOwn\n+               THEN\n+                  GetAccessToScreenNo(p) ;\n+                  IF Wounds>DammageByMagicParry\n+                  THEN\n+                     DEC(Wounds, DammageByMagicParry) ;\n+                     WriteCommentLine1(p, 'hit') ;\n+                     DelCommentLine2(p) ;\n+                     DelCommentLine3(p)\n+                  ELSE\n+                     r := RoomOfMan ;\n+                     SlainP := TRUE ;\n+                     Wounds := 0 ;\n+                     DeathType := sword ;\n+                     DelCommentLine1(p) ;\n+                     WriteCommentLine2(p, 'Slain') ;\n+                     WriteCommentLine3(p, ManName )\n+                  END ;\n+                  ReleaseAccessToScreenNo(p)\n+               ELSE\n+                  GetAccessToScreenNo(p) ;\n+                  IF Wounds>DammageByParry\n+                  THEN\n+                     DEC( Wounds, DammageByParry ) ;\n+                     WriteCommentLine1(p, 'hit') ;\n+                     DelCommentLine2(p) ;\n+                     DelCommentLine3(p)\n+                  ELSE\n+                     r := RoomOfMan ;\n+                     SlainP := TRUE ;\n+                     Wounds := 0 ;\n+                     DeathType := sword ;\n+                     DelCommentLine1(p) ;\n+                     WriteCommentLine2(p, 'Slain') ;\n+                     WriteCommentLine3(p, ManName ) ;\n+                  END ;\n+                  ReleaseAccessToScreenNo(p)\n+               END ;\n+\n+               GetAccessToScreenNo(Pn) ;\n+               WriteCommentLine1(Pn, 'hit thee') ;\n+               DelCommentLine2(Pn) ;\n+               DelCommentLine3(Pn) ;\n+               WriteWounds( Pn, Wounds ) ;\n+               ReleaseAccessToScreenNo(Pn) ;\n+\n+               ReleaseWriteAccessToPlayer\n+            END\n+         ELSE\n+            GetAccessToScreenNo(p) ;\n+            WriteCommentLine1(p, 'missed') ;\n+            DelCommentLine2(p) ;\n+            DelCommentLine3(p) ;\n+            ReleaseAccessToScreenNo(p)\n+         END\n+      ELSE\n+         ReleaseWriteAccessToPlayer\n+      END\n+   END ;\n+   IF SlainP\n+   THEN\n+      Dead( Pn, r )\n+   END\n+END Parry ;\n+\n+\n+PROCEDURE Attack ;\n+VAR\n+   p, r, x, y, Pn : CARDINAL ;\n+   hit, SlainP    : BOOLEAN ;\n+BEGIN\n+   SlainP := FALSE ;\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      GetWriteAccessToPlayer ;\n+      StrengthToAttack( hit ) ;\n+      IF hit\n+      THEN\n+         ReleaseWriteAccessToPlayer ;\n+         GetReadAccessToPlayer ;\n+         x := Xman ;\n+         y := Yman ;\n+         IncPosition(x, y, Direction) ;\n+         PointOnOtherPlayer(x, y, Pn, hit) ;\n+         ReleaseReadAccessToPlayer ;\n+         IF hit\n+         THEN\n+            WITH Player[Pn] DO\n+               GetWriteAccessToPlayer ;\n+\n+               GetAccessToScreenNo(Pn) ;\n+               UpDateWoundsAndFatigue(Pn) ;\n+               ReleaseAccessToScreenNo(Pn) ;\n+\n+               IF MagicSword IN Player[p].TreasureOwn\n+               THEN\n+                  GetAccessToScreenNo(p) ;\n+                  IF Wounds>DammageByMagicAttack\n+                  THEN\n+                     DEC(Wounds, DammageByMagicAttack) ;\n+                     WriteCommentLine1(p, 'hit') ;\n+                     DelCommentLine2(p) ;\n+                     DelCommentLine3(p)\n+                  ELSE\n+                     r := RoomOfMan ;\n+                     SlainP := TRUE ;\n+                     Wounds := 0 ;\n+                     DeathType := sword ;\n+                     DelCommentLine1(p) ;\n+                     WriteCommentLine2(p, 'Slain') ;\n+                     WriteCommentLine3(p, ManName)\n+                  END ;\n+                  ReleaseAccessToScreenNo( p )\n+               ELSE\n+                  GetAccessToScreenNo( p ) ;\n+                  IF Wounds>DammageByAttack\n+                  THEN\n+                     DEC( Wounds, DammageByAttack ) ;\n+                     WriteCommentLine1(p, 'hit') ;\n+                     DelCommentLine2(p) ;\n+                     DelCommentLine3(p)\n+                  ELSE\n+                     r := RoomOfMan ;\n+                     SlainP := TRUE ;\n+                     Wounds := 0 ;\n+                     DeathType := sword ;\n+                     DelCommentLine1(p) ;\n+                     WriteCommentLine2(p, 'Slain') ;\n+                     WriteCommentLine3(p, ManName)\n+                  END ;\n+                  ReleaseAccessToScreenNo(p)\n+               END ;\n+\n+               GetAccessToScreenNo(Pn) ;\n+\n+               WriteCommentLine1(Pn, 'hit thee') ;\n+               DelCommentLine2(Pn) ;\n+               DelCommentLine3(Pn) ;\n+               WriteWounds(Pn, Wounds) ;\n+               ReleaseAccessToScreenNo(Pn) ;\n+\n+               ReleaseWriteAccessToPlayer\n+            END\n+         ELSE\n+            GetAccessToScreenNo(p) ;\n+            WriteCommentLine1(p, 'missed') ;\n+            DelCommentLine2(p) ;\n+            DelCommentLine3(p) ;\n+            ReleaseAccessToScreenNo(p)\n+         END\n+      ELSE\n+         ReleaseWriteAccessToPlayer\n+      END\n+   END ;\n+   IF SlainP\n+   THEN\n+      Dead( Pn, r )\n+   END\n+END Attack ;\n+\n+\n+PROCEDURE Thrust ;\n+VAR\n+   p, r, x, y, Pn : CARDINAL ;\n+   hit, SlainP    : BOOLEAN ;\n+BEGIN\n+   SlainP := FALSE ;\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      GetWriteAccessToPlayer ;\n+      StrengthToThrust(hit) ;\n+      IF hit\n+      THEN\n+         ReleaseWriteAccessToPlayer ;\n+         GetReadAccessToPlayer ;\n+         x := Xman ;\n+         y := Yman ;\n+         IncPosition(x, y, Direction) ;\n+         PointOnOtherPlayer(x, y, Pn, hit) ;\n+         ReleaseReadAccessToPlayer ;\n+         IF hit\n+         THEN\n+            WITH Player[Pn] DO\n+               GetWriteAccessToPlayer ;\n+\n+               GetAccessToScreenNo(Pn) ;\n+               UpDateWoundsAndFatigue(Pn) ;\n+               ReleaseAccessToScreenNo(Pn) ;\n+\n+               IF MagicSword IN Player[p].TreasureOwn\n+               THEN\n+                  GetAccessToScreenNo(p) ;\n+                  IF Wounds>DammageByMagicThrust\n+                  THEN\n+                     DEC(Wounds, DammageByMagicThrust) ;\n+                     WriteCommentLine1(p, 'hit') ;\n+                     DelCommentLine2(p) ;\n+                     DelCommentLine3(p)\n+                  ELSE\n+                     r := RoomOfMan ;\n+                     SlainP := TRUE ;\n+                     Wounds := 0 ;\n+                     DeathType := sword ;\n+                     DelCommentLine1(p) ;\n+                     WriteCommentLine2(p, 'Slain') ;\n+                     WriteCommentLine3(p, ManName)\n+                  END ;\n+                  ReleaseAccessToScreenNo(p)\n+               ELSE\n+                  GetAccessToScreenNo(p) ;\n+                  IF Wounds>DammageByThrust\n+                  THEN\n+                     DEC(Wounds, DammageByThrust) ;\n+                     WriteCommentLine1(p, 'hit') ;\n+                     DelCommentLine2(p) ;\n+                     DelCommentLine3(p)\n+                  ELSE\n+                     r := RoomOfMan ;\n+                     SlainP := TRUE ;\n+                     Wounds := 0 ;\n+                     DeathType := sword ;\n+                     DelCommentLine1(p) ;\n+                     WriteCommentLine2(p, 'Slain') ;\n+                     WriteCommentLine3(p, ManName)\n+                  END ;\n+                  ReleaseAccessToScreenNo( p )\n+               END ;\n+\n+               GetAccessToScreenNo(Pn) ;\n+\n+               WriteCommentLine1(Pn, 'hit thee') ;\n+               DelCommentLine2(Pn) ;\n+               DelCommentLine3(Pn) ;\n+               WriteWounds( Pn, Wounds ) ;\n+               ReleaseAccessToScreenNo(Pn) ;\n+\n+               ReleaseWriteAccessToPlayer\n+            END\n+         ELSE\n+            GetAccessToScreenNo(p) ;\n+            WriteCommentLine1(p, 'missed') ;\n+            DelCommentLine2(p) ;\n+            DelCommentLine3(p) ;\n+            ReleaseAccessToScreenNo(p)\n+         END\n+      ELSE\n+         ReleaseWriteAccessToPlayer\n+      END\n+   END ;\n+   IF SlainP\n+   THEN\n+      Dead( Pn, r )\n+   END\n+END Thrust ;\n+\n+\n+(* Tests to see whether the point is occupied by another player. *)\n+(* This procedure does NOT use any lock.                         *)\n+\n+PROCEDURE PointOnOtherPlayer (x, y: CARDINAL ;\n+                              VAR Pn: CARDINAL ; VAR Success: BOOLEAN) ;\n+VAR\n+   p: CARDINAL ;\n+BEGIN\n+   Success := FALSE ;\n+   p := PlayerNo() ;\n+   Pn := 0 ;\n+   WHILE (Pn<NextFreePlayer) AND (NOT Success) DO\n+      IF (Pn#p) AND IsPlayerActive(Pn)\n+      THEN\n+         WITH Player[Pn] DO\n+            IF (Xman=x) AND (Yman=y)\n+            THEN\n+               Success := TRUE\n+            ELSE\n+               INC( Pn )\n+            END\n+         END\n+      ELSE\n+         INC( Pn )\n+      END\n+   END\n+END PointOnOtherPlayer ;\n+\n+\n+PROCEDURE OpenDoor ;\n+VAR\n+   Success: BOOLEAN ;\n+BEGIN\n+   GetReadAccessToPlayer ;\n+   GetWriteAccessToDoor ;\n+   ClosedToOpenDoor(Success) ;\n+   GetAccessToScreen ;\n+   IF Success\n+   THEN\n+      DelCommentLine1(PlayerNo())\n+   ELSE\n+      WriteCommentLine1(PlayerNo(), 'thou canst')\n+   END ;\n+   ReleaseAccessToScreen ;\n+   ReleaseWriteAccessToDoor ;\n+   ReleaseReadAccessToPlayer\n+END OpenDoor ;\n+\n+\n+PROCEDURE ExamineDoor ;\n+VAR\n+   Success: BOOLEAN ;\n+BEGIN\n+   GetReadAccessToPlayer ;\n+   GetWriteAccessToDoor ;\n+   SecretToClosedDoor(Success) ;\n+   GetAccessToScreen ;\n+   IF Success\n+   THEN\n+      DelCommentLine1(PlayerNo())\n+   ELSE\n+      WriteCommentLine1(PlayerNo(), 'nothing')\n+   END ;\n+   ReleaseAccessToScreen ;\n+   ReleaseWriteAccessToDoor ;\n+   ReleaseReadAccessToPlayer\n+END ExamineDoor ;\n+\n+\n+PROCEDURE CloseDoor ;\n+VAR\n+   Success: BOOLEAN ;\n+BEGIN\n+   GetReadAccessToPlayer ;\n+   GetWriteAccessToDoor ;\n+   OpenToClosedDoor(Success) ;\n+   GetAccessToScreen ;\n+   IF Success\n+   THEN\n+      DelCommentLine1(PlayerNo())\n+   ELSE\n+      WriteCommentLine1(PlayerNo(), 'thou canst')\n+   END ;\n+   ReleaseAccessToScreen ;\n+   ReleaseWriteAccessToDoor ;\n+   ReleaseReadAccessToPlayer\n+END CloseDoor ;\n+\n+\n+PROCEDURE HideDoor ;\n+VAR\n+   Success: BOOLEAN ;\n+BEGIN\n+   GetReadAccessToPlayer ;\n+   GetWriteAccessToDoor ;\n+   ClosedToSecretDoor(Success) ;\n+   GetAccessToScreen ;\n+   IF Success\n+   THEN\n+      DelCommentLine1(PlayerNo())\n+   ELSE\n+      WriteCommentLine1(PlayerNo(), 'thou canst')\n+   END ;\n+   ReleaseAccessToScreen ;\n+   ReleaseWriteAccessToDoor ;\n+   ReleaseReadAccessToPlayer\n+END HideDoor ;\n+\n+\n+(* Speak Function                                                     *)\n+\n+PROCEDURE Speak ;\n+VAR\n+   a1, a2, a3: ARRAY [0..14] OF CHAR ;\n+   i, r, p   : CARDINAL ;\n+   ch        : CHAR ;\n+BEGIN\n+   p := PlayerNo() ;\n+   r := Player[p].RoomOfMan ;\n+   i := 0 ;\n+   a1[0] := nul ;\n+   a2[0] := nul ;\n+   a3[0] := nul ;\n+   REPEAT\n+      IF ClientRead(ch)\n+      THEN\n+         IF ch=nak\n+         THEN\n+            i := 0\n+         ELSIF (ch=del) OR (ch=bs)\n+         THEN\n+            IF i>0\n+            THEN\n+               DEC( i )\n+            END\n+         ELSIF (ch>=' ') OR (ch=cr)\n+         THEN\n+            IF ch=cr\n+            THEN\n+               ch := nul\n+            END ;\n+            IF i<15\n+            THEN\n+               a1[i] := ch\n+            ELSIF i<30\n+            THEN\n+               a2[i-15] := ch\n+            ELSE\n+               a3[i-30] := ch\n+            END ;\n+            INC( i )\n+         END\n+      ELSE\n+         RETURN\n+      END\n+   UNTIL (ch=nul) OR (i>44) ;\n+   DisplayMessage( a1, a2, a3 ) ;\n+END Speak ;\n+\n+\n+(* Assumes we are configured to write to player, p, *)\n+\n+PROCEDURE Dead (p, room : CARDINAL) ;\n+BEGIN\n+   WITH Player[p] DO\n+      GetWriteAccessToPlayer ;\n+      IF room#0\n+      THEN\n+         GetReadAccessToDoor ;\n+         GetWriteAccessToTreasure ;\n+         ScatterTreasures(p, room) ;\n+         EraseMan(p) ;\n+         ReleaseWriteAccessToTreasure ;\n+         ReleaseReadAccessToDoor\n+      END ;\n+      ReleaseWriteAccessToPlayer\n+   END\n+END Dead ;\n+\n+\n+(* RandomRoom takes the current room and works out a random room.    *)\n+\n+PROCEDURE RandomRoom (CurrentRoom, NoOfRoomsApart: CARDINAL ;\n+                      VAR room: CARDINAL) ;\n+VAR\n+   i: CARDINAL ;\n+BEGIN\n+   (* Warning the method used here may cause problems to a map which *)\n+   (* does not have consecutive rooms.                               *)\n+\n+   RandomNumber( i, ActualNoOfRooms) ;\n+   room := i+1\n+\n+(*\n+   Cutting out this routine for the moment.\n+\n+   room := CurrentRoom ;\n+   WHILE NoOfRoomsApart>0 DO\n+      IF Rooms[CurrentRoom].NoOfDoors=1\n+      THEN\n+         i := 1\n+      ELSE\n+         RandomNumber( i, Rooms[CurrentRoom].NoOfDoors ) ;\n+         INC( i )\n+      END ;\n+      room := Rooms[CurrentRoom].Doors[i].LeadsTo ;\n+      IF room=0\n+      THEN\n+         room := CurrentRoom\n+      ELSE\n+         CurrentRoom := room\n+      END ;\n+      DEC( NoOfRoomsApart )\n+   END\n+*)\n+END RandomRoom ;\n+\n+\n+(* GetRandomPosition finds a free random position within a room *)\n+\n+PROCEDURE PositionInRoom (room: CARDINAL ;\n+                          VAR x, y: CARDINAL ; VAR Success: BOOLEAN) ;\n+VAR\n+   r          : INTEGER ;\n+   maxx, maxy,\n+   x1, y1, doorno,\n+   j, i, d, z,\n+   OldRoom    : CARDINAL ;\n+   OkOld, ok,\n+   OkCurrent  : BOOLEAN ;\n+BEGIN\n+   doorno := 1 ;\n+   Success := FALSE ;\n+   WHILE (doorno<=Rooms[room].NoOfDoors) AND (NOT Success) DO\n+      OldRoom := Rooms[room].Doors[doorno].LeadsTo ;\n+      IF OldRoom#0\n+      THEN\n+         WITH Rooms[room].Doors[doorno].Position DO\n+            x1 := X1 ;\n+            y1 := Y1 ;\n+            i := X2\n+         END ;\n+         IF x1=i\n+         THEN\n+            d := 1\n+         ELSE\n+            d := 0\n+         END ;\n+         i := 1 ;\n+         maxx := 0 ;\n+         maxy := 0 ;\n+         WHILE i<=Rooms[room].NoOfWalls DO\n+            maxx := Max(Rooms[room].Walls[i].X2, maxx) ;\n+            maxy := Max(Rooms[room].Walls[i].Y2, maxy) ;\n+            INC(i)\n+         END ;\n+         OkCurrent := FALSE ;\n+         OkOld := FALSE ;\n+         WHILE NOT OkCurrent DO\n+            d := (d+2) MOD 4 ;\n+            i := x1 ;\n+            j := y1 ;\n+            REPEAT\n+               IncPosition(i, j, d) ;\n+               PointOnWall(room, i, j, OkCurrent) ;\n+               IF NOT OkCurrent\n+               THEN\n+                  GetDoorOnPoint(room, i, j, z, OkCurrent)\n+               END ;\n+               PointOnWall(OldRoom, i, j, OkOld) ;\n+               IF NOT OkOld\n+               THEN\n+                  GetDoorOnPoint(OldRoom, i, j, z, OkOld)\n+               END ;\n+               IF NOT OkCurrent\n+               THEN\n+                  FreeOfPlayersAndTreasure(room, i, j, ok) ;\n+                  IF ok\n+                  THEN\n+                     Success := TRUE ;\n+                     x := i ;\n+                     y := j\n+                  END\n+               END\n+            UNTIL OkCurrent OR OkOld OR\n+                  (ODD(d) AND ((i=0) OR (i>=maxx))) OR\n+                  ((NOT ODD(d)) AND ((j=0) OR (j>=maxy))) ;\n+            IF OkOld\n+            THEN\n+               Success := FALSE\n+            END\n+         END\n+      END ;\n+      INC(doorno)\n+   END ;\n+   IF Success\n+   THEN\n+      r := printf(\"room %d position %d %d\\n\", room, x, y)\n+   END\n+END PositionInRoom ;\n+\n+\n+PROCEDURE FreeOfPlayersAndTreasure (room, x, y: CARDINAL ; VAR Success: BOOLEAN) ;\n+VAR\n+   i : CARDINAL ;\n+BEGIN\n+   Success := TRUE ;\n+   i := 0 ;\n+   WHILE (i<NextFreePlayer) AND Success DO\n+      IF IsPlayerActive(i)\n+      THEN\n+         WITH Player[i] DO\n+            IF room=RoomOfMan\n+            THEN\n+               IF (Xman=x) AND (Yman=y)\n+               THEN\n+                  Success := FALSE\n+               END\n+            END\n+         END\n+      END ;\n+      INC (i)\n+   END ;\n+   IF Success\n+   THEN\n+      i := 1 ;\n+      WHILE (i<=MaxNoOfTreasures) AND Success DO\n+         WITH Treasure[i] DO\n+            IF (Rm=room) AND (kind=onfloor)\n+            THEN\n+               IF (Xpos=x) AND (Ypos=y)\n+               THEN\n+                  Success := FALSE\n+               END\n+            END\n+         END ;\n+         INC (i)\n+      END\n+   END\n+END FreeOfPlayersAndTreasure ;\n+\n+\n+(*\n+   HideTreasure - hides treasure, t, which is assummed to be absent from the\n+                  data structures when this procedure is called.\n+*)\n+\n+PROCEDURE HideTreasure (t: CARDINAL) ;\n+VAR\n+   ok: BOOLEAN ;\n+BEGIN\n+   GetReadAccessToTreasure ;\n+   RespawnTreasure (GetRandomRoom(NoOfRoomsToHidePlayers, ActualNoOfRooms), t, 0) ;\n+   ReleaseReadAccessToTreasure\n+END HideTreasure ;\n+\n+\n+(*\n+   GetRandomRoom - returns a random room.\n+*)\n+\n+PROCEDURE GetRandomRoom (NoOfRoomsToTraverse, TotalRooms: CARDINAL) : CARDINAL ;\n+VAR\n+   x, y, r: CARDINAL ;\n+BEGIN\n+   RandomNumber(x, NoOfRoomsToTraverse) ;\n+   INC(x) ;\n+   RandomNumber(y, TotalRooms) ;\n+   INC(y) ;\n+   RandomRoom(y, x, r) ;\n+   RETURN( r )\n+END GetRandomRoom ;\n+\n+\n+PROCEDURE Positioning ;\n+VAR\n+   Attempt,\n+   i, r, x, y, p: CARDINAL ;\n+   ok           : BOOLEAN ;\n+BEGIN\n+   Attempt := MaxNoOfPlayers ;\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      GetWriteAccessToPlayer ;\n+      GetReadAccessToDoor ;\n+      GetReadAccessToTreasure ;\n+      REPEAT\n+         r := GetRandomRoom(NoOfRoomsToHidePlayers, ActualNoOfRooms) ;\n+         ok := TRUE ;\n+         IF Attempt>0\n+         THEN\n+            FOR i := 0 TO NextFreePlayer-1 DO\n+               IF IsPlayerActive(i) AND (i#p)\n+               THEN\n+                  IF r=Player[i].RoomOfMan\n+                  THEN\n+                     ok := FALSE\n+                  END\n+               END\n+            END ;\n+            DEC(Attempt)\n+         END ;\n+         IF ok\n+         THEN\n+            PositionInRoom(r, x, y, ok)\n+         END\n+      UNTIL ok ;\n+      ScreenX := x-(x MOD Width) ;\n+      ScreenY := y-(y MOD Height) ;\n+      RoomOfMan := r ;\n+      Xman := x ;\n+      Yman := y ;\n+      ScaleSights(Xman, Yman, ScreenX, ScreenY, ok) ;\n+      ReleaseReadAccessToTreasure ;\n+      ReleaseReadAccessToDoor ;\n+      ReleaseWriteAccessToPlayer\n+   END\n+END Positioning ;\n+\n+\n+(* Miscellaneous routines that connect the screen to the main program *)\n+\n+\n+PROCEDURE InitialDisplay ;\n+BEGIN\n+   InitScreen(PlayerNo()) ;\n+   GetReadAccessToPlayer ;\n+   DrawRoom ;\n+   ReleaseReadAccessToPlayer\n+END InitialDisplay ;\n+\n+\n+END AdvUtil.\n+(*\n+ * Local variables:\n+ *  compile-command: \"make\"\n+ * End:\n+ *)"}, {"sha": "fedf0aced7d37f7f2e47a66624774d4362217a4c", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/DrawG.def", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FDrawG.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FDrawG.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FDrawG.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,36 @@\n+DEFINITION MODULE DrawG ;\n+\n+FROM AdvSystem IMPORT PlayerSet ;\n+EXPORT QUALIFIED DrawMan, EraseMan, DrawDoor, DrawTreasure,\n+                 EraseTreasure, DrawArrow, EraseArrow,\n+                 DisplayMessage ;\n+\n+\n+(* All these procedures to draw on the screens - are Global *)\n+(* Ie they will draw to all the screens that are within     *)\n+(* the area of effect.                                      *)\n+\n+\n+PROCEDURE DrawMan (p: CARDINAL) ;\n+\n+PROCEDURE EraseMan (p: CARDINAL) ;\n+\n+\n+(* DrawDoor draws a door on every screen possible ie all that *)\n+(* are in this particular area. Hence the coordinates need    *)\n+(* to be absolute NOT relative!                               *)\n+\n+PROCEDURE DrawDoor (RoomOfDoor, IndexToDoor: CARDINAL) ;\n+\n+PROCEDURE DrawTreasure (room, x, y: CARDINAL) ;\n+\n+PROCEDURE EraseTreasure (room, x, y: CARDINAL) ;\n+\n+PROCEDURE DrawArrow (room, x, y, dir: CARDINAL ; VAR playerscreen: PlayerSet) ;\n+\n+PROCEDURE EraseArrow (x, y: CARDINAL ; playerscreen: PlayerSet; flush: BOOLEAN) ;\n+\n+PROCEDURE DisplayMessage (a1, a2, a3: ARRAY OF CHAR) ;\n+\n+      \n+END DrawG."}, {"sha": "ff85fe364dfacf691ef1269bb073a5d5f023b020", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/DrawG.mod", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FDrawG.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FDrawG.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FDrawG.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,327 @@\n+IMPLEMENTATION MODULE DrawG ;\n+\n+\n+FROM AdvMap IMPORT Rooms, Door, DoorStatus, Line, Adjacent ;\n+FROM ASCII IMPORT lf, bs ;\n+FROM Window IMPORT Clip, ClipPoint ;\n+FROM StdIO IMPORT Write ;\n+IMPORT DrawL ;\n+\n+FROM Screen IMPORT Height, Width, Flush,\n+                   WriteCommentLine1, WriteCommentLine2, WriteCommentLine3 ;\n+\n+FROM AdvSystem IMPORT Player, PlayerNo, PlayerSet,\n+                      NextFreePlayer,\n+                      IsPlayerActive,\n+                      GetReadAccessToPlayer,\n+                      GetWriteAccessToPlayer,\n+                      ReleaseReadAccessToPlayer,\n+                      ReleaseWriteAccessToPlayer,\n+                      GetReadAccessToDoor,\n+                      ReleaseReadAccessToDoor,\n+                      GetReadAccessToTreasure,\n+                      ReleaseReadAccessToTreasure,\n+                      GetAccessToScreenNo,\n+                      ReleaseAccessToScreenNo ;\n+\n+\n+(* All these procedures to draw on the screens - are Global *)\n+(* Ie they will draw to all the screens that are within     *)\n+(* the area of effect.                                      *)\n+\n+\n+(* DrawMan draws the calling player on every screen that    *)\n+(* is within the area of effect. And which has the same     *)\n+(* current room number.                                     *)\n+(* This routine only uses the AccessToScreen Locks.         *)\n+\n+PROCEDURE DrawMan (p: CARDINAL) ;\n+VAR\n+   i,\n+   x, y, Sx, Sy, r,\n+   dir            : CARDINAL ;\n+BEGIN\n+   WITH Player[p] DO\n+      r := RoomOfMan ;\n+      x := Xman ;\n+      y := Yman ;\n+      dir := Direction\n+   END ;\n+\n+   FOR i := 0 TO NextFreePlayer-1 DO\n+      IF IsPlayerActive(i)\n+      THEN\n+         WITH Player[i] DO\n+            IF r=RoomOfMan\n+            THEN\n+               Sy := ScreenY ;\n+               Sx := ScreenX ;\n+               IF (x>=Sx) AND (x<=Sx+Width) AND\n+                  (y>=Sy) AND (y<=Sy+Height)\n+               THEN\n+                  GetAccessToScreenNo(i) ;\n+                  DrawL.DrawMan(p#i, x-Sx, y-Sy, dir) ;\n+                  ReleaseAccessToScreenNo(i)\n+               END\n+            END\n+         END\n+      END\n+   END\n+END DrawMan ;\n+\n+\n+(* EraseMan erases the calling player on every screen that is *)\n+(* currently displaying this player.                          *)\n+\n+PROCEDURE EraseMan (p: CARDINAL) ;\n+VAR\n+   i, r, x, y, Sx, Sy: CARDINAL ;\n+BEGIN\n+   WITH Player[p] DO\n+      r := RoomOfMan ;\n+      x := Xman ;\n+      y := Yman\n+   END ;\n+\n+   FOR i := 0 TO NextFreePlayer-1 DO\n+      IF IsPlayerActive(i)\n+      THEN\n+         WITH Player[i] DO\n+            IF r=RoomOfMan\n+            THEN\n+               Sy := ScreenY ;\n+               Sx := ScreenX ;\n+               IF (x>=Sx) AND (x<=Sx+Width) AND\n+                  (y>=Sy) AND (y<=Sy+Height)\n+               THEN\n+                  GetAccessToScreenNo(i) ;\n+                  DrawL.Erase(x-Sx, y-Sy) ;\n+                  Flush(i) ;\n+                  ReleaseAccessToScreenNo(i)\n+               END\n+            END\n+         END\n+      END\n+   END\n+END EraseMan ;\n+\n+\n+(* DrawDoor draws a door on every screen possible ie all that *)\n+(* are in this particular area. Hence the coordinates need    *)\n+(* to be absolute NOT relative!                               *)\n+(* This procedure uses Locks GetAccessToScreen ONLY!          *)\n+\n+PROCEDURE DrawDoor (RoomOfDoor, IndexToDoor: CARDINAL) ;\n+VAR\n+   p                   : CARDINAL ;\n+   hx, hy,\n+   x, y, NextRoom,\n+   i, j, x1, y1, x2, y2: CARDINAL ;\n+   ok                  : BOOLEAN ;\n+   yt, xt              : CARDINAL ;\n+   ds                  : DoorStatus ;\n+BEGIN\n+   WITH Rooms[RoomOfDoor].Doors[IndexToDoor].Position DO\n+      x1 := X1 ;\n+      x2 := X2 ;\n+      y1 := Y1 ;\n+      y2 := Y2\n+   END ;\n+\n+   WITH Rooms[RoomOfDoor].Doors[IndexToDoor] DO\n+      ds := StateOfDoor ;\n+      NextRoom := LeadsTo\n+   END ;\n+\n+   FOR p := 0 TO NextFreePlayer-1 DO\n+      IF IsPlayerActive(p)\n+      THEN\n+         WITH Player[p] DO\n+            IF (RoomOfDoor=RoomOfMan) OR (RoomOfMan=NextRoom)\n+            THEN\n+               i := x1 ;\n+               j := y1 ;\n+               x := x2 ;\n+               y := y2 ;\n+               Clip(i, j, x, y, ScreenX, ScreenY, ok) ;\n+               IF ok\n+               THEN\n+                  GetAccessToScreenNo(p) ;\n+                  IF i=x\n+                  THEN\n+                     hx := x2 ;\n+                     hy := y2 ;\n+                     ClipPoint(hx, hy, ScreenX, ScreenY, ok) ;\n+                     DrawL.DLine(i, j, x, y, ok, ds)\n+                  ELSE\n+                     hx := x1 ;\n+                     hy := y1 ;\n+                     ClipPoint(hx, hy, ScreenX, ScreenY, ok) ;\n+                     DrawL.DLine(i, j, x, y, ok, ds)\n+                  END ;\n+                  ReleaseAccessToScreenNo(p)\n+               END\n+            END\n+         END\n+      END\n+   END\n+END DrawDoor ;\n+\n+\n+(* This procedure only uses LOCKS GetAccessToScreen *)\n+\n+PROCEDURE DrawTreasure (room, x, y: CARDINAL) ;\n+VAR\n+   p     : CARDINAL ;\n+   Sx, Sy: CARDINAL ;\n+BEGIN\n+   p := 0 ;\n+   WHILE p < NextFreePlayer DO\n+      IF IsPlayerActive(p)\n+      THEN\n+         WITH Player[p] DO\n+            IF room=RoomOfMan\n+            THEN\n+               Sy := ScreenY ;\n+               Sx := ScreenX ;\n+               IF (x>=Sx) AND (x<=Sx+Width) AND\n+                  (y>=Sy) AND (y<=Sy+Height)\n+               THEN\n+                  GetAccessToScreenNo(p) ;\n+                  DrawL.DTreasure(x-Sx, y-Sy) ;\n+                  ReleaseAccessToScreenNo(p)\n+               END\n+            END\n+         END\n+      END ;\n+      INC (p)\n+   END\n+END DrawTreasure ;\n+\n+\n+PROCEDURE EraseTreasure (room, x, y: CARDINAL) ;\n+VAR\n+   p     : CARDINAL ;\n+   Sx, Sy: CARDINAL ;\n+BEGIN\n+   p := 0 ;\n+   WHILE p < NextFreePlayer DO\n+      IF IsPlayerActive(p)\n+      THEN\n+         WITH Player[p] DO\n+            IF room=RoomOfMan\n+            THEN\n+               Sy := ScreenY ;\n+               Sx := ScreenX ;\n+               IF (x>=Sx) AND (x<=Sx+Width) AND\n+                  (y>=Sy) AND (y<=Sy+Height)\n+               THEN\n+                  GetAccessToScreenNo(p) ;\n+                  DrawL.Erase(x-Sx, y-Sy) ;\n+                  Flush(p) ;\n+                  ReleaseAccessToScreenNo(p)\n+               END\n+            END\n+         END\n+      END ;\n+      INC (p)\n+   END\n+END EraseTreasure ;\n+\n+\n+(* This procedure only uses LOCKS GetAccessToScreen *)\n+\n+PROCEDURE DrawArrow (room, x, y, dir: CARDINAL ; VAR playerscreen: PlayerSet) ;\n+VAR\n+   p, Sx, Sy: CARDINAL ;\n+BEGIN\n+   playerscreen := PlayerSet{} ;\n+   p := 0 ;\n+   WHILE p < NextFreePlayer DO\n+      IF IsPlayerActive(p)\n+      THEN\n+         WITH Player[p] DO\n+            IF room=RoomOfMan\n+            THEN\n+               Sy := ScreenY ;\n+               Sx := ScreenX ;\n+               IF (x>=Sx) AND (x<=Sx+Width) AND\n+                  (y>=Sy) AND (y<=Sy+Height)\n+               THEN\n+                  INCL(playerscreen, p) ;\n+                  GetAccessToScreenNo(p) ;\n+                  DrawL.DArrow(x-Sx, y-Sy, dir) ;\n+                  ReleaseAccessToScreenNo(p)\n+               END\n+            END\n+         END\n+      END ;\n+      INC (p)\n+   END\n+END DrawArrow ;\n+\n+\n+PROCEDURE EraseArrow (x, y: CARDINAL ; playerscreen: PlayerSet; flush: BOOLEAN) ;\n+VAR\n+   p, Sx, Sy: CARDINAL ;\n+BEGIN\n+   p := 0 ;\n+   WHILE p < NextFreePlayer DO\n+      IF IsPlayerActive(p)\n+      THEN\n+         WITH Player[p] DO\n+            IF p IN playerscreen\n+            THEN\n+               Sy := ScreenY ;\n+               Sx := ScreenX ;\n+               IF (x>=Sx) AND (x<=Sx+Width) AND\n+                  (y>=Sy) AND (y<=Sy+Height)\n+               THEN\n+                  GetAccessToScreenNo(p) ;\n+                  DrawL.Erase(x-Sx, y-Sy) ;\n+                  IF flush\n+                  THEN\n+                     Flush(p)\n+                  END ;\n+                  ReleaseAccessToScreenNo(p)\n+               END\n+            END\n+         END\n+      END ;\n+      INC (p)\n+   END\n+END EraseArrow ;\n+\n+\n+PROCEDURE DisplayMessage (a1, a2, a3: ARRAY OF CHAR) ;\n+VAR\n+   i, p, r: CARDINAL ;\n+BEGIN\n+   p := PlayerNo() ;\n+   GetReadAccessToPlayer ;\n+   r := Player[p].RoomOfMan ;\n+   FOR i := 0 TO NextFreePlayer-1 DO\n+      IF IsPlayerActive(i)\n+      THEN\n+         WITH Player[i] DO\n+            IF r=RoomOfMan\n+            THEN\n+               GetAccessToScreenNo(i) ;\n+               WriteCommentLine1(i, a1) ;\n+               WriteCommentLine2(i, a2) ;\n+               WriteCommentLine3(i, a3) ;\n+               ReleaseAccessToScreenNo(i)\n+            END\n+         END\n+      END\n+   END ;\n+   ReleaseReadAccessToPlayer\n+END DisplayMessage ;\n+\n+\n+END DrawG.\n+(*\n+ * Local variables:\n+ *  compile-command: \"make\"\n+ * End:\n+ *)"}, {"sha": "48c165ef6461536513bfeefc5ee5ae153475cdb2", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/DrawL.def", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FDrawL.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FDrawL.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FDrawL.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,23 @@\n+DEFINITION MODULE DrawL ;\n+\n+FROM AdvMap IMPORT DoorStatus ;\n+EXPORT QUALIFIED DrawRoom, ClearRoom, DrawAllPlayers, EraseAllPlayers,\n+                 StrPoint, DTreasure, Erase, DrawMan, DLine, DArrow ;\n+\n+\n+PROCEDURE DrawRoom ;\n+PROCEDURE ClearRoom (r: CARDINAL) ;\n+PROCEDURE DrawAllPlayers ;\n+PROCEDURE EraseAllPlayers ;\n+\n+(* and some low level string routines *)\n+\n+PROCEDURE StrPoint (a: ARRAY OF CHAR; x, y: CARDINAL) ;\n+PROCEDURE DTreasure (x, y: CARDINAL) ;\n+PROCEDURE Erase (x, y: CARDINAL) ;\n+PROCEDURE DrawMan (other: BOOLEAN; x, y, dir: CARDINAL) ;\n+PROCEDURE DLine (x1, y1, x2, y2: CARDINAL; hinge: BOOLEAN; ds: DoorStatus) ;\n+PROCEDURE DArrow (x, y, dir: CARDINAL) ;\n+\n+\n+END DrawL."}, {"sha": "e6753c9ba18404084171ad9fddecf582334cb5f1", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/DrawL.mod", "status": "added", "additions": 422, "deletions": 0, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FDrawL.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FDrawL.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FDrawL.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,422 @@\n+IMPLEMENTATION MODULE DrawL ;\n+\n+\n+FROM ASCII IMPORT lf, bs ;\n+FROM Window IMPORT Clip, ClipPoint ;\n+FROM StrIO IMPORT WriteString, WriteLn ;\n+FROM NumberIO IMPORT WriteCard ;\n+FROM StdIO IMPORT Write ;\n+FROM Debug IMPORT Halt ;\n+FROM Assertion IMPORT Assert ;\n+\n+FROM AdvMap IMPORT Rooms, DoorStatus, Line, Room, Door, Treasure ;\n+\n+FROM AdvMath IMPORT MaxNoOfTreasures ;\n+\n+FROM AdvSystem IMPORT Player, PlayerNo,\n+                      IsPlayerActive,\n+                      NextFreePlayer,\n+                      GetAccessToScreen,\n+                      ReleaseAccessToScreen,\n+                      GetAccessToScreenNo,\n+                      ReleaseAccessToScreenNo,\n+                      GetWriteAccessToPlayer,\n+                      ReleaseWriteAccessToPlayer,\n+                      GetReadAccessToPlayer,\n+                      ReleaseReadAccessToPlayer,\n+                      GetReadAccessToDoor,\n+                      ReleaseReadAccessToDoor,\n+                      GetReadAccessToTreasure,\n+                      ReleaseReadAccessToTreasure ;\n+\n+\n+(* Draws the current Room that the callers player is in. It also draws *)\n+(* all treasures, doors and players associated with this room. This    *)\n+(* procedure DOES get access to treasure locks and door locks but NO   *)\n+(* player lock is used.                                                *)\n+(* This procedure does NOT draw SECRET doors as might give them away!  *)\n+(* It is assumed that walls cover ALL doors.                           *)\n+\n+PROCEDURE DrawRoom ;\n+VAR\n+   ok            : BOOLEAN ;\n+   hx, hy,\n+   x1, y1, x2, y2,\n+   p, t, r, i,\n+   Sx, Sy        : CARDINAL ;\n+   ds            : DoorStatus ;\n+BEGIN\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+\n+      r := RoomOfMan ;\n+      Sx := ScreenX ;\n+      Sy := ScreenY ;\n+      t := Rooms[r].NoOfWalls ;\n+      FOR i := 1 TO t DO\n+         WITH Rooms[r].Walls[i] DO\n+            x1 := X1 ;\n+            y1 := Y1 ;\n+            x2 := X2 ;\n+            y2 := Y2\n+         END ;\n+         Clip( x1, y1, x2, y2, Sx, Sy, ok ) ;\n+\n+         IF ok\n+         THEN\n+            GetAccessToScreen ;\n+            WLine(x1, y1, x2, y2) ;\n+            ReleaseAccessToScreen\n+         END\n+      END ;\n+\n+      GetReadAccessToDoor ;\n+      t := Rooms[r].NoOfDoors ;\n+      FOR i := 1 TO t DO\n+         WITH Rooms[r].Doors[i] DO\n+            x1 := Position.X1 ;\n+            y1 := Position.Y1 ;\n+            x2 := Position.X2 ;\n+            y2 := Position.Y2 ;\n+            ds := StateOfDoor ;\n+            IF ds#Secret\n+            THEN\n+               Clip( x1, y1, x2, y2, Sx, Sy, ok ) ;\n+               IF ok\n+               THEN\n+                  GetAccessToScreen ;\n+                  IF Position.X1=Position.X2\n+                  THEN\n+                     hx := Position.X2 ;\n+                     hy := Position.Y2 ;\n+                     Assert((ScreenX=Sx) AND (ScreenY=Sy)) ;\n+                     ClipPoint(hx, hy, ScreenX, ScreenY, ok) ;\n+                     DLine(x1, y1, x2, y2, ok, ds)\n+                  ELSE\n+                     hx := Position.X1 ;\n+                     hy := Position.Y1 ;\n+                     Assert((ScreenX=Sx) AND (ScreenY=Sy)) ;\n+                     ClipPoint(hx, hy, ScreenX, ScreenY, ok) ;\n+                     DLine(x1, y1, x2, y2, ok, ds)\n+                  END ;\n+                  ReleaseAccessToScreen\n+               END\n+            END\n+         END\n+      END ;\n+      ReleaseReadAccessToDoor ;\n+\n+      GetReadAccessToTreasure ;\n+      FOR i := 1 TO MaxNoOfTreasures DO\n+         WITH Rooms[r] DO\n+            IF i IN Treasures\n+            THEN\n+               x1 := Treasure[i].Xpos ;\n+               y1 := Treasure[i].Ypos ;\n+               ClipPoint(x1, y1, ScreenX, ScreenY, ok) ;\n+               IF ok\n+               THEN\n+                  GetAccessToScreen ;\n+                  DTreasure(x1, y1) ;\n+                  ReleaseAccessToScreen\n+               END\n+            END\n+         END\n+      END ;\n+      ReleaseReadAccessToTreasure ;\n+   END ;\n+\n+   (* This called routine must now draw the other players as well *)\n+   (* as drawing the current man.                                 *)\n+   (* Assumes that this player has been updated in Data Structure *)\n+   (* but has not yet been displayed on the screen.               *)\n+\n+   DrawAllPlayers ;\n+\n+END DrawRoom ;\n+\n+\n+(* Draw all players uses no player lock.                        *)\n+\n+PROCEDURE DrawAllPlayers ;\n+VAR\n+   pn,\n+   Sx, Sy, dir, p: CARDINAL ;\n+   x, y, r       : CARDINAL ;\n+   ok            : BOOLEAN ;\n+   ch            : CHAR ;\n+BEGIN\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      Sx := ScreenX ;\n+      Sy := ScreenY ;\n+      r := RoomOfMan ;\n+      dir := Direction ;\n+      x := Xman-Sx ;\n+      y := Yman-Sy ;\n+      GetAccessToScreenNo(p) ;\n+      DrawMan(FALSE, x, y, dir) ;\n+      ReleaseAccessToScreenNo(p)\n+   END ;\n+\n+   (* Now write all the other Players on the screen *)\n+\n+   FOR pn := 0 TO NextFreePlayer-1 DO\n+      IF (pn#p) AND IsPlayerActive(pn)\n+      THEN\n+         WITH Player[pn] DO\n+            IF r=RoomOfMan\n+            THEN\n+               x := Xman ;\n+               y := Yman ;\n+               dir := Direction ;\n+               ClipPoint(x, y, Sx, Sy, ok) ;\n+               IF ok\n+               THEN\n+                  GetAccessToScreenNo( p ) ;\n+                  DrawMan(TRUE, x, y, dir) ;\n+                  ReleaseAccessToScreenNo( p )\n+               END\n+            END\n+         END\n+      END\n+   END\n+END DrawAllPlayers ;\n+\n+\n+(* This procedure uses no player lock.                        *)\n+\n+PROCEDURE EraseAllPlayers ;\n+VAR\n+   pn,\n+   Sx, Sy, p: CARDINAL ;\n+   x, y, r  : CARDINAL ;\n+   ok       : BOOLEAN ;\n+BEGIN\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      Sx := ScreenX ;\n+      Sy := ScreenY ;\n+      r := RoomOfMan ;\n+      x := Xman-Sx ;\n+      y := Yman-Sy ;\n+      GetAccessToScreenNo(p) ;\n+      Erase(x, y) ;\n+      ReleaseAccessToScreenNo(p)\n+   END ;\n+\n+   (* Now write all the other Players on the screen *)\n+\n+   FOR pn := 0 TO NextFreePlayer-1 DO\n+      IF (pn#p) AND IsPlayerActive(pn)\n+      THEN\n+         WITH Player[pn] DO\n+            IF r=RoomOfMan\n+            THEN\n+               x := Xman ;\n+               y := Yman ;\n+               ClipPoint(x, y, Sx, Sy, ok) ;\n+               IF ok\n+               THEN\n+                  GetAccessToScreenNo(p) ;\n+                  Erase(x, y) ;\n+                  ReleaseAccessToScreenNo(p)\n+               END\n+            END\n+         END\n+      END\n+   END\n+END EraseAllPlayers ;\n+\n+\n+(* Clears the Room specified of all treasures and all OTHER players. *)\n+(* It uses NO lock on any Player. But uses Treasure Lock.            *)\n+\n+PROCEDURE ClearRoom (r: CARDINAL) ;\n+VAR\n+   p, Sx, Sy,\n+   x, y, pn,\n+   x1, y1, i: CARDINAL ;\n+   ok       : BOOLEAN ;\n+BEGIN\n+   p := PlayerNo() ;\n+   WITH Player[p] DO\n+      Sx := ScreenX ;\n+      Sy := ScreenY ;\n+      GetReadAccessToTreasure ;\n+      FOR i := 1 TO MaxNoOfTreasures DO\n+         WITH Rooms[r] DO\n+            IF i IN Treasures\n+            THEN\n+               x1 := Treasure[i].Xpos ;\n+               y1 := Treasure[i].Ypos ;\n+               ClipPoint(x1, y1, Sx, Sy, ok) ;\n+               IF ok\n+               THEN\n+                  GetAccessToScreenNo(p) ;\n+                  Erase(x1, y1) ;\n+                  ReleaseAccessToScreenNo(p)\n+               END\n+            END\n+         END\n+      END ;\n+      ReleaseReadAccessToTreasure\n+   END ;\n+\n+   (* Now erase all the other Players on the screen *)\n+\n+   FOR pn := 0 TO NextFreePlayer-1 DO\n+      IF p#pn\n+      THEN\n+         WITH Player[pn] DO\n+            IF r=RoomOfMan\n+            THEN\n+               x := Xman ;\n+               y := Yman ;\n+               ClipPoint(x, y, Sx, Sy, ok) ;\n+               IF ok\n+               THEN\n+                  GetAccessToScreenNo(p) ;\n+                  Erase(x, y) ;\n+                  ReleaseAccessToScreenNo(p)\n+               END\n+            END\n+         END\n+      END\n+   END\n+END ClearRoom ;\n+\n+\n+PROCEDURE StrLine (a: ARRAY OF CHAR; x1, y1, x2, y2: CARDINAL) ;\n+BEGIN\n+   WriteString(a) ; Write(' ') ;\n+   WriteCard(x1, 0) ; Write(' ') ;\n+   WriteCard(y1, 0) ; Write(' ') ;\n+   WriteCard(x2, 0) ; Write(' ') ;\n+   WriteCard(y2, 0) ; WriteLn\n+END StrLine ;\n+\n+\n+PROCEDURE WLine (x1, y1, x2, y2: CARDINAL) ;\n+BEGIN\n+   IF y1=y2\n+   THEN\n+      StrLine('hwall', x1, y1, x2, y2)\n+   ELSE\n+      Assert(x1=x2) ;\n+      StrLine('vwall', x1, y1, x2, y2)\n+   END\n+END WLine ;\n+\n+\n+PROCEDURE DLine (x1, y1, x2, y2: CARDINAL; hinge: BOOLEAN; ds: DoorStatus) ;\n+VAR\n+   x, ys: CARDINAL ;\n+BEGIN\n+   IF y1=y2\n+   THEN\n+      CASE ds OF\n+\n+      Closed: IF hinge\n+              THEN\n+                 WriteString('hhinge ') ; WriteCard(x1, 0) ; Write(' ') ; WriteCard(y1, 0) ; WriteLn ;\n+                 INC(x1)\n+              END ;\n+              IF x1<=x2\n+              THEN\n+                 StrLine('hdoor', x1, y1, x2, y2)\n+              END |\n+      Open  : StrLine('eL', x1, y1, x2, y2) |\n+      Secret: WLine(x1, y1, x2, y2)\n+\n+      END\n+   ELSE\n+      CASE ds OF\n+\n+      Closed: IF hinge\n+              THEN\n+                 WriteString('vhinge ') ; WriteCard(x1, 0) ; Write(' ') ; WriteCard(y2, 0) ; WriteLn ;\n+                 DEC(y2)\n+              END ;\n+              IF y1<=y2\n+              THEN\n+                 StrLine('vdoor', x1, y1, x2, y2)\n+              END |\n+      Open  : StrLine('eL', x1, y1, x2, y2) |\n+      Secret: WLine(x1, y1, x2, y2)\n+\n+      END\n+   END\n+END DLine ;\n+\n+\n+PROCEDURE StrPoint (a: ARRAY OF CHAR; x, y: CARDINAL) ;\n+BEGIN\n+   WriteString(a) ; Write(' ') ;\n+   WriteCard(x, 0) ; Write(' ') ;\n+   WriteCard(y, 0) ; WriteLn\n+END StrPoint ;\n+\n+\n+PROCEDURE DTreasure (x, y: CARDINAL) ;\n+BEGIN\n+   StrPoint('treasure', x, y)\n+END DTreasure ;\n+\n+\n+PROCEDURE Erase (x, y: CARDINAL) ;\n+BEGIN\n+   StrPoint('eL', x, y)\n+END Erase ;\n+\n+\n+PROCEDURE DrawMan (other: BOOLEAN; x, y, dir: CARDINAL) ;\n+BEGIN\n+   IF other\n+   THEN\n+      CASE dir OF\n+\n+      0:  StrPoint('Nman', x, y) |\n+      1:  StrPoint('Wman', x, y) |\n+      2:  StrPoint('Sman', x, y) |\n+      3:  StrPoint('Eman', x, y)\n+\n+      ELSE\n+         Halt(__FILE__, __LINE__, __FUNCTION__, 'unexpected direction')\n+      END\n+   ELSE\n+      CASE dir OF\n+\n+      0:  StrPoint('nman', x, y) |\n+      1:  StrPoint('wman', x, y) |\n+      2:  StrPoint('sman', x, y) |\n+      3:  StrPoint('eman', x, y)\n+\n+      ELSE\n+         Halt(__FILE__, __LINE__, __FUNCTION__, 'unexpected direction')\n+      END\n+   END\n+END DrawMan ;\n+\n+\n+PROCEDURE DArrow (x, y, dir: CARDINAL) ;\n+BEGIN\n+   CASE dir OF\n+\n+   0:  StrPoint('nar', x, y) |\n+   1:  StrPoint('war', x, y) |\n+   2:  StrPoint('sar', x, y) |\n+   3:  StrPoint('ear', x, y)\n+\n+   ELSE\n+      Halt(__FILE__, __LINE__, __FUNCTION__, 'unexpected direction')\n+   END\n+END DArrow ;\n+\n+\n+END DrawL.\n+(*\n+ * Local variables:\n+ *  compile-command: \"make\"\n+ * End:\n+ *)"}, {"sha": "29b5e79e78401765adb477d61d6db869d75496ba", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/Dungeon.mod", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FDungeon.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FDungeon.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FDungeon.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,34 @@\n+MODULE Dungeon ;\n+(* *)\n+\n+FROM AdvIntroduction IMPORT StartGame ;\n+FROM SArgs IMPORT GetArg ;\n+FROM AdvParse IMPORT ParseMap ;\n+FROM DynamicStrings IMPORT String, string ;\n+FROM libc IMPORT printf, exit ;\n+FROM Screen IMPORT AssignMapName ;\n+\n+\n+VAR\n+   s: String ;\n+   r: INTEGER ;\n+BEGIN\n+   IF GetArg(s, 1)\n+   THEN\n+      r := ParseMap(string(s)) ;\n+      IF r=0\n+      THEN\n+         AssignMapName(s) ;\n+         StartGame\n+      ELSE\n+         exit(r)\n+      END\n+   ELSE\n+      r := printf(\"usage: dungeon mapfile\\n\")\n+   END\n+END Dungeon.\n+(*\n+ * Local variables:\n+ *  compile-command: \"make\"\n+ * End:\n+ *)"}, {"sha": "6829b1506b677ecd971bf9d87cabf3e1a18edb81", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/Lock.def", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FLock.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FLock.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FLock.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,27 @@\n+DEFINITION MODULE Lock ;\n+\n+(*\n+   Author     : Gaius Mulley\n+   Title      : Lock\n+   Date       : 12/2/86\n+   Version    : 1.0\n+   Last Edit  : 22/7/86\n+   Description: Lock - Implements a Read / Write Lock\n+*)\n+\n+EXPORT QUALIFIED LOCK,\n+                 GetReadAccess, ReleaseReadAccess,\n+                 GetWriteAccess, ReleaseWriteAccess,\n+                 InitLock ;\n+\n+TYPE\n+   LOCK ;\n+\n+PROCEDURE GetReadAccess (l: LOCK) ;\n+PROCEDURE ReleaseReadAccess (l: LOCK) ;\n+PROCEDURE GetWriteAccess (l: LOCK) ;\n+PROCEDURE ReleaseWriteAccess (l: LOCK) ;\n+PROCEDURE InitLock (Name: ARRAY OF CHAR) : LOCK ;\n+\n+\n+END Lock."}, {"sha": "3f7726a01590538bd14777057e4318c5d95f5d1f", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/Lock.mod", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FLock.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FLock.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FLock.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,75 @@\n+IMPLEMENTATION MODULE Lock ;\n+\n+\n+FROM Storage IMPORT ALLOCATE, DEALLOCATE ;\n+FROM Executive IMPORT Wait, Signal, InitSemaphore,\n+                      SEMAPHORE ;\n+\n+\n+TYPE\n+   LOCK = POINTER TO RECORD\n+                        Mutex     : SEMAPHORE ;\n+                        ReadCount : CARDINAL ;\n+                        Wrt       : SEMAPHORE ;\n+                     END ;\n+\n+\n+PROCEDURE InitLock (Name: ARRAY OF CHAR) : LOCK ;\n+VAR\n+   l: LOCK ;\n+BEGIN\n+   NEW( l ) ;\n+   WITH l^ DO\n+      Mutex := InitSemaphore(1, Name) ;\n+      Wrt   := InitSemaphore(1, Name) ;\n+      ReadCount := 0\n+   END ;\n+   RETURN( l )\n+END InitLock ;\n+\n+\n+PROCEDURE GetReadAccess (l: LOCK) ;\n+BEGIN\n+   WITH l^ DO\n+      Wait( Mutex ) ;\n+      INC( ReadCount ) ;\n+      IF ReadCount=1\n+      THEN\n+         Wait( Wrt )\n+      END ;\n+      Signal( Mutex )\n+   END\n+END GetReadAccess ;\n+\n+\n+PROCEDURE ReleaseReadAccess (l: LOCK) ;\n+BEGIN\n+   WITH l^ DO\n+      Wait( Mutex ) ;\n+      DEC( ReadCount ) ;\n+      IF ReadCount=0\n+      THEN\n+         Signal( Wrt )\n+      END ;\n+      Signal( Mutex )\n+   END\n+END ReleaseReadAccess ;\n+\n+\n+PROCEDURE GetWriteAccess (l: LOCK) ;\n+BEGIN\n+   WITH l^ DO\n+      Wait( Wrt )\n+   END\n+END GetWriteAccess ;\n+\n+\n+PROCEDURE ReleaseWriteAccess (l: LOCK) ;\n+BEGIN\n+   WITH l^ DO\n+      Signal( Wrt )\n+   END\n+END ReleaseWriteAccess ;\n+\n+\n+END Lock."}, {"sha": "cf5b023b2021db17906bcc1bbdaf9666785ae6d3", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/ProcArgs.def", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FProcArgs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FProcArgs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FProcArgs.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,15 @@\n+DEFINITION MODULE ProcArgs ;\n+\n+FROM SYSTEM IMPORT ADDRESS ;\n+EXPORT QUALIFIED ProcessArgs,\n+                 InitArgs, SetArgs, CollectArgs, KillArgs ;\n+\n+TYPE\n+   ProcessArgs ;\n+\n+PROCEDURE InitArgs () : ProcessArgs ;\n+PROCEDURE SetArgs (p: ProcessArgs; a: ADDRESS) : ADDRESS ;\n+PROCEDURE CollectArgs (p: ProcessArgs) : ADDRESS ;\n+PROCEDURE KillArgs (p: ProcessArgs) : ProcessArgs ;\n+\n+END ProcArgs."}, {"sha": "ceae24145481a6e0a0fce51beb5acb9cb03fc0cc", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/ProcArgs.mod", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FProcArgs.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FProcArgs.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FProcArgs.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,58 @@\n+IMPLEMENTATION MODULE ProcArgs ;\n+\n+FROM Storage IMPORT ALLOCATE, DEALLOCATE ;\n+FROM Executive IMPORT SEMAPHORE, InitSemaphore, Wait, Signal ;\n+\n+TYPE\n+   ProcessArgs = POINTER TO RECORD\n+                               argPtr: ADDRESS ;\n+                               taken,\n+                               given : SEMAPHORE ;\n+                            END ;\n+\n+PROCEDURE InitArgs () : ProcessArgs ;\n+VAR\n+   p: ProcessArgs ;\n+BEGIN\n+   NEW(p) ;\n+   WITH p^ DO\n+      taken := InitSemaphore(1, 'ProcArgs') ;\n+      given := InitSemaphore(0, 'ProcArgs') ;\n+      argPtr := NIL\n+   END ;\n+   RETURN( p )\n+END InitArgs ;\n+\n+\n+PROCEDURE SetArgs (p: ProcessArgs; a: ADDRESS) : ADDRESS ;\n+BEGIN\n+   WITH p^ DO\n+      Wait(taken) ;\n+      argPtr := a ;\n+      Signal(given)\n+   END ;\n+   RETURN( NIL )\n+END SetArgs ;\n+\n+\n+PROCEDURE CollectArgs (p: ProcessArgs) : ADDRESS ;\n+VAR\n+   a: ADDRESS ;\n+BEGIN\n+   WITH p^ DO\n+      Wait(given) ;\n+      a := argPtr ;\n+      Signal(taken)\n+   END ;\n+   RETURN( a )\n+END CollectArgs ;\n+\n+\n+PROCEDURE KillArgs (p: ProcessArgs) : ProcessArgs ;\n+BEGIN\n+   DISPOSE(p) ;\n+   RETURN( NIL )\n+END KillArgs ;\n+\n+\n+END ProcArgs."}, {"sha": "91d2d38d9fba9f31c193c49ae6ac07250d3ab95c", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/Screen.def", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FScreen.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FScreen.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FScreen.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,55 @@\n+DEFINITION MODULE Screen ;\n+\n+FROM DynamicStrings IMPORT String ;\n+EXPORT QUALIFIED ClearScreen, WriteString, PromptString,\n+                 InitScreen, WriteName, WriteFloor, WriteRoom,\n+                 WriteWounds, WriteFatigue, WriteMagicArrows,\n+                 WriteArrows, WriteTime, WriteCommand, WriteWeight,\n+                 WriteCommentLine1, WriteCommentLine2, WriteCommentLine3,\n+                 DelCommentLine1, DelCommentLine2, DelCommentLine3,\n+                 Pause, AssignMapName, Quit, Flush,\n+                 Width, Height,\n+                 InnerX, OuterX, InnerY, OuterY, OffX, OffY ;\n+\n+\n+CONST\n+   Width = 29 ;   (* 0..29  Horizontal Width                *)\n+   Height= 31 ;   (* 0..31  Vertical   Height               *)\n+\n+   InnerX= 5 ;               (* when do we adjust screen    *)\n+   OuterX= Width-InnerX ;\n+   InnerY= 5 ;\n+   OuterY= Height-InnerY ;\n+\n+   OffX  = OuterX-InnerX ;   (* To redraw screen +- Off     *)\n+   OffY  = OuterY-InnerY ;\n+\n+\n+PROCEDURE ClearScreen (p: CARDINAL) ;\n+PROCEDURE WriteString (p: CARDINAL; a: ARRAY OF CHAR) ;\n+PROCEDURE PromptString (p: CARDINAL; a: ARRAY OF CHAR) ;\n+\n+PROCEDURE InitScreen (p: CARDINAL) ;\n+PROCEDURE WriteName (p: CARDINAL; a: ARRAY OF CHAR) ;\n+PROCEDURE WriteFloor (p: CARDINAL) ;\n+PROCEDURE WriteRoom (p: CARDINAL; x: CARDINAL) ;\n+PROCEDURE WriteWeight (p: CARDINAL; x: CARDINAL) ;\n+PROCEDURE WriteWounds (p: CARDINAL; x: CARDINAL) ;\n+PROCEDURE WriteFatigue (p: CARDINAL; x: CARDINAL) ;\n+PROCEDURE WriteMagicArrows (p: CARDINAL; x: CARDINAL) ;\n+PROCEDURE WriteArrows (p: CARDINAL; x: CARDINAL) ;\n+PROCEDURE WriteTime (p: CARDINAL) ;\n+PROCEDURE WriteCommand (p: CARDINAL; ch: CHAR) ;\n+PROCEDURE WriteCommentLine1 (p: CARDINAL; a: ARRAY OF CHAR) ;\n+PROCEDURE WriteCommentLine2 (p: CARDINAL; a: ARRAY OF CHAR) ;\n+PROCEDURE WriteCommentLine3 (p: CARDINAL; a: ARRAY OF CHAR) ;\n+PROCEDURE DelCommentLine1 (p: CARDINAL) ;\n+PROCEDURE DelCommentLine2 (p: CARDINAL) ;\n+PROCEDURE DelCommentLine3 (p: CARDINAL) ;\n+PROCEDURE Pause (p: CARDINAL) ;\n+PROCEDURE AssignMapName (s: String) ;\n+PROCEDURE Quit (p: CARDINAL) ;\n+PROCEDURE Flush (p: CARDINAL) ;\n+\n+\n+END Screen."}, {"sha": "098867ef7ef151599363c5df12a8e78a2932aeb3", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/Screen.mod", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FScreen.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FScreen.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FScreen.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,303 @@\n+IMPLEMENTATION MODULE Screen ;\n+\n+\n+FROM ASCII IMPORT nul ;\n+FROM StrLib IMPORT StrLen ;\n+FROM TimerHandler IMPORT GetTicks, TicksPerSecond ;\n+\n+FROM AdvSystem IMPORT Player, PlayerNo, ClientRead,\n+                      GetAccessToScreenNo,\n+                      ReleaseAccessToScreenNo, AssignOutputTo ;\n+\n+FROM AdvMap IMPORT DoorStatus, FileName, MaxLengthOfFileName ;\n+FROM DynamicStrings IMPORT CopyOut ;\n+\n+FROM StdIO IMPORT Write ;\n+IMPORT NumberIO ;\n+IMPORT StrIO ;\n+\n+\n+VAR\n+   mapname: ARRAY [0..12] OF CHAR ;\n+\n+\n+PROCEDURE AssignMapName (s: String) ;\n+BEGIN\n+   CopyOut(mapname, s)\n+END AssignMapName ;\n+\n+\n+PROCEDURE WriteCommand (p: CARDINAL; ch: CHAR) ;\n+BEGIN\n+   GetAccessToScreenNo(p) ;\n+   StrIO.WriteString('dCMD ') ; Write(ch) ;\n+   Write(' ') ;\n+   CASE ch OF\n+\n+   'l'      : StrIO.WriteString( 'Left         ') |\n+   'r'      : StrIO.WriteString( 'Right        ') |\n+   'v'      : StrIO.WriteString( 'Vault Turn   ') |\n+   '0'..'9' : StrIO.WriteString( 'Forward ') ; Write(ch) |\n+   't'      : StrIO.WriteString( 'Thrust       ') |\n+   'a'      : StrIO.WriteString( 'Attack       ') |\n+   'p'      : StrIO.WriteString( 'Parry        ') |\n+   'o'      : StrIO.WriteString( 'Open Door    ') |\n+   'c'      : StrIO.WriteString( 'Close Door   ') |\n+   'e'      : StrIO.WriteString( 'Examine Door ') |\n+   'f'      : StrIO.WriteString( 'Fire Arrow   ') |\n+   'm'      : StrIO.WriteString( 'Magic Arrow  ') |\n+   'g'      : StrIO.WriteString( 'Get Treasure ') |\n+   'd'      : StrIO.WriteString( 'Drop Treasure') |\n+   'u'      : StrIO.WriteString( 'Use Treasure ') |\n+   's'      : StrIO.WriteString( 'Speak        ') |\n+   'w'      : StrIO.WriteString( 'Watch sayeth ') |\n+   '|'      : StrIO.WriteString( 'Exit Dungeon ')\n+\n+   ELSE       StrIO.WriteString( 'No Command   ') \n+   END ;\n+   StrIO.WriteLn ;\n+   ReleaseAccessToScreenNo(p)\n+END WriteCommand ;\n+\n+\n+(*\n+   Sync - \n+*)\n+\n+PROCEDURE Sync (p: CARDINAL) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('sync') ; StrIO.WriteLn\n+END Sync ;\n+\n+\n+(*\n+   Flush - \n+*)\n+\n+PROCEDURE Flush (p: CARDINAL) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('fl') ; StrIO.WriteLn\n+END Flush ;\n+\n+\n+(*\n+   ClearScreen - \n+*)\n+\n+PROCEDURE ClearScreen (p: CARDINAL) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('clear') ; StrIO.WriteLn\n+END ClearScreen ;\n+\n+PROCEDURE WriteName (p: CARDINAL; n: ARRAY OF CHAR) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('dN ') ; StrIO.WriteString(n) ; StrIO.WriteLn\n+END WriteName ;\n+\n+PROCEDURE WriteRoom (p: CARDINAL; r: CARDINAL) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('dR ') ; NumberIO.WriteCard(r, 0) ; StrIO.WriteLn\n+END WriteRoom ;\n+\n+PROCEDURE WriteWounds (p: CARDINAL; w: CARDINAL) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('dW ') ; NumberIO.WriteCard(w, 0) ; StrIO.WriteLn\n+END WriteWounds ;\n+\n+PROCEDURE WriteFatigue (p: CARDINAL; f: CARDINAL) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('dF ') ; NumberIO.WriteCard(f, 0) ; StrIO.WriteLn\n+END WriteFatigue ;\n+\n+PROCEDURE WriteMagicArrows (p: CARDINAL; m: CARDINAL) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('dM ') ; NumberIO.WriteCard(m, 0) ; StrIO.WriteLn\n+END WriteMagicArrows ;\n+\n+PROCEDURE WriteArrows (p: CARDINAL; a: CARDINAL) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('dA ') ; NumberIO.WriteCard(a, 0) ; StrIO.WriteLn\n+END WriteArrows ;\n+\n+PROCEDURE WriteWeight (p: CARDINAL; w: CARDINAL) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('dw ') ; NumberIO.WriteCard(w, 0) ; StrIO.WriteLn\n+END WriteWeight ;\n+\n+PROCEDURE WriteTime (p: CARDINAL) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('dT ') ;\n+   NumberIO.WriteCard((GetTicks() DIV TicksPerSecond) DIV 60, 0) ;\n+   Write(':') ;\n+   NumberIO.WriteCard((GetTicks() DIV TicksPerSecond) MOD 60, 0) ;\n+   StrIO.WriteLn\n+END WriteTime ;\n+\n+PROCEDURE WriteFloor (p: CARDINAL) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('dMap ') ; StrIO.WriteString('mapname') ; StrIO.WriteLn\n+END WriteFloor ;\n+\n+PROCEDURE InitScreen (p: CARDINAL) ;\n+BEGIN\n+   GetAccessToScreenNo(p) ;\n+   Sync(p) ;\n+   ClearScreen(p) ;\n+\n+   WITH Player[p] DO\n+      WriteName(p, ManName) ;\n+      WriteFloor(p) ;\n+      WriteRoom(p, RoomOfMan) ;\n+      WriteWounds(p, Wounds) ;\n+      WriteFatigue(p, Fatigue) ;\n+      WriteMagicArrows(p, NoOfMagic) ;\n+      WriteArrows(p, NoOfNormal) ;\n+      WriteWeight(p, Weight) ;\n+      WriteTime(p)\n+   END ;\n+   ReleaseAccessToScreenNo(p)\n+END InitScreen ;\n+\n+\n+PROCEDURE WriteCommentLine1 (p: CARDINAL; a: ARRAY OF CHAR) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('dC1 ') ; StrIO.WriteString(a) ; StrIO.WriteLn\n+END WriteCommentLine1 ;\n+\n+\n+PROCEDURE WriteCommentLine2 (p: CARDINAL; a: ARRAY OF CHAR) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('dC2 ') ; StrIO.WriteString(a) ; StrIO.WriteLn\n+END WriteCommentLine2 ;\n+\n+\n+PROCEDURE WriteCommentLine3 (p: CARDINAL; a: ARRAY OF CHAR) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('dC3 ') ; StrIO.WriteString(a) ; StrIO.WriteLn\n+END WriteCommentLine3 ;\n+\n+\n+PROCEDURE DelCommentLine1 (p: CARDINAL) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   WriteCommentLine1(p, '')\n+END DelCommentLine1 ;\n+\n+\n+PROCEDURE DelCommentLine2 (p: CARDINAL) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   WriteCommentLine2(p, '')\n+END DelCommentLine2 ;\n+\n+\n+PROCEDURE DelCommentLine3 (p: CARDINAL) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   WriteCommentLine3(p, '')\n+END DelCommentLine3 ;\n+\n+\n+(*\n+   Pause - issues a pause message and waits for a character to be pressed.\n+*)\n+\n+PROCEDURE Pause (p: CARDINAL) ;\n+VAR\n+   ch: CHAR ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   WriteCommentLine2(p, 'Press any key') ;\n+   WriteCommentLine3(p, 'to continue') ;\n+   IF ClientRead(ch)\n+   THEN\n+   END\n+END Pause ;\n+\n+\n+PROCEDURE Quit (p: CARDINAL) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('quit') ; StrIO.WriteLn\n+END Quit ;\n+\n+\n+(*\n+   PromptString - writes a text message to the client console.\n+                  without the final 'newline'\n+*)\n+\n+PROCEDURE PromptString (p: CARDINAL; a: ARRAY OF CHAR) ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   StrIO.WriteString('dWriteStr ') ;\n+   StrIO.WriteString(a) ;\n+   StrIO.WriteLn\n+END PromptString ;\n+\n+\n+(*\n+   WriteString - writes a text message to the client console.\n+*)\n+\n+PROCEDURE WriteString (p: CARDINAL; a: ARRAY OF CHAR) ;\n+VAR\n+   start,\n+   needEol: BOOLEAN ;\n+   i, j, n: CARDINAL ;\n+BEGIN\n+   AssignOutputTo(p) ;\n+   n := StrLen(a) ;\n+   i := 0 ;\n+   start := TRUE ;\n+   needEol := FALSE ;\n+   WHILE i<n DO\n+      IF (a[i]='\\') AND (a[i+1]='n')\n+      THEN\n+         IF start\n+         THEN\n+            StrIO.WriteString('dWriteLn ')\n+         END ;\n+         StrIO.WriteLn ;\n+         start := TRUE ;\n+         needEol := FALSE ;\n+         INC(i)\n+      ELSE\n+         IF start\n+         THEN\n+            StrIO.WriteString('dWriteLn ') ;\n+            start := FALSE\n+         END ;\n+         Write(a[i]) ;\n+         needEol := TRUE\n+      END ;\n+      INC(i)\n+   END ;\n+   IF needEol\n+   THEN\n+      StrIO.WriteLn\n+   END\n+END WriteString ;\n+\n+\n+END Screen.\n+(*\n+ * Local variables:\n+ *  compile-command: \"make\"\n+ * End:\n+ *)"}, {"sha": "5844bd26207f280cd4fb87c1e9110d0a59d5fcf5", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/SocketControl.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FSocketControl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FSocketControl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FSocketControl.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,27 @@\n+\n+#include <unistd.h>\n+#include <fcntl.h>\n+#include <signal.h>\n+\n+\n+int SocketControl_nonBlocking (int fd)\n+{\n+  return fcntl (fd, fcntl (fd, F_GETFL) | O_NONBLOCK);\n+}\n+\n+int SocketControl_ignoreSignals (void)\n+{\n+  signal (SIGPIPE, SIG_IGN);\n+}\n+\n+void _M2_SocketControl_init (int, char *, char *)\n+{\n+}\n+\n+void _M2_SocketControl_finish (int, char *, char *)\n+{\n+}\n+\n+void _M2_SocketControl_ctor ()\n+{\n+}"}, {"sha": "e52b2ec2b506b1ce7f6c8c398a8ec585153abfa8", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/SocketControl.def", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FSocketControl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FSocketControl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FSocketControl.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,6 @@\n+DEFINITION MODULE SocketControl ;\n+\n+PROCEDURE nonBlocking (fd: INTEGER) : INTEGER ;\n+PROCEDURE ignoreSignals ;\n+\n+END SocketControl."}, {"sha": "d515af404e66c4df893d3f1ae9f706cd97e110e0", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/Window.def", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FWindow.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FWindow.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FWindow.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,16 @@\n+DEFINITION MODULE Window ;\n+\n+\n+EXPORT QUALIFIED ClipPoint, Clip ;\n+\n+\n+PROCEDURE ClipPoint (VAR x, y: CARDINAL ; Sx, Sy: CARDINAL ; VAR ok: BOOLEAN) ;\n+\n+\n+PROCEDURE Clip (VAR x1,y1,x2,y2: CARDINAL ;\n+                          Sx,Sy: CARDINAL ;\n+                         VAR ok: BOOLEAN) ;\n+\n+\n+END Window.\n+"}, {"sha": "2f71271c2535ab1d1430be83136c4cde5c7f0783", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/Window.mod", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FWindow.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FWindow.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2FWindow.mod?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,62 @@\n+IMPLEMENTATION MODULE Window ;\n+\n+\n+FROM Screen IMPORT Width, Height ;\n+\n+\n+\n+PROCEDURE ClipPoint (VAR x, y: CARDINAL ; Sx, Sy: CARDINAL ; VAR ok: BOOLEAN) ;\n+BEGIN\n+   IF (x>=Sx) AND (x<=Sx+Width) AND\n+      (y>=Sy) AND (y<=Sy+Height)\n+   THEN\n+      DEC(x, Sx) ;\n+      DEC(y, Sy) ;\n+      ok := TRUE\n+   ELSE\n+      ok := FALSE\n+   END\n+END ClipPoint ;\n+\n+\n+PROCEDURE Clip (VAR x1, y1, x2, y2: CARDINAL ;\n+                            Sx, Sy: CARDINAL ;\n+                            VAR ok: BOOLEAN) ;\n+BEGIN\n+   IF (Sx>x2) OR (Sx+Width<x1)\n+   THEN\n+      ok := FALSE ;\n+   ELSIF (Sy>y2) OR (Sy+Height<y1)\n+   THEN\n+      ok := FALSE\n+   ELSE\n+      ok := TRUE ;\n+      IF Sx>x1\n+      THEN\n+         x1 := 0\n+      ELSE\n+         DEC(x1, Sx)\n+      END ;\n+      IF Sy>y1\n+      THEN\n+         y1 := 0\n+      ELSE\n+         DEC(y1, Sy)\n+      END ;\n+      IF x2-Sx>Width\n+      THEN\n+         x2 := Width\n+      ELSE\n+         DEC(x2, Sx)\n+      END ;\n+      IF y2-Sy>Height\n+      THEN\n+         y2 := Height\n+      ELSE\n+         DEC(y2, Sy)\n+      END\n+   END\n+END Clip ;\n+\n+      \n+END Window."}, {"sha": "0c4eebbcbbb94e76b90ec2af1cddc9c6c2bf079d", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/adv.flex", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2Fadv.flex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2Fadv.flex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2Fadv.flex?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "patch": "@@ -0,0 +1,266 @@\n+%{\n+/* Copyright (C) 2022 Free Software Foundation, Inc.\n+   This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License along\n+with gm2; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+ */\n+\n+  /*\n+   *  adv.flex - provides a lexical analyser for Dungeon\n+   */\n+\n+  struct lineInfo {\n+    char            *linebuf;          /* line contents */\n+    int              linelen;          /* length */\n+    int              tokenpos;         /* start position of token within line */\n+    int              toklen;           /* a copy of yylen (length of token) */\n+    int              nextpos;          /* position after token */\n+    int              actualline;       /* line number of this line */\n+  };\n+\n+  static int                  lineno      =1;   /* a running count of the file line number */\n+  static char                *filename    =NULL;\n+  static struct lineInfo     *currentLine =NULL;\n+\n+        void advflex_error      (const char *);\n+static  void finishedLine       (void);\n+static  void resetpos           (void);\n+static  void consumeLine        (void);\n+static  void updatepos          (void);\n+static  void skippos            (void);\n+static  void poperrorskip       (const char *);\n+\tint  advflex_OpenSource (char *s);\n+\tint  advflex_GetLineNo  (void);\n+\tvoid advflex_CloseSource(void);\n+\tchar *advflex_GetToken  (void);\n+        void _M2_advflex_init   (int, char *, char *);\n+        void _M2_advflex_finish (int, char *, char *);\n+        void _M2_advflex_ctor   (void);\n+extern  void  yylex             (void);\n+\n+#if !defined(TRUE)\n+#    define TRUE  (1==1)\n+#endif\n+#if !defined(FALSE)\n+#    define FALSE (1==0)\n+#endif\n+\n+typedef enum {eoftok, roomtok, doortok, walltok, treasuretok, attok,\n+              leadstok, totok, statustok, closedtok, opentok, secrettok,\n+              istok, endtok, enddottok, integertok, randomizetok} toktype ;\n+\n+toktype  advflex_currenttoken;\n+char    *advflex_currentident;\n+int      advflex_currentinteger;\n+\n+\n+#define YY_DECL void yylex (void)\n+%}\n+\n+%%\n+\n+\\n.*                      { consumeLine(); /* printf(\"found: %s\\n\", currentLine->linebuf); */ }\n+[0-9]+                    { updatepos();\n+                            advflex_currenttoken = integertok;\n+                            advflex_currentinteger = atoi(yytext);\n+                            return; }\n+[ \\t]*                    { updatepos(); }\n+ROOM                      { updatepos(); advflex_currenttoken = roomtok; return; }\n+END                       { updatepos(); advflex_currenttoken = endtok; return; }\n+WALL                      { updatepos(); advflex_currenttoken = walltok; return; }\n+DOOR                      { updatepos(); advflex_currenttoken = doortok; return; }\n+STATUS                    { updatepos(); advflex_currenttoken = statustok; return; }\n+CLOSED                    { updatepos(); advflex_currenttoken = closedtok; return; }\n+OPEN                      { updatepos(); advflex_currenttoken = opentok; return; }\n+SECRET                    { updatepos(); advflex_currenttoken = secrettok; return; }\n+LEADS                     { updatepos(); advflex_currenttoken = leadstok; return; }\n+TO                        { updatepos(); advflex_currenttoken = totok; return; }\n+TREASURE                  { updatepos(); advflex_currenttoken = treasuretok; return; }\n+AT                        { updatepos(); advflex_currenttoken = attok; return; }\n+IS                        { updatepos(); advflex_currenttoken = istok; return; }\n+END.                      { updatepos(); advflex_currenttoken = enddottok; return; }\n+RANDOMIZE                 { updatepos(); advflex_currenttoken = randomizetok; return; }\n+<<EOF>>                   { updatepos(); advflex_currenttoken = eoftok; return; }\n+\n+%%\n+\n+/*\n+ *  consumeLine - reads a line into a buffer, it then pushes back the whole\n+ *                line except the initial \\n.\n+ */\n+\n+static void consumeLine (void)\n+{\n+  if (currentLine->linelen<yyleng) {\n+    currentLine->linebuf = (char *)realloc (currentLine->linebuf, yyleng);\n+    currentLine->linelen = yyleng;\n+  }\n+  strcpy(currentLine->linebuf, yytext+1);  /* copy all except the initial \\n */\n+  lineno++;\n+  currentLine->actualline = lineno;\n+  currentLine->tokenpos=0;\n+  currentLine->nextpos=0;\n+  yyless(1);                  /* push back all but the \\n */\n+}\n+\n+/*\n+ *  updatepos - updates the current token position.\n+ *              Should be used when a rule matches a token.\n+ */\n+\n+static void updatepos (void)\n+{\n+  currentLine->nextpos = currentLine->tokenpos+yyleng;\n+  currentLine->toklen  = yyleng;\n+}\n+\n+/*\n+ *  skippos - skips over this token. This function should be called\n+ *            if we are not returning and thus not calling getToken.\n+ */\n+\n+static void skippos (void)\n+{\n+  currentLine->tokenpos = currentLine->nextpos;\n+}\n+\n+/*\n+ *  initLine - initializes a currentLine\n+ */\n+\n+static void initLine (void)\n+{\n+  currentLine = (struct lineInfo *)malloc (sizeof(struct lineInfo));\n+\n+  if (currentLine == NULL)\n+    perror(\"malloc\");\n+  currentLine->linebuf    = NULL;\n+  currentLine->linelen    = 0;\n+  currentLine->tokenpos   = 0;\n+  currentLine->toklen     = 0;\n+  currentLine->nextpos    = 0;\n+  currentLine->actualline = lineno;\n+}\n+\n+/*\n+ *  resetpos - resets the position of the next token to the start of the line.\n+ */\n+\n+static void resetpos (void)\n+{\n+  if (currentLine != NULL)\n+    currentLine->nextpos = 0;\n+}\n+\n+/*\n+ *  advflex_GetToken - returns a new token.\n+ */\n+\n+char *advflex_GetToken (void)\n+{\n+  if (currentLine == NULL)\n+    initLine();\n+  currentLine->tokenpos = currentLine->nextpos;\n+  yylex();\n+}\n+\n+void advflex_error (const char *s)\n+{\n+  if (currentLine != NULL) {\n+    printf(\"%s:%d:%s\\n\", filename, currentLine->actualline, s);\n+    printf(\"%s\\n\", currentLine->linebuf);\n+# if 0\n+    printf(\"%*s%*s\\n\", currentLine->nextpos, \" \", currentLine->toklen, \"^\");\n+# endif\n+  }\n+}\n+\n+/*\n+ *  OpenSource - returns TRUE if file, s, can be opened and\n+ *               all tokens are taken from this file.\n+ */\n+\n+int advflex_OpenSource (char *s)\n+{\n+  FILE *f = fopen(s, \"r\");\n+\n+  if (f == NULL)\n+    return FALSE;\n+  else {\n+    yy_delete_buffer(YY_CURRENT_BUFFER);\n+    yy_switch_to_buffer(yy_create_buffer(f, YY_BUF_SIZE));\n+    filename = strdup(s);\n+    lineno   =1;\n+    if (currentLine != NULL)\n+      currentLine->actualline = lineno;\n+    return TRUE;\n+  }\n+}\n+\n+/*\n+ *  CloseSource - provided for semantic sugar\n+ */\n+\n+void advflex_CloseSource (void)\n+{\n+}\n+\n+/*\n+ *  advflex_GetLineNo - returns the current line number.\n+ */\n+\n+int advflex_GetLineNo (void)\n+{\n+  if (currentLine != NULL)\n+    return currentLine->actualline;\n+  else\n+    return 0;\n+}\n+\n+/*\n+ *  yywrap is called when end of file is seen. We push an eof token\n+ *         and tell the lexical analysis to stop.\n+ */\n+\n+int yywrap (void)\n+{\n+  updatepos(); return 1;\n+}\n+\n+void _M2_advflex_init (int, char *, char *)\n+{\n+}\n+\n+void _M2_advflex_finish (int, char *, char *)\n+{\n+}\n+\n+void _M2_advflex_ctor (void)\n+{\n+}\n+\n+#if 0\n+main () {\n+  char *s;\n+\n+  if (advflex_OpenSource(\"../maps/glover\")) {\n+    s = (char *)advflex_GetToken();\n+    while (s != NULL) {\n+      advflex_error(s);\n+      s = (char *)advflex_GetToken();\n+    }\n+  }\n+}\n+#endif"}, {"sha": "542723f652105b1fdef84ca254516eea342a5371", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/advflex.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2Fadvflex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2Fadvflex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2Fadvflex.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "49e50c63cbe86099b1e46353952ecb3e686bab2a", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/advflex.def", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2Fadvflex.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2Fadvflex.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2Fadvflex.def?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "303672eb5f7c4bf83a130f9ca23e267891348bf7", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/projects-pim-run-pass-tower.exp", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2Fprojects-pim-run-pass-tower.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2Fprojects-pim-run-pass-tower.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2Fprojects-pim-run-pass-tower.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "4bdae853296ad8e72c2e61f6121abf6e0be07608", "filename": "gcc/testsuite/gm2/projects/pim/run/pass/tower/star", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2Fstar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2Fstar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fprojects%2Fpim%2Frun%2Fpass%2Ftower%2Fstar?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "44b44b42fe5ff87330d84e06ee1f54e931e0ff3a", "filename": "gcc/testsuite/gm2/switches/auto-init/fail/switches-auto-init-fail.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fswitches%2Fauto-init%2Ffail%2Fswitches-auto-init-fail.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fswitches%2Fauto-init%2Ffail%2Fswitches-auto-init-fail.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fswitches%2Fauto-init%2Ffail%2Fswitches-auto-init-fail.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "bd2d72373ea16b4b7027aa19a7665679ed1d4335", "filename": "gcc/testsuite/gm2/switches/check-all/pim2/fail/switches-check-all-pim2-fail.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fswitches%2Fcheck-all%2Fpim2%2Ffail%2Fswitches-check-all-pim2-fail.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fswitches%2Fcheck-all%2Fpim2%2Ffail%2Fswitches-check-all-pim2-fail.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fswitches%2Fcheck-all%2Fpim2%2Ffail%2Fswitches-check-all-pim2-fail.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "42dc3f108c4181d24c6468ce08969ddb8c654d2c", "filename": "gcc/testsuite/gm2/switches/makeall/fail/switches-makeall-fail.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fswitches%2Fmakeall%2Ffail%2Fswitches-makeall-fail.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fswitches%2Fmakeall%2Ffail%2Fswitches-makeall-fail.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fswitches%2Fmakeall%2Ffail%2Fswitches-makeall-fail.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "e94d0fdfe4fc736f90ee9a5762a8cac3563d7010", "filename": "gcc/testsuite/gm2/switches/makeall/pass/switches-makeall-pass.exp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fswitches%2Fmakeall%2Fpass%2Fswitches-makeall-pass.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Fgm2%2Fswitches%2Fmakeall%2Fpass%2Fswitches-makeall-pass.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fswitches%2Fmakeall%2Fpass%2Fswitches-makeall-pass.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "506a8155737bf76b208cdb790b9f96aa80010963", "filename": "gcc/testsuite/lib/gm2-simple.exp", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Flib%2Fgm2-simple.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Flib%2Fgm2-simple.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgm2-simple.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "e364dcf41afdb1cc7693fbaafffddc8b44c5878f", "filename": "gcc/testsuite/lib/gm2-torture.exp", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Flib%2Fgm2-torture.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Flib%2Fgm2-torture.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgm2-torture.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "25b5e684b3a58f6519c14270b4bc6ef744f30675", "filename": "gcc/testsuite/lib/gm2.exp", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Flib%2Fgm2.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/gcc%2Ftestsuite%2Flib%2Fgm2.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgm2.exp?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "e2e8198fb13121ca09ab70a4d1a8eb85c62f5eba", "filename": "libgm2/libm2cor/KeyBoardLEDs.cc", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2cor%2FKeyBoardLEDs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2cor%2FKeyBoardLEDs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2cor%2FKeyBoardLEDs.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "25a5f002f7725c31cee33d7dbb6acc5aba7801bf", "filename": "libgm2/libm2cor/Makefile.am", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2cor%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2cor%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2cor%2FMakefile.am?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "869924ba17b2c88b275e483e1131a4d40312b08a", "filename": "libgm2/libm2cor/Makefile.in", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2cor%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2cor%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2cor%2FMakefile.in?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "55db89df30d15e46c87600b3e76f6b97b6f1d96f", "filename": "libgm2/libm2iso/ErrnoCategory.cc", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2iso%2FErrnoCategory.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2iso%2FErrnoCategory.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2iso%2FErrnoCategory.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "dddced4b8af1fece6fd7760657b436b1217c8eed", "filename": "libgm2/libm2iso/Makefile.am", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2iso%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2iso%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2iso%2FMakefile.am?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "e28e9dd29787605496e220320f9a4f4b86069642", "filename": "libgm2/libm2iso/Makefile.in", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2iso%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2iso%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2iso%2FMakefile.in?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "33da58661d254ecf6ed673df7a5ce728c056285f", "filename": "libgm2/libm2iso/RTco.cc", "status": "modified", "additions": 64, "deletions": 53, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2iso%2FRTco.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2iso%2FRTco.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2iso%2FRTco.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "97612c11c8d56702a58323e0c3f001b2fb62fd7c", "filename": "libgm2/libm2iso/m2rts.h", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2iso%2Fm2rts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2iso%2Fm2rts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2iso%2Fm2rts.h?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "1582f24c359b27d0b0dad736b782b687e9eea171", "filename": "libgm2/libm2iso/wrapsock.c", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2iso%2Fwrapsock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2iso%2Fwrapsock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2iso%2Fwrapsock.c?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "3cdc3856ef12fd60ef1958663771f441eff4464b", "filename": "libgm2/libm2iso/wraptime.cc", "status": "renamed", "additions": 105, "deletions": 84, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2iso%2Fwraptime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2iso%2Fwraptime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2iso%2Fwraptime.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "previous_filename": "libgm2/libm2iso/wraptime.c"}, {"sha": "c38ec3cda56f6f8820e8b1baa1b891e1354edee9", "filename": "libgm2/libm2log/Makefile.am", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2log%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2log%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2log%2FMakefile.am?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "ef43b0dc49f1866a326d844f2f75716d30172182", "filename": "libgm2/libm2log/Makefile.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2log%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2log%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2log%2FMakefile.in?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "4d6203a69e3258bcce5fb1d09bc8ceccb4cd4e75", "filename": "libgm2/libm2min/Makefile.am", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2min%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2min%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2min%2FMakefile.am?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "673d6d59d94289e0cc7715f2dc6b5322b7ed5ca5", "filename": "libgm2/libm2min/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2min%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2min%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2min%2FMakefile.in?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "eae14fad62bd6aa0fe9eb13f0caa191f0f2911aa", "filename": "libgm2/libm2pim/Makefile.am", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2pim%2FMakefile.am?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "ec81103981bb52eef2f67212cda0b8c0467980e1", "filename": "libgm2/libm2pim/Makefile.in", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2pim%2FMakefile.in?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "09c57f2f0d4966af9d2db461c1e23ef148299fa2", "filename": "libgm2/libm2pim/Selective.cc", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2FSelective.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2FSelective.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2pim%2FSelective.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "d93e79e3d558ac84e4f1cc0ef63ebffa883ca824", "filename": "libgm2/libm2pim/SysExceptions.cc", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2FSysExceptions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2FSysExceptions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2pim%2FSysExceptions.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "803188d0298b7401932b6662b176fb772cd43d8f", "filename": "libgm2/libm2pim/UnixArgs.cc", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2FUnixArgs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2FUnixArgs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2pim%2FUnixArgs.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "858c77503f1355316e604541c01a23405eb6c923", "filename": "libgm2/libm2pim/cgetopt.cc", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2Fcgetopt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2Fcgetopt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2pim%2Fcgetopt.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "c6b573bedc02617b2981e40316d65facf3bf1b27", "filename": "libgm2/libm2pim/dtoa.cc", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2Fdtoa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2Fdtoa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2pim%2Fdtoa.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "db8628f5b55b269717ed6c2933f70b3180fbe227", "filename": "libgm2/libm2pim/errno.cc", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2Ferrno.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2Ferrno.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2pim%2Ferrno.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "9250ca4aaf60c175f48e673b67d28281a2b4de1f", "filename": "libgm2/libm2pim/ldtoa.cc", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2Fldtoa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2Fldtoa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2pim%2Fldtoa.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "ee579c2cc69dd0f91370e8e99360a70307060df2", "filename": "libgm2/libm2pim/sckt.cc", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2Fsckt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2Fsckt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2pim%2Fsckt.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "5812837f2bfea07998963ffbef245ec0d1c4bd2b", "filename": "libgm2/libm2pim/termios.cc", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2Ftermios.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2Ftermios.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2pim%2Ftermios.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892"}, {"sha": "0412cccb70bb497194423518b9bc23a9b5636151", "filename": "libgm2/libm2pim/wrapc.cc", "status": "renamed", "additions": 52, "deletions": 40, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2Fwrapc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05652ac4e8b8685fe0c0f4ee2f75516d28bbf892/libgm2%2Flibm2pim%2Fwrapc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2pim%2Fwrapc.cc?ref=05652ac4e8b8685fe0c0f4ee2f75516d28bbf892", "previous_filename": "libgm2/libm2pim/wrapc.c"}]}