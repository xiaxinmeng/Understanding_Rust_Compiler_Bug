{"sha": "cb96daa2dcb181abb218017a4de32838285094fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I5NmRhYTJkY2IxODFhYmIyMTgwMTdhNGRlMzI4MzgyODUwOTRmYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-05-21T00:48:49Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-05-21T00:48:49Z"}, "message": "decl2.c (find_representative_member): Rename to ...\n\n\t* decl2.c (find_representative_member): Rename to ...\n\t(build_anon_union_vars): New function.\n\t(finish_anon_union): Fix stupidity of previous change.\n\nFrom-SVN: r19920", "tree": {"sha": "7ab08ece36e47071a3f82d11d4879b0babf319a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ab08ece36e47071a3f82d11d4879b0babf319a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb96daa2dcb181abb218017a4de32838285094fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb96daa2dcb181abb218017a4de32838285094fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb96daa2dcb181abb218017a4de32838285094fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb96daa2dcb181abb218017a4de32838285094fa/comments", "author": null, "committer": null, "parents": [{"sha": "f9d94ea4d411ebc87081197daa8b53c65e50c6bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9d94ea4d411ebc87081197daa8b53c65e50c6bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9d94ea4d411ebc87081197daa8b53c65e50c6bd"}], "stats": {"total": 147, "additions": 92, "deletions": 55}, "files": [{"sha": "b89b270df3b153868dc66ed983503589456ae8c7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb96daa2dcb181abb218017a4de32838285094fa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb96daa2dcb181abb218017a4de32838285094fa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cb96daa2dcb181abb218017a4de32838285094fa", "patch": "@@ -1,3 +1,9 @@\n+1998-05-21  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* decl2.c (find_representative_member): Rename to ...\n+\t(build_anon_union_vars): New function.\n+\t(finish_anon_union): Fix stupidity of previous change.\n+\n 1998-05-20  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (grokfndecl): Handle definition of specialization in"}, {"sha": "a7daa2aafa3db51d06152b02af21260364bd9214", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb96daa2dcb181abb218017a4de32838285094fa/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb96daa2dcb181abb218017a4de32838285094fa/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=cb96daa2dcb181abb218017a4de32838285094fa", "patch": "@@ -52,7 +52,7 @@ static int is_namespace_ancestor PROTO((tree, tree));\n static tree namespace_ancestor PROTO((tree, tree));\n static void add_using_namespace PROTO((tree, tree, int));\n static tree ambiguous_decl PROTO((tree, tree, tree));\n-static tree find_representative_member PROTO((tree));\n+static tree build_anon_union_vars PROTO((tree, tree*, int, int));\n \n extern int current_class_depth;\n \n@@ -2145,40 +2145,73 @@ get_temp_regvar (type, init)\n   return decl;\n }\n \n-/* Hunt through ANON_DECL, which declares an anonymous union, for a named\n-   member of the same size as ANON_DECL.  */\n+/* Hunts through the global anonymous union ANON_DECL, building\n+   appropriate VAR_DECLs.  Stores cleanups on the list of ELEMS, and\n+   returns a VAR_DECL whose size is the same as the size of the\n+   ANON_DECL, if one is available.  */\n \n-tree\n-find_representative_member (anon_decl)\n+tree \n+build_anon_union_vars (anon_decl, elems, static_p, external_p)\n      tree anon_decl;\n+     tree* elems;\n+     int static_p;\n+     int external_p;\n {\n-  tree field;\n+  tree type = TREE_TYPE (anon_decl);\n   tree main_decl = NULL_TREE;\n+  tree field;\n \n-  for (field = TYPE_FIELDS (TREE_TYPE (anon_decl));\n+  for (field = TYPE_FIELDS (type); \n        field != NULL_TREE; \n        field = TREE_CHAIN (field))\n     {\n+      tree decl;\n       if (TREE_CODE (field) != FIELD_DECL)\n \tcontinue;\n \n+      if (TREE_PRIVATE (field))\n+\tcp_pedwarn_at (\"private member `%#D' in anonymous union\", field);\n+      else if (TREE_PROTECTED (field))\n+\tcp_pedwarn_at (\"protected member `%#D' in anonymous union\", field);\n+\n+      if (DECL_NAME (field) == NULL_TREE\n+\t  && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n+\tdecl = build_anon_union_vars (field, elems, static_p, external_p);\n+      else\n+\t{\n+\t  decl = build_decl (VAR_DECL, DECL_NAME (field), TREE_TYPE (field));\n+\t  /* tell `pushdecl' that this is not tentative.  */\n+\t  DECL_INITIAL (decl) = error_mark_node;\n+\t  TREE_PUBLIC (decl) = 0;\n+\t  TREE_STATIC (decl) = static_p;\n+\t  DECL_EXTERNAL (decl) = external_p;\n+\t  decl = pushdecl (decl);\n+\t  DECL_INITIAL (decl) = NULL_TREE;\n+\t}\n+\n       /* Only write out one anon union element--choose the one that\n \t can hold them all.  */\n       if (main_decl == NULL_TREE\n-\t  && 1 == simple_cst_equal (DECL_SIZE (field),\n-\t\t\t\t    DECL_SIZE (anon_decl)))\n-\t{\n-\t  if (DECL_NAME (field))\n-\t    main_decl = field;\n-\t  else if (TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n-\t    main_decl = find_representative_member (field);\n-\t}\n-      else\n+\t  && simple_cst_equal (DECL_SIZE (decl),\n+\t\t\t       DECL_SIZE (anon_decl)) == 1)\n+\tmain_decl = decl;\n+      else \n \t/* ??? This causes there to be no debug info written out\n \t   about this decl.  */\n-\tTREE_ASM_WRITTEN (field) = 1;\n-    }\n+\tTREE_ASM_WRITTEN (decl) = 1;\n+      \n+      if (DECL_NAME (field) == NULL_TREE\n+\t  && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n+\t/* The remainder of the processing was already done in the\n+\t   recursive call.  */\n+\tcontinue;\n \n+      /* If there's a cleanup to do, it belongs in the\n+\t TREE_PURPOSE of the following TREE_LIST.  */\n+      *elems = scratch_tree_cons (NULL_TREE, decl, *elems);\n+      TREE_TYPE (*elems) = type;\n+    }\n+  \n   return main_decl;\n }\n \n@@ -2194,13 +2227,13 @@ finish_anon_union (anon_union_decl)\n      tree anon_union_decl;\n {\n   tree type = TREE_TYPE (anon_union_decl);\n-  tree field = TYPE_FIELDS (type);\n   tree elems = NULL_TREE;\n+  tree main_decl;\n   int public_p = TREE_PUBLIC (anon_union_decl);\n   int static_p = TREE_STATIC (anon_union_decl);\n   int external_p = DECL_EXTERNAL (anon_union_decl);\n \n-  if (field == NULL_TREE)\n+  if (TYPE_FIELDS (type) == NULL_TREE)\n     return;\n \n   if (public_p)\n@@ -2209,44 +2242,11 @@ finish_anon_union (anon_union_decl)\n       return;\n     }\n \n-  for (; field; field = TREE_CHAIN (field))\n-    {\n-      tree decl;\n-      if (TREE_CODE (field) != FIELD_DECL)\n-\tcontinue;\n-\n-      if (TREE_PRIVATE (field))\n-\tcp_pedwarn_at (\"private member `%#D' in anonymous union\", field);\n-      else if (TREE_PROTECTED (field))\n-\tcp_pedwarn_at (\"protected member `%#D' in anonymous union\", field);\n-\n-      if (DECL_NAME (field) == NULL_TREE\n-\t  && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE\n-\t  && find_representative_member (field) == NULL_TREE)\n-\t/* The member is an empty anonymous union.  Don't make a\n-\t   declaration for it, as finish_file will otherwise try to\n-\t   call make_decl_rtl for it, and crash.  */\n-\tcontinue;\n-\n-      decl = build_decl (VAR_DECL, DECL_NAME (field), TREE_TYPE (field));\n-      /* tell `pushdecl' that this is not tentative.  */\n-      DECL_INITIAL (decl) = error_mark_node;\n-      TREE_PUBLIC (decl) = public_p;\n-      TREE_STATIC (decl) = static_p;\n-      DECL_EXTERNAL (decl) = external_p;\n-      decl = pushdecl (decl);\n-\n-      DECL_INITIAL (decl) = NULL_TREE;\n-      /* If there's a cleanup to do, it belongs in the\n-\t TREE_PURPOSE of the following TREE_LIST.  */\n-      elems = scratch_tree_cons (NULL_TREE, decl, elems);\n-      TREE_TYPE (elems) = type;\n-    }\n+  main_decl = build_anon_union_vars (anon_union_decl, &elems, \n+\t\t\t\t     static_p, external_p);\n \n   if (static_p)\n     {\n-      tree main_decl = find_representative_member (anon_union_decl);\n-\n       if (main_decl)\n \t{\n \t  make_decl_rtl (main_decl, 0, toplevel_bindings_p ());"}, {"sha": "49a7b2c35d6e9878422ee4fe132a2b78d6aed9d7", "filename": "gcc/testsuite/g++.old-deja/g++.other/anon2.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb96daa2dcb181abb218017a4de32838285094fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb96daa2dcb181abb218017a4de32838285094fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon2.C?ref=cb96daa2dcb181abb218017a4de32838285094fa", "patch": "@@ -0,0 +1,31 @@\n+extern \"C\" void abort (void);\n+\n+static union { \n+  int x1; \n+  long x2; \n+  short x3;\n+  long x4;\n+};\n+\n+static union {\n+  union {\n+    union {\n+      int z;\n+    };\n+  };\n+  union {\n+    union {\n+      double d;\n+      int i;\n+    };\n+  };\n+};\n+\n+\n+int main()\n+{\n+  z = 3;\n+  if (i != 3)\n+    abort ();\n+  d = 2.5;\n+}"}]}