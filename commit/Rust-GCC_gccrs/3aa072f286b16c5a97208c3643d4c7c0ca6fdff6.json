{"sha": "3aa072f286b16c5a97208c3643d4c7c0ca6fdff6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FhMDcyZjI4NmIxNmM1YTk3MjA4YzM2NDNkNGM3YzBjYTZmZGZmNg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-27T22:11:24Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-27T22:11:24Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1108", "tree": {"sha": "5e28bce09ad07cefce68def20203767592fb6d4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e28bce09ad07cefce68def20203767592fb6d4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3aa072f286b16c5a97208c3643d4c7c0ca6fdff6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aa072f286b16c5a97208c3643d4c7c0ca6fdff6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aa072f286b16c5a97208c3643d4c7c0ca6fdff6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aa072f286b16c5a97208c3643d4c7c0ca6fdff6/comments", "author": null, "committer": null, "parents": [{"sha": "2b9a9aea2f9414a4abe0450d0c660deb8532bd83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b9a9aea2f9414a4abe0450d0c660deb8532bd83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b9a9aea2f9414a4abe0450d0c660deb8532bd83"}], "stats": {"total": 22, "additions": 16, "deletions": 6}, "files": [{"sha": "225ea955ee2fc2d26c38e7be5da12ea6f4f37d0a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aa072f286b16c5a97208c3643d4c7c0ca6fdff6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aa072f286b16c5a97208c3643d4c7c0ca6fdff6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3aa072f286b16c5a97208c3643d4c7c0ca6fdff6", "patch": "@@ -416,9 +416,9 @@ Makefile: $(srcdir)/Makefile.in $(srcdir)/configure $(srcdir)/version.c \\\n \n all.internal: start.encap rest.encap\n # This is what to compile if making a cross-compiler.\n-all.cross: native gcc-cross cross-test\n+all.cross: native gcc-cross cross-test $(EXTRA_PARTS)\n # This is what must be made before installing GCC and converting libraries.\n-start.encap: native gcc $(LIBGCC1_TARGET)\n+start.encap: native gcc specs $(LIBGCC1_TARGET)\n # Use this to make a GCC that will be used only to recompile GCC.\n for-bootstrap: start.encap libgcc.a\n # These can't be made, with COFF encapsulation, until after GCC can run.\n@@ -445,20 +445,28 @@ config.status:\n \t  true; \\\n \tfi\n \n+# On the target machine, finish building a cross compiler.\n+# This does the things that can't be done on the host machine.\n+rest.cross: libgcc.a float.h specs\n+\n # Verify that it works to compile and link cross-test.\n # If it does, then there are sufficient replacements for libgcc1.a.\n cross-test: cross-test.o native gcc-cross\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) cross-test.o -o $@\n cross-test.o: cross-test.c native gcc-cross\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(ALL_CPPFLAGS) -c $(srcdir)/cross-test.c\n \n+# Recompile all the language-independent object files.\n+# This is used only if the user explicitly asks for it.\n compilations: ${OBJS}\n \n gcc: gcc.o version.o $(LIBDEPS)\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o gccnew gcc.o version.o $(LIBS)\n # Go via `gccnew' to avoid `file busy' if $(CC) is `gcc'.\n \tmv -f gccnew gcc\n-# Dump a specs file to make -B./ read these specs over installed ones\n+\n+# Dump a specs file to make -B./ read these specs over installed ones.\n+specs: gcc\n \t./gcc -dumpspecs > specs\n \n # We do want to create an executable named `gcc', so we can use it to\n@@ -1135,12 +1143,14 @@ protoize.1:\t$(srcdir)/proto-man ./cpp\n \t./cpp -traditional $(srcdir)/proto-man \\\n \t\t| grep -v '^#' \\\n \t\t\t| awk 'NF > 0 {print}' > tmp-proto.1\n+\t-rm -f protoize.1\n \tmv tmp-proto.1 protoize.1\n \n unprotoize.1:\t$(srcdir)/proto-man ./cpp\n \t./cpp -traditional -DUNPRO $(srcdir)/proto-man \\\n \t\t| grep -v '^#' \\\n \t\t\t| awk 'NF > 0 {print}' > tmp-unproto.1\n+\t-rm -f unprotoize.1\n \tmv tmp-unproto.1 unprotoize.1\n \n # This info describes the target machine, so compile with GCC just built.\n@@ -1213,7 +1223,7 @@ mostlyclean:\n \tfor name in $(LIB1FUNCS); do rm -f $${name}.c; done\n # Delete other temporary files.\n \t-rm -f tmp-float.h tmp-gcc.xtar.Z tmp-limits.h gccnew\n-\t-rm -f tmp-foo1 tmp-foo2 tmp-proto.*\n+\t-rm -f tmp-foo1 tmp-foo2 tmp-proto.* tmp-unproto.1\n # Delete the stamp files.\n \t-rm -f stamp-* tmp-*\n # Delete debugging dump files.\n@@ -1236,8 +1246,8 @@ clean: mostlyclean\n # but the spec for `make clean' requires it.\n # Using unprotoize.c is not quite right in the first place, \n # but what better way is there?\n-\t-rm -f libgcc.a libgcc1.a libgcc2.a libgcc2.ready unprotoize.c\n-\t-rm -f *.dvi\n+\t-rm -f libgcc.a libgcc1.a libgcc2.a libgcc2.ready libgcc1.null\n+\t-rm -f *.dvi unprotoize.c\n \n # Delete all files that users would normally create\n # while building and installing GCC."}]}