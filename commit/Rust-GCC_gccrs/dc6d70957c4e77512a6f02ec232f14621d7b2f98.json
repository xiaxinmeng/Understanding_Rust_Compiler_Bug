{"sha": "dc6d70957c4e77512a6f02ec232f14621d7b2f98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM2ZDcwOTU3YzRlNzc1MTJhNmYwMmVjMjMyZjE0NjIxZDdiMmY5OA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-08-01T18:04:42Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-08-01T18:04:42Z"}, "message": "decl.c (update_aliases, [...]): Replace calls to build with calls to buildN.\n\n\n\t* decl.c (update_aliases, initialize_local_variable): Replace calls\n\tto build with calls to buildN.\n\t* java-gimplify.c (java_gimplify_modify_expr): Likewise.\n\t* java-tree.h (BUILD_MONITOR_ENTER, BUILD_MONITOR_EXIT): Likewise.\n\t* parse.h (BUILD_THROW): Likewise.\n\t* parse.y (switch_expression, synchronized_statement,\n\tcatch_clause_parameter, array_creation_expression,\n\tconditional_expression, make_qualified_name,\n\tresolve_qualified_expression_name, patch_method_invocation,\n\tpatch_invoke, build_method_invocation, build_new_invocation,\n\tbuild_assignment, patch_assignment, build_binop, patch_binop,\n\tbuild_string_concatenation, build_incdec, patch_unaryop,\n\tpatch_cast, build_array_ref, build_newarray_node, patch_newarray,\n\tpatch_return, build_if_else_statement, build_labeled_block,\n\tbuild_new_loop, build_loop_body, build_bc_statement,\n\tbuild_assertion, encapsulate_with_try_catch, build_try_statement,\n\tbuild_try_finally_statement, patch_synchronized_statement,\n\temit_test_initialization): Likewise, replace build with buildN.\n\nFrom-SVN: r85410", "tree": {"sha": "f84e9456b641e477dd7ac93534fec7e9caea9a9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f84e9456b641e477dd7ac93534fec7e9caea9a9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc6d70957c4e77512a6f02ec232f14621d7b2f98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc6d70957c4e77512a6f02ec232f14621d7b2f98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc6d70957c4e77512a6f02ec232f14621d7b2f98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc6d70957c4e77512a6f02ec232f14621d7b2f98/comments", "author": null, "committer": null, "parents": [{"sha": "023d776a1124e7cdcc9bb51716f1aed6b0ff3735", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/023d776a1124e7cdcc9bb51716f1aed6b0ff3735", "html_url": "https://github.com/Rust-GCC/gccrs/commit/023d776a1124e7cdcc9bb51716f1aed6b0ff3735"}], "stats": {"total": 230, "additions": 125, "deletions": 105}, "files": [{"sha": "b2c0a625fa6afdf77df5451ec389604a951a5646", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc6d70957c4e77512a6f02ec232f14621d7b2f98/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc6d70957c4e77512a6f02ec232f14621d7b2f98/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=dc6d70957c4e77512a6f02ec232f14621d7b2f98", "patch": "@@ -1,3 +1,24 @@\n+2004-08-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* decl.c (update_aliases, initialize_local_variable): Replace calls\n+\tto build with calls to buildN.\n+\t* java-gimplify.c (java_gimplify_modify_expr): Likewise.\n+\t* java-tree.h (BUILD_MONITOR_ENTER, BUILD_MONITOR_EXIT): Likewise.\n+\t* parse.h (BUILD_THROW): Likewise.\n+\t* parse.y (switch_expression, synchronized_statement,\n+\tcatch_clause_parameter, array_creation_expression,\n+\tconditional_expression, make_qualified_name,\n+\tresolve_qualified_expression_name, patch_method_invocation,\n+\tpatch_invoke, build_method_invocation, build_new_invocation,\n+\tbuild_assignment, patch_assignment, build_binop, patch_binop,\n+\tbuild_string_concatenation, build_incdec, patch_unaryop,\n+\tpatch_cast, build_array_ref, build_newarray_node, patch_newarray,\n+\tpatch_return, build_if_else_statement, build_labeled_block,\n+\tbuild_new_loop, build_loop_body, build_bc_statement,\n+\tbuild_assertion, encapsulate_with_try_catch, build_try_statement,\n+\tbuild_try_finally_statement, patch_synchronized_statement,\n+\temit_test_initialization): Likewise, replace build with buildN.\n+\n 2004-07-28  Eric Christopher  <echristo@redhat.com>\n \n \t* lang.c (LANG_HOOKS_UNSAFE_FOR_REEVAL): Delete."}, {"sha": "54a2e207273df8d4d0a12e25b21d2f707bf9b9af", "filename": "gcc/java/decl.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc6d70957c4e77512a6f02ec232f14621d7b2f98/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc6d70957c4e77512a6f02ec232f14621d7b2f98/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=dc6d70957c4e77512a6f02ec232f14621d7b2f98", "patch": "@@ -153,8 +153,7 @@ update_aliases (tree decl, int index, int pc)\n \t  tree src = build1 (NOP_EXPR, tmp_type, decl);\n \t  if (LOCAL_VAR_OUT_OF_SCOPE_P (tmp))\n \t    abort ();\n-\t  java_add_stmt \n-\t    (build (MODIFY_EXPR, tmp_type, tmp, src));\n+\t  java_add_stmt (build2 (MODIFY_EXPR, tmp_type, tmp, src));\n \t}\n     }\n }\n@@ -196,8 +195,7 @@ initialize_local_variable (tree decl, int index)\n \t  /* At the point of its creation this decl inherits whatever\n \t     is in the slot.  */\n \t  tree src = build1 (NOP_EXPR, decl_type, tmp);\n-\t  java_add_stmt \n-\t    (build (MODIFY_EXPR, decl_type, decl, src));\t\n+\t  java_add_stmt (build2 (MODIFY_EXPR, decl_type, decl, src));\t\n \t}\n     }\n   else\n@@ -216,10 +214,10 @@ initialize_local_variable (tree decl, int index)\n \t\t      && INTEGRAL_TYPE_P (decl_type)\n \t\t      && TYPE_PRECISION (decl_type) <= 32\n \t\t      && TYPE_PRECISION (tmp_type) <= 32\n-\t\t      && TYPE_PRECISION (tmp_type) >= TYPE_PRECISION (decl_type))))\n+\t\t      && TYPE_PRECISION (tmp_type)\n+\t\t\t >= TYPE_PRECISION (decl_type))))\n \t    {\n-\t      java_add_stmt \n-\t\t(build (MODIFY_EXPR, decl_type, decl, tmp));\t\n+\t      java_add_stmt (build2 (MODIFY_EXPR, decl_type, decl, tmp));\t\n \t      return;\n \t    }\n \t}  "}, {"sha": "5dd69bf40fe364ba23fc7aaed0e61b0227ad1fd3", "filename": "gcc/java/java-gimplify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc6d70957c4e77512a6f02ec232f14621d7b2f98/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc6d70957c4e77512a6f02ec232f14621d7b2f98/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=dc6d70957c4e77512a6f02ec232f14621d7b2f98", "patch": "@@ -174,8 +174,8 @@ java_gimplify_modify_expr (tree modify_expr)\n     {\n       tree new_lhs = java_replace_reference (lhs, /* want_lvalue */ true);\n       tree new_rhs = build1 (NOP_EXPR, TREE_TYPE (new_lhs), rhs);\n-      modify_expr = build (MODIFY_EXPR, TREE_TYPE (new_lhs),\n-\t\t\t   new_lhs, new_rhs);\n+      modify_expr = build2 (MODIFY_EXPR, TREE_TYPE (new_lhs),\n+\t\t\t    new_lhs, new_rhs);\n       modify_expr = build1 (NOP_EXPR, lhs_type, modify_expr);\n     }\n   "}, {"sha": "f44005d0f2edc8105767433fae4a0e280a72e051", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc6d70957c4e77512a6f02ec232f14621d7b2f98/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc6d70957c4e77512a6f02ec232f14621d7b2f98/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=dc6d70957c4e77512a6f02ec232f14621d7b2f98", "patch": "@@ -1761,21 +1761,21 @@ while (0)\n #define BLOCK_EMPTY_P(NODE) \\\n   (TREE_CODE (NODE) == BLOCK && BLOCK_EXPR_BODY (NODE) == empty_stmt_node)\n \n-#define BUILD_MONITOR_ENTER(WHERE, ARG)\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n-    (WHERE) = build (CALL_EXPR, int_type_node,\t\t\t\\\n-\t\t     build_address_of (soft_monitorenter_node),\t\\\n-\t\t     build_tree_list (NULL_TREE, (ARG)), \t\\\n-\t\t     NULL_TREE);\t\t\t\t\\\n-    TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\t\\\n+#define BUILD_MONITOR_ENTER(WHERE, ARG)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    (WHERE) = build3 (CALL_EXPR, int_type_node,\t\t\t\t\\\n+\t\t      build_address_of (soft_monitorenter_node),\t\\\n+\t\t      build_tree_list (NULL_TREE, (ARG)),\t \t\\\n+\t\t      NULL_TREE);\t\t\t\t\t\\\n+    TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\t\t\\\n   }\n \n #define BUILD_MONITOR_EXIT(WHERE, ARG)\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n-    (WHERE) = build (CALL_EXPR, int_type_node,\t\t\t\\\n-\t\t     build_address_of (soft_monitorexit_node),\t\\\n-\t\t     build_tree_list (NULL_TREE, (ARG)),\t\\\n-\t\t     NULL_TREE);\t\t\t\t\\\n+    (WHERE) = build3 (CALL_EXPR, int_type_node,\t\t\t\\\n+\t\t      build_address_of (soft_monitorexit_node),\t\\\n+\t\t      build_tree_list (NULL_TREE, (ARG)),\t\\\n+\t\t      NULL_TREE);\t\t\t\t\\\n     TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\t\\\n   }\n "}, {"sha": "c873b855f8e5be87e04a81816aa71c65fb4f9d79", "filename": "gcc/java/parse.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc6d70957c4e77512a6f02ec232f14621d7b2f98/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc6d70957c4e77512a6f02ec232f14621d7b2f98/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=dc6d70957c4e77512a6f02ec232f14621d7b2f98", "patch": "@@ -664,9 +664,9 @@ typedef struct jdeplist_s jdeplist;\n #define BUILD_THROW(WHERE, WHAT)\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n     (WHERE) = \t\t\t\t\t\t\t\\\n-      build (CALL_EXPR, void_type_node,\t\t\t\t\\\n-\t     build_address_of (throw_node),\t\t\t\\\n-\t     build_tree_list (NULL_TREE, (WHAT)), NULL_TREE);\t\\\n+      build3 (CALL_EXPR, void_type_node,\t\t\t\\\n+\t      build_address_of (throw_node),\t\t\t\\\n+\t      build_tree_list (NULL_TREE, (WHAT)), NULL_TREE);\t\\\n     TREE_SIDE_EFFECTS ((WHERE)) = 1;\t\t\t\t\\\n   }\n "}, {"sha": "c251f2f12b705d6b3b845e936933cd235a1997f6", "filename": "gcc/java/parse.y", "status": "modified", "additions": 83, "deletions": 82, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc6d70957c4e77512a6f02ec232f14621d7b2f98/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc6d70957c4e77512a6f02ec232f14621d7b2f98/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=dc6d70957c4e77512a6f02ec232f14621d7b2f98", "patch": "@@ -1585,7 +1585,8 @@ switch_statement:\n switch_expression:\n \tSWITCH_TK OP_TK expression CP_TK\n \t\t{\n-\t\t  $$ = build (SWITCH_EXPR, NULL_TREE, $3, NULL_TREE, NULL_TREE);\n+\t\t  $$ = build3 (SWITCH_EXPR, NULL_TREE, $3,\n+\t\t\t       NULL_TREE, NULL_TREE);\n \t\t  EXPR_WFL_LINECOL ($$) = $2.location;\n \t\t}\n |\tSWITCH_TK error\n@@ -1839,7 +1840,7 @@ assert_statement:\n synchronized_statement:\n \tsynchronized OP_TK expression CP_TK block\n \t\t{\n-\t\t  $$ = build (SYNCHRONIZED_EXPR, NULL_TREE, $3, $5);\n+\t\t  $$ = build2 (SYNCHRONIZED_EXPR, NULL_TREE, $3, $5);\n \t\t  EXPR_WFL_LINECOL ($$) =\n \t\t    EXPR_WFL_LINECOL (MODIFIER_WFL (SYNCHRONIZED_TK));\n \t\t}\n@@ -1911,7 +1912,7 @@ catch_clause_parameter:\n                       ccpb = enter_block ();\n                       init = build_assignment\n                         (ASSIGN_TK, $2.location, TREE_PURPOSE ($3),\n-                         build (JAVA_EXC_OBJ_EXPR, ptr_type_node));\n+                         build0 (JAVA_EXC_OBJ_EXPR, ptr_type_node));\n                       declare_local_variables (0, TREE_VALUE ($3),\n                                                build_tree_list \n \t\t\t\t\t       (TREE_PURPOSE ($3), init));\n@@ -2124,17 +2125,17 @@ array_creation_expression:\n \t\t    obstack_grow (&temporary_obstack, \"[]\", 2);\n \t\t  obstack_1grow (&temporary_obstack, '\\0');\n \t\t  sig = obstack_finish (&temporary_obstack);\n-\t\t  $$ = build (NEW_ANONYMOUS_ARRAY_EXPR, NULL_TREE,\n-\t\t\t      $2, get_identifier (sig), $4);\n+\t\t  $$ = build3 (NEW_ANONYMOUS_ARRAY_EXPR, NULL_TREE,\n+\t\t\t       $2, get_identifier (sig), $4);\n \t\t}\n |\tNEW_TK primitive_type dims array_initializer\n \t\t{\n \t\t  int osb = pop_current_osb (ctxp);\n \t\t  tree type = $2;\n \t\t  while (osb--)\n \t\t    type = build_java_array_type (type, -1);\n-\t\t  $$ = build (NEW_ANONYMOUS_ARRAY_EXPR, NULL_TREE,\n-\t\t\t      build_pointer_type (type), NULL_TREE, $4);\n+\t\t  $$ = build3 (NEW_ANONYMOUS_ARRAY_EXPR, NULL_TREE,\n+\t\t\t       build_pointer_type (type), NULL_TREE, $4);\n \t\t}\n |\tNEW_TK error CSB_TK\n \t\t{yyerror (\"'[' expected\"); DRECOVER (\"]\");}\n@@ -2581,7 +2582,7 @@ conditional_expression:\t\t/* Error handling here is weak */\n \tconditional_or_expression\n |\tconditional_or_expression REL_QM_TK expression REL_CL_TK conditional_expression\n \t\t{\n-\t\t  $$ = build (CONDITIONAL_EXPR, NULL_TREE, $1, $3, $5);\n+\t\t  $$ = build3 (CONDITIONAL_EXPR, NULL_TREE, $1, $3, $5);\n \t\t  EXPR_WFL_LINECOL ($$) = $2.location;\n \t\t}\n |\tconditional_or_expression REL_QM_TK REL_CL_TK error\n@@ -9204,7 +9205,7 @@ static tree\n make_qualified_name (tree left, tree right, int location)\n {\n #ifdef USE_COMPONENT_REF\n-  tree node = build (COMPONENT_REF, NULL_TREE, left, right, NULL_TREE);\n+  tree node = build3 (COMPONENT_REF, NULL_TREE, left, right, NULL_TREE);\n   EXPR_WFL_LINECOL (node) = location;\n   return node;\n #else\n@@ -9591,8 +9592,8 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t     forcoming function's argument. */\n \t  if (previous_call_static && is_static)\n \t    {\n-\t      decl = build (COMPOUND_EXPR, TREE_TYPE (*where_found),\n-\t\t\t    decl, *where_found);\n+\t      decl = build2 (COMPOUND_EXPR, TREE_TYPE (*where_found),\n+\t\t\t     decl, *where_found);\n \t      TREE_SIDE_EFFECTS (decl) = 1;\n \t    }\n \t  else\n@@ -10595,8 +10596,8 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n \t initialization statement and build a compound statement along\n \t with the super constructor invocation. */\n       CAN_COMPLETE_NORMALLY (patch) = 1;\n-      patch = build (COMPOUND_EXPR, void_type_node, patch,\n-\t\t     java_complete_tree (finit_call));\n+      patch = build2 (COMPOUND_EXPR, void_type_node, patch,\n+\t\t      java_complete_tree (finit_call));\n     }\n   return patch;\n }\n@@ -10797,16 +10798,16 @@ patch_invoke (tree patch, tree method, tree args)\n       alloc_node =\n \t(class_has_finalize_method (class) ? alloc_object_node\n \t\t  \t\t\t   : alloc_no_finalizer_node);\n-      new = build (CALL_EXPR, promote_type (class),\n-\t\t     build_address_of (alloc_node),\n-\t\t     build_tree_list (NULL_TREE, build_class_ref (class)),\n-\t\t     NULL_TREE);\n+      new = build3 (CALL_EXPR, promote_type (class),\n+\t\t    build_address_of (alloc_node),\n+\t\t    build_tree_list (NULL_TREE, build_class_ref (class)),\n+\t\t    NULL_TREE);\n       saved_new = save_expr (new);\n       c1 = build_tree_list (NULL_TREE, saved_new);\n       TREE_CHAIN (c1) = TREE_OPERAND (original_call, 1);\n       TREE_OPERAND (original_call, 1) = c1;\n       TREE_SET_CODE (original_call, CALL_EXPR);\n-      patch = build (COMPOUND_EXPR, TREE_TYPE (new), patch, saved_new);\n+      patch = build2 (COMPOUND_EXPR, TREE_TYPE (new), patch, saved_new);\n     }\n \n   /* If CHECK is set, then we are building a check to see if the object\n@@ -10816,8 +10817,8 @@ patch_invoke (tree patch, tree method, tree args)\n       /* We have to call force_evaluation_order now because creating a\n  \t COMPOUND_EXPR wraps the arg list in a way that makes it\n  \t unrecognizable by force_evaluation_order later.  Yuk.  */\n-      patch = build (COMPOUND_EXPR, TREE_TYPE (patch), check, \n- \t\t     force_evaluation_order (patch));\n+      patch = build2 (COMPOUND_EXPR, TREE_TYPE (patch), check, \n+\t\t      force_evaluation_order (patch));\n       TREE_SIDE_EFFECTS (patch) = 1;\n     }\n \n@@ -10839,13 +10840,13 @@ patch_invoke (tree patch, tree method, tree args)\n       tree save = force_evaluation_order (patch);\n       tree type = TREE_TYPE (patch);\n \n-      patch = build (COMPOUND_EXPR, type, save, build_java_empty_stmt ());\n+      patch = build2 (COMPOUND_EXPR, type, save, build_java_empty_stmt ());\n       list = tree_cons (method, patch,\n \t\t\tDECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND (fndecl));\n \n       DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND (fndecl) = list;\n \n-      patch = build (COMPOUND_EXPR, type, patch, save);\n+      patch = build2 (COMPOUND_EXPR, type, patch, save);\n     }\n \n   return patch;\n@@ -12355,7 +12356,7 @@ build_this_super_qualified_invocation (int use_this, tree name, tree args,\n static tree\n build_method_invocation (tree name, tree args)\n {\n-  tree call = build (CALL_EXPR, NULL_TREE, name, args, NULL_TREE);\n+  tree call = build3 (CALL_EXPR, NULL_TREE, name, args, NULL_TREE);\n   TREE_SIDE_EFFECTS (call) = 1;\n   EXPR_WFL_LINECOL (call) = EXPR_WFL_LINECOL (name);\n   return call;\n@@ -12366,7 +12367,7 @@ build_method_invocation (tree name, tree args)\n static tree\n build_new_invocation (tree name, tree args)\n {\n-  tree call = build (NEW_CLASS_EXPR, NULL_TREE, name, args, NULL_TREE);\n+  tree call = build3 (NEW_CLASS_EXPR, NULL_TREE, name, args, NULL_TREE);\n   TREE_SIDE_EFFECTS (call) = 1;\n   EXPR_WFL_LINECOL (call) = EXPR_WFL_LINECOL (name);\n   return call;\n@@ -12386,7 +12387,7 @@ build_assignment (int op, int op_location, tree lhs, tree rhs)\n       rhs = build_binop (BINOP_LOOKUP (op), op_location, lhs, rhs);\n       COMPOUND_ASSIGN_P (rhs) = 1;\n     }\n-  assignment = build (MODIFY_EXPR, NULL_TREE, lhs, rhs);\n+  assignment = build2 (MODIFY_EXPR, NULL_TREE, lhs, rhs);\n   TREE_SIDE_EFFECTS (assignment) = 1;\n   EXPR_WFL_LINECOL (assignment) = op_location;\n   return assignment;\n@@ -12640,8 +12641,8 @@ patch_assignment (tree node, tree wfl_op1)\n         base = lvalue;\n \n       index_expr = TREE_OPERAND (base, 1);\n-      TREE_OPERAND (base, 1) = build (COMPOUND_EXPR, TREE_TYPE (index_expr),\n-\t  \t\t\t      store_check, index_expr);\n+      TREE_OPERAND (base, 1) = build2 (COMPOUND_EXPR, TREE_TYPE (index_expr),\n+\t\t\t\t       store_check, index_expr);\n     }\n \n   /* Final locals can be used as case values in switch\n@@ -12682,7 +12683,7 @@ patch_assignment (tree node, tree wfl_op1)\n \t\t\t\t   TREE_TYPE (new_rhs));\n \t    tree block = make_node (BLOCK);\n \t    tree assignment \n-\t      = build (MODIFY_EXPR, TREE_TYPE (new_rhs), tmp, fold (new_rhs));\n+\t      = build2 (MODIFY_EXPR, TREE_TYPE (new_rhs), tmp, fold (new_rhs));\n \t    DECL_CONTEXT (tmp) = current_function_decl;\n \t    TREE_TYPE (block) = TREE_TYPE (new_rhs);\n \t    BLOCK_VARS (block) = tmp;\n@@ -13005,7 +13006,7 @@ valid_method_invocation_conversion_p (tree dest, tree source)\n static tree\n build_binop (enum tree_code op, int op_location, tree op1, tree op2)\n {\n-  tree binop = build (op, NULL_TREE, op1, op2);\n+  tree binop = build2 (op, NULL_TREE, op1, op2);\n   TREE_SIDE_EFFECTS (binop) = 1;\n   /* Store the location of the operator, for better error report. The\n      string of the operator will be rebuild based on the OP value. */\n@@ -13320,11 +13321,11 @@ patch_binop (tree node, tree wfl_op1, tree wfl_op2)\n \n       /* Shift int only up to 0x1f and long up to 0x3f */\n       if (prom_type == int_type_node)\n-\top2 = fold (build (BIT_AND_EXPR, int_type_node, op2,\n-\t\t\t   build_int_2 (0x1f, 0)));\n+\top2 = fold (build2 (BIT_AND_EXPR, int_type_node, op2,\n+\t\t\t    build_int_2 (0x1f, 0)));\n       else\n-\top2 = fold (build (BIT_AND_EXPR, int_type_node, op2,\n-\t\t\t   build_int_2 (0x3f, 0)));\n+\top2 = fold (build2 (BIT_AND_EXPR, int_type_node, op2,\n+\t\t\t    build_int_2 (0x3f, 0)));\n \n       /* The >>> operator is a >> operating on unsigned quantities */\n       if (code == URSHIFT_EXPR && ! flag_emit_class_files)\n@@ -13697,7 +13698,7 @@ build_string_concatenation (tree op1, tree op2)\n   int side_effects = TREE_SIDE_EFFECTS (op1) | TREE_SIDE_EFFECTS (op2);\n \n   if (flag_emit_xref)\n-    return build (PLUS_EXPR, string_type_node, op1, op2);\n+    return build2 (PLUS_EXPR, string_type_node, op1, op2);\n \n   /* Try to do some static optimization */\n   if ((result = string_constant_concatenation (op1, op2)))\n@@ -13843,8 +13844,8 @@ build_incdec (int op_token, int op_location, tree op1, int is_post_p)\n       { PREDECREMENT_EXPR, PREINCREMENT_EXPR, },\n       { POSTDECREMENT_EXPR, POSTINCREMENT_EXPR, },\n     };\n-  tree node = build (lookup [is_post_p][(op_token - DECR_TK)],\n-\t\t     NULL_TREE, op1, NULL_TREE);\n+  tree node = build2 (lookup [is_post_p][(op_token - DECR_TK)],\n+\t\t      NULL_TREE, op1, NULL_TREE);\n   TREE_SIDE_EFFECTS (node) = 1;\n   /* Store the location of the operator, for better error report. The\n      string of the operator will be rebuild based on the OP value. */\n@@ -14034,8 +14035,8 @@ patch_unaryop (tree node, tree wfl_op)\n \t  if (outer_field_flag)\n \t    {\n \t      /* We re-generate an access to the field */\n-\t      value = build (PLUS_EXPR, TREE_TYPE (op),\n-\t\t\t     build_outer_field_access (wfl_op, decl), value);\n+\t      value = build2 (PLUS_EXPR, TREE_TYPE (op),\n+\t\t\t      build_outer_field_access (wfl_op, decl), value);\n \n \t      /* And we patch the original access$() into a write\n                  with plus_op as a rhs */\n@@ -14230,11 +14231,11 @@ patch_cast (tree node, tree wfl_op)\n \t}\n \n       /* The cast requires a run-time check */\n-      return build (CALL_EXPR, promote_type (cast_type),\n-\t\t    build_address_of (soft_checkcast_node),\n-\t\t    tree_cons (NULL_TREE, build_class_ref (cast_type),\n-\t\t\t       build_tree_list (NULL_TREE, op)),\n-\t\t    NULL_TREE);\n+      return build3 (CALL_EXPR, promote_type (cast_type),\n+\t\t     build_address_of (soft_checkcast_node),\n+\t\t     tree_cons (NULL_TREE, build_class_ref (cast_type),\n+\t\t\t\tbuild_tree_list (NULL_TREE, op)),\n+\t\t     NULL_TREE);\n     }\n \n   /* Any other casts are proven incorrect at compile time */\n@@ -14260,7 +14261,8 @@ build_null_of_type (tree type)\n static tree\n build_array_ref (int location, tree array, tree index)\n {\n-  tree node = build (ARRAY_REF, NULL_TREE, array, index, NULL_TREE, NULL_TREE);\n+  tree node = build4 (ARRAY_REF, NULL_TREE, array, index,\n+\t\t      NULL_TREE, NULL_TREE);\n   EXPR_WFL_LINECOL (node) = location;\n   return node;\n }\n@@ -14330,9 +14332,8 @@ patch_array_ref (tree node)\n static tree\n build_newarray_node (tree type, tree dims, int extra_dims)\n {\n-  tree node =\n-    build (NEW_ARRAY_EXPR, NULL_TREE, type, nreverse (dims),\n-\t   build_int_2 (extra_dims, 0));\n+  tree node = build3 (NEW_ARRAY_EXPR, NULL_TREE, type,\n+\t\t      nreverse (dims), build_int_2 (extra_dims, 0));\n   return node;\n }\n \n@@ -14426,12 +14427,13 @@ patch_newarray (tree node)\n \n   /* Can't reuse what's already written in expr.c because it uses the\n      JVM stack representation. Provide a build_multianewarray. FIXME */\n-  return build (CALL_EXPR, array_type,\n-\t\tbuild_address_of (soft_multianewarray_node),\n-\t\ttree_cons (NULL_TREE, build_class_ref (TREE_TYPE (array_type)),\n-\t\t\t   tree_cons (NULL_TREE,\n-\t\t\t\t      build_int_2 (ndims, 0), dims )),\n-\t\tNULL_TREE);\n+  return build3 (CALL_EXPR, array_type,\n+\t\t build_address_of (soft_multianewarray_node),\n+\t\t tree_cons (NULL_TREE,\n+\t\t\t    build_class_ref (TREE_TYPE (array_type)),\n+\t\t\t    tree_cons (NULL_TREE,\n+\t\t\t\t       build_int_2 (ndims, 0), dims )),\n+\t\t NULL_TREE);\n }\n \n /* 10.6 Array initializer.  */\n@@ -14667,7 +14669,7 @@ patch_return (tree node)\n       if ((patched = patch_string (exp)))\n \texp = patched;\n \n-      modify = build (MODIFY_EXPR, NULL_TREE, DECL_RESULT (meth), exp);\n+      modify = build2 (MODIFY_EXPR, NULL_TREE, DECL_RESULT (meth), exp);\n       EXPR_WFL_LINECOL (modify) = EXPR_WFL_LINECOL (node);\n       modify = java_complete_tree (modify);\n \n@@ -14693,7 +14695,7 @@ build_if_else_statement (int location, tree expression, tree if_body,\n   tree node;\n   if (!else_body)\n     else_body = build_java_empty_stmt ();\n-  node = build (COND_EXPR, NULL_TREE, expression, if_body, else_body);\n+  node = build3 (COND_EXPR, NULL_TREE, expression, if_body, else_body);\n   EXPR_WFL_LINECOL (node) = location;\n   node = build_debugable_stmt (location, node);\n   return node;\n@@ -14761,7 +14763,7 @@ build_labeled_block (int location, tree label)\n     }\n \n   label_decl = create_label_decl (label_name);\n-  node = build (LABELED_BLOCK_EXPR, NULL_TREE, label_decl, NULL_TREE);\n+  node = build2 (LABELED_BLOCK_EXPR, NULL_TREE, label_decl, NULL_TREE);\n   EXPR_WFL_LINECOL (node) = location;\n   TREE_SIDE_EFFECTS (node) = 1;\n   return node;\n@@ -14788,7 +14790,7 @@ finish_labeled_statement (tree lbe, /* Labeled block expr */\n static tree\n build_new_loop (tree loop_body)\n {\n-  tree loop =  build (LOOP_EXPR, NULL_TREE, loop_body);\n+  tree loop = build1 (LOOP_EXPR, NULL_TREE, loop_body);\n   TREE_SIDE_EFFECTS (loop) = 1;\n   PUSH_LOOP (loop);\n   return loop;\n@@ -14819,18 +14821,17 @@ build_loop_body (int location, tree condition, int reversed)\n {\n   tree first, second, body;\n \n-  condition = build (EXIT_EXPR, NULL_TREE, condition); /* Force walk */\n+  condition = build1 (EXIT_EXPR, NULL_TREE, condition); /* Force walk */\n   EXPR_WFL_LINECOL (condition) = location; /* For accurate error report */\n   condition = build_debugable_stmt (location, condition);\n   TREE_SIDE_EFFECTS (condition) = 1;\n \n   body = build_labeled_block (0, continue_identifier_node);\n   first = (reversed ? body : condition);\n   second = (reversed ? condition : body);\n-  return\n-    build (COMPOUND_EXPR, NULL_TREE,\n-\t   build (COMPOUND_EXPR, NULL_TREE, first, second),\n-\t\t  build_java_empty_stmt ());\n+  return build2 (COMPOUND_EXPR, NULL_TREE,\n+\t\t build2 (COMPOUND_EXPR, NULL_TREE, first, second),\n+\t\t build_java_empty_stmt ());\n }\n \n /* Install CONDITION (if any) and loop BODY (using REVERSED to tell\n@@ -14978,8 +14979,8 @@ build_bc_statement (int location, int is_break, tree name)\n     }\n   /* Unlabeled break/continue will be handled during the\n      break/continue patch operation */\n-  break_continue\n-    = build (EXIT_BLOCK_EXPR, NULL_TREE, label_block_expr, NULL_TREE);\n+  break_continue = build2 (EXIT_BLOCK_EXPR, NULL_TREE,\n+\t\t\t   label_block_expr, NULL_TREE);\n \n   IS_BREAK_STMT_P (break_continue) = is_break;\n   TREE_SIDE_EFFECTS (break_continue) = 1;\n@@ -15186,8 +15187,8 @@ build_assertion (int location, tree condition, tree value)\n \n   if (! enable_assertions (klass))\n     {\n-      condition = build (TRUTH_ANDIF_EXPR, NULL_TREE,\n-\t\t\t boolean_false_node, condition);\n+      condition = build2 (TRUTH_ANDIF_EXPR, NULL_TREE,\n+\t\t\t  boolean_false_node, condition);\n       if (value == NULL_TREE)\n \tvalue = build_java_empty_stmt ();\n       return build_if_else_statement (location, condition,\n@@ -15210,7 +15211,7 @@ build_assertion (int location, tree condition, tree value)\n \n       /* Call CLASS.desiredAssertionStatus().  */\n       id = build_wfl_node (get_identifier (\"desiredAssertionStatus\"));\n-      call = build (CALL_EXPR, NULL_TREE, id, NULL_TREE, NULL_TREE);\n+      call = build3 (CALL_EXPR, NULL_TREE, id, NULL_TREE, NULL_TREE);\n       call = make_qualified_primary (classdollar, call, location);\n       TREE_SIDE_EFFECTS (call) = 1;\n \n@@ -15222,7 +15223,7 @@ build_assertion (int location, tree condition, tree value)\n       DECL_INITIAL (field) = call;\n \n       /* Record the initializer in the initializer statement list.  */\n-      call = build (MODIFY_EXPR, NULL_TREE, field, call);\n+      call = build2 (MODIFY_EXPR, NULL_TREE, field, call);\n       TREE_CHAIN (call) = CPC_STATIC_INITIALIZER_STMT (ctxp);\n       SET_CPC_STATIC_INITIALIZER_STMT (ctxp, call);\n       MODIFY_EXPR_FROM_INITIALIZATION_P (call) = 1;\n@@ -15239,7 +15240,7 @@ build_assertion (int location, tree condition, tree value)\n   node = make_qualified_name (node, build_wfl_node (get_identifier (\"AssertionError\")),\n \t\t\t      location);\n \n-  node = build (NEW_CLASS_EXPR, NULL_TREE, node, value, NULL_TREE);\n+  node = build3 (NEW_CLASS_EXPR, NULL_TREE, node, value, NULL_TREE);\n   TREE_SIDE_EFFECTS (node) = 1;\n   /* It is too early to use BUILD_THROW.  */\n   node = build1 (THROW_EXPR, NULL_TREE, node);\n@@ -15250,10 +15251,10 @@ build_assertion (int location, tree condition, tree value)\n   condition = build1 (TRUTH_NOT_EXPR, NULL_TREE, condition);\n   /* Check $assertionsDisabled.  */\n   condition\n-    = build (TRUTH_ANDIF_EXPR, NULL_TREE,\n-\t     build1 (TRUTH_NOT_EXPR, NULL_TREE,\n-\t\t     build_wfl_node (get_identifier (\"$assertionsDisabled\"))),\n-\t     condition);\n+    = build2 (TRUTH_ANDIF_EXPR, NULL_TREE,\n+\t      build1 (TRUTH_NOT_EXPR, NULL_TREE,\n+\t\t      build_wfl_node (get_identifier (\"$assertionsDisabled\"))),\n+\t      condition);\n   node = build_if_else_statement (location, condition, node, NULL_TREE);\n   return node;\n }\n@@ -15291,8 +15292,8 @@ encapsulate_with_try_catch (int location, tree type_or_name, tree try_stmts,\n   catch_block = build_expr_block (NULL_TREE, catch_clause_param);\n \n   /* Initialize the variable and store in the block */\n-  catch = build (MODIFY_EXPR, NULL_TREE, catch_clause_param,\n-\t\t build (JAVA_EXC_OBJ_EXPR, ptr_type_node));\n+  catch = build2 (MODIFY_EXPR, NULL_TREE, catch_clause_param,\n+\t\t  build0 (JAVA_EXC_OBJ_EXPR, ptr_type_node));\n   add_stmt_to_block (catch_block, NULL_TREE, catch);\n \n   /* Add the catch statements */\n@@ -15307,15 +15308,15 @@ encapsulate_with_try_catch (int location, tree type_or_name, tree try_stmts,\n static tree\n build_try_statement (int location, tree try_block, tree catches)\n {\n-  tree node = build (TRY_EXPR, NULL_TREE, try_block, catches);\n+  tree node = build2 (TRY_EXPR, NULL_TREE, try_block, catches);\n   EXPR_WFL_LINECOL (node) = location;\n   return node;\n }\n \n static tree\n build_try_finally_statement (int location, tree try_block, tree finally)\n {\n-  tree node = build (TRY_FINALLY_EXPR, NULL_TREE, try_block, finally);\n+  tree node = build2 (TRY_FINALLY_EXPR, NULL_TREE, try_block, finally);\n   EXPR_WFL_LINECOL (node) = location;\n   return node;\n }\n@@ -15488,11 +15489,11 @@ patch_synchronized_statement (tree node, tree wfl_op1)\n   BUILD_MONITOR_EXIT (exit, expr_decl);\n   CAN_COMPLETE_NORMALLY (enter) = 1;\n   CAN_COMPLETE_NORMALLY (exit) = 1;\n-  assignment = build (MODIFY_EXPR, NULL_TREE, expr_decl, expr);\n+  assignment = build2 (MODIFY_EXPR, NULL_TREE, expr_decl, expr);\n   TREE_SIDE_EFFECTS (assignment) = 1;\n-  node = build (COMPOUND_EXPR, NULL_TREE,\n-\t\tbuild (COMPOUND_EXPR, NULL_TREE, assignment, enter),\n-\t\tbuild (TRY_FINALLY_EXPR, NULL_TREE, block, exit));\n+  node = build2 (COMPOUND_EXPR, NULL_TREE,\n+\t\t build2 (COMPOUND_EXPR, NULL_TREE, assignment, enter),\n+\t\t build2 (TRY_FINALLY_EXPR, NULL_TREE, block, exit));\n   node = build_expr_block (node, expr_decl);\n \n   return java_complete_tree (node);\n@@ -16097,7 +16098,7 @@ emit_test_initialization (void **entry_p, void *info)\n \n   /* Now simply augment the compound that holds all the assignments\n      pertaining to this method invocation. */\n-  init = build (MODIFY_EXPR, boolean_type_node, decl, boolean_true_node);\n+  init = build2 (MODIFY_EXPR, boolean_type_node, decl, boolean_true_node);\n   TREE_SIDE_EFFECTS (init) = 1;\n   TREE_VALUE (l) = add_stmt_to_compound (TREE_VALUE (l), void_type_node, init);\n   TREE_SIDE_EFFECTS (TREE_VALUE (l)) = 1;"}]}