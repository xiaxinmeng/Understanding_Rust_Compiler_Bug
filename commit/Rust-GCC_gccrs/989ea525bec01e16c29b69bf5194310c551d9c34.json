{"sha": "989ea525bec01e16c29b69bf5194310c551d9c34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg5ZWE1MjViZWMwMWUxNmMyOWI2OWJmNTE5NDMxMGM1NTFkOWMzNA==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-07-05T12:46:52Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-07-05T12:46:52Z"}, "message": "vec.h (VEC_splice, [...]): New macros.\n\ngcc/\n\t* vec.h (VEC_splice, VEC_safe_splice): New macros.  Add function\n\timplementations.\n\ngcc/fortran/\n\t* trans.h (gfc_conv_procedure_call): Take a VEC instead of a tree.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_funcall): Adjust for new\n\ttype of gfc_conv_procedure_call.\n\t(conv_generic_with_optional_char_arg): Likewise.\n\t* trans-stmt.c (gfc_trans_call): Likewise.\n\t* trans-expr.c (gfc_conv_function_expr): Likewise.\n\t(gfc_conv_procedure_call): Use build_call_vec instead of\n\tbuild_call_list.\n\nFrom-SVN: r161834", "tree": {"sha": "5666dfc48fb2cc1c04e55452418033ee9e2438bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5666dfc48fb2cc1c04e55452418033ee9e2438bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/989ea525bec01e16c29b69bf5194310c551d9c34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/989ea525bec01e16c29b69bf5194310c551d9c34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/989ea525bec01e16c29b69bf5194310c551d9c34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/989ea525bec01e16c29b69bf5194310c551d9c34/comments", "author": null, "committer": null, "parents": [{"sha": "7ec6356e22e1644f3fee6314790b2680098778de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ec6356e22e1644f3fee6314790b2680098778de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ec6356e22e1644f3fee6314790b2680098778de"}], "stats": {"total": 198, "additions": 155, "deletions": 43}, "files": [{"sha": "23d71ec8b9ee396839816deb17a2fa5067b44adf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/989ea525bec01e16c29b69bf5194310c551d9c34/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/989ea525bec01e16c29b69bf5194310c551d9c34/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=989ea525bec01e16c29b69bf5194310c551d9c34", "patch": "@@ -1,3 +1,8 @@\n+2010-07-05  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* vec.h (VEC_splice, VEC_safe_splice): New macros.  Add function\n+\timplementations.\n+\n 2010-07-05  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* config/arm/arm.c (get_arm_condition_code): Remove CC_NOTBmode case."}, {"sha": "3530c8f332673f7794ff2693d3538be80d34698c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/989ea525bec01e16c29b69bf5194310c551d9c34/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/989ea525bec01e16c29b69bf5194310c551d9c34/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=989ea525bec01e16c29b69bf5194310c551d9c34", "patch": "@@ -1,3 +1,14 @@\n+2010-07-05  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* trans.h (gfc_conv_procedure_call): Take a VEC instead of a tree.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_funcall): Adjust for new\n+\ttype of gfc_conv_procedure_call.\n+\t(conv_generic_with_optional_char_arg): Likewise.\n+\t* trans-stmt.c (gfc_trans_call): Likewise.\n+\t* trans-expr.c (gfc_conv_function_expr): Likewise.\n+\t(gfc_conv_procedure_call): Use build_call_vec instead of\n+\tbuild_call_list.\n+\n 2010-07-04  Daniel Kraft  <d@domob.eu>\n \n \t* gfc-internals.texi (gfc_code): Document BLOCK and ASSOCIATE."}, {"sha": "1a7a4a1e4e2e69bd133eec8cde8b6c28d05a024c", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/989ea525bec01e16c29b69bf5194310c551d9c34/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/989ea525bec01e16c29b69bf5194310c551d9c34/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=989ea525bec01e16c29b69bf5194310c551d9c34", "patch": "@@ -2653,7 +2653,6 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n   return 0;\n }\n \n-\n /* Generate code for a procedure call.  Note can return se->post != NULL.\n    If se->direct_byref is set then se->expr contains the return parameter.\n    Return nonzero, if the call has alternate specifiers.\n@@ -2662,11 +2661,11 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n int\n gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t gfc_actual_arglist * arg, gfc_expr * expr,\n-\t\t\t tree append_args)\n+\t\t\t VEC(tree,gc) *append_args)\n {\n   gfc_interface_mapping mapping;\n-  tree arglist;\n-  tree retargs;\n+  VEC(tree,gc) *arglist;\n+  VEC(tree,gc) *retargs;\n   tree tmp;\n   tree fntype;\n   gfc_se parmse;\n@@ -2677,7 +2676,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   tree type;\n   tree var;\n   tree len;\n-  tree stringargs;\n+  VEC(tree,gc) *stringargs;\n   tree result = NULL;\n   gfc_formal_arglist *formal;\n   int has_alternate_specifier = 0;\n@@ -2690,10 +2689,11 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   stmtblock_t post;\n   enum {MISSING = 0, ELEMENTAL, SCALAR, SCALAR_POINTER, ARRAY};\n   gfc_component *comp = NULL;\n+  int arglen;\n \n-  arglist = NULL_TREE;\n-  retargs = NULL_TREE;\n-  stringargs = NULL_TREE;\n+  arglist = NULL;\n+  retargs = NULL;\n+  stringargs = NULL;\n   var = NULL_TREE;\n   len = NULL_TREE;\n   gfc_clear_ts (&ts);\n@@ -3136,9 +3136,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       /* Character strings are passed as two parameters, a length and a\n          pointer - except for Bind(c) which only passes the pointer.  */\n       if (parmse.string_length != NULL_TREE && !sym->attr.is_bind_c)\n-        stringargs = gfc_chainon_list (stringargs, parmse.string_length);\n+\tVEC_safe_push (tree, gc, stringargs, parmse.string_length);\n \n-      arglist = gfc_chainon_list (arglist, parmse.expr);\n+      VEC_safe_push (tree, gc, arglist, parmse.expr);\n     }\n   gfc_finish_interface_mapping (&mapping, &se->pre, &se->post);\n \n@@ -3160,7 +3160,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t     For dummies, we have to look through the formal argument list for\n \t     this function and use the character length found there.*/\n \t  if (!sym->attr.dummy)\n-\t    cl.backend_decl = TREE_VALUE (stringargs);\n+\t    cl.backend_decl = VEC_index (tree, stringargs, 0);\n \t  else\n \t    {\n \t      formal = sym->ns->proc_name->formal;\n@@ -3213,7 +3213,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t  result = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\tse->expr);\n-\t  retargs = gfc_chainon_list (retargs, se->expr);\n+\t  VEC_safe_push (tree, gc, retargs, se->expr);\n \t}\n       else if (comp && comp->attr.dimension)\n \t{\n@@ -3237,7 +3237,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  /* Pass the temporary as the first argument.  */\n \t  result = info->descriptor;\n \t  tmp = gfc_build_addr_expr (NULL_TREE, result);\n-\t  retargs = gfc_chainon_list (retargs, tmp);\n+\t  VEC_safe_push (tree, gc, retargs, tmp);\n \t}\n       else if (!comp && sym->result->attr.dimension)\n \t{\n@@ -3261,7 +3261,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  /* Pass the temporary as the first argument.  */\n \t  result = info->descriptor;\n \t  tmp = gfc_build_addr_expr (NULL_TREE, result);\n-\t  retargs = gfc_chainon_list (retargs, tmp);\n+\t  VEC_safe_push (tree, gc, retargs, tmp);\n \t}\n       else if (ts.type == BT_CHARACTER)\n \t{\n@@ -3288,33 +3288,39 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  else\n \t    var = gfc_conv_string_tmp (se, type, len);\n \n-\t  retargs = gfc_chainon_list (retargs, var);\n+\t  VEC_safe_push (tree, gc, retargs, var);\n \t}\n       else\n \t{\n \t  gcc_assert (gfc_option.flag_f2c && ts.type == BT_COMPLEX);\n \n \t  type = gfc_get_complex_type (ts.kind);\n \t  var = gfc_build_addr_expr (NULL_TREE, gfc_create_var (type, \"cmplx\"));\n-\t  retargs = gfc_chainon_list (retargs, var);\n+\t  VEC_safe_push (tree, gc, retargs, var);\n \t}\n \n       /* Add the string length to the argument list.  */\n       if (ts.type == BT_CHARACTER)\n-\tretargs = gfc_chainon_list (retargs, len);\n+\tVEC_safe_push (tree, gc, retargs, len);\n     }\n   gfc_free_interface_mapping (&mapping);\n \n+  /* We need to glom RETARGS + ARGLIST + STRINGARGS + APPEND_ARGS.  */\n+  arglen = (VEC_length (tree, arglist)\n+\t    + VEC_length (tree, stringargs) + VEC_length (tree, append_args));\n+  VEC_reserve_exact (tree, gc, retargs, arglen);\n+\n   /* Add the return arguments.  */\n-  arglist = chainon (retargs, arglist);\n+  VEC_splice (tree, retargs, arglist);\n \n   /* Add the hidden string length parameters to the arguments.  */\n-  arglist = chainon (arglist, stringargs);\n+  VEC_splice (tree, retargs, stringargs);\n \n   /* We may want to append extra arguments here.  This is used e.g. for\n      calls to libgfortran_matmul_??, which need extra information.  */\n-  if (append_args != NULL_TREE)\n-    arglist = chainon (arglist, append_args);\n+  if (!VEC_empty (tree, append_args))\n+    VEC_splice (tree, retargs, append_args);\n+  arglist = retargs;\n \n   /* Generate the actual call.  */\n   conv_function_val (se, sym, expr);\n@@ -3338,7 +3344,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n     }\n \n   fntype = TREE_TYPE (TREE_TYPE (se->expr));\n-  se->expr = build_call_list (TREE_TYPE (fntype), se->expr, arglist);\n+  se->expr = build_call_vec (TREE_TYPE (fntype), se->expr, arglist);\n \n   /* If we have a pointer function, but we don't want a pointer, e.g.\n      something like\n@@ -3786,8 +3792,7 @@ gfc_conv_function_expr (gfc_se * se, gfc_expr * expr)\n   if (!sym)\n     sym = expr->symtree->n.sym;\n \n-  gfc_conv_procedure_call (se, sym, expr->value.function.actual, expr,\n-\t\t\t  NULL_TREE);\n+  gfc_conv_procedure_call (se, sym, expr->value.function.actual, expr, NULL);\n }\n \n "}, {"sha": "7f583dabe4461487e053ce0409a1ddabec244d1b", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/989ea525bec01e16c29b69bf5194310c551d9c34/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/989ea525bec01e16c29b69bf5194310c551d9c34/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=989ea525bec01e16c29b69bf5194310c551d9c34", "patch": "@@ -1570,7 +1570,7 @@ static void\n gfc_conv_intrinsic_funcall (gfc_se * se, gfc_expr * expr)\n {\n   gfc_symbol *sym;\n-  tree append_args;\n+  VEC(tree,gc) *append_args;\n \n   gcc_assert (!se->ss || se->ss->expr == expr);\n \n@@ -1583,7 +1583,7 @@ gfc_conv_intrinsic_funcall (gfc_se * se, gfc_expr * expr)\n \n   /* Calls to libgfortran_matmul need to be appended special arguments,\n      to be able to call the BLAS ?gemm functions if required and possible.  */\n-  append_args = NULL_TREE;\n+  append_args = NULL;\n   if (expr->value.function.isym->id == GFC_ISYM_MATMUL\n       && sym->ts.type != BT_LOGICAL)\n     {\n@@ -1611,19 +1611,19 @@ gfc_conv_intrinsic_funcall (gfc_se * se, gfc_expr * expr)\n \t\tgemm_fndecl = gfor_fndecl_zgemm;\n \t    }\n \n-\t  append_args = gfc_chainon_list (NULL_TREE, build_int_cst (cint, 1));\n-\t  append_args = gfc_chainon_list\n-\t\t\t  (append_args, build_int_cst\n-\t\t\t\t\t  (cint, gfc_option.blas_matmul_limit));\n-\t  append_args = gfc_chainon_list (append_args,\n-\t\t\t\t\t  gfc_build_addr_expr (NULL_TREE,\n-\t\t\t\t\t\t\t       gemm_fndecl));\n+\t  append_args = VEC_alloc (tree, gc, 3);\n+\t  VEC_quick_push (tree, append_args, build_int_cst (cint, 1));\n+\t  VEC_quick_push (tree, append_args,\n+\t\t\t  build_int_cst (cint, gfc_option.blas_matmul_limit));\n+\t  VEC_quick_push (tree, append_args,\n+\t\t\t  gfc_build_addr_expr (NULL_TREE, gemm_fndecl));\n \t}\n       else\n \t{\n-\t  append_args = gfc_chainon_list (NULL_TREE, build_int_cst (cint, 0));\n-\t  append_args = gfc_chainon_list (append_args, build_int_cst (cint, 0));\n-\t  append_args = gfc_chainon_list (append_args, null_pointer_node);\n+\t  append_args = VEC_alloc (tree, gc, 3);\n+\t  VEC_quick_push (tree, append_args, build_int_cst (cint, 0));\n+\t  VEC_quick_push (tree, append_args, build_int_cst (cint, 0));\n+\t  VEC_quick_push (tree, append_args, null_pointer_node);\n \t}\n     }\n \n@@ -3285,7 +3285,7 @@ conv_generic_with_optional_char_arg (gfc_se* se, gfc_expr* expr,\n   unsigned cur_pos;\n   gfc_actual_arglist* arg;\n   gfc_symbol* sym;\n-  tree append_args;\n+  VEC(tree,gc) *append_args;\n \n   /* Find the two arguments given as position.  */\n   cur_pos = 0;\n@@ -3309,13 +3309,14 @@ conv_generic_with_optional_char_arg (gfc_se* se, gfc_expr* expr,\n \n   /* If we do have type CHARACTER and the optional argument is really absent,\n      append a dummy 0 as string length.  */\n-  append_args = NULL_TREE;\n+  append_args = NULL;\n   if (prim_arg->expr->ts.type == BT_CHARACTER && !opt_arg->expr)\n     {\n       tree dummy;\n \n       dummy = build_int_cst (gfc_charlen_type_node, 0);\n-      append_args = gfc_chainon_list (append_args, dummy);\n+      append_args = VEC_alloc (tree, gc, 1);\n+      VEC_quick_push (tree, append_args, dummy);\n     }\n \n   /* Build the call itself.  */"}, {"sha": "beada6a718d42b3366faed85b28e7af096f57a58", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/989ea525bec01e16c29b69bf5194310c551d9c34/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/989ea525bec01e16c29b69bf5194310c551d9c34/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=989ea525bec01e16c29b69bf5194310c551d9c34", "patch": "@@ -373,7 +373,7 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n       /* Translate the call.  */\n       has_alternate_specifier\n \t= gfc_conv_procedure_call (&se, code->resolved_sym, code->ext.actual,\n-\t\t\t\t  code->expr1, NULL_TREE);\n+\t\t\t\t  code->expr1, NULL);\n \n       /* A subroutine without side-effect, by definition, does nothing!  */\n       TREE_SIDE_EFFECTS (se.expr) = 1;\n@@ -457,8 +457,7 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n \n       /* Add the subroutine call to the block.  */\n       gfc_conv_procedure_call (&loopse, code->resolved_sym,\n-\t\t\t       code->ext.actual, code->expr1,\n-\t\t\t       NULL_TREE);\n+\t\t\t       code->ext.actual, code->expr1, NULL);\n \n       if (mask && count1)\n \t{"}, {"sha": "fa2d583173aa55f8f32d51ccc813a988b9d2806c", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/989ea525bec01e16c29b69bf5194310c551d9c34/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/989ea525bec01e16c29b69bf5194310c551d9c34/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=989ea525bec01e16c29b69bf5194310c551d9c34", "patch": "@@ -314,7 +314,7 @@ int gfc_is_intrinsic_libcall (gfc_expr *);\n /* Used to call ordinary functions/subroutines\n    and procedure pointer components.  */\n int gfc_conv_procedure_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *,\n-\t\t\t    gfc_expr *, tree);\n+\t\t\t     gfc_expr *, VEC(tree,gc) *);\n \n void gfc_conv_subref_array_arg (gfc_se *, gfc_expr *, int, sym_intent, bool);\n "}, {"sha": "e6c42bc0a609b00a52c19873e0ae5aef81ff0413", "filename": "gcc/vec.h", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/989ea525bec01e16c29b69bf5194310c551d9c34/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/989ea525bec01e16c29b69bf5194310c551d9c34/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=989ea525bec01e16c29b69bf5194310c551d9c34", "patch": "@@ -259,6 +259,32 @@ along with GCC; see the file COPYING3.  If not see\n #define VEC_reserve_exact(T,A,V,R)\t\\\n \t(VEC_OP(T,A,reserve_exact)(&(V),R VEC_CHECK_INFO MEM_STAT_INFO))\n \n+/* Copy elements with no reallocation\n+   void VEC_T_splice (VEC(T) *dst, VEC(T) *src); // Integer\n+   void VEC_T_splice (VEC(T) *dst, VEC(T) *src); // Pointer\n+   void VEC_T_splice (VEC(T) *dst, VEC(T) *src); // Object\n+\n+   Copy the elements in SRC to the end of DST as if by memcpy.  DST and\n+   SRC need not be allocated with the same mechanism, although they most\n+   often will be.  DST is assumed to have sufficient headroom\n+   available.  */\n+\n+#define VEC_splice(T,DST,SRC)\t\t\t\\\n+  (VEC_OP(T,base,splice)(VEC_BASE(DST), VEC_BASE(SRC) VEC_CHECK_INFO))\n+\n+/* Copy elements with reallocation\n+   void VEC_T_safe_splice (VEC(T,A) *&dst, VEC(T) *src); // Integer\n+   void VEC_T_safe_splice (VEC(T,A) *&dst, VEC(T) *src); // Pointer\n+   void VEC_T_safe_splice (VEC(T,A) *&dst, VEC(T) *src); // Object\n+\n+   Copy the elements in SRC to the end of DST as if by memcpy.  DST and\n+   SRC need not be allocated with the same mechanism, although they most\n+   often will be.  DST need not have sufficient headroom and will be\n+   reallocated if needed.  */\n+\n+#define VEC_safe_splice(T,A,DST,SRC)\t\t\t\t\t\\\n+  (VEC_OP(T,A,safe_splice)(&(DST), VEC_BASE(SRC) VEC_CHECK_INFO MEM_STAT_INFO))\n+  \n /* Push object with no reallocation\n    T *VEC_T_quick_push (VEC(T) *v, T obj); // Integer\n    T *VEC_T_quick_push (VEC(T) *v, T obj); // Pointer\n@@ -589,6 +615,19 @@ static inline int VEC_OP (T,base,space)\t       \t\t\t\t  \\\n   return vec_ ? vec_->alloc - vec_->num >= (unsigned)alloc_ : !alloc_;\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP(T,base,splice)\t\t\t\t  \\\n+     (VEC(T,base) *dst_, VEC(T,base) *src_ VEC_CHECK_DECL)\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  if (src_)\t\t\t\t\t\t\t\t  \\\n+    {\t\t\t\t\t\t\t\t\t  \\\n+      unsigned len_ = src_->num;\t\t\t\t\t  \\\n+      VEC_ASSERT (dst_->num + len_ <= dst_->alloc, \"splice\", T, base);\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+      memcpy (&dst_->vec[dst_->num], &src_->vec[0], len_ * sizeof (T));\t  \\\n+      dst_->num += len_;\t\t\t\t\t\t  \\\n+    }\t\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n static inline T *VEC_OP (T,base,quick_push)\t\t\t\t  \\\n      (VEC(T,base) *vec_, T obj_ VEC_CHECK_DECL)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n@@ -796,6 +835,19 @@ static inline void VEC_OP (T,A,safe_grow_cleared)\t\t\t  \\\n \t  sizeof (T) * (size_ - oldsize));\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP(T,A,safe_splice)\t\t\t\t  \\\n+     (VEC(T,A) **dst_, VEC(T,base) *src_ VEC_CHECK_DECL MEM_STAT_DECL)\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  if (src_)\t\t\t\t\t\t\t\t  \\\n+    {\t\t\t\t\t\t\t\t\t  \\\n+      VEC_OP (T,A,reserve_exact) (dst_, src_->num\t\t\t  \\\n+\t\t\t\t  VEC_CHECK_PASS MEM_STAT_INFO);\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+      VEC_OP (T,base,splice) (VEC_BASE (*dst_), src_\t\t\t  \\\n+\t\t\t      VEC_CHECK_PASS);\t\t\t\t  \\\n+    }\t\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n static inline T *VEC_OP (T,A,safe_push)\t\t\t\t\t  \\\n      (VEC(T,A) **vec_, T obj_ VEC_CHECK_DECL MEM_STAT_DECL)       \t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n@@ -881,6 +933,19 @@ static inline int VEC_OP (T,base,space)\t       \t\t\t\t  \\\n   return vec_ ? vec_->alloc - vec_->num >= (unsigned)alloc_ : !alloc_;\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP(T,base,splice)\t\t\t\t  \\\n+     (VEC(T,base) *dst_, VEC(T,base) *src_ VEC_CHECK_DECL)\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  if (src_)\t\t\t\t\t\t\t\t  \\\n+    {\t\t\t\t\t\t\t\t\t  \\\n+      unsigned len_ = src_->num;\t\t\t\t\t  \\\n+      VEC_ASSERT (dst_->num + len_ <= dst_->alloc, \"splice\", T, base);\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+      memcpy (&dst_->vec[dst_->num], &src_->vec[0], len_ * sizeof (T));\t  \\\n+      dst_->num += len_;\t\t\t\t\t\t  \\\n+    }\t\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n static inline T *VEC_OP (T,base,quick_push)\t\t\t\t  \\\n      (VEC(T,base) *vec_, const T *obj_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n@@ -1084,6 +1149,19 @@ static inline void VEC_OP (T,A,safe_grow_cleared)\t\t\t  \\\n \t  sizeof (T) * (size_ - oldsize));\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP(T,A,safe_splice)\t\t\t\t  \\\n+     (VEC(T,A) **dst_, VEC(T,base) *src_ VEC_CHECK_DECL MEM_STAT_DECL)\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  if (src_)\t\t\t\t\t\t\t\t  \\\n+    {\t\t\t\t\t\t\t\t\t  \\\n+      VEC_OP (T,A,reserve_exact) (dst_, src_->num\t\t\t  \\\n+\t\t\t\t  VEC_CHECK_PASS MEM_STAT_INFO);\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+      VEC_OP (T,base,splice) (VEC_BASE (*dst_), src_\t\t\t  \\\n+\t\t\t      VEC_CHECK_PASS);\t\t\t\t  \\\n+    }\t\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n static inline T *VEC_OP (T,A,safe_push)\t\t\t\t\t  \\\n      (VEC(T,A) **vec_, const T *obj_ VEC_CHECK_DECL MEM_STAT_DECL)\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n@@ -1188,6 +1266,19 @@ static inline void VEC_OP (T,A,safe_grow_cleared)\t\t\t  \\\n \t  sizeof (T) * (size_ - oldsize));\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP(T,A,safe_splice)\t\t\t\t  \\\n+     (VEC(T,A) **dst_, VEC(T,base) *src_ VEC_CHECK_DECL MEM_STAT_DECL)\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  if (src_)\t\t\t\t\t\t\t\t  \\\n+    {\t\t\t\t\t\t\t\t\t  \\\n+      VEC_OP (T,A,reserve_exact) (dst_, src_->num\t\t\t  \\\n+\t\t\t\t  VEC_CHECK_PASS MEM_STAT_INFO);\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+      VEC_OP (T,base,splice) (VEC_BASE (*dst_), src_\t\t\t  \\\n+\t\t\t      VEC_CHECK_PASS);\t\t\t\t  \\\n+    }\t\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n static inline T *VEC_OP (T,A,safe_push)\t\t\t\t\t  \\\n      (VEC(T,A) **vec_, const T obj_ VEC_CHECK_DECL MEM_STAT_DECL)\t  \\\n {\t\t\t\t\t\t\t\t\t  \\"}]}