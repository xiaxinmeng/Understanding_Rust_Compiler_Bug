{"sha": "70c947e4dfaa6d63b5efc0d8cd990726a9b6d8ba", "node_id": "C_kwDOANBUbNoAKDcwYzk0N2U0ZGZhYTZkNjNiNWVmYzBkOGNkOTkwNzI2YTliNmQ4YmE", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2021-10-30T09:36:05Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2021-10-30T09:36:05Z"}, "message": "Implied compares in Ada Harded Conditionals documentation\n\nImprove the wording on optimizations that prevent compare hardening,\nso as to also cover cases in which explicit compares get combined into\noperations with implied compares.\n\n\nfor  gcc/ada/ChangeLog\n\n\t* doc/gnat_rm/security_hardening_features.rst: Mention\n\toptimization to operations with implied compares.", "tree": {"sha": "6bc5f0540c374e7ce1d0ad193a4db7677552a31b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bc5f0540c374e7ce1d0ad193a4db7677552a31b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70c947e4dfaa6d63b5efc0d8cd990726a9b6d8ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70c947e4dfaa6d63b5efc0d8cd990726a9b6d8ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70c947e4dfaa6d63b5efc0d8cd990726a9b6d8ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70c947e4dfaa6d63b5efc0d8cd990726a9b6d8ba/comments", "author": null, "committer": null, "parents": [{"sha": "6f449bb93b33d63fa8a1b8d021d8d36f27ffe054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f449bb93b33d63fa8a1b8d021d8d36f27ffe054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f449bb93b33d63fa8a1b8d021d8d36f27ffe054"}], "stats": {"total": 7, "additions": 4, "deletions": 3}, "files": [{"sha": "cf76938d91d1300d193a095817ccb1248edd5339", "filename": "gcc/ada/doc/gnat_rm/security_hardening_features.rst", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70c947e4dfaa6d63b5efc0d8cd990726a9b6d8ba/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70c947e4dfaa6d63b5efc0d8cd990726a9b6d8ba/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst?ref=70c947e4dfaa6d63b5efc0d8cd990726a9b6d8ba", "patch": "@@ -112,14 +112,15 @@ long after boolean expressions are decomposed into separate compares,\n each one turned into either a conditional branch or a compare whose\n result is stored in a boolean variable or temporary.  Compiler\n optimizations, if enabled, may also turn conditional branches into\n-stored compares, and vice-versa.  Conditionals may also be optimized\n+stored compares, and vice-versa, or into operations with implied\n+conditionals (e.g. MIN and MAX).  Conditionals may also be optimized\n out entirely, if their value can be determined at compile time, and\n occasionally multiple compares can be combined into one.\n \n It is thus difficult to predict which of these two options will affect\n a specific compare operation expressed in source code.  Using both\n-options ensures that every compare that is not optimized out will be\n-hardened.\n+options ensures that every compare that is neither optimized out nor\n+optimized into implied conditionals will be hardened.\n \n The addition of reversed compares can be observed by enabling the dump\n files of the corresponding passes, through command line options"}]}