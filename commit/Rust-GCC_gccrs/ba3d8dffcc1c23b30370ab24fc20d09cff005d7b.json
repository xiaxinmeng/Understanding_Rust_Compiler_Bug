{"sha": "ba3d8dffcc1c23b30370ab24fc20d09cff005d7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmEzZDhkZmZjYzFjMjNiMzAzNzBhYjI0ZmMyMGQwOWNmZjAwNWQ3Yg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-02T23:25:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-02T23:40:33Z"}, "message": "c++: Implement LWG3396 Clarify point of reference for source_location::current() [PR80780, PR93093]\n\nWhile std::source_location::current () is static consteval source_location\ncurrent() noexcept; in the standard, it also says with LWG3396:\n\"Any call to current that appears as a default member initializer\n([class.mem]), or as a subexpression thereof, should correspond to the\nlocation of the constructor definition or aggregate initialization that uses\nthe default member initializer.  Any call to current that appears as a\ndefault argument ([dcl.fct.default]), or as a subexpression thereof, should\ncorrespond to the location of the invocation of the function that uses the\ndefault argument ([expr.call]).\"\nso it must work as compiler magic rather than normal immediate functions,\nin particular we need to defer its evaluation when parsing default arguments\nor nsdmis.\n\nThis patch actually defers evaluation of all the calls to\nstd::source_location::current () until genericization (or constant expression\nevaluation when called from constant expression contexts).\nI had to change constexpr.c too so that it temporarily adjusts\ncurrent_function_decl from the constexpr evaluation context, but we do the\nsame already from __builtin_FUNCTION ().\n\n2020-12-03  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/80780\n\tPR c++/93093\n\t* cp-tree.h (source_location_current_p): Declare.\n\t* tree.c (source_location_current_p): New function.\n\t* call.c (immediate_invocation_p): New function.\n\t(build_over_call): Use it to resolve LWG3396.\n\t* constexpr.c (cxx_eval_builtin_function_call): Temporarily set\n\tcurrent_function_decl from ctx->call->fundef->decl if any.\n\t* cp-gimplify.c (cp_genericize_r) <case CALL_EXPR>: Fold calls\n\tto immediate function std::source_location::current ().\n\n\t* g++.dg/cpp2a/srcloc15.C: New test.\n\t* g++.dg/cpp2a/srcloc16.C: New test.\n\t* g++.dg/cpp2a/srcloc17.C: New test.\n\t* g++.dg/cpp2a/srcloc18.C: New test.", "tree": {"sha": "e4ea6a9a8e575d5f90fdc95c71e3e56bb94816cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4ea6a9a8e575d5f90fdc95c71e3e56bb94816cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cace1cd683318e83e8a613f1aa2f2b16e37a342", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cace1cd683318e83e8a613f1aa2f2b16e37a342", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cace1cd683318e83e8a613f1aa2f2b16e37a342"}], "stats": {"total": 515, "additions": 500, "deletions": 15}, "files": [{"sha": "f1e0bcb796b1baf0e9b97c95ef8811b76421b814", "filename": "gcc/cp/call.c", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=ba3d8dffcc1c23b30370ab24fc20d09cff005d7b", "patch": "@@ -8540,6 +8540,25 @@ build_trivial_dtor_call (tree instance, bool no_ptr_deref)\n \t\t instance, clobber);\n }\n \n+/* Return true if a call to FN with number of arguments NARGS\n+   is an immediate invocation.  */\n+\n+static bool\n+immediate_invocation_p (tree fn, int nargs)\n+{\n+  return (TREE_CODE (fn) == FUNCTION_DECL\n+\t  && DECL_IMMEDIATE_FUNCTION_P (fn)\n+\t  && cp_unevaluated_operand == 0\n+\t  && (current_function_decl == NULL_TREE\n+\t      || !DECL_IMMEDIATE_FUNCTION_P (current_function_decl))\n+\t  && (current_binding_level->kind != sk_function_parms\n+\t      || !current_binding_level->immediate_fn_ctx_p)\n+\t  /* As an exception, we defer std::source_location::current ()\n+\t     invocations until genericization because LWG3396 mandates\n+\t     special behavior for it.  */\n+\t  && (nargs > 1 || !source_location_current_p (fn)));\n+}\n+\n /* Subroutine of the various build_*_call functions.  Overload resolution\n    has chosen a winning candidate CAND; build up a CALL_EXPR accordingly.\n    ARGS is a TREE_LIST of the unconverted arguments to the call.  FLAGS is a\n@@ -8607,13 +8626,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t\t\t\t   addr, nargs, argarray);\n       if (TREE_THIS_VOLATILE (fn) && cfun)\n \tcurrent_function_returns_abnormally = 1;\n-      if (TREE_CODE (fn) == FUNCTION_DECL\n-\t  && DECL_IMMEDIATE_FUNCTION_P (fn)\n-\t  && cp_unevaluated_operand == 0\n-\t  && (current_function_decl == NULL_TREE\n-\t      || !DECL_IMMEDIATE_FUNCTION_P (current_function_decl))\n-\t  && (current_binding_level->kind != sk_function_parms\n-\t      || !current_binding_level->immediate_fn_ctx_p))\n+      if (immediate_invocation_p (fn, nargs))\n \t{\n \t  tree obj_arg = NULL_TREE, exprimm = expr;\n \t  if (DECL_CONSTRUCTOR_P (fn))\n@@ -9251,13 +9264,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n   if (TREE_CODE (fn) == ADDR_EXPR)\n     {\n       tree fndecl = STRIP_TEMPLATE (TREE_OPERAND (fn, 0));\n-      if (TREE_CODE (fndecl) == FUNCTION_DECL\n-\t  && DECL_IMMEDIATE_FUNCTION_P (fndecl)\n-\t  && cp_unevaluated_operand == 0\n-\t  && (current_function_decl == NULL_TREE\n-\t      || !DECL_IMMEDIATE_FUNCTION_P (current_function_decl))\n-\t  && (current_binding_level->kind != sk_function_parms\n-\t      || !current_binding_level->immediate_fn_ctx_p))\n+      if (immediate_invocation_p (fndecl, nargs))\n \t{\n \t  tree obj_arg = NULL_TREE;\n \t  if (DECL_CONSTRUCTOR_P (fndecl))"}, {"sha": "cd34e8e7eb4612cb72122498d1086f60efed7310", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=ba3d8dffcc1c23b30370ab24fc20d09cff005d7b", "patch": "@@ -1332,7 +1332,12 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n     }\n \n   if (fndecl_built_in_p (fun, CP_BUILT_IN_SOURCE_LOCATION, BUILT_IN_FRONTEND))\n-    return fold_builtin_source_location (EXPR_LOCATION (t));\n+    {\n+      temp_override<tree> ovr (current_function_decl);\n+      if (ctx->call && ctx->call->fundef)\n+\tcurrent_function_decl = ctx->call->fundef->decl;\n+      return fold_builtin_source_location (EXPR_LOCATION (t));\n+    }\n \n   int strops = 0;\n   int strret = 0;"}, {"sha": "84b8d16e74232a8515f27039f9b024209d36be17", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=ba3d8dffcc1c23b30370ab24fc20d09cff005d7b", "patch": "@@ -1374,6 +1374,14 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t  break;\n \t}\n \n+      if (tree fndecl = cp_get_callee_fndecl (stmt))\n+\tif (DECL_IMMEDIATE_FUNCTION_P (fndecl))\n+\t  {\n+\t    gcc_assert (source_location_current_p (fndecl));\n+\t    *stmt_p = cxx_constant_value (stmt);\n+\t    break;\n+\t  }\n+\n       if (!wtd->no_sanitize_p\n \t  && sanitize_flags_p ((SANITIZE_NULL\n \t\t\t\t| SANITIZE_ALIGNMENT | SANITIZE_VPTR)))"}, {"sha": "d77ec119be40844cde6f3f97bebcba881410ac45", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ba3d8dffcc1c23b30370ab24fc20d09cff005d7b", "patch": "@@ -7478,6 +7478,7 @@ extern tree bind_template_template_parm\t\t(tree, tree);\n extern tree array_type_nelts_total\t\t(tree);\n extern tree array_type_nelts_top\t\t(tree);\n extern bool array_of_unknown_bound_p\t\t(const_tree);\n+extern bool source_location_current_p\t\t(tree);\n extern tree break_out_target_exprs\t\t(tree, bool = false);\n extern tree build_ctor_subob_ref\t\t(tree, tree, tree);\n extern tree replace_placeholders\t\t(tree, tree, bool * = NULL);"}, {"sha": "4d9efb74744b0be6c66abf1f1eb41c5212d23b5d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=ba3d8dffcc1c23b30370ab24fc20d09cff005d7b", "patch": "@@ -2993,6 +2993,32 @@ array_type_nelts_total (tree type)\n   return sz;\n }\n \n+/* Return true if FNDECL is std::source_location::current () method.  */\n+\n+bool\n+source_location_current_p (tree fndecl)\n+{\n+  gcc_checking_assert (TREE_CODE (fndecl) == FUNCTION_DECL\n+\t\t       && DECL_IMMEDIATE_FUNCTION_P (fndecl));\n+  if (DECL_NAME (fndecl) == NULL_TREE\n+      || TREE_CODE (TREE_TYPE (fndecl)) != FUNCTION_TYPE\n+      || TREE_CODE (TREE_TYPE (TREE_TYPE (fndecl))) != RECORD_TYPE\n+      || DECL_CONTEXT (fndecl) != TREE_TYPE (TREE_TYPE (fndecl))\n+      || !id_equal (DECL_NAME (fndecl), \"current\"))\n+    return false;\n+\n+  tree source_location = DECL_CONTEXT (fndecl);\n+  if (TYPE_NAME (source_location) == NULL_TREE\n+      || TREE_CODE (TYPE_NAME (source_location)) != TYPE_DECL\n+      || TYPE_IDENTIFIER (source_location) == NULL_TREE\n+      || !id_equal (TYPE_IDENTIFIER (source_location),\n+\t\t    \"source_location\")\n+      || !decl_in_std_namespace_p (TYPE_NAME (source_location)))\n+    return false;\n+\n+  return true;\n+}\n+\n struct bot_data\n {\n   splay_tree target_remap;"}, {"sha": "30e5845121117b53474e6bc400ec460f4f74895e", "filename": "gcc/testsuite/g++.dg/cpp2a/srcloc15.C", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc15.C?ref=ba3d8dffcc1c23b30370ab24fc20d09cff005d7b", "patch": "@@ -0,0 +1,119 @@\n+// { dg-do run { target c++20 } }\n+\n+namespace std {\n+  struct source_location {\n+    struct __impl {\n+      const char *_M_file_name;\n+      const char *_M_function_name;\n+      unsigned int _M_line, _M_column;\n+    };\n+    const __impl *__ptr;\n+    constexpr source_location () : __ptr (nullptr) {}\n+    static consteval source_location\n+    current (const void *__p = __builtin_source_location ()) {\n+      source_location __ret;\n+      __ret.__ptr = static_cast <const __impl *> (__p);\n+      return __ret;\n+    }\n+    constexpr const char *file_name () const {\n+      return __ptr ? __ptr->_M_file_name : \"\";\n+    }\n+    constexpr const char *function_name () const {\n+      return __ptr ? __ptr->_M_function_name : \"\";\n+    }\n+    constexpr unsigned line () const {\n+      return __ptr ? __ptr->_M_line : 0;\n+    }\n+    constexpr unsigned column () const {\n+      return __ptr ? __ptr->_M_column : 0;\n+    }\n+  };\n+}\n+\n+using namespace std;\n+\n+constexpr source_location\n+foo (const source_location x = source_location::current ())\n+{\n+  return x;\n+}\n+\n+struct S {\n+  const char *func;\n+  unsigned line = 0;\n+  source_location loc = source_location::current ();\n+\n+  constexpr S (int l, source_location loc = source_location::current ())\n+  : func(__FUNCTION__), line(l), loc(loc)\n+  {}\n+\n+  constexpr S (double)\n+  : func(__FUNCTION__), line(__LINE__)\n+  //                                 ^ column 38\n+  {}\n+};\n+\n+constexpr bool\n+cmp (const char *p, const char *q)\n+{\n+  for (; *p && *q; p++, q++)\n+    if (*p != *q)\n+      return true;\n+  return *p || *q;\n+}\n+\n+constexpr bool\n+bar ()\n+{\n+  int line = __LINE__;\n+  source_location a = foo ();\n+  source_location b = source_location::current ();\n+  source_location c = foo ();\n+  //                       ^ column 28\n+  //                                            ^ column 49\n+  const source_location *d[3] = { &a, &b, &c };\n+  const char *file1 = __FILE__;\n+  const char *function1 = __FUNCTION__;\n+  for (int j = 0; j < 3; j++)\n+    {\n+      int i= 0;\n+      if (cmp (d[j]->file_name (), file1))\n+\treturn false;\n+      if (cmp (d[j]->function_name (), function1))\n+\treturn false;\n+      if (d[j]->line () != line + j + 1)\n+\treturn false;\n+      if (d[j]->column () != (j == 1 ? 49 : 28))\n+\treturn false;\n+    }\n+\n+  S e = __LINE__;\n+  //    ^ column 9\n+  S f = 1.0;\n+  if (cmp (e.loc.file_name (), file1))\n+    return false;\n+  if (cmp (f.loc.file_name (), file1))\n+    return false;\n+  if (cmp (e.loc.function_name (), function1))\n+    return false;\n+  if (cmp (f.loc.function_name (), f.func))\n+    return false;\n+  if (e.loc.line () != e.line)\n+    return false;\n+  if (f.loc.line () != f.line)\n+    return false;\n+  if (e.loc.column () != 9)\n+    return false;\n+  if (f.loc.column () != 38)\n+    return false;\n+  return true;\n+}\n+\n+static_assert (bar ());\n+\n+int\n+main ()\n+{\n+  if (!bar ())\n+    __builtin_abort ();\n+}"}, {"sha": "c8bd28169d2beaaafd3d05e09fb608528ed827a1", "filename": "gcc/testsuite/g++.dg/cpp2a/srcloc16.C", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc16.C?ref=ba3d8dffcc1c23b30370ab24fc20d09cff005d7b", "patch": "@@ -0,0 +1,97 @@\n+// { dg-do run { target c++20 } }\n+\n+namespace std {\n+  struct source_location {\n+    struct __impl {\n+      const char *_M_file_name;\n+      const char *_M_function_name;\n+      unsigned int _M_line, _M_column;\n+    };\n+    const __impl *__ptr;\n+    constexpr source_location () : __ptr (nullptr) {}\n+    static consteval source_location\n+    current (const void *__p = __builtin_source_location ()) {\n+      source_location __ret;\n+      __ret.__ptr = static_cast <const __impl *> (__p);\n+      return __ret;\n+    }\n+    constexpr const char *file_name () const {\n+      return __ptr ? __ptr->_M_file_name : \"\";\n+    }\n+    constexpr const char *function_name () const {\n+      return __ptr ? __ptr->_M_function_name : \"\";\n+    }\n+    constexpr unsigned line () const {\n+      return __ptr ? __ptr->_M_line : 0;\n+    }\n+    constexpr unsigned column () const {\n+      return __ptr ? __ptr->_M_column : 0;\n+    }\n+  };\n+}\n+\n+using namespace std;\n+\n+struct S\n+{\n+  source_location a = source_location::current ();\n+  source_location b = source_location::current ();\n+  source_location c = source_location ();\n+  constexpr S () { c = source_location::current (); }\n+};\n+\n+struct T\n+{\n+  int t;\n+  source_location u = source_location::current ();\n+  int v = __builtin_LINE ();\n+};\n+\n+constexpr S s;\n+constexpr T t = { 1 };\n+\n+constexpr bool\n+cmp (const char *p, const char *q)\n+{\n+  for (; *p && *q; p++, q++)\n+    if (*p != *q)\n+      return true;\n+  return *p || *q;\n+}\n+\n+constexpr bool\n+foo ()\n+{\n+  T u = { 2 };\n+  source_location v = source_location::current ();\n+  if (cmp (s.a.file_name (), s.c.file_name ())\n+      || cmp (s.b.file_name (), s.c.file_name ())\n+      || cmp (t.u.file_name (), s.c.file_name ())\n+      || cmp (u.u.file_name (), s.c.file_name ())\n+      || cmp (v.file_name (), s.c.file_name ())\n+      || cmp (s.a.function_name (), s.c.function_name ())\n+      || cmp (s.b.function_name (), s.c.function_name ())\n+      || cmp (t.u.function_name (), \"\")\n+      || cmp (u.u.function_name (), v.function_name ())\n+      || s.a.line () != s.c.line ()\n+      || s.b.line () != s.c.line ()\n+      || t.u.line () != t.v\n+      || u.u.line () + 1 != v.line ()\n+      || s.a.column () != 18\n+      || s.b.column () != 18\n+      || s.c.column () != 50\n+      || t.u.column () != 21\n+      || u.u.column () != 13\n+      || v.column () != 49)\n+    return false;\n+  return true;\n+}\n+\n+static_assert (foo ());\n+\n+int\n+main ()\n+{\n+  if (!foo ())\n+    __builtin_abort ();\n+}"}, {"sha": "16704d0d33e85c286a7356368fd3e38ef0067d1d", "filename": "gcc/testsuite/g++.dg/cpp2a/srcloc17.C", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc17.C?ref=ba3d8dffcc1c23b30370ab24fc20d09cff005d7b", "patch": "@@ -0,0 +1,122 @@\n+// { dg-do run { target c++20 } }\n+\n+namespace std {\n+  struct source_location {\n+    struct __impl {\n+      const char *_M_file_name;\n+      const char *_M_function_name;\n+      unsigned int _M_line, _M_column;\n+    };\n+    const __impl *__ptr;\n+    constexpr source_location () : __ptr (nullptr) {}\n+    static consteval source_location\n+    current (const void *__p = __builtin_source_location ()) {\n+      source_location __ret;\n+      __ret.__ptr = static_cast <const __impl *> (__p);\n+      return __ret;\n+    }\n+    constexpr const char *file_name () const {\n+      return __ptr ? __ptr->_M_file_name : \"\";\n+    }\n+    constexpr const char *function_name () const {\n+      return __ptr ? __ptr->_M_function_name : \"\";\n+    }\n+    constexpr unsigned line () const {\n+      return __ptr ? __ptr->_M_line : 0;\n+    }\n+    constexpr unsigned column () const {\n+      return __ptr ? __ptr->_M_column : 0;\n+    }\n+  };\n+}\n+\n+using namespace std;\n+\n+template <int N>\n+constexpr source_location\n+foo (const source_location x = source_location::current ())\n+{\n+  return x;\n+}\n+\n+template <int N>\n+struct S {\n+  const char *func;\n+  unsigned line = 0;\n+  source_location loc = source_location::current ();\n+\n+  constexpr S (int l, source_location loc = source_location::current ())\n+  : func(__FUNCTION__), line(l), loc(loc)\n+  {}\n+\n+  constexpr S (double)\n+  : func(__FUNCTION__), line(__LINE__)\n+  //                                 ^ column 38\n+  {}\n+};\n+\n+constexpr bool\n+cmp (const char *p, const char *q)\n+{\n+  for (; *p && *q; p++, q++)\n+    if (*p != *q)\n+      return true;\n+  return *p || *q;\n+}\n+\n+template <int N>\n+constexpr bool\n+bar ()\n+{\n+  int line = __LINE__;\n+  source_location a = foo<N> ();\n+  source_location b = source_location::current ();\n+  source_location c = foo<N> ();\n+  //                         ^ column 30\n+  //                                           ^ column 48\n+  const source_location *d[3] = { &a, &b, &c };\n+  const char *file1 = __FILE__;\n+  const char *function1 = b.function_name ();\n+  for (int j = 0; j < 3; j++)\n+    {\n+      int i= 0;\n+      if (cmp (d[j]->file_name (), file1))\n+\treturn false;\n+      if (cmp (d[j]->function_name (), function1))\n+\treturn false;\n+      if (d[j]->line () != line + j + 1)\n+\treturn false;\n+      if (d[j]->column () != (j == 1 ? 48 : 30))\n+\treturn false;\n+    }\n+\n+  S<N> e = __LINE__;\n+  //   ^ column 8\n+  S<N> f = 1.0;\n+  if (cmp (e.loc.file_name (), file1))\n+    return false;\n+  if (cmp (f.loc.file_name (), file1))\n+    return false;\n+  if (cmp (e.loc.function_name (), function1))\n+    return false;\n+  if (cmp (f.loc.function_name (), f.func))\n+    return false;\n+  if (e.loc.line () != e.line)\n+    return false;\n+  if (f.loc.line () != f.line)\n+    return false;\n+  if (e.loc.column () != 8)\n+    return false;\n+  if (f.loc.column () != 38)\n+    return false;\n+  return true;\n+}\n+\n+static_assert (bar<0> ());\n+\n+int\n+main ()\n+{\n+  if (!bar<0> ())\n+    __builtin_abort ();\n+}"}, {"sha": "7e685ba93a1182e2a69d91d3a70ff39fc588c2ec", "filename": "gcc/testsuite/g++.dg/cpp2a/srcloc18.C", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3d8dffcc1c23b30370ab24fc20d09cff005d7b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc18.C?ref=ba3d8dffcc1c23b30370ab24fc20d09cff005d7b", "patch": "@@ -0,0 +1,100 @@\n+// { dg-do run { target c++20 } }\n+\n+namespace std {\n+  struct source_location {\n+    struct __impl {\n+      const char *_M_file_name;\n+      const char *_M_function_name;\n+      unsigned int _M_line, _M_column;\n+    };\n+    const __impl *__ptr;\n+    constexpr source_location () : __ptr (nullptr) {}\n+    static consteval source_location\n+    current (const void *__p = __builtin_source_location ()) {\n+      source_location __ret;\n+      __ret.__ptr = static_cast <const __impl *> (__p);\n+      return __ret;\n+    }\n+    constexpr const char *file_name () const {\n+      return __ptr ? __ptr->_M_file_name : \"\";\n+    }\n+    constexpr const char *function_name () const {\n+      return __ptr ? __ptr->_M_function_name : \"\";\n+    }\n+    constexpr unsigned line () const {\n+      return __ptr ? __ptr->_M_line : 0;\n+    }\n+    constexpr unsigned column () const {\n+      return __ptr ? __ptr->_M_column : 0;\n+    }\n+  };\n+}\n+\n+using namespace std;\n+\n+template <int N>\n+struct S\n+{\n+  source_location a = source_location::current ();\n+  source_location b = source_location::current ();\n+  source_location c = source_location ();\n+  constexpr S () { c = source_location::current (); }\n+};\n+\n+template <int N>\n+struct T\n+{\n+  int t;\n+  source_location u = source_location::current ();\n+  int v = __builtin_LINE ();\n+};\n+\n+constexpr S<0> s;\n+constexpr T<0> t = { 1 };\n+\n+constexpr bool\n+cmp (const char *p, const char *q)\n+{\n+  for (; *p && *q; p++, q++)\n+    if (*p != *q)\n+      return true;\n+  return *p || *q;\n+}\n+\n+template <int N>\n+constexpr bool\n+foo ()\n+{\n+  T<N> u = { 2 };\n+  source_location v = source_location::current ();\n+  if (cmp (s.a.file_name (), s.c.file_name ())\n+      || cmp (s.b.file_name (), s.c.file_name ())\n+      || cmp (t.u.file_name (), s.c.file_name ())\n+      || cmp (u.u.file_name (), s.c.file_name ())\n+      || cmp (v.file_name (), s.c.file_name ())\n+      || cmp (s.a.function_name (), s.c.function_name ())\n+      || cmp (s.b.function_name (), s.c.function_name ())\n+      || cmp (t.u.function_name (), \"\")\n+      || cmp (u.u.function_name (), v.function_name ())\n+      || s.a.line () != s.c.line ()\n+      || s.b.line () != s.c.line ()\n+      || t.u.line () != t.v\n+      || u.u.line () + 1 != v.line ()\n+      || s.a.column () != 18\n+      || s.b.column () != 18\n+      || s.c.column () != 49\n+      || t.u.column () != 24\n+      || u.u.column () != 8\n+      || v.column () != 48)\n+    return false;\n+  return true;\n+}\n+\n+static_assert (foo<1> ());\n+\n+int\n+main ()\n+{\n+  if (!foo<1> ())\n+    __builtin_abort ();\n+}"}]}