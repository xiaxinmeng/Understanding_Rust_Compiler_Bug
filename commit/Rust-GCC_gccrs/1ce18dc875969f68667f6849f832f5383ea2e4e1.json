{"sha": "1ce18dc875969f68667f6849f832f5383ea2e4e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNlMThkYzg3NTk2OWY2ODY2N2Y2ODQ5ZjgzMmY1MzgzZWEyZTRlMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-04-13T18:22:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-04-13T18:22:35Z"}, "message": "ipa-inline.c (cgraph_mark_inline_edge): Avoid double accounting of optimized out static functions.\n\n\n\t* ipa-inline.c (cgraph_mark_inline_edge): Avoid double accounting\n\tof optimized out static functions.\n\t(cgraph_edge_badness): Add DUMP parameter and dump reasons for the\n\tcost computation.  Also sanity check for overflows.\n\t(update_caller_keys): Update cgraph_edge_badness call; properly\n\tupdate fibheap and sanity check that it is up to date.\n\t(add_new_edges_to_heap): Update cgraph_edge_badness.\n\t(cgraph_decide_inlining_of_small_function): Likewise;\n\tadd sanity checking that badness in heap is up to date;\n\timprove dumping of reason; Update badness of calls to the\n\toffline copy of function currently inlined; dump badness\n\tof functions not inlined because of unit growth limits.\n\nFrom-SVN: r158278", "tree": {"sha": "781e2dec9feabff28d0f9be27d6fc88b6cc7426e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/781e2dec9feabff28d0f9be27d6fc88b6cc7426e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ce18dc875969f68667f6849f832f5383ea2e4e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce18dc875969f68667f6849f832f5383ea2e4e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ce18dc875969f68667f6849f832f5383ea2e4e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce18dc875969f68667f6849f832f5383ea2e4e1/comments", "author": null, "committer": null, "parents": [{"sha": "44b2dc6ca39c88648a5e173a5be450b3b0ca4f69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44b2dc6ca39c88648a5e173a5be450b3b0ca4f69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44b2dc6ca39c88648a5e173a5be450b3b0ca4f69"}], "stats": {"total": 176, "additions": 140, "deletions": 36}, "files": [{"sha": "99fecd25178a12b10085f59bc2bb48960dd35222", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ce18dc875969f68667f6849f832f5383ea2e4e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ce18dc875969f68667f6849f832f5383ea2e4e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ce18dc875969f68667f6849f832f5383ea2e4e1", "patch": "@@ -1,3 +1,18 @@\n+2010-04-13  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c (cgraph_mark_inline_edge): Avoid double accounting\n+\tof optimized out static functions.\n+\t(cgraph_edge_badness): Add DUMP parameter and dump reasons for the\n+\tcost computation.  Also sanity check for overflows.\n+\t(update_caller_keys): Update cgraph_edge_badness call; properly\n+\tupdate fibheap and sanity check that it is up to date.\n+\t(add_new_edges_to_heap): Update cgraph_edge_badness.\n+\t(cgraph_decide_inlining_of_small_function): Likewise;\n+\tadd sanity checking that badness in heap is up to date;\n+\timprove dumping of reason; Update badness of calls to the\n+\toffline copy of function currently inlined; dump badness\n+\tof functions not inlined because of unit growth limits.\n+\n 2010-04-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR middle-end/32628"}, {"sha": "601695a3fdaacd3cb09b999b34e176a651e63be7", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 125, "deletions": 36, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ce18dc875969f68667f6849f832f5383ea2e4e1/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ce18dc875969f68667f6849f832f5383ea2e4e1/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=1ce18dc875969f68667f6849f832f5383ea2e4e1", "patch": "@@ -306,8 +306,6 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n   struct cgraph_node *to = NULL, *what;\n   struct cgraph_edge *curr = e;\n   int freq;\n-  bool duplicate = false;\n-  int orig_size = e->callee->global.size;\n \n   gcc_assert (e->inline_failed);\n   e->inline_failed = CIF_OK;\n@@ -316,10 +314,6 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n     DECL_POSSIBLY_INLINED (e->callee->decl) = true;\n   e->callee->global.inlined = true;\n \n-  if (e->callee->callers->next_caller\n-      || !cgraph_can_remove_if_no_direct_calls_p (e->callee)\n-      || e->callee->same_comdat_group)\n-    duplicate = true;\n   cgraph_clone_inlined_nodes (e, true, update_original);\n \n   what = e->callee;\n@@ -337,8 +331,6 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n   gcc_assert (what->global.inlined_to == to);\n   if (new_size > old_size)\n     overall_size += new_size - old_size;\n-  if (!duplicate)\n-    overall_size -= orig_size;\n   ncalls_inlined++;\n \n   if (flag_indirect_inlining)\n@@ -544,23 +536,54 @@ cgraph_recursive_inlining_p (struct cgraph_node *to,\n    of the function or function body size.  */\n \n static int\n-cgraph_edge_badness (struct cgraph_edge *edge)\n+cgraph_edge_badness (struct cgraph_edge *edge, bool dump)\n {\n   gcov_type badness;\n   int growth =\n-    cgraph_estimate_size_after_inlining (1, edge->caller, edge->callee);\n+    (cgraph_estimate_size_after_inlining (1, edge->caller, edge->callee)\n+     - edge->caller->global.size);\n \n-  growth -= edge->caller->global.size;\n+  if (dump)\n+    {\n+      fprintf (dump_file, \"    Badness calculcation for %s -> %s\\n\",\n+\t       cgraph_node_name (edge->caller),\n+\t       cgraph_node_name (edge->callee));\n+      fprintf (dump_file, \"      growth %i, time %i-%i, size %i-%i\\n\",\n+\t       growth,\n+\t       edge->callee->global.time,\n+\t       inline_summary (edge->callee)->time_inlining_benefit,\n+\t       edge->callee->global.size,\n+\t       inline_summary (edge->callee)->size_inlining_benefit);\n+    }\n \n   /* Always prefer inlining saving code size.  */\n   if (growth <= 0)\n-    badness = INT_MIN - growth;\n+    {\n+      badness = INT_MIN - growth;\n+      if (dump)\n+\tfprintf (dump_file, \"      %i: Growth %i < 0\\n\", (int) badness,\n+\t\t growth);\n+    }\n \n   /* When profiling is available, base priorities -(#calls / growth).\n      So we optimize for overall number of \"executed\" inlined calls.  */\n   else if (max_count)\n-    badness = ((int)((double)edge->count * INT_MIN / max_count / (max_benefit + 1))\n-    \t      * (inline_summary (edge->callee)->time_inlining_benefit + 1)) / growth;\n+    {\n+      badness =\n+\t((int)\n+\t ((double) edge->count * INT_MIN / max_count / (max_benefit + 1)) *\n+\t (inline_summary (edge->callee)->time_inlining_benefit + 1)) / growth;\n+      if (dump)\n+\t{\n+\t  fprintf (dump_file,\n+\t\t   \"      %i (relative %f): profile info. Relative count %f\"\n+\t\t   \" * Relative benefit %f\\n\",\n+\t\t   (int) badness, (double) badness / INT_MIN,\n+\t\t   (double) edge->count / max_count,\n+\t\t   (double) (inline_summary (edge->callee)->\n+\t\t\t     time_inlining_benefit + 1) / (max_benefit + 1));\n+\t}\n+    }\n \n   /* When function local profile is available, base priorities on\n      growth / frequency, so we optimize for overall frequency of inlined\n@@ -574,9 +597,13 @@ cgraph_edge_badness (struct cgraph_edge *edge)\n   else if (flag_guess_branch_prob)\n     {\n       int div = edge->frequency * 100 / CGRAPH_FREQ_BASE + 1;\n+      int benefitperc;\n+      int growth_for_all;\n       badness = growth * 10000;\n-      div *= MIN (100 * inline_summary (edge->callee)->time_inlining_benefit\n-      \t          / (edge->callee->global.time + 1) + 1, 100);\n+      benefitperc =\n+\tMIN (100 * inline_summary (edge->callee)->time_inlining_benefit /\n+\t     (edge->callee->global.time + 1) +1, 100);\n+      div *= benefitperc;\n \n \n       /* Decrease badness if call is nested.  */\n@@ -587,9 +614,17 @@ cgraph_edge_badness (struct cgraph_edge *edge)\n \tdiv = 1;\n       if (badness > 0)\n \tbadness /= div;\n-      badness += cgraph_estimate_growth (edge->callee);\n+      growth_for_all = cgraph_estimate_growth (edge->callee);\n+      badness += growth_for_all;\n       if (badness > INT_MAX)\n-        badness = INT_MAX;\n+\tbadness = INT_MAX;\n+      if (dump)\n+\t{\n+\t  fprintf (dump_file,\n+\t\t   \"      %i: guessed profile. frequency %i, overall growth %i,\"\n+\t\t   \" benefit %i%%, divisor %i\\n\",\n+\t\t   (int) badness, edge->frequency, growth_for_all, benefitperc, div);\n+\t}\n     }\n   /* When function local profile is not available or it does not give\n      useful information (ie frequency is zero), base the cost on\n@@ -604,10 +639,17 @@ cgraph_edge_badness (struct cgraph_edge *edge)\n       if (badness > 0)\n \tbadness >>= nest;\n       else\n-        {\n+\t{\n \t  badness <<= nest;\n-        }\n+\t}\n+      if (dump)\n+\tfprintf (dump_file, \"      %i: no profile. nest %i\\n\", (int) badness,\n+\t\t nest);\n     }\n+\n+  /* Ensure that we did not overflow in all the fixed point math above.  */\n+  gcc_assert (badness >= INT_MIN);\n+  gcc_assert (badness <= INT_MAX - 1);\n   /* Make recursive inlining happen always after other inlining is done.  */\n   if (cgraph_recursive_inlining_p (edge->caller, edge->callee, NULL))\n     return badness + 1;\n@@ -651,7 +693,7 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n   for (edge = node->callers; edge; edge = edge->next_caller)\n     if (edge->inline_failed)\n       {\n-\tint badness = cgraph_edge_badness (edge);\n+\tint badness = cgraph_edge_badness (edge, false);\n \tif (edge->aux)\n \t  {\n \t    fibnode_t n = (fibnode_t) edge->aux;\n@@ -660,8 +702,12 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n \t      continue;\n \n \t    /* fibheap_replace_key only increase the keys.  */\n-\t    if (fibheap_replace_key (heap, n, badness))\n-\t      continue;\n+\t    if (badness < n->key)\n+\t      {\n+\t\tfibheap_replace_key (heap, n, badness);\n+\t\tgcc_assert (n->key == badness);\n+\t        continue;\n+\t      }\n \t    fibheap_delete_node (heap, (fibnode_t) edge->aux);\n \t  }\n \tedge->aux = fibheap_insert (heap, badness, edge);\n@@ -889,7 +935,7 @@ add_new_edges_to_heap (fibheap_t heap, VEC (cgraph_edge_p, heap) *new_edges)\n       struct cgraph_edge *edge = VEC_pop (cgraph_edge_p, new_edges);\n \n       gcc_assert (!edge->aux);\n-      edge->aux = fibheap_insert (heap, cgraph_edge_badness (edge), edge);\n+      edge->aux = fibheap_insert (heap, cgraph_edge_badness (edge, false), edge);\n     }\n }\n \n@@ -938,23 +984,34 @@ cgraph_decide_inlining_of_small_functions (void)\n \tif (edge->inline_failed)\n \t  {\n \t    gcc_assert (!edge->aux);\n-\t    edge->aux = fibheap_insert (heap, cgraph_edge_badness (edge), edge);\n+\t    edge->aux = fibheap_insert (heap, cgraph_edge_badness (edge, false), edge);\n \t  }\n     }\n \n   max_size = compute_max_insns (overall_size);\n   min_size = overall_size;\n \n   while (overall_size <= max_size\n-\t && (edge = (struct cgraph_edge *) fibheap_extract_min (heap)))\n+\t && !fibheap_empty (heap))\n     {\n       int old_size = overall_size;\n-      struct cgraph_node *where;\n-      int growth =\n-\tcgraph_estimate_size_after_inlining (1, edge->caller, edge->callee);\n+      struct cgraph_node *where, *callee;\n+      int badness = fibheap_min_key (heap);\n+      int growth;\n       cgraph_inline_failed_t not_good = CIF_OK;\n \n-      growth -= edge->caller->global.size;\n+      edge = (struct cgraph_edge *) fibheap_extract_min (heap);\n+      gcc_assert (edge->aux);\n+      edge->aux = NULL;\n+      if (!edge->inline_failed)\n+\tcontinue;\n+#ifdef ENABLE_CHECKING\n+      gcc_assert (cgraph_edge_badness (edge, false) == badness);\n+#endif\n+      callee = edge->callee;\n+\n+      growth = (cgraph_estimate_size_after_inlining (1, edge->caller, edge->callee)\n+\t\t- edge->caller->global.size);\n \n       if (dump_file)\n \t{\n@@ -970,15 +1027,13 @@ cgraph_decide_inlining_of_small_functions (void)\n \t\t   gimple_filename ((const_gimple) edge->call_stmt),\n \t\t   gimple_lineno ((const_gimple) edge->call_stmt),\n \t\t   cgraph_estimate_growth (edge->callee),\n-\t\t   cgraph_edge_badness (edge),\n+\t\t   badness,\n \t\t   edge->frequency / (double)CGRAPH_FREQ_BASE);\n \t  if (edge->count)\n \t    fprintf (dump_file,\" Called \"HOST_WIDEST_INT_PRINT_DEC\"x\\n\", edge->count);\n+\t  if (dump_flags & TDF_DETAILS)\n+\t    cgraph_edge_badness (edge, true);\n \t}\n-      gcc_assert (edge->aux);\n-      edge->aux = NULL;\n-      if (!edge->inline_failed)\n-\tcontinue;\n \n       /* When not having profile info ready we don't weight by any way the\n          position of call in procedure itself.  This means if call of\n@@ -1096,6 +1151,11 @@ cgraph_decide_inlining_of_small_functions (void)\n \t called by function we inlined (since number of it inlinable callers\n \t might change).  */\n       update_caller_keys (heap, where, updated_nodes);\n+\n+      /* We removed one call of the function we just inlined.  If offline\n+\t copy is still needed, be sure to update the keys.  */\n+      if (callee != where && !callee->global.inlined_to)\n+        update_caller_keys (heap, callee, updated_nodes);\n       bitmap_clear (updated_nodes);\n \n       if (dump_file)\n@@ -1117,10 +1177,39 @@ cgraph_decide_inlining_of_small_functions (void)\n \t    fprintf (dump_file, \"New minimal size reached: %i\\n\", min_size);\n \t}\n     }\n-  while ((edge = (struct cgraph_edge *) fibheap_extract_min (heap)) != NULL)\n+  while (!fibheap_empty (heap))\n     {\n+      int badness = fibheap_min_key (heap);\n+\n+      edge = (struct cgraph_edge *) fibheap_extract_min (heap);\n       gcc_assert (edge->aux);\n       edge->aux = NULL;\n+      if (!edge->inline_failed)\n+\tcontinue;\n+#ifdef ENABLE_CHECKING\n+      gcc_assert (cgraph_edge_badness (edge, false) == badness);\n+#endif\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file,\n+\t\t   \"\\nSkipping %s with %i size\\n\",\n+\t\t   cgraph_node_name (edge->callee),\n+\t\t   edge->callee->global.size);\n+\t  fprintf (dump_file,\n+\t\t   \" called by %s in %s:%i\\n\"\n+\t\t   \" Estimated growth after inlined into all callees is %+i insns.\\n\"\n+\t\t   \" Estimated badness is %i, frequency %.2f.\\n\",\n+\t\t   cgraph_node_name (edge->caller),\n+\t\t   gimple_filename ((const_gimple) edge->call_stmt),\n+\t\t   gimple_lineno ((const_gimple) edge->call_stmt),\n+\t\t   cgraph_estimate_growth (edge->callee),\n+\t\t   badness,\n+\t\t   edge->frequency / (double)CGRAPH_FREQ_BASE);\n+\t  if (edge->count)\n+\t    fprintf (dump_file,\" Called \"HOST_WIDEST_INT_PRINT_DEC\"x\\n\", edge->count);\n+\t  if (dump_flags & TDF_DETAILS)\n+\t    cgraph_edge_badness (edge, true);\n+\t}\n       if (!edge->callee->local.disregard_inline_limits && edge->inline_failed\n           && !cgraph_recursive_inlining_p (edge->caller, edge->callee,\n \t\t\t\t           &edge->inline_failed))"}]}