{"sha": "92c7734db7af1395be571c5ec023a38fb7b42adf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJjNzczNGRiN2FmMTM5NWJlNTcxYzVlYzAyM2EzOGZiN2I0MmFkZg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2019-07-08T08:13:43Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-08T08:13:43Z"}, "message": "[Ada] New algorithm for Elaboration order v4.0\n\nThis patch introduces several changes to the new elaboration order\nmechanism:\n\n   * The concept of \"strong\" and \"weak\" edges is introduced. Strong\n     edges are the byproduct of language-defined relations between\n     units, such as with clauses. Weak edges are the byproduct of\n     specilative invocations at elaboration time, which may or may not\n     take place depending on control flow.\n\n   * The elaboration order algorithm has been heavily modified to make\n     use of the strong and weak edges, and operate on units compiled\n     with different elaboration models.\n\n   * The elaboration order algorithm employs the following logic:\n\n        - Maintain two sets of vertices, one for all elaborable\n          vertices, and one for all waiting vertices.\n\n        - Pick the best elaborable vertex, and elaborate its component.\n\n        - If no such elaborable vertex is available, pick the best\n          weakly elaborable vertex whose unit has been compiled with the\n          dynamic model, and elaborate its component.\n\n        - If no such weakly elaborable vertex is available, then either\n          all vertices were already elaborated, or the graph contains a\n          cycle.\n\n     The elaboration of a component employs the same logic, with an\n     added step where all successors of some predecessor currently being\n     elaborated are notified that they have one fewer predecessor to\n     wait on. This may cause certain successors to become elaborable, in\n     which case they are moved from the set of waiting vertices to the\n     set of elaborable vertices.\n\n   * Three new GNATbind debug switches are introduced, -d_a, -d_b, and\n     -d_e, to eliminate the effects of pragmas Elaborate_All,\n     Elaborate_Body, and Elaborate respectively.\n\n   * The section on terminology is updated to include new entries.\n\n2019-07-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* bindo.adb: Update the section on terminology to include new\n\tconcepts.  Update the section on switches to include new\n\tentries.\n\t* bindo.ads: Add type Precedence_Kind.\n\t* bindo-builders.adb: Add with and use clauses for Debug and\n\tBindo.Validators.  Add use clauses for\n\tBindo.Validators.Invocation_Graph_Validators and\n\tBindo.Validators.Library_Graph_Validators.\n\t(Build_Invocation_Graph): Validate the graph immediately after\n\tit was built.\n\t(Build_Library_Graph): Update the parameter profile. The\n\tcreation of the graph is now elaboration model-agnostic.\n\tValidate the graph immediately after it was built.\n\t(Create_With_Edge): Create regular with edges for Elaborate and\n\tElaborate_All edges when the appropriate debug switches are in\n\teffect.\n\t* bindo-builders.ads (Build_Library_Graph): Update the parameter\n\tprofile.\n\t* bindo-diagnostics.adb (Diagnose_Cycle): Track the presence of\n\tan Elaborate_All edge throughout the inspection of the cycle's\n\tedges.\n\t(Output_Dynamic_Model_Suggestions): Output the suggestion only\n\twhen the cycle contains at least one weak edge where the\n\tsuccessor was statically elaborated.\n\t(Output_Elaborate_Body_Transition, Output_Forced_Transition,\n\tOutput_With_Transition): Update the assertions.\n\t* bindo-elaborators.adb: Remove use clauses for\n\tBindo.Validators.Invocation_Graph_Validators and\n\tBindo.Validators.Library_Graph_Validators.  Remove strings\n\tAdd_To_All_Candidates_Msg and Add_To_Comp_Candidates_Msg.\n\tRemove type String_Ptr.\n\t(Add_Vertex, Add_Vertex_If_Elaborable, Create_All_Candidates_Set\n\tCreate_Component_Candidates_Set): Remove.\n\t(Create_Component_Vertex_Sets, Create_Vertex_Sets): New routine.\n\t(Elaborate_Component): Update the parameter profile and the\n\tcomment on usage.  Reimplement the elaboration of a component.\n\tThe algorithm will now attempt to elaborate as many vertices\n\tpossible. If this is not possible, and a weakly elaborable\n\tvertex is available use unit was compiled using the dynamic\n\tmodel, the algorithm will elaborate it.\n\t(Elaborate_Library_Graph): Reimplement the elaboration of the\n\tgraph. The algorithm will now attempt to elaborate as many\n\tvertices along with their components as possible. If this is not\n\tpossible, and a weakly elaborable vertex is available use unit\n\twas compiled using the dynamic model, the algorithm will\n\telaborate it along with its component.\n\t(Elaborate_Units): Merge with the functionality of\n\tElaborate_Units_Common.\n\t(Elaborate_Units_Common, Elaborate_Units_Dynamic,\n\tElaborate_Units_Static): Remove.\n\t(Elaborate_Vertex): Update the parameter profile and the comment\n\ton usage.  Reimplemented.\n\t(Find_Best_Candidate): Remove.\n\t(Find_Best_Elaborable_Vertex, Find_Best_Vertex,\n\tFind_Best_Weakly_Elaborable_Vertex, Has_Elaborable_Body,\n\tInsert_Elaborable_Successor, Insert_Vertex): New routines.\n\t(Is_Better_Candidate): Remove.\n\t(Is_Better_Elaborable_Vertex,\n\tIs_Better_Weakly_Elaborable_Vertex,\n\tIs_Suitable_Elaborable_Vertex,\n\tIs_Suitable_Weakly_Elaborable_Vertex): New routines.\n\t(Trace_Candidate_Vertices): Remove.\n\t(Trace_Component): Output the number of strong and weak\n\tpredecessors.\n\t(Trace_Unelaborated_Vertices): Remove.\n\t(Trace_Vertex): Output the number of strong and weak\n\tpredecessors.\n\t(Trace_Vertices): New routine.\n\t(Update_Successor, Update_Successors): Update the parameter\n\tprofile and the comment on usage.\n\t* bindo-graphs.adb: Remove type Precedence_Kind.\n\t(Add_Edge_With_Return): Update the increment of pending\n\tpredecessors.\n\t(Add_Vertex): Provide default values for strong and weak\n\tpredecessors.\n\t(Complementary_Vertex): Move the initial declaration to the\n\tspec. Update the parameter profile and the comment on usage.\n\t(Contains_Weak_Static_Successor): New routine.\n\t(Create): Update the parameter profile. The creation of the\n\tgraph is now elaboration model-agnostic.\n\t(Decrement_Pending_Predecessors): Update the parameter profile\n\tand the comment on usage. Reimplemented.\n\t(Delete_Edge): Update the decrement of pending predecesors.\n\t(Has_Elaborate_Body): Do not treat a vertex as being subject to\n\tElaborate_Body when a debug switch is in effect.\n\t(Increment_Pending_Predecessors): Update the parameter profile\n\tand the comment on usage. Reimplemented.\n\t(Is_Elaborable_Component): Reimplemented.\n\t(Is_Elaborable_Vertex): Move the initial declaration to the\n\tspec.  Reimplemented.\n\t(Is_Elaborate_Body_Pair): New routine.\n\t(Is_Dynamically_Elaborated): Update the parameter profile.\n\tReimplemented.\n\t(Is_Weakly_Elaborable_Vertex): New routine.\n\t(Pending_Predecessors): Removed.\n\t(Pending_Predecessors_For_Elaboration,\n\tPending_Strong_Predecessors, Pending_Weak_Predecessors,\n\tUpdate_Pending_Predecessors): New routines.\n\t(Update_Pending_Predecessors_Of_Components): Update the\n\tincrement of pending predecessors.\n\t* bindo-graphs.ads: Update the components of type\n\tComponent_Attributes.  Update the components of type\n\tLibrary_Graph_Attributes.  Update the components of type\n\tLibrary_Graph_Vertex_Attributes.  Update the initialization of\n\tNo_Component_Attributes.  Update the initialization of\n\tNo_Library_Graph_Vertex_Attributes.\n\t(Complementary_Vertex, Contains_Weak_Static_Successor): New\n\troutines.\n\t(Create): Update the parameter profile and the comment on usage.\n\t(Decrement_Pending_Predecessors, Is_Dynamically_Elaborated):\n\tUpdate the parameter profile and the comment on usage.\n\t(Is_Elaborate_Body_Pair, Is_Weakly_Elaborable_Vertex): New\n\troutines.\n\t(Pending_Predecessors): Removed.\n\t(Pending_Predecessors_For_Elaboration,\n\tPending_Strong_Predecessors, Pending_Weak_Predecessors): New\n\troutines.\n\t* bindo-writers.adb (Write_Components): Moved from the spec.\n\t(Write_Component): Output the strong and weak predecessors.\n\t(Write_Library_Graph): Output the components as part of the\n\tgraph.\n\t(Write_Library_Graph_Vertex): Output the strong and weak\n\tpredecessors.\n\t* bindo-writers.ads (Write_Components): Moved to the body.\n\t* debug.adb: Add and document new GNATbind switches -d_a, -d_b,\n\t-d_e.\n\t* bindo-validators.adb: Minor reformattings.\n\nFrom-SVN: r273209", "tree": {"sha": "2a24490b459eb9348717049e1670a899ba5b2aab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a24490b459eb9348717049e1670a899ba5b2aab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92c7734db7af1395be571c5ec023a38fb7b42adf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92c7734db7af1395be571c5ec023a38fb7b42adf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92c7734db7af1395be571c5ec023a38fb7b42adf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92c7734db7af1395be571c5ec023a38fb7b42adf/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "79ee9e32b17be333e6c70a104c7049c8cab40834", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79ee9e32b17be333e6c70a104c7049c8cab40834", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79ee9e32b17be333e6c70a104c7049c8cab40834"}], "stats": {"total": 2920, "additions": 1845, "deletions": 1075}, "files": [{"sha": "e6eac08a8025cf441b2c855fa0419203b48a2a17", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=92c7734db7af1395be571c5ec023a38fb7b42adf", "patch": "@@ -1,3 +1,133 @@\n+2019-07-08  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* bindo.adb: Update the section on terminology to include new\n+\tconcepts.  Update the section on switches to include new\n+\tentries.\n+\t* bindo.ads: Add type Precedence_Kind.\n+\t* bindo-builders.adb: Add with and use clauses for Debug and\n+\tBindo.Validators.  Add use clauses for\n+\tBindo.Validators.Invocation_Graph_Validators and\n+\tBindo.Validators.Library_Graph_Validators.\n+\t(Build_Invocation_Graph): Validate the graph immediately after\n+\tit was built.\n+\t(Build_Library_Graph): Update the parameter profile. The\n+\tcreation of the graph is now elaboration model-agnostic.\n+\tValidate the graph immediately after it was built.\n+\t(Create_With_Edge): Create regular with edges for Elaborate and\n+\tElaborate_All edges when the appropriate debug switches are in\n+\teffect.\n+\t* bindo-builders.ads (Build_Library_Graph): Update the parameter\n+\tprofile.\n+\t* bindo-diagnostics.adb (Diagnose_Cycle): Track the presence of\n+\tan Elaborate_All edge throughout the inspection of the cycle's\n+\tedges.\n+\t(Output_Dynamic_Model_Suggestions): Output the suggestion only\n+\twhen the cycle contains at least one weak edge where the\n+\tsuccessor was statically elaborated.\n+\t(Output_Elaborate_Body_Transition, Output_Forced_Transition,\n+\tOutput_With_Transition): Update the assertions.\n+\t* bindo-elaborators.adb: Remove use clauses for\n+\tBindo.Validators.Invocation_Graph_Validators and\n+\tBindo.Validators.Library_Graph_Validators.  Remove strings\n+\tAdd_To_All_Candidates_Msg and Add_To_Comp_Candidates_Msg.\n+\tRemove type String_Ptr.\n+\t(Add_Vertex, Add_Vertex_If_Elaborable, Create_All_Candidates_Set\n+\tCreate_Component_Candidates_Set): Remove.\n+\t(Create_Component_Vertex_Sets, Create_Vertex_Sets): New routine.\n+\t(Elaborate_Component): Update the parameter profile and the\n+\tcomment on usage.  Reimplement the elaboration of a component.\n+\tThe algorithm will now attempt to elaborate as many vertices\n+\tpossible. If this is not possible, and a weakly elaborable\n+\tvertex is available use unit was compiled using the dynamic\n+\tmodel, the algorithm will elaborate it.\n+\t(Elaborate_Library_Graph): Reimplement the elaboration of the\n+\tgraph. The algorithm will now attempt to elaborate as many\n+\tvertices along with their components as possible. If this is not\n+\tpossible, and a weakly elaborable vertex is available use unit\n+\twas compiled using the dynamic model, the algorithm will\n+\telaborate it along with its component.\n+\t(Elaborate_Units): Merge with the functionality of\n+\tElaborate_Units_Common.\n+\t(Elaborate_Units_Common, Elaborate_Units_Dynamic,\n+\tElaborate_Units_Static): Remove.\n+\t(Elaborate_Vertex): Update the parameter profile and the comment\n+\ton usage.  Reimplemented.\n+\t(Find_Best_Candidate): Remove.\n+\t(Find_Best_Elaborable_Vertex, Find_Best_Vertex,\n+\tFind_Best_Weakly_Elaborable_Vertex, Has_Elaborable_Body,\n+\tInsert_Elaborable_Successor, Insert_Vertex): New routines.\n+\t(Is_Better_Candidate): Remove.\n+\t(Is_Better_Elaborable_Vertex,\n+\tIs_Better_Weakly_Elaborable_Vertex,\n+\tIs_Suitable_Elaborable_Vertex,\n+\tIs_Suitable_Weakly_Elaborable_Vertex): New routines.\n+\t(Trace_Candidate_Vertices): Remove.\n+\t(Trace_Component): Output the number of strong and weak\n+\tpredecessors.\n+\t(Trace_Unelaborated_Vertices): Remove.\n+\t(Trace_Vertex): Output the number of strong and weak\n+\tpredecessors.\n+\t(Trace_Vertices): New routine.\n+\t(Update_Successor, Update_Successors): Update the parameter\n+\tprofile and the comment on usage.\n+\t* bindo-graphs.adb: Remove type Precedence_Kind.\n+\t(Add_Edge_With_Return): Update the increment of pending\n+\tpredecessors.\n+\t(Add_Vertex): Provide default values for strong and weak\n+\tpredecessors.\n+\t(Complementary_Vertex): Move the initial declaration to the\n+\tspec. Update the parameter profile and the comment on usage.\n+\t(Contains_Weak_Static_Successor): New routine.\n+\t(Create): Update the parameter profile. The creation of the\n+\tgraph is now elaboration model-agnostic.\n+\t(Decrement_Pending_Predecessors): Update the parameter profile\n+\tand the comment on usage. Reimplemented.\n+\t(Delete_Edge): Update the decrement of pending predecesors.\n+\t(Has_Elaborate_Body): Do not treat a vertex as being subject to\n+\tElaborate_Body when a debug switch is in effect.\n+\t(Increment_Pending_Predecessors): Update the parameter profile\n+\tand the comment on usage. Reimplemented.\n+\t(Is_Elaborable_Component): Reimplemented.\n+\t(Is_Elaborable_Vertex): Move the initial declaration to the\n+\tspec.  Reimplemented.\n+\t(Is_Elaborate_Body_Pair): New routine.\n+\t(Is_Dynamically_Elaborated): Update the parameter profile.\n+\tReimplemented.\n+\t(Is_Weakly_Elaborable_Vertex): New routine.\n+\t(Pending_Predecessors): Removed.\n+\t(Pending_Predecessors_For_Elaboration,\n+\tPending_Strong_Predecessors, Pending_Weak_Predecessors,\n+\tUpdate_Pending_Predecessors): New routines.\n+\t(Update_Pending_Predecessors_Of_Components): Update the\n+\tincrement of pending predecessors.\n+\t* bindo-graphs.ads: Update the components of type\n+\tComponent_Attributes.  Update the components of type\n+\tLibrary_Graph_Attributes.  Update the components of type\n+\tLibrary_Graph_Vertex_Attributes.  Update the initialization of\n+\tNo_Component_Attributes.  Update the initialization of\n+\tNo_Library_Graph_Vertex_Attributes.\n+\t(Complementary_Vertex, Contains_Weak_Static_Successor): New\n+\troutines.\n+\t(Create): Update the parameter profile and the comment on usage.\n+\t(Decrement_Pending_Predecessors, Is_Dynamically_Elaborated):\n+\tUpdate the parameter profile and the comment on usage.\n+\t(Is_Elaborate_Body_Pair, Is_Weakly_Elaborable_Vertex): New\n+\troutines.\n+\t(Pending_Predecessors): Removed.\n+\t(Pending_Predecessors_For_Elaboration,\n+\tPending_Strong_Predecessors, Pending_Weak_Predecessors): New\n+\troutines.\n+\t* bindo-writers.adb (Write_Components): Moved from the spec.\n+\t(Write_Component): Output the strong and weak predecessors.\n+\t(Write_Library_Graph): Output the components as part of the\n+\tgraph.\n+\t(Write_Library_Graph_Vertex): Output the strong and weak\n+\tpredecessors.\n+\t* bindo-writers.ads (Write_Components): Moved to the body.\n+\t* debug.adb: Add and document new GNATbind switches -d_a, -d_b,\n+\t-d_e.\n+\t* bindo-validators.adb: Minor reformattings.\n+\n 2019-07-08  Bob Duff  <duff@adacore.com>\n \n \t* libgnat/g-sercom.ads, libgnat/g-sercom__linux.adb (Data_Rate):"}, {"sha": "233891d12e486ad96917ab77158f9af3060ca2d1", "filename": "gcc/ada/bindo-builders.adb", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-builders.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-builders.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-builders.adb?ref=92c7734db7af1395be571c5ec023a38fb7b42adf", "patch": "@@ -25,12 +25,18 @@\n \n with Binderr; use Binderr;\n with Butil;   use Butil;\n+with Debug;   use Debug;\n with Opt;     use Opt;\n with Output;  use Output;\n with Types;   use Types;\n \n with Bindo.Units; use Bindo.Units;\n \n+with Bindo.Validators;\n+use  Bindo.Validators;\n+use  Bindo.Validators.Invocation_Graph_Validators;\n+use  Bindo.Validators.Library_Graph_Validators;\n+\n with GNAT;                 use GNAT;\n with GNAT.Dynamic_HTables; use GNAT.Dynamic_HTables;\n \n@@ -104,6 +110,8 @@ package body Bindo.Builders is\n          For_Each_Elaborable_Unit (Create_Vertices'Access);\n          For_Each_Elaborable_Unit (Create_Edges'Access);\n \n+         Validate_Invocation_Graph (Inv_Graph);\n+\n          return Inv_Graph;\n       end Build_Invocation_Graph;\n \n@@ -365,24 +373,22 @@ package body Bindo.Builders is\n       -- Build_Library_Graph --\n       -------------------------\n \n-      function Build_Library_Graph\n-        (Dynamically_Elaborated : Boolean) return Library_Graph\n-      is\n+      function Build_Library_Graph return Library_Graph is\n       begin\n          --  Prepare the global data\n \n          Lib_Graph :=\n            Create\n-             (Initial_Vertices       => Number_Of_Elaborable_Units,\n-              Initial_Edges          => Number_Of_Elaborable_Units,\n-              Dynamically_Elaborated => Dynamically_Elaborated);\n+             (Initial_Vertices => Number_Of_Elaborable_Units,\n+              Initial_Edges    => Number_Of_Elaborable_Units);\n \n          For_Each_Elaborable_Unit (Create_Vertex'Access);\n          For_Each_Elaborable_Unit (Create_Spec_And_Body_Edge'Access);\n          For_Each_Elaborable_Unit (Create_With_Edges'Access);\n-\n          Create_Forced_Edges;\n \n+         Validate_Library_Graph (Lib_Graph);\n+\n          return Lib_Graph;\n       end Build_Library_Graph;\n \n@@ -549,9 +555,13 @@ package body Bindo.Builders is\n \n          Withed_Vertex := Corresponding_Vertex (Lib_Graph, Withed_U_Id);\n \n-         --  The with comes with pragma Elaborate\n+         --  The with comes with pragma Elaborate. Treat the edge as a with\n+         --  edge when switch -d_e (ignore the effects of pragma Elaborate)\n+         --  is in effect.\n \n-         if Withed_Rec.Elaborate then\n+         if Withed_Rec.Elaborate\n+           and then not Debug_Flag_Underscore_E\n+         then\n             Kind := Elaborate_Edge;\n \n             --  The withed unit is a spec with a completing body. Add an edge\n@@ -568,9 +578,13 @@ package body Bindo.Builders is\n                   Kind => Kind);\n             end if;\n \n-         --  The with comes with pragma Elaborate_All\n+         --  The with comes with pragma Elaborate_All. Treat the edge as a with\n+         --  edge when switch -d_a (ignore the effects of pragma Elaborate_All)\n+         --  is in effect.\n \n-         elsif Withed_Rec.Elaborate_All then\n+         elsif Withed_Rec.Elaborate_All\n+           and then not Debug_Flag_Underscore_A\n+         then\n             Kind := Elaborate_All_Edge;\n \n          --  Otherwise this is a regular with"}, {"sha": "54c39e4820a8ff4b149caffe6c64fe2144ad6ea0", "filename": "gcc/ada/bindo-builders.ads", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-builders.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-builders.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-builders.ads?ref=92c7734db7af1395be571c5ec023a38fb7b42adf", "patch": "@@ -56,11 +56,9 @@ package Bindo.Builders is\n    ----------------------------\n \n    package Library_Graph_Builders is\n-      function Build_Library_Graph\n-        (Dynamically_Elaborated : Boolean) return Library_Graph;\n+      function Build_Library_Graph return Library_Graph;\n       --  Return a new library graph that reflects the dependencies between\n-      --  all units of the bind. Flag Dynamically_Elaborated must be set when\n-      --  the main library unit was compiled using the dynamic model.\n+      --  all units of the bind.\n \n    end Library_Graph_Builders;\n "}, {"sha": "0c1a924a1d668107eb0bb7a3ffa4eb6923813ea3", "filename": "gcc/ada/bindo-diagnostics.adb", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-diagnostics.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-diagnostics.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-diagnostics.adb?ref=92c7734db7af1395be571c5ec023a38fb7b42adf", "patch": "@@ -285,9 +285,9 @@ package body Bindo.Diagnostics is\n       end loop;\n    end Diagnose_All_Cycles;\n \n-   --------------------------\n+   ----------------------------\n    -- Diagnose_Circularities --\n-   --------------------------\n+   ----------------------------\n \n    procedure Diagnose_Circularities\n      (Inv_Graph : Invocation_Graph;\n@@ -374,6 +374,12 @@ package body Bindo.Diagnostics is\n          --  taking into account the predecessors and successors involved, as\n          --  well as the nature of the edge.\n \n+         Elaborate_All_Active :=\n+           Elaborate_All_Active\n+             or else Is_Elaborate_All_Edge\n+                       (G    => Lib_Graph,\n+                        Edge => Current_Edge);\n+\n          Output_Transition\n            (Inv_Graph            => Inv_Graph,\n             Lib_Graph            => Lib_Graph,\n@@ -533,12 +539,12 @@ package body Bindo.Diagnostics is\n       pragma Assert (Present (G));\n       pragma Assert (Present (Cycle));\n \n-      --  The cycle contains at least one invocation edge and the main library\n-      --  unit was compiled with the static model. Using the dynamic model may\n-      --  eliminate the invocation edge, and thus the cycle.\n+      --  The cycle contains at least one invocation edge where the successor\n+      --  was statically elaborated. Using the dynamic model may eliminate an\n+      --  invocation edge, and thus the cycle.\n \n       if Invocation_Edge_Count (G, Cycle) > 0\n-        and then not Is_Dynamically_Elaborated (G)\n+        and then Contains_Weak_Static_Successor (G, Cycle)\n       then\n          Error_Msg_Info\n            (\"    use the dynamic elaboration model (compiler switch -gnatE)\");\n@@ -703,10 +709,11 @@ package body Bindo.Diagnostics is\n       --               Expected_Destination\n \n       else\n-         pragma Assert (Is_Spec_With_Body (G, Actual_Destination));\n-         pragma Assert (Is_Body_With_Spec (G, Expected_Destination));\n          pragma Assert\n-           (Proper_Body (G, Actual_Destination) = Expected_Destination);\n+           (Is_Elaborate_Body_Pair\n+             (G           => G,\n+              Spec_Vertex => Actual_Destination,\n+              Body_Vertex => Expected_Destination));\n \n          Error_Msg_Unit_1 := Name (G, Source);\n          Error_Msg_Unit_2 := Name (G, Actual_Destination);\n@@ -922,13 +929,11 @@ package body Bindo.Diagnostics is\n       --                     Expected_Destination\n \n       else\n-         pragma Assert (Is_Spec_With_Body (G, Actual_Destination));\n-         pragma Assert (Is_Spec_With_Elaborate_Body (G, Actual_Destination));\n-         pragma Assert (Is_Body_With_Spec (G, Expected_Destination));\n-         pragma Assert\n-           (Is_Body_Of_Spec_With_Elaborate_Body (G, Expected_Destination));\n          pragma Assert\n-           (Proper_Body (G, Actual_Destination) = Expected_Destination);\n+           (Is_Elaborate_Body_Pair\n+             (G           => G,\n+              Spec_Vertex => Actual_Destination,\n+              Body_Vertex => Expected_Destination));\n \n          Error_Msg_Unit_1 := Name (G, Source);\n          Error_Msg_Unit_2 := Name (G, Actual_Destination);\n@@ -1392,13 +1397,11 @@ package body Bindo.Diagnostics is\n       --                   Expected_Destination\n \n       else\n-         pragma Assert (Is_Spec_With_Body (G, Actual_Destination));\n-         pragma Assert (Is_Spec_With_Elaborate_Body (G, Actual_Destination));\n-         pragma Assert (Is_Body_With_Spec (G, Expected_Destination));\n-         pragma Assert\n-           (Is_Body_Of_Spec_With_Elaborate_Body (G, Expected_Destination));\n          pragma Assert\n-           (Proper_Body (G, Actual_Destination) = Expected_Destination);\n+           (Is_Elaborate_Body_Pair\n+             (G           => G,\n+              Spec_Vertex => Actual_Destination,\n+              Body_Vertex => Expected_Destination));\n \n          Error_Msg_Unit_1 := Name (G, Source);\n          Error_Msg_Unit_2 := Name (G, Actual_Destination);"}, {"sha": "192e4a228ed63e0e361782902699411edbd9a72f", "filename": "gcc/ada/bindo-elaborators.adb", "status": "modified", "additions": 1086, "deletions": 821, "changes": 1907, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-elaborators.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-elaborators.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-elaborators.adb?ref=92c7734db7af1395be571c5ec023a38fb7b42adf", "patch": "@@ -46,8 +46,6 @@ use  Bindo.Units;\n with Bindo.Validators;\n use  Bindo.Validators;\n use  Bindo.Validators.Elaboration_Order_Validators;\n-use  Bindo.Validators.Invocation_Graph_Validators;\n-use  Bindo.Validators.Library_Graph_Validators;\n \n with Bindo.Writers;\n use  Bindo.Writers;\n@@ -76,76 +74,61 @@ package body Bindo.Elaborators is\n    ----------------------------------------------\n \n    package body Invocation_And_Library_Graph_Elaborators is\n-      Add_To_All_Candidates_Msg  : aliased String :=\n-                                     \"add vertex to all candidates\";\n-      Add_To_Comp_Candidates_Msg : aliased String :=\n-                                     \"add vertex to component candidates\";\n-\n-      -----------\n-      -- Types --\n-      -----------\n-\n-      type String_Ptr is access all String;\n \n       -----------------------\n       -- Local subprograms --\n       -----------------------\n \n-      procedure Add_Vertex\n-        (G      : Library_Graph;\n-         Vertex : Library_Graph_Vertex_Id;\n-         Set    : LGV_Sets.Membership_Set;\n-         Msg    : String;\n-         Step   : Elaboration_Order_Step;\n-         Indent : Indentation_Level);\n-      pragma Inline (Add_Vertex);\n-      --  Add vertex Vertex of library graph G to membership set Set. Msg is\n-      --  a message emitted for tracing purposes. Step is the current step in\n-      --  the elaboration order. Indent is the desired indentation level for\n-      --  tracing.\n-\n-      procedure Add_Vertex_If_Elaborable\n-        (G      : Library_Graph;\n-         Vertex : Library_Graph_Vertex_Id;\n-         Set    : LGV_Sets.Membership_Set;\n-         Msg    : String;\n-         Step   : Elaboration_Order_Step;\n-         Indent : Indentation_Level);\n-      pragma Inline (Add_Vertex_If_Elaborable);\n-      --  Add vertex Vertex of library graph G to membership set Set if it can\n-      --  be elaborated. Msg is a message emitted for tracing purposes. Step is\n-      --  the current step in the elaboration order. Indent is the desired\n-      --  indentation level for tracing.\n-\n-      function Create_All_Candidates_Set\n-        (G    : Library_Graph;\n-         Step : Elaboration_Order_Step) return LGV_Sets.Membership_Set;\n-      pragma Inline (Create_All_Candidates_Set);\n-      --  Collect all elaborable candidate vertices of library graph G in a\n-      --  set. Step is the current step in the elaboration order.\n-\n-      function Create_Component_Candidates_Set\n-        (G    : Library_Graph;\n-         Comp : Component_Id;\n-         Step : Elaboration_Order_Step) return LGV_Sets.Membership_Set;\n-      pragma Inline (Create_Component_Candidates_Set);\n-      --  Collect all elaborable candidate vertices that appear in component\n-      --  Comp of library graph G in a set. Step is the current step in the\n-      --  elaboration order.\n+      procedure Create_Component_Vertex_Sets\n+        (G                   : Library_Graph;\n+         Comp                : Component_Id;\n+         Elaborable_Vertices : out LGV_Sets.Membership_Set;\n+         Waiting_Vertices    : out LGV_Sets.Membership_Set;\n+         Step                : Elaboration_Order_Step);\n+      pragma Inline (Create_Component_Vertex_Sets);\n+      --  Split all vertices of component Comp of library graph G as follows:\n+      --\n+      --    * Elaborable vertices are added to set Elaborable_Vertices.\n+      --\n+      --    * Vertices that are still waiting on their predecessors to be\n+      --      elaborated are added to set Waiting_Vertices.\n+      --\n+      --  Step is the current step in the elaboration order.\n+\n+      procedure Create_Vertex_Sets\n+        (G                   : Library_Graph;\n+         Elaborable_Vertices : out LGV_Sets.Membership_Set;\n+         Waiting_Vertices    : out LGV_Sets.Membership_Set;\n+         Step                : Elaboration_Order_Step);\n+      pragma Inline (Create_Vertex_Sets);\n+      --  Split all vertices of library graph G as follows:\n+      --\n+      --    * Elaborable vertices are added to set Elaborable_Vertices.\n+      --\n+      --    * Vertices that are still waiting on their predecessors to be\n+      --      elaborated are added to set Waiting_Vertices.\n+      --\n+      --  Step is the current step in the elaboration order.\n \n       procedure Elaborate_Component\n-        (G                  : Library_Graph;\n-         Comp               : Component_Id;\n-         All_Candidates     : LGV_Sets.Membership_Set;\n-         Remaining_Vertices : in out Natural;\n-         Order              : in out Unit_Id_Table;\n-         Step               : Elaboration_Order_Step);\n+        (G                       : Library_Graph;\n+         Comp                    : Component_Id;\n+         All_Elaborable_Vertices : LGV_Sets.Membership_Set;\n+         All_Waiting_Vertices    : LGV_Sets.Membership_Set;\n+         Order                   : in out Unit_Id_Table;\n+         Step                    : Elaboration_Order_Step);\n       pragma Inline (Elaborate_Component);\n-      --  Elaborate as many vertices as possible that appear in component\n-      --  Comp of library graph G. All_Candidates is the set of all elaborable\n-      --  vertices across the whole library graph. Remaining_Vertices is the\n-      --  number of vertices that remain to be elaborated. Order denotes the\n-      --  elaboration order. Step is the current step in the elaboration order.\n+      --  Elaborate as many vertices as possible that appear in component Comp\n+      --  of library graph G. The sets contain vertices arranged as follows:\n+      --\n+      --    * All_Elaborable_Vertices - all elaborable vertices in the library\n+      --      graph.\n+      --\n+      --    * All_Waiting_Vertices - all vertices in the library graph that are\n+      --      waiting on predecessors to be elaborated.\n+      --\n+      --  Order is the elaboration order. Step denotes the current step in the\n+      --  elaboration order.\n \n       procedure Elaborate_Library_Graph\n         (G      : Library_Graph;\n@@ -156,81 +139,149 @@ package body Bindo.Elaborators is\n       --  the elaboration order. Status is the condition of the elaboration\n       --  order.\n \n-      procedure Elaborate_Units_Common\n-        (Use_Inv_Graph : Boolean;\n-         Is_Dyn_Elab   : Boolean;\n-         Inv_Graph     : out Invocation_Graph;\n-         Lib_Graph     : out Library_Graph;\n-         Order         : out Unit_Id_Table;\n-         Status        : out Elaboration_Order_Status);\n-      pragma Inline (Elaborate_Units_Common);\n-      --  Find the elaboration order of all units in the bind. Use_Inv_Graph\n-      --  should be set when library graph Lib_Graph is to be augmented with\n-      --  information from invocation graph Inv_Graph. Is_Dyn_Elab should be\n-      --  set when the main library unit was compiled using the dynamic model.\n-      --  Order is the elaboration order. Status is the condition of the\n-      --  elaboration order.\n-\n-      procedure Elaborate_Units_Dynamic (Order : out Unit_Id_Table);\n-      pragma Inline (Elaborate_Units_Dynamic);\n-      --  Find the elaboration order of all units in the bind using the dynamic\n-      --  model. Order is the elaboration order. In the event where no ordering\n-      --  is possible, this routine diagnoses the issue(s) and raises exception\n-      --  Unrecoverable_Error.\n-\n-      procedure Elaborate_Units_Static (Order : out Unit_Id_Table);\n-      pragma Inline (Elaborate_Units_Static);\n-      --  Find the elaboration order of all units in the bind using the static\n-      --  model. Order is the elaboration order. In the event where no ordering\n-      --  is possible, this routine diagnoses the issue(s) and raises exception\n-      --  Unrecoverable_Error.\n-\n       procedure Elaborate_Vertex\n-        (G                  : Library_Graph;\n-         Vertex             : Library_Graph_Vertex_Id;\n-         All_Candidates     : LGV_Sets.Membership_Set;\n-         Comp_Candidates    : LGV_Sets.Membership_Set;\n-         Remaining_Vertices : in out Natural;\n-         Order              : in out Unit_Id_Table;\n-         Step               : Elaboration_Order_Step;\n-         Indent             : Indentation_Level);\n+        (G                        : Library_Graph;\n+         Vertex                   : Library_Graph_Vertex_Id;\n+         All_Elaborable_Vertices  : LGV_Sets.Membership_Set;\n+         All_Waiting_Vertices     : LGV_Sets.Membership_Set;\n+         Comp_Elaborable_Vertices : LGV_Sets.Membership_Set;\n+         Comp_Waiting_Vertices    : LGV_Sets.Membership_Set;\n+         Order                    : in out Unit_Id_Table;\n+         Step                     : Elaboration_Order_Step;\n+         Indent                   : Indentation_Level);\n       pragma Inline (Elaborate_Vertex);\n       --  Elaborate vertex Vertex of library graph G by adding its unit to\n       --  elaboration order Order. The routine updates awaiting successors\n-      --  where applicable. All_Candidates denotes the set of all elaborable\n-      --  vertices across the whole library graph. Comp_Candidates is the set\n-      --  of all elaborable vertices in the component of Vertex. Parameter\n-      --  Remaining_Vertices denotes the number of vertices that remain to\n-      --  be elaborated. Step is the current step in the elaboration order.\n+      --  where applicable. The sets contain vertices arranged as follows:\n+      --\n+      --    * All_Elaborable_Vertices - all elaborable vertices in the library\n+      --      graph.\n+      --\n+      --    * All_Waiting_Vertices - all vertices in the library graph that are\n+      --      waiting on predecessors to be elaborated.\n+      --\n+      --    * Comp_Elaborable_Vertices - all elaborable vertices found in the\n+      --      component of Vertex.\n+      --\n+      --    * Comp_Waiting_Vertices - all vertices found in the component of\n+      --      Vertex that are still waiting on predecessors to be elaborated.\n+      --\n+      --  Order denotes the elaboration order. Step is the current step in the\n+      --  elaboration order. Indent denotes the desired indentation level for\n+      --  tracing.\n+\n+      function Find_Best_Elaborable_Vertex\n+        (G      : Library_Graph;\n+         Set    : LGV_Sets.Membership_Set;\n+         Step   : Elaboration_Order_Step;\n+         Indent : Indentation_Level) return Library_Graph_Vertex_Id;\n+      pragma Inline (Find_Best_Elaborable_Vertex);\n+      --  Find the best vertex of library graph G from membership set S that\n+      --  can be elaborated. Step is the current step in the elaboration order.\n       --  Indent is the desired indentation level for tracing.\n \n-      function Find_Best_Candidate\n+      type Comparator_Ptr is access function\n+        (G           : Library_Graph;\n+         Vertex      : Library_Graph_Vertex_Id;\n+         Compared_To : Library_Graph_Vertex_Id) return Precedence_Kind;\n+\n+      type Predicate_Ptr is access function\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n+\n+      function Find_Best_Vertex\n+        (G                   : Library_Graph;\n+         Set                 : LGV_Sets.Membership_Set;\n+         Is_Suitable_Vertex  : Predicate_Ptr;\n+         Compare_Vertices    : Comparator_Ptr;\n+         Initial_Best_Msg    : String;\n+         Subsequent_Best_Msg : String;\n+         Step                : Elaboration_Order_Step;\n+         Indent              : Indentation_Level)\n+         return Library_Graph_Vertex_Id;\n+      pragma Inline (Find_Best_Vertex);\n+      --  Find the best vertex of library graph G from membership set S which\n+      --  satisfies predicate Is_Suitable_Vertex and is preferred by comparator\n+      --  Compare_Vertices. Initial_Best_Msg is emitted on the first candidate\n+      --  vertex. Subsequent_Best_Msg is emitted whenever a better vertex is\n+      --  discovered. Step is the current step in the elaboration order. Indent\n+      --  is the desired indentation level for tracing.\n+\n+      function Find_Best_Weakly_Elaborable_Vertex\n         (G      : Library_Graph;\n          Set    : LGV_Sets.Membership_Set;\n          Step   : Elaboration_Order_Step;\n          Indent : Indentation_Level) return Library_Graph_Vertex_Id;\n-      pragma Inline (Find_Best_Candidate);\n-      --  Find the most suitable vertex of library graph G for elaboration from\n-      --  membership set Set. Step denotes the current step in the elaboration\n+      pragma Inline (Find_Best_Weakly_Elaborable_Vertex);\n+      --  Find the best vertex of library graph G from membership set S that\n+      --  can be weakly elaborated. Step is the current step in the elaboration\n       --  order. Indent is the desired indentation level for tracing.\n \n-      function Is_Better_Candidate\n-        (G              : Library_Graph;\n-         Best_Candidate : Library_Graph_Vertex_Id;\n-         New_Candidate  : Library_Graph_Vertex_Id) return Boolean;\n-      pragma Inline (Is_Better_Candidate);\n-      --  Determine whether new candidate vertex New_Candidate of library graph\n-      --  G is a more suitable choice for elaboration compared to the current\n-      --  best candidate Best_Candidate.\n+      function Has_Elaborable_Body\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Has_Elaborable_Body);\n+      --  Determine whether vertex Vertex of library graph G has a body that is\n+      --  elaborable. It is assumed that the vertex has been elaborated.\n+\n+      procedure Insert_Elaborable_Successor\n+        (G                     : Library_Graph;\n+         Vertex                : Library_Graph_Vertex_Id;\n+         Elaborable_Vertices   : LGV_Sets.Membership_Set;\n+         All_Waiting_Vertices  : LGV_Sets.Membership_Set;\n+         Comp_Waiting_Vertices : LGV_Sets.Membership_Set;\n+         Msg                   : String;\n+         Step                  : Elaboration_Order_Step;\n+         Indent                : Indentation_Level);\n+      pragma Inline (Insert_Elaborable_Successor);\n+      --  Add elaborable successor Vertex of library graph G to membership set\n+      --  Elaborable_Vertices and remove it from both All_Waiting_Vertices and\n+      --  Comp_Waiting_Vertices. Msg is a message emitted for tracing purposes.\n+      --  Step is the current step in the elaboration order. Indent denotes the\n+      --  desired indentation level for tracing.\n+\n+      procedure Insert_Vertex\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id;\n+         Set    : LGV_Sets.Membership_Set;\n+         Msg    : String;\n+         Step   : Elaboration_Order_Step;\n+         Indent : Indentation_Level);\n+      pragma Inline (Insert_Vertex);\n+      --  Add vertex Vertex of library graph G to membership set Set. Msg is\n+      --  a message emitted for tracing purposes. Step is the current step in\n+      --  the elaboration order. Indent is the desired indentation level for\n+      --  tracing.\n \n-      procedure Trace_Candidate_Vertices\n-        (G    : Library_Graph;\n-         Set  : LGV_Sets.Membership_Set;\n-         Step : Elaboration_Order_Step);\n-      pragma Inline (Trace_Candidate_Vertices);\n-      --  Write the candidate vertices of library graph G present in membership\n-      --  set Set to standard output. Formal Step denotes the current step in\n-      --  the elaboration order.\n+      function Is_Better_Elaborable_Vertex\n+        (G           : Library_Graph;\n+         Vertex      : Library_Graph_Vertex_Id;\n+         Compared_To : Library_Graph_Vertex_Id) return Precedence_Kind;\n+      pragma Inline (Is_Better_Elaborable_Vertex);\n+      --  Determine whether vertex Vertex of library graph G is a better choice\n+      --  for elaboration compared to vertex Compared_To.\n+\n+      function Is_Better_Weakly_Elaborable_Vertex\n+        (G           : Library_Graph;\n+         Vertex      : Library_Graph_Vertex_Id;\n+         Compared_To : Library_Graph_Vertex_Id) return Precedence_Kind;\n+      pragma Inline (Is_Better_Weakly_Elaborable_Vertex);\n+      --  Determine whether vertex Vertex of library graph G is a better choice\n+      --  for weak elaboration compared to vertex Compared_To.\n+\n+      function Is_Suitable_Elaborable_Vertex\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Suitable_Elaborable_Vertex);\n+      --  Determine whether vertex Vertex of library graph G is suitable for\n+      --  elaboration.\n+\n+      function Is_Suitable_Weakly_Elaborable_Vertex\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Suitable_Weakly_Elaborable_Vertex);\n+      --  Determine whether vertex Vertex of library graph G is suitable for\n+      --  weak elaboration.\n \n       procedure Trace_Component\n         (G    : Library_Graph;\n@@ -246,15 +297,6 @@ package body Bindo.Elaborators is\n       pragma Inline (Trace_Step);\n       --  Write current step Step of the elaboration order to standard output\n \n-      procedure Trace_Unelaborated_Vertices\n-        (G     : Library_Graph;\n-         Count : Natural;\n-         Step  : Elaboration_Order_Step);\n-      pragma Inline (Trace_Unelaborated_Vertices);\n-      --  Write the remaining unelaborated vertices of library graph G to\n-      --  standard output. Count is the number of vertices that remain to\n-      --  be elaborated. Step is the current step in the elaboration order.\n-\n       procedure Trace_Vertex\n         (G      : Library_Graph;\n          Vertex : Library_Graph_Vertex_Id;\n@@ -267,256 +309,284 @@ package body Bindo.Elaborators is\n       --  current step in the elaboration order. Indent denotes the desired\n       --  indentation level for tracing.\n \n+      procedure Trace_Vertices\n+        (G          : Library_Graph;\n+         Set        : LGV_Sets.Membership_Set;\n+         Set_Msg    : String;\n+         Vertex_Msg : String;\n+         Step       : Elaboration_Order_Step;\n+         Indent     : Indentation_Level);\n+      pragma Inline (Trace_Vertices);\n+      --  Write the candidate vertices of library graph G present in membership\n+      --  set Set to standard output, starting with message Set_Msg. Vertex_Msg\n+      --  is the message emitted prior to each vertex. Step denotes the current\n+      --  step in the elaboration order. Indent denotes the desired indentation\n+      --  level for tracing.\n+\n       procedure Update_Successor\n-        (G               : Library_Graph;\n-         Pred            : Library_Graph_Vertex_Id;\n-         Succ            : Library_Graph_Vertex_Id;\n-         All_Candidates  : LGV_Sets.Membership_Set;\n-         Comp_Candidates : LGV_Sets.Membership_Set;\n-         Step            : Elaboration_Order_Step;\n-         Indent          : Indentation_Level);\n+        (G                        : Library_Graph;\n+         Edge                     : Library_Graph_Edge_Id;\n+         All_Elaborable_Vertices  : LGV_Sets.Membership_Set;\n+         All_Waiting_Vertices     : LGV_Sets.Membership_Set;\n+         Comp_Elaborable_Vertices : LGV_Sets.Membership_Set;\n+         Comp_Waiting_Vertices    : LGV_Sets.Membership_Set;\n+         Step                     : Elaboration_Order_Step;\n+         Indent                   : Indentation_Level);\n       pragma Inline (Update_Successor);\n-      --  Notify successor vertex Succ of library graph G along with its\n-      --  component that their predecessor Pred has just been elaborated.\n-      --  This may cause new vertices to become elaborable, and thus be added\n-      --  to one of the two sets. All_Candidates is the set of all elaborable\n-      --  vertices across the whole library graph. Comp_Candidates is the set\n-      --  of all elaborable vertices in the component of Pred. Step is the\n-      --  current step in the elaboration order. Indent denotes the desired\n-      --  indentation level for tracing.\n+      --  Notify the successor of edge Edge of library graph G along with its\n+      --  component that their predecessor has just been elaborated. This may\n+      --  cause new vertices to become elaborable. The sets contain vertices\n+      --  arranged as follows:\n+      --\n+      --    * All_Elaborable_Vertices - all elaborable vertices in the library\n+      --      graph.\n+      --\n+      --    * All_Waiting_Vertices - all vertices in the library graph that are\n+      --      waiting on predecessors to be elaborated.\n+      --\n+      --    * Comp_Elaborable_Vertices - all elaborable vertices found in the\n+      --      component of Vertex.\n+      --\n+      --    * Comp_Waiting_Vertices - all vertices found in the component of\n+      --      Vertex that are still waiting on predecessors to be elaborated.\n+      --\n+      --  Step is the current step in the elaboration order. Indent denotes the\n+      --  desired indentation level for tracing.\n \n       procedure Update_Successors\n-        (G               : Library_Graph;\n-         Pred            : Library_Graph_Vertex_Id;\n-         All_Candidates  : LGV_Sets.Membership_Set;\n-         Comp_Candidates : LGV_Sets.Membership_Set;\n-         Step            : Elaboration_Order_Step;\n-         Indent          : Indentation_Level);\n+        (G                        : Library_Graph;\n+         Vertex                   : Library_Graph_Vertex_Id;\n+         All_Elaborable_Vertices  : LGV_Sets.Membership_Set;\n+         All_Waiting_Vertices     : LGV_Sets.Membership_Set;\n+         Comp_Elaborable_Vertices : LGV_Sets.Membership_Set;\n+         Comp_Waiting_Vertices    : LGV_Sets.Membership_Set;\n+         Step                     : Elaboration_Order_Step;\n+         Indent                   : Indentation_Level);\n       pragma Inline (Update_Successors);\n-      --  Notify all successors along with their components that their\n-      --  predecessor vertex Pred of ligrary graph G has just been elaborated.\n-      --  This may cause new vertices to become elaborable, and thus be added\n-      --  to one of the two sets. All_Candidates is the set of all elaborable\n-      --  vertices across the whole library graph. Comp_Candidates is the set\n-      --  of all elaborable vertices in the component of Pred. Step is the\n-      --  current step in the elaboration order. Indent denotes the desired\n-      --  indentation level for tracing.\n-\n-      ----------------\n-      -- Add_Vertex --\n-      ----------------\n-\n-      procedure Add_Vertex\n-        (G      : Library_Graph;\n-         Vertex : Library_Graph_Vertex_Id;\n-         Set    : LGV_Sets.Membership_Set;\n-         Msg    : String;\n-         Step   : Elaboration_Order_Step;\n-         Indent : Indentation_Level)\n+      --  Notify all successors of vertex Vertex of library graph G along with\n+      --  their components that their predecessor has just been elaborated.\n+      --  This may cause new vertices to become elaborable. The sets contain\n+      --  vertices arranged as follows:\n+      --\n+      --    * All_Elaborable_Vertices - all elaborable vertices in the library\n+      --      graph.\n+      --\n+      --    * All_Waiting_Vertices - all vertices in the library graph that are\n+      --      waiting on predecessors to be elaborated.\n+      --\n+      --    * Comp_Elaborable_Vertices - all elaborable vertices found in the\n+      --      component of Vertex.\n+      --\n+      --    * Comp_Waiting_Vertices - all vertices found in the component of\n+      --      Vertex that are still waiting on predecessors to be elaborated.\n+      --\n+      --  Step is the current step in the elaboration order. Indent denotes the\n+      --  desired indentation level for tracing.\n+\n+      ----------------------------------\n+      -- Create_Component_Vertex_Sets --\n+      ----------------------------------\n+\n+      procedure Create_Component_Vertex_Sets\n+        (G                   : Library_Graph;\n+         Comp                : Component_Id;\n+         Elaborable_Vertices : out LGV_Sets.Membership_Set;\n+         Waiting_Vertices    : out LGV_Sets.Membership_Set;\n+         Step                : Elaboration_Order_Step)\n       is\n-      begin\n-         pragma Assert (Present (Vertex));\n-         pragma Assert (Needs_Elaboration (G, Vertex));\n-         pragma Assert (LGV_Sets.Present (Set));\n-\n-         --  Add vertex only when it is not present in the set. This is not\n-         --  strictly necessary because the set implementation handles this\n-         --  case, however the check eliminates spurious traces.\n-\n-         if not LGV_Sets.Contains (Set, Vertex) then\n-            Trace_Vertex\n-              (G      => G,\n-               Vertex => Vertex,\n-               Msg    => Msg,\n-               Step   => Step,\n-               Indent => Indent);\n-\n-            LGV_Sets.Insert (Set, Vertex);\n-         end if;\n-      end Add_Vertex;\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n \n-      ------------------------------\n-      -- Add_Vertex_If_Elaborable --\n-      ------------------------------\n+         Num_Of_Vertices : constant Natural :=\n+                             Number_Of_Component_Vertices (G, Comp);\n \n-      procedure Add_Vertex_If_Elaborable\n-        (G      : Library_Graph;\n+         Iter   : Component_Vertex_Iterator;\n          Vertex : Library_Graph_Vertex_Id;\n-         Set    : LGV_Sets.Membership_Set;\n-         Msg    : String;\n-         Step   : Elaboration_Order_Step;\n-         Indent : Indentation_Level)\n-      is\n-         Extra_Vertex : Library_Graph_Vertex_Id;\n \n       begin\n-         pragma Assert (Present (G));\n-         pragma Assert (Present (Vertex));\n-         pragma Assert (Needs_Elaboration (G, Vertex));\n-         pragma Assert (LGV_Sets.Present (Set));\n-\n-         if Is_Elaborable_Vertex (G, Vertex) then\n-            Add_Vertex\n-              (G      => G,\n-               Vertex => Vertex,\n-               Set    => Set,\n-               Msg    => Msg,\n-               Step   => Step,\n-               Indent => Indent);\n-\n-            --  Assume that there is no extra vertex that needs to be added\n+         Elaborable_Vertices := LGV_Sets.Create (Num_Of_Vertices);\n+         Waiting_Vertices    := LGV_Sets.Create (Num_Of_Vertices);\n \n-            Extra_Vertex := No_Library_Graph_Vertex;\n-\n-            --  A spec-body pair where the spec carries pragma Elaborate_Body\n-            --  must be treated as one vertex for elaboration purposes. If one\n-            --  of them is elaborable, then the other is also elaborable. This\n-            --  property is guaranteed by predicate Is_Elaborable_Vertex.\n-\n-            if Is_Body_Of_Spec_With_Elaborate_Body (G, Vertex) then\n-               Extra_Vertex := Proper_Spec (G, Vertex);\n-               pragma Assert (Present (Extra_Vertex));\n+         Iter := Iterate_Component_Vertices (G, Comp);\n+         while Has_Next (Iter) loop\n+            Next (Iter, Vertex);\n \n-            elsif Is_Spec_With_Elaborate_Body (G, Vertex) then\n-               Extra_Vertex := Proper_Body (G, Vertex);\n-               pragma Assert (Present (Extra_Vertex));\n-            end if;\n+            --  Add the vertex to the proper set depending on whether it can be\n+            --  elaborated.\n \n-            if Present (Extra_Vertex) then\n-               pragma Assert (Needs_Elaboration (G, Extra_Vertex));\n+            if Is_Elaborable_Vertex (G, Vertex) then\n+               Insert_Vertex\n+                 (G      => G,\n+                  Vertex => Vertex,\n+                  Set    => Elaborable_Vertices,\n+                  Msg    => \"add elaborable component vertex\",\n+                  Step   => Step,\n+                  Indent => No_Indentation);\n \n-               Add_Vertex\n+            else\n+               Insert_Vertex\n                  (G      => G,\n-                  Vertex => Extra_Vertex,\n-                  Set    => Set,\n-                  Msg    => Msg,\n+                  Vertex => Vertex,\n+                  Set    => Waiting_Vertices,\n+                  Msg    => \"add waiting component vertex\",\n                   Step   => Step,\n-                  Indent => Indent);\n+                  Indent => No_Indentation);\n             end if;\n-         end if;\n-      end Add_Vertex_If_Elaborable;\n+         end loop;\n+      end Create_Component_Vertex_Sets;\n \n-      -------------------------------\n-      -- Create_All_Candidates_Set --\n-      -------------------------------\n+      ------------------------\n+      -- Create_Vertex_Sets --\n+      ------------------------\n \n-      function Create_All_Candidates_Set\n-        (G    : Library_Graph;\n-         Step : Elaboration_Order_Step) return LGV_Sets.Membership_Set\n+      procedure Create_Vertex_Sets\n+        (G                   : Library_Graph;\n+         Elaborable_Vertices : out LGV_Sets.Membership_Set;\n+         Waiting_Vertices    : out LGV_Sets.Membership_Set;\n+         Step                : Elaboration_Order_Step)\n       is\n+         pragma Assert (Present (G));\n+\n+         Num_Of_Vertices : constant Natural := Number_Of_Vertices (G);\n+\n          Iter   : Library_Graphs.All_Vertex_Iterator;\n-         Set    : LGV_Sets.Membership_Set;\n          Vertex : Library_Graph_Vertex_Id;\n \n       begin\n-         pragma Assert (Present (G));\n+         Elaborable_Vertices := LGV_Sets.Create (Num_Of_Vertices);\n+         Waiting_Vertices    := LGV_Sets.Create (Num_Of_Vertices);\n \n-         Set  := LGV_Sets.Create (Number_Of_Vertices (G));\n          Iter := Iterate_All_Vertices (G);\n          while Has_Next (Iter) loop\n             Next (Iter, Vertex);\n \n-            Add_Vertex_If_Elaborable\n-              (G      => G,\n-               Vertex => Vertex,\n-               Set    => Set,\n-               Msg    => Add_To_All_Candidates_Msg,\n-               Step   => Step,\n-               Indent => No_Indentation);\n-         end loop;\n-\n-         return Set;\n-      end Create_All_Candidates_Set;\n-\n-      -------------------------------------\n-      -- Create_Component_Candidates_Set --\n-      -------------------------------------\n-\n-      function Create_Component_Candidates_Set\n-        (G    : Library_Graph;\n-         Comp : Component_Id;\n-         Step : Elaboration_Order_Step) return LGV_Sets.Membership_Set\n-      is\n-         Iter   : Component_Vertex_Iterator;\n-         Set    : LGV_Sets.Membership_Set;\n-         Vertex : Library_Graph_Vertex_Id;\n-\n-      begin\n-         pragma Assert (Present (G));\n-         pragma Assert (Present (Comp));\n+            --  Add the vertex to the proper set depending on whether it can be\n+            --  elaborated.\n \n-         Set  := LGV_Sets.Create (Number_Of_Component_Vertices (G, Comp));\n-         Iter := Iterate_Component_Vertices (G, Comp);\n-         while Has_Next (Iter) loop\n-            Next (Iter, Vertex);\n+            if Is_Elaborable_Vertex (G, Vertex) then\n+               Insert_Vertex\n+                 (G      => G,\n+                  Vertex => Vertex,\n+                  Set    => Elaborable_Vertices,\n+                  Msg    => \"add elaborable vertex\",\n+                  Step   => Step,\n+                  Indent => No_Indentation);\n \n-            Add_Vertex_If_Elaborable\n-              (G      => G,\n-               Vertex => Vertex,\n-               Set    => Set,\n-               Msg    => Add_To_Comp_Candidates_Msg,\n-               Step   => Step,\n-               Indent => No_Indentation);\n+            else\n+               Insert_Vertex\n+                 (G      => G,\n+                  Vertex => Vertex,\n+                  Set    => Waiting_Vertices,\n+                  Msg    => \"add waiting vertex\",\n+                  Step   => Step,\n+                  Indent => No_Indentation);\n+            end if;\n          end loop;\n-\n-         return Set;\n-      end Create_Component_Candidates_Set;\n+      end Create_Vertex_Sets;\n \n       -------------------------\n       -- Elaborate_Component --\n       -------------------------\n \n       procedure Elaborate_Component\n-        (G                  : Library_Graph;\n-         Comp               : Component_Id;\n-         All_Candidates     : LGV_Sets.Membership_Set;\n-         Remaining_Vertices : in out Natural;\n-         Order              : in out Unit_Id_Table;\n-         Step               : Elaboration_Order_Step)\n+        (G                       : Library_Graph;\n+         Comp                    : Component_Id;\n+         All_Elaborable_Vertices : LGV_Sets.Membership_Set;\n+         All_Waiting_Vertices    : LGV_Sets.Membership_Set;\n+         Order                   : in out Unit_Id_Table;\n+         Step                    : Elaboration_Order_Step)\n       is\n-         Candidate       : Library_Graph_Vertex_Id;\n-         Comp_Candidates : LGV_Sets.Membership_Set;\n+         Comp_Elaborable_Vertices : LGV_Sets.Membership_Set;\n+         Comp_Waiting_Vertices    : LGV_Sets.Membership_Set;\n+         Vertex                   : Library_Graph_Vertex_Id;\n \n       begin\n          pragma Assert (Present (G));\n          pragma Assert (Present (Comp));\n-         pragma Assert (LGV_Sets.Present (All_Candidates));\n+         pragma Assert (LGV_Sets.Present (All_Elaborable_Vertices));\n+         pragma Assert (LGV_Sets.Present (All_Waiting_Vertices));\n \n          Trace_Component\n            (G    => G,\n             Comp => Comp,\n             Msg  => \"elaborating component\",\n             Step => Step);\n \n-         Comp_Candidates := Create_Component_Candidates_Set (G, Comp, Step);\n+         --  Divide all vertices of the component into an elaborable and\n+         --  waiting vertex set.\n+\n+         Create_Component_Vertex_Sets\n+           (G                   => G,\n+            Comp                => Comp,\n+            Elaborable_Vertices => Comp_Elaborable_Vertices,\n+            Waiting_Vertices    => Comp_Waiting_Vertices,\n+            Step                => Step);\n \n          loop\n-            Candidate :=\n-              Find_Best_Candidate\n+            Trace_Vertices\n+              (G          => G,\n+               Set        => Comp_Elaborable_Vertices,\n+               Set_Msg    => \"elaborable component vertices\",\n+               Vertex_Msg => \"elaborable component vertex\",\n+               Step       => Step,\n+               Indent     => Nested_Indentation);\n+\n+            Trace_Vertices\n+              (G          => G,\n+               Set        => Comp_Waiting_Vertices,\n+               Set_Msg    => \"waiting component vertices\",\n+               Vertex_Msg => \"waiting component vertex\",\n+               Step       => Step,\n+               Indent     => Nested_Indentation);\n+\n+            Vertex :=\n+              Find_Best_Elaborable_Vertex\n                 (G      => G,\n-                 Set    => Comp_Candidates,\n+                 Set    => Comp_Elaborable_Vertices,\n                  Step   => Step,\n                  Indent => Nested_Indentation);\n \n-            --  Stop the elaboration of the component when there is no suitable\n-            --  candidate. This indicates that either all vertices within the\n-            --  component have been elaborated, or the library graph contains a\n-            --  circularity.\n+            --  The component lacks an elaborable vertex. This indicates that\n+            --  either all vertices of the component have been elaborated or\n+            --  the graph has a circularity. Locate the best weak vertex that\n+            --  was compiled with the dynamic model to elaborate from the set\n+            --  waiting vertices. This action assumes that certain invocations\n+            --  will not take place at elaboration time. An order produced in\n+            --  this fashion may fail an ABE check at run time.\n+\n+            if not Present (Vertex) then\n+               Vertex :=\n+                 Find_Best_Weakly_Elaborable_Vertex\n+                   (G      => G,\n+                    Set    => Comp_Waiting_Vertices,\n+                    Step   => Step,\n+                    Indent => Nested_Indentation);\n+            end if;\n+\n+            --  Stop the elaboration when either all vertices of the component\n+            --  have been elaborated, or the graph contains a circularity.\n+\n+            exit when not Present (Vertex);\n \n-            exit when not Present (Candidate);\n+            --  Try to elaborate as many vertices within the component as\n+            --  possible. Each successful elaboration signals the appropriate\n+            --  successors and components that they have one less predecessor\n+            --  to wait on.\n \n             Elaborate_Vertex\n-              (G                  => G,\n-               Vertex             => Candidate,\n-               All_Candidates     => All_Candidates,\n-               Comp_Candidates    => Comp_Candidates,\n-               Remaining_Vertices => Remaining_Vertices,\n-               Order              => Order,\n-               Step               => Step,\n-               Indent             => Nested_Indentation);\n+              (G                        => G,\n+               Vertex                   => Vertex,\n+               All_Elaborable_Vertices  => All_Elaborable_Vertices,\n+               All_Waiting_Vertices     => All_Waiting_Vertices,\n+               Comp_Elaborable_Vertices => Comp_Elaborable_Vertices,\n+               Comp_Waiting_Vertices    => Comp_Waiting_Vertices,\n+               Order                    => Order,\n+               Step                     => Step,\n+               Indent                   => Nested_Indentation);\n          end loop;\n \n-         LGV_Sets.Destroy (Comp_Candidates);\n+         LGV_Sets.Destroy (Comp_Elaborable_Vertices);\n+         LGV_Sets.Destroy (Comp_Waiting_Vertices);\n       end Elaborate_Component;\n \n       -----------------------------\n@@ -528,80 +598,107 @@ package body Bindo.Elaborators is\n          Order  : out Unit_Id_Table;\n          Status : out Elaboration_Order_Status)\n       is\n-         All_Candidates     : LGV_Sets.Membership_Set;\n-         Candidate          : Library_Graph_Vertex_Id;\n-         Remaining_Vertices : Natural;\n-         Step               : Elaboration_Order_Step;\n+         Elaborable_Vertices : LGV_Sets.Membership_Set;\n+         Step                : Elaboration_Order_Step;\n+         Vertex              : Library_Graph_Vertex_Id;\n+         Waiting_Vertices    : LGV_Sets.Membership_Set;\n \n       begin\n          pragma Assert (Present (G));\n \n          Step := Initial_Step;\n \n-         All_Candidates     := Create_All_Candidates_Set (G, Step);\n-         Remaining_Vertices := Number_Of_Vertices (G);\n+         --  Divide all vertices of the library graph into an elaborable and\n+         --  waiting vertex set.\n+\n+         Create_Vertex_Sets\n+           (G                   => G,\n+            Elaborable_Vertices => Elaborable_Vertices,\n+            Waiting_Vertices    => Waiting_Vertices,\n+            Step                => Step);\n \n          loop\n             Step := Step + 1;\n \n-            Trace_Candidate_Vertices\n-              (G    => G,\n-               Set  => All_Candidates,\n-               Step => Step);\n-\n-            Trace_Unelaborated_Vertices\n-              (G     => G,\n-               Count => Remaining_Vertices,\n-               Step  => Step);\n-\n-            Candidate :=\n-              Find_Best_Candidate\n+            Trace_Vertices\n+              (G          => G,\n+               Set        => Elaborable_Vertices,\n+               Set_Msg    => \"elaborable vertices\",\n+               Vertex_Msg => \"elaborable vertex\",\n+               Step       => Step,\n+               Indent     => No_Indentation);\n+\n+            Trace_Vertices\n+              (G          => G,\n+               Set        => Waiting_Vertices,\n+               Set_Msg    => \"waiting vertices\",\n+               Vertex_Msg => \"waiting vertex\",\n+               Step       => Step,\n+               Indent     => No_Indentation);\n+\n+            Vertex :=\n+              Find_Best_Elaborable_Vertex\n                 (G      => G,\n-                 Set    => All_Candidates,\n+                 Set    => Elaborable_Vertices,\n                  Step   => Step,\n                  Indent => No_Indentation);\n \n-            --  Stop the elaboration when there is no suitable candidate. This\n-            --  indicates that either all units were elaborated or the library\n-            --  graph contains a circularity.\n+            --  The graph lacks an elaborable vertex. This indicates that\n+            --  either all vertices have been elaborated or the graph has a\n+            --  circularity. Find the best weak vertex that was compiled with\n+            --  the dynamic model to elaborate from set of waiting vertices.\n+            --  This action assumes that certain invocations will not take\n+            --  place at elaboration time. An order produced in this fashion\n+            --  may fail an ABE check at run time.\n+\n+            if not Present (Vertex) then\n+               Vertex :=\n+                 Find_Best_Weakly_Elaborable_Vertex\n+                   (G      => G,\n+                    Set    => Waiting_Vertices,\n+                    Step   => Step,\n+                    Indent => No_Indentation);\n+            end if;\n+\n+            --  Stop the elaboration when either all vertices of the graph have\n+            --  been elaborated, or the graph contains a circularity.\n \n-            exit when not Present (Candidate);\n+            exit when not Present (Vertex);\n \n-            --  Elaborate the component of the candidate vertex by trying to\n-            --  elaborate as many vertices within the component as possible.\n-            --  Each successful elaboration signals the appropriate successors\n-            --  and their components that they have one less predecessor to\n-            --  wait on. This may add new candidates to set All_Candidates.\n+            --  Elaborate the component of the vertex by trying to elaborate as\n+            --  many vertices within the component as possible. Each successful\n+            --  elaboration signals the appropriate successors and components\n+            --  that they have one less predecessor to wait on.\n \n             Elaborate_Component\n-              (G                  => G,\n-               Comp               => Component (G, Candidate),\n-               All_Candidates     => All_Candidates,\n-               Remaining_Vertices => Remaining_Vertices,\n-               Order              => Order,\n-               Step               => Step);\n+              (G                       => G,\n+               Comp                    => Component (G, Vertex),\n+               All_Elaborable_Vertices => Elaborable_Vertices,\n+               All_Waiting_Vertices    => Waiting_Vertices,\n+               Order                   => Order,\n+               Step                    => Step);\n          end loop;\n \n-         LGV_Sets.Destroy (All_Candidates);\n-\n-         --  The library graph contains an Elaborate_All circularity when\n-         --  at least one edge subject to the related pragma appears in a\n-         --  component.\n+         --  The graph contains an Elaborate_All circularity when at least one\n+         --  edge subject to the related pragma appears in a component.\n \n          if Has_Elaborate_All_Cycle (G) then\n             Status := Order_Has_Elaborate_All_Circularity;\n \n-         --  The library contains a circularity when at least one vertex failed\n+         --  The graph contains a circularity when at least one vertex failed\n          --  to elaborate.\n \n-         elsif Remaining_Vertices /= 0 then\n+         elsif LGV_Sets.Size (Waiting_Vertices) /= 0 then\n             Status := Order_Has_Circularity;\n \n          --  Otherwise the elaboration order is satisfactory\n \n          else\n             Status := Order_OK;\n          end if;\n+\n+         LGV_Sets.Destroy (Elaborable_Vertices);\n+         LGV_Sets.Destroy (Waiting_Vertices);\n       end Elaborate_Library_Graph;\n \n       ---------------------\n@@ -612,271 +709,114 @@ package body Bindo.Elaborators is\n         (Order         : out Unit_Id_Table;\n          Main_Lib_File : File_Name_Type)\n       is\n-         Main_Lib_Unit : constant Unit_Id :=\n-                           Corresponding_Unit (Unit_Name_Type (Main_Lib_File));\n+         pragma Unreferenced (Main_Lib_File);\n \n-      begin\n-         pragma Assert (Present (Main_Lib_Unit));\n+         Inv_Graph : Invocation_Graph;\n+         Lib_Graph : Library_Graph;\n+         Status    : Elaboration_Order_Status;\n \n+      begin\n          --  Initialize all unit-related data structures and gather all units\n          --  that need elaboration.\n \n          Initialize_Units;\n          Collect_Elaborable_Units;\n \n-         Write_ALI_Tables;\n-\n-         --  Choose the proper elaboration strategy based on whether the main\n-         --  library unit was compiled using the dynamic model.\n-\n-         if Is_Dynamically_Elaborated (Main_Lib_Unit) then\n-            Elaborate_Units_Dynamic (Order);\n-         else\n-            Elaborate_Units_Static (Order);\n-         end if;\n-\n-         Validate_Elaboration_Order (Order);\n-         Write_Elaboration_Order    (Order);\n-\n-         --  Enumerate the sources referenced in the closure of the order\n-\n-         Write_Unit_Closure (Order);\n-\n-         --  Destroy all unit-delated data structures\n-\n-         Finalize_Units;\n-\n-      exception\n-         when others =>\n-            Finalize_Units;\n-            raise;\n-      end Elaborate_Units;\n-\n-      ----------------------------\n-      -- Elaborate_Units_Common --\n-      ----------------------------\n-\n-      procedure Elaborate_Units_Common\n-        (Use_Inv_Graph : Boolean;\n-         Is_Dyn_Elab   : Boolean;\n-         Inv_Graph     : out Invocation_Graph;\n-         Lib_Graph     : out Library_Graph;\n-         Order         : out Unit_Id_Table;\n-         Status        : out Elaboration_Order_Status)\n-      is\n-      begin\n-         --  Create, validate, and output the library graph that captures the\n-         --  dependencies between library items.\n-\n-         Lib_Graph := Build_Library_Graph (Is_Dyn_Elab);\n-         Validate_Library_Graph (Lib_Graph);\n-         Write_Library_Graph    (Lib_Graph);\n-\n-         --  Create, validate, output, and use the invocation graph that\n-         --  represents the flow of execusion only when requested by the\n-         --  caller.\n+         --  Create the library graph that captures the dependencies between\n+         --  library items.\n \n-         if Use_Inv_Graph then\n-            Inv_Graph := Build_Invocation_Graph (Lib_Graph);\n-            Validate_Invocation_Graph (Inv_Graph);\n-            Write_Invocation_Graph    (Inv_Graph);\n+         Lib_Graph := Build_Library_Graph;\n \n-         --  Otherwise the invocation graph is not used. Create a dummy graph\n-         --  as this allows for a uniform behavior on the caller side.\n+         --  Create the invocation graph that represents the flow of execution\n \n-         else\n-            Inv_Graph :=\n-              Invocation_Graphs.Create\n-                (Initial_Vertices => 1,\n-                 Initial_Edges    => 1);\n-         end if;\n+         Inv_Graph := Build_Invocation_Graph (Lib_Graph);\n \n          --  Traverse the invocation graph starting from elaboration code in\n          --  order to discover transitions of the execution flow from a unit\n          --  to a unit that result in extra edges within the library graph.\n \n          Augment_Library_Graph (Inv_Graph, Lib_Graph);\n-         Write_Library_Graph (Lib_Graph);\n \n-         --  Create and output the component graph by collapsing all library\n-         --  items into library units and traversing the library graph.\n+         --  Create the component graph by collapsing all library items into\n+         --  library units and traversing the library graph.\n \n-         Find_Components  (Lib_Graph);\n-         Write_Components (Lib_Graph);\n+         Find_Components (Lib_Graph);\n \n-         --  Traverse the library graph to determine the elaboration order of\n-         --  units.\n+         --  Output the contents of the ALI tables and both graphs to standard\n+         --  output now that they have been fully decorated.\n \n-         Elaborate_Library_Graph\n-           (G      => Lib_Graph,\n-            Order  => Order,\n-            Status => Status);\n-      end Elaborate_Units_Common;\n-\n-      -----------------------------\n-      -- Elaborate_Units_Dynamic --\n-      -----------------------------\n+         Write_ALI_Tables;\n+         Write_Invocation_Graph (Inv_Graph);\n+         Write_Library_Graph    (Lib_Graph);\n \n-      procedure Elaborate_Units_Dynamic (Order : out Unit_Id_Table) is\n-         Dyn_Inv_Graph : Invocation_Graph;\n-         Dyn_Lib_Graph : Library_Graph;\n-         Dyn_Order     : Unit_Id_Table;\n-         Mix_Inv_Graph : Invocation_Graph;\n-         Mix_Lib_Graph : Library_Graph;\n-         Mix_Order     : Unit_Id_Table;\n-         Status        : Elaboration_Order_Status;\n+         --  Traverse the library graph to determine the elaboration order of\n+         --  units.\n \n-      begin\n-         --  Attempt to elaborate the units in the library graph by mixing in\n-         --  the information from the invocation graph. This assumes that all\n-         --  invocations will take place at elaboration time.\n-\n-         Elaborate_Units_Common\n-           (Use_Inv_Graph => True,\n-            Is_Dyn_Elab   => True,\n-            Inv_Graph     => Mix_Inv_Graph,\n-            Lib_Graph     => Mix_Lib_Graph,\n-            Order         => Mix_Order,\n-            Status        => Status);\n+         Elaborate_Library_Graph (Lib_Graph, Order, Status);\n \n          --  The elaboration order is satisfactory\n \n          if Status = Order_OK then\n-            Order := Mix_Order;\n+            Validate_Elaboration_Order (Order);\n \n-            --  Output the dependencies of vertices when switch -e (output\n+            --  Output the dependencies among units when switch -e (output\n             --  complete list of elaboration order dependencies) is active.\n \n-            Write_Dependencies (Mix_Lib_Graph);\n-\n-         --  The library graph contains an Elaborate_All circularity. There is\n-         --  no point in re-elaborating the units without the information from\n-         --  the invocation graph because the circularity will persist.\n-\n-         elsif Status = Order_Has_Elaborate_All_Circularity then\n-            Diagnose_Circularities\n-              (Inv_Graph => Mix_Inv_Graph,\n-               Lib_Graph => Mix_Lib_Graph);\n-\n-         --  Otherwise the library graph contains a circularity, or the extra\n-         --  information provided by the invocation graph caused a circularity.\n-         --  Re-elaborate the units without using the invocation graph. This\n-         --  assumes that all invocations will not take place at elaboration\n-         --  time.\n-\n-         else\n-            pragma Assert (Status = Order_Has_Circularity);\n-\n-            Elaborate_Units_Common\n-              (Use_Inv_Graph => False,\n-               Is_Dyn_Elab   => True,\n-               Inv_Graph     => Dyn_Inv_Graph,\n-               Lib_Graph     => Dyn_Lib_Graph,\n-               Order         => Dyn_Order,\n-               Status        => Status);\n-\n-            --  The elaboration order is satisfactory. The elaboration of the\n-            --  program may still fail at runtime with an ABE.\n-\n-            if Status = Order_OK then\n-               Order := Dyn_Order;\n-\n-               --  Output the dependencies of vertices when switch -e (output\n-               --  complete list of elaboration order dependencies) is active.\n-\n-               Write_Dependencies (Dyn_Lib_Graph);\n-\n-            --  Otherwise the library graph contains a circularity without the\n-            --  extra information provided by the invocation graph. Diagnose\n-            --  the circularity.\n-\n-            else\n-               Diagnose_Circularities\n-                 (Inv_Graph => Dyn_Inv_Graph,\n-                  Lib_Graph => Dyn_Lib_Graph);\n-            end if;\n-\n-            Destroy (Dyn_Inv_Graph);\n-            Destroy (Dyn_Lib_Graph);\n-         end if;\n-\n-         Destroy (Mix_Inv_Graph);\n-         Destroy (Mix_Lib_Graph);\n-\n-         --  Halt the bind as there is no satisfactory elaboration order\n-\n-         if Status /= Order_OK then\n-            raise Unrecoverable_Error;\n-         end if;\n-      end Elaborate_Units_Dynamic;\n+            Write_Dependencies (Lib_Graph);\n \n-      ----------------------------\n-      -- Elaborate_Units_Static --\n-      ----------------------------\n+            --  Output the elaboration order when switch -l (output chosen\n+            --  elaboration order) is in effect.\n \n-      procedure Elaborate_Units_Static (Order : out Unit_Id_Table) is\n-         Inv_Graph : Invocation_Graph;\n-         Lib_Graph : Library_Graph;\n-         Status    : Elaboration_Order_Status;\n+            Write_Elaboration_Order (Order);\n \n-      begin\n-         --  Attempt to elaborate the units in the library graph by mixing in\n-         --  the information from the invocation graph. This assumes that all\n-         --  invocations will take place at elaboration time.\n-\n-         Elaborate_Units_Common\n-           (Use_Inv_Graph => True,\n-            Is_Dyn_Elab   => False,\n-            Inv_Graph     => Inv_Graph,\n-            Lib_Graph     => Lib_Graph,\n-            Order         => Order,\n-            Status        => Status);\n-\n-         --  The elaboration order is satisfactory. Output the dependencies of\n-         --  vertices when switch -e (output complete list of elaboration order\n-         --  dependencies) is active.\n+            --  Output the sources referenced in the closure of the order when\n+            --  switch -R (list sources referenced in closure) is in effect.\n \n-         if Status = Order_OK then\n-            Write_Dependencies (Lib_Graph);\n+            Write_Unit_Closure (Order);\n \n-         --  Otherwise the augmented library graph contains a circularity\n+         --  Otherwise the library graph contains at least one circularity\n \n          else\n-            Diagnose_Circularities\n-              (Inv_Graph => Inv_Graph,\n-               Lib_Graph => Lib_Graph);\n+            Diagnose_Circularities (Inv_Graph, Lib_Graph);\n          end if;\n \n          Destroy (Inv_Graph);\n          Destroy (Lib_Graph);\n \n-         --  Halt the bind as there is no satisfactory elaboration order\n+         --  Destroy all unit-related data structures\n+\n+         Finalize_Units;\n+\n+         --  Halt the bind when there is no satisfactory elaboration order\n \n          if Status /= Order_OK then\n             raise Unrecoverable_Error;\n          end if;\n-      end Elaborate_Units_Static;\n+      end Elaborate_Units;\n \n       ----------------------\n       -- Elaborate_Vertex --\n       ----------------------\n \n       procedure Elaborate_Vertex\n-        (G                  : Library_Graph;\n-         Vertex             : Library_Graph_Vertex_Id;\n-         All_Candidates     : LGV_Sets.Membership_Set;\n-         Comp_Candidates    : LGV_Sets.Membership_Set;\n-         Remaining_Vertices : in out Natural;\n-         Order              : in out Unit_Id_Table;\n-         Step               : Elaboration_Order_Step;\n-         Indent             : Indentation_Level)\n+        (G                        : Library_Graph;\n+         Vertex                   : Library_Graph_Vertex_Id;\n+         All_Elaborable_Vertices  : LGV_Sets.Membership_Set;\n+         All_Waiting_Vertices     : LGV_Sets.Membership_Set;\n+         Comp_Elaborable_Vertices : LGV_Sets.Membership_Set;\n+         Comp_Waiting_Vertices    : LGV_Sets.Membership_Set;\n+         Order                    : in out Unit_Id_Table;\n+         Step                     : Elaboration_Order_Step;\n+         Indent                   : Indentation_Level)\n       is\n       begin\n          pragma Assert (Present (G));\n          pragma Assert (Present (Vertex));\n          pragma Assert (Needs_Elaboration (G, Vertex));\n-         pragma Assert (LGV_Sets.Present (All_Candidates));\n-         pragma Assert (LGV_Sets.Present (Comp_Candidates));\n+         pragma Assert (LGV_Sets.Present (All_Elaborable_Vertices));\n+         pragma Assert (LGV_Sets.Present (All_Waiting_Vertices));\n+         pragma Assert (LGV_Sets.Present (Comp_Elaborable_Vertices));\n+         pragma Assert (LGV_Sets.Present (Comp_Waiting_Vertices));\n \n          Trace_Vertex\n            (G      => G,\n@@ -885,14 +825,20 @@ package body Bindo.Elaborators is\n             Step   => Step,\n             Indent => Indent);\n \n-         --  Remove the vertex from both candidate sets. This is needed when\n+         --  Remove the vertex from both elaborable sets. This is needed when\n          --  the vertex is both an overall best candidate among all vertices,\n-         --  and the best candidate within the component. There is no need to\n-         --  check that the vertex is present in either set because the set\n-         --  implementation handles this case.\n+         --  and the best candidate within the component.\n+\n+         LGV_Sets.Delete (All_Elaborable_Vertices,  Vertex);\n+         LGV_Sets.Delete (Comp_Elaborable_Vertices, Vertex);\n \n-         LGV_Sets.Delete (All_Candidates,  Vertex);\n-         LGV_Sets.Delete (Comp_Candidates, Vertex);\n+         --  Remove the vertex from both waiting sets. This is needed when a\n+         --  weakly elaborable vertex is both an overall best candidate among\n+         --  all waiting vertices and the best waiting candidate within the\n+         --  component.\n+\n+         LGV_Sets.Delete (All_Waiting_Vertices,  Vertex);\n+         LGV_Sets.Delete (Comp_Waiting_Vertices, Vertex);\n \n          --  Mark the vertex as elaborated in order to prevent further attempts\n          --  to re-elaborate it.\n@@ -903,202 +849,469 @@ package body Bindo.Elaborators is\n \n          Unit_Id_Tables.Append (Order, Unit (G, Vertex));\n \n-         --  There is now one fewer vertex to elaborate\n-\n-         Remaining_Vertices := Remaining_Vertices - 1;\n-\n          --  Notify all successors and their components that they have one\n          --  fewer predecessor to wait on. This may cause some successors to\n          --  be included in one of the sets.\n \n          Update_Successors\n-           (G               => G,\n-            Pred            => Vertex,\n-            All_Candidates  => All_Candidates,\n-            Comp_Candidates => Comp_Candidates,\n-            Step            => Step,\n-            Indent          => Indent + Nested_Indentation);\n-\n-         --  The vertex denotes a spec with a completing body, and is subject\n-         --  to pragma Elaborate_Body. Elaborate the body in order to satisfy\n-         --  the semantics of the pragma.\n-\n-         if Is_Spec_With_Elaborate_Body (G, Vertex) then\n+           (G                        => G,\n+            Vertex                   => Vertex,\n+            All_Elaborable_Vertices  => All_Elaborable_Vertices,\n+            All_Waiting_Vertices     => All_Waiting_Vertices,\n+            Comp_Elaborable_Vertices => Comp_Elaborable_Vertices,\n+            Comp_Waiting_Vertices    => Comp_Waiting_Vertices,\n+            Step                     => Step,\n+            Indent                   => Indent + Nested_Indentation);\n+\n+         --  Elaborate an eligible completing body immediately after its spec.\n+         --  This action satisfies the semantics of pragma Elaborate_Body. In\n+         --  addition, it ensures that a body will not \"drift\" too far from its\n+         --  spec in case invocation edges are removed from the library graph.\n+\n+         if Has_Elaborable_Body (G, Vertex) then\n             Elaborate_Vertex\n-              (G                  => G,\n-               Vertex             => Proper_Body (G, Vertex),\n-               All_Candidates     => All_Candidates,\n-               Comp_Candidates    => Comp_Candidates,\n-               Remaining_Vertices => Remaining_Vertices,\n-               Order              => Order,\n-               Step               => Step,\n-               Indent             => Indent);\n+              (G                        => G,\n+               Vertex                   => Proper_Body (G, Vertex),\n+               All_Elaborable_Vertices  => All_Elaborable_Vertices,\n+               All_Waiting_Vertices     => All_Waiting_Vertices,\n+               Comp_Elaborable_Vertices => Comp_Elaborable_Vertices,\n+               Comp_Waiting_Vertices    => Comp_Waiting_Vertices,\n+               Order                    => Order,\n+               Step                     => Step,\n+               Indent                   => Indent);\n          end if;\n       end Elaborate_Vertex;\n \n-      -------------------------\n-      -- Find_Best_Candidate --\n-      -------------------------\n+      ---------------------------------\n+      -- Find_Best_Elaborable_Vertex --\n+      ---------------------------------\n \n-      function Find_Best_Candidate\n+      function Find_Best_Elaborable_Vertex\n         (G      : Library_Graph;\n          Set    : LGV_Sets.Membership_Set;\n          Step   : Elaboration_Order_Step;\n          Indent : Indentation_Level) return Library_Graph_Vertex_Id\n       is\n-         Best    : Library_Graph_Vertex_Id;\n-         Current : Library_Graph_Vertex_Id;\n-         Iter    : LGV_Sets.Iterator;\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (LGV_Sets.Present (Set));\n+\n+         return\n+           Find_Best_Vertex\n+             (G                   => G,\n+              Set                 => Set,\n+              Is_Suitable_Vertex  =>\n+                Is_Suitable_Elaborable_Vertex'Access,\n+              Compare_Vertices    =>\n+                Is_Better_Elaborable_Vertex'Access,\n+              Initial_Best_Msg    => \"initial best elaborable vertex\",\n+              Subsequent_Best_Msg => \"better elaborable vertex\",\n+              Step                => Step,\n+              Indent              => Indent);\n+      end Find_Best_Elaborable_Vertex;\n+\n+      ----------------------\n+      -- Find_Best_Vertex --\n+      ----------------------\n+\n+      function Find_Best_Vertex\n+        (G                   : Library_Graph;\n+         Set                 : LGV_Sets.Membership_Set;\n+         Is_Suitable_Vertex  : Predicate_Ptr;\n+         Compare_Vertices    : Comparator_Ptr;\n+         Initial_Best_Msg    : String;\n+         Subsequent_Best_Msg : String;\n+         Step                : Elaboration_Order_Step;\n+         Indent              : Indentation_Level)\n+         return Library_Graph_Vertex_Id\n+      is\n+         Best_Vertex    : Library_Graph_Vertex_Id;\n+         Current_Vertex : Library_Graph_Vertex_Id;\n+         Iter           : LGV_Sets.Iterator;\n \n       begin\n          pragma Assert (Present (G));\n          pragma Assert (LGV_Sets.Present (Set));\n+         pragma Assert (Is_Suitable_Vertex /= null);\n+         pragma Assert (Compare_Vertices /= null);\n \n          --  Assume that there is no candidate\n \n-         Best := No_Library_Graph_Vertex;\n+         Best_Vertex := No_Library_Graph_Vertex;\n \n-         --  Inspect all vertices in the set, looking for the best candidate to\n-         --  elaborate.\n+         --  Inspect all vertices in the set, looking for the best candidate\n+         --  according to the comparator.\n \n          Iter := LGV_Sets.Iterate (Set);\n          while LGV_Sets.Has_Next (Iter) loop\n-            LGV_Sets.Next (Iter, Current);\n-            pragma Assert (Needs_Elaboration (G, Current));\n+            LGV_Sets.Next (Iter, Current_Vertex);\n+            pragma Assert (Needs_Elaboration (G, Current_Vertex));\n+\n+            if Is_Suitable_Vertex.all (G, Current_Vertex) then\n+\n+               --  A previous iteration already picked the best candidate.\n+               --  Update the best candidate when the current vertex is a\n+               --  better choice.\n+\n+               if Present (Best_Vertex) then\n+                  if Compare_Vertices.all\n+                       (G           => G,\n+                        Vertex      => Current_Vertex,\n+                        Compared_To => Best_Vertex) = Higher_Precedence\n+                  then\n+                     Best_Vertex := Current_Vertex;\n+\n+                     Trace_Vertex\n+                       (G      => G,\n+                        Vertex => Best_Vertex,\n+                        Msg    => Subsequent_Best_Msg,\n+                        Step   => Step,\n+                        Indent => Indent);\n+                  end if;\n+\n+               --  Otherwise this is the first candidate\n+\n+               else\n+                  Best_Vertex := Current_Vertex;\n+\n+                  Trace_Vertex\n+                    (G      => G,\n+                     Vertex => Best_Vertex,\n+                     Msg    => Initial_Best_Msg,\n+                     Step   => Step,\n+                     Indent => Indent);\n+               end if;\n+            end if;\n+         end loop;\n \n-            --  Update the best candidate when there is no such candidate\n+         return Best_Vertex;\n+      end Find_Best_Vertex;\n \n-            if not Present (Best) then\n-               Best := Current;\n+      ----------------------------------------\n+      -- Find_Best_Weakly_Elaborable_Vertex --\n+      ----------------------------------------\n \n-               Trace_Vertex\n-                 (G      => G,\n-                  Vertex => Best,\n-                  Msg    => \"initial best candidate vertex\",\n-                  Step   => Step,\n-                  Indent => Indent);\n+      function Find_Best_Weakly_Elaborable_Vertex\n+        (G      : Library_Graph;\n+         Set    : LGV_Sets.Membership_Set;\n+         Step   : Elaboration_Order_Step;\n+         Indent : Indentation_Level) return Library_Graph_Vertex_Id\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (LGV_Sets.Present (Set));\n \n-            --  Update the best candidate when the current vertex is a better\n-            --  choice.\n+         return\n+           Find_Best_Vertex\n+             (G                   => G,\n+              Set                 => Set,\n+              Is_Suitable_Vertex  =>\n+                Is_Suitable_Weakly_Elaborable_Vertex'Access,\n+              Compare_Vertices    =>\n+                Is_Better_Weakly_Elaborable_Vertex'Access,\n+              Initial_Best_Msg    => \"initial best weakly elaborable vertex\",\n+              Subsequent_Best_Msg => \"better weakly elaborable vertex\",\n+              Step                => Step,\n+              Indent              => Indent);\n+      end Find_Best_Weakly_Elaborable_Vertex;\n \n-            elsif Is_Better_Candidate\n-                    (G           => G,\n-                     Best_Candidate => Best,\n-                     New_Candidate  => Current)\n-            then\n-               Best := Current;\n+      -------------------------\n+      -- Has_Elaborable_Body --\n+      -------------------------\n \n-               Trace_Vertex\n-                 (G      => G,\n-                  Vertex => Best,\n-                  Msg    => \"best candidate vertex\",\n-                  Step   => Step,\n-                  Indent => Indent);\n-            end if;\n-         end loop;\n+      function Has_Elaborable_Body\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Vertex));\n \n-         return Best;\n-      end Find_Best_Candidate;\n+         --  The body of an already-elaborated spec subject to Elaborate_Body\n+         --  is always elaborable.\n \n-      -------------------------\n-      -- Is_Better_Candidate --\n-      -------------------------\n+         if Is_Spec_With_Elaborate_Body (G, Vertex) then\n+            return True;\n+\n+         elsif Is_Spec_With_Body (G, Vertex) then\n+            return Is_Elaborable_Vertex (G, Proper_Body (G, Vertex));\n+         end if;\n+\n+         return False;\n+      end Has_Elaborable_Body;\n+\n+      ---------------------------------\n+      -- Insert_Elaborable_Successor --\n+      ---------------------------------\n+\n+      procedure Insert_Elaborable_Successor\n+        (G                     : Library_Graph;\n+         Vertex                : Library_Graph_Vertex_Id;\n+         Elaborable_Vertices   : LGV_Sets.Membership_Set;\n+         All_Waiting_Vertices  : LGV_Sets.Membership_Set;\n+         Comp_Waiting_Vertices : LGV_Sets.Membership_Set;\n+         Msg                   : String;\n+         Step                  : Elaboration_Order_Step;\n+         Indent                : Indentation_Level)\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Vertex));\n+         pragma Assert (LGV_Sets.Present (Elaborable_Vertices));\n+         pragma Assert (LGV_Sets.Present (All_Waiting_Vertices));\n+         pragma Assert (LGV_Sets.Present (Comp_Waiting_Vertices));\n+\n+         Complement : constant Library_Graph_Vertex_Id :=\n+                        Complementary_Vertex\n+                          (G                => G,\n+                           Vertex           => Vertex,\n+                           Force_Complement => False);\n+\n+      begin\n+         --  Remove the successor from both waiting vertex sets because it may\n+         --  be the best vertex to elaborate across the whole graph and within\n+         --  its component.\n+\n+         LGV_Sets.Delete (All_Waiting_Vertices,  Vertex);\n+         LGV_Sets.Delete (Comp_Waiting_Vertices, Vertex);\n+\n+         Insert_Vertex\n+           (G      => G,\n+            Vertex => Vertex,\n+            Set    => Elaborable_Vertices,\n+            Msg    => Msg,\n+            Step   => Step,\n+            Indent => Indent);\n+\n+         if Present (Complement) then\n+\n+            --  Remove the complement of the successor from both waiting vertex\n+            --  sets because it may be the best vertex to elaborate across the\n+            --  whole graph and within its component.\n+\n+            LGV_Sets.Delete (All_Waiting_Vertices,  Complement);\n+            LGV_Sets.Delete (Comp_Waiting_Vertices, Complement);\n+\n+            Insert_Vertex\n+              (G      => G,\n+               Vertex => Complement,\n+               Set    => Elaborable_Vertices,\n+               Msg    => Msg,\n+               Step   => Step,\n+               Indent => Indent);\n+         end if;\n+      end Insert_Elaborable_Successor;\n+\n+      -------------------\n+      -- Insert_Vertex --\n+      -------------------\n+\n+      procedure Insert_Vertex\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id;\n+         Set    : LGV_Sets.Membership_Set;\n+         Msg    : String;\n+         Step   : Elaboration_Order_Step;\n+         Indent : Indentation_Level)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Vertex));\n+         pragma Assert (Needs_Elaboration (G, Vertex));\n+         pragma Assert (LGV_Sets.Present (Set));\n+\n+         --  Nothing to do when the vertex is already present in the set\n \n-      function Is_Better_Candidate\n-        (G              : Library_Graph;\n-         Best_Candidate : Library_Graph_Vertex_Id;\n-         New_Candidate  : Library_Graph_Vertex_Id) return Boolean\n+         if LGV_Sets.Contains (Set, Vertex) then\n+            return;\n+         end if;\n+\n+         Trace_Vertex\n+           (G      => G,\n+            Vertex => Vertex,\n+            Msg    => Msg,\n+            Step   => Step,\n+            Indent => Indent);\n+\n+         --  Add the vertex to the set\n+\n+         LGV_Sets.Insert (Set, Vertex);\n+      end Insert_Vertex;\n+\n+      ---------------------------------\n+      -- Is_Better_Elaborable_Vertex --\n+      ---------------------------------\n+\n+      function Is_Better_Elaborable_Vertex\n+        (G           : Library_Graph;\n+         Vertex      : Library_Graph_Vertex_Id;\n+         Compared_To : Library_Graph_Vertex_Id) return Precedence_Kind\n       is\n       begin\n          pragma Assert (Present (G));\n-         pragma Assert (Present (Best_Candidate));\n-         pragma Assert (Present (New_Candidate));\n+         pragma Assert (Present (Vertex));\n+         pragma Assert (Present (Compared_To));\n+\n+         --  Prefer a spec with Elaborate_Body over its corresponding body\n+\n+         if Is_Elaborate_Body_Pair\n+              (G           => G,\n+               Spec_Vertex => Vertex,\n+               Body_Vertex => Compared_To)\n+         then\n+            return Higher_Precedence;\n+\n+         elsif Is_Elaborate_Body_Pair\n+                 (G           => G,\n+                  Spec_Vertex => Compared_To,\n+                  Body_Vertex => Vertex)\n+         then\n+            return Lower_Precedence;\n \n          --  Prefer a predefined unit over a non-predefined unit\n \n-         if Is_Predefined_Unit (G, Best_Candidate)\n-           and then not Is_Predefined_Unit (G, New_Candidate)\n+         elsif Is_Predefined_Unit (G, Vertex)\n+           and then not Is_Predefined_Unit (G, Compared_To)\n          then\n-            return False;\n+            return Higher_Precedence;\n \n-         elsif not Is_Predefined_Unit (G, Best_Candidate)\n-           and then Is_Predefined_Unit (G, New_Candidate)\n+         elsif not Is_Predefined_Unit (G, Vertex)\n+           and then Is_Predefined_Unit (G, Compared_To)\n          then\n-            return True;\n+            return Lower_Precedence;\n \n-         --  Prefer an internal unit over a non-iternal unit\n+         --  Prefer an internal unit over a non-internal unit\n \n-         elsif Is_Internal_Unit (G, Best_Candidate)\n-           and then not Is_Internal_Unit (G, New_Candidate)\n+         elsif Is_Internal_Unit (G, Vertex)\n+           and then not Is_Internal_Unit (G, Compared_To)\n          then\n-            return False;\n+            return Higher_Precedence;\n \n-         elsif not Is_Internal_Unit (G, Best_Candidate)\n-           and then Is_Internal_Unit (G, New_Candidate)\n+         elsif not Is_Internal_Unit (G, Vertex)\n+           and then Is_Internal_Unit (G, Compared_To)\n          then\n-            return True;\n+            return Lower_Precedence;\n \n          --  Prefer a preelaborated unit over a non-preelaborated unit\n \n-         elsif Is_Preelaborated_Unit (G, Best_Candidate)\n-           and then not Is_Preelaborated_Unit (G, New_Candidate)\n+         elsif Is_Preelaborated_Unit (G, Vertex)\n+           and then not Is_Preelaborated_Unit (G, Compared_To)\n          then\n-            return False;\n+            return Higher_Precedence;\n \n-         elsif not Is_Preelaborated_Unit (G, Best_Candidate)\n-           and then Is_Preelaborated_Unit (G, New_Candidate)\n+         elsif not Is_Preelaborated_Unit (G, Vertex)\n+           and then Is_Preelaborated_Unit (G, Compared_To)\n          then\n-            return True;\n+            return Lower_Precedence;\n \n          --  Otherwise default to lexicographical order to ensure deterministic\n          --  behavior.\n \n+         elsif Uname_Less (Name (G, Vertex), Name (G, Compared_To)) then\n+            return Higher_Precedence;\n+\n          else\n-            return\n-              Uname_Less (Name (G, Best_Candidate), Name (G, New_Candidate));\n+            return Lower_Precedence;\n          end if;\n-      end Is_Better_Candidate;\n+      end Is_Better_Elaborable_Vertex;\n \n-      ------------------------------\n-      -- Trace_Candidate_Vertices --\n-      ------------------------------\n+      ----------------------------------------\n+      -- Is_Better_Weakly_Elaborable_Vertex --\n+      ----------------------------------------\n \n-      procedure Trace_Candidate_Vertices\n-        (G    : Library_Graph;\n-         Set  : LGV_Sets.Membership_Set;\n-         Step : Elaboration_Order_Step)\n+      function Is_Better_Weakly_Elaborable_Vertex\n+        (G           : Library_Graph;\n+         Vertex      : Library_Graph_Vertex_Id;\n+         Compared_To : Library_Graph_Vertex_Id) return Precedence_Kind\n       is\n-         Iter   : LGV_Sets.Iterator;\n-         Vertex : Library_Graph_Vertex_Id;\n+         Comp_Strong_Preds   : Natural;\n+         Comp_Weak_Preds     : Natural;\n+         Vertex_Strong_Preds : Natural;\n+         Vertex_Weak_Preds   : Natural;\n \n       begin\n          pragma Assert (Present (G));\n-         pragma Assert (LGV_Sets.Present (Set));\n+         pragma Assert (Present (Vertex));\n+         pragma Assert (Present (Compared_To));\n \n-         --  Nothing to do when switch -d_T (output elaboration order and cycle\n-         --  detection trace information) is not in effect.\n+         --  Obtain the number of pending predecessors for both candidates,\n+         --  taking into account Elaborate_Body pairs.\n \n-         if not Debug_Flag_Underscore_TT then\n-            return;\n+         Pending_Predecessors_For_Elaboration\n+           (G            => G,\n+            Vertex       => Vertex,\n+            Strong_Preds => Vertex_Strong_Preds,\n+            Weak_Preds   => Vertex_Weak_Preds);\n+\n+         Pending_Predecessors_For_Elaboration\n+           (G            => G,\n+            Vertex       => Compared_To,\n+            Strong_Preds => Comp_Strong_Preds,\n+            Weak_Preds   => Comp_Weak_Preds);\n+\n+         --  Neither candidate should be waiting on strong predecessors,\n+         --  otherwise the candidate cannot be weakly elaborated.\n+\n+         pragma Assert (Vertex_Strong_Preds = 0);\n+         pragma Assert (Comp_Strong_Preds   = 0);\n+\n+         --  Prefer a unit with fewer weak predecessors over a unit with more\n+         --  weak predecessors.\n+\n+         if Vertex_Weak_Preds < Comp_Weak_Preds then\n+            return Higher_Precedence;\n+\n+         elsif Vertex_Weak_Preds > Comp_Weak_Preds then\n+            return Lower_Precedence;\n+\n+         --  Otherwise default to lexicographical order to ensure deterministic\n+         --  behavior.\n+\n+         elsif Uname_Less (Name (G, Vertex), Name (G, Compared_To)) then\n+            return Higher_Precedence;\n+\n+         else\n+            return Lower_Precedence;\n          end if;\n+      end Is_Better_Weakly_Elaborable_Vertex;\n \n-         Trace_Step (Step);\n-         Write_Str  (\"candidate vertices: \");\n-         Write_Int  (Int (LGV_Sets.Size (Set)));\n-         Write_Eol;\n+      -----------------------------------\n+      -- Is_Suitable_Elaborable_Vertex --\n+      -----------------------------------\n \n-         Iter := LGV_Sets.Iterate (Set);\n-         while LGV_Sets.Has_Next (Iter) loop\n-            LGV_Sets.Next (Iter, Vertex);\n+      function Is_Suitable_Elaborable_Vertex\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Vertex));\n \n-            Trace_Vertex\n-              (G      => G,\n-               Vertex => Vertex,\n-               Msg    => \"candidate vertex\",\n-               Step   => Step,\n-               Indent => Nested_Indentation);\n-         end loop;\n-      end Trace_Candidate_Vertices;\n+         --  A vertex is suitable for elaboration as long it is not waiting on\n+         --  any predecessors, ignoring the static or dynamic model.\n+\n+         return Is_Elaborable_Vertex (G, Vertex);\n+      end Is_Suitable_Elaborable_Vertex;\n+\n+      ------------------------------------------\n+      -- Is_Suitable_Weakly_Elaborable_Vertex --\n+      ------------------------------------------\n+\n+      function Is_Suitable_Weakly_Elaborable_Vertex\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Vertex));\n+\n+         --  A vertex is suitable for weak elaboration when it is waiting on\n+         --  weak predecessors only, and the unit it represents was compiled\n+         --  using the dynamic model.\n+\n+         return\n+           Is_Dynamically_Elaborated (G, Vertex)\n+             and then Is_Weakly_Elaborable_Vertex (G, Vertex);\n+      end Is_Suitable_Weakly_Elaborable_Vertex;\n \n       ---------------------\n       -- Trace_Component --\n@@ -1130,8 +1343,14 @@ package body Bindo.Elaborators is\n \n          Trace_Step (Step);\n          Indent_By  (Nested_Indentation);\n-         Write_Str  (\"pending predecessors: \");\n-         Write_Num  (Int (Pending_Predecessors (G, Comp)));\n+         Write_Str  (\"pending strong predecessors: \");\n+         Write_Num  (Int (Pending_Strong_Predecessors (G, Comp)));\n+         Write_Eol;\n+\n+         Trace_Step (Step);\n+         Indent_By  (Nested_Indentation);\n+         Write_Str  (\"pending weak predecessors  : \");\n+         Write_Num  (Int (Pending_Weak_Predecessors (G, Comp)));\n          Write_Eol;\n       end Trace_Component;\n \n@@ -1154,50 +1373,6 @@ package body Bindo.Elaborators is\n          Write_Str (\": \");\n       end Trace_Step;\n \n-      ---------------------------------\n-      -- Trace_Unelaborated_Vertices --\n-      ---------------------------------\n-\n-      procedure Trace_Unelaborated_Vertices\n-        (G     : Library_Graph;\n-         Count : Natural;\n-         Step  : Elaboration_Order_Step)\n-      is\n-         Iter   : Library_Graphs.All_Vertex_Iterator;\n-         Vertex : Library_Graph_Vertex_Id;\n-\n-      begin\n-         pragma Assert (Present (G));\n-\n-         --  Nothing to do when switch -d_T (output elaboration order and cycle\n-         --  detection trace information) is not in effect.\n-\n-         if not Debug_Flag_Underscore_TT then\n-            return;\n-         end if;\n-\n-         Trace_Step (Step);\n-         Write_Str  (\"remaining unelaborated vertices: \");\n-         Write_Int  (Int (Count));\n-         Write_Eol;\n-\n-         Iter := Iterate_All_Vertices (G);\n-         while Has_Next (Iter) loop\n-            Next (Iter, Vertex);\n-\n-            if Needs_Elaboration (G, Vertex)\n-              and then not In_Elaboration_Order (G, Vertex)\n-            then\n-               Trace_Vertex\n-                 (G      => G,\n-                  Vertex => Vertex,\n-                  Msg    => \"remaining vertex\",\n-                  Step   => Step,\n-                  Indent => Nested_Indentation);\n-            end if;\n-         end loop;\n-      end Trace_Unelaborated_Vertices;\n-\n       ------------------\n       -- Trace_Vertex --\n       ------------------\n@@ -1247,37 +1422,104 @@ package body Bindo.Elaborators is\n \n          Trace_Step (Step);\n          Indent_By  (Attr_Indent);\n-         Write_Str  (\"pending predecessors: \");\n-         Write_Num  (Int (Pending_Predecessors (G, Vertex)));\n+         Write_Str  (\"pending strong predecessors: \");\n+         Write_Num  (Int (Pending_Strong_Predecessors (G, Vertex)));\n+         Write_Eol;\n+\n+         Trace_Step (Step);\n+         Indent_By  (Attr_Indent);\n+         Write_Str  (\"pending weak predecessors  : \");\n+         Write_Num  (Int (Pending_Weak_Predecessors (G, Vertex)));\n          Write_Eol;\n \n          Trace_Step (Step);\n          Indent_By  (Attr_Indent);\n-         Write_Str  (\"pending components  : \");\n-         Write_Num  (Int (Pending_Predecessors (G, Comp)));\n+         Write_Str  (\"pending strong components  : \");\n+         Write_Num  (Int (Pending_Strong_Predecessors (G, Comp)));\n+         Write_Eol;\n+\n+         Trace_Step (Step);\n+         Indent_By  (Attr_Indent);\n+         Write_Str  (\"pending weak components    : \");\n+         Write_Num  (Int (Pending_Weak_Predecessors (G, Comp)));\n          Write_Eol;\n       end Trace_Vertex;\n \n+      --------------------\n+      -- Trace_Vertices --\n+      --------------------\n+\n+      procedure Trace_Vertices\n+        (G          : Library_Graph;\n+         Set        : LGV_Sets.Membership_Set;\n+         Set_Msg    : String;\n+         Vertex_Msg : String;\n+         Step       : Elaboration_Order_Step;\n+         Indent     : Indentation_Level)\n+      is\n+         Vertex_Indent : constant Indentation_Level :=\n+                           Indent + Nested_Indentation;\n+\n+         Iter   : LGV_Sets.Iterator;\n+         Vertex : Library_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (LGV_Sets.Present (Set));\n+\n+         --  Nothing to do when switch -d_T (output elaboration order and cycle\n+         --  detection trace information) is not in effect.\n+\n+         if not Debug_Flag_Underscore_TT then\n+            return;\n+         end if;\n+\n+         Trace_Step (Step);\n+         Indent_By  (Indent);\n+         Write_Str  (Set_Msg);\n+         Write_Str  (\": \");\n+         Write_Int  (Int (LGV_Sets.Size (Set)));\n+         Write_Eol;\n+\n+         Iter := LGV_Sets.Iterate (Set);\n+         while LGV_Sets.Has_Next (Iter) loop\n+            LGV_Sets.Next (Iter, Vertex);\n+\n+            Trace_Vertex\n+              (G      => G,\n+               Vertex => Vertex,\n+               Msg    => Vertex_Msg,\n+               Step   => Step,\n+               Indent => Vertex_Indent);\n+         end loop;\n+      end Trace_Vertices;\n+\n       ----------------------\n       -- Update_Successor --\n       ----------------------\n \n       procedure Update_Successor\n-        (G               : Library_Graph;\n-         Pred            : Library_Graph_Vertex_Id;\n-         Succ            : Library_Graph_Vertex_Id;\n-         All_Candidates  : LGV_Sets.Membership_Set;\n-         Comp_Candidates : LGV_Sets.Membership_Set;\n-         Step            : Elaboration_Order_Step;\n-         Indent          : Indentation_Level)\n+        (G                        : Library_Graph;\n+         Edge                     : Library_Graph_Edge_Id;\n+         All_Elaborable_Vertices  : LGV_Sets.Membership_Set;\n+         All_Waiting_Vertices     : LGV_Sets.Membership_Set;\n+         Comp_Elaborable_Vertices : LGV_Sets.Membership_Set;\n+         Comp_Waiting_Vertices    : LGV_Sets.Membership_Set;\n+         Step                     : Elaboration_Order_Step;\n+         Indent                   : Indentation_Level)\n       is\n          pragma Assert (Present (G));\n-         pragma Assert (Present (Pred));\n+         pragma Assert (Present (Edge));\n+         pragma Assert (LGV_Sets.Present (All_Elaborable_Vertices));\n+         pragma Assert (LGV_Sets.Present (All_Waiting_Vertices));\n+         pragma Assert (LGV_Sets.Present (Comp_Elaborable_Vertices));\n+         pragma Assert (LGV_Sets.Present (Comp_Waiting_Vertices));\n+\n+         Pred : constant Library_Graph_Vertex_Id := Predecessor (G, Edge);\n+         Succ : constant Library_Graph_Vertex_Id := Successor   (G, Edge);\n+\n          pragma Assert (Needs_Elaboration (G, Pred));\n-         pragma Assert (Present (Succ));\n          pragma Assert (Needs_Elaboration (G, Succ));\n-         pragma Assert (LGV_Sets.Present (All_Candidates));\n-         pragma Assert (LGV_Sets.Present (Comp_Candidates));\n \n          In_Different_Components : constant Boolean :=\n                                      not In_Same_Component\n@@ -1289,10 +1531,8 @@ package body Bindo.Elaborators is\n          Vertex_Indent : constant Indentation_Level :=\n                            Indent + Nested_Indentation;\n \n-         Candidate : Library_Graph_Vertex_Id;\n-         Iter      : Component_Vertex_Iterator;\n-         Msg       : String_Ptr;\n-         Set       : LGV_Sets.Membership_Set;\n+         Iter   : Component_Vertex_Iterator;\n+         Vertex : Library_Graph_Vertex_Id;\n \n       begin\n          Trace_Vertex\n@@ -1305,45 +1545,61 @@ package body Bindo.Elaborators is\n          --  Notify the successor that it has one less predecessor to wait on.\n          --  This effectively eliminates the edge that links the two.\n \n-         Decrement_Pending_Predecessors (G, Succ);\n+         Decrement_Pending_Predecessors\n+           (G      => G,\n+            Vertex => Succ,\n+            Edge   => Edge);\n \n          --  The predecessor and successor reside in different components.\n          --  Notify the successor component it has one fewer components to\n          --  wait on.\n \n          if In_Different_Components then\n-            Decrement_Pending_Predecessors (G, Succ_Comp);\n+            Decrement_Pending_Predecessors\n+              (G    => G,\n+               Comp => Succ_Comp,\n+               Edge => Edge);\n          end if;\n \n          --  At this point the successor may become elaborable when its final\n-         --  predecessor or final predecessor component is elaborated.\n-\n-         --  The predecessor and successor reside in different components.\n-         --  The successor must not be added to the candidates of Pred's\n-         --  component because this will mix units from the two components.\n-         --  Instead, the successor is added to the set of all candidates\n-         --  that must be elaborated.\n+         --  predecessor or final predecessor component has been elaborated.\n+\n+         if Is_Elaborable_Vertex (G, Succ) then\n+\n+            --  The predecessor and successor reside in different components.\n+            --  The successor must not be added to the candidates of Pred's\n+            --  component because this will mix units from the two components.\n+            --  Instead, the successor is added to the set of all elaborable\n+            --  vertices.\n+\n+            if In_Different_Components then\n+               Insert_Elaborable_Successor\n+                 (G                     => G,\n+                  Vertex                => Succ,\n+                  Elaborable_Vertices   => All_Elaborable_Vertices,\n+                  All_Waiting_Vertices  => All_Waiting_Vertices,\n+                  Comp_Waiting_Vertices => Comp_Waiting_Vertices,\n+                  Msg                   => \"add elaborable successor\",\n+                  Step                  => Step,\n+                  Indent                => Vertex_Indent);\n+\n+            --  Otherwise the predecessor and successor reside within the same\n+            --  component. Pred's component gains another elaborable vertex.\n \n-         if In_Different_Components then\n-            Msg := Add_To_All_Candidates_Msg'Access;\n-            Set := All_Candidates;\n-\n-         --  Otherwise the predecessor and successor reside within the same\n-         --  component. Pred's component gains another elaborable node.\n-\n-         else\n-            Msg := Add_To_Comp_Candidates_Msg'Access;\n-            Set := Comp_Candidates;\n+            else\n+               Insert_Elaborable_Successor\n+                 (G                     => G,\n+                  Vertex                => Succ,\n+                  Elaborable_Vertices   => Comp_Elaborable_Vertices,\n+                  All_Waiting_Vertices  => All_Waiting_Vertices,\n+                  Comp_Waiting_Vertices => Comp_Waiting_Vertices,\n+                  Msg                   =>\n+                    \"add elaborable component successor\",\n+                  Step                  => Step,\n+                  Indent                => Vertex_Indent);\n+            end if;\n          end if;\n \n-         Add_Vertex_If_Elaborable\n-           (G      => G,\n-            Vertex => Succ,\n-            Set    => Set,\n-            Msg    => Msg.all,\n-            Step   => Step,\n-            Indent => Vertex_Indent);\n-\n          --  At this point the successor component may become elaborable when\n          --  its final predecessor component is elaborated. This in turn may\n          --  allow vertices of the successor component to be elaborated.\n@@ -1353,15 +1609,19 @@ package body Bindo.Elaborators is\n          then\n             Iter := Iterate_Component_Vertices (G, Succ_Comp);\n             while Has_Next (Iter) loop\n-               Next (Iter, Candidate);\n-\n-               Add_Vertex_If_Elaborable\n-                 (G      => G,\n-                  Vertex => Candidate,\n-                  Set    => All_Candidates,\n-                  Msg    => Add_To_All_Candidates_Msg,\n-                  Step   => Step,\n-                  Indent => Vertex_Indent);\n+               Next (Iter, Vertex);\n+\n+               if Is_Elaborable_Vertex (G, Vertex) then\n+                  Insert_Elaborable_Successor\n+                    (G                     => G,\n+                     Vertex                => Vertex,\n+                     Elaborable_Vertices   => All_Elaborable_Vertices,\n+                     All_Waiting_Vertices  => All_Waiting_Vertices,\n+                     Comp_Waiting_Vertices => Comp_Waiting_Vertices,\n+                     Msg                   => \"add elaborable vertex\",\n+                     Step                  => Step,\n+                     Indent                => Vertex_Indent);\n+               end if;\n             end loop;\n          end if;\n       end Update_Successor;\n@@ -1371,36 +1631,41 @@ package body Bindo.Elaborators is\n       -----------------------\n \n       procedure Update_Successors\n-        (G               : Library_Graph;\n-         Pred            : Library_Graph_Vertex_Id;\n-         All_Candidates  : LGV_Sets.Membership_Set;\n-         Comp_Candidates : LGV_Sets.Membership_Set;\n-         Step            : Elaboration_Order_Step;\n-         Indent          : Indentation_Level)\n+        (G                        : Library_Graph;\n+         Vertex                   : Library_Graph_Vertex_Id;\n+         All_Elaborable_Vertices  : LGV_Sets.Membership_Set;\n+         All_Waiting_Vertices     : LGV_Sets.Membership_Set;\n+         Comp_Elaborable_Vertices : LGV_Sets.Membership_Set;\n+         Comp_Waiting_Vertices    : LGV_Sets.Membership_Set;\n+         Step                     : Elaboration_Order_Step;\n+         Indent                   : Indentation_Level)\n       is\n          Edge : Library_Graph_Edge_Id;\n          Iter : Edges_To_Successors_Iterator;\n \n       begin\n          pragma Assert (Present (G));\n-         pragma Assert (Present (Pred));\n-         pragma Assert (Needs_Elaboration (G, Pred));\n-         pragma Assert (LGV_Sets.Present (All_Candidates));\n-         pragma Assert (LGV_Sets.Present (Comp_Candidates));\n+         pragma Assert (Present (Vertex));\n+         pragma Assert (Needs_Elaboration (G, Vertex));\n+         pragma Assert (LGV_Sets.Present (All_Elaborable_Vertices));\n+         pragma Assert (LGV_Sets.Present (All_Waiting_Vertices));\n+         pragma Assert (LGV_Sets.Present (Comp_Elaborable_Vertices));\n+         pragma Assert (LGV_Sets.Present (Comp_Waiting_Vertices));\n \n-         Iter := Iterate_Edges_To_Successors (G, Pred);\n+         Iter := Iterate_Edges_To_Successors (G, Vertex);\n          while Has_Next (Iter) loop\n             Next (Iter, Edge);\n-            pragma Assert (Predecessor (G, Edge) = Pred);\n+            pragma Assert (Predecessor (G, Edge) = Vertex);\n \n             Update_Successor\n-              (G               => G,\n-               Pred            => Pred,\n-               Succ            => Successor (G, Edge),\n-               All_Candidates  => All_Candidates,\n-               Comp_Candidates => Comp_Candidates,\n-               Step            => Step,\n-               Indent          => Indent);\n+              (G                        => G,\n+               Edge                     => Edge,\n+               All_Elaborable_Vertices  => All_Elaborable_Vertices,\n+               All_Waiting_Vertices     => All_Waiting_Vertices,\n+               Comp_Elaborable_Vertices => Comp_Elaborable_Vertices,\n+               Comp_Waiting_Vertices    => Comp_Waiting_Vertices,\n+               Step                     => Step,\n+               Indent                   => Indent);\n          end loop;\n       end Update_Successors;\n    end Invocation_And_Library_Graph_Elaborators;"}, {"sha": "387d969f74e327aedfb9973392db0ccaa7b5dc84", "filename": "gcc/ada/bindo-graphs.adb", "status": "modified", "additions": 372, "deletions": 155, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-graphs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-graphs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-graphs.adb?ref=92c7734db7af1395be571c5ec023a38fb7b42adf", "patch": "@@ -205,7 +205,7 @@ package body Bindo.Graphs is\n         (G   : Invocation_Graph;\n          Rel : Source_Target_Relation) return Boolean;\n       pragma Inline (Is_Existing_Source_Target_Relation);\n-      --  Determine whether a source vertex and a target vertex desctibed by\n+      --  Determine whether a source vertex and a target vertex described by\n       --  relation Rel are already related in invocation graph G.\n \n       procedure Save_Elaboration_Root\n@@ -226,7 +226,7 @@ package body Bindo.Graphs is\n          Rel : Source_Target_Relation;\n          Val : Boolean := True);\n       pragma Inline (Set_Is_Existing_Source_Target_Relation);\n-      --  Mark a source vertex and a target vertex desctibed by relation Rel as\n+      --  Mark a source vertex and a target vertex described by relation Rel as\n       --  already related in invocation graph G depending on value Val.\n \n       procedure Set_IGE_Attributes\n@@ -1026,18 +1026,6 @@ package body Bindo.Graphs is\n \n    package body Library_Graphs is\n \n-      -----------\n-      -- Types --\n-      -----------\n-\n-      --  The following type represents the various kinds of precedence between\n-      --  two items.\n-\n-      type Precedence_Kind is\n-        (Lower_Precedence,\n-         Equal_Precedence,\n-         Higher_Precedence);\n-\n       -----------------------\n       -- Local subprograms --\n       -----------------------\n@@ -1064,7 +1052,7 @@ package body Bindo.Graphs is\n          Attrs  : Library_Graph_Cycle_Attributes;\n          Indent : Indentation_Level);\n       pragma Inline (Add_Cycle);\n-      --  Store a cycle described by attribytes Attrs in library graph G,\n+      --  Store a cycle described by attributes Attrs in library graph G,\n       --  unless a prior rotation of it already exists. The edges of the cycle\n       --  must be in normalized form. Indent is the desired indentation level\n       --  for tracing.\n@@ -1090,15 +1078,6 @@ package body Bindo.Graphs is\n       --  part of an Elaborate_Body pair, or flag Do_Complement is set, add\n       --  the complementary vertex to the set.\n \n-      function Complementary_Vertex\n-        (G             : Library_Graph;\n-         Vertex        : Library_Graph_Vertex_Id;\n-         Do_Complement : Boolean) return Library_Graph_Vertex_Id;\n-      pragma Inline (Complementary_Vertex);\n-      --  If vertex Vertex of library graph G is part of an Elaborate_Body\n-      --  pair, or flag Do_Complement is set, return the spec when Vertex is\n-      --  a body, the body when Vertex is a spec, or No_Library_Graph_Vertex.\n-\n       function Copy_Cycle_Path\n         (Cycle_Path : LGE_Lists.Doubly_Linked_List)\n          return LGE_Lists.Doubly_Linked_List;\n@@ -1228,17 +1207,21 @@ package body Bindo.Graphs is\n \n       procedure Increment_Pending_Predecessors\n         (G    : Library_Graph;\n-         Comp : Component_Id);\n+         Comp : Component_Id;\n+         Edge : Library_Graph_Edge_Id);\n       pragma Inline (Increment_Pending_Predecessors);\n-      --  Increment the number of pending precedessors component Comp of\n-      --  library graph G must wait on before it can be elaborated by one.\n+      --  Increment the number of pending predecessors component Comp which was\n+      --  reached via edge Edge of library graph G must wait on before it can\n+      --  be elaborated by one.\n \n       procedure Increment_Pending_Predecessors\n         (G      : Library_Graph;\n-         Vertex : Library_Graph_Vertex_Id);\n+         Vertex : Library_Graph_Vertex_Id;\n+         Edge   : Library_Graph_Edge_Id);\n       pragma Inline (Increment_Pending_Predecessors);\n-      --  Increment the number of pending precedessors vertex Vertex of library\n-      --  graph G must wait on before it can be elaborated by one.\n+      --  Increment the number of pending predecessors vertex Vertex which was\n+      --  reached via edge Edge of library graph G must wait on before it can\n+      --  be elaborated by one.\n \n       procedure Initialize_Components (G : Library_Graph);\n       pragma Inline (Initialize_Components);\n@@ -1306,30 +1289,22 @@ package body Bindo.Graphs is\n          Edge : Library_Graph_Edge_Id) return Boolean;\n       pragma Inline (Is_Cyclic_With_Edge);\n       --  Determine whether edge Edge of library graph G participates in a\n-      --  cycle and is the result of awith dependency between its successor\n+      --  cycle and is the result of a with dependency between its successor\n       --  and predecessor.\n \n-      function Is_Elaborable_Vertex\n-        (G            : Library_Graph;\n-         Vertex       : Library_Graph_Vertex_Id;\n-         Predecessors : Natural) return Boolean;\n-      pragma Inline (Is_Elaborable_Vertex);\n-      --  Determine whether vertex Vertex of library graph G can be elaborated\n-      --  given that it meets number of predecessors Predecessors.\n-\n       function Is_Recorded_Cycle\n         (G     : Library_Graph;\n          Attrs : Library_Graph_Cycle_Attributes) return Boolean;\n       pragma Inline (Is_Recorded_Cycle);\n-      --  Determine whether a cycle desctibed by its attributes Attrs has\n+      --  Determine whether a cycle described by its attributes Attrs has\n       --  has already been recorded in library graph G.\n \n       function Is_Recorded_Edge\n         (G   : Library_Graph;\n          Rel : Predecessor_Successor_Relation) return Boolean;\n       pragma Inline (Is_Recorded_Edge);\n       --  Determine whether a predecessor vertex and a successor vertex\n-      --  desctibed by relation Rel are already linked in library graph G.\n+      --  described by relation Rel are already linked in library graph G.\n \n       function Links_Vertices_In_Same_Component\n         (G    : Library_Graph;\n@@ -1441,7 +1416,7 @@ package body Bindo.Graphs is\n          Rel : Predecessor_Successor_Relation;\n          Val : Boolean := True);\n       pragma Inline (Set_Is_Recorded_Edge);\n-      --  Mark a predecessor vertex and a successor vertex desctibed by\n+      --  Mark a predecessor vertex and a successor vertex described by\n       --  relation Rel as already linked depending on value Val.\n \n       procedure Set_LGC_Attributes\n@@ -1493,6 +1468,16 @@ package body Bindo.Graphs is\n       --  Write the contents of vertex Vertex of library graph G to standard\n       --  output. Indent is the desired indentation level for tracing.\n \n+      procedure Update_Pending_Predecessors\n+        (Strong_Predecessors : in out Natural;\n+         Weak_Predecessors   : in out Natural;\n+         Update_Weak         : Boolean;\n+         Value               : Integer);\n+      pragma Inline (Update_Pending_Predecessors);\n+      --  Update the number of pending strong or weak predecessors denoted by\n+      --  Strong_Predecessors and Weak_Predecessors respectively depending on\n+      --  flag Update_Weak by adding value Value.\n+\n       procedure Update_Pending_Predecessors_Of_Components (G : Library_Graph);\n       pragma Inline (Update_Pending_Predecessors_Of_Components);\n       --  Update the number of pending predecessors all components of library\n@@ -1523,7 +1508,7 @@ package body Bindo.Graphs is\n          pragma Assert (LGE_Lists.Present (Edges));\n \n          --  A vertex requires a special Body_Before_Spec edge to its\n-         --  Corresponging_Item when it either denotes a\n+         --  Corresponding_Item when it either denotes a\n          --\n          --    * Body that completes a previous spec\n          --\n@@ -1717,7 +1702,10 @@ package body Bindo.Graphs is\n          --  Update the number of pending predecessors the successor must wait\n          --  on before it is elaborated.\n \n-         Increment_Pending_Predecessors (G, Succ);\n+         Increment_Pending_Predecessors\n+           (G      => G,\n+            Vertex => Succ,\n+            Edge   => Edge);\n \n          --  Update the edge statistics\n \n@@ -1757,10 +1745,12 @@ package body Bindo.Graphs is\n          Set_LGV_Attributes\n            (G      => G,\n             Vertex => Vertex,\n-            Val    => (Corresponding_Item   => No_Library_Graph_Vertex,\n-                       In_Elaboration_Order => False,\n-                       Pending_Predecessors => 0,\n-                       Unit                 => U_Id));\n+            Val    =>\n+              (Corresponding_Item          => No_Library_Graph_Vertex,\n+               In_Elaboration_Order        => False,\n+               Pending_Strong_Predecessors => 0,\n+               Pending_Weak_Predecessors   => 0,\n+               Unit                        => U_Id));\n \n          --  Associate the unit with its corresponding vertex\n \n@@ -1783,9 +1773,9 @@ package body Bindo.Graphs is\n \n          Complement : constant Library_Graph_Vertex_Id :=\n                         Complementary_Vertex\n-                          (G             => G,\n-                           Vertex        => Vertex,\n-                           Do_Complement => Do_Complement);\n+                          (G                => G,\n+                           Vertex           => Vertex,\n+                           Force_Complement => Do_Complement);\n \n       begin\n          LGV_Sets.Insert (Set, Vertex);\n@@ -1800,9 +1790,9 @@ package body Bindo.Graphs is\n       --------------------------\n \n       function Complementary_Vertex\n-        (G             : Library_Graph;\n-         Vertex        : Library_Graph_Vertex_Id;\n-         Do_Complement : Boolean) return Library_Graph_Vertex_Id\n+        (G                : Library_Graph;\n+         Vertex           : Library_Graph_Vertex_Id;\n+         Force_Complement : Boolean) return Library_Graph_Vertex_Id\n       is\n          Complement : Library_Graph_Vertex_Id;\n \n@@ -1816,7 +1806,7 @@ package body Bindo.Graphs is\n \n          --  The caller requests the complement explicitly\n \n-         if Do_Complement then\n+         if Force_Complement then\n             Complement := Corresponding_Item (G, Vertex);\n \n          --  The vertex is a completing body of a spec subject to pragma\n@@ -1850,6 +1840,46 @@ package body Bindo.Graphs is\n          return DG.Component (G.Graph, Vertex);\n       end Component;\n \n+      ------------------------------------\n+      -- Contains_Weak_Static_Successor --\n+      ------------------------------------\n+\n+      function Contains_Weak_Static_Successor\n+        (G     : Library_Graph;\n+         Cycle : Library_Graph_Cycle_Id) return Boolean\n+      is\n+         Edge : Library_Graph_Edge_Id;\n+         Iter : Edges_Of_Cycle_Iterator;\n+         Seen : Boolean;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Cycle));\n+\n+         --  Assume that no weak static successor has been seen\n+\n+         Seen := False;\n+\n+         --  IMPORTANT:\n+         --\n+         --    * The iteration must run to completion in order to unlock the\n+         --      edges of the cycle.\n+\n+         Iter := Iterate_Edges_Of_Cycle (G, Cycle);\n+         while Has_Next (Iter) loop\n+            Next (Iter, Edge);\n+\n+            if not Seen\n+              and then Is_Invocation_Edge (G, Edge)\n+              and then not Is_Dynamically_Elaborated (G, Successor (G, Edge))\n+            then\n+               Seen := True;\n+            end if;\n+         end loop;\n+\n+         return Seen;\n+      end Contains_Weak_Static_Successor;\n+\n       ---------------------\n       -- Copy_Cycle_Path --\n       ---------------------\n@@ -1911,15 +1941,12 @@ package body Bindo.Graphs is\n       ------------\n \n       function Create\n-        (Initial_Vertices       : Positive;\n-         Initial_Edges          : Positive;\n-         Dynamically_Elaborated : Boolean) return Library_Graph\n+        (Initial_Vertices : Positive;\n+         Initial_Edges    : Positive) return Library_Graph\n       is\n          G : constant Library_Graph := new Library_Graph_Attributes;\n \n       begin\n-         G.Dynamically_Elaborated := Dynamically_Elaborated;\n-\n          G.Component_Attributes := Component_Tables.Create (Initial_Vertices);\n          G.Cycle_Attributes     := LGC_Tables.Create       (Initial_Vertices);\n          G.Cycles               := LGC_Lists.Create;\n@@ -1990,7 +2017,8 @@ package body Bindo.Graphs is\n \n       procedure Decrement_Pending_Predecessors\n         (G    : Library_Graph;\n-         Comp : Component_Id)\n+         Comp : Component_Id;\n+         Edge : Library_Graph_Edge_Id)\n       is\n          Attrs : Component_Attributes;\n \n@@ -1999,7 +2027,13 @@ package body Bindo.Graphs is\n          pragma Assert (Present (Comp));\n \n          Attrs := Get_Component_Attributes (G, Comp);\n-         Attrs.Pending_Predecessors := Attrs.Pending_Predecessors - 1;\n+\n+         Update_Pending_Predecessors\n+           (Strong_Predecessors => Attrs.Pending_Strong_Predecessors,\n+            Weak_Predecessors   => Attrs.Pending_Weak_Predecessors,\n+            Update_Weak         => Is_Invocation_Edge (G, Edge),\n+            Value               => -1);\n+\n          Set_Component_Attributes (G, Comp, Attrs);\n       end Decrement_Pending_Predecessors;\n \n@@ -2009,7 +2043,8 @@ package body Bindo.Graphs is\n \n       procedure Decrement_Pending_Predecessors\n         (G      : Library_Graph;\n-         Vertex : Library_Graph_Vertex_Id)\n+         Vertex : Library_Graph_Vertex_Id;\n+         Edge   : Library_Graph_Edge_Id)\n       is\n          Attrs : Library_Graph_Vertex_Attributes;\n \n@@ -2018,7 +2053,13 @@ package body Bindo.Graphs is\n          pragma Assert (Present (Vertex));\n \n          Attrs := Get_LGV_Attributes (G, Vertex);\n-         Attrs.Pending_Predecessors := Attrs.Pending_Predecessors - 1;\n+\n+         Update_Pending_Predecessors\n+           (Strong_Predecessors => Attrs.Pending_Strong_Predecessors,\n+            Weak_Predecessors   => Attrs.Pending_Weak_Predecessors,\n+            Update_Weak         => Is_Invocation_Edge (G, Edge),\n+            Value               => -1);\n+\n          Set_LGV_Attributes (G, Vertex, Attrs);\n       end Decrement_Pending_Predecessors;\n \n@@ -2071,7 +2112,10 @@ package body Bindo.Graphs is\n          --  Update the number of pending predecessors the successor must wait\n          --  on before it is elaborated.\n \n-         Decrement_Pending_Predecessors (G, Succ);\n+         Decrement_Pending_Predecessors\n+           (G      => G,\n+            Vertex => Succ,\n+            Edge   => Edge);\n \n          --  Delete the link between the predecessor and successor. This allows\n          --  for further attempts to link the same predecessor and successor.\n@@ -2298,9 +2342,9 @@ package body Bindo.Graphs is\n               (G                      => G,\n                Vertex                 =>\n                  Complementary_Vertex\n-                   (G             => G,\n-                    Vertex        => Vertex,\n-                    Do_Complement => Spec_And_Body_Together),\n+                   (G                => G,\n+                    Vertex           => Vertex,\n+                    Force_Complement => Spec_And_Body_Together),\n                End_Vertices           => End_Vertices,\n                Most_Significant_Edge  => Most_Significant_Edge,\n                Invocation_Edge_Count  => Invocation_Edge_Count,\n@@ -2343,7 +2387,7 @@ package body Bindo.Graphs is\n          Trace_Edge (G, Initial_Edge, Indent);\n \n          --  Use a set to represent the end vertices of the cycle. The set is\n-         --  needed to accomodate the Elaborate_All and Elaborate_Body cases\n+         --  needed to accommodate the Elaborate_All and Elaborate_Body cases\n          --  where a cycle may terminate on either a spec or a body vertex.\n \n          End_Vertices := LGV_Sets.Create (2);\n@@ -2650,7 +2694,10 @@ package body Bindo.Graphs is\n          U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n \n       begin\n-         return U_Rec.Elaborate_Body;\n+         --  Treat the spec and body as decoupled when switch -d_b (ignore the\n+         --  effects of pragma Elaborate_Body) is in effect.\n+\n+         return U_Rec.Elaborate_Body and not Debug_Flag_Underscore_B;\n       end Has_Elaborate_Body;\n \n       --------------\n@@ -2884,7 +2931,8 @@ package body Bindo.Graphs is\n \n       procedure Increment_Pending_Predecessors\n         (G    : Library_Graph;\n-         Comp : Component_Id)\n+         Comp : Component_Id;\n+         Edge : Library_Graph_Edge_Id)\n       is\n          Attrs : Component_Attributes;\n \n@@ -2893,7 +2941,13 @@ package body Bindo.Graphs is\n          pragma Assert (Present (Comp));\n \n          Attrs := Get_Component_Attributes (G, Comp);\n-         Attrs.Pending_Predecessors := Attrs.Pending_Predecessors + 1;\n+\n+         Update_Pending_Predecessors\n+           (Strong_Predecessors => Attrs.Pending_Strong_Predecessors,\n+            Weak_Predecessors   => Attrs.Pending_Weak_Predecessors,\n+            Update_Weak         => Is_Invocation_Edge (G, Edge),\n+            Value               => 1);\n+\n          Set_Component_Attributes (G, Comp, Attrs);\n       end Increment_Pending_Predecessors;\n \n@@ -2903,7 +2957,8 @@ package body Bindo.Graphs is\n \n       procedure Increment_Pending_Predecessors\n         (G      : Library_Graph;\n-         Vertex : Library_Graph_Vertex_Id)\n+         Vertex : Library_Graph_Vertex_Id;\n+         Edge   : Library_Graph_Edge_Id)\n       is\n          Attrs : Library_Graph_Vertex_Attributes;\n \n@@ -2912,7 +2967,13 @@ package body Bindo.Graphs is\n          pragma Assert (Present (Vertex));\n \n          Attrs := Get_LGV_Attributes (G, Vertex);\n-         Attrs.Pending_Predecessors := Attrs.Pending_Predecessors + 1;\n+\n+         Update_Pending_Predecessors\n+           (Strong_Predecessors => Attrs.Pending_Strong_Predecessors,\n+            Weak_Predecessors   => Attrs.Pending_Weak_Predecessors,\n+            Update_Weak         => Is_Invocation_Edge (G, Edge),\n+            Value               => 1);\n+\n          Set_LGV_Attributes (G, Vertex, Attrs);\n       end Increment_Pending_Predecessors;\n \n@@ -2925,7 +2986,7 @@ package body Bindo.Graphs is\n          pragma Assert (Present (G));\n \n          --  The graph already contains a set of components. Reinitialize\n-         --  them in order to accomodate the new set of components about to\n+         --  them in order to accommodate the new set of components about to\n          --  be computed.\n \n          if Number_Of_Components (G) > 0 then\n@@ -3216,11 +3277,15 @@ package body Bindo.Graphs is\n       -- Is_Dynamically_Elaborated --\n       -------------------------------\n \n-      function Is_Dynamically_Elaborated (G : Library_Graph) return Boolean is\n+      function Is_Dynamically_Elaborated\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean\n+      is\n       begin\n          pragma Assert (Present (G));\n+         pragma Assert (Present (Vertex));\n \n-         return G.Dynamically_Elaborated;\n+         return Is_Dynamically_Elaborated (Unit (G, Vertex));\n       end Is_Dynamically_Elaborated;\n \n       -----------------------------\n@@ -3235,12 +3300,14 @@ package body Bindo.Graphs is\n          pragma Assert (Present (G));\n          pragma Assert (Present (Comp));\n \n-         --  A component can be elaborated when\n+         --  A component is elaborable when:\n          --\n-         --    * The component is no longer wanting on any of its predecessors\n-         --      to be elaborated.\n+         --    * It is not waiting on strong predecessors, and\n+         --    * It is not waiting on weak predecessors\n \n-         return Pending_Predecessors (G, Comp) = 0;\n+         return\n+           Pending_Strong_Predecessors (G, Comp) = 0\n+             and then Pending_Weak_Predecessors (G, Comp) = 0;\n       end Is_Elaborable_Component;\n \n       --------------------------\n@@ -3251,80 +3318,47 @@ package body Bindo.Graphs is\n         (G      : Library_Graph;\n          Vertex : Library_Graph_Vertex_Id) return Boolean\n       is\n-         Check_Vertex : Library_Graph_Vertex_Id;\n-\n-      begin\n          pragma Assert (Present (G));\n          pragma Assert (Present (Vertex));\n \n-         Check_Vertex := Vertex;\n-\n-         --  A spec-body pair where the spec carries pragma Elaborate_Body must\n-         --  be treated as one vertex for elaboration purposes. Use the spec as\n-         --  the point of reference for the composite vertex.\n-\n-         if Is_Body_Of_Spec_With_Elaborate_Body (G, Check_Vertex) then\n-            Check_Vertex := Proper_Spec (G, Check_Vertex);\n-         end if;\n-\n-         return\n-           Is_Elaborable_Vertex\n-             (G            => G,\n-              Vertex       => Check_Vertex,\n-              Predecessors => 0);\n-      end Is_Elaborable_Vertex;\n-\n-      --------------------------\n-      -- Is_Elaborable_Vertex --\n-      --------------------------\n+         Complement : constant Library_Graph_Vertex_Id :=\n+                        Complementary_Vertex\n+                          (G                => G,\n+                           Vertex           => Vertex,\n+                           Force_Complement => False);\n \n-      function Is_Elaborable_Vertex\n-        (G            : Library_Graph;\n-         Vertex       : Library_Graph_Vertex_Id;\n-         Predecessors : Natural) return Boolean\n-      is\n-         Body_Vertex : Library_Graph_Vertex_Id;\n+         Strong_Preds : Natural;\n+         Weak_Preds   : Natural;\n \n       begin\n-         pragma Assert (Present (G));\n-         pragma Assert (Present (Vertex));\n-\n-         --  The vertex must not be re-elaborated once it has been elaborated\n+         --  A vertex is elaborable when:\n+         --\n+         --    * It has not been elaborated yet, and\n+         --    * The complement vertex of an Elaborate_Body pair has not been\n+         --      elaborated yet, and\n+         --    * It resides within an elaborable component, and\n+         --    * It is not waiting on strong predecessors, and\n+         --    * It is not waiting on weak predecessors\n \n          if In_Elaboration_Order (G, Vertex) then\n             return False;\n \n-         --  The vertex must not be waiting on more precedessors than requested\n-         --  to be elaborated.\n-\n-         elsif Pending_Predecessors (G, Vertex) /= Predecessors then\n+         elsif Present (Complement)\n+           and then In_Elaboration_Order (G, Complement)\n+         then\n             return False;\n \n-         --  The component where the vertex resides must not be waiting on any\n-         --  of its precedessors to be elaborated.\n-\n          elsif not Is_Elaborable_Component (G, Component (G, Vertex)) then\n             return False;\n-\n-         --  The vertex denotes a spec with a completing body, and is subject\n-         --  to pragma Elaborate_Body. The body must be elaborable for the\n-         --  vertex to be elaborated. Account for the sole predecessor of the\n-         --  body which is the vertex itself.\n-\n-         elsif Is_Spec_With_Elaborate_Body (G, Vertex) then\n-            Body_Vertex := Proper_Body (G, Vertex);\n-            pragma Assert (Present (Body_Vertex));\n-\n-            return\n-              Is_Elaborable_Vertex\n-                (G            => G,\n-                 Vertex       => Body_Vertex,\n-                 Predecessors => 1);\n          end if;\n \n-         --  At this point it is known that the vertex can be elaborated\n+         Pending_Predecessors_For_Elaboration\n+           (G            => G,\n+            Vertex       => Vertex,\n+            Strong_Preds => Strong_Preds,\n+            Weak_Preds   => Weak_Preds);\n \n-         return True;\n+         return Strong_Preds = 0 and then Weak_Preds = 0;\n       end Is_Elaborable_Vertex;\n \n       ---------------------------\n@@ -3378,6 +3412,26 @@ package body Bindo.Graphs is\n          return Kind (G, Edge) = Elaborate_Edge;\n       end Is_Elaborate_Edge;\n \n+      ----------------------------\n+      -- Is_Elaborate_Body_Pair --\n+      ----------------------------\n+\n+      function Is_Elaborate_Body_Pair\n+        (G           : Library_Graph;\n+         Spec_Vertex : Library_Graph_Vertex_Id;\n+         Body_Vertex : Library_Graph_Vertex_Id) return Boolean\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Spec_Vertex));\n+         pragma Assert (Present (Body_Vertex));\n+\n+         return\n+           Is_Spec_With_Elaborate_Body (G, Spec_Vertex)\n+             and then Is_Body_Of_Spec_With_Elaborate_Body (G, Body_Vertex)\n+             and then Proper_Body (G, Spec_Vertex) = Body_Vertex;\n+      end Is_Elaborate_Body_Pair;\n+\n       --------------------\n       -- Is_Forced_Edge --\n       --------------------\n@@ -3539,6 +3593,57 @@ package body Bindo.Graphs is\n              and then Has_Elaborate_Body (G, Vertex);\n       end Is_Spec_With_Elaborate_Body;\n \n+      ---------------------------------\n+      -- Is_Weakly_Elaborable_Vertex --\n+      ----------------------------------\n+\n+      function Is_Weakly_Elaborable_Vertex\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Vertex));\n+\n+         Complement : constant Library_Graph_Vertex_Id :=\n+                        Complementary_Vertex\n+                          (G                => G,\n+                           Vertex           => Vertex,\n+                           Force_Complement => False);\n+\n+         Strong_Preds : Natural;\n+         Weak_Preds   : Natural;\n+\n+      begin\n+         --  A vertex is weakly elaborable when:\n+         --\n+         --    * It has not been elaborated yet, and\n+         --    * The complement vertex of an Elaborate_Body pair has not been\n+         --      elaborated yet, and\n+         --    * It resides within an elaborable component, and\n+         --    * It is not waiting on strong predecessors, and\n+         --    * It is waiting on at least one weak predecessor\n+\n+         if In_Elaboration_Order (G, Vertex) then\n+            return False;\n+\n+         elsif Present (Complement)\n+           and then In_Elaboration_Order (G, Complement)\n+         then\n+            return False;\n+\n+         elsif not Is_Elaborable_Component (G, Component (G, Vertex)) then\n+            return False;\n+         end if;\n+\n+         Pending_Predecessors_For_Elaboration\n+           (G            => G,\n+            Vertex       => Vertex,\n+            Strong_Preds => Strong_Preds,\n+            Weak_Preds   => Weak_Preds);\n+\n+         return Strong_Preds = 0 and then Weak_Preds >= 1;\n+      end Is_Weakly_Elaborable_Vertex;\n+\n       ------------------\n       -- Is_With_Edge --\n       ------------------\n@@ -4044,35 +4149,126 @@ package body Bindo.Graphs is\n          return Get_LGC_Attributes (G, Cycle).Path;\n       end Path;\n \n-      --------------------------\n-      -- Pending_Predecessors --\n-      --------------------------\n+      ------------------------------------------\n+      -- Pending_Predecessors_For_Elaboration --\n+      ------------------------------------------\n \n-      function Pending_Predecessors\n+      procedure Pending_Predecessors_For_Elaboration\n+        (G            : Library_Graph;\n+         Vertex       : Library_Graph_Vertex_Id;\n+         Strong_Preds : out Natural;\n+         Weak_Preds   : out Natural)\n+      is\n+         Complement         : Library_Graph_Vertex_Id;\n+         Spec_Vertex        : Library_Graph_Vertex_Id;\n+         Total_Strong_Preds : Natural;\n+         Total_Weak_Preds   : Natural;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Vertex));\n+\n+         Total_Strong_Preds := Pending_Strong_Predecessors (G, Vertex);\n+         Total_Weak_Preds   := Pending_Weak_Predecessors   (G, Vertex);\n+\n+         --  Assume that there is no complementary vertex that needs to be\n+         --  examined.\n+\n+         Complement  := No_Library_Graph_Vertex;\n+         Spec_Vertex := No_Library_Graph_Vertex;\n+\n+         if Is_Body_Of_Spec_With_Elaborate_Body (G, Vertex) then\n+            Complement  := Proper_Spec (G, Vertex);\n+            Spec_Vertex := Complement;\n+\n+         elsif Is_Spec_With_Elaborate_Body (G, Vertex) then\n+            Complement  := Proper_Body (G, Vertex);\n+            Spec_Vertex := Vertex;\n+         end if;\n+\n+         --  The vertex is part of an Elaborate_Body pair. Take into account\n+         --  the strong and weak predecessors of the complementary vertex.\n+\n+         if Present (Complement) then\n+            Total_Strong_Preds :=\n+              Pending_Strong_Predecessors (G, Complement) + Total_Strong_Preds;\n+            Total_Weak_Preds :=\n+              Pending_Weak_Predecessors   (G, Complement) + Total_Weak_Preds;\n+\n+            --  The body of an Elaborate_Body pair is the successor of a strong\n+            --  edge where the predecessor is the spec. This edge must not be\n+            --  considered for elaboration purposes because the pair is treated\n+            --  as one vertex. Account for the edge only when the spec has not\n+            --  been elaborated yet.\n+\n+            if not In_Elaboration_Order (G, Spec_Vertex) then\n+               Total_Strong_Preds := Total_Strong_Preds - 1;\n+            end if;\n+         end if;\n+\n+         Strong_Preds := Total_Strong_Preds;\n+         Weak_Preds   := Total_Weak_Preds;\n+      end Pending_Predecessors_For_Elaboration;\n+\n+      ---------------------------------\n+      -- Pending_Strong_Predecessors --\n+      ---------------------------------\n+\n+      function Pending_Strong_Predecessors\n         (G    : Library_Graph;\n          Comp : Component_Id) return Natural\n       is\n       begin\n          pragma Assert (Present (G));\n          pragma Assert (Present (Comp));\n \n-         return Get_Component_Attributes (G, Comp).Pending_Predecessors;\n-      end Pending_Predecessors;\n+         return Get_Component_Attributes (G, Comp).Pending_Strong_Predecessors;\n+      end Pending_Strong_Predecessors;\n \n-      --------------------------\n-      -- Pending_Predecessors --\n-      --------------------------\n+      ---------------------------------\n+      -- Pending_Strong_Predecessors --\n+      ---------------------------------\n \n-      function Pending_Predecessors\n+      function Pending_Strong_Predecessors\n         (G      : Library_Graph;\n          Vertex : Library_Graph_Vertex_Id) return Natural\n       is\n       begin\n          pragma Assert (Present (G));\n          pragma Assert (Present (Vertex));\n \n-         return Get_LGV_Attributes (G, Vertex).Pending_Predecessors;\n-      end Pending_Predecessors;\n+         return Get_LGV_Attributes (G, Vertex).Pending_Strong_Predecessors;\n+      end Pending_Strong_Predecessors;\n+\n+      -------------------------------\n+      -- Pending_Weak_Predecessors --\n+      -------------------------------\n+\n+      function Pending_Weak_Predecessors\n+        (G    : Library_Graph;\n+         Comp : Component_Id) return Natural\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         return Get_Component_Attributes (G, Comp).Pending_Weak_Predecessors;\n+      end Pending_Weak_Predecessors;\n+\n+      -------------------------------\n+      -- Pending_Weak_Predecessors --\n+      -------------------------------\n+\n+      function Pending_Weak_Predecessors\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Natural\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Vertex));\n+\n+         return Get_LGV_Attributes (G, Vertex).Pending_Weak_Predecessors;\n+      end Pending_Weak_Predecessors;\n \n       ----------------\n       -- Precedence --\n@@ -4306,9 +4502,9 @@ package body Bindo.Graphs is\n \n          Complement : constant Library_Graph_Vertex_Id :=\n                         Complementary_Vertex\n-                          (G             => G,\n-                           Vertex        => Vertex,\n-                           Do_Complement => Do_Complement);\n+                          (G                => G,\n+                           Vertex           => Vertex,\n+                           Force_Complement => Do_Complement);\n \n       begin\n          LGV_Sets.Delete (Set, Vertex);\n@@ -4702,6 +4898,24 @@ package body Bindo.Graphs is\n          return Get_LGV_Attributes (G, Vertex).Unit;\n       end Unit;\n \n+      ---------------------------------\n+      -- Update_Pending_Predecessors --\n+      ---------------------------------\n+\n+      procedure Update_Pending_Predecessors\n+        (Strong_Predecessors : in out Natural;\n+         Weak_Predecessors   : in out Natural;\n+         Update_Weak         : Boolean;\n+         Value               : Integer)\n+      is\n+      begin\n+         if Update_Weak then\n+            Weak_Predecessors := Weak_Predecessors + Value;\n+         else\n+            Strong_Predecessors := Strong_Predecessors + Value;\n+         end if;\n+      end Update_Pending_Predecessors;\n+\n       -----------------------------------------------\n       -- Update_Pending_Predecessors_Of_Components --\n       -----------------------------------------------\n@@ -4748,7 +4962,10 @@ package body Bindo.Graphs is\n          --  must wait on another predecessor until it can be elaborated.\n \n          if Pred_Comp /= Succ_Comp then\n-            Increment_Pending_Predecessors (G, Succ_Comp);\n+            Increment_Pending_Predecessors\n+              (G    => G,\n+               Comp => Succ_Comp,\n+               Edge => Edge);\n          end if;\n       end Update_Pending_Predecessors_Of_Components;\n    end Library_Graphs;\n@@ -4835,7 +5052,7 @@ package body Bindo.Graphs is\n    --------------------------\n \n    LGC_Sequencer : Library_Graph_Cycle_Id := First_Library_Graph_Cycle;\n-   --  The couhnter for library graph cycles. Do not directly manipulate its\n+   --  The counter for library graph cycles. Do not directly manipulate its\n    --  value.\n \n    function Sequence_Next_Cycle return Library_Graph_Cycle_Id is"}, {"sha": "3c2fef0182535045d7a1ce1bbf40e6414a325fb0", "filename": "gcc/ada/bindo-graphs.ads", "status": "modified", "additions": 115, "deletions": 41, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-graphs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-graphs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-graphs.ads?ref=92c7734db7af1395be571c5ec023a38fb7b42adf", "patch": "@@ -668,7 +668,7 @@ package Bindo.Graphs is\n \n       --  The following type represents the various kinds of library graph\n       --  cycles. The ordering of kinds is significant, where a literal with\n-      --  lower ordinal has a higner precedence than one with higher ordinal.\n+      --  lower ordinal has a higher precedence than one with higher ordinal.\n \n       type Library_Graph_Cycle_Kind is\n         (Elaborate_Body_Cycle,\n@@ -753,13 +753,11 @@ package Bindo.Graphs is\n       --  describes.\n \n       function Create\n-        (Initial_Vertices       : Positive;\n-         Initial_Edges          : Positive;\n-         Dynamically_Elaborated : Boolean) return Library_Graph;\n+        (Initial_Vertices : Positive;\n+         Initial_Edges    : Positive) return Library_Graph;\n       pragma Inline (Create);\n       --  Create a new empty graph with vertex capacity Initial_Vertices and\n-      --  edge capacity Initial_Edges. Flag Dynamically_Elaborated must be set\n-      --  when the main library unit was compiled using the dynamic model.\n+      --  edge capacity Initial_Edges.\n \n       procedure Destroy (G : in out Library_Graph);\n       pragma Inline (Destroy);\n@@ -809,10 +807,12 @@ package Bindo.Graphs is\n \n       procedure Decrement_Pending_Predecessors\n         (G      : Library_Graph;\n-         Vertex : Library_Graph_Vertex_Id);\n+         Vertex : Library_Graph_Vertex_Id;\n+         Edge   : Library_Graph_Edge_Id);\n       pragma Inline (Decrement_Pending_Predecessors);\n-      --  Decrease the number of pending predecessors vertex Vertex of library\n-      --  graph G must wait on until it can be elaborated.\n+      --  Decrease the number of pending predecessors vertex Vertex which was\n+      --  reached via edge Edge of library graph G must wait until it can be\n+      --  elaborated.\n \n       function File_Name\n         (G      : Library_Graph;\n@@ -844,12 +844,30 @@ package Bindo.Graphs is\n       --  Obtain the name of the unit which vertex Vertex of library graph G\n       --  represents.\n \n-      function Pending_Predecessors\n+      procedure Pending_Predecessors_For_Elaboration\n+        (G            : Library_Graph;\n+         Vertex       : Library_Graph_Vertex_Id;\n+         Strong_Preds : out Natural;\n+         Weak_Preds   : out Natural);\n+      pragma Inline (Pending_Predecessors_For_Elaboration);\n+      --  Obtain the number of pending strong and weak predecessors of vertex\n+      --  Vertex of library graph G, taking into account Elaborate_Body pairs.\n+      --  Strong predecessors are returned in Strong_Preds. Weak predecessors\n+      --  are returned in Weak_Preds.\n+\n+      function Pending_Strong_Predecessors\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Natural;\n+      pragma Inline (Pending_Strong_Predecessors);\n+      --  Obtain the number of pending strong predecessors vertex Vertex of\n+      --  library graph G must wait on until it can be elaborated.\n+\n+      function Pending_Weak_Predecessors\n         (G      : Library_Graph;\n          Vertex : Library_Graph_Vertex_Id) return Natural;\n-      pragma Inline (Pending_Predecessors);\n-      --  Obtain the number of pending predecessors vertex Vertex of library\n-      --  graph G must wait on until it can be elaborated.\n+      pragma Inline (Pending_Weak_Predecessors);\n+      --  Obtain the number of pending weak predecessors vertex Vertex of\n+      --  library graph G must wait on until it can be elaborated.\n \n       procedure Set_Corresponding_Item\n         (G      : Library_Graph;\n@@ -901,17 +919,26 @@ package Bindo.Graphs is\n \n       procedure Decrement_Pending_Predecessors\n         (G    : Library_Graph;\n-         Comp : Component_Id);\n+         Comp : Component_Id;\n+         Edge : Library_Graph_Edge_Id);\n       pragma Inline (Decrement_Pending_Predecessors);\n-      --  Decrease the number of pending predecessors component Comp of library\n-      --  graph G must wait on until it can be elaborated.\n+      --  Decrease the number of pending predecessors component Comp which was\n+      --  reached via edge Edge of library graph G must wait on until it can be\n+      --  elaborated.\n \n-      function Pending_Predecessors\n+      function Pending_Strong_Predecessors\n         (G    : Library_Graph;\n          Comp : Component_Id) return Natural;\n-      pragma Inline (Pending_Predecessors);\n-      --  Obtain the number of pending predecessors component Comp of library\n-      --  graph G must wait on until it can be elaborated.\n+      pragma Inline (Pending_Strong_Predecessors);\n+      --  Obtain the number of pending strong predecessors component Comp of\n+      --  library graph G must wait on until it can be elaborated.\n+\n+      function Pending_Weak_Predecessors\n+        (G    : Library_Graph;\n+         Comp : Component_Id) return Natural;\n+      pragma Inline (Pending_Weak_Predecessors);\n+      --  Obtain the number of pending weak predecessors component Comp of\n+      --  library graph G must wait on until it can be elaborated.\n \n       ----------------------\n       -- Cycle attributes --\n@@ -940,6 +967,26 @@ package Bindo.Graphs is\n       -- Semantics --\n       ---------------\n \n+      function Complementary_Vertex\n+        (G                : Library_Graph;\n+         Vertex           : Library_Graph_Vertex_Id;\n+         Force_Complement : Boolean) return Library_Graph_Vertex_Id;\n+      pragma Inline (Complementary_Vertex);\n+      --  Obtain the complementary vertex of vertex Vertex of library graph G\n+      --  as follows:\n+      --\n+      --    * If Vertex is the spec of an Elaborate_Body pair, return the body\n+      --    * If Vertex is the body of an Elaborate_Body pair, return the spec\n+      --\n+      --  This behavior can be forced by setting flag Force_Complement to True.\n+\n+      function Contains_Weak_Static_Successor\n+        (G     : Library_Graph;\n+         Cycle : Library_Graph_Cycle_Id) return Boolean;\n+      pragma Inline (Contains_Weak_Static_Successor);\n+      --  Determine whether cycle Cycle of library graph G contains a weak edge\n+      --  where the successor was compiled using the static model.\n+\n       function Has_Elaborate_All_Cycle (G : Library_Graph) return Boolean;\n       pragma Inline (Has_Elaborate_All_Cycle);\n       --  Determine whether library graph G contains a cycle involving pragma\n@@ -973,22 +1020,26 @@ package Bindo.Graphs is\n       --  Determine whether vertex Vertex of library graph G denotes a body\n       --  with a corresponding spec.\n \n-      function Is_Dynamically_Elaborated (G : Library_Graph) return Boolean;\n+      function Is_Dynamically_Elaborated\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n       pragma Inline (Is_Dynamically_Elaborated);\n-      --  Determine whether library graph G was created from a set of units\n-      --  where the main library unit was compiled using the dynamic model.\n+      --  Determine whether vertex Vertex of library graph G was compiled\n+      --  using the dynamic model.\n \n       function Is_Elaborable_Component\n         (G    : Library_Graph;\n          Comp : Component_Id) return Boolean;\n       pragma Inline (Is_Elaborable_Component);\n-      --  Determine whether component Comp of library graph G can be elaborated\n+      --  Determine whether component Comp of library graph G is not waiting on\n+      --  any predecessors, and can thus be elaborated.\n \n       function Is_Elaborable_Vertex\n         (G      : Library_Graph;\n          Vertex : Library_Graph_Vertex_Id) return Boolean;\n       pragma Inline (Is_Elaborable_Vertex);\n-      --  Determine whether vertex Vertex of library graph G can be elaborated\n+      --  Determine whether vertex Vertex of library graph G is not waiting on\n+      --  any predecessors, and can thus be elaborated.\n \n       function Is_Elaborate_All_Edge\n         (G    : Library_Graph;\n@@ -1012,6 +1063,15 @@ package Bindo.Graphs is\n       --  Determine whether edge Edge of library graph G is an edge whose\n       --  predecessor is subject to pragma Elaborate.\n \n+      function Is_Elaborate_Body_Pair\n+        (G           : Library_Graph;\n+         Spec_Vertex : Library_Graph_Vertex_Id;\n+         Body_Vertex : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Elaborate_Body_Pair);\n+      --  Determine whether vertices Spec_Vertex and Body_Vertex of library\n+      --  graph G denote a spec subject to Elaborate_Body and its completing\n+      --  body.\n+\n       function Is_Forced_Edge\n         (G    : Library_Graph;\n          Edge : Library_Graph_Edge_Id) return Boolean;\n@@ -1045,7 +1105,7 @@ package Bindo.Graphs is\n          Vertex : Library_Graph_Vertex_Id) return Boolean;\n       pragma Inline (Is_Preelaborated_Unit);\n       --  Determine whether vertex Vertex of library graph G denotes a unit\n-      --  subjec to pragma Pure or Preelaborable.\n+      --  subject to pragma Pure or Preelaborable.\n \n       function Is_Spec\n         (G      : Library_Graph;\n@@ -1067,6 +1127,14 @@ package Bindo.Graphs is\n       --  Determine whether vertex Vertex of library graph G denotes a spec\n       --  with a corresponding body, and is subject to pragma Elaborate_Body.\n \n+      function Is_Weakly_Elaborable_Vertex\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Weakly_Elaborable_Vertex);\n+      --  Determine whether vertex Vertex of library graph G is waiting on\n+      --  weak predecessors only, in which case it can be elaborated assuming\n+      --  that the weak edges will not be exercised at elaboration time.\n+\n       function Is_With_Edge\n         (G    : Library_Graph;\n          Edge : Library_Graph_Edge_Id) return Boolean;\n@@ -1320,20 +1388,25 @@ package Bindo.Graphs is\n          In_Elaboration_Order : Boolean := False;\n          --  Set when this vertex is elaborated\n \n-         Pending_Predecessors : Natural := 0;\n-         --  The number of pending predecessor vertices this vertex must wait\n-         --  on before it can be elaborated.\n+         Pending_Strong_Predecessors : Natural := 0;\n+         --  The number of pending strong predecessor vertices this vertex must\n+         --  wait on before it can be elaborated.\n+\n+         Pending_Weak_Predecessors : Natural := 0;\n+         --  The number of weak predecessor vertices this vertex must wait on\n+         --  before it can be elaborated.\n \n          Unit : Unit_Id := No_Unit_Id;\n          --  The reference to unit this vertex represents\n       end record;\n \n       No_Library_Graph_Vertex_Attributes :\n         constant Library_Graph_Vertex_Attributes :=\n-          (Corresponding_Item   => No_Library_Graph_Vertex,\n-           In_Elaboration_Order => False,\n-           Pending_Predecessors => 0,\n-           Unit                 => No_Unit_Id);\n+          (Corresponding_Item          => No_Library_Graph_Vertex,\n+           In_Elaboration_Order        => False,\n+           Pending_Strong_Predecessors => 0,\n+           Pending_Weak_Predecessors   => 0,\n+           Unit                        => No_Unit_Id);\n \n       procedure Destroy_Library_Graph_Vertex_Attributes\n         (Attrs : in out Library_Graph_Vertex_Attributes);\n@@ -1391,13 +1464,18 @@ package Bindo.Graphs is\n       --  The following type represents the attributes of a component\n \n       type Component_Attributes is record\n-         Pending_Predecessors : Natural := 0;\n-         --  The number of pending predecessor components this component must\n-         --  wait on before it can be elaborated.\n+         Pending_Strong_Predecessors : Natural := 0;\n+         --  The number of pending strong predecessor components this component\n+         --  must wait on before it can be elaborated.\n+\n+         Pending_Weak_Predecessors : Natural := 0;\n+         --  The number of pending weak predecessor components this component\n+         --  must wait on before it can be elaborated.\n       end record;\n \n       No_Component_Attributes : constant Component_Attributes :=\n-        (Pending_Predecessors => 0);\n+        (Pending_Strong_Predecessors => 0,\n+         Pending_Weak_Predecessors   => 0);\n \n       procedure Destroy_Component_Attributes\n         (Attrs : in out Component_Attributes);\n@@ -1560,10 +1638,6 @@ package Bindo.Graphs is\n          Cycles : LGC_Lists.Doubly_Linked_List := LGC_Lists.Nil;\n          --  The list of all cycles in the graph, sorted based on precedence\n \n-         Dynamically_Elaborated : Boolean := False;\n-         --  Set when the main library unit was compiled using the dynamic\n-         --  model.\n-\n          Edge_Attributes : LGE_Tables.Dynamic_Hash_Table := LGE_Tables.Nil;\n          --  The map of edge -> edge attributes for all edges in the graph\n "}, {"sha": "88be2e8f9eddd2be47fcf7ef3fb8eaf32f58ab3b", "filename": "gcc/ada/bindo-validators.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-validators.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-validators.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-validators.adb?ref=92c7734db7af1395be571c5ec023a38fb7b42adf", "patch": "@@ -140,7 +140,7 @@ package body Bindo.Validators is\n \n          Edges := LGE_Sets.Create (Length (G, Cycle));\n \n-         --  Inspect the edges of the cucle, trying to catch duplicates\n+         --  Inspect the edges of the cycle, trying to catch duplicates\n \n          Iter := Iterate_Edges_Of_Cycle (G, Cycle);\n          while Has_Next (Iter) loop\n@@ -155,7 +155,7 @@ package body Bindo.Validators is\n \n                Write_Str (\"  library graph edge (LGE_Id_\");\n                Write_Int (Int (Edge));\n-               Write_Str (\") is repeaded in cycle (LGC_Id_\");\n+               Write_Str (\") is repeated in cycle (LGC_Id_\");\n                Write_Int (Int (Cycle));\n                Write_Str (\")\");\n                Write_Eol;\n@@ -421,7 +421,7 @@ package body Bindo.Validators is\n         (G      : Invocation_Graph;\n          Vertex : Invocation_Graph_Vertex_Id);\n       pragma Inline (Validate_Invocation_Graph_Vertex);\n-      --  Verify that the attributes of vertex Vertex of inbocation graph G are\n+      --  Verify that the attributes of vertex Vertex of invocation graph G are\n       --  properly set.\n \n       procedure Validate_Invocation_Graph_Vertices (G : Invocation_Graph);\n@@ -468,7 +468,7 @@ package body Bindo.Validators is\n          if not Present (Edge) then\n             Write_Error (Msg, Has_Invalid_Data);\n \n-            Write_Str (\"  emply invocation graph edge\");\n+            Write_Str (\"  empty invocation graph edge\");\n             Write_Eol;\n             Write_Eol;\n             return;\n@@ -530,7 +530,7 @@ package body Bindo.Validators is\n          if not Present (Vertex) then\n             Write_Error (Msg, Has_Invalid_Data);\n \n-            Write_Str (\"  emply invocation graph vertex\");\n+            Write_Str (\"  empty invocation graph vertex\");\n             Write_Eol;\n             Write_Eol;\n             return;\n@@ -662,7 +662,7 @@ package body Bindo.Validators is\n          if not Present (Edge) then\n             Write_Error (Msg, Has_Invalid_Data);\n \n-            Write_Str (\"  emply library graph edge\");\n+            Write_Str (\"  empty library graph edge\");\n             Write_Eol;\n             Write_Eol;\n             return;"}, {"sha": "99f93f5e4030b077927e85c7d57316d4f8295d0d", "filename": "gcc/ada/bindo-writers.adb", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-writers.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-writers.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-writers.adb?ref=92c7734db7af1395be571c5ec023a38fb7b42adf", "patch": "@@ -1025,6 +1025,10 @@ package body Bindo.Writers is\n       --  Write all vertices of component Comp of library graph G to standard\n       --  output.\n \n+      procedure Write_Components (G : Library_Graph);\n+      pragma Inline (Write_Component);\n+      --  Write all components of library graph G to standard output\n+\n       procedure Write_Edges_To_Successors\n         (G      : Library_Graph;\n          Vertex : Library_Graph_Vertex_Id);\n@@ -1089,8 +1093,12 @@ package body Bindo.Writers is\n          Write_Str (\")\");\n          Write_Eol;\n \n-         Write_Str (\"  Pending_Predecessors = \");\n-         Write_Int (Int (Pending_Predecessors (G, Comp)));\n+         Write_Str (\"  Pending_Strong_Predecessors = \");\n+         Write_Int (Int (Pending_Strong_Predecessors (G, Comp)));\n+         Write_Eol;\n+\n+         Write_Str (\"  Pending_Weak_Predecessors   = \");\n+         Write_Int (Int (Pending_Weak_Predecessors (G, Comp)));\n          Write_Eol;\n \n          Write_Component_Vertices (G, Comp);\n@@ -1225,6 +1233,7 @@ package body Bindo.Writers is\n \n          Write_Statistics (G);\n          Write_Library_Graph_Vertices (G);\n+         Write_Components (G);\n \n          Write_Str (\"Library Graph end\");\n          Write_Eol;\n@@ -1312,8 +1321,12 @@ package body Bindo.Writers is\n          end if;\n \n          Write_Eol;\n-         Write_Str (\"  Pending_Predecessors = \");\n-         Write_Int (Int (Pending_Predecessors (G, Vertex)));\n+         Write_Str (\"  Pending_Strong_Predecessors = \");\n+         Write_Int (Int (Pending_Strong_Predecessors (G, Vertex)));\n+         Write_Eol;\n+\n+         Write_Str (\"  Pending_Weak_Predecessors   = \");\n+         Write_Int (Int (Pending_Weak_Predecessors (G, Vertex)));\n          Write_Eol;\n \n          Write_Str (\"  Component (Comp_Id_\");\n@@ -1612,7 +1625,7 @@ package body Bindo.Writers is\n    is\n       function Digits_Indentation return Indentation_Level;\n       pragma Inline (Digits_Indentation);\n-      --  Determine the level of indentation the number requies in order to\n+      --  Determine the level of indentation the number requires in order to\n       --  be right-justified by Val_Indent.\n \n       ------------------------"}, {"sha": "01e48e40fce65c35f352c98a5f23f65a267ad4cd", "filename": "gcc/ada/bindo-writers.ads", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-writers.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo-writers.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-writers.ads?ref=92c7734db7af1395be571c5ec023a38fb7b42adf", "patch": "@@ -127,9 +127,6 @@ package Bindo.Writers is\n    ---------------------------\n \n    package Library_Graph_Writers is\n-      procedure Write_Components (G : Library_Graph);\n-      --  Write all components of library graph G to standard output\n-\n       procedure Write_Library_Graph (G : Library_Graph);\n       --  Write library graph G to standard output\n "}, {"sha": "897e7467f7d277ba9839cee24ccb60a1b85e897f", "filename": "gcc/ada/bindo.adb", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo.adb?ref=92c7734db7af1395be571c5ec023a38fb7b42adf", "patch": "@@ -74,7 +74,7 @@ package body Bindo is\n    --\n    --    * Diagnose elaboration circularities between units\n    --\n-   --      An elaboration circularity arrises when either\n+   --      An elaboration circularity arises when either\n    --\n    --        - At least one unit cannot be ordered, or\n    --\n@@ -95,6 +95,12 @@ package body Bindo is\n \n    --  * Component - A strongly connected component of a graph.\n    --\n+   --  * Elaborable component - A component that is not waiting on other\n+   --    components to be elaborated.\n+   --\n+   --  * Elaborable vertex - A vertex that is not waiting on strong and weak\n+   --    predecessors, and whose component is elaborable.\n+   --\n    --  * Elaboration circularity - A cycle involving units from the bind.\n    --\n    --  * Elaboration root - A special invocation construct which denotes the\n@@ -136,8 +142,23 @@ package body Bindo is\n    --  * Pending predecessor - A vertex that must be elaborated before another\n    --    vertex can be elaborated.\n    --\n+   --  * Strong edge - A non-invocation library graph edge. Strong edges\n+   --    represent the language-defined relations between units.\n+   --\n+   --  * Strong predecessor - A library graph vertex reachable via a strong\n+   --    edge.\n+   --\n    --  * Target - The destination construct of an invocation relation (the\n    --    generic, subprogram, or task type).\n+   --\n+   --  * Weak edge - An invocation library graph edge. Weak edges represent\n+   --    the speculative flow of execution at elaboration time, which may or\n+   --    may not take place.\n+   --\n+   --  * Weak predecessor - A library graph vertex reachable via a weak edge.\n+   --\n+   --  * Weakly elaborable vertex - A vertex that is waiting solely on weak\n+   --    predecessors to be elaborated, and whose component is elaborable.\n \n    ------------------\n    -- Architecture --\n@@ -233,7 +254,7 @@ package body Bindo is\n    --      bodies as single vertices.\n    --\n    --    * Try to order as many vertices of the library graph as possible by\n-   --      peforming a topological sort based on the pending predecessors of\n+   --      performing a topological sort based on the pending predecessors of\n    --      vertices across all components and within a single component.\n    --\n    --    * Validate the consistency of the order, only when switch -d_V is in\n@@ -251,7 +272,7 @@ package body Bindo is\n    --  The Diagnostics phase has the following objectives:\n    --\n    --    * Discover, save, and sort all cycles in the library graph. The cycles\n-   --      are sorted based on the following heiristics:\n+   --      are sorted based on the following heuristics:\n    --\n    --        - A cycle with higher precedence is preferred.\n    --\n@@ -268,22 +289,39 @@ package body Bindo is\n    --    * Diagnose the most important cycle, or all cycles when switch -d_C is\n    --      in effect. The diagnostic consists of:\n    --\n-   --        - The reason for the existance of the cycle, along with the unit\n+   --        - The reason for the existence of the cycle, along with the unit\n    --          whose elaboration cannot be guaranteed.\n    --\n    --        - A detailed traceback of the cycle, showcasing the transition\n    --          between units, along with any other elaboration-order-related\n    --          information.\n    --\n    --        - A set of suggestions on how to break the cycle considering the\n-   --          the edges coprising the circuit, the elaboration model used to\n+   --          the edges comprising the circuit, the elaboration model used to\n    --          compile the units, the availability of invocation information,\n    --          and the state of various relevant switches.\n \n    --------------\n    -- Switches --\n    --------------\n \n+   --  -d_a  Ignore the effects of pragma Elaborate_All\n+   --\n+   --        GNATbind creates a regular with edge instead of an Elaborate_All\n+   --        edge in the library graph, thus eliminating the effects of the\n+   --        pragma.\n+   --\n+   --  -d_b  Ignore the effects of pragma Elaborate_Body\n+   --\n+   --        GNATbind treats a spec and body pair as decoupled.\n+   --\n+   --  -d_e  Ignore the effects of pragma Elaborate\n+   --\n+   --        GNATbind creates a regular with edge instead of an Elaborate edge\n+   --        in the library graph, thus eliminating the effects of the pragma.\n+   --        In addition, GNATbind does not create an edge to the body of the\n+   --        pragma argument.\n+   --\n    --  -d_A  Output ALI invocation tables\n    --\n    --        GNATbind outputs the contents of ALI table Invocation_Constructs"}, {"sha": "940b752e484961cc33f39b9dba72a2f940358da1", "filename": "gcc/ada/bindo.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fbindo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo.ads?ref=92c7734db7af1395be571c5ec023a38fb7b42adf", "patch": "@@ -41,4 +41,14 @@ package Bindo is\n    --  exists, it is returned in Order, otherwise Unrecoverable_Error is\n    --  raised.\n \n+private\n+\n+   --  The following type represents the various kinds of precedence between\n+   --  two items.\n+\n+   type Precedence_Kind is\n+     (Lower_Precedence,\n+      Equal_Precedence,\n+      Higher_Precedence);\n+\n end Bindo;"}, {"sha": "680c38fa4ce8d8930a3d8bffcf384670781bc081", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c7734db7af1395be571c5ec023a38fb7b42adf/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=92c7734db7af1395be571c5ec023a38fb7b42adf", "patch": "@@ -349,11 +349,11 @@ package body Debug is\n    --  d.8\n    --  d.9\n \n-   --  d_a\n-   --  d_b\n+   --  d_a  Ignore the effects of pragma Elaborate_All\n+   --  d_b  Ignore the effects of pragma Elaborate_Body\n    --  d_c\n    --  d_d\n-   --  d_e\n+   --  d_e  Ignore the effects of pragma Elaborate\n    --  d_f\n    --  d_g\n    --  d_h\n@@ -1141,6 +1141,17 @@ package body Debug is\n    --  dx  Force the binder to read (and then ignore) the xref information\n    --      in ali files (used to check that read circuit is working OK).\n \n+   --  d_a  GNATBIND ignores the effects of pragma Elaborate_All in the case of\n+   --       elaboration order and treats the associated dependency as a regular\n+   --       with edge.\n+\n+   --  d_b  GNATBIND ignores the effects of pragma Elaborate_Body in the case\n+   --       of elaboration order and treats the spec and body as decoupled.\n+\n+   --  d_e  GNATBIND ignores the effects of pragma Elaborate in the case of\n+   --       elaboration order and no longer creates an implicit dependency on\n+   --       the body of the argument.\n+\n    --  d_A  GNATBIND output the contents of all ALI invocation-related tables\n    --       in textual format to standard output.\n "}]}