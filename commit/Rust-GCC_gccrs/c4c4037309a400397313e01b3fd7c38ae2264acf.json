{"sha": "c4c4037309a400397313e01b3fd7c38ae2264acf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRjNDAzNzMwOWE0MDAzOTczMTNlMDFiM2ZkN2MzOGFlMjI2NGFjZg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-07-10T19:12:59Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-07-10T19:12:59Z"}, "message": "Use integer ops to load SF constants for software floating point; fix up software floating constants in general\n\nFrom-SVN: r12421", "tree": {"sha": "651af82f9d39d7e3e23414fb6406500a5b08b10f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/651af82f9d39d7e3e23414fb6406500a5b08b10f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4c4037309a400397313e01b3fd7c38ae2264acf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4c4037309a400397313e01b3fd7c38ae2264acf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4c4037309a400397313e01b3fd7c38ae2264acf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4c4037309a400397313e01b3fd7c38ae2264acf/comments", "author": null, "committer": null, "parents": [{"sha": "a72734717c6437270db05b0423c99c99fcaf7798", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a72734717c6437270db05b0423c99c99fcaf7798", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a72734717c6437270db05b0423c99c99fcaf7798"}], "stats": {"total": 250, "additions": 195, "deletions": 55}, "files": [{"sha": "7b7896001b4920e9f0ecd23cf10873f3b693173d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4c4037309a400397313e01b3fd7c38ae2264acf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4c4037309a400397313e01b3fd7c38ae2264acf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c4c4037309a400397313e01b3fd7c38ae2264acf", "patch": "@@ -372,6 +372,24 @@ rs6000_immed_double_const (i0, i1, mode)\n   return immed_double_const (i0, i1, mode);\n }\n \n+\f\n+/* Return the GOT register, creating it if needed.  */\n+\n+struct rtx_def *\n+rs6000_got_register (value)\n+     rtx value;\n+{\n+  if (!pic_offset_table_rtx)\n+    {\n+      if (reload_in_progress || reload_completed)\n+\tfatal_insn (\"internal error -- needed new GOT register during reload phase to load:\", value);\n+\n+      pic_offset_table_rtx = gen_reg_rtx (SImode);\n+    }\n+\n+  return pic_offset_table_rtx;\n+}\n+\n \f\n /* Return non-zero if this function is known to have a null epilogue.  */\n \n@@ -614,7 +632,7 @@ num_insns_constant (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (mode != SImode && mode != DImode)\n+  if (mode != SImode && mode != DImode && mode != SFmode && mode != DFmode)\n     abort ();\n \n   if (GET_CODE (op) == CONST_INT)"}, {"sha": "f291bae62a39d892db5ff4bb755a8d8a8163e895", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4c4037309a400397313e01b3fd7c38ae2264acf/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4c4037309a400397313e01b3fd7c38ae2264acf/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=c4c4037309a400397313e01b3fd7c38ae2264acf", "patch": "@@ -1029,12 +1029,13 @@ enum reg_class\n    We flag for special constants when we can copy the constant into\n    a general register in two insns for DF/DI and one insn for SF.\n \n-   'H' is used for DI constants that take 3 insns.  */\n+   'H' is used for DI/DF constants that take 3 insns.  */\n \n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n-  ((C) == 'G' ? easy_fp_constant (VALUE, GET_MODE (VALUE)) :\t\t\\\n-   (C) == 'H' ? (num_insns_constant (VALUE, DImode) == 3) :\t\t\\\n-   0)\n+  (  (C) == 'G' ? (num_insns_constant (VALUE, GET_MODE (VALUE))\t\t\\\n+\t\t   == ((GET_MODE (VALUE) == SFmode) ? 1 : 2))\t\t\\\n+   : (C) == 'H' ? (num_insns_constant (VALUE, GET_MODE (VALUE)) == 3)\t\\\n+   : 0)\n \n /* Optional extra constraints for this machine.\n \n@@ -3018,6 +3019,7 @@ extern void rs6000_override_options ();\n extern void rs6000_file_start ();\n extern struct rtx_def *rs6000_float_const ();\n extern struct rtx_def *rs6000_immed_double_const ();\n+extern struct rtx_def *rs6000_got_register ();\n extern int direct_return ();\n extern int any_operand ();\n extern int short_cint_operand ();"}, {"sha": "80135d3da06396f4c65ea528741a950ddd3887f3", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 170, "deletions": 50, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4c4037309a400397313e01b3fd7c38ae2264acf/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4c4037309a400397313e01b3fd7c38ae2264acf/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=c4c4037309a400397313e01b3fd7c38ae2264acf", "patch": "@@ -5036,10 +5036,7 @@\n   \"(DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS) && flag_pic\"\n   \"\n {\n-  if (!pic_offset_table_rtx)\n-    pic_offset_table_rtx = gen_reg_rtx (SImode);\n-\n-  operands[2] = pic_offset_table_rtx;\n+  operands[2] = rs6000_got_register (operands[1]);\n   if (flag_pic > 1)\n     {\n       emit_insn (gen_movsi_got_large (operands[0], operands[1], operands[2]));\n@@ -5468,7 +5465,7 @@\n \t}\n     }\n \n-  if (CONSTANT_P (operands[1]))\n+  if (CONSTANT_P (operands[1]) && TARGET_HARD_FLOAT)\n     {\n       operands[1] = force_const_mem (SFmode, operands[1]);\n       if (! memory_address_p (SFmode, XEXP (operands[1], 0))\n@@ -5480,33 +5477,57 @@\n \n (define_split\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:SF 1 \"easy_fp_constant\" \"\"))]\n-  \"reload_completed && REGNO (operands[0]) <= 31\"\n-  [(set (subreg:SI (match_dup 0) 0) (match_dup 2))]\n+\t(match_operand:SF 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], SFmode) <= 1 && REGNO (operands[0]) <= 31\"\n+  [(set (match_dup 2) (match_dup 3))]\n   \"\n {\n   long l;\n   REAL_VALUE_TYPE rv;\n \n   REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n   REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n-  operands[2] = GEN_INT(l);\n+\n+  operands[2] = gen_rtx (SUBREG, SImode, operands[0], 0);\n+  operands[3] = GEN_INT(l);\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"fp_reg_or_mem_operand\" \"=f,f,m\")\n-\t(match_operand:SF 1 \"input_operand\" \"f,m,f\"))]\n+(define_split\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:SF 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], SFmode) == 2 && REGNO (operands[0]) <= 31\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 2) (ior:SI (match_dup 2) (match_dup 4)))]\n+  \"\n+{\n+  long l;\n+  REAL_VALUE_TYPE rv;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n+  REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n+\n+  operands[2] = gen_rtx (SUBREG, SImode, operands[0], 0);\n+  operands[3] = GEN_INT(l & 0xffff0000);\n+  operands[4] = GEN_INT(l & 0x0000ffff);\n+}\")\n+\n+(define_insn \"*movsf_hardfloat\"\n+  [(set (match_operand:SF 0 \"fp_reg_or_mem_operand\" \"=f,f,m,!r,!r\")\n+\t(match_operand:SF 1 \"input_operand\" \"f,m,f,G,Fn\"))]\n   \"(gpc_reg_operand (operands[0], SFmode)\n    || gpc_reg_operand (operands[1], SFmode)) && TARGET_HARD_FLOAT\"\n   \"@\n    fmr %0,%1\n    lfs%U1%X1 %0,%1\n-   stfs%U0%X0 %1,%0\"\n-  [(set_attr \"type\" \"fp,fpload,fpstore\")])\n+   stfs%U0%X0 %1,%0\n+   #\n+   #\"\n+  [(set_attr \"type\" \"fp,fpload,fpstore,*,*\")\n+   (set_attr \"length\" \"4,4,4,4,8\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r\")\n-\t(match_operand:SF 1 \"input_operand\" \"r,m,r,I,J,R\"))]\n+(define_insn \"*movsf_softfloat\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,r,r\")\n+\t(match_operand:SF 1 \"input_operand\" \"r,m,r,I,J,R,G,Fn\"))]\n   \"(gpc_reg_operand (operands[0], SFmode)\n    || gpc_reg_operand (operands[1], SFmode)) && TARGET_SOFT_FLOAT\"\n   \"@\n@@ -5515,8 +5536,11 @@\n    {st%U0%X0|stw%U0%X0} %1,%0\n    {lil|li} %0,%1\n    {liu|lis} %0,%v1\n-   {cal|la} %0,%1(%*)\"\n-  [(set_attr \"type\" \"*,load,store,*,*,*\")])\n+   {cal|la} %0,%1(%*)\n+   #\n+   #\"\n+  [(set_attr \"type\" \"*,load,store,*,*,*,*,*\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,8\")])\n \n \f\n (define_expand \"movdf\"\n@@ -5557,15 +5581,101 @@\n \n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DF 1 \"easy_fp_constant\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && REGNO (operands[0]) <= 31\"\n-  [(set (match_dup 2) (match_dup 3))\n-   (set (match_dup 4) (match_dup 5))]\n+\t(match_operand:DF 1 \"const_int_operand\" \"\"))]\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) <= 1 && REGNO (operands[0]) <= 31\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 1))]\n+  \"\n+{\n+  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n+  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  operands[4] = (INTVAL (operands[1]) & 0x80000000) ? constm1_rtx : const0_rtx;\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DF 1 \"const_int_operand\" \"\"))]\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) >= 2 && REGNO (operands[0]) <= 31\"\n+  [(set (match_dup 3) (match_dup 5))\n+   (set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (ior:SI (match_dup 3) (match_dup 6)))]\n+  \"\n+{\n+  HOST_WIDE_INT value = INTVAL (operands[1]);\n+  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n+  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  operands[4] = (value & 0x80000000) ? constm1_rtx : const0_rtx;\n+  operands[5] = GEN_INT (value & 0xffff0000);\n+  operands[6] = GEN_INT (value & 0x0000ffff);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DF 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) <= 2 && REGNO (operands[0]) <= 31\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+  \"\n+{\n+  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n+  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  operands[4] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n+  operands[5] = GEN_INT (CONST_DOUBLE_LOW  (operands[1]));\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DF 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) == 3 && REGNO (operands[0]) <= 31\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))\n+   (set (match_dup 2) (ior:SI (match_dup 2) (match_dup 6)))]\n+  \"\n+{\n+  HOST_WIDE_INT high = CONST_DOUBLE_HIGH (operands[1]);\n+  HOST_WIDE_INT low  = CONST_DOUBLE_LOW  (operands[1]);\n+  rtx high_reg = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n+  rtx low_reg  = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+\n+  if (((unsigned HOST_WIDE_INT) (low + 0x8000) < 0x10000)\n+      || (low & 0xffff) == 0)\n+    {\n+      operands[2] = high_reg;\n+      operands[3] = low_reg;\n+      operands[4] = GEN_INT (high & 0xffff0000);\n+      operands[5] = GEN_INT (low);\n+      operands[6] = GEN_INT (high & 0x0000ffff);\n+    }\n+  else\n+    {\n+      operands[2] = low_reg;\n+      operands[3] = high_reg;\n+      operands[4] = GEN_INT (low & 0xffff0000);\n+      operands[5] = GEN_INT (high);\n+      operands[6] = GEN_INT (low & 0x0000ffff);\n+    }\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DF 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) >= 4 && REGNO (operands[0]) <= 31\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))\n+   (set (match_dup 2) (ior:SI (match_dup 2) (match_dup 6)))\n+   (set (match_dup 3) (ior:SI (match_dup 3) (match_dup 7)))]\n   \"\n-{ operands[2] = operand_subword (operands[0], 0, 0, DFmode);\n-  operands[3] = operand_subword (operands[1], 0, 0, DFmode);\n-  operands[4] = operand_subword (operands[0], 1, 0, DFmode);\n-  operands[5] = operand_subword (operands[1], 1, 0, DFmode); }\")\n+{\n+  HOST_WIDE_INT high = CONST_DOUBLE_HIGH (operands[1]);\n+  HOST_WIDE_INT low  = CONST_DOUBLE_LOW  (operands[1]);\n+\n+  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n+  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  operands[4] = GEN_INT (high & 0xffff0000);\n+  operands[5] = GEN_INT (low  & 0xffff0000);\n+  operands[6] = GEN_INT (high & 0x0000ffff);\n+  operands[7] = GEN_INT (low  & 0x0000ffff);\n+}\")\n \n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n@@ -5580,9 +5690,9 @@\n ;; the constant into an FP register, since it will probably be used there.\n ;; The \"??\" is a kludge until we can figure out a more reasonable way\n ;; of handling these non-offsettable values.\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=!r,??r,o,!r,f,f,m\")\n-\t(match_operand:DF 1 \"input_operand\" \"r,o,r,G,f,m,f\"))]\n+(define_insn \"*movdf_hardfloat32\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=!r,??r,o,!r,!r,!r,f,f,m\")\n+\t(match_operand:DF 1 \"input_operand\" \"r,o,r,G,H,F,f,m,f\"))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n@@ -5611,21 +5721,23 @@\n     case 2:\n       return \\\"{st%U0|stw%U0} %1,%0\\;{st|stw} %L1,%L0\\\";\n     case 3:\n-      return \\\"#\\\";\n     case 4:\n-      return \\\"fmr %0,%1\\\";\n     case 5:\n-      return \\\"lfd%U1%X1 %0,%1\\\";\n+      return \\\"#\\\";\n     case 6:\n+      return \\\"fmr %0,%1\\\";\n+    case 7:\n+      return \\\"lfd%U1%X1 %0,%1\\\";\n+    case 8:\n       return \\\"stfd%U0%X0 %1,%0\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"*,load,store,*,fp,fpload,fpstore\")\n-   (set_attr \"length\" \"8,8,8,8,*,*,*\")])\n+  [(set_attr \"type\" \"*,load,store,*,*,*,fp,fpload,fpstore\")\n+   (set_attr \"length\" \"8,8,8,8,12,16,*,*,*\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,o,r\")\n-\t(match_operand:DF 1 \"input_operand\" \"r,o,r,G\"))]\n+(define_insn \"*movdf_softfloat32\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,o,r,r,r\")\n+\t(match_operand:DF 1 \"input_operand\" \"r,o,r,G,H,F\"))]\n   \"! TARGET_POWERPC64 && TARGET_SOFT_FLOAT\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n@@ -5654,15 +5766,17 @@\n     case 2:\n       return \\\"{st%U0|stw%U0} %1,%0\\;{st|stw} %L1,%L0\\\";\n     case 3:\n+    case 4:\n+    case 5:\n       return \\\"#\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"*,load,store,*\")\n-   (set_attr \"length\" \"8,8,8,8\")])\n+  [(set_attr \"type\" \"*,load,store,*,*,*\")\n+   (set_attr \"length\" \"8,8,8,8,12,16\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=!r,??r,o,!r,f,f,m\")\n-\t(match_operand:DF 1 \"input_operand\" \"r,o,r,G,f,m,f\"))]\n+(define_insn \"*movdf_hardfloat64\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=!r,??r,o,!r,!r,!r,f,f,m\")\n+\t(match_operand:DF 1 \"input_operand\" \"r,o,r,G,H,F,f,m,f\"))]\n   \"TARGET_POWERPC64 && TARGET_HARD_FLOAT\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n@@ -5671,23 +5785,29 @@\n    ld%U1%X1 %0,%1\n    std%U0%X0 %1,%0\n    #\n+   #\n+   #\n    fmr %0,%1\n    lfd%U1%X1 %0,%1\n    stfd%U0%X0 %1,%0\"\n-  [(set_attr \"type\" \"*,load,store,*,fp,fpload,fpstore\")])\n+  [(set_attr \"type\" \"*,load,store,*,*,*,fp,fpload,fpstore\")\n+   (set_attr \"length\" \"4,4,4,8,12,16,4,4,4\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,o,r\")\n-\t(match_operand:DF 1 \"input_operand\" \"r,o,r,G\"))]\n+(define_insn \"*movdf_softfloat64\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,o,r,r,r\")\n+\t(match_operand:DF 1 \"input_operand\" \"r,o,r,G,H,F\"))]\n   \"TARGET_POWERPC64 && TARGET_SOFT_FLOAT\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n   \"@\n    mr %0,%1\n    ld%U1%X1 %0,%1\n    std%U0%X0 %1,%0\n+   #\n+   #\n    #\"\n-  [(set_attr \"type\" \"*,load,store,*\")])\n+  [(set_attr \"type\" \"*,load,store,*,*,*\")\n+   (set_attr \"length\" \"*,*,*,8,12,16\")])\n \f\n ;; Next come the multi-word integer load and store and the load and store\n ;; multiple insns.\n@@ -5761,7 +5881,7 @@\n     }\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*movdi_32\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,f,f,m,r,r,r,r,r\")\n \t(match_operand:DI 1 \"input_operand\" \"r,m,r,f,m,f,IJK,n,G,H,F\"))]\n   \"TARGET_32BIT\n@@ -5906,7 +6026,7 @@\n   operands[7] = GEN_INT (low  & 0x0000ffff);\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*movdi_64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,r,f,f,m,r,*h,*h\")\n \t(match_operand:DI 1 \"input_operand\" \"r,m,r,I,J,nF,R,f,m,f,*h,r,0\"))]\n   \"TARGET_64BIT"}]}