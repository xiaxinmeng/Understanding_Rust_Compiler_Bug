{"sha": "315bbd2e3c15dea3528259be2aee2876dec33843", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE1YmJkMmUzYzE1ZGVhMzUyODI1OWJlMmFlZTI4NzZkZWMzMzg0Mw==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2013-04-29T13:08:24Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2013-04-29T13:08:24Z"}, "message": "Preserve loops in tail-merge\n\n2013-04-29  Tom de Vries  <tom@codesourcery.com>\n\n\t* tree-ssa-tail-merge.c (find_same_succ_bb): Skip loop latch bbs.\n\t(replace_block_by): Don't set LOOPS_NEED_FIXUP.\n\t(tail_merge_optimize): Handle current_loops == NULL.\n\n\t* gcc.dg/pr50763.c: Update test.\n\nFrom-SVN: r198414", "tree": {"sha": "0b4e47abd7c97690dc392866a93c0c360dbf06d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b4e47abd7c97690dc392866a93c0c360dbf06d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/315bbd2e3c15dea3528259be2aee2876dec33843", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315bbd2e3c15dea3528259be2aee2876dec33843", "html_url": "https://github.com/Rust-GCC/gccrs/commit/315bbd2e3c15dea3528259be2aee2876dec33843", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315bbd2e3c15dea3528259be2aee2876dec33843/comments", "author": null, "committer": null, "parents": [{"sha": "ebbd90d832d3f0277f02b30fe03451fe0bbf659d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebbd90d832d3f0277f02b30fe03451fe0bbf659d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebbd90d832d3f0277f02b30fe03451fe0bbf659d"}], "stats": {"total": 47, "additions": 33, "deletions": 14}, "files": [{"sha": "34dcd58638445ae6289f948276024dc4c82f4e3a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315bbd2e3c15dea3528259be2aee2876dec33843/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315bbd2e3c15dea3528259be2aee2876dec33843/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=315bbd2e3c15dea3528259be2aee2876dec33843", "patch": "@@ -1,3 +1,9 @@\n+2013-04-29  Tom de Vries  <tom@codesourcery.com>\n+\n+\t* tree-ssa-tail-merge.c (find_same_succ_bb): Skip loop latch bbs.\n+\t(replace_block_by): Don't set LOOPS_NEED_FIXUP.\n+\t(tail_merge_optimize): Handle current_loops == NULL.\n+\n 2013-04-26  Jeff Law  <law@redhat.com>\n \n \t* tree-vrp.c (range_fits_type_p): Move to earlier point in file."}, {"sha": "c1db93b35fa6673314cc11d14fc2dc18384ef09c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315bbd2e3c15dea3528259be2aee2876dec33843/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315bbd2e3c15dea3528259be2aee2876dec33843/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=315bbd2e3c15dea3528259be2aee2876dec33843", "patch": "@@ -1,3 +1,7 @@\n+2013-04-29  Tom de Vries  <tom@codesourcery.com>\n+\n+\t* gcc.dg/pr50763.c: Update test.\n+\n 2013-04-26  Jeff Law  <law@redhat.com>\n \n \t* gcc.dg/tree-ssa/vrp88.c: New test."}, {"sha": "695b61c75f02345164c0b535daeb42a88592f499", "filename": "gcc/testsuite/gcc.dg/pr50763.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315bbd2e3c15dea3528259be2aee2876dec33843/gcc%2Ftestsuite%2Fgcc.dg%2Fpr50763.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315bbd2e3c15dea3528259be2aee2876dec33843/gcc%2Ftestsuite%2Fgcc.dg%2Fpr50763.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr50763.c?ref=315bbd2e3c15dea3528259be2aee2876dec33843", "patch": "@@ -12,5 +12,5 @@ foo (int c, int d)\n   while (c == d);\n }\n \n-/* { dg-final { scan-tree-dump-times \"== 33\" 1 \"pre\"} } */\n+/* { dg-final { scan-tree-dump-times \"== 33\" 2 \"pre\"} } */\n /* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "317fe4c997def15f81818359329bb19b7c41a2c8", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315bbd2e3c15dea3528259be2aee2876dec33843/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315bbd2e3c15dea3528259be2aee2876dec33843/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=315bbd2e3c15dea3528259be2aee2876dec33843", "patch": "@@ -691,7 +691,15 @@ find_same_succ_bb (basic_block bb, same_succ *same_p)\n   edge_iterator ei;\n   edge e;\n \n-  if (bb == NULL)\n+  if (bb == NULL\n+      /* Be conservative with loop structure.  It's not evident that this test\n+\t is sufficient.  Before tail-merge, we've just called\n+\t loop_optimizer_finalize, and LOOPS_MAY_HAVE_MULTIPLE_LATCHES is now\n+\t set, so there's no guarantee that the loop->latch value is still valid.\n+\t But we assume that, since we've forced LOOPS_HAVE_SIMPLE_LATCHES at the\n+\t start of pre, we've kept that property intact throughout pre, and are\n+\t keeping it throughout tail-merge using this test.  */\n+      || bb->loop_father->latch == bb)\n     return;\n   bitmap_set_bit (same->bbs, bb->index);\n   FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -1462,17 +1470,6 @@ replace_block_by (basic_block bb1, basic_block bb2)\n   /* Mark the basic block as deleted.  */\n   mark_basic_block_deleted (bb1);\n \n-  /* ???  If we merge the loop preheader with the loop latch we are creating\n-     additional entries into the loop, eventually rotating it.\n-     Mark loops for fixup in this case.\n-     ???  This is a completely unwanted transform and will wreck most\n-     loops at this point - but with just not considering loop latches as\n-     merge candidates we fail to commonize the two loops in gcc.dg/pr50763.c.\n-     A better fix to avoid that regression is needed.  */\n-  if (current_loops\n-      && bb2->loop_father->latch == bb2)\n-    loops_state_set (LOOPS_NEED_FIXUP);\n-\n   /* Redirect the incoming edges of bb1 to bb2.  */\n   for (i = EDGE_COUNT (bb1->preds); i > 0 ; --i)\n     {\n@@ -1614,7 +1611,19 @@ tail_merge_optimize (unsigned int todo)\n   int iteration_nr = 0;\n   int max_iterations = PARAM_VALUE (PARAM_MAX_TAIL_MERGE_ITERATIONS);\n \n-  if (!flag_tree_tail_merge || max_iterations == 0)\n+  if (!flag_tree_tail_merge\n+      || max_iterations == 0\n+      /* We try to be conservative with respect to loop structure, since:\n+\t - the cases where tail-merging could both affect loop structure and be\n+\t   benificial are rare,\n+\t - it prevents us from having to fixup the loops using\n+\t   loops_state_set (LOOPS_NEED_FIXUP), and\n+\t - keeping loop structure may allow us to simplify the pass.\n+\t In order to be conservative, we need loop information.\t In rare cases\n+\t (about 7 test-cases in the g++ testsuite) there is none (because\n+\t loop_optimizer_finalize has been called before tail-merge, and\n+\t PROP_loops is not set), so we bail out.  */\n+      || current_loops == NULL)\n     return 0;\n \n   timevar_push (TV_TREE_TAIL_MERGE);"}]}