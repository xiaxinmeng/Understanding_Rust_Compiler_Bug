{"sha": "c3c822d506d98ca880dd2da32b5af0330a3c0f91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNjODIyZDUwNmQ5OGNhODgwZGQyZGEzMmI1YWYwMzMwYTNjMGY5MQ==", "commit": {"author": {"name": "Caroline Tice", "email": "ctice@gcc.gnu.org", "date": "2005-04-12T20:39:09Z"}, "committer": {"name": "Caroline Tice", "email": "ctice@gcc.gnu.org", "date": "2005-04-12T20:39:09Z"}, "message": "Revert patch from April 9.\n\nFrom-SVN: r98039", "tree": {"sha": "2a43fb81a341285d6b565e80e3d30dcf600bd613", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a43fb81a341285d6b565e80e3d30dcf600bd613"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3c822d506d98ca880dd2da32b5af0330a3c0f91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3c822d506d98ca880dd2da32b5af0330a3c0f91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3c822d506d98ca880dd2da32b5af0330a3c0f91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3c822d506d98ca880dd2da32b5af0330a3c0f91/comments", "author": null, "committer": null, "parents": [{"sha": "b0d9bc9b22e6118728e4a156aeb18b908ae5b41c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d9bc9b22e6118728e4a156aeb18b908ae5b41c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0d9bc9b22e6118728e4a156aeb18b908ae5b41c"}], "stats": {"total": 445, "additions": 193, "deletions": 252}, "files": [{"sha": "6925114e133ddc3ed9b24a9bb928f77f4fcde00a", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 50, "deletions": 37, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c822d506d98ca880dd2da32b5af0330a3c0f91/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c822d506d98ca880dd2da32b5af0330a3c0f91/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=c3c822d506d98ca880dd2da32b5af0330a3c0f91", "patch": "@@ -1241,24 +1241,27 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n   /* Mark every edge that crosses between sections.  */\n \n   i = 0;\n-  FOR_EACH_BB (bb)\n-    FOR_EACH_EDGE (e, ei, bb->succs)\n+  if (targetm.have_named_sections)\n     {\n-      if (e->src != ENTRY_BLOCK_PTR\n-\t  && e->dest != EXIT_BLOCK_PTR\n-\t  && BB_PARTITION (e->src) != BB_PARTITION (e->dest))\n-\t{\n-\t  e->flags |= EDGE_CROSSING;\n-\t  if (i == *max_idx)\n-\t    {\n-\t      *max_idx *= 2;\n-\t      crossing_edges = xrealloc (crossing_edges,\n-\t\t\t\t\t (*max_idx) * sizeof (edge));\n-\t    }\n-\t  crossing_edges[i++] = e;\n-\t}\n-      else\n-\te->flags &= ~EDGE_CROSSING;\n+      FOR_EACH_BB (bb)\n+        FOR_EACH_EDGE (e, ei, bb->succs)\n+\t  {\n+\t    if (e->src != ENTRY_BLOCK_PTR\n+\t\t&& e->dest != EXIT_BLOCK_PTR\n+\t\t&& BB_PARTITION (e->src) != BB_PARTITION (e->dest))\n+\t      {\n+\t\te->flags |= EDGE_CROSSING;\n+\t\tif (i == *max_idx)\n+\t\t  {\n+\t\t    *max_idx *= 2;\n+\t\t    crossing_edges = xrealloc (crossing_edges,\n+\t\t\t\t\t       (*max_idx) * sizeof (edge));\n+\t\t  }\n+\t\tcrossing_edges[i++] = e;\n+\t      }\n+\t    else\n+\t      e->flags &= ~EDGE_CROSSING;\n+\t  }\n     }\n   *n_crossing_edges = i;\n }\n@@ -1822,26 +1825,36 @@ fix_edges_for_rarely_executed_code (edge *crossing_edges,\n   \n   fix_up_fall_thru_edges ();\n   \n-  /* If the architecture does not have conditional branches that can\n-     span all of memory, convert crossing conditional branches into\n-     crossing unconditional branches.  */\n-  \n-  if (!HAS_LONG_COND_BRANCH)\n-    fix_crossing_conditional_branches ();\n+  /* Only do the parts necessary for writing separate sections if\n+     the target architecture has the ability to write separate sections\n+     (i.e. it has named sections).  Otherwise, the hot/cold partitioning\n+     information will be used when reordering blocks to try to put all\n+     the hot blocks together, then all the cold blocks, but no actual\n+     section partitioning will be done.  */\n+\n+  if (targetm.have_named_sections)\n+    {\n+      /* If the architecture does not have conditional branches that can\n+\t span all of memory, convert crossing conditional branches into\n+\t crossing unconditional branches.  */\n   \n-  /* If the architecture does not have unconditional branches that\n-     can span all of memory, convert crossing unconditional branches\n-     into indirect jumps.  Since adding an indirect jump also adds\n-     a new register usage, update the register usage information as\n-     well.  */\n+      if (!HAS_LONG_COND_BRANCH)\n+\tfix_crossing_conditional_branches ();\n   \n-  if (!HAS_LONG_UNCOND_BRANCH)\n-    {\n-      fix_crossing_unconditional_branches ();\n-      reg_scan (get_insns(), max_reg_num ());\n+      /* If the architecture does not have unconditional branches that\n+\t can span all of memory, convert crossing unconditional branches\n+\t into indirect jumps.  Since adding an indirect jump also adds\n+\t a new register usage, update the register usage information as\n+\t well.  */\n+      \n+      if (!HAS_LONG_UNCOND_BRANCH)\n+\t{\n+\t  fix_crossing_unconditional_branches ();\n+\t  reg_scan (get_insns(), max_reg_num ());\n+\t}\n+\n+      add_reg_crossing_jump_notes ();\n     }\n-  \n-  add_reg_crossing_jump_notes ();\n }\n \n /* Verify, in the basic block chain, that there is at most one switch\n@@ -1933,8 +1946,7 @@ reorder_basic_blocks (unsigned int flags)\n     dump_flow_info (dump_file);\n \n   cfg_layout_finalize ();\n-  if (flag_reorder_blocks_and_partition)\n-    verify_hot_cold_block_grouping ();\n+  verify_hot_cold_block_grouping ();\n \n   timevar_pop (TV_REORDER_BLOCKS);\n }\n@@ -1954,7 +1966,8 @@ insert_section_boundary_note (void)\n   rtx new_note;\n   int first_partition = 0;\n   \n-  if (flag_reorder_blocks_and_partition)\n+  if (flag_reorder_blocks_and_partition\n+      && targetm.have_named_sections)\n     FOR_EACH_BB (bb)\n     {\n       if (!first_partition)"}, {"sha": "c645edbeec2d00346c656032664c0dd76dfe72c2", "filename": "gcc/dbxout.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c822d506d98ca880dd2da32b5af0330a3c0f91/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c822d506d98ca880dd2da32b5af0330a3c0f91/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=c3c822d506d98ca880dd2da32b5af0330a3c0f91", "patch": "@@ -938,14 +938,11 @@ dbxout_function_end (tree decl)\n #else\n   if (flag_reorder_blocks_and_partition)\n     {\n-      struct function *cfun = DECL_STRUCT_FUNCTION (decl);\n-\n       dbxout_begin_empty_stabs (N_FUN);\n-      dbxout_stab_value_label_diff (cfun->hot_section_end_label, \n-\t\t\t\t    cfun->hot_section_label);\n+      dbxout_stab_value_label_diff (hot_section_end_label, hot_section_label);\n       dbxout_begin_empty_stabs (N_FUN);\n-      dbxout_stab_value_label_diff (cfun->cold_section_end_label, \n-\t\t\t\t    cfun->cold_section_label);\n+      dbxout_stab_value_label_diff (cold_section_end_label, \n+\t\t\t\t    unlikely_section_label);\n     }\n   else\n     {"}, {"sha": "b750ff8b466e876eb8ade530edf6af4d56c8c9e8", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 36, "deletions": 53, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c822d506d98ca880dd2da32b5af0330a3c0f91/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c822d506d98ca880dd2da32b5af0330a3c0f91/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c3c822d506d98ca880dd2da32b5af0330a3c0f91", "patch": "@@ -4122,9 +4122,6 @@ static int maybe_emit_file (int);\n #ifndef TEXT_SECTION_LABEL\n #define TEXT_SECTION_LABEL\t\t\"Ltext\"\n #endif\n-#ifndef COLD_TEXT_SECTION_LABEL\n-#define COLD_TEXT_SECTION_LABEL         \"Ltext_cold\"\n-#endif\n #ifndef DEBUG_LINE_SECTION_LABEL\n #define DEBUG_LINE_SECTION_LABEL\t\"Ldebug_line\"\n #endif\n@@ -4152,8 +4149,6 @@ static int maybe_emit_file (int);\n \n static char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char text_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n-static char cold_text_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n-static char cold_end_label[MAX_ARTIFICIAL_LABEL_BYTES]; \n static char abbrev_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char debug_info_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char debug_line_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -4164,9 +4159,6 @@ static char ranges_section_label[2 * MAX_ARTIFICIAL_LABEL_BYTES];\n #ifndef TEXT_END_LABEL\n #define TEXT_END_LABEL\t\t\"Letext\"\n #endif\n-#ifndef COLD_END_LABEL\n-#define COLD_END_LABEL          \"Letext_cold\"\n-#endif\n #ifndef BLOCK_BEGIN_LABEL\n #define BLOCK_BEGIN_LABEL\t\"LBB\"\n #endif\n@@ -6807,14 +6799,13 @@ static void\n dwarf2out_switch_text_section (void)\n {\n   dw_fde_ref fde;\n-  struct function *cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n \n   fde = &fde_table[fde_table_in_use - 1];\n   fde->dw_fde_switched_sections = true;\n-  fde->dw_fde_hot_section_label = cfun->hot_section_label;\n-  fde->dw_fde_hot_section_end_label = cfun->hot_section_end_label;\n-  fde->dw_fde_unlikely_section_label = cfun->cold_section_label;\n-  fde->dw_fde_unlikely_section_end_label = cfun->cold_section_end_label;\n+  fde->dw_fde_hot_section_label = xstrdup (hot_section_label);\n+  fde->dw_fde_hot_section_end_label = xstrdup (hot_section_end_label);\n+  fde->dw_fde_unlikely_section_label = xstrdup (unlikely_section_label);\n+  fde->dw_fde_unlikely_section_end_label = xstrdup (cold_section_end_label);\n   separate_line_info_table_in_use++;\n }\n \n@@ -7244,15 +7235,14 @@ output_aranges (void)\n     }\n \n   dw2_asm_output_addr (DWARF2_ADDR_SIZE, text_section_label, \"Address\");\n-  dw2_asm_output_delta (DWARF2_ADDR_SIZE, text_end_label,\n-\t\t\ttext_section_label, \"Length\");\n-  if (flag_reorder_blocks_and_partition)\n-    {\n-      dw2_asm_output_addr (DWARF2_ADDR_SIZE, cold_text_section_label, \n-\t\t\t   \"Address\");\n-      dw2_asm_output_delta (DWARF2_ADDR_SIZE, cold_end_label,\n-\t\t\t    cold_text_section_label, \"Length\");\n-    }\n+  if (last_text_section == in_unlikely_executed_text\n+      || (last_text_section == in_named\n+\t  && last_text_section_name == unlikely_text_section_name))\n+    dw2_asm_output_delta (DWARF2_ADDR_SIZE, text_end_label,\n+\t\t\t  unlikely_section_label, \"Length\");\n+  else\n+    dw2_asm_output_delta (DWARF2_ADDR_SIZE, text_end_label,\n+\t\t\t  text_section_label, \"Length\");\n \n   for (i = 0; i < arange_table_in_use; i++)\n     {\n@@ -7342,11 +7332,24 @@ output_ranges (void)\n \t     base of the text section.  */\n \t  if (separate_line_info_table_in_use == 0)\n \t    {\n-\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE, blabel,\n-\t\t\t\t    text_section_label,\n-\t\t\t\t    fmt, i * 2 * DWARF2_ADDR_SIZE);\n-\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE, elabel,\n-\t\t\t\t    text_section_label, NULL);\n+\t      if (last_text_section == in_unlikely_executed_text\n+\t\t  || (last_text_section == in_named\n+\t\t      && last_text_section_name == unlikely_text_section_name))\n+\t\t{\n+\t\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, blabel,\n+\t\t\t\t\tunlikely_section_label,\n+\t\t\t\t\tfmt, i * 2 * DWARF2_ADDR_SIZE);\n+\t\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, elabel,\n+\t\t\t\t\tunlikely_section_label, NULL);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, blabel,\n+\t\t\t\t\ttext_section_label,\n+\t\t\t\t\tfmt, i * 2 * DWARF2_ADDR_SIZE);\n+\t\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, elabel,\n+\t\t\t\t\ttext_section_label, NULL);\n+\t\t}\n \t    }\n \n \t  /* Otherwise, we add a DW_AT_entry_pc attribute to force the\n@@ -7662,7 +7665,6 @@ output_line_info (void)\n   long line_delta;\n   unsigned long current_file;\n   unsigned long function;\n-  struct function *cfun;\n \n   ASM_GENERATE_INTERNAL_LABEL (l1, LINE_NUMBER_BEGIN_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (l2, LINE_NUMBER_END_LABEL, 0);\n@@ -7733,14 +7735,10 @@ output_line_info (void)\n   current_file = 1;\n   current_line = 1;\n   \n-  if (current_function_decl)\n-    cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n-  else\n-    cfun = NULL;\n   if (last_text_section == in_unlikely_executed_text\n       || (last_text_section == in_named\n-\t  && last_text_section_name == cfun->unlikely_text_section_name))\n-    strcpy (prev_line_label, cfun->cold_section_label);\n+\t  && last_text_section_name == unlikely_text_section_name))\n+    strcpy (prev_line_label, unlikely_section_label);\n   else\n     strcpy (prev_line_label, text_section_label);\n   for (lt_index = 1; lt_index < line_info_table_in_use; ++lt_index)\n@@ -10113,7 +10111,6 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n       const char *endname;\n       dw_loc_list_ref list;\n       rtx varloc;\n-      struct function *cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n \n \n       /* We need to figure out what section we should use as the base\n@@ -10139,8 +10136,8 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \t}\n       else if (last_text_section == in_unlikely_executed_text\n \t       || (last_text_section == in_named\n-\t\t   && last_text_section_name == cfun->unlikely_text_section_name))\n-\tsecname = cfun->cold_section_label;\n+\t\t   && last_text_section_name == unlikely_text_section_name))\n+\tsecname = unlikely_section_label;\n       else\n \tsecname = text_section_label;\n \n@@ -13233,7 +13230,6 @@ dwarf2out_var_location (rtx loc_note)\n   static rtx last_insn;\n   static const char *last_label;\n   tree decl;\n-  struct function *cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n \n   if (!DECL_P (NOTE_VAR_LOCATION_DECL (loc_note)))\n     return;\n@@ -13262,8 +13258,8 @@ dwarf2out_var_location (rtx loc_note)\n \n   if (last_text_section == in_unlikely_executed_text\n       || (last_text_section == in_named\n-\t  && last_text_section_name == cfun->unlikely_text_section_name))\n-    newloc->section_label = cfun->cold_section_label;\n+\t  && last_text_section_name == unlikely_text_section_name))\n+    newloc->section_label = unlikely_section_label;\n   else\n     newloc->section_label = text_section_label;\n \n@@ -13501,9 +13497,6 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n   ASM_GENERATE_INTERNAL_LABEL (abbrev_section_label,\n \t\t\t       DEBUG_ABBREV_SECTION_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (text_section_label, TEXT_SECTION_LABEL, 0);\n-  ASM_GENERATE_INTERNAL_LABEL (cold_text_section_label, \n-\t\t\t       COLD_TEXT_SECTION_LABEL, 0);\n-  ASM_GENERATE_INTERNAL_LABEL (cold_end_label, COLD_END_LABEL, 0);\n \n   ASM_GENERATE_INTERNAL_LABEL (debug_info_section_label,\n \t\t\t       DEBUG_INFO_SECTION_LABEL, 0);\n@@ -13528,11 +13521,6 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n \n   text_section ();\n   ASM_OUTPUT_LABEL (asm_out_file, text_section_label);\n-  if (flag_reorder_blocks_and_partition)\n-    {\n-      unlikely_text_section ();\n-      ASM_OUTPUT_LABEL (asm_out_file, cold_text_section_label);\n-    }\n }\n \n /* A helper function for dwarf2out_finish called through\n@@ -13864,11 +13852,6 @@ dwarf2out_finish (const char *filename)\n   /* Output a terminator label for the .text section.  */\n   text_section ();\n   targetm.asm_out.internal_label (asm_out_file, TEXT_END_LABEL, 0);\n-  if (flag_reorder_blocks_and_partition)\n-    {\n-      unlikely_text_section ();\n-      targetm.asm_out.internal_label (asm_out_file, COLD_END_LABEL, 0);\n-    }\n \n   /* Output the source line correspondence table.  We must do this\n      even if there is no line information.  Otherwise, on an empty"}, {"sha": "b772752552f27877ad0ad05ff1f47a91ca2b9934", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c822d506d98ca880dd2da32b5af0330a3c0f91/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c822d506d98ca880dd2da32b5af0330a3c0f91/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=c3c822d506d98ca880dd2da32b5af0330a3c0f91", "patch": "@@ -349,20 +349,6 @@ struct function GTY(())\n   /* The variables unexpanded so far.  */\n   tree unexpanded_var_list;\n \n-  /* Assembly labels for the hot and cold text sections, to\n-     be used by debugger functions for determining the size of text\n-     sections.  */\n-\n-  const char * hot_section_label;\n-  const char * cold_section_label;\n-  const char * hot_section_end_label;\n-  const char * cold_section_end_label;\n-\n-  /* String to be used for name of cold text sections, via\n-     targetm.asm_out.named_section.  */\n-\n-  const char *unlikely_text_section_name;\n-\n   /* Collected bit flags.  */\n \n   /* Nonzero if function being compiled needs to be given an address"}, {"sha": "70a9b22ac5b6b460a2cc444c32278a12c9b1f20d", "filename": "gcc/opts.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c822d506d98ca880dd2da32b5af0330a3c0f91/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c822d506d98ca880dd2da32b5af0330a3c0f91/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=c3c822d506d98ca880dd2da32b5af0330a3c0f91", "patch": "@@ -678,15 +678,6 @@ decode_options (unsigned int argc, const char **argv)\n       flag_reorder_blocks_and_partition = 0;\n       flag_reorder_blocks = 1;\n     }\n-\n-  if (flag_reorder_blocks_and_partition\n-      && !targetm.have_named_sections)\n-    {\n-      inform \n-       (\"-freorder-blocks-and-partition does not work on this architecture.\");\n-      flag_reorder_blocks_and_partition = 0;\n-      flag_reorder_blocks = 1;\n-    }\n }\n \n /* Handle target- and language-independent options.  Return zero to"}, {"sha": "4d9eabb49f75b5a7a3b7a3eddf4e654274640dfc", "filename": "gcc/output.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c822d506d98ca880dd2da32b5af0330a3c0f91/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c822d506d98ca880dd2da32b5af0330a3c0f91/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=c3c822d506d98ca880dd2da32b5af0330a3c0f91", "patch": "@@ -453,6 +453,11 @@ enum in_section { no_section, in_text, in_unlikely_executed_text, in_data,\n #endif\n };\n \n+extern char *unlikely_section_label;\n+extern char *hot_section_label;\n+extern char *hot_section_end_label;\n+extern char *cold_section_end_label;\n+extern char *unlikely_text_section_name;\n extern const char *last_text_section_name;\n extern enum in_section last_text_section;\n extern bool first_function_block_is_cold;"}, {"sha": "a34c97553daabd20e58936429802143a4beeaf5d", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c822d506d98ca880dd2da32b5af0330a3c0f91/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c822d506d98ca880dd2da32b5af0330a3c0f91/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=c3c822d506d98ca880dd2da32b5af0330a3c0f91", "patch": "@@ -329,6 +329,8 @@ rest_of_handle_final (void)\n \n   timevar_push (TV_SYMOUT);\n   (*debug_hooks->function_decl) (current_function_decl);\n+  if (unlikely_text_section_name)\n+    free (unlikely_text_section_name);\n   timevar_pop (TV_SYMOUT);\n \n   ggc_collect ();"}, {"sha": "b8c982639db731244aaa67eedb381feb565daf96", "filename": "gcc/varasm.c", "status": "modified", "additions": 97, "deletions": 133, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c822d506d98ca880dd2da32b5af0330a3c0f91/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c822d506d98ca880dd2da32b5af0330a3c0f91/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=c3c822d506d98ca880dd2da32b5af0330a3c0f91", "patch": "@@ -101,6 +101,40 @@ tree last_assemble_variable_decl;\n \n bool first_function_block_is_cold;\n \n+/* The following global variable indicates the label name to be put at\n+   the start of the first cold section within each function, when\n+   partitioning basic blocks into hot and cold sections.  Used for\n+   debug info.  */\n+\n+char *unlikely_section_label;\n+\n+/* The following global variable indicates the label name to be put at\n+   the start of the first hot section within each function, when\n+   partitioning basic blocks into hot and cold sections.  Used for\n+   debug info.  */\n+\n+char *hot_section_label;\n+\n+/* The following global variable indicates the label name to be put at\n+   the end of the last hot section within each function, when\n+   partitioning basic blocks into hot and cold sections.  Used for\n+   debug info.  */\n+\n+char *hot_section_end_label;\n+\n+/* The following global variable indicates the label name to be put at\n+   the end of the last cold section within each function, when\n+   partitioning basic blocks into hot and cold sections.  Used for \n+   debug info.*/\n+\n+char *cold_section_end_label;\n+ \n+/* The following global variable indicates the seciton name to be used\n+   for the current cold section, when partitiong hot and cold basic \n+   blocks into separate sections.  */\n+\n+char *unlikely_text_section_name;\n+\n /* We give all constants their own alias set.  Perhaps redundant with\n    MEM_READONLY_P, but pre-dates it.  */\n \n@@ -177,37 +211,28 @@ static void\n initialize_cold_section_name (void)\n {\n   const char *name;\n-  const char *stripped_name;\n-  char *buffer;\n   int len;\n-  struct function *cfun;\n \n-  if (current_function_decl)\n+  if (! unlikely_text_section_name)\n     {\n-      cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n-      if (!cfun->unlikely_text_section_name)\n+      if (DECL_SECTION_NAME (current_function_decl)\n+\t  && (strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME\n+\t\t\t\t\t   (current_function_decl)),\n+\t\t      HOT_TEXT_SECTION_NAME) != 0)\n+\t  && (strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME\n+\t\t\t\t\t   (current_function_decl)),\n+\t\t      UNLIKELY_EXECUTED_TEXT_SECTION_NAME) != 0))\n \t{\n-\t  if (flag_function_sections\n-\t      && DECL_SECTION_NAME (current_function_decl))\n-\t    {\n-\t      name = xstrdup (TREE_STRING_POINTER (DECL_SECTION_NAME \n-\t\t\t\t\t\t   (current_function_decl)));\n-\t      stripped_name = targetm.strip_name_encoding (name);\n-\t      len = strlen (stripped_name);\n-\t      buffer = (char *) xmalloc (len + 10);\n-\t      sprintf (buffer, \"%s%s\", stripped_name, \"_unlikely\");\n-\t      cfun->unlikely_text_section_name = ggc_strdup (buffer);\n-\t      free (buffer);\n-\t      free ((char *) name);\n-\t    }\n-\t  else\n-\t    cfun->unlikely_text_section_name = \n-\t                                UNLIKELY_EXECUTED_TEXT_SECTION_NAME;\n+\t  name = TREE_STRING_POINTER (DECL_SECTION_NAME \n+\t\t\t\t                   (current_function_decl));\n+\t  len = strlen (name);\n+\t  unlikely_text_section_name = xmalloc (len + 10);\n+\t  sprintf (unlikely_text_section_name, \"%s%s\", name, \"_unlikely\");\n \t}\n+      else\n+\tunlikely_text_section_name = \n+\t                      xstrdup (UNLIKELY_EXECUTED_TEXT_SECTION_NAME);\n     }\n-  else\n-   internal_error \n-     (\"initialize_cold_section_name called without valid current_function_decl.\");\n }\n \n /* Tell assembler to switch to text section.  */\n@@ -228,25 +253,14 @@ text_section (void)\n void\n unlikely_text_section (void)\n {\n-  if (current_function_decl)\n-    {\n-      struct function *cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n+  if (! unlikely_text_section_name)\n+    initialize_cold_section_name ();\n \n-      if (!cfun->unlikely_text_section_name)\n-\tinitialize_cold_section_name ();\n-\n-      if ((in_section != in_unlikely_executed_text)\n-\t  &&  (in_section != in_named \n-\t       || strcmp (in_named_name, cfun->unlikely_text_section_name) != 0))\n-\t{\n-\t  named_section (NULL_TREE, cfun->unlikely_text_section_name, 0);\n-\t  in_section = in_unlikely_executed_text;\n-\t  last_text_section = in_unlikely_executed_text;\n-\t}\n-    }\n-  else\n+  if ((in_section != in_unlikely_executed_text)\n+      &&  (in_section != in_named \n+\t   || strcmp (in_named_name, unlikely_text_section_name) != 0))\n     {\n-      named_section (NULL_TREE, UNLIKELY_EXECUTED_TEXT_SECTION_NAME, 0);\n+      named_section (NULL_TREE, unlikely_text_section_name, 0);\n       in_section = in_unlikely_executed_text;\n       last_text_section = in_unlikely_executed_text;\n     }\n@@ -300,25 +314,11 @@ int\n in_unlikely_text_section (void)\n {\n   bool ret_val;\n-  struct function *cfun;\n-\n-  if (current_function_decl)\n-    {\n-      cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n \n-      ret_val = ((in_section == in_unlikely_executed_text)\n-\t\t || (in_section == in_named\n-\t\t     && cfun->unlikely_text_section_name\n-\t\t     && strcmp (in_named_name, \n-\t\t\t\tcfun->unlikely_text_section_name) == 0));\n-    }\n-  else\n-    {\n-      ret_val = ((in_section == in_unlikely_executed_text)\n-\t\t || (in_section == in_named\n-\t\t     && strcmp (in_named_name,\n-\t\t\t\tUNLIKELY_EXECUTED_TEXT_SECTION_NAME) == 0));\n-    }\n+  ret_val = ((in_section == in_unlikely_executed_text)\n+\t     || (in_section == in_named\n+\t\t && unlikely_text_section_name\n+\t\t && strcmp (in_named_name, unlikely_text_section_name) == 0));\n \n   return ret_val;\n }\n@@ -463,12 +463,9 @@ named_section (tree decl, const char *name, int reloc)\n     name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n \n   if (strcmp (name, UNLIKELY_EXECUTED_TEXT_SECTION_NAME) == 0\n-      && current_function_decl\n-      && !(DECL_STRUCT_FUNCTION (current_function_decl))->unlikely_text_section_name)\n-    {\n-      struct function *cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n-      cfun->unlikely_text_section_name = UNLIKELY_EXECUTED_TEXT_SECTION_NAME;\n-    }\n+      && !unlikely_text_section_name)\n+      unlikely_text_section_name =\n+\txstrdup (UNLIKELY_EXECUTED_TEXT_SECTION_NAME);\n \n   flags = targetm.section_type_flags (decl, name, reloc);\n \n@@ -577,17 +574,16 @@ asm_output_aligned_bss (FILE *file, tree decl ATTRIBUTE_UNUSED,\n void\n function_section (tree decl)\n {\n-  int reloc = 0;\n+  bool unlikely = false;\n     \n   if (first_function_block_is_cold)\n-    reloc = 1;\n+    unlikely = true;\n   \n #ifdef USE_SELECT_SECTION_FOR_FUNCTIONS\n-  targetm.asm_out.select_section (decl, reloc, DECL_ALIGN (decl));\n+  targetm.asm_out.select_section (decl, unlikely, DECL_ALIGN (decl));\n #else\n   if (decl != NULL_TREE\n-      && DECL_SECTION_NAME (decl) != NULL_TREE\n-      && targetm.have_named_sections)\n+      && DECL_SECTION_NAME (decl) != NULL_TREE)\n     named_section (decl, (char *) 0, 0);\n   else\n     text_section ();\n@@ -598,20 +594,16 @@ void\n current_function_section (tree decl)\n {\n #ifdef USE_SELECT_SECTION_FOR_FUNCTIONS\n-  int reloc = 0; \n-\n-  if (in_unlikely_text_section () \n-      || last_text_section == in_unlikely_executed_text)\n-    reloc = 1;\n- \n-  targetm.asm_out.select_section (decl, reloc, DECL_ALIGN (decl));\n+  bool unlikely = (in_unlikely_text_section () \n+\t\t   || (last_text_section == in_unlikely_executed_text));\n+  \n+  targetm.asm_out.select_section (decl, unlikely, DECL_ALIGN (decl));\n #else\n   if (last_text_section == in_unlikely_executed_text)\n     unlikely_text_section ();\n   else if (last_text_section == in_text)\n     text_section ();\n-  else if (last_text_section == in_named\n-\t   && targetm.have_named_sections)\n+  else if (last_text_section == in_named)\n     named_section (NULL_TREE, last_text_section_name, 0);\n   else\n     function_section (decl);\n@@ -1232,32 +1224,18 @@ void\n assemble_start_function (tree decl, const char *fnname)\n {\n   int align;\n-  char tmp_label[100];\n   bool hot_label_written = false;\n-  struct function *cfun = DECL_STRUCT_FUNCTION (decl);\n \n-  cfun->unlikely_text_section_name = NULL;\n- \n+  unlikely_text_section_name = NULL;\n+  \n   first_function_block_is_cold = false;\n-  if (flag_reorder_blocks_and_partition)\n-    {\n-      ASM_GENERATE_INTERNAL_LABEL (tmp_label, \"HOTB\", const_labelno);\n-      cfun->hot_section_label = ggc_strdup (tmp_label);\n-      ASM_GENERATE_INTERNAL_LABEL (tmp_label, \"COLDB\", const_labelno);\n-      cfun->cold_section_label = ggc_strdup (tmp_label);\n-      ASM_GENERATE_INTERNAL_LABEL (tmp_label, \"HOTE\", const_labelno);\n-      cfun->hot_section_end_label = ggc_strdup (tmp_label);\n-      ASM_GENERATE_INTERNAL_LABEL (tmp_label, \"COLDE\", const_labelno);\n-      cfun->cold_section_end_label = ggc_strdup (tmp_label);\n-      const_labelno++;\n-    }\n-  else\n-    {\n-      cfun->hot_section_label = NULL;\n-      cfun->cold_section_label = NULL;\n-      cfun->hot_section_end_label = NULL;\n-      cfun->cold_section_end_label = NULL;\n-    }\n+  hot_section_label = reconcat (hot_section_label, fnname, \".hot_section\", NULL);\n+  unlikely_section_label = reconcat (unlikely_section_label, \n+\t\t\t\t     fnname, \".unlikely_section\", NULL);\n+  hot_section_end_label = reconcat (hot_section_end_label,\n+\t\t\t\t    fnname, \".end\", NULL);\n+  cold_section_end_label = reconcat (cold_section_end_label,\n+\t\t\t\t    fnname, \".end.cold\", NULL);\n \n   /* The following code does not need preprocessing in the assembler.  */\n \n@@ -1275,15 +1253,15 @@ assemble_start_function (tree decl, const char *fnname)\n     {\n       unlikely_text_section ();\n       assemble_align (FUNCTION_BOUNDARY);\n-      ASM_OUTPUT_LABEL (asm_out_file, cfun->cold_section_label);\n+      ASM_OUTPUT_LABEL (asm_out_file, unlikely_section_label);\n       if (BB_PARTITION (ENTRY_BLOCK_PTR->next_bb) == BB_COLD_PARTITION)\n \t{\n \t  /* Since the function starts with a cold section, we need to\n \t     explicitly align the hot section and write out the hot\n \t     section label.  */\n \t  text_section ();\n \t  assemble_align (FUNCTION_BOUNDARY);\n-\t  ASM_OUTPUT_LABEL (asm_out_file, cfun->hot_section_label);\n+\t  ASM_OUTPUT_LABEL (asm_out_file, hot_section_label);\n \t  hot_label_written = true;\n \t  first_function_block_is_cold = true;\n \t}\n@@ -1313,8 +1291,8 @@ assemble_start_function (tree decl, const char *fnname)\n \ts[i] = (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)))[i];\n       s[len] = '\\0';\n       \n-      if (cfun->unlikely_text_section_name \n-\t  && (strcmp (s, cfun->unlikely_text_section_name) == 0))\n+      if (unlikely_text_section_name \n+\t  && (strcmp (s, unlikely_text_section_name) == 0))\n \tfirst_function_block_is_cold = true;\n     }\n \n@@ -1325,8 +1303,8 @@ assemble_start_function (tree decl, const char *fnname)\n   /* Switch to the correct text section for the start of the function.  */\n \n   function_section (decl);\n-  if (flag_reorder_blocks_and_partition && !hot_label_written)\n-    ASM_OUTPUT_LABEL (asm_out_file, cfun->hot_section_label);\n+  if (!hot_label_written)\n+    ASM_OUTPUT_LABEL (asm_out_file, hot_section_label);\n \n   /* Tell assembler to move to target machine's alignment for functions.  */\n   align = floor_log2 (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n@@ -1388,6 +1366,7 @@ assemble_start_function (tree decl, const char *fnname)\n void\n assemble_end_function (tree decl, const char *fnname)\n {\n+  enum in_section save_text_section;\n #ifdef ASM_DECLARE_FUNCTION_SIZE\n   ASM_DECLARE_FUNCTION_SIZE (asm_out_file, fnname, decl);\n #endif\n@@ -1398,19 +1377,13 @@ assemble_end_function (tree decl, const char *fnname)\n     }\n   /* Output labels for end of hot/cold text sections (to be used by\n      debug info.)  */\n-  if (flag_reorder_blocks_and_partition)\n-    {\n-      enum in_section save_text_section;\n-      struct function *cfun = DECL_STRUCT_FUNCTION (decl);\n-\n-      save_text_section = in_section;\n-      unlikely_text_section ();\n-      ASM_OUTPUT_LABEL (asm_out_file, cfun->cold_section_end_label);\n-      text_section ();\n-      ASM_OUTPUT_LABEL (asm_out_file, cfun->hot_section_end_label);\n-      if (save_text_section == in_unlikely_executed_text)\n-\tunlikely_text_section ();\n-    }\n+  save_text_section = in_section;\n+  unlikely_text_section ();\n+  ASM_OUTPUT_LABEL (asm_out_file, cold_section_end_label);\n+  text_section ();\n+  ASM_OUTPUT_LABEL (asm_out_file, hot_section_end_label);\n+  if (save_text_section == in_unlikely_executed_text)\n+    unlikely_text_section ();\n }\n \f\n /* Assemble code to leave SIZE bytes of zeros.  */\n@@ -4793,23 +4766,14 @@ default_section_type_flags_1 (tree decl, const char *name, int reloc,\n \t\t\t      int shlib)\n {\n   unsigned int flags;\n-  struct function *cfun = NULL;\n-\n-  if (current_function_decl)\n-    cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n \n   if (decl && TREE_CODE (decl) == FUNCTION_DECL)\n     flags = SECTION_CODE;\n   else if (decl && decl_readonly_section_1 (decl, reloc, shlib))\n     flags = 0;\n-  else if (current_function_decl\n-\t   && cfun->unlikely_text_section_name\n-\t   && strcmp (name, cfun->unlikely_text_section_name) == 0)\n+  else if (unlikely_text_section_name\n+\t   && strcmp (name, unlikely_text_section_name) == 0)\n     flags = SECTION_CODE;\n-  else if (!decl \n-\t   && !current_function_decl\n-\t   && strcmp (name, UNLIKELY_EXECUTED_TEXT_SECTION_NAME) == 0)\n-    flags = SECTION_CODE; \n   else\n     flags = SECTION_WRITE;\n "}]}