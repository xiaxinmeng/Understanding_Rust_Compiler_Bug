{"sha": "e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRkMjk3MzYyNDljYzljNWU2MmIwZjhiM2VjZmVkMWE5M2I2ZDczZA==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2018-07-17T08:07:52Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-07-17T08:07:52Z"}, "message": "[Ada] Crash processing abstract state aspect of a package\n\nThe compiler may crash processing an aspect Part_Of used in a\npackage spec which has also an Initial_Condition aspect. After\nthis patch the following test compiles fine.\n\npackage P\nwith\n  SPARK_Mode => On,\n  Abstract_State => (Count_State),\n  Initial_Condition => (Get_Count = 0)              -- Test\nis\n   type Count_Type is range 0 .. 16;\n\n   function Get_Count return Count_Type;\n\n   procedure Dummy;\n\nprivate\n   C: Count_Type := 0 with Part_Of => Count_State;  -- Test\n\n   function Get_Count return Count_Type is (C);\nend P;\n\npackage body P\nwith\n  SPARK_Mode => On,\n  Refined_State => (Count_State => C)\nis\n  procedure Dummy is null;\nend P;\n\nCommand: gcc -c p.adb\n\n2018-07-17  Javier Miranda  <miranda@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch13.adb (Expand_N_Freeze_Entity): Handle subtype declared for an\n\titerator.\n\t* freeze.adb (Freeze_Expression): Handle freeze of an entity defined\n\toutside of a subprogram body. This case was previously handled during\n\tpreanalysis; the frozen entities were remembered and left pending until\n\twe continued freezeing entities outside of the subprogram. Now, when\n\tclimbing the parents chain to locate the correct placement for the\n\tfreezeing node, we check if the entity can be frozen and only when no\n\tenclosing node is marked as Must_Not_Freeze the entity is frozen.\n\t* sem_ch3.ads (Preanalyze_Default_Expression): Declaration moved to the\n\tpackage body.\n\t* sem_ch3.adb (Preanalyze_Default_Expression): Code adjusted to invoke\n\tthe new subprogram Preanalyze_With_Freezing_And_Resolve.\n\t* sem_ch6.adb (Preanalyze_Formal_Expression): New subprogram.\n\t(Analyze_Expression_Function, Process_Formals): Invoke\n\tPreanalyze_Formal_Expression instead of Preanalyze_Spec_Expression\n\tsince the analysis of the formals may freeze entities.\n\t(Analyze_Subprogram_Body_Helper): Skip building the body of the\n\tclass-wide clone for eliminated subprograms.\n\t* sem_res.ads, sem_res.adb (Preanalyze_And_Resolve): New subprogram.\n\tIts code is basically the previous version of this routine but extended\n\twith an additional parameter which is used to specify if during\n\tpreanalysis we are allowed to freeze entities.  If the new parameter is\n\tTrue then the subtree root node is marked as Must_Not_Freeze and no\n\tentities are frozen during preanalysis.\n\t(Preanalyze_And_Resolve): Invokes the internal version of\n\tPreanalyze_And_Resolve without entity freezing.\n\t(Preanalyze_With_Freezing_And_Resolve): Invokes the internal version of\n\tPrenalyze_And_Resolve with freezing enabled.\n\nFrom-SVN: r262785", "tree": {"sha": "aeecc5fc02b7b37f8899912235c025e22763fc8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aeecc5fc02b7b37f8899912235c025e22763fc8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "52afb18645d8ee2d2426d318aa078fbc9f4bcb87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52afb18645d8ee2d2426d318aa078fbc9f4bcb87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52afb18645d8ee2d2426d318aa078fbc9f4bcb87"}], "stats": {"total": 641, "additions": 414, "deletions": 227}, "files": [{"sha": "a2075223678c4a6a396d219055b84464fd188f85", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d", "patch": "@@ -1,3 +1,35 @@\n+2018-07-17  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch13.adb (Expand_N_Freeze_Entity): Handle subtype declared for an\n+\titerator.\n+\t* freeze.adb (Freeze_Expression): Handle freeze of an entity defined\n+\toutside of a subprogram body. This case was previously handled during\n+\tpreanalysis; the frozen entities were remembered and left pending until\n+\twe continued freezeing entities outside of the subprogram. Now, when\n+\tclimbing the parents chain to locate the correct placement for the\n+\tfreezeing node, we check if the entity can be frozen and only when no\n+\tenclosing node is marked as Must_Not_Freeze the entity is frozen.\n+\t* sem_ch3.ads (Preanalyze_Default_Expression): Declaration moved to the\n+\tpackage body.\n+\t* sem_ch3.adb (Preanalyze_Default_Expression): Code adjusted to invoke\n+\tthe new subprogram Preanalyze_With_Freezing_And_Resolve.\n+\t* sem_ch6.adb (Preanalyze_Formal_Expression): New subprogram.\n+\t(Analyze_Expression_Function, Process_Formals): Invoke\n+\tPreanalyze_Formal_Expression instead of Preanalyze_Spec_Expression\n+\tsince the analysis of the formals may freeze entities.\n+\t(Analyze_Subprogram_Body_Helper): Skip building the body of the\n+\tclass-wide clone for eliminated subprograms.\n+\t* sem_res.ads, sem_res.adb (Preanalyze_And_Resolve): New subprogram.\n+\tIts code is basically the previous version of this routine but extended\n+\twith an additional parameter which is used to specify if during\n+\tpreanalysis we are allowed to freeze entities.  If the new parameter is\n+\tTrue then the subtree root node is marked as Must_Not_Freeze and no\n+\tentities are frozen during preanalysis.\n+\t(Preanalyze_And_Resolve): Invokes the internal version of\n+\tPreanalyze_And_Resolve without entity freezing.\n+\t(Preanalyze_With_Freezing_And_Resolve): Invokes the internal version of\n+\tPrenalyze_And_Resolve with freezing enabled.\n+\n 2018-07-17  Piotr Trojanek  <trojanek@adacore.com>\n \n \t* einfo.ads, libgnat/g-comlin.ads: Minor change \"ie\" to \"i.e.\" in docs"}, {"sha": "70e9327704cecb5edf474261163bece41d01d065", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d", "patch": "@@ -470,6 +470,11 @@ package body Exp_Ch13 is\n         and then Ekind (E_Scope) not in Concurrent_Kind\n       then\n          E_Scope := Scope (E_Scope);\n+\n+      --  The entity may be a subtype declared for an iterator.\n+\n+      elsif Ekind (E_Scope) = E_Loop then\n+         E_Scope := Scope (E_Scope);\n       end if;\n \n       --  Remember that we are processing a freezing entity and its freezing"}, {"sha": "691d6a5fe6cc96f0c2e121b1ad8f16c4bebb6d09", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 303, "deletions": 214, "changes": 517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d", "patch": "@@ -6936,20 +6936,6 @@ package body Freeze is\n    -----------------------\n \n    procedure Freeze_Expression (N : Node_Id) is\n-      In_Spec_Exp : constant Boolean := In_Spec_Expression;\n-      Typ         : Entity_Id;\n-      Nam         : Entity_Id;\n-      Desig_Typ   : Entity_Id;\n-      P           : Node_Id;\n-      Parent_P    : Node_Id;\n-\n-      Freeze_Outside : Boolean := False;\n-      --  This flag is set true if the entity must be frozen outside the\n-      --  current subprogram. This happens in the case of expander generated\n-      --  subprograms (_Init_Proc, _Input, _Output, _Read, _Write) which do\n-      --  not freeze all entities like other bodies, but which nevertheless\n-      --  may reference entities that have to be frozen before the body and\n-      --  obviously cannot be frozen inside the body.\n \n       function Find_Aggregate_Component_Desig_Type return Entity_Id;\n       --  If the expression is an array aggregate, the type of the component\n@@ -7038,6 +7024,29 @@ package body Freeze is\n          end if;\n       end In_Expanded_Body;\n \n+      --  Local variables\n+\n+      In_Spec_Exp : constant Boolean := In_Spec_Expression;\n+      Typ         : Entity_Id;\n+      Nam         : Entity_Id;\n+      Desig_Typ   : Entity_Id;\n+      P           : Node_Id;\n+      Parent_P    : Node_Id;\n+\n+      Freeze_Outside       : Boolean := False;\n+      --  This flag is set true if the entity must be frozen outside the\n+      --  current subprogram. This happens in the case of expander generated\n+      --  subprograms (_Init_Proc, _Input, _Output, _Read, _Write) which do\n+      --  not freeze all entities like other bodies, but which nevertheless\n+      --  may reference entities that have to be frozen before the body and\n+      --  obviously cannot be frozen inside the body.\n+\n+      Freeze_Outside_Subp  : Entity_Id := Empty;\n+      --  This entity is set if we are inside a subprogram body and the frozen\n+      --  entity is defined in the enclosing scope of this subprogram. In such\n+      --  case we must skip the subprogram body when climbing the parents chain\n+      --  to locate the correct placement for the freezing node.\n+\n    --  Start of processing for Freeze_Expression\n \n    begin\n@@ -7181,253 +7190,333 @@ package body Freeze is\n          return;\n       end if;\n \n-      --  Examine the enclosing context by climbing the parent chain. The\n-      --  traversal serves two purposes - to detect scenarios where freezeing\n-      --  is not needed and to find the proper insertion point for the freeze\n-      --  nodes. Although somewhat similar to Insert_Actions, this traversal\n-      --  is freezing semantics-sensitive. Inserting freeze nodes blindly in\n-      --  the tree may result in types being frozen too early.\n+      --  Check if we are inside a subprogram body and the frozen entity is\n+      --  defined in the enclosing scope of this subprogram. In such case we\n+      --  must skip the subprogram when climbing the parents chain to locate\n+      --  the correct placement for the freezing node.\n+\n+      --  This is not needed for default expressions and other spec expressions\n+      --  in generic units since the Move_Freeze_Nodes mechanism (sem_ch12.adb)\n+      --  takes care of placing them at the proper place, after the generic\n+      --  unit.\n+\n+      if Present (Nam)\n+        and then Scope (Nam) /= Current_Scope\n+        and then not (In_Spec_Exp and then Inside_A_Generic)\n+      then\n+         declare\n+            S : Entity_Id := Current_Scope;\n+\n+         begin\n+            while Present (S)\n+              and then In_Same_Source_Unit (Nam, S)\n+            loop\n+               if Scope (S) = Scope (Nam) then\n+                  if Is_Subprogram (S) and then Has_Completion (S) then\n+                     Freeze_Outside_Subp := S;\n+                  end if;\n+\n+                  exit;\n+               end if;\n+\n+               S := Scope (S);\n+            end loop;\n+         end;\n+      end if;\n+\n+      --  Examine the enclosing context by climbing the parent chain.\n+\n+      --  If we identified that we must freeze the entity outside of a given\n+      --  subprogram then we just climb up to that subprogram checking if some\n+      --  enclosing node is marked as Must_Not_Freeze (since in such case we\n+      --  must not freeze yet this entity).\n \n       P := N;\n-      loop\n-         Parent_P := Parent (P);\n \n-         --  If we don't have a parent, then we are not in a well-formed tree.\n-         --  This is an unusual case, but there are some legitimate situations\n-         --  in which this occurs, notably when the expressions in the range of\n-         --  a type declaration are resolved. We simply ignore the freeze\n-         --  request in this case. Is this right ???\n+      if Present (Freeze_Outside_Subp) then\n+         loop\n+            --  Do not freeze the current expression if another expression in\n+            --  the chain of parents must not be frozen.\n \n-         if No (Parent_P) then\n-            return;\n-         end if;\n+            if Nkind (P) in N_Subexpr and then Must_Not_Freeze (P) then\n+               return;\n+            end if;\n \n-         --  See if we have got to an appropriate point in the tree\n+            Parent_P := Parent (P);\n \n-         case Nkind (Parent_P) is\n+            --  If we don't have a parent, then we are not in a well-formed\n+            --  tree. This is an unusual case, but there are some legitimate\n+            --  situations in which this occurs, notably when the expressions\n+            --  in the range of a type declaration are resolved. We simply\n+            --  ignore the freeze request in this case.\n \n-            --  A special test for the exception of (RM 13.14(8)) for the case\n-            --  of per-object expressions (RM 3.8(18)) occurring in component\n-            --  definition or a discrete subtype definition. Note that we test\n-            --  for a component declaration which includes both cases we are\n-            --  interested in, and furthermore the tree does not have explicit\n-            --  nodes for either of these two constructs.\n+            if No (Parent_P) then\n+               return;\n+            end if;\n \n-            when N_Component_Declaration =>\n+            exit when Nkind (Parent_P) = N_Subprogram_Body\n+              and then Unique_Defining_Entity (Parent_P) = Freeze_Outside_Subp;\n \n-               --  The case we want to test for here is an identifier that is\n-               --  a per-object expression, this is either a discriminant that\n-               --  appears in a context other than the component declaration\n-               --  or it is a reference to the type of the enclosing construct.\n+            P := Parent_P;\n+         end loop;\n \n-               --  For either of these cases, we skip the freezing\n+      --  Otherwise the traversal serves two purposes - to detect scenarios\n+      --  where freezeing is not needed and to find the proper insertion point\n+      --  for the freeze nodes. Although somewhat similar to Insert_Actions,\n+      --  this traversal is freezing semantics-sensitive. Inserting freeze\n+      --  nodes blindly in the tree may result in types being frozen too early.\n \n-               if not In_Spec_Expression\n-                 and then Nkind (N) = N_Identifier\n-                 and then (Present (Entity (N)))\n-               then\n-                  --  We recognize the discriminant case by just looking for\n-                  --  a reference to a discriminant. It can only be one for\n-                  --  the enclosing construct. Skip freezing in this case.\n+      else\n+         loop\n+            --  Do not freeze the current expression if another expression in\n+            --  the chain of parents must not be frozen.\n \n-                  if Ekind (Entity (N)) = E_Discriminant then\n-                     return;\n+            if Nkind (P) in N_Subexpr and then Must_Not_Freeze (P) then\n+               return;\n+            end if;\n \n-                  --  For the case of a reference to the enclosing record,\n-                  --  (or task or protected type), we look for a type that\n-                  --  matches the current scope.\n+            Parent_P := Parent (P);\n \n-                  elsif Entity (N) = Current_Scope then\n-                     return;\n-                  end if;\n-               end if;\n+            --  If we don't have a parent, then we are not in a well-formed\n+            --  tree. This is an unusual case, but there are some legitimate\n+            --  situations in which this occurs, notably when the expressions\n+            --  in the range of a type declaration are resolved. We simply\n+            --  ignore the freeze request in this case. Is this right ???\n \n-            --  If we have an enumeration literal that appears as the choice in\n-            --  the aggregate of an enumeration representation clause, then\n-            --  freezing does not occur (RM 13.14(10)).\n+            if No (Parent_P) then\n+               return;\n+            end if;\n \n-            when N_Enumeration_Representation_Clause =>\n+            --  See if we have got to an appropriate point in the tree\n \n-               --  The case we are looking for is an enumeration literal\n+            case Nkind (Parent_P) is\n \n-               if (Nkind (N) = N_Identifier or Nkind (N) = N_Character_Literal)\n-                 and then Is_Enumeration_Type (Etype (N))\n-               then\n-                  --  If enumeration literal appears directly as the choice,\n-                  --  do not freeze (this is the normal non-overloaded case)\n+               --  A special test for the exception of (RM 13.14(8)) for the\n+               --  case of per-object expressions (RM 3.8(18)) occurring in\n+               --  component definition or a discrete subtype definition. Note\n+               --  that we test for a component declaration which includes both\n+               --  cases we are interested in, and furthermore the tree does\n+               --  not have explicit nodes for either of these two constructs.\n+\n+               when N_Component_Declaration =>\n+\n+                  --  The case we want to test for here is an identifier that\n+                  --  is a per-object expression, this is either a discriminant\n+                  --  that appears in a context other than the component\n+                  --  declaration or it is a reference to the type of the\n+                  --  enclosing construct.\n \n-                  if Nkind (Parent (N)) = N_Component_Association\n-                    and then First (Choices (Parent (N))) = N\n+                  --  For either of these cases, we skip the freezing\n+\n+                  if not In_Spec_Expression\n+                    and then Nkind (N) = N_Identifier\n+                    and then (Present (Entity (N)))\n                   then\n-                     return;\n+                     --  We recognize the discriminant case by just looking for\n+                     --  a reference to a discriminant. It can only be one for\n+                     --  the enclosing construct. Skip freezing in this case.\n \n-                  --  If enumeration literal appears as the name of function\n-                  --  which is the choice, then also do not freeze. This\n-                  --  happens in the overloaded literal case, where the\n-                  --  enumeration literal is temporarily changed to a function\n-                  --  call for overloading analysis purposes.\n+                     if Ekind (Entity (N)) = E_Discriminant then\n+                        return;\n \n-                  elsif Nkind (Parent (N)) = N_Function_Call\n-                     and then\n-                       Nkind (Parent (Parent (N))) = N_Component_Association\n-                     and then\n-                       First (Choices (Parent (Parent (N)))) = Parent (N)\n+                     --  For the case of a reference to the enclosing record,\n+                     --  (or task or protected type), we look for a type that\n+                     --  matches the current scope.\n+\n+                     elsif Entity (N) = Current_Scope then\n+                        return;\n+                     end if;\n+                  end if;\n+\n+               --  If we have an enumeration literal that appears as the choice\n+               --  in the aggregate of an enumeration representation clause,\n+               --  then freezing does not occur (RM 13.14(10)).\n+\n+               when N_Enumeration_Representation_Clause =>\n+\n+                  --  The case we are looking for is an enumeration literal\n+\n+                  if Nkind_In (N, N_Identifier, N_Character_Literal)\n+                    and then Is_Enumeration_Type (Etype (N))\n                   then\n-                     return;\n+                     --  If enumeration literal appears directly as the choice,\n+                     --  do not freeze (this is the normal non-overloaded case)\n+\n+                     if Nkind (Parent (N)) = N_Component_Association\n+                       and then First (Choices (Parent (N))) = N\n+                     then\n+                        return;\n+\n+                     --  If enumeration literal appears as the name of function\n+                     --  which is the choice, then also do not freeze. This\n+                     --  happens in the overloaded literal case, where the\n+                     --  enumeration literal is temporarily changed to a\n+                     --  function call for overloading analysis purposes.\n+\n+                     elsif Nkind (Parent (N)) = N_Function_Call\n+                        and then\n+                          Nkind (Parent (Parent (N))) = N_Component_Association\n+                        and then\n+                          First (Choices (Parent (Parent (N)))) = Parent (N)\n+                     then\n+                        return;\n+                     end if;\n                   end if;\n-               end if;\n \n-            --  Normally if the parent is a handled sequence of statements,\n-            --  then the current node must be a statement, and that is an\n-            --  appropriate place to insert a freeze node.\n+               --  Normally if the parent is a handled sequence of statements,\n+               --  then the current node must be a statement, and that is an\n+               --  appropriate place to insert a freeze node.\n \n-            when N_Handled_Sequence_Of_Statements =>\n+               when N_Handled_Sequence_Of_Statements =>\n \n-               --  An exception occurs when the sequence of statements is for\n-               --  an expander generated body that did not do the usual freeze\n-               --  all operation. In this case we usually want to freeze\n-               --  outside this body, not inside it, and we skip past the\n-               --  subprogram body that we are inside.\n+                  --  An exception occurs when the sequence of statements is\n+                  --  for an expander generated body that did not do the usual\n+                  --  freeze all operation. In this case we usually want to\n+                  --  freeze outside this body, not inside it, and we skip\n+                  --  past the subprogram body that we are inside.\n \n-               if In_Expanded_Body (Parent_P) then\n-                  declare\n-                     Subp : constant Node_Id := Parent (Parent_P);\n-                     Spec : Entity_Id;\n+                  if In_Expanded_Body (Parent_P) then\n+                     declare\n+                        Subp : constant Node_Id := Parent (Parent_P);\n+                        Spec : Entity_Id;\n \n-                  begin\n-                     --  Freeze the entity only when it is declared inside the\n-                     --  body of the expander generated procedure. This case\n-                     --  is recognized by the scope of the entity or its type,\n-                     --  which is either the spec for some enclosing body, or\n-                     --  (in the case of init_procs, for which there are no\n-                     --  separate specs) the current scope.\n-\n-                     if Nkind (Subp) = N_Subprogram_Body then\n-                        Spec := Corresponding_Spec (Subp);\n-\n-                        if (Present (Typ) and then Scope (Typ) = Spec)\n-                             or else\n-                           (Present (Nam) and then Scope (Nam) = Spec)\n-                        then\n-                           exit;\n+                     begin\n+                        --  Freeze the entity only when it is declared inside\n+                        --  the body of the expander generated procedure.\n+                        --  This case is recognized by the scope of the entity\n+                        --  or its type, which is either the spec for some\n+                        --  enclosing body, or (in the case of init_procs,\n+                        --  for which there are no separate specs) the current\n+                        --  scope.\n+\n+                        if Nkind (Subp) = N_Subprogram_Body then\n+                           Spec := Corresponding_Spec (Subp);\n+\n+                           if (Present (Typ) and then Scope (Typ) = Spec)\n+                                or else\n+                              (Present (Nam) and then Scope (Nam) = Spec)\n+                           then\n+                              exit;\n \n-                        elsif Present (Typ)\n-                          and then Scope (Typ) = Current_Scope\n-                          and then Defining_Entity (Subp) = Current_Scope\n-                        then\n-                           exit;\n+                           elsif Present (Typ)\n+                             and then Scope (Typ) = Current_Scope\n+                             and then Defining_Entity (Subp) = Current_Scope\n+                           then\n+                              exit;\n+                           end if;\n                         end if;\n-                     end if;\n \n-                     --  An expression function may act as a completion of\n-                     --  a function declaration. As such, it can reference\n-                     --  entities declared between the two views:\n+                        --  An expression function may act as a completion of\n+                        --  a function declaration. As such, it can reference\n+                        --  entities declared between the two views:\n \n-                     --     Hidden [];                             -- 1\n-                     --     function F return ...;\n-                     --     private\n-                     --        function Hidden return ...;\n-                     --        function F return ... is (Hidden);  -- 2\n+                        --     Hidden [];                             -- 1\n+                        --     function F return ...;\n+                        --     private\n+                        --        function Hidden return ...;\n+                        --        function F return ... is (Hidden);  -- 2\n \n-                     --  Refering to the example above, freezing the expression\n-                     --  of F (2) would place Hidden's freeze node (1) in the\n-                     --  wrong place. Avoid explicit freezing and let the usual\n-                     --  scenarios do the job - for example, reaching the end\n-                     --  of the private declarations, or a call to F.\n+                        --  Refering to the example above, freezing the\n+                        --  expression of F (2) would place Hidden's freeze\n+                        --  node (1) in the wrong place. Avoid explicit\n+                        --  freezing and let the usual scenarios do the job\n+                        --  (for example, reaching the end of the private\n+                        --  declarations, or a call to F.)\n \n-                     if Nkind (Original_Node (Subp)) =\n-                                                N_Expression_Function\n-                     then\n-                        null;\n+                        if Nkind (Original_Node (Subp)) = N_Expression_Function\n+                        then\n+                           null;\n \n-                     --  Freeze outside the body\n+                        --  Freeze outside the body\n \n-                     else\n-                        Parent_P := Parent (Parent_P);\n-                        Freeze_Outside := True;\n-                     end if;\n-                  end;\n+                        else\n+                           Parent_P := Parent (Parent_P);\n+                           Freeze_Outside := True;\n+                        end if;\n+                     end;\n \n-               --  Here if normal case where we are in handled statement\n-               --  sequence and want to do the insertion right there.\n+                  --  Here if normal case where we are in handled statement\n+                  --  sequence and want to do the insertion right there.\n \n-               else\n-                  exit;\n-               end if;\n+                  else\n+                     exit;\n+                  end if;\n \n-            --  If parent is a body or a spec or a block, then the current node\n-            --  is a statement or declaration and we can insert the freeze node\n-            --  before it.\n-\n-            when N_Block_Statement\n-               | N_Entry_Body\n-               | N_Package_Body\n-               | N_Package_Specification\n-               | N_Protected_Body\n-               | N_Subprogram_Body\n-               | N_Task_Body\n-            =>\n-               exit;\n-\n-            --  The expander is allowed to define types in any statements list,\n-            --  so any of the following parent nodes also mark a freezing point\n-            --  if the actual node is in a list of statements or declarations.\n-\n-            when N_Abortable_Part\n-               | N_Accept_Alternative\n-               | N_And_Then\n-               | N_Case_Statement_Alternative\n-               | N_Compilation_Unit_Aux\n-               | N_Conditional_Entry_Call\n-               | N_Delay_Alternative\n-               | N_Elsif_Part\n-               | N_Entry_Call_Alternative\n-               | N_Exception_Handler\n-               | N_Extended_Return_Statement\n-               | N_Freeze_Entity\n-               | N_If_Statement\n-               | N_Or_Else\n-               | N_Selective_Accept\n-               | N_Triggering_Alternative\n-            =>\n-               exit when Is_List_Member (P);\n-\n-            --  Freeze nodes produced by an expression coming from the Actions\n-            --  list of a N_Expression_With_Actions node must remain within the\n-            --  Actions list. Inserting the freeze nodes further up the tree\n-            --  may lead to use before declaration issues in the case of array\n-            --  types.\n-\n-            when N_Expression_With_Actions =>\n-               if Is_List_Member (P)\n-                 and then List_Containing (P) = Actions (Parent_P)\n-               then\n+               --  If parent is a body or a spec or a block, then the current\n+               --  node is a statement or declaration and we can insert the\n+               --  freeze node before it.\n+\n+               when N_Block_Statement\n+                  | N_Entry_Body\n+                  | N_Package_Body\n+                  | N_Package_Specification\n+                  | N_Protected_Body\n+                  | N_Subprogram_Body\n+                  | N_Task_Body\n+               =>\n                   exit;\n-               end if;\n \n-            --  Note: N_Loop_Statement is a special case. A type that appears\n-            --  in the source can never be frozen in a loop (this occurs only\n-            --  because of a loop expanded by the expander), so we keep on\n-            --  going. Otherwise we terminate the search. Same is true of any\n-            --  entity which comes from source. (if they have predefined type,\n-            --  that type does not appear to come from source, but the entity\n-            --  should not be frozen here).\n+               --  The expander is allowed to define types in any statements\n+               --  list, so any of the following parent nodes also mark a\n+               --  freezing point if the actual node is in a list of\n+               --  statements or declarations.\n+\n+               when N_Abortable_Part\n+                  | N_Accept_Alternative\n+                  | N_And_Then\n+                  | N_Case_Statement_Alternative\n+                  | N_Compilation_Unit_Aux\n+                  | N_Conditional_Entry_Call\n+                  | N_Delay_Alternative\n+                  | N_Elsif_Part\n+                  | N_Entry_Call_Alternative\n+                  | N_Exception_Handler\n+                  | N_Extended_Return_Statement\n+                  | N_Freeze_Entity\n+                  | N_If_Statement\n+                  | N_Or_Else\n+                  | N_Selective_Accept\n+                  | N_Triggering_Alternative\n+               =>\n+                  exit when Is_List_Member (P);\n+\n+               --  Freeze nodes produced by an expression coming from the\n+               --  Actions list of a N_Expression_With_Actions node must remain\n+               --  within the Actions list. Inserting the freeze nodes further\n+               --  up the tree may lead to use before declaration issues in the\n+               --  case of array types.\n+\n+               when N_Expression_With_Actions =>\n+                  if Is_List_Member (P)\n+                    and then List_Containing (P) = Actions (Parent_P)\n+                  then\n+                     exit;\n+                  end if;\n \n-            when N_Loop_Statement =>\n-               exit when not Comes_From_Source (Etype (N))\n-                 and then (No (Nam) or else not Comes_From_Source (Nam));\n+               --  Note: N_Loop_Statement is a special case. A type that\n+               --  appears in the source can never be frozen in a loop (this\n+               --  occurs only because of a loop expanded by the expander), so\n+               --  we keep on going. Otherwise we terminate the search. Same\n+               --  is true of any entity which comes from source. (if they\n+               --  have predefined type, that type does not appear to come\n+               --  from source, but the entity should not be frozen here).\n \n-            --  For all other cases, keep looking at parents\n+               when N_Loop_Statement =>\n+                  exit when not Comes_From_Source (Etype (N))\n+                    and then (No (Nam) or else not Comes_From_Source (Nam));\n \n-            when others =>\n-               null;\n-         end case;\n+               --  For all other cases, keep looking at parents\n \n-         --  We fall through the case if we did not yet find the proper\n-         --  place in the free for inserting the freeze node, so climb.\n+               when others =>\n+                  null;\n+            end case;\n \n-         P := Parent_P;\n-      end loop;\n+            --  We fall through the case if we did not yet find the proper\n+            --  place in the free for inserting the freeze node, so climb.\n+\n+            P := Parent_P;\n+         end loop;\n+      end if;\n \n       --  If the expression appears in a record or an initialization procedure,\n       --  the freeze nodes are collected and attached to the current scope, to"}, {"sha": "ad9d7e14d1b502c41be121990bfdd0ca97ce3a46", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d", "patch": "@@ -605,6 +605,10 @@ package body Sem_Ch3 is\n    --  Create a new ordinary fixed point type, and apply the constraint to\n    --  obtain subtype of it.\n \n+   procedure Preanalyze_Default_Expression (N : Node_Id; T : Entity_Id);\n+   --  Wrapper on Preanalyze_Spec_Expression for default expressions, so that\n+   --  In_Default_Expr can be properly adjusted.\n+\n    procedure Prepare_Private_Subtype_Completion\n      (Id          : Entity_Id;\n       Related_Nod : Node_Id);\n@@ -19818,11 +19822,14 @@ package body Sem_Ch3 is\n    -----------------------------------\n \n    procedure Preanalyze_Default_Expression (N : Node_Id; T : Entity_Id) is\n-      Save_In_Default_Expr : constant Boolean := In_Default_Expr;\n+      Save_In_Default_Expr    : constant Boolean := In_Default_Expr;\n+      Save_In_Spec_Expression : constant Boolean := In_Spec_Expression;\n    begin\n-      In_Default_Expr := True;\n-      Preanalyze_Spec_Expression (N, T);\n-      In_Default_Expr := Save_In_Default_Expr;\n+      In_Default_Expr    := True;\n+      In_Spec_Expression := True;\n+      Preanalyze_With_Freezing_And_Resolve (N, T);\n+      In_Default_Expr    := Save_In_Default_Expr;\n+      In_Spec_Expression := Save_In_Spec_Expression;\n    end Preanalyze_Default_Expression;\n \n    --------------------------------"}, {"sha": "c82ab860e77404813ec0bc16cf4553db972ee40e", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d", "patch": "@@ -250,10 +250,6 @@ package Sem_Ch3 is\n    --  Wrapper on Preanalyze_Spec_Expression for assertion expressions, so that\n    --  In_Assertion_Expr can be properly adjusted.\n \n-   procedure Preanalyze_Default_Expression (N : Node_Id; T : Entity_Id);\n-   --  Wrapper on Preanalyze_Spec_Expression for default expressions, so that\n-   --  In_Default_Expr can be properly adjusted.\n-\n    procedure Process_Full_View (N : Node_Id; Full_T, Priv_T : Entity_Id);\n    --  Process some semantic actions when the full view of a private type is\n    --  encountered and analyzed. The first action is to create the full views"}, {"sha": "08717bf0a23190fae066babb1d93b61ff6f2661b", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d", "patch": "@@ -206,6 +206,10 @@ package body Sem_Ch6 is\n    --  Create the declaration for an inequality operator that is implicitly\n    --  created by a user-defined equality operator that yields a boolean.\n \n+   procedure Preanalyze_Formal_Expression (N : Node_Id; T : Entity_Id);\n+   --  Preanalysis of default expressions of subprogram formals. N is the\n+   --  expression to be analyzed and T is the expected type.\n+\n    procedure Set_Formal_Validity (Formal_Id : Entity_Id);\n    --  Formal_Id is an formal parameter entity. This procedure deals with\n    --  setting the proper validity status for this entity, which depends on\n@@ -761,7 +765,7 @@ package body Sem_Ch6 is\n                if not Inside_A_Generic then\n                   Push_Scope (Def_Id);\n                   Install_Formals (Def_Id);\n-                  Preanalyze_Spec_Expression (Expr, Typ);\n+                  Preanalyze_Formal_Expression (Expr, Typ);\n                   Check_Limited_Return (Original_Node (N), Expr, Typ);\n                   End_Scope;\n                end if;\n@@ -3862,12 +3866,14 @@ package body Sem_Ch6 is\n       --  If the subprogram has a class-wide clone, build its body as a copy\n       --  of the original body, and rewrite body of original subprogram as a\n       --  wrapper that calls the clone. If N is a stub, this construction will\n-      --  take place when the proper body is analyzed.\n+      --  take place when the proper body is analyzed. No action needed if this\n+      --  subprogram has been eliminated.\n \n       if Present (Spec_Id)\n         and then Present (Class_Wide_Clone (Spec_Id))\n         and then (Comes_From_Source (N) or else Was_Expression_Function (N))\n         and then Nkind (N) /= N_Subprogram_Body_Stub\n+        and then not (Expander_Active and then Is_Eliminated (Spec_Id))\n       then\n          Build_Class_Wide_Clone_Body (Spec_Id, N);\n \n@@ -11333,6 +11339,18 @@ package body Sem_Ch6 is\n          end if;\n    end New_Overloaded_Entity;\n \n+   ----------------------------------\n+   -- Preanalyze_Formal_Expression --\n+   ----------------------------------\n+\n+   procedure Preanalyze_Formal_Expression (N : Node_Id; T : Entity_Id) is\n+      Save_In_Spec_Expression : constant Boolean := In_Spec_Expression;\n+   begin\n+      In_Spec_Expression := True;\n+      Preanalyze_With_Freezing_And_Resolve (N, T);\n+      In_Spec_Expression := Save_In_Spec_Expression;\n+   end Preanalyze_Formal_Expression;\n+\n    ---------------------\n    -- Process_Formals --\n    ---------------------\n@@ -11625,7 +11643,7 @@ package body Sem_Ch6 is\n             --  Do the special preanalysis of the expression (see section on\n             --  \"Handling of Default Expressions\" in the spec of package Sem).\n \n-            Preanalyze_Spec_Expression (Default, Formal_Type);\n+            Preanalyze_Formal_Expression (Default, Formal_Type);\n \n             --  An access to constant cannot be the default for\n             --  an access parameter that is an access to variable."}, {"sha": "6bcfc389db8ea5af6050302efa5ac73a6c3f7c7d", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d", "patch": "@@ -142,6 +142,12 @@ package body Sem_Res is\n    --  a call, so such an operator is not treated as predefined by this\n    --  predicate.\n \n+   procedure Preanalyze_And_Resolve\n+     (N             : Node_Id;\n+      T             : Entity_Id;\n+      With_Freezing : Boolean);\n+   --  Subsidiary of public versions of Preanalyze_And_Resolve.\n+\n    procedure Replace_Actual_Discriminants (N : Node_Id; Default : Node_Id);\n    --  If a default expression in entry call N depends on the discriminants\n    --  of the task, it must be replaced with a reference to the discriminant\n@@ -1660,10 +1666,21 @@ package body Sem_Res is\n    -- Preanalyze_And_Resolve --\n    ----------------------------\n \n-   procedure Preanalyze_And_Resolve (N : Node_Id; T : Entity_Id) is\n-      Save_Full_Analysis : constant Boolean := Full_Analysis;\n+   procedure Preanalyze_And_Resolve\n+     (N             : Node_Id;\n+      T             : Entity_Id;\n+      With_Freezing : Boolean)\n+   is\n+      Save_Full_Analysis   : constant Boolean := Full_Analysis;\n+      Save_Must_Not_Freeze : constant Boolean := Must_Not_Freeze (N);\n \n    begin\n+      pragma Assert (Nkind (N) in N_Subexpr);\n+\n+      if not With_Freezing then\n+         Set_Must_Not_Freeze (N);\n+      end if;\n+\n       Full_Analysis := False;\n       Expander_Mode_Save_And_Set (False);\n \n@@ -1690,6 +1707,16 @@ package body Sem_Res is\n \n       Expander_Mode_Restore;\n       Full_Analysis := Save_Full_Analysis;\n+      Set_Must_Not_Freeze (N, Save_Must_Not_Freeze);\n+   end Preanalyze_And_Resolve;\n+\n+   ----------------------------\n+   -- Preanalyze_And_Resolve --\n+   ----------------------------\n+\n+   procedure Preanalyze_And_Resolve (N : Node_Id; T : Entity_Id) is\n+   begin\n+      Preanalyze_And_Resolve (N, T, With_Freezing => False);\n    end Preanalyze_And_Resolve;\n \n    --  Version without context type\n@@ -1708,6 +1735,16 @@ package body Sem_Res is\n       Full_Analysis := Save_Full_Analysis;\n    end Preanalyze_And_Resolve;\n \n+   ------------------------------------------\n+   -- Preanalyze_With_Freezing_And_Resolve --\n+   ------------------------------------------\n+\n+   procedure Preanalyze_With_Freezing_And_Resolve (N : Node_Id; T : Entity_Id)\n+   is\n+   begin\n+      Preanalyze_And_Resolve (N, T, With_Freezing => True);\n+   end Preanalyze_With_Freezing_And_Resolve;\n+\n    ----------------------------------\n    -- Replace_Actual_Discriminants --\n    ----------------------------------"}, {"sha": "aeb758df4661c6bdbb576c1e81dc22a80d4adaf8", "filename": "gcc/ada/sem_res.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/gcc%2Fada%2Fsem_res.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d/gcc%2Fada%2Fsem_res.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.ads?ref=e4d29736249cc9c5e62b0f8b3ecfed1a93b6d73d", "patch": "@@ -93,6 +93,9 @@ package Sem_Res is\n    procedure Preanalyze_And_Resolve (N : Node_Id);\n    --  Same, but use type of node because context does not impose a single type\n \n+   procedure Preanalyze_With_Freezing_And_Resolve (N : Node_Id; T : Entity_Id);\n+   --  Same, but perform freezing of static expressions of N or its children.\n+\n    procedure Resolve (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve (N : Node_Id; Typ : Entity_Id; Suppress : Check_Id);\n    --  Top-level type-checking procedure, called in a complete context. The"}]}