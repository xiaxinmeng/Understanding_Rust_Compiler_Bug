{"sha": "62852194225ed2df31ff6a600659e5cefbb1e8c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI4NTIxOTQyMjVlZDJkZjMxZmY2YTYwMDY1OWU1Y2VmYmIxZThjMA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2018-08-23T13:25:36Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2018-08-23T13:25:36Z"}, "message": "tree-vrp.c (abs_extent_range): Remove.\n\n\t* tree-vrp.c (abs_extent_range): Remove.\n\t(extract_range_into_wide_ints): Pass wide ints by reference.\n\t(extract_range_from_binary_expr_1): Rewrite the *DIV_EXPR code.\n\tPass wide ints by reference in all calls to\n\textract_range_into_wide_ints.\n\t* wide-int-range.cc (wide_int_range_div): New.\n\t* wide-int-range.h (wide_int_range_div): New.\n\t(wide_int_range_includes_zero_p): New.\n\t(wide_int_range_zero_p): New.\n\nFrom-SVN: r263813", "tree": {"sha": "0ae9ff87faf8a472941922a6c3732b1148f5c74f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ae9ff87faf8a472941922a6c3732b1148f5c74f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62852194225ed2df31ff6a600659e5cefbb1e8c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62852194225ed2df31ff6a600659e5cefbb1e8c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62852194225ed2df31ff6a600659e5cefbb1e8c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62852194225ed2df31ff6a600659e5cefbb1e8c0/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "488461d8622d5d7b5f85612562fd5abb979f5d57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/488461d8622d5d7b5f85612562fd5abb979f5d57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/488461d8622d5d7b5f85612562fd5abb979f5d57"}], "stats": {"total": 309, "additions": 168, "deletions": 141}, "files": [{"sha": "594e1252b1cd1cbafcb61554f1d9ed53db4b6c1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62852194225ed2df31ff6a600659e5cefbb1e8c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62852194225ed2df31ff6a600659e5cefbb1e8c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62852194225ed2df31ff6a600659e5cefbb1e8c0", "patch": "@@ -1,3 +1,15 @@\n+2018-08-23  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* tree-vrp.c (abs_extent_range): Remove.\n+\t(extract_range_into_wide_ints): Pass wide ints by reference.\n+\t(extract_range_from_binary_expr_1): Rewrite the *DIV_EXPR code.\n+\tPass wide ints by reference in all calls to\n+\textract_range_into_wide_ints.\n+\t* wide-int-range.cc (wide_int_range_div): New.\n+\t* wide-int-range.h (wide_int_range_div): New.\n+\t(wide_int_range_includes_zero_p): New.\n+\t(wide_int_range_zero_p): New.\n+\n 2018-08-23  Matthew Malcomson  <matthew.malcomson@arm.com>\n \n \t* config/aarch64/aarch64.md (arches): New enum."}, {"sha": "735b3646e815600d677c337ddd8309373ef25aa4", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 54, "deletions": 141, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62852194225ed2df31ff6a600659e5cefbb1e8c0/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62852194225ed2df31ff6a600659e5cefbb1e8c0/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=62852194225ed2df31ff6a600659e5cefbb1e8c0", "patch": "@@ -478,42 +478,6 @@ set_value_range_to_null (value_range *vr, tree type)\n   set_value_range_to_value (vr, build_int_cst (type, 0), vr->equiv);\n }\n \n-\n-/* If abs (min) < abs (max), set VR to [-max, max], if\n-   abs (min) >= abs (max), set VR to [-min, min].  */\n-\n-static void\n-abs_extent_range (value_range *vr, tree min, tree max)\n-{\n-  int cmp;\n-\n-  gcc_assert (TREE_CODE (min) == INTEGER_CST);\n-  gcc_assert (TREE_CODE (max) == INTEGER_CST);\n-  gcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (min)));\n-  gcc_assert (!TYPE_UNSIGNED (TREE_TYPE (min)));\n-  min = fold_unary (ABS_EXPR, TREE_TYPE (min), min);\n-  max = fold_unary (ABS_EXPR, TREE_TYPE (max), max);\n-  if (TREE_OVERFLOW (min) || TREE_OVERFLOW (max))\n-    {\n-      set_value_range_to_varying (vr);\n-      return;\n-    }\n-  cmp = compare_values (min, max);\n-  if (cmp == -1)\n-    min = fold_unary (NEGATE_EXPR, TREE_TYPE (min), max);\n-  else if (cmp == 0 || cmp == 1)\n-    {\n-      max = min;\n-      min = fold_unary (NEGATE_EXPR, TREE_TYPE (min), min);\n-    }\n-  else\n-    {\n-      set_value_range_to_varying (vr);\n-      return;\n-    }\n-  set_and_canonicalize_value_range (vr, VR_RANGE, min, max, NULL);\n-}\n-\n /* Return true, if VAL1 and VAL2 are equal values for VRP purposes.  */\n \n bool\n@@ -997,6 +961,9 @@ ranges_from_anti_range (value_range *ar,\n   vr0->type = VR_UNDEFINED;\n   vr1->type = VR_UNDEFINED;\n \n+  /* As a future improvement, we could handle ~[0, A] as: [-INF, -1] U\n+     [A+1, +INF].  Not sure if this helps in practice, though.  */\n+\n   if (ar->type != VR_ANTI_RANGE\n       || TREE_CODE (ar->min) != INTEGER_CST\n       || TREE_CODE (ar->max) != INTEGER_CST\n@@ -1034,17 +1001,17 @@ ranges_from_anti_range (value_range *ar,\n static void inline\n extract_range_into_wide_ints (value_range *vr,\n \t\t\t      signop sign, unsigned prec,\n-\t\t\t      wide_int *wmin, wide_int *wmax)\n+\t\t\t      wide_int &wmin, wide_int &wmax)\n {\n   if (range_int_cst_p (vr))\n     {\n-      *wmin = wi::to_wide (vr->min);\n-      *wmax = wi::to_wide (vr->max);\n+      wmin = wi::to_wide (vr->min);\n+      wmax = wi::to_wide (vr->max);\n     }\n   else\n     {\n-      *wmin = wi::min_value (prec, sign);\n-      *wmax = wi::max_value (prec, sign);\n+      wmin = wi::min_value (prec, sign);\n+      wmax = wi::max_value (prec, sign);\n     }\n }\n \n@@ -1597,8 +1564,8 @@ extract_range_from_binary_expr_1 (value_range *vr,\n       wide_int wmin, wmax;\n       wide_int vr0_min, vr0_max;\n       wide_int vr1_min, vr1_max;\n-      extract_range_into_wide_ints (&vr0, sign, prec, &vr0_min, &vr0_max);\n-      extract_range_into_wide_ints (&vr1, sign, prec, &vr1_min, &vr1_max);\n+      extract_range_into_wide_ints (&vr0, sign, prec, vr0_min, vr0_max);\n+      extract_range_into_wide_ints (&vr1, sign, prec, vr1_min, vr1_max);\n       if (wide_int_range_min_max (wmin, wmax, code, sign, prec,\n \t\t\t\t  vr0_min, vr0_max, vr1_min, vr1_max))\n \tset_value_range (vr, VR_RANGE,\n@@ -1668,109 +1635,55 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t   || code == EXACT_DIV_EXPR\n \t   || code == ROUND_DIV_EXPR)\n     {\n-      if (vr0.type != VR_RANGE || symbolic_range_p (&vr0))\n+      wide_int dividend_min, dividend_max, divisor_min, divisor_max;\n+      wide_int wmin, wmax, extra_min, extra_max;\n+      bool extra_range_p;\n+\n+      /* Special case explicit division by zero as undefined.  */\n+      if (range_is_null (&vr1))\n \t{\n-\t  /* For division, if op1 has VR_RANGE but op0 does not, something\n-\t     can be deduced just from that range.  Say [min, max] / [4, max]\n-\t     gives [min / 4, max / 4] range.  */\n-\t  if (vr1.type == VR_RANGE\n-\t      && !symbolic_range_p (&vr1)\n-\t      && range_includes_zero_p (vr1.min, vr1.max) == 0)\n-\t    {\n-\t      vr0.type = type = VR_RANGE;\n-\t      vr0.min = vrp_val_min (expr_type);\n-\t      vr0.max = vrp_val_max (expr_type);\n-\t    }\n+\t  /* However, we must not eliminate a division by zero if\n+\t     flag_non_call_exceptions.  */\n+\t  if (cfun->can_throw_non_call_exceptions)\n+\t    set_value_range_to_varying (vr);\n \t  else\n-\t    {\n-\t      set_value_range_to_varying (vr);\n-\t      return;\n-\t    }\n+\t    set_value_range_to_undefined (vr);\n+\t  return;\n \t}\n \n-      /* For divisions, if flag_non_call_exceptions is true, we must\n-\t not eliminate a division by zero.  */\n-      if (cfun->can_throw_non_call_exceptions\n-\t  && (vr1.type != VR_RANGE\n-\t      || range_includes_zero_p (vr1.min, vr1.max) != 0))\n+      /* First, normalize ranges into constants we can handle.  Note\n+\t that VR_ANTI_RANGE's of constants were already normalized\n+\t before arriving here.\n+\n+\t NOTE: As a future improvement, we may be able to do better\n+\t with mixed symbolic (anti-)ranges like [0, A].  See note in\n+\t ranges_from_anti_range.  */\n+      extract_range_into_wide_ints (&vr0, sign, prec,\n+\t\t\t\t    dividend_min, dividend_max);\n+      extract_range_into_wide_ints (&vr1, sign, prec,\n+\t\t\t\t    divisor_min, divisor_max);\n+      if (!wide_int_range_div (wmin, wmax, code, sign, prec,\n+\t\t\t       dividend_min, dividend_max,\n+\t\t\t       divisor_min, divisor_max,\n+\t\t\t       TYPE_OVERFLOW_UNDEFINED (expr_type),\n+\t\t\t       TYPE_OVERFLOW_WRAPS (expr_type),\n+\t\t\t       extra_range_p, extra_min, extra_max))\n \t{\n \t  set_value_range_to_varying (vr);\n \t  return;\n \t}\n-\n-      /* For divisions, if op0 is VR_RANGE, we can deduce a range\n-\t even if op1 is VR_VARYING, VR_ANTI_RANGE, symbolic or can\n-\t include 0.  */\n-      if (vr0.type == VR_RANGE\n-\t  && (vr1.type != VR_RANGE\n-\t      || range_includes_zero_p (vr1.min, vr1.max) != 0))\n-\t{\n-\t  tree zero = build_int_cst (TREE_TYPE (vr0.min), 0);\n-\t  int cmp;\n-\n-\t  min = NULL_TREE;\n-\t  max = NULL_TREE;\n-\t  if (TYPE_UNSIGNED (expr_type)\n-\t      || value_range_nonnegative_p (&vr1))\n-\t    {\n-\t      /* For unsigned division or when divisor is known\n-\t\t to be non-negative, the range has to cover\n-\t\t all numbers from 0 to max for positive max\n-\t\t and all numbers from min to 0 for negative min.  */\n-\t      cmp = compare_values (vr0.max, zero);\n-\t      if (cmp == -1)\n-\t\t{\n-\t\t  /* When vr0.max < 0, vr1.min != 0 and value\n-\t\t     ranges for dividend and divisor are available.  */\n-\t\t  if (vr1.type == VR_RANGE\n-\t\t      && !symbolic_range_p (&vr0)\n-\t\t      && !symbolic_range_p (&vr1)\n-\t\t      && compare_values (vr1.min, zero) != 0)\n-\t\t    max = int_const_binop (code, vr0.max, vr1.min);\n-\t\t  else\n-\t\t    max = zero;\n-\t\t}\n-\t      else if (cmp == 0 || cmp == 1)\n-\t\tmax = vr0.max;\n-\t      else\n-\t\ttype = VR_VARYING;\n-\t      cmp = compare_values (vr0.min, zero);\n-\t      if (cmp == 1)\n-\t\t{\n-\t\t  /* For unsigned division when value ranges for dividend\n-\t\t     and divisor are available.  */\n-\t\t  if (vr1.type == VR_RANGE\n-\t\t      && !symbolic_range_p (&vr0)\n-\t\t      && !symbolic_range_p (&vr1)\n-\t\t      && compare_values (vr1.max, zero) != 0)\n-\t\t    min = int_const_binop (code, vr0.min, vr1.max);\n-\t\t  else\n-\t\t    min = zero;\n-\t\t}\n-\t      else if (cmp == 0 || cmp == -1)\n-\t\tmin = vr0.min;\n-\t      else\n-\t\ttype = VR_VARYING;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Otherwise the range is -max .. max or min .. -min\n-\t\t depending on which bound is bigger in absolute value,\n-\t\t as the division can change the sign.  */\n-\t      abs_extent_range (vr, vr0.min, vr0.max);\n-\t      return;\n-\t    }\n-\t  if (type == VR_VARYING)\n-\t    {\n-\t      set_value_range_to_varying (vr);\n-\t      return;\n-\t    }\n-\t}\n-      else if (range_int_cst_p (&vr0) && range_int_cst_p (&vr1))\n+      set_value_range (vr, VR_RANGE,\n+\t\t       wide_int_to_tree (expr_type, wmin),\n+\t\t       wide_int_to_tree (expr_type, wmax), NULL);\n+      if (extra_range_p)\n \t{\n-\t  extract_range_from_multiplicative_op (vr, code, &vr0, &vr1);\n-\t  return;\n+\t  value_range extra_range = VR_INITIALIZER;\n+\t  set_value_range (&extra_range, VR_RANGE,\n+\t\t\t   wide_int_to_tree (expr_type, extra_min),\n+\t\t\t   wide_int_to_tree (expr_type, extra_max), NULL);\n+\t  vrp_meet (vr, &extra_range);\n \t}\n+      return;\n     }\n   else if (code == TRUNC_MOD_EXPR)\n     {\n@@ -1781,8 +1694,8 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t}\n       wide_int wmin, wmax, tmp;\n       wide_int vr0_min, vr0_max, vr1_min, vr1_max;\n-      extract_range_into_wide_ints (&vr0, sign, prec, &vr0_min, &vr0_max);\n-      extract_range_into_wide_ints (&vr1, sign, prec, &vr1_min, &vr1_max);\n+      extract_range_into_wide_ints (&vr0, sign, prec, vr0_min, vr0_max);\n+      extract_range_into_wide_ints (&vr1, sign, prec, vr1_min, vr1_max);\n       wide_int_range_trunc_mod (wmin, wmax, sign, prec,\n \t\t\t\tvr0_min, vr0_max, vr1_min, vr1_max);\n       min = wide_int_to_tree (expr_type, wmin);\n@@ -1803,8 +1716,8 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t\t\t\t &may_be_nonzero0, &must_be_nonzero0);\n       vrp_set_zero_nonzero_bits (expr_type, &vr1,\n \t\t\t\t &may_be_nonzero1, &must_be_nonzero1);\n-      extract_range_into_wide_ints (&vr0, sign, prec, &vr0_min, &vr0_max);\n-      extract_range_into_wide_ints (&vr1, sign, prec, &vr1_min, &vr1_max);\n+      extract_range_into_wide_ints (&vr0, sign, prec, vr0_min, vr0_max);\n+      extract_range_into_wide_ints (&vr1, sign, prec, vr1_min, vr1_max);\n       if (code == BIT_AND_EXPR)\n \t{\n \t  if (wide_int_range_bit_and (wmin, wmax, sign, prec,\n@@ -2033,7 +1946,7 @@ extract_range_from_unary_expr (value_range *vr,\n \t}\n       wide_int wmin, wmax;\n       wide_int vr0_min, vr0_max;\n-      extract_range_into_wide_ints (&vr0, sign, prec, &vr0_min, &vr0_max);\n+      extract_range_into_wide_ints (&vr0, sign, prec, vr0_min, vr0_max);\n       if (wide_int_range_abs (wmin, wmax, sign, prec, vr0_min, vr0_max,\n \t\t\t      TYPE_OVERFLOW_UNDEFINED (type)))\n \tset_value_range (vr, VR_RANGE,"}, {"sha": "cbc71c25cfeacddc43c93fb0dcd3b97da0230a2f", "filename": "gcc/wide-int-range.cc", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62852194225ed2df31ff6a600659e5cefbb1e8c0/gcc%2Fwide-int-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62852194225ed2df31ff6a600659e5cefbb1e8c0/gcc%2Fwide-int-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int-range.cc?ref=62852194225ed2df31ff6a600659e5cefbb1e8c0", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n+#include \"function.h\"\n #include \"fold-const.h\"\n #include \"wide-int-range.h\"\n \n@@ -663,3 +664,75 @@ wide_int_range_abs (wide_int &min, wide_int &max,\n       return false;\n   return true;\n }\n+\n+/* Calculate a division operation on two ranges and store the result in\n+   [WMIN, WMAX] U [EXTRA_MIN, EXTRA_MAX].\n+\n+   If EXTRA_RANGE_P is set upon return, EXTRA_MIN/EXTRA_MAX hold\n+   meaningful information, otherwise they should be ignored.\n+\n+   Return TRUE if we were able to successfully calculate the new range.  */\n+\n+bool\n+wide_int_range_div (wide_int &wmin, wide_int &wmax,\n+\t\t    tree_code code, signop sign, unsigned prec,\n+\t\t    const wide_int &dividend_min, const wide_int &dividend_max,\n+\t\t    const wide_int &divisor_min, const wide_int &divisor_max,\n+\t\t    bool overflow_undefined,\n+\t\t    bool overflow_wraps,\n+\t\t    bool &extra_range_p,\n+\t\t    wide_int &extra_min, wide_int &extra_max)\n+{\n+  extra_range_p = false;\n+\n+  /* If we know we won't divide by zero, just do the division.  */\n+  if (!wide_int_range_includes_zero_p (divisor_min, divisor_max, sign))\n+    {\n+      wide_int_range_multiplicative_op (wmin, wmax, code, sign, prec,\n+\t\t\t\t\tdividend_min, dividend_max,\n+\t\t\t\t\tdivisor_min, divisor_max,\n+\t\t\t\t\toverflow_undefined,\n+\t\t\t\t\toverflow_wraps);\n+      return true;\n+    }\n+\n+  /* If flag_non_call_exceptions, we must not eliminate a division\n+     by zero.  */\n+  if (cfun->can_throw_non_call_exceptions)\n+    return false;\n+\n+  /* If we're definitely dividing by zero, there's nothing to do.  */\n+  if (wide_int_range_zero_p (divisor_min, divisor_max, prec))\n+    return false;\n+\n+  /* Perform the division in 2 parts, [LB, -1] and [1, UB],\n+     which will skip any division by zero.\n+\n+     First divide by the negative numbers, if any.  */\n+  if (wi::neg_p (divisor_min, sign))\n+    {\n+      if (!wide_int_range_multiplicative_op (wmin, wmax,\n+\t\t\t\t\t     code, sign, prec,\n+\t\t\t\t\t     dividend_min, dividend_max,\n+\t\t\t\t\t     divisor_min, wi::minus_one (prec),\n+\t\t\t\t\t     overflow_undefined,\n+\t\t\t\t\t     overflow_wraps))\n+\treturn false;\n+      extra_range_p = true;\n+    }\n+  /* Then divide by the non-zero positive numbers, if any.  */\n+  if (wi::gt_p (divisor_max, wi::zero (prec), sign))\n+    {\n+      if (!wide_int_range_multiplicative_op (extra_range_p ? extra_min : wmin,\n+\t\t\t\t\t     extra_range_p ? extra_max : wmax,\n+\t\t\t\t\t     code, sign, prec,\n+\t\t\t\t\t     dividend_min, dividend_max,\n+\t\t\t\t\t     wi::one (prec), divisor_max,\n+\t\t\t\t\t     overflow_undefined,\n+\t\t\t\t\t     overflow_wraps))\n+\treturn false;\n+    }\n+  else\n+    extra_range_p = false;\n+  return true;\n+}"}, {"sha": "427ef34c6b4bb2f1943dad5ca58b8c4561c49568", "filename": "gcc/wide-int-range.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62852194225ed2df31ff6a600659e5cefbb1e8c0/gcc%2Fwide-int-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62852194225ed2df31ff6a600659e5cefbb1e8c0/gcc%2Fwide-int-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int-range.h?ref=62852194225ed2df31ff6a600659e5cefbb1e8c0", "patch": "@@ -99,6 +99,17 @@ extern bool wide_int_range_abs (wide_int &min, wide_int &max,\n \t\t\t\tconst wide_int &vr0_min,\n \t\t\t\tconst wide_int &vr0_max,\n \t\t\t\tbool overflow_undefined);\n+extern bool wide_int_range_div (wide_int &wmin, wide_int &wmax,\n+\t\t\t\tenum tree_code code,\n+\t\t\t\tsignop sign, unsigned prec,\n+\t\t\t\tconst wide_int &dividend_min,\n+\t\t\t\tconst wide_int &dividend_max,\n+\t\t\t\tconst wide_int &divisor_min,\n+\t\t\t\tconst wide_int &divisor_max,\n+\t\t\t\tbool overflow_undefined,\n+\t\t\t\tbool overflow_wraps,\n+\t\t\t\tbool &extra_range_p,\n+\t\t\t\twide_int &extra_min, wide_int &extra_max);\n \n /* Return TRUE if shifting by range [MIN, MAX] is undefined behavior.  */\n \n@@ -137,4 +148,22 @@ wide_int_range_min_max (wide_int &min, wide_int &max,\n   return true;\n }\n \n+/* Return TRUE if 0 is within [WMIN, WMAX].  */\n+\n+inline bool\n+wide_int_range_includes_zero_p (const wide_int &wmin, const wide_int &wmax,\n+\t\t\t\tsignop sign)\n+{\n+  return wi::le_p (wmin, 0, sign) && wi::ge_p (wmax, 0, sign);\n+}\n+\n+/* Return TRUE if [WMIN, WMAX] is the singleton 0.  */\n+\n+inline bool\n+wide_int_range_zero_p (const wide_int &wmin, const wide_int &wmax,\n+\t\t       unsigned prec)\n+{\n+  return wmin == wmax && wi::eq_p (wmin, wi::zero (prec));\n+}\n+\n #endif /* GCC_WIDE_INT_RANGE_H */"}]}