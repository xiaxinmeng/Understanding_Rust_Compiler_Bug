{"sha": "b4934671aed067e0a8c3ac3fcc5871dd27a706ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ5MzQ2NzFhZWQwNjdlMGE4YzNhYzNmY2M1ODcxZGQyN2E3MDZlZA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2016-01-11T10:40:33Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2016-01-11T10:40:33Z"}, "message": "[PR69123] fix handling of MEMs in VTA to avoid dataflow oscillation\n\nThe problem arises because we used to drop overwritten MEMs from loc\nlists of VALUEs, but not of other onepart variables, and it just so\nhappens that, by doing so, block 6 in the testcase has no D#5 in its\noutput in the first pass, because the MEM holding its (previous) value\nwas correctly dropped from value 88:88, but gains it in the second\npass because D#5 has the MEM location incoming directly in its loc\nlist, rather than indirectly in a VALUE.\n\nThis incorrect binding enables other blocks to believe they have a\ntentative binding for D#5 in some cycles, but others, still operating\non the early conclusion, believe there isn't, and they oscillate from\nthat.\n\nSince we check for escaping MEMs in clobbers, we won't lose anything\nrelevant by dropping call-clobbered or overwritten MEMs in all onepart\nvariables, and this ensures the loc intersection operation in onepart\nvars won't let a MEM through that wasn't present in earlier\niterations.\n\nfor  gcc/ChangeLog\n\n\tPR bootstrap/69123\n\t* var-tracking.c (drop_overlapping_mem_locs): Operate on all\n\tonepart vars.  Fix typo in comment.  Fix reversed condition in\n\tunshare test.\n\t(dataflow_set_remove_mem_locs): Operate on all onepart vars.\n\nfor gcc/testsuite/ChangeLog\n\n\tPR bootstrap/69123\n\t* g++.dg/pr69123.C: New.\n\nFrom-SVN: r232218", "tree": {"sha": "f256be24de028f3ba0f7322f307659ce87652c96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f256be24de028f3ba0f7322f307659ce87652c96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4934671aed067e0a8c3ac3fcc5871dd27a706ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4934671aed067e0a8c3ac3fcc5871dd27a706ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4934671aed067e0a8c3ac3fcc5871dd27a706ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4934671aed067e0a8c3ac3fcc5871dd27a706ed/comments", "author": null, "committer": null, "parents": [{"sha": "4708731cceffa32a0bcddb8300147369299c4361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4708731cceffa32a0bcddb8300147369299c4361", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4708731cceffa32a0bcddb8300147369299c4361"}], "stats": {"total": 118, "additions": 112, "deletions": 6}, "files": [{"sha": "71aac8e89c97cc1ab72b84967d4a616be7fe05d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4934671aed067e0a8c3ac3fcc5871dd27a706ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4934671aed067e0a8c3ac3fcc5871dd27a706ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4934671aed067e0a8c3ac3fcc5871dd27a706ed", "patch": "@@ -1,5 +1,11 @@\n 2016-01-11  Alexandre Oliva <aoliva@redhat.com>\n \n+\tPR bootstrap/69123\n+\t* var-tracking.c (drop_overlapping_mem_locs): Operate on all\n+\tonepart vars.  Fix typo in comment.  Fix reversed condition in\n+\tunshare test.\n+\t(dataflow_set_remove_mem_locs): Operate on all onepart vars.\n+\n \tPR bootstrap/69123\n \t* var-tracking.c (dump_onepart_variable_differences): New.\n \t(dataflow_set_different): If a detailed dump is requested,"}, {"sha": "7095b45d12efcbc52df173efa26640fbfe6323c6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4934671aed067e0a8c3ac3fcc5871dd27a706ed/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4934671aed067e0a8c3ac3fcc5871dd27a706ed/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b4934671aed067e0a8c3ac3fcc5871dd27a706ed", "patch": "@@ -1,3 +1,8 @@\n+2016-01-11  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR bootstrap/69123\n+\t* g++.dg/pr69123.C: New.\n+\n 2016-01-11  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \tPR target/69010"}, {"sha": "0546e2074a5390a483d351a55831b383bc453c30", "filename": "gcc/testsuite/g++.dg/pr69123.C", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4934671aed067e0a8c3ac3fcc5871dd27a706ed/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr69123.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4934671aed067e0a8c3ac3fcc5871dd27a706ed/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr69123.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr69123.C?ref=b4934671aed067e0a8c3ac3fcc5871dd27a706ed", "patch": "@@ -0,0 +1,95 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -g\" } */\n+\n+/* This was reduced from gcc/tree-vect-slp.c by H.J.Lu.  */\n+\n+struct xxx_def;\n+typedef xxx_def *xxx;\n+\n+union rtxxx\n+{\n+  const char *rt_str;\n+  xxx rt_xxx;\n+};\n+\n+struct xxx_def {\n+  union u {\n+    rtxxx fld[1];\n+  } u;\n+};\n+\n+extern xxx bar (void);\n+extern int foo1 (xxx);\n+\n+static inline xxx\n+foo2 (xxx arg0, xxx arg1)\n+{\n+  xxx rt;\n+  rt = bar ();\n+  (((rt)->u.fld[0]).rt_xxx) = arg0;\n+  (((rt)->u.fld[1]).rt_xxx) = arg1;\n+  return rt;\n+}\n+\n+static inline xxx\n+foo4 (const char *arg0 )\n+{\n+  xxx rt;\n+  rt = bar ();\n+  (((rt)->u.fld[0]).rt_str) = arg0;\n+  (((rt)->u.fld[1]).rt_xxx) = (xxx) 0;\n+  return rt;\n+}\n+\n+extern xxx foo5 (long);\n+\n+struct address_cost_data\n+{\n+  unsigned costs[2][2][2][2];\n+};\n+\n+void\n+get_address_cost (address_cost_data *data)\n+{\n+  unsigned acost;\n+  long i;\n+  long rat, off = 0;\n+  unsigned sym_p, var_p, off_p, rat_p;\n+  xxx addr, base;\n+  xxx reg0, reg1;\n+\n+  reg1 = bar ();\n+  addr = foo2 (reg1, (xxx) 0);\n+  rat = 1;\n+  acost = 0;\n+  reg0 = bar ();\n+  reg1 = bar ();\n+\n+  for (i = 0; i < 16; i++)\n+    {\n+      sym_p = i & 1;\n+      var_p = (i >> 1) & 1;\n+      off_p = (i >> 2) & 1;\n+      rat_p = (i >> 3) & 1;\n+\n+      addr = reg0;\n+      if (rat_p)\n+\taddr = foo2 (addr, foo5 (rat)) ;\n+\n+      if (var_p)\n+\taddr = foo2 (addr, reg1);\n+\n+      if (sym_p)\n+\tbase = foo4 (\"\");\n+      else if (off_p)\n+\tbase = foo5 (off);\n+      else\n+\tbase = (xxx) 0;\n+\n+      if (base)\n+\taddr = foo2 (addr, base);\n+\n+      acost = foo1 (addr);\n+      data->costs[sym_p][var_p][off_p][rat_p] = acost;\n+    }\n+}"}, {"sha": "86183b3f0cd7cf7ad5e855125e6b0569edeecdc7", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4934671aed067e0a8c3ac3fcc5871dd27a706ed/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4934671aed067e0a8c3ac3fcc5871dd27a706ed/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=b4934671aed067e0a8c3ac3fcc5871dd27a706ed", "patch": "@@ -2224,7 +2224,7 @@ struct overlapping_mems\n };\n \n /* Remove all MEMs that overlap with COMS->LOC from the location list\n-   of a hash table entry for a value.  COMS->ADDR must be a\n+   of a hash table entry for a onepart variable.  COMS->ADDR must be a\n    canonicalized form of COMS->LOC's address, and COMS->LOC must be\n    canonicalized itself.  */\n \n@@ -2235,7 +2235,7 @@ drop_overlapping_mem_locs (variable **slot, overlapping_mems *coms)\n   rtx mloc = coms->loc, addr = coms->addr;\n   variable *var = *slot;\n \n-  if (var->onepart == ONEPART_VALUE)\n+  if (var->onepart != NOT_ONEPART)\n     {\n       location_chain *loc, **locp;\n       bool changed = false;\n@@ -4682,11 +4682,11 @@ dataflow_set_preserve_mem_locs (variable **slot, dataflow_set *set)\n \t{\n \t  for (loc = var->var_part[0].loc_chain; loc; loc = loc->next)\n \t    {\n-\t      /* We want to remove dying MEMs that doesn't refer to DECL.  */\n+\t      /* We want to remove dying MEMs that don't refer to DECL.  */\n \t      if (GET_CODE (loc->loc) == MEM\n \t\t  && (MEM_EXPR (loc->loc) != decl\n \t\t      || INT_MEM_OFFSET (loc->loc) != 0)\n-\t\t  && !mem_dies_at_call (loc->loc))\n+\t\t  && mem_dies_at_call (loc->loc))\n \t\tbreak;\n \t      /* We want to move here MEMs that do refer to DECL.  */\n \t      else if (GET_CODE (loc->loc) == VALUE\n@@ -4769,14 +4769,14 @@ dataflow_set_preserve_mem_locs (variable **slot, dataflow_set *set)\n }\n \n /* Remove all MEMs from the location list of a hash table entry for a\n-   value.  */\n+   onepart variable.  */\n \n int\n dataflow_set_remove_mem_locs (variable **slot, dataflow_set *set)\n {\n   variable *var = *slot;\n \n-  if (var->onepart == ONEPART_VALUE)\n+  if (var->onepart != NOT_ONEPART)\n     {\n       location_chain *loc, **locp;\n       bool changed = false;"}]}