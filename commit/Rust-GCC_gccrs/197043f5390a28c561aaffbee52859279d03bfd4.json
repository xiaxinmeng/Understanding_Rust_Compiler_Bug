{"sha": "197043f5390a28c561aaffbee52859279d03bfd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk3MDQzZjUzOTBhMjhjNTYxYWFmZmJlZTUyODU5Mjc5ZDAzYmZkNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-07-21T01:15:47Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-07-21T01:15:47Z"}, "message": "haifa-sched.c (insn_cost): FREE implies cost 0 and vice versa.\n\n        * haifa-sched.c (insn_cost): FREE implies cost 0 and vice versa.\n        (adjust_priority): Always call ADJUST_PRIORITY.\n        (schedule_insn): Only put insns into the ready at cost 0.\n        (schedule_block): Remove redundant initial sort.  Give clock_var\n        and can_issue_more to MD_SCHED_REORDER.  Requeue if hazard cost\n        is not 0.\n        * tm.texi (MD_SCHED_REORDER): Update docs.\n\n        * sparc.h (MD_SCHED_REORDER): Update.  Set CAN_ISSUE_MORE.\n        * sparc.c (ultra_reorder_called_this_block): Delete.\n        (ultrasparc_sched_init): Don't set it.\n        (ultrasparc_sched_reorder): Don't check it.\n\nFrom-SVN: r28201", "tree": {"sha": "56e6b845eb55c0c9c095d807ea1c678349ac5184", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56e6b845eb55c0c9c095d807ea1c678349ac5184"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/197043f5390a28c561aaffbee52859279d03bfd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/197043f5390a28c561aaffbee52859279d03bfd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/197043f5390a28c561aaffbee52859279d03bfd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/197043f5390a28c561aaffbee52859279d03bfd4/comments", "author": null, "committer": null, "parents": [{"sha": "03a6745b8b745131f1ee72141258a67de7d79c5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03a6745b8b745131f1ee72141258a67de7d79c5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03a6745b8b745131f1ee72141258a67de7d79c5b"}], "stats": {"total": 246, "additions": 124, "deletions": 122}, "files": [{"sha": "17a4ab6dfcc427645527db3cd975a1309c089490", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197043f5390a28c561aaffbee52859279d03bfd4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197043f5390a28c561aaffbee52859279d03bfd4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=197043f5390a28c561aaffbee52859279d03bfd4", "patch": "@@ -1,3 +1,18 @@\n+Tue Jul 20 18:02:42 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* haifa-sched.c (insn_cost): FREE implies cost 0 and vice versa.\n+\t(adjust_priority): Always call ADJUST_PRIORITY.\n+\t(schedule_insn): Only put insns into the ready at cost 0.\n+\t(schedule_block): Remove redundant initial sort.  Give clock_var\n+\tand can_issue_more to MD_SCHED_REORDER.  Requeue if hazard cost\n+\tis not 0.\n+\t* tm.texi (MD_SCHED_REORDER): Update docs.\n+\n+\t* sparc.h (MD_SCHED_REORDER): Update.  Set CAN_ISSUE_MORE.\n+\t* sparc.c (ultra_reorder_called_this_block): Delete.\n+\t(ultrasparc_sched_init): Don't set it.\n+\t(ultrasparc_sched_reorder): Don't check it.\n+\t\n Tue Jul 20 17:07:54 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* rs6000.h (struct rs6000_args): Add sysv_gregno."}, {"sha": "e38d71adf9a20b4ff193539105be90980c93ae4f", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197043f5390a28c561aaffbee52859279d03bfd4/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197043f5390a28c561aaffbee52859279d03bfd4/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=197043f5390a28c561aaffbee52859279d03bfd4", "patch": "@@ -6879,8 +6879,6 @@ ultra_flush_pipeline ()\n   ultra_pipe.free_slot_mask = 0xf;\n }\n \n-static int ultra_reorder_called_this_block;\n-\n /* Init our data structures for this current block.  */\n void\n ultrasparc_sched_init (dump, sched_verbose)\n@@ -6890,7 +6888,6 @@ ultrasparc_sched_init (dump, sched_verbose)\n   bzero ((char *) ultra_pipe_hist, sizeof ultra_pipe_hist);\n   ultra_cur_hist = 0;\n   ultra_cycles_elapsed = 0;\n-  ultra_reorder_called_this_block = 0;\n   ultra_pipe.free_slot_mask = 0xf;\n }\n \n@@ -6980,14 +6977,6 @@ ultrasparc_sched_reorder (dump, sched_verbose, ready, n_ready)\n   struct ultrasparc_pipeline_state *up = &ultra_pipe;\n   int i, this_insn;\n \n-  /* We get called once unnecessarily per block of insns\n-     scheduled.  */\n-  if (ultra_reorder_called_this_block == 0)\n-    {\n-      ultra_reorder_called_this_block = 1;\n-      return;\n-    }\n-\n   if (sched_verbose)\n     {\n       int n;"}, {"sha": "f75437b8fe1c3dfc449cb893ac60e3f57cfa1fc4", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197043f5390a28c561aaffbee52859279d03bfd4/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197043f5390a28c561aaffbee52859279d03bfd4/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=197043f5390a28c561aaffbee52859279d03bfd4", "patch": "@@ -2702,21 +2702,28 @@ extern int ultrasparc_variable_issue ();\n   if (sparc_cpu == PROCESSOR_ULTRASPARC)\t\t\t\t\\\n     ultrasparc_sched_init (DUMP, SCHED_VERBOSE)\n \n-#define MD_SCHED_REORDER(DUMP, SCHED_VERBOSE, READY, N_READY)\t\t\\\n+#define MD_SCHED_REORDER(DUMP, SCHED_VERBOSE, READY, N_READY, CLOCK, CIM) \\\n+do {\t\t\t\t\t\t\t\t\t\\\n   if (sparc_cpu == PROCESSOR_ULTRASPARC)\t\t\t\t\\\n-    ultrasparc_sched_reorder (DUMP, SCHED_VERBOSE, READY, N_READY)\n+    ultrasparc_sched_reorder (DUMP, SCHED_VERBOSE, READY, N_READY);\t\\\n+  CIM = issue_rate;\t\t\t\t\t\t\t\\\n+} while (0)\n \n #define MD_SCHED_VARIABLE_ISSUE(DUMP, SCHED_VERBOSE, INSN, CAN_ISSUE_MORE) \\\n-  if (sparc_cpu == PROCESSOR_ULTRASPARC)\t\t\t\\\n-    (CAN_ISSUE_MORE) = ultrasparc_variable_issue (INSN);\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    (CAN_ISSUE_MORE)--\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (sparc_cpu == PROCESSOR_ULTRASPARC)\t\t\t\t\\\n+    (CAN_ISSUE_MORE) = ultrasparc_variable_issue (INSN);\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    (CAN_ISSUE_MORE)--;\t\t\t\t\t\t\t\\\n+} while (0)\n \n /* Conditional branches with empty delay slots have a length of two.  */\n #define ADJUST_INSN_LENGTH(INSN, LENGTH)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n   if (GET_CODE (INSN) == CALL_INSN\t\t\t\t\t\\\n       || (GET_CODE (INSN) == JUMP_INSN && ! simplejump_p (insn)))\t\\\n-    LENGTH += 1; else\n+    LENGTH += 1;\t\t\t\t\t\t\t\\\n+} while (0)\n \f\n /* Control the assembler format that we output.  */\n "}, {"sha": "9325f61e19dfd2c5f6b4112f53458aab7555ac9c", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 89, "deletions": 102, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197043f5390a28c561aaffbee52859279d03bfd4/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197043f5390a28c561aaffbee52859279d03bfd4/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=197043f5390a28c561aaffbee52859279d03bfd4", "patch": "@@ -3147,15 +3147,18 @@ insn_cost (insn, link, used)\n      and LINK_COST_ZERO.  */\n \n   if (LINK_COST_FREE (link))\n-    cost = 1;\n+    cost = 0;\n #ifdef ADJUST_COST\n   else if (!LINK_COST_ZERO (link))\n     {\n       int ncost = cost;\n \n       ADJUST_COST (used, link, insn, ncost);\n-      if (ncost <= 1)\n-\tLINK_COST_FREE (link) = ncost = 1;\n+      if (ncost < 1)\n+\t{\n+\t  LINK_COST_FREE (link) = 1;\n+\t  ncost = 0;\n+\t}\n       if (cost == ncost)\n \tLINK_COST_ZERO (link) = 1;\n       cost = ncost;\n@@ -4362,10 +4365,13 @@ adjust_priority (prev)\n \t    }\n \t  break;\n \t}\n+    }\n+\n+  /* That said, a target might have it's own reasons for adjusting\n+     priority after reload.  */\n #ifdef ADJUST_PRIORITY\n-      ADJUST_PRIORITY (prev);\n+  ADJUST_PRIORITY (prev);\n #endif\n-    }\n }\n \n /* Clock at which the previous instruction was issued.  */\n@@ -4439,7 +4445,7 @@ schedule_insn (insn, ready, n_ready, clock)\n \t      if (current_nr_blocks > 1 && INSN_BB (next) != target_bb)\n \t\tfprintf (dump, \"/b%d \", INSN_BLOCK (next));\n \n-\t      if (effective_cost <= 1)\n+\t      if (effective_cost < 1)\n \t\tfprintf (dump, \"into ready\\n\");\n \t      else\n \t\tfprintf (dump, \"into queue with cost=%d\\n\", effective_cost);\n@@ -4448,7 +4454,7 @@ schedule_insn (insn, ready, n_ready, clock)\n \t  /* Adjust the priority of NEXT and either put it on the ready\n \t     list or queue it.  */\n \t  adjust_priority (next);\n-\t  if (effective_cost <= 1)\n+\t  if (effective_cost < 1)\n \t    ready[n_ready++] = next;\n \t  else\n \t    queue_insn (next, effective_cost);\n@@ -6675,7 +6681,6 @@ schedule_block (bb, rgn_n_insns)\n   /* Local variables.  */\n   rtx insn, last;\n   rtx *ready;\n-  int i;\n   int n_ready = 0;\n   int can_issue_more;\n \n@@ -6857,25 +6862,15 @@ schedule_block (bb, rgn_n_insns)\n   /* no insns scheduled in this block yet */\n   last_scheduled_insn = 0;\n \n-  /* Sort the ready list */\n-  SCHED_SORT (ready, n_ready);\n-#ifdef MD_SCHED_REORDER\n-  MD_SCHED_REORDER (dump, sched_verbose, ready, n_ready);\n-#endif\n-\n-  if (sched_verbose >= 2)\n-    {\n-      fprintf (dump, \";;\\t\\tReady list initially:             \");\n-      debug_ready_list (ready, n_ready);\n-    }\n-\n   /* Q_SIZE is the total number of insns in the queue.  */\n   q_ptr = 0;\n   q_size = 0;\n-  clock_var = 0;\n   last_clock_var = 0;\n   bzero ((char *) insn_queue, sizeof (insn_queue));\n \n+  /* Start just before the beginning of time.  */\n+  clock_var = -1;\n+\n   /* We start inserting insns after PREV_HEAD.  */\n   last = prev_head;\n \n@@ -6907,10 +6902,16 @@ schedule_block (bb, rgn_n_insns)\n \t  debug_ready_list (ready, n_ready);\n \t}\n \n-      /* Sort the ready list.  */\n+      /* Sort the ready list based on priority.  */\n       SCHED_SORT (ready, n_ready);\n+\n+      /* Allow the target to reorder the list, typically for \n+\t better instruction bundling.  */\n #ifdef MD_SCHED_REORDER\n-      MD_SCHED_REORDER (dump, sched_verbose, ready, n_ready);\n+      MD_SCHED_REORDER (dump, sched_verbose, ready, n_ready, clock_var,\n+\t\t\tcan_issue_more);\n+#else\n+      can_issue_more = issue_rate;\n #endif\n \n       if (sched_verbose)\n@@ -6919,110 +6920,96 @@ schedule_block (bb, rgn_n_insns)\n \t  debug_ready_list (ready, n_ready);\n \t}\n \n-      /* Issue insns from ready list.\n-         It is important to count down from n_ready, because n_ready may change\n-         as insns are issued.  */\n-      can_issue_more = issue_rate;\n-      for (i = n_ready - 1; i >= 0 && can_issue_more; i--)\n+      /* Issue insns from ready list.  */\n+      while (n_ready != 0 && can_issue_more)\n \t{\n-\t  rtx insn = ready[i];\n+\t  /* Select and remove the insn from the ready list.  */\n+\t  rtx insn = ready[--n_ready];\n \t  int cost = actual_hazard (insn_unit (insn), insn, clock_var, 0);\n \n-\t  if (cost > 1)\n+\t  if (cost >= 1)\n \t    {\n \t      queue_insn (insn, cost);\n-\t      ready[i] = ready[--n_ready];\t/* remove insn from ready list */\n+\t      continue;\n \t    }\n-\t  else if (cost == 0)\n-\t    {\n-\t      /* an interblock motion? */\n-\t      if (INSN_BB (insn) != target_bb)\n-\t\t{\n-\t\t  rtx temp;\n \n-\t\t  if (IS_SPECULATIVE_INSN (insn))\n-\t\t    {\n+\t  /* An interblock motion?  */\n+\t  if (INSN_BB (insn) != target_bb)\n+\t    {\n+\t      rtx temp;\n \n-\t\t      if (!check_live (insn, INSN_BB (insn)))\n-\t\t\t{\n-\t\t\t  /* speculative motion, live check failed, remove\n-\t\t\t     insn from ready list */\n-\t\t\t  ready[i] = ready[--n_ready];\n-\t\t\t  continue;\n-\t\t\t}\n-\t\t      update_live (insn, INSN_BB (insn));\n+\t      if (IS_SPECULATIVE_INSN (insn))\n+\t\t{\n+\t\t  if (!check_live (insn, INSN_BB (insn)))\n+\t\t    continue;\n+\t\t  update_live (insn, INSN_BB (insn));\n \n-\t\t      /* for speculative load, mark insns fed by it.  */\n-\t\t      if (IS_LOAD_INSN (insn) || FED_BY_SPEC_LOAD (insn))\n-\t\t\tset_spec_fed (insn);\n+\t\t  /* For speculative load, mark insns fed by it.  */\n+\t\t  if (IS_LOAD_INSN (insn) || FED_BY_SPEC_LOAD (insn))\n+\t\t    set_spec_fed (insn);\n \n-\t\t      nr_spec++;\n-\t\t    }\n-\t\t  nr_inter++;\n+\t\t  nr_spec++;\n+\t\t}\n+\t      nr_inter++;\n \n-\t\t  temp = insn;\n-\t\t  while (SCHED_GROUP_P (temp))\n-\t\t    temp = PREV_INSN (temp);\n+\t      temp = insn;\n+\t      while (SCHED_GROUP_P (temp))\n+\t\ttemp = PREV_INSN (temp);\n \n-\t\t  /* Update source block boundaries.   */\n-\t\t  b1 = INSN_BLOCK (temp);\n-\t\t  if (temp == BLOCK_HEAD (b1)\n-\t\t      && insn == BLOCK_END (b1))\n-\t\t    {\n-\t\t      /* We moved all the insns in the basic block.\n-\t\t\t Emit a note after the last insn and update the\n-\t\t\t begin/end boundaries to point to the note.  */\n-\t\t      emit_note_after (NOTE_INSN_DELETED, insn);\n-\t\t      BLOCK_END (b1) = NEXT_INSN (insn);\n-\t\t      BLOCK_HEAD (b1) = NEXT_INSN (insn);\n-\t\t    }\n-\t\t  else if (insn == BLOCK_END (b1))\n-\t\t    {\n-\t\t      /* We took insns from the end of the basic block,\n-\t\t\t so update the end of block boundary so that it\n-\t\t\t points to the first insn we did not move.  */\n-\t\t      BLOCK_END (b1) = PREV_INSN (temp);\n-\t\t    }\n-\t\t  else if (temp == BLOCK_HEAD (b1))\n-\t\t    {\n-\t\t      /* We took insns from the start of the basic block,\n-\t\t\t so update the start of block boundary so that\n-\t\t\t it points to the first insn we did not move.  */\n-\t\t      BLOCK_HEAD (b1) = NEXT_INSN (insn);\n-\t\t    }\n+\t      /* Update source block boundaries.   */\n+\t      b1 = INSN_BLOCK (temp);\n+\t      if (temp == BLOCK_HEAD (b1)\n+\t\t  && insn == BLOCK_END (b1))\n+\t\t{\n+\t\t  /* We moved all the insns in the basic block.\n+\t\t     Emit a note after the last insn and update the\n+\t\t     begin/end boundaries to point to the note.  */\n+\t\t  emit_note_after (NOTE_INSN_DELETED, insn);\n+\t\t  BLOCK_END (b1) = NEXT_INSN (insn);\n+\t\t  BLOCK_HEAD (b1) = NEXT_INSN (insn);\n \t\t}\n-\t      else\n+\t      else if (insn == BLOCK_END (b1))\n \t\t{\n-\t\t  /* in block motion */\n-\t\t  sched_target_n_insns++;\n+\t\t  /* We took insns from the end of the basic block,\n+\t\t     so update the end of block boundary so that it\n+\t\t     points to the first insn we did not move.  */\n+\t\t  BLOCK_END (b1) = PREV_INSN (temp);\n \t\t}\n+\t      else if (temp == BLOCK_HEAD (b1))\n+\t\t{\n+\t\t  /* We took insns from the start of the basic block,\n+\t\t     so update the start of block boundary so that\n+\t\t     it points to the first insn we did not move.  */\n+\t\t  BLOCK_HEAD (b1) = NEXT_INSN (insn);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* In block motion.  */\n+\t      sched_target_n_insns++;\n+\t    }\n \n-\t      last_scheduled_insn = insn;\n-\t      last = move_insn (insn, last);\n-\t      sched_n_insns++;\n+\t  last_scheduled_insn = insn;\n+\t  last = move_insn (insn, last);\n+\t  sched_n_insns++;\n \n #ifdef MD_SCHED_VARIABLE_ISSUE\n-\t      MD_SCHED_VARIABLE_ISSUE (dump, sched_verbose, insn, can_issue_more);\n+\t  MD_SCHED_VARIABLE_ISSUE (dump, sched_verbose, insn,\n+\t\t\t\t   can_issue_more);\n #else\n-\t      can_issue_more--;\n+\t  can_issue_more--;\n #endif\n \n-\t      n_ready = schedule_insn (insn, ready, n_ready, clock_var);\n+\t  n_ready = schedule_insn (insn, ready, n_ready, clock_var);\n \n-\t      /* remove insn from ready list */\n-\t      ready[i] = ready[--n_ready];\n-\n-\t      /* close this block after scheduling its jump */\n-\t      if (GET_CODE (last_scheduled_insn) == JUMP_INSN)\n-\t\tbreak;\n-\t    }\n+\t  /* Close this block after scheduling its jump.  */\n+\t  if (GET_CODE (last_scheduled_insn) == JUMP_INSN)\n+\t    break;\n \t}\n \n-      /* debug info */\n+      /* Debug info.  */\n       if (sched_verbose)\n-\t{\n-\t  visualize_scheduled_insns (b, clock_var);\n-\t}\n+\tvisualize_scheduled_insns (b, clock_var);\n     }\n \n   /* debug info */"}, {"sha": "28fefa847c4b1f2dd00a8a92c1157b2ea97440e6", "filename": "gcc/tm.texi", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197043f5390a28c561aaffbee52859279d03bfd4/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197043f5390a28c561aaffbee52859279d03bfd4/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=197043f5390a28c561aaffbee52859279d03bfd4", "patch": "@@ -7656,7 +7656,8 @@ debug output to.  @var{verbose} is the verbose level provided by\n @samp{-fsched-verbose-}@var{n}.\n \n @findex MD_SCHED_REORDER\n-@item MD_SCHED_REORDER (@var{file}, @var{verbose}, @var{ready}, @var{n_ready})\n+@item MD_SCHED_REORDER (@var{file}, @var{verbose}, @var{ready}, @var{n_ready},\n+\t\t\t@var{clock}, @var{can_issue_more})\n A C statement which is executed by the @samp{Haifa} scheduler after it\n has scheduled the ready list to allow the machine description to reorder\n it (for example to combine two small instructions together on\n@@ -7666,7 +7667,10 @@ provided by @samp{-fsched-verbose-}@var{n}.  @var{ready} is a pointer to\n the ready list of instructions that are ready to be scheduled.\n @var{n_ready} is the number of elements in the ready list.  The\n scheduler reads the ready list in reverse order, starting with\n-@var{ready}[@var{n_ready}-1] and going to @var{ready}[0].\n+@var{ready}[@var{n_ready}-1] and going to @var{ready}[0].  @var{clock}\n+is the timer tick of the scheduler.  @var{can_issue_more} is an output\n+parameter that is set to the number of insns that can issue this clock;\n+normally this is just @code{issue_rate}.\n \n @findex MD_SCHED_VARIABLE_ISSUE\n @item MD_SCHED_VARIABLE_ISSUE (@var{file}, @var{verbose}, @var{insn}, @var{more})"}]}