{"sha": "3954ead0d88676855e877a8a20c05f49256260d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk1NGVhZDBkODg2NzY4NTVlODc3YThhMjBjMDVmNDkyNTYyNjBkNw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2015-04-28T03:47:19Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2015-04-28T03:47:19Z"}, "message": "re PR target/65810 (powerpc64 alignment of r2 insufficient for loading long-double constants)\n\n\tPR target/65810\n\t* config/rs6000/rs6000.c (POWERPC64_TOC_POINTER_ALIGNMENT): Define.\n\t(offsettable_ok_by_alignment): Use minimum of decl and toc\n\tpointer alignment.  Replace dead code with assertion.\n\t(use_toc_relative_ref): Add mode arg.  Return false in -mcmodel=medium\n\tcase if size exceeds toc pointer alignment.\n\t(rs6000_legitimize_reload_address): Update use_toc_relative_ref call.\n\t(rs6000_emit_move): Likewise.\n\t* configure.ac: Add linker toc pointer alignment check.\n\t* configure: Regenerate.\n\t* config.in: Regenerate.\n\nFrom-SVN: r222498", "tree": {"sha": "a4a4eb35291c72c4e8e3667ec61ef8760b899aa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4a4eb35291c72c4e8e3667ec61ef8760b899aa6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3954ead0d88676855e877a8a20c05f49256260d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3954ead0d88676855e877a8a20c05f49256260d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3954ead0d88676855e877a8a20c05f49256260d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3954ead0d88676855e877a8a20c05f49256260d7/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1a9f259288745633d1cec9991b55c08dfae2669b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a9f259288745633d1cec9991b55c08dfae2669b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a9f259288745633d1cec9991b55c08dfae2669b"}], "stats": {"total": 136, "additions": 103, "deletions": 33}, "files": [{"sha": "fff0015a15fc7a036233d1ad3d9984b6555af56a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3954ead0d88676855e877a8a20c05f49256260d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3954ead0d88676855e877a8a20c05f49256260d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3954ead0d88676855e877a8a20c05f49256260d7", "patch": "@@ -1,3 +1,17 @@\n+2015-04-28  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/65810\n+\t* config/rs6000/rs6000.c (POWERPC64_TOC_POINTER_ALIGNMENT): Define.\n+\t(offsettable_ok_by_alignment): Use minimum of decl and toc\n+\tpointer alignment.  Replace dead code with assertion.\n+\t(use_toc_relative_ref): Add mode arg.  Return false in -mcmodel=medium\n+\tcase if size exceeds toc pointer alignment.\n+\t(rs6000_legitimize_reload_address): Update use_toc_relative_ref call.\n+\t(rs6000_emit_move): Likewise.\n+\t* configure.ac: Add linker toc pointer alignment check.\n+\t* configure: Regenerate.\n+\t* config.in: Regenerate.\n+\n 2015-04-27  Yoshinori Sato <ysato@users.sourceforge.jp>\n \n \t* config.gcc: Add h8300-*-linux."}, {"sha": "231c9abe712bfd244e96d70b8bc200783d1e3450", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3954ead0d88676855e877a8a20c05f49256260d7/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3954ead0d88676855e877a8a20c05f49256260d7/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=3954ead0d88676855e877a8a20c05f49256260d7", "patch": "@@ -1910,6 +1910,12 @@\n #endif\n \n \n+/* Define to .TOC. alignment forced by your linker. */\n+#ifndef USED_FOR_TARGET\n+#undef POWERPC64_TOC_POINTER_ALIGNMENT\n+#endif\n+\n+\n /* Define to PREFIX/include if cpp should also search that directory. */\n #ifndef USED_FOR_TARGET\n #undef PREFIX_INCLUDE_DIR"}, {"sha": "c74c7d14b87da848174ba9a4b83cef9ed1b08f68", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3954ead0d88676855e877a8a20c05f49256260d7/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3954ead0d88676855e877a8a20c05f49256260d7/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=3954ead0d88676855e877a8a20c05f49256260d7", "patch": "@@ -6524,13 +6524,21 @@ virtual_stack_registers_memory_p (rtx op)\n }\n \n /* Return true if a MODE sized memory accesses to OP plus OFFSET\n-   is known to not straddle a 32k boundary.  */\n+   is known to not straddle a 32k boundary.  This function is used\n+   to determine whether -mcmodel=medium code can use TOC pointer\n+   relative addressing for OP.  This means the alignment of the TOC\n+   pointer must also be taken into account, and unfortunately that is\n+   only 8 bytes.  */ \n+\n+#ifndef POWERPC64_TOC_POINTER_ALIGNMENT\n+#define POWERPC64_TOC_POINTER_ALIGNMENT 8\n+#endif\n \n static bool\n offsettable_ok_by_alignment (rtx op, HOST_WIDE_INT offset,\n \t\t\t     machine_mode mode)\n {\n-  tree decl, type;\n+  tree decl;\n   unsigned HOST_WIDE_INT dsize, dalign, lsb, mask;\n \n   if (GET_CODE (op) != SYMBOL_REF)\n@@ -6583,38 +6591,20 @@ offsettable_ok_by_alignment (rtx op, HOST_WIDE_INT offset,\n \t  if (dsize > 32768)\n \t    return false;\n \n-\t  return dalign / BITS_PER_UNIT >= dsize;\n+\t  dalign /= BITS_PER_UNIT;\n+\t  if (dalign > POWERPC64_TOC_POINTER_ALIGNMENT)\n+\t    dalign = POWERPC64_TOC_POINTER_ALIGNMENT;\n+\t  return dalign >= dsize;\n \t}\n     }\n   else\n-    {\n-      type = TREE_TYPE (decl);\n-\n-      dalign = TYPE_ALIGN (type);\n-      if (CONSTANT_CLASS_P (decl))\n-\tdalign = CONSTANT_ALIGNMENT (decl, dalign);\n-      else\n-\tdalign = DATA_ALIGNMENT (decl, dalign);\n-\n-      if (dsize == 0)\n-\t{\n-\t  /* BLKmode, check the entire object.  */\n-\t  if (TREE_CODE (decl) == STRING_CST)\n-\t    dsize = TREE_STRING_LENGTH (decl);\n-\t  else if (TYPE_SIZE_UNIT (type)\n-\t\t   && tree_fits_uhwi_p (TYPE_SIZE_UNIT (type)))\n-\t    dsize = tree_to_uhwi (TYPE_SIZE_UNIT (type));\n-\t  else\n-\t    return false;\n-\t  if (dsize > 32768)\n-\t    return false;\n-\n-\t  return dalign / BITS_PER_UNIT >= dsize;\n-\t}\n-    }\n+    gcc_unreachable ();\n \n   /* Find how many bits of the alignment we know for this access.  */\n-  mask = dalign / BITS_PER_UNIT - 1;\n+  dalign /= BITS_PER_UNIT;\n+  if (dalign > POWERPC64_TOC_POINTER_ALIGNMENT)\n+    dalign = POWERPC64_TOC_POINTER_ALIGNMENT;\n+  mask = dalign - 1;\n   lsb = offset & -offset;\n   mask &= lsb - 1;\n   dalign = mask + 1;\n@@ -7553,13 +7543,14 @@ rs6000_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n    can be addressed relative to the toc pointer.  */\n \n static bool\n-use_toc_relative_ref (rtx sym)\n+use_toc_relative_ref (rtx sym, machine_mode mode)\n {\n   return ((constant_pool_expr_p (sym)\n \t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (sym),\n \t\t\t\t\t       get_pool_mode (sym)))\n \t  || (TARGET_CMODEL == CMODEL_MEDIUM\n-\t      && SYMBOL_REF_LOCAL_P (sym)));\n+\t      && SYMBOL_REF_LOCAL_P (sym)\n+\t      && GET_MODE_SIZE (mode) <= POWERPC64_TOC_POINTER_ALIGNMENT));\n }\n \n /* Our implementation of LEGITIMIZE_RELOAD_ADDRESS.  Returns a value to\n@@ -7764,7 +7755,7 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n   if (TARGET_TOC\n       && reg_offset_p\n       && GET_CODE (x) == SYMBOL_REF\n-      && use_toc_relative_ref (x))\n+      && use_toc_relative_ref (x, mode))\n     {\n       x = create_TOC_reference (x, NULL_RTX);\n       if (TARGET_CMODEL != CMODEL_SMALL)\n@@ -8842,7 +8833,7 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \t reference to it.  */\n       if (TARGET_TOC\n \t  && GET_CODE (operands[1]) == SYMBOL_REF\n-\t  && use_toc_relative_ref (operands[1]))\n+\t  && use_toc_relative_ref (operands[1], mode))\n \toperands[1] = create_TOC_reference (operands[1], operands[0]);\n       else if (mode == Pmode\n \t       && CONSTANT_P (operands[1])"}, {"sha": "84f58ce35d2fd7b3e41d3f714bfacfb0c10ad4a7", "filename": "gcc/configure", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3954ead0d88676855e877a8a20c05f49256260d7/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3954ead0d88676855e877a8a20c05f49256260d7/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=3954ead0d88676855e877a8a20c05f49256260d7", "patch": "@@ -27530,6 +27530,40 @@ $as_echo \"$gcc_cv_ld_large_toc\" >&6; }\n \n $as_echo \"#define HAVE_LD_LARGE_TOC 1\" >>confdefs.h\n \n+    fi\n+\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking linker toc pointer alignment\" >&5\n+$as_echo_n \"checking linker toc pointer alignment... \" >&6; }\n+if test \"${gcc_cv_ld_toc_align+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test x$gcc_cv_as != x -a x$gcc_cv_ld != x -a x$gcc_cv_nm != x; then\n+      cat > conftest.s <<EOF\n+\t.global _start\n+\t.text\n+_start:\n+\taddis 9,2,x@got@ha\n+\t.section .data.rel.ro,\"aw\",@progbits\n+\t.p2align 16\n+\t.space 32768\n+x:\t.quad .TOC.\n+EOF\n+      if $gcc_cv_as -a64 -o conftest.o conftest.s > /dev/null 2>&1 \\\n+         && $gcc_cv_ld $emul_name -o conftest conftest.o > /dev/null 2>&1; then\n+        gcc_cv_ld_toc_align=`$gcc_cv_nm conftest | ${AWK} '/\\.TOC\\./ { match ($0, \"0[[:xdigit:]]*\", a); print strtonum (\"0x\" substr(a[0], length(a[0])-3)) }'`\n+      fi\n+      rm -f conftest conftest.o conftest.s\n+    fi\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_ld_toc_align\" >&5\n+$as_echo \"$gcc_cv_ld_toc_align\" >&6; }\n+    if test -n \"$gcc_cv_ld_toc_align\" && test $gcc_cv_ld_toc_align -gt 8; then\n+\n+cat >>confdefs.h <<_ACEOF\n+#define POWERPC64_TOC_POINTER_ALIGNMENT $gcc_cv_ld_toc_align\n+_ACEOF\n+\n     fi\n     ;;\n esac"}, {"sha": "7fb61312f3f7ad468356862824644da06e73ed2d", "filename": "gcc/configure.ac", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3954ead0d88676855e877a8a20c05f49256260d7/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3954ead0d88676855e877a8a20c05f49256260d7/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=3954ead0d88676855e877a8a20c05f49256260d7", "patch": "@@ -5087,6 +5087,31 @@ EOF\n       AC_DEFINE(HAVE_LD_LARGE_TOC, 1,\n     [Define if your PowerPC64 linker supports a large TOC.])\n     fi\n+\n+    AC_CACHE_CHECK(linker toc pointer alignment,\n+    gcc_cv_ld_toc_align,\n+    [if test x$gcc_cv_as != x -a x$gcc_cv_ld != x -a x$gcc_cv_nm != x; then\n+      cat > conftest.s <<EOF\n+\t.global _start\n+\t.text\n+_start:\n+\taddis 9,2,x@got@ha\n+\t.section .data.rel.ro,\"aw\",@progbits\n+\t.p2align 16\n+\t.space 32768\n+x:\t.quad .TOC.\n+EOF\n+      if $gcc_cv_as -a64 -o conftest.o conftest.s > /dev/null 2>&1 \\\n+         && $gcc_cv_ld $emul_name -o conftest conftest.o > /dev/null 2>&1; then\n+        gcc_cv_ld_toc_align=`$gcc_cv_nm conftest | ${AWK} '/\\.TOC\\./ { match ($0, \"0[[[:xdigit:]]]*\", a); print strtonum (\"0x\" substr(a[[0]], length(a[[0]])-3)) }'`\n+      fi\n+      rm -f conftest conftest.o conftest.s\n+    fi\n+    ])\n+    if test -n \"$gcc_cv_ld_toc_align\" && test $gcc_cv_ld_toc_align -gt 8; then\n+      AC_DEFINE_UNQUOTED(POWERPC64_TOC_POINTER_ALIGNMENT, $gcc_cv_ld_toc_align,\n+    [Define to .TOC. alignment forced by your linker.])\n+    fi\n     ;;\n esac\n "}]}