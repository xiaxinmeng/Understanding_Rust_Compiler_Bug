{"sha": "3363daad0cbf860eebb516030084723ce73eb1e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM2M2RhYWQwY2JmODYwZWViYjUxNjAzMDA4NDcyM2NlNzNlYjFlNQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2015-09-01T19:37:52Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2015-09-01T19:37:52Z"}, "message": "re PR target/61578 (Code size increase for ARM thumb compared to 4.8.x when compiling with -Os)\n\n2015-09-01  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/61578\n\t* lra-lives.c (process_bb_lives): Process move pseudos with the\n\tsame value for copies and preferences\n\t* lra-constraints.c (match_reload): Create match reload pseudo\n\twith the same value from single dying input pseudo.\n\nFrom-SVN: r227382", "tree": {"sha": "2d86073d67af59894d4756cb8103bb1ed6470ca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d86073d67af59894d4756cb8103bb1ed6470ca9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3363daad0cbf860eebb516030084723ce73eb1e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3363daad0cbf860eebb516030084723ce73eb1e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3363daad0cbf860eebb516030084723ce73eb1e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3363daad0cbf860eebb516030084723ce73eb1e5/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aef90c1d3dd67054bf1f0ca854b14dcdef5745b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef90c1d3dd67054bf1f0ca854b14dcdef5745b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aef90c1d3dd67054bf1f0ca854b14dcdef5745b8"}], "stats": {"total": 47, "additions": 33, "deletions": 14}, "files": [{"sha": "690e57eb74b2539cc2a28a39cfccca9f6a89f957", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3363daad0cbf860eebb516030084723ce73eb1e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3363daad0cbf860eebb516030084723ce73eb1e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3363daad0cbf860eebb516030084723ce73eb1e5", "patch": "@@ -1,3 +1,11 @@\n+2015-09-01  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/61578\n+\t* lra-lives.c (process_bb_lives): Process move pseudos with the\n+\tsame value for copies and preferences\n+\t* lra-constraints.c (match_reload): Create match reload pseudo\n+\twith the same value from single dying input pseudo.\n+\n 2015-09-01  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \tPR target/67405"}, {"sha": "cdb2695acfa87875de079dc2ed19e21bff99d6fd", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3363daad0cbf860eebb516030084723ce73eb1e5/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3363daad0cbf860eebb516030084723ce73eb1e5/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=3363daad0cbf860eebb516030084723ce73eb1e5", "patch": "@@ -928,10 +928,12 @@ match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n \t they live in the same place.  When we create a pseudo we\n \t assign value of original pseudo (if any) from which we\n \t created the new pseudo.  If we create the pseudo from the\n-\t input pseudo, the new pseudo will no conflict with the input\n-\t pseudo which is wrong when the input pseudo lives after the\n-\t insn and as the new pseudo value is changed by the insn\n-\t output.  Therefore we create the new pseudo from the output.\n+\t input pseudo, the new pseudo will have no conflict with the\n+\t input pseudo which is wrong when the input pseudo lives after\n+\t the insn and as the new pseudo value is changed by the insn\n+\t output.  Therefore we create the new pseudo from the output\n+\t except the case when we have single matched dying input\n+\t pseudo.\n \n \t We cannot reuse the current output register because we might\n \t have a situation like \"a <- a op b\", where the constraints\n@@ -940,8 +942,12 @@ match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n \t so that it doesn't clobber the current value of \"a\".  */\n \n       new_in_reg = new_out_reg\n-\t= lra_create_new_reg_with_unique_value (outmode, out_rtx,\n-\t\t\t\t\t\tgoal_class, \"\");\n+\t= (ins[1] < 0 && REG_P (in_rtx)\n+\t   && (int) REGNO (in_rtx) < lra_new_regno_start\n+\t   && find_regno_note (curr_insn, REG_DEAD, REGNO (in_rtx))\n+\t   ? lra_create_new_reg (inmode, in_rtx, goal_class, \"\")\n+\t   : lra_create_new_reg_with_unique_value (outmode, out_rtx,\n+\t\t\t\t\t\t   goal_class, \"\"));\n     }\n   /* In operand can be got from transformations before processing insn\n      constraints.  One example of such transformations is subreg"}, {"sha": "1da5204da45cb403d90cd5ac0538cac1e0b3797a", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3363daad0cbf860eebb516030084723ce73eb1e5/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3363daad0cbf860eebb516030084723ce73eb1e5/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=3363daad0cbf860eebb516030084723ce73eb1e5", "patch": "@@ -726,28 +726,33 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t  lra_hard_reg_usage[reg->regno] += freq;\n \n       call_p = CALL_P (curr_insn);\n+      src_regno = (set != NULL_RTX && REG_P (SET_SRC (set))\n+\t\t   ? REGNO (SET_SRC (set)) : -1);\n+      dst_regno = (set != NULL_RTX && REG_P (SET_DEST (set))\n+\t\t   ? REGNO (SET_DEST (set)) : -1);\n       if (complete_info_p\n-\t  && set != NULL_RTX\n-\t  && REG_P (SET_DEST (set)) && REG_P (SET_SRC (set))\n+\t  && src_regno >= 0 && dst_regno >= 0\n \t  /* Check that source regno does not conflict with\n \t     destination regno to exclude most impossible\n \t     preferences.  */\n-\t  && ((((src_regno = REGNO (SET_SRC (set))) >= FIRST_PSEUDO_REGISTER\n-\t\t&& ! sparseset_bit_p (pseudos_live, src_regno))\n+\t  && (((src_regno >= FIRST_PSEUDO_REGISTER\n+\t\t&& (! sparseset_bit_p (pseudos_live, src_regno)\n+\t\t    || (dst_regno >= FIRST_PSEUDO_REGISTER\n+\t\t\t&& lra_reg_val_equal_p (src_regno,\n+\t\t\t\t\t\tlra_reg_info[dst_regno].val,\n+\t\t\t\t\t\tlra_reg_info[dst_regno].offset))))\n \t       || (src_regno < FIRST_PSEUDO_REGISTER\n \t\t   && ! TEST_HARD_REG_BIT (hard_regs_live, src_regno)))\n \t      /* It might be 'inheritance pseudo <- reload pseudo'.  */\n \t      || (src_regno >= lra_constraint_new_regno_start\n-\t\t  && ((int) REGNO (SET_DEST (set))\n-\t\t      >= lra_constraint_new_regno_start)\n+\t\t  && dst_regno >= lra_constraint_new_regno_start\n \t\t  /* Remember to skip special cases where src/dest regnos are\n \t\t     the same, e.g. insn SET pattern has matching constraints\n \t\t     like =r,0.  */\n-\t\t  && src_regno != (int) REGNO (SET_DEST (set)))))\n+\t\t  && src_regno != dst_regno)))\n \t{\n \t  int hard_regno = -1, regno = -1;\n \n-\t  dst_regno = REGNO (SET_DEST (set));\n \t  if (dst_regno >= lra_constraint_new_regno_start\n \t      && src_regno >= lra_constraint_new_regno_start)\n \t    {"}]}