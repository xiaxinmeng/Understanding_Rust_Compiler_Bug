{"sha": "3891cee2305bb50ede9598793afbedc761f6bcd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg5MWNlZTIzMDViYjUwZWRlOTU5ODc5M2FmYmVkYzc2MWY2YmNkNw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-02-18T17:26:35Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-02-18T17:26:35Z"}, "message": "trans-stmt.c (struct temporary_list): Delete.\n\n\n\t* trans-stmt.c (struct temporary_list): Delete.\n\t(gfc_trans_where_2): Major reorganization.  Remove no longer needed\n\tTEMP argument.  Allocate and deallocate the control mask and\n\tpending control mask locally.\n\t(gfc_trans_forall_1): Delete TEMP local variable, and update\n\tcall to gfc_trans_where_2.  No need to deallocate arrays after.\n\t(gfc_evaluate_where_mask): Major reorganization.  Change return\n\ttype to void.  Pass in parent execution mask, MASK, and two\n\talready allocated mask arrays CMASK and PMASK.  On return\n\tCMASK := MASK & COND, PMASK := MASK & !COND.  MASK, CMASK and\n\tCMASK may all be NULL, or refer to the same temporary arrays.\n\t(gfc_trans_where): Update call to gfc_trans_where_2.  We no\n\tlonger need a TEMP variable or to deallocate temporary arrays\n\tallocated by gfc_trans_where_2.\n\nFrom-SVN: r111245", "tree": {"sha": "845df317e73a9d6012862b3e3c03232be1cd595e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/845df317e73a9d6012862b3e3c03232be1cd595e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3891cee2305bb50ede9598793afbedc761f6bcd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3891cee2305bb50ede9598793afbedc761f6bcd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3891cee2305bb50ede9598793afbedc761f6bcd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3891cee2305bb50ede9598793afbedc761f6bcd7/comments", "author": null, "committer": null, "parents": [{"sha": "4ea42ebadb93edf5f33b751cf53fbfee8a595ff8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ea42ebadb93edf5f33b751cf53fbfee8a595ff8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ea42ebadb93edf5f33b751cf53fbfee8a595ff8"}], "stats": {"total": 312, "additions": 136, "deletions": 176}, "files": [{"sha": "83a9059b8a34bfee77f32c0af6e239cecd34441f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3891cee2305bb50ede9598793afbedc761f6bcd7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3891cee2305bb50ede9598793afbedc761f6bcd7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3891cee2305bb50ede9598793afbedc761f6bcd7", "patch": "@@ -1,3 +1,20 @@\n+2006-02-18  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* trans-stmt.c (struct temporary_list): Delete.\n+\t(gfc_trans_where_2): Major reorganization.  Remove no longer needed\n+\tTEMP argument.  Allocate and deallocate the control mask and\n+\tpending control mask locally.\n+\t(gfc_trans_forall_1): Delete TEMP local variable, and update\n+\tcall to gfc_trans_where_2.  No need to deallocate arrays after.\n+\t(gfc_evaluate_where_mask): Major reorganization.  Change return\n+\ttype to void.  Pass in parent execution mask, MASK, and two\n+\talready allocated mask arrays CMASK and PMASK.  On return\n+\tCMASK := MASK & COND, PMASK := MASK & !COND.  MASK, CMASK and\n+\tCMASK may all be NULL, or refer to the same temporary arrays.\n+\t(gfc_trans_where): Update call to gfc_trans_where_2.  We no\n+\tlonger need a TEMP variable or to deallocate temporary arrays\n+\tallocated by gfc_trans_where_2.\n+\n 2006-02-18   Danny Smith  <dannysmith@users.sourceforeg.net>\n \n \t* gfortran.h (gfc_add_attribute): Change uint to unsigned int."}, {"sha": "32c750a97211d8bdfb63740ca2a8a2495021d152", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 119, "deletions": 176, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3891cee2305bb50ede9598793afbedc761f6bcd7/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3891cee2305bb50ede9598793afbedc761f6bcd7/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=3891cee2305bb50ede9598793afbedc761f6bcd7", "patch": "@@ -49,13 +49,6 @@ typedef struct iter_info\n }\n iter_info;\n \n-typedef  struct temporary_list\n-{\n-  tree temporary;\n-  struct temporary_list *next;\n-}\n-temporary_list;\n-\n typedef struct forall_info\n {\n   iter_info *this_loop;\n@@ -69,8 +62,7 @@ typedef struct forall_info\n }\n forall_info;\n \n-static void gfc_trans_where_2 (gfc_code *, tree, forall_info *,\n-                               stmtblock_t *, temporary_list **temp);\n+static void gfc_trans_where_2 (gfc_code *, tree, forall_info *, stmtblock_t *);\n \n /* Translate a F95 label number to a LABEL_EXPR.  */\n \n@@ -2317,7 +2309,6 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   gfc_saved_var *saved_vars;\n   iter_info *this_forall, *iter_tmp;\n   forall_info *info, *forall_tmp;\n-  temporary_list *temp;\n \n   gfc_start_block (&block);\n \n@@ -2523,27 +2514,9 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n \t  break;\n \n         case EXEC_WHERE:\n-\n \t  /* Translate WHERE or WHERE construct nested in FORALL.  */\n-          temp = NULL;\n-\t  gfc_trans_where_2 (c, NULL, nested_forall_info, &block, &temp);\n-\n-          while (temp)\n-            {\n-              tree args;\n-              temporary_list *p;\n-\n-              /* Free the temporary.  */\n-              args = gfc_chainon_list (NULL_TREE, temp->temporary);\n-              tmp = build_function_call_expr (gfor_fndecl_internal_free, args);\n-              gfc_add_expr_to_block (&block, tmp);\n-\n-              p = temp;\n-              temp = temp->next;\n-              gfc_free (p);\n-            }\n-\n-          break;\n+\t  gfc_trans_where_2 (c, NULL, nested_forall_info, &block);\n+\t  break;\n \n         /* Pointer assignment inside FORALL.  */\n \tcase EXEC_POINTER_ASSIGN:\n@@ -2622,71 +2595,27 @@ tree gfc_trans_forall (gfc_code * code)\n    needed by the WHERE mask expression multiplied by the iterator number of\n    the nested forall.\n    ME is the WHERE mask expression.\n-   MASK is the temporary whose value is mask's value.\n-   NMASK is another temporary whose value is !mask, or NULL if not required.\n-   TEMP records the temporary's address allocated in this function in order\n-   to free them outside this function.\n-   MASK, NMASK and TEMP are all OUT arguments.  */\n+   MASK is the current execution mask upon input.\n+   CMASK is the updated execution mask on output, or NULL if not required.\n+   PMASK is the pending execution mask on output, or NULL if not required.\n+   BLOCK is the block in which to place the condition evaluation loops.  */\n \n-static tree\n+static void\n gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n-                         tree * mask, tree * nmask, temporary_list ** temp,\n-                         stmtblock_t * block)\n+                         tree mask, tree cmask, tree pmask,\n+                         tree mask_type, stmtblock_t * block)\n {\n   tree tmp, tmp1;\n   gfc_ss *lss, *rss;\n   gfc_loopinfo loop;\n-  tree ptemp1, ntmp, ptemp2;\n-  tree inner_size, size;\n-  stmtblock_t body, body1, inner_size_body;\n+  stmtblock_t body, body1;\n+  tree count, cond, mtmp;\n   gfc_se lse, rse;\n-  tree mask_type;\n-  tree count;\n-  tree tmpexpr;\n \n   gfc_init_loopinfo (&loop);\n \n-  /* Calculate the size of temporary needed by the mask-expr.  */\n-  gfc_init_block (&inner_size_body);\n-  inner_size = compute_inner_temp_size (me, me, &inner_size_body, &lss, &rss);\n-\n-  /* Calculate the total size of temporary needed.  */\n-  size = compute_overall_iter_number (nested_forall_info, inner_size,\n-\t\t\t\t      &inner_size_body, block);\n-\n-  /* As the mask array can be very big, prefer compact boolean types.  */\n-  mask_type = gfc_get_logical_type (gfc_logical_kinds[0].kind);\n-\n-  /* Allocate temporary for where mask.  */\n-  tmp = allocate_temp_for_forall_nest_1 (mask_type, size, block, &ptemp1);\n-\n-  /* Record the temporary address in order to free it later.  */\n-  if (ptemp1)\n-    {\n-      temporary_list *tempo;\n-      tempo = (temporary_list *) gfc_getmem (sizeof (temporary_list));\n-      tempo->temporary = ptemp1;\n-      tempo->next = *temp;\n-      *temp = tempo;\n-    }\n-\n-  if (nmask)\n-    {\n-      /* Allocate temporary for !mask.  */\n-      ntmp = allocate_temp_for_forall_nest_1 (mask_type, size, block, &ptemp2);\n-\n-      /* Record the temporary  in order to free it later.  */\n-      if (ptemp2)\n-\t{\n-\t  temporary_list *tempo;\n-\t  tempo = (temporary_list *) gfc_getmem (sizeof (temporary_list));\n-\t  tempo->temporary = ptemp2;\n-\t  tempo->next = *temp;\n-\t  *temp = tempo;\n-\t}\n-    }\n-  else\n-    ntmp = NULL_TREE;\n+  lss = gfc_walk_expr (me);\n+  rss = gfc_walk_expr (me);\n \n   /* Variable to index the temporary.  */\n   count = gfc_create_var (gfc_array_index_type, \"count\");\n@@ -2723,22 +2652,46 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n       rse.ss = rss;\n       gfc_conv_expr (&rse, me);\n     }\n-  /* Form the expression of the temporary.  */\n-  lse.expr = gfc_build_array_ref (tmp, count);\n \n-  /* Use the scalar assignment to fill temporary TMP.  */\n-  tmp1 = gfc_trans_scalar_assign (&lse, &rse, me->ts.type);\n-  gfc_add_expr_to_block (&body1, tmp1);\n+  /* Variable to evalate mask condition.  */\n+  cond = gfc_create_var (mask_type, \"cond\");\n+  if (mask && (cmask || pmask))\n+    mtmp = gfc_create_var (mask_type, \"mask\");\n+  else mtmp = NULL_TREE;\n+\n+  gfc_add_block_to_block (&body1, &lse.pre);\n+  gfc_add_block_to_block (&body1, &rse.pre);\n \n-  if (nmask)\n+  gfc_add_modify_expr (&body1, cond, fold_convert (mask_type, rse.expr));\n+\n+  if (mask && (cmask || pmask))\n     {\n-      /* Fill temporary NTMP.  */\n-      tmp1 = build1 (TRUTH_NOT_EXPR, TREE_TYPE (lse.expr), lse.expr);\n-      tmpexpr = gfc_build_array_ref (ntmp, count);\n-      gfc_add_modify_expr (&body1, tmpexpr, tmp1);\n+      tmp = gfc_build_array_ref (mask, count);\n+      gfc_add_modify_expr (&body1, mtmp, tmp);\n     }\n \n- if (lss == gfc_ss_terminator)\n+  if (cmask)\n+    {\n+      tmp1 = gfc_build_array_ref (cmask, count);\n+      tmp = cond;\n+      if (mask)\n+\ttmp = build2 (TRUTH_AND_EXPR, mask_type, mtmp, tmp);\n+      gfc_add_modify_expr (&body1, tmp1, tmp);\n+    }\n+\n+  if (pmask)\n+    {\n+      tmp1 = gfc_build_array_ref (pmask, count);\n+      tmp = build1 (TRUTH_NOT_EXPR, mask_type, cond);\n+      if (mask)\n+\ttmp = build2 (TRUTH_AND_EXPR, mask_type, mtmp, tmp);\n+      gfc_add_modify_expr (&body1, tmp1, tmp);\n+    }\n+\n+  gfc_add_block_to_block (&body1, &lse.post);\n+  gfc_add_block_to_block (&body1, &rse.post);\n+\n+  if (lss == gfc_ss_terminator)\n     {\n       gfc_add_block_to_block (&body, &body1);\n     }\n@@ -2766,12 +2719,6 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n     tmp1 = gfc_trans_nested_forall_loop (nested_forall_info, tmp1, 1, 1);\n \n   gfc_add_expr_to_block (block, tmp1);\n-\n-  *mask = tmp;\n-  if (nmask)\n-    *nmask = ntmp;\n-\n-  return tmp1;\n }\n \n \n@@ -2999,80 +2946,76 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n /* Translate the WHERE construct or statement.\n    This function can be called iteratively to translate the nested WHERE\n    construct or statement.\n-   MASK is the control mask.\n-   TEMP records the temporary address which must be freed later.  */\n+   MASK is the control mask.  */\n \n static void\n gfc_trans_where_2 (gfc_code * code, tree mask,\n-\t\t   forall_info * nested_forall_info, stmtblock_t * block,\n-                   temporary_list ** temp)\n+\t\t   forall_info * nested_forall_info, stmtblock_t * block)\n {\n+  stmtblock_t inner_size_body;\n+  tree inner_size, size;\n+  gfc_ss *lss, *rss;\n+  tree mask_type;\n   gfc_expr *expr1;\n   gfc_expr *expr2;\n   gfc_code *cblock;\n   gfc_code *cnext;\n-  tree tmp, tmp1, tmp2;\n+  tree tmp;\n   tree count1, count2;\n-  tree mask_copy;\n   int need_temp;\n-  tree *tmp1_ptr;\n-  tree pmask;\n-\n-  pmask = NULL_TREE;\n+  tree pcmask = NULL_TREE;\n+  tree ppmask = NULL_TREE;\n+  tree cmask = NULL_TREE;\n+  tree pmask = NULL_TREE;\n \n   /* the WHERE statement or the WHERE construct statement.  */\n   cblock = code->block;\n+\n+  /* Calculate the size of temporary needed by the mask-expr.  */\n+  gfc_init_block (&inner_size_body);\n+  inner_size = compute_inner_temp_size (cblock->expr, cblock->expr,\n+\t\t\t\t\t&inner_size_body, &lss, &rss);\n+\n+  /* Calculate the total size of temporary needed.  */\n+  size = compute_overall_iter_number (nested_forall_info, inner_size,\n+\t\t\t\t      &inner_size_body, block);\n+\n+  /* As the mask array can be very big, prefer compact boolean types.  */\n+  mask_type = gfc_get_logical_type (gfc_logical_kinds[0].kind);\n+\n+  /* Allocate temporary for where mask.  */\n+  cmask = allocate_temp_for_forall_nest_1 (mask_type, size, block, &pcmask);\n+\n+  if (cblock->block)\n+    {\n+      /* Allocate temporary for !mask.  */\n+      pmask = allocate_temp_for_forall_nest_1 (mask_type, size, block,\n+\t\t\t\t\t       &ppmask);\n+    }\n+  else\n+    {\n+      ppmask = NULL_TREE;\n+      pmask = NULL_TREE;\n+    }\n+\n   while (cblock)\n     {\n       /* Has mask-expr.  */\n       if (cblock->expr)\n         {\n \t  /* If this is the last clause of the WHERE construct, then\n-\t     we don't need to allocate/populate/deallocate a complementary\n-\t     pending control mask (pmask).  */\n+\t     we don't need to update the pending control mask (pmask).  */\n \t  if (! cblock->block)\n-\t    {\n-\t      tmp1 = NULL_TREE;\n-\t      tmp1_ptr = NULL;\n-\t    }\n-\t  else\n-\t    tmp1_ptr = &tmp1;\n+\t    pmask = NULL_TREE;\n \n           /* Ensure that the WHERE mask be evaluated only once.  */\n-          tmp2 = gfc_evaluate_where_mask (cblock->expr, nested_forall_info,\n-                                          &tmp, tmp1_ptr, temp, block);\n-\n-          /* Set the control mask and the pending control mask.  */\n-          /* It's a where-stmt.  */\n-          if (mask == NULL)\n-            {\n-              mask = tmp;\n-              pmask = tmp1;\n-            }\n-          /* It's a nested where-stmt.  */\n-          else if (mask && pmask == NULL)\n-            {\n-              tree tmp2;\n-              /* Use the TREE_CHAIN to list the masks.  */\n-              tmp2 = copy_list (mask);\n-              pmask = chainon (mask, tmp1);\n-              mask = chainon (tmp2, tmp);\n-            }\n-          /* It's a masked-elsewhere-stmt.  */\n-          else if (mask && cblock->expr)\n-            {\n-              tree tmp2;\n-              tmp2 = copy_list (pmask);\n+          gfc_evaluate_where_mask (cblock->expr, nested_forall_info,\n+\t\t\t\t   mask, cmask, pmask, mask_type, block);\n \n-              mask = pmask;\n-              tmp2 = chainon (tmp2, tmp);\n-              pmask = chainon (mask, tmp1);\n-              mask = tmp2;\n-            }\n         }\n       /* It's a elsewhere-stmt. No mask-expr is present.  */\n       else\n-        mask = pmask;\n+        cmask = mask;\n \n       /* Get the assignment statement of a WHERE statement, or the first\n          statement in where-body-construct of a WHERE construct.  */\n@@ -3089,7 +3032,7 @@ gfc_trans_where_2 (gfc_code * code, tree mask,\n                 {\n                   need_temp = gfc_check_dependency (expr1, expr2, 0);\n                   if (need_temp)\n-                    gfc_trans_assign_need_temp (expr1, expr2, mask,\n+                    gfc_trans_assign_need_temp (expr1, expr2, cmask,\n                                                 nested_forall_info, block);\n                   else\n                     {\n@@ -3099,8 +3042,8 @@ gfc_trans_where_2 (gfc_code * code, tree mask,\n                       gfc_add_modify_expr (block, count1, gfc_index_zero_node);\n                       gfc_add_modify_expr (block, count2, gfc_index_zero_node);\n \n-                      tmp = gfc_trans_where_assign (expr1, expr2, mask, count1,\n-                                                    count2);\n+                      tmp = gfc_trans_where_assign (expr1, expr2, cmask,\n+\t\t\t\t\t\t    count1, count2);\n \n                       tmp = gfc_trans_nested_forall_loop (nested_forall_info,\n                                                           tmp, 1, 1);\n@@ -3115,20 +3058,18 @@ gfc_trans_where_2 (gfc_code * code, tree mask,\n                   gfc_add_modify_expr (block, count1, gfc_index_zero_node);\n                   gfc_add_modify_expr (block, count2, gfc_index_zero_node);\n \n-                  tmp = gfc_trans_where_assign (expr1, expr2, mask, count1,\n-                                                count2);\n+                  tmp = gfc_trans_where_assign (expr1, expr2, cmask,\n+\t\t\t\t\t\tcount1, count2);\n                   gfc_add_expr_to_block (block, tmp);\n \n                 }\n               break;\n \n             /* WHERE or WHERE construct is part of a where-body-construct.  */\n             case EXEC_WHERE:\n-              /* Ensure that MASK is not modified by next gfc_trans_where_2.  */\n-              mask_copy = copy_list (mask);\n-              gfc_trans_where_2 (cnext, mask_copy, nested_forall_info,\n-                                 block, temp);\n-              break;\n+\t      /* Ensure that MASK is not modified by next gfc_trans_where_2.  */\n+\t      gfc_trans_where_2 (cnext, cmask, nested_forall_info, block);\n+\t      break;\n \n             default:\n               gcc_unreachable ();\n@@ -3139,7 +3080,24 @@ gfc_trans_where_2 (gfc_code * code, tree mask,\n        }\n     /* The next masked-elsewhere-stmt, elsewhere-stmt, or end-where-stmt.  */\n     cblock = cblock->block;\n+    mask = pmask;\n   }\n+\n+  /* If we allocated a pending mask array, deallocate it now.  */\n+  if (ppmask)\n+    {\n+      tree args = gfc_chainon_list (NULL_TREE, ppmask);\n+      tmp = build_function_call_expr (gfor_fndecl_internal_free, args);\n+      gfc_add_expr_to_block (block, tmp);\n+    }\n+\n+  /* If we allocated a current mask array, deallocate it now.  */\n+  if (pcmask)\n+    {\n+      tree args = gfc_chainon_list (NULL_TREE, pcmask);\n+      tmp = build_function_call_expr (gfor_fndecl_internal_free, args);\n+      gfc_add_expr_to_block (block, tmp);\n+    }\n }\n \n /* Translate a simple WHERE construct or statement without dependencies.\n@@ -3282,11 +3240,8 @@ tree\n gfc_trans_where (gfc_code * code)\n {\n   stmtblock_t block;\n-  temporary_list *temp, *p;\n   gfc_code *cblock;\n   gfc_code *eblock;\n-  tree args;\n-  tree tmp;\n \n   cblock = code->block;\n   if (cblock->next\n@@ -3333,21 +3288,9 @@ gfc_trans_where (gfc_code * code)\n     }\n \n   gfc_start_block (&block);\n-  temp = NULL;\n-\n-  gfc_trans_where_2 (code, NULL, NULL, &block, &temp);\n \n-  /* Add calls to free temporaries which were dynamically allocated.  */\n-  while (temp)\n-    {\n-      args = gfc_chainon_list (NULL_TREE, temp->temporary);\n-      tmp = build_function_call_expr (gfor_fndecl_internal_free, args);\n-      gfc_add_expr_to_block (&block, tmp);\n+  gfc_trans_where_2 (code, NULL, NULL, &block);\n \n-      p = temp;\n-      temp = temp->next;\n-      gfc_free (p);\n-    }\n   return gfc_finish_block (&block);\n }\n "}]}