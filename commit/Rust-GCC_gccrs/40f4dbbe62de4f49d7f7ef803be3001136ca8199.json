{"sha": "40f4dbbe62de4f49d7f7ef803be3001136ca8199", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBmNGRiYmU2MmRlNGY0OWQ3ZjdlZjgwM2JlMzAwMTEzNmNhODE5OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-06-11T12:42:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-06-11T12:42:28Z"}, "message": "[multiple changes]\n\n2014-06-11  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Input_Item): Allow formal\n\tparameters to appear as input_items in an initialization_list\n\tof pragma Initializes. Encapsulation now applies to states and\n\tvariables only (as it should). Add RM references to key errors.\n\t* sem_prag.adb (Set_Imported): Suppress errors\n\tabout preceding Imports when the pragma does not come from source,\n\twhich can happen through use of pragma Provide_Shift_Operators.\n\n2014-06-11  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch3.adb: Minor reformatting.\n\t* einfo.ads (Full_View): Minor comment update.\n\nFrom-SVN: r211460", "tree": {"sha": "30a57fbfd15a83ef0146f0073940716305dd317f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30a57fbfd15a83ef0146f0073940716305dd317f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40f4dbbe62de4f49d7f7ef803be3001136ca8199", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40f4dbbe62de4f49d7f7ef803be3001136ca8199", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40f4dbbe62de4f49d7f7ef803be3001136ca8199", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40f4dbbe62de4f49d7f7ef803be3001136ca8199/comments", "author": null, "committer": null, "parents": [{"sha": "e9daba516938491b64759703018edc71b928bfad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9daba516938491b64759703018edc71b928bfad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9daba516938491b64759703018edc71b928bfad"}], "stats": {"total": 283, "additions": 191, "deletions": 92}, "files": [{"sha": "126ffbe45b0214d20daaa5b5c49c6927c4f5228d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f4dbbe62de4f49d7f7ef803be3001136ca8199/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f4dbbe62de4f49d7f7ef803be3001136ca8199/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=40f4dbbe62de4f49d7f7ef803be3001136ca8199", "patch": "@@ -1,3 +1,40 @@\n+2014-06-11  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Input_Item): Allow formal\n+\tparameters to appear as input_items in an initialization_list\n+\tof pragma Initializes. Encapsulation now applies to states and\n+\tvariables only (as it should). Add RM references to key errors.\n+\t* sem_prag.adb (Set_Imported): Suppress errors\n+\tabout preceding Imports when the pragma does not come from source,\n+\twhich can happen through use of pragma Provide_Shift_Operators.\n+\n+2014-06-11  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch3.adb: Minor reformatting.\n+\t* einfo.ads (Full_View): Minor comment update.\n+\n+2014-06-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.adb (Is_Independent): New flag.\n+\t* einfo.ads (Is_Independent): New flag.\n+\t(Has_Independent_Components): Clean up and fix comments.\n+\t* sem_prag.adb (Fix_Error): Deal with changing argument\n+\t[of] to entity [for].\n+\t(Analyze_Pragma, case Independent): Set Is_Independent flag\n+\t(Analyze_Pragma, case Independent_Components): Set Is_Independent flag\n+\tin all components of specified record.\n+\n+2014-06-11  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch12.adb (Analyze_Formal_Decimal_Fixed_Point_Type):\n+\tSet proper Etype on bounds of dummy type created for analysis\n+\tof the generic.\n+\n+2014-06-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* debug.adb: Minor comment fix (add missing section of dot\n+\tnumeric flags).\n+\n 2014-06-11  Robert Dewar  <dewar@adacore.com>\n \n \t* gnat_rm.texi, switch-c.adb, sem_prag.adb, a-tgdico.ads, par-prag.adb,"}, {"sha": "cbe2ea92c8f3c915061a7c76926eaeda333427cf", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f4dbbe62de4f49d7f7ef803be3001136ca8199/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f4dbbe62de4f49d7f7ef803be3001136ca8199/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=40f4dbbe62de4f49d7f7ef803be3001136ca8199", "patch": "@@ -1336,12 +1336,12 @@ package Einfo is\n \n --    Full_View (Node11)\n --       Defined in all type and subtype entities and in deferred constants.\n---       References the entity for the corresponding full type declaration.\n---       For all types other than private and incomplete types, this field\n---       always contains Empty. If an incomplete type E1 is completed by a\n---       private type E2 whose full type declaration entity is E3 then the\n---       full view of E1 is E2, and the full view of E2 is E3. See also\n---       Underlying_Type.\n+--       References the entity for the corresponding full type or constant\n+--       declaration. For all types other than private and incomplete types,\n+--       this field always contains Empty. If an incomplete type E1 is\n+--       completed by a private type E2 whose full type declaration entity is\n+--       E3 then the full view of E1 is E2, and the full view of E2 is E3. See\n+--       also Underlying_Type.\n \n --    Generic_Homonym (Node11)\n --       Defined in generic packages. The generic homonym is the entity of\n@@ -1581,9 +1581,11 @@ package Einfo is\n --       Implicit_Dereference. Set also on the discriminant named in the aspect\n --       clause, to simplify type resolution.\n \n---    Has_Independent_Components (Flag34)\n---       Defined in objects and types. Set if the aspect Independent_Components\n---       applies (as set by coresponding pragma or aspect specification).\n+--    Has_Independent_Components (Flag34) [base type only]\n+--       Defined in types. Set if the aspect Independent_Components applies\n+--       (in the base type only), if corresponding pragma or aspect applies.\n+--       In the case of an object of anonymous array type, the flag is set on\n+--       the created array type.\n \n --    Has_Inheritable_Invariants (Flag248)\n --       Defined in all type entities. Set in private types from which one\n@@ -2415,6 +2417,11 @@ package Einfo is\n --    Is_Incomplete_Type (synthesized)\n --       Applies to all entities, true for incomplete types and subtypes\n \n+--    Is_Independent (Flag268)\n+--       Defined in record components. Set if a valid pragma or aspect\n+--       Independent applies to the component, or if a valid pragma or aspect\n+--       Independent_Components applies to the enclosing record type.\n+\n --    Is_Inlined (Flag11)\n --       Defined in all entities. Set for functions and procedures which are\n --       to be inlined. For subprograms created during expansion, this flag\n@@ -4215,7 +4222,7 @@ package Einfo is\n --  In addition, we define the kind E_Allocator_Type to label allocators.\n --  This is because special resolution rules apply to this construct.\n --  Eventually the constructs are labeled with the access type imposed by\n---  the context. Gigi should never see the type E_Allocator.\n+--  the context. Gigi should never see types with this Ekind.\n \n --  Similarly, the type E_Access_Attribute_Type is used as the initial kind\n --  associated with an access attribute. After resolution a specific access\n@@ -4398,8 +4405,8 @@ package Einfo is\n       --  'Unrestricted_Access and Unchecked_Access)\n \n       E_Allocator_Type,\n-      --  A special internal type used to label allocators and attribute\n-      --  references using 'Access. This is needed because special resolution\n+      --  A special internal type used to label allocators and references to\n+      --  objects using 'Reference. This is needed because special resolution\n       --  rules apply to these constructs. On the resolution pass, this type\n       --  is always replaced by the actual access type, so Gigi should never\n       --  see types with this Ekind.\n@@ -5350,6 +5357,7 @@ package Einfo is\n    --    Has_Biased_Representation           (Flag139)\n    --    Has_Per_Object_Constraint           (Flag154)\n    --    Is_Atomic                           (Flag85)\n+   --    Is_Independent                      (Flag268)\n    --    Is_Tag                              (Flag78)\n    --    Is_Volatile                         (Flag16)\n    --    Treat_As_Volatile                   (Flag41)\n@@ -5379,7 +5387,6 @@ package Einfo is\n    --    Has_Atomic_Components               (Flag86)\n    --    Has_Biased_Representation           (Flag139)\n    --    Has_Completion                      (Flag26)   (constants only)\n-   --    Has_Independent_Components          (Flag34)   (base type only)\n    --    Has_Thunks                          (Flag228)  (constants only)\n    --    Has_Size_Clause                     (Flag29)\n    --    Has_Up_Level_Access                 (Flag215)\n@@ -6089,7 +6096,6 @@ package Einfo is\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)\n    --    Has_Biased_Representation           (Flag139)\n-   --    Has_Independent_Components          (Flag34)   (base type only)\n    --    Has_Initial_Value                   (Flag219)\n    --    Has_Size_Clause                     (Flag29)\n    --    Has_Up_Level_Access                 (Flag215)\n@@ -6589,6 +6595,7 @@ package Einfo is\n    function Is_Immediately_Visible              (Id : E) return B;\n    function Is_Implementation_Defined           (Id : E) return B;\n    function Is_Imported                         (Id : E) return B;\n+   function Is_Independent                      (Id : E) return B;\n    function Is_Inlined                          (Id : E) return B;\n    function Is_Instantiated                     (Id : E) return B;\n    function Is_Interface                        (Id : E) return B;\n@@ -7217,6 +7224,7 @@ package Einfo is\n    procedure Set_Is_Immediately_Visible          (Id : E; V : B := True);\n    procedure Set_Is_Implementation_Defined       (Id : E; V : B := True);\n    procedure Set_Is_Imported                     (Id : E; V : B := True);\n+   procedure Set_Is_Independent                  (Id : E; V : B := True);\n    procedure Set_Is_Inlined                      (Id : E; V : B := True);\n    procedure Set_Is_Instantiated                 (Id : E; V : B := True);\n    procedure Set_Is_Interface                    (Id : E; V : B := True);\n@@ -7979,6 +7987,7 @@ package Einfo is\n    pragma Inline (Is_Imported);\n    pragma Inline (Is_Incomplete_Or_Private_Type);\n    pragma Inline (Is_Incomplete_Type);\n+   pragma Inline (Is_Independent);\n    pragma Inline (Is_Inlined);\n    pragma Inline (Is_Instantiated);\n    pragma Inline (Is_Integer_Type);\n@@ -8426,6 +8435,7 @@ package Einfo is\n    pragma Inline (Set_Is_Immediately_Visible);\n    pragma Inline (Set_Is_Implementation_Defined);\n    pragma Inline (Set_Is_Imported);\n+   pragma Inline (Set_Is_Independent);\n    pragma Inline (Set_Is_Inlined);\n    pragma Inline (Set_Is_Instantiated);\n    pragma Inline (Set_Is_Interface);"}, {"sha": "684b0a4e0c5c2bc2e7ee6f693888f7c288da3aec", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f4dbbe62de4f49d7f7ef803be3001136ca8199/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f4dbbe62de4f49d7f7ef803be3001136ca8199/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=40f4dbbe62de4f49d7f7ef803be3001136ca8199", "patch": "@@ -15508,7 +15508,6 @@ package body Sem_Ch3 is\n                       or else No (Full_View (Prev))\n                       or else not Is_Private_Type (Full_View (Prev)))\n          then\n-\n             --  Indicate that the incomplete declaration has a matching full\n             --  declaration. The defining occurrence of the incomplete\n             --  declaration remains the visible one, and the procedure"}, {"sha": "622a2c0be20e3f331541da6de191890d6306064b", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 130, "deletions": 77, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f4dbbe62de4f49d7f7ef803be3001136ca8199/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f4dbbe62de4f49d7f7ef803be3001136ca8199/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=40f4dbbe62de4f49d7f7ef803be3001136ca8199", "patch": "@@ -2583,8 +2583,12 @@ package body Sem_Prag is\n                if Is_Entity_Name (Input) then\n                   Input_Id := Entity_Of (Input);\n \n-                  if Ekind_In (Input_Id, E_Abstract_State, E_Variable) then\n-\n+                  if Ekind_In (Input_Id, E_Abstract_State,\n+                                         E_In_Parameter,\n+                                         E_In_Out_Parameter,\n+                                         E_Out_Parameter,\n+                                         E_Variable)\n+                  then\n                      --  The input cannot denote states or variables declared\n                      --  within the related package.\n \n@@ -2610,20 +2614,23 @@ package body Sem_Prag is\n                            Add_Item (Input_Id, States_Seen);\n                         end if;\n \n-                        if Present (Encapsulating_State (Input_Id)) then\n+                        if Ekind_In (Input_Id, E_Abstract_State, E_Variable)\n+                          and then Present (Encapsulating_State (Input_Id))\n+                        then\n                            Add_Item (Input_Id, Constits_Seen);\n                         end if;\n                      end if;\n \n                   --  The input references something that is not a state or a\n-                  --  variable.\n+                  --  variable (SPARK RM 7.1.5(3)).\n \n                   else\n                      Error_Msg_N\n                        (\"input item must denote variable or state\", Input);\n                   end if;\n \n                --  Some form of illegal construct masquerading as a name\n+               --  (SPARK RM 7.1.5(3)).\n \n                else\n                   Error_Msg_N\n@@ -3219,14 +3226,27 @@ package body Sem_Prag is\n       --  procedure identified by Name, returns it if it exists, otherwise\n       --  errors out and uses Arg as the pragma argument for the message.\n \n-      procedure Fix_Error (Msg : in out String);\n-      --  This is called prior to issuing an error message. Msg is a string\n-      --  that typically contains the substring \"pragma\". If the pragma comes\n-      --  from an aspect, each such \"pragma\" substring is replaced with the\n-      --  characters \"aspect\", and Error_Msg_Name_1 is set to the name of the\n-      --  aspect (which may be different from the pragma name). If the current\n-      --  pragma results from rewriting another pragma, then Error_Msg_Name_1\n-      --  is set to the original pragma name.\n+      function Fix_Error (Msg : String) return String;\n+      --  This is called prior to issuing an error message. Msg is the normal\n+      --  error message issued in the pragma case. This routine checks for the\n+      --  case of a pragma coming from an aspect in the source, and returns a\n+      --  message suitable for the aspect case as follows:\n+      --\n+      --    Each substring \"pragma\" is replaced by \"aspect\"\n+      --\n+      --    If \"argument of\" is at the start of the error message text, it is\n+      --    replaced by \"entity for\".\n+      --\n+      --    If \"argument\" is at the start of the error message text, it is\n+      --    replaced by \"entity\".\n+      --\n+      --  So for example, \"argument of pragma X must be discrete type\"\n+      --  returns \"entity for aspect X must be a discrete type\".\n+\n+      --  Finally Error_Msg_Name_1 is set to the name of the aspect (which may\n+      --  be different from the pragma name). If the current pragma results\n+      --  from rewriting another pragma, then Error_Msg_Name_1 is set to the\n+      --  original pragma name.\n \n       procedure Gather_Associations\n         (Names : Name_List;\n@@ -3746,12 +3766,11 @@ package body Sem_Prag is\n                Error_Msg_Name_1 := Pname;\n \n                declare\n-                  Msg : String :=\n+                  Msg : constant String :=\n                           \"argument for pragma% must be a identifier or \"\n                           & \"static string expression!\";\n                begin\n-                  Fix_Error (Msg);\n-                  Flag_Non_Static_Expr (Msg, Argx);\n+                  Flag_Non_Static_Expr (Fix_Error (Msg), Argx);\n                   raise Pragma_Exit;\n                end;\n             end if;\n@@ -4419,15 +4438,9 @@ package body Sem_Prag is\n \n          else\n             Error_Msg_Name_1 := Pname;\n-\n-            declare\n-               Msg : String :=\n-                       \"argument for pragma% must be a static expression!\";\n-            begin\n-               Fix_Error (Msg);\n-               Flag_Non_Static_Expr (Msg, Expr);\n-            end;\n-\n+            Flag_Non_Static_Expr\n+              (Fix_Error (\"argument for pragma% must be a static expression!\"),\n+               Expr);\n             raise Pragma_Exit;\n          end if;\n       end Check_Expr_Is_Static_Expression;\n@@ -5822,11 +5835,9 @@ package body Sem_Prag is\n       ------------------\n \n       procedure Error_Pragma (Msg : String) is\n-         MsgF : String := Msg;\n       begin\n          Error_Msg_Name_1 := Pname;\n-         Fix_Error (MsgF);\n-         Error_Msg_N (MsgF, N);\n+         Error_Msg_N (Fix_Error (Msg), N);\n          raise Pragma_Exit;\n       end Error_Pragma;\n \n@@ -5835,20 +5846,16 @@ package body Sem_Prag is\n       ----------------------\n \n       procedure Error_Pragma_Arg (Msg : String; Arg : Node_Id) is\n-         MsgF : String := Msg;\n       begin\n          Error_Msg_Name_1 := Pname;\n-         Fix_Error (MsgF);\n-         Error_Msg_N (MsgF, Get_Pragma_Arg (Arg));\n+         Error_Msg_N (Fix_Error (Msg), Get_Pragma_Arg (Arg));\n          raise Pragma_Exit;\n       end Error_Pragma_Arg;\n \n       procedure Error_Pragma_Arg (Msg1, Msg2 : String; Arg : Node_Id) is\n-         MsgF : String := Msg1;\n       begin\n          Error_Msg_Name_1 := Pname;\n-         Fix_Error (MsgF);\n-         Error_Msg_N (MsgF, Get_Pragma_Arg (Arg));\n+         Error_Msg_N (Fix_Error (Msg1), Get_Pragma_Arg (Arg));\n          Error_Pragma_Arg (Msg2, Arg);\n       end Error_Pragma_Arg;\n \n@@ -5857,11 +5864,9 @@ package body Sem_Prag is\n       ----------------------------\n \n       procedure Error_Pragma_Arg_Ident (Msg : String; Arg : Node_Id) is\n-         MsgF : String := Msg;\n       begin\n          Error_Msg_Name_1 := Pname;\n-         Fix_Error (MsgF);\n-         Error_Msg_N (MsgF, Arg);\n+         Error_Msg_N (Fix_Error (Msg), Arg);\n          raise Pragma_Exit;\n       end Error_Pragma_Arg_Ident;\n \n@@ -5870,12 +5875,10 @@ package body Sem_Prag is\n       ----------------------\n \n       procedure Error_Pragma_Ref (Msg : String; Ref : Entity_Id) is\n-         MsgF : String := Msg;\n       begin\n          Error_Msg_Name_1 := Pname;\n-         Fix_Error (MsgF);\n-         Error_Msg_Sloc   := Sloc (Ref);\n-         Error_Msg_NE (MsgF, N, Ref);\n+         Error_Msg_Sloc := Sloc (Ref);\n+         Error_Msg_NE (Fix_Error (Msg), N, Ref);\n          raise Pragma_Exit;\n       end Error_Pragma_Ref;\n \n@@ -6006,7 +6009,11 @@ package body Sem_Prag is\n       -- Fix_Error --\n       ---------------\n \n-      procedure Fix_Error (Msg : in out String) is\n+      function Fix_Error (Msg : String) return String is\n+         Res      : String (Msg'Range) := Msg;\n+         Res_Last : Natural            := Msg'Last;\n+         J        : Natural;\n+\n       begin\n          --  If we have a rewriting of another pragma, go to that pragma\n \n@@ -6022,16 +6029,47 @@ package body Sem_Prag is\n \n             --  Change appearence of \"pragma\" in message to \"aspect\"\n \n-            for J in Msg'First .. Msg'Last - 5 loop\n-               if Msg (J .. J + 5) = \"pragma\" then\n-                  Msg (J .. J + 5) := \"aspect\";\n+            J := Res'First;\n+            while J <= Res_Last - 5 loop\n+               if Res (J .. J + 5) = \"pragma\" then\n+                  Res (J .. J + 5) := \"aspect\";\n+                  J := J + 6;\n+\n+               else\n+                  J := J + 1;\n                end if;\n             end loop;\n \n+            --  Change \"argument of\" at start of message to \"entity for\"\n+\n+            if Res'Length > 11\n+              and then Res (Res'First .. Res'First + 10) = \"argument of\"\n+            then\n+               Res (Res'First .. Res'First + 9) := \"entity for\";\n+               Res (Res'First + 10 .. Res_Last - 1) :=\n+                 Res (Res'First + 11 .. Res_Last);\n+               Res_Last := Res_Last - 1;\n+            end if;\n+\n+            --  Change \"argument\" at start of message to \"entity\"\n+\n+            if Res'Length > 8\n+              and then Res (Res'First .. Res'First + 7) = \"argument\"\n+            then\n+               Res (Res'First .. Res'First + 5) := \"entity\";\n+               Res (Res'First + 6 .. Res_Last - 2) :=\n+                 Res (Res'First + 8 .. Res_Last);\n+               Res_Last := Res_Last - 2;\n+            end if;\n+\n             --  Get name from corresponding aspect\n \n             Error_Msg_Name_1 := Original_Aspect_Name (N);\n          end if;\n+\n+         --  Return possibly modified message\n+\n+         return Res (Res'First .. Res_Last);\n       end Fix_Error;\n \n       -------------------------\n@@ -9538,6 +9576,12 @@ package body Sem_Prag is\n             elsif Import_Interface_Present (N) then\n                goto OK;\n \n+            --  OK if the pragma was expanded by the compiler. Can occur when\n+            --  using pragma Provide_Shift_Operators on multiple types.\n+\n+            elsif not Comes_From_Source (N) then\n+               goto OK;\n+\n             --  Error if being set Imported twice\n \n             else\n@@ -14974,13 +15018,11 @@ package body Sem_Prag is\n          -- Independent --\n          -----------------\n \n-         --  pragma Independent (LOCAL_NAME);\n+         --  pragma Independent (record_component_LOCAL_NAME);\n \n          when Pragma_Independent => Independent : declare\n             E_Id : Node_Id;\n             E    : Entity_Id;\n-            D    : Node_Id;\n-            K    : Node_Kind;\n \n          begin\n             Check_Ada_83_Warning;\n@@ -14995,38 +15037,32 @@ package body Sem_Prag is\n             end if;\n \n             E := Entity (E_Id);\n-            D := Declaration_Node (E);\n-            K := Nkind (D);\n+\n+            --  Check we have a record component. We have not yet setup\n+            --  components fully, so identify by syntactic structure.\n+\n+            if Nkind (Declaration_Node (E)) /= N_Component_Declaration then\n+               Error_Pragma_Arg\n+                 (\"argument for pragma% must be record component\", Arg1);\n+            end if;\n \n             --  Check duplicate before we chain ourselves\n \n             Check_Duplicate_Pragma (E);\n \n-            --  Check appropriate entity\n+            --  Chain pragma\n \n-            if Is_Type (E) then\n-               if Rep_Item_Too_Early (E, N)\n-                    or else\n-                  Rep_Item_Too_Late (E, N)\n-               then\n-                  return;\n-               else\n-                  Check_First_Subtype (Arg1);\n-               end if;\n-\n-            elsif K = N_Object_Declaration\n-              or else (K = N_Component_Declaration\n-                        and then Original_Record_Component (E) = E)\n+            if Rep_Item_Too_Early (E, N)\n+                 or else\n+               Rep_Item_Too_Late (E, N)\n             then\n-               if Rep_Item_Too_Late (E, N) then\n-                  return;\n-               end if;\n-\n-            else\n-               Error_Pragma_Arg\n-                 (\"inappropriate entity for pragma%\", Arg1);\n+               return;\n             end if;\n \n+            --  Set flag in component\n+\n+            Set_Is_Independent (E);\n+\n             Independence_Checks.Append ((N, E));\n          end Independent;\n \n@@ -15043,6 +15079,7 @@ package body Sem_Prag is\n             E    : Entity_Id;\n             D    : Node_Id;\n             K    : Node_Kind;\n+            C    : Node_Id;\n \n          begin\n             Check_Ada_83_Warning;\n@@ -15077,16 +15114,26 @@ package body Sem_Prag is\n             if K = N_Full_Type_Declaration\n               and then (Is_Array_Type (E) or else Is_Record_Type (E))\n             then\n-               Independence_Checks.Append ((N, E));\n+               Independence_Checks.Append ((N, Base_Type (E)));\n                Set_Has_Independent_Components (Base_Type (E));\n \n+               --  For record type, set all components independent\n+\n+               if Is_Record_Type (E) then\n+                  C := First_Component (E);\n+                  while Present (C) loop\n+                     Set_Is_Independent (C);\n+                     Next_Component (C);\n+                  end loop;\n+               end if;\n+\n             elsif (Ekind (E) = E_Constant or else Ekind (E) = E_Variable)\n               and then Nkind (D) = N_Object_Declaration\n               and then Nkind (Object_Definition (D)) =\n                                            N_Constrained_Array_Definition\n             then\n-               Independence_Checks.Append ((N, E));\n-               Set_Has_Independent_Components (E);\n+               Independence_Checks.Append ((N, Base_Type (Etype (E))));\n+               Set_Has_Independent_Components (Base_Type (Etype (E)));\n \n             else\n                Error_Pragma_Arg (\"inappropriate entity for pragma%\", Arg1);\n@@ -17426,8 +17473,15 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n             Check_Arg_Is_Local_Name (Arg1);\n-\n             Type_Id := Get_Pragma_Arg (Assoc);\n+\n+            if not Is_Entity_Name (Type_Id)\n+              or else not Is_Type (Entity (Type_Id))\n+            then\n+               Error_Pragma_Arg\n+                 (\"argument for pragma% must be type or subtype\", Arg1);\n+            end if;\n+\n             Find_Type (Type_Id);\n             Typ := Entity (Type_Id);\n \n@@ -19650,13 +19704,12 @@ package body Sem_Prag is\n             --------------------------------\n \n             procedure Check_Library_Level_Entity (E : Entity_Id) is\n-               MsgF : String := \"incorrect placement of pragma%\";\n+               MsgF : constant String := \"incorrect placement of pragma%\";\n \n             begin\n                if not Is_Library_Level_Entity (E) then\n                   Error_Msg_Name_1 := Pname;\n-                  Fix_Error (MsgF);\n-                  Error_Msg_N (MsgF, N);\n+                  Error_Msg_N (Fix_Error (MsgF), N);\n \n                   if Ekind_In (E, E_Generic_Package,\n                                   E_Package,"}]}