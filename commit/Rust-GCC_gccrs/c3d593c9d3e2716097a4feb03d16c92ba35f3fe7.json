{"sha": "c3d593c9d3e2716097a4feb03d16c92ba35f3fe7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNkNTkzYzlkM2UyNzE2MDk3YTRmZWIwM2QxNmM5MmJhMzVmM2ZlNw==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2007-06-06T10:26:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:26:39Z"}, "message": "exp_dist.ads, [...] (Make_Transportable_Check): New subprogram (GARLIC_Support.Build_Subprogram_Receiving_Stubs...\n\n2007-04-20  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_dist.ads, exp_dist.adb (Make_Transportable_Check): New subprogram\n\t(GARLIC_Support.Build_Subprogram_Receiving_Stubs,\n\tPolyORB_Support.Build_Subprogram_Receiving_Stubs):\n\tFor a remote call to a function with a classwide return type, apply an\n\tE.4(18) check to the returned value.\n\t(Add_RACW_Primitive_Declarations_And_Bodies): Do not generate stubs for\n\tstream attributes of the designated type of an RACW, as they are not\n\tdispatching primitive operations.\n\nFrom-SVN: r125403", "tree": {"sha": "d395727268ae8ec3c8e5b770e57e0cc3ec343da2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d395727268ae8ec3c8e5b770e57e0cc3ec343da2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3d593c9d3e2716097a4feb03d16c92ba35f3fe7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3d593c9d3e2716097a4feb03d16c92ba35f3fe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3d593c9d3e2716097a4feb03d16c92ba35f3fe7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3d593c9d3e2716097a4feb03d16c92ba35f3fe7/comments", "author": null, "committer": null, "parents": [{"sha": "7853d9342541e5d4e125304b6bcc595e55698811", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7853d9342541e5d4e125304b6bcc595e55698811", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7853d9342541e5d4e125304b6bcc595e55698811"}], "stats": {"total": 352, "additions": 240, "deletions": 112}, "files": [{"sha": "10eae084718a634021f01c63da01b4bf67d22b5b", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 230, "deletions": 111, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3d593c9d3e2716097a4feb03d16c92ba35f3fe7/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3d593c9d3e2716097a4feb03d16c92ba35f3fe7/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=c3d593c9d3e2716097a4feb03d16c92ba35f3fe7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,11 +27,11 @@\n with Atree;    use Atree;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n+with Exp_Atag; use Exp_Atag;\n with Exp_Strm; use Exp_Strm;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Lib;      use Lib;\n-with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n@@ -162,12 +162,12 @@ package body Exp_Dist is\n       Vis_Decl           : Node_Id;\n       All_Calls_Remote_E : Entity_Id;\n       Proxy_Object_Addr  : out Entity_Id);\n-   --  Add the proxy type necessary to call the subprogram declared\n-   --  by Vis_Decl through a remote access to subprogram type.\n-   --  All_Calls_Remote_E must be Standard_True if a pragma All_Calls_Remote\n-   --  applies, Standard_False otherwise. The new proxy type is appended\n-   --  to Decls. Proxy_Object_Addr is a constant of type System.Address that\n-   --  designates an instance of the proxy object.\n+   --  Add the proxy type required, on the receiving (server) side, to handle\n+   --  calls to the subprogram declared by Vis_Decl through a remote access\n+   --  to subprogram type. All_Calls_Remote_E must be Standard_True if a pragma\n+   --  All_Calls_Remote applies, Standard_False otherwise. The new proxy type\n+   --  is appended to Decls. Proxy_Object_Addr is a constant of type\n+   --  System.Address that designates an instance of the proxy object.\n \n    function Build_Remote_Subprogram_Proxy_Type\n      (Loc            : Source_Ptr;\n@@ -1270,7 +1270,12 @@ package body Exp_Dist is\n \n             if Chars (Current_Primitive) /= Name_uSize\n               and then Chars (Current_Primitive) /= Name_uAlignment\n-              and then not Is_TSS (Current_Primitive, TSS_Deep_Finalize)\n+              and then not\n+                (Is_TSS (Current_Primitive, TSS_Deep_Finalize) or else\n+                 Is_TSS (Current_Primitive, TSS_Stream_Input)  or else\n+                 Is_TSS (Current_Primitive, TSS_Stream_Output) or else\n+                 Is_TSS (Current_Primitive, TSS_Stream_Read)   or else\n+                 Is_TSS (Current_Primitive, TSS_Stream_Write))\n             then\n                --  The first thing to do is build an up-to-date copy of the\n                --  spec with all the formals referencing Designated_Type\n@@ -2705,14 +2710,14 @@ package body Exp_Dist is\n \n             begin\n                if Ekind (Scop) = E_Package_Body then\n-                  New_Scope (Spec_Entity (Scop));\n+                  Push_Scope (Spec_Entity (Scop));\n \n                elsif Ekind (Scop) = E_Subprogram_Body then\n-                  New_Scope\n+                  Push_Scope\n                      (Corresponding_Spec (Unit_Declaration_Node (Scop)));\n \n                else\n-                  New_Scope (Scop);\n+                  Push_Scope (Scop);\n                end if;\n \n                Analyze (RCI_Locator);\n@@ -2750,7 +2755,7 @@ package body Exp_Dist is\n       Spec  : constant Node_Id := Specification (Unit_Node);\n       Decls : constant List_Id := Visible_Declarations (Spec);\n    begin\n-      New_Scope (Scope_Of_Spec (Spec));\n+      Push_Scope (Scope_Of_Spec (Spec));\n       Add_Calling_Stubs_To_Declarations\n         (Specification (Unit_Node), Decls);\n       Pop_Scope;\n@@ -2774,15 +2779,15 @@ package body Exp_Dist is\n             Decls := Visible_Declarations (Spec);\n          end if;\n \n-         New_Scope (Scope_Of_Spec (Spec));\n+         Push_Scope (Scope_Of_Spec (Spec));\n          Specific_Add_Receiving_Stubs_To_Declarations\n            (Spec, Decls, Decls);\n       else\n          Spec  :=\n            Package_Specification_Of_Scope (Corresponding_Spec (Unit_Node));\n          Decls := Declarations (Unit_Node);\n \n-         New_Scope (Scope_Of_Spec (Unit_Node));\n+         Push_Scope (Scope_Of_Spec (Unit_Node));\n          Temp := New_List;\n          Specific_Add_Receiving_Stubs_To_Declarations\n            (Spec, Temp, Statements (Handled_Statement_Sequence (Unit_Node)));\n@@ -3645,17 +3650,17 @@ package body Exp_Dist is\n \n          --    - a package RPC receiver must be built. This subprogram\n          --      will get a Subprogram_Id from the incoming stream\n-         --      and will dispatch the call to the right subprogram\n+         --      and will dispatch the call to the right subprogram;\n \n-         --    - a receiving stub for any subprogram visible in the package\n+         --    - a receiving stub for each subprogram visible in the package\n          --      spec. This stub will read all the parameters from the stream,\n          --      and put the result as well as the exception occurrence in the\n-         --      output stream\n+         --      output stream;\n \n          --    - a dummy package with an empty spec and a body made of an\n          --      elaboration part, whose job is to register the receiving\n          --      part of this RCI package on the name server. This is done\n-         --      by calling System.Partition_Interface.Register_Receiving_Stub\n+         --      by calling System.Partition_Interface.Register_Receiving_Stub.\n \n          Build_RPC_Receiver_Body (\n            RPC_Receiver => Pkg_RPC_Receiver,\n@@ -3861,76 +3866,121 @@ package body Exp_Dist is\n                          High_Bound =>\n                            Make_Integer_Literal (Loc,\n                              First_RCI_Subprogram_Id\n-                             + List_Length (Subp_Info_List) - 1))))),\n-             Expression          =>\n-               Make_Aggregate (Loc,\n-                 Component_Associations => Subp_Info_List)));\n+                             + List_Length (Subp_Info_List) - 1)))))));\n+\n+         --  For a degenerate RCI with no visible subprograms, Subp_Info_List\n+         --  has zero length, and the declaration is for an empty array, in\n+         --  which case no initialization aggregate must be generated.\n+\n+         if Present (First (Subp_Info_List)) then\n+            Set_Expression (Last (Decls),\n+              Make_Aggregate (Loc,\n+                Component_Associations => Subp_Info_List));\n+\n+         --  No initialization provided: remove CONSTANT so that the\n+         --  declaration is not an incomplete deferred constant.\n+\n+         else\n+            Set_Constant_Present (Last (Decls), False);\n+         end if;\n+\n          Analyze (Last (Decls));\n \n-         Append_To (Decls,\n-           Make_Subprogram_Body (Loc,\n-             Specification =>\n-               Copy_Specification (Loc, Parent (Lookup_RAS_Info)),\n-             Declarations =>\n-               No_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => New_List (\n-                   Make_Return_Statement (Loc,\n-                     Expression => OK_Convert_To (RTE (RE_Unsigned_64),\n-                       Make_Selected_Component (Loc,\n-                         Prefix =>\n-                           Make_Indexed_Component (Loc,\n-                             Prefix =>\n-                               New_Occurrence_Of (Subp_Info_Array, Loc),\n-                             Expressions => New_List (\n-                               Convert_To (Standard_Integer,\n-                                 Make_Identifier (Loc, Name_Subp_Id)))),\n-                         Selector_Name =>\n-                           Make_Identifier (Loc, Name_Addr))))))));\n+         declare\n+            Subp_Info_Addr : Node_Id;\n+            --  Return statement for Lookup_RAS_Info: address of the subprogram\n+            --  information record for the requested subprogram id.\n+\n+         begin\n+            if Present (First (Subp_Info_List)) then\n+               Subp_Info_Addr :=\n+                 Make_Selected_Component (Loc,\n+                   Prefix =>\n+                     Make_Indexed_Component (Loc,\n+                       Prefix =>\n+                         New_Occurrence_Of (Subp_Info_Array, Loc),\n+                       Expressions => New_List (\n+                         Convert_To (Standard_Integer,\n+                           Make_Identifier (Loc, Name_Subp_Id)))),\n+                   Selector_Name =>\n+                     Make_Identifier (Loc, Name_Addr));\n+\n+            --  Case of no visible subprogram: just raise Constraint_Error, we\n+            --  know for sure we got junk from a remote partition.\n+\n+            else\n+               Subp_Info_Addr :=\n+                 Make_Raise_Constraint_Error (Loc,\n+                    Reason => CE_Range_Check_Failed);\n+               Set_Etype (Subp_Info_Addr, RTE (RE_Unsigned_64));\n+            end if;\n+\n+            Append_To (Decls,\n+              Make_Subprogram_Body (Loc,\n+                Specification =>\n+                  Copy_Specification (Loc, Parent (Lookup_RAS_Info)),\n+                Declarations =>\n+                  No_List,\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => New_List (\n+                      Make_Return_Statement (Loc,\n+                        Expression =>\n+                          OK_Convert_To (RTE (RE_Unsigned_64),\n+                                         Subp_Info_Addr))))));\n+         end;\n+\n          Analyze (Last (Decls));\n \n          Append_To (Decls, Pkg_RPC_Receiver_Body);\n          Analyze (Last (Decls));\n \n          Get_Library_Unit_Name_String (Pkg_Spec);\n+\n+         --  Name\n+\n          Append_To (Register_Pkg_Actuals,\n-            --  Name\n            Make_String_Literal (Loc,\n              Strval => String_From_Name_Buffer));\n \n+         --  Receiver\n+\n          Append_To (Register_Pkg_Actuals,\n-            --  Receiver\n            Make_Attribute_Reference (Loc,\n              Prefix         =>\n                New_Occurrence_Of (Pkg_RPC_Receiver, Loc),\n              Attribute_Name =>\n                Name_Unrestricted_Access));\n \n+         --  Version\n+\n          Append_To (Register_Pkg_Actuals,\n-            --  Version\n            Make_Attribute_Reference (Loc,\n              Prefix         =>\n                New_Occurrence_Of (Defining_Entity (Pkg_Spec), Loc),\n              Attribute_Name =>\n                Name_Version));\n \n+         --  Subp_Info\n+\n          Append_To (Register_Pkg_Actuals,\n-            --  Subp_Info\n            Make_Attribute_Reference (Loc,\n              Prefix         =>\n                New_Occurrence_Of (Subp_Info_Array, Loc),\n              Attribute_Name =>\n                Name_Address));\n \n+         --  Subp_Info_Len\n+\n          Append_To (Register_Pkg_Actuals,\n-            --  Subp_Info_Len\n            Make_Attribute_Reference (Loc,\n              Prefix         =>\n                New_Occurrence_Of (Subp_Info_Array, Loc),\n              Attribute_Name =>\n                Name_Length));\n \n+         --  Generate the call\n+\n          Append_To (Stmts,\n            Make_Procedure_Call_Statement (Loc,\n              Name                   =>\n@@ -4932,6 +4982,18 @@ package body Exp_Dist is\n                        Name                   => Called_Subprogram,\n                        Parameter_Associations => Parameter_List)));\n \n+               if Is_Class_Wide_Type (Etyp) then\n+\n+                  --  For a remote call to a function with a class-wide type,\n+                  --  check that the returned value satisfies the requirements\n+                  --  of E.4(18).\n+\n+                  Append_To (Inner_Decls,\n+                    Make_Transportable_Check (Loc,\n+                      New_Occurrence_Of (Result, Loc)));\n+\n+               end if;\n+\n                Append_To (After_Statements,\n                  Make_Attribute_Reference (Loc,\n                    Prefix         => New_Occurrence_Of (Etyp, Loc),\n@@ -5195,6 +5257,25 @@ package body Exp_Dist is\n         or else Etype (Typ) = Stub_Type;\n    end Is_RACW_Controlling_Formal;\n \n+   ------------------------------\n+   -- Make_Transportable_Check --\n+   ------------------------------\n+\n+   function Make_Transportable_Check\n+     (Loc  : Source_Ptr;\n+      Expr : Node_Id) return Node_Id is\n+   begin\n+      return\n+        Make_Raise_Program_Error (Loc,\n+          Condition       =>\n+            Make_Op_Not (Loc,\n+              Build_Get_Transportable (Loc,\n+                Make_Selected_Component (Loc,\n+                  Prefix        => Expr,\n+                  Selector_Name => Make_Identifier (Loc, Name_uTag)))),\n+          Reason => PE_Non_Transportable_Actual);\n+   end Make_Transportable_Check;\n+\n    -----------------------------\n    -- Make_Selected_Component --\n    -----------------------------\n@@ -6873,17 +6954,17 @@ package body Exp_Dist is\n \n          --    - a package RPC receiver must be built. This subprogram\n          --      will get a Subprogram_Id from the incoming stream\n-         --      and will dispatch the call to the right subprogram\n+         --      and will dispatch the call to the right subprogram;\n \n-         --    - a receiving stub for any subprogram visible in the package\n+         --    - a receiving stub for each subprogram visible in the package\n          --      spec. This stub will read all the parameters from the stream,\n          --      and put the result as well as the exception occurrence in the\n-         --      output stream\n+         --      output stream;\n \n          --    - a dummy package with an empty spec and a body made of an\n          --      elaboration part, whose job is to register the receiving\n          --      part of this RCI package on the name server. This is done\n-         --      by calling System.Partition_Interface.Register_Receiving_Stub\n+         --      by calling System.Partition_Interface.Register_Receiving_Stub.\n \n          Build_RPC_Receiver_Body (\n            RPC_Receiver => Pkg_RPC_Receiver,\n@@ -6922,41 +7003,6 @@ package body Exp_Dist is\n                New_Occurrence_Of (Is_Local, Loc),\n                New_Occurrence_Of (Local_Address, Loc))));\n \n-         --  Determine whether the reference that was used to make\n-         --  the call was the base RCI reference (in which case\n-         --  Local_Address is 0, and the method identifier from the\n-         --  request must be used to determine which subprogram is\n-         --  called) or a reference identifying one particular subprogram\n-         --  (in which case Local_Address is the address of that\n-         --  subprogram, and the method name from the request is\n-         --  ignored).\n-         --  In each case, cascaded elsifs are used to determine the\n-         --  proper subprogram index. Using hash tables might be\n-         --  more efficient.\n-\n-         Append_To (Pkg_RPC_Receiver_Statements,\n-           Make_Implicit_If_Statement (Pkg_Spec,\n-             Condition =>\n-               Make_Op_Ne (Loc,\n-                 Left_Opnd  => New_Occurrence_Of (Local_Address, Loc),\n-                 Right_Opnd => New_Occurrence_Of (RTE (RE_Null_Address), Loc)),\n-             Then_Statements => New_List (\n-               Make_Implicit_If_Statement (Pkg_Spec,\n-                 Condition =>\n-                   New_Occurrence_Of (Standard_False, Loc),\n-                 Then_Statements => New_List (\n-                   Make_Null_Statement (Loc)),\n-                 Elsif_Parts =>\n-                   Dispatch_On_Address)),\n-             Else_Statements => New_List (\n-               Make_Implicit_If_Statement (Pkg_Spec,\n-                 Condition =>\n-                   New_Occurrence_Of (Standard_False, Loc),\n-                 Then_Statements => New_List (\n-                   Make_Null_Statement (Loc)),\n-                 Elsif_Parts =>\n-                   Dispatch_On_Name))));\n-\n          --  For each subprogram, the receiving stub will be built and a\n          --  case statement will be made on the Subprogram_Id to dispatch\n          --  to the right subprogram.\n@@ -7076,6 +7122,88 @@ package body Exp_Dist is\n             Next (Current_Declaration);\n          end loop;\n \n+         Append_To (Decls,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Subp_Info_Array,\n+             Constant_Present    => True,\n+             Aliased_Present     => True,\n+             Object_Definition   =>\n+               Make_Subtype_Indication (Loc,\n+                 Subtype_Mark =>\n+                   New_Occurrence_Of (RTE (RE_RCI_Subp_Info_Array), Loc),\n+                 Constraint =>\n+                   Make_Index_Or_Discriminant_Constraint (Loc,\n+                     New_List (\n+                       Make_Range (Loc,\n+                         Low_Bound  => Make_Integer_Literal (Loc,\n+                           First_RCI_Subprogram_Id),\n+                         High_Bound =>\n+                           Make_Integer_Literal (Loc,\n+                             First_RCI_Subprogram_Id\n+                             + List_Length (Subp_Info_List) - 1)))))));\n+\n+         if Present (First (Subp_Info_List)) then\n+            Set_Expression (Last (Decls),\n+              Make_Aggregate (Loc,\n+                Component_Associations => Subp_Info_List));\n+\n+            --  Generate the dispatch statement to determine the subprogram id\n+            --  of the called subprogram.\n+\n+            --  We first test whether the reference that was used to make the\n+            --  call was the base RCI reference (in which case Local_Address is\n+            --  zero, and the method identifier from the request must be used\n+            --  to determine which subprogram is called) or a reference\n+            --  identifying one particular subprogram (in which case\n+            --  Local_Address is the address of that subprogram, and the\n+            --  method name from the request is ignored). The latter occurs\n+            --  for the case of a call through a remote access-to-subprogram.\n+\n+            --  In each case, cascaded elsifs are used to determine the proper\n+            --  subprogram index. Using hash tables might be more efficient.\n+\n+            Append_To (Pkg_RPC_Receiver_Statements,\n+              Make_Implicit_If_Statement (Pkg_Spec,\n+                Condition =>\n+                  Make_Op_Ne (Loc,\n+                    Left_Opnd  => New_Occurrence_Of\n+                                    (Local_Address, Loc),\n+                    Right_Opnd => New_Occurrence_Of\n+                                    (RTE (RE_Null_Address), Loc)),\n+                Then_Statements => New_List (\n+                  Make_Implicit_If_Statement (Pkg_Spec,\n+                    Condition =>\n+                      New_Occurrence_Of (Standard_False, Loc),\n+                    Then_Statements => New_List (\n+                      Make_Null_Statement (Loc)),\n+                    Elsif_Parts =>\n+                      Dispatch_On_Address)),\n+\n+                Else_Statements => New_List (\n+                  Make_Implicit_If_Statement (Pkg_Spec,\n+                    Condition =>\n+                      New_Occurrence_Of (Standard_False, Loc),\n+                    Then_Statements => New_List (\n+                      Make_Null_Statement (Loc)),\n+                    Elsif_Parts =>\n+                      Dispatch_On_Name))));\n+\n+         else\n+            --  For a degenerate RCI with no visible subprograms,\n+            --  Subp_Info_List has zero length, and the declaration is for an\n+            --  empty array, in which case no initialization aggregate must be\n+            --  generated. We do not generate a Dispatch_Statement either.\n+\n+            --  No initialization provided: remove CONSTANT so that the\n+            --  declaration is not an incomplete deferred constant.\n+\n+            Set_Constant_Present (Last (Decls), False);\n+         end if;\n+\n+         --  Analyze Subp_Info_Array declaration\n+\n+         Analyze (Last (Decls));\n+\n          --  If we receive an invalid Subprogram_Id, it is best to do nothing\n          --  rather than raising an exception since we do not want someone\n          --  to crash a remote partition by sending invalid subprogram ids.\n@@ -7097,29 +7225,8 @@ package body Exp_Dist is\n                New_Occurrence_Of (Subp_Index, Loc),\n              Alternatives => Pkg_RPC_Receiver_Cases));\n \n-         Append_To (Decls,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Subp_Info_Array,\n-             Constant_Present    => True,\n-             Aliased_Present     => True,\n-             Object_Definition   =>\n-               Make_Subtype_Indication (Loc,\n-                 Subtype_Mark =>\n-                   New_Occurrence_Of (RTE (RE_RCI_Subp_Info_Array), Loc),\n-                 Constraint =>\n-                   Make_Index_Or_Discriminant_Constraint (Loc,\n-                     New_List (\n-                       Make_Range (Loc,\n-                         Low_Bound  => Make_Integer_Literal (Loc,\n-                           First_RCI_Subprogram_Id),\n-                         High_Bound =>\n-                           Make_Integer_Literal (Loc,\n-                             First_RCI_Subprogram_Id\n-                             + List_Length (Subp_Info_List) - 1))))),\n-             Expression          =>\n-               Make_Aggregate (Loc,\n-                 Component_Associations => Subp_Info_List)));\n-         Analyze (Last (Decls));\n+         --  Pkg_RPC_Receiver body is now complete: insert it into the tree and\n+         --  analyze it.\n \n          Append_To (Decls, Pkg_RPC_Receiver_Body);\n          Analyze (Last (Decls));\n@@ -8183,6 +8290,18 @@ package body Exp_Dist is\n                        Name                   => Called_Subprogram,\n                        Parameter_Associations => Parameter_List)));\n \n+               if Is_Class_Wide_Type (Etyp) then\n+\n+                  --  For a remote call to a function with a class-wide type,\n+                  --  check that the returned value satisfies the requirements\n+                  --  of E.4(18).\n+\n+                  Append_To (Inner_Decls,\n+                    Make_Transportable_Check (Loc,\n+                      New_Occurrence_Of (Result, Loc)));\n+\n+               end if;\n+\n                Set_Etype (Result, Etyp);\n                Append_To (After_Statements,\n                  Make_Procedure_Call_Statement (Loc,"}, {"sha": "41c4d3f2c94122068fe73aee677e1b02c23b4491", "filename": "gcc/ada/exp_dist.ads", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3d593c9d3e2716097a4feb03d16c92ba35f3fe7/gcc%2Fada%2Fexp_dist.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3d593c9d3e2716097a4feb03d16c92ba35f3fe7/gcc%2Fada%2Fexp_dist.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.ads?ref=c3d593c9d3e2716097a4feb03d16c92ba35f3fe7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,6 +27,7 @@\n --  This package contains utility routines used for the generation of the\n --  stubs relevant to the distribution annex.\n \n+with Namet; use Namet;\n with Types; use Types;\n \n package Exp_Dist is\n@@ -110,4 +111,12 @@ package Exp_Dist is\n    --  not be generated in the package spec because this would cause an\n    --  incorrect attempt to freeze Taft amendment types declared in the spec.\n \n+   function Make_Transportable_Check\n+     (Loc  : Source_Ptr;\n+      Expr : Node_Id) return Node_Id;\n+   --  Generate a check that the given expression (an actual in a remote\n+   --  subprogram call, or the return value of a function in the context of\n+   --  a remote call) satisfies the requirements for being transportable\n+   --  across partitions, raising Program_Error if it does not.\n+\n end Exp_Dist;"}]}