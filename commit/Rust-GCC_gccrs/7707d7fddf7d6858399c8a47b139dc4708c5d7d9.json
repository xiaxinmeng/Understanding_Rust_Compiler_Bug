{"sha": "7707d7fddf7d6858399c8a47b139dc4708c5d7d9", "node_id": "C_kwDOANBUbNoAKDc3MDdkN2ZkZGY3ZDY4NTgzOTljOGE0N2IxMzlkYzQ3MDhjNWQ3ZDk", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-05-23T07:47:42Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-05-23T07:47:42Z"}, "message": "Some additional ix86_rtx_costs clean-ups: NEG, AND, andn and pandn.\n\nDouble-word NOT requires two operations, but double-word NEG requires\nthree operations.  Using SSE, vector NOT requires a pxor with -1, but\nAND of NOT is cheap thanks to the existence of pandn.  There's also some\nlegacy (aka incorrect) logic explicitly testing for DImode [independently\nof TARGET_64BIT] in determining the cost of logic operations that's not\nrequired.\n\n2022-05-23  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\t* config/i386/i386.cc (ix86_rtx_costs) <case AND>: Split from\n\tXOR/IOR case.  Account for two instructions for double-word\n\toperations.  In case of vector pandn, account for single\n\tinstruction.  Likewise for integer andn with TARGET_BMI.\n\t<case NOT>: Vector NOT requires more than 1 instruction (pxor).\n\t<case NEG>: Double-word negation requires 3 instructions.", "tree": {"sha": "a426ea691f3525546d8b5bd081ddeca1b59ad1d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a426ea691f3525546d8b5bd081ddeca1b59ad1d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7707d7fddf7d6858399c8a47b139dc4708c5d7d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7707d7fddf7d6858399c8a47b139dc4708c5d7d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7707d7fddf7d6858399c8a47b139dc4708c5d7d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7707d7fddf7d6858399c8a47b139dc4708c5d7d9/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "075fb873c264a030f56793cb162c9fdecbdd1773", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/075fb873c264a030f56793cb162c9fdecbdd1773", "html_url": "https://github.com/Rust-GCC/gccrs/commit/075fb873c264a030f56793cb162c9fdecbdd1773"}], "stats": {"total": 133, "additions": 94, "deletions": 39}, "files": [{"sha": "daa60acdc0576ca16e123ca9bb2a917c42aa990f", "filename": "gcc/config/i386/i386.cc", "status": "modified", "additions": 94, "deletions": 39, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7707d7fddf7d6858399c8a47b139dc4708c5d7d9/gcc%2Fconfig%2Fi386%2Fi386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7707d7fddf7d6858399c8a47b139dc4708c5d7d9/gcc%2Fconfig%2Fi386%2Fi386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.cc?ref=7707d7fddf7d6858399c8a47b139dc4708c5d7d9", "patch": "@@ -20738,70 +20738,125 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n \t}\n \n       if (SSE_FLOAT_MODE_SSEMATH_OR_HF_P (mode))\n-\t{\n-\t  *total = cost->addss;\n-\t  return false;\n-\t}\n+\t*total = cost->addss;\n       else if (X87_FLOAT_MODE_P (mode))\n-\t{\n-\t  *total = cost->fadd;\n-\t  return false;\n-\t}\n+\t*total = cost->fadd;\n       else if (FLOAT_MODE_P (mode))\n-\t{\n-\t  *total = ix86_vec_cost (mode, cost->addss);\n-\t  return false;\n-\t}\n-      /* FALLTHRU */\n+\t*total = ix86_vec_cost (mode, cost->addss);\n+      else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+\t*total = ix86_vec_cost (mode, cost->sse_op);\n+      else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+\t*total = cost->add * 2;\n+      else\n+\t*total = cost->add;\n+      return false;\n \n-    case AND:\n     case IOR:\n     case XOR:\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+      if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+\t*total = ix86_vec_cost (mode, cost->sse_op);\n+      else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+\t*total = cost->add * 2;\n+      else\n+\t*total = cost->add;\n+      return false;\n+\n+    case AND:\n+      if (address_no_seg_operand (x, mode))\n \t{\n-\t  *total = (cost->add * 2\n-\t\t    + (rtx_cost (XEXP (x, 0), mode, outer_code, opno, speed)\n-\t\t       << (GET_MODE (XEXP (x, 0)) != DImode))\n-\t\t    + (rtx_cost (XEXP (x, 1), mode, outer_code, opno, speed)\n-\t               << (GET_MODE (XEXP (x, 1)) != DImode)));\n+\t  *total = cost->lea;\n \t  return true;\n \t}\n-      else if (code == AND\n-\t       && address_no_seg_operand (x, mode))\n+      else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n \t{\n-\t  *total = cost->lea;\n-\t  return true;\n+\t  /* pandn is a single instruction.  */\n+\t  if (GET_CODE (XEXP (x, 0)) == NOT)\n+\t    {\n+\t      *total = ix86_vec_cost (mode, cost->sse_op)\n+\t\t       + rtx_cost (XEXP (XEXP (x, 0), 0), mode,\n+\t\t\t\t   outer_code, opno, speed)\n+\t\t       + rtx_cost (XEXP (x, 1), mode,\n+\t\t\t\t   outer_code, opno, speed);\n+\t      return true;\n+\t    }\n+\t  else if (GET_CODE (XEXP (x, 1)) == NOT)\n+\t    {\n+\t      *total = ix86_vec_cost (mode, cost->sse_op)\n+\t\t       + rtx_cost (XEXP (x, 0), mode,\n+\t\t\t\t   outer_code, opno, speed)\n+\t\t       + rtx_cost (XEXP (XEXP (x, 1), 0), mode,\n+\t\t\t\t   outer_code, opno, speed);\n+\t      return true;\n+\t    }\n+\t  *total = ix86_vec_cost (mode, cost->sse_op);\n \t}\n-      /* FALLTHRU */\n-\n-    case NEG:\n-      if (SSE_FLOAT_MODE_SSEMATH_OR_HF_P (mode))\n+      else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n \t{\n-\t  *total = cost->sse_op;\n-\t  return false;\n+\t  if (TARGET_BMI && GET_CODE (XEXP (x,0)) == NOT)\n+\t    {\n+\t      *total = cost->add * 2\n+\t\t       + rtx_cost (XEXP (XEXP (x, 0), 0), mode,\n+\t\t\t\t   outer_code, opno, speed)\n+\t\t       + rtx_cost (XEXP (x, 1), mode,\n+\t\t\t\t   outer_code, opno, speed);\n+\t      return true;\n+\t    }\n+\t  else if (TARGET_BMI && GET_CODE (XEXP (x, 1)) == NOT)\n+\t    {\n+\t      *total = cost->add * 2\n+\t\t       + rtx_cost (XEXP (x, 0), mode,\n+\t\t\t\t   outer_code, opno, speed)\n+\t\t       + rtx_cost (XEXP (XEXP (x, 1), 0), mode,\n+\t\t\t\t   outer_code, opno, speed);\n+\t      return true;\n+\t    }\n+\t  *total = cost->add * 2;\n \t}\n-      else if (X87_FLOAT_MODE_P (mode))\n+      else if (TARGET_BMI && GET_CODE (XEXP (x,0)) == NOT)\n \t{\n-\t  *total = cost->fchs;\n-\t  return false;\n+\t  *total = cost->add\n+\t\t   + rtx_cost (XEXP (XEXP (x, 0), 0), mode,\n+\t\t\t       outer_code, opno, speed)\n+\t\t   + rtx_cost (XEXP (x, 1), mode, outer_code, opno, speed);\n+\t  return true;\n \t}\n-      else if (FLOAT_MODE_P (mode))\n+      else if (TARGET_BMI && GET_CODE (XEXP (x,1)) == NOT)\n \t{\n-\t  *total = ix86_vec_cost (mode, cost->sse_op);\n-\t  return false;\n+\t  *total = cost->add\n+\t\t   + rtx_cost (XEXP (x, 0), mode, outer_code, opno, speed)\n+\t\t   + rtx_cost (XEXP (XEXP (x, 1), 0), mode,\n+\t\t\t       outer_code, opno, speed);\n+\t  return true;\n \t}\n-      /* FALLTHRU */\n+      else\n+\t*total = cost->add;\n+      return false;\n \n     case NOT:\n       if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n-\t*total = ix86_vec_cost (mode, cost->sse_op);\n+\t// vnot is pxor -1.\n+\t*total = ix86_vec_cost (mode, cost->sse_op) + 1;\n       else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n \t*total = cost->add * 2;\n       else\n \t*total = cost->add;\n       return false;\n \n+    case NEG:\n+      if (SSE_FLOAT_MODE_SSEMATH_OR_HF_P (mode))\n+\t*total = cost->sse_op;\n+      else if (X87_FLOAT_MODE_P (mode))\n+\t*total = cost->fchs;\n+      else if (FLOAT_MODE_P (mode))\n+\t*total = ix86_vec_cost (mode, cost->sse_op);\n+      else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+\t*total = ix86_vec_cost (mode, cost->sse_op);\n+      else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+\t*total = cost->add * 3;\n+      else\n+\t*total = cost->add;\n+      return false;\n+\n     case COMPARE:\n       rtx op0, op1;\n       op0 = XEXP (x, 0);"}]}