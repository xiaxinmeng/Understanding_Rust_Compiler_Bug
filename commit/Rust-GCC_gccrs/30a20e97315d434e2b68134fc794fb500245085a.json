{"sha": "30a20e97315d434e2b68134fc794fb500245085a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBhMjBlOTczMTVkNDM0ZTJiNjgxMzRmYzc5NGZiNTAwMjQ1MDg1YQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2009-11-05T12:09:08Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2009-11-05T12:09:08Z"}, "message": "tree-sra.c (struct access): Changed comment of next_sibling field.\n\n2009-11-04  Martin Jambor  <mjambor@suse.cz>\n\n\t* tree-sra.c (struct access): Changed comment of next_sibling field.\n\t(analyze_modified_params): Loop over accesses of a group rather than\n\tover all with the ame base, pass a common bitmap to\n\twalk_aliased_vdefs.\n\t(unmodified_by_ref_scalar_representative): Build link lists of\n\taccesses of a group.\n\t(splice_param_accesses): Likewise.\n\nFrom-SVN: r153935", "tree": {"sha": "8814059ab8c3a70f3b8109e41082e68eb64718c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8814059ab8c3a70f3b8109e41082e68eb64718c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30a20e97315d434e2b68134fc794fb500245085a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30a20e97315d434e2b68134fc794fb500245085a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30a20e97315d434e2b68134fc794fb500245085a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30a20e97315d434e2b68134fc794fb500245085a/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8bae6273fbc016a8f055ee90baa824a21c285b6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bae6273fbc016a8f055ee90baa824a21c285b6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bae6273fbc016a8f055ee90baa824a21c285b6a"}], "stats": {"total": 62, "additions": 39, "deletions": 23}, "files": [{"sha": "dd3fa834e2b1116deae81eec045fb3db4315a955", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30a20e97315d434e2b68134fc794fb500245085a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30a20e97315d434e2b68134fc794fb500245085a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30a20e97315d434e2b68134fc794fb500245085a", "patch": "@@ -1,3 +1,13 @@\n+2009-11-05  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* tree-sra.c (struct access): Changed comment of next_sibling field.\n+\t(analyze_modified_params): Loop over accesses of a group rather than\n+\tover all with the ame base, pass a common bitmap to\n+\twalk_aliased_vdefs.\n+\t(unmodified_by_ref_scalar_representative): Build link lists of\n+\taccesses of a group.\n+\t(splice_param_accesses): Likewise.\n+\n 2009-11-04  Kenneth Zadeck  <zadeck@naturalbridge.com>\n \n \t* df-scan.c (df-uses-record): Add case zero_extract of mem."}, {"sha": "67001a6456477718edbb73120008c4400c3101e4", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30a20e97315d434e2b68134fc794fb500245085a/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30a20e97315d434e2b68134fc794fb500245085a/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=30a20e97315d434e2b68134fc794fb500245085a", "patch": "@@ -144,7 +144,9 @@ struct access\n      points to the first one.  */\n   struct access *first_child;\n \n-  /* Pointer to the next sibling in the access tree as described above.  */\n+  /* In intraprocedural SRA, pointer to the next sibling in the access tree as\n+     described above.  In IPA-SRA this is a pointer to the next access\n+     belonging to the same group (having the same representative).  */\n   struct access *next_sibling;\n \n   /* Pointers to the first and last element in the linked list of assign\n@@ -2824,33 +2826,28 @@ analyze_modified_params (VEC (access_p, heap) *representatives)\n \t   repr;\n \t   repr = repr->next_grp)\n \t{\n-\t  VEC (access_p, heap) *access_vec;\n-\t  int j, access_count;\n-\t  tree parm;\n+\t  struct access *access;\n+\t  bitmap visited;\n+\t  ao_ref ar;\n \n \t  if (no_accesses_p (repr))\n \t    continue;\n-\t  parm = repr->base;\n-\t  if (!POINTER_TYPE_P (TREE_TYPE (parm))\n+\t  if (!POINTER_TYPE_P (TREE_TYPE (repr->base))\n \t      || repr->grp_maybe_modified)\n \t    continue;\n \n-\t  access_vec = get_base_access_vector (parm);\n-\t  access_count = VEC_length (access_p, access_vec);\n-\t  for (j = 0; j < access_count; j++)\n+\t  ao_ref_init (&ar, repr->expr);\n+\t  visited = BITMAP_ALLOC (NULL);\n+\t  for (access = repr; access; access = access->next_sibling)\n \t    {\n-\t      struct access *access;\n-\t      ao_ref ar;\n-\n \t      /* All accesses are read ones, otherwise grp_maybe_modified would\n \t\t be trivially set.  */\n-\t      access = VEC_index (access_p, access_vec, j);\n-\t      ao_ref_init (&ar, access->expr);\n \t      walk_aliased_vdefs (&ar, gimple_vuse (access->stmt),\n-\t\t\t\t  mark_maybe_modified, repr, NULL);\n+\t\t\t\t  mark_maybe_modified, repr, &visited);\n \t      if (repr->grp_maybe_modified)\n \t\tbreak;\n \t    }\n+\t  BITMAP_FREE (visited);\n \t}\n     }\n }\n@@ -3019,24 +3016,30 @@ static struct access *\n unmodified_by_ref_scalar_representative (tree parm)\n {\n   int i, access_count;\n-  struct access *access;\n+  struct access *repr;\n   VEC (access_p, heap) *access_vec;\n \n   access_vec = get_base_access_vector (parm);\n   gcc_assert (access_vec);\n-  access_count = VEC_length (access_p, access_vec);\n+  repr = VEC_index (access_p, access_vec, 0);\n+  if (repr->write)\n+    return NULL;\n+  repr->group_representative = repr;\n \n-  for (i = 0; i < access_count; i++)\n+  access_count = VEC_length (access_p, access_vec);\n+  for (i = 1; i < access_count; i++)\n     {\n-      access = VEC_index (access_p, access_vec, i);\n+      struct access *access = VEC_index (access_p, access_vec, i);\n       if (access->write)\n \treturn NULL;\n+      access->group_representative = repr;\n+      access->next_sibling = repr->next_sibling;\n+      repr->next_sibling = access;\n     }\n \n-  access = VEC_index (access_p, access_vec, 0);\n-  access->grp_read = 1;\n-  access->grp_scalar_ptr = 1;\n-  return access;\n+  repr->grp_read = 1;\n+  repr->grp_scalar_ptr = 1;\n+  return repr;\n }\n \n /* Sort collected accesses for parameter PARM, identify representatives for\n@@ -3091,6 +3094,9 @@ splice_param_accesses (tree parm, bool *ro_grp)\n \t    return NULL;\n \n \t  modification |= ac2->write;\n+\t  ac2->group_representative = access;\n+\t  ac2->next_sibling = access->next_sibling;\n+\t  access->next_sibling = ac2;\n \t  j++;\n \t}\n "}]}