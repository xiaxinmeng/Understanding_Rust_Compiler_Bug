{"sha": "7de5bcccabe7577efb9e734e5534a2318b1f3703", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RlNWJjY2NhYmU3NTc3ZWZiOWU3MzRlNTUzNGEyMzE4YjFmMzcwMw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-07-08T09:39:17Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-07-08T09:39:17Z"}, "message": "vec.c (vec_p_reserve, [...]): Allocation is signed.\n\n.:\t* vec.c (vec_p_reserve, vec_o_reserve): Allocation is signed.\n\t* vec.h (VEC_alloc, VEC_embedded_size, VEC_embedded_init):\n\tAllocation is signed.\n\t(VEC_reserve): Return flag, allocation is signed.\ncp:\n\t* name-lookup.c (push_binding): Use VEC_reserve.\n\nFrom-SVN: r84281", "tree": {"sha": "2700bf7cb28064eaba654eed36d38552e0016572", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2700bf7cb28064eaba654eed36d38552e0016572"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7de5bcccabe7577efb9e734e5534a2318b1f3703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7de5bcccabe7577efb9e734e5534a2318b1f3703", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7de5bcccabe7577efb9e734e5534a2318b1f3703", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7de5bcccabe7577efb9e734e5534a2318b1f3703/comments", "author": null, "committer": null, "parents": [{"sha": "5df6d966d388fc0c7aae3653f72b37a4c4473646", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5df6d966d388fc0c7aae3653f72b37a4c4473646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5df6d966d388fc0c7aae3653f72b37a4c4473646"}], "stats": {"total": 162, "additions": 95, "deletions": 67}, "files": [{"sha": "9baf0be323b9b73f6352c5de6d9b28d7d83c90e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de5bcccabe7577efb9e734e5534a2318b1f3703/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de5bcccabe7577efb9e734e5534a2318b1f3703/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7de5bcccabe7577efb9e734e5534a2318b1f3703", "patch": "@@ -1,3 +1,10 @@\n+2004-07-08  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* vec.c (vec_p_reserve, vec_o_reserve): Allocation is signed.\n+\t* vec.h (VEC_alloc, VEC_embedded_size, VEC_embedded_init):\n+\tAllocation is signed.\n+\t(VEC_reserve): Return flag, allocation is signed.\n+\n 2004-07-08  Richard Henderson  <rth@redhat.com>\n \n \t* tree-ssa-ccp.c (fold_stmt): Get type directly from"}, {"sha": "8b0bc21a1fe719e859de28bbaf1bbf88e395b944", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de5bcccabe7577efb9e734e5534a2318b1f3703/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de5bcccabe7577efb9e734e5534a2318b1f3703/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7de5bcccabe7577efb9e734e5534a2318b1f3703", "patch": "@@ -1,3 +1,7 @@\n+2004-07-08  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* name-lookup.c (push_binding): Use VEC_reserve.\n+\n 2004-07-08  Richard Henderson  <rth@redhat.com>\n \n \t* cp-tree.h (expand_eh_spec_block): Remove."}, {"sha": "b0708002ae7541ab84cd0c8d48000fade9de2f6c", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de5bcccabe7577efb9e734e5534a2318b1f3703/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de5bcccabe7577efb9e734e5534a2318b1f3703/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=7de5bcccabe7577efb9e734e5534a2318b1f3703", "patch": "@@ -381,22 +381,22 @@ push_binding (tree id, tree decl, cxx_scope* level)\n   else\n     {\n       cp_class_binding *cb;\n-      size_t length;\n-      size_t i;\n-      bool need_fixup;\n \n-      length = VEC_length (cp_class_binding, level->class_shadowed);\n-      need_fixup = (length && length == level->class_shadowed->alloc);\n-      cb = VEC_safe_push (cp_class_binding, level->class_shadowed, NULL);\n+      if (VEC_reserve (cp_class_binding, level->class_shadowed, -1))\n+\t{\n+\t  /* Fixup the current bindings, as they might have moved.  */\n+\t  size_t i;\n+\t  \n+\t  for (i = 0;\n+\t       (cb = VEC_iterate (cp_class_binding, level->class_shadowed, i));\n+\t       i++)\n+\t    IDENTIFIER_BINDING (cb->identifier) = &cb->base;\n+\t}\n+\n+      cb = VEC_quick_push (cp_class_binding, level->class_shadowed, NULL);\n       cb->identifier = id;\n       binding = &cb->base;\n       cxx_binding_init (binding, decl, NULL_TREE);\n-      if (need_fixup)\n-\tfor (i = 0; i < length; ++i)\n-\t  {\n-\t    cb = VEC_index (cp_class_binding, level->class_shadowed, i);\n-\t    IDENTIFIER_BINDING (cb->identifier) = &cb->base;\n-\t  }\n     }\n \t\t\t      \n   /* Now, fill in the binding information.  */"}, {"sha": "9d1d8b2d2577d70de3e724af82dcbfb623a5a24d", "filename": "gcc/vec.c", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de5bcccabe7577efb9e734e5534a2318b1f3703/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de5bcccabe7577efb9e734e5534a2318b1f3703/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=7de5bcccabe7577efb9e734e5534a2318b1f3703", "patch": "@@ -34,44 +34,45 @@ struct vec_prefix\n   void *vec[1];\n };\n \n-/* Ensure there are at least RESERVE free slots in VEC, if RESERVE !=\n-   ~0u. If RESERVE == ~0u increase the current allocation\n-   exponentially.  VEC can be NULL, to create a new vector.  */\n+/* Ensure there are at least RESERVE free slots in VEC, if RESERVE >=\n+   0.  If RESERVE < 0 increase the current allocation exponentially.\n+   VEC can be NULL, to create a new vector.  */\n \n void *\n-vec_p_reserve (void *vec, size_t reserve MEM_STAT_DECL)\n+vec_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n {\n   return vec_o_reserve (vec, reserve,\n \t\t\toffsetof (struct vec_prefix, vec), sizeof (void *)\n \t\t\tPASS_MEM_STAT);\n }\n \n-/* Ensure there are at least RESERVE free slots in VEC, if RESERVE !=\n-   ~0u.  If RESERVE == ~0u, increase the current allocation\n-   exponentially.  VEC can be NULL, in which case a new vector is\n-   created.  The vector's trailing array is at VEC_OFFSET offset and\n-   consistes of ELT_SIZE sized elements.  */\n+/* Ensure there are at least RESERVE free slots in VEC, if RESERVE >=\n+   0.  If RESERVE < 0, increase the current allocation exponentially.\n+   VEC can be NULL, in which case a new vector is created.  The\n+   vector's trailing array is at VEC_OFFSET offset and consistes of\n+   ELT_SIZE sized elements.  */\n \n void *\n-vec_o_reserve (void *vec, size_t reserve, size_t vec_offset, size_t elt_size\n+vec_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n \t       MEM_STAT_DECL)\n {\n   struct vec_prefix *pfx = vec;\n-  size_t alloc;\n+  size_t alloc = pfx ? pfx->num : 0;\n \n-  if (reserve + 1)\n-    alloc = (pfx ? pfx->num : 0) + reserve;\n+  if (reserve >= 0)\n+    alloc += reserve;\n+  else if (alloc)\n+    alloc *= 2;\n   else\n-    alloc = pfx ? pfx->alloc * 2 : 4;\n+    alloc = 4;\n+\n+  if (pfx && pfx->alloc >= alloc)\n+    abort ();\n   \n-  if (!pfx || pfx->alloc < alloc)\n-    {\n-      vec = ggc_realloc_stat (vec, vec_offset + alloc * elt_size\n-\t\t\t      PASS_MEM_STAT);\n-      ((struct vec_prefix *)vec)->alloc = alloc;\n-      if (!pfx)\n-\t((struct vec_prefix *)vec)->num = 0;\n-    }\n+  vec = ggc_realloc_stat (vec, vec_offset + alloc * elt_size PASS_MEM_STAT);\n+  ((struct vec_prefix *)vec)->alloc = alloc;\n+  if (!pfx)\n+    ((struct vec_prefix *)vec)->num = 0;\n   \n   return vec;\n }"}, {"sha": "84b8dbf978b90f30e00cffeeea971f94e05f03e0", "filename": "gcc/vec.h", "status": "modified", "additions": 49, "deletions": 33, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de5bcccabe7577efb9e734e5534a2318b1f3703/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de5bcccabe7577efb9e734e5534a2318b1f3703/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=7de5bcccabe7577efb9e734e5534a2318b1f3703", "patch": "@@ -58,7 +58,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    vector, if needed.  Reallocation causes an exponential increase in\n    vector size.  If you know you will be adding N elements, it would\n    be more efficient to use the reserve operation before adding the\n-   elements with the 'quick' operation.\n+   elements with the 'quick' operation.  You may also use the reserve\n+   operation with a -1 operand, to gain control over exactly when\n+   reallocation occurs.\n \n    You should prefer the push and pop operations, as they append and\n    remove from the end of the vector. If you need to remove several\n@@ -132,27 +134,33 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define VEC_iterate(TDEF,V,I)\t\t(VEC_OP(TDEF,iterate)(V,I))\n \n /* Allocate new vector.\n-   VEC(T) *VEC_T_alloc(size_t reserve);\n+   VEC(T) *VEC_T_alloc(int reserve);\n \n-   Allocate a new vector with space for RESERVE objects.  */\n+   Allocate a new vector with space for RESERVE objects.  If RESERVE\n+   is <= 0, a default number of slots are created.  */\n #define VEC_alloc(TDEF,A)\t\t(VEC_OP(TDEF,alloc)(A MEM_STAT_INFO))\n \n /* Use these to determine the required size and initialization of a\n    vector embedded within another structure (as the final member).\n    \n-   size_t VEC_T_embedded_size(size_t reserve);\n-   void VEC_T_embedded_init(VEC(T) *v, size_t reserve);\n+   size_t VEC_T_embedded_size(int reserve);\n+   void VEC_T_embedded_init(VEC(T) *v, int reserve);\n    \n    These allow the caller to perform the memory allocation.  */\n #define VEC_embedded_size(TDEF,A) (VEC_OP(TDEF,embedded_size)(A))\n #define VEC_embedded_init(TDEF,O,A) (VEC_OP(TDEF,embedded_init)(O,A))\n \n /* Reserve space.\n-   void VEC_T_reserve(VEC(T) *&v, size_t reserve);\n+   int VEC_T_reserve(VEC(T) *&v, int reserve);\n \n-   Ensure that V has at least RESERVE slots available.  Note this can\n-   cause V to be reallocated.  */\n-#define VEC_reserve(TDEF,V,R)\t\t(VEC_OP(TDEF,reserve)(&(V),R MEM_STAT_INFO))\n+   Ensure that V has at least RESERVE slots available, if RESERVE is\n+   >= 0.  If RESERVE < 0, ensure that there is at least one spare\n+   slot.  These differ in their reallocation behaviour, the first will\n+   not create additionsl headroom, but the second mechanism will\n+   perform the usual exponential headroom increase.  Note this can\n+   cause V to be reallocated.  Returns non-zero iff reallocation\n+   actually occurred.  */\n+#define VEC_reserve(TDEF,V,R)\t(VEC_OP(TDEF,reserve)(&(V),R MEM_STAT_INFO))\n \n /* Push object with no reallocation\n    T *VEC_T_quick_push (VEC(T) *v, T obj); // Pointer\n@@ -238,8 +246,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #if !IN_GENGTYPE\n /* Reallocate an array of elements with prefix.  */\n-extern void *vec_p_reserve (void *, size_t MEM_STAT_DECL);\n-extern void *vec_o_reserve (void *, size_t, size_t, size_t MEM_STAT_DECL);\n+extern void *vec_p_reserve (void *, int MEM_STAT_DECL);\n+extern void *vec_o_reserve (void *, int, size_t, size_t MEM_STAT_DECL);\n \n #if ENABLE_CHECKING\n extern void vec_assert_fail (const char *, const char *,\n@@ -310,28 +318,34 @@ static inline TDEF VEC_OP (TDEF,iterate)\t\t  \t     \t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline VEC (TDEF) *VEC_OP (TDEF,alloc MEM_STAT_DECL)\t\t  \\\n-     (size_t alloc_)\t\t\t\t\t\t\t  \\\n+     (int alloc_)\t\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   return vec_p_reserve (NULL, alloc_ - !alloc_ PASS_MEM_STAT);\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline size_t VEC_OP (TDEF,embedded_size)\t\t\t  \\\n-     (size_t alloc_)\t\t\t\t\t\t\t  \\\n+     (int alloc_)\t\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   return offsetof (VEC(TDEF),vec) + alloc_ * sizeof(TDEF);\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (TDEF,embedded_init)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, size_t alloc_)\t\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, int alloc_)\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   vec_->num = 0;\t\t\t\t\t\t\t  \\\n   vec_->alloc = alloc_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (TDEF,reserve)\t       \t\t\t  \\\n-     (VEC (TDEF) **vec_, size_t alloc_ MEM_STAT_DECL)\t\t\t  \\\n+static inline int VEC_OP (TDEF,reserve)\t       \t\t\t\t  \\\n+     (VEC (TDEF) **vec_, int alloc_ MEM_STAT_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  *vec_ = vec_p_reserve (*vec_, alloc_ PASS_MEM_STAT);\t\t\t  \\\n+  int extend = !*vec_ || ((*vec_)->alloc - (*vec_)->num\t\t\t  \\\n+\t\t\t  < (size_t)(alloc_ < 0 ? 1 : alloc_));\t\t  \\\n+\t\t  \t\t\t\t\t\t\t  \\\n+  if (extend)\t  \t\t\t\t\t\t\t  \\\n+    *vec_ = vec_p_reserve (*vec_, alloc_ PASS_MEM_STAT);\t\t  \\\n+\t\t  \t\t\t\t\t\t\t  \\\n+  return extend;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,quick_push)\t\t\t\t  \\\n@@ -349,8 +363,7 @@ static inline TDEF *VEC_OP (TDEF,quick_push)\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,safe_push)\t\t\t\t  \\\n      (VEC (TDEF) **vec_, TDEF obj_ MEM_STAT_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  if (!*vec_ || (*vec_)->num == (*vec_)->alloc)\t\t\t\t  \\\n-    VEC_OP (TDEF,reserve) (vec_, ~(size_t)0 PASS_MEM_STAT);\t\t  \\\n+  VEC_OP (TDEF,reserve) (vec_, -1 PASS_MEM_STAT);\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return VEC_OP (TDEF,quick_push) (*vec_, obj_);\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n@@ -402,8 +415,7 @@ static inline TDEF *VEC_OP (TDEF,quick_insert)\t\t     \t  \t  \\\n static inline TDEF *VEC_OP (TDEF,safe_insert)\t\t     \t  \t  \\\n      (VEC (TDEF) **vec_, size_t ix_, TDEF obj_ MEM_STAT_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  if (!*vec_ || (*vec_)->num == (*vec_)->alloc)\t\t\t\t  \\\n-    VEC_OP (TDEF,reserve) (vec_, ~(size_t)0 PASS_MEM_STAT);\t\t  \\\n+  VEC_OP (TDEF,reserve) (vec_, -1 PASS_MEM_STAT);\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return VEC_OP (TDEF,quick_insert) (*vec_, ix_, obj_);\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n@@ -476,32 +488,38 @@ static inline TDEF *VEC_OP (TDEF,iterate)\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline VEC (TDEF) *VEC_OP (TDEF,alloc)      \t\t\t  \\\n-     (size_t alloc_ MEM_STAT_DECL)\t\t\t\t\t  \\\n+     (int alloc_ MEM_STAT_DECL)\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   return vec_o_reserve (NULL, alloc_ - !alloc_,\t\t\t\t  \\\n \t\t\toffsetof (VEC(TDEF),vec), sizeof (TDEF)\t\t  \\\n \t\t\tPASS_MEM_STAT);\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline size_t VEC_OP (TDEF,embedded_size)\t\t\t  \\\n-     (size_t alloc_)\t\t\t\t\t\t\t  \\\n+     (int alloc_)\t\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   return offsetof (VEC(TDEF),vec) + alloc_ * sizeof(TDEF);\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (TDEF,embedded_init)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, size_t alloc_)\t\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, int alloc_)\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   vec_->num = 0;\t\t\t\t\t\t\t  \\\n   vec_->alloc = alloc_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (TDEF,reserve)\t       \t\t\t  \\\n-     (VEC (TDEF) **vec_, size_t alloc_ MEM_STAT_DECL)\t\t\t  \\\n+static inline int VEC_OP (TDEF,reserve)\t   \t    \t\t\t  \\\n+     (VEC (TDEF) **vec_, int alloc_ MEM_STAT_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  *vec_ = vec_o_reserve (*vec_, alloc_,\t\t\t\t\t  \\\n-\t\t\t offsetof (VEC(TDEF),vec), sizeof (TDEF)\t  \\\n-\t\t\t PASS_MEM_STAT);\t\t\t\t  \\\n+  int extend = !*vec_ || ((*vec_)->alloc - (*vec_)->num\t\t\t  \\\n+\t\t\t  < (size_t)(alloc_ < 0 ? 1 : alloc_));\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  if (extend)\t\t\t\t\t\t\t\t  \\\n+    *vec_ = vec_o_reserve (*vec_, alloc_,\t\t\t\t  \\\n+\t\t\t   offsetof (VEC(TDEF),vec), sizeof (TDEF)\t  \\\n+\t\t\t   PASS_MEM_STAT);\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return extend;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,quick_push)\t\t\t\t  \\\n@@ -520,8 +538,7 @@ static inline TDEF *VEC_OP (TDEF,quick_push)\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,safe_push)\t\t\t\t  \\\n      (VEC (TDEF) **vec_, const TDEF *obj_ MEM_STAT_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  if (!*vec_ || (*vec_)->num == (*vec_)->alloc)\t\t\t\t  \\\n-    VEC_OP (TDEF,reserve) (vec_, ~(size_t)0 PASS_MEM_STAT);\t\t  \\\n+  VEC_OP (TDEF,reserve) (vec_, -1 PASS_MEM_STAT);\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return VEC_OP (TDEF,quick_push) (*vec_, obj_);\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n@@ -571,8 +588,7 @@ static inline TDEF *VEC_OP (TDEF,quick_insert)\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,safe_insert)\t\t     \t  \t  \\\n      (VEC (TDEF) **vec_, size_t ix_, const TDEF *obj_ MEM_STAT_DECL)\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  if (!*vec_ || (*vec_)->num == (*vec_)->alloc)\t\t\t\t  \\\n-    VEC_OP (TDEF,reserve) (vec_, ~(size_t)0 PASS_MEM_STAT);\t\t  \\\n+  VEC_OP (TDEF,reserve) (vec_, -1 PASS_MEM_STAT);\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return VEC_OP (TDEF,quick_insert) (*vec_, ix_, obj_);\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\"}]}