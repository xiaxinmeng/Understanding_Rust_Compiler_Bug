{"sha": "5025a549a1e8387b314c36f24a0de8f8af7bcd1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAyNWE1NDlhMWU4Mzg3YjMxNGMzNmYyNGEwZGU4ZjhhZjdiY2QxZg==", "commit": {"author": {"name": "David Mosberger", "email": "davidm@hpl.hp.com", "date": "2002-03-15T01:55:49Z"}, "committer": {"name": "Hans Boehm", "email": "hboehm@gcc.gnu.org", "date": "2002-03-15T01:55:49Z"}, "message": "unwind-ia64.c: Handle copy_state and label_state descriptors correctly.\n\n\t* config/ia64/unwind-ia64.c: Handle copy_state and label_state\n\t  descriptors correctly.\n\nFrom-SVN: r50789", "tree": {"sha": "37c5df43f20092428f156e31511098dd0f6683ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37c5df43f20092428f156e31511098dd0f6683ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5025a549a1e8387b314c36f24a0de8f8af7bcd1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5025a549a1e8387b314c36f24a0de8f8af7bcd1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5025a549a1e8387b314c36f24a0de8f8af7bcd1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5025a549a1e8387b314c36f24a0de8f8af7bcd1f/comments", "author": null, "committer": null, "parents": [{"sha": "03e9dbc91c347697d6eecbd5154a545b56349157", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03e9dbc91c347697d6eecbd5154a545b56349157", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03e9dbc91c347697d6eecbd5154a545b56349157"}], "stats": {"total": 100, "additions": 77, "deletions": 23}, "files": [{"sha": "d003e7c71149f67650ebf30f7cdf9ec790cf78df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5025a549a1e8387b314c36f24a0de8f8af7bcd1f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5025a549a1e8387b314c36f24a0de8f8af7bcd1f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5025a549a1e8387b314c36f24a0de8f8af7bcd1f", "patch": "@@ -1,3 +1,8 @@\n+2002-03-14  David Mosberger <davidm@hpl.hp.com>, Hans Boehm <Hans_Boehm@hp.com>\n+\n+\t* config/ia64/unwind-ia64.c: Handle copy_state and label_state\n+\t  descriptors correctly.\n+\n 2002-03-14  Michael Meissner  <meissner@redhat.com>\n \n \t* params.def (PARAM_MAX_UNROLLED_INSNS): New macro, default to"}, {"sha": "b9bcf48784af4ad044cc9be6055df33cb29385a2", "filename": "gcc/config/ia64/unwind-ia64.c", "status": "modified", "additions": 72, "deletions": 23, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5025a549a1e8387b314c36f24a0de8f8af7bcd1f/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5025a549a1e8387b314c36f24a0de8f8af7bcd1f/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Funwind-ia64.c?ref=5025a549a1e8387b314c36f24a0de8f8af7bcd1f", "patch": "@@ -121,6 +121,17 @@ struct unw_reg_info\n   int when;\t\t\t/* when the register gets saved */\n };\n \n+struct unw_reg_state {\n+\tstruct unw_reg_state *next;\t/* next (outer) element on state stack */\n+\tstruct unw_reg_info reg[UNW_NUM_REGS];\t/* register save locations */\n+};\n+\n+struct unw_labeled_state {\n+\tstruct unw_labeled_state *next;\t\t/* next labeled state (or NULL) */\n+\tunsigned long label;\t\t\t/* label for this state */\n+\tstruct unw_reg_state saved_state;\n+};\n+\n typedef struct unw_state_record\n {\n   unsigned int first_region : 1;\t/* is this the first region? */\n@@ -141,11 +152,8 @@ typedef struct unw_state_record\n   unsigned char gr_save_loc;\t/* next general register to use for saving */\n   unsigned char return_link_reg; /* branch register for return link */\n \n-  struct unw_reg_state {\n-    struct unw_reg_state *next;\n-    unsigned long label;\t/* label of this state record */\n-    struct unw_reg_info reg[UNW_NUM_REGS];\n-  } curr, *stack, *reg_state_list;\n+  struct unw_labeled_state *labeled_states;\t/* list of all labeled states */\n+  struct unw_reg_state curr;\t/* current state */\n \n   _Unwind_Personality_Fn personality;\n   \n@@ -226,7 +234,7 @@ static unsigned char const save_order[] =\n \f\n #define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n \n-/* Unwind decoder routines */\n+/* Routines to manipulate the state stack.  */\n \n static void\n push (struct unw_state_record *sr)\n@@ -235,20 +243,56 @@ push (struct unw_state_record *sr)\n \n   rs = malloc (sizeof (struct unw_reg_state));\n   memcpy (rs, &sr->curr, sizeof (*rs));\n-  rs->next = sr->stack;\n-  sr->stack = rs;\n+  sr->curr.next = rs;\n }\n \n static void\n pop (struct unw_state_record *sr)\n {\n-  struct unw_reg_state *rs;\n+  struct unw_reg_state *rs = sr->curr.next;\n \n-  rs = sr->stack;\n-  sr->stack = rs->next;\n+  if (!rs)\n+    abort();\n+  memcpy(&sr->curr, rs, sizeof(*rs));\n   free (rs);\n }\n \n+/* Make a copy of the state stack.  Non-recursive to avoid stack overflows.  */\n+static struct unw_reg_state *\n+dup_state_stack (struct unw_reg_state *rs)\n+{\n+  struct unw_reg_state *copy, *prev = NULL, *first = NULL;\n+\n+  while (rs)\n+    {\n+      copy = malloc(sizeof(struct unw_state_record));\n+      memcpy(copy, rs, sizeof(*copy));\n+      if (first)\n+\tprev->next = copy;\n+      else\n+\tfirst = copy;\n+      rs = rs->next;\n+      prev = copy;\n+    }\n+  return first;\n+}\n+\n+/* Free all stacked register states (but not RS itself).  */\n+static void\n+free_state_stack (struct unw_reg_state *rs)\n+{\n+  struct unw_reg_state *p, *next;\n+\n+  for (p = rs->next; p != NULL; p = next)\n+    {\n+      next = p->next;\n+      free(p);\n+    }\n+  rs->next = NULL;\n+}\n+\f\n+/* Unwind decoder routines */\n+\n static enum unw_register_index __attribute__((const))\n decode_abreg (unsigned char abreg, int memory)\n {\n@@ -396,7 +440,7 @@ desc_prologue (int body, unw_word rlen, unsigned char mask,\n   sr->first_region = 0;\n \n   /* Check if we're done.  */\n-  if (body && sr->when_target < sr->region_start + sr->region_len)\n+  if (sr->when_target < sr->region_start + sr->region_len) \n     {\n       sr->done = 1;\n       return;\n@@ -631,13 +675,15 @@ desc_epilogue (unw_word t, unw_word ecount, struct unw_state_record *sr)\n static inline void\n desc_copy_state (unw_word label, struct unw_state_record *sr)\n {\n-  struct unw_reg_state *rs;\n+  struct unw_labeled_state *ls;\n \n-  for (rs = sr->reg_state_list; rs; rs = rs->next)\n+  for (ls = sr->labeled_states; ls; ls = ls->next)\n     {\n-      if (rs->label == label)\n-\t{\n-\t  memcpy (&sr->curr, rs, sizeof(sr->curr));\n+      if (ls->label == label)\n+        {\n+\t  free_state_stack(&sr->curr);\n+   \t  memcpy(&sr->curr, &ls->saved_state, sizeof(sr->curr));\n+\t  sr->curr.next = dup_state_stack(ls->saved_state.next);\n \t  return;\n \t}\n     }\n@@ -647,13 +693,16 @@ desc_copy_state (unw_word label, struct unw_state_record *sr)\n static inline void\n desc_label_state (unw_word label, struct unw_state_record *sr)\n {\n-  struct unw_reg_state *rs;\n+  struct unw_labeled_state *ls;\n \n-  rs = malloc (sizeof (struct unw_reg_state));\n-  memcpy (rs, &sr->curr, sizeof (*rs));\n-  rs->label = label;\n-  rs->next = sr->reg_state_list;\n-  sr->reg_state_list = rs;\n+  ls = malloc(sizeof(struct unw_labeled_state));\n+  ls->label = label;\n+  memcpy(&ls->saved_state, &sr->curr, sizeof(ls->saved_state));\n+  ls->saved_state.next = dup_state_stack(sr->curr.next);\n+\n+  /* insert into list of labeled states: */\n+  ls->next = sr->labeled_states;\n+  sr->labeled_states = ls;\n }\n \n /*"}]}