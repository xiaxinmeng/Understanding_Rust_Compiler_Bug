{"sha": "c414ac1d704c156056ff4e2b86f6f98ee0416580", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQxNGFjMWQ3MDRjMTU2MDU2ZmY0ZTJiODZmNmY5OGVlMDQxNjU4MA==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2005-08-19T21:20:02Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2005-08-19T21:20:02Z"}, "message": "optabs.h: Change CTI_ to COI_.\n\n2005-08-19  Eric Christopher  <echristo@apple.com>\n\n        * optabs.h: Change CTI_ to COI_.\n        * optabs.c: Ditto.\n\nFrom-SVN: r103295", "tree": {"sha": "098fc740187e8923e5cf7ecea380c849688f26c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/098fc740187e8923e5cf7ecea380c849688f26c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c414ac1d704c156056ff4e2b86f6f98ee0416580", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c414ac1d704c156056ff4e2b86f6f98ee0416580", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c414ac1d704c156056ff4e2b86f6f98ee0416580", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c414ac1d704c156056ff4e2b86f6f98ee0416580/comments", "author": null, "committer": null, "parents": [{"sha": "c8f27794b81ede496c04086105ff1a572ccfca47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8f27794b81ede496c04086105ff1a572ccfca47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8f27794b81ede496c04086105ff1a572ccfca47"}], "stats": {"total": 151, "additions": 78, "deletions": 73}, "files": [{"sha": "ea13f3822498e42adcf64909a78fe1b738e68b67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c414ac1d704c156056ff4e2b86f6f98ee0416580/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c414ac1d704c156056ff4e2b86f6f98ee0416580/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c414ac1d704c156056ff4e2b86f6f98ee0416580", "patch": "@@ -1,3 +1,8 @@\n+2005-08-19  Eric Christopher  <echristo@apple.com>\n+\n+\t* optabs.h: Change CTI_ to COI_.\n+\t* optabs.c: Ditto.\n+\n 2005-08-19  James E Wilson  <wilson@specifix.com>\n \n \t* builtins.c (expand_builtin_return_addr): Set\n@@ -33,14 +38,14 @@\n \tblock or not.\n \t(if_convertible_loop_p): Supply exit block itself to\n \tif_convertible_bb_p.\n-\t\n+\n 2005-08-19  Richard Earnshaw  <richard.earnshaw@arm.com>\n \n \tPR target/23473\n \t* arm.md (arm_load_pic_register): Change argument to the mask of\n-\tsaved registers.  Call thumb_find_work_register if we need a \n+\tsaved registers.  Call thumb_find_work_register if we need a\n \tscratch register on Thumb.\n-\t(arm_expand_prologue): Pass empty register set to \n+\t(arm_expand_prologue): Pass empty register set to\n \tarm_load_pic_register.\n \t(thumb_expand_prologue): Pass live_regs_mask directly to\n \tarm_load_pic_register.\n@@ -151,7 +156,7 @@\n \t(plus_gtu<mode>): Same.\n \n 2005-08-17  Erik Christiansen  <erik@dd.nec.com.au>\n-\t\n+\n \t* config/v850/lib1funcs.asm (callt_save_interrupt): Fix comment typos.\n \tMove call_table_data to end.  Delete spurious .text.\n \t(callt_save_all_interrupt): Fix comment typo.\n@@ -188,8 +193,8 @@\n \t* config.gcc: Added z9-109 switch.\n \t* config/s390/2084.md (\"x_int\", \"x_agen\", \"x_lr\", \"x_la\", \"x_larl\",\n \t\"x_load\", \"x_store\", \"x_branch\", \"x_call\", \"x_mul_hi\", \"x_mul_sidi\",\n-\t\"x_div\", \"x_sem\", \"x_cs\", \"x_vs\", \"x_stm\", \"x_lm\", \"x_other\", \n-\t\"x_fsimpdf\", \"x_fsimpsf\", \"x_fdivdf\", \"x_fdivsf\", \"x_floaddf\", \n+\t\"x_div\", \"x_sem\", \"x_cs\", \"x_vs\", \"x_stm\", \"x_lm\", \"x_other\",\n+\t\"x_fsimpdf\", \"x_fsimpsf\", \"x_fdivdf\", \"x_fdivsf\", \"x_floaddf\",\n \t\"x_floadsf\", \"x_fstore_df\", \"x_fstoresf\", \"x_ftoi\", \"x_itof\"): Enable\n \tfor \"z9_109\" cpu attribute.\n \t* config/s390/s390.c (z9_109_cost): New processor cost structure.\n@@ -206,7 +211,7 @@\n \t(CONSTRAINT_LEN): Added length of O constraint.\n \t(CLZ_DEFINED_VALUE_AT_ZERO): Definition added.\n \t* config/s390/s390.md (\"cpu\"): New value z9_109 added.\n-\t(\"*tstdi_extimm\", \"*tstdi_ccconly_extimm\", \"*tstsi_extimm\", \n+\t(\"*tstdi_extimm\", \"*tstdi_ccconly_extimm\", \"*tstsi_extimm\",\n \t\"*tstsi_cconly_extimm\", \"*movdi_64extimm\", \"*extendhidi2_extimm\",\n \t\"*extendqidi2_extimm\", \"*extendhisi2_extimm\", \"*extendqisi2_extimm\",\n \t\"*zero_extend<mode>si2_extimm\", \"*anddi3_extimm\", \"*iordi3_extimm\",\n@@ -220,7 +225,7 @@\n \t\"*addsi3_carry1_cc\", \"*addsi3_carry2_cc\", \"*addsi3_cc\", \"addsi3\",\n \t\"*andsi3_cc\", \"*andsi3_cconly\", \"*andsi3_zarch\", \"*iorsi3_cc\",\n \t\"*iorsi3_cconly\", \"*iorsi3_zarch\", \"*xorsi3_cc\", \"*xorsi3_cconly\",\n-\t\"*xorsi3\", \"*xorhi3\", \"*xorqi3\"): Added instruction using extended \n+\t\"*xorsi3\", \"*xorhi3\", \"*xorqi3\"): Added instruction using extended\n \timmediates.\n \t(\"extend<mode>di2\", \"extend<mode>si2\", \"zero_extend<mode>di2\",\n \t\"zero_extend<mode>si2\"): Allow memory operands and don't manually emit\n@@ -356,7 +361,7 @@\n 2005-08-15  Richard Earnshaw  <richard.earnshaw@arm.com>\n \n \tPR target/23355\n-\t* arm.c (thumb_compute_save_reg_mask): Use similar logic to \n+\t* arm.c (thumb_compute_save_reg_mask): Use similar logic to\n \tarm_compure_save_reg0_reg12_mask to determine when the PIC register\n \tmust be saved.\n \n@@ -389,7 +394,7 @@\n \t* aclocal.m4 (gcc_AC_FUNC_PRINTF_PTR): Delete.\n \t* configure.ac: Don't call gcc_AC_FUNC_PRINTF_PTR.\n \t* system.h (HOST_PTR_PRINTF): Don't define, poison it.\n-\t\n+\n \t* bitmap.c, c-decl.c, config/i386/i386-interix.h,\n \tconfig/iq2000/iq2000.c, mips-tfile.c, print-rtl.c, print-tree.c:\n \tDelete HOST_PTR_PRINTF.\n@@ -424,7 +429,7 @@\n \tPR 23386\n \t* tree-data-ref.c (estimate_niter_from_size_of_data): When\n \tstep is negative compute the estimation from init downwards to zero.\n-\t\n+\n 2005-08-14  James A. Morrison  <phython@gcc.gnu.org>\n \n \t* fold-const (fold_binary): Call fold_build2 instead of fold (build.\n@@ -441,17 +446,17 @@\n 2005-08-14  Daniel Berlin  <dberlin@dberlin.org>\n \n \tFix PR tree-optimization/22615\n-\t\n+\n \t* tree-ssa-structalias.c (solution_set_add): Handle\n-\tfirst_vi_for_offset returning NULL. \n+\tfirst_vi_for_offset returning NULL.\n \t(do_da_constraint): Ditto.\n \t(do_sd_constraint): Ditto.\n \t(do_ds_constraint): Ditto\n \t(find_func_aliases): Ditto.\n \t(build_constraint_graph): RHS is allowed be ANYTHING.\n \t(first_vi_for_offset): Return NULL if we couldn't find anything at\n \tthe offset.\n-\t\n+\n 2005-08-14  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390.c (s390_canonicalize_comparison): Prefer register\n@@ -466,9 +471,9 @@\n 2005-08-14  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/23320\n-\t* tree-data-ref.c (base_addr_differ_p): Add comment. Check \n-\tdata-refs' types instead of base object nullness. Add check for \n-\tpointer type data-refs before first location comparison. Remove \n+\t* tree-data-ref.c (base_addr_differ_p): Add comment. Check\n+\tdata-refs' types instead of base object nullness. Add check for\n+\tpointer type data-refs before first location comparison. Remove\n \tassert.\n \n 2005-08-14  Andreas Schwab  <schwab@suse.de>\n@@ -508,7 +513,7 @@\n \t* tree-flow-inline.h (single_ssa_tree_operand, single_ssa_use_operand,\n \tsingle_ssa_def_operand, zero_ssa_operands): Fix documentation.\n \t* tree-flow.h (scev_probably_wraps_p): Declare with an extra parameter.\n-\t* tree-scalar-evolution.c (instantiate_parameters_1): Factor entry \n+\t* tree-scalar-evolution.c (instantiate_parameters_1): Factor entry\n \tcondition.\n \t* tree-ssa-loop-ivcanon.c: Fix documentation.\n \t* tree-ssa-loop-ivopts.c (idx_find_step): Add a fixme note.\n@@ -534,7 +539,7 @@\n \n 2005-08-12  Gerald Pfeifer  <gerald@pfeifer.com>\n \n-\t* doc/invoke.texi (C++ Dialect Options): Add dynamic_cast to \n+\t* doc/invoke.texi (C++ Dialect Options): Add dynamic_cast to\n \tdescription of -Wold-style-casts.\n \n 2005-08-12  Andreas Krebbel  <krebbel1@de.ibm.com>\n@@ -589,7 +594,7 @@\n \n 2005-08-12  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n-\t* config/s390/s390.c (s390_split_branches, s390_init_frame_layout): \n+\t* config/s390/s390.c (s390_split_branches, s390_init_frame_layout):\n \tDon't set save_return_addr_p.\n \t(s390_register_info): Make clobbered_regs not depending on\n \tsave_return_addr_p."}, {"sha": "f2df3de54ea184ca5c1035f5a2e91f7a6dace2fb", "filename": "gcc/optabs.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c414ac1d704c156056ff4e2b86f6f98ee0416580/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c414ac1d704c156056ff4e2b86f6f98ee0416580/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=c414ac1d704c156056ff4e2b86f6f98ee0416580", "patch": "@@ -59,7 +59,7 @@ optab optab_table[OTI_MAX];\n rtx libfunc_table[LTI_MAX];\n \n /* Tables of patterns for converting one mode to another.  */\n-convert_optab convert_optab_table[CTI_MAX];\n+convert_optab convert_optab_table[COI_MAX];\n \n /* Contains the optab used for each rtx code.  */\n optab code_to_optab[NUM_RTX_CODE + 1];\n@@ -349,8 +349,8 @@ optab_for_tree_code (enum tree_code code, tree type)\n    this may or may not be TARGET.  */\n \n rtx\n-expand_ternary_op (enum machine_mode mode, optab ternary_optab, rtx op0, \n-\t\t   rtx op1, rtx op2, rtx target, int unsignedp) \n+expand_ternary_op (enum machine_mode mode, optab ternary_optab, rtx op0,\n+\t\t   rtx op1, rtx op2, rtx target, int unsignedp)\n {\n   int icode = (int) ternary_optab->handlers[(int) mode].insn_code;\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n@@ -377,7 +377,7 @@ expand_ternary_op (enum machine_mode mode, optab ternary_optab, rtx op0,\n   if (GET_MODE (op0) != mode0 && mode0 != VOIDmode)\n     xop0 = convert_modes (mode0,\n                           GET_MODE (op0) != VOIDmode\n-                          ? GET_MODE (op0) \n+                          ? GET_MODE (op0)\n                           : mode,\n                           xop0, unsignedp);\n \n@@ -397,23 +397,23 @@ expand_ternary_op (enum machine_mode mode, optab ternary_optab, rtx op0,\n \n   /* Now, if insn's predicates don't allow our operands, put them into\n      pseudo regs.  */\n-  \n+\n   if (!insn_data[icode].operand[1].predicate (xop0, mode0)\n-      && mode0 != VOIDmode) \n+      && mode0 != VOIDmode)\n     xop0 = copy_to_mode_reg (mode0, xop0);\n-  \n+\n   if (!insn_data[icode].operand[2].predicate (xop1, mode1)\n       && mode1 != VOIDmode)\n     xop1 = copy_to_mode_reg (mode1, xop1);\n-    \n+\n   if (!insn_data[icode].operand[3].predicate (xop2, mode2)\n       && mode2 != VOIDmode)\n     xop2 = copy_to_mode_reg (mode2, xop2);\n-    \n+\n   pat = GEN_FCN (icode) (temp, xop0, xop1, xop2);\n-    \n+\n   emit_insn (pat);\n-  return temp; \n+  return temp;\n }\n \n \n@@ -2192,7 +2192,7 @@ expand_parity (enum machine_mode mode, rtx op0, rtx target)\n   return 0;\n }\n \n-/* Extract the OMODE lowpart from VAL, which has IMODE.  Under certain \n+/* Extract the OMODE lowpart from VAL, which has IMODE.  Under certain\n    conditions, VAL may already be a SUBREG against which we cannot generate\n    a further SUBREG.  In this case, we expect forcing the value into a\n    register will work around the situation.  */\n@@ -2282,7 +2282,7 @@ expand_absneg_bit (enum rtx_code code, enum machine_mode mode,\n \t{\n \t  rtx targ_piece = operand_subword (target, i, 1, mode);\n \t  rtx op0_piece = operand_subword_force (op0, i, mode);\n-\t\n+\n \t  if (i == word)\n \t    {\n \t      temp = expand_binop (imode, code == ABS ? and_optab : xor_optab,\n@@ -2854,7 +2854,7 @@ expand_copysign_bit (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t{\n \t  rtx targ_piece = operand_subword (target, i, 1, mode);\n \t  rtx op0_piece = operand_subword_force (op0, i, mode);\n-\t\n+\n \t  if (i == word)\n \t    {\n \t      if (!op0_is_abs)\n@@ -2901,7 +2901,7 @@ expand_copysign_bit (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n   return target;\n }\n \n-/* Expand the C99 copysign operation.  OP0 and OP1 must be the same \n+/* Expand the C99 copysign operation.  OP0 and OP1 must be the same\n    scalar floating point mode.  Return NULL if we do not know how to\n    expand the operation inline.  */\n \n@@ -5282,7 +5282,7 @@ debug_optab_libfuncs (void)\n       }\n \n   /* Dump the conversion optabs.  */\n-  for (i = 0; i < (int) CTI_MAX; ++i)\n+  for (i = 0; i < (int) COI_MAX; ++i)\n     for (j = 0; j < NUM_MACHINE_MODES; ++j)\n       for (k = 0; k < NUM_MACHINE_MODES; ++k)\n \t{\n@@ -5377,7 +5377,7 @@ get_rtx_code (enum tree_code tcode, bool unsignedp)\n     case GE_EXPR:\n       code = unsignedp ? GEU : GE;\n       break;\n-      \n+\n     case UNORDERED_EXPR:\n       code = UNORDERED;\n       break;\n@@ -5423,18 +5423,18 @@ vector_compare_rtx (tree cond, bool unsignedp, enum insn_code icode)\n      ensures that condition is a relational operation.  */\n   gcc_assert (COMPARISON_CLASS_P (cond));\n \n-  rcode = get_rtx_code (TREE_CODE (cond), unsignedp); \n+  rcode = get_rtx_code (TREE_CODE (cond), unsignedp);\n   t_op0 = TREE_OPERAND (cond, 0);\n   t_op1 = TREE_OPERAND (cond, 1);\n-  \n+\n   /* Expand operands.  */\n   rtx_op0 = expand_expr (t_op0, NULL_RTX, TYPE_MODE (TREE_TYPE (t_op0)), 1);\n   rtx_op1 = expand_expr (t_op1, NULL_RTX, TYPE_MODE (TREE_TYPE (t_op1)), 1);\n \n   if (!insn_data[icode].operand[4].predicate (rtx_op0, GET_MODE (rtx_op0))\n       && GET_MODE (rtx_op0) != VOIDmode)\n     rtx_op0 = force_reg (GET_MODE (rtx_op0), rtx_op0);\n-  \n+\n   if (!insn_data[icode].operand[5].predicate (rtx_op1, GET_MODE (rtx_op1))\n       && GET_MODE (rtx_op1) != VOIDmode)\n     rtx_op1 = force_reg (GET_MODE (rtx_op1), rtx_op1);\n@@ -5443,8 +5443,8 @@ vector_compare_rtx (tree cond, bool unsignedp, enum insn_code icode)\n }\n \n /* Return insn code for VEC_COND_EXPR EXPR.  */\n-  \n-static inline enum insn_code \n+\n+static inline enum insn_code\n get_vcond_icode (tree expr, enum machine_mode mode)\n {\n   enum insn_code icode = CODE_FOR_nothing;\n@@ -5485,7 +5485,7 @@ expand_vec_cond_expr (tree vec_cond_expr, rtx target)\n     target = gen_reg_rtx (mode);\n \n   /* Get comparison rtx.  First expand both cond expr operands.  */\n-  comparison = vector_compare_rtx (TREE_OPERAND (vec_cond_expr, 0), \n+  comparison = vector_compare_rtx (TREE_OPERAND (vec_cond_expr, 0),\n \t\t\t\t   unsignedp, icode);\n   cc_op0 = XEXP (comparison, 0);\n   cc_op1 = XEXP (comparison, 1);\n@@ -5503,7 +5503,7 @@ expand_vec_cond_expr (tree vec_cond_expr, rtx target)\n     rtx_op2 = force_reg (mode, rtx_op2);\n \n   /* Emit instruction! */\n-  emit_insn (GEN_FCN (icode) (target, rtx_op1, rtx_op2, \n+  emit_insn (GEN_FCN (icode) (target, rtx_op1, rtx_op2,\n \t\t\t      comparison, cc_op0,  cc_op1));\n \n   return target;\n@@ -5629,8 +5629,8 @@ expand_bool_compare_and_swap (rtx mem, rtx old_val, rtx new_val, rtx target)\n \t}\n     }\n \n-  /* Without an appropriate setcc instruction, use a set of branches to \n-     get 1 and 0 stored into target.  Presumably if the target has a \n+  /* Without an appropriate setcc instruction, use a set of branches to\n+     get 1 and 0 stored into target.  Presumably if the target has a\n      STORE_FLAG_VALUE that isn't 1, then this will get cleaned up by ifcvt.  */\n \n   label0 = gen_label_rtx ();\n@@ -5723,7 +5723,7 @@ expand_compare_and_swap_loop (rtx mem, rtx old_reg, rtx new_reg, rtx seq)\n }\n \n /* This function generates the atomic operation MEM CODE= VAL.  In this\n-   case, we do not care about any resulting value.  Returns NULL if we \n+   case, we do not care about any resulting value.  Returns NULL if we\n    cannot generate the operation.  */\n \n rtx\n@@ -5776,7 +5776,7 @@ expand_sync_operation (rtx mem, rtx val, enum rtx_code code)\n \tval = convert_modes (mode, GET_MODE (val), val, 1);\n       if (!insn_data[icode].operand[1].predicate (val, mode))\n \tval = force_reg (mode, val);\n-      \n+\n       insn = GEN_FCN (icode) (mem, val);\n       if (insn)\n \t{\n@@ -5814,7 +5814,7 @@ expand_sync_operation (rtx mem, rtx val, enum rtx_code code)\n \n /* This function generates the atomic operation MEM CODE= VAL.  In this\n    case, we do care about the resulting value: if AFTER is true then\n-   return the value MEM holds after the operation, if AFTER is false \n+   return the value MEM holds after the operation, if AFTER is false\n    then return the value MEM holds before the operation.  TARGET is an\n    optional place for the result value to be stored.  */\n \n@@ -5909,7 +5909,7 @@ expand_sync_fetch_operation (rtx mem, rtx val, enum rtx_code code,\n \tval = convert_modes (mode, GET_MODE (val), val, 1);\n       if (!insn_data[icode].operand[2].predicate (val, mode))\n \tval = force_reg (mode, val);\n-      \n+\n       insn = GEN_FCN (icode) (target, mem, val);\n       if (insn)\n \t{\n@@ -5974,7 +5974,7 @@ expand_sync_fetch_operation (rtx mem, rtx val, enum rtx_code code,\n /* This function expands a test-and-set operation.  Ideally we atomically\n    store VAL in MEM and return the previous value in MEM.  Some targets\n    may not support this operation and only support VAL with the constant 1;\n-   in this case while the return value will be 0/1, but the exact value \n+   in this case while the return value will be 0/1, but the exact value\n    stored in MEM is target defined.  TARGET is an option place to stick\n    the return value.  */\n "}, {"sha": "582684f40381d13df7ceff75171d43504710858e", "filename": "gcc/optabs.h", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c414ac1d704c156056ff4e2b86f6f98ee0416580/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c414ac1d704c156056ff4e2b86f6f98ee0416580/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=c414ac1d704c156056ff4e2b86f6f98ee0416580", "patch": "@@ -377,33 +377,33 @@ extern GTY(()) optab optab_table[OTI_MAX];\n /* Conversion optabs have their own table and indexes.  */\n enum convert_optab_index\n {\n-  CTI_sext,\n-  CTI_zext,\n-  CTI_trunc,\n+  COI_sext,\n+  COI_zext,\n+  COI_trunc,\n \n-  CTI_sfix,\n-  CTI_ufix,\n+  COI_sfix,\n+  COI_ufix,\n \n-  CTI_sfixtrunc,\n-  CTI_ufixtrunc,\n+  COI_sfixtrunc,\n+  COI_ufixtrunc,\n \n-  CTI_sfloat,\n-  CTI_ufloat,\n+  COI_sfloat,\n+  COI_ufloat,\n \n-  CTI_MAX\n+  COI_MAX\n };\n \n-extern GTY(()) convert_optab convert_optab_table[CTI_MAX];\n+extern GTY(()) convert_optab convert_optab_table[COI_MAX];\n \n-#define sext_optab (convert_optab_table[CTI_sext])\n-#define zext_optab (convert_optab_table[CTI_zext])\n-#define trunc_optab (convert_optab_table[CTI_trunc])\n-#define sfix_optab (convert_optab_table[CTI_sfix])\n-#define ufix_optab (convert_optab_table[CTI_ufix])\n-#define sfixtrunc_optab (convert_optab_table[CTI_sfixtrunc])\n-#define ufixtrunc_optab (convert_optab_table[CTI_ufixtrunc])\n-#define sfloat_optab (convert_optab_table[CTI_sfloat])\n-#define ufloat_optab (convert_optab_table[CTI_ufloat])\n+#define sext_optab (convert_optab_table[COI_sext])\n+#define zext_optab (convert_optab_table[COI_zext])\n+#define trunc_optab (convert_optab_table[COI_trunc])\n+#define sfix_optab (convert_optab_table[COI_sfix])\n+#define ufix_optab (convert_optab_table[COI_ufix])\n+#define sfixtrunc_optab (convert_optab_table[COI_sfixtrunc])\n+#define ufixtrunc_optab (convert_optab_table[COI_ufixtrunc])\n+#define sfloat_optab (convert_optab_table[COI_sfloat])\n+#define ufloat_optab (convert_optab_table[COI_ufloat])\n \n /* These arrays record the insn_code of insns that may be needed to\n    perform input and output reloads of special objects.  They provide a\n@@ -492,8 +492,8 @@ extern enum insn_code sync_lock_release[NUM_MACHINE_MODES];\n \n /* Define functions given in optabs.c.  */\n \n-extern rtx expand_ternary_op (enum machine_mode mode, optab ternary_optab, \n-\t\t\t      rtx op0, rtx op1, rtx op2, rtx target, \n+extern rtx expand_ternary_op (enum machine_mode mode, optab ternary_optab,\n+\t\t\t      rtx op0, rtx op1, rtx op2, rtx target,\n \t\t\t      int unsignedp);\n \n /* Expand a binary operation given optab and rtx operands.  */"}]}