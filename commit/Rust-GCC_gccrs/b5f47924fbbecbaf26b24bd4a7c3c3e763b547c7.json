{"sha": "b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVmNDc5MjRmYmJlY2JhZjI2YjI0YmQ0YTdjM2MzZTc2M2I1NDdjNw==", "commit": {"author": {"name": "Sharad Singhai", "email": "singhai@google.com", "date": "2012-10-01T06:10:29Z"}, "committer": {"name": "Sharad Singhai", "email": "singhai@gcc.gnu.org", "date": "2012-10-01T06:10:29Z"}, "message": "dumpfile.c: New file with parts moved from tree-dump.c.\n\n2012-09-30  Sharad Singhai  <singhai@google.com>\n\n\t* dumpfile.c: New file with parts moved from tree-dump.c.\n\t(pflags): New variable.\n\t(alt_flags): Ditto.\n\t(alt_dump_file): Ditto.\n\t(dump_files):  Update to include additional fields.\n\t(struct dump_option_value_info): Add additional entries.\n\t(get_dump_file_name): Use command line filename if available.\n\t(dump_open_alternate_stream): New function.\n\t(dump_loc): Ditto.\n\t(dump_gimple_stmt): Ditto.\n\t(dump_gimple_stmt_loc): Ditto.\n\t(dump_generic_expr): Ditto.\n\t(dump_generic_expr_loc): Ditto.\n\t(dump_printf): Ditto.\n\t(dump_printf_loc): Ditto.\n\t(dump_start): Ditto.\n\t(dump_finish): Ditto.\n\t(dump_begin): Ditto.\n\t(dump_enabled_p): Return true if either of the dump types is enabled.\n\t(dump_initialized_p): Return true if either type of dump is initialized.\n\t(dump_end): Do not close standard streams.\n\t(dump_enable_all): Handle filenames for regular dumps.\n\t(dump_switch_p_1): Handle command-line dump filenames.\n\t(opt_info_enable_all): New function.\n\t(opt_info_switch_p_1): Ditto.\n\t(opt_info_switch_p): Ditto.\n\t(dump_kind_p): Ditto.\n\t(dump_basic_block): Ditto.\n\t(dump_combine_total_stats): Ditto.\n\t(dump_remap_tree_vectorizer_verbose): Ditto.\n\t* gimple-pretty-print.h: Rename dump_gimple_stmt to\n\tpp_gimple_stmt_1.  All callers updated.\n\nFrom-SVN: r191884", "tree": {"sha": "ad2ef830e2e9ae5df413e1c4ed662af1ab33d511", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad2ef830e2e9ae5df413e1c4ed662af1ab33d511"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7/comments", "author": null, "committer": null, "parents": [{"sha": "78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78c60e3da2d1a25ac13b725980e5f4dd53b9df60"}], "stats": {"total": 956, "additions": 930, "deletions": 26}, "files": [{"sha": "b971cd74645a9437f76bae92213e29b636d50665", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7", "patch": "@@ -1,3 +1,38 @@\n+2012-09-30  Sharad Singhai  <singhai@google.com>\n+\n+\t* dumpfile.c: New file with parts moved from tree-dump.c.\n+\t(pflags): New variable.\n+\t(alt_flags): Ditto.\n+\t(alt_dump_file): Ditto.\n+\t(dump_files):  Update to include additional fields.\n+\t(struct dump_option_value_info): Add additional entries.\n+\t(get_dump_file_name): Use command line filename if available.\n+\t(dump_open_alternate_stream): New function.\n+\t(dump_loc): Ditto.\n+\t(dump_gimple_stmt): Ditto.\n+\t(dump_gimple_stmt_loc): Ditto.\n+\t(dump_generic_expr): Ditto.\n+\t(dump_generic_expr_loc): Ditto.\n+\t(dump_printf): Ditto.\n+\t(dump_printf_loc): Ditto.\n+\t(dump_start): Ditto.\n+\t(dump_finish): Ditto.\n+\t(dump_begin): Ditto.\n+\t(dump_enabled_p): Return true if either of the dump types is enabled.\n+\t(dump_initialized_p): Return true if either type of dump is initialized.\n+\t(dump_end): Do not close standard streams.\n+\t(dump_enable_all): Handle filenames for regular dumps.\n+\t(dump_switch_p_1): Handle command-line dump filenames.\n+\t(opt_info_enable_all): New function.\n+\t(opt_info_switch_p_1): Ditto.\n+\t(opt_info_switch_p): Ditto.\n+\t(dump_kind_p): Ditto.\n+\t(dump_basic_block): Ditto.\n+\t(dump_combine_total_stats): Ditto.\n+\t(dump_remap_tree_vectorizer_verbose): Ditto.\n+\t* gimple-pretty-print.h: Rename dump_gimple_stmt to\n+\tpp_gimple_stmt_1.  All callers updated.\n+\n 2012-09-30  Sharad Singhai  <singhai@google.com>\n \n \t* doc/invoke.texi: Add documentation for the new -fopt-info option."}, {"sha": "92d1409be081a37888d0c115ab885415b6062e7d", "filename": "gcc/dumpfile.c", "status": "added", "additions": 869, "deletions": 0, "changes": 869, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7", "patch": "@@ -0,0 +1,869 @@\n+/* Dump infrastructure for optimizations and intermediate representation.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic-core.h\"\n+#include \"dumpfile.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"tree.h\"\n+\n+/* If non-NULL, return one past-the-end of the matching SUBPART of\n+   the WHOLE string.  */\n+#define skip_leading_substring(whole,  part) \\\n+   (strncmp (whole, part, strlen (part)) ? NULL : whole + strlen (part))\n+\n+static int pflags;                   /* current dump_flags */\n+static int alt_flags;                /* current opt_info flags */\n+static FILE *alt_dump_file = NULL;\n+\n+static void dump_loc (int, FILE *, source_location);\n+static int dump_enabled_p (int);\n+static FILE *dump_open_alternate_stream (struct dump_file_info *);\n+\n+/* Table of tree dump switches. This must be consistent with the\n+   TREE_DUMP_INDEX enumeration in dumpfile.h.  */\n+static struct dump_file_info dump_files[TDI_end] =\n+{\n+  {NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, 0},\n+  {\".cgraph\", \"ipa-cgraph\", NULL, NULL, NULL, NULL, NULL, TDF_IPA,\n+   0, 0, 0, 0},\n+  {\".tu\", \"translation-unit\", NULL, NULL, NULL, NULL, NULL, TDF_TREE,\n+   0, 0, 0, 1},\n+  {\".class\", \"class-hierarchy\", NULL, NULL, NULL, NULL, NULL, TDF_TREE,\n+   0, 0, 0, 2},\n+  {\".original\", \"tree-original\", NULL, NULL, NULL, NULL, NULL, TDF_TREE,\n+   0, 0, 0, 3},\n+  {\".gimple\", \"tree-gimple\", NULL, NULL, NULL, NULL, NULL, TDF_TREE,\n+   0, 0, 0, 4},\n+  {\".nested\", \"tree-nested\", NULL, NULL, NULL, NULL, NULL, TDF_TREE,\n+   0, 0, 0, 5},\n+  {\".vcg\", \"tree-vcg\", NULL, NULL, NULL, NULL, NULL, TDF_TREE,\n+   0, 0, 0, 6},\n+  {\".ads\", \"ada-spec\", NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, 7},\n+#define FIRST_AUTO_NUMBERED_DUMP 8\n+\n+  {NULL, \"tree-all\", NULL, NULL, NULL, NULL, NULL, TDF_TREE,\n+   0, 0, 0, 0},\n+  {NULL, \"rtl-all\", NULL, NULL, NULL, NULL, NULL, TDF_RTL,\n+   0, 0, 0, 0},\n+  {NULL, \"ipa-all\", NULL, NULL, NULL, NULL, NULL, TDF_IPA,\n+   0, 0, 0, 0},\n+};\n+\n+/* Dynamically registered tree dump files and switches.  */\n+static struct dump_file_info *extra_dump_files;\n+static size_t extra_dump_files_in_use;\n+static size_t extra_dump_files_alloced;\n+\n+/* Define a name->number mapping for a dump flag value.  */\n+struct dump_option_value_info\n+{\n+  const char *const name;\t/* the name of the value */\n+  const int value;\t\t/* the value of the name */\n+};\n+\n+/* Table of dump options. This must be consistent with the TDF_* flags\n+   in dumpfile.h and opt_info_options below. */\n+static const struct dump_option_value_info dump_options[] =\n+{\n+  {\"address\", TDF_ADDRESS},\n+  {\"asmname\", TDF_ASMNAME},\n+  {\"slim\", TDF_SLIM},\n+  {\"raw\", TDF_RAW},\n+  {\"graph\", TDF_GRAPH},\n+  {\"details\", (TDF_DETAILS | MSG_OPTIMIZED_LOCATIONS\n+               | MSG_MISSED_OPTIMIZATION\n+               | MSG_NOTE)},\n+  {\"cselib\", TDF_CSELIB},\n+  {\"stats\", TDF_STATS},\n+  {\"blocks\", TDF_BLOCKS},\n+  {\"vops\", TDF_VOPS},\n+  {\"lineno\", TDF_LINENO},\n+  {\"uid\", TDF_UID},\n+  {\"stmtaddr\", TDF_STMTADDR},\n+  {\"memsyms\", TDF_MEMSYMS},\n+  {\"verbose\", TDF_VERBOSE},\n+  {\"eh\", TDF_EH},\n+  {\"alias\", TDF_ALIAS},\n+  {\"nouid\", TDF_NOUID},\n+  {\"enumerate_locals\", TDF_ENUMERATE_LOCALS},\n+  {\"scev\", TDF_SCEV},\n+  {\"all\", ~(TDF_RAW | TDF_SLIM | TDF_LINENO | TDF_TREE | TDF_RTL | TDF_IPA\n+\t    | TDF_STMTADDR | TDF_GRAPH | TDF_DIAGNOSTIC | TDF_VERBOSE\n+\t    | TDF_RHS_ONLY | TDF_NOUID | TDF_ENUMERATE_LOCALS | TDF_SCEV)},\n+  {NULL, 0}\n+};\n+\n+/* A subset of the dump_options table which is used for opt-info\n+   options. This must be consistent with the MSG_* flags in\n+   dump_options.\n+ */\n+static const struct dump_option_value_info opt_info_options[] =\n+{\n+  {\"optimized\", MSG_OPTIMIZED_LOCATIONS},\n+  {\"missed\", MSG_MISSED_OPTIMIZATION},\n+  {\"note\", MSG_NOTE},\n+  {\"optall\", (MSG_OPTIMIZED_LOCATIONS\n+           | MSG_MISSED_OPTIMIZATION\n+           | MSG_NOTE)},\n+  {NULL, 0}\n+};\n+\n+unsigned int\n+dump_register (const char *suffix, const char *swtch, const char *glob,\n+\t       int flags)\n+{\n+  static int next_dump = FIRST_AUTO_NUMBERED_DUMP;\n+  int num = next_dump++;\n+\n+  size_t count = extra_dump_files_in_use++;\n+\n+  if (count >= extra_dump_files_alloced)\n+    {\n+      if (extra_dump_files_alloced == 0)\n+\textra_dump_files_alloced = 32;\n+      else\n+\textra_dump_files_alloced *= 2;\n+      extra_dump_files = XRESIZEVEC (struct dump_file_info,\n+\t\t\t\t     extra_dump_files,\n+\t\t\t\t     extra_dump_files_alloced);\n+    }\n+\n+  memset (&extra_dump_files[count], 0, sizeof (struct dump_file_info));\n+  extra_dump_files[count].suffix = suffix;\n+  extra_dump_files[count].swtch = swtch;\n+  extra_dump_files[count].glob = glob;\n+  extra_dump_files[count].pflags = flags;\n+  extra_dump_files[count].num = num;\n+\n+  return count + TDI_end;\n+}\n+\n+\n+/* Return the dump_file_info for the given phase.  */\n+\n+struct dump_file_info *\n+get_dump_file_info (int phase)\n+{\n+  if (phase < TDI_end)\n+    return &dump_files[phase];\n+  else if ((size_t) (phase - TDI_end) >= extra_dump_files_in_use)\n+    return NULL;\n+  else\n+    return extra_dump_files + (phase - TDI_end);\n+}\n+\n+\n+/* Return the name of the dump file for the given phase.\n+   If the dump is not enabled, returns NULL.  */\n+\n+char *\n+get_dump_file_name (int phase)\n+{\n+  char dump_id[10];\n+  struct dump_file_info *dfi;\n+\n+  if (phase == TDI_none)\n+    return NULL;\n+\n+  dfi = get_dump_file_info (phase);\n+  if (dfi->pstate == 0)\n+    return NULL;\n+\n+  /* If available, use the command line dump filename. */\n+  if (dfi->pfilename)\n+    return xstrdup (dfi->pfilename);\n+\n+  if (dfi->num < 0)\n+    dump_id[0] = '\\0';\n+  else\n+    {\n+      char suffix;\n+      if (dfi->pflags & TDF_TREE)\n+\tsuffix = 't';\n+      else if (dfi->pflags & TDF_IPA)\n+\tsuffix = 'i';\n+      else\n+\tsuffix = 'r';\n+\n+      if (snprintf (dump_id, sizeof (dump_id), \".%03d%c\", dfi->num, suffix) < 0)\n+\tdump_id[0] = '\\0';\n+    }\n+\n+  return concat (dump_base_name, dump_id, dfi->suffix, NULL);\n+}\n+\n+/* For a given DFI, open an alternate dump filename (which could also\n+   be a standard stream such as stdout/stderr). If the alternate dump\n+   file cannot be opened, return NULL.  */\n+\n+static FILE *\n+dump_open_alternate_stream (struct dump_file_info *dfi)\n+{\n+  FILE *stream ;\n+  if (!dfi->alt_filename)\n+    return NULL;\n+\n+  if (dfi->alt_stream)\n+    return dfi->alt_stream;\n+\n+  stream = strcmp(\"stderr\", dfi->alt_filename) == 0\n+    ? stderr\n+    : strcmp(\"stdout\", dfi->alt_filename) == 0\n+    ?  stdout\n+    : fopen (dfi->alt_filename, dfi->alt_state < 0 ? \"w\" : \"a\");\n+\n+  if (!stream)\n+    error (\"could not open dump file %qs: %m\", dfi->alt_filename);\n+  else\n+    dfi->alt_state = 1;\n+\n+  return stream;\n+}\n+\n+/* Print source location on DFILE if enabled.  */\n+\n+void\n+dump_loc (int dump_kind, FILE *dfile, source_location loc)\n+{\n+  /* Currently vectorization passes print location information.  */\n+  if (dump_kind)\n+    {\n+      if (loc == UNKNOWN_LOCATION)\n+        fprintf (dfile, \"\\n%s:%d: note: \",\n+                 DECL_SOURCE_FILE (current_function_decl),\n+                 DECL_SOURCE_LINE (current_function_decl));\n+     else\n+        fprintf (dfile, \"\\n%d: \", LOCATION_LINE (loc));\n+    }\n+}\n+\n+/* Dump gimple statement GS with SPC indentation spaces and\n+   EXTRA_DUMP_FLAGS on the dump streams if DUMP_KIND is enabled.  */\n+\n+void\n+dump_gimple_stmt (int dump_kind, int extra_dump_flags, gimple gs, int spc)\n+{\n+  if (dump_file && (dump_kind & pflags))\n+    print_gimple_stmt (dump_file, gs, spc, dump_flags | extra_dump_flags);\n+\n+  if (alt_dump_file && (dump_kind & alt_flags))\n+    print_gimple_stmt (alt_dump_file, gs, spc, dump_flags | extra_dump_flags);\n+}\n+\n+/* Similar to dump_gimple_stmt, except additionally print source location.  */\n+\n+void\n+dump_gimple_stmt_loc (int dump_kind, source_location loc, int extra_dump_flags,\n+                      gimple gs, int spc)\n+{\n+  if (dump_file && (dump_kind & pflags))\n+    {\n+      dump_loc (dump_kind, dump_file, loc);\n+      print_gimple_stmt (dump_file, gs, spc, dump_flags | extra_dump_flags);\n+    }\n+\n+  if (alt_dump_file && (dump_kind & alt_flags))\n+    {\n+      dump_loc (dump_kind, alt_dump_file, loc);\n+      print_gimple_stmt (alt_dump_file, gs, spc, dump_flags | extra_dump_flags);\n+    }\n+}\n+\n+/* Dump expression tree T using EXTRA_DUMP_FLAGS on dump streams if\n+   DUMP_KIND is enabled.  */\n+\n+void\n+dump_generic_expr (int dump_kind, int extra_dump_flags, tree t)\n+{\n+  if (dump_file && (dump_kind & pflags))\n+      print_generic_expr (dump_file, t, dump_flags | extra_dump_flags);\n+\n+  if (alt_dump_file && (dump_kind & alt_flags))\n+      print_generic_expr (alt_dump_file, t, dump_flags | extra_dump_flags);\n+}\n+\n+\n+/* Similar to dump_generic_expr, except additionally print the source\n+   location.  */\n+\n+void\n+dump_generic_expr_loc (int dump_kind, source_location loc,\n+                       int extra_dump_flags, tree t)\n+{\n+  if (dump_file && (dump_kind & pflags))\n+    {\n+      dump_loc (dump_kind, dump_file, loc);\n+      print_generic_expr (dump_file, t, dump_flags | extra_dump_flags);\n+    }\n+\n+  if (alt_dump_file && (dump_kind & alt_flags))\n+    {\n+      dump_loc (dump_kind, alt_dump_file, loc);\n+      print_generic_expr (alt_dump_file, t, dump_flags | extra_dump_flags);\n+    }\n+}\n+\n+/* Output a formatted message using FORMAT on appropriate dump streams.  */\n+\n+void\n+dump_printf (int dump_kind, const char *format, ...)\n+{\n+  if (dump_file && (dump_kind & pflags))\n+    {\n+      va_list ap;\n+      va_start (ap, format);\n+      vfprintf (dump_file, format, ap);\n+      va_end (ap);\n+    }\n+\n+  if (alt_dump_file && (dump_kind & alt_flags))\n+    {\n+      va_list ap;\n+      va_start (ap, format);\n+      vfprintf (alt_dump_file, format, ap);\n+      va_end (ap);\n+    }\n+}\n+\n+/* Similar to dump_printf, except source location is also printed.  */\n+\n+void\n+dump_printf_loc (int dump_kind, source_location loc, const char *format, ...)\n+{\n+  if (dump_file && (dump_kind & pflags))\n+    {\n+      va_list ap;\n+      dump_loc (dump_kind, dump_file, loc);\n+      va_start (ap, format);\n+      vfprintf (dump_file, format, ap);\n+      va_end (ap);\n+    }\n+\n+  if (alt_dump_file && (dump_kind & alt_flags))\n+    {\n+      va_list ap;\n+      dump_loc (dump_kind, alt_dump_file, loc);\n+      va_start (ap, format);\n+      vfprintf (alt_dump_file, format, ap);\n+      va_end (ap);\n+    }\n+}\n+\n+/* Start a dump for PHASE. Store user-supplied dump flags in\n+   *FLAG_PTR.  Return the number of streams opened.  Set globals\n+   DUMP_FILE, and ALT_DUMP_FILE to point to the opened streams, and\n+   set dump_flags appropriately for both pass dump stream and opt-info\n+   stream. */\n+\n+int\n+dump_start (int phase, int *flag_ptr)\n+{\n+  int count = 0;\n+  char *name;\n+  struct dump_file_info *dfi;\n+  FILE *stream;\n+  if (phase == TDI_none || !dump_enabled_p (phase))\n+    return 0;\n+\n+  dfi = get_dump_file_info (phase);\n+  name = get_dump_file_name (phase);\n+  if (name)\n+    {\n+      stream = strcmp(\"stderr\", name) == 0\n+          ? stderr\n+          : strcmp(\"stdout\", name) == 0\n+          ?  stdout\n+          : fopen (name, dfi->pstate < 0 ? \"w\" : \"a\");\n+      if (!stream)\n+        error (\"could not open dump file %qs: %m\", name);\n+      else\n+        {\n+          dfi->pstate = 1;\n+          count++;\n+        }\n+      free (name);\n+      dfi->pstream = stream;\n+      dump_file = dfi->pstream;\n+      /* Initialize current dump flags. */\n+      pflags = dfi->pflags;\n+    }\n+\n+  stream = dump_open_alternate_stream (dfi);\n+  if (stream)\n+    {\n+      dfi->alt_stream = stream;\n+      count++;\n+      alt_dump_file = dfi->alt_stream;\n+      /* Initialize current opt-info flags. */\n+      alt_flags = dfi->alt_flags;\n+    }\n+\n+  if (flag_ptr)\n+    *flag_ptr = dfi->pflags;\n+\n+  return count;\n+}\n+\n+/* Finish a tree dump for PHASE and close associated dump streams.  Also\n+   reset the globals DUMP_FILE, ALT_DUMP_FILE, and DUMP_FLAGS.  */\n+\n+void\n+dump_finish (int phase)\n+{\n+  struct dump_file_info *dfi;\n+\n+  if (phase < 0)\n+    return;\n+  dfi = get_dump_file_info (phase);\n+  if (dfi->pstream)\n+    fclose (dfi->pstream);\n+\n+  if (dfi->alt_stream && strcmp(\"stderr\", dfi->alt_filename) != 0\n+      && strcmp(\"stdout\", dfi->alt_filename) != 0)\n+    fclose (dfi->alt_stream);\n+\n+  dfi->alt_stream = NULL;\n+  dfi->pstream = NULL;\n+  dump_file = NULL;\n+  alt_dump_file = NULL;\n+  dump_flags = TDI_none;\n+  alt_flags = 0;\n+  pflags = 0;\n+}\n+\n+/* Begin a tree dump for PHASE. Stores any user supplied flag in\n+   *FLAG_PTR and returns a stream to write to. If the dump is not\n+   enabled, returns NULL.\n+   Multiple calls will reopen and append to the dump file.  */\n+\n+FILE *\n+dump_begin (int phase, int *flag_ptr)\n+{\n+  char *name;\n+  struct dump_file_info *dfi;\n+  FILE *stream;\n+\n+  if (phase == TDI_none || !dump_enabled_p (phase))\n+    return NULL;\n+\n+  name = get_dump_file_name (phase);\n+  if (!name)\n+    return NULL;\n+  dfi = get_dump_file_info (phase);\n+\n+  stream = strcmp(\"stderr\", name) == 0\n+    ? stderr\n+    : strcmp(\"stdout\", name) == 0\n+    ?  stdout\n+    : fopen (name, dfi->pstate < 0 ? \"w\" : \"a\");\n+\n+  if (!stream)\n+    error (\"could not open dump file %qs: %m\", name);\n+  else\n+    dfi->pstate = 1;\n+  free (name);\n+\n+  if (flag_ptr)\n+    *flag_ptr = dfi->pflags;\n+\n+  /* Initialize current flags */\n+  pflags = dfi->pflags;\n+  return stream;\n+}\n+\n+/* Returns nonzero if dump PHASE is enabled for at least one stream.\n+   If PHASE is TDI_tree_all, return nonzero if any dump is enabled for\n+   any phase.  */\n+\n+int\n+dump_enabled_p (int phase)\n+{\n+  if (phase == TDI_tree_all)\n+    {\n+      size_t i;\n+      for (i = TDI_none + 1; i < (size_t) TDI_end; i++)\n+\tif (dump_files[i].pstate || dump_files[i].alt_state)\n+\t  return 1;\n+      for (i = 0; i < extra_dump_files_in_use; i++)\n+\tif (extra_dump_files[i].pstate || extra_dump_files[i].alt_state)\n+\t  return 1;\n+      return 0;\n+    }\n+  else\n+    {\n+      struct dump_file_info *dfi = get_dump_file_info (phase);\n+      return dfi->pstate || dfi->alt_state;\n+    }\n+}\n+\n+/* Returns nonzero if tree dump PHASE has been initialized.  */\n+\n+int\n+dump_initialized_p (int phase)\n+{\n+  struct dump_file_info *dfi = get_dump_file_info (phase);\n+  return dfi->pstate > 0 || dfi->alt_state > 0;\n+}\n+\n+/* Returns the switch name of PHASE.  */\n+\n+const char *\n+dump_flag_name (int phase)\n+{\n+  struct dump_file_info *dfi = get_dump_file_info (phase);\n+  return dfi->swtch;\n+}\n+\n+/* Finish a tree dump for PHASE. STREAM is the stream created by\n+   dump_begin.  */\n+\n+void\n+dump_end (int phase ATTRIBUTE_UNUSED, FILE *stream)\n+{\n+  if (stream != stderr && stream != stdout)\n+    fclose (stream);\n+}\n+\n+/* Enable all tree dumps with FLAGS on FILENAME.  Return number of\n+   enabled tree dumps.  */\n+\n+static int\n+dump_enable_all (int flags, const char *filename)\n+{\n+  int ir_dump_type = (flags & (TDF_TREE | TDF_RTL | TDF_IPA));\n+  int n = 0;\n+  size_t i;\n+\n+  for (i = TDI_none + 1; i < (size_t) TDI_end; i++)\n+    {\n+      if ((dump_files[i].pflags & ir_dump_type))\n+        {\n+          const char *old_filename = dump_files[i].pfilename;\n+          dump_files[i].pstate = -1;\n+          dump_files[i].pflags |= flags;\n+          n++;\n+          /* Override the existing filename.  */\n+          if (filename)\n+            {\n+              dump_files[i].pfilename = xstrdup (filename);\n+              /* Since it is a command-line provided file, which is\n+                 common to all the phases, use it in append mode.  */\n+              dump_files[i].pstate = 1;\n+            }\n+          if (old_filename && filename != old_filename)\n+            free (CONST_CAST (char *, old_filename));\n+        }\n+    }\n+\n+  for (i = 0; i < extra_dump_files_in_use; i++)\n+    {\n+      if ((extra_dump_files[i].pflags & ir_dump_type))\n+        {\n+          const char *old_filename = extra_dump_files[i].pfilename;\n+          extra_dump_files[i].pstate = -1;\n+          extra_dump_files[i].pflags |= flags;\n+          n++;\n+          /* Override the existing filename.  */\n+          if (filename)\n+            {\n+              extra_dump_files[i].pfilename = xstrdup (filename);\n+              /* Since it is a command-line provided file, which is\n+                 common to all the phases, use it in append mode.  */\n+              extra_dump_files[i].pstate = 1;\n+            }\n+          if (old_filename && filename != old_filename)\n+            free (CONST_CAST (char *, old_filename));\n+        }\n+    }\n+\n+  return n;\n+}\n+\n+/* Enable opt-info dumps on all IR_DUMP_TYPE passes with FLAGS on\n+   FILENAME.  Return the number of enabled dumps.  */\n+\n+static int\n+opt_info_enable_all (int ir_dump_type, int flags, const char *filename)\n+{\n+  int n = 0;\n+  size_t i;\n+\n+  for (i = TDI_none + 1; i < (size_t) TDI_end; i++)\n+    {\n+      if ((dump_files[i].pflags & ir_dump_type))\n+        {\n+          const char *old_filename = dump_files[i].alt_filename;\n+          /* Since this file is shared among different passes, it\n+             should be opened in append mode.  */\n+          dump_files[i].alt_state = 1;\n+          dump_files[i].alt_flags |= flags;\n+          n++;\n+          /* Override the existing filename.  */\n+          if (filename)\n+            dump_files[i].alt_filename = xstrdup (filename);\n+          if (old_filename && filename != old_filename)\n+            free (CONST_CAST (char *, old_filename));\n+        }\n+    }\n+\n+  for (i = 0; i < extra_dump_files_in_use; i++)\n+    {\n+      if ((extra_dump_files[i].pflags & ir_dump_type))\n+        {\n+          const char *old_filename = extra_dump_files[i].alt_filename;\n+          /* Since this file is shared among different passes, it\n+             should be opened in append mode.  */\n+          extra_dump_files[i].alt_state = 1;\n+          extra_dump_files[i].alt_flags |= flags;\n+          n++;\n+          /* Override the existing filename.  */\n+          if (filename)\n+            extra_dump_files[i].alt_filename = xstrdup (filename);\n+          if (old_filename && filename != old_filename)\n+            free (CONST_CAST (char *, old_filename));\n+        }\n+    }\n+\n+  return n;\n+}\n+\n+/* Parse ARG as a dump switch. Return nonzero if it is, and store the\n+   relevant details in the dump_files array.  */\n+\n+static int\n+dump_switch_p_1 (const char *arg, struct dump_file_info *dfi, bool doglob)\n+{\n+  const char *option_value;\n+  const char *ptr;\n+  int flags;\n+\n+  if (doglob && !dfi->glob)\n+    return 0;\n+\n+  option_value = skip_leading_substring (arg, doglob ? dfi->glob : dfi->swtch);\n+  if (!option_value)\n+    return 0;\n+\n+  if (*option_value && *option_value != '-' && *option_value != '=')\n+    return 0;\n+\n+  ptr = option_value;\n+  flags = 0;\n+\n+  while (*ptr)\n+    {\n+      const struct dump_option_value_info *option_ptr;\n+      const char *end_ptr;\n+      const char *eq_ptr;\n+      unsigned length;\n+\n+      while (*ptr == '-')\n+\tptr++;\n+      end_ptr = strchr (ptr, '-');\n+      eq_ptr = strchr (ptr, '=');\n+\n+      if (eq_ptr && !end_ptr)\n+        end_ptr = eq_ptr;\n+\n+      if (!end_ptr)\n+\tend_ptr = ptr + strlen (ptr);\n+      length = end_ptr - ptr;\n+\n+      for (option_ptr = dump_options; option_ptr->name; option_ptr++)\n+\tif (strlen (option_ptr->name) == length\n+\t    && !memcmp (option_ptr->name, ptr, length))\n+          {\n+            flags |= option_ptr->value;\n+\t    goto found;\n+          }\n+\n+      if (*ptr == '=')\n+        {\n+          /* Interpret rest of the argument as a dump filename.  This\n+             filename overrides other command line filenames.  */\n+          if (dfi->pfilename)\n+            free (CONST_CAST (char *, dfi->pfilename));\n+          dfi->pfilename = xstrdup (ptr + 1);\n+          break;\n+        }\n+      else\n+        warning (0, \"ignoring unknown option %q.*s in %<-fdump-%s%>\",\n+                 length, ptr, dfi->swtch);\n+    found:;\n+      ptr = end_ptr;\n+    }\n+\n+  dfi->pstate = -1;\n+  dfi->pflags |= flags;\n+\n+  /* Process -fdump-tree-all and -fdump-rtl-all, by enabling all the\n+     known dumps.  */\n+  if (dfi->suffix == NULL)\n+    dump_enable_all (dfi->pflags, dfi->pfilename);\n+\n+  return 1;\n+}\n+\n+int\n+dump_switch_p (const char *arg)\n+{\n+  size_t i;\n+  int any = 0;\n+\n+  for (i = TDI_none + 1; i != TDI_end; i++)\n+    any |= dump_switch_p_1 (arg, &dump_files[i], false);\n+\n+  /* Don't glob if we got a hit already */\n+  if (!any)\n+    for (i = TDI_none + 1; i != TDI_end; i++)\n+      any |= dump_switch_p_1 (arg, &dump_files[i], true);\n+\n+  for (i = 0; i < extra_dump_files_in_use; i++)\n+    any |= dump_switch_p_1 (arg, &extra_dump_files[i], false);\n+\n+  if (!any)\n+    for (i = 0; i < extra_dump_files_in_use; i++)\n+      any |= dump_switch_p_1 (arg, &extra_dump_files[i], true);\n+\n+\n+  return any;\n+}\n+\n+/* Parse ARG as a -fopt-info switch and store flags and filename.\n+   Return non-zero if it is a recognized switch.  */\n+\n+static int\n+opt_info_switch_p_1 (const char *arg, int *flags, char **filename)\n+{\n+  const char *option_value;\n+  const char *ptr;\n+\n+  option_value = arg;\n+  ptr = option_value;\n+\n+  *filename = NULL;\n+  *flags = 0;\n+\n+  if (!ptr)\n+    return 1;\n+\n+  while (*ptr)\n+    {\n+      const struct dump_option_value_info *option_ptr;\n+      const char *end_ptr;\n+      const char *eq_ptr;\n+      unsigned length;\n+\n+      while (*ptr == '-')\n+\tptr++;\n+      end_ptr = strchr (ptr, '-');\n+      eq_ptr = strchr (ptr, '=');\n+\n+      if (eq_ptr && !end_ptr)\n+        end_ptr = eq_ptr;\n+\n+      if (!end_ptr)\n+\tend_ptr = ptr + strlen (ptr);\n+      length = end_ptr - ptr;\n+\n+      for (option_ptr = opt_info_options; option_ptr->name; option_ptr++)\n+\tif (strlen (option_ptr->name) == length\n+\t    && !memcmp (option_ptr->name, ptr, length))\n+          {\n+            *flags |= option_ptr->value;\n+\t    goto found;\n+          }\n+\n+      if (*ptr == '=')\n+        {\n+          /* Interpret rest of the argument as a dump filename.  This\n+             filename overrides other command line filenames.  */\n+          *filename = xstrdup (ptr + 1);\n+          break;\n+        }\n+      else\n+        warning (0, \"ignoring unknown option %q.*s in %<-fopt-info=%s%>\",\n+                 length, ptr, arg);\n+    found:;\n+      ptr = end_ptr;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Return non-zero if ARG is a recognized switch for\n+   -fopt-info. Return zero otherwise.  */\n+\n+int\n+opt_info_switch_p (const char *arg)\n+{\n+  int flags;\n+  char *filename;\n+\n+  opt_info_switch_p_1 (arg, &flags, &filename);\n+\n+  if (!filename)\n+    filename = xstrdup (\"stderr\");\n+  if (!flags)\n+    flags = MSG_ALL;\n+\n+  return opt_info_enable_all ((TDF_TREE | TDF_RTL | TDF_IPA), flags, filename);\n+}\n+\n+/* Return true if any dumps are enabled for the given MSG_TYPE, false\n+   otherwise.  */\n+\n+bool\n+dump_kind_p (int msg_type)\n+{\n+  if (!current_function_decl)\n+    return 0;\n+  return ((msg_type & pflags) || (msg_type & alt_flags));\n+}\n+\n+/* Print basic block on the dump streams.  */\n+\n+void\n+dump_basic_block (int dump_kind, basic_block bb, int indent)\n+{\n+  if (dump_file && (dump_kind & pflags))\n+    dump_bb (dump_file, bb, indent, TDF_DETAILS);\n+  if (alt_dump_file && (dump_kind & alt_flags))\n+    dump_bb (alt_dump_file, bb, indent, TDF_DETAILS);\n+}\n+\n+/* Print information from the combine pass on dump_file.  */\n+\n+void\n+print_combine_total_stats (void)\n+{\n+  if (dump_file)\n+    dump_combine_total_stats (dump_file);\n+}\n+\n+/* Enable RTL dump for all the RTL passes.  */\n+\n+bool\n+enable_rtl_dump_file (void)\n+{\n+  return dump_enable_all (TDF_RTL | TDF_DETAILS | TDF_BLOCKS, NULL) > 0;\n+}"}, {"sha": "4b3235edf56ba485fa61522d3800c1597353787a", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7", "patch": "@@ -69,7 +69,7 @@ maybe_init_pretty_print (FILE *file)\n }\n \n \n-/* Emit a newline and SPC indentantion spaces to BUFFER.  */\n+/* Emit a newline and SPC indentation spaces to BUFFER.  */\n \n static void\n newline_and_indent (pretty_printer *buffer, int spc)\n@@ -89,33 +89,33 @@ debug_gimple_stmt (gimple gs)\n }\n \n \n-/* Dump GIMPLE statement G to FILE using SPC indentantion spaces and\n-   FLAGS as in dump_gimple_stmt.  */\n+/* Print GIMPLE statement G to FILE using SPC indentation spaces and\n+   FLAGS as in pp_gimple_stmt_1.  */\n \n void\n print_gimple_stmt (FILE *file, gimple g, int spc, int flags)\n {\n   maybe_init_pretty_print (file);\n-  dump_gimple_stmt (&buffer, g, spc, flags);\n+  pp_gimple_stmt_1 (&buffer, g, spc, flags);\n   pp_newline_and_flush (&buffer);\n }\n \n \n-/* Dump GIMPLE statement G to FILE using SPC indentantion spaces and\n-   FLAGS as in dump_gimple_stmt.  Print only the right-hand side\n+/* Print GIMPLE statement G to FILE using SPC indentation spaces and\n+   FLAGS as in pp_gimple_stmt_1.  Print only the right-hand side\n    of the statement.  */\n \n void\n print_gimple_expr (FILE *file, gimple g, int spc, int flags)\n {\n   flags |= TDF_RHS_ONLY;\n   maybe_init_pretty_print (file);\n-  dump_gimple_stmt (&buffer, g, spc, flags);\n+  pp_gimple_stmt_1 (&buffer, g, spc, flags);\n }\n \n \n-/* Print the GIMPLE sequence SEQ on BUFFER using SPC indentantion\n-   spaces and FLAGS as in dump_gimple_stmt.\n+/* Print the GIMPLE sequence SEQ on BUFFER using SPC indentation\n+   spaces and FLAGS as in pp_gimple_stmt_1.\n    The caller is responsible for calling pp_flush on BUFFER to finalize\n    the pretty printer.  */\n \n@@ -128,15 +128,15 @@ dump_gimple_seq (pretty_printer *buffer, gimple_seq seq, int spc, int flags)\n     {\n       gimple gs = gsi_stmt (i);\n       INDENT (spc);\n-      dump_gimple_stmt (buffer, gs, spc, flags);\n+      pp_gimple_stmt_1 (buffer, gs, spc, flags);\n       if (!gsi_one_before_end_p (i))\n \tpp_newline (buffer);\n     }\n }\n \n \n-/* Dump GIMPLE sequence SEQ to FILE using SPC indentantion spaces and\n-   FLAGS as in dump_gimple_stmt.  */\n+/* Print GIMPLE sequence SEQ to FILE using SPC indentation spaces and\n+   FLAGS as in pp_gimple_stmt_1.  */\n \n void\n print_gimple_seq (FILE *file, gimple_seq seq, int spc, int flags)\n@@ -245,7 +245,7 @@ dump_gimple_fmt (pretty_printer *buffer, int spc, int flags,\n \n \n /* Helper for dump_gimple_assign.  Print the unary RHS of the\n-   assignment GS.  BUFFER, SPC and FLAGS are as in dump_gimple_stmt.  */\n+   assignment GS.  BUFFER, SPC and FLAGS are as in pp_gimple_stmt_1.  */\n \n static void\n dump_unary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n@@ -329,7 +329,7 @@ dump_unary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n \n \n /* Helper for dump_gimple_assign.  Print the binary RHS of the\n-   assignment GS.  BUFFER, SPC and FLAGS are as in dump_gimple_stmt.  */\n+   assignment GS.  BUFFER, SPC and FLAGS are as in pp_gimple_stmt_1.  */\n \n static void\n dump_binary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n@@ -385,7 +385,7 @@ dump_binary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n }\n \n /* Helper for dump_gimple_assign.  Print the ternary RHS of the\n-   assignment GS.  BUFFER, SPC and FLAGS are as in dump_gimple_stmt.  */\n+   assignment GS.  BUFFER, SPC and FLAGS are as in pp_gimple_stmt_1.  */\n \n static void\n dump_ternary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n@@ -470,7 +470,7 @@ dump_ternary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n \n \n /* Dump the gimple assignment GS.  BUFFER, SPC and FLAGS are as in\n-   dump_gimple_stmt.  */\n+   pp_gimple_stmt_1.  */\n \n static void\n dump_gimple_assign (pretty_printer *buffer, gimple gs, int spc, int flags)\n@@ -529,7 +529,7 @@ dump_gimple_assign (pretty_printer *buffer, gimple gs, int spc, int flags)\n \n \n /* Dump the return statement GS.  BUFFER, SPC and FLAGS are as in\n-   dump_gimple_stmt.  */\n+   pp_gimple_stmt_1.  */\n \n static void\n dump_gimple_return (pretty_printer *buffer, gimple gs, int spc, int flags)\n@@ -616,7 +616,7 @@ pp_points_to_solution (pretty_printer *buffer, struct pt_solution *pt)\n }\n \n /* Dump the call statement GS.  BUFFER, SPC and FLAGS are as in\n-   dump_gimple_stmt.  */\n+   pp_gimple_stmt_1.  */\n \n static void\n dump_gimple_call (pretty_printer *buffer, gimple gs, int spc, int flags)\n@@ -749,7 +749,7 @@ dump_gimple_call (pretty_printer *buffer, gimple gs, int spc, int flags)\n \n \n /* Dump the switch statement GS.  BUFFER, SPC and FLAGS are as in\n-   dump_gimple_stmt.  */\n+   pp_gimple_stmt_1.  */\n \n static void\n dump_gimple_switch (pretty_printer *buffer, gimple gs, int spc, int flags)\n@@ -782,7 +782,7 @@ dump_gimple_switch (pretty_printer *buffer, gimple gs, int spc, int flags)\n \n \n /* Dump the gimple conditional GS.  BUFFER, SPC and FLAGS are as in\n-   dump_gimple_stmt.  */\n+   pp_gimple_stmt_1.  */\n \n static void\n dump_gimple_cond (pretty_printer *buffer, gimple gs, int spc, int flags)\n@@ -1573,7 +1573,7 @@ dump_gimple_asm (pretty_printer *buffer, gimple gs, int spc, int flags)\n }\n \n \n-/* Dump a PHI node PHI.  BUFFER, SPC and FLAGS are as in dump_gimple_stmt.\n+/* Dump a PHI node PHI.  BUFFER, SPC and FLAGS are as in pp_gimple_stmt_1.\n    The caller is responsible for calling pp_flush on BUFFER to finalize\n    pretty printer.  */\n \n@@ -1807,7 +1807,7 @@ dump_gimple_omp_atomic_store (pretty_printer *buffer, gimple gs, int spc,\n \n \n /* Dump all the memory operands for statement GS.  BUFFER, SPC and\n-   FLAGS are as in dump_gimple_stmt.  */\n+   FLAGS are as in pp_gimple_stmt_1.  */\n \n static void\n dump_gimple_mem_ops (pretty_printer *buffer, gimple gs, int spc, int flags)\n@@ -1838,13 +1838,13 @@ dump_gimple_mem_ops (pretty_printer *buffer, gimple gs, int spc, int flags)\n }\n \n \n-/* Dump the gimple statement GS on the pretty printer BUFFER, SPC\n+/* Print the gimple statement GS on the pretty printer BUFFER, SPC\n    spaces of indent.  FLAGS specifies details to show in the dump (see\n    TDF_* in dumpfile.h).  The caller is responsible for calling\n    pp_flush on BUFFER to finalize the pretty printer.  */\n \n void\n-dump_gimple_stmt (pretty_printer *buffer, gimple gs, int spc, int flags)\n+pp_gimple_stmt_1 (pretty_printer *buffer, gimple gs, int spc, int flags)\n {\n   if (!gs)\n     return;\n@@ -2253,7 +2253,7 @@ gimple_dump_bb_buff (pretty_printer *buffer, basic_block bb, int indent,\n       curr_indent = gimple_code (stmt) == GIMPLE_LABEL ? label_indent : indent;\n \n       INDENT (curr_indent);\n-      dump_gimple_stmt (buffer, stmt, curr_indent, flags);\n+      pp_gimple_stmt_1 (buffer, stmt, curr_indent, flags);\n       pp_newline_and_flush (buffer);\n       gcc_checking_assert (DECL_STRUCT_FUNCTION (current_function_decl));\n       dump_histograms_for_stmt (DECL_STRUCT_FUNCTION (current_function_decl),"}, {"sha": "9b6b5592f199da60c97b8676bf9f66db1eda3c65", "filename": "gcc/gimple-pretty-print.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7/gcc%2Fgimple-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7/gcc%2Fgimple-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.h?ref=b5f47924fbbecbaf26b24bd4a7c3c3e763b547c7", "patch": "@@ -31,6 +31,6 @@ extern void debug_gimple_seq (gimple_seq);\n extern void print_gimple_seq (FILE *, gimple_seq, int, int);\n extern void print_gimple_stmt (FILE *, gimple, int, int);\n extern void print_gimple_expr (FILE *, gimple, int, int);\n-extern void dump_gimple_stmt (pretty_printer *, gimple, int, int);\n+extern void pp_gimple_stmt_1 (pretty_printer *, gimple, int, int);\n \n #endif /* ! GCC_GIMPLE_PRETTY_PRINT_H */"}]}