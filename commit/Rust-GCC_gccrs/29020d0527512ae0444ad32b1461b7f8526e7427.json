{"sha": "29020d0527512ae0444ad32b1461b7f8526e7427", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkwMjBkMDUyNzUxMmFlMDQ0NGFkMzJiMTQ2MWI3Zjg1MjZlNzQyNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2021-08-16T10:14:12Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2021-08-16T10:16:32Z"}, "message": "Disable GNAT encodings by default\n\nGiven the latest work in the compiler and debugger, we no longer need to use\nmost GNAT-specific encodings in the debug info generated for an Ada program,\nso the attached patch disables them, except with -fgnat-encodings=all.\n\ngcc/\n\t* dwarf2out.c (add_data_member_location_attribute): Use GNAT\n\tencodings only when -fgnat-encodings=all is specified.\n\t(add_bound_info): Likewise.\n\t(add_byte_size_attribute): Likewise.\n\t(gen_member_die): Likewise.", "tree": {"sha": "54a495035450d29ada4acf87212c062faaab4f2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54a495035450d29ada4acf87212c062faaab4f2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29020d0527512ae0444ad32b1461b7f8526e7427", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29020d0527512ae0444ad32b1461b7f8526e7427", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29020d0527512ae0444ad32b1461b7f8526e7427", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29020d0527512ae0444ad32b1461b7f8526e7427/comments", "author": null, "committer": null, "parents": [{"sha": "a2ab2f0dfba0fa69ebf6c82e34750911b2e5a639", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ab2f0dfba0fa69ebf6c82e34750911b2e5a639", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2ab2f0dfba0fa69ebf6c82e34750911b2e5a639"}], "stats": {"total": 32, "additions": 15, "deletions": 17}, "files": [{"sha": "4bcd3313feec53d85e603f8947cc186ba620daab", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29020d0527512ae0444ad32b1461b7f8526e7427/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29020d0527512ae0444ad32b1461b7f8526e7427/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=29020d0527512ae0444ad32b1461b7f8526e7427", "patch": "@@ -19915,22 +19915,23 @@ add_data_member_location_attribute (dw_die_ref die,\n     {\n       loc_descr = field_byte_offset (decl, ctx, &offset);\n \n-      /* If loc_descr is available then we know the field offset is dynamic.\n-\t However, GDB does not handle dynamic field offsets very well at the\n-\t moment.  */\n-      if (loc_descr != NULL && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+      if (!loc_descr)\n+\t;\n+\n+      /* If loc_descr is available, then we know the offset is dynamic.  */\n+      else if (gnat_encodings == DWARF_GNAT_ENCODINGS_ALL)\n \t{\n \t  loc_descr = NULL;\n \t  offset = 0;\n \t}\n \n-      /* Data member location evalutation starts with the base address on the\n+      /* Data member location evaluation starts with the base address on the\n \t stack.  Compute the field offset and add it to this base address.  */\n-      else if (loc_descr != NULL)\n+      else\n \tadd_loc_descr (&loc_descr, new_loc_descr (DW_OP_plus, 0, 0));\n     }\n \n-  if (! loc_descr)\n+  if (!loc_descr)\n     {\n       /* While DW_AT_data_bit_offset has been added already in DWARF4,\n \t e.g. GDB only added support to it in November 2016.  For DWARF5\n@@ -21389,12 +21390,9 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr,\n \t/* FALLTHRU */\n \n       default:\n-\t/* Because of the complex interaction there can be with other GNAT\n-\t   encodings, GDB isn't ready yet to handle proper DWARF description\n-\t   for self-referencial subrange bounds: let GNAT encodings do the\n-\t   magic in such a case.  */\n+\t/* Let GNAT encodings do the magic for self-referential bounds.  */\n \tif (is_ada ()\n-\t    && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL\n+\t    && gnat_encodings == DWARF_GNAT_ENCODINGS_ALL\n \t    && contains_placeholder_p (bound))\n \t  return;\n \n@@ -21566,7 +21564,7 @@ add_byte_size_attribute (dw_die_ref die, tree tree_node)\n   /* Support for dynamically-sized objects was introduced in DWARF3.  */\n   else if (TYPE_P (tree_node)\n \t   && (dwarf_version >= 3 || !dwarf_strict)\n-\t   && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t   && gnat_encodings != DWARF_GNAT_ENCODINGS_ALL)\n     {\n       struct loc_descr_context ctx = {\n \tconst_cast<tree> (tree_node),\t/* context_type */\n@@ -25629,11 +25627,11 @@ gen_member_die (tree type, dw_die_ref context_die)\n \t    splice_child_die (context_die, child);\n \t}\n \n-      /* Do not generate standard DWARF for variant parts if we are generating\n-\t the corresponding GNAT encodings: DIEs generated for both would\n-\t conflict in our mappings.  */\n+      /* Do not generate DWARF for variant parts if we are generating the\n+\t corresponding GNAT encodings: DIEs generated for the two schemes\n+\t would conflict in our mappings.  */\n       else if (is_variant_part (member)\n-\t       && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t       && gnat_encodings != DWARF_GNAT_ENCODINGS_ALL)\n \t{\n \t  vlr_ctx.variant_part_offset = byte_position (member);\n \t  gen_variant_part (member, &vlr_ctx, context_die);"}]}