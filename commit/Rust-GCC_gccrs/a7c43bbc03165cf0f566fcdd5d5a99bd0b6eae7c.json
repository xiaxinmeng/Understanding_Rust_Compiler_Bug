{"sha": "a7c43bbc03165cf0f566fcdd5d5a99bd0b6eae7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdjNDNiYmMwMzE2NWNmMGY1NjZmY2RkNWQ1YTk5YmQwYjZlYWU3Yw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-11-07T09:44:12Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-11-07T09:44:12Z"}, "message": "* gcc-interface/trans.c: Fix formatting nits.\n\nFrom-SVN: r141667", "tree": {"sha": "df0b3fe513be6e51a9db8771c5a7d0d58ec2bdb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df0b3fe513be6e51a9db8771c5a7d0d58ec2bdb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7c43bbc03165cf0f566fcdd5d5a99bd0b6eae7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7c43bbc03165cf0f566fcdd5d5a99bd0b6eae7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7c43bbc03165cf0f566fcdd5d5a99bd0b6eae7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7c43bbc03165cf0f566fcdd5d5a99bd0b6eae7c/comments", "author": null, "committer": null, "parents": [{"sha": "2575024c21b803674a4fc18cf312509f97fe5686", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2575024c21b803674a4fc18cf312509f97fe5686", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2575024c21b803674a4fc18cf312509f97fe5686"}], "stats": {"total": 77, "additions": 37, "deletions": 40}, "files": [{"sha": "fe366025f0326968d786b1aa15a90f8d95cad178", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c43bbc03165cf0f566fcdd5d5a99bd0b6eae7c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c43bbc03165cf0f566fcdd5d5a99bd0b6eae7c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a7c43bbc03165cf0f566fcdd5d5a99bd0b6eae7c", "patch": "@@ -1,3 +1,7 @@\n+2008-11-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c: Fix formatting nits.\n+\n 2008-11-07  Geert Bosch  <bosch@adacore.com>\n \n \t* gcc-interface/trans.c (build_binary_op_trapv): Avoid emitting"}, {"sha": "d1d449ef280ec09fb78fa10e629d363a890fa215", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c43bbc03165cf0f566fcdd5d5a99bd0b6eae7c/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c43bbc03165cf0f566fcdd5d5a99bd0b6eae7c/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=a7c43bbc03165cf0f566fcdd5d5a99bd0b6eae7c", "patch": "@@ -5961,16 +5961,14 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n }\n \f\n /* Make a unary operation of kind CODE using build_unary_op, but guard\n-   the operation by an overflow check. CODE can be one of NEGATE_EXPR\n-   or ABS_EXPR.  GNU_TYPE is the type desired for the result.\n-   Usually the operation is to be performed in that type.  */\n+   the operation by an overflow check.  CODE can be one of NEGATE_EXPR\n+   or ABS_EXPR.  GNU_TYPE is the type desired for the result.  Usually\n+   the operation is to be performed in that type.  */\n \n static tree\n-build_unary_op_trapv (enum tree_code code,\n-\t\t      tree gnu_type,\n-\t\t      tree operand)\n+build_unary_op_trapv (enum tree_code code, tree gnu_type, tree operand)\n {\n-  gcc_assert ((code == NEGATE_EXPR) || (code == ABS_EXPR));\n+  gcc_assert (code == NEGATE_EXPR || code == ABS_EXPR);\n \n   operand = protect_multiple_eval (operand);\n \n@@ -5980,15 +5978,13 @@ build_unary_op_trapv (enum tree_code code,\n \t\t     CE_Overflow_Check_Failed);\n }\n \n-/* Make a binary operation of kind CODE using build_binary_op, but\n-   guard the operation by an overflow check. CODE can be one of\n-   PLUS_EXPR, MINUS_EXPR or MULT_EXPR.  GNU_TYPE is the type desired\n-   for the result.  Usually the operation is to be performed in that type.  */\n+/* Make a binary operation of kind CODE using build_binary_op, but guard\n+   the operation by an overflow check.  CODE can be one of PLUS_EXPR,\n+   MINUS_EXPR or MULT_EXPR.  GNU_TYPE is the type desired for the result.\n+   Usually the operation is to be performed in that type.  */\n \n static tree\n-build_binary_op_trapv (enum tree_code code,\n-\t\t       tree gnu_type,\n-\t\t       tree left,\n+build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n \t\t       tree right)\n {\n   tree lhs = protect_multiple_eval (left);\n@@ -6002,45 +5998,42 @@ build_binary_op_trapv (enum tree_code code,\n   tree check_pos;\n   tree check_neg;\n   tree check;\n-\n   int precision = TYPE_PRECISION (gnu_type);\n \n   gcc_assert (!(precision & (precision - 1))); /* ensure power of 2 */\n \n-  /* Prefer a constant or known-positive rhs to simplify checks */\n-\n+  /* Prefer a constant or known-positive rhs to simplify checks.  */\n   if (!TREE_CONSTANT (rhs)\n       && commutative_tree_code (code)\n       && (TREE_CONSTANT (lhs) || (!tree_expr_nonnegative_p (rhs)\n \t\t\t\t  && tree_expr_nonnegative_p (lhs))))\n     {\n-\t  tree tmp = lhs;\n-\t  lhs = rhs;\n-\t  rhs = tmp;\n+      tree tmp = lhs;\n+      lhs = rhs;\n+      rhs = tmp;\n     }\n \n   rhs_lt_zero = tree_expr_nonnegative_p (rhs)\n-    ? integer_zero_node \n-    : build_binary_op (LT_EXPR, integer_type_node, rhs, zero);\n+\t\t? integer_zero_node\n+\t\t: build_binary_op (LT_EXPR, integer_type_node, rhs, zero);\n \n-  /* Should use more efficient check for operand_equal_p (lhs, rhs, 0) ??? */\n+  /* ??? Should use more efficient check for operand_equal_p (lhs, rhs, 0) */\n \n   /* Try a few strategies that may be cheaper than the general\n-     code at the end of the function, if the RHS is not known.\n+     code at the end of the function, if the rhs is not known.\n      The strategies are:\n        - Call library function for 64-bit multiplication (complex)\n        - Widen, if input arguments are sufficiently small\n-       - Determine overflow using wrapped result for addition/subtraction */\n+       - Determine overflow using wrapped result for addition/subtraction.  */\n \n   if (!TREE_CONSTANT (rhs))\n     {\n-      /* Even for add/subtract double size in order to get another basetype */\n+      /* Even for add/subtract double size to get another base type.  */\n       int needed_precision = precision * 2;\n \n       if (code == MULT_EXPR && precision == 64)\n-\t{\n-\t  return build_call_2_expr (mulv64_decl, lhs, rhs);\n-\t}\n+\treturn build_call_2_expr (mulv64_decl, lhs, rhs);\n+\n       else if (needed_precision <= BITS_PER_WORD\n \t       || (code == MULT_EXPR \n \t\t   && needed_precision <= LONG_LONG_TYPE_SIZE))\n@@ -6060,9 +6053,9 @@ build_binary_op_trapv (enum tree_code code,\n \n \t  tree result = convert (gnu_type, wide_result);\n \n-\n \t  return emit_check (check, result, CE_Overflow_Check_Failed);\n \t}\n+\n       else if (code == PLUS_EXPR || code == MINUS_EXPR)\n \t{\n \t  tree unsigned_type = gnat_type_for_size (precision, 1);\n@@ -6075,8 +6068,7 @@ build_binary_op_trapv (enum tree_code code,\n \t    (gnu_type, build_binary_op (code, gnu_type, lhs, rhs));\n \n \t  /* Overflow when (rhs < 0) ^ (wrapped_expr < lhs)), for addition\n-\t     or when (rhs < 0) ^ (wrapped_expr > lhs) for subtraction */\n-\n+\t     or when (rhs < 0) ^ (wrapped_expr > lhs) for subtraction.  */\n \t  tree check = build_binary_op\n \t    (TRUTH_XOR_EXPR, integer_type_node, rhs_lt_zero,\n \t     build_binary_op (code == PLUS_EXPR ? LT_EXPR : GT_EXPR,\n@@ -6089,24 +6081,24 @@ build_binary_op_trapv (enum tree_code code,\n   switch (code)\n     {\n     case PLUS_EXPR:\n-      /* When rhs >= 0, overflow when lhs > type_max - rhs */\n+      /* When rhs >= 0, overflow when lhs > type_max - rhs.  */\n       check_pos = build_binary_op (GT_EXPR, integer_type_node, lhs,\n \t\t\t\t   build_binary_op (MINUS_EXPR, gnu_type,\n \t\t\t\t\t\t    type_max, rhs)),\n \n-      /* When rhs < 0, overflow when lhs < type_min - rhs */\n+      /* When rhs < 0, overflow when lhs < type_min - rhs.  */\n       check_neg = build_binary_op (LT_EXPR, integer_type_node, lhs,\n \t\t\t\t   build_binary_op (MINUS_EXPR, gnu_type,\n \t\t\t\t\t\t    type_min, rhs));\n       break;\n \n     case MINUS_EXPR:\n-      /* When rhs >= 0, overflow when lhs < type_min + rhs */\n+      /* When rhs >= 0, overflow when lhs < type_min + rhs.  */\n       check_pos = build_binary_op (LT_EXPR, integer_type_node, lhs,\n \t\t\t\t   build_binary_op (PLUS_EXPR, gnu_type,\n \t\t\t\t\t\t    type_min, rhs)),\n \n-      /* When rhs < 0, overflow when lhs > type_max + rhs */\n+      /* When rhs < 0, overflow when lhs > type_max + rhs.  */\n       check_neg = build_binary_op (GT_EXPR, integer_type_node, lhs,\n \t\t\t\t   build_binary_op (PLUS_EXPR, gnu_type,\n \t\t\t\t\t\t    type_max, rhs));\n@@ -6147,18 +6139,19 @@ build_binary_op_trapv (enum tree_code code,\n   gnu_expr = build_binary_op (code, gnu_type, lhs, rhs);\n \n   /* If we can fold the expression to a constant, just return it.\n-     The caller will deal with overflow, no need to generate a check. */\n-  if (TREE_CONSTANT (gnu_expr)) return gnu_expr;\n+     The caller will deal with overflow, no need to generate a check.  */\n+  if (TREE_CONSTANT (gnu_expr))\n+    return gnu_expr;\n \n   check = fold_build3 (COND_EXPR, integer_type_node,\n \t\t       rhs_lt_zero,  check_neg, check_pos);\n \n   return emit_check (check, gnu_expr, CE_Overflow_Check_Failed);\n }\n \n-/* Emit code for a range check. GNU_EXPR is the expression to be checked,\n+/* Emit code for a range check.  GNU_EXPR is the expression to be checked,\n    GNAT_RANGE_TYPE the gnat type or subtype containing the bounds against\n-   which we have to check. */\n+   which we have to check.  */\n \n static tree\n emit_range_check (tree gnu_expr, Entity_Id gnat_range_type)"}]}