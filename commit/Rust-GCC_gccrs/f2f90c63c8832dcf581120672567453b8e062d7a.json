{"sha": "f2f90c63c8832dcf581120672567453b8e062d7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJmOTBjNjNjODgzMmRjZjU4MTEyMDY3MjU2NzQ1M2I4ZTA2MmQ3YQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-09-18T19:03:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-09-18T19:03:37Z"}, "message": "ia64-protos.h: Update.\n\n\t* config/ia64/ia64-protos.h: Update.\n\t* config/ia64/ia64.c (signed_inequality_operator): New.\n\t(ia64_expand_compare): New.\n\t(ia64_register_move_cost): Handle PR_REGS moves.\n\t(ia64_secondary_reload_class): Require a GR when moving to a PR.\n\t(struct reg_write_state): Add written_by_and/or.\n\t(struct reg_flags): Add is_and/or.\n\t(rws_update): Set them.\n\t(rws_access_regno): Test them to allow parallel comparisons.\n\t(rtx_needs_barrier): Recognize parallel comparisons.\n\t(emit_insn_group_barriers): Set prev_insn after a call stop bit.\n\tCall recog_memoized; ignore pred_rel_mutex.\n\t(emit_predicate_relation_info): Don't call find_basic_blocks here.\n\t(ia64_reorg): Do it here instead.\n\t* config/ia64/ia64.h: s/CCmode/BImode/g\n\t(MODES_TIEABLE_P): Don't tie BImode.\n\t(PREFERRED_RELOAD_CLASS): Do not reload operations into AR regs.\n\t(CONST_COSTS): Pick sensible values for CONST_INT based on context.\n\t(RTX_COSTS): Make multiply 4 insns.\n\t(MEMORY_MOVE_COST): New.\n\t(PREDICATE_CODES): Update.\n\t* config/ia64/ia64.md: s/CCmode/BImode/g\n\t(movcci, movbi): New.\n\t(andbi3, andcmbi3, iorbi3, iorcmbi3, one_cmplbi2): New.\n\t(cmpsi_and_0, cmpsi_and_1, cmpsi_andnot_0, cmpsi_andnot_1): New.\n\t(cmpdi_and_0, cmpdi_and_1, cmpdi_andnot_0, cmpdi_andnot_1): New.\n\t(tbit_and_0, tbit_and_1, tbit_and_2, tbit_and_3): New.\n\t(cmpsi_or_0, cmpsi_or_1, cmpsi_orcm_0, cmpsi_orcm_1): New.\n\t(cmpdi_or_0, cmpdi_or_1, cmpdi_orcm_0, cmpdi_orcm_1): New.\n\t(tbit_or_0, tbit_or_1, tbit_or_2, tbit_or_3): New.\n\t(mulsi, muldi): Use xmpy not xma.\n\t(cmpbi): New.\n\t(movcc, movcc_internal): Remove.\n\t(branch expanders): Use ia64_expand_compare.\n\t(setcc expanders): Likewise.\n\t(cmov insns): Use move_operand and ia64_move_ok.\n\t(pred_rel_mutex): Use unspec not unspec_volatile.  Prevent the\n\tscheduler from moving it past a use.\n\t* config/ia64/build.hacks: Remove.\n\nFrom-SVN: r36510", "tree": {"sha": "1d6ad6d0a8c7e923e27386f559f09296fda57b8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d6ad6d0a8c7e923e27386f559f09296fda57b8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2f90c63c8832dcf581120672567453b8e062d7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2f90c63c8832dcf581120672567453b8e062d7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2f90c63c8832dcf581120672567453b8e062d7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2f90c63c8832dcf581120672567453b8e062d7a/comments", "author": null, "committer": null, "parents": [{"sha": "0d9f234d9317f291eb49dab50277efeee85e5b91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d9f234d9317f291eb49dab50277efeee85e5b91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d9f234d9317f291eb49dab50277efeee85e5b91"}], "stats": {"total": 1689, "additions": 1036, "deletions": 653}, "files": [{"sha": "4c0edc7a9ecc676d38760a8ca9419471dad6f1ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2f90c63c8832dcf581120672567453b8e062d7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2f90c63c8832dcf581120672567453b8e062d7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2f90c63c8832dcf581120672567453b8e062d7a", "patch": "@@ -1,3 +1,45 @@\n+2000-09-18  Richard Henderson  <rth@cygnus.com>\n+\n+\t* config/ia64/ia64-protos.h: Update.\n+\t* config/ia64/ia64.c (signed_inequality_operator): New.\n+\t(ia64_expand_compare): New.\n+\t(ia64_register_move_cost): Handle PR_REGS moves.\n+\t(ia64_secondary_reload_class): Require a GR when moving to a PR.\n+\t(struct reg_write_state): Add written_by_and/or.\n+\t(struct reg_flags): Add is_and/or.\n+\t(rws_update): Set them.\n+\t(rws_access_regno): Test them to allow parallel comparisons.\n+\t(rtx_needs_barrier): Recognize parallel comparisons.\n+\t(emit_insn_group_barriers): Set prev_insn after a call stop bit.\n+\tCall recog_memoized; ignore pred_rel_mutex.\n+\t(emit_predicate_relation_info): Don't call find_basic_blocks here.\n+\t(ia64_reorg): Do it here instead.\n+\t* config/ia64/ia64.h: s/CCmode/BImode/g\n+\t(MODES_TIEABLE_P): Don't tie BImode.\n+\t(PREFERRED_RELOAD_CLASS): Do not reload operations into AR regs.\n+\t(CONST_COSTS): Pick sensible values for CONST_INT based on context.\n+\t(RTX_COSTS): Make multiply 4 insns.\n+\t(MEMORY_MOVE_COST): New.\n+\t(PREDICATE_CODES): Update.\n+\t* config/ia64/ia64.md: s/CCmode/BImode/g\n+\t(movcci, movbi): New.\n+\t(andbi3, andcmbi3, iorbi3, iorcmbi3, one_cmplbi2): New.\n+\t(cmpsi_and_0, cmpsi_and_1, cmpsi_andnot_0, cmpsi_andnot_1): New.\n+\t(cmpdi_and_0, cmpdi_and_1, cmpdi_andnot_0, cmpdi_andnot_1): New.\n+\t(tbit_and_0, tbit_and_1, tbit_and_2, tbit_and_3): New.\n+\t(cmpsi_or_0, cmpsi_or_1, cmpsi_orcm_0, cmpsi_orcm_1): New.\n+\t(cmpdi_or_0, cmpdi_or_1, cmpdi_orcm_0, cmpdi_orcm_1): New.\n+\t(tbit_or_0, tbit_or_1, tbit_or_2, tbit_or_3): New.\n+\t(mulsi, muldi): Use xmpy not xma.\n+\t(cmpbi): New.\n+\t(movcc, movcc_internal): Remove.\n+\t(branch expanders): Use ia64_expand_compare.\n+\t(setcc expanders): Likewise.\n+\t(cmov insns): Use move_operand and ia64_move_ok.\n+\t(pred_rel_mutex): Use unspec not unspec_volatile.  Prevent the\n+\tscheduler from moving it past a use.\n+\t* config/ia64/build.hacks: Remove.\n+\n Mon 18-Sep-2000 19:21:35 BST  Neil Booth  <NeilB@earthling.net>\n \n \t* cpphash.h (HASHSTEP): Take character rather than pointer"}, {"sha": "5da0d83ba224443b859de109515bd6bb7872c454", "filename": "gcc/config/ia64/build.hacks", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2Fconfig%2Fia64%2Fbuild.hacks", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2Fconfig%2Fia64%2Fbuild.hacks", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fbuild.hacks?ref=0d9f234d9317f291eb49dab50277efeee85e5b91", "patch": "@@ -1,97 +0,0 @@\n-The gcse.c patch fixes an optimization problem.  This is probably not the right\n-solution, but it was quick.  I will replace with a better solution later.\n-\n-The libio/libstdc++ patches are useful if you have a version of glibc without\n-thread support.  There is no official ia64 glibc version yet, and some of the\n-unofficial ones in common use are missing thread support.  libio/libstdc++\n-assume that glibc always has thread support, so we need to patch them until\n-the official ia64 glibc is available.\n-\n-Index: gcc/gcse.c\n-===================================================================\n-RCS file: /cvs/cvsfiles/devo/gcc/gcse.c,v\n-retrieving revision 1.87\n-diff -p -r1.87 gcse.c\n-*** gcse.c\t2000/01/11 14:59:28\t1.87\n---- gcse.c\t2000/02/16 04:17:06\n-*************** try_replace_reg (from, to, insn)\n-*** 4039,4045 ****\n-       information.  */\n-    if (!success && !note)\n-      {\n-!       if (!set)\n-  \treturn 0;\n-        note = REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL,\n-  \t\t\t\t\t\t   copy_rtx (SET_SRC (set)),\n---- 4039,4048 ----\n-       information.  */\n-    if (!success && !note)\n-      {\n-!       /* Don't add a REG_EQUAL note for a CCmode destination, because this\n-! \t confuses the code in cse.c that simplifies compare and branch\n-! \t instructions.  */\n-!       if (!set || GET_MODE_CLASS (GET_MODE (SET_DEST (set))) == MODE_CC)\n-  \treturn 0;\n-        note = REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL,\n-  \t\t\t\t\t\t   copy_rtx (SET_SRC (set)),\n-Index: libio/configure.in\n-===================================================================\n-RCS file: /cvs/cvsfiles/devo/libio/configure.in,v\n-retrieving revision 1.57\n-diff -p -r1.57 configure.in\n-*** configure.in\t1999/10/26 03:42:26\t1.57\n---- configure.in\t2000/02/16 04:17:56\n-*************** case \"${target}\" in\n-*** 57,62 ****\n---- 57,64 ----\n-  \t\t frags=\"linux.mt linuxaxp1.mt mtsafe.mt\" ;;\n-    *-linux-gnulibc1)\n-  \t\t frags=linuxlibc1.mt ;;\n-+   # ??? glibc does not have thread support yet, so we can't use mtsafe.mt.\n-+   ia64*-linux-gnu) frags=\"linux.mt\" ;;\n-    *-linux-gnu)   frags=\"linux.mt mtsafe.mt\" ;;\n-    *-sco3.2v[45]*)   frags=sco4.mt ;;\n-    *-isc*)        frags=isc.mt ;;\n-Index: libstdc++/configure.in\n-===================================================================\n-RCS file: /cvs/cvsfiles/devo/libstdc++/configure.in,v\n-retrieving revision 1.46\n-diff -p -r1.46 configure.in\n-*** configure.in\t1999/09/21 19:26:16\t1.46\n---- configure.in\t2000/02/16 04:17:57\n-*************** fi\n-*** 89,94 ****\n---- 89,96 ----\n-  case \"${target}\" in\n-    alpha*-*-linux-gnulibc1)\tfrags=\"${frags} linux.mt\" ;;\n-    powerpc*-*-linux-gnulibc1)\tfrags=\"${frags} linux.mt\" ;;\n-+   # ??? ia64 glibc port does not have thread support yet.\n-+   ia64*-*-linux-gnu)\t\t;;\n-    *-*-linux-gnu)\t\tfrags=\"${frags} linux.mt\" ;;\n-    *-*-openbsd*)\t\t\n-    \tcase \"x${enable_threads}\" in\n-Index: libstdc++/stl/stl_config.h\n-===================================================================\n-RCS file: /cvs/cvsfiles/devo/libstdc++/stl/stl_config.h,v\n-retrieving revision 1.17\n-diff -p -r1.17 stl_config.h\n-*** stl_config.h\t1999/12/24 16:21:31\t1.17\n---- stl_config.h\t2000/02/16 04:17:58\n-***************\n-*** 168,174 ****\n-  #   if defined(__linux__)\n-       /* glibc pre 2.0 is very buggy. We have to disable thread for it.\n-          It should be upgraded to glibc 2.0 or later. */\n-! #    if !defined(_NOTHREADS) && __GLIBC__ >= 2 && defined(_G_USING_THUNKS)\n-  #      define __STL_PTHREADS\n-  #      ifdef __STRICT_ANSI__\n-           /* Work around a bug in the glibc 2.0.x pthread.h.  */\n---- 168,175 ----\n-  #   if defined(__linux__)\n-       /* glibc pre 2.0 is very buggy. We have to disable thread for it.\n-          It should be upgraded to glibc 2.0 or later. */\n-!      /* ??? ia64 glibc port does not have thread support yet.  */\n-! #    if !defined(_NOTHREADS) && __GLIBC__ >= 2 && defined(_G_USING_THUNKS) && !defined(__ia64__)\n-  #      define __STL_PTHREADS\n-  #      ifdef __STRICT_ANSI__\n-           /* Work around a bug in the glibc 2.0.x pthread.h.  */"}, {"sha": "7cde4ea8ca25c4d17c96d53a1ad1db7dcd6583d7", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2f90c63c8832dcf581120672567453b8e062d7a/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2f90c63c8832dcf581120672567453b8e062d7a/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=f2f90c63c8832dcf581120672567453b8e062d7a", "patch": "@@ -56,6 +56,7 @@ extern int fetchadd_operand PARAMS((rtx, enum machine_mode));\n extern int fr_reg_or_fp01_operand PARAMS((rtx, enum machine_mode));\n extern int normal_comparison_operator PARAMS((rtx, enum machine_mode));\n extern int adjusted_comparison_operator PARAMS((rtx, enum machine_mode));\n+extern int signed_inequality_operator PARAMS((rtx, enum machine_mode));\n extern int call_multiple_values_operation PARAMS((rtx, enum machine_mode));\n extern int destination_operand PARAMS((rtx, enum machine_mode));\n extern int not_postinc_memory_operand PARAMS((rtx, enum machine_mode));\n@@ -71,6 +72,7 @@ extern int ia64_depz_field_mask PARAMS((rtx, rtx));\n extern rtx ia64_gp_save_reg PARAMS((int));\n extern rtx ia64_split_timode PARAMS((rtx[], rtx, rtx));\n extern rtx spill_tfmode_operand PARAMS((rtx, int));\n+extern rtx ia64_expand_compare PARAMS((enum rtx_code, enum machine_mode));\n \n extern HOST_WIDE_INT ia64_initial_elimination_offset PARAMS((int, int));\n extern void ia64_expand_prologue PARAMS((void));"}, {"sha": "31c54bceb4ff4ae2af1358fc851a0739d78975d1", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 137, "deletions": 26, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2f90c63c8832dcf581120672567453b8e062d7a/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2f90c63c8832dcf581120672567453b8e062d7a/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=f2f90c63c8832dcf581120672567453b8e062d7a", "patch": "@@ -115,7 +115,7 @@ static void ia64_add_gc_roots PARAMS ((void));\n static void ia64_init_machine_status PARAMS ((struct function *));\n static void ia64_mark_machine_status PARAMS ((struct function *));\n static void emit_insn_group_barriers PARAMS ((rtx));\n-static void emit_predicate_relation_info PARAMS ((rtx));\n+static void emit_predicate_relation_info PARAMS ((void));\n static int process_set PARAMS ((FILE *, rtx));\n \n static rtx ia64_expand_fetch_and_op PARAMS ((optab, enum machine_mode,\n@@ -663,6 +663,19 @@ adjusted_comparison_operator (op, mode)\n \t  && (code == LT || code == GE || code == LTU || code == GEU));\n }\n \n+/* Return 1 if this is a signed inequality operator.  */\n+\n+int\n+signed_inequality_operator (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  return ((mode == VOIDmode || GET_MODE (op) == mode)\n+\t  && (code == GE || code == GT\n+\t      || code == LE || code == LT));\n+}\n+\n /* Return 1 if OP is a call returning an HFA.  It is known to be a PARALLEL\n    and the first section has already been tested.  */\n \n@@ -1000,6 +1013,37 @@ spill_tfmode_operand (in, force)\n   else\n     return in;\n }\n+\n+/* Emit comparison instruction if necessary, returning the expression\n+   that holds the compare result in the proper mode.  */\n+\n+rtx\n+ia64_expand_compare (code, mode)\n+     enum rtx_code code;\n+     enum machine_mode mode;\n+{\n+  rtx op0 = ia64_compare_op0, op1 = ia64_compare_op1;\n+  rtx cmp;\n+\n+  /* If we have a BImode input, then we already have a compare result, and\n+     do not need to emit another comparison.  */\n+  if (GET_MODE (op0) == BImode)\n+    {\n+      if ((code == NE || code == EQ) && op1 == const0_rtx)\n+\tcmp = op0;\n+      else\n+\tabort ();\n+    }\n+  else\n+    {\n+      cmp = gen_reg_rtx (BImode);\n+      emit_insn (gen_rtx_SET (VOIDmode, cmp,\n+\t\t\t      gen_rtx_fmt_ee (code, BImode, op0, op1)));\n+      code = NE;\n+    }\n+\n+  return gen_rtx_fmt_ee (code, mode, cmp, const0_rtx);\n+}\n \f\n /* Begin the assembly file.  */\n \n@@ -3247,19 +3291,29 @@ ia64_register_move_cost (from, to)\n   int from_hard, to_hard;\n   int from_gr, to_gr;\n   int from_fr, to_fr;\n+  int from_pr, to_pr;\n \n   from_hard = (from == BR_REGS || from == AR_M_REGS || from == AR_I_REGS);\n   to_hard = (to == BR_REGS || to == AR_M_REGS || to == AR_I_REGS);\n   from_gr = (from == GENERAL_REGS);\n   to_gr = (to == GENERAL_REGS);\n   from_fr = (from == FR_REGS);\n   to_fr = (to == FR_REGS);\n+  from_pr = (from == PR_REGS);\n+  to_pr = (to == PR_REGS);\n \n   if (from_hard && to_hard)\n     return 8;\n   else if ((from_hard && !to_gr) || (!from_gr && to_hard))\n     return 6;\n \n+  /* Moving between PR registers takes two insns.  */\n+  else if (from_pr && to_pr)\n+    return 3;\n+  /* Moving between PR and anything but GR is impossible.  */\n+  else if ((from_pr && !to_gr) || (!from_gr && to_pr))\n+    return 6;\n+\n   /* ??? Moving from FR<->GR must be more expensive than 2, so that we get\n      secondary memory reloads for TFmode moves.  Unfortunately, we don't\n      have the mode here, so we can't check that.  */\n@@ -3335,14 +3389,19 @@ ia64_secondary_reload_class (class, mode, x)\n       break;\n \n     case PR_REGS:\n-      /* ??? This happens if we cse/gcse a CCmode value across a call,\n+      /* ??? This happens if we cse/gcse a BImode value across a call,\n \t and the function has a nonlocal goto.  This is because global\n \t does not allocate call crossing pseudos to hard registers when\n \t current_function_has_nonlocal_goto is true.  This is relatively\n \t common for C++ programs that use exceptions.  To reproduce,\n \t return NO_REGS and compile libstdc++.  */\n       if (GET_CODE (x) == MEM)\n \treturn GR_REGS;\n+\n+      /* This can happen when we take a BImode subreg of a DImode value,\n+\t and that DImode value winds up in some non-GR register.  */\n+      if (regno >= 0 && ! GENERAL_REGNO_P (regno) && ! PR_REGNO_P (regno))\n+\treturn GR_REGS;\n       break;\n \n     case GR_REGS:\n@@ -3539,21 +3598,33 @@ ia64_override_options ()\n #define AR_UNAT_BIT_0\t(FIRST_PSEUDO_REGISTER + 3)\n #define NUM_REGS\t(AR_UNAT_BIT_0 + 64)\n \n-/* For each register, we keep track of how many times it has been\n-   written in the current instruction group.  If a register is written\n-   unconditionally (no qualifying predicate), WRITE_COUNT is set to 2\n-   and FIRST_PRED is ignored.  If a register is written if its\n-   qualifying predicate P is true, we set WRITE_COUNT to 1 and\n-   FIRST_PRED to P.  Later on, the same register may be written again\n-   by the complement of P (P+1 if P is even, P-1, otherwise) and when\n-   this happens, WRITE_COUNT gets set to 2.  The result of this is\n-   that whenever an insn attempts to write a register whose\n-   WRITE_COUNT is two, we need to issue a insn group barrier first.  */\n+/* For each register, we keep track of how it has been written in the\n+   current instruction group.\n+\n+   If a register is written unconditionally (no qualifying predicate),\n+   WRITE_COUNT is set to 2 and FIRST_PRED is ignored.\n+\n+   If a register is written if its qualifying predicate P is true, we\n+   set WRITE_COUNT to 1 and FIRST_PRED to P.  Later on, the same register\n+   may be written again by the complement of P (P^1) and when this happens,\n+   WRITE_COUNT gets set to 2.\n+\n+   The result of this is that whenever an insn attempts to write a register\n+   whose WRITE_COUNT is two, we need to issue a insn group barrier first.\n+\n+   If a predicate register is written by a floating-point insn, we set\n+   WRITTEN_BY_FP to true.\n+\n+   If a predicate register is written by an AND.ORCM we set WRITTEN_BY_AND\n+   to true; if it was written by an OR.ANDCM we set WRITTEN_BY_OR to true.  */\n+\n struct reg_write_state\n {\n-  char write_count;\n-  char written_by_fp;\t/* Was register written by a floating-point insn?  */\n-  short first_pred;\t/* 0 means ``no predicate'' */\n+  unsigned int write_count : 2;\n+  unsigned int first_pred : 16;\n+  unsigned int written_by_fp : 1;\n+  unsigned int written_by_and : 1;\n+  unsigned int written_by_or : 1;\n };\n \n /* Cumulative info for the current instruction group.  */\n@@ -3569,6 +3640,8 @@ struct reg_flags\n   unsigned int is_write : 1;\t/* Is register being written?  */\n   unsigned int is_fp : 1;\t/* Is register used as part of an fp op?  */\n   unsigned int is_branch : 1;\t/* Is register used as part of a branch?  */\n+  unsigned int is_and : 1;\t/* Is register used as part of and.orcm?  */\n+  unsigned int is_or : 1;\t/* Is register used as part of or.andcm?  */\n };\n \n static void rws_update PARAMS ((struct reg_write_state *, int,\n@@ -3589,6 +3662,9 @@ rws_update (rws, regno, flags, pred)\n {\n   rws[regno].write_count += pred ? 1 : 2;\n   rws[regno].written_by_fp |= flags.is_fp;\n+  /* ??? Not tracking and/or across differing predicates.  */\n+  rws[regno].written_by_and = flags.is_and;\n+  rws[regno].written_by_or = flags.is_or;\n   rws[regno].first_pred = pred;\n }\n \n@@ -3607,6 +3683,9 @@ rws_access_regno (regno, flags, pred)\n   if (regno >= NUM_REGS)\n     abort ();\n \n+  if (! PR_REGNO_P (regno))\n+    flags.is_and = flags.is_or = 0;\n+\n   if (flags.is_write)\n     {\n       int write_count;\n@@ -3631,15 +3710,26 @@ rws_access_regno (regno, flags, pred)\n \t     not a complementary predicate, then we need a barrier.  */\n \t  /* ??? This assumes that P and P+1 are always complementary\n \t     predicates for P even.  */\n-\t  if ((rws_sum[regno].first_pred ^ 1) != pred)\n+\t  if (flags.is_and && rws_sum[regno].written_by_and)\n+\t    ; \n+\t  else if (flags.is_or && rws_sum[regno].written_by_or)\n+\t    ;\n+\t  else if ((rws_sum[regno].first_pred ^ 1) != pred)\n \t    need_barrier = 1;\n \t  rws_update (rws_sum, regno, flags, pred);\n \t  break;\n \n \tcase 2:\n \t  /* The register has been unconditionally written already.  We\n \t     need a barrier.  */\n-\t  need_barrier = 1;\n+\t  if (flags.is_and && rws_sum[regno].written_by_and)\n+\t    ;\n+\t  else if (flags.is_or && rws_sum[regno].written_by_or)\n+\t    ;\n+\t  else\n+\t    need_barrier = 1;\n+\t  rws_sum[regno].written_by_and = flags.is_and;\n+\t  rws_sum[regno].written_by_or = flags.is_or;\n \t  break;\n \n \tdefault:\n@@ -3669,6 +3759,11 @@ rws_access_regno (regno, flags, pred)\n \t    return 0;\n \t}\n \n+      if (flags.is_and && rws_sum[regno].written_by_and)\n+\treturn 0;\n+      if (flags.is_or && rws_sum[regno].written_by_or)\n+\treturn 0;\n+\n       switch (rws_sum[regno].write_count)\n \t{\n \tcase 0:\n@@ -3806,6 +3901,15 @@ rtx_needs_barrier (x, flags, pred)\n \t       with a floating point comparison when processing the\n \t       destination of the SET.  */\n \t    new_flags.is_fp = 1;\n+\n+\t  /* Discover if this is a parallel comparison.  We only handle\n+\t     and.orcm and or.andcm at present, since we must retain a\n+\t     strict inverse on the predicate pair.  */\n+\t  else if (GET_CODE (src) == AND)\n+\t    new_flags.is_and = flags.is_and = 1;\n+\t  else if (GET_CODE (src) == IOR)\n+\t    new_flags.is_or = flags.is_or = 1;\n+\n \t  break;\n \t}\n       need_barrier = rtx_needs_barrier (src, flags, pred);\n@@ -3991,6 +4095,7 @@ rtx_needs_barrier (x, flags, pred)\n \t  need_barrier = rtx_needs_barrier (XVECEXP (x, 0, 0), flags, pred);\n \t  break;\n \n+\tcase 7: /* pred_rel_mutex */\n         case 12: /* mf */\n         case 19: /* fetchadd_acq */\n \tcase 20: /* mov = ar.bsp */\n@@ -4162,6 +4267,8 @@ emit_insn_group_barriers (insns)\n \t      memset (rws_sum, 0, sizeof (rws_sum));\n \t      prev_insn = NULL_RTX;\n \t    }\n+\t  else\n+\t    prev_insn = insn;\n \t  break;\n \t\n \tcase JUMP_INSN:\n@@ -4179,7 +4286,7 @@ emit_insn_group_barriers (insns)\n \t      rtx pat = PATTERN (insn);\n \n \t      /* Ug.  Hack hacks hacked elsewhere.  */\n-\t      switch (INSN_CODE (insn))\n+\t      switch (recog_memoized (insn))\n \t\t{\n \t\t  /* We play dependency tricks with the epilogue in order\n \t\t     to get proper schedules.  Undo this for dv analysis.  */\n@@ -4205,6 +4312,10 @@ emit_insn_group_barriers (insns)\n \t\t  pat = XVECEXP (pat, 0, 0);\n \t\t  break;\n \n+\t\t  /* Doesn't generate code.  */\n+\t\tcase CODE_FOR_pred_rel_mutex:\n+\t\t  continue;\n+\n \t\tdefault:\n \t\t  break;\n \t\t}\n@@ -4250,15 +4361,10 @@ emit_insn_group_barriers (insns)\n    straight-line code.  */\n \n static void\n-emit_predicate_relation_info (insns)\n-     rtx insns;\n+emit_predicate_relation_info ()\n {\n   int i;\n \n-  /* Make sure the CFG and global_live_at_start are correct.  */\n-  find_basic_blocks (insns, max_reg_num (), NULL);\n-  life_analysis (insns, NULL, 0);\n-\n   for (i = n_basic_blocks - 1; i >= 0; --i)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n@@ -4275,7 +4381,7 @@ emit_predicate_relation_info (insns)\n       for (r = PR_REG (0); r < PR_REG (64); r += 2)\n \tif (REGNO_REG_SET_P (bb->global_live_at_start, r))\n \t  {\n-\t    rtx p = gen_rtx_REG (CCmode, r);\n+\t    rtx p = gen_rtx_REG (BImode, r);\n \t    rtx n = emit_insn_after (gen_pred_rel_mutex (p), head);\n \t    if (head == bb->end)\n \t      bb->end = n;\n@@ -4323,8 +4429,13 @@ ia64_reorg (insns)\n   if (optimize == 0)\n     split_all_insns (0);\n \n-  emit_predicate_relation_info (insns);\n+  /* Make sure the CFG and global_live_at_start are correct\n+     for emit_predicate_relation_info.  */\n+  find_basic_blocks (insns, max_reg_num (), NULL);\n+  life_analysis (insns, NULL, 0);\n+\n   emit_insn_group_barriers (insns);\n+  emit_predicate_relation_info ();\n }\n \f\n /* Return true if REGNO is used by the epilogue.  */"}, {"sha": "f2402a38ea430c90eba4450f84babbc5f0b2dbcf", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 56, "deletions": 41, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2f90c63c8832dcf581120672567453b8e062d7a/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2f90c63c8832dcf581120672567453b8e062d7a/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=f2f90c63c8832dcf581120672567453b8e062d7a", "patch": "@@ -813,13 +813,13 @@ while (0)\n /* A C expression for the number of consecutive hard registers, starting at\n    register number REGNO, required to hold a value of mode MODE.  */\n \n-/* ??? We say that CCmode values require two registers.  This allows us to\n+/* ??? We say that BImode PR values require two registers.  This allows us to\n    easily store the normal and inverted values.  We use CCImode to indicate\n    a single predicate register.  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n   ((REGNO) == PR_REG (0) && (MODE) == DImode ? 64\t\t\t\\\n-   : PR_REGNO_P (REGNO) && (MODE) == CCmode ? 2\t\t\t\t\\\n+   : PR_REGNO_P (REGNO) && (MODE) == BImode ? 2\t\t\t\t\\\n    : PR_REGNO_P (REGNO) && (MODE) == CCImode ? 1\t\t\t\\\n    : FR_REGNO_P (REGNO) && (MODE) == TFmode ? 1\t\t\t\t\\\n    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n@@ -828,12 +828,14 @@ while (0)\n    MODE in hard register number REGNO (or in several registers starting with\n    that one).  */\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n-  (FR_REGNO_P (REGNO) ? GET_MODE_CLASS (MODE) != MODE_CC && (MODE) != TImode \\\n-   : PR_REGNO_P (REGNO) ? GET_MODE_CLASS (MODE) == MODE_CC\t\t\\\n-   : GR_REGNO_P (REGNO) ? (MODE) != CCImode && (MODE) != TFmode\t\t\\\n-   : AR_REGNO_P (REGNO) ? (MODE) == DImode\t\t\t\t\\\n-   : BR_REGNO_P (REGNO) ? (MODE) == DImode\t\t\t\t\\\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\\\n+  (FR_REGNO_P (REGNO) ?\t\t\t\t\t\t\\\n+     GET_MODE_CLASS (MODE) != MODE_CC && (MODE) != TImode && (MODE) != BImode \\\n+   : PR_REGNO_P (REGNO) ?\t\t\t\t\t\\\n+     (MODE) == BImode || GET_MODE_CLASS (MODE) == MODE_CC\t\\\n+   : GR_REGNO_P (REGNO) ? (MODE) != CCImode && (MODE) != TFmode\t\\\n+   : AR_REGNO_P (REGNO) ? (MODE) == DImode\t\t\t\\\n+   : BR_REGNO_P (REGNO) ? (MODE) == DImode\t\t\t\\\n    : 0)\n \n /* A C expression that is nonzero if it is desirable to choose register\n@@ -843,22 +845,13 @@ while (0)\n    If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R, MODE2)' are\n    ever different for any R, then `MODES_TIEABLE_P (MODE1, MODE2)' must be\n    zero.  */\n-/* ??? If the comments are true, then this must be zero if one mode is CCmode,\n-   INTEGRAL_MODE_P or FLOAT_MODE_P and the other is not.  Otherwise, it is\n-   true.  */\n /* Don't tie integer and FP modes, as that causes us to get integer registers\n    allocated for FP instructions.  TFmode only supported in FP registers so\n    we can't tie it with any other modes.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  ((GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2)) \\\n-   && (((MODE1) == TFmode) == ((MODE2) == TFmode)))\n-\n-/* Define this macro if the compiler should avoid copies to/from CCmode\n-   registers.  You should only define this macro if support fo copying to/from\n-   CCmode is incomplete.  */\n-/* ??? CCmode copies are very expensive, so we might want this defined.  */\n-/* #define AVOID_CCMODE_COPIES */\n-\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n+  (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2)\t\\\n+   && (((MODE1) == TFmode) == ((MODE2) == TFmode))\t\\\n+   && (((MODE1) == BImode) == ((MODE2) == BImode)))\n \f\n /* Handling Leaf Functions */\n \n@@ -910,9 +903,8 @@ enum reg_class\n /* An initializer containing the names of the register classes as C string\n    constants.  These names are used in writing some of the debugging dumps.  */\n #define REG_CLASS_NAMES \\\n-{ \"NO_REGS\", \"PR_REGS\", \"BR_REGS\", \"ADDL_REGS\", \"GR_REGS\", \\\n-  \"FR_REGS\", \"GR_AND_FR_REGS\", \"AR_M_REGS\", \"AR_I_REGS\", \\\n-  \"ALL_REGS\" }\n+{ \"NO_REGS\", \"PR_REGS\", \"BR_REGS\", \"ADDL_REGS\", \"GR_REGS\", \"FR_REGS\", \\\n+  \"GR_AND_FR_REGS\", \"AR_M_REGS\", \"AR_I_REGS\", \"ALL_REGS\" }\n \n /* An initializer containing the contents of the register classes, as integers\n    which are bit masks.  The Nth integer specifies the contents of class N.\n@@ -1022,11 +1014,13 @@ enum reg_class\n \n /* Don't allow volatile mem reloads into floating point registers.  This\n    is defined to force reload to choose the r/m case instead of the f/f case\n-   when reloading (set (reg fX) (mem/v)).  */\n+   when reloading (set (reg fX) (mem/v)).\n+\n+   Do not reload expressions into AR regs.  */\n \n #define PREFERRED_RELOAD_CLASS(X, CLASS) \\\n-  ((CLASS == FR_REGS && GET_CODE (X) == MEM && MEM_VOLATILE_P (X))\t\\\n-   ? NO_REGS\t\t\t\t\t\t\t\t\\\n+  (CLASS == FR_REGS && GET_CODE (X) == MEM && MEM_VOLATILE_P (X) ? NO_REGS   \\\n+   : GET_RTX_CLASS (GET_CODE (X)) != 'o' && CLASS > GR_AND_FR_REGS ? NO_REGS \\\n    : CLASS)\n \n /* You should define this macro to indicate to the reload phase that it may\n@@ -1061,7 +1055,7 @@ enum reg_class\n    This is closely related to the macro `HARD_REGNO_NREGS'.  */\n \n #define CLASS_MAX_NREGS(CLASS, MODE) \\\n-  ((MODE) == CCmode && (CLASS) == PR_REGS ? 2\t\t\t\\\n+  ((MODE) == BImode && (CLASS) == PR_REGS ? 2\t\t\t\\\n    : ((CLASS) == FR_REGS && (MODE) == TFmode) ? 1\t\t\\\n    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n@@ -1823,29 +1817,49 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* ??? This is incomplete.  */\n \n-#define CONST_COSTS(X, CODE, OUTER_CODE) \\\n+#define CONST_COSTS(X, CODE, OUTER_CODE)\t\t\t\t\\\n   case CONST_INT:\t\t\t\t\t\t\t\\\n     if ((X) == const0_rtx)\t\t\t\t\t\t\\\n       return 0;\t\t\t\t\t\t\t\t\\\n+    switch (OUTER_CODE)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+      case SET:\t\t\t\t\t\t\t\t\\\n+\treturn CONST_OK_FOR_J (INTVAL (X)) ? 0 : COSTS_N_INSNS (1);\t\\\n+      case PLUS:\t\t\t\t\t\t\t\\\n+\tif (CONST_OK_FOR_I (INTVAL (X)))\t\t\t\t\\\n+\t  return 0;\t\t\t\t\t\t\t\\\n+\tif (CONST_OK_FOR_J (INTVAL (X)))\t\t\t\t\\\n+\t  return 1;\t\t\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (1);\t\t\t\t\t\\\n+      default:\t\t\t\t\t\t\t\t\\\n+\tif (CONST_OK_FOR_K (INTVAL (X)) || CONST_OK_FOR_L (INTVAL (X)))\t\\\n+\t  return 0;\t\t\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (1);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n   case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n   case CONST:\t\t\t\t\t\t\t\t\\\n   case SYMBOL_REF:\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (1);\n+    return COSTS_N_INSNS (2);\n \n /* Like `CONST_COSTS' but applies to nonconstant RTL expressions.  */\n \n-/* ??? Should define this to get better optimized code.  */\n-\n-/* We make divide expensive, so that divide-by-constant will be optimized to\n-   a multiply.  */\n-\n-#define RTX_COSTS(X, CODE, OUTER_CODE) \\\n+#define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\t\t\\\n+    /* For multiplies wider than HImode, we have to go to the FPU,\t\\\n+       which normally involves copies.  Plus there's the latency\t\\\n+       of the multiply itself.  */\t\t\t\t\t\\\n+    if (GET_MODE_SIZE (GET_MODE (X)) > 2)\t\t\t\t\\\n+      return COSTS_N_INSNS (4);\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n   case DIV:\t\t\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\t\t\\\n   case MOD:\t\t\t\t\t\t\t\t\\\n   case UMOD:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (20);\n+    /* We make divide expensive, so that divide-by-constant will be\t\\\n+       optimized to a multiply.  */\t\t\t\t\t\\\n+    return COSTS_N_INSNS (60);\n \n /* An expression giving the cost of an addressing mode that contains ADDRESS.\n    If not defined, the cost is computed from the ADDRESS expression and the\n@@ -1859,10 +1873,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define REGISTER_MOVE_COST(FROM, TO) \\\n   ia64_register_move_cost((FROM), (TO))\n \n-/* A C expression for the cost of moving data of mode M between a register and\n-   memory.  */\n-/* ??? Investigate.  Might get better code by defining this.  */\n-/* #define MEMORY_MOVE_COST(M,C,I) */\n+/* A C expression for the cost of moving data of mode M between a\n+   register and memory.  */\n+#define MEMORY_MOVE_COST(MODE,CLASS,IN) \\\n+  ((CLASS) == GENERAL_REGS || (CLASS) == FR_REGS ? 4 : 10)\n \n /* A C expression for the cost of a branch instruction.  A value of 1 is the\n    default; other values are interpreted relative to that.  Used by the \n@@ -2682,6 +2696,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n { \"fr_reg_or_fp01_operand\", {SUBREG, REG, CONST_DOUBLE}},\t\t\\\n { \"normal_comparison_operator\", {EQ, NE, GT, LE, GTU, LEU}},\t\t\\\n { \"adjusted_comparison_operator\", {LT, GE, LTU, GEU}},\t\t\t\\\n+{ \"signed_inequality_operator\", {GE, GT, LE, LT}},\t\t\t\\\n { \"call_multiple_values_operation\", {PARALLEL}},\t\t\t\\\n { \"predicate_operator\", {NE, EQ}},\t\t\t\t\t\\\n { \"ar_lc_reg_operand\", {REG}},\t\t\t\t\t\t\\"}, {"sha": "45479a22c771d82801fb0669e6ba86c67ea60fb1", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 799, "deletions": 489, "changes": 1288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2f90c63c8832dcf581120672567453b8e062d7a/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2f90c63c8832dcf581120672567453b8e062d7a/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=f2f90c63c8832dcf581120672567453b8e062d7a", "patch": "@@ -60,6 +60,7 @@\n ;;\t3\tfr_spill\n ;;\t4\tfr_restore\n ;;\t5\trecip_approx\n+;;\t7\tpred_rel_mutex\n ;;\t8\tpopcnt\n ;;\t12\tmf\n ;;\t13\tcmpxchg_acq\n@@ -72,7 +73,6 @@\n ;;\t1\tblockage\n ;;\t2\tinsn_group_barrier\n ;;\t5\tset_bsp\n-;;\t7\tpred.rel.mutex\n ;;\t8\tpred.safe_across_calls all\n ;;\t9\tpred.safe_across_calls normal\n \f\n@@ -159,6 +159,61 @@\n ;; ::\n ;; ::::::::::::::::::::\n \n+;; Set of a single predicate register.  This is only used to implement\n+;; pr-to-pr move and complement.\n+\n+(define_insn \"*movcci\"\n+  [(set (match_operand:CCI 0 \"register_operand\" \"=c,c,c\")\n+\t(match_operand:CCI 1 \"nonmemory_operand\" \"O,n,c\"))]\n+  \"\"\n+  \"@\n+   cmp.ne %0, p0 = r0, r0\n+   cmp.eq %0, p0 = r0, r0\n+   (%1) cmp.eq.unc %0, p0 = r0, r0\"\n+  [(set_attr \"type\" \"A\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"movbi\"\n+  [(set (match_operand:BI 0 \"nonimmediate_operand\" \"=c,c,?c,?*r, c,*r,*r,*m\")\n+\t(match_operand:BI 1 \"move_operand\"         \" O,n, c,  c,*r, n,*m,*r\"))]\n+  \"\"\n+  \"@\n+   cmp.ne %0, %I0 = r0, r0\n+   cmp.eq %0, %I0 = r0, r0\n+   #\n+   #\n+   tbit.nz %0, %I0 = %1, 0\n+   adds %0 = %1, r0\n+   ld1%O1 %0 = %1%P1\n+   st1%Q0 %0 = %1%P0\"\n+  [(set_attr \"type\" \"A,A,unknown,unknown,I,A,M,M\")])\n+\n+(define_split\n+  [(set (match_operand:BI 0 \"register_operand\" \"\")\n+\t(match_operand:BI 1 \"register_operand\" \"\"))]\n+  \"reload_completed\n+   && GET_CODE (operands[0]) == REG && GR_REGNO_P (REGNO (operands[0]))\n+   && GET_CODE (operands[1]) == REG && PR_REGNO_P (REGNO (operands[1]))\"\n+  [(cond_exec (ne (match_dup 1) (const_int 0))\n+     (set (match_dup 0) (const_int 1)))\n+   (cond_exec (eq (match_dup 1) (const_int 0))\n+     (set (match_dup 0) (const_int 0)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:BI 0 \"register_operand\" \"\")\n+\t(match_operand:BI 1 \"register_operand\" \"\"))]\n+  \"reload_completed\n+   && GET_CODE (operands[0]) == REG && PR_REGNO_P (REGNO (operands[0]))\n+   && GET_CODE (operands[1]) == REG && PR_REGNO_P (REGNO (operands[1]))\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))\n+   (set (match_dup 0) (unspec:BI [(match_dup 0)] 7))]\n+  \"operands[2] = gen_rtx_REG (CCImode, REGNO (operands[0]));\n+   operands[3] = gen_rtx_REG (CCImode, REGNO (operands[0]) + 1);\n+   operands[4] = gen_rtx_REG (CCImode, REGNO (operands[1]));\n+   operands[5] = gen_rtx_REG (CCImode, REGNO (operands[1]) + 1);\")\n+\n (define_expand \"movqi\"\n   [(set (match_operand:QI 0 \"general_operand\" \"\")\n \t(match_operand:QI 1 \"general_operand\" \"\"))]\n@@ -180,7 +235,7 @@\n (define_insn \"*movqicc_astep\"\n   [(cond_exec\n      (match_operator 2 \"predicate_operator\"\n-       [(match_operand:CC 3 \"register_operand\" \"c,c,c,c,c\")\n+       [(match_operand:BI 3 \"register_operand\" \"c,c,c,c,c\")\n         (const_int 0)])\n      (set (match_operand:QI 0 \"register_operand\"  \"=r,r, r,*f,*f\")\n \t  (match_operand:QI 1 \"nonmemory_operand\" \"rO,J,*f,rO,*f\")))]\n@@ -238,7 +293,7 @@\n (define_insn \"*movhicc_astep\"\n   [(cond_exec\n      (match_operator 2 \"predicate_operator\"\n-       [(match_operand:CC 3 \"register_operand\" \"c,c,c,c,c\")\n+       [(match_operand:BI 3 \"register_operand\" \"c,c,c,c,c\")\n         (const_int 0)])\n      (set (match_operand:HI 0 \"register_operand\"  \"=r,r, r,*f,*f\")\n \t  (match_operand:HI 1 \"nonmemory_operand\" \"rO,J,*f,rO,*f\")))]\n@@ -296,7 +351,7 @@\n (define_insn \"*movsicc_astep\"\n   [(cond_exec\n      (match_operator 2 \"predicate_operator\"\n-       [(match_operand:CC 3 \"register_operand\" \"c,c,c,c,c,c,c,c\")\n+       [(match_operand:BI 3 \"register_operand\" \"c,c,c,c,c,c,c,c\")\n         (const_int 0)])\n      (set (match_operand:SI 0 \"register_operand\"  \"=r,r,r, r,*f,*f, r,*d\")\n \t  (match_operand:SI 1 \"nonmemory_operand\" \"rO,J,i,*f,rO,*f,*d,rK\")))]\n@@ -383,7 +438,7 @@\n (define_insn \"\"\n   [(cond_exec\n      (match_operator 2 \"predicate_operator\"\n-       [(match_operand:CC 3 \"register_operand\" \"c,c,c,c,c,c,c,c,c,c,c\")\n+       [(match_operand:BI 3 \"register_operand\" \"c,c,c,c,c,c,c,c,c,c,c\")\n         (const_int 0)])\n      (set (match_operand:DI 0 \"register_operand\"\n \t\t\t      \"=r,r,r, r,*f,*f,   r,*b,*e, r,*d\")\n@@ -719,7 +774,7 @@\n (define_insn \"*movsfcc_astep\"\n   [(cond_exec\n      (match_operator 2 \"predicate_operator\"\n-       [(match_operand:CC 3 \"register_operand\" \"c,c,c,c\")\n+       [(match_operand:BI 3 \"register_operand\" \"c,c,c,c\")\n         (const_int 0)])\n      (set (match_operand:SF 0 \"register_operand\"  \"=f,*r, f,*r\")\n \t  (match_operand:SF 1 \"nonmemory_operand\" \"fG,fG,*r,*r\")))]\n@@ -778,7 +833,7 @@\n (define_insn \"*movdfcc_astep\"\n   [(cond_exec\n      (match_operator 2 \"predicate_operator\"\n-       [(match_operand:CC 3 \"register_operand\" \"c,c,c,c\")\n+       [(match_operand:BI 3 \"register_operand\" \"c,c,c,c\")\n         (const_int 0)])\n      (set (match_operand:DF 0 \"register_operand\"  \"=f,*r, f,*r\")\n \t  (match_operand:DF 1 \"nonmemory_operand\" \"fG,fG,*r,*r\")))]\n@@ -900,7 +955,7 @@\n (define_insn \"*movtfcc_astep\"\n   [(cond_exec\n      (match_operator 2 \"predicate_operator\"\n-       [(match_operand:CC 3 \"register_operand\" \"c\")\n+       [(match_operand:BI 3 \"register_operand\" \"c\")\n         (const_int 0)])\n      (set (match_operand:TF 0 \"register_operand\"  \"=f\")\n \t  (match_operand:TF 1 \"nonmemory_operand\" \"fG\")))]\n@@ -1357,6 +1412,520 @@\n \f\n ;; ::::::::::::::::::::\n ;; ::\n+;; :: 1 bit Integer arithmetic\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_insn_and_split \"andbi3\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c,c,r\")\n+\t(and:BI (match_operand:BI 1 \"register_operand\" \"%0,0,r\")\n+\t\t(match_operand:BI 2 \"register_operand\" \"c,r,r\")))]\n+  \"\"\n+  \"@\n+   #\n+   tbit.nz.and.orcm %0, %I0 = %2, 0\n+   and %0 = %2, %1\"\n+  \"reload_completed\n+   && GET_CODE (operands[0]) == REG && PR_REGNO_P (REGNO (operands[0]))\n+   && GET_CODE (operands[2]) == REG && PR_REGNO_P (REGNO (operands[2]))\"\n+  [(cond_exec (eq (match_dup 2) (const_int 0))\n+     (set (match_dup 0) (and:BI (ne:BI (const_int 0) (const_int 0))\n+\t\t\t\t(match_dup 0))))]\n+  \"\"\n+  [(set_attr \"type\" \"unknown,I,A\")])\n+\n+(define_insn_and_split \"*andcmbi3\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c,c,r\")\n+\t(and:BI (not:BI (match_operand:BI 1 \"register_operand\" \"c,r,r\"))\n+\t\t(match_operand:BI 2 \"register_operand\" \"0,0,r\")))]\n+  \"\"\n+  \"@\n+   #\n+   tbit.z.and.orcm %0, %I0 = %2, 0\n+   andcm %0 = %2, %1\"\n+  \"reload_completed\n+   && GET_CODE (operands[0]) == REG && PR_REGNO_P (REGNO (operands[0]))\n+   && GET_CODE (operands[2]) == REG && PR_REGNO_P (REGNO (operands[2]))\"\n+  [(cond_exec (ne (match_dup 1) (const_int 0))\n+     (set (match_dup 0) (and:BI (ne:BI (const_int 0) (const_int 0))\n+\t\t\t\t(match_dup 0))))]\n+  \"\"\n+  [(set_attr \"type\" \"unknown,I,A\")])\n+\n+(define_insn_and_split \"iorbi3\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c,c,r\")\n+\t(ior:BI (match_operand:BI 1 \"register_operand\" \"%0,0,r\")\n+\t\t(match_operand:BI 2 \"register_operand\" \"c,r,r\")))]\n+  \"\"\n+  \"@\n+   #\n+   tbit.nz.or.andcm %0, %I0 = %2, 0\n+   or %0 = %2, %1\"\n+  \"reload_completed\n+   && GET_CODE (operands[0]) == REG && PR_REGNO_P (REGNO (operands[0]))\n+   && GET_CODE (operands[2]) == REG && PR_REGNO_P (REGNO (operands[2]))\"\n+  [(cond_exec (ne (match_dup 2) (const_int 0))\n+     (set (match_dup 0) (ior:BI (eq:BI (const_int 0) (const_int 0))\n+\t\t\t\t(match_dup 0))))]\n+  \"\"\n+  [(set_attr \"type\" \"unknown,I,A\")])\n+\n+(define_insn_and_split \"*iorcmbi3\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c,c\")\n+\t(ior:BI (not:BI (match_operand:BI 1 \"register_operand\" \"c,r\"))\n+\t\t(match_operand:BI 2 \"register_operand\" \"0,0\")))]\n+  \"\"\n+  \"@\n+   #\n+   tbit.z.or.andcm %0, %I0 = %2, 0\"\n+  \"reload_completed\n+   && GET_CODE (operands[0]) == REG && PR_REGNO_P (REGNO (operands[0]))\n+   && GET_CODE (operands[2]) == REG && PR_REGNO_P (REGNO (operands[2]))\"\n+  [(cond_exec (eq (match_dup 1) (const_int 0))\n+     (set (match_dup 0) (ior:BI (eq:BI (const_int 0) (const_int 0))\n+\t\t\t\t(match_dup 0))))]\n+  \"\"\n+  [(set_attr \"type\" \"unknown,I\")])\n+\n+(define_insn \"one_cmplbi2\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c,r,c,&c\")\n+\t(not:BI (match_operand:BI 1 \"register_operand\" \"r,r,0,c\")))\n+   (clobber (match_scratch:BI 2 \"=X,X,c,X\"))]\n+  \"\"\n+  \"@\n+   tbit.z %0, %I0 = %1, 0\n+   xor %0 = 1, %1\n+   #\n+   #\"\n+  [(set_attr \"type\" \"I,A,unknown,unknown\")])\n+\n+(define_split\n+  [(set (match_operand:BI 0 \"register_operand\" \"\")\n+\t(not:BI (match_operand:BI 1 \"register_operand\" \"\")))\n+   (clobber (match_scratch:BI 2 \"\"))]\n+  \"reload_completed\n+   && GET_CODE (operands[0]) == REG && PR_REGNO_P (REGNO (operands[0]))\n+   && GET_CODE (operands[1]) == REG && PR_REGNO_P (REGNO (operands[1]))\n+   && rtx_equal_p (operands[0], operands[1])\"\n+  [(set (match_dup 4) (match_dup 3))\n+   (set (match_dup 0) (const_int 1))\n+   (cond_exec (ne (match_dup 2) (const_int 0))\n+     (set (match_dup 0) (const_int 0)))\n+   (set (match_dup 0) (unspec:BI [(match_dup 0)] 7))]\n+  \"operands[3] = gen_rtx_REG (CCImode, REGNO (operands[1]));\n+   operands[4] = gen_rtx_REG (CCImode, REGNO (operands[2]));\")\n+\n+(define_split\n+  [(set (match_operand:BI 0 \"register_operand\" \"\")\n+\t(not:BI (match_operand:BI 1 \"register_operand\" \"\")))\n+   (clobber (match_scratch:BI 2 \"\"))]\n+  \"reload_completed\n+   && GET_CODE (operands[0]) == REG && PR_REGNO_P (REGNO (operands[0]))\n+   && GET_CODE (operands[1]) == REG && PR_REGNO_P (REGNO (operands[1]))\n+   && ! rtx_equal_p (operands[0], operands[1])\"\n+  [(cond_exec (ne (match_dup 1) (const_int 0))\n+     (set (match_dup 0) (const_int 0)))\n+   (cond_exec (eq (match_dup 1) (const_int 0))\n+     (set (match_dup 0) (const_int 1)))\n+   (set (match_dup 0) (unspec:BI [(match_dup 0)] 7))]\n+  \"\")\n+\n+(define_insn \"*cmpsi_and_0\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(and:BI (match_operator:BI 4 \"predicate_operator\"\n+\t\t  [(match_operand:SI 2 \"gr_reg_or_0_operand\" \"rO\")\n+\t\t   (match_operand:SI 3 \"gr_reg_or_8bit_operand\" \"rK\")])\n+\t\t(match_operand:BI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmp4.%C4.and.orcm %0, %I0 = %3, %r2\"\n+  [(set_attr \"type\" \"A\")])\n+\n+(define_insn \"*cmpsi_and_1\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(and:BI (match_operator:BI 3 \"signed_inequality_operator\"\n+\t\t  [(match_operand:SI 2 \"gr_register_operand\" \"r\")\n+\t\t   (const_int 0)])\n+\t\t(match_operand:BI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmp4.%C3.and.orcm %0, %I0 = r0, %2\"\n+  [(set_attr \"type\" \"A\")])\n+\n+(define_insn \"*cmpsi_andnot_0\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(and:BI (not:BI (match_operator:BI 4 \"predicate_operator\"\n+\t\t\t [(match_operand:SI 2 \"gr_reg_or_0_operand\" \"rO\")\n+\t\t\t  (match_operand:SI 3 \"gr_reg_or_8bit_operand\" \"rK\")]))\n+\t\t(match_operand:BI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmp4.%C4.or.andcm %I0, %0 = %3, %r2\"\n+  [(set_attr \"type\" \"A\")])\n+\n+(define_insn \"*cmpsi_andnot_1\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(and:BI (not:BI (match_operator:BI 3 \"signed_inequality_operator\"\n+\t\t\t  [(match_operand:SI 2 \"gr_register_operand\" \"r\")\n+\t\t\t   (const_int 0)]))\n+\t\t(match_operand:BI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmp4.%C3.or.andcm %I0, %0 = r0, %2\"\n+  [(set_attr \"type\" \"A\")])\n+\n+(define_insn \"*cmpdi_and_0\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(and:BI (match_operator:BI 4 \"predicate_operator\"\n+\t\t  [(match_operand:DI 2 \"gr_register_operand\" \"r\")\n+\t\t   (match_operand:DI 3 \"gr_reg_or_8bit_operand\" \"rK\")])\n+\t\t(match_operand:BI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmp.%C4.and.orcm %0, %I0 = %3, %2\"\n+  [(set_attr \"type\" \"A\")])\n+\n+(define_insn \"*cmpdi_and_1\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(and:BI (match_operator:BI 3 \"signed_inequality_operator\"\n+\t\t  [(match_operand:DI 2 \"gr_register_operand\" \"r\")\n+\t\t   (const_int 0)])\n+\t\t(match_operand:BI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmp.%C3.and.orcm %0, %I0 = r0, %2\"\n+  [(set_attr \"type\" \"A\")])\n+\n+(define_insn \"*cmpdi_andnot_0\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(and:BI (not:BI (match_operator:BI 4 \"predicate_operator\"\n+\t\t\t [(match_operand:DI 2 \"gr_register_operand\" \"r\")\n+\t\t\t  (match_operand:DI 3 \"gr_reg_or_8bit_operand\" \"rK\")]))\n+\t\t(match_operand:BI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmp.%C4.or.andcm %I0, %0 = %3, %2\"\n+  [(set_attr \"type\" \"A\")])\n+\n+(define_insn \"*cmpdi_andnot_1\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(and:BI (not:BI (match_operator:BI 3 \"signed_inequality_operator\"\n+\t\t\t  [(match_operand:DI 2 \"gr_register_operand\" \"r\")\n+\t\t\t   (const_int 0)]))\n+\t\t(match_operand:BI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmp.%C3.or.andcm %I0, %0 = r0, %2\"\n+  [(set_attr \"type\" \"A\")])\n+\n+(define_insn \"*tbit_and_0\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(and:BI (ne:BI (and:DI (match_operand:DI 1 \"gr_register_operand\" \"r\")\n+\t\t\t       (const_int 1))\n+\t\t       (const_int 0))\n+\t\t(match_operand:BI 3 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"tbit.nz.and.orcm %0, %I0 = %1, 0\"\n+  [(set_attr \"type\" \"I\")])\n+\n+(define_insn \"*tbit_and_1\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(and:BI (eq:BI (and:DI (match_operand:DI 1 \"gr_register_operand\" \"r\")\n+\t\t\t       (const_int 1))\n+\t\t       (const_int 0))\n+\t\t(match_operand:BI 3 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"tbit.z.and.orcm %0, %I0 = %1, 0\"\n+  [(set_attr \"type\" \"I\")])\n+\n+(define_insn \"*tbit_and_2\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(and:BI (ne:BI (zero_extract:DI\n+\t\t\t (match_operand:DI 1 \"gr_register_operand\" \"r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:DI 2 \"const_int_operand\" \"n\"))\n+\t\t       (const_int 0))\n+\t\t(match_operand:BI 3 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"tbit.nz.and.orcm %0, %I0 = %1, %2\"\n+  [(set_attr \"type\" \"I\")])\n+\n+(define_insn \"*tbit_and_3\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(and:BI (eq:BI (zero_extract:DI\n+\t\t\t (match_operand:DI 1 \"gr_register_operand\" \"r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:DI 2 \"const_int_operand\" \"n\"))\n+\t\t       (const_int 0))\n+\t\t(match_operand:BI 3 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"tbit.z.and.orcm %0, %I0 = %1, %2\"\n+  [(set_attr \"type\" \"I\")])\n+\n+(define_insn \"*cmpsi_or_0\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(ior:BI (match_operator:BI 4 \"predicate_operator\"\n+\t\t  [(match_operand:SI 2 \"gr_reg_or_0_operand\" \"rO\")\n+\t\t   (match_operand:SI 3 \"gr_reg_or_8bit_operand\" \"rK\")])\n+\t\t(match_operand:BI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmp4.%C4.or.andcm %0, %I0 = %3, %r2\"\n+  [(set_attr \"type\" \"A\")])\n+\n+(define_insn \"*cmpsi_or_1\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(ior:BI (match_operator:BI 3 \"signed_inequality_operator\"\n+\t\t  [(match_operand:SI 2 \"gr_register_operand\" \"r\")\n+\t\t   (const_int 0)])\n+\t\t(match_operand:BI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmp4.%C3.or.andcm %0, %I0 = r0, %2\"\n+  [(set_attr \"type\" \"A\")])\n+\n+(define_insn \"*cmpsi_orcm_0\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(ior:BI (not:BI (match_operator:BI 4 \"predicate_operator\"\n+\t\t\t [(match_operand:SI 2 \"gr_reg_or_0_operand\" \"rO\")\n+\t\t\t  (match_operand:SI 3 \"gr_reg_or_8bit_operand\" \"rK\")]))\n+\t\t(match_operand:BI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmp4.%C4.and.orcm %I0, %0 = %3, %r2\"\n+  [(set_attr \"type\" \"A\")])\n+\n+(define_insn \"*cmpsi_orcm_1\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(ior:BI (not:BI (match_operator:BI 3 \"signed_inequality_operator\"\n+\t\t\t  [(match_operand:SI 2 \"gr_register_operand\" \"r\")\n+\t\t\t   (const_int 0)]))\n+\t\t(match_operand:BI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmp4.%C3.and.orcm %I0, %0 = r0, %2\"\n+  [(set_attr \"type\" \"A\")])\n+\n+(define_insn \"*cmpdi_or_0\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(ior:BI (match_operator:BI 4 \"predicate_operator\"\n+\t\t  [(match_operand:DI 2 \"gr_register_operand\" \"r\")\n+\t\t   (match_operand:DI 3 \"gr_reg_or_8bit_operand\" \"rK\")])\n+\t\t(match_operand:BI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmp.%C4.or.andcm %0, %I0 = %3, %2\"\n+  [(set_attr \"type\" \"A\")])\n+\n+(define_insn \"*cmpdi_or_1\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(ior:BI (match_operator:BI 3 \"signed_inequality_operator\"\n+\t\t  [(match_operand:DI 2 \"gr_register_operand\" \"r\")\n+\t\t   (const_int 0)])\n+\t\t(match_operand:BI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmp.%C3.or.andcm %0, %I0 = r0, %2\"\n+  [(set_attr \"type\" \"A\")])\n+\n+(define_insn \"*cmpdi_orcm_0\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(ior:BI (not:BI (match_operator:BI 4 \"predicate_operator\"\n+\t\t\t [(match_operand:DI 2 \"gr_register_operand\" \"r\")\n+\t\t\t  (match_operand:DI 3 \"gr_reg_or_8bit_operand\" \"rK\")]))\n+\t\t(match_operand:BI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmp.%C4.and.orcm %I0, %0 = %3, %2\"\n+  [(set_attr \"type\" \"A\")])\n+\n+(define_insn \"*cmpdi_orcm_1\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(ior:BI (not:BI (match_operator:BI 3 \"signed_inequality_operator\"\n+\t\t\t  [(match_operand:DI 2 \"gr_register_operand\" \"r\")\n+\t\t\t   (const_int 0)]))\n+\t\t(match_operand:BI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmp.%C3.and.orcm %I0, %0 = r0, %2\"\n+  [(set_attr \"type\" \"A\")])\n+\n+(define_insn \"*tbit_or_0\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(ior:BI (ne:BI (and:DI (match_operand:DI 1 \"gr_register_operand\" \"r\")\n+\t\t\t       (const_int 1))\n+\t\t       (const_int 0))\n+\t\t(match_operand:BI 3 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"tbit.nz.or.andcm %0, %I0 = %1, 0\"\n+  [(set_attr \"type\" \"I\")])\n+\n+(define_insn \"*tbit_or_1\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(ior:BI (eq:BI (and:DI (match_operand:DI 1 \"gr_register_operand\" \"r\")\n+\t\t\t       (const_int 1))\n+\t\t       (const_int 0))\n+\t\t(match_operand:BI 3 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"tbit.z.or.andcm %0, %I0 = %1, 0\"\n+  [(set_attr \"type\" \"I\")])\n+\n+(define_insn \"*tbit_or_2\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(ior:BI (ne:BI (zero_extract:DI\n+\t\t\t (match_operand:DI 1 \"gr_register_operand\" \"r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:DI 2 \"const_int_operand\" \"n\"))\n+\t\t       (const_int 0))\n+\t\t(match_operand:BI 3 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"tbit.nz.or.andcm %0, %I0 = %1, %2\"\n+  [(set_attr \"type\" \"I\")])\n+\n+(define_insn \"*tbit_or_3\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(ior:BI (eq:BI (zero_extract:DI\n+\t\t\t (match_operand:DI 1 \"gr_register_operand\" \"r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:DI 2 \"const_int_operand\" \"n\"))\n+\t\t       (const_int 0))\n+\t\t(match_operand:BI 3 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"tbit.z.or.andcm %0, %I0 = %1, %2\"\n+  [(set_attr \"type\" \"I\")])\n+\n+;; Transform test of and/or of setcc into parallel comparisons.\n+\n+(define_split\n+  [(set (match_operand:BI 0 \"register_operand\" \"\")\n+\t(ne:BI (and:DI (ne:DI (match_operand:BI 2 \"register_operand\" \"\")\n+\t\t\t      (const_int 0))\n+\t\t       (match_operand:DI 3 \"register_operand\" \"\"))\n+\t       (const_int 0)))]\n+  \"\"\n+  [(set (match_dup 0)\n+\t(and:BI (ne:BI (and:DI (match_dup 3) (const_int 1)) (const_int 0))\n+\t\t(match_dup 2)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:BI 0 \"register_operand\" \"\")\n+\t(eq:BI (and:DI (ne:DI (match_operand:BI 2 \"register_operand\" \"\")\n+\t\t\t      (const_int 0))\n+\t\t       (match_operand:DI 3 \"register_operand\" \"\"))\n+\t       (const_int 0)))]\n+  \"\"\n+  [(set (match_dup 0)\n+\t(and:BI (ne:BI (and:DI (match_dup 3) (const_int 1)) (const_int 0))\n+\t\t(match_dup 2)))\n+   (parallel [(set (match_dup 0) (not:BI (match_dup 0)))\n+\t      (clobber (scratch))])]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:BI 0 \"register_operand\" \"\")\n+\t(ne:BI (ior:DI (ne:DI (match_operand:BI 2 \"register_operand\" \"\")\n+\t\t\t      (const_int 0))\n+\t\t       (match_operand:DI 3 \"register_operand\" \"\"))\n+\t       (const_int 0)))]\n+  \"\"\n+  [(set (match_dup 0) \n+\t(ior:BI (ne:BI (match_dup 3) (const_int 0))\n+\t\t(match_dup 2)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:BI 0 \"register_operand\" \"\")\n+\t(eq:BI (ior:DI (ne:DI (match_operand:BI 2 \"register_operand\" \"\")\n+\t\t\t      (const_int 0))\n+\t\t       (match_operand:DI 3 \"register_operand\" \"\"))\n+\t       (const_int 0)))]\n+  \"\"\n+  [(set (match_dup 0) \n+\t(ior:BI (ne:BI (match_dup 3) (const_int 0))\n+\t\t(match_dup 2)))\n+   (parallel [(set (match_dup 0) (not:BI (match_dup 0)))\n+\t      (clobber (scratch))])]\n+  \"\")\n+\n+;; ??? Incredibly hackish.  Either need four proper patterns with all\n+;; the alternatives, or rely on sched1 to split the insn and hope that\n+;; nothing bad happens to the comparisons in the meantime.\n+;;\n+;; Alternately, adjust combine to allow 2->2 and 3->3 splits, assuming\n+;; that we're doing height reduction.\n+;\n+;(define_insn_and_split \"\"\n+;  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+;\t(and:BI (and:BI (match_operator:BI 1 \"comparison_operator\"\n+;\t\t\t  [(match_operand 2 \"\" \"\")\n+;\t\t\t   (match_operand 3 \"\" \"\")])\n+;\t\t\t(match_operator:BI 4 \"comparison_operator\"\n+;\t\t\t  [(match_operand 5 \"\" \"\")\n+;\t\t\t   (match_operand 6 \"\" \"\")]))\n+;\t\t(match_dup 0)))]\n+;  \"flag_schedule_insns\"\n+;  \"#\"\n+;  \"\"\n+;  [(set (match_dup 0) (and:BI (match_dup 1) (match_dup 0)))\n+;   (set (match_dup 0) (and:BI (match_dup 4) (match_dup 0)))]\n+;  \"\")\n+;\n+;(define_insn_and_split \"\"\n+;  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+;\t(ior:BI (ior:BI (match_operator:BI 1 \"comparison_operator\"\n+;\t\t\t  [(match_operand 2 \"\" \"\")\n+;\t\t\t   (match_operand 3 \"\" \"\")])\n+;\t\t\t(match_operator:BI 4 \"comparison_operator\"\n+;\t\t\t  [(match_operand 5 \"\" \"\")\n+;\t\t\t   (match_operand 6 \"\" \"\")]))\n+;\t\t(match_dup 0)))]\n+;  \"flag_schedule_insns\"\n+;  \"#\"\n+;  \"\"\n+;  [(set (match_dup 0) (ior:BI (match_dup 1) (match_dup 0)))\n+;   (set (match_dup 0) (ior:BI (match_dup 4) (match_dup 0)))]\n+;  \"\")\n+;\n+;(define_split\n+;  [(set (match_operand:BI 0 \"register_operand\" \"\")\n+;\t(and:BI (and:BI (match_operator:BI 1 \"comparison_operator\"\n+;\t\t\t  [(match_operand 2 \"\" \"\")\n+;\t\t\t   (match_operand 3 \"\" \"\")])\n+;\t\t\t(match_operand:BI 7 \"register_operand\" \"\"))\n+;\t\t(and:BI (match_operator:BI 4 \"comparison_operator\"\n+;\t\t\t  [(match_operand 5 \"\" \"\")\n+;\t\t\t   (match_operand 6 \"\" \"\")])\n+;\t\t\t(match_operand:BI 8 \"register_operand\" \"\"))))]\n+;  \"\"\n+;  [(set (match_dup 0) (and:BI (match_dup 7) (match_dup 8)))\n+;   (set (match_dup 0) (and:BI (and:BI (match_dup 1) (match_dup 4))\n+;\t\t\t      (match_dup 0)))]\n+;  \"\")\n+;\n+;(define_split\n+;  [(set (match_operand:BI 0 \"register_operand\" \"\")\n+;\t(ior:BI (ior:BI (match_operator:BI 1 \"comparison_operator\"\n+;\t\t\t  [(match_operand 2 \"\" \"\")\n+;\t\t\t   (match_operand 3 \"\" \"\")])\n+;\t\t\t(match_operand:BI 7 \"register_operand\" \"\"))\n+;\t\t(ior:BI (match_operator:BI 4 \"comparison_operator\"\n+;\t\t\t  [(match_operand 5 \"\" \"\")\n+;\t\t\t   (match_operand 6 \"\" \"\")])\n+;\t\t\t(match_operand:BI 8 \"register_operand\" \"\"))))]\n+;  \"\"\n+;  [(set (match_dup 0) (ior:BI (match_dup 7) (match_dup 8)))\n+;   (set (match_dup 0) (ior:BI (ior:BI (match_dup 1) (match_dup 4))\n+;\t\t\t      (match_dup 0)))]\n+;  \"\")\n+\n+;; Try harder to avoid predicate copies by duplicating compares.\n+;; Note that we'll have already split the predicate copy, which\n+;; is kind of a pain, but oh well.\n+\n+(define_peephole2\n+  [(set (match_operand:BI 0 \"register_operand\" \"\")\n+\t(match_operand:BI 1 \"comparison_operator\" \"\"))\n+   (set (match_operand:CCI 2 \"register_operand\" \"\")\n+\t(match_operand:CCI 3 \"register_operand\" \"\"))\n+   (set (match_operand:CCI 4 \"register_operand\" \"\")\n+\t(match_operand:CCI 5 \"register_operand\" \"\"))\n+   (set (match_operand:BI 6 \"register_operand\" \"\")\n+\t(unspec:BI [(match_dup 6)] 7))]\n+  \"REGNO (operands[3]) == REGNO (operands[0])\n+   && REGNO (operands[4]) == REGNO (operands[0]) + 1\n+   && REGNO (operands[4]) == REGNO (operands[2]) + 1\n+   && REGNO (operands[6]) == REGNO (operands[2])\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 6) (match_dup 7))]\n+  \"operands[7] = copy_rtx (operands[1]);\")\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n ;; :: 16 bit Integer arithmetic\n ;; ::\n ;; ::::::::::::::::::::\n@@ -1435,7 +2004,7 @@\n \t(mult:SI (match_operand:SI 1 \"grfr_register_operand\" \"f\")\n \t\t (match_operand:SI 2 \"grfr_register_operand\" \"f\")))]\n   \"\"\n-  \"xma.l %0 = %1, %2, f0%B0\"\n+  \"xmpy.l %0 = %1, %2%B0\"\n   [(set_attr \"type\" \"F\")])\n \n (define_insn \"maddsi4\"\n@@ -1456,67 +2025,67 @@\n \n (define_expand \"abssi2\"\n   [(set (match_dup 2)\n-\t(ge:CC (match_operand:SI 1 \"gr_register_operand\" \"\") (const_int 0)))\n+\t(ge:BI (match_operand:SI 1 \"gr_register_operand\" \"\") (const_int 0)))\n    (set (match_operand:SI 0 \"gr_register_operand\" \"\")\n-\t(if_then_else:SI (eq:CC (match_dup 2) (const_int 0))\n+\t(if_then_else:SI (eq (match_dup 2) (const_int 0))\n \t\t\t (neg:SI (match_dup 1))\n \t\t\t (match_dup 1)))]\n   \"\"\n   \"\n {\n-  operands[2] = gen_reg_rtx (CCmode);\n+  operands[2] = gen_reg_rtx (BImode);\n }\")\n \n (define_expand \"sminsi3\"\n   [(set (match_dup 3)\n-\t(ge:CC (match_operand:SI 1 \"gr_register_operand\" \"\")\n+\t(ge:BI (match_operand:SI 1 \"gr_register_operand\" \"\")\n \t       (match_operand:SI 2 \"gr_register_operand\" \"\")))\n    (set (match_operand:SI 0 \"gr_register_operand\" \"\")\n-\t(if_then_else:SI (ne:CC (match_dup 3) (const_int 0))\n+\t(if_then_else:SI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 2) (match_dup 1)))]\n   \"\"\n   \"\n {\n-  operands[3] = gen_reg_rtx (CCmode);\n+  operands[3] = gen_reg_rtx (BImode);\n }\")\n \n (define_expand \"smaxsi3\"\n   [(set (match_dup 3)\n-\t(ge:CC (match_operand:SI 1 \"gr_register_operand\" \"\")\n+\t(ge:BI (match_operand:SI 1 \"gr_register_operand\" \"\")\n \t       (match_operand:SI 2 \"gr_register_operand\" \"\")))\n    (set (match_operand:SI 0 \"gr_register_operand\" \"\")\n-\t(if_then_else:SI (ne:CC (match_dup 3) (const_int 0))\n+\t(if_then_else:SI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"\n {\n-  operands[3] = gen_reg_rtx (CCmode);\n+  operands[3] = gen_reg_rtx (BImode);\n }\")\n \n (define_expand \"uminsi3\"\n   [(set (match_dup 3)\n-\t(geu:CC (match_operand:SI 1 \"gr_register_operand\" \"\")\n+\t(geu:BI (match_operand:SI 1 \"gr_register_operand\" \"\")\n \t\t(match_operand:SI 2 \"gr_register_operand\" \"\")))\n    (set (match_operand:SI 0 \"gr_register_operand\" \"\")\n-\t(if_then_else:SI (ne:CC (match_dup 3) (const_int 0))\n+\t(if_then_else:SI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 2) (match_dup 1)))]\n   \"\"\n   \"\n {\n-  operands[3] = gen_reg_rtx (CCmode);\n+  operands[3] = gen_reg_rtx (BImode);\n }\")\n \n (define_expand \"umaxsi3\"\n   [(set (match_dup 3)\n-\t(geu:CC (match_operand:SI 1 \"gr_register_operand\" \"\")\n+\t(geu:BI (match_operand:SI 1 \"gr_register_operand\" \"\")\n \t\t(match_operand:SI 2 \"gr_register_operand\" \"\")))\n    (set (match_operand:SI 0 \"gr_register_operand\" \"\")\n-\t(if_then_else:SI (ne:CC (match_dup 3) (const_int 0))\n+\t(if_then_else:SI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"\n {\n-  operands[3] = gen_reg_rtx (CCmode);\n+  operands[3] = gen_reg_rtx (BImode);\n }\")\n \n (define_expand \"divsi3\"\n@@ -1651,13 +2220,13 @@\n \t\t\t  (match_operand:TF 2 \"fr_register_operand\" \"f\"))))\n    (clobber (match_scratch:TF 4 \"=&f\"))\n    (clobber (match_scratch:TF 5 \"=&f\"))\n-   (clobber (match_scratch:CC 6 \"=c\"))\n+   (clobber (match_scratch:BI 6 \"=c\"))\n    (use (match_operand:TF 3 \"fr_register_operand\" \"f\"))]\n   \"TARGET_INLINE_DIV\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n-\t      (set (match_dup 6) (unspec:CC [(match_dup 1) (match_dup 2)] 5))\n+\t      (set (match_dup 6) (unspec:BI [(match_dup 1) (match_dup 2)] 5))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 4) (mult:TF (match_dup 1) (match_dup 0)))\n@@ -1747,7 +2316,7 @@\n \t(mult:DI (match_operand:DI 1 \"grfr_register_operand\" \"f\")\n \t\t (match_operand:DI 2 \"grfr_register_operand\" \"f\")))]\n   \"\"\n-  \"xma.l %0 = %1, %2, f0%B0\"\n+  \"xmpy.l %0 = %1, %2%B0\"\n   [(set_attr \"type\" \"F\")])\n \n ;; ??? If operand 3 is an eliminable reg, then register elimination causes the\n@@ -1823,7 +2392,7 @@\n \t\t     (match_operand:DI 2 \"fr_register_operand\" \"f\")))\n \t  (const_int 64))))]\n   \"\"\n-  \"xma.h %0 = %1, %2, f0%B0\"\n+  \"xmpy.h %0 = %1, %2%B0\"\n   [(set_attr \"type\" \"F\")])\n \n (define_insn \"umuldi3_highpart\"\n@@ -1836,7 +2405,7 @@\n \t\t     (match_operand:DI 2 \"fr_register_operand\" \"f\")))\n \t  (const_int 64))))]\n   \"\"\n-  \"xma.hu %0 = %1, %2, f0%B0\"\n+  \"xmpy.hu %0 = %1, %2%B0\"\n   [(set_attr \"type\" \"F\")])\n \n (define_insn \"negdi2\"\n@@ -1848,78 +2417,78 @@\n \n (define_expand \"absdi2\"\n   [(set (match_dup 2)\n-\t(ge:CC (match_operand:DI 1 \"gr_register_operand\" \"\") (const_int 0)))\n+\t(ge:BI (match_operand:DI 1 \"gr_register_operand\" \"\") (const_int 0)))\n    (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(if_then_else:DI (eq:CC (match_dup 2) (const_int 0))\n+\t(if_then_else:DI (eq (match_dup 2) (const_int 0))\n \t\t\t (neg:DI (match_dup 1))\n \t\t\t (match_dup 1)))]\n   \"\"\n   \"\n {\n-  operands[2] = gen_reg_rtx (CCmode);\n+  operands[2] = gen_reg_rtx (BImode);\n }\")\n \n (define_expand \"smindi3\"\n   [(set (match_dup 3)\n-\t(ge:CC (match_operand:DI 1 \"gr_register_operand\" \"\")\n+\t(ge:BI (match_operand:DI 1 \"gr_register_operand\" \"\")\n \t       (match_operand:DI 2 \"gr_register_operand\" \"\")))\n    (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(if_then_else:DI (ne:CC (match_dup 3) (const_int 0))\n+\t(if_then_else:DI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 2) (match_dup 1)))]\n   \"\"\n   \"\n {\n-  operands[3] = gen_reg_rtx (CCmode);\n+  operands[3] = gen_reg_rtx (BImode);\n }\")\n \n (define_expand \"smaxdi3\"\n   [(set (match_dup 3)\n-\t(ge:CC (match_operand:DI 1 \"gr_register_operand\" \"\")\n+\t(ge:BI (match_operand:DI 1 \"gr_register_operand\" \"\")\n \t       (match_operand:DI 2 \"gr_register_operand\" \"\")))\n    (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(if_then_else:DI (ne:CC (match_dup 3) (const_int 0))\n+\t(if_then_else:DI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"\n {\n-  operands[3] = gen_reg_rtx (CCmode);\n+  operands[3] = gen_reg_rtx (BImode);\n }\")\n \n (define_expand \"umindi3\"\n   [(set (match_dup 3)\n-\t(geu:CC (match_operand:DI 1 \"gr_register_operand\" \"\")\n+\t(geu:BI (match_operand:DI 1 \"gr_register_operand\" \"\")\n \t\t(match_operand:DI 2 \"gr_register_operand\" \"\")))\n    (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(if_then_else:DI (ne:CC (match_dup 3) (const_int 0))\n+\t(if_then_else:DI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 2) (match_dup 1)))]\n   \"\"\n   \"\n {\n-  operands[3] = gen_reg_rtx (CCmode);\n+  operands[3] = gen_reg_rtx (BImode);\n }\")\n \n (define_expand \"umaxdi3\"\n   [(set (match_dup 3)\n-\t(geu:CC (match_operand:DI 1 \"gr_register_operand\" \"\")\n+\t(geu:BI (match_operand:DI 1 \"gr_register_operand\" \"\")\n \t\t(match_operand:DI 2 \"gr_register_operand\" \"\")))\n    (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(if_then_else:DI (ne:CC (match_dup 3) (const_int 0))\n+\t(if_then_else:DI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"\n {\n-  operands[3] = gen_reg_rtx (CCmode);\n+  operands[3] = gen_reg_rtx (BImode);\n }\")\n \n (define_expand \"ffsdi2\"\n   [(set (match_dup 6)\n-\t(eq:CC (match_operand:DI 1 \"gr_register_operand\" \"\") (const_int 0)))\n+\t(eq:BI (match_operand:DI 1 \"gr_register_operand\" \"\") (const_int 0)))\n    (set (match_dup 2) (plus:DI (match_dup 1) (const_int -1)))\n    (set (match_dup 5) (const_int 0))\n    (set (match_dup 3) (xor:DI (match_dup 1) (match_dup 2)))\n    (set (match_dup 4) (unspec:DI [(match_dup 3)] 8))\n    (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(if_then_else:DI (ne:CC (match_dup 6) (const_int 0))\n+\t(if_then_else:DI (ne (match_dup 6) (const_int 0))\n \t\t\t (match_dup 5) (match_dup 4)))]\n   \"\"\n   \"\n@@ -1928,7 +2497,7 @@\n   operands[3] = gen_reg_rtx (DImode);\n   operands[4] = gen_reg_rtx (DImode);\n   operands[5] = gen_reg_rtx (DImode);\n-  operands[6] = gen_reg_rtx (CCmode);\n+  operands[6] = gen_reg_rtx (BImode);\n }\")\n \n (define_insn \"*popcnt\"\n@@ -2041,12 +2610,12 @@\n    (clobber (match_scratch:TF 3 \"=&f\"))\n    (clobber (match_scratch:TF 4 \"=&f\"))\n    (clobber (match_scratch:TF 5 \"=&f\"))\n-   (clobber (match_scratch:CC 6 \"=c\"))]\n+   (clobber (match_scratch:BI 6 \"=c\"))]\n   \"TARGET_INLINE_DIV_LAT\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n-\t      (set (match_dup 6) (unspec:CC [(match_dup 1) (match_dup 2)] 5))\n+\t      (set (match_dup 6) (unspec:BI [(match_dup 1) (match_dup 2)] 5))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 3)\n@@ -2099,12 +2668,12 @@\n \t\t\t  (match_operand:TF 2 \"fr_register_operand\" \"f\"))))\n    (clobber (match_scratch:TF 3 \"=&f\"))\n    (clobber (match_scratch:TF 4 \"=f\"))\n-   (clobber (match_scratch:CC 5 \"=c\"))]\n+   (clobber (match_scratch:BI 5 \"=c\"))]\n   \"TARGET_INLINE_DIV_THR\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n-\t      (set (match_dup 5) (unspec:CC [(match_dup 1) (match_dup 2)] 5))\n+\t      (set (match_dup 5) (unspec:BI [(match_dup 1) (match_dup 2)] 5))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3)\n@@ -2268,12 +2837,12 @@\n \t\t(match_operand:SF 2 \"fr_register_operand\" \"f\")))\n    (clobber (match_scratch:TF 3 \"=&f\"))\n    (clobber (match_scratch:TF 4 \"=f\"))\n-   (clobber (match_scratch:CC 5 \"=c\"))]\n+   (clobber (match_scratch:BI 5 \"=c\"))]\n   \"TARGET_INLINE_DIV_LAT\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 6) (div:TF (const_int 1) (match_dup 8)))\n-\t      (set (match_dup 5) (unspec:CC [(match_dup 7) (match_dup 8)] 5))\n+\t      (set (match_dup 5) (unspec:BI [(match_dup 7) (match_dup 8)] 5))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3) (mult:TF (match_dup 7) (match_dup 6)))\n@@ -2322,12 +2891,12 @@\n \t\t(match_operand:SF 2 \"fr_register_operand\" \"f\")))\n    (clobber (match_scratch:TF 3 \"=&f\"))\n    (clobber (match_scratch:TF 4 \"=f\"))\n-   (clobber (match_scratch:CC 5 \"=c\"))]\n+   (clobber (match_scratch:BI 5 \"=c\"))]\n   \"TARGET_INLINE_DIV_THR\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 6) (div:TF (const_int 1) (match_dup 8)))\n-\t      (set (match_dup 5) (unspec:CC [(match_dup 7) (match_dup 8)] 5))\n+\t      (set (match_dup 5) (unspec:BI [(match_dup 7) (match_dup 8)] 5))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3)\n@@ -2573,12 +3142,12 @@\n    (clobber (match_scratch:TF 3 \"=&f\"))\n    (clobber (match_scratch:TF 4 \"=&f\"))\n    (clobber (match_scratch:TF 5 \"=&f\"))\n-   (clobber (match_scratch:CC 6 \"=c\"))]\n+   (clobber (match_scratch:BI 6 \"=c\"))]\n   \"TARGET_INLINE_DIV_LAT\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 7) (div:TF (const_int 1) (match_dup 9)))\n-\t      (set (match_dup 6) (unspec:CC [(match_dup 8) (match_dup 9)] 5))\n+\t      (set (match_dup 6) (unspec:BI [(match_dup 8) (match_dup 9)] 5))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 3) (mult:TF (match_dup 8) (match_dup 7)))\n@@ -2650,12 +3219,12 @@\n \t\t(match_operand:DF 2 \"fr_register_operand\" \"f\")))\n    (clobber (match_scratch:TF 3 \"=&f\"))\n    (clobber (match_scratch:DF 4 \"=f\"))\n-   (clobber (match_scratch:CC 5 \"=c\"))]\n+   (clobber (match_scratch:BI 5 \"=c\"))]\n   \"TARGET_INLINE_DIV_THR\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 6) (div:TF (const_int 1) (match_dup 8)))\n-\t      (set (match_dup 5) (unspec:CC [(match_dup 7) (match_dup 8)] 5))\n+\t      (set (match_dup 5) (unspec:BI [(match_dup 7) (match_dup 8)] 5))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3)\n@@ -3046,12 +3615,12 @@\n    (clobber (match_scratch:TF 4 \"=&f\"))\n    (clobber (match_scratch:TF 5 \"=&f\"))\n    (clobber (match_scratch:TF 6 \"=&f\"))\n-   (clobber (match_scratch:CC 7 \"=c\"))]\n+   (clobber (match_scratch:BI 7 \"=c\"))]\n   \"TARGET_INLINE_DIV_LAT\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n-\t      (set (match_dup 7) (unspec:CC [(match_dup 1) (match_dup 2)] 5))\n+\t      (set (match_dup 7) (unspec:BI [(match_dup 1) (match_dup 2)] 5))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 7) (const_int 0))\n      (parallel [(set (match_dup 3)\n@@ -3123,12 +3692,12 @@\n \t\t(match_operand:TF 2 \"fr_register_operand\" \"f\")))\n    (clobber (match_scratch:TF 3 \"=&f\"))\n    (clobber (match_scratch:TF 4 \"=&f\"))\n-   (clobber (match_scratch:CC 5 \"=c\"))]\n+   (clobber (match_scratch:BI 5 \"=c\"))]\n   \"TARGET_INLINE_DIV_THR\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n-\t      (set (match_dup 5) (unspec:CC [(match_dup 1) (match_dup 2)] 5))\n+\t      (set (match_dup 5) (unspec:BI [(match_dup 1) (match_dup 2)] 5))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3)\n@@ -3200,8 +3769,8 @@\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(div:TF (const_int 1)\n \t\t(match_operand:TF 3 \"fr_register_operand\" \"f\")))\n-   (set (match_operand:CC 1 \"register_operand\" \"=c\")\n-\t(unspec:CC [(match_operand:TF 2 \"fr_register_operand\" \"f\")\n+   (set (match_operand:BI 1 \"register_operand\" \"=c\")\n+\t(unspec:BI [(match_operand:TF 2 \"fr_register_operand\" \"f\")\n \t\t    (match_dup 3)] 5))\n    (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n   \"\"\n@@ -3484,6 +4053,18 @@\n ;; ::\n ;; ::::::::::::::::::::\n \n+(define_expand \"cmpbi\"\n+  [(set (cc0)\n+        (compare (match_operand:BI 0 \"register_operand\" \"\")\n+  \t\t (match_operand:BI 1 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  ia64_compare_op0 = operands[0];\n+  ia64_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n (define_expand \"cmpsi\"\n   [(set (cc0)\n         (compare (match_operand:SI 0 \"gr_register_operand\" \"\")\n@@ -3545,62 +4126,62 @@\n }\")\n \n (define_insn \"*cmpsi_normal\"\n-  [(set (match_operand:CC 0 \"register_operand\" \"=c\")\n-\t(match_operator:CC 1 \"normal_comparison_operator\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(match_operator:BI 1 \"normal_comparison_operator\"\n \t   [(match_operand:SI 2 \"gr_register_operand\" \"r\")\n \t    (match_operand:SI 3 \"gr_reg_or_8bit_operand\" \"rK\")]))]\n   \"\"\n   \"cmp4.%C1 %0, %I0 = %3, %2\"\n   [(set_attr \"type\" \"A\")])\n \n (define_insn \"*cmpsi_adjusted\"\n-  [(set (match_operand:CC 0 \"register_operand\" \"=c\")\n-\t(match_operator:CC 1 \"adjusted_comparison_operator\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(match_operator:BI 1 \"adjusted_comparison_operator\"\n \t   [(match_operand:SI 2 \"gr_register_operand\" \"r\")\n \t    (match_operand:SI 3 \"gr_reg_or_8bit_adjusted_operand\" \"rL\")]))]\n   \"\"\n   \"cmp4.%C1 %0, %I0 = %3, %2\"\n   [(set_attr \"type\" \"A\")])\n \n (define_insn \"*cmpdi_normal\"\n-  [(set (match_operand:CC 0 \"register_operand\" \"=c\")\n-\t(match_operator:CC 1 \"normal_comparison_operator\"\n-\t   [(match_operand:DI 2 \"gr_register_operand\" \"r\")\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(match_operator:BI 1 \"normal_comparison_operator\"\n+\t   [(match_operand:DI 2 \"gr_reg_or_0_operand\" \"rO\")\n \t    (match_operand:DI 3 \"gr_reg_or_8bit_operand\" \"rK\")]))]\n   \"\"\n-  \"cmp.%C1 %0, %I0 = %3, %2\"\n+  \"cmp.%C1 %0, %I0 = %3, %r2\"\n   [(set_attr \"type\" \"A\")])\n \n (define_insn \"*cmpdi_adjusted\"\n-  [(set (match_operand:CC 0 \"register_operand\" \"=c\")\n-\t(match_operator:CC 1 \"adjusted_comparison_operator\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(match_operator:BI 1 \"adjusted_comparison_operator\"\n \t   [(match_operand:DI 2 \"gr_register_operand\" \"r\")\n \t    (match_operand:DI 3 \"gr_reg_or_8bit_adjusted_operand\" \"rL\")]))]\n   \"\"\n   \"cmp.%C1 %0, %I0 = %3, %2\"\n   [(set_attr \"type\" \"A\")])\n \n (define_insn \"*cmpsf_internal\"\n-  [(set (match_operand:CC 0 \"register_operand\" \"=c\")\n-\t(match_operator:CC 1 \"comparison_operator\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(match_operator:BI 1 \"comparison_operator\"\n \t   [(match_operand:SF 2 \"fr_reg_or_fp01_operand\" \"fG\")\n \t    (match_operand:SF 3 \"fr_reg_or_fp01_operand\" \"fG\")]))]\n   \"\"\n   \"fcmp.%D1 %0, %I0 = %F2, %F3\"\n   [(set_attr \"type\" \"F\")])\n \n (define_insn \"*cmpdf_internal\"\n-  [(set (match_operand:CC 0 \"register_operand\" \"=c\")\n-\t(match_operator:CC 1 \"comparison_operator\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(match_operator:BI 1 \"comparison_operator\"\n \t   [(match_operand:DF 2 \"fr_reg_or_fp01_operand\" \"fG\")\n \t    (match_operand:DF 3 \"fr_reg_or_fp01_operand\" \"fG\")]))]\n   \"\"\n   \"fcmp.%D1 %0, %I0 = %F2, %F3\"\n   [(set_attr \"type\" \"F\")])\n \n (define_insn \"*cmptf_internal\"\n-  [(set (match_operand:CC 0 \"register_operand\" \"=c\")\n-\t(match_operator:CC 1 \"comparison_operator\"\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(match_operator:BI 1 \"comparison_operator\"\n \t\t   [(match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t    (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\")]))]\n   \"\"\n@@ -3610,8 +4191,8 @@\n ;; ??? Can this pattern be generated?\n \n (define_insn \"*bit_zero\"\n-  [(set (match_operand:CC 0 \"register_operand\" \"=c\")\n-\t(eq:CC (zero_extract:DI (match_operand:DI 1 \"gr_register_operand\" \"r\")\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(eq:BI (zero_extract:DI (match_operand:DI 1 \"gr_register_operand\" \"r\")\n \t\t\t\t(const_int 1)\n \t\t\t\t(match_operand:DI 2 \"immediate_operand\" \"n\"))\n \t       (const_int 0)))]\n@@ -3620,65 +4201,14 @@\n   [(set_attr \"type\" \"I\")])\n \n (define_insn \"*bit_one\"\n-  [(set (match_operand:CC 0 \"register_operand\" \"=c\")\n-\t(ne:CC (zero_extract:DI (match_operand:DI 1 \"gr_register_operand\" \"r\")\n+  [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n+\t(ne:BI (zero_extract:DI (match_operand:DI 1 \"gr_register_operand\" \"r\")\n \t\t\t\t(const_int 1)\n \t\t\t\t(match_operand:DI 2 \"immediate_operand\" \"n\"))\n \t       (const_int 0)))]\n   \"\"\n   \"tbit.nz %0, %I0 = %1, %2\"\n   [(set_attr \"type\" \"I\")])\n-\n-;; ??? We also need this if we run out of PR regs and need to spill some.\n-\n-;; ??? We need this if a CCmode value does not get allocated to a hard\n-;; register.  This happens if we cse/gcse a CCmode value across a call, and the\n-;; function has a nonlocal goto.  This is because global does not allocate\n-;; call crossing pseudos to hard registers when current_function_has_\n-;; nonlocal_goto is true.  This is relatively common for C++ programs that\n-;; use exceptions.  See ia64_secondary_reload_class.\n-\n-;; We use a define_expand here so that cse/gcse/combine can't accidentally\n-;; create movcc insns.  If this was a named define_insn, we would not be able\n-;; to make it conditional on reload.\n-\n-(define_expand \"movcc\"\n-  [(set (match_operand:CC 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:CC 1 \"move_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (! reload_in_progress && ! reload_completed)\n-    FAIL;\n-}\")\n-\n-(define_insn \"*movcc_internal\"\n-  [(set (match_operand:CC 0 \"nonimmediate_operand\" \"=r,c,r,m\")\n-\t(match_operand:CC 1 \"move_operand\" \"c,r,m,r\"))]\n-  \"reload_in_progress || reload_completed\"\n-  \"@\n-   #\n-   cmp4.ne %0, %I0 = %1, r0\n-   ld4%O1 %0 = %1%P1\n-   st4%Q0 %0 = %1%P0\"\n-  [(set_attr \"type\" \"unknown,A,M,M\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"register_operand\" \"\")\n-\t(match_operand:CC 1 \"register_operand\" \"\"))]\n-  \"reload_completed\n-   && GET_CODE (operands[0]) == REG && GR_REGNO_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == REG && PR_REGNO_P (REGNO (operands[1]))\"\n-  [(set (match_dup 2)\n-\t(if_then_else:DI (ne:CC (match_dup 1) (const_int 0))\n-\t\t\t (const_int 1)\n-\t\t\t (match_dup 2)))\n-   (set (match_dup 2)\n-\t(if_then_else:DI (ne:CC (match_dup 1) (const_int 0))\n-\t\t\t (match_dup 2)\n-\t\t\t (const_int 0)))]\n-  \"operands[2] = gen_rtx_SUBREG (DImode, operands[0], 0);\")\n-\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -3687,213 +4217,105 @@\n ;; ::::::::::::::::::::\n \n (define_expand \"beq\"\n-  [(set (match_dup 1)\n-\t(eq:CC (match_dup 2)\n-\t       (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (ne:CC (match_dup 1)\n-\t\t\t     (const_int 0))\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (EQ, VOIDmode);\")\n \n (define_expand \"bne\"\n-  [(set (match_dup 1)\n-\t(ne:CC (match_dup 2)\n-\t       (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (ne:CC (match_dup 1)\n-\t\t\t     (const_int 0))\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (NE, VOIDmode);\")\n \n (define_expand \"blt\"\n-  [(set (match_dup 1)\n-\t(lt:CC (match_dup 2)\n-\t       (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (ne:CC (match_dup 1)\n-\t\t\t     (const_int 0))\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (LT, VOIDmode);\")\n \n (define_expand \"ble\"\n-  [(set (match_dup 1)\n-\t(le:CC (match_dup 2)\n-\t       (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (ne:CC (match_dup 1)\n-\t\t\t     (const_int 0))\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (LE, VOIDmode);\")\n \n (define_expand \"bgt\"\n-  [(set (match_dup 1)\n-\t(gt:CC (match_dup 2)\n-\t       (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (ne:CC (match_dup 1)\n-\t\t\t     (const_int 0))\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (GT, VOIDmode);\")\n \n (define_expand \"bge\"\n-  [(set (match_dup 1)\n-\t(ge:CC (match_dup 2)\n-\t       (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (ne:CC (match_dup 1)\n-\t\t\t     (const_int 0))\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (GE, VOIDmode);\")\n \n (define_expand \"bltu\"\n-  [(set (match_dup 1)\n-\t(ltu:CC (match_dup 2)\n-\t\t(match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (ne:CC (match_dup 1)\n-\t\t\t     (const_int 0))\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (LTU, VOIDmode);\")\n \n (define_expand \"bleu\"\n-  [(set (match_dup 1)\n-\t(leu:CC (match_dup 2)\n-\t\t(match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (ne:CC (match_dup 1)\n-\t\t\t     (const_int 0))\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (LEU, VOIDmode);\")\n \n (define_expand \"bgtu\"\n-  [(set (match_dup 1)\n-\t(gtu:CC (match_dup 2)\n-\t\t(match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (ne:CC (match_dup 1)\n-\t\t\t     (const_int 0))\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (GTU, VOIDmode);\")\n \n (define_expand \"bgeu\"\n-  [(set (match_dup 1)\n-\t(geu:CC (match_dup 2)\n-\t\t(match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (ne:CC (match_dup 1)\n-\t\t\t     (const_int 0))\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (GEU, VOIDmode);\")\n \n (define_expand \"bunordered\"\n-  [(set (match_dup 1)\n-\t(unordered:CC (match_dup 2)\n-\t\t      (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (ne:CC (match_dup 1)\n-\t\t\t     (const_int 0))\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (UNORDERED, VOIDmode);\")\n \n (define_expand \"bordered\"\n-  [(set (match_dup 1)\n-\t(ordered:CC (match_dup 2)\n-\t\t      (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (ne:CC (match_dup 1)\n-\t\t\t     (const_int 0))\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (ORDERED, VOIDmode);\")\n \n (define_insn \"*br_true\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"predicate_operator\"\n-\t\t\t[(match_operand:CC 1 \"register_operand\" \"c\")\n+\t\t\t[(match_operand:BI 1 \"register_operand\" \"c\")\n \t\t\t (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n@@ -3905,7 +4327,7 @@\n (define_insn \"*br_false\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"predicate_operator\"\n-\t\t\t[(match_operand:CC 1 \"register_operand\" \"c\")\n+\t\t\t[(match_operand:BI 1 \"register_operand\" \"c\")\n \t\t\t (const_int 0)])\n \t\t      (pc)\n \t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n@@ -3957,214 +4379,95 @@\n ;; ::::::::::::::::::::\n \n (define_expand \"seq\"\n-  [(set (match_dup 1)\n-\t(eq:CC (match_dup 2)\n-\t       (match_dup 3)))\n-   (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(ne:DI (match_dup 1) (const_int 0)))]\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (EQ, DImode);\")\n \n (define_expand \"sne\"\n-  [(set (match_dup 1)\n-\t(ne:CC (match_dup 2)\n-\t       (match_dup 3)))\n-   (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(ne:DI (match_dup 1) (const_int 0)))]\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (NE, DImode);\")\n \n (define_expand \"slt\"\n-  [(set (match_dup 1)\n-\t(lt:CC (match_dup 2)\n-\t       (match_dup 3)))\n-   (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(ne:DI (match_dup 1) (const_int 0)))]\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (LT, DImode);\")\n \n (define_expand \"sle\"\n-  [(set (match_dup 1)\n-\t(le:CC (match_dup 2)\n-\t       (match_dup 3)))\n-   (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(ne:DI (match_dup 1) (const_int 0)))]\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (LE, DImode);\")\n \n (define_expand \"sgt\"\n-  [(set (match_dup 1)\n-\t(gt:CC (match_dup 2)\n-\t       (match_dup 3)))\n-   (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(ne:DI (match_dup 1) (const_int 0)))]\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (GT, DImode);\")\n \n (define_expand \"sge\"\n-  [(set (match_dup 1)\n-\t(ge:CC (match_dup 2)\n-\t       (match_dup 3)))\n-   (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(ne:DI (match_dup 1) (const_int 0)))]\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (GE, DImode);\")\n \n (define_expand \"sltu\"\n-  [(set (match_dup 1)\n-\t(ltu:CC (match_dup 2)\n-\t\t(match_dup 3)))\n-   (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(ne:DI (match_dup 1) (const_int 0)))]\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (LTU, DImode);\")\n \n (define_expand \"sleu\"\n-  [(set (match_dup 1)\n-\t(leu:CC (match_dup 2)\n-\t\t(match_dup 3)))\n-   (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(ne:DI (match_dup 1) (const_int 0)))]\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (LEU, DImode);\")\n \n (define_expand \"sgtu\"\n-  [(set (match_dup 1)\n-\t(gtu:CC (match_dup 2)\n-\t\t(match_dup 3)))\n-   (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(ne:DI (match_dup 1) (const_int 0)))]\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (GTU, DImode);\")\n \n (define_expand \"sgeu\"\n-  [(set (match_dup 1)\n-\t(geu:CC (match_dup 2)\n-\t\t(match_dup 3)))\n-   (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(ne:DI (match_dup 1) (const_int 0)))]\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (GEU, DImode);\")\n \n (define_expand \"sunordered\"\n-  [(set (match_dup 1)\n-\t(unordered:CC (match_dup 2)\n-\t\t      (match_dup 3)))\n-   (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(ne:DI (match_dup 1) (const_int 0)))]\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (UNORDERED, DImode);\")\n \n (define_expand \"sordered\"\n-  [(set (match_dup 1)\n-\t(ordered:CC (match_dup 2)\n-\t\t      (match_dup 3)))\n-   (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n-\t(ne:DI (match_dup 1) (const_int 0)))]\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (CCmode);\n-  operands[2] = ia64_compare_op0;\n-  operands[3] = ia64_compare_op1;\n-}\")\n+  \"operands[1] = ia64_expand_compare (ORDERED, DImode);\")\n \n ;; Don't allow memory as destination here, because cmov/cmov/st is more\n ;; efficient than mov/mov/cst/cst.\n \n (define_insn_and_split \"*sne_internal\"\n   [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n-\t(ne:DI (match_operand:CC 1 \"register_operand\" \"c\")\n+\t(ne:DI (match_operand:BI 1 \"register_operand\" \"c\")\n \t       (const_int 0)))]\n   \"\"\n   \"#\"\n   \"reload_completed\"\n-  [(set (match_dup 0)\n-\t(if_then_else:DI (ne:CC (match_dup 1) (const_int 0))\n-\t\t\t (const_int 1)\n-\t\t\t (match_dup 0)))\n-   (set (match_dup 0)\n-\t(if_then_else:DI (ne:CC (match_dup 1) (const_int 0))\n-\t\t\t (match_dup 0)\n-\t\t\t (const_int 0)))]\n+  [(cond_exec (ne (match_dup 1) (const_int 0))\n+     (set (match_dup 0) (const_int 1)))\n+   (cond_exec (eq (match_dup 1) (const_int 0))\n+     (set (match_dup 0) (const_int 0)))]\n   \"\"\n   [(set_attr \"type\" \"unknown\")])\n \n-;; ??? Unknown if this can be matched.\n-\n (define_insn_and_split \"*seq_internal\"\n   [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n-\t(eq:DI (match_operand:CC 1 \"register_operand\" \"c\")\n+\t(eq:DI (match_operand:BI 1 \"register_operand\" \"c\")\n \t       (const_int 0)))]\n   \"\"\n   \"#\"\n   \"reload_completed\"\n-  [(set (match_dup 0)\n-\t(if_then_else:DI (eq:CC (match_dup 1) (const_int 0))\n-\t\t\t (const_int 1)\n-\t\t\t (match_dup 0)))\n-   (set (match_dup 0)\n-\t(if_then_else:DI (eq:CC (match_dup 1) (const_int 0))\n-\t\t\t (match_dup 0)\n-\t\t\t (const_int 0)))]\n+  [(cond_exec (ne (match_dup 1) (const_int 0))\n+     (set (match_dup 0) (const_int 0)))\n+   (cond_exec (eq (match_dup 1) (const_int 0))\n+     (set (match_dup 0) (const_int 1)))]\n   \"\"\n   [(set_attr \"type\" \"unknown\")])\n-\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -4180,45 +4483,49 @@\n \n ;; Errata 72 workaround.\n (define_insn \"*cmovdi_internal_astep\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-\t\t\"=r,*f,Q,*b,r,*f,Q,*b,r,*f,Q,*b\")\n+  [(set (match_operand:DI 0 \"register_operand\"\n+\t\t\"=r,*f,*b,r,*f,*b,r,*f,*b\")\n \t(if_then_else:DI\n-\t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\"\n-\t\t\t       \"c,c,c,c,c,c,c,c,c,c,c,c\")\n+\t  (match_operator 4 \"predicate_operator\"\n+\t    [(match_operand:BI 1 \"register_operand\"\n+\t\t\t       \"c,c,c,c,c,c,c,c,c\")\n \t     (const_int 0)])\n-\t  (match_operand:DI 2 \"general_operand\"\n-\t\t\"0,0,0,0,ri*f*b,rO,*f,r,ri*f*b,rO,*f,r\")\n-\t  (match_operand:DI 3 \"general_operand\"\n-\t\t\"ri*f*b,rO,*f,r,0,0,0,0,ri*f*b,rO,*f,r\")))]\n-  \"TARGET_A_STEP\"\n+\t  (match_operand:DI 2 \"move_operand\"\n+\t\t\"0,0,0,ri*f*b,rO,r,ri*f*b,rO,r\")\n+\t  (match_operand:DI 3 \"move_operand\"\n+\t\t\"ri*f*b,rO,r,0,0,0,ri*f*b,rO,r\")))]\n+  \"TARGET_A_STEP\n+   && ia64_move_ok (operands[0], operands[2])\n+   && ia64_move_ok (operands[0], operands[3])\"\n   \"* abort ();\"\n   [(set_attr \"predicable\" \"no\")])\n \n (define_insn \"*cmovdi_internal\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\"\n+  [(set (match_operand:DI 0 \"destination_operand\"\n \t\t\"=r,m,*f,Q,*b,*d*e,r,m,*f,Q,*b,*d*e,r,m,*f,Q,*b,*d*e\")\n \t(if_then_else:DI\n-\t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\"\n+\t  (match_operator 4 \"predicate_operator\"\n+\t    [(match_operand:BI 1 \"register_operand\"\n \t\t\t       \"c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c\")\n \t     (const_int 0)])\n-\t  (match_operand:DI 2 \"general_operand\"\n+\t  (match_operand:DI 2 \"move_operand\"\n \t\t\"0,0,0,0,0,0,rim*f*b*d*e,rO,rOQ,*f,rO,rK,rim*f*b*d*e,rO,rOQ,*f,rO,rK\")\n-\t  (match_operand:DI 3 \"general_operand\"\n+\t  (match_operand:DI 3 \"move_operand\"\n \t\t\"rim*f*b*d*e,rO,rOQ,*f,rO,rK,0,0,0,0,0,0,rim*f*b*d*e,rO,rOQ,*f,rO,rK\")))]\n-  \"! TARGET_A_STEP\"\n+  \"! TARGET_A_STEP\n+   && ia64_move_ok (operands[0], operands[2])\n+   && ia64_move_ok (operands[0], operands[3])\"\n   \"* abort ();\"\n   [(set_attr \"predicable\" \"no\")])\n \n (define_split\n-  [(set (match_operand 0 \"nonimmediate_operand\" \"\")\n+  [(set (match_operand 0 \"destination_operand\" \"\")\n \t(if_then_else\n-\t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\" \"\")\n+\t  (match_operator 4 \"predicate_operator\"\n+\t    [(match_operand:BI 1 \"register_operand\" \"\")\n \t     (const_int 0)])\n-\t  (match_operand 2 \"general_operand\" \"\")\n-\t  (match_operand 3 \"general_operand\" \"\")))]\n+\t  (match_operand 2 \"move_operand\" \"\")\n+\t  (match_operand 3 \"move_operand\" \"\")))]\n   \"reload_completed\"\n   [(const_int 0)]\n   \"\n@@ -4233,7 +4540,7 @@\n   if (! rtx_equal_p (operands[0], operands[3]))\n     {\n       tmp = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n-\t\t\t    CCmode, operands[1], const0_rtx);\n+\t\t\t    VOIDmode, operands[1], const0_rtx);\n       tmp = gen_rtx_COND_EXEC (VOIDmode, tmp,\n \t\t\t       gen_rtx_SET (VOIDmode, operands[0],\n \t\t\t\t\t    operands[3]));\n@@ -4247,8 +4554,8 @@\n (define_insn \"*absdi2_internal\"\n   [(set (match_operand:DI 0 \"gr_register_operand\" \"=r,r\")\n \t(if_then_else:DI\n-\t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\" \"c,c\")\n+\t  (match_operator 4 \"predicate_operator\"\n+\t    [(match_operand:BI 1 \"register_operand\" \"c,c\")\n \t     (const_int 0)])\n \t  (neg:DI (match_operand:DI 2 \"gr_reg_or_22bit_operand\" \"rI,rI\"))\n \t  (match_operand:DI 3 \"gr_reg_or_22bit_operand\" \"0,rI\")))]\n@@ -4260,8 +4567,8 @@\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(if_then_else:DI\n-\t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\" \"c,c\")\n+\t  (match_operator 4 \"predicate_operator\"\n+\t    [(match_operand:BI 1 \"register_operand\" \"c,c\")\n \t     (const_int 0)])\n \t  (neg:DI (match_operand:DI 2 \"gr_reg_or_22bit_operand\" \"\"))\n \t  (match_operand:DI 3 \"gr_reg_or_22bit_operand\" \"\")))]\n@@ -4275,8 +4582,8 @@\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(if_then_else:DI\n-\t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\" \"c,c\")\n+\t  (match_operator 4 \"predicate_operator\"\n+\t    [(match_operand:BI 1 \"register_operand\" \"c,c\")\n \t     (const_int 0)])\n \t  (neg:DI (match_operand:DI 2 \"gr_reg_or_22bit_operand\" \"\"))\n \t  (match_operand:DI 3 \"gr_reg_or_22bit_operand\" \"\")))]\n@@ -4290,46 +4597,48 @@\n   \"\n {\n   operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n-\t\t\t\tCCmode, operands[1], const0_rtx);\n+\t\t\t\tVOIDmode, operands[1], const0_rtx);\n }\")\n \n ;;\n ;; SImode if_then_else patterns.\n ;;\n \n (define_insn \"*cmovsi_internal_astep\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,*f,r,*f,r,*f\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,*f,r,*f,r,*f\")\n \t(if_then_else:SI\n-\t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\" \"c,c,c,c,c,c\")\n+\t  (match_operator 4 \"predicate_operator\"\n+\t    [(match_operand:BI 1 \"register_operand\" \"c,c,c,c,c,c\")\n \t     (const_int 0)])\n-\t  (match_operand:SI 2 \"general_operand\"\n-\t\t    \"0,0,ri*f,rO,ri*f,rO\")\n-\t  (match_operand:SI 3 \"general_operand\"\n-\t\t    \"ri*f,rO,0,0,ri*f,rO\")))]\n-  \"TARGET_A_STEP\"\n+\t  (match_operand:SI 2 \"move_operand\" \"0,0,ri*f,rO,ri*f,rO\")\n+\t  (match_operand:SI 3 \"move_operand\" \"ri*f,rO,0,0,ri*f,rO\")))]\n+  \"TARGET_A_STEP\n+   && ia64_move_ok (operands[0], operands[2])\n+   && ia64_move_ok (operands[0], operands[3])\"\n   \"* abort ();\"\n   [(set_attr \"predicable\" \"no\")])\n \n (define_insn \"*cmovsi_internal\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,m,*f,r,m,*f,r,m,*f\")\n+  [(set (match_operand:SI 0 \"destination_operand\" \"=r,m,*f,r,m,*f,r,m,*f\")\n \t(if_then_else:SI\n-\t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\" \"c,c,c,c,c,c,c,c,c\")\n+\t  (match_operator 4 \"predicate_operator\"\n+\t    [(match_operand:BI 1 \"register_operand\" \"c,c,c,c,c,c,c,c,c\")\n \t     (const_int 0)])\n-\t  (match_operand:SI 2 \"general_operand\"\n+\t  (match_operand:SI 2 \"move_operand\"\n \t\t    \"0,0,0,rim*f,rO,rO,rim*f,rO,rO\")\n-\t  (match_operand:SI 3 \"general_operand\"\n+\t  (match_operand:SI 3 \"move_operand\"\n \t\t    \"rim*f,rO,rO,0,0,0,rim*f,rO,rO\")))]\n-  \"! TARGET_A_STEP\"\n+  \"! TARGET_A_STEP\n+   && ia64_move_ok (operands[0], operands[2])\n+   && ia64_move_ok (operands[0], operands[3])\"\n   \"* abort ();\"\n   [(set_attr \"predicable\" \"no\")])\n \n (define_insn \"*abssi2_internal\"\n   [(set (match_operand:SI 0 \"gr_register_operand\" \"=r,r\")\n \t(if_then_else:SI\n-\t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\" \"c,c\")\n+\t  (match_operator 4 \"predicate_operator\"\n+\t    [(match_operand:BI 1 \"register_operand\" \"c,c\")\n \t     (const_int 0)])\n \t  (neg:SI (match_operand:SI 3 \"gr_reg_or_22bit_operand\" \"rI,rI\"))\n \t  (match_operand:SI 2 \"gr_reg_or_22bit_operand\" \"0,rI\")))]\n@@ -4341,8 +4650,8 @@\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(if_then_else:SI\n-\t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\" \"c,c\")\n+\t  (match_operator 4 \"predicate_operator\"\n+\t    [(match_operand:BI 1 \"register_operand\" \"c,c\")\n \t     (const_int 0)])\n \t  (neg:SI (match_operand:SI 2 \"gr_reg_or_22bit_operand\" \"\"))\n \t  (match_operand:SI 3 \"gr_reg_or_22bit_operand\" \"\")))]\n@@ -4356,8 +4665,8 @@\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(if_then_else:SI\n-\t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\" \"c,c\")\n+\t  (match_operator 4 \"predicate_operator\"\n+\t    [(match_operand:BI 1 \"register_operand\" \"c,c\")\n \t     (const_int 0)])\n \t  (neg:SI (match_operand:SI 2 \"gr_reg_or_22bit_operand\" \"\"))\n \t  (match_operand:SI 3 \"gr_reg_or_22bit_operand\" \"\")))]\n@@ -4371,7 +4680,7 @@\n   \"\n {\n   operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n-\t\t\t\tCCmode, operands[1], const0_rtx);\n+\t\t\t\tVOIDmode, operands[1], const0_rtx);\n }\")\n \n \f\n@@ -4712,7 +5021,7 @@\n (define_insn \"*return_true\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"predicate_operator\"\n-\t\t\t[(match_operand:CC 1 \"register_operand\" \"c\")\n+\t\t\t[(match_operand:BI 1 \"register_operand\" \"c\")\n \t\t\t (const_int 0)])\n \t\t      (return)\n \t\t      (pc)))]\n@@ -4724,7 +5033,7 @@\n (define_insn \"*return_false\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"predicate_operator\"\n-\t\t\t[(match_operand:CC 1 \"register_operand\" \"c\")\n+\t\t\t[(match_operand:BI 1 \"register_operand\" \"c\")\n \t\t\t (const_int 0)])\n \t\t      (pc)\n \t\t      (return)))]\n@@ -5122,13 +5431,14 @@\n \n (define_cond_exec\n   [(match_operator 0 \"predicate_operator\"\n-     [(match_operand:CC 1 \"register_operand\" \"c\")\n+     [(match_operand:BI 1 \"register_operand\" \"c\")\n       (const_int 0)])]\n   \"\"\n   \"(%J0)\")\n \n (define_insn \"pred_rel_mutex\"\n-  [(unspec_volatile [(match_operand:CC 0 \"register_operand\" \"c\")] 7)]\n+  [(set (match_operand:BI 0 \"register_operand\" \"+c\")\n+       (unspec:BI [(match_dup 0)] 7))]\n   \"\"\n   \".pred.rel.mutex %0, %I0\"\n   [(set_attr \"type\" \"unknown\")"}]}