{"sha": "90c254565122fa5c02114698ce35ac46679c03b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBjMjU0NTY1MTIyZmE1YzAyMTE0Njk4Y2UzNWFjNDY2NzljMDNiMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-09-17T00:03:52Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-09-17T00:04:43Z"}, "message": "libbacktrace: use ELF symbol table if no debug info available\n\n\tPR libbacktrace/97080\n\t* fileline.c (backtrace_syminfo_to_full_callback): New function.\n\t(backtrace_syminfo_to_full_error_callback): New function.\n\t* elf.c (elf_nodebug): Call syminfo_fn if possible.\n\t* internal.h (struct backtrace_call_full): Define.\n\t(backtrace_syminfo_to_full_callback): Declare.\n\t(backtrace_syminfo_to_full_error_callback): Declare.\n\t* mtest.c (f3): Only check all[i] if data.index permits.", "tree": {"sha": "c893c6c0c0e87f702441fd7d31f57e522083aa22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c893c6c0c0e87f702441fd7d31f57e522083aa22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90c254565122fa5c02114698ce35ac46679c03b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90c254565122fa5c02114698ce35ac46679c03b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90c254565122fa5c02114698ce35ac46679c03b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90c254565122fa5c02114698ce35ac46679c03b0/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd111c419d146ee47c7df9a36a535e8d843d4802", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd111c419d146ee47c7df9a36a535e8d843d4802", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd111c419d146ee47c7df9a36a535e8d843d4802"}], "stats": {"total": 154, "additions": 115, "deletions": 39}, "files": [{"sha": "941f820d944c76ec349a597ce32bf7fa7acb4693", "filename": "libbacktrace/elf.c", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90c254565122fa5c02114698ce35ac46679c03b0/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90c254565122fa5c02114698ce35ac46679c03b0/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=90c254565122fa5c02114698ce35ac46679c03b0", "patch": "@@ -547,18 +547,6 @@ elf_crc32_file (struct backtrace_state *state, int descriptor,\n   return ret;\n }\n \n-/* A dummy callback function used when we can't find any debug info.  */\n-\n-static int\n-elf_nodebug (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t     uintptr_t pc ATTRIBUTE_UNUSED,\n-\t     backtrace_full_callback callback ATTRIBUTE_UNUSED,\n-\t     backtrace_error_callback error_callback, void *data)\n-{\n-  error_callback (data, \"no debug info in ELF executable\", -1);\n-  return 0;\n-}\n-\n /* A dummy callback function used when we can't find a symbol\n    table.  */\n \n@@ -571,6 +559,33 @@ elf_nosyms (struct backtrace_state *state ATTRIBUTE_UNUSED,\n   error_callback (data, \"no symbol table in ELF executable\", -1);\n }\n \n+/* A callback function used when we can't find any debug info.  */\n+\n+static int\n+elf_nodebug (struct backtrace_state *state, uintptr_t pc,\n+\t     backtrace_full_callback callback,\n+\t     backtrace_error_callback error_callback, void *data)\n+{\n+  if (state->syminfo_fn != NULL && state->syminfo_fn != elf_nosyms)\n+    {\n+      struct backtrace_call_full bdata;\n+\n+      /* Fetch symbol information so that we can least get the\n+\t function name.  */\n+\n+      bdata.full_callback = callback;\n+      bdata.full_error_callback = error_callback;\n+      bdata.full_data = data;\n+      bdata.ret = 0;\n+      state->syminfo_fn (state, pc, backtrace_syminfo_to_full_callback,\n+\t\t\t backtrace_syminfo_to_full_error_callback, &bdata);\n+      return bdata.ret;\n+    }\n+\n+  error_callback (data, \"no debug info in ELF executable\", -1);\n+  return 0;\n+}\n+\n /* Compare struct elf_symbol for qsort.  */\n \n static int"}, {"sha": "cd1e10dd58cca26c0b2a1dc4b7e3986559e1a8df", "filename": "libbacktrace/fileline.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90c254565122fa5c02114698ce35ac46679c03b0/libbacktrace%2Ffileline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90c254565122fa5c02114698ce35ac46679c03b0/libbacktrace%2Ffileline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Ffileline.c?ref=90c254565122fa5c02114698ce35ac46679c03b0", "patch": "@@ -317,3 +317,30 @@ backtrace_syminfo (struct backtrace_state *state, uintptr_t pc,\n   state->syminfo_fn (state, pc, callback, error_callback, data);\n   return 1;\n }\n+\n+/* A backtrace_syminfo_callback that can call into a\n+   backtrace_full_callback, used when we have a symbol table but no\n+   debug info.  */\n+\n+void\n+backtrace_syminfo_to_full_callback (void *data, uintptr_t pc,\n+\t\t\t\t    const char *symname,\n+\t\t\t\t    uintptr_t symval ATTRIBUTE_UNUSED,\n+\t\t\t\t    uintptr_t symsize ATTRIBUTE_UNUSED)\n+{\n+  struct backtrace_call_full *bdata = (struct backtrace_call_full *) data;\n+\n+  bdata->ret = bdata->full_callback (bdata->full_data, pc, NULL, 0, symname);\n+}\n+\n+/* An error callback that corresponds to\n+   backtrace_syminfo_to_full_callback.  */\n+\n+void\n+backtrace_syminfo_to_full_error_callback (void *data, const char *msg,\n+\t\t\t\t\t  int errnum)\n+{\n+  struct backtrace_call_full *bdata = (struct backtrace_call_full *) data;\n+\n+  bdata->full_error_callback (bdata->full_data, msg, errnum);\n+}"}, {"sha": "047a700c0ce469ad241d321864a80b95e5793769", "filename": "libbacktrace/internal.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90c254565122fa5c02114698ce35ac46679c03b0/libbacktrace%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90c254565122fa5c02114698ce35ac46679c03b0/libbacktrace%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Finternal.h?ref=90c254565122fa5c02114698ce35ac46679c03b0", "patch": "@@ -326,6 +326,31 @@ extern int backtrace_dwarf_add (struct backtrace_state *state,\n \t\t\t\tvoid *data, fileline *fileline_fn,\n \t\t\t\tstruct dwarf_data **fileline_entry);\n \n+/* A data structure to pass to backtrace_syminfo_to_full.  */\n+\n+struct backtrace_call_full\n+{\n+  backtrace_full_callback full_callback;\n+  backtrace_error_callback full_error_callback;\n+  void *full_data;\n+  int ret;\n+};\n+\n+/* A backtrace_syminfo_callback that can call into a\n+   backtrace_full_callback, used when we have a symbol table but no\n+   debug info.  */\n+\n+extern void backtrace_syminfo_to_full_callback (void *data, uintptr_t pc,\n+\t\t\t\t\t\tconst char *symname,\n+\t\t\t\t\t\tuintptr_t symval,\n+\t\t\t\t\t\tuintptr_t symsize);\n+\n+/* An error callback that corresponds to\n+   backtrace_syminfo_to_full_callback.  */\n+\n+extern void backtrace_syminfo_to_full_error_callback (void *, const char *,\n+\t\t\t\t\t\t      int);\n+\n /* A test-only hook for elf_uncompress_zdebug.  */\n \n extern int backtrace_uncompress_zdebug (struct backtrace_state *,"}, {"sha": "d73c98d44f8ea4e314405edc1853160e3b00e0cb", "filename": "libbacktrace/mtest.c", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90c254565122fa5c02114698ce35ac46679c03b0/libbacktrace%2Fmtest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90c254565122fa5c02114698ce35ac46679c03b0/libbacktrace%2Fmtest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fmtest.c?ref=90c254565122fa5c02114698ce35ac46679c03b0", "patch": "@@ -156,40 +156,49 @@ f3 (int f1line __attribute__ ((unused)), int f2line __attribute__ ((unused)))\n \t}\n     }\n \n-  if (all[0].function == NULL)\n+  if (data.index > 0)\n     {\n-      fprintf (stderr, \"test1: [0]: missing function name\\n\");\n-      data.failed = 1;\n-    }\n-  else if (strcmp (all[0].function, \"f3\") != 0)\n-    {\n-      fprintf (stderr, \"test1: [0]: got %s expected %s\\n\",\n-\t       all[0].function, \"f3\");\n-      data.failed = 1;\n+      if (all[0].function == NULL)\n+\t{\n+\t  fprintf (stderr, \"test1: [0]: missing function name\\n\");\n+\t  data.failed = 1;\n+\t}\n+      else if (strcmp (all[0].function, \"f3\") != 0)\n+\t{\n+\t  fprintf (stderr, \"test1: [0]: got %s expected %s\\n\",\n+\t\t   all[0].function, \"f3\");\n+\t  data.failed = 1;\n+\t}\n     }\n \n-  if (all[1].function == NULL)\n-    {\n-      fprintf (stderr, \"test1: [1]: missing function name\\n\");\n-      data.failed = 1;\n-    }\n-  else if (strcmp (all[1].function, \"f2\") != 0)\n+  if (data.index > 1)\n     {\n-      fprintf (stderr, \"test1: [1]: got %s expected %s\\n\",\n-\t       all[0].function, \"f2\");\n-      data.failed = 1;\n+      if (all[1].function == NULL)\n+\t{\n+\t  fprintf (stderr, \"test1: [1]: missing function name\\n\");\n+\t  data.failed = 1;\n+\t}\n+      else if (strcmp (all[1].function, \"f2\") != 0)\n+\t{\n+\t  fprintf (stderr, \"test1: [1]: got %s expected %s\\n\",\n+\t\t   all[0].function, \"f2\");\n+\t  data.failed = 1;\n+\t}\n     }\n \n-  if (all[2].function == NULL)\n-    {\n-      fprintf (stderr, \"test1: [2]: missing function name\\n\");\n-      data.failed = 1;\n-    }\n-  else if (strcmp (all[2].function, \"test1\") != 0)\n+  if (data.index > 2)\n     {\n-      fprintf (stderr, \"test1: [2]: got %s expected %s\\n\",\n-\t       all[0].function, \"test1\");\n-      data.failed = 1;\n+      if (all[2].function == NULL)\n+\t{\n+\t  fprintf (stderr, \"test1: [2]: missing function name\\n\");\n+\t  data.failed = 1;\n+\t}\n+      else if (strcmp (all[2].function, \"test1\") != 0)\n+\t{\n+\t  fprintf (stderr, \"test1: [2]: got %s expected %s\\n\",\n+\t\t   all[0].function, \"test1\");\n+\t  data.failed = 1;\n+\t}\n     }\n \n   printf (\"%s: backtrace_full noinline\\n\", data.failed ? \"FAIL\" : \"PASS\");"}]}