{"sha": "da22f50517faeb3fc185521631e3b86b89bd60ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGEyMmY1MDUxN2ZhZWIzZmMxODU1MjE2MzFlM2I4NmI4OWJkNjBlYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-07-09T19:09:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-07-09T19:09:50Z"}, "message": "* lto-streamer-out.c (hash_scc): Avoid quadratic hashing loop.\n\nFrom-SVN: r212404", "tree": {"sha": "eb9c33519ed93b72589ae736d44e885a88dd9b5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb9c33519ed93b72589ae736d44e885a88dd9b5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da22f50517faeb3fc185521631e3b86b89bd60ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da22f50517faeb3fc185521631e3b86b89bd60ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da22f50517faeb3fc185521631e3b86b89bd60ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da22f50517faeb3fc185521631e3b86b89bd60ec/comments", "author": null, "committer": null, "parents": [{"sha": "63dfbb95054c0ee31a1e8647316e1ef7015875a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63dfbb95054c0ee31a1e8647316e1ef7015875a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63dfbb95054c0ee31a1e8647316e1ef7015875a5"}], "stats": {"total": 38, "additions": 14, "deletions": 24}, "files": [{"sha": "96b437fbcf4f496cee29743e4cbf243fa3e94cf7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da22f50517faeb3fc185521631e3b86b89bd60ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da22f50517faeb3fc185521631e3b86b89bd60ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da22f50517faeb3fc185521631e3b86b89bd60ec", "patch": "@@ -1,3 +1,7 @@\n+2014-07-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-streamer-out.c (hash_scc): Avoid quadratic hashing loop.\n+\n 2014-07-08  Jan Hubicka  <hubicka@ucw.cz>\n \n \tRevert:"}, {"sha": "bd289090bae046f5816c1db769febd2abc4260bf", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 10, "deletions": 24, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da22f50517faeb3fc185521631e3b86b89bd60ec/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da22f50517faeb3fc185521631e3b86b89bd60ec/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=da22f50517faeb3fc185521631e3b86b89bd60ec", "patch": "@@ -1131,32 +1131,18 @@ hash_scc (struct streamer_tree_cache_d *cache, unsigned first, unsigned size)\n \n   /* Sort the SCC of type, hash pairs so that when we mix in\n      all members of the SCC the hash value becomes independent on\n-     the order we visited the SCC.  Disregard hashes equal to\n-     the hash of the tree we mix into because we cannot guarantee\n-     a stable sort for those across different TUs.  */\n+     the order we visited the SCC.  Produce hash of the whole SCC as\n+     combination of hashes of individual elements.  Then combine that hash into\n+     hash of each element, so othewise identically looking elements from two\n+     different SCCs are distinguished.  */\n   qsort (&sccstack[first], size, sizeof (scc_entry), scc_entry_compare);\n-  hashval_t *tem = XALLOCAVEC (hashval_t, size);\n-  for (unsigned i = 0; i < size; ++i)\n-    {\n-      hashval_t hash = sccstack[first+i].hash;\n-      hashval_t orig_hash = hash;\n-      unsigned j;\n-      /* Skip same hashes.  */\n-      for (j = i + 1;\n-\t   j < size && sccstack[first+j].hash == orig_hash; ++j)\n-\t;\n-      for (; j < size; ++j)\n-\thash = iterative_hash_hashval_t (sccstack[first+j].hash, hash);\n-      for (j = 0; sccstack[first+j].hash != orig_hash; ++j)\n-\thash = iterative_hash_hashval_t (sccstack[first+j].hash, hash);\n-      tem[i] = hash;\n-    }\n-  hashval_t scc_hash = 0;\n+\n+  hashval_t scc_hash = sccstack[first].hash;\n+  for (unsigned i = 1; i < size; ++i)\n+    scc_hash = iterative_hash_hashval_t (scc_hash,\n+\t\t\t\t\t sccstack[first+i].hash);\n   for (unsigned i = 0; i < size; ++i)\n-    {\n-      sccstack[first+i].hash = tem[i];\n-      scc_hash = iterative_hash_hashval_t (tem[i], scc_hash);\n-    }\n+    sccstack[first+i].hash = iterative_hash_hashval_t (sccstack[first+i].hash, scc_hash);\n   return scc_hash;\n }\n "}]}