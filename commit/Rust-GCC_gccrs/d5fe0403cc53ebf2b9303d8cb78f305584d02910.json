{"sha": "d5fe0403cc53ebf2b9303d8cb78f305584d02910", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVmZTA0MDNjYzUzZWJmMmI5MzAzZDhjYjc4ZjMwNTU4NGQwMjkxMA==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-02-29T19:10:46Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-02-29T19:10:46Z"}, "message": "FileChannelImpl.java: Moved to package gnu/java/nio/channels, since we need to refer to it from java.io.\n\n\n\t* java/nio/channels/FileChannelImpl.java:  Moved to package\n\tgnu/java/nio/channels, since we need to refer to it from java.io.\n\t* java/nio/channels/natFileChannelImpl.cc:  Removed file.\n\n\t* Makefile.am, configure.in:  Updated accordingly.\n\nFrom-SVN: r78660", "tree": {"sha": "507b52432fe5692a9d3978c735de8e444fd9761c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/507b52432fe5692a9d3978c735de8e444fd9761c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5fe0403cc53ebf2b9303d8cb78f305584d02910", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5fe0403cc53ebf2b9303d8cb78f305584d02910", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5fe0403cc53ebf2b9303d8cb78f305584d02910", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5fe0403cc53ebf2b9303d8cb78f305584d02910/comments", "author": null, "committer": null, "parents": [{"sha": "612e6609875599726838087b64e1ec6d6c8ee4e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/612e6609875599726838087b64e1ec6d6c8ee4e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/612e6609875599726838087b64e1ec6d6c8ee4e9"}], "stats": {"total": 551, "additions": 0, "deletions": 551}, "files": [{"sha": "ea2526e7002f6c80564a419b64a0e45ece7ae1e1", "filename": "libjava/java/nio/channels/FileChannelImpl.java", "status": "removed", "additions": 0, "deletions": 441, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/612e6609875599726838087b64e1ec6d6c8ee4e9/libjava%2Fjava%2Fnio%2Fchannels%2FFileChannelImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/612e6609875599726838087b64e1ec6d6c8ee4e9/libjava%2Fjava%2Fnio%2Fchannels%2FFileChannelImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FFileChannelImpl.java?ref=612e6609875599726838087b64e1ec6d6c8ee4e9", "patch": "@@ -1,441 +0,0 @@\n-/* FileChannelImpl.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n-02111-1307 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package java.nio.channels;\n-\n-import gnu.classpath.Configuration;\n-import gnu.gcj.RawData;\n-import gnu.java.nio.FileLockImpl;\n-import java.io.EOFException;\n-import java.io.FileDescriptor;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n-import java.nio.ByteBuffer;\n-import java.nio.MappedByteBuffer;\n-import java.nio.MappedByteBufferImpl;\n-\n-/**\n- * This file is not user visible !\n- * But alas, Java does not have a concept of friendly packages\n- * so this class is public. \n- * Instances of this class are created by invoking getChannel\n- * Upon a Input/Output/RandomAccessFile object.\n- */\n-\n-public class FileChannelImpl extends FileChannel\n-{\n-  static\n-  {\n-    // load the shared library needed for native methods.\n-    if (Configuration.INIT_LOAD_LIBRARY)\n-      {\n-        System.loadLibrary (\"javanio\");\n-      }\n-  }\n-  \n-  public RawData map_address;\n-  \n-  int length;\n-  FileDescriptor fd;\n-  MappedByteBuffer buf;\n-  Object file_obj; // just to keep it live...\n-\n-  public FileChannelImpl (FileDescriptor fd, boolean write, Object obj)\n-  {\n-    if (!(obj instanceof RandomAccessFile)\n-        && !(obj instanceof FileInputStream)\n-        && !(obj instanceof FileOutputStream))\n-      throw new InternalError ();\n-\n-    this.fd = fd;\n-    this.file_obj = obj;\n-  }\n-\n-  public FileChannelImpl ()\n-  {\n-    this (new FileDescriptor (), true, null);\n-  }\n-\n-  private native long implPosition ();\n-  private native FileChannel implPosition (long newPosition);\n-  private native FileChannel implTruncate (long size);\n-  \n-  private native RawData nio_mmap_file (long pos, long size, int mode);\n-  private native void nio_unmmap_file (RawData map_address, int size);\n-  private native void nio_msync (RawData map_address, int length);\n-\n-  public native long size () throws IOException;\n-    \n-  protected void implCloseChannel() throws IOException\n-  {\n-    if (map_address != null)\n-      {\n-        nio_unmmap_file (map_address, (int) length);\n-        map_address = null;\n-      }\n-\n-    if (file_obj instanceof RandomAccessFile)\n-      {\n-        RandomAccessFile o = (RandomAccessFile) file_obj;\n-        o.close();\n-      }\n-    else if (file_obj instanceof FileInputStream)\n-      {\n-        FileInputStream o = (FileInputStream) file_obj;\n-        o.close();\n-      }\n-    else if (file_obj instanceof FileOutputStream)\n-      {\n-        FileOutputStream o = (FileOutputStream) file_obj;\n-        o.close();\n-      }\n-  }\n-\n-  public int read (ByteBuffer dst) throws IOException\n-  {\n-    // Check if file is mapped into memory.\n-    if (buf != null)\n-      {\n-\t// FIXME: implement this\n-        throw new Error (\"Accessing mapped buffers not implemented.\");\n-      }\n-\n-    // File not mapped, access it directly.\n-    return implRead (dst);\n-  }\n-\n-  public int read (ByteBuffer dst, long position)\n-    throws IOException\n-  {\n-    if (position < 0)\n-      throw new IllegalArgumentException ();\n-\n-    if (!isOpen ())\n-      throw new ClosedChannelException ();\n-   \n-    if (file_obj instanceof FileOutputStream)\n-      throw new NonReadableChannelException ();\n-\n-    int result;\n-    long oldPosition;\n-\n-    oldPosition = implPosition ();\n-    position (position);\n-    result = implRead (dst);\n-    implPosition (oldPosition);\n-    \n-    return result;\n-  }\n-\n-  private int implRead (ByteBuffer dst) throws IOException\n-  {\n-    int result;\n-    byte[] buffer = new byte [dst.remaining ()];\n-    \n-    result = implRead (buffer, 0, buffer.length);\n-\n-    if (result > 0)\n-      dst.put (buffer, 0, result);\n-\n-    return result;\n-  }\n-  \n-  private native int implRead (byte[] buffer, int offset, int length)\n-    throws IOException;\n-\n-  public long read (ByteBuffer[] dsts, int offset, int length)\n-    throws IOException\n-  {\n-    long result = 0;\n-\n-    for (int i = offset; i < offset + length; i++)\n-      {\n-        result += read (dsts [i]);\n-      }\n-\n-    return result;\n-  }\n-\n-  public int write (ByteBuffer src) throws IOException\n-  {\n-    // Check if file is mapped into memory.\n-    if (buf != null)\n-      {\n-\t// FIXME: implement this\n-        throw new Error (\"Accessing mapped buffers not implemented.\");\n-      }\n-    \n-    // File not mapped, access it directly.\n-    return implWrite (src);\n-  }\n-    \n-  public int write (ByteBuffer src, long position)\n-    throws IOException\n-  {\n-    if (position < 0)\n-      throw new IllegalArgumentException ();\n-\n-    if (!isOpen ())\n-      throw new ClosedChannelException ();\n-    \n-    if (file_obj instanceof FileInputStream)\n-       throw new NonWritableChannelException ();\n-\n-    int result;\n-    long oldPosition;\n-\n-    oldPosition = implPosition ();\n-    position (position);\n-    result = implWrite (src);\n-    implPosition (oldPosition);\n-    \n-    return result;\n-  }\n-\n-  private int implWrite (ByteBuffer src) throws IOException\n-  {\n-    byte[] buffer = new byte [src.remaining ()];\n-    \n-    src.get (buffer, 0, buffer.length);\n-    return implWrite (buffer, 0, buffer.length);\n-  }\n-  \n-  private native int implWrite (byte[] buffer, int offset, int length)\n-    throws IOException;\n-  \n-  public long write(ByteBuffer[] srcs, int offset, int length)\n-    throws IOException\n-  {\n-    long result = 0;\n-\n-    for (int i = offset;i < offset + length;i++)\n-      {\n-        result += write (srcs[i]);\n-      }\n-    \n-    return result;\n-  }\n-\t\t\t\t   \n-  public MappedByteBuffer map (FileChannel.MapMode mode, long position,\n-                               long size)\n-    throws IOException\n-  {\n-    if ((mode != MapMode.READ_ONLY\n-         && mode != MapMode.READ_WRITE\n-         && mode != MapMode.PRIVATE)\n-        || position < 0\n-        || size < 0\n-        || size > Integer.MAX_VALUE)\n-      throw new IllegalArgumentException ();\n-    \n-    // FIXME: Make this working.\n-    int cmode = mode.m;\n-    map_address = nio_mmap_file (position, size, cmode);\n-    length = (int) size;\n-    buf = new MappedByteBufferImpl (this);\n-    return buf;\n-  }\n-\n-  static MappedByteBuffer create_direct_mapped_buffer (RawData map_address,\n-                                                       long length)\n-    throws IOException\n-  {\n-    FileChannelImpl ch = new FileChannelImpl ();\n-    ch.map_address = map_address;\n-    ch.length = (int) length;\n-    ch.buf = new MappedByteBufferImpl (ch);\n-    return ch.buf;\t\t\t \n-  }\n-\n-  /**\n-   * msync with the disk\n-   */\n-  public void force (boolean metaData) throws IOException\n-  {\n-    if (!isOpen ())\n-      throw new ClosedChannelException ();\n-\n-    // FIXME: What to do with metaData ?\n-    \n-    nio_msync (map_address, length);\n-  }\n-\n-  public long transferTo (long position, long count, WritableByteChannel target)\n-    throws IOException\n-  {\n-    if (position < 0\n-        || count < 0)\n-      throw new IllegalArgumentException ();\n-\n-    if (!isOpen ())\n-      throw new ClosedChannelException ();\n-\n-    if (file_obj instanceof FileOutputStream)\n-       throw new NonReadableChannelException ();\n-   \n-    // XXX: count needs to be casted from long to int. Dataloss ?\n-    ByteBuffer buffer = ByteBuffer.allocate ((int) count);\n-    read (buffer, position);\n-    buffer.flip();\n-    return target.write (buffer);\n-  }\n-\n-  public long transferFrom (ReadableByteChannel src, long position, long count)\n-    throws IOException\n-  {\n-    if (position < 0\n-        || count < 0)\n-      throw new IllegalArgumentException ();\n-\n-    if (!isOpen ())\n-      throw new ClosedChannelException ();\n-\n-    if (file_obj instanceof FileInputStream)\n-       throw new NonWritableChannelException ();\n-\n-    // XXX: count needs to be casted from long to int. Dataloss ?\n-    ByteBuffer buffer = ByteBuffer.allocate ((int) count);\n-    src.read (buffer);\n-    buffer.flip();\n-    return write (buffer, position);\n-  }\n-\n-  public FileLock lock (long position, long size, boolean shared)\n-    throws IOException\n-  {\n-    if (position < 0\n-        || size < 0)\n-      throw new IllegalArgumentException ();\n-\n-    if (!isOpen ())\n-      throw new ClosedChannelException ();\n-\n-    if (shared &&\n-        file_obj instanceof FileOutputStream)\n-      throw new NonReadableChannelException ();\n-\t\n-    if (!shared &&\n-        file_obj instanceof FileInputStream)\n-      throw new NonWritableChannelException ();\n-\t\n-    boolean completed = false;\n-    \n-    try\n-      {\n-\tbegin();\n-        lockImpl(position, size, shared);\n-\tcompleted = true;\n-\treturn new FileLockImpl(fd, this, position, size, shared);\n-      }\n-    finally\n-      {\n-\tend(completed);\n-      }\n-  }\n-\n-  private native void lockImpl(long position, long size, boolean shared);\n-  \n-  public FileLock tryLock (long position, long size, boolean shared)\n-    throws IOException\n-  {\n-    if (position < 0\n-        || size < 0)\n-      throw new IllegalArgumentException ();\n-\n-    if (!isOpen ())\n-      throw new ClosedChannelException ();\n-\n-    if (! tryLockImpl(position, size, shared))\n-      return null;\n-\n-    boolean completed = false;\n-\n-    try\n-      {\n-\tboolean lockable = tryLockImpl(position, size, shared);\n-\tcompleted = true;\n-\treturn (lockable\n-\t\t? new FileLockImpl(fd, this, position, size, shared)\n-\t\t: null);\n-      }\n-    finally\n-      {\n-\tend(completed);\n-      }\n-  }\n-\n-  private native boolean tryLockImpl(long position, long size, boolean shared);\n-  \n-  public long position ()\n-    throws IOException\n-  {\n-    if (!isOpen ())\n-      throw new ClosedChannelException ();\n-\n-    return implPosition ();\n-  }\n-  \n-  public FileChannel position (long newPosition)\n-    throws IOException\n-  {\n-    if (newPosition < 0)\n-      throw new IllegalArgumentException ();\n-\n-    if (!isOpen ())\n-      throw new ClosedChannelException ();\n-\n-    return implPosition (newPosition);\n-  }\n-  \n-  public FileChannel truncate (long size)\n-    throws IOException\n-  {\n-    if (size < 0)\n-      throw new IllegalArgumentException ();\n-\n-    if (!isOpen ())\n-      throw new ClosedChannelException ();\n-\n-    if (file_obj instanceof FileInputStream)\n-       throw new NonWritableChannelException ();\n-\n-    return implTruncate (size);\n-  }\n-}"}, {"sha": "56828a46604c1da25c6354f80501a387cb16dd81", "filename": "libjava/java/nio/channels/natFileChannelImpl.cc", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/612e6609875599726838087b64e1ec6d6c8ee4e9/libjava%2Fjava%2Fnio%2Fchannels%2FnatFileChannelImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/612e6609875599726838087b64e1ec6d6c8ee4e9/libjava%2Fjava%2Fnio%2Fchannels%2FnatFileChannelImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FnatFileChannelImpl.cc?ref=612e6609875599726838087b64e1ec6d6c8ee4e9", "patch": "@@ -1,110 +0,0 @@\n-// natFileChannelImpl.cc\n-\n-/* Copyright (C) 2003  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-#include <config.h>\n-\n-#include <jvm.h>\n-\n-#include <errno.h>\n-#include <string.h>\n-#include <sys/types.h>\n-\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n-\n-#ifdef HAVE_FCNTL_H\n-#include <fcntl.h>\n-#endif\n-\n-#include <gnu/gcj/RawData.h>\n-#include <gnu/java/nio/FileLockImpl.h>\n-#include <java/io/FileDescriptor.h>\n-#include <java/io/IOException.h>\n-#include <java/nio/ByteBuffer.h>\n-#include <java/nio/channels/FileChannel.h>\n-#include <java/nio/channels/FileChannelImpl.h>\n-#include <java/nio/channels/FileLock.h>\n-\n-jlong\n-java::nio::channels::FileChannelImpl::size ()\n-{\n-  return fd->getLength ();\n-}\n-\n-jlong\n-java::nio::channels::FileChannelImpl::implPosition ()\n-{\n-  return fd->getFilePointer ();\n-}\n-\n-java::nio::channels::FileChannel*\n-java::nio::channels::FileChannelImpl::implPosition (jlong newPosition)\n-{\n-  fd->seek (newPosition, ::java::io::FileDescriptor::SET, true);\n-  return this;\n-}\n-\n-jint\n-java::nio::channels::FileChannelImpl::implRead (JArray<jbyte>* buffer,\n-                                                jint offset, jint len)\n-{\n-  return fd->read (buffer, offset, len);\n-}\n-\n-jint\n-java::nio::channels::FileChannelImpl::implWrite (JArray<jbyte>* buffer,\n-                                                 jint offset, jint len)\n-{\n-  fd->write (buffer, offset, len);\n-  return len;\n-}\n-\n-java::nio::channels::FileChannel*\n-java::nio::channels::FileChannelImpl::implTruncate (jlong size)\n-{\n-  fd->setLength (size);\n-  return this;\n-}\n-\n-gnu::gcj::RawData*\n-java::nio::channels::FileChannelImpl::nio_mmap_file (jlong /*pos*/, jlong /*size*/,\n-                                                     jint /*mode*/)\n-{\n-  throw new ::java::io::IOException (JvNewStringUTF (\"mmap not implemented\"));\n-}\n-\n-void\n-java::nio::channels::FileChannelImpl::nio_unmmap_file (gnu::gcj::RawData* /*address*/,\n-\t\t\t\t                       jint /*size*/)\n-{\n-  throw new ::java::io::IOException (JvNewStringUTF (\"munmap not implemented\"));\n-}\n-\n-void\n-java::nio::channels::FileChannelImpl::nio_msync (gnu::gcj::RawData* /*map_address*/,\n-                                                 jint /*length*/)\n-{\n-  throw new ::java::io::IOException (JvNewStringUTF (\"msync not implemented\"));\n-}\n-\n-void\n-java::nio::channels::FileChannelImpl::lockImpl(jlong position, jlong size, jboolean shared)\n-{\n-  // FIXME: shared is unused, write is always true.\n-  fd->lock(position, size, true);\n-}\n-\n-jboolean\n-java::nio::channels::FileChannelImpl::tryLockImpl(jlong position, jlong size, jboolean shared)\n-{\n-  // FIXME: shared is unused, write is always true.\n-  return fd->tryLock(position, size, true);\n-}"}]}