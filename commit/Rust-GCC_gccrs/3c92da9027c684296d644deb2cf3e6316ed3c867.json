{"sha": "3c92da9027c684296d644deb2cf3e6316ed3c867", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M5MmRhOTAyN2M2ODQyOTZkNjQ0ZGViMmNmM2U2MzE2ZWQzYzg2Nw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2014-01-08T06:03:12Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2014-01-08T06:03:12Z"}, "message": "re PR middle-end/53623 (sign extension is effectively split into two x86-64 instructions)\n\n\tPR middle-end/53623\n\t* ree.c (combine_set_extension): Handle case where source\n\tand destination registers in an extension insn are different.\n\t(combine_reaching_defs): Allow source and destination\n\tregisters in extension to be different under limited\n\tcircumstances.\n\t(add_removable_extension): Remove restriction that the\n\tsource and destination registers in the extension are the\n\tsame.\n\t(find_and_remove_re): Emit a copy from the extension's\n\tdestination to its source after the defining insn if\n\tthe source and destination registers are different.\n\n\tPR middle-end/53623\n\t* gcc.target/i386/pr53623.c: New test.\n\nFrom-SVN: r206418", "tree": {"sha": "9d6940a9da8de60753e9b31ec7d076e013a60547", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d6940a9da8de60753e9b31ec7d076e013a60547"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c92da9027c684296d644deb2cf3e6316ed3c867", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c92da9027c684296d644deb2cf3e6316ed3c867", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c92da9027c684296d644deb2cf3e6316ed3c867", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c92da9027c684296d644deb2cf3e6316ed3c867/comments", "author": null, "committer": null, "parents": [{"sha": "04af8ab664b576f02652dc0034393b3a563b28f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04af8ab664b576f02652dc0034393b3a563b28f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04af8ab664b576f02652dc0034393b3a563b28f7"}], "stats": {"total": 143, "additions": 138, "deletions": 5}, "files": [{"sha": "986ffaf2070858f03ed662af293a22ce4aa524c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c92da9027c684296d644deb2cf3e6316ed3c867/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c92da9027c684296d644deb2cf3e6316ed3c867/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c92da9027c684296d644deb2cf3e6316ed3c867", "patch": "@@ -1,5 +1,18 @@\n 2014-01-07  Jeff Law  <law@redhat.com>\n \n+\tPR middle-end/53623\n+\t* ree.c (combine_set_extension): Handle case where source\n+\tand destination registers in an extension insn are different.\n+\t(combine_reaching_defs): Allow source and destination\n+\tregisters in extension to be different under limited\n+\tcircumstances.\n+\t(add_removable_extension): Remove restriction that the\n+\tsource and destination registers in the extension are the\n+\tsame.\n+\t(find_and_remove_re): Emit a copy from the extension's\n+\tdestination to its source after the defining insn if\n+\tthe source and destination registers are different.\n+\n \tPR middle-end/59285\n \t* ifcvt.c (merge_if_block): If we are merging a block with more than\n \tone successor with a block with no successors, remove any BARRIER"}, {"sha": "ec09c7ae730fa9f4e076489593a1c3108a4c6332", "filename": "gcc/ree.c", "status": "modified", "additions": 95, "deletions": 5, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c92da9027c684296d644deb2cf3e6316ed3c867/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c92da9027c684296d644deb2cf3e6316ed3c867/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=3c92da9027c684296d644deb2cf3e6316ed3c867", "patch": "@@ -282,8 +282,20 @@ static bool\n combine_set_extension (ext_cand *cand, rtx curr_insn, rtx *orig_set)\n {\n   rtx orig_src = SET_SRC (*orig_set);\n-  rtx new_reg = gen_rtx_REG (cand->mode, REGNO (SET_DEST (*orig_set)));\n   rtx new_set;\n+  rtx cand_pat = PATTERN (cand->insn);\n+\n+  /* If the extension's source/destination registers are not the same\n+     then we need to change the original load to reference the destination\n+     of the extension.  Then we need to emit a copy from that destination\n+     to the original destination of the load.  */\n+  rtx new_reg;\n+  bool copy_needed\n+    = (REGNO (SET_DEST (cand_pat)) != REGNO (XEXP (SET_SRC (cand_pat), 0)));\n+  if (copy_needed)\n+    new_reg = gen_rtx_REG (cand->mode, REGNO (SET_DEST (cand_pat)));\n+  else\n+    new_reg = gen_rtx_REG (cand->mode, REGNO (SET_DEST (*orig_set)));\n \n   /* Merge constants by directly moving the constant into the register under\n      some conditions.  Recall that RTL constants are sign-extended.  */\n@@ -342,7 +354,8 @@ combine_set_extension (ext_cand *cand, rtx curr_insn, rtx *orig_set)\n       if (dump_file)\n         {\n           fprintf (dump_file,\n-\t\t   \"Tentatively merged extension with definition:\\n\");\n+\t\t   \"Tentatively merged extension with definition %s:\\n\",\n+\t\t   (copy_needed) ? \"(copy needed)\" : \"\");\n           print_rtl_single (dump_file, curr_insn);\n         }\n       return true;\n@@ -662,6 +675,53 @@ combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)\n   if (!outcome)\n     return false;\n \n+  /* If the destination operand of the extension is a different\n+     register than the source operand, then additional restrictions\n+     are needed.  */\n+  if ((REGNO (SET_DEST (PATTERN (cand->insn)))\n+       != REGNO (XEXP (SET_SRC (PATTERN (cand->insn)), 0))))\n+    {\n+      /* In theory we could handle more than one reaching def, it\n+\t just makes the code to update the insn stream more complex.  */\n+      if (state->defs_list.length () != 1)\n+\treturn false;\n+\n+      /* We require the candidate not already be modified.  This may\n+\t be overly conservative.  */\n+      if (state->modified[INSN_UID (cand->insn)].kind != EXT_MODIFIED_NONE)\n+\treturn false;\n+\n+      /* There's only one reaching def.  */\n+      rtx def_insn = state->defs_list[0];\n+\n+      /* The defining statement must not have been modified either.  */\n+      if (state->modified[INSN_UID (def_insn)].kind != EXT_MODIFIED_NONE)\n+\treturn false;\n+\n+      /* The defining statement and candidate insn must be in the same block.\n+\t This is merely to keep the test for safety and updating the insn\n+\t stream simple.  */\n+      if (BLOCK_FOR_INSN (cand->insn) != BLOCK_FOR_INSN (def_insn))\n+\treturn false;\n+\n+      /* If there is an overlap between the destination of DEF_INSN and\n+\t CAND->insn, then this transformation is not safe.  Note we have\n+\t to test in the widened mode.  */\n+      rtx tmp_reg = gen_rtx_REG (GET_MODE (SET_DEST (PATTERN (cand->insn))),\n+\t\t\t\t REGNO (SET_DEST (PATTERN (def_insn))));\n+      if (reg_overlap_mentioned_p (tmp_reg, SET_DEST (PATTERN (cand->insn))))\n+\treturn false;\n+\n+      /* The destination register of the extension insn must not be\n+\t used or set between the def_insn and cand->insn exclusive.  */\n+      if (reg_used_between_p (SET_DEST (PATTERN (cand->insn)),\n+\t\t\t      def_insn, cand->insn)\n+\t  || reg_set_between_p (SET_DEST (PATTERN (cand->insn)),\n+\t\t\t\tdef_insn, cand->insn))\n+\treturn false;\n+    }\n+\n+\n   /* If cand->insn has been already modified, update cand->mode to a wider\n      mode if possible, or punt.  */\n   if (state->modified[INSN_UID (cand->insn)].kind != EXT_MODIFIED_NONE)\n@@ -778,8 +838,7 @@ add_removable_extension (const_rtx expr, rtx insn,\n \n   if (REG_P (dest)\n       && (code == SIGN_EXTEND || code == ZERO_EXTEND)\n-      && REG_P (XEXP (src, 0))\n-      && REGNO (dest) == REGNO (XEXP (src, 0)))\n+      && REG_P (XEXP (src, 0)))\n     {\n       struct df_link *defs, *def;\n       ext_cand *cand;\n@@ -863,6 +922,7 @@ find_and_remove_re (void)\n   int num_re_opportunities = 0, num_realized = 0, i;\n   vec<ext_cand> reinsn_list;\n   auto_vec<rtx> reinsn_del_list;\n+  auto_vec<rtx> reinsn_copy_list;\n   ext_state state;\n \n   /* Construct DU chain to get all reaching definitions of each\n@@ -899,11 +959,41 @@ find_and_remove_re (void)\n           if (dump_file)\n             fprintf (dump_file, \"Eliminated the extension.\\n\");\n           num_realized++;\n-          reinsn_del_list.safe_push (curr_cand->insn);\n+\t  if (REGNO (SET_DEST (PATTERN (curr_cand->insn)))\n+\t      != REGNO (XEXP (SET_SRC (PATTERN (curr_cand->insn)), 0)))\n+\t    {\n+              reinsn_copy_list.safe_push (curr_cand->insn);\n+              reinsn_copy_list.safe_push (state.defs_list[0]);\n+\t    }\n+\t  reinsn_del_list.safe_push (curr_cand->insn);\n \t  state.modified[INSN_UID (curr_cand->insn)].deleted = 1;\n         }\n     }\n \n+  /* The copy list contains pairs of insns which describe copies we\n+     need to insert into the INSN stream.\n+\n+     The first insn in each pair is the extension insn, from which\n+     we derive the source and destination of the copy.\n+\n+     The second insn in each pair is the memory reference where the\n+     extension will ultimately happen.  We emit the new copy\n+     immediately after this insn.\n+\n+     It may first appear that the arguments for the copy are reversed.\n+     Remember that the memory reference will be changed to refer to the\n+     destination of the extention.  So we're actually emitting a copy\n+     from the new destination to the old destination.  */\n+  for (unsigned int i = 0; i < reinsn_copy_list.length (); i += 2)\n+    {\n+      rtx curr_insn = reinsn_copy_list[i];\n+      rtx pat = PATTERN (curr_insn);\n+      rtx new_reg = gen_rtx_REG (GET_MODE (SET_DEST (pat)),\n+\t\t\t\t REGNO (XEXP (SET_SRC (pat), 0)));\n+      rtx set = gen_rtx_SET (VOIDmode, new_reg, SET_DEST (pat));\n+      emit_insn_after (set, reinsn_copy_list[i + 1]);\n+    }\n+\n   /* Delete all useless extensions here in one sweep.  */\n   FOR_EACH_VEC_ELT (reinsn_del_list, i, curr_insn)\n     delete_insn (curr_insn);"}, {"sha": "442eb03d2dce167224eddb96656c23a73657ea6d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c92da9027c684296d644deb2cf3e6316ed3c867/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c92da9027c684296d644deb2cf3e6316ed3c867/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3c92da9027c684296d644deb2cf3e6316ed3c867", "patch": "@@ -1,3 +1,8 @@\n+2014-01-07  Jeff Law  <law@redhat.com>\n+\n+\tPR middle-end/53623\n+\t* gcc.target/i386/pr53623.c: New test.\n+\n 2014-01-07  Adam Butcher  <adam@jessamine.co.uk>\n \n \t* g++.dg/cpp1y/pr58500.C: Hoist PR reference to first line and remove"}, {"sha": "35c578bd618f87a22c2582907cd6571a691818ef", "filename": "gcc/testsuite/gcc.target/i386/pr53623.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c92da9027c684296d644deb2cf3e6316ed3c867/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr53623.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c92da9027c684296d644deb2cf3e6316ed3c867/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr53623.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr53623.c?ref=3c92da9027c684296d644deb2cf3e6316ed3c867", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile { target {! ia32 } } } */\n+/* { dg-options \"-O2 -fdump-rtl-ree\" } */\n+\n+\n+#include <stdint.h>\n+\n+typedef (*inst_t)(int64_t rdi, int64_t rsi, int64_t rdx);\n+\n+int16_t code[256];\n+inst_t dispatch[256];\n+\n+void an_inst(int64_t rdi, int64_t rsi, int64_t rdx) {\n+  rdx = code[rdx];\n+  uint8_t inst = (uint8_t) rdx;\n+  rdx >>= 8;\n+  dispatch[inst](rdi, rsi, rdx);\n+}\n+\n+int main(void) {\n+  return 0;\n+}\n+\n+/* { dg-final { scan-rtl-dump \"copy needed\" \"ree\" } } */\n+/* { dg-final { cleanup-rtl-dump \"ree\" } } */\n+"}]}