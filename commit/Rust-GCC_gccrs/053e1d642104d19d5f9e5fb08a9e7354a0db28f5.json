{"sha": "053e1d642104d19d5f9e5fb08a9e7354a0db28f5", "node_id": "C_kwDOANBUbNoAKDA1M2UxZDY0MjEwNGQxOWQ1ZjllNWZiMDhhOWU3MzU0YTBkYjI4ZjU", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-09-22T20:58:22Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-09-23T16:56:43Z"}, "message": "Create a ranger-local flag for non-executable edges.\n\nInstead of repurposing EDGE_EXECUTABLE, ranger creates a local flag and\nultizes it throughout.\n\n\t* gimple-range-cache.cc (ranger_cache::ranger_cache): Take\n\tnon-executable_edge flag as parameter.\n\t* gimple-range-cache.h (ranger_cache): Adjust prototype.\n\t* gimple-range-gori.cc (gori_compute::gori_compute): Take\n\tnon-executable_edge flag as parameter.\n\t(gori_compute::outgoing_edge_range_p): Check new flag.\n\t* gimple-range-gori.h (gori_compute): Adjust prototype.\n\t* gimple-range.cc (gimple_ranger::gimple_ranger): Create new flag.\n\t(gimple_ranger::range_on_edge): Check new flag.\n\t* gimple-range.h (gimple_ranger::non_executable_edge_flag): New.\n\t* gimple-ssa-evrp.c (rvrp_folder): Pass ranger flag to simplifer.\n\t(hybrid_folder::hybrid_folder): Set ranger non-executable flag value.\n\t(hybrid_folder::fold_stmt): Set flag value in the simplifer.\n\t* vr-values.c (simplify_using_ranges::set_and_propagate_unexecutable):\n\tUse not_executable flag if provided inmstead of EDGE_EXECUTABLE.\n\t(simplify_using_ranges::simplify_switch_using_ranges): Clear\n\tEDGE_EXECUTABLE like it originally did.\n\t(simplify_using_ranges::cleanup_edges_and_switches): Clear any\n\tNON_EXECUTABLE flags.\n\t(simplify_using_ranges::simplify_using_ranges): Adjust.\n\t* vr-values.h (class simplify_using_ranges): Adjust.\n\t(simplify_using_ranges::set_range_query): Add non-executable flag param.", "tree": {"sha": "0e842f9e1c0fdd1788cb7465c2ac4f14b397b519", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e842f9e1c0fdd1788cb7465c2ac4f14b397b519"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/053e1d642104d19d5f9e5fb08a9e7354a0db28f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/053e1d642104d19d5f9e5fb08a9e7354a0db28f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/053e1d642104d19d5f9e5fb08a9e7354a0db28f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/comments", "author": null, "committer": null, "parents": [{"sha": "1b07d9dce6c51c98d011236c3d4cd84a2ed59ba2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b07d9dce6c51c98d011236c3d4cd84a2ed59ba2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b07d9dce6c51c98d011236c3d4cd84a2ed59ba2"}], "stats": {"total": 84, "additions": 64, "deletions": 20}, "files": [{"sha": "61043d3f37507056e4618f76c2124aede3169c71", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=053e1d642104d19d5f9e5fb08a9e7354a0db28f5", "patch": "@@ -750,7 +750,8 @@ temporal_cache::set_always_current (tree name)\n \n // --------------------------------------------------------------------------\n \n-ranger_cache::ranger_cache ()\n+ranger_cache::ranger_cache (int not_executable_flag)\n+\t\t\t\t\t\t: m_gori (not_executable_flag)\n {\n   m_workback.create (0);\n   m_workback.safe_grow_cleared (last_basic_block_for_fn (cfun));"}, {"sha": "4937a0b305a5befedf8608a6f8fab210d01fb1af", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=053e1d642104d19d5f9e5fb08a9e7354a0db28f5", "patch": "@@ -92,7 +92,7 @@ class ssa_global_cache\n class ranger_cache : public range_query\n {\n public:\n-  ranger_cache ();\n+  ranger_cache (int not_executable_flag);\n   ~ranger_cache ();\n \n   virtual bool range_of_expr (irange &r, tree name, gimple *stmt);"}, {"sha": "4a1ade7f921b1039022e0b7625c2314f5040f0db", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=053e1d642104d19d5f9e5fb08a9e7354a0db28f5", "patch": "@@ -634,8 +634,9 @@ debug (gori_map &g)\n \n // Construct a gori_compute object.\n \n-gori_compute::gori_compute () : tracer (\"GORI \")\n+gori_compute::gori_compute (int not_executable_flag) : tracer (\"GORI \")\n {\n+  m_not_executable_flag = not_executable_flag;\n   // Create a boolean_type true and false range.\n   m_bool_zero = int_range<2> (boolean_false_node, boolean_false_node);\n   m_bool_one = int_range<2> (boolean_true_node, boolean_true_node);\n@@ -1214,7 +1215,7 @@ gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name,\n   int_range_max lhs;\n   unsigned idx;\n \n-  if ((e->flags & EDGE_EXECUTABLE) == 0)\n+  if ((e->flags & m_not_executable_flag))\n     {\n       r.set_undefined ();\n       if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "ec0b95145f00924e11aa859a948da1308924e30c", "filename": "gcc/gimple-range-gori.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fgimple-range-gori.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fgimple-range-gori.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.h?ref=053e1d642104d19d5f9e5fb08a9e7354a0db28f5", "patch": "@@ -147,12 +147,16 @@ class gori_map : public range_def_chain\n // expr_range_in_bb is simply a wrapper which calls ssa_range_in_bb for \n // SSA_NAMES and otherwise simply calculates the range of the expression.\n //\n+// The constructor takes a flag value to use on edges to check for the\n+// NON_EXECUTABLE_EDGE property.  The zero default means no flag is checked.\n+// All value requests from NON_EXECUTABLE_EDGE edges are returned UNDEFINED.\n+//\n // The remaining routines are internal use only.\n \n class gori_compute : public gori_map\n {\n public:\n-  gori_compute ();\n+  gori_compute (int not_executable_flag = 0);\n   bool outgoing_edge_range_p (irange &r, edge e, tree name, range_query &q);\n   bool has_edge_range_p (tree name, edge e = NULL);\n   void dump (FILE *f);\n@@ -181,6 +185,7 @@ class gori_compute : public gori_map\n \n   gimple_outgoing_range outgoing;\t// Edge values for COND_EXPR & SWITCH_EXPR.\n   range_tracer tracer;\n+  int m_not_executable_flag;\n };\n \n // These routines provide a GIMPLE interface to the range-ops code."}, {"sha": "d4108db18557609eaeb130b54bf7c28a98381125", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=053e1d642104d19d5f9e5fb08a9e7354a0db28f5", "patch": "@@ -34,15 +34,29 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"gimple-range.h\"\n-#include \"domwalk.h\"\n \n-gimple_ranger::gimple_ranger () : tracer (\"\")\n+gimple_ranger::gimple_ranger () :\n+\tnon_executable_edge_flag (cfun),\n+\tm_cache (non_executable_edge_flag),\n+\ttracer (\"\")\n {\n   // If the cache has a relation oracle, use it.\n   m_oracle = m_cache.oracle ();\n   if (dump_file && (param_evrp_mode & EVRP_MODE_TRACE))\n     tracer.enable_trace ();\n-  set_all_edges_as_executable (cfun);\n+\n+  // Ensure the not_executable flag is clear everywhere.\n+  if (flag_checking)\n+    {\n+      basic_block bb;\n+      FOR_ALL_BB_FN (bb, cfun)\n+\t{\n+\t  edge_iterator ei;\n+\t  edge e;\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    gcc_checking_assert ((e->flags & non_executable_edge_flag) == 0);\n+\t}\n+    }\n }\n \n bool\n@@ -174,7 +188,7 @@ gimple_ranger::range_on_edge (irange &r, edge e, tree name)\n     }\n \n   // Check to see if the edge is executable.\n-  if ((e->flags & EDGE_EXECUTABLE) == 0)\n+  if ((e->flags & non_executable_edge_flag))\n     {\n       r.set_undefined ();\n       if (idx)"}, {"sha": "191a075a1b0115f8d4f93b6554c9eb3981b40f69", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=053e1d642104d19d5f9e5fb08a9e7354a0db28f5", "patch": "@@ -56,6 +56,7 @@ class gimple_ranger : public range_query\n   inline gori_compute &gori ()  { return m_cache.m_gori; }\n   virtual void dump (FILE *f) OVERRIDE;\n   void dump_bb (FILE *f, basic_block bb);\n+  auto_edge_flag non_executable_edge_flag;\n protected:\n   bool fold_range_internal (irange &r, gimple *s, tree name);\n   ranger_cache m_cache;"}, {"sha": "437f19471f14e9055c602f0411fbc7402fae83d9", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=053e1d642104d19d5f9e5fb08a9e7354a0db28f5", "patch": "@@ -121,7 +121,7 @@ class rvrp_folder : public substitute_and_fold_engine\n   rvrp_folder () : substitute_and_fold_engine (), m_simplifier ()\n   {\n     m_ranger = enable_ranger (cfun);\n-    m_simplifier.set_range_query (m_ranger);\n+    m_simplifier.set_range_query (m_ranger, m_ranger->non_executable_edge_flag);\n     m_pta = new pointer_equiv_analyzer (m_ranger);\n   }\n       \n@@ -205,12 +205,16 @@ class hybrid_folder : public evrp_folder\n     if (evrp_first)\n       {\n \tfirst = &m_range_analyzer;\n+\tfirst_exec_flag = 0;\n \tsecond = m_ranger;\n+\tsecond_exec_flag = m_ranger->non_executable_edge_flag;\n       }\n      else\n       {\n \tfirst = m_ranger;\n+\tfirst_exec_flag = m_ranger->non_executable_edge_flag;\n \tsecond = &m_range_analyzer;\n+\tsecond_exec_flag = 0;\n       }\n     m_pta = new pointer_equiv_analyzer (m_ranger);\n   }\n@@ -227,11 +231,11 @@ class hybrid_folder : public evrp_folder\n \n   bool fold_stmt (gimple_stmt_iterator *gsi) OVERRIDE\n     {\n-      simplifier.set_range_query (first);\n+      simplifier.set_range_query (first, first_exec_flag);\n       if (simplifier.simplify (gsi))\n \treturn true;\n \n-      simplifier.set_range_query (second);\n+      simplifier.set_range_query (second, second_exec_flag);\n       if (simplifier.simplify (gsi))\n \t{\n \t  if (dump_file)\n@@ -267,7 +271,9 @@ class hybrid_folder : public evrp_folder\n   DISABLE_COPY_AND_ASSIGN (hybrid_folder);\n   gimple_ranger *m_ranger;\n   range_query *first;\n+  int first_exec_flag;\n   range_query *second;\n+  int second_exec_flag;\n   pointer_equiv_analyzer *m_pta;\n   tree choose_value (tree evrp_val, tree ranger_val);\n };"}, {"sha": "9bf58f416f2d86f2fcb2a494861fa6807fa52fb7", "filename": "gcc/vr-values.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=053e1d642104d19d5f9e5fb08a9e7354a0db28f5", "patch": "@@ -3460,19 +3460,21 @@ range_fits_type_p (const value_range *vr,\n void\n simplify_using_ranges::set_and_propagate_unexecutable (edge e)\n {\n-  // If EXECUUTABLE is already clear, we're done.\n-  if ((e->flags & EDGE_EXECUTABLE) == 0)\n+  // If not_executable is already set, we're done.\n+  // This works in the absence of a flag as well.\n+  if ((e->flags & m_not_executable_flag) == m_not_executable_flag)\n     return;\n \n-  e->flags &= ~EDGE_EXECUTABLE;\n+  e->flags |= m_not_executable_flag;\n+  m_flag_set_edges.safe_push (e);\n \n   // Check if the destination block needs to propagate the property.\n   basic_block bb = e->dest;\n \n-  // If any entry edge is marked EXECUTABLE, we are done.\n+  // If any incoming edge is executable, we are done.\n   edge_iterator ei;\n   FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (e->flags & EDGE_EXECUTABLE)\n+    if ((e->flags & m_not_executable_flag) == 0)\n       return;\n \n   // This block is also unexecutable, propagate to all exit edges as well.\n@@ -3805,6 +3807,7 @@ simplify_using_ranges::simplify_switch_using_ranges (gswitch *stmt)\n \t}\n       to_remove_edges.safe_push (e);\n       set_and_propagate_unexecutable (e);\n+      e->flags &= ~EDGE_EXECUTABLE;\n       e->flags |= EDGE_IGNORE;\n     }\n \n@@ -3822,6 +3825,12 @@ simplify_using_ranges::cleanup_edges_and_switches (void)\n   edge e;\n   switch_update *su;\n \n+  /* Clear any edges marked as not executable.  */\n+  if (m_not_executable_flag)\n+    {\n+      FOR_EACH_VEC_ELT (m_flag_set_edges, i, e)\n+\te->flags &= ~m_not_executable_flag;\n+    }\n   /* Remove dead edges from SWITCH_EXPR optimization.  This leaves the\n      CFG in a broken state and requires a cfg_cleanup run.  */\n   FOR_EACH_VEC_ELT (to_remove_edges, i, e)\n@@ -4124,11 +4133,14 @@ simplify_using_ranges::two_valued_val_range_p (tree var, tree *a, tree *b,\n   return false;\n }\n \n-simplify_using_ranges::simplify_using_ranges (range_query *query)\n+simplify_using_ranges::simplify_using_ranges (range_query *query,\n+\t\t\t\t\t      int not_executable_flag)\n   : query (query)\n {\n   to_remove_edges = vNULL;\n   to_update_switch_stmts = vNULL;\n+  m_not_executable_flag = not_executable_flag;\n+  m_flag_set_edges = vNULL;\n }\n \n simplify_using_ranges::~simplify_using_ranges ()"}, {"sha": "821bcb9d58d552a6af4f8a9efb79e70d3aa1bf25", "filename": "gcc/vr-values.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053e1d642104d19d5f9e5fb08a9e7354a0db28f5/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=053e1d642104d19d5f9e5fb08a9e7354a0db28f5", "patch": "@@ -30,9 +30,11 @@ along with GCC; see the file COPYING3.  If not see\n class simplify_using_ranges\n {\n public:\n-  simplify_using_ranges (class range_query *query = NULL);\n+  simplify_using_ranges (range_query *query = NULL,\n+\t\t\t int not_executable_flag = 0);\n   ~simplify_using_ranges ();\n-  void set_range_query (class range_query *q) { query = q; }\n+  void set_range_query (class range_query *q, int not_executable_flag = 0)\n+      { query = q; m_not_executable_flag = not_executable_flag; }\n \n   bool simplify (gimple_stmt_iterator *);\n \n@@ -82,6 +84,8 @@ class simplify_using_ranges\n   vec<edge> to_remove_edges;\n   vec<switch_update> to_update_switch_stmts;\n   class range_query *query;\n+  int m_not_executable_flag;   // Non zero if not_executable flag exists.\n+  vec<edge> m_flag_set_edges;  // List of edges with flag to be cleared.\n };\n \n /* The VR_VALUES class holds the current view of range information"}]}