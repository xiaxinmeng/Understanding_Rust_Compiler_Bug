{"sha": "630e77b6562e834c9f49124bd39117654dfa3259", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMwZTc3YjY1NjJlODM0YzlmNDkxMjRiZDM5MTE3NjU0ZGZhMzI1OQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-07-11T23:23:51Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-07-11T23:23:51Z"}, "message": "Initial revision\n\nFrom-SVN: r7731", "tree": {"sha": "242fe03358b5faaaf36836f96da2d50b6ab3f57f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/242fe03358b5faaaf36836f96da2d50b6ab3f57f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/630e77b6562e834c9f49124bd39117654dfa3259", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630e77b6562e834c9f49124bd39117654dfa3259", "html_url": "https://github.com/Rust-GCC/gccrs/commit/630e77b6562e834c9f49124bd39117654dfa3259", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630e77b6562e834c9f49124bd39117654dfa3259/comments", "author": null, "committer": null, "parents": [{"sha": "b4d2cd972daef23a952fa516b9ba02e888d63d98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4d2cd972daef23a952fa516b9ba02e888d63d98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4d2cd972daef23a952fa516b9ba02e888d63d98"}], "stats": {"total": 3005, "additions": 3005, "deletions": 0}, "files": [{"sha": "67cf864a8b85b86926029fe518b9f68959c72c0b", "filename": "gcc/config/1750a/1750a.c", "status": "added", "additions": 530, "deletions": 0, "changes": 530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630e77b6562e834c9f49124bd39117654dfa3259/gcc%2Fconfig%2F1750a%2F1750a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630e77b6562e834c9f49124bd39117654dfa3259/gcc%2Fconfig%2F1750a%2F1750a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.c?ref=630e77b6562e834c9f49124bd39117654dfa3259", "patch": "@@ -0,0 +1,530 @@\n+/* Subroutines for insn-output.c for MIL-STD-1750A.\n+   Copyright (C) 1994 Free Software Foundation, Inc.\n+   Contributed by O.M.Kellogg, Deutsche Aerospace (okellogg@salyko.cube.net).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef FILE\n+#include <stdio.h>\n+#endif\n+\n+#define __datalbl\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#define HAVE_cc0\n+#include \"conditions.h\"\n+#include \"real.h\"\n+\n+struct datalabel_array datalbl[DATALBL_ARRSIZ];\n+int datalbl_ndx = -1;\n+struct jumplabel_array jmplbl[JMPLBL_ARRSIZ];\n+int jmplbl_ndx = -1;\n+int label_pending = 0, program_counter = 0;\n+enum section  current_section=NREL;\n+char *sectname[4] = { \"NREL\",\"IREL\",\"KREL\",\"SREL\" };\n+\n+int notice_update_cc(exp)\n+  rtx exp;\n+{\n+  if (GET_CODE (exp) == SET)\n+    {\n+      enum rtx_code src_code = GET_CODE (SET_SRC (exp));\n+      /* Jumps do not alter the cc's.  */\n+      if (SET_DEST (exp) == pc_rtx)\n+\treturn;\n+      /* Moving register into memory doesn't alter the cc's.\n+\t It may invalidate the RTX's which we remember the cc's came from.  */\n+      if (GET_CODE (SET_DEST (exp)) == MEM)\n+\t{\n+\t  if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM)\n+\t    cc_status.value1 = 0;\n+\t  if (cc_status.value2 && GET_CODE (cc_status.value2) == MEM)\n+\t    cc_status.value2 = 0;\n+\t  return;\n+\t}\n+      /* Function calls clobber the cc's.  */\n+      else if (src_code == CALL)\n+\t{\n+\t  CC_STATUS_INIT;\n+\t  return;\n+\t}\n+      /* Emulated longword bit-ops leave cc's incorrect */\n+      else if (GET_MODE (SET_DEST (exp)) == HImode ?\n+               src_code == AND || src_code == IOR ||\n+               src_code == XOR || src_code == NOT : 0)\n+\t{\n+\t  CC_STATUS_INIT;\n+\t  return;\n+\t}\n+      /* Tests and compares set the cc's in predictable ways.  */\n+      else if (SET_DEST (exp) == cc0_rtx)\n+\t{\n+\t  CC_STATUS_INIT;\n+\t  cc_status.value1 = SET_SRC (exp);\n+\t  return;\n+\t}\n+      /* Anything that lands in a reg will set cc_status. */\n+      else if (REG_P (SET_DEST (exp)))\n+\t{\n+          cc_status.flags = CC_NO_OVERFLOW;\n+\t  cc_status.value1 = SET_SRC (exp);\n+\t  cc_status.value2 = SET_DEST (exp);\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  CC_STATUS_INIT;\n+\t}\n+    }\n+  else if (GET_CODE (exp) == PARALLEL\n+\t   && GET_CODE (XVECEXP (exp, 0, 0)) == SET)\n+    {\n+      if (SET_DEST (XVECEXP (exp, 0, 0)) == pc_rtx)\n+\treturn;\n+      if (SET_DEST (XVECEXP (exp, 0, 0)) == cc0_rtx)\n+\t{\n+\t  CC_STATUS_INIT;\n+\t  cc_status.value1 = SET_SRC (XVECEXP (exp, 0, 0));\n+\t  return;\n+\t}\n+      CC_STATUS_INIT;\n+    }\n+  else\n+    {\n+      CC_STATUS_INIT;\n+    }\n+}\n+\n+\n+rtx function_arg(cum,mode,type,named)\n+  int cum;\n+  enum machine_mode mode;\n+  tree type;\n+  int named;\n+{\n+  int size;\n+  rtx result;\n+\n+  if (MUST_PASS_IN_STACK(mode,type))\n+    return (rtx) 0;\n+  if (mode == BLKmode)\n+    size = int_size_in_bytes(type);\n+  else\n+    size = GET_MODE_SIZE (mode);\n+  if (cum + size < 12) \n+    return gen_rtx(REG, mode, cum);\n+  else\n+    return (rtx) 0;\n+}\n+\n+\n+char *tekasm_float(exp_char,value)\n+  char exp_char;\n+  double value;\n+{\n+  extern char *strpbrk();\n+  int found_letter = 0;\n+  char *p;\n+  static char fbuf[20];\n+    \n+  sprintf(fbuf,\"%g\",value);\n+  if ((p = strpbrk(fbuf,\"Ee\")) == NULL)\n+    sprintf(fbuf+strlen(fbuf),\"%c0\",exp_char);\n+  else\n+    *p = exp_char;\n+  return fbuf;\n+}\n+\n+char *asm_float_syntax(rtx x)\n+{\n+  if (GET_MODE(x) == HFmode)\n+    {\n+      union { double d; int i[2]; } du;\n+      union { float f; int i; } su;\n+      du.i[0] = CONST_DOUBLE_LOW(x);\n+      du.i[1] = CONST_DOUBLE_HIGH(x);\n+      su.f = (float) du.d;\n+      return tekasm_float('E',su.f);\n+    }\n+  else\n+    {\n+      union { double d; int i[2]; } du;\n+      du.i[0] = CONST_DOUBLE_LOW(x);\n+      du.i[1] = CONST_DOUBLE_HIGH(x);\n+      return tekasm_float('D',du.d);\n+    }\n+}\n+\n+char *float_label(char code,char *fltstr)\n+{\n+    int i=1;\n+    static char label[32];\n+    \n+    label[0] = code;\n+    while (*fltstr)\n+    {\n+\tlabel[i] = (*fltstr == '+') ? 'p' :\n+\t\t   (*fltstr == '-') ? 'm' : *fltstr;\n+\ti++;\n+\tfltstr++;\n+    }\n+    if (i > 11)\n+\ti = 11;\n+    label[i] = '\\0';\n+    return label;\n+}\n+\n+\n+char *movcnt_regno_adjust(rtx *op)\n+{\n+  static char outstr[40];\n+  int cntreg = REGNO(op[2]), cntreg_1750 = REGNO(op[0]) + 1;\n+  int dstreg = REGNO(op[0]), srcreg = REGNO(op[1]);\n+\n+  if (cntreg == cntreg_1750)\n+    sprintf(outstr,\"MOV    R%%0,R%%1\");\n+  else if (dstreg+1 == srcreg && srcreg == cntreg+2)\n+    sprintf(outstr,\"XWR    R%d,R%d\\n\\tMOV    R%%0,R%%1\",cntreg,dstreg);\n+  else if (dstreg+1 == srcreg && srcreg < cntreg)\n+    sprintf(outstr,\"XWR    R%d,R%d\\n\\tMOV    R%%0,R%%1\",srcreg,cntreg);\n+  else if (srcreg+1 == cntreg && dstreg > cntreg)\n+    sprintf(outstr,\"XWR    R%d,R%d\\n\\tMOV    R%%0,R%%1\",srcreg,dstreg);\n+  else\n+    sprintf(outstr,\"XWR    R%d,R%d\\n\\tMOV    R%%0,%%1\\n\\tXWR     R%d,R%d\",\n+\t\t   cntreg,cntreg_1750,cntreg_1750,cntreg);\n+  return outstr;\n+}\n+\n+char *mod_regno_adjust(char *instr,rtx *op)\n+{\n+  static char outstr[40];\n+  char *r = (!strncmp(instr,\"DVR\",3) ? \"R\" : \"\");\n+  int modregno_gcc = REGNO(op[3]), modregno_1750 = REGNO(op[0]) + 1;\n+\n+  if (modregno_gcc == modregno_1750)\n+    sprintf(outstr,\"%s   R%%0,%s%%2\",instr,r);\n+  else\n+    sprintf(outstr,\"LR     R%d,R%d\\n\\t%s   R%%0,%s%%2\\n\\tXWR     R%d,R%d\",\n+\t    modregno_gcc,modregno_1750,instr,r,modregno_1750,modregno_gcc);\n+  return outstr;\n+}\n+\n+\n+/* Auxiliary to `nonindirect_operand':\n+   Check if op is a valid memory operand for 1750A arith./logic (non-move)\n+   instructions. */\n+int memop_valid(register rtx op)\n+{\n+  if (GET_MODE(op) != Pmode && GET_MODE(op) != VOIDmode)\n+    return 0;\n+  switch (GET_CODE(op))\n+    {\n+      case MEM:\n+      case MINUS:\n+      case MULT:\n+      case DIV:\n+\treturn 0;\n+      case PLUS:\n+\tif (! memop_valid(XEXP(op,0)))\n+\t    return 0;\n+\treturn memop_valid(XEXP(op,1));\n+      case REG:\n+\tif (REGNO(op) > 0)\n+\t    return 1;\n+\treturn 0;\n+      case CONST:\n+      case CONST_INT:\n+      case SYMBOL_REF:\n+      case SUBREG:\n+\treturn 1;\n+      default:\n+\tprintf(\"memop_valid: code=%d\\n\",(int) GET_CODE(op));\n+\treturn 1;\n+    }\n+}\n+\n+/* extra predicate for recog: */\n+int nonindirect_operand(register rtx op, enum machine_mode mode)\n+{\n+  int retval;\n+\n+  switch (GET_CODE(op))\n+    {\n+      case MEM:\n+\tretval = memop_valid(XEXP(op,0));\n+\treturn retval;\n+      case REG:\n+\treturn 1;\n+      default:\n+\tif (! CONSTANT_P(op))\n+\t    return 0;\n+    }\n+  return 1;\n+}\n+\n+/* predicate for the STC instruction: */\n+int small_nonneg_const(register rtx op, enum machine_mode mode)\n+{\n+  if (GET_CODE(op) == CONST_INT && INTVAL(op) >= 0 && INTVAL(op) <= 15)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Decide whether to output a conditional jump as a \"Jump Conditional\"\n+   or as a \"Branch Conditional\": */\n+\n+int find_jmplbl(int labelnum)\n+{\n+  int i, found = 0;\n+\n+  for (i = 0; i <= jmplbl_ndx; i++)\n+    if (labelnum == jmplbl[i].num)\n+      {\n+\tfound = 1;\n+\tbreak;\n+      }\n+  if (found)\n+    return i;\n+  return -1;\n+}\n+\n+char *branch_or_jump(char *condition, int targetlabel_number)\n+{\n+  static char buf[30];\n+  int index;\n+\n+  if ((index = find_jmplbl(targetlabel_number)) >= 0)\n+    if (program_counter - jmplbl[index].pc < 128)\n+      {\n+\tsprintf(buf,\"B%s    %%l0\",condition);\n+\treturn buf;\n+      }\n+  sprintf(buf,\"JC     %s,%%l0\",condition);\n+  return buf;\n+}\n+\n+\n+\n+/* The PRINT_OPERAND and PRINT_OPERAND_ADDRESS macros have been \n+   made functions: */\n+\n+print_operand(file, x, code)\n+  FILE *file;\n+  rtx x;\n+  enum rtx_code code;\n+{ \n+  switch (GET_CODE(x))\n+    {\n+      case REG:\n+        fprintf (file, \"%d\",REGNO (x));\n+        break;\n+      case SYMBOL_REF:\n+        fprintf(file,\"%s\",XSTR(x,0));\n+        break;\n+      case LABEL_REF:\n+      case CONST:\n+      case MEM:\n+        output_address(XEXP(x,0));\n+        break;\n+      case CONST_DOUBLE:\n+        if (code == 'D' || code == 'E')\t/* KREL output hack: */\n+          {\t\t/* make a label out of a floating-point number. */\n+            char *fltstr = (char *)asm_float_syntax(x);\n+            int i, found = 0;\n+            for (i = 0; i <= datalbl_ndx; i++)\n+\t      if (strcmp(fltstr,datalbl[i].value) == 0) { found = 1; break; }\n+            if (! found)\n+\t      {\n+\t        strcpy(datalbl[i = ++datalbl_ndx].value,fltstr);\n+                strcpy(datalbl[i].name,(char *)float_label(code,fltstr));\n+\t        datalbl[i].size = (code=='D') ? 3 : 2;\n+\t        check_section(KREL);\n+\t        fprintf(file,\"K%s \\tDATAF %s ;p_o\\n\", datalbl[i].name,fltstr);\n+\t        check_section(NREL);\n+              }\n+          }\n+\telse if (code == 'F')\n+\t  {\n+            char *fltstr = (char *)asm_float_syntax(x);\n+            int i, found = 0;\n+            for (i = 0; i <= datalbl_ndx; i++)\n+\t      if (strcmp(fltstr,datalbl[i].value) == 0)\n+\t\t{\n+\t\t  found = 1;\n+\t\t  break;\n+\t\t}\n+            if (! found)\n+\t      {\n+\t\tprintf(\"Aborting: 'F' float label not found in datalbl[].\\n\");\n+\t \tabort();\n+\t      }\n+\t    fprintf(file,\"%s ;P_O 'F'\",datalbl[i].name);\n+          }\n+\telse\n+\t  fprintf(file,\"%s  ;P_O cst_dbl\",(char *)asm_float_syntax(x));\n+\tbreak;\n+      case CONST_INT:\n+\tif (code == 'J')\n+\t  fprintf (file, \"%d\",-INTVAL(x));\n+\telse if (INTVAL(x) > 0x7FFF)\n+\t  fprintf (file, \"%d  ; range correction (val>0x7FFF) applied\",\n+\t \t\t INTVAL(x) - 0x10000);\n+\telse\n+\t  fprintf (file, \"%d\", INTVAL(x));\n+\tbreak;\n+      case CODE_LABEL:\n+\tfprintf (file, \"L%d\", XINT(x,3));\n+\tbreak;\n+      case CALL:\n+\tfprintf(file,\"CALL nargs=%d, func is either '%s' or '%s'\",\n+                XEXP(x,1),XSTR(XEXP(XEXP(x,0),1),0),XSTR(XEXP(x,0),1));\n+\tbreak;\n+      case PLUS:\n+        {\n+\t  rtx op0 = XEXP(x,0), op1 = XEXP(x,1);\n+\t  int op0code=GET_CODE(op0), op1code=GET_CODE(op1);\n+          if (op1code == CONST_INT)\n+            switch (op0code)\n+\t      {\n+\t\tcase REG:\n+\t\t  fprintf(file,\"%d,R%d  ; p_o_PLUS for REG and CONST\",\n+\t\t\tINTVAL(op1),REGNO(op0));\n+\t\t  break;\n+\t\tcase SYMBOL_REF:\n+\t\t  fprintf(file,\"%d+%s\",INTVAL(op1),XSTR(op0,0));\n+\t\t  break;\n+\t\tcase MEM:\n+\t\t  fprintf(file,\"%d,[mem:\",INTVAL(op1));\n+\t\t  output_address(XEXP(op0,0));\n+\t\t  fprintf(file,\"] ;P_O plus\");\n+\t\t  break;\n+\t\tdefault:\n+\t\t  fprintf(file,\"p_o_PLUS UFO, code=%d, with CONST=%d\",\n+\t\t\t\t(int)op0code,INTVAL(op1));\n+\t      }\n+\t  else if (op1code == SYMBOL_REF && op0code == REG)\n+\t    fprintf(file,\"%s,R%d  ; P_O: (plus reg sym)\",\n+\t\t\tXSTR(op1,0),REGNO(op0));\n+          else\n+            fprintf(file,\"p_o_+: op0code=%d, op1code=%d\",op0code,op1code);\n+        }\n+\tbreak;\n+      default:\n+\tfprintf (file, \"p_o_UFO code=%d\", GET_CODE(x));\n+    }\n+}\n+\n+print_operand_address(file, addr)\n+  FILE *file;\n+  rtx addr;\n+{\n+  switch (GET_CODE (addr))\n+    {\n+      case REG:\n+\tfprintf (file, \"0,R%d ; P_O_A\", REGNO (addr));\n+\tbreak;\n+      case PLUS:\n+\t{\n+\t  register rtx x = XEXP(addr,0), y = XEXP(addr,1);\n+\t  switch (GET_CODE(x))\n+\t    {\n+\t      case REG:\n+                switch (GET_CODE(y))\n+\t\t  {\n+\t\t    case CONST:\n+\t\t      output_address(XEXP(y,0));\n+\t\t      fprintf(file, \",R%d ;P_O_A reg + const expr\",REGNO(x));\n+\t\t      break;\n+\t\t    case CONST_INT:\n+\t\t      fprintf(file,\"%d,R%d  ; P_O_A reg + const_int\",\n+\t\t\t\tINTVAL(y),REGNO(x));\n+\t\t      break;\n+\t\t    case SYMBOL_REF:\n+\t\t      fprintf(file,\"%s,R%d  ; P_O_A reg + sym\",\n+\t\t\t\tXSTR(y,0),REGNO(x));\n+\t\t      break;\n+\t\t    default:\n+\t\t      fprintf(file, \"[P_O_A reg%d+UFO code=%d]\",\n+\t\t\t        REGNO(x),GET_CODE(y));\n+\t \t  }\n+\t\tbreak;\n+\t      case LABEL_REF:\n+\t      case SYMBOL_REF:\n+\t\tswitch (GET_CODE(y))\n+\t\t  {\n+\t\t    case CONST_INT:\n+\t \t      fprintf (file,\"%d+%s\",INTVAL(y),XSTR(x,0));\n+\t \t      break;\n+\t\t    case REG:\n+\t\t      fprintf (file,\"%s,R%d ;P_O_A sym + reg\",\n+\t\t\t\t XSTR(x,0),REGNO(y));\n+\t\t      break;\n+\t\t    default:\n+\t\t      fprintf(file, \"P_O_A sym/lab+UFO[sym=%s,code(y)=%d]\",\n+\t\t\t\t XSTR(x,0),GET_CODE(y));\n+\t\t  }\n+\t \tbreak;\n+\t      case CONST:\n+\t        output_address(XEXP(x,0));\n+\t        if (GET_CODE(y) == REG)\n+\t\t  fprintf(file, \",R%d ;P_O_A const + reg\",REGNO(x));\n+\t        else\n+\t\t  fprintf(file,\"P_O_A const+UFO code(y)=%d]\",GET_CODE(y));\n+\t        break;\n+\t      case MEM:\n+\t\toutput_address(y);\n+\t\tfprintf(file, \",[mem:\");\n+\t\toutput_address(XEXP(x,0));\n+\t\tfprintf(file, \"] ;P_O_A plus\");\n+\t\tbreak;\n+\t      default:\n+\t\tfprintf(file, \"P_O_A plus op1_UFO[code1=%d,code2=%d]\",\n+\t\t\tGET_CODE(x),GET_CODE(y));\n+\t    }\n+\t}\n+\tbreak;\n+      case CONST_INT:\n+\tif (INTVAL(addr) < 0x10000 && INTVAL(addr) >= -0x10000)\n+\t  fprintf (file, \"%d ; p_o_a const addr?!\", INTVAL(addr));\n+\telse\n+\t  {\n+\t    fprintf(file,\"[p_o_a=ILLEGAL_CONST]\");\n+\t    output_addr_const (file, addr);\n+\t  }\n+\tbreak;\n+      case LABEL_REF:\n+      case SYMBOL_REF:\n+\tfprintf(file,\"%s\",XSTR(addr,0));\n+\tbreak;\n+      case MEM:\n+\tfprintf(file,\"[memUFO:\");\n+\toutput_address(XEXP(addr,0));\n+\tfprintf(file,\"]\");\n+\tbreak;\n+      case CONST:\n+\toutput_address(XEXP(addr,0));\n+\tfprintf(file,\" ;P_O_A const\");\n+\tbreak;\n+      default:\n+\tfprintf(file,\" p_o_a UFO, code=%d val=0x%x\",\n+\t\t\t(int) GET_CODE(addr),INTVAL(addr));\n+\tbreak;\n+    }\n+}\n+"}, {"sha": "b07edaf17c952d85ebf2798d2acdf4adf807657d", "filename": "gcc/config/1750a/1750a.h", "status": "added", "additions": 1234, "deletions": 0, "changes": 1234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630e77b6562e834c9f49124bd39117654dfa3259/gcc%2Fconfig%2F1750a%2F1750a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630e77b6562e834c9f49124bd39117654dfa3259/gcc%2Fconfig%2F1750a%2F1750a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.h?ref=630e77b6562e834c9f49124bd39117654dfa3259", "patch": "@@ -0,0 +1,1234 @@\n+/* Definitions of target machine for GNU compiler, MIL-STD-1750A version.\n+   Copyright (C) 1994 Free Software Foundation, Inc.\n+   Contributed by O.M.Kellogg, Deutsche Aerospace (okellogg@salyko.cube.net).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+/* See tm-sun3.h, tm-sun2.h, tm-isi68.h for different CPP_PREDEFINES.  */\n+#define CPP_PREDEFINES \"\"\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#ifdef IEEE\n+#define TARGET_VERSION fprintf (stderr, \" (1750A, IEEE syntax)\");\n+#else\n+#define TARGET_VERSION fprintf (stderr, \" (MIL-STD-1750A)\");\n+#endif\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+#define TARGET_SWITCHES  \\\n+  { {\"vaxc-alignment\", 2}, \\\n+    { \"\", TARGET_DEFAULT}}\n+\n+/* Default target_flags if no switches specified.  */\n+\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT 1\n+#endif\n+\n+/*****************************************************************************/\n+\n+/* SPECIAL ADDITION FOR MIL-STD-1750A     by O.M.Kellogg, 15-Apr-1993 */\n+/* See file aux-output.c for the actual data instances. */\n+struct datalabel_array {\n+    char name[14];\n+    char value[14];\n+    int size;\n+};\n+struct jumplabel_array {\n+    int pc;\n+    int num;\n+};\n+enum section { NREL, IREL, KREL, SREL };\n+#define DATALBL_ARRSIZ 256\n+#define JMPLBL_ARRSIZ  256\n+#ifndef __datalbl\n+extern struct datalabel_array datalbl[];\n+extern struct jumplabel_array jmplbl[];\n+extern int datalbl_ndx, jmplbl_ndx, label_pending, program_counter;\n+extern enum section current_section;\n+extern char *sectname[4];\n+#endif\n+/*--------------------------------------------------------------------*/\n+\n+/* target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+   Though 1750 actually counts bits in big-endian fashion, the sign bit\n+   is still the most significant bit, which is leftmost. Therefore leaving\n+   this little-endian. Adjust short before assembler output when needed:\n+   e.g. in QImode, a GCC bit n is a 1750 bit (15-n). */\n+#define BITS_BIG_ENDIAN 0 \n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* For 1750 we can decide arbitrarily\n+   since there are no machine instructions for them.  */\n+#define BYTES_BIG_ENDIAN 0\n+\n+/* Define this if most significant word of a multiword value is lowest\n+   numbered.\n+   True for 1750. */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* number of bits in an addressable storage unit */\n+#define BITS_PER_UNIT        16\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD        16\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD       1\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE         16\n+\n+#define PTRDIFF_TYPE        \"int\"\n+\n+/* Type to use for `size_t'. If undefined, uses `long unsigned int'. */\n+#define SIZE_TYPE           \"int\"\n+\n+/* 1750a preliminary\n+   #define TARGET_FLOAT_FORMAT UNKNOWN_FLOAT_FORMAT\n+*/\n+\n+/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n+#define POINTER_BOUNDARY     16\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+/* 1750: should have had to make this 32 when BITS_PER_WORD is 32. */\n+#define PARM_BOUNDARY        16\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY       16\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY    16\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 16\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT    16\n+\n+/* Define this to 1 if move instructions will actually fail to work\n+   when given unaligned data. */\n+#define STRICT_ALIGNMENT 0\n+\n+/* Define number of bits in most basic integer type.\n+   (If undefined, default is BITS_PER_WORD).\n+   #define INT_TYPE_SIZE  16  */\n+\n+/* Define number of bits in short integer type.\n+   (If undefined, default is half of BITS_PER_WORD). */\n+#define SHORT_TYPE_SIZE 16\n+\n+/* Define number of bits in long integer type.\n+   (If undefined, default is BITS_PER_WORD). */\n+#define LONG_TYPE_SIZE  32\n+\n+/* Define number of bits in long long integer type.\n+   (If undefined, default is twice BITS_PER_WORD). */\n+/* 1750 PRELIMINARY : no processor support for `long long', therefore\n+        need to check out the long-long opencodings ! */\n+#define LONG_LONG_TYPE_SIZE  64\n+\n+/* Define number of bits in char type.\n+   (If undefined, default is one fourth of BITS_PER_WORD). */\n+#define CHAR_TYPE_SIZE  16\n+\n+/* Define number of bits in float type.\n+   (If undefined, default is BITS_PER_WORD). */\n+#define FLOAT_TYPE_SIZE  32\n+\n+/* Define number of bits in double type.\n+   (If undefined, default is twice BITS_PER_WORD). */\n+#define DOUBLE_TYPE_SIZE  48\n+\n+/*****************************************************************************/\n+\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers. */\n+#define FIRST_PSEUDO_REGISTER 16\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+   R15 is the 1750A stack pointer. R14 would be the frame \n+   pointer, but we'd like to try avoid using it if possible. */\n+\n+#define FIXED_REGISTERS  \\\n+ { 0, 0, 0, 0, 0, 0, 0, 0, \\\n+   0, 0, 0, 0, 0, 0, 0, 1 }\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.\n+   1750: return value in R0 foll. (depending on size of retval).\n+   Should be possible to refine this (how many regs are actually used) */\n+\n+#define CALL_USED_REGISTERS \\\n+ { 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1 }\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+   All 1750 registers are one word long. */\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output. */\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t1\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* 1750A pc isn't overloaded on a register.  */\n+/* #define PC_REGNUM  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 15\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 14\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c. */\n+#define FRAME_POINTER_REQUIRED 0\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 14\n+\n+/* Define this if successive args to a function occupy decreasing addresses\n+   on the stack. \n+   #define ARGS_GROW_DOWNWARD\n+*/\n+\n+/* Register in which static-chain is passed to a function. */\n+#define STATIC_CHAIN_REGNUM 13\n+\n+/* Register in which address to store a structure value\n+   is passed to a function. */\n+#define STRUCT_VALUE_REGNUM 12\n+\n+/* Define this to be 1 if all structure return values must be in memory. */\n+#define DEFAUT_PCC_STRUCT_RETURN 0\n+\n+/*****************************************************************************/\n+\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+/* 1750 note: The names (BASE_REGS/INDEX_REGS) are used in their *gcc sense*\n+   (i.e. *opposite* to the MIL-STD-1750A defined meanings). This means that\n+   R1..R15 are called \"base\" regs and R12..R15 are \"index\" regs.\n+   Index reg mode (in the gcc sense) is not yet implemented (these are the\n+   1750 \"Base with Index Reg\" instructions, LBX etc. See 1750.md)\n+\n+   Here's an example to drive this point home: in \"LBX B12,R5\"\n+   B12 shall be called the \"index\" reg and R5 shall be the \"base\" reg.\n+   This naming inversion is due to the GCC defined capabilities of\n+   \"Base\" vs. \"Index\" regs. */\n+\n+enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Since GENERAL_REGS is the same class as ALL_REGS,\n+   don't give it a different class number; just make it an alias. */\n+#define GENERAL_REGS ALL_REGS\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+ { \"NO_REGS\", \"INDEX_REGS\", \"BASE_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.\n+   1750 \"index\" (remember, in the *GCC* sense!) regs are R12 through R15. \n+   The only 1750 register not usable as BASE_REG is R0. */\n+\n+#define REG_CLASS_CONTENTS  {0, 0xf000, 0xfffe, 0xffff}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+#define REGNO_REG_CLASS(REGNO)\t\\\n+ ((REGNO) >= 12 ? INDEX_REGS : (REGNO) >  0 ? BASE_REGS : ALL_REGS)\n+\n+/* The class value for index registers, and the one for base regs. */\n+\n+#define BASE_REG_CLASS  BASE_REGS\n+#define INDEX_REG_CLASS INDEX_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.\n+   For the 1750, we have 'b' for gcc Base regs and 'x' for gcc Index regs. */\n+\n+#define REG_CLASS_FROM_LETTER(C) ((C) == 'b' ? BASE_REGS : \\\n+\t\t\t\t  (C) == 'x' ? INDEX_REGS : NO_REGS)\n+\n+/* The letters I,J,K,.. to P in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   For the 1750A, \n+   `I' is used for ISP mode instructions,\n+   `J' is used for ISN mode instructions,\n+   `K' is used for the STC instruction's constant range,\n+   `L' is used for unsigned 8-bit address displacements in instructions\n+       of addressing mode \"Base Relative\",\n+   `M' is for IM mode instructions et al.,\n+   `O' is a synonym for (const_int 0). */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n+  ((C) == 'I' ? (VALUE) > 0 && (VALUE) <=  16 :\t\t\t\\\n+   (C) == 'J' ? (VALUE) < 0 && (VALUE) >= -16 :\t\t\t\\\n+   (C) == 'K' ? (VALUE) >= 0 && (VALUE) <= 15 :\t\t\t\\\n+   (C) == 'L' ? (VALUE) >= 0 && (VALUE) <= 0xFF :\t\t\\\n+   (C) == 'M' ? (VALUE) >= -0x8000 && (VALUE) <= 0x7FFF : \t\\\n+   (C) == 'O' ? (VALUE) == 0 :\t\t\t\t0)\n+\n+/* Similar, but for floating constants, and defining letter 'G'.\n+   Here VALUE is the CONST_DOUBLE rtx itself.\n+   1750 longfloat constant 0.0 is worth recognizing 'cause it's got \n+   all bits zero. */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'G' && (VALUE) == CONST0_RTX(HFmode))\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.\n+   For the 1750A, we force an immediate CONST_DOUBLE value to memory. */\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)  \\\n+\t\t(GET_CODE(X) == CONST_DOUBLE ? NO_REGS : CLASS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.\n+   On the 1750A, this is the size of MODE in words,\n+   since class doesn't make any difference. */\n+#define CLASS_MAX_NREGS(CLASS,MODE)  GET_MODE_SIZE(MODE)\n+\n+/*****************************************************************************/\n+\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD 1\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   goes at a more negative offset in the frame. \n+   #define FRAME_GROWS_DOWNWARD\n+*/\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.\n+*/\n+#define STARTING_FRAME_OFFSET 1\n+\n+/* This is the default anyway:\n+   #define DYNAMIC_CHAIN_ADDRESS(FRAMEADDR) FRAMEADDR\n+*/\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.\n+   1750 note: what GCC calls a \"byte\" is really a 16-bit word,\n+   because BITS_PER_UNIT is 16. */\n+\n+#define PUSH_ROUNDING(BYTES) (BYTES)\n+\n+/* Define this macro if functions should assume that stack space has\n+   been allocated for arguments even when their values are passed in\n+   registers.\n+   Size, in bytes, of the area reserved for arguments passed in\n+   registers for the function represented by FNDECL. \n+   #define REG_PARM_STACK_SPACE(FNDECL) 14 */\n+\n+/* Define this if it is the responsibility of the caller to allocate\n+   the area reserved for arguments passed in registers. \n+   #define OUTGOING_REG_PARM_STACK_SPACE */\n+\n+/* Offset of first parameter from the argument pointer register value.\n+   1750 note:\n+   Parameters appear in reversed order on the frame (so when they are\n+   popped, they come off in the normal left-to-right order.)\n+   Computed as follows:\n+   one word for the caller's (PC+1) (i.e. the return address)\n+   plus total size of called function's \"auto\" variables\n+   plus one word for the caller's frame pointer (i.e. the old FP) */\n+\n+#define FIRST_PARM_OFFSET(FNDECL) \\\n+   (1 + get_frame_size() + 1)\n+\n+/* Value is 1 if returning from a function call automatically\n+   pops the arguments described by the number-of-args field in the call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+*/\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) 0\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0. */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx(REG,TYPE_MODE(VALTYPE),0)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE. */\n+/* 1750 note: no libcalls yet */\n+\n+#define LIBCALL_VALUE(MODE)  printf(\"LIBCALL_VALUE called!\\n\"), \\\n+  gen_rtx(REG,MODE,0)\n+\n+/* 1 if N is a possible register number for a function value. */\n+\n+#define FUNCTION_VALUE_REGNO_P(N)  ((N) == 0)\n+\n+/* 1 if the tree TYPE should be returned in memory instead of in regs. \n+   #define RETURN_IN_MEMORY(TYPE) \\\n+   (int_size_in_bytes(TYPE) > 13)\n+*/\n+\n+/* Define this if PCC uses the nonreentrant convention for returning\n+   structure and union values. \n+   #define PCC_STATIC_STRUCT_RETURN  */\n+\n+/* 1 if N is a possible register number for function argument passing. */\n+\n+#define FUNCTION_ARG_REGNO_P(N)  ((N) < 12)\n+\n+/*****************************************************************************/\n+\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   For 1750A, this is a single integer, which is a number of bytes\n+   of arguments scanned so far.  */\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   For 1750A, the offset starts at 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)   ((CUM) = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)\n+\n+   1750 note: \"int_size_in_bytes()\" returns a unit relative to\n+   BITS_PER_UNIT, so in our case not bytes, but 16-bit words.  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM) += (MODE) == BLKmode ? int_size_in_bytes(TYPE) : GET_MODE_SIZE(MODE))\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+\t(rtx) function_arg(CUM,MODE,TYPE,NAMED)\n+/*\n+ (! MUST_PASS_IN_STACK(MODE,TYPE) &&\t\t\t\t\\\n+  14 >= (CUM) +\t\t\t\t\t\t\t\\\n+  ((MODE)==BLKmode ? int_size_in_bytes(TYPE) : GET_MODE_SIZE (MODE))  \\\n+ ? gen_rtx (REG, MODE, CUM)\t\t\t\t\t\\\n+ : 0)\n+*/\n+\n+/* Define the following macro if function calls on the target machine\n+   do not preserve any registers; in other words, if `CALL_USED_REGISTERS'\n+   has 1 for all registers. This macro enables `-fcaller-saves' by\n+   default. Eventually that option will be nabled by default on all\n+   machines and both the option and this macro will be eliminated. */\n+\n+#define DEFAULT_CALLER_SAVES\n+\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE) {   \\\n+  register int regno, none_used=1;\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  fprintf(FILE, \"; regs used in this function: \");\t\t\\\n+  for (regno = 0; regno < 15; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno]) {\t\t\t\t\\\n+\tfprintf(FILE,\" %s\",reg_names[regno]);\t\t\t\\\n+\tnone_used = 0;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  if (none_used)\t\t\t\t\t\t\\\n+    fprintf(FILE,\" (none)\");\t\t\t\t \t\\\n+  fprintf(FILE,\"\\n\");\t\t\t\t\t \t\\\n+  if (SIZE > 0)\t\t\t\t\t\t\t\\\n+    fprintf(FILE,\"\\t%s   R15,%d  ; reserve local-variable space\\n\",\\\n+\t\t\t (SIZE <= 16 ? \"SISP\" : \"SIM \"),SIZE);\t\\\n+  fprintf(FILE,\"\\tPSHM   R14,R14 ; push old frame\\n\");\t\t\\\n+  fprintf(FILE,\"\\tLR     R14,R15 ; set new frame\\n\");\t\t\\\n+  program_counter = 0; jmplbl_ndx = -1;\t\t\t\t\\\n+}\n+\n+/************* 1750: PROFILER HANDLING NOT YET DONE !!!!!!! *************/\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+  fprintf (FILE, \"; got into FUNCTION_PROFILER with label # %d\\n\", (LABELNO))\n+\n+/* Output assembler code to FILE to initialize this source file's\n+   basic block profiling info, if that has not already been done.  */\n+#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n+  fprintf (FILE, \"; got into FUNCTION_BLOCK_PROFILER with label # %d\\n\",LABELNO)\n+\n+/* Output assembler code to FILE to increment the entry-count for\n+   the BLOCKNO'th basic block in this source file.  */\n+#define BLOCK_PROFILER(FILE, BLOCKNO)\t\\\n+  fprintf (FILE, \"; got into BLOCK_PROFILER with block # %d\\n\",BLOCKNO)\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning. */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE) {\t\t\t\\\n+  if (SIZE > 0)\t\t\t\t\t\t\t\\\n+    fprintf(FILE,\"\\t%s   R14,%d ; free up local-var space\\n\",\t\\\n+\t\t\t (SIZE <= 16 ? \"AISP\" : \"AIM \"),SIZE);\t\\\n+  fprintf(FILE,\"\\tLR     R15,R14 ; set stack to return addr\\n\");\\\n+  fprintf(FILE,\"\\tURS    R15\\n\"); }\n+\n+/* If the memory address ADDR is relative to the frame pointer,\n+   correct it to be relative to the stack pointer instead.\n+   This is for when we don't use a frame pointer.\n+   ADDR should be a variable name. */\n+\n+#define FIX_FRAME_POINTER_ADDRESS(ADDR,DEPTH)  \\\n+   fprintf(asm_out_file,\"FIX_FRAME_POINTER_ADDRESS called, DEPTH=%d\\n\"), \\\n+           DEPTH), abort()\n+\n+/* Store in the variable DEPTH the initial difference between the\n+   frame pointer reg contents and the stack pointer reg contents,\n+   as of the start of the function body.  This depends on the layout\n+   of the fixed parts of the stack frame and on how registers are saved.\n+*/\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) DEPTH = 0\n+\n+/* 1750: not needed 'cause we have INITIAL_FRAME_POINTER_OFFSET.\n+   #define ELIMINABLE_REGS { \\\n+\t{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM },  \\\n+\t{ ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM },  \\\n+\t{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM } }\n+\n+   #define CAN_ELIMINATE(FROM, TO)   1\n+\n+   #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) { OFFSET = 0; }\n+*/\n+\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)  fprintf(FILE,\"TRAMPOLINE_TEMPLATE called\\n\")\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 2\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)  printf(\"INITIALIZE_TRAMPO called\\n\")\n+/* {\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, QImode, plus_constant (TRAMP, 1)), CXT); \\\n+  emit_move_insn (gen_rtx (MEM, QImode, plus_constant (TRAMP, 6)), FNADDR); \\\n+} */\n+\n+\n+/*****************************************************************************/\n+\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* 1750 doesn't have a lot of auto-incr./decr. - just for the stack ptr. */\n+\n+/* #define HAVE_POST_INCREMENT  just for R15 (stack pointer) */\n+/* #define HAVE_POST_DECREMENT */\n+/* #define HAVE_PRE_DECREMENT   just for R15 (stack pointer) */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c. \n+   1750 note: The words BASE and INDEX are used in their GCC senses:\n+   The \"Index Registers\", R12 through R15, can have an address displacement\n+   int the range 0..255 words.\n+   */\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO)  \\\n+ ((REGNO) > 0 && (REGNO) <= 15 ||   \\\n+  reg_renumber[REGNO] > 0 && reg_renumber[REGNO] < 15)\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n+ ((REGNO) >= 12 && (REGNO) <= 15 || \\\n+  reg_renumber[REGNO] >= 12 && reg_renumber[REGNO] <= 15)\n+\n+/* Now macros that check whether X is a register and also,\n+   strictly, whether it is in a specified class.\n+\n+/* 1 if X is an address register  */\n+\n+#define ADDRESS_REG_P(X) (REG_P (X) && REGNO_OK_FOR_BASE_P (REGNO (X)))\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* Recognize any constant value that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X)  CONSTANT_P(X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifdef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) (REGNO (X) >= 12)\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) (REGNO (X) > 0)\n+\n+#endif\n+\n+\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS.\n+\n+   1750 note: Currently we don't implement address expressions that use\n+   GCC \"Index\"-class regs. To be expanded to handle the 1750 \"Base with Index\"\n+   instructions (see also MAX_REGS_PER_ADDRESS and others). */\n+\n+#define GO_IF_BASED_ADDRESS(X, ADDR) {\t\t\t\t\t\\\n+   if ((GET_CODE (X) == REG && REG_OK_FOR_BASE_P(X)))\t\t\t\\\n+     goto ADDR;\t\t\t\t\t\t\t\t\\\n+   if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n+    { register rtx x0 = XEXP(X,0), x1 = XEXP(X,1);\t\t\t\\\n+      if ((REG_P(x0) && REG_OK_FOR_BASE_P(x0) && CONSTANT_ADDRESS_P(x1)) \\\n+       || (REG_P(x1) && REG_OK_FOR_BASE_P(x1) && CONSTANT_ADDRESS_P(x0))) \\\n+     goto ADDR; } }\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) {\t\t\t\\\n+\tif (CONSTANT_ADDRESS_P(X)) goto ADDR;\t\t\t\t\\\n+\tGO_IF_BASED_ADDRESS(X,ADDR) }\n+\n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output. */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+   On the 68000, only predecrement and postincrement address depend thus\n+   (the amount of decrement or increment being the length of the operand).  */\n+/* 1750: not used. */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n+\n+/*****************************************************************************/\n+\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE QImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses. */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+/* (was: \"1750: not counting the MOV instruction\") */\n+#define MOVE_MAX 256\n+\n+/* Define this if zero-extension is slow (more than one real instruction).  */\n+/* #define SLOW_ZERO_EXTEND */\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count. */\n+/* #define SHIFT_COUNT_TRUNCATED 1 */\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+\n+#define STORE_FLAG_VALUE 1\n+\n+/* When a prototype says `char' or `short', really pass an `int'. \n+   1750: for now, `char' is 16 bits wide anyway.\n+   #define PROMOTE_PROTOTYPES */\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode QImode\n+\n+/* A function address in a call instruction\n+   is a 16-bit address (for indexing purposes) */\n+#define FUNCTION_MODE QImode\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+/* 1750 note: haven't paid attention to this yet. */\n+\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    if (INTVAL(RTX) >= -16 && INTVAL(RTX) <= 16) return 1;\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return 5;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return 7;\n+\n+#define ADDRESS_COST(ADDRESS)\t(memop_valid(ADDRESS) ?  3 : 1000)\n+\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  */\n+/* MIL-STD-1750: none -- just has the garden variety C,P,Z,N flags. */\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.\n+   1750: See file out-1750a.c for notice_update_cc().  */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc(EXP)\n+\n+/**********************************************/\n+/* Produce debugging info in the DWARF format \n+   #define DWARF_DEBUGGING_INFO\n+*/\n+\n+/*****************************************************************************/\n+\n+/* Control the assembler format that we output.  */\n+\n+/* Output at beginning of assembler file.  */\n+\n+#define ASM_FILE_START(FILE)   {\t\t\t\t\t\\\n+   char *p, name[40];\t\t\t\t\t\t\t\\\n+   if ((p = (char *)strrchr(main_input_filename,'/')) != NULL ? 1 :\t\\\n+       (p = (char *)strrchr(main_input_filename,']')) != NULL)\t\t\\\n+\tp++;\t\t\t\t\t\t\t\t\\\n+   else\t\t\t\t\t\t\t\t\t\\\n+\tp = main_input_filename;\t\t\t\t\t\\\n+   strcpy(name,p);\t\t\t\t\t\t\t\\\n+   if (p = (char *)strchr(name,'.'))\t\t\t\t\t\\\n+\t*p = '\\0';\t\t\t\t\t\t\t\\\n+   if (strlen(name) > 12)\t\t\t\t\t\t\\\n+\tname[12] = '\\0';   /* TekAs can handle only up to 12 char. */\t\\\n+   fprintf(FILE,\"\\tNAME %s\\n\",name); \t\t\t\t\t\\\n+   fprintf(FILE,\"\\tNOLIST\\n\\tINCLUDE \\\"M1750.INC\\\"\\n\\tLIST\\n\");\t\t\\\n+   fprintf(FILE,\"\\n\\tSECTION SREL\\n\\tSECTION KREL\\n\\tSECTION IREL\\n\");\t\\\n+   fprintf(FILE,\"\\tSECTION NREL\\n\"); }\n+\n+/* Output at end of assembler file.  \n+   For 1750, we copy the data labels accrued in datalbl[] from the Constants \n+   section (KREL) to the Writable-Data section (SREL).     */\n+\n+#define ASM_FILE_END(FILE)\t\\\n+   do {\t\t\t\t\t\t\t\t\t\\\n+      if (datalbl_ndx >= 0) {\t\t\t\t\t\t\\\n+         int i, cum_size=0;\t\t\t\t\t\t\\\n+         fprintf(FILE,\"\\n\\tRESUME SREL\\nINIT_SREL\\n\");\t\t\t\\\n+         for (i = 0; i <= datalbl_ndx; i++) {\t\t\t\t\\\n+            fprintf(FILE,\"%s\\t BLOCK %d\\n\",\t\t\t\t\\\n+                 datalbl[i].name,datalbl[i].size);\t\t\t\\\n+            cum_size += datalbl[i].size;\t\t\t\t\\\n+\t }\t\t\t\t\t\t\t\t\\\n+         fprintf(FILE,\"\\n\\tRESUME IREL\\n\");\t\t\t\t\\\n+         fprintf(FILE,\"\\tLIM  R0,INIT_SREL\\n\");           /* destin. */\t\\\n+         fprintf(FILE,\"\\tLIM  R1,%d\\n\",cum_size);         /* count */\t\\\n+         fprintf(FILE,\"\\tLIM  R2,K%s\\n\",datalbl[0].name); /* source */\t\\\n+         fprintf(FILE,\"\\tMOV  R0,R2\\n\");\t\t\t\t\\\n+         fprintf(FILE,\"\\n\\tRESUME NREL\\n\");\t\t\t\t\\\n+         datalbl_ndx = -1;\t\t\t/* reset stuff */\t\\\n+         for (i = 0; i < DATALBL_ARRSIZ; i++)\t\t\t\t\\\n+            datalbl[i].size = 0;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+      fprintf(FILE,\"\\n\\tEND\\n\");\t\t\t\t\t\\\n+   } while (0)\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"\\n\\tIF 0\\n; by ASM_APP_ON\\n\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"\\n\\tENDIF\\n\"\n+\n+\n+#define EXTRA_SECTIONS  in_readonly_data\n+\n+#define EXTRA_SECTION_FUNCTIONS\t\t\\\n+    void const_section()\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+\tfprintf(asm_out_file,\"\\tRESUME KREL\\n\");\t\\\n+\tcurrent_section = KREL;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+    check_section(enum section sect)\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+        if (current_section != sect) {\t\t\t\\\n+\t    fprintf(asm_out_file,\"\\tRESUME %s\\n\",sectname[(int)sect]); \\\n+\t    current_section = sect;\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+\tswitch (sect) {\t\t\t\t\t\\\n+\t  case NREL:\t\t\t\t\t\\\n+\t    in_section = in_text;\t\t\t\\\n+\t    break;\t\t\t\t\t\\\n+\t  case SREL:\t\t\t\t\t\\\n+\t    in_section = in_data;\t\t\t\\\n+\t    break;\t\t\t\t\t\\\n+\t  case KREL:\t\t\t\t\t\\\n+\t    in_section = in_readonly_data;\t\t\\\n+\t    break;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+    }\n+\n+\t\t\n+/* Function that switches to the read-only data section (optional) */\n+#define READONLY_DATA_SECTION\tconst_section\n+\n+/* Output before program text section */\n+#define TEXT_SECTION_ASM_OP \"\\n\\tRESUME NREL   ; text_section\\n\"\n+\n+/* Output before writable data.  */\n+#define DATA_SECTION_ASM_OP \"\\n\\tRESUME SREL   ; data_section\\n\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+ { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \\\n+   \"8\", \"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\" }\n+\n+/* How to renumber registers for dbx and gdb. */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/******************  Assembler output formatting  **********************/\n+\n+#define ASM_IDENTIFY_GCC(FILE)\n+\n+#define ASM_COMMENT_START  \";\"\n+\n+#define ASM_OUTPUT_FUNNAM(FILE,NAME)\t\\\n+\tfprintf(FILE,\"%s\\n\",NAME)\n+\n+#define ASM_OUTPUT_OPCODE(FILE,PTR)  do {\t\t\\\n+\tprogram_counter += 2;\t\t\t\t\\\n+     } while (0)\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\\\n+\tfprintf(FILE,\"%s\\n\",NAME)\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+/* 1750 note: Labels are prefixed with a 'K'. This is because handling\n+   has been changed for labels to be output in the \"Constants\" section\n+   (named \"KREL\"), and special initialization code takes care of copying\n+   the Const-section data into the writable data section (named \"SREL\").\n+   In the SREL section we therefore have the true label names (i.e.\n+   not prefixed with 'K').  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do {  if (NAME[0] == '.')\t\t\t\t\\\n+\t   fprintf(FILE,\"%s\\n\",NAME);\t\t\t\\\n+\telse {\t\t\t\t\t\t\\\n+\t   if (strlen(NAME) > 11) NAME[11] = '\\0';\t\\\n+\t   check_section(KREL);\t\t\t\t\\\n+\t   fprintf(FILE,\"K%s\\n\",NAME);\t\t\t\\\n+\t   strcpy(datalbl[++datalbl_ndx].name,NAME);\t\\\n+\t   label_pending = 1;\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME) do {\t\t\\\n+\t   check_section(NREL);\t\t\t\t\\\n+\t   fputs (\"\\tGLOBAL \", FILE); assemble_name (FILE, NAME); \\\n+\t   fputs (\"   ; export\\n\", FILE); } while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+\t  fprintf (FILE, \"%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\t\\\n+\tdo {\t\t\t\t\t\t\t\\\n+\t  if (strcmp(PREFIX,\"LC\") == 0) {\t\t\t\\\n+\t     label_pending = 1;\t\t\t\t\t\\\n+\t     sprintf(datalbl[++datalbl_ndx].name,\"LC%d\",NUM);\t\\\n+\t     check_section(KREL);\t\t\t\t\\\n+\t     fprintf(FILE,\"K%s%d\\n\",PREFIX,NUM);\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\t  else if (find_jmplbl(NUM) < 0) {\t\t\t\\\n+\t     jmplbl[++jmplbl_ndx].num = NUM;\t\t\t\\\n+\t     jmplbl[jmplbl_ndx].pc = program_counter;\t\t\\\n+\t     fprintf(FILE, \"%s%d\\n\", PREFIX, NUM);\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\t} while (0)\n+\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+\t  sprintf (LABEL, \"%s%d\", PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a 1750A `float'\n+   constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE) \t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+      char *tekfltstr = (char *)tekasm_float('E',VALUE);\t\\\n+      if (label_pending)\t\t\t\t\t\\\n+\t label_pending = 0;\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+         strcpy(datalbl[++datalbl_ndx].name,\t\t\t\\\n+\t\t(char *)float_label('E',tekfltstr));\t\t\\\n+      strcpy(datalbl[datalbl_ndx].value,tekfltstr);\t\t\\\n+      datalbl[datalbl_ndx].size = 2;\t\t\t\t\\\n+      fprintf (FILE, \"\\tDATAF %s\\n\",tekfltstr);\t\t\t\\\n+  } while(0)\n+\n+/* This is how to output an assembler line defining a 1750A `double'\n+    constant. */\n+\n+#define ASM_OUTPUT_THREE_QUARTER_FLOAT(FILE,VALUE)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+      char *tekfltstr = (char *)tekasm_float('D',VALUE);\t\\\n+      if (label_pending)\t\t\t\t\t\\\n+\t label_pending = 0;\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+         strcpy(datalbl[++datalbl_ndx].name,\t\t\t\\\n+\t\t(char *)float_label('D',tekfltstr));\t\t\\\n+      strcpy(datalbl[datalbl_ndx].value,tekfltstr);\t\t\\\n+      datalbl[datalbl_ndx].size = 3;\t\t\t\t\\\n+      fprintf(FILE,\"\\tDATAF %s\\n\",tekfltstr);\t\t\t\\\n+  } while (0)\n+\n+/* This is how to output an assembler line defining a string constant.  */\n+\n+#define ASM_OUTPUT_ASCII(FILE, PTR, LEN)  do {\t\t\\\n+\tint i;\t\t\t\t\t\t\t\t\\\n+\tif (! label_pending)\t\t\t\t\t\t\\\n+\t   fprintf(FILE,\";in ASM_OUTPUT_ASCII without label_pending\\n\");\\\n+\telse {\t\t\t\t\t\t\t\t\\\n+\t   label_pending = 0;\t\t\t\t\t\t\\\n+\t   datalbl[datalbl_ndx].size = LEN;\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\tfor (i = 0; i < LEN; i++)\t\t\t\t\t\\\n+\t  if (PTR[i] >= 32 && PTR[i] < 127)\t\t\t\t\\\n+\t    fprintf(FILE,\"\\tDATA   %d\\t; '%c'\\n\",PTR[i],PTR[i]);\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    fprintf(FILE,\"\\tDATA   %d\\t; (ascii)\\n\",PTR[i]);\t\t\\\n+  } while (0)\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  do {\t  \\\n+\tif (! label_pending) \t\t\t\t\t\t\\\n+\t   fprintf(FILE,\";in ASM_OUTPUT_INT without label_pending\\n\");\t\\\n+\telse {\t\t\t\t\t\t\t\t\\\n+\t   label_pending = 0;\t\t\t\t\t\t\\\n+\t   datalbl[datalbl_ndx].size = 1;\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\tfprintf(FILE, \"\\tDATA \"); output_addr_const(FILE,VALUE);\t\\\n+\tfprintf(FILE, \"\\n\"); } while (0)\n+\n+/* This is how to output an assembler line defining a `long int' constant. */\n+\n+#define ASM_OUTPUT_LONG_INT(FILE,VALUE) do {\t  \\\n+\tif (! label_pending)\t\t\t\t\t\t\\\n+\t   fprintf(FILE,\";in ASM_OUTPUT_LONG_INT without label_pending\\n\");\\\n+\telse {\t\t\t\t\t\t\t\t\\\n+\t   label_pending = 0;\t\t\t\t\t\t\\\n+\t   datalbl[datalbl_ndx].size = 2;\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\tfprintf(FILE, \"\\tDATAL \"); output_addr_const(FILE,VALUE);\t\\\n+\tfprintf(FILE, \"\\n\"); } while (0)\n+\n+/* Likewise for `short' and `char' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  ASM_OUTPUT_INT(FILE,VALUE)\n+\n+/* For 1750, we treat char same as word. Tektronix 1750\n+   Assembler does a better (packing) job with strings.  */\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)   ASM_OUTPUT_INT(FILE,VALUE)\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+/* 1750: For the time being, treating this same as word. Tektronix 1750\n+   Assembler does a better (packing) job with strings.  */\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  ASM_OUTPUT_INT(FILE,VALUE)\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tPSHM R%s,R%s\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+\tfprintf (FILE, \"\\tPOPM R%s,R%s\\n\", reg_names[REGNO])\n+\n+/* This is how to output an element of a case-vector that is absolute. */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)   \\\n+\tfprintf (FILE, \"\\tDATA   L%d ;addr_vec_elt\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+\tfprintf (FILE, \"\\tDATA   L%d-L%d ;addr_diff_elt\\n\", VALUE,REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+ fprintf(FILE,\"; in ASM_OUTPUT_ALIGN: pwr_of_2_bytcnt=%d\\n\",LOG)\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)\t\\\n+   fprintf(FILE,\"; in ASM_OUTPUT_SKIP: size=%d\\n\",SIZE)\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  do {\t\\\n+\tcheck_section(NREL);\t\t\t\t\t\\\n+\tfprintf(FILE,\"\\tGLOBAL \"); assemble_name(FILE,NAME);\t\\\n+\tfprintf(FILE,\"   ; common\\n\"); } while (0)\n+\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)  do {\t\t\\\n+\tcheck_section(NREL);\t\t\t\t\t\\\n+\tfprintf(FILE,\"\\tGLOBAL \"); assemble_name(FILE,NAME);\t\\\n+\tfprintf(FILE,\"\\t; external\\n\"); } while (0)\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  do {  \\\n+\tcheck_section(SREL);\t\t\t\t\t\\\n+\tfprintf(FILE,\"%s \\tBLOCK %d  ; local\\n\",NAME,SIZE);\t\\\n+     } while (0)\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL\t007\n+#define TARGET_BS\t010\n+#define TARGET_TAB\t011\n+#define TARGET_NEWLINE\t012\n+#define TARGET_VT\t013\n+#define TARGET_FF\t014\n+#define TARGET_CR\t015\n+\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.\n+   1750 note:  there are three special CODE characters:\n+        'D', 'E': print a reference to a floating point constant (D=double,\n+\t\t  E=single precision) label name\n+\t'F': print a label defining a floating-point constant value\n+\t'J': print the absolute value of a negative INT_CONST\n+\t     (this is used in LISN/CISN/MISN/SISP and others)   */\n+\n+/* 1750A: see file aux-output.c */\n+#define PRINT_OPERAND(FILE, X, CODE)  print_operand(FILE,X,CODE)\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  print_operand_address(FILE,ADDR)\n+"}, {"sha": "95714d361d99bd9d8091719220b79573f7c253d6", "filename": "gcc/config/1750a/1750a.md", "status": "added", "additions": 1241, "deletions": 0, "changes": 1241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630e77b6562e834c9f49124bd39117654dfa3259/gcc%2Fconfig%2F1750a%2F1750a.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630e77b6562e834c9f49124bd39117654dfa3259/gcc%2Fconfig%2F1750a%2F1750a.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.md?ref=630e77b6562e834c9f49124bd39117654dfa3259", "patch": "@@ -0,0 +1,1241 @@\n+;;- Machine description for GNU compiler, MIL-STD-1750A version.\n+;;  Copyright (C) 1994 Free Software Foundation, Inc.\n+;;  Contributed by O.M.Kellogg, Deutsche Aerospace (okellogg@salyko.cube.net).\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 1, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+;;- instruction definitions\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;;- When naming insn's (operand 0 of define_insn) be careful about using\n+;;- names from other targets machine descriptions.\n+\n+;; MIL-STD-1750 specific remarks:\n+;;\n+;; 1) BITS_PER_UNIT = 16\n+;;\n+;; 2) GCC   to    MIL-STD-1750       data type mappings:\n+;;    QImode => single integer (16 bits or 1 reg).\n+;;    HImode => double integer (32 bits or 2 regs).\n+;;    HFmode => single precision float (32 bits or 2 regs).\n+;;    TQFmode => extended precision float (48 bits or 3 regs).\n+;; \n+;; 3) Immediate integer operands Constraints:\n+;;    'I'  1 .. 16\n+;;    'J' -1 ..-16\n+;;    'K'  0 .. 15\n+;;    'L'  0 .. 255\n+;;    'M' -32768 .. 32767\n+;;    'O' => 0  (for optimizations and GCC quirks)\n+;;\n+;; Further notes:\n+;;-  Assembly output ending in \".M\" are macros in file M1750.INC\n+\n+\n+;; stackpush\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"push_operand\" \"=<\")\n+        (match_operand:QI 1 \"general_operand\" \"r\"))]\n+  \"\"\n+  \"PSHM   R%1,R%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"push_operand\" \"=<\")\n+        (match_operand:HI 1 \"general_operand\" \"r\"))]\n+  \"\"\n+  \"*\n+   { \n+        rtx new_operands[2];\n+        new_operands[0] = operands[1];\n+        new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[1])+1);\n+   } \")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HF 0 \"push_operand\" \"=<\")\n+        (match_operand:HF 1 \"general_operand\" \"r\"))]\n+  \"\"\n+  \"*\n+  { \n+        rtx new_operands[2];\n+        new_operands[0] = operands[1];\n+        new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[1])+1);\n+        output_asm_insn(\\\"PSHM   R%0,R%1\\\",new_operands);\n+        return \\\"\\;\\\";\n+   } \")\n+\n+(define_insn \"\"\n+  [(set (match_operand:TQF 0 \"push_operand\" \"=<\")\n+        (match_operand:TQF 1 \"general_operand\" \"r\"))]\n+  \"\"\n+  \"*\n+   { \n+        rtx new_operands[2];\n+        new_operands[0] = operands[1];\n+        new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[1])+2);\n+        output_asm_insn(\\\"PSHM   R%0,R%1\\\",new_operands);\n+        return \\\"\\;\\\";\n+   } \")\n+\n+;; stackpop\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r\")\n+        (match_operand:QI 1 \"push_operand\" \">\"))]\n+  \"\"\n+  \"POPM   R%1,R%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n+        (match_operand:HI 1 \"push_operand\" \">\"))]\n+  \"\"\n+  \"*\n+   { \n+        rtx new_operands[2];\n+        new_operands[0] = operands[0];\n+        new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[0])+1);\n+        output_asm_insn(\\\"POPM   R%0,R%1\\\",new_operands);\n+        return \\\"\\;\\\";\n+   } \")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HF 0 \"general_operand\" \"=r\")\n+        (match_operand:HF 1 \"push_operand\" \">\"))]\n+  \"\"\n+  \"*\n+   { \n+        rtx new_operands[2];\n+        new_operands[0] = operands[0];\n+        new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[0])+1);\n+        output_asm_insn(\\\"POPM   R%0,R%1\\\",new_operands);\n+        return \\\"\\;\\\";\n+   } \")\n+\n+(define_insn \"\"\n+  [(set (match_operand:TQF 0 \"general_operand\" \"=r\")\n+        (match_operand:TQF 1 \"push_operand\" \">\"))]\n+  \"\"\n+  \"*\n+   { \n+        rtx new_operands[2];\n+        new_operands[0] = operands[0];\n+        new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[0])+2);\n+        output_asm_insn(\\\"POPM   R%0,R%1\\\",new_operands);\n+        return \\\"\\;\\\";\n+   } \")\n+\n+;; Test operations. These shouldn't really occur for 1750:\n+;; all important instructions set the cc's (see NOTICE_UPDATE_CC)\n+\n+(define_insn \"tstqi\"\n+  [(set (cc0)\n+        (match_operand:QI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"LR     R%0,R%0   ; from tstqi\")\n+\n+(define_insn \"tsthi\"\n+  [(set (cc0)\n+        (match_operand:HI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"DLR    R%0,R%0   ; from tsthi\")\n+\n+(define_insn \"tsthf\"\n+  [(set (cc0)\n+        (match_operand:HF 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"DLR    R%0,R%0   ; from tsthf\")\n+\n+;; This one is happy with \"roughly zero\" :-)  (should be improved)\n+(define_insn \"tsttqf\"\n+  [(set (cc0)\n+        (match_operand:TQF 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"DLR    R%0,R%0   ; from tsttqf\")\n+\n+\n+;; block move.\n+\n+; there is a problem with this insn in gcc-2.2.3\n+; (clobber (match_dup 2)) does not prevent use of this operand later\n+;\n+(define_insn \"movstrqi\"\n+  [(set (mem:BLK (match_operand:QI 0 \"register_operand\" \"r\"))\n+\t(mem:BLK (match_operand:QI 1 \"register_operand\" \"r\")))\n+   (use (match_operand:QI 2 \"register_operand\" \"r\"))\n+   (use (match_operand:QI 3 \"immediate_operand\" \"\"))\n+   (clobber (match_dup 0))\n+   (clobber (match_dup 1))\n+   (clobber (match_dup 2))]\n+  \"\"\n+  \"* return (char *)movcnt_regno_adjust(operands); \")\n+\n+\n+;; compare instructions.\n+\n+(define_insn \"cmpqi\"\n+  [(set (cc0)\n+        (compare (match_operand:QI 0 \"register_operand\" \"r,r,r,r,r\")\n+                 (match_operand:QI 1 \"general_operand\"  \"I,J,i,r,m\")))]\n+  \"\"\n+  \"@\n+     CISP   R%0,%1\n+     CISN   R%0,%J1\n+     CIM    R%0,%1\n+     CR     R%0,R%1\n+     C      R%0,%1 \")\n+\n+(define_insn \"cmphi\"\n+  [(set (cc0)\n+        (compare (match_operand:HI 0 \"general_operand\" \"r,r\")\n+                 (match_operand:HI 1 \"general_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+    DCR    R%0,R%1\n+    DC     R%0,%1 \")\n+\n+(define_insn \"cmphf\"\n+ [(set (cc0)\n+       (compare (match_operand:HF 0 \"general_operand\" \"r,r\")\n+                (match_operand:HF 1 \"general_operand\" \"r,m\")))]\n+ \"\"\n+ \"@\n+   FCR    R%0,R%1\n+   FC     R%0,%1 \")\n+\n+(define_insn \"cmptqf\"\n+  [(set (cc0)\n+        (compare (match_operand:TQF 0 \"general_operand\" \"r,r\")\n+                 (match_operand:TQF 1 \"general_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+    EFCR   R%0,R%1\n+    EFC    R%0,%1 \")\n+\n+\n+;; truncation instructions\n+;;- 1750: any needed?\n+\n+(define_insn \"trunchiqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+        (truncate:QI\n+         (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+     {\n+        REGNO(operands[1]) += 1;\n+        return \\\"LR     R%0,R%1  ;trunchiqi2\\\";\n+     } \")\n+\n+;; zero extension instructions\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n+        (zero_extend:HI (match_operand:QI 1 \"general_operand\" \"r,m,i\")))]\n+  \"\"\n+  \"*\n+      {\n+        output_asm_insn(\\\"XORR   R%0,R%0   ;zero_extendqihi2\\\",operands);\n+        REGNO(operands[0]) += 1;\n+        switch (which_alternative)\n+          {\n+            case 0:\n+              return \\\"LR     R%0,R%1\\\";\n+            case 1:\n+              return \\\"L      R%0,%1\\\";\n+            case 2:\n+              return \\\"LIM    R%0,%1\\\";\n+          }\n+      } \")\n+\n+;; sign extension instructions\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n+        (sign_extend:HI (match_operand:QI 1 \"general_operand\" \"r,m,i\")) )]\n+  \"\"\n+  \"@\n+    LR     R%0,R%1 ;extendqihi2\\;DSRA   R%0,16\n+    L      R%0,%1  ;extendqihi2\\;DSRA   R%0,16\n+    LIM    R%0,%1  ;extendqihi2\\;DSRA   R%0,16 \")\n+\n+\n+;; Conversions between float and double.\n+\n+; 1750 HF-to-TQF extend: just append 16 bits (least signif.) with all bits zero\n+(define_insn \"extendhftqf2\"\n+  [(set (match_operand:TQF 0 \"register_operand\" \"=r,r\")\n+        (float_extend:TQF\n+         (match_operand:HF 1 \"general_operand\" \"r,m\")))]\n+  \"\"\n+  \"*\n+      {\n+        REGNO(operands[0]) += 2;\n+        output_asm_insn(\\\"XORR   R%0,R%0   ;extendhftqf2\\\",operands);\n+        REGNO(operands[0]) -= 2;\n+        if (which_alternative == 0)\n+          return \\\"DLR    R%0,R%1\\\";\n+        else\n+          return \\\"DL     R%0,%1\\\";\n+      } \")\n+\n+; 1750 TQF-to-HF truncate is a no-op: just leave away the least signif. 16 bits\n+(define_insn \"trunctqfhf2\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n+        (float_truncate:HF\n+          (match_operand:TQF 1 \"general_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+     DLR    R%0,R%1  ;trunctqfhf2\n+     DL     R%0,%1   ;trunctqfhf2 \")\n+\n+\n+;; Conversion between fixed point and floating point.\n+\n+(define_insn \"floatqihf2\"\n+  [(set           (match_operand:HF 0 \"register_operand\" \"=r\")\n+        (float:HF (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"FLT    R%0,R%1\")\n+\n+(define_insn \"floathitqf2\"\n+  [(set           (match_operand:TQF 0 \"register_operand\" \"=r\")\n+        (float:TQF (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"EFLT   R%0,R%1\")\n+\n+\n+;; Convert floats to ints\n+\n+(define_insn \"fix_trunchfqi2\"\n+  [(set                 (match_operand:QI 0 \"register_operand\" \"=r\")\n+        (fix:QI (fix:HF (match_operand:HF 1 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"FIX    R%0,R%1\")\n+\n+(define_insn \"fix_trunctqfhi2\"\n+  [(set                 (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (fix:HI (fix:TQF (match_operand:TQF 1 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"EFIX   R%0,R%1\")\n+\n+\n+;; Move instructions\n+\n+;; We can't deal with normal byte-size characters, only with WIDE characters!\n+;; This may appear as a serious restriction, but it also opens the doors\n+;; for ISO 10646  :-)\n+\n+;; 16-bit moves\n+\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,r,r,r,r,m,m\")\n+        (match_operand:QI 1 \"general_operand\"  \"O,I,J,M,i,r,m,r,K\"))]\n+  \"\"\n+  \"@\n+     XORR   R%0,R%0\n+     LISP   R%0,%1\n+     LISN   R%0,%J1\n+     LIM    R%0,%1  ; 'M' constraint\n+     LIM    R%0,%1  ; 'i' constraint\n+     LR     R%0,R%1\n+     L      R%0,%1\n+     ST     R%1,%0\n+     STC    %1,%0   \")\n+\n+;; 32-bit moves\n+\n+;; Set HIreg to constant\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (match_operand    1 \"immediate_operand\" \"i\"))]\n+  \"\"\n+  \"*\n+    if (GET_CODE(operands[1]) == CONST_INT)\n+      {\n+        int val = INTVAL(operands[1]);\n+        if (val >= 0)\n+          {\n+            if (val <= 65535)\n+              {\n+                output_asm_insn(\\\"XORR   R%0,R%0 ;movhi cst->reg\\\",operands);\n+                operands[0] = gen_rtx(REG,QImode,REGNO(operands[0]) + 1);\n+                if (val == 0)\n+                  return \\\"XORR   R%0,R%0\\\";\n+                else if (val <= 16)\n+                  return \\\"LISP   R%0,%1\\\";\n+                else\n+                  return \\\"LIM    R%0,%1\\\";\n+              }\n+          }\n+        else if (val >= -16)\n+          return \\\"LISN   R%0,%J1\\;DSRA   R%0,16 ;movhi cst\\\";\n+        INTVAL(operands[1]) >>= 16;\n+        output_asm_insn(\\\"LIM    R%0,%1 ;movhi cst->reg\\\",operands);\n+        REGNO(operands[0]) += 1;\n+        INTVAL(operands[1]) = val & 0xFFFF;\n+        return \\\"LIM    R%0,%1\\\";\n+      }\n+    return \\\"LIM    R%0,%1\\;DSRA   R%0,16 ;movhi cst\\\";\n+  \")\n+\n+(define_insn \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,r,m\")\n+        (match_operand:HI 1 \"general_operand\"  \"r,m,r\"))]\n+  \"\"\n+  \"@\n+    DLR    R%0,R%1\n+    DL     R%0,%1\n+    DST    R%1,%0 \")\n+\n+\n+;; Single-Float moves are *same* as HImode moves:\n+\n+(define_insn \"movhf\"\n+  [(set (match_operand:HF 0 \"general_operand\" \"=r,r,r,r,m\")\n+        (match_operand:HF 1 \"general_operand\"  \"G,F,r,m,r\"))]\n+  \"\"\n+  \"@\n+    DXRR.M %0,%0 ; movhf const(0.0)\n+    %E1\\;DL     R%0,%F1\n+    DLR    R%0,R%1\n+    DL     R%0,%1\n+    DST    R%1,%0 \")\n+\n+\n+;; Longfloat moves\n+\n+(define_insn \"movtqf\"\n+  [(set (match_operand:TQF 0 \"general_operand\" \"=r,r,r,m\")\n+        (match_operand:TQF 1 \"general_operand\"  \"F,r,m,r\"))]\n+  \"\"\n+  \"@\n+    %D1\\;EFL    R%0,%F1\n+    EFLR.M %0,%1\n+    EFL    R%0,%1\n+    EFST   R%1,%0 \")\n+\n+\n+;; add instructions \n+\n+;; single integer\n+\n+;; Use \"LIM Ra,sym,Rb\" for adding a symbol value to a register and\n+;; transferring the result to a different register.\n+;(define_insn \"\"\n+;  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+;        (plus:QI (match_operand:QI 1 \"register_operand\" \"b\")\n+;                 (match_operand:QI 2 \"immediate_operand\"  \"i\")))]\n+;   \"REGNO(operands[0]) != REGNO(operands[1])\"\n+;   \"LIM    R%0,%2,R%1 ;md special addqi\")\n+\n+(define_insn \"addqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,r,r,m,m\")\n+        (plus:QI (match_operand:QI 1 \"general_operand\" \"%0,0,0,0,0,0,0\")\n+                 (match_operand:QI 2 \"general_operand\"  \"I,J,i,r,m,I,J\")))]\n+  \"\"\n+  \"*\n+    switch (which_alternative)\n+      {\n+        case 0:\n+          return \\\"AISP   R%0,%2\\\";\n+        case 1:\n+          return \\\"SISP   R%0,%J2\\\";\n+        case 2:\n+          if (INTVAL(operands[2]) < 0)\n+            return \\\"SIM    R%0,%J2\\\";\n+          else\n+            return \\\"AIM    R%0,%2\\\";\n+        case 3:\n+          return \\\"AR     R%0,R%2\\\";\n+        case 4:\n+          return \\\"A      R%0,%2\\\";\n+        case 5:\n+          return \\\"INCM   %2,%0\\\";\n+        case 6:\n+          return \\\"DECM   %J2,%0\\\";\n+      } \")\n+\n+;; double integer\n+(define_insn \"addhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+        (plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n+                 (match_operand:HI 2 \"general_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+    DAR    R%0,R%2\n+    DA     R%0,%2 \")\n+\n+(define_insn \"addhf3\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n+        (plus:HF (match_operand:HF 1 \"register_operand\" \"%0,0\")\n+                 (match_operand:HF 2 \"general_operand\" \"m,r\")))]\n+  \"\"\n+  \"@\n+    FA     R%0,%2\n+    FAR    R%0,R%2 \")\n+\n+(define_insn \"addtqf3\"\n+  [(set (match_operand:TQF 0 \"register_operand\" \"=r,r\")\n+        (plus:TQF (match_operand:TQF 1 \"register_operand\" \"%0,0\")\n+                 (match_operand:TQF 2 \"general_operand\" \"m,r\")))]\n+  \"\"\n+  \"@\n+    EFA    R%0,%2\n+    EFAR   R%0,R%2 \")\n+\n+\n+;; subtract instructions\n+\n+;; single integer\n+(define_insn \"subqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,r,m\")\n+        (minus:QI (match_operand:QI 1 \"general_operand\" \"%0,0,0,0,0\")\n+                  (match_operand:QI 2 \"general_operand\"  \"I,i,r,m,I\")))]\n+  \"\"\n+  \"@\n+    SISP   R%0,%2\n+    SIM    R%0,%2\n+    SR     R%0,R%2\n+    S      R%0,%2\n+    DECM   %2,%0 \")\n+\n+;; double integer\n+(define_insn \"subhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+        (minus:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n+                  (match_operand:HI 2 \"general_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+    DSR    R%0,R%2\n+    DS     R%0,%2 \")\n+\n+(define_insn \"subhf3\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n+        (minus:HF (match_operand:HF 1 \"register_operand\" \"0,0\")\n+                  (match_operand:HF 2 \"general_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+    FSR    R%0,R%2\n+    FS     R%0,%2 \")\n+\n+(define_insn \"subtqf3\"\n+  [(set (match_operand:TQF 0 \"register_operand\" \"=r,r\")\n+        (minus:TQF (match_operand:TQF 1 \"register_operand\" \"0,0\")\n+                  (match_operand:TQF 2 \"general_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+    EFSR   R%0,R%2\n+    EFS    R%0,%2 \")\n+\n+\n+;; multiply instructions\n+\n+(define_insn \"mulqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r,r,r\")\n+        (mult:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0,0\")\n+                 (match_operand:QI 2 \"general_operand\"  \"I,J,M,r,m\")))]\n+  \"\"\n+  \"@\n+     MISP   R%0,%2\n+     MISN   R%0,%J2\n+     MSIM   R%0,%2\n+     MSR    R%0,R%2\n+     MS     R%0,%2  \")\n+\n+\n+; 32-bit product\n+(define_insn \"mulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n+        (mult:HI (match_operand:QI 1 \"register_operand\" \"%0,0,0\")\n+                 (match_operand:QI 2 \"general_operand\" \"M,r,m\")))]\n+  \"\"\n+  \"@\n+    MIM    R%0,%1\n+    MR     R%0,R%2\n+    M      R%0,%2 \")\n+\n+(define_insn \"mulhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+        (mult:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n+                 (match_operand:HI 2 \"general_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+    DMR    R%0,R%2\n+    DM     R%0,%2 \")\n+\n+; not available on 1750: \"umulhi3\",\"umulhisi3\",\"umulsi3\" (unsigned multiply's)\n+\n+(define_insn \"mulhf3\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n+        (mult:HF (match_operand:HF 1 \"register_operand\" \"%0,0\")\n+                 (match_operand:HF 2 \"general_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+    FMR    R%0,R%2\n+    FM     R%0,%2 \")\n+\n+(define_insn \"multqf3\"\n+  [(set (match_operand:TQF 0 \"register_operand\" \"=r,r\")\n+        (mult:TQF (match_operand:TQF 1 \"register_operand\" \"%0,0\")\n+                 (match_operand:TQF 2 \"general_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+    EFMR   R%0,R%2\n+    EFM    R%0,%2 \")\n+\n+\n+;; divide instructions\n+;; The 1750 16bit integer division instructions deliver a 16-bit\n+;; quotient and a 16-bit remainder, where the remainder is in the next higher\n+;; register number above the quotient. For now, we haven't found a way\n+;; to give the reload pass knowledge of this property. So we make do with\n+;; whatever registers the allocator wants, and willy-nilly output a pair of\n+;; register-copy ops when needed. (See mod_regno_adjust() in file aux-output.c)\n+;; A comment in the description of `divmodM4' suggests that one leave the divM3\n+;; undefined when there is a divmodM4 available.\n+\n+(define_insn \"divmodqi4\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r,r,r\")\n+        (div:QI (match_operand:QI 1 \"register_operand\" \"0,0,0,0,0\")\n+                (match_operand:QI 2 \"general_operand\"  \"I,J,M,r,m\")))\n+   (set (match_operand:QI 3 \"register_operand\" \"=r,r,r,r,r\")\n+        (mod:QI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"*\n+   {\n+     char *istr;\n+     switch(which_alternative)\n+       {\n+       case 0:\n+         istr = \\\"DISP\\\";\n+         break;\n+       case 1:\n+         INTVAL(operands[2]) = - INTVAL(operands[2]); /* to be corrected */\n+         istr = \\\"DISN\\\";\n+         break;\n+       case 2:\n+         istr = \\\"DVIM\\\";\n+         break;\n+       case 3:\n+         istr = \\\"DVR \\\";\n+         break;\n+       case 4:\n+         istr = \\\"DV  \\\";\n+         break;\n+      }\n+      return (char *)mod_regno_adjust(istr,operands);\n+     }\")\n+\n+;; Division for other types is straightforward.\n+\n+(define_insn \"divhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+        (div:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n+                (match_operand:HI 2 \"general_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+    DDR    R%0,R%2\n+    DD     R%0,%2 \")\n+\n+(define_insn \"divhf3\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n+        (div:HF (match_operand:HF 1 \"register_operand\" \"0,0\")\n+                (match_operand:HF 2 \"general_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+    FDR    R%0,R%2\n+    FD     R%0,%2 \")\n+\n+(define_insn \"divtqf3\"\n+  [(set (match_operand:TQF 0 \"register_operand\" \"=r,r\")\n+        (div:TQF (match_operand:TQF 1 \"register_operand\" \"0,0\")\n+                (match_operand:TQF 2 \"general_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+    EFDR   R%0,R%2\n+    EFD    R%0,%2 \")\n+\n+\n+;; Other arithmetic instructions:\n+\n+;; Absolute value\n+\n+(define_insn \"absqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+        (abs:QI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"ABS    R%0,R%1\")\n+\n+(define_insn \"abshi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (abs:HI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"DABS   R%0,R%1\")\n+\n+(define_insn \"abshf2\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"=r\")\n+        (abs:HF (match_operand:HF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"FABS   R%0,R%1\")\n+\n+\n+;; Negation\n+\n+(define_insn \"negqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+        (neg:QI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"NEG    R%0,R%1\")\n+\n+(define_insn \"neghi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (neg:HI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"DNEG   R%0,R%1\")\n+\n+(define_insn \"neghf2\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"=r\")\n+        (neg:HF (match_operand:HF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"FNEG   R%0,R%1\")\n+\n+; The 1750A does not have an extended float negate instruction, so simulate.\n+;(define_expand \"negtqf2\"\n+;  [(set (match_operand:TQF 0 \"register_operand\" \"=&r\")\n+;        (neg:TQF (match_operand:TQF 1 \"register_operand\" \"r\")))]\n+;  \"\"\n+;  \"\n+;   emit_insn(gen_rtx(SET,VOIDmode,operands[0],CONST0_RTX(TQFmode)));\n+;   emit_insn(gen_rtx(SET,VOIDmode,operands[0],\n+;             gen_rtx(MINUS,TQFmode,operands[0],operands[1])));\n+;   DONE;\n+;  \")\n+\n+\n+;; bit-logical instructions\n+\n+;; AND\n+\n+(define_insn \"andqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r\")\n+        (and:QI (match_operand:QI 1 \"general_operand\" \"%0,0,0\")\n+                (match_operand:QI 2 \"general_operand\" \"M,r,m\")))]\n+  \"\"\n+  \"@\n+    ANDM   R%0,%2\n+    ANDR   R%0,R%2\n+    AND    R%0,%2 \")\n+\n+; This sets incorrect condition codes. See notice_update_cc()\n+(define_insn \"andhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (and:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n+                (match_operand:HI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"DANR.M %0,%2\")\n+\n+;; OR\n+\n+(define_insn \"iorqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r\")\n+        (ior:QI  (match_operand:QI 1 \"general_operand\" \"%0,0,0\")\n+                (match_operand:QI 2 \"general_operand\" \"M,r,m\")))]\n+  \"\"\n+  \"@\n+    ORIM   R%0,%2\n+    ORR    R%0,R%2\n+    OR     R%0,%2 \")\n+\n+; This sets incorrect condition codes. See notice_update_cc()\n+(define_insn \"iorhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (ior:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n+                (match_operand:HI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"DORR.M %0,%2\")\n+\n+;; XOR\n+\n+(define_insn \"xorqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r\")\n+        (xor:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0\")\n+                (match_operand:QI 2 \"general_operand\"  \"M,r,m\")))]\n+  \"\"\n+  \"@\n+    XORM   R%0,%2\n+    XORR   R%0,R%2\n+    XOR    R%0,%2 \")\n+\n+; This sets incorrect condition codes. See notice_update_cc()\n+(define_insn \"xorhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (xor:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n+                (match_operand:HI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"DXRR.M %0,%2\")\n+\n+;; NAND\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r\")\n+\t(ior:QI (not:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0\"))\n+\t\t(not:QI (match_operand:QI 2 \"general_operand\" \"M,r,m\"))))]\n+  \"\"\n+  \"@\n+    NIM    R%0,%2\n+    NR     R%0,R%2\n+    N      R%0,%2 \")\n+\n+; This sets incorrect condition codes. See notice_update_cc()\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ior:HI (not:HI (match_operand:HI 1 \"register_operand\" \"%0\"))\n+\t\t(not:HI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"DNR.M  %0,%2\")\n+\n+;; NOT\n+\n+(define_insn \"one_cmplqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+        (not:QI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"NR     R%0,R%0\")\n+\n+; This sets incorrect condition codes. See notice_update_cc()\n+(define_insn \"one_cmplhi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (not:HI (match_operand:HI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"DNR.M  %0,%0\")\n+\n+\n+;; Shift instructions\n+\n+; (What to the 1750 is logical-shift-left, GCC likes to call \"arithmetic\")\n+(define_insn \"ashlqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r\")\n+        (ashift:QI (match_operand:QI 1 \"register_operand\" \"0,0,0\")\n+                   (match_operand:QI 2 \"general_operand\" \"O,I,r\")))]\n+  \"\"\n+  \"@\n+    ; optimized away an SLL R%0,0\n+    SLL    R%0,%2\n+    SLR    R%0,R%2 \")\n+\n+(define_insn \"ashlhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+        (ashift:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n+                   (match_operand:QI 2 \"general_operand\" \"L,r\")))]\n+  \"\"                        ; the 'L' constraint is a slight imprecise...\n+  \"@\n+     DSLL   R%0,%2\n+     DSLR   R%0,R%2 \")\n+\n+(define_insn \"lshrqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n+        (lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n+                     (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n+  \"\"\n+  \"@\n+    SRL    R%0,%2\n+    NEG    R%2,R%2\\;SLR    R%0,R%2 \")\n+\n+(define_insn \"lshrhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+        (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n+                     (match_operand:QI 2 \"general_operand\" \"L,r\")))]\n+  \"\"                        ; the 'L' constraint is a slight imprecise...\n+  \"@\n+    DSRL   R%0,%2\n+    NEG    R%2,R%2\\;DSLR   R%0,R%2 \")\n+\n+(define_insn \"ashrqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n+        (ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n+                     (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n+  \"\"\n+  \"@\n+     SRA    R%0,%2\n+     NEG    R%2,R%2\\;SAR    R%0,R%2 \")\n+\n+(define_insn \"ashrhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+        (ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n+                     (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n+  \"\"\n+  \"@\n+     DSRA   R%0,%2\n+     NEG    R%2,R%2\\;DSAR   R%0,R%2 \")\n+\n+\n+;; rotate instructions\n+\n+(define_insn \"rotlqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n+        (rotate:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n+                   (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n+  \"\"\n+  \"@\n+    SLC    R%0,%2\n+    SCR    R%0,R%2 \")\n+\n+(define_insn \"rotlhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+        (rotate:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n+                   (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n+  \"\"\n+  \"@\n+    DSLC   R%0,%2\n+    DSCR   R%0,R%2 \")\n+\n+(define_insn \"rotrqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n+        (rotatert:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n+                     (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n+  \"\"\n+  \"@\n+    SLC    R%0,%2\n+    NEG    R%2,R%2\\;SCR    R%0,R%2 \")\n+\n+(define_insn \"rotrhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+        (rotatert:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n+                     (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n+  \"\"\n+  \"@\n+    DSLC   R%0,%2\n+    NEG    R%2,R%2\\;DSCR   R%0,R%2 \")\n+\n+\n+\n+;; Special cases of bit-field insns which we should\n+;; recognize in preference to the general case.\n+;; These handle aligned 8-bit and 16-bit fields,\n+;; which can usually be done with move instructions.\n+;    1750: t.b.d.\n+;********************\n+\n+;; Bit field instructions, general cases.\n+;; \"o,d\" constraint causes a nonoffsetable memref to match the \"o\"\n+;; so that its address is reloaded.\n+\n+;; (define_insn \"extv\" ...\n+\n+;; (define_insn \"extzv\" ...\n+\n+;; (define_insn \"insv\" ...\n+\n+;; Now recognize bit field insns that operate on registers\n+;; (or at least were intended to do so).\n+;[unnamed only]\n+\n+;; Special patterns for optimizing bit-field instructions.\n+;**************************************\n+\n+; cc status test ops n.a. on 1750 ......... e.g. \"sleu\" on 68k:\n+;  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+;        (leu (cc0) (const_int 0)))]\n+;  \"\"\n+;  \"* cc_status = cc_prev_status;\n+;     return \\\"sls %0\\\"; \")\n+\n+\n+;; Basic conditional jump instructions.\n+\n+(define_insn \"beq\"\n+  [(set (pc)\n+        (if_then_else (eq (cc0)\n+                          (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"* return (char *)branch_or_jump(\\\"EZ\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \")\n+\n+(define_insn \"bne\"\n+  [(set (pc)\n+        (if_then_else (ne (cc0)\n+                          (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"* return (char *)branch_or_jump(\\\"NZ\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \")\n+\n+(define_insn \"bgt\"\n+  [(set (pc)\n+        (if_then_else (gt (cc0)\n+                          (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"* return (char *)branch_or_jump(\\\"GT\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \")\n+\n+(define_insn \"blt\"\n+  [(set (pc)\n+        (if_then_else (lt (cc0)\n+                          (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"* return (char *)branch_or_jump(\\\"LT\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \")\n+\n+(define_insn \"bge\"\n+  [(set (pc)\n+        (if_then_else (ge (cc0)\n+                          (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"* return (char *)branch_or_jump(\\\"GE\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \")\n+\n+(define_insn \"ble\"\n+  [(set (pc)\n+        (if_then_else (le (cc0)\n+                          (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"* return (char *)branch_or_jump(\\\"LE\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \")\n+\n+\n+; no unsigned branches available on 1750. But GCC still needs them, so faking:\n+\n+(define_insn \"bgtu\"\n+  [(set (pc)\n+        (if_then_else (gtu (cc0)\n+                          (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"JC     GT,%l0 ; Warning: this should be an *unsigned* test!\")\n+\n+(define_insn \"bltu\"\n+  [(set (pc)\n+        (if_then_else (ltu (cc0)\n+                          (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"JC     LT,%l0 ; Warning: this should be an *unsigned* test!\")\n+\n+(define_insn \"bgeu\"\n+  [(set (pc)\n+        (if_then_else (geu (cc0)\n+                          (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"JC     GE,%l0 ; Warning: this should be an *unsigned* test!\")\n+\n+(define_insn \"bleu\"\n+  [(set (pc)\n+        (if_then_else (leu (cc0)\n+                          (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"JC     LE,%l0 ; Warning: this should be an *unsigned* test!\")\n+\n+\n+;; Negated conditional jump instructions.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (cc0)\n+                          (const_int 0))\n+                      (pc)\n+                      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return (char *)branch_or_jump(\\\"NZ\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (cc0)\n+                          (const_int 0))\n+                      (pc)\n+                      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return (char *)branch_or_jump(\\\"EZ\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (gt (cc0)\n+                          (const_int 0))\n+                      (pc)\n+                      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return (char *)branch_or_jump(\\\"LE\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (lt (cc0)\n+                          (const_int 0))\n+                      (pc)\n+                      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return (char *)branch_or_jump(\\\"GE\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ge (cc0)\n+                          (const_int 0))\n+                      (pc)\n+                      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return (char *)branch_or_jump(\\\"LT\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (le (cc0)\n+                          (const_int 0))\n+                      (pc)\n+                      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return (char *)branch_or_jump(\\\"GT\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \")\n+\n+\n+;; Negated unsigned conditional jump instructions (faked for 1750).\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (gtu (cc0)\n+                          (const_int 0))\n+                      (pc)\n+                      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"JC     LE,%l0 ;inv.cond. ;Warning: this should be an *unsigned* test!\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ltu (cc0)\n+                          (const_int 0))\n+                      (pc)\n+                      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"JC     GE,%l0 ;inv.cond. ;Warning: this should be an *unsigned* test!\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (geu (cc0)\n+                          (const_int 0))\n+                      (pc)\n+                      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"JC     LT,%l0 ;inv.cond. ;Warning: this should be an *unsigned* test!\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (leu (cc0)\n+                          (const_int 0))\n+                      (pc)\n+                      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"JC     GT,%l0 ;inv.cond. ;Warning: this should be an *unsigned* test!\")\n+\n+;; Tablejump \n+;; 1750 note: CASE_VECTOR_PC_RELATIVE is not defined\n+(define_insn \"tablejump\"\n+  [(set (pc)\n+        (match_operand:QI 0 \"register_operand\" \"b\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"JC     15,0,R%0   ; tablejump label_ref=%1\")\n+\n+\n+;; Unconditional jump\n+(define_insn \"jump\"\n+  [(set (pc)\n+        (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"JC     UC,%0\")\n+\n+;; Call subroutine, returning value in operand 0\n+;; (which must be a hard register).\n+(define_insn \"call_value\"\n+  [(set (match_operand 0 \"register_operand\" \"r\")\n+        (call (match_operand:QI 1 \"memory_operand\" \"m\")\n+              (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  ;; Operand 2 not really used for 1750.\n+  \"\"\n+  \"SJS    R15,%1   ; return value in R0\")\n+\n+;; Call subroutine with no return value.\n+\n+;;  Operand 1 not really used in MIL-STD-1750.\n+(define_insn \"\"\n+  [(call (match_operand:QI 0 \"memory_operand\" \"mp\")\n+         (match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"SJS    R15,%0   ; no return value\")\n+\n+;;;;;;;;;;;; 1750: NOT READY YET.\n+(define_insn \"call\"\n+  [(call (match_operand:QI 0 \"\" \"\")\n+         (match_operand:QI 1 \"\" \"\"))]\n+  \"\"\n+  \"ANYCALL %0\")\n+\n+\n+; (define_insn \"return\"\n+;   [(return)]\n+;   \"\"\n+;   \"*\n+;    { \n+;         rtx oprnd = gen_rtx(CONST_INT,VOIDmode,get_frame_size());\n+;         output_asm_insn(\\\"RET.M  %0\\\",&oprnd);\n+;         return \\\"\\;\\\";\n+;    } \")\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:QI 0 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"JCI   15,%0\")\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\n+\n+;; Subtract One and Jump (if non-zero)\n+(define_peephole \n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+        (plus:QI (match_operand:QI 1 \"register_operand\" \"%0\")\n+                 (match_operand:QI 2 \"immediate_operand\" \"J\")))\n+   (set (cc0) (match_dup 0))\n+   (set (pc)\n+        (if_then_else (ne (cc0) (const_int 0))\n+         (label_ref (match_operand 3 \"\" \"\"))\n+         (pc)))\n+   ]\n+  \"INTVAL(operands[2]) == -1\"\n+  \"SOJ    R%0,%3\")\n+\n+;;;End.\n+"}]}