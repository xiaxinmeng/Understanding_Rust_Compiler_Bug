{"sha": "9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFjYjhkZGYzZTdjZjMxMmRlMjI5ZWFlMTFlMGExZGYyOTU0OGVjOQ==", "commit": {"author": {"name": "Matthias Klose", "email": "doko@ubuntu.com", "date": "2012-11-16T18:35:05Z"}, "committer": {"name": "Matthias Klose", "email": "doko@gcc.gnu.org", "date": "2012-11-16T18:35:05Z"}, "message": "2012-11-16  Matthias Klose  <doko@ubuntu.com>\n\n        * Imported zlib 1.2.7; merged local changes.\n\nFrom-SVN: r193574", "tree": {"sha": "134aeb9aadb88e8719595edaaa40522b99d2a56a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/134aeb9aadb88e8719595edaaa40522b99d2a56a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/comments", "author": {"login": "doko42", "id": 11258518, "node_id": "MDQ6VXNlcjExMjU4NTE4", "avatar_url": "https://avatars.githubusercontent.com/u/11258518?v=4", "gravatar_id": "", "url": "https://api.github.com/users/doko42", "html_url": "https://github.com/doko42", "followers_url": "https://api.github.com/users/doko42/followers", "following_url": "https://api.github.com/users/doko42/following{/other_user}", "gists_url": "https://api.github.com/users/doko42/gists{/gist_id}", "starred_url": "https://api.github.com/users/doko42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/doko42/subscriptions", "organizations_url": "https://api.github.com/users/doko42/orgs", "repos_url": "https://api.github.com/users/doko42/repos", "events_url": "https://api.github.com/users/doko42/events{/privacy}", "received_events_url": "https://api.github.com/users/doko42/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "50605a7f19869692a6c29cead0a1366a420e0e65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50605a7f19869692a6c29cead0a1366a420e0e65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50605a7f19869692a6c29cead0a1366a420e0e65"}], "stats": {"total": 7943, "additions": 4982, "deletions": 2961}, "files": [{"sha": "7ee3bc41bc94cdb8b1c929a6bd4878ea2a9642ab", "filename": "zlib/CMakeLists.txt", "status": "modified", "additions": 48, "deletions": 27, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2FCMakeLists.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2FCMakeLists.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FCMakeLists.txt?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -3,9 +3,13 @@ set(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)\n \n project(zlib C)\n \n-if(NOT DEFINED BUILD_SHARED_LIBS)\n-    option(BUILD_SHARED_LIBS \"Build a shared library form of zlib\" ON)\n-endif()\n+set(VERSION \"1.2.7\")\n+\n+set(INSTALL_BIN_DIR \"${CMAKE_INSTALL_PREFIX}/bin\" CACHE PATH \"Installation directory for executables\")\n+set(INSTALL_LIB_DIR \"${CMAKE_INSTALL_PREFIX}/lib\" CACHE PATH \"Installation directory for libraries\")\n+set(INSTALL_INC_DIR \"${CMAKE_INSTALL_PREFIX}/include\" CACHE PATH \"Installation directory for headers\")\n+set(INSTALL_MAN_DIR \"${CMAKE_INSTALL_PREFIX}/share/man\" CACHE PATH \"Installation directory for manual pages\")\n+set(INSTALL_PKGCONFIG_DIR \"${CMAKE_INSTALL_PREFIX}/share/pkgconfig\" CACHE PATH \"Installation directory for pkgconfig (.pc) files\")\n \n include(CheckTypeSize)\n include(CheckFunctionExists)\n@@ -56,23 +60,27 @@ if(MSVC)\n     set(CMAKE_DEBUG_POSTFIX \"d\")\n     add_definitions(-D_CRT_SECURE_NO_DEPRECATE)\n     add_definitions(-D_CRT_NONSTDC_NO_DEPRECATE)\n+    include_directories(${CMAKE_CURRENT_SOURCE_DIR})\n endif()\n \n if(NOT CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR)\n     # If we're doing an out of source build and the user has a zconf.h\n     # in their source tree...\n     if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h)\n-        message(FATAL_ERROR\n-            \"You must remove ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h \"\n-            \"from the source tree.  This file is included with zlib \"\n-            \"but CMake generates this file for you automatically \"\n-            \"in the build directory.\")\n+        message(STATUS \"Renaming\")\n+        message(STATUS \"    ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h\")\n+        message(STATUS \"to 'zconf.h.included' because this file is included with zlib\")\n+        message(STATUS \"but CMake generates it automatically in the build directory.\")\n+        file(RENAME ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h.included)\n   endif()\n endif()\n \n-configure_file(${CMAKE_CURRENT_SOURCE_DIR}/zconf.h.cmakein\n-               ${CMAKE_CURRENT_BINARY_DIR}/zconf.h @ONLY)\n-include_directories(${CMAKE_CURRENT_BINARY_DIR})\n+set(ZLIB_PC ${CMAKE_CURRENT_BINARY_DIR}/zlib.pc)\n+configure_file( ${CMAKE_CURRENT_SOURCE_DIR}/zlib.pc.cmakein\n+\t\t${ZLIB_PC} @ONLY)\n+configure_file(\t${CMAKE_CURRENT_SOURCE_DIR}/zconf.h.cmakein\n+\t\t${CMAKE_CURRENT_BINARY_DIR}/zconf.h @ONLY)\n+include_directories(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_SOURCE_DIR})\n \n \n #============================================================================\n@@ -110,18 +118,27 @@ set(ZLIB_SRCS\n     trees.c\n     uncompr.c\n     zutil.c\n-    win32/zlib1.rc\n )\n \n+if(NOT MINGW)\n+    set(ZLIB_SRCS ${ZLIB_SRCS}\n+        win32/zlib1.rc # If present will override custom build rule below.\n+    )\n+endif()\n+\n # parse the full version number from zlib.h and include in ZLIB_FULL_VERSION\n file(READ ${CMAKE_CURRENT_SOURCE_DIR}/zlib.h _zlib_h_contents)\n-string(REGEX REPLACE \".*#define[ \\t]+ZLIB_VERSION[ \\t]+\\\"([0-9A-Za-z.]+)\\\".*\"\n+string(REGEX REPLACE \".*#define[ \\t]+ZLIB_VERSION[ \\t]+\\\"([-0-9A-Za-z.]+)\\\".*\"\n     \"\\\\1\" ZLIB_FULL_VERSION ${_zlib_h_contents})\n \n if(MINGW)\n     # This gets us DLL resource information when compiling on MinGW.\n+    if(NOT CMAKE_RC_COMPILER)\n+        SET(CMAKE_RC_COMPILER windres.exe)\n+    endif()\n+\n     add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/zlib1rc.obj\n-                       COMMAND windres.exe\n+                       COMMAND ${CMAKE_RC_COMPILER}\n                             -D GCC_WINDRES\n                             -I ${CMAKE_CURRENT_SOURCE_DIR}\n                             -I ${CMAKE_CURRENT_BINARY_DIR}\n@@ -130,9 +147,9 @@ if(MINGW)\n     set(ZLIB_SRCS ${ZLIB_SRCS} ${CMAKE_CURRENT_BINARY_DIR}/zlib1rc.obj)\n endif(MINGW)\n \n-add_library(zlib ${ZLIB_SRCS} ${ZLIB_PUBLIC_HDRS} ${ZLIB_PRIVATE_HDRS})\n+add_library(zlib SHARED ${ZLIB_SRCS} ${ZLIB_PUBLIC_HDRS} ${ZLIB_PRIVATE_HDRS})\n+add_library(zlibstatic STATIC ${ZLIB_SRCS} ${ZLIB_PUBLIC_HDRS} ${ZLIB_PRIVATE_HDRS})\n set_target_properties(zlib PROPERTIES DEFINE_SYMBOL ZLIB_DLL)\n-\n set_target_properties(zlib PROPERTIES SOVERSION 1)\n \n if(NOT CYGWIN)\n@@ -148,43 +165,47 @@ endif()\n \n if(UNIX)\n     # On unix-like platforms the library is almost always called libz\n-   set_target_properties(zlib PROPERTIES OUTPUT_NAME z)\n+   set_target_properties(zlib zlibstatic PROPERTIES OUTPUT_NAME z)\n+   set_target_properties(zlib PROPERTIES LINK_FLAGS \"-Wl,--version-script,${CMAKE_CURRENT_SOURCE_DIR}/zlib.map\")\n elseif(BUILD_SHARED_LIBS AND WIN32)\n     # Creates zlib1.dll when building shared library version\n     set_target_properties(zlib PROPERTIES SUFFIX \"1.dll\")\n endif()\n \n if(NOT SKIP_INSTALL_LIBRARIES AND NOT SKIP_INSTALL_ALL )\n-    install(TARGETS zlib\n-        RUNTIME DESTINATION bin\n-        ARCHIVE DESTINATION lib\n-        LIBRARY DESTINATION lib )\n+    install(TARGETS zlib zlibstatic\n+        RUNTIME DESTINATION \"${INSTALL_BIN_DIR}\"\n+        ARCHIVE DESTINATION \"${INSTALL_LIB_DIR}\"\n+        LIBRARY DESTINATION \"${INSTALL_LIB_DIR}\" )\n endif()\n if(NOT SKIP_INSTALL_HEADERS AND NOT SKIP_INSTALL_ALL )\n-    install(FILES ${ZLIB_PUBLIC_HDRS} DESTINATION include)\n+    install(FILES ${ZLIB_PUBLIC_HDRS} DESTINATION \"${INSTALL_INC_DIR}\")\n+endif()\n+if(NOT SKIP_INSTALL_FILES AND NOT SKIP_INSTALL_ALL )\n+    install(FILES zlib.3 DESTINATION \"${INSTALL_MAN_DIR}/man3\")\n endif()\n if(NOT SKIP_INSTALL_FILES AND NOT SKIP_INSTALL_ALL )\n-    install(FILES zlib.3 DESTINATION share/man/man3)\n+    install(FILES ${ZLIB_PC} DESTINATION \"${INSTALL_PKGCONFIG_DIR}\")\n endif()\n \n #============================================================================\n # Example binaries\n #============================================================================\n \n-add_executable(example example.c)\n+add_executable(example test/example.c)\n target_link_libraries(example zlib)\n add_test(example example)\n \n-add_executable(minigzip minigzip.c)\n+add_executable(minigzip test/minigzip.c)\n target_link_libraries(minigzip zlib)\n \n if(HAVE_OFF64_T)\n-    add_executable(example64 example.c)\n+    add_executable(example64 test/example.c)\n     target_link_libraries(example64 zlib)\n     set_target_properties(example64 PROPERTIES COMPILE_FLAGS \"-D_FILE_OFFSET_BITS=64\")\n     add_test(example64 example64)\n \n-    add_executable(minigzip64 minigzip.c)\n+    add_executable(minigzip64 test/minigzip.c)\n     target_link_libraries(minigzip64 zlib)\n     set_target_properties(minigzip64 PROPERTIES COMPILE_FLAGS \"-D_FILE_OFFSET_BITS=64\")\n endif()"}, {"sha": "d9b5030e35ff1d8c1ddb0ed7029f3407ba38f792", "filename": "zlib/ChangeLog", "status": "modified", "additions": 202, "deletions": 1, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FChangeLog?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,12 +1,213 @@\n \n                 ChangeLog file for zlib\n \n+Changes in 1.2.7 (2 May 2012)\n+- Replace use of memmove() with a simple copy for portability\n+- Test for existence of strerror\n+- Restore gzgetc_ for backward compatibility with 1.2.6\n+- Fix build with non-GNU make on Solaris\n+- Require gcc 4.0 or later on Mac OS X to use the hidden attribute\n+- Include unistd.h for Watcom C\n+- Use __WATCOMC__ instead of __WATCOM__\n+- Do not use the visibility attribute if NO_VIZ defined\n+- Improve the detection of no hidden visibility attribute\n+- Avoid using __int64 for gcc or solo compilation\n+- Cast to char * in gzprintf to avoid warnings [Zinser]\n+- Fix make_vms.com for VAX [Zinser]\n+- Don't use library or built-in byte swaps\n+- Simplify test and use of gcc hidden attribute\n+- Fix bug in gzclose_w() when gzwrite() fails to allocate memory\n+- Add \"x\" (O_EXCL) and \"e\" (O_CLOEXEC) modes support to gzopen()\n+- Fix bug in test/minigzip.c for configure --solo\n+- Fix contrib/vstudio project link errors [Mohanathas]\n+- Add ability to choose the builder in make_vms.com [Schweda]\n+- Add DESTDIR support to mingw32 win32/Makefile.gcc\n+- Fix comments in win32/Makefile.gcc for proper usage\n+- Allow overriding the default install locations for cmake\n+- Generate and install the pkg-config file with cmake\n+- Build both a static and a shared version of zlib with cmake\n+- Include version symbols for cmake builds\n+- If using cmake with MSVC, add the source directory to the includes\n+- Remove unneeded EXTRA_CFLAGS from win32/Makefile.gcc [Truta]\n+- Move obsolete emx makefile to old [Truta]\n+- Allow the use of -Wundef when compiling or using zlib\n+- Avoid the use of the -u option with mktemp\n+- Improve inflate() documentation on the use of Z_FINISH\n+- Recognize clang as gcc\n+- Add gzopen_w() in Windows for wide character path names\n+- Rename zconf.h in CMakeLists.txt to move it out of the way\n+- Add source directory in CMakeLists.txt for building examples\n+- Look in build directory for zlib.pc in CMakeLists.txt\n+- Remove gzflags from zlibvc.def in vc9 and vc10\n+- Fix contrib/minizip compilation in the MinGW environment\n+- Update ./configure for Solaris, support --64 [Mooney]\n+- Remove -R. from Solaris shared build (possible security issue)\n+- Avoid race condition for parallel make (-j) running example\n+- Fix type mismatch between get_crc_table() and crc_table\n+- Fix parsing of version with \"-\" in CMakeLists.txt [Snider, Ziegler]\n+- Fix the path to zlib.map in CMakeLists.txt\n+- Force the native libtool in Mac OS X to avoid GNU libtool [Beebe]\n+- Add instructions to win32/Makefile.gcc for shared install [Torri]\n+\n+Changes in 1.2.6.1 (12 Feb 2012)\n+- Avoid the use of the Objective-C reserved name \"id\"\n+- Include io.h in gzguts.h for Microsoft compilers\n+- Fix problem with ./configure --prefix and gzgetc macro\n+- Include gz_header definition when compiling zlib solo\n+- Put gzflags() functionality back in zutil.c\n+- Avoid library header include in crc32.c for Z_SOLO\n+- Use name in GCC_CLASSIC as C compiler for coverage testing, if set\n+- Minor cleanup in contrib/minizip/zip.c [Vollant]\n+- Update make_vms.com [Zinser]\n+- Remove unnecessary gzgetc_ function\n+- Use optimized byte swap operations for Microsoft and GNU [Snyder]\n+- Fix minor typo in zlib.h comments [Rzesniowiecki]\n+\n+Changes in 1.2.6 (29 Jan 2012)\n+- Update the Pascal interface in contrib/pascal\n+- Fix function numbers for gzgetc_ in zlibvc.def files\n+- Fix configure.ac for contrib/minizip [Schiffer]\n+- Fix large-entry detection in minizip on 64-bit systems [Schiffer]\n+- Have ./configure use the compiler return code for error indication\n+- Fix CMakeLists.txt for cross compilation [McClure]\n+- Fix contrib/minizip/zip.c for 64-bit architectures [Dalsnes]\n+- Fix compilation of contrib/minizip on FreeBSD [Marquez]\n+- Correct suggested usages in win32/Makefile.msc [Shachar, Horvath]\n+- Include io.h for Turbo C / Borland C on all platforms [Truta]\n+- Make version explicit in contrib/minizip/configure.ac [Bosmans]\n+- Avoid warning for no encryption in contrib/minizip/zip.c [Vollant]\n+- Minor cleanup up contrib/minizip/unzip.c [Vollant]\n+- Fix bug when compiling minizip with C++ [Vollant]\n+- Protect for long name and extra fields in contrib/minizip [Vollant]\n+- Avoid some warnings in contrib/minizip [Vollant]\n+- Add -I../.. -L../.. to CFLAGS for minizip and miniunzip\n+- Add missing libs to minizip linker command\n+- Add support for VPATH builds in contrib/minizip\n+- Add an --enable-demos option to contrib/minizip/configure\n+- Add the generation of configure.log by ./configure\n+- Exit when required parameters not provided to win32/Makefile.gcc\n+- Have gzputc return the character written instead of the argument\n+- Use the -m option on ldconfig for BSD systems [Tobias]\n+- Correct in zlib.map when deflateResetKeep was added\n+\n+Changes in 1.2.5.3 (15 Jan 2012)\n+- Restore gzgetc function for binary compatibility\n+- Do not use _lseeki64 under Borland C++ [Truta]\n+- Update win32/Makefile.msc to build test/*.c [Truta]\n+- Remove old/visualc6 given CMakefile and other alternatives\n+- Update AS400 build files and documentation [Monnerat]\n+- Update win32/Makefile.gcc to build test/*.c [Truta]\n+- Permit stronger flushes after Z_BLOCK flushes\n+- Avoid extraneous empty blocks when doing empty flushes\n+- Permit Z_NULL arguments to deflatePending\n+- Allow deflatePrime() to insert bits in the middle of a stream\n+- Remove second empty static block for Z_PARTIAL_FLUSH\n+- Write out all of the available bits when using Z_BLOCK\n+- Insert the first two strings in the hash table after a flush\n+\n+Changes in 1.2.5.2 (17 Dec 2011)\n+- fix ld error: unable to find version dependency 'ZLIB_1.2.5'\n+- use relative symlinks for shared libs\n+- Avoid searching past window for Z_RLE strategy\n+- Assure that high-water mark initialization is always applied in deflate\n+- Add assertions to fill_window() in deflate.c to match comments\n+- Update python link in README\n+- Correct spelling error in gzread.c\n+- Fix bug in gzgets() for a concatenated empty gzip stream\n+- Correct error in comment for gz_make()\n+- Change gzread() and related to ignore junk after gzip streams\n+- Allow gzread() and related to continue after gzclearerr()\n+- Allow gzrewind() and gzseek() after a premature end-of-file\n+- Simplify gzseek() now that raw after gzip is ignored\n+- Change gzgetc() to a macro for speed (~40% speedup in testing)\n+- Fix gzclose() to return the actual error last encountered\n+- Always add large file support for windows\n+- Include zconf.h for windows large file support\n+- Include zconf.h.cmakein for windows large file support\n+- Update zconf.h.cmakein on make distclean\n+- Merge vestigial vsnprintf determination from zutil.h to gzguts.h\n+- Clarify how gzopen() appends in zlib.h comments\n+- Correct documentation of gzdirect() since junk at end now ignored\n+- Add a transparent write mode to gzopen() when 'T' is in the mode\n+- Update python link in zlib man page\n+- Get inffixed.h and MAKEFIXED result to match\n+- Add a ./config --solo option to make zlib subset with no libary use\n+- Add undocumented inflateResetKeep() function for CAB file decoding\n+- Add --cover option to ./configure for gcc coverage testing\n+- Add #define ZLIB_CONST option to use const in the z_stream interface\n+- Add comment to gzdopen() in zlib.h to use dup() when using fileno()\n+- Note behavior of uncompress() to provide as much data as it can\n+- Add files in contrib/minizip to aid in building libminizip\n+- Split off AR options in Makefile.in and configure\n+- Change ON macro to Z_ARG to avoid application conflicts\n+- Facilitate compilation with Borland C++ for pragmas and vsnprintf\n+- Include io.h for Turbo C / Borland C++\n+- Move example.c and minigzip.c to test/\n+- Simplify incomplete code table filling in inflate_table()\n+- Remove code from inflate.c and infback.c that is impossible to execute\n+- Test the inflate code with full coverage\n+- Allow deflateSetDictionary, inflateSetDictionary at any time (in raw)\n+- Add deflateResetKeep and fix inflateResetKeep to retain dictionary\n+- Fix gzwrite.c to accommodate reduced memory zlib compilation\n+- Have inflate() with Z_FINISH avoid the allocation of a window\n+- Do not set strm->adler when doing raw inflate\n+- Fix gzeof() to behave just like feof() when read is not past end of file\n+- Fix bug in gzread.c when end-of-file is reached\n+- Avoid use of Z_BUF_ERROR in gz* functions except for premature EOF\n+- Document gzread() capability to read concurrently written files\n+- Remove hard-coding of resource compiler in CMakeLists.txt [Blammo]\n+\n+Changes in 1.2.5.1 (10 Sep 2011)\n+- Update FAQ entry on shared builds (#13)\n+- Avoid symbolic argument to chmod in Makefile.in\n+- Fix bug and add consts in contrib/puff [Oberhumer]\n+- Update contrib/puff/zeros.raw test file to have all block types\n+- Add full coverage test for puff in contrib/puff/Makefile\n+- Fix static-only-build install in Makefile.in\n+- Fix bug in unzGetCurrentFileInfo() in contrib/minizip [Kuno]\n+- Add libz.a dependency to shared in Makefile.in for parallel builds\n+- Spell out \"number\" (instead of \"nb\") in zlib.h for total_in, total_out\n+- Replace $(...) with `...` in configure for non-bash sh [Bowler]\n+- Add darwin* to Darwin* and solaris* to SunOS\\ 5* in configure [Groffen]\n+- Add solaris* to Linux* in configure to allow gcc use [Groffen]\n+- Add *bsd* to Linux* case in configure [Bar-Lev]\n+- Add inffast.obj to dependencies in win32/Makefile.msc\n+- Correct spelling error in deflate.h [Kohler]\n+- Change libzdll.a again to libz.dll.a (!) in win32/Makefile.gcc\n+- Add test to configure for GNU C looking for gcc in output of $cc -v\n+- Add zlib.pc generation to win32/Makefile.gcc [Weigelt]\n+- Fix bug in zlib.h for _FILE_OFFSET_BITS set and _LARGEFILE64_SOURCE not\n+- Add comment in zlib.h that adler32_combine with len2 < 0 makes no sense\n+- Make NO_DIVIDE option in adler32.c much faster (thanks to John Reiser)\n+- Make stronger test in zconf.h to include unistd.h for LFS\n+- Apply Darwin patches for 64-bit file offsets to contrib/minizip [Slack]\n+- Fix zlib.h LFS support when Z_PREFIX used\n+- Add updated as400 support (removed from old) [Monnerat]\n+- Avoid deflate sensitivity to volatile input data\n+- Avoid division in adler32_combine for NO_DIVIDE\n+- Clarify the use of Z_FINISH with deflateBound() amount of space\n+- Set binary for output file in puff.c\n+- Use u4 type for crc_table to avoid conversion warnings\n+- Apply casts in zlib.h to avoid conversion warnings\n+- Add OF to prototypes for adler32_combine_ and crc32_combine_ [Miller]\n+- Improve inflateSync() documentation to note indeterminancy\n+- Add deflatePending() function to return the amount of pending output\n+- Correct the spelling of \"specification\" in FAQ [Randers-Pehrson]\n+- Add a check in configure for stdarg.h, use for gzprintf()\n+- Check that pointers fit in ints when gzprint() compiled old style\n+- Add dummy name before $(SHAREDLIBV) in Makefile [Bar-Lev, Bowler]\n+- Delete line in configure that adds -L. libz.a to LDFLAGS [Weigelt]\n+- Add debug records in assmebler code [Londer]\n+- Update RFC references to use http://tools.ietf.org/html/... [Li]\n+- Add --archs option, use of libtool to configure for Mac OS X [Borstel]\n+\n Changes in 1.2.5 (19 Apr 2010)\n - Disable visibility attribute in win32/Makefile.gcc [Bar-Lev]\n - Default to libdir as sharedlibdir in configure [Nieder]\n - Update copyright dates on modified source files\n - Update trees.c to be able to generate modified trees.h\n - Exit configure for MinGW, suggesting win32/Makefile.gcc\n+- Check for NULL path in gz_open [Homurlu]\n \n Changes in 1.2.4.5 (18 Apr 2010)\n - Set sharedlibdir in configure [Torok]\n@@ -261,7 +462,7 @@ Changes in 1.2.3.4 (21 Dec 2009)\n - Clear bytes after deflate lookahead to avoid use of uninitialized data\n - Change a limit in inftrees.c to be more transparent to Coverity Prevent\n - Update win32/zlib.def with exported symbols from zlib.h\n-- Correct spelling error in zlib.h [Willem]\n+- Correct spelling errors in zlib.h [Willem, Sobrado]\n - Allow Z_BLOCK for deflate() to force a new block\n - Allow negative bits in inflatePrime() to delete existing bit buffer\n - Add Z_TREES flush option to inflate() to return at end of trees"}, {"sha": "13b62a4a129e71b62ee2ac95e72944cb9d939402", "filename": "zlib/ChangeLog.gcj", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2FChangeLog.gcj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2FChangeLog.gcj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FChangeLog.gcj?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,3 +1,7 @@\n+2012-11-16  Matthias Klose  <doko@ubuntu.com>\n+\n+\t* Imported zlib 1.2.7; merged local changes.\n+\n 2012-09-14  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* configure: Regenerated."}, {"sha": "99b7cf92e45497fc8f608777f962dce2148d108b", "filename": "zlib/FAQ", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2FFAQ", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2FFAQ", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FFAQ?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -44,8 +44,8 @@ The lastest zlib FAQ is at http://zlib.net/zlib_faq.html\n \n  6. Where's the zlib documentation (man pages, etc.)?\n \n-    It's in zlib.h .  Examples of zlib usage are in the files example.c and\n-    minigzip.c, with more in examples/ .\n+    It's in zlib.h .  Examples of zlib usage are in the files test/example.c\n+    and test/minigzip.c, with more in examples/ .\n \n  7. Why don't you use GNU autoconf or libtool or ...?\n \n@@ -84,8 +84,10 @@ The lastest zlib FAQ is at http://zlib.net/zlib_faq.html\n \n 13. How can I make a Unix shared library?\n \n-    make clean\n-    ./configure -s\n+    By default a shared (and a static) library is built for Unix.  So:\n+\n+    make distclean\n+    ./configure\n     make\n \n 14. How do I install a shared zlib library on Unix?\n@@ -325,7 +327,7 @@ The lastest zlib FAQ is at http://zlib.net/zlib_faq.html\n     correctly points to the zlib specification in RFC 1950 for the \"deflate\"\n     transfer encoding, there have been reports of servers and browsers that\n     incorrectly produce or expect raw deflate data per the deflate\n-    specficiation in RFC 1951, most notably Microsoft.  So even though the\n+    specification in RFC 1951, most notably Microsoft.  So even though the\n     \"deflate\" transfer encoding using the zlib format would be the more\n     efficient approach (and in fact exactly what the zlib format was designed\n     for), using the \"gzip\" transfer encoding is probably more reliable due to"}, {"sha": "2ba0641204861d7ebb63524c961e6e004113356c", "filename": "zlib/INDEX", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2FINDEX", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2FINDEX", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FINDEX?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -7,16 +7,21 @@ Makefile.in     template for Unix Makefile\n README          guess what\n configure       configure script for Unix\n make_vms.com    makefile for VMS\n+test/example.c  zlib usages examples for build testing\n+test/minigzip.c minimal gzip-like functionality for build testing\n+test/infcover.c inf*.c code coverage for build coverage testing\n treebuild.xml   XML description of source file dependencies\n zconf.h.cmakein zconf.h template for cmake\n zconf.h.in      zconf.h template for configure\n zlib.3          Man page for zlib\n zlib.3.pdf      Man page in PDF format\n zlib.map        Linux symbol information\n zlib.pc.in      Template for pkg-config descriptor\n+zlib.pc.cmakein zlib.pc template for cmake\n zlib2ansi       perl script to convert source files for C++ compilation\n \n amiga/          makefiles for Amiga SAS C\n+as400/          makefiles for AS/400\n doc/            documentation for formats and algorithms\n msdos/          makefiles for MSDOS\n nintendods/     makefile for Nintendo DS\n@@ -56,10 +61,8 @@ uncompr.c\n zutil.c\n zutil.h\n \n-                source files for sample programs:\n-example.c\n-minigzip.c\n-See examples/README.examples for more\n+                source files for sample programs\n+See examples/README.examples\n \n-                unsupported contribution by third parties\n+                unsupported contributions by third parties\n See contrib/README.contrib"}, {"sha": "7e50f1983a634816b8ecb3922c4edd6ec6bf63e2", "filename": "zlib/README", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FREADME?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -3,23 +3,23 @@ shipped with GCC as convenience.\n \n ZLIB DATA COMPRESSION LIBRARY\n \n-zlib 1.2.5 is a general purpose data compression library.  All the code is\n+zlib 1.2.7 is a general purpose data compression library.  All the code is\n thread safe.  The data format used by the zlib library is described by RFCs\n (Request for Comments) 1950 to 1952 in the files\n-http://www.ietf.org/rfc/rfc1950.txt (zlib format), rfc1951.txt (deflate format)\n-and rfc1952.txt (gzip format).\n+http://tools.ietf.org/html/rfc1950 (zlib format), rfc1951 (deflate format) and\n+rfc1952 (gzip format).\n \n All functions of the compression library are documented in the file zlib.h\n (volunteer to write man pages welcome, contact zlib@gzip.org).  A usage example\n-of the library is given in the file example.c which also tests that the library\n-is working correctly.  Another example is given in the file minigzip.c.  The\n-compression library itself is composed of all source files except example.c and\n-minigzip.c.\n+of the library is given in the file test/example.c which also tests that\n+the library is working correctly.  Another example is given in the file\n+test/minigzip.c.  The compression library itself is composed of all source\n+files in the root directory.\n \n To compile all files and run the test program, follow the instructions given at\n the top of Makefile.in.  In short \"./configure; make test\", and if that goes\n-well, \"make install\" should work for most flavors of Unix.  For Windows, use one\n-of the special makefiles in win32/ or contrib/vstudio/ .  For VMS, use\n+well, \"make install\" should work for most flavors of Unix.  For Windows, use\n+one of the special makefiles in win32/ or contrib/vstudio/ .  For VMS, use\n make_vms.com.\n \n Questions about zlib should be sent to <zlib@gzip.org>, or to Gilles Vollant\n@@ -34,7 +34,7 @@ Mark Nelson <markn@ieee.org> wrote an article about zlib for the Jan.  1997\n issue of Dr.  Dobb's Journal; a copy of the article is available at\n http://marknelson.us/1997/01/01/zlib-engine/ .\n \n-The changes made in version 1.2.5 are documented in the file ChangeLog.\n+The changes made in version 1.2.7 are documented in the file ChangeLog.\n \n Unsupported third party contributions are provided in directory contrib/ .\n \n@@ -47,7 +47,7 @@ http://search.cpan.org/~pmqs/IO-Compress-Zlib/ .\n \n A Python interface to zlib written by A.M. Kuchling <amk@amk.ca> is\n available in Python 1.5 and later versions, see\n-http://www.python.org/doc/lib/module-zlib.html .\n+http://docs.python.org/library/zlib.html .\n \n zlib is built into tcl: http://wiki.tcl.tk/4610 .\n \n@@ -87,7 +87,7 @@ Acknowledgments:\n \n Copyright notice:\n \n- (C) 1995-2010 Jean-loup Gailly and Mark Adler\n+ (C) 1995-2012 Jean-loup Gailly and Mark Adler\n \n   This software is provided 'as-is', without any express or implied\n   warranty.  In no event will the authors be held liable for any damages"}, {"sha": "023c5df9b548888bed927662e000b5eca5f671a9", "filename": "zlib/adler32.c", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fadler32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fadler32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fadler32.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,5 +1,5 @@\n /* adler32.c -- compute the Adler-32 checksum of a data stream\n- * Copyright (C) 1995-2007 Mark Adler\n+ * Copyright (C) 1995-2011 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -9,9 +9,9 @@\n \n #define local static\n \n-local uLong adler32_combine_(uLong adler1, uLong adler2, z_off64_t len2);\n+local uLong adler32_combine_ OF((uLong adler1, uLong adler2, z_off64_t len2));\n \n-#define BASE 65521UL    /* largest prime smaller than 65536 */\n+#define BASE 65521      /* largest prime smaller than 65536 */\n #define NMAX 5552\n /* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */\n \n@@ -21,39 +21,44 @@ local uLong adler32_combine_(uLong adler1, uLong adler2, z_off64_t len2);\n #define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);\n #define DO16(buf)   DO8(buf,0); DO8(buf,8);\n \n-/* use NO_DIVIDE if your processor does not do division in hardware */\n+/* use NO_DIVIDE if your processor does not do division in hardware --\n+   try it both ways to see which is faster */\n #ifdef NO_DIVIDE\n-#  define MOD(a) \\\n+/* note that this assumes BASE is 65521, where 65536 % 65521 == 15\n+   (thank you to John Reiser for pointing this out) */\n+#  define CHOP(a) \\\n+    do { \\\n+        unsigned long tmp = a >> 16; \\\n+        a &= 0xffffUL; \\\n+        a += (tmp << 4) - tmp; \\\n+    } while (0)\n+#  define MOD28(a) \\\n     do { \\\n-        if (a >= (BASE << 16)) a -= (BASE << 16); \\\n-        if (a >= (BASE << 15)) a -= (BASE << 15); \\\n-        if (a >= (BASE << 14)) a -= (BASE << 14); \\\n-        if (a >= (BASE << 13)) a -= (BASE << 13); \\\n-        if (a >= (BASE << 12)) a -= (BASE << 12); \\\n-        if (a >= (BASE << 11)) a -= (BASE << 11); \\\n-        if (a >= (BASE << 10)) a -= (BASE << 10); \\\n-        if (a >= (BASE << 9)) a -= (BASE << 9); \\\n-        if (a >= (BASE << 8)) a -= (BASE << 8); \\\n-        if (a >= (BASE << 7)) a -= (BASE << 7); \\\n-        if (a >= (BASE << 6)) a -= (BASE << 6); \\\n-        if (a >= (BASE << 5)) a -= (BASE << 5); \\\n-        if (a >= (BASE << 4)) a -= (BASE << 4); \\\n-        if (a >= (BASE << 3)) a -= (BASE << 3); \\\n-        if (a >= (BASE << 2)) a -= (BASE << 2); \\\n-        if (a >= (BASE << 1)) a -= (BASE << 1); \\\n+        CHOP(a); \\\n         if (a >= BASE) a -= BASE; \\\n     } while (0)\n-#  define MOD4(a) \\\n+#  define MOD(a) \\\n     do { \\\n-        if (a >= (BASE << 4)) a -= (BASE << 4); \\\n-        if (a >= (BASE << 3)) a -= (BASE << 3); \\\n-        if (a >= (BASE << 2)) a -= (BASE << 2); \\\n-        if (a >= (BASE << 1)) a -= (BASE << 1); \\\n+        CHOP(a); \\\n+        MOD28(a); \\\n+    } while (0)\n+#  define MOD63(a) \\\n+    do { /* this assumes a is not negative */ \\\n+        z_off64_t tmp = a >> 32; \\\n+        a &= 0xffffffffL; \\\n+        a += (tmp << 8) - (tmp << 5) + tmp; \\\n+        tmp = a >> 16; \\\n+        a &= 0xffffL; \\\n+        a += (tmp << 4) - tmp; \\\n+        tmp = a >> 16; \\\n+        a &= 0xffffL; \\\n+        a += (tmp << 4) - tmp; \\\n         if (a >= BASE) a -= BASE; \\\n     } while (0)\n #else\n #  define MOD(a) a %= BASE\n-#  define MOD4(a) a %= BASE\n+#  define MOD28(a) a %= BASE\n+#  define MOD63(a) a %= BASE\n #endif\n \n /* ========================================================================= */\n@@ -92,7 +97,7 @@ uLong ZEXPORT adler32(adler, buf, len)\n         }\n         if (adler >= BASE)\n             adler -= BASE;\n-        MOD4(sum2);             /* only added so many BASE's */\n+        MOD28(sum2);            /* only added so many BASE's */\n         return adler | (sum2 << 16);\n     }\n \n@@ -137,8 +142,13 @@ local uLong adler32_combine_(adler1, adler2, len2)\n     unsigned long sum2;\n     unsigned rem;\n \n+    /* for negative len, return invalid adler32 as a clue for debugging */\n+    if (len2 < 0)\n+        return 0xffffffffUL;\n+\n     /* the derivation of this formula is left as an exercise for the reader */\n-    rem = (unsigned)(len2 % BASE);\n+    MOD63(len2);                /* assumes len2 >= 0 */\n+    rem = (unsigned)len2;\n     sum1 = adler1 & 0xffff;\n     sum2 = rem * sum1;\n     MOD(sum2);"}, {"sha": "52cc6613b30a939fadc73d9dd377b7f5e12a00b2", "filename": "zlib/as400/bndsrc", "status": "renamed", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fas400%2Fbndsrc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fas400%2Fbndsrc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fas400%2Fbndsrc?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -129,4 +129,77 @@ STRPGMEXP PGMLVL(*CURRENT) SIGNATURE('ZLIB')\n \n   EXPORT SYMBOL(\"zlibCompileFlags\")\n \n+/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n+/*   Version 1.2.5 additional entry points.                         */\n+/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n+\n+/********************************************************************/\n+/*   *MODULE      ADLER32      ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"adler32_combine\")\n+  EXPORT SYMBOL(\"adler32_combine64\")\n+\n+/********************************************************************/\n+/*   *MODULE      CRC32        ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"crc32_combine\")\n+  EXPORT SYMBOL(\"crc32_combine64\")\n+\n+/********************************************************************/\n+/*   *MODULE      GZLIB        ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"gzbuffer\")\n+  EXPORT SYMBOL(\"gzoffset\")\n+  EXPORT SYMBOL(\"gzoffset64\")\n+  EXPORT SYMBOL(\"gzopen64\")\n+  EXPORT SYMBOL(\"gzseek64\")\n+  EXPORT SYMBOL(\"gztell64\")\n+\n+/********************************************************************/\n+/*   *MODULE      GZREAD       ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"gzclose_r\")\n+\n+/********************************************************************/\n+/*   *MODULE      GZWRITE      ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"gzclose_w\")\n+\n+/********************************************************************/\n+/*   *MODULE      INFLATE      ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"inflateMark\")\n+  EXPORT SYMBOL(\"inflatePrime\")\n+  EXPORT SYMBOL(\"inflateReset2\")\n+  EXPORT SYMBOL(\"inflateUndermine\")\n+\n+/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n+/*   Version 1.2.6 additional entry points.                         */\n+/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n+\n+/********************************************************************/\n+/*   *MODULE      DEFLATE      ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"deflateResetKeep\")\n+  EXPORT SYMBOL(\"deflatePending\")\n+\n+/********************************************************************/\n+/*   *MODULE      GZWRITE      ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"gzgetc_\")\n+\n+/********************************************************************/\n+/*   *MODULE      INFLATE      ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"inflateResetKeep\")\n+\n ENDPGMEXP", "previous_filename": "zlib/old/as400/bndsrc"}, {"sha": "8d0c58f51e1728375b38a651abcd7cefaa50688b", "filename": "zlib/as400/compile.clp", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fas400%2Fcompile.clp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fas400%2Fcompile.clp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fas400%2Fcompile.clp?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -0,0 +1,110 @@\n+/******************************************************************************/\n+/*                                                                            */\n+/*  ZLIB                                                                      */\n+/*                                                                            */\n+/*    Compile sources into modules and link them into a service program.      */\n+/*                                                                            */\n+/******************************************************************************/\n+\n+             PGM\n+\n+/*      Configuration adjustable parameters.                                  */\n+\n+             DCL        VAR(&SRCLIB) TYPE(*CHAR) LEN(10) +\n+                          VALUE('ZLIB')                         /* Source library. */\n+             DCL        VAR(&SRCFILE) TYPE(*CHAR) LEN(10) +\n+                          VALUE('SOURCES')                      /* Source member file. */\n+             DCL        VAR(&CTLFILE) TYPE(*CHAR) LEN(10) +\n+                          VALUE('TOOLS')                        /* Control member file. */\n+\n+             DCL        VAR(&MODLIB) TYPE(*CHAR) LEN(10) +\n+                          VALUE('ZLIB')                         /* Module library. */\n+\n+             DCL        VAR(&SRVLIB) TYPE(*CHAR) LEN(10) +\n+                          VALUE('LGPL')                         /* Service program library. */\n+\n+             DCL        VAR(&CFLAGS) TYPE(*CHAR) +\n+                          VALUE('OPTIMIZE(40)')                 /* Compile options. */\n+\n+             DCL        VAR(&TGTRLS) TYPE(*CHAR) +\n+                          VALUE('V5R3M0')                       /* Target release. */\n+\n+\n+/*      Working storage.                                                      */\n+\n+             DCL        VAR(&CMDLEN) TYPE(*DEC) LEN(15 5) VALUE(300)    /* Command length. */\n+             DCL        VAR(&CMD) TYPE(*CHAR) LEN(512)\n+             DCL        VAR(&FIXDCMD) TYPE(*CHAR) LEN(512)\n+\n+\n+/*      Compile sources into modules.                                         */\n+\n+             CHGVAR     VAR(&FIXDCMD) VALUE('CRTCMOD' *BCAT &CFLAGS *BCAT      +\n+                        'SYSIFCOPT(*IFS64IO)' *BCAT                            +\n+                        'DEFINE(''_LARGEFILE64_SOURCE''' *BCAT                 +\n+                        '''_LFS64_LARGEFILE=1'') TGTRLS(' *TCAT &TGTRLS *TCAT  +\n+                        ') SRCFILE(' *TCAT &SRCLIB *TCAT '/' *TCAT             +\n+                        &SRCFILE *TCAT ') MODULE(' *TCAT &MODLIB *TCAT '/')\n+\n+\n+             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'ADLER32)')\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'COMPRESS)')\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'CRC32)')\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'DEFLATE)')\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'GZCLOSE)')\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'GZLIB)')\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'GZREAD)')\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'GZWRITE)')\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'INFBACK)')\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'INFFAST)')\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'INFLATE)')\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'INFTREES)')\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'TREES)')\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'UNCOMPR)')\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'ZUTIL)')\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+\n+/*      Link modules into a service program.                                  */\n+\n+             CRTSRVPGM  SRVPGM(&SRVLIB/ZLIB) +\n+                          MODULE(&MODLIB/ADLER32     &MODLIB/COMPRESS    +\n+                                 &MODLIB/CRC32       &MODLIB/DEFLATE     +\n+                                 &MODLIB/GZCLOSE     &MODLIB/GZLIB       +\n+                                 &MODLIB/GZREAD      &MODLIB/GZWRITE     +\n+                                 &MODLIB/INFBACK     &MODLIB/INFFAST     +\n+                                 &MODLIB/INFLATE     &MODLIB/INFTREES    +\n+                                 &MODLIB/TREES       &MODLIB/UNCOMPR     +\n+                                 &MODLIB/ZUTIL)                          +\n+                          SRCFILE(&SRCLIB/&CTLFILE) SRCMBR(BNDSRC)       +\n+                          TEXT('ZLIB 1.2.7') TGTRLS(&TGTRLS)\n+\n+             ENDPGM"}, {"sha": "23cd1b8a3c5914e4337e3c24c0946e566725a622", "filename": "zlib/as400/readme.txt", "status": "renamed", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fas400%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fas400%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fas400%2Freadme.txt?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,4 +1,4 @@\n-        ZLIB version 1.2.3 for AS400 installation instructions\n+        ZLIB version 1.2.7 for AS400 installation instructions\n \n I) From an AS400 *SAVF file:\n \n@@ -8,7 +8,7 @@ On the AS400:\n \n _       Create the ZLIB AS400 library:\n \n-        CRTLIB LIB(ZLIB) TYPE(PROD) TEXT('ZLIB compression API library')\n+        CRTLIB LIB(ZLIB) TYPE(*PROD) TEXT('ZLIB compression API library')\n \n _       Create a work save file, for example:\n \n@@ -52,7 +52,7 @@ II) From the original source distribution:\n \n 1)      On the AS400, create the source library:\n \n-        CRTLIB LIB(ZLIB) TYPE(PROD) TEXT('ZLIB compression API library')\n+        CRTLIB LIB(ZLIB) TYPE(*PROD) TEXT('ZLIB compression API library')\n \n 2)      Create the source files:\n \n@@ -70,7 +70,10 @@ II) From the original source distribution:\n     compress.c          COMPRESS C     ZLIB - Compress a memory buffer\n     crc32.c             CRC32    C     ZLIB - Compute the CRC-32 of a data stream\n     deflate.c           DEFLATE  C     ZLIB - Compress data using the deflation algorithm\n-    gzio.c              GZIO     C     ZLIB - IO on .gz files\n+    gzclose.c           GZCLOSE  C     ZLIB - Close .gz files\n+    gzlib.c             GZLIB    C     ZLIB - Miscellaneous .gz files IO support\n+    gzread.c            GZREAD   C     ZLIB - Read .gz files\n+    gzwrite.c           GZWRITE  C     ZLIB - Write .gz files\n     infback.c           INFBACK  C     ZLIB - Inflate using a callback interface\n     inffast.c           INFFAST  C     ZLIB - Fast proc. literals & length/distance pairs\n     inflate.c           INFLATE  C     ZLIB - Interface to inflate modules\n@@ -81,6 +84,7 @@ II) From the original source distribution:\n                 H                      Original ZLIB C and ILE/RPG include files\n     crc32.h             CRC32    C     ZLIB - CRC32 tables\n     deflate.h           DEFLATE  C     ZLIB - Internal compression state\n+    gzguts.h            GZGUTS   C     ZLIB - Definitions for the gzclose module\n     inffast.h           INFFAST  C     ZLIB - Header to use inffast.c\n     inffixed.h          INFFIXED C     ZLIB - Table for decoding fixed codes\n     inflate.h           INFLATE  C     ZLIB - Internal inflate state definitions\n@@ -108,4 +112,4 @@ Notes:  For AS400 ILE RPG programmers, a /copy member defining the ZLIB\n                 implementation does not handle conversion from/to ASCII, so\n                 text data code conversions must be done explicitely.\n \n-        Always open zipped files in binary mode.\n+        Mainly for the reason above, always open zipped files in binary mode.", "previous_filename": "zlib/old/as400/readme.txt"}, {"sha": "747c598aa05daa7630c4099a8c2d18f55bea2409", "filename": "zlib/as400/zlib.inc", "status": "renamed", "additions": 134, "deletions": 20, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fas400%2Fzlib.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fas400%2Fzlib.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fas400%2Fzlib.inc?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,7 +1,7 @@\n       *  ZLIB.INC - Interface to the general purpose compression library\n       *\n       *  ILE RPG400 version by Patrick Monnerat, DATASPHERE.\n-      *  Version 1.2.3.9\n+      *  Version 1.2.7\n       *\n       *\n       *  WARNING:\n@@ -22,16 +22,25 @@\n       *\n       *  Versioning information.\n       *\n-     D ZLIB_VERSION    C                   '1.2.3.9'\n-     D ZLIB_VERNUM     C                   X'1239'\n+     D ZLIB_VERSION    C                   '1.2.7'\n+     D ZLIB_VERNUM     C                   X'1270'\n+     D ZLIB_VER_MAJOR  C                   1\n+     D ZLIB_VER_MINOR  C                   2\n+     D ZLIB_VER_REVISION...\n+     D                 C                   7\n+     D ZLIB_VER_SUBREVISION...\n+     D                 C                   0\n       *\n       *  Other equates.\n       *\n      D Z_NO_FLUSH      C                   0\n+     D Z_PARTIAL_FLUSH...\n+     D                 C                   1\n      D Z_SYNC_FLUSH    C                   2\n      D Z_FULL_FLUSH    C                   3\n      D Z_FINISH        C                   4\n      D Z_BLOCK         C                   5\n+     D Z_TREES         C                   6\n       *\n      D Z_OK            C                   0\n      D Z_STREAM_END    C                   1\n@@ -72,6 +81,7 @@\n      D z_streamp       S               *                                        Stream struct ptr\n      D gzFile          S               *                                        File pointer\n      D z_off_t         S             10i 0                                      Stream offsets\n+     D z_off64_t       S             20i 0                                      Stream offsets\n       *\n       **************************************************************************\n       *                               Structures\n@@ -101,50 +111,66 @@\n       **************************************************************************\n       *\n      D compress        PR            10I 0 extproc('compress')\n-     D  dest                      32767    options(*varsize)                    Destination buffer\n+     D  dest                      65535    options(*varsize)                    Destination buffer\n      D  destLen                      10U 0                                      Destination length\n-     D  source                    32767    const options(*varsize)              Source buffer\n+     D  source                    65535    const options(*varsize)              Source buffer\n      D  sourceLen                    10u 0 value                                Source length\n       *\n      D compress2       PR            10I 0 extproc('compress2')\n-     D  dest                      32767    options(*varsize)                    Destination buffer\n+     D  dest                      65535    options(*varsize)                    Destination buffer\n      D  destLen                      10U 0                                      Destination length\n-     D  source                    32767    const options(*varsize)              Source buffer\n+     D  source                    65535    const options(*varsize)              Source buffer\n      D  sourceLen                    10U 0 value                                Source length\n      D  level                        10I 0 value                                Compression level\n       *\n      D compressBound   PR            10U 0 extproc('compressBound')\n      D  sourceLen                    10U 0 value\n       *\n      D uncompress      PR            10I 0 extproc('uncompress')\n-     D  dest                      32767    options(*varsize)                    Destination buffer\n+     D  dest                      65535    options(*varsize)                    Destination buffer\n      D  destLen                      10U 0                                      Destination length\n-     D  source                    32767    const options(*varsize)              Source buffer\n+     D  source                    65535    const options(*varsize)              Source buffer\n      D  sourceLen                    10U 0 value                                Source length\n       *\n+      /if not defined(LARGE_FILES)\n      D gzopen          PR                  extproc('gzopen')\n      D                                     like(gzFile)\n      D  path                           *   value options(*string)               File pathname\n+     D  mode                           *   value options(*string)               Open mode\n+      /else\n+     D gzopen          PR                  extproc('gzopen64')\n+     D                                     like(gzFile)\n+     D  path                           *   value options(*string)               File pathname\n      D  mode                           *   value options(*string)               Open mode\n       *\n+     D gzopen64        PR                  extproc('gzopen64')\n+     D                                     like(gzFile)\n+     D  path                           *   value options(*string)               File pathname\n+     D  mode                           *   value options(*string)               Open mode\n+      /endif\n+      *\n      D gzdopen         PR                  extproc('gzdopen')\n      D                                     like(gzFile)\n-     D  fd                           10i 0 value                                File descriptor\n+     D  fd                           10I 0 value                                File descriptor\n      D  mode                           *   value options(*string)               Open mode\n       *\n+     D gzbuffer        PR            10I 0 extproc('gzbuffer')\n+     D  file                               value like(gzFile)                   File pointer\n+     D  size                         10U 0 value\n+      *\n      D gzsetparams     PR            10I 0 extproc('gzsetparams')\n      D  file                               value like(gzFile)                   File pointer\n      D  level                        10I 0 value\n-     D  strategy                     10i 0 value\n+     D  strategy                     10I 0 value\n       *\n      D gzread          PR            10I 0 extproc('gzread')\n      D  file                               value like(gzFile)                   File pointer\n-     D  buf                       32767    options(*varsize)                    Buffer\n+     D  buf                       65535    options(*varsize)                    Buffer\n      D  len                          10u 0 value                                Buffer length\n       *\n      D gzwrite         PR            10I 0 extproc('gzwrite')\n      D  file                               value like(gzFile)                   File pointer\n-     D  buf                       32767    const options(*varsize)              Buffer\n+     D  buf                       65535    const options(*varsize)              Buffer\n      D  len                          10u 0 value                                Buffer length\n       *\n      D gzputs          PR            10I 0 extproc('gzputs')\n@@ -153,27 +179,85 @@\n       *\n      D gzgets          PR              *   extproc('gzgets')\n      D  file                               value like(gzFile)                   File pointer\n-     D  buf                       32767    options(*varsize)                    Read buffer\n+     D  buf                       65535    options(*varsize)                    Read buffer\n      D  len                          10i 0 value                                Buffer length\n       *\n+     D gzputc          PR            10i 0 extproc('gzputc')\n+     D  file                               value like(gzFile)                   File pointer\n+     D  c                            10I 0 value                                Character to write\n+      *\n+     D gzgetc          PR            10i 0 extproc('gzgetc')\n+     D  file                               value like(gzFile)                   File pointer\n+      *\n+     D gzgetc_         PR            10i 0 extproc('gzgetc_')\n+     D  file                               value like(gzFile)                   File pointer\n+      *\n+     D gzungetc        PR            10i 0 extproc('gzungetc')\n+     D  c                            10I 0 value                                Character to push\n+     D  file                               value like(gzFile)                   File pointer\n+      *\n      D gzflush         PR            10i 0 extproc('gzflush')\n      D  file                               value like(gzFile)                   File pointer\n      D  flush                        10I 0 value                                Type of flush\n       *\n+      /if not defined(LARGE_FILES)\n      D gzseek          PR                  extproc('gzseek')\n      D                                     like(z_off_t)\n      D  file                               value like(gzFile)                   File pointer\n      D  offset                             value like(z_off_t)                  Offset\n+     D  whence                       10i 0 value                                Origin\n+      /else\n+     D gzseek          PR                  extproc('gzseek64')\n+     D                                     like(z_off_t)\n+     D  file                               value like(gzFile)                   File pointer\n+     D  offset                             value like(z_off_t)                  Offset\n      D  whence                       10i 0 value                                Origin\n       *\n+     D gzseek64        PR                  extproc('gzseek64')\n+     D                                     like(z_off64_t)\n+     D  file                               value like(gzFile)                   File pointer\n+     D  offset                             value like(z_off64_t)                Offset\n+     D  whence                       10i 0 value                                Origin\n+      /endif\n+      *\n      D gzrewind        PR            10i 0 extproc('gzrewind')\n      D  file                               value like(gzFile)                   File pointer\n       *\n+      /if not defined(LARGE_FILES)\n      D gztell          PR                  extproc('gztell')\n      D                                     like(z_off_t)\n+     D  file                               value like(gzFile)                   File pointer\n+      /else\n+     D gztell          PR                  extproc('gztell64')\n+     D                                     like(z_off_t)\n+     D  file                               value like(gzFile)                   File pointer\n+      *\n+     D gztell64        PR                  extproc('gztell64')\n+     D                                     like(z_off64_t)\n+     D  file                               value like(gzFile)                   File pointer\n+      /endif\n+      *\n+      /if not defined(LARGE_FILES)\n+     D gzoffset        PR                  extproc('gzoffset')\n+     D                                     like(z_off_t)\n+     D  file                               value like(gzFile)                   File pointer\n+      /else\n+     D gzoffset        PR                  extproc('gzoffset64')\n+     D                                     like(z_off_t)\n      D  file                               value like(gzFile)                   File pointer\n       *\n+     D gzoffset64      PR                  extproc('gzoffset64')\n+     D                                     like(z_off64_t)\n+     D  file                               value like(gzFile)                   File pointer\n+      /endif\n+      *\n      D gzeof           PR            10i 0 extproc('gzeof')\n+     D  file                               value like(gzFile)                   File pointer\n+      *\n+     D gzclose_r       PR            10i 0 extproc('gzclose_r')\n+     D  file                               value like(gzFile)                   File pointer\n+      *\n+     D gzclose_w       PR            10i 0 extproc('gzclose_w')\n      D  file                               value like(gzFile)                   File pointer\n       *\n      D gzclose         PR            10i 0 extproc('gzclose')\n@@ -234,7 +318,7 @@\n      D deflateSetDictionary...\n      D                 PR            10I 0 extproc('deflateSetDictionary')      Init. dictionary\n      D  strm                               like(z_stream)                       Compression stream\n-     D  dictionary                32767    const options(*varsize)              Dictionary bytes\n+     D  dictionary                65535    const options(*varsize)              Dictionary bytes\n      D  dictLength                   10U 0 value                                Dictionary length\n       *\n      D deflateCopy     PR            10I 0 extproc('deflateCopy')               Compress strm 2 strm\n@@ -253,9 +337,14 @@\n      D  strm                               like(z_stream)                       Compression stream\n      D  sourcelen                    10U 0 value                                Compression level\n       *\n+     D deflatePending  PR            10I 0 extproc('deflatePending')            Change level & strat\n+     D  strm                               like(z_stream)                       Compression stream\n+     D  pending                      10U 0                                      Pending bytes\n+     D  bits                         10I 0                                      Pending bits\n+      *\n      D deflatePrime    PR            10I 0 extproc('deflatePrime')              Change level & strat\n      D  strm                               like(z_stream)                       Compression stream\n-     D  bits                         10I 0 value                                Number of bits to insert\n+     D  bits                         10I 0 value                                # of bits to insert\n      D  value                        10I 0 value                                Bits to insert\n       *\n      D inflateInit2    PR            10I 0 extproc('inflateInit2_')             Init. expansion\n@@ -267,7 +356,7 @@\n      D inflateSetDictionary...\n      D                 PR            10I 0 extproc('inflateSetDictionary')      Init. dictionary\n      D  strm                               like(z_stream)                       Expansion stream\n-     D  dictionary                32767    const options(*varsize)              Dictionary bytes\n+     D  dictionary                65535    const options(*varsize)              Dictionary bytes\n      D  dictLength                   10U 0 value                                Dictionary length\n       *\n      D inflateSync     PR            10I 0 extproc('inflateSync')               Sync. expansion\n@@ -278,13 +367,25 @@\n      D  source                             like(z_stream)                       Source stream\n       *\n      D inflateReset    PR            10I 0 extproc('inflateReset')              End and init. stream\n+     D  strm                               like(z_stream)                       Expansion stream\n+      *\n+     D inflateReset2   PR            10I 0 extproc('inflateReset2')             End and init. stream\n+     D  strm                               like(z_stream)                       Expansion stream\n+     D  windowBits                   10I 0 value                                Log2(buffer size)\n+      *\n+     D inflatePrime    PR            10I 0 extproc('inflatePrime')              Insert bits\n+     D  strm                               like(z_stream)                       Expansion stream\n+     D  bits                         10I 0 value                                Bit count\n+     D  value                        10I 0 value                                Bits to insert\n+      *\n+     D inflateMark     PR            10I 0 extproc('inflateMark')               Get inflate info\n      D  strm                               like(z_stream)                       Expansion stream\n       *\n      D inflateBackInit...\n      D                 PR            10I 0 extproc('inflateBackInit_')\n      D  strm                               like(z_stream)                       Expansion stream\n      D  windowBits                   10I 0 value                                Log2(buffer size)\n-     D  window                    32767    options(*varsize)                    Buffer\n+     D  window                    65535    options(*varsize)                    Buffer\n      D  version                        *   value options(*string)               Version string\n      D  stream_size                  10i 0 value                                Stream struct. size\n       *\n@@ -307,12 +408,12 @@\n       *\n      D adler32         PR            10U 0 extproc('adler32')                   New checksum\n      D  adler                        10U 0 value                                Old checksum\n-     D  buf                       32767    const options(*varsize)              Bytes to accumulate\n+     D  buf                       65535    const options(*varsize)              Bytes to accumulate\n      D  len                          10U 0 value                                Buffer length\n       *\n      D crc32           PR            10U 0 extproc('crc32')                     New checksum\n      D  crc                          10U 0 value                                Old checksum\n-     D  buf                       32767    const options(*varsize)              Bytes to accumulate\n+     D  buf                       65535    const options(*varsize)              Bytes to accumulate\n      D  len                          10U 0 value                                Buffer length\n       *\n       **************************************************************************\n@@ -328,4 +429,17 @@\n       *\n      D get_crc_table   PR              *   extproc('get_crc_table')             Ptr to ulongs\n       *\n+     D inflateUndermine...\n+     D                 PR            10I 0 extproc('inflateUndermine')\n+     D  strm                               like(z_stream)                       Expansion stream\n+     D  arg                          10I 0 value                                Error code\n+      *\n+     D inflateResetKeep...\n+     D                 PR            10I 0 extproc('inflateResetKeep')          End and init. stream\n+     D  strm                               like(z_stream)                       Expansion stream\n+      *\n+     D deflateResetKeep...\n+     D                 PR            10I 0 extproc('deflateResetKeep')          End and init. stream\n+     D  strm                               like(z_stream)                       Expansion stream\n+      *\n       /endif", "previous_filename": "zlib/old/as400/zlib.inc"}, {"sha": "fa421092785d4ca295de262f3a2c6dffa4137f1b", "filename": "zlib/contrib/asm686/match.S", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fasm686%2Fmatch.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fasm686%2Fmatch.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm686%2Fmatch.S?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -83,17 +83,25 @@\n .text\n \n /* uInt longest_match(deflate_state *deflatestate, IPos curmatch) */\n+.cfi_sections\t.debug_frame\n \n longest_match:\n \n+.cfi_startproc\n /* Save registers that the compiler may be using, and adjust %esp to\t*/\n /* make room for our stack frame.\t\t\t\t\t*/\n \n \t\tpushl\t%ebp\n+\t\t.cfi_def_cfa_offset 8\n+\t\t.cfi_offset ebp, -8\n \t\tpushl\t%edi\n+\t\t.cfi_def_cfa_offset 12\n \t\tpushl\t%esi\n+\t\t.cfi_def_cfa_offset 16\n \t\tpushl\t%ebx\n+\t\t.cfi_def_cfa_offset 20\n \t\tsubl\t$LocalVarsSize, %esp\n+\t\t.cfi_def_cfa_offset LocalVarsSize+20\n \n /* Retrieve the function arguments. %ecx will hold cur_match\t\t*/\n /* throughout the entire function. %edx will hold the pointer to the\t*/\n@@ -108,7 +116,7 @@ longest_match:\n /* if (s->prev_length >= s->good_match) {\t\t\t\t*/\n /*     chain_length >>= 2;\t\t\t\t\t\t*/\n /* }\t\t\t\t\t\t\t\t\t*/\n-\n+ \n \t\tmovl\tdsPrevLen(%edx), %eax\n \t\tmovl\tdsGoodMatch(%edx), %ebx\n \t\tcmpl\t%ebx, %eax\n@@ -336,8 +344,14 @@ LookaheadRet:\n /* Restore the stack and return from whence we came.\t\t\t*/\n \n \t\taddl\t$LocalVarsSize, %esp\n+\t\t.cfi_def_cfa_offset 20\n \t\tpopl\t%ebx\n+\t\t.cfi_def_cfa_offset 16\n \t\tpopl\t%esi\n+\t\t.cfi_def_cfa_offset 12\n \t\tpopl\t%edi\n+\t\t.cfi_def_cfa_offset 8\n \t\tpopl\t%ebp\n+\t\t.cfi_def_cfa_offset 4\n+.cfi_endproc\n match_init:\tret"}, {"sha": "f24bb3eda0e8d8c94aa7cf9289e2d7a2afe42dee", "filename": "zlib/contrib/delphi/ZLib.pas", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fdelphi%2FZLib.pas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fdelphi%2FZLib.pas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi%2FZLib.pas?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -152,7 +152,7 @@ procedure DecompressToUserBuf(const InBuf: Pointer; InBytes: Integer;\n   const OutBuf: Pointer; BufSize: Integer);\n \n const\n-  zlib_version = '1.2.5';\n+  zlib_version = '1.2.7';\n \n type\n   EZlibError = class(Exception);"}, {"sha": "9bb00b7cc4211c89db28d55443910aeab505fe44", "filename": "zlib/contrib/delphi/zlibd32.mak", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fdelphi%2Fzlibd32.mak", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fdelphi%2Fzlibd32.mak", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi%2Fzlibd32.mak?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -63,9 +63,9 @@ uncompr.obj: uncompr.c zlib.h zconf.h\n \n zutil.obj: zutil.c zutil.h zlib.h zconf.h\n \n-example.obj: example.c zlib.h zconf.h\n+example.obj: test/example.c zlib.h zconf.h\n \n-minigzip.obj: minigzip.c zlib.h zconf.h\n+minigzip.obj: test/minigzip.c zlib.h zconf.h\n \n \n # For the sake of the old Borland make,"}, {"sha": "109028841d6559fa4edef88605e1fa61bdf1be9a", "filename": "zlib/contrib/dotzlib/DotZLib/UnitTests.cs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FUnitTests.cs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FUnitTests.cs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FUnitTests.cs?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -156,7 +156,7 @@ public class InfoTests\n         public void Info_Version()\r\n         {\r\n             Info info = new Info();\r\n-            Assert.AreEqual(\"1.2.5\", Info.Version);\r\n+            Assert.AreEqual(\"1.2.7\", Info.Version);\r\n             Assert.AreEqual(32, info.SizeOfUInt);\r\n             Assert.AreEqual(32, info.SizeOfULong);\r\n             Assert.AreEqual(32, info.SizeOfPointer);\r"}, {"sha": "5a0b3287efb50ae378c7d97be8ca07d851ca1048", "filename": "zlib/contrib/infback9/inftree9.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Finfback9%2Finftree9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Finfback9%2Finftree9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Finfback9%2Finftree9.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,5 +1,5 @@\n /* inftree9.c -- generate Huffman trees for efficient decoding\n- * Copyright (C) 1995-2010 Mark Adler\n+ * Copyright (C) 1995-2012 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -9,7 +9,7 @@\n #define MAXBITS 15\n \n const char inflate9_copyright[] =\n-   \" inflate9 1.2.5 Copyright 1995-2010 Mark Adler \";\n+   \" inflate9 1.2.7 Copyright 1995-2012 Mark Adler \";\n /*\n   If you use the zlib library in a product, an acknowledgment is welcome\n   in the documentation of your product. If for some reason you cannot\n@@ -64,7 +64,7 @@ unsigned short FAR *work;\n     static const unsigned short lext[31] = { /* Length codes 257..285 extra */\n         128, 128, 128, 128, 128, 128, 128, 128, 129, 129, 129, 129,\n         130, 130, 130, 130, 131, 131, 131, 131, 132, 132, 132, 132,\n-        133, 133, 133, 133, 144, 73, 195};\n+        133, 133, 133, 133, 144, 78, 68};\n     static const unsigned short dbase[32] = { /* Distance codes 0..31 base */\n         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49,\n         65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073,"}, {"sha": "03d20f838bfbb0b73a6d2fb35f4363add2af74ad", "filename": "zlib/contrib/masmx86/inffas32.asm", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fmasmx86%2Finffas32.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fmasmx86%2Finffas32.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx86%2Finffas32.asm?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -73,11 +73,6 @@ inflate_fast_use_mmx:\n \r\n \r\n _TEXT\t\t\tsegment\r\n-PUBLIC _inflate_fast\r\n-\r\n-ALIGN 4\r\n-_inflate_fast:\r\n-\tjmp inflate_fast_entry\r\n \r\n \r\n \r\n@@ -163,7 +158,8 @@ distbits_state\t equ\t(76+4+zlib1222sup)\t;/* state->distbits */\n ;SECTION .text\r\n \r\n ALIGN 4\r\n-inflate_fast_entry:\r\n+_inflate_fast proc near\r\n+.FPO (16, 4, 0, 0, 1, 0)\r\n \tpush  edi\r\n \tpush  esi\r\n \tpush  ebp\r\n@@ -1078,6 +1074,7 @@ L_done:\n \tpop  esi\r\n \tpop  edi\r\n \tret\r\n+_inflate_fast endp\r\n \r\n _TEXT\tends\r\n end\r"}, {"sha": "3b09212f8a29916959be48a7cc920d423794c60c", "filename": "zlib/contrib/masmx86/match686.asm", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fmasmx86%2Fmatch686.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fmasmx86%2Fmatch686.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx86%2Fmatch686.asm?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -195,6 +195,7 @@ dsNiceMatch equ 136+zlib1222add\n     ELSE\r\n     _longest_match      proc near\r\n     ENDIF\r\n+.FPO (9, 4, 0, 0, 1, 0)\r\n \r\n ;;; Save registers that the compiler may be using, and adjust esp to\r\n ;;; make room for our stack frame.\r"}, {"sha": "d343011ebc3b3fd78d2bc3a29801a083c038cf0c", "filename": "zlib/contrib/minizip/Makefile.am", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2FMakefile.am?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -0,0 +1,45 @@\n+lib_LTLIBRARIES = libminizip.la\n+\n+if COND_DEMOS\n+bin_PROGRAMS = miniunzip minizip\n+endif\n+\n+zlib_top_srcdir = $(top_srcdir)/../..\n+zlib_top_builddir = $(top_builddir)/../..\n+\n+AM_CPPFLAGS = -I$(zlib_top_srcdir)\n+AM_LDFLAGS = -L$(zlib_top_builddir)\n+\n+if WIN32\n+iowin32_src = iowin32.c\n+iowin32_h = iowin32.h\n+endif\n+\n+libminizip_la_SOURCES = \\\n+\tioapi.c \\\n+\tmztools.c \\\n+\tunzip.c \\\n+\tzip.c \\\n+\t${iowin32_src}\n+\n+libminizip_la_LDFLAGS = $(AM_LDFLAGS) -version-info 1:0:0 -lz\n+\n+minizip_includedir = $(includedir)/minizip\n+minizip_include_HEADERS = \\\n+\tcrypt.h \\\n+\tioapi.h \\\n+\tmztools.h \\\n+\tunzip.h \\\n+\tzip.h \\\n+\t${iowin32_h}\n+\n+pkgconfigdir = $(libdir)/pkgconfig\n+pkgconfig_DATA = minizip.pc\n+\n+EXTRA_PROGRAMS = miniunzip minizip\n+\n+miniunzip_SOURCES = miniunz.c\n+miniunzip_LDADD = libminizip.la\n+\n+minizip_SOURCES = minizip.c\n+minizip_LDADD = libminizip.la -lz"}, {"sha": "6a9af21c317e81ba986a30da2092c72eb2387611", "filename": "zlib/contrib/minizip/configure.ac", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fconfigure.ac?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -0,0 +1,32 @@\n+#                                               -*- Autoconf -*-\n+# Process this file with autoconf to produce a configure script.\n+\n+AC_INIT([minizip], [1.2.7], [bugzilla.redhat.com])\n+AC_CONFIG_SRCDIR([minizip.c])\n+AM_INIT_AUTOMAKE([foreign])\n+LT_INIT\n+\n+AC_MSG_CHECKING([whether to build example programs])\n+AC_ARG_ENABLE([demos], AC_HELP_STRING([--enable-demos], [build example programs]))\n+AM_CONDITIONAL([COND_DEMOS], [test \"$enable_demos\" = yes])\n+if test \"$enable_demos\" = yes\n+then\n+\tAC_MSG_RESULT([yes])\n+else\n+\tAC_MSG_RESULT([no])\n+fi\n+\n+case \"${host}\" in\n+\t*-mingw* | mingw*)\n+\t\tWIN32=\"yes\"\n+\t\t;;\n+\t*)\n+\t\t;;\n+esac\n+AM_CONDITIONAL([WIN32], [test \"${WIN32}\" = \"yes\"])\n+\n+\n+AC_SUBST([HAVE_UNISTD_H], [0])\n+AC_CHECK_HEADER([unistd.h], [HAVE_UNISTD_H=1], [])\n+AC_CONFIG_FILES([Makefile minizip.pc])\n+AC_OUTPUT"}, {"sha": "7f5c191b2afd1624a653afafad3fef722e864bc3", "filename": "zlib/contrib/minizip/ioapi.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fioapi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fioapi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fioapi.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -10,10 +10,22 @@\n \n */\n \n-#if (defined(_WIN32))\n+#if defined(_WIN32) && (!(defined(_CRT_SECURE_NO_WARNINGS)))\n         #define _CRT_SECURE_NO_WARNINGS\n #endif\n \n+#if defined(__APPLE__) || defined(IOAPI_NO_64)\n+// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions\n+#define FOPEN_FUNC(filename, mode) fopen(filename, mode)\n+#define FTELLO_FUNC(stream) ftello(stream)\n+#define FSEEKO_FUNC(stream, offset, origin) fseeko(stream, offset, origin)\n+#else\n+#define FOPEN_FUNC(filename, mode) fopen64(filename, mode)\n+#define FTELLO_FUNC(stream) ftello64(stream)\n+#define FSEEKO_FUNC(stream, offset, origin) fseeko64(stream, offset, origin)\n+#endif\n+\n+\n #include \"ioapi.h\"\n \n voidpf call_zopen64 (const zlib_filefunc64_32_def* pfilefunc,const void*filename,int mode)\n@@ -47,7 +59,7 @@ ZPOS64_T call_ztell64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream\n     else\n     {\n         uLong tell_uLong = (*(pfilefunc->ztell32_file))(pfilefunc->zfile_func64.opaque,filestream);\n-        if ((tell_uLong) == ((uLong)-1))\n+        if ((tell_uLong) == MAXU32)\n             return (ZPOS64_T)-1;\n         else\n             return tell_uLong;\n@@ -112,7 +124,7 @@ static voidpf ZCALLBACK fopen64_file_func (voidpf opaque, const void* filename,\n         mode_fopen = \"wb\";\n \n     if ((filename!=NULL) && (mode_fopen != NULL))\n-        file = fopen64((const char*)filename, mode_fopen);\n+        file = FOPEN_FUNC((const char*)filename, mode_fopen);\n     return file;\n }\n \n@@ -142,7 +154,7 @@ static long ZCALLBACK ftell_file_func (voidpf opaque, voidpf stream)\n static ZPOS64_T ZCALLBACK ftell64_file_func (voidpf opaque, voidpf stream)\n {\n     ZPOS64_T ret;\n-    ret = ftello64((FILE *)stream);\n+    ret = FTELLO_FUNC((FILE *)stream);\n     return ret;\n }\n \n@@ -188,7 +200,7 @@ static long ZCALLBACK fseek64_file_func (voidpf  opaque, voidpf stream, ZPOS64_T\n     }\n     ret = 0;\n \n-    if(fseeko64((FILE *)stream, offset, fseek_origin) != 0)\n+    if(FSEEKO_FUNC((FILE *)stream, offset, fseek_origin) != 0)\n                         ret = -1;\n \n     return ret;"}, {"sha": "8dcbdb06e35ad55a11e342ccc052b85a1c807ddd", "filename": "zlib/contrib/minizip/ioapi.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fioapi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fioapi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fioapi.h?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -21,7 +21,7 @@\n #ifndef _ZLIBIOAPI64_H\n #define _ZLIBIOAPI64_H\n \n-#if (!defined(_WIN32)) && (!defined(WIN32))\n+#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))\n \n   // Linux needs this to support file operation on files larger then 4+GB\n   // But might need better if/def to select just the platforms that needs them.\n@@ -38,6 +38,7 @@\n         #ifndef _FILE_OFFSET_BIT\n                 #define _FILE_OFFSET_BIT 64\n         #endif\n+\n #endif\n \n #include <stdio.h>\n@@ -49,6 +50,11 @@\n #define ftello64 ftell\n #define fseeko64 fseek\n #else\n+#ifdef __FreeBSD__\n+#define fopen64 fopen\n+#define ftello64 ftello\n+#define fseeko64 fseeko\n+#endif\n #ifdef _MSC_VER\n  #define fopen64 fopen\n  #if (_MSC_VER >= 1400) && (!(defined(NO_MSCVER_FILE64_FUNC)))\n@@ -85,6 +91,8 @@ typedef  64BIT_INT_CUSTOM_TYPE ZPOS64_T;\n typedef uint64_t ZPOS64_T;\n #else\n \n+/* Maximum unsigned 32-bit value used as placeholder for zip64 */\n+#define MAXU32 0xffffffff\n \n #if defined(_MSC_VER) || defined(__BORLANDC__)\n typedef unsigned __int64 ZPOS64_T;"}, {"sha": "3d65401be5cdd7b58c57d681e28347278942917b", "filename": "zlib/contrib/minizip/miniunz.c", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fminiunz.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fminiunz.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fminiunz.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -12,7 +12,7 @@\n          Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )\n */\n \n-#ifndef _WIN32\n+#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))\n         #ifndef __USE_FILE_OFFSET64\n                 #define __USE_FILE_OFFSET64\n         #endif\n@@ -27,21 +27,34 @@\n         #endif\n #endif\n \n+#ifdef __APPLE__\n+// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions\n+#define FOPEN_FUNC(filename, mode) fopen(filename, mode)\n+#define FTELLO_FUNC(stream) ftello(stream)\n+#define FSEEKO_FUNC(stream, offset, origin) fseeko(stream, offset, origin)\n+#else\n+#define FOPEN_FUNC(filename, mode) fopen64(filename, mode)\n+#define FTELLO_FUNC(stream) ftello64(stream)\n+#define FSEEKO_FUNC(stream, offset, origin) fseeko64(stream, offset, origin)\n+#endif\n+\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n #include <time.h>\n #include <errno.h>\n #include <fcntl.h>\n \n-#ifdef unix\n-# include <unistd.h>\n-# include <utime.h>\n-#else\n+#ifdef _WIN32\n # include <direct.h>\n # include <io.h>\n+#else\n+# include <unistd.h>\n+# include <utime.h>\n #endif\n \n+\n #include \"unzip.h\"\n \n #define CASESENSITIVITY (0)\n@@ -84,7 +97,7 @@ void change_file_date(filename,dosdate,tmu_date)\n   SetFileTime(hFile,&ftm,&ftLastAcc,&ftm);\n   CloseHandle(hFile);\n #else\n-#ifdef unix\n+#ifdef unix || __APPLE__\n   struct utimbuf ut;\n   struct tm newdate;\n   newdate.tm_sec = tmu_date.tm_sec;\n@@ -114,10 +127,10 @@ int mymkdir(dirname)\n     int ret=0;\n #ifdef _WIN32\n     ret = _mkdir(dirname);\n-#else\n-#ifdef unix\n+#elif unix\n+    ret = mkdir (dirname,0775);\n+#elif __APPLE__\n     ret = mkdir (dirname,0775);\n-#endif\n #endif\n     return ret;\n }\n@@ -364,7 +377,7 @@ int do_extract_currentfile(uf,popt_extract_without_path,popt_overwrite,password)\n         {\n             char rep=0;\n             FILE* ftestexist;\n-            ftestexist = fopen64(write_filename,\"rb\");\n+            ftestexist = FOPEN_FUNC(write_filename,\"rb\");\n             if (ftestexist!=NULL)\n             {\n                 fclose(ftestexist);\n@@ -395,8 +408,7 @@ int do_extract_currentfile(uf,popt_extract_without_path,popt_overwrite,password)\n \n         if ((skip==0) && (err==UNZ_OK))\n         {\n-            fout=fopen64(write_filename,\"wb\");\n-\n+            fout=FOPEN_FUNC(write_filename,\"wb\");\n             /* some zipfile don't contain directory alone before file */\n             if ((fout==NULL) && ((*popt_extract_without_path)==0) &&\n                                 (filename_withoutpath!=(char*)filename_inzip))\n@@ -405,7 +417,7 @@ int do_extract_currentfile(uf,popt_extract_without_path,popt_overwrite,password)\n                 *(filename_withoutpath-1)='\\0';\n                 makedir(write_filename);\n                 *(filename_withoutpath-1)=c;\n-                fout=fopen64(write_filename,\"wb\");\n+                fout=FOPEN_FUNC(write_filename,\"wb\");\n             }\n \n             if (fout==NULL)"}, {"sha": "4288962ecef05681db4c62bfa13b2f090b9ce6a8", "filename": "zlib/contrib/minizip/minizip.c", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fminizip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fminizip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fminizip.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -13,7 +13,7 @@\n */\n \n \n-#ifndef _WIN32\n+#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))\n         #ifndef __USE_FILE_OFFSET64\n                 #define __USE_FILE_OFFSET64\n         #endif\n@@ -28,21 +28,34 @@\n         #endif\n #endif\n \n+#ifdef __APPLE__\n+// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions\n+#define FOPEN_FUNC(filename, mode) fopen(filename, mode)\n+#define FTELLO_FUNC(stream) ftello(stream)\n+#define FSEEKO_FUNC(stream, offset, origin) fseeko(stream, offset, origin)\n+#else\n+#define FOPEN_FUNC(filename, mode) fopen64(filename, mode)\n+#define FTELLO_FUNC(stream) ftello64(stream)\n+#define FSEEKO_FUNC(stream, offset, origin) fseeko64(stream, offset, origin)\n+#endif\n+\n+\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n #include <time.h>\n #include <errno.h>\n #include <fcntl.h>\n \n-#ifdef unix\n+#ifdef _WIN32\n+# include <direct.h>\n+# include <io.h>\n+#else\n # include <unistd.h>\n # include <utime.h>\n # include <sys/types.h>\n # include <sys/stat.h>\n-#else\n-# include <direct.h>\n-# include <io.h>\n #endif\n \n #include \"zip.h\"\n@@ -81,7 +94,7 @@ uLong filetime(f, tmzip, dt)\n   return ret;\n }\n #else\n-#ifdef unix\n+#ifdef unix || __APPLE__\n uLong filetime(f, tmzip, dt)\n     char *f;               /* name of file to get info on */\n     tm_zip *tmzip;         /* return value: access, modific. and creation times */\n@@ -142,7 +155,7 @@ int check_exist_file(filename)\n {\n     FILE* ftestexist;\n     int ret = 1;\n-    ftestexist = fopen64(filename,\"rb\");\n+    ftestexist = FOPEN_FUNC(filename,\"rb\");\n     if (ftestexist==NULL)\n         ret = 0;\n     else\n@@ -173,7 +186,8 @@ int getFileCrc(const char* filenameinzip,void*buf,unsigned long size_buf,unsigne\n {\n    unsigned long calculate_crc=0;\n    int err=ZIP_OK;\n-   FILE * fin = fopen64(filenameinzip,\"rb\");\n+   FILE * fin = FOPEN_FUNC(filenameinzip,\"rb\");\n+\n    unsigned long size_read = 0;\n    unsigned long total_read = 0;\n    if (fin==NULL)\n@@ -211,13 +225,12 @@ int isLargeFile(const char* filename)\n {\n   int largeFile = 0;\n   ZPOS64_T pos = 0;\n-  FILE* pFile = fopen64(filename, \"rb\");\n+  FILE* pFile = FOPEN_FUNC(filename, \"rb\");\n \n   if(pFile != NULL)\n   {\n-    int n = fseeko64(pFile, 0, SEEK_END);\n-\n-    pos = ftello64(pFile);\n+    int n = FSEEKO_FUNC(pFile, 0, SEEK_END);\n+    pos = FTELLO_FUNC(pFile);\n \n                 printf(\"File : %s is %lld bytes\\n\", filename, pos);\n \n@@ -447,7 +460,7 @@ int main(argc,argv)\n                     printf(\"error in opening %s in zipfile\\n\",filenameinzip);\n                 else\n                 {\n-                    fin = fopen64(filenameinzip,\"rb\");\n+                    fin = FOPEN_FUNC(filenameinzip,\"rb\");\n                     if (fin==NULL)\n                     {\n                         err=ZIP_ERRNO;"}, {"sha": "69b5b7fdcb3b4ae67ac7f9ee23733a59dac7e665", "filename": "zlib/contrib/minizip/minizip.pc.in", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fminizip.pc.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fminizip.pc.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fminizip.pc.in?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -0,0 +1,12 @@\n+prefix=@prefix@\n+exec_prefix=@exec_prefix@\n+libdir=@libdir@\n+includedir=@includedir@/minizip\n+\n+Name: minizip\n+Description: Minizip zip file manipulation library\n+Requires:\n+Version: @PACKAGE_VERSION@\n+Libs: -L${libdir} -lminizip\n+Libs.private: -lz\n+Cflags: -I${includedir}"}, {"sha": "96891c2e0b71ef95a50a0c3271c83e5a2123d025", "filename": "zlib/contrib/minizip/mztools.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fmztools.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fmztools.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fmztools.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -42,7 +42,7 @@ uLong* bytesRecovered;\n     int entries = 0;\n     uLong totalBytes = 0;\n     char header[30];\n-    char filename[256];\n+    char filename[1024];\n     char extra[1024];\n     int offset = 0;\n     int offsetCD = 0;\n@@ -73,9 +73,14 @@ uLong* bytesRecovered;\n \n         /* Filename */\n         if (fnsize > 0) {\n-          if (fread(filename, 1, fnsize, fpZip) == fnsize) {\n-            if (fwrite(filename, 1, fnsize, fpOut) == fnsize) {\n-              offset += fnsize;\n+          if (fnsize < sizeof(filename)) {\n+            if (fread(filename, 1, fnsize, fpZip) == fnsize) {\n+                if (fwrite(filename, 1, fnsize, fpOut) == fnsize) {\n+                offset += fnsize;\n+              } else {\n+                err = Z_ERRNO;\n+                break;\n+              }\n             } else {\n               err = Z_ERRNO;\n               break;\n@@ -91,9 +96,14 @@ uLong* bytesRecovered;\n \n         /* Extra field */\n         if (extsize > 0) {\n-          if (fread(extra, 1, extsize, fpZip) == extsize) {\n-            if (fwrite(extra, 1, extsize, fpOut) == extsize) {\n-              offset += extsize;\n+          if (extsize < sizeof(extra)) {\n+            if (fread(extra, 1, extsize, fpZip) == extsize) {\n+              if (fwrite(extra, 1, extsize, fpOut) == extsize) {\n+                offset += extsize;\n+                } else {\n+                err = Z_ERRNO;\n+                break;\n+              }\n             } else {\n               err = Z_ERRNO;\n               break;"}, {"sha": "a49a426ec2fcb279995806adbfd2ed48e781f616", "filename": "zlib/contrib/minizip/mztools.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fmztools.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fmztools.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fmztools.h?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -28,4 +28,10 @@ extern int ZEXPORT unzRepair(const char* file,\n                              uLong* nRecovered,\n                              uLong* bytesRecovered);\n \n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+\n #endif"}, {"sha": "affad4bfeb270eb0ae049862240c52918102d6bc", "filename": "zlib/contrib/minizip/unzip.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Funzip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Funzip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Funzip.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1040,26 +1040,26 @@ local int unz64local_GetCurrentFileInfoInternal (unzFile file,\n             {\n                                                         uLong uL;\n \n-                                                                if(file_info.uncompressed_size == (ZPOS64_T)(unsigned long)-1)\n+                                                                if(file_info.uncompressed_size == MAXU32)\n                                                                 {\n                                                                         if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.uncompressed_size) != UNZ_OK)\n                                                                                         err=UNZ_ERRNO;\n                                                                 }\n \n-                                                                if(file_info.compressed_size == (ZPOS64_T)(unsigned long)-1)\n+                                                                if(file_info.compressed_size == MAXU32)\n                                                                 {\n                                                                         if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.compressed_size) != UNZ_OK)\n                                                                                   err=UNZ_ERRNO;\n                                                                 }\n \n-                                                                if(file_info_internal.offset_curfile == (ZPOS64_T)(unsigned long)-1)\n+                                                                if(file_info_internal.offset_curfile == MAXU32)\n                                                                 {\n                                                                         /* Relative Header offset */\n                                                                         if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info_internal.offset_curfile) != UNZ_OK)\n                                                                                 err=UNZ_ERRNO;\n                                                                 }\n \n-                                                                if(file_info.disk_num_start == (unsigned long)-1)\n+                                                                if(file_info.disk_num_start == MAXU32)\n                                                                 {\n                                                                         /* Disk Start Number */\n                                                                         if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)\n@@ -1145,7 +1145,7 @@ extern int ZEXPORT unzGetCurrentFileInfo (unzFile file,\n                                                 szFileName,fileNameBufferSize,\n                                                 extraField,extraFieldBufferSize,\n                                                 szComment,commentBufferSize);\n-    if (err==UNZ_OK)\n+    if ((err==UNZ_OK) && (pfile_info != NULL))\n     {\n         pfile_info->version = file_info64.version;\n         pfile_info->version_needed = file_info64.version_needed;\n@@ -1696,7 +1696,7 @@ extern int ZEXPORT unzReadCurrentFile  (unzFile file, voidp buf, unsigned len)\n         return UNZ_PARAMERROR;\n \n \n-    if ((pfile_in_zip_read_info->read_buffer == NULL))\n+    if (pfile_in_zip_read_info->read_buffer == NULL)\n         return UNZ_END_OF_LIST_OF_FILE;\n     if (len==0)\n         return 0;"}, {"sha": "147934c75d3f5a8ee3ebabc0d7d8df1a05dd3d4e", "filename": "zlib/contrib/minizip/zip.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fzip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fminizip%2Fzip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fzip.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1067,6 +1067,7 @@ extern int ZEXPORT zipOpenNewFileInZip4_64 (zipFile file, const char* filename,\n     int err = ZIP_OK;\n \n #    ifdef NOCRYPT\n+    (crcForCrypting);\n     if (password != NULL)\n         return ZIP_PARAMERROR;\n #    endif\n@@ -1114,9 +1115,9 @@ extern int ZEXPORT zipOpenNewFileInZip4_64 (zipFile file, const char* filename,\n     zi->ci.flag = flagBase;\n     if ((level==8) || (level==9))\n       zi->ci.flag |= 2;\n-    if ((level==2))\n+    if (level==2)\n       zi->ci.flag |= 4;\n-    if ((level==1))\n+    if (level==1)\n       zi->ci.flag |= 6;\n     if (password != NULL)\n       zi->ci.flag |= 1;\n@@ -1710,7 +1711,7 @@ extern int ZEXPORT zipCloseFileInZipRaw64 (zipFile file, ZPOS64_T uncompressed_s\n         if (err==ZIP_OK)\n             err = zip64local_putValue(&zi->z_filefunc,zi->filestream,crc32,4); /* crc 32, unknown */\n \n-        if(uncompressed_size >= 0xffffffff)\n+        if(uncompressed_size >= 0xffffffff || compressed_size >= 0xffffffff )\n         {\n           if(zi->ci.pos_zip64extrainfo > 0)\n           {\n@@ -1724,6 +1725,8 @@ extern int ZEXPORT zipCloseFileInZipRaw64 (zipFile file, ZPOS64_T uncompressed_s\n             if (err==ZIP_OK) /* uncompressed size, unknown */\n               err = zip64local_putValue(&zi->z_filefunc, zi->filestream, compressed_size, 8);\n           }\n+          else\n+              err = ZIP_BADZIPFILE; // Caller passed zip64 = 0, so no room for zip64 info -> fatal\n         }\n         else\n         {\n@@ -1852,7 +1855,7 @@ int Write_EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir,\n       err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)0xffffffff,4);\n     }\n     else\n-                  err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)(centraldir_pos_inzip - zi->add_position_when_writting_offset),4);\n+      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)(centraldir_pos_inzip - zi->add_position_when_writting_offset),4);\n   }\n \n    return err;\n@@ -1919,7 +1922,7 @@ extern int ZEXPORT zipClose (zipFile file, const char* global_comment)\n     free_linkedlist(&(zi->central_dir));\n \n     pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;\n-    if(pos >= 0xffffffff)\n+    if(pos >= 0xffffffff || zi->number_entry > 0xFFFF)\n     {\n       ZPOS64_T Zip64EOCDpos = ZTELL64(zi->z_filefunc,zi->filestream);\n       Write_Zip64EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);"}, {"sha": "9bb00b7cc4211c89db28d55443910aeab505fe44", "filename": "zlib/contrib/pascal/zlibd32.mak", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fpascal%2Fzlibd32.mak", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fpascal%2Fzlibd32.mak", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpascal%2Fzlibd32.mak?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -63,9 +63,9 @@ uncompr.obj: uncompr.c zlib.h zconf.h\n \n zutil.obj: zutil.c zutil.h zlib.h zconf.h\n \n-example.obj: example.c zlib.h zconf.h\n+example.obj: test/example.c zlib.h zconf.h\n \n-minigzip.obj: minigzip.c zlib.h zconf.h\n+minigzip.obj: test/minigzip.c zlib.h zconf.h\n \n \n # For the sake of the old Borland make,"}, {"sha": "7abd862ae66096007ab2a775b6cdd8008405907d", "filename": "zlib/contrib/pascal/zlibpas.pas", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fpascal%2Fzlibpas.pas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fpascal%2Fzlibpas.pas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpascal%2Fzlibpas.pas?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -10,7 +10,8 @@\n interface\n \n const\n-  ZLIB_VERSION = '1.2.5';\n+  ZLIB_VERSION = '1.2.7';\n+  ZLIB_VERNUM  = $1270;\n \n type\n   alloc_func = function(opaque: Pointer; items, size: Integer): Pointer;\n@@ -45,13 +46,32 @@ interface\n     reserved: LongInt;    (* reserved for future use *)\n   end;\n \n+  gz_headerp = ^gz_header;\n+  gz_header = packed record\n+    text: Integer;        (* true if compressed data believed to be text *)\n+    time: LongInt;        (* modification time *)\n+    xflags: Integer;      (* extra flags (not used when writing a gzip file) *)\n+    os: Integer;          (* operating system *)\n+    extra: PChar;         (* pointer to extra field or Z_NULL if none *)\n+    extra_len: Integer;   (* extra field length (valid if extra != Z_NULL) *)\n+    extra_max: Integer;   (* space at extra (only when reading header) *)\n+    name: PChar;          (* pointer to zero-terminated file name or Z_NULL *)\n+    name_max: Integer;    (* space at name (only when reading header) *)\n+    comment: PChar;       (* pointer to zero-terminated comment or Z_NULL *)\n+    comm_max: Integer;    (* space at comment (only when reading header) *)\n+    hcrc: Integer;        (* true if there was or will be a header crc *)\n+    done: Integer;        (* true when done reading gzip header *)\n+  end;\n+\n (* constants *)\n const\n   Z_NO_FLUSH      = 0;\n   Z_PARTIAL_FLUSH = 1;\n   Z_SYNC_FLUSH    = 2;\n   Z_FULL_FLUSH    = 3;\n   Z_FINISH        = 4;\n+  Z_BLOCK         = 5;\n+  Z_TREES         = 6;\n \n   Z_OK            =  0;\n   Z_STREAM_END    =  1;\n@@ -71,9 +91,11 @@ interface\n   Z_FILTERED            = 1;\n   Z_HUFFMAN_ONLY        = 2;\n   Z_RLE                 = 3;\n+  Z_FIXED               = 4;\n   Z_DEFAULT_STRATEGY    = 0;\n \n   Z_BINARY   = 0;\n+  Z_TEXT     = 1;\n   Z_ASCII    = 1;\n   Z_UNKNOWN  = 2;\n \n@@ -96,14 +118,21 @@ function deflateSetDictionary(var strm: z_stream; const dictionary: PChar;\n function deflateCopy(var dest, source: z_stream): Integer;\n function deflateReset(var strm: z_stream): Integer;\n function deflateParams(var strm: z_stream; level, strategy: Integer): Integer;\n+function deflateTune(var strm: z_stream; good_length, max_lazy, nice_length, max_chain: Integer): Integer;\n function deflateBound(var strm: z_stream; sourceLen: LongInt): LongInt;\n+function deflatePending(var strm: z_stream; var pending: Integer; var bits: Integer): Integer;\n function deflatePrime(var strm: z_stream; bits, value: Integer): Integer;\n+function deflateSetHeader(var strm: z_stream; head: gz_header): Integer;\n function inflateInit2(var strm: z_stream; windowBits: Integer): Integer;\n function inflateSetDictionary(var strm: z_stream; const dictionary: PChar;\n                               dictLength: Integer): Integer;\n function inflateSync(var strm: z_stream): Integer;\n function inflateCopy(var dest, source: z_stream): Integer;\n function inflateReset(var strm: z_stream): Integer;\n+function inflateReset2(var strm: z_stream; windowBits: Integer): Integer;\n+function inflatePrime(var strm: z_stream; bits, value: Integer): Integer;\n+function inflateMark(var strm: z_stream): LongInt;\n+function inflateGetHeader(var strm: z_stream; var head: gz_header): Integer;\n function inflateBackInit(var strm: z_stream;\n                          windowBits: Integer; window: PChar): Integer;\n function inflateBack(var strm: z_stream; in_fn: in_func; in_desc: Pointer;\n@@ -123,7 +152,9 @@ function uncompress(dest: PChar; var destLen: LongInt;\n \n (* checksum functions *)\n function adler32(adler: LongInt; const buf: PChar; len: Integer): LongInt;\n+function adler32_combine(adler1, adler2, len2: LongInt): LongInt;\n function crc32(crc: LongInt; const buf: PChar; len: Integer): LongInt;\n+function crc32_combine(crc1, crc2, len2: LongInt): LongInt;\n \n (* various hacks, don't look :) *)\n function deflateInit_(var strm: z_stream; level: Integer;\n@@ -155,29 +186,38 @@ implementation\n {$L zutil.obj}\n \n function adler32; external;\n+function adler32_combine; external;\n function compress; external;\n function compress2; external;\n function compressBound; external;\n function crc32; external;\n+function crc32_combine; external;\n function deflate; external;\n function deflateBound; external;\n function deflateCopy; external;\n function deflateEnd; external;\n function deflateInit_; external;\n function deflateInit2_; external;\n function deflateParams; external;\n+function deflatePending; external;\n function deflatePrime; external;\n function deflateReset; external;\n function deflateSetDictionary; external;\n+function deflateSetHeader; external;\n+function deflateTune; external;\n function inflate; external;\n function inflateBack; external;\n function inflateBackEnd; external;\n function inflateBackInit_; external;\n function inflateCopy; external;\n function inflateEnd; external;\n+function inflateGetHeader; external;\n function inflateInit_; external;\n function inflateInit2_; external;\n+function inflateMark; external;\n+function inflatePrime; external;\n function inflateReset; external;\n+function inflateReset2; external;\n function inflateSetDictionary; external;\n function inflateSync; external;\n function uncompress; external;"}, {"sha": "0e2594c80885c0dbea13c6d22b2e60e9fb82b51f", "filename": "zlib/contrib/puff/Makefile", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fpuff%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fpuff%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpuff%2FMakefile?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,8 +1,42 @@\n-puff: puff.c puff.h\n-\tcc -DTEST -o puff puff.c\n+CFLAGS=-O\n+\n+puff: puff.o pufftest.o\n+\n+puff.o: puff.h\n+\n+pufftest.o: puff.h\n \n test: puff\n \tpuff zeros.raw\n \n+puft: puff.c puff.h pufftest.o\n+\tcc -fprofile-arcs -ftest-coverage -o puft puff.c pufftest.o\n+\n+# puff full coverage test (should say 100%)\n+cov: puft\n+\t@rm -f *.gcov *.gcda\n+\t@puft -w zeros.raw 2>&1 | cat > /dev/null\n+\t@echo '04' | xxd -r -p | puft 2> /dev/null || test $$? -eq 2\n+\t@echo '00' | xxd -r -p | puft 2> /dev/null || test $$? -eq 2\n+\t@echo '00 00 00 00 00' | xxd -r -p | puft 2> /dev/null || test $$? -eq 254\n+\t@echo '00 01 00 fe ff' | xxd -r -p | puft 2> /dev/null || test $$? -eq 2\n+\t@echo '01 01 00 fe ff 0a' | xxd -r -p | puft -f 2>&1 | cat > /dev/null\n+\t@echo '02 7e ff ff' | xxd -r -p | puft 2> /dev/null || test $$? -eq 246\n+\t@echo '02' | xxd -r -p | puft 2> /dev/null || test $$? -eq 2\n+\t@echo '04 80 49 92 24 49 92 24 0f b4 ff ff c3 04' | xxd -r -p | puft 2> /dev/null || test $$? -eq 2\n+\t@echo '04 80 49 92 24 49 92 24 71 ff ff 93 11 00' | xxd -r -p | puft 2> /dev/null || test $$? -eq 249\n+\t@echo '04 c0 81 08 00 00 00 00 20 7f eb 0b 00 00' | xxd -r -p | puft 2> /dev/null || test $$? -eq 246\n+\t@echo '0b 00 00' | xxd -r -p | puft -f 2>&1 | cat > /dev/null\n+\t@echo '1a 07' | xxd -r -p | puft 2> /dev/null || test $$? -eq 246\n+\t@echo '0c c0 81 00 00 00 00 00 90 ff 6b 04' | xxd -r -p | puft 2> /dev/null || test $$? -eq 245\n+\t@puft -f zeros.raw 2>&1 | cat > /dev/null\n+\t@echo 'fc 00 00' | xxd -r -p | puft 2> /dev/null || test $$? -eq 253\n+\t@echo '04 00 fe ff' | xxd -r -p | puft 2> /dev/null || test $$? -eq 252\n+\t@echo '04 00 24 49' | xxd -r -p | puft 2> /dev/null || test $$? -eq 251\n+\t@echo '04 80 49 92 24 49 92 24 0f b4 ff ff c3 84' | xxd -r -p | puft 2> /dev/null || test $$? -eq 248\n+\t@echo '04 00 24 e9 ff ff' | xxd -r -p | puft 2> /dev/null || test $$? -eq 250\n+\t@echo '04 00 24 e9 ff 6d' | xxd -r -p | puft 2> /dev/null || test $$? -eq 247\n+\t@gcov -n puff.c\n+\n clean:\n-\trm -f puff puff.o\n+\trm -f puff puft *.o *.gc*"}, {"sha": "df8470c937351db3f04d7edcd399ff5182d538ad", "filename": "zlib/contrib/puff/puff.c", "status": "modified", "additions": 67, "deletions": 185, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fpuff%2Fpuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fpuff%2Fpuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpuff%2Fpuff.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -2,7 +2,7 @@\n  * puff.c\n  * Copyright (C) 2002-2010 Mark Adler\n  * For conditions of distribution and use, see copyright notice in puff.h\n- * version 2.1, 4 Apr 2010\n+ * version 2.2, 25 Apr 2010\n  *\n  * puff.c is a simple inflate written to be an unambiguous way to specify the\n  * deflate format.  It is not written for speed but rather simplicity.  As a\n@@ -49,9 +49,9 @@\n  *                      - Fix fixed codes table error\n  *                      - Provide a scanning mode for determining size of\n  *                        uncompressed data\n- * 1.3  20 Mar 2002     - Go back to lengths for puff() parameters [Jean-loup]\n+ * 1.3  20 Mar 2002     - Go back to lengths for puff() parameters [Gailly]\n  *                      - Add a puff.h file for the interface\n- *                      - Add braces in puff() for else do [Jean-loup]\n+ *                      - Add braces in puff() for else do [Gailly]\n  *                      - Use indexes instead of pointers for readability\n  * 1.4  31 Mar 2002     - Simplify construct() code set check\n  *                      - Fix some comments\n@@ -69,13 +69,19 @@\n  *                      - Allow TEST code to read from piped stdin\n  * 2.1   4 Apr 2010     - Avoid variable initialization for happier compilers\n  *                      - Avoid unsigned comparisons for even happier compilers\n+ * 2.2  25 Apr 2010     - Fix bug in variable initializations [Oberhumer]\n+ *                      - Add const where appropriate [Oberhumer]\n+ *                      - Split if's and ?'s for coverage testing\n+ *                      - Break out test code to separate file\n+ *                      - Move NIL to puff.h\n+ *                      - Allow incomplete code only if single code length is 1\n+ *                      - Add full code coverage test to Makefile\n  */\n \n #include <setjmp.h>             /* for setjmp(), longjmp(), and jmp_buf */\n #include \"puff.h\"               /* prototype for puff() */\n \n #define local static            /* for local function definitions */\n-#define NIL ((unsigned char *)0)        /* for no output option */\n \n /*\n  * Maximums for allocations and loops.  It is not useful to change these --\n@@ -95,7 +101,7 @@ struct state {\n     unsigned long outcnt;       /* bytes written to out so far */\n \n     /* input state */\n-    unsigned char *in;          /* input buffer */\n+    const unsigned char *in;    /* input buffer */\n     unsigned long inlen;        /* available input at in */\n     unsigned long incnt;        /* bytes read so far */\n     int bitbuf;                 /* bit buffer */\n@@ -123,7 +129,8 @@ local int bits(struct state *s, int need)\n     /* load at least need bits into val */\n     val = s->bitbuf;\n     while (s->bitcnt < need) {\n-        if (s->incnt == s->inlen) longjmp(s->env, 1);   /* out of input */\n+        if (s->incnt == s->inlen)\n+            longjmp(s->env, 1);         /* out of input */\n         val |= (long)(s->in[s->incnt++]) << s->bitcnt;  /* load eight bits */\n         s->bitcnt += 8;\n     }\n@@ -162,15 +169,17 @@ local int stored(struct state *s)\n     s->bitcnt = 0;\n \n     /* get length and check against its one's complement */\n-    if (s->incnt + 4 > s->inlen) return 2;      /* not enough input */\n+    if (s->incnt + 4 > s->inlen)\n+        return 2;                               /* not enough input */\n     len = s->in[s->incnt++];\n     len |= s->in[s->incnt++] << 8;\n     if (s->in[s->incnt++] != (~len & 0xff) ||\n         s->in[s->incnt++] != ((~len >> 8) & 0xff))\n         return -2;                              /* didn't match complement! */\n \n     /* copy len bytes from in to out */\n-    if (s->incnt + len > s->inlen) return 2;    /* not enough input */\n+    if (s->incnt + len > s->inlen)\n+        return 2;                               /* not enough input */\n     if (s->out != NIL) {\n         if (s->outcnt + len > s->outlen)\n             return 1;                           /* not enough output space */\n@@ -222,7 +231,7 @@ struct huffman {\n  *   in the deflate format.  See the format notes for fixed() and dynamic().\n  */\n #ifdef SLOW\n-local int decode(struct state *s, struct huffman *h)\n+local int decode(struct state *s, const struct huffman *h)\n {\n     int len;            /* current number of bits in code */\n     int code;           /* len bits being decoded */\n@@ -250,7 +259,7 @@ local int decode(struct state *s, struct huffman *h)\n  * a few percent larger.\n  */\n #else /* !SLOW */\n-local int decode(struct state *s, struct huffman *h)\n+local int decode(struct state *s, const struct huffman *h)\n {\n     int len;            /* current number of bits in code */\n     int code;           /* len bits being decoded */\n@@ -283,10 +292,13 @@ local int decode(struct state *s, struct huffman *h)\n             len++;\n         }\n         left = (MAXBITS+1) - len;\n-        if (left == 0) break;\n-        if (s->incnt == s->inlen) longjmp(s->env, 1);   /* out of input */\n+        if (left == 0)\n+            break;\n+        if (s->incnt == s->inlen)\n+            longjmp(s->env, 1);         /* out of input */\n         bitbuf = s->in[s->incnt++];\n-        if (left > 8) left = 8;\n+        if (left > 8)\n+            left = 8;\n     }\n     return -10;                         /* ran out of codes */\n }\n@@ -324,7 +336,7 @@ local int decode(struct state *s, struct huffman *h)\n  * - Within a given code length, the symbols are kept in ascending order for\n  *   the code bits definition.\n  */\n-local int construct(struct huffman *h, short *length, int n)\n+local int construct(struct huffman *h, const short *length, int n)\n {\n     int symbol;         /* current symbol when stepping through length[] */\n     int len;            /* current length when stepping through h->count[] */\n@@ -344,7 +356,8 @@ local int construct(struct huffman *h, short *length, int n)\n     for (len = 1; len <= MAXBITS; len++) {\n         left <<= 1;                     /* one more bit, double codes left */\n         left -= h->count[len];          /* deduct count from possible codes */\n-        if (left < 0) return left;      /* over-subscribed--return negative */\n+        if (left < 0)\n+            return left;                /* over-subscribed--return negative */\n     }                                   /* left > 0 means incomplete */\n \n     /* generate offsets into symbol table for each length for sorting */\n@@ -420,8 +433,8 @@ local int construct(struct huffman *h, short *length, int n)\n  *   defined to do the wrong thing in this case.\n  */\n local int codes(struct state *s,\n-                struct huffman *lencode,\n-                struct huffman *distcode)\n+                const struct huffman *lencode,\n+                const struct huffman *distcode)\n {\n     int symbol;         /* decoded symbol */\n     int len;            /* length for copy */\n@@ -444,24 +457,28 @@ local int codes(struct state *s,\n     /* decode literals and length/distance pairs */\n     do {\n         symbol = decode(s, lencode);\n-        if (symbol < 0) return symbol;  /* invalid symbol */\n+        if (symbol < 0)\n+            return symbol;              /* invalid symbol */\n         if (symbol < 256) {             /* literal: symbol is the byte */\n             /* write out the literal */\n             if (s->out != NIL) {\n-                if (s->outcnt == s->outlen) return 1;\n+                if (s->outcnt == s->outlen)\n+                    return 1;\n                 s->out[s->outcnt] = symbol;\n             }\n             s->outcnt++;\n         }\n         else if (symbol > 256) {        /* length */\n             /* get and compute length */\n             symbol -= 257;\n-            if (symbol >= 29) return -10;       /* invalid fixed code */\n+            if (symbol >= 29)\n+                return -10;             /* invalid fixed code */\n             len = lens[symbol] + bits(s, lext[symbol]);\n \n             /* get and check distance */\n             symbol = decode(s, distcode);\n-            if (symbol < 0) return symbol;      /* invalid symbol */\n+            if (symbol < 0)\n+                return symbol;          /* invalid symbol */\n             dist = dists[symbol] + bits(s, dext[symbol]);\n #ifndef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n             if (dist > s->outcnt)\n@@ -470,13 +487,15 @@ local int codes(struct state *s,\n \n             /* copy length bytes from distance bytes back */\n             if (s->out != NIL) {\n-                if (s->outcnt + len > s->outlen) return 1;\n+                if (s->outcnt + len > s->outlen)\n+                    return 1;\n                 while (len--) {\n                     s->out[s->outcnt] =\n #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n-                        dist > s->outcnt ? 0 :\n+                        dist > s->outcnt ?\n+                            0 :\n #endif\n-                        s->out[s->outcnt - dist];\n+                            s->out[s->outcnt - dist];\n                     s->outcnt++;\n                 }\n             }\n@@ -525,6 +544,12 @@ local int fixed(struct state *s)\n         int symbol;\n         short lengths[FIXLCODES];\n \n+        /* construct lencode and distcode */\n+        lencode.count = lencnt;\n+        lencode.symbol = lensym;\n+        distcode.count = distcnt;\n+        distcode.symbol = distsym;\n+\n         /* literal/length table */\n         for (symbol = 0; symbol < 144; symbol++)\n             lengths[symbol] = 8;\n@@ -541,12 +566,6 @@ local int fixed(struct state *s)\n             lengths[symbol] = 5;\n         construct(&distcode, lengths, MAXDCODES);\n \n-        /* construct lencode and distcode */\n-        lencode.count = lencnt;\n-        lencode.symbol = lensym;\n-        distcode.count = distcnt;\n-        distcode.symbol = distsym;\n-\n         /* do this just once */\n         virgin = 0;\n     }\n@@ -675,7 +694,8 @@ local int dynamic(struct state *s)\n \n     /* build huffman table for code lengths codes (use lencode temporarily) */\n     err = construct(&lencode, lengths, 19);\n-    if (err != 0) return -4;            /* require complete code set here */\n+    if (err != 0)               /* require complete code set here */\n+        return -4;\n \n     /* read length/literal and distance code length tables */\n     index = 0;\n@@ -689,7 +709,8 @@ local int dynamic(struct state *s)\n         else {                          /* repeat instruction */\n             len = 0;                    /* assume repeating zeros */\n             if (symbol == 16) {         /* repeat last length 3..6 times */\n-                if (index == 0) return -5;      /* no last length! */\n+                if (index == 0)\n+                    return -5;          /* no last length! */\n                 len = lengths[index - 1];       /* last length */\n                 symbol = 3 + bits(s, 2);\n             }\n@@ -710,13 +731,13 @@ local int dynamic(struct state *s)\n \n     /* build huffman table for literal/length codes */\n     err = construct(&lencode, lengths, nlen);\n-    if (err < 0 || (err > 0 && nlen - lencode.count[0] != 1))\n-        return -7;      /* only allow incomplete codes if just one code */\n+    if (err && (err < 0 || nlen != lencode.count[0] + lencode.count[1]))\n+        return -7;      /* incomplete code ok only for single length 1 code */\n \n     /* build huffman table for distance codes */\n     err = construct(&distcode, lengths + nlen, ndist);\n-    if (err < 0 || (err > 0 && ndist - distcode.count[0] != 1))\n-        return -8;      /* only allow incomplete codes if just one code */\n+    if (err && (err < 0 || ndist != distcode.count[0] + distcode.count[1]))\n+        return -8;      /* incomplete code ok only for single length 1 code */\n \n     /* decode data until end-of-block code */\n     return codes(s, &lencode, &distcode);\n@@ -768,7 +789,7 @@ local int dynamic(struct state *s)\n  */\n int puff(unsigned char *dest,           /* pointer to destination pointer */\n          unsigned long *destlen,        /* amount of output space */\n-         unsigned char *source,         /* pointer to source data pointer */\n+         const unsigned char *source,   /* pointer to source data pointer */\n          unsigned long *sourcelen)      /* amount of input available */\n {\n     struct state s;             /* input/output state */\n@@ -795,11 +816,15 @@ int puff(unsigned char *dest,           /* pointer to destination pointer */\n         do {\n             last = bits(&s, 1);         /* one if last block */\n             type = bits(&s, 2);         /* block type 0..3 */\n-            err = type == 0 ? stored(&s) :\n-                  (type == 1 ? fixed(&s) :\n-                   (type == 2 ? dynamic(&s) :\n-                    -1));               /* type == 3, invalid */\n-            if (err != 0) break;        /* return with error */\n+            err = type == 0 ?\n+                    stored(&s) :\n+                    (type == 1 ?\n+                        fixed(&s) :\n+                        (type == 2 ?\n+                            dynamic(&s) :\n+                            -1));       /* type == 3, invalid */\n+            if (err != 0)\n+                break;                  /* return with error */\n         } while (!last);\n     }\n \n@@ -810,146 +835,3 @@ int puff(unsigned char *dest,           /* pointer to destination pointer */\n     }\n     return err;\n }\n-\n-#ifdef TEST\n-/* Examples of how to use puff().\n-\n-   Usage: puff [-w] [-nnn] file\n-          ... | puff [-w] [-nnn]\n-\n-   where file is the input file with deflate data, nnn is the number of bytes\n-   of input to skip before inflating (e.g. to skip a zlib or gzip header), and\n-   -w is used to write the decompressed data to stdout */\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-/* Return size times approximately the cube root of 2, keeping the result as 1,\n-   3, or 5 times a power of 2 -- the result is always > size, until the result\n-   is the maximum value of an unsigned long, where it remains.  This is useful\n-   to keep reallocations less than ~33% over the actual data. */\n-local size_t bythirds(size_t size)\n-{\n-    int n;\n-    size_t m;\n-\n-    m = size;\n-    for (n = 0; m; n++)\n-        m >>= 1;\n-    if (n < 3)\n-        return size + 1;\n-    n -= 3;\n-    m = size >> n;\n-    m += m == 6 ? 2 : 1;\n-    m <<= n;\n-    return m > size ? m : (size_t)(-1);\n-}\n-\n-/* Read the input file *name, or stdin if name is NULL, into allocated memory.\n-   Reallocate to larger buffers until the entire file is read in.  Return a\n-   pointer to the allocated data, or NULL if there was a memory allocation\n-   failure.  *len is the number of bytes of data read from the input file (even\n-   if load() returns NULL).  If the input file was empty or could not be opened\n-   or read, *len is zero. */\n-local void *load(char *name, size_t *len)\n-{\n-    size_t size;\n-    void *buf, *swap;\n-    FILE *in;\n-\n-    *len = 0;\n-    buf = malloc(size = 4096);\n-    if (buf == NULL)\n-        return NULL;\n-    in = name == NULL ? stdin : fopen(name, \"rb\");\n-    if (in != NULL) {\n-        for (;;) {\n-            *len += fread((char *)buf + *len, 1, size - *len, in);\n-            if (*len < size) break;\n-            size = bythirds(size);\n-            if (size == *len || (swap = realloc(buf, size)) == NULL) {\n-                free(buf);\n-                buf = NULL;\n-                break;\n-            }\n-            buf = swap;\n-        }\n-        fclose(in);\n-    }\n-    return buf;\n-}\n-\n-int main(int argc, char **argv)\n-{\n-    int ret, put = 0;\n-    unsigned skip = 0;\n-    char *arg, *name = NULL;\n-    unsigned char *source = NULL, *dest;\n-    size_t len = 0;\n-    unsigned long sourcelen, destlen;\n-\n-    /* process arguments */\n-    while (arg = *++argv, --argc)\n-        if (arg[0] == '-') {\n-            if (arg[1] == 'w' && arg[2] == 0)\n-                put = 1;\n-            else if (arg[1] >= '0' && arg[1] <= '9')\n-                skip = (unsigned)atoi(arg + 1);\n-            else {\n-                fprintf(stderr, \"invalid option %s\\n\", arg);\n-                return 3;\n-            }\n-        }\n-        else if (name != NULL) {\n-            fprintf(stderr, \"only one file name allowed\\n\");\n-            return 3;\n-        }\n-        else\n-            name = arg;\n-    source = load(name, &len);\n-    if (source == NULL) {\n-        fprintf(stderr, \"memory allocation failure\\n\");\n-        return 4;\n-    }\n-    if (len == 0) {\n-        fprintf(stderr, \"could not read %s, or it was empty\\n\",\n-                name == NULL ? \"<stdin>\" : name);\n-        free(source);\n-        return 3;\n-    }\n-    if (skip >= len) {\n-        fprintf(stderr, \"skip request of %d leaves no input\\n\", skip);\n-        free(source);\n-        return 3;\n-    }\n-\n-    /* test inflate data with offset skip */\n-    len -= skip;\n-    sourcelen = (unsigned long)len;\n-    ret = puff(NIL, &destlen, source + skip, &sourcelen);\n-    if (ret)\n-        fprintf(stderr, \"puff() failed with return code %d\\n\", ret);\n-    else {\n-        fprintf(stderr, \"puff() succeeded uncompressing %lu bytes\\n\", destlen);\n-        if (sourcelen < len) fprintf(stderr, \"%lu compressed bytes unused\\n\",\n-                                     len - sourcelen);\n-    }\n-\n-    /* if requested, inflate again and write decompressd data to stdout */\n-    if (put) {\n-        dest = malloc(destlen);\n-        if (dest == NULL) {\n-            fprintf(stderr, \"memory allocation failure\\n\");\n-            free(source);\n-            return 4;\n-        }\n-        puff(dest, &destlen, source + skip, &sourcelen);\n-        fwrite(dest, 1, destlen, stdout);\n-        free(dest);\n-    }\n-\n-    /* clean up */\n-    free(source);\n-    return ret;\n-}\n-#endif"}, {"sha": "6a0080ae1a7074a543425b5286da2b71a19257a8", "filename": "zlib/contrib/puff/puff.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fpuff%2Fpuff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fpuff%2Fpuff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpuff%2Fpuff.h?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,6 +1,6 @@\n /* puff.h\n   Copyright (C) 2002-2010 Mark Adler, all rights reserved\n-  version 2.1, 4 Apr 2010\n+  version 2.2, 25 Apr 2010\n \n   This software is provided 'as-is', without any express or implied\n   warranty.  In no event will the author be held liable for any damages\n@@ -25,7 +25,11 @@\n /*\n  * See puff.c for purpose and usage.\n  */\n+#ifndef NIL\n+#  define NIL ((unsigned char *)0)      /* for no output option */\n+#endif\n+\n int puff(unsigned char *dest,           /* pointer to destination pointer */\n          unsigned long *destlen,        /* amount of output space */\n-         unsigned char *source,         /* pointer to source data pointer */\n+         const unsigned char *source,   /* pointer to source data pointer */\n          unsigned long *sourcelen);     /* amount of input available */"}, {"sha": "76e35f66bf6ab9d7e2846fef365b1c607d15a759", "filename": "zlib/contrib/puff/pufftest.c", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fpuff%2Fpufftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fpuff%2Fpufftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpuff%2Fpufftest.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -0,0 +1,165 @@\n+/*\n+ * pufftest.c\n+ * Copyright (C) 2002-2010 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in puff.h\n+ * version 2.2, 25 Apr 2010\n+ */\n+\n+/* Example of how to use puff().\n+\n+   Usage: puff [-w] [-f] [-nnn] file\n+          ... | puff [-w] [-f] [-nnn]\n+\n+   where file is the input file with deflate data, nnn is the number of bytes\n+   of input to skip before inflating (e.g. to skip a zlib or gzip header), and\n+   -w is used to write the decompressed data to stdout.  -f is for coverage\n+   testing, and causes pufftest to fail with not enough output space (-f does\n+   a write like -w, so -w is not required). */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"puff.h\"\n+\n+#if defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(__CYGWIN__)\n+#  include <fcntl.h>\n+#  include <io.h>\n+#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)\n+#else\n+#  define SET_BINARY_MODE(file)\n+#endif\n+\n+#define local static\n+\n+/* Return size times approximately the cube root of 2, keeping the result as 1,\n+   3, or 5 times a power of 2 -- the result is always > size, until the result\n+   is the maximum value of an unsigned long, where it remains.  This is useful\n+   to keep reallocations less than ~33% over the actual data. */\n+local size_t bythirds(size_t size)\n+{\n+    int n;\n+    size_t m;\n+\n+    m = size;\n+    for (n = 0; m; n++)\n+        m >>= 1;\n+    if (n < 3)\n+        return size + 1;\n+    n -= 3;\n+    m = size >> n;\n+    m += m == 6 ? 2 : 1;\n+    m <<= n;\n+    return m > size ? m : (size_t)(-1);\n+}\n+\n+/* Read the input file *name, or stdin if name is NULL, into allocated memory.\n+   Reallocate to larger buffers until the entire file is read in.  Return a\n+   pointer to the allocated data, or NULL if there was a memory allocation\n+   failure.  *len is the number of bytes of data read from the input file (even\n+   if load() returns NULL).  If the input file was empty or could not be opened\n+   or read, *len is zero. */\n+local void *load(const char *name, size_t *len)\n+{\n+    size_t size;\n+    void *buf, *swap;\n+    FILE *in;\n+\n+    *len = 0;\n+    buf = malloc(size = 4096);\n+    if (buf == NULL)\n+        return NULL;\n+    in = name == NULL ? stdin : fopen(name, \"rb\");\n+    if (in != NULL) {\n+        for (;;) {\n+            *len += fread((char *)buf + *len, 1, size - *len, in);\n+            if (*len < size) break;\n+            size = bythirds(size);\n+            if (size == *len || (swap = realloc(buf, size)) == NULL) {\n+                free(buf);\n+                buf = NULL;\n+                break;\n+            }\n+            buf = swap;\n+        }\n+        fclose(in);\n+    }\n+    return buf;\n+}\n+\n+int main(int argc, char **argv)\n+{\n+    int ret, put = 0, fail = 0;\n+    unsigned skip = 0;\n+    char *arg, *name = NULL;\n+    unsigned char *source = NULL, *dest;\n+    size_t len = 0;\n+    unsigned long sourcelen, destlen;\n+\n+    /* process arguments */\n+    while (arg = *++argv, --argc)\n+        if (arg[0] == '-') {\n+            if (arg[1] == 'w' && arg[2] == 0)\n+                put = 1;\n+            else if (arg[1] == 'f' && arg[2] == 0)\n+                fail = 1, put = 1;\n+            else if (arg[1] >= '0' && arg[1] <= '9')\n+                skip = (unsigned)atoi(arg + 1);\n+            else {\n+                fprintf(stderr, \"invalid option %s\\n\", arg);\n+                return 3;\n+            }\n+        }\n+        else if (name != NULL) {\n+            fprintf(stderr, \"only one file name allowed\\n\");\n+            return 3;\n+        }\n+        else\n+            name = arg;\n+    source = load(name, &len);\n+    if (source == NULL) {\n+        fprintf(stderr, \"memory allocation failure\\n\");\n+        return 4;\n+    }\n+    if (len == 0) {\n+        fprintf(stderr, \"could not read %s, or it was empty\\n\",\n+                name == NULL ? \"<stdin>\" : name);\n+        free(source);\n+        return 3;\n+    }\n+    if (skip >= len) {\n+        fprintf(stderr, \"skip request of %d leaves no input\\n\", skip);\n+        free(source);\n+        return 3;\n+    }\n+\n+    /* test inflate data with offset skip */\n+    len -= skip;\n+    sourcelen = (unsigned long)len;\n+    ret = puff(NIL, &destlen, source + skip, &sourcelen);\n+    if (ret)\n+        fprintf(stderr, \"puff() failed with return code %d\\n\", ret);\n+    else {\n+        fprintf(stderr, \"puff() succeeded uncompressing %lu bytes\\n\", destlen);\n+        if (sourcelen < len) fprintf(stderr, \"%lu compressed bytes unused\\n\",\n+                                     len - sourcelen);\n+    }\n+\n+    /* if requested, inflate again and write decompressd data to stdout */\n+    if (put && ret == 0) {\n+        if (fail)\n+            destlen >>= 1;\n+        dest = malloc(destlen);\n+        if (dest == NULL) {\n+            fprintf(stderr, \"memory allocation failure\\n\");\n+            free(source);\n+            return 4;\n+        }\n+        puff(dest, &destlen, source + skip, &sourcelen);\n+        SET_BINARY_MODE(stdout);\n+        fwrite(dest, 1, destlen, stdout);\n+        free(dest);\n+    }\n+\n+    /* clean up */\n+    free(source);\n+    return ret;\n+}"}, {"sha": "59c8b8b4707104c1e7421d826bd4d1e8e43cd972", "filename": "zlib/contrib/vstudio/readme.txt", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fvstudio%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fvstudio%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Freadme.txt?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,32 +1,32 @@\n-Building instructions for the DLL versions of Zlib 1.2.4\r\n+Building instructions for the DLL versions of Zlib 1.2.7\r\n ========================================================\r\n \r\n This directory contains projects that build zlib and minizip using\r\n-Microsoft Visual C++ 9.0/10.0, and Visual C++ .\r\n+Microsoft Visual C++ 9.0/10.0.\r\n \r\n You don't need to build these projects yourself. You can download the\r\n binaries from:\r\n   http://www.winimage.com/zLibDll\r\n \r\n More information can be found at this site.\r\n \r\n-first compile assembly code by running\r\n-bld_ml64.bat in contrib\\masmx64\r\n-bld_ml32.bat in contrib\\masmx86\r\n \r\n \r\n \r\n \r\n Build instructions for Visual Studio 2008 (32 bits or 64 bits)\r\n --------------------------------------------------------------\r\n - Uncompress current zlib, including all contrib/* files\r\n-- Open contrib\\vstudio\\vc9\\zlibvc.sln with Microsoft Visual C++ 2008.0\r\n+- Compile assembly code (with Visual Studio Command Prompt) by running:\r\n+   bld_ml64.bat (in contrib\\masmx64)\r\n+   bld_ml32.bat (in contrib\\masmx86)\r\n+- Open contrib\\vstudio\\vc9\\zlibvc.sln with Microsoft Visual C++ 2008\r\n - Or run: vcbuild /rebuild contrib\\vstudio\\vc9\\zlibvc.sln \"Release|Win32\"\r\n \r\n Build instructions for Visual Studio 2010 (32 bits or 64 bits)\r\n --------------------------------------------------------------\r\n - Uncompress current zlib, including all contrib/* files\r\n-- Open contrib\\vstudio\\vc10\\zlibvc.sln with Microsoft Visual C++ 2010.0\r\n+- Open contrib\\vstudio\\vc10\\zlibvc.sln with Microsoft Visual C++ 2010\r\n \r\n \r\n Important\r"}, {"sha": "bcb08ff95d33c3270c4dd821b63ab3f36dcccee4", "filename": "zlib/contrib/vstudio/vc10/testzlibdll.vcxproj", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fvstudio%2Fvc10%2Ftestzlibdll.vcxproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fvstudio%2Fvc10%2Ftestzlibdll.vcxproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc10%2Ftestzlibdll.vcxproj?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -139,7 +139,7 @@\n     </ClCompile>\r\n     <Link>\r\n       <AdditionalDependencies>x86\\ZlibDllDebug\\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n-      <OutputFile>$(OutDir)testzlib.exe</OutputFile>\r\n+      <OutputFile>$(OutDir)testzlibdll.exe</OutputFile>\r\n       <GenerateDebugInformation>true</GenerateDebugInformation>\r\n       <ProgramDatabaseFile>$(OutDir)testzlib.pdb</ProgramDatabaseFile>\r\n       <SubSystem>Console</SubSystem>\r\n@@ -169,7 +169,7 @@\n     </ClCompile>\r\n     <Link>\r\n       <AdditionalDependencies>x86\\ZlibDllRelease\\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n-      <OutputFile>$(OutDir)testzlib.exe</OutputFile>\r\n+      <OutputFile>$(OutDir)testzlibdll.exe</OutputFile>\r\n       <GenerateDebugInformation>true</GenerateDebugInformation>\r\n       <SubSystem>Console</SubSystem>\r\n       <OptimizeReferences>true</OptimizeReferences>\r\n@@ -200,7 +200,7 @@\n     </ClCompile>\r\n     <Link>\r\n       <AdditionalDependencies>x64\\ZlibDllDebug\\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n-      <OutputFile>$(OutDir)testzlib.exe</OutputFile>\r\n+      <OutputFile>$(OutDir)testzlibdll.exe</OutputFile>\r\n       <GenerateDebugInformation>true</GenerateDebugInformation>\r\n       <ProgramDatabaseFile>$(OutDir)testzlib.pdb</ProgramDatabaseFile>\r\n       <SubSystem>Console</SubSystem>\r\n@@ -227,7 +227,7 @@\n     </ClCompile>\r\n     <Link>\r\n       <AdditionalDependencies>ia64\\ZlibDllDebug\\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n-      <OutputFile>$(OutDir)testzlib.exe</OutputFile>\r\n+      <OutputFile>$(OutDir)testzlibdll.exe</OutputFile>\r\n       <GenerateDebugInformation>true</GenerateDebugInformation>\r\n       <ProgramDatabaseFile>$(OutDir)testzlib.pdb</ProgramDatabaseFile>\r\n       <SubSystem>Console</SubSystem>\r\n@@ -257,7 +257,7 @@\n     </ClCompile>\r\n     <Link>\r\n       <AdditionalDependencies>x64\\ZlibDllRelease\\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n-      <OutputFile>$(OutDir)testzlib.exe</OutputFile>\r\n+      <OutputFile>$(OutDir)testzlibdll.exe</OutputFile>\r\n       <GenerateDebugInformation>true</GenerateDebugInformation>\r\n       <SubSystem>Console</SubSystem>\r\n       <OptimizeReferences>true</OptimizeReferences>\r\n@@ -288,7 +288,7 @@\n     </ClCompile>\r\n     <Link>\r\n       <AdditionalDependencies>ia64\\ZlibDllRelease\\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n-      <OutputFile>$(OutDir)testzlib.exe</OutputFile>\r\n+      <OutputFile>$(OutDir)testzlibdll.exe</OutputFile>\r\n       <GenerateDebugInformation>true</GenerateDebugInformation>\r\n       <SubSystem>Console</SubSystem>\r\n       <OptimizeReferences>true</OptimizeReferences>\r"}, {"sha": "8eca4dbbc1b917c9c6df0c60463ac6e632463542", "filename": "zlib/contrib/vstudio/vc10/zlib.rc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fvstudio%2Fvc10%2Fzlib.rc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fvstudio%2Fvc10%2Fzlib.rc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc10%2Fzlib.rc?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -2,8 +2,8 @@\n \r\n #define IDR_VERSION1  1\r\n IDR_VERSION1\tVERSIONINFO\tMOVEABLE IMPURE LOADONCALL DISCARDABLE\r\n-  FILEVERSION\t 1,2,5,0\r\n-  PRODUCTVERSION 1,2,5,0\r\n+  FILEVERSION\t 1.2.7,0\r\n+  PRODUCTVERSION 1.2.7,0\r\n   FILEFLAGSMASK\tVS_FFI_FILEFLAGSMASK\r\n   FILEFLAGS\t0\r\n   FILEOS\tVOS_DOS_WINDOWS32\r\n@@ -17,12 +17,12 @@ BEGIN\n \r\n     BEGIN\r\n       VALUE \"FileDescription\", \"zlib data compression and ZIP file I/O library\\0\"\r\n-      VALUE \"FileVersion\",\t\"1.2.5\\0\"\r\n+      VALUE \"FileVersion\",\t\"1.2.7\\0\"\r\n       VALUE \"InternalName\",\t\"zlib\\0\"\r\n       VALUE \"OriginalFilename\",\t\"zlib.dll\\0\"\r\n       VALUE \"ProductName\",\t\"ZLib.DLL\\0\"\r\n       VALUE \"Comments\",\"DLL support by Alessandro Iacopetti & Gilles Vollant\\0\"\r\n-      VALUE \"LegalCopyright\", \"(C) 1995-2010 Jean-loup Gailly & Mark Adler\\0\"\r\n+      VALUE \"LegalCopyright\", \"(C) 1995-2012 Jean-loup Gailly & Mark Adler\\0\"\r\n     END\r\n   END\r\n   BLOCK \"VarFileInfo\"\r"}, {"sha": "18ddf50eea3362496bee4154a3ff90e4d2b815e6", "filename": "zlib/contrib/vstudio/vc10/zlibvc.def", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fvstudio%2Fvc10%2Fzlibvc.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fvstudio%2Fvc10%2Fzlibvc.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc10%2Fzlibvc.def?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,7 +1,7 @@\n LIBRARY\r\n ; zlib data compression and ZIP file I/O library\r\n \r\n-VERSION\t\t1.24\r\n+VERSION\t\t1.2.7\r\n \r\n EXPORTS\r\n         adler32                                  @1\r\n@@ -55,6 +55,7 @@ EXPORTS\n         gzungetc                                 @49\r\n         zlibCompileFlags                         @50\r\n         deflatePrime                             @51\r\n+        deflatePending                           @52\r\n \r\n         unzOpen                                  @61\r\n         unzClose                                 @62\r\n@@ -128,3 +129,11 @@ EXPORTS\n         inflatePrime                            @158\r\n         inflateReset2                           @159\r\n         inflateUndermine                        @160\r\n+\r\n+; zlib1 v1.2.6 added:\r\n+        gzgetc_                                 @161\r\n+        inflateResetKeep                        @163\r\n+        deflateResetKeep                        @164\r\n+\n+; zlib1 v1.2.7 added:\n+        gzopen_w                                @165"}, {"sha": "9218fdce92093635415c3bb518141848354f8a3d", "filename": "zlib/contrib/vstudio/vc10/zlibvc.vcxproj", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fvstudio%2Fvc10%2Fzlibvc.vcxproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fvstudio%2Fvc10%2Fzlibvc.vcxproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc10%2Fzlibvc.vcxproj?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -180,6 +180,12 @@\n     <CodeAnalysisRuleSet Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">AllRules.ruleset</CodeAnalysisRuleSet>\r\n     <CodeAnalysisRules Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" />\r\n     <CodeAnalysisRuleAssemblies Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" />\r\n+    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">zlibwapi</TargetName>\r\n+    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'\">zlibwapi</TargetName>\r\n+    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">zlibwapi</TargetName>\r\n+    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">zlibwapi</TargetName>\r\n+    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'\">zlibwapi</TargetName>\r\n+    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">zlibwapi</TargetName>\r\n   </PropertyGroup>\r\n   <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\r\n     <Midl>\r\n@@ -227,6 +233,10 @@\n       </DataExecutionPrevention>\r\n       <ImportLibrary>$(OutDir)zlibwapi.lib</ImportLibrary>\r\n     </Link>\r\n+    <PreBuildEvent>\r\n+      <Command>cd ..\\..\\masmx86\r\n+bld_ml32.bat</Command>\r\n+    </PreBuildEvent>\r\n   </ItemDefinitionGroup>\r\n   <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'\">\r\n     <Midl>\r\n@@ -324,6 +334,10 @@\n       </DataExecutionPrevention>\r\n       <ImportLibrary>$(OutDir)zlibwapi.lib</ImportLibrary>\r\n     </Link>\r\n+    <PreBuildEvent>\r\n+      <Command>cd ..\\..\\masmx86\r\n+bld_ml32.bat</Command>\r\n+    </PreBuildEvent>\r\n   </ItemDefinitionGroup>\r\n   <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\r\n     <Midl>\r\n@@ -368,6 +382,10 @@\n       <ImportLibrary>$(OutDir)zlibwapi.lib</ImportLibrary>\r\n       <TargetMachine>MachineX64</TargetMachine>\r\n     </Link>\r\n+    <PreBuildEvent>\r\n+      <Command>cd ..\\..\\contrib\\masmx64\r\n+bld_ml64.bat</Command>\r\n+    </PreBuildEvent>\r\n   </ItemDefinitionGroup>\r\n   <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Itanium'\">\r\n     <Midl>\r\n@@ -547,6 +565,10 @@\n       <ImportLibrary>$(OutDir)zlibwapi.lib</ImportLibrary>\r\n       <TargetMachine>MachineX64</TargetMachine>\r\n     </Link>\r\n+    <PreBuildEvent>\r\n+      <Command>cd ..\\..\\masmx64\r\n+bld_ml64.bat</Command>\r\n+    </PreBuildEvent>\r\n   </ItemDefinitionGroup>\r\n   <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Itanium'\">\r\n     <Midl>\r"}, {"sha": "8eca4dbbc1b917c9c6df0c60463ac6e632463542", "filename": "zlib/contrib/vstudio/vc9/zlib.rc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fvstudio%2Fvc9%2Fzlib.rc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fvstudio%2Fvc9%2Fzlib.rc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc9%2Fzlib.rc?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -2,8 +2,8 @@\n \r\n #define IDR_VERSION1  1\r\n IDR_VERSION1\tVERSIONINFO\tMOVEABLE IMPURE LOADONCALL DISCARDABLE\r\n-  FILEVERSION\t 1,2,5,0\r\n-  PRODUCTVERSION 1,2,5,0\r\n+  FILEVERSION\t 1.2.7,0\r\n+  PRODUCTVERSION 1.2.7,0\r\n   FILEFLAGSMASK\tVS_FFI_FILEFLAGSMASK\r\n   FILEFLAGS\t0\r\n   FILEOS\tVOS_DOS_WINDOWS32\r\n@@ -17,12 +17,12 @@ BEGIN\n \r\n     BEGIN\r\n       VALUE \"FileDescription\", \"zlib data compression and ZIP file I/O library\\0\"\r\n-      VALUE \"FileVersion\",\t\"1.2.5\\0\"\r\n+      VALUE \"FileVersion\",\t\"1.2.7\\0\"\r\n       VALUE \"InternalName\",\t\"zlib\\0\"\r\n       VALUE \"OriginalFilename\",\t\"zlib.dll\\0\"\r\n       VALUE \"ProductName\",\t\"ZLib.DLL\\0\"\r\n       VALUE \"Comments\",\"DLL support by Alessandro Iacopetti & Gilles Vollant\\0\"\r\n-      VALUE \"LegalCopyright\", \"(C) 1995-2010 Jean-loup Gailly & Mark Adler\\0\"\r\n+      VALUE \"LegalCopyright\", \"(C) 1995-2012 Jean-loup Gailly & Mark Adler\\0\"\r\n     END\r\n   END\r\n   BLOCK \"VarFileInfo\"\r"}, {"sha": "2df8bb3a71cd40cb4d43fe326b9aaf137805401d", "filename": "zlib/contrib/vstudio/vc9/zlibvc.def", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fvstudio%2Fvc9%2Fzlibvc.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcontrib%2Fvstudio%2Fvc9%2Fzlibvc.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc9%2Fzlibvc.def?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,7 +1,7 @@\n LIBRARY\r\n ; zlib data compression and ZIP file I/O library\r\n \r\n-VERSION\t\t1.24\r\n+VERSION\t\t1.2.7\r\n \r\n EXPORTS\r\n         adler32                                  @1\r\n@@ -55,6 +55,7 @@ EXPORTS\n         gzungetc                                 @49\r\n         zlibCompileFlags                         @50\r\n         deflatePrime                             @51\r\n+        deflatePending                           @52\r\n \r\n         unzOpen                                  @61\r\n         unzClose                                 @62\r\n@@ -128,3 +129,11 @@ EXPORTS\n         inflatePrime                            @158\r\n         inflateReset2                           @159\r\n         inflateUndermine                        @160\r\n+\r\n+; zlib1 v1.2.6 added:\r\n+        gzgetc_                                 @161\r\n+        inflateResetKeep                        @163\r\n+        deflateResetKeep                        @164\n+\n+; zlib1 v1.2.7 added:\n+        gzopen_w                                @165"}, {"sha": "e2f5892df91e6be5c8524c87a40d193c153ff133", "filename": "zlib/crc32.c", "status": "modified", "additions": 33, "deletions": 50, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcrc32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcrc32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcrc32.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,5 +1,5 @@\n /* crc32.c -- compute the CRC-32 of a data stream\n- * Copyright (C) 1995-2006, 2010 Mark Adler\n+ * Copyright (C) 1995-2006, 2010, 2011, 2012 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  *\n  * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster\n@@ -17,6 +17,8 @@\n   of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should\n   first call get_crc_table() to initialize the tables before allowing more than\n   one thread to use crc32().\n+\n+  DYNAMIC_CRC_TABLE and MAKECRCH can be #defined to write out crc32.h.\n  */\n \n #ifdef MAKECRCH\n@@ -30,31 +32,11 @@\n \n #define local static\n \n-/* Find a four-byte integer type for crc32_little() and crc32_big(). */\n-#ifndef NOBYFOUR\n-#  ifdef STDC           /* need ANSI C limits.h to determine sizes */\n-#    include <limits.h>\n-#    define BYFOUR\n-#    if (UINT_MAX == 0xffffffffUL)\n-       typedef unsigned int u4;\n-#    else\n-#      if (ULONG_MAX == 0xffffffffUL)\n-         typedef unsigned long u4;\n-#      else\n-#        if (USHRT_MAX == 0xffffffffUL)\n-           typedef unsigned short u4;\n-#        else\n-#          undef BYFOUR     /* can't find a four-byte integer type! */\n-#        endif\n-#      endif\n-#    endif\n-#  endif /* STDC */\n-#endif /* !NOBYFOUR */\n-\n /* Definitions for doing the crc four data bytes at a time. */\n+#if !defined(NOBYFOUR) && defined(Z_U4)\n+#  define BYFOUR\n+#endif\n #ifdef BYFOUR\n-#  define REV(w) ((((w)>>24)&0xff)+(((w)>>8)&0xff00)+ \\\n-                (((w)&0xff00)<<8)+(((w)&0xff)<<24))\n    local unsigned long crc32_little OF((unsigned long,\n                         const unsigned char FAR *, unsigned));\n    local unsigned long crc32_big OF((unsigned long,\n@@ -68,16 +50,16 @@\n local unsigned long gf2_matrix_times OF((unsigned long *mat,\n                                          unsigned long vec));\n local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));\n-local uLong crc32_combine_(uLong crc1, uLong crc2, z_off64_t len2);\n+local uLong crc32_combine_ OF((uLong crc1, uLong crc2, z_off64_t len2));\n \n \n #ifdef DYNAMIC_CRC_TABLE\n \n local volatile int crc_table_empty = 1;\n-local unsigned long FAR crc_table[TBLS][256];\n+local z_crc_t FAR crc_table[TBLS][256];\n local void make_crc_table OF((void));\n #ifdef MAKECRCH\n-   local void write_table OF((FILE *, const unsigned long FAR *));\n+   local void write_table OF((FILE *, const z_crc_t FAR *));\n #endif /* MAKECRCH */\n /*\n   Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:\n@@ -107,9 +89,9 @@ local void make_crc_table OF((void));\n */\n local void make_crc_table()\n {\n-    unsigned long c;\n+    z_crc_t c;\n     int n, k;\n-    unsigned long poly;                 /* polynomial exclusive-or pattern */\n+    z_crc_t poly;                       /* polynomial exclusive-or pattern */\n     /* terms of polynomial defining this crc (except x^32): */\n     static volatile int first = 1;      /* flag to limit concurrent making */\n     static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n@@ -121,13 +103,13 @@ local void make_crc_table()\n         first = 0;\n \n         /* make exclusive-or pattern from polynomial (0xedb88320UL) */\n-        poly = 0UL;\n-        for (n = 0; n < sizeof(p)/sizeof(unsigned char); n++)\n-            poly |= 1UL << (31 - p[n]);\n+        poly = 0;\n+        for (n = 0; n < (int)(sizeof(p)/sizeof(unsigned char)); n++)\n+            poly |= (z_crc_t)1 << (31 - p[n]);\n \n         /* generate a crc for every 8-bit value */\n         for (n = 0; n < 256; n++) {\n-            c = (unsigned long)n;\n+            c = (z_crc_t)n;\n             for (k = 0; k < 8; k++)\n                 c = c & 1 ? poly ^ (c >> 1) : c >> 1;\n             crc_table[0][n] = c;\n@@ -138,11 +120,11 @@ local void make_crc_table()\n            and then the byte reversal of those as well as the first table */\n         for (n = 0; n < 256; n++) {\n             c = crc_table[0][n];\n-            crc_table[4][n] = REV(c);\n+            crc_table[4][n] = ZSWAP32(c);\n             for (k = 1; k < 4; k++) {\n                 c = crc_table[0][c & 0xff] ^ (c >> 8);\n                 crc_table[k][n] = c;\n-                crc_table[k + 4][n] = REV(c);\n+                crc_table[k + 4][n] = ZSWAP32(c);\n             }\n         }\n #endif /* BYFOUR */\n@@ -164,7 +146,7 @@ local void make_crc_table()\n         if (out == NULL) return;\n         fprintf(out, \"/* crc32.h -- tables for rapid CRC calculation\\n\");\n         fprintf(out, \" * Generated automatically by crc32.c\\n */\\n\\n\");\n-        fprintf(out, \"local const unsigned long FAR \");\n+        fprintf(out, \"local const z_crc_t FAR \");\n         fprintf(out, \"crc_table[TBLS][256] =\\n{\\n  {\\n\");\n         write_table(out, crc_table[0]);\n #  ifdef BYFOUR\n@@ -184,12 +166,13 @@ local void make_crc_table()\n #ifdef MAKECRCH\n local void write_table(out, table)\n     FILE *out;\n-    const unsigned long FAR *table;\n+    const z_crc_t FAR *table;\n {\n     int n;\n \n     for (n = 0; n < 256; n++)\n-        fprintf(out, \"%s0x%08lxUL%s\", n % 5 ? \"\" : \"    \", table[n],\n+        fprintf(out, \"%s0x%08lxUL%s\", n % 5 ? \"\" : \"    \",\n+                (unsigned long)(table[n]),\n                 n == 255 ? \"\\n\" : (n % 5 == 4 ? \",\\n\" : \", \"));\n }\n #endif /* MAKECRCH */\n@@ -204,13 +187,13 @@ local void write_table(out, table)\n /* =========================================================================\n  * This function can be used by asm versions of crc32()\n  */\n-const unsigned long FAR * ZEXPORT get_crc_table()\n+const z_crc_t FAR * ZEXPORT get_crc_table()\n {\n #ifdef DYNAMIC_CRC_TABLE\n     if (crc_table_empty)\n         make_crc_table();\n #endif /* DYNAMIC_CRC_TABLE */\n-    return (const unsigned long FAR *)crc_table;\n+    return (const z_crc_t FAR *)crc_table;\n }\n \n /* ========================================================================= */\n@@ -232,7 +215,7 @@ unsigned long ZEXPORT crc32(crc, buf, len)\n \n #ifdef BYFOUR\n     if (sizeof(void *) == sizeof(ptrdiff_t)) {\n-        u4 endian;\n+        z_crc_t endian;\n \n         endian = 1;\n         if (*((unsigned char *)(&endian)))\n@@ -266,17 +249,17 @@ local unsigned long crc32_little(crc, buf, len)\n     const unsigned char FAR *buf;\n     unsigned len;\n {\n-    register u4 c;\n-    register const u4 FAR *buf4;\n+    register z_crc_t c;\n+    register const z_crc_t FAR *buf4;\n \n-    c = (u4)crc;\n+    c = (z_crc_t)crc;\n     c = ~c;\n     while (len && ((ptrdiff_t)buf & 3)) {\n         c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);\n         len--;\n     }\n \n-    buf4 = (const u4 FAR *)(const void FAR *)buf;\n+    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;\n     while (len >= 32) {\n         DOLIT32;\n         len -= 32;\n@@ -306,17 +289,17 @@ local unsigned long crc32_big(crc, buf, len)\n     const unsigned char FAR *buf;\n     unsigned len;\n {\n-    register u4 c;\n-    register const u4 FAR *buf4;\n+    register z_crc_t c;\n+    register const z_crc_t FAR *buf4;\n \n-    c = REV((u4)crc);\n+    c = ZSWAP32((z_crc_t)crc);\n     c = ~c;\n     while (len && ((ptrdiff_t)buf & 3)) {\n         c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n         len--;\n     }\n \n-    buf4 = (const u4 FAR *)(const void FAR *)buf;\n+    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;\n     buf4--;\n     while (len >= 32) {\n         DOBIG32;\n@@ -333,7 +316,7 @@ local unsigned long crc32_big(crc, buf, len)\n         c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n     } while (--len);\n     c = ~c;\n-    return (unsigned long)(REV(c));\n+    return (unsigned long)(ZSWAP32(c));\n }\n \n #endif /* BYFOUR */"}, {"sha": "9e0c7781025148380d130d6f7b6e590117ad3a8c", "filename": "zlib/crc32.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcrc32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fcrc32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcrc32.h?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -2,7 +2,7 @@\n  * Generated automatically by crc32.c\n  */\n \n-local const unsigned long FAR crc_table[TBLS][256] =\n+local const z_crc_t FAR crc_table[TBLS][256] =\n {\n   {\n     0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,"}, {"sha": "99184ff0cef44896d846724d866d7152c341a85f", "filename": "zlib/deflate.c", "status": "modified", "additions": 195, "deletions": 64, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fdeflate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fdeflate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fdeflate.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,5 +1,5 @@\n /* deflate.c -- compress data using the deflation algorithm\n- * Copyright (C) 1995-2010 Jean-loup Gailly and Mark Adler\n+ * Copyright (C) 1995-2012 Jean-loup Gailly and Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -37,7 +37,7 @@\n  *  REFERENCES\n  *\n  *      Deutsch, L.P.,\"DEFLATE Compressed Data Format Specification\".\n- *      Available in http://www.ietf.org/rfc/rfc1951.txt\n+ *      Available in http://tools.ietf.org/html/rfc1951\n  *\n  *      A description of the Rabin and Karp algorithm is given in the book\n  *         \"Algorithms\" by R. Sedgewick, Addison-Wesley, p252.\n@@ -52,7 +52,7 @@\n #include \"deflate.h\"\n \n const char deflate_copyright[] =\n-   \" deflate 1.2.5 Copyright 1995-2010 Jean-loup Gailly and Mark Adler \";\n+   \" deflate 1.2.7 Copyright 1995-2012 Jean-loup Gailly and Mark Adler \";\n /*\n   If you use the zlib library in a product, an acknowledgment is welcome\n   in the documentation of your product. If for some reason you cannot\n@@ -155,6 +155,9 @@ local const config configuration_table[10] = {\n struct static_tree_desc_s {int dummy;}; /* for buggy compilers */\n #endif\n \n+/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */\n+#define RANK(f) (((f) << 1) - ((f) > 4 ? 9 : 0))\n+\n /* ===========================================================================\n  * Update a hash value with the given input byte\n  * IN  assertion: all calls to to UPDATE_HASH are made with consecutive\n@@ -235,10 +238,19 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n \n     strm->msg = Z_NULL;\n     if (strm->zalloc == (alloc_func)0) {\n+#ifdef Z_SOLO\n+        return Z_STREAM_ERROR;\n+#else\n         strm->zalloc = zcalloc;\n         strm->opaque = (voidpf)0;\n+#endif\n     }\n-    if (strm->zfree == (free_func)0) strm->zfree = zcfree;\n+    if (strm->zfree == (free_func)0)\n+#ifdef Z_SOLO\n+        return Z_STREAM_ERROR;\n+#else\n+        strm->zfree = zcfree;\n+#endif\n \n #ifdef FASTEST\n     if (level != 0) level = 1;\n@@ -314,43 +326,70 @@ int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)\n     uInt  dictLength;\n {\n     deflate_state *s;\n-    uInt length = dictLength;\n-    uInt n;\n-    IPos hash_head = 0;\n+    uInt str, n;\n+    int wrap;\n+    unsigned avail;\n+    unsigned char *next;\n \n-    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||\n-        strm->state->wrap == 2 ||\n-        (strm->state->wrap == 1 && strm->state->status != INIT_STATE))\n+    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL)\n         return Z_STREAM_ERROR;\n-\n     s = strm->state;\n-    if (s->wrap)\n-        strm->adler = adler32(strm->adler, dictionary, dictLength);\n+    wrap = s->wrap;\n+    if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)\n+        return Z_STREAM_ERROR;\n \n-    if (length < MIN_MATCH) return Z_OK;\n-    if (length > s->w_size) {\n-        length = s->w_size;\n-        dictionary += dictLength - length; /* use the tail of the dictionary */\n+    /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n+    if (wrap == 1)\n+        strm->adler = adler32(strm->adler, dictionary, dictLength);\n+    s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */\n+\n+    /* if dictionary would fill window, just replace the history */\n+    if (dictLength >= s->w_size) {\n+        if (wrap == 0) {            /* already empty otherwise */\n+            CLEAR_HASH(s);\n+            s->strstart = 0;\n+            s->block_start = 0L;\n+            s->insert = 0;\n+        }\n+        dictionary += dictLength - s->w_size;  /* use the tail */\n+        dictLength = s->w_size;\n     }\n-    zmemcpy(s->window, dictionary, length);\n-    s->strstart = length;\n-    s->block_start = (long)length;\n \n-    /* Insert all strings in the hash table (except for the last two bytes).\n-     * s->lookahead stays null, so s->ins_h will be recomputed at the next\n-     * call of fill_window.\n-     */\n-    s->ins_h = s->window[0];\n-    UPDATE_HASH(s, s->ins_h, s->window[1]);\n-    for (n = 0; n <= length - MIN_MATCH; n++) {\n-        INSERT_STRING(s, n, hash_head);\n+    /* insert dictionary into window and hash */\n+    avail = strm->avail_in;\n+    next = strm->next_in;\n+    strm->avail_in = dictLength;\n+    strm->next_in = (Bytef *)dictionary;\n+    fill_window(s);\n+    while (s->lookahead >= MIN_MATCH) {\n+        str = s->strstart;\n+        n = s->lookahead - (MIN_MATCH-1);\n+        do {\n+            UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);\n+#ifndef FASTEST\n+            s->prev[str & s->w_mask] = s->head[s->ins_h];\n+#endif\n+            s->head[s->ins_h] = (Pos)str;\n+            str++;\n+        } while (--n);\n+        s->strstart = str;\n+        s->lookahead = MIN_MATCH-1;\n+        fill_window(s);\n     }\n-    if (hash_head) hash_head = 0;  /* to make compiler happy */\n+    s->strstart += s->lookahead;\n+    s->block_start = (long)s->strstart;\n+    s->insert = s->lookahead;\n+    s->lookahead = 0;\n+    s->match_length = s->prev_length = MIN_MATCH-1;\n+    s->match_available = 0;\n+    strm->next_in = next;\n+    strm->avail_in = avail;\n+    s->wrap = wrap;\n     return Z_OK;\n }\n \n /* ========================================================================= */\n-int ZEXPORT deflateReset (strm)\n+int ZEXPORT deflateResetKeep (strm)\n     z_streamp strm;\n {\n     deflate_state *s;\n@@ -380,11 +419,22 @@ int ZEXPORT deflateReset (strm)\n     s->last_flush = Z_NO_FLUSH;\n \n     _tr_init(s);\n-    lm_init(s);\n \n     return Z_OK;\n }\n \n+/* ========================================================================= */\n+int ZEXPORT deflateReset (strm)\n+    z_streamp strm;\n+{\n+    int ret;\n+\n+    ret = deflateResetKeep(strm);\n+    if (ret == Z_OK)\n+        lm_init(strm->state);\n+    return ret;\n+}\n+\n /* ========================================================================= */\n int ZEXPORT deflateSetHeader (strm, head)\n     z_streamp strm;\n@@ -396,15 +446,43 @@ int ZEXPORT deflateSetHeader (strm, head)\n     return Z_OK;\n }\n \n+/* ========================================================================= */\n+int ZEXPORT deflatePending (strm, pending, bits)\n+    unsigned *pending;\n+    int *bits;\n+    z_streamp strm;\n+{\n+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n+    if (pending != Z_NULL)\n+        *pending = strm->state->pending;\n+    if (bits != Z_NULL)\n+        *bits = strm->state->bi_valid;\n+    return Z_OK;\n+}\n+\n /* ========================================================================= */\n int ZEXPORT deflatePrime (strm, bits, value)\n     z_streamp strm;\n     int bits;\n     int value;\n {\n+    deflate_state *s;\n+    int put;\n+\n     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n-    strm->state->bi_valid = bits;\n-    strm->state->bi_buf = (ush)(value & ((1 << bits) - 1));\n+    s = strm->state;\n+    if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))\n+        return Z_BUF_ERROR;\n+    do {\n+        put = Buf_size - s->bi_valid;\n+        if (put > bits)\n+            put = bits;\n+        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);\n+        s->bi_valid += put;\n+        _tr_flush_bits(s);\n+        value >>= put;\n+        bits -= put;\n+    } while (bits);\n     return Z_OK;\n }\n \n@@ -562,19 +640,22 @@ local void putShortMSB (s, b)\n local void flush_pending(strm)\n     z_streamp strm;\n {\n-    unsigned len = strm->state->pending;\n+    unsigned len;\n+    deflate_state *s = strm->state;\n \n+    _tr_flush_bits(s);\n+    len = s->pending;\n     if (len > strm->avail_out) len = strm->avail_out;\n     if (len == 0) return;\n \n-    zmemcpy(strm->next_out, strm->state->pending_out, len);\n+    zmemcpy(strm->next_out, s->pending_out, len);\n     strm->next_out  += len;\n-    strm->state->pending_out  += len;\n+    s->pending_out  += len;\n     strm->total_out += len;\n     strm->avail_out  -= len;\n-    strm->state->pending -= len;\n-    if (strm->state->pending == 0) {\n-        strm->state->pending_out = strm->state->pending_buf;\n+    s->pending -= len;\n+    if (s->pending == 0) {\n+        s->pending_out = s->pending_buf;\n     }\n }\n \n@@ -801,7 +882,7 @@ int ZEXPORT deflate (strm, flush)\n      * flushes. For repeated and useless calls with Z_FINISH, we keep\n      * returning Z_STREAM_END instead of Z_BUF_ERROR.\n      */\n-    } else if (strm->avail_in == 0 && flush <= old_flush &&\n+    } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&\n                flush != Z_FINISH) {\n         ERR_RETURN(strm, Z_BUF_ERROR);\n     }\n@@ -850,6 +931,7 @@ int ZEXPORT deflate (strm, flush)\n                     if (s->lookahead == 0) {\n                         s->strstart = 0;\n                         s->block_start = 0L;\n+                        s->insert = 0;\n                     }\n                 }\n             }\n@@ -945,12 +1027,12 @@ int ZEXPORT deflateCopy (dest, source)\n \n     ss = source->state;\n \n-    zmemcpy(dest, source, sizeof(z_stream));\n+    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));\n \n     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n     if (ds == Z_NULL) return Z_MEM_ERROR;\n     dest->state = (struct internal_state FAR *) ds;\n-    zmemcpy(ds, ss, sizeof(deflate_state));\n+    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));\n     ds->strm = dest;\n \n     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n@@ -966,8 +1048,8 @@ int ZEXPORT deflateCopy (dest, source)\n     }\n     /* following zmemcpy do not work for 16-bit MSDOS */\n     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));\n-    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));\n-    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));\n+    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));\n+    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));\n     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n \n     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n@@ -1001,15 +1083,15 @@ local int read_buf(strm, buf, size)\n \n     strm->avail_in  -= len;\n \n+    zmemcpy(buf, strm->next_in, len);\n     if (strm->state->wrap == 1) {\n-        strm->adler = adler32(strm->adler, strm->next_in, len);\n+        strm->adler = adler32(strm->adler, buf, len);\n     }\n #ifdef GZIP\n     else if (strm->state->wrap == 2) {\n-        strm->adler = crc32(strm->adler, strm->next_in, len);\n+        strm->adler = crc32(strm->adler, buf, len);\n     }\n #endif\n-    zmemcpy(buf, strm->next_in, len);\n     strm->next_in  += len;\n     strm->total_in += len;\n \n@@ -1036,6 +1118,7 @@ local void lm_init (s)\n     s->strstart = 0;\n     s->block_start = 0L;\n     s->lookahead = 0;\n+    s->insert = 0;\n     s->match_length = s->prev_length = MIN_MATCH-1;\n     s->match_available = 0;\n     s->ins_h = 0;\n@@ -1310,6 +1393,8 @@ local void fill_window(s)\n     unsigned more;    /* Amount of free space at the end of the window. */\n     uInt wsize = s->w_size;\n \n+    Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n+\n     do {\n         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);\n \n@@ -1362,7 +1447,7 @@ local void fill_window(s)\n #endif\n             more += wsize;\n         }\n-        if (s->strm->avail_in == 0) return;\n+        if (s->strm->avail_in == 0) break;\n \n         /* If there was no sliding:\n          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n@@ -1381,12 +1466,24 @@ local void fill_window(s)\n         s->lookahead += n;\n \n         /* Initialize the hash value now that we have some input: */\n-        if (s->lookahead >= MIN_MATCH) {\n-            s->ins_h = s->window[s->strstart];\n-            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);\n+        if (s->lookahead + s->insert >= MIN_MATCH) {\n+            uInt str = s->strstart - s->insert;\n+            s->ins_h = s->window[str];\n+            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);\n #if MIN_MATCH != 3\n             Call UPDATE_HASH() MIN_MATCH-3 more times\n #endif\n+            while (s->insert) {\n+                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);\n+#ifndef FASTEST\n+                s->prev[str & s->w_mask] = s->head[s->ins_h];\n+#endif\n+                s->head[s->ins_h] = (Pos)str;\n+                str++;\n+                s->insert--;\n+                if (s->lookahead + s->insert < MIN_MATCH)\n+                    break;\n+            }\n         }\n         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n          * but this is not important since only literal bytes will be emitted.\n@@ -1427,6 +1524,9 @@ local void fill_window(s)\n             s->high_water += init;\n         }\n     }\n+\n+    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n+           \"not enough room for search\");\n }\n \n /* ===========================================================================\n@@ -1506,8 +1606,14 @@ local block_state deflate_stored(s, flush)\n             FLUSH_BLOCK(s, 0);\n         }\n     }\n-    FLUSH_BLOCK(s, flush == Z_FINISH);\n-    return flush == Z_FINISH ? finish_done : block_done;\n+    s->insert = 0;\n+    if (flush == Z_FINISH) {\n+        FLUSH_BLOCK(s, 1);\n+        return finish_done;\n+    }\n+    if ((long)s->strstart > s->block_start)\n+        FLUSH_BLOCK(s, 0);\n+    return block_done;\n }\n \n /* ===========================================================================\n@@ -1603,8 +1709,14 @@ local block_state deflate_fast(s, flush)\n         }\n         if (bflush) FLUSH_BLOCK(s, 0);\n     }\n-    FLUSH_BLOCK(s, flush == Z_FINISH);\n-    return flush == Z_FINISH ? finish_done : block_done;\n+    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n+    if (flush == Z_FINISH) {\n+        FLUSH_BLOCK(s, 1);\n+        return finish_done;\n+    }\n+    if (s->last_lit)\n+        FLUSH_BLOCK(s, 0);\n+    return block_done;\n }\n \n #ifndef FASTEST\n@@ -1728,8 +1840,14 @@ local block_state deflate_slow(s, flush)\n         _tr_tally_lit(s, s->window[s->strstart-1], bflush);\n         s->match_available = 0;\n     }\n-    FLUSH_BLOCK(s, flush == Z_FINISH);\n-    return flush == Z_FINISH ? finish_done : block_done;\n+    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n+    if (flush == Z_FINISH) {\n+        FLUSH_BLOCK(s, 1);\n+        return finish_done;\n+    }\n+    if (s->last_lit)\n+        FLUSH_BLOCK(s, 0);\n+    return block_done;\n }\n #endif /* FASTEST */\n \n@@ -1749,11 +1867,11 @@ local block_state deflate_rle(s, flush)\n     for (;;) {\n         /* Make sure that we always have enough lookahead, except\n          * at the end of the input file. We need MAX_MATCH bytes\n-         * for the longest encodable run.\n+         * for the longest run, plus one for the unrolled loop.\n          */\n-        if (s->lookahead < MAX_MATCH) {\n+        if (s->lookahead <= MAX_MATCH) {\n             fill_window(s);\n-            if (s->lookahead < MAX_MATCH && flush == Z_NO_FLUSH) {\n+            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {\n                 return need_more;\n             }\n             if (s->lookahead == 0) break; /* flush the current block */\n@@ -1776,6 +1894,7 @@ local block_state deflate_rle(s, flush)\n                 if (s->match_length > s->lookahead)\n                     s->match_length = s->lookahead;\n             }\n+            Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n         }\n \n         /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n@@ -1796,8 +1915,14 @@ local block_state deflate_rle(s, flush)\n         }\n         if (bflush) FLUSH_BLOCK(s, 0);\n     }\n-    FLUSH_BLOCK(s, flush == Z_FINISH);\n-    return flush == Z_FINISH ? finish_done : block_done;\n+    s->insert = 0;\n+    if (flush == Z_FINISH) {\n+        FLUSH_BLOCK(s, 1);\n+        return finish_done;\n+    }\n+    if (s->last_lit)\n+        FLUSH_BLOCK(s, 0);\n+    return block_done;\n }\n \n /* ===========================================================================\n@@ -1829,6 +1954,12 @@ local block_state deflate_huff(s, flush)\n         s->strstart++;\n         if (bflush) FLUSH_BLOCK(s, 0);\n     }\n-    FLUSH_BLOCK(s, flush == Z_FINISH);\n-    return flush == Z_FINISH ? finish_done : block_done;\n+    s->insert = 0;\n+    if (flush == Z_FINISH) {\n+        FLUSH_BLOCK(s, 1);\n+        return finish_done;\n+    }\n+    if (s->last_lit)\n+        FLUSH_BLOCK(s, 0);\n+    return block_done;\n }"}, {"sha": "da72661d9d1101cde0a37f89b362f8c59ce62ac9", "filename": "zlib/deflate.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fdeflate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fdeflate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fdeflate.h?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,5 +1,5 @@\n /* deflate.h -- internal compression state\n- * Copyright (C) 1995-2010 Jean-loup Gailly\n+ * Copyright (C) 1995-2012 Jean-loup Gailly\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -48,6 +48,9 @@\n #define MAX_BITS 15\n /* All codes must not exceed MAX_BITS bits */\n \n+#define Buf_size 16\n+/* size of bit buffer in bi_buf */\n+\n #define INIT_STATE    42\n #define EXTRA_STATE   69\n #define NAME_STATE    73\n@@ -188,7 +191,7 @@ typedef struct internal_state {\n     int nice_match; /* Stop searching when current match exceeds this */\n \n                 /* used by trees.c: */\n-    /* Didn't use ct_data typedef below to supress compiler warning */\n+    /* Didn't use ct_data typedef below to suppress compiler warning */\n     struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n     struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n     struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n@@ -244,7 +247,7 @@ typedef struct internal_state {\n     ulg opt_len;        /* bit length of current block with optimal trees */\n     ulg static_len;     /* bit length of current block with static trees */\n     uInt matches;       /* number of string matches in current block */\n-    int last_eob_len;   /* bit length of EOB code for last block */\n+    uInt insert;        /* bytes at end of window left to insert */\n \n #ifdef DEBUG\n     ulg compressed_len; /* total bit length of compressed file mod 2^32 */\n@@ -294,6 +297,7 @@ void ZLIB_INTERNAL _tr_init OF((deflate_state *s));\n int ZLIB_INTERNAL _tr_tally OF((deflate_state *s, unsigned dist, unsigned lc));\n void ZLIB_INTERNAL _tr_flush_block OF((deflate_state *s, charf *buf,\n                         ulg stored_len, int last));\n+void ZLIB_INTERNAL _tr_flush_bits OF((deflate_state *s));\n void ZLIB_INTERNAL _tr_align OF((deflate_state *s));\n void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,\n                         ulg stored_len, int last));"}, {"sha": "c97f495020b4293ee09994143ed6cd9d1bd0a2bf", "filename": "zlib/doc/algorithm.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fdoc%2Falgorithm.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fdoc%2Falgorithm.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fdoc%2Falgorithm.txt?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -206,4 +206,4 @@ Compression,'' IEEE Transactions on Information Theory, Vol. 23, No. 3,\n pp. 337-343.\n \n ``DEFLATE Compressed Data Format Specification'' available in\n-http://www.ietf.org/rfc/rfc1951.txt\n+http://tools.ietf.org/html/rfc1951"}, {"sha": "ee3f281aa5713659c007fed390009490afb60c15", "filename": "zlib/gzguts.h", "status": "modified", "additions": 74, "deletions": 13, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fgzguts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fgzguts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fgzguts.h?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,5 +1,5 @@\n /* gzguts.h -- zlib internal header definitions for gz* operations\n- * Copyright (C) 2004, 2005, 2010 Mark Adler\n+ * Copyright (C) 2004, 2005, 2010, 2011, 2012 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -12,7 +12,7 @@\n #  endif\n #endif\n \n-#if ((__GNUC__-0) * 10 + __GNUC_MINOR__-0 >= 33) && !defined(NO_VIZ)\n+#ifdef HAVE_HIDDEN\n #  define ZLIB_INTERNAL __attribute__((visibility (\"hidden\")))\n #else\n #  define ZLIB_INTERNAL\n@@ -27,13 +27,65 @@\n #endif\n #include <fcntl.h>\n \n+#ifdef _WIN32\n+#  include <stddef.h>\n+#endif\n+\n+#if defined(__TURBOC__) || defined(_MSC_VER) || defined(_WIN32)\n+#  include <io.h>\n+#endif\n+\n #ifdef NO_DEFLATE       /* for compatibility with old definition */\n #  define NO_GZCOMPRESS\n #endif\n \n-#ifdef _MSC_VER\n-#  include <io.h>\n-#  define vsnprintf _vsnprintf\n+#if defined(STDC99) || (defined(__TURBOC__) && __TURBOC__ >= 0x550)\n+#  ifndef HAVE_VSNPRINTF\n+#    define HAVE_VSNPRINTF\n+#  endif\n+#endif\n+\n+#if defined(__CYGWIN__)\n+#  ifndef HAVE_VSNPRINTF\n+#    define HAVE_VSNPRINTF\n+#  endif\n+#endif\n+\n+#if defined(MSDOS) && defined(__BORLANDC__) && (BORLANDC > 0x410)\n+#  ifndef HAVE_VSNPRINTF\n+#    define HAVE_VSNPRINTF\n+#  endif\n+#endif\n+\n+#ifndef HAVE_VSNPRINTF\n+#  ifdef MSDOS\n+/* vsnprintf may exist on some MS-DOS compilers (DJGPP?),\n+ but for now we just assume it doesn't. */\n+#    define NO_vsnprintf\n+#  endif\n+#  ifdef __TURBOC__\n+#    define NO_vsnprintf\n+#  endif\n+#  ifdef WIN32\n+/* In Win32, vsnprintf is available as the \"non-ANSI\" _vsnprintf. */\n+#    if !defined(vsnprintf) && !defined(NO_vsnprintf)\n+#      if !defined(_MSC_VER) || ( defined(_MSC_VER) && _MSC_VER < 1500 )\n+#         define vsnprintf _vsnprintf\n+#      endif\n+#    endif\n+#  endif\n+#  ifdef __SASC\n+#    define NO_vsnprintf\n+#  endif\n+#  ifdef VMS\n+#    define NO_vsnprintf\n+#  endif\n+#  ifdef __OS400__\n+#    define NO_vsnprintf\n+#  endif\n+#  ifdef __MVS__\n+#    define NO_vsnprintf\n+#  endif\n #endif\n \n #ifndef local\n@@ -52,7 +104,7 @@\n #  include <windows.h>\n #  define zstrerror() gz_strwinerror((DWORD)GetLastError())\n #else\n-#  ifdef STDC\n+#  ifndef NO_STRERROR\n #    include <errno.h>\n #    define zstrerror() strerror(errno)\n #  else\n@@ -68,6 +120,13 @@\n     ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));\n #endif\n \n+/* default memLevel */\n+#if MAX_MEM_LEVEL >= 8\n+#  define DEF_MEM_LEVEL 8\n+#else\n+#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL\n+#endif\n+\n /* default i/o buffer size -- double this for output when reading */\n #define GZBUFSIZE 8192\n \n@@ -84,23 +143,25 @@\n \n /* internal gzip file state data structure */\n typedef struct {\n+        /* exposed contents for gzgetc() macro */\n+    struct gzFile_s x;      /* \"x\" for exposed */\n+                            /* x.have: number of bytes available at x.next */\n+                            /* x.next: next output data to deliver or write */\n+                            /* x.pos: current position in uncompressed data */\n         /* used for both reading and writing */\n     int mode;               /* see gzip modes above */\n     int fd;                 /* file descriptor */\n     char *path;             /* path or fd for error messages */\n-    z_off64_t pos;          /* current position in uncompressed data */\n     unsigned size;          /* buffer size, zero if not allocated yet */\n     unsigned want;          /* requested buffer size, default is GZBUFSIZE */\n     unsigned char *in;      /* input buffer */\n     unsigned char *out;     /* output buffer (double-sized when reading) */\n-    unsigned char *next;    /* next output data to deliver or write */\n+    int direct;             /* 0 if processing gzip, 1 if transparent */\n         /* just for reading */\n-    unsigned have;          /* amount of output data unused at next */\n-    int eof;                /* true if end of input file reached */\n-    z_off64_t start;        /* where the gzip data started, for rewinding */\n-    z_off64_t raw;          /* where the raw data started, for seeking */\n     int how;                /* 0: get header, 1: copy, 2: decompress */\n-    int direct;             /* true if last read direct, false if gzip */\n+    z_off64_t start;        /* where the gzip data started, for rewinding */\n+    int eof;                /* true if end of input file reached */\n+    int past;               /* true if read requested past end */\n         /* just for writing */\n     int level;              /* compression level */\n     int strategy;           /* compression strategy */"}, {"sha": "ca55c6ea9265dbdd07893c190935ca6165f1dd30", "filename": "zlib/gzlib.c", "status": "modified", "additions": 124, "deletions": 41, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fgzlib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fgzlib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fgzlib.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,19 +1,23 @@\n /* gzlib.c -- zlib functions common to reading and writing gzip files\n- * Copyright (C) 2004, 2010 Mark Adler\n+ * Copyright (C) 2004, 2010, 2011, 2012 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n #include \"gzguts.h\"\n \n+#if defined(_WIN32) && !defined(__BORLANDC__)\n+#  define LSEEK _lseeki64\n+#else\n #if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0\n #  define LSEEK lseek64\n #else\n #  define LSEEK lseek\n #endif\n+#endif\n \n /* Local functions */\n local void gz_reset OF((gz_statep));\n-local gzFile gz_open OF((const char *, int, const char *));\n+local gzFile gz_open OF((const void *, int, const char *));\n \n #if defined UNDER_CE\n \n@@ -71,25 +75,37 @@ char ZLIB_INTERNAL *gz_strwinerror (error)\n local void gz_reset(state)\n     gz_statep state;\n {\n+    state->x.have = 0;              /* no output data available */\n     if (state->mode == GZ_READ) {   /* for reading ... */\n-        state->have = 0;            /* no output data available */\n         state->eof = 0;             /* not at end of file */\n+        state->past = 0;            /* have not read past end yet */\n         state->how = LOOK;          /* look for gzip header */\n-        state->direct = 1;          /* default for empty file */\n     }\n     state->seek = 0;                /* no seek request pending */\n     gz_error(state, Z_OK, NULL);    /* clear error */\n-    state->pos = 0;                 /* no uncompressed data yet */\n+    state->x.pos = 0;               /* no uncompressed data yet */\n     state->strm.avail_in = 0;       /* no input data yet */\n }\n \n /* Open a gzip file either by name or file descriptor. */\n local gzFile gz_open(path, fd, mode)\n-    const char *path;\n+    const void *path;\n     int fd;\n     const char *mode;\n {\n     gz_statep state;\n+    size_t len;\n+    int oflag;\n+#ifdef O_CLOEXEC\n+    int cloexec = 0;\n+#endif\n+#ifdef O_EXCL\n+    int exclusive = 0;\n+#endif\n+\n+    /* check input */\n+    if (path == NULL)\n+        return NULL;\n \n     /* allocate gzFile structure to return */\n     state = malloc(sizeof(gz_state));\n@@ -103,6 +119,7 @@ local gzFile gz_open(path, fd, mode)\n     state->mode = GZ_NONE;\n     state->level = Z_DEFAULT_COMPRESSION;\n     state->strategy = Z_DEFAULT_STRATEGY;\n+    state->direct = 0;\n     while (*mode) {\n         if (*mode >= '0' && *mode <= '9')\n             state->level = *mode - '0';\n@@ -124,6 +141,16 @@ local gzFile gz_open(path, fd, mode)\n                 return NULL;\n             case 'b':       /* ignore -- will request binary anyway */\n                 break;\n+#ifdef O_CLOEXEC\n+            case 'e':\n+                cloexec = 1;\n+                break;\n+#endif\n+#ifdef O_EXCL\n+            case 'x':\n+                exclusive = 1;\n+                break;\n+#endif\n             case 'f':\n                 state->strategy = Z_FILTERED;\n                 break;\n@@ -135,6 +162,8 @@ local gzFile gz_open(path, fd, mode)\n                 break;\n             case 'F':\n                 state->strategy = Z_FIXED;\n+            case 'T':\n+                state->direct = 1;\n             default:        /* could consider as an error, but just ignore */\n                 ;\n             }\n@@ -147,30 +176,67 @@ local gzFile gz_open(path, fd, mode)\n         return NULL;\n     }\n \n+    /* can't force transparent read */\n+    if (state->mode == GZ_READ) {\n+        if (state->direct) {\n+            free(state);\n+            return NULL;\n+        }\n+        state->direct = 1;      /* for empty file */\n+    }\n+\n     /* save the path name for error messages */\n-    state->path = malloc(strlen(path) + 1);\n+#ifdef _WIN32\n+    if (fd == -2) {\n+        len = wcstombs(NULL, path, 0);\n+        if (len == (size_t)-1)\n+            len = 0;\n+    }\n+    else\n+#endif\n+        len = strlen(path);\n+    state->path = malloc(len + 1);\n     if (state->path == NULL) {\n         free(state);\n         return NULL;\n     }\n-    strcpy(state->path, path);\n+#ifdef _WIN32\n+    if (fd == -2)\n+        if (len)\n+            wcstombs(state->path, path, len + 1);\n+        else\n+            *(state->path) = 0;\n+    else\n+#endif\n+        strcpy(state->path, path);\n \n-    /* open the file with the appropriate mode (or just use fd) */\n-    state->fd = fd != -1 ? fd :\n-        open(path,\n+    /* compute the flags for open() */\n+    oflag =\n #ifdef O_LARGEFILE\n-            O_LARGEFILE |\n+        O_LARGEFILE |\n #endif\n #ifdef O_BINARY\n-            O_BINARY |\n+        O_BINARY |\n+#endif\n+#ifdef O_CLOEXEC\n+        (cloexec ? O_CLOEXEC : 0) |\n #endif\n-            (state->mode == GZ_READ ?\n-                O_RDONLY :\n-                (O_WRONLY | O_CREAT | (\n-                    state->mode == GZ_WRITE ?\n-                        O_TRUNC :\n-                        O_APPEND))),\n-            0666);\n+        (state->mode == GZ_READ ?\n+         O_RDONLY :\n+         (O_WRONLY | O_CREAT |\n+#ifdef O_EXCL\n+          (exclusive ? O_EXCL : 0) |\n+#endif\n+          (state->mode == GZ_WRITE ?\n+           O_TRUNC :\n+           O_APPEND)));\n+\n+    /* open the file with the appropriate flags (or just use fd) */\n+    state->fd = fd > -1 ? fd : (\n+#ifdef _WIN32\n+        fd == -2 ? _wopen(path, oflag, 0666) :\n+#endif\n+        open(path, oflag, 0666));\n     if (state->fd == -1) {\n         free(state->path);\n         free(state);\n@@ -224,6 +290,16 @@ gzFile ZEXPORT gzdopen(fd, mode)\n     return gz;\n }\n \n+/* -- see zlib.h -- */\n+#ifdef _WIN32\n+gzFile ZEXPORT gzopen_w(path, mode)\n+    const wchar_t *path;\n+    const char *mode;\n+{\n+    return gz_open(path, -2, mode);\n+}\n+#endif\n+\n /* -- see zlib.h -- */\n int ZEXPORT gzbuffer(file, size)\n     gzFile file;\n@@ -243,8 +319,8 @@ int ZEXPORT gzbuffer(file, size)\n         return -1;\n \n     /* check and set requested size */\n-    if (size == 0)\n-        return -1;\n+    if (size < 2)\n+        size = 2;               /* need two bytes to check magic header */\n     state->want = size;\n     return 0;\n }\n@@ -261,7 +337,8 @@ int ZEXPORT gzrewind(file)\n     state = (gz_statep)file;\n \n     /* check that we're reading and that there's no error */\n-    if (state->mode != GZ_READ || state->err != Z_OK)\n+    if (state->mode != GZ_READ ||\n+            (state->err != Z_OK && state->err != Z_BUF_ERROR))\n         return -1;\n \n     /* back up and start over */\n@@ -289,7 +366,7 @@ z_off64_t ZEXPORT gzseek64(file, offset, whence)\n         return -1;\n \n     /* check that there's no error */\n-    if (state->err != Z_OK)\n+    if (state->err != Z_OK && state->err != Z_BUF_ERROR)\n         return -1;\n \n     /* can only seek from start or relative to current position */\n@@ -298,31 +375,32 @@ z_off64_t ZEXPORT gzseek64(file, offset, whence)\n \n     /* normalize offset to a SEEK_CUR specification */\n     if (whence == SEEK_SET)\n-        offset -= state->pos;\n+        offset -= state->x.pos;\n     else if (state->seek)\n         offset += state->skip;\n     state->seek = 0;\n \n     /* if within raw area while reading, just go there */\n     if (state->mode == GZ_READ && state->how == COPY &&\n-        state->pos + offset >= state->raw) {\n-        ret = LSEEK(state->fd, offset - state->have, SEEK_CUR);\n+            state->x.pos + offset >= 0) {\n+        ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);\n         if (ret == -1)\n             return -1;\n-        state->have = 0;\n+        state->x.have = 0;\n         state->eof = 0;\n+        state->past = 0;\n         state->seek = 0;\n         gz_error(state, Z_OK, NULL);\n         state->strm.avail_in = 0;\n-        state->pos += offset;\n-        return state->pos;\n+        state->x.pos += offset;\n+        return state->x.pos;\n     }\n \n     /* calculate skip amount, rewinding if needed for back seek when reading */\n     if (offset < 0) {\n         if (state->mode != GZ_READ)         /* writing -- can't go backwards */\n             return -1;\n-        offset += state->pos;\n+        offset += state->x.pos;\n         if (offset < 0)                     /* before start of file! */\n             return -1;\n         if (gzrewind(file) == -1)           /* rewind, then skip to offset */\n@@ -331,11 +409,11 @@ z_off64_t ZEXPORT gzseek64(file, offset, whence)\n \n     /* if reading, skip what's in output buffer (one less gzgetc() check) */\n     if (state->mode == GZ_READ) {\n-        n = GT_OFF(state->have) || (z_off64_t)state->have > offset ?\n-            (unsigned)offset : state->have;\n-        state->have -= n;\n-        state->next += n;\n-        state->pos += n;\n+        n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?\n+            (unsigned)offset : state->x.have;\n+        state->x.have -= n;\n+        state->x.next += n;\n+        state->x.pos += n;\n         offset -= n;\n     }\n \n@@ -344,7 +422,7 @@ z_off64_t ZEXPORT gzseek64(file, offset, whence)\n         state->seek = 1;\n         state->skip = offset;\n     }\n-    return state->pos + offset;\n+    return state->x.pos + offset;\n }\n \n /* -- see zlib.h -- */\n@@ -373,7 +451,7 @@ z_off64_t ZEXPORT gztell64(file)\n         return -1;\n \n     /* return position */\n-    return state->pos + (state->seek ? state->skip : 0);\n+    return state->x.pos + (state->seek ? state->skip : 0);\n }\n \n /* -- see zlib.h -- */\n@@ -433,8 +511,7 @@ int ZEXPORT gzeof(file)\n         return 0;\n \n     /* return end-of-file state */\n-    return state->mode == GZ_READ ?\n-        (state->eof && state->strm.avail_in == 0 && state->have == 0) : 0;\n+    return state->mode == GZ_READ ? state->past : 0;\n }\n \n /* -- see zlib.h -- */\n@@ -471,8 +548,10 @@ void ZEXPORT gzclearerr(file)\n         return;\n \n     /* clear error and end-of-file */\n-    if (state->mode == GZ_READ)\n+    if (state->mode == GZ_READ) {\n         state->eof = 0;\n+        state->past = 0;\n+    }\n     gz_error(state, Z_OK, NULL);\n }\n \n@@ -494,6 +573,10 @@ void ZLIB_INTERNAL gz_error(state, err, msg)\n         state->msg = NULL;\n     }\n \n+    /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */\n+    if (err != Z_OK && err != Z_BUF_ERROR)\n+        state->x.have = 0;\n+\n     /* set error code, and if no message, then done */\n     state->err = err;\n     if (msg == NULL)"}, {"sha": "3493d34d4ea62cae85bf7628619dec94f25fdb46", "filename": "zlib/gzread.c", "status": "modified", "additions": 177, "deletions": 241, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fgzread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fgzread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fgzread.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,5 +1,5 @@\n /* gzread.c -- zlib functions for reading gzip files\n- * Copyright (C) 2004, 2005, 2010 Mark Adler\n+ * Copyright (C) 2004, 2005, 2010, 2011, 2012 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -8,10 +8,9 @@\n /* Local functions */\n local int gz_load OF((gz_statep, unsigned char *, unsigned, unsigned *));\n local int gz_avail OF((gz_statep));\n-local int gz_next4 OF((gz_statep, unsigned long *));\n-local int gz_head OF((gz_statep));\n+local int gz_look OF((gz_statep));\n local int gz_decomp OF((gz_statep));\n-local int gz_make OF((gz_statep));\n+local int gz_fetch OF((gz_statep));\n local int gz_skip OF((gz_statep, z_off64_t));\n \n /* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from\n@@ -46,67 +45,47 @@ local int gz_load(state, buf, len, have)\n    error, 0 otherwise.  Note that the eof flag is set when the end of the input\n    file is reached, even though there may be unused data in the buffer.  Once\n    that data has been used, no more attempts will be made to read the file.\n-   gz_avail() assumes that strm->avail_in == 0. */\n+   If strm->avail_in != 0, then the current data is moved to the beginning of\n+   the input buffer, and then the remainder of the buffer is loaded with the\n+   available data from the input file. */\n local int gz_avail(state)\n     gz_statep state;\n {\n+    unsigned got;\n     z_streamp strm = &(state->strm);\n \n-    if (state->err != Z_OK)\n+    if (state->err != Z_OK && state->err != Z_BUF_ERROR)\n         return -1;\n     if (state->eof == 0) {\n-        if (gz_load(state, state->in, state->size,\n-                (unsigned *)&(strm->avail_in)) == -1)\n+        if (strm->avail_in) {       /* copy what's there to the start */\n+            unsigned char *p = state->in, *q = strm->next_in;\n+            unsigned n = strm->avail_in;\n+            do {\n+                *p++ = *q++;\n+            } while (--n);\n+        }\n+        if (gz_load(state, state->in + strm->avail_in,\n+                    state->size - strm->avail_in, &got) == -1)\n             return -1;\n+        strm->avail_in += got;\n         strm->next_in = state->in;\n     }\n     return 0;\n }\n \n-/* Get next byte from input, or -1 if end or error. */\n-#define NEXT() ((strm->avail_in == 0 && gz_avail(state) == -1) ? -1 : \\\n-                (strm->avail_in == 0 ? -1 : \\\n-                 (strm->avail_in--, *(strm->next_in)++)))\n-\n-/* Get a four-byte little-endian integer and return 0 on success and the value\n-   in *ret.  Otherwise -1 is returned and *ret is not modified. */\n-local int gz_next4(state, ret)\n-    gz_statep state;\n-    unsigned long *ret;\n-{\n-    int ch;\n-    unsigned long val;\n-    z_streamp strm = &(state->strm);\n-\n-    val = NEXT();\n-    val += (unsigned)NEXT() << 8;\n-    val += (unsigned long)NEXT() << 16;\n-    ch = NEXT();\n-    if (ch == -1)\n-        return -1;\n-    val += (unsigned long)ch << 24;\n-    *ret = val;\n-    return 0;\n-}\n-\n-/* Look for gzip header, set up for inflate or copy.  state->have must be zero.\n+/* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.\n    If this is the first time in, allocate required memory.  state->how will be\n    left unchanged if there is no more input data available, will be set to COPY\n    if there is no gzip header and direct copying will be performed, or it will\n-   be set to GZIP for decompression, and the gzip header will be skipped so\n-   that the next available input data is the raw deflate stream.  If direct\n-   copying, then leftover input data from the input buffer will be copied to\n-   the output buffer.  In that case, all further file reads will be directly to\n-   either the output buffer or a user buffer.  If decompressing, the inflate\n-   state and the check value will be initialized.  gz_head() will return 0 on\n-   success or -1 on failure.  Failures may include read errors or gzip header\n-   errors.  */\n-local int gz_head(state)\n+   be set to GZIP for decompression.  If direct copying, then leftover input\n+   data from the input buffer will be copied to the output buffer.  In that\n+   case, all further file reads will be directly to either the output buffer or\n+   a user buffer.  If decompressing, the inflate state will be initialized.\n+   gz_look() will return 0 on success or -1 on failure. */\n+local int gz_look(state)\n     gz_statep state;\n {\n     z_streamp strm = &(state->strm);\n-    int flags;\n-    unsigned len;\n \n     /* allocate read buffers and inflate memory */\n     if (state->size == 0) {\n@@ -129,7 +108,7 @@ local int gz_head(state)\n         state->strm.opaque = Z_NULL;\n         state->strm.avail_in = 0;\n         state->strm.next_in = Z_NULL;\n-        if (inflateInit2(&(state->strm), -15) != Z_OK) {    /* raw inflate */\n+        if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */\n             free(state->out);\n             free(state->in);\n             state->size = 0;\n@@ -138,83 +117,45 @@ local int gz_head(state)\n         }\n     }\n \n-    /* get some data in the input buffer */\n-    if (strm->avail_in == 0) {\n+    /* get at least the magic bytes in the input buffer */\n+    if (strm->avail_in < 2) {\n         if (gz_avail(state) == -1)\n             return -1;\n         if (strm->avail_in == 0)\n             return 0;\n     }\n \n-    /* look for the gzip magic header bytes 31 and 139 */\n-    if (strm->next_in[0] == 31) {\n-        strm->avail_in--;\n-        strm->next_in++;\n-        if (strm->avail_in == 0 && gz_avail(state) == -1)\n-            return -1;\n-        if (strm->avail_in && strm->next_in[0] == 139) {\n-            /* we have a gzip header, woo hoo! */\n-            strm->avail_in--;\n-            strm->next_in++;\n-\n-            /* skip rest of header */\n-            if (NEXT() != 8) {      /* compression method */\n-                gz_error(state, Z_DATA_ERROR, \"unknown compression method\");\n-                return -1;\n-            }\n-            flags = NEXT();\n-            if (flags & 0xe0) {     /* reserved flag bits */\n-                gz_error(state, Z_DATA_ERROR, \"unknown header flags set\");\n-                return -1;\n-            }\n-            NEXT();                 /* modification time */\n-            NEXT();\n-            NEXT();\n-            NEXT();\n-            NEXT();                 /* extra flags */\n-            NEXT();                 /* operating system */\n-            if (flags & 4) {        /* extra field */\n-                len = (unsigned)NEXT();\n-                len += (unsigned)NEXT() << 8;\n-                while (len--)\n-                    if (NEXT() < 0)\n-                        break;\n-            }\n-            if (flags & 8)          /* file name */\n-                while (NEXT() > 0)\n-                    ;\n-            if (flags & 16)         /* comment */\n-                while (NEXT() > 0)\n-                    ;\n-            if (flags & 2) {        /* header crc */\n-                NEXT();\n-                NEXT();\n-            }\n-            /* an unexpected end of file is not checked for here -- it will be\n-               noticed on the first request for uncompressed data */\n-\n-            /* set up for decompression */\n-            inflateReset(strm);\n-            strm->adler = crc32(0L, Z_NULL, 0);\n-            state->how = GZIP;\n-            state->direct = 0;\n-            return 0;\n-        }\n-        else {\n-            /* not a gzip file -- save first byte (31) and fall to raw i/o */\n-            state->out[0] = 31;\n-            state->have = 1;\n-        }\n+    /* look for gzip magic bytes -- if there, do gzip decoding (note: there is\n+       a logical dilemma here when considering the case of a partially written\n+       gzip file, to wit, if a single 31 byte is written, then we cannot tell\n+       whether this is a single-byte file, or just a partially written gzip\n+       file -- for here we assume that if a gzip file is being written, then\n+       the header will be written in a single operation, so that reading a\n+       single byte is sufficient indication that it is not a gzip file) */\n+    if (strm->avail_in > 1 &&\n+            strm->next_in[0] == 31 && strm->next_in[1] == 139) {\n+        inflateReset(strm);\n+        state->how = GZIP;\n+        state->direct = 0;\n+        return 0;\n+    }\n+\n+    /* no gzip header -- if we were decoding gzip before, then this is trailing\n+       garbage.  Ignore the trailing garbage and finish. */\n+    if (state->direct == 0) {\n+        strm->avail_in = 0;\n+        state->eof = 1;\n+        state->x.have = 0;\n+        return 0;\n     }\n \n-    /* doing raw i/o, save start of raw data for seeking, copy any leftover\n-       input to output -- this assumes that the output buffer is larger than\n-       the input buffer, which also assures space for gzungetc() */\n-    state->raw = state->pos;\n-    state->next = state->out;\n+    /* doing raw i/o, copy any leftover input to output -- this assumes that\n+       the output buffer is larger than the input buffer, which also assures\n+       space for gzungetc() */\n+    state->x.next = state->out;\n     if (strm->avail_in) {\n-        memcpy(state->next + state->have, strm->next_in, strm->avail_in);\n-        state->have += strm->avail_in;\n+        memcpy(state->x.next, strm->next_in, strm->avail_in);\n+        state->x.have = strm->avail_in;\n         strm->avail_in = 0;\n     }\n     state->how = COPY;\n@@ -223,19 +164,15 @@ local int gz_head(state)\n }\n \n /* Decompress from input to the provided next_out and avail_out in the state.\n-   If the end of the compressed data is reached, then verify the gzip trailer\n-   check value and length (modulo 2^32).  state->have and state->next are set\n-   to point to the just decompressed data, and the crc is updated.  If the\n-   trailer is verified, state->how is reset to LOOK to look for the next gzip\n-   stream or raw data, once state->have is depleted.  Returns 0 on success, -1\n-   on failure.  Failures may include invalid compressed data or a failed gzip\n-   trailer verification. */\n+   On return, state->x.have and state->x.next point to the just decompressed\n+   data.  If the gzip stream completes, state->how is reset to LOOK to look for\n+   the next gzip stream or raw data, once state->x.have is depleted.  Returns 0\n+   on success, -1 on failure. */\n local int gz_decomp(state)\n     gz_statep state;\n {\n-    int ret;\n+    int ret = Z_OK;\n     unsigned had;\n-    unsigned long crc, len;\n     z_streamp strm = &(state->strm);\n \n     /* fill output buffer up to end of deflate stream */\n@@ -245,15 +182,15 @@ local int gz_decomp(state)\n         if (strm->avail_in == 0 && gz_avail(state) == -1)\n             return -1;\n         if (strm->avail_in == 0) {\n-            gz_error(state, Z_DATA_ERROR, \"unexpected end of file\");\n-            return -1;\n+            gz_error(state, Z_BUF_ERROR, \"unexpected end of file\");\n+            break;\n         }\n \n         /* decompress and handle errors */\n         ret = inflate(strm, Z_NO_FLUSH);\n         if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {\n             gz_error(state, Z_STREAM_ERROR,\n-                      \"internal error: inflate stream corrupt\");\n+                     \"internal error: inflate stream corrupt\");\n             return -1;\n         }\n         if (ret == Z_MEM_ERROR) {\n@@ -262,67 +199,55 @@ local int gz_decomp(state)\n         }\n         if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */\n             gz_error(state, Z_DATA_ERROR,\n-                      strm->msg == NULL ? \"compressed data error\" : strm->msg);\n+                     strm->msg == NULL ? \"compressed data error\" : strm->msg);\n             return -1;\n         }\n     } while (strm->avail_out && ret != Z_STREAM_END);\n \n-    /* update available output and crc check value */\n-    state->have = had - strm->avail_out;\n-    state->next = strm->next_out - state->have;\n-    strm->adler = crc32(strm->adler, state->next, state->have);\n+    /* update available output */\n+    state->x.have = had - strm->avail_out;\n+    state->x.next = strm->next_out - state->x.have;\n \n-    /* check gzip trailer if at end of deflate stream */\n-    if (ret == Z_STREAM_END) {\n-        if (gz_next4(state, &crc) == -1 || gz_next4(state, &len) == -1) {\n-            gz_error(state, Z_DATA_ERROR, \"unexpected end of file\");\n-            return -1;\n-        }\n-        if (crc != strm->adler) {\n-            gz_error(state, Z_DATA_ERROR, \"incorrect data check\");\n-            return -1;\n-        }\n-        if (len != (strm->total_out & 0xffffffffL)) {\n-            gz_error(state, Z_DATA_ERROR, \"incorrect length check\");\n-            return -1;\n-        }\n-        state->how = LOOK;      /* ready for next stream, once have is 0 (leave\n-                                   state->direct unchanged to remember how) */\n-    }\n+    /* if the gzip stream completed successfully, look for another */\n+    if (ret == Z_STREAM_END)\n+        state->how = LOOK;\n \n     /* good decompression */\n     return 0;\n }\n \n-/* Make data and put in the output buffer.  Assumes that state->have == 0.\n+/* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.\n    Data is either copied from the input file or decompressed from the input\n    file depending on state->how.  If state->how is LOOK, then a gzip header is\n-   looked for (and skipped if found) to determine wither to copy or decompress.\n-   Returns -1 on error, otherwise 0.  gz_make() will leave state->have as COPY\n-   or GZIP unless the end of the input file has been reached and all data has\n-   been processed.  */\n-local int gz_make(state)\n+   looked for to determine whether to copy or decompress.  Returns -1 on error,\n+   otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the\n+   end of the input file has been reached and all data has been processed.  */\n+local int gz_fetch(state)\n     gz_statep state;\n {\n     z_streamp strm = &(state->strm);\n \n-    if (state->how == LOOK) {           /* look for gzip header */\n-        if (gz_head(state) == -1)\n-            return -1;\n-        if (state->have)                /* got some data from gz_head() */\n+    do {\n+        switch(state->how) {\n+        case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */\n+            if (gz_look(state) == -1)\n+                return -1;\n+            if (state->how == LOOK)\n+                return 0;\n+            break;\n+        case COPY:      /* -> COPY */\n+            if (gz_load(state, state->out, state->size << 1, &(state->x.have))\n+                    == -1)\n+                return -1;\n+            state->x.next = state->out;\n             return 0;\n-    }\n-    if (state->how == COPY) {           /* straight copy */\n-        if (gz_load(state, state->out, state->size << 1, &(state->have)) == -1)\n-            return -1;\n-        state->next = state->out;\n-    }\n-    else if (state->how == GZIP) {      /* decompress */\n-        strm->avail_out = state->size << 1;\n-        strm->next_out = state->out;\n-        if (gz_decomp(state) == -1)\n-            return -1;\n-    }\n+        case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */\n+            strm->avail_out = state->size << 1;\n+            strm->next_out = state->out;\n+            if (gz_decomp(state) == -1)\n+                return -1;\n+        }\n+    } while (state->x.have == 0 && (!state->eof || strm->avail_in));\n     return 0;\n }\n \n@@ -336,12 +261,12 @@ local int gz_skip(state, len)\n     /* skip over len bytes or reach end-of-file, whichever comes first */\n     while (len)\n         /* skip over whatever is in output buffer */\n-        if (state->have) {\n-            n = GT_OFF(state->have) || (z_off64_t)state->have > len ?\n-                (unsigned)len : state->have;\n-            state->have -= n;\n-            state->next += n;\n-            state->pos += n;\n+        if (state->x.have) {\n+            n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?\n+                (unsigned)len : state->x.have;\n+            state->x.have -= n;\n+            state->x.next += n;\n+            state->x.pos += n;\n             len -= n;\n         }\n \n@@ -352,7 +277,7 @@ local int gz_skip(state, len)\n         /* need more data to skip -- load up output buffer */\n         else {\n             /* get more output, looking for header if required */\n-            if (gz_make(state) == -1)\n+            if (gz_fetch(state) == -1)\n                 return -1;\n         }\n     return 0;\n@@ -374,14 +299,15 @@ int ZEXPORT gzread(file, buf, len)\n     state = (gz_statep)file;\n     strm = &(state->strm);\n \n-    /* check that we're reading and that there's no error */\n-    if (state->mode != GZ_READ || state->err != Z_OK)\n+    /* check that we're reading and that there's no (serious) error */\n+    if (state->mode != GZ_READ ||\n+            (state->err != Z_OK && state->err != Z_BUF_ERROR))\n         return -1;\n \n     /* since an int is returned, make sure len fits in one, otherwise return\n        with an error (this avoids the flaw in the interface) */\n     if ((int)len < 0) {\n-        gz_error(state, Z_BUF_ERROR, \"requested length does not fit in int\");\n+        gz_error(state, Z_DATA_ERROR, \"requested length does not fit in int\");\n         return -1;\n     }\n \n@@ -400,24 +326,26 @@ int ZEXPORT gzread(file, buf, len)\n     got = 0;\n     do {\n         /* first just try copying data from the output buffer */\n-        if (state->have) {\n-            n = state->have > len ? len : state->have;\n-            memcpy(buf, state->next, n);\n-            state->next += n;\n-            state->have -= n;\n+        if (state->x.have) {\n+            n = state->x.have > len ? len : state->x.have;\n+            memcpy(buf, state->x.next, n);\n+            state->x.next += n;\n+            state->x.have -= n;\n         }\n \n         /* output buffer empty -- return if we're at the end of the input */\n-        else if (state->eof && strm->avail_in == 0)\n+        else if (state->eof && strm->avail_in == 0) {\n+            state->past = 1;        /* tried to read past end */\n             break;\n+        }\n \n         /* need output data -- for small len or new stream load up our output\n            buffer */\n         else if (state->how == LOOK || len < (state->size << 1)) {\n             /* get more output, looking for header if required */\n-            if (gz_make(state) == -1)\n+            if (gz_fetch(state) == -1)\n                 return -1;\n-            continue;       /* no progress yet -- go back to memcpy() above */\n+            continue;       /* no progress yet -- go back to copy above */\n             /* the copy above assures that we will leave with space in the\n                output buffer, allowing at least one gzungetc() to succeed */\n         }\n@@ -434,22 +362,23 @@ int ZEXPORT gzread(file, buf, len)\n             strm->next_out = buf;\n             if (gz_decomp(state) == -1)\n                 return -1;\n-            n = state->have;\n-            state->have = 0;\n+            n = state->x.have;\n+            state->x.have = 0;\n         }\n \n         /* update progress */\n         len -= n;\n         buf = (char *)buf + n;\n         got += n;\n-        state->pos += n;\n+        state->x.pos += n;\n     } while (len);\n \n     /* return number of bytes read into user buffer (will fit in int) */\n     return (int)got;\n }\n \n /* -- see zlib.h -- */\n+#undef gzgetc\n int ZEXPORT gzgetc(file)\n     gzFile file;\n {\n@@ -462,22 +391,29 @@ int ZEXPORT gzgetc(file)\n         return -1;\n     state = (gz_statep)file;\n \n-    /* check that we're reading and that there's no error */\n-    if (state->mode != GZ_READ || state->err != Z_OK)\n+    /* check that we're reading and that there's no (serious) error */\n+    if (state->mode != GZ_READ ||\n+        (state->err != Z_OK && state->err != Z_BUF_ERROR))\n         return -1;\n \n     /* try output buffer (no need to check for skip request) */\n-    if (state->have) {\n-        state->have--;\n-        state->pos++;\n-        return *(state->next)++;\n+    if (state->x.have) {\n+        state->x.have--;\n+        state->x.pos++;\n+        return *(state->x.next)++;\n     }\n \n     /* nothing there -- try gzread() */\n     ret = gzread(file, buf, 1);\n     return ret < 1 ? -1 : buf[0];\n }\n \n+int ZEXPORT gzgetc_(file)\n+gzFile file;\n+{\n+    return gzgetc(file);\n+}\n+\n /* -- see zlib.h -- */\n int ZEXPORT gzungetc(c, file)\n     int c;\n@@ -490,8 +426,9 @@ int ZEXPORT gzungetc(c, file)\n         return -1;\n     state = (gz_statep)file;\n \n-    /* check that we're reading and that there's no error */\n-    if (state->mode != GZ_READ || state->err != Z_OK)\n+    /* check that we're reading and that there's no (serious) error */\n+    if (state->mode != GZ_READ ||\n+        (state->err != Z_OK && state->err != Z_BUF_ERROR))\n         return -1;\n \n     /* process a skip request */\n@@ -506,32 +443,34 @@ int ZEXPORT gzungetc(c, file)\n         return -1;\n \n     /* if output buffer empty, put byte at end (allows more pushing) */\n-    if (state->have == 0) {\n-        state->have = 1;\n-        state->next = state->out + (state->size << 1) - 1;\n-        state->next[0] = c;\n-        state->pos--;\n+    if (state->x.have == 0) {\n+        state->x.have = 1;\n+        state->x.next = state->out + (state->size << 1) - 1;\n+        state->x.next[0] = c;\n+        state->x.pos--;\n+        state->past = 0;\n         return c;\n     }\n \n     /* if no room, give up (must have already done a gzungetc()) */\n-    if (state->have == (state->size << 1)) {\n-        gz_error(state, Z_BUF_ERROR, \"out of room to push characters\");\n+    if (state->x.have == (state->size << 1)) {\n+        gz_error(state, Z_DATA_ERROR, \"out of room to push characters\");\n         return -1;\n     }\n \n     /* slide output data if needed and insert byte before existing data */\n-    if (state->next == state->out) {\n-        unsigned char *src = state->out + state->have;\n+    if (state->x.next == state->out) {\n+        unsigned char *src = state->out + state->x.have;\n         unsigned char *dest = state->out + (state->size << 1);\n         while (src > state->out)\n             *--dest = *--src;\n-        state->next = dest;\n+        state->x.next = dest;\n     }\n-    state->have++;\n-    state->next--;\n-    state->next[0] = c;\n-    state->pos--;\n+    state->x.have++;\n+    state->x.next--;\n+    state->x.next[0] = c;\n+    state->x.pos--;\n+    state->past = 0;\n     return c;\n }\n \n@@ -551,8 +490,9 @@ char * ZEXPORT gzgets(file, buf, len)\n         return NULL;\n     state = (gz_statep)file;\n \n-    /* check that we're reading and that there's no error */\n-    if (state->mode != GZ_READ || state->err != Z_OK)\n+    /* check that we're reading and that there's no (serious) error */\n+    if (state->mode != GZ_READ ||\n+        (state->err != Z_OK && state->err != Z_BUF_ERROR))\n         return NULL;\n \n     /* process a skip request */\n@@ -569,32 +509,31 @@ char * ZEXPORT gzgets(file, buf, len)\n     left = (unsigned)len - 1;\n     if (left) do {\n         /* assure that something is in the output buffer */\n-        if (state->have == 0) {\n-            if (gz_make(state) == -1)\n-                return NULL;            /* error */\n-            if (state->have == 0) {     /* end of file */\n-                if (buf == str)         /* got bupkus */\n-                    return NULL;\n-                break;                  /* got something -- return it */\n-            }\n+        if (state->x.have == 0 && gz_fetch(state) == -1)\n+            return NULL;                /* error */\n+        if (state->x.have == 0) {       /* end of file */\n+            state->past = 1;            /* read past end */\n+            break;                      /* return what we have */\n         }\n \n         /* look for end-of-line in current output buffer */\n-        n = state->have > left ? left : state->have;\n-        eol = memchr(state->next, '\\n', n);\n+        n = state->x.have > left ? left : state->x.have;\n+        eol = memchr(state->x.next, '\\n', n);\n         if (eol != NULL)\n-            n = (unsigned)(eol - state->next) + 1;\n+            n = (unsigned)(eol - state->x.next) + 1;\n \n         /* copy through end-of-line, or remainder if not found */\n-        memcpy(buf, state->next, n);\n-        state->have -= n;\n-        state->next += n;\n-        state->pos += n;\n+        memcpy(buf, state->x.next, n);\n+        state->x.have -= n;\n+        state->x.next += n;\n+        state->x.pos += n;\n         left -= n;\n         buf += n;\n     } while (left && eol == NULL);\n \n-    /* found end-of-line or out of space -- terminate string and return it */\n+    /* return terminated string, or if nothing, end of file */\n+    if (buf == str)\n+        return NULL;\n     buf[0] = 0;\n     return str;\n }\n@@ -610,24 +549,20 @@ int ZEXPORT gzdirect(file)\n         return 0;\n     state = (gz_statep)file;\n \n-    /* check that we're reading */\n-    if (state->mode != GZ_READ)\n-        return 0;\n-\n     /* if the state is not known, but we can find out, then do so (this is\n        mainly for right after a gzopen() or gzdopen()) */\n-    if (state->how == LOOK && state->have == 0)\n-        (void)gz_head(state);\n+    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)\n+        (void)gz_look(state);\n \n-    /* return 1 if reading direct, 0 if decompressing a gzip stream */\n+    /* return 1 if transparent, 0 if processing a gzip stream */\n     return state->direct;\n }\n \n /* -- see zlib.h -- */\n int ZEXPORT gzclose_r(file)\n     gzFile file;\n {\n-    int ret;\n+    int ret, err;\n     gz_statep state;\n \n     /* get internal structure */\n@@ -645,9 +580,10 @@ int ZEXPORT gzclose_r(file)\n         free(state->out);\n         free(state->in);\n     }\n+    err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;\n     gz_error(state, Z_OK, NULL);\n     free(state->path);\n     ret = close(state->fd);\n     free(state);\n-    return ret ? Z_ERRNO : Z_OK;\n+    return ret ? Z_ERRNO : err;\n }"}, {"sha": "27cb3428e32f16f11b729ac8de1ceed786fb8be1", "filename": "zlib/gzwrite.c", "status": "modified", "additions": 90, "deletions": 56, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fgzwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fgzwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fgzwrite.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,5 +1,5 @@\n /* gzwrite.c -- zlib functions for writing gzip files\n- * Copyright (C) 2004, 2005, 2010 Mark Adler\n+ * Copyright (C) 2004, 2005, 2010, 2011, 2012 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -18,44 +18,55 @@ local int gz_init(state)\n     int ret;\n     z_streamp strm = &(state->strm);\n \n-    /* allocate input and output buffers */\n+    /* allocate input buffer */\n     state->in = malloc(state->want);\n-    state->out = malloc(state->want);\n-    if (state->in == NULL || state->out == NULL) {\n-        if (state->out != NULL)\n-            free(state->out);\n-        if (state->in != NULL)\n-            free(state->in);\n+    if (state->in == NULL) {\n         gz_error(state, Z_MEM_ERROR, \"out of memory\");\n         return -1;\n     }\n \n-    /* allocate deflate memory, set up for gzip compression */\n-    strm->zalloc = Z_NULL;\n-    strm->zfree = Z_NULL;\n-    strm->opaque = Z_NULL;\n-    ret = deflateInit2(strm, state->level, Z_DEFLATED,\n-                       15 + 16, 8, state->strategy);\n-    if (ret != Z_OK) {\n-        free(state->in);\n-        gz_error(state, Z_MEM_ERROR, \"out of memory\");\n-        return -1;\n+    /* only need output buffer and deflate state if compressing */\n+    if (!state->direct) {\n+        /* allocate output buffer */\n+        state->out = malloc(state->want);\n+        if (state->out == NULL) {\n+            free(state->in);\n+            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n+            return -1;\n+        }\n+\n+        /* allocate deflate memory, set up for gzip compression */\n+        strm->zalloc = Z_NULL;\n+        strm->zfree = Z_NULL;\n+        strm->opaque = Z_NULL;\n+        ret = deflateInit2(strm, state->level, Z_DEFLATED,\n+                           MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);\n+        if (ret != Z_OK) {\n+            free(state->out);\n+            free(state->in);\n+            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n+            return -1;\n+        }\n     }\n \n     /* mark state as initialized */\n     state->size = state->want;\n \n-    /* initialize write buffer */\n-    strm->avail_out = state->size;\n-    strm->next_out = state->out;\n-    state->next = strm->next_out;\n+    /* initialize write buffer if compressing */\n+    if (!state->direct) {\n+        strm->avail_out = state->size;\n+        strm->next_out = state->out;\n+        state->x.next = strm->next_out;\n+    }\n     return 0;\n }\n \n /* Compress whatever is at avail_in and next_in and write to the output file.\n    Return -1 if there is an error writing to the output file, otherwise 0.\n    flush is assumed to be a valid deflate() flush value.  If flush is Z_FINISH,\n-   then the deflate() state is reset to start a new gzip stream. */\n+   then the deflate() state is reset to start a new gzip stream.  If gz->direct\n+   is true, then simply write to the output file without compressing, and\n+   ignore flush. */\n local int gz_comp(state, flush)\n     gz_statep state;\n     int flush;\n@@ -68,15 +79,26 @@ local int gz_comp(state, flush)\n     if (state->size == 0 && gz_init(state) == -1)\n         return -1;\n \n+    /* write directly if requested */\n+    if (state->direct) {\n+        got = write(state->fd, strm->next_in, strm->avail_in);\n+        if (got < 0 || (unsigned)got != strm->avail_in) {\n+            gz_error(state, Z_ERRNO, zstrerror());\n+            return -1;\n+        }\n+        strm->avail_in = 0;\n+        return 0;\n+    }\n+\n     /* run deflate() on provided input until it produces no more output */\n     ret = Z_OK;\n     do {\n         /* write out current buffer contents if full, or if flushing, but if\n            doing Z_FINISH then don't write until we get to Z_STREAM_END */\n         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&\n             (flush != Z_FINISH || ret == Z_STREAM_END))) {\n-            have = (unsigned)(strm->next_out - state->next);\n-            if (have && ((got = write(state->fd, state->next, have)) < 0 ||\n+            have = (unsigned)(strm->next_out - state->x.next);\n+            if (have && ((got = write(state->fd, state->x.next, have)) < 0 ||\n                          (unsigned)got != have)) {\n                 gz_error(state, Z_ERRNO, zstrerror());\n                 return -1;\n@@ -85,7 +107,7 @@ local int gz_comp(state, flush)\n                 strm->avail_out = state->size;\n                 strm->next_out = state->out;\n             }\n-            state->next = strm->next_out;\n+            state->x.next = strm->next_out;\n         }\n \n         /* compress */\n@@ -131,7 +153,7 @@ local int gz_zero(state, len)\n         }\n         strm->avail_in = n;\n         strm->next_in = state->in;\n-        state->pos += n;\n+        state->x.pos += n;\n         if (gz_comp(state, Z_NO_FLUSH) == -1)\n             return -1;\n         len -= n;\n@@ -163,7 +185,7 @@ int ZEXPORT gzwrite(file, buf, len)\n     /* since an int is returned, make sure len fits in one, otherwise return\n        with an error (this avoids the flaw in the interface) */\n     if ((int)len < 0) {\n-        gz_error(state, Z_BUF_ERROR, \"requested length does not fit in int\");\n+        gz_error(state, Z_DATA_ERROR, \"requested length does not fit in int\");\n         return 0;\n     }\n \n@@ -193,7 +215,7 @@ int ZEXPORT gzwrite(file, buf, len)\n                 n = len;\n             memcpy(strm->next_in + strm->avail_in, buf, n);\n             strm->avail_in += n;\n-            state->pos += n;\n+            state->x.pos += n;\n             buf = (char *)buf + n;\n             len -= n;\n             if (len && gz_comp(state, Z_NO_FLUSH) == -1)\n@@ -208,7 +230,7 @@ int ZEXPORT gzwrite(file, buf, len)\n         /* directly compress user buffer to file */\n         strm->avail_in = len;\n         strm->next_in = (voidp)buf;\n-        state->pos += len;\n+        state->x.pos += len;\n         if (gz_comp(state, Z_NO_FLUSH) == -1)\n             return 0;\n     }\n@@ -249,15 +271,15 @@ int ZEXPORT gzputc(file, c)\n         if (strm->avail_in == 0)\n             strm->next_in = state->in;\n         strm->next_in[strm->avail_in++] = c;\n-        state->pos++;\n-        return c;\n+        state->x.pos++;\n+        return c & 0xff;\n     }\n \n     /* no room in buffer or not initialized, use gz_write() */\n     buf[0] = c;\n     if (gzwrite(file, buf, 1) != 1)\n         return -1;\n-    return c;\n+    return c & 0xff;\n }\n \n /* -- see zlib.h -- */\n@@ -274,7 +296,7 @@ int ZEXPORT gzputs(file, str)\n     return ret == 0 && len != 0 ? -1 : ret;\n }\n \n-#ifdef STDC\n+#if defined(STDC) || defined(Z_HAVE_STDARG_H)\n #include <stdarg.h>\n \n /* -- see zlib.h -- */\n@@ -316,19 +338,19 @@ int ZEXPORTVA gzprintf (gzFile file, const char *format, ...)\n     va_start(va, format);\n #ifdef NO_vsnprintf\n #  ifdef HAS_vsprintf_void\n-    (void)vsprintf(state->in, format, va);\n+    (void)vsprintf((char *)(state->in), format, va);\n     va_end(va);\n     for (len = 0; len < size; len++)\n         if (state->in[len] == 0) break;\n #  else\n-    len = vsprintf(state->in, format, va);\n+    len = vsprintf((char *)(state->in), format, va);\n     va_end(va);\n #  endif\n #else\n #  ifdef HAS_vsnprintf_void\n-    (void)vsnprintf(state->in, size, format, va);\n+    (void)vsnprintf((char *)(state->in), size, format, va);\n     va_end(va);\n-    len = strlen(state->in);\n+    len = strlen((char *)(state->in));\n #  else\n     len = vsnprintf((char *)(state->in), size, format, va);\n     va_end(va);\n@@ -342,11 +364,11 @@ int ZEXPORTVA gzprintf (gzFile file, const char *format, ...)\n     /* update buffer and position, defer compression until needed */\n     strm->avail_in = (unsigned)len;\n     strm->next_in = state->in;\n-    state->pos += len;\n+    state->x.pos += len;\n     return len;\n }\n \n-#else /* !STDC */\n+#else /* !STDC && !Z_HAVE_STDARG_H */\n \n /* -- see zlib.h -- */\n int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n@@ -366,6 +388,10 @@ int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n     state = (gz_statep)file;\n     strm = &(state->strm);\n \n+    /* check that can really pass pointer in ints */\n+    if (sizeof(int) != sizeof(void *))\n+        return 0;\n+\n     /* check that we're writing and that there's no error */\n     if (state->mode != GZ_WRITE || state->err != Z_OK)\n         return 0;\n@@ -390,22 +416,23 @@ int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n     state->in[size - 1] = 0;\n #ifdef NO_snprintf\n #  ifdef HAS_sprintf_void\n-    sprintf(state->in, format, a1, a2, a3, a4, a5, a6, a7, a8,\n+    sprintf((char *)(state->in), format, a1, a2, a3, a4, a5, a6, a7, a8,\n             a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n     for (len = 0; len < size; len++)\n         if (state->in[len] == 0) break;\n #  else\n-    len = sprintf(state->in, format, a1, a2, a3, a4, a5, a6, a7, a8,\n-                a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n+    len = sprintf((char *)(state->in), format, a1, a2, a3, a4, a5, a6, a7, a8,\n+                  a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n #  endif\n #else\n #  ifdef HAS_snprintf_void\n-    snprintf(state->in, size, format, a1, a2, a3, a4, a5, a6, a7, a8,\n+    snprintf((char *)(state->in), size, format, a1, a2, a3, a4, a5, a6, a7, a8,\n              a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n-    len = strlen(state->in);\n+    len = strlen((char *)(state->in));\n #  else\n-    len = snprintf(state->in, size, format, a1, a2, a3, a4, a5, a6, a7, a8,\n-                 a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n+    len = snprintf((char *)(state->in), size, format, a1, a2, a3, a4, a5, a6,\n+                   a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18,\n+                   a19, a20);\n #  endif\n #endif\n \n@@ -416,7 +443,7 @@ int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n     /* update buffer and position, defer compression until needed */\n     strm->avail_in = (unsigned)len;\n     strm->next_in = state->in;\n-    state->pos += len;\n+    state->x.pos += len;\n     return len;\n }\n \n@@ -500,7 +527,7 @@ int ZEXPORT gzsetparams(file, level, strategy)\n int ZEXPORT gzclose_w(file)\n     gzFile file;\n {\n-    int ret = 0;\n+    int ret = Z_OK;\n     gz_statep state;\n \n     /* get internal structure */\n@@ -515,17 +542,24 @@ int ZEXPORT gzclose_w(file)\n     /* check for seek request */\n     if (state->seek) {\n         state->seek = 0;\n-        ret += gz_zero(state, state->skip);\n+        if (gz_zero(state, state->skip) == -1)\n+            ret = state->err;\n     }\n \n     /* flush, free memory, and close file */\n-    ret += gz_comp(state, Z_FINISH);\n-    (void)deflateEnd(&(state->strm));\n-    free(state->out);\n-    free(state->in);\n+    if (state->size) {\n+        if (gz_comp(state, Z_FINISH) == -1)\n+            ret = state->err;\n+        if (!state->direct) {\n+            (void)deflateEnd(&(state->strm));\n+            free(state->out);\n+        }\n+        free(state->in);\n+    }\n     gz_error(state, Z_OK, NULL);\n     free(state->path);\n-    ret += close(state->fd);\n+    if (close(state->fd) == -1)\n+        ret = Z_ERRNO;\n     free(state);\n-    return ret ? Z_ERRNO : Z_OK;\n+    return ret;\n }"}, {"sha": "981aff17c2d4ab0f157e503219e4ca9bd68eaf3a", "filename": "zlib/infback.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Finfback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Finfback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finfback.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,5 +1,5 @@\n /* infback.c -- inflate using a call-back interface\n- * Copyright (C) 1995-2009 Mark Adler\n+ * Copyright (C) 1995-2011 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -42,10 +42,19 @@ int stream_size;\n         return Z_STREAM_ERROR;\n     strm->msg = Z_NULL;                 /* in case we return an error */\n     if (strm->zalloc == (alloc_func)0) {\n+#ifdef Z_SOLO\n+        return Z_STREAM_ERROR;\n+#else\n         strm->zalloc = zcalloc;\n         strm->opaque = (voidpf)0;\n+#endif\n     }\n-    if (strm->zfree == (free_func)0) strm->zfree = zcfree;\n+    if (strm->zfree == (free_func)0)\n+#ifdef Z_SOLO\n+        return Z_STREAM_ERROR;\n+#else\n+    strm->zfree = zcfree;\n+#endif\n     state = (struct inflate_state FAR *)ZALLOC(strm, 1,\n                                                sizeof(struct inflate_state));\n     if (state == Z_NULL) return Z_MEM_ERROR;\n@@ -394,7 +403,6 @@ void FAR *out_desc;\n                     PULLBYTE();\n                 }\n                 if (here.val < 16) {\n-                    NEEDBITS(here.bits);\n                     DROPBITS(here.bits);\n                     state->lens[state->have++] = here.val;\n                 }"}, {"sha": "d6283277694802ce7938f537f12990d6eead4924", "filename": "zlib/inffixed.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Finffixed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Finffixed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finffixed.h?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -2,9 +2,9 @@\n      * Generated automatically by makefixed().\n      */\n \n-    /* WARNING: this file should *not* be used by applications. It\n-       is part of the implementation of the compression library and\n-       is subject to change. Applications should only use zlib.h.\n+    /* WARNING: this file should *not* be used by applications.\n+       It is part of the implementation of this library and is\n+       subject to change. Applications should only use zlib.h.\n      */\n \n     static const code lenfix[512] = {"}, {"sha": "47418a1e1e1e6b3690c45d8de9e2fc3c1e6945f2", "filename": "zlib/inflate.c", "status": "modified", "additions": 53, "deletions": 37, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Finflate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Finflate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finflate.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,5 +1,5 @@\n /* inflate.c -- zlib decompression\n- * Copyright (C) 1995-2010 Mark Adler\n+ * Copyright (C) 1995-2012 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -100,7 +100,7 @@ local int updatewindow OF((z_streamp strm, unsigned out));\n local unsigned syncsearch OF((unsigned FAR *have, unsigned char FAR *buf,\n                               unsigned len));\n \n-int ZEXPORT inflateReset(strm)\n+int ZEXPORT inflateResetKeep(strm)\n z_streamp strm;\n {\n     struct inflate_state FAR *state;\n@@ -109,15 +109,13 @@ z_streamp strm;\n     state = (struct inflate_state FAR *)strm->state;\n     strm->total_in = strm->total_out = state->total = 0;\n     strm->msg = Z_NULL;\n-    strm->adler = 1;        /* to support ill-conceived Java test suite */\n+    if (state->wrap)        /* to support ill-conceived Java test suite */\n+        strm->adler = state->wrap & 1;\n     state->mode = HEAD;\n     state->last = 0;\n     state->havedict = 0;\n     state->dmax = 32768U;\n     state->head = Z_NULL;\n-    state->wsize = 0;\n-    state->whave = 0;\n-    state->wnext = 0;\n     state->hold = 0;\n     state->bits = 0;\n     state->lencode = state->distcode = state->next = state->codes;\n@@ -127,6 +125,19 @@ z_streamp strm;\n     return Z_OK;\n }\n \n+int ZEXPORT inflateReset(strm)\n+z_streamp strm;\n+{\n+    struct inflate_state FAR *state;\n+\n+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n+    state = (struct inflate_state FAR *)strm->state;\n+    state->wsize = 0;\n+    state->whave = 0;\n+    state->wnext = 0;\n+    return inflateResetKeep(strm);\n+}\n+\n int ZEXPORT inflateReset2(strm, windowBits)\n z_streamp strm;\n int windowBits;\n@@ -180,10 +191,19 @@ int stream_size;\n     if (strm == Z_NULL) return Z_STREAM_ERROR;\n     strm->msg = Z_NULL;                 /* in case we return an error */\n     if (strm->zalloc == (alloc_func)0) {\n+#ifdef Z_SOLO\n+        return Z_STREAM_ERROR;\n+#else\n         strm->zalloc = zcalloc;\n         strm->opaque = (voidpf)0;\n+#endif\n     }\n-    if (strm->zfree == (free_func)0) strm->zfree = zcfree;\n+    if (strm->zfree == (free_func)0)\n+#ifdef Z_SOLO\n+        return Z_STREAM_ERROR;\n+#else\n+        strm->zfree = zcfree;\n+#endif\n     state = (struct inflate_state FAR *)\n             ZALLOC(strm, 1, sizeof(struct inflate_state));\n     if (state == Z_NULL) return Z_MEM_ERROR;\n@@ -321,8 +341,8 @@ void makefixed()\n     low = 0;\n     for (;;) {\n         if ((low % 7) == 0) printf(\"\\n        \");\n-        printf(\"{%u,%u,%d}\", state.lencode[low].op, state.lencode[low].bits,\n-               state.lencode[low].val);\n+        printf(\"{%u,%u,%d}\", (low & 127) == 99 ? 64 : state.lencode[low].op,\n+               state.lencode[low].bits, state.lencode[low].val);\n         if (++low == size) break;\n         putchar(',');\n     }\n@@ -499,11 +519,6 @@ unsigned out;\n         bits -= bits & 7; \\\n     } while (0)\n \n-/* Reverse the bytes in a 32-bit value */\n-#define REVERSE(q) \\\n-    ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \\\n-     (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))\n-\n /*\n    inflate() uses a state machine to process as much input data and generate as\n    much output data as possible before returning.  The state machine is\n@@ -797,7 +812,7 @@ int flush;\n #endif\n         case DICTID:\n             NEEDBITS(32);\n-            strm->adler = state->check = REVERSE(hold);\n+            strm->adler = state->check = ZSWAP32(hold);\n             INITBITS();\n             state->mode = DICT;\n         case DICT:\n@@ -925,7 +940,6 @@ int flush;\n                     PULLBYTE();\n                 }\n                 if (here.val < 16) {\n-                    NEEDBITS(here.bits);\n                     DROPBITS(here.bits);\n                     state->lens[state->have++] = here.val;\n                 }\n@@ -1170,7 +1184,7 @@ int flush;\n #ifdef GUNZIP\n                      state->flags ? hold :\n #endif\n-                     REVERSE(hold)) != state->check) {\n+                     ZSWAP32(hold)) != state->check) {\n                     strm->msg = (char *)\"incorrect data check\";\n                     state->mode = BAD;\n                     break;\n@@ -1214,7 +1228,8 @@ int flush;\n      */\n   inf_leave:\n     RESTORE();\n-    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))\n+    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&\n+            (state->mode < CHECK || flush != Z_FINISH)))\n         if (updatewindow(strm, out)) {\n             state->mode = MEM;\n             return Z_MEM_ERROR;\n@@ -1255,37 +1270,38 @@ const Bytef *dictionary;\n uInt dictLength;\n {\n     struct inflate_state FAR *state;\n-    unsigned long id;\n+    unsigned long dictid;\n+    unsigned char *next;\n+    unsigned avail;\n+    int ret;\n \n     /* check state */\n     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n     state = (struct inflate_state FAR *)strm->state;\n     if (state->wrap != 0 && state->mode != DICT)\n         return Z_STREAM_ERROR;\n \n-    /* check for correct dictionary id */\n+    /* check for correct dictionary identifier */\n     if (state->mode == DICT) {\n-        id = adler32(0L, Z_NULL, 0);\n-        id = adler32(id, dictionary, dictLength);\n-        if (id != state->check)\n+        dictid = adler32(0L, Z_NULL, 0);\n+        dictid = adler32(dictid, dictionary, dictLength);\n+        if (dictid != state->check)\n             return Z_DATA_ERROR;\n     }\n \n-    /* copy dictionary to window */\n-    if (updatewindow(strm, strm->avail_out)) {\n+    /* copy dictionary to window using updatewindow(), which will amend the\n+       existing dictionary if appropriate */\n+    next = strm->next_out;\n+    avail = strm->avail_out;\n+    strm->next_out = (Bytef *)dictionary + dictLength;\n+    strm->avail_out = 0;\n+    ret = updatewindow(strm, dictLength);\n+    strm->avail_out = avail;\n+    strm->next_out = next;\n+    if (ret) {\n         state->mode = MEM;\n         return Z_MEM_ERROR;\n     }\n-    if (dictLength > state->wsize) {\n-        zmemcpy(state->window, dictionary + dictLength - state->wsize,\n-                state->wsize);\n-        state->whave = state->wsize;\n-    }\n-    else {\n-        zmemcpy(state->window + state->wsize - dictLength, dictionary,\n-                dictLength);\n-        state->whave = dictLength;\n-    }\n     state->havedict = 1;\n     Tracev((stderr, \"inflate:   dictionary set\\n\"));\n     return Z_OK;\n@@ -1433,8 +1449,8 @@ z_streamp source;\n     }\n \n     /* copy state */\n-    zmemcpy(dest, source, sizeof(z_stream));\n-    zmemcpy(copy, state, sizeof(struct inflate_state));\n+    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));\n+    zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));\n     if (state->lencode >= state->codes &&\n         state->lencode <= state->codes + ENOUGH - 1) {\n         copy->lencode = copy->codes + (state->lencode - state->codes);"}, {"sha": "abcd7c45ed354df856a76c6060a26be51d830804", "filename": "zlib/inftrees.c", "status": "modified", "additions": 11, "deletions": 35, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Finftrees.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Finftrees.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finftrees.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,5 +1,5 @@\n /* inftrees.c -- generate Huffman trees for efficient decoding\n- * Copyright (C) 1995-2010 Mark Adler\n+ * Copyright (C) 1995-2012 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -9,7 +9,7 @@\n #define MAXBITS 15\n \n const char inflate_copyright[] =\n-   \" inflate 1.2.5 Copyright 1995-2010 Mark Adler \";\n+   \" inflate 1.2.7 Copyright 1995-2012 Mark Adler \";\n /*\n   If you use the zlib library in a product, an acknowledgment is welcome\n   in the documentation of your product. If for some reason you cannot\n@@ -62,7 +62,7 @@ unsigned short FAR *work;\n         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n     static const unsigned short lext[31] = { /* Length codes 257..285 extra */\n         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n-        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 73, 195};\n+        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 78, 68};\n     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */\n         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n@@ -289,38 +289,14 @@ unsigned short FAR *work;\n         }\n     }\n \n-    /*\n-       Fill in rest of table for incomplete codes.  This loop is similar to the\n-       loop above in incrementing huff for table indices.  It is assumed that\n-       len is equal to curr + drop, so there is no loop needed to increment\n-       through high index bits.  When the current sub-table is filled, the loop\n-       drops back to the root table to fill in any remaining entries there.\n-     */\n-    here.op = (unsigned char)64;                /* invalid code marker */\n-    here.bits = (unsigned char)(len - drop);\n-    here.val = (unsigned short)0;\n-    while (huff != 0) {\n-        /* when done with sub-table, drop back to root table */\n-        if (drop != 0 && (huff & mask) != low) {\n-            drop = 0;\n-            len = root;\n-            next = *table;\n-            here.bits = (unsigned char)len;\n-        }\n-\n-        /* put invalid code marker in table */\n-        next[huff >> drop] = here;\n-\n-        /* backwards increment the len-bit code huff */\n-        incr = 1U << (len - 1);\n-        while (huff & incr)\n-            incr >>= 1;\n-        if (incr != 0) {\n-            huff &= incr - 1;\n-            huff += incr;\n-        }\n-        else\n-            huff = 0;\n+    /* fill in remaining table entry if code is incomplete (guaranteed to have\n+       at most one remaining entry, since if the code is incomplete, the\n+       maximum code length that was allowed to get this far is one bit) */\n+    if (huff != 0) {\n+        here.op = (unsigned char)64;            /* invalid code marker */\n+        here.bits = (unsigned char)(len - drop);\n+        here.val = (unsigned short)0;\n+        next[huff] = here;\n     }\n \n     /* set return parameters */"}, {"sha": "65e9d0cbc8e1ddfc828ddc26ecb74c7b507faf20", "filename": "zlib/make_vms.com", "status": "modified", "additions": 233, "deletions": 170, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fmake_vms.com", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fmake_vms.com", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmake_vms.com?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -3,7 +3,7 @@ $! Martin P.J. Zinser\n $!\n $! In case of problems with the install you might contact me at\n $! zinser@zinser.no-ip.info(preferred) or\n-$! zinser@sysdev.deutsche-boerse.com (work)\n+$! martin.zinser@eurexchange.com (work)\n $!\n $! Make procedure history for Zlib\n $!\n@@ -14,9 +14,16 @@ $! 0.02 20061008 Adapt to new Makefile.in\n $! 0.03 20091224 Add support for large file check\n $! 0.04 20100110 Add new gzclose, gzlib, gzread, gzwrite\n $! 0.05 20100221 Exchange zlibdefs.h by zconf.h.in\n+$! 0.06 20120111 Fix missing amiss_err, update zconf_h.in, fix new exmples\n+$!               subdir path, update module search in makefile.in\n+$! 0.07 20120115 Triggered by work done by Alexey Chupahin completly redesigned\n+$!               shared image creation\n+$! 0.08 20120219 Make it work on VAX again, pre-load missing symbols to shared\n+$!               image\n+$! 0.09 20120305 SMS.  P1 sets builder (\"MMK\", \"MMS\", \" \" (built-in)).\n+$!               \"\" -> automatic, preference: MMK, MMS, built-in.\n $!\n $ on error then goto err_exit\n-$ set proc/parse=ext\n $!\n $ true  = 1\n $ false = 0\n@@ -32,31 +39,43 @@ $ s_case   = False\n $!\n $! Setup variables holding \"config\" information\n $!\n-$ Make    = \"\"\n+$ Make    = \"''p1'\"\n $ name     = \"Zlib\"\n $ version  = \"?.?.?\"\n $ v_string = \"ZLIB_VERSION\"\n $ v_file   = \"zlib.h\"\n-$ ccopt   = \"\"\n+$ ccopt   = \"/include = []\"\n $ lopts   = \"\"\n $ dnsrl   = \"\"\n-$ aconf_in_file = \"zconf.h.in#zconf.h_in\"\n+$ aconf_in_file = \"zconf.h.in#zconf.h_in#zconf_h.in\"\n $ conf_check_string = \"\"\n $ linkonly = false\n $ optfile  = name + \".opt\"\n+$ mapfile  = name + \".map\"\n $ libdefs  = \"\"\n+$ vax      = f$getsyi(\"HW_MODEL\").lt.1024\n $ axp      = f$getsyi(\"HW_MODEL\").ge.1024 .and. f$getsyi(\"HW_MODEL\").lt.4096\n+$ ia64     = f$getsyi(\"HW_MODEL\").ge.4096\n $!\n-$ whoami = f$parse(f$enviornment(\"Procedure\"),,,,\"NO_CONCEAL\")\n+$! 2012-03-05 SMS.\n+$! Why is this needed?  And if it is needed, why not simply \".not. vax\"?\n+$!\n+$!!! if axp .or. ia64 then  set proc/parse=extended\n+$!\n+$ whoami = f$parse(f$environment(\"Procedure\"),,,,\"NO_CONCEAL\")\n $ mydef  = F$parse(whoami,,,\"DEVICE\")\n $ mydir  = f$parse(whoami,,,\"DIRECTORY\") - \"][\"\n $ myproc = f$parse(whoami,,,\"Name\") + f$parse(whoami,,,\"type\")\n $!\n $! Check for MMK/MMS\n $!\n-$ If F$Search (\"Sys$System:MMS.EXE\") .nes. \"\" Then Make = \"MMS\"\n-$ If F$Type (MMK) .eqs. \"STRING\" Then Make = \"MMK\"\n-$!\n+$ if (Make .eqs. \"\")\n+$ then\n+$   If F$Search (\"Sys$System:MMS.EXE\") .nes. \"\" Then Make = \"MMS\"\n+$   If F$Type (MMK) .eqs. \"STRING\" Then Make = \"MMK\"\n+$ else\n+$   Make = f$edit( Make, \"trim\")\n+$ endif\n $!\n $ gosub find_version\n $!\n@@ -69,6 +88,7 @@ $! Look for the compiler used\n $!\n $ gosub check_compiler\n $ close topt\n+$ close optf\n $!\n $ if its_decc\n $ then\n@@ -83,6 +103,15 @@ $       ccopt = \"/decc\" + ccopt\n $       define sys decc$library_include:\n $     endif\n $   endif\n+$!\n+$! 2012-03-05 SMS.\n+$! Why /NAMES = AS_IS?  Why not simply \".not. vax\"?  And why not on VAX?\n+$!\n+$   if axp .or. ia64\n+$   then\n+$       ccopt = ccopt + \"/name=as_is/opt=(inline=speed)\"\n+$       s_case = true\n+$   endif\n $ endif\n $ if its_vaxc .or. its_gnuc\n $ then\n@@ -122,15 +151,20 @@ $   gosub check_config\n $ endif\n $ goto aconf_loop\n $ACONF_EXIT:\n+$ write aconf \"\"\n+$ write aconf \"/* VMS specifics added by make_vms.com: */\"\n $ write aconf \"#define VMS 1\"\n $ write aconf \"#include <unistd.h>\"\n $ write aconf \"#include <unixio.h>\"\n $ write aconf \"#ifdef _LARGEFILE\"\n-$ write aconf \"#define off64_t __off64_t\"\n-$ write aconf \"#define fopen64 fopen\"\n-$ write aconf \"#define fseeko64 fseeko\"\n-$ write aconf \"#define lseek64 lseek\"\n-$ write aconf \"#define ftello64 ftell\"\n+$ write aconf \"# define off64_t __off64_t\"\n+$ write aconf \"# define fopen64 fopen\"\n+$ write aconf \"# define fseeko64 fseeko\"\n+$ write aconf \"# define lseek64 lseek\"\n+$ write aconf \"# define ftello64 ftell\"\n+$ write aconf \"#endif\"\n+$ write aconf \"#if !defined( __VAX) && (__CRTL_VER >= 70312000)\"\n+$ write aconf \"# define HAVE_VSNPRINTF\"\n $ write aconf \"#endif\"\n $ close aconf_in\n $ close aconf\n@@ -139,8 +173,9 @@ $! Build the thing plain or with mms\n $!\n $ write sys$output \"Compiling Zlib sources ...\"\n $ if make.eqs.\"\"\n-$  then\n-$   dele example.obj;*,minigzip.obj;*\n+$ then\n+$   if (f$search( \"example.obj;*\") .nes. \"\") then delete example.obj;*\n+$   if (f$search( \"minigzip.obj;*\") .nes. \"\") then delete minigzip.obj;*\n $   CALL MAKE adler32.OBJ \"CC ''CCOPT' adler32\" -\n                 adler32.c zlib.h zconf.h\n $   CALL MAKE compress.OBJ \"CC ''CCOPT' compress\" -\n@@ -174,49 +209,41 @@ $   CALL MAKE zutil.OBJ \"CC ''CCOPT' zutil\" -\n $   write sys$output \"Building Zlib ...\"\n $   CALL MAKE libz.OLB \"lib/crea libz.olb *.obj\" *.OBJ\n $   write sys$output \"Building example...\"\n-$   CALL MAKE example.OBJ \"CC ''CCOPT' example\" -\n-                example.c zlib.h zconf.h\n+$   CALL MAKE example.OBJ \"CC ''CCOPT' [.test]example\" -\n+                [.test]example.c zlib.h zconf.h\n $   call make example.exe \"LINK example,libz.olb/lib\" example.obj libz.olb\n-$   if f$search(\"x11vms:xvmsutils.olb\") .nes. \"\"\n-$   then\n-$     write sys$output \"Building minigzip...\"\n-$     CALL MAKE minigzip.OBJ \"CC ''CCOPT' minigzip\" -\n-                minigzip.c zlib.h zconf.h\n-$     call make minigzip.exe -\n-                \"LINK minigzip,libz.olb/lib,x11vms:xvmsutils.olb/lib\" -\n-                minigzip.obj libz.olb\n-$   endif\n-$  else\n+$   write sys$output \"Building minigzip...\"\n+$   CALL MAKE minigzip.OBJ \"CC ''CCOPT' [.test]minigzip\" -\n+              [.test]minigzip.c zlib.h zconf.h\n+$   call make minigzip.exe -\n+              \"LINK minigzip,libz.olb/lib\" -\n+              minigzip.obj libz.olb\n+$ else\n $   gosub crea_mms\n $   write sys$output \"Make ''name' ''version' with ''Make' \"\n $   'make'\n-$  endif\n+$ endif\n $!\n-$! Alpha gets a shareable image\n+$! Create shareable image\n $!\n-$ If axp\n-$ Then\n-$   gosub crea_olist\n-$   write sys$output \"Creating libzshr.exe\"\n-$   call anal_obj_axp modules.opt _link.opt\n-$   if s_case\n-$   then\n-$      open/append optf modules.opt\n-$      write optf \"case_sensitive=YES\"\n-$      close optf\n-$   endif\n-$   LINK_'lopts'/SHARE=libzshr.exe modules.opt/opt,_link.opt/opt\n-$ endif\n+$ gosub crea_olist\n+$ write sys$output \"Creating libzshr.exe\"\n+$ call map_2_shopt 'mapfile' 'optfile'\n+$ LINK_'lopts'/SHARE=libzshr.exe modules.opt/opt,'optfile'/opt\n $ write sys$output \"Zlib build completed\"\n+$ delete/nolog tmp.opt;*\n $ exit\n+$AMISS_ERR:\n+$ write sys$output \"No source for config.hin found.\"\n+$ write sys$output \"Tried any of ''aconf_in_file'\"\n+$ goto err_exit\n $CC_ERR:\n $ write sys$output \"C compiler required to build ''name'\"\n $ goto err_exit\n $ERR_EXIT:\n $ set message/facil/ident/sever/text\n $ close/nolog optf\n $ close/nolog topt\n-$ close/nolog conf_hin\n $ close/nolog aconf_in\n $ close/nolog aconf\n $ close/nolog out\n@@ -397,7 +424,7 @@ $ copy sys$input: out\n $ deck\n # descrip.mms: MMS description file for building zlib on VMS\n # written by Martin P.J. Zinser\n-# <zinser@zinser.no-ip.info or zinser@sysdev.deutsche-boerse.com>\n+# <zinser@zinser.no-ip.info or martin.zinser@eurexchange.com>\n \n OBJS = adler32.obj, compress.obj, crc32.obj, gzclose.obj, gzlib.obj\\\n        gzread.obj, gzwrite.obj, uncompr.obj, infback.obj\\\n@@ -407,10 +434,9 @@ OBJS = adler32.obj, compress.obj, crc32.obj, gzclose.obj, gzlib.obj\\\n $ eod\n $ write out \"CFLAGS=\", ccopt\n $ write out \"LOPTS=\", lopts\n+$ write out \"all : example.exe minigzip.exe libz.olb\"\n $ copy sys$input: out\n $ deck\n-\n-all : example.exe minigzip.exe libz.olb\n         @ write sys$output \" Example applications available\"\n \n libz.olb : libz.olb($(OBJS))\n@@ -420,7 +446,7 @@ example.exe : example.obj libz.olb\n               link $(LOPTS) example,libz.olb/lib\n \n minigzip.exe : minigzip.obj libz.olb\n-              link $(LOPTS) minigzip,libz.olb/lib,x11vms:xvmsutils.olb/lib\n+              link $(LOPTS) minigzip,libz.olb/lib\n \n clean :\n \tdelete *.obj;*,libz.olb;*,*.opt;*,*.exe;*\n@@ -431,15 +457,15 @@ adler32.obj  : adler32.c zutil.h zlib.h zconf.h\n compress.obj : compress.c zlib.h zconf.h\n crc32.obj    : crc32.c zutil.h zlib.h zconf.h\n deflate.obj  : deflate.c deflate.h zutil.h zlib.h zconf.h\n-example.obj  : example.c zlib.h zconf.h\n+example.obj  : [.test]example.c zlib.h zconf.h\n gzclose.obj  : gzclose.c zutil.h zlib.h zconf.h\n gzlib.obj    : gzlib.c zutil.h zlib.h zconf.h\n gzread.obj   : gzread.c zutil.h zlib.h zconf.h\n gzwrite.obj  : gzwrite.c zutil.h zlib.h zconf.h\n inffast.obj  : inffast.c zutil.h zlib.h zconf.h inftrees.h inffast.h\n inflate.obj  : inflate.c zutil.h zlib.h zconf.h\n inftrees.obj : inftrees.c zutil.h zlib.h zconf.h inftrees.h\n-minigzip.obj : minigzip.c zlib.h zconf.h\n+minigzip.obj : [.test]minigzip.c zlib.h zconf.h\n trees.obj    : trees.c deflate.h zutil.h zlib.h zconf.h\n uncompr.obj  : uncompr.c zlib.h zconf.h\n zutil.obj    : zutil.c zutil.h zlib.h zconf.h\n@@ -455,13 +481,18 @@ $!\n $CREA_OLIST:\n $ open/read min makefile.in\n $ open/write mod modules.opt\n-$ src_check = \"OBJC =\"\n+$ src_check_list = \"OBJZ =#OBJG =\"\n $MRLOOP:\n $ read/end=mrdone min rec\n-$ if (f$extract(0,6,rec) .nes. src_check) then goto mrloop\n+$ i = 0\n+$SRC_CHECK_LOOP:\n+$ src_check = f$element(i, \"#\", src_check_list)\n+$ i = i+1\n+$ if src_check .eqs. \"#\" then goto mrloop\n+$ if (f$extract(0,6,rec) .nes. src_check) then goto src_check_loop\n $ rec = rec - src_check\n $ gosub extra_filnam\n-$ if (f$element(1,\"\\\",rec) .eqs. \"\\\") then goto mrdone\n+$ if (f$element(1,\"\\\",rec) .eqs. \"\\\") then goto mrloop\n $MRSLOOP:\n $ read/end=mrdone min rec\n $ gosub extra_filnam\n@@ -672,133 +703,165 @@ $ endif\n $ return\n $!------------------------------------------------------------------------------\n $!\n-$! Analyze Object files for OpenVMS AXP to extract Procedure and Data\n-$! information to build a symbol vector for a shareable image\n-$! All the \"brains\" of this logic was suggested by Hartmut Becker\n-$! (Hartmut.Becker@compaq.com). All the bugs were introduced by me\n-$! (zinser@zinser.no-ip.info), so if you do have problem reports please do not\n-$! bother Hartmut/HP, but get in touch with me\n+$! Write configuration to both permanent and temporary config file\n $!\n $! Version history\n-$! 0.01 20040406 Skip over shareable images in option file\n-$! 0.02 20041109 Fix option file for shareable images with case_sensitive=YES\n-$! 0.03 20050107 Skip over Identification labels in option file\n-$! 0.04 20060117 Add uppercase alias to code compiled with /name=as_is\n+$! 0.01 20031029 First version to receive a number\n+$!\n+$WRITE_CONFIG: SUBROUTINE\n+$  write aconf 'p1'\n+$  open/append confh 'th'\n+$  write confh 'p1'\n+$  close confh\n+$ENDSUBROUTINE\n+$!------------------------------------------------------------------------------\n+$!\n+$! Analyze the project map file and create the symbol vector for a shareable\n+$! image from it\n+$!\n+$! Version history\n+$! 0.01 20120128 First version\n+$! 0.02 20120226 Add pre-load logic\n+$!\n+$ MAP_2_SHOPT: Subroutine\n $!\n-$ ANAL_OBJ_AXP: Subroutine\n-$ V = 'F$Verify(0)\n $ SAY := \"WRITE_ SYS$OUTPUT\"\n-$\n+$!\n $ IF F$SEARCH(\"''P1'\") .EQS. \"\"\n $ THEN\n-$    SAY \"ANAL_OBJ_AXP-E-NOSUCHFILE:  Error, inputfile ''p1' not available\"\n-$    goto exit_aa\n+$    SAY \"MAP_2_SHOPT-E-NOSUCHFILE:  Error, inputfile ''p1' not available\"\n+$    goto exit_m2s\n $ ENDIF\n $ IF \"''P2'\" .EQS. \"\"\n $ THEN\n-$    SAY \"ANAL_OBJ_AXP:  Error, no output file provided\"\n-$    goto exit_aa\n+$    SAY \"MAP_2_SHOPT:  Error, no output file provided\"\n+$    goto exit_m2s\n $ ENDIF\n-$\n-$ open/read in 'p1\n-$ create a.tmp\n-$ open/append atmp a.tmp\n-$ loop:\n-$ read/end=end_loop in line\n-$ if f$locate(\"/SHARE\",f$edit(line,\"upcase\")) .lt. f$length(line)\n-$ then\n-$   write sys$output \"ANAL_SKP_SHR-i-skipshare, ''line'\"\n-$   goto loop\n-$ endif\n-$ if f$locate(\"IDENTIFICATION=\",f$edit(line,\"upcase\")) .lt. f$length(line)\n-$ then\n-$   write sys$output \"ANAL_OBJ_AXP-i-ident: Identification \", -\n-                     f$element(1,\"=\",line)\n-$   goto loop\n-$ endif\n-$ f= f$search(line)\n-$ if f .eqs. \"\"\n-$ then\n-$\twrite sys$output \"ANAL_OBJ_AXP-w-nosuchfile, ''line'\"\n-$\tgoto loop\n-$ endif\n-$ define/user sys$output nl:\n-$ define/user sys$error nl:\n-$ anal/obj/gsd 'f /out=x.tmp\n-$ open/read xtmp x.tmp\n-$ XLOOP:\n-$ read/end=end_xloop xtmp xline\n-$ xline = f$edit(xline,\"compress\")\n-$ write atmp xline\n-$ goto xloop\n-$ END_XLOOP:\n-$ close xtmp\n-$ goto loop\n-$ end_loop:\n-$ close in\n-$ close atmp\n-$ if f$search(\"a.tmp\") .eqs. \"\" -\n-\tthen $ exit\n-$ ! all global definitions\n-$ search a.tmp \"symbol:\",\"EGSY$V_DEF 1\",\"EGSY$V_NORM 1\"/out=b.tmp\n-$ ! all procedures\n-$ search b.tmp \"EGSY$V_NORM 1\"/wind=(0,1) /out=c.tmp\n-$ search c.tmp \"symbol:\"/out=d.tmp\n-$ define/user sys$output nl:\n-$ edito/edt/command=sys$input d.tmp\n-sub/symbol: \"/symbol_vector=(/whole\n-sub/\"/=PROCEDURE)/whole\n-exit\n-$ ! all data\n-$ search b.tmp \"EGSY$V_DEF 1\"/wind=(0,1) /out=e.tmp\n-$ search e.tmp \"symbol:\"/out=f.tmp\n-$ define/user sys$output nl:\n-$ edito/edt/command=sys$input f.tmp\n-sub/symbol: \"/symbol_vector=(/whole\n-sub/\"/=DATA)/whole\n-exit\n-$ sort/nodupl d.tmp,f.tmp g.tmp\n-$ open/read raw_vector g.tmp\n-$ open/write case_vector 'p2'\n-$ RAWLOOP:\n-$ read/end=end_rawloop raw_vector raw_element\n-$ write case_vector raw_element\n-$ if f$locate(\"=PROCEDURE)\",raw_element) .lt. f$length(raw_element)\n-$ then\n-$     name = f$element(1,\"=\",raw_element) - \"(\"\n-$     if f$edit(name,\"UPCASE\") .nes. name then -\n-          write case_vector f$fao(\" symbol_vector=(!AS/!AS=PROCEDURE)\", -\n-\t                          f$edit(name,\"UPCASE\"), name)\n-$ endif\n-$ if f$locate(\"=DATA)\",raw_element) .lt. f$length(raw_element)\n+$!\n+$ module1 = \"deflate#deflateEnd#deflateInit_#deflateParams#deflateSetDictionary\"\n+$ module2 = \"gzclose#gzerror#gzgetc#gzgets#gzopen#gzprintf#gzputc#gzputs#gzread\"\n+$ module3 = \"gzseek#gztell#inflate#inflateEnd#inflateInit_#inflateSetDictionary\"\n+$ module4 = \"inflateSync#uncompress#zlibVersion#compress\"\n+$ open/read map 'p1\n+$ if axp .or. ia64\n $ then\n-$     name = f$element(1,\"=\",raw_element) - \"(\"\n-$     if f$edit(name,\"UPCASE\") .nes. name then -\n-          write case_vector f$fao(\" symbol_vector=(!AS/!AS=DATA)\", -\n-\t                          f$edit(name,\"UPCASE\"), name)\n+$     open/write aopt a.opt\n+$     open/write bopt b.opt\n+$     write aopt \" CASE_SENSITIVE=YES\"\n+$     write bopt \"SYMBOL_VECTOR= (-\"\n+$     mod_sym_num = 1\n+$ MOD_SYM_LOOP:\n+$     if f$type(module'mod_sym_num') .nes. \"\"\n+$     then\n+$         mod_in = 0\n+$ MOD_SYM_IN:\n+$         shared_proc = f$element(mod_in, \"#\", module'mod_sym_num')\n+$         if shared_proc .nes. \"#\"\n+$         then\n+$             write aopt f$fao(\" symbol_vector=(!AS/!AS=PROCEDURE)\",-\n+        \t\t       f$edit(shared_proc,\"upcase\"),shared_proc)\n+$             write bopt f$fao(\"!AS=PROCEDURE,-\",shared_proc)\n+$             mod_in = mod_in + 1\n+$             goto mod_sym_in\n+$         endif\n+$         mod_sym_num = mod_sym_num + 1\n+$         goto mod_sym_loop\n+$     endif\n+$MAP_LOOP:\n+$     read/end=map_end map line\n+$     if (f$locate(\"{\",line).lt. f$length(line)) .or. -\n+         (f$locate(\"global:\", line) .lt. f$length(line))\n+$     then\n+$         proc = true\n+$         goto map_loop\n+$     endif\n+$     if f$locate(\"}\",line).lt. f$length(line) then proc = false\n+$     if f$locate(\"local:\", line) .lt. f$length(line) then proc = false\n+$     if proc\n+$     then\n+$         shared_proc = f$edit(line,\"collapse\")\n+$         chop_semi = f$locate(\";\", shared_proc)\n+$         if chop_semi .lt. f$length(shared_proc) then -\n+              shared_proc = f$extract(0, chop_semi, shared_proc)\n+$         write aopt f$fao(\" symbol_vector=(!AS/!AS=PROCEDURE)\",-\n+        \t\t\t f$edit(shared_proc,\"upcase\"),shared_proc)\n+$         write bopt f$fao(\"!AS=PROCEDURE,-\",shared_proc)\n+$     endif\n+$     goto map_loop\n+$MAP_END:\n+$     close/nolog aopt\n+$     close/nolog bopt\n+$     open/append libopt 'p2'\n+$     open/read aopt a.opt\n+$     open/read bopt b.opt\n+$ALOOP:\n+$     read/end=aloop_end aopt line\n+$     write libopt line\n+$     goto aloop\n+$ALOOP_END:\n+$     close/nolog aopt\n+$     sv = \"\"\n+$BLOOP:\n+$     read/end=bloop_end bopt svn\n+$     if (svn.nes.\"\")\n+$     then\n+$        if (sv.nes.\"\") then write libopt sv\n+$        sv = svn\n+$     endif\n+$     goto bloop\n+$BLOOP_END:\n+$     write libopt f$extract(0,f$length(sv)-2,sv), \"-\"\n+$     write libopt \")\"\n+$     close/nolog bopt\n+$     delete/nolog/noconf a.opt;*,b.opt;*\n+$ else\n+$     if vax\n+$     then\n+$     open/append libopt 'p2'\n+$     mod_sym_num = 1\n+$ VMOD_SYM_LOOP:\n+$     if f$type(module'mod_sym_num') .nes. \"\"\n+$     then\n+$         mod_in = 0\n+$ VMOD_SYM_IN:\n+$         shared_proc = f$element(mod_in, \"#\", module'mod_sym_num')\n+$         if shared_proc .nes. \"#\"\n+$         then\n+$     \t      write libopt f$fao(\"UNIVERSAL=!AS\",-\n+      \t  \t\t\t     f$edit(shared_proc,\"upcase\"))\n+$             mod_in = mod_in + 1\n+$             goto vmod_sym_in\n+$         endif\n+$         mod_sym_num = mod_sym_num + 1\n+$         goto vmod_sym_loop\n+$     endif\n+$VMAP_LOOP:\n+$     \t  read/end=vmap_end map line\n+$     \t  if (f$locate(\"{\",line).lt. f$length(line)) .or. -\n+   \t      (f$locate(\"global:\", line) .lt. f$length(line))\n+$     \t  then\n+$     \t      proc = true\n+$     \t      goto vmap_loop\n+$     \t  endif\n+$     \t  if f$locate(\"}\",line).lt. f$length(line) then proc = false\n+$     \t  if f$locate(\"local:\", line) .lt. f$length(line) then proc = false\n+$     \t  if proc\n+$     \t  then\n+$     \t      shared_proc = f$edit(line,\"collapse\")\n+$     \t      chop_semi = f$locate(\";\", shared_proc)\n+$     \t      if chop_semi .lt. f$length(shared_proc) then -\n+      \t  \t  shared_proc = f$extract(0, chop_semi, shared_proc)\n+$     \t      write libopt f$fao(\"UNIVERSAL=!AS\",-\n+      \t  \t\t\t     f$edit(shared_proc,\"upcase\"))\n+$     \t  endif\n+$     \t  goto vmap_loop\n+$VMAP_END:\n+$     else\n+$         write sys$output \"Unknown Architecture (Not VAX, AXP, or IA64)\"\n+$         write sys$output \"No options file created\"\n+$     endif\n $ endif\n-$ goto rawloop\n-$ END_RAWLOOP:\n-$ close raw_vector\n-$ close case_vector\n-$ delete a.tmp;*,b.tmp;*,c.tmp;*,d.tmp;*,e.tmp;*,f.tmp;*,g.tmp;*\n-$ if f$search(\"x.tmp\") .nes. \"\" -\n-\tthen $ delete x.tmp;*\n-$!\n-$ EXIT_AA:\n-$ if V then set verify\n+$ EXIT_M2S:\n+$ close/nolog map\n+$ close/nolog libopt\n $ endsubroutine\n-$!------------------------------------------------------------------------------\n-$!\n-$! Write configuration to both permanent and temporary config file\n-$!\n-$! Version history\n-$! 0.01 20031029 First version to receive a number\n-$!\n-$WRITE_CONFIG: SUBROUTINE\n-$  write aconf 'p1'\n-$  open/append confh 'th'\n-$  write confh 'p1'\n-$  close confh\n-$ENDSUBROUTINE\n-$!------------------------------------------------------------------------------"}, {"sha": "3d12a2c25270a42e66ffad27357d9b8a974bfefd", "filename": "zlib/msdos/Makefile.bor", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fmsdos%2FMakefile.bor", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fmsdos%2FMakefile.bor", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.bor?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -86,9 +86,9 @@ uncompr.obj: uncompr.c zlib.h zconf.h\n \n zutil.obj: zutil.c zutil.h zlib.h zconf.h\n \n-example.obj: example.c zlib.h zconf.h\n+example.obj: test/example.c zlib.h zconf.h\n \n-minigzip.obj: minigzip.c zlib.h zconf.h\n+minigzip.obj: test/minigzip.c zlib.h zconf.h\n \n \n # the command line is cut to fit in the MS-DOS 128 byte limit:"}, {"sha": "ae8378615ec6bc5998d52d87429971d99e2b7ae6", "filename": "zlib/msdos/Makefile.msc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fmsdos%2FMakefile.msc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fmsdos%2FMakefile.msc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.msc?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -80,10 +80,10 @@ uncompr.obj: uncompr.c zlib.h zconf.h\n \n zutil.obj: zutil.c zutil.h zlib.h zconf.h\n \n-example.obj: example.c zlib.h zconf.h\n+example.obj: test/example.c zlib.h zconf.h\n \t$(CC) -c $(CFLAGS) $*.c\n \n-minigzip.obj: minigzip.c zlib.h zconf.h\n+minigzip.obj: test/minigzip.c zlib.h zconf.h\n \t$(CC) -c $(CFLAGS) $*.c\n \n "}, {"sha": "5aec82a9d58c4597f84dae6475fb5f23221fb6b9", "filename": "zlib/msdos/Makefile.tc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fmsdos%2FMakefile.tc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fmsdos%2FMakefile.tc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.tc?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -71,9 +71,9 @@ uncompr.obj: uncompr.c zlib.h zconf.h\n \n zutil.obj: zutil.c zutil.h zlib.h zconf.h\n \n-example.obj: example.c zlib.h zconf.h\n+example.obj: test/example.c zlib.h zconf.h\n \n-minigzip.obj: minigzip.c zlib.h zconf.h\n+minigzip.obj: test/minigzip.c zlib.h zconf.h\n \n \n # the command line is cut to fit in the MS-DOS 128 byte limit:"}, {"sha": "4d6ab0efa6629b13024d9c153de24a43732949b8", "filename": "zlib/old/Makefile.emx", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fold%2FMakefile.emx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fold%2FMakefile.emx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2FMakefile.emx?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "previous_filename": "zlib/win32/Makefile.emx"}, {"sha": "85549515006281b6ccc305d7bddccfeb84dcb529", "filename": "zlib/old/as400/compile.clp", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50605a7f19869692a6c29cead0a1366a420e0e65/zlib%2Fold%2Fas400%2Fcompile.clp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50605a7f19869692a6c29cead0a1366a420e0e65/zlib%2Fold%2Fas400%2Fcompile.clp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2Fas400%2Fcompile.clp?ref=50605a7f19869692a6c29cead0a1366a420e0e65", "patch": "@@ -1,123 +0,0 @@\n-/******************************************************************************/\n-/*                                                                            */\n-/*  ZLIB                                                                      */\n-/*                                                                            */\n-/*    Compile sources into modules and link them into a service program.      */\n-/*                                                                            */\n-/******************************************************************************/\n-\n-             PGM\n-\n-/*      Configuration adjustable parameters.                                  */\n-\n-             DCL        VAR(&SRCLIB) TYPE(*CHAR) LEN(10) +\n-                          VALUE('ZLIB')                         /* Source library. */\n-             DCL        VAR(&SRCFILE) TYPE(*CHAR) LEN(10) +\n-                          VALUE('SOURCES')                      /* Source member file. */\n-             DCL        VAR(&CTLFILE) TYPE(*CHAR) LEN(10) +\n-                          VALUE('TOOLS')                        /* Control member file. */\n-\n-             DCL        VAR(&MODLIB) TYPE(*CHAR) LEN(10) +\n-                          VALUE('ZLIB')                         /* Module library. */\n-\n-             DCL        VAR(&SRVLIB) TYPE(*CHAR) LEN(10) +\n-                          VALUE('LGPL')                         /* Service program library. */\n-\n-             DCL        VAR(&CFLAGS) TYPE(*CHAR) +\n-                          VALUE('OPTIMIZE(40)')                 /* Compile options. */\n-\n-\n-/*      Working storage.                                                      */\n-\n-             DCL        VAR(&CMDLEN) TYPE(*DEC) LEN(15 5) VALUE(300)    /* Command length. */\n-             DCL        VAR(&CMD) TYPE(*CHAR) LEN(512)\n-\n-\n-/*      Compile sources into modules.                                         */\n-\n-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n-                        '/ADLER32)               SRCFILE(' *TCAT               +\n-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n-\n-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n-                        '/COMPRESS)              SRCFILE(' *TCAT               +\n-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n-\n-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n-                        '/CRC32)                 SRCFILE(' *TCAT               +\n-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n-\n-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n-                        '/DEFLATE)               SRCFILE(' *TCAT               +\n-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n-\n-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n-                        '/GZIO)                  SRCFILE(' *TCAT               +\n-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n-\n-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n-                        '/INFBACK)               SRCFILE(' *TCAT               +\n-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n-\n-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n-                        '/INFFAST)               SRCFILE(' *TCAT               +\n-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n-\n-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n-                        '/INFLATE)               SRCFILE(' *TCAT               +\n-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n-\n-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n-                        '/INFTREES)              SRCFILE(' *TCAT               +\n-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n-\n-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n-                        '/TREES)                 SRCFILE(' *TCAT               +\n-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n-\n-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n-                        '/UNCOMPR)               SRCFILE(' *TCAT               +\n-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n-\n-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n-                        '/ZUTIL)                 SRCFILE(' *TCAT               +\n-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n-\n-\n-/*      Link modules into a service program.                                  */\n-\n-             CRTSRVPGM  SRVPGM(&SRVLIB/ZLIB) +\n-                          MODULE(&MODLIB/ADLER32     &MODLIB/COMPRESS    +\n-                                 &MODLIB/CRC32       &MODLIB/DEFLATE     +\n-                                 &MODLIB/GZIO        &MODLIB/INFBACK     +\n-                                 &MODLIB/INFFAST     &MODLIB/INFLATE     +\n-                                 &MODLIB/INFTREES    &MODLIB/TREES       +\n-                                 &MODLIB/UNCOMPR     &MODLIB/ZUTIL)      +\n-                          SRCFILE(&SRCLIB/&CTLFILE) SRCMBR(BNDSRC) +\n-                          TEXT('ZLIB 1.2.3') TGTRLS(V4R4M0)\n-\n-             ENDPGM"}, {"sha": "d0296c272c31c82545b0d287c0b9a4198c834854", "filename": "zlib/old/visualc6/README.txt", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50605a7f19869692a6c29cead0a1366a420e0e65/zlib%2Fold%2Fvisualc6%2FREADME.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50605a7f19869692a6c29cead0a1366a420e0e65/zlib%2Fold%2Fvisualc6%2FREADME.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2Fvisualc6%2FREADME.txt?ref=50605a7f19869692a6c29cead0a1366a420e0e65", "patch": "@@ -1,73 +0,0 @@\n-Microsoft Developer Studio Project Files, Format Version 6.00 for zlib.\r\n-\r\n-Copyright (C) 2000-2004 Simon-Pierre Cadieux.\r\n-Copyright (C) 2004 Cosmin Truta.\r\n-For conditions of distribution and use, see copyright notice in zlib.h.\r\n-\r\n-\r\n-This project builds the zlib binaries as follows:\r\n-\r\n-* Win32_DLL_Release\\zlib1.dll       DLL build\r\n-* Win32_DLL_Debug\\zlib1d.dll        DLL build (debug version)\r\n-* Win32_DLL_ASM_Release\\zlib1.dll   DLL build using ASM code\r\n-* Win32_DLL_ASM_Debug\\zlib1d.dll    DLL build using ASM code (debug version)\r\n-* Win32_LIB_Release\\zlib.lib        static build\r\n-* Win32_LIB_Debug\\zlibd.lib         static build (debug version)\r\n-* Win32_LIB_ASM_Release\\zlib.lib    static build using ASM code\r\n-* Win32_LIB_ASM_Debug\\zlibd.lib     static build using ASM code (debug version)\r\n-\r\n-\r\n-For more information regarding the DLL builds, please see the DLL FAQ\r\n-in ..\\..\\win32\\DLL_FAQ.txt.\r\n-\r\n-\r\n-To build and test:\r\n-\r\n-1) On the main menu, select \"File | Open Workspace\".\r\n-   Open \"zlib.dsw\".\r\n-\r\n-2) Select \"Build | Set Active Configuration\".\r\n-   Choose the configuration you wish to build.\r\n-\r\n-3) Select \"Build | Clean\".\r\n-\r\n-4) Select \"Build | Build ... (F7)\".  Ignore warning messages about\r\n-   not being able to find certain include files (e.g. alloc.h).\r\n-\r\n-5) If you built one of the sample programs (example or minigzip),\r\n-   select \"Build | Execute ... (Ctrl+F5)\".\r\n-\r\n-\r\n-To use:\r\n-\r\n-1) Select \"Project | Settings (Alt+F7)\".\r\n-   Make note of the configuration names used in your project.\r\n-   Usually, these names are \"Win32 Release\" and \"Win32 Debug\".\r\n-\r\n-2) In the Workspace window, select the \"FileView\" tab.\r\n-   Right-click on the root item \"Workspace '...'\".\r\n-   Select \"Insert Project into Workspace\".\r\n-   Switch on the checkbox \"Dependency of:\", and select the name\r\n-   of your project.  Open \"zlib.dsp\".\r\n-\r\n-3) Select \"Build | Configurations\".\r\n-   For each configuration of your project:\r\n-   3.1) Choose the zlib configuration you wish to use.\r\n-   3.2) Click on \"Add\".\r\n-   3.3) Set the new zlib configuration name to the name used by\r\n-        the configuration from the current iteration.\r\n-\r\n-4) Select \"Build | Set Active Configuration\".\r\n-   Choose the configuration you wish to build.\r\n-\r\n-5) Select \"Build | Build ... (F7)\".\r\n-\r\n-6) If you built an executable program, select\r\n-   \"Build | Execute ... (Ctrl+F5)\".\r\n-\r\n-\r\n-Note:\r\n-\r\n-To build the ASM-enabled code, you need Microsoft Assembler\r\n-(ML.EXE).  You can get it by downloading and installing the\r\n-latest Processor Pack for Visual C++ 6.0.\r"}, {"sha": "d3580525bd4e1d453d1f62d920237273672f8aea", "filename": "zlib/old/visualc6/example.dsp", "status": "removed", "additions": 0, "deletions": 278, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50605a7f19869692a6c29cead0a1366a420e0e65/zlib%2Fold%2Fvisualc6%2Fexample.dsp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50605a7f19869692a6c29cead0a1366a420e0e65/zlib%2Fold%2Fvisualc6%2Fexample.dsp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2Fvisualc6%2Fexample.dsp?ref=50605a7f19869692a6c29cead0a1366a420e0e65", "patch": "@@ -1,278 +0,0 @@\n-# Microsoft Developer Studio Project File - Name=\"example\" - Package Owner=<4>\r\n-# Microsoft Developer Studio Generated Build File, Format Version 6.00\r\n-# ** DO NOT EDIT **\r\n-\r\n-# TARGTYPE \"Win32 (x86) Console Application\" 0x0103\r\n-\r\n-CFG=example - Win32 LIB Debug\r\n-!MESSAGE This is not a valid makefile. To build this project using NMAKE,\r\n-!MESSAGE use the Export Makefile command and run\r\n-!MESSAGE\r\n-!MESSAGE NMAKE /f \"example.mak\".\r\n-!MESSAGE\r\n-!MESSAGE You can specify a configuration when running NMAKE\r\n-!MESSAGE by defining the macro CFG on the command line. For example:\r\n-!MESSAGE\r\n-!MESSAGE NMAKE /f \"example.mak\" CFG=\"example - Win32 LIB Debug\"\r\n-!MESSAGE\r\n-!MESSAGE Possible choices for configuration are:\r\n-!MESSAGE\r\n-!MESSAGE \"example - Win32 DLL ASM Release\" (based on \"Win32 (x86) Console Application\")\r\n-!MESSAGE \"example - Win32 DLL ASM Debug\" (based on \"Win32 (x86) Console Application\")\r\n-!MESSAGE \"example - Win32 DLL Release\" (based on \"Win32 (x86) Console Application\")\r\n-!MESSAGE \"example - Win32 DLL Debug\" (based on \"Win32 (x86) Console Application\")\r\n-!MESSAGE \"example - Win32 LIB ASM Release\" (based on \"Win32 (x86) Console Application\")\r\n-!MESSAGE \"example - Win32 LIB ASM Debug\" (based on \"Win32 (x86) Console Application\")\r\n-!MESSAGE \"example - Win32 LIB Release\" (based on \"Win32 (x86) Console Application\")\r\n-!MESSAGE \"example - Win32 LIB Debug\" (based on \"Win32 (x86) Console Application\")\r\n-!MESSAGE\r\n-\r\n-# Begin Project\r\n-# PROP AllowPerConfigDependencies 0\r\n-# PROP Scc_ProjName \"\"\r\n-# PROP Scc_LocalPath \"\"\r\n-CPP=cl.exe\r\n-RSC=rc.exe\r\n-\r\n-!IF  \"$(CFG)\" == \"example - Win32 DLL ASM Release\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 0\r\n-# PROP BASE Output_Dir \"example___Win32_DLL_ASM_Release\"\r\n-# PROP BASE Intermediate_Dir \"example___Win32_DLL_ASM_Release\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 0\r\n-# PROP Output_Dir \"Win32_DLL_ASM_Release\"\r\n-# PROP Intermediate_Dir \"Win32_DLL_ASM_Release\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT BASE CPP /YX\r\n-# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT CPP /YX\r\n-# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n-# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386\r\n-# ADD LINK32 /nologo /subsystem:console /machine:I386\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"example - Win32 DLL ASM Debug\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 1\r\n-# PROP BASE Output_Dir \"example___Win32_DLL_ASM_Debug\"\r\n-# PROP BASE Intermediate_Dir \"example___Win32_DLL_ASM_Debug\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 1\r\n-# PROP Output_Dir \"Win32_DLL_ASM_Debug\"\r\n-# PROP Intermediate_Dir \"Win32_DLL_ASM_Debug\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n-# SUBTRACT BASE CPP /YX\r\n-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"_DEBUG\" /FR /FD /GZ /c\r\n-# SUBTRACT CPP /YX\r\n-# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n-# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n-# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"example - Win32 DLL Release\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 0\r\n-# PROP BASE Output_Dir \"example___Win32_DLL_Release\"\r\n-# PROP BASE Intermediate_Dir \"example___Win32_DLL_Release\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 0\r\n-# PROP Output_Dir \"Win32_DLL_Release\"\r\n-# PROP Intermediate_Dir \"Win32_DLL_Release\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT BASE CPP /YX\r\n-# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT CPP /YX\r\n-# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n-# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386\r\n-# ADD LINK32 /nologo /subsystem:console /machine:I386\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"example - Win32 DLL Debug\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 1\r\n-# PROP BASE Output_Dir \"example___Win32_DLL_Debug\"\r\n-# PROP BASE Intermediate_Dir \"example___Win32_DLL_Debug\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 1\r\n-# PROP Output_Dir \"Win32_DLL_Debug\"\r\n-# PROP Intermediate_Dir \"Win32_DLL_Debug\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n-# SUBTRACT BASE CPP /YX\r\n-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"_DEBUG\" /FR /FD /GZ /c\r\n-# SUBTRACT CPP /YX\r\n-# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n-# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n-# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"example - Win32 LIB ASM Release\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 0\r\n-# PROP BASE Output_Dir \"example___Win32_LIB_ASM_Release\"\r\n-# PROP BASE Intermediate_Dir \"example___Win32_LIB_ASM_Release\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 0\r\n-# PROP Output_Dir \"Win32_LIB_ASM_Release\"\r\n-# PROP Intermediate_Dir \"Win32_LIB_ASM_Release\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT BASE CPP /YX\r\n-# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT CPP /YX\r\n-# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n-# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386\r\n-# ADD LINK32 /nologo /subsystem:console /machine:I386\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"example - Win32 LIB ASM Debug\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 1\r\n-# PROP BASE Output_Dir \"example___Win32_LIB_ASM_Debug\"\r\n-# PROP BASE Intermediate_Dir \"example___Win32_LIB_ASM_Debug\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 1\r\n-# PROP Output_Dir \"Win32_LIB_ASM_Debug\"\r\n-# PROP Intermediate_Dir \"Win32_LIB_ASM_Debug\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n-# SUBTRACT BASE CPP /YX\r\n-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"_DEBUG\" /FR /FD /GZ /c\r\n-# SUBTRACT CPP /YX\r\n-# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n-# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n-# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"example - Win32 LIB Release\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 0\r\n-# PROP BASE Output_Dir \"example___Win32_LIB_Release\"\r\n-# PROP BASE Intermediate_Dir \"example___Win32_LIB_Release\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 0\r\n-# PROP Output_Dir \"Win32_LIB_Release\"\r\n-# PROP Intermediate_Dir \"Win32_LIB_Release\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT BASE CPP /YX\r\n-# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT CPP /YX\r\n-# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n-# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386\r\n-# ADD LINK32 /nologo /subsystem:console /machine:I386\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"example - Win32 LIB Debug\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 1\r\n-# PROP BASE Output_Dir \"example___Win32_LIB_Debug\"\r\n-# PROP BASE Intermediate_Dir \"example___Win32_LIB_Debug\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 1\r\n-# PROP Output_Dir \"Win32_LIB_Debug\"\r\n-# PROP Intermediate_Dir \"Win32_LIB_Debug\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n-# SUBTRACT BASE CPP /YX\r\n-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"_DEBUG\" /FR /FD /GZ /c\r\n-# SUBTRACT CPP /YX\r\n-# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n-# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n-# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n-\r\n-!ENDIF\r\n-\r\n-# Begin Target\r\n-\r\n-# Name \"example - Win32 DLL ASM Release\"\r\n-# Name \"example - Win32 DLL ASM Debug\"\r\n-# Name \"example - Win32 DLL Release\"\r\n-# Name \"example - Win32 DLL Debug\"\r\n-# Name \"example - Win32 LIB ASM Release\"\r\n-# Name \"example - Win32 LIB ASM Debug\"\r\n-# Name \"example - Win32 LIB Release\"\r\n-# Name \"example - Win32 LIB Debug\"\r\n-# Begin Group \"Source Files\"\r\n-\r\n-# PROP Default_Filter \"cpp;c;cxx;rc;def;r;odl;idl;hpj;bat\"\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\example.c\r\n-# End Source File\r\n-# End Group\r\n-# Begin Group \"Header Files\"\r\n-\r\n-# PROP Default_Filter \"h;hpp;hxx;hm;inl\"\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\zconf.h\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\zlib.h\r\n-# End Source File\r\n-# End Group\r\n-# End Target\r\n-# End Project\r"}, {"sha": "71034684d820b2fb01b843e13b03dc54fcf62a8e", "filename": "zlib/old/visualc6/minigzip.dsp", "status": "removed", "additions": 0, "deletions": 278, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50605a7f19869692a6c29cead0a1366a420e0e65/zlib%2Fold%2Fvisualc6%2Fminigzip.dsp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50605a7f19869692a6c29cead0a1366a420e0e65/zlib%2Fold%2Fvisualc6%2Fminigzip.dsp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2Fvisualc6%2Fminigzip.dsp?ref=50605a7f19869692a6c29cead0a1366a420e0e65", "patch": "@@ -1,278 +0,0 @@\n-# Microsoft Developer Studio Project File - Name=\"minigzip\" - Package Owner=<4>\r\n-# Microsoft Developer Studio Generated Build File, Format Version 6.00\r\n-# ** DO NOT EDIT **\r\n-\r\n-# TARGTYPE \"Win32 (x86) Console Application\" 0x0103\r\n-\r\n-CFG=minigzip - Win32 LIB Debug\r\n-!MESSAGE This is not a valid makefile. To build this project using NMAKE,\r\n-!MESSAGE use the Export Makefile command and run\r\n-!MESSAGE\r\n-!MESSAGE NMAKE /f \"minigzip.mak\".\r\n-!MESSAGE\r\n-!MESSAGE You can specify a configuration when running NMAKE\r\n-!MESSAGE by defining the macro CFG on the command line. For example:\r\n-!MESSAGE\r\n-!MESSAGE NMAKE /f \"minigzip.mak\" CFG=\"minigzip - Win32 LIB Debug\"\r\n-!MESSAGE\r\n-!MESSAGE Possible choices for configuration are:\r\n-!MESSAGE\r\n-!MESSAGE \"minigzip - Win32 DLL ASM Release\" (based on \"Win32 (x86) Console Application\")\r\n-!MESSAGE \"minigzip - Win32 DLL ASM Debug\" (based on \"Win32 (x86) Console Application\")\r\n-!MESSAGE \"minigzip - Win32 DLL Release\" (based on \"Win32 (x86) Console Application\")\r\n-!MESSAGE \"minigzip - Win32 DLL Debug\" (based on \"Win32 (x86) Console Application\")\r\n-!MESSAGE \"minigzip - Win32 LIB ASM Release\" (based on \"Win32 (x86) Console Application\")\r\n-!MESSAGE \"minigzip - Win32 LIB ASM Debug\" (based on \"Win32 (x86) Console Application\")\r\n-!MESSAGE \"minigzip - Win32 LIB Release\" (based on \"Win32 (x86) Console Application\")\r\n-!MESSAGE \"minigzip - Win32 LIB Debug\" (based on \"Win32 (x86) Console Application\")\r\n-!MESSAGE\r\n-\r\n-# Begin Project\r\n-# PROP AllowPerConfigDependencies 0\r\n-# PROP Scc_ProjName \"\"\r\n-# PROP Scc_LocalPath \"\"\r\n-CPP=cl.exe\r\n-RSC=rc.exe\r\n-\r\n-!IF  \"$(CFG)\" == \"minigzip - Win32 DLL ASM Release\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 0\r\n-# PROP BASE Output_Dir \"minigzip___Win32_DLL_ASM_Release\"\r\n-# PROP BASE Intermediate_Dir \"minigzip___Win32_DLL_ASM_Release\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 0\r\n-# PROP Output_Dir \"Win32_DLL_ASM_Release\"\r\n-# PROP Intermediate_Dir \"Win32_DLL_ASM_Release\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT BASE CPP /YX\r\n-# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT CPP /YX\r\n-# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n-# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386\r\n-# ADD LINK32 /nologo /subsystem:console /machine:I386\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"minigzip - Win32 DLL ASM Debug\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 1\r\n-# PROP BASE Output_Dir \"minigzip___Win32_DLL_ASM_Debug\"\r\n-# PROP BASE Intermediate_Dir \"minigzip___Win32_DLL_ASM_Debug\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 1\r\n-# PROP Output_Dir \"Win32_DLL_ASM_Debug\"\r\n-# PROP Intermediate_Dir \"Win32_DLL_ASM_Debug\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n-# SUBTRACT BASE CPP /YX\r\n-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"_DEBUG\" /FR /FD /GZ /c\r\n-# SUBTRACT CPP /YX\r\n-# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n-# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n-# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"minigzip - Win32 DLL Release\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 0\r\n-# PROP BASE Output_Dir \"minigzip___Win32_DLL_Release\"\r\n-# PROP BASE Intermediate_Dir \"minigzip___Win32_DLL_Release\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 0\r\n-# PROP Output_Dir \"Win32_DLL_Release\"\r\n-# PROP Intermediate_Dir \"Win32_DLL_Release\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT BASE CPP /YX\r\n-# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT CPP /YX\r\n-# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n-# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386\r\n-# ADD LINK32 /nologo /subsystem:console /machine:I386\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"minigzip - Win32 DLL Debug\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 1\r\n-# PROP BASE Output_Dir \"minigzip___Win32_DLL_Debug\"\r\n-# PROP BASE Intermediate_Dir \"minigzip___Win32_DLL_Debug\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 1\r\n-# PROP Output_Dir \"Win32_DLL_Debug\"\r\n-# PROP Intermediate_Dir \"Win32_DLL_Debug\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n-# SUBTRACT BASE CPP /YX\r\n-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"_DEBUG\" /FR /FD /GZ /c\r\n-# SUBTRACT CPP /YX\r\n-# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n-# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n-# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"minigzip - Win32 LIB ASM Release\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 0\r\n-# PROP BASE Output_Dir \"minigzip___Win32_LIB_ASM_Release\"\r\n-# PROP BASE Intermediate_Dir \"minigzip___Win32_LIB_ASM_Release\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 0\r\n-# PROP Output_Dir \"Win32_LIB_ASM_Release\"\r\n-# PROP Intermediate_Dir \"Win32_LIB_ASM_Release\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT BASE CPP /YX\r\n-# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT CPP /YX\r\n-# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n-# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386\r\n-# ADD LINK32 /nologo /subsystem:console /machine:I386\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"minigzip - Win32 LIB ASM Debug\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 1\r\n-# PROP BASE Output_Dir \"minigzip___Win32_LIB_ASM_Debug\"\r\n-# PROP BASE Intermediate_Dir \"minigzip___Win32_LIB_ASM_Debug\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 1\r\n-# PROP Output_Dir \"Win32_LIB_ASM_Debug\"\r\n-# PROP Intermediate_Dir \"Win32_LIB_ASM_Debug\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n-# SUBTRACT BASE CPP /YX\r\n-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"_DEBUG\" /FR /FD /GZ /c\r\n-# SUBTRACT CPP /YX\r\n-# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n-# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n-# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"minigzip - Win32 LIB Release\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 0\r\n-# PROP BASE Output_Dir \"minigzip___Win32_LIB_Release\"\r\n-# PROP BASE Intermediate_Dir \"minigzip___Win32_LIB_Release\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 0\r\n-# PROP Output_Dir \"Win32_LIB_Release\"\r\n-# PROP Intermediate_Dir \"Win32_LIB_Release\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT BASE CPP /YX\r\n-# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT CPP /YX\r\n-# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n-# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386\r\n-# ADD LINK32 /nologo /subsystem:console /machine:I386\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"minigzip - Win32 LIB Debug\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 1\r\n-# PROP BASE Output_Dir \"minigzip___Win32_LIB_Debug\"\r\n-# PROP BASE Intermediate_Dir \"minigzip___Win32_LIB_Debug\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 1\r\n-# PROP Output_Dir \"Win32_LIB_Debug\"\r\n-# PROP Intermediate_Dir \"Win32_LIB_Debug\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n-# SUBTRACT BASE CPP /YX\r\n-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"_DEBUG\" /FR /FD /GZ /c\r\n-# SUBTRACT CPP /YX\r\n-# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n-# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n-# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n-\r\n-!ENDIF\r\n-\r\n-# Begin Target\r\n-\r\n-# Name \"minigzip - Win32 DLL ASM Release\"\r\n-# Name \"minigzip - Win32 DLL ASM Debug\"\r\n-# Name \"minigzip - Win32 DLL Release\"\r\n-# Name \"minigzip - Win32 DLL Debug\"\r\n-# Name \"minigzip - Win32 LIB ASM Release\"\r\n-# Name \"minigzip - Win32 LIB ASM Debug\"\r\n-# Name \"minigzip - Win32 LIB Release\"\r\n-# Name \"minigzip - Win32 LIB Debug\"\r\n-# Begin Group \"Source Files\"\r\n-\r\n-# PROP Default_Filter \"cpp;c;cxx;rc;def;r;odl;idl;hpj;bat\"\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\minigzip.c\r\n-# End Source File\r\n-# End Group\r\n-# Begin Group \"Header Files\"\r\n-\r\n-# PROP Default_Filter \"h;hpp;hxx;hm;inl\"\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\zconf.h\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\zlib.h\r\n-# End Source File\r\n-# End Group\r\n-# End Target\r\n-# End Project\r"}, {"sha": "00f54ea4222e6fe274958c77379ae5066cf99266", "filename": "zlib/old/visualc6/zlib.dsp", "status": "removed", "additions": 0, "deletions": 621, "changes": 621, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50605a7f19869692a6c29cead0a1366a420e0e65/zlib%2Fold%2Fvisualc6%2Fzlib.dsp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50605a7f19869692a6c29cead0a1366a420e0e65/zlib%2Fold%2Fvisualc6%2Fzlib.dsp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2Fvisualc6%2Fzlib.dsp?ref=50605a7f19869692a6c29cead0a1366a420e0e65", "patch": "@@ -1,621 +0,0 @@\n-# Microsoft Developer Studio Project File - Name=\"zlib\" - Package Owner=<4>\r\n-# Microsoft Developer Studio Generated Build File, Format Version 6.00\r\n-# ** DO NOT EDIT **\r\n-\r\n-# TARGTYPE \"Win32 (x86) Dynamic-Link Library\" 0x0102\r\n-# TARGTYPE \"Win32 (x86) Static Library\" 0x0104\r\n-\r\n-CFG=zlib - Win32 LIB Debug\r\n-!MESSAGE This is not a valid makefile. To build this project using NMAKE,\r\n-!MESSAGE use the Export Makefile command and run\r\n-!MESSAGE\r\n-!MESSAGE NMAKE /f \"zlib.mak\".\r\n-!MESSAGE\r\n-!MESSAGE You can specify a configuration when running NMAKE\r\n-!MESSAGE by defining the macro CFG on the command line. For example:\r\n-!MESSAGE\r\n-!MESSAGE NMAKE /f \"zlib.mak\" CFG=\"zlib - Win32 LIB Debug\"\r\n-!MESSAGE\r\n-!MESSAGE Possible choices for configuration are:\r\n-!MESSAGE\r\n-!MESSAGE \"zlib - Win32 DLL ASM Release\" (based on \"Win32 (x86) Dynamic-Link Library\")\r\n-!MESSAGE \"zlib - Win32 DLL ASM Debug\" (based on \"Win32 (x86) Dynamic-Link Library\")\r\n-!MESSAGE \"zlib - Win32 DLL Release\" (based on \"Win32 (x86) Dynamic-Link Library\")\r\n-!MESSAGE \"zlib - Win32 DLL Debug\" (based on \"Win32 (x86) Dynamic-Link Library\")\r\n-!MESSAGE \"zlib - Win32 LIB ASM Release\" (based on \"Win32 (x86) Static Library\")\r\n-!MESSAGE \"zlib - Win32 LIB ASM Debug\" (based on \"Win32 (x86) Static Library\")\r\n-!MESSAGE \"zlib - Win32 LIB Release\" (based on \"Win32 (x86) Static Library\")\r\n-!MESSAGE \"zlib - Win32 LIB Debug\" (based on \"Win32 (x86) Static Library\")\r\n-!MESSAGE\r\n-\r\n-# Begin Project\r\n-# PROP AllowPerConfigDependencies 0\r\n-# PROP Scc_ProjName \"\"\r\n-# PROP Scc_LocalPath \"\"\r\n-\r\n-!IF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Release\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 0\r\n-# PROP BASE Output_Dir \"zlib___Win32_DLL_ASM_Release\"\r\n-# PROP BASE Intermediate_Dir \"zlib___Win32_DLL_ASM_Release\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 0\r\n-# PROP Output_Dir \"Win32_DLL_ASM_Release\"\r\n-# PROP Intermediate_Dir \"Win32_DLL_ASM_Release\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-CPP=cl.exe\r\n-# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT BASE CPP /YX /Yc /Yu\r\n-# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"NDEBUG\" /D \"ASMV\" /D \"ASMINF\" /FD /c\r\n-# SUBTRACT CPP /YX /Yc /Yu\r\n-MTL=midl.exe\r\n-# ADD BASE MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\r\n-# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\r\n-RSC=rc.exe\r\n-# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n-# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386\r\n-# ADD LINK32 /nologo /dll /machine:I386 /out:\"Win32_DLL_ASM_Release\\zlib1.dll\"\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Debug\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 1\r\n-# PROP BASE Output_Dir \"zlib___Win32_DLL_ASM_Debug\"\r\n-# PROP BASE Intermediate_Dir \"zlib___Win32_DLL_ASM_Debug\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 1\r\n-# PROP Output_Dir \"Win32_DLL_ASM_Debug\"\r\n-# PROP Intermediate_Dir \"Win32_DLL_ASM_Debug\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-CPP=cl.exe\r\n-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n-# SUBTRACT BASE CPP /YX /Yc /Yu\r\n-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"_DEBUG\" /D \"ASMV\" /D \"ASMINF\" /FR /FD /GZ /c\r\n-# SUBTRACT CPP /YX /Yc /Yu\r\n-MTL=midl.exe\r\n-# ADD BASE MTL /nologo /D \"_DEBUG\" /mktyplib203 /win32\r\n-# ADD MTL /nologo /D \"_DEBUG\" /mktyplib203 /win32\r\n-RSC=rc.exe\r\n-# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n-# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept\r\n-# ADD LINK32 /nologo /dll /debug /machine:I386 /out:\"Win32_DLL_ASM_Debug\\zlib1d.dll\" /pdbtype:sept\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL Release\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 0\r\n-# PROP BASE Output_Dir \"zlib___Win32_DLL_Release\"\r\n-# PROP BASE Intermediate_Dir \"zlib___Win32_DLL_Release\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 0\r\n-# PROP Output_Dir \"Win32_DLL_Release\"\r\n-# PROP Intermediate_Dir \"Win32_DLL_Release\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-CPP=cl.exe\r\n-# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT BASE CPP /YX /Yc /Yu\r\n-# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT CPP /YX /Yc /Yu\r\n-MTL=midl.exe\r\n-# ADD BASE MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\r\n-# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\r\n-RSC=rc.exe\r\n-# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n-# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386\r\n-# ADD LINK32 /nologo /dll /machine:I386 /out:\"Win32_DLL_Release\\zlib1.dll\"\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL Debug\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 1\r\n-# PROP BASE Output_Dir \"zlib___Win32_DLL_Debug\"\r\n-# PROP BASE Intermediate_Dir \"zlib___Win32_DLL_Debug\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 1\r\n-# PROP Output_Dir \"Win32_DLL_Debug\"\r\n-# PROP Intermediate_Dir \"Win32_DLL_Debug\"\r\n-# PROP Ignore_Export_Lib 0\r\n-# PROP Target_Dir \"\"\r\n-CPP=cl.exe\r\n-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n-# SUBTRACT BASE CPP /YX /Yc /Yu\r\n-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"_DEBUG\" /FR /FD /GZ /c\r\n-# SUBTRACT CPP /YX /Yc /Yu\r\n-MTL=midl.exe\r\n-# ADD BASE MTL /nologo /D \"_DEBUG\" /mktyplib203 /win32\r\n-# ADD MTL /nologo /D \"_DEBUG\" /mktyplib203 /win32\r\n-RSC=rc.exe\r\n-# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n-# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LINK32=link.exe\r\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept\r\n-# ADD LINK32 /nologo /dll /debug /machine:I386 /out:\"Win32_DLL_Debug\\zlib1d.dll\" /pdbtype:sept\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Release\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 0\r\n-# PROP BASE Output_Dir \"zlib___Win32_LIB_ASM_Release\"\r\n-# PROP BASE Intermediate_Dir \"zlib___Win32_LIB_ASM_Release\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 0\r\n-# PROP Output_Dir \"Win32_LIB_ASM_Release\"\r\n-# PROP Intermediate_Dir \"Win32_LIB_ASM_Release\"\r\n-# PROP Target_Dir \"\"\r\n-CPP=cl.exe\r\n-# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT BASE CPP /YX /Yc /Yu\r\n-# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"NDEBUG\" /D \"ASMV\" /D \"ASMINF\" /FD /c\r\n-# SUBTRACT CPP /YX /Yc /Yu\r\n-RSC=rc.exe\r\n-# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n-# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LIB32=link.exe -lib\r\n-# ADD BASE LIB32 /nologo\r\n-# ADD LIB32 /nologo\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Debug\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 1\r\n-# PROP BASE Output_Dir \"zlib___Win32_LIB_ASM_Debug\"\r\n-# PROP BASE Intermediate_Dir \"zlib___Win32_LIB_ASM_Debug\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 1\r\n-# PROP Output_Dir \"Win32_LIB_ASM_Debug\"\r\n-# PROP Intermediate_Dir \"Win32_LIB_ASM_Debug\"\r\n-# PROP Target_Dir \"\"\r\n-CPP=cl.exe\r\n-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n-# SUBTRACT BASE CPP /YX /Yc /Yu\r\n-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"_DEBUG\" /D \"ASMV\" /D \"ASMINF\" /FR /FD /GZ /c\r\n-# SUBTRACT CPP /YX /Yc /Yu\r\n-RSC=rc.exe\r\n-# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n-# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LIB32=link.exe -lib\r\n-# ADD BASE LIB32 /nologo\r\n-# ADD LIB32 /nologo /out:\"Win32_LIB_ASM_Debug\\zlibd.lib\"\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Release\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 0\r\n-# PROP BASE Output_Dir \"zlib___Win32_LIB_Release\"\r\n-# PROP BASE Intermediate_Dir \"zlib___Win32_LIB_Release\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 0\r\n-# PROP Output_Dir \"Win32_LIB_Release\"\r\n-# PROP Intermediate_Dir \"Win32_LIB_Release\"\r\n-# PROP Target_Dir \"\"\r\n-CPP=cl.exe\r\n-# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT BASE CPP /YX /Yc /Yu\r\n-# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"NDEBUG\" /FD /c\r\n-# SUBTRACT CPP /YX /Yc /Yu\r\n-RSC=rc.exe\r\n-# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n-# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LIB32=link.exe -lib\r\n-# ADD BASE LIB32 /nologo\r\n-# ADD LIB32 /nologo\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Debug\"\r\n-\r\n-# PROP BASE Use_MFC 0\r\n-# PROP BASE Use_Debug_Libraries 1\r\n-# PROP BASE Output_Dir \"zlib___Win32_LIB_Debug\"\r\n-# PROP BASE Intermediate_Dir \"zlib___Win32_LIB_Debug\"\r\n-# PROP BASE Target_Dir \"\"\r\n-# PROP Use_MFC 0\r\n-# PROP Use_Debug_Libraries 1\r\n-# PROP Output_Dir \"Win32_LIB_Debug\"\r\n-# PROP Intermediate_Dir \"Win32_LIB_Debug\"\r\n-# PROP Target_Dir \"\"\r\n-CPP=cl.exe\r\n-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n-# SUBTRACT BASE CPP /YX /Yc /Yu\r\n-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_CRT_SECURE_NO_DEPRECATE\" /D \"_CRT_NONSTDC_NO_DEPRECATE\" /D \"_DEBUG\" /FR /FD /GZ /c\r\n-# SUBTRACT CPP /YX /Yc /Yu\r\n-RSC=rc.exe\r\n-# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n-# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n-BSC32=bscmake.exe\r\n-# ADD BASE BSC32 /nologo\r\n-# ADD BSC32 /nologo\r\n-LIB32=link.exe -lib\r\n-# ADD BASE LIB32 /nologo\r\n-# ADD LIB32 /nologo /out:\"Win32_LIB_Debug\\zlibd.lib\"\r\n-\r\n-!ENDIF\r\n-\r\n-# Begin Target\r\n-\r\n-# Name \"zlib - Win32 DLL ASM Release\"\r\n-# Name \"zlib - Win32 DLL ASM Debug\"\r\n-# Name \"zlib - Win32 DLL Release\"\r\n-# Name \"zlib - Win32 DLL Debug\"\r\n-# Name \"zlib - Win32 LIB ASM Release\"\r\n-# Name \"zlib - Win32 LIB ASM Debug\"\r\n-# Name \"zlib - Win32 LIB Release\"\r\n-# Name \"zlib - Win32 LIB Debug\"\r\n-# Begin Group \"Source Files\"\r\n-\r\n-# PROP Default_Filter \"cpp;c;cxx;rc;def;r;odl;idl;hpj;bat\"\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\adler32.c\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\compress.c\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\crc32.c\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\deflate.c\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\gzclose.c\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\gzlib.c\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\gzread.c\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\gzwrite.c\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\infback.c\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\inffast.c\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\inflate.c\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\inftrees.c\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\trees.c\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\uncompr.c\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\win32\\zlib.def\r\n-\r\n-!IF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Release\"\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Debug\"\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL Release\"\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL Debug\"\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Release\"\r\n-\r\n-# PROP Exclude_From_Build 1\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Debug\"\r\n-\r\n-# PROP Exclude_From_Build 1\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Release\"\r\n-\r\n-# PROP Exclude_From_Build 1\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Debug\"\r\n-\r\n-# PROP Exclude_From_Build 1\r\n-\r\n-!ENDIF\r\n-\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\zutil.c\r\n-# End Source File\r\n-# End Group\r\n-# Begin Group \"Header Files\"\r\n-\r\n-# PROP Default_Filter \"h;hpp;hxx;hm;inl\"\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\crc32.h\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\deflate.h\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\inffast.h\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\inffixed.h\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\inflate.h\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\inftrees.h\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\trees.h\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\zconf.h\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\zlib.h\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\zutil.h\r\n-# End Source File\r\n-# End Group\r\n-# Begin Group \"Resource Files\"\r\n-\r\n-# PROP Default_Filter \"ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe\"\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\win32\\zlib1.rc\r\n-# End Source File\r\n-# End Group\r\n-# Begin Group \"Assembler Files (Unsupported)\"\r\n-\r\n-# PROP Default_Filter \"asm;obj;c;cpp;cxx;h;hpp;hxx\"\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\contrib\\masmx86\\gvmat32.asm\r\n-\r\n-!IF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Release\"\r\n-\r\n-# Begin Custom Build - Assembling...\r\n-IntDir=.\\Win32_DLL_ASM_Release\r\n-InputPath=..\\..\\contrib\\masmx86\\gvmat32.asm\r\n-InputName=gvmat32\r\n-\r\n-\"$(IntDir)\\$(InputName).obj\" : $(SOURCE) \"$(INTDIR)\" \"$(OUTDIR)\"\r\n-\tml.exe /nologo /c /coff /Cx /Fo\"$(IntDir)\\$(InputName).obj\" \"$(InputPath)\"\r\n-\r\n-# End Custom Build\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Debug\"\r\n-\r\n-# Begin Custom Build - Assembling...\r\n-IntDir=.\\Win32_DLL_ASM_Debug\r\n-InputPath=..\\..\\contrib\\masmx86\\gvmat32.asm\r\n-InputName=gvmat32\r\n-\r\n-\"$(IntDir)\\$(InputName).obj\" : $(SOURCE) \"$(INTDIR)\" \"$(OUTDIR)\"\r\n-\tml.exe /nologo /c /coff /Cx /Zi /Fo\"$(IntDir)\\$(InputName).obj\" \"$(InputPath)\"\r\n-\r\n-# End Custom Build\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL Release\"\r\n-\r\n-# PROP Exclude_From_Build 1\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL Debug\"\r\n-\r\n-# PROP Exclude_From_Build 1\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Release\"\r\n-\r\n-# Begin Custom Build - Assembling...\r\n-IntDir=.\\Win32_LIB_ASM_Release\r\n-InputPath=..\\..\\contrib\\masmx86\\gvmat32.asm\r\n-InputName=gvmat32\r\n-\r\n-\"$(IntDir)\\$(InputName).obj\" : $(SOURCE) \"$(INTDIR)\" \"$(OUTDIR)\"\r\n-\tml.exe /nologo /c /coff /Cx /Fo\"$(IntDir)\\$(InputName).obj\" \"$(InputPath)\"\r\n-\r\n-# End Custom Build\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Debug\"\r\n-\r\n-# Begin Custom Build - Assembling...\r\n-IntDir=.\\Win32_LIB_ASM_Debug\r\n-InputPath=..\\..\\contrib\\masmx86\\gvmat32.asm\r\n-InputName=gvmat32\r\n-\r\n-\"$(IntDir)\\$(InputName).obj\" : $(SOURCE) \"$(INTDIR)\" \"$(OUTDIR)\"\r\n-\tml.exe /nologo /c /coff /Cx /Zi /Fo\"$(IntDir)\\$(InputName).obj\" \"$(InputPath)\"\r\n-\r\n-# End Custom Build\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Release\"\r\n-\r\n-# PROP Exclude_From_Build 1\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Debug\"\r\n-\r\n-# PROP Exclude_From_Build 1\r\n-\r\n-!ENDIF\r\n-\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\contrib\\masmx86\\gvmat32c.c\r\n-\r\n-!IF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Release\"\r\n-\r\n-# ADD CPP /I \"..\\..\"\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Debug\"\r\n-\r\n-# ADD CPP /I \"..\\..\"\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL Release\"\r\n-\r\n-# PROP Exclude_From_Build 1\r\n-# ADD CPP /I \"..\\..\"\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL Debug\"\r\n-\r\n-# PROP Exclude_From_Build 1\r\n-# ADD CPP /I \"..\\..\"\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Release\"\r\n-\r\n-# ADD CPP /I \"..\\..\"\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Debug\"\r\n-\r\n-# ADD CPP /I \"..\\..\"\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Release\"\r\n-\r\n-# PROP Exclude_From_Build 1\r\n-# ADD CPP /I \"..\\..\"\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Debug\"\r\n-\r\n-# PROP Exclude_From_Build 1\r\n-# ADD CPP /I \"..\\..\"\r\n-\r\n-!ENDIF\r\n-\r\n-# End Source File\r\n-# Begin Source File\r\n-\r\n-SOURCE=..\\..\\contrib\\masmx86\\inffas32.asm\r\n-\r\n-!IF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Release\"\r\n-\r\n-# Begin Custom Build - Assembling...\r\n-IntDir=.\\Win32_DLL_ASM_Release\r\n-InputPath=..\\..\\contrib\\masmx86\\inffas32.asm\r\n-InputName=inffas32\r\n-\r\n-\"$(IntDir)\\$(InputName).obj\" : $(SOURCE) \"$(INTDIR)\" \"$(OUTDIR)\"\r\n-\tml.exe /nologo /c /coff /Cx /Fo\"$(IntDir)\\$(InputName).obj\" \"$(InputPath)\"\r\n-\r\n-# End Custom Build\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Debug\"\r\n-\r\n-# Begin Custom Build - Assembling...\r\n-IntDir=.\\Win32_DLL_ASM_Debug\r\n-InputPath=..\\..\\contrib\\masmx86\\inffas32.asm\r\n-InputName=inffas32\r\n-\r\n-\"$(IntDir)\\$(InputName).obj\" : $(SOURCE) \"$(INTDIR)\" \"$(OUTDIR)\"\r\n-\tml.exe /nologo /c /coff /Cx /Zi /Fo\"$(IntDir)\\$(InputName).obj\" \"$(InputPath)\"\r\n-\r\n-# End Custom Build\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL Release\"\r\n-\r\n-# PROP Exclude_From_Build 1\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL Debug\"\r\n-\r\n-# PROP Exclude_From_Build 1\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Release\"\r\n-\r\n-# Begin Custom Build - Assembling...\r\n-IntDir=.\\Win32_LIB_ASM_Release\r\n-InputPath=..\\..\\contrib\\masmx86\\inffas32.asm\r\n-InputName=inffas32\r\n-\r\n-\"$(IntDir)\\$(InputName).obj\" : $(SOURCE) \"$(INTDIR)\" \"$(OUTDIR)\"\r\n-\tml.exe /nologo /c /coff /Cx /Fo\"$(IntDir)\\$(InputName).obj\" \"$(InputPath)\"\r\n-\r\n-# End Custom Build\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Debug\"\r\n-\r\n-# Begin Custom Build - Assembling...\r\n-IntDir=.\\Win32_LIB_ASM_Debug\r\n-InputPath=..\\..\\contrib\\masmx86\\inffas32.asm\r\n-InputName=inffas32\r\n-\r\n-\"$(IntDir)\\$(InputName).obj\" : $(SOURCE) \"$(INTDIR)\" \"$(OUTDIR)\"\r\n-\tml.exe /nologo /c /coff /Cx /Zi /Fo\"$(IntDir)\\$(InputName).obj\" \"$(InputPath)\"\r\n-\r\n-# End Custom Build\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Release\"\r\n-\r\n-# PROP Exclude_From_Build 1\r\n-\r\n-!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Debug\"\r\n-\r\n-# PROP Exclude_From_Build 1\r\n-\r\n-!ENDIF\r\n-\r\n-# End Source File\r\n-# End Group\r\n-# Begin Source File\r\n-\r\n-SOURCE=.\\README.txt\r\n-# End Source File\r\n-# End Target\r\n-# End Project\r"}, {"sha": "3a771fce07d16f68c4dfffd6f90d7ea8973d6c76", "filename": "zlib/old/visualc6/zlib.dsw", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50605a7f19869692a6c29cead0a1366a420e0e65/zlib%2Fold%2Fvisualc6%2Fzlib.dsw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50605a7f19869692a6c29cead0a1366a420e0e65/zlib%2Fold%2Fvisualc6%2Fzlib.dsw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2Fvisualc6%2Fzlib.dsw?ref=50605a7f19869692a6c29cead0a1366a420e0e65", "patch": "@@ -1,59 +0,0 @@\n-Microsoft Developer Studio Workspace File, Format Version 6.00\r\n-# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!\r\n-\r\n-###############################################################################\r\n-\r\n-Project: \"example\"=.\\example.dsp - Package Owner=<4>\r\n-\r\n-Package=<5>\r\n-{{{\r\n-}}}\r\n-\r\n-Package=<4>\r\n-{{{\r\n-    Begin Project Dependency\r\n-    Project_Dep_Name zlib\r\n-    End Project Dependency\r\n-}}}\r\n-\r\n-###############################################################################\r\n-\r\n-Project: \"minigzip\"=.\\minigzip.dsp - Package Owner=<4>\r\n-\r\n-Package=<5>\r\n-{{{\r\n-}}}\r\n-\r\n-Package=<4>\r\n-{{{\r\n-    Begin Project Dependency\r\n-    Project_Dep_Name zlib\r\n-    End Project Dependency\r\n-}}}\r\n-\r\n-###############################################################################\r\n-\r\n-Project: \"zlib\"=.\\zlib.dsp - Package Owner=<4>\r\n-\r\n-Package=<5>\r\n-{{{\r\n-}}}\r\n-\r\n-Package=<4>\r\n-{{{\r\n-}}}\r\n-\r\n-###############################################################################\r\n-\r\n-Global:\r\n-\r\n-Package=<5>\r\n-{{{\r\n-}}}\r\n-\r\n-Package=<3>\r\n-{{{\r\n-}}}\r\n-\r\n-###############################################################################\r\n-\r"}, {"sha": "26eed9b34fee956539c1e20b9ac2b5b149aacffb", "filename": "zlib/qnx/package.qpg", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fqnx%2Fpackage.qpg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fqnx%2Fpackage.qpg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fqnx%2Fpackage.qpg?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -25,10 +25,10 @@\n       <QPG:Files>\n          <QPG:Add file=\"../zconf.h\" install=\"/opt/include/\" user=\"root:sys\" permission=\"644\"/>\n          <QPG:Add file=\"../zlib.h\" install=\"/opt/include/\" user=\"root:sys\" permission=\"644\"/>\n-         <QPG:Add file=\"../libz.so.1.2.5\" install=\"/opt/lib/\" user=\"root:bin\" permission=\"644\"/>\n-         <QPG:Add file=\"libz.so\" install=\"/opt/lib/\" component=\"dev\" filetype=\"symlink\" linkto=\"libz.so.1.2.5\"/>\n-         <QPG:Add file=\"libz.so.1\" install=\"/opt/lib/\" filetype=\"symlink\" linkto=\"libz.so.1.2.5\"/>\n-         <QPG:Add file=\"../libz.so.1.2.5\" install=\"/opt/lib/\" component=\"slib\"/>\n+         <QPG:Add file=\"../libz.so.1.2.7\" install=\"/opt/lib/\" user=\"root:bin\" permission=\"644\"/>\n+         <QPG:Add file=\"libz.so\" install=\"/opt/lib/\" component=\"dev\" filetype=\"symlink\" linkto=\"libz.so.1.2.7\"/>\n+         <QPG:Add file=\"libz.so.1\" install=\"/opt/lib/\" filetype=\"symlink\" linkto=\"libz.so.1.2.7\"/>\n+         <QPG:Add file=\"../libz.so.1.2.7\" install=\"/opt/lib/\" component=\"slib\"/>\n       </QPG:Files>\n \n       <QPG:PackageFilter>\n@@ -63,7 +63,7 @@\n             </QPM:ProductDescription>\n \n             <QPM:ReleaseDescription>\n-               <QPM:ReleaseVersion>1.2.5</QPM:ReleaseVersion>\n+               <QPM:ReleaseVersion>1.2.7</QPM:ReleaseVersion>\n                <QPM:ReleaseUrgency>Medium</QPM:ReleaseUrgency>\n                <QPM:ReleaseStability>Stable</QPM:ReleaseStability>\n                <QPM:ReleaseNoteMinor></QPM:ReleaseNoteMinor>"}, {"sha": "f515a4853d6f09d4071d2381b6c7cc79fec2245a", "filename": "zlib/test/example.c", "status": "added", "additions": 601, "deletions": 0, "changes": 601, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Ftest%2Fexample.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Ftest%2Fexample.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Ftest%2Fexample.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -0,0 +1,601 @@\n+/* example.c -- usage example of the zlib compression library\n+ * Copyright (C) 1995-2006, 2011 Jean-loup Gailly.\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+ */\n+\n+/* @(#) $Id$ */\n+\n+#include \"zlib.h\"\n+#include <stdio.h>\n+\n+#ifdef STDC\n+#  include <string.h>\n+#  include <stdlib.h>\n+#endif\n+\n+#if defined(VMS) || defined(RISCOS)\n+#  define TESTFILE \"foo-gz\"\n+#else\n+#  define TESTFILE \"foo.gz\"\n+#endif\n+\n+#define CHECK_ERR(err, msg) { \\\n+    if (err != Z_OK) { \\\n+        fprintf(stderr, \"%s error: %d\\n\", msg, err); \\\n+        exit(1); \\\n+    } \\\n+}\n+\n+const char hello[] = \"hello, hello!\";\n+/* \"hello world\" would be more standard, but the repeated \"hello\"\n+ * stresses the compression code better, sorry...\n+ */\n+\n+const char dictionary[] = \"hello\";\n+uLong dictId; /* Adler32 value of the dictionary */\n+\n+void test_deflate       OF((Byte *compr, uLong comprLen));\n+void test_inflate       OF((Byte *compr, uLong comprLen,\n+                            Byte *uncompr, uLong uncomprLen));\n+void test_large_deflate OF((Byte *compr, uLong comprLen,\n+                            Byte *uncompr, uLong uncomprLen));\n+void test_large_inflate OF((Byte *compr, uLong comprLen,\n+                            Byte *uncompr, uLong uncomprLen));\n+void test_flush         OF((Byte *compr, uLong *comprLen));\n+void test_sync          OF((Byte *compr, uLong comprLen,\n+                            Byte *uncompr, uLong uncomprLen));\n+void test_dict_deflate  OF((Byte *compr, uLong comprLen));\n+void test_dict_inflate  OF((Byte *compr, uLong comprLen,\n+                            Byte *uncompr, uLong uncomprLen));\n+int  main               OF((int argc, char *argv[]));\n+\n+\n+#ifdef Z_SOLO\n+\n+void *myalloc OF((void *, unsigned, unsigned));\n+void myfree OF((void *, void *));\n+\n+void *myalloc(q, n, m)\n+    void *q;\n+    unsigned n, m;\n+{\n+    q = Z_NULL;\n+    return calloc(n, m);\n+}\n+\n+void myfree(void *q, void *p)\n+{\n+    q = Z_NULL;\n+    free(p);\n+}\n+\n+static alloc_func zalloc = myalloc;\n+static free_func zfree = myfree;\n+\n+#else /* !Z_SOLO */\n+\n+static alloc_func zalloc = (alloc_func)0;\n+static free_func zfree = (free_func)0;\n+\n+void test_compress      OF((Byte *compr, uLong comprLen,\n+                            Byte *uncompr, uLong uncomprLen));\n+void test_gzio          OF((const char *fname,\n+                            Byte *uncompr, uLong uncomprLen));\n+\n+/* ===========================================================================\n+ * Test compress() and uncompress()\n+ */\n+void test_compress(compr, comprLen, uncompr, uncomprLen)\n+    Byte *compr, *uncompr;\n+    uLong comprLen, uncomprLen;\n+{\n+    int err;\n+    uLong len = (uLong)strlen(hello)+1;\n+\n+    err = compress(compr, &comprLen, (const Bytef*)hello, len);\n+    CHECK_ERR(err, \"compress\");\n+\n+    strcpy((char*)uncompr, \"garbage\");\n+\n+    err = uncompress(uncompr, &uncomprLen, compr, comprLen);\n+    CHECK_ERR(err, \"uncompress\");\n+\n+    if (strcmp((char*)uncompr, hello)) {\n+        fprintf(stderr, \"bad uncompress\\n\");\n+        exit(1);\n+    } else {\n+        printf(\"uncompress(): %s\\n\", (char *)uncompr);\n+    }\n+}\n+\n+/* ===========================================================================\n+ * Test read/write of .gz files\n+ */\n+void test_gzio(fname, uncompr, uncomprLen)\n+    const char *fname; /* compressed file name */\n+    Byte *uncompr;\n+    uLong uncomprLen;\n+{\n+#ifdef NO_GZCOMPRESS\n+    fprintf(stderr, \"NO_GZCOMPRESS -- gz* functions cannot compress\\n\");\n+#else\n+    int err;\n+    int len = (int)strlen(hello)+1;\n+    gzFile file;\n+    z_off_t pos;\n+\n+    file = gzopen(fname, \"wb\");\n+    if (file == NULL) {\n+        fprintf(stderr, \"gzopen error\\n\");\n+        exit(1);\n+    }\n+    gzputc(file, 'h');\n+    if (gzputs(file, \"ello\") != 4) {\n+        fprintf(stderr, \"gzputs err: %s\\n\", gzerror(file, &err));\n+        exit(1);\n+    }\n+    if (gzprintf(file, \", %s!\", \"hello\") != 8) {\n+        fprintf(stderr, \"gzprintf err: %s\\n\", gzerror(file, &err));\n+        exit(1);\n+    }\n+    gzseek(file, 1L, SEEK_CUR); /* add one zero byte */\n+    gzclose(file);\n+\n+    file = gzopen(fname, \"rb\");\n+    if (file == NULL) {\n+        fprintf(stderr, \"gzopen error\\n\");\n+        exit(1);\n+    }\n+    strcpy((char*)uncompr, \"garbage\");\n+\n+    if (gzread(file, uncompr, (unsigned)uncomprLen) != len) {\n+        fprintf(stderr, \"gzread err: %s\\n\", gzerror(file, &err));\n+        exit(1);\n+    }\n+    if (strcmp((char*)uncompr, hello)) {\n+        fprintf(stderr, \"bad gzread: %s\\n\", (char*)uncompr);\n+        exit(1);\n+    } else {\n+        printf(\"gzread(): %s\\n\", (char*)uncompr);\n+    }\n+\n+    pos = gzseek(file, -8L, SEEK_CUR);\n+    if (pos != 6 || gztell(file) != pos) {\n+        fprintf(stderr, \"gzseek error, pos=%ld, gztell=%ld\\n\",\n+                (long)pos, (long)gztell(file));\n+        exit(1);\n+    }\n+\n+    if (gzgetc(file) != ' ') {\n+        fprintf(stderr, \"gzgetc error\\n\");\n+        exit(1);\n+    }\n+\n+    if (gzungetc(' ', file) != ' ') {\n+        fprintf(stderr, \"gzungetc error\\n\");\n+        exit(1);\n+    }\n+\n+    gzgets(file, (char*)uncompr, (int)uncomprLen);\n+    if (strlen((char*)uncompr) != 7) { /* \" hello!\" */\n+        fprintf(stderr, \"gzgets err after gzseek: %s\\n\", gzerror(file, &err));\n+        exit(1);\n+    }\n+    if (strcmp((char*)uncompr, hello + 6)) {\n+        fprintf(stderr, \"bad gzgets after gzseek\\n\");\n+        exit(1);\n+    } else {\n+        printf(\"gzgets() after gzseek: %s\\n\", (char*)uncompr);\n+    }\n+\n+    gzclose(file);\n+#endif\n+}\n+\n+#endif /* Z_SOLO */\n+\n+/* ===========================================================================\n+ * Test deflate() with small buffers\n+ */\n+void test_deflate(compr, comprLen)\n+    Byte *compr;\n+    uLong comprLen;\n+{\n+    z_stream c_stream; /* compression stream */\n+    int err;\n+    uLong len = (uLong)strlen(hello)+1;\n+\n+    c_stream.zalloc = zalloc;\n+    c_stream.zfree = zfree;\n+    c_stream.opaque = (voidpf)0;\n+\n+    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);\n+    CHECK_ERR(err, \"deflateInit\");\n+\n+    c_stream.next_in  = (Bytef*)hello;\n+    c_stream.next_out = compr;\n+\n+    while (c_stream.total_in != len && c_stream.total_out < comprLen) {\n+        c_stream.avail_in = c_stream.avail_out = 1; /* force small buffers */\n+        err = deflate(&c_stream, Z_NO_FLUSH);\n+        CHECK_ERR(err, \"deflate\");\n+    }\n+    /* Finish the stream, still forcing small buffers: */\n+    for (;;) {\n+        c_stream.avail_out = 1;\n+        err = deflate(&c_stream, Z_FINISH);\n+        if (err == Z_STREAM_END) break;\n+        CHECK_ERR(err, \"deflate\");\n+    }\n+\n+    err = deflateEnd(&c_stream);\n+    CHECK_ERR(err, \"deflateEnd\");\n+}\n+\n+/* ===========================================================================\n+ * Test inflate() with small buffers\n+ */\n+void test_inflate(compr, comprLen, uncompr, uncomprLen)\n+    Byte *compr, *uncompr;\n+    uLong comprLen, uncomprLen;\n+{\n+    int err;\n+    z_stream d_stream; /* decompression stream */\n+\n+    strcpy((char*)uncompr, \"garbage\");\n+\n+    d_stream.zalloc = zalloc;\n+    d_stream.zfree = zfree;\n+    d_stream.opaque = (voidpf)0;\n+\n+    d_stream.next_in  = compr;\n+    d_stream.avail_in = 0;\n+    d_stream.next_out = uncompr;\n+\n+    err = inflateInit(&d_stream);\n+    CHECK_ERR(err, \"inflateInit\");\n+\n+    while (d_stream.total_out < uncomprLen && d_stream.total_in < comprLen) {\n+        d_stream.avail_in = d_stream.avail_out = 1; /* force small buffers */\n+        err = inflate(&d_stream, Z_NO_FLUSH);\n+        if (err == Z_STREAM_END) break;\n+        CHECK_ERR(err, \"inflate\");\n+    }\n+\n+    err = inflateEnd(&d_stream);\n+    CHECK_ERR(err, \"inflateEnd\");\n+\n+    if (strcmp((char*)uncompr, hello)) {\n+        fprintf(stderr, \"bad inflate\\n\");\n+        exit(1);\n+    } else {\n+        printf(\"inflate(): %s\\n\", (char *)uncompr);\n+    }\n+}\n+\n+/* ===========================================================================\n+ * Test deflate() with large buffers and dynamic change of compression level\n+ */\n+void test_large_deflate(compr, comprLen, uncompr, uncomprLen)\n+    Byte *compr, *uncompr;\n+    uLong comprLen, uncomprLen;\n+{\n+    z_stream c_stream; /* compression stream */\n+    int err;\n+\n+    c_stream.zalloc = zalloc;\n+    c_stream.zfree = zfree;\n+    c_stream.opaque = (voidpf)0;\n+\n+    err = deflateInit(&c_stream, Z_BEST_SPEED);\n+    CHECK_ERR(err, \"deflateInit\");\n+\n+    c_stream.next_out = compr;\n+    c_stream.avail_out = (uInt)comprLen;\n+\n+    /* At this point, uncompr is still mostly zeroes, so it should compress\n+     * very well:\n+     */\n+    c_stream.next_in = uncompr;\n+    c_stream.avail_in = (uInt)uncomprLen;\n+    err = deflate(&c_stream, Z_NO_FLUSH);\n+    CHECK_ERR(err, \"deflate\");\n+    if (c_stream.avail_in != 0) {\n+        fprintf(stderr, \"deflate not greedy\\n\");\n+        exit(1);\n+    }\n+\n+    /* Feed in already compressed data and switch to no compression: */\n+    deflateParams(&c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);\n+    c_stream.next_in = compr;\n+    c_stream.avail_in = (uInt)comprLen/2;\n+    err = deflate(&c_stream, Z_NO_FLUSH);\n+    CHECK_ERR(err, \"deflate\");\n+\n+    /* Switch back to compressing mode: */\n+    deflateParams(&c_stream, Z_BEST_COMPRESSION, Z_FILTERED);\n+    c_stream.next_in = uncompr;\n+    c_stream.avail_in = (uInt)uncomprLen;\n+    err = deflate(&c_stream, Z_NO_FLUSH);\n+    CHECK_ERR(err, \"deflate\");\n+\n+    err = deflate(&c_stream, Z_FINISH);\n+    if (err != Z_STREAM_END) {\n+        fprintf(stderr, \"deflate should report Z_STREAM_END\\n\");\n+        exit(1);\n+    }\n+    err = deflateEnd(&c_stream);\n+    CHECK_ERR(err, \"deflateEnd\");\n+}\n+\n+/* ===========================================================================\n+ * Test inflate() with large buffers\n+ */\n+void test_large_inflate(compr, comprLen, uncompr, uncomprLen)\n+    Byte *compr, *uncompr;\n+    uLong comprLen, uncomprLen;\n+{\n+    int err;\n+    z_stream d_stream; /* decompression stream */\n+\n+    strcpy((char*)uncompr, \"garbage\");\n+\n+    d_stream.zalloc = zalloc;\n+    d_stream.zfree = zfree;\n+    d_stream.opaque = (voidpf)0;\n+\n+    d_stream.next_in  = compr;\n+    d_stream.avail_in = (uInt)comprLen;\n+\n+    err = inflateInit(&d_stream);\n+    CHECK_ERR(err, \"inflateInit\");\n+\n+    for (;;) {\n+        d_stream.next_out = uncompr;            /* discard the output */\n+        d_stream.avail_out = (uInt)uncomprLen;\n+        err = inflate(&d_stream, Z_NO_FLUSH);\n+        if (err == Z_STREAM_END) break;\n+        CHECK_ERR(err, \"large inflate\");\n+    }\n+\n+    err = inflateEnd(&d_stream);\n+    CHECK_ERR(err, \"inflateEnd\");\n+\n+    if (d_stream.total_out != 2*uncomprLen + comprLen/2) {\n+        fprintf(stderr, \"bad large inflate: %ld\\n\", d_stream.total_out);\n+        exit(1);\n+    } else {\n+        printf(\"large_inflate(): OK\\n\");\n+    }\n+}\n+\n+/* ===========================================================================\n+ * Test deflate() with full flush\n+ */\n+void test_flush(compr, comprLen)\n+    Byte *compr;\n+    uLong *comprLen;\n+{\n+    z_stream c_stream; /* compression stream */\n+    int err;\n+    uInt len = (uInt)strlen(hello)+1;\n+\n+    c_stream.zalloc = zalloc;\n+    c_stream.zfree = zfree;\n+    c_stream.opaque = (voidpf)0;\n+\n+    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);\n+    CHECK_ERR(err, \"deflateInit\");\n+\n+    c_stream.next_in  = (Bytef*)hello;\n+    c_stream.next_out = compr;\n+    c_stream.avail_in = 3;\n+    c_stream.avail_out = (uInt)*comprLen;\n+    err = deflate(&c_stream, Z_FULL_FLUSH);\n+    CHECK_ERR(err, \"deflate\");\n+\n+    compr[3]++; /* force an error in first compressed block */\n+    c_stream.avail_in = len - 3;\n+\n+    err = deflate(&c_stream, Z_FINISH);\n+    if (err != Z_STREAM_END) {\n+        CHECK_ERR(err, \"deflate\");\n+    }\n+    err = deflateEnd(&c_stream);\n+    CHECK_ERR(err, \"deflateEnd\");\n+\n+    *comprLen = c_stream.total_out;\n+}\n+\n+/* ===========================================================================\n+ * Test inflateSync()\n+ */\n+void test_sync(compr, comprLen, uncompr, uncomprLen)\n+    Byte *compr, *uncompr;\n+    uLong comprLen, uncomprLen;\n+{\n+    int err;\n+    z_stream d_stream; /* decompression stream */\n+\n+    strcpy((char*)uncompr, \"garbage\");\n+\n+    d_stream.zalloc = zalloc;\n+    d_stream.zfree = zfree;\n+    d_stream.opaque = (voidpf)0;\n+\n+    d_stream.next_in  = compr;\n+    d_stream.avail_in = 2; /* just read the zlib header */\n+\n+    err = inflateInit(&d_stream);\n+    CHECK_ERR(err, \"inflateInit\");\n+\n+    d_stream.next_out = uncompr;\n+    d_stream.avail_out = (uInt)uncomprLen;\n+\n+    inflate(&d_stream, Z_NO_FLUSH);\n+    CHECK_ERR(err, \"inflate\");\n+\n+    d_stream.avail_in = (uInt)comprLen-2;   /* read all compressed data */\n+    err = inflateSync(&d_stream);           /* but skip the damaged part */\n+    CHECK_ERR(err, \"inflateSync\");\n+\n+    err = inflate(&d_stream, Z_FINISH);\n+    if (err != Z_DATA_ERROR) {\n+        fprintf(stderr, \"inflate should report DATA_ERROR\\n\");\n+        /* Because of incorrect adler32 */\n+        exit(1);\n+    }\n+    err = inflateEnd(&d_stream);\n+    CHECK_ERR(err, \"inflateEnd\");\n+\n+    printf(\"after inflateSync(): hel%s\\n\", (char *)uncompr);\n+}\n+\n+/* ===========================================================================\n+ * Test deflate() with preset dictionary\n+ */\n+void test_dict_deflate(compr, comprLen)\n+    Byte *compr;\n+    uLong comprLen;\n+{\n+    z_stream c_stream; /* compression stream */\n+    int err;\n+\n+    c_stream.zalloc = zalloc;\n+    c_stream.zfree = zfree;\n+    c_stream.opaque = (voidpf)0;\n+\n+    err = deflateInit(&c_stream, Z_BEST_COMPRESSION);\n+    CHECK_ERR(err, \"deflateInit\");\n+\n+    err = deflateSetDictionary(&c_stream,\n+                (const Bytef*)dictionary, (int)sizeof(dictionary));\n+    CHECK_ERR(err, \"deflateSetDictionary\");\n+\n+    dictId = c_stream.adler;\n+    c_stream.next_out = compr;\n+    c_stream.avail_out = (uInt)comprLen;\n+\n+    c_stream.next_in = (Bytef*)hello;\n+    c_stream.avail_in = (uInt)strlen(hello)+1;\n+\n+    err = deflate(&c_stream, Z_FINISH);\n+    if (err != Z_STREAM_END) {\n+        fprintf(stderr, \"deflate should report Z_STREAM_END\\n\");\n+        exit(1);\n+    }\n+    err = deflateEnd(&c_stream);\n+    CHECK_ERR(err, \"deflateEnd\");\n+}\n+\n+/* ===========================================================================\n+ * Test inflate() with a preset dictionary\n+ */\n+void test_dict_inflate(compr, comprLen, uncompr, uncomprLen)\n+    Byte *compr, *uncompr;\n+    uLong comprLen, uncomprLen;\n+{\n+    int err;\n+    z_stream d_stream; /* decompression stream */\n+\n+    strcpy((char*)uncompr, \"garbage\");\n+\n+    d_stream.zalloc = zalloc;\n+    d_stream.zfree = zfree;\n+    d_stream.opaque = (voidpf)0;\n+\n+    d_stream.next_in  = compr;\n+    d_stream.avail_in = (uInt)comprLen;\n+\n+    err = inflateInit(&d_stream);\n+    CHECK_ERR(err, \"inflateInit\");\n+\n+    d_stream.next_out = uncompr;\n+    d_stream.avail_out = (uInt)uncomprLen;\n+\n+    for (;;) {\n+        err = inflate(&d_stream, Z_NO_FLUSH);\n+        if (err == Z_STREAM_END) break;\n+        if (err == Z_NEED_DICT) {\n+            if (d_stream.adler != dictId) {\n+                fprintf(stderr, \"unexpected dictionary\");\n+                exit(1);\n+            }\n+            err = inflateSetDictionary(&d_stream, (const Bytef*)dictionary,\n+                                       (int)sizeof(dictionary));\n+        }\n+        CHECK_ERR(err, \"inflate with dict\");\n+    }\n+\n+    err = inflateEnd(&d_stream);\n+    CHECK_ERR(err, \"inflateEnd\");\n+\n+    if (strcmp((char*)uncompr, hello)) {\n+        fprintf(stderr, \"bad inflate with dict\\n\");\n+        exit(1);\n+    } else {\n+        printf(\"inflate with dictionary: %s\\n\", (char *)uncompr);\n+    }\n+}\n+\n+/* ===========================================================================\n+ * Usage:  example [output.gz  [input.gz]]\n+ */\n+\n+int main(argc, argv)\n+    int argc;\n+    char *argv[];\n+{\n+    Byte *compr, *uncompr;\n+    uLong comprLen = 10000*sizeof(int); /* don't overflow on MSDOS */\n+    uLong uncomprLen = comprLen;\n+    static const char* myVersion = ZLIB_VERSION;\n+\n+    if (zlibVersion()[0] != myVersion[0]) {\n+        fprintf(stderr, \"incompatible zlib version\\n\");\n+        exit(1);\n+\n+    } else if (strcmp(zlibVersion(), ZLIB_VERSION) != 0) {\n+        fprintf(stderr, \"warning: different zlib version\\n\");\n+    }\n+\n+    printf(\"zlib version %s = 0x%04x, compile flags = 0x%lx\\n\",\n+            ZLIB_VERSION, ZLIB_VERNUM, zlibCompileFlags());\n+\n+    compr    = (Byte*)calloc((uInt)comprLen, 1);\n+    uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);\n+    /* compr and uncompr are cleared to avoid reading uninitialized\n+     * data and to ensure that uncompr compresses well.\n+     */\n+    if (compr == Z_NULL || uncompr == Z_NULL) {\n+        printf(\"out of memory\\n\");\n+        exit(1);\n+    }\n+\n+#ifdef Z_SOLO\n+    argc = strlen(argv[0]);\n+#else\n+    test_compress(compr, comprLen, uncompr, uncomprLen);\n+\n+    test_gzio((argc > 1 ? argv[1] : TESTFILE),\n+              uncompr, uncomprLen);\n+#endif\n+\n+    test_deflate(compr, comprLen);\n+    test_inflate(compr, comprLen, uncompr, uncomprLen);\n+\n+    test_large_deflate(compr, comprLen, uncompr, uncomprLen);\n+    test_large_inflate(compr, comprLen, uncompr, uncomprLen);\n+\n+    test_flush(compr, &comprLen);\n+    test_sync(compr, comprLen, uncompr, uncomprLen);\n+    comprLen = uncomprLen;\n+\n+    test_dict_deflate(compr, comprLen);\n+    test_dict_inflate(compr, comprLen, uncompr, uncomprLen);\n+\n+    free(compr);\n+    free(uncompr);\n+\n+    return 0;\n+}"}, {"sha": "fe3d9203a023777a82572e9aa38449a066d7c07b", "filename": "zlib/test/infcover.c", "status": "added", "additions": 671, "deletions": 0, "changes": 671, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Ftest%2Finfcover.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Ftest%2Finfcover.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Ftest%2Finfcover.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -0,0 +1,671 @@\n+/* infcover.c -- test zlib's inflate routines with full code coverage\n+ * Copyright (C) 2011 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+ */\n+\n+/* to use, do: ./configure --cover && make cover */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include \"zlib.h\"\n+\n+/* get definition of internal structure so we can mess with it (see pull()),\n+   and so we can call inflate_trees() (see cover5()) */\n+#define ZLIB_INTERNAL\n+#include \"inftrees.h\"\n+#include \"inflate.h\"\n+\n+#define local static\n+\n+/* -- memory tracking routines -- */\n+\n+/*\n+   These memory tracking routines are provided to zlib and track all of zlib's\n+   allocations and deallocations, check for LIFO operations, keep a current\n+   and high water mark of total bytes requested, optionally set a limit on the\n+   total memory that can be allocated, and when done check for memory leaks.\n+\n+   They are used as follows:\n+\n+   z_stream strm;\n+   mem_setup(&strm)         initializes the memory tracking and sets the\n+                            zalloc, zfree, and opaque members of strm to use\n+                            memory tracking for all zlib operations on strm\n+   mem_limit(&strm, limit)  sets a limit on the total bytes requested -- a\n+                            request that exceeds this limit will result in an\n+                            allocation failure (returns NULL) -- setting the\n+                            limit to zero means no limit, which is the default\n+                            after mem_setup()\n+   mem_used(&strm, \"msg\")   prints to stderr \"msg\" and the total bytes used\n+   mem_high(&strm, \"msg\")   prints to stderr \"msg\" and the high water mark\n+   mem_done(&strm, \"msg\")   ends memory tracking, releases all allocations\n+                            for the tracking as well as leaked zlib blocks, if\n+                            any.  If there was anything unusual, such as leaked\n+                            blocks, non-FIFO frees, or frees of addresses not\n+                            allocated, then \"msg\" and information about the\n+                            problem is printed to stderr.  If everything is\n+                            normal, nothing is printed. mem_done resets the\n+                            strm members to Z_NULL to use the default memory\n+                            allocation routines on the next zlib initialization\n+                            using strm.\n+ */\n+\n+/* these items are strung together in a linked list, one for each allocation */\n+struct mem_item {\n+    void *ptr;                  /* pointer to allocated memory */\n+    size_t size;                /* requested size of allocation */\n+    struct mem_item *next;      /* pointer to next item in list, or NULL */\n+};\n+\n+/* this structure is at the root of the linked list, and tracks statistics */\n+struct mem_zone {\n+    struct mem_item *first;     /* pointer to first item in list, or NULL */\n+    size_t total, highwater;    /* total allocations, and largest total */\n+    size_t limit;               /* memory allocation limit, or 0 if no limit */\n+    int notlifo, rogue;         /* counts of non-LIFO frees and rogue frees */\n+};\n+\n+/* memory allocation routine to pass to zlib */\n+local void *mem_alloc(void *mem, unsigned count, unsigned size)\n+{\n+    void *ptr;\n+    struct mem_item *item;\n+    struct mem_zone *zone = mem;\n+    size_t len = count * (size_t)size;\n+\n+    /* induced allocation failure */\n+    if (zone == NULL || (zone->limit && zone->total + len > zone->limit))\n+        return NULL;\n+\n+    /* perform allocation using the standard library, fill memory with a\n+       non-zero value to make sure that the code isn't depending on zeros */\n+    ptr = malloc(len);\n+    if (ptr == NULL)\n+        return NULL;\n+    memset(ptr, 0xa5, len);\n+\n+    /* create a new item for the list */\n+    item = malloc(sizeof(struct mem_item));\n+    if (item == NULL) {\n+        free(ptr);\n+        return NULL;\n+    }\n+    item->ptr = ptr;\n+    item->size = len;\n+\n+    /* insert item at the beginning of the list */\n+    item->next = zone->first;\n+    zone->first = item;\n+\n+    /* update the statistics */\n+    zone->total += item->size;\n+    if (zone->total > zone->highwater)\n+        zone->highwater = zone->total;\n+\n+    /* return the allocated memory */\n+    return ptr;\n+}\n+\n+/* memory free routine to pass to zlib */\n+local void mem_free(void *mem, void *ptr)\n+{\n+    struct mem_item *item, *next;\n+    struct mem_zone *zone = mem;\n+\n+    /* if no zone, just do a free */\n+    if (zone == NULL) {\n+        free(ptr);\n+        return;\n+    }\n+\n+    /* point next to the item that matches ptr, or NULL if not found -- remove\n+       the item from the linked list if found */\n+    next = zone->first;\n+    if (next) {\n+        if (next->ptr == ptr)\n+            zone->first = next->next;   /* first one is it, remove from list */\n+        else {\n+            do {                        /* search the linked list */\n+                item = next;\n+                next = item->next;\n+            } while (next != NULL && next->ptr != ptr);\n+            if (next) {                 /* if found, remove from linked list */\n+                item->next = next->next;\n+                zone->notlifo++;        /* not a LIFO free */\n+            }\n+\n+        }\n+    }\n+\n+    /* if found, update the statistics and free the item */\n+    if (next) {\n+        zone->total -= next->size;\n+        free(next);\n+    }\n+\n+    /* if not found, update the rogue count */\n+    else\n+        zone->rogue++;\n+\n+    /* in any case, do the requested free with the standard library function */\n+    free(ptr);\n+}\n+\n+/* set up a controlled memory allocation space for monitoring, set the stream\n+   parameters to the controlled routines, with opaque pointing to the space */\n+local void mem_setup(z_stream *strm)\n+{\n+    struct mem_zone *zone;\n+\n+    zone = malloc(sizeof(struct mem_zone));\n+    assert(zone != NULL);\n+    zone->first = NULL;\n+    zone->total = 0;\n+    zone->highwater = 0;\n+    zone->limit = 0;\n+    zone->notlifo = 0;\n+    zone->rogue = 0;\n+    strm->opaque = zone;\n+    strm->zalloc = mem_alloc;\n+    strm->zfree = mem_free;\n+}\n+\n+/* set a limit on the total memory allocation, or 0 to remove the limit */\n+local void mem_limit(z_stream *strm, size_t limit)\n+{\n+    struct mem_zone *zone = strm->opaque;\n+\n+    zone->limit = limit;\n+}\n+\n+/* show the current total requested allocations in bytes */\n+local void mem_used(z_stream *strm, char *prefix)\n+{\n+    struct mem_zone *zone = strm->opaque;\n+\n+    fprintf(stderr, \"%s: %lu allocated\\n\", prefix, zone->total);\n+}\n+\n+/* show the high water allocation in bytes */\n+local void mem_high(z_stream *strm, char *prefix)\n+{\n+    struct mem_zone *zone = strm->opaque;\n+\n+    fprintf(stderr, \"%s: %lu high water mark\\n\", prefix, zone->highwater);\n+}\n+\n+/* release the memory allocation zone -- if there are any surprises, notify */\n+local void mem_done(z_stream *strm, char *prefix)\n+{\n+    int count = 0;\n+    struct mem_item *item, *next;\n+    struct mem_zone *zone = strm->opaque;\n+\n+    /* show high water mark */\n+    mem_high(strm, prefix);\n+\n+    /* free leftover allocations and item structures, if any */\n+    item = zone->first;\n+    while (item != NULL) {\n+        free(item->ptr);\n+        next = item->next;\n+        free(item);\n+        item = next;\n+        count++;\n+    }\n+\n+    /* issue alerts about anything unexpected */\n+    if (count || zone->total)\n+        fprintf(stderr, \"** %s: %lu bytes in %d blocks not freed\\n\",\n+                prefix, zone->total, count);\n+    if (zone->notlifo)\n+        fprintf(stderr, \"** %s: %d frees not LIFO\\n\", prefix, zone->notlifo);\n+    if (zone->rogue)\n+        fprintf(stderr, \"** %s: %d frees not recognized\\n\",\n+                prefix, zone->rogue);\n+\n+    /* free the zone and delete from the stream */\n+    free(zone);\n+    strm->opaque = Z_NULL;\n+    strm->zalloc = Z_NULL;\n+    strm->zfree = Z_NULL;\n+}\n+\n+/* -- inflate test routines -- */\n+\n+/* Decode a hexadecimal string, set *len to length, in[] to the bytes.  This\n+   decodes liberally, in that hex digits can be adjacent, in which case two in\n+   a row writes a byte.  Or they can delimited by any non-hex character, where\n+   the delimiters are ignored except when a single hex digit is followed by a\n+   delimiter in which case that single digit writes a byte.  The returned\n+   data is allocated and must eventually be freed.  NULL is returned if out of\n+   memory.  If the length is not needed, then len can be NULL. */\n+local unsigned char *h2b(const char *hex, unsigned *len)\n+{\n+    unsigned char *in;\n+    unsigned next, val;\n+\n+    in = malloc((strlen(hex) + 1) >> 1);\n+    if (in == NULL)\n+        return NULL;\n+    next = 0;\n+    val = 1;\n+    do {\n+        if (*hex >= '0' && *hex <= '9')\n+            val = (val << 4) + *hex - '0';\n+        else if (*hex >= 'A' && *hex <= 'F')\n+            val = (val << 4) + *hex - 'A' + 10;\n+        else if (*hex >= 'a' && *hex <= 'f')\n+            val = (val << 4) + *hex - 'a' + 10;\n+        else if (val != 1 && val < 32)  /* one digit followed by delimiter */\n+            val += 240;                 /* make it look like two digits */\n+        if (val > 255) {                /* have two digits */\n+            in[next++] = val & 0xff;    /* save the decoded byte */\n+            val = 1;                    /* start over */\n+        }\n+    } while (*hex++);       /* go through the loop with the terminating null */\n+    if (len != NULL)\n+        *len = next;\n+    in = reallocf(in, next);\n+    return in;\n+}\n+\n+/* generic inflate() run, where hex is the hexadecimal input data, what is the\n+   text to include in an error message, step is how much input data to feed\n+   inflate() on each call, or zero to feed it all, win is the window bits\n+   parameter to inflateInit2(), len is the size of the output buffer, and err\n+   is the error code expected from the first inflate() call (the second\n+   inflate() call is expected to return Z_STREAM_END).  If win is 47, then\n+   header information is collected with inflateGetHeader().  If a zlib stream\n+   is looking for a dictionary, then an empty dictionary is provided.\n+   inflate() is run until all of the input data is consumed. */\n+local void inf(char *hex, char *what, unsigned step, int win, unsigned len,\n+               int err)\n+{\n+    int ret;\n+    unsigned have;\n+    unsigned char *in, *out;\n+    z_stream strm, copy;\n+    gz_header head;\n+\n+    mem_setup(&strm);\n+    strm.avail_in = 0;\n+    strm.next_in = Z_NULL;\n+    ret = inflateInit2(&strm, win);\n+    if (ret != Z_OK) {\n+        mem_done(&strm, what);\n+        return;\n+    }\n+    out = malloc(len);                          assert(out != NULL);\n+    if (win == 47) {\n+        head.extra = out;\n+        head.extra_max = len;\n+        head.name = out;\n+        head.name_max = len;\n+        head.comment = out;\n+        head.comm_max = len;\n+        ret = inflateGetHeader(&strm, &head);   assert(ret == Z_OK);\n+    }\n+    in = h2b(hex, &have);                       assert(in != NULL);\n+    if (step == 0 || step > have)\n+        step = have;\n+    strm.avail_in = step;\n+    have -= step;\n+    strm.next_in = in;\n+    do {\n+        strm.avail_out = len;\n+        strm.next_out = out;\n+        ret = inflate(&strm, Z_NO_FLUSH);       assert(err == 9 || ret == err);\n+        if (ret != Z_OK && ret != Z_BUF_ERROR && ret != Z_NEED_DICT)\n+            break;\n+        if (ret == Z_NEED_DICT) {\n+            ret = inflateSetDictionary(&strm, in, 1);\n+                                                assert(ret == Z_DATA_ERROR);\n+            mem_limit(&strm, 1);\n+            ret = inflateSetDictionary(&strm, out, 0);\n+                                                assert(ret == Z_MEM_ERROR);\n+            mem_limit(&strm, 0);\n+            ((struct inflate_state *)strm.state)->mode = DICT;\n+            ret = inflateSetDictionary(&strm, out, 0);\n+                                                assert(ret == Z_OK);\n+            ret = inflate(&strm, Z_NO_FLUSH);   assert(ret == Z_BUF_ERROR);\n+        }\n+        ret = inflateCopy(&copy, &strm);        assert(ret == Z_OK);\n+        ret = inflateEnd(&copy);                assert(ret == Z_OK);\n+        err = 9;                        /* don't care next time around */\n+        have += strm.avail_in;\n+        strm.avail_in = step > have ? have : step;\n+        have -= strm.avail_in;\n+    } while (strm.avail_in);\n+    free(in);\n+    free(out);\n+    ret = inflateReset2(&strm, -8);             assert(ret == Z_OK);\n+    ret = inflateEnd(&strm);                    assert(ret == Z_OK);\n+    mem_done(&strm, what);\n+}\n+\n+/* cover all of the lines in inflate.c up to inflate() */\n+local void cover_support(void)\n+{\n+    int ret;\n+    z_stream strm;\n+\n+    mem_setup(&strm);\n+    strm.avail_in = 0;\n+    strm.next_in = Z_NULL;\n+    ret = inflateInit(&strm);                   assert(ret == Z_OK);\n+    mem_used(&strm, \"inflate init\");\n+    ret = inflatePrime(&strm, 5, 31);           assert(ret == Z_OK);\n+    ret = inflatePrime(&strm, -1, 0);           assert(ret == Z_OK);\n+    ret = inflateSetDictionary(&strm, Z_NULL, 0);\n+                                                assert(ret == Z_STREAM_ERROR);\n+    ret = inflateEnd(&strm);                    assert(ret == Z_OK);\n+    mem_done(&strm, \"prime\");\n+\n+    inf(\"63 0\", \"force window allocation\", 0, -15, 1, Z_OK);\n+    inf(\"63 18 5\", \"force window replacement\", 0, -8, 259, Z_OK);\n+    inf(\"63 18 68 30 d0 0 0\", \"force split window update\", 4, -8, 259, Z_OK);\n+    inf(\"3 0\", \"use fixed blocks\", 0, -15, 1, Z_STREAM_END);\n+    inf(\"\", \"bad window size\", 0, 1, 0, Z_STREAM_ERROR);\n+\n+    mem_setup(&strm);\n+    strm.avail_in = 0;\n+    strm.next_in = Z_NULL;\n+    ret = inflateInit_(&strm, ZLIB_VERSION - 1, (int)sizeof(z_stream));\n+                                                assert(ret == Z_VERSION_ERROR);\n+    mem_done(&strm, \"wrong version\");\n+\n+    strm.avail_in = 0;\n+    strm.next_in = Z_NULL;\n+    ret = inflateInit(&strm);                   assert(ret == Z_OK);\n+    ret = inflateEnd(&strm);                    assert(ret == Z_OK);\n+    fputs(\"inflate built-in memory routines\\n\", stderr);\n+}\n+\n+/* cover all inflate() header and trailer cases and code after inflate() */\n+local void cover_wrap(void)\n+{\n+    int ret;\n+    z_stream strm, copy;\n+    unsigned char dict[257];\n+\n+    ret = inflate(Z_NULL, 0);                   assert(ret == Z_STREAM_ERROR);\n+    ret = inflateEnd(Z_NULL);                   assert(ret == Z_STREAM_ERROR);\n+    ret = inflateCopy(Z_NULL, Z_NULL);          assert(ret == Z_STREAM_ERROR);\n+    fputs(\"inflate bad parameters\\n\", stderr);\n+\n+    inf(\"1f 8b 0 0\", \"bad gzip method\", 0, 31, 0, Z_DATA_ERROR);\n+    inf(\"1f 8b 8 80\", \"bad gzip flags\", 0, 31, 0, Z_DATA_ERROR);\n+    inf(\"77 85\", \"bad zlib method\", 0, 15, 0, Z_DATA_ERROR);\n+    inf(\"8 99\", \"set window size from header\", 0, 0, 0, Z_OK);\n+    inf(\"78 9c\", \"bad zlib window size\", 0, 8, 0, Z_DATA_ERROR);\n+    inf(\"78 9c 63 0 0 0 1 0 1\", \"check adler32\", 0, 15, 1, Z_STREAM_END);\n+    inf(\"1f 8b 8 1e 0 0 0 0 0 0 1 0 0 0 0 0 0\", \"bad header crc\", 0, 47, 1,\n+        Z_DATA_ERROR);\n+    inf(\"1f 8b 8 2 0 0 0 0 0 0 1d 26 3 0 0 0 0 0 0 0 0 0\", \"check gzip length\",\n+        0, 47, 0, Z_STREAM_END);\n+    inf(\"78 90\", \"bad zlib header check\", 0, 47, 0, Z_DATA_ERROR);\n+    inf(\"8 b8 0 0 0 1\", \"need dictionary\", 0, 8, 0, Z_NEED_DICT);\n+    inf(\"78 9c 63 0\", \"compute adler32\", 0, 15, 1, Z_OK);\n+\n+    mem_setup(&strm);\n+    strm.avail_in = 0;\n+    strm.next_in = Z_NULL;\n+    ret = inflateInit2(&strm, -8);\n+    strm.avail_in = 2;\n+    strm.next_in = (void *)\"\\x63\";\n+    strm.avail_out = 1;\n+    strm.next_out = (void *)&ret;\n+    mem_limit(&strm, 1);\n+    ret = inflate(&strm, Z_NO_FLUSH);           assert(ret == Z_MEM_ERROR);\n+    ret = inflate(&strm, Z_NO_FLUSH);           assert(ret == Z_MEM_ERROR);\n+    mem_limit(&strm, 0);\n+    memset(dict, 0, 257);\n+    ret = inflateSetDictionary(&strm, dict, 257);\n+                                                assert(ret == Z_OK);\n+    mem_limit(&strm, (sizeof(struct inflate_state) << 1) + 256);\n+    ret = inflatePrime(&strm, 16, 0);           assert(ret == Z_OK);\n+    strm.avail_in = 2;\n+    strm.next_in = (void *)\"\\x80\";\n+    ret = inflateSync(&strm);                   assert(ret == Z_DATA_ERROR);\n+    ret = inflate(&strm, Z_NO_FLUSH);           assert(ret == Z_STREAM_ERROR);\n+    strm.avail_in = 4;\n+    strm.next_in = (void *)\"\\0\\0\\xff\\xff\";\n+    ret = inflateSync(&strm);                   assert(ret == Z_OK);\n+    (void)inflateSyncPoint(&strm);\n+    ret = inflateCopy(&copy, &strm);            assert(ret == Z_MEM_ERROR);\n+    mem_limit(&strm, 0);\n+    ret = inflateUndermine(&strm, 1);           assert(ret == Z_DATA_ERROR);\n+    (void)inflateMark(&strm);\n+    ret = inflateEnd(&strm);                    assert(ret == Z_OK);\n+    mem_done(&strm, \"miscellaneous, force memory errors\");\n+}\n+\n+/* input and output functions for inflateBack() */\n+local unsigned pull(void *desc, unsigned char **buf)\n+{\n+    static unsigned int next = 0;\n+    static unsigned char dat[] = {0x63, 0, 2, 0};\n+    struct inflate_state *state;\n+\n+    if (desc == Z_NULL) {\n+        next = 0;\n+        return 0;   /* no input (already provided at next_in) */\n+    }\n+    state = (void *)((z_stream *)desc)->state;\n+    if (state != Z_NULL)\n+        state->mode = SYNC;     /* force an otherwise impossible situation */\n+    return next < sizeof(dat) ? (*buf = dat + next++, 1) : 0;\n+}\n+\n+local int push(void *desc, unsigned char *buf, unsigned len)\n+{\n+    buf += len;\n+    return desc != Z_NULL;      /* force error if desc not null */\n+}\n+\n+/* cover inflateBack() up to common deflate data cases and after those */\n+local void cover_back(void)\n+{\n+    int ret;\n+    z_stream strm;\n+    unsigned char win[32768];\n+\n+    ret = inflateBackInit_(Z_NULL, 0, win, 0, 0);\n+                                                assert(ret == Z_VERSION_ERROR);\n+    ret = inflateBackInit(Z_NULL, 0, win);      assert(ret == Z_STREAM_ERROR);\n+    ret = inflateBack(Z_NULL, Z_NULL, Z_NULL, Z_NULL, Z_NULL);\n+                                                assert(ret == Z_STREAM_ERROR);\n+    ret = inflateBackEnd(Z_NULL);               assert(ret == Z_STREAM_ERROR);\n+    fputs(\"inflateBack bad parameters\\n\", stderr);\n+\n+    mem_setup(&strm);\n+    ret = inflateBackInit(&strm, 15, win);      assert(ret == Z_OK);\n+    strm.avail_in = 2;\n+    strm.next_in = (void *)\"\\x03\";\n+    ret = inflateBack(&strm, pull, Z_NULL, push, Z_NULL);\n+                                                assert(ret == Z_STREAM_END);\n+        /* force output error */\n+    strm.avail_in = 3;\n+    strm.next_in = (void *)\"\\x63\\x00\";\n+    ret = inflateBack(&strm, pull, Z_NULL, push, &strm);\n+                                                assert(ret == Z_BUF_ERROR);\n+        /* force mode error by mucking with state */\n+    ret = inflateBack(&strm, pull, &strm, push, Z_NULL);\n+                                                assert(ret == Z_STREAM_ERROR);\n+    ret = inflateBackEnd(&strm);                assert(ret == Z_OK);\n+    mem_done(&strm, \"inflateBack bad state\");\n+\n+    ret = inflateBackInit(&strm, 15, win);      assert(ret == Z_OK);\n+    ret = inflateBackEnd(&strm);                assert(ret == Z_OK);\n+    fputs(\"inflateBack built-in memory routines\\n\", stderr);\n+}\n+\n+/* do a raw inflate of data in hexadecimal with both inflate and inflateBack */\n+local int try(char *hex, char *id, int err)\n+{\n+    int ret;\n+    unsigned len, size;\n+    unsigned char *in, *out, *win;\n+    char *prefix;\n+    z_stream strm;\n+\n+    /* convert to hex */\n+    in = h2b(hex, &len);\n+    assert(in != NULL);\n+\n+    /* allocate work areas */\n+    size = len << 3;\n+    out = malloc(size);\n+    assert(out != NULL);\n+    win = malloc(32768);\n+    assert(win != NULL);\n+    prefix = malloc(strlen(id) + 6);\n+    assert(prefix != NULL);\n+\n+    /* first with inflate */\n+    strcpy(prefix, id);\n+    strcat(prefix, \"-late\");\n+    mem_setup(&strm);\n+    strm.avail_in = 0;\n+    strm.next_in = Z_NULL;\n+    ret = inflateInit2(&strm, err < 0 ? 47 : -15);\n+    assert(ret == Z_OK);\n+    strm.avail_in = len;\n+    strm.next_in = in;\n+    do {\n+        strm.avail_out = size;\n+        strm.next_out = out;\n+        ret = inflate(&strm, Z_TREES);\n+        assert(ret != Z_STREAM_ERROR && ret != Z_MEM_ERROR);\n+        if (ret == Z_DATA_ERROR || ret == Z_NEED_DICT)\n+            break;\n+    } while (strm.avail_in || strm.avail_out == 0);\n+    if (err) {\n+        assert(ret == Z_DATA_ERROR);\n+        assert(strcmp(id, strm.msg) == 0);\n+    }\n+    inflateEnd(&strm);\n+    mem_done(&strm, prefix);\n+\n+    /* then with inflateBack */\n+    if (err >= 0) {\n+        strcpy(prefix, id);\n+        strcat(prefix, \"-back\");\n+        mem_setup(&strm);\n+        ret = inflateBackInit(&strm, 15, win);\n+        assert(ret == Z_OK);\n+        strm.avail_in = len;\n+        strm.next_in = in;\n+        ret = inflateBack(&strm, pull, Z_NULL, push, Z_NULL);\n+        assert(ret != Z_STREAM_ERROR);\n+        if (err) {\n+            assert(ret == Z_DATA_ERROR);\n+            assert(strcmp(id, strm.msg) == 0);\n+        }\n+        inflateBackEnd(&strm);\n+        mem_done(&strm, prefix);\n+    }\n+\n+    /* clean up */\n+    free(prefix);\n+    free(win);\n+    free(out);\n+    free(in);\n+    return ret;\n+}\n+\n+/* cover deflate data cases in both inflate() and inflateBack() */\n+local void cover_inflate(void)\n+{\n+    try(\"0 0 0 0 0\", \"invalid stored block lengths\", 1);\n+    try(\"3 0\", \"fixed\", 0);\n+    try(\"6\", \"invalid block type\", 1);\n+    try(\"1 1 0 fe ff 0\", \"stored\", 0);\n+    try(\"fc 0 0\", \"too many length or distance symbols\", 1);\n+    try(\"4 0 fe ff\", \"invalid code lengths set\", 1);\n+    try(\"4 0 24 49 0\", \"invalid bit length repeat\", 1);\n+    try(\"4 0 24 e9 ff ff\", \"invalid bit length repeat\", 1);\n+    try(\"4 0 24 e9 ff 6d\", \"invalid code -- missing end-of-block\", 1);\n+    try(\"4 80 49 92 24 49 92 24 71 ff ff 93 11 0\",\n+        \"invalid literal/lengths set\", 1);\n+    try(\"4 80 49 92 24 49 92 24 f b4 ff ff c3 84\", \"invalid distances set\", 1);\n+    try(\"4 c0 81 8 0 0 0 0 20 7f eb b 0 0\", \"invalid literal/length code\", 1);\n+    try(\"2 7e ff ff\", \"invalid distance code\", 1);\n+    try(\"c c0 81 0 0 0 0 0 90 ff 6b 4 0\", \"invalid distance too far back\", 1);\n+\n+    /* also trailer mismatch just in inflate() */\n+    try(\"1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 1\", \"incorrect data check\", -1);\n+    try(\"1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 1\",\n+        \"incorrect length check\", -1);\n+    try(\"5 c0 21 d 0 0 0 80 b0 fe 6d 2f 91 6c\", \"pull 17\", 0);\n+    try(\"5 e0 81 91 24 cb b2 2c 49 e2 f 2e 8b 9a 47 56 9f fb fe ec d2 ff 1f\",\n+        \"long code\", 0);\n+    try(\"ed c0 1 1 0 0 0 40 20 ff 57 1b 42 2c 4f\", \"length extra\", 0);\n+    try(\"ed cf c1 b1 2c 47 10 c4 30 fa 6f 35 1d 1 82 59 3d fb be 2e 2a fc f c\",\n+        \"long distance and extra\", 0);\n+    try(\"ed c0 81 0 0 0 0 80 a0 fd a9 17 a9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \"\n+        \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6\", \"window end\", 0);\n+    inf(\"2 8 20 80 0 3 0\", \"inflate_fast TYPE return\", 0, -15, 258,\n+        Z_STREAM_END);\n+    inf(\"63 18 5 40 c 0\", \"window wrap\", 3, -8, 300, Z_OK);\n+}\n+\n+/* cover remaining lines in inftrees.c */\n+local void cover_trees(void)\n+{\n+    int ret;\n+    unsigned bits;\n+    unsigned short lens[16], work[16];\n+    code *next, table[ENOUGH_DISTS];\n+\n+    /* we need to call inflate_table() directly in order to manifest not-\n+       enough errors, since zlib insures that enough is always enough */\n+    for (bits = 0; bits < 15; bits++)\n+        lens[bits] = (unsigned short)(bits + 1);\n+    lens[15] = 15;\n+    next = table;\n+    bits = 15;\n+    ret = inflate_table(DISTS, lens, 16, &next, &bits, work);\n+                                                assert(ret == 1);\n+    next = table;\n+    bits = 1;\n+    ret = inflate_table(DISTS, lens, 16, &next, &bits, work);\n+                                                assert(ret == 1);\n+    fputs(\"inflate_table not enough errors\\n\", stderr);\n+}\n+\n+/* cover remaining inffast.c decoding and window copying */\n+local void cover_fast(void)\n+{\n+    inf(\"e5 e0 81 ad 6d cb b2 2c c9 01 1e 59 63 ae 7d ee fb 4d fd b5 35 41 68\"\n+        \" ff 7f 0f 0 0 0\", \"fast length extra bits\", 0, -8, 258, Z_DATA_ERROR);\n+    inf(\"25 fd 81 b5 6d 59 b6 6a 49 ea af 35 6 34 eb 8c b9 f6 b9 1e ef 67 49\"\n+        \" 50 fe ff ff 3f 0 0\", \"fast distance extra bits\", 0, -8, 258,\n+        Z_DATA_ERROR);\n+    inf(\"3 7e 0 0 0 0 0\", \"fast invalid distance code\", 0, -8, 258,\n+        Z_DATA_ERROR);\n+    inf(\"1b 7 0 0 0 0 0\", \"fast invalid literal/length code\", 0, -8, 258,\n+        Z_DATA_ERROR);\n+    inf(\"d c7 1 ae eb 38 c 4 41 a0 87 72 de df fb 1f b8 36 b1 38 5d ff ff 0\",\n+        \"fast 2nd level codes and too far back\", 0, -8, 258, Z_DATA_ERROR);\n+    inf(\"63 18 5 8c 10 8 0 0 0 0\", \"very common case\", 0, -8, 259, Z_OK);\n+    inf(\"63 60 60 18 c9 0 8 18 18 18 26 c0 28 0 29 0 0 0\",\n+        \"contiguous and wrap around window\", 6, -8, 259, Z_OK);\n+    inf(\"63 0 3 0 0 0 0 0\", \"copy direct from output\", 0, -8, 259,\n+        Z_STREAM_END);\n+}\n+\n+int main(void)\n+{\n+    fprintf(stderr, \"%s\\n\", zlibVersion());\n+    cover_support();\n+    cover_wrap();\n+    cover_back();\n+    cover_inflate();\n+    cover_trees();\n+    cover_fast();\n+    return 0;\n+}"}, {"sha": "aa7ac7a0494b3a926033cb0e2b8cdb9f8e578e17", "filename": "zlib/test/minigzip.c", "status": "added", "additions": 631, "deletions": 0, "changes": 631, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Ftest%2Fminigzip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Ftest%2Fminigzip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Ftest%2Fminigzip.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -0,0 +1,631 @@\n+/* minigzip.c -- simulate gzip using the zlib compression library\n+ * Copyright (C) 1995-2006, 2010, 2011 Jean-loup Gailly.\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+ */\n+\n+/*\n+ * minigzip is a minimal implementation of the gzip utility. This is\n+ * only an example of using zlib and isn't meant to replace the\n+ * full-featured gzip. No attempt is made to deal with file systems\n+ * limiting names to 14 or 8+3 characters, etc... Error checking is\n+ * very limited. So use minigzip only for testing; use gzip for the\n+ * real thing. On MSDOS, use only on file names without extension\n+ * or in pipe mode.\n+ */\n+\n+/* @(#) $Id$ */\n+\n+#include \"zlib.h\"\n+#include <stdio.h>\n+\n+#ifdef STDC\n+#  include <string.h>\n+#  include <stdlib.h>\n+#endif\n+\n+#ifdef USE_MMAP\n+#  include <sys/types.h>\n+#  include <sys/mman.h>\n+#  include <sys/stat.h>\n+#endif\n+\n+#if defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(__CYGWIN__)\n+#  include <fcntl.h>\n+#  include <io.h>\n+#  ifdef UNDER_CE\n+#    include <stdlib.h>\n+#  endif\n+#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)\n+#else\n+#  define SET_BINARY_MODE(file)\n+#endif\n+\n+#ifdef VMS\n+#  define unlink delete\n+#  define GZ_SUFFIX \"-gz\"\n+#endif\n+#ifdef RISCOS\n+#  define unlink remove\n+#  define GZ_SUFFIX \"-gz\"\n+#  define fileno(file) file->__file\n+#endif\n+#if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os\n+#  include <unix.h> /* for fileno */\n+#endif\n+\n+#if !defined(Z_HAVE_UNISTD_H) && !defined(_LARGEFILE64_SOURCE)\n+#ifndef WIN32 /* unlink already in stdio.h for WIN32 */\n+  extern int unlink OF((const char *));\n+#endif\n+#endif\n+\n+#if defined(UNDER_CE)\n+#  include <windows.h>\n+#  define perror(s) pwinerror(s)\n+\n+/* Map the Windows error number in ERROR to a locale-dependent error\n+   message string and return a pointer to it.  Typically, the values\n+   for ERROR come from GetLastError.\n+\n+   The string pointed to shall not be modified by the application,\n+   but may be overwritten by a subsequent call to strwinerror\n+\n+   The strwinerror function does not change the current setting\n+   of GetLastError.  */\n+\n+static char *strwinerror (error)\n+     DWORD error;\n+{\n+    static char buf[1024];\n+\n+    wchar_t *msgbuf;\n+    DWORD lasterr = GetLastError();\n+    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM\n+        | FORMAT_MESSAGE_ALLOCATE_BUFFER,\n+        NULL,\n+        error,\n+        0, /* Default language */\n+        (LPVOID)&msgbuf,\n+        0,\n+        NULL);\n+    if (chars != 0) {\n+        /* If there is an \\r\\n appended, zap it.  */\n+        if (chars >= 2\n+            && msgbuf[chars - 2] == '\\r' && msgbuf[chars - 1] == '\\n') {\n+            chars -= 2;\n+            msgbuf[chars] = 0;\n+        }\n+\n+        if (chars > sizeof (buf) - 1) {\n+            chars = sizeof (buf) - 1;\n+            msgbuf[chars] = 0;\n+        }\n+\n+        wcstombs(buf, msgbuf, chars + 1);\n+        LocalFree(msgbuf);\n+    }\n+    else {\n+        sprintf(buf, \"unknown win32 error (%ld)\", error);\n+    }\n+\n+    SetLastError(lasterr);\n+    return buf;\n+}\n+\n+static void pwinerror (s)\n+    const char *s;\n+{\n+    if (s && *s)\n+        fprintf(stderr, \"%s: %s\\n\", s, strwinerror(GetLastError ()));\n+    else\n+        fprintf(stderr, \"%s\\n\", strwinerror(GetLastError ()));\n+}\n+\n+#endif /* UNDER_CE */\n+\n+#ifndef GZ_SUFFIX\n+#  define GZ_SUFFIX \".gz\"\n+#endif\n+#define SUFFIX_LEN (sizeof(GZ_SUFFIX)-1)\n+\n+#define BUFLEN      16384\n+#define MAX_NAME_LEN 1024\n+\n+#ifdef MAXSEG_64K\n+#  define local static\n+   /* Needed for systems with limitation on stack size. */\n+#else\n+#  define local\n+#endif\n+\n+#ifdef Z_SOLO\n+/* for Z_SOLO, create simplified gz* functions using deflate and inflate */\n+\n+#if defined(Z_HAVE_UNISTD_H) || defined(Z_LARGE)\n+#  include <unistd.h>       /* for unlink() */\n+#endif\n+\n+void *myalloc OF((void *, unsigned, unsigned));\n+void myfree OF((void *, void *));\n+\n+void *myalloc(q, n, m)\n+    void *q;\n+    unsigned n, m;\n+{\n+    q = Z_NULL;\n+    return calloc(n, m);\n+}\n+\n+void myfree(q, p)\n+    void *q, *p;\n+{\n+    q = Z_NULL;\n+    free(p);\n+}\n+\n+typedef struct gzFile_s {\n+    FILE *file;\n+    int write;\n+    int err;\n+    char *msg;\n+    z_stream strm;\n+} *gzFile;\n+\n+gzFile gzopen OF((const char *, const char *));\n+gzFile gzdopen OF((int, const char *));\n+gzFile gz_open OF((const char *, int, const char *));\n+\n+gzFile gzopen(path, mode)\n+const char *path;\n+const char *mode;\n+{\n+    return gz_open(path, -1, mode);\n+}\n+\n+gzFile gzdopen(fd, mode)\n+int fd;\n+const char *mode;\n+{\n+    return gz_open(NULL, fd, mode);\n+}\n+\n+gzFile gz_open(path, fd, mode)\n+    const char *path;\n+    int fd;\n+    const char *mode;\n+{\n+    gzFile gz;\n+    int ret;\n+\n+    gz = malloc(sizeof(struct gzFile_s));\n+    if (gz == NULL)\n+        return NULL;\n+    gz->write = strchr(mode, 'w') != NULL;\n+    gz->strm.zalloc = myalloc;\n+    gz->strm.zfree = myfree;\n+    gz->strm.opaque = Z_NULL;\n+    if (gz->write)\n+        ret = deflateInit2(&(gz->strm), -1, 8, 15 + 16, 8, 0);\n+    else {\n+        gz->strm.next_in = 0;\n+        gz->strm.avail_in = Z_NULL;\n+        ret = inflateInit2(&(gz->strm), 15 + 16);\n+    }\n+    if (ret != Z_OK) {\n+        free(gz);\n+        return NULL;\n+    }\n+    gz->file = path == NULL ? fdopen(fd, gz->write ? \"wb\" : \"rb\") :\n+                              fopen(path, gz->write ? \"wb\" : \"rb\");\n+    if (gz->file == NULL) {\n+        gz->write ? deflateEnd(&(gz->strm)) : inflateEnd(&(gz->strm));\n+        free(gz);\n+        return NULL;\n+    }\n+    gz->err = 0;\n+    gz->msg = \"\";\n+    return gz;\n+}\n+\n+int gzwrite OF((gzFile, const void *, unsigned));\n+\n+int gzwrite(gz, buf, len)\n+    gzFile gz;\n+    const void *buf;\n+    unsigned len;\n+{\n+    z_stream *strm;\n+    unsigned char out[BUFLEN];\n+\n+    if (gz == NULL || !gz->write)\n+        return 0;\n+    strm = &(gz->strm);\n+    strm->next_in = (void *)buf;\n+    strm->avail_in = len;\n+    do {\n+        strm->next_out = out;\n+        strm->avail_out = BUFLEN;\n+        (void)deflate(strm, Z_NO_FLUSH);\n+        fwrite(out, 1, BUFLEN - strm->avail_out, gz->file);\n+    } while (strm->avail_out == 0);\n+    return len;\n+}\n+\n+int gzread OF((gzFile, void *, unsigned));\n+\n+int gzread(gz, buf, len)\n+    gzFile gz;\n+    void *buf;\n+    unsigned len;\n+{\n+    int ret;\n+    unsigned got;\n+    unsigned char in[1];\n+    z_stream *strm;\n+\n+    if (gz == NULL || gz->write)\n+        return 0;\n+    if (gz->err)\n+        return 0;\n+    strm = &(gz->strm);\n+    strm->next_out = (void *)buf;\n+    strm->avail_out = len;\n+    do {\n+        got = fread(in, 1, 1, gz->file);\n+        if (got == 0)\n+            break;\n+        strm->next_in = in;\n+        strm->avail_in = 1;\n+        ret = inflate(strm, Z_NO_FLUSH);\n+        if (ret == Z_DATA_ERROR) {\n+            gz->err = Z_DATA_ERROR;\n+            gz->msg = strm->msg;\n+            return 0;\n+        }\n+        if (ret == Z_STREAM_END)\n+            inflateReset(strm);\n+    } while (strm->avail_out);\n+    return len - strm->avail_out;\n+}\n+\n+int gzclose OF((gzFile));\n+\n+int gzclose(gz)\n+    gzFile gz;\n+{\n+    z_stream *strm;\n+    unsigned char out[BUFLEN];\n+\n+    if (gz == NULL)\n+        return Z_STREAM_ERROR;\n+    strm = &(gz->strm);\n+    if (gz->write) {\n+        strm->next_in = Z_NULL;\n+        strm->avail_in = 0;\n+        do {\n+            strm->next_out = out;\n+            strm->avail_out = BUFLEN;\n+            (void)deflate(strm, Z_FINISH);\n+            fwrite(out, 1, BUFLEN - strm->avail_out, gz->file);\n+        } while (strm->avail_out == 0);\n+        deflateEnd(strm);\n+    }\n+    else\n+        inflateEnd(strm);\n+    fclose(gz->file);\n+    free(gz);\n+    return Z_OK;\n+}\n+\n+const char *gzerror OF((gzFile, int *));\n+\n+const char *gzerror(gz, err)\n+    gzFile gz;\n+    int *err;\n+{\n+    *err = gz->err;\n+    return gz->msg;\n+}\n+\n+#endif\n+\n+char *prog;\n+\n+void error            OF((const char *msg));\n+void gz_compress      OF((FILE   *in, gzFile out));\n+#ifdef USE_MMAP\n+int  gz_compress_mmap OF((FILE   *in, gzFile out));\n+#endif\n+void gz_uncompress    OF((gzFile in, FILE   *out));\n+void file_compress    OF((char  *file, char *mode));\n+void file_uncompress  OF((char  *file));\n+int  main             OF((int argc, char *argv[]));\n+\n+/* ===========================================================================\n+ * Display error message and exit\n+ */\n+void error(msg)\n+    const char *msg;\n+{\n+    fprintf(stderr, \"%s: %s\\n\", prog, msg);\n+    exit(1);\n+}\n+\n+/* ===========================================================================\n+ * Compress input to output then close both files.\n+ */\n+\n+void gz_compress(in, out)\n+    FILE   *in;\n+    gzFile out;\n+{\n+    local char buf[BUFLEN];\n+    int len;\n+    int err;\n+\n+#ifdef USE_MMAP\n+    /* Try first compressing with mmap. If mmap fails (minigzip used in a\n+     * pipe), use the normal fread loop.\n+     */\n+    if (gz_compress_mmap(in, out) == Z_OK) return;\n+#endif\n+    for (;;) {\n+        len = (int)fread(buf, 1, sizeof(buf), in);\n+        if (ferror(in)) {\n+            perror(\"fread\");\n+            exit(1);\n+        }\n+        if (len == 0) break;\n+\n+        if (gzwrite(out, buf, (unsigned)len) != len) error(gzerror(out, &err));\n+    }\n+    fclose(in);\n+    if (gzclose(out) != Z_OK) error(\"failed gzclose\");\n+}\n+\n+#ifdef USE_MMAP /* MMAP version, Miguel Albrecht <malbrech@eso.org> */\n+\n+/* Try compressing the input file at once using mmap. Return Z_OK if\n+ * if success, Z_ERRNO otherwise.\n+ */\n+int gz_compress_mmap(in, out)\n+    FILE   *in;\n+    gzFile out;\n+{\n+    int len;\n+    int err;\n+    int ifd = fileno(in);\n+    caddr_t buf;    /* mmap'ed buffer for the entire input file */\n+    off_t buf_len;  /* length of the input file */\n+    struct stat sb;\n+\n+    /* Determine the size of the file, needed for mmap: */\n+    if (fstat(ifd, &sb) < 0) return Z_ERRNO;\n+    buf_len = sb.st_size;\n+    if (buf_len <= 0) return Z_ERRNO;\n+\n+    /* Now do the actual mmap: */\n+    buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t)0);\n+    if (buf == (caddr_t)(-1)) return Z_ERRNO;\n+\n+    /* Compress the whole file at once: */\n+    len = gzwrite(out, (char *)buf, (unsigned)buf_len);\n+\n+    if (len != (int)buf_len) error(gzerror(out, &err));\n+\n+    munmap(buf, buf_len);\n+    fclose(in);\n+    if (gzclose(out) != Z_OK) error(\"failed gzclose\");\n+    return Z_OK;\n+}\n+#endif /* USE_MMAP */\n+\n+/* ===========================================================================\n+ * Uncompress input to output then close both files.\n+ */\n+void gz_uncompress(in, out)\n+    gzFile in;\n+    FILE   *out;\n+{\n+    local char buf[BUFLEN];\n+    int len;\n+    int err;\n+\n+    for (;;) {\n+        len = gzread(in, buf, sizeof(buf));\n+        if (len < 0) error (gzerror(in, &err));\n+        if (len == 0) break;\n+\n+        if ((int)fwrite(buf, 1, (unsigned)len, out) != len) {\n+            error(\"failed fwrite\");\n+        }\n+    }\n+    if (fclose(out)) error(\"failed fclose\");\n+\n+    if (gzclose(in) != Z_OK) error(\"failed gzclose\");\n+}\n+\n+\n+/* ===========================================================================\n+ * Compress the given file: create a corresponding .gz file and remove the\n+ * original.\n+ */\n+void file_compress(file, mode)\n+    char  *file;\n+    char  *mode;\n+{\n+    local char outfile[MAX_NAME_LEN];\n+    FILE  *in;\n+    gzFile out;\n+\n+    if (strlen(file) + strlen(GZ_SUFFIX) >= sizeof(outfile)) {\n+        fprintf(stderr, \"%s: filename too long\\n\", prog);\n+        exit(1);\n+    }\n+\n+    strcpy(outfile, file);\n+    strcat(outfile, GZ_SUFFIX);\n+\n+    in = fopen(file, \"rb\");\n+    if (in == NULL) {\n+        perror(file);\n+        exit(1);\n+    }\n+    out = gzopen(outfile, mode);\n+    if (out == NULL) {\n+        fprintf(stderr, \"%s: can't gzopen %s\\n\", prog, outfile);\n+        exit(1);\n+    }\n+    gz_compress(in, out);\n+\n+    unlink(file);\n+}\n+\n+\n+/* ===========================================================================\n+ * Uncompress the given file and remove the original.\n+ */\n+void file_uncompress(file)\n+    char  *file;\n+{\n+    local char buf[MAX_NAME_LEN];\n+    char *infile, *outfile;\n+    FILE  *out;\n+    gzFile in;\n+    size_t len = strlen(file);\n+\n+    if (len + strlen(GZ_SUFFIX) >= sizeof(buf)) {\n+        fprintf(stderr, \"%s: filename too long\\n\", prog);\n+        exit(1);\n+    }\n+\n+    strcpy(buf, file);\n+\n+    if (len > SUFFIX_LEN && strcmp(file+len-SUFFIX_LEN, GZ_SUFFIX) == 0) {\n+        infile = file;\n+        outfile = buf;\n+        outfile[len-3] = '\\0';\n+    } else {\n+        outfile = file;\n+        infile = buf;\n+        strcat(infile, GZ_SUFFIX);\n+    }\n+    in = gzopen(infile, \"rb\");\n+    if (in == NULL) {\n+        fprintf(stderr, \"%s: can't gzopen %s\\n\", prog, infile);\n+        exit(1);\n+    }\n+    out = fopen(outfile, \"wb\");\n+    if (out == NULL) {\n+        perror(file);\n+        exit(1);\n+    }\n+\n+    gz_uncompress(in, out);\n+\n+    unlink(infile);\n+}\n+\n+\n+/* ===========================================================================\n+ * Usage:  minigzip [-c] [-d] [-f] [-h] [-r] [-1 to -9] [files...]\n+ *   -c : write to standard output\n+ *   -d : decompress\n+ *   -f : compress with Z_FILTERED\n+ *   -h : compress with Z_HUFFMAN_ONLY\n+ *   -r : compress with Z_RLE\n+ *   -1 to -9 : compression level\n+ */\n+\n+int main(argc, argv)\n+    int argc;\n+    char *argv[];\n+{\n+    int copyout = 0;\n+    int uncompr = 0;\n+    gzFile file;\n+    char *bname, outmode[20];\n+\n+    strcpy(outmode, \"wb6 \");\n+\n+    prog = argv[0];\n+    bname = strrchr(argv[0], '/');\n+    if (bname)\n+      bname++;\n+    else\n+      bname = argv[0];\n+    argc--, argv++;\n+\n+    if (!strcmp(bname, \"gunzip\"))\n+      uncompr = 1;\n+    else if (!strcmp(bname, \"zcat\"))\n+      copyout = uncompr = 1;\n+\n+    while (argc > 0) {\n+      if (strcmp(*argv, \"-c\") == 0)\n+        copyout = 1;\n+      else if (strcmp(*argv, \"-d\") == 0)\n+        uncompr = 1;\n+      else if (strcmp(*argv, \"-f\") == 0)\n+        outmode[3] = 'f';\n+      else if (strcmp(*argv, \"-h\") == 0)\n+        outmode[3] = 'h';\n+      else if (strcmp(*argv, \"-r\") == 0)\n+        outmode[3] = 'R';\n+      else if ((*argv)[0] == '-' && (*argv)[1] >= '1' && (*argv)[1] <= '9' &&\n+               (*argv)[2] == 0)\n+        outmode[2] = (*argv)[1];\n+      else\n+        break;\n+      argc--, argv++;\n+    }\n+    if (outmode[3] == ' ')\n+        outmode[3] = 0;\n+    if (argc == 0) {\n+        SET_BINARY_MODE(stdin);\n+        SET_BINARY_MODE(stdout);\n+        if (uncompr) {\n+            file = gzdopen(fileno(stdin), \"rb\");\n+            if (file == NULL) error(\"can't gzdopen stdin\");\n+            gz_uncompress(file, stdout);\n+        } else {\n+            file = gzdopen(fileno(stdout), outmode);\n+            if (file == NULL) error(\"can't gzdopen stdout\");\n+            gz_compress(stdin, file);\n+        }\n+    } else {\n+        if (copyout) {\n+            SET_BINARY_MODE(stdout);\n+        }\n+        do {\n+            if (uncompr) {\n+                if (copyout) {\n+                    file = gzopen(*argv, \"rb\");\n+                    if (file == NULL)\n+                        fprintf(stderr, \"%s: can't gzopen %s\\n\", prog, *argv);\n+                    else\n+                        gz_uncompress(file, stdout);\n+                } else {\n+                    file_uncompress(*argv);\n+                }\n+            } else {\n+                if (copyout) {\n+                    FILE * in = fopen(*argv, \"rb\");\n+\n+                    if (in == NULL) {\n+                        perror(*argv);\n+                    } else {\n+                        file = gzdopen(fileno(stdout), outmode);\n+                        if (file == NULL) error(\"can't gzdopen stdout\");\n+\n+                        gz_compress(in, file);\n+                    }\n+\n+                } else {\n+                    file_compress(*argv, outmode);\n+                }\n+            }\n+        } while (argv++, --argc);\n+    }\n+    return 0;\n+}"}, {"sha": "1f4d15f4e3835beb4c53b1c044020405e126da76", "filename": "zlib/treebuild.xml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Ftreebuild.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Ftreebuild.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Ftreebuild.xml?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,6 +1,6 @@\n <?xml version=\"1.0\" ?>\n-<package name=\"zlib\" version=\"1.2.5\">\n-    <library name=\"zlib\" dlversion=\"1.2.5\" dlname=\"z\">\n+<package name=\"zlib\" version=\"1.2.7\">\n+    <library name=\"zlib\" dlversion=\"1.2.7\" dlname=\"z\">\n \t<property name=\"description\"> zip compression library </property>\n \t<property name=\"include-target-dir\" value=\"$(@PACKAGE/install-includedir)\" />\n "}, {"sha": "cd0af2d032814d95c1e6c7d1d99496fe1e924baa", "filename": "zlib/trees.c", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Ftrees.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Ftrees.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Ftrees.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,5 +1,5 @@\n /* trees.c -- output deflated data using Huffman coding\n- * Copyright (C) 1995-2010 Jean-loup Gailly\n+ * Copyright (C) 1995-2012 Jean-loup Gailly\n  * detect_data_type() function provided freely by Cosmin Truta, 2006\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n@@ -74,11 +74,6 @@ local const uch bl_order[BL_CODES]\n  * probability, to avoid transmitting the lengths for unused bit length codes.\n  */\n \n-#define Buf_size (8 * 2*sizeof(char))\n-/* Number of bits used within bi_buf. (bi_buf might be implemented on\n- * more than 16 bits on some systems.)\n- */\n-\n /* ===========================================================================\n  * Local data. These are initialized only once.\n  */\n@@ -399,7 +394,6 @@ void ZLIB_INTERNAL _tr_init(s)\n \n     s->bi_buf = 0;\n     s->bi_valid = 0;\n-    s->last_eob_len = 8; /* enough lookahead for inflate */\n #ifdef DEBUG\n     s->compressed_len = 0L;\n     s->bits_sent = 0L;\n@@ -882,16 +876,18 @@ void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)\n     copy_block(s, buf, (unsigned)stored_len, 1); /* with header */\n }\n \n+/* ===========================================================================\n+ * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)\n+ */\n+void ZLIB_INTERNAL _tr_flush_bits(s)\n+    deflate_state *s;\n+{\n+    bi_flush(s);\n+}\n+\n /* ===========================================================================\n  * Send one empty static block to give enough lookahead for inflate.\n  * This takes 10 bits, of which 7 may remain in the bit buffer.\n- * The current inflate code requires 9 bits of lookahead. If the\n- * last two codes for the previous block (real code plus EOB) were coded\n- * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode\n- * the last real code. In this case we send two empty static blocks instead\n- * of one. (There are no problems if the previous block is stored or fixed.)\n- * To simplify the code, we assume the worst case of last real code encoded\n- * on one bit only.\n  */\n void ZLIB_INTERNAL _tr_align(s)\n     deflate_state *s;\n@@ -902,20 +898,6 @@ void ZLIB_INTERNAL _tr_align(s)\n     s->compressed_len += 10L; /* 3 for block type, 7 for EOB */\n #endif\n     bi_flush(s);\n-    /* Of the 10 bits for the empty block, we have already sent\n-     * (10 - bi_valid) bits. The lookahead for the last real code (before\n-     * the EOB of the previous block) was thus at least one plus the length\n-     * of the EOB plus what we have just sent of the empty static block.\n-     */\n-    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {\n-        send_bits(s, STATIC_TREES<<1, 3);\n-        send_code(s, END_BLOCK, static_ltree);\n-#ifdef DEBUG\n-        s->compressed_len += 10L;\n-#endif\n-        bi_flush(s);\n-    }\n-    s->last_eob_len = 7;\n }\n \n /* ===========================================================================\n@@ -1118,7 +1100,6 @@ local void compress_block(s, ltree, dtree)\n     } while (lx < s->last_lit);\n \n     send_code(s, END_BLOCK, ltree);\n-    s->last_eob_len = ltree[END_BLOCK].Len;\n }\n \n /* ===========================================================================\n@@ -1226,7 +1207,6 @@ local void copy_block(s, buf, len, header)\n     int      header;  /* true if block header must be written */\n {\n     bi_windup(s);        /* align on byte boundary */\n-    s->last_eob_len = 8; /* enough lookahead for inflate */\n \n     if (header) {\n         put_short(s, (ush)len);"}, {"sha": "d152bbb7ffd95161a8b400d2de87e49346a9a0c4", "filename": "zlib/win32/Makefile.bor", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fwin32%2FMakefile.bor", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fwin32%2FMakefile.bor", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fwin32%2FMakefile.bor?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -74,9 +74,9 @@ uncompr.obj: uncompr.c zlib.h zconf.h\n \n zutil.obj: zutil.c zutil.h zlib.h zconf.h\n \n-example.obj: example.c zlib.h zconf.h\n+example.obj: test/example.c zlib.h zconf.h\n \n-minigzip.obj: minigzip.c zlib.h zconf.h\n+minigzip.obj: test/minigzip.c zlib.h zconf.h\n \n \n # For the sake of the old Borland make,"}, {"sha": "6d1ded622bf0080a120868df69e49971b7174006", "filename": "zlib/win32/Makefile.gcc", "status": "modified", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fwin32%2FMakefile.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fwin32%2FMakefile.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fwin32%2FMakefile.gcc?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,31 +1,37 @@\n # Makefile for zlib, derived from Makefile.dj2.\n # Modified for mingw32 by C. Spieler, 6/16/98.\n # Updated for zlib 1.2.x by Christian Spieler and Cosmin Truta, Mar-2003.\n-# Last updated: 1-Aug-2003.\n+# Last updated: Mar 2012.\n # Tested under Cygwin and MinGW.\n \n # Copyright (C) 1995-2003 Jean-loup Gailly.\n # For conditions of distribution and use, see copyright notice in zlib.h\n \n-# To compile, or to compile and test, type:\n+# To compile, or to compile and test, type from the top level zlib directory:\n #\n-#   make -fmakefile.gcc;  make test testdll -fmakefile.gcc\n+#   make -fwin32/Makefile.gcc;  make test testdll -fwin32/Makefile.gcc\n #\n # To use the asm code, type:\n #   cp contrib/asm?86/match.S ./match.S\n-#   make LOC=-DASMV OBJA=match.o -fmakefile.gcc\n+#   make LOC=-DASMV OBJA=match.o -fwin32/Makefile.gcc\n #\n # To install libz.a, zconf.h and zlib.h in the system directories, type:\n #\n-#   make install -fmakefile.gcc\n+#   make install -fwin32/Makefile.gcc\n+#\n+# BINARY_PATH, INCLUDE_PATH and LIBRARY_PATH must be set.\n+#\n+# To install the shared lib, append SHARED_MODE=1 to the make command :\n+#\n+#   make install -fwin32/Makefile.gcc SHARED_MODE=1\n \n # Note:\n # If the platform is *not* MinGW (e.g. it is Cygwin or UWIN),\n # the DLL name should be changed from \"zlib1.dll\".\n \n STATICLIB = libz.a\n SHAREDLIB = zlib1.dll\n-IMPLIB    = libzdll.a\n+IMPLIB    = libz.dll.a\n \n #\n # Set to 1 if shared object needs to be installed\n@@ -38,7 +44,6 @@ SHARED_MODE=0\n PREFIX =\n CC = $(PREFIX)gcc\n CFLAGS = $(LOC) -O3 -Wall\n-EXTRA_CFLAGS = -DNO_VIZ\n \n AS = $(CC)\n ASFLAGS = $(LOC) -Wall\n@@ -59,7 +64,7 @@ CP = cp -fp\n INSTALL = $(CP)\n RM = rm -f\n \n-prefix = /usr/local\n+prefix ?= /usr/local\n exec_prefix = $(prefix)\n \n OBJS = adler32.o compress.o crc32.o deflate.o gzclose.o gzlib.o gzread.o \\\n@@ -77,7 +82,7 @@ testdll: example_d.exe minigzip_d.exe\n \techo hello world | ./minigzip_d | ./minigzip_d -d\n \n .c.o:\n-\t$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c -o $@ $<\n+\t$(CC) $(CFLAGS) -c -o $@ $<\n \n .S.o:\n \t$(AS) $(ASFLAGS) -c -o $@ $<\n@@ -108,34 +113,49 @@ minigzip_d.exe: minigzip.o $(IMPLIB)\n \t$(LD) $(LDFLAGS) -o $@ minigzip.o $(IMPLIB)\n \t$(STRIP) $@\n \n-zlibrc.o: win32/zlib1.rc\n-\t$(RC) $(RCFLAGS) -o $@ win32/zlib1.rc\n+example.o: test/example.c zlib.h zconf.h\n+\t$(CC) $(CFLAGS) -I. -c -o $@ test/example.c\n \n+minigzip.o: test/minigzip.c zlib.h zconf.h\n+\t$(CC) $(CFLAGS) -I. -c -o $@ test/minigzip.c\n \n-# BINARY_PATH, INCLUDE_PATH and LIBRARY_PATH must be set.\n+zlibrc.o: win32/zlib1.rc\n+\t$(RC) $(RCFLAGS) -o $@ win32/zlib1.rc\n \n .PHONY: install uninstall clean\n \n install: zlib.h zconf.h $(STATICLIB) $(IMPLIB)\n-\t-@mkdir -p $(INCLUDE_PATH)\n-\t-@mkdir -p $(LIBRARY_PATH)\n+\t@if test -z \"$(DESTDIR)$(INCLUDE_PATH)\" -o -z \"$(DESTDIR)$(LIBRARY_PATH)\" -o -z \"$(DESTDIR)$(BINARY_PATH)\"; then \\\n+\t\techo INCLUDE_PATH, LIBRARY_PATH, and BINARY_PATH must be specified; \\\n+\t\texit 1; \\\n+\tfi\n+\t-@mkdir -p '$(DESTDIR)$(INCLUDE_PATH)'\n+\t-@mkdir -p '$(DESTDIR)$(LIBRARY_PATH)' '$(DESTDIR)$(LIBRARY_PATH)'/pkgconfig\n \t-if [ \"$(SHARED_MODE)\" = \"1\" ]; then \\\n-\t\tmkdir -p $(BINARY_PATH); \\\n-\t\t$(INSTALL) $(SHAREDLIB) $(BINARY_PATH); \\\n-\t\t$(INSTALL) $(IMPLIB) $(LIBRARY_PATH); \\\n+\t\tmkdir -p '$(DESTDIR)$(BINARY_PATH)'; \\\n+\t\t$(INSTALL) $(SHAREDLIB) '$(DESTDIR)$(BINARY_PATH)'; \\\n+\t\t$(INSTALL) $(IMPLIB) '$(DESTDIR)$(LIBRARY_PATH)'; \\\n \tfi\n-\t-$(INSTALL) zlib.h $(INCLUDE_PATH)\n-\t-$(INSTALL) zconf.h $(INCLUDE_PATH)\n-\t-$(INSTALL) $(STATICLIB) $(LIBRARY_PATH)\n+\t-$(INSTALL) zlib.h '$(DESTDIR)$(INCLUDE_PATH)'\n+\t-$(INSTALL) zconf.h '$(DESTDIR)$(INCLUDE_PATH)'\n+\t-$(INSTALL) $(STATICLIB) '$(DESTDIR)$(LIBRARY_PATH)'\n+\tsed \\\n+\t\t-e 's|@prefix@|${prefix}|g' \\\n+\t\t-e 's|@exec_prefix@|${exec_prefix}|g' \\\n+\t\t-e 's|@libdir@|$(LIBRARY_PATH)|g' \\\n+\t\t-e 's|@sharedlibdir@|$(LIBRARY_PATH)|g' \\\n+\t\t-e 's|@includedir@|$(INCLUDE_PATH)|g' \\\n+\t\t-e 's|@VERSION@|'`sed -n -e '/VERSION \"/s/.*\"\\(.*\\)\".*/\\1/p' zlib.h`'|g' \\\n+\t\tzlib.pc.in > '$(DESTDIR)$(LIBRARY_PATH)'/pkgconfig/zlib.pc\n \n uninstall:\n \t-if [ \"$(SHARED_MODE)\" = \"1\" ]; then \\\n-\t\t$(RM) $(BINARY_PATH)/$(SHAREDLIB); \\\n-\t\t$(RM) $(LIBRARY_PATH)/$(IMPLIB); \\\n+\t\t$(RM) '$(DESTDIR)$(BINARY_PATH)'/$(SHAREDLIB); \\\n+\t\t$(RM) '$(DESTDIR)$(LIBRARY_PATH)'/$(IMPLIB); \\\n \tfi\n-\t-$(RM) $(INCLUDE_PATH)/zlib.h\n-\t-$(RM) $(INCLUDE_PATH)/zconf.h\n-\t-$(RM) $(LIBRARY_PATH)/$(STATICLIB)\n+\t-$(RM) '$(DESTDIR)$(INCLUDE_PATH)'/zlib.h\n+\t-$(RM) '$(DESTDIR)$(INCLUDE_PATH)'/zconf.h\n+\t-$(RM) '$(DESTDIR)$(LIBRARY_PATH)'/$(STATICLIB)\n \n clean:\n \t-$(RM) $(STATICLIB)\n@@ -149,7 +169,6 @@ adler32.o: zlib.h zconf.h\n compress.o: zlib.h zconf.h\n crc32.o: crc32.h zlib.h zconf.h\n deflate.o: deflate.h zutil.h zlib.h zconf.h\n-example.o: zlib.h zconf.h\n gzclose.o: zlib.h zconf.h gzguts.h\n gzlib.o: zlib.h zconf.h gzguts.h\n gzread.o: zlib.h zconf.h gzguts.h\n@@ -158,7 +177,6 @@ inffast.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h\n inflate.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h\n infback.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h\n inftrees.o: zutil.h zlib.h zconf.h inftrees.h\n-minigzip.o: zlib.h zconf.h\n trees.o: deflate.h zutil.h zlib.h zconf.h trees.h\n uncompr.o: zlib.h zconf.h\n zutil.o: zutil.h zlib.h zconf.h"}, {"sha": "59bb0dae5d23c8355e0d5480ace6230bdeb63c8f", "filename": "zlib/win32/Makefile.msc", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fwin32%2FMakefile.msc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fwin32%2FMakefile.msc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fwin32%2FMakefile.msc?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -6,8 +6,8 @@\n #   nmake -f win32/Makefile.msc LOC=-DFOO                (nonstandard build)\n #   nmake -f win32/Makefile.msc LOC=\"-DASMV -DASMINF\" \\\n #         OBJA=\"inffas32.obj match686.obj\"               (use ASM code, x86)\n-#   nmake -f win32/Makefile.msc AS=ml64 LOC=\"-DASMV -DASMINF\" \\\n-#         OBJA=\"inffasx64.obj gvmat64.obj inffas8664.c\"  (use ASM code, x64)\n+#   nmake -f win32/Makefile.msc AS=ml64 LOC=\"-DASMV -DASMINF -I.\" \\\n+#         OBJA=\"inffasx64.obj gvmat64.obj inffas8664.obj\"  (use ASM code, x64)\n \n # optional build flags\n LOC =\n@@ -30,7 +30,7 @@ ARFLAGS = -nologo\n RCFLAGS = /dWIN32 /r\n \n OBJS = adler32.obj compress.obj crc32.obj deflate.obj gzclose.obj gzlib.obj gzread.obj \\\n-       gzwrite.obj infback.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj\n+       gzwrite.obj infback.obj inflate.obj inftrees.obj inffast.obj trees.obj uncompr.obj zutil.obj\n OBJA =\n \n \n@@ -72,6 +72,9 @@ minigzip_d.exe: minigzip.obj $(IMPLIB)\n .c.obj:\n \t$(CC) -c $(WFLAGS) $(CFLAGS) $<\n \n+{test}.c.obj:\n+\t$(CC) -c -I. $(WFLAGS) $(CFLAGS) $<\n+\n {contrib/masmx64}.c.obj:\n \t$(CC) -c $(WFLAGS) $(CFLAGS) $<\n \n@@ -125,9 +128,9 @@ inffas32.obj: contrib\\masmx86\\inffas32.asm\n \n match686.obj: contrib\\masmx86\\match686.asm\n \n-example.obj: example.c zlib.h zconf.h\n+example.obj: test/example.c zlib.h zconf.h\n \n-minigzip.obj: minigzip.c zlib.h zconf.h\n+minigzip.obj: test/minigzip.c zlib.h zconf.h\n \n zlib1.res: win32/zlib1.rc\n \t$(RC) $(RCFLAGS) /fo$@ win32/zlib1.rc"}, {"sha": "46c5923c4c6b0aaeb6b453e6aae651454860440b", "filename": "zlib/win32/README-WIN32.txt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fwin32%2FREADME-WIN32.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fwin32%2FREADME-WIN32.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fwin32%2FREADME-WIN32.txt?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,6 +1,6 @@\n ZLIB DATA COMPRESSION LIBRARY\n \n-zlib 1.2.4 is a general purpose data compression library.  All the code is\n+zlib 1.2.7 is a general purpose data compression library.  All the code is\n thread safe.  The data format used by the zlib library is described by RFCs\n (Request for Comments) 1950 to 1952 in the files\n http://www.ietf.org/rfc/rfc1950.txt (zlib format), rfc1951.txt (deflate format)\n@@ -22,7 +22,7 @@ before asking for help.\n \n Manifest:\n \n-The package zlib-1.2.4-win32-x86.zip contains the following files:\n+The package zlib-1.2.7-win32-x86.zip will contain the following files:\n \n   README-WIN32.txt This document\n   ChangeLog        Changes since previous zlib packages\n@@ -58,7 +58,7 @@ The package zlib-1.2.4-win32-x86.zip contains the following files:\n \n All .pdb files above are entirely optional, but are very useful to a developer\n attempting to diagnose program misbehavior or a crash.  Many additional\n-important files for developers can be found in the zlib124.zip source package\n+important files for developers can be found in the zlib127.zip source package\n available from http://zlib.net/ - review that package's README file for details.\n \n \n@@ -72,7 +72,7 @@ are too numerous to cite here.\n \n Copyright notice:\n \n-  (C) 1995-2010 Jean-loup Gailly and Mark Adler\n+  (C) 1995-2012 Jean-loup Gailly and Mark Adler\n \n   This software is provided 'as-is', without any express or implied\n   warranty.  In no event will the authors be held liable for any damages"}, {"sha": "04896150e4b7e41a9156e44590835894d2dfc2a3", "filename": "zlib/win32/zlib.def", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fwin32%2Fzlib.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fwin32%2Fzlib.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fwin32%2Fzlib.def?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,6 +1,4 @@\n-LIBRARY\n ; zlib data compression library\n-\n EXPORTS\n ; basic functions\n     zlibVersion\n@@ -15,6 +13,7 @@ EXPORTS\n     deflateParams\n     deflateTune\n     deflateBound\n+    deflatePending\n     deflatePrime\n     deflateSetHeader\n     inflateSetDictionary\n@@ -57,6 +56,13 @@ EXPORTS\n     gzclose_w\n     gzerror\n     gzclearerr\n+; large file functions\n+    gzopen64\n+    gzseek64\n+    gztell64\n+    gzoffset64\n+    adler32_combine64\n+    crc32_combine64\n ; checksum functions\n     adler32\n     crc32\n@@ -68,7 +74,11 @@ EXPORTS\n     inflateInit_\n     inflateInit2_\n     inflateBackInit_\n+    gzgetc_\n     zError\n     inflateSyncPoint\n     get_crc_table\n     inflateUndermine\n+    inflateResetKeep\n+    deflateResetKeep\n+    gzopen_w"}, {"sha": "18dcee1cbe73575ff77979cba27d045e12aa1bee", "filename": "zlib/zconf.h", "status": "modified", "additions": 137, "deletions": 59, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzconf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzconf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzconf.h?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,5 +1,5 @@\n /* zconf.h -- configuration of the zlib compression library\n- * Copyright (C) 1995-2010 Jean-loup Gailly.\n+ * Copyright (C) 1995-2012 Jean-loup Gailly.\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -15,6 +15,7 @@\n  * this permanently in zconf.h using \"./configure --zprefix\".\n  */\n #ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */\n+#  define Z_PREFIX_SET\n \n /* all linked symbols */\n #  define _dist_code            z__dist_code\n@@ -27,9 +28,11 @@\n #  define adler32               z_adler32\n #  define adler32_combine       z_adler32_combine\n #  define adler32_combine64     z_adler32_combine64\n-#  define compress              z_compress\n-#  define compress2             z_compress2\n-#  define compressBound         z_compressBound\n+#  ifndef Z_SOLO\n+#    define compress              z_compress\n+#    define compress2             z_compress2\n+#    define compressBound         z_compressBound\n+#  endif\n #  define crc32                 z_crc32\n #  define crc32_combine         z_crc32_combine\n #  define crc32_combine64       z_crc32_combine64\n@@ -40,44 +43,52 @@\n #  define deflateInit2_         z_deflateInit2_\n #  define deflateInit_          z_deflateInit_\n #  define deflateParams         z_deflateParams\n+#  define deflatePending        z_deflatePending\n #  define deflatePrime          z_deflatePrime\n #  define deflateReset          z_deflateReset\n+#  define deflateResetKeep      z_deflateResetKeep\n #  define deflateSetDictionary  z_deflateSetDictionary\n #  define deflateSetHeader      z_deflateSetHeader\n #  define deflateTune           z_deflateTune\n #  define deflate_copyright     z_deflate_copyright\n #  define get_crc_table         z_get_crc_table\n-#  define gz_error              z_gz_error\n-#  define gz_intmax             z_gz_intmax\n-#  define gz_strwinerror        z_gz_strwinerror\n-#  define gzbuffer              z_gzbuffer\n-#  define gzclearerr            z_gzclearerr\n-#  define gzclose               z_gzclose\n-#  define gzclose_r             z_gzclose_r\n-#  define gzclose_w             z_gzclose_w\n-#  define gzdirect              z_gzdirect\n-#  define gzdopen               z_gzdopen\n-#  define gzeof                 z_gzeof\n-#  define gzerror               z_gzerror\n-#  define gzflush               z_gzflush\n-#  define gzgetc                z_gzgetc\n-#  define gzgets                z_gzgets\n-#  define gzoffset              z_gzoffset\n-#  define gzoffset64            z_gzoffset64\n-#  define gzopen                z_gzopen\n-#  define gzopen64              z_gzopen64\n-#  define gzprintf              z_gzprintf\n-#  define gzputc                z_gzputc\n-#  define gzputs                z_gzputs\n-#  define gzread                z_gzread\n-#  define gzrewind              z_gzrewind\n-#  define gzseek                z_gzseek\n-#  define gzseek64              z_gzseek64\n-#  define gzsetparams           z_gzsetparams\n-#  define gztell                z_gztell\n-#  define gztell64              z_gztell64\n-#  define gzungetc              z_gzungetc\n-#  define gzwrite               z_gzwrite\n+#  ifndef Z_SOLO\n+#    define gz_error              z_gz_error\n+#    define gz_intmax             z_gz_intmax\n+#    define gz_strwinerror        z_gz_strwinerror\n+#    define gzbuffer              z_gzbuffer\n+#    define gzclearerr            z_gzclearerr\n+#    define gzclose               z_gzclose\n+#    define gzclose_r             z_gzclose_r\n+#    define gzclose_w             z_gzclose_w\n+#    define gzdirect              z_gzdirect\n+#    define gzdopen               z_gzdopen\n+#    define gzeof                 z_gzeof\n+#    define gzerror               z_gzerror\n+#    define gzflush               z_gzflush\n+#    define gzgetc                z_gzgetc\n+#    define gzgetc_               z_gzgetc_\n+#    define gzgets                z_gzgets\n+#    define gzoffset              z_gzoffset\n+#    define gzoffset64            z_gzoffset64\n+#    define gzopen                z_gzopen\n+#    define gzopen64              z_gzopen64\n+#    ifdef _WIN32\n+#      define gzopen_w              z_gzopen_w\n+#    endif\n+#    define gzprintf              z_gzprintf\n+#    define gzputc                z_gzputc\n+#    define gzputs                z_gzputs\n+#    define gzread                z_gzread\n+#    define gzrewind              z_gzrewind\n+#    define gzseek                z_gzseek\n+#    define gzseek64              z_gzseek64\n+#    define gzsetparams           z_gzsetparams\n+#    define gztell                z_gztell\n+#    define gztell64              z_gztell64\n+#    define gzungetc              z_gzungetc\n+#    define gzwrite               z_gzwrite\n+#  endif\n #  define inflate               z_inflate\n #  define inflateBack           z_inflateBack\n #  define inflateBackEnd        z_inflateBackEnd\n@@ -95,13 +106,18 @@\n #  define inflateSync           z_inflateSync\n #  define inflateSyncPoint      z_inflateSyncPoint\n #  define inflateUndermine      z_inflateUndermine\n+#  define inflateResetKeep      z_inflateResetKeep\n #  define inflate_copyright     z_inflate_copyright\n #  define inflate_fast          z_inflate_fast\n #  define inflate_table         z_inflate_table\n-#  define uncompress            z_uncompress\n+#  ifndef Z_SOLO\n+#    define uncompress            z_uncompress\n+#  endif\n #  define zError                z_zError\n-#  define zcalloc               z_zcalloc\n-#  define zcfree                z_zcfree\n+#  ifndef Z_SOLO\n+#    define zcalloc               z_zcalloc\n+#    define zcfree                z_zcfree\n+#  endif\n #  define zlibCompileFlags      z_zlibCompileFlags\n #  define zlibVersion           z_zlibVersion\n \n@@ -111,7 +127,9 @@\n #  define alloc_func            z_alloc_func\n #  define charf                 z_charf\n #  define free_func             z_free_func\n-#  define gzFile                z_gzFile\n+#  ifndef Z_SOLO\n+#    define gzFile                z_gzFile\n+#  endif\n #  define gz_header             z_gz_header\n #  define gz_headerp            z_gz_headerp\n #  define in_func               z_in_func\n@@ -197,6 +215,12 @@\n #  endif\n #endif\n \n+#if defined(ZLIB_CONST) && !defined(z_const)\n+#  define z_const const\n+#else\n+#  define z_const\n+#endif\n+\n /* Some Mac compilers merge all .h files incorrectly: */\n #if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)\n #  define NO_DUMMY_DECL\n@@ -243,6 +267,14 @@\n #  endif\n #endif\n \n+#ifndef Z_ARG /* function prototypes for stdarg */\n+#  if defined(STDC) || defined(Z_HAVE_STDARG_H)\n+#    define Z_ARG(args)  args\n+#  else\n+#    define Z_ARG(args)  ()\n+#  endif\n+#endif\n+\n /* The following definitions for FAR are needed only for MSDOS mixed\n  * model programming (small or medium model with some far allocations).\n  * This was tested only with MSC; for other MSDOS compilers you may have\n@@ -356,12 +388,45 @@ typedef uLong FAR uLongf;\n    typedef Byte       *voidp;\n #endif\n \n+/* ./configure may #define Z_U4 here */\n+\n+#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)\n+#  include <limits.h>\n+#  if (UINT_MAX == 0xffffffffUL)\n+#    define Z_U4 unsigned\n+#  else\n+#    if (ULONG_MAX == 0xffffffffUL)\n+#      define Z_U4 unsigned long\n+#    else\n+#      if (USHRT_MAX == 0xffffffffUL)\n+#        define Z_U4 unsigned short\n+#      endif\n+#    endif\n+#  endif\n+#endif\n+\n+#ifdef Z_U4\n+   typedef Z_U4 z_crc_t;\n+#else\n+   typedef unsigned long z_crc_t;\n+#endif\n+\n #ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */\n #  define Z_HAVE_UNISTD_H\n #endif\n \n+#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */\n+#  define Z_HAVE_STDARG_H\n+#endif\n+\n #ifdef STDC\n-#  include <sys/types.h>    /* for off_t */\n+#  ifndef Z_SOLO\n+#    include <sys/types.h>      /* for off_t */\n+#  endif\n+#endif\n+\n+#ifdef _WIN32\n+#  include <stddef.h>           /* for wchar_t */\n #endif\n \n /* a little trick to accommodate both \"#define _LARGEFILE64_SOURCE\" and\n@@ -370,21 +435,38 @@ typedef uLong FAR uLongf;\n  * both \"#undef _LARGEFILE64_SOURCE\" and \"#define _LARGEFILE64_SOURCE 0\" as\n  * equivalently requesting no 64-bit operations\n  */\n-#if -_LARGEFILE64_SOURCE - -1 == 1\n+#if defined(LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1\n #  undef _LARGEFILE64_SOURCE\n #endif\n \n-#if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)\n-#  include <unistd.h>       /* for SEEK_* and off_t */\n-#  ifdef VMS\n-#    include <unixio.h>     /* for off_t */\n-#  endif\n-#  ifndef z_off_t\n-#    define z_off_t off_t\n+#if defined(__WATCOMC__) && !defined(Z_HAVE_UNISTD_H)\n+#  define Z_HAVE_UNISTD_H\n+#endif\n+#ifndef Z_SOLO\n+#  if defined(Z_HAVE_UNISTD_H) || defined(LARGEFILE64_SOURCE)\n+#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */\n+#    ifdef VMS\n+#      include <unixio.h>       /* for off_t */\n+#    endif\n+#    ifndef z_off_t\n+#      define z_off_t off_t\n+#    endif\n #  endif\n #endif\n \n-#ifndef SEEK_SET\n+#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0\n+#  define Z_LFS64\n+#endif\n+\n+#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)\n+#  define Z_LARGE64\n+#endif\n+\n+#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)\n+#  define Z_WANT64\n+#endif\n+\n+#if !defined(SEEK_SET) && !defined(Z_SOLO)\n #  define SEEK_SET        0       /* Seek from beginning of file.  */\n #  define SEEK_CUR        1       /* Seek from current position.  */\n #  define SEEK_END        2       /* Set file pointer to EOF plus \"offset\" */\n@@ -394,18 +476,14 @@ typedef uLong FAR uLongf;\n #  define z_off_t long\n #endif\n \n-#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0\n+#if !defined(_WIN32) && defined(Z_LARGE64)\n #  define z_off64_t off64_t\n #else\n-#  define z_off64_t z_off_t\n-#endif\n-\n-#if defined(__OS400__)\n-#  define NO_vsnprintf\n-#endif\n-\n-#if defined(__MVS__)\n-#  define NO_vsnprintf\n+#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)\n+#    define z_off64_t __int64\n+#  else\n+#    define z_off64_t z_off_t\n+#  endif\n #endif\n \n /* MVS linker does not support external names larger than 8 bytes */"}, {"sha": "b6ca59ab4270d48d918ff65195e2188a99e736c7", "filename": "zlib/zconf.h.cmakein", "status": "modified", "additions": 137, "deletions": 59, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzconf.h.cmakein", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzconf.h.cmakein", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzconf.h.cmakein?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,5 +1,5 @@\n /* zconf.h -- configuration of the zlib compression library\n- * Copyright (C) 1995-2010 Jean-loup Gailly.\n+ * Copyright (C) 1995-2012 Jean-loup Gailly.\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -17,6 +17,7 @@\n  * this permanently in zconf.h using \"./configure --zprefix\".\n  */\n #ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */\n+#  define Z_PREFIX_SET\n \n /* all linked symbols */\n #  define _dist_code            z__dist_code\n@@ -29,9 +30,11 @@\n #  define adler32               z_adler32\n #  define adler32_combine       z_adler32_combine\n #  define adler32_combine64     z_adler32_combine64\n-#  define compress              z_compress\n-#  define compress2             z_compress2\n-#  define compressBound         z_compressBound\n+#  ifndef Z_SOLO\n+#    define compress              z_compress\n+#    define compress2             z_compress2\n+#    define compressBound         z_compressBound\n+#  endif\n #  define crc32                 z_crc32\n #  define crc32_combine         z_crc32_combine\n #  define crc32_combine64       z_crc32_combine64\n@@ -42,44 +45,52 @@\n #  define deflateInit2_         z_deflateInit2_\n #  define deflateInit_          z_deflateInit_\n #  define deflateParams         z_deflateParams\n+#  define deflatePending        z_deflatePending\n #  define deflatePrime          z_deflatePrime\n #  define deflateReset          z_deflateReset\n+#  define deflateResetKeep      z_deflateResetKeep\n #  define deflateSetDictionary  z_deflateSetDictionary\n #  define deflateSetHeader      z_deflateSetHeader\n #  define deflateTune           z_deflateTune\n #  define deflate_copyright     z_deflate_copyright\n #  define get_crc_table         z_get_crc_table\n-#  define gz_error              z_gz_error\n-#  define gz_intmax             z_gz_intmax\n-#  define gz_strwinerror        z_gz_strwinerror\n-#  define gzbuffer              z_gzbuffer\n-#  define gzclearerr            z_gzclearerr\n-#  define gzclose               z_gzclose\n-#  define gzclose_r             z_gzclose_r\n-#  define gzclose_w             z_gzclose_w\n-#  define gzdirect              z_gzdirect\n-#  define gzdopen               z_gzdopen\n-#  define gzeof                 z_gzeof\n-#  define gzerror               z_gzerror\n-#  define gzflush               z_gzflush\n-#  define gzgetc                z_gzgetc\n-#  define gzgets                z_gzgets\n-#  define gzoffset              z_gzoffset\n-#  define gzoffset64            z_gzoffset64\n-#  define gzopen                z_gzopen\n-#  define gzopen64              z_gzopen64\n-#  define gzprintf              z_gzprintf\n-#  define gzputc                z_gzputc\n-#  define gzputs                z_gzputs\n-#  define gzread                z_gzread\n-#  define gzrewind              z_gzrewind\n-#  define gzseek                z_gzseek\n-#  define gzseek64              z_gzseek64\n-#  define gzsetparams           z_gzsetparams\n-#  define gztell                z_gztell\n-#  define gztell64              z_gztell64\n-#  define gzungetc              z_gzungetc\n-#  define gzwrite               z_gzwrite\n+#  ifndef Z_SOLO\n+#    define gz_error              z_gz_error\n+#    define gz_intmax             z_gz_intmax\n+#    define gz_strwinerror        z_gz_strwinerror\n+#    define gzbuffer              z_gzbuffer\n+#    define gzclearerr            z_gzclearerr\n+#    define gzclose               z_gzclose\n+#    define gzclose_r             z_gzclose_r\n+#    define gzclose_w             z_gzclose_w\n+#    define gzdirect              z_gzdirect\n+#    define gzdopen               z_gzdopen\n+#    define gzeof                 z_gzeof\n+#    define gzerror               z_gzerror\n+#    define gzflush               z_gzflush\n+#    define gzgetc                z_gzgetc\n+#    define gzgetc_               z_gzgetc_\n+#    define gzgets                z_gzgets\n+#    define gzoffset              z_gzoffset\n+#    define gzoffset64            z_gzoffset64\n+#    define gzopen                z_gzopen\n+#    define gzopen64              z_gzopen64\n+#    ifdef _WIN32\n+#      define gzopen_w              z_gzopen_w\n+#    endif\n+#    define gzprintf              z_gzprintf\n+#    define gzputc                z_gzputc\n+#    define gzputs                z_gzputs\n+#    define gzread                z_gzread\n+#    define gzrewind              z_gzrewind\n+#    define gzseek                z_gzseek\n+#    define gzseek64              z_gzseek64\n+#    define gzsetparams           z_gzsetparams\n+#    define gztell                z_gztell\n+#    define gztell64              z_gztell64\n+#    define gzungetc              z_gzungetc\n+#    define gzwrite               z_gzwrite\n+#  endif\n #  define inflate               z_inflate\n #  define inflateBack           z_inflateBack\n #  define inflateBackEnd        z_inflateBackEnd\n@@ -97,13 +108,18 @@\n #  define inflateSync           z_inflateSync\n #  define inflateSyncPoint      z_inflateSyncPoint\n #  define inflateUndermine      z_inflateUndermine\n+#  define inflateResetKeep      z_inflateResetKeep\n #  define inflate_copyright     z_inflate_copyright\n #  define inflate_fast          z_inflate_fast\n #  define inflate_table         z_inflate_table\n-#  define uncompress            z_uncompress\n+#  ifndef Z_SOLO\n+#    define uncompress            z_uncompress\n+#  endif\n #  define zError                z_zError\n-#  define zcalloc               z_zcalloc\n-#  define zcfree                z_zcfree\n+#  ifndef Z_SOLO\n+#    define zcalloc               z_zcalloc\n+#    define zcfree                z_zcfree\n+#  endif\n #  define zlibCompileFlags      z_zlibCompileFlags\n #  define zlibVersion           z_zlibVersion\n \n@@ -113,7 +129,9 @@\n #  define alloc_func            z_alloc_func\n #  define charf                 z_charf\n #  define free_func             z_free_func\n-#  define gzFile                z_gzFile\n+#  ifndef Z_SOLO\n+#    define gzFile                z_gzFile\n+#  endif\n #  define gz_header             z_gz_header\n #  define gz_headerp            z_gz_headerp\n #  define in_func               z_in_func\n@@ -199,6 +217,12 @@\n #  endif\n #endif\n \n+#if defined(ZLIB_CONST) && !defined(z_const)\n+#  define z_const const\n+#else\n+#  define z_const\n+#endif\n+\n /* Some Mac compilers merge all .h files incorrectly: */\n #if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)\n #  define NO_DUMMY_DECL\n@@ -245,6 +269,14 @@\n #  endif\n #endif\n \n+#ifndef Z_ARG /* function prototypes for stdarg */\n+#  if defined(STDC) || defined(Z_HAVE_STDARG_H)\n+#    define Z_ARG(args)  args\n+#  else\n+#    define Z_ARG(args)  ()\n+#  endif\n+#endif\n+\n /* The following definitions for FAR are needed only for MSDOS mixed\n  * model programming (small or medium model with some far allocations).\n  * This was tested only with MSC; for other MSDOS compilers you may have\n@@ -358,12 +390,45 @@ typedef uLong FAR uLongf;\n    typedef Byte       *voidp;\n #endif\n \n+/* ./configure may #define Z_U4 here */\n+\n+#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)\n+#  include <limits.h>\n+#  if (UINT_MAX == 0xffffffffUL)\n+#    define Z_U4 unsigned\n+#  else\n+#    if (ULONG_MAX == 0xffffffffUL)\n+#      define Z_U4 unsigned long\n+#    else\n+#      if (USHRT_MAX == 0xffffffffUL)\n+#        define Z_U4 unsigned short\n+#      endif\n+#    endif\n+#  endif\n+#endif\n+\n+#ifdef Z_U4\n+   typedef Z_U4 z_crc_t;\n+#else\n+   typedef unsigned long z_crc_t;\n+#endif\n+\n #ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */\n #  define Z_HAVE_UNISTD_H\n #endif\n \n+#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */\n+#  define Z_HAVE_STDARG_H\n+#endif\n+\n #ifdef STDC\n-#  include <sys/types.h>    /* for off_t */\n+#  ifndef Z_SOLO\n+#    include <sys/types.h>      /* for off_t */\n+#  endif\n+#endif\n+\n+#ifdef _WIN32\n+#  include <stddef.h>           /* for wchar_t */\n #endif\n \n /* a little trick to accommodate both \"#define _LARGEFILE64_SOURCE\" and\n@@ -372,21 +437,38 @@ typedef uLong FAR uLongf;\n  * both \"#undef _LARGEFILE64_SOURCE\" and \"#define _LARGEFILE64_SOURCE 0\" as\n  * equivalently requesting no 64-bit operations\n  */\n-#if -_LARGEFILE64_SOURCE - -1 == 1\n+#if defined(LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1\n #  undef _LARGEFILE64_SOURCE\n #endif\n \n-#if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)\n-#  include <unistd.h>       /* for SEEK_* and off_t */\n-#  ifdef VMS\n-#    include <unixio.h>     /* for off_t */\n-#  endif\n-#  ifndef z_off_t\n-#    define z_off_t off_t\n+#if defined(__WATCOMC__) && !defined(Z_HAVE_UNISTD_H)\n+#  define Z_HAVE_UNISTD_H\n+#endif\n+#ifndef Z_SOLO\n+#  if defined(Z_HAVE_UNISTD_H) || defined(LARGEFILE64_SOURCE)\n+#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */\n+#    ifdef VMS\n+#      include <unixio.h>       /* for off_t */\n+#    endif\n+#    ifndef z_off_t\n+#      define z_off_t off_t\n+#    endif\n #  endif\n #endif\n \n-#ifndef SEEK_SET\n+#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0\n+#  define Z_LFS64\n+#endif\n+\n+#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)\n+#  define Z_LARGE64\n+#endif\n+\n+#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)\n+#  define Z_WANT64\n+#endif\n+\n+#if !defined(SEEK_SET) && !defined(Z_SOLO)\n #  define SEEK_SET        0       /* Seek from beginning of file.  */\n #  define SEEK_CUR        1       /* Seek from current position.  */\n #  define SEEK_END        2       /* Set file pointer to EOF plus \"offset\" */\n@@ -396,18 +478,14 @@ typedef uLong FAR uLongf;\n #  define z_off_t long\n #endif\n \n-#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0\n+#if !defined(_WIN32) && defined(Z_LARGE64)\n #  define z_off64_t off64_t\n #else\n-#  define z_off64_t z_off_t\n-#endif\n-\n-#if defined(__OS400__)\n-#  define NO_vsnprintf\n-#endif\n-\n-#if defined(__MVS__)\n-#  define NO_vsnprintf\n+#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)\n+#    define z_off64_t __int64\n+#  else\n+#    define z_off64_t z_off_t\n+#  endif\n #endif\n \n /* MVS linker does not support external names larger than 8 bytes */"}, {"sha": "8a46a58b30c59423a827a62437bc6e50fdbe4e90", "filename": "zlib/zconf.h.in", "status": "modified", "additions": 137, "deletions": 59, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzconf.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzconf.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzconf.h.in?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,5 +1,5 @@\n /* zconf.h -- configuration of the zlib compression library\n- * Copyright (C) 1995-2010 Jean-loup Gailly.\n+ * Copyright (C) 1995-2012 Jean-loup Gailly.\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -15,6 +15,7 @@\n  * this permanently in zconf.h using \"./configure --zprefix\".\n  */\n #ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */\n+#  define Z_PREFIX_SET\n \n /* all linked symbols */\n #  define _dist_code            z__dist_code\n@@ -27,9 +28,11 @@\n #  define adler32               z_adler32\n #  define adler32_combine       z_adler32_combine\n #  define adler32_combine64     z_adler32_combine64\n-#  define compress              z_compress\n-#  define compress2             z_compress2\n-#  define compressBound         z_compressBound\n+#  ifndef Z_SOLO\n+#    define compress              z_compress\n+#    define compress2             z_compress2\n+#    define compressBound         z_compressBound\n+#  endif\n #  define crc32                 z_crc32\n #  define crc32_combine         z_crc32_combine\n #  define crc32_combine64       z_crc32_combine64\n@@ -40,44 +43,52 @@\n #  define deflateInit2_         z_deflateInit2_\n #  define deflateInit_          z_deflateInit_\n #  define deflateParams         z_deflateParams\n+#  define deflatePending        z_deflatePending\n #  define deflatePrime          z_deflatePrime\n #  define deflateReset          z_deflateReset\n+#  define deflateResetKeep      z_deflateResetKeep\n #  define deflateSetDictionary  z_deflateSetDictionary\n #  define deflateSetHeader      z_deflateSetHeader\n #  define deflateTune           z_deflateTune\n #  define deflate_copyright     z_deflate_copyright\n #  define get_crc_table         z_get_crc_table\n-#  define gz_error              z_gz_error\n-#  define gz_intmax             z_gz_intmax\n-#  define gz_strwinerror        z_gz_strwinerror\n-#  define gzbuffer              z_gzbuffer\n-#  define gzclearerr            z_gzclearerr\n-#  define gzclose               z_gzclose\n-#  define gzclose_r             z_gzclose_r\n-#  define gzclose_w             z_gzclose_w\n-#  define gzdirect              z_gzdirect\n-#  define gzdopen               z_gzdopen\n-#  define gzeof                 z_gzeof\n-#  define gzerror               z_gzerror\n-#  define gzflush               z_gzflush\n-#  define gzgetc                z_gzgetc\n-#  define gzgets                z_gzgets\n-#  define gzoffset              z_gzoffset\n-#  define gzoffset64            z_gzoffset64\n-#  define gzopen                z_gzopen\n-#  define gzopen64              z_gzopen64\n-#  define gzprintf              z_gzprintf\n-#  define gzputc                z_gzputc\n-#  define gzputs                z_gzputs\n-#  define gzread                z_gzread\n-#  define gzrewind              z_gzrewind\n-#  define gzseek                z_gzseek\n-#  define gzseek64              z_gzseek64\n-#  define gzsetparams           z_gzsetparams\n-#  define gztell                z_gztell\n-#  define gztell64              z_gztell64\n-#  define gzungetc              z_gzungetc\n-#  define gzwrite               z_gzwrite\n+#  ifndef Z_SOLO\n+#    define gz_error              z_gz_error\n+#    define gz_intmax             z_gz_intmax\n+#    define gz_strwinerror        z_gz_strwinerror\n+#    define gzbuffer              z_gzbuffer\n+#    define gzclearerr            z_gzclearerr\n+#    define gzclose               z_gzclose\n+#    define gzclose_r             z_gzclose_r\n+#    define gzclose_w             z_gzclose_w\n+#    define gzdirect              z_gzdirect\n+#    define gzdopen               z_gzdopen\n+#    define gzeof                 z_gzeof\n+#    define gzerror               z_gzerror\n+#    define gzflush               z_gzflush\n+#    define gzgetc                z_gzgetc\n+#    define gzgetc_               z_gzgetc_\n+#    define gzgets                z_gzgets\n+#    define gzoffset              z_gzoffset\n+#    define gzoffset64            z_gzoffset64\n+#    define gzopen                z_gzopen\n+#    define gzopen64              z_gzopen64\n+#    ifdef _WIN32\n+#      define gzopen_w              z_gzopen_w\n+#    endif\n+#    define gzprintf              z_gzprintf\n+#    define gzputc                z_gzputc\n+#    define gzputs                z_gzputs\n+#    define gzread                z_gzread\n+#    define gzrewind              z_gzrewind\n+#    define gzseek                z_gzseek\n+#    define gzseek64              z_gzseek64\n+#    define gzsetparams           z_gzsetparams\n+#    define gztell                z_gztell\n+#    define gztell64              z_gztell64\n+#    define gzungetc              z_gzungetc\n+#    define gzwrite               z_gzwrite\n+#  endif\n #  define inflate               z_inflate\n #  define inflateBack           z_inflateBack\n #  define inflateBackEnd        z_inflateBackEnd\n@@ -95,13 +106,18 @@\n #  define inflateSync           z_inflateSync\n #  define inflateSyncPoint      z_inflateSyncPoint\n #  define inflateUndermine      z_inflateUndermine\n+#  define inflateResetKeep      z_inflateResetKeep\n #  define inflate_copyright     z_inflate_copyright\n #  define inflate_fast          z_inflate_fast\n #  define inflate_table         z_inflate_table\n-#  define uncompress            z_uncompress\n+#  ifndef Z_SOLO\n+#    define uncompress            z_uncompress\n+#  endif\n #  define zError                z_zError\n-#  define zcalloc               z_zcalloc\n-#  define zcfree                z_zcfree\n+#  ifndef Z_SOLO\n+#    define zcalloc               z_zcalloc\n+#    define zcfree                z_zcfree\n+#  endif\n #  define zlibCompileFlags      z_zlibCompileFlags\n #  define zlibVersion           z_zlibVersion\n \n@@ -111,7 +127,9 @@\n #  define alloc_func            z_alloc_func\n #  define charf                 z_charf\n #  define free_func             z_free_func\n-#  define gzFile                z_gzFile\n+#  ifndef Z_SOLO\n+#    define gzFile                z_gzFile\n+#  endif\n #  define gz_header             z_gz_header\n #  define gz_headerp            z_gz_headerp\n #  define in_func               z_in_func\n@@ -197,6 +215,12 @@\n #  endif\n #endif\n \n+#if defined(ZLIB_CONST) && !defined(z_const)\n+#  define z_const const\n+#else\n+#  define z_const\n+#endif\n+\n /* Some Mac compilers merge all .h files incorrectly: */\n #if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)\n #  define NO_DUMMY_DECL\n@@ -243,6 +267,14 @@\n #  endif\n #endif\n \n+#ifndef Z_ARG /* function prototypes for stdarg */\n+#  if defined(STDC) || defined(Z_HAVE_STDARG_H)\n+#    define Z_ARG(args)  args\n+#  else\n+#    define Z_ARG(args)  ()\n+#  endif\n+#endif\n+\n /* The following definitions for FAR are needed only for MSDOS mixed\n  * model programming (small or medium model with some far allocations).\n  * This was tested only with MSC; for other MSDOS compilers you may have\n@@ -356,12 +388,45 @@ typedef uLong FAR uLongf;\n    typedef Byte       *voidp;\n #endif\n \n+/* ./configure may #define Z_U4 here */\n+\n+#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)\n+#  include <limits.h>\n+#  if (UINT_MAX == 0xffffffffUL)\n+#    define Z_U4 unsigned\n+#  else\n+#    if (ULONG_MAX == 0xffffffffUL)\n+#      define Z_U4 unsigned long\n+#    else\n+#      if (USHRT_MAX == 0xffffffffUL)\n+#        define Z_U4 unsigned short\n+#      endif\n+#    endif\n+#  endif\n+#endif\n+\n+#ifdef Z_U4\n+   typedef Z_U4 z_crc_t;\n+#else\n+   typedef unsigned long z_crc_t;\n+#endif\n+\n #ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */\n #  define Z_HAVE_UNISTD_H\n #endif\n \n+#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */\n+#  define Z_HAVE_STDARG_H\n+#endif\n+\n #ifdef STDC\n-#  include <sys/types.h>    /* for off_t */\n+#  ifndef Z_SOLO\n+#    include <sys/types.h>      /* for off_t */\n+#  endif\n+#endif\n+\n+#ifdef _WIN32\n+#  include <stddef.h>           /* for wchar_t */\n #endif\n \n /* a little trick to accommodate both \"#define _LARGEFILE64_SOURCE\" and\n@@ -370,21 +435,38 @@ typedef uLong FAR uLongf;\n  * both \"#undef _LARGEFILE64_SOURCE\" and \"#define _LARGEFILE64_SOURCE 0\" as\n  * equivalently requesting no 64-bit operations\n  */\n-#if -_LARGEFILE64_SOURCE - -1 == 1\n+#if defined(LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1\n #  undef _LARGEFILE64_SOURCE\n #endif\n \n-#if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)\n-#  include <unistd.h>       /* for SEEK_* and off_t */\n-#  ifdef VMS\n-#    include <unixio.h>     /* for off_t */\n-#  endif\n-#  ifndef z_off_t\n-#    define z_off_t off_t\n+#if defined(__WATCOMC__) && !defined(Z_HAVE_UNISTD_H)\n+#  define Z_HAVE_UNISTD_H\n+#endif\n+#ifndef Z_SOLO\n+#  if defined(Z_HAVE_UNISTD_H) || defined(LARGEFILE64_SOURCE)\n+#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */\n+#    ifdef VMS\n+#      include <unixio.h>       /* for off_t */\n+#    endif\n+#    ifndef z_off_t\n+#      define z_off_t off_t\n+#    endif\n #  endif\n #endif\n \n-#ifndef SEEK_SET\n+#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0\n+#  define Z_LFS64\n+#endif\n+\n+#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)\n+#  define Z_LARGE64\n+#endif\n+\n+#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)\n+#  define Z_WANT64\n+#endif\n+\n+#if !defined(SEEK_SET) && !defined(Z_SOLO)\n #  define SEEK_SET        0       /* Seek from beginning of file.  */\n #  define SEEK_CUR        1       /* Seek from current position.  */\n #  define SEEK_END        2       /* Set file pointer to EOF plus \"offset\" */\n@@ -394,18 +476,14 @@ typedef uLong FAR uLongf;\n #  define z_off_t long\n #endif\n \n-#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0\n+#if !defined(_WIN32) && defined(Z_LARGE64)\n #  define z_off64_t off64_t\n #else\n-#  define z_off64_t z_off_t\n-#endif\n-\n-#if defined(__OS400__)\n-#  define NO_vsnprintf\n-#endif\n-\n-#if defined(__MVS__)\n-#  define NO_vsnprintf\n+#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)\n+#    define z_off64_t __int64\n+#  else\n+#    define z_off64_t z_off_t\n+#  endif\n #endif\n \n /* MVS linker does not support external names larger than 8 bytes */"}, {"sha": "79d3402b39c4fc406842dbd3805bf45b45ccc94e", "filename": "zlib/zlib.3", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzlib.3", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzlib.3", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzlib.3?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,4 +1,4 @@\n-.TH ZLIB 3 \"19 Apr 2010\"\n+.TH ZLIB 3 \"2 May 2012\"\n .SH NAME\n zlib \\- compression/decompression library\n .SH SYNOPSIS\n@@ -36,9 +36,9 @@ All functions of the compression library are documented in the file\n .IR zlib.h .\n The distribution source includes examples of use of the library\n in the files\n-.I example.c\n+.I test/example.c\n and\n-.IR minigzip.c,\n+.IR test/minigzip.c,\n as well as other examples in the\n .IR examples/\n directory.\n@@ -65,7 +65,7 @@ A Python interface to\n written by A.M. Kuchling (amk@magnet.com),\n is available in Python 1.5 and later versions:\n .IP\n-http://www.python.org/doc/lib/module-zlib.html\n+http://docs.python.org/library/zlib.html\n .LP\n .I zlib\n is built into\n@@ -95,11 +95,11 @@ http://zlib.net/\n The data format used by the zlib library is described by RFC\n (Request for Comments) 1950 to 1952 in the files:\n .IP\n-http://www.ietf.org/rfc/rfc1950.txt (for the zlib header and trailer format)\n+http://tools.ietf.org/html/rfc1950 (for the zlib header and trailer format)\n .br\n-http://www.ietf.org/rfc/rfc1951.txt (for the deflate compressed data format)\n+http://tools.ietf.org/html/rfc1951 (for the deflate compressed data format)\n .br\n-http://www.ietf.org/rfc/rfc1952.txt (for the gzip header and trailer format)\n+http://tools.ietf.org/html/rfc1952 (for the gzip header and trailer format)\n .LP\n Mark Nelson wrote an article about\n .I zlib\n@@ -125,8 +125,8 @@ before asking for help.\n Send questions and/or comments to zlib@gzip.org,\n or (for the Windows DLL version) to Gilles Vollant (info@winimage.com).\n .SH AUTHORS\n-Version 1.2.5\n-Copyright (C) 1995-2010 Jean-loup Gailly (jloup@gzip.org)\n+Version 1.2.7\n+Copyright (C) 1995-2012 Jean-loup Gailly (jloup@gzip.org)\n and Mark Adler (madler@alumni.caltech.edu).\n .LP\n This software is provided \"as-is,\""}, {"sha": "3edf3acdb570377cb0803f092700f1c000643e9f", "filename": "zlib/zlib.h", "status": "modified", "additions": 220, "deletions": 89, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzlib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzlib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzlib.h?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,7 +1,7 @@\n /* zlib.h -- interface of the 'zlib' general purpose compression library\n-  version 1.2.5, April 19th, 2010\n+  version 1.2.7, May 2nd, 2012\n \n-  Copyright (C) 1995-2010 Jean-loup Gailly and Mark Adler\n+  Copyright (C) 1995-2012 Jean-loup Gailly and Mark Adler\n \n   This software is provided 'as-is', without any express or implied\n   warranty.  In no event will the authors be held liable for any damages\n@@ -24,8 +24,8 @@\n \n \n   The data format used by the zlib library is described by RFCs (Request for\n-  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt\n-  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).\n+  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950\n+  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).\n */\n \n #ifndef ZLIB_H\n@@ -37,11 +37,11 @@\n extern \"C\" {\n #endif\n \n-#define ZLIB_VERSION \"1.2.5\"\n-#define ZLIB_VERNUM 0x1250\n+#define ZLIB_VERSION \"1.2.7\"\n+#define ZLIB_VERNUM 0x1270\n #define ZLIB_VER_MAJOR 1\n #define ZLIB_VER_MINOR 2\n-#define ZLIB_VER_REVISION 5\n+#define ZLIB_VER_REVISION 7\n #define ZLIB_VER_SUBREVISION 0\n \n /*\n@@ -83,15 +83,15 @@ typedef void   (*free_func)  OF((voidpf opaque, voidpf address));\n struct internal_state;\n \n typedef struct z_stream_s {\n-    Bytef    *next_in;  /* next input byte */\n+    z_const Bytef *next_in;     /* next input byte */\n     uInt     avail_in;  /* number of bytes available at next_in */\n-    uLong    total_in;  /* total nb of input bytes read so far */\n+    uLong    total_in;  /* total number of input bytes read so far */\n \n     Bytef    *next_out; /* next output byte should be put there */\n     uInt     avail_out; /* remaining free space at next_out */\n-    uLong    total_out; /* total nb of bytes output so far */\n+    uLong    total_out; /* total number of bytes output so far */\n \n-    char     *msg;      /* last error message, NULL if no error */\n+    z_const char *msg;  /* last error message, NULL if no error */\n     struct internal_state FAR *state; /* not visible by applications */\n \n     alloc_func zalloc;  /* used to allocate the internal state */\n@@ -327,8 +327,9 @@ ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));\n \n     Z_FINISH can be used immediately after deflateInit if all the compression\n   is to be done in a single step.  In this case, avail_out must be at least the\n-  value returned by deflateBound (see below).  If deflate does not return\n-  Z_STREAM_END, then it must be called again as described above.\n+  value returned by deflateBound (see below).  Then deflate is guaranteed to\n+  return Z_STREAM_END.  If not enough output space is provided, deflate will\n+  not return Z_STREAM_END, and it must be called again as described above.\n \n     deflate() sets strm->adler to the adler32 checksum of all input read\n   so far (that is, total_in bytes).\n@@ -451,23 +452,29 @@ ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));\n   error.  However if all decompression is to be performed in a single step (a\n   single call of inflate), the parameter flush should be set to Z_FINISH.  In\n   this case all pending input is processed and all pending output is flushed;\n-  avail_out must be large enough to hold all the uncompressed data.  (The size\n-  of the uncompressed data may have been saved by the compressor for this\n-  purpose.) The next operation on this stream must be inflateEnd to deallocate\n-  the decompression state.  The use of Z_FINISH is never required, but can be\n-  used to inform inflate that a faster approach may be used for the single\n-  inflate() call.\n+  avail_out must be large enough to hold all of the uncompressed data for the\n+  operation to complete.  (The size of the uncompressed data may have been\n+  saved by the compressor for this purpose.) The use of Z_FINISH is not\n+  required to perform an inflation in one step.  However it may be used to\n+  inform inflate that a faster approach can be used for the single inflate()\n+  call.  Z_FINISH also informs inflate to not maintain a sliding window if the\n+  stream completes, which reduces inflate's memory footprint.  If the stream\n+  does not complete, either because not all of the stream is provided or not\n+  enough output space is provided, then a sliding window will be allocated and\n+  inflate() can be called again to continue the operation as if Z_NO_FLUSH had\n+  been used.\n \n      In this implementation, inflate() always flushes as much output as\n   possible to the output buffer, and always uses the faster approach on the\n-  first call.  So the only effect of the flush parameter in this implementation\n-  is on the return value of inflate(), as noted below, or when it returns early\n-  because Z_BLOCK or Z_TREES is used.\n+  first call.  So the effects of the flush parameter in this implementation are\n+  on the return value of inflate() as noted below, when inflate() returns early\n+  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of\n+  memory for a sliding window when Z_FINISH is used.\n \n      If a preset dictionary is needed after this call (see inflateSetDictionary\n-  below), inflate sets strm->adler to the adler32 checksum of the dictionary\n+  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary\n   chosen by the compressor and returns Z_NEED_DICT; otherwise it sets\n-  strm->adler to the adler32 checksum of all output produced so far (that is,\n+  strm->adler to the Adler-32 checksum of all output produced so far (that is,\n   total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described\n   below.  At the end of the stream, inflate() checks that its computed adler32\n   checksum is equal to that saved by the compressor and returns Z_STREAM_END\n@@ -478,7 +485,9 @@ ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));\n   initializing with inflateInit2().  Any information contained in the gzip\n   header is not retained, so applications that need that information should\n   instead use raw inflate, see inflateInit2() below, or inflateBack() and\n-  perform their own processing of the gzip header and trailer.\n+  perform their own processing of the gzip header and trailer.  When processing\n+  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output\n+  producted so far.  The CRC-32 is checked against the gzip trailer.\n \n     inflate() returns Z_OK if some progress has been made (more input processed\n   or more output produced), Z_STREAM_END if the end of the compressed data has\n@@ -580,10 +589,15 @@ ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,\n                                              uInt  dictLength));\n /*\n      Initializes the compression dictionary from the given byte sequence\n-   without producing any compressed output.  This function must be called\n-   immediately after deflateInit, deflateInit2 or deflateReset, before any call\n-   of deflate.  The compressor and decompressor must use exactly the same\n-   dictionary (see inflateSetDictionary).\n+   without producing any compressed output.  When using the zlib format, this\n+   function must be called immediately after deflateInit, deflateInit2 or\n+   deflateReset, and before any call of deflate.  When doing raw deflate, this\n+   function must be called either before any call of deflate, or immediately\n+   after the completion of a deflate block, i.e. after all input has been\n+   consumed and all output has been delivered when using any of the flush\n+   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The\n+   compressor and decompressor must use exactly the same dictionary (see\n+   inflateSetDictionary).\n \n      The dictionary should consist of strings (byte sequences) that are likely\n    to be encountered later in the data to be compressed, with the most commonly\n@@ -610,8 +624,8 @@ ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,\n      deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a\n    parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is\n    inconsistent (for example if deflate has already been called for this stream\n-   or if the compression method is bsort).  deflateSetDictionary does not\n-   perform any compression: this will be done by deflate().\n+   or if not at a block boundary for raw deflate).  deflateSetDictionary does\n+   not perform any compression: this will be done by deflate().\n */\n \n ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,\n@@ -688,8 +702,28 @@ ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,\n    deflation of sourceLen bytes.  It must be called after deflateInit() or\n    deflateInit2(), and after deflateSetHeader(), if used.  This would be used\n    to allocate an output buffer for deflation in a single pass, and so would be\n-   called before deflate().\n-*/\n+   called before deflate().  If that first deflate() call is provided the\n+   sourceLen input bytes, an output buffer allocated to the size returned by\n+   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed\n+   to return Z_STREAM_END.  Note that it is possible for the compressed size to\n+   be larger than the value returned by deflateBound() if flush options other\n+   than Z_FINISH or Z_NO_FLUSH are used.\n+*/\n+\n+ZEXTERN int ZEXPORT deflatePending OF((z_streamp strm,\n+                                       unsigned *pending,\n+                                       int *bits));\n+/*\n+     deflatePending() returns the number of bytes and bits of output that have\n+   been generated, but not yet provided in the available output.  The bytes not\n+   provided would be due to the available output space having being consumed.\n+   The number of bits of output not provided are between 0 and 7, where they\n+   await more bits to join them in order to fill out a full byte.  If pending\n+   or bits are Z_NULL, then those values are not set.\n+\n+     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source\n+   stream state was inconsistent.\n+ */\n \n ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,\n                                      int bits,\n@@ -703,8 +737,9 @@ ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,\n    than or equal to 16, and that many of the least significant bits of value\n    will be inserted in the output.\n \n-     deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source\n-   stream state was inconsistent.\n+     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough\n+   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the\n+   source stream state was inconsistent.\n */\n \n ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,\n@@ -790,10 +825,11 @@ ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,\n    if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor\n    can be determined from the adler32 value returned by that call of inflate.\n    The compressor and decompressor must use exactly the same dictionary (see\n-   deflateSetDictionary).  For raw inflate, this function can be called\n-   immediately after inflateInit2() or inflateReset() and before any call of\n-   inflate() to set the dictionary.  The application must insure that the\n-   dictionary that was used for compression is provided.\n+   deflateSetDictionary).  For raw inflate, this function can be called at any\n+   time to set the dictionary.  If the provided dictionary is smaller than the\n+   window and there is already data in the window, then the provided dictionary\n+   will amend what's there.  The application must insure that the dictionary\n+   that was used for compression is provided.\n \n      inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a\n    parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is\n@@ -805,17 +841,21 @@ ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,\n \n ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));\n /*\n-     Skips invalid compressed data until a full flush point (see above the\n-   description of deflate with Z_FULL_FLUSH) can be found, or until all\n+     Skips invalid compressed data until a possible full flush point (see above\n+   for the description of deflate with Z_FULL_FLUSH) can be found, or until all\n    available input is skipped.  No output is provided.\n \n-     inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR\n-   if no more input was provided, Z_DATA_ERROR if no flush point has been\n-   found, or Z_STREAM_ERROR if the stream structure was inconsistent.  In the\n-   success case, the application may save the current current value of total_in\n-   which indicates where valid compressed data was found.  In the error case,\n-   the application may repeatedly call inflateSync, providing more input each\n-   time, until success or end of the input data.\n+     inflateSync searches for a 00 00 FF FF pattern in the compressed data.\n+   All full flush points have this pattern, but not all occurences of this\n+   pattern are full flush points.\n+\n+     inflateSync returns Z_OK if a possible full flush point has been found,\n+   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point\n+   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.\n+   In the success case, the application may save the current current value of\n+   total_in which indicates where valid compressed data was found.  In the\n+   error case, the application may repeatedly call inflateSync, providing more\n+   input each time, until success or end of the input data.\n */\n \n ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,\n@@ -962,7 +1002,7 @@ ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,\n      See inflateBack() for the usage of these routines.\n \n      inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of\n-   the paramaters are invalid, Z_MEM_ERROR if the internal state could not be\n+   the parameters are invalid, Z_MEM_ERROR if the internal state could not be\n    allocated, or Z_VERSION_ERROR if the version of the library does not match\n    the version of the header file.\n */\n@@ -1088,6 +1128,7 @@ ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));\n      27-31: 0 (reserved)\n  */\n \n+#ifndef Z_SOLO\n \n                         /* utility functions */\n \n@@ -1149,10 +1190,11 @@ ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,\n \n      uncompress returns Z_OK if success, Z_MEM_ERROR if there was not\n    enough memory, Z_BUF_ERROR if there was not enough room in the output\n-   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.\n+   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In\n+   the case where there is not enough room, uncompress() will fill the output\n+   buffer with the uncompressed data up to that point.\n */\n \n-\n                         /* gzip file access functions */\n \n /*\n@@ -1162,7 +1204,7 @@ ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,\n    wrapper, documented in RFC 1952, wrapped around a deflate stream.\n */\n \n-typedef voidp gzFile;       /* opaque gzip file descriptor */\n+typedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */\n \n /*\n ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));\n@@ -1172,13 +1214,28 @@ ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));\n    a strategy: 'f' for filtered data as in \"wb6f\", 'h' for Huffman-only\n    compression as in \"wb1h\", 'R' for run-length encoding as in \"wb1R\", or 'F'\n    for fixed code compression as in \"wb9F\".  (See the description of\n-   deflateInit2 for more information about the strategy parameter.) Also \"a\"\n-   can be used instead of \"w\" to request that the gzip stream that will be\n-   written be appended to the file.  \"+\" will result in an error, since reading\n-   and writing to the same gzip file is not supported.\n+   deflateInit2 for more information about the strategy parameter.)  'T' will\n+   request transparent writing or appending with no compression and not using\n+   the gzip format.\n+\n+     \"a\" can be used instead of \"w\" to request that the gzip stream that will\n+   be written be appended to the file.  \"+\" will result in an error, since\n+   reading and writing to the same gzip file is not supported.  The addition of\n+   \"x\" when writing will create the file exclusively, which fails if the file\n+   already exists.  On systems that support it, the addition of \"e\" when\n+   reading or writing will set the flag to close the file on an execve() call.\n+\n+     These functions, as well as gzip, will read and decode a sequence of gzip\n+   streams in a file.  The append function of gzopen() can be used to create\n+   such a file.  (Also see gzflush() for another way to do this.)  When\n+   appending, gzopen does not test whether the file begins with a gzip stream,\n+   nor does it look for the end of the gzip streams to begin appending.  gzopen\n+   will simply append a gzip stream to the existing file.\n \n      gzopen can be used to read a file which is not in gzip format; in this\n-   case gzread will directly read from the file without decompression.\n+   case gzread will directly read from the file without decompression.  When\n+   reading, this will be detected automatically by looking for the magic two-\n+   byte gzip header.\n \n      gzopen returns NULL if the file could not be opened, if there was\n    insufficient memory to allocate the gzFile state, or if an invalid mode was\n@@ -1197,7 +1254,11 @@ ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));\n    descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor\n    fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,\n    mode);.  The duplicated descriptor should be saved to avoid a leak, since\n-   gzdopen does not close fd if it fails.\n+   gzdopen does not close fd if it fails.  If you are using fileno() to get the\n+   file descriptor from a FILE *, then you will have to use dup() to avoid\n+   double-close()ing the file descriptor.  Both gzclose() and fclose() will\n+   close the associated file descriptor, so they need to have different file\n+   descriptors.\n \n      gzdopen returns NULL if there was insufficient memory to allocate the\n    gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not\n@@ -1235,14 +1296,26 @@ ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));\n ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));\n /*\n      Reads the given number of uncompressed bytes from the compressed file.  If\n-   the input file was not in gzip format, gzread copies the given number of\n-   bytes into the buffer.\n+   the input file is not in gzip format, gzread copies the given number of\n+   bytes into the buffer directly from the file.\n \n      After reaching the end of a gzip stream in the input, gzread will continue\n-   to read, looking for another gzip stream, or failing that, reading the rest\n-   of the input file directly without decompression.  The entire input file\n-   will be read if gzread is called until it returns less than the requested\n-   len.\n+   to read, looking for another gzip stream.  Any number of gzip streams may be\n+   concatenated in the input file, and will all be decompressed by gzread().\n+   If something other than a gzip stream is encountered after a gzip stream,\n+   that remaining trailing garbage is ignored (and no error is returned).\n+\n+     gzread can be used to read a gzip file that is being concurrently written.\n+   Upon reaching the end of the input, gzread will return with the available\n+   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then\n+   gzclearerr can be used to clear the end of file indicator in order to permit\n+   gzread to be tried again.  Z_OK indicates that a gzip stream was completed\n+   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the\n+   middle of a gzip stream.  Note that gzread does not return -1 in the event\n+   of an incomplete gzip stream.  This error is deferred until gzclose(), which\n+   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip\n+   stream.  Alternatively, gzerror can be used before gzclose to detect this\n+   case.\n \n      gzread returns the number of uncompressed bytes actually read, less than\n    len for end of file, or -1 for error.\n@@ -1256,7 +1329,7 @@ ZEXTERN int ZEXPORT gzwrite OF((gzFile file,\n    error.\n */\n \n-ZEXTERN int ZEXPORTVA gzprintf OF((gzFile file, const char *format, ...));\n+ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));\n /*\n      Converts, formats, and writes the arguments to the compressed file under\n    control of the format string, as in fprintf.  gzprintf returns the number of\n@@ -1301,7 +1374,10 @@ ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));\n ZEXTERN int ZEXPORT gzgetc OF((gzFile file));\n /*\n      Reads one byte from the compressed file.  gzgetc returns this byte or -1\n-   in case of end of file or error.\n+   in case of end of file or error.  This is implemented as a macro for speed.\n+   As such, it does not do all of the checking the other functions do.  I.e.\n+   it does not check to see if file is NULL, nor whether the structure file\n+   points to has been clobbered or not.\n */\n \n ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));\n@@ -1397,9 +1473,7 @@ ZEXTERN int ZEXPORT gzeof OF((gzFile file));\n ZEXTERN int ZEXPORT gzdirect OF((gzFile file));\n /*\n      Returns true (1) if file is being copied directly while reading, or false\n-   (0) if file is a gzip stream being decompressed.  This state can change from\n-   false to true while reading the input file if the end of a gzip stream is\n-   reached, but is followed by data that is not another gzip stream.\n+   (0) if file is a gzip stream being decompressed.\n \n      If the input file is empty, gzdirect() will return true, since the input\n    does not contain a gzip stream.\n@@ -1408,6 +1482,13 @@ ZEXTERN int ZEXPORT gzdirect OF((gzFile file));\n    cause buffers to be allocated to allow reading the file to determine if it\n    is a gzip file.  Therefore if gzbuffer() is used, it should be called before\n    gzdirect().\n+\n+     When writing, gzdirect() returns true (1) if transparent writing was\n+   requested (\"wT\" for the gzopen() mode), or false (0) otherwise.  (Note:\n+   gzdirect() is not needed when writing.  Transparent writing must be\n+   explicitly requested, so the application already knows the answer.  When\n+   linking statically, using gzdirect() will include all of the zlib code for\n+   gzip file reading and decompression, which may not be desired.)\n */\n \n ZEXTERN int ZEXPORT    gzclose OF((gzFile file));\n@@ -1419,7 +1500,8 @@ ZEXTERN int ZEXPORT    gzclose OF((gzFile file));\n    must not be called more than once on the same allocation.\n \n      gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a\n-   file operation error, or Z_OK on success.\n+   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the\n+   last read ended in the middle of a gzip stream, or Z_OK on success.\n */\n \n ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));\n@@ -1457,6 +1539,7 @@ ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));\n    file that is being written concurrently.\n */\n \n+#endif /* !Z_SOLO */\n \n                         /* checksum functions */\n \n@@ -1492,16 +1575,17 @@ ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,\n      Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1\n    and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for\n    each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of\n-   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.\n+   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note\n+   that the z_off_t type (like off_t) is a signed integer.  If len2 is\n+   negative, the result has no meaning or utility.\n */\n \n ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));\n /*\n      Update a running CRC-32 with the bytes buf[0..len-1] and return the\n    updated CRC-32.  If buf is Z_NULL, this function returns the required\n-   initial value for the for the crc.  Pre- and post-conditioning (one's\n-   complement) is performed within this function so it shouldn't be done by the\n-   application.\n+   initial value for the crc.  Pre- and post-conditioning (one's complement) is\n+   performed within this function so it shouldn't be done by the application.\n \n    Usage example:\n \n@@ -1544,25 +1628,50 @@ ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,\n                                          const char *version,\n                                          int stream_size));\n #define deflateInit(strm, level) \\\n-        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))\n+        deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))\n #define inflateInit(strm) \\\n-        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))\n+        inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))\n #define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \\\n         deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\\\n-                      (strategy),           ZLIB_VERSION, sizeof(z_stream))\n+                      (strategy), ZLIB_VERSION, (int)sizeof(z_stream))\n #define inflateInit2(strm, windowBits) \\\n-        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))\n+        inflateInit2_((strm), (windowBits), ZLIB_VERSION, \\\n+                      (int)sizeof(z_stream))\n #define inflateBackInit(strm, windowBits, window) \\\n         inflateBackInit_((strm), (windowBits), (window), \\\n-                                            ZLIB_VERSION, sizeof(z_stream))\n+                      ZLIB_VERSION, (int)sizeof(z_stream))\n+\n+#ifndef Z_SOLO\n+\n+/* gzgetc() macro and its supporting function and exposed data structure.  Note\n+ * that the real internal state is much larger than the exposed structure.\n+ * This abbreviated structure exposes just enough for the gzgetc() macro.  The\n+ * user should not mess with these exposed elements, since their names or\n+ * behavior could change in the future, perhaps even capriciously.  They can\n+ * only be used by the gzgetc() macro.  You have been warned.\n+ */\n+struct gzFile_s {\n+    unsigned have;\n+    unsigned char *next;\n+    z_off64_t pos;\n+};\n+ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */\n+#ifdef Z_PREFIX_SET\n+#  undef z_gzgetc\n+#  define z_gzgetc(g) \\\n+          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : gzgetc(g))\n+#else\n+#  define gzgetc(g) \\\n+          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : gzgetc(g))\n+#endif\n \n /* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or\n  * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if\n  * both are true, the application gets the *64 functions, and the regular\n  * functions are changed to 64 bits) -- in case these are set on systems\n  * without large file support, _LFS64_LARGEFILE must also be true\n  */\n-#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0\n+#ifdef Z_LARGE64\n    ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));\n    ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));\n    ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));\n@@ -1571,14 +1680,23 @@ ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,\n    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));\n #endif\n \n-#if !defined(ZLIB_INTERNAL) && _FILE_OFFSET_BITS-0 == 64 && _LFS64_LARGEFILE-0\n-#  define gzopen gzopen64\n-#  define gzseek gzseek64\n-#  define gztell gztell64\n-#  define gzoffset gzoffset64\n-#  define adler32_combine adler32_combine64\n-#  define crc32_combine crc32_combine64\n-#  ifdef _LARGEFILE64_SOURCE\n+#if !defined(ZLIB_INTERNAL) && defined(Z_WANT64)\n+#  ifdef Z_PREFIX_SET\n+#    define z_gzopen z_gzopen64\n+#    define z_gzseek z_gzseek64\n+#    define z_gztell z_gztell64\n+#    define z_gzoffset z_gzoffset64\n+#    define z_adler32_combine z_adler32_combine64\n+#    define z_crc32_combine z_crc32_combine64\n+#  else\n+#    define gzopen gzopen64\n+#    define gzseek gzseek64\n+#    define gztell gztell64\n+#    define gzoffset gzoffset64\n+#    define adler32_combine adler32_combine64\n+#    define crc32_combine crc32_combine64\n+#  endif\n+#  ifndef Z_LARGE64\n      ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));\n      ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));\n      ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));\n@@ -1595,6 +1713,13 @@ ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,\n    ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));\n #endif\n \n+#else /* Z_SOLO */\n+\n+   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));\n+   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));\n+\n+#endif /* !Z_SOLO */\n+\n /* hack for buggy compilers */\n #if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)\n     struct internal_state {int dummy;};\n@@ -1603,8 +1728,14 @@ ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,\n /* undocumented functions */\n ZEXTERN const char   * ZEXPORT zError           OF((int));\n ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));\n-ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));\n+ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));\n ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));\n+ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));\n+ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));\n+#if defined(_WIN32) && !defined(Z_SOLO)\n+ZEXTERN gzFile         ZEXPORT gzopen_w OF((const wchar_t *path,\n+                                            const char *mode));\n+#endif\n \n #ifdef __cplusplus\n }"}, {"sha": "771f420412e2162ac6c9c9aefc1c3d4b15a713f5", "filename": "zlib/zlib.map", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzlib.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzlib.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzlib.map?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -66,3 +66,13 @@ ZLIB_1.2.3.5 {\n     gzclose_r;\n     gzclose_w;\n } ZLIB_1.2.3.4;\n+\n+ZLIB_1.2.5.1 {\n+    deflatePending;\n+} ZLIB_1.2.3.5;\n+\n+ZLIB_1.2.5.2 {\n+    deflateResetKeep;\n+    gzgetc_;\n+    inflateResetKeep;\n+} ZLIB_1.2.5.1;"}, {"sha": "a5e642938c69851ea57d0a4e1dcd94ea1381edfa", "filename": "zlib/zlib.pc.cmakein", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzlib.pc.cmakein", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzlib.pc.cmakein", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzlib.pc.cmakein?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -0,0 +1,13 @@\n+prefix=@CMAKE_INSTALL_PREFIX@\n+exec_prefix=@CMAKE_INSTALL_PREFIX@\n+libdir=@INSTALL_LIB_DIR@\n+sharedlibdir=@INSTALL_LIB_DIR@\n+includedir=@INSTALL_INC_DIR@\n+\n+Name: zlib\n+Description: zlib compression library\n+Version: @VERSION@\n+\n+Requires:\n+Libs: -L${libdir} -L${sharedlibdir} -lz\n+Cflags: -I${includedir}"}, {"sha": "e1e463fa9602de94acfa8c771dd28675e937b269", "filename": "zlib/zutil.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzutil.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzutil.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzutil.c?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,11 +1,14 @@\n /* zutil.c -- target dependent utility functions for the compression library\n- * Copyright (C) 1995-2005, 2010 Jean-loup Gailly.\n+ * Copyright (C) 1995-2005, 2010, 2011, 2012 Jean-loup Gailly.\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n /* @(#) $Id: zutil.c,v 1.1.1.2 2002/03/11 21:53:27 tromey Exp $ */\n \n #include \"zutil.h\"\n+#ifndef Z_SOLO\n+#  include \"gzguts.h\"\n+#endif\n \n #ifndef NO_DUMMY_DECL\n struct internal_state      {int dummy;}; /* for buggy compilers */\n@@ -85,27 +88,27 @@ uLong ZEXPORT zlibCompileFlags()\n #ifdef FASTEST\n     flags += 1L << 21;\n #endif\n-#ifdef STDC\n+#if defined(STDC) || defined(Z_HAVE_STDARG_H)\n #  ifdef NO_vsnprintf\n-        flags += 1L << 25;\n+    flags += 1L << 25;\n #    ifdef HAS_vsprintf_void\n-        flags += 1L << 26;\n+    flags += 1L << 26;\n #    endif\n #  else\n #    ifdef HAS_vsnprintf_void\n-        flags += 1L << 26;\n+    flags += 1L << 26;\n #    endif\n #  endif\n #else\n-        flags += 1L << 24;\n+    flags += 1L << 24;\n #  ifdef NO_snprintf\n-        flags += 1L << 25;\n+    flags += 1L << 25;\n #    ifdef HAS_sprintf_void\n-        flags += 1L << 26;\n+    flags += 1L << 26;\n #    endif\n #  else\n #    ifdef HAS_snprintf_void\n-        flags += 1L << 26;\n+    flags += 1L << 26;\n #    endif\n #  endif\n #endif\n@@ -181,6 +184,7 @@ void ZLIB_INTERNAL zmemzero(dest, len)\n }\n #endif\n \n+#ifndef Z_SOLO\n \n #ifdef SYS16BIT\n \n@@ -316,3 +320,5 @@ void ZLIB_INTERNAL zcfree (opaque, ptr)\n }\n \n #endif /* MY_ZCALLOC */\n+\n+#endif /* !Z_SOLO */"}, {"sha": "ed6b127e1e400cc4e99a49e1394f0696451fc8b9", "filename": "zlib/zutil.h", "status": "modified", "additions": 38, "deletions": 60, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzutil.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9acb8ddf3e7cf312de229eae11e0a1df29548ec9/zlib%2Fzutil.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzutil.h?ref=9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "patch": "@@ -1,5 +1,5 @@\n /* zutil.h -- internal interface and configuration of the compression library\n- * Copyright (C) 1995-2010 Jean-loup Gailly.\n+ * Copyright (C) 1995-2012 Jean-loup Gailly.\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -13,22 +13,26 @@\n #ifndef ZUTIL_H\n #define ZUTIL_H\n \n-#if ((__GNUC__-0) * 10 + __GNUC_MINOR__-0 >= 33) && !defined(NO_VIZ)\n+#ifdef HAVE_HIDDEN\n #  define ZLIB_INTERNAL __attribute__((visibility (\"hidden\")))\n #else\n #  define ZLIB_INTERNAL\n #endif\n \n #include \"zlib.h\"\n \n-#ifdef STDC\n+#if defined(STDC) && !defined(Z_SOLO)\n #  if !(defined(_WIN32_WCE) && defined(_MSC_VER))\n #    include <stddef.h>\n #  endif\n #  include <string.h>\n #  include <stdlib.h>\n #endif\n \n+#ifdef Z_SOLO\n+   typedef long ptrdiff_t;  /* guess -- will be caught if guess is wrong */\n+#endif\n+\n #ifndef local\n #  define local static\n #endif\n@@ -78,16 +82,18 @@ extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */\n \n #if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))\n #  define OS_CODE  0x00\n-#  if defined(__TURBOC__) || defined(__BORLANDC__)\n-#    if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))\n-       /* Allow compilation with ANSI keywords only enabled */\n-       void _Cdecl farfree( void *block );\n-       void *_Cdecl farmalloc( unsigned long nbytes );\n-#    else\n-#      include <alloc.h>\n+#  ifndef Z_SOLO\n+#    if defined(__TURBOC__) || defined(__BORLANDC__)\n+#      if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))\n+         /* Allow compilation with ANSI keywords only enabled */\n+         void _Cdecl farfree( void *block );\n+         void *_Cdecl farmalloc( unsigned long nbytes );\n+#      else\n+#        include <alloc.h>\n+#      endif\n+#    else /* MSC or DJGPP */\n+#      include <malloc.h>\n #    endif\n-#  else /* MSC or DJGPP */\n-#    include <malloc.h>\n #  endif\n #endif\n \n@@ -107,18 +113,20 @@ extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */\n \n #ifdef OS2\n #  define OS_CODE  0x06\n-#  ifdef M_I86\n+#  if defined(M_I86) && !defined(Z_SOLO)\n #    include <malloc.h>\n #  endif\n #endif\n \n #if defined(MACOS) || defined(TARGET_OS_MAC)\n #  define OS_CODE  0x07\n-#  if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os\n-#    include <unix.h> /* for fdopen */\n-#  else\n-#    ifndef fdopen\n-#      define fdopen(fd,mode) NULL /* No fdopen() */\n+#  ifndef Z_SOLO\n+#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os\n+#      include <unix.h> /* for fdopen */\n+#    else\n+#      ifndef fdopen\n+#        define fdopen(fd,mode) NULL /* No fdopen() */\n+#      endif\n #    endif\n #  endif\n #endif\n@@ -153,14 +161,14 @@ extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */\n #  endif\n #endif\n \n-#if defined(__BORLANDC__)\n+#if defined(__BORLANDC__) && !defined(MSDOS)\n   #pragma warn -8004\n   #pragma warn -8008\n   #pragma warn -8066\n #endif\n \n /* provide prototypes for these when building zlib without LFS */\n-#if !defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0\n+#if !defined(_WIN32) && (!defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0)\n     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));\n     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));\n #endif\n@@ -177,42 +185,7 @@ extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */\n \n          /* functions */\n \n-#if defined(STDC99) || (defined(__TURBOC__) && __TURBOC__ >= 0x550)\n-#  ifndef HAVE_VSNPRINTF\n-#    define HAVE_VSNPRINTF\n-#  endif\n-#endif\n-#if defined(__CYGWIN__)\n-#  ifndef HAVE_VSNPRINTF\n-#    define HAVE_VSNPRINTF\n-#  endif\n-#endif\n-#ifndef HAVE_VSNPRINTF\n-#  ifdef MSDOS\n-     /* vsnprintf may exist on some MS-DOS compilers (DJGPP?),\n-        but for now we just assume it doesn't. */\n-#    define NO_vsnprintf\n-#  endif\n-#  ifdef __TURBOC__\n-#    define NO_vsnprintf\n-#  endif\n-#  ifdef WIN32\n-     /* In Win32, vsnprintf is available as the \"non-ANSI\" _vsnprintf. */\n-#    if !defined(vsnprintf) && !defined(NO_vsnprintf)\n-#      if !defined(_MSC_VER) || ( defined(_MSC_VER) && _MSC_VER < 1500 )\n-#         define vsnprintf _vsnprintf\n-#      endif\n-#    endif\n-#  endif\n-#  ifdef __SASC\n-#    define NO_vsnprintf\n-#  endif\n-#endif\n-#ifdef VMS\n-#  define NO_vsnprintf\n-#endif\n-\n-#if defined(pyr)\n+#if defined(pyr) || defined(Z_SOLO)\n #  define NO_MEMCPY\n #endif\n #if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)\n@@ -261,14 +234,19 @@ extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */\n #  define Tracecv(c,x)\n #endif\n \n-\n-voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,\n-                        unsigned size));\n-void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));\n+#ifndef Z_SOLO\n+   voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,\n+                                    unsigned size));\n+   void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));\n+#endif\n \n #define ZALLOC(strm, items, size) \\\n            (*((strm)->zalloc))((strm)->opaque, (items), (size))\n #define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))\n #define TRY_FREE(s, p) {if (p) ZFREE(s, p);}\n \n+/* Reverse the bytes in a 32-bit value */\n+#define ZSWAP32(q) ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \\\n+                    (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))\n+\n #endif /* ZUTIL_H */"}]}