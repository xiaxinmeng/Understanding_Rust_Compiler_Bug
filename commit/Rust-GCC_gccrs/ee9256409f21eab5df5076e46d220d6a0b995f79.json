{"sha": "ee9256409f21eab5df5076e46d220d6a0b995f79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU5MjU2NDA5ZjIxZWFiNWRmNTA3NmU0NmQyMjBkNmEwYjk5NWY3OQ==", "commit": {"author": {"name": "Lewis Hyatt", "email": "lhyatt@gmail.com", "date": "2019-12-09T20:03:47Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2019-12-09T20:03:47Z"}, "message": "Byte vs column awareness for diagnostic-show-locus.c (PR 49973)\n\ncontrib/ChangeLog\n\n2019-12-09  Lewis Hyatt  <lhyatt@gmail.com>\n\n\tPR preprocessor/49973\n\t* unicode/from_glibc/unicode_utils.py: Support script from\n\tglibc (commit 464cd3) to extract character widths from Unicode data\n\tfiles.\n\t* unicode/from_glibc/utf8_gen.py: Likewise.\n\t* unicode/UnicodeData.txt: Unicode v. 12.1.0 data file.\n\t* unicode/EastAsianWidth.txt: Likewise.\n\t* unicode/PropList.txt: Likewise.\n\t* unicode/gen_wcwidth.py: New utility to generate\n\tlibcpp/generated_cpp_wcwidth.h with help from the glibc support\n\tscripts and the Unicode data files.\n\t* unicode/unicode-license.txt: Added.\n\t* unicode/README: New explanatory file.\n\nlibcpp/ChangeLog\n\n2019-12-09  Lewis Hyatt  <lhyatt@gmail.com>\n\n\tPR preprocessor/49973\n\t* generated_cpp_wcwidth.h: New file generated by\n\t../contrib/unicode/gen_wcwidth.py, supports new cpp_wcwidth function.\n\t* charset.c (compute_next_display_width): New function to help\n\timplement display columns.\n\t(cpp_byte_column_to_display_column): Likewise.\n\t(cpp_display_column_to_byte_column): Likewise.\n\t(cpp_wcwidth): Likewise.\n\t* include/cpplib.h (cpp_byte_column_to_display_column): Declare.\n\t(cpp_display_column_to_byte_column): Declare.\n\t(cpp_wcwidth): Declare.\n\t(cpp_display_width): New function.\n\ngcc/ChangeLog\n\n2019-12-09  Lewis Hyatt  <lhyatt@gmail.com>\n\n\tPR preprocessor/49973\n\t* input.c (location_compute_display_column): New function to help with\n\tmultibyte awareness in diagnostics.\n\t(test_cpp_utf8): New self-test.\n\t(input_c_tests): Call the new test.\n\t* input.h (location_compute_display_column): Declare.\n\t* diagnostic-show-locus.c: Pervasive changes to add multibyte awareness\n\tto all classes and functions.\n\t(enum column_unit): New enum.\n\t(class exploc_with_display_col): New class.\n\t(class layout_point): Convert m_column member to array m_columns[2].\n\t(layout_range::contains_point): Add col_unit argument.\n\t(test_layout_range_for_single_point): Pass new argument.\n\t(test_layout_range_for_single_line): Likewise.\n\t(test_layout_range_for_multiple_lines): Likewise.\n\t(line_bounds::convert_to_display_cols): New function.\n\t(layout::get_state_at_point): Add col_unit argument.\n\t(make_range): Use empty filename rather than dummy filename.\n\t(get_line_width_without_trailing_whitespace): Rename to...\n\t(get_line_bytes_without_trailing_whitespace): ...this.\n\t(test_get_line_width_without_trailing_whitespace): Rename to...\n\t(test_get_line_bytes_without_trailing_whitespace): ...this.\n\t(class layout): m_exploc changed to exploc_with_display_col from\n\tplain expanded_location.\n\t(layout::get_linenum_width): New accessor member function.\n\t(layout::get_x_offset_display): Likewise.\n\t(layout::calculate_linenum_width): New subroutine for the constuctor.\n\t(layout::calculate_x_offset_display): Likewise.\n\t(layout::layout): Use the new subroutines. Add multibyte awareness.\n\t(layout::print_source_line): Add multibyte awareness.\n\t(layout::print_line): Likewise.\n\t(layout::print_annotation_line): Likewise.\n\t(line_label::line_label): Likewise.\n\t(layout::print_any_labels): Likewise.\n\t(layout::annotation_line_showed_range_p): Likewise.\n\t(get_printed_columns): Likewise.\n\t(class line_label): Rename m_length to m_display_width.\n\t(get_affected_columns): Rename to...\n\t(get_affected_range): ...this; add col_unit argument and multibyte\n\tawareness.\n\t(class correction): Add m_affected_bytes and m_display_cols\n\tmembers.  Rename m_len to m_byte_length for clarity.  Add multibyte\n\tawareness throughout.\n\t(correction::insertion_p): Add multibyte awareness.\n\t(correction::compute_display_cols): New function.\n\t(correction::ensure_terminated): Use new member name m_byte_length.\n\t(line_corrections::add_hint): Add multibyte awareness.\n\t(layout::print_trailing_fixits): Likewise.\n\t(layout::get_x_bound_for_row): Likewise.\n\t(test_one_liner_simple_caret_utf8): New self-test analogous to the one\n\twith _utf8 suffix removed, testing multibyte awareness.\n\t(test_one_liner_caret_and_range_utf8): Likewise.\n\t(test_one_liner_multiple_carets_and_ranges_utf8): Likewise.\n\t(test_one_liner_fixit_insert_before_utf8): Likewise.\n\t(test_one_liner_fixit_insert_after_utf8): Likewise.\n\t(test_one_liner_fixit_remove_utf8): Likewise.\n\t(test_one_liner_fixit_replace_utf8): Likewise.\n\t(test_one_liner_fixit_replace_non_equal_range_utf8): Likewise.\n\t(test_one_liner_fixit_replace_equal_secondary_range_utf8): Likewise.\n\t(test_one_liner_fixit_validation_adhoc_locations_utf8): Likewise.\n\t(test_one_liner_many_fixits_1_utf8): Likewise.\n\t(test_one_liner_many_fixits_2_utf8): Likewise.\n\t(test_one_liner_labels_utf8): Likewise.\n\t(test_diagnostic_show_locus_one_liner_utf8): Likewise.\n\t(test_overlapped_fixit_printing_utf8): Likewise.\n\t(test_overlapped_fixit_printing): Adapt for changes to\n\tget_affected_columns, get_printed_columns and class corrections.\n\t(test_overlapped_fixit_printing_2): Likewise.\n\t(test_linenum_sep): New constant.\n\t(test_left_margin): Likewise.\n\t(test_offset_impl): Helper function for new test.\n\t(test_layout_x_offset_display_utf8): New test.\n\t(diagnostic_show_locus_c_tests): Call new tests.\n\ngcc/testsuite/ChangeLog:\n\n2019-12-09  Lewis Hyatt  <lhyatt@gmail.com>\n\n\tPR preprocessor/49973\n\t* gcc.dg/plugin/diagnostic_plugin_test_show_locus.c\n\t(test_show_locus): Tweak so that expected output is the same as\n\tbefore the diagnostic-show-locus.c changes.\n\t* gcc.dg/cpp/pr66415-1.c: Likewise.\n\nFrom-SVN: r279137", "tree": {"sha": "68053762905d3e64e86dc0db19b7d1f3d65b5ba8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68053762905d3e64e86dc0db19b7d1f3d65b5ba8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee9256409f21eab5df5076e46d220d6a0b995f79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee9256409f21eab5df5076e46d220d6a0b995f79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee9256409f21eab5df5076e46d220d6a0b995f79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee9256409f21eab5df5076e46d220d6a0b995f79/comments", "author": null, "committer": null, "parents": [{"sha": "763c9f4a8544318998c7adf04e4c92e9a4b85614", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/763c9f4a8544318998c7adf04e4c92e9a4b85614", "html_url": "https://github.com/Rust-GCC/gccrs/commit/763c9f4a8544318998c7adf04e4c92e9a4b85614"}], "stats": {"total": 40307, "additions": 40043, "deletions": 264}, "files": [{"sha": "e3fef3273ffed7dc12ffcd697ccdff3fdb5cbf2a", "filename": "contrib/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -1,3 +1,19 @@\n+2019-12-09  Lewis Hyatt  <lhyatt@gmail.com>\n+\n+\tPR preprocessor/49973\n+\t* unicode/from_glibc/unicode_utils.py: Support script from\n+\tglibc (commit 464cd3) to extract character widths from Unicode data\n+\tfiles.\n+\t* unicode/from_glibc/utf8_gen.py: Likewise.\n+\t* unicode/UnicodeData.txt: Unicode v. 12.1.0 data file.\n+\t* unicode/EastAsianWidth.txt: Likewise.\n+\t* unicode/PropList.txt: Likewise.\n+\t* unicode/gen_wcwidth.py: New utility to generate\n+\tlibcpp/generated_cpp_wcwidth.h with help from the glibc support\n+\tscripts and the Unicode data files.\n+\t* unicode/unicode-license.txt: Added.\n+\t* unicode/README: New explanatory file.\n+\n 2019-12-07  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* texi2pod.pl: Handle @headitems in @multitables, printing them"}, {"sha": "94d55d6654af552459102a347a1eacba30dbc7ab", "filename": "contrib/unicode/EastAsianWidth.txt", "status": "added", "additions": 2473, "deletions": 0, "changes": 2473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2Funicode%2FEastAsianWidth.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2Funicode%2FEastAsianWidth.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Funicode%2FEastAsianWidth.txt?ref=ee9256409f21eab5df5076e46d220d6a0b995f79"}, {"sha": "4394602fea7a273068e2990e5e369572716ff09d", "filename": "contrib/unicode/PropList.txt", "status": "added", "additions": 1666, "deletions": 0, "changes": 1666, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2Funicode%2FPropList.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2Funicode%2FPropList.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Funicode%2FPropList.txt?ref=ee9256409f21eab5df5076e46d220d6a0b995f79"}, {"sha": "01ae2c1e1afe7c23037ddfa9f2da522eb4b73017", "filename": "contrib/unicode/README", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2Funicode%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2Funicode%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Funicode%2FREADME?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -0,0 +1,44 @@\n+This directory contains a mechanism for GCC to have its own internal\n+implementation of wcwidth functionality.  (cpp_wcwidth () in libcpp/charset.c).\n+\n+The idea is to produce the necessary lookup table\n+(../../libcpp/generated_cpp_wcwidth.h) in a reproducible way, starting from the\n+following files that are distributed by the Unicode Consortium:\n+\n+ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n+ftp://ftp.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n+ftp://ftp.unicode.org/Public/UNIDATA/PropList.txt\n+\n+These three files have been added to source control in this directory;\n+please see unicode-license.txt for the relevant copyright information.\n+\n+In order to keep in sync with glibc's wcwidth as much as possible, it is\n+desirable for the logic that processes the Unicode data to be the same as\n+glibc's.  To that end, we also put in this directory, in the from_glibc/\n+directory, the glibc python code that implements their logic.  This code was\n+copied verbatim from glibc, and it can be updated at any time from the glibc\n+source code repository.  The files copied from that respository are:\n+\n+localedata/unicode-gen/unicode_utils.py\n+localedata/unicode-gen/utf8_gen.py\n+\n+And the most recent versions added to GCC are from glibc git commit:\n+2a764c6ee848dfe92cb2921ed3b14085f15d9e79\n+\n+Finally, the script gen_wcwidth.py found here contains the GCC-specific code to\n+map glibc's output to the lookup tables we require.  This script should not need\n+to change, unless there are structural changes to the Unicode data files or to\n+the glibc code.\n+\n+The procedure to update GCC's wcwidth tables is the following:\n+\n+1.  Update the three Unicode data files from the above URLs.\n+\n+2.  Update the two glibc files in from_glibc/ from glibc's git.  Update\n+    the commit number above in this README.\n+\n+3.  Run ./gen_wcwidth.py X.Y > ../../libcpp/generated_cpp_wcwidth.h\n+    (where X.Y is the version of the Unicode standard corresponding to the\n+    Unicode data files being used, most recently, 12.1).\n+\n+After that, GCC's wcwidth will match the most recent glibc."}, {"sha": "e65aec52f71ef6242b104d252fea5b4f9854938a", "filename": "contrib/unicode/UnicodeData.txt", "status": "added", "additions": 32841, "deletions": 0, "changes": 32841, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2Funicode%2FUnicodeData.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2Funicode%2FUnicodeData.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Funicode%2FUnicodeData.txt?ref=ee9256409f21eab5df5076e46d220d6a0b995f79"}, {"sha": "a9e94cce4189bd7c7d6c04c9a014ce4fddbd8fbe", "filename": "contrib/unicode/from_glibc/unicode_utils.py", "status": "added", "additions": 527, "deletions": 0, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2Funicode%2Ffrom_glibc%2Funicode_utils.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2Funicode%2Ffrom_glibc%2Funicode_utils.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Funicode%2Ffrom_glibc%2Funicode_utils.py?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -0,0 +1,527 @@\n+# Utilities to generate Unicode data for glibc from upstream Unicode data.\n+#\n+# Copyright (C) 2014-2019 Free Software Foundation, Inc.\n+# This file is part of the GNU C Library.\n+#\n+# The GNU C Library is free software; you can redistribute it and/or\n+# modify it under the terms of the GNU Lesser General Public\n+# License as published by the Free Software Foundation; either\n+# version 2.1 of the License, or (at your option) any later version.\n+#\n+# The GNU C Library is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# Lesser General Public License for more details.\n+#\n+# You should have received a copy of the GNU Lesser General Public\n+# License along with the GNU C Library; if not, see\n+# <https://www.gnu.org/licenses/>.\n+\n+'''\n+This module contains utilities used by the scripts to generate\n+Unicode data for glibc from upstream Unicode data files.\n+'''\n+\n+import sys\n+import re\n+\n+\n+# Common locale header.\n+COMMENT_HEADER = \"\"\"\n+% This file is part of the GNU C Library and contains locale data.\n+% The Free Software Foundation does not claim any copyright interest\n+% in the locale data contained in this file.  The foregoing does not\n+% affect the license of the GNU C Library as a whole.  It does not\n+% exempt you from the conditions of the license if your use would\n+% otherwise be governed by that license.\n+\"\"\"\n+\n+# Dictionary holding the entire contents of the UnicodeData.txt file\n+#\n+# Contents of this dictionary look like this:\n+#\n+# {0: {'category': 'Cc',\n+#      'title': None,\n+#      'digit': '',\n+#      'name': '<control>',\n+#      'bidi': 'BN',\n+#      'combining': '0',\n+#      'comment': '',\n+#      'oldname': 'NULL',\n+#      'decomposition': '',\n+#      'upper': None,\n+#      'mirrored': 'N',\n+#      'lower': None,\n+#      'decdigit': '',\n+#      'numeric': ''},\n+#      \u2026\n+# }\n+UNICODE_ATTRIBUTES = {}\n+\n+# Dictionary holding the entire contents of the DerivedCoreProperties.txt file\n+#\n+# Contents of this dictionary look like this:\n+#\n+# {917504: ['Default_Ignorable_Code_Point'],\n+#  917505: ['Case_Ignorable', 'Default_Ignorable_Code_Point'],\n+#  \u2026\n+# }\n+DERIVED_CORE_PROPERTIES = {}\n+\n+# Dictionary holding the entire contents of the EastAsianWidths.txt file\n+#\n+# Contents of this dictionary look like this:\n+#\n+# {0: 'N', \u2026 , 45430: 'W', \u2026}\n+EAST_ASIAN_WIDTHS = {}\n+\n+def fill_attribute(code_point, fields):\n+    '''Stores in UNICODE_ATTRIBUTES[code_point] the values from the fields.\n+\n+    One entry in the UNICODE_ATTRIBUTES dictionary represents one line\n+    in the UnicodeData.txt file.\n+\n+    '''\n+    UNICODE_ATTRIBUTES[code_point] =  {\n+        'name': fields[1],          # Character name\n+        'category': fields[2],      # General category\n+        'combining': fields[3],     # Canonical combining classes\n+        'bidi': fields[4],          # Bidirectional category\n+        'decomposition': fields[5], # Character decomposition mapping\n+        'decdigit': fields[6],      # Decimal digit value\n+        'digit': fields[7],         # Digit value\n+        'numeric': fields[8],       # Numeric value\n+        'mirrored': fields[9],      # mirrored\n+        'oldname': fields[10],      # Old Unicode 1.0 name\n+        'comment': fields[11],      # comment\n+        # Uppercase mapping\n+        'upper': int(fields[12], 16) if fields[12] else None,\n+        # Lowercase mapping\n+        'lower': int(fields[13], 16) if fields[13] else None,\n+        # Titlecase mapping\n+        'title': int(fields[14], 16) if fields[14] else None,\n+    }\n+\n+def fill_attributes(filename):\n+    '''Stores the entire contents of the UnicodeData.txt file\n+    in the UNICODE_ATTRIBUTES dictionary.\n+\n+    A typical line for a single code point in UnicodeData.txt looks\n+    like this:\n+\n+    0041;LATIN CAPITAL LETTER A;Lu;0;L;;;;;N;;;;0061;\n+\n+    Code point ranges are indicated by pairs of lines like this:\n+\n+    4E00;<CJK Ideograph, First>;Lo;0;L;;;;;N;;;;;\n+    9FCC;<CJK Ideograph, Last>;Lo;0;L;;;;;N;;;;;\n+    '''\n+    with open(filename, mode='r') as unicode_data_file:\n+        fields_start = []\n+        for line in unicode_data_file:\n+            fields = line.strip().split(';')\n+            if len(fields) != 15:\n+                sys.stderr.write(\n+                    'short line in file \"%(f)s\": %(l)s\\n' %{\n+                    'f': filename, 'l': line})\n+                exit(1)\n+            if fields[2] == 'Cs':\n+                # Surrogates are UTF-16 artefacts,\n+                # not real characters. Ignore them.\n+                fields_start = []\n+                continue\n+            if fields[1].endswith(', First>'):\n+                fields_start = fields\n+                fields_start[1] = fields_start[1].split(',')[0][1:]\n+                continue\n+            if fields[1].endswith(', Last>'):\n+                fields[1] = fields[1].split(',')[0][1:]\n+                if fields[1:] != fields_start[1:]:\n+                    sys.stderr.write(\n+                        'broken code point range in file \"%(f)s\": %(l)s\\n' %{\n+                            'f': filename, 'l': line})\n+                    exit(1)\n+                for code_point in range(\n+                        int(fields_start[0], 16),\n+                        int(fields[0], 16)+1):\n+                    fill_attribute(code_point, fields)\n+                fields_start = []\n+                continue\n+            fill_attribute(int(fields[0], 16), fields)\n+            fields_start = []\n+\n+def fill_derived_core_properties(filename):\n+    '''Stores the entire contents of the DerivedCoreProperties.txt file\n+    in the DERIVED_CORE_PROPERTIES dictionary.\n+\n+    Lines in DerivedCoreProperties.txt are either a code point range like\n+    this:\n+\n+    0061..007A    ; Lowercase # L&  [26] LATIN SMALL LETTER A..LATIN SMALL LETTER Z\n+\n+    or a single code point like this:\n+\n+    00AA          ; Lowercase # Lo       FEMININE ORDINAL INDICATOR\n+\n+    '''\n+    with open(filename, mode='r') as derived_core_properties_file:\n+        for line in derived_core_properties_file:\n+            match = re.match(\n+                r'^(?P<codepoint1>[0-9A-F]{4,6})'\n+                + r'(?:\\.\\.(?P<codepoint2>[0-9A-F]{4,6}))?'\n+                + r'\\s*;\\s*(?P<property>[a-zA-Z_]+)',\n+                line)\n+            if not match:\n+                continue\n+            start = match.group('codepoint1')\n+            end = match.group('codepoint2')\n+            if not end:\n+                end = start\n+            for code_point in range(int(start, 16), int(end, 16)+1):\n+                prop = match.group('property')\n+                if code_point in DERIVED_CORE_PROPERTIES:\n+                    DERIVED_CORE_PROPERTIES[code_point].append(prop)\n+                else:\n+                    DERIVED_CORE_PROPERTIES[code_point] = [prop]\n+\n+def fill_east_asian_widths(filename):\n+    '''Stores the entire contents of the EastAsianWidths.txt file\n+    in the EAST_ASIAN_WIDTHS dictionary.\n+\n+    Lines in EastAsianWidths.txt are either a code point range like\n+    this:\n+\n+    9FCD..9FFF;W     # Cn    [51] <reserved-9FCD>..<reserved-9FFF>\n+\n+    or a single code point like this:\n+\n+    A015;W           # Lm         YI SYLLABLE WU\n+    '''\n+    with open(filename, mode='r') as east_asian_widths_file:\n+        for line in east_asian_widths_file:\n+            match = re.match(\n+                r'^(?P<codepoint1>[0-9A-F]{4,6})'\n+                +r'(?:\\.\\.(?P<codepoint2>[0-9A-F]{4,6}))?'\n+                +r'\\s*;\\s*(?P<property>[a-zA-Z]+)',\n+                line)\n+            if not match:\n+                continue\n+            start = match.group('codepoint1')\n+            end = match.group('codepoint2')\n+            if not end:\n+                end = start\n+            for code_point in range(int(start, 16), int(end, 16)+1):\n+                EAST_ASIAN_WIDTHS[code_point] = match.group('property')\n+\n+def to_upper(code_point):\n+    '''Returns the code point of the uppercase version\n+    of the given code point'''\n+    if (UNICODE_ATTRIBUTES[code_point]['name']\n+        and UNICODE_ATTRIBUTES[code_point]['upper']):\n+        return UNICODE_ATTRIBUTES[code_point]['upper']\n+    else:\n+        return code_point\n+\n+def to_lower(code_point):\n+    '''Returns the code point of the lowercase version\n+    of the given code point'''\n+    if (UNICODE_ATTRIBUTES[code_point]['name']\n+        and UNICODE_ATTRIBUTES[code_point]['lower']):\n+        return UNICODE_ATTRIBUTES[code_point]['lower']\n+    else:\n+        return code_point\n+\n+def to_upper_turkish(code_point):\n+    '''Returns the code point of the Turkish uppercase version\n+    of the given code point'''\n+    if code_point == 0x0069:\n+        return 0x0130\n+    return to_upper(code_point)\n+\n+def to_lower_turkish(code_point):\n+    '''Returns the code point of the Turkish lowercase version\n+    of the given code point'''\n+    if code_point == 0x0049:\n+        return 0x0131\n+    return to_lower(code_point)\n+\n+def to_title(code_point):\n+    '''Returns the code point of the titlecase version\n+    of the given code point'''\n+    if (UNICODE_ATTRIBUTES[code_point]['name']\n+        and UNICODE_ATTRIBUTES[code_point]['title']):\n+        return UNICODE_ATTRIBUTES[code_point]['title']\n+    else:\n+        return code_point\n+\n+def is_upper(code_point):\n+    '''Checks whether the character with this code point is uppercase'''\n+    return (to_lower(code_point) != code_point\n+            or (code_point in DERIVED_CORE_PROPERTIES\n+                and 'Uppercase' in DERIVED_CORE_PROPERTIES[code_point]))\n+\n+def is_lower(code_point):\n+    '''Checks whether the character with this code point is lowercase'''\n+    # Some characters are defined as \u201cLowercase\u201d in\n+    # DerivedCoreProperties.txt but do not have a mapping to upper\n+    # case. For example, \ua730 U+A72F \u201cLATIN LETTER SMALL CAPITAL F\u201d is\n+    # one of these.\n+    return (to_upper(code_point) != code_point\n+            # <U00DF> is lowercase, but without simple to_upper mapping.\n+            or code_point == 0x00DF\n+            or (code_point in DERIVED_CORE_PROPERTIES\n+                and 'Lowercase' in DERIVED_CORE_PROPERTIES[code_point]))\n+\n+def is_alpha(code_point):\n+    '''Checks whether the character with this code point is alphabetic'''\n+    return ((code_point in DERIVED_CORE_PROPERTIES\n+             and\n+             'Alphabetic' in DERIVED_CORE_PROPERTIES[code_point])\n+            or\n+            # Consider all the non-ASCII digits as alphabetic.\n+            # ISO C 99 forbids us to have them in category \u201cdigit\u201d,\n+            # but we want iswalnum to return true on them.\n+            (UNICODE_ATTRIBUTES[code_point]['category'] == 'Nd'\n+             and not (code_point >= 0x0030 and code_point <= 0x0039)))\n+\n+def is_digit(code_point):\n+    '''Checks whether the character with this code point is a digit'''\n+    if False:\n+        return (UNICODE_ATTRIBUTES[code_point]['name']\n+                and UNICODE_ATTRIBUTES[code_point]['category'] == 'Nd')\n+        # Note: U+0BE7..U+0BEF and U+1369..U+1371 are digit systems without\n+        # a zero.  Must add <0> in front of them by hand.\n+    else:\n+        # SUSV2 gives us some freedom for the \"digit\" category, but ISO C 99\n+        # takes it away:\n+        # 7.25.2.1.5:\n+        #    The iswdigit function tests for any wide character that\n+        #    corresponds to a decimal-digit character (as defined in 5.2.1).\n+        # 5.2.1:\n+        #    the 10 decimal digits 0 1 2 3 4 5 6 7 8 9\n+        return (code_point >= 0x0030 and code_point <= 0x0039)\n+\n+def is_outdigit(code_point):\n+    '''Checks whether the character with this code point is outdigit'''\n+    return (code_point >= 0x0030 and code_point <= 0x0039)\n+\n+def is_blank(code_point):\n+    '''Checks whether the character with this code point is blank'''\n+    return (code_point == 0x0009 # '\\t'\n+            # Category Zs without mention of '<noBreak>'\n+            or (UNICODE_ATTRIBUTES[code_point]['name']\n+                and UNICODE_ATTRIBUTES[code_point]['category'] == 'Zs'\n+                and '<noBreak>' not in\n+                UNICODE_ATTRIBUTES[code_point]['decomposition']))\n+\n+def is_space(code_point):\n+    '''Checks whether the character with this code point is a space'''\n+    # Don\u2019t make U+00A0 a space. Non-breaking space means that all programs\n+    # should treat it like a punctuation character, not like a space.\n+    return (code_point == 0x0020 # ' '\n+            or code_point == 0x000C # '\\f'\n+            or code_point == 0x000A # '\\n'\n+            or code_point == 0x000D # '\\r'\n+            or code_point == 0x0009 # '\\t'\n+            or code_point == 0x000B # '\\v'\n+            # Categories Zl, Zp, and Zs without mention of \"<noBreak>\"\n+            or (UNICODE_ATTRIBUTES[code_point]['name']\n+                and\n+                (UNICODE_ATTRIBUTES[code_point]['category'] in ['Zl', 'Zp']\n+                 or\n+                 (UNICODE_ATTRIBUTES[code_point]['category'] in ['Zs']\n+                  and\n+                  '<noBreak>' not in\n+                  UNICODE_ATTRIBUTES[code_point]['decomposition']))))\n+\n+def is_cntrl(code_point):\n+    '''Checks whether the character with this code point is\n+    a control character'''\n+    return (UNICODE_ATTRIBUTES[code_point]['name']\n+            and (UNICODE_ATTRIBUTES[code_point]['name'] == '<control>'\n+                 or\n+                 UNICODE_ATTRIBUTES[code_point]['category'] in ['Zl', 'Zp']))\n+\n+def is_xdigit(code_point):\n+    '''Checks whether the character with this code point is\n+    a hexadecimal digit'''\n+    if False:\n+        return (is_digit(code_point)\n+                or (code_point >= 0x0041 and code_point <= 0x0046)\n+                or (code_point >= 0x0061 and code_point <= 0x0066))\n+    else:\n+        # SUSV2 gives us some freedom for the \"xdigit\" category, but ISO C 99\n+        # takes it away:\n+        # 7.25.2.1.12:\n+        #    The iswxdigit function tests for any wide character that\n+        #    corresponds to a hexadecimal-digit character (as defined\n+        #    in 6.4.4.1).\n+        # 6.4.4.1:\n+        #    hexadecimal-digit: one of\n+        #    0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F\n+        return ((code_point >= 0x0030 and code_point  <= 0x0039)\n+                or (code_point >= 0x0041 and code_point <= 0x0046)\n+                or (code_point >= 0x0061 and code_point <= 0x0066))\n+\n+def is_graph(code_point):\n+    '''Checks whether the character with this code point is\n+    a graphical character'''\n+    return (UNICODE_ATTRIBUTES[code_point]['name']\n+            and UNICODE_ATTRIBUTES[code_point]['name'] != '<control>'\n+            and not is_space(code_point))\n+\n+def is_print(code_point):\n+    '''Checks whether the character with this code point is printable'''\n+    return (UNICODE_ATTRIBUTES[code_point]['name']\n+            and UNICODE_ATTRIBUTES[code_point]['name'] != '<control>'\n+            and UNICODE_ATTRIBUTES[code_point]['category'] not in ['Zl', 'Zp'])\n+\n+def is_punct(code_point):\n+    '''Checks whether the character with this code point is punctuation'''\n+    if False:\n+        return (UNICODE_ATTRIBUTES[code_point]['name']\n+                and UNICODE_ATTRIBUTES[code_point]['category'].startswith('P'))\n+    else:\n+        # The traditional POSIX definition of punctuation is every graphic,\n+        # non-alphanumeric character.\n+        return (is_graph(code_point)\n+                and not is_alpha(code_point)\n+                and not is_digit(code_point))\n+\n+def is_combining(code_point):\n+    '''Checks whether the character with this code point is\n+    a combining character'''\n+    # Up to Unicode 3.0.1 we took the Combining property from the PropList.txt\n+    # file. In 3.0.1 it was identical to the union of the general categories\n+    # \"Mn\", \"Mc\", \"Me\". In Unicode 3.1 this property has been dropped from the\n+    # PropList.txt file, so we take the latter definition.\n+    return (UNICODE_ATTRIBUTES[code_point]['name']\n+            and\n+            UNICODE_ATTRIBUTES[code_point]['category'] in ['Mn', 'Mc', 'Me'])\n+\n+def is_combining_level3(code_point):\n+    '''Checks whether the character with this code point is\n+    a combining level3 character'''\n+    return (is_combining(code_point)\n+            and\n+            int(UNICODE_ATTRIBUTES[code_point]['combining']) in range(0, 200))\n+\n+def ucs_symbol(code_point):\n+    '''Return the UCS symbol string for a Unicode character.'''\n+    if code_point < 0x10000:\n+        return '<U{:04X}>'.format(code_point)\n+    else:\n+        return '<U{:08X}>'.format(code_point)\n+\n+def ucs_symbol_range(code_point_low, code_point_high):\n+    '''Returns a string UCS symbol string for a code point range.\n+\n+    Example:\n+\n+    <U0041>..<U005A>\n+    '''\n+    return ucs_symbol(code_point_low) + '..' + ucs_symbol(code_point_high)\n+\n+def verifications():\n+    '''Tests whether the is_* functions observe the known restrictions'''\n+    for code_point in sorted(UNICODE_ATTRIBUTES):\n+        # toupper restriction: \"Only characters specified for the keywords\n+        # lower and upper shall be specified.\n+        if (to_upper(code_point) != code_point\n+            and not (is_lower(code_point) or is_upper(code_point))):\n+            sys.stderr.write(\n+                ('%(sym)s is not upper|lower '\n+                 + 'but toupper(0x%(c)04X) = 0x%(uc)04X\\n') %{\n+                    'sym': ucs_symbol(code_point),\n+                    'c': code_point,\n+                    'uc': to_upper(code_point)})\n+        # tolower restriction: \"Only characters specified for the keywords\n+        # lower and upper shall be specified.\n+        if (to_lower(code_point) != code_point\n+            and not (is_lower(code_point) or is_upper(code_point))):\n+            sys.stderr.write(\n+                ('%(sym)s is not upper|lower '\n+                 + 'but tolower(0x%(c)04X) = 0x%(uc)04X\\n') %{\n+                    'sym': ucs_symbol(code_point),\n+                    'c': code_point,\n+                    'uc': to_lower(code_point)})\n+        # alpha restriction: \"Characters classified as either upper or lower\n+        # shall automatically belong to this class.\n+        if ((is_lower(code_point) or is_upper(code_point))\n+             and not is_alpha(code_point)):\n+            sys.stderr.write('%(sym)s is upper|lower but not alpha\\n' %{\n+                'sym': ucs_symbol(code_point)})\n+        # alpha restriction: \u201cNo character specified for the keywords cntrl,\n+        # digit, punct or space shall be specified.\u201d\n+        if (is_alpha(code_point) and is_cntrl(code_point)):\n+            sys.stderr.write('%(sym)s is alpha and cntrl\\n' %{\n+                'sym': ucs_symbol(code_point)})\n+        if (is_alpha(code_point) and is_digit(code_point)):\n+            sys.stderr.write('%(sym)s is alpha and digit\\n' %{\n+                'sym': ucs_symbol(code_point)})\n+        if (is_alpha(code_point) and is_punct(code_point)):\n+            sys.stderr.write('%(sym)s is alpha and punct\\n' %{\n+                'sym': ucs_symbol(code_point)})\n+        if (is_alpha(code_point) and is_space(code_point)):\n+            sys.stderr.write('%(sym)s is alpha and space\\n' %{\n+                'sym': ucs_symbol(code_point)})\n+        # space restriction: \u201cNo character specified for the keywords upper,\n+        # lower, alpha, digit, graph or xdigit shall be specified.\u201d\n+        # upper, lower, alpha already checked above.\n+        if (is_space(code_point) and is_digit(code_point)):\n+            sys.stderr.write('%(sym)s is space and digit\\n' %{\n+                'sym': ucs_symbol(code_point)})\n+        if (is_space(code_point) and is_graph(code_point)):\n+            sys.stderr.write('%(sym)s is space and graph\\n' %{\n+                'sym': ucs_symbol(code_point)})\n+        if (is_space(code_point) and is_xdigit(code_point)):\n+            sys.stderr.write('%(sym)s is space and xdigit\\n' %{\n+                'sym': ucs_symbol(code_point)})\n+        # cntrl restriction: \u201cNo character specified for the keywords upper,\n+        # lower, alpha, digit, punct, graph, print or xdigit shall be\n+        # specified.\u201d  upper, lower, alpha already checked above.\n+        if (is_cntrl(code_point) and is_digit(code_point)):\n+            sys.stderr.write('%(sym)s is cntrl and digit\\n' %{\n+                'sym': ucs_symbol(code_point)})\n+        if (is_cntrl(code_point) and is_punct(code_point)):\n+            sys.stderr.write('%(sym)s is cntrl and punct\\n' %{\n+                'sym': ucs_symbol(code_point)})\n+        if (is_cntrl(code_point) and is_graph(code_point)):\n+            sys.stderr.write('%(sym)s is cntrl and graph\\n' %{\n+                'sym': ucs_symbol(code_point)})\n+        if (is_cntrl(code_point) and is_print(code_point)):\n+            sys.stderr.write('%(sym)s is cntrl and print\\n' %{\n+                'sym': ucs_symbol(code_point)})\n+        if (is_cntrl(code_point) and is_xdigit(code_point)):\n+            sys.stderr.write('%(sym)s is cntrl and xdigit\\n' %{\n+                'sym': ucs_symbol(code_point)})\n+        # punct restriction: \u201cNo character specified for the keywords upper,\n+        # lower, alpha, digit, cntrl, xdigit or as the <space> character shall\n+        # be specified.\u201d  upper, lower, alpha, cntrl already checked above.\n+        if (is_punct(code_point) and is_digit(code_point)):\n+            sys.stderr.write('%(sym)s is punct and digit\\n' %{\n+                'sym': ucs_symbol(code_point)})\n+        if (is_punct(code_point) and is_xdigit(code_point)):\n+            sys.stderr.write('%(sym)s is punct and xdigit\\n' %{\n+                'sym': ucs_symbol(code_point)})\n+        if (is_punct(code_point) and code_point == 0x0020):\n+            sys.stderr.write('%(sym)s is punct\\n' %{\n+                'sym': ucs_symbol(code_point)})\n+        # graph restriction: \u201cNo character specified for the keyword cntrl\n+        # shall be specified.\u201d  Already checked above.\n+\n+        # print restriction: \u201cNo character specified for the keyword cntrl\n+        # shall be specified.\u201d  Already checked above.\n+\n+        # graph - print relation: differ only in the <space> character.\n+        # How is this possible if there are more than one space character?!\n+        # I think susv2/xbd/locale.html should speak of \u201cspace characters\u201d,\n+        # not \u201cspace character\u201d.\n+        if (is_print(code_point)\n+            and not (is_graph(code_point) or is_space(code_point))):\n+            sys.stderr.write('%(sym)s is print but not graph|<space>\\n' %{\n+                'sym': unicode_utils.ucs_symbol(code_point)})\n+        if (not is_print(code_point)\n+            and (is_graph(code_point) or code_point == 0x0020)):\n+            sys.stderr.write('%(sym)s is graph|<space> but not print\\n' %{\n+                'sym': unicode_utils.ucs_symbol(code_point)})"}, {"sha": "0e5583cd259a7f19cff04ea458ef30289981c0a3", "filename": "contrib/unicode/from_glibc/utf8_gen.py", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2Funicode%2Ffrom_glibc%2Futf8_gen.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2Funicode%2Ffrom_glibc%2Futf8_gen.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Funicode%2Ffrom_glibc%2Futf8_gen.py?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -0,0 +1,364 @@\n+#!/usr/bin/python3\n+# -*- coding: utf-8 -*-\n+# Copyright (C) 2014-2019 Free Software Foundation, Inc.\n+# This file is part of the GNU C Library.\n+#\n+# The GNU C Library is free software; you can redistribute it and/or\n+# modify it under the terms of the GNU Lesser General Public\n+# License as published by the Free Software Foundation; either\n+# version 2.1 of the License, or (at your option) any later version.\n+#\n+# The GNU C Library is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+# Lesser General Public License for more details.\n+#\n+# You should have received a copy of the GNU Lesser General Public\n+# License along with the GNU C Library; if not, see\n+# <https://www.gnu.org/licenses/>.\n+\n+'''glibc/localedata/charmaps/UTF-8 file generator script\n+\n+This script generates a glibc/localedata/charmaps/UTF-8 file\n+from Unicode data.\n+\n+Usage: python3 utf8_gen.py UnicodeData.txt EastAsianWidth.txt\n+\n+It will output UTF-8 file\n+'''\n+\n+import argparse\n+import sys\n+import re\n+import unicode_utils\n+\n+# Auxiliary tables for Hangul syllable names, see the Unicode 3.0 book,\n+# sections 3.11 and 4.4.\n+\n+JAMO_INITIAL_SHORT_NAME = (\n+    'G', 'GG', 'N', 'D', 'DD', 'R', 'M', 'B', 'BB', 'S', 'SS', '', 'J', 'JJ',\n+    'C', 'K', 'T', 'P', 'H'\n+)\n+\n+JAMO_MEDIAL_SHORT_NAME = (\n+    'A', 'AE', 'YA', 'YAE', 'EO', 'E', 'YEO', 'YE', 'O', 'WA', 'WAE', 'OE',\n+    'YO', 'U', 'WEO', 'WE', 'WI', 'YU', 'EU', 'YI', 'I'\n+)\n+\n+JAMO_FINAL_SHORT_NAME = (\n+    '', 'G', 'GG', 'GS', 'N', 'NI', 'NH', 'D', 'L', 'LG', 'LM', 'LB', 'LS',\n+    'LT', 'LP', 'LH', 'M', 'B', 'BS', 'S', 'SS', 'NG', 'J', 'C', 'K', 'T',\n+    'P', 'H'\n+)\n+\n+def process_range(start, end, outfile, name):\n+    '''Writes a range of code points into the CHARMAP section of the\n+    output file\n+\n+    '''\n+    if 'Hangul Syllable' in name:\n+        # from glibc/localedata/ChangeLog:\n+        #\n+        #  2000-09-24  Bruno Haible  <haible@clisp.cons.org>\n+        #  * charmaps/UTF-8: Expand <Hangul Syllable> and <Private Use> ranges,\n+        #  so they become printable and carry a width. Comment out surrogate\n+        #  ranges. Add a WIDTH table\n+        #\n+        # So we expand the Hangul Syllables here:\n+        for i in range(int(start, 16), int(end, 16)+1 ):\n+            index2, index3 = divmod(i - 0xaC00, 28)\n+            index1, index2 = divmod(index2, 21)\n+            hangul_syllable_name = 'HANGUL SYLLABLE ' \\\n+                                   + JAMO_INITIAL_SHORT_NAME[index1] \\\n+                                   + JAMO_MEDIAL_SHORT_NAME[index2] \\\n+                                   + JAMO_FINAL_SHORT_NAME[index3]\n+            outfile.write('{:<11s} {:<12s} {:s}\\n'.format(\n+                unicode_utils.ucs_symbol(i), convert_to_hex(i),\n+                hangul_syllable_name))\n+        return\n+    # UnicodeData.txt file has contains code point ranges like this:\n+    #\n+    # 3400;<CJK Ideograph Extension A, First>;Lo;0;L;;;;;N;;;;;\n+    # 4DB5;<CJK Ideograph Extension A, Last>;Lo;0;L;;;;;N;;;;;\n+    #\n+    # The glibc UTF-8 file splits ranges like these into shorter\n+    # ranges of 64 code points each:\n+    #\n+    # <U3400>..<U343F>     /xe3/x90/x80         <CJK Ideograph Extension A>\n+    # \u2026\n+    # <U4D80>..<U4DB5>     /xe4/xb6/x80         <CJK Ideograph Extension A>\n+    for i in range(int(start, 16), int(end, 16), 64 ):\n+        if i > (int(end, 16)-64):\n+            outfile.write('{:s}..{:s} {:<12s} {:s}\\n'.format(\n+                    unicode_utils.ucs_symbol(i),\n+                    unicode_utils.ucs_symbol(int(end,16)),\n+                    convert_to_hex(i),\n+                    name))\n+            break\n+        outfile.write('{:s}..{:s} {:<12s} {:s}\\n'.format(\n+                unicode_utils.ucs_symbol(i),\n+                unicode_utils.ucs_symbol(i+63),\n+                convert_to_hex(i),\n+                name))\n+\n+def process_charmap(flines, outfile):\n+    '''This function takes an array which contains *all* lines of\n+    of UnicodeData.txt and write lines to outfile as used in the\n+\n+    CHARMAP\n+    \u2026\n+    END CHARMAP\n+\n+    section of the UTF-8 file in glibc/localedata/charmaps/UTF-8.\n+\n+    Samples for input lines:\n+\n+    0010;<control>;Cc;0;BN;;;;;N;DATA LINK ESCAPE;;;;\n+    3400;<CJK Ideograph Extension A, First>;Lo;0;L;;;;;N;;;;;\n+    4DB5;<CJK Ideograph Extension A, Last>;Lo;0;L;;;;;N;;;;;\n+    D800;<Non Private Use High Surrogate, First>;Cs;0;L;;;;;N;;;;;\n+    DB7F;<Non Private Use High Surrogate, Last>;Cs;0;L;;;;;N;;;;;\n+    100000;<Plane 16 Private Use, First>;Co;0;L;;;;;N;;;;;\n+    10FFFD;<Plane 16 Private Use, Last>;Co;0;L;;;;;N;;;;;\n+\n+    Samples for output lines (Unicode-Value UTF-8-HEX Unicode-Char-Name):\n+\n+    <U0010>     /x10 DATA LINK ESCAPE\n+    <U3400>..<U343F>     /xe3/x90/x80 <CJK Ideograph Extension A>\n+    %<UD800>     /xed/xa0/x80 <Non Private Use High Surrogate, First>\n+    %<UDB7F>     /xed/xad/xbf <Non Private Use High Surrogate, Last>\n+    <U0010FFC0>..<U0010FFFD>     /xf4/x8f/xbf/x80 <Plane 16 Private Use>\n+\n+    '''\n+    fields_start = []\n+    for line in flines:\n+        fields = line.split(\";\")\n+         # Some characters have \u201c<control>\u201d as their name. We try to\n+         # use the \u201cUnicode 1.0 Name\u201d (10th field in\n+         # UnicodeData.txt) for them.\n+         #\n+         # The Characters U+0080, U+0081, U+0084 and U+0099 have\n+         # \u201c<control>\u201d as their name but do not even have aa\n+         # \u201dUnicode 1.0 Name\u201d. We could write code to take their\n+         # alternate names from NameAliases.txt.\n+        if fields[1] == \"<control>\" and fields[10]:\n+            fields[1] = fields[10]\n+        # Handling code point ranges like:\n+        #\n+        # 3400;<CJK Ideograph Extension A, First>;Lo;0;L;;;;;N;;;;;\n+        # 4DB5;<CJK Ideograph Extension A, Last>;Lo;0;L;;;;;N;;;;;\n+        if fields[1].endswith(', First>') and not 'Surrogate,' in fields[1]:\n+            fields_start = fields\n+            continue\n+        if fields[1].endswith(', Last>') and not 'Surrogate,' in fields[1]:\n+            process_range(fields_start[0], fields[0],\n+                          outfile, fields[1][:-7]+'>')\n+            fields_start = []\n+            continue\n+        fields_start = []\n+        if 'Surrogate,' in fields[1]:\n+            # Comment out the surrogates in the UTF-8 file.\n+            # One could of course skip them completely but\n+            # the original UTF-8 file in glibc had them as\n+            # comments, so we keep these comment lines.\n+            outfile.write('%')\n+        outfile.write('{:<11s} {:<12s} {:s}\\n'.format(\n+                unicode_utils.ucs_symbol(int(fields[0], 16)),\n+                convert_to_hex(int(fields[0], 16)),\n+                fields[1]))\n+\n+def convert_to_hex(code_point):\n+    '''Converts a code point to a hexadecimal UTF-8 representation\n+    like /x**/x**/x**.'''\n+    # Getting UTF8 of Unicode characters.\n+    # In Python3, .encode('UTF-8') does not work for\n+    # surrogates. Therefore, we use this conversion table\n+    surrogates = {\n+        0xD800: '/xed/xa0/x80',\n+        0xDB7F: '/xed/xad/xbf',\n+        0xDB80: '/xed/xae/x80',\n+        0xDBFF: '/xed/xaf/xbf',\n+        0xDC00: '/xed/xb0/x80',\n+        0xDFFF: '/xed/xbf/xbf',\n+    }\n+    if code_point in surrogates:\n+        return surrogates[code_point]\n+    return ''.join([\n+        '/x{:02x}'.format(c) for c in chr(code_point).encode('UTF-8')\n+    ])\n+\n+def write_header_charmap(outfile):\n+    '''Write the header on top of the CHARMAP section to the output file'''\n+    outfile.write(\"<code_set_name> UTF-8\\n\")\n+    outfile.write(\"<comment_char> %\\n\")\n+    outfile.write(\"<escape_char> /\\n\")\n+    outfile.write(\"<mb_cur_min> 1\\n\")\n+    outfile.write(\"<mb_cur_max> 6\\n\\n\")\n+    outfile.write(\"% CHARMAP generated using utf8_gen.py\\n\")\n+    outfile.write(\"% alias ISO-10646/UTF-8\\n\")\n+    outfile.write(\"CHARMAP\\n\")\n+\n+def write_header_width(outfile, unicode_version):\n+    '''Writes the header on top of the WIDTH section to the output file'''\n+    outfile.write('% Character width according to Unicode '\n+                  + '{:s}.\\n'.format(unicode_version))\n+    outfile.write('% - Default width is 1.\\n')\n+    outfile.write('% - Double-width characters have width 2; generated from\\n')\n+    outfile.write('%        \"grep \\'^[^;]*;[WF]\\' EastAsianWidth.txt\"\\n')\n+    outfile.write('% - Non-spacing characters have width 0; '\n+                  + 'generated from PropList.txt or\\n')\n+    outfile.write('%   \"grep \\'^[^;]*;[^;]*;[^;]*;[^;]*;NSM;\\' '\n+                  + 'UnicodeData.txt\"\\n')\n+    outfile.write('% - Format control characters have width 0; '\n+                  + 'generated from\\n')\n+    outfile.write(\"%   \\\"grep '^[^;]*;[^;]*;Cf;' UnicodeData.txt\\\"\\n\")\n+#   Not needed covered by Cf\n+#    outfile.write(\"% - Zero width characters have width 0; generated from\\n\")\n+#    outfile.write(\"%   \\\"grep '^[^;]*;ZERO WIDTH ' UnicodeData.txt\\\"\\n\")\n+    outfile.write(\"WIDTH\\n\")\n+\n+def process_width(outfile, ulines, elines, plines):\n+    '''ulines are lines from UnicodeData.txt, elines are lines from\n+    EastAsianWidth.txt containing characters with width \u201cW\u201d or \u201cF\u201d,\n+    plines are lines from PropList.txt which contain characters\n+    with the property \u201cPrepended_Concatenation_Mark\u201d.\n+\n+    '''\n+    width_dict = {}\n+    for line in elines:\n+        fields = line.split(\";\")\n+        if not '..' in fields[0]:\n+            code_points = (fields[0], fields[0])\n+        else:\n+            code_points = fields[0].split(\"..\")\n+        for key in range(int(code_points[0], 16),\n+                         int(code_points[1], 16)+1):\n+            width_dict[key] = 2\n+\n+    for line in ulines:\n+        fields = line.split(\";\")\n+        if fields[4] == \"NSM\" or fields[2] in (\"Cf\", \"Me\", \"Mn\"):\n+            width_dict[int(fields[0], 16)] = 0\n+\n+    for line in plines:\n+        # Characters with the property \u201cPrepended_Concatenation_Mark\u201d\n+        # should have the width 1:\n+        fields = line.split(\";\")\n+        if not '..' in fields[0]:\n+            code_points = (fields[0], fields[0])\n+        else:\n+            code_points = fields[0].split(\"..\")\n+        for key in range(int(code_points[0], 16),\n+                         int(code_points[1], 16)+1):\n+            del width_dict[key] # default width is 1\n+\n+    # handle special cases for compatibility\n+    for key in list((0x00AD,)):\n+        # https://www.cs.tut.fi/~jkorpela/shy.html\n+        if key in width_dict:\n+            del width_dict[key] # default width is 1\n+    for key in list(range(0x1160, 0x1200)):\n+        width_dict[key] = 0\n+    for key in list(range(0x3248, 0x3250)):\n+        # These are \u201cA\u201d which means we can decide whether to treat them\n+        # as \u201cW\u201d or \u201cN\u201d based on context:\n+        # http://www.unicode.org/mail-arch/unicode-ml/y2017-m08/0023.html\n+        # For us, \u201cW\u201d seems better.\n+        width_dict[key] = 2\n+    for key in list(range(0x4DC0, 0x4E00)):\n+        width_dict[key] = 2\n+\n+    same_width_lists = []\n+    current_width_list = []\n+    for key in sorted(width_dict):\n+        if not current_width_list:\n+            current_width_list = [key]\n+        elif (key == current_width_list[-1] + 1\n+              and width_dict[key] == width_dict[current_width_list[0]]):\n+            current_width_list.append(key)\n+        else:\n+            same_width_lists.append(current_width_list)\n+            current_width_list = [key]\n+    if current_width_list:\n+        same_width_lists.append(current_width_list)\n+\n+    for same_width_list in same_width_lists:\n+        if len(same_width_list) == 1:\n+            outfile.write('{:s}\\t{:d}\\n'.format(\n+                unicode_utils.ucs_symbol(same_width_list[0]),\n+                width_dict[same_width_list[0]]))\n+        else:\n+            outfile.write('{:s}...{:s}\\t{:d}\\n'.format(\n+                unicode_utils.ucs_symbol(same_width_list[0]),\n+                unicode_utils.ucs_symbol(same_width_list[-1]),\n+                width_dict[same_width_list[0]]))\n+\n+if __name__ == \"__main__\":\n+    PARSER = argparse.ArgumentParser(\n+        description='''\n+        Generate a UTF-8 file from UnicodeData.txt, EastAsianWidth.txt, and PropList.txt.\n+        ''')\n+    PARSER.add_argument(\n+        '-u', '--unicode_data_file',\n+        nargs='?',\n+        type=str,\n+        default='UnicodeData.txt',\n+        help=('The UnicodeData.txt file to read, '\n+              + 'default: %(default)s'))\n+    PARSER.add_argument(\n+        '-e', '--east_asian_with_file',\n+        nargs='?',\n+        type=str,\n+        default='EastAsianWidth.txt',\n+        help=('The EastAsianWidth.txt file to read, '\n+              + 'default: %(default)s'))\n+    PARSER.add_argument(\n+        '-p', '--prop_list_file',\n+        nargs='?',\n+        type=str,\n+        default='PropList.txt',\n+        help=('The PropList.txt file to read, '\n+              + 'default: %(default)s'))\n+    PARSER.add_argument(\n+        '--unicode_version',\n+        nargs='?',\n+        required=True,\n+        type=str,\n+        help='The Unicode version of the input files used.')\n+    ARGS = PARSER.parse_args()\n+\n+    with open(ARGS.unicode_data_file, mode='r') as UNIDATA_FILE:\n+        UNICODE_DATA_LINES = UNIDATA_FILE.readlines()\n+    with open(ARGS.east_asian_with_file, mode='r') as EAST_ASIAN_WIDTH_FILE:\n+        EAST_ASIAN_WIDTH_LINES = []\n+        for LINE in EAST_ASIAN_WIDTH_FILE:\n+            # If characters from EastAasianWidth.txt which are from\n+            # from reserved ranges (i.e. not yet assigned code points)\n+            # are added to the WIDTH section of the UTF-8 file, then\n+            # \u201cmake check\u201d produces \u201cUnknown Character\u201d errors for\n+            # these code points because such unassigned code points\n+            # are not in the CHARMAP section of the UTF-8 file.\n+            #\n+            # Therefore, we skip all reserved code points when reading\n+            # the EastAsianWidth.txt file.\n+            if re.match(r'.*<reserved-.+>\\.\\.<reserved-.+>.*', LINE):\n+                continue\n+            if re.match(r'^[^;]*;[WF]', LINE):\n+                EAST_ASIAN_WIDTH_LINES.append(LINE.strip())\n+    with open(ARGS.prop_list_file, mode='r') as PROP_LIST_FILE:\n+        PROP_LIST_LINES = []\n+        for LINE in PROP_LIST_FILE:\n+            if re.match(r'^[^;]*;[\\s]*Prepended_Concatenation_Mark', LINE):\n+                PROP_LIST_LINES.append(LINE.strip())\n+    with open('UTF-8', mode='w') as OUTFILE:\n+        # Processing UnicodeData.txt and write CHARMAP to UTF-8 file\n+        write_header_charmap(OUTFILE)\n+        process_charmap(UNICODE_DATA_LINES, OUTFILE)\n+        OUTFILE.write(\"END CHARMAP\\n\\n\")\n+        # Processing EastAsianWidth.txt and write WIDTH to UTF-8 file\n+        write_header_width(OUTFILE, ARGS.unicode_version)\n+        process_width(OUTFILE,\n+                      UNICODE_DATA_LINES,\n+                      EAST_ASIAN_WIDTH_LINES,\n+                      PROP_LIST_LINES)\n+        OUTFILE.write(\"END WIDTH\\n\")"}, {"sha": "02b28bcedcfd0e9219e656ae2f98f153515d2d83", "filename": "contrib/unicode/gen_wcwidth.py", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2Funicode%2Fgen_wcwidth.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2Funicode%2Fgen_wcwidth.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Funicode%2Fgen_wcwidth.py?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -0,0 +1,106 @@\n+#!/usr/bin/env python3\n+#\n+# Script to generate tables for cpp_wcwidth, leveraging glibc's utf8_gen.py.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it under\n+# the terms of the GNU General Public License as published by the Free\n+# Software Foundation; either version 3, or (at your option) any later\n+# version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.  */\n+\n+import sys\n+import os\n+\n+if len(sys.argv) != 2:\n+    print(\"usage: %s <unicode version>\", file=sys.stderr)\n+    sys.exit(1)\n+unicode_version = sys.argv[1]\n+\n+# Parse a codepoint in the format output by glibc tools.\n+def parse_ucn(s):\n+    if not (s.startswith(\"<U\") and s.endswith(\">\")):\n+        raise ValueError\n+    return int(s[2:-1], base=16)\n+\n+# Process a line of width output from utf_gen.py and update global array.\n+widths = [1] * (1 + 0x10FFFF)\n+def process_width(line):\n+    # Example lines:\n+    # <UA8FF>\t0\n+    # <UA926>...<UA92D>\t0\n+\n+    s = line.split()\n+    width = int(s[1])\n+    r = s[0].split(\"...\")\n+    if len(r) == 1:\n+        begin = parse_ucn(r[0])\n+        end = begin + 1\n+    elif len(r) == 2:\n+        begin = parse_ucn(r[0])\n+        end = parse_ucn(r[1]) + 1\n+    else:\n+        raise ValueError\n+    widths[begin:end] = [width] * (end - begin)\n+\n+# To keep things simple, we use glibc utf8_gen.py as-is.  It only outputs to a\n+# file named UTF-8, which is not configurable.  Then we parse this into the form\n+# we want it.\n+os.system(\"from_glibc/utf8_gen.py --unicode_version %s\" % unicode_version)\n+processing = False\n+for line in open(\"UTF-8\", \"r\"):\n+    if processing:\n+        if line == \"END WIDTH\\n\":\n+            processing = False\n+        else:\n+            try:\n+                process_width(line)\n+            except (ValueError, IndexError):\n+                print(e, \"warning: ignored unexpected line: %s\" % line,\n+                        file=sys.stderr, end=\"\")\n+    elif line == \"WIDTH\\n\":\n+        processing = True\n+\n+# All bytes < 256 we treat as width 1.\n+widths[0:255] = [1] * 255\n+\n+# Condense the list to contiguous ranges.\n+cur_range = [-1, 1]\n+all_ranges = []\n+for i, width in enumerate(widths):\n+    if width == cur_range[1]:\n+        cur_range[0] = i\n+    else:\n+        all_ranges.append(cur_range)\n+        cur_range = [i, width]\n+\n+# Output the arrays for generated_cpp_wcwidth.h\n+print(\"/*  Generated by contrib/unicode/gen_wcwidth.py,\",\n+          \"with the help of glibc's\")\n+print(\"    utf8_gen.py, using version %s\" % unicode_version,\n+          \"of the Unicode standard.  */\")\n+print(\"\\nstatic const cppchar_t wcwidth_range_ends[] = {\", end=\"\")\n+for i, r in enumerate(all_ranges):\n+    if i % 8:\n+        print(\" \", end=\"\")\n+    else:\n+        print(\"\\n  \", end=\"\")\n+    print(\"0x%x,\" % (r[0]), end=\"\")\n+print(\"\\n};\\n\")\n+print(\"static const unsigned char wcwidth_widths[] = {\", end=\"\")\n+for i, r in enumerate(all_ranges):\n+    if i % 24:\n+        print(\" \", end=\"\")\n+    else:\n+        print(\"\\n  \", end=\"\")\n+    print(\"%d,\" % r[1], end=\"\")\n+print(\"\\n};\")"}, {"sha": "bdbb0a5c32d2d30c1e735469a2c799ce52e3c167", "filename": "contrib/unicode/unicode-license.txt", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2Funicode%2Funicode-license.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/contrib%2Funicode%2Funicode-license.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Funicode%2Funicode-license.txt?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -0,0 +1,50 @@\n+\ufeffUNICODE, INC. LICENSE AGREEMENT - DATA FILES AND SOFTWARE\n+\n+    Unicode Data Files include all data files under the directories\n+http://www.unicode.org/Public/, http://www.unicode.org/reports/, and\n+http://www.unicode.org/cldr/data/. Unicode Data Files do not include PDF\n+online code charts under the directory http://www.unicode.org/Public/.\n+Software includes any source code published in the Unicode Standard or under\n+the directories http://www.unicode.org/Public/,\n+http://www.unicode.org/reports/, and http://www.unicode.org/cldr/data/.\n+\n+    NOTICE TO USER: Carefully read the following legal agreement. BY\n+DOWNLOADING, INSTALLING, COPYING OR OTHERWISE USING UNICODE INC.'S DATA FILES\n+(\"DATA FILES\"), AND/OR SOFTWARE (\"SOFTWARE\"), YOU UNEQUIVOCALLY ACCEPT, AND\n+AGREE TO BE BOUND BY, ALL OF THE TERMS AND CONDITIONS OF THIS AGREEMENT. IF\n+YOU DO NOT AGREE, DO NOT DOWNLOAD, INSTALL, COPY, DISTRIBUTE OR USE THE DATA\n+FILES OR SOFTWARE.\n+\n+    COPYRIGHT AND PERMISSION NOTICE\n+\n+    Copyright \u00a9 1991-2013 Unicode, Inc. All rights reserved. Distributed under\n+the Terms of Use in http://www.unicode.org/copyright.html.\n+\n+    Permission is hereby granted, free of charge, to any person obtaining a\n+copy of the Unicode data files and any associated documentation (the \"Data\n+Files\") or Unicode software and any associated documentation (the \"Software\")\n+to deal in the Data Files or Software without restriction, including without\n+limitation the rights to use, copy, modify, merge, publish, distribute, and/or\n+sell copies of the Data Files or Software, and to permit persons to whom the\n+Data Files or Software are furnished to do so, provided that (a) the above\n+copyright notice(s) and this permission notice appear with all copies of the\n+Data Files or Software, (b) both the above copyright notice(s) and this\n+permission notice appear in associated documentation, and (c) there is clear\n+notice in each modified Data File or in the Software as well as in the\n+documentation associated with the Data File(s) or Software that the data or\n+software has been modified.\n+\n+    THE DATA FILES AND SOFTWARE ARE PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY\n+KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD\n+PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN\n+THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL\n+DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR\n+PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\n+ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THE\n+DATA FILES OR SOFTWARE.\n+\n+    Except as contained in this notice, the name of a copyright holder shall\n+not be used in advertising or otherwise to promote the sale, use or other\n+dealings in these Data Files or Software without prior written authorization\n+of the copyright holder."}, {"sha": "8f5b06d8be31447272243a533fe804590cdf1507", "filename": "gcc/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -1,3 +1,79 @@\n+2019-12-09  Lewis Hyatt  <lhyatt@gmail.com>\n+\n+\tPR preprocessor/49973\n+\t* input.c (location_compute_display_column): New function to help with\n+\tmultibyte awareness in diagnostics.\n+\t(test_cpp_utf8): New self-test.\n+\t(input_c_tests): Call the new test.\n+\t* input.h (location_compute_display_column): Declare.\n+\t* diagnostic-show-locus.c: Pervasive changes to add multibyte awareness\n+\tto all classes and functions.\n+\t(enum column_unit): New enum.\n+\t(class exploc_with_display_col): New class.\n+\t(class layout_point): Convert m_column member to array m_columns[2].\n+\t(layout_range::contains_point): Add col_unit argument.\n+\t(test_layout_range_for_single_point): Pass new argument.\n+\t(test_layout_range_for_single_line): Likewise.\n+\t(test_layout_range_for_multiple_lines): Likewise.\n+\t(line_bounds::convert_to_display_cols): New function.\n+\t(layout::get_state_at_point): Add col_unit argument.\n+\t(make_range): Use empty filename rather than dummy filename.\n+\t(get_line_width_without_trailing_whitespace): Rename to...\n+\t(get_line_bytes_without_trailing_whitespace): ...this.\n+\t(test_get_line_width_without_trailing_whitespace): Rename to...\n+\t(test_get_line_bytes_without_trailing_whitespace): ...this.\n+\t(class layout): m_exploc changed to exploc_with_display_col from\n+\tplain expanded_location.\n+\t(layout::get_linenum_width): New accessor member function.\n+\t(layout::get_x_offset_display): Likewise.\n+\t(layout::calculate_linenum_width): New subroutine for the constuctor.\n+\t(layout::calculate_x_offset_display): Likewise.\n+\t(layout::layout): Use the new subroutines. Add multibyte awareness.\n+\t(layout::print_source_line): Add multibyte awareness.\n+\t(layout::print_line): Likewise.\n+\t(layout::print_annotation_line): Likewise.\n+\t(line_label::line_label): Likewise.\n+\t(layout::print_any_labels): Likewise.\n+\t(layout::annotation_line_showed_range_p): Likewise.\n+\t(get_printed_columns): Likewise.\n+\t(class line_label): Rename m_length to m_display_width.\n+\t(get_affected_columns): Rename to...\n+\t(get_affected_range): ...this; add col_unit argument and multibyte\n+\tawareness.\n+\t(class correction): Add m_affected_bytes and m_display_cols\n+\tmembers.  Rename m_len to m_byte_length for clarity.  Add multibyte\n+\tawareness throughout.\n+\t(correction::insertion_p): Add multibyte awareness.\n+\t(correction::compute_display_cols): New function.\n+\t(correction::ensure_terminated): Use new member name m_byte_length.\n+\t(line_corrections::add_hint): Add multibyte awareness.\n+\t(layout::print_trailing_fixits): Likewise.\n+\t(layout::get_x_bound_for_row): Likewise.\n+\t(test_one_liner_simple_caret_utf8): New self-test analogous to the one\n+\twith _utf8 suffix removed, testing multibyte awareness.\n+\t(test_one_liner_caret_and_range_utf8): Likewise.\n+\t(test_one_liner_multiple_carets_and_ranges_utf8): Likewise.\n+\t(test_one_liner_fixit_insert_before_utf8): Likewise.\n+\t(test_one_liner_fixit_insert_after_utf8): Likewise.\n+\t(test_one_liner_fixit_remove_utf8): Likewise.\n+\t(test_one_liner_fixit_replace_utf8): Likewise.\n+\t(test_one_liner_fixit_replace_non_equal_range_utf8): Likewise.\n+\t(test_one_liner_fixit_replace_equal_secondary_range_utf8): Likewise.\n+\t(test_one_liner_fixit_validation_adhoc_locations_utf8): Likewise.\n+\t(test_one_liner_many_fixits_1_utf8): Likewise.\n+\t(test_one_liner_many_fixits_2_utf8): Likewise.\n+\t(test_one_liner_labels_utf8): Likewise.\n+\t(test_diagnostic_show_locus_one_liner_utf8): Likewise.\n+\t(test_overlapped_fixit_printing_utf8): Likewise.\n+\t(test_overlapped_fixit_printing): Adapt for changes to\n+\tget_affected_columns, get_printed_columns and class corrections.\n+\t(test_overlapped_fixit_printing_2): Likewise.\n+\t(test_linenum_sep): New constant.\n+\t(test_left_margin): Likewise.\n+\t(test_offset_impl): Helper function for new test.\n+\t(test_layout_x_offset_display_utf8): New test.\n+\t(diagnostic_show_locus_c_tests): Call new tests.\n+\n 2019-12-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree.c (build_array_type_1): Add SET_CANONICAL parameter and compute"}, {"sha": "9cd16952ce0c90927ec7376d0d33e689f12367a0", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 1479, "deletions": 262, "changes": 1741, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gcc-rich-location.h\"\n #include \"selftest.h\"\n #include \"selftest-diagnostic.h\"\n+#include \"cpplib.h\"\n \n #ifdef HAVE_TERMIOS_H\n # include <termios.h>\n@@ -112,18 +113,81 @@ class colorizer\n   const char *m_stop_color;\n };\n \n-/* A point within a layout_range; similar to an expanded_location,\n+/* In order to handle multibyte sources properly, all of this logic needs to be\n+   aware of the distinction between the number of bytes and the number of\n+   display columns occupied by a character, which are not the same for non-ASCII\n+   characters.  For example, the Unicode pi symbol, U+03C0, is encoded in UTF-8\n+   as \"\\xcf\\x80\", and thus occupies 2 bytes of space while only occupying 1\n+   display column when it is output.  A typical emoji, such as U+1F602 (in\n+   UTF-8, \"\\xf0\\x9f\\x98\\x82\"), requires 4 bytes and has a display width of 2.\n+\n+   The below example line, which is also used for selftests below, shows how the\n+   display column and byte column are related:\n+\n+     0000000001111111111222222   display\n+     1234567890123456789012345   columns\n+     SS_foo = P_bar.SS_fieldP;\n+     0000000111111111222222223   byte\n+     1356789012456789134567891   columns\n+\n+   Here SS represents the two display columns for the U+1F602 emoji, and P\n+   represents the one display column for the U+03C0 pi symbol.  As an example, a\n+   diagnostic pointing to the final P on this line is at byte column 29 and\n+   display column 24.  This reflects the fact that the three extended characters\n+   before the final P occupy cumulatively 5 more bytes than they do display\n+   columns (a difference of 2 for each of the two SSs, and one for the other P).\n+\n+   One or the other of the two column units is more useful depending on the\n+   context.  For instance, in order to output the caret at the correct location,\n+   we need to count display columns; in order to colorize a source line, we need\n+   to count the bytes.  All locations are provided to us as byte counts, which\n+   we augment with the display column on demand so that it can be used when\n+   needed.  This is not the most efficient way to do things since it requires\n+   looping over the whole line each time, but it should be fine for the purpose\n+   of outputting diagnostics.\n+\n+   In order to keep straight which units (byte or display) are in use at a\n+   given time, the following enum lets us specify that explicitly.  */\n+\n+enum column_unit {\n+  /* Measured in raw bytes.  */\n+  CU_BYTES = 0,\n+\n+  /* Measured in display units.  */\n+  CU_DISPLAY_COLS,\n+\n+  /* For arrays indexed by column_unit.  */\n+  CU_NUM_UNITS\n+};\n+\n+/* Utility class to augment an exploc with the corresponding display column.  */\n+\n+class exploc_with_display_col : public expanded_location\n+{\n+ public:\n+  exploc_with_display_col (const expanded_location &exploc)\n+    : expanded_location (exploc),\n+      m_display_col (location_compute_display_column (exploc)) {}\n+\n+  int m_display_col;\n+};\n+\n+\n+/* A point within a layout_range; similar to an exploc_with_display_col,\n    but after filtering on file.  */\n \n class layout_point\n {\n  public:\n   layout_point (const expanded_location &exploc)\n-  : m_line (exploc.line),\n-    m_column (exploc.column) {}\n+    : m_line (exploc.line)\n+  {\n+    m_columns[CU_BYTES] = exploc.column;\n+    m_columns[CU_DISPLAY_COLS] = location_compute_display_column (exploc);\n+  }\n \n   linenum_type m_line;\n-  int m_column;\n+  int m_columns[CU_NUM_UNITS];\n };\n \n /* A class for use by \"class layout\" below: a filtered location_range.  */\n@@ -138,7 +202,8 @@ class layout_range\n \t\tunsigned original_idx,\n \t\tconst range_label *label);\n \n-  bool contains_point (linenum_type row, int column) const;\n+  bool contains_point (linenum_type row, int column,\n+\t\t       enum column_unit col_unit) const;\n   bool intersects_line_p (linenum_type row) const;\n \n   layout_point m_start;\n@@ -157,6 +222,17 @@ struct line_bounds\n {\n   int m_first_non_ws;\n   int m_last_non_ws;\n+\n+  void convert_to_display_cols (char_span line)\n+  {\n+    m_first_non_ws = cpp_byte_column_to_display_column (line.get_buffer (),\n+\t\t\t\t\t\t\tline.length (),\n+\t\t\t\t\t\t\tm_first_non_ws);\n+\n+    m_last_non_ws = cpp_byte_column_to_display_column (line.get_buffer (),\n+\t\t\t\t\t\t       line.length (),\n+\t\t\t\t\t\t       m_last_non_ws);\n+  }\n };\n \n /* A range of contiguous source lines within a layout (e.g. \"lines 5-10\"\n@@ -252,6 +328,9 @@ class layout\n   int get_num_line_spans () const { return m_line_spans.length (); }\n   const line_span *get_line_span (int idx) const { return &m_line_spans[idx]; }\n \n+  int get_linenum_width () const { return m_linenum_width; }\n+  int get_x_offset_display () const { return m_x_offset_display; }\n+\n   void print_gap_in_line_numbering ();\n   bool print_heading_for_line_span_index_p (int line_span_idx) const;\n \n@@ -262,7 +341,7 @@ class layout\n  private:\n   bool will_show_line_p (linenum_type row) const;\n   void print_leading_fixits (linenum_type row);\n-  void print_source_line (linenum_type row, const char *line, int line_width,\n+  void print_source_line (linenum_type row, const char *line, int line_bytes,\n \t\t\t  line_bounds *lbounds_out);\n   bool should_print_annotation_line_p (linenum_type row) const;\n   void start_annotation_line (char margin_char = ' ') const;\n@@ -277,13 +356,16 @@ class layout\n   bool validate_fixit_hint_p (const fixit_hint *hint);\n \n   void calculate_line_spans ();\n+  void calculate_linenum_width ();\n+  void calculate_x_offset_display ();\n \n   void print_newline ();\n \n   bool\n   get_state_at_point (/* Inputs.  */\n \t\t      linenum_type row, int column,\n \t\t      int first_non_ws, int last_non_ws,\n+\t\t      enum column_unit col_unit,\n \t\t      /* Outputs.  */\n \t\t      point_state *out_state);\n \n@@ -298,7 +380,7 @@ class layout\n   diagnostic_context *m_context;\n   pretty_printer *m_pp;\n   location_t m_primary_loc;\n-  expanded_location m_exploc;\n+  exploc_with_display_col m_exploc;\n   colorizer m_colorizer;\n   bool m_colorize_source_p;\n   bool m_show_labels_p;\n@@ -307,7 +389,7 @@ class layout\n   auto_vec <const fixit_hint *> m_fixit_hints;\n   auto_vec <line_span> m_line_spans;\n   int m_linenum_width;\n-  int m_x_offset;\n+  int m_x_offset_display;\n };\n \n /* Implementation of \"class colorizer\".  */\n@@ -472,10 +554,15 @@ layout_range::layout_range (const expanded_location *start_exploc,\n    - 'w' indicates a point within the range\n    - 'F' indicates the finish of the range (which is\n \t within it).\n-   - 'a' indicates a subsequent point *after* the range.  */\n+   - 'a' indicates a subsequent point *after* the range.\n+\n+   COL_UNIT controls whether we check the byte column or\n+   the display column; one or the other is more convenient\n+   depending on the context.  */\n \n bool\n-layout_range::contains_point (linenum_type row, int column) const\n+layout_range::contains_point (linenum_type row, int column,\n+\t\t\t      enum column_unit col_unit) const\n {\n   gcc_assert (m_start.m_line <= m_finish.m_line);\n   /* ...but the equivalent isn't true for the columns;\n@@ -491,7 +578,7 @@ layout_range::contains_point (linenum_type row, int column) const\n     /* On same line as start of range (corresponding\n        to line 02 in example A and line 03 in example B).  */\n     {\n-      if (column < m_start.m_column)\n+      if (column < m_start.m_columns[col_unit])\n \t/* Points on the starting line of the range, but\n \t   before the column in which it begins.  */\n \treturn false;\n@@ -505,7 +592,7 @@ layout_range::contains_point (linenum_type row, int column) const\n \t{\n \t  /* This is a single-line range.  */\n \t  gcc_assert (row == m_finish.m_line);\n-\t  return column <= m_finish.m_column;\n+\t  return column <= m_finish.m_columns[col_unit];\n \t}\n     }\n \n@@ -530,7 +617,7 @@ layout_range::contains_point (linenum_type row, int column) const\n \n   gcc_assert (row ==  m_finish.m_line);\n \n-  return column <= m_finish.m_column;\n+  return column <= m_finish.m_columns[col_unit];\n }\n \n /* Does this layout_range contain any part of line ROW?  */\n@@ -548,15 +635,22 @@ layout_range::intersects_line_p (linenum_type row) const\n \n #if CHECKING_P\n \n-/* A helper function for testing layout_range.  */\n+/* Create some expanded locations for testing layout_range.  The filename\n+   member of the explocs is set to the empty string.  This member will only be\n+   inspected by the calls to location_compute_display_column() made from the\n+   layout_point constructors.  That function will check for an empty filename\n+   argument and not attempt to open it, rather treating the non-existent data\n+   as if the display width were the same as the byte count.  Tests exercising a\n+   real difference between byte count and display width are performed later,\n+   e.g. in test_diagnostic_show_locus_one_liner_utf8().  */\n \n static layout_range\n make_range (int start_line, int start_col, int end_line, int end_col)\n {\n   const expanded_location start_exploc\n-    = {\"test.c\", start_line, start_col, NULL, false};\n+    = {\"\", start_line, start_col, NULL, false};\n   const expanded_location finish_exploc\n-    = {\"test.c\", end_line, end_col, NULL, false};\n+    = {\"\", end_line, end_col, NULL, false};\n   return layout_range (&start_exploc, &finish_exploc, SHOW_RANGE_WITHOUT_CARET,\n \t\t       &start_exploc, 0, NULL);\n }\n@@ -574,20 +668,25 @@ test_layout_range_for_single_point ()\n \n   /* Tests for layout_range::contains_point.  */\n \n-  /* Before the line. */\n-  ASSERT_FALSE (point.contains_point (6, 1));\n+  for (int i = 0; i != CU_NUM_UNITS; ++i)\n+    {\n+      const enum column_unit col_unit = (enum column_unit) i;\n+\n+      /* Before the line.  */\n+      ASSERT_FALSE (point.contains_point (6, 1, col_unit));\n \n-  /* On the line, but before start.  */\n-  ASSERT_FALSE (point.contains_point (7, 9));\n+      /* On the line, but before start.  */\n+      ASSERT_FALSE (point.contains_point (7, 9, col_unit));\n \n-  /* At the point.  */\n-  ASSERT_TRUE (point.contains_point (7, 10));\n+      /* At the point.  */\n+      ASSERT_TRUE (point.contains_point (7, 10, col_unit));\n \n-  /* On the line, after the point.  */\n-  ASSERT_FALSE (point.contains_point (7, 11));\n+      /* On the line, after the point.  */\n+      ASSERT_FALSE (point.contains_point (7, 11, col_unit));\n \n-  /* After the line.  */\n-  ASSERT_FALSE (point.contains_point (8, 1));\n+      /* After the line.  */\n+      ASSERT_FALSE (point.contains_point (8, 1, col_unit));\n+    }\n \n   /* Tests for layout_range::intersects_line_p.  */\n   ASSERT_FALSE (point.intersects_line_p (6));\n@@ -605,26 +704,31 @@ test_layout_range_for_single_line ()\n \n   /* Tests for layout_range::contains_point.  */\n \n-  /* Before the line. */\n-  ASSERT_FALSE (example_a.contains_point (1, 1));\n+  for (int i = 0; i != CU_NUM_UNITS; ++i)\n+    {\n+      const enum column_unit col_unit = (enum column_unit) i;\n+\n+      /* Before the line.  */\n+      ASSERT_FALSE (example_a.contains_point (1, 1, col_unit));\n \n-  /* On the line, but before start.  */\n-  ASSERT_FALSE (example_a.contains_point (2, 21));\n+      /* On the line, but before start.  */\n+      ASSERT_FALSE (example_a.contains_point (2, 21, col_unit));\n \n-  /* On the line, at the start.  */\n-  ASSERT_TRUE (example_a.contains_point (2, 22));\n+      /* On the line, at the start.  */\n+      ASSERT_TRUE (example_a.contains_point (2, 22, col_unit));\n \n-  /* On the line, within the range.  */\n-  ASSERT_TRUE (example_a.contains_point (2, 23));\n+      /* On the line, within the range.  */\n+      ASSERT_TRUE (example_a.contains_point (2, 23, col_unit));\n \n-  /* On the line, at the end.  */\n-  ASSERT_TRUE (example_a.contains_point (2, 38));\n+      /* On the line, at the end.  */\n+      ASSERT_TRUE (example_a.contains_point (2, 38, col_unit));\n \n-  /* On the line, after the end.  */\n-  ASSERT_FALSE (example_a.contains_point (2, 39));\n+      /* On the line, after the end.  */\n+      ASSERT_FALSE (example_a.contains_point (2, 39, col_unit));\n \n-  /* After the line.  */\n-  ASSERT_FALSE (example_a.contains_point (2, 39));\n+      /* After the line.  */\n+      ASSERT_FALSE (example_a.contains_point (2, 39, col_unit));\n+    }\n \n   /* Tests for layout_range::intersects_line_p.  */\n   ASSERT_FALSE (example_a.intersects_line_p (1));\n@@ -642,40 +746,45 @@ test_layout_range_for_multiple_lines ()\n \n   /* Tests for layout_range::contains_point.  */\n \n-  /* Before first line. */\n-  ASSERT_FALSE (example_b.contains_point (1, 1));\n+  for (int i = 0; i != CU_NUM_UNITS; ++i)\n+    {\n+      const enum column_unit col_unit = (enum column_unit) i;\n+\n+      /* Before first line.  */\n+      ASSERT_FALSE (example_b.contains_point (1, 1, col_unit));\n \n-  /* On the first line, but before start.  */\n-  ASSERT_FALSE (example_b.contains_point (3, 13));\n+      /* On the first line, but before start.  */\n+      ASSERT_FALSE (example_b.contains_point (3, 13, col_unit));\n \n-  /* At the start.  */\n-  ASSERT_TRUE (example_b.contains_point (3, 14));\n+      /* At the start.  */\n+      ASSERT_TRUE (example_b.contains_point (3, 14, col_unit));\n \n-  /* On the first line, within the range.  */\n-  ASSERT_TRUE (example_b.contains_point (3, 15));\n+      /* On the first line, within the range.  */\n+      ASSERT_TRUE (example_b.contains_point (3, 15, col_unit));\n \n-  /* On an interior line.\n-     The column number should not matter; try various boundary\n-     values.  */\n-  ASSERT_TRUE (example_b.contains_point (4, 1));\n-  ASSERT_TRUE (example_b.contains_point (4, 7));\n-  ASSERT_TRUE (example_b.contains_point (4, 8));\n-  ASSERT_TRUE (example_b.contains_point (4, 9));\n-  ASSERT_TRUE (example_b.contains_point (4, 13));\n-  ASSERT_TRUE (example_b.contains_point (4, 14));\n-  ASSERT_TRUE (example_b.contains_point (4, 15));\n+      /* On an interior line.\n+\t The column number should not matter; try various boundary\n+\t values.  */\n+      ASSERT_TRUE (example_b.contains_point (4, 1, col_unit));\n+      ASSERT_TRUE (example_b.contains_point (4, 7, col_unit));\n+      ASSERT_TRUE (example_b.contains_point (4, 8, col_unit));\n+      ASSERT_TRUE (example_b.contains_point (4, 9, col_unit));\n+      ASSERT_TRUE (example_b.contains_point (4, 13, col_unit));\n+      ASSERT_TRUE (example_b.contains_point (4, 14, col_unit));\n+      ASSERT_TRUE (example_b.contains_point (4, 15, col_unit));\n \n-  /* On the final line, before the end.  */\n-  ASSERT_TRUE (example_b.contains_point (5, 7));\n+      /* On the final line, before the end.  */\n+      ASSERT_TRUE (example_b.contains_point (5, 7, col_unit));\n \n-  /* On the final line, at the end.  */\n-  ASSERT_TRUE (example_b.contains_point (5, 8));\n+      /* On the final line, at the end.  */\n+      ASSERT_TRUE (example_b.contains_point (5, 8, col_unit));\n \n-  /* On the final line, after the end.  */\n-  ASSERT_FALSE (example_b.contains_point (5, 9));\n+      /* On the final line, after the end.  */\n+      ASSERT_FALSE (example_b.contains_point (5, 9, col_unit));\n \n-  /* After the line.  */\n-  ASSERT_FALSE (example_b.contains_point (6, 1));\n+      /* After the line.  */\n+      ASSERT_FALSE (example_b.contains_point (6, 1, col_unit));\n+    }\n \n   /* Tests for layout_range::intersects_line_p.  */\n   ASSERT_FALSE (example_b.intersects_line_p (2));\n@@ -687,13 +796,13 @@ test_layout_range_for_multiple_lines ()\n \n #endif /* #if CHECKING_P */\n \n-/* Given a source line LINE of length LINE_WIDTH, determine the width\n-   without any trailing whitespace.  */\n+/* Given a source line LINE of length LINE_BYTES bytes, determine the length\n+   (still in bytes, not display cols) without any trailing whitespace.  */\n \n static int\n-get_line_width_without_trailing_whitespace (const char *line, int line_width)\n+get_line_bytes_without_trailing_whitespace (const char *line, int line_bytes)\n {\n-  int result = line_width;\n+  int result = line_bytes;\n   while (result > 0)\n     {\n       char ch = line[result - 1];\n@@ -703,7 +812,7 @@ get_line_width_without_trailing_whitespace (const char *line, int line_width)\n \tbreak;\n     }\n   gcc_assert (result >= 0);\n-  gcc_assert (result <= line_width);\n+  gcc_assert (result <= line_bytes);\n   gcc_assert (result == 0 ||\n \t      (line[result - 1] != ' '\n \t       && line[result -1] != '\\t'\n@@ -713,21 +822,21 @@ get_line_width_without_trailing_whitespace (const char *line, int line_width)\n \n #if CHECKING_P\n \n-/* A helper function for testing get_line_width_without_trailing_whitespace.  */\n+/* A helper function for testing get_line_bytes_without_trailing_whitespace.  */\n \n static void\n-assert_eq (const char *line, int expected_width)\n+assert_eq (const char *line, int expected_bytes)\n {\n   int actual_value\n-    = get_line_width_without_trailing_whitespace (line, strlen (line));\n-  ASSERT_EQ (actual_value, expected_width);\n+    = get_line_bytes_without_trailing_whitespace (line, strlen (line));\n+  ASSERT_EQ (actual_value, expected_bytes);\n }\n \n-/* Verify that get_line_width_without_trailing_whitespace is sane for\n+/* Verify that get_line_bytes_without_trailing_whitespace is sane for\n    various inputs.  It is not required to handle newlines.  */\n \n static void\n-test_get_line_width_without_trailing_whitespace ()\n+test_get_line_bytes_without_trailing_whitespace ()\n {\n   assert_eq (\"\", 0);\n   assert_eq (\" \", 0);\n@@ -835,7 +944,7 @@ fixit_cmp (const void *p_a, const void *p_b)\n    sanely print, populating m_layout_ranges and m_fixit_hints.\n    Determine the range of lines that we will print, splitting them\n    up into an ordered list of disjoint spans of contiguous line numbers.\n-   Determine m_x_offset, to ensure that the primary caret\n+   Determine m_x_offset_display, to ensure that the primary caret\n    will fit within the max_width provided by the diagnostic_context.  */\n \n layout::layout (diagnostic_context * context,\n@@ -853,7 +962,7 @@ layout::layout (diagnostic_context * context,\n   m_fixit_hints (richloc->get_num_fixit_hints ()),\n   m_line_spans (1 + richloc->get_num_locations ()),\n   m_linenum_width (0),\n-  m_x_offset (0)\n+  m_x_offset_display (0)\n {\n   for (unsigned int idx = 0; idx < richloc->get_num_locations (); idx++)\n     {\n@@ -875,45 +984,16 @@ layout::layout (diagnostic_context * context,\n   /* Sort m_fixit_hints.  */\n   m_fixit_hints.qsort (fixit_cmp);\n \n-  /* Populate m_line_spans.  */\n+  /* Populate the indicated members.  */\n   calculate_line_spans ();\n-\n-  /* Determine m_linenum_width.  */\n-  gcc_assert (m_line_spans.length () > 0);\n-  const line_span *last_span = &m_line_spans[m_line_spans.length () - 1];\n-  int highest_line = last_span->m_last_line;\n-  if (highest_line < 0)\n-    highest_line = 0;\n-  m_linenum_width = num_digits (highest_line);\n-  /* If we're showing jumps in the line-numbering, allow at least 3 chars.  */\n-  if (m_line_spans.length () > 1)\n-    m_linenum_width = MAX (m_linenum_width, 3);\n-  /* If there's a minimum margin width, apply it (subtracting 1 for the space\n-     after the line number.  */\n-  m_linenum_width = MAX (m_linenum_width, context->min_margin_width - 1);\n-\n-  /* Adjust m_x_offset.\n-     Center the primary caret to fit in max_width; all columns\n-     will be adjusted accordingly.  */\n-  size_t max_width = m_context->caret_max_width;\n-  char_span line = location_get_source_line (m_exploc.file, m_exploc.line);\n-  if (line && (size_t)m_exploc.column <= line.length ())\n-    {\n-      size_t right_margin = CARET_LINE_MARGIN;\n-      size_t column = m_exploc.column;\n-      if (m_show_line_numbers_p)\n-\tcolumn += m_linenum_width + 2;\n-      right_margin = MIN (line.length () - column, right_margin);\n-      right_margin = max_width - right_margin;\n-      if (line.length () >= max_width && column > right_margin)\n-\tm_x_offset = column - right_margin;\n-      gcc_assert (m_x_offset >= 0);\n-    }\n+  calculate_linenum_width ();\n+  calculate_x_offset_display ();\n \n   if (context->show_ruler_p)\n-    show_ruler (m_x_offset + max_width);\n+    show_ruler (m_x_offset_display + m_context->caret_max_width);\n }\n \n+\n /* Attempt to add LOC_RANGE to m_layout_ranges, filtering them to\n    those that we can sanely print.\n \n@@ -1086,7 +1166,7 @@ layout::get_expanded_location (const line_span *line_span) const\n \t{\n \t  expanded_location exploc = m_exploc;\n \t  exploc.line = lr->m_start.m_line;\n-\t  exploc.column = lr->m_start.m_column;\n+\t  exploc.column = lr->m_start.m_columns[CU_BYTES];\n \t  return exploc;\n \t}\n     }\n@@ -1251,25 +1331,122 @@ layout::calculate_line_spans ()\n     }\n }\n \n+/* Determine how many display columns need to be reserved for line numbers,\n+   based on the largest line number that will be needed, and populate\n+   m_linenum_width.  */\n+\n+void\n+layout::calculate_linenum_width ()\n+{\n+  gcc_assert (m_line_spans.length () > 0);\n+  const line_span *last_span = &m_line_spans[m_line_spans.length () - 1];\n+  int highest_line = last_span->m_last_line;\n+  if (highest_line < 0)\n+    highest_line = 0;\n+  m_linenum_width = num_digits (highest_line);\n+  /* If we're showing jumps in the line-numbering, allow at least 3 chars.  */\n+  if (m_line_spans.length () > 1)\n+    m_linenum_width = MAX (m_linenum_width, 3);\n+  /* If there's a minimum margin width, apply it (subtracting 1 for the space\n+     after the line number.  */\n+  m_linenum_width = MAX (m_linenum_width, m_context->min_margin_width - 1);\n+}\n+\n+/* Calculate m_x_offset_display, which improves readability in case the source\n+   line of interest is longer than the user's display.  All lines output will be\n+   shifted to the left (so that their beginning is no longer displayed) by\n+   m_x_offset_display display columns, so that the caret is in a reasonable\n+   location.  */\n+\n+void\n+layout::calculate_x_offset_display ()\n+{\n+  m_x_offset_display = 0;\n+\n+  const int max_width = m_context->caret_max_width;\n+  if (!max_width)\n+    {\n+      /* Nothing to do, the width is not capped.  */\n+      return;\n+    }\n+\n+  const char_span line = location_get_source_line (m_exploc.file,\n+\t\t\t\t\t\t   m_exploc.line);\n+  if (!line)\n+    {\n+      /* Nothing to do, we couldn't find the source line.  */\n+      return;\n+    }\n+  int caret_display_column = m_exploc.m_display_col;\n+  const int line_bytes\n+    = get_line_bytes_without_trailing_whitespace (line.get_buffer (),\n+\t\t\t\t\t\t  line.length ());\n+  int eol_display_column\n+    = cpp_display_width (line.get_buffer (), line_bytes);\n+  if (caret_display_column > eol_display_column\n+      || !caret_display_column)\n+    {\n+      /* This does not make sense, so don't try to do anything in this case.  */\n+      return;\n+    }\n+\n+  /* Adjust caret and eol positions to include the left margin.  If we are\n+     outputting line numbers, then the left margin is equal to m_linenum_width\n+     plus three for the \" | \" which follows it.  Otherwise the left margin width\n+     is equal to 1, because layout::print_source_line() will prefix each line\n+     with a space.  */\n+  const int source_display_cols = eol_display_column;\n+  int left_margin_size = 1;\n+  if (m_show_line_numbers_p)\n+      left_margin_size = m_linenum_width + 3;\n+  caret_display_column += left_margin_size;\n+  eol_display_column += left_margin_size;\n+\n+  if (eol_display_column <= max_width)\n+    {\n+      /* Nothing to do, everything fits in the display.  */\n+      return;\n+    }\n+\n+  /* The line is too long for the display.  Calculate an offset such that the\n+     caret is not too close to the right edge of the screen.  It will be\n+     CARET_LINE_MARGIN display columns from the right edge, unless it is closer\n+     than that to the end of the source line anyway.  */\n+  int right_margin_size = CARET_LINE_MARGIN;\n+  right_margin_size = MIN (eol_display_column - caret_display_column,\n+\t\t\t   right_margin_size);\n+  if (right_margin_size + left_margin_size >= max_width)\n+    {\n+      /* The max_width is very small, so anything we try to do will not be very\n+\t effective; just punt in this case and output with no offset.  */\n+      return;\n+    }\n+  const int max_caret_display_column = max_width - right_margin_size;\n+  if (caret_display_column > max_caret_display_column)\n+    {\n+      m_x_offset_display = caret_display_column - max_caret_display_column;\n+      /* Make sure we don't offset the line into oblivion.  */\n+      static const int min_cols_visible = 2;\n+      if (source_display_cols - m_x_offset_display < min_cols_visible)\n+\tm_x_offset_display = 0;\n+    }\n+}\n+\n /* Print line ROW of source code, potentially colorized at any ranges, and\n    populate *LBOUNDS_OUT.\n-   LINE is the source line (not necessarily 0-terminated) and LINE_WIDTH\n-   is its width.  */\n+   LINE is the source line (not necessarily 0-terminated) and LINE_BYTES\n+   is its length in bytes.\n+   This function deals only with byte offsets, not display columns, so\n+   m_x_offset_display must be converted from display to byte units.  In\n+   particular, LINE_BYTES and LBOUNDS_OUT are in bytes.  */\n \n void\n-layout::print_source_line (linenum_type row, const char *line, int line_width,\n+layout::print_source_line (linenum_type row, const char *line, int line_bytes,\n \t\t\t   line_bounds *lbounds_out)\n {\n   m_colorizer.set_normal_text ();\n \n-  /* We will stop printing the source line at any trailing\n-     whitespace.  */\n-  line_width = get_line_width_without_trailing_whitespace (line,\n-\t\t\t\t\t\t\t   line_width);\n-  line += m_x_offset;\n-\n   pp_emit_prefix (m_pp);\n-\n   if (m_show_line_numbers_p)\n     {\n       int width = num_digits (row);\n@@ -1279,10 +1456,31 @@ layout::print_source_line (linenum_type row, const char *line, int line_width,\n     }\n   else\n     pp_space (m_pp);\n+\n+  /* We will stop printing the source line at any trailing whitespace, and start\n+     printing it as per m_x_offset_display.  */\n+  line_bytes = get_line_bytes_without_trailing_whitespace (line,\n+\t\t\t\t\t\t\t   line_bytes);\n+  int x_offset_bytes = 0;\n+  if (m_x_offset_display)\n+    {\n+      x_offset_bytes = cpp_display_column_to_byte_column (line, line_bytes,\n+\t\t\t\t\t\t\t  m_x_offset_display);\n+      /* In case the leading portion of the line that will be skipped over ends\n+\t with a character with wcwidth > 1, then it is possible we skipped too\n+\t much, so account for that by padding with spaces.  */\n+      const int overage\n+\t= cpp_byte_column_to_display_column (line, line_bytes, x_offset_bytes)\n+\t- m_x_offset_display;\n+      for (int column = 0; column < overage; ++column)\n+\tpp_space (m_pp);\n+      line += x_offset_bytes;\n+    }\n+\n+  /* Print the line.  */\n   int first_non_ws = INT_MAX;\n   int last_non_ws = 0;\n-  int column;\n-  for (column = 1 + m_x_offset; column <= line_width; column++)\n+  for (int col_byte = 1 + x_offset_bytes; col_byte <= line_bytes; col_byte++)\n     {\n       /* Assuming colorization is enabled for the caret and underline\n \t characters, we may also colorize the associated characters\n@@ -1300,8 +1498,9 @@ layout::print_source_line (linenum_type row, const char *line, int line_width,\n \t{\n \t  bool in_range_p;\n \t  point_state state;\n-\t  in_range_p = get_state_at_point (row, column,\n+\t  in_range_p = get_state_at_point (row, col_byte,\n \t\t\t\t\t   0, INT_MAX,\n+\t\t\t\t\t   CU_BYTES,\n \t\t\t\t\t   &state);\n \t  if (in_range_p)\n \t    m_colorizer.set_range (state.range_idx);\n@@ -1313,9 +1512,9 @@ layout::print_source_line (linenum_type row, const char *line, int line_width,\n \tc = ' ';\n       if (c != ' ')\n \t{\n-\t  last_non_ws = column;\n+\t  last_non_ws = col_byte;\n \t  if (first_non_ws == INT_MAX)\n-\t    first_non_ws = column;\n+\t    first_non_ws = col_byte;\n \t}\n       pp_character (m_pp, c);\n       line++;\n@@ -1365,24 +1564,26 @@ layout::start_annotation_line (char margin_char) const\n }\n \n /* Print a line consisting of the caret/underlines for the given\n-   source line.  */\n+   source line.  This function works with display columns, rather than byte\n+   counts; in particular, LBOUNDS should be in display column units.  */\n \n void\n layout::print_annotation_line (linenum_type row, const line_bounds lbounds)\n {\n-  int x_bound = get_x_bound_for_row (row, m_exploc.column,\n+  int x_bound = get_x_bound_for_row (row, m_exploc.m_display_col,\n \t\t\t\t     lbounds.m_last_non_ws);\n \n   start_annotation_line ();\n   pp_space (m_pp);\n \n-  for (int column = 1 + m_x_offset; column < x_bound; column++)\n+  for (int column = 1 + m_x_offset_display; column < x_bound; column++)\n     {\n       bool in_range_p;\n       point_state state;\n       in_range_p = get_state_at_point (row, column,\n \t\t\t\t       lbounds.m_first_non_ws,\n \t\t\t\t       lbounds.m_last_non_ws,\n+\t\t\t\t       CU_DISPLAY_COLS,\n \t\t\t\t       &state);\n       if (in_range_p)\n \t{\n@@ -1420,9 +1621,11 @@ class line_label\n public:\n   line_label (int state_idx, int column, label_text text)\n   : m_state_idx (state_idx), m_column (column),\n-    m_text (text), m_length (strlen (text.m_buffer)),\n-    m_label_line (0), m_has_vbar (true)\n-  {}\n+    m_text (text), m_label_line (0), m_has_vbar (true)\n+  {\n+    const int bytes = strlen (text.m_buffer);\n+    m_display_width = cpp_display_width (text.m_buffer, bytes);\n+  }\n \n   /* Sorting is primarily by column, then by state index.  */\n   static int comparator (const void *p1, const void *p2)\n@@ -1441,7 +1644,7 @@ class line_label\n   int m_state_idx;\n   int m_column;\n   label_text m_text;\n-  size_t m_length;\n+  size_t m_display_width;\n   int m_label_line;\n   bool m_has_vbar;\n };\n@@ -1467,8 +1670,9 @@ layout::print_any_labels (linenum_type row)\n \t  continue;\n \n \t/* Reject labels that aren't fully visible due to clipping\n-\t   by m_x_offset.  */\n-\tif (range->m_caret.m_column <= m_x_offset)\n+\t   by m_x_offset_display.  */\n+\tconst int disp_col = range->m_caret.m_columns[CU_DISPLAY_COLS];\n+\tif (disp_col <= m_x_offset_display)\n \t  continue;\n \n \tlabel_text text;\n@@ -1480,7 +1684,7 @@ layout::print_any_labels (linenum_type row)\n \tif (text.m_buffer == NULL)\n \t  continue;\n \n-\tlabels.safe_push (line_label (i, range->m_caret.m_column, text));\n+\tlabels.safe_push (line_label (i, disp_col, text));\n       }\n   }\n \n@@ -1530,7 +1734,7 @@ layout::print_any_labels (linenum_type row)\n     FOR_EACH_VEC_ELT_REVERSE (labels, i, label)\n       {\n \t/* Would this label \"touch\" or overlap the next label?  */\n-\tif (label->m_column + label->m_length >= (size_t)next_column)\n+\tif (label->m_column + label->m_display_width >= (size_t)next_column)\n \t  {\n \t    max_label_line++;\n \n@@ -1554,7 +1758,7 @@ layout::print_any_labels (linenum_type row)\n       {\n \tstart_annotation_line ();\n \tpp_space (m_pp);\n-\tint column = 1 + m_x_offset;\n+\tint column = 1 + m_x_offset_display;\n \tline_label *label;\n \tFOR_EACH_VEC_ELT (labels, i, label)\n \t  {\n@@ -1569,7 +1773,7 @@ layout::print_any_labels (linenum_type row)\n \t\tm_colorizer.set_range (label->m_state_idx);\n \t\tpp_string (m_pp, label->m_text.m_buffer);\n \t\tm_colorizer.set_normal_text ();\n-\t\tcolumn += label->m_length;\n+\t\tcolumn += label->m_display_width;\n \t      }\n \t    else if (label->m_has_vbar)\n \t      {\n@@ -1636,7 +1840,7 @@ layout::print_leading_fixits (linenum_type row)\n /* Subroutine of layout::print_trailing_fixits.\n \n    Determine if the annotation line printed for LINE contained\n-   the exact range from START_COLUMN to FINISH_COLUMN.  */\n+   the exact range from START_COLUMN to FINISH_COLUMN (in display units).  */\n \n bool\n layout::annotation_line_showed_range_p (linenum_type line, int start_column,\n@@ -1646,9 +1850,9 @@ layout::annotation_line_showed_range_p (linenum_type line, int start_column,\n   int i;\n   FOR_EACH_VEC_ELT (m_layout_ranges, i, range)\n     if (range->m_start.m_line == line\n-\t&& range->m_start.m_column == start_column\n+\t&& range->m_start.m_columns[CU_DISPLAY_COLS] == start_column\n \t&& range->m_finish.m_line == line\n-\t&& range->m_finish.m_column == finish_column)\n+\t&& range->m_finish.m_columns[CU_DISPLAY_COLS] == finish_column)\n       return true;\n   return false;\n }\n@@ -1735,7 +1939,7 @@ layout::annotation_line_showed_range_p (linenum_type line, int start_column,\n \n    and is thus printed as desired.  */\n \n-/* A range of columns within a line.  */\n+/* A range of (byte or display) columns within a line.  */\n \n class column_range\n {\n@@ -1755,32 +1959,51 @@ class column_range\n   int finish;\n };\n \n-/* Get the range of columns that HINT would affect.  */\n-\n+/* Get the range of bytes or display columns that HINT would affect.  */\n static column_range\n-get_affected_columns (const fixit_hint *hint)\n+get_affected_range (const fixit_hint *hint, enum column_unit col_unit)\n {\n-  int start_column = LOCATION_COLUMN (hint->get_start_loc ());\n-  int finish_column = LOCATION_COLUMN (hint->get_next_loc ()) - 1;\n+  expanded_location exploc_start = expand_location (hint->get_start_loc ());\n+  expanded_location exploc_finish = expand_location (hint->get_next_loc ());\n+  --exploc_finish.column;\n \n+  int start_column;\n+  int finish_column;\n+  if (col_unit == CU_DISPLAY_COLS)\n+    {\n+      start_column = location_compute_display_column (exploc_start);\n+      if (hint->insertion_p ())\n+\tfinish_column = start_column - 1;\n+      else\n+\tfinish_column = location_compute_display_column (exploc_finish);\n+    }\n+  else\n+    {\n+      start_column = exploc_start.column;\n+      finish_column = exploc_finish.column;\n+    }\n   return column_range (start_column, finish_column);\n }\n \n-/* Get the range of columns that would be printed for HINT.  */\n+/* Get the range of display columns that would be printed for HINT.  */\n \n static column_range\n get_printed_columns (const fixit_hint *hint)\n {\n-  int start_column = LOCATION_COLUMN (hint->get_start_loc ());\n-  int final_hint_column = start_column + hint->get_length () - 1;\n+  expanded_location exploc = expand_location (hint->get_start_loc ());\n+  int start_column = location_compute_display_column (exploc);\n+  int hint_width = cpp_display_width (hint->get_string (),\n+\t\t\t\t      hint->get_length ());\n+  int final_hint_column = start_column + hint_width - 1;\n   if (hint->insertion_p ())\n     {\n       return column_range (start_column, final_hint_column);\n     }\n   else\n     {\n-      int finish_column = LOCATION_COLUMN (hint->get_next_loc ()) - 1;\n-\n+      exploc = expand_location (hint->get_next_loc ());\n+      --exploc.column;\n+      int finish_column = location_compute_display_column (exploc);\n       return column_range (start_column,\n \t\t\t   MAX (finish_column, final_hint_column));\n     }\n@@ -1794,27 +2017,35 @@ get_printed_columns (const fixit_hint *hint)\n class correction\n {\n public:\n-  correction (column_range affected_columns,\n+  correction (column_range affected_bytes,\n+\t      column_range affected_columns,\n \t      column_range printed_columns,\n \t      const char *new_text, size_t new_text_len)\n-  : m_affected_columns (affected_columns),\n+  : m_affected_bytes (affected_bytes),\n+    m_affected_columns (affected_columns),\n     m_printed_columns (printed_columns),\n     m_text (xstrdup (new_text)),\n-    m_len (new_text_len),\n+    m_byte_length (new_text_len),\n     m_alloc_sz (new_text_len + 1)\n   {\n+    compute_display_cols ();\n   }\n \n   ~correction () { free (m_text); }\n \n   bool insertion_p () const\n   {\n-    return m_affected_columns.start == m_affected_columns.finish + 1;\n+    return m_affected_bytes.start == m_affected_bytes.finish + 1;\n   }\n \n   void ensure_capacity (size_t len);\n   void ensure_terminated ();\n \n+  void compute_display_cols ()\n+  {\n+    m_display_cols = cpp_display_width (m_text, m_byte_length);\n+  }\n+\n   void overwrite (int dst_offset, const char_span &src_span)\n   {\n     gcc_assert (dst_offset >= 0);\n@@ -1827,6 +2058,7 @@ class correction\n      is to be inserted, and finish is offset by the length of\n      the replacement.\n      If replace, then the range of columns affected.  */\n+  column_range m_affected_bytes;\n   column_range m_affected_columns;\n \n   /* If insert, then start: the column before which the text\n@@ -1837,7 +2069,8 @@ class correction\n \n   /* The text to be inserted/used as replacement.  */\n   char *m_text;\n-  size_t m_len;\n+  size_t m_byte_length; /* Not including null-terminator.  */\n+  int m_display_cols;\n   size_t m_alloc_sz;\n };\n \n@@ -1862,8 +2095,8 @@ void\n correction::ensure_terminated ()\n {\n   /* 0-terminate the buffer.  */\n-  gcc_assert (m_len < m_alloc_sz);\n-  m_text[m_len] = '\\0';\n+  gcc_assert (m_byte_length < m_alloc_sz);\n+  m_text[m_byte_length] = '\\0';\n }\n \n /* A list of corrections affecting a particular line.\n@@ -1925,7 +2158,8 @@ source_line::source_line (const char *filename, int line)\n void\n line_corrections::add_hint (const fixit_hint *hint)\n {\n-  column_range affected_columns = get_affected_columns (hint);\n+  column_range affected_bytes = get_affected_range (hint, CU_BYTES);\n+  column_range affected_columns = get_affected_range (hint, CU_DISPLAY_COLS);\n   column_range printed_columns = get_printed_columns (hint);\n \n   /* Potentially consolidate.  */\n@@ -1936,8 +2170,8 @@ line_corrections::add_hint (const fixit_hint *hint)\n \n       /* The following consolidation code assumes that the fix-it hints\n \t have been sorted by start (done within layout's ctor).  */\n-      gcc_assert (affected_columns.start\n-\t\t  >= last_correction->m_affected_columns.start);\n+      gcc_assert (affected_bytes.start\n+\t\t  >= last_correction->m_affected_bytes.start);\n       gcc_assert (printed_columns.start\n \t\t  >= last_correction->m_printed_columns.start);\n \n@@ -1949,8 +2183,8 @@ line_corrections::add_hint (const fixit_hint *hint)\n \t     Attempt to inject a \"replace\" correction from immediately\n \t     after the end of the last hint to immediately before the start\n \t     of the next hint.  */\n-\t  column_range between (last_correction->m_affected_columns.finish + 1,\n-\t\t\t\tprinted_columns.start - 1);\n+\t  column_range between (last_correction->m_affected_bytes.finish + 1,\n+\t\t\t\taffected_bytes.start - 1);\n \n \t  /* Try to read the source.  */\n \t  source_line line (m_filename, m_row);\n@@ -1959,33 +2193,39 @@ line_corrections::add_hint (const fixit_hint *hint)\n \t      /* Consolidate into the last correction:\n \t\t add a no-op \"replace\" of the \"between\" text, and\n \t\t add the text from the new hint.  */\n-\t      int old_len = last_correction->m_len;\n-\t      gcc_assert (old_len >= 0);\n-\t      int between_len = between.finish + 1 - between.start;\n-\t      gcc_assert (between_len >= 0);\n-\t      int new_len = old_len + between_len + hint->get_length ();\n-\t      gcc_assert (new_len >= 0);\n-\t      last_correction->ensure_capacity (new_len);\n+\t      int old_byte_len = last_correction->m_byte_length;\n+\t      gcc_assert (old_byte_len >= 0);\n+\t      int between_byte_len = between.finish + 1 - between.start;\n+\t      gcc_assert (between_byte_len >= 0);\n+\t      int new_byte_len\n+\t\t= old_byte_len + between_byte_len + hint->get_length ();\n+\t      gcc_assert (new_byte_len >= 0);\n+\t      last_correction->ensure_capacity (new_byte_len);\n \t      last_correction->overwrite\n-\t\t(old_len,\n+\t\t(old_byte_len,\n \t\t line.as_span ().subspan (between.start - 1,\n \t\t\t\t\t  between.finish + 1 - between.start));\n-\t      last_correction->overwrite (old_len + between_len,\n+\t      last_correction->overwrite (old_byte_len + between_byte_len,\n \t\t\t\t\t  char_span (hint->get_string (),\n \t\t\t\t\t\t     hint->get_length ()));\n-\t      last_correction->m_len = new_len;\n+\t      last_correction->m_byte_length = new_byte_len;\n \t      last_correction->ensure_terminated ();\n+\t      last_correction->m_affected_bytes.finish\n+\t\t= affected_bytes.finish;\n \t      last_correction->m_affected_columns.finish\n \t\t= affected_columns.finish;\n+\t      int prev_display_cols = last_correction->m_display_cols;\n+\t      last_correction->compute_display_cols ();\n \t      last_correction->m_printed_columns.finish\n-\t\t+= between_len + hint->get_length ();\n+\t\t+= last_correction->m_display_cols - prev_display_cols;\n \t      return;\n \t    }\n \t}\n     }\n \n   /* If no consolidation happened, add a new correction instance.  */\n-  m_corrections.safe_push (new correction (affected_columns,\n+  m_corrections.safe_push (new correction (affected_bytes,\n+\t\t\t\t\t   affected_columns,\n \t\t\t\t\t   printed_columns,\n \t\t\t\t\t   hint->get_string (),\n \t\t\t\t\t   hint->get_length ()));\n@@ -2018,7 +2258,7 @@ layout::print_trailing_fixits (linenum_type row)\n   /* Now print the corrections.  */\n   unsigned i;\n   correction *c;\n-  int column = m_x_offset;\n+  int column = m_x_offset_display;\n \n   if (!corrections.m_corrections.is_empty ())\n     start_annotation_line ();\n@@ -2034,7 +2274,7 @@ layout::print_trailing_fixits (linenum_type row)\n \t  m_colorizer.set_fixit_insert ();\n \t  pp_string (m_pp, c->m_text);\n \t  m_colorizer.set_normal_text ();\n-\t  column += c->m_len;\n+\t  column += c->m_display_cols;\n \t}\n       else\n \t{\n@@ -2046,7 +2286,7 @@ layout::print_trailing_fixits (linenum_type row)\n \t  int finish_column = c->m_affected_columns.finish;\n \t  if (!annotation_line_showed_range_p (row, start_column,\n \t\t\t\t\t       finish_column)\n-\t      || c->m_len == 0)\n+\t      || c->m_byte_length == 0)\n \t    {\n \t      move_to_column (&column, start_column, true);\n \t      m_colorizer.set_fixit_delete ();\n@@ -2057,13 +2297,13 @@ layout::print_trailing_fixits (linenum_type row)\n \t  /* Print the replacement text.  REPLACE also covers\n \t     removals, so only do this extra work (potentially starting\n \t     a new line) if we have actual replacement text.  */\n-\t  if (c->m_len > 0)\n+\t  if (c->m_byte_length > 0)\n \t    {\n \t      move_to_column (&column, start_column, true);\n \t      m_colorizer.set_fixit_insert ();\n \t      pp_string (m_pp, c->m_text);\n \t      m_colorizer.set_normal_text ();\n-\t      column += c->m_len;\n+\t      column += c->m_display_cols;\n \t    }\n \t}\n     }\n@@ -2084,12 +2324,14 @@ layout::print_newline ()\n /* Return true if (ROW/COLUMN) is within a range of the layout.\n    If it returns true, OUT_STATE is written to, with the\n    range index, and whether we should draw the caret at\n-   (ROW/COLUMN) (as opposed to an underline).  */\n+   (ROW/COLUMN) (as opposed to an underline).  COL_UNIT controls\n+   whether all inputs and outputs are in bytes or display column units.  */\n \n bool\n layout::get_state_at_point (/* Inputs.  */\n \t\t\t    linenum_type row, int column,\n \t\t\t    int first_non_ws, int last_non_ws,\n+\t\t\t    enum column_unit col_unit,\n \t\t\t    /* Outputs.  */\n \t\t\t    point_state *out_state)\n {\n@@ -2102,15 +2344,15 @@ layout::get_state_at_point (/* Inputs.  */\n \t   source colorization.  */\n \tcontinue;\n \n-      if (range->contains_point (row, column))\n+      if (range->contains_point (row, column, col_unit))\n \t{\n \t  out_state->range_idx = i;\n \n \t  /* Are we at the range's caret?  is it visible? */\n \t  out_state->draw_caret_p = false;\n \t  if (range->m_range_display_kind == SHOW_RANGE_WITH_CARET\n \t      && row == range->m_caret.m_line\n-\t      && column == range->m_caret.m_column)\n+\t      && column == range->m_caret.m_columns[col_unit])\n \t    out_state->draw_caret_p = true;\n \n \t  /* Within a multiline range, don't display any underline\n@@ -2130,11 +2372,11 @@ layout::get_state_at_point (/* Inputs.  */\n \n /* Helper function for use by layout::print_line when printing the\n    annotation line under the source line.\n-   Get the column beyond the rightmost one that could contain a caret or\n-   range marker, given that we stop rendering at trailing whitespace.\n+   Get the display column beyond the rightmost one that could contain a caret\n+   or range marker, given that we stop rendering at trailing whitespace.\n    ROW is the source line within the given file.\n-   CARET_COLUMN is the column of range 0's caret.\n-   LAST_NON_WS_COLUMN is the last column containing a non-whitespace\n+   CARET_COLUMN is the display column of range 0's caret.\n+   LAST_NON_WS_COLUMN is the last display column containing a non-whitespace\n    character of source (as determined when printing the source line).  */\n \n int\n@@ -2153,8 +2395,9 @@ layout::get_x_bound_for_row (linenum_type row, int caret_column,\n \t    {\n \t      /* On the final line within a range; ensure that\n \t\t we render up to the end of the range.  */\n-\t      if (result <= range->m_finish.m_column)\n-\t\tresult = range->m_finish.m_column + 1;\n+\t      const int disp_col = range->m_finish.m_columns[CU_DISPLAY_COLS];\n+\t      if (result <= disp_col)\n+\t\tresult = disp_col + 1;\n \t    }\n \t  else if (row < range->m_finish.m_line)\n \t    {\n@@ -2183,7 +2426,7 @@ layout::move_to_column (int *column, int dest_column, bool add_left_margin)\n       print_newline ();\n       if (add_left_margin)\n \tstart_annotation_line ();\n-      *column = m_x_offset;\n+      *column = m_x_offset_display;\n     }\n \n   while (*column < dest_column)\n@@ -2204,7 +2447,7 @@ layout::show_ruler (int max_column) const\n     {\n       start_annotation_line ();\n       pp_space (m_pp);\n-      for (int column = 1 + m_x_offset; column <= max_column; column++)\n+      for (int column = 1 + m_x_offset_display; column <= max_column; column++)\n \tif (column % 10 == 0)\n \t  pp_character (m_pp, '0' + (column / 100) % 10);\n \telse\n@@ -2215,7 +2458,7 @@ layout::show_ruler (int max_column) const\n   /* Tens.  */\n   start_annotation_line ();\n   pp_space (m_pp);\n-  for (int column = 1 + m_x_offset; column <= max_column; column++)\n+  for (int column = 1 + m_x_offset_display; column <= max_column; column++)\n     if (column % 10 == 0)\n       pp_character (m_pp, '0' + (column / 10) % 10);\n     else\n@@ -2225,7 +2468,7 @@ layout::show_ruler (int max_column) const\n   /* Units.  */\n   start_annotation_line ();\n   pp_space (m_pp);\n-  for (int column = 1 + m_x_offset; column <= max_column; column++)\n+  for (int column = 1 + m_x_offset_display; column <= max_column; column++)\n     pp_character (m_pp, '0' + (column % 10));\n   pp_newline (m_pp);\n }\n@@ -2245,7 +2488,11 @@ layout::print_line (linenum_type row)\n   print_leading_fixits (row);\n   print_source_line (row, line.get_buffer (), line.length (), &lbounds);\n   if (should_print_annotation_line_p (row))\n-    print_annotation_line (row, lbounds);\n+    {\n+      if (lbounds.m_first_non_ws != INT_MAX)\n+\tlbounds.convert_to_display_cols (line);\n+      print_annotation_line (row, lbounds);\n+    }\n   if (m_show_labels_p)\n     print_any_labels (row);\n   print_trailing_fixits (row);\n@@ -2339,6 +2586,178 @@ namespace selftest {\n \n /* Selftests for diagnostic_show_locus.  */\n \n+/* For precise tests of the layout, make clear where the source line will\n+   start.  test_left_margin sets the total byte count from the left side of the\n+   screen to the start of source lines, after the line number and the separator,\n+   which consists of the three characters \" | \".  */\n+static const int test_linenum_sep = 3;\n+static const int test_left_margin = 7;\n+\n+/* Helper function for test_layout_x_offset_display_utf8().  */\n+static void\n+test_offset_impl (int caret_byte_col, int max_width,\n+\t\t  int expected_x_offset_display,\n+\t\t  int left_margin = test_left_margin)\n+{\n+  test_diagnostic_context dc;\n+  dc.caret_max_width = max_width;\n+  /* diagnostic_context::min_margin_width sets the minimum space reserved for\n+     the line number plus one space after.  */\n+  dc.min_margin_width = left_margin - test_linenum_sep + 1;\n+  dc.show_line_numbers_p = true;\n+  rich_location richloc (line_table,\n+\t\t\t linemap_position_for_column (line_table,\n+\t\t\t\t\t\t      caret_byte_col));\n+  layout test_layout (&dc, &richloc, DK_ERROR);\n+  ASSERT_EQ (left_margin - test_linenum_sep,\n+\t     test_layout.get_linenum_width ());\n+  ASSERT_EQ (expected_x_offset_display,\n+\t     test_layout.get_x_offset_display ());\n+}\n+\n+/* Test that layout::calculate_x_offset_display() works.  */\n+static void\n+test_layout_x_offset_display_utf8 (const line_table_case &case_)\n+{\n+\n+  const char *content\n+    = \"This line is very long, so that we can use it to test the logic for \"\n+      \"clipping long lines.  Also this: \\xf0\\x9f\\x98\\x82\\xf0\\x9f\\x98\\x82 is a \"\n+      \"pair of emojis that occupies 8 bytes and 4 display columns, starting at \"\n+      \"column #102.\\n\";\n+\n+  /* Number of bytes in the line, subtracting one to remove the newline.  */\n+  const int line_bytes = strlen (content) - 1;\n+\n+  /* Number of display columns occupied by the line; each of the 2 emojis\n+     takes up 2 fewer display columns than it does bytes.  */\n+  const int line_display_cols = line_bytes - 2*2;\n+\n+  /* The column of the first emoji.  Byte or display is the same as there are\n+     no multibyte characters earlier on the line.  */\n+  const int emoji_col = 102;\n+\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", content);\n+  line_table_test ltt (case_);\n+\n+  linemap_add (line_table, LC_ENTER, false, tmp.get_filename (), 1);\n+\n+  location_t line_end = linemap_position_for_column (line_table, line_bytes);\n+\n+  /* Don't attempt to run the tests if column data might be unavailable.  */\n+  if (line_end > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  ASSERT_STREQ (tmp.get_filename (), LOCATION_FILE (line_end));\n+  ASSERT_EQ (1, LOCATION_LINE (line_end));\n+  ASSERT_EQ (line_bytes, LOCATION_COLUMN (line_end));\n+\n+  char_span lspan = location_get_source_line (tmp.get_filename (), 1);\n+  ASSERT_EQ (line_display_cols,\n+\t     cpp_display_width (lspan.get_buffer (), lspan.length ()));\n+  ASSERT_EQ (line_display_cols,\n+\t     location_compute_display_column (expand_location (line_end)));\n+  ASSERT_EQ (0, memcmp (lspan.get_buffer () + (emoji_col - 1),\n+\t\t\t\"\\xf0\\x9f\\x98\\x82\\xf0\\x9f\\x98\\x82\", 8));\n+\n+  /* (caret_byte, max_width, expected_x_offset_display, [left_margin])  */\n+\n+  /* No constraint on the width -> no offset.  */\n+  test_offset_impl (emoji_col, 0, 0);\n+\n+  /* Caret is before the beginning -> no offset.  */\n+  test_offset_impl (0, 100, 0);\n+\n+  /* Caret is past the end of the line -> no offset.  */\n+  test_offset_impl (line_bytes+1, 100, 0);\n+\n+  /* Line fits in the display -> no offset.  */\n+  test_offset_impl (line_bytes, line_display_cols + test_left_margin, 0);\n+  test_offset_impl (emoji_col, line_display_cols + test_left_margin, 0);\n+\n+  /* Line is too long for the display but caret location is OK\n+     anyway -> no offset.  */\n+  static const int small_width = 24;\n+  test_offset_impl (1, small_width, 0);\n+\n+  /* Width constraint is very small -> no offset.  */\n+  test_offset_impl (emoji_col, CARET_LINE_MARGIN, 0);\n+\n+  /* Line would be offset, but due to large line numbers, offsetting\n+     would remove the whole line -> no offset.  */\n+  static const int huge_left_margin = 100;\n+  test_offset_impl (emoji_col, huge_left_margin, 0, huge_left_margin);\n+\n+  /* Line is the same length as the display, but the line number makes it too\n+     long, so offset is required.  Caret is at the end so padding on the right\n+     is not in effect.  */\n+  for (int excess = 1; excess <= 3; ++excess)\n+    test_offset_impl (line_bytes, line_display_cols + test_left_margin - excess,\n+\t\t      excess);\n+\n+  /* Line is much too long for the display, caret is near the end ->\n+     offset should be such that the line fits in the display and caret\n+     remains the same distance from the end that it was.  */\n+  for (int caret_offset = 0, max_offset = MIN (CARET_LINE_MARGIN, 10);\n+       caret_offset <= max_offset; ++caret_offset)\n+    test_offset_impl (line_bytes - caret_offset, small_width,\n+\t\t      line_display_cols + test_left_margin - small_width);\n+\n+  /* As previous case but caret is closer to the middle; now we want it to end\n+     up CARET_LINE_MARGIN bytes from the end.  */\n+  ASSERT_GT (line_display_cols - emoji_col, CARET_LINE_MARGIN);\n+  test_offset_impl (emoji_col, small_width,\n+\t\t    emoji_col + test_left_margin\n+\t\t    - (small_width - CARET_LINE_MARGIN));\n+\n+  /* Test that the source line is offset as expected when printed.  */\n+  {\n+    test_diagnostic_context dc;\n+    dc.caret_max_width = small_width - 6;\n+    dc.min_margin_width = test_left_margin - test_linenum_sep + 1;\n+    dc.show_line_numbers_p = true;\n+    dc.show_ruler_p = true;\n+    rich_location richloc (line_table,\n+\t\t\t   linemap_position_for_column (line_table,\n+\t\t\t\t\t\t\temoji_col));\n+    layout test_layout (&dc, &richloc, DK_ERROR);\n+    test_layout.print_line (1);\n+    ASSERT_STREQ (\"     |         1         \\n\"\n+\t\t  \"     |         1         \\n\"\n+\t\t  \"     | 234567890123456789\\n\"\n+\t\t  \"   1 | \\xf0\\x9f\\x98\\x82\\xf0\\x9f\\x98\\x82 is a pair of emojis \"\n+\t\t  \"that occupies 8 bytes and 4 display columns, starting at \"\n+\t\t  \"column #102.\\n\"\n+\t\t  \"     | ^\\n\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+\n+  /* Similar to the previous example, but now the offset called for would split\n+     the first emoji in the middle of the UTF-8 sequence.  Check that we replace\n+     it with a padding space in this case.  */\n+  {\n+    test_diagnostic_context dc;\n+    dc.caret_max_width = small_width - 5;\n+    dc.min_margin_width = test_left_margin - test_linenum_sep + 1;\n+    dc.show_line_numbers_p = true;\n+    dc.show_ruler_p = true;\n+    rich_location richloc (line_table,\n+\t\t\t   linemap_position_for_column (line_table,\n+\t\t\t\t\t\t\temoji_col + 2));\n+    layout test_layout (&dc, &richloc, DK_ERROR);\n+    test_layout.print_line (1);\n+    ASSERT_STREQ (\"     |        1         1 \\n\"\n+\t\t  \"     |        1         2 \\n\"\n+\t\t  \"     | 3456789012345678901\\n\"\n+\t\t  \"   1 |  \\xf0\\x9f\\x98\\x82 is a pair of emojis \"\n+\t\t  \"that occupies 8 bytes and 4 display columns, starting at \"\n+\t\t  \"column #102.\\n\"\n+\t\t  \"     |  ^\\n\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+\n+}\n+\n /* Verify that diagnostic_show_locus works sanely on UNKNOWN_LOCATION.  */\n \n static void\n@@ -2965,77 +3384,622 @@ test_diagnostic_show_locus_one_liner (const line_table_case &case_)\n   test_one_liner_labels ();\n }\n \n-/* Verify that gcc_rich_location::add_location_if_nearby works.  */\n+/* Version of all one-liner tests exercising multibyte awareness.  For\n+   simplicity we stick to using two multibyte characters in the test, U+1F602\n+   == \"\\xf0\\x9f\\x98\\x82\", which uses 4 bytes and 2 display columns, and U+03C0\n+   == \"\\xcf\\x80\", which uses 2 bytes and 1 display column.  Note: all of the\n+   below asserts would be easier to read if we used UTF-8 directly in the\n+   string constants, but it seems better not to demand the host compiler\n+   support this, when it isn't otherwise necessary.  Instead, whenever an\n+   extended character appears in a string, we put a line break after it so that\n+   all succeeding characters can appear visually at the correct display column.\n+\n+   All of these work on the following 1-line source file:\n+\n+     .0000000001111111111222222   display\n+     .1234567890123456789012345   columns\n+     \"SS_foo = P_bar.SS_fieldP;\\n\"\n+     .0000000111111111222222223   byte\n+     .1356789012456789134567891   columns\n+\n+   which is set up by test_diagnostic_show_locus_one_liner and calls\n+   them.  Here SS represents the two display columns for the U+1F602 emoji and\n+   P represents the one display column for the U+03C0 pi symbol.  */\n+\n+/* Just a caret.  */\n \n static void\n-test_add_location_if_nearby (const line_table_case &case_)\n+test_one_liner_simple_caret_utf8 ()\n {\n-  /* Create a tempfile and write some text to it.\n-     ...000000000111111111122222222223333333333.\n-     ...123456789012345678901234567890123456789.  */\n-  const char *content\n-    = (\"struct same_line { double x; double y; ;\\n\" /* line 1.  */\n-       \"struct different_line\\n\"                    /* line 2.  */\n-       \"{\\n\"                                        /* line 3.  */\n-       \"  double x;\\n\"                              /* line 4.  */\n-       \"  double y;\\n\"                              /* line 5.  */\n-       \";\\n\");                                      /* line 6.  */\n-  temp_source_file tmp (SELFTEST_LOCATION, \".c\", content);\n-  line_table_test ltt (case_);\n+  test_diagnostic_context dc;\n+  location_t caret = linemap_position_for_column (line_table, 18);\n+  rich_location richloc (line_table, caret);\n+  diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+  ASSERT_STREQ (\"\\n\"\n+\t\t\" \\xf0\\x9f\\x98\\x82\"\n+\t\t   \"_foo = \\xcf\\x80\"\n+\t\t\t   \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \"_field\\xcf\\x80\"\n+\t\t\t\t\t \";\\n\"\n+\t\t\"               ^\\n\",\n+\t\tpp_formatted_text (dc.printer));\n+}\n \n-  const line_map_ordinary *ord_map\n-    = linemap_check_ordinary (linemap_add (line_table, LC_ENTER, false,\n-\t\t\t\t\t   tmp.get_filename (), 0));\n+/* Caret and range.  */\n+static void\n+test_one_liner_caret_and_range_utf8 ()\n+{\n+  test_diagnostic_context dc;\n+  location_t caret = linemap_position_for_column (line_table, 18);\n+  location_t start = linemap_position_for_column (line_table, 12);\n+  location_t finish = linemap_position_for_column (line_table, 30);\n+  location_t loc = make_location (caret, start, finish);\n+  rich_location richloc (line_table, loc);\n+  diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+  ASSERT_STREQ (\"\\n\"\n+\t\t\" \\xf0\\x9f\\x98\\x82\"\n+\t\t   \"_foo = \\xcf\\x80\"\n+\t\t\t   \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \"_field\\xcf\\x80\"\n+\t\t\t\t\t \";\\n\"\n+\t\t\"          ~~~~~^~~~~~~~~~\\n\",\n+\t\tpp_formatted_text (dc.printer));\n+}\n \n-  linemap_line_start (line_table, 1, 100);\n+/* Multiple ranges and carets.  */\n \n-  const location_t final_line_end\n-    = linemap_position_for_line_and_column (line_table, ord_map, 6, 7);\n+static void\n+test_one_liner_multiple_carets_and_ranges_utf8 ()\n+{\n+  test_diagnostic_context dc;\n+  location_t foo\n+    = make_location (linemap_position_for_column (line_table, 7),\n+\t\t     linemap_position_for_column (line_table, 1),\n+\t\t     linemap_position_for_column (line_table, 8));\n+  dc.caret_chars[0] = 'A';\n \n-  /* Don't attempt to run the tests if column data might be unavailable.  */\n-  if (final_line_end > LINE_MAP_MAX_LOCATION_WITH_COLS)\n-    return;\n+  location_t bar\n+    = make_location (linemap_position_for_column (line_table, 16),\n+\t\t     linemap_position_for_column (line_table, 12),\n+\t\t     linemap_position_for_column (line_table, 17));\n+  dc.caret_chars[1] = 'B';\n \n-  /* Test of add_location_if_nearby on the same line as the\n-     primary location.  */\n-  {\n-    const location_t missing_close_brace_1_39\n-      = linemap_position_for_line_and_column (line_table, ord_map, 1, 39);\n-    const location_t matching_open_brace_1_18\n-      = linemap_position_for_line_and_column (line_table, ord_map, 1, 18);\n-    gcc_rich_location richloc (missing_close_brace_1_39);\n-    bool added = richloc.add_location_if_nearby (matching_open_brace_1_18);\n-    ASSERT_TRUE (added);\n-    ASSERT_EQ (2, richloc.get_num_locations ());\n-    test_diagnostic_context dc;\n-    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n-    ASSERT_STREQ (\"\\n\"\n-\t\t  \" struct same_line { double x; double y; ;\\n\"\n-\t\t  \"                  ~                    ^\\n\",\n-\t\t  pp_formatted_text (dc.printer));\n-  }\n+  location_t field\n+    = make_location (linemap_position_for_column (line_table, 26),\n+\t\t     linemap_position_for_column (line_table, 19),\n+\t\t     linemap_position_for_column (line_table, 30));\n+  dc.caret_chars[2] = 'C';\n+  rich_location richloc (line_table, foo);\n+  richloc.add_range (bar, SHOW_RANGE_WITH_CARET);\n+  richloc.add_range (field, SHOW_RANGE_WITH_CARET);\n+  diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+  ASSERT_STREQ (\"\\n\"\n+\t\t\" \\xf0\\x9f\\x98\\x82\"\n+\t\t   \"_foo = \\xcf\\x80\"\n+\t\t\t   \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \"_field\\xcf\\x80\"\n+\t\t\t\t\t \";\\n\"\n+\t\t\" ~~~~A~   ~~~B~ ~~~~~C~~~\\n\",\n+\t\tpp_formatted_text (dc.printer));\n+}\n \n-  /* Test of add_location_if_nearby on a different line to the\n-     primary location.  */\n-  {\n-    const location_t missing_close_brace_6_1\n-      = linemap_position_for_line_and_column (line_table, ord_map, 6, 1);\n-    const location_t matching_open_brace_3_1\n-      = linemap_position_for_line_and_column (line_table, ord_map, 3, 1);\n-    gcc_rich_location richloc (missing_close_brace_6_1);\n-    bool added = richloc.add_location_if_nearby (matching_open_brace_3_1);\n-    ASSERT_FALSE (added);\n-    ASSERT_EQ (1, richloc.get_num_locations ());\n-  }\n+/* Insertion fix-it hint: adding an \"&\" to the front of \"P_bar.field\". */\n+\n+static void\n+test_one_liner_fixit_insert_before_utf8 ()\n+{\n+  test_diagnostic_context dc;\n+  location_t caret = linemap_position_for_column (line_table, 12);\n+  rich_location richloc (line_table, caret);\n+  richloc.add_fixit_insert_before (\"&\");\n+  diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+  ASSERT_STREQ (\"\\n\"\n+\t\t\" \\xf0\\x9f\\x98\\x82\"\n+\t\t   \"_foo = \\xcf\\x80\"\n+\t\t\t   \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \"_field\\xcf\\x80\"\n+\t\t\t\t\t \";\\n\"\n+\t\t\"          ^\\n\"\n+\t\t\"          &\\n\",\n+\t\tpp_formatted_text (dc.printer));\n }\n \n-/* Verify that we print fixits even if they only affect lines\n-   outside those covered by the ranges in the rich_location.  */\n+/* Insertion fix-it hint: adding a \"[0]\" after \"SS_foo\". */\n \n static void\n-test_diagnostic_show_locus_fixit_lines (const line_table_case &case_)\n+test_one_liner_fixit_insert_after_utf8 ()\n {\n-  /* Create a tempfile and write some text to it.\n+  test_diagnostic_context dc;\n+  location_t start = linemap_position_for_column (line_table, 1);\n+  location_t finish = linemap_position_for_column (line_table, 8);\n+  location_t foo = make_location (start, start, finish);\n+  rich_location richloc (line_table, foo);\n+  richloc.add_fixit_insert_after (\"[0]\");\n+  diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+  ASSERT_STREQ (\"\\n\"\n+\t\t\" \\xf0\\x9f\\x98\\x82\"\n+\t\t   \"_foo = \\xcf\\x80\"\n+\t\t\t   \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \"_field\\xcf\\x80\"\n+\t\t\t\t\t \";\\n\"\n+\t\t\" ^~~~~~\\n\"\n+\t\t\"       [0]\\n\",\n+\t\tpp_formatted_text (dc.printer));\n+}\n+\n+/* Removal fix-it hint: removal of the \".SS_fieldP\". */\n+\n+static void\n+test_one_liner_fixit_remove_utf8 ()\n+{\n+  test_diagnostic_context dc;\n+  location_t start = linemap_position_for_column (line_table, 18);\n+  location_t finish = linemap_position_for_column (line_table, 30);\n+  location_t dot = make_location (start, start, finish);\n+  rich_location richloc (line_table, dot);\n+  richloc.add_fixit_remove ();\n+  diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+  ASSERT_STREQ (\"\\n\"\n+\t\t\" \\xf0\\x9f\\x98\\x82\"\n+\t\t   \"_foo = \\xcf\\x80\"\n+\t\t\t   \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \"_field\\xcf\\x80\"\n+\t\t\t\t\t \";\\n\"\n+\t\t\"               ^~~~~~~~~~\\n\"\n+\t\t\"               ----------\\n\",\n+\t\tpp_formatted_text (dc.printer));\n+}\n+\n+/* Replace fix-it hint: replacing \"SS_fieldP\" with \"m_SSfieldP\". */\n+\n+static void\n+test_one_liner_fixit_replace_utf8 ()\n+{\n+  test_diagnostic_context dc;\n+  location_t start = linemap_position_for_column (line_table, 19);\n+  location_t finish = linemap_position_for_column (line_table, 30);\n+  location_t field = make_location (start, start, finish);\n+  rich_location richloc (line_table, field);\n+  richloc.add_fixit_replace (\"m_\\xf0\\x9f\\x98\\x82_field\\xcf\\x80\");\n+  diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+  ASSERT_STREQ (\"\\n\"\n+\t\t\" \\xf0\\x9f\\x98\\x82\"\n+\t\t   \"_foo = \\xcf\\x80\"\n+\t\t\t   \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \"_field\\xcf\\x80\"\n+\t\t\t\t\t \";\\n\"\n+\t\t\"                ^~~~~~~~~\\n\"\n+\t\t\"                m_\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t    \"_field\\xcf\\x80\\n\",\n+\t\tpp_formatted_text (dc.printer));\n+}\n+\n+/* Replace fix-it hint: replacing \"SS_fieldP\" with \"m_SSfieldP\",\n+   but where the caret was elsewhere.  */\n+\n+static void\n+test_one_liner_fixit_replace_non_equal_range_utf8 ()\n+{\n+  test_diagnostic_context dc;\n+  location_t equals = linemap_position_for_column (line_table, 10);\n+  location_t start = linemap_position_for_column (line_table, 19);\n+  location_t finish = linemap_position_for_column (line_table, 30);\n+  rich_location richloc (line_table, equals);\n+  source_range range;\n+  range.m_start = start;\n+  range.m_finish = finish;\n+  richloc.add_fixit_replace (range, \"m_\\xf0\\x9f\\x98\\x82_field\\xcf\\x80\");\n+  diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+  /* The replacement range is not indicated in the annotation line, so\n+     it should be indicated via an additional underline.  */\n+  ASSERT_STREQ (\"\\n\"\n+\t\t\" \\xf0\\x9f\\x98\\x82\"\n+\t\t   \"_foo = \\xcf\\x80\"\n+\t\t\t   \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \"_field\\xcf\\x80\"\n+\t\t\t\t\t \";\\n\"\n+\t\t\"        ^\\n\"\n+\t\t\"                ---------\\n\"\n+\t\t\"                m_\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t    \"_field\\xcf\\x80\\n\",\n+\t\tpp_formatted_text (dc.printer));\n+}\n+\n+/* Replace fix-it hint: replacing \"SS_fieldP\" with \"m_SSfieldP\",\n+   where the caret was elsewhere, but where a secondary range\n+   exactly covers \"field\".  */\n+\n+static void\n+test_one_liner_fixit_replace_equal_secondary_range_utf8 ()\n+{\n+  test_diagnostic_context dc;\n+  location_t equals = linemap_position_for_column (line_table, 10);\n+  location_t start = linemap_position_for_column (line_table, 19);\n+  location_t finish = linemap_position_for_column (line_table, 30);\n+  rich_location richloc (line_table, equals);\n+  location_t field = make_location (start, start, finish);\n+  richloc.add_range (field);\n+  richloc.add_fixit_replace (field, \"m_\\xf0\\x9f\\x98\\x82_field\\xcf\\x80\");\n+  diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+  /* The replacement range is indicated in the annotation line,\n+     so it shouldn't be indicated via an additional underline.  */\n+  ASSERT_STREQ (\"\\n\"\n+\t\t\" \\xf0\\x9f\\x98\\x82\"\n+\t\t   \"_foo = \\xcf\\x80\"\n+\t\t\t   \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \"_field\\xcf\\x80\"\n+\t\t\t\t\t \";\\n\"\n+\t\t\"        ^       ~~~~~~~~~\\n\"\n+\t\t\"                m_\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t    \"_field\\xcf\\x80\\n\",\n+\t\tpp_formatted_text (dc.printer));\n+}\n+\n+/* Verify that we can use ad-hoc locations when adding fixits to a\n+   rich_location.  */\n+\n+static void\n+test_one_liner_fixit_validation_adhoc_locations_utf8 ()\n+{\n+  /* Generate a range that's too long to be packed, so must\n+     be stored as an ad-hoc location (given the defaults\n+     of 5 bits or 0 bits of packed range); 41 columns > 2**5.  */\n+  const location_t c12 = linemap_position_for_column (line_table, 12);\n+  const location_t c52 = linemap_position_for_column (line_table, 52);\n+  const location_t loc = make_location (c12, c12, c52);\n+\n+  if (c52 > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  ASSERT_TRUE (IS_ADHOC_LOC (loc));\n+\n+  /* Insert.  */\n+  {\n+    rich_location richloc (line_table, loc);\n+    richloc.add_fixit_insert_before (loc, \"test\");\n+    /* It should not have been discarded by the validator.  */\n+    ASSERT_EQ (1, richloc.get_num_fixit_hints ());\n+\n+    test_diagnostic_context dc;\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \" \\xf0\\x9f\\x98\\x82\"\n+\t\t     \"_foo = \\xcf\\x80\"\n+\t\t\t     \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t    \"_field\\xcf\\x80\"\n+\t\t\t\t\t   \";\\n\"\n+\t\t  \"          ^~~~~~~~~~~~~~~~                     \\n\"\n+\t\t  \"          test\\n\",\n+\t\tpp_formatted_text (dc.printer));\n+  }\n+\n+  /* Remove.  */\n+  {\n+    rich_location richloc (line_table, loc);\n+    source_range range = source_range::from_locations (loc, c52);\n+    richloc.add_fixit_remove (range);\n+    /* It should not have been discarded by the validator.  */\n+    ASSERT_EQ (1, richloc.get_num_fixit_hints ());\n+\n+    test_diagnostic_context dc;\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \" \\xf0\\x9f\\x98\\x82\"\n+\t\t     \"_foo = \\xcf\\x80\"\n+\t\t\t     \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t    \"_field\\xcf\\x80\"\n+\t\t\t\t\t   \";\\n\"\n+\t\t  \"          ^~~~~~~~~~~~~~~~                     \\n\"\n+\t\t  \"          -------------------------------------\\n\",\n+\t\tpp_formatted_text (dc.printer));\n+  }\n+\n+  /* Replace.  */\n+  {\n+    rich_location richloc (line_table, loc);\n+    source_range range = source_range::from_locations (loc, c52);\n+    richloc.add_fixit_replace (range, \"test\");\n+    /* It should not have been discarded by the validator.  */\n+    ASSERT_EQ (1, richloc.get_num_fixit_hints ());\n+\n+    test_diagnostic_context dc;\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \" \\xf0\\x9f\\x98\\x82\"\n+\t\t     \"_foo = \\xcf\\x80\"\n+\t\t\t     \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t    \"_field\\xcf\\x80\"\n+\t\t\t\t\t   \";\\n\"\n+\t\t  \"          ^~~~~~~~~~~~~~~~                     \\n\"\n+\t\t  \"          test\\n\",\n+\t\tpp_formatted_text (dc.printer));\n+  }\n+}\n+\n+/* Test of consolidating insertions at the same location.  */\n+\n+static void\n+test_one_liner_many_fixits_1_utf8 ()\n+{\n+  test_diagnostic_context dc;\n+  location_t equals = linemap_position_for_column (line_table, 10);\n+  rich_location richloc (line_table, equals);\n+  for (int i = 0; i < 19; i++)\n+    richloc.add_fixit_insert_before (i & 1 ? \"@\" : \"\\xcf\\x80\");\n+  ASSERT_EQ (1, richloc.get_num_fixit_hints ());\n+  diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+  ASSERT_STREQ (\"\\n\"\n+\t\t\" \\xf0\\x9f\\x98\\x82\"\n+\t\t   \"_foo = \\xcf\\x80\"\n+\t\t\t   \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \"_field\\xcf\\x80\"\n+\t\t\t\t\t \";\\n\"\n+\t\t\"        ^\\n\"\n+\t\t\"        \\xcf\\x80@\\xcf\\x80@\\xcf\\x80@\\xcf\\x80@\\xcf\\x80@\"\n+\t\t\"\\xcf\\x80@\\xcf\\x80@\\xcf\\x80@\\xcf\\x80@\\xcf\\x80\\n\",\n+\t\tpp_formatted_text (dc.printer));\n+}\n+\n+/* Ensure that we can add an arbitrary number of fix-it hints to a\n+   rich_location, even if they are not consolidated.  */\n+\n+static void\n+test_one_liner_many_fixits_2_utf8 ()\n+{\n+  test_diagnostic_context dc;\n+  location_t equals = linemap_position_for_column (line_table, 10);\n+  rich_location richloc (line_table, equals);\n+  const int nlocs = 19;\n+  int locs[nlocs] = {1, 5, 7, 9, 11, 14, 16, 18, 23, 25, 27, 29, 32,\n+\t\t     34, 36, 38, 40, 42, 44};\n+  for (int i = 0; i != nlocs; ++i)\n+    {\n+      location_t loc = linemap_position_for_column (line_table, locs[i]);\n+      richloc.add_fixit_insert_before (loc, i & 1 ? \"@\" : \"\\xcf\\x80\");\n+    }\n+\n+  ASSERT_EQ (nlocs, richloc.get_num_fixit_hints ());\n+  diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+  ASSERT_STREQ (\"\\n\"\n+\t\t\" \\xf0\\x9f\\x98\\x82\"\n+\t\t   \"_foo = \\xcf\\x80\"\n+\t\t\t   \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \"_field\\xcf\\x80\"\n+\t\t\t\t\t \";\\n\"\n+\t\t\"        ^\\n\"\n+\t\t\" \\xcf\\x80 @ \\xcf\\x80 @ \\xcf\\x80 @ \\xcf\\x80 @  \\xcf\\x80 @\"\n+\t\t\" \\xcf\\x80 @ \\xcf\\x80 @ \\xcf\\x80 @ \\xcf\\x80 @ \\xcf\\x80\\n\",\n+\t\tpp_formatted_text (dc.printer));\n+}\n+\n+/* Test of labeling the ranges within a rich_location.  */\n+\n+static void\n+test_one_liner_labels_utf8 ()\n+{\n+  location_t foo\n+    = make_location (linemap_position_for_column (line_table, 1),\n+\t\t     linemap_position_for_column (line_table, 1),\n+\t\t     linemap_position_for_column (line_table, 8));\n+  location_t bar\n+    = make_location (linemap_position_for_column (line_table, 12),\n+\t\t     linemap_position_for_column (line_table, 12),\n+\t\t     linemap_position_for_column (line_table, 17));\n+  location_t field\n+    = make_location (linemap_position_for_column (line_table, 19),\n+\t\t     linemap_position_for_column (line_table, 19),\n+\t\t     linemap_position_for_column (line_table, 30));\n+\n+  /* Example where all the labels fit on one line.  */\n+  {\n+    /* These three labels contain multibyte characters such that their byte\n+       lengths are respectively (12, 10, 18), but their display widths are only\n+       (6, 5, 9).  All three fit on the line when considering the display\n+       widths, but not when considering the byte widths, so verify that we do\n+       indeed put them all on one line.  */\n+    text_range_label label0\n+      (\"\\xcf\\x80\\xcf\\x80\\xcf\\x80\\xcf\\x80\\xcf\\x80\\xcf\\x80\");\n+    text_range_label label1\n+      (\"\\xf0\\x9f\\x98\\x82\\xf0\\x9f\\x98\\x82\\xcf\\x80\");\n+    text_range_label label2\n+      (\"\\xf0\\x9f\\x98\\x82\\xcf\\x80\\xf0\\x9f\\x98\\x82\\xf0\\x9f\\x98\\x82\\xcf\\x80\"\n+       \"\\xcf\\x80\");\n+    gcc_rich_location richloc (foo, &label0);\n+    richloc.add_range (bar, SHOW_RANGE_WITHOUT_CARET, &label1);\n+    richloc.add_range (field, SHOW_RANGE_WITHOUT_CARET, &label2);\n+\n+    {\n+      test_diagnostic_context dc;\n+      diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+      ASSERT_STREQ (\"\\n\"\n+\t\t    \" \\xf0\\x9f\\x98\\x82\"\n+\t\t       \"_foo = \\xcf\\x80\"\n+\t\t\t       \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t      \"_field\\xcf\\x80\"\n+\t\t\t\t\t     \";\\n\"\n+\t\t    \" ^~~~~~   ~~~~~ ~~~~~~~~~\\n\"\n+\t\t    \" |        |     |\\n\"\n+\t\t    \" \\xcf\\x80\\xcf\\x80\\xcf\\x80\\xcf\\x80\\xcf\\x80\\xcf\\x80\"\n+\t\t\t   \"   \\xf0\\x9f\\x98\\x82\\xf0\\x9f\\x98\\x82\\xcf\\x80\"\n+\t\t\t\t   \" \\xf0\\x9f\\x98\\x82\\xcf\\x80\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t\t \"\\xf0\\x9f\\x98\\x82\\xcf\\x80\\xcf\\x80\\n\",\n+\t\t    pp_formatted_text (dc.printer));\n+    }\n+\n+  }\n+\n+  /* Example where the labels need extra lines.  */\n+  {\n+    text_range_label label0 (\"label 0\\xf0\\x9f\\x98\\x82\");\n+    text_range_label label1 (\"label 1\\xcf\\x80\");\n+    text_range_label label2 (\"label 2\\xcf\\x80\");\n+    gcc_rich_location richloc (foo, &label0);\n+    richloc.add_range (bar, SHOW_RANGE_WITHOUT_CARET, &label1);\n+    richloc.add_range (field, SHOW_RANGE_WITHOUT_CARET, &label2);\n+\n+    test_diagnostic_context dc;\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \" \\xf0\\x9f\\x98\\x82\"\n+\t\t     \"_foo = \\xcf\\x80\"\n+\t\t\t     \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t    \"_field\\xcf\\x80\"\n+\t\t\t\t\t   \";\\n\"\n+\t\t  \" ^~~~~~   ~~~~~ ~~~~~~~~~\\n\"\n+\t\t  \" |        |     |\\n\"\n+\t\t  \" |        |     label 2\\xcf\\x80\\n\"\n+\t\t  \" |        label 1\\xcf\\x80\\n\"\n+\t\t  \" label 0\\xf0\\x9f\\x98\\x82\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+\n+  /* Example of boundary conditions: label 0 and 1 have just enough clearance,\n+     but label 1 just touches label 2.  */\n+  {\n+    text_range_label label0 (\"aaaaa\\xf0\\x9f\\x98\\x82\\xcf\\x80\");\n+    text_range_label label1 (\"bb\\xf0\\x9f\\x98\\x82\\xf0\\x9f\\x98\\x82\");\n+    text_range_label label2 (\"c\");\n+    gcc_rich_location richloc (foo, &label0);\n+    richloc.add_range (bar, SHOW_RANGE_WITHOUT_CARET, &label1);\n+    richloc.add_range (field, SHOW_RANGE_WITHOUT_CARET, &label2);\n+\n+    test_diagnostic_context dc;\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \" \\xf0\\x9f\\x98\\x82\"\n+\t\t     \"_foo = \\xcf\\x80\"\n+\t\t\t     \"_bar.\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t    \"_field\\xcf\\x80\"\n+\t\t\t\t\t   \";\\n\"\n+\t\t  \" ^~~~~~   ~~~~~ ~~~~~~~~~\\n\"\n+\t\t  \" |        |     |\\n\"\n+\t\t  \" |        |     c\\n\"\n+\t\t  \" aaaaa\\xf0\\x9f\\x98\\x82\\xcf\\x80\"\n+\t\t\t   \" bb\\xf0\\x9f\\x98\\x82\\xf0\\x9f\\x98\\x82\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+}\n+\n+/* Run the various one-liner tests.  */\n+\n+static void\n+test_diagnostic_show_locus_one_liner_utf8 (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.  */\n+  const char *content\n+    /* Display columns.\n+       0000000000000000000000011111111111111111111111111111112222222222222\n+       1111111122222222345678900000000123456666666677777777890123444444445  */\n+    = \"\\xf0\\x9f\\x98\\x82_foo = \\xcf\\x80_bar.\\xf0\\x9f\\x98\\x82_field\\xcf\\x80;\\n\";\n+    /* 0000000000000000000001111111111111111111222222222222222222222233333\n+       1111222233334444567890122223333456789999000011112222345678999900001\n+       Byte columns.  */\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", content);\n+  line_table_test ltt (case_);\n+\n+  linemap_add (line_table, LC_ENTER, false, tmp.get_filename (), 1);\n+\n+  location_t line_end = linemap_position_for_column (line_table, 31);\n+\n+  /* Don't attempt to run the tests if column data might be unavailable.  */\n+  if (line_end > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  ASSERT_STREQ (tmp.get_filename (), LOCATION_FILE (line_end));\n+  ASSERT_EQ (1, LOCATION_LINE (line_end));\n+  ASSERT_EQ (31, LOCATION_COLUMN (line_end));\n+\n+  char_span lspan = location_get_source_line (tmp.get_filename (), 1);\n+  ASSERT_EQ (25, cpp_display_width (lspan.get_buffer (), lspan.length ()));\n+  ASSERT_EQ (25, location_compute_display_column (expand_location (line_end)));\n+\n+  test_one_liner_simple_caret_utf8 ();\n+  test_one_liner_caret_and_range_utf8 ();\n+  test_one_liner_multiple_carets_and_ranges_utf8 ();\n+  test_one_liner_fixit_insert_before_utf8 ();\n+  test_one_liner_fixit_insert_after_utf8 ();\n+  test_one_liner_fixit_remove_utf8 ();\n+  test_one_liner_fixit_replace_utf8 ();\n+  test_one_liner_fixit_replace_non_equal_range_utf8 ();\n+  test_one_liner_fixit_replace_equal_secondary_range_utf8 ();\n+  test_one_liner_fixit_validation_adhoc_locations_utf8 ();\n+  test_one_liner_many_fixits_1_utf8 ();\n+  test_one_liner_many_fixits_2_utf8 ();\n+  test_one_liner_labels_utf8 ();\n+}\n+\n+/* Verify that gcc_rich_location::add_location_if_nearby works.  */\n+\n+static void\n+test_add_location_if_nearby (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.\n+     ...000000000111111111122222222223333333333.\n+     ...123456789012345678901234567890123456789.  */\n+  const char *content\n+    = (\"struct same_line { double x; double y; ;\\n\" /* line 1.  */\n+       \"struct different_line\\n\"                    /* line 2.  */\n+       \"{\\n\"                                        /* line 3.  */\n+       \"  double x;\\n\"                              /* line 4.  */\n+       \"  double y;\\n\"                              /* line 5.  */\n+       \";\\n\");                                      /* line 6.  */\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", content);\n+  line_table_test ltt (case_);\n+\n+  const line_map_ordinary *ord_map\n+    = linemap_check_ordinary (linemap_add (line_table, LC_ENTER, false,\n+\t\t\t\t\t   tmp.get_filename (), 0));\n+\n+  linemap_line_start (line_table, 1, 100);\n+\n+  const location_t final_line_end\n+    = linemap_position_for_line_and_column (line_table, ord_map, 6, 7);\n+\n+  /* Don't attempt to run the tests if column data might be unavailable.  */\n+  if (final_line_end > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  /* Test of add_location_if_nearby on the same line as the\n+     primary location.  */\n+  {\n+    const location_t missing_close_brace_1_39\n+      = linemap_position_for_line_and_column (line_table, ord_map, 1, 39);\n+    const location_t matching_open_brace_1_18\n+      = linemap_position_for_line_and_column (line_table, ord_map, 1, 18);\n+    gcc_rich_location richloc (missing_close_brace_1_39);\n+    bool added = richloc.add_location_if_nearby (matching_open_brace_1_18);\n+    ASSERT_TRUE (added);\n+    ASSERT_EQ (2, richloc.get_num_locations ());\n+    test_diagnostic_context dc;\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \" struct same_line { double x; double y; ;\\n\"\n+\t\t  \"                  ~                    ^\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+\n+  /* Test of add_location_if_nearby on a different line to the\n+     primary location.  */\n+  {\n+    const location_t missing_close_brace_6_1\n+      = linemap_position_for_line_and_column (line_table, ord_map, 6, 1);\n+    const location_t matching_open_brace_3_1\n+      = linemap_position_for_line_and_column (line_table, ord_map, 3, 1);\n+    gcc_rich_location richloc (missing_close_brace_6_1);\n+    bool added = richloc.add_location_if_nearby (matching_open_brace_3_1);\n+    ASSERT_FALSE (added);\n+    ASSERT_EQ (1, richloc.get_num_locations ());\n+  }\n+}\n+\n+/* Verify that we print fixits even if they only affect lines\n+   outside those covered by the ranges in the rich_location.  */\n+\n+static void\n+test_diagnostic_show_locus_fixit_lines (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.\n      ...000000000111111111122222222223333333333.\n      ...123456789012345678901234567890123456789.  */\n   const char *content\n@@ -3340,13 +4304,19 @@ test_overlapped_fixit_printing (const line_table_case &case_)\n     /* Unit-test the line_corrections machinery.  */\n     ASSERT_EQ (3, richloc.get_num_fixit_hints ());\n     const fixit_hint *hint_0 = richloc.get_fixit_hint (0);\n-    ASSERT_EQ (column_range (12, 12), get_affected_columns (hint_0));\n+    ASSERT_EQ (column_range (12, 12), get_affected_range (hint_0, CU_BYTES));\n+    ASSERT_EQ (column_range (12, 12),\n+\t\t\t   get_affected_range (hint_0, CU_DISPLAY_COLS));\n     ASSERT_EQ (column_range (12, 22), get_printed_columns (hint_0));\n     const fixit_hint *hint_1 = richloc.get_fixit_hint (1);\n-    ASSERT_EQ (column_range (18, 18), get_affected_columns (hint_1));\n+    ASSERT_EQ (column_range (18, 18), get_affected_range (hint_1, CU_BYTES));\n+    ASSERT_EQ (column_range (18, 18),\n+\t\t\t   get_affected_range (hint_1, CU_DISPLAY_COLS));\n     ASSERT_EQ (column_range (18, 20), get_printed_columns (hint_1));\n     const fixit_hint *hint_2 = richloc.get_fixit_hint (2);\n-    ASSERT_EQ (column_range (29, 28), get_affected_columns (hint_2));\n+    ASSERT_EQ (column_range (29, 28), get_affected_range (hint_2, CU_BYTES));\n+    ASSERT_EQ (column_range (29, 28),\n+\t\t\t   get_affected_range (hint_2, CU_DISPLAY_COLS));\n     ASSERT_EQ (column_range (29, 29), get_printed_columns (hint_2));\n \n     /* Add each hint in turn to a line_corrections instance,\n@@ -3357,6 +4327,7 @@ test_overlapped_fixit_printing (const line_table_case &case_)\n     /* The first replace hint by itself.  */\n     lc.add_hint (hint_0);\n     ASSERT_EQ (1, lc.m_corrections.length ());\n+    ASSERT_EQ (column_range (12, 12), lc.m_corrections[0]->m_affected_bytes);\n     ASSERT_EQ (column_range (12, 12), lc.m_corrections[0]->m_affected_columns);\n     ASSERT_EQ (column_range (12, 22), lc.m_corrections[0]->m_printed_columns);\n     ASSERT_STREQ (\"const_cast<\", lc.m_corrections[0]->m_text);\n@@ -3366,6 +4337,7 @@ test_overlapped_fixit_printing (const line_table_case &case_)\n     lc.add_hint (hint_1);\n     ASSERT_EQ (1, lc.m_corrections.length ());\n     ASSERT_STREQ (\"const_cast<foo *> (\", lc.m_corrections[0]->m_text);\n+    ASSERT_EQ (column_range (12, 18), lc.m_corrections[0]->m_affected_bytes);\n     ASSERT_EQ (column_range (12, 18), lc.m_corrections[0]->m_affected_columns);\n     ASSERT_EQ (column_range (12, 30), lc.m_corrections[0]->m_printed_columns);\n \n@@ -3375,6 +4347,7 @@ test_overlapped_fixit_printing (const line_table_case &case_)\n     ASSERT_STREQ (\"const_cast<foo *> (ptr->field)\",\n \t\t  lc.m_corrections[0]->m_text);\n     ASSERT_EQ (1, lc.m_corrections.length ());\n+    ASSERT_EQ (column_range (12, 28), lc.m_corrections[0]->m_affected_bytes);\n     ASSERT_EQ (column_range (12, 28), lc.m_corrections[0]->m_affected_columns);\n     ASSERT_EQ (column_range (12, 41), lc.m_corrections[0]->m_printed_columns);\n   }\n@@ -3477,6 +4450,246 @@ test_overlapped_fixit_printing (const line_table_case &case_)\n   }\n }\n \n+/* Multibyte-aware version of preceding tests.  See comments above\n+   test_one_liner_simple_caret_utf8() too, we use the same two multibyte\n+   characters here.  */\n+\n+static void\n+test_overlapped_fixit_printing_utf8 (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.  */\n+\n+  const char *content\n+    /* Display columns.\n+       00000000000000000000000111111111111111111111111222222222222222223\n+       12344444444555555556789012344444444555555556789012345678999999990  */\n+    = \"  f\\xf0\\x9f\\x98\\x82 *f = (f\\xf0\\x9f\\x98\\x82 *)ptr->field\\xcf\\x80;\\n\";\n+    /* 00000000000000000000011111111111111111111112222222222333333333333\n+       12344445555666677778901234566667777888899990123456789012333344445\n+       Byte columns.  */\n+\n+  temp_source_file tmp (SELFTEST_LOCATION, \".C\", content);\n+  line_table_test ltt (case_);\n+\n+  const line_map_ordinary *ord_map\n+    = linemap_check_ordinary (linemap_add (line_table, LC_ENTER, false,\n+\t\t\t\t\t   tmp.get_filename (), 0));\n+\n+  linemap_line_start (line_table, 1, 100);\n+\n+  const location_t final_line_end\n+    = linemap_position_for_line_and_column (line_table, ord_map, 6, 50);\n+\n+  /* Don't attempt to run the tests if column data might be unavailable.  */\n+  if (final_line_end > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  /* A test for converting a C-style cast to a C++-style cast.  */\n+  const location_t open_paren\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 14);\n+  const location_t close_paren\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 22);\n+  const location_t expr_start\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 23);\n+  const location_t expr_finish\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 34);\n+  const location_t expr = make_location (expr_start, expr_start, expr_finish);\n+\n+  /* Various examples of fix-it hints that aren't themselves consolidated,\n+     but for which the *printing* may need consolidation.  */\n+\n+  /* Example where 3 fix-it hints are printed as one.  */\n+  {\n+    test_diagnostic_context dc;\n+    rich_location richloc (line_table, expr);\n+    richloc.add_fixit_replace (open_paren, \"const_cast<\");\n+    richloc.add_fixit_replace (close_paren, \"> (\");\n+    richloc.add_fixit_insert_after (\")\");\n+\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \"   f\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\" *f = (f\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \" *)ptr->field\\xcf\\x80\"\n+\t\t\t\t\t\t\";\\n\"\n+\t\t  \"                   ^~~~~~~~~~~\\n\"\n+\t\t  \"            ------------------\\n\"\n+\t\t  \"            const_cast<f\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t\t    \" *> (ptr->field\\xcf\\x80\"\n+\t\t\t\t\t\t\t    \")\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+\n+    /* Unit-test the line_corrections machinery.  */\n+    ASSERT_EQ (3, richloc.get_num_fixit_hints ());\n+    const fixit_hint *hint_0 = richloc.get_fixit_hint (0);\n+    ASSERT_EQ (column_range (14, 14), get_affected_range (hint_0, CU_BYTES));\n+    ASSERT_EQ (column_range (12, 12),\n+\t\t\t   get_affected_range (hint_0, CU_DISPLAY_COLS));\n+    ASSERT_EQ (column_range (12, 22), get_printed_columns (hint_0));\n+    const fixit_hint *hint_1 = richloc.get_fixit_hint (1);\n+    ASSERT_EQ (column_range (22, 22), get_affected_range (hint_1, CU_BYTES));\n+    ASSERT_EQ (column_range (18, 18),\n+\t\t\t   get_affected_range (hint_1, CU_DISPLAY_COLS));\n+    ASSERT_EQ (column_range (18, 20), get_printed_columns (hint_1));\n+    const fixit_hint *hint_2 = richloc.get_fixit_hint (2);\n+    ASSERT_EQ (column_range (35, 34), get_affected_range (hint_2, CU_BYTES));\n+    ASSERT_EQ (column_range (30, 29),\n+\t\t\t   get_affected_range (hint_2, CU_DISPLAY_COLS));\n+    ASSERT_EQ (column_range (30, 30), get_printed_columns (hint_2));\n+\n+    /* Add each hint in turn to a line_corrections instance,\n+       and verify that they are consolidated into one correction instance\n+       as expected.  */\n+    line_corrections lc (tmp.get_filename (), 1);\n+\n+    /* The first replace hint by itself.  */\n+    lc.add_hint (hint_0);\n+    ASSERT_EQ (1, lc.m_corrections.length ());\n+    ASSERT_EQ (column_range (14, 14), lc.m_corrections[0]->m_affected_bytes);\n+    ASSERT_EQ (column_range (12, 12), lc.m_corrections[0]->m_affected_columns);\n+    ASSERT_EQ (column_range (12, 22), lc.m_corrections[0]->m_printed_columns);\n+    ASSERT_STREQ (\"const_cast<\", lc.m_corrections[0]->m_text);\n+\n+    /* After the second replacement hint, they are printed together\n+       as a replacement (along with the text between them).  */\n+    lc.add_hint (hint_1);\n+    ASSERT_EQ (1, lc.m_corrections.length ());\n+    ASSERT_STREQ (\"const_cast<f\\xf0\\x9f\\x98\\x82 *> (\",\n+\t\t  lc.m_corrections[0]->m_text);\n+    ASSERT_EQ (column_range (14, 22), lc.m_corrections[0]->m_affected_bytes);\n+    ASSERT_EQ (column_range (12, 18), lc.m_corrections[0]->m_affected_columns);\n+    ASSERT_EQ (column_range (12, 30), lc.m_corrections[0]->m_printed_columns);\n+\n+    /* After the final insertion hint, they are all printed together\n+       as a replacement (along with the text between them).  */\n+    lc.add_hint (hint_2);\n+    ASSERT_STREQ (\"const_cast<f\\xf0\\x9f\\x98\\x82 *> (ptr->field\\xcf\\x80)\",\n+\t\t  lc.m_corrections[0]->m_text);\n+    ASSERT_EQ (1, lc.m_corrections.length ());\n+    ASSERT_EQ (column_range (14, 34), lc.m_corrections[0]->m_affected_bytes);\n+    ASSERT_EQ (column_range (12, 29), lc.m_corrections[0]->m_affected_columns);\n+    ASSERT_EQ (column_range (12, 42), lc.m_corrections[0]->m_printed_columns);\n+  }\n+\n+  /* Example where two are consolidated during printing.  */\n+  {\n+    test_diagnostic_context dc;\n+    rich_location richloc (line_table, expr);\n+    richloc.add_fixit_replace (open_paren, \"CAST (\");\n+    richloc.add_fixit_replace (close_paren, \") (\");\n+    richloc.add_fixit_insert_after (\")\");\n+\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \"   f\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\" *f = (f\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \" *)ptr->field\\xcf\\x80\"\n+\t\t\t\t\t\t\";\\n\"\n+\t\t  \"                   ^~~~~~~~~~~\\n\"\n+\t\t  \"            -\\n\"\n+\t\t  \"            CAST (-\\n\"\n+\t\t  \"                  ) (         )\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+\n+  /* Example where none are consolidated during printing.  */\n+  {\n+    test_diagnostic_context dc;\n+    rich_location richloc (line_table, expr);\n+    richloc.add_fixit_replace (open_paren, \"CST (\");\n+    richloc.add_fixit_replace (close_paren, \") (\");\n+    richloc.add_fixit_insert_after (\")\");\n+\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \"   f\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\" *f = (f\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \" *)ptr->field\\xcf\\x80\"\n+\t\t\t\t\t\t\";\\n\"\n+\t\t  \"                   ^~~~~~~~~~~\\n\"\n+\t\t  \"            -\\n\"\n+\t\t  \"            CST ( -\\n\"\n+\t\t  \"                  ) (         )\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+\n+  /* Example of deletion fix-it hints.  */\n+  {\n+    test_diagnostic_context dc;\n+    rich_location richloc (line_table, expr);\n+    richloc.add_fixit_insert_before (open_paren, \"(bar\\xf0\\x9f\\x98\\x82 *)\");\n+    source_range victim = {open_paren, close_paren};\n+    richloc.add_fixit_remove (victim);\n+\n+    /* This case is actually handled by fixit-consolidation,\n+       rather than by line_corrections.  */\n+    ASSERT_EQ (1, richloc.get_num_fixit_hints ());\n+\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \"   f\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\" *f = (f\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \" *)ptr->field\\xcf\\x80\"\n+\t\t\t\t\t\t\";\\n\"\n+\t\t  \"                   ^~~~~~~~~~~\\n\"\n+\t\t  \"            -------\\n\"\n+\t\t  \"            (bar\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t    \" *)\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+\n+  /* Example of deletion fix-it hints that would overlap.  */\n+  {\n+    test_diagnostic_context dc;\n+    rich_location richloc (line_table, expr);\n+    richloc.add_fixit_insert_before (open_paren, \"(long\\xf0\\x9f\\x98\\x82 *)\");\n+    source_range victim = {expr_start, expr_finish};\n+    richloc.add_fixit_remove (victim);\n+\n+    /* These fixits are not consolidated.  */\n+    ASSERT_EQ (2, richloc.get_num_fixit_hints ());\n+\n+    /* But the corrections are.  */\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \"   f\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\" *f = (f\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \" *)ptr->field\\xcf\\x80\"\n+\t\t\t\t\t\t\";\\n\"\n+\t\t  \"                   ^~~~~~~~~~~\\n\"\n+\t\t  \"            ------------------\\n\"\n+\t\t  \"            (long\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t     \" *)(f\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t\t    \" *)\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+\n+  /* Example of insertion fix-it hints that would overlap.  */\n+  {\n+    test_diagnostic_context dc;\n+    rich_location richloc (line_table, expr);\n+    richloc.add_fixit_insert_before\n+      (open_paren, \"L\\xf0\\x9f\\x98\\x82NGER THAN THE CAST\");\n+    richloc.add_fixit_insert_after (close_paren, \"TEST\");\n+\n+    /* The first insertion is long enough that if printed naively,\n+       it would overlap with the second.\n+       Verify that they are printed as a single replacement.  */\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \"   f\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\" *f = (f\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t  \" *)ptr->field\\xcf\\x80\"\n+\t\t\t\t\t\t\";\\n\"\n+\t\t  \"                   ^~~~~~~~~~~\\n\"\n+\t\t  \"            -------\\n\"\n+\t\t  \"            L\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t \"NGER THAN THE CAST(f\\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t\t\t       \" *)TEST\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+}\n+\n /* Verify that the line_corrections machinery correctly prints\n    overlapping fixit-hints that have been added in the wrong\n    order.\n@@ -3526,10 +4739,10 @@ test_overlapped_fixit_printing_2 (const line_table_case &case_)\n     /* These fixits should be accepted; they can't be consolidated.  */\n     ASSERT_EQ (2, richloc.get_num_fixit_hints ());\n     const fixit_hint *hint_0 = richloc.get_fixit_hint (0);\n-    ASSERT_EQ (column_range (23, 22), get_affected_columns (hint_0));\n+    ASSERT_EQ (column_range (23, 22), get_affected_range (hint_0, CU_BYTES));\n     ASSERT_EQ (column_range (23, 23), get_printed_columns (hint_0));\n     const fixit_hint *hint_1 = richloc.get_fixit_hint (1);\n-    ASSERT_EQ (column_range (21, 20), get_affected_columns (hint_1));\n+    ASSERT_EQ (column_range (21, 20), get_affected_range (hint_1, CU_BYTES));\n     ASSERT_EQ (column_range (21, 21), get_printed_columns (hint_1));\n \n     /* Verify that they're printed correctly.  */\n@@ -3851,15 +5064,19 @@ diagnostic_show_locus_c_tests ()\n   test_layout_range_for_single_line ();\n   test_layout_range_for_multiple_lines ();\n \n-  test_get_line_width_without_trailing_whitespace ();\n+  for_each_line_table_case (test_layout_x_offset_display_utf8);\n+\n+  test_get_line_bytes_without_trailing_whitespace ();\n \n   test_diagnostic_show_locus_unknown_location ();\n \n   for_each_line_table_case (test_diagnostic_show_locus_one_liner);\n+  for_each_line_table_case (test_diagnostic_show_locus_one_liner_utf8);\n   for_each_line_table_case (test_add_location_if_nearby);\n   for_each_line_table_case (test_diagnostic_show_locus_fixit_lines);\n   for_each_line_table_case (test_fixit_consolidation);\n   for_each_line_table_case (test_overlapped_fixit_printing);\n+  for_each_line_table_case (test_overlapped_fixit_printing_utf8);\n   for_each_line_table_case (test_overlapped_fixit_printing_2);\n   for_each_line_table_case (test_fixit_insert_containing_newline);\n   for_each_line_table_case (test_fixit_insert_containing_newline_2);"}, {"sha": "1dc6b339afe9187a17b809742f1c714a28f0c5c9", "filename": "gcc/input.c", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -908,6 +908,22 @@ make_location (location_t caret, source_range src_range)\n   return COMBINE_LOCATION_DATA (line_table, pure_loc, src_range, NULL);\n }\n \n+/* An expanded_location stores the column in byte units.  This function\n+   converts that column to display units.  That requires reading the associated\n+   source line in order to calculate the display width.  If that cannot be done\n+   for any reason, then returns the byte column as a fallback.  */\n+int\n+location_compute_display_column (expanded_location exploc)\n+{\n+  if (!(exploc.file && *exploc.file && exploc.line && exploc.column))\n+    return exploc.column;\n+  char_span line = location_get_source_line (exploc.file, exploc.line);\n+  /* If line is NULL, this function returns exploc.column which is the\n+     desired fallback.  */\n+  return cpp_byte_column_to_display_column (line.get_buffer (), line.length (),\n+\t\t\t\t\t    exploc.column);\n+}\n+\n /* Dump statistics to stderr about the memory usage of the line_table\n    set of line maps.  This also displays some statistics about macro\n    expansion.  */\n@@ -3590,6 +3606,93 @@ test_line_offset_overflow ()\n   ASSERT_NE (ordmap_a, ordmap_b);\n }\n \n+void test_cpp_utf8 ()\n+{\n+  /* Verify that wcwidth of invalid UTF-8 or control bytes is 1.  */\n+  {\n+    int w_bad = cpp_display_width (\"\\xf0!\\x9f!\\x98!\\x82!\", 8);\n+    ASSERT_EQ (8, w_bad);\n+    int w_ctrl = cpp_display_width (\"\\r\\t\\n\\v\\0\\1\", 6);\n+    ASSERT_EQ (6, w_ctrl);\n+  }\n+\n+  /* Verify that wcwidth of valid UTF-8 is as expected.  */\n+  {\n+    const int w_pi = cpp_display_width (\"\\xcf\\x80\", 2);\n+    ASSERT_EQ (1, w_pi);\n+    const int w_emoji = cpp_display_width (\"\\xf0\\x9f\\x98\\x82\", 4);\n+    ASSERT_EQ (2, w_emoji);\n+    const int w_umlaut_precomposed = cpp_display_width (\"\\xc3\\xbf\", 2);\n+    ASSERT_EQ (1, w_umlaut_precomposed);\n+    const int w_umlaut_combining = cpp_display_width (\"y\\xcc\\x88\", 3);\n+    ASSERT_EQ (1, w_umlaut_combining);\n+    const int w_han = cpp_display_width (\"\\xe4\\xb8\\xba\", 3);\n+    ASSERT_EQ (2, w_han);\n+    const int w_ascii = cpp_display_width (\"GCC\", 3);\n+    ASSERT_EQ (3, w_ascii);\n+    const int w_mixed = cpp_display_width (\"\\xcf\\x80 = 3.14 \\xf0\\x9f\\x98\\x82\"\n+\t\t\t\t\t   \"\\x9f! \\xe4\\xb8\\xba y\\xcc\\x88\", 24);\n+    ASSERT_EQ (18, w_mixed);\n+  }\n+\n+  /* Verify that cpp_byte_column_to_display_column can go past the end,\n+     and similar edge cases.  */\n+  {\n+    const char *str\n+      /* Display columns.\n+         111111112345  */\n+      = \"\\xcf\\x80 abc\";\n+      /* 111122223456\n+\t Byte columns.  */\n+\n+    ASSERT_EQ (5, cpp_display_width (str, 6));\n+    ASSERT_EQ (105, cpp_byte_column_to_display_column (str, 6, 106));\n+    ASSERT_EQ (10000, cpp_byte_column_to_display_column (NULL, 0, 10000));\n+    ASSERT_EQ (0, cpp_byte_column_to_display_column (NULL, 10000, 0));\n+  }\n+\n+  /* Verify that cpp_display_column_to_byte_column can go past the end,\n+     and similar edge cases, and check invertibility.  */\n+  {\n+    const char *str\n+      /* Display columns.\n+\t 000000000000000000000000000000000000011\n+\t 111111112222222234444444455555555678901  */\n+      = \"\\xf0\\x9f\\x98\\x82 \\xf0\\x9f\\x98\\x82 hello\";\n+      /* 000000000000000000000000000000000111111\n+\t 111122223333444456666777788889999012345\n+\t Byte columns.  */\n+    ASSERT_EQ (4, cpp_display_column_to_byte_column (str, 15, 2));\n+    ASSERT_EQ (15, cpp_display_column_to_byte_column (str, 15, 11));\n+    ASSERT_EQ (115, cpp_display_column_to_byte_column (str, 15, 111));\n+    ASSERT_EQ (10000, cpp_display_column_to_byte_column (NULL, 0, 10000));\n+    ASSERT_EQ (0, cpp_display_column_to_byte_column (NULL, 10000, 0));\n+\n+    /* Verify that we do not interrupt a UTF-8 sequence.  */\n+    ASSERT_EQ (4, cpp_display_column_to_byte_column (str, 15, 1));\n+\n+    for (int byte_col = 1; byte_col <= 15; ++byte_col)\n+      {\n+\tconst int disp_col = cpp_byte_column_to_display_column (str, 15,\n+\t\t\t\t\t\t\t\tbyte_col);\n+\tconst int byte_col2 = cpp_display_column_to_byte_column (str, 15,\n+\t\t\t\t\t\t\t\t disp_col);\n+\n+\t/* If we ask for the display column in the middle of a UTF-8\n+\t   sequence, it will return the length of the partial sequence,\n+\t   matching the behavior of GCC before display column support.\n+\t   Otherwise check the round trip was successful.  */\n+\tif (byte_col < 4)\n+\t  ASSERT_EQ (byte_col, disp_col);\n+\telse if (byte_col >= 6 && byte_col < 9)\n+\t  ASSERT_EQ (3 + (byte_col - 5), disp_col);\n+\telse\n+\t  ASSERT_EQ (byte_col2, byte_col);\n+      }\n+  }\n+\n+}\n+\n /* Run all of the selftests within this file.  */\n \n void\n@@ -3631,6 +3734,8 @@ input_c_tests ()\n   test_reading_source_line ();\n \n   test_line_offset_overflow ();\n+\n+  test_cpp_utf8 ();\n }\n \n } // namespace selftest"}, {"sha": "35e02bd91d5e2e128cc6c2cadf821b643e80dba5", "filename": "gcc/input.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -38,6 +38,7 @@ STATIC_ASSERT (BUILTINS_LOCATION < RESERVED_LOCATION_COUNT);\n \n extern bool is_location_from_builtin_token (location_t);\n extern expanded_location expand_location (location_t);\n+extern int location_compute_display_column (expanded_location);\n \n /* A class capturing the bounds of a buffer, to allow for run-time\n    bounds-checking in a checked build.  */"}, {"sha": "a03407038c8dfc661b108ef05636008be04f5d70", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -1,3 +1,11 @@\n+2019-12-09  Lewis Hyatt  <lhyatt@gmail.com>\n+\n+\tPR preprocessor/49973\n+\t* gcc.dg/plugin/diagnostic_plugin_test_show_locus.c\n+\t(test_show_locus): Tweak so that expected output is the same as\n+\tbefore the diagnostic-show-locus.c changes.\n+\t* gcc.dg/cpp/pr66415-1.c: Likewise.\n+\n 2019-12-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/lto23.adb: New test."}, {"sha": "4a0ef551840d02ca41635085ad9f769d1ba929d5", "filename": "gcc/testsuite/gcc.dg/cpp/pr66415-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpr66415-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpr66415-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpr66415-1.c?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -1,7 +1,7 @@\n /* PR c/66415 */\n /* { dg-do compile } */\n /* { dg-options \"-Wformat -fdiagnostics-show-caret\" } */\n-/* { dg-set-compiler-env-var COLUMNS \"82\" } */\n+/* { dg-set-compiler-env-var COLUMNS \"83\" } */\n \n void\n fn1 (void)"}, {"sha": "153bdb2fd898e469cab27d7850d3b8793730ef84", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic_plugin_test_show_locus.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -174,7 +174,7 @@ test_show_locus (function *fun)\n \n   /* Hardcode the \"terminal width\", to verify the behavior of\n      very wide lines.  */\n-  global_dc->caret_max_width = 70;\n+  global_dc->caret_max_width = 71;\n \n   if (0 == strcmp (fnname, \"test_simple\"))\n     {"}, {"sha": "f4376e6cf80f8c85b88691b8bc4ff9f6c31b5e02", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -1,3 +1,18 @@\n+2019-12-09  Lewis Hyatt  <lhyatt@gmail.com>\n+\n+\tPR preprocessor/49973\n+\t* generated_cpp_wcwidth.h: New file generated by\n+\t../contrib/unicode/gen_wcwidth.py, supports new cpp_wcwidth function.\n+\t* charset.c (compute_next_display_width): New function to help\n+\timplement display columns.\n+\t(cpp_byte_column_to_display_column): Likewise.\n+\t(cpp_display_column_to_byte_column): Likewise.\n+\t(cpp_wcwidth): Likewise.\n+\t* include/cpplib.h (cpp_byte_column_to_display_column): Declare.\n+\t(cpp_display_column_to_byte_column): Declare.\n+\t(cpp_wcwidth): Declare.\n+\t(cpp_display_width): New function.\n+\n 2019-11-14  Joseph Myers  <joseph@codesourcery.com>\n \n \t* charset.c (narrow_str_to_charconst): Make CPP_UTF8CHAR constants"}, {"sha": "956d2dad5c86079bbd8644fb261dc167cfd64e11", "filename": "libcpp/charset.c", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/libcpp%2Fcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/libcpp%2Fcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fcharset.c?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -2265,3 +2265,106 @@ cpp_string_location_reader::get_next ()\n     m_loc += m_offset_per_column;\n   return result;\n }\n+\n+/* Helper for cpp_byte_column_to_display_column and its inverse.  Given a\n+   pointer to a UTF-8-encoded character, compute its display width.  *INBUFP\n+   points on entry to the start of the UTF-8 encoding of the character, and\n+   is updated to point just after the last byte of the encoding.  *INBYTESLEFTP\n+   contains on entry the remaining size of the buffer into which *INBUFP\n+   points, and this is also updated accordingly.  If *INBUFP does not\n+   point to a valid UTF-8-encoded sequence, then it will be treated as a single\n+   byte with display width 1.  */\n+\n+static inline int\n+compute_next_display_width (const uchar **inbufp, size_t *inbytesleftp)\n+{\n+  cppchar_t c;\n+  if (one_utf8_to_cppchar (inbufp, inbytesleftp, &c) != 0)\n+    {\n+      /* Input is not convertible to UTF-8.  This could be fine, e.g. in a\n+\t string literal, so don't complain.  Just treat it as if it has a width\n+\t of one.  */\n+      ++*inbufp;\n+      --*inbytesleftp;\n+      return 1;\n+    }\n+\n+  /*  one_utf8_to_cppchar() has updated inbufp and inbytesleftp for us.  */\n+  return cpp_wcwidth (c);\n+}\n+\n+/*  For the string of length DATA_LENGTH bytes that begins at DATA, compute\n+    how many display columns are occupied by the first COLUMN bytes.  COLUMN\n+    may exceed DATA_LENGTH, in which case the phantom bytes at the end are\n+    treated as if they have display width 1.  */\n+\n+int\n+cpp_byte_column_to_display_column (const char *data, int data_length,\n+\t\t\t\t   int column)\n+{\n+  int display_col = 0;\n+  const uchar *udata = (const uchar *) data;\n+  const int offset = MAX (0, column - data_length);\n+  size_t inbytesleft = column - offset;\n+  while (inbytesleft)\n+    display_col += compute_next_display_width (&udata, &inbytesleft);\n+  return display_col + offset;\n+}\n+\n+/*  For the string of length DATA_LENGTH bytes that begins at DATA, compute\n+    the least number of bytes that will result in at least DISPLAY_COL display\n+    columns.  The return value may exceed DATA_LENGTH if the entire string does\n+    not occupy enough display columns.  */\n+\n+int\n+cpp_display_column_to_byte_column (const char *data, int data_length,\n+\t\t\t\t   int display_col)\n+{\n+  int column = 0;\n+  const uchar *udata = (const uchar *) data;\n+  size_t inbytesleft = data_length;\n+  while (column < display_col && inbytesleft)\n+      column += compute_next_display_width (&udata, &inbytesleft);\n+  return data_length - inbytesleft + MAX (0, display_col - column);\n+}\n+\n+/* Our own version of wcwidth().  We don't use the actual wcwidth() in glibc,\n+   because that will inspect the user's locale, and in particular in an ASCII\n+   locale, it will not return anything useful for extended characters.  But GCC\n+   in other respects (see e.g. _cpp_default_encoding()) behaves as if\n+   everything is UTF-8.  We also make some tweaks that are useful for the way\n+   GCC needs to use this data, e.g. tabs and other control characters should be\n+   treated as having width 1.  The lookup tables are generated from\n+   contrib/unicode/gen_wcwidth.py and were made by simply calling glibc\n+   wcwidth() on all codepoints, then applying the small tweaks.  These tables\n+   are not highly optimized, but for the present purpose of outputting\n+   diagnostics, they are sufficient.  */\n+\n+#include \"generated_cpp_wcwidth.h\"\n+int cpp_wcwidth (cppchar_t c)\n+{\n+  if (__builtin_expect (c <= wcwidth_range_ends[0], true))\n+    return wcwidth_widths[0];\n+\n+  /* Binary search the tables.  */\n+  int begin = 1;\n+  static const int end\n+      = sizeof wcwidth_range_ends / sizeof (*wcwidth_range_ends);\n+  int len = end - begin;\n+  do\n+    {\n+      int half = len/2;\n+      int middle = begin + half;\n+      if (c > wcwidth_range_ends[middle])\n+\t{\n+\t  begin = middle + 1;\n+\t  len -= half + 1;\n+\t}\n+      else\n+\tlen = half;\n+    } while (len);\n+\n+  if (__builtin_expect (begin != end, true))\n+    return wcwidth_widths[begin];\n+  return 1;\n+}"}, {"sha": "ec8b73d3d01adeecfb159fe7c7118c7fc87d613f", "filename": "libcpp/generated_cpp_wcwidth.h", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/libcpp%2Fgenerated_cpp_wcwidth.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/libcpp%2Fgenerated_cpp_wcwidth.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fgenerated_cpp_wcwidth.h?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -0,0 +1,156 @@\n+/*  Generated by contrib/unicode/gen_wcwidth.py, with the help of glibc's\n+    utf8_gen.py, using version 12.1.0 of the Unicode standard.  */\n+\n+static const cppchar_t wcwidth_range_ends[] = {\n+  0x2ff, 0x36f, 0x482, 0x489, 0x590, 0x5bd, 0x5be, 0x5bf,\n+  0x5c0, 0x5c2, 0x5c3, 0x5c5, 0x5c6, 0x5c7, 0x60f, 0x61a,\n+  0x61b, 0x61c, 0x64a, 0x65f, 0x66f, 0x670, 0x6d5, 0x6dc,\n+  0x6de, 0x6e4, 0x6e6, 0x6e8, 0x6e9, 0x6ed, 0x710, 0x711,\n+  0x72f, 0x74a, 0x7a5, 0x7b0, 0x7ea, 0x7f3, 0x7fc, 0x7fd,\n+  0x815, 0x819, 0x81a, 0x823, 0x824, 0x827, 0x828, 0x82d,\n+  0x858, 0x85b, 0x8d2, 0x8e1, 0x8e2, 0x902, 0x939, 0x93a,\n+  0x93b, 0x93c, 0x940, 0x948, 0x94c, 0x94d, 0x950, 0x957,\n+  0x961, 0x963, 0x980, 0x981, 0x9bb, 0x9bc, 0x9c0, 0x9c4,\n+  0x9cc, 0x9cd, 0x9e1, 0x9e3, 0x9fd, 0x9fe, 0xa00, 0xa02,\n+  0xa3b, 0xa3c, 0xa40, 0xa42, 0xa46, 0xa48, 0xa4a, 0xa4d,\n+  0xa50, 0xa51, 0xa6f, 0xa71, 0xa74, 0xa75, 0xa80, 0xa82,\n+  0xabb, 0xabc, 0xac0, 0xac5, 0xac6, 0xac8, 0xacc, 0xacd,\n+  0xae1, 0xae3, 0xaf9, 0xaff, 0xb00, 0xb01, 0xb3b, 0xb3c,\n+  0xb3e, 0xb3f, 0xb40, 0xb44, 0xb4c, 0xb4d, 0xb55, 0xb56,\n+  0xb61, 0xb63, 0xb81, 0xb82, 0xbbf, 0xbc0, 0xbcc, 0xbcd,\n+  0xbff, 0xc00, 0xc03, 0xc04, 0xc3d, 0xc40, 0xc45, 0xc48,\n+  0xc49, 0xc4d, 0xc54, 0xc56, 0xc61, 0xc63, 0xc80, 0xc81,\n+  0xcbb, 0xcbc, 0xcbe, 0xcbf, 0xcc5, 0xcc6, 0xccb, 0xccd,\n+  0xce1, 0xce3, 0xcff, 0xd01, 0xd3a, 0xd3c, 0xd40, 0xd44,\n+  0xd4c, 0xd4d, 0xd61, 0xd63, 0xdc9, 0xdca, 0xdd1, 0xdd4,\n+  0xdd5, 0xdd6, 0xe30, 0xe31, 0xe33, 0xe3a, 0xe46, 0xe4e,\n+  0xeb0, 0xeb1, 0xeb3, 0xebc, 0xec7, 0xecd, 0xf17, 0xf19,\n+  0xf34, 0xf35, 0xf36, 0xf37, 0xf38, 0xf39, 0xf70, 0xf7e,\n+  0xf7f, 0xf84, 0xf85, 0xf87, 0xf8c, 0xf97, 0xf98, 0xfbc,\n+  0xfc5, 0xfc6, 0x102c, 0x1030, 0x1031, 0x1037, 0x1038, 0x103a,\n+  0x103c, 0x103e, 0x1057, 0x1059, 0x105d, 0x1060, 0x1070, 0x1074,\n+  0x1081, 0x1082, 0x1084, 0x1086, 0x108c, 0x108d, 0x109c, 0x109d,\n+  0x10ff, 0x115f, 0x11ff, 0x135c, 0x135f, 0x1711, 0x1714, 0x1731,\n+  0x1734, 0x1751, 0x1753, 0x1771, 0x1773, 0x17b3, 0x17b5, 0x17b6,\n+  0x17bd, 0x17c5, 0x17c6, 0x17c8, 0x17d3, 0x17dc, 0x17dd, 0x180a,\n+  0x180e, 0x1884, 0x1886, 0x18a8, 0x18a9, 0x191f, 0x1922, 0x1926,\n+  0x1928, 0x1931, 0x1932, 0x1938, 0x193b, 0x1a16, 0x1a18, 0x1a1a,\n+  0x1a1b, 0x1a55, 0x1a56, 0x1a57, 0x1a5e, 0x1a5f, 0x1a60, 0x1a61,\n+  0x1a62, 0x1a64, 0x1a6c, 0x1a72, 0x1a7c, 0x1a7e, 0x1a7f, 0x1aaf,\n+  0x1abe, 0x1aff, 0x1b03, 0x1b33, 0x1b34, 0x1b35, 0x1b3a, 0x1b3b,\n+  0x1b3c, 0x1b41, 0x1b42, 0x1b6a, 0x1b73, 0x1b7f, 0x1b81, 0x1ba1,\n+  0x1ba5, 0x1ba7, 0x1ba9, 0x1baa, 0x1bad, 0x1be5, 0x1be6, 0x1be7,\n+  0x1be9, 0x1bec, 0x1bed, 0x1bee, 0x1bf1, 0x1c2b, 0x1c33, 0x1c35,\n+  0x1c37, 0x1ccf, 0x1cd2, 0x1cd3, 0x1ce0, 0x1ce1, 0x1ce8, 0x1cec,\n+  0x1ced, 0x1cf3, 0x1cf4, 0x1cf7, 0x1cf9, 0x1dbf, 0x1df9, 0x1dfa,\n+  0x1dff, 0x200a, 0x200f, 0x2029, 0x202e, 0x205f, 0x2064, 0x2065,\n+  0x206f, 0x20cf, 0x20f0, 0x2319, 0x231b, 0x2328, 0x232a, 0x23e8,\n+  0x23ec, 0x23ef, 0x23f0, 0x23f2, 0x23f3, 0x25fc, 0x25fe, 0x2613,\n+  0x2615, 0x2647, 0x2653, 0x267e, 0x267f, 0x2692, 0x2693, 0x26a0,\n+  0x26a1, 0x26a9, 0x26ab, 0x26bc, 0x26be, 0x26c3, 0x26c5, 0x26cd,\n+  0x26ce, 0x26d3, 0x26d4, 0x26e9, 0x26ea, 0x26f1, 0x26f3, 0x26f4,\n+  0x26f5, 0x26f9, 0x26fa, 0x26fc, 0x26fd, 0x2704, 0x2705, 0x2709,\n+  0x270b, 0x2727, 0x2728, 0x274b, 0x274c, 0x274d, 0x274e, 0x2752,\n+  0x2755, 0x2756, 0x2757, 0x2794, 0x2797, 0x27af, 0x27b0, 0x27be,\n+  0x27bf, 0x2b1a, 0x2b1c, 0x2b4f, 0x2b50, 0x2b54, 0x2b55, 0x2cee,\n+  0x2cf1, 0x2d7e, 0x2d7f, 0x2ddf, 0x2dff, 0x2e7f, 0x2e99, 0x2e9a,\n+  0x2ef3, 0x2eff, 0x2fd5, 0x2fef, 0x2ffb, 0x2fff, 0x3029, 0x302d,\n+  0x303e, 0x3040, 0x3096, 0x3098, 0x309a, 0x30ff, 0x3104, 0x312f,\n+  0x3130, 0x318e, 0x318f, 0x31ba, 0x31bf, 0x31e3, 0x31ef, 0x321e,\n+  0x321f, 0x4db5, 0x4dbf, 0x9fef, 0x9fff, 0xa48c, 0xa48f, 0xa4c6,\n+  0xa66e, 0xa672, 0xa673, 0xa67d, 0xa69d, 0xa69f, 0xa6ef, 0xa6f1,\n+  0xa801, 0xa802, 0xa805, 0xa806, 0xa80a, 0xa80b, 0xa824, 0xa826,\n+  0xa8c3, 0xa8c5, 0xa8df, 0xa8f1, 0xa8fe, 0xa8ff, 0xa925, 0xa92d,\n+  0xa946, 0xa951, 0xa95f, 0xa97c, 0xa97f, 0xa982, 0xa9b2, 0xa9b3,\n+  0xa9b5, 0xa9b9, 0xa9bb, 0xa9bd, 0xa9e4, 0xa9e5, 0xaa28, 0xaa2e,\n+  0xaa30, 0xaa32, 0xaa34, 0xaa36, 0xaa42, 0xaa43, 0xaa4b, 0xaa4c,\n+  0xaa7b, 0xaa7c, 0xaaaf, 0xaab0, 0xaab1, 0xaab4, 0xaab6, 0xaab8,\n+  0xaabd, 0xaabf, 0xaac0, 0xaac1, 0xaaeb, 0xaaed, 0xaaf5, 0xaaf6,\n+  0xabe4, 0xabe5, 0xabe7, 0xabe8, 0xabec, 0xabed, 0xabff, 0xd7a3,\n+  0xf8ff, 0xfa6d, 0xfa6f, 0xfad9, 0xfb1d, 0xfb1e, 0xfdff, 0xfe0f,\n+  0xfe19, 0xfe1f, 0xfe2f, 0xfe52, 0xfe53, 0xfe66, 0xfe67, 0xfe6b,\n+  0xfefe, 0xfeff, 0xff00, 0xff60, 0xffdf, 0xffe6, 0xfff8, 0xfffb,\n+  0x101fc, 0x101fd, 0x102df, 0x102e0, 0x10375, 0x1037a, 0x10a00, 0x10a03,\n+  0x10a04, 0x10a06, 0x10a0b, 0x10a0f, 0x10a37, 0x10a3a, 0x10a3e, 0x10a3f,\n+  0x10ae4, 0x10ae6, 0x10d23, 0x10d27, 0x10f45, 0x10f50, 0x11000, 0x11001,\n+  0x11037, 0x11046, 0x1107e, 0x11081, 0x110b2, 0x110b6, 0x110b8, 0x110ba,\n+  0x110ff, 0x11102, 0x11126, 0x1112b, 0x1112c, 0x11134, 0x11172, 0x11173,\n+  0x1117f, 0x11181, 0x111b5, 0x111be, 0x111c8, 0x111cc, 0x1122e, 0x11231,\n+  0x11233, 0x11234, 0x11235, 0x11237, 0x1123d, 0x1123e, 0x112de, 0x112df,\n+  0x112e2, 0x112ea, 0x112ff, 0x11301, 0x1133a, 0x1133c, 0x1133f, 0x11340,\n+  0x11365, 0x1136c, 0x1136f, 0x11374, 0x11437, 0x1143f, 0x11441, 0x11444,\n+  0x11445, 0x11446, 0x1145d, 0x1145e, 0x114b2, 0x114b8, 0x114b9, 0x114ba,\n+  0x114be, 0x114c0, 0x114c1, 0x114c3, 0x115b1, 0x115b5, 0x115bb, 0x115bd,\n+  0x115be, 0x115c0, 0x115db, 0x115dd, 0x11632, 0x1163a, 0x1163c, 0x1163d,\n+  0x1163e, 0x11640, 0x116aa, 0x116ab, 0x116ac, 0x116ad, 0x116af, 0x116b5,\n+  0x116b6, 0x116b7, 0x1171c, 0x1171f, 0x11721, 0x11725, 0x11726, 0x1172b,\n+  0x1182e, 0x11837, 0x11838, 0x1183a, 0x119d3, 0x119d7, 0x119d9, 0x119db,\n+  0x119df, 0x119e0, 0x11a00, 0x11a0a, 0x11a32, 0x11a38, 0x11a3a, 0x11a3e,\n+  0x11a46, 0x11a47, 0x11a50, 0x11a56, 0x11a58, 0x11a5b, 0x11a89, 0x11a96,\n+  0x11a97, 0x11a99, 0x11c2f, 0x11c36, 0x11c37, 0x11c3d, 0x11c3e, 0x11c3f,\n+  0x11c91, 0x11ca7, 0x11ca9, 0x11cb0, 0x11cb1, 0x11cb3, 0x11cb4, 0x11cb6,\n+  0x11d30, 0x11d36, 0x11d39, 0x11d3a, 0x11d3b, 0x11d3d, 0x11d3e, 0x11d45,\n+  0x11d46, 0x11d47, 0x11d8f, 0x11d91, 0x11d94, 0x11d95, 0x11d96, 0x11d97,\n+  0x11ef2, 0x11ef4, 0x1342f, 0x13438, 0x16aef, 0x16af4, 0x16b2f, 0x16b36,\n+  0x16f4e, 0x16f4f, 0x16f8e, 0x16f92, 0x16fdf, 0x16fe3, 0x16fff, 0x187f7,\n+  0x187ff, 0x18af2, 0x1afff, 0x1b11e, 0x1b14f, 0x1b152, 0x1b163, 0x1b167,\n+  0x1b16f, 0x1b2fb, 0x1bc9c, 0x1bc9e, 0x1bc9f, 0x1bca3, 0x1d166, 0x1d169,\n+  0x1d172, 0x1d182, 0x1d184, 0x1d18b, 0x1d1a9, 0x1d1ad, 0x1d241, 0x1d244,\n+  0x1d9ff, 0x1da36, 0x1da3a, 0x1da6c, 0x1da74, 0x1da75, 0x1da83, 0x1da84,\n+  0x1da9a, 0x1da9f, 0x1daa0, 0x1daaf, 0x1dfff, 0x1e006, 0x1e007, 0x1e018,\n+  0x1e01a, 0x1e021, 0x1e022, 0x1e024, 0x1e025, 0x1e02a, 0x1e12f, 0x1e136,\n+  0x1e2eb, 0x1e2ef, 0x1e8cf, 0x1e8d6, 0x1e943, 0x1e94a, 0x1f003, 0x1f004,\n+  0x1f0ce, 0x1f0cf, 0x1f18d, 0x1f18e, 0x1f190, 0x1f19a, 0x1f1ff, 0x1f202,\n+  0x1f20f, 0x1f23b, 0x1f23f, 0x1f248, 0x1f24f, 0x1f251, 0x1f25f, 0x1f265,\n+  0x1f2ff, 0x1f320, 0x1f32c, 0x1f335, 0x1f336, 0x1f37c, 0x1f37d, 0x1f393,\n+  0x1f39f, 0x1f3ca, 0x1f3ce, 0x1f3d3, 0x1f3df, 0x1f3f0, 0x1f3f3, 0x1f3f4,\n+  0x1f3f7, 0x1f43e, 0x1f43f, 0x1f440, 0x1f441, 0x1f4fc, 0x1f4fe, 0x1f53d,\n+  0x1f54a, 0x1f54e, 0x1f54f, 0x1f567, 0x1f579, 0x1f57a, 0x1f594, 0x1f596,\n+  0x1f5a3, 0x1f5a4, 0x1f5fa, 0x1f64f, 0x1f67f, 0x1f6c5, 0x1f6cb, 0x1f6cc,\n+  0x1f6cf, 0x1f6d2, 0x1f6d4, 0x1f6d5, 0x1f6ea, 0x1f6ec, 0x1f6f3, 0x1f6fa,\n+  0x1f7df, 0x1f7eb, 0x1f90c, 0x1f971, 0x1f972, 0x1f976, 0x1f979, 0x1f9a2,\n+  0x1f9a4, 0x1f9aa, 0x1f9ad, 0x1f9ca, 0x1f9cc, 0x1f9ff, 0x1fa6f, 0x1fa73,\n+  0x1fa77, 0x1fa7a, 0x1fa7f, 0x1fa82, 0x1fa8f, 0x1fa95, 0x1ffff, 0x2a6d6,\n+  0x2a6ff, 0x2b734, 0x2b73f, 0x2b81d, 0x2b81f, 0x2cea1, 0x2ceaf, 0x2ebe0,\n+  0x2f7ff, 0x2fa1d, 0xe0000, 0xe0001, 0xe001f, 0xe007f, 0xe00ff, 0xe01ef,\n+};\n+\n+static const unsigned char wcwidth_widths[] = {\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n+  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n+  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n+  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n+  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n+  0, 1, 0, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,\n+  2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,\n+  2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,\n+  0, 1, 0, 1, 0, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 1, 0, 2, 1, 2,\n+  1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 1, 2, 1, 2, 1, 0, 1, 0,\n+  2, 1, 0, 2, 1, 2, 1, 2, 1, 0, 1, 2, 1, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,\n+  1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,\n+  1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,\n+  1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,\n+  1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 0, 1, 0, 1, 0,\n+};"}, {"sha": "e199aecfa480c6b51b6d6a7f5277c6907436d48f", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9256409f21eab5df5076e46d220d6a0b995f79/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9256409f21eab5df5076e46d220d6a0b995f79/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=ee9256409f21eab5df5076e46d220d6a0b995f79", "patch": "@@ -1320,4 +1320,15 @@ extern bool cpp_userdef_char_p\n extern const char * cpp_get_userdef_suffix\n   (const cpp_token *);\n \n+/* In charset.c */\n+int cpp_byte_column_to_display_column (const char *data, int data_length,\n+\t\t\t\t       int column);\n+inline int cpp_display_width (const char *data, int data_length)\n+{\n+    return cpp_byte_column_to_display_column (data, data_length, data_length);\n+}\n+int cpp_display_column_to_byte_column (const char *data, int data_length,\n+\t\t\t\t       int display_col);\n+int cpp_wcwidth (cppchar_t c);\n+\n #endif /* ! LIBCPP_CPPLIB_H */"}]}