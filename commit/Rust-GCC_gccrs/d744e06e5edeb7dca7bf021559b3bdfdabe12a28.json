{"sha": "d744e06e5edeb7dca7bf021559b3bdfdabe12a28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc0NGUwNmU1ZWRlYjdkY2E3YmYwMjE1NTliM2JkZmRhYmUxMmEyOA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2003-04-01T13:40:11Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2003-04-01T13:40:11Z"}, "message": "simd-3.c: New.\n\n        * testsuite/gcc.c-torture/execute/simd-3.c: New.\n\n        * expr.c (expand_expr): Handle VECTOR_CST.\n        (const_vector_from_tree): New.\n\n        * varasm.c (output_constant): Handle VECTOR_CST.\n\n        * c-typeck.c (digest_init): Build a vector constant from a\n        VECTOR_TYPE.\n\n        * config/rs6000/rs6000.c: Remove prototype for\n        easy_vector_constant.\n        (easy_vector_constant): Add mode parameter.  Rewrite to handle\n        more easy constants.\n        (rs6000_emit_move): Pass mode to easy_vector_constant.\n        Call emit_easy_vector_insn for SPE V2SI vector constant moves.\n        (emit_easy_vector_insn): New.\n        (easy_vector_same): New.\n        (EASY_VECTOR_15): New macro.\n        (EASY_VECTOR_15_ADD_SELF): New macro.\n        (bdesc_2arg): Rename to xorv2si3.\n        (easy_vector_constant_add_self): New.\n        (input_operand): Allow vector constants.\n\n        * config/rs6000/rs6000.h (PREDICATE_CODES): Add\n        easy_vector_constant, easy_vector_constant_add_self.\n        (EXTRA_CONSTRAINT): Add 'W'.\n\n        * config/rs6000/rs6000-protos.h: Add prototype for\n        easy_vector_constant, emit_easy_vector_insn.\n\n        * config/rs6000/altivec.md (xorv8hi3): New.\n        (xorv16qi3): New.\n        Remove all _const0 patterns.\n        (movv4si_internal): Rewrite to use code.  Add vector constant to\n        vector alternative.  Add splitter.\n        (movv8hi_internal): Same.\n        (movv16qi_internal): Same.\n        (movv4sf_internal): Same.\n        Change the unspecs for vspltis* to use constants.\n\n        * config/rs6000/spe.md (\"xorv4hi3\"): New.\n        (\"spe_evxor\"): Rename to xorv2si3.\n        (\"xorv1di3\"): New.\n        Remove all _const0 patterns.\n        (movv2si_internal): Rewrite to use code.  Add vector constant to\n        alternatives.  Add splitter.\n        (movv4hi_internal): Add vector constant to alternatives.\n        (movv1di_internal): Same.\n        (movv2sf_internal): Same.\n\nFrom-SVN: r65130", "tree": {"sha": "8129a959cc2632337ea9823f4d5298efac0ea6e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8129a959cc2632337ea9823f4d5298efac0ea6e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d744e06e5edeb7dca7bf021559b3bdfdabe12a28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d744e06e5edeb7dca7bf021559b3bdfdabe12a28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d744e06e5edeb7dca7bf021559b3bdfdabe12a28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "46e33d43a2f80c82284832820287e118c7e7c65c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46e33d43a2f80c82284832820287e118c7e7c65c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46e33d43a2f80c82284832820287e118c7e7c65c"}], "stats": {"total": 613, "additions": 453, "deletions": 160}, "files": [{"sha": "895acf4f97b06ef63bfe82127b1f3967b062b289", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d744e06e5edeb7dca7bf021559b3bdfdabe12a28", "patch": "@@ -1,3 +1,56 @@\n+2003-02-31  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * testsuite/gcc.c-torture/execute/simd-3.c: New.\n+\n+        * expr.c (expand_expr): Handle VECTOR_CST.\n+        (const_vector_from_tree): New.\n+\n+        * varasm.c (output_constant): Handle VECTOR_CST.\n+\n+        * c-typeck.c (digest_init): Build a vector constant from a\n+        VECTOR_TYPE.\n+\n+        * config/rs6000/rs6000.c: Remove prototype for\n+        easy_vector_constant.\n+        (easy_vector_constant): Add mode parameter.  Rewrite to handle\n+        more easy constants.\n+        (rs6000_emit_move): Pass mode to easy_vector_constant.\n+        Call emit_easy_vector_insn for SPE V2SI vector constant moves.\n+        (emit_easy_vector_insn): New.\n+        (easy_vector_same): New.\n+        (EASY_VECTOR_15): New macro.\n+        (EASY_VECTOR_15_ADD_SELF): New macro.\n+        (bdesc_2arg): Rename to xorv2si3.\n+        (easy_vector_constant_add_self): New.\n+        (input_operand): Allow vector constants.\n+\n+        * config/rs6000/rs6000.h (PREDICATE_CODES): Add\n+        easy_vector_constant, easy_vector_constant_add_self.\n+        (EXTRA_CONSTRAINT): Add 'W'.\n+\n+        * config/rs6000/rs6000-protos.h: Add prototype for\n+        easy_vector_constant, emit_easy_vector_insn.\n+\n+        * config/rs6000/altivec.md (xorv8hi3): New.\n+        (xorv16qi3): New.\n+        Remove all _const0 patterns.\n+        (movv4si_internal): Rewrite to use code.  Add vector constant to\n+        vector alternative.  Add splitter.\n+        (movv8hi_internal): Same.\n+        (movv16qi_internal): Same.\n+        (movv4sf_internal): Same.\n+        Change the unspecs for vspltis* to use constants.\n+\n+        * config/rs6000/spe.md (\"xorv4hi3\"): New.\n+        (\"spe_evxor\"): Rename to xorv2si3.\n+        (\"xorv1di3\"): New.\n+        Remove all _const0 patterns.\n+        (movv2si_internal): Rewrite to use code.  Add vector constant to\n+        alternatives.  Add splitter.\n+        (movv4hi_internal): Add vector constant to alternatives.\n+        (movv1di_internal): Same.\n+        (movv2sf_internal): Same.\n+\n 2003-03-31  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c/9936"}, {"sha": "ce37eea09f74ebeb1cedef66be4ed4e1f51a81b5", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=d744e06e5edeb7dca7bf021559b3bdfdabe12a28", "patch": "@@ -4759,6 +4759,14 @@ digest_init (type, init, require_constant)\n \t}\n     }\n \n+  /* Build a VECTOR_CST from a *constant* vector constructor.  If the\n+     vector constructor is not constant (e.g. {1,2,3,foo()}) then punt\n+     below and handle as a constructor.  */\n+  if (code == VECTOR_TYPE\n+      && comptypes (TREE_TYPE (inside_init), type)\n+      && TREE_CONSTANT (inside_init))\n+    return build_vector (type, TREE_OPERAND (inside_init, 1));\n+\n   /* Any type can be initialized\n      from an expression of the same type, optionally with braces.  */\n "}, {"sha": "1d35f8039d00e630a84d2c858df0ce1c5c3cd900", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 142, "deletions": 81, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=d744e06e5edeb7dca7bf021559b3bdfdabe12a28", "patch": "@@ -19,6 +19,12 @@\n ;; the Free Software Foundation, 59 Temple Place - Suite 330,\n ;; Boston, MA 02111-1307, USA.\n \n+(define_constants\n+  [(UNSPEC_VSPLTISW\t141)\n+   (UNSPEC_VSPLTISH\t140)\n+   (UNSPEC_VSPLTISB\t139)\n+   ])\n+\n ;; Generic LVX load instruction.\n (define_insn \"altivec_lvx_4si\"\n   [(set (match_operand:V4SI 0 \"altivec_register_operand\" \"=v\")\n@@ -85,18 +91,37 @@\n   \"{ rs6000_emit_move (operands[0], operands[1], V4SImode); DONE; }\")\n \n (define_insn \"*movv4si_internal\"\n-  [(set (match_operand:V4SI 0 \"nonimmediate_operand\" \"=m,v,v,o,r,r\")\n-\t(match_operand:V4SI 1 \"input_operand\" \"v,m,v,r,o,r\"))]\n-  \"TARGET_ALTIVEC\"\n-  \"@\n-   stvx %1,%y0\n-   lvx %0,%y1\n-   vor %0,%1,%1\n-   stw%U0 %1,%0\\;stw %L1,%L0\\;stw %Y1,%Y0\\;stw %Z1,%Z0\n-   lwz%U1 %0,%1\\;lwz %L0,%L1\\;lwz %Y0,%Y1\\;lwz %Z0,%Z1\n-   mr %0,%1\\;mr %L0,%L1\\;mr %Y0,%Y1\\;mr %Z0,%Z1\"\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*\")\n-   (set_attr \"length\" \"*,*,*,16,16,16\")])\n+  [(set (match_operand:V4SI 0 \"nonimmediate_operand\" \"=m,v,v,o,r,r,v\")\n+\t(match_operand:V4SI 1 \"input_operand\" \"v,m,v,r,o,r,W\"))]\n+  \"TARGET_ALTIVEC\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"stvx %1,%y0\\\";\n+    case 1: return \\\"lvx %0,%y1\\\";\n+    case 2: return \\\"vor %0,%1,%1\\\";\n+    case 3: return \\\"stw%U0 %1,%0\\;stw %L1,%L0\\;stw %Y1,%Y0\\;stw %Z1,%Z0\\\";\n+    case 4: return \\\"lwz%U1 %0,%1\\;lwz %L0,%L1\\;lwz %Y0,%Y1\\;lwz %Z0,%Z1\\\";\n+    case 5: return \\\"mr %0,%1\\;mr %L0,%L1\\;mr %Y0,%Y1\\;mr %Z0,%Z1\\\";\n+    case 6: return output_vec_const_move (operands);\n+    default: abort();\n+    }\n+}\"\n+  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*,*\")\n+   (set_attr \"length\" \"*,*,*,16,16,16,*\")])\n+\n+(define_split\n+  [(set (match_operand:V4SI 0 \"altivec_register_operand\" \"\")\n+\t(match_operand:V4SI 1 \"easy_vector_constant_add_self\" \"\"))]\n+  \"TARGET_ALTIVEC && reload_completed\"\n+  [(set (match_dup 0)\n+\t(unspec:V4SI [(match_dup 3)] UNSPEC_VSPLTISW))\n+   (set (match_dup 0)\n+\t(plus:V4SI (match_dup 0)\n+\t\t   (match_dup 0)))]\n+  \"\n+{ operands[3] = GEN_INT (INTVAL (CONST_VECTOR_ELT (operands[1], 0)) >> 1); }\")\n \n (define_expand \"movv8hi\"\n   [(set (match_operand:V8HI 0 \"nonimmediate_operand\" \"\")\n@@ -105,18 +130,37 @@\n   \"{ rs6000_emit_move (operands[0], operands[1], V8HImode); DONE; }\")\n \n (define_insn \"*movv8hi_internal1\"\n-  [(set (match_operand:V8HI 0 \"nonimmediate_operand\" \"=m,v,v,o,r,r\")\n-\t(match_operand:V8HI 1 \"input_operand\" \"v,m,v,r,o,r\"))]\n-  \"TARGET_ALTIVEC\"\n-  \"@\n-   stvx %1,%y0\n-   lvx %0,%y1\n-   vor %0,%1,%1\n-   stw%U0 %1,%0\\;stw %L1,%L0\\;stw %Y1,%Y0\\;stw %Z1,%Z0\n-   lwz%U1 %0,%1\\;lwz %L0,%L1\\;lwz %Y0,%Y1\\;lwz %Z0,%Z1\n-   mr %0,%1\\;mr %L0,%L1\\;mr %Y0,%Y1\\;mr %Z0,%Z1\"\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*\")\n-   (set_attr \"length\" \"*,*,*,16,16,16\")])\n+  [(set (match_operand:V8HI 0 \"nonimmediate_operand\" \"=m,v,v,o,r,r,v\")\n+\t(match_operand:V8HI 1 \"input_operand\" \"v,m,v,r,o,r,W\"))]\n+  \"TARGET_ALTIVEC\"\n+  \"*\n+{\n+   switch (which_alternative)\n+     {\n+     case 0: return \\\"stvx %1,%y0\\\";\n+     case 1: return \\\"lvx %0,%y1\\\";\n+     case 2: return \\\"vor %0,%1,%1\\\";\n+     case 3: return \\\"stw%U0 %1,%0\\;stw %L1,%L0\\;stw %Y1,%Y0\\;stw %Z1,%Z0\\\";\n+     case 4: return \\\"lwz%U1 %0,%1\\;lwz %L0,%L1\\;lwz %Y0,%Y1\\;lwz %Z0,%Z1\\\";\n+     case 5: return \\\"mr %0,%1\\;mr %L0,%L1\\;mr %Y0,%Y1\\;mr %Z0,%Z1\\\";\n+     case 6: return output_vec_const_move (operands);\n+     default: abort ();\n+     }\n+}\"\n+  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*,*\")\n+   (set_attr \"length\" \"*,*,*,16,16,16,*\")])\n+\n+(define_split\n+  [(set (match_operand:V8HI 0 \"altivec_register_operand\" \"\")\n+\t(match_operand:V8HI 1 \"easy_vector_constant_add_self\" \"\"))]\n+  \"TARGET_ALTIVEC && reload_completed\"\n+  [(set (match_dup 0)\n+\t(unspec:V8HI [(match_dup 3)] UNSPEC_VSPLTISH))\n+   (set (match_dup 0)\n+\t(plus:V8HI (match_dup 0)\n+\t\t   (match_dup 0)))]\n+  \"\n+{ operands[3] = GEN_INT (INTVAL (CONST_VECTOR_ELT (operands[1], 0)) >> 1); }\")\n \n (define_expand \"movv16qi\"\n   [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"\")\n@@ -125,18 +169,37 @@\n   \"{ rs6000_emit_move (operands[0], operands[1], V16QImode); DONE; }\")\n \n (define_insn \"*movv16qi_internal1\"\n-  [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"=m,v,v,o,r,r\")\n-\t(match_operand:V16QI 1 \"input_operand\" \"v,m,v,r,o,r\"))]\n-  \"TARGET_ALTIVEC\"\n-  \"@\n-   stvx %1,%y0\n-   lvx %0,%y1\n-   vor %0,%1,%1\n-   stw%U0 %1,%0\\;stw %L1,%L0\\;stw %Y1,%Y0\\;stw %Z1,%Z0\n-   lwz%U1 %0,%1\\;lwz %L0,%L1\\;lwz %Y0,%Y1\\;lwz %Z0,%Z1\n-   mr %0,%1\\;mr %L0,%L1\\;mr %Y0,%Y1\\;mr %Z0,%Z1\"\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*\")\n-   (set_attr \"length\" \"*,*,*,16,16,16\")])\n+  [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"=m,v,v,o,r,r,v\")\n+\t(match_operand:V16QI 1 \"input_operand\" \"v,m,v,r,o,r,W\"))]\n+  \"TARGET_ALTIVEC\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"stvx %1,%y0\\\";\n+    case 1: return \\\"lvx %0,%y1\\\";\n+    case 2: return \\\"vor %0,%1,%1\\\";\n+    case 3: return \\\"stw%U0 %1,%0\\;stw %L1,%L0\\;stw %Y1,%Y0\\;stw %Z1,%Z0\\\";\n+    case 4: return \\\"lwz%U1 %0,%1\\;lwz %L0,%L1\\;lwz %Y0,%Y1\\;lwz %Z0,%Z1\\\";\n+    case 5: return \\\"mr %0,%1\\;mr %L0,%L1\\;mr %Y0,%Y1\\;mr %Z0,%Z1\\\";\n+    case 6: return output_vec_const_move (operands);\n+    default: abort ();\n+    }\n+}\"\n+  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*,*\")\n+   (set_attr \"length\" \"*,*,*,16,16,16,*\")])\n+\n+(define_split\n+  [(set (match_operand:V16QI 0 \"altivec_register_operand\" \"\")\n+\t(match_operand:V16QI 1 \"easy_vector_constant_add_self\" \"\"))]\n+  \"TARGET_ALTIVEC && reload_completed\"\n+  [(set (match_dup 0)\n+\t(unspec:V16QI [(match_dup 3)] UNSPEC_VSPLTISB))\n+   (set (match_dup 0)\n+\t(plus:V16QI (match_dup 0)\n+\t\t   (match_dup 0)))]\n+  \"\n+{ operands[3] = GEN_INT (INTVAL (CONST_VECTOR_ELT (operands[1], 0)) >> 1); }\")\n \n (define_expand \"movv4sf\"\n   [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"\")\n@@ -145,18 +208,25 @@\n   \"{ rs6000_emit_move (operands[0], operands[1], V4SFmode); DONE; }\")\n \n (define_insn \"*movv4sf_internal1\"\n-  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=m,v,v,o,r,r\")\n-\t(match_operand:V4SF 1 \"input_operand\" \"v,m,v,r,o,r\"))]\n-  \"TARGET_ALTIVEC\"\n-  \"@\n-   stvx %1,%y0\n-   lvx %0,%y1\n-   vor %0,%1,%1\n-   stw%U0 %1,%0\\;stw %L1,%L0\\;stw %Y1,%Y0\\;stw %Z1,%Z0\n-   lwz%U1 %0,%1\\;lwz %L0,%L1\\;lwz %Y0,%Y1\\;lwz %Z0,%Z1\n-   mr %0,%1\\;mr %L0,%L1\\;mr %Y0,%Y1\\;mr %Z0,%Z1\"\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*\")\n-   (set_attr \"length\" \"*,*,*,16,16,16\")])\n+  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=m,v,v,o,r,r,v\")\n+\t(match_operand:V4SF 1 \"input_operand\" \"v,m,v,r,o,r,W\"))]\n+  \"TARGET_ALTIVEC\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"stvx %1,%y0\\\";\n+    case 1: return \\\"lvx %0,%y1\\\";\n+    case 2: return \\\"vor %0,%1,%1\\\";\n+    case 3: return \\\"stw%U0 %1,%0\\;stw %L1,%L0\\;stw %Y1,%Y0\\;stw %Z1,%Z0\\\";\n+    case 4: return \\\"lwz%U1 %0,%1\\;lwz %L0,%L1\\;lwz %Y0,%Y1\\;lwz %Z0,%Z1\\\";\n+    case 5: return \\\"mr %0,%1\\;mr %L0,%L1\\;mr %Y0,%Y1\\;mr %Z0,%Z1\\\";\n+    case 6: return output_vec_const_move (operands);\n+    default: abort ();\n+    }\n+}\"\n+  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*,*\")\n+   (set_attr \"length\" \"*,*,*,16,16,16,*\")])\n \n (define_insn \"get_vrsave_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -186,36 +256,6 @@\n }\"\n   [(set_attr \"type\" \"*\")])\n \n-;; Vector clears\n-(define_insn \"*movv4si_const0\"\n-  [(set (match_operand:V4SI 0 \"altivec_register_operand\" \"=v\")\n-\t(match_operand:V4SI 1 \"zero_constant\" \"\"))]\n-  \"TARGET_ALTIVEC\"\n-  \"vxor %0,%0,%0\"\n-  [(set_attr \"type\" \"vecsimple\")])\n-\n-(define_insn \"*movv4sf_const0\"\n-  [(set (match_operand:V4SF 0 \"altivec_register_operand\" \"=v\")\n-\t(match_operand:V4SF 1 \"zero_constant\" \"\"))]\n-\t\t\t\t\t \n-  \"TARGET_ALTIVEC\"\n-  \"vxor %0,%0,%0\"\n-  [(set_attr \"type\" \"vecsimple\")])\n-\n-(define_insn \"*movv8hi_const0\"\n-  [(set (match_operand:V8HI 0 \"altivec_register_operand\" \"=v\")\n-\t(match_operand:V8HI 1 \"zero_constant\" \"\"))]\n-  \"TARGET_ALTIVEC\"\n-  \"vxor %0,%0,%0\"\n-  [(set_attr \"type\" \"vecsimple\")])\n-\n-(define_insn \"*movv16qi_const0\"\n-  [(set (match_operand:V16QI 0 \"altivec_register_operand\" \"=v\")\n-\t(match_operand:V16QI 1 \"zero_constant\" \"\"))]\n-  \"TARGET_ALTIVEC\"\n-  \"vxor %0,%0,%0\"\n-  [(set_attr \"type\" \"vecsimple\")])\n-\n ;; Simple binary operations.\n \n (define_insn \"addv16qi3\"\n@@ -1279,6 +1319,7 @@\n   \"vsumsws %0,%1,%2\"\n   [(set_attr \"type\" \"veccomplex\")])\n \n+;; Vector xor's\n (define_insn \"xorv4si3\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (xor:V4SI (match_operand:V4SI 1 \"register_operand\" \"v\")\n@@ -1287,13 +1328,30 @@\n   \"vxor %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n+(define_insn \"xorv8hi3\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n+        (xor:V8HI (match_operand:V8HI 1 \"register_operand\" \"v\")\n+                  (match_operand:V8HI 2 \"register_operand\" \"v\")))]\n+  \"TARGET_ALTIVEC\"\n+  \"vxor %0,%1,%2\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"xorv16qi3\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n+        (xor:V16QI (match_operand:V16QI 1 \"register_operand\" \"v\")\n+\t\t   (match_operand:V16QI 2 \"register_operand\" \"v\")))]\n+  \"TARGET_ALTIVEC\"\n+  \"vxor %0,%1,%2\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n (define_insn \"altivec_vspltb\"\n   [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n         (unspec:V16QI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n                        (match_operand:QI 2 \"immediate_operand\" \"i\")] 136))]\n   \"TARGET_ALTIVEC\"\n   \"vspltb %0,%1,%2\"\n   [(set_attr \"type\" \"vecperm\")])\n+;; End of vector xor's\n \n (define_insn \"altivec_vsplth\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n@@ -1313,21 +1371,24 @@\n \n (define_insn \"altivec_vspltisb\"\n   [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n-        (unspec:V16QI [(match_operand:QI 1 \"immediate_operand\" \"i\")] 139))]\n+        (unspec:V16QI [(match_operand:QI 1 \"immediate_operand\" \"i\")]\n+\t\t      UNSPEC_VSPLTISB))]\n   \"TARGET_ALTIVEC\"\n   \"vspltisb %0,%1\"\n   [(set_attr \"type\" \"vecperm\")])\n \n (define_insn \"altivec_vspltish\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n-        (unspec:V8HI [(match_operand:QI 1 \"immediate_operand\" \"i\")] 140))]\n+        (unspec:V8HI [(match_operand:QI 1 \"immediate_operand\" \"i\")]\n+\t\t     UNSPEC_VSPLTISH))]\n   \"TARGET_ALTIVEC\"\n   \"vspltish %0,%1\"\n   [(set_attr \"type\" \"vecperm\")])\n \n (define_insn \"altivec_vspltisw\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n-        (unspec:V4SI [(match_operand:QI 1 \"immediate_operand\" \"i\")] 141))]\n+        (unspec:V4SI [(match_operand:QI 1 \"immediate_operand\" \"i\")]\n+\t\t     UNSPEC_VSPLTISW))]\n   \"TARGET_ALTIVEC\"\n   \"vspltisw %0,%1\"\n   [(set_attr \"type\" \"vecperm\")])"}, {"sha": "3bd3b737611ec6b8374d12079d6b036891ecc6e4", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=d744e06e5edeb7dca7bf021559b3bdfdabe12a28", "patch": "@@ -54,6 +54,8 @@ extern int got_operand PARAMS ((rtx, enum machine_mode));\n extern int got_no_const_operand PARAMS ((rtx, enum machine_mode));\n extern int num_insns_constant PARAMS ((rtx, enum machine_mode));\n extern int easy_fp_constant PARAMS ((rtx, enum machine_mode));\n+extern int easy_vector_constant PARAMS ((rtx, enum machine_mode));\n+extern const char *output_vec_const_move PARAMS ((rtx *));\n extern int zero_fp_constant PARAMS ((rtx, enum machine_mode));\n extern int zero_constant PARAMS ((rtx, enum machine_mode));\n extern int volatile_mem_operand PARAMS ((rtx, enum machine_mode));"}, {"sha": "0de56c1c8fbe0483e43394cf1083bb102fedf712", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 144, "deletions": 30, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d744e06e5edeb7dca7bf021559b3bdfdabe12a28", "patch": "@@ -55,6 +55,13 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_NO_PROTOTYPE 0\n #endif\n \n+#define EASY_VECTOR_15(n, x, y) ((n) >= -16 && (n) <= 15 \\\n+\t\t\t\t && easy_vector_same (x, y))\n+\n+#define EASY_VECTOR_15_ADD_SELF(n, x, y) ((n) >= 0x10 && (n) <= 0x1e \\\n+                                          && !((n) & 1)              \\\n+\t\t\t\t\t  && easy_vector_same (x, y))\n+\n #define min(A,B)\t((A) < (B) ? (A) : (B))\n #define max(A,B)\t((A) > (B) ? (A) : (B))\n \n@@ -266,7 +273,8 @@ static int first_altivec_reg_to_save PARAMS ((void));\n static unsigned int compute_vrsave_mask PARAMS ((void));\n static void is_altivec_return_reg PARAMS ((rtx, void *));\n static rtx generate_set_vrsave PARAMS ((rtx, rs6000_stack_t *, int));\n-static int easy_vector_constant PARAMS ((rtx));\n+int easy_vector_constant PARAMS ((rtx, enum machine_mode));\n+static int easy_vector_same PARAMS ((rtx, enum machine_mode));\n static bool is_ev64_opaque_type PARAMS ((tree));\n static rtx rs6000_dwarf_register_span PARAMS ((rtx));\n \n@@ -1416,48 +1424,149 @@ easy_fp_constant (op, mode)\n     abort ();\n }\n \n-/* Return 1 if the operand is a CONST_INT and can be put into a\n-   register with one instruction.  */\n+/* Return non zero if all elements of a vector have the same value.  */\n \n static int\n-easy_vector_constant (op)\n+easy_vector_same (op, mode)\n      rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  rtx elt;\n-  int units, i;\n+  int units, i, cst;\n+\n+  units = CONST_VECTOR_NUNITS (op);\n \n-  if (GET_CODE (op) != CONST_VECTOR)\n+  cst = INTVAL (CONST_VECTOR_ELT (op, 0));\n+  for (i = 1; i < units; ++i)\n+    if (INTVAL (CONST_VECTOR_ELT (op, i)) != cst)\n+      break;\n+  if (i == units)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Return 1 if the operand is a CONST_INT and can be put into a\n+   register without using memory.  */\n+\n+int\n+easy_vector_constant (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  int cst, cst2;\n+\n+  if (GET_CODE (op) != CONST_VECTOR\n+      || (!TARGET_ALTIVEC\n+\t  && !TARGET_SPE))\n     return 0;\n \n-  units = CONST_VECTOR_NUNITS (op);\n+  if (zero_constant (op, mode)\n+      && ((TARGET_ALTIVEC && ALTIVEC_VECTOR_MODE (mode))\n+\t  || (TARGET_SPE && SPE_VECTOR_MODE (mode))))\n+    return 1;\n \n-  /* We can generate 0 easily.  Look for that.  */\n-  for (i = 0; i < units; ++i)\n-    {\n-      elt = CONST_VECTOR_ELT (op, i);\n+  if (GET_MODE_CLASS (mode) != MODE_VECTOR_INT)\n+    return 0;\n+\n+  cst  = INTVAL (CONST_VECTOR_ELT (op, 0));\n+  cst2 = INTVAL (CONST_VECTOR_ELT (op, 1));\n+\n+  /* Limit SPE vectors to 15 bits signed.  These we can generate with:\n+       li r0, CONSTANT1\n+       evmergelo r0, r0, r0\n+       li r0, CONSTANT2\n+\n+     I don't know how efficient it would be to allow bigger constants,\n+     considering we'll have an extra 'ori' for every 'li'.  I doubt 5\n+     instructions is better than a 64-bit memory load, but I don't\n+     have the e500 timing specs.  */\n+  if (TARGET_SPE && mode == V2SImode\n+      && cst  >= -0x7fff && cst <= 0x7fff\n+      && cst2 >= -0x7fff && cst <= 0x7fff)\n+    return 1;\n+\n+  if (TARGET_ALTIVEC && EASY_VECTOR_15 (cst, op, mode))\n+    return 1;\n+\n+  if (TARGET_ALTIVEC && EASY_VECTOR_15_ADD_SELF (cst, op, mode))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Same as easy_vector_constant but only for EASY_VECTOR_15_ADD_SELF.  */\n+\n+int\n+easy_vector_constant_add_self (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  int cst;\n \n-      /* We could probably simplify this by just checking for equality\n-\t with CONST0_RTX for the current mode, but let's be safe\n-\t instead.  */\n+  if (!easy_vector_constant (op, mode))\n+    return 0;\n+\n+  cst = INTVAL (CONST_VECTOR_ELT (op, 0));\n+\n+  return TARGET_ALTIVEC && EASY_VECTOR_15_ADD_SELF (cst, op, mode);\n+}\n+\n+const char *\n+output_vec_const_move (operands)\n+     rtx *operands;\n+{\n+  int cst, cst2;\n+  enum machine_mode mode;\n+  rtx dest, vec;\n+\n+  dest = operands[0];\n+  vec = operands[1];\n \n-      switch (GET_CODE (elt))\n+  cst = INTVAL (CONST_VECTOR_ELT (vec, 0));\n+  cst2 = INTVAL (CONST_VECTOR_ELT (vec, 1));\n+  mode = GET_MODE (dest);\n+\n+  if (TARGET_ALTIVEC)\n+    {\n+      if (zero_constant (vec, mode))\n+\treturn \"vxor %0,%0,%0\";\n+      else if (EASY_VECTOR_15 (cst, vec, mode))\n \t{\n-\tcase CONST_INT:\n-\t  if (INTVAL (elt) != 0)\n-\t    return 0;\n-\t  break;\n-\tcase CONST_DOUBLE:\n-\t  if (CONST_DOUBLE_LOW (elt) != 0 || CONST_DOUBLE_HIGH (elt) != 0)\n-\t    return 0;\n-\t  break;\n-\tdefault:\n-\t  return 0;\n+\t  operands[1] = GEN_INT (cst);\n+\t  switch (mode)\n+\t    {\n+\t    case V4SImode:\n+\t      return \"vspltisw %0,%1\";\n+\t    case V8HImode:\n+\t      return \"vspltish %0,%1\";\n+\t    case V16QImode:\n+\t      return \"vspltisb %0,%1\";\n+\t    default:\n+\t      abort ();\n+\t    }\n \t}\n+      else if (EASY_VECTOR_15_ADD_SELF (cst, vec, mode))\n+\treturn \"#\";\n+      else\n+\tabort ();\n     }\n \n-  /* We could probably generate a few other constants trivially, but\n-     gcc doesn't generate them yet.  FIXME later.  */\n-  return 1;\n+  if (TARGET_SPE)\n+    {\n+      /* Vector constant 0 is handled as a splitter of V2SI, and in the\n+\t pattern of V1DI, V4HI, and V2SF.\n+\n+\t FIXME: We should probabl return # and add post reload\n+\t splitters for these, but this way is so easy ;-).\n+      */\n+      operands[1] = GEN_INT (cst);\n+      operands[2] = GEN_INT (cst2);\n+      if (cst == cst2)\n+\treturn \"li %0,%1\\n\\tevmergelo %0,%0,%0\";\n+      else\n+\treturn \"li %0,%1\\n\\tevmergelo %0,%0,%0\\n\\tli %0,%2\";\n+    }\n+\n+  abort ();\n }\n \n /* Return 1 if the operand is the constant 0.  This works for scalars\n@@ -1990,6 +2099,11 @@ input_operand (op, mode)\n \t  || GET_CODE (op) == CONST_DOUBLE))\n     return 1;\n \n+  /* Allow easy vector constants.  */\n+  if (GET_CODE (op) == CONST_VECTOR\n+      && easy_vector_constant (op, mode))\n+    return 1;\n+\n   /* For floating-point or multi-word mode, the only remaining valid type\n      is a register.  */\n   if (GET_MODE_CLASS (mode) == MODE_FLOAT\n@@ -2744,7 +2858,7 @@ rs6000_emit_move (dest, source, mode)\n     case V2SImode:\n     case V1DImode:\n       if (CONSTANT_P (operands[1])\n-\t  && !easy_vector_constant (operands[1]))\n+\t  && !easy_vector_constant (operands[1], mode))\n \toperands[1] = force_const_mem (mode, operands[1]);\n       break;\n       "}, {"sha": "0d8085c4e3f23674650eac7d3310815d78995480", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=d744e06e5edeb7dca7bf021559b3bdfdabe12a28", "patch": "@@ -1292,6 +1292,7 @@ enum reg_class\n    'S' is a constant that can be placed into a 64-bit mask operand\n    'T' is a constant that can be placed into a 32-bit mask operand\n    'U' is for V.4 small data references.\n+   'W' is a vector constant that can be easily generated (no mem refs).\n    't' is for AND masks that can be performed by two rldic{l,r} insns.  */\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\t\t\\\n@@ -1305,6 +1306,7 @@ enum reg_class\n \t\t   && (fixed_regs[CR0_REGNO]\t\t\t\t\\\n \t\t       || !logical_operand (OP, DImode))\t\t\\\n \t\t   && !mask64_operand (OP, DImode))\t\t\t\\\n+   : (C) == 'W' ? (easy_vector_constant (OP, GET_MODE (OP)))\t\t\\\n    : 0)\n \n /* Given an rtx X being reloaded into a reg required to be\n@@ -2740,6 +2742,8 @@ extern char rs6000_reg_names[][8];\t/* register names (0 vs. %r0).  */\n   {\"got_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\t   \\\n   {\"got_no_const_operand\", {SYMBOL_REF, LABEL_REF}},\t\t\t   \\\n   {\"easy_fp_constant\", {CONST_DOUBLE}},\t\t\t\t\t   \\\n+  {\"easy_vector_constant\", {CONST_VECTOR}},\t\t\t\t   \\\n+  {\"easy_vector_constant_add_self\", {CONST_VECTOR}},\t\t\t   \\\n   {\"zero_fp_constant\", {CONST_DOUBLE}},\t\t\t\t\t   \\\n   {\"reg_or_mem_operand\", {SUBREG, MEM, REG}},\t\t\t\t   \\\n   {\"lwa_operand\", {SUBREG, MEM, REG}},\t\t\t\t\t   \\"}, {"sha": "30a07f98a9ae1c70e308b2c34c9209e62516c38c", "filename": "gcc/config/rs6000/spe.md", "status": "modified", "additions": 37, "deletions": 48, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Fconfig%2Frs6000%2Fspe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Fconfig%2Frs6000%2Fspe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fspe.md?ref=d744e06e5edeb7dca7bf021559b3bdfdabe12a28", "patch": "@@ -2147,36 +2147,6 @@\n   [(set_attr \"type\" \"vecstore\")\n    (set_attr  \"length\" \"4\")])\n \n-;; SPE vector clears\n-\n-(define_insn \"*movv2si_const0\"\n-  [(set (match_operand:V2SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(match_operand:V2SI 1 \"zero_constant\" \"\"))]\n-  \"TARGET_SPE\"\n-  \"evxor %0,%0,%0\"\n-  [(set_attr \"type\" \"vecsimple\")])\n-\n-(define_insn \"*movv2sf_const0\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=r\")\n-\t(match_operand:V2SF 1 \"zero_constant\" \"\"))]\n-  \"TARGET_SPE\"\n-  \"evxor %0,%0,%0\"\n-  [(set_attr \"type\" \"vecsimple\")])\n-\n-(define_insn \"*movv4hi_const0\"\n-  [(set (match_operand:V4HI 0 \"gpc_reg_operand\" \"=r\")\n-\t(match_operand:V4HI 1 \"zero_constant\" \"\"))]\n-  \"TARGET_SPE\"\n-  \"evxor %0,%0,%0\"\n-  [(set_attr \"type\" \"vecsimple\")])\n-\n-(define_insn \"*movv1di_const0\"\n-  [(set (match_operand:V1DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(match_operand:V1DI 1 \"zero_constant\" \"\"))]\n-  \"TARGET_SPE\"\n-  \"evxor %0,%0,%0\"\n-  [(set_attr \"type\" \"vecsimple\")])\n-\n ;; Vector move instructions.\n \n (define_expand \"movv2si\"\n@@ -2185,16 +2155,31 @@\n   \"TARGET_SPE\"\n   \"{ rs6000_emit_move (operands[0], operands[1], V2SImode); DONE; }\")\n \n-\n (define_insn \"*movv2si_internal\"\n-  [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"=m,r,r\")\n-\t(match_operand:V2SI 1 \"input_operand\" \"r,m,r\"))]\n-  \"TARGET_SPE\"\n-  \"@\n-   evstdd%X0 %1,%y0\n-   evldd%X1 %0,%y1\n-   evor %0,%1,%1\"\n-  [(set_attr \"type\" \"vecload,vecload,vecsimple\")])\n+  [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"=m,r,r,r\")\n+\t(match_operand:V2SI 1 \"input_operand\" \"r,m,r,W\"))]\n+  \"TARGET_SPE\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"evstdd%X0 %1,%y0\\\";\n+    case 1: return \\\"evldd%X1 %0,%y1\\\";\n+    case 2: return \\\"evor %0,%1,%1\\\";\n+    case 3: return output_vec_const_move (operands);\n+    default: abort ();\n+    }\n+}\"\n+  [(set_attr \"type\" \"vecload,vecstore,*,*\")\n+   (set_attr \"length\" \"*,*,*,12\")])\n+\n+(define_split\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"\")\n+\t(match_operand:V2SI 1 \"zero_constant\" \"\"))]\n+  \"TARGET_SPE && reload_completed\"\n+  [(set (match_dup 0)\n+\t(xor:V2SI (match_dup 0) (match_dup 0)))]\n+  \"\")\n \n (define_expand \"movv1di\"\n   [(set (match_operand:V1DI 0 \"nonimmediate_operand\" \"\")\n@@ -2203,14 +2188,16 @@\n   \"{ rs6000_emit_move (operands[0], operands[1], V1DImode); DONE; }\")\n \n (define_insn \"*movv1di_internal\"\n-  [(set (match_operand:V1DI 0 \"nonimmediate_operand\" \"=m,r,r\")\n-\t(match_operand:V1DI 1 \"input_operand\" \"r,m,r\"))]\n+  [(set (match_operand:V1DI 0 \"nonimmediate_operand\" \"=m,r,r,r\")\n+\t(match_operand:V1DI 1 \"input_operand\" \"r,m,r,W\"))]\n   \"TARGET_SPE\"\n   \"@\n    evstdd%X0 %1,%y0\n    evldd%X1 %0,%y1\n-   evor %0,%1,%1\"\n-  [(set_attr \"type\" \"vecload,vecload,vecsimple\")])\n+   evor %0,%1,%1\n+   evxor %0,%0,%0\"\n+  [(set_attr \"type\" \"vecload,vecstore,*,*\")\n+   (set_attr \"length\" \"*,*,*,*\")])\n \n (define_expand \"movv4hi\"\n   [(set (match_operand:V4HI 0 \"nonimmediate_operand\" \"\")\n@@ -2226,7 +2213,7 @@\n    evstdd%X0 %1,%y0\n    evldd%X1 %0,%y1\n    evor %0,%1,%1\"\n-  [(set_attr \"type\" \"vecload,vecload,vecsimple\")])\n+  [(set_attr \"type\" \"vecload\")])\n \n (define_expand \"movv2sf\"\n   [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"\")\n@@ -2235,14 +2222,16 @@\n   \"{ rs6000_emit_move (operands[0], operands[1], V2SFmode); DONE; }\")\n \n (define_insn \"*movv2sf_internal\"\n-  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"=m,r,r\")\n-\t(match_operand:V2SF 1 \"input_operand\" \"r,m,r\"))]\n+  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"=m,r,r,r\")\n+\t(match_operand:V2SF 1 \"input_operand\" \"r,m,r,W\"))]\n   \"TARGET_SPE\"\n   \"@\n    evstdd%X0 %1,%y0\n    evldd%X1 %0,%y1\n-   evor %0,%1,%1\"\n-  [(set_attr \"type\" \"vecload,vecload,vecsimple\")])\n+   evor %0,%1,%1\n+   evxor %0,%0,%0\"\n+  [(set_attr \"type\" \"vecload,vecstore,*,*\")\n+   (set_attr \"length\" \"*,*,*,*\")])\n \n (define_insn \"spe_evmwhssfaa\"\n   [(set (match_operand:V2SI 0 \"gpc_reg_operand\" \"=r\")"}, {"sha": "e9d0ee52c92c750fe423f837d04a206941b4f089", "filename": "gcc/expr.c", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d744e06e5edeb7dca7bf021559b3bdfdabe12a28", "patch": "@@ -155,7 +155,7 @@ static rtx clear_storage_via_libcall PARAMS ((rtx, rtx));\n static tree clear_storage_libcall_fn PARAMS ((int));\n static rtx compress_float_constant PARAMS ((rtx, rtx));\n static rtx get_subtarget\tPARAMS ((rtx));\n-static int is_zeros_p\t\tPARAMS ((tree));\n+static int is_zeros_p         PARAMS ((tree));\n static int mostly_zeros_p\tPARAMS ((tree));\n static void store_constructor_field PARAMS ((rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t\t     HOST_WIDE_INT, enum machine_mode,\n@@ -175,6 +175,7 @@ static rtx do_store_flag\tPARAMS ((tree, rtx, enum machine_mode, int));\n static void emit_single_push_insn PARAMS ((enum machine_mode, rtx, tree));\n #endif\n static void do_tablejump PARAMS ((rtx, enum machine_mode, rtx, rtx, rtx));\n+static rtx const_vector_from_tree PARAMS ((tree));\n \n /* Record for each mode whether we can move a register directly to or\n    from an object of that mode in memory.  If we can't, we won't try\n@@ -6842,6 +6843,9 @@ expand_expr (exp, target, tmode, modifier)\n \n       return temp;\n \n+    case VECTOR_CST:\n+      return const_vector_from_tree (exp);\n+\n     case CONST_DECL:\n       return expand_expr (DECL_INITIAL (exp), target, VOIDmode, modifier);\n \n@@ -10329,4 +10333,41 @@ vector_mode_valid_p (mode)\n   return mov_optab->handlers[innermode].insn_code != CODE_FOR_nothing;\n }\n \n+/* Return a CONST_VECTOR rtx for a VECTOR_CST tree.  */\n+static rtx\n+const_vector_from_tree (exp)\n+     tree exp;\n+{\n+  rtvec v;\n+  int units, i;\n+  tree link, elt;\n+  enum machine_mode inner, mode;\n+\n+  mode = TYPE_MODE (TREE_TYPE (exp));\n+\n+  if (is_zeros_p (exp))\n+    return CONST0_RTX (mode);\n+\n+  units = GET_MODE_NUNITS (mode);\n+  inner = GET_MODE_INNER (mode);\n+\n+  v = rtvec_alloc (units);\n+\n+  link = TREE_VECTOR_CST_ELTS (exp);\n+  for (i = 0; link; link = TREE_CHAIN (link), ++i)\n+    {\n+      elt = TREE_VALUE (link);\n+\n+      if (TREE_CODE (elt) == REAL_CST)\n+\tRTVEC_ELT (v, i) = CONST_DOUBLE_FROM_REAL_VALUE (TREE_REAL_CST (elt),\n+\t\t\t\t\t\t\t inner);\n+      else\n+\tRTVEC_ELT (v, i) = immed_double_const (TREE_INT_CST_LOW (elt),\n+\t\t\t\t\t       TREE_INT_CST_HIGH (elt),\n+\t\t\t\t\t       inner);\n+    }\n+\n+  return gen_rtx_raw_CONST_VECTOR (mode, v);\n+}\n+\n #include \"gt-expr.h\""}, {"sha": "2bae494c225d6ed560154f3619020decfa3c1b56", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d744e06e5edeb7dca7bf021559b3bdfdabe12a28", "patch": "@@ -1,3 +1,7 @@\n+2003-03-01  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * testsuite/gcc.c-torture/execute/simd-3.c: New.\n+\n 2003-03-31  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c/9936"}, {"sha": "9c93e9bd26db5420d805436a84a66470324716f4", "filename": "gcc/varasm.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d744e06e5edeb7dca7bf021559b3bdfdabe12a28/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=d744e06e5edeb7dca7bf021559b3bdfdabe12a28", "patch": "@@ -4015,6 +4015,23 @@ output_constant (exp, size, align)\n \t  thissize = MIN (TREE_STRING_LENGTH (exp), size);\n \t  assemble_string (TREE_STRING_POINTER (exp), thissize);\n \t}\n+      else if (TREE_CODE (exp) == VECTOR_CST)\n+\t{\n+\t  int elt_size;\n+\t  tree link;\n+\t  unsigned int nalign;\n+\t  enum machine_mode inner;\n+\n+\t  inner = GET_MODE_INNER (TYPE_MODE (TREE_TYPE (exp)));\n+\t  nalign = MIN (align, GET_MODE_ALIGNMENT (inner));\n+\n+\t  elt_size = GET_MODE_UNIT_SIZE (TYPE_MODE (TREE_TYPE (exp)));\n+\n+\t  link = TREE_VECTOR_CST_ELTS (exp);\n+\t  output_constant (TREE_VALUE (link), elt_size, align);\n+\t  while ((link = TREE_CHAIN (link)) != NULL)\n+\t    output_constant (TREE_VALUE (link), elt_size, nalign);\n+\t}\n       else\n \tabort ();\n       break;"}]}