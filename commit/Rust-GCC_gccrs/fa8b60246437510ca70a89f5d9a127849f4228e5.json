{"sha": "fa8b60246437510ca70a89f5d9a127849f4228e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE4YjYwMjQ2NDM3NTEwY2E3MGE4OWY1ZDlhMTI3ODQ5ZjQyMjhlNQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1997-09-03T19:28:49Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-09-03T19:28:49Z"}, "message": "Fix H.J. Lu's alpha-linux aliasing bug.\n\n\t* alias.c (true_dependence): Address with AND can alias scalars.\n\t(anti_dependence, output_dependence): Likewise.\n\nFrom-SVN: r15063", "tree": {"sha": "6f784566b8cf913929bf3bb2e772812c549daac1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f784566b8cf913929bf3bb2e772812c549daac1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa8b60246437510ca70a89f5d9a127849f4228e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa8b60246437510ca70a89f5d9a127849f4228e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa8b60246437510ca70a89f5d9a127849f4228e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa8b60246437510ca70a89f5d9a127849f4228e5/comments", "author": null, "committer": null, "parents": [{"sha": "03e707055891d5eaaf5dc9e850123bd2dd16ba38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03e707055891d5eaaf5dc9e850123bd2dd16ba38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03e707055891d5eaaf5dc9e850123bd2dd16ba38"}], "stats": {"total": 15, "additions": 13, "deletions": 2}, "files": [{"sha": "e77c1c6a30bfbd55333b3cbdb6444557cfe90657", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa8b60246437510ca70a89f5d9a127849f4228e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa8b60246437510ca70a89f5d9a127849f4228e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa8b60246437510ca70a89f5d9a127849f4228e5", "patch": "@@ -1,5 +1,8 @@\n Wed Sep  3 10:39:42 1997  Jim Wilson  <wilson@cygnus.com>\n \n+\t* alias.c (true_dependence): Address with AND can alias scalars.\n+\t(anti_dependence, output_dependence): Likewise.\n+\t\n \t* alias.c (true_dependence): Test x for BLKmode, in addition to mem.\n \n Wed Sep  3 09:28:50 CDT 1997  Joel Sherrill (joel@OARcorp.com)"}, {"sha": "4c2ca48b3eb94916c03328bdc20c819947414c37", "filename": "gcc/alias.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa8b60246437510ca70a89f5d9a127849f4228e5/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa8b60246437510ca70a89f5d9a127849f4228e5/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=fa8b60246437510ca70a89f5d9a127849f4228e5", "patch": "@@ -751,11 +751,14 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n    changed.  A volatile and non-volatile reference can be interchanged\n    though. \n \n-   A MEM_IN_STRUCT reference at a non-QImode varying address can never\n+   A MEM_IN_STRUCT reference at a non-QImode non-AND varying address can never\n    conflict with a non-MEM_IN_STRUCT reference at a fixed address.   We must\n    allow QImode aliasing because the ANSI C standard allows character\n    pointers to alias anything.  We are assuming that characters are\n-   always QImode here.  */\n+   always QImode here.  We also must allow AND addresses, because they may\n+   generate accesses outside the object being referenced.  This is used to\n+   generate aligned addresses from unaligned addresses, for instance, the\n+   alpha storeqi_unaligned pattern.  */\n \n /* Read dependence: X is read after read in MEM takes place.  There can\n    only be a dependence here if both reads are volatile.  */\n@@ -816,6 +819,7 @@ true_dependence (mem, mem_mode, x, varies)\n   if (MEM_IN_STRUCT_P (x) == MEM_IN_STRUCT_P (mem)\n       || mem_mode == QImode || mem_mode == BLKmode\n       || GET_MODE (x) == QImode || GET_MODE (x) == BLKmode\n+      || GET_CODE (x_addr) == AND || GET_CODE (mem_addr) == AND\n       || varies (x_addr) == varies (mem_addr))\n     return 1;\n \n@@ -856,9 +860,11 @@ anti_dependence (mem, x)\n \t\t\t      SIZE_FOR_MODE (x), XEXP (x, 0), 0)\n \t  && ! (MEM_IN_STRUCT_P (mem) && rtx_addr_varies_p (mem)\n \t\t&& GET_MODE (mem) != QImode\n+\t\t&& GET_CODE (XEXP (mem, 0)) != AND\n \t\t&& ! MEM_IN_STRUCT_P (x) && ! rtx_addr_varies_p (x))\n \t  && ! (MEM_IN_STRUCT_P (x) && rtx_addr_varies_p (x)\n \t\t&& GET_MODE (x) != QImode\n+\t\t&& GET_CODE (XEXP (x, 0)) != AND\n \t\t&& ! MEM_IN_STRUCT_P (mem) && ! rtx_addr_varies_p (mem)));\n }\n \n@@ -881,9 +887,11 @@ output_dependence (mem, x)\n \t\t\t      SIZE_FOR_MODE (x), XEXP (x, 0), 0)\n \t  && ! (MEM_IN_STRUCT_P (mem) && rtx_addr_varies_p (mem)\n \t\t&& GET_MODE (mem) != QImode\n+\t\t&& GET_CODE (XEXP (mem, 0)) != AND\n \t\t&& ! MEM_IN_STRUCT_P (x) && ! rtx_addr_varies_p (x))\n \t  && ! (MEM_IN_STRUCT_P (x) && rtx_addr_varies_p (x)\n \t\t&& GET_MODE (x) != QImode\n+\t\t&& GET_CODE (XEXP (x, 0)) != AND\n \t\t&& ! MEM_IN_STRUCT_P (mem) && ! rtx_addr_varies_p (mem)));\n }\n "}]}