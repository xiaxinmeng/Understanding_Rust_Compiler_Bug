{"sha": "f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZiNWRjOGUxZjg4ZjcxYjNhNTIzZmY2NTFiZmRjMzJhYTNjODkwYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-25T14:44:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-25T14:44:20Z"}, "message": "[multiple changes]\n\n2010-10-25  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch5.adb (Expand_Predicated_Loop): Remove code for loop through\n\tnon-static predicate, since we agree not to allow this.\n\t(Expand_Predicated_Loop): Properlay handle false predicate (null\n\tlist in Static_Predicate field.\n\t* sem_ch13.adb (Build_Static_Predicate): Extensive changes to clean up\n\thandling of more general predicate forms.\n\n2010-10-25  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch4.adb, sem_util.adb: Minor reformatting.\n\t* sem_ch8.adb (Find_Selected_Component): Allow selection from instance\n\tof type in predicate or invariant expression.\n\n2010-10-25  Pascal Obry  <obry@adacore.com>\n\n\t* adaint.c (__gnat_stat_to_attr): Can set the timestamp on Windows now.\n\t(f2t): New routine.\n\t(__gnat_stat): Rewrite Win32 version.\n\nFrom-SVN: r165919", "tree": {"sha": "6324a36969f16b9d490577a0560b012087d1c2ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6324a36969f16b9d490577a0560b012087d1c2ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b/comments", "author": null, "committer": null, "parents": [{"sha": "66150d01351e5ca53999297629516ea2d5bcedb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66150d01351e5ca53999297629516ea2d5bcedb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66150d01351e5ca53999297629516ea2d5bcedb1"}], "stats": {"total": 491, "additions": 274, "deletions": 217}, "files": [{"sha": "646811d924c072b06f7dda2cd179b02021b62c59", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b", "patch": "@@ -1,3 +1,24 @@\n+2010-10-25  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch5.adb (Expand_Predicated_Loop): Remove code for loop through\n+\tnon-static predicate, since we agree not to allow this.\n+\t(Expand_Predicated_Loop): Properlay handle false predicate (null\n+\tlist in Static_Predicate field.\n+\t* sem_ch13.adb (Build_Static_Predicate): Extensive changes to clean up\n+\thandling of more general predicate forms.\n+\n+2010-10-25  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch4.adb, sem_util.adb: Minor reformatting.\n+\t* sem_ch8.adb (Find_Selected_Component): Allow selection from instance\n+\tof type in predicate or invariant expression.\n+\n+2010-10-25  Pascal Obry  <obry@adacore.com>\n+\n+\t* adaint.c (__gnat_stat_to_attr): Can set the timestamp on Windows now.\n+\t(f2t): New routine.\n+\t(__gnat_stat): Rewrite Win32 version.\n+\n 2010-10-25  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_warn.adb, einfo.ads, exp_ch4.adb: Minor comment fix"}, {"sha": "a251a4e3ee94a5971e6cd4bfbed6b842e041ca36", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 48, "deletions": 30, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b", "patch": "@@ -1112,8 +1112,6 @@ __gnat_stat_to_attr (int fd, char* name, struct file_attributes* attr)\n   attr->executable = (!ret && (statbuf.st_mode & S_IXUSR));\n #endif\n \n-#if !defined (_WIN32) || defined (RTX)\n-  /* on Windows requires extra system call, see __gnat_file_time_name_attr */\n   if (ret != 0) {\n      attr->timestamp = (OS_Time)-1;\n   } else {\n@@ -1124,8 +1122,6 @@ __gnat_stat_to_attr (int fd, char* name, struct file_attributes* attr)\n      attr->timestamp = (OS_Time)statbuf.st_mtime;\n #endif\n   }\n-#endif\n-\n }\n \n /****************************************************************\n@@ -1345,6 +1341,19 @@ win32_filetime (HANDLE h)\n     return (time_t) (t_write.ull_time / 10000000ULL - w32_epoch_offset);\n   return (time_t) 0;\n }\n+\n+/* As above but starting from a FILETIME.  */\n+static void f2t (const FILETIME *ft, time_t *t)\n+{\n+  union\n+  {\n+    FILETIME ft_time;\n+    unsigned long long ull_time;\n+  } t_write;\n+\n+  t_write.ft_time = *ft;\n+  *t = (time_t) (t_write.ull_time / 10000000ULL - w32_epoch_offset);\n+}\n #endif\n \n /* Return a GNAT time stamp given a file name.  */\n@@ -1687,45 +1696,54 @@ int\n __gnat_stat (char *name, GNAT_STRUCT_STAT *statbuf)\n {\n #ifdef __MINGW32__\n-  /* Under Windows the directory name for the stat function must not be\n-     terminated by a directory separator except if just after a drive name\n-     or with UNC path without directory (only the name of the shared\n-     resource), for example: \\\\computer\\share\\  */\n-\n+  WIN32_FILE_ATTRIBUTE_DATA fad;\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n-  int name_len, k;\n-  TCHAR last_char;\n-  int dirsep_count = 0;\n+  int name_len;\n+  BOOL res;\n \n   S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n   name_len = _tcslen (wname);\n \n   if (name_len > GNAT_MAX_PATH_LEN)\n     return -1;\n \n-  last_char = wname[name_len - 1];\n-\n-  while (name_len > 1 && (last_char == _T('\\\\') || last_char == _T('/')))\n-    {\n-      wname[name_len - 1] = _T('\\0');\n-      name_len--;\n-      last_char = wname[name_len - 1];\n+  ZeroMemory (statbuf, sizeof(GNAT_STRUCT_STAT));\n+\n+  res = GetFileAttributesEx (wname, GetFileExInfoStandard, &fad);\n+\n+  if (res == FALSE)\n+    switch (GetLastError()) {\n+    case ERROR_ACCESS_DENIED:\n+    case ERROR_SHARING_VIOLATION:\n+    case ERROR_LOCK_VIOLATION:\n+    case ERROR_SHARING_BUFFER_EXCEEDED:\n+      return EACCES;\n+    case ERROR_BUFFER_OVERFLOW:\n+      return ENAMETOOLONG;\n+    case ERROR_NOT_ENOUGH_MEMORY:\n+      return ENOMEM;\n+    default:\n+      return ENOENT;\n     }\n \n-  /* Count back-slashes.  */\n+  f2t (&fad.ftCreationTime, &statbuf->st_ctime);\n+  f2t (&fad.ftLastWriteTime, &statbuf->st_mtime);\n+  f2t (&fad.ftLastAccessTime, &statbuf->st_atime);\n+\n+  statbuf->st_size = (off_t)fad.nFileSizeLow;\n \n-  for (k=0; k<name_len; k++)\n-    if (wname[k] == _T('\\\\') || wname[k] == _T('/'))\n-      dirsep_count++;\n+  /* We do not have the S_IEXEC attribute, but this is not used on GNAT.  */\n+  statbuf->st_mode = S_IREAD;\n \n-  /* Only a drive letter followed by ':', we must add a directory separator\n-     for the stat routine to work properly.  */\n-  if ((name_len == 2 && wname[1] == _T(':'))\n-      || (name_len > 3 && wname[0] == _T('\\\\') && wname[1] == _T('\\\\')\n-\t  && dirsep_count == 3))\n-    _tcscat (wname, _T(\"\\\\\"));\n+  if (fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n+    statbuf->st_mode |= S_IFDIR;\n+  else\n+    statbuf->st_mode |= S_IFREG;\n \n-  return _tstat (wname, (struct _stat *)statbuf);\n+  if (!(fad.dwFileAttributes & FILE_ATTRIBUTE_READONLY))\n+    statbuf->st_mode |= S_IWRITE;\n+\n+  return 0;\n \n #else\n   return GNAT_STAT (name, statbuf);"}, {"sha": "7432bdc51fc97d4a479577b01c7272f6fbe2724d", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b", "patch": "@@ -3001,7 +3001,7 @@ package body Exp_Ch5 is\n       if No (Isc) then\n          null;\n \n-      --  Case of for loop (Loop_Parameter_Specfication present)\n+      --  Case of for loop (Loop_Parameter_Specification present)\n \n       --  Note: we do not have to worry about validity checking of the for loop\n       --  range bounds here, since they were frozen with constant declarations\n@@ -3215,26 +3215,20 @@ package body Exp_Ch5 is\n       Stmts   : constant List_Id    := Statements (N);\n \n    begin\n-      --  Case of iteration over non-static predicate. In this case we\n-      --  generate the sequence:\n-\n-      --     for J in Ltype'First .. Ltype'Last loop\n-      --        if Ltype_Predicate_Function (J) then\n-      --           body;\n-      --        end if;\n-      --     end loop;\n+      --  Case of iteration over non-static predicate, should not be possible\n+      --  since this is not allowed by the semantics and should have been\n+      --  caught during analysis of the loop statement.\n \n       if No (Stat) then\n+         raise Program_Error;\n \n-         --  The analyzer already expanded the First/Last, so all we have\n-         --  to do is wrap the body within the predicate function test.\n+      --  If the predicate list is empty, that corresponds to a predicate of\n+      --  False, in which case the loop won't run at all, and we rewrite the\n+      --  entire loop as a null statement.\n \n-         Set_Statements (N, New_List (\n-           Make_If_Statement (Loc,\n-             Condition =>\n-               Make_Predicate_Call (Ltype, New_Occurrence_Of (Loop_Id, Loc)),\n-             Then_Statements => Stmts)));\n-         Analyze (First (Statements (N)));\n+      elsif Is_Empty_List (Stat) then\n+         Rewrite (N, Make_Null_Statement (Loc));\n+         Analyze (N);\n \n       --  For expansion over a static predicate we generate the following\n "}, {"sha": "e7362fdffc0f5a2a4b59d64745b18928a260bdf2", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 179, "deletions": 158, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b", "patch": "@@ -94,16 +94,16 @@ package body Sem_Ch13 is\n      (Typ  : Entity_Id;\n       Expr : Node_Id;\n       Nam  : Name_Id);\n-   --  Given a predicated type Typ, whose predicate expression is Expr, tests\n-   --  if Expr is a static predicate, and if so, builds the predicate range\n-   --  list. Nam is the name of the argument to the predicate function.\n-   --  Occurrences of the type name in the predicate expression have been\n-   --  replaced by identifer references to this name, which is unique, so any\n-   --  identifier with Chars matching Nam must be a reference to the type. If\n-   --  the predicate is non-static, this procedure returns doing nothing. If\n-   --  the predicate is static, then the corresponding predicate list is stored\n-   --  in Static_Predicate (Typ), and the Expr is rewritten as a canonicalized\n-   --  membership operation.\n+   --  Given a predicated type Typ, where Typ is a discrete static subtype,\n+   --  whose predicate expression is Expr, tests if Expr is a static predicate,\n+   --  and if so, builds the predicate range list. Nam is the name of the one\n+   --  argument to the predicate function. Occurrences of the type name in the\n+   --  predicate expression have been replaced by identifer references to this\n+   --  name, which is unique, so any identifier with Chars matching Nam must be\n+   --  a reference to the type. If the predicate is non-static, this procedure\n+   --  returns doing nothing. If the predicate is static, then the predicate\n+   --  list is stored in Static_Predicate (Typ), and the Expr is rewritten as\n+   --  a canonicalized membership operation.\n \n    function Get_Alignment_Value (Expr : Node_Id) return Uint;\n    --  Given the expression for an alignment value, returns the corresponding\n@@ -4045,7 +4045,13 @@ package body Sem_Ch13 is\n \n          --  Deal with static predicate case\n \n-         Build_Static_Predicate (Typ, Expr, Object_Name);\n+         if Ekind_In (Typ, E_Enumeration_Subtype,\n+                           E_Modular_Integer_Subtype,\n+                           E_Signed_Integer_Subtype)\n+           and then Is_Static_Subtype (Typ)\n+         then\n+            Build_Static_Predicate (Typ, Expr, Object_Name);\n+         end if;\n \n          --  Build function declaration\n \n@@ -4115,8 +4121,15 @@ package body Sem_Ch13 is\n       Non_Static : exception;\n       --  Raised if something non-static is found\n \n-      TLo, THi : Uint;\n-      --  Low bound and high bound values of static subtype of Typ\n+      Btyp : constant Entity_Id := Base_Type (Typ);\n+\n+      BLo : constant Uint := Expr_Value (Type_Low_Bound  (Btyp));\n+      BHi : constant Uint := Expr_Value (Type_High_Bound (Btyp));\n+      --  Low bound and high bound value of base type of Typ\n+\n+      TLo : constant Uint := Expr_Value (Type_Low_Bound  (Typ));\n+      THi : constant Uint := Expr_Value (Type_High_Bound (Typ));\n+      --  Low bound and high bound values of static subtype Typ\n \n       type REnt is record\n          Lo, Hi : Uint;\n@@ -4128,15 +4141,20 @@ package body Sem_Ch13 is\n       type RList is array (Nat range <>) of REnt;\n       --  A list of ranges. The ranges are sorted in increasing order,\n       --  and are disjoint (there is a gap of at least one value between\n-      --  each range in the table).\n+      --  each range in the table). A value is in the set of ranges in\n+      --  Rlist if it lies within one of these ranges\n \n-      Null_Range : constant RList := RList'(1 .. 0 => REnt'(No_Uint, No_Uint));\n-      True_Range : RList renames Null_Range;\n-      --  Constant representing null list of ranges, used to represent a\n-      --  predicate of True, since there are no ranges to be satisfied.\n+      False_Range : constant RList :=\n+                      RList'(1 .. 0 => REnt'(No_Uint, No_Uint));\n+      --  An empty set of ranges represents a range list that can never be\n+      --  satisfied, since there are no ranges in which the value could lie,\n+      --  so it does not lie in any of them. False_Range is a canonical value\n+      --  for this empty set, but general processing should test for an Rlist\n+      --  with length zero (see Is_False predicate), since other null ranges\n+      --  may appear which must be treated as False.\n \n-      False_Range : constant RList := RList'(1 => REnt'(Uint_1, Uint_0));\n-      --  Range representing false\n+      True_Range : constant RList := RList'(1 => REnt'(BLo, BHi));\n+      --  Range representing True, value must be in the base range\n \n       function \"and\" (Left, Right : RList) return RList;\n       --  And's together two range lists, returning a range list. This is\n@@ -4153,16 +4171,27 @@ package body Sem_Ch13 is\n \n       function Build_Val (V : Uint) return Node_Id;\n       --  Return an analyzed N_Identifier node referencing this value, suitable\n-      --  for use as an entry in the Static_Predicate list.\n+      --  for use as an entry in the Static_Predicate list. This node is typed\n+      --  with the base type.\n \n       function Build_Range (Lo, Hi : Uint) return Node_Id;\n       --  Return an analyzed N_Range node referencing this range, suitable\n-      --  for use as an entry in the Static_Predicate list.\n+      --  for use as an entry in the Static_Predicate list. This node is typed\n+      --  with the base type.\n \n       function Get_RList (Exp : Node_Id) return RList;\n       --  This is a recursive routine that converts the given expression into\n       --  a list of ranges, suitable for use in building the static predicate.\n \n+      function Is_False (R : RList) return Boolean;\n+      pragma Inline (Is_False);\n+      --  Returns True if the given range list is empty, and thus represents\n+      --  a False list of ranges that can never be satsified.\n+\n+      function Is_True (R : RList) return Boolean;\n+      --  Returns True if R trivially represents the True predicate by having\n+      --  a single range from BLo to BHi.\n+\n       function Is_Type_Ref (N : Node_Id) return Boolean;\n       pragma Inline (Is_Type_Ref);\n       --  Returns if True if N is a reference to the type for the predicate in\n@@ -4207,21 +4236,15 @@ package body Sem_Ch13 is\n       begin\n          --  If either range is True, return the other\n \n-         if Left = True_Range then\n+         if Is_True (Left) then\n             return Right;\n-         elsif Right = True_Range then\n+         elsif Is_True (Right) then\n             return Left;\n          end if;\n \n          --  If either range is False, return False\n \n-         if Left = False_Range or else Right = False_Range then\n-            return False_Range;\n-         end if;\n-\n-         --  If either range is empty, return False\n-\n-         if Left'Length = 0 or else Right'Length = 0 then\n+         if Is_False (Left) or else Is_False (Right) then\n             return False_Range;\n          end if;\n \n@@ -4267,18 +4290,13 @@ package body Sem_Ch13 is\n             SRight := SRight + 1;\n          end if;\n \n-         --  If either operand is empty, that's the only entry\n+         --  Compute result by concatenating this first entry with the \"and\"\n+         --  of the remaining parts of the left and right operands. Note that\n+         --  if either of these is empty, \"and\" will yield empty, so that we\n+         --  will end up with just Fent, which is what we want in that case.\n \n-         if SLeft > Left'Last or else SRight > Right'Last then\n-            return RList'(1 => FEnt);\n-\n-         --  Else compute and of remaining entries and concatenate\n-\n-         else\n-            return\n-              FEnt &\n-                (Left (SLeft .. Left'Last) and Right (SRight .. Right'Last));\n-         end if;\n+         return\n+           FEnt & (Left (SLeft .. Left'Last) and Right (SRight .. Right'Last));\n       end \"and\";\n \n       -----------\n@@ -4289,13 +4307,13 @@ package body Sem_Ch13 is\n       begin\n          --  Return True if False range\n \n-         if Right = False_Range then\n+         if Is_False (Right) then\n             return True_Range;\n          end if;\n \n          --  Return False if True range\n \n-         if Right'Length = 0 then\n+         if Is_True (Right) then\n             return False_Range;\n          end if;\n \n@@ -4340,100 +4358,76 @@ package body Sem_Ch13 is\n       ----------\n \n       function \"or\" (Left, Right : RList) return RList is\n+         FEnt : REnt;\n+         --  First range of result\n+\n+         SLeft : Nat := Left'First;\n+         --  Start of rest of left entries\n+\n+         SRight : Nat := Right'First;\n+         --  Start of rest of right entries\n+\n       begin\n          --  If either range is True, return True\n \n-         if Left = True_Range or else Right = True_Range then\n+         if Is_True (Left) or else Is_True (Right) then\n             return True_Range;\n          end if;\n \n-         --  If either range is False, return the other\n+         --  If either range is False (empty), return the other\n \n-         if Left = False_Range then\n+         if Is_False (Left) then\n             return Right;\n-         elsif Right = False_Range then\n+         elsif Is_False (Right) then\n             return Left;\n          end if;\n \n-         --  If either operand is null, return the other one\n+         --  Initialize result first entry from left or right operand\n+         --  depending on which starts with the lower range.\n \n-         if Left'Length = 0 then\n-            return Right;\n-         elsif Right'Length = 0 then\n-            return Left;\n+         if Left (SLeft).Lo < Right (SRight).Lo then\n+            FEnt := Left (SLeft);\n+            SLeft := SLeft + 1;\n+         else\n+            FEnt := Right (SRight);\n+            SRight := SRight + 1;\n          end if;\n \n-         --  Now we have two non-null ranges\n-\n-         declare\n-            FEnt : REnt;\n-            --  First range of result\n-\n-            SLeft : Nat := Left'First;\n-            --  Start of rest of left entries\n+         --  This loop eats ranges from left and right operands that\n+         --  are contiguous with the first range we are gathering.\n \n-            SRight : Nat := Right'First;\n-            --  Start of rest of right entries\n-\n-         begin\n-            --  Initialize result first entry from left or right operand\n-            --  depending on which starts with the lower range.\n+         loop\n+            --  Eat first entry in left operand if contiguous or\n+            --  overlapped by gathered first operand of result.\n \n-            if Left (SLeft).Lo < Right (SRight).Lo then\n-               FEnt := Left (SLeft);\n+            if SLeft <= Left'Last\n+              and then Left (SLeft).Lo <= FEnt.Hi + 1\n+            then\n+               FEnt.Hi := UI_Max (FEnt.Hi, Left (SLeft).Hi);\n                SLeft := SLeft + 1;\n-            else\n-               FEnt := Right (SRight);\n-               SRight := SRight + 1;\n-            end if;\n-\n-            --  This loop eats ranges from left and right operands that\n-            --  are contiguous with the first range we are gathering.\n-\n-            loop\n-               --  Eat first entry in left operand if contiguous or\n-               --  overlapped by gathered first operand of result.\n-\n-               if SLeft <= Left'Last\n-                 and then Left (SLeft).Lo <= FEnt.Hi + 1\n-               then\n-                  FEnt.Hi := UI_Max (FEnt.Hi, Left (SLeft).Hi);\n-                  SLeft := SLeft + 1;\n \n                --  Eat first entry in right operand if contiguous or\n                --  overlapped by gathered right operand of result.\n \n-               elsif SRight <= Right'Last\n-                 and then Right (SRight).Lo <= FEnt.Hi + 1\n-               then\n-                  FEnt.Hi := UI_Max (FEnt.Hi, Right (SRight).Hi);\n-                  SRight := SRight + 1;\n+            elsif SRight <= Right'Last\n+              and then Right (SRight).Lo <= FEnt.Hi + 1\n+            then\n+               FEnt.Hi := UI_Max (FEnt.Hi, Right (SRight).Hi);\n+               SRight := SRight + 1;\n \n                --  All done if no more entries to eat!\n \n-               else\n-                  exit;\n-               end if;\n-            end loop;\n-\n-            --  If left operand now empty, concatenate our new entry to right\n-\n-            if SLeft > Left'Last then\n-               return FEnt & Right (SRight .. Right'Last);\n-\n-            --  If right operand now empty, concatenate our new entry to left\n-\n-            elsif SRight > Right'Last then\n-               return FEnt & Left (SLeft .. Left'Last);\n-\n-            --  Otherwise, compute or of what is left and concatenate\n-\n             else\n-               return\n-                 FEnt &\n-                  (Left (SLeft .. Left'Last) or Right (SRight .. Right'Last));\n+               exit;\n             end if;\n-         end;\n+         end loop;\n+\n+         --  Obtain result as the first entry we just computed, concatenated\n+         --  to the \"or\" of the remaining results (if one operand is empty,\n+         --  this will just concatenate with the other\n+\n+         return\n+           FEnt & (Left (SLeft .. Left'Last) or Right (SRight .. Right'Last));\n       end \"or\";\n \n       -----------------\n@@ -4450,7 +4444,7 @@ package body Sem_Ch13 is\n               Make_Range (Loc,\n                 Low_Bound  => Build_Val (Lo),\n                 High_Bound => Build_Val (Hi));\n-            Set_Etype (Result, Typ);\n+            Set_Etype (Result, Btyp);\n             Set_Analyzed (Result);\n             return Result;\n          end if;\n@@ -4470,7 +4464,7 @@ package body Sem_Ch13 is\n             Result := Make_Integer_Literal (Loc, Intval => V);\n          end if;\n \n-         Set_Etype (Result, Typ);\n+         Set_Etype (Result, Btyp);\n          Set_Is_Static_Expression (Result);\n          Set_Analyzed (Result);\n          return Result;\n@@ -4489,15 +4483,12 @@ package body Sem_Ch13 is\n \n          if Is_OK_Static_Expression (Exp) then\n \n-            --  For False, return impossible range, which will always fail\n+            --  For False\n \n             if Expr_Value (Exp) = 0 then\n                return False_Range;\n-\n-            --  For True, null range\n-\n             else\n-               return Null_Range;\n+               return True_Range;\n             end if;\n          end if;\n \n@@ -4566,20 +4557,20 @@ package body Sem_Ch13 is\n                      return RList'(1 => REnt'(Val, Val));\n \n                   when N_Op_Ge =>\n-                     return RList'(1 => REnt'(Val, THi));\n+                     return RList'(1 => REnt'(Val, BHi));\n \n                   when N_Op_Gt =>\n-                     return RList'(1 => REnt'(Val + 1, THi));\n+                     return RList'(1 => REnt'(Val + 1, BHi));\n \n                   when N_Op_Le =>\n-                     return RList'(1 => REnt'(TLo, Val));\n+                     return RList'(1 => REnt'(BLo, Val));\n \n                   when N_Op_Lt =>\n-                     return RList'(1 => REnt'(TLo, Val - 1));\n+                     return RList'(1 => REnt'(BLo, Val - 1));\n \n                   when N_Op_Ne =>\n-                     return RList'(REnt'(TLo, Val - 1),\n-                                   REnt'(Val + 1, THi));\n+                     return RList'(REnt'(BLo, Val - 1),\n+                                   REnt'(Val + 1, BHi));\n \n                   when others  =>\n                      raise Program_Error;\n@@ -4633,6 +4624,14 @@ package body Sem_Ch13 is\n             when N_Qualified_Expression =>\n                return Get_RList (Expression (Exp));\n \n+            --  Xor operator\n+\n+            when N_Op_Xor =>\n+               return (Get_RList (Left_Opnd (Exp))\n+                        and not Get_RList (Right_Opnd (Exp)))\n+                 or   (Get_RList (Right_Opnd (Exp))\n+                        and not Get_RList (Left_Opnd (Exp)));\n+\n             --  Any other node type is non-static\n \n             when others =>\n@@ -4654,6 +4653,26 @@ package body Sem_Ch13 is\n          end if;\n       end Hi_Val;\n \n+      --------------\n+      -- Is_False --\n+      --------------\n+\n+      function Is_False (R : RList) return Boolean is\n+      begin\n+         return R'Length = 0;\n+      end Is_False;\n+\n+      -------------\n+      -- Is_True --\n+      -------------\n+\n+      function Is_True (R : RList) return Boolean is\n+      begin\n+         return R'Length = 1\n+           and then R (R'First).Lo = BLo\n+           and then R (R'First).Hi = BHi;\n+      end Is_True;\n+\n       -----------------\n       -- Is_Type_Ref --\n       -----------------\n@@ -4789,22 +4808,6 @@ package body Sem_Ch13 is\n    --  Start of processing for Build_Static_Predicate\n \n    begin\n-      --  Immediately non-static if our subtype is non static, or we\n-      --  do not have an appropriate discrete subtype in the first place.\n-\n-      if not Ekind_In (Typ, E_Enumeration_Subtype,\n-                            E_Modular_Integer_Subtype,\n-                            E_Signed_Integer_Subtype)\n-        or else not Is_Static_Subtype (Typ)\n-      then\n-         return;\n-      end if;\n-\n-      --  Get bounds of the type\n-\n-      TLo := Expr_Value (Type_Low_Bound  (Typ));\n-      THi := Expr_Value (Type_High_Bound (Typ));\n-\n       --  Now analyze the expression to see if it is a static predicate\n \n       declare\n@@ -4818,18 +4821,45 @@ package body Sem_Ch13 is\n          --  Ranges array, we just have raw ranges, these must be converted\n          --  to properly typed and analyzed static expressions or range nodes.\n \n+         --  Note: here we limit ranges to the ranges of the subtype, so that\n+         --  a predicate is always false for values outside the subtype. That\n+         --  seems fine, such values are invalid anyway, and considering them\n+         --  to fail the predicate seems allowed and friendly, and furthermore\n+         --  simplifies processing for case statements and loops.\n+\n          Plist := New_List;\n \n          for J in Ranges'Range loop\n             declare\n-               Lo : constant Uint := Ranges (J).Lo;\n-               Hi : constant Uint := Ranges (J).Hi;\n+               Lo : Uint := Ranges (J).Lo;\n+               Hi : Uint := Ranges (J).Hi;\n \n             begin\n-               if Lo = Hi then\n-                  Append_To (Plist, Build_Val (Lo));\n+               --  Ignore completely out of range entry\n+\n+               if Hi < TLo or else Lo > THi then\n+                  null;\n+\n+                  --  Otherwise process entry\n+\n                else\n-                  Append_To (Plist, Build_Range (Lo, Hi));\n+                  --  Adjust out of range value to subtype range\n+\n+                  if Lo < TLo then\n+                     Lo := TLo;\n+                  end if;\n+\n+                  if Hi > THi then\n+                     Hi := THi;\n+                  end if;\n+\n+                  --  Convert range into required form\n+\n+                  if Lo = Hi then\n+                     Append_To (Plist, Build_Val (Lo));\n+                  else\n+                     Append_To (Plist, Build_Range (Lo, Hi));\n+                  end if;\n                end if;\n             end;\n          end loop;\n@@ -4865,21 +4895,12 @@ package body Sem_Ch13 is\n                Next (Old_Node);\n             end loop;\n \n-            --  If empty list, replace by True\n+            --  If empty list, replace by False\n \n             if Is_Empty_List (New_Alts) then\n-               Rewrite (Expr, New_Occurrence_Of (Standard_True, Loc));\n-\n-            --  If singleton list, replace by simple membership test\n-\n-            elsif List_Length (New_Alts) = 1 then\n-               Rewrite (Expr,\n-                 Make_In (Loc,\n-                   Left_Opnd    => Make_Identifier (Loc, Nam),\n-                   Right_Opnd   => Relocate_Node (First (New_Alts)),\n-                   Alternatives => No_List));\n+               Rewrite (Expr, New_Occurrence_Of (Standard_False, Loc));\n \n-            --  If more than one range, replace by set membership test\n+            --  Else replace by set membership test\n \n             else\n                Rewrite (Expr,"}, {"sha": "6a0aa06e0a08f6fed48289c523af2d18d6f41572", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b", "patch": "@@ -2440,9 +2440,8 @@ package body Sem_Ch4 is\n             end loop;\n          end if;\n \n-      --  If not a range, it can be a subtype mark, or else it is\n-      --  a degenerate membership test with a singleton value, i.e.\n-      --  a test for equality.\n+      --  If not a range, it can be a subtype mark, or else it is a degenerate\n+      --  membership test with a singleton value, i.e. a test for equality.\n \n       else\n          Analyze (R);\n@@ -2469,8 +2468,8 @@ package body Sem_Ch4 is\n             return;\n \n          else\n-            --  in previous version of the language this is an error\n-            --  that will be diagnosed below.\n+            --  In previous version of the language this is an error that will\n+            --  be diagnosed below.\n \n             Find_Type (R);\n          end if;"}, {"sha": "0aaa426ece6fddd8dd7154a0cf8cc819b83e47cd", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b", "patch": "@@ -5479,6 +5479,11 @@ package body Sem_Ch8 is\n \n             Analyze_Selected_Component (N);\n \n+         --  Reference to type name in predicate/invariant expression\n+\n+         elsif OK_To_Reference (Etype (P)) then\n+            Analyze_Selected_Component (N);\n+\n          elsif Is_Appropriate_For_Entry_Prefix (P_Type)\n            and then not In_Open_Scopes (P_Name)\n            and then (not Is_Concurrent_Type (Etype (P_Name))\n@@ -5490,10 +5495,10 @@ package body Sem_Ch8 is\n             Analyze_Selected_Component (N);\n \n          elsif (In_Open_Scopes (P_Name)\n-                  and then Ekind (P_Name) /= E_Void\n-                  and then not Is_Overloadable (P_Name))\n+                 and then Ekind (P_Name) /= E_Void\n+                 and then not Is_Overloadable (P_Name))\n            or else (Is_Concurrent_Type (Etype (P_Name))\n-                      and then In_Open_Scopes (Etype (P_Name)))\n+                     and then In_Open_Scopes (Etype (P_Name)))\n          then\n             --  Prefix denotes an enclosing loop, block, or task, i.e. an\n             --  enclosing construct that is not a subprogram or accept.\n@@ -5508,8 +5513,7 @@ package body Sem_Ch8 is\n             --  The subprogram may be a renaming (of an enclosing scope) as\n             --  in the case of the name of the generic within an instantiation.\n \n-            if (Ekind (P_Name) = E_Procedure\n-                 or else Ekind (P_Name) = E_Function)\n+            if Ekind_In (P_Name, E_Procedure, E_Function)\n               and then Present (Alias (P_Name))\n               and then Is_Generic_Instance (Alias (P_Name))\n             then"}, {"sha": "322c168ee6d90c76f5276fd720e41d656f0f35b2", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b", "patch": "@@ -1226,7 +1226,7 @@ package body Sem_Util is\n          return;\n       end if;\n \n-      --  Ada 2012 AI04-0144-2 : dangerous order dependence. Actuals in nested\n+      --  Ada 2012 AI04-0144-2: Dangerous order dependence. Actuals in nested\n       --  calls within a construct have been collected. If one of them is\n       --  writable and overlaps with another one, evaluation of the enclosing\n       --  construct is nondeterministic. This is illegal in Ada 2012, but is\n@@ -1278,6 +1278,7 @@ package body Sem_Util is\n \n    procedure Check_Potentially_Blocking_Operation (N : Node_Id) is\n       S : Entity_Id;\n+\n    begin\n       --  N is one of the potentially blocking operations listed in 9.5.1(8).\n       --  When pragma Detect_Blocking is active, the run time will raise\n@@ -1294,7 +1295,6 @@ package body Sem_Util is\n          if Is_Protected_Type (S) then\n             Error_Msg_N\n               (\"potentially blocking operation in protected operation?\", N);\n-\n             return;\n          end if;\n "}]}