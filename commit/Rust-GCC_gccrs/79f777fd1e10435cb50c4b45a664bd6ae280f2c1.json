{"sha": "79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlmNzc3ZmQxZTEwNDM1Y2I1MGM0YjQ1YTY2NGJkNmFlMjgwZjJjMQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@waitaki.otago.ac.nz", "date": "2002-02-12T04:37:57Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2002-02-12T04:37:57Z"}, "message": "Imported GC 6.1 Alpha 3. Finally.\n\nFrom-SVN: r49698", "tree": {"sha": "cef3197531d988920cbff060bdc10742baf06d01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cef3197531d988920cbff060bdc10742baf06d01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/comments", "author": null, "committer": null, "parents": [{"sha": "005326029f35b4271c5274114a17126039fe18a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/005326029f35b4271c5274114a17126039fe18a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/005326029f35b4271c5274114a17126039fe18a0"}], "stats": {"total": 1795, "additions": 1285, "deletions": 510}, "files": [{"sha": "8f724c280c0cfbb4c2d7bcba24731eccc9a53c4a", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -1,6 +1,10 @@\n+2002-02-12  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\tImported GC 6.1 Alpha 3.\n+\n 2001-02-11  Adam Megacz <adam@xwt.org\n \n-        * gcc/boehm-gc/configure.in: support for win32, saner\n+\t* gcc/boehm-gc/configure.in: support for win32, saner\n \tcross-compile options\n \n 2001-02-08  Anthony Green  <green@redhat.com>\n@@ -16,13 +20,13 @@\n \n 2002-02-06  Adam Megacz <adam@xwt.org>\n \n-        * boehm-gc/include/gc.h: (GC_CreateThread) This function is\n-        now exposed on all Win32 platforms.\n-        * boehm-gc/win32_threads.c: (GC_CreateThread) This now\n-        compiles on Win32; it invokes CreateThread() if GC is built\n-        as a DLL; otherwise it registers the thread.\n-        * boehm-gc/misc.c (GC_init): Initialize GC_allocate_ml in case\n-        libgcjgc was not built as a DLL.\n+\t* boehm-gc/include/gc.h: (GC_CreateThread) This function is\n+\tnow exposed on all Win32 platforms.\n+\t* boehm-gc/win32_threads.c: (GC_CreateThread) This now\n+\tcompiles on Win32; it invokes CreateThread() if GC is built\n+\tas a DLL; otherwise it registers the thread.\n+\t* boehm-gc/misc.c (GC_init): Initialize GC_allocate_ml in case\n+\tlibgcjgc was not built as a DLL.\n \n 2002-02-01  Adam Megacz <adam@xwt.org>\n "}, {"sha": "40970729f447f41e08c7d969b5782c67439dcd85", "filename": "boehm-gc/Makefile.am", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.am?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -6,8 +6,6 @@\n \n AUTOMAKE_OPTIONS = cygnus\n \n-SUBDIRS = include\n-\n # Multilib support variables.\n MULTISRCTOP =\n MULTIBUILDTOP =\n@@ -31,7 +29,8 @@ libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \\\n dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c irix_threads.c \\\n linux_threads.c malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \\\n obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \\\n-solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c\n+solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c \\\n+backgraph.c\n \n # Include THREADLIBS here to ensure that the correct versions of\n # linuxthread semaphore functions get linked:"}, {"sha": "af6192ebc455b6a654f5bd22c6543284a5ac6571", "filename": "boehm-gc/Makefile.direct", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2FMakefile.direct", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2FMakefile.direct", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.direct?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -10,20 +10,13 @@\n #\t c++ interface to gc.a\n # cord/de - builds dumb editor based on cords.\n ABI_FLAG= \n-# ABI_FLAG should be the cc flag that specifies the ABI.  On most\n-# platforms this will be the empty string.  Possible values:\n-# +DD64 for 64-bit executable on HP/UX.\n-# -n32, -n64, -o32 for SGI/MIPS ABIs.\n-\n-AS_ABI_FLAG=$(ABI_FLAG)\n-# ABI flag for assembler.  On HP/UX this is +A64 for 64 bit\n-# executables.\n-\n CC=cc $(ABI_FLAG)\n CXX=g++ $(ABI_FLAG)\n-AS=as $(AS_ABI_FLAG)\n+AS=as $(ABI_FLAG)\n #  The above doesn't work with gas, which doesn't run cpp.\n #  Define AS as `gcc -c -x assembler-with-cpp' instead.\n+#  Under Irix 6, you will have to specify the ABI (-o32, -n32, or -64)\n+#  if you use something other than the default ABI on your machine.\n \n # Redefining srcdir allows object code for the nonPCR version of the collector\n # to be generated in different directories.\n@@ -61,15 +54,12 @@ HOSTCFLAGS=$(CFLAGS)\n #   gc.h before performing thr_ or dl* or GC_ operations.)\n #   Must also define -D_REENTRANT.\n # -DGC_SOLARIS_PTHREADS enables support for Solaris pthreads.\n-#   (Internally this define GC_SOLARIS_THREADS as well.)\n+#   Define SOLARIS_THREADS as well.\n # -DGC_IRIX_THREADS enables support for Irix pthreads.  See README.irix.\n # -DGC_HPUX_THREADS enables support for HP/UX 11 pthreads.\n #   Also requires -D_REENTRANT or -D_POSIX_C_SOURCE=199506L. See README.hp.\n # -DGC_LINUX_THREADS enables support for Xavier Leroy's Linux threads.\n #   see README.linux.  -D_REENTRANT may also be required.\n-# -DGC_OSF1_THREADS enables support for Tru64 pthreads.  Untested.\n-# -DGC_FREEBSD_THREADS enables support for FreeBSD pthreads.  Untested.\n-#   Appeared to run into some underlying thread problems.\n # -DALL_INTERIOR_POINTERS allows all pointers to the interior\n #   of objects to be recognized.  (See gc_priv.h for consequences.)\n #   Alternatively, GC_all_interior_pointers can be set at process\n@@ -207,8 +197,8 @@ HOSTCFLAGS=$(CFLAGS)\n #   15% or so.\n # -DUSE_3DNOW_PREFETCH causes the collector to issue AMD 3DNow style\n #   prefetch instructions.  Same restrictions as USE_I686_PREFETCH.\n-#   Minimally tested.  Didn't appear to be an obvious win on a K6-2/500.\n-# -DGC_USE_LD_WRAP in combination with the old flags listed in README.linux\n+#   UNTESTED!!\n+# -DGC_USE_LD_WRAP in combination with the gld flags listed in README.linux\n #   causes the collector some system and pthread calls in a more transparent\n #   fashion than the usual macro-based approach.  Requires GNU ld, and\n #   currently probably works only with Linux.\n@@ -266,8 +256,7 @@ SRCS= $(CSRCS) mips_sgi_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.s \\\n     include/gc_local_alloc.h include/private/dbg_mlc.h \\\n     include/private/specific.h powerpc_macosx_mach_dep.s \\\n     include/leak_detector.h include/gc_amiga_redirects.h \\\n-    include/gc_pthread_redirects.h ia64_save_regs_in_stack.s \\\n-    $(CORD_SRCS)\n+    include/gc_pthread_redirects.h $(CORD_SRCS)\n \n DOC_FILES= README.QUICK doc/README.Mac doc/README.MacOSX doc/README.OS2 \\\n \tdoc/README.amiga doc/README.cords doc/debugging.html \\"}, {"sha": "4460d67289bd382b4f25189cbceb81528023ced3", "filename": "boehm-gc/Makefile.in", "status": "modified", "additions": 77, "deletions": 110, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.in?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -96,22 +96,25 @@ target_all = @target_all@\n \n AUTOMAKE_OPTIONS = cygnus\n \n-SUBDIRS = include\n-\n # Multilib support variables.\n MULTISRCTOP = \n MULTIBUILDTOP = \n MULTIDIRS = \n MULTISUBDIR = \n MULTIDO = true\n MULTICLEAN = true\n-@USE_LIBDIR_TRUE@toolexeclibdir = $(libdir)$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexeclibdir = $(toolexecdir)/lib$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexecdir = $(exec_prefix)/$(target_alias)\n+@USE_LIBDIR_TRUE@toolexeclibdir = @USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexeclibdir = @USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexecdir = @USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n \n toolexeclib_LTLIBRARIES = $(target_all)\n EXTRA_LTLIBRARIES = libgcjgc.la\n-libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c irix_threads.c linux_threads.c malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c\n+libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \\\n+dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c irix_threads.c \\\n+linux_threads.c malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \\\n+obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \\\n+solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c \\\n+backgraph.c\n \n \n # Include THREADLIBS here to ensure that the correct versions of\n@@ -120,7 +123,10 @@ libgcjgc_la_LIBADD = @addobjs@ $(THREADLIBS)\n libgcjgc_la_DEPENDENCIES = @addobjs@\n libgcjgc_la_LDFLAGS = -version-info 1:1:0 -rpath $(toolexeclibdir)\n \n-EXTRA_libgcjgc_la_SOURCES = alpha_mach_dep.s mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_macosx_mach_dep.s rs6000_mach_dep.s sparc_mach_dep.s sparc_netbsd_mach_dep.s sparc_sunos4_mach_dep.s ia64_save_regs_in_stack.s\n+EXTRA_libgcjgc_la_SOURCES = alpha_mach_dep.s \\\n+mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_macosx_mach_dep.s \\\n+rs6000_mach_dep.s sparc_mach_dep.s sparc_netbsd_mach_dep.s \\\n+sparc_sunos4_mach_dep.s ia64_save_regs_in_stack.s\n \n \n AM_CXXFLAGS = @GC_CFLAGS@\n@@ -138,14 +144,52 @@ TESTS = gctest\n \n all_objs = @addobjs@ $(libgcjgc_la_OBJECTS)\n \n-LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(INCLUDES) \t$(AM_CPPFLAGS) $(CPPFLAGS) \t$(AM_CFLAGS) $(MY_CFLAGS) $(GC_CFLAGS) \n+LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) \\\n+\t$(AM_CFLAGS) $(MY_CFLAGS) $(GC_CFLAGS) \n \n LINK = $(LIBTOOL) --mode=link $(CC) $(AM_CFLAGS) $(MY_CFLAGS) $(LDFLAGS) -o $@\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and\n # friends when we are called from the top level Makefile.\n-AM_MAKEFLAGS =  \t\"AR_FLAGS=$(AR_FLAGS)\" \t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \t\"CFLAGS=$(CFLAGS)\" \t\"CXXFLAGS=$(CXXFLAGS)\" \t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \t\"INSTALL=$(INSTALL)\" \t\"INSTALL_DATA=$(INSTALL_DATA)\" \t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \t\"LDFLAGS=$(LDFLAGS)\" \t\"LIBCFLAGS=$(LIBCFLAGS)\" \t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \t\"MAKE=$(MAKE)\" \t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \t\"PICFLAG=$(PICFLAG)\" \t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \t\"SHELL=$(SHELL)\" \t\"EXPECT=$(EXPECT)\" \t\"RUNTEST=$(RUNTEST)\" \t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \t\"exec_prefix=$(exec_prefix)\" \t\"infodir=$(infodir)\" \t\"libdir=$(libdir)\" \t\"prefix=$(prefix)\" \t\"tooldir=$(tooldir)\" \t\"AR=$(AR)\" \t\"AS=$(AS)\" \t\"CC=$(CC)\" \t\"CXX=$(CXX)\" \t\"LD=$(LD)\" \t\"LIBCFLAGS=$(LIBCFLAGS)\" \t\"NM=$(NM)\" \t\"PICFLAG=$(PICFLAG)\" \t\"RANLIB=$(RANLIB)\" \t\"DESTDIR=$(DESTDIR)\"\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"EXPECT=$(EXPECT)\" \\\n+\t\"RUNTEST=$(RUNTEST)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"tooldir=$(tooldir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"CC=$(CC)\" \\\n+\t\"CXX=$(CXX)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n \n \n CONFIG_STATUS_DEPENDENCIES = $(srcdir)/configure.host\n@@ -165,7 +209,7 @@ dbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo headers.lo \\\n irix_threads.lo linux_threads.lo malloc.lo mallocx.lo mark.lo \\\n mark_rts.lo misc.lo new_hblk.lo obj_map.lo os_dep.lo pcr_interface.lo \\\n ptr_chck.lo real_malloc.lo reclaim.lo solaris_pthreads.lo \\\n-solaris_threads.lo specific.lo stubborn.lo typd_mlc.lo\n+solaris_threads.lo specific.lo stubborn.lo typd_mlc.lo backgraph.lo\n check_PROGRAMS =  gctest$(EXEEXT)\n gctest_DEPENDENCIES =  ./libgcjgc.la\n CFLAGS = @CFLAGS@\n@@ -283,61 +327,6 @@ gctest$(EXEEXT): $(gctest_OBJECTS) $(gctest_DEPENDENCIES)\n \t@rm -f gctest$(EXEEXT)\n \t$(LINK) $(gctest_LDFLAGS) $(gctest_OBJECTS) $(gctest_LDADD) $(LIBS)\n \n-# This directory's subdirectories are mostly independent; you can cd\n-# into them and run `make' without going through this Makefile.\n-# To change the values of `make' variables: instead of editing Makefiles,\n-# (1) if the variable is set in `config.status', edit `config.status'\n-#     (which will cause the Makefiles to be regenerated when you run `make');\n-# (2) otherwise, pass the desired values on the `make' command line.\n-\n-@SET_MAKE@\n-\n-all-recursive install-data-recursive install-exec-recursive \\\n-installdirs-recursive install-recursive uninstall-recursive install-info-recursive \\\n-check-recursive installcheck-recursive info-recursive dvi-recursive:\n-\t@set fnord $(MAKEFLAGS); amf=$$2; \\\n-\tdot_seen=no; \\\n-\ttarget=`echo $@ | sed s/-recursive//`; \\\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  echo \"Making $$target in $$subdir\"; \\\n-\t  if test \"$$subdir\" = \".\"; then \\\n-\t    dot_seen=yes; \\\n-\t    local_target=\"$$target-am\"; \\\n-\t  else \\\n-\t    local_target=\"$$target\"; \\\n-\t  fi; \\\n-\t  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n-\t   || case \"$$amf\" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \\\n-\tdone; \\\n-\tif test \"$$dot_seen\" = \"no\"; then \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n-\tfi; test -z \"$$fail\"\n-\n-mostlyclean-recursive clean-recursive distclean-recursive \\\n-maintainer-clean-recursive:\n-\t@set fnord $(MAKEFLAGS); amf=$$2; \\\n-\tdot_seen=no; \\\n-\trev=''; list='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  rev=\"$$subdir $$rev\"; \\\n-\t  test \"$$subdir\" = \".\" && dot_seen=yes; \\\n-\tdone; \\\n-\ttest \"$$dot_seen\" = \"no\" && rev=\". $$rev\"; \\\n-\ttarget=`echo $@ | sed s/-recursive//`; \\\n-\tfor subdir in $$rev; do \\\n-\t  echo \"Making $$target in $$subdir\"; \\\n-\t  if test \"$$subdir\" = \".\"; then \\\n-\t    local_target=\"$$target-am\"; \\\n-\t  else \\\n-\t    local_target=\"$$target\"; \\\n-\t  fi; \\\n-\t  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n-\t   || case \"$$amf\" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \\\n-\tdone && test -z \"$$fail\"\n-tags-recursive:\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  test \"$$subdir\" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \\\n-\tdone\n-\n tags: TAGS\n \n ID: $(HEADERS) $(SOURCES) $(LISP)\n@@ -348,14 +337,9 @@ ID: $(HEADERS) $(SOURCES) $(LISP)\n \there=`pwd` && cd $(srcdir) \\\n \t  && mkid -f$$here/ID $$unique $(LISP)\n \n-TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) $(LISP)\n+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) $(LISP)\n \ttags=; \\\n \there=`pwd`; \\\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-   if test \"$$subdir\" = .; then :; else \\\n-\t    test -f $$subdir/TAGS && tags=\"$$tags -i $$here/$$subdir/TAGS\"; \\\n-   fi; \\\n-\tdone; \\\n \tlist='$(SOURCES) $(HEADERS)'; \\\n \tunique=`for i in $$list; do echo $$i; done | \\\n \t  awk '    { files[$$0] = 1; } \\\n@@ -420,16 +404,6 @@ distdir: $(DISTFILES)\n \t    || cp -p $$d/$$file $(distdir)/$$file || :; \\\n \t  fi; \\\n \tdone\n-\tfor subdir in $(SUBDIRS); do \\\n-\t  if test \"$$subdir\" = .; then :; else \\\n-\t    test -d $(distdir)/$$subdir \\\n-\t    || mkdir $(distdir)/$$subdir \\\n-\t    || exit 1; \\\n-\t    chmod 777 $(distdir)/$$subdir; \\\n-\t    (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir=../$(distdir) distdir=../$(distdir)/$$subdir distdir) \\\n-\t      || exit 1; \\\n-\t  fi; \\\n-\tdone\n check-TESTS: $(TESTS)\n \t@failed=0; all=0; \\\n \tsrcdir=$(srcdir); export srcdir; \\\n@@ -456,33 +430,32 @@ check-TESTS: $(TESTS)\n \techo \"$$dashes\"; \\\n \ttest \"$$failed\" -eq 0\n info-am:\n-info: info-recursive\n+info: info-am\n dvi-am:\n-dvi: dvi-recursive\n+dvi: dvi-am\n check-am: $(check_PROGRAMS)\n \t$(MAKE) $(AM_MAKEFLAGS) check-TESTS\n-check: check-recursive\n+check: check-am\n installcheck-am:\n-installcheck: installcheck-recursive\n+installcheck: installcheck-am\n install-info-am: \n-install-info: install-info-recursive\n+install-info: install-info-am\n install-exec-am: install-toolexeclibLTLIBRARIES\n-install-exec: install-exec-recursive\n+install-exec: install-exec-am\n \n install-data-am:\n-install-data: install-data-recursive\n+install-data: install-data-am\n \n install-am: all-am\n \t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-install: install-recursive\n+install: install-am\n uninstall-am: uninstall-toolexeclibLTLIBRARIES\n-uninstall: uninstall-recursive\n+uninstall: uninstall-am\n all-am: Makefile $(LTLIBRARIES)\n-all-redirect: all-recursive\n+all-redirect: all-am\n install-strip:\n \t$(MAKE) $(AM_MAKEFLAGS) AM_INSTALL_PROGRAM_FLAGS=-s install\n-installdirs: installdirs-recursive\n-installdirs-am:\n+installdirs:\n \t$(mkinstalldirs)  $(DESTDIR)$(toolexeclibdir)\n \n \n@@ -499,20 +472,20 @@ mostlyclean-am:  mostlyclean-toolexeclibLTLIBRARIES mostlyclean-compile \\\n \t\tmostlyclean-libtool mostlyclean-checkPROGRAMS \\\n \t\tmostlyclean-tags mostlyclean-generic\n \n-mostlyclean: mostlyclean-recursive\n+mostlyclean: mostlyclean-am\n \n clean-am:  clean-toolexeclibLTLIBRARIES clean-compile clean-libtool \\\n \t\tclean-checkPROGRAMS clean-tags clean-generic \\\n \t\tmostlyclean-am\n \n-clean: clean-recursive\n+clean: clean-am\n \n distclean-am:  distclean-toolexeclibLTLIBRARIES distclean-compile \\\n \t\tdistclean-libtool distclean-checkPROGRAMS \\\n \t\tdistclean-tags distclean-generic clean-am\n \t-rm -f libtool\n \n-distclean: distclean-recursive\n+distclean: distclean-am\n \t-rm -f config.status\n \n maintainer-clean-am:  maintainer-clean-toolexeclibLTLIBRARIES \\\n@@ -522,7 +495,7 @@ maintainer-clean-am:  maintainer-clean-toolexeclibLTLIBRARIES \\\n \t@echo \"This command is intended for maintainers to use;\"\n \t@echo \"it deletes files that may require special tools to rebuild.\"\n \n-maintainer-clean: maintainer-clean-recursive\n+maintainer-clean: maintainer-clean-am\n \t-rm -f config.status\n \n .PHONY: mostlyclean-toolexeclibLTLIBRARIES \\\n@@ -533,19 +506,13 @@ mostlyclean-compile distclean-compile clean-compile \\\n maintainer-clean-compile mostlyclean-libtool distclean-libtool \\\n clean-libtool maintainer-clean-libtool mostlyclean-checkPROGRAMS \\\n distclean-checkPROGRAMS clean-checkPROGRAMS \\\n-maintainer-clean-checkPROGRAMS install-data-recursive \\\n-uninstall-data-recursive install-exec-recursive \\\n-uninstall-exec-recursive installdirs-recursive uninstalldirs-recursive \\\n-all-recursive check-recursive installcheck-recursive info-recursive \\\n-dvi-recursive mostlyclean-recursive distclean-recursive clean-recursive \\\n-maintainer-clean-recursive tags tags-recursive mostlyclean-tags \\\n-distclean-tags clean-tags maintainer-clean-tags distdir check-TESTS \\\n-info-am info dvi-am dvi check check-am installcheck-am installcheck \\\n-install-info-am install-info install-exec-am install-exec \\\n-install-data-am install-data install-am install uninstall-am uninstall \\\n-all-redirect all-am all installdirs-am installdirs mostlyclean-generic \\\n-distclean-generic clean-generic maintainer-clean-generic clean \\\n-mostlyclean distclean maintainer-clean\n+maintainer-clean-checkPROGRAMS tags mostlyclean-tags distclean-tags \\\n+clean-tags maintainer-clean-tags distdir check-TESTS info-am info \\\n+dvi-am dvi check check-am installcheck-am installcheck install-info-am \\\n+install-info install-exec-am install-exec install-data-am install-data \\\n+install-am install uninstall-am uninstall all-redirect all-am all \\\n+installdirs mostlyclean-generic distclean-generic clean-generic \\\n+maintainer-clean-generic clean mostlyclean distclean maintainer-clean\n \n # The following hack produces a warning from automake, but we need it in order \n # to build a file from a subdirectory. FIXME."}, {"sha": "3da58c4ca0cb5f0987b87bdf3dc49ce927926603", "filename": "boehm-gc/allchblk.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fallchblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fallchblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fallchblk.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -86,7 +86,6 @@ word blocks_needed;\n     \n }\n \n-# define HBLK_IS_FREE(hdr) ((hdr) -> hb_map == GC_invalid_map)\n # define PHDR(hhdr) HDR(hhdr -> hb_prev)\n # define NHDR(hhdr) HDR(hhdr -> hb_next)\n \n@@ -719,9 +718,6 @@ int n;\n \n     if (0 == hbp) return 0;\n \t\n-    /* Notify virtual dirty bit implementation that we are about to write. */\n-    \tGC_write_hint(hbp);\n-    \n     /* Add it to map of valid blocks */\n     \tif (!GC_install_counts(hbp, (word)size_needed)) return(0);\n     \t/* This leaks memory under very rare conditions. */\n@@ -731,6 +727,11 @@ int n;\n             GC_remove_counts(hbp, (word)size_needed);\n             return(0); /* ditto */\n         }\n+\n+    /* Notify virtual dirty bit implementation that we are about to write.  */\n+    /* Ensure that pointerfree objects are not protected if it's avoidable. */\n+    \tGC_remove_protection(hbp, divHBLKSZ(size_needed),\n+\t\t\t     (hhdr -> hb_descr == 0) /* pointer-free */);\n         \n     /* We just successfully allocated a block.  Restart count of\t*/\n     /* consecutive failures.\t\t\t\t\t\t*/"}, {"sha": "8a413b275f88087c5e3028e2108bbdd3c1abeb27", "filename": "boehm-gc/alloc.c", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Falloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Falloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Falloc.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -78,7 +78,7 @@ char * GC_copyright[] =\n {\"Copyright 1988,1989 Hans-J. Boehm and Alan J. Demers \",\n \"Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved. \",\n \"Copyright (c) 1996-1998 by Silicon Graphics.  All rights reserved. \",\n-\"Copyright (c) 1999-2000 by Hewlett-Packard Company.  All rights reserved. \",\n+\"Copyright (c) 1999-2001 by Hewlett-Packard Company.  All rights reserved. \",\n \"THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY\",\n \" EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\",\n \"See source code for details.\" };\n@@ -97,13 +97,17 @@ word GC_free_space_divisor = 3;\n extern GC_bool GC_collection_in_progress();\n \t\t/* Collection is in progress, or was abandoned.\t*/\n \n+extern GC_bool GC_print_back_height;\n+\n int GC_never_stop_func GC_PROTO((void)) { return(0); }\n \n+unsigned long GC_time_limit = TIME_LIMIT;\n+\n CLOCK_TYPE GC_start_time;  \t/* Time at which we stopped world.\t*/\n \t\t\t\t/* used only in GC_timeout_stop_func.\t*/\n \n int GC_n_attempts = 0;\t\t/* Number of attempts at finishing\t*/\n-\t\t\t\t/* collection within TIME_LIMIT\t\t*/\n+\t\t\t\t/* collection within GC_time_limit.\t*/\n \n #if defined(SMALL_CONFIG) || defined(NO_CLOCK)\n #   define GC_timeout_stop_func GC_never_stop_func\n@@ -118,7 +122,7 @@ int GC_n_attempts = 0;\t\t/* Number of attempts at finishing\t*/\n #ifndef NO_CLOCK\n     GET_TIME(current_time);\n     time_diff = MS_TIME_DIFF(current_time,GC_start_time);\n-    if (time_diff >= TIME_LIMIT) {\n+    if (time_diff >= GC_time_limit) {\n #   \tifdef CONDPRINT\n \t  if (GC_print_stats) {\n \t    GC_printf0(\"Abandoning stopped marking after \");\n@@ -277,9 +281,10 @@ void GC_maybe_gc()\n         /* If we run out of time, this turns into\t*/\n         /* incremental marking.\t\t\t*/\n #\tifndef NO_CLOCK\n-          GET_TIME(GC_start_time);\n+          if (GC_time_limit != GC_TIME_UNLIMITED) { GET_TIME(GC_start_time); }\n #\tendif\n-        if (GC_stopped_mark(GC_timeout_stop_func)) {\n+        if (GC_stopped_mark(GC_time_limit == GC_TIME_UNLIMITED? \n+\t\t\t    GC_never_stop_func : GC_timeout_stop_func)) {\n #           ifdef SAVE_CALL_CHAIN\n                 GC_save_callers(GC_last_stack);\n #           endif\n@@ -391,7 +396,8 @@ int n;\n #\t\tifdef PARALLEL_MARK\n \t\t    GC_wait_for_reclaim();\n #\t\tendif\n-\t\tif (GC_n_attempts < MAX_PRIOR_ATTEMPTS) {\n+\t\tif (GC_n_attempts < MAX_PRIOR_ATTEMPTS\n+\t\t    && GC_time_limit != GC_TIME_UNLIMITED) {\n \t\t  GET_TIME(GC_start_time);\n \t\t  if (!GC_stopped_mark(GC_timeout_stop_func)) {\n \t\t    GC_n_attempts++;\n@@ -436,14 +442,17 @@ GC_stop_func stop_func;\n {\n     register int i;\n     int dummy;\n-#   ifdef PRINTTIMES\n+#   if defined(PRINTTIMES) || defined(CONDPRINT)\n \tCLOCK_TYPE start_time, current_time;\n #   endif\n \t\n     STOP_WORLD();\n #   ifdef PRINTTIMES\n \tGET_TIME(start_time);\n #   endif\n+#   if defined(CONDPRINT) && !defined(PRINTTIMES)\n+\tif (GC_print_stats) GET_TIME(start_time);\n+#   endif\n #   ifdef CONDPRINT\n       if (GC_print_stats) {\n \tGC_printf1(\"--> Marking for collection %lu \",\n@@ -453,6 +462,11 @@ GC_stop_func stop_func;\n \t   \t   (unsigned long) WORDS_TO_BYTES(GC_words_wasted));\n       }\n #   endif\n+#   ifdef MAKE_BACK_GRAPH\n+      if (GC_print_back_height) {\n+        GC_build_back_graph();\n+      }\n+#   endif\n \n     /* Mark from all roots.  */\n         /* Minimize junk left in my registers and on the stack */\n@@ -506,6 +520,14 @@ GC_stop_func stop_func;\n \tGET_TIME(current_time);\n \tGC_printf1(\"World-stopped marking took %lu msecs\\n\",\n \t           MS_TIME_DIFF(current_time,start_time));\n+#   else\n+#     ifdef CONDPRINT\n+\tif (GC_print_stats) {\n+\t  GET_TIME(current_time);\n+\t  GC_printf1(\"World-stopped marking took %lu msecs\\n\",\n+\t             MS_TIME_DIFF(current_time,start_time));\n+\t}\n+#     endif\n #   endif\n     START_WORLD();\n     return(TRUE);\n@@ -612,6 +634,17 @@ void GC_finish_collection()\n       GET_TIME(finalize_time);\n #   endif\n \n+    if (GC_print_back_height) {\n+#     ifdef MAKE_BACK_GRAPH\n+\tGC_traverse_back_graph();\n+#     else\n+#\tifndef SMALL_CONFIG\n+\t  GC_err_printf0(\"Back height not available: \"\n+\t\t         \"Rebuild collector with -DMAKE_BACK_GRAPH\\n\");\n+#  \tendif\n+#     endif\n+    }\n+\n     /* Clear free list mark bits, in case they got accidentally marked   */\n     /* (or GC_find_leak is set and they were intentionally marked).\t */\n     /* Also subtract memory remaining from GC_mem_found count.           */"}, {"sha": "aa6ea3f676608cb445e4f9ecfcb2ebfc11187e64", "filename": "boehm-gc/config.guess", "status": "modified", "additions": 60, "deletions": 49, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fconfig.guess", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fconfig.guess", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfig.guess?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -1,9 +1,9 @@\n #! /bin/sh\n # Attempt to guess a canonical system name.\n-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n-#   Free Software Foundation, Inc.\n+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n+#   2000, 2001, 2002 Free Software Foundation, Inc.\n \n-timestamp='2001-10-05'\n+timestamp='2002-01-10'\n \n # This file is free software; you can redistribute it and/or modify it\n # under the terms of the GNU General Public License as published by\n@@ -24,7 +24,7 @@ timestamp='2001-10-05'\n # configuration script generated by Autoconf, you may include it under\n # the same distribution terms that you use for the rest of that program.\n \n-# Originally written by Per Bothner <bothner@cygnus.com>.\n+# Originally written by Per Bothner <per@bothner.com>.\n # Please send patches to <config-patches@gnu.org>.  Submit a context\n # diff and a properly formatted ChangeLog entry.\n #\n@@ -135,23 +135,21 @@ case \"${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}\" in\n \t# object file format.  This provides both forward\n \t# compatibility and a consistent mechanism for selecting the\n \t# object file format.\n-\t# Determine the machine/vendor (is the vendor relevant).\n-\tcase \"${UNAME_MACHINE}\" in\n-\t    amiga) machine=m68k-unknown ;;\n-\t    arm32) machine=arm-unknown ;;\n-\t    atari*) machine=m68k-atari ;;\n-\t    sun3*) machine=m68k-sun ;;\n-\t    mac68k) machine=m68k-apple ;;\n-\t    macppc) machine=powerpc-apple ;;\n-\t    hp3[0-9][05]) machine=m68k-hp ;;\n-\t    ibmrt|romp-ibm) machine=romp-ibm ;;\n-\t    sparc*) machine=`uname -p`-unknown ;;\n-\t    *) machine=${UNAME_MACHINE}-unknown ;;\n+\t#\n+\t# Note: NetBSD doesn't particularly care about the vendor\n+\t# portion of the name.  We always set it to \"unknown\".\n+\tUNAME_MACHINE_ARCH=`(uname -p) 2>/dev/null` || \\\n+\t    UNAME_MACHINE_ARCH=unknown\n+\tcase \"${UNAME_MACHINE_ARCH}\" in\n+\t    arm*) machine=arm-unknown ;;\n+\t    sh3el) machine=shl-unknown ;;\n+\t    sh3eb) machine=sh-unknown ;;\n+\t    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;\n \tesac\n \t# The Operating System including object format, if it has switched\n \t# to ELF recently, or will in the future.\n-\tcase \"${UNAME_MACHINE}\" in\n-\t    i386|sparc|amiga|arm*|hp300|mvme68k|vax|atari|luna68k|mac68k|news68k|next68k|pc532|sun3*|x68k)\n+\tcase \"${UNAME_MACHINE_ARCH}\" in\n+\t    arm*|i386|m68k|ns32k|sh3*|sparc|vax)\n \t\teval $set_cc_for_build\n \t\tif echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \\\n \t\t\t| grep __ELF__ >/dev/null\n@@ -291,6 +289,9 @@ EOF\n     *:[Aa]miga[Oo][Ss]:*:*)\n \techo ${UNAME_MACHINE}-unknown-amigaos\n \texit 0 ;;\n+    *:[Mm]orph[Oo][Ss]:*:*)\n+\techo ${UNAME_MACHINE}-unknown-morphos\n+\texit 0 ;;\n     *:OS/390:*:*)\n \techo i370-ibm-openedition\n \texit 0 ;;\n@@ -736,6 +737,9 @@ EOF\n     i*:PW*:*)\n \techo ${UNAME_MACHINE}-pc-pw32\n \texit 0 ;;\n+    x86:Interix*:3*)\n+\techo i386-pc-interix3\n+\texit 0 ;;\n     i*:Windows_NT*:* | Pentium*:Windows_NT*:*)\n \t# How do we know it's Interix rather than the generic POSIX subsystem?\n \t# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we\n@@ -767,10 +771,24 @@ EOF\n \techo ${UNAME_MACHINE}-unknown-linux-gnu\n \texit 0 ;;\n     mips:Linux:*:*)\n-\tcase `sed -n '/^byte/s/^.*: \\(.*\\) endian/\\1/p' < /proc/cpuinfo` in\n-\t  big)    echo mips-unknown-linux-gnu && exit 0 ;;\n-\t  little) echo mipsel-unknown-linux-gnu && exit 0 ;;\n-\tesac\n+\teval $set_cc_for_build\n+\tsed 's/^\t//' << EOF >$dummy.c\n+\t#undef CPU\n+\t#undef mips\n+\t#undef mipsel\n+\t#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL) \n+\tCPU=mipsel \n+\t#else\n+\t#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB) \n+\tCPU=mips\n+\t#else\n+\tCPU=\n+\t#endif\n+\t#endif \n+EOF\n+\teval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`\n+\trm -f $dummy.c\n+\ttest x\"${CPU}\" != x && echo \"${CPU}-pc-linux-gnu\" && exit 0\n \t;;\n     ppc:Linux:*:*)\n \techo powerpc-unknown-linux-gnu\n@@ -843,32 +861,25 @@ EOF\n \tesac\n \t# Determine whether the default compiler is a.out or elf\n \teval $set_cc_for_build\n-\tcat >$dummy.c <<EOF\n-#include <features.h>\n-#ifdef __cplusplus\n-#include <stdio.h>  /* for printf() prototype */\n-\tint main (int argc, char *argv[]) {\n-#else\n-\tint main (argc, argv) int argc; char *argv[]; {\n-#endif\n-#ifdef __ELF__\n-# ifdef __GLIBC__\n-#  if __GLIBC__ >= 2\n-    printf (\"%s-pc-linux-gnu\\n\", argv[1]);\n-#  else\n-    printf (\"%s-pc-linux-gnulibc1\\n\", argv[1]);\n-#  endif\n-# else\n-   printf (\"%s-pc-linux-gnulibc1\\n\", argv[1]);\n-# endif\n-#else\n-  printf (\"%s-pc-linux-gnuaout\\n\", argv[1]);\n-#endif\n-  return 0;\n-}\n+\tsed 's/^\t//' << EOF >$dummy.c\n+\t#include <features.h>\n+\t#ifdef __ELF__\n+\t# ifdef __GLIBC__\n+\t#  if __GLIBC__ >= 2\n+\tLIBC=gnu\n+\t#  else\n+\tLIBC=gnulibc1\n+\t#  endif\n+\t# else\n+\tLIBC=gnulibc1\n+\t# endif\n+\t#else\n+\tLIBC=gnuaout\n+\t#endif\n EOF\n-\t$CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy \"${UNAME_MACHINE}\" && rm -f $dummy.c $dummy && exit 0\n-\trm -f $dummy.c $dummy\n+\teval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`\n+\trm -f $dummy.c\n+\ttest x\"${LIBC}\" != x && echo \"${UNAME_MACHINE}-pc-linux-${LIBC}\" && exit 0\n \ttest x\"${TENTATIVE}\" != x && echo \"${TENTATIVE}\" && exit 0\n \t;;\n     i*86:DYNIX/ptx:4*:*)\n@@ -947,7 +958,7 @@ EOF\n \texit 0 ;;\n     M68*:*:R3V[567]*:*)\n \ttest -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;\n-    3[34]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0)\n+    3[34]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0)\n \tOS_REL=''\n \ttest -r /etc/.relid \\\n \t&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \\([0-9][0-9]\\).*/\\1/p' < /etc/.relid`\n@@ -1056,7 +1067,7 @@ EOF\n     *:QNX:*:4*)\n \techo i386-pc-qnx\n \texit 0 ;;\n-    NSR-[KW]:NONSTOP_KERNEL:*:*)\n+    NSR-[GKLNPTVW]:NONSTOP_KERNEL:*:*)\n \techo nsr-tandem-nsk${UNAME_RELEASE}\n \texit 0 ;;\n     *:NonStop-UX:*:*)"}, {"sha": "16573348b81f291aed336a09e157f42ba6c20a24", "filename": "boehm-gc/config.sub", "status": "modified", "additions": 298, "deletions": 90, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fconfig.sub", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fconfig.sub", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfig.sub?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -1,6 +1,10 @@\n #! /bin/sh\n-# Configuration validation subroutine script, version 1.1.\n-#   Copyright (C) 1991, 92-97, 1998, 1999 Free Software Foundation, Inc.\n+# Configuration validation subroutine script.\n+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n+#   2000, 2001, 2002 Free Software Foundation, Inc.\n+\n+timestamp='2002-01-02'\n+\n # This file is (in principle) common to ALL GNU software.\n # The presence of a machine in this file suggests that SOME GNU software\n # can handle that machine.  It does not imply ALL GNU software can.\n@@ -25,6 +29,9 @@\n # configuration script generated by Autoconf, you may include it under\n # the same distribution terms that you use for the rest of that program.\n \n+# Please send patches to <config-patches@gnu.org>.  Submit a context\n+# diff and a properly formatted ChangeLog entry.\n+#\n # Configuration subroutine to validate and canonicalize a configuration type.\n # Supply the specified configuration type as an argument.\n # If it is invalid, we print an error message on stderr and exit with code 1.\n@@ -45,30 +52,73 @@\n #\tCPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM\n # It is wrong to echo any other type of specification.\n \n-if [ x$1 = x ]\n-then\n-\techo Configuration name missing. 1>&2\n-\techo \"Usage: $0 CPU-MFR-OPSYS\" 1>&2\n-\techo \"or     $0 ALIAS\" 1>&2\n-\techo where ALIAS is a recognized configuration type. 1>&2\n-\texit 1\n-fi\n+me=`echo \"$0\" | sed -e 's,.*/,,'`\n \n-# First pass through any local machine types.\n-case $1 in\n-\t*local*)\n-\t\techo $1\n-\t\texit 0\n-\t\t;;\n-\t*)\n-\t;;\n+usage=\"\\\n+Usage: $0 [OPTION] CPU-MFR-OPSYS\n+       $0 [OPTION] ALIAS\n+\n+Canonicalize a configuration name.\n+\n+Operation modes:\n+  -h, --help         print this help, then exit\n+  -t, --time-stamp   print date of last modification, then exit\n+  -v, --version      print version number, then exit\n+\n+Report bugs and patches to <config-patches@gnu.org>.\"\n+\n+version=\"\\\n+GNU config.sub ($timestamp)\n+\n+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n+Free Software Foundation, Inc.\n+\n+This is free software; see the source for copying conditions.  There is NO\n+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n+\n+help=\"\n+Try \\`$me --help' for more information.\"\n+\n+# Parse command line\n+while test $# -gt 0 ; do\n+  case $1 in\n+    --time-stamp | --time* | -t )\n+       echo \"$timestamp\" ; exit 0 ;;\n+    --version | -v )\n+       echo \"$version\" ; exit 0 ;;\n+    --help | --h* | -h )\n+       echo \"$usage\"; exit 0 ;;\n+    -- )     # Stop option processing\n+       shift; break ;;\n+    - )\t# Use stdin as input.\n+       break ;;\n+    -* )\n+       echo \"$me: invalid option $1$help\"\n+       exit 1 ;;\n+\n+    *local*)\n+       # First pass through any local machine types.\n+       echo $1\n+       exit 0;;\n+\n+    * )\n+       break ;;\n+  esac\n+done\n+\n+case $# in\n+ 0) echo \"$me: missing argument$help\" >&2\n+    exit 1;;\n+ 1) ;;\n+ *) echo \"$me: too many arguments$help\" >&2\n+    exit 1;;\n esac\n \n # Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).\n # Here we must recognize all the valid KERNEL-OS combinations.\n maybe_os=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\2/'`\n case $maybe_os in\n-  linux-gnu*)\n+  nto-qnx* | linux-gnu* | storm-chaos* | os2-emx* | windows32-*)\n     os=-$maybe_os\n     basic_machine=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\1/'`\n     ;;\n@@ -94,7 +144,7 @@ case $os in\n \t-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\\\n \t-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \\\n \t-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \\\n-\t-apple)\n+\t-apple | -axis)\n \t\tos=\n \t\tbasic_machine=$1\n \t\t;;\n@@ -108,6 +158,14 @@ case $os in\n \t\tos=-vxworks\n \t\tbasic_machine=$1\n \t\t;;\n+\t-chorusos*)\n+\t\tos=-chorusos\n+\t\tbasic_machine=$1\n+\t\t;;\n+ \t-chorusrdb)\n+ \t\tos=-chorusrdb\n+\t\tbasic_machine=$1\n+ \t\t;;\n \t-hiux*)\n \t\tos=-hiuxwe2\n \t\t;;\n@@ -166,27 +224,50 @@ esac\n case $basic_machine in\n \t# Recognize the basic CPU types without company name.\n \t# Some are omitted here because they have special meanings below.\n-\ttahoe | i860 | ia64 | m32r | m68k | m68000 | m88k | ns32k | arc | arm \\\n-\t\t| arme[lb] | pyramid | mn10200 | mn10300 | tron | a29k \\\n-\t\t| 580 | i960 | h8300 \\\n-\t\t| hppa | hppa1.0 | hppa1.1 | hppa2.0 | hppa2.0w | hppa2.0n \\\n-\t\t| alpha | alphaev[4-7] | alphaev56 | alphapca5[67] \\\n-\t\t| we32k | ns16k | clipper | i370 | sh | powerpc | powerpcle \\\n-\t\t| 1750a | dsp16xx | pdp11 | mips16 | mips64 | mipsel | mips64el \\\n-\t\t| mips64orion | mips64orionel | mipstx39 | mipstx39el \\\n-\t\t| mips64vr4300 | mips64vr4300el | mips64vr4100 | mips64vr4100el \\\n-\t\t| mips64vr5000 | miprs64vr5000el | mcore \\\n-\t\t| sparc | sparclet | sparclite | sparc64 | sparcv9 | v850 | c4x \\\n-\t\t| thumb | d10v | fr30)\n+\t1750a | 580 \\\n+\t| a29k \\\n+\t| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \\\n+\t| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \\\n+\t| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \\\n+\t| c4x | clipper \\\n+\t| d10v | d30v | dsp16xx \\\n+\t| fr30 \\\n+\t| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \\\n+\t| i370 | i860 | i960 | ia64 \\\n+\t| m32r | m68000 | m68k | m88k | mcore \\\n+\t| mips16 | mips64 | mips64el | mips64orion | mips64orionel \\\n+\t| mips64vr4100 | mips64vr4100el | mips64vr4300 \\\n+\t| mips64vr4300el | mips64vr5000 | mips64vr5000el \\\n+\t| mipsbe | mipseb | mipsel | mipsle | mipstx39 | mipstx39el \\\n+\t| mipsisa32 \\\n+\t| mn10200 | mn10300 \\\n+\t| ns16k | ns32k \\\n+\t| openrisc \\\n+\t| pdp10 | pdp11 | pj | pjl \\\n+\t| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \\\n+\t| pyramid \\\n+\t| sh | sh[34] | sh[34]eb | shbe | shle \\\n+\t| sparc | sparc64 | sparclet | sparclite | sparcv9 | sparcv9b \\\n+\t| strongarm \\\n+\t| tahoe | thumb | tic80 | tron \\\n+\t| v850 | v850e \\\n+\t| we32k \\\n+\t| x86 | xscale | xstormy16 | xtensa \\\n+\t| z8k)\n \t\tbasic_machine=$basic_machine-unknown\n \t\t;;\n-\tm88110 | m680[12346]0 | m683?2 | m68360 | m5200 | z8k | v70 | h8500 | w65 | pj | pjl)\n+\tm6811 | m68hc11 | m6812 | m68hc12)\n+\t\t# Motorola 68HC11/12.\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\tos=-none\n+\t\t;;\n+\tm88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)\n \t\t;;\n \n \t# We use `pc' rather than `unknown'\n \t# because (1) that's what they normally are, and\n \t# (2) the word \"unknown\" tends to confuse beginning users.\n-\ti[34567]86)\n+\ti*86 | x86_64)\n \t  basic_machine=$basic_machine-pc\n \t  ;;\n \t# Object if more than one company name word.\n@@ -195,24 +276,45 @@ case $basic_machine in\n \t\texit 1\n \t\t;;\n \t# Recognize the basic CPU types with company name.\n-\t# FIXME: clean up the formatting here.\n-\tvax-* | tahoe-* | i[34567]86-* | i860-* | ia64-* | m32r-* | m68k-* | m68000-* \\\n-\t      | m88k-* | sparc-* | ns32k-* | fx80-* | arc-* | arm-* | c[123]* \\\n-\t      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* \\\n-\t      | power-* | none-* | 580-* | cray2-* | h8300-* | h8500-* | i960-* \\\n-\t      | xmp-* | ymp-* \\\n-\t      | hppa-* | hppa1.0-* | hppa1.1-* | hppa2.0-* | hppa2.0w-* | hppa2.0n-* \\\n-\t      | alpha-* | alphaev[4-7]-* | alphaev56-* | alphapca5[67]-* \\\n-\t      | we32k-* | cydra-* | ns16k-* | pn-* | np1-* | xps100-* \\\n-\t      | clipper-* | orion-* \\\n-\t      | sparclite-* | pdp11-* | sh-* | powerpc-* | powerpcle-* \\\n-\t      | sparc64-* | sparcv9-* | sparc86x-* | mips16-* | mips64-* | mipsel-* \\\n-\t      | mips64el-* | mips64orion-* | mips64orionel-* \\\n-\t      | mips64vr4100-* | mips64vr4100el-* | mips64vr4300-* | mips64vr4300el-* \\\n-\t      | mipstx39-* | mipstx39el-* | mcore-* \\\n-\t      | f301-* | armv*-* | t3e-* \\\n-\t      | m88110-* | m680[01234]0-* | m683?2-* | m68360-* | z8k-* | d10v-* \\\n-\t      | thumb-* | v850-* | d30v-* | tic30-* | c30-* | fr30-* )\n+\t580-* \\\n+\t| a29k-* \\\n+\t| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \\\n+\t| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \\\n+\t| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \\\n+\t| arm-*  | armbe-* | armle-* | armv*-* \\\n+\t| avr-* \\\n+\t| bs2000-* \\\n+\t| c[123]* | c30-* | [cjt]90-* | c54x-* \\\n+\t| clipper-* | cray2-* | cydra-* \\\n+\t| d10v-* | d30v-* \\\n+\t| elxsi-* \\\n+\t| f30[01]-* | f700-* | fr30-* | fx80-* \\\n+\t| h8300-* | h8500-* \\\n+\t| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \\\n+\t| i*86-* | i860-* | i960-* | ia64-* \\\n+\t| m32r-* \\\n+\t| m68000-* | m680[01234]0-* | m68360-* | m683?2-* | m68k-* \\\n+\t| m88110-* | m88k-* | mcore-* \\\n+\t| mips-* | mips16-* | mips64-* | mips64el-* | mips64orion-* \\\n+\t| mips64orionel-* | mips64vr4100-* | mips64vr4100el-* \\\n+\t| mips64vr4300-* | mips64vr4300el-* | mipsbe-* | mipseb-* \\\n+\t| mipsle-* | mipsel-* | mipstx39-* | mipstx39el-* \\\n+\t| none-* | np1-* | ns16k-* | ns32k-* \\\n+\t| orion-* \\\n+\t| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \\\n+\t| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \\\n+\t| pyramid-* \\\n+\t| romp-* | rs6000-* \\\n+\t| sh-* | sh[34]-* | sh[34]eb-* | shbe-* | shle-* \\\n+\t| sparc-* | sparc64-* | sparc86x-* | sparclite-* \\\n+\t| sparcv9-* | sparcv9b-* | strongarm-* | sv1-* \\\n+\t| t3e-* | tahoe-* | thumb-* | tic30-* | tic54x-* | tic80-* | tron-* \\\n+\t| v850-* | v850e-* | vax-* \\\n+\t| we32k-* \\\n+\t| x86-* | x86_64-* | xmp-* | xps100-* | xscale-* | xstormy16-* \\\n+\t| xtensa-* \\\n+\t| ymp-* \\\n+\t| z8k-*)\n \t\t;;\n \t# Recognize the various machine names and aliases which stand\n \t# for a CPU type and a company and sometimes even an OS.\n@@ -249,14 +351,14 @@ case $basic_machine in\n \t\tos=-sysv\n \t\t;;\n \tamiga | amiga-*)\n-\t\tbasic_machine=m68k-cbm\n+\t\tbasic_machine=m68k-unknown\n \t\t;;\n \tamigaos | amigados)\n-\t\tbasic_machine=m68k-cbm\n+\t\tbasic_machine=m68k-unknown\n \t\tos=-amigaos\n \t\t;;\n \tamigaunix | amix)\n-\t\tbasic_machine=m68k-cbm\n+\t\tbasic_machine=m68k-unknown\n \t\tos=-sysv4\n \t\t;;\n \tapollo68)\n@@ -303,19 +405,30 @@ case $basic_machine in\n \t\tbasic_machine=cray2-cray\n \t\tos=-unicos\n \t\t;;\n-\t[ctj]90-cray)\n-\t\tbasic_machine=c90-cray\n+\t[cjt]90)\n+\t\tbasic_machine=${basic_machine}-cray\n \t\tos=-unicos\n \t\t;;\n \tcrds | unos)\n \t\tbasic_machine=m68k-crds\n \t\t;;\n+\tcris | cris-* | etrax*)\n+\t\tbasic_machine=cris-axis\n+\t\t;;\n \tda30 | da30-*)\n \t\tbasic_machine=m68k-da30\n \t\t;;\n \tdecstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)\n \t\tbasic_machine=mips-dec\n \t\t;;\n+\tdecsystem10* | dec10*)\n+\t\tbasic_machine=pdp10-dec\n+\t\tos=-tops10\n+\t\t;;\n+\tdecsystem20* | dec20*)\n+\t\tbasic_machine=pdp10-dec\n+\t\tos=-tops20\n+\t\t;;\n \tdelta | 3300 | motorola-3300 | motorola-delta \\\n \t      | 3300-motorola | delta-motorola)\n \t\tbasic_machine=m68k-motorola\n@@ -357,6 +470,10 @@ case $basic_machine in\n \t\tbasic_machine=tron-gmicro\n \t\tos=-sysv\n \t\t;;\n+\tgo32)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-go32\n+\t\t;;\n \th3050r* | hiux*)\n \t\tbasic_machine=hppa1.1-hitachi\n \t\tos=-hiuxwe2\n@@ -432,19 +549,19 @@ case $basic_machine in\n \t\tbasic_machine=i370-ibm\n \t\t;;\n # I'm not sure what \"Sysv32\" means.  Should this be sysv3.2?\n-\ti[34567]86v32)\n+\ti*86v32)\n \t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n \t\tos=-sysv32\n \t\t;;\n-\ti[34567]86v4*)\n+\ti*86v4*)\n \t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n \t\tos=-sysv4\n \t\t;;\n-\ti[34567]86v)\n+\ti*86v)\n \t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n \t\tos=-sysv\n \t\t;;\n-\ti[34567]86sol2)\n+\ti*86sol2)\n \t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n \t\tos=-solaris2\n \t\t;;\n@@ -456,17 +573,6 @@ case $basic_machine in\n \t\tbasic_machine=i386-unknown\n \t\tos=-vsta\n \t\t;;\n-\ti386-go32 | go32)\n-\t\tbasic_machine=i386-unknown\n-\t\tos=-go32\n-\t\t;;\n-\ti386-mingw32 | mingw32)\n-\t\tbasic_machine=i386-unknown\n-\t\tos=-mingw32\n-\t\t;;\n-\ti386-qnx | qnx)\n-\t\tbasic_machine=i386-qnx\n-\t\t;;\n \tiris | iris4d)\n \t\tbasic_machine=mips-sgi\n \t\tcase $os in\n@@ -492,6 +598,10 @@ case $basic_machine in\n \t\tbasic_machine=ns32k-utek\n \t\tos=-sysv\n \t\t;;\n+\tmingw32)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-mingw32\n+\t\t;;\n \tminiframe)\n \t\tbasic_machine=m68000-convergent\n \t\t;;\n@@ -513,12 +623,20 @@ case $basic_machine in\n \tmips3*)\n \t\tbasic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown\n \t\t;;\n+\tmmix*)\n+\t\tbasic_machine=mmix-knuth\n+\t\tos=-mmixware\n+\t\t;;\n \tmonitor)\n \t\tbasic_machine=m68k-rom68k\n \t\tos=-coff\n \t\t;;\n+\tmorphos)\n+\t\tbasic_machine=powerpc-unknown\n+\t\tos=-morphos\n+\t\t;;\n \tmsdos)\n-\t\tbasic_machine=i386-unknown\n+\t\tbasic_machine=i386-pc\n \t\tos=-msdos\n \t\t;;\n \tmvs)\n@@ -582,9 +700,16 @@ case $basic_machine in\n \t\tbasic_machine=i960-intel\n \t\tos=-mon960\n \t\t;;\n+\tnonstopux)\n+\t\tbasic_machine=mips-compaq\n+\t\tos=-nonstopux\n+\t\t;;\n \tnp1)\n \t\tbasic_machine=np1-gould\n \t\t;;\n+\tnsr-tandem)\n+\t\tbasic_machine=nsr-tandem\n+\t\t;;\n \top50n-* | op60c-*)\n \t\tbasic_machine=hppa1.1-oki\n \t\tos=-proelf\n@@ -614,28 +739,28 @@ case $basic_machine in\n         pc532 | pc532-*)\n \t\tbasic_machine=ns32k-pc532\n \t\t;;\n-\tpentium | p5 | k5 | k6 | nexen)\n+\tpentium | p5 | k5 | k6 | nexgen | viac3)\n \t\tbasic_machine=i586-pc\n \t\t;;\n-\tpentiumpro | p6 | 6x86)\n+\tpentiumpro | p6 | 6x86 | athlon)\n \t\tbasic_machine=i686-pc\n \t\t;;\n \tpentiumii | pentium2)\n-\t\tbasic_machine=i786-pc\n+\t\tbasic_machine=i686-pc\n \t\t;;\n-\tpentium-* | p5-* | k5-* | k6-* | nexen-*)\n+\tpentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)\n \t\tbasic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`\n \t\t;;\n-\tpentiumpro-* | p6-* | 6x86-*)\n+\tpentiumpro-* | p6-* | 6x86-* | athlon-*)\n \t\tbasic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`\n \t\t;;\n \tpentiumii-* | pentium2-*)\n-\t\tbasic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\tbasic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`\n \t\t;;\n \tpn)\n \t\tbasic_machine=pn-gould\n \t\t;;\n-\tpower)\tbasic_machine=rs6000-ibm\n+\tpower)\tbasic_machine=power-ibm\n \t\t;;\n \tppc)\tbasic_machine=powerpc-unknown\n \t        ;;\n@@ -647,9 +772,23 @@ case $basic_machine in\n \tppcle-* | powerpclittle-*)\n \t\tbasic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`\n \t\t;;\n+\tppc64)\tbasic_machine=powerpc64-unknown\n+\t        ;;\n+\tppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tppc64le | powerpc64little | ppc64-le | powerpc64-little)\n+\t\tbasic_machine=powerpc64le-unknown\n+\t        ;;\n+\tppc64le-* | powerpc64little-*)\n+\t\tbasic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n \tps2)\n \t\tbasic_machine=i386-ibm\n \t\t;;\n+\tpw32)\n+\t\tbasic_machine=i586-unknown\n+\t\tos=-pw32\n+\t\t;;\n \trom68k)\n \t\tbasic_machine=m68k-rom68k\n \t\tos=-coff\n@@ -660,6 +799,12 @@ case $basic_machine in\n \trtpc | rtpc-*)\n \t\tbasic_machine=romp-ibm\n \t\t;;\n+\ts390 | s390-*)\n+\t\tbasic_machine=s390-ibm\n+\t\t;;\n+\ts390x | s390x-*)\n+\t\tbasic_machine=s390x-ibm\n+\t\t;;\n \tsa29200)\n \t\tbasic_machine=a29k-amd\n \t\tos=-udi\n@@ -671,7 +816,7 @@ case $basic_machine in\n \t\tbasic_machine=sh-hitachi\n \t\tos=-hms\n \t\t;;\n-\tsparclite-wrs)\n+\tsparclite-wrs | simso-wrs)\n \t\tbasic_machine=sparclite-wrs\n \t\tos=-vxworks\n \t\t;;\n@@ -729,6 +874,10 @@ case $basic_machine in\n \tsun386 | sun386i | roadrunner)\n \t\tbasic_machine=i386-sun\n \t\t;;\n+\tsv1)\n+\t\tbasic_machine=sv1-cray\n+\t\tos=-unicos\n+\t\t;;\n \tsymmetry)\n \t\tbasic_machine=i386-sequent\n \t\tos=-dynix\n@@ -737,12 +886,20 @@ case $basic_machine in\n \t\tbasic_machine=t3e-cray\n \t\tos=-unicos\n \t\t;;\n+\ttic54x | c54x*)\n+\t\tbasic_machine=tic54x-unknown\n+\t\tos=-coff\n+\t\t;;\n \ttx39)\n \t\tbasic_machine=mipstx39-unknown\n \t\t;;\n \ttx39el)\n \t\tbasic_machine=mipstx39el-unknown\n \t\t;;\n+\ttoad1)\n+\t\tbasic_machine=pdp10-xkl\n+\t\tos=-tops20\n+\t\t;;\n \ttower | tower-32)\n \t\tbasic_machine=m68k-ncr\n \t\t;;\n@@ -789,6 +946,10 @@ case $basic_machine in\n \t\tbasic_machine=hppa1.1-winbond\n \t\tos=-proelf\n \t\t;;\n+\twindows32)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-windows32-msvcrt\n+\t\t;;\n \txmp)\n \t\tbasic_machine=xmp-cray\n \t\tos=-unicos\n@@ -832,13 +993,20 @@ case $basic_machine in\n \tvax)\n \t\tbasic_machine=vax-dec\n \t\t;;\n+\tpdp10)\n+\t\t# there are many clones, so DEC is not a safe bet\n+\t\tbasic_machine=pdp10-unknown\n+\t\t;;\n \tpdp11)\n \t\tbasic_machine=pdp11-dec\n \t\t;;\n \twe32k)\n \t\tbasic_machine=we32k-att\n \t\t;;\n-\tsparc | sparcv9)\n+\tsh3 | sh4 | sh3eb | sh4eb)\n+\t\tbasic_machine=sh-unknown\n+\t\t;;\n+\tsparc | sparcv9 | sparcv9b)\n \t\tbasic_machine=sparc-sun\n \t\t;;\n         cydra)\n@@ -860,6 +1028,9 @@ case $basic_machine in\n \t\tbasic_machine=c4x-none\n \t\tos=-coff\n \t\t;;\n+\t*-unknown)\n+\t\t# Make sure to match an already-canonicalized machine name.\n+\t\t;;\n \t*)\n \t\techo Invalid configuration \\`$1\\': machine \\`$basic_machine\\' not recognized 1>&2\n \t\texit 1\n@@ -916,14 +1087,30 @@ case $os in\n \t      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \\\n \t      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \\\n \t      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \\\n+\t      | -chorusos* | -chorusrdb* \\\n \t      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \\\n \t      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \\\n-\t      | -interix* | -uwin* | -rhapsody* | -opened* | -openstep* | -oskit*)\n+\t      | -interix* | -uwin* | -rhapsody* | -darwin* | -opened* \\\n+\t      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \\\n+\t      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \\\n+\t      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* | -morphos*)\n \t# Remember, each alternative MUST END IN *, to match a version number.\n \t\t;;\n+\t-qnx*)\n+\t\tcase $basic_machine in\n+\t\t    x86-* | i*86-*)\n+\t\t\t;;\n+\t\t    *)\n+\t\t\tos=-nto$os\n+\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\t-nto*)\n+\t\tos=-nto-qnx\n+\t\t;;\n \t-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \\\n \t      | -windows* | -osx | -abug | -netware* | -os9* | -beos* \\\n-\t      | -macos* | -mpw* | -magic* | -mon960* | -lnews*)\n+\t      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)\n \t\t;;\n \t-mac*)\n \t\tos=`echo $os | sed -e 's|mac|macos|'`\n@@ -940,6 +1127,9 @@ case $os in\n \t-opened*)\n \t\tos=-openedition\n \t\t;;\n+\t-wince*)\n+\t\tos=-wince\n+\t\t;;\n \t-osfrose*)\n \t\tos=-osfrose\n \t\t;;\n@@ -955,6 +1145,9 @@ case $os in\n \t-acis*)\n \t\tos=-aos\n \t\t;;\n+\t-atheos*)\n+\t\tos=-atheos\n+\t\t;;\n \t-386bsd)\n \t\tos=-bsd\n \t\t;;\n@@ -964,6 +1157,9 @@ case $os in\n \t-ns2 )\n \t        os=-nextstep2\n \t\t;;\n+\t-nsk*)\n+\t\tos=-nsk\n+\t\t;;\n \t# Preserve the version number of sinix5.\n \t-sinix5.*)\n \t\tos=`echo $os | sed -e 's|sinix|sysv|'`\n@@ -977,9 +1173,6 @@ case $os in\n \t-oss*)\n \t\tos=-sysv3\n \t\t;;\n-        -qnx)\n-\t\tos=-qnx4\n-\t\t;;\n \t-svr4)\n \t\tos=-sysv4\n \t\t;;\n@@ -1001,7 +1194,7 @@ case $os in\n \t-xenix)\n \t\tos=-xenix\n \t\t;;\n-        -*mint | -*MiNT)\n+        -*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)\n \t        os=-mint\n \t\t;;\n \t-none)\n@@ -1035,6 +1228,10 @@ case $basic_machine in\n \tarm*-semi)\n \t\tos=-aout\n \t\t;;\n+\t# This must come before the *-dec entry.\n+\tpdp10-*)\n+\t\tos=-tops20\n+\t\t;;\n         pdp11-*)\n \t\tos=-none\n \t\t;;\n@@ -1143,7 +1340,7 @@ case $basic_machine in\n \t*-masscomp)\n \t\tos=-rtu\n \t\t;;\n-\tf301-fujitsu)\n+\tf30[01]-fujitsu | f700-fujitsu)\n \t\tos=-uxpv\n \t\t;;\n \t*-rom68k)\n@@ -1221,12 +1418,23 @@ case $basic_machine in\n \t\t\t-mpw* | -macos*)\n \t\t\t\tvendor=apple\n \t\t\t\t;;\n-\t\t\t-*mint | -*MiNT)\n+\t\t\t-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)\n \t\t\t\tvendor=atari\n \t\t\t\t;;\n+\t\t\t-vos*)\n+\t\t\t\tvendor=stratus\n+\t\t\t\t;;\n \t\tesac\n \t\tbasic_machine=`echo $basic_machine | sed \"s/unknown/$vendor/\"`\n \t\t;;\n esac\n \n echo $basic_machine$os\n+exit 0\n+\n+# Local variables:\n+# eval: (add-hook 'write-file-hooks 'time-stamp)\n+# time-stamp-start: \"timestamp='\"\n+# time-stamp-format: \"%:y-%02m-%02d\"\n+# time-stamp-end: \"'\"\n+# End:"}, {"sha": "6805af9e03a2ae7f0d13ee62460ca64a03810fc9", "filename": "boehm-gc/configure", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -2693,8 +2693,7 @@ EOF\n \tTHREADLIBS=\"-lpthread -lrt\"\n \t;;\n      *-*-freebsd*)\n-\techo \"configure: warning: \"Threaded GC is prone to deadlock before FreeBSD 4.5.\"\" 1>&2\n-\techo \"configure: warning: \"Related symptom is pthread_join returns spurious EINTR.\"\" 1>&2\n+\techo \"configure: warning: \"FreeBSD does not yet fully support threads with Boehm GC.\"\" 1>&2\n \tcat >> confdefs.h <<\\EOF\n #define GC_FREEBSD_THREADS 1\n EOF\n@@ -2739,15 +2738,15 @@ esac\n \n \n echo $ac_n \"checking for dlopen in -ldl\"\"... $ac_c\" 1>&6\n-echo \"configure:2743: checking for dlopen in -ldl\" >&5\n+echo \"configure:2742: checking for dlopen in -ldl\" >&5\n ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-ldl  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 2751 \"configure\"\n+#line 2750 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -2758,7 +2757,7 @@ int main() {\n dlopen()\n ; return 0; }\n EOF\n-if { (eval echo configure:2762: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2761: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -2814,8 +2813,16 @@ esac\n \n machdep=\n case \"$host\" in\n- alpha*-*-*)\n-    machdep=\"alpha_mach_dep.lo\"\n+# alpha_mach_dep.s assumes that pointers are not saved in fp registers.\n+# Gcc on a 21264 can spill pointers to fp registers.  Oops.\n+# alpha*-*-*)\n+#    machdep=\"alpha_mach_dep.lo\"\n+#    ;;\n+ i?86-*-solaris2.[89]*)\n+    cat >> confdefs.h <<\\EOF\n+#define SOLARIS25_PROC_VDB_BUG_FIXED 1\n+EOF\n+\n     ;;\n  alpha-*-openbsd*)\n     if test x\"${ac_cv_lib_dl_dlopen}\" != xyes ; then\n@@ -2844,12 +2851,6 @@ else\n fi\n \n     fi\n-    ;;\n- i?86-*-solaris2.[89]*)\n-    cat >> confdefs.h <<\\EOF\n-#define SOLARIS25_PROC_VDB_BUG_FIXED 1\n-EOF\n-\n     ;;\n  mipstx39-*-elf*)\n     machdep=\"mips_ultrix_mach_dep.lo\"\n@@ -2873,12 +2874,16 @@ EOF\n \n     ;;\n  sparc-sun-solaris2.3*)\n+    machdep=\"sparc_mach_dep.lo\"\n     cat >> confdefs.h <<\\EOF\n #define SUNOS53_SHARED_LIB 1\n EOF\n \n     ;;\n- ia64-*-hpux*)\n+ sparc-sun-solaris2.*)\n+    machdep=\"sparc_mach_dep.lo\"\n+    ;;\n+ ia64-*-*)\n     machdep=\"mach_dep.lo ia64_save_regs_in_stack.lo\"\n     ;;\n esac\n@@ -2964,7 +2969,17 @@ EOF\n EOF\n \n     case $host in\n+      ia64-*-linux* )\n+\tcat >> confdefs.h <<\\EOF\n+#define MAKE_BACK_GRAPH 1\n+EOF\n+\n+      ;;\n       x86-*-linux* | i586-*-linux* | i686-*-linux* )\n+\tcat >> confdefs.h <<\\EOF\n+#define MAKE_BACK_GRAPH 1\n+EOF\n+\n \techo \"configure: warning: \"Client must not use -fomit-frame-pointer.\"\" 1>&2\n \tcat >> confdefs.h <<\\EOF\n #define SAVE_CALL_COUNT 8"}, {"sha": "d22516c2f00afa61f118f3f01745518ad2eed198", "filename": "boehm-gc/configure.in", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.in?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -90,8 +90,7 @@ case \"$THREADS\" in\n \tTHREADLIBS=\"-lpthread -lrt\"\n \t;;\n      *-*-freebsd*)\n-\tAC_MSG_WARN(\"Threaded GC is prone to deadlock before FreeBSD 4.5.\")\n-\tAC_MSG_WARN(\"Related symptom is pthread_join returns spurious EINTR.\")\n+\tAC_MSG_WARN(\"FreeBSD does not yet fully support threads with Boehm GC.\")\n \tAC_DEFINE(GC_FREEBSD_THREADS)\n \tINCLUDES=\"$INCLUDES -pthread\"\n \tTHREADLIBS=-pthread\n@@ -155,18 +154,20 @@ AC_SUBST(CXXINCLUDES)\n \n machdep=\n case \"$host\" in\n- alpha*-*-*)\n-    machdep=\"alpha_mach_dep.lo\"\n+# alpha_mach_dep.s assumes that pointers are not saved in fp registers.\n+# Gcc on a 21264 can spill pointers to fp registers.  Oops.\n+# alpha*-*-*)\n+#    machdep=\"alpha_mach_dep.lo\"\n+#    ;;\n+ i?86-*-solaris2.[[89]]*)\n+    AC_DEFINE(SOLARIS25_PROC_VDB_BUG_FIXED)\n     ;;\n  alpha-*-openbsd*)\n     if test x\"${ac_cv_lib_dl_dlopen}\" != xyes ; then\n        AC_MSG_WARN(OpenBSD/Alpha without dlopen(). Shared library support is disabled)\n        AM_DISABLE_SHARED\n     fi\n     ;;\n- i?86-*-solaris2.[[89]]*)\n-    AC_DEFINE(SOLARIS25_PROC_VDB_BUG_FIXED)\n-    ;;\n  mipstx39-*-elf*)\n     machdep=\"mips_ultrix_mach_dep.lo\"\n     AC_DEFINE(STACKBASE, __stackbase)\n@@ -180,9 +181,13 @@ case \"$host\" in\n     AC_DEFINE(NO_EXECUTE_PERMISSION)\n     ;;\n  sparc-sun-solaris2.3*)\n+    machdep=\"sparc_mach_dep.lo\"\n     AC_DEFINE(SUNOS53_SHARED_LIB)\n     ;;\n- ia64-*-hpux*)\n+ sparc-sun-solaris2.*)\n+    machdep=\"sparc_mach_dep.lo\"\n+    ;;\n+ ia64-*-*)\n     machdep=\"mach_dep.lo ia64_save_regs_in_stack.lo\"\n     ;;\n esac\n@@ -243,7 +248,11 @@ AC_ARG_ENABLE(full-debug,\n     AC_DEFINE(KEEP_BACK_PTRS)\n     AC_DEFINE(DBG_HDRS_ALL)\n     case $host in\n+      ia64-*-linux* )\n+\tAC_DEFINE(MAKE_BACK_GRAPH)\n+      ;;\n       x86-*-linux* | i586-*-linux* | i686-*-linux* )\n+\tAC_DEFINE(MAKE_BACK_GRAPH)\n \tAC_MSG_WARN(\"Client must not use -fomit-frame-pointer.\")\n \tAC_DEFINE(SAVE_CALL_COUNT, 8)\n       ;;"}, {"sha": "e875c880f071be362526716883e2908da7766950", "filename": "boehm-gc/dbg_mlc.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fdbg_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fdbg_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdbg_mlc.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -245,6 +245,9 @@ word integer;\n     LOCK();\n #   ifdef KEEP_BACK_PTRS\n       ((oh *)p) -> oh_back_ptr = HIDE_BACK_PTR(NOT_MARKED);\n+#   endif\n+#   ifdef MAKE_BACK_GRAPH\n+      ((oh *)p) -> oh_bg_ptr = HIDE_BACK_PTR((ptr_t)0);\n #   endif\n     ((oh *)p) -> oh_string = string;\n     ((oh *)p) -> oh_int = integer;\n@@ -274,6 +277,9 @@ word integer;\n     /* inconsistent while we're in the handler.\t\t\t\t*/\n #   ifdef KEEP_BACK_PTRS\n       ((oh *)p) -> oh_back_ptr = HIDE_BACK_PTR(NOT_MARKED);\n+#   endif\n+#   ifdef MAKE_BACK_GRAPH\n+      ((oh *)p) -> oh_bg_ptr = HIDE_BACK_PTR((ptr_t)0);\n #   endif\n     ((oh *)p) -> oh_string = string;\n     ((oh *)p) -> oh_int = integer;"}, {"sha": "6ac37c6c8ce0b338c9aea6cfaace397347b7f81a", "filename": "boehm-gc/doc/README", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fdoc%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fdoc%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -27,7 +27,7 @@ are GPL'ed, but with an exception that should cover all uses in the\n collector.  (If you are concerned about such things, I recommend you look\n at the notice in config.guess or ltmain.sh.)\n \n-This is version 6.1alpha1 of a conservative garbage collector for C and C++.\n+This is version 6.1alpha3 of a conservative garbage collector for C and C++.\n \n You might find a more recent version of this at\n "}, {"sha": "232938b437595b5e344f245807c6bf679cf65e70", "filename": "boehm-gc/doc/README.changes", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fdoc%2FREADME.changes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fdoc%2FREADME.changes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.changes?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -1413,6 +1413,61 @@ Since 6.0:\n    less common thread implementations, since some of the original code\n    didn't stand up to close scrutiny.  Support for the next pthreads\n    implementation should be easier to add.\n+\n+Since 6.1alpha1:\n+ - No longer wrap read by default in multithreaded applications.  It was\n+   pointed out on the libgcj list that this holds the allocation lock for\n+   way too long if the read blocks.  For now, reads into the heap are\n+   broken with incremental collection.  It's possible to turn this back on\n+   if you make sure that read calls don't block (e.g. by calling select\n+   first).\n+ - Fix ifdef in Solaris_threads.h to refer to GC_SOLARIS_THREADS.\n+ - Added check for environment variable GC_IGNORE_GCJ_INFO.\n+ - Added printing of stop-the-world GC times if GC_PRINT_STATS environment\n+   variable is set.\n+ - The calloc definition in leak_detector.h was missing parentheses, and\n+   realloc was missing a second argument to GC_REALLOC.\n+   (Thanks to Elrond (elrond<at>samba-tng.org).)\n+ - Added GC_PRINT_BACK_HEIGHT environment variable and associated\n+   code, mostly in the new file backgraph.c.  See doc/README.environment.\n+ - Added -DUSE_GLOBAL_ALLOC to work around a Windows NT issue.  (Thanks to\n+   Jonathan Clark.)\n+ - Integrated port to NEC EWS4800 (MIPS-based workstation, with somewhat\n+   different address-space layout). This may help for other machines with\n+   holes in the data segment.  (Thanks to Hironori Sakamoto.)\n+ - Changed the order in which GC_push_roots and friends push things onto\n+   the mark stack.  GC_push_all calls need to come first, since we can't\n+   necessarily recovere if those overflow the mark stack.  (Thanks to\n+   Matthew Flatt for tracking down the problem.)\n+ - Some minor cleanups to mostly support the Intel compiler on Linux/IA64.\n+\n+Since 6.1 alpha2:\n+ - Minor cleanup on the gcconfig.h section for SPARC.\n+ - Minor fix to support Intel compiler for I386/Linux. (Thanks to Sven\n+   Hartrumpf.)\n+ - Added SPARC V9 (64-bit) support.  (Thanks to Jeff Sturm.)\n+ - Restructured the way in which we determine whether or not to keep\n+   call stacks for debug allocation.  By default SAVE_CALL_COUNT is\n+   now zero on all platforms.  Added SAVE_CALL_NARGS parameters.\n+   If possible, use execinfo.h to capture call stack.  (This should\n+   add support for a number of new platforms, though often at\n+   considerable runtime expense.)\n+ - Try to print symbolic information for call stacks.  On Linux, we\n+   do this with a combination of execinfo.h and running addr2line in\n+   a separate process.  This is both much more expensive and much more\n+   useful.  Amazingly, it seems to be fast enough for most purposes.\n+ - Redefined strdup if -DREDIRECT_MALLOC is given.\n+ - Changed incremental collector and MPROTECT_VDB implementation so that,\n+   under favorable conditions, pointerfree objects are not protected.\n+   Added GC_incremental_protection_needs() to determine ahead of time whether\n+   pointerfree objects may be protected.  Replaced GC_write_hint() with\n+   GC_remove_protection().\n+ - Added test for GC_ENABLE_INCREMENTAL environment variable.\n+ - Made GC_time_limit runtime configurable.  Added GC_PAUSE_TIME_TARGET\n+   environment variable.\n+ - Eliminated GC_page_sz, a duplicate of GC_page_size.\n+ - Caused the Solaris and Irix thread creation primitives to call\n+   GC_init_inner().\n  \n \n To do:"}, {"sha": "6b25af1f6fe683c5e49de9c6f2942114a98c3fb8", "filename": "boehm-gc/doc/README.environment", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fdoc%2FREADME.environment", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fdoc%2FREADME.environment", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.environment?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -1,5 +1,5 @@\n The garbage collector looks at a number of environment variables which are\n-the used to affect its operation.  These are examined only on Un*x-like\n+then used to affect its operation.  These are examined only on Un*x-like\n platforms.\n \n GC_INITIAL_HEAP_SIZE=<bytes> -\tInitial heap size in bytes.  May speed up\n@@ -32,6 +32,47 @@ GC_NPROCS=<n> - Linux w/threads only.  Explicitly sets the number of processors\n GC_NO_BLACKLIST_WARNING - Prevents the collector from issuing\n \t\t\"Needed to allocate blacklisted block at ...\" warnings.\n \n+GC_IGNORE_GCJ_INFO - Ignore the type descriptors implicitly supplied by\n+\t\t     GC_gcj_malloc and friends.  This is useful for debugging\n+\t\t     descriptor generation problems, and possibly for\n+\t\t     temporarily working around such problems.  It forces a\n+\t\t     fully conservative scan of all heap objects except\n+\t\t     those known to be pointerfree, and may thus have other\n+\t\t     adverse effects.\n+\n+GC_PRINT_BACK_HEIGHT - Print max length of chain through unreachable objects\n+\t\t     ending in a reachable one.  If this number remains\n+\t\t     bounded, then the program is \"GC robust\".  This ensures\n+\t\t     that a fixed number of misidentified pointers can only\n+\t\t     result in a bounded space leak.  This currently only\n+\t\t     works if debugging allocation is used throughout.\n+\t\t     It increases GC space and time requirements appreciably.\n+\t\t     This feature is still somewhat experimental, and requires\n+\t\t     that the collector have been built with MAKE_BACK_GRAPH\n+\t\t     defined.  For details, see Boehm, \"Bounding Space Usage\n+\t\t     of Conservative Garbage Collectors\", POPL 2001, or\n+\t\t     http://lib.hpl.hp.com/techpubs/2001/HPL-2001-251.html .\n+\n+GC_ENABLE_INCREMENTAL - Turn on incremental collection at startup.  Note that,\n+\t\t     depending on platform and collector configuration, this\n+\t\t     may involve write protecting pieces of the heap to\n+\t\t     track modifications.  These pieces may include pointerfree\n+\t\t     objects or not.  Although this is intended to be\n+\t\t     transparent, it may cause unintended system call failures.\n+\t\t     Use with caution.\n+\n+GC_PAUSE_TIME_TARGET - Set the desired garbage collector pause time in msecs.\n+\t\t     This only has an effect if incremental collection is enabled.\n+\t\t     If a collection requires appreciably more time than this,\n+\t\t     the client will be restarted, and the collector will need\n+\t\t     to do additional work to compensate.  The special value\n+\t\t     \"999999\" indicates that pause time is unlimited, and the\n+\t\t     incremental collector will behave completely like a\n+\t\t     simple generational collector.  If the collector is\n+\t\t     configured for parallel marking, and run on a multiprocessor,\n+\t\t     incremental collection should only be used with unlimited\n+\t\t     pause time.\n+\n The following turn on runtime flags that are also program settable.  Checked\n only during initialization.  We expect that they will usually be set through\n other means, but this may help with debugging and testing:"}, {"sha": "b1a6ec5966491054687e795495ed6ad68d32971c", "filename": "boehm-gc/doc/README.win32", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fdoc%2FREADME.win32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fdoc%2FREADME.win32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.win32?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -1,8 +1,8 @@\n The collector has at various times been compiled under Windows 95 & NT,\n with the original Microsoft SDK, with Visual C++ 2.0, 4.0, and 6, with\n-the GNU win32 environment, with Borland 4.5, and recently with\n-Watcom C.  It is likely that some of these have been broken in the\n-meantime.  Patches are appreciated.\n+the GNU win32 environment, with Borland 4.5,  with Watcom C, and recently\n+with the Digital Mars compiler.  It is likely that some of these have been\n+broken in the meantime.  Patches are appreciated.\n \n It runs under both win32s and win32, but with different semantics.\n Under win32, all writable pages outside of the heaps and stack are\n@@ -45,6 +45,13 @@ window colors.)\n In general -DREDIRECT_MALLOC is unlikely to work unless the\n application is completely statically linked.\n \n+The collector normally allocates memory from the OS with VirtualAlloc.\n+This appears to cause problems under Windows NT and Windows 2000 (but\n+not Windows 95/98) if the memory is later passed to CreateDIBitmap.\n+To work around this problem, build the collector with -DUSE_GLOBAL_ALLOC.\n+This is currently incompatible with -DUSE_MUNMAP.  (Thanks to Jonathan\n+Clark for tracking this down.)\n+\n For Microsoft development tools, rename NT_MAKEFILE as\n MAKEFILE.  (Make sure that the CPU environment variable is defined\n to be i386.)  In order to use the gc_cpp.h C++ interface, all"}, {"sha": "d80600bb1d79b2b74b437441dbb5356f195dd405", "filename": "boehm-gc/dyn_load.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fdyn_load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fdyn_load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdyn_load.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -79,6 +79,14 @@\n #   define l_name\tlm_name\n #endif\n \n+#if defined(LINUX) && defined(__ELF__) || defined(SCO_ELF) || \\\n+    (defined(FREEBSD) && defined(__ELF__)) || \\\n+    (defined(NETBSD) && defined(__ELF__)) || defined(HURD)\n+#   include <stddef.h>\n+#   include <elf.h>\n+#   include <link.h>\n+#endif\n+\n /* Newer versions of GNU/Linux define this macro.  We\n  * define it similarly for any ELF systems that don't.  */\n #  ifndef ElfW\n@@ -438,10 +446,6 @@ static char *parse_map_entry(char *buf_ptr, word *start, word *end,\n /* For glibc 2.2.4+.  Unfortunately, it doesn't work for older\t*/\n /* versions.  Thanks to Jakub Jelinek for most of the code.\t*/\n \n-#include <stddef.h>\n-#include <elf.h>\n-#include <link.h>\n-\n # if defined(LINUX) /* Are others OK here, too? */ \\\n      && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2) \\\n          || (__GLIBC__ == 2 && __GLIBC_MINOR__ == 2 && defined(DT_CONFIG))) "}, {"sha": "a316010a680f0c8476f38f568f6ff265e9b5c92d", "filename": "boehm-gc/finalize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Ffinalize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Ffinalize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ffinalize.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -838,3 +838,4 @@ void GC_notify_or_invoke_finalizers GC_PROTO((void))\n #   endif\n     return(result);\n }\n+"}, {"sha": "89f0d728a57f4cdfbe32b471032ce2ef2e36944e", "filename": "boehm-gc/gcj_mlc.c", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fgcj_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fgcj_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcj_mlc.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -54,6 +54,7 @@ ptr_t * GC_gcjdebugobjfreelist;\n void GC_init_gcj_malloc(int mp_index, void * /* really GC_mark_proc */mp)\n {\n     register int i;\n+    GC_bool ignore_gcj_info;\n     DCL_LOCK_STATE;\n \n     GC_init();\t/* In case it's not already done.\t*/\n@@ -65,6 +66,12 @@ void GC_init_gcj_malloc(int mp_index, void * /* really GC_mark_proc */mp)\n       return;\n     }\n     GC_gcj_malloc_initialized = TRUE;\n+    ignore_gcj_info = (0 != GETENV(\"GC_IGNORE_GCJ_INFO\"));\n+#   ifdef CONDPRINT\n+      if (GC_print_stats && ignore_gcj_info) {\n+        GC_printf0(\"Gcj-style type information is disabled!\\n\");\n+      }\n+#   endif\n     GC_mark_procs[mp_index] = (GC_mark_proc)mp;\n     if (mp_index >= GC_n_mark_procs) ABORT(\"GC_init_gcj_malloc: bad index\");\n     /* Set up object kind gcj-style indirect descriptor. */\n@@ -75,9 +82,17 @@ void GC_init_gcj_malloc(int mp_index, void * /* really GC_mark_proc */mp)\n       GC_gcj_kind = GC_n_kinds++;\n       GC_obj_kinds[GC_gcj_kind].ok_freelist = GC_gcjobjfreelist;\n       GC_obj_kinds[GC_gcj_kind].ok_reclaim_list = 0;\n-      GC_obj_kinds[GC_gcj_kind].ok_descriptor =\n-    \t(((word)(-MARK_DESCR_OFFSET - GC_INDIR_PER_OBJ_BIAS)) | GC_DS_PER_OBJECT);\n-      GC_obj_kinds[GC_gcj_kind].ok_relocate_descr = FALSE;\n+      if (ignore_gcj_info) {\n+\t/* Use a simple length-based descriptor, thus forcing a fully\t*/\n+\t/* conservative scan.\t\t\t\t\t\t*/\n+        GC_obj_kinds[GC_gcj_kind].ok_descriptor = (0 | GC_DS_LENGTH);\n+        GC_obj_kinds[GC_gcj_kind].ok_relocate_descr = TRUE;\n+      } else {\n+\tGC_obj_kinds[GC_gcj_kind].ok_descriptor =\n+    \t  (((word)(-MARK_DESCR_OFFSET - GC_INDIR_PER_OBJ_BIAS))\n+\t   | GC_DS_PER_OBJECT);\n+        GC_obj_kinds[GC_gcj_kind].ok_relocate_descr = FALSE;\n+      }\n       GC_obj_kinds[GC_gcj_kind].ok_init = TRUE;\n     /* Set up object kind for objects that require mark proc call.\t*/\n       GC_gcjdebugobjfreelist = (ptr_t *)\n@@ -88,9 +103,14 @@ void GC_init_gcj_malloc(int mp_index, void * /* really GC_mark_proc */mp)\n       GC_gcj_debug_kind = GC_n_kinds++;\n       GC_obj_kinds[GC_gcj_debug_kind].ok_freelist = GC_gcjdebugobjfreelist;\n       GC_obj_kinds[GC_gcj_debug_kind].ok_reclaim_list = 0;\n-      GC_obj_kinds[GC_gcj_debug_kind].ok_descriptor =\n-    \tGC_MAKE_PROC(mp_index, 1 /* allocated with debug info */);\n-      GC_obj_kinds[GC_gcj_debug_kind].ok_relocate_descr = FALSE;\n+      if (ignore_gcj_info) {\n+        GC_obj_kinds[GC_gcj_kind].ok_descriptor = (0 | GC_DS_LENGTH);\n+        GC_obj_kinds[GC_gcj_kind].ok_relocate_descr = TRUE;\n+      } else {\n+        GC_obj_kinds[GC_gcj_debug_kind].ok_descriptor =\n+    \t  GC_MAKE_PROC(mp_index, 1 /* allocated with debug info */);\n+        GC_obj_kinds[GC_gcj_debug_kind].ok_relocate_descr = FALSE;\n+      }\n       GC_obj_kinds[GC_gcj_debug_kind].ok_init = TRUE;\n     UNLOCK();\n     ENABLE_SIGNALS();"}, {"sha": "611f56518394ee142c12610aed34af6b2d116539", "filename": "boehm-gc/include/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2FMakefile.in?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -1,4 +1,4 @@\n-# Makefile.in generated automatically by automake 1.4-p1 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4 from Makefile.am\n \n # Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n@@ -96,7 +96,8 @@ target_all = @target_all@\n \n AUTOMAKE_OPTIONS = foreign\n \n-include_HEADERS = gc.h gc_backptr.h gc_local_alloc.h   gc_pthread_redirects.h gc_cpp.h\n+include_HEADERS = gc.h gc_backptr.h gc_local_alloc.h \\\n+  gc_pthread_redirects.h gc_cpp.h\n \n CONFIG_CLEAN_FILES = \n HEADERS =  $(include_HEADERS)"}, {"sha": "69075b0669e153ed5365ce06c8025e914b16a4bd", "filename": "boehm-gc/include/gc.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Finclude%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Finclude%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc.h?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -305,6 +305,20 @@ GC_API int GC_dont_precollect;  /* Don't collect as part of \t\t*/\n  */\n GC_API void GC_init GC_PROTO((void));\n \n+GC_API unsigned long GC_time_limit;\n+\t\t\t\t/* If incremental collection is enabled, */\n+\t\t\t\t/* We try to terminate collections\t */\n+\t\t\t\t/* after this many milliseconds.  Not a\t */\n+\t\t\t\t/* hard time bound.  Setting this to \t */\n+\t\t\t\t/* GC_TIME_UNLIMITED will essentially\t */\n+\t\t\t\t/* disable incremental collection while  */\n+\t\t\t\t/* leaving generational collection\t */\n+\t\t\t\t/* enabled.\t \t\t\t */\n+#\tdefine GC_TIME_UNLIMITED 999999\n+\t\t\t\t/* Setting GC_time_limit to this value\t */\n+\t\t\t\t/* will disable the \"pause time exceeded */\n+\t\t\t\t/* tests.\t\t\t\t */\n+\n /*\n  * general purpose allocation routines, with roughly malloc calling conv.\n  * The atomic versions promise that no relevant pointers are contained\n@@ -463,6 +477,16 @@ GC_API size_t GC_get_total_bytes GC_PROTO((void));\n /* functional if GC_parallel is TRUE.\t\t*/\n GC_API void GC_enable_incremental GC_PROTO((void));\n \n+/* Does incremental mode write-protect pages?  Returns zero or\t*/\n+/* more of the following, or'ed together:\t\t\t*/\n+#define GC_PROTECTS_POINTER_HEAP  1 /* May protect non-atomic objs.\t*/\n+#define GC_PROTECTS_PTRFREE_HEAP  2\n+#define GC_PROTECTS_STATIC_DATA   4 /* Curently never.\t\t\t*/\n+#define GC_PROTECTS_STACK\t  8 /* Probably impractical.\t\t*/\n+\n+#define GC_PROTECTS_NONE 0\n+GC_API int GC_incremental_protection_needs GC_PROTO((void));\n+\n /* Perform some garbage collection work, if appropriate.\t*/\n /* Return 0 if there is no more work to be done.\t\t*/\n /* Typically performs an amount of work corresponding roughly\t*/"}, {"sha": "0674ab4d09f6d1db7bc625b058145186cee75df6", "filename": "boehm-gc/include/leak_detector.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Finclude%2Fleak_detector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Finclude%2Fleak_detector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fleak_detector.h?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -1,7 +1,7 @@\n #define GC_DEBUG\n #include \"gc.h\"\n #define malloc(n) GC_MALLOC(n)\n-#define calloc(m,n) GC_MALLOC(m*n)\n+#define calloc(m,n) GC_MALLOC((m)*(n))\n #define free(p) GC_FREE(p)\n-#define realloc(p,n) GC_REALLOC(n)\n+#define realloc(p,n) GC_REALLOC((p),(n))\n #define CHECK_LEAKS() GC_gcollect()"}, {"sha": "5378835811ce44c01d297a39229fad015b22c664", "filename": "boehm-gc/include/private/dbg_mlc.h", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -46,7 +46,8 @@\n \t/* Stored both one past the end of user object, and one before\t*/\n \t/* the end of the object as seen by the allocator.\t\t*/\n \n-# if defined(KEEP_BACK_PTRS) || defined(PRINT_BLACK_LIST)\n+# if defined(KEEP_BACK_PTRS) || defined(PRINT_BLACK_LIST) \\\n+     || defined(MAKE_BACK_GRAPH)\n     /* Pointer \"source\"s that aren't real locations.\t*/\n     /* Used in oh_back_ptr fields and as \"source\"\t*/\n     /* argument to some marking functions.\t\t*/\n@@ -60,28 +61,42 @@\n \n /* Object header */\n typedef struct {\n-#   ifdef KEEP_BACK_PTRS\n-\tGC_hidden_pointer oh_back_ptr;\n-\t    /* We make sure that we only store even valued\t*/\n-\t    /* pointers here, so that the hidden version has\t*/\n-\t    /* the least significant bit set.  We never\t\t*/\n-\t    /* overwrite a value with the least significant\t*/\n-\t    /* bit clear, thus ensuring that we never overwrite\t*/\n-\t    /* a free list link field.\t\t\t\t*/\n- \t    /* Note that blocks dropped by black-listing will\t*/\n- \t    /* also have the lsb clear once debugging has\t*/\n- \t    /* started.\t\t\t\t\t\t*/\n-\t    /* The following are special back pointer values.\t*/\n-\t    /* Note that the \"hidden\" (i.e. bitwise \t\t*/\n-\t    /* complemented version) of these is actually \t*/\n-\t    /* stored.\t\t\t\t\t\t*/\n+#   if defined(KEEP_BACK_PTRS) || defined(MAKE_BACK_GRAPH)\n+\t/* We potentially keep two different kinds of back \t*/\n+\t/* pointers.  KEEP_BACK_PTRS stores a single back \t*/\n+\t/* pointer in each reachable object to allow reporting\t*/\n+\t/* of why an object was retained.  MAKE_BACK_GRAPH\t*/\n+\t/* builds a graph containing the inverse of all \t*/\n+\t/* \"points-to\" edges including those involving \t\t*/\n+\t/* objects that have just become unreachable. This\t*/\n+\t/* allows detection of growing chains of unreachable\t*/\n+\t/* objects.  It may be possible to eventually combine\t*/\n+\t/* both, but for now we keep them separate.  Both\t*/\n+\t/* kinds of back pointers are hidden using the \t\t*/\n+\t/* following macros.  In both cases, the plain version\t*/\n+\t/* is constrained to have an least significant bit of 1,*/\n+\t/* to allow it to be distinguished from a free list \t*/\n+\t/* link.  This means the plain version must have an\t*/\n+\t/* lsb of 0.\t\t\t\t\t\t*/\n+\t/* Note that blocks dropped by black-listing will\t*/\n+\t/* also have the lsb clear once debugging has\t\t*/\n+\t/* started.\t\t\t\t\t\t*/\n+\t/* We're careful never to overwrite a value with lsb 0.\t*/\n #       if ALIGNMENT == 1\n \t  /* Fudge back pointer to be even.  */\n #\t  define HIDE_BACK_PTR(p) HIDE_POINTER(~1 & (GC_word)(p))\n #\telse\n #\t  define HIDE_BACK_PTR(p) HIDE_POINTER(p)\n #\tendif\n-#\tifdef ALIGN_DOUBLE\n+\t\n+#       ifdef KEEP_BACK_PTRS\n+\t  GC_hidden_pointer oh_back_ptr;\n+#\tendif\n+#\tifdef MAKE_BACK_GRAPH\n+\t  GC_hidden_pointer oh_bg_ptr;\n+#\tendif\n+#\tif defined(ALIGN_DOUBLE) && \\\n+\t    (defined(KEEP_BACK_PTRS) != defined(MAKE_BACK_GRAPH))\n \t  word oh_dummy;\n #\tendif\n #   endif\n@@ -139,9 +154,9 @@ typedef struct {\n   GC_bool GC_has_other_debug_info(/* p */);\n #endif\n \n-#ifdef KEEP_BACK_PTRS\n+#if defined(KEEP_BACK_PTRS) || defined(MAKE_BACK_GRAPH)\n # define GC_HAS_DEBUG_INFO(p) \\\n-\t((((oh *)p)->oh_back_ptr & 1) && GC_has_other_debug_info(p))\n+\t((*((word *)p) & 1) && GC_has_other_debug_info(p))\n #else\n # define GC_HAS_DEBUG_INFO(p) GC_has_other_debug_info(p)\n #endif"}, {"sha": "872065702f06bf1843895aaefbaa48091ff86f04", "filename": "boehm-gc/include/private/gc_pmark.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -136,7 +136,8 @@ extern mse * GC_mark_stack;\n /* Set *new_hdr_p to corr. hdr.\t\t\t\t*/\n #ifdef __STDC__\n # ifdef PRINT_BLACK_LIST\n-    ptr_t GC_find_start(ptr_t current, hdr *hhdr, hdr **new_hdr_p, word source);\n+    ptr_t GC_find_start(ptr_t current, hdr *hhdr, hdr **new_hdr_p,\n+\t\t    \tptr_t source);\n # else\n     ptr_t GC_find_start(ptr_t current, hdr *hhdr, hdr **new_hdr_p);\n # endif"}, {"sha": "ae406cb9010c7055ee3cd4e6d5cf68b68d080078", "filename": "boehm-gc/include/private/gc_priv.h", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -249,35 +249,13 @@ typedef char * ptr_t;\t/* A generic pointer to which we can add\t*/\n \n #ifdef SAVE_CALL_CHAIN\n \n-/*\n- * Number of frames and arguments to save in objects allocated by\n- * debugging allocator.\n- */\n-#   ifndef SAVE_CALL_COUNT\n-#     define NFRAMES 6\t/* Number of frames to save. Even for\t\t*/\n-\t\t\t/* alignment reasons.\t\t\t\t*/\n-#   else\n-#     define NFRAMES ((SAVE_CALL_COUNT + 1) & ~1)\n-#   endif\n-#   define NARGS 2\t/* Mumber of arguments to save for each call.\t*/\n-\n-#   define NEED_CALLINFO\n-\n /* Fill in the pc and argument information for up to NFRAMES of my\t*/\n /* callers.  Ignore my frame and my callers frame.\t\t\t*/\n struct callinfo;\n void GC_save_callers GC_PROTO((struct callinfo info[NFRAMES]));\n   \n void GC_print_callers GC_PROTO((struct callinfo info[NFRAMES]));\n \n-#else\n-\n-# ifdef GC_ADD_CALLER\n-#   define NFRAMES 1\n-#   define NARGS 0\n-#   define NEED_CALLINFO\n-# endif\n-\n #endif\n \n #ifdef NEED_CALLINFO\n@@ -396,7 +374,8 @@ struct hblk;\t/* See below.\t*/\n                                     + GC_page_size-1)\n #   else\n #     if defined(NEXT) || defined(MACOSX) || defined(DOS4GW) || \\\n-\t (defined(AMIGA) && !defined(GC_AMIGA_FASTALLOC))\n+\t (defined(AMIGA) && !defined(GC_AMIGA_FASTALLOC)) || \\\n+\t (defined(SUNOS5) && !defined(USE_MMAP))\n #       define GET_MEM(bytes) HBLKPTR((size_t) \\\n \t\t\t\t      calloc(1, (size_t)bytes + GC_page_size) \\\n                                       + GC_page_size-1)\n@@ -787,12 +766,11 @@ struct hblkhdr {\n # define BODY_SZ (HBLKSIZE/sizeof(word))\n \n struct hblk {\n-#   if 0  /* DISCARDWORDS no longer supported */\n-        word garbage[DISCARD_WORDS];\n-#   endif\n     word hb_body[BODY_SZ];\n };\n \n+# define HBLK_IS_FREE(hdr) ((hdr) -> hb_map == GC_invalid_map)\n+\n # define OBJ_SZ_TO_BLOCKS(sz) \\\n     divHBLKSZ(WORDS_TO_BYTES(sz) + HBLKSIZE-1)\n     /* Size of block (in units of HBLKSIZE) needed to hold objects of\t*/\n@@ -1765,8 +1743,12 @@ GC_bool GC_page_was_ever_dirty GC_PROTO((struct hblk *h));\n void GC_is_fresh GC_PROTO((struct hblk *h, word n));\n   \t\t\t/* Assert the region currently contains no\t*/\n   \t\t\t/* valid pointers.\t\t\t\t*/\n-void GC_write_hint GC_PROTO((struct hblk *h));\n-  \t\t\t/* h is about to be written.\t*/\n+void GC_remove_protection GC_PROTO((struct hblk *h, word nblocks,\n+\t\t\t   \t    GC_bool pointerfree));\n+  \t\t\t/* h is about to be writteni or allocated.  Ensure  */\n+\t\t\t/* that it's not write protected by the virtual\t    */\n+\t\t\t/* dirty bit implementation.\t\t\t    */\n+\t\t\t\n void GC_dirty_init GC_PROTO((void));\n   \n /* Slow/general mark bit manipulation: */"}, {"sha": "e06cc4abc569a41303a7879b0a0b0fc400a96c04", "filename": "boehm-gc/include/private/gcconfig.h", "status": "modified", "additions": 117, "deletions": 18, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -85,9 +85,12 @@\n #    endif\n #    define mach_type_known\n # endif\n-# if defined(mips) || defined(__mips)\n+# if defined(mips) || defined(__mips) || defined(_mips)\n #    define MIPS\n-#    if !defined(LINUX)\n+#    if defined(nec_ews) || defined(_nec_ews)\n+#      define EWS4800\n+#    endif\n+#    if !defined(LINUX) && !defined(EWS4800)\n #      if defined(ultrix) || defined(__ultrix) || defined(__NetBSD__)\n #\t define ULTRIX\n #      else\n@@ -726,6 +729,7 @@\n #     define ELF_CLASS ELFCLASS64\n #   else\n #     define ALIGNMENT 4\t/* Required by hardware\t*/\n+#     define CPP_WORDSZ 32\n #   endif\n #   define ALIGN_DOUBLE\n #   ifdef SUNOS5\n@@ -735,8 +739,12 @@\n \textern char * GC_SysVGetDataStart();\n #       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n #\tdefine DATAEND (&_end)\n-#\tifndef USE_MMAP\n+#\tif !defined(USE_MMAP) && defined(REDIRECT_MALLOC)\n #\t    define USE_MMAP\n+\t    /* Otherwise we now use calloc.  Mmap may result in the\t*/\n+\t    /* heap interleaved with thread stacks, which can result in\t*/\n+\t    /* excessive blacklisting.  Sbrk is unusable since it\t*/\n+\t    /* doesn't interact correctly with the system malloc.\t*/\n #\tendif\n #       ifdef USE_MMAP\n #         define HEAP_START (ptr_t)0x40000000\n@@ -760,7 +768,9 @@\n #       define GETPAGESIZE()  sysconf(_SC_PAGESIZE)\n \t\t/* getpagesize() appeared to be missing from at least one */\n \t\t/* Solaris 5.4 installation.  Weird.\t\t\t  */\n-#\tdefine DYNAMIC_LOADING\n+#       if CPP_WORDSZ == 32\n+#\t  define DYNAMIC_LOADING\n+#    \tendif\n #   endif\n #   ifdef SUNOS4\n #\tdefine OS_TYPE \"SUNOS4\"\n@@ -782,7 +792,6 @@\n # \tdefine DYNAMIC_LOADING\n #   endif\n #   ifdef DRSNX\n-#       define CPP_WORDSZ 32\n #\tdefine OS_TYPE \"DRSNX\"\n \textern char * GC_SysVGetDataStart();\n \textern int etext;\n@@ -805,7 +814,6 @@\n #     ifdef __arch64__\n #       define STACKBOTTOM ((ptr_t) 0x80000000000ULL)\n #\tdefine DATASTART (ptr_t)GC_SysVGetDataStart(0x100000, &_etext)\n-#\tdefine CPP_WORDSZ 64\n #     else\n #       define STACKBOTTOM ((ptr_t) 0xf0000000)\n #\tdefine DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n@@ -858,7 +866,7 @@\n #   endif\n #   ifdef SUNOS5\n #\tdefine OS_TYPE \"SUNOS5\"\n-  \textern int _etext, _end;\n+        extern int _etext, _end;\n   \textern char * GC_SysVGetDataStart();\n #       define DATASTART GC_SysVGetDataStart(0x1000, &_etext)\n #\tdefine DATAEND (&_end)\n@@ -867,15 +875,20 @@\n /* \tbase is a property of the executable, so this should not break\t*/\n /* \told executables.\t\t\t\t\t\t*/\n /*  \tHEURISTIC2 probably works, but this appears to be preferable.\t*/\n-#       include <sys/vmparam.h>\n+#       include <sys/vm.h>\n #\tdefine STACKBOTTOM USRSTACK\n-/** At least in Solaris 2.5, PROC_VDB gives wrong values for dirty bits. */\n+/* At least in Solaris 2.5, PROC_VDB gives wrong values for dirty bits. */\n+/* It appears to be fixed in 2.8 and 2.9.\t\t\t\t*/\n #\tifdef SOLARIS25_PROC_VDB_BUG_FIXED\n #\t  define PROC_VDB\n #\tendif\n #\tdefine DYNAMIC_LOADING\n-#\tifndef USE_MMAP\n+#\tif !defined(USE_MMAP) && defined(REDIRECT_MALLOC)\n #\t    define USE_MMAP\n+\t    /* Otherwise we now use calloc.  Mmap may result in the\t*/\n+\t    /* heap interleaved with thread stacks, which can result in\t*/\n+\t    /* excessive blacklisting.  Sbrk is unusable since it\t*/\n+\t    /* doesn't interact correctly with the system malloc.\t*/\n #\tendif\n #       ifdef USE_MMAP\n #         define HEAP_START (ptr_t)0x40000000\n@@ -900,6 +913,10 @@\n #\tdefine ELF_CLASS ELFCLASS32\n #   endif\n #   ifdef LINUX\n+#\tifndef __GNUC__\n+\t  /* The Intel compiler doesn't like inline assembly */\n+#\t  define USE_GENERIC_PUSH_REGS\n+# \tendif\n #\tdefine OS_TYPE \"LINUX\"\n #       define LINUX_STACKBOTTOM\n #\tif 0\n@@ -1035,6 +1052,8 @@\n #\tifdef __ELF__\n #\t    define DYNAMIC_LOADING\n #\tendif\n+\textern char etext;\n+#\tdefine DATASTART ((ptr_t)(&etext))\n #   endif\n #   ifdef NETBSD\n #\tdefine OS_TYPE \"NETBSD\"\n@@ -1045,7 +1064,7 @@\n #   ifdef BSDI\n #\tdefine OS_TYPE \"BSDI\"\n #   endif\n-#   if defined(OPENBSD) || defined(NETBSD) || defined(FREEBSD) \\\n+#   if defined(OPENBSD) || defined(NETBSD) \\\n         || defined(THREE86BSD) || defined(BSDI)\n #\tdefine HEURISTIC2\n \textern char etext;\n@@ -1113,6 +1132,29 @@\n \t/* instead. But some kernel versions seem to give the wrong\t*/\n \t/* value from /proc.\t\t\t\t\t\t*/\n #   endif /* Linux */\n+#   ifdef EWS4800\n+#      define HEURISTIC2\n+#      if defined(_MIPS_SZPTR) && (_MIPS_SZPTR == 64)\n+         extern int _fdata[], _end[];\n+#        define DATASTART ((ptr_t)_fdata)\n+#        define DATAEND ((ptr_t)_end)\n+#        define CPP_WORDSZ _MIPS_SZPTR\n+#        define ALIGNMENT (_MIPS_SZPTR/8)\n+#      else\n+         extern int etext, edata, end;\n+         extern int _DYNAMIC_LINKING, _gp;\n+#        define DATASTART ((ptr_t)((((word)&etext + 0x3ffff) & ~0x3ffff) \\\n+               + ((word)&etext & 0xffff)))\n+#        define DATAEND (&edata)\n+#        define DATASTART2 (&_DYNAMIC_LINKING \\\n+               ? (ptr_t)(((word)&_gp + 0x8000 + 0x3ffff) & ~0x3ffff) \\\n+               : (ptr_t)&edata)\n+#        define DATAEND2 (&end)\n+#        define ALIGNMENT 4\n+#      endif\n+#      define OS_TYPE \"EWS4800\"\n+#      define USE_GENERIC_PUSH_REGS 1\n+#   endif\n #   ifdef ULTRIX\n #\tdefine HEURISTIC2\n #       define DATASTART (ptr_t)0x10000000\n@@ -1394,7 +1436,13 @@\n #\tdefine BACKING_STORE_BASE ((ptr_t)GC_register_stackbottom)\n #\tdefine SEARCH_FOR_DATA_START\n #\tdefine DATASTART GC_data_start\n-#       define DYNAMIC_LOADING\n+#\tifdef __GNUC__\n+#         define DYNAMIC_LOADING\n+#\telse\n+\t  /* In the Intel compiler environment, we seem to end up with  */\n+\t  /* statically linked executables and an undefined reference\t*/\n+\t  /* to _DYNAMIC\t\t\t\t\t\t*/\n+#  \tendif\n #\tdefine MPROTECT_VDB\n \t\t/* Requires Linux 2.3.47 or later.\t*/\n \textern int _end;\n@@ -1707,17 +1755,68 @@\n \t/* descriptions.\t\t\t\t\t\t*/\n #\tdefine USE_GENERIC_PUSH_REGS\n # endif\n-# if defined(I386) && defined(LINUX)\n+\n+# if defined(SPARC)\n+#   define ASM_CLEAR_CODE\t/* Stack clearing is crucial, and we \t*/\n+\t\t\t\t/* include assembly code to do it well.\t*/\n+# endif\n+\n+/* Can we save call chain in objects for debugging?   \t\t        */\n+/* SET NFRAMES (# of saved frames) and NARGS (#of args for each frame)\t*/\n+/* to reasonable values for the platform.\t\t\t\t*/\n+/* Set SAVE_CALL_CHAIN if we can.  SAVE_CALL_COUNT can be specified at\t*/\n+/* build time, though we feel free to adjust it slightly.\t\t*/\n+/* Define NEED_CALLINFO if we either save the call stack or \t\t*/\n+/* GC_ADD_CALLER is defined.\t\t\t\t\t\t*/\n+#ifdef LINUX\n+# include <features.h>\n+# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 1 || __GLIBC__ > 2\n+#   define HAVE_BUILTIN_BACKTRACE\n+# endif\n+#endif\n+\n+#if defined(SPARC)\n+# define CAN_SAVE_CALL_STACKS\n+# define CAN_SAVE_CALL_ARGS\n+#endif\n+#if defined(I386) && defined(LINUX)\n     /* SAVE_CALL_CHAIN is supported if the code is compiled to save\t*/\n     /* frame pointers by default, i.e. no -fomit-frame-pointer flag.\t*/\n-# ifdef SAVE_CALL_COUNT\n+# define CAN_SAVE_CALL_STACKS\n+# define CAN_SAVE_CALL_ARGS\n+#endif\n+#if defined(HAVE_BUILTIN_BACKTRACE) && !defined(CAN_SAVE_CALL_STACKS)\n+# define CAN_SAVE_CALL_STACKS\n+#endif\n+\n+# if defined(SAVE_CALL_COUNT) && !defined(GC_ADD_CALLER) \\\n+     && defined(CAN_SAVE_CALL_STACKS)\n #   define SAVE_CALL_CHAIN \n # endif\n+# ifdef SAVE_CALL_CHAIN\n+#   if defined(SAVE_CALL_NARGS) && defined(CAN_SAVE_CALL_ARGS)\n+#     define NARGS SAVE_CALL_NARGS\n+#   else\n+#     define NARGS 0\t/* Number of arguments to save for each call.\t*/\n+#   endif\n # endif\n-# if defined(SPARC)\n-#   define SAVE_CALL_CHAIN\n-#   define ASM_CLEAR_CODE\t/* Stack clearing is crucial, and we \t*/\n-\t\t\t\t/* include assembly code to do it well.\t*/\n+# ifdef SAVE_CALL_CHAIN\n+#   ifndef SAVE_CALL_COUNT\n+#     define NFRAMES 6\t/* Number of frames to save. Even for\t\t*/\n+\t\t\t/* alignment reasons.\t\t\t\t*/\n+#   else\n+#     define NFRAMES ((SAVE_CALL_COUNT + 1) & ~1)\n+#   endif\n+#   define NEED_CALLINFO\n+# endif /* SAVE_CALL_CHAIN */\n+# ifdef GC_ADD_CALLER\n+#   define NFRAMES 1\n+#   define NARGS 0\n+#   define NEED_CALLINFO\n+# endif\n+\n+# if defined(MAKE_BACK_GRAPH) && !defined(DBG_HDRS_ALL)\n+#   define DBG_HDRS_ALL\n # endif\n \n # endif /* GCCONFIG_H */"}, {"sha": "12204fdabc2f606b5bfe541d900852427bb16ba2", "filename": "boehm-gc/irix_threads.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Firix_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Firix_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Firix_threads.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -141,8 +141,6 @@ GC_bool GC_thr_initialized = FALSE;\n \n size_t GC_min_stack_sz;\n \n-size_t GC_page_sz;\n-\n # define N_FREE_LISTS 25\n ptr_t GC_stack_free_lists[N_FREE_LISTS] = { 0 };\n \t\t/* GC_stack_free_lists[i] is free list for stacks of \t*/\n@@ -171,14 +169,14 @@ ptr_t GC_stack_alloc(size_t * stack_size)\n     if (result != 0) {\n         GC_stack_free_lists[index] = *(ptr_t *)result;\n     } else {\n-        result = (ptr_t) GC_scratch_alloc(search_sz + 2*GC_page_sz);\n-        result = (ptr_t)(((word)result + GC_page_sz) & ~(GC_page_sz - 1));\n+        result = (ptr_t) GC_scratch_alloc(search_sz + 2*GC_page_size);\n+        result = (ptr_t)(((word)result + GC_page_size) & ~(GC_page_size - 1));\n         /* Protect hottest page to detect overflow. */\n #\tifdef STACK_GROWS_UP\n-          /* mprotect(result + search_sz, GC_page_sz, PROT_NONE); */\n+          /* mprotect(result + search_sz, GC_page_size, PROT_NONE); */\n #\telse\n-          /* mprotect(result, GC_page_sz, PROT_NONE); */\n-          result += GC_page_sz;\n+          /* mprotect(result, GC_page_size, PROT_NONE); */\n+          result += GC_page_size;\n #\tendif\n     }\n     *stack_size = search_sz;\n@@ -438,7 +436,6 @@ void GC_thr_init()\n     if (GC_thr_initialized) return;\n     GC_thr_initialized = TRUE;\n     GC_min_stack_sz = HBLKSIZE;\n-    GC_page_sz = sysconf(_SC_PAGESIZE);\n     (void) sigaction(SIG_SUSPEND, 0, &act);\n     if (act.sa_handler != SIG_DFL)\n     \tABORT(\"Previously installed SIG_SUSPEND handler\");\n@@ -602,7 +599,7 @@ GC_pthread_create(pthread_t *new_thread,\n     si -> start_routine = start_routine;\n     si -> arg = arg;\n     LOCK();\n-    if (!GC_thr_initialized) GC_thr_init();\n+    if (!GC_initialized) GC_init();\n     if (NULL == attr) {\n         stack = 0;\n \t(void) pthread_attr_init(&new_attr);"}, {"sha": "b26988cef9e5d5b0158148b4b8149e9d09180c2c", "filename": "boehm-gc/linux_threads.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Flinux_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Flinux_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Flinux_threads.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -1268,6 +1268,17 @@ int WRAP_FUNC(pthread_join)(pthread_t thread, void **retval)\n     /* cant have been recycled by pthreads.\t\t\t\t*/\n     UNLOCK();\n     result = REAL_FUNC(pthread_join)(thread, retval);\n+# if defined (GC_FREEBSD_THREADS)\n+    /* On FreeBSD, the wrapped pthread_join() sometimes returns (what\n+       appears to be) a spurious EINTR which caused the test and real code\n+       to gratuitously fail.  Having looked at system pthread library source\n+       code, I see how this return code may be generated.  In one path of\n+       code, pthread_join() just returns the errno setting of the thread\n+       being joined.  This does not match the POSIX specification or the\n+       local man pages thus I have taken the liberty to catch this one\n+       spurious return value properly conditionalized on GC_FREEBSD_THREADS. */\n+    if (result == EINTR) result = 0;\n+# endif\n     if (result == 0) {\n         LOCK();\n         /* Here the pthread thread id may have been recycled. */"}, {"sha": "b582db034df62c6fc38dc7fe2699156014510667", "filename": "boehm-gc/mach_dep.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fmach_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fmach_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmach_dep.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -429,7 +429,7 @@ ptr_t cold_gc_frame;\n \t\t    *i = 0;\n \t\t}\n #\t      if defined(POWERPC) || defined(MSWIN32) || defined(MSWINCE) \\\n-\t         || defined(UTS4) || defined(LINUX)\n+                || defined(UTS4) || defined(LINUX) || defined(EWS4800)\n \t\t  (void) setjmp(regs);\n #\t      else\n \t          (void) _setjmp(regs);\n@@ -492,8 +492,10 @@ ptr_t cold_gc_frame;\n /* On IA64, we also need to flush register windows.  But they end\t*/\n /* up on the other side of the stack segment.\t\t\t\t*/\n /* Returns the backing store pointer for the register stack.\t\t*/\n-/* We implement this as a separate file in HP/UX.\t\t\t*/\n-# ifdef IA64\n+/* We now implement this as a separate assembly file, since inline\t*/\n+/* assembly code here doesn't work with either the Intel or HP \t\t*/\n+/* compilers.\t\t\t\t\t\t\t\t*/\n+# if 0\n #   ifdef LINUX\n \tasm(\"        .text\");\n \tasm(\"        .psr abi64\");"}, {"sha": "5ac21421beab26592795843cdf4a33cb5e43d7ef", "filename": "boehm-gc/malloc.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmalloc.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -337,6 +337,20 @@ DCL_LOCK_STATE;\n   {\n     return((GC_PTR)REDIRECT_MALLOC(n*lb));\n   }\n+\n+# include <string.h>\n+# ifdef __STDC__\n+    char *strdup(const char *s)\n+# else\n+    char *strdup(s)\n+    char *s;\n+# endif\n+  {\n+    size_t len = strlen + 1;\n+    char * result = ((char *)REDIRECT_MALLOC(len+1));\n+    BCOPY(s, result, len+1);\n+    return result;\n+  }\n # endif /* REDIRECT_MALLOC */\n \n /* Explicitly deallocate an object p.\t\t\t\t*/"}, {"sha": "70ba135f1ab060c322c4d963454e557c02899512", "filename": "boehm-gc/mark.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fmark.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fmark.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -838,7 +838,7 @@ long GC_markers = 2;\t\t/* Normally changed by thread-library-\t*/\n \t\t\t\t/* -specific code.\t\t\t*/\n \n /* Mark using the local mark stack until the global mark stack is empty\t*/\n-/* and ther are no active workers.  Update GC_first_nonempty to reflect\t*/\n+/* and there are no active workers. Update GC_first_nonempty to reflect\t*/\n /* progress.\t\t\t\t\t\t\t\t*/\n /* Caller does not hold mark lock.\t\t\t\t\t*/\n /* Caller has already incremented GC_helper_count.  We decrement it,\t*/\n@@ -918,7 +918,7 @@ void GC_mark_local(mse *local_mark_stack, int id)\n \t\t    return;\n \t\t}\n \t\t/* else there's something on the stack again, or\t*/\n-\t\t/* another help may push something.\t\t\t*/\n+\t\t/* another helper may push something.\t\t\t*/\n \t\tGC_active_count++;\n \t        GC_ASSERT(GC_active_count > 0);\n \t\tGC_release_mark_lock();\n@@ -950,8 +950,10 @@ void GC_do_parallel_mark()\n \n     GC_acquire_mark_lock();\n     GC_ASSERT(I_HOLD_LOCK());\n-    GC_ASSERT(!GC_help_wanted);\n-    GC_ASSERT(GC_active_count == 0);\n+    /* This could be a GC_ASSERT, but it seems safer to keep it on\t*/\n+    /* all the time, especially since it's cheap.\t\t\t*/\n+    if (GC_help_wanted || GC_active_count != 0 || GC_helper_count != 0)\n+\tABORT(\"Tried to start parallel mark in bad state\");\n #   ifdef PRINTSTATS\n \tGC_printf1(\"Starting marking for mark phase number %lu\\n\",\n \t\t   (unsigned long)GC_mark_no);\n@@ -1374,11 +1376,11 @@ ptr_t cold_gc_frame;\n \treturn;\n     }\n #   ifdef STACK_GROWS_DOWN\n-\tGC_push_all_eager(bottom, cold_gc_frame);\n \tGC_push_all(cold_gc_frame - sizeof(ptr_t), top);\n+\tGC_push_all_eager(bottom, cold_gc_frame);\n #   else /* STACK_GROWS_UP */\n-\tGC_push_all_eager(cold_gc_frame, top);\n \tGC_push_all(bottom, cold_gc_frame + sizeof(ptr_t));\n+\tGC_push_all_eager(cold_gc_frame, top);\n #   endif /* STACK_GROWS_UP */\n   } else {\n     GC_push_all_eager(bottom, top);"}, {"sha": "628cba289acaecf5bc36914c14257c0e7c5e5eb6", "filename": "boehm-gc/mark_rts.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fmark_rts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fmark_rts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark_rts.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -252,7 +252,7 @@ GC_bool tmp;\n     n_root_sets++;\n }\n \n-static roots_were_cleared = FALSE;\n+static GC_bool roots_were_cleared = FALSE;\n \n void GC_clear_roots GC_PROTO((void))\n {\n@@ -521,16 +521,6 @@ ptr_t cold_gc_frame;\n {\n     register int i;\n \n-    /*\n-     * push registers - i.e., call GC_push_one(r) for each\n-     * register contents r.\n-     */\n-#   ifdef USE_GENERIC_PUSH_REGS\n-\tGC_generic_push_regs(cold_gc_frame);\n-#   else\n-        GC_push_regs(); /* usually defined in machine_dep.c */\n-#   endif\n-        \n     /*\n      * Next push static data.  This must happen early on, since it's\n      * not robust against mark stack overflow.\n@@ -564,19 +554,30 @@ ptr_t cold_gc_frame;\n #      endif\n \n     /*\n-     * Now traverse stacks.\n+     * Now traverse stacks, and mark from register contents.\n+     * These must be done last, since they can legitimately overflow\n+     * the mark stack.\n      */\n-#   if !defined(USE_GENERIC_PUSH_REGS)\n+#   ifdef USE_GENERIC_PUSH_REGS\n+\tGC_generic_push_regs(cold_gc_frame);\n+\t/* Also pushes stack, so that we catch callee-save registers\t*/\n+\t/* saved inside the GC_push_regs frame.\t\t\t\t*/\n+#   else\n+       /*\n+        * push registers - i.e., call GC_push_one(r) for each\n+        * register contents r.\n+        */\n+        GC_push_regs(); /* usually defined in machine_dep.c */\n \tGC_push_current_stack(cold_gc_frame);\n \t/* In the threads case, this only pushes collector frames.      */\n-\t/* In the USE_GENERIC_PUSH_REGS case, this is done inside\t*/\n-\t/* GC_push_regs, so that we catch callee-save registers saved\t*/\n-\t/* inside the GC_push_regs frame.\t\t\t\t*/\n \t/* In the case of linux threads on IA64, the hot section of\t*/\n \t/* the main stack is marked here, but the register stack\t*/\n \t/* backing store is handled in the threads-specific code.\t*/\n #   endif\n     if (GC_push_other_roots != 0) (*GC_push_other_roots)();\n     \t/* In the threads case, this also pushes thread stacks.\t*/\n+        /* Note that without interior pointer recognition lots\t*/\n+    \t/* of stuff may have been pushed already, and this\t*/\n+    \t/* should be careful about mark stack overflows.\t*/\n }\n "}, {"sha": "079a037a4aea8d999c0a8c6962d285a0c7e47d3e", "filename": "boehm-gc/misc.c", "status": "modified", "additions": 114, "deletions": 11, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmisc.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -1,6 +1,7 @@\n /* \n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1999-2001 by Hewlett-Packard Company. All rights reserved.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -97,6 +98,8 @@ GC_bool GC_quiet = 0;\n \n GC_bool GC_print_stats = 0;\n \n+GC_bool GC_print_back_height = 0;\n+\n #ifdef FIND_LEAK\n   int GC_find_leak = 1;\n #else\n@@ -479,6 +482,12 @@ int sig;\n }\n #endif\n \n+#ifdef MSWIN32\n+  extern GC_bool GC_is_win32s();\n+#else\n+# define GC_is_win32s() FALSE\n+#endif\n+\n void GC_init_inner()\n {\n #   if !defined(THREADS) && defined(GC_ASSERTIONS)\n@@ -502,6 +511,22 @@ void GC_init_inner()\n     if (0 != GETENV(\"GC_DONT_GC\")) {\n       GC_dont_gc = 1;\n     }\n+    if (0 != GETENV(\"GC_PRINT_BACK_HEIGHT\")) {\n+      GC_print_back_height = 1;\n+    }\n+    {\n+      char * time_limit_string = GETENV(\"GC_PAUSE_TIME_TARGET\");\n+      if (0 != time_limit_string) {\n+        long time_limit;\n+        if (time_limit_string != 0) time_limit = atol(time_limit_string);\n+        if (time_limit < 5) {\n+\t  WARN(\"GC_PAUSE_TIME_TARGET environment variable value too small \"\n+\t       \"or bad syntax: Ignoring\\n\", 0);\n+        } else {\n+\t  GC_time_limit = time_limit;\n+        }\n+      }\n+    }\n #   ifdef UNIX_LIKE\n       if (0 != GETENV(\"GC_LOOP_ON_ABORT\")) {\n         GC_set_and_save_fault_handler(looping_handler);\n@@ -611,8 +636,19 @@ void GC_init_inner()\n       PCR_IL_Unlock();\n       GC_pcr_install();\n #   endif\n-    /* Get black list set up */\n-      if (!GC_dont_precollect) GC_gcollect_inner();\n+#   if !defined(SMALL_CONFIG)\n+      if (!GC_is_win32s() && 0 != GETENV(\"GC_ENABLE_INCREMENTAL\")) {\n+\tGC_ASSERT(!GC_incremental);\n+        GC_setpagesize();\n+#       ifndef GC_SOLARIS_THREADS\n+          GC_dirty_init();\n+#       endif\n+        GC_ASSERT(GC_words_allocd == 0)\n+    \tGC_incremental = TRUE;\n+      }\n+#   endif /* !SMALL_CONFIG */\n+    /* Get black list set up and/or incrmental GC started */\n+      if (!GC_dont_precollect || GC_incremental) GC_gcollect_inner();\n     GC_is_initialized = TRUE;\n #   ifdef STUBBORN_ALLOC\n     \tGC_stubborn_init();\n@@ -645,20 +681,14 @@ void GC_enable_incremental GC_PROTO(())\n     LOCK();\n     if (GC_incremental) goto out;\n     GC_setpagesize();\n-#   ifdef MSWIN32\n-      {\n-        extern GC_bool GC_is_win32s();\n-\n-\t/* VirtualProtect is not functional under win32s.\t*/\n-\tif (GC_is_win32s()) goto out;\n-      }\n-#   endif /* MSWIN32 */\n+    if (GC_is_win32s()) goto out;\n #   ifndef GC_SOLARIS_THREADS\n         GC_dirty_init();\n #   endif\n     if (!GC_is_initialized) {\n         GC_init_inner();\n     }\n+    if (GC_incremental) goto out;\n     if (GC_dont_gc) {\n         /* Can't easily do it. */\n         UNLOCK();\n@@ -900,6 +930,13 @@ GC_CONST char * msg;\n \n #ifdef NEED_CALLINFO\n \n+#ifdef HAVE_BUILTIN_BACKTRACE\n+# include <execinfo.h>\n+# ifdef LINUX\n+#   include <unistd.h>\n+# endif\n+#endif\n+\n void GC_print_callers (info)\n struct callinfo info[NFRAMES];\n {\n@@ -925,7 +962,73 @@ struct callinfo info[NFRAMES];\n \t  GC_err_printf0(\"\\n\");\n \t}\n # \tendif\n-     \tGC_err_printf1(\"\\t\\t##PC##= 0x%X\\n\", info[i].ci_pc);\n+#\tif defined(HAVE_BUILTIN_BACKTRACE) && !defined(REDIRECT_MALLOC)\n+\t  /* Unfortunately backtrace_symbols calls malloc, which makes  */\n+\t  /* it dangersous if that has been redirected.\t\t\t*/\n+\t  {\n+\t    char **sym_name =\n+\t      backtrace_symbols((void **)(&(info[i].ci_pc)), 1);\n+\t    char *name = sym_name[0];\n+\t    GC_bool found_it = (strchr(name, '(') != 0);\n+\t    FILE *pipe;\n+#\t    ifdef LINUX\n+\t      if (!found_it) {\n+#\t        define EXE_SZ 100\n+\t\tstatic char exe_name[EXE_SZ];\n+#\t\tdefine CMD_SZ 200\n+\t\tchar cmd_buf[CMD_SZ];\n+#\t\tdefine RESULT_SZ 200\n+\t\tstatic char result_buf[RESULT_SZ];\n+\t\tsize_t result_len;\n+\t\tstatic GC_bool found_exe_name = FALSE;\n+\t\tstatic GC_bool will_fail = FALSE;\n+\t\tint ret_code;\n+\t\t/* Unfortunately, this is the common case for the \t*/\n+\t\t/* main executable.\t\t\t\t\t*/\n+\t\t/* Try to get it via a hairy and expensive scheme.\t*/\n+\t\t/* First we get the name of the executable:\t\t*/\n+\t\tif (will_fail) goto out;\n+\t\tif (!found_exe_name) { \n+\t\t  ret_code = readlink(\"/proc/self/exe\", exe_name, EXE_SZ);\n+\t\t  if (ret_code < 0 || ret_code >= EXE_SZ || exe_name[0] != '/') {\n+\t\t    will_fail = TRUE;\t/* Dont try again. */\n+\t\t    goto out;\n+\t\t  }\n+\t\t  exe_name[ret_code] = '\\0';\n+\t\t  found_exe_name = TRUE;\n+\t\t}\n+\t\t/* Then we use popen to start addr2line -e <exe> <addr>\t*/\n+\t\t/* There are faster ways to do this, but hopefully this\t*/\n+\t\t/* isn't time critical.\t\t\t\t\t*/\n+\t\tsprintf(cmd_buf, \"/usr/bin/addr2line -e %s 0x%lx\", exe_name,\n+\t\t\t\t (unsigned long)info[i].ci_pc);\n+\t\tpipe = popen(cmd_buf, \"r\");\n+\t\tif (pipe < 0 || fgets(result_buf, RESULT_SZ, pipe) == 0) {\n+\t\t  will_fail = TRUE;\n+\t\t  goto out;\n+\t\t}\n+\t\tresult_len = strlen(result_buf);\n+\t\tif (result_buf[result_len - 1] == '\\n') --result_len;\n+\t\tif (result_buf[0] == '?'\n+\t\t    || result_buf[result_len-2] == ':' \n+\t\t       && result_buf[result_len-1] == '0')\n+\t\t    goto out;\n+\t\tif (result_len < RESULT_SZ - 25) {\n+\t\t  /* Add in hex address\t*/\n+\t\t    sprintf(result_buf + result_len, \" [0x%lx]\",\n+\t\t\t  (unsigned long)info[i].ci_pc);\n+\t\t}\n+\t\tname = result_buf;\n+\t\tpclose(pipe);\n+\t\tout:\n+\t      }\n+#\t    endif\n+\t    GC_err_printf1(\"\\t\\t%s\\n\", name);\n+\t    free(sym_name);\n+\t  }\n+#\telse\n+     \t  GC_err_printf1(\"\\t\\t##PC##= 0x%lx\\n\", info[i].ci_pc);\n+#\tendif\n     }\n }\n "}, {"sha": "ae1125664e325f69a332408c527fc4ea98438f17", "filename": "boehm-gc/os_dep.c", "status": "modified", "additions": 167, "deletions": 34, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fos_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fos_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fos_dep.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -1101,6 +1101,9 @@ void GC_register_data_segments()\n \tGC_add_roots_inner(DATASTART, (char *)sbrk(0), FALSE);\n #     else\n \tGC_add_roots_inner(DATASTART, (char *)(DATAEND), FALSE);\n+#       if defined(DATASTART2)\n+         GC_add_roots_inner(DATASTART2, (char *)(DATAEND2), FALSE);\n+#       endif\n #     endif\n #   endif\n #   if !defined(PCR) && (defined(NEXT) || defined(MACOSX))\n@@ -1299,16 +1302,22 @@ void * os2_alloc(size_t bytes)\n SYSTEM_INFO GC_sysinfo;\n # endif\n \n-\n # ifdef MSWIN32\n+\n+# ifdef USE_GLOBAL_ALLOC\n+#   define GLOBAL_ALLOC_TEST 1\n+# else\n+#   define GLOBAL_ALLOC_TEST GC_win32s\n+# endif\n+\n word GC_n_heap_bases = 0;\n \n ptr_t GC_win32_get_mem(bytes)\n word bytes;\n {\n     ptr_t result;\n \n-    if (GC_win32s) {\n+    if (GLOBAL_ALLOC_TEST) {\n     \t/* VirtualAlloc doesn't like PAGE_EXECUTE_READWRITE.\t*/\n     \t/* There are also unconfirmed rumors of other\t\t*/\n     \t/* problems, so we dodge the issue.\t\t\t*/\n@@ -1742,11 +1751,18 @@ word n;\n {\n }\n \n-/* A call hints that h is about to be written.\t*/\n-/* May speed up some dirty bit implementations.\t*/\n+/* A call that:\t\t\t\t\t\t*/\n+/* I) hints that [h, h+nblocks) is about to be written.\t*/\n+/* II) guarantees that protection is removed.\t\t*/\n+/* (I) may speed up some dirty bit implementations.\t*/\n+/* (II) may be essential if we need to ensure that\t*/\n+/* pointer-free system call buffers in the heap are \t*/\n+/* not protected.\t\t\t\t\t*/\n /*ARGSUSED*/\n-void GC_write_hint(h)\n+void GC_remove_protection(h, nblocks, is_ptrfree)\n struct hblk *h;\n+word nblocks;\n+GC_bool is_ptrfree;\n {\n }\n \n@@ -1849,12 +1865,16 @@ struct hblk *h;\n # endif\n #endif\n #if defined(LINUX)\n-#   include <linux/version.h>\n-#   if (LINUX_VERSION_CODE >= 0x20100) && !defined(M68K) || defined(ALPHA) || defined(IA64)\n+#   if __GLIBC__ > 2 || __GLIBC__ == 2 && __GLIBC_MINOR__ >= 2\n       typedef struct sigcontext s_c;\n-#   else\n-      typedef struct sigcontext_struct s_c;\n-#   endif\n+#   else  /* glibc < 2.2 */\n+#     include <linux/version.h>\n+#     if (LINUX_VERSION_CODE >= 0x20100) && !defined(M68K) || defined(ALPHA)\n+        typedef struct sigcontext s_c;\n+#     else\n+        typedef struct sigcontext_struct s_c;\n+#     endif\n+#   endif  /* glibc < 2.2 */\n #   if defined(ALPHA) || defined(M68K)\n       typedef void (* REAL_SIG_PF)(int, int, s_c *);\n #   else\n@@ -2320,29 +2340,33 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n \n /*\n  * We hold the allocation lock.  We expect block h to be written\n- * shortly.\n+ * shortly.  Ensure that all pages cvontaining any part of the n hblks\n+ * starting at h are no longer protected.  If is_ptrfree is false,\n+ * also ensure that they will subsequently appear to be dirty.\n  */\n-void GC_write_hint(h)\n+void GC_remove_protection(h, nblocks, is_ptrfree)\n struct hblk *h;\n+word nblocks;\n+GC_bool is_ptrfree;\n {\n-    register struct hblk * h_trunc;\n-    register unsigned i;\n-    register GC_bool found_clean;\n+    struct hblk * h_trunc;  /* Truncated to page boundary */\n+    struct hblk * h_end;    /* Page boundary following block end */\n+    struct hblk * current;\n+    GC_bool found_clean;\n     \n     if (!GC_dirty_maintained) return;\n     h_trunc = (struct hblk *)((word)h & ~(GC_page_size-1));\n+    h_end = (struct hblk *)(((word)(h + nblocks) + GC_page_size-1)\n+\t                    & ~(GC_page_size-1));\n     found_clean = FALSE;\n-    for (i = 0; i < divHBLKSZ(GC_page_size); i++) {\n-        register int index = PHT_HASH(h_trunc+i);\n+    for (current = h_trunc; current < h_end; ++current) {\n+        int index = PHT_HASH(current);\n             \n-        if (!get_pht_entry_from_index(GC_dirty_pages, index)) {\n-            found_clean = TRUE;\n+        if (!is_ptrfree || current < h || current >= h + nblocks) {\n             async_set_pht_entry_from_index(GC_dirty_pages, index);\n         }\n     }\n-    if (found_clean) {\n-    \tUNPROTECT(h_trunc, GC_page_size);\n-    }\n+    UNPROTECT(h_trunc, (ptr_t)h_end - (ptr_t)h_trunc);\n }\n \n void GC_dirty_init()\n@@ -2461,18 +2485,77 @@ void GC_dirty_init()\n #   endif\n }\n \n+int GC_incremental_protection_needs()\n+{\n+    if (GC_page_size == HBLKSIZE) {\n+\treturn GC_PROTECTS_POINTER_HEAP;\n+    } else {\n+\treturn GC_PROTECTS_POINTER_HEAP | GC_PROTECTS_PTRFREE_HEAP;\n+    }\n+}\n \n+#define HAVE_INCREMENTAL_PROTECTION_NEEDS\n \n+#define IS_PTRFREE(hhdr) ((hhdr)->hb_descr == 0)\n+\n+#define PAGE_ALIGNED(x) !((word)(x) & (GC_page_size - 1))\n void GC_protect_heap()\n {\n     ptr_t start;\n     word len;\n+    struct hblk * current;\n+    struct hblk * current_start;  /* Start of block to be protected. */\n+    struct hblk * limit;\n     unsigned i;\n-    \n+    GC_bool protect_all = \n+\t  (0 != (GC_incremental_protection_needs() & GC_PROTECTS_PTRFREE_HEAP));\n     for (i = 0; i < GC_n_heap_sects; i++) {\n         start = GC_heap_sects[i].hs_start;\n         len = GC_heap_sects[i].hs_bytes;\n-        PROTECT(start, len);\n+\tif (protect_all) {\n+          PROTECT(start, len);\n+\t} else {\n+\t  GC_ASSERT(PAGE_ALIGNED(len))\n+\t  GC_ASSERT(PAGE_ALIGNED(start))\n+\t  current_start = current = (struct hblk *)start;\n+\t  limit = (struct hblk *)(start + len);\n+\t  while (current < limit) {\n+            hdr * hhdr;\n+\t    word nhblks;\n+\t    GC_bool is_ptrfree;\n+\n+\t    GC_ASSERT(PAGE_ALIGNED(current));\n+\t    GET_HDR(current, hhdr);\n+\t    if (IS_FORWARDING_ADDR_OR_NIL(hhdr)) {\n+\t      /* This can happen only if we're at the beginning of a \t*/\n+\t      /* heap segment, and a block spans heap segments.\t\t*/\n+\t      /* We will handle that block as part of the preceding\t*/\n+\t      /* segment.\t\t\t\t\t\t*/\n+\t      GC_ASSERT(current_start == current);\n+\t      current_start = ++current;\n+\t      continue;\n+\t    }\n+\t    if (HBLK_IS_FREE(hhdr)) {\n+\t      GC_ASSERT(PAGE_ALIGNED(hhdr -> hb_sz));\n+\t      nhblks = divHBLKSZ(hhdr -> hb_sz);\n+\t      is_ptrfree = TRUE;\t/* dirty on alloc */\n+\t    } else {\n+\t      nhblks = OBJ_SZ_TO_BLOCKS(hhdr -> hb_sz);\n+\t      is_ptrfree = IS_PTRFREE(hhdr);\n+\t    }\n+\t    if (is_ptrfree) {\n+\t      if (current_start < current) {\n+\t\tPROTECT(current_start, (ptr_t)current - (ptr_t)current_start);\n+\t      }\n+\t      current_start = (current += nhblks);\n+\t    } else {\n+\t      current += nhblks;\n+\t    }\n+\t  } \n+\t  if (current_start < current) {\n+\t    PROTECT(current_start, (ptr_t)current - (ptr_t)current_start);\n+\t  }\n+\t}\n     }\n }\n \n@@ -2529,7 +2612,7 @@ word len;\n     register struct hblk *h;\n     ptr_t obj_start;\n     \n-    if (!GC_incremental) return;\n+    if (!GC_dirty_maintained) return;\n     obj_start = GC_base(addr);\n     if (obj_start == 0) return;\n     if (GC_base(addr + len - 1) != obj_start) {\n@@ -2547,11 +2630,15 @@ word len;\n     \t      ((ptr_t)end_block - (ptr_t)start_block) + HBLKSIZE);\n }\n \n-#if !defined(MSWIN32) && !defined(MSWINCE) && !defined(GC_LINUX_THREADS) \\\n+#if !defined(MSWIN32) && !defined(MSWINCE) && !defined(THREADS) \\\n     && !defined(GC_USE_LD_WRAP)\n-/* Replacement for UNIX system call.\t */\n-/* Other calls that write to the heap\t */\n-/* should be handled similarly.\t\t */\n+/* Replacement for UNIX system call.\t\t\t\t\t */\n+/* Other calls that write to the heap should be handled similarly.\t */\n+/* Note that this doesn't work well for blocking reads:  It will hold\t */\n+/* tha allocation lock for the entur duration of the call. Multithreaded */\n+/* clients should really ensure that it won't block, either by setting \t */\n+/* the descriptor nonblocking, or by calling select or poll first, to\t */\n+/* make sure that input is available.\t\t\t\t\t */\n # if defined(__STDC__) && !defined(SUNOS4)\n #   include <unistd.h>\n #   include <sys/uio.h>\n@@ -2599,7 +2686,7 @@ word len;\n }\n #endif /* !MSWIN32 && !MSWINCE && !GC_LINUX_THREADS */\n \n-#ifdef GC_USE_LD_WRAP\n+#if defined(GC_USE_LD_WRAP) && !defined(THREADS)\n     /* We use the GNU ld call wrapping facility.\t\t\t*/\n     /* This requires that the linker be invoked with \"--wrap read\".\t*/\n     /* This can be done by passing -Wl,\"--wrap read\" to gcc.\t\t*/\n@@ -2738,8 +2825,10 @@ void GC_dirty_init()\n \n /* Ignore write hints. They don't help us here.\t*/\n /*ARGSUSED*/\n-void GC_write_hint(h)\n+void GC_remove_protection(h, nblocks, is_ptrfree)\n struct hblk *h;\n+word nblocks;\n+GC_bool is_ptrfree;\n {\n }\n \n@@ -2947,15 +3036,24 @@ struct hblk *h;\n }\n \n /*ARGSUSED*/\n-void GC_write_hint(h)\n+void GC_remove_protection(h, nblocks, is_ptrfree)\n struct hblk *h;\n+word nblocks;\n+GC_bool is_ptrfree;\n {\n-    PCR_VD_WriteProtectDisable(h, HBLKSIZE);\n-    PCR_VD_WriteProtectEnable(h, HBLKSIZE);\n+    PCR_VD_WriteProtectDisable(h, nblocks*HBLKSIZE);\n+    PCR_VD_WriteProtectEnable(h, nblocks*HBLKSIZE);\n }\n \n # endif /* PCR_VDB */\n \n+# ifndef HAVE_INCREMENTAL_PROTECTION_NEEDS\n+  int GC_incremental_protection_needs()\n+  {\n+    return GC_PROTECTS_NONE;\n+  }\n+# endif /* !HAVE_INCREMENTAL_PROTECTION_NEEDS */\n+\n /*\n  * Call stack save code for debugging.\n  * Should probably be in mach_dep.c, but that requires reorganization.\n@@ -2965,6 +3063,8 @@ struct hblk *h;\n /* long as the frame pointer is explicitly stored.  In the case of gcc,\t*/\n /* compiler flags (e.g. -fomit-frame-pointer) determine whether it is.\t*/\n #if defined(I386) && defined(LINUX) && defined(SAVE_CALL_CHAIN)\n+#   include <features.h>\n+\n     struct frame {\n \tstruct frame *fr_savfp;\n \tlong\tfr_savpc;\n@@ -2974,6 +3074,8 @@ struct hblk *h;\n \n #if defined(SPARC)\n #  if defined(LINUX)\n+#    include <features.h>\n+\n      struct frame {\n \tlong\tfr_local[8];\n \tlong\tfr_arg[6];\n@@ -3009,6 +3111,35 @@ struct hblk *h;\n /* Fill in the pc and argument information for up to NFRAMES of my\t*/\n /* callers.  Ignore my frame and my callers frame.\t\t\t*/\n \n+#ifdef LINUX\n+# include <features.h>\n+# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 1 || __GLIBC__ > 2\n+#   define HAVE_BUILTIN_BACKTRACE\n+# endif\n+#endif\n+\n+#if NARGS == 0 && NFRAMES % 2 == 0 /* No padding */ \\\n+    && defined(HAVE_BUILTIN_BACKTRACE)\n+\n+#include <execinfo.h>\n+\n+void GC_save_callers (info) \n+struct callinfo info[NFRAMES];\n+{\n+  void * tmp_info[NFRAMES + 1];\n+  int npcs, i;\n+# define IGNORE_FRAMES 1\n+  \n+  /* We retrieve NFRAMES+1 pc values, but discard the first, since it\t*/\n+  /* points to our own frame.\t\t\t\t\t\t*/\n+  GC_ASSERT(sizeof(struct callinfo) == sizeof(void *));\n+  npcs = backtrace((void **)tmp_info, NFRAMES + IGNORE_FRAMES);\n+  BCOPY(tmp_info+IGNORE_FRAMES, info, (npcs - IGNORE_FRAMES) * sizeof(void *));\n+  for (i = npcs - IGNORE_FRAMES; i < NFRAMES; ++i) info[i].ci_pc = 0;\n+}\n+\n+#else /* No builtin backtrace; do it ourselves */\n+\n #if (defined(OPENBSD) || defined(NETBSD)) && defined(SPARC)\n #  define FR_SAVFP fr_fp\n #  define FR_SAVPC fr_pc\n@@ -3055,6 +3186,8 @@ struct callinfo info[NFRAMES];\n   if (nframes < NFRAMES) info[nframes].ci_pc = 0;\n }\n \n+#endif /* No builtin backtrace */\n+\n #endif /* SAVE_CALL_CHAIN */\n \n #if defined(LINUX) && defined(__ELF__) && \\"}, {"sha": "846215edb4f87370ae33b3e939bd5358535c6ef7", "filename": "boehm-gc/reclaim.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Freclaim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Freclaim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Freclaim.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -631,47 +631,41 @@ COUNT_DECL\n     ptr_t result = list;\n \n     GC_ASSERT(GC_find_header((ptr_t)hbp) == hhdr);\n+    GC_remove_protection(hbp, 1, (hhdr)->hb_descr == 0 /* Pointer-free? */);\n     if (init) {\n       switch(sz) {\n #      if !defined(SMALL_CONFIG) && !defined(USE_MARK_BYTES)\n         case 1:\n \t    /* We now issue the hint even if GC_nearly_full returned\t*/\n \t    /* DONT_KNOW.\t\t\t\t\t\t*/\n-\t    GC_write_hint(hbp);\n             result = GC_reclaim1(hbp, hhdr, list COUNT_ARG);\n             break;\n         case 2:\n-\t    GC_write_hint(hbp);\n             result = GC_reclaim_clear2(hbp, hhdr, list COUNT_ARG);\n             break;\n         case 4:\n-\t    GC_write_hint(hbp);\n             result = GC_reclaim_clear4(hbp, hhdr, list COUNT_ARG);\n             break;\n #      endif /* !SMALL_CONFIG && !USE_MARK_BYTES */\n         default:\n-\t    GC_write_hint(hbp);\n             result = GC_reclaim_clear(hbp, hhdr, sz, list COUNT_ARG);\n             break;\n       }\n     } else {\n+      GC_ASSERT((hhdr)->hb_descr == 0 /* Pointer-free block */);\n       switch(sz) {\n #      if !defined(SMALL_CONFIG) && !defined(USE_MARK_BYTES)\n         case 1:\n-\t    GC_write_hint(hbp);\n             result = GC_reclaim1(hbp, hhdr, list COUNT_ARG);\n             break;\n         case 2:\n-\t    GC_write_hint(hbp);\n             result = GC_reclaim_uninit2(hbp, hhdr, list COUNT_ARG);\n             break;\n         case 4:\n-\t    GC_write_hint(hbp);\n             result = GC_reclaim_uninit4(hbp, hhdr, list COUNT_ARG);\n             break;\n #      endif /* !SMALL_CONFIG && !USE_MARK_BYTES */\n         default:\n-\t    GC_write_hint(hbp);\n             result = GC_reclaim_uninit(hbp, hhdr, sz, list COUNT_ARG);\n             break;\n       }"}, {"sha": "bd63e6c612c9abf291631edac2c41339c42517e6", "filename": "boehm-gc/solaris_pthreads.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fsolaris_pthreads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fsolaris_pthreads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_pthreads.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -88,8 +88,8 @@ GC_pthread_create(pthread_t *new_thread,\n     }\n \n     LOCK();\n-    if (!GC_thr_initialized) {\n-\t    GC_thr_init();\n+    if (!GC_is_initialized) {\n+\t    GC_init_inner();\n     }\n     GC_multithreaded++;\n \t    "}, {"sha": "2b520d3d085084fd60554ea35e2a8bb83ea987e4", "filename": "boehm-gc/solaris_threads.c", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fsolaris_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fsolaris_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_threads.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -16,7 +16,7 @@\n  */\n /* Boehm, September 14, 1994 4:44 pm PDT */\n \n-# if defined(GC_SOLARIS_THREADS)\n+# if defined(GC_SOLARIS_THREADS) || defined(GC_SOLARIS_PTHREADS)\n \n # include \"private/gc_priv.h\"\n # include \"private/solaris_threads.h\"\n@@ -414,7 +414,6 @@ GC_bool GC_thr_initialized = FALSE;\n \n size_t GC_min_stack_sz;\n \n-size_t GC_page_sz;\n \n /*\n  * stack_head is stored at the top of free stacks\n@@ -456,7 +455,7 @@ ptr_t GC_stack_alloc(size_t * stack_size)\n         GC_stack_free_lists[index] = GC_stack_free_lists[index]->next;\n     } else {\n #ifdef MMAP_STACKS\n-        base = (ptr_t)mmap(0, search_sz + GC_page_sz,\n+        base = (ptr_t)mmap(0, search_sz + GC_page_size,\n \t\t\t     PROT_READ|PROT_WRITE, MAP_PRIVATE |MAP_NORESERVE,\n \t\t\t     GC_zfd, 0);\n \tif (base == (ptr_t)-1)\n@@ -465,27 +464,27 @@ ptr_t GC_stack_alloc(size_t * stack_size)\n \t\treturn NULL;\n \t}\n \n-\tmprotect(base, GC_page_sz, PROT_NONE);\n-\t/* Should this use divHBLKSZ(search_sz + GC_page_sz) ? -- cf */\n+\tmprotect(base, GC_page_size, PROT_NONE);\n+\t/* Should this use divHBLKSZ(search_sz + GC_page_size) ? -- cf */\n \tGC_is_fresh((struct hblk *)base, divHBLKSZ(search_sz));\n-\tbase += GC_page_sz;\n+\tbase += GC_page_size;\n \n #else\n-        base = (ptr_t) GC_scratch_alloc(search_sz + 2*GC_page_sz);\n+        base = (ptr_t) GC_scratch_alloc(search_sz + 2*GC_page_size);\n \tif (base == NULL)\n \t{\n \t\t*stack_size = 0;\n \t\treturn NULL;\n \t}\n \n-        base = (ptr_t)(((word)base + GC_page_sz) & ~(GC_page_sz - 1));\n+        base = (ptr_t)(((word)base + GC_page_size) & ~(GC_page_size - 1));\n         /* Protect hottest page to detect overflow. */\n #\tifdef SOLARIS23_MPROTECT_BUG_FIXED\n-            mprotect(base, GC_page_sz, PROT_NONE);\n+            mprotect(base, GC_page_size, PROT_NONE);\n #\tendif\n         GC_is_fresh((struct hblk *)base, divHBLKSZ(search_sz));\n \n-        base += GC_page_sz;\n+        base += GC_page_size;\n #endif\n     }\n     *stack_size = search_sz;\n@@ -665,8 +664,8 @@ void GC_my_stack_limits()\n       /* original thread */\n         /* Empirically, what should be the stack page with lowest\t*/\n         /* address is actually inaccessible.\t\t\t\t*/\n-        stack_size = GC_get_orig_stack_size() - GC_page_sz;\n-        stack = GC_stackbottom - stack_size + GC_page_sz;\n+        stack_size = GC_get_orig_stack_size() - GC_page_size;\n+        stack = GC_stackbottom - stack_size + GC_page_size;\n     } else {\n         stack = me -> stack;\n     }\n@@ -704,7 +703,7 @@ void GC_push_all_stacks()\n             top = p -> stack + p -> stack_size;\n         } else {\n             /* The original stack. */\n-            bottom = GC_stackbottom - GC_get_orig_stack_size() + GC_page_sz;\n+            bottom = GC_stackbottom - GC_get_orig_stack_size() + GC_page_size;\n             top = GC_stackbottom;\n         }\n         if ((word)sp > (word)bottom && (word)sp < (word)top) bottom = sp;\n@@ -789,7 +788,6 @@ void GC_thr_init(void)\n     GC_thr_initialized = TRUE;\n     GC_min_stack_sz = ((thr_min_stack() + 32*1024 + HBLKSIZE-1)\n     \t\t       & ~(HBLKSIZE - 1));\n-    GC_page_sz = sysconf(_SC_PAGESIZE);\n #ifdef MMAP_STACKS\n     GC_zfd = open(\"/dev/zero\", O_RDONLY);\n     if (GC_zfd == -1)\n@@ -911,10 +909,7 @@ GC_thr_create(void *stack_base, size_t stack_size,\n     void * stack = stack_base;\n    \n     LOCK();\n-    if (!GC_thr_initialized)\n-    {\n-    GC_thr_init();\n-    }\n+    if (!GC_is_initialized) GC_init_inner();\n     GC_multithreaded++;\n     if (stack == 0) {\n      \tif (stack_size == 0) stack_size = 1024*1024;"}, {"sha": "9f3a4b0a99d8e82b9d428ddcd2d33bef985c1561", "filename": "boehm-gc/sparc_mach_dep.s", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fsparc_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fsparc_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsparc_mach_dep.s?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -9,13 +9,38 @@\n \t.globl \tGC_push_regs\n GC_save_regs_in_stack:\n GC_push_regs:\n+#if defined(__arch64__) || defined(__sparcv9)\n+\tsave\t%sp,-128,%sp\n+\tflushw\n+\tret\n+\t  restore %sp,2047+128,%o0\n+#else /* 32 bit SPARC */\n \tta\t0x3   ! ST_FLUSH_WINDOWS\n \tmov\t%sp,%o0\n \tretl\n \tnop\n+#endif /* 32 bit SPARC */\n+.GC_save_regs_in_stack_end:\n+\t.size GC_save_regs_in_stack,.GC_save_regs_in_stack_end-GC_save_regs_in_stack\n \t\n+\n \t.globl\tGC_clear_stack_inner\n GC_clear_stack_inner:\n+#if defined(__arch64__) || defined(__sparcv9)\n+\tmov %sp,%o2\t\t! Save sp\n+\tadd %sp,2047-8,%o3\t! p = sp+bias-8\n+\tadd %o1,-2047-192,%sp\t! Move sp out of the way,\n+  \t\t\t\t! so that traps still work.\n+  \t\t\t\t! Includes some extra words\n+  \t\t\t\t! so we can be sloppy below.\n+loop:\n+\tstx %g0,[%o3]\t\t! *(long *)p = 0\n+\tcmp %o3,%o1\n+\tbgu,pt %xcc, loop\t! if (p > limit) goto loop\n+          asm(\"add %o3,-8,%o3\t! p -= 8 (delay slot)\n+\tretl\n+    \t  mov %o2,%sp\t\t! Restore sp., delay slot\t\n+#else  /* 32 bit SPARC */\n \tmov\t%sp,%o2\t\t! Save sp\n \tadd\t%sp,-8,%o3\t! p = sp-8\n \tclr\t%g1\t\t! [g0,g1] = 0\n@@ -30,6 +55,10 @@ loop:\n \t  add\t%o3,-8,%o3\t! p -= 8 (delay slot)\n \tretl\n \t  mov\t%o2,%sp\t\t! Restore sp., delay slot\n+#endif  /* 32 bit SPARC */\n+.GC_clear_stack_inner_end:\n+      \t.size GC_clear_stack_inner,.GC_clear_stack_inner_end-GC_clear_stack_inner\n+\n \t\n \t\t\n \t\t"}, {"sha": "7cb4d0c768f9ec30606ae4e758dbf09685450876", "filename": "boehm-gc/tests/test.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Ftests%2Ftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Ftests%2Ftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftests%2Ftest.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -20,7 +20,7 @@\n \n # undef GC_BUILD\n \n-#ifdef DBG_HDRS_ALL\n+#if defined(DBG_HDRS_ALL) || defined(MAKE_BACK_GRAPH)\n #  define GC_DEBUG\n #endif\n \n@@ -1340,7 +1340,7 @@ void SetMinimumStack(long minSize)\n #   endif\n     GC_INIT();\t/* Only needed if gc is dynamic library.\t*/\n     (void) GC_set_warn_proc(warn_proc);\n-#   if defined(MPROTECT_VDB) || defined(PROC_VDB)\n+#   if (defined(MPROTECT_VDB) || defined(PROC_VDB)) && !defined(MAKE_BACK_GRAPH)\n       GC_enable_incremental();\n       (void) GC_printf0(\"Switched to incremental mode\\n\");\n #     if defined(MPROTECT_VDB)\n@@ -1571,7 +1571,9 @@ main()\n \n     n_tests = 0;\n     GC_INIT();\t/* Only needed if gc is dynamic library.\t*/\n-    GC_enable_incremental();\n+#   ifndef MAKE_BACK_GRAPH\n+      GC_enable_incremental();\n+#   endif\n     (void) GC_set_warn_proc(warn_proc);\n     if (thr_keycreate(&fl_key, GC_free) != 0) {\n         (void)GC_printf1(\"Key creation failed %lu\\n\", (unsigned long)code);\n@@ -1628,7 +1630,7 @@ main()\n     \tpthread_attr_setstacksize(&attr, 1000000);\n #   endif\n     n_tests = 0;\n-#   if  defined(MPROTECT_VDB) && !defined(PARALLEL_MARK) &&!defined(REDIRECT_MALLOC)\n+#   if  defined(MPROTECT_VDB) && !defined(PARALLEL_MARK) &&!defined(REDIRECT_MALLOC) && !defined(MAKE_BACK_GRAPH)\n     \tGC_enable_incremental();\n         (void) GC_printf0(\"Switched to incremental mode\\n\");\n \t(void) GC_printf0(\"Emulating dirty bits with mprotect/signals\\n\");"}, {"sha": "99968a94a6cc9cf1f9e5f7a78264c397a07425bb", "filename": "boehm-gc/threadlibs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fthreadlibs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fthreadlibs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fthreadlibs.c?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -10,13 +10,13 @@ int main()\n \t       \"-Wl,--wrap -Wl,pthread_sigmask -Wl,--wrap -Wl,sleep\\n\");\n #   endif\n #   if defined(GC_LINUX_THREADS) || defined(GC_IRIX_THREADS) \\\n-\t|| defined(GC_FREEBSD_THREADS)\n+\t|| defined(GC_FREEBSD_THREADS) || defined(GC_SOLARIS_PTHREADS)\n         printf(\"-lpthread\\n\");\n #   endif\n #   if defined(GC_HPUX_THREADS) || defined(GC_OSF1_THREADS)\n \tprintf(\"-lpthread -lrt\\n\");\n #   endif\n-#   if defined(GC_SOLARIS_THREADS)\n+#   if defined(GC_SOLARIS_THREADS) && !defined(GC_SOLARIS_PTHREADS)\n         printf(\"-lthread -ldl\\n\");\n #   endif\n     return 0;"}, {"sha": "96b7e64cbbeea2fc100d2e6ea35693b0ac760d0a", "filename": "boehm-gc/version.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f777fd1e10435cb50c4b45a664bd6ae280f2c1/boehm-gc%2Fversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fversion.h?ref=79f777fd1e10435cb50c4b45a664bd6ae280f2c1", "patch": "@@ -1,6 +1,6 @@\n #define GC_VERSION_MAJOR 6\n #define GC_VERSION_MINOR 1\n-#define GC_ALPHA_VERSION 1\n+#define GC_ALPHA_VERSION 3\n \n #   define GC_NOT_ALPHA 0xff\n "}]}