{"sha": "e8dc4658fa3910188ee5d7c66a801a14025df408", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThkYzQ2NThmYTM5MTAxODhlZTVkN2M2NmE4MDFhMTQwMjVkZjQwOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-08-04T23:58:08Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-08-04T23:58:08Z"}, "message": "Cleanup 32-bit ms_hook code.\n\nEmit the entire required hook code sequence via ASM_BYTE; emit\nunwind info onto a blockage insn.\n\nRemove the vswapmov pattern.\n\nFix indentation in several places.\n\nFrom-SVN: r162886", "tree": {"sha": "81659448b51a63abd86a1b9a3e7a74e805cd8ba0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81659448b51a63abd86a1b9a3e7a74e805cd8ba0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8dc4658fa3910188ee5d7c66a801a14025df408", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8dc4658fa3910188ee5d7c66a801a14025df408", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8dc4658fa3910188ee5d7c66a801a14025df408", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8dc4658fa3910188ee5d7c66a801a14025df408/comments", "author": null, "committer": null, "parents": [{"sha": "2550204162adf316f427ed8697b891ec5b416bf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2550204162adf316f427ed8697b891ec5b416bf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2550204162adf316f427ed8697b891ec5b416bf4"}], "stats": {"total": 142, "additions": 82, "deletions": 60}, "files": [{"sha": "1d78cce9c5ec440b8fb131de9433a98b91ae091e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8dc4658fa3910188ee5d7c66a801a14025df408/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8dc4658fa3910188ee5d7c66a801a14025df408/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8dc4658fa3910188ee5d7c66a801a14025df408", "patch": "@@ -1,5 +1,15 @@\n 2010-08-04  Richard Henderson  <rth@redhat.com>\n \n+\t* config/i386/i386.c (ix86_function_ms_hook_prologue): Fix\n+\targument name to reflect the expected tree; fix indentation.\n+\t(ix86_asm_output_function_label): Output the entire 32-bit\n+\tms_hook here as bytes ...\n+\t(ix86_expand_prologue): ... not here as insns.  Attach the\n+\tunwind info for the ms_hook to a blockage insn.\n+\t(ix86_handle_fndecl_attribute): Don't check HAVE_AS_IX86_SWAP.\n+\t(ix86_ms_bitfield_layout_p): Fix indentation.\n+\t* config/i386/i386.md (UNSPECV_VSWAPMOV, vswapmov): Remove.\n+\n \t* config/i386/i386.c (ix86_using_red_zone): New.\n \t(ix86_compute_frame_layout, ix86_add_cfa_restore_note,\n \tix86_expand_prologue, ix86_force_to_memory): Use it."}, {"sha": "a77014c9557d1f0179ecab4490c63255f32a40cb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 72, "deletions": 49, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8dc4658fa3910188ee5d7c66a801a14025df408/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8dc4658fa3910188ee5d7c66a801a14025df408/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e8dc4658fa3910188ee5d7c66a801a14025df408", "patch": "@@ -5117,17 +5117,15 @@ ix86_function_type_abi (const_tree fntype)\n }\n \n static bool\n-ix86_function_ms_hook_prologue (const_tree fntype)\n+ix86_function_ms_hook_prologue (const_tree fn)\n {\n-  if (fntype && lookup_attribute (\"ms_hook_prologue\", DECL_ATTRIBUTES (fntype)))\n+  if (fn && lookup_attribute (\"ms_hook_prologue\", DECL_ATTRIBUTES (fn)))\n     {\n-      if (decl_function_context (fntype) != NULL_TREE)\n-      {\n-\terror_at (DECL_SOURCE_LOCATION (fntype),\n-\t    \"ms_hook_prologue is not compatible with nested function\");\n-      }\n-\n-      return true;\n+      if (decl_function_context (fn) != NULL_TREE)\n+\terror_at (DECL_SOURCE_LOCATION (fn),\n+\t\t  \"ms_hook_prologue is not compatible with nested function\");\n+      else\n+        return true;\n     }\n   return false;\n }\n@@ -5169,18 +5167,23 @@ ix86_asm_output_function_label (FILE *asm_out_file, const char *fname,\n \n   ASM_OUTPUT_LABEL (asm_out_file, fname);\n \n-  /* Output magic byte marker, if hot-patch attribute is set.\n-     For x86 case frame-pointer prologue will be emitted in\n-     expand_prologue.  */\n+  /* Output magic byte marker, if hot-patch attribute is set.  */\n   if (is_ms_hook)\n     {\n       if (TARGET_64BIT)\n-\t/* leaq [%rsp + 0], %rsp  */\n-\tasm_fprintf (asm_out_file, ASM_BYTE\n-\t\t     \"0x48, 0x8d, 0xa4, 0x24, 0x00, 0x00, 0x00, 0x00\\n\");\n+\t{\n+\t  /* leaq [%rsp + 0], %rsp  */\n+\t  asm_fprintf (asm_out_file, ASM_BYTE\n+\t\t       \"0x48, 0x8d, 0xa4, 0x24, 0x00, 0x00, 0x00, 0x00\\n\");\n+\t}\n       else\n-        /* movl.s %edi, %edi.  */\n-\tasm_fprintf (asm_out_file, ASM_BYTE \"0x8b, 0xff\\n\");\n+\t{\n+          /* movl.s %edi, %edi\n+\t     push   %ebp\n+\t     movl.s %esp, %ebp */\n+\t  asm_fprintf (asm_out_file, ASM_BYTE\n+\t\t       \"0x8b, 0xff, 0x55, 0x8b, 0xec\\n\");\n+\t}\n     }\n }\n \n@@ -9200,7 +9203,7 @@ ix86_expand_prologue (void)\n   bool pic_reg_used;\n   struct ix86_frame frame;\n   HOST_WIDE_INT allocate;\n-  int gen_frame_pointer = frame_pointer_needed;\n+  bool gen_frame_pointer = frame_pointer_needed;\n   bool int_registers_saved = false;\n \n   ix86_finalize_stack_realign_flags ();\n@@ -9216,51 +9219,78 @@ ix86_expand_prologue (void)\n \n   if (!TARGET_64BIT && ix86_function_ms_hook_prologue (current_function_decl))\n     {\n-      rtx push, mov;\n+      /* We should have already generated an error for any use of\n+         ms_hook on a nested function.  */\n+      gcc_checking_assert (!ix86_static_chain_on_stack);\n \n       /* Check if profiling is active and we shall use profiling before\n          prologue variant. If so sorry.  */\n       if (crtl->profile && flag_fentry != 0)\n         sorry (\"ms_hook_prologue attribute isn't compatible with -mfentry for 32-bit\");\n \n-      /* Make sure the function starts with\n-\t 8b ff     movl.s %edi,%edi (emited by ix86_asm_output_function_label)\n+      /* In ix86_asm_output_function_label we emitted:\n+\t 8b ff     movl.s %edi,%edi\n \t 55        push   %ebp\n \t 8b ec     movl.s %esp,%ebp\n \n \t This matches the hookable function prologue in Win32 API\n \t functions in Microsoft Windows XP Service Pack 2 and newer.\n \t Wine uses this to enable Windows apps to hook the Win32 API\n-\t functions provided by Wine.  */\n-      push = emit_insn (gen_push (hard_frame_pointer_rtx));\n-      mov = emit_insn (gen_vswapmov (hard_frame_pointer_rtx,\n-\t\t\t\t     stack_pointer_rtx));\n+\t functions provided by Wine.\n \n-      if (frame_pointer_needed && !(crtl->drap_reg\n-\t\t\t\t    && crtl->stack_realign_needed))\n+\t What that means is that we've already set up the frame pointer.  */\n+\n+      if (frame_pointer_needed\n+\t  && !(crtl->drap_reg && crtl->stack_realign_needed))\n \t{\n-\t  /* The push %ebp and movl.s %esp, %ebp already set up\n-\t     the frame pointer.  No need to do this again. */\n-\t  gen_frame_pointer = 0;\n+\t  rtx push, mov;\n+\n+\t  /* We've decided to use the frame pointer already set up.\n+\t     Describe this to the unwinder by pretending that both\n+\t     push and mov insns happen right here.\n+\n+\t     Putting the unwind info here at the end of the ms_hook\n+\t     is done so that we can make absolutely certain we get\n+\t     the required byte sequence at the start of the function,\n+\t     rather than relying on an assembler that can produce\n+\t     the exact encoding required.\n+\n+\t     However it does mean (in the unpatched case) that we have\n+\t     a 1 insn window where the asynchronous unwind info is\n+\t     incorrect.  However, if we placed the unwind info at\n+\t     its correct location we would have incorrect unwind info\n+\t     in the patched case.  Which is probably all moot since\n+\t     I don't expect Wine generates dwarf2 unwind info for the\n+\t     system libraries that use this feature.  */\n+\n+\t  insn = emit_insn (gen_blockage ());\n+\n+\t  push = gen_push (hard_frame_pointer_rtx);\n+\t  mov = gen_rtx_SET (VOIDmode, hard_frame_pointer_rtx,\n+\t\t\t     stack_pointer_rtx);\n \t  RTX_FRAME_RELATED_P (push) = 1;\n \t  RTX_FRAME_RELATED_P (mov) = 1;\n+\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\tgen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, push, mov)));\n+\n \t  if (ix86_cfa_state->reg == stack_pointer_rtx)\n \t    ix86_cfa_state->reg = hard_frame_pointer_rtx;\n+\t  gen_frame_pointer = false;\n \t}\n       else\n-\t/* If the frame pointer is not needed, pop %ebp again. This\n-\t   could be optimized for cases where ebp needs to be backed up\n-\t   for some other reason.  If stack realignment is needed, pop\n-\t   the base pointer again, align the stack, and later regenerate\n-\t   the frame pointer setup.  The frame pointer generated by the\n-\t   hook prologue is not aligned, so it can't be used.  */\n-\tinsn = emit_insn (ix86_gen_pop1 (hard_frame_pointer_rtx));\n+\t{\n+\t  /* The frame pointer is not needed so pop %ebp again.\n+\t     This leaves us with a pristine state.  */\n+\t  emit_insn (ix86_gen_pop1 (hard_frame_pointer_rtx));\n+\t}\n     }\n \n   /* The first insn of a function that accepts its static chain on the\n      stack is to push the register that would be filled in by a direct\n      call.  This insn will be skipped by the trampoline.  */\n-  if (ix86_static_chain_on_stack)\n+  else if (ix86_static_chain_on_stack)\n     {\n       rtx t;\n \n@@ -27010,23 +27040,16 @@ ix86_handle_fndecl_attribute (tree *node, tree name,\n       warning (OPT_Wattributes, \"%qE attribute only applies to functions\",\n                name);\n       *no_add_attrs = true;\n-      return NULL_TREE;\n     }\n-\n-#ifndef HAVE_AS_IX86_SWAP\n-  if (!TARGET_64BIT)\n-    sorry (\"ms_hook_prologue attribute needs assembler swap suffix support\");\n-#endif\n-\n-    return NULL_TREE;\n+  return NULL_TREE;\n }\n \n static bool\n ix86_ms_bitfield_layout_p (const_tree record_type)\n {\n-  return (TARGET_MS_BITFIELD_LAYOUT &&\n-\t  !lookup_attribute (\"gcc_struct\", TYPE_ATTRIBUTES (record_type)))\n-    || lookup_attribute (\"ms_struct\", TYPE_ATTRIBUTES (record_type));\n+  return ((TARGET_MS_BITFIELD_LAYOUT\n+\t   && !lookup_attribute (\"gcc_struct\", TYPE_ATTRIBUTES (record_type)))\n+          || lookup_attribute (\"ms_struct\", TYPE_ATTRIBUTES (record_type)));\n }\n \n /* Returns an expression indicating where the this parameter is"}, {"sha": "00411583a6d52e625f36c01f5a3ec376ad5f8909", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8dc4658fa3910188ee5d7c66a801a14025df408/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8dc4658fa3910188ee5d7c66a801a14025df408/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=e8dc4658fa3910188ee5d7c66a801a14025df408", "patch": "@@ -250,7 +250,6 @@\n   UNSPECV_RDTSC\n   UNSPECV_RDTSCP\n   UNSPECV_RDPMC\n-  UNSPECV_VSWAPMOV\n   UNSPECV_LLWP_INTRINSIC\n   UNSPECV_SLWP_INTRINSIC\n   UNSPECV_LWPVAL_INTRINSIC\n@@ -11573,16 +11572,6 @@\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"modrm\" \"0\")])\n \n-(define_insn \"vswapmov\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (match_operand:SI 1 \"register_operand\" \"r\"))\n-   (unspec_volatile [(const_int 0)] UNSPECV_VSWAPMOV)]\n-  \"\"\n-  \"movl.s\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"modrm\" \"0\")])\n-\n ;; Pad to 16-byte boundary, max skip in op0.  Used to avoid\n ;; branch prediction penalty for the third jump in a 16-byte\n ;; block on K8."}]}