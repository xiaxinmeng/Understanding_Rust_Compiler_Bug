{"sha": "cf7aa6a3b79ac25df266aa4fcfe6c059243602aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y3YWE2YTNiNzlhYzI1ZGYyNjZhYTRmY2ZlNmMwNTkyNDM2MDJhYQ==", "commit": {"author": {"name": "Alan Lawrence", "email": "alan.lawrence@arm.com", "date": "2014-11-13T16:27:37Z"}, "committer": {"name": "Alan Lawrence", "email": "alalaw01@gcc.gnu.org", "date": "2014-11-13T16:27:37Z"}, "message": "[Vectorizer] Use a VEC_PERM_EXPR instead of VEC_RSHIFT_EXPR; expand appropriate VEC_PERM_EXPRs using vec_shr_optab\n\n\t* optabs.c (can_vec_perm_p): Update comment, does not consider vec_shr.\n\t(shift_amt_for_vec_perm_mask): New.\n\t(expand_vec_perm_1): Use vec_shr_optab if second vector is const0_rtx\n\tand mask appropriate.\n\n\t* tree-vect-loop.c (calc_vec_perm_mask_for_shift): New.\n\t(have_whole_vector_shift): New.\n\t(vect_model_reduction_cost): Call have_whole_vector_shift instead of\n\tlooking for vec_shr_optab.\n\t(vect_create_epilog_for_reduction): Likewise; also rename local variable\n\thave_whole_vector_shift to reduce_with_shift; output VEC_PERM_EXPRs\n\tinstead of VEC_RSHIFT_EXPRs.\n\n\t* tree-vect-stmts.c (vect_gen_perm_mask_checked): Extend comment.\n\nFrom-SVN: r217509", "tree": {"sha": "6780c5d8c1b45da220db82c4a0f897afcd467d9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6780c5d8c1b45da220db82c4a0f897afcd467d9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf7aa6a3b79ac25df266aa4fcfe6c059243602aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf7aa6a3b79ac25df266aa4fcfe6c059243602aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf7aa6a3b79ac25df266aa4fcfe6c059243602aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf7aa6a3b79ac25df266aa4fcfe6c059243602aa/comments", "author": null, "committer": null, "parents": [{"sha": "557be5a8767902f204e8afa04551a387eac33a26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/557be5a8767902f204e8afa04551a387eac33a26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/557be5a8767902f204e8afa04551a387eac33a26"}], "stats": {"total": 149, "additions": 122, "deletions": 27}, "files": [{"sha": "99f18b45a79d62094b23a6f64d9af6e35d4a89a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7aa6a3b79ac25df266aa4fcfe6c059243602aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7aa6a3b79ac25df266aa4fcfe6c059243602aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf7aa6a3b79ac25df266aa4fcfe6c059243602aa", "patch": "@@ -1,3 +1,20 @@\n+2014-11-13  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\t* optabs.c (can_vec_perm_p): Update comment, does not consider vec_shr.\n+\t(shift_amt_for_vec_perm_mask): New.\n+\t(expand_vec_perm_1): Use vec_shr_optab if second vector is const0_rtx\n+\tand mask appropriate.\n+\n+\t* tree-vect-loop.c (calc_vec_perm_mask_for_shift): New.\n+\t(have_whole_vector_shift): New.\n+\t(vect_model_reduction_cost): Call have_whole_vector_shift instead of\n+\tlooking for vec_shr_optab.\n+\t(vect_create_epilog_for_reduction): Likewise; also rename local variable\n+\thave_whole_vector_shift to reduce_with_shift; output VEC_PERM_EXPRs\n+\tinstead of VEC_RSHIFT_EXPRs.\n+\n+\t* tree-vect-stmts.c (vect_gen_perm_mask_checked): Extend comment.\n+\n 2014-11-13  Alan Lawrence  <alan.lawrence@arm.com>\n \n         * tree-vectorizer.h (vect_gen_perm_mask): Remove."}, {"sha": "4ddd9cc538f10845202abd1bceac0c9c1437d384", "filename": "gcc/optabs.c", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7aa6a3b79ac25df266aa4fcfe6c059243602aa/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7aa6a3b79ac25df266aa4fcfe6c059243602aa/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=cf7aa6a3b79ac25df266aa4fcfe6c059243602aa", "patch": "@@ -6567,8 +6567,11 @@ vector_compare_rtx (enum tree_code tcode, tree t_op0, tree t_op1,\n   return gen_rtx_fmt_ee (rcode, VOIDmode, ops[0].value, ops[1].value);\n }\n \n-/* Return true if VEC_PERM_EXPR can be expanded using SIMD extensions\n-   of the CPU.  SEL may be NULL, which stands for an unknown constant.  */\n+/* Return true if VEC_PERM_EXPR of arbitrary input vectors can be expanded using\n+   SIMD extensions of the CPU.  SEL may be NULL, which stands for an unknown\n+   constant.  Note that additional permutations representing whole-vector shifts\n+   may also be handled via the vec_shr optab, but only where the second input\n+   vector is entirely constant zeroes; this case is not dealt with here.  */\n \n bool\n can_vec_perm_p (machine_mode mode, bool variable,\n@@ -6621,6 +6624,36 @@ can_vec_perm_p (machine_mode mode, bool variable,\n   return true;\n }\n \n+/* Checks if vec_perm mask SEL is a constant equivalent to a shift of the first\n+   vec_perm operand, assuming the second operand is a constant vector of zeroes.\n+   Return the shift distance in bits if so, or NULL_RTX if the vec_perm is not a\n+   shift.  */\n+static rtx\n+shift_amt_for_vec_perm_mask (rtx sel)\n+{\n+  unsigned int i, first, nelt = GET_MODE_NUNITS (GET_MODE (sel));\n+  unsigned int bitsize = GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (sel)));\n+\n+  if (GET_CODE (sel) != CONST_VECTOR)\n+    return NULL_RTX;\n+\n+  first = INTVAL (CONST_VECTOR_ELT (sel, 0));\n+  if (first >= 2*nelt)\n+    return NULL_RTX;\n+  for (i = 1; i < nelt; i++)\n+    {\n+      int idx = INTVAL (CONST_VECTOR_ELT (sel, i));\n+      unsigned int expected = (i + first) & (2 * nelt - 1);\n+      /* Indices into the second vector are all equivalent.  */\n+      if (idx < 0 || (MIN (nelt, (unsigned) idx) != MIN (nelt, expected)))\n+\treturn NULL_RTX;\n+    }\n+\n+  if (BYTES_BIG_ENDIAN)\n+    first = (2 * nelt) - first;\n+  return GEN_INT (first * bitsize);\n+}\n+\n /* A subroutine of expand_vec_perm for expanding one vec_perm insn.  */\n \n static rtx\n@@ -6649,6 +6682,17 @@ expand_vec_perm_1 (enum insn_code icode, rtx target,\n   else\n     {\n       create_input_operand (&ops[1], v0, tmode);\n+      /* See if this can be handled with a vec_shr.  We only do this if the\n+         second vector is all zeroes.  */\n+      enum insn_code shift_code = optab_handler (vec_shr_optab, GET_MODE (v0));\n+      if (v1 == CONST0_RTX (GET_MODE (v1)) && shift_code)\n+\tif (rtx shift_amt = shift_amt_for_vec_perm_mask (sel))\n+\t  {\n+\t    create_convert_operand_from_type (&ops[2], shift_amt,\n+\t\t\t\t\t      sizetype_tab[(int) stk_sizetype]);\n+\t    if (maybe_expand_insn (shift_code, 3, ops))\n+\t      return ops[0].value;\n+\t  }\n       create_input_operand (&ops[2], v1, tmode);\n     }\n "}, {"sha": "7aa58623207955cf45d70ca9dc5100f275ea2aa8", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 57, "deletions": 24, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7aa6a3b79ac25df266aa4fcfe6c059243602aa/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7aa6a3b79ac25df266aa4fcfe6c059243602aa/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=cf7aa6a3b79ac25df266aa4fcfe6c059243602aa", "patch": "@@ -3083,6 +3083,41 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   *ret_min_profitable_estimate = min_profitable_estimate;\n }\n \n+/* Writes into SEL a mask for a vec_perm, equivalent to a vec_shr by OFFSET\n+   vector elements (not bits) for a vector of mode MODE.  */\n+static void\n+calc_vec_perm_mask_for_shift (enum machine_mode mode, unsigned int offset,\n+\t\t\t      unsigned char *sel)\n+{\n+  unsigned int i, nelt = GET_MODE_NUNITS (mode);\n+\n+  for (i = 0; i < nelt; i++)\n+    sel[i] = (BYTES_BIG_ENDIAN ? i - offset : i + offset) & (2*nelt - 1);\n+}\n+\n+/* Checks whether the target supports whole-vector shifts for vectors of mode\n+   MODE.  This is the case if _either_ the platform handles vec_shr_optab, _or_\n+   it supports vec_perm_const with masks for all necessary shift amounts.  */\n+static bool\n+have_whole_vector_shift (enum machine_mode mode)\n+{\n+  if (optab_handler (vec_shr_optab, mode) != CODE_FOR_nothing)\n+    return true;\n+\n+  if (direct_optab_handler (vec_perm_const_optab, mode) == CODE_FOR_nothing)\n+    return false;\n+\n+  unsigned int i, nelt = GET_MODE_NUNITS (mode);\n+  unsigned char *sel = XALLOCAVEC (unsigned char, nelt);\n+\n+  for (i = nelt/2; i >= 1; i/=2)\n+    {\n+      calc_vec_perm_mask_for_shift (mode, i, sel);\n+      if (!can_vec_perm_p (mode, false, sel))\n+\treturn false;\n+    }\n+  return true;\n+}\n \n /* TODO: Close dependency between vect_model_*_cost and vectorizable_*\n    functions. Design better to avoid maintenance issues.  */\n@@ -3185,7 +3220,7 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \t  /* We have a whole vector shift available.  */\n \t  if (VECTOR_MODE_P (mode)\n \t      && optab_handler (optab, mode) != CODE_FOR_nothing\n-\t      && optab_handler (vec_shr_optab, mode) != CODE_FOR_nothing)\n+\t      && have_whole_vector_shift (mode))\n \t    {\n \t      /* Final reduction via vector shifts and the reduction operator.\n \t\t Also requires scalar extract.  */\n@@ -3788,7 +3823,6 @@ get_initial_def_for_reduction (gimple stmt, tree init_val,\n   return init_def;\n }\n \n-\n /* Function vect_create_epilog_for_reduction\n \n    Create code at the loop-epilog to finalize the result of a reduction\n@@ -4212,37 +4246,36 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n     }\n   else\n     {\n-      enum tree_code shift_code = ERROR_MARK;\n-      bool have_whole_vector_shift = true;\n-      int bit_offset;\n+      bool reduce_with_shift = have_whole_vector_shift (mode);\n       int element_bitsize = tree_to_uhwi (bitsize);\n       int vec_size_in_bits = tree_to_uhwi (TYPE_SIZE (vectype));\n       tree vec_temp;\n \n-      if (optab_handler (vec_shr_optab, mode) != CODE_FOR_nothing)\n-        shift_code = VEC_RSHIFT_EXPR;\n-      else\n-        have_whole_vector_shift = false;\n-\n       /* Regardless of whether we have a whole vector shift, if we're\n          emulating the operation via tree-vect-generic, we don't want\n          to use it.  Only the first round of the reduction is likely\n          to still be profitable via emulation.  */\n       /* ??? It might be better to emit a reduction tree code here, so that\n          tree-vect-generic can expand the first round via bit tricks.  */\n       if (!VECTOR_MODE_P (mode))\n-        have_whole_vector_shift = false;\n+        reduce_with_shift = false;\n       else\n         {\n           optab optab = optab_for_tree_code (code, vectype, optab_default);\n           if (optab_handler (optab, mode) == CODE_FOR_nothing)\n-            have_whole_vector_shift = false;\n+            reduce_with_shift = false;\n         }\n \n-      if (have_whole_vector_shift && !slp_reduc)\n+      if (reduce_with_shift && !slp_reduc)\n         {\n+          int nelements = vec_size_in_bits / element_bitsize;\n+          unsigned char *sel = XALLOCAVEC (unsigned char, nelements);\n+\n+          int elt_offset;\n+\n+          tree zero_vec = build_zero_cst (vectype);\n           /*** Case 2: Create:\n-             for (offset = VS/2; offset >= element_size; offset/=2)\n+             for (offset = nelements/2; offset >= 1; offset/=2)\n                 {\n                   Create:  va' = vec_shift <va, offset>\n                   Create:  va = vop <va, va'>\n@@ -4254,14 +4287,15 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n \n           vec_dest = vect_create_destination_var (scalar_dest, vectype);\n           new_temp = new_phi_result;\n-          for (bit_offset = vec_size_in_bits/2;\n-               bit_offset >= element_bitsize;\n-               bit_offset /= 2)\n+          for (elt_offset = nelements / 2;\n+               elt_offset >= 1;\n+               elt_offset /= 2)\n             {\n-              tree bitpos = size_int (bit_offset);\n-\n-              epilog_stmt = gimple_build_assign_with_ops (shift_code,\n-                                               vec_dest, new_temp, bitpos);\n+              calc_vec_perm_mask_for_shift (mode, elt_offset, sel);\n+              tree mask = vect_gen_perm_mask_any (vectype, sel);\n+\t      epilog_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR,\n+\t\t\t\t\t\t\t  vec_dest, new_temp,\n+\t\t\t\t\t\t\t  zero_vec, mask);\n               new_name = make_ssa_name (vec_dest, epilog_stmt);\n               gimple_assign_set_lhs (epilog_stmt, new_name);\n               gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n@@ -4277,8 +4311,6 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n         }\n       else\n         {\n-          tree rhs;\n-\n           /*** Case 3: Create:\n              s = extract_field <v_out2, 0>\n              for (offset = element_size;\n@@ -4296,11 +4328,12 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n           vec_size_in_bits = tree_to_uhwi (TYPE_SIZE (vectype));\n           FOR_EACH_VEC_ELT (new_phis, i, new_phi)\n             {\n+              int bit_offset;\n               if (gimple_code (new_phi) == GIMPLE_PHI)\n                 vec_temp = PHI_RESULT (new_phi);\n               else\n                 vec_temp = gimple_assign_lhs (new_phi);\n-              rhs = build3 (BIT_FIELD_REF, scalar_type, vec_temp, bitsize,\n+              tree rhs = build3 (BIT_FIELD_REF, scalar_type, vec_temp, bitsize,\n                             bitsize_zero_node);\n               epilog_stmt = gimple_build_assign (new_scalar_dest, rhs);\n               new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);"}, {"sha": "f877feaf347bc76fc6636fe47ac8938ea4981d48", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7aa6a3b79ac25df266aa4fcfe6c059243602aa/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7aa6a3b79ac25df266aa4fcfe6c059243602aa/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=cf7aa6a3b79ac25df266aa4fcfe6c059243602aa", "patch": "@@ -5495,7 +5495,8 @@ vect_gen_perm_mask_any (tree vectype, const unsigned char *sel)\n   return mask_vec;\n }\n \n-/* Checked version of vect_gen_perm_mask_any.  Asserts can_vec_perm_p.  */\n+/* Checked version of vect_gen_perm_mask_any.  Asserts can_vec_perm_p,\n+   i.e. that the target supports the pattern _for arbitrary input vectors_.  */\n \n tree\n vect_gen_perm_mask_checked (tree vectype, const unsigned char *sel)"}]}