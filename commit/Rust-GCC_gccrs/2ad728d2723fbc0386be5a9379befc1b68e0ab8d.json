{"sha": "2ad728d2723fbc0386be5a9379befc1b68e0ab8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFkNzI4ZDI3MjNmYmMwMzg2YmU1YTkzNzliZWZjMWI2OGUwYWI4ZA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-08-14T11:22:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-08-14T11:22:23Z"}, "message": "gimplify.c (create_tmp_from_val): Mark temporary with DECL_GIMPLE_REG_P here ...\n\n2012-08-14  Richard Guenther  <rguenther@suse.de>\n\n\t* gimplify.c (create_tmp_from_val): Mark temporary with\n\tDECL_GIMPLE_REG_P here ...\n\t(internal_get_tmp_var): ... instead of here.  If we go into\n\tSSA create an SSA name instead of a VAR_DECL.\n\t(gimplify_modify_expr): Do not create SSA names here, assert\n\twe already got them.\n\t(force_gimple_operand_1): Create an SSA name if we go into SSA.\n\t* sese.c (rename_uses): Simplify.\n\nFrom-SVN: r190381", "tree": {"sha": "fd4084fc9466e792c2096d7dbfe52c540c1e1904", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd4084fc9466e792c2096d7dbfe52c540c1e1904"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ad728d2723fbc0386be5a9379befc1b68e0ab8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ad728d2723fbc0386be5a9379befc1b68e0ab8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ad728d2723fbc0386be5a9379befc1b68e0ab8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ad728d2723fbc0386be5a9379befc1b68e0ab8d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d8d707b4b576ebceac3e902d31bf954bca728660", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8d707b4b576ebceac3e902d31bf954bca728660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8d707b4b576ebceac3e902d31bf954bca728660"}], "stats": {"total": 159, "additions": 84, "deletions": 75}, "files": [{"sha": "5fb0846eb9f4ca88297f60e011bd6508d4ce5bc1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ad728d2723fbc0386be5a9379befc1b68e0ab8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ad728d2723fbc0386be5a9379befc1b68e0ab8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ad728d2723fbc0386be5a9379befc1b68e0ab8d", "patch": "@@ -1,3 +1,14 @@\n+2012-08-14  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gimplify.c (create_tmp_from_val): Mark temporary with\n+\tDECL_GIMPLE_REG_P here ...\n+\t(internal_get_tmp_var): ... instead of here.  If we go into\n+\tSSA create an SSA name instead of a VAR_DECL.\n+\t(gimplify_modify_expr): Do not create SSA names here, assert\n+\twe already got them.\n+\t(force_gimple_operand_1): Create an SSA name if we go into SSA.\n+\t* sese.c (rename_uses): Simplify.\n+\n 2012-08-14  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-into-ssa.c: Include diagnostic-core.h."}, {"sha": "9b66a22affdb34b7155945137866dacb39eeaf42", "filename": "gcc/gimplify.c", "status": "modified", "additions": 71, "deletions": 72, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ad728d2723fbc0386be5a9379befc1b68e0ab8d/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ad728d2723fbc0386be5a9379befc1b68e0ab8d/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=2ad728d2723fbc0386be5a9379befc1b68e0ab8d", "patch": "@@ -488,58 +488,6 @@ create_tmp_reg (tree type, const char *prefix)\n   return tmp;\n }\n \n-/* Create a temporary with a name derived from VAL.  Subroutine of\n-   lookup_tmp_var; nobody else should call this function.  */\n-\n-static inline tree\n-create_tmp_from_val (tree val)\n-{\n-  /* Drop all qualifiers and address-space information from the value type.  */\n-  return create_tmp_var (TYPE_MAIN_VARIANT (TREE_TYPE (val)), get_name (val));\n-}\n-\n-/* Create a temporary to hold the value of VAL.  If IS_FORMAL, try to reuse\n-   an existing expression temporary.  */\n-\n-static tree\n-lookup_tmp_var (tree val, bool is_formal)\n-{\n-  tree ret;\n-\n-  /* If not optimizing, never really reuse a temporary.  local-alloc\n-     won't allocate any variable that is used in more than one basic\n-     block, which means it will go into memory, causing much extra\n-     work in reload and final and poorer code generation, outweighing\n-     the extra memory allocation here.  */\n-  if (!optimize || !is_formal || TREE_SIDE_EFFECTS (val))\n-    ret = create_tmp_from_val (val);\n-  else\n-    {\n-      elt_t elt, *elt_p;\n-      void **slot;\n-\n-      elt.val = val;\n-      if (gimplify_ctxp->temp_htab == NULL)\n-        gimplify_ctxp->temp_htab\n-\t  = htab_create (1000, gimple_tree_hash, gimple_tree_eq, free);\n-      slot = htab_find_slot (gimplify_ctxp->temp_htab, (void *)&elt, INSERT);\n-      if (*slot == NULL)\n-\t{\n-\t  elt_p = XNEW (elt_t);\n-\t  elt_p->val = val;\n-\t  elt_p->temp = ret = create_tmp_from_val (val);\n-\t  *slot = (void *) elt_p;\n-\t}\n-      else\n-\t{\n-\t  elt_p = (elt_t *) *slot;\n-          ret = elt_p->temp;\n-\t}\n-    }\n-\n-  return ret;\n-}\n-\n /* Returns true iff T is a valid RHS for an assignment to a renamed\n    user -- or front-end generated artificial -- variable.  */\n \n@@ -591,6 +539,64 @@ is_gimple_mem_rhs_or_call (tree t)\n \t    || TREE_CODE (t) == CALL_EXPR);\n }\n \n+/* Create a temporary with a name derived from VAL.  Subroutine of\n+   lookup_tmp_var; nobody else should call this function.  */\n+\n+static inline tree\n+create_tmp_from_val (tree val, bool is_formal)\n+{\n+  /* Drop all qualifiers and address-space information from the value type.  */\n+  tree type = TYPE_MAIN_VARIANT (TREE_TYPE (val));\n+  tree var = create_tmp_var (type, get_name (val));\n+  if (is_formal\n+      && (TREE_CODE (TREE_TYPE (var)) == COMPLEX_TYPE\n+\t  || TREE_CODE (TREE_TYPE (var)) == VECTOR_TYPE))\n+    DECL_GIMPLE_REG_P (var) = 1;\n+  return var;\n+}\n+\n+/* Create a temporary to hold the value of VAL.  If IS_FORMAL, try to reuse\n+   an existing expression temporary.  */\n+\n+static tree\n+lookup_tmp_var (tree val, bool is_formal)\n+{\n+  tree ret;\n+\n+  /* If not optimizing, never really reuse a temporary.  local-alloc\n+     won't allocate any variable that is used in more than one basic\n+     block, which means it will go into memory, causing much extra\n+     work in reload and final and poorer code generation, outweighing\n+     the extra memory allocation here.  */\n+  if (!optimize || !is_formal || TREE_SIDE_EFFECTS (val))\n+    ret = create_tmp_from_val (val, is_formal);\n+  else\n+    {\n+      elt_t elt, *elt_p;\n+      void **slot;\n+\n+      elt.val = val;\n+      if (gimplify_ctxp->temp_htab == NULL)\n+        gimplify_ctxp->temp_htab\n+\t  = htab_create (1000, gimple_tree_hash, gimple_tree_eq, free);\n+      slot = htab_find_slot (gimplify_ctxp->temp_htab, (void *)&elt, INSERT);\n+      if (*slot == NULL)\n+\t{\n+\t  elt_p = XNEW (elt_t);\n+\t  elt_p->val = val;\n+\t  elt_p->temp = ret = create_tmp_from_val (val, is_formal);\n+\t  *slot = (void *) elt_p;\n+\t}\n+      else\n+\t{\n+\t  elt_p = (elt_t *) *slot;\n+          ret = elt_p->temp;\n+\t}\n+    }\n+\n+  return ret;\n+}\n+\n /* Helper for get_formal_tmp_var and get_initialized_tmp_var.  */\n \n static tree\n@@ -604,12 +610,11 @@ internal_get_tmp_var (tree val, gimple_seq *pre_p, gimple_seq *post_p,\n   gimplify_expr (&val, pre_p, post_p, is_gimple_reg_rhs_or_call,\n \t\t fb_rvalue);\n \n-  t = lookup_tmp_var (val, is_formal);\n-\n-  if (is_formal\n-      && (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE\n-\t  || TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE))\n-    DECL_GIMPLE_REG_P (t) = 1;\n+  if (gimplify_ctxp->into_ssa\n+      && is_gimple_reg_type (TREE_TYPE (val)))\n+    t = make_ssa_name (TYPE_MAIN_VARIANT (TREE_TYPE (val)), NULL);\n+  else\n+    t = lookup_tmp_var (val, is_formal);\n \n   mod = build2 (INIT_EXPR, TREE_TYPE (t), t, unshare_expr (val));\n \n@@ -619,14 +624,6 @@ internal_get_tmp_var (tree val, gimple_seq *pre_p, gimple_seq *post_p,\n   gimplify_and_add (mod, pre_p);\n   ggc_free (mod);\n \n-  /* If we're gimplifying into ssa, gimplify_modify_expr will have\n-     given our temporary an SSA name.  Find and return it.  */\n-  if (gimplify_ctxp->into_ssa)\n-    {\n-      gimple last = gimple_seq_last_stmt (*pre_p);\n-      t = gimple_get_lhs (last);\n-    }\n-\n   return t;\n }\n \n@@ -4919,11 +4916,8 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n   if (gimplify_ctxp->into_ssa && is_gimple_reg (*to_p))\n     {\n-      /* If we've somehow already got an SSA_NAME on the LHS, then\n-\t we've probably modified it twice.  Not good.  */\n-      gcc_assert (TREE_CODE (*to_p) != SSA_NAME);\n-      *to_p = make_ssa_name (*to_p, assign);\n-      gimple_set_lhs (assign, *to_p);\n+      /* We should have got an SSA name from the start.  */\n+      gcc_assert (TREE_CODE (*to_p) == SSA_NAME);\n     }\n \n   gimplify_seq_add_stmt (pre_p, assign);\n@@ -8552,7 +8546,12 @@ force_gimple_operand_1 (tree expr, gimple_seq *stmts,\n   gimplify_ctxp->allow_rhs_cond_expr = true;\n \n   if (var)\n-    expr = build2 (MODIFY_EXPR, TREE_TYPE (var), var, expr);\n+    {\n+      if (gimplify_ctxp->into_ssa\n+\t  && is_gimple_reg (var))\n+\tvar = make_ssa_name (var, NULL);\n+      expr = build2 (MODIFY_EXPR, TREE_TYPE (var), var, expr);\n+    }\n \n   if (TREE_CODE (expr) != MODIFY_EXPR\n       && TREE_TYPE (expr) == void_type_node)"}, {"sha": "44bc74044b611ac1f9aec444eb32df0b6d8069bc", "filename": "gcc/sese.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ad728d2723fbc0386be5a9379befc1b68e0ab8d/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ad728d2723fbc0386be5a9379befc1b68e0ab8d/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=2ad728d2723fbc0386be5a9379befc1b68e0ab8d", "patch": "@@ -504,11 +504,10 @@ rename_uses (gimple copy, htab_t rename_map, gimple_stmt_iterator *gsi_tgt,\n \t    {\n \t      tree var = create_tmp_var (type_old_name, \"var\");\n \n-\t      if (type_old_name != type_new_expr)\n+\t      if (!useless_type_conversion_p (type_old_name, type_new_expr))\n \t\tnew_expr = fold_convert (type_old_name, new_expr);\n \n-\t      new_expr = build2 (MODIFY_EXPR, type_old_name, var, new_expr);\n-\t      new_expr = force_gimple_operand (new_expr, &stmts, true, NULL);\n+\t      new_expr = force_gimple_operand (new_expr, &stmts, true, var);\n \t      gsi_insert_seq_before (gsi_tgt, stmts, GSI_SAME_STMT);\n \t    }\n "}]}