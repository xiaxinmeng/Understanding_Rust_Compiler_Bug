{"sha": "af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYzYzE5ZjBhNTA3MjE5OWY3MDU3MWEzMDI3MWEwZWU5YTRhZTVjZQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-16T14:23:44Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-16T21:39:23Z"}, "message": "d: Update code formatting in a consistent style.\n\ngcc/d/ChangeLog:\n\n\t* d-attribs.cc: Update code formatting in a consistant style.\n\t* d-builtins.cc: Likewise.\n\t* d-codegen.cc: Likewise.\n\t* d-compiler.cc: Likewise.\n\t* d-convert.cc: Likewise.\n\t* d-diagnostic.cc: Likewise.\n\t* d-frontend.cc: Likewise.\n\t* d-lang.cc: Likewise.\n\t* d-longdouble.cc: Likewise.\n\t* d-port.cc: Likewise.\n\t* d-spec.cc: Likewise.\n\t* d-tree.h: Likewise.\n\t* decl.cc: Likewise.\n\t* expr.cc: Likewise.\n\t* longdouble.h: Likewise.\n\t* modules.cc: Likewise.\n\t* toir.cc: Likewise.\n\t* typeinfo.cc: Likewise.", "tree": {"sha": "0725a38c694476f76a353be38e0f44857e85ca91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0725a38c694476f76a353be38e0f44857e85ca91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdbf48bed4e947f8d20c8c22d400fb52a407d46f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdbf48bed4e947f8d20c8c22d400fb52a407d46f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdbf48bed4e947f8d20c8c22d400fb52a407d46f"}], "stats": {"total": 271, "additions": 136, "deletions": 135}, "files": [{"sha": "31137957c46486126b4822145bb22b2b92930997", "filename": "gcc/d/d-attribs.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-attribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-attribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-attribs.cc?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -254,7 +254,7 @@ build_attributes (Expressions *eattrs)\n \tcontinue;\n \n       /* Attribute symbol must come from the `gcc.attribute' module.  */\n-      Dsymbol *mod = (Dsymbol*) sym->getModule ();\n+      Dsymbol *mod = (Dsymbol *) sym->getModule ();\n       if (!(strcmp (mod->toChars (), \"attribute\") == 0\n \t    && mod->parent != NULL\n \t    && strcmp (mod->parent->toChars (), \"gcc\") == 0\n@@ -643,7 +643,7 @@ d_handle_forceinline_attribute (tree *node, tree name,\n       tree attributes = DECL_ATTRIBUTES (*node);\n \n       /* Push attribute always_inline.  */\n-      if (! lookup_attribute (\"always_inline\", attributes))\n+      if (!lookup_attribute (\"always_inline\", attributes))\n \tDECL_ATTRIBUTES (*node) = tree_cons (get_identifier (\"always_inline\"),\n \t\t\t\t\t     NULL_TREE, attributes);\n \n@@ -692,7 +692,7 @@ d_handle_target_attribute (tree *node, tree name, tree args, int flags,\n       warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n       *no_add_attrs = true;\n     }\n-  else if (! targetm.target_option.valid_attribute_p (*node, name, args, flags))\n+  else if (!targetm.target_option.valid_attribute_p (*node, name, args, flags))\n     *no_add_attrs = true;\n \n   return NULL_TREE;\n@@ -713,7 +713,7 @@ d_handle_noclone_attribute (tree *node, tree name,\n       tree attributes = DECL_ATTRIBUTES (*node);\n \n       /* Push attribute noclone.  */\n-      if (! lookup_attribute (\"noclone\", attributes))\n+      if (!lookup_attribute (\"noclone\", attributes))\n \tDECL_ATTRIBUTES (*node) = tree_cons (get_identifier (\"noclone\"),\n \t\t\t\t\t     NULL_TREE, attributes);\n     }\n@@ -810,7 +810,7 @@ d_handle_alias_attribute (tree *node, tree ARG_UNUSED (name),\n       /* A static variable declaration is always a tentative definition,\n \t but the alias is a non-tentative definition which overrides.  */\n       || (TREE_CODE (decl) != FUNCTION_DECL\n-\t  && ! TREE_PUBLIC (decl) && DECL_INITIAL (decl)))\n+\t  && !TREE_PUBLIC (decl) && DECL_INITIAL (decl)))\n     {\n       error (\"%q+D defined both normally and as %qE attribute\", decl, name);\n       *no_add_attrs = true;"}, {"sha": "6272ab83a764f207ac91a6d72ea488c4cf20f75b", "filename": "gcc/d/d-builtins.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-builtins.cc?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -42,9 +42,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"d-target.h\"\n \n \n-static GTY(()) vec<tree, va_gc> *gcc_builtins_functions = NULL;\n-static GTY(()) vec<tree, va_gc> *gcc_builtins_libfuncs = NULL;\n-static GTY(()) vec<tree, va_gc> *gcc_builtins_types = NULL;\n+static GTY(()) vec <tree, va_gc> *gcc_builtins_functions = NULL;\n+static GTY(()) vec <tree, va_gc> *gcc_builtins_libfuncs = NULL;\n+static GTY(()) vec <tree, va_gc> *gcc_builtins_types = NULL;\n \n /* Record built-in types and their associated decls for re-use when\n    generating the `gcc.builtins' module.  */\n@@ -60,7 +60,7 @@ struct builtin_data\n   { }\n };\n \n-static vec<builtin_data> builtin_converted_decls;\n+static vec <builtin_data> builtin_converted_decls;\n \n /* Build D frontend type from tree TYPE type given.  This will set the\n    back-end type symbol directly for complex types to save build_ctype()"}, {"sha": "cea47315d0e0387abe957b74c1351d8bc4524acf", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -44,7 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Return the GCC location for the D frontend location LOC.  */\n \n location_t\n-make_location_t (const Loc& loc)\n+make_location_t (const Loc &loc)\n {\n   location_t gcc_location = input_location;\n \n@@ -241,7 +241,7 @@ build_integer_cst (dinteger_t value, tree type)\n /* Build REAL_CST of type TOTYPE with the value VALUE.  */\n \n tree\n-build_float_cst (const real_t& value, Type *totype)\n+build_float_cst (const real_t &value, Type *totype)\n {\n   real_t new_value;\n   TypeBasic *tb = totype->isTypeBasic ();\n@@ -293,7 +293,7 @@ tree\n d_array_value (tree type, tree len, tree data)\n {\n   tree len_field, ptr_field;\n-  vec<constructor_elt, va_gc> *ce = NULL;\n+  vec <constructor_elt, va_gc> *ce = NULL;\n \n   gcc_assert (TYPE_DYNAMIC_ARRAY (type));\n   len_field = TYPE_FIELDS (type);\n@@ -356,7 +356,7 @@ build_class_binfo (tree super, ClassDeclaration *cd)\n    This function makes assumptions about interface layout.  */\n \n tree\n-build_interface_binfo (tree super, ClassDeclaration *cd, unsigned& offset)\n+build_interface_binfo (tree super, ClassDeclaration *cd, unsigned &offset)\n {\n   tree binfo = make_tree_binfo (cd->baseclasses->length);\n   tree ctype = build_ctype (cd->type);\n@@ -421,7 +421,7 @@ build_delegate_cst (tree method, tree object, Type *type)\n       TYPE_DELEGATE (ctype) = 1;\n     }\n \n-  vec<constructor_elt, va_gc> *ce = NULL;\n+  vec <constructor_elt, va_gc> *ce = NULL;\n   CONSTRUCTOR_APPEND_ELT (ce, TYPE_FIELDS (ctype), object);\n   CONSTRUCTOR_APPEND_ELT (ce, TREE_CHAIN (TYPE_FIELDS (ctype)), method);\n \n@@ -445,7 +445,7 @@ build_method_call (tree callee, tree object, Type *type)\n /* Extract callee and object from T and return in to CALLEE and OBJECT.  */\n \n void\n-extract_from_method_call (tree t, tree& callee, tree& object)\n+extract_from_method_call (tree t, tree &callee, tree &object)\n {\n   gcc_assert (METHOD_CALL_EXPR (t));\n   object = CONSTRUCTOR_ELT (t, 0)->value;\n@@ -1094,13 +1094,13 @@ build_array_struct_comparison (tree_code code, StructDeclaration *sd,\n    matches the layout of TYPE.  */\n \n tree\n-build_struct_literal (tree type, vec<constructor_elt, va_gc> *init)\n+build_struct_literal (tree type, vec <constructor_elt, va_gc> *init)\n {\n   /* If the initializer was empty, use default zero initialization.  */\n   if (vec_safe_is_empty (init))\n     return build_constructor (type, NULL);\n \n-  vec<constructor_elt, va_gc> *ve = NULL;\n+  vec <constructor_elt, va_gc> *ve = NULL;\n   HOST_WIDE_INT offset = 0;\n   bool constant_p = true;\n   bool finished = false;\n@@ -1685,7 +1685,7 @@ build_array_from_val (Type *type, tree val)\n     val = build_array_from_val (type->nextOf (), val);\n \n   size_t dims = type->isTypeSArray ()->dim->toInteger ();\n-  vec<constructor_elt, va_gc> *elms = NULL;\n+  vec <constructor_elt, va_gc> *elms = NULL;\n   vec_safe_reserve (elms, dims);\n \n   val = d_convert (etype, val);\n@@ -1737,7 +1737,7 @@ build_array_bounds_call (const Loc &loc)\n    If INCLUSIVE, we allow INDEX == LEN to return true also.  */\n \n tree\n-build_bounds_condition (const Loc& loc, tree index, tree len, bool inclusive)\n+build_bounds_condition (const Loc &loc, tree index, tree len, bool inclusive)\n {\n   if (!array_bounds_check ())\n     return index;\n@@ -1873,7 +1873,7 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n     }\n \n   /* Build the argument list for the call.  */\n-  vec<tree, va_gc> *args = NULL;\n+  vec <tree, va_gc> *args = NULL;\n   tree saved_args = NULL_TREE;\n \n   /* If this is a delegate call or a nested function being called as\n@@ -1976,7 +1976,7 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n /* Builds a call to AssertError or AssertErrorMsg.  */\n \n tree\n-d_assert_call (const Loc& loc, libcall_fn libcall, tree msg)\n+d_assert_call (const Loc &loc, libcall_fn libcall, tree msg)\n {\n   tree file;\n   tree line = size_int (loc.linnum);\n@@ -2202,7 +2202,7 @@ get_frame_for_symbol (Dsymbol *sym)\n \t      tree fields = TYPE_FIELDS (type);\n \t      /* The `this' field comes immediately after the `__chain'.  */\n \t      tree thisfield = chain_index (1, fields);\n-\t      vec<constructor_elt, va_gc> *ve = NULL;\n+\t      vec <constructor_elt, va_gc> *ve = NULL;\n \n \t      tree framefields = TYPE_FIELDS (FRAMEINFO_TYPE (ffo));\n \t      frame_ref = build_deref (frame_ref);"}, {"sha": "ffa7f78c82e0c933d2522132274564370f3c64a1", "filename": "gcc/d/d-compiler.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-compiler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-compiler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-compiler.cc?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -89,7 +89,7 @@ Compiler::paintAsType (UnionExp *, Expression *expr, Type *type)\n     {\n       /* Build array as VECTOR_CST, assumes EXPR is constant.  */\n       Expressions *elements = expr->isArrayLiteralExp ()->elements;\n-      vec<constructor_elt, va_gc> *elms = NULL;\n+      vec <constructor_elt, va_gc> *elms = NULL;\n \n       vec_safe_reserve (elms, elements->length);\n       for (size_t i = 0; i < elements->length; i++)"}, {"sha": "5e3e855b2cb6c561b3fded9576128941269438a0", "filename": "gcc/d/d-convert.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-convert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-convert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-convert.cc?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -622,7 +622,7 @@ convert_for_assignment (tree expr, Type *etype, Type *totype)\n \t  tree ctor = build_constructor (build_ctype (totype), NULL);\n \t  if (count)\n \t    {\n-\t      vec<constructor_elt, va_gc> *ce = NULL;\n+\t      vec <constructor_elt, va_gc> *ce = NULL;\n \t      tree index = build2 (RANGE_EXPR, build_ctype (Type::tsize_t),\n \t\t\t\t   size_zero_node, size_int (count - 1));\n \t      tree value = convert_for_assignment (expr, etype, sa_type->next);"}, {"sha": "7eeb41312cfd6f6c58fcf9c1471ac682935be9ad", "filename": "gcc/d/d-diagnostic.cc", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-diagnostic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-diagnostic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-diagnostic.cc?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -119,7 +119,7 @@ expand_d_format (const char *format)\n    front-end, which does not get translated by the gcc diagnostic routines.  */\n \n static void ATTRIBUTE_GCC_DIAG(3,0)\n-d_diagnostic_report_diagnostic (const Loc& loc, int opt, const char *format,\n+d_diagnostic_report_diagnostic (const Loc &loc, int opt, const char *format,\n \t\t\t\tva_list ap, diagnostic_t kind, bool verbatim)\n {\n   va_list argp;\n@@ -159,7 +159,7 @@ d_diagnostic_report_diagnostic (const Loc& loc, int opt, const char *format,\n    error count.  */\n \n void ATTRIBUTE_GCC_DIAG(2,3)\n-error (const Loc& loc, const char *format, ...)\n+error (const Loc &loc, const char *format, ...)\n {\n   va_list ap;\n   va_start (ap, format);\n@@ -168,7 +168,7 @@ error (const Loc& loc, const char *format, ...)\n }\n \n void ATTRIBUTE_GCC_DIAG(2,0)\n-verror (const Loc& loc, const char *format, va_list ap,\n+verror (const Loc &loc, const char *format, va_list ap,\n \tconst char *prefix1, const char *prefix2, const char *)\n {\n   if (!global.gag || global.params.showGaggedErrors)\n@@ -199,7 +199,7 @@ verror (const Loc& loc, const char *format, va_list ap,\n    This doesn't increase the global error count.  */\n \n void ATTRIBUTE_GCC_DIAG(2,3)\n-errorSupplemental (const Loc& loc, const char *format, ...)\n+errorSupplemental (const Loc &loc, const char *format, ...)\n {\n   va_list ap;\n   va_start (ap, format);\n@@ -208,7 +208,7 @@ errorSupplemental (const Loc& loc, const char *format, ...)\n }\n \n void ATTRIBUTE_GCC_DIAG(2,0)\n-verrorSupplemental (const Loc& loc, const char *format, va_list ap)\n+verrorSupplemental (const Loc &loc, const char *format, va_list ap)\n {\n   if (global.gag && !global.params.showGaggedErrors)\n     return;\n@@ -220,7 +220,7 @@ verrorSupplemental (const Loc& loc, const char *format, va_list ap)\n    global warning count.  */\n \n void ATTRIBUTE_GCC_DIAG(2,3)\n-warning (const Loc& loc, const char *format, ...)\n+warning (const Loc &loc, const char *format, ...)\n {\n   va_list ap;\n   va_start (ap, format);\n@@ -229,7 +229,7 @@ warning (const Loc& loc, const char *format, ...)\n }\n \n void ATTRIBUTE_GCC_DIAG(2,0)\n-vwarning (const Loc& loc, const char *format, va_list ap)\n+vwarning (const Loc &loc, const char *format, va_list ap)\n {\n   if (!global.gag && global.params.warnings != DIAGNOSTICoff)\n     {\n@@ -245,7 +245,7 @@ vwarning (const Loc& loc, const char *format, va_list ap)\n    LOC.  This doesn't increase the global warning count.  */\n \n void ATTRIBUTE_GCC_DIAG(2,3)\n-warningSupplemental (const Loc& loc, const char *format, ...)\n+warningSupplemental (const Loc &loc, const char *format, ...)\n {\n   va_list ap;\n   va_start (ap, format);\n@@ -254,7 +254,7 @@ warningSupplemental (const Loc& loc, const char *format, ...)\n }\n \n void ATTRIBUTE_GCC_DIAG(2,0)\n-vwarningSupplemental (const Loc& loc, const char *format, va_list ap)\n+vwarningSupplemental (const Loc &loc, const char *format, va_list ap)\n {\n   if (global.params.warnings == DIAGNOSTICoff || global.gag)\n     return;\n@@ -267,7 +267,7 @@ vwarningSupplemental (const Loc& loc, const char *format, va_list ap)\n    error count depending on how deprecations are treated.  */\n \n void ATTRIBUTE_GCC_DIAG(2,3)\n-deprecation (const Loc& loc, const char *format, ...)\n+deprecation (const Loc &loc, const char *format, ...)\n {\n   va_list ap;\n   va_start (ap, format);\n@@ -276,7 +276,7 @@ deprecation (const Loc& loc, const char *format, ...)\n }\n \n void ATTRIBUTE_GCC_DIAG(2,0)\n-vdeprecation (const Loc& loc, const char *format, va_list ap,\n+vdeprecation (const Loc &loc, const char *format, va_list ap,\n \t      const char *prefix1, const char *prefix2)\n {\n   if (global.params.useDeprecated == DIAGNOSTICerror)\n@@ -303,7 +303,7 @@ vdeprecation (const Loc& loc, const char *format, va_list ap,\n    location LOC.  This does not increase the global error count.  */\n \n void ATTRIBUTE_GCC_DIAG(2,3)\n-deprecationSupplemental (const Loc& loc, const char *format, ...)\n+deprecationSupplemental (const Loc &loc, const char *format, ...)\n {\n   va_list ap;\n   va_start (ap, format);\n@@ -312,7 +312,7 @@ deprecationSupplemental (const Loc& loc, const char *format, ...)\n }\n \n void ATTRIBUTE_GCC_DIAG(2,0)\n-vdeprecationSupplemental (const Loc& loc, const char *format, va_list ap)\n+vdeprecationSupplemental (const Loc &loc, const char *format, va_list ap)\n {\n   if (global.params.useDeprecated == DIAGNOSTICerror)\n     verrorSupplemental (loc, format, ap);\n@@ -323,7 +323,7 @@ vdeprecationSupplemental (const Loc& loc, const char *format, va_list ap)\n /* Print a verbose message with explicit location LOC.  */\n \n void ATTRIBUTE_GCC_DIAG(2, 3)\n-message (const Loc& loc, const char *format, ...)\n+message (const Loc &loc, const char *format, ...)\n {\n   va_list ap;\n   va_start (ap, format);\n@@ -332,7 +332,7 @@ message (const Loc& loc, const char *format, ...)\n }\n \n void ATTRIBUTE_GCC_DIAG(2,0)\n-vmessage (const Loc& loc, const char *format, va_list ap)\n+vmessage (const Loc &loc, const char *format, va_list ap)\n {\n   d_diagnostic_report_diagnostic (loc, 0, format, ap, DK_NOTE, true);\n }"}, {"sha": "3b9fc1aaf2aa1304691fd562e518949e50723188", "filename": "gcc/d/d-frontend.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-frontend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-frontend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-frontend.cc?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -125,7 +125,7 @@ Loc::toChars (void) const\n }\n \n bool\n-Loc::equals (const Loc& loc)\n+Loc::equals (const Loc &loc)\n {\n   if (this->linnum != loc.linnum || this->charnum != loc.charnum)\n     return false;"}, {"sha": "82e24de8cd1edf51cbf8b3797ee4c84dc7b76053", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -95,7 +95,7 @@ struct binding_level *global_binding_level;\n static GTY(()) tree global_context;\n \n /* Array of all global declarations to pass back to the middle-end.  */\n-static GTY(()) vec<tree, va_gc> *global_declarations;\n+static GTY(()) vec <tree, va_gc> *global_declarations;\n \n /* Support for GCC-style command-line make dependency generation.\n    Adds TARGET to the make dependencies target buffer.\n@@ -366,7 +366,7 @@ d_init (void)\n   Objc::_init ();\n \n   /* Back-end init.  */\n-  global_binding_level = ggc_cleared_alloc<binding_level> ();\n+  global_binding_level = ggc_cleared_alloc <binding_level> ();\n   current_binding_level = global_binding_level;\n \n   /* This allows the code in d-builtins.cc to not have to worry about\n@@ -1142,7 +1142,7 @@ d_parse_file (void)\n       unsigned errors = global.startGagging ();\n       Module *m = Module::load (Loc (), NULL, Identifier::idPool (\"__main\"));\n \n-      if (! global.endGagging (errors))\n+      if (!global.endGagging (errors))\n \t{\n \t  m->importedFrom = m;\n \t  modules.push (m);\n@@ -1774,7 +1774,7 @@ d_tree_node_structure (lang_tree_node *t)\n struct lang_type *\n build_lang_type (Type *t)\n {\n-  struct lang_type *lt = ggc_cleared_alloc<struct lang_type> ();\n+  struct lang_type *lt = ggc_cleared_alloc <struct lang_type> ();\n   lt->type = t;\n   return lt;\n }\n@@ -1788,11 +1788,11 @@ build_lang_decl (Declaration *d)\n      there's no associated frontend symbol to refer to (yet).  If the symbol\n      appears later in the compilation, then the slot will be re-used.  */\n   if (d == NULL)\n-    return ggc_cleared_alloc<struct lang_decl> ();\n+    return ggc_cleared_alloc <struct lang_decl> ();\n \n   struct lang_decl *ld = (d->csym) ? DECL_LANG_SPECIFIC (d->csym) : NULL;\n   if (ld == NULL)\n-    ld = ggc_cleared_alloc<struct lang_decl> ();\n+    ld = ggc_cleared_alloc <struct lang_decl> ();\n \n   if (ld->decl == NULL)\n     ld->decl = d;\n@@ -1806,10 +1806,10 @@ build_lang_decl (Declaration *d)\n static void\n d_dup_lang_specific_decl (tree node)\n {\n-  if (! DECL_LANG_SPECIFIC (node))\n+  if (!DECL_LANG_SPECIFIC (node))\n     return;\n \n-  struct lang_decl *ld = ggc_alloc<struct lang_decl> ();\n+  struct lang_decl *ld = ggc_alloc <struct lang_decl> ();\n   memcpy (ld, DECL_LANG_SPECIFIC (node), sizeof (struct lang_decl));\n   DECL_LANG_SPECIFIC (node) = ld;\n }"}, {"sha": "04623d0a30a40b474fceb579623d44dafc418903", "filename": "gcc/d/d-longdouble.cc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-longdouble.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-longdouble.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-longdouble.cc?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -49,7 +49,7 @@ longdouble::normalize (void)\n /* Assign a real_value to a longdouble type.  */\n \n void\n-longdouble::set (real_value& d)\n+longdouble::set (real_value &d)\n {\n   real_convert (&this->rv (), TYPE_MODE (long_double_type_node), &d);\n }\n@@ -117,39 +117,39 @@ longdouble::to_bool (void) const\n /* Overload numeric operators for longdouble types.  */\n \n longdouble\n-longdouble::add (const longdouble& r) const\n+longdouble::add (const longdouble &r) const\n {\n   longdouble x;\n   real_arithmetic (&x.rv (), PLUS_EXPR, &this->rv (), &r.rv ());\n   return x.normalize ();\n }\n \n longdouble\n-longdouble::sub (const longdouble& r) const\n+longdouble::sub (const longdouble &r) const\n {\n   longdouble x;\n   real_arithmetic (&x.rv (), MINUS_EXPR, &this->rv (), &r.rv ());\n   return x.normalize ();\n }\n \n longdouble\n-longdouble::mul (const longdouble& r) const\n+longdouble::mul (const longdouble &r) const\n {\n   longdouble x;\n   real_arithmetic (&x.rv (), MULT_EXPR, &this->rv (), &r.rv ());\n   return x.normalize ();\n }\n \n longdouble\n-longdouble::div (const longdouble& r) const\n+longdouble::div (const longdouble &r) const\n {\n   longdouble x;\n   real_arithmetic (&x.rv (), RDIV_EXPR, &this->rv (), &r.rv ());\n   return x.normalize ();\n }\n \n longdouble\n-longdouble::mod (const longdouble& r) const\n+longdouble::mod (const longdouble &r) const\n {\n   longdouble x;\n   real_value q;\n@@ -186,7 +186,7 @@ longdouble::neg (void) const\n /* Overload equality operators for longdouble types.  */\n \n int\n-longdouble::cmp (const longdouble& r) const\n+longdouble::cmp (const longdouble &r) const\n {\n   if (real_compare (LT_EXPR, &this->rv (), &r.rv ()))\n     return -1;\n@@ -198,7 +198,7 @@ longdouble::cmp (const longdouble& r) const\n }\n \n int\n-longdouble::equals (const longdouble& r) const\n+longdouble::equals (const longdouble &r) const\n {\n   return real_compare (EQ_EXPR, &this->rv (), &r.rv ());\n }"}, {"sha": "d09c33e4ab01f3bb35f0fb3cfd2a7d1322a4363e", "filename": "gcc/d/d-port.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-port.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-port.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-port.cc?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -99,7 +99,7 @@ Port::isFloat64LiteralOutOfRange (const char *buffer)\n unsigned\n Port::readwordLE (const void *buffer)\n {\n-  const unsigned char *p = (const unsigned char*) buffer;\n+  const unsigned char *p = (const unsigned char *) buffer;\n \n   return ((unsigned) p[1] << 8) | (unsigned) p[0];\n }\n@@ -109,7 +109,7 @@ Port::readwordLE (const void *buffer)\n unsigned\n Port::readwordBE (const void *buffer)\n {\n-  const unsigned char *p = (const unsigned char*) buffer;\n+  const unsigned char *p = (const unsigned char *) buffer;\n \n   return ((unsigned) p[0] << 8) | (unsigned) p[1];\n }\n@@ -119,7 +119,7 @@ Port::readwordBE (const void *buffer)\n unsigned\n Port::readlongLE (const void *buffer)\n {\n-  const unsigned char *p = (const unsigned char*) buffer;\n+  const unsigned char *p = (const unsigned char *) buffer;\n \n   return (((unsigned) p[3] << 24)\n \t  | ((unsigned) p[2] << 16)\n@@ -132,7 +132,7 @@ Port::readlongLE (const void *buffer)\n unsigned\n Port::readlongBE (const void *buffer)\n {\n-  const unsigned char *p = (const unsigned char*) buffer;\n+  const unsigned char *p = (const unsigned char *) buffer;\n \n   return (((unsigned) p[0] << 24)\n \t  | ((unsigned) p[1] << 16)"}, {"sha": "cde43e918637e41f79da32606d765bd94c7aee28", "filename": "gcc/d/d-spec.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-spec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-spec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-spec.cc?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -56,7 +56,7 @@ enum phobos_action\n   /* libgphobos is needed and should be linked statically.  */\n   PHOBOS_STATIC,\n   /* libgphobos is needed and should be linked dynamically.  */\n-  PHOBOS_DYNAMIC,\n+  PHOBOS_DYNAMIC\n };\n \n static phobos_action phobos_library = PHOBOS_DEFAULT;"}, {"sha": "4ae38d187d715bcd52fec7d8ae063e78ce68ca28", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -41,7 +41,7 @@ struct Scope;\n struct Loc;\n \n template <typename TYPE> struct Array;\n-typedef Array<Expression *> Expressions;\n+typedef Array <Expression *> Expressions;\n \n /* Usage of TREE_LANG_FLAG_?:\n    0: METHOD_CALL_EXPR\n@@ -234,13 +234,13 @@ struct GTY(()) language_function\n \n   /* Stack of statement lists being collected while we are\n      compiling the function.  */\n-  vec<tree, va_gc> *stmt_list;\n+  vec <tree, va_gc> *stmt_list;\n \n   /* Variables that are in scope that will need destruction later.  */\n-  vec<tree, va_gc> *vars_in_scope;\n+  vec <tree, va_gc> *vars_in_scope;\n \n   /* Table of all used or defined labels in the function.  */\n-  hash_map<Statement *, d_label_entry> *labels;\n+  hash_map <Statement *, d_label_entry> *labels;\n };\n \n /* The D front end types have not been integrated into the GCC garbage\n@@ -536,7 +536,7 @@ extern tree build_struct_comparison (tree_code, StructDeclaration *,\n \t\t\t\t     tree, tree);\n extern tree build_array_struct_comparison (tree_code, StructDeclaration *,\n \t\t\t\t\t   tree, tree, tree);\n-extern tree build_struct_literal (tree, vec<constructor_elt, va_gc> *);\n+extern tree build_struct_literal (tree, vec <constructor_elt, va_gc> *);\n extern tree component_ref (tree, tree);\n extern tree build_assign (tree_code, tree, tree);\n extern tree modify_expr (tree, tree);"}, {"sha": "ea6614fb7144917c0308d9f42d34bba0e2600261", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -63,7 +63,7 @@ const char *\n d_mangle_decl (Dsymbol *decl)\n {\n   if (decl->isFuncDeclaration ())\n-    return mangleExact ((FuncDeclaration *)decl);\n+    return mangleExact ((FuncDeclaration *) decl);\n   else\n     {\n       OutBuffer buf;\n@@ -511,7 +511,7 @@ class DeclVisitor : public Visitor\n     d_finish_decl (d->csym);\n \n     /* Put out the vtbl[].  */\n-    vec<constructor_elt, va_gc> *elms = NULL;\n+    vec <constructor_elt, va_gc> *elms = NULL;\n \n     /* First entry is ClassInfo reference.  */\n     if (d->vtblOffset ())\n@@ -521,7 +521,7 @@ class DeclVisitor : public Visitor\n       {\n \tFuncDeclaration *fd = d->vtbl[i]->isFuncDeclaration ();\n \n-\tif (fd && (fd->fbody || !d->isAbstract()))\n+\tif (fd && (fd->fbody || !d->isAbstract ()))\n \t  {\n \t    CONSTRUCTOR_APPEND_ELT (elms, size_int (i),\n \t\t\t\t    build_address (get_symbol_decl (fd)));\n@@ -1897,7 +1897,7 @@ start_function (FuncDeclaration *fd)\n   else\n     cfun->function_end_locus = DECL_SOURCE_LOCATION (fndecl);\n \n-  cfun->language = ggc_cleared_alloc<language_function> ();\n+  cfun->language = ggc_cleared_alloc <language_function> ();\n   cfun->language->function = fd;\n \n   /* Default chain value is `null' unless parent found.  */\n@@ -2097,7 +2097,7 @@ build_class_instance (ClassReferenceExp *exp)\n {\n   ClassDeclaration *cd = exp->originalClass ();\n   tree type = TREE_TYPE (build_ctype (exp->value->stype));\n-  vec<constructor_elt, va_gc> *ve = NULL;\n+  vec <constructor_elt, va_gc> *ve = NULL;\n \n   /* The set base vtable field.  */\n   tree vptr = build_address (get_vtable_decl (cd));"}, {"sha": "7a209fbe73368f5926768aa63016c7eba892d75e", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -695,7 +695,7 @@ class ExprVisitor : public Visitor\n \ttree var = build_local_temp (make_array_type (targselem, ndims));\n \n \t/* Loop through each concatenation from right to left.  */\n-\tvec<constructor_elt, va_gc> *elms = NULL;\n+\tvec <constructor_elt, va_gc> *elms = NULL;\n \tCatExp *ce = e;\n \tint dim = ndims - 1;\n \n@@ -2465,7 +2465,7 @@ class ExprVisitor : public Visitor\n \t    /* Multidimensional array allocations.  */\n \t    tree tarray = make_array_type (Type::tsize_t, e->arguments->length);\n \t    tree var = build_local_temp (tarray);\n-\t    vec<constructor_elt, va_gc> *elms = NULL;\n+\t    vec <constructor_elt, va_gc> *elms = NULL;\n \n \t    /* Get the base element type for the array, generating the\n \t       initializer for the dims parameter along the way.  */\n@@ -2591,7 +2591,7 @@ class ExprVisitor : public Visitor\n     if (tb->ty == Tsarray)\n       {\n \t/* Turn the string into a constructor for the static array.  */\n-\tvec<constructor_elt, va_gc> *elms = NULL;\n+\tvec <constructor_elt, va_gc> *elms = NULL;\n \tvec_safe_reserve (elms, e->len);\n \ttree etype = TREE_TYPE (type);\n \n@@ -2677,7 +2677,7 @@ class ExprVisitor : public Visitor\n \n     /* Build an expression that assigns the expressions in ELEMENTS to\n        a constructor.  */\n-    vec<constructor_elt, va_gc> *elms = NULL;\n+    vec <constructor_elt, va_gc> *elms = NULL;\n     vec_safe_reserve (elms, e->elements->length);\n     bool constant_p = true;\n     tree saved_elems = NULL_TREE;\n@@ -2784,7 +2784,7 @@ class ExprVisitor : public Visitor\n \n     /* Build an expression that assigns all expressions in KEYS\n        to a constructor.  */\n-    vec<constructor_elt, va_gc> *kelts = NULL;\n+    vec <constructor_elt, va_gc> *kelts = NULL;\n     vec_safe_reserve (kelts, e->keys->length);\n     for (size_t i = 0; i < e->keys->length; i++)\n       {\n@@ -2797,7 +2797,7 @@ class ExprVisitor : public Visitor\n     tree akeys = build_constructor (tkeys, kelts);\n \n     /* Do the same with all expressions in VALUES.  */\n-    vec<constructor_elt, va_gc> *velts = NULL;\n+    vec <constructor_elt, va_gc> *velts = NULL;\n     vec_safe_reserve (velts, e->values->length);\n     for (size_t i = 0; i < e->values->length; i++)\n       {\n@@ -2822,7 +2822,7 @@ class ExprVisitor : public Visitor\n \n     /* Return an associative array pointed to by MEM.  */\n     tree aatype = build_ctype (ta);\n-    vec<constructor_elt, va_gc> *ce = NULL;\n+    vec <constructor_elt, va_gc> *ce = NULL;\n     CONSTRUCTOR_APPEND_ELT (ce, TYPE_FIELDS (aatype), mem);\n \n     this->result_ = build_nop (build_ctype (e->type),\n@@ -2850,7 +2850,7 @@ class ExprVisitor : public Visitor\n \n     /* Build a constructor that assigns the expressions in ELEMENTS\n        at each field index that has been filled in.  */\n-    vec<constructor_elt, va_gc> *ve = NULL;\n+    vec <constructor_elt, va_gc> *ve = NULL;\n     tree saved_elems = NULL_TREE;\n \n     /* CTFE may fill the hidden pointer by NullExp.  */\n@@ -2961,7 +2961,7 @@ class ExprVisitor : public Visitor\n     if (e->e1->op == TOKarrayliteral)\n       {\n \tArrayLiteralExp *ale = e->e1->isArrayLiteralExp ();\n-\tvec<constructor_elt, va_gc> *elms = NULL;\n+\tvec <constructor_elt, va_gc> *elms = NULL;\n \tbool constant_p = true;\n \n \tvec_safe_reserve (elms, ale->elements->length);"}, {"sha": "905e682c9ca03fb3d818ff695d483b7528f47402", "filename": "gcc/d/longdouble.h", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Flongdouble.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Flongdouble.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Flongdouble.h?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -25,21 +25,21 @@ struct longdouble\n {\n public:\n   /* Return the hidden real_value from the longdouble type.  */\n-  const real_value& rv (void) const\n+  const real_value &rv (void) const\n   { return *(const real_value *) this; }\n \n-  real_value& rv (void)\n+  real_value &rv (void)\n   { return *(real_value *) this; }\n \n   /* Normalize the value to be the precision supported by target.  */\n   longdouble normalize (void);\n \n   /* No constructor to be able to use this class in a union.  */\n-  template<typename T> longdouble& operator = (T x)\n+  template <typename T> longdouble &operator = (T x)\n   { set (x); return *this; }\n \n   /* Lvalue operators.  */\n-  void set (real_value& d);\n+  void set (real_value &d);\n   void set (int32_t d);\n   void set (int64_t d);\n   void set (uint32_t d);\n@@ -67,51 +67,51 @@ struct longdouble\n   { return this->to_bool (); }\n \n   /* Arithmetic operators.  */\n-  longdouble add (const longdouble& r) const;\n-  longdouble sub (const longdouble& r) const;\n-  longdouble mul (const longdouble& r) const;\n-  longdouble div (const longdouble& r) const;\n-  longdouble mod (const longdouble& r) const;\n+  longdouble add (const longdouble &r) const;\n+  longdouble sub (const longdouble &r) const;\n+  longdouble mul (const longdouble &r) const;\n+  longdouble div (const longdouble &r) const;\n+  longdouble mod (const longdouble &r) const;\n   longdouble neg () const;\n \n-  longdouble operator + (const longdouble& r)\n+  longdouble operator + (const longdouble &r)\n   { return this->add (r); }\n \n-  longdouble operator - (const longdouble& r)\n+  longdouble operator - (const longdouble &r)\n   { return this->sub (r); }\n \n-  longdouble operator * (const longdouble& r)\n+  longdouble operator * (const longdouble &r)\n   { return this->mul (r); }\n \n-  longdouble operator / (const longdouble& r)\n+  longdouble operator / (const longdouble &r)\n   { return this->div (r); }\n \n-  longdouble operator % (const longdouble& r)\n+  longdouble operator % (const longdouble &r)\n   { return this->mod (r); }\n \n-  longdouble operator -()\n+  longdouble operator - (void)\n   { return this->neg (); }\n \n   /* Comparison operators.  */\n-  int cmp (const longdouble& t) const;\n-  int equals (const longdouble& t) const;\n+  int cmp (const longdouble &t) const;\n+  int equals (const longdouble &t) const;\n \n-  bool operator < (const longdouble& r)\n+  bool operator < (const longdouble &r)\n   { return this->cmp (r) < 0; }\n \n-  bool operator <= (const longdouble& r)\n+  bool operator <= (const longdouble &r)\n   { return this->cmp (r) <= 0; }\n \n-  bool operator > (const longdouble& r)\n+  bool operator > (const longdouble &r)\n   { return this->cmp (r) > 0; }\n \n-  bool operator >= (const longdouble& r)\n+  bool operator >= (const longdouble &r)\n   { return this->cmp (r) >= 0; }\n \n-  bool operator == (const longdouble& r)\n+  bool operator == (const longdouble &r)\n   { return this->equals (r); }\n \n-  bool operator != (const longdouble& r)\n+  bool operator != (const longdouble &r)\n   { return !this->equals (r); }\n \n private:\n@@ -124,7 +124,7 @@ struct longdouble\n typedef longdouble volatile_longdouble;\n \n /* Use ldouble() to explicitly create a longdouble value.  */\n-template<typename T>\n+template <typename T>\n inline longdouble\n ldouble (T x)\n {"}, {"sha": "4b48c19a90e86702c1df5c131e21245122872ad9", "filename": "gcc/d/modules.cc", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fmodules.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Fmodules.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fmodules.cc?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -76,15 +76,15 @@ static tree stop_minfo_node;\n \n struct GTY(()) module_info\n {\n-  vec<tree, va_gc> *ctors;\n-  vec<tree, va_gc> *dtors;\n-  vec<tree, va_gc> *ctorgates;\n+  vec <tree, va_gc> *ctors;\n+  vec <tree, va_gc> *dtors;\n+  vec <tree, va_gc> *ctorgates;\n \n-  vec<tree, va_gc> *sharedctors;\n-  vec<tree, va_gc> *shareddtors;\n-  vec<tree, va_gc> *sharedctorgates;\n+  vec <tree, va_gc> *sharedctors;\n+  vec <tree, va_gc> *shareddtors;\n+  vec <tree, va_gc> *sharedctorgates;\n \n-  vec<tree, va_gc> *unitTests;\n+  vec <tree, va_gc> *unitTests;\n };\n \n /* These must match the values in libdruntime/object_.d.  */\n@@ -122,8 +122,8 @@ static Module *current_module_decl;\n \n /* Static constructors and destructors (not D `static this').  */\n \n-static GTY(()) vec<tree, va_gc> *static_ctor_list;\n-static GTY(()) vec<tree, va_gc> *static_dtor_list;\n+static GTY(()) vec <tree, va_gc> *static_ctor_list;\n+static GTY(()) vec <tree, va_gc> *static_dtor_list;\n \n /* Returns an internal function identified by IDENT.  This is used\n    by both module initialization and dso handlers.  */\n@@ -180,8 +180,8 @@ build_internal_fn (tree ident, tree expr)\n    all variables in GATES, then calls the list of functions in FUNCTIONS.  */\n \n static tree\n-build_funcs_gates_fn (tree ident, vec<tree, va_gc> *functions,\n-\t\t      vec<tree, va_gc> *gates)\n+build_funcs_gates_fn (tree ident, vec <tree, va_gc> *functions,\n+\t\t      vec <tree, va_gc> *gates)\n {\n   tree expr_list = NULL_TREE;\n \n@@ -365,7 +365,7 @@ build_dso_cdtor_fn (bool ctor_p)\n   tree dso_type = get_compiler_dso_type ();\n   tree dso = build_local_temp (dso_type);\n \n-  vec<constructor_elt, va_gc> *ve = NULL;\n+  vec <constructor_elt, va_gc> *ve = NULL;\n   CONSTRUCTOR_APPEND_ELT (ve, NULL_TREE, build_integer_cst (1, size_type_node));\n   CONSTRUCTOR_APPEND_ELT (ve, NULL_TREE, build_address (dso_slot_node));\n   CONSTRUCTOR_APPEND_ELT (ve, NULL_TREE, build_address (start_minfo_node));\n@@ -465,7 +465,7 @@ register_moduleinfo (Module *decl, tree minfo)\n    position.  No alignment is taken into account, all fields are packed.  */\n \n static void\n-layout_moduleinfo_field (tree type, tree rec_type, HOST_WIDE_INT& offset)\n+layout_moduleinfo_field (tree type, tree rec_type, HOST_WIDE_INT &offset)\n {\n   tree field = create_field_decl (type, NULL, 1, 1);\n   insert_aggregate_field (rec_type, field, offset);\n@@ -603,7 +603,7 @@ layout_moduleinfo (Module *decl)\n   /* Put out the two named fields in a ModuleInfo decl:\n \tuint flags;\n \tuint index;  */\n-  vec<constructor_elt, va_gc> *minit = NULL;\n+  vec <constructor_elt, va_gc> *minit = NULL;\n \n   CONSTRUCTOR_APPEND_ELT (minit, NULL_TREE,\n \t\t\t  build_integer_cst (flags, d_uint_type));\n@@ -649,7 +649,7 @@ layout_moduleinfo (Module *decl)\n \n   if (flags & MIimportedModules)\n     {\n-      vec<constructor_elt, va_gc> *elms = NULL;\n+      vec <constructor_elt, va_gc> *elms = NULL;\n       tree satype = make_array_type (Type::tvoidptr, aimports_dim);\n       size_t idx = 0;\n \n@@ -671,7 +671,7 @@ layout_moduleinfo (Module *decl)\n \n   if (flags & MIlocalClasses)\n     {\n-      vec<constructor_elt, va_gc> *elms = NULL;\n+      vec <constructor_elt, va_gc> *elms = NULL;\n       tree satype = make_array_type (Type::tvoidptr, aclasses.length);\n \n       for (size_t i = 0; i < aclasses.length; i++)"}, {"sha": "329efcdb40c085f633793f9c582a5e056f8d34f2", "filename": "gcc/d/toir.cc", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Ftoir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Ftoir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftoir.cc?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -68,7 +68,7 @@ pop_binding_label (Statement * const &, d_label_entry *ent, binding_level *bl)\n    go out of scope.  Queue them in LABELS.  */\n \n bool\n-pop_label (Statement * const &, d_label_entry *ent, vec<tree> &labels)\n+pop_label (Statement * const &, d_label_entry *ent, vec <tree> &labels)\n {\n   if (!ent->bc_label)\n     {\n@@ -93,7 +93,7 @@ void\n push_binding_level (level_kind kind)\n {\n   /* Add it to the front of currently active scopes stack.  */\n-  binding_level *new_level = ggc_cleared_alloc<binding_level> ();\n+  binding_level *new_level = ggc_cleared_alloc <binding_level> ();\n   new_level->level_chain = current_binding_level;\n   new_level->kind = kind;\n \n@@ -103,8 +103,8 @@ push_binding_level (level_kind kind)\n static int\n cmp_labels (const void *p1, const void *p2)\n {\n-  const tree *l1 = (const tree *)p1;\n-  const tree *l2 = (const tree *)p2;\n+  const tree *l1 = (const tree *) p1;\n+  const tree *l2 = (const tree *) p2;\n   return DECL_UID (*l1) - DECL_UID (*l2);\n }\n \n@@ -131,8 +131,9 @@ pop_binding_level (void)\n       /* Pop all the labels declared in the function.  */\n       if (d_function_chain->labels)\n \t{\n-\t  auto_vec<tree> labels;\n-\t  d_function_chain->labels->traverse<vec<tree> &, &pop_label> (labels);\n+\t  auto_vec <tree> labels;\n+\t  d_function_chain->labels->traverse <vec <tree> &,\n+\t\t\t\t\t      &pop_label> (labels);\n \t  d_function_chain->labels->empty ();\n \t  labels.qsort (cmp_labels);\n \t  for (unsigned i = 0; i < labels.length (); ++i)\n@@ -149,7 +150,7 @@ pop_binding_level (void)\n       if (d_function_chain && d_function_chain->labels)\n \t{\n \t  language_function *f = d_function_chain;\n-\t  f->labels->traverse<binding_level *, &pop_binding_label> (level);\n+\t  f->labels->traverse <binding_level *, &pop_binding_label> (level);\n \t}\n \n       current_binding_level->blocks\n@@ -292,7 +293,7 @@ class IRVisitor : public Visitor\n     tree block = pop_binding_level ();\n     tree body = pop_stmt_list ();\n \n-    if (! BLOCK_VARS (block))\n+    if (!BLOCK_VARS (block))\n       return body;\n \n     tree bind = build3 (BIND_EXPR, void_type_node,\n@@ -371,9 +372,9 @@ class IRVisitor : public Visitor\n     gcc_assert (ent != NULL);\n \n     /* If the label hasn't been defined yet, defer checking.  */\n-    if (! DECL_INITIAL (ent->label))\n+    if (!DECL_INITIAL (ent->label))\n       {\n-\td_label_use_entry *fwdref = ggc_alloc<d_label_use_entry> ();\n+\td_label_use_entry *fwdref = ggc_alloc <d_label_use_entry> ();\n \tfwdref->level = current_binding_level;\n \tfwdref->statement = from;\n \tfwdref->next = ent->fwdrefs;\n@@ -446,7 +447,7 @@ class IRVisitor : public Visitor\n     if (!d_function_chain->labels)\n       {\n \td_function_chain->labels\n-\t  = hash_map<Statement *, d_label_entry>::create_ggc (13);\n+\t  = hash_map <Statement *, d_label_entry>::create_ggc (13);\n       }\n \n     d_label_entry *ent = d_function_chain->labels->get (s);\n@@ -461,7 +462,7 @@ class IRVisitor : public Visitor\n \tDECL_MODE (decl) = VOIDmode;\n \n \t/* Create new empty slot.  */\n-\tent = ggc_cleared_alloc<d_label_entry> ();\n+\tent = ggc_cleared_alloc <d_label_entry> ();\n \tent->statement = s;\n \tent->label = decl;\n \n@@ -813,7 +814,7 @@ class IRVisitor : public Visitor\n \t/* Apparently the backend is supposed to sort and set the indexes\n \t   on the case array, have to change them to be usable.  */\n \tType *satype = condtype->sarrayOf (s->cases->length);\n-\tvec<constructor_elt, va_gc> *elms = NULL;\n+\tvec <constructor_elt, va_gc> *elms = NULL;\n \n \ts->cases->sort ();\n "}, {"sha": "ae281d5594621c964d73ac2773c12872a6452ae6", "filename": "gcc/d/typeinfo.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Ftypeinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3c19f0a5072199f70571a30271a0ee9a4ae5ce/gcc%2Fd%2Ftypeinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypeinfo.cc?ref=af3c19f0a5072199f70571a30271a0ee9a4ae5ce", "patch": "@@ -1683,12 +1683,12 @@ class SpeculativeTypeVisitor : public Visitor\n   void visit (TypeAArray *t)\n   {\n     t->index->accept (this);\n-    visit ((TypeNext *)t);\n+    visit ((TypeNext *) t);\n   }\n \n   void visit (TypeFunction *t)\n   {\n-    visit ((TypeNext *)t);\n+    visit ((TypeNext *) t);\n   }\n \n   void visit (TypeStruct *t)"}]}