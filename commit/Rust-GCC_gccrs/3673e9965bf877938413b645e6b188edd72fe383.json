{"sha": "3673e9965bf877938413b645e6b188edd72fe383", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY3M2U5OTY1YmY4Nzc5Mzg0MTNiNjQ1ZTZiMTg4ZWRkNzJmZTM4Mw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-05-31T04:02:43Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-05-31T04:02:43Z"}, "message": "(pa_insn_adjust_length): Rework.\n\n(pa_insn_adjust_length): Rework.  Add code to handle\nmillicode calls with unfilled delay slots and inline block moves.\n\n(compute_movstrsi_length): New function to compute the length of\na movstrsi pattern.\n\n(output_cbranch): Long branches with unfilled delay slots can\nalways nullify the following instruction if their delay slot\nwas not filled.\n\nFrom-SVN: r4602", "tree": {"sha": "6fb2b50993204634cd14f5bdd9ea994c4d788495", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fb2b50993204634cd14f5bdd9ea994c4d788495"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3673e9965bf877938413b645e6b188edd72fe383", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3673e9965bf877938413b645e6b188edd72fe383", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3673e9965bf877938413b645e6b188edd72fe383", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3673e9965bf877938413b645e6b188edd72fe383/comments", "author": null, "committer": null, "parents": [{"sha": "04664e247087df48e99148ba9ceabc25b8557b00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04664e247087df48e99148ba9ceabc25b8557b00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04664e247087df48e99148ba9ceabc25b8557b00"}], "stats": {"total": 180, "additions": 170, "deletions": 10}, "files": [{"sha": "0c37e6c979768356a4aa0d4b5f462817d22a94b2", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 170, "deletions": 10, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3673e9965bf877938413b645e6b188edd72fe383/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3673e9965bf877938413b645e6b188edd72fe383/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=3673e9965bf877938413b645e6b188edd72fe383", "patch": "@@ -1446,6 +1446,120 @@ output_block_move (operands, size_is_constant)\n     }\n   return \"\";\n }\n+\n+/* Count the number of insns necessary to handle this block move.\n+\n+   Basic structure is the same as emit_block_move, except that we\n+   count insns rather than emit them.  */\n+\n+int\n+compute_movstrsi_length (insn)\n+     rtx insn;\n+{\n+  rtx pat = PATTERN (insn);\n+  int size_is_constant;\n+  int align = INTVAL (XEXP (XVECEXP (pat, 0, 6), 0));\n+  unsigned long n_bytes;\n+  int insn_count = 0;\n+\n+  if (GET_CODE (XEXP (XVECEXP (pat, 0, 5), 0)) == CONST_INT)\n+    {\n+      size_is_constant = 1;\n+      n_bytes = INTVAL (XEXP (XVECEXP (pat, 0, 5), 0));\n+    }\n+  else\n+    {\n+      size_is_constant = 0;\n+      n_bytes = 0;\n+    }\n+\n+  /* We can't move more than four bytes at a time because the PA\n+     has no longer integer move insns.  (Could use fp mem ops?)  */\n+  if (align > 4)\n+    align = 4;\n+\n+  if (size_is_constant)\n+    {\n+      unsigned long n_items;\n+      unsigned long offset;\n+      rtx temp;\n+\n+      if (n_bytes == 0)\n+\treturn 0;\n+\n+      if (align >= 4)\n+\t{\n+\t  /* Don't unroll too large blocks.  */\n+\t  if (n_bytes > 64)\n+\t    goto copy_with_loop;\n+\n+\t  /* first load */\n+\t  insn_count = 1;\n+\n+\t  /* Count the unrolled insns.  */\n+\t  for (offset = 4; offset < n_bytes; offset += 4)\n+\t    insn_count += 2;\n+\n+\t  /* Count last store or partial store.  */\n+\t  insn_count += 1;\n+\t  return insn_count;\n+\t}\n+\n+      if (align >= 2 && n_bytes >= 2)\n+\t{\n+\t  /* initial load.  */\n+\t  insn_count = 1;\n+\n+\t  /* Unrolled loop.  */\n+\t  for (offset = 2; offset + 2 <= n_bytes; offset += 2)\n+\t    insn_count += 2;\n+\n+\t  /* ??? odd load/store */\n+\t  if (n_bytes % 2 != 0)\n+\t    insn_count += 2;\n+\n+\t  /* ??? final store from loop.  */\n+\t  insn_count += 1;\n+\n+\t  return insn_count;\n+\t}\n+\n+      /* First load.  */\n+      insn_count = 1;\n+\n+      /* The unrolled loop.  */\n+      for (offset = 1; offset + 1 <= n_bytes; offset += 1)\n+\tinsn_count += 2;\n+\n+      /* Final store.  */\n+      insn_count += 1;\n+\n+      return insn_count;\n+    }\n+\n+  if (align != 4)\n+    abort();\n+     \n+ copy_with_loop:\n+\n+  /* setup for constant and non-constant case.  */\n+  insn_count = 1;\n+\n+  /* The copying loop.  */\n+  insn_count += 3;\n+\n+  /* The counter is negative, >= -4.  The remaining number of bytes are\n+     determined by the two least significant bits.  */\n+\n+  if (size_is_constant)\n+    {\n+      if (n_bytes % 4 != 0)\n+\tinsn_count += 2;\n+    }\n+  else\n+    insn_count += 4;\n+  return insn_count;\n+}\n \f\n \n char *\n@@ -2327,6 +2441,53 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n   return cost - 1;\n }\n \n+/* Return any length adjustment needed by INSN which already has its length\n+   computed as LENGTH.   Return zero if no adjustment is necessary. \n+\n+   For the PA: function calls, millicode calls, and short conditional branches\n+   with unfilled delay slots need an adjustment by +1 (to account for\n+   the NOP which will be inserted into the instruction stream).\n+\n+   Also compute the length of an inline block move here as it is too\n+   complicated to express as a length attribute in pa.md.\n+\n+   (For 2.5) Indirect calls do not need length adjustment as their\n+   delay slot is filled internally in the output template.\n+\n+   (For 2.5) No adjustment is necessary for jump tables or casesi insns.  */\n+int\n+pa_adjust_insn_length (insn, length)\n+    rtx insn;\n+    int length;\n+{\n+  rtx pat = PATTERN (insn);\n+\n+  /* Call insn with an unfilled delay slot.  */ \n+  if (GET_CODE (insn) == CALL_INSN)\n+    return 1;\n+  /* Millicode insn with an unfilled delay slot.  */\n+  else if (GET_CODE (insn) == INSN\n+\t   && GET_CODE (pat) != SEQUENCE\n+\t   && GET_CODE (pat) != USE\n+\t   && GET_CODE (pat) != CLOBBER\n+\t   && get_attr_type (insn) == TYPE_MILLI)\n+    return 1;\n+  /* Block move pattern.  */\n+  else if (GET_CODE (insn) == INSN\n+\t   && GET_CODE (pat) == PARALLEL\n+\t   && GET_CODE (XEXP (XVECEXP (pat, 0, 0), 0)) == MEM\n+\t   && GET_CODE (XEXP (XVECEXP (pat, 0, 0), 1)) == MEM\n+\t   && GET_MODE (XEXP (XVECEXP (pat, 0, 0), 0)) == BLKmode\n+\t   && GET_MODE (XEXP (XVECEXP (pat, 0, 0), 1)) == BLKmode)\n+    return compute_movstrsi_length (insn) - 1;\n+  /* Conditional branch with an unfilled delay slot.  */\n+  else if (GET_CODE (insn) == JUMP_INSN && ! simplejump_p (insn)\n+\t   && length != 2 && length != 4))\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n /* Print operand X (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n    For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n@@ -3064,10 +3225,10 @@ output_cbranch (operands, nullify, length, negated, insn)\n \t  strcat (buf, \"%S3\");\n \telse\n \t  strcat (buf, \"%B3\");\n-\tif (nullify)\n-\t  strcat (buf, \" %2,%1,0\\n\\tbl,n %0,0\");\n-\telse\n-\t  strcat (buf, \" %2,%1,0\\n\\tbl %0,0%#\");\n+\t/* Regardless of whether or not this branch got its slot\n+\t   filled we can nullify the following instruction and \n+\t   avoid emitting a nop.  */\n+\tstrcat (buf, \" %2,%1,0\\n\\tbl%* %0,0\");\n \tbreak;\n \n       /* Long backward conditional branch with nullification.  */\n@@ -3147,14 +3308,13 @@ output_bb (operands, nullify, length, negated, insn, which)\n \t  strcat (buf, \"<\");\n \telse\n \t  strcat (buf, \">=\");\n-\tif (nullify && negated)\n+\t/* Regardless of whether or not this branch got its slot\n+\t   filled we can nullify the following instruction and \n+\t   avoid emitting a nop.  */\n+\tif (negated)\n \t  strcat (buf, \" %0,%1,1,0\\n\\tbl,n %3,0\");\n-\telse if (nullify && ! negated)\n+\telse \n \t  strcat (buf, \" %0,%1,1,0\\n\\tbl,n %2,0\");\n-\telse if (! nullify && negated)\n-\t  strcat (buf, \" %0,%1,1,0\\n\\tbl %3,0%#\");\n-\telse if (! nullify && ! negated)\n-\t  strcat (buf, \" %0,%1,1,0\\n\\tbl %2,0%#\");\n \tbreak;\n \n       /* Long backward conditional branch with nullification.  */"}]}