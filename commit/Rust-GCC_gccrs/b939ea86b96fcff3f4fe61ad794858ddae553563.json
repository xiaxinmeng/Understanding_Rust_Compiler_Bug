{"sha": "b939ea86b96fcff3f4fe61ad794858ddae553563", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkzOWVhODZiOTZmY2ZmM2Y0ZmU2MWFkNzk0ODU4ZGRhZTU1MzU2Mw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-10-13T08:39:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-10-13T08:39:41Z"}, "message": "tree-vect-data-refs.c (vect_analyze_data_ref_dependences): Allocate the data dependence vector.\n\n2015-10-13  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependences): Allocate\n\tthe data dependence vector.\n\t(vect_peeling_hash_insert): Get the peeling hash table as argument.\n\t(vect_peeling_hash_get_lowest_cost): Likewise.\n\t(vect_enhance_data_refs_alignment): Adjust.\n\t(struct _vect_peel_info, struct _vect_peel_extended_info,\n\tstruct peel_info_hasher): Move from ...\n\t* tree-vectorizer.h: ... here.\n\t(LOOP_VINFO_COST_MODEL_MIN_ITERS): Remove.\n\t(LOOP_VINFO_PEELING_HTAB): Likewise.\n\t(struct _loop_vec_info): Remove min_profitable_iters and\n\tpeeling_htab members.\n\t* tree-vect-loop.c (new_loop_vec_info): Do not allocate vectors\n\there.\n\t(destroy_loop_vec_info): Adjust.\n\t(vect_analyze_loop_2): Do not set LOOP_VINFO_COST_MODEL_MIN_ITERS.\n\t(vect_estimate_min_profitable_iters): Use LOOP_VINFO_COMP_ALIAS_DDRS\n\tto estimate alias versioning cost.\n\t* tree-vect-slp.c (vect_analyze_slp_cost): Dump header.\n\nFrom-SVN: r228751", "tree": {"sha": "729ac9ed62a9b2397629cfbe0dfe7004f66eaabf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/729ac9ed62a9b2397629cfbe0dfe7004f66eaabf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b939ea86b96fcff3f4fe61ad794858ddae553563", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b939ea86b96fcff3f4fe61ad794858ddae553563", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b939ea86b96fcff3f4fe61ad794858ddae553563", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b939ea86b96fcff3f4fe61ad794858ddae553563/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b054b08813d37586d6765fd087b0fc85dc94daf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b054b08813d37586d6765fd087b0fc85dc94daf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b054b08813d37586d6765fd087b0fc85dc94daf"}], "stats": {"total": 172, "additions": 91, "deletions": 81}, "files": [{"sha": "e5ede0bda318eb461d2e3ef1cac32c7e15b29a10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939ea86b96fcff3f4fe61ad794858ddae553563/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939ea86b96fcff3f4fe61ad794858ddae553563/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b939ea86b96fcff3f4fe61ad794858ddae553563", "patch": "@@ -1,3 +1,25 @@\n+2015-10-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependences): Allocate\n+\tthe data dependence vector.\n+\t(vect_peeling_hash_insert): Get the peeling hash table as argument.\n+\t(vect_peeling_hash_get_lowest_cost): Likewise.\n+\t(vect_enhance_data_refs_alignment): Adjust.\n+\t(struct _vect_peel_info, struct _vect_peel_extended_info,\n+\tstruct peel_info_hasher): Move from ...\n+\t* tree-vectorizer.h: ... here.\n+\t(LOOP_VINFO_COST_MODEL_MIN_ITERS): Remove.\n+\t(LOOP_VINFO_PEELING_HTAB): Likewise.\n+\t(struct _loop_vec_info): Remove min_profitable_iters and\n+\tpeeling_htab members.\n+\t* tree-vect-loop.c (new_loop_vec_info): Do not allocate vectors\n+\there.\n+\t(destroy_loop_vec_info): Adjust.\n+\t(vect_analyze_loop_2): Do not set LOOP_VINFO_COST_MODEL_MIN_ITERS.\n+\t(vect_estimate_min_profitable_iters): Use LOOP_VINFO_COMP_ALIAS_DDRS\n+\tto estimate alias versioning cost.\n+\t* tree-vect-slp.c (vect_analyze_slp_cost): Dump header.\n+\n 2015-10-13  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* real.h (real_isinteger): Declare."}, {"sha": "8a4d48919302edf25f24dc499eb5c75f21a0805d", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 55, "deletions": 17, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939ea86b96fcff3f4fe61ad794858ddae553563/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939ea86b96fcff3f4fe61ad794858ddae553563/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=b939ea86b96fcff3f4fe61ad794858ddae553563", "patch": "@@ -468,6 +468,9 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo, int *max_vf)\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_analyze_data_ref_dependences ===\\n\");\n \n+  LOOP_VINFO_DDRS (loop_vinfo)\n+    .create (LOOP_VINFO_DATAREFS (loop_vinfo).length ()\n+\t     * LOOP_VINFO_DATAREFS (loop_vinfo).length ());\n   LOOP_VINFO_NO_DATA_DEPENDENCIES (loop_vinfo) = true;\n   if (!compute_all_dependences (LOOP_VINFO_DATAREFS (loop_vinfo),\n \t\t\t\t&LOOP_VINFO_DDRS (loop_vinfo),\n@@ -1039,18 +1042,56 @@ vect_get_data_access_cost (struct data_reference *dr,\n }\n \n \n+typedef struct _vect_peel_info\n+{\n+  int npeel;\n+  struct data_reference *dr;\n+  unsigned int count;\n+} *vect_peel_info;\n+\n+typedef struct _vect_peel_extended_info\n+{\n+  struct _vect_peel_info peel_info;\n+  unsigned int inside_cost;\n+  unsigned int outside_cost;\n+  stmt_vector_for_cost body_cost_vec;\n+} *vect_peel_extended_info;\n+\n+\n+/* Peeling hashtable helpers.  */\n+\n+struct peel_info_hasher : free_ptr_hash <_vect_peel_info>\n+{\n+  static inline hashval_t hash (const _vect_peel_info *);\n+  static inline bool equal (const _vect_peel_info *, const _vect_peel_info *);\n+};\n+\n+inline hashval_t\n+peel_info_hasher::hash (const _vect_peel_info *peel_info)\n+{\n+  return (hashval_t) peel_info->npeel;\n+}\n+\n+inline bool\n+peel_info_hasher::equal (const _vect_peel_info *a, const _vect_peel_info *b)\n+{\n+  return (a->npeel == b->npeel);\n+}\n+\n+\n /* Insert DR into peeling hash table with NPEEL as key.  */\n \n static void\n-vect_peeling_hash_insert (loop_vec_info loop_vinfo, struct data_reference *dr,\n+vect_peeling_hash_insert (hash_table<peel_info_hasher> *peeling_htab,\n+\t\t\t  loop_vec_info loop_vinfo, struct data_reference *dr,\n                           int npeel)\n {\n   struct _vect_peel_info elem, *slot;\n   _vect_peel_info **new_slot;\n   bool supportable_dr_alignment = vect_supportable_dr_alignment (dr, true);\n \n   elem.npeel = npeel;\n-  slot = LOOP_VINFO_PEELING_HTAB (loop_vinfo)->find (&elem);\n+  slot = peeling_htab->find (&elem);\n   if (slot)\n     slot->count++;\n   else\n@@ -1059,8 +1100,7 @@ vect_peeling_hash_insert (loop_vec_info loop_vinfo, struct data_reference *dr,\n       slot->npeel = npeel;\n       slot->dr = dr;\n       slot->count = 1;\n-      new_slot\n-       \t= LOOP_VINFO_PEELING_HTAB (loop_vinfo)->find_slot (slot, INSERT);\n+      new_slot = peeling_htab->find_slot (slot, INSERT);\n       *new_slot = slot;\n     }\n \n@@ -1164,7 +1204,8 @@ vect_peeling_hash_get_lowest_cost (_vect_peel_info **slot,\n    option that aligns as many accesses as possible.  */\n \n static struct data_reference *\n-vect_peeling_hash_choose_best_peeling (loop_vec_info loop_vinfo,\n+vect_peeling_hash_choose_best_peeling (hash_table<peel_info_hasher> *peeling_htab,\n+\t\t\t\t       loop_vec_info loop_vinfo,\n                                        unsigned int *npeel,\n \t\t\t\t       stmt_vector_for_cost *body_cost_vec)\n {\n@@ -1177,16 +1218,14 @@ vect_peeling_hash_choose_best_peeling (loop_vec_info loop_vinfo,\n      {\n        res.inside_cost = INT_MAX;\n        res.outside_cost = INT_MAX;\n-       LOOP_VINFO_PEELING_HTAB (loop_vinfo)\n-           ->traverse <_vect_peel_extended_info *,\n-                       vect_peeling_hash_get_lowest_cost> (&res);\n+       peeling_htab->traverse <_vect_peel_extended_info *,\n+\t   \t\t       vect_peeling_hash_get_lowest_cost> (&res);\n      }\n    else\n      {\n        res.peel_info.count = 0;\n-       LOOP_VINFO_PEELING_HTAB (loop_vinfo)\n-           ->traverse <_vect_peel_extended_info *,\n-                       vect_peeling_hash_get_most_frequent> (&res);\n+       peeling_htab->traverse <_vect_peel_extended_info *,\n+\t   \t\t       vect_peeling_hash_get_most_frequent> (&res);\n      }\n \n    *npeel = res.peel_info.npeel;\n@@ -1307,6 +1346,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   tree vectype;\n   unsigned int nelements, mis, same_align_drs_max = 0;\n   stmt_vector_for_cost body_cost_vec = stmt_vector_for_cost ();\n+  hash_table<peel_info_hasher> peeling_htab (1);\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -1379,10 +1419,6 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t\t\t\t\t    size_zero_node) < 0;\n \n               /* Save info about DR in the hash table.  */\n-              if (!LOOP_VINFO_PEELING_HTAB (loop_vinfo))\n-                LOOP_VINFO_PEELING_HTAB (loop_vinfo)\n-\t\t  = new hash_table<peel_info_hasher> (1);\n-\n               vectype = STMT_VINFO_VECTYPE (stmt_info);\n               nelements = TYPE_VECTOR_SUBPARTS (vectype);\n               mis = DR_MISALIGNMENT (dr) / GET_MODE_SIZE (TYPE_MODE (\n@@ -1424,7 +1460,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n               for (j = 0; j < possible_npeel_number; j++)\n                 {\n-                  vect_peeling_hash_insert (loop_vinfo, dr, npeel_tmp);\n+                  vect_peeling_hash_insert (&peeling_htab, loop_vinfo,\n+\t\t\t\t\t    dr, npeel_tmp);\n                   npeel_tmp += nelements;\n                 }\n \n@@ -1590,7 +1627,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       gcc_assert (!all_misalignments_unknown);\n \n       /* Choose the best peeling from the hash table.  */\n-      dr0 = vect_peeling_hash_choose_best_peeling (loop_vinfo, &npeel,\n+      dr0 = vect_peeling_hash_choose_best_peeling (&peeling_htab,\n+\t\t\t\t\t\t   loop_vinfo, &npeel,\n \t\t\t\t\t\t   &body_cost_vec);\n       if (!dr0 || !npeel)\n         do_peeling = false;"}, {"sha": "68405351d29be910049e0792e536cbb42af2bb6d", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939ea86b96fcff3f4fe61ad794858ddae553563/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939ea86b96fcff3f4fe61ad794858ddae553563/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b939ea86b96fcff3f4fe61ad794858ddae553563", "patch": "@@ -937,23 +937,20 @@ new_loop_vec_info (struct loop *loop)\n   LOOP_VINFO_NITERSM1 (res) = NULL;\n   LOOP_VINFO_NITERS (res) = NULL;\n   LOOP_VINFO_NITERS_UNCHANGED (res) = NULL;\n-  LOOP_VINFO_COST_MODEL_MIN_ITERS (res) = 0;\n   LOOP_VINFO_COST_MODEL_THRESHOLD (res) = 0;\n   LOOP_VINFO_VECTORIZABLE_P (res) = 0;\n   LOOP_VINFO_PEELING_FOR_ALIGNMENT (res) = 0;\n   LOOP_VINFO_VECT_FACTOR (res) = 0;\n-  LOOP_VINFO_LOOP_NEST (res).create (3);\n-  LOOP_VINFO_DATAREFS (res).create (10);\n-  LOOP_VINFO_DDRS (res).create (10 * 10);\n+  LOOP_VINFO_LOOP_NEST (res) = vNULL;\n+  LOOP_VINFO_DATAREFS (res) = vNULL;\n+  LOOP_VINFO_DDRS (res) = vNULL;\n   LOOP_VINFO_UNALIGNED_DR (res) = NULL;\n-  LOOP_VINFO_MAY_MISALIGN_STMTS (res).create (\n-\t     PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIGNMENT_CHECKS));\n-  LOOP_VINFO_MAY_ALIAS_DDRS (res).create (\n-\t     PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS));\n-  LOOP_VINFO_GROUPED_STORES (res).create (10);\n-  LOOP_VINFO_REDUCTIONS (res).create (10);\n-  LOOP_VINFO_REDUCTION_CHAINS (res).create (10);\n-  LOOP_VINFO_SLP_INSTANCES (res).create (10);\n+  LOOP_VINFO_MAY_MISALIGN_STMTS (res) = vNULL;\n+  LOOP_VINFO_MAY_ALIAS_DDRS (res) = vNULL;\n+  LOOP_VINFO_GROUPED_STORES (res) = vNULL;\n+  LOOP_VINFO_REDUCTIONS (res) = vNULL;\n+  LOOP_VINFO_REDUCTION_CHAINS (res) = vNULL;\n+  LOOP_VINFO_SLP_INSTANCES (res) = vNULL;\n   LOOP_VINFO_SLP_UNROLLING_FACTOR (res) = 1;\n   LOOP_VINFO_TARGET_COST_DATA (res) = init_cost (loop);\n   LOOP_VINFO_PEELING_FOR_GAPS (res) = false;\n@@ -1036,9 +1033,6 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n   LOOP_VINFO_REDUCTIONS (loop_vinfo).release ();\n   LOOP_VINFO_REDUCTION_CHAINS (loop_vinfo).release ();\n \n-  delete LOOP_VINFO_PEELING_HTAB (loop_vinfo);\n-  LOOP_VINFO_PEELING_HTAB (loop_vinfo) = NULL;\n-\n   destroy_cost_data (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n   loop_vinfo->scalar_cost_vec.release ();\n \n@@ -1786,7 +1780,6 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   int min_profitable_estimate, min_profitable_iters;\n   vect_estimate_min_profitable_iters (loop_vinfo, &min_profitable_iters,\n \t\t\t\t      &min_profitable_estimate);\n-  LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo) = min_profitable_iters;\n \n   if (min_profitable_iters < 0)\n     {\n@@ -2810,7 +2803,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   if (LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))\n     {\n       /*  FIXME: Make cost depend on complexity of individual check.  */\n-      unsigned len = LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo).length ();\n+      unsigned len = LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo).length ();\n       (void) add_stmt_cost (target_cost_data, len, vector_stmt, NULL, 0,\n \t\t\t    vect_prologue);\n       dump_printf (MSG_NOTE,"}, {"sha": "7e6ac526a1ad1777d89d3ae5cfff26d2c2c1a45d", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939ea86b96fcff3f4fe61ad794858ddae553563/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939ea86b96fcff3f4fe61ad794858ddae553563/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=b939ea86b96fcff3f4fe61ad794858ddae553563", "patch": "@@ -1569,6 +1569,10 @@ vect_analyze_slp_cost (slp_instance instance, void *data)\n   stmt_info_for_cost *si;\n   unsigned i;\n \n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"=== vect_analyze_slp_cost ===\\n\");\n+\n   /* Calculate the number of vector stmts to create based on the unrolling\n      factor (number of vectors is 1 if NUNITS >= GROUP_SIZE, and is\n      GROUP_SIZE / NUNITS otherwise.  */"}, {"sha": "ebe38b762bd29973f37020019866dde14e0d23fd", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939ea86b96fcff3f4fe61ad794858ddae553563/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939ea86b96fcff3f4fe61ad794858ddae553563/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=b939ea86b96fcff3f4fe61ad794858ddae553563", "patch": "@@ -194,41 +194,6 @@ struct dr_with_seg_len_pair_t\n };\n \n \n-typedef struct _vect_peel_info\n-{\n-  int npeel;\n-  struct data_reference *dr;\n-  unsigned int count;\n-} *vect_peel_info;\n-\n-typedef struct _vect_peel_extended_info\n-{\n-  struct _vect_peel_info peel_info;\n-  unsigned int inside_cost;\n-  unsigned int outside_cost;\n-  stmt_vector_for_cost body_cost_vec;\n-} *vect_peel_extended_info;\n-\n-\n-/* Peeling hashtable helpers.  */\n-\n-struct peel_info_hasher : free_ptr_hash <_vect_peel_info>\n-{\n-  static inline hashval_t hash (const _vect_peel_info *);\n-  static inline bool equal (const _vect_peel_info *, const _vect_peel_info *);\n-};\n-\n-inline hashval_t\n-peel_info_hasher::hash (const _vect_peel_info *peel_info)\n-{\n-  return (hashval_t) peel_info->npeel;\n-}\n-\n-inline bool\n-peel_info_hasher::equal (const _vect_peel_info *a, const _vect_peel_info *b)\n-{\n-  return (a->npeel == b->npeel);\n-}\n \n /* Vectorizer state common between loop and basic-block vectorization.  */\n struct vec_info {\n@@ -289,13 +254,6 @@ typedef struct _loop_vec_info : public vec_info {\n   /* Number of iterations of the original loop.  */\n   tree num_iters_unchanged;\n \n-  /* Minimum number of iterations below which vectorization is expected to\n-     not be profitable (as estimated by the cost model).\n-     -1 indicates that vectorization will not be profitable.\n-     FORNOW: This field is an int. Will be a tree in the future, to represent\n-\t     values unknown at compile time.  */\n-  int min_profitable_iters;\n-\n   /* Threshold of number of iterations below which vectorzation will not be\n      performed. It is calculated from MIN_PROFITABLE_ITERS and\n      PARAM_MIN_VECT_LOOP_BOUND.  */\n@@ -349,9 +307,6 @@ typedef struct _loop_vec_info : public vec_info {\n      stmt in the chain.  */\n   vec<gimple *> reduction_chains;\n \n-  /* Hash table used to choose the best peeling option.  */\n-  hash_table<peel_info_hasher> *peeling_htab;\n-\n   /* Cost vector for a single scalar iteration.  */\n   vec<stmt_info_for_cost> scalar_cost_vec;\n \n@@ -407,7 +362,6 @@ typedef struct _loop_vec_info : public vec_info {\n    prologue peeling retain total unchanged scalar loop iterations for\n    cost model.  */\n #define LOOP_VINFO_NITERS_UNCHANGED(L)     (L)->num_iters_unchanged\n-#define LOOP_VINFO_COST_MODEL_MIN_ITERS(L) (L)->min_profitable_iters\n #define LOOP_VINFO_COST_MODEL_THRESHOLD(L) (L)->th\n #define LOOP_VINFO_VECTORIZABLE_P(L)       (L)->vectorizable\n #define LOOP_VINFO_VECT_FACTOR(L)          (L)->vectorization_factor\n@@ -426,7 +380,6 @@ typedef struct _loop_vec_info : public vec_info {\n #define LOOP_VINFO_SLP_UNROLLING_FACTOR(L) (L)->slp_unrolling_factor\n #define LOOP_VINFO_REDUCTIONS(L)           (L)->reductions\n #define LOOP_VINFO_REDUCTION_CHAINS(L)     (L)->reduction_chains\n-#define LOOP_VINFO_PEELING_HTAB(L)         (L)->peeling_htab\n #define LOOP_VINFO_TARGET_COST_DATA(L)     (L)->target_cost_data\n #define LOOP_VINFO_PEELING_FOR_GAPS(L)     (L)->peeling_for_gaps\n #define LOOP_VINFO_OPERANDS_SWAPPED(L)     (L)->operands_swapped"}]}