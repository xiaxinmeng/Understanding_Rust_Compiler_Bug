{"sha": "83720594cedb0b10abc4c0e28b8ec71e8a5f999d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM3MjA1OTRjZWRiMGIxMGFiYzRjMGUyOGI4ZWM3MWU4YTVmOTk5ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-03-28T11:19:20Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-03-28T11:19:20Z"}, "message": "rs6000.c (rs6000_stack_info): Allocate space for eh_return data registers.\n\n        * config/rs6000/rs6000.c (rs6000_stack_info): Allocate space\n        for eh_return data registers.\n        (rs6000_emit_prologue): Save eh_return data registers.\n        (rs6000_emit_epilogue): Force inline restores if eh_return.\n        Restore eh_return data registers.  Mind EH_RETURN_STACKADJ_RTX.\n        * config/rs6000/rs6000.h (rs6000_stack_t): Add ehrd_offset.\n        (EH_RETURN_DATA_REGNO, EH_RETURN_STACKADJ_RTX): New.\n        (EPILOGUE_USES): True for TOC_REGISTER if calls_eh_return and\n        the target uses one.\n        * config/rs6000/rs6000.md (eh_epilogue, eh_reg_restore): Remove.\n        (return_eh_si, return_eh_di): Remove.\n        (eh_return): New, from corpse of eh_epilogue.\n        (eh_set_lr_si, eh_set_lr_di): New.\n\nFrom-SVN: r40927", "tree": {"sha": "c0090fc2e8668cc9dfcbe6558c32adf6588d3142", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0090fc2e8668cc9dfcbe6558c32adf6588d3142"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83720594cedb0b10abc4c0e28b8ec71e8a5f999d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83720594cedb0b10abc4c0e28b8ec71e8a5f999d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83720594cedb0b10abc4c0e28b8ec71e8a5f999d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83720594cedb0b10abc4c0e28b8ec71e8a5f999d/comments", "author": null, "committer": null, "parents": [{"sha": "1020a5ab7ee1a39c3d2be3d3bdb4242985d75812", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1020a5ab7ee1a39c3d2be3d3bdb4242985d75812", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1020a5ab7ee1a39c3d2be3d3bdb4242985d75812"}], "stats": {"total": 251, "additions": 146, "deletions": 105}, "files": [{"sha": "b6d3eb9f2e55508019d016440d1802ab7031ff87", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83720594cedb0b10abc4c0e28b8ec71e8a5f999d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83720594cedb0b10abc4c0e28b8ec71e8a5f999d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83720594cedb0b10abc4c0e28b8ec71e8a5f999d", "patch": "@@ -1,5 +1,19 @@\n 2001-03-28  Richard Henderson  <rth@redhat.com>\n \n+\t* config/rs6000/rs6000.c (rs6000_stack_info): Allocate space\n+\tfor eh_return data registers.\n+\t(rs6000_emit_prologue): Save eh_return data registers.\n+\t(rs6000_emit_epilogue): Force inline restores if eh_return.\n+\tRestore eh_return data registers.  Mind EH_RETURN_STACKADJ_RTX.\n+\t* config/rs6000/rs6000.h (rs6000_stack_t): Add ehrd_offset.\n+\t(EH_RETURN_DATA_REGNO, EH_RETURN_STACKADJ_RTX): New.\n+\t(EPILOGUE_USES): True for TOC_REGISTER if calls_eh_return and\n+\tthe target uses one.\n+\t* config/rs6000/rs6000.md (eh_epilogue, eh_reg_restore): Remove.\n+\t(return_eh_si, return_eh_di): Remove.\n+\t(eh_return): New, from corpse of eh_epilogue.\n+\t(eh_set_lr_si, eh_set_lr_di): New.\n+\n \t* config/i386/i386.c (general_no_elim_operand): Disallow virtual regs.\n \t(ix86_save_reg): If maybe_eh_return, true for EH_RETURN_DATA_REGNOs.\n \tTrue for pic register if current_function_calls_eh_return."}, {"sha": "4b24bfb800f24a2bf3830f5979ff496eb40ab868", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 73, "deletions": 2, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83720594cedb0b10abc4c0e28b8ec71e8a5f999d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83720594cedb0b10abc4c0e28b8ec71e8a5f999d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=83720594cedb0b10abc4c0e28b8ec71e8a5f999d", "patch": "@@ -4808,6 +4808,7 @@ rs6000_stack_info ()\n   rs6000_stack_t *info_ptr = &info;\n   int reg_size = TARGET_POWERPC64 ? 8 : 4;\n   enum rs6000_abi abi;\n+  int ehrd_size;\n   int total_raw_size;\n \n   /* Zero all fields portably */\n@@ -4860,6 +4861,19 @@ rs6000_stack_info ()\n \tinfo_ptr->cr_size = reg_size;\n     }\n \n+  /* If the current function calls __builtin_eh_return, then we need\n+     to allocate stack space for registers that will hold data for\n+     the exception handler.  */\n+  if (current_function_calls_eh_return)\n+    {\n+      unsigned int i;\n+      for (i = 0; EH_RETURN_DATA_REGNO (i) != INVALID_REGNUM; ++i)\n+\tcontinue;\n+      ehrd_size = i * UNITS_PER_WORD;\n+    }\n+  else\n+    ehrd_size = 0;\n+\n   /* Determine various sizes */\n   info_ptr->reg_size     = reg_size;\n   info_ptr->fixed_size   = RS6000_SAVE_AREA;\n@@ -4868,6 +4882,7 @@ rs6000_stack_info ()\n   info_ptr->parm_size    = RS6000_ALIGN (current_function_outgoing_args_size, 8);\n   info_ptr->save_size    = RS6000_ALIGN (info_ptr->fp_size\n \t\t\t\t  + info_ptr->gp_size\n+\t\t\t\t  + ehrd_size\n \t\t\t\t  + info_ptr->cr_size\n \t\t\t\t  + info_ptr->lr_size\n \t\t\t\t  + info_ptr->toc_size, 8);\n@@ -4883,6 +4898,7 @@ rs6000_stack_info ()\n     case ABI_AIX_NODESC:\n       info_ptr->fp_save_offset   = - info_ptr->fp_size;\n       info_ptr->gp_save_offset   = info_ptr->fp_save_offset - info_ptr->gp_size;\n+      info_ptr->ehrd_offset      = info_ptr->gp_save_offset - ehrd_size;\n       info_ptr->cr_save_offset   = reg_size; /* first word when 64-bit.  */\n       info_ptr->lr_save_offset   = 2*reg_size;\n       break;\n@@ -4893,6 +4909,7 @@ rs6000_stack_info ()\n       info_ptr->gp_save_offset   = info_ptr->fp_save_offset - info_ptr->gp_size;\n       info_ptr->cr_save_offset   = info_ptr->gp_save_offset - info_ptr->cr_size;\n       info_ptr->toc_save_offset  = info_ptr->cr_save_offset - info_ptr->toc_size;\n+      info_ptr->ehrd_offset      = info_ptr->toc_save_offset - ehrd_size;\n       info_ptr->lr_save_offset   = reg_size;\n       break;\n     }\n@@ -5585,7 +5602,7 @@ rs6000_frame_related (insn, reg, val, reg2, rreg)\n /* Emit function prologue as insns.  */\n \n void\n-rs6000_emit_prologue()\n+rs6000_emit_prologue ()\n {\n   rs6000_stack_t *info = rs6000_stack_info ();\n   enum machine_mode reg_mode = TARGET_POWERPC64 ? DImode : SImode;\n@@ -5741,6 +5758,31 @@ rs6000_emit_prologue()\n \t  }\n     }\n \n+  /* ??? There's no need to emit actual instructions here, but it's the\n+     easiest way to get the frame unwind information emitted.  */\n+  if (current_function_calls_eh_return)\n+    {\n+      unsigned int i, regno;\n+      for (i = 0; ; ++i)\n+\t{\n+\t  rtx addr, reg, mem;\n+\n+\t  regno = EH_RETURN_DATA_REGNO (i);\n+\t  if (regno == INVALID_REGNUM)\n+\t    break;\n+\n+\t  reg = gen_rtx_REG (reg_mode, regno);\n+\t  addr = plus_constant (frame_reg_rtx,\n+\t\t\t\tinfo->ehrd_offset + sp_offset + reg_size * i);\n+\t  mem = gen_rtx_MEM (reg_mode, addr);\n+\t  MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+\n+\t  insn = emit_move_insn (mem, reg);\n+\t  rs6000_frame_related (insn, frame_ptr_rtx, info->total_size, \n+\t\t\t\tNULL_RTX, NULL_RTX);\n+\t}\n+    }\n+\n   /* Save lr if we used it.  */\n   if (info->lr_save_p)\n     {\n@@ -5876,7 +5918,7 @@ output_prolog (file, size)\n    need special notes to explain where r11 is in relation to the stack.  */\n \n void\n-rs6000_emit_epilogue(sibcall)\n+rs6000_emit_epilogue (sibcall)\n      int sibcall;\n {\n   rs6000_stack_t *info;\n@@ -5895,6 +5937,7 @@ rs6000_emit_epilogue(sibcall)\n   using_load_multiple = (TARGET_MULTIPLE && ! TARGET_POWERPC64\n \t\t\t && info->first_gp_reg_save < 31);\n   restoring_FPRs_inline = (sibcall\n+\t\t\t   || current_function_calls_eh_return\n \t\t\t   || info->first_fp_reg_save == 64\n \t\t\t   || FP_SAVE_INLINE (info->first_fp_reg_save));\n   use_backchain_to_restore_sp = (frame_pointer_needed \n@@ -5960,6 +6003,26 @@ rs6000_emit_epilogue(sibcall)\n     emit_move_insn (gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM),\n \t\t    gen_rtx_REG (Pmode, 0));\n   \n+  /* Load exception handler data registers, if needed.  */\n+  if (current_function_calls_eh_return)\n+    {\n+      unsigned int i, regno;\n+      for (i = 0; ; ++i)\n+\t{\n+\t  rtx addr, mem;\n+\n+\t  regno = EH_RETURN_DATA_REGNO (i);\n+\t  if (regno == INVALID_REGNUM)\n+\t    break;\n+\n+\t  addr = plus_constant (frame_reg_rtx,\n+\t\t\t\tinfo->ehrd_offset + sp_offset + reg_size * i);\n+\t  mem = gen_rtx_MEM (reg_mode, addr);\n+\t  MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+\n+\t  emit_move_insn (gen_rtx_REG (reg_mode, regno), mem);\n+\t}\n+    }\n   \n   /* Restore GPRs.  This is done as a PARALLEL if we are using\n      the load-multiple instructions.  */\n@@ -6095,6 +6158,14 @@ rs6000_emit_epilogue(sibcall)\n \t}\n     }\n \n+  if (current_function_calls_eh_return)\n+    {\n+      rtx sa = EH_RETURN_STACKADJ_RTX;\n+      emit_insn (Pmode == SImode\n+\t\t ? gen_addsi3 (sp_reg_rtx, sp_reg_rtx, sa)\n+\t\t : gen_adddi3 (sp_reg_rtx, sp_reg_rtx, sa));\n+    }\n+\n   if (!sibcall)\n     {\n       rtvec p;"}, {"sha": "a520b57cce71b128eb801fdffdea17ac00e15f7c", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83720594cedb0b10abc4c0e28b8ec71e8a5f999d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83720594cedb0b10abc4c0e28b8ec71e8a5f999d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=83720594cedb0b10abc4c0e28b8ec71e8a5f999d", "patch": "@@ -1180,6 +1180,7 @@ typedef struct rs6000_stack {\n   int cr_save_offset;\t\t/* offset to save CR from initial SP */\n   int toc_save_offset;\t\t/* offset to save the TOC pointer */\n   int varargs_save_offset;\t/* offset to save the varargs registers */\n+  int ehrd_offset;\t\t/* offset to EH return data */\n   int reg_size;\t\t\t/* register size (4 or 8) */\n   int varargs_size;\t\t/* size to hold V.4 args passed in regs */\n   int vars_size;\t\t/* variable save area size */\n@@ -1569,8 +1570,11 @@ typedef struct rs6000_args\n    and frame pointer registers are already be assumed to be used as\n    needed.  */\n \n-#define\tEPILOGUE_USES(REGNO)\t\\\n-  (reload_completed && (REGNO) == LINK_REGISTER_REGNUM)\n+#define\tEPILOGUE_USES(REGNO)\t\t\t\t\t\\\n+  ((reload_completed && (REGNO) == LINK_REGISTER_REGNUM)\t\\\n+   || (current_function_calls_eh_return\t\t\t\t\\\n+       && TARGET_TOC\t\t\t\t\t\t\\\n+       && (REGNO) == TOC_REGISTER))\n \n /* This macro generates the assembly code for function exit,\n    on machines that need it.  If FUNCTION_EPILOGUE is not defined\n@@ -2641,6 +2645,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define INCOMING_RETURN_ADDR_RTX   gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM)\n #define DWARF_FRAME_RETURN_COLUMN  DWARF_FRAME_REGNUM (LINK_REGISTER_REGNUM)\n \n+/* Describe how we implement __builtin_eh_return.  */\n+#define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N) + 3 : INVALID_REGNUM)\n+#define EH_RETURN_STACKADJ_RTX  gen_rtx_REG (Pmode, 10)\n+\n /* Define results of standard character escape sequences.  */\n #define TARGET_BELL 007\n #define TARGET_BS 010"}, {"sha": "e92cbc8703b52a83a76aa9cff05e9927399eb12c", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 49, "deletions": 101, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83720594cedb0b10abc4c0e28b8ec71e8a5f999d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83720594cedb0b10abc4c0e28b8ec71e8a5f999d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=83720594cedb0b10abc4c0e28b8ec71e8a5f999d", "patch": "@@ -13381,118 +13381,66 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n  \"TARGET_64BIT\"\n  \"b %z2\")\n \n-; This is used in compiling the routines __throw and __rethrow.\n-; It's a little different to the usual definition...\n-\n-(define_expand \"eh_epilogue\"\n-  [(use (match_operand 0 \"general_operand\" \"r\"))\n-   (use (match_operand 1 \"general_operand\" \"r\"))\n-   (use (match_operand 2 \"general_operand\" \"c\"))]\n+; This is used in compiling the unwind routines.\n+(define_expand \"eh_return\"\n+  [(use (match_operand 0 \"general_operand\" \"\"))\n+   (use (match_operand 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  rtx stack_reg = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n-  rtx insn;\n-\n-  /* This is required for binary compatibility.  If it's wrong,\n-     it probably means that eh_regs() in except.c is broken.  */\n-  if (GET_CODE (operands[0]) != REG || REGNO (operands[0]) != 3)\n-    abort();\n-\n-  /* These can be anything that doesn't interfere with the epilogue.  */\n-  if (GET_CODE (operands[1]) != REG || REGNO (operands[1]) != 4)\n-    {\n-      rtx r = gen_rtx_REG (Pmode, 4);\n-      emit_move_insn (r, operands[1]);\n-      operands[1] = r;\n-    }\n-\n-  if (GET_CODE (operands[2]) != REG \n-\t|| REGNO (operands[2]) != COUNT_REGISTER_REGNUM)\n-    {\n-      rtx r = gen_rtx_REG (Pmode, COUNT_REGISTER_REGNUM);\n-      emit_move_insn (r, operands[2]);\n-      operands[2] = r;\n-    }\n-\n-#if TARGET_AIX\n-    rs6000_emit_eh_toc_restore (operands[1]);\n-#endif\n-\n-  emit_insn (gen_eh_reg_restore ());\n-\n-  if (Pmode == SImode)\n-    emit_insn (gen_addsi3 (stack_reg, stack_reg, operands[1]));\n-  else\n-    emit_insn (gen_adddi3 (stack_reg, stack_reg, operands[1]));\n-  \n-  if (Pmode == SImode)\n-    insn = emit_jump_insn (gen_return_eh_si (operands[2]));\n+  if (TARGET_TOC)\n+    rs6000_emit_eh_toc_restore (operands[0]);\n+  if (TARGET_32BIT)\n+    emit_insn (gen_eh_set_lr_si (operands[1]));\n   else\n-    insn = emit_jump_insn (gen_return_eh_di (operands[2]));\n-  emit_barrier_after (insn);\n-\n+    emit_insn (gen_eh_set_lr_di (operands[1]));\n+  emit_move_insn (EH_RETURN_STACKADJ_RTX, operands[0]);\n   DONE;\n }\")\n \n-; We can't expand this before we know which registers are restored,\n-; but we do want to expand it before flow2 because that way flow2 can\n-; remove the redundant loads of the link register.\n-(define_expand \"eh_reg_restore\"\n-  [(unspec_volatile [(const_int 0)] 9)]\n-  \"\"\n-  \"\")\n+; We can't expand this before we know where the link register is stored.\n+(define_insn \"eh_set_lr_si\"\n+  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"r\")] 9)\n+   (clobber (match_scratch:SI 1 \"=&r\"))]\n+  \"TARGET_32BIT\"\n+  \"#\")\n+\n+(define_insn \"eh_set_lr_di\"\n+  [(unspec_volatile [(match_operand:DI 0 \"register_operand\" \"r\")] 9)\n+   (clobber (match_scratch:DI 1 \"=&r\"))]\n+  \"TARGET_64BIT\"\n+  \"#\")\n \n (define_split\n-  [(unspec_volatile [(const_int 0)] 9)]\n-  \"reload_completed && TARGET_SCHED_PROLOG\"\n-  [(unspec_volatile [(const_int 0)] 9)]\n+  [(unspec_volatile [(match_operand 0 \"register_operand\" \"\")] 9)\n+   (clobber (match_scratch 1 \"\"))]\n+  \"reload_completed\"\n+  [(const_int 0)]\n   \"\n {\n-  rs6000_emit_epilogue (TRUE);\n-  DONE;\n-}\")\n-\n-(define_insn \"\"\n-  [(unspec_volatile [(const_int 0)] 9)]\n-  \"\"\n-  \"*\n-{\n-  if (TARGET_SCHED_PROLOG)\n-    return \\\"#\\\";\n-\n-  /* This is slightly ugly, but at least we don't have multiple\n-     copies of the epilogue-emitting code.  */\n-  start_sequence ();\n-\n-  /* A NOTE_INSN_DELETED is supposed to be at the start\n-     and end of the \\\"toplevel\\\" insn chain.  */\n-  emit_note (0, NOTE_INSN_DELETED);\n-  rs6000_emit_epilogue (TRUE);\n-  emit_note (0, NOTE_INSN_DELETED);\n-\n-  if (TARGET_DEBUG_STACK)\n-    debug_rtx_list (get_insns(), 100);\n-  final (get_insns(), asm_out_file, FALSE, FALSE);\n-  end_sequence ();\n-  return \\\"\\\";\n-}\")\n+  rs6000_stack_t *info = rs6000_stack_info ();\n \n+  if (info->lr_save_p)\n+    {\n+      rtx frame_rtx = stack_pointer_rtx;\n+      int sp_offset = 0;\n+      rtx tmp;\n \n-(define_insn \"return_eh_si\"\n-  [(return)\n-   (use (match_operand:SI 0 \"register_operand\" \"lc\"))\n-   (use (reg:SI 2))\n-   (use (reg:SI 3))]\n-  \"TARGET_32BIT\"\n-  \"b%T0\"\n-  [(set_attr \"type\" \"jmpreg\")])\n+      if (frame_pointer_needed\n+\t  || current_function_calls_alloca\n+\t  || info->total_size > 32767)\n+\t{\n+\t  emit_move_insn (operands[1], gen_rtx_MEM (Pmode, frame_rtx));\n+\t  frame_rtx = operands[1];\n+\t}\n+      else if (info->push_p)\n+\tsp_offset = info->total_size;\n \n-(define_insn \"return_eh_di\"\n-  [(return)\n-   (use (match_operand:DI 0 \"register_operand\" \"lc\"))\n-   (use (reg:DI 2))\n-   (use (reg:DI 3))]\n-  \"TARGET_64BIT\"\n-  \"b%T0\"\n-  [(set_attr \"type\" \"jmpreg\")])\n+      tmp = plus_constant (frame_rtx, info->lr_save_offset + sp_offset);\n+      tmp = gen_rtx_MEM (Pmode, tmp);\n+      emit_move_insn (tmp, operands[0]);\n+    }\n+  else\n+    emit_move_insn (gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM), operands[0]);\n+  DONE;\n+}\")"}]}