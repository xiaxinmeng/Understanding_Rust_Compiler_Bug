{"sha": "899583cb409be525bc9ab6ac11b3ce53f4791a30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk5NTgzY2I0MDliZTUyNWJjOWFiNmFjMTFiM2NlNTNmNDc5MWEzMA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-07-10T05:37:29Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-07-10T05:37:29Z"}, "message": "re PR libfortran/32702 (crash when printing big character variable)\n\n2007-07-09  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/32702\n\t* io/unix.c (unix_stream): Restore buffer pointer and small_buffer.\n\t(fd_alloc): If the number of bytes needed is greater than the default\n\tBUFFER_SIZE, allocate a new buffer large enough.  Free the old buffer if\n\tnecessary. (fd_sfree): Restore use of buffer pointer.\n\t(fd_close): Likewise. (fd_open): Likewise.\n\t(init_error_stream): Likewise.\n\nFrom-SVN: r126510", "tree": {"sha": "2a610d19110bd011851316a599cf55540a6a308d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a610d19110bd011851316a599cf55540a6a308d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/899583cb409be525bc9ab6ac11b3ce53f4791a30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/899583cb409be525bc9ab6ac11b3ce53f4791a30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/899583cb409be525bc9ab6ac11b3ce53f4791a30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/899583cb409be525bc9ab6ac11b3ce53f4791a30/comments", "author": null, "committer": null, "parents": [{"sha": "e7c8ff569c1183610a1ff25c8fb4756be078dc75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7c8ff569c1183610a1ff25c8fb4756be078dc75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7c8ff569c1183610a1ff25c8fb4756be078dc75"}], "stats": {"total": 47, "additions": 41, "deletions": 6}, "files": [{"sha": "25b5d4ca227247dde2434f70c7d1845108cd8d87", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/899583cb409be525bc9ab6ac11b3ce53f4791a30/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/899583cb409be525bc9ab6ac11b3ce53f4791a30/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=899583cb409be525bc9ab6ac11b3ce53f4791a30", "patch": "@@ -1,3 +1,13 @@\n+2007-07-09  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/32702\n+\t* io/unix.c (unix_stream): Restore buffer pointer and small_buffer.\n+\t(fd_alloc): If the number of bytes needed is greater than the default\n+\tBUFFER_SIZE, allocate a new buffer large enough.  Free the old buffer if\n+\tnecessary. (fd_sfree): Restore use of buffer pointer.\n+\t(fd_close): Likewise. (fd_open): Likewise.\n+\t(init_error_stream): Likewise.\n+\t\n 2007-07-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR libfortran/32336"}, {"sha": "bdfd245a5331aa64277e487f022dcaed0feb3042", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/899583cb409be525bc9ab6ac11b3ce53f4791a30/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/899583cb409be525bc9ab6ac11b3ce53f4791a30/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=899583cb409be525bc9ab6ac11b3ce53f4791a30", "patch": "@@ -97,6 +97,7 @@ typedef struct\n   gfc_offset dirty_offset;\t/* Start of modified bytes in buffer */\n   gfc_offset file_length;\t/* Length of the file, -1 if not seekable. */\n \n+  char *buffer;\n   int len;\t\t\t/* Physical length of the current buffer */\n   int active;\t\t\t/* Length of valid bytes in the buffer */\n \n@@ -107,7 +108,7 @@ typedef struct\n \n   int unbuffered;               /* =1 if the stream is not buffered */\n \n-  char buffer[BUFFER_SIZE];\n+  char small_buffer[BUFFER_SIZE];\n }\n unix_stream;\n \n@@ -437,17 +438,29 @@ static void\n fd_alloc (unix_stream * s, gfc_offset where,\n \t  int *len __attribute__ ((unused)))\n {\n-  int n;\n+  char *new_buffer;\n+  int n, read_len;\n+\n+  if (*len <= BUFFER_SIZE)\n+    {\n+      new_buffer = s->small_buffer;\n+      read_len = BUFFER_SIZE;\n+    }\n+  else\n+    {\n+      new_buffer = get_mem (*len);\n+      read_len = *len;\n+    }\n \n   /* Salvage bytes currently within the buffer.  This is important for\n    * devices that cannot seek. */\n \n-  if (s->buffer_offset <= where &&\n+  if (s->buffer != NULL && s->buffer_offset <= where &&\n       where <= s->buffer_offset + s->active)\n     {\n \n       n = s->active - (where - s->buffer_offset);\n-      memmove (s->buffer, s->buffer + (where - s->buffer_offset), n);\n+      memmove (new_buffer, s->buffer + (where - s->buffer_offset), n);\n \n       s->active = n;\n     }\n@@ -458,7 +471,13 @@ fd_alloc (unix_stream * s, gfc_offset where,\n \n   s->buffer_offset = where;\n \n-  s->len = BUFFER_SIZE;\n+  /* free the old buffer if necessary */\n+\n+  if (s->buffer != NULL && s->buffer != s->small_buffer)\n+    free_mem (s->buffer);\n+\n+  s->buffer = new_buffer;\n+  s->len = read_len;\n }\n \n \n@@ -590,7 +609,8 @@ static try\n fd_sfree (unix_stream * s)\n {\n   if (s->ndirty != 0 &&\n-      (options.all_unbuffered || s->unbuffered))\n+      (s->buffer != s->small_buffer || options.all_unbuffered ||\n+       s->unbuffered))\n     return fd_flush (s);\n \n   return SUCCESS;\n@@ -791,6 +811,9 @@ fd_close (unix_stream * s)\n   if (fd_flush (s) == FAILURE)\n     return FAILURE;\n \n+  if (s->buffer != NULL && s->buffer != s->small_buffer)\n+    free_mem (s->buffer);\n+\n   if (s->fd != STDOUT_FILENO && s->fd != STDERR_FILENO)\n     {\n       if (close (s->fd) < 0)\n@@ -819,6 +842,7 @@ fd_open (unix_stream * s)\n   s->st.write = (void *) fd_write;\n   s->st.set = (void *) fd_sset;\n \n+  s->buffer = NULL;\n }\n \n \n@@ -1377,6 +1401,7 @@ init_error_stream (unix_stream *error)\n   error->st.sfree = (void *) fd_sfree;\n \n   error->unbuffered = 1;\n+  error->buffer = error->small_buffer;\n \n   return (stream *) error;\n }"}]}