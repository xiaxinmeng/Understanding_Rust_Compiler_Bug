{"sha": "c00d5b12b08040fe0d8ee5168b612bf125e21566", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAwZDViMTJiMDgwNDBmZTBkOGVlNTE2OGI2MTJiZjEyNWUyMTU2Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-12-20T10:30:27Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-12-20T10:30:27Z"}, "message": "decl.c (gnat_to_gnu_entity): During layout in type_annotate_only mode...\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Type>: During\n\tlayout in type_annotate_only mode, skip discriminants of derived\n\ttagged types renaming those of the parent type.\n\tIn type_annotate_only mode, if the type is tagged, do not override a\n\tsize clause but take into account the alignment of the tag.\n\t(annotate_rep): In type_annotate_only mode, deal with  discriminants\n\tof derived tagged types renaming those of the parent type.\n\nFrom-SVN: r231860", "tree": {"sha": "3d14385013f62adc777b2477fd1703d21cb760ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d14385013f62adc777b2477fd1703d21cb760ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c00d5b12b08040fe0d8ee5168b612bf125e21566", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c00d5b12b08040fe0d8ee5168b612bf125e21566", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c00d5b12b08040fe0d8ee5168b612bf125e21566", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c00d5b12b08040fe0d8ee5168b612bf125e21566/comments", "author": null, "committer": null, "parents": [{"sha": "80746f5d88a60d13bc63f2f76a9dc547261b9601", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80746f5d88a60d13bc63f2f76a9dc547261b9601", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80746f5d88a60d13bc63f2f76a9dc547261b9601"}], "stats": {"total": 64, "additions": 53, "deletions": 11}, "files": [{"sha": "1a97c932ce583de8e529f1a60ef0205420cee0d7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00d5b12b08040fe0d8ee5168b612bf125e21566/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00d5b12b08040fe0d8ee5168b612bf125e21566/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c00d5b12b08040fe0d8ee5168b612bf125e21566", "patch": "@@ -1,3 +1,13 @@\n+2015-12-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Type>: During\n+\tlayout in type_annotate_only mode, skip discriminants of derived\n+\ttagged types renaming those of the parent type.\n+\tIn type_annotate_only mode, if the type is tagged, do not override a\n+\tsize clause but take into account the alignment of the tag.\n+\t(annotate_rep): In type_annotate_only mode, deal with  discriminants\n+\tof derived tagged types renaming those of the parent type.\n+\n 2015-12-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils.c (maybe_pad_type): In type_annotate_only mode,"}, {"sha": "0b1cd6f18bf7129cc1f2384a72b6bdddf227723f", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00d5b12b08040fe0d8ee5168b612bf125e21566/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00d5b12b08040fe0d8ee5168b612bf125e21566/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=c00d5b12b08040fe0d8ee5168b612bf125e21566", "patch": "@@ -3181,6 +3181,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  && Present (Corresponding_Discriminant (gnat_field)))\n \t\tcontinue;\n \n+\t      /* However, if we are just annotating types, the Parent_Subtype\n+\t\t doesn't exist so we need skip the discriminant altogether.  */\n+\t      if (type_annotate_only\n+\t\t  && Is_Tagged_Type (gnat_entity)\n+\t\t  && Is_Derived_Type (gnat_entity)\n+\t\t  && Present (Corresponding_Discriminant (gnat_field)))\n+\t\tcontinue;\n+\n \t      gnu_field\n \t\t= gnat_to_gnu_field (gnat_field, gnu_type, packed, definition,\n \t\t\t\t     debug_info_p);\n@@ -5321,15 +5329,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t  /* If we are just annotating types and the type is tagged, the tag\n \t     and the parent components are not generated by the front-end so\n-\t     sizes must be adjusted if there is no representation clause.  */\n+\t     alignment and sizes must be adjusted if there is no rep clause.  */\n \t  if (type_annotate_only\n \t      && Is_Tagged_Type (gnat_entity)\n+\t      && Unknown_RM_Size (gnat_entity)\n \t      && !VOID_TYPE_P (gnu_type)\n \t      && (!TYPE_FIELDS (gnu_type)\n \t\t  || integer_zerop (bit_position (TYPE_FIELDS (gnu_type)))))\n \t    {\n-\t      tree pointer_size = bitsize_int (POINTER_SIZE), offset;\n-\t      Uint uint_size;\n+\t      tree offset;\n \n \t      if (Is_Derived_Type (gnat_entity))\n \t\t{\n@@ -5338,18 +5346,35 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  Set_Alignment (gnat_entity, Alignment (gnat_parent));\n \t\t}\n \t      else\n-\t\toffset = pointer_size;\n+\t\t{\n+\t\t  unsigned int align\n+\t\t    = MAX (TYPE_ALIGN (gnu_type), POINTER_SIZE) / BITS_PER_UNIT;\n+\t\t  offset = bitsize_int (POINTER_SIZE);\n+\t\t  Set_Alignment (gnat_entity, UI_From_Int (align));\n+\t\t}\n \n \t      if (TYPE_FIELDS (gnu_type))\n \t\toffset\n \t\t  = round_up (offset, DECL_ALIGN (TYPE_FIELDS (gnu_type)));\n \n \t      gnu_size = size_binop (PLUS_EXPR, gnu_size, offset);\n \t      gnu_size = round_up (gnu_size, POINTER_SIZE);\n-\t      uint_size = annotate_value (gnu_size);\n-\t      Set_Esize (gnat_entity, uint_size);\n+\t      Uint uint_size = annotate_value (gnu_size);\n \t      Set_RM_Size (gnat_entity, uint_size);\n+\t      Set_Esize (gnat_entity, uint_size);\n+\t    }\n+\n+\t  /* If there is a rep clause, only adjust alignment and Esize.  */\n+\t  else if (type_annotate_only && Is_Tagged_Type (gnat_entity))\n+\t    {\n+\t      unsigned int align\n+\t\t= MAX (TYPE_ALIGN (gnu_type), POINTER_SIZE) / BITS_PER_UNIT;\n+\t      Set_Alignment (gnat_entity, UI_From_Int (align));\n+\t      gnu_size = round_up (gnu_size, POINTER_SIZE);\n+\t      Set_Esize (gnat_entity, annotate_value (gnu_size));\n \t    }\n+\n+\t  /* Otherwise no adjustment is needed.  */\n \t  else\n \t    Set_Esize (gnat_entity, annotate_value (gnu_size));\n \t}\n@@ -7933,12 +7958,19 @@ annotate_rep (Entity_Id gnat_entity, tree gnu_type)\n \t  {\n \t    /* If there is no entry, this is an inherited component whose\n \t       position is the same as in the parent type.  */\n-\t    Set_Component_Bit_Offset\n-\t      (gnat_field,\n-\t       Component_Bit_Offset (Original_Record_Component (gnat_field)));\n+\t    Entity_Id gnat_orig_field = Original_Record_Component (gnat_field);\n \n-\t    Set_Esize (gnat_field,\n-\t\t       Esize (Original_Record_Component (gnat_field)));\n+\t    /* If we are just annotating types, discriminants renaming those of\n+\t       the parent have no entry so deal with them specifically.  */\n+\t    if (type_annotate_only\n+\t\t&& gnat_orig_field == gnat_field\n+\t\t&& Ekind (gnat_field) == E_Discriminant)\n+\t      gnat_orig_field = Corresponding_Discriminant (gnat_field);\n+\n+\t    Set_Component_Bit_Offset (gnat_field,\n+\t\t\t\t      Component_Bit_Offset (gnat_orig_field));\n+\n+\t    Set_Esize (gnat_field, Esize (gnat_orig_field));\n \t  }\n       }\n }"}]}