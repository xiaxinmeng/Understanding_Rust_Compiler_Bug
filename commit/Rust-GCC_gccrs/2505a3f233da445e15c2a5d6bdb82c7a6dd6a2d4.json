{"sha": "2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjUwNWEzZjIzM2RhNDQ1ZTE1YzJhNWQ2YmRiODJjN2E2ZGQ2YTJkNA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2006-11-27T12:41:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2006-11-27T12:41:51Z"}, "message": "target.h (struct gcc_target): Add builtin_vectorized_function target hook.\n\n2006-11-27  Richard Guenther  <rguenther@suse.de>\n\tZdenek Dvorak <dvorakz@suse.cz>\n\n\t* target.h (struct gcc_target): Add builtin_vectorized_function\n\ttarget hook.\n\t* target-def.h (TARGET_VECTORIZE): Likewise.\n\t* doc/tm.texi (TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION):\n\tDocument new target hook.\n\t* targhooks.h (default_builtin_vectorized_function): Declare.\n\t* targhooks.c (default_builtin_vectorized_function): Define.\n\t* tree-vectorizer.h (stmt_vec_info_type): Add call_vec_info_type.\n\t(vectorizable_call): Declare.\n\t* tree-vect-analyze.c (vect_analyze_operations): Call\n\tvectorizable_call.\n\t* tree-vect-transform.c (vectorizable_function): New static function.\n\t(build_vectorized_function_call): Likewise.\n\t(vectorizable_call): New function.\n\t(vect_transform_stmt): Handle vectorizable calls.\n\nCo-Authored-By: Zdenek Dvorak <dvorakz@suse.cz>\n\nFrom-SVN: r119249", "tree": {"sha": "9ec10231876edbe86522e49ba924fa140768debf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ec10231876edbe86522e49ba924fa140768debf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9fca6f972d71fb1b9bacdc99478b21faeb0db384", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fca6f972d71fb1b9bacdc99478b21faeb0db384", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fca6f972d71fb1b9bacdc99478b21faeb0db384"}], "stats": {"total": 204, "additions": 201, "deletions": 3}, "files": [{"sha": "4d4a97d14287c5073b85f4fa4bcd69809df6c134", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4", "patch": "@@ -1,3 +1,22 @@\n+2006-11-27  Richard Guenther  <rguenther@suse.de>\n+\tZdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* target.h (struct gcc_target): Add builtin_vectorized_function\n+\ttarget hook.\n+\t* target-def.h (TARGET_VECTORIZE): Likewise.\n+\t* doc/tm.texi (TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION):\n+\tDocument new target hook.\n+\t* targhooks.h (default_builtin_vectorized_function): Declare.\n+\t* targhooks.c (default_builtin_vectorized_function): Define.\n+\t* tree-vectorizer.h (stmt_vec_info_type): Add call_vec_info_type.\n+\t(vectorizable_call): Declare.\n+\t* tree-vect-analyze.c (vect_analyze_operations): Call\n+\tvectorizable_call.\n+\t* tree-vect-transform.c (vectorizable_function): New static function.\n+\t(build_vectorized_function_call): Likewise.\n+\t(vectorizable_call): New function.\n+\t(vect_transform_stmt): Handle vectorizable calls.\n+\n 2006-11-27  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/25620"}, {"sha": "70e30ae3ac302b6515bcc935a6fe13cb16c0d04f", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4", "patch": "@@ -5306,6 +5306,13 @@ preserved (e.g. used only by a reduction computation). Otherwise, the\n @code{widen_mult_hi/lo} idioms will be used.\n @end deftypefn\n \n+@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION (enum built_in_function @var{code}, tree @var{vec_type})\n+This hook should return the decl of a function that implements the vectorized\n+variant of the builtin function with builtin function code @var{code} or\n+@code{NULL_TREE} if such a function is not available.  The return type of\n+the vectorized function shall be of vector type @var{vec_type}.\n+@end deftypefn\n+\n @node Anchored Addresses\n @section Anchored Addresses\n @cindex anchored addresses"}, {"sha": "580c3276900b66a9287388e7c3d46bcdd7f19cab", "filename": "gcc/target-def.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4", "patch": "@@ -332,13 +332,17 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n    TARGET_SCHED_SET_SCHED_FLAGS}\n \n #define TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD 0\n+#define TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION default_builtin_vectorized_function\n #define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN 0\n #define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD 0\n \n #define TARGET_VECTORIZE                                                \\\n-  {TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD,\t\t\t\t\\\n-   TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN,                             \\\n-   TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD}\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD,\t\t\t\t\\\n+    TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION,\t\t\t\\\n+    TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN,                            \\\n+    TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD\t\t\t\t\\\n+  }\n \n #define TARGET_DEFAULT_TARGET_FLAGS 0\n "}, {"sha": "1147142f2cfa7c186fef6ab5d061bfe9be137b01", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4", "patch": "@@ -370,6 +370,10 @@ struct gcc_target\n        function.  */\n     tree (* builtin_mask_for_load) (void);\n \n+    /* Returns a code for builtin that realizes vectorized version of\n+       function, or NULL_TREE if not available.  */\n+    tree (* builtin_vectorized_function) (unsigned, tree);\n+\n     /* Target builtin that implements vector widening multiplication.\n        builtin_mul_widen_eve computes the element-by-element products \n        for the even elements, and builtin_mul_widen_odd computes the"}, {"sha": "e7bdf0b3cbc7e7c2562f8521bbc83a7f2f5ac4c2", "filename": "gcc/targhooks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4", "patch": "@@ -319,6 +319,15 @@ default_invalid_within_doloop (rtx insn)\n   return NULL;\n }\n \n+/* Mapping of builtin functions to vectorized variants.  */\n+\n+tree\n+default_builtin_vectorized_function (enum built_in_function fn ATTRIBUTE_UNUSED,\n+\t\t\t\t     tree type ATTRIBUTE_UNUSED)\n+{\n+  return NULL_TREE;\n+}\n+\n bool\n hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false (\n \tCUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,"}, {"sha": "5f63dd77f6f8526cef5fbd547a8260e6e176224e", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4", "patch": "@@ -57,6 +57,8 @@ extern const char * default_invalid_within_doloop (rtx);\n \n extern bool default_narrow_bitfield (void);\n \n+extern tree default_builtin_vectorized_function (enum built_in_function, tree);\n+\n /* These are here, and not in hooks.[ch], because not all users of\n    hooks.h include tm.h, and thus we don't have CUMULATIVE_ARGS.  */\n "}, {"sha": "a0d6e08708215740bdacfa5168cb06599b443f13", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4", "patch": "@@ -301,6 +301,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t\t    || vectorizable_operation (stmt, NULL, NULL)\n \t\t    || vectorizable_assignment (stmt, NULL, NULL)\n \t\t    || vectorizable_load (stmt, NULL, NULL)\n+\t\t    || vectorizable_call (stmt, NULL, NULL)\n \t\t    || vectorizable_store (stmt, NULL, NULL)\n \t\t    || vectorizable_condition (stmt, NULL, NULL));\n "}, {"sha": "84ae19facfd96f791423853643c85838347f725a", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4", "patch": "@@ -1566,6 +1566,152 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   return true;\n }\n \n+/* Checks if CALL can be vectorized in type VECTYPE.  Returns\n+   true if the target has a vectorized version of the function,\n+   or false if the function cannot be vectorized.  */\n+\n+static bool\n+vectorizable_function (tree call, tree vectype)\n+{\n+  tree fndecl = get_callee_fndecl (call);\n+\n+  /* We only handle functions that do not read or clobber memory -- i.e.\n+     const or novops ones.  */\n+  if (!(call_expr_flags (call) & (ECF_CONST | ECF_NOVOPS)))\n+    return false;\n+\n+  if (!fndecl\n+      || TREE_CODE (fndecl) != FUNCTION_DECL\n+      || !DECL_BUILT_IN (fndecl))\n+    return false;\n+\n+  if (targetm.vectorize.builtin_vectorized_function (DECL_FUNCTION_CODE (fndecl), vectype))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Returns an expression that performs a call to vectorized version\n+   of FNDECL in type VECTYPE, with the arguments given by ARGS.\n+   If extra statements need to be generated, they are inserted\n+   before BSI.  */\n+\n+static tree\n+build_vectorized_function_call (tree fndecl,\n+\t\t\t\ttree vectype, tree args)\n+{\n+  tree vfndecl;\n+  enum built_in_function code = DECL_FUNCTION_CODE (fndecl);\n+\n+  /* The target specific builtin should be available.  */\n+  vfndecl = targetm.vectorize.builtin_vectorized_function (code, vectype);\n+  gcc_assert (vfndecl != NULL_TREE);\n+\n+  return build_function_call_expr (vfndecl, args);\n+}\n+\n+/* Function vectorizable_call.\n+\n+   Check if STMT performs a function call that can be vectorized. \n+   If VEC_STMT is also passed, vectorize the STMT: create a vectorized \n+   stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n+   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+\n+bool\n+vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n+{\n+  tree vec_dest;\n+  tree scalar_dest;\n+  tree operation;\n+  tree op, args, type;\n+  tree vec_oprnd, vargs, *pvargs_end;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  tree fndecl, rhs, new_temp, def, def_stmt;\n+  enum vect_def_type dt;\n+\n+  /* Is STMT a vectorizable call?   */\n+  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+    return false;\n+\n+  if (TREE_CODE (TREE_OPERAND (stmt, 0)) != SSA_NAME)\n+    return false;\n+\n+  operation = TREE_OPERAND (stmt, 1);\n+  if (TREE_CODE (operation) != CALL_EXPR)\n+    return false;\n+   \n+  /* For now, we only vectorize functions if a target specific builtin\n+     is available.  TODO -- in some cases, it might be profitable to\n+     insert the calls for pieces of the vector, in order to be able\n+     to vectorize other operations in the loop.  */\n+  if (!vectorizable_function (operation, vectype))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"function is not vectorizable.\");\n+\n+      return false;\n+    }\n+  gcc_assert (!stmt_references_memory_p (stmt));\n+\n+  for (args = TREE_OPERAND (operation, 1); args; args = TREE_CHAIN (args))\n+    {\n+      op = TREE_VALUE (args);\n+\n+      if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"use not simple.\");\n+\t  return false;\n+\t}\n+    }\n+\n+  if (!vec_stmt) /* transformation not required.  */\n+    {\n+      STMT_VINFO_TYPE (stmt_info) = call_vec_info_type;\n+      return true;\n+    }\n+\n+  /** Transform.  **/\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"transform operation.\");\n+\n+  /* Handle def.  */\n+  scalar_dest = TREE_OPERAND (stmt, 0);\n+  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+\n+  /* Handle uses.  */\n+  vargs = NULL_TREE;\n+  pvargs_end = &vargs;\n+  for (args = TREE_OPERAND (operation, 1); args; args = TREE_CHAIN (args))\n+    {\n+      op = TREE_VALUE (args);\n+      vec_oprnd = vect_get_vec_def_for_operand (op, stmt, NULL);\n+\t  \n+      *pvargs_end = tree_cons (NULL_TREE, vec_oprnd, NULL_TREE);\n+      pvargs_end = &TREE_CHAIN (*pvargs_end);\n+    }\n+\n+  fndecl = get_callee_fndecl (operation);\n+  rhs = build_vectorized_function_call (fndecl, vectype, vargs);\n+  *vec_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, rhs);\n+  new_temp = make_ssa_name (vec_dest, *vec_stmt);\n+  TREE_OPERAND (*vec_stmt, 0) = new_temp;\n+\n+  vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n+\n+  /* The call in STMT might prevent it from being removed in dce.  We however\n+     cannot remove it here, due to the way the ssa name it defines is mapped\n+     to the new definition.  So just replace rhs of the statement with something\n+     harmless.  */\n+  type = TREE_TYPE (scalar_dest);\n+  TREE_OPERAND (stmt, 1) = fold_convert (type, integer_zero_node);\n+\n+  return true;\n+}\n+\n \n /* Function vectorizable_assignment.\n \n@@ -3721,6 +3867,10 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi, bool *strided_store)\n \tgcc_assert (done);\n \tbreak;\n \n+      case call_vec_info_type:\n+\tdone = vectorizable_call (stmt, bsi, &vec_stmt);\n+\tbreak;\n+\n       default:\n \tif (vect_print_dump_info (REPORT_DETAILS))\n \t  fprintf (vect_dump, \"stmt not supported.\");"}, {"sha": "6af68a319f87635d0fc6dafa8dce3f27c628127b", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=2505a3f233da445e15c2a5d6bdb82c7a6dd6a2d4", "patch": "@@ -163,6 +163,7 @@ enum stmt_vec_info_type {\n   load_vec_info_type,\n   store_vec_info_type,\n   op_vec_info_type,\n+  call_vec_info_type,\n   assignment_vec_info_type,\n   condition_vec_info_type,\n   reduc_vec_info_type,\n@@ -397,6 +398,7 @@ extern bool vectorizable_operation (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_type_promotion (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_type_demotion (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_assignment (tree, block_stmt_iterator *, tree *);\n+extern bool vectorizable_call (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_condition (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_live_operation (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_reduction (tree, block_stmt_iterator *, tree *);"}]}