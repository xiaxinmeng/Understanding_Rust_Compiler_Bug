{"sha": "42c633132521c8c2874cef54852090d587ce66c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJjNjMzMTMyNTIxYzhjMjg3NGNlZjU0ODUyMDkwZDU4N2NlNjZjMw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-03-20T18:28:05Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-03-27T14:02:39Z"}, "message": "analyzer: add new supergraph visualization\n\nThis patch extends -fdump-analyzer-supergraph so that rather than just\ndumping a DUMP_BASE_NAME.supergraph.dot at the start of analysis, it\nalso dumps a DUMP_BASE_NAME.supergraph-eg.dot at the end.\n\nThe new dump file contains a concise dump of the exploded_graph,\norganized with respect to the supergraph and its statements.  The\nexploded nodes are colorized to show sm-state, but no other state\nis shown.  Per exploded_node saved_diagnostics are also shown,\nalong with feasibility of the paths to reach them.\n\nI've been finding this a useful way of tracking down issues in\nexploded_graphs that are sufficiently large that the output of\n-fdump-analyzer-exploded-graph becomes unwieldy.\n\nThe patch extends feasiblity-testing so that if the exploded_path\nfor a saved_diagnostic is found to be infeasible, the reason is\nsaved and written into the saved_diagnostic, so it can be shown in the\ndump.  I've found this very useful when tracking down feasibility\nissues.\n\nI'm keeping the initial dump file as it's useful when tracking down\nICEs within the analyzer (which would stop the second dump file being\nwritten).\n\ngcc/analyzer/ChangeLog:\n\t* analyzer.h (class feasibility_problem): New forward decl.\n\t* diagnostic-manager.cc (saved_diagnostic::saved_diagnostic):\n\tInitialize new fields m_status, m_epath_length, and m_problem.\n\t(saved_diagnostic::~saved_diagnostic): Delete m_problem.\n\t(dedupe_candidate::dedupe_candidate): Convert \"sd\" param from a\n\tconst ref to a mutable ptr.\n\t(dedupe_winners::add): Convert \"sd\" param from a const ref to a\n\tmutable ptr.  Record the length of the exploded_path.  Record the\n\tfeasibility/infeasibility of sd into sd, capturing a\n\tfeasibility_problem when feasible_p fails, and storing it in sd.\n\t(diagnostic_manager::emit_saved_diagnostics): Update for pass by\n\tptr rather than by const ref.\n\t* diagnostic-manager.h (class saved_diagnostic): Add new enum\n\tstatus.  Add fields m_status, m_epath_length and m_problem.\n\t(saved_diagnostic::set_feasible): New member function.\n\t(saved_diagnostic::set_infeasible): New member function.\n\t(saved_diagnostic::get_feasibility_problem): New accessor.\n\t(saved_diagnostic::get_status): New accessor.\n\t(saved_diagnostic::set_epath_length): New member function.\n\t(saved_diagnostic::get_epath_length): New accessor.\n\t* engine.cc: Include \"gimple-pretty-print.h\".\n\t(exploded_path::feasible_p): Add OUT param and, if non-NULL, write\n\ta new feasibility_problem to it on failure.\n\t(viz_callgraph_node::dump_dot): Convert begin_tr calls to\n\tbegin_trtd.  Convert end_tr calls to end_tdtr.\n\t(class exploded_graph_annotator): New subclass of dot_annotator.\n\t(impl_run_checkers): Add a second -fdump-analyzer-supergraph dump\n\tafter the analysis runs, using exploded_graph_annotator. dumping\n\tto DUMP_BASE_NAME.supergraph-eg.dot.\n\t* exploded-graph.h (exploded_node::get_dot_fillcolor): Make\n\tpublic.\n\t(exploded_path::feasible_p): Add OUT param.\n\t(class feasibility_problem): New class.\n\t* state-purge.cc (state_purge_annotator::add_node_annotations):\n\tReturn a bool, add a \"within_table\" param.\n\t(print_vec_of_names): Convert begin_tr calls to begin_trtd.\n\tConvert end_tr calls to end_tdtr.\n\t(state_purge_annotator::add_stmt_annotations): Add \"within_row\"\n\tparam.\n\t* state-purge.h ((state_purge_annotator::add_node_annotations):\n\tReturn a bool, add a \"within_table\" param.\n\t(state_purge_annotator::add_stmt_annotations): Add \"within_row\"\n\tparam.\n\t* supergraph.cc (supernode::dump_dot): Call add_node_annotations\n\ttwice: as before, passing false for \"within_table\", then again\n\twith true when within the TABLE element.  Convert some begin_tr\n\tcalls to begin_trtd, and some end_tr calls to end_tdtr.\n\tRepeat each add_stmt_annotations call, distinguishing between\n\tcalls that add TRs and those that add TDs to an existing TR.\n\tAdd a call to add_after_node_annotations.\n\t* supergraph.h (dot_annotator::add_node_annotations): Add a\n\t\"within_table\" param.\n\t(dot_annotator::add_stmt_annotations): Add a \"within_row\" param.\n\t(dot_annotator::add_after_node_annotations): New vfunc.\n\ngcc/ChangeLog:\n\t* doc/invoke.texi (-fdump-analyzer-supergraph): Document that this\n\tnow emits two .dot files.\n\t* graphviz.cc (graphviz_out::begin_tr): Only emit a TR, not a TD.\n\t(graphviz_out::end_tr): Only close a TR, not a TD.\n\t(graphviz_out::begin_td): New.\n\t(graphviz_out::end_td): New.\n\t(graphviz_out::begin_trtd): New, replacing the old implementation\n\tof graphviz_out::begin_tr.\n\t(graphviz_out::end_tdtr): New, replacing the old implementation\n\tof graphviz_out::end_tr.\n\t* graphviz.h (graphviz_out::begin_td): New decl.\n\t(graphviz_out::end_td): New decl.\n\t(graphviz_out::begin_trtd): New decl.\n\t(graphviz_out::end_tdtr): New decl.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/dot-output.c: Check that\n\tdot-output.c.supergraph-eg.dot is valid.", "tree": {"sha": "7e322b4912ed569f3101aca2038719e57baa94f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e322b4912ed569f3101aca2038719e57baa94f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42c633132521c8c2874cef54852090d587ce66c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42c633132521c8c2874cef54852090d587ce66c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42c633132521c8c2874cef54852090d587ce66c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42c633132521c8c2874cef54852090d587ce66c3/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f02357571a858f7ff5ca7734e5344d989a7fd0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f02357571a858f7ff5ca7734e5344d989a7fd0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f02357571a858f7ff5ca7734e5344d989a7fd0c"}], "stats": {"total": 590, "additions": 537, "deletions": 53}, "files": [{"sha": "c4386d832dd8e6a891b1198611222698f6f79f14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c633132521c8c2874cef54852090d587ce66c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c633132521c8c2874cef54852090d587ce66c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=42c633132521c8c2874cef54852090d587ce66c3", "patch": "@@ -1,3 +1,20 @@\n+2020-03-27  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* doc/invoke.texi (-fdump-analyzer-supergraph): Document that this\n+\tnow emits two .dot files.\n+\t* graphviz.cc (graphviz_out::begin_tr): Only emit a TR, not a TD.\n+\t(graphviz_out::end_tr): Only close a TR, not a TD.\n+\t(graphviz_out::begin_td): New.\n+\t(graphviz_out::end_td): New.\n+\t(graphviz_out::begin_trtd): New, replacing the old implementation\n+\tof graphviz_out::begin_tr.\n+\t(graphviz_out::end_tdtr): New, replacing the old implementation\n+\tof graphviz_out::end_tr.\n+\t* graphviz.h (graphviz_out::begin_td): New decl.\n+\t(graphviz_out::end_td): New decl.\n+\t(graphviz_out::begin_trtd): New decl.\n+\t(graphviz_out::end_tdtr): New decl.\n+\n 2020-03-27  Richard Biener  <rguenther@suse.de>\n \n \tPR debug/94273"}, {"sha": "ddb02afe192668eb137c0f7d98810987a3e06445", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=42c633132521c8c2874cef54852090d587ce66c3", "patch": "@@ -1,3 +1,60 @@\n+2020-03-27  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* analyzer.h (class feasibility_problem): New forward decl.\n+\t* diagnostic-manager.cc (saved_diagnostic::saved_diagnostic):\n+\tInitialize new fields m_status, m_epath_length, and m_problem.\n+\t(saved_diagnostic::~saved_diagnostic): Delete m_problem.\n+\t(dedupe_candidate::dedupe_candidate): Convert \"sd\" param from a\n+\tconst ref to a mutable ptr.\n+\t(dedupe_winners::add): Convert \"sd\" param from a const ref to a\n+\tmutable ptr.  Record the length of the exploded_path.  Record the\n+\tfeasibility/infeasibility of sd into sd, capturing a\n+\tfeasibility_problem when feasible_p fails, and storing it in sd.\n+\t(diagnostic_manager::emit_saved_diagnostics): Update for pass by\n+\tptr rather than by const ref.\n+\t* diagnostic-manager.h (class saved_diagnostic): Add new enum\n+\tstatus.  Add fields m_status, m_epath_length and m_problem.\n+\t(saved_diagnostic::set_feasible): New member function.\n+\t(saved_diagnostic::set_infeasible): New member function.\n+\t(saved_diagnostic::get_feasibility_problem): New accessor.\n+\t(saved_diagnostic::get_status): New accessor.\n+\t(saved_diagnostic::set_epath_length): New member function.\n+\t(saved_diagnostic::get_epath_length): New accessor.\n+\t* engine.cc: Include \"gimple-pretty-print.h\".\n+\t(exploded_path::feasible_p): Add OUT param and, if non-NULL, write\n+\ta new feasibility_problem to it on failure.\n+\t(viz_callgraph_node::dump_dot): Convert begin_tr calls to\n+\tbegin_trtd.  Convert end_tr calls to end_tdtr.\n+\t(class exploded_graph_annotator): New subclass of dot_annotator.\n+\t(impl_run_checkers): Add a second -fdump-analyzer-supergraph dump\n+\tafter the analysis runs, using exploded_graph_annotator. dumping\n+\tto DUMP_BASE_NAME.supergraph-eg.dot.\n+\t* exploded-graph.h (exploded_node::get_dot_fillcolor): Make\n+\tpublic.\n+\t(exploded_path::feasible_p): Add OUT param.\n+\t(class feasibility_problem): New class.\n+\t* state-purge.cc (state_purge_annotator::add_node_annotations):\n+\tReturn a bool, add a \"within_table\" param.\n+\t(print_vec_of_names): Convert begin_tr calls to begin_trtd.\n+\tConvert end_tr calls to end_tdtr.\n+\t(state_purge_annotator::add_stmt_annotations): Add \"within_row\"\n+\tparam.\n+\t* state-purge.h ((state_purge_annotator::add_node_annotations):\n+\tReturn a bool, add a \"within_table\" param.\n+\t(state_purge_annotator::add_stmt_annotations): Add \"within_row\"\n+\tparam.\n+\t* supergraph.cc (supernode::dump_dot): Call add_node_annotations\n+\ttwice: as before, passing false for \"within_table\", then again\n+\twith true when within the TABLE element.  Convert some begin_tr\n+\tcalls to begin_trtd, and some end_tr calls to end_tdtr.\n+\tRepeat each add_stmt_annotations call, distinguishing between\n+\tcalls that add TRs and those that add TDs to an existing TR.\n+\tAdd a call to add_after_node_annotations.\n+\t* supergraph.h (dot_annotator::add_node_annotations): Add a\n+\t\"within_table\" param.\n+\t(dot_annotator::add_stmt_annotations): Add a \"within_row\" param.\n+\t(dot_annotator::add_after_node_annotations): New vfunc.\n+\n 2020-03-27  David Malcolm  <dmalcolm@redhat.com>\n \n \t* diagnostic-manager.cc (dedupe_winners::add): Show the"}, {"sha": "a7401128517f7c0cc659f751b7d945bb39b81de1", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=42c633132521c8c2874cef54852090d587ce66c3", "patch": "@@ -64,6 +64,7 @@ class program_state;\n class exploded_graph;\n class exploded_node;\n class exploded_edge;\n+class feasibility_problem;\n class exploded_cluster;\n class exploded_path;\n class analysis_plan;"}, {"sha": "4b884c7a45256a5cba7d25826a09950daff80a53", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=42c633132521c8c2874cef54852090d587ce66c3", "patch": "@@ -77,7 +77,8 @@ saved_diagnostic::saved_diagnostic (const state_machine *sm,\n     outlive that.  */\n   m_stmt_finder (stmt_finder ? stmt_finder->clone () : NULL),\n   m_var (var), m_state (state),\n-  m_d (d), m_trailing_eedge (NULL)\n+  m_d (d), m_trailing_eedge (NULL),\n+  m_status (STATUS_NEW), m_epath_length (0), m_problem (NULL)\n {\n   gcc_assert (m_stmt || m_stmt_finder);\n \n@@ -92,6 +93,7 @@ saved_diagnostic::~saved_diagnostic ()\n {\n   delete m_stmt_finder;\n   delete m_d;\n+  delete m_problem;\n }\n \n bool\n@@ -257,8 +259,8 @@ class dedupe_candidate\n public:\n   // has the exploded_path\n   dedupe_candidate (const shortest_exploded_paths &sp,\n-\t\t    const saved_diagnostic &sd)\n-  : m_epath (sp.get_shortest_path (sd.m_enode)),\n+\t\t    saved_diagnostic *sd)\n+  : m_epath (sp.get_shortest_path (sd->m_enode)),\n     m_num_dupes (0)\n   {\n   }\n@@ -344,12 +346,14 @@ class dedupe_winners\n \n   void add (logger *logger,\n \t    const shortest_exploded_paths &sp,\n-\t    const saved_diagnostic &sd)\n+\t    saved_diagnostic *sd)\n   {\n     /* Build a dedupe_candidate for SD.\n        This uses SP to build an exploded_path.  */\n     dedupe_candidate *dc = new dedupe_candidate (sp, sd);\n \n+    sd->set_epath_length (dc->length ());\n+\n     /* Verify that the epath is feasible.\n        State-merging means that not every path in the epath corresponds\n        to a feasible one w.r.t. states.\n@@ -359,26 +363,30 @@ class dedupe_winners\n        feasible paths within the egraph.  */\n     if (logger)\n       logger->log (\"considering %qs at EN: %i, SN: %i\",\n-\t\t   sd.m_d->get_kind (), sd.m_enode->m_index,\n-\t\t   sd.m_snode->m_index);\n+\t\t   sd->m_d->get_kind (), sd->m_enode->m_index,\n+\t\t   sd->m_snode->m_index);\n \n-    if (!dc->get_path ().feasible_p (logger))\n+    feasibility_problem *p = NULL;\n+    if (!dc->get_path ().feasible_p (logger, &p))\n       {\n \tif (logger)\n \t  logger->log (\"rejecting %qs at EN: %i, SN: %i\"\n \t\t       \" due to infeasible path\",\n-\t\t       sd.m_d->get_kind (), sd.m_enode->m_index,\n-\t\t       sd.m_snode->m_index);\n+\t\t       sd->m_d->get_kind (), sd->m_enode->m_index,\n+\t\t       sd->m_snode->m_index);\n+\tsd->set_infeasible (p);\n \tdelete dc;\n \treturn;\n       }\n     else\n       if (logger)\n \tlogger->log (\"accepting %qs at EN: %i, SN: %i with feasible path\",\n-\t\t     sd.m_d->get_kind (), sd.m_enode->m_index,\n-\t\t     sd.m_snode->m_index);\n+\t\t     sd->m_d->get_kind (), sd->m_enode->m_index,\n+\t\t     sd->m_snode->m_index);\n+\n+    sd->set_feasible ();\n \n-    dedupe_key *key = new dedupe_key (sd, dc->get_path ());\n+    dedupe_key *key = new dedupe_key (*sd, dc->get_path ());\n     if (dedupe_candidate **slot = m_map.get (key))\n       {\n \tif (logger)\n@@ -495,7 +503,7 @@ diagnostic_manager::emit_saved_diagnostics (const exploded_graph &eg)\n   int i;\n   saved_diagnostic *sd;\n   FOR_EACH_VEC_ELT (m_saved_diagnostics, i, sd)\n-    best_candidates.add (get_logger (), sp, *sd);\n+    best_candidates.add (get_logger (), sp, sd);\n \n   /* For each dedupe-key, call emit_saved_diagnostic on the \"best\"\n      saved_diagnostic.  */"}, {"sha": "c6f3c0c4ad1e0d6b1fdba26578067b0bac4bf76a", "filename": "gcc/analyzer/diagnostic-manager.h", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.h?ref=42c633132521c8c2874cef54852090d587ce66c3", "patch": "@@ -28,6 +28,13 @@ namespace ana {\n class saved_diagnostic\n {\n public:\n+  enum status\n+  {\n+   STATUS_NEW,\n+   STATUS_INFEASIBLE_PATH,\n+   STATUS_FEASIBLE_PATH\n+  };\n+\n   saved_diagnostic (const state_machine *sm,\n \t\t    const exploded_node *enode,\n \t\t    const supernode *snode, const gimple *stmt,\n@@ -38,6 +45,27 @@ class saved_diagnostic\n \n   bool operator== (const saved_diagnostic &other) const;\n \n+  void set_feasible ()\n+  {\n+    gcc_assert (m_status == STATUS_NEW);\n+    m_status = STATUS_FEASIBLE_PATH;\n+  }\n+  void set_infeasible (feasibility_problem *p)\n+  {\n+    gcc_assert (m_status == STATUS_NEW);\n+    m_status = STATUS_INFEASIBLE_PATH;\n+    m_problem = p; // take ownership\n+  }\n+  const feasibility_problem *get_feasibility_problem () const\n+  {\n+    return m_problem;\n+  }\n+\n+  enum status get_status () const { return m_status; }\n+\n+  void set_epath_length (unsigned length) { m_epath_length = length; }\n+  unsigned get_epath_length () const { return m_epath_length; }\n+\n   //private:\n   const state_machine *m_sm;\n   const exploded_node *m_enode;\n@@ -51,6 +79,10 @@ class saved_diagnostic\n \n private:\n   DISABLE_COPY_AND_ASSIGN (saved_diagnostic);\n+\n+  enum status m_status;\n+  unsigned m_epath_length;\n+  feasibility_problem *m_problem;\n };\n \n class path_builder;"}, {"sha": "befd4836cb4eda04c4d575af9eca0229abda4358", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 256, "deletions": 14, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=42c633132521c8c2874cef54852090d587ce66c3", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"gimple.h\"\n #include \"gimple-iterator.h\"\n+#include \"gimple-pretty-print.h\"\n #include \"cgraph.h\"\n #include \"digraph.h\"\n #include \"analyzer/supergraph.h\"\n@@ -2842,10 +2843,12 @@ exploded_path::get_final_enode () const\n   return m_edges[m_edges.length () - 1]->m_dest;\n }\n \n-/* Check state along this path, returning true if it is feasible.  */\n+/* Check state along this path, returning true if it is feasible.\n+   If OUT is non-NULL, and the path is infeasible, write a new\n+   feasibility_problem to *OUT.  */\n \n bool\n-exploded_path::feasible_p (logger *logger) const\n+exploded_path::feasible_p (logger *logger, feasibility_problem **out) const\n {\n   LOG_SCOPE (logger);\n \n@@ -2898,6 +2901,8 @@ exploded_path::feasible_p (logger *logger) const\n \t\t  logger->log (\"rejecting due to region model\");\n \t\t  model.dump_to_pp (logger->get_printer (), false);\n \t\t}\n+\t      if (out)\n+\t\t*out = new feasibility_problem (i, model, *eedge, last_stmt);\n \t      return false;\n \t    }\n \t}\n@@ -3522,19 +3527,19 @@ class viz_callgraph_node : public dnode<viz_callgraph_traits>\n     pp_string (pp, \"<TABLE BORDER=\\\"0\\\">\");\n     pp_write_text_to_stream (pp);\n \n-    gv->begin_tr ();\n+    gv->begin_trtd ();\n     pp_printf (pp, \"VCG: %i: %s\", m_index, function_name (m_fun));\n-    gv->end_tr ();\n+    gv->end_tdtr ();\n     pp_newline (pp);\n \n-    gv->begin_tr ();\n+    gv->begin_trtd ();\n     pp_printf (pp, \"supernodes: %i\\n\", m_num_supernodes);\n-    gv->end_tr ();\n+    gv->end_tdtr ();\n     pp_newline (pp);\n \n-    gv->begin_tr ();\n+    gv->begin_trtd ();\n     pp_printf (pp, \"superedges: %i\\n\", m_num_superedges);\n-    gv->end_tr ();\n+    gv->end_tdtr ();\n     pp_newline (pp);\n \n     if (args.m_eg)\n@@ -3547,9 +3552,9 @@ class viz_callgraph_node : public dnode<viz_callgraph_traits>\n \t    if (enode->get_point ().get_function () == m_fun)\n \t      num_enodes++;\n \t  }\n-\tgv->begin_tr ();\n+\tgv->begin_trtd ();\n \tpp_printf (pp, \"enodes: %i\\n\", num_enodes);\n-\tgv->end_tr ();\n+\tgv->end_tdtr ();\n \tpp_newline (pp);\n \n \t// TODO: also show the per-callstring breakdown\n@@ -3571,11 +3576,11 @@ class viz_callgraph_node : public dnode<viz_callgraph_traits>\n \t      }\n \t    if (num_enodes > 0)\n \t      {\n-\t\tgv->begin_tr ();\n+\t\tgv->begin_trtd ();\n \t\tcs->print (pp);\n \t\tpp_printf (pp, \": %i\\n\", num_enodes);\n \t\tpp_write_text_as_html_like_dot_to_stream (pp);\n-\t\tgv->end_tr ();\n+\t\tgv->end_tdtr ();\n \t      }\n \t  }\n \n@@ -3584,10 +3589,10 @@ class viz_callgraph_node : public dnode<viz_callgraph_traits>\n \tif (data)\n \t  {\n \t    pp_newline (pp);\n-\t    gv->begin_tr ();\n+\t    gv->begin_trtd ();\n \t    pp_printf (pp, \"summaries: %i\\n\", data->m_summaries.length ());\n \t    pp_write_text_as_html_like_dot_to_stream (pp);\n-\t    gv->end_tr ();\n+\t    gv->end_tdtr ();\n \t  }\n       }\n \n@@ -3730,6 +3735,231 @@ dump_callgraph (const supergraph &sg, const exploded_graph *eg)\n   free (filename);\n }\n \n+/* Subclass of dot_annotator for implementing\n+   DUMP_BASE_NAME.supergraph-eg.dot, a post-analysis dump of the supergraph.\n+\n+   Annotate the supergraph nodes by printing the exploded nodes in concise\n+   form within them, next to their pertinent statements where appropriate,\n+   colorizing the exploded nodes based on sm-state.\n+   Also show saved diagnostics within the exploded nodes, giving information\n+   on whether they were feasible, and, if infeasible, where the problem\n+   was.  */\n+\n+class exploded_graph_annotator : public dot_annotator\n+{\n+public:\n+  exploded_graph_annotator (const exploded_graph &eg)\n+  : m_eg (eg)\n+  {\n+    /* Avoid O(N^2) by prepopulating m_enodes_per_snodes.  */\n+    unsigned i;\n+    supernode *snode;\n+    FOR_EACH_VEC_ELT (eg.get_supergraph ().m_nodes, i, snode)\n+      m_enodes_per_snodes.safe_push (new auto_vec <exploded_node *> ());\n+    exploded_node *enode;\n+    FOR_EACH_VEC_ELT (m_eg.m_nodes, i, enode)\n+      if (enode->get_supernode ())\n+\tm_enodes_per_snodes[enode->get_supernode ()->m_index]->safe_push (enode);\n+  }\n+\n+  /* Show exploded nodes for BEFORE_SUPERNODE points before N.  */\n+  bool add_node_annotations (graphviz_out *gv, const supernode &n,\n+\t\t\t     bool within_table)\n+    const FINAL OVERRIDE\n+  {\n+    if (!within_table)\n+      return false;\n+    gv->begin_tr ();\n+    pretty_printer *pp = gv->get_pp ();\n+\n+    gv->begin_td ();\n+    pp_string (pp, \"BEFORE\");\n+    gv->end_td ();\n+\n+    unsigned i;\n+    exploded_node *enode;\n+    bool had_enode = false;\n+    FOR_EACH_VEC_ELT (*m_enodes_per_snodes[n.m_index], i, enode)\n+      {\n+\tgcc_assert (enode->get_supernode () == &n);\n+\tconst program_point &point = enode->get_point ();\n+\tif (point.get_kind () != PK_BEFORE_SUPERNODE)\n+\t  continue;\n+\tprint_enode (gv, enode);\n+\thad_enode = true;\n+      }\n+    if (!had_enode)\n+      pp_string (pp, \"<TD BGCOLOR=\\\"red\\\">UNREACHED</TD>\");\n+    pp_flush (pp);\n+    gv->end_tr ();\n+    return true;\n+  }\n+\n+  /* Show exploded nodes for STMT.  */\n+  void add_stmt_annotations (graphviz_out *gv, const gimple *stmt,\n+\t\t\t     bool within_row)\n+    const FINAL OVERRIDE\n+  {\n+    if (!within_row)\n+      return;\n+    pretty_printer *pp = gv->get_pp ();\n+\n+    const supernode *snode\n+      = m_eg.get_supergraph ().get_supernode_for_stmt (stmt);\n+    unsigned i;\n+    exploded_node *enode;\n+    bool had_td = false;\n+    FOR_EACH_VEC_ELT (*m_enodes_per_snodes[snode->m_index], i, enode)\n+      {\n+\tconst program_point &point = enode->get_point ();\n+\tif (point.get_kind () != PK_BEFORE_STMT)\n+\t  continue;\n+\tif (point.get_stmt () != stmt)\n+\t  continue;\n+\tprint_enode (gv, enode);\n+\thad_td = true;\n+      }\n+    pp_flush (pp);\n+    if (!had_td)\n+      {\n+\tgv->begin_td ();\n+\tgv->end_td ();\n+      }\n+  }\n+\n+  /* Show exploded nodes for AFTER_SUPERNODE points after N.  */\n+  bool add_after_node_annotations (graphviz_out *gv, const supernode &n)\n+    const FINAL OVERRIDE\n+  {\n+    gv->begin_tr ();\n+    pretty_printer *pp = gv->get_pp ();\n+\n+    gv->begin_td ();\n+    pp_string (pp, \"AFTER\");\n+    gv->end_td ();\n+\n+    unsigned i;\n+    exploded_node *enode;\n+    FOR_EACH_VEC_ELT (*m_enodes_per_snodes[n.m_index], i, enode)\n+      {\n+\tgcc_assert (enode->get_supernode () == &n);\n+\tconst program_point &point = enode->get_point ();\n+\tif (point.get_kind () != PK_AFTER_SUPERNODE)\n+\t  continue;\n+\tprint_enode (gv, enode);\n+      }\n+    pp_flush (pp);\n+    gv->end_tr ();\n+    return true;\n+  }\n+\n+private:\n+  /* Concisely print a TD element for ENODE, showing the index, status,\n+     and any saved_diagnostics at the enode.  Colorize it to show sm-state.\n+\n+     Ideally we'd dump ENODE's state here, hidden behind some kind of\n+     interactive disclosure method like a tooltip, so that the states\n+     can be explored without overwhelming the graph.\n+     However, I wasn't able to get graphviz/xdot to show tooltips on\n+     individual elements within a HTML-like label.  */\n+  void print_enode (graphviz_out *gv, const exploded_node *enode) const\n+  {\n+    pretty_printer *pp = gv->get_pp ();\n+    pp_printf (pp, \"<TD BGCOLOR=\\\"%s\\\">\",\n+\t       enode->get_dot_fillcolor ());\n+    pp_printf (pp, \"<TABLE BORDER=\\\"0\\\">\");\n+    gv->begin_trtd ();\n+    pp_printf (pp, \"EN: %i\", enode->m_index);\n+    switch (enode->get_status ())\n+      {\n+      default:\n+\tgcc_unreachable ();\n+      case exploded_node::STATUS_WORKLIST:\n+\tpp_string (pp, \"(W)\");\n+\tbreak;\n+      case exploded_node::STATUS_PROCESSED:\n+\tbreak;\n+      case exploded_node::STATUS_MERGER:\n+\tpp_string (pp, \"(M)\");\n+\tbreak;\n+      }\n+    gv->end_tdtr ();\n+    /* Dump any saved_diagnostics at this enode.  */\n+    {\n+      const diagnostic_manager &dm = m_eg.get_diagnostic_manager ();\n+      for (unsigned i = 0; i < dm.get_num_diagnostics (); i++)\n+\t{\n+\t  const saved_diagnostic *sd = dm.get_saved_diagnostic (i);\n+\t  if (sd->m_enode == enode)\n+\t    print_saved_diagnostic (gv, sd);\n+\t}\n+    }\n+    pp_printf (pp, \"</TABLE>\");\n+    pp_printf (pp, \"</TD>\");\n+  }\n+\n+  /* Print a TABLE element for SD, showing the kind, the length of the\n+     exploded_path, whether the path was feasible, and if infeasible,\n+     what the problem was.  */\n+  void print_saved_diagnostic (graphviz_out *gv,\n+\t\t\t       const saved_diagnostic *sd) const\n+  {\n+    pretty_printer *pp = gv->get_pp ();\n+    gv->begin_trtd ();\n+    pp_printf (pp, \"<TABLE BORDER=\\\"0\\\">\");\n+    gv->begin_tr ();\n+    pp_string (pp, \"<TD BGCOLOR=\\\"green\\\">\");\n+    pp_printf (pp, \"DIAGNOSTIC: %s\", sd->m_d->get_kind ());\n+    gv->end_tdtr ();\n+    gv->begin_trtd ();\n+    pp_printf (pp, \"epath length: %i\", sd->get_epath_length ());\n+    gv->end_tdtr ();\n+    switch (sd->get_status ())\n+      {\n+      default:\n+      case saved_diagnostic::STATUS_NEW:\n+\tgcc_unreachable ();\n+\tbreak;\n+      case saved_diagnostic::STATUS_INFEASIBLE_PATH:\n+\t{\n+\t  gv->begin_trtd ();\n+\t  pp_printf (pp, \"INFEASIBLE\");\n+\t  gv->end_tdtr ();\n+\t  const feasibility_problem *p = sd->get_feasibility_problem ();\n+\t  gcc_assert (p);\n+\t  gv->begin_trtd ();\n+\t  pp_printf (pp, \"at eedge %i: EN:%i -> EN:%i\",\n+\t\t     p->m_eedge_idx,\n+\t\t     p->m_eedge.m_src->m_index,\n+\t\t     p->m_eedge.m_dest->m_index);\n+\t  pp_write_text_as_html_like_dot_to_stream (pp);\n+\t  gv->end_tdtr ();\n+\t  gv->begin_trtd ();\n+\t  p->m_eedge.m_sedge->dump (pp);\n+\t  pp_write_text_as_html_like_dot_to_stream (pp);\n+\t  gv->end_tdtr ();\n+\t  gv->begin_trtd ();\n+\t  pp_gimple_stmt_1 (pp, p->m_last_stmt, 0, (dump_flags_t)0);\n+\t  pp_write_text_as_html_like_dot_to_stream (pp);\n+\t  gv->end_tdtr ();\n+\t  /* Ideally we'd print p->m_model here; see the notes above about\n+\t     tooltips.  */\n+\t}\n+\tbreak;\n+      case saved_diagnostic::STATUS_FEASIBLE_PATH:\n+\tgv->begin_trtd ();\n+\tpp_printf (pp, \"FEASIBLE\");\n+\tgv->end_tdtr ();\n+\tbreak;\n+      }\n+    pp_printf (pp, \"</TABLE>\");\n+    gv->end_tdtr ();\n+  }\n+\n+  const exploded_graph &m_eg;\n+  auto_delete_vec<auto_vec <exploded_node *> > m_enodes_per_snodes;\n+};\n+\n /* Run the analysis \"engine\".  */\n \n void\n@@ -3752,6 +3982,7 @@ impl_run_checkers (logger *logger)\n \n   if (flag_dump_analyzer_supergraph)\n     {\n+      /* Dump supergraph pre-analysis.  */\n       auto_timevar tv (TV_ANALYZER_DUMP);\n       char *filename = concat (dump_base_name, \".supergraph.dot\", NULL);\n       supergraph::dump_args_t args ((enum supergraph_dot_flags)0, NULL);\n@@ -3816,6 +4047,17 @@ impl_run_checkers (logger *logger)\n   if (flag_dump_analyzer_callgraph)\n     dump_callgraph (sg, &eg);\n \n+  if (flag_dump_analyzer_supergraph)\n+    {\n+      /* Dump post-analysis form of supergraph.  */\n+      auto_timevar tv (TV_ANALYZER_DUMP);\n+      char *filename = concat (dump_base_name, \".supergraph-eg.dot\", NULL);\n+      exploded_graph_annotator a (eg);\n+      supergraph::dump_args_t args ((enum supergraph_dot_flags)0, &a);\n+      sg.dump_dot (filename, args);\n+      free (filename);\n+    }\n+\n   delete purge_map;\n }\n "}, {"sha": "b3e89d4a094a537404e3a475c4eb784696dfe16a", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=42c633132521c8c2874cef54852090d587ce66c3", "patch": "@@ -179,6 +179,7 @@ class exploded_node : public dnode<eg_traits>\n \n   hashval_t hash () const { return m_ps.hash (); }\n \n+  const char * get_dot_fillcolor () const;\n   void dump_dot (graphviz_out *gv, const dump_args_t &args)\n     const FINAL OVERRIDE;\n   void dump_dot_id (pretty_printer *pp) const;\n@@ -269,8 +270,6 @@ class exploded_node : public dnode<eg_traits>\n private:\n   DISABLE_COPY_AND_ASSIGN (exploded_node);\n \n-  const char * get_dot_fillcolor () const;\n-\n   /* The <program_point, program_state> pair.  This is const, as it\n      is immutable once the exploded_node has been created.  */\n   const point_and_state m_ps;\n@@ -857,11 +856,30 @@ class exploded_path\n   void dump (FILE *fp) const;\n   void dump () const;\n \n-  bool feasible_p (logger *logger) const;\n+  bool feasible_p (logger *logger, feasibility_problem **out) const;\n \n   auto_vec<const exploded_edge *> m_edges;\n };\n \n+/* A reason why a particular exploded_path is infeasible.  */\n+\n+class feasibility_problem\n+{\n+public:\n+  feasibility_problem (unsigned eedge_idx,\n+\t\t       const region_model &model,\n+\t\t       const exploded_edge &eedge,\n+\t\t       const gimple *last_stmt)\n+  : m_eedge_idx (eedge_idx), m_model (model), m_eedge (eedge),\n+    m_last_stmt (last_stmt)\n+  {}\n+\n+  unsigned m_eedge_idx;\n+  region_model m_model;\n+  const exploded_edge &m_eedge;\n+  const gimple *m_last_stmt;\n+};\n+\n /* Finding the shortest exploded_path within an exploded_graph.  */\n \n typedef shortest_paths<eg_traits, exploded_path> shortest_exploded_paths;"}, {"sha": "d5a24b48e1ef7fffe7d08fc5691d212c537d29d2", "filename": "gcc/analyzer/state-purge.cc", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fstate-purge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fstate-purge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstate-purge.cc?ref=42c633132521c8c2874cef54852090d587ce66c3", "patch": "@@ -419,12 +419,16 @@ state_purge_per_ssa_name::process_point (const function_point &point,\n    Add an additional record showing which names are purged on entry\n    to the supernode N.  */\n \n-void\n+bool\n state_purge_annotator::add_node_annotations (graphviz_out *gv,\n-\t\t\t\t\t     const supernode &n) const\n+\t\t\t\t\t     const supernode &n,\n+\t\t\t\t\t     bool within_table) const\n {\n   if (m_map == NULL)\n-    return;\n+    return false;\n+\n+  if (within_table)\n+    return false;\n \n   pretty_printer *pp = gv->get_pp ();\n \n@@ -455,6 +459,7 @@ state_purge_annotator::add_node_annotations (graphviz_out *gv,\n \n    pp_string (pp, \"\\\"];\\n\\n\");\n    pp_flush (pp);\n+   return false;\n }\n \n /* Print V to GV as a comma-separated list in braces within a <TR>,\n@@ -469,7 +474,7 @@ print_vec_of_names (graphviz_out *gv, const char *title,\n   pretty_printer *pp = gv->get_pp ();\n   tree name;\n   unsigned i;\n-  gv->begin_tr ();\n+  gv->begin_trtd ();\n   pp_printf (pp, \"%s: {\", title);\n   FOR_EACH_VEC_ELT (v, i, name)\n     {\n@@ -479,7 +484,7 @@ print_vec_of_names (graphviz_out *gv, const char *title,\n     }\n   pp_printf (pp, \"}\");\n   pp_write_text_as_html_like_dot_to_stream (pp);\n-  gv->end_tr ();\n+  gv->end_tdtr ();\n   pp_newline (pp);\n }\n \n@@ -490,8 +495,12 @@ print_vec_of_names (graphviz_out *gv, const char *title,\n \n void\n state_purge_annotator::add_stmt_annotations (graphviz_out *gv,\n-\t\t\t\t\t     const gimple *stmt) const\n+\t\t\t\t\t     const gimple *stmt,\n+\t\t\t\t\t     bool within_row) const\n {\n+  if (within_row)\n+    return;\n+\n   if (m_map == NULL)\n     return;\n "}, {"sha": "60464ebee20bf59192488717b878714aa0993478", "filename": "gcc/analyzer/state-purge.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fstate-purge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fstate-purge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstate-purge.h?ref=42c633132521c8c2874cef54852090d587ce66c3", "patch": "@@ -151,10 +151,11 @@ class state_purge_annotator : public dot_annotator\n public:\n   state_purge_annotator (const state_purge_map *map) : m_map (map) {}\n \n-  void add_node_annotations (graphviz_out *gv, const supernode &n)\n+  bool add_node_annotations (graphviz_out *gv, const supernode &n, bool)\n     const FINAL OVERRIDE;\n \n-  void add_stmt_annotations (graphviz_out *gv, const gimple *stmt)\n+  void add_stmt_annotations (graphviz_out *gv, const gimple *stmt,\n+\t\t\t     bool within_row)\n     const FINAL OVERRIDE;\n \n private:"}, {"sha": "7c6fed3a060da85e211bc1eeb6a3a56bf5a7046a", "filename": "gcc/analyzer/supergraph.cc", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fsupergraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fsupergraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.cc?ref=42c633132521c8c2874cef54852090d587ce66c3", "patch": "@@ -458,7 +458,7 @@ supernode::dump_dot (graphviz_out *gv, const dump_args_t &args) const\n   pretty_printer *pp = gv->get_pp ();\n \n   if (args.m_node_annotator)\n-    args.m_node_annotator->add_node_annotations (gv, *this);\n+    args.m_node_annotator->add_node_annotations (gv, *this, false);\n \n   gv->write_indent ();\n   dump_dot_id (pp);\n@@ -470,19 +470,33 @@ supernode::dump_dot (graphviz_out *gv, const dump_args_t &args) const\n \n   bool had_row = false;\n \n+  /* Give any annotator the chance to add its own per-node TR elements. */\n+  if (args.m_node_annotator)\n+    if (args.m_node_annotator->add_node_annotations (gv, *this, true))\n+      had_row = true;\n+\n   if (m_returning_call)\n     {\n-      gv->begin_tr ();\n+      gv->begin_trtd ();\n       pp_string (pp, \"returning call: \");\n-      gv->end_tr ();\n+      gv->end_tdtr ();\n \n       gv->begin_tr ();\n+      gv->begin_td ();\n       pp_gimple_stmt_1 (pp, m_returning_call, 0, (dump_flags_t)0);\n       pp_write_text_as_html_like_dot_to_stream (pp);\n+      gv->end_td ();\n+      /* Give any annotator the chance to add per-stmt TD elements to\n+\t this row.  */\n+      if (args.m_node_annotator)\n+\targs.m_node_annotator->add_stmt_annotations (gv, m_returning_call,\n+\t\t\t\t\t\t     true);\n       gv->end_tr ();\n \n+      /* Give any annotator the chance to add per-stmt TR elements.  */\n       if (args.m_node_annotator)\n-\targs.m_node_annotator->add_stmt_annotations (gv, m_returning_call);\n+\targs.m_node_annotator->add_stmt_annotations (gv, m_returning_call,\n+\t\t\t\t\t\t     false);\n       pp_newline (pp);\n \n       had_row = true;\n@@ -508,12 +522,19 @@ supernode::dump_dot (graphviz_out *gv, const dump_args_t &args) const\n     {\n       const gimple *stmt = gsi_stmt (gpi);\n       gv->begin_tr ();\n+      gv->begin_td ();\n       pp_gimple_stmt_1 (pp, stmt, 0, (dump_flags_t)0);\n       pp_write_text_as_html_like_dot_to_stream (pp);\n+      gv->end_td ();\n+      /* Give any annotator the chance to add per-phi TD elements to\n+\t this row.  */\n+      if (args.m_node_annotator)\n+\targs.m_node_annotator->add_stmt_annotations (gv, stmt, true);\n       gv->end_tr ();\n \n+      /* Give any annotator the chance to add per-phi TR elements.  */\n       if (args.m_node_annotator)\n-\targs.m_node_annotator->add_stmt_annotations (gv, stmt);\n+\targs.m_node_annotator->add_stmt_annotations (gv, stmt, false);\n \n       pp_newline (pp);\n       had_row = true;\n@@ -525,17 +546,30 @@ supernode::dump_dot (graphviz_out *gv, const dump_args_t &args) const\n   FOR_EACH_VEC_ELT (m_stmts, i, stmt)\n     {\n       gv->begin_tr ();\n+      gv->begin_td ();\n       pp_gimple_stmt_1 (pp, stmt, 0, (dump_flags_t)0);\n       pp_write_text_as_html_like_dot_to_stream (pp);\n+      gv->end_td ();\n+      /* Give any annotator the chance to add per-stmt TD elements to\n+\t this row.  */\n+      if (args.m_node_annotator)\n+\targs.m_node_annotator->add_stmt_annotations (gv, stmt, true);\n       gv->end_tr ();\n \n+      /* Give any annotator the chance to add per-stmt TR elements.  */\n       if (args.m_node_annotator)\n-\targs.m_node_annotator->add_stmt_annotations (gv, stmt);\n+\targs.m_node_annotator->add_stmt_annotations (gv, stmt, false);\n \n       pp_newline (pp);\n       had_row = true;\n     }\n \n+  /* Give any annotator the chance to add additional per-node TR elements\n+     to the end of the TABLE. */\n+  if (args.m_node_annotator)\n+    if (args.m_node_annotator->add_after_node_annotations (gv, *this))\n+      had_row = true;\n+\n   /* Graphviz requires a TABLE element to have at least one TR\n      (and each TR to have at least one TD).  */\n   if (!had_row)"}, {"sha": "c25043d92fd01f5584684fb64036bb292074258b", "filename": "gcc/analyzer/supergraph.h", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fsupergraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fanalyzer%2Fsupergraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.h?ref=42c633132521c8c2874cef54852090d587ce66c3", "patch": "@@ -569,12 +569,23 @@ class dot_annotator\n {\n  public:\n   virtual ~dot_annotator () {}\n-  virtual void add_node_annotations (graphviz_out *gv ATTRIBUTE_UNUSED,\n-\t\t\t\t     const supernode &n ATTRIBUTE_UNUSED)\n-    const {}\n+  virtual bool add_node_annotations (graphviz_out *gv ATTRIBUTE_UNUSED,\n+\t\t\t\t     const supernode &n ATTRIBUTE_UNUSED,\n+\t\t\t\t     bool within_table ATTRIBUTE_UNUSED)\n+    const\n+  {\n+    return false;\n+  }\n   virtual void add_stmt_annotations (graphviz_out *gv ATTRIBUTE_UNUSED,\n-\t\t\t\t     const gimple *stmt ATTRIBUTE_UNUSED)\n+\t\t\t\t     const gimple *stmt ATTRIBUTE_UNUSED,\n+\t\t\t\t     bool within_row ATTRIBUTE_UNUSED)\n     const {}\n+  virtual bool add_after_node_annotations (graphviz_out *gv ATTRIBUTE_UNUSED,\n+\t\t\t\t\t   const supernode &n ATTRIBUTE_UNUSED)\n+    const\n+  {\n+    return false;\n+  }\n };\n \n extern cgraph_edge *supergraph_call_edge (function *fun, gimple *stmt);"}, {"sha": "c2053a3804fb1af9eb8e4309f20621afa5df2d76", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=42c633132521c8c2874cef54852090d587ce66c3", "patch": "@@ -8607,10 +8607,12 @@ The graph is written to @file{@var{file}.state-purge.dot}.\n \n @item -fdump-analyzer-supergraph\n @opindex fdump-analyzer-supergraph\n-Dump a representation of the ``supergraph'' suitable for viewing with\n-GraphViz to @file{@var{file}.supergraph.dot}.  This shows all of the\n+Dump representations of the ``supergraph'' suitable for viewing with\n+GraphViz to @file{@var{file}.supergraph.dot} and to\n+@file{@var{file}.supergraph-eg.dot}.  These show all of the\n control flow graphs in the program, with interprocedural edges for\n-calls and returns.\n+calls and returns.  The second dump contains annotations showing nodes\n+in the ``exploded graph'' and diagnostics associated with them.\n \n @end table\n "}, {"sha": "3b75f7259aa5cedcc1ed51e52f8a19d7f358d13f", "filename": "gcc/graphviz.cc", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fgraphviz.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fgraphviz.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphviz.cc?ref=42c633132521c8c2874cef54852090d587ce66c3", "patch": "@@ -79,11 +79,51 @@ graphviz_out::write_indent ()\n     pp_space (m_pp);\n }\n \n-/* Write the start of an HTML-like row via <TR><TD>, writing to the stream\n+/* Write the start of an HTML-like row via <TR>, writing to the stream\n    so that followup text can be escaped.  */\n \n void\n graphviz_out::begin_tr ()\n+{\n+  pp_string (m_pp, \"<TR>\");\n+  pp_write_text_to_stream (m_pp);\n+}\n+\n+/* Write the end of an HTML-like row via </TR>, writing to the stream\n+   so that followup text can be escaped.  */\n+\n+void\n+graphviz_out::end_tr ()\n+{\n+  pp_string (m_pp, \"</TR>\");\n+  pp_write_text_to_stream (m_pp);\n+}\n+\n+/* Write the start of an HTML-like <TD>, writing to the stream\n+   so that followup text can be escaped.  */\n+\n+void\n+graphviz_out::begin_td ()\n+{\n+  pp_string (m_pp, \"<TD ALIGN=\\\"LEFT\\\">\");\n+  pp_write_text_to_stream (m_pp);\n+}\n+\n+/* Write the end of an HTML-like </TD>, writing to the stream\n+   so that followup text can be escaped.  */\n+\n+void\n+graphviz_out::end_td ()\n+{\n+  pp_string (m_pp, \"</TD>\");\n+  pp_write_text_to_stream (m_pp);\n+}\n+\n+/* Write the start of an HTML-like row via <TR><TD>, writing to the stream\n+   so that followup text can be escaped.  */\n+\n+void\n+graphviz_out::begin_trtd ()\n {\n   pp_string (m_pp, \"<TR><TD ALIGN=\\\"LEFT\\\">\");\n   pp_write_text_to_stream (m_pp);\n@@ -93,7 +133,7 @@ graphviz_out::begin_tr ()\n    so that followup text can be escaped.  */\n \n void\n-graphviz_out::end_tr ()\n+graphviz_out::end_tdtr ()\n {\n   pp_string (m_pp, \"</TD></TR>\");\n   pp_write_text_to_stream (m_pp);"}, {"sha": "1d4dae9e2d77822a11071879607385d39d54700e", "filename": "gcc/graphviz.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fgraphviz.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Fgraphviz.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphviz.h?ref=42c633132521c8c2874cef54852090d587ce66c3", "patch": "@@ -43,6 +43,12 @@ class graphviz_out {\n   void begin_tr ();\n   void end_tr ();\n \n+  void begin_td ();\n+  void end_td ();\n+\n+  void begin_trtd ();\n+  void end_tdtr ();\n+\n   pretty_printer *get_pp () const { return m_pp; }\n \n  private:"}, {"sha": "bc88021ca2d0ca916ead552d3280372021ebb31c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=42c633132521c8c2874cef54852090d587ce66c3", "patch": "@@ -1,3 +1,8 @@\n+2020-03-27  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/analyzer/dot-output.c: Check that\n+\tdot-output.c.supergraph-eg.dot is valid.\n+\n 2020-03-27  Richard Biener  <rguenther@suse.de>\n \n \tPR debug/94273"}, {"sha": "7b69c626f4e736667c6b1274afea1230f7003295", "filename": "gcc/testsuite/gcc.dg/analyzer/dot-output.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdot-output.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c633132521c8c2874cef54852090d587ce66c3/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdot-output.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdot-output.c?ref=42c633132521c8c2874cef54852090d587ce66c3", "patch": "@@ -47,3 +47,4 @@ int test_2 (void)\n /* { dg-final { dg-check-dot \"dot-output.c.eg.dot\" } } */\n /* { dg-final { dg-check-dot \"dot-output.c.state-purge.dot\" } } */\n /* { dg-final { dg-check-dot \"dot-output.c.supergraph.dot\" } } */\n+/* { dg-final { dg-check-dot \"dot-output.c.supergraph-eg.dot\" } } */"}]}