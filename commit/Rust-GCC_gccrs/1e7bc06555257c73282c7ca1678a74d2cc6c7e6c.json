{"sha": "1e7bc06555257c73282c7ca1678a74d2cc6c7e6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU3YmMwNjU1NTI1N2M3MzI4MmM3Y2ExNjc4YTc0ZDJjYzZjN2U2Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-14T13:31:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-14T13:31:52Z"}, "message": "[multiple changes]\n\n2013-10-14  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_prag.adb: Minor reformatting.\n\n2013-10-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_case.adb (Check_Against_Predicate): Handle properly an\n\tothers clause in various cases.\n\n2013-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Check_Matching_Constituent): Do\n\tnot inspect the hidden states if there are no hidden states. This\n\tcase arises when the constituents are states coming from a\n\tprivate child.\n\n2013-10-14  Doug Rupp  <rupp@adacore.com>\n\n\t* init.c [ARMEL and VxWorks] (__gnat_map_signal): Re-arm guard\n\tpage by clearing VALID bit vice setting page protection.\n\n2013-10-14  Arnaud Charlet  <charlet@adacore.com>\n\n\t* gnat_rm.texi, adaint.c: Fix typo.\n\n2013-10-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb (Is_Variable, In_Protected_Function):  In the\n\tbody of a protected function, the protected object itself is a\n\tconstant (not just its components).\n\nFrom-SVN: r203550", "tree": {"sha": "83de5b6633cd5a5aeabf422cb2244eb93481f494", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83de5b6633cd5a5aeabf422cb2244eb93481f494"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/comments", "author": null, "committer": null, "parents": [{"sha": "5644b7e8e7fcc55fe544949c58ce049039e671c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5644b7e8e7fcc55fe544949c58ce049039e671c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5644b7e8e7fcc55fe544949c58ce049039e671c9"}], "stats": {"total": 172, "additions": 125, "deletions": 47}, "files": [{"sha": "adb5e6d79e231f8d885e4bc1e4a6cb6b95baf778", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1e7bc06555257c73282c7ca1678a74d2cc6c7e6c", "patch": "@@ -1,3 +1,34 @@\n+2013-10-14  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_prag.adb: Minor reformatting.\n+\n+2013-10-14  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_case.adb (Check_Against_Predicate): Handle properly an\n+\tothers clause in various cases.\n+\n+2013-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Check_Matching_Constituent): Do\n+\tnot inspect the hidden states if there are no hidden states. This\n+\tcase arises when the constituents are states coming from a\n+\tprivate child.\n+\n+2013-10-14  Doug Rupp  <rupp@adacore.com>\n+\n+\t* init.c [ARMEL and VxWorks] (__gnat_map_signal): Re-arm guard\n+\tpage by clearing VALID bit vice setting page protection.\n+\n+2013-10-14  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gnat_rm.texi, adaint.c: Fix typo.\n+\n+2013-10-14  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb (Is_Variable, In_Protected_Function):  In the\n+\tbody of a protected function, the protected object itself is a\n+\tconstant (not just its components).\n+\n 2013-10-14  Vincent Celier  <celier@adacore.com>\n \n \t* snames.ads-tmpl: Add new standard name Library_Rpath_Options."}, {"sha": "e447907095594ad72a9bb19a57b58707f2dd8ae8", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=1e7bc06555257c73282c7ca1678a74d2cc6c7e6c", "patch": "@@ -3982,7 +3982,7 @@ __gnat_get_executable_load_address (void)\n       status = loadquery (L_GETINFO, buf, blen);\n       if (status == 0)\n         {\n-          struct ldinfo *info = (struct ld_info *)buf;\n+          struct ld_info *info = (struct ld_info *)buf;\n           return info->ldinfo_textorg;\n         }\n       blen = blen * 2;"}, {"sha": "f4314780f9ec359649d6670f0efd82ae3f1ecf1f", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=1e7bc06555257c73282c7ca1678a74d2cc6c7e6c", "patch": "@@ -543,30 +543,34 @@ package body Exp_Prag is\n    -- Expand_Pragma_Import_Or_Interface --\n    ---------------------------------------\n \n-   --  When applied to a variable, the default initialization must not be done.\n-   --  As it is already done when the pragma is found, we just get rid of the\n-   --  call the initialization procedure which followed the object declaration.\n-   --  The call is inserted after the declaration, but validity checks may\n-   --  also have been inserted and the initialization call does not necessarily\n-   --  appear immediately after the object declaration.\n-\n-   --  We can't use the freezing mechanism for this purpose, since we have to\n-   --  elaborate the initialization expression when it is first seen (i.e. this\n-   --  elaboration cannot be deferred to the freeze point).\n-\n    procedure Expand_Pragma_Import_Or_Interface (N : Node_Id) is\n       Def_Id    : Entity_Id;\n       Init_Call : Node_Id;\n \n    begin\n       Def_Id := Entity (Arg2 (N));\n+\n+      --  Variable case\n+\n       if Ekind (Def_Id) = E_Variable then\n \n+         --  When applied to a variable, the default initialization must not be\n+         --  done. As it is already done when the pragma is found, we just get\n+         --  rid of the call the initialization procedure which followed the\n+         --  object declaration. The call is inserted after the declaration,\n+         --  but validity checks may also have been inserted and thus the\n+         --  initialization call does not necessarily appear immediately\n+         --  after the object declaration.\n+\n+         --  We can't use the freezing mechanism for this purpose, since we\n+         --  have to elaborate the initialization expression when it is first\n+         --  seen (so this elaboration cannot be deferred to the freeze point).\n+\n          --  Find and remove generated initialization call for object, if any\n \n          Init_Call := Remove_Init_Call (Def_Id, Rep_Clause => N);\n \n-         --  Any default initialization expression should be removed (e.g.,\n+         --  Any default initialization expression should be removed (e.g.\n          --  null defaults for access objects, zero initialization of packed\n          --  bit arrays). Imported objects aren't allowed to have explicit\n          --  initialization, so the expression must have been generated by\n@@ -575,19 +579,21 @@ package body Exp_Prag is\n          if No (Init_Call) and then Present (Expression (Parent (Def_Id))) then\n             Set_Expression (Parent (Def_Id), Empty);\n          end if;\n+\n+      --  Case of exception with convention C++\n+\n       elsif Ekind (Def_Id) = E_Exception\n         and then Convention (Def_Id) = Convention_CPP\n       then\n-\n          --  Import a C++ convention\n \n          declare\n-            Loc            : constant Source_Ptr := Sloc (N);\n-            Exdata         : List_Id;\n-            Lang_Char      : Node_Id;\n-            Foreign_Data   : Node_Id;\n-            Rtti_Name      : constant Node_Id := Arg3 (N);\n-            Dum            : constant Entity_Id  := Make_Temporary (Loc, 'D');\n+            Loc          : constant Source_Ptr := Sloc (N);\n+            Rtti_Name    : constant Node_Id    := Arg3 (N);\n+            Dum          : constant Entity_Id  := Make_Temporary (Loc, 'D');\n+            Exdata       : List_Id;\n+            Lang_Char    : Node_Id;\n+            Foreign_Data : Node_Id;\n \n          begin\n             Exdata := Component_Associations (Expression (Parent (Def_Id)));\n@@ -598,9 +604,8 @@ package body Exp_Prag is\n \n             Rewrite (Expression (Lang_Char),\n               Make_Character_Literal (Loc,\n-                Chars => Name_uC,\n-                Char_Literal_Value =>\n-                  UI_From_Int (Character'Pos ('C'))));\n+                Chars              => Name_uC,\n+                Char_Literal_Value => UI_From_Int (Character'Pos ('C'))));\n             Analyze (Expression (Lang_Char));\n \n             --  Change the value of Foreign_Data\n@@ -633,6 +638,12 @@ package body Exp_Prag is\n                   Attribute_Name => Name_Address)));\n             Analyze (Expression (Foreign_Data));\n          end;\n+\n+      --  No special expansion required for any other case\n+\n+      else\n+         null;\n+\n       end if;\n    end Expand_Pragma_Import_Or_Interface;\n "}, {"sha": "ff8013be9d5d0ccb62c006539ed54fa31f489420", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=1e7bc06555257c73282c7ca1678a74d2cc6c7e6c", "patch": "@@ -18886,7 +18886,7 @@ pragma Import (Cpp,\n   [External_Name =>] static_string_EXPRESSION);\n @end smallexample\n \n-@noident\n+@noindent\n The @code{External_Name} is the name of the C++ RTTI symbol. You can then\n cover a specific C++ exception in an exception handler.\n "}, {"sha": "7f8b3a3e58c53711a1c29a465be16611eaec2c88", "filename": "gcc/ada/init.c", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=1e7bc06555257c73282c7ca1678a74d2cc6c7e6c", "patch": "@@ -1663,6 +1663,10 @@ __gnat_install_handler ()\n #include <iv.h>\n #endif\n \n+#if defined (ARMEL) && (_WRS_VXWORKS_MAJOR == 6)\n+#include <vmLib.h>\n+#endif\n+\n #ifdef VTHREADS\n #include \"private/vThreadsP.h\"\n #endif\n@@ -1799,38 +1803,31 @@ __gnat_map_signal (int sig, siginfo_t *si ATTRIBUTE_UNUSED,\n       msg = \"unhandled signal\";\n     }\n \n-  /* On ARM VxWorks 6.x, the guard page is left in a RWX state by the kernel\n-     after being violated, so subsequent violations aren't detected.  Even if\n-     this defect is fixed, it seems dubious to rely on the signal value alone,\n+  /* On ARM VxWorks 6.x, the guard page is left un-armed by the kernel\n+     after being violated, so subsequent violations aren't detected.\n      so we retrieve the address of the guard page from the TCB and compare it\n      with the page that is violated (pREG 12 in the context) and re-arm that\n      page if there's a match.  Additionally we're are assured this is a\n      genuine stack overflow condition and and set the message and exception\n      to that effect.  */\n #if defined (ARMEL) && (_WRS_VXWORKS_MAJOR == 6)\n \n-  /* We re-arm the guard page by re-setting it's attributes, however the\n-     protection bits are just the low order seven (0x3f).\n-     0x00040 is the Valid Mask\n-     0x00f00 are Cache attributes\n-     0xff000 are Special attributes\n-     We don't meddle with the 0xfff40 attributes.  */\n+  /* We re-arm the guard page by marking it invalid */\n \n #define PAGE_SIZE 4096\n-#define MMU_ATTR_PROT_MSK 0x0000003f /* Protection Mask.  */\n-#define GUARD_PAGE_PROT 0x8101       /* Found by experiment.  */\n+#define REG_IP 12\n \n   if (sig == SIGSEGV || sig == SIGBUS || sig == SIGILL)\n     {\n       TASK_ID tid = taskIdSelf ();\n       WIND_TCB *pTcb = taskTcb (tid);\n-      unsigned long Violated_Page\n-          = ((struct sigcontext *) sc)->sc_pregs->r[12] & ~(PAGE_SIZE - 1);\n+      unsigned long violated_page\n+          = ((struct sigcontext *) sc)->sc_pregs->r[REG_IP] & ~(PAGE_SIZE - 1);\n \n-      if ((unsigned long) (pTcb->pStackEnd - PAGE_SIZE) == Violated_Page)\n+      if ((unsigned long) (pTcb->pStackEnd - PAGE_SIZE) == violated_page)\n         {\n-\t  vmStateSet (NULL, Violated_Page,\n-\t\t      PAGE_SIZE, MMU_ATTR_PROT_MSK, GUARD_PAGE_PROT);\n+\t  vmStateSet (NULL, violated_page,\n+\t\t      PAGE_SIZE, VM_STATE_MASK_VALID, VM_STATE_VALID_NOT);\n \t  exception = &storage_error;\n \n \t  switch (sig)"}, {"sha": "33f29776d111c7e1e1aeffb81289f00b70559aab", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=1e7bc06555257c73282c7ca1678a74d2cc6c7e6c", "patch": "@@ -319,8 +319,16 @@ package body Sem_Case is\n          --                       ^ illegal ^\n \n          elsif Pred_Lo < Choice_Lo and then Pred_Hi < Choice_Lo then\n-            Missing_Choice (Pred_Lo, Pred_Hi);\n-            Error := True;\n+            if Others_Present then\n+\n+               --  Current predicate set is covered by others clause.\n+\n+               null;\n+\n+            else\n+               Missing_Choice (Pred_Lo, Pred_Hi);\n+               Error := True;\n+            end if;\n \n             --  There may be several static predicate sets between the current\n             --  one and the choice. Inspect the next static predicate set.\n@@ -384,7 +392,12 @@ package body Sem_Case is\n             if Others_Present then\n                Prev_Lo := Choice_Lo;\n                Prev_Hi := Choice_Hi;\n-               Next (Pred);\n+\n+               --  Check whether  predicate set is fully covered by choice\n+\n+               if Pred_Hi = Choice_Hi then\n+                  Next (Pred);\n+               end if;\n \n             --  Choice_Lo   Choice_Hi   Pred_Hi\n             --  +===========+===========+"}, {"sha": "95ac60088ad1ee9c5504da219a38af8096deae52", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=1e7bc06555257c73282c7ca1678a74d2cc6c7e6c", "patch": "@@ -21118,6 +21118,14 @@ package body Sem_Prag is\n                   return;\n                end if;\n \n+               --  The related package has no hidden states, nothing to match.\n+               --  This case arises when the constituents are states coming\n+               --  from a private child.\n+\n+               if No (Hidden_States) then\n+                  return;\n+               end if;\n+\n                --  Inspect the hidden states of the related package looking for\n                --  a match.\n "}, {"sha": "83decce62f0f76046e092ba8006f8cfbba3e35d5", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=1e7bc06555257c73282c7ca1678a74d2cc6c7e6c", "patch": "@@ -10198,7 +10198,8 @@ package body Sem_Util is\n       function In_Protected_Function (E : Entity_Id) return Boolean;\n       --  Within a protected function, the private components of the enclosing\n       --  protected type are constants. A function nested within a (protected)\n-      --  procedure is not itself protected.\n+      --  procedure is not itself protected. Within the body of a protected\n+      --  function the current instance of the protected type is a constant.\n \n       function Is_Variable_Prefix (P : Node_Id) return Boolean;\n       --  Prefixes can involve implicit dereferences, in which case we must\n@@ -10210,12 +10211,24 @@ package body Sem_Util is\n       ---------------------------\n \n       function In_Protected_Function (E : Entity_Id) return Boolean is\n-         Prot : constant Entity_Id := Scope (E);\n+         Prot : Entity_Id;\n          S    : Entity_Id;\n \n       begin\n+         if Is_Type (E) then\n+            --  E is the current instance of a type.\n+\n+            Prot := E;\n+\n+         else\n+            --  E is an object.\n+\n+            Prot := Scope (E);\n+         end if;\n+\n          if not Is_Protected_Type (Prot) then\n             return False;\n+\n          else\n             S := Current_Scope;\n             while Present (S) and then S /= Prot loop\n@@ -10336,9 +10349,14 @@ package body Sem_Util is\n               or else  K = E_In_Out_Parameter\n               or else  K = E_Generic_In_Out_Parameter\n \n-               --  Current instance of type\n+               --  Current instance of type. If this is a protected type, check\n+               --  that we are not within the body of one of its protected\n+               --  functions.\n+\n+              or else (Is_Type (E)\n+                        and then In_Open_Scopes (E)\n+                        and then not In_Protected_Function (E))\n \n-              or else (Is_Type (E) and then In_Open_Scopes (E))\n               or else (Is_Incomplete_Or_Private_Type (E)\n                         and then In_Open_Scopes (Full_View (E)));\n          end;"}]}