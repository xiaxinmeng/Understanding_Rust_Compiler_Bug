{"sha": "07444f1d90c7b70f892063a0ae81bc43a68f6633", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc0NDRmMWQ5MGM3YjcwZjg5MjA2M2EwYWU4MWJjNDNhNjhmNjYzMw==", "commit": {"author": {"name": "Toshiyasu Morita", "email": "tm@netcom.com", "date": "1999-04-26T00:15:54Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-04-26T00:15:54Z"}, "message": "fold-const.c (make_range): Always initialize arg0 and arg1.\n\n        * fold-const.c (make_range): Always initialize arg0 and arg1.\n        (fold): Simlarly for alt0 and alt1.\n        * function.c (fixup_var_refs_insns): Initialize insn_list.\n        (instantiate_virtual_regs_1): Initialize offset.\n        * optabs.c (expand_binop): Initialize carry_in, carry_out, op0_xhigh\n        and op1_xhigh.\n        * stmt.c (expand_end_case): Initialize minval and maxval.\n\nFrom-SVN: r26632", "tree": {"sha": "7b64ed2d96959f1a08898a32af51473ac0098e4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b64ed2d96959f1a08898a32af51473ac0098e4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07444f1d90c7b70f892063a0ae81bc43a68f6633", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07444f1d90c7b70f892063a0ae81bc43a68f6633", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07444f1d90c7b70f892063a0ae81bc43a68f6633", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07444f1d90c7b70f892063a0ae81bc43a68f6633/comments", "author": null, "committer": null, "parents": [{"sha": "c1709d0c7ad2a6dbcda2bde402e2fd747fa6cfd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1709d0c7ad2a6dbcda2bde402e2fd747fa6cfd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1709d0c7ad2a6dbcda2bde402e2fd747fa6cfd9"}], "stats": {"total": 26, "additions": 18, "deletions": 8}, "files": [{"sha": "de75f8233542a506f5b541e25ca716005f8769aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07444f1d90c7b70f892063a0ae81bc43a68f6633/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07444f1d90c7b70f892063a0ae81bc43a68f6633/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07444f1d90c7b70f892063a0ae81bc43a68f6633", "patch": "@@ -1,3 +1,13 @@\n+Mon Apr 26 01:08:36 1999  Toshiyasu Morita  (tm@netcom.com)\n+\n+\t* fold-const.c (make_range): Always initialize arg0 and arg1.\n+\t(fold): Simlarly for alt0 and alt1.\n+\t* function.c (fixup_var_refs_insns): Initialize insn_list.\n+\t(instantiate_virtual_regs_1): Initialize offset.\n+\t* optabs.c (expand_binop): Initialize carry_in, carry_out, op0_xhigh\n+\tand op1_xhigh.\n+\t* stmt.c (expand_end_case): Initialize minval and maxval.\n+\n Mon Apr 26 01:02:34 1999  Nathan Sidwell  <nathan@acm.org>\n \n \t* toplev.c (report_error_function): Reorder file stack and"}, {"sha": "b7720f745a5fcada0fb2f57b471e5ebcfe7052ec", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07444f1d90c7b70f892063a0ae81bc43a68f6633/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07444f1d90c7b70f892063a0ae81bc43a68f6633/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=07444f1d90c7b70f892063a0ae81bc43a68f6633", "patch": "@@ -3109,7 +3109,7 @@ make_range (exp, pin_p, plow, phigh)\n      tree *plow, *phigh;\n {\n   enum tree_code code;\n-  tree arg0, arg1, type = NULL_TREE;\n+  tree arg0 = NULL_TREE, arg1 = NULL_TREE, type = NULL_TREE;\n   tree orig_type = NULL_TREE;\n   int in_p, n_in_p;\n   tree low, high, n_low, n_high;\n@@ -4767,7 +4767,7 @@ fold (expr)\n \t  if (TREE_CODE (arg0) == MULT_EXPR && TREE_CODE (arg1) == MULT_EXPR)\n \t    {\n \t      tree arg00, arg01, arg10, arg11;\n-\t      tree alt0, alt1, same;\n+\t      tree alt0 = NULL_TREE, alt1 = NULL_TREE, same;\n \n \t      /* (A * C) + (B * C) -> (A+B) * C.\n \t\t We are most concerned about the case where C is a constant,"}, {"sha": "d9274bf3ace5cd96eb0e7c400380f1ace78c20be", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07444f1d90c7b70f892063a0ae81bc43a68f6633/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07444f1d90c7b70f892063a0ae81bc43a68f6633/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=07444f1d90c7b70f892063a0ae81bc43a68f6633", "patch": "@@ -1827,7 +1827,7 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel, ht)\n      struct hash_table *ht;\n {\n   rtx call_dest = 0;\n-  rtx insn_list;\n+  rtx insn_list = NULL_RTX;\n \n   /* If we already know which INSNs reference VAR there's no need\n      to walk the entire instruction chain.  */\n@@ -3649,7 +3649,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n   rtx x;\n   RTX_CODE code;\n   rtx new = 0;\n-  HOST_WIDE_INT offset;\n+  HOST_WIDE_INT offset = 0;\n   rtx temp;\n   rtx seq;\n   int i, j;"}, {"sha": "00ce961743a08834564b6fffec40eeff8a5b8244", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07444f1d90c7b70f892063a0ae81bc43a68f6633/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07444f1d90c7b70f892063a0ae81bc43a68f6633/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=07444f1d90c7b70f892063a0ae81bc43a68f6633", "patch": "@@ -898,7 +898,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       rtx carry_tmp = gen_reg_rtx (word_mode);\n       optab otheroptab = binoptab == add_optab ? sub_optab : add_optab;\n       int nwords = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n-      rtx carry_in, carry_out;\n+      rtx carry_in = NULL_RTX, carry_out = NULL_RTX;\n       rtx xop0, xop1;\n \n       /* We can handle either a 1 or -1 value for the carry.  If STORE_FLAG\n@@ -1068,8 +1068,8 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       rtx op1_high = operand_subword_force (op1, high, mode);\n       rtx op1_low = operand_subword_force (op1, low, mode);\n       rtx product = 0;\n-      rtx op0_xhigh;\n-      rtx op1_xhigh;\n+      rtx op0_xhigh = NULL_RTX;\n+      rtx op1_xhigh = NULL_RTX;\n \n       /* If the target is the same as one of the inputs, don't use it.  This\n \t prevents problems with the REG_EQUAL note.  */"}, {"sha": "41bc736681d0b23206c361c8dabfd072087ab674", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07444f1d90c7b70f892063a0ae81bc43a68f6633/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07444f1d90c7b70f892063a0ae81bc43a68f6633/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=07444f1d90c7b70f892063a0ae81bc43a68f6633", "patch": "@@ -5037,7 +5037,7 @@ void\n expand_end_case (orig_index)\n      tree orig_index;\n {\n-  tree minval, maxval, range, orig_minval;\n+  tree minval = NULL_TREE, maxval = NULL_TREE, range, orig_minval;\n   rtx default_label = 0;\n   register struct case_node *n;\n   unsigned int count;"}]}