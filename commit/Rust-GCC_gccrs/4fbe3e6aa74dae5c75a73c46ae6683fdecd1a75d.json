{"sha": "4fbe3e6aa74dae5c75a73c46ae6683fdecd1a75d", "node_id": "C_kwDOANBUbNoAKDRmYmUzZTZhYTc0ZGFlNWM3NWE3M2M0NmFlNjY4M2ZkZWNkMWE3NWQ", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-08-30T06:23:51Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-08-30T09:26:24Z"}, "message": "Implement relational operators for frange with endpoints.\n\nThis is the implementation of the relational range operators for\nfrange.  These are the core operations that require specific FP domain\nknowledge.\n\ngcc/ChangeLog:\n\n\t* range-op-float.cc (finite_operand_p): New.\n\t(build_le): New.\n\t(build_lt): New.\n\t(build_ge): New.\n\t(build_gt): New.\n\t(foperator_equal::fold_range): New implementation with endpoints.\n\t(foperator_equal::op1_range): Same.\n\t(foperator_not_equal::fold_range): Same.\n\t(foperator_not_equal::op1_range): Same.\n\t(foperator_lt::fold_range): Same.\n\t(foperator_lt::op1_range): Same.\n\t(foperator_lt::op2_range): Same.\n\t(foperator_le::fold_range): Same.\n\t(foperator_le::op1_range): Same.\n\t(foperator_le::op2_range): Same.\n\t(foperator_gt::fold_range): Same.\n\t(foperator_gt::op1_range): Same.\n\t(foperator_gt::op2_range): Same.\n\t(foperator_ge::fold_range): Same.\n\t(foperator_ge::op1_range): Same.\n\t(foperator_ge::op2_range): Same.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/recip-3.c: Avoid premature optimization so test\n\thas a chance to succeed.", "tree": {"sha": "220ecc3307a028f7c960b977f5feaf66e9989a3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/220ecc3307a028f7c960b977f5feaf66e9989a3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fbe3e6aa74dae5c75a73c46ae6683fdecd1a75d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fbe3e6aa74dae5c75a73c46ae6683fdecd1a75d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fbe3e6aa74dae5c75a73c46ae6683fdecd1a75d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fbe3e6aa74dae5c75a73c46ae6683fdecd1a75d/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bb1df032cc080b751e00c0d7d86c31a630105f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bb1df032cc080b751e00c0d7d86c31a630105f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bb1df032cc080b751e00c0d7d86c31a630105f9"}], "stats": {"total": 363, "additions": 309, "deletions": 54}, "files": [{"sha": "d859309f863057b89acc645f1d754a5eee7fda13", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 304, "deletions": 54, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fbe3e6aa74dae5c75a73c46ae6683fdecd1a75d/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fbe3e6aa74dae5c75a73c46ae6683fdecd1a75d/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=4fbe3e6aa74dae5c75a73c46ae6683fdecd1a75d", "patch": "@@ -162,6 +162,14 @@ frange_set_nan (frange &r, tree type)\n   r.set (type, rv, rv);\n }\n \n+// Return TRUE if OP1 is known to be free of NANs.\n+\n+static inline bool\n+finite_operand_p (const frange &op1)\n+{\n+  return flag_finite_math_only || op1.get_nan ().no_p ();\n+}\n+\n // Return TRUE if OP1 and OP2 are known to be free of NANs.\n \n static inline bool\n@@ -240,6 +248,45 @@ default_frelop_fold_range (irange &r, tree type,\n   return true;\n }\n \n+// (X <= VAL) produces the range of [MIN, VAL].\n+\n+static void\n+build_le (frange &r, tree type, const REAL_VALUE_TYPE &val)\n+{\n+  REAL_VALUE_TYPE min;\n+  real_inf (&min, 1);\n+  r.set (type, min, val);\n+}\n+\n+// (X < VAL) produces the range of [MIN, VAL).\n+\n+static void\n+build_lt (frange &r, tree type, const REAL_VALUE_TYPE &val)\n+{\n+  // Hijack LE because we only support closed intervals.\n+  build_le (r, type, val);\n+}\n+\n+// (X >= VAL) produces the range of [VAL, MAX].\n+\n+static void\n+build_ge (frange &r, tree type, const REAL_VALUE_TYPE &val)\n+{\n+  REAL_VALUE_TYPE max;\n+  real_inf (&max, 0);\n+  r.set (type, val, max);\n+}\n+\n+// (X > VAL) produces the range of (VAL, MAX].\n+\n+static void\n+build_gt (frange &r, tree type, const REAL_VALUE_TYPE &val)\n+{\n+  // Hijack GE because we only support closed intervals.\n+  build_ge (r, type, val);\n+}\n+\n+\n class foperator_identity : public range_operator_float\n {\n   using range_operator_float::fold_range;\n@@ -270,10 +317,7 @@ class foperator_equal : public range_operator_float\n \n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind rel) const final override\n-  {\n-    return default_frelop_fold_range (r, type, op1, op2, rel, VREL_EQ);\n-  }\n+\t\t   relation_kind rel) const final override;\n   relation_kind op1_op2_relation (const irange &lhs) const final override\n   {\n     return equal_op1_op2_relation (lhs);\n@@ -289,6 +333,39 @@ class foperator_equal : public range_operator_float\n   }\n } fop_equal;\n \n+bool\n+foperator_equal::fold_range (irange &r, tree type,\n+\t\t\t     const frange &op1, const frange &op2,\n+\t\t\t     relation_kind rel) const\n+{\n+  if (frelop_early_resolve (r, type, op1, op2, rel, VREL_EQ))\n+    return true;\n+\n+  // We can be sure the values are always equal or not if both ranges\n+  // consist of a single value, and then compare them.\n+  if (op1.singleton_p () && op2.singleton_p ())\n+    {\n+      if (op1 == op2)\n+\tr = range_true (type);\n+      else\n+\tr = range_false (type);\n+    }\n+  else if (finite_operands_p (op1, op2))\n+    {\n+      // If ranges do not intersect, we know the range is not equal,\n+      // otherwise we don't know anything for sure.\n+      frange tmp = op1;\n+      tmp.intersect (op2);\n+      if (tmp.undefined_p ())\n+\tr = range_false (type);\n+      else\n+\tr = range_true_and_false (type);\n+    }\n+  else\n+    r = range_true_and_false (type);\n+  return true;\n+}\n+\n bool\n foperator_equal::op1_range (frange &r, tree type,\n \t\t\t    const irange &lhs,\n@@ -309,6 +386,14 @@ foperator_equal::op1_range (frange &r, tree type,\n       // The FALSE side of op1 == op1 implies op1 is a NAN.\n       if (rel == VREL_EQ)\n \tfrange_set_nan (r, type);\n+      // If the result is false, the only time we know anything is\n+      // if OP2 is a constant.\n+      else if (op2.singleton_p ()\n+\t       || (finite_operand_p (op2) && op2.zero_p ()))\n+\t{\n+\t  REAL_VALUE_TYPE tmp = op2.lower_bound ();\n+\t  r.set (type, tmp, tmp, VR_ANTI_RANGE);\n+\t}\n       break;\n \n     default:\n@@ -324,10 +409,7 @@ class foperator_not_equal : public range_operator_float\n \n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind rel) const final override\n-  {\n-    return default_frelop_fold_range (r, type, op1, op2, rel, VREL_NE);\n-  }\n+\t\t   relation_kind rel) const final override;\n   relation_kind op1_op2_relation (const irange &lhs) const final override\n   {\n     return not_equal_op1_op2_relation (lhs);\n@@ -337,6 +419,39 @@ class foperator_not_equal : public range_operator_float\n \t\t  relation_kind rel) const final override;\n } fop_not_equal;\n \n+bool\n+foperator_not_equal::fold_range (irange &r, tree type,\n+\t\t\t\t const frange &op1, const frange &op2,\n+\t\t\t\t relation_kind rel) const\n+{\n+  if (frelop_early_resolve (r, type, op1, op2, rel, VREL_NE))\n+    return true;\n+\n+  // We can be sure the values are always equal or not if both ranges\n+  // consist of a single value, and then compare them.\n+  if (op1.singleton_p () && op2.singleton_p ())\n+    {\n+      if (op1 != op2)\n+\tr = range_true (type);\n+      else\n+\tr = range_false (type);\n+    }\n+  else if (finite_operands_p (op1, op2))\n+    {\n+      // If ranges do not intersect, we know the range is not equal,\n+      // otherwise we don't know anything for sure.\n+      frange tmp = op1;\n+      tmp.intersect (op2);\n+      if (tmp.undefined_p ())\n+\tr = range_true (type);\n+      else\n+\tr = range_true_and_false (type);\n+    }\n+  else\n+    r = range_true_and_false (type);\n+  return true;\n+}\n+\n bool\n foperator_not_equal::op1_range (frange &r, tree type,\n \t\t\t\tconst irange &lhs,\n@@ -346,11 +461,23 @@ foperator_not_equal::op1_range (frange &r, tree type,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      r.set_varying (type);\n+      // If the result is true, the only time we know anything is if\n+      // OP2 is a constant.\n+      if (op2.singleton_p ())\n+\t{\n+\t  // This is correct even if op1 is NAN, because the following\n+\t  // range would be ~[tmp, tmp] with the NAN property set to\n+\t  // maybe (VARYING).\n+\t  REAL_VALUE_TYPE tmp = op2.lower_bound ();\n+\t  r.set (type, tmp, tmp, VR_ANTI_RANGE);\n+\t}\n+      else\n+\tr.set_varying (type);\n       break;\n \n     case BRS_FALSE:\n-      r.set_varying (type);\n+      // If it's false, the result is the same as OP2.\n+      r = op2;\n       // The FALSE side of op1 != op2 implies op1 is !NAN.\n       r.set_nan (fp_prop::NO);\n       break;\n@@ -369,10 +496,7 @@ class foperator_lt : public range_operator_float\n \n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind rel) const final override\n-  {\n-    return default_frelop_fold_range (r, type, op1, op2, rel, VREL_LT);\n-  }\n+\t\t   relation_kind rel) const final override;\n   relation_kind op1_op2_relation (const irange &lhs) const final override\n   {\n     return lt_op1_op2_relation (lhs);\n@@ -385,6 +509,31 @@ class foperator_lt : public range_operator_float\n \t\t  relation_kind rel) const final override;\n } fop_lt;\n \n+bool\n+foperator_lt::fold_range (irange &r, tree type,\n+\t\t\t  const frange &op1, const frange &op2,\n+\t\t\t  relation_kind rel) const\n+{\n+  if (frelop_early_resolve (r, type, op1, op2, rel, VREL_LT))\n+    return true;\n+\n+  if (finite_operands_p (op1, op2))\n+    {\n+      if (real_less (&op1.upper_bound (), &op2.lower_bound ()))\n+\tr = range_true (type);\n+      else if (finite_operands_p (op1, op2)\n+\t       && !real_less (&op1.lower_bound (), &op2.upper_bound ()))\n+\tr = range_false (type);\n+      else\n+\tr = range_true_and_false (type);\n+    }\n+  else if (op1.get_nan ().yes_p () || op2.get_nan ().yes_p ())\n+    r = range_false (type);\n+  else\n+    r = range_true_and_false (type);\n+  return true;\n+}\n+\n bool\n foperator_lt::op1_range (frange &r,\n \t\t\t tree type,\n@@ -395,15 +544,14 @@ foperator_lt::op1_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      r.set_varying (type);\n-      // The TRUE side of op1 < op2 implies op1 is !NAN and !INF.\n+      build_lt (r, type, op2.upper_bound ());\n       r.set_nan (fp_prop::NO);\n       // x < y implies x is not +INF.\n       frange_drop_inf (r, type);\n       break;\n \n     case BRS_FALSE:\n-      r.set_varying (type);\n+      build_ge (r, type, op2.lower_bound ());\n       break;\n \n     default:\n@@ -422,15 +570,14 @@ foperator_lt::op2_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      r.set_varying (type);\n-      // The TRUE side of op1 < op2 implies op2 is !NAN and !NINF.\n+      build_gt (r, type, op1.lower_bound ());\n       r.set_nan (fp_prop::NO);\n       // x < y implies y is not -INF.\n       frange_drop_ninf (r, type);\n       break;\n \n     case BRS_FALSE:\n-      r.set_varying (type);\n+      build_le (r, type, op1.upper_bound ());\n       break;\n \n     default:\n@@ -447,10 +594,7 @@ class foperator_le : public range_operator_float\n \n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind rel) const final override\n-  {\n-    return default_frelop_fold_range (r, type, op1, op2, rel, VREL_LE);\n-  }\n+\t\t   relation_kind rel) const final override;\n   relation_kind op1_op2_relation (const irange &lhs) const final override\n   {\n     return le_op1_op2_relation (lhs);\n@@ -460,29 +604,74 @@ class foperator_le : public range_operator_float\n \t\t  relation_kind rel) const final override;\n   bool op2_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op1,\n-\t\t  relation_kind rel) const final override\n-  {\n-    return op1_range (r, type, lhs, op1, rel);\n-  }\n+\t\t  relation_kind rel) const final override;\n } fop_le;\n \n+bool\n+foperator_le::fold_range (irange &r, tree type,\n+\t\t\t  const frange &op1, const frange &op2,\n+\t\t\t  relation_kind rel) const\n+{\n+  if (frelop_early_resolve (r, type, op1, op2, rel, VREL_LE))\n+    return true;\n+\n+  if (finite_operands_p (op1, op2))\n+    {\n+      if (real_compare (LE_EXPR, &op1.upper_bound (), &op2.lower_bound ()))\n+\tr = range_true (type);\n+      else if (finite_operands_p (op1, op2)\n+\t       && !real_compare (LE_EXPR, &op1.lower_bound (), &op2.upper_bound ()))\n+\tr = range_false (type);\n+      else\n+\tr = range_true_and_false (type);\n+    }\n+  else if (op1.get_nan ().yes_p () || op2.get_nan ().yes_p ())\n+    r = range_false (type);\n+  else\n+    r = range_true_and_false (type);\n+  return true;\n+}\n+\n bool\n foperator_le::op1_range (frange &r,\n \t\t\t tree type,\n \t\t\t const irange &lhs,\n-\t\t\t const frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t const frange &op2,\n \t\t\t relation_kind) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      r.set_varying (type);\n-      // The TRUE side of op1 <= op2 implies op1 is !NAN.\n+      build_le (r, type, op2.upper_bound ());\n       r.set_nan (fp_prop::NO);\n       break;\n \n     case BRS_FALSE:\n-      r.set_varying (type);\n+      build_gt (r, type, op2.lower_bound ());\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return true;\n+}\n+\n+bool\n+foperator_le::op2_range (frange &r,\n+\t\t\t tree type,\n+\t\t\t const irange &lhs,\n+\t\t\t const frange &op1,\n+\t\t\t relation_kind) const\n+{\n+  switch (get_bool_state (r, lhs, type))\n+    {\n+    case BRS_TRUE:\n+      build_ge (r, type, op1.lower_bound ());\n+      r.set_nan (fp_prop::NO);\n+      break;\n+\n+    case BRS_FALSE:\n+      build_lt (r, type, op1.upper_bound ());\n       break;\n \n     default:\n@@ -499,10 +688,7 @@ class foperator_gt : public range_operator_float\n \n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind rel) const final override\n-  {\n-    return default_frelop_fold_range (r, type, op1, op2, rel, VREL_GT);\n-  }\n+\t\t   relation_kind rel) const final override;\n   relation_kind op1_op2_relation (const irange &lhs) const final override\n   {\n     return gt_op1_op2_relation (lhs);\n@@ -515,6 +701,31 @@ class foperator_gt : public range_operator_float\n \t\t  relation_kind rel) const final override;\n } fop_gt;\n \n+bool\n+foperator_gt::fold_range (irange &r, tree type,\n+\t\t\t  const frange &op1, const frange &op2,\n+\t\t\t  relation_kind rel) const\n+{\n+  if (frelop_early_resolve (r, type, op1, op2, rel, VREL_GT))\n+    return true;\n+\n+  if (finite_operands_p (op1, op2))\n+    {\n+      if (real_compare (GT_EXPR, &op1.lower_bound (), &op2.upper_bound ()))\n+\tr = range_true (type);\n+      else if (finite_operands_p (op1, op2)\n+\t       && !real_compare (GT_EXPR, &op1.upper_bound (), &op2.lower_bound ()))\n+\tr = range_false (type);\n+      else\n+\tr = range_true_and_false (type);\n+    }\n+  else if (op1.get_nan ().yes_p () || op2.get_nan ().yes_p ())\n+    r = range_false (type);\n+  else\n+    r = range_true_and_false (type);\n+  return true;\n+}\n+\n bool\n foperator_gt::op1_range (frange &r,\n \t\t\t tree type,\n@@ -525,15 +736,14 @@ foperator_gt::op1_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      r.set_varying (type);\n-      // The TRUE side of op1 > op2 implies op1 is !NAN and !NINF.\n+      build_gt (r, type, op2.lower_bound ());\n       r.set_nan (fp_prop::NO);\n       // x > y implies x is not -INF.\n       frange_drop_ninf (r, type);\n       break;\n \n     case BRS_FALSE:\n-      r.set_varying (type);\n+      build_le (r, type, op2.upper_bound ());\n       break;\n \n     default:\n@@ -552,15 +762,14 @@ foperator_gt::op2_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      r.set_varying (type);\n-      // The TRUE side of op1 > op2 implies op2 is !NAN and !INF.\n+      build_lt (r, type, op1.upper_bound ());\n       r.set_nan (fp_prop::NO);\n       // x > y implies y is not +INF.\n       frange_drop_inf (r, type);\n       break;\n \n     case BRS_FALSE:\n-      r.set_varying (type);\n+      build_ge (r, type, op1.lower_bound ());\n       break;\n \n     default:\n@@ -577,10 +786,7 @@ class foperator_ge : public range_operator_float\n \n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind rel) const final override\n-  {\n-    return default_frelop_fold_range (r, type, op1, op2, rel, VREL_GE);\n-  }\n+\t\t   relation_kind rel) const final override;\n   relation_kind op1_op2_relation (const irange &lhs) const final override\n   {\n     return ge_op1_op2_relation (lhs);\n@@ -590,29 +796,73 @@ class foperator_ge : public range_operator_float\n \t\t  relation_kind rel) const final override;\n   bool op2_range (frange &r, tree type,\n \t\t  const irange &lhs, const frange &op1,\n-\t\t  relation_kind rel) const final override\n-  {\n-    return op1_range (r, type, lhs, op1, rel);\n-  }\n+\t\t  relation_kind rel) const final override;\n } fop_ge;\n \n+bool\n+foperator_ge::fold_range (irange &r, tree type,\n+\t\t\t  const frange &op1, const frange &op2,\n+\t\t\t  relation_kind rel) const\n+{\n+  if (frelop_early_resolve (r, type, op1, op2, rel, VREL_GE))\n+    return true;\n+\n+  if (finite_operands_p (op1, op2))\n+    {\n+      if (real_compare (GE_EXPR, &op1.lower_bound (), &op2.upper_bound ()))\n+\tr = range_true (type);\n+      else if (finite_operands_p (op1, op2)\n+\t       && !real_compare (GE_EXPR, &op1.upper_bound (), &op2.lower_bound ()))\n+\tr = range_false (type);\n+      else\n+\tr = range_true_and_false (type);\n+    }\n+  else if (op1.get_nan ().yes_p () || op2.get_nan ().yes_p ())\n+    r = range_false (type);\n+  else\n+    r = range_true_and_false (type);\n+  return true;\n+}\n+\n bool\n foperator_ge::op1_range (frange &r,\n \t\t\t tree type,\n \t\t\t const irange &lhs,\n-\t\t\t const frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t const frange &op2,\n \t\t\t relation_kind) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      r.set_varying (type);\n-      // The TRUE side of op1 >= op2 implies op1 is !NAN.\n+      build_ge (r, type, op2.lower_bound ());\n       r.set_nan (fp_prop::NO);\n       break;\n \n     case BRS_FALSE:\n-      r.set_varying (type);\n+      build_lt (r, type, op2.upper_bound ());\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return true;\n+}\n+\n+bool\n+foperator_ge::op2_range (frange &r, tree type,\n+\t\t\t const irange &lhs,\n+\t\t\t const frange &op1,\n+\t\t\t relation_kind) const\n+{\n+  switch (get_bool_state (r, lhs, type))\n+    {\n+    case BRS_FALSE:\n+      build_gt (r, type, op1.lower_bound ());\n+      break;\n+\n+    case BRS_TRUE:\n+      build_le (r, type, op1.upper_bound ());\n+      r.set_nan (fp_prop::NO);\n       break;\n \n     default:"}, {"sha": "036f32a9c3383da4d4900c1aa7a01458d3e28404", "filename": "gcc/testsuite/gcc.dg/tree-ssa/recip-3.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fbe3e6aa74dae5c75a73c46ae6683fdecd1a75d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fbe3e6aa74dae5c75a73c46ae6683fdecd1a75d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-3.c?ref=4fbe3e6aa74dae5c75a73c46ae6683fdecd1a75d", "patch": "@@ -1,6 +1,11 @@\n /* { dg-do compile } */\n /* { dg-options \"-O1 -fno-trapping-math -funsafe-math-optimizations -fdump-tree-recip\" } */\n \n+/* The recip pass has a threshold of 3 reciprocal operations before it attempts\n+   to optimize a sequence.  With a FP enabled ranger, we eliminate one of them\n+   earlier, causing the pass to skip this optimization.  */\n+/* { dg-additional-options \"-fno-thread-jumps -fno-tree-dominator-opts\" } */\n+\n double F[5] = { 0.0, 0.0 }, e;\n \n /* In this case the optimization is interesting.  */"}]}