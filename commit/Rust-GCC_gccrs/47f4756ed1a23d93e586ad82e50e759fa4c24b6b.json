{"sha": "47f4756ed1a23d93e586ad82e50e759fa4c24b6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdmNDc1NmVkMWEyM2Q5M2U1ODZhZDgyZTUwZTc1OWZhNGMyNGI2Yg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2014-12-02T10:12:27Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2014-12-02T10:12:27Z"}, "message": "re PR ipa/63814 (g++.dg/ipa/pr61160-1.C fails with -m32 -fPIC)\n\n2014-12-02  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/63814\n\t* ipa-cp.c (same_node_or_its_all_contexts_clone_p): New function.\n\t(cgraph_edge_brings_value_p): New parameter dest, use\n\tsame_node_or_its_all_contexts_clone_p and check availability.\n\t(cgraph_edge_brings_value_p): Likewise.\n\t(get_info_about_necessary_edges): New parameter dest, pass it to\n\tcgraph_edge_brings_value_p.  Update caller.\n\t(gather_edges_for_value): Likewise.\n\t(perhaps_add_new_callers): Use cgraph_edge_brings_value_p to check\n\tboth the destination and availability.\n\nFrom-SVN: r218265", "tree": {"sha": "72ac8b75d1a23f45e3f88b78b6ade9d43c45254a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72ac8b75d1a23f45e3f88b78b6ade9d43c45254a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47f4756ed1a23d93e586ad82e50e759fa4c24b6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47f4756ed1a23d93e586ad82e50e759fa4c24b6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47f4756ed1a23d93e586ad82e50e759fa4c24b6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47f4756ed1a23d93e586ad82e50e759fa4c24b6b/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c271ca677e13442bf7a660deee9a4030107c87e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c271ca677e13442bf7a660deee9a4030107c87e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c271ca677e13442bf7a660deee9a4030107c87e0"}], "stats": {"total": 108, "additions": 65, "deletions": 43}, "files": [{"sha": "91bde4ffa61ab21e620f8b969ada7cd327967ac5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47f4756ed1a23d93e586ad82e50e759fa4c24b6b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47f4756ed1a23d93e586ad82e50e759fa4c24b6b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47f4756ed1a23d93e586ad82e50e759fa4c24b6b", "patch": "@@ -1,3 +1,16 @@\n+2014-12-02  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/63814\n+\t* ipa-cp.c (same_node_or_its_all_contexts_clone_p): New function.\n+\t(cgraph_edge_brings_value_p): New parameter dest, use\n+\tsame_node_or_its_all_contexts_clone_p and check availability.\n+\t(cgraph_edge_brings_value_p): Likewise.\n+\t(get_info_about_necessary_edges): New parameter dest, pass it to\n+\tcgraph_edge_brings_value_p.  Update caller.\n+\t(gather_edges_for_value): Likewise.\n+\t(perhaps_add_new_callers): Use cgraph_edge_brings_value_p to check\n+\tboth the destination and availability.\n+\n 2014-12-02  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/64113"}, {"sha": "408626511acc7d855a235846ace744cbb930568c", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 52, "deletions": 43, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47f4756ed1a23d93e586ad82e50e759fa4c24b6b/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47f4756ed1a23d93e586ad82e50e759fa4c24b6b/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=47f4756ed1a23d93e586ad82e50e759fa4c24b6b", "patch": "@@ -2779,17 +2779,31 @@ get_clone_agg_value (struct cgraph_node *node, HOST_WIDE_INT offset,\n   return NULL_TREE;\n }\n \n-/* Return true if edge CS does bring about the value described by SRC.  */\n+/* Return true is NODE is DEST or its clone for all contexts.  */\n \n static bool\n-cgraph_edge_brings_value_p (struct cgraph_edge *cs,\n-\t\t\t    ipcp_value_source<tree> *src)\n+same_node_or_its_all_contexts_clone_p (cgraph_node *node, cgraph_node *dest)\n+{\n+  if (node == dest)\n+    return true;\n+\n+  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  return info->is_all_contexts_clone && info->ipcp_orig_node == dest;\n+}\n+\n+/* Return true if edge CS does bring about the value described by SRC to node\n+   DEST or its clone for all contexts.  */\n+\n+static bool\n+cgraph_edge_brings_value_p (cgraph_edge *cs, ipcp_value_source<tree> *src,\n+\t\t\t    cgraph_node *dest)\n {\n   struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n-  cgraph_node *real_dest = cs->callee->function_symbol ();\n-  struct ipa_node_params *dst_info = IPA_NODE_REF (real_dest);\n+  enum availability availability;\n+  cgraph_node *real_dest = cs->callee->function_symbol (&availability);\n \n-  if ((dst_info->ipcp_orig_node && !dst_info->is_all_contexts_clone)\n+  if (!same_node_or_its_all_contexts_clone_p (real_dest, dest)\n+      || availability <= AVAIL_INTERPOSABLE\n       || caller_info->node_dead)\n     return false;\n   if (!src->val)\n@@ -2828,18 +2842,18 @@ cgraph_edge_brings_value_p (struct cgraph_edge *cs,\n     }\n }\n \n-/* Return true if edge CS does bring about the value described by SRC.  */\n+/* Return true if edge CS does bring about the value described by SRC to node\n+   DEST or its clone for all contexts.  */\n \n static bool\n-cgraph_edge_brings_value_p (struct cgraph_edge *cs,\n-\t\t\t    ipcp_value_source<ipa_polymorphic_call_context>\n-\t\t\t    *src)\n+cgraph_edge_brings_value_p (cgraph_edge *cs,\n+\t\t\t    ipcp_value_source<ipa_polymorphic_call_context> *src,\n+\t\t\t    cgraph_node *dest)\n {\n   struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n   cgraph_node *real_dest = cs->callee->function_symbol ();\n-  struct ipa_node_params *dst_info = IPA_NODE_REF (real_dest);\n \n-  if ((dst_info->ipcp_orig_node && !dst_info->is_all_contexts_clone)\n+  if (!same_node_or_its_all_contexts_clone_p (real_dest, dest)\n       || caller_info->node_dead)\n     return false;\n   if (!src->val)\n@@ -2865,13 +2879,14 @@ get_next_cgraph_edge_clone (struct cgraph_edge *cs)\n   return next_edge_clone[cs->uid];\n }\n \n-/* Given VAL, iterate over all its sources and if they still hold, add their\n-   edge frequency and their number into *FREQUENCY and *CALLER_COUNT\n-   respectively.  */\n+/* Given VAL that is intended for DEST, iterate over all its sources and if\n+   they still hold, add their edge frequency and their number into *FREQUENCY\n+   and *CALLER_COUNT respectively.  */\n \n template <typename valtype>\n static bool\n-get_info_about_necessary_edges (ipcp_value<valtype> *val, int *freq_sum,\n+get_info_about_necessary_edges (ipcp_value<valtype> *val, cgraph_node *dest,\n+\t\t\t\tint *freq_sum,\n \t\t\t\tgcov_type *count_sum, int *caller_count)\n {\n   ipcp_value_source<valtype> *src;\n@@ -2884,7 +2899,7 @@ get_info_about_necessary_edges (ipcp_value<valtype> *val, int *freq_sum,\n       struct cgraph_edge *cs = src->cs;\n       while (cs)\n \t{\n-\t  if (cgraph_edge_brings_value_p (cs, src))\n+\t  if (cgraph_edge_brings_value_p (cs, src, dest))\n \t    {\n \t      count++;\n \t      freq += cs->frequency;\n@@ -2901,12 +2916,13 @@ get_info_about_necessary_edges (ipcp_value<valtype> *val, int *freq_sum,\n   return hot;\n }\n \n-/* Return a vector of incoming edges that do bring value VAL.  It is assumed\n-   their number is known and equal to CALLER_COUNT.  */\n+/* Return a vector of incoming edges that do bring value VAL to node DEST.  It\n+   is assumed their number is known and equal to CALLER_COUNT.  */\n \n template <typename valtype>\n static vec<cgraph_edge *>\n-gather_edges_for_value (ipcp_value<valtype> *val, int caller_count)\n+gather_edges_for_value (ipcp_value<valtype> *val, cgraph_node *dest,\n+\t\t\tint caller_count)\n {\n   ipcp_value_source<valtype> *src;\n   vec<cgraph_edge *> ret;\n@@ -2917,7 +2933,7 @@ gather_edges_for_value (ipcp_value<valtype> *val, int caller_count)\n       struct cgraph_edge *cs = src->cs;\n       while (cs)\n \t{\n-\t  if (cgraph_edge_brings_value_p (cs, src))\n+\t  if (cgraph_edge_brings_value_p (cs, src, dest))\n \t    ret.quick_push (cs);\n \t  cs = get_next_cgraph_edge_clone (cs);\n \t}\n@@ -3778,27 +3794,20 @@ perhaps_add_new_callers (cgraph_node *node, ipcp_value<valtype> *val)\n       struct cgraph_edge *cs = src->cs;\n       while (cs)\n \t{\n-\t  enum availability availability;\n-\t  struct cgraph_node *dst = cs->callee->function_symbol (&availability);\n-\t  if ((dst == node || IPA_NODE_REF (dst)->is_all_contexts_clone)\n-\t      && availability > AVAIL_INTERPOSABLE\n-\t      && cgraph_edge_brings_value_p (cs, src))\n+\t  if (cgraph_edge_brings_value_p (cs, src, node)\n+\t      && cgraph_edge_brings_all_scalars_for_node (cs, val->spec_node)\n+\t      && cgraph_edge_brings_all_agg_vals_for_node (cs, val->spec_node))\n \t    {\n-\t      if (cgraph_edge_brings_all_scalars_for_node (cs, val->spec_node)\n-\t\t  && cgraph_edge_brings_all_agg_vals_for_node (cs,\n-\t\t\t\t\t\t\t       val->spec_node))\n-\t\t{\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \" - adding an extra caller %s/%i\"\n-\t\t\t     \" of %s/%i\\n\",\n-\t\t\t     xstrdup (cs->caller->name ()),\n-\t\t\t     cs->caller->order,\n-\t\t\t     xstrdup (val->spec_node->name ()),\n-\t\t\t     val->spec_node->order);\n-\n-\t\t  cs->redirect_callee (val->spec_node);\n-\t\t  redirected_sum += cs->count;\n-\t\t}\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \" - adding an extra caller %s/%i\"\n+\t\t\t \" of %s/%i\\n\",\n+\t\t\t xstrdup (cs->caller->name ()),\n+\t\t\t cs->caller->order,\n+\t\t\t xstrdup (val->spec_node->name ()),\n+\t\t\t val->spec_node->order);\n+\n+\t      cs->redirect_callee (val->spec_node);\n+\t      redirected_sum += cs->count;\n \t    }\n \t  cs = get_next_cgraph_edge_clone (cs);\n \t}\n@@ -3923,7 +3932,7 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n \t\t val->local_size_cost + overall_size);\n       return false;\n     }\n-  else if (!get_info_about_necessary_edges (val, &freq_sum, &count_sum,\n+  else if (!get_info_about_necessary_edges (val, node, &freq_sum, &count_sum,\n \t\t\t\t\t    &caller_count))\n     return false;\n \n@@ -3953,7 +3962,7 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n     fprintf (dump_file, \"  Creating a specialized node of %s/%i.\\n\",\n \t     node->name (), node->order);\n \n-  callers = gather_edges_for_value (val, caller_count);\n+  callers = gather_edges_for_value (val, node, caller_count);\n   if (offset == -1)\n     modify_known_vectors_with_val (&known_csts, &known_contexts, val, index);\n   else"}]}