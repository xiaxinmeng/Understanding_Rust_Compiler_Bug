{"sha": "35fc243fca06b1ce845a605cd1d6fd199a857e8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVmYzI0M2ZjYTA2YjFjZTg0NWE2MDVjZDFkNmZkMTk5YTg1N2U4ZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-14T17:30:00Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-15T15:41:54Z"}, "message": "Add c++tools\n\nPart of our module implementation adds a sample mapper server, the\nguts of which are used by the default in-process mapping of cc1plus.\nRather than add another executable to gcc/cp/, this creates a new\nc++tools directory where this and any other c++ tools might live.\nThe toplevel changes are a subsequent commit, because ... git.\n\nc++tools/ChangeLog:\n\n\t* Makefile.in: New.\n\t* config.h.in: New.\n\t* configure: New.\n\t* configure.ac: New.\n\t* resolver.cc: New.\n\t* resolver.h: New.\n\t* server.cc: New.", "tree": {"sha": "b6f20f124b37e5b2c94c22ddaf660277c6e6d149", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6f20f124b37e5b2c94c22ddaf660277c6e6d149"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35fc243fca06b1ce845a605cd1d6fd199a857e8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35fc243fca06b1ce845a605cd1d6fd199a857e8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35fc243fca06b1ce845a605cd1d6fd199a857e8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35fc243fca06b1ce845a605cd1d6fd199a857e8e/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e831ad4dab9d693885a5654d49e8f219e53eaee1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e831ad4dab9d693885a5654d49e8f219e53eaee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e831ad4dab9d693885a5654d49e8f219e53eaee1"}], "stats": {"total": 6571, "additions": 6571, "deletions": 0}, "files": [{"sha": "49b7fae1526f4270c65ec8f9c24fbe5184eba78a", "filename": "c++tools/Makefile.in", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fc243fca06b1ce845a605cd1d6fd199a857e8e/c%2B%2Btools%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fc243fca06b1ce845a605cd1d6fd199a857e8e/c%2B%2Btools%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/c%2B%2Btools%2FMakefile.in?ref=35fc243fca06b1ce845a605cd1d6fd199a857e8e", "patch": "@@ -0,0 +1,125 @@\n+# Makefile for c++tools\n+#   Copyright 2020 Free Software Foundation, Inc.\n+#\n+# This file is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+srcdir := @srcdir@\n+prefix := @prefix@\n+bindir := @bindir@\n+libexecdir := @libexecdir@\n+target_noncanonical := @target_noncanonical@\n+version := $(shell cat $(srcdir)/../gcc/BASE-VER)\n+libexecsubdir := $(libexecdir)/gcc/$(target_noncanonical)/$(version)\n+INSTALL := @INSTALL@\n+AUTOCONF := @AUTOCONF@\n+AUTOHEADER := @AUTOHEADER@\n+CXX := @CXX@\n+CXXFLAGS := @CXXFLAGS@\n+CXXOPTS := $(CXXFLAGS) -fno-exceptions -fno-rtti\n+EXEEXT := @EXEEXT@\n+LIBIBERTY := ../libiberty/libiberty.a\n+VERSION.O := ../gcc/version.o\n+\n+all::\n+\n+mostlyclean::\n+\trm -f $(MAPPER.O)\n+\n+clean::\n+\trm -f c++-mapper-server$(exeext)\n+\n+distclean::\n+\trm -f config.log config.status config.h\n+\n+maintainer-clean::\n+\n+install::\n+\n+check:\n+installcheck:\n+dvi:\n+pdf:\n+html:\n+info:\n+install-info:\n+install-pdf:\n+install-man:\n+install-html:\n+\n+vpath %.cc $(srcdir)\n+vpath %.in $(srcdir)\n+.SUFFIXES:\n+.SUFFIXES: .cc .o\n+\n+# Per-source & per-directory compile flags (warning: recursive)\n+SRC_CXXFLAGS = $(CXXFLAGS$(patsubst $(srcdir)%,%,$1)) \\\n+\t$(if $(filter-out $(srcdir)/,$1),\\\n+\t  $(call $0,$(dir $(patsubst %/,%,$1))))\n+\n+%.o: %.cc\n+\t$(CXX) $(strip $(CXXOPTS) $(call SRC_CXXFLAGS,$<) $(CXXINC)) \\\n+\t  -MMD -MP -MF ${@:.o=.d} -c -o $@ $<\n+\n+ifeq (@CXX_AUX_TOOLS@,yes)\n+\n+all::g++-mapper-server$(exeext)\n+\n+MAPPER.O := server.o resolver.o\n+CODYLIB = ../libcody/libcody.a\n+CXXINC += -I$(srcdir)/../libcody -I$(srcdir)/../include -I$(srcdir)/../gcc -I.\n+g++-mapper-server$(exeext): $(MAPPER.O) $(CODYLIB)\n+\t+$(CXX) $(LDFLAGS) -o $@ $^ $(VERSION.O) $(LIBIBERTY)\n+\n+# copy to gcc dir so tests there can run\n+all::../gcc/g++-mapper-server$(exeext)\n+\n+../gcc/g++-mapper-server$(exeext): g++-mapper-server$(exeext)\n+\t$(INSTALL) -p $< $@\n+\n+install::\n+\t$(INSTALL) -p g++-mapper-server$(exeext) $(DESTDIR)$(libexecsubdir)\n+\n+endif\n+\n+ifneq ($(MAINTAINER),)\n+override MAINTAINER += $1\n+endif\n+ifeq (@MAINTAINER@,yes)\n+MAINTAINER = $2\n+else\n+MAINTAINER = \\# --enable-maintainer-mode to rebuild $1, or make MAINTAINER=touch\n+endif\n+\n+all:: Makefile\n+\n+Makefile: $(srcdir)/Makefile.in config.status\n+\t$(SHELL) ./config.status Makefile\n+\n+$(srcdir)/configure: $(srcdir)/configure.ac\n+\t$(call MAINTAINER,$@,cd $(@D) && $(AUTOCONF) -W all,error)\n+\n+$(srcdir)/config.h.in: $(srcdir)/configure.ac\n+\t$(call MAINTAINER,$@,cd $(@D) && $(AUTOHEADER) -f -W all,error)\n+\n+config.h: config.status config.h.in\n+\t./$< --header=$@\n+\ttouch $@\n+\n+config.status: $(srcdir)/configure $(srcdir)/config.h.in\n+\tif test -x $@; then ./$@ -recheck; else $< @configure_args@; fi\n+\n+.PHONY: all check clean distclean maintainer-clean\n+\n+-include $(MAPPER.O:.o=.d)"}, {"sha": "747aaf40b1253f7eaf006bdb771315624fa57f18", "filename": "c++tools/config.h.in", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fc243fca06b1ce845a605cd1d6fd199a857e8e/c%2B%2Btools%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fc243fca06b1ce845a605cd1d6fd199a857e8e/c%2B%2Btools%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/c%2B%2Btools%2Fconfig.h.in?ref=35fc243fca06b1ce845a605cd1d6fd199a857e8e", "patch": "@@ -0,0 +1,43 @@\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define if accept4 provided. */\n+#undef HAVE_ACCEPT4\n+\n+/* Define if AF_INET6 supported. */\n+#undef HAVE_AF_INET6\n+\n+/* Define if AF_UNIX supported. */\n+#undef HAVE_AF_UNIX\n+\n+/* Define if epoll_create, epoll_ctl, epoll_pwait provided. */\n+#undef HAVE_EPOLL\n+\n+/* Define if inet_ntop provided. */\n+#undef HAVE_INET_NTOP\n+\n+/* Define if pselect provided. */\n+#undef HAVE_PSELECT\n+\n+/* Define if select provided. */\n+#undef HAVE_SELECT\n+\n+/* Define if O_CLOEXEC supported by fcntl. */\n+#undef HOST_HAS_O_CLOEXEC\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#undef PACKAGE_BUGREPORT\n+\n+/* Define to the full name of this package. */\n+#undef PACKAGE_NAME\n+\n+/* Define to the full name and version of this package. */\n+#undef PACKAGE_STRING\n+\n+/* Define to the one symbol short name of this package. */\n+#undef PACKAGE_TARNAME\n+\n+/* Define to the home page for this package. */\n+#undef PACKAGE_URL\n+\n+/* Define to the version of this package. */\n+#undef PACKAGE_VERSION"}, {"sha": "82975120393bea2fe0773340c1dccce2afec0ee2", "filename": "c++tools/configure", "status": "added", "additions": 4840, "deletions": 0, "changes": 4840, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fc243fca06b1ce845a605cd1d6fd199a857e8e/c%2B%2Btools%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fc243fca06b1ce845a605cd1d6fd199a857e8e/c%2B%2Btools%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/c%2B%2Btools%2Fconfigure?ref=35fc243fca06b1ce845a605cd1d6fd199a857e8e"}, {"sha": "75773650be7a502c94936567fb6e123ca16fa022", "filename": "c++tools/configure.ac", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fc243fca06b1ce845a605cd1d6fd199a857e8e/c%2B%2Btools%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fc243fca06b1ce845a605cd1d6fd199a857e8e/c%2B%2Btools%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/c%2B%2Btools%2Fconfigure.ac?ref=35fc243fca06b1ce845a605cd1d6fd199a857e8e", "patch": "@@ -0,0 +1,210 @@\n+# Configure script for c++tools\n+#   Copyright (C) 2020 Free Software Foundation, Inc.\n+#   Written by Nathan Sidwell <nathan@acm.org> while at FaceBook\n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# C++ has grown a C++20 mapper server.  This may be used to provide\n+# and/or learn and/or build required modules.  This sample server\n+# shows how the protocol introduced by wg21.link/p1184 may be used.\n+# By default g++ uses an in-process mapper.\n+\n+sinclude(../config/acx.m4)\n+\n+AC_INIT(c++tools)\n+\n+AC_CONFIG_SRCDIR([server.cc])\n+\n+# Determine the noncanonical names used for directories.\n+ACX_NONCANONICAL_TARGET\n+\n+AC_CANONICAL_SYSTEM\n+AC_PROG_INSTALL\n+\n+AC_PROG_CXX\n+MISSING=`cd $ac_aux_dir && ${PWDCMD-pwd}`/missing\n+AC_CHECK_PROGS([AUTOCONF], [autoconf], [$MISSING autoconf])\n+AC_CHECK_PROGS([AUTOHEADER], [autoheader], [$MISSING autoheader])\n+\n+dnl Enabled by default\n+AC_MSG_CHECKING([whether to build C++ tools])\n+  AC_ARG_ENABLE(c++-tools, \n+    [AS_HELP_STRING([--enable-c++-tools],\n+\t\t    [build auxiliary c++ tools])],\n+      cxx_aux_tools=$enableval,\n+      cxx_aux_tools=yes)\n+\n+AC_MSG_RESULT($cxx_aux_tools)\n+CXX_AUX_TOOLS=\"$cxx_aux_tools\"\n+AC_SUBST(CXX_AUX_TOOLS)\n+\n+AC_ARG_ENABLE([maintainer-mode],\n+AS_HELP_STRING([--enable-maintainer-mode],\n+[enable maintainer mode.  Add rules to rebuild configurey bits]),,\n+[enable_maintainer_mode=no])\n+case \"$enable_maintainer_mode\" in\n+  (\"yes\") maintainer_mode=yes ;;\n+  (\"no\") maintainer=no ;;\n+  (*) AC_MSG_ERROR([unknown maintainer mode $enable_maintainer_mode]) ;;\n+esac\n+AC_MSG_CHECKING([maintainer-mode])\n+AC_MSG_RESULT([$maintainer_mode])\n+test \"$maintainer_mode\" = yes && MAINTAINER=yes\n+AC_SUBST(MAINTAINER)\n+\n+# Check if O_CLOEXEC is defined by fcntl\n+AC_CACHE_CHECK(for O_CLOEXEC, ac_cv_o_cloexec, [\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+#include <fcntl.h>]], [[\n+return open (\"/dev/null\", O_RDONLY | O_CLOEXEC);]])],\n+[ac_cv_o_cloexec=yes],[ac_cv_o_cloexec=no])])\n+if test $ac_cv_o_cloexec = yes; then\n+  AC_DEFINE(HOST_HAS_O_CLOEXEC, 1,\n+  [Define if O_CLOEXEC supported by fcntl.])\n+fi\n+\n+# C++ Modules would like some networking features to provide the mapping\n+# server.  You can still use modules without them though.\n+# The following network-related checks could probably do with some\n+# Windows and other non-linux defenses and checking.\n+\n+# Local socket connectivity wants AF_UNIX networking\n+# Check for AF_UNIX networking\n+AC_CACHE_CHECK(for AF_UNIX, ac_cv_af_unix, [\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <netinet/in.h>]],[[\n+sockaddr_un un;\n+un.sun_family = AF_UNSPEC;\n+int fd = socket (AF_UNIX, SOCK_STREAM, 0);\n+connect (fd, (sockaddr *)&un, sizeof (un));]])],\n+[ac_cv_af_unix=yes],\n+[ac_cv_af_unix=no])])\n+if test $ac_cv_af_unix = yes; then\n+  AC_DEFINE(HAVE_AF_UNIX, 1,\n+  [Define if AF_UNIX supported.])\n+fi\n+\n+# Remote socket connectivity wants AF_INET6 networking\n+# Check for AF_INET6 networking\n+AC_CACHE_CHECK(for AF_INET6, ac_cv_af_inet6, [\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <netinet/in.h>\n+#include <netdb.h>]],[[\n+sockaddr_in6 in6;\n+in6.sin6_family = AF_UNSPEC;\n+struct addrinfo *addrs = 0;\n+struct addrinfo hints;\n+hints.ai_flags = 0;\n+hints.ai_family = AF_INET6;\n+hints.ai_socktype = SOCK_STREAM;\n+hints.ai_protocol = 0;\n+hints.ai_canonname = 0;\n+hints.ai_addr = 0;\n+hints.ai_next = 0;\n+int e = getaddrinfo (\"localhost\", 0, &hints, &addrs);\n+const char *str = gai_strerror (e);\n+freeaddrinfo (addrs);\n+int fd = socket (AF_INET6, SOCK_STREAM, 0);\n+connect (fd, (sockaddr *)&in6, sizeof (in6));]])],\n+[ac_cv_af_inet6=yes],\n+[ac_cv_af_inet6=no])])\n+if test $ac_cv_af_inet6 = yes; then\n+  AC_DEFINE(HAVE_AF_INET6, 1,\n+  [Define if AF_INET6 supported.])\n+fi\n+\n+# Efficient server response wants epoll\n+# Check for epoll_create, epoll_ctl, epoll_pwait\n+AC_CACHE_CHECK(for epoll, ac_cv_epoll, [\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+#include <sys/epoll.h>]],[[\n+int fd = epoll_create (1);\n+epoll_event ev;\n+ev.events = EPOLLIN;\n+ev.data.fd = 0;\n+epoll_ctl (fd, EPOLL_CTL_ADD, 0, &ev);\n+epoll_pwait (fd, 0, 0, -1, 0);]])],\n+[ac_cv_epoll=yes],\n+[ac_cv_epoll=no])])\n+if test $ac_cv_epoll = yes; then\n+  AC_DEFINE(HAVE_EPOLL, 1,\n+  [Define if epoll_create, epoll_ctl, epoll_pwait provided.])\n+fi\n+\n+# If we can't use epoll, try pselect.\n+# Check for pselect\n+AC_CACHE_CHECK(for pselect, ac_cv_pselect, [\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+#include <sys/select.h>]],[[\n+pselect (0, 0, 0, 0, 0, 0);]])],\n+[ac_cv_pselect=yes],\n+[ac_cv_pselect=no])])\n+if test $ac_cv_pselect = yes; then\n+  AC_DEFINE(HAVE_PSELECT, 1,\n+  [Define if pselect provided.])\n+fi\n+\n+# And failing that, use good old select.\n+# If we can't even use this, the server is serialized.\n+# Check for select\n+AC_CACHE_CHECK(for select, ac_cv_select, [\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+#include <sys/select.h>]],[[\n+select (0, 0, 0, 0, 0);]])],\n+[ac_cv_select=yes],\n+[ac_cv_select=no])])\n+if test $ac_cv_select = yes; then\n+  AC_DEFINE(HAVE_SELECT, 1,\n+  [Define if select provided.])\n+fi\n+\n+# Avoid some fnctl calls by using accept4, when available.\n+# Check for accept4\n+AC_CACHE_CHECK(for accept4, ac_cv_accept4, [\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+#include <sys/socket.h>]],[[\n+int err = accept4 (1, 0, 0, SOCK_NONBLOCK);]])],\n+[ac_cv_accept4=yes],\n+[ac_cv_accept4=no])])\n+if test $ac_cv_accept4 = yes; then\n+  AC_DEFINE(HAVE_ACCEPT4, 1,\n+  [Define if accept4 provided.])\n+fi\n+\n+# For better server messages, look for a way to stringize network addresses\n+# Check for inet_ntop\n+AC_CACHE_CHECK(for inet_ntop, ac_cv_inet_ntop, [\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+#include <arpa/inet.h>\n+#include <netinet/in.h>]],[[\n+sockaddr_in6 in6;\n+char buf[INET6_ADDRSTRLEN];\n+const char *str = inet_ntop (AF_INET6, &in6, buf, sizeof (buf));]])],\n+[ac_cv_inet_ntop=yes],\n+[ac_cv_inet_ntop=no])])\n+if test $ac_cv_inet_ntop = yes; then\n+  AC_DEFINE(HAVE_INET_NTOP, 1,\n+  [Define if inet_ntop provided.])\n+fi\n+\n+AC_CONFIG_HEADERS([config.h])\n+AC_CONFIG_FILES([Makefile])\n+\n+AC_OUTPUT"}, {"sha": "5028d2a4a37455616d519a41a1be339c9e1b7d09", "filename": "c++tools/resolver.cc", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fc243fca06b1ce845a605cd1d6fd199a857e8e/c%2B%2Btools%2Fresolver.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fc243fca06b1ce845a605cd1d6fd199a857e8e/c%2B%2Btools%2Fresolver.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/c%2B%2Btools%2Fresolver.cc?ref=35fc243fca06b1ce845a605cd1d6fd199a857e8e", "patch": "@@ -0,0 +1,272 @@\n+/* C++ modules.  Experimental!\t-*- c++ -*-\n+   Copyright (C) 2017-2020 Free Software Foundation, Inc.\n+   Written by Nathan Sidwell <nathan@acm.org> while at FaceBook\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+\n+#include \"resolver.h\"\n+// C++\n+#include <algorithm>\n+// C\n+#include <cstring>\n+// OS\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <sys/mman.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#ifndef DIR_SEPARATOR\n+#define DIR_SEPARATOR '/'\n+#endif\n+\n+module_resolver::module_resolver (bool map, bool xlate)\n+  : default_map (map), default_translate (xlate)\n+{\n+}\n+\n+module_resolver::~module_resolver ()\n+{\n+  if (fd_repo >= 0)\n+    close (fd_repo);\n+}\n+\n+bool\n+module_resolver::set_repo (std::string &&r, bool force)\n+{\n+  if (force || repo.empty ())\n+    {\n+      repo = std::move (r);\n+      force = true;\n+    }\n+  return force;\n+}\n+\n+bool\n+module_resolver::add_mapping (std::string &&module, std::string &&file,\n+\t\t\t      bool force)\n+{\n+  auto res = map.emplace (std::move (module), std::move (file));\n+  if (res.second)\n+    force = true;\n+  else if (force)\n+    res.first->second = std::move (file);\n+\n+  return force;\n+}\n+\n+int\n+module_resolver::read_tuple_file (int fd, char const *prefix, bool force)\n+{\n+  struct stat stat;\n+  if (fstat (fd, &stat) < 0)\n+    return -errno;\n+\n+  if (!stat.st_size)\n+    return 0;\n+\n+  // Just map the file, we're gonna read all of it, so no need for\n+  // line buffering\n+  void *buffer = mmap (nullptr, stat.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n+  if (buffer == MAP_FAILED)\n+    return -errno;\n+\n+  size_t prefix_len = prefix ? strlen (prefix) : 0;\n+  unsigned lineno = 0;\n+\n+  for (char const *begin = reinterpret_cast <char const *> (buffer),\n+\t *end = begin + stat.st_size, *eol;\n+       begin != end; begin = eol + 1)\n+    {\n+      lineno++;\n+      eol = std::find (begin, end, '\\n');\n+      if (eol == end)\n+\t// last line has no \\n, ignore the line, you lose\n+\tbreak;\n+\n+      auto *pos = begin;\n+      bool pfx_search = prefix_len != 0;\n+\n+    pfx_search:\n+      while (*pos == ' ' || *pos == '\\t')\n+\tpos++;\n+\n+      auto *space = pos;\n+      while (*space != '\\n' && *space != ' ' && *space != '\\t')\n+\tspace++;\n+\n+      if (pos == space)\n+\t// at end of line, nothing here\t\n+\tcontinue;\n+\n+      if (pfx_search)\n+\t{\n+\t  if (size_t (space - pos) == prefix_len\n+\t      && std::equal (pos, space, prefix))\n+\t    pfx_search = false;\n+\t  pos = space;\n+\t  goto pfx_search;\n+\t}\n+\n+      std::string module (pos, space);\n+      while (*space == ' ' || *space == '\\t')\n+\tspace++;\n+      std::string file (space, eol);\n+\n+      if (module[0] == '$')\n+\t{\n+\t  if (module == \"$root\")\n+\t    set_repo (std::move (file));\n+\t  else\n+\t    return lineno;\n+\t}\n+      else\n+\t{\n+\t  if (file.empty ())\n+\t    file = GetCMIName (module);\n+\t  add_mapping (std::move (module), std::move (file), force);\n+\t}\n+    }\n+\n+  munmap (buffer, stat.st_size);\n+\n+  return 0;\n+}\n+\n+char const *\n+module_resolver::GetCMISuffix ()\n+{\n+  return \"gcm\";\n+}\n+\n+module_resolver *\n+module_resolver::ConnectRequest (Cody::Server *s, unsigned version,\n+\t\t\t\t std::string &a, std::string &i)\n+{\n+  if (!version || version > Cody::Version)\n+    s->ErrorResponse (\"version mismatch\");\n+  else if (a != \"GCC\")\n+    // Refuse anything but GCC\n+    ErrorResponse (s, std::string (\"only GCC supported\"));\n+  else if (!ident.empty () && ident != i)\n+    // Failed ident check\n+    ErrorResponse (s, std::string (\"bad ident\"));\n+  else\n+    // Success!\n+    s->ConnectResponse (\"gcc\");\n+\n+  return this;\n+}\n+\n+int\n+module_resolver::ModuleRepoRequest (Cody::Server *s)\n+{\n+  s->PathnameResponse (repo);\n+  return 0;\n+}\n+\n+int\n+module_resolver::cmi_response (Cody::Server *s, std::string &module)\n+{\n+  auto iter = map.find (module);\n+  if (iter == map.end ())\n+    {\n+      std::string file;\n+      if (default_map)\n+\tfile = std::move (GetCMIName (module));\n+      auto res = map.emplace (module, file);\n+      iter = res.first;\n+    }\n+\n+  if (iter->second.empty ())\n+    s->ErrorResponse (\"no such module\");\n+  else\n+    s->PathnameResponse (iter->second);\n+\n+  return 0;\n+}\n+\n+int\n+module_resolver::ModuleExportRequest (Cody::Server *s, Cody::Flags,\n+\t\t\t\t      std::string &module)\n+{\n+  return cmi_response (s, module);\n+}\n+\n+int\n+module_resolver::ModuleImportRequest (Cody::Server *s, Cody::Flags,\n+\t\t\t\t      std::string &module)\n+{\n+  return cmi_response (s, module);\n+}\n+\n+int\n+module_resolver::IncludeTranslateRequest (Cody::Server *s, Cody::Flags,\n+\t\t\t\t\t  std::string &include)\n+{\n+  auto iter = map.find (include);\n+  if (iter == map.end () && default_translate)\n+    {\n+      // Not found, look for it\n+      auto file = GetCMIName (include);\n+      struct stat statbuf;\n+      bool ok = true;\n+\n+#if HAVE_FSTATAT\n+      int fd_dir = AT_FDCWD;\n+      if (!repo.empty ())\n+\t{\n+\t  if (fd_repo == -1)\n+\t    {\n+\t      fd_repo = open (repo.c_str (),\n+\t\t\t      O_RDONLY | O_CLOEXEC | O_DIRECTORY);\n+\t      if (fd_repo < 0)\n+\t\tfd_repo = -2;\n+\t    }\n+\t  fd_dir = fd_repo;\n+\t}\n+\n+      if (!repo.empty () && fd_repo < 0)\n+\tok = false;\n+      else if (fstatat (fd_dir, file.c_str (), &statbuf, 0) < 0\n+\t       || !S_ISREG (statbuf.st_mode))\n+\tok = false;\n+#else\n+      auto append = repo;\n+      append.push_back (DIR_SEPARATOR);\n+      append.append (file);\n+      if (stat (append.c_str (), &statbuf) < 0\n+\t  || !S_ISREG (statbuf.st_mode))\n+\tok = false;\n+#endif\n+      if (!ok)\n+\t// Mark as not present\n+\tfile.clear ();\n+      auto res = map.emplace (include, file);\n+      iter = res.first;\n+    }\n+\n+  if (iter == map.end () || iter->second.empty ())\n+    s->BoolResponse (false);\n+  else\n+    s->PathnameResponse (iter->second);\n+\n+  return 0;\n+}\n+"}, {"sha": "19339125b261c8b2ddf9a7b87817c8a6a04c58cb", "filename": "c++tools/resolver.h", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fc243fca06b1ce845a605cd1d6fd199a857e8e/c%2B%2Btools%2Fresolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fc243fca06b1ce845a605cd1d6fd199a857e8e/c%2B%2Btools%2Fresolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/c%2B%2Btools%2Fresolver.h?ref=35fc243fca06b1ce845a605cd1d6fd199a857e8e", "patch": "@@ -0,0 +1,105 @@\n+/* C++ modules.  Experimental!\t-*- c++ -*-\n+   Copyright (C) 2017-2020 Free Software Foundation, Inc.\n+   Written by Nathan Sidwell <nathan@acm.org> while at FaceBook\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GXX_RESOLVER_H\n+#define GXX_RESOLVER_H 1\n+\n+// Mapper interface for client and server bits\n+#include \"cody.hh\"\n+// C++\n+#include <string>\n+#include <map>\n+\n+// This is a GCC class, so GCC coding conventions on new bits.  \n+class module_resolver : public Cody::Resolver\n+{\n+public:\n+  using parent = Cody::Resolver;\n+  using module_map = std::map<std::string, std::string>;\n+\n+private:\n+  std::string repo;\n+  std::string ident;\n+  module_map map;\n+  int fd_repo = -1;\n+  bool default_map = true;\n+  bool default_translate = true;\n+\n+public:\n+  module_resolver (bool map = true, bool xlate = false);\n+  virtual ~module_resolver () override;\n+\n+public:\n+  void set_default_map (bool d)\n+  {\n+    default_map = d;\n+  }\n+  void set_default_translate (bool d)\n+  {\n+    default_translate = d;\n+  }\n+  void set_ident (char const *i)\n+  {\n+    ident = i;\n+  }\n+  bool set_repo (std::string &&repo, bool force = false);\n+  bool add_mapping (std::string &&module, std::string &&file,\n+\t\t    bool force = false);\n+\n+  // Return +ve line number of error, or -ve errno\n+  int read_tuple_file (int fd, char const *prefix, bool force = false);\n+  int read_tuple_file (int fd, std::string const &prefix,\n+\t\t\t    bool force = false)\n+  {\n+    return read_tuple_file (fd, prefix.empty () ? nullptr : prefix.c_str (),\n+\t\t\t    force);\n+  }\n+\n+public:\n+  // Virtual overriders, names are controlled by Cody::Resolver\n+  using parent::ConnectRequest;\n+  virtual module_resolver *ConnectRequest (Cody::Server *, unsigned version,\n+\t\t\t\t\t   std::string &agent,\n+\t\t\t\t\t   std::string &ident)\n+    override;\n+  using parent::ModuleRepoRequest;\n+  virtual int ModuleRepoRequest (Cody::Server *) override;\n+  using parent::ModuleExportRequest;\n+  virtual int ModuleExportRequest (Cody::Server *s, Cody::Flags,\n+\t\t\t\t   std::string &module)\n+    override;\n+  using parent::ModuleImportRequest;\n+  virtual int ModuleImportRequest (Cody::Server *s, Cody::Flags,\n+\t\t\t\t   std::string &module)\n+    override;\n+  using parent::IncludeTranslateRequest;\n+  virtual int IncludeTranslateRequest (Cody::Server *s, Cody::Flags,\n+\t\t\t\t       std::string &include)\n+    override;\n+\n+private:\n+  using parent::GetCMISuffix;\n+  virtual char const *GetCMISuffix () override;\n+\n+private:\n+  int cmi_response (Cody::Server *s, std::string &module);\n+};\n+\n+#endif"}, {"sha": "6457dc5b878629c5dfff61ea910d94b5497d2537", "filename": "c++tools/server.cc", "status": "added", "additions": 976, "deletions": 0, "changes": 976, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fc243fca06b1ce845a605cd1d6fd199a857e8e/c%2B%2Btools%2Fserver.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fc243fca06b1ce845a605cd1d6fd199a857e8e/c%2B%2Btools%2Fserver.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/c%2B%2Btools%2Fserver.cc?ref=35fc243fca06b1ce845a605cd1d6fd199a857e8e", "patch": "@@ -0,0 +1,976 @@\n+/* C++ modules.  Experimental!\n+   Copyright (C) 2018-2020 Free Software Foundation, Inc.\n+   Written by Nathan Sidwell <nathan@acm.org> while at FaceBook\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"resolver.h\"\n+\n+// C++\n+#include <set>\n+#include <vector>\n+#include <map>\n+// C\n+#include <csignal>\n+#include <cstring>\n+#include <cstdarg>\n+// OS\n+#include <unistd.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+\n+// Network\n+/* Include network stuff first.  Excitingly OSX10.14 uses bcmp here, which\n+   we poison later!  */\n+#if defined (HAVE_AF_UNIX) || defined (HAVE_AF_INET6)\n+/* socket, bind, listen, accept{4}  */\n+# define NETWORKING 1\n+# include <sys/socket.h>\n+# ifdef HAVE_AF_UNIX\n+/* sockaddr_un  */\n+#  include <sys/un.h>\n+# endif\n+# include <netinet/in.h>\n+# ifdef HAVE_AF_INET6\n+/* sockaddr_in6, getaddrinfo, freeaddrinfo, gai_sterror, ntohs, htons.  */\n+#  include <netdb.h>\n+# endif\n+#ifdef HAVE_INET_NTOP\n+/* inet_ntop.  */\n+#include <arpa/inet.h>\n+#endif\n+#endif\n+#ifndef HAVE_AF_INET6\n+# define gai_strerror(X) \"\"\n+#endif\n+\n+#include <getopt.h>\n+\n+// Select or epoll\n+#ifdef NETWORKING\n+#ifdef HAVE_EPOLL\n+/* epoll_create, epoll_ctl, epoll_pwait  */\n+#include <sys/epoll.h>\n+#endif\n+#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)\n+/* pselect or select  */\n+#include <sys/select.h>\n+#endif\n+#endif\n+\n+// GCC\n+#include \"version.h\"\n+#include \"ansidecl.h\"\n+#define HAVE_DECL_BASENAME 1 /* See comment in gcc/configure.ac.  */\n+#include \"libiberty.h\"\n+\n+#if !HOST_HAS_O_CLOEXEC\n+#define O_CLOEXEC 0\n+#endif\n+\n+#ifndef IS_DIR_SEPARATOR\n+#define IS_DIR_SEPARATOR(C) ((C) == '/')\n+#endif\n+#ifndef DIR_SEPARATOR\n+#define DIR_SEPARATOR '/'\n+#endif\n+\n+#ifdef NETWORKING\n+struct netmask {\n+  in6_addr addr;\n+  unsigned bits;\n+\n+  netmask (const in6_addr &a, unsigned b)\n+  {\n+    if (b > sizeof (in6_addr) * 8)\n+      b = sizeof (in6_addr) * 8;\n+    bits = b;\n+    unsigned byte = (b + 7) / 8;\n+    unsigned ix = 0;\n+    for (ix = 0; ix < byte; ix++)\n+      addr.s6_addr[ix] = a.s6_addr[ix];\n+    for (; ix != sizeof (in6_addr); ix++)\n+      addr.s6_addr[ix] = 0;\n+    if (b & 3)\n+      addr.s6_addr[b/7] &= (255 << 8) >> (b & 3);\n+  }\n+\n+  bool includes (const in6_addr &a) const\n+  {\n+    unsigned byte = bits / 8;\n+    for (unsigned ix = 0; ix != byte; ix++)\n+      if (addr.s6_addr[ix] != a.s6_addr[ix])\n+\treturn false;\n+    if (bits & 3)\n+      if ((addr.s6_addr[byte] ^ a.s6_addr[byte]) >> (8 - (bits & 3)))\n+\treturn false;\n+    return true;\n+  }\n+};\n+\n+/* Netmask comparison.  */\n+struct netmask_cmp {\n+  bool operator() (const netmask &a, const netmask &b) const\n+  {\n+    if (a.bits != b.bits)\n+      return a.bits < b.bits;\n+    for (unsigned ix = 0; ix != sizeof (in6_addr); ix++)\n+      if (a.addr.s6_addr[ix] != b.addr.s6_addr[ix])\n+\treturn a.addr.s6_addr[ix] < b.addr.s6_addr[ix];\n+    return false;\n+  }\n+};\n+\n+typedef std::set<netmask, netmask_cmp> netmask_set_t;\n+typedef std::vector<netmask> netmask_vec_t;\n+#endif\n+\n+const char *progname;\n+\n+/* Speak thoughts out loud.  */\n+static bool flag_noisy = false;\n+\n+/* One and done.  */\n+static bool flag_one = false;\n+\n+/* Serialize connections.  */\n+static bool flag_sequential = false;\n+\n+/* Fallback to default if map file is unrewarding.  */\n+static bool flag_map = false;\n+\n+/* Fallback to xlate if map file is unrewarding.  */\n+static bool flag_xlate = false;\n+\n+/* Root binary directory.  */\n+static const char *flag_root = \"gcm.cache\";\n+\n+#ifdef NETWORKING\n+static netmask_set_t netmask_set;\n+\n+static netmask_vec_t accept_addrs;\n+#endif\n+\n+/* Strip out the source directory from FILE.  */\n+\n+static const char *\n+trim_src_file (const char *file)\n+{\n+  static const char me[] = __FILE__;\n+  unsigned pos = 0;\n+\n+  while (file[pos] == me[pos] && me[pos])\n+    pos++;\n+  while (pos && !IS_DIR_SEPARATOR (me[pos-1]))\n+    pos--;\n+\n+  return file + pos;\n+}\n+\n+/* Die screaming.  */\n+\n+void ATTRIBUTE_NORETURN ATTRIBUTE_PRINTF_1 ATTRIBUTE_COLD\n+internal_error (const char *fmt, ...)\n+{\n+  fprintf (stderr, \"%s:Internal error \", progname);\n+  va_list args;\n+\n+  va_start (args, fmt);\n+  vfprintf (stderr, fmt, args);\n+  va_end (args);\n+  fprintf (stderr, \"\\n\");\n+\n+  exit (2);\n+}\n+\n+/* Hooked to from gcc_assert & gcc_unreachable.  */\n+\n+void ATTRIBUTE_NORETURN ATTRIBUTE_COLD\n+fancy_abort (const char *file, int line, const char *func)\n+{\n+  internal_error (\"in %s, at %s:%d\", func, trim_src_file (file), line);\n+}\n+\n+/* Exploded on a signal.  */\n+\n+static void ATTRIBUTE_NORETURN ATTRIBUTE_COLD\n+crash_signal (int sig)\n+{\n+  signal (sig, SIG_DFL);\n+  internal_error (\"signal %s\", strsignal (sig));\n+}\n+\n+/* A fatal error of some kind.  */\n+\n+static void ATTRIBUTE_NORETURN ATTRIBUTE_COLD ATTRIBUTE_PRINTF_1\n+error (const char *msg, ...)\n+{\n+  fprintf (stderr, \"%s:error: \", progname);\n+  va_list args;\n+\n+  va_start (args, msg);\n+  vfprintf (stderr, msg, args);\n+  va_end (args);\n+  fprintf (stderr, \"\\n\");\n+\n+  exit (1);\n+}\n+\n+#ifdef NETWORKING\n+/* Progress messages to the user.  */\n+static bool ATTRIBUTE_PRINTF_1 ATTRIBUTE_COLD\n+noisy (const char *fmt, ...)\n+{\n+  fprintf (stderr, \"%s:\", progname);\n+  va_list args;\n+  va_start (args, fmt);\n+  vfprintf (stderr, fmt, args);\n+  va_end (args);\n+  fprintf (stderr, \"\\n\");\n+\n+  return false;\n+}\n+#endif\n+\n+/* More messages to the user.  */\n+\n+static void ATTRIBUTE_PRINTF_2\n+fnotice (FILE *file, const char *fmt, ...)\n+{\n+  va_list args;\n+\n+  va_start (args, fmt);\n+  vfprintf (file, fmt, args);\n+  va_end (args);\n+}\n+\n+static void ATTRIBUTE_NORETURN\n+print_usage (int error_p)\n+{\n+  FILE *file = error_p ? stderr : stdout;\n+  int status = error_p ? 1 : 0;\n+\n+  fnotice (file, \"Usage: %s [OPTION...] [CONNECTION] [MAPPINGS...] \\n\\n\",\n+\t   progname);\n+  fnotice (file, \"C++ Module Mapper.\\n\\n\");\n+  fnotice (file, \"  -a, --accept     Netmask to accept from\\n\");\n+  fnotice (file, \"  -f, --fallback   Use fallback for missing mappings\\n\");\n+  fnotice (file, \"  -h, --help       Print this help, then exit\\n\");\n+  fnotice (file, \"  -n, --noisy      Print progress messages\\n\");\n+  fnotice (file, \"  -1, --one        One connection and then exit\\n\");\n+  fnotice (file, \"  -r, --root DIR   Root compiled module directory\\n\");\n+  fnotice (file, \"  -s, --sequential Process connections sequentially\\n\");\n+  fnotice (file, \"  -v, --version    Print version number, then exit\\n\");\n+  fnotice (file, \"Send SIGTERM(%d) to terminate\\n\", SIGTERM);\n+  fnotice (file, \"\\nFor bug reporting instructions, please see:\\n%s.\\n\",\n+\t   bug_report_url);\n+  exit (status);\n+}\n+\n+/* Print version information and exit.  */\n+\n+static void ATTRIBUTE_NORETURN\n+print_version (void)\n+{\n+  fnotice (stdout, \"%s %s%s\\n\", progname, pkgversion_string, version_string);\n+  fprintf (stdout, \"Copyright %s 2018-2020 Free Software Foundation, Inc.\\n\",\n+\t   (\"(C)\"));\n+  fnotice (stdout,\n+\t   (\"This is free software; see the source for copying conditions.\\n\"\n+\t    \"There is NO warranty; not even for MERCHANTABILITY or \\n\"\n+\t    \"FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"));\n+  exit (0);\n+}\n+\n+/* ARG is a netmask to accept from.  Add it to the table.  Return\n+   false if we fail to resolve it.  */\n+\n+static bool\n+accept_from (char *arg ATTRIBUTE_UNUSED)\n+{\n+  bool ok = true;\n+#if HAVE_AF_INET6\n+  unsigned bits = sizeof (in6_addr) * 8;\n+  char *slash = strrchr (arg, '/');\n+  if (slash)\n+    {\n+      *slash = 0;\n+      if (slash[1])\n+\t{\n+\t  char *endp;\n+\t  bits = strtoul (slash + 1, &endp, 0);\n+\t}\n+    }\n+\n+  addrinfo hints;\n+\n+  hints.ai_flags = AI_NUMERICSERV;\n+  hints.ai_family = AF_INET6;\n+  hints.ai_socktype = SOCK_STREAM;\n+  hints.ai_protocol = 0;\n+  hints.ai_addrlen = 0;\n+  hints.ai_addr = NULL;\n+  hints.ai_canonname = NULL;\n+  hints.ai_next = NULL;\n+\n+  struct addrinfo *addrs = NULL;\n+  if (int e = getaddrinfo (slash == arg ? NULL : arg, \"0\", &hints, &addrs))\n+    {\n+      noisy (\"cannot resolve '%s': %s\", arg, gai_strerror (e));\n+      ok = false;\n+    }\n+  else\n+    for (addrinfo *next = addrs; next; next = next->ai_next)\n+      if (next->ai_family == AF_INET6)\n+\t{\n+\t  netmask mask (((const sockaddr_in6 *)next->ai_addr)->sin6_addr, bits);\n+\t  netmask_set.insert (mask);\n+\t}\n+  freeaddrinfo (addrs);\n+#endif\n+  return ok;\n+}\n+\n+/* Process args, return index to first non-arg.  */\n+\n+static int\n+process_args (int argc, char **argv)\n+{\n+  static const struct option options[] =\n+    {\n+     { \"accept\", required_argument, NULL, 'a' },\n+     { \"help\",\tno_argument,\tNULL, 'h' },\n+     { \"map\",   no_argument,\tNULL, 'm' },\n+     { \"noisy\",\tno_argument,\tNULL, 'n' },\n+     { \"one\",\tno_argument,\tNULL, '1' },\n+     { \"root\",\trequired_argument, NULL, 'r' },\n+     { \"sequential\", no_argument, NULL, 's' },\n+     { \"translate\",no_argument,\tNULL, 't' },\n+     { \"version\", no_argument,\tNULL, 'v' },\n+     { 0, 0, 0, 0 }\n+    };\n+  int opt;\n+  bool bad_accept = false;\n+  const char *opts = \"a:fhmn1r:stv\";\n+  while ((opt = getopt_long (argc, argv, opts, options, NULL)) != -1)\n+    {\n+      switch (opt)\n+\t{\n+\tcase 'a':\n+\t  if (!accept_from (optarg))\n+\t    bad_accept = true;\n+\t  break;\n+\tcase 'h':\n+\t  print_usage (false);\n+\t  /* print_usage will exit.  */\n+\tcase 'f': // deprecated alias\n+\tcase 'm':\n+\t  flag_map = true;\n+\t  break;\n+\tcase 'n':\n+\t  flag_noisy = true;\n+\t  break;\n+\tcase '1':\n+\t  flag_one = true;\n+\t  break;\n+\tcase 'r':\n+\t  flag_root = optarg;\n+\t  break;\n+\tcase 's':\n+\t  flag_sequential = true;\n+\t  break;\n+\tcase 't':\n+\t  flag_xlate = true;\n+\t  break;\n+\tcase 'v':\n+\t  print_version ();\n+\t  /* print_version will exit.  */\n+\tdefault:\n+\t  print_usage (true);\n+\t  /* print_usage will exit.  */\n+\t}\n+    }\n+\n+  if (bad_accept)\n+    error (\"failed to resolve all accept addresses\");\n+\n+  return optind;\n+}\n+\n+#ifdef NETWORKING\n+\n+/* Manipulate the EPOLL state, or do nothing, if there is epoll.  */\n+\n+#ifdef HAVE_EPOLL\n+static inline void\n+do_epoll_ctl (int epoll_fd, int code, int event, int fd, unsigned data)\n+{\n+  epoll_event ev;\n+  ev.events = event;\n+  ev.data.u32 = data;\n+  if (epoll_ctl (epoll_fd, code, fd, &ev))\n+    {\n+      noisy (\"epoll_ctl error:%s\", xstrerror (errno));\n+      gcc_unreachable ();\n+    }\n+}\n+#define my_epoll_ctl(EFD,C,EV,FD,CL) \\\n+  ((EFD) >= 0 ? do_epoll_ctl (EFD,C,EV,FD,CL) : (void)0)\n+#else\n+#define my_epoll_ctl(EFD,C,EV,FD,CL) ((void)(EFD), (void)(FD), (void)(CL))\n+#endif\n+\n+/* We increment this to tell the server to shut down.  */\n+static volatile int term = false;\n+static volatile int kill_sock_fd = -1;\n+#if !defined (HAVE_PSELECT) && defined (HAVE_SELECT)\n+static int term_pipe[2] = {-1, -1};\n+#else\n+#define term_pipe ((int *)NULL)\n+#endif\n+\n+/* A terminate signal.  Shutdown gracefully.  */\n+\n+static void\n+term_signal (int sig)\n+{\n+  signal (sig, term_signal);\n+  term = term + 1;\n+  if (term_pipe && term_pipe[1] >= 0)\n+    write (term_pipe[1], &term_pipe[1], 1);\n+}\n+\n+/* A kill signal.  Shutdown immediately.  */\n+\n+static void\n+kill_signal (int sig)\n+{\n+  signal (sig, SIG_DFL);\n+  int sock_fd = kill_sock_fd;\n+  if (sock_fd >= 0)\n+    close (sock_fd);\n+  exit (2);\n+}\n+\n+bool process_server (Cody::Server *server, unsigned slot, int epoll_fd)\n+{\n+  switch (server->GetDirection ())\n+    {\n+    case Cody::Server::READING:\n+      if (int err = server->Read ())\n+\treturn !(err == EINTR || err == EAGAIN);\n+      server->ProcessRequests ();\n+      server->PrepareToWrite ();\n+      break;\n+\n+    case Cody::Server::WRITING:\n+      if (int err = server->Write ())\n+\treturn !(err == EINTR || err == EAGAIN);\n+      server->PrepareToRead ();\n+      break;\n+\n+    default:\n+      // We should never get here\n+      return true;\n+    }\n+\n+  // We've changed direction, so update epoll\n+  gcc_assert (server->GetFDRead () == server->GetFDWrite ());\n+  my_epoll_ctl (epoll_fd, EPOLL_CTL_MOD,\n+\t\tserver->GetDirection () == Cody::Server::READING\n+\t\t? EPOLLIN : EPOLLOUT, server->GetFDRead (), slot + 1);\n+\n+  return false;\n+}\n+\n+void close_server (Cody::Server *server, int epoll_fd)\n+{\n+  my_epoll_ctl (epoll_fd, EPOLL_CTL_DEL, EPOLLIN, server->GetFDRead (), 0);\n+\n+  close (server->GetFDRead ());\n+  \n+  delete server;\n+}\n+\n+int open_server (bool ip6, int sock_fd)\n+{\n+  sockaddr_in6 addr;\n+  socklen_t addr_len = sizeof (addr);\n+\n+#ifdef HAVE_ACCEPT4\n+  int client_fd = accept4 (sock_fd, ip6 ? (sockaddr *)&addr : nullptr,\n+\t\t\t   &addr_len, SOCK_NONBLOCK);\n+#else\n+  int client_fd = accept (sock_fd, ip6 ? (sockaddr *)&addr : nullptr, &addr_len);\n+#endif\n+  if (client_fd < 0)\n+    {\n+      error (\"cannot accept: %s\", xstrerror (errno));\n+      flag_one = true;\n+    }\n+  else if (ip6)\n+    {\n+      const char *str = NULL;\n+#if HAVE_INET_NTOP\n+      char name[INET6_ADDRSTRLEN];\n+      str = inet_ntop (addr.sin6_family, &addr.sin6_addr, name, sizeof (name));\n+#endif\n+      if (!accept_addrs.empty ())\n+\t{\n+\t  netmask_vec_t::iterator e = accept_addrs.end ();\n+\t  for (netmask_vec_t::iterator i = accept_addrs.begin ();\n+\t       i != e; ++i)\n+\t    if (i->includes (addr.sin6_addr))\n+\t      goto present;\n+\t  close (client_fd);\n+\t  client_fd = -1;\n+\t  noisy (\"Rejecting connection from disallowed source '%s'\",\n+\t\t str ? str : \"\");\n+\tpresent:;\n+\t}\n+      if (client_fd >= 0)\n+\tflag_noisy && noisy (\"Accepting connection from '%s'\", str ? str : \"\");\n+    }\n+\n+  return client_fd;\n+}\n+\n+/* A server listening on bound socket SOCK_FD.  */\n+\n+static void\n+server (bool ipv6, int sock_fd, module_resolver *resolver)\n+{\n+  int epoll_fd = -1;\n+\n+  signal (SIGTERM, term_signal);\n+#ifdef HAVE_EPOLL\n+  epoll_fd = epoll_create (1);\n+#endif\n+  if (epoll_fd >= 0)\n+    my_epoll_ctl (epoll_fd, EPOLL_CTL_ADD, EPOLLIN, sock_fd, 0);\n+\n+#if defined (HAVE_EPOLL) || defined (HAVE_PSELECT) || defined (HAVE_SELECT)\n+  sigset_t mask;\n+  {\n+    sigset_t block;\n+    sigemptyset (&block);\n+    sigaddset (&block, SIGTERM);\n+    sigprocmask (SIG_BLOCK, &block, &mask);\n+  }\n+#endif\n+\n+#ifdef HAVE_EPOLL\n+  const unsigned max_events = 20;\n+  epoll_event events[max_events];\n+#endif\n+#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)\n+  fd_set readers, writers;\n+#endif\n+  if (term_pipe)\n+    pipe (term_pipe);\n+\n+  // We need stable references to servers, so this array can contain nulls\n+  std::vector<Cody::Server *> connections;\n+  unsigned live = 0;\n+  while (sock_fd >= 0 || live)\n+    {\n+      /* Wait for one or more events.  */\n+      bool eintr = false;\n+      int event_count;\n+\n+      if (epoll_fd >= 0)\n+\t{\n+#ifdef HAVE_EPOLL\n+\t  event_count = epoll_pwait (epoll_fd, events, max_events, -1, &mask);\n+#endif\n+\t}\n+      else\n+\t{\n+#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)\n+\t  FD_ZERO (&readers);\n+\t  FD_ZERO (&writers);\n+\n+\t  unsigned limit = 0;\n+\t  if (sock_fd >= 0\n+\t      && !(term || (live && (flag_one || flag_sequential))))\n+\t    {\n+\t      FD_SET (sock_fd, &readers);\n+\t      limit = sock_fd + 1;\n+\t    }\n+\n+\t  if (term_pipe && term_pipe[0] >= 0)\n+\t    {\n+\t      FD_SET (term_pipe[0], &readers);\n+\t      if (unsigned (term_pipe[0]) >= limit)\n+\t\tlimit = term_pipe[0] + 1;\n+\t    }\n+\n+\t  for (auto iter = connections.begin ();\n+\t       iter != connections.end (); ++iter)\n+\t    if (auto *server = *iter)\n+\t      {\n+\t\tint fd = -1;\n+\t\tswitch (server->GetDirection ())\n+\t\t  {\n+\t\t  case Cody::Server::READING:\n+\t\t    fd = server->GetFDRead ();\n+\t\t    FD_SET (fd, &readers);\n+\t\t    break;\n+\t\t  case Cody::Server::WRITING:\n+\t\t    fd = server->GetFDWrite ();\n+\t\t    FD_SET (fd, &writers);\n+\t\t    break;\n+\t\t  default:\n+\t\t    break;\n+\t\t  }\n+\n+\t\tif (fd >= 0 && limit <= unsigned (fd))\n+\t\t  limit = fd + 1;\n+\t      }\n+\n+#ifdef HAVE_PSELECT\n+\t  event_count = pselect (limit, &readers, &writers, NULL, NULL, &mask);\n+#else\n+\t  event_count = select (limit, &readers, &writers, NULL, NULL);\n+#endif\n+\t  if (term_pipe && FD_ISSET (term_pipe[0], &readers))\n+\t    {\n+\t      /* Fake up an interrupted system call.  */\n+\t      event_count = -1;\n+\t      errno = EINTR;\n+\t    }\n+#endif\n+\t}\n+\n+      if (event_count < 0)\n+\t{\n+\t  // Error in waiting\n+\t  if (errno == EINTR)\n+\t    {\n+\t      flag_noisy && noisy (\"Interrupted wait\");\n+\t      eintr = true;\n+\t    }\n+\t  else\n+\t    error (\"cannot %s: %s\", epoll_fd >= 0 ? \"epoll_wait\"\n+#ifdef HAVE_PSELECT\n+\t\t   : \"pselect\",\n+#else\n+\t\t   : \"select\",\n+#endif\n+\t\t   xstrerror (errno));\n+\t  event_count = 0;\n+\t}\n+\n+      auto iter = connections.begin ();\n+      while (event_count--)\n+\t{\n+\t  // Process an event\n+\t  int active = -2;\n+\n+\t  if (epoll_fd >= 0)\n+\t    {\n+#ifdef HAVE_EPOLL\n+\t      /* See PR c++/88664 for why a temporary is used.  */\n+\t      unsigned data = events[event_count].data.u32;\n+\t      active = int (data) - 1;\n+#endif\n+\t    }\n+\t  else\n+\t    {\n+\t      for (; iter != connections.end (); ++iter)\n+\t\tif (auto *server = *iter)\n+\t\t  {\n+\t\t    bool found = false;\n+\t\t    switch (server->GetDirection ())\n+\t\t      {\n+#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)\n+\t\t      case Cody::Server::READING:\n+\t\t\tfound = FD_ISSET (server->GetFDRead (), &readers);\n+\t\t\tbreak;\n+\t\t      case Cody::Server::WRITING:\n+\t\t\tfound = FD_ISSET (server->GetFDWrite (), &writers);\n+\t\t\tbreak;\n+#endif\n+\t\t      default:\n+\t\t\tbreak;\n+\t\t      }\n+\n+\t\t    if (found)\n+\t\t      {\n+\t\t\tactive = iter - connections.begin ();\n+\t\t\t++iter;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\n+\t      if (active < 0 && sock_fd >= 0 && FD_ISSET (sock_fd, &readers))\n+\t\tactive = -1;\n+\t    }\n+\n+\t  if (active >= 0)\n+\t    {\n+\t      // Do the action\n+\t      auto *server = connections[active];\n+\t      if (process_server (server, active, epoll_fd))\n+\t\t{\n+\t\t  connections[active] = nullptr;\n+\t\t  close_server (server, epoll_fd);\n+\t\t  live--;\n+\t\t  if (flag_sequential)\n+\t\t    my_epoll_ctl (epoll_fd, EPOLL_CTL_ADD, EPOLLIN, sock_fd, 0);\n+\t\t}\n+\t    }\n+\t  else if (active == -1 && !eintr)\n+\t    {\n+\t      // New connection\n+\t      int fd = open_server (ipv6, sock_fd);\n+\t      if (fd >= 0)\n+\t\t{\n+#if !defined (HAVE_ACCEPT4) \\\n+  && (defined (HAVE_EPOLL) || defined (HAVE_PSELECT) || defined (HAVE_SELECT))\n+\t\t  int flags = fcntl (fd, F_GETFL, 0);\n+\t\t  fcntl (fd, F_SETFL, flags | O_NONBLOCK);\n+#endif\n+\t\t  auto *server = new Cody::Server (resolver, fd);\n+\n+\t\t  unsigned slot = connections.size ();\n+\t\t  if (live == slot)\n+\t\t    connections.push_back (server);\n+\t\t  else\n+\t\t    for (auto iter = connections.begin (); ; ++iter)\n+\t\t      if (!*iter)\n+\t\t\t{\n+\t\t\t  *iter = server;\n+\t\t\t  slot = iter - connections.begin ();\n+\t\t\t  break;\n+\t\t\t}\n+\t\t  live++;\n+\t\t  my_epoll_ctl (epoll_fd, EPOLL_CTL_ADD, EPOLLIN, fd, slot + 1);\n+\t\t}\n+\t    }\n+\n+\t  if (sock_fd >= 0\n+\t      && (term || (live && (flag_one || flag_sequential))))\n+\t    {\n+\t      /* Stop paying attention to sock_fd.  */\n+\t      my_epoll_ctl (epoll_fd, EPOLL_CTL_DEL, EPOLLIN, sock_fd, 0);\n+\t      if (flag_one || term)\n+\t\t{\n+\t\t  close (sock_fd);\n+\t\t  sock_fd = -1;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+#if defined (HAVE_EPOLL) || defined (HAVE_PSELECT) || defined (HAVE_SELECT)\n+  /* Restore the signal mask.  */\n+  sigprocmask (SIG_SETMASK, &mask, NULL);\n+#endif\n+\n+  gcc_assert (sock_fd < 0);\n+  if (epoll_fd >= 0)\n+    close (epoll_fd);\n+\n+  if (term_pipe && term_pipe[0] >= 0)\n+    {\n+      close (term_pipe[0]);\n+      close (term_pipe[1]);\n+    }\n+}\n+\n+#endif\n+\n+static int maybe_parse_socket (std::string &option, module_resolver *r)\n+{\n+  /* Local or ipv6 address.  */\n+  auto last = option.find_last_of ('?');\n+  if (last != option.npos)\n+    {\n+      r->set_ident (option.c_str () + last + 1);\n+      option.erase (last);\n+    }\n+  int fd = -2;\n+  char const *errmsg = nullptr;\n+\n+  /* Does it look like a socket?  */\n+  if (option[0] == '=')\n+    {\n+      /* A local socket.  */\n+#if CODY_NETWORKING\n+      fd = Cody::ListenLocal (&errmsg, option.c_str () + 1);\n+#endif\n+    }\n+  else\n+    {\n+      auto colon = option.find_last_of (':');\n+      if (colon != option.npos)\n+\t{\n+\t  /* Try a hostname:port address.  */\n+\t  char const *cptr = option.c_str () + colon;\n+\t  char *endp;\n+\t  unsigned port = strtoul (cptr + 1, &endp, 10);\n+\n+\t  if (port && endp != cptr + 1 && !*endp)\n+\t    {\n+\t      /* Ends in ':number', treat as ipv6 domain socket.  */\n+\t      option.erase (colon);\n+#if CODY_NETWORKING\n+\t      fd = Cody::ListenInet6 (&errmsg, option.c_str (), port);\n+#endif\n+\t    }\n+\t}\n+    }\n+\n+  if (errmsg)\n+    error (\"failed to open socket: %s\", errmsg);\n+\n+  return fd;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  const char *p = argv[0] + strlen (argv[0]);\n+  while (p != argv[0] && !IS_DIR_SEPARATOR (p[-1]))\n+    --p;\n+  progname = p;\n+\n+#ifdef SIGSEGV\n+  signal (SIGSEGV, crash_signal);\n+#endif\n+#ifdef SIGILL\n+  signal (SIGILL, crash_signal);\n+#endif\n+#ifdef SIGBUS\n+  signal (SIGBUS, crash_signal);\n+#endif\n+#ifdef SIGABRT\n+  signal (SIGABRT, crash_signal);\n+#endif\n+#ifdef SIGFPE\n+  signal (SIGFPE, crash_signal);\n+#endif\n+#ifdef SIGPIPE\n+  /* Ignore sigpipe, so read/write get an error.  */\n+  signal (SIGPIPE, SIG_IGN);\n+#endif\n+#ifdef NETWORKING\n+#ifdef SIGINT\n+  signal (SIGINT, kill_signal);\n+#endif\n+#endif\n+\n+  int argno = process_args (argc, argv);\n+\n+  std::string name;\n+  int sock_fd = -1; /* Socket fd, otherwise stdin/stdout.  */\n+  module_resolver r (flag_map, flag_xlate);\n+\n+  if (argno != argc)\n+    {\n+      name = argv[argno];\n+      sock_fd = maybe_parse_socket (name, &r);\n+      if (!name.empty ())\n+\targno++;\n+    }\n+\n+  if (argno != argc)\n+    for (; argno != argc; argno++)\n+      {\n+\tstd::string option = argv[argno];\n+\tchar const *prefix = nullptr;\n+\tauto ident = option.find_last_of ('?');\n+\tif (ident != option.npos)\n+\t  {\n+\t    prefix = option.c_str () + ident + 1;\n+\t    option[ident] = 0;\n+\t  }\n+\tint fd = open (option.c_str (), O_RDONLY | O_CLOEXEC);\n+\tint err = 0;\n+\tif (fd < 0)\n+\t  err = errno;\n+\telse\n+\t  {\n+\t    err = r.read_tuple_file (fd, prefix, false);\n+\t    close (fd);\n+\t  }\n+\n+\tif (err)\n+\t  error (\"failed reading '%s': %s\", option.c_str (), xstrerror (err));\n+      }\n+  else\n+    r.set_default_map (true);\n+\n+  if (flag_root)\n+    r.set_repo (flag_root);\n+\n+#ifdef HAVE_AF_INET6\n+  netmask_set_t::iterator end = netmask_set.end ();\n+  for (netmask_set_t::iterator iter = netmask_set.begin ();\n+       iter != end; ++iter)\n+    {\n+      netmask_vec_t::iterator e = accept_addrs.end ();\n+      for (netmask_vec_t::iterator i = accept_addrs.begin (); i != e; ++i)\n+\tif (i->includes (iter->addr))\n+\t  goto present;\n+      accept_addrs.push_back (*iter);\n+    present:;\n+    }\n+#endif\n+\n+#ifdef NETWORKING\n+  if (sock_fd >= 0)\n+    {\n+      server (name[0] != '=', sock_fd, &r);\n+      if (name[0] == '=')\n+\tunlink (name.c_str () + 1);\n+    }\n+  else\n+#endif\n+    {\n+      auto server = Cody::Server (&r, 0, 1);\n+\n+      int err = 0;\n+      for (;;)\n+\t{\n+\t  server.PrepareToRead ();\n+\t  while ((err = server.Read ()))\n+\t    {\n+\t      if (err == EINTR || err == EAGAIN)\n+\t\tcontinue;\n+\t      goto done;\n+\t    }\n+\n+\t  server.ProcessRequests ();\n+\n+\t  server.PrepareToWrite ();\n+\t  while ((err = server.Write ()))\n+\t    {\n+\t      if (err == EINTR || err == EAGAIN)\n+\t\tcontinue;\n+\t      goto done;\n+\t    }\n+\t}\n+    done:;\n+      if (err > 0)\n+\terror (\"communication error:%s\", xstrerror (err));\n+    }\n+\n+  return 0;\n+}"}]}