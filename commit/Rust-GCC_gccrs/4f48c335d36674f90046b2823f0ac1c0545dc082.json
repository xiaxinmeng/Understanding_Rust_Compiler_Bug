{"sha": "4f48c335d36674f90046b2823f0ac1c0545dc082", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY0OGMzMzVkMzY2NzRmOTAwNDZiMjgyM2YwYWMxYzA1NDVkYzA4Mg==", "commit": {"author": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2021-04-26T12:12:08Z"}, "committer": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2021-05-03T10:34:55Z"}, "message": "IBM Z: Handle hard registers in s390_md_asm_adjust()\n\ngen_fprx2_to_tf() and gen_tf_to_fprx2() cannot handle hard registers,\nsince the subregs they create do not pass validation.  Change\ns390_md_asm_adjust() to manually copy between hard VRs and FPRs instead\nof using these two functions.\n\ngcc/ChangeLog:\n\n\tPR target/100217\n\t* config/s390/s390.c (s390_hard_fp_reg_p): New function.\n\t(s390_md_asm_adjust): Handle hard registers.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/100217\n\t* gcc.target/s390/vector/long-double-asm-in-out-hard-fp-reg.c: New test.\n\t* gcc.target/s390/vector/long-double-asm-inout-hard-fp-reg.c: New test.", "tree": {"sha": "8d6060f2619e402e06814f13b5eac163ff833219", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d6060f2619e402e06814f13b5eac163ff833219"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f48c335d36674f90046b2823f0ac1c0545dc082", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f48c335d36674f90046b2823f0ac1c0545dc082", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f48c335d36674f90046b2823f0ac1c0545dc082", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f48c335d36674f90046b2823f0ac1c0545dc082/comments", "author": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80bbb7ff83d81544b09820428bdd7db9f50fe362", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80bbb7ff83d81544b09820428bdd7db9f50fe362", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80bbb7ff83d81544b09820428bdd7db9f50fe362"}], "stats": {"total": 116, "additions": 112, "deletions": 4}, "files": [{"sha": "88361f98c7ef0bdc07b265395a5a4b979272d75a", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f48c335d36674f90046b2823f0ac1c0545dc082/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f48c335d36674f90046b2823f0ac1c0545dc082/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=4f48c335d36674f90046b2823f0ac1c0545dc082", "patch": "@@ -16754,6 +16754,23 @@ f_constraint_p (const char *constraint)\n   return seen_f_p && !seen_v_p;\n }\n \n+/* Return TRUE iff X is a hard floating-point (and not a vector) register.  */\n+\n+static bool\n+s390_hard_fp_reg_p (rtx x)\n+{\n+  if (!(REG_P (x) && HARD_REGISTER_P (x) && REG_ATTRS (x)))\n+    return false;\n+\n+  tree decl = REG_EXPR (x);\n+  if (!(HAS_DECL_ASSEMBLER_NAME_P (decl) && DECL_ASSEMBLER_NAME_SET_P (decl)))\n+    return false;\n+\n+  const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\n+  return name[0] == '*' && name[1] == 'f';\n+}\n+\n /* Implement TARGET_MD_ASM_ADJUST hook in order to fix up \"f\"\n    constraints when long doubles are stored in vector registers.  */\n \n@@ -16787,9 +16804,24 @@ s390_md_asm_adjust (vec<rtx> &outputs, vec<rtx> &inputs,\n       gcc_assert (allows_reg);\n       gcc_assert (!is_inout);\n       /* Copy output value from a FPR pair into a vector register.  */\n-      rtx fprx2 = gen_reg_rtx (FPRX2mode);\n+      rtx fprx2;\n       push_to_sequence2 (after_md_seq, after_md_end);\n-      emit_insn (gen_fprx2_to_tf (outputs[i], fprx2));\n+      if (s390_hard_fp_reg_p (outputs[i]))\n+\t{\n+\t  fprx2 = gen_rtx_REG (FPRX2mode, REGNO (outputs[i]));\n+\t  /* The first half is already at the correct location, copy only the\n+\t   * second one.  Use the UNSPEC pattern instead of the SUBREG one,\n+\t   * since s390_can_change_mode_class() rejects\n+\t   * (subreg:DF (reg:TF %fN) 8) and thus subreg validation fails.  */\n+\t  rtx v1 = gen_rtx_REG (V2DFmode, REGNO (outputs[i]));\n+\t  rtx v3 = gen_rtx_REG (V2DFmode, REGNO (outputs[i]) + 1);\n+\t  emit_insn (gen_vec_permiv2df (v1, v1, v3, const0_rtx));\n+\t}\n+      else\n+\t{\n+\t  fprx2 = gen_reg_rtx (FPRX2mode);\n+\t  emit_insn (gen_fprx2_to_tf (outputs[i], fprx2));\n+\t}\n       after_md_seq = get_insns ();\n       after_md_end = get_last_insn ();\n       end_sequence ();\n@@ -16813,8 +16845,20 @@ s390_md_asm_adjust (vec<rtx> &outputs, vec<rtx> &inputs,\n \tcontinue;\n       gcc_assert (allows_reg);\n       /* Copy input value from a vector register into a FPR pair.  */\n-      rtx fprx2 = gen_reg_rtx (FPRX2mode);\n-      emit_insn (gen_tf_to_fprx2 (fprx2, inputs[i]));\n+      rtx fprx2;\n+      if (s390_hard_fp_reg_p (inputs[i]))\n+\t{\n+\t  fprx2 = gen_rtx_REG (FPRX2mode, REGNO (inputs[i]));\n+\t  /* Copy only the second half.  */\n+\t  rtx v1 = gen_rtx_REG (V2DFmode, REGNO (inputs[i]) + 1);\n+\t  rtx v2 = gen_rtx_REG (V2DFmode, REGNO (inputs[i]));\n+\t  emit_insn (gen_vec_permiv2df (v1, v2, v1, GEN_INT (3)));\n+\t}\n+      else\n+\t{\n+\t  fprx2 = gen_reg_rtx (FPRX2mode);\n+\t  emit_insn (gen_tf_to_fprx2 (fprx2, inputs[i]));\n+\t}\n       inputs[i] = fprx2;\n       input_modes[i] = FPRX2mode;\n     }"}, {"sha": "2dcaf08f00b1b538f263617f2ae7bf2c41adeb5a", "filename": "gcc/testsuite/gcc.target/s390/vector/long-double-asm-in-out-hard-fp-reg.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f48c335d36674f90046b2823f0ac1c0545dc082/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Flong-double-asm-in-out-hard-fp-reg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f48c335d36674f90046b2823f0ac1c0545dc082/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Flong-double-asm-in-out-hard-fp-reg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Flong-double-asm-in-out-hard-fp-reg.c?ref=4f48c335d36674f90046b2823f0ac1c0545dc082", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=z14 -mzarch --save-temps\" } */\n+/* { dg-do run { target { s390_z14_hw } } } */\n+#include <assert.h>\n+#include <stdint.h>\n+\n+__attribute__ ((noipa)) static long double\n+sqxbr (long double x)\n+{\n+  register long double in asm(\"f0\") = x;\n+  register long double out asm(\"f1\");\n+\n+  asm(\"sqxbr\\t%0,%1\" : \"=f\"(out) : \"f\"(in));\n+  asm(\"# %0\" : \"+f\"(out));\n+\n+  return out;\n+}\n+\n+/* Ideally `vpdi %v3,%v1,%v3,5` should be optimized away, but the compiler\n+ * can't do it, because the UNSPEC pattern operates on the whole register.\n+ * Using the SUBREG pattern solves this problem, but it's fragile.\n+ */\n+/* { dg-final { scan-assembler-times {\\n\\tvpdi\\t%v2,%v0,%v2,5\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\n\\tvpdi\\t%v1,%v1,%v3,0\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\n\\tvpdi\\t%v3,%v1,%v3,5\\n} 1 } } */\n+\n+int\n+main (void)\n+{\n+  long double x = 0x1.0000000000001p+0L,\n+\t      exp = 1.00000000000000011102230246251564788e+0L;\n+  assert (sqxbr (x) == exp);\n+}"}, {"sha": "6c5f88d8652d2c743e6253b794eb2ffd17c3d86c", "filename": "gcc/testsuite/gcc.target/s390/vector/long-double-asm-inout-hard-fp-reg.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f48c335d36674f90046b2823f0ac1c0545dc082/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Flong-double-asm-inout-hard-fp-reg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f48c335d36674f90046b2823f0ac1c0545dc082/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Flong-double-asm-inout-hard-fp-reg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Flong-double-asm-inout-hard-fp-reg.c?ref=4f48c335d36674f90046b2823f0ac1c0545dc082", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=z14 -mzarch --save-temps\" } */\n+/* { dg-do run { target { s390_z14_hw } } } */\n+#include <assert.h>\n+#include <stdint.h>\n+\n+__attribute__ ((noipa)) static long double\n+sqxbr (long double x)\n+{\n+  register long double inout asm(\"f4\") = x;\n+\n+  asm(\"sqxbr\\t%0,%0\" : \"+f\"(inout));\n+  asm(\"# %0\" : \"+f\"(inout));\n+\n+  return inout;\n+}\n+\n+/* Ideally there should be just one `vpdi %v6,%v4,%v6,5`, but the compiler\n+ * can't optimize it away, because the UNSPEC pattern operates on the whole\n+ * register.  Using the SUBREG pattern solves this problem, but it's fragile.\n+ */\n+/* { dg-final { scan-assembler-times {\\n\\tvpdi\\t%v6,%v4,%v6,5\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\n\\tvpdi\\t%v4,%v4,%v6,0\\n} 2 } } */\n+\n+int\n+main (void)\n+{\n+  long double x = 0x1.0000000000001p+0L,\n+\t      exp = 1.00000000000000011102230246251564788e+0L;\n+  assert (sqxbr (x) == exp);\n+}"}]}