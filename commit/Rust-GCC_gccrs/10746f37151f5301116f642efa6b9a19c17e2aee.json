{"sha": "10746f37151f5301116f642efa6b9a19c17e2aee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA3NDZmMzcxNTFmNTMwMTExNmY2NDJlZmE2YjlhMTljMTdlMmFlZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-07-15T20:45:35Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-07-15T20:45:35Z"}, "message": "re PR c++/44909 ([C++0x] Copy constructors implicitly deleted)\n\n\tPR c++/44909\n\t* call.c (add_function_candidate): If we're working on an implicit\n\tdeclaration, don't consider candidates that won't match.\n\t* typeck.c (same_type_ignoring_top_level_qualifiers_p): Now a fn.\n\t* cp-tree.h (same_type_ignoring_top_level_qualifiers_p): Adjust.\n\n\tRevert:\n\t* cp-tree.h (struct lang_type_class): Add has_user_opeq.\n\t(TYPE_HAS_USER_OPEQ): New.\n\t* decl.c (grok_special_member_properties): Set it.\n\t* class.c (add_implicitly_declared_members): Don't lazily declare\n\tconstructors/operator= if a base or member has a user-declared one.\n\t(check_bases_and_members, check_bases): Adjust.\n\t(check_field_decls, check_field_decl): Adjust.\n\nFrom-SVN: r162233", "tree": {"sha": "d24edade7e9292821567ee6d7750184f5d39c55d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d24edade7e9292821567ee6d7750184f5d39c55d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10746f37151f5301116f642efa6b9a19c17e2aee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10746f37151f5301116f642efa6b9a19c17e2aee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10746f37151f5301116f642efa6b9a19c17e2aee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10746f37151f5301116f642efa6b9a19c17e2aee/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8e7af53e4a83fec17fed87aa5193f9144f1061e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7af53e4a83fec17fed87aa5193f9144f1061e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e7af53e4a83fec17fed87aa5193f9144f1061e3"}], "stats": {"total": 217, "additions": 142, "deletions": 75}, "files": [{"sha": "8f0c70aee56b0ba52585d736642b3020d1c8694c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=10746f37151f5301116f642efa6b9a19c17e2aee", "patch": "@@ -1,3 +1,20 @@\n+2010-07-15  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/44909\n+\t* call.c (add_function_candidate): If we're working on an implicit\n+\tdeclaration, don't consider candidates that won't match.\n+\t* typeck.c (same_type_ignoring_top_level_qualifiers_p): Now a fn.\n+\t* cp-tree.h (same_type_ignoring_top_level_qualifiers_p): Adjust.\n+\n+\tRevert:\n+\t* cp-tree.h (struct lang_type_class): Add has_user_opeq.\n+\t(TYPE_HAS_USER_OPEQ): New.\n+\t* decl.c (grok_special_member_properties): Set it.\n+\t* class.c (add_implicitly_declared_members): Don't lazily declare\n+\tconstructors/operator= if a base or member has a user-declared one.\n+\t(check_bases_and_members, check_bases): Adjust.\n+\t(check_field_decls, check_field_decl): Adjust.\n+\n 2010-07-15  Anatoly Sokolov  <aesok@post.ru>\n \n \t* decl.c (integer_three_node): Remove."}, {"sha": "0bc99bfa57d2a5115d7bc1e04776db4f2d86d987", "filename": "gcc/cp/call.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=10746f37151f5301116f642efa6b9a19c17e2aee", "patch": "@@ -1596,6 +1596,27 @@ add_function_candidate (struct z_candidate **candidates,\n   else if (!sufficient_parms_p (parmnode))\n     viable = 0;\n \n+  /* Kludge: When looking for a function from a subobject while generating\n+     an implicit copy/move constructor/operator=, don't consider anything\n+     that takes (a reference to) a different type.  See c++/44909.  */\n+  else if (flags & LOOKUP_SPECULATIVE)\n+    {\n+      if (DECL_CONSTRUCTOR_P (fn))\n+\ti = 1;\n+      else if (DECL_ASSIGNMENT_OPERATOR_P (fn)\n+\t       && DECL_OVERLOADED_OPERATOR_P (fn) == NOP_EXPR)\n+\ti = 2;\n+      else\n+\ti = 0;\n+      if (i && len == i)\n+\t{\n+\t  parmnode = chain_index (i-1, parmlist);\n+\t  if (!(same_type_ignoring_top_level_qualifiers_p\n+\t\t(non_reference (TREE_VALUE (parmnode)), ctype)))\n+\t    viable = 0;\n+\t}\n+    }\n+\n   if (! viable)\n     goto out;\n "}, {"sha": "73bcb7598ee0ed92a1a0a127640735c1c35eb539", "filename": "gcc/cp/class.c", "status": "modified", "additions": 13, "deletions": 60, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=10746f37151f5301116f642efa6b9a19c17e2aee", "patch": "@@ -130,7 +130,7 @@ static void finish_struct_methods (tree);\n static void maybe_warn_about_overly_private_class (tree);\n static int method_name_cmp (const void *, const void *);\n static int resort_method_name_cmp (const void *, const void *);\n-static void add_implicitly_declared_members (tree, int, int, int, int);\n+static void add_implicitly_declared_members (tree, int, int);\n static tree fixed_type_or_null (tree, int *, int *);\n static tree build_simple_base_path (tree expr, tree binfo);\n static tree build_vtbl_ref_1 (tree, tree);\n@@ -139,13 +139,13 @@ static void build_vtbl_initializer (tree, tree, tree, tree, int *,\n static int count_fields (tree);\n static int add_fields_to_record_type (tree, struct sorted_fields_type*, int);\n static bool check_bitfield_decl (tree);\n-static void check_field_decl (tree, tree, int *, int *, int *, int *, int *);\n-static void check_field_decls (tree, tree *, int *, int *, int *, int *);\n+static void check_field_decl (tree, tree, int *, int *, int *);\n+static void check_field_decls (tree, tree *, int *, int *);\n static tree *build_base_field (record_layout_info, tree, splay_tree, tree *);\n static void build_base_fields (record_layout_info, splay_tree, tree *);\n static void check_methods (tree);\n static void remove_zero_width_bit_fields (tree);\n-static void check_bases (tree, int *, int *, int *, int *);\n+static void check_bases (tree, int *, int *);\n static void check_bases_and_members (tree);\n static tree create_vtable_ptr (tree, tree *);\n static void include_empty_classes (record_layout_info);\n@@ -1249,9 +1249,7 @@ handle_using_decl (tree using_decl, tree t)\n static void\n check_bases (tree t,\n \t     int* cant_have_const_ctor_p,\n-\t     int* no_const_asn_ref_p,\n-\t     int* cant_have_lazy_ctor,\n-\t     int* cant_have_lazy_opeq)\n+\t     int* no_const_asn_ref_p)\n {\n   int i;\n   int seen_non_virtual_nearly_empty_base_p;\n@@ -1290,10 +1288,6 @@ check_bases (tree t,\n       if (TYPE_HAS_COPY_ASSIGN (basetype)\n \t  && !TYPE_HAS_CONST_COPY_ASSIGN (basetype))\n \t*no_const_asn_ref_p = 1;\n-      if (TYPE_HAS_USER_CONSTRUCTOR (basetype))\n-\t*cant_have_lazy_ctor = 1;\n-      if (TYPE_HAS_USER_OPEQ (basetype))\n-\t*cant_have_lazy_opeq = 1;\n \n       if (BINFO_VIRTUAL_P (base_binfo))\n \t/* A virtual base does not effect nearly emptiness.  */\n@@ -2634,9 +2628,7 @@ maybe_add_class_template_decl_list (tree type, tree t, int friend_p)\n static void\n add_implicitly_declared_members (tree t,\n \t\t\t\t int cant_have_const_cctor,\n-\t\t\t\t int cant_have_const_assignment,\n-\t\t\t\t int cant_have_lazy_ctor,\n-\t\t\t\t int cant_have_lazy_opeq)\n+\t\t\t\t int cant_have_const_assignment)\n {\n   /* Destructor.  */\n   if (!CLASSTYPE_DESTRUCTORS (t))\n@@ -2690,26 +2682,6 @@ add_implicitly_declared_members (tree t,\n \tCLASSTYPE_LAZY_MOVE_ASSIGN (t) = 1;\n     }\n \n-  /* If a base or member type has a user-declared constructor or operator=,\n-     we need to declare ours now to avoid issues with circular lazy\n-     declarations (cpp0x/implicit6.C).  */\n-  if (cant_have_lazy_ctor)\n-    {\n-      if (CLASSTYPE_LAZY_DEFAULT_CTOR (t))\n-\tlazily_declare_fn (sfk_constructor, t);\n-      if (CLASSTYPE_LAZY_COPY_CTOR (t))\n-\tlazily_declare_fn (sfk_copy_constructor, t);\n-      if (CLASSTYPE_LAZY_MOVE_CTOR (t))\n-\tlazily_declare_fn (sfk_move_constructor, t);\n-    }\n-  if (cant_have_lazy_opeq)\n-    {\n-      if (CLASSTYPE_LAZY_COPY_ASSIGN (t))\n-\tlazily_declare_fn (sfk_copy_assignment, t);\n-      if (CLASSTYPE_LAZY_MOVE_ASSIGN (t))\n-\tlazily_declare_fn (sfk_move_assignment, t);\n-    }\n-\n   /* We can't be lazy about declaring functions that might override\n      a virtual function from a base class.  */\n   if (TYPE_POLYMORPHIC_P (t)\n@@ -2858,9 +2830,7 @@ check_field_decl (tree field,\n \t\t  tree t,\n \t\t  int* cant_have_const_ctor,\n \t\t  int* no_const_asn_ref,\n-\t\t  int* any_default_members,\n-\t\t  int* cant_have_lazy_ctor,\n-\t\t  int* cant_have_lazy_opeq)\n+\t\t  int* any_default_members)\n {\n   tree type = strip_array_types (TREE_TYPE (field));\n \n@@ -2877,8 +2847,7 @@ check_field_decl (tree field,\n       for (fields = TYPE_FIELDS (type); fields; fields = DECL_CHAIN (fields))\n \tif (TREE_CODE (fields) == FIELD_DECL && !DECL_C_BIT_FIELD (field))\n \t  check_field_decl (fields, t, cant_have_const_ctor,\n-\t\t\t    no_const_asn_ref, any_default_members,\n-\t\t\t    cant_have_lazy_ctor, cant_have_lazy_opeq);\n+\t\t\t    no_const_asn_ref, any_default_members);\n     }\n   /* Check members with class type for constructors, destructors,\n      etc.  */\n@@ -2930,11 +2899,6 @@ check_field_decl (tree field,\n       if (TYPE_HAS_COPY_ASSIGN (type)\n \t  && !TYPE_HAS_CONST_COPY_ASSIGN (type))\n \t*no_const_asn_ref = 1;\n-\n-      if (TYPE_HAS_USER_CONSTRUCTOR (type))\n-\t*cant_have_lazy_ctor = 1;\n-      if (TYPE_HAS_USER_OPEQ (type))\n-\t*cant_have_lazy_opeq = 1;\n     }\n   if (DECL_INITIAL (field) != NULL_TREE)\n     {\n@@ -2974,9 +2938,7 @@ check_field_decl (tree field,\n static void\n check_field_decls (tree t, tree *access_decls,\n \t\t   int *cant_have_const_ctor_p,\n-\t\t   int *no_const_asn_ref_p,\n-\t\t   int *cant_have_lazy_ctor_p,\n-\t\t   int *cant_have_lazy_opeq_p)\n+\t\t   int *no_const_asn_ref_p)\n {\n   tree *field;\n   tree *next;\n@@ -3168,9 +3130,7 @@ check_field_decls (tree t, tree *access_decls,\n \tcheck_field_decl (x, t,\n \t\t\t  cant_have_const_ctor_p,\n \t\t\t  no_const_asn_ref_p,\n-\t\t\t  &any_default_members,\n-\t\t\t  cant_have_lazy_ctor_p,\n-\t\t\t  cant_have_lazy_opeq_p);\n+\t\t\t  &any_default_members);\n \n       /* If any field is const, the structure type is pseudo-const.  */\n       if (CP_TYPE_CONST_P (type))\n@@ -4493,8 +4453,6 @@ check_bases_and_members (tree t)\n   /* Nonzero if the implicitly generated assignment operator\n      should take a non-const reference argument.  */\n   int no_const_asn_ref;\n-  int cant_have_lazy_ctor = 0;\n-  int cant_have_lazy_opeq = 0;\n   tree access_decls;\n   bool saved_complex_asn_ref;\n   bool saved_nontrivial_dtor;\n@@ -4507,8 +4465,7 @@ check_bases_and_members (tree t)\n \n   /* Check all the base-classes.  */\n   check_bases (t, &cant_have_const_ctor,\n-\t       &no_const_asn_ref, &cant_have_lazy_ctor,\n-\t       &cant_have_lazy_opeq);\n+\t       &no_const_asn_ref);\n \n   /* Check all the method declarations.  */\n   check_methods (t);\n@@ -4525,9 +4482,7 @@ check_bases_and_members (tree t)\n      being set appropriately.  */\n   check_field_decls (t, &access_decls,\n \t\t     &cant_have_const_ctor,\n-\t\t     &no_const_asn_ref,\n-\t\t     &cant_have_lazy_ctor,\n-\t\t     &cant_have_lazy_opeq);\n+\t\t     &no_const_asn_ref);\n \n   /* A nearly-empty class has to be vptr-containing; a nearly empty\n      class contains just a vptr.  */\n@@ -4599,9 +4554,7 @@ check_bases_and_members (tree t)\n   /* Synthesize any needed methods.  */\n   add_implicitly_declared_members (t,\n \t\t\t\t   cant_have_const_ctor,\n-\t\t\t\t   no_const_asn_ref,\n-\t\t\t\t   cant_have_lazy_ctor,\n-\t\t\t\t   cant_have_lazy_opeq);\n+\t\t\t\t   no_const_asn_ref);\n \n   /* Check defaulted declarations here so we have cant_have_const_ctor\n      and don't need to worry about clones.  */"}, {"sha": "13d43da7dbe83a9df87a721f559081e804512a40", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=10746f37151f5301116f642efa6b9a19c17e2aee", "patch": "@@ -289,11 +289,6 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n #define same_type_p(TYPE1, TYPE2) \\\n   comptypes ((TYPE1), (TYPE2), COMPARE_STRICT)\n \n-/* Returns nonzero iff TYPE1 and TYPE2 are the same type, ignoring\n-   top-level qualifiers.  */\n-#define same_type_ignoring_top_level_qualifiers_p(TYPE1, TYPE2) \\\n-  same_type_p (TYPE_MAIN_VARIANT (TYPE1), TYPE_MAIN_VARIANT (TYPE2))\n-\n /* Nonzero if we are presently building a statement tree, rather\n    than expanding each statement as we encounter it.  */\n #define building_stmt_tree()  (cur_stmt_list != NULL_TREE)\n@@ -1326,7 +1321,6 @@ struct GTY(()) lang_type_class {\n   unsigned lazy_move_assign : 1;\n   unsigned has_complex_move_ctor : 1;\n   unsigned has_complex_move_assign : 1;\n-  unsigned has_user_opeq : 1;\n \n   /* When adding a flag here, consider whether or not it ought to\n      apply to a template instance if it applies to the template.  If\n@@ -1335,7 +1329,7 @@ struct GTY(()) lang_type_class {\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 3;\n+  unsigned dummy : 4;\n \n   tree primary_base;\n   VEC(tree_pair_s,gc) *vcall_indices;\n@@ -3143,10 +3137,6 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    user-declared constructor.  */\n #define TYPE_HAS_USER_CONSTRUCTOR(NODE) (TYPE_LANG_FLAG_1 (NODE))\n \n-/* ...or a user-declared operator=.  */\n-#define TYPE_HAS_USER_OPEQ(NODE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->has_user_opeq)\n-\n /* When appearing in an INDIRECT_REF, it means that the tree structure\n    underneath is actually a call to a constructor.  This is needed\n    when the constructor must initialize local storage (which can\n@@ -5433,6 +5423,7 @@ extern int type_unknown_p\t\t\t(const_tree);\n enum { ce_derived, ce_normal, ce_exact };\n extern bool comp_except_specs\t\t\t(const_tree, const_tree, int);\n extern bool comptypes\t\t\t\t(tree, tree, int);\n+extern bool same_type_ignoring_top_level_qualifiers_p (tree, tree);\n extern bool compparms\t\t\t\t(const_tree, const_tree);\n extern int comp_cv_qualification\t\t(const_tree, const_tree);\n extern int comp_cv_qual_signature\t\t(tree, tree);"}, {"sha": "ddc262b22b66b7789c09d3ce2111dcc95844b02f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=10746f37151f5301116f642efa6b9a19c17e2aee", "patch": "@@ -10292,8 +10292,6 @@ grok_special_member_properties (tree decl)\n \n       int assop = copy_fn_p (decl);\n \n-      if (!DECL_ARTIFICIAL (decl))\n-\tTYPE_HAS_USER_OPEQ (class_type) = 1;\n       if (assop)\n \t{\n \t  TYPE_HAS_COPY_ASSIGN (class_type) = 1;"}, {"sha": "12e76497df18962af81d8022e46f7716c9817a41", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=10746f37151f5301116f642efa6b9a19c17e2aee", "patch": "@@ -1503,6 +1503,18 @@ comptypes (tree t1, tree t2, int strict)\n     return structural_comptypes (t1, t2, strict);\n }\n \n+/* Returns nonzero iff TYPE1 and TYPE2 are the same type, ignoring\n+   top-level qualifiers.  */\n+\n+bool\n+same_type_ignoring_top_level_qualifiers_p (tree type1, tree type2)\n+{\n+  if (type1 == error_mark_node || type2 == error_mark_node)\n+    return false;\n+\n+  return same_type_p (TYPE_MAIN_VARIANT (type1), TYPE_MAIN_VARIANT (type2));\n+}\n+\n /* Returns 1 if TYPE1 is at least as qualified as TYPE2.  */\n \n bool"}, {"sha": "4b409389ec46d8a2bb332db4fe7ec32833ae69ee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10746f37151f5301116f642efa6b9a19c17e2aee", "patch": "@@ -1,3 +1,9 @@\n+2010-07-15  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/44909\n+\t* g++.dg/cpp0x/implicit7.C: New.\n+\t* g++.dg/cpp0x/implicit8.C: New.\n+\n 2010-07-15  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \tDisable float tests for __SPU__ targets due to lack of signed zero:"}, {"sha": "c7902969dce29f0017f1516e79dc1203dd937007", "filename": "gcc/testsuite/g++.dg/cpp0x/implicit6.C", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fimplicit6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fimplicit6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fimplicit6.C?ref=10746f37151f5301116f642efa6b9a19c17e2aee", "patch": "@@ -6,7 +6,6 @@ struct Ray;\n struct Vector\n {\n   virtual void f();\t\t// make non-trivially-copyable\n-  Vector();\n   Vector(const Ray &) ;\n };\n \n@@ -18,7 +17,6 @@ struct array\n struct Ray\n {\n   array a;\n-  operator Vector();\n };\n \n extern Ray r1;"}, {"sha": "f29e5009fbd6f4cbdd51bba8b5311a92180863ed", "filename": "gcc/testsuite/g++.dg/cpp0x/implicit7.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fimplicit7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fimplicit7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fimplicit7.C?ref=10746f37151f5301116f642efa6b9a19c17e2aee", "patch": "@@ -0,0 +1,37 @@\n+// PR c++/44909\n+// { dg-options -std=c++0x }\n+// Declaring A<D<E>>'s copy ctor means choosing a ctor to initialize D<E>,\n+// which means choosing a ctor for C<B<E>>, which meant considering\n+// C(const B<E>&) which means choosing a ctor for B<E>, which means choosing\n+// a ctor for A<D<E>>.  Cycle.\n+\n+template<typename T>\n+struct A\n+{\n+  T t;\n+};\n+\n+template <typename T>\n+struct B\n+{\n+  typename T::U u;\n+};\n+\n+template <typename T>\n+struct C\n+{\n+  C(const T&);\n+};\n+\n+template <typename T>\n+struct D\n+{\n+  C<B<T> > v;\n+};\n+\n+struct E {\n+  typedef A<D<E> > U;\n+};\n+\n+extern A<D<E> > a;\n+A<D<E> > a2(a);"}, {"sha": "2f3febae8b2a61c2ebde744fa321d92c2ff8f34c", "filename": "gcc/testsuite/g++.dg/cpp0x/implicit8.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fimplicit8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10746f37151f5301116f642efa6b9a19c17e2aee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fimplicit8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fimplicit8.C?ref=10746f37151f5301116f642efa6b9a19c17e2aee", "patch": "@@ -0,0 +1,34 @@\n+// The hack for PR c++/44909 breaks this testcase.  We need feedback\n+// from the C++ committee to know how to proceed.\n+// { dg-options -std=c++0x }\n+// { dg-prune-output \"implicitly deleted\" }\n+// { dg-prune-output \"cannot bind\" }\n+// { dg-prune-output \"initializing argument\" }\n+\n+struct A\n+{\n+  A();\n+  A(A&);\n+};\n+\n+struct B;\n+struct BP\n+{\n+  BP(const B&);\n+};\n+\n+struct B\n+{\n+  B();\n+  B(B&&);\n+  B(const BP&);\n+};\n+\n+// If B(B&&) suppresses the B copy constructor, then copying the B\n+// subobject of C should use B(const BP&).  But we ignore that constructor\n+// in order to break the cycle in 44909.  Perhaps the move ctor shouldn't\n+// suppress the copy ctor?\n+struct C: A, B { };\n+\n+C c;\n+C c2(c);\t\t\t// { dg-bogus \"deleted\" \"\" { xfail *-*-* } }"}]}