{"sha": "d43f603d85d1aabb1cd23bd108f57b63ee507930", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQzZjYwM2Q4NWQxYWFiYjFjZDIzYmQxMDhmNTdiNjNlZTUwNzkzMA==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2003-11-22T06:49:21Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2003-11-22T06:49:21Z"}, "message": "re PR c++/5369 (template member friend declaration not honored)\n\n\tPR c++/5369\n\t* friend.c (is_friend): Handle member function of a class\n\ttemplate as template friend.\n\t(do_friend): Likewise.\n\t* decl2.c (check_classfn): Add template_header_p parameter.\n\t* decl.c (start_decl): Adjust check_classfn call.\n\t(grokfndecl): Likewise.\n\t* pt.c (is_specialization_of_friend): New function.\n\t(uses_template_parms_level): Likewise.\n\t(push_template_decl_real): Use uses_template_parms_level.\n\t(tsubst_friend_function): Adjust check_classfn call.\n\t* cp-tree.h (check_classfn): Adjust declaration.\n\t(uses_template_parms_level): Add declaration.\n\t(is_specialization_of_friend): Likewise.\n\n\t* g++.dg/template/memfriend1.C: New test.\n\t* g++.dg/template/memfriend2.C: Likewise.\n\t* g++.dg/template/memfriend3.C: Likewise.\n\t* g++.dg/template/memfriend4.C: Likewise.\n\t* g++.dg/template/memfriend5.C: Likewise.\n\t* g++.dg/template/memfriend6.C: Likewise.\n\t* g++.dg/template/memfriend7.C: Likewise.\n\t* g++.dg/template/memfriend8.C: Likewise.\n\t* g++.old-deja/g++.pt/friend44.C: Remove a bogus error.\n\nFrom-SVN: r73833", "tree": {"sha": "235f9fa2a81fd346b1ecc91dda40c6d2e542d41d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/235f9fa2a81fd346b1ecc91dda40c6d2e542d41d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d43f603d85d1aabb1cd23bd108f57b63ee507930", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d43f603d85d1aabb1cd23bd108f57b63ee507930", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d43f603d85d1aabb1cd23bd108f57b63ee507930", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d43f603d85d1aabb1cd23bd108f57b63ee507930/comments", "author": null, "committer": null, "parents": [{"sha": "646118866e5814988b3bd39ff6fae772b009a47d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/646118866e5814988b3bd39ff6fae772b009a47d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/646118866e5814988b3bd39ff6fae772b009a47d"}], "stats": {"total": 738, "additions": 692, "deletions": 46}, "files": [{"sha": "d047b0a644546d054e12f6ec2c66717c124fa9b3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d43f603d85d1aabb1cd23bd108f57b63ee507930", "patch": "@@ -1,3 +1,20 @@\n+2003-11-22  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/5369\n+\t* friend.c (is_friend): Handle member function of a class\n+\ttemplate as template friend.\n+\t(do_friend): Likewise.\n+\t* decl2.c (check_classfn): Add template_header_p parameter.\n+\t* decl.c (start_decl): Adjust check_classfn call.\n+\t(grokfndecl): Likewise.\n+\t* pt.c (is_specialization_of_friend): New function.\n+\t(uses_template_parms_level): Likewise.\n+\t(push_template_decl_real): Use uses_template_parms_level.\n+\t(tsubst_friend_function): Adjust check_classfn call.\n+\t* cp-tree.h (check_classfn): Adjust declaration.\n+\t(uses_template_parms_level): Add declaration.\n+\t(is_specialization_of_friend): Likewise.\n+\n 2003-11-21  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/12515"}, {"sha": "80414db73a676262936742b4e8764a1463c7ca1e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d43f603d85d1aabb1cd23bd108f57b63ee507930", "patch": "@@ -3718,7 +3718,7 @@ extern void maybe_make_one_only\t(tree);\n extern void grokclassfn\t(tree, tree, enum overload_flags, tree);\n extern tree grok_array_decl (tree, tree);\n extern tree delete_sanity (tree, tree, int, int);\n-extern tree check_classfn (tree, tree);\n+extern tree check_classfn (tree, tree, bool);\n extern void check_member_template (tree);\n extern tree grokfield (tree, tree, tree, tree, tree);\n extern tree grokbitfield (tree, tree, tree);\n@@ -3877,6 +3877,7 @@ extern void redeclare_class_template            (tree, tree);\n extern tree lookup_template_class\t\t(tree, tree, tree, tree, int, tsubst_flags_t);\n extern tree lookup_template_function            (tree, tree);\n extern int uses_template_parms\t\t\t(tree);\n+extern int uses_template_parms_level\t\t(tree, int);\n extern tree instantiate_class_template\t\t(tree);\n extern tree instantiate_template\t\t(tree, tree, tsubst_flags_t);\n extern int fn_type_unification                  (tree, tree, tree, tree, tree, unification_kind_t, int);\n@@ -3894,6 +3895,7 @@ extern int is_member_template                   (tree);\n extern int comp_template_parms                  (tree, tree);\n extern int template_class_depth                 (tree);\n extern int is_specialization_of                 (tree, tree);\n+extern bool is_specialization_of_friend         (tree, tree);\n extern int comp_template_args                   (tree, tree);\n extern void maybe_process_partial_specialization (tree);\n extern void maybe_check_template_type           (tree);"}, {"sha": "a1b320ff3523f447e2c68484beadde8c7fb1096e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d43f603d85d1aabb1cd23bd108f57b63ee507930", "patch": "@@ -3756,7 +3756,9 @@ start_decl (tree declarator,\n \t}\n       else\n \t{\n-\t  tree field = check_classfn (context, decl);\n+\t  tree field = check_classfn (context, decl,\n+\t\t\t\t      processing_template_decl\n+\t\t\t\t      > template_class_depth (context));\n \t  if (field && duplicate_decls (decl, field))\n \t    decl = field;\n \t}\n@@ -5661,7 +5663,9 @@ grokfndecl (tree ctype,\n     {\n       tree old_decl;\n \n-      old_decl = check_classfn (ctype, decl);\n+      old_decl = check_classfn (ctype, decl,\n+\t\t\t\tprocessing_template_decl\n+\t\t\t\t> template_class_depth (ctype));\n \n       if (old_decl && TREE_CODE (old_decl) == TEMPLATE_DECL)\n \t/* Because grokfndecl is always supposed to return a"}, {"sha": "b7774c45df865b5e3c18f4585cd8d057173ea31f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d43f603d85d1aabb1cd23bd108f57b63ee507930", "patch": "@@ -643,10 +643,12 @@ check_java_method (tree method)\n \n /* Sanity check: report error if this function FUNCTION is not\n    really a member of the class (CTYPE) it is supposed to belong to.\n-   CNAME is the same here as it is for grokclassfn above.  */\n+   CNAME is the same here as it is for grokclassfn above.\n+   TEMPLATE_HEADER_P is true when this declaration comes with a\n+   template header.  */\n \n tree\n-check_classfn (tree ctype, tree function)\n+check_classfn (tree ctype, tree function, bool template_header_p)\n {\n   int ix;\n   int is_template;\n@@ -669,7 +671,7 @@ check_classfn (tree ctype, tree function)\n \n   /* OK, is this a definition of a member template?  */\n   is_template = (TREE_CODE (function) == TEMPLATE_DECL\n-\t\t || (processing_template_decl - template_class_depth (ctype)));\n+\t\t || template_header_p);\n \n   ix = lookup_fnfields_1 (complete_type (ctype),\n \t\t\t  DECL_CONSTRUCTOR_P (function) ? ctor_identifier :"}, {"sha": "8605321012c39da62780cb4f0b8157b62900fa81", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 55, "deletions": 34, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=d43f603d85d1aabb1cd23bd108f57b63ee507930", "patch": "@@ -60,25 +60,15 @@ is_friend (tree type, tree supplicant)\n \t      tree friends = FRIEND_DECLS (list);\n \t      for (; friends ; friends = TREE_CHAIN (friends))\n \t\t{\n-\t\t  if (TREE_VALUE (friends) == NULL_TREE)\n-\t\t    continue;\n+\t\t  tree friend = TREE_VALUE (friends);\n \n-\t\t  if (supplicant == TREE_VALUE (friends))\n-\t\t    return 1;\n+\t\t  if (friend == NULL_TREE)\n+\t\t    continue;\n \n-\t\t  /* Temporarily, we are more lenient to deal with\n-\t\t     nested friend functions, for which there can be\n-\t\t     more than one FUNCTION_DECL, despite being the\n-\t\t     same function.  When that's fixed, this bit can\n-\t\t     go.  */\n-\t\t  if (DECL_FUNCTION_MEMBER_P (supplicant)\n-\t\t      && same_type_p (TREE_TYPE (supplicant),\n-\t\t\t\t      TREE_TYPE (TREE_VALUE (friends))))\n+\t\t  if (supplicant == friend)\n \t\t    return 1;\n \n-\t\t  if (TREE_CODE (TREE_VALUE (friends)) == TEMPLATE_DECL\n-\t\t      && is_specialization_of (supplicant, \n-\t\t\t\t\t       TREE_VALUE (friends)))\n+\t\t  if (is_specialization_of_friend (supplicant, friend))\n \t\t    return 1;\n \t\t}\n \t      break;\n@@ -338,8 +328,6 @@ do_friend (tree ctype, tree declarator, tree decl, tree parmdecls,\n \t   tree attrlist, enum overload_flags flags, tree quals,\n \t   int funcdef_flag)\n {\n-  int is_friend_template = 0;\n-\n   /* Every decl that gets here is a friend of something.  */\n   DECL_FRIEND_P (decl) = 1;\n \n@@ -353,39 +341,70 @@ do_friend (tree ctype, tree declarator, tree decl, tree parmdecls,\n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     abort ();\n \n-  is_friend_template = PROCESSING_REAL_TEMPLATE_DECL_P ();\n-\n   if (ctype)\n     {\n+      /* CLASS_TEMPLATE_DEPTH counts the number of template headers for\n+\t the enclosing class.  FRIEND_DEPTH counts the number of template\n+\t headers used for this friend declaration.  TEMPLATE_MEMBER_P is\n+\t true if a template header in FRIEND_DEPTH is intended for\n+\t DECLARATOR.  For example, the code\n+\n+\t   template <class T> struct A {\n+\t     template <class U> struct B {\n+\t       template <class V> template <class W>\n+\t\t friend void C<V>::f(W);\n+\t     };\n+\t   };\n+\n+\t will eventually give the following results\n+\n+\t 1. CLASS_TEMPLATE_DEPTH equals 2 (for `T' and `U').\n+\t 2. FRIEND_DEPTH equals 2 (for `V' and `W').\n+\t 3. TEMPLATE_MEMBER_P is true (for `W').  */\n+\n+      int class_template_depth = template_class_depth (current_class_type);\n+      int friend_depth = processing_template_decl - class_template_depth;\n+      /* We will figure this out later.  */\n+      bool template_member_p = false;\n+\n       tree cname = TYPE_NAME (ctype);\n       if (TREE_CODE (cname) == TYPE_DECL)\n \tcname = DECL_NAME (cname);\n \n       /* A method friend.  */\n-      if (flags == NO_SPECIAL && ctype && declarator == cname)\n+      if (flags == NO_SPECIAL && declarator == cname)\n \tDECL_CONSTRUCTOR_P (decl) = 1;\n \n       /* This will set up DECL_ARGUMENTS for us.  */\n       grokclassfn (ctype, decl, flags, quals);\n \n-      if (is_friend_template)\n-\tdecl = DECL_TI_TEMPLATE (push_template_decl (decl));\n-      else if (DECL_TEMPLATE_INFO (decl))\n-\t;\n-      else if (template_class_depth (current_class_type))\n-\tdecl = push_template_decl_real (decl, /*is_friend=*/1);\n-\n-      /* We can't do lookup in a type that involves template\n-\t parameters.  Instead, we rely on tsubst_friend_function\n-\t to check the validity of the declaration later.  */\n-      if (processing_template_decl)\n-\tadd_friend (current_class_type, decl, /*complain=*/true);\n+      if (friend_depth)\n+\t{\n+\t  if (!uses_template_parms_level (ctype, class_template_depth\n+\t\t\t\t\t\t + friend_depth))\n+\t    template_member_p = true;\n+\t}\n+\n       /* A nested class may declare a member of an enclosing class\n \t to be a friend, so we do lookup here even if CTYPE is in\n \t the process of being defined.  */\n-      else if (COMPLETE_TYPE_P (ctype) || TYPE_BEING_DEFINED (ctype))\n+      if (class_template_depth\n+\t  || COMPLETE_TYPE_P (ctype)\n+\t  || TYPE_BEING_DEFINED (ctype))\n \t{\n-\t  decl = check_classfn (ctype, decl);\n+\t  if (DECL_TEMPLATE_INFO (decl))\n+\t    /* DECL is a template specialization.  No need to\n+\t       build a new TEMPLATE_DECL.  */\n+\t    ;\n+\t  else if (class_template_depth)\n+\t    /* We rely on tsubst_friend_function to check the\n+\t       validity of the declaration later.  */\n+\t    decl = push_template_decl_real (decl, /*is_friend=*/1);\n+\t  else\n+\t    decl = check_classfn (ctype, decl, template_member_p);\n+\n+\t  if (template_member_p && decl && TREE_CODE (decl) == FUNCTION_DECL)\n+\t    decl = DECL_TI_TEMPLATE (decl);\n \n \t  if (decl)\n \t    add_friend (current_class_type, decl, /*complain=*/true);\n@@ -398,6 +417,8 @@ do_friend (tree ctype, tree declarator, tree decl, tree parmdecls,\n      @@ or possibly a friend from a base class ?!?  */\n   else if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n+      int is_friend_template = PROCESSING_REAL_TEMPLATE_DECL_P ();\n+\n       /* Friends must all go through the overload machinery,\n \t even though they may not technically be overloaded.\n "}, {"sha": "9f73174f7c5c416377e9d3d9cb10a24eae2310a4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 147, "deletions": 5, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d43f603d85d1aabb1cd23bd108f57b63ee507930", "patch": "@@ -876,6 +876,140 @@ is_specialization_of (tree decl, tree tmpl)\n   return 0;\n }\n \n+/* Returns nonzero iff DECL is a specialization of friend declaration\n+   FRIEND according to [temp.friend].  */\n+\n+bool\n+is_specialization_of_friend (tree decl, tree friend)\n+{\n+  bool need_template = true;\n+  int template_depth;\n+\n+  my_friendly_assert (TREE_CODE (decl) == FUNCTION_DECL, 0);\n+\n+  /* For [temp.friend/6] when FRIEND is an ordinary member function\n+     of a template class, we want to check if DECL is a specialization\n+     if this.  */\n+  if (TREE_CODE (friend) == FUNCTION_DECL\n+      && DECL_TEMPLATE_INFO (friend)\n+      && !DECL_USE_TEMPLATE (friend))\n+    {\n+      friend = DECL_TI_TEMPLATE (friend);\n+      need_template = false;\n+    }\n+\n+  /* There is nothing to do if this is not a template friend.  */\n+  if (TREE_CODE (friend) != TEMPLATE_DECL)\n+    return 0;\n+\n+  if (is_specialization_of (decl, friend))\n+    return 1;\n+\n+  /* [temp.friend/6]\n+     A member of a class template may be declared to be a friend of a\n+     non-template class.  In this case, the corresponding member of\n+     every specialization of the class template is a friend of the\n+     class granting friendship.\n+     \n+     For example, given a template friend declaration\n+\n+       template <class T> friend void A<T>::f();\n+\n+     the member function below is considered a friend\n+\n+       template <> struct A<int> {\n+\t void f();\n+       };\n+\n+     For this type of template friend, TEMPLATE_DEPTH below will be\n+     non-zero.  To determine if DECL is a friend of FRIEND, we first\n+     check if the enclosing class is a specialization of another.  */\n+\n+  template_depth = template_class_depth (DECL_CONTEXT (friend));\n+  if (template_depth\n+      && DECL_CLASS_SCOPE_P (decl)\n+      && is_specialization_of (TYPE_NAME (DECL_CONTEXT (decl)), \n+\t\t\t       CLASSTYPE_TI_TEMPLATE (DECL_CONTEXT (friend))))\n+    {\n+      /* Next, we check the members themselves.  In order to handle\n+\t a few tricky cases like\n+\n+\t   template <class T> friend void A<T>::g(T t);\n+\t   template <class T> template <T t> friend void A<T>::h();\n+\n+\t we need to figure out what ARGS is (corresponding to `T' in above\n+\t examples) from DECL for later processing.  */\n+\n+      tree context = DECL_CONTEXT (decl);\n+      tree args = NULL_TREE;\n+      int current_depth = 0;\n+      while (current_depth < template_depth)\n+\t{\n+\t  if (CLASSTYPE_TEMPLATE_INFO (context))\n+\t    {\n+\t      if (current_depth == 0)\n+\t\targs = TYPE_TI_ARGS (context);\n+\t      else\n+\t\targs = add_to_template_args (TYPE_TI_ARGS (context), args);\n+\t      current_depth++;\n+\t    }\n+\t  context = TYPE_CONTEXT (context);\n+\t}\n+\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t{\n+\t  bool is_template;\n+\t  tree friend_type;\n+\t  tree decl_type;\n+\t  tree friend_args_type;\n+\t  tree decl_args_type;\n+\n+\t  /* Make sure that both DECL and FRIEND are templates or\n+\t     non-templates.  */\n+\t  is_template = DECL_TEMPLATE_INFO (decl)\n+\t\t\t&& PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (decl));\n+\t  if (need_template ^ is_template)\n+\t    return 0;\n+\t  else if (is_template)\n+\t    {\n+\t      /* If both are templates, check template paramter list.  */\n+\t      tree friend_parms\n+\t\t= tsubst_template_parms (DECL_TEMPLATE_PARMS (friend),\n+\t\t\t\t\t args, tf_none);\n+\t      if (!comp_template_parms\n+\t\t     (DECL_TEMPLATE_PARMS (DECL_TI_TEMPLATE (decl)),\n+\t\t      friend_parms))\n+\t\treturn 0;\n+\n+\t      decl_type = TREE_TYPE (DECL_TI_TEMPLATE (decl));\n+\t    }\n+\t  else\n+\t    decl_type = TREE_TYPE (decl);\n+\n+\t  friend_type = tsubst_function_type (TREE_TYPE (friend), args,\n+\t\t\t\t\t      tf_none, NULL_TREE);\n+\t  if (friend_type == error_mark_node)\n+\t    return 0;\n+\n+\t  /* Check if return types match.  */\n+\t  if (!same_type_p (TREE_TYPE (decl_type), TREE_TYPE (friend_type)))\n+\t    return 0;\n+\n+\t  /* Check if function parameter types match, ignoring the\n+\t     `this' parameter.  */\n+\t  friend_args_type = TYPE_ARG_TYPES (friend_type);\n+\t  decl_args_type = TYPE_ARG_TYPES (decl_type);\n+\t  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (friend))\n+\t    friend_args_type = TREE_CHAIN (friend_args_type);\n+\t  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n+\t    decl_args_type = TREE_CHAIN (decl_args_type);\n+\t  if (compparms (decl_args_type, friend_args_type))\n+\t    return 1;\n+\t}\n+    }\n+  return 0;\n+}\n+\n /* Register the specialization SPEC as a specialization of TMPL with\n    the indicated ARGS.  Returns SPEC, or an equivalent prior\n    declaration, if available.  */\n@@ -2861,10 +2995,8 @@ push_template_decl_real (tree decl, int is_friend)\n \t  /* It is a conversion operator. See if the type converted to\n \t     depends on innermost template operands.  */\n \t  \n-\t  if (for_each_template_parm (TREE_TYPE (TREE_TYPE (tmpl)),\n-\t\t\t\t      template_parm_this_level_p,\n-\t\t\t\t      &depth,\n-\t\t\t\t      NULL))\n+\t  if (uses_template_parms_level (TREE_TYPE (TREE_TYPE (tmpl)),\n+\t\t\t\t\t depth))\n \t    DECL_TEMPLATE_CONV_FN_P (tmpl) = 1;\n \t}\n     }\n@@ -4602,12 +4734,22 @@ for_each_template_parm (tree t, tree_fn_t fn, void* data, htab_t visited)\n   return result;\n }\n \n+/* Returns true if T depends on any template parameter.  */\n+\n int\n uses_template_parms (tree t)\n {\n   return for_each_template_parm (t, 0, 0, NULL);\n }\n \n+/* Returns true if T depends on any template parameter with level LEVEL.  */\n+\n+int\n+uses_template_parms_level (tree t, int level)\n+{\n+  return for_each_template_parm (t, template_parm_this_level_p, &level, NULL);\n+}\n+\n static int tinst_depth;\n extern int max_tinst_depth;\n #ifdef GATHER_STATISTICS\n@@ -4917,7 +5059,7 @@ tsubst_friend_function (tree decl, tree args)\n       /* Check to see that the declaration is really present, and,\n \t possibly obtain an improved declaration.  */\n       tree fn = check_classfn (DECL_CONTEXT (new_friend),\n-\t\t\t       new_friend);\n+\t\t\t       new_friend, false);\n       \n       if (fn)\n \tnew_friend = fn;"}, {"sha": "c339a0da467ab7947665112d96d35689a15702da", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d43f603d85d1aabb1cd23bd108f57b63ee507930", "patch": "@@ -1,3 +1,16 @@\n+2003-11-22  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/5369\n+\t* g++.dg/template/memfriend1.C: New test.\n+\t* g++.dg/template/memfriend2.C: Likewise.\n+\t* g++.dg/template/memfriend3.C: Likewise.\n+\t* g++.dg/template/memfriend4.C: Likewise.\n+\t* g++.dg/template/memfriend5.C: Likewise.\n+\t* g++.dg/template/memfriend6.C: Likewise.\n+\t* g++.dg/template/memfriend7.C: Likewise.\n+\t* g++.dg/template/memfriend8.C: Likewise.\n+\t* g++.old-deja/g++.pt/friend44.C: Remove a bogus error.\n+\n 2003-11-21  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/12515"}, {"sha": "f4541279c8ba5e4e96ca03b1d5d47e4a429297bf", "filename": "gcc/testsuite/g++.dg/template/memfriend1.C", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend1.C?ref=d43f603d85d1aabb1cd23bd108f57b63ee507930", "patch": "@@ -0,0 +1,54 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2003 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+\n+// Member function of class template as friend\n+\n+template<class T> struct A\n+{\n+  void f();\n+};\n+\n+class C {\n+  int i;\n+  template<class T> friend void A<T>::f();\n+};\n+\n+template<class T> struct A<T*>\n+{\n+  void f();\n+};\n+\n+template<> struct A<char>\n+{\n+  void f();\n+};\n+\n+template<class T> void A<T>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+template<class T> void A<T*>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+void A<char>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+int main()\n+{\n+  A<int> a1;\n+  a1.f();\n+  A<int *> a2;\n+  a2.f();\n+  A<char> a3;\n+  a3.f();\n+}"}, {"sha": "364ad7d78645eb3d8fe88f045f34daa1f10c33e5", "filename": "gcc/testsuite/g++.dg/template/memfriend2.C", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend2.C?ref=d43f603d85d1aabb1cd23bd108f57b63ee507930", "patch": "@@ -0,0 +1,61 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2003 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+\n+// Member function template of class template as friend\n+\n+template <class T> struct A\n+{\n+  template <class U> void f();\n+};\n+\n+class C {\n+  int i;\n+  template <class T> template <class U> friend void A<T>::f();\n+};\n+\n+template <class T> struct A<T*>\n+{\n+  template <class U> void f();\n+};\n+\n+template <> struct A<char>\n+{\n+  template <class U> void f();\n+};\n+\n+template <class T> template <class U> void A<T>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+template <class T> template <class U> void A<T*>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+template <class U> void A<char>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+template <> void A<char>::f<int>()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+int main()\n+{\n+  A<int> a1;\n+  a1.f<char>();\n+  A<int *> a2;\n+  a2.f<char>();\n+  A<char> a3;\n+  a3.f<char>();\n+  a3.f<int>();\n+}"}, {"sha": "3ea8c84cf25164be0925064e64f75929e32bcce4", "filename": "gcc/testsuite/g++.dg/template/memfriend3.C", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend3.C?ref=d43f603d85d1aabb1cd23bd108f57b63ee507930", "patch": "@@ -0,0 +1,55 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2003 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+\n+// Member function of class template as friend\n+\n+template<class T> struct A\n+{\n+  void f(T);\n+};\n+\n+class C {\n+  int i;\n+  template<class T> friend void A<T>::f(T);\n+};\n+\n+template<class T> struct A<T*>\n+{\n+  void f(T*);\n+};\n+\n+template<> struct A<char>\n+{\n+  void f(char);\n+};\n+\n+template<class T> void A<T>::f(T)\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+template<class T> void A<T*>::f(T*)\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+void A<char>::f(char)\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+int main()\n+{\n+  A<int> a1;\n+  a1.f(0);\n+  A<int *> a2;\n+  int *p = 0;\n+  a2.f(p);\n+  A<char> a3;\n+  a3.f('a');\n+}"}, {"sha": "5c006fe84f31bc1b8f5e87b4075106a6e532d9d3", "filename": "gcc/testsuite/g++.dg/template/memfriend4.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend4.C?ref=d43f603d85d1aabb1cd23bd108f57b63ee507930", "patch": "@@ -0,0 +1,63 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2003 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+\n+// Member function of class template as friend\n+\n+template<class T> struct A\n+{\n+  template <T t> void f();\n+};\n+\n+class C {\n+  int i;\n+  template<class T> template <T t> friend void A<T>::f();\n+};\n+\n+template<class T> struct A<T*>\n+{\n+  template <T* t> void f();\n+};\n+\n+template<> struct A<char>\n+{\n+  template <char t> void f();\n+};\n+\n+template<class T> template <T t> void A<T>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+template<class T> template <T* t> void A<T*>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+template <char t> void A<char>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+template <> void A<char>::f<'b'>()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+int d2 = 0;\n+\n+int main()\n+{\n+  A<int> a1;\n+  a1.f<0>();\n+  A<int *> a2;\n+  a2.f<&d2>();\n+  A<char> a3;\n+  a3.f<'a'>();\n+  a3.f<'b'>();\n+}"}, {"sha": "38c2fb93fad34d971c1b1ad4935ed6784ff559e4", "filename": "gcc/testsuite/g++.dg/template/memfriend5.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend5.C?ref=d43f603d85d1aabb1cd23bd108f57b63ee507930", "patch": "@@ -0,0 +1,31 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2003 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+\n+// Member template function of member class template as friend\n+\n+template <class T> struct A {\n+  template <class U> struct B {\n+    template <class V> void f(V);\n+  };\n+};\n+\n+class X {\n+  int i;\n+  template <class T> template <class U> template <class V>\n+    friend void A<T>::B<U>::f(V);\n+};\n+\n+template <class T> template <class U> template <class V>\n+  void A<T>::B<U>::f(V)\n+{\n+  X x;\n+  x.i = 0;\n+}\n+\n+int main()\n+{\n+  A<char>::B<char> a1;\n+  a1.f(0);\n+}"}, {"sha": "21d799605ec9df662f04453bb8123e95fd647be6", "filename": "gcc/testsuite/g++.dg/template/memfriend6.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend6.C?ref=d43f603d85d1aabb1cd23bd108f57b63ee507930", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2003 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+\n+// Member function of class template as friend\n+// Erroneous case: mismatch during declaration\n+\n+template <class T> struct A {\n+  template <class U> void f(U);\t\t// { dg-error \"candidate\" }\n+  void g();\t\t\t\t// { dg-error \"candidate\" }\n+  void h();\t\t\t\t// { dg-error \"candidate\" }\n+  void i(int);\t\t\t\t// { dg-error \"candidate\" }\n+};\n+\n+class C {\n+  int ii;\n+  template <class U> friend void A<U>::f(U);\t// { dg-error \"not match\" }\n+  template <class U> template <class V>\n+    friend void A<U>::g();\t\t\t// { dg-error \"not match\" }\n+  template <class U> friend int A<U>::h();\t// { dg-error \"not match\" }\n+  template <class U> friend void A<U>::i(char);\t// { dg-error \"not match\" }\n+};"}, {"sha": "aed029500af7e04a6561cecf0ae968c22614a645", "filename": "gcc/testsuite/g++.dg/template/memfriend7.C", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend7.C?ref=d43f603d85d1aabb1cd23bd108f57b63ee507930", "patch": "@@ -0,0 +1,133 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2003 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+\n+// Member function of class template as friend\n+// Erroneous case: mismatch during specialization\n+\n+template <class T> struct A {\n+  template <class U> void f(U);\n+  void g();\n+  void h();\n+  void i(int);\n+  template <T t> void j();\n+};\n+\n+class C {\n+  int ii;\t\t\t\t// { dg-error \"private\" }\n+  template <class U> template <class V>\n+    friend void A<U>::f(V);\n+  template <class U> friend void A<U>::g();\n+  template <class U> friend void A<U>::h();\n+  template <class U> friend void A<U>::i(int);\n+  template <class U> template <U t>\n+    friend void A<U>::j();\n+};\n+\n+template <class T> struct A<T*> {\n+  void f(int);\n+  template <class U> void g();\n+  int h();\n+  void i(char);\n+  template <int> void j();\n+};\n+\n+template <class T> void A<T*>::f(int)\n+{\n+  C c;\n+  c.ii = 0;\t\t\t\t// { dg-error \"context\" }\n+}\n+\n+template <class T> template <class U> void A<T*>::g()\n+{\n+  C c;\n+  c.ii = 0;\t\t\t\t// { dg-error \"context\" }\n+}\n+\n+template <class T> int A<T*>::h()\n+{\n+  C c;\n+  c.ii = 0;\t\t\t\t// { dg-error \"context\" }\n+}\n+\n+template <class T> void A<T*>::i(char)\n+{\n+  C c;\n+  c.ii = 0;\t\t\t\t// { dg-error \"context\" }\n+}\n+\n+template <class T> template <int> void A<T*>::j()\n+{\n+  C c;\n+  c.ii = 0;\t\t\t\t// { dg-error \"context\" }\n+}\n+\n+template <> struct A<char> {\n+  void f(int);\n+  template <class U> void g();\n+  int h();\n+  void i(char);\n+  template <int> void j();\n+};\n+\n+void A<char>::f(int)\n+{\n+  C c;\n+  c.ii = 0;\t\t\t\t// { dg-error \"context\" }\n+}\n+\n+template <class U> void A<char>::g()\n+{\n+  C c;\n+  c.ii = 0;\t\t\t\t// { dg-error \"context\" }\n+}\n+\n+template <> void A<char>::g<int>()\n+{\n+  C c;\n+  c.ii = 0;\t\t\t\t// { dg-error \"context\" }\n+}\n+\n+int A<char>::h()\n+{\n+  C c;\n+  c.ii = 0;\t\t\t\t// { dg-error \"context\" }\n+}\n+\n+void A<char>::i(char)\n+{\n+  C c;\n+  c.ii = 0;\t\t\t\t// { dg-error \"context\" }\n+}\n+\n+template <int> void A<char>::j()\n+{\n+  C c;\n+  c.ii = 0;\t\t\t\t// { dg-error \"context\" }\n+}\n+\n+template <> void A<char>::j<0>()\n+{\n+  C c;\n+  c.ii = 0;\t\t\t\t// { dg-error \"context\" }\n+}\n+\n+int main()\n+{\n+  A<int *> a1;\n+  a1.f(0);\t\t\t\t// { dg-error \"instantiated\" }\n+  a1.g<char>();\t\t\t\t// { dg-error \"instantiated\" }\n+  a1.g<int>();\t\t\t\t// { dg-error \"instantiated\" }\n+  a1.h();\t\t\t\t// { dg-error \"instantiated\" }\n+  a1.i('a');\t\t\t\t// { dg-error \"instantiated\" }\n+  a1.j<1>();\t\t\t\t// { dg-error \"instantiated\" }\n+  A<char> a2;\n+  a2.f(0);\n+  a2.g<char>();\t\t\t\t// { dg-error \"instantiated\" }\n+  a2.g<int>();\n+  a2.h();\n+  a2.i('a');\n+  a2.j<1>();\t\t\t\t// { dg-error \"instantiated\" }\n+  a2.j<0>();\n+}"}, {"sha": "886096b9d54a1c7d0e9375715a761cafb4fca89f", "filename": "gcc/testsuite/g++.dg/template/memfriend8.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend8.C?ref=d43f603d85d1aabb1cd23bd108f57b63ee507930", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do compile }\n+\n+// Origin: Martin Sebor <sebor@roguewave.com>\n+\n+// PR c++/5369: Member function of class template as friend\n+\n+template <class T>\n+struct S\n+{\n+  int foo () {\n+    return S<int>::bar ();\n+  }\n+\n+private:\n+\n+  template <class U>\n+  friend int S<U>::foo ();\n+\n+  static int bar () { return 0; }\n+};\n+\n+int main ()\n+{\n+  S<char>().foo ();\n+}"}, {"sha": "1f79172906145ec0bf0c85b175cba57b8f80a9f7", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend44.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend44.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43f603d85d1aabb1cd23bd108f57b63ee507930/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend44.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend44.C?ref=d43f603d85d1aabb1cd23bd108f57b63ee507930", "patch": "@@ -23,7 +23,7 @@ public:\n template <class T> int A<T>::f (T)\n {\n   B b;\n-  return b.a; // { dg-bogus \"\" \"\" { xfail *-*-* } }\n+  return b.a;\n }\n \n template <class T> int A<T>::AI::f (T)"}]}