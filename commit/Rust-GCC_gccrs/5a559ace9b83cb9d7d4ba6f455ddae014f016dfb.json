{"sha": "5a559ace9b83cb9d7d4ba6f455ddae014f016dfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE1NTlhY2U5YjgzY2I5ZDdkNGJhNmY0NTVkZGFlMDE0ZjAxNmRmYg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-03-03T17:03:09Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-03-03T17:03:09Z"}, "message": "c++: Unify REQUIRES_EXPR evaluation / diagnostic routines\n\nThis folds the diagnose_requires_expr routines into the corresponding\ntsubst_requires_expr ones.  This is achieved by making the latter\nroutines take a sat_info instead of a subst_info, and assigning the\nappropriate meanings to the flags sat_info::noisy and\nsat_info::diagnose_unsatisfaction_p during tsubst_requires_expr:\ninfo.noisy() controls whether to diagnose invalid types and expressions\ninside the requirements, and info.diagnose_unsatisfaction_p() controls\nwhether to additionally diagnose why the requires-expression evaluates\nto false.\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (struct sat_info): Document the different\n\tmeanings of noisy() and diagnose_unsatisfaction_p() during\n\tsatisfaction and requires-expression evaluation.\n\t(tsubst_valid_expression_requirement): Take a sat_info instead\n\tof a subst_info.  Perform the substitution quietly first.  Fold\n\tin error-replaying code from diagnose_valid_expression.\n\t(tsubst_simple_requirement): Take a sat_info instead of a\n\tsubst_info.\n\t(tsubst_type_requirement_1): New.  Fold in error-replaying code\n\tfrom diagnose_valid_type.\n\t(tsubst_type_requirement): Use the above.  Take a sat_info\n\tinstead of a subst_info.\n\t(tsubst_compound_requirement): Likewise.  Fold in\n\terror-replaying code from diagnose_compound_requirement.\n\t(tsubst_nested_requirement): Take a sat_info instead of a\n\tsubst_info.  Fold in error-replaying code from\n\tdiagnose_nested_requirement.\n\t(tsubst_requirement): Take a sat_info instead of a subst_info.\n\t(tsubst_requires_expr): Split into two versions, one that takes\n\ta sat_info argument and another that takes a complain and\n\tin_decl argument.  Remove outdated documentation.  Document the\n\teffects of the sat_info argument.  Don't short-circuit\n\tprocessing of requirements when diagnosing unsatisfaction,\n\tmirroring diagnose_requires_expr.\n\t(satisfy_nondeclaration_constraint) <case REQUIRES_EXPR>: Remove\n\tassert, and se the three-parameter version of tsubst_requires_expr.\n\t(diagnose_trait_expr): Make static.  Take a template argument\n\tvector instead of a parameter mapping.\n\t(diagnose_valid_expression): Remove.\n\t(diagnose_valid_type): Remove.\n\t(diagnose_simple_requirement): Remove.\n\t(diagnose_compound_requirement): Remove.\n\t(diagnose_type_requirement): Remove.\n\t(diagnose_nested_requirement): Remove.\n\t(diagnose_requirement): Remove.\n\t(diagnose_requires_expr): Remove.\n\t(diagnose_atomic_constraint): Take a sat_info instead of a\n\tsubst_info.  Adjust call to diagnose_trait_expr.  Call\n\ttsubst_requires_expr instead of diagnose_requires_expr.\n\t(diagnose_constraints): Remove special casing of REQUIRES_EXPR\n\tand just always call constraint_satisfaction_value.", "tree": {"sha": "1c70d2db0efd8149d43aed9b2ab13890384feb37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c70d2db0efd8149d43aed9b2ab13890384feb37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a559ace9b83cb9d7d4ba6f455ddae014f016dfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a559ace9b83cb9d7d4ba6f455ddae014f016dfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a559ace9b83cb9d7d4ba6f455ddae014f016dfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a559ace9b83cb9d7d4ba6f455ddae014f016dfb/comments", "author": null, "committer": null, "parents": [{"sha": "662ef5b54de8f77080a19e03f31b162c04ba273f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/662ef5b54de8f77080a19e03f31b162c04ba273f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/662ef5b54de8f77080a19e03f31b162c04ba273f"}], "stats": {"total": 448, "additions": 193, "deletions": 255}, "files": [{"sha": "5cf43bd6c18a56b5ee2e413e5598d0bd1f4057ed", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 193, "deletions": 255, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a559ace9b83cb9d7d4ba6f455ddae014f016dfb/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a559ace9b83cb9d7d4ba6f455ddae014f016dfb/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=5a559ace9b83cb9d7d4ba6f455ddae014f016dfb", "patch": "@@ -100,17 +100,31 @@ struct subst_info\n \n /* Provides additional context for satisfaction.\n \n-   The flag noisy() controls whether to diagnose ill-formed satisfaction,\n-   such as the satisfaction value of an atom being non-bool or non-constant.\n-\n-   The flag diagnose_unsatisfaction_p() controls whether to explain why\n-   a constraint is not satisfied.\n-\n-   The entrypoints to satisfaction for which we set noisy+unsat are\n-   diagnose_constraints and diagnose_nested_requirement.  The entrypoint for\n-   which we set noisy-unsat is the replay inside constraint_satisfaction_value.\n-   From constraints_satisfied_p, we enter satisfaction quietly (both flags\n-   cleared).  */\n+   During satisfaction:\n+    - The flag noisy() controls whether to diagnose ill-formed satisfaction,\n+      such as the satisfaction value of an atom being non-bool or non-constant.\n+    - The flag diagnose_unsatisfaction_p() controls whether to additionally\n+      explain why a constraint is not satisfied.\n+    - We enter satisfaction with noisy+unsat from diagnose_constraints.\n+    - We enter satisfaction with noisy-unsat from the replay inside\n+      constraint_satisfaction_value.\n+    - We enter satisfaction quietly (both flags cleared) from\n+      constraints_satisfied_p.\n+\n+   During evaluation of a requires-expression:\n+    - The flag noisy() controls whether to diagnose ill-formed types and\n+      expressions inside its requirements.\n+    - The flag diagnose_unsatisfaction_p() controls whether to additionally\n+      explain why the requires-expression evaluates to false.\n+    - We enter tsubst_requires_expr with noisy+unsat from\n+      diagnose_atomic_constraint and potentially from\n+      satisfy_nondeclaration_constraints.\n+    - We enter tsubst_requires_expr with noisy-unsat from\n+      cp_parser_requires_expression when processing a requires-expression that\n+      appears outside a template.\n+    - We enter tsubst_requires_expr quietly (both flags cleared) when\n+      substituting through a requires-expression as part of template\n+      instantiation.  */\n \n struct sat_info : subst_info\n {\n@@ -1926,22 +1940,44 @@ hash_placeholder_constraint (tree c)\n   return val;\n }\n \n-/* Substitute through the simple requirement.  */\n+/* Substitute through the expression of a simple requirement or\n+   compound requirement.  */\n \n static tree\n-tsubst_valid_expression_requirement (tree t, tree args, subst_info info)\n+tsubst_valid_expression_requirement (tree t, tree args, sat_info info)\n {\n-  tree r = tsubst_expr (t, args, info.complain, info.in_decl, false);\n-  if (convert_to_void (r, ICV_STATEMENT, info.complain) == error_mark_node)\n-    return error_mark_node;\n-  return r;\n+  tree r = tsubst_expr (t, args, tf_none, info.in_decl, false);\n+  if (convert_to_void (r, ICV_STATEMENT, tf_none) != error_mark_node)\n+    return r;\n+\n+  if (info.diagnose_unsatisfaction_p ())\n+    {\n+      location_t loc = cp_expr_loc_or_input_loc (t);\n+      if (diagnosing_failed_constraint::replay_errors_p ())\n+\t{\n+\t  inform (loc, \"the required expression %qE is invalid, because\", t);\n+\t  if (r == error_mark_node)\n+\t    tsubst_expr (t, args, info.complain, info.in_decl, false);\n+\t  else\n+\t    convert_to_void (r, ICV_STATEMENT, info.complain);\n+\t}\n+      else\n+\tinform (loc, \"the required expression %qE is invalid\", t);\n+    }\n+  else if (info.noisy ())\n+    {\n+      r = tsubst_expr (t, args, info.complain, info.in_decl, false);\n+      convert_to_void (r, ICV_STATEMENT, info.complain);\n+    }\n+\n+  return error_mark_node;\n }\n \n \n /* Substitute through the simple requirement.  */\n \n static tree\n-tsubst_simple_requirement (tree t, tree args, subst_info info)\n+tsubst_simple_requirement (tree t, tree args, sat_info info)\n {\n   tree t0 = TREE_OPERAND (t, 0);\n   tree expr = tsubst_valid_expression_requirement (t0, args, info);\n@@ -1950,13 +1986,41 @@ tsubst_simple_requirement (tree t, tree args, subst_info info)\n   return boolean_true_node;\n }\n \n+/* Subroutine of tsubst_type_requirement that performs the actual substitution\n+   and diagnosing.  Also used by tsubst_compound_requirement.  */\n+\n+static tree\n+tsubst_type_requirement_1 (tree t, tree args, sat_info info, location_t loc)\n+{\n+  tree r = tsubst (t, args, tf_none, info.in_decl);\n+  if (r != error_mark_node)\n+    return r;\n+\n+  if (info.diagnose_unsatisfaction_p ())\n+    {\n+      if (diagnosing_failed_constraint::replay_errors_p ())\n+\t{\n+\t  /* Replay the substitution error.  */\n+\t  inform (loc, \"the required type %qT is invalid, because\", t);\n+\t  tsubst (t, args, info.complain, info.in_decl);\n+\t}\n+      else\n+\tinform (loc, \"the required type %qT is invalid\", t);\n+    }\n+  else if (info.noisy ())\n+    tsubst (t, args, info.complain, info.in_decl);\n+\n+  return error_mark_node;\n+}\n+\n+\n /* Substitute through the type requirement.  */\n \n static tree\n-tsubst_type_requirement (tree t, tree args, subst_info info)\n+tsubst_type_requirement (tree t, tree args, sat_info info)\n {\n   tree t0 = TREE_OPERAND (t, 0);\n-  tree type = tsubst (t0, args, info.complain, info.in_decl);\n+  tree type = tsubst_type_requirement_1 (t0, args, info, EXPR_LOCATION (t));\n   if (type == error_mark_node)\n     return error_mark_node;\n   return boolean_true_node;\n@@ -2013,21 +2077,28 @@ expression_convertible_p (tree expr, tree type, subst_info info)\n /* Substitute through the compound requirement.  */\n \n static tree\n-tsubst_compound_requirement (tree t, tree args, subst_info info)\n+tsubst_compound_requirement (tree t, tree args, sat_info info)\n {\n   tree t0 = TREE_OPERAND (t, 0);\n   tree t1 = TREE_OPERAND (t, 1);\n   tree expr = tsubst_valid_expression_requirement (t0, args, info);\n   if (expr == error_mark_node)\n     return error_mark_node;\n \n+  location_t loc = cp_expr_loc_or_input_loc (expr);\n+\n   /* Check the noexcept condition.  */\n   bool noexcept_p = COMPOUND_REQ_NOEXCEPT_P (t);\n   if (noexcept_p && !expr_noexcept_p (expr, tf_none))\n-    return error_mark_node;\n+    {\n+      if (info.diagnose_unsatisfaction_p ())\n+\tinform (loc, \"%qE is not %<noexcept%>\", expr);\n+      else\n+\treturn error_mark_node;\n+    }\n \n   /* Substitute through the type expression, if any.  */\n-  tree type = tsubst (t1, args, info.complain, info.in_decl);\n+  tree type = tsubst_type_requirement_1 (t1, args, info, EXPR_LOCATION (t));\n   if (type == error_mark_node)\n     return error_mark_node;\n \n@@ -2039,29 +2110,76 @@ tsubst_compound_requirement (tree t, tree args, subst_info info)\n       if (tree placeholder = type_uses_auto (type))\n \t{\n \t  if (!type_deducible_p (expr, type, placeholder, args, quiet))\n-\t    return error_mark_node;\n+\t    {\n+\t      if (info.diagnose_unsatisfaction_p ())\n+\t\t{\n+\t\t  if (diagnosing_failed_constraint::replay_errors_p ())\n+\t\t    {\n+\t\t      inform (loc,\n+\t\t\t      \"%qE does not satisfy return-type-requirement, \"\n+\t\t\t      \"because\", t0);\n+\t\t      /* Further explain the reason for the error.  */\n+\t\t      type_deducible_p (expr, type, placeholder, args, info);\n+\t\t    }\n+\t\t  else\n+\t\t    inform (loc,\n+\t\t\t    \"%qE does not satisfy return-type-requirement\", t0);\n+\t\t}\n+\t      return error_mark_node;\n+\t    }\n \t}\n       else if (!expression_convertible_p (expr, type, quiet))\n-\treturn error_mark_node;\n+\t{\n+\t  if (info.diagnose_unsatisfaction_p ())\n+\t    {\n+\t      if (diagnosing_failed_constraint::replay_errors_p ())\n+\t\t{\n+\t\t  inform (loc, \"cannot convert %qE to %qT because\", t0, type);\n+\t\t  /* Further explain the reason for the error.  */\n+\t\t  expression_convertible_p (expr, type, info);\n+\t\t}\n+\t      else\n+\t\tinform (loc, \"cannot convert %qE to %qT\", t0, type);\n+\t    }\n+\t  return error_mark_node;\n+\t}\n     }\n \n   return boolean_true_node;\n }\n \n+/* Substitute through the nested requirement.  */\n+\n static tree\n-tsubst_nested_requirement (tree t, tree args, subst_info info)\n+tsubst_nested_requirement (tree t, tree args, sat_info info)\n {\n   sat_info quiet (tf_none, info.in_decl);\n   tree result = constraint_satisfaction_value (t, args, quiet);\n-  if (result != boolean_true_node)\n-    return error_mark_node;\n-  return boolean_true_node;\n+  if (result == boolean_true_node)\n+    return boolean_true_node;\n+\n+  if (result == boolean_false_node\n+      && info.diagnose_unsatisfaction_p ())\n+    {\n+      tree expr = TREE_OPERAND (t, 0);\n+      location_t loc = cp_expr_location (t);\n+      if (diagnosing_failed_constraint::replay_errors_p ())\n+\t{\n+\t  /* Replay the substitution error.  */\n+\t  inform (loc, \"nested requirement %qE is not satisfied, because\", expr);\n+\t  constraint_satisfaction_value (t, args, info);\n+\t}\n+      else\n+\tinform (loc, \"nested requirement %qE is not satisfied\", expr);\n+    }\n+\n+  return error_mark_node;\n }\n \n /* Substitute ARGS into the requirement T.  */\n \n static tree\n-tsubst_requirement (tree t, tree args, subst_info info)\n+tsubst_requirement (tree t, tree args, sat_info info)\n {\n   iloc_sentinel loc_s (cp_expr_location (t));\n   switch (TREE_CODE (t))\n@@ -2151,30 +2269,22 @@ tsubst_constraint_variables (tree t, tree args, subst_info info)\n    in its requirements ... In such cases, the expression evaluates\n    to false; it does not cause the program to be ill-formed.\n \n-   However, there are cases where substitution must produce a\n-   new requires-expression, that is not a template constraint.\n-   For example:\n+   When substituting through a REQUIRES_EXPR as part of template\n+   instantiation, we call this routine with info.quiet() true.\n \n-        template<typename T>\n-        class X {\n-          template<typename U>\n-          static constexpr bool var = requires (U u) { T::fn(u); };\n-        };\n+   When evaluating a REQUIRES_EXPR that appears outside a template in\n+   cp_parser_requires_expression, we call this routine with\n+   info.noisy() true.\n \n-   In the instantiation of X<Y> (assuming Y defines fn), then the\n-   instantiated requires-expression would include Y::fn(u). If any\n-   substitution in the requires-expression fails, we can immediately\n-   fold the expression to false, as would be the case e.g., when\n-   instantiation X<int>.  */\n+   Finally, when diagnosing unsatisfaction from diagnose_atomic_constraint\n+   and when diagnosing a false REQUIRES_EXPR via diagnose_constraints,\n+   we call this routine with info.diagnose_unsatisfaction_p() true.  */\n \n-tree\n-tsubst_requires_expr (tree t, tree args,\n-\t\t      tsubst_flags_t complain, tree in_decl)\n+static tree\n+tsubst_requires_expr (tree t, tree args, sat_info info)\n {\n   local_specialization_stack stack (lss_copy);\n \n-  subst_info info (complain, in_decl);\n-\n   /* A requires-expression is an unevaluated context.  */\n   cp_unevaluated u;\n \n@@ -2186,7 +2296,7 @@ tsubst_requires_expr (tree t, tree args,\n \t checked out of order, so instead just remember the template\n \t arguments and wait until we can substitute them all at once.  */\n       t = copy_node (t);\n-      REQUIRES_EXPR_EXTRA_ARGS (t) = build_extra_args (t, args, complain);\n+      REQUIRES_EXPR_EXTRA_ARGS (t) = build_extra_args (t, args, info.complain);\n       return t;\n     }\n \n@@ -2197,14 +2307,30 @@ tsubst_requires_expr (tree t, tree args,\n \treturn boolean_false_node;\n     }\n \n+  tree result = boolean_true_node;\n   for (tree reqs = REQUIRES_EXPR_REQS (t); reqs; reqs = TREE_CHAIN (reqs))\n     {\n       tree req = TREE_VALUE (reqs);\n-      tree result = tsubst_requirement (req, args, info);\n-      if (result == error_mark_node)\n-\treturn boolean_false_node;\n+      if (tsubst_requirement (req, args, info) == error_mark_node)\n+\t{\n+\t  result = boolean_false_node;\n+\t  if (info.diagnose_unsatisfaction_p ())\n+\t    /* Keep going so that we diagnose all failed requirements.  */;\n+\t  else\n+\t    break;\n+\t}\n     }\n-  return boolean_true_node;\n+  return result;\n+}\n+\n+/* Public wrapper for the above.  */\n+\n+tree\n+tsubst_requires_expr (tree t, tree args,\n+\t\t      tsubst_flags_t complain, tree in_decl)\n+{\n+  sat_info info (complain, in_decl);\n+  return tsubst_requires_expr (t, args, info);\n }\n \n /* Substitute ARGS into the constraint information CI, producing a new\n@@ -2790,7 +2916,7 @@ get_mapped_args (tree map)\n   return args;\n }\n \n-static void diagnose_atomic_constraint (tree, tree, tree, subst_info);\n+static void diagnose_atomic_constraint (tree, tree, tree, sat_info);\n \n /* Compute the satisfaction of an atomic constraint.  */\n \n@@ -2976,14 +3102,10 @@ satisfy_nondeclaration_constraints (tree t, tree args, sat_info info)\n   /* Handle REQUIRES_EXPR directly, bypassing satisfaction.  */\n   if (TREE_CODE (t) == REQUIRES_EXPR)\n     {\n-      /* TODO: Remove this assert and the special casing of REQUIRES_EXPRs\n-\t from diagnose_constraints once we merge tsubst_requires_expr and\n-\t diagnose_requires_expr.  */\n-      gcc_assert (!info.diagnose_unsatisfaction_p ());\n       auto ovr = make_temp_override (current_constraint_diagnosis_depth);\n       if (info.noisy ())\n \t++current_constraint_diagnosis_depth;\n-      return tsubst_requires_expr (t, args, info.complain, info.in_decl);\n+      return tsubst_requires_expr (t, args, info);\n     }\n \n   /* Get the normalized constraints.  */\n@@ -3466,11 +3588,10 @@ get_constraint_error_location (tree t)\n \n /* Emit a diagnostic for a failed trait.  */\n \n-void\n-diagnose_trait_expr (tree expr, tree map)\n+static void\n+diagnose_trait_expr (tree expr, tree args)\n {\n   location_t loc = cp_expr_location (expr);\n-  tree args = get_mapped_args (map);\n \n   /* Build a \"fake\" version of the instantiated trait, so we can\n      get the instantiated types from result.  */\n@@ -3550,192 +3671,11 @@ diagnose_trait_expr (tree expr, tree map)\n     }\n }\n \n-static tree\n-diagnose_valid_expression (tree expr, tree args, tree in_decl)\n-{\n-  tree result = tsubst_expr (expr, args, tf_none, in_decl, false);\n-  if (result != error_mark_node\n-      && convert_to_void (result, ICV_STATEMENT, tf_none) != error_mark_node)\n-    return result;\n-\n-  location_t loc = cp_expr_loc_or_input_loc (expr);\n-  if (diagnosing_failed_constraint::replay_errors_p ())\n-    {\n-      /* Replay the substitution error.  */\n-      inform (loc, \"the required expression %qE is invalid, because\", expr);\n-      if (result == error_mark_node)\n-\ttsubst_expr (expr, args, tf_error, in_decl, false);\n-      else\n-\tconvert_to_void (result, ICV_STATEMENT, tf_error);\n-    }\n-  else\n-    inform (loc, \"the required expression %qE is invalid\", expr);\n-\n-  return error_mark_node;\n-}\n-\n-static tree\n-diagnose_valid_type (tree type, tree args, tree in_decl)\n-{\n-  tree result = tsubst (type, args, tf_none, in_decl);\n-  if (result != error_mark_node)\n-    return result;\n-\n-  location_t loc = cp_expr_loc_or_input_loc (type);\n-  if (diagnosing_failed_constraint::replay_errors_p ())\n-    {\n-      /* Replay the substitution error.  */\n-      inform (loc, \"the required type %qT is invalid, because\", type);\n-      tsubst (type, args, tf_error, in_decl);\n-    }\n-  else\n-    inform (loc, \"the required type %qT is invalid\", type);\n-\n-  return error_mark_node;\n-}\n-\n-static void\n-diagnose_simple_requirement (tree req, tree args, tree in_decl)\n-{\n-  diagnose_valid_expression (TREE_OPERAND (req, 0), args, in_decl);\n-}\n-\n-static void\n-diagnose_compound_requirement (tree req, tree args, tree in_decl)\n-{\n-  tree expr = TREE_OPERAND (req, 0);\n-  expr = diagnose_valid_expression (expr, args, in_decl);\n-  if (expr == error_mark_node)\n-    return;\n-\n-  location_t loc = cp_expr_loc_or_input_loc (expr);\n-\n-  /* Check the noexcept condition.  */\n-  if (COMPOUND_REQ_NOEXCEPT_P (req) && !expr_noexcept_p (expr, tf_none))\n-    inform (loc, \"%qE is not %<noexcept%>\", expr);\n-\n-  tree type = TREE_OPERAND (req, 1);\n-  type = diagnose_valid_type (type, args, in_decl);\n-  if (type == error_mark_node)\n-    return;\n-\n-  if (type)\n-    {\n-      subst_info quiet (tf_none, in_decl);\n-      subst_info noisy (tf_error, in_decl);\n-\n-      /* Check the expression against the result type.  */\n-      if (tree placeholder = type_uses_auto (type))\n-\t{\n-\t  if (!type_deducible_p (expr, type, placeholder, args, quiet))\n-\t    {\n-\t      tree orig_expr = TREE_OPERAND (req, 0);\n-\t      if (diagnosing_failed_constraint::replay_errors_p ())\n-\t\t{\n-\t\t  inform (loc,\n-\t\t\t  \"%qE does not satisfy return-type-requirement, \"\n-\t\t\t  \"because\", orig_expr);\n-\t\t  /* Further explain the reason for the error.  */\n-\t\t  type_deducible_p (expr, type, placeholder, args, noisy);\n-\t\t}\n-\t      else\n-\t\tinform (loc, \"%qE does not satisfy return-type-requirement\",\n-\t\t\torig_expr);\n-\t    }\n-\t}\n-      else if (!expression_convertible_p (expr, type, quiet))\n-\t{\n-\t  tree orig_expr = TREE_OPERAND (req, 0);\n-\t  if (diagnosing_failed_constraint::replay_errors_p ())\n-\t    {\n-\t      inform (loc, \"cannot convert %qE to %qT because\", orig_expr, type);\n-\t      /* Further explain the reason for the error.  */\n-\t      expression_convertible_p (expr, type, noisy);\n-\t    }\n-\t  else\n-\t    inform (loc, \"cannot convert %qE to %qT\", orig_expr, type);\n-\t}\n-    }\n-}\n-\n-static void\n-diagnose_type_requirement (tree req, tree args, tree in_decl)\n-{\n-  tree type = TREE_OPERAND (req, 0);\n-  diagnose_valid_type (type, args, in_decl);\n-}\n-\n-static void\n-diagnose_nested_requirement (tree req, tree args)\n-{\n-  /* Quietly check for satisfaction first.  */\n-  sat_info quiet (tf_none, NULL_TREE);\n-  tree result = satisfy_nondeclaration_constraints (req, args, quiet);\n-  if (result == boolean_true_node)\n-    return;\n-\n-  tree expr = TREE_OPERAND (req, 0);\n-  location_t loc = cp_expr_location (expr);\n-  if (diagnosing_failed_constraint::replay_errors_p ())\n-    {\n-      /* Replay the substitution error with re-normalized requirements.  */\n-      inform (loc, \"nested requirement %qE is not satisfied, because\", expr);\n-\n-      sat_info noisy (tf_warning_or_error, NULL_TREE, /*diag_unsat=*/true);\n-      satisfy_nondeclaration_constraints (req, args, noisy);\n-    }\n-  else\n-    inform (loc, \"nested requirement %qE is not satisfied\", expr);\n-\n-}\n-\n-static void\n-diagnose_requirement (tree req, tree args, tree in_decl)\n-{\n-  iloc_sentinel loc_s (cp_expr_location (req));\n-  switch (TREE_CODE (req))\n-    {\n-    case SIMPLE_REQ:\n-      return diagnose_simple_requirement (req, args, in_decl);\n-    case COMPOUND_REQ:\n-      return diagnose_compound_requirement (req, args, in_decl);\n-    case TYPE_REQ:\n-      return diagnose_type_requirement (req, args, in_decl);\n-    case NESTED_REQ:\n-      return diagnose_nested_requirement (req, args);\n-    default:\n-       gcc_unreachable ();\n-    }\n-}\n-\n-static void\n-diagnose_requires_expr (tree expr, tree map, tree in_decl)\n-{\n-  local_specialization_stack stack (lss_copy);\n-  tree parms = TREE_OPERAND (expr, 0);\n-  tree body = TREE_OPERAND (expr, 1);\n-  tree args = get_mapped_args (map);\n-\n-  cp_unevaluated u;\n-  subst_info info (tf_warning_or_error, NULL_TREE);\n-  tree vars = tsubst_constraint_variables (parms, args, info);\n-  if (vars == error_mark_node)\n-    return;\n-\n-  tree p = body;\n-  while (p)\n-    {\n-      tree req = TREE_VALUE (p);\n-      diagnose_requirement (req, args, in_decl);\n-      p = TREE_CHAIN (p);\n-    }\n-}\n-\n /* Diagnose a substitution failure in the atomic constraint T when applied\n    with the instantiated parameter mapping MAP.  */\n \n static void\n-diagnose_atomic_constraint (tree t, tree map, tree result, subst_info info)\n+diagnose_atomic_constraint (tree t, tree map, tree result, sat_info info)\n {\n   /* If the constraint is already ill-formed, we've previously diagnosed\n      the reason. We should still say why the constraints aren't satisfied.  */\n@@ -3756,13 +3696,19 @@ diagnose_atomic_constraint (tree t, tree map, tree result, subst_info info)\n   /* Generate better diagnostics for certain kinds of expressions.  */\n   tree expr = ATOMIC_CONSTR_EXPR (t);\n   STRIP_ANY_LOCATION_WRAPPER (expr);\n+  tree args = get_mapped_args (map);\n   switch (TREE_CODE (expr))\n     {\n     case TRAIT_EXPR:\n-      diagnose_trait_expr (expr, map);\n+      diagnose_trait_expr (expr, args);\n       break;\n     case REQUIRES_EXPR:\n-      diagnose_requires_expr (expr, map, info.in_decl);\n+      gcc_checking_assert (info.diagnose_unsatisfaction_p ());\n+      /* Clear in_decl before replaying the substitution to avoid emitting\n+\t seemingly unhelpful \"in declaration ...\" notes that follow some\n+\t substitution failure error messages.  */\n+      info.in_decl = NULL_TREE;\n+      tsubst_requires_expr (expr, args, info);\n       break;\n     default:\n       if (!same_type_p (TREE_TYPE (result), boolean_type_node))\n@@ -3827,15 +3773,7 @@ diagnose_constraints (location_t loc, tree t, tree args)\n \n   /* Replay satisfaction, but diagnose unsatisfaction.  */\n   sat_info noisy (tf_warning_or_error, NULL_TREE, /*diag_unsat=*/true);\n-  if (TREE_CODE (t) == REQUIRES_EXPR)\n-    {\n-      gcc_assert (!args);\n-      ++current_constraint_diagnosis_depth;\n-      diagnose_requires_expr (t, /*map=*/NULL_TREE, /*in_decl=*/NULL_TREE);\n-      --current_constraint_diagnosis_depth;\n-    }\n-  else\n-    constraint_satisfaction_value (t, args, noisy);\n+  constraint_satisfaction_value (t, args, noisy);\n \n   static bool suggested_p;\n   if (concepts_diagnostics_max_depth_exceeded_p"}]}