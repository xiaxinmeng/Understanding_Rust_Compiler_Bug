{"sha": "2a2ab3f96a2acd47e9736aa77e9eebb4a2550398", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEyYWIzZjk2YTJhY2Q0N2U5NzM2YWE3N2U5ZWViYjRhMjU1MDM5OA==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-02-01T06:00:10Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-02-01T06:00:10Z"}, "message": "Initial revision\n\nFrom-SVN: r264", "tree": {"sha": "18a8d2ce4828395a0e6d6363b7f7550e770ade3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18a8d2ce4828395a0e6d6363b7f7550e770ade3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a2ab3f96a2acd47e9736aa77e9eebb4a2550398", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a2ab3f96a2acd47e9736aa77e9eebb4a2550398", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a2ab3f96a2acd47e9736aa77e9eebb4a2550398", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a2ab3f96a2acd47e9736aa77e9eebb4a2550398/comments", "author": null, "committer": null, "parents": [{"sha": "8b62f241abd4d68df89826780294b3f4dc47133c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b62f241abd4d68df89826780294b3f4dc47133c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b62f241abd4d68df89826780294b3f4dc47133c"}], "stats": {"total": 2541, "additions": 2541, "deletions": 0}, "files": [{"sha": "5c9820d8c1550044f5f0db8a7aac86d62faa669c", "filename": "gcc/config/i386/i386.c", "status": "added", "additions": 1874, "deletions": 0, "changes": 1874, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2ab3f96a2acd47e9736aa77e9eebb4a2550398/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2ab3f96a2acd47e9736aa77e9eebb4a2550398/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2a2ab3f96a2acd47e9736aa77e9eebb4a2550398", "patch": "@@ -0,0 +1,1874 @@\n+/* Subroutines for insn-output.c for Intel 80386.\n+   Copyright (C) 1988 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+\n+#define AT_BP(mode) (gen_rtx (MEM, (mode), frame_pointer_rtx))\n+\n+extern FILE *asm_out_file;\n+extern char *strcat ();\n+\n+char *singlemove_string ();\n+char *output_move_const_single ();\n+\n+static char *hi_reg_name[] = HI_REGISTER_NAMES;\n+static char *qi_reg_name[] = QI_REGISTER_NAMES;\n+static char *qi_high_reg_name[] = QI_HIGH_REGISTER_NAMES;\n+\f\n+/* Output an insn whose source is a 386 integer register.  SRC is the\n+   rtx for the register, and TEMPLATE is the op-code template.  SRC may\n+   be either SImode or DImode.\n+\n+   The template will be output with operands[0] as SRC, and operands[1]\n+   as a pointer to the top of the 386 stack.  So a call from floatsidf2\n+   would look like this:\n+\n+      output_op_from_reg (operands[1], AS1 (fild%z0,%1));\n+\n+   where %z0 corresponds to the caller's operands[1], and is used to\n+   emit the proper size suffix.\n+\n+   ??? Extend this to handle HImode - a 387 can load and store HImode\n+   values directly. */\n+\n+void\n+output_op_from_reg (src, template)\n+     rtx src;\n+     char *template;\n+{\n+  rtx xops[4];\n+\n+  xops[0] = src;\n+  xops[1] = AT_SP (Pmode);\n+  xops[2] = gen_rtx (CONST_INT, VOIDmode, GET_MODE_SIZE (GET_MODE (src)));\n+  xops[3] = stack_pointer_rtx;\n+\n+  if (GET_MODE_SIZE (GET_MODE (src)) > UNITS_PER_WORD)\n+    {\n+      rtx high = gen_rtx (REG, SImode, REGNO (src) + 1);\n+      output_asm_insn (AS1 (push%L0,%0), &high);\n+    }\n+  output_asm_insn (AS1 (push%L0,%0), &src);\n+\n+  output_asm_insn (template, xops);\n+\n+  output_asm_insn (AS2 (add%L3,%2,%3), xops);\n+}\n+\f\n+/* Output an insn to pop an value from the 387 top-of-stack to 386\n+   register DEST. The 387 register stack is popped if DIES is true.  If\n+   the mode of DEST is an integer mode, a `fist' integer store is done,\n+   otherwise a `fst' float store is done. */\n+\n+void\n+output_to_reg (dest, dies)\n+     rtx dest;\n+     int dies;\n+{\n+  rtx xops[4];\n+\n+  xops[0] = AT_SP (Pmode);\n+  xops[1] = stack_pointer_rtx;\n+  xops[2] = gen_rtx (CONST_INT, VOIDmode, GET_MODE_SIZE (GET_MODE (dest)));\n+  xops[3] = dest;\n+\n+  output_asm_insn (AS2 (sub%L1,%2,%1), xops);\n+\n+  if (GET_MODE_CLASS (GET_MODE (dest)) == MODE_INT)\n+    {\n+      if (dies)\n+\toutput_asm_insn (AS1 (fistp%z3,%y0), xops);\n+      else\n+\toutput_asm_insn (AS1 (fist%z3,%y0), xops);\n+    }\n+  else if (GET_MODE_CLASS (GET_MODE (dest)) == MODE_FLOAT)\n+    {\n+      if (dies)\n+\toutput_asm_insn (AS1 (fstp%z3,%y0), xops);\n+      else\n+\toutput_asm_insn (AS1 (fst%z3,%y0), xops);\n+    }\n+  else\n+    abort ();\n+\n+  output_asm_insn (AS1 (pop%L0,%0), &dest);\n+\n+  if (GET_MODE_SIZE (GET_MODE (dest)) > UNITS_PER_WORD)\n+    {\n+      dest = gen_rtx (REG, SImode, REGNO (dest) + 1);\n+      output_asm_insn (AS1 (pop%L0,%0), &dest);\n+    }\n+}\n+\f\n+char *\n+singlemove_string (operands)\n+     rtx *operands;\n+{\n+  rtx x;\n+  if (GET_CODE (operands[0]) == MEM\n+      && GET_CODE (x = XEXP (operands[0], 0)) == PRE_DEC)\n+    {\n+      if (XEXP (x, 0) != stack_pointer_rtx)\n+\tabort ();\n+      return \"push%L1 %1\";\n+    }\n+  else if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+    {\n+      return output_move_const_single (operands);\n+    }\n+  else if (GET_CODE (operands[0]) == REG || GET_CODE (operands[1]) == REG)\n+    return AS2 (mov%L0,%1,%0);\n+  else if (CONSTANT_P (operands[1]))\n+    return AS2 (mov%L0,%1,%0);\n+  else\n+    {\n+      output_asm_insn (\"push%L1 %1\", operands);\n+      return \"pop%L0 %0\";\n+    }\n+}\n+\f\n+/* Return a REG that occurs in ADDR with coefficient 1.\n+   ADDR can be effectively incremented by incrementing REG.  */\n+\n+static rtx\n+find_addr_reg (addr)\n+     rtx addr;\n+{\n+  while (GET_CODE (addr) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (addr, 0)) == REG)\n+\taddr = XEXP (addr, 0);\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\taddr = XEXP (addr, 1);\n+      else if (CONSTANT_P (XEXP (addr, 0)))\n+\taddr = XEXP (addr, 1);\n+      else if (CONSTANT_P (XEXP (addr, 1)))\n+\taddr = XEXP (addr, 0);\n+      else\n+\tabort ();\n+    }\n+  if (GET_CODE (addr) == REG)\n+    return addr;\n+  abort ();\n+}\n+\n+/* Output an insn to add the constant N to the register X.  */\n+\n+static void\n+asm_add (n, x)\n+     int n;\n+     rtx x;\n+{\n+  rtx xops[2];\n+  xops[1] = x;\n+  if (n < 0)\n+    {\n+      xops[0] = gen_rtx (CONST_INT, VOIDmode, -n);\n+      output_asm_insn (AS2 (sub%L0,%0,%1), xops);\n+    }\n+  else if (n > 0)\n+    {\n+      xops[0] = gen_rtx (CONST_INT, VOIDmode, n);\n+      output_asm_insn (AS2 (add%L0,%0,%1), xops);\n+    }\n+}\n+\n+/* Output assembler code to perform a doubleword move insn\n+   with operands OPERANDS.  */\n+\n+char *\n+output_move_double (operands)\n+     rtx *operands;\n+{\n+  enum {REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n+  rtx latehalf[2];\n+  rtx addreg0 = 0, addreg1 = 0;\n+\n+  /* First classify both operands.  */\n+\n+  if (REG_P (operands[0]))\n+    optype0 = REGOP;\n+  else if (offsettable_memref_p (operands[0]))\n+    optype0 = OFFSOP;\n+  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n+    optype0 = POPOP;\n+  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+    optype0 = PUSHOP;\n+  else if (GET_CODE (operands[0]) == MEM)\n+    optype0 = MEMOP;\n+  else\n+    optype0 = RNDOP;\n+\n+  if (REG_P (operands[1]))\n+    optype1 = REGOP;\n+  else if (CONSTANT_P (operands[1]))\n+    optype1 = CNSTOP;\n+  else if (offsettable_memref_p (operands[1]))\n+    optype1 = OFFSOP;\n+  else if (GET_CODE (XEXP (operands[1], 0)) == POST_INC)\n+    optype1 = POPOP;\n+  else if (GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)\n+    optype1 = PUSHOP;\n+  else if (GET_CODE (operands[1]) == MEM)\n+    optype1 = MEMOP;\n+  else\n+    optype1 = RNDOP;\n+\n+  /* Check for the cases that the operand constraints are not\n+     supposed to allow to happen.  Abort if we get one,\n+     because generating code for these cases is painful.  */\n+\n+  if (optype0 == RNDOP || optype1 == RNDOP)\n+    abort ();\n+\n+  /* If one operand is decrementing and one is incrementing\n+     decrement the former register explicitly\n+     and change that operand into ordinary indexing.  */\n+\n+  if (optype0 == PUSHOP && optype1 == POPOP)\n+    {\n+      operands[0] = XEXP (XEXP (operands[0], 0), 0);\n+      asm_add (-8, operands[0]);\n+      operands[0] = gen_rtx (MEM, DImode, operands[0]);\n+      optype0 = OFFSOP;\n+    }\n+  if (optype0 == POPOP && optype1 == PUSHOP)\n+    {\n+      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n+      asm_add (-8, operands[1]);\n+      operands[1] = gen_rtx (MEM, DImode, operands[1]);\n+      optype1 = OFFSOP;\n+    }\n+\n+  /* If an operand is an unoffsettable memory ref, find a register\n+     we can increment temporarily to make it refer to the second word.  */\n+\n+  if (optype0 == MEMOP)\n+    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n+\n+  if (optype1 == MEMOP)\n+    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n+\n+  /* Ok, we can do one word at a time.\n+     Normally we do the low-numbered word first,\n+     but if either operand is autodecrementing then we\n+     do the high-numbered word first.\n+\n+     In either case, set up in LATEHALF the operands to use\n+     for the high-numbered word and in some cases alter the\n+     operands in OPERANDS to be suitable for the low-numbered word.  */\n+\n+  if (optype0 == REGOP)\n+    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else if (optype0 == OFFSOP)\n+    latehalf[0] = adj_offsettable_operand (operands[0], 4);\n+  else\n+    latehalf[0] = operands[0];\n+\n+  if (optype1 == REGOP)\n+    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  else if (optype1 == OFFSOP)\n+    latehalf[1] = adj_offsettable_operand (operands[1], 4);\n+  else if (optype1 == CNSTOP)\n+    {\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\tsplit_double (operands[1], &operands[1], &latehalf[1]);\n+      else if (CONSTANT_P (operands[1]))\n+\tlatehalf[1] = const0_rtx;\n+    }\n+  else\n+    latehalf[1] = operands[1];\n+\n+  /* If insn is effectively movd N (sp),-(sp) then we will do the\n+     high word first.  We should use the adjusted operand 1 (which is N+4 (sp))\n+     for the low word as well, to compensate for the first decrement of sp.  */\n+  if (optype0 == PUSHOP\n+      && REGNO (XEXP (XEXP (operands[0], 0), 0)) == STACK_POINTER_REGNUM\n+      && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))\n+    operands[1] = latehalf[1];\n+\n+  /* If one or both operands autodecrementing,\n+     do the two words, high-numbered first.  */\n+\n+  /* Likewise,  the first move would clobber the source of the second one,\n+     do them in the other order.  This happens only for registers;\n+     such overlap can't happen in memory unless the user explicitly\n+     sets it up, and that is an undefined circumstance.  */\n+\n+  if (optype0 == PUSHOP || optype1 == PUSHOP\n+      || (optype0 == REGOP && optype1 == REGOP\n+\t  && REGNO (operands[0]) == REGNO (latehalf[1])))\n+    {\n+      /* Make any unoffsettable addresses point at high-numbered word.  */\n+      if (addreg0)\n+\tasm_add (4, addreg0);\n+      if (addreg1)\n+\tasm_add (4, addreg1);\n+\n+      /* Do that word.  */\n+      output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+      /* Undo the adds we just did.  */\n+      if (addreg0)\n+         asm_add (-4, addreg0);\n+      if (addreg1)\n+\tasm_add (-4, addreg1);\n+\n+      /* Do low-numbered word.  */\n+      return singlemove_string (operands);\n+    }\n+\n+  /* Normal case: do the two words, low-numbered first.  */\n+\n+  output_asm_insn (singlemove_string (operands), operands);\n+\n+  /* Make any unoffsettable addresses point at high-numbered word.  */\n+  if (addreg0)\n+    asm_add (4, addreg0);\n+  if (addreg1)\n+    asm_add (4, addreg1);\n+\n+  /* Do that word.  */\n+  output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+  /* Undo the adds we just did.  */\n+  if (addreg0)\n+    asm_add (-4, addreg0);\n+  if (addreg1)\n+    asm_add (-4, addreg1);\n+\n+  return \"\";\n+}\n+\f\n+int\n+standard_80387_constant_p (x)\n+     rtx x;\n+{\n+  union real_extract u;\n+  register double d;\n+\n+  bcopy (&CONST_DOUBLE_LOW (x), &u, sizeof u);\n+  d = u.d;\n+\n+  if (d == 0)\n+    return 1;\n+\n+  if (d == 1)\n+    return 2;\n+\n+  /* Note that on the 80387, other constants, such as pi,\n+     are much slower to load as standard constants\n+     than to load from doubles in memory!  */\n+\n+  return 0;\n+}\n+\n+char *\n+output_move_const_single (operands)\n+     rtx *operands;\n+{\n+  if (FP_REG_P (operands[0]))\n+    {\n+      int conval = standard_80387_constant_p (operands[1]);\n+\n+      if (conval == 1)\n+\treturn \"fldz\";\n+\n+      if (conval == 2)\n+\treturn \"fld1\";\n+    }\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+    {\n+      union { int i[2]; double d;} u1;\n+      union { int i; float f;} u2;\n+      u1.i[0] = CONST_DOUBLE_LOW (operands[1]);\n+      u1.i[1] = CONST_DOUBLE_HIGH (operands[1]);\n+      u2.f = u1.d;\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, u2.i);\n+    }\n+  return singlemove_string (operands);\n+}\n+\f\n+/* Returns 1 if OP is either a symbol reference or a sum of a symbol\n+   reference and a constant.  */\n+\n+int\n+symbolic_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 1;\n+    case CONST:\n+      op = XEXP (op, 0);\n+      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+    default:\n+      return 0;\n+    }\n+}\n+\f\n+/* Returns 1 if OP contains a symbol reference */\n+\n+int\n+symbolic_reference_mentioned_p (op)\n+     rtx op;\n+{\n+  register char *fmt;\n+  register int i;\n+\n+  if (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF)\n+    return 1;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (op));\n+  for (i = GET_RTX_LENGTH (GET_CODE (op)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\n+\t  for (j = XVECLEN (op, i) - 1; j >= 0; j--)\n+\t    if (symbolic_reference_mentioned_p (XVECEXP (op, i, j)))\n+\t      return 1;\n+\t}\n+      else if (fmt[i] == 'e' && symbolic_reference_mentioned_p (XEXP (op, i)))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\f\n+/* Return a legitimate reference for ORIG (an address) using the\n+   register REG.  If REG is 0, a new pseudo is generated.\n+\n+   There are three types of references that must be handled:\n+\n+   1. Global data references must load the address from the GOT, via\n+      the PIC reg.  An insn is emitted to do this load, and the reg is\n+      returned.\n+\n+   2. Static data references must compute the address as an offset\n+      from the GOT, whose base is in the PIC reg.  An insn is emitted to\n+      compute the address into a reg, and the reg is returned.  Static\n+      data objects have SYMBOL_REF_FLAG set to differentiate them from\n+      global data objects.\n+\n+   3. Constant pool addresses must be handled special.  They are\n+      considered legitimate addresses, but only if not used with regs.\n+      When printed, the output routines know to print the reference with the\n+      PIC reg, even though the PIC reg doesn't appear in the RTL.\n+\n+   GO_IF_LEGITIMATE_ADDRESS rejects symbolic references unless the PIC\n+   reg also appears in the address (except for constant pool references,\n+   noted above).\n+\n+   \"switch\" statements also require special handling when generating\n+   PIC code.  See comments by the `casesi' insn in i386.md for details.  */\n+\n+rtx\n+legitimize_pic_address (orig, reg)\n+     rtx orig;\n+     rtx reg;\n+{\n+  rtx addr = orig;\n+  rtx new = orig;\n+\n+  if (GET_CODE (addr) == SYMBOL_REF || GET_CODE (addr) == LABEL_REF)\n+    {\n+      if (GET_CODE (addr) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (addr))\n+\treg = new = orig;\n+      else\n+\t{\n+\t  if (reg == 0)\n+\t    reg = gen_reg_rtx (Pmode);\n+\n+\t  if (GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_FLAG (addr))\n+\t    new = gen_rtx (PLUS, Pmode, pic_offset_table_rtx, orig);\n+\t  else\n+\t    new = gen_rtx (MEM, Pmode,\n+\t\t\t   gen_rtx (PLUS, Pmode,\n+\t\t\t\t    pic_offset_table_rtx, orig));\n+\n+\t  emit_move_insn (reg, new);\n+\t}\n+      current_function_uses_pic_offset_table = 1;\n+      return reg;\n+    }\n+  else if (GET_CODE (addr) == CONST || GET_CODE (addr) == PLUS)\n+    {\n+      rtx base;\n+\n+      if (GET_CODE (addr) == CONST)\n+\t{\n+\t  addr = XEXP (addr, 0);\n+\t  if (GET_CODE (addr) != PLUS)\n+\t    abort ();\n+\t}\n+\n+      if (XEXP (addr, 0) == pic_offset_table_rtx)\n+\treturn orig;\n+\n+      if (reg == 0)\n+\treg = gen_reg_rtx (Pmode);\n+\n+      base = legitimize_pic_address (XEXP (addr, 0), reg);\n+      addr = legitimize_pic_address (XEXP (addr, 1), base == reg ? 0 : reg);\n+\n+      if (GET_CODE (addr) == CONST_INT)\n+\treturn plus_constant (base, INTVAL (addr));\n+\n+      if (GET_CODE (addr) == PLUS && CONSTANT_P (XEXP (addr, 1)))\n+\t{\n+\t  base = gen_rtx (PLUS, Pmode, base, XEXP (addr, 0));\n+\t  addr = XEXP (addr, 1);\n+\t}\n+\treturn gen_rtx (PLUS, Pmode, base, addr);\n+    }\n+  return new;\n+}\n+\f\n+/* Emit insns to move operands[1] into operands[0].  */\n+\n+void\n+emit_pic_move (operands, mode)\n+     rtx *operands;\n+     enum machine_mode mode;\n+{\n+  rtx temp = reload_in_progress ? operands[0] : gen_reg_rtx (Pmode);\n+\n+  if (GET_CODE (operands[0]) == MEM && SYMBOLIC_CONST (operands[1]))\n+    operands[1] = (rtx) force_reg (SImode, operands[1]);\n+  else\n+    operands[1] = legitimize_pic_address (operands[1], temp);\n+}\n+\f\n+/* This function generates the assembly code for function entry.\n+   FILE is an stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate. */\n+\n+void\n+function_prologue (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  register int regno;\n+  int limit;\n+  rtx xops[4];\n+\n+  xops[0] = stack_pointer_rtx;\n+  xops[1] = frame_pointer_rtx;\n+  xops[2] = gen_rtx (CONST_INT, VOIDmode, size);\n+  if (frame_pointer_needed)\n+    {\n+      output_asm_insn (\"push%L1 %1\", xops);\n+      output_asm_insn (AS2 (mov%L0,%0,%1), xops);\n+    }\n+\n+  if (size)\n+    output_asm_insn (AS2 (sub%L0,%2,%0), xops);\n+\n+  /* Note If use enter it is NOT reversed args.\n+     This one is not reversed from intel!!\n+     I think enter is slower.  Also sdb doesn't like it.\n+     But if you want it the code is:\n+     {\n+     xops[3] = const0_rtx;\n+     output_asm_insn (\"enter %2,%3\", xops);\n+     }\n+     */\n+  limit = (frame_pointer_needed ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n+  for (regno = limit - 1; regno >= 0; regno--)\n+    if ((regs_ever_live[regno] && ! call_used_regs[regno])\n+\t|| (current_function_uses_pic_offset_table\n+\t    && regno == PIC_OFFSET_TABLE_REGNUM))\n+      {\n+\txops[0] = gen_rtx (REG, SImode, regno);\n+\toutput_asm_insn (\"push%L0 %0\", xops);\n+      }\n+\n+  if (current_function_uses_pic_offset_table)\n+    {\n+      xops[0] = pic_offset_table_rtx;\n+      xops[1] = (rtx) gen_label_rtx ();\n+\n+      output_asm_insn (AS1 (call,%P1), xops);\n+      ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (xops[1]));\n+      output_asm_insn (AS1 (pop%L0,%0), xops);\n+      output_asm_insn (\"addl $_GLOBAL_OFFSET_TABLE_+[.-%P1],%0\", xops);\n+    }\n+}\n+\n+/* Return 1 if it is appropriate to emit `ret' instructions in the\n+   body of a function.  Do this only if the epilogue is simple, needing a\n+   couple of insns.  Prior to reloading, we can't tell how many registers\n+   must be saved, so return 0 then.\n+\n+   If NON_SAVING_SETJMP is defined and true, then it is not possible\n+   for the epilogue to be simple, so return 0.  This is a special case\n+   since NON_SAVING_SETJMP will not cause regs_ever_live to change until\n+   final, but jump_optimize may need to know sooner if a `return' is OK.  */\n+\n+int\n+simple_386_epilogue ()\n+{\n+  int regno;\n+  int nregs = 0;\n+  int reglimit = (frame_pointer_needed\n+\t\t  ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n+\n+#ifdef NON_SAVING_SETJMP\n+  if (NON_SAVING_SETJMP && current_function_calls_setjmp)\n+    return 0;\n+#endif\n+\n+  if (! reload_completed)\n+    return 0;\n+\n+  for (regno = reglimit - 1; regno >= 0; regno--)\n+    if ((regs_ever_live[regno] && ! call_used_regs[regno])\n+\t|| (current_function_uses_pic_offset_table\n+\t    && regno == PIC_OFFSET_TABLE_REGNUM))\n+      nregs++;\n+\n+  return nregs == 0 || ! frame_pointer_needed;\n+}\n+\n+/* This function generates the assembly code for function exit.\n+   FILE is an stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to deallocate. */\n+\n+void\n+function_epilogue (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  register int regno;\n+  register int nregs, limit;\n+  int offset;\n+  rtx xops[3];\n+\n+  /* Compute the number of registers to pop */\n+\n+  limit = (frame_pointer_needed\n+\t   ? FRAME_POINTER_REGNUM\n+\t   : STACK_POINTER_REGNUM);\n+\n+  nregs = 0;\n+\n+  for (regno = limit - 1; regno >= 0; regno--)\n+    if ((regs_ever_live[regno] && ! call_used_regs[regno])\n+\t|| (current_function_uses_pic_offset_table\n+\t    && regno == PIC_OFFSET_TABLE_REGNUM))\n+      nregs++;\n+\n+  /* sp is often  unreliable so we must go off the frame pointer,\n+   */\n+\n+  /* In reality, we may not care if sp is unreliable, because we can\n+     restore the register relative to the frame pointer.  In theory,\n+     since each move is the same speed as a pop, and we don't need the\n+     leal, this is faster.  For now restore multiple registers the old\n+     way. */\n+\n+  offset = -size - (nregs * UNITS_PER_WORD);\n+\n+  xops[2] = stack_pointer_rtx;\n+\n+  if (nregs > 1 || ! frame_pointer_needed)\n+    {\n+      if (frame_pointer_needed)\n+\t{\n+\t  xops[0] = adj_offsettable_operand (AT_BP (Pmode), offset);\n+\t  output_asm_insn (AS2 (lea%L2,%0,%2), xops);\n+\t}\n+\n+      for (regno = 0; regno < limit; regno++)\n+\tif ((regs_ever_live[regno] && ! call_used_regs[regno])\n+\t    || (current_function_uses_pic_offset_table\n+\t\t&& regno == PIC_OFFSET_TABLE_REGNUM))\n+\t  {\n+\t    xops[0] = gen_rtx (REG, SImode, regno);\n+\t    output_asm_insn (\"pop%L0 %0\", xops);\n+\t  }\n+    }\n+  else\n+    for (regno = 0; regno < limit; regno++)\n+      if ((regs_ever_live[regno] && ! call_used_regs[regno])\n+\t  || (current_function_uses_pic_offset_table\n+\t      && regno == PIC_OFFSET_TABLE_REGNUM))\n+\t{\n+\t  xops[0] = gen_rtx (REG, SImode, regno);\n+\t  xops[1] = adj_offsettable_operand (AT_BP (Pmode), offset);\n+\t  output_asm_insn (AS2 (mov%L0,%1,%0), xops);\n+\t  offset += 4;\n+\t}\n+\n+  if (frame_pointer_needed)\n+    {\n+      /* On i486, mov & pop is faster than \"leave\". */\n+\n+      if (TARGET_486)\n+\t{\n+\t  xops[0] = frame_pointer_rtx;\n+\t  output_asm_insn (AS2 (mov%L2,%0,%2), xops);\n+\t  output_asm_insn (\"pop%L0 %0\", xops);\n+\t}\n+      else\n+\toutput_asm_insn (\"leave\", xops);\n+    }\n+  else if (size)\n+    {\n+      /* If there is no frame pointer, we must still release the frame. */\n+\n+      xops[0] = gen_rtx (CONST_INT, VOIDmode, size);\n+      output_asm_insn (AS2 (add%L2,%0,%2), xops);\n+    }\n+\n+  if (current_function_pops_args && current_function_args_size)\n+    {\n+      xops[1] = gen_rtx (CONST_INT, VOIDmode, current_function_pops_args);\n+\n+      /* i386 can only pop 32K bytes (maybe 64K?  Is it signed?).  If\n+\t asked to pop more, pop return address, do explicit add, and jump\n+\t indirectly to the caller. */\n+\n+      if (current_function_pops_args >= 32768)\n+\t{\n+\t  /* ??? Which register to use here? */\n+\t  xops[0] = gen_rtx (REG, SImode, 2);\n+\t  output_asm_insn (\"pop%L0 %0\", xops);\n+\t  output_asm_insn (AS2 (add%L2,%1,%2), xops);\n+\t  output_asm_insn (\"jmp %*%0\", xops);\n+\t}\n+      else\n+\t  output_asm_insn (\"ret %1\", xops);\n+    }\n+  else if (current_function_returns_struct)\n+    {\n+      xops[0] = gen_rtx (CONST_INT, VOIDmode, 4);\n+      output_asm_insn (\"ret %0\", xops);\n+    }\n+  else\n+    output_asm_insn (\"ret\", xops);\n+}\n+\f\n+/* Print an integer constant expression in assembler syntax.  Addition\n+   and subtraction are the only arithmetic that may appear in these\n+   expressions.  FILE is the stdio stream to write to, X is the rtx, and\n+   CODE is the operand print code from the output string.  */\n+\n+static void\n+output_pic_addr_const (file, x, code)\n+     FILE *file;\n+     rtx x;\n+     int code;\n+{\n+  char buf[256];\n+\n+  switch (GET_CODE (x))\n+    {\n+    case PC:\n+      if (flag_pic)\n+\tputc ('.', file);\n+      else\n+\tabort ();\n+      break;\n+\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      if (GET_CODE (x) == SYMBOL_REF)\n+\tassemble_name (file, XSTR (x, 0));\n+      else\n+\t{\n+\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"L\",\n+\t\t\t\t       CODE_LABEL_NUMBER (XEXP (x, 0)));\n+\t  assemble_name (asm_out_file, buf);\n+\t}\n+\n+      if (GET_CODE (x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (x))\n+\tfprintf (file, \"@GOTOFF(%%ebx)\");\n+      else if (code == 'P')\n+\tfprintf (file, \"@PLT\");\n+      else if (GET_CODE (x) == LABEL_REF || ! SYMBOL_REF_FLAG (x))\n+\tfprintf (file, \"@GOT\");\n+      else\n+\tfprintf (file, \"@GOTOFF\");\n+\n+      break;\n+\n+    case CODE_LABEL:\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (x));\n+      assemble_name (asm_out_file, buf);\n+      break;\n+\n+    case CONST_INT:\n+      fprintf (file, \"%d\", INTVAL (x));\n+      break;\n+\n+    case CONST:\n+      /* This used to output parentheses around the expression,\n+\t but that does not work on the 386 (either ATT or BSD assembler).  */\n+      output_pic_addr_const (file, XEXP (x, 0), code);\n+      break;\n+\n+    case CONST_DOUBLE:\n+      if (GET_MODE (x) == VOIDmode)\n+\t{\n+\t  /* We can use %d if the number is <32 bits and positive.  */\n+\t  if (CONST_DOUBLE_HIGH (x) || CONST_DOUBLE_LOW (x) < 0)\n+\t    fprintf (file, \"0x%x%08x\",\n+\t\t     CONST_DOUBLE_HIGH (x), CONST_DOUBLE_LOW (x));\n+\t  else\n+\t    fprintf (file, \"%d\", CONST_DOUBLE_LOW (x));\n+\t}\n+      else\n+\t/* We can't handle floating point constants;\n+\t   PRINT_OPERAND must handle them.  */\n+\toutput_operand_lossage (\"floating constant misused\");\n+      break;\n+\n+    case PLUS:\n+      /* Some assemblers need integer constants to appear last (eg masm).  */\n+      if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n+\t{\n+\t  output_pic_addr_const (file, XEXP (x, 1), code);\n+\t  if (INTVAL (XEXP (x, 0)) >= 0)\n+\t    fprintf (file, \"+\");\n+\t  output_pic_addr_const (file, XEXP (x, 0), code);\n+\t}\n+      else\n+\t{\n+\t  output_pic_addr_const (file, XEXP (x, 0), code);\n+\t  if (INTVAL (XEXP (x, 1)) >= 0)\n+\t    fprintf (file, \"+\");\n+\t  output_pic_addr_const (file, XEXP (x, 1), code);\n+\t}\n+      break;\n+\n+    case MINUS:\n+      output_pic_addr_const (file, XEXP (x, 0), code);\n+      fprintf (file, \"-\");\n+      output_pic_addr_const (file, XEXP (x, 1), code);\n+      break;\n+\n+    default:\n+      output_operand_lossage (\"invalid expression as operand\");\n+    }\n+}\n+\f\n+/* Print the name of a register based on its machine mode and number.\n+   If CODE is 'w', pretend the mode is HImode.\n+   If CODE is 'b', pretend the mode is QImode.\n+   If CODE is 'k', pretend the mode is SImode.\n+   If CODE is 'h', pretend the reg is the `high' byte register.\n+   If CODE is 'y', print \"st(0)\" instead of \"st\", if the reg is stack op. */\n+\n+#define PRINT_REG(X, CODE, FILE) \\\n+  do { if (REGNO (X) == ARG_POINTER_REGNUM)\t\t\\\n+\t abort ();\t\t\t\t\t\\\n+       fprintf (FILE, \"%s\", RP);\t\t\t\\\n+       switch ((CODE == 'w' ? 2 \t\t\t\\\n+\t\t: CODE == 'b' ? 1\t\t\t\\\n+\t\t: CODE == 'k' ? 4\t\t\t\\\n+\t\t: CODE == 'y' ? 3\t\t\t\\\n+\t\t: CODE == 'h' ? 0\t\t\t\\\n+\t\t: GET_MODE_SIZE (GET_MODE (X))))\t\\\n+\t {\t\t\t\t\t\t\\\n+\t case 3:\t\t\t\t\t\\\n+\t   if (STACK_TOP_P (X))\t\t\t\t\\\n+\t     {\t\t\t\t\t\t\\\n+\t       fputs (\"st(0)\", FILE);\t\t\t\\\n+\t       break;\t\t\t\t\t\\\n+\t     }\t\t\t\t\t\t\\\n+\t case 4:\t\t\t\t\t\\\n+\t case 8:\t\t\t\t\t\\\n+\t   if (!FP_REG_P (X)) fputs (\"e\", FILE);\t\\\n+\t case 2:\t\t\t\t\t\\\n+\t   fputs (hi_reg_name[REGNO (X)], FILE);\t\\\n+\t   break;\t\t\t\t\t\\\n+\t case 1:\t\t\t\t\t\\\n+\t   fputs (qi_reg_name[REGNO (X)], FILE);\t\\\n+\t   break;\t\t\t\t\t\\\n+\t case 0:\t\t\t\t\t\\\n+\t   fputs (qi_high_reg_name[REGNO (X)], FILE);\t\\\n+\t   break;\t\t\t\t\t\\\n+\t }\t\t\t\t\t\t\\\n+     } while (0)\n+\n+/* Meaning of CODE:\n+   f -- float insn (print a CONST_DOUBLE as a float rather than in hex).\n+   D,L,W,B,Q,S -- print the opcode suffix for specified size of operand.\n+   R -- print the prefix for register names.\n+   z -- print the opcode suffix for the size of the current operand.\n+   * -- print a star (in certain assembler syntax)\n+   w -- print the operand as if it's a \"word\" (HImode) even if it isn't.\n+   c -- don't print special prefixes before constant operands.\n+*/\n+\n+void\n+print_operand (file, x, code)\n+     FILE *file;\n+     rtx x;\n+     int code;\n+{\n+  if (code)\n+    {\n+      switch (code)\n+\t{\n+\tcase '*':\n+\t  if (USE_STAR)\n+\t    putc ('*', file);\n+\t  return;\n+\n+\tcase 'D':\n+\t  PUT_OP_SIZE (code, 'l', file);\n+\tcase 'L':\n+\t  PUT_OP_SIZE (code, 'l', file);\n+\t  return;\n+\n+\tcase 'W':\n+\t  PUT_OP_SIZE (code, 'w', file);\n+\t  return;\n+\n+\tcase 'B':\n+\t  PUT_OP_SIZE (code, 'b', file);\n+\t  return;\n+\n+\tcase 'Q':\n+\t  PUT_OP_SIZE (code, 'l', file);\n+\t  return;\n+\n+\tcase 'S':\n+\t  PUT_OP_SIZE (code, 's', file);\n+\t  return;\n+\n+\tcase 'R':\n+\t  fprintf (file, \"%s\", RP);\n+\t  return;\n+\n+\tcase 'z':\n+\t  /* 387 opcodes don't get size suffixes if the operands are\n+\t     registers. */\n+\n+\t  if (STACK_REG_P (x))\n+\t    return;\n+\n+\t  /* this is the size of op from size of operand */\n+\t  switch (GET_MODE_SIZE (GET_MODE (x)))\n+\t    {\n+\t    case 1:\n+\t      PUT_OP_SIZE ('B', 'b', file);\n+\t      return;\n+\n+\t    case 2:\n+\t      PUT_OP_SIZE ('W', 'w', file);\n+\t      return;\n+\n+\t    case 4:\n+\t      if (GET_MODE (x) == SFmode)\n+\t\t{\n+\t\t  PUT_OP_SIZE ('S', 's', file);\n+\t\t  return;\n+\t\t}\n+\t      else\n+\t\tPUT_OP_SIZE ('L', 'l', file);\n+\t      return;\n+\n+\t    case 8:\n+\t      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n+\t\tPUT_OP_SIZE ('Q', 'l', file);\n+\n+\t      PUT_OP_SIZE ('Q', 'l', file);\n+\t      return;\n+\t    }\n+\t}\n+    }\n+  if (GET_CODE (x) == REG)\n+    {\n+      PRINT_REG (x, code, file);\n+    }\n+  else if (GET_CODE (x) == MEM)\n+    {\n+      PRINT_PTR (x, file);\n+      if (CONSTANT_ADDRESS_P (XEXP (x, 0)))\n+\t{\n+\t  if (flag_pic)\n+\t    output_pic_addr_const (file, XEXP (x, 0), code);\n+\t  else\n+\t    output_addr_const (file, XEXP (x, 0));\n+\t}\n+      else\n+\toutput_address (XEXP (x, 0));\n+    }\n+  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == SFmode)\n+    {\n+      union { double d; int i[2]; } u;\n+      union { float f; int i; } u1;\n+      u.i[0] = CONST_DOUBLE_LOW (x);\n+      u.i[1] = CONST_DOUBLE_HIGH (x);\n+      u1.f = u.d;\n+      if (code == 'f')\n+        fprintf (file, \"%.22e\", u1.f);\n+      else\n+        {\n+\t  PRINT_IMMED_PREFIX (file);\n+\t  fprintf (file, \"0x%x\", u1.i);\n+\t}\n+    }\n+  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode)\n+    {\n+      union { double d; int i[2]; } u;\n+      u.i[0] = CONST_DOUBLE_LOW (x);\n+      u.i[1] = CONST_DOUBLE_HIGH (x);\n+      fprintf (file, \"%.22e\", u.d);\n+    }\n+  else \n+    {\n+      if (code != 'c' && code != 'P')\n+\t{\n+\t  if (GET_CODE (x) == CONST_INT)\n+\t    PRINT_IMMED_PREFIX (file);\n+\t  else if (GET_CODE (x) == CONST || GET_CODE (x) == SYMBOL_REF\n+\t\t   || GET_CODE (x) == LABEL_REF)\n+\t    PRINT_OFFSET_PREFIX (file);\n+\t}\n+      if (flag_pic)\n+\toutput_pic_addr_const (file, x, code);\n+      else\n+\toutput_addr_const (file, x);\n+    }\n+}\n+\f\n+/* Print a memory operand whose address is ADDR.  */\n+\n+void\n+print_operand_address (file, addr)\n+     FILE *file;\n+     register rtx addr;\n+{\n+  register rtx reg1, reg2, breg, ireg;\n+  rtx offset;\n+\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      ADDR_BEG (file);\n+      fprintf (file, \"%se\", RP);\n+      fputs (hi_reg_name[REGNO (addr)], file);\n+      ADDR_END (file);\n+      break;\n+\n+    case PLUS:\n+      reg1 = 0;\n+      reg2 = 0;\n+      ireg = 0;\n+      breg = 0;\n+      offset = 0;\n+      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\n+\t{\n+\t  offset = XEXP (addr, 0);\n+\t  addr = XEXP (addr, 1);\n+\t}\n+      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\n+\t{\n+\t  offset = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      if (GET_CODE (addr) != PLUS) ;\n+      else if (GET_CODE (XEXP (addr, 0)) == MULT)\n+\t{\n+\t  reg1 = XEXP (addr, 0);\n+\t  addr = XEXP (addr, 1);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 1)) == MULT)\n+\t{\n+\t  reg1 = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 0)) == REG)\n+\t{\n+\t  reg1 = XEXP (addr, 0);\n+\t  addr = XEXP (addr, 1);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\t{\n+\t  reg1 = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT)\n+\t{\n+\t  if (reg1 == 0) reg1 = addr;\n+\t  else reg2 = addr;\n+\t  addr = 0;\n+\t}\n+      if (offset != 0)\n+\t{\n+\t  if (addr != 0) abort ();\n+\t  addr = offset;\n+\t}\n+      if ((reg1 && GET_CODE (reg1) == MULT)\n+\t  || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\n+\t{\n+\t  breg = reg2;\n+\t  ireg = reg1;\n+\t}\n+      else if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\n+\t{\n+\t  breg = reg1;\n+\t  ireg = reg2;\n+\t}\n+\n+      if (ireg != 0 || breg != 0)\n+\t{\n+\t  int scale = 1;\n+\n+\t  if (addr != 0)\n+\t    {\n+\t      if (GET_CODE (addr) == LABEL_REF)\n+\t\toutput_asm_label (addr);\n+\t      else\n+\t\t{\n+\t\t  if (flag_pic)\n+\t\t    output_pic_addr_const (file, addr, 0);\n+\t\t  else\n+\t\t    output_addr_const (file, addr);\n+\t\t}\n+\t    }\n+\n+  \t  if (ireg != 0 && GET_CODE (ireg) == MULT)\n+\t    {\n+\t      scale = INTVAL (XEXP (ireg, 1));\n+\t      ireg = XEXP (ireg, 0);\n+\t    }\n+\n+\t  /* The stack pointer can only appear as a base register,\n+\t     never an index register, so exchange the regs if it is wrong. */\n+\n+\t  if (scale == 1 && ireg && REGNO (ireg) == STACK_POINTER_REGNUM)\n+\t    {\n+\t      rtx tmp;\n+\n+\t      tmp = breg;\n+\t      breg = ireg;\n+\t      ireg = tmp;\n+\t    }\n+\n+\t  /* output breg+ireg*scale */\n+\t  PRINT_B_I_S (breg, ireg, scale, file);\n+\t  break;\n+\t}\n+\n+    case MULT:\n+      {\n+\tint scale;\n+\tif (GET_CODE (XEXP (addr, 0)) == CONST_INT)\n+\t  {\n+\t    scale = INTVAL (XEXP (addr, 0));\n+\t    ireg = XEXP (addr, 1);\n+\t  }\n+\telse\n+\t  {\n+\t    scale = INTVAL (XEXP (addr, 1));\n+\t    ireg = XEXP (addr, 0);\n+\t  }\n+\toutput_addr_const (file, const0_rtx);\n+\tPRINT_B_I_S ((rtx) 0, ireg, scale, file);\n+      }\n+      break;\n+\n+    default:\n+      if (GET_CODE (addr) == CONST_INT\n+\t  && INTVAL (addr) < 0x8000\n+\t  && INTVAL (addr) >= -0x8000)\n+\tfprintf (file, \"%d\", INTVAL (addr));\n+      else\n+\t{\n+\t  if (flag_pic)\n+\t    output_pic_addr_const (file, addr, 0);\n+\t  else\n+\t    output_addr_const (file, addr);\n+\t}\n+    }\n+}\n+\f\n+/* Set the cc_status for the results of an insn whose pattern is EXP.\n+   On the 80386, we assume that only test and compare insns, as well\n+   as SI, HI, & DI mode ADD, SUB, NEG, AND, IOR, XOR, ASHIFT, LSHIFT,\n+   ASHIFTRT, and LSHIFTRT instructions set the condition codes usefully.\n+   Also, we assume that jumps and moves don't affect the condition codes.\n+   All else, clobbers the condition codes, by assumption.\n+\n+   We assume that ALL add, minus, etc. instructions effect the condition\n+   codes.  This MUST be consistent with i386.md.  */\n+\n+void\n+notice_update_cc (exp)\n+     rtx exp;\n+{\n+  if (GET_CODE (exp) == SET)\n+    {\n+      /* Jumps do not alter the cc's.  */\n+      if (SET_DEST (exp) == pc_rtx)\n+\treturn;\n+      /* Moving register or memory into a register:\n+\t it doesn't alter the cc's, but it might invalidate\n+\t the RTX's which we remember the cc's came from.\n+\t (Note that moving a constant 0 or 1 MAY set the cc's).  */\n+      if (REG_P (SET_DEST (exp))\n+\t  && (REG_P (SET_SRC (exp)) || GET_CODE (SET_SRC (exp)) == MEM))\n+\t{\n+\t  if (cc_status.value1\n+\t      && reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value1))\n+\t    cc_status.value1 = 0;\n+\t  if (cc_status.value2\n+\t      && reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value2))\n+\t    cc_status.value2 = 0;\n+\t  return;\n+\t}\n+      /* Moving register into memory doesn't alter the cc's.\n+\t It may invalidate the RTX's which we remember the cc's came from.  */\n+      if (GET_CODE (SET_DEST (exp)) == MEM && REG_P (SET_SRC (exp)))\n+\t{\n+\t  if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM)\n+\t    cc_status.value1 = 0;\n+\t  if (cc_status.value2 && GET_CODE (cc_status.value2) == MEM)\n+\t    cc_status.value2 = 0;\n+\t  return;\n+\t}\n+      /* Function calls clobber the cc's.  */\n+      else if (GET_CODE (SET_SRC (exp)) == CALL)\n+\t{\n+\t  CC_STATUS_INIT;\n+\t  return;\n+\t}\n+      /* Tests and compares set the cc's in predictable ways.  */\n+      else if (SET_DEST (exp) == cc0_rtx)\n+\t{\n+\t  CC_STATUS_INIT;\n+\t  cc_status.value1 = SET_SRC (exp);\n+\t  return;\n+\t}\n+      /* Certain instructions effect the condition codes. */\n+      else if (GET_MODE (SET_SRC (exp)) == SImode\n+\t       || GET_MODE (SET_SRC (exp)) == HImode\n+\t       || GET_MODE (SET_SRC (exp)) == QImode)\n+\tswitch (GET_CODE (SET_SRC (exp)))\n+\t  {\n+\t  case ASHIFTRT: case LSHIFTRT:\n+\t  case ASHIFT: case LSHIFT:\n+\t    /* Shifts on the 386 don't set the condition codes if the\n+\t       shift count is zero. */\n+\t    if (GET_CODE (XEXP (SET_SRC (exp), 1)) != CONST_INT)\n+\t      {\n+\t\tCC_STATUS_INIT;\n+\t\tbreak;\n+\t      }\n+\t    /* We assume that the CONST_INT is non-zero (this rtx would\n+\t       have been deleted if it were zero. */\n+\n+\t  case PLUS: case MINUS: case NEG:\n+\t  case AND: case IOR: case XOR:\n+\t    cc_status.flags = CC_NO_OVERFLOW;\n+\t    cc_status.value1 = SET_SRC (exp);\n+\t    cc_status.value2 = SET_DEST (exp);\n+\t    break;\n+\n+\t  default:\n+\t    CC_STATUS_INIT;\n+\t  }\n+      else\n+\t{\n+\t  CC_STATUS_INIT;\n+\t}\n+    }\n+  else if (GET_CODE (exp) == PARALLEL\n+\t   && GET_CODE (XVECEXP (exp, 0, 0)) == SET)\n+    {\n+      if (SET_DEST (XVECEXP (exp, 0, 0)) == pc_rtx)\n+\treturn;\n+      if (SET_DEST (XVECEXP (exp, 0, 0)) == cc0_rtx)\n+\t{\n+\t  CC_STATUS_INIT;\n+\t  cc_status.value1 = SET_SRC (XVECEXP (exp, 0, 0));\n+\t  return;\n+\t}\n+      CC_STATUS_INIT;\n+    }\n+  else\n+    {\n+      CC_STATUS_INIT;\n+    }\n+}\n+\f\n+/* Split one or more DImode RTL references into pairs of SImode\n+   references.  The RTL can be REG, offsettable MEM, integer constant, or\n+   CONST_DOUBLE.  \"operands\" is a pointer to an array of DImode RTL to\n+   split and \"num\" is its length.  lo_half and hi_half are output arrays\n+   that parallel \"operands\". */\n+\n+void\n+split_di (operands, num, lo_half, hi_half)\n+     rtx operands[];\n+     int num;\n+     rtx lo_half[], hi_half[];\n+{\n+  while (num--)\n+    {\n+      if (GET_CODE (operands[num]) == REG)\n+\t{\n+\t  lo_half[num] = gen_rtx (REG, SImode, REGNO (operands[num]));\n+\t  hi_half[num] = gen_rtx (REG, SImode, REGNO (operands[num]) + 1);\n+\t}\n+      else if (CONSTANT_P (operands[num]))\n+\t{\n+\t  split_double (operands[num], &lo_half[num], &hi_half[num]);\n+\t}\n+      else if (offsettable_memref_p (operands[num]))\n+\t{\n+\t  lo_half[num] = operands[num];\n+\t  hi_half[num] = adj_offsettable_operand (operands[num], 4);\n+\t}\n+      else\n+\tabort();\n+    }\n+}\n+\f\n+/* Return 1 if this is a valid binary operation on a 387.\n+   OP is the expression matched, and MODE is its mode. */\n+\n+int\n+binary_387_op (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  if (mode != VOIDmode && mode != GET_MODE (op))\n+    return 0;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case PLUS:\n+    case MINUS:\n+    case MULT:\n+    case DIV:\n+      return GET_MODE_CLASS (GET_MODE (op)) == MODE_FLOAT;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return 1 if this is a valid conversion operation on a 387.\n+   OP is the expression matched, and MODE is its mode. */\n+\n+int\n+convert_387_op (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  if (mode != VOIDmode && mode != GET_MODE (op))\n+    return 0;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case FLOAT:\n+      return GET_MODE (XEXP (op, 0)) == SImode;\n+\n+    case FLOAT_EXTEND:\n+      return mode == DFmode && GET_MODE (XEXP (op, 0)) == SFmode;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return 1 if this is a valid \"float from int\" operation on a 387.\n+   OP is the expression matched, and MODE is its mode. */\n+\n+int\n+float_op (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  if (mode != VOIDmode && mode != GET_MODE (op))\n+    return 0;\n+\n+  return GET_CODE (op) == FLOAT\n+    && GET_MODE_CLASS (GET_MODE (op)) == MODE_FLOAT;\n+}\n+\n+/* Return 1 if this is a valid shift or rotate operation on a 386.\n+   OP is the expression matched, and MODE is its mode. */\n+\n+int\n+shift_op (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  rtx operand = XEXP (op, 0);\n+\n+  if (mode != VOIDmode && mode != GET_MODE (op))\n+    return 0;\n+\n+  if (GET_MODE (operand) != GET_MODE (op)\n+      || GET_MODE_CLASS (GET_MODE (op)) != MODE_INT)\n+    return 0;\n+\n+  return (GET_CODE (op) == ASHIFT\n+\t  || GET_CODE (op) == ASHIFTRT\n+\t  || GET_CODE (op) == LSHIFTRT\n+\t  || GET_CODE (op) == ROTATE\n+\t  || GET_CODE (op) == ROTATERT);\n+}\n+\f\n+/* Output code to perform a 387 binary operation in INSN, one of PLUS,\n+   MINUS, MULT or DIV.  OPERANDS are the insn operands, where operands[3]\n+   is the expression of the binary operation.  The output may either be\n+   emitted here, or returned to the caller, like all output_* functions.\n+\n+   There is no guarantee that the operands are the same mode, as they\n+   might be within FLOAT or FLOAT_EXTEND expressions. */\n+\n+char *\n+output_387_binary_op (insn, operands)\n+     rtx insn;\n+     rtx *operands;\n+{\n+  rtx temp;\n+  char *base_op;\n+  static char buf[100];\n+\n+  switch (GET_CODE (operands[3]))\n+    {\n+    case PLUS:\n+      if (GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT\n+\t  || GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT)\n+\tbase_op = \"fiadd\";\n+      else\n+\tbase_op = \"fadd\";\n+      break;\n+\n+    case MINUS:\n+      if (GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT\n+\t  || GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT)\n+\tbase_op = \"fisub\";\n+      else\n+\tbase_op = \"fsub\";\n+      break;\n+\n+    case MULT:\n+      if (GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT\n+\t  || GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT)\n+\tbase_op = \"fimul\";\n+      else\n+\tbase_op = \"fmul\";\n+      break;\n+\n+    case DIV:\n+      if (GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT\n+\t  || GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT)\n+\tbase_op = \"fidiv\";\n+      else\n+\tbase_op = \"fdiv\";\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  strcpy (buf, base_op);\n+\n+  switch (GET_CODE (operands[3]))\n+    {\n+    case MULT:\n+    case PLUS:\n+      if (REG_P (operands[2]) && REGNO (operands[0]) == REGNO (operands[2]))\n+\t{\n+\t  temp = operands[2];\n+\t  operands[2] = operands[1];\n+\t  operands[1] = temp;\n+\t}\n+\n+      if (GET_CODE (operands[2]) == MEM)\n+\treturn strcat (buf, AS1 (%z2,%2));\n+\n+      if (NON_STACK_REG_P (operands[1]))\n+\t{\n+\t  output_op_from_reg (operands[1], strcat (buf, AS1 (%z0,%1)));\n+\t  RET;\n+\t}\n+      else if (NON_STACK_REG_P (operands[2]))\n+\t{\n+\t  output_op_from_reg (operands[2], strcat (buf, AS1 (%z0,%1)));\n+\t  RET;\n+\t}\n+\n+      if (find_regno_note (insn, REG_DEAD, REGNO (operands[2])))\n+\treturn strcat (buf, AS2 (p,%2,%0));\n+\n+      if (STACK_TOP_P (operands[0]))\n+\treturn strcat (buf, AS2 (,%y2,%0));\n+      else\n+\treturn strcat (buf, AS2 (,%2,%0));\n+\n+    case MINUS:\n+    case DIV:\n+      if (GET_CODE (operands[1]) == MEM)\n+\treturn strcat (buf, AS1 (r%z1,%1));\n+\n+      if (GET_CODE (operands[2]) == MEM)\n+\treturn strcat (buf, AS1 (%z2,%2));\n+\n+      if (NON_STACK_REG_P (operands[1]))\n+\t{\n+\t  output_op_from_reg (operands[1], strcat (buf, AS1 (r%z0,%1)));\n+\t  RET;\n+\t}\n+      else if (NON_STACK_REG_P (operands[2]))\n+\t{\n+\t  output_op_from_reg (operands[2], strcat (buf, AS1 (%z0,%1)));\n+\t  RET;\n+\t}\n+\n+      if (! STACK_REG_P (operands[1]) || ! STACK_REG_P (operands[2]))\n+\tabort ();\n+\n+      if (find_regno_note (insn, REG_DEAD, REGNO (operands[2])))\n+\treturn strcat (buf, AS2 (rp,%2,%0));\n+\n+      if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+\treturn strcat (buf, AS2 (p,%1,%0));\n+\n+      if (STACK_TOP_P (operands[0]))\n+\t{\n+\t  if (STACK_TOP_P (operands[1]))\n+\t    return strcat (buf, AS2 (,%y2,%0));\n+\t  else\n+\t    return strcat (buf, AS2 (r,%y1,%0));\n+\t}\n+      else if (STACK_TOP_P (operands[1]))\n+\treturn strcat (buf, AS2 (,%1,%0));\n+      else\n+\treturn strcat (buf, AS2 (r,%2,%0));\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\f\n+/* Output code for INSN to convert a float to a signed int.  OPERANDS\n+   are the insn operands.  The output may be SFmode or DFmode and the\n+   input operand may be SImode or DImode.  As a special case, make sure\n+   that the 387 stack top dies if the output mode is DImode, because the\n+   hardware requires this.  */\n+\n+char *\n+output_fix_trunc (insn, operands)\n+     rtx insn;\n+     rtx *operands;\n+{\n+  int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n+  rtx xops[6];\n+\n+  if (! STACK_TOP_P (operands[1]) ||\n+      (GET_MODE (operands[0]) == DImode && ! stack_top_dies))\n+    abort ();\n+\n+  xops[0] = stack_pointer_rtx;\n+  xops[1] = AT_SP (SImode);\n+  xops[2] = adj_offsettable_operand (xops[1], 2);\n+  xops[3] = gen_rtx (CONST_INT, VOIDmode, 4);\n+  xops[4] = gen_rtx (CONST_INT, VOIDmode, 0xc00);\n+  xops[5] = operands[2];\n+\n+  output_asm_insn (AS2 (sub%L0,%3,%0), xops);\n+  output_asm_insn (AS1 (fnstc%W5,%1), xops);\n+  output_asm_insn (AS2 (mov%W5,%1,%5), xops);\n+  output_asm_insn (AS2 (or%W5,%4,%5), xops);\n+  output_asm_insn (AS2 (mov%W5,%5,%2), xops);\n+  output_asm_insn (AS1 (fldc%W5,%2), xops);\n+\n+  if (NON_STACK_REG_P (operands[0]))\n+    output_to_reg (operands[0], stack_top_dies);\n+  else if (GET_CODE (operands[0]) == MEM)\n+    {\n+      /* If frame pointer elimination is being done, the MEM reference\n+\t might be an index off of the stack pointer.  In that case,\n+\t since we have already adjusted %esp above, adjust the operand\n+\t address so it points where it should. */\n+\n+      if (! frame_pointer_needed\n+\t  && reg_mentioned_p (stack_pointer_rtx, operands[0]))\n+\toperands[0] = adj_offsettable_operand (operands[0], 4);\n+\n+      if (stack_top_dies)\n+\toutput_asm_insn (AS1 (fistp%z0,%0), operands);\n+      else\n+\toutput_asm_insn (AS1 (fist%z0,%0), operands);\n+    }\n+  else\n+    abort ();\n+\n+  output_asm_insn (AS1 (fldc%W5,%1), xops);\n+  output_asm_insn (AS2 (add%L0,%3,%0), xops);\n+\n+  RET;\n+}\n+\f\n+/* Output code for INSN to compare OPERANDS.  The two operands might\n+   not have the same mode: one might be within a FLOAT or FLOAT_EXTEND\n+   expression. */\n+\n+char *\n+output_float_compare (insn, operands)\n+     rtx insn;\n+     rtx *operands;\n+{\n+  int stack_top_dies;\n+\n+  if (! STACK_TOP_P (operands[0]))\n+    abort ();\n+\n+  stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n+\n+  if (STACK_REG_P (operands[1])\n+      && stack_top_dies\n+      && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n+      && REGNO (operands[1]) != FIRST_STACK_REG)\n+    {\n+      /* If both the top of the 387 stack dies, and the other operand\n+\t is also a stack register that dies, then this must be a\n+\t `fcompp' float compare */\n+\n+      output_asm_insn (\"fcompp\", operands);\n+    }\n+  else\n+    {\n+      static char buf[100];\n+\n+      /* Decide if this is the integer or float compare opcode. */\n+\n+      if (GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_FLOAT)\n+\tstrcpy (buf, \"fcom\");\n+      else\n+\tstrcpy (buf, \"ficom\");\n+\n+      /* Modify the opcode if the 387 stack is to be popped. */\n+\n+      if (stack_top_dies)\n+\tstrcat (buf, \"p\");\n+\n+      if (NON_STACK_REG_P (operands[1]))\n+\toutput_op_from_reg (operands[1], strcat (buf, AS1 (%z0,%1)));\n+      else\n+        output_asm_insn (strcat (buf, AS1 (%z1,%y1)), operands);\n+    }\n+\n+  /* Now retrieve the condition code. */\n+\n+  output_asm_insn (AS1 (fnsts%W2,%2), operands);\n+\n+  cc_status.flags |= CC_IN_80387;\n+  return \"sahf\";\n+}\n+\f\n+#ifdef HANDLE_PRAGMA\n+\n+/* When structure field packing is in effect, this variable is the\n+   number of bits to use as the maximum alignment.  When packing is not\n+   in effect, this is zero. */\n+\n+int maximum_field_alignment = 0;\n+\n+/* Handle a pragma directive.  HANDLE_PRAGMA conspires to parse the\n+   input following #pragma into tokens based on yylex.  TOKEN is the\n+   current token, and STRING is its printable form.  */\n+\n+void\n+handle_pragma_token (string, token)\n+     char *string;\n+     tree token;\n+{\n+  static enum pragma_state\n+    {\n+      ps_start,\n+      ps_done,\n+      ps_bad,\n+      ps_weak,\n+      ps_name,\n+      ps_equals,\n+      ps_value,\n+      ps_pack,\n+      ps_left,\n+      ps_align,\n+      ps_right\n+      } state = ps_start, type;\n+  static char *name;\n+  static char *value;\n+  static int align;\n+\n+  if (string == 0)\n+    {\n+      if (type == ps_pack)\n+\t{\n+\t  if (state == ps_right)\n+\t    maximum_field_alignment = align * 8;\n+\t  else\n+\t    warning (\"ignoring malformed #pragma pack( [ 1 | 2 | 4 ] )\");\n+\t}\n+#ifdef WEAK_ASM_OP\n+      else if (type == ps_weak)\n+\t{\n+\t  if (state == ps_name || state == ps_value)\n+\t    {\n+\t      fprintf (asm_out_file, \"\\t%s\\t\", WEAK_ASM_OP);\n+\t      ASM_OUTPUT_LABELREF (asm_out_file, name);\n+\t      fputc ('\\n', asm_out_file);\n+\t      if (state == ps_value)\n+\t\t{\n+\t\t  fprintf (asm_out_file, \"\\t%s\\t\", DEF_ASM_OP);\n+\t\t  ASM_OUTPUT_LABELREF (asm_out_file, name);\n+\t\t  fputc (',', asm_out_file);\n+\t\t  ASM_OUTPUT_LABELREF (asm_out_file, value);\n+\t\t  fputc ('\\n', asm_out_file);\n+\t\t}\n+\t    }\n+\t  else if (! (state == ps_done || state == ps_start))\n+\t    warning (\"ignoring malformed #pragma weak symbol [=value]\");\n+\t}\n+#endif /* WEAK_ASM_OP */\n+\n+      type = state = ps_start;\n+      return;\n+    }\n+\n+  switch (state)\n+    {\n+    case ps_start:\n+      if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n+\t{\n+\t  if (strcmp (IDENTIFIER_POINTER (token), \"pack\") == 0)\n+\t    type = state = ps_pack;\n+#ifdef WEAK_ASM_OP\n+\t  else if (strcmp (IDENTIFIER_POINTER (token), \"weak\") == 0)\n+\t    type = state = ps_weak;\n+#endif\n+\t  else\n+\t    type = state = ps_done;\n+\t}\n+      else\n+\ttype = state = ps_done;\n+      break;\n+\n+#ifdef WEAK_ASM_OP\n+    case ps_weak:\n+      if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n+\t{\n+\t  name = IDENTIFIER_POINTER (token);\n+\t  state = ps_name;\n+\t}\n+      else\n+\tstate = ps_bad;\n+      break;\n+\n+    case ps_name:\n+      state = (strcmp (string, \"=\") ? ps_bad : ps_equals);\n+      break;\n+\n+    case ps_equals:\n+      if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n+\t{\n+\t  value = IDENTIFIER_POINTER (token);\n+\t  state = ps_value;\n+\t}\n+      else\n+\tstate = ps_bad;\n+      break;\n+\n+    case ps_value:\n+      state = ps_bad;\n+      break;\n+#endif /* WEAK_ASM_OP */\n+\n+    case ps_pack:\n+      if (strcmp (string, \"(\") == 0)\n+\tstate = ps_left;\n+      else\n+\tstate = ps_bad;\n+      break;\n+\n+    case ps_left:\n+      if (token && TREE_CODE (token) == INTEGER_CST\n+\t  && TREE_INT_CST_HIGH (token) == 0)\n+\tswitch (TREE_INT_CST_LOW (token))\n+\t  {\n+\t  case 1:\n+\t  case 2:\n+\t  case 4:\n+\t    align = TREE_INT_CST_LOW (token);\n+\t    state = ps_align;\n+\t    break;\n+\n+\t  default:\n+\t    state = ps_bad;\n+\t  }\n+      else if (! token && strcmp (string, \")\") == 0)\n+\t{\n+\t  align = 0;\n+\t  state = ps_right;\n+\t}\n+      else\n+\tstate = ps_bad;\n+      break;\n+\n+    case ps_align:\n+      if (strcmp (string, \")\") == 0)\n+\tstate = ps_right;\n+      else\n+\tstate = ps_bad;\n+      break;\n+\n+    case ps_right:\n+      state = ps_bad;\n+      break;\n+\n+    case ps_bad:\n+    case ps_done:\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+#endif /* HANDLE_PRAGMA */"}, {"sha": "7db294c051a61389c44b358d19c420eec30d4476", "filename": "gcc/config/svr4.h", "status": "added", "additions": 667, "deletions": 0, "changes": 667, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2ab3f96a2acd47e9736aa77e9eebb4a2550398/gcc%2Fconfig%2Fsvr4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2ab3f96a2acd47e9736aa77e9eebb4a2550398/gcc%2Fconfig%2Fsvr4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsvr4.h?ref=2a2ab3f96a2acd47e9736aa77e9eebb4a2550398", "patch": "@@ -0,0 +1,667 @@\n+/* svr4.h  --  operating system specific defines to be used when\n+   targeting GCC for some generic System V Release 4 system.\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+   Written by Ron Guilmette (rfg@ncd.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+   To use this file, make up a file with a name like:\n+\n+\t?????svr4.h\n+\n+   where ????? is replaced by the name of the basic hardware that you\n+   are targeting for.  Then, in the file ?????svr4.h, put something\n+   like:\n+\n+\t#include \"?????.h\"\n+\t#include \"svr4.h\"\n+\n+   followed by any really system-specific defines (or overrides of\n+   defines) which you find that you need.  For example, CPP_PREDEFINES\n+   is defined here with only the defined -Dunix and -DSVR4.  You should\n+   probably override that in your target-specific ?????svr4.h file\n+   with a set of defines that includes these, but also contains an\n+   appropriate define for the type of hardware that you are targeting.\n+*/\n+\n+/* Define a symbol so that libgcc* can know what sort of operating\n+   environment and assembler syntax we are targeting for.  */\n+#ifndef SVR4\n+#define SVR4\n+#endif\n+\n+/* For the sake of libgcc2.c, indicate target supports atexit.  */\n+#define HAVE_ATEXIT\n+\n+/* Cpp, assembler, linker, library, and startfile spec's.  */\n+\n+/* This defines which switch letters take arguments.  On svr4, most of\n+   the normal cases (defined in gcc.c) apply, and we also have -h* and\n+   -z* options (for the linker).  Note however that there is no such\n+   thing as a -T option for svr4.  */\n+\n+#define SWITCH_TAKES_ARG(CHAR) \\\n+  (   (CHAR) == 'D' \\\n+   || (CHAR) == 'U' \\\n+   || (CHAR) == 'o' \\\n+   || (CHAR) == 'e' \\\n+   || (CHAR) == 'u' \\\n+   || (CHAR) == 'I' \\\n+   || (CHAR) == 'm' \\\n+   || (CHAR) == 'L' \\\n+   || (CHAR) == 'A' \\\n+   || (CHAR) == 'h' \\\n+   || (CHAR) == 'z')\n+\n+/* This defines which multi-letter switches take arguments.  On svr4,\n+   there are no such switches except those implemented by GCC itself.  */\n+\n+#define WORD_SWITCH_TAKES_ARG(STR)\t\t\t\\\n+ (!strcmp (STR, \"include\") || !strcmp (STR, \"imacros\"))\n+\n+/* You should redefine CPP_PREDEFINES in any file which includes this one.\n+   The definition should be appropriate for the type of target system\n+   involved, and it should include any -A (assertion) options which are\n+   appropriate for the given target system.  */\n+#undef CPP_PREDEFINES\n+\n+/* Provide an ASM_SPEC appropriate for svr4.  Here we try to support as\n+   many of the specialized svr4 assembler options as seems reasonable,\n+   given that there are certain options which we can't (or shouldn't)\n+   support directly due to the fact that they conflict with other options \n+   for other svr4 tools (e.g. ld) or with other options for GCC itself.\n+   For example, we don't support the -o (output file) or -R (remove\n+   input file) options because GCC already handles these things.  We\n+   also don't support the -m (run m4) option for the assembler because\n+   that conflicts with the -m (produce load map) option of the svr4\n+   linker.  We do however allow passing arbitrary options to the svr4\n+   assembler via the -Wa, option.\n+\n+   Note that gcc doesn't allow a space to follow -Y in a -Ym,* or -Yd,*\n+   option.\n+*/\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \\\n+  \"%{V} %{v:%{!V:-V}} %{Qy:} %{!Qn:-Qy} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*}\"\n+\n+/* svr4 assemblers need the `-' (indicating input from stdin) to come after\n+   the -o option (and its argument) for some reason.  If we try to put it\n+   before the -o option, the assembler will try to read the file named as\n+   the output file in the -o option as an input file (after it has already\n+   written some stuff to it) and the binary stuff contained therein will\n+   cause totally confuse the assembler, resulting in many spurious error\n+   messages.  */\n+\n+#undef ASM_FINAL_SPEC\n+#define ASM_FINAL_SPEC \"%{pipe:-}\"\n+\n+/* Under svr4, the normal location of the various *crt*.o files is the\n+   /usr/ccs/lib directory.  */\n+\n+#undef MD_STARTFILE_PREFIX\n+#define MD_STARTFILE_PREFIX \"/usr/ccs/lib/\"\n+\n+/* Provide a LIB_SPEC appropropriate for svr4.  Here we tack on the default\n+   standard C library (unless we are building a shared library) followed by\n+   our own magical crtend.o file (see crtstuff.c) which provides part of\n+   the support for getting C++ file-scope static object constructed before\n+   entering `main', followed by the normal svr3/svr4 \"finalizer\" file,\n+   which is either `gcrtn.o' or `crtn.o'.  */\n+\n+#undef\tLIB_SPEC\n+#define LIB_SPEC \\\n+  \"%{!shared:%{!symbolic:-lc}} \\\n+  crtend.o%s \\\n+  %{!shared:%{!symbolic:%{pg:gcrtn.o}%{!pg:crtn.o%s}}}\"\n+\n+/* Provide a LINK_SPEC appropriate for svr4.  Here we provide support\n+   for the special GCC options -static, -shared, and -symbolic which\n+   allow us to link things in one of these three modes by applying the\n+   appropriate combinations of options at link-time.  We also provide\n+   support here for as many of the other svr4 linker options as seems\n+   reasonable, given that some of them conflict with options for other\n+   svr4 tools (e.g. the assembler).  In particular, we do support the\n+   -h*, -z*, -V, -b, -t, -Qy, -Qn, and -YP* options here, and the -e*,\n+   -l*, -o*, -r, -s, -u*, and -L* options are directly supported\n+   by gcc.c itself.  We don't directly support the -m (generate load\n+   map) option because that conflicts with the -m (run m4) option of\n+   the svr4 assembler.  We also don't directly support the svr4 linker's\n+   -I* or -M* options because these conflict with existing GCC options.\n+   We do however allow passing arbitrary options to the svr4 linker\n+   via the -Wl, option.  We don't support the svr4 linker's -a option\n+   at all because it is totally useless and because it conflicts with\n+   GCC's own -a option.\n+\n+   Note that gcc doesn't allow a space to follow -Y in a -YP,* option.\n+\n+   When the -G link option is used (-shared and -symbolic) a final link is\n+   not being done.  */\n+\n+#undef\tLINK_SPEC\n+#define LINK_SPEC \"%{z*} %{h*} %{V} %{v:%{!V:-V}} \\\n+\t\t   %{b} %{t} %{Wl,*:%*} \\\n+\t\t   %{static:-dn -Bstatic} \\\n+\t\t   %{shared:-G -dy} \\\n+\t\t   %{symbolic:-Bsymbolic -G -dy} \\\n+\t\t   %{YP,*} \\\n+\t\t   %{!YP,*:%{p:-Y P,/usr/ccs/lib/libp:/usr/lib/libp:/usr/ccs/lib:/usr/lib} \\\n+\t\t    %{!p:-Y P,/usr/ccs/lib:/usr/lib}} \\\n+\t\t   %{Qy:} %{!Qn:-Qy}\"\n+\n+/* Gcc automatically adds in one of the files /usr/ccs/lib/values-Xc.o,\n+   /usr/ccs/lib/values-Xa.o, or /usr/ccs/lib/values-Xt.o for each final\n+   link step (depending upon the other gcc options selected, such as\n+   -traditional and -ansi).  These files each contain one (initialized)\n+   copy of a special variable called `_lib_version'.  Each one of these\n+   files has `_lib_version' initialized to a different (enum) value.\n+   The SVR4 library routines query the value of `_lib_version' at run\n+   to decide how they should behave.  Specifically, they decide (based\n+   upon the value of `_lib_version') if they will act in a strictly ANSI\n+   conformant manner or not.\n+*/\n+\n+#undef\tSTARTFILE_SPEC\n+#define STARTFILE_SPEC \"%{!shared: \\\n+\t\t\t %{!symbolic: \\\n+\t\t\t  %{pg:gcrt1.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}} \\\n+\t\t\t  %{pg:gcrti.o%s}%{!pg:crti.o%s} \\\n+\t\t\t  %{ansi:values-Xc.o%s} \\\n+\t\t\t  %{!ansi: \\\n+\t\t\t   %{traditional:values-Xt.o%s} \\\n+\t\t\t   %{!traditional:values-Xa.o%s}}}} crtbegin.o%s\"\n+\n+/* Attach a sepcial .ident directive to the end of the file to identify\n+   the version of GCC which compiled this code.  The format of the\n+   .ident string is patterened after the ones produced by native svr4\n+   C compilers.  */\n+\n+#define ASM_FILE_END(FILE)\t\t\t\t\t\\\n+do {\t\t\t\t \t\t\t\t\\\n+     fprintf ((FILE), \"\\t.ident\\t\\\"GCC: (GNU) %s\\\"\\n\",\t\t\\\n+\t      version_string);\t\t\t\t\t\\\n+   } while (0)\n+\n+/* Allow #sccs in preprocessor.  */\n+\n+#define SCCS_DIRECTIVE\n+\n+/* Output #ident as a .ident.  */\n+\n+#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n+  fprintf (FILE, \"\\t.ident \\\"%s\\\"\\n\", NAME);\n+\n+/* Use periods rather than dollar signs in special g++ assembler names.  */\n+\n+#define NO_DOLLAR_IN_LABEL\n+\n+/* Writing `int' for a bitfield forces int alignment for the structure.  */\n+\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* Implicit library calls should use memcpy, not bcopy, etc.  */\n+\n+#define TARGET_MEM_FUNCTIONS\n+\n+/* System V Release 4 uses DWARF debugging info.  */\n+\n+#define DWARF_DEBUGGING_INFO\n+\n+/* The numbers used to denote specific machine registers in the System V\n+   Release 4 DWARF debugging information are quite likely to be totally\n+   different from the numbers used in BSD stabs debugging information\n+   for the same kind of target machine.  Thus, we undefine the macro\n+   DBX_REGISTER_NUMBER here as an extra inducement to get people to\n+   provide proper machine-specific definitions of DBX_REGISTER_NUMBER\n+   (which is also used to provide DWARF registers numbers in dwarfout.c)\n+   in their tm.h files which include this file.  */\n+\n+#undef DBX_REGISTER_NUMBER\n+\n+/* Define the actual types of some ANSI-mandated types.  (These\n+   definitions should work for most SVR4 systems).  */\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE \"unsigned int\"\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"long int\"\n+\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE BITS_PER_WORD\n+\n+#undef ASM_BYTE_OP\n+#define ASM_BYTE_OP\t\"\\t.byte\"\n+\n+/* This is how to begin an assembly language file.  Most svr4 assemblers want\n+   at least a .file directive to come first, and some want to see a .version\n+   directive come right after that.  Here we just establish a default\n+   which generates only the .file directive.  If you need a .version\n+   directive for any specific target, you should override this definition\n+   in the target-specific file which includes this one.  */\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)                                    \\\n+  output_file_directive ((FILE), main_input_filename)\n+\n+/* This is how to allocate empty space in some section.  The .zero\n+   pseudo-op is used for this on most svr4 assemblers.  */\n+\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE,SIZE) fprintf (FILE, \"\\t.zero\\t%u\\n\", (SIZE))\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.\n+\n+   For System V Release 4 the convention is *not* to prepend a leading\n+   underscore onto user-level symbol names.  */\n+\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE,NAME) fprintf (FILE, \"%s\", NAME)\n+\n+/* The standard SVR4 assembler seems to require that certain builtin\n+   library routines (e.g. .udiv) be explicitly declared as .globl\n+   in each assembly file where they are referenced.  */\n+\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\t\t\t\\\n+  ASM_GLOBALIZE_LABEL (FILE, XSTR (FUN, 0))\n+\n+/* This says how to output assembler code to declare an\n+   uninitialized external linkage data object.  Under SVR4,\n+   the linker seems to want the alignment of data objects\n+   to depend on their types.  We do exactly that here.  */\n+\n+#undef ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fputs (\"\\t.comm\\t\", (FILE));\t\t\t\t\t\t\\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n+} while (0)\n+\n+/* This says how to output assembler code to declare an\n+   uninitialized internal linkage data object.  Under SVR4,\n+   the linker seems to want the alignment of data objects\n+   to depend on their types.  We do exactly that here.  */\n+\n+#define BSS_ASM_OP\t\"\\t.bss\"\n+\n+#undef ASM_OUTPUT_ALIGNED_LOCAL\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"%s\\t%s,%u,%u\\n\",\t\t\t\t\t\\\n+\t   BSS_ASM_OP, (NAME), (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n+} while (0)\n+\n+/* This is the pseudo-op used to generate a 32-bit word of data with a\n+   specific value in some section.  This is the same for all known svr4\n+   assemblers.  */\n+\n+#define INT_ASM_OP\t\t\"\\t.long\\t\"\n+\n+/* This is the pseudo-op used to generate a contiguous sequence of byte\n+   values from a double-quoted string WITHOUT HAVING A TERMINATING NUL\n+   AUTOMATICALLY APPENDED.  This is the same for most svr4 assemblers.  */\n+\n+#undef ASCII_DATA_ASM_OP\n+#define ASCII_DATA_ASM_OP\t\".ascii\"\n+\n+/* Support const sections and the ctors and dtors sections for g++.\n+   Note that there appears to be two different ways to support const\n+   sections at the moment.  You can either #define the symbol\n+   READONLY_DATA_SECTION (giving it some code which switches to the\n+   readonly data section) or else you can #define the symbols\n+   EXTRA_SECTIONS, EXTRA_SECTION_FUNCTIONS, SELECT_SECTION, and\n+   SELECT_RTX_SECTION.  We do both here just to be on the safe side.  */\n+\n+#define USE_CONST_SECTION\t1\n+\n+#define CONST_SECTION_ASM_OP\t\"\\t.section\\t.rodata\"\n+#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"a\\\",@progbits\\n\"\n+#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"a\\\",@progbits\\n\"\n+\n+/* On svr4, we *do* have support for the .init section, and we can put\n+   stuff in there to be executed before `main'.  We let crtstuff.c and\n+   other files know this by defining the following symbol.  The definition\n+   says how to change sections to the .init section.  This is the same\n+   for all know svr4 assemblers.  */\n+\n+#define INIT_SECTION_ASM_OP\t\"\\t.section\\t.init\"\n+\n+/* A default list of other sections which we might be \"in\" at any given\n+   time.  For targets that use additional sections (e.g. .tdesc) you\n+   should override this definition in the target-specific file which\n+   includes this file.  */\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_const, in_ctors, in_dtors\n+\n+/* A default list of extra section function definitions.  For targets\n+   that use additional sections (e.g. .tdesc) you should override this\n+   definition in the target-specific file which includes this file.  */\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+  CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  DTORS_SECTION_FUNCTION\n+\n+#define READONLY_DATA_SECTION() const_section ()\n+\n+extern void text_section();\n+\n+#define CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+const_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (!USE_CONST_SECTION)\t\t\t\t\t\t\\\n+    text_section();\t\t\t\t\t\t\t\\\n+  else if (in_section != in_const)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CONST_SECTION_ASM_OP);\t\t\\\n+      in_section = in_const;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, CTORS_SECTION_ASM_OP);\t\t\t\\\n+      in_section = in_ctors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, DTORS_SECTION_ASM_OP);\t\t\t\\\n+      in_section = in_dtors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global constructors.  */\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    ctors_section ();\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\\t \", INT_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global destructors.  */\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    dtors_section ();                   \t\t\t\t\\\n+    fprintf (FILE, \"%s\\t \", INT_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);              \t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of DECL.  DECL is either a `VAR_DECL' node\n+   or a constant of some sort.  RELOC indicates whether forming\n+   the initial value of DECL requires link-time relocations.  */\n+\n+#define SELECT_SECTION(DECL,RELOC)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (DECL) == STRING_CST)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (! flag_writable_strings)\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if ((flag_pic && RELOC)\t\t\t\t\t\t\\\n+\t  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL))\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    const_section ();\t\t\t\t\t\t\t\\\n+}\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of RTX in mode MODE.  RTX is some kind\n+   of constant in RTL.  The argument MODE is redundant except\n+   in the case of a `const_int' rtx.  Currently, these always\n+   go into the const section.  */\n+\n+#undef SELECT_RTX_SECTION\n+#define SELECT_RTX_SECTION(MODE,RTX) const_section()\n+\n+/* Define the strings used for the special svr4 .type and .size directives.\n+   These strings generally do not vary from one system running svr4 to\n+   another, but if a given system (e.g. m88k running svr) needs to use\n+   different pseudo-op names for these, they may be overridden in the\n+   file which includes this one.  */\n+\n+#define TYPE_ASM_OP\t\"\\t.type\"\n+#define SIZE_ASM_OP\t\"\\t.size\"\n+\n+/* The following macro defines the format used to output the second\n+   operand of the .type assembler directive.  Different svr4 assemblers\n+   expect various different forms for this operand.  The one given here\n+   is just a default.  You may need to override it in your machine-\n+   specific tm.h file (depending upon the particulars of your assembler).  */\n+\n+#define TYPE_OPERAND_FMT\t\"@%s\"\n+\n+/* These macros generate the special .type and .size directives which\n+   are used to set the corresponding fields of the linker symbol table\n+   entries in an ELF object file under SVR4.  */\n+\n+/* Write the extra assembler code needed to declare a function properly.  */\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Write the extra assembler code needed to declare an object properly.  */\n+\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+\tfprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (decl)));\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* This is how to declare the size of a function.  */\n+\n+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        char label[256];\t\t\t\t\t\t\\\n+\tstatic int labelno;\t\t\t\t\t\t\\\n+\tlabelno++;\t\t\t\t\t\t\t\\\n+\tASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\t\\\n+\tASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\t\\\n+\tfprintf (FILE, \"%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n+        fprintf (FILE, \",\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, label);\t\t\t\t\t\\\n+        fprintf (FILE, \"-\");\t\t\t\t\t\t\\\n+\tASM_OUTPUT_LABELREF (FILE, (FNAME));\t\t\t\t\\\n+\tputc ('\\n', FILE);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A table of bytes codes used by the ASM_OUTPUT_ASCII and\n+   ASM_OUTPUT_LIMITED_STRING macros.  Each byte in the table\n+   corresponds to a particular byte value [0..255].  For any\n+   given byte value, if the value in the corresponding table\n+   position is zero, the given character can be output directly.\n+   If the table value is 1, the byte must be output as a \\ooo\n+   octal escape.  If the tables value is anything else, then the\n+   byte value should be output as a \\ followed by the value\n+   in the table.  Note that we can use standard UN*X escape\n+   sequences for many control characters, but we don't use\n+   \\a to represent BEL because some svr4 assemblers (e.g. on\n+   the i386) don't know about that.   */\n+\n+#define ESCAPES \\\n+\"\\1\\1\\1\\1\\1\\1\\1\\1btnvfr\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\0\\0\\\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\\\\0\\0\\0\\\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\"\n+\n+/* Some svr4 assemblers have a limit on the number of characters which\n+   can appear in the operand of a .string directive.  If your assembler\n+   has such a limitation, you should define STRING_LIMIT to reflect that\n+   limit.  Note that at least some svr4 assemblers have a limit on the\n+   actual number of bytes in the double-quoted string, and that they\n+   count each chanacter in an escape sequence as one byte.  Thus, an\n+   escape sequence like \\377 would count as four bytes.\n+\n+   If your target assembler doesn't support the .string directive, you\n+   should define this to zero.\n+*/\n+\n+#define STRING_LIMIT\t((unsigned) 256)\n+\n+#define STRING_ASM_OP\t\".string\"\n+\n+/* The routine used to output NUL terminated strings.  We use a special\n+   version of this for most svr4 targets because doing so makes the\n+   generated assembly code more compact (and thus faster to assemble)\n+   as well as more readable, especially for targets like the i386\n+   (where the only alternative is to output character sequences as\n+   comma separated lists of numbers).   */\n+\n+#define ASM_OUTPUT_LIMITED_STRING(FILE, STR)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      register unsigned char *_limited_str = (unsigned char *) (STR);\t\\\n+      register unsigned ch;\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\t%s\\t\\\"\", STRING_ASM_OP);\t\t\t\\\n+      for (; ch = *_limited_str; _limited_str++)\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+\t  register int escape;\t\t\t\t\t\t\\\n+\t  switch (escape = ESCAPES[ch])\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t    case 0:\t\t\t\t\t\t\t\\\n+\t      putc (ch, (FILE));\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    case 1:\t\t\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"\\\\%03o\", ch);\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    default:\t\t\t\t\t\t\t\\\n+\t      putc ('\\\\', (FILE));\t\t\t\t\t\\\n+\t      putc (escape, (FILE));\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* The routine used to output sequences of byte values.  We use a special\n+   version of this for most svr4 targets because doing so makes the\n+   generated assembly code more compact (and thus faster to assemble)\n+   as well as more readable.  Note that if we find subparts of the\n+   character sequence which end with NUL (and which are shorter than\n+   STRING_LIMIT) we output those using ASM_OUTPUT_LIMITED_STRING.  */\n+\n+#undef ASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      register unsigned char *_ascii_bytes = (unsigned char *) (STR);\t\\\n+      register unsigned char *limit = _ascii_bytes + (LENGTH);\t\t\\\n+      register unsigned bytes_in_chunk = 0;\t\t\t\t\\\n+      for (; _ascii_bytes < limit; _ascii_bytes++)\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+\t  register unsigned char *p;\t\t\t\t\t\\\n+\t  if (bytes_in_chunk >= 60)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n+\t      bytes_in_chunk = 0;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  for (p = _ascii_bytes; p < limit && *p != '\\0'; p++)\t\t\\\n+\t    continue;\t\t\t\t\t\t\t\\\n+\t  if (p < limit && (p - _ascii_bytes) <= STRING_LIMIT)\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk > 0)\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\\\n+\t\t  bytes_in_chunk = 0;\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      ASM_OUTPUT_LIMITED_STRING ((FILE), _ascii_bytes);\t\t\\\n+\t      _ascii_bytes = p;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      register int escape;\t\t\t\t\t\\\n+\t      register unsigned ch;\t\t\t\t\t\\\n+\t      if (bytes_in_chunk == 0)\t\t\t\t\t\\\n+\t\tfprintf ((FILE), \"\\t%s\\t\\\"\", ASCII_DATA_ASM_OP);\t\\\n+\t      switch (escape = ESCAPES[ch = *_ascii_bytes])\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\tcase 0:\t\t\t\t\t\t\t\\\n+\t\t  putc (ch, (FILE));\t\t\t\t\t\\\n+\t\t  bytes_in_chunk++;\t\t\t\t\t\\\n+\t\t  break;\t\t\t\t\t\t\\\n+\t\tcase 1:\t\t\t\t\t\t\t\\\n+\t\t  fprintf ((FILE), \"\\\\%03o\", ch);\t\t\t\\\n+\t\t  bytes_in_chunk += 4;\t\t\t\t\t\\\n+\t\t  break;\t\t\t\t\t\t\\\n+\t\tdefault:\t\t\t\t\t\t\\\n+\t\t  putc ('\\\\', (FILE));\t\t\t\t\t\\\n+\t\t  putc (escape, (FILE));\t\t\t\t\\\n+\t\t  bytes_in_chunk += 2;\t\t\t\t\t\\\n+\t\t  break;\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (bytes_in_chunk > 0)\t\t\t\t\t\t\\\n+        fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)"}]}