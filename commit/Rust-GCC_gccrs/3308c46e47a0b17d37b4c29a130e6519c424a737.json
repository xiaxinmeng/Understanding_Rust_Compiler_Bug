{"sha": "3308c46e47a0b17d37b4c29a130e6519c424a737", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzMwOGM0NmU0N2EwYjE3ZDM3YjRjMjlhMTMwZTY1MTljNDI0YTczNw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-08-29T17:53:28Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-08-29T17:53:28Z"}, "message": "jvm.h (struct _Jv_frame_info): New structure.\n\n\t* include/jvm.h (struct _Jv_frame_info): New structure.\n\t* gnu/gcj/runtime/natNameFinder.cc: Include StringBuffer.h,\n\tjava-interp.h.\n\t(lookupInterp): New method.\n\t(getAddrAsString): Use _Jv_frame_info.\n\t(dladdrLookup): Likewise.\n\t* gnu/gcj/runtime/NameFinder.java (lookup): Try to look up\n\tinterpreted frame.\n\t(lookupInterp): Declare.\n\t* java/lang/natVMThrowable.cc: Include Thread.h, java-interp.h.\n\t(fillInStackTrace): Collect information on interpreted frames.\n\tUse _Jv_frame_info.\n\t* interpret.cc: Include Thread.h.\n\t(run): Create and push _Jv_MethodChain object.\n\t(_Jv_EndOfInterpreter): New global.\n\t* java/lang/Thread.java (interp_frame): New field.\n\t* include/java-interp.h (struct _Jv_MethodChain): New structure.\n\tInclude NameFinder.h.\n\nFrom-SVN: r56657", "tree": {"sha": "538202560a3a2f376b6fb55ee3b836b195f01e73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/538202560a3a2f376b6fb55ee3b836b195f01e73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3308c46e47a0b17d37b4c29a130e6519c424a737", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3308c46e47a0b17d37b4c29a130e6519c424a737", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3308c46e47a0b17d37b4c29a130e6519c424a737", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3308c46e47a0b17d37b4c29a130e6519c424a737/comments", "author": null, "committer": null, "parents": [{"sha": "ce4e997039ab374d5d1719b02aae3ded0a2a8ec4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce4e997039ab374d5d1719b02aae3ded0a2a8ec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce4e997039ab374d5d1719b02aae3ded0a2a8ec4"}], "stats": {"total": 171, "additions": 160, "deletions": 11}, "files": [{"sha": "8d8f248bed3a75fb0bcdba3121913344dd89a2f8", "filename": "libjava/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3308c46e47a0b17d37b4c29a130e6519c424a737/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3308c46e47a0b17d37b4c29a130e6519c424a737/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=3308c46e47a0b17d37b4c29a130e6519c424a737", "patch": "@@ -1,3 +1,24 @@\n+2002-08-29  Tom Tromey  <tromey@redhat.com>\n+\n+\t* include/jvm.h (struct _Jv_frame_info): New structure.\n+\t* gnu/gcj/runtime/natNameFinder.cc: Include StringBuffer.h,\n+\tjava-interp.h.\n+\t(lookupInterp): New method.\n+\t(getAddrAsString): Use _Jv_frame_info.\n+\t(dladdrLookup): Likewise.\n+\t* gnu/gcj/runtime/NameFinder.java (lookup): Try to look up\n+\tinterpreted frame.\n+\t(lookupInterp): Declare.\n+\t* java/lang/natVMThrowable.cc: Include Thread.h, java-interp.h.\n+\t(fillInStackTrace): Collect information on interpreted frames.\n+\tUse _Jv_frame_info.\n+\t* interpret.cc: Include Thread.h.\n+\t(run): Create and push _Jv_MethodChain object.\n+\t(_Jv_EndOfInterpreter): New global.\n+\t* java/lang/Thread.java (interp_frame): New field.\n+\t* include/java-interp.h (struct _Jv_MethodChain): New structure.\n+\tInclude NameFinder.h.\n+\n 2002-08-28  Tom Tromey  <tromey@redhat.com>\n \n \t* java/lang/Class.h: Include Package.h."}, {"sha": "f32ebe0f530dd2a0e3516befc411b586ce1888b6", "filename": "libjava/gnu/gcj/runtime/NameFinder.java", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3308c46e47a0b17d37b4c29a130e6519c424a737/libjava%2Fgnu%2Fgcj%2Fruntime%2FNameFinder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3308c46e47a0b17d37b4c29a130e6519c424a737/libjava%2Fgnu%2Fgcj%2Fruntime%2FNameFinder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FNameFinder.java?ref=3308c46e47a0b17d37b4c29a130e6519c424a737", "patch": "@@ -172,18 +172,27 @@ public NameFinder()\n    */\n   native private String getAddrAsString(RawData addrs, int n);\n \n+  /**\n+   * If nth element of stack is an interpreted frame, return the\n+   * element representing the method being interpreted.\n+   */\n+  native private StackTraceElement lookupInterp(RawData addrs, int n);\n+\n   /**\n    * Creates the nth StackTraceElement from the given native stacktrace.\n    */\n   private StackTraceElement lookup(RawData addrs, int n)\n   {\n     StackTraceElement result;\n \n-    result = dladdrLookup(addrs, n);\n+    result = lookupInterp(addrs, n);\n+    if (result == null)\n+      result = dladdrLookup(addrs, n);\n     if (result == null)\n       {\n \tString name = null;\n \tString file = null;\n+\n \tString hex = getAddrAsString(addrs, n);\n \t\n \tif (addr2line != null)"}, {"sha": "29488eddda72bdbf8874b5c16a4eff3d11689293", "filename": "libjava/gnu/gcj/runtime/natNameFinder.cc", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3308c46e47a0b17d37b4c29a130e6519c424a737/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatNameFinder.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3308c46e47a0b17d37b4c29a130e6519c424a737/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatNameFinder.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatNameFinder.cc?ref=3308c46e47a0b17d37b4c29a130e6519c424a737", "patch": "@@ -1,4 +1,4 @@\n-// natNameFinder.cc - native helper methods for NameFiner.java\n+// natNameFinder.cc - native helper methods for NameFinder.java\n \n /* Copyright (C) 2002  Free Software Foundation, Inc\n \n@@ -19,6 +19,8 @@ details.  */\n #include <jvm.h>\n #include <java/lang/String.h>\n #include <java/lang/StackTraceElement.h>\n+#include <java/lang/StringBuffer.h>\n+#include <java-interp.h>\n \n #include <gnu/gcj/runtime/NameFinder.h>\n \n@@ -29,15 +31,15 @@ details.  */\n java::lang::String*\n gnu::gcj::runtime::NameFinder::getExecutable (void)\n {\n-    return JvNewStringLatin1 (_Jv_ThisExecutable ());\n+  return JvNewStringLatin1 (_Jv_ThisExecutable ());\n }\n \n java::lang::String*\n gnu::gcj::runtime::NameFinder::getAddrAsString(RawData* addrs, jint n)\n {\n-  void **p = (void **) addrs;\n+  _Jv_frame_info *p = (_Jv_frame_info *) addrs;\n   typedef unsigned word_t __attribute ((mode (word)));\n-  word_t w = (word_t) p[n];\n+  word_t w = (word_t) p[n].addr;\n   int digits = sizeof (void *) * 2;\n   char hex[digits+5];\n \n@@ -61,8 +63,8 @@ gnu::gcj::runtime::NameFinder::dladdrLookup(RawData* addrs, jint n)\n   extern char **_Jv_argv;\n   char name[1024];\n   char file_name[1024];\n-  void **stack = (void **) addrs;\n-  void* p = stack[n];\n+  _Jv_frame_info *stack = (_Jv_frame_info *) addrs;\n+  void* p = stack[n].addr;\n   Dl_info dl_info;\n    \n   if (dladdr (p, &dl_info))\n@@ -82,3 +84,29 @@ gnu::gcj::runtime::NameFinder::dladdrLookup(RawData* addrs, jint n)\n #endif\n   return NULL;\n }\n+\n+java::lang::StackTraceElement *\n+gnu::gcj::runtime::NameFinder::lookupInterp(RawData* addrs, jint n)\n+{\n+#ifdef INTERPRETER\n+  _Jv_frame_info *stack = (_Jv_frame_info *) addrs;\n+  if (stack[n].interp == NULL)\n+    return NULL;\n+\n+  _Jv_InterpMethod *meth\n+    = reinterpret_cast<_Jv_InterpMethod *> (stack[n].interp);\n+  // FIXME: demangle.\n+  java::lang::StringBuffer *sb = new java::lang::StringBuffer();\n+  sb->append(_Jv_NewStringUtf8Const(meth->self->name));\n+  sb->append(_Jv_NewStringUtf8Const(meth->self->signature));\n+  // FIXME: source file name and line number can be found from\n+  // bytecode debug information.  But currently we don't keep that\n+  // around.\n+  // FIXME: is using the defining class correct here?\n+  return new java::lang::StackTraceElement(NULL, -1,\n+\t\t\t\t\t   meth->defining_class->getName(),\n+\t\t\t\t\t   sb->toString(), false);\n+#else // INTERPRETER\n+  return NULL;\n+#endif // INTERPRETER\n+}"}, {"sha": "e3f96713ce77c09418f0cc1cee31aed03bec842f", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3308c46e47a0b17d37b4c29a130e6519c424a737/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3308c46e47a0b17d37b4c29a130e6519c424a737/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=3308c46e47a0b17d37b4c29a130e6519c424a737", "patch": "@@ -13,6 +13,7 @@ details.  */\n \n #include <jvm.h>\n #include <java-cpool.h>\n+#include <gnu/gcj/runtime/NameFinder.h>\n \n #ifdef INTERPRETER\n \n@@ -138,6 +139,7 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n \n   friend class _Jv_ClassReader;\n   friend class _Jv_BytecodeVerifier;\n+  friend class gnu::gcj::runtime::NameFinder;\n \n   friend void _Jv_PrepareClass(jclass);\n };\n@@ -205,6 +207,28 @@ class _Jv_JNIMethod : public _Jv_MethodBase\n   }\n };\n \n+// A structure of this type is used to link together interpreter\n+// invocations on the stack.\n+struct _Jv_MethodChain\n+{\n+  const _Jv_InterpMethod *self;\n+  _Jv_MethodChain **ptr;\n+  _Jv_MethodChain *next;\n+\n+  _Jv_MethodChain (const _Jv_InterpMethod *s, _Jv_MethodChain **n)\n+  {\n+    self = s;\n+    ptr = n;\n+    next = *n;\n+    *n = this;\n+  }\n+\n+  ~_Jv_MethodChain ()\n+  {\n+    *ptr = next;\n+  }\n+};\n+\n #endif /* INTERPRETER */\n \n #endif /* __JAVA_INTERP_H__ */"}, {"sha": "e02901de824dc7411f931552a5b4bb625ae4b870", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3308c46e47a0b17d37b4c29a130e6519c424a737/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3308c46e47a0b17d37b4c29a130e6519c424a737/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=3308c46e47a0b17d37b4c29a130e6519c424a737", "patch": "@@ -111,6 +111,20 @@ union _Jv_word2\n   jdouble d;\n };                              \n \n+// An instance of this type is used to represent a single frame in a\n+// backtrace.  If the interpreter has been built, we also include\n+// information about the interpreted method.\n+struct _Jv_frame_info\n+{\n+  // PC value.\n+  void *addr;\n+#ifdef INTERPRETER\n+  // Actually a _Jv_InterpMethod, but we don't want to include\n+  // java-interp.h everywhere.\n+  void *interp;\n+#endif // INTERPRETER\n+};\n+\n /* Extract a character from a Java-style Utf8 string.\n  * PTR points to the current character.\n  * LIMIT points to the end of the Utf8 string."}, {"sha": "d231387dc9a40b1b48ca2d6904329efcb39bb1c8", "filename": "libjava/interpret.cc", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3308c46e47a0b17d37b4c29a130e6519c424a737/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3308c46e47a0b17d37b4c29a130e6519c424a737/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=3308c46e47a0b17d37b4c29a130e6519c424a737", "patch": "@@ -22,7 +22,6 @@ details.  */\n #include <jvm.h>\n #include <java-cpool.h>\n #include <java-interp.h>\n-// #include <java/lang/fdlibm.h>\n #include <java/lang/System.h>\n #include <java/lang/String.h>\n #include <java/lang/Integer.h>\n@@ -36,6 +35,7 @@ details.  */\n #include <java/lang/NullPointerException.h>\n #include <java/lang/ArithmeticException.h>\n #include <java/lang/IncompatibleClassChangeError.h>\n+#include <java/lang/Thread.h>\n #include <java-insns.h>\n #include <java-signal.h>\n \n@@ -744,11 +744,28 @@ _Jv_InterpMethod::compile (const void * const *insn_targets)\n }\n #endif /* DIRECT_THREADED */\n \n+// This function exists so that the stack-tracing code can find the\n+// boundaries of the interpreter.\n+void\n+_Jv_StartOfInterpreter (void)\n+{\n+}\n+\n void\n _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n {\n   using namespace java::lang::reflect;\n \n+  // FRAME_DESC registers this particular invocation as the top-most\n+  // interpreter frame.  This lets the stack tracing code (for\n+  // Throwable) print information about the method being interpreted\n+  // rather than about the interpreter itself.  FRAME_DESC has a\n+  // destructor so it cleans up automatically when the interpreter\n+  // returns.\n+  java::lang::Thread *thread = java::lang::Thread::currentThread();\n+  _Jv_MethodChain frame_desc (this,\n+\t\t\t      (_Jv_MethodChain **) &thread->interp_frame);\n+\n   _Jv_word stack[max_stack];\n   _Jv_word *sp = stack;\n \n@@ -3169,6 +3186,13 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n     }\n }\n \n+// This function exists so that the stack-tracing code can find the\n+// boundaries of the interpreter.\n+void\n+_Jv_EndOfInterpreter (void)\n+{\n+}\n+\n static void\n throw_internal_error (char *msg)\n {"}, {"sha": "64d58dda080002fda4f604a0479a25dcafd33aba", "filename": "libjava/java/lang/Thread.java", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3308c46e47a0b17d37b4c29a130e6519c424a737/libjava%2Fjava%2Flang%2FThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3308c46e47a0b17d37b4c29a130e6519c424a737/libjava%2Fjava%2Flang%2FThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThread.java?ref=3308c46e47a0b17d37b4c29a130e6519c424a737", "patch": "@@ -10,6 +10,8 @@\n \n package java.lang;\n \n+import gnu.gcj.RawData;\n+\n /**\n  * @author Tom Tromey <tromey@cygnus.com>\n  * @date August 24, 1998 \n@@ -311,6 +313,9 @@ public String toString ()\n   private boolean startable_flag;\n   private ClassLoader context_class_loader;\n \n+  // This describes the top-most interpreter frame for this thread.\n+  RawData interp_frame;\n+\n   // Our native data - points to an instance of struct natThread.\n   private Object data;\n }"}, {"sha": "f5c56c7a1d4639cd344ec8bd24d2a457e688436f", "filename": "libjava/java/lang/natVMThrowable.cc", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3308c46e47a0b17d37b4c29a130e6519c424a737/libjava%2Fjava%2Flang%2FnatVMThrowable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3308c46e47a0b17d37b4c29a130e6519c424a737/libjava%2Fjava%2Flang%2FnatVMThrowable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatVMThrowable.cc?ref=3308c46e47a0b17d37b4c29a130e6519c424a737", "patch": "@@ -26,6 +26,8 @@ details.  */\n #include <java-threads.h>\n #include <java/lang/Throwable.h>\n #include <java/lang/VMThrowable.h>\n+#include <java/lang/Thread.h>\n+#include <java-interp.h>\n \n #include <sys/types.h>\n \n@@ -54,13 +56,35 @@ java::lang::VMThrowable::fillInStackTrace (java::lang::Throwable* t)\n   // to include the calls to fillInStackTrace in the trace.\n   int n = backtrace (p, 128) - 1;  \n \n-  void **addrs;\n+  _Jv_frame_info *addrs;\n   if (n > 0)\n     {\n+#ifdef INTERPRETER\n+      extern void _Jv_StartOfInterpreter (void);\n+      extern void _Jv_EndOfInterpreter (void);\n+\n+      java::lang::Thread *thread = java::lang::Thread::currentThread();\n+      _Jv_MethodChain *interp_frame\n+\t= (thread ? reinterpret_cast<_Jv_MethodChain *> (thread->interp_frame)\n+\t   : NULL);\n+#endif // INTERPRETER\n+\n       state->length = n;\n-      addrs = (void **) _Jv_Malloc (n * sizeof p[0]);\n+      int len = n;\n+      addrs = (_Jv_frame_info *) _Jv_Malloc (n * sizeof (_Jv_frame_info));\n       while (n--)\n-\taddrs[n] = p[n];\n+\t{\n+\t  addrs[n].addr = p[n];\n+#ifdef INTERPRETER\n+\t  if (p[n] >= &_Jv_StartOfInterpreter && p[n] <= &_Jv_EndOfInterpreter)\n+\t    {\n+\t      addrs[n].interp = (void *) interp_frame->self;\n+\t      interp_frame = interp_frame->next;\n+\t    }\n+\t  else\n+\t    addrs[n].interp = 0;\n+#endif // INTERPRETER\n+\t}\n     }\n   else\n     addrs = NULL;"}]}