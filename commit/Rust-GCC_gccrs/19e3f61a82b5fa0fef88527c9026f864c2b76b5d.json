{"sha": "19e3f61a82b5fa0fef88527c9026f864c2b76b5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTllM2Y2MWE4MmI1ZmEwZmVmODg1MjdjOTAyNmY4NjRjMmI3NmI1ZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.cygnus.com", "date": "2000-03-01T00:01:31Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-03-01T00:01:31Z"}, "message": "* calls.c (emit_library_call): Check for null REG.\n\nFrom-SVN: r32270", "tree": {"sha": "bd8682a7d33529b240ffe036d1e25fd460bb2467", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd8682a7d33529b240ffe036d1e25fd460bb2467"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19e3f61a82b5fa0fef88527c9026f864c2b76b5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19e3f61a82b5fa0fef88527c9026f864c2b76b5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19e3f61a82b5fa0fef88527c9026f864c2b76b5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19e3f61a82b5fa0fef88527c9026f864c2b76b5d/comments", "author": null, "committer": null, "parents": [{"sha": "1fcd0c12e3fabc3567a64ddf2fccd006a49c2c06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fcd0c12e3fabc3567a64ddf2fccd006a49c2c06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fcd0c12e3fabc3567a64ddf2fccd006a49c2c06"}], "stats": {"total": 26, "additions": 16, "deletions": 10}, "files": [{"sha": "1868dbe2f3afc693012356e490bd55f967085030", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e3f61a82b5fa0fef88527c9026f864c2b76b5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e3f61a82b5fa0fef88527c9026f864c2b76b5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19e3f61a82b5fa0fef88527c9026f864c2b76b5d", "patch": "@@ -1,3 +1,7 @@\n+2000-02-29  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* calls.c (emit_library_call): Check for null REG.\n+\n 2000-03-01  Martin von Loewis  <loewis@informatik.hu-berlin.de>\n \n \t* c-decl.c (current_function_decl): Move to toplev.c."}, {"sha": "a5bf750c3527d73e1c3aa2a9012488c6c641ecf8", "filename": "gcc/calls.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e3f61a82b5fa0fef88527c9026f864c2b76b5d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e3f61a82b5fa0fef88527c9026f864c2b76b5d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=19e3f61a82b5fa0fef88527c9026f864c2b76b5d", "patch": "@@ -3086,7 +3086,7 @@ emit_library_call VPARAMS((rtx orgfun, int no_queue, enum machine_mode outmode,\n \n       /* Handle calls that pass values in multiple non-contiguous\n \t locations.  The PA64 has examples of this for library calls.  */\n-      if (GET_CODE (reg) == PARALLEL)\n+      if (reg != 0 && GET_CODE (reg) == PARALLEL)\n \temit_group_load (reg, val,\n \t\t\t GET_MODE_SIZE (GET_MODE (val)),\n \t\t\t GET_MODE_ALIGNMENT (GET_MODE (val)));\n@@ -3103,10 +3103,11 @@ emit_library_call VPARAMS((rtx orgfun, int no_queue, enum machine_mode outmode,\n   /* Any regs containing parms remain in use through the call.  */\n   for (count = 0; count < nargs; count++)\n     {\n-      if (GET_CODE (argvec[count].reg) == PARALLEL)\n-\tuse_group_regs (&call_fusage, argvec[count].reg);\n-      else if (argvec[count].reg != 0)\n-\tuse_reg (&call_fusage, argvec[count].reg);\n+      rtx reg = argvec[count].reg;\n+      if (reg != 0 && GET_CODE (argvec[count].reg) == PARALLEL)\n+\tuse_group_regs (&call_fusage, reg);\n+      else if (reg != 0)\n+\tuse_reg (&call_fusage, reg);\n     }\n \n   /* Don't allow popping to be deferred, since then\n@@ -3673,7 +3674,7 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n \n       /* Handle calls that pass values in multiple non-contiguous\n \t locations.  The PA64 has examples of this for library calls.  */\n-      if (GET_CODE (reg) == PARALLEL)\n+      if (reg != 0 && GET_CODE (reg) == PARALLEL)\n \temit_group_load (reg, val,\n \t\t\t GET_MODE_SIZE (GET_MODE (val)),\n \t\t\t GET_MODE_ALIGNMENT (GET_MODE (val)));\n@@ -3692,10 +3693,11 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n   /* Any regs containing parms remain in use through the call.  */\n   for (count = 0; count < nargs; count++)\n     {\n-      if (GET_CODE (argvec[count].reg) == PARALLEL)\n-\tuse_group_regs (&call_fusage, argvec[count].reg);\n-      else if (argvec[count].reg != 0)\n-\tuse_reg (&call_fusage, argvec[count].reg);\n+      rtx reg = argvec[count].reg;\n+      if (reg != 0 && GET_CODE (reg) == PARALLEL)\n+\tuse_group_regs (&call_fusage, reg);\n+      else if (reg != 0)\n+\tuse_reg (&call_fusage, reg);\n     }\n \n   /* Pass the function the address in which to return a structure value.  */"}]}