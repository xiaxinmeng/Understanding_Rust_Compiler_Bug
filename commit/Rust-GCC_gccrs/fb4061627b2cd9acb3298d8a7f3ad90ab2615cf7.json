{"sha": "fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI0MDYxNjI3YjJjZDlhY2IzMjk4ZDhhN2YzYWQ5MGFiMjYxNWNmNw==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2007-03-20T08:31:13Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2007-03-20T08:31:13Z"}, "message": "re PR middle-end/30907 (Propagation of addresses within loops pessimizes code)\n\n2007-03-19  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR rtl-optimization/30907\n\t* fwprop.c (forward_propagate_into): Never propagate inside a loop.\n\t(fwprop_init): Always call loop_optimizer_initialize.\n\t(fwprop_done): Always call loop_optimizer_finalize.\n\t(fwprop): We always have loop info now.\n\t(gate_fwprop_addr): Remove.\n\t(pass_fwprop_addr): Use gate_fwprop as gate.\n\n\tPR rtl-optimization/30841\n\t* df-problems.c (df_ru_local_compute, df_rd_local_compute,\n\tdf_chain_alloc): Call df_reorganize_refs unconditionally.\n\t* df-scan.c (df_rescan_blocks, df_reorganize_refs): Change\n\trefs_organized to refs_organized_size.\n\t(df_ref_create_structure): Use refs_organized_size instead of\n\tbitmap_size if refs had been organized, and keep refs_organized_size\n\tup-to-date.\n\t* df.h (struct df_ref_info): Change refs_organized to\n\trefs_organized_size.\n\t(DF_DEFS_SIZE, DF_USES_SIZE): Use refs_organized_size instead of\n\tbitmap_size.\n\nFrom-SVN: r123084", "tree": {"sha": "ac14daea0ef0dd3b428a5ec40c1293f79e2d5e54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac14daea0ef0dd3b428a5ec40c1293f79e2d5e54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0a85ec2e8c8a0d0632bbfc16ebe2d9eab4010995", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a85ec2e8c8a0d0632bbfc16ebe2d9eab4010995", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a85ec2e8c8a0d0632bbfc16ebe2d9eab4010995"}], "stats": {"total": 113, "additions": 61, "deletions": 52}, "files": [{"sha": "43a8abfd596802245137120321f00bf2849bfaed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7", "patch": "@@ -1,3 +1,26 @@\n+2007-03-19  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR rtl-optimization/30907\n+\t* fwprop.c (forward_propagate_into): Never propagate inside a loop.\n+\t(fwprop_init): Always call loop_optimizer_initialize.\n+\t(fwprop_done): Always call loop_optimizer_finalize.\n+\t(fwprop): We always have loop info now.\n+\t(gate_fwprop_addr): Remove.\n+\t(pass_fwprop_addr): Use gate_fwprop as gate.\n+\n+\tPR rtl-optimization/30841\n+\t* df-problems.c (df_ru_local_compute, df_rd_local_compute,\n+\tdf_chain_alloc): Call df_reorganize_refs unconditionally.\n+\t* df-scan.c (df_rescan_blocks, df_reorganize_refs): Change\n+\trefs_organized to refs_organized_size.\n+\t(df_ref_create_structure): Use refs_organized_size instead of\n+\tbitmap_size if refs had been organized, and keep refs_organized_size\n+\tup-to-date.\n+\t* df.h (struct df_ref_info): Change refs_organized to\n+\trefs_organized_size.\n+\t(DF_DEFS_SIZE, DF_USES_SIZE): Use refs_organized_size instead of\n+\tbitmap_size.\n+\n 2007-03-19  Mark Mitchell  <mark@codesourcery.com>\n \n \t* except.c (output_function_exception_table): Do not reference the"}, {"sha": "42710b203cf08a6039fc1d1901a60b209335e9b5", "filename": "gcc/df-problems.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7", "patch": "@@ -586,9 +586,7 @@ df_ru_local_compute (struct dataflow *dflow,\n   bitmap dense_invalidated = problem_data->dense_invalidated_by_call;\n \n   df_set_seen ();\n-\n-  if (!df->use_info.refs_organized)\n-    df_reorganize_refs (&df->use_info);\n+  df_reorganize_refs (&df->use_info);\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n@@ -1109,9 +1107,7 @@ df_rd_local_compute (struct dataflow *dflow,\n   bitmap dense_invalidated = problem_data->dense_invalidated_by_call;\n \n   df_set_seen ();\n-\n-  if (!df->def_info.refs_organized)\n-    df_reorganize_refs (&df->def_info);\n+  df_reorganize_refs (&df->def_info);\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n@@ -2771,8 +2767,7 @@ df_chain_alloc (struct dataflow *dflow,\n \n   if (dflow->flags & DF_DU_CHAIN)\n     {\n-      if (!df->def_info.refs_organized)\n-\tdf_reorganize_refs (&df->def_info);\n+      df_reorganize_refs (&df->def_info);\n       \n       /* Clear out the pointers from the refs.  */\n       for (i = 0; i < DF_DEFS_SIZE (df); i++)\n@@ -2784,8 +2779,7 @@ df_chain_alloc (struct dataflow *dflow,\n   \n   if (dflow->flags & DF_UD_CHAIN)\n     {\n-      if (!df->use_info.refs_organized)\n-\tdf_reorganize_refs (&df->use_info);\n+      df_reorganize_refs (&df->use_info);\n       for (i = 0; i < DF_USES_SIZE (df); i++)\n \t{\n \t  struct df_ref *ref = df->use_info.refs[i];"}, {"sha": "d88da8a99308b5873b5ae8f8025e04f60e5a5023", "filename": "gcc/df-scan.c", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7", "patch": "@@ -435,8 +435,8 @@ df_rescan_blocks (struct df *df, bitmap blocks)\n   struct dataflow *dflow = df->problems_by_index[DF_SCAN];\n   basic_block bb;\n \n-  df->def_info.refs_organized = false;\n-  df->use_info.refs_organized = false;\n+  df->def_info.refs_organized_size = 0;\n+  df->use_info.refs_organized_size = 0;\n \n   if (blocks)\n     {\n@@ -882,7 +882,7 @@ df_reorganize_refs (struct df_ref_info *ref_info)\n   unsigned int offset = 0;\n   unsigned int size = 0;\n \n-  if (ref_info->refs_organized)\n+  if (ref_info->refs_organized_size)\n     return;\n \n   if (ref_info->refs_size < ref_info->bitmap_size)\n@@ -915,7 +915,7 @@ df_reorganize_refs (struct df_ref_info *ref_info)\n      reset it now that we have squished out all of the empty\n      slots.  */\n   ref_info->bitmap_size = size;\n-  ref_info->refs_organized = true;\n+  ref_info->refs_organized_size = size;\n   ref_info->add_refs_inline = true;\n }\n \n@@ -957,22 +957,25 @@ df_ref_create_structure (struct dataflow *dflow, rtx reg, rtx *loc,\n     case DF_REF_REG_DEF:\n       {\n \tstruct df_reg_info *reg_info = DF_REG_DEF_GET (df, regno);\n-\treg_info->n_refs++;\n+\tunsigned int size = df->def_info.refs_organized_size\n+\t\t\t    ? df->def_info.refs_organized_size\n+\t\t\t    : df->def_info.bitmap_size;\n \t\n \t/* Add the ref to the reg_def chain.  */\n+\treg_info->n_refs++;\n \tdf_reg_chain_create (reg_info, this_ref);\n-\tDF_REF_ID (this_ref) = df->def_info.bitmap_size;\n+\tDF_REF_ID (this_ref) = size;\n \tif (df->def_info.add_refs_inline)\n \t  {\n-\t    if (DF_DEFS_SIZE (df) >= df->def_info.refs_size)\n+\t    if (size >= df->def_info.refs_size)\n \t      {\n-\t\tint new_size = df->def_info.bitmap_size \n-\t\t  + df->def_info.bitmap_size / 4;\n+\t\tint new_size = size + size / 4;\n \t\tdf_grow_ref_info (&df->def_info, new_size);\n \t      }\n \t    /* Add the ref to the big array of defs.  */\n-\t    DF_DEFS_SET (df, df->def_info.bitmap_size, this_ref);\n-\t    df->def_info.refs_organized = false;\n+\t    DF_DEFS_SET (df, size, this_ref);\n+\t    if (df->def_info.refs_organized_size)\n+\t      df->def_info.refs_organized_size++;\n \t  }\n \t\n \tdf->def_info.bitmap_size++;\n@@ -997,22 +1000,25 @@ df_ref_create_structure (struct dataflow *dflow, rtx reg, rtx *loc,\n     case DF_REF_REG_USE:\n       {\n \tstruct df_reg_info *reg_info = DF_REG_USE_GET (df, regno);\n-\treg_info->n_refs++;\n+\tunsigned int size = df->use_info.refs_organized_size\n+\t\t\t    ? df->use_info.refs_organized_size\n+\t\t\t    : df->use_info.bitmap_size;\n \t\n \t/* Add the ref to the reg_use chain.  */\n+\treg_info->n_refs++;\n \tdf_reg_chain_create (reg_info, this_ref);\n-\tDF_REF_ID (this_ref) = df->use_info.bitmap_size;\n+\tDF_REF_ID (this_ref) = size;\n \tif (df->use_info.add_refs_inline)\n \t  {\n-\t    if (DF_USES_SIZE (df) >= df->use_info.refs_size)\n+\t    if (size >= df->use_info.refs_size)\n \t      {\n-\t\tint new_size = df->use_info.bitmap_size \n-\t\t  + df->use_info.bitmap_size / 4;\n+\t\tint new_size = size + size / 4;\n \t\tdf_grow_ref_info (&df->use_info, new_size);\n \t      }\n \t    /* Add the ref to the big array of defs.  */\n-\t    DF_USES_SET (df, df->use_info.bitmap_size, this_ref);\n-\t    df->use_info.refs_organized = false;\n+\t    DF_USES_SET (df, size, this_ref);\n+\t    if (df->def_info.refs_organized_size)\n+\t      df->def_info.refs_organized_size++;\n \t  }\n \t\n \tdf->use_info.bitmap_size++;"}, {"sha": "d8789b9a7f6b4babe02d040d1d3fa04edcbe761e", "filename": "gcc/df.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7", "patch": "@@ -323,9 +323,9 @@ struct df_ref_info\n   unsigned int refs_size;       /* Size of currently allocated refs table.  */\n   unsigned int bitmap_size;\t/* Number of refs seen.  */\n \n-  /* True if refs table is organized so that every reference for a\n+  /* >0 if refs table is organized so that every reference for a\n      pseudo is contiguous.  */\n-  bool refs_organized;\n+  unsigned int refs_organized_size;\n   /* True if the next refs should be added immediately or false to\n      defer to later to reorganize the table.  */\n   bool add_refs_inline; \n@@ -433,10 +433,10 @@ struct df\n                                || DF_REF_REG_MEM_LOAD_P (REF))\n \n /* Macros to get the refs out of def_info or use_info refs table.  */\n-#define DF_DEFS_SIZE(DF) ((DF)->def_info.bitmap_size)\n+#define DF_DEFS_SIZE(DF) ((DF)->def_info.refs_organized_size)\n #define DF_DEFS_GET(DF,ID) ((DF)->def_info.refs[(ID)])\n #define DF_DEFS_SET(DF,ID,VAL) ((DF)->def_info.refs[(ID)]=(VAL))\n-#define DF_USES_SIZE(DF) ((DF)->use_info.bitmap_size)\n+#define DF_USES_SIZE(DF) ((DF)->use_info.refs_organized_size)\n #define DF_USES_GET(DF,ID) ((DF)->use_info.refs[(ID)])\n #define DF_USES_SET(DF,ID,VAL) ((DF)->use_info.refs[(ID)]=(VAL))\n "}, {"sha": "106424efc9672e8daf2c6b39c314123fadac7e42", "filename": "gcc/fwprop.c", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=fb4061627b2cd9acb3298d8a7f3ad90ab2615cf7", "patch": "@@ -862,10 +862,8 @@ forward_propagate_into (struct df_ref *use)\n   if (DF_REF_FLAGS (def) & DF_REF_ARTIFICIAL)\n     return;\n \n-  /* Do not propagate loop invariant definitions inside the loop if\n-     we are going to unroll.  */\n-  if (current_loops\n-      && DF_REF_BB (def)->loop_father != DF_REF_BB (use)->loop_father)\n+  /* Do not propagate loop invariant definitions inside the loop.  */\n+  if (DF_REF_BB (def)->loop_father != DF_REF_BB (use)->loop_father)\n     return;\n \n   /* Check if the use is still present in the insn!  */\n@@ -900,8 +898,7 @@ fwprop_init (void)\n      loops and be careful about them.  But we have to call flow_loops_find\n      before df_analyze, because flow_loops_find may introduce new jump\n      insns (sadly) if we are not working in cfglayout mode.  */\n-  if (flag_rerun_cse_after_loop && (flag_unroll_loops || flag_peel_loops))\n-    loop_optimizer_init (0);\n+  loop_optimizer_init (0);\n \n   /* Now set up the dataflow problem (we only want use-def chains) and\n      put the dataflow solver to work.  */\n@@ -915,10 +912,7 @@ static void\n fwprop_done (void)\n {\n   df_finish (df);\n-\n-  if (flag_rerun_cse_after_loop && (flag_unroll_loops || flag_peel_loops))\n-    loop_optimizer_finalize ();\n-\n+  loop_optimizer_finalize ();\n   free_dominance_info (CDI_DOMINATORS);\n   cleanup_cfg (0);\n   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n@@ -957,8 +951,7 @@ fwprop (void)\n     {\n       struct df_ref *use = DF_USES_GET (df, i);\n       if (use)\n-\tif (!current_loops \n-\t    || DF_REF_TYPE (use) == DF_REF_REG_USE\n+\tif (DF_REF_TYPE (use) == DF_REF_REG_USE\n \t    || DF_REF_BB (use)->loop_father == NULL)\n \t  forward_propagate_into (use);\n     }\n@@ -985,13 +978,6 @@ struct tree_opt_pass pass_rtl_fwprop =\n   0                                     /* letter */\n };\n \n-static bool\n-gate_fwprop_addr (void)\n-{\n-  return optimize > 0 && flag_forward_propagate && flag_rerun_cse_after_loop\n-  \t && (flag_unroll_loops || flag_peel_loops);\n-}\n-\n static unsigned int\n fwprop_addr (void)\n {\n@@ -1018,7 +1004,7 @@ fwprop_addr (void)\n struct tree_opt_pass pass_rtl_fwprop_addr =\n {\n   \"fwprop2\",                            /* name */\n-  gate_fwprop_addr,\t\t\t/* gate */   \n+  gate_fwprop,\t\t\t\t/* gate */   \n   fwprop_addr,\t\t\t\t/* execute */       \n   NULL,                                 /* sub */\n   NULL,                                 /* next */"}]}