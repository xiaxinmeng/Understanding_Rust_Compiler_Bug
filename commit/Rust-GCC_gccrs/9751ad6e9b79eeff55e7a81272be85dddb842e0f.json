{"sha": "9751ad6e9b79eeff55e7a81272be85dddb842e0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc1MWFkNmU5Yjc5ZWVmZjU1ZTdhODEyNzJiZTg1ZGRkYjg0MmUwZg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2017-03-24T13:59:13Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2017-03-24T13:59:13Z"}, "message": "S/390: Rearrange fixuns_trunc pattern definitions.\n\nThis reworks the fixuns_trunc* patterns a bit which got quite confusing\nafter adding z13 support.  Now we just have a single RTL standard name\nexpander definition (\"fixuns_trunc<FP:mode><GPR:mode>2\") which then\nmultiplexes to either the emulation variants *_emu or the hardware\nimplementations.\n\ngcc/ChangeLog:\n\n2017-03-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* config/s390/s390.md\n\t(\"fixuns_truncdddi2\", \"fixuns_trunctddi2\")\n\t(\"fixuns_trunc<BFP:mode><GPR:mode>2\"): Merge into ...\n\t(\"fixuns_trunc<FP:mode><GPR:mode>2\"): New expander.\n\n\t(\"fixuns_trunc<BFP:mode><GPR:mode>2\", \"fixuns_trunc<mode>si2\"):\n\tRename expanders to ...\n\n\t(\"fixuns_trunc<BFP:mode><GPR:mode>2_emu\")\n\t(\"fixuns_truncdddi2_emu\"): ... these.\n\n\t(\"fixuns_trunc<mode>si2_emu\"): New expander.\n\n\t(\"*fixuns_truncdfdi2_z13\"): Rename to ...\n\t(\"*fixuns_truncdfdi2_vx\"): ... this.\n\nFrom-SVN: r246451", "tree": {"sha": "1bfcbef3bf46dca78b0d4f6a139e9e7e2dc5f157", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bfcbef3bf46dca78b0d4f6a139e9e7e2dc5f157"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9751ad6e9b79eeff55e7a81272be85dddb842e0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9751ad6e9b79eeff55e7a81272be85dddb842e0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9751ad6e9b79eeff55e7a81272be85dddb842e0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9751ad6e9b79eeff55e7a81272be85dddb842e0f/comments", "author": null, "committer": null, "parents": [{"sha": "77c585ca576b4bc6bf7850c40771862667f6c0e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77c585ca576b4bc6bf7850c40771862667f6c0e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77c585ca576b4bc6bf7850c40771862667f6c0e7"}], "stats": {"total": 271, "additions": 161, "deletions": 110}, "files": [{"sha": "4efabf0d81ed99b7f9cc6b5d6c0f295d84bff8df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9751ad6e9b79eeff55e7a81272be85dddb842e0f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9751ad6e9b79eeff55e7a81272be85dddb842e0f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9751ad6e9b79eeff55e7a81272be85dddb842e0f", "patch": "@@ -1,3 +1,21 @@\n+2017-03-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390.md\n+\t(\"fixuns_truncdddi2\", \"fixuns_trunctddi2\")\n+\t(\"fixuns_trunc<BFP:mode><GPR:mode>2\"): Merge into ...\n+\t(\"fixuns_trunc<FP:mode><GPR:mode>2\"): New expander.\n+\n+\t(\"fixuns_trunc<BFP:mode><GPR:mode>2\", \"fixuns_trunc<mode>si2\"):\n+\tRename expanders to ...\n+\n+\t(\"fixuns_trunc<BFP:mode><GPR:mode>2_emu\")\n+\t(\"fixuns_truncdddi2_emu\"): ... these.\n+\n+\t(\"fixuns_trunc<mode>si2_emu\"): New expander.\n+\n+\t(\"*fixuns_truncdfdi2_z13\"): Rename to ...\n+\t(\"*fixuns_truncdfdi2_vx\"): ... this.\n+\n 2017-03-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/2964.md: Remove the single element vector compare"}, {"sha": "d4d3781d3a7f629ed8006904181483ee2020eb3e", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 143, "deletions": 110, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9751ad6e9b79eeff55e7a81272be85dddb842e0f/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9751ad6e9b79eeff55e7a81272be85dddb842e0f/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=9751ad6e9b79eeff55e7a81272be85dddb842e0f", "patch": "@@ -4735,152 +4735,185 @@\n   \"operands[2] = gen_lowpart (QImode, operands[0]);\")\n \n ;\n-; fixuns_trunc(dd|td)di2 instruction pattern(s).\n+; fixuns_trunc(dd|td|sf|df|tf)(si|di)2 expander\n ;\n \n-(define_expand \"fixuns_truncdddi2\"\n+; This is the only entry point for fixuns_trunc.  It multiplexes the\n+; expansion to either the *_emu expanders below for pre z196 machines\n+; or emits the default pattern otherwise.\n+(define_expand \"fixuns_trunc<FP:mode><GPR:mode>2\"\n   [(parallel\n-    [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t  (unsigned_fix:DI (match_operand:DD 1 \"register_operand\" \"\")))\n-     (unspec:DI [(const_int DFP_RND_TOWARD_0)] UNSPEC_ROUND)\n+    [(set (match_operand:GPR 0 \"register_operand\" \"\")\n+\t  (unsigned_fix:GPR (match_operand:FP 1 \"register_operand\" \"\")))\n+     (unspec:GPR [(match_dup 2)] UNSPEC_ROUND)\n      (clobber (reg:CC CC_REGNUM))])]\n-\n-  \"TARGET_HARD_DFP\"\n+  \"TARGET_HARD_FLOAT\"\n {\n   if (!TARGET_Z196)\n     {\n-      rtx_code_label *label1 = gen_label_rtx ();\n-      rtx_code_label *label2 = gen_label_rtx ();\n-      rtx temp = gen_reg_rtx (TDmode);\n-      REAL_VALUE_TYPE cmp, sub;\n-\n-      decimal_real_from_string (&cmp, \"9223372036854775808.0\");  /* 2^63 */\n-      decimal_real_from_string (&sub, \"18446744073709551616.0\"); /* 2^64 */\n-\n-      /* 2^63 can't be represented as 64bit DFP number with full precision.  The\n-         solution is doing the check and the subtraction in TD mode and using a\n-         TD -> DI convert afterwards.  */\n-      emit_insn (gen_extendddtd2 (temp, operands[1]));\n-      temp = force_reg (TDmode, temp);\n-      emit_cmp_and_jump_insns (temp,\n-\t    const_double_from_real_value (cmp, TDmode),\n-\t    LT, NULL_RTX, VOIDmode, 0, label1);\n-      emit_insn (gen_subtd3 (temp, temp,\n-\t    const_double_from_real_value (sub, TDmode)));\n-      emit_insn (gen_fix_trunctddi2_dfp (operands[0], temp,\n-\t\t\t\t\t GEN_INT (DFP_RND_TOWARD_MINF)));\n-      emit_jump (label2);\n-\n-      emit_label (label1);\n-      emit_insn (gen_fix_truncdddi2_dfp (operands[0], operands[1],\n-\t\t\t\t\t GEN_INT (DFP_RND_TOWARD_0)));\n-      emit_label (label2);\n+      /* We don't provide emulation for TD|DD->SI.  */\n+      if (GET_MODE_CLASS (<FP:MODE>mode) == MODE_DECIMAL_FLOAT\n+\t  && <GPR:MODE>mode == SImode)\n+\tFAIL;\n+      emit_insn (gen_fixuns_trunc<FP:mode><GPR:mode>2_emu (operands[0],\n+\t\t\t\t\t\t\t       operands[1]));\n       DONE;\n     }\n+\n+  if (GET_MODE_CLASS (<FP:MODE>mode) == MODE_DECIMAL_FLOAT)\n+    operands[2] = GEN_INT (DFP_RND_TOWARD_0);\n+  else\n+    operands[2] = GEN_INT (BFP_RND_TOWARD_0);\n+})\n+\n+; (sf|df|tf)->unsigned (si|di)\n+\n+; Emulate the unsigned conversion with the signed version for pre z196\n+; machines.\n+(define_expand \"fixuns_trunc<BFP:mode><GPR:mode>2_emu\"\n+  [(parallel\n+    [(set (match_operand:GPR 0 \"register_operand\" \"\")\n+\t  (unsigned_fix:GPR (match_operand:BFP 1 \"register_operand\" \"\")))\n+     (unspec:GPR [(const_int BFP_RND_TOWARD_0)] UNSPEC_ROUND)\n+     (clobber (reg:CC CC_REGNUM))])]\n+  \"!TARGET_Z196 && TARGET_HARD_FLOAT\"\n+{\n+  rtx_code_label *label1 = gen_label_rtx ();\n+  rtx_code_label *label2 = gen_label_rtx ();\n+  rtx temp = gen_reg_rtx (<BFP:MODE>mode);\n+  REAL_VALUE_TYPE cmp, sub;\n+\n+  operands[1] = force_reg (<BFP:MODE>mode, operands[1]);\n+  real_2expN (&cmp, <GPR:bitsize> - 1, <BFP:MODE>mode);\n+  real_2expN (&sub, <GPR:bitsize>, <BFP:MODE>mode);\n+\n+  emit_cmp_and_jump_insns (operands[1],\n+\t\t\t   const_double_from_real_value (cmp, <BFP:MODE>mode),\n+\t\t\t   LT, NULL_RTX, VOIDmode, 0, label1);\n+  emit_insn (gen_sub<BFP:mode>3 (temp, operands[1],\n+\t       const_double_from_real_value (sub, <BFP:MODE>mode)));\n+  emit_insn (gen_fix_trunc<BFP:mode><GPR:mode>2_bfp (operands[0], temp,\n+\t       GEN_INT (BFP_RND_TOWARD_MINF)));\n+  emit_jump (label2);\n+\n+  emit_label (label1);\n+  emit_insn (gen_fix_trunc<BFP:mode><GPR:mode>2_bfp (operands[0],\n+\t\t\t\t\t\t\t operands[1],\n+\t\t\t\t\t\t\t GEN_INT (BFP_RND_TOWARD_0)));\n+  emit_label (label2);\n+  DONE;\n })\n \n-(define_expand \"fixuns_trunctddi2\"\n+; dd->unsigned di\n+\n+; Emulate the unsigned conversion with the signed version for pre z196\n+; machines.\n+(define_expand \"fixuns_truncdddi2_emu\"\n   [(parallel\n     [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t  (unsigned_fix:DI (match_operand:TD 1 \"register_operand\" \"\")))\n+\t  (unsigned_fix:DI (match_operand:DD 1 \"register_operand\" \"\")))\n      (unspec:DI [(const_int DFP_RND_TOWARD_0)] UNSPEC_ROUND)\n      (clobber (reg:CC CC_REGNUM))])]\n \n-  \"TARGET_HARD_DFP\"\n-{\n-  if (!TARGET_Z196)\n-    {\n-      rtx_code_label *label1 = gen_label_rtx ();\n-      rtx_code_label *label2 = gen_label_rtx ();\n-      rtx temp = gen_reg_rtx (TDmode);\n-      REAL_VALUE_TYPE cmp, sub;\n-\n-      operands[1] = force_reg (TDmode, operands[1]);\n-      decimal_real_from_string (&cmp, \"9223372036854775808.0\");  /* 2^63 */\n-      decimal_real_from_string (&sub, \"18446744073709551616.0\"); /* 2^64 */\n-\n-      emit_cmp_and_jump_insns (operands[1],\n-\t    const_double_from_real_value (cmp, TDmode),\n-\t    LT, NULL_RTX, VOIDmode, 0, label1);\n-      emit_insn (gen_subtd3 (temp, operands[1],\n-\t    const_double_from_real_value (sub, TDmode)));\n-      emit_insn (gen_fix_trunctddi2_dfp (operands[0], temp,\n-\t\t\t\t\t GEN_INT (DFP_RND_TOWARD_MINF)));\n-      emit_jump (label2);\n-\n-      emit_label (label1);\n-      emit_insn (gen_fix_trunctddi2_dfp (operands[0], operands[1],\n-\t\t\t\t\t GEN_INT (DFP_RND_TOWARD_0)));\n-      emit_label (label2);\n-      DONE;\n-    }\n+  \"!TARGET_Z196 && TARGET_HARD_DFP\"\n+{\n+  rtx_code_label *label1 = gen_label_rtx ();\n+  rtx_code_label *label2 = gen_label_rtx ();\n+  rtx temp = gen_reg_rtx (TDmode);\n+  REAL_VALUE_TYPE cmp, sub;\n+\n+  decimal_real_from_string (&cmp, \"9223372036854775808.0\");  /* 2^63 */\n+  decimal_real_from_string (&sub, \"18446744073709551616.0\"); /* 2^64 */\n+\n+  /* 2^63 can't be represented as 64bit DFP number with full precision.  The\n+     solution is doing the check and the subtraction in TD mode and using a\n+     TD -> DI convert afterwards.  */\n+  emit_insn (gen_extendddtd2 (temp, operands[1]));\n+  temp = force_reg (TDmode, temp);\n+  emit_cmp_and_jump_insns (temp,\n+\t\t\t   const_double_from_real_value (cmp, TDmode),\n+\t\t\t   LT, NULL_RTX, VOIDmode, 0, label1);\n+  emit_insn (gen_subtd3 (temp, temp,\n+\t\t\t const_double_from_real_value (sub, TDmode)));\n+  emit_insn (gen_fix_trunctddi2_dfp (operands[0], temp,\n+\t\t\t\t     GEN_INT (DFP_RND_TOWARD_MINF)));\n+  emit_jump (label2);\n+\n+  emit_label (label1);\n+  emit_insn (gen_fix_truncdddi2_dfp (operands[0], operands[1],\n+\t\t\t\t     GEN_INT (DFP_RND_TOWARD_0)));\n+  emit_label (label2);\n+  DONE;\n })\n \n-;\n-; fixuns_trunc(sf|df|tf)(si|di)2 and fix_trunc(sf|df|tf)(si|di)2\n-; instruction pattern(s).\n-;\n+; td->unsigned di\n \n-(define_expand \"fixuns_trunc<BFP:mode><GPR:mode>2\"\n+; Emulate the unsigned conversion with the signed version for pre z196\n+; machines.\n+(define_expand \"fixuns_trunctddi2_emu\"\n   [(parallel\n-    [(set (match_operand:GPR 0 \"register_operand\" \"\")\n-\t  (unsigned_fix:GPR (match_operand:BFP 1 \"register_operand\" \"\")))\n-     (unspec:GPR [(const_int BFP_RND_TOWARD_0)] UNSPEC_ROUND)\n+    [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t  (unsigned_fix:DI (match_operand:TD 1 \"register_operand\" \"\")))\n+     (unspec:DI [(const_int DFP_RND_TOWARD_0)] UNSPEC_ROUND)\n      (clobber (reg:CC CC_REGNUM))])]\n-  \"TARGET_HARD_FLOAT\"\n-{\n-  if (!TARGET_Z196)\n-    {\n-      rtx_code_label *label1 = gen_label_rtx ();\n-      rtx_code_label *label2 = gen_label_rtx ();\n-      rtx temp = gen_reg_rtx (<BFP:MODE>mode);\n-      REAL_VALUE_TYPE cmp, sub;\n-\n-      operands[1] = force_reg (<BFP:MODE>mode, operands[1]);\n-      real_2expN (&cmp, <GPR:bitsize> - 1, <BFP:MODE>mode);\n-      real_2expN (&sub, <GPR:bitsize>, <BFP:MODE>mode);\n-\n-      emit_cmp_and_jump_insns (operands[1],\n-\t    const_double_from_real_value (cmp, <BFP:MODE>mode),\n-\t    LT, NULL_RTX, VOIDmode, 0, label1);\n-      emit_insn (gen_sub<BFP:mode>3 (temp, operands[1],\n-\t    const_double_from_real_value (sub, <BFP:MODE>mode)));\n-      emit_insn (gen_fix_trunc<BFP:mode><GPR:mode>2_bfp (operands[0], temp,\n-\t    GEN_INT (BFP_RND_TOWARD_MINF)));\n-      emit_jump (label2);\n \n-      emit_label (label1);\n-      emit_insn (gen_fix_trunc<BFP:mode><GPR:mode>2_bfp (operands[0],\n-\t    operands[1], GEN_INT (BFP_RND_TOWARD_0)));\n-      emit_label (label2);\n-      DONE;\n-    }\n+  \"!TARGET_Z196 && TARGET_HARD_DFP\"\n+{\n+  rtx_code_label *label1 = gen_label_rtx ();\n+  rtx_code_label *label2 = gen_label_rtx ();\n+  rtx temp = gen_reg_rtx (TDmode);\n+  REAL_VALUE_TYPE cmp, sub;\n+\n+  operands[1] = force_reg (TDmode, operands[1]);\n+  decimal_real_from_string (&cmp, \"9223372036854775808.0\");  /* 2^63 */\n+  decimal_real_from_string (&sub, \"18446744073709551616.0\"); /* 2^64 */\n+\n+  emit_cmp_and_jump_insns (operands[1],\n+\t\t\t   const_double_from_real_value (cmp, TDmode),\n+\t\t\t   LT, NULL_RTX, VOIDmode, 0, label1);\n+  emit_insn (gen_subtd3 (temp, operands[1],\n+\t\t\t const_double_from_real_value (sub, TDmode)));\n+  emit_insn (gen_fix_trunctddi2_dfp (operands[0], temp,\n+\t\t\t\t     GEN_INT (DFP_RND_TOWARD_MINF)));\n+  emit_jump (label2);\n+\n+  emit_label (label1);\n+  emit_insn (gen_fix_trunctddi2_dfp (operands[0], operands[1],\n+\t\t\t\t     GEN_INT (DFP_RND_TOWARD_0)));\n+  emit_label (label2);\n+  DONE;\n })\n \n-; fixuns_trunc(td|dd)si2 expander\n-(define_expand \"fixuns_trunc<mode>si2\"\n+; Just a dummy to make the code in the first expander a bit easier.\n+(define_expand \"fixuns_trunc<mode>si2_emu\"\n   [(parallel\n     [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t  (unsigned_fix:SI (match_operand:DFP 1 \"register_operand\" \"\")))\n-     (unspec:SI [(const_int DFP_RND_TOWARD_0)] UNSPEC_ROUND)\n+     (unspec:DI [(const_int DFP_RND_TOWARD_0)] UNSPEC_ROUND)\n      (clobber (reg:CC CC_REGNUM))])]\n-  \"TARGET_Z196 && TARGET_HARD_DFP\"\n-  \"\")\n+\n+  \"!TARGET_Z196 && TARGET_HARD_DFP\"\n+ {\n+   FAIL;\n+ })\n+\n \n ; fixuns_trunc(tf|df|sf|td|dd)(di|si)2 instruction patterns.\n \n-(define_insn \"*fixuns_truncdfdi2_z13\"\n+; df -> unsigned di\n+(define_insn \"*fixuns_truncdfdi2_vx\"\n   [(set (match_operand:DI                  0 \"register_operand\" \"=d,v\")\n \t(unsigned_fix:DI (match_operand:DF 1 \"register_operand\"  \"f,v\")))\n    (unspec:DI [(match_operand:DI           2 \"immediate_operand\" \"K,K\")] UNSPEC_ROUND)\n    (clobber (reg:CC CC_REGNUM))]\n-   \"TARGET_VX && TARGET_HARD_FLOAT\"\n-   \"@\n-    clgdbr\\t%0,%h2,%1,0\n-    wclgdb\\t%v0,%v1,0,%h2\"\n-   [(set_attr \"op_type\" \"RRF,VRR\")\n-    (set_attr \"type\"    \"ftoi\")])\n+  \"TARGET_VX && TARGET_HARD_FLOAT\"\n+  \"@\n+   clgdbr\\t%0,%h2,%1,0\n+   wclgdb\\t%v0,%v1,0,%h2\"\n+  [(set_attr \"op_type\" \"RRF,VRR\")\n+   (set_attr \"type\"    \"ftoi\")])\n \n+; (dd|td|sf|df|tf)->unsigned (di|si)\n ; clfebr, clfdbr, clfxbr, clgebr, clgdbr, clgxbr\n ;         clfdtr, clfxtr,         clgdtr, clgxtr\n (define_insn \"*fixuns_trunc<FP:mode><GPR:mode>2_z196\""}]}