{"sha": "31418d3513edce4366a45f622701fbc858c3dad8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE0MThkMzUxM2VkY2U0MzY2YTQ1ZjYyMjcwMWZiYzg1OGMzZGFkOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1997-04-13T18:20:27Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1997-04-13T18:20:27Z"}, "message": "Remove REG_DEAD notes when eliminating a set in the reload CSE pass\n\nFrom-SVN: r13886", "tree": {"sha": "d74b15c353fc918f810a88f42550e51d5ed4113d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d74b15c353fc918f810a88f42550e51d5ed4113d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31418d3513edce4366a45f622701fbc858c3dad8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31418d3513edce4366a45f622701fbc858c3dad8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31418d3513edce4366a45f622701fbc858c3dad8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31418d3513edce4366a45f622701fbc858c3dad8/comments", "author": null, "committer": null, "parents": [{"sha": "c7063b9a371df4010a5fcabdf9f6fba19a4626c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7063b9a371df4010a5fcabdf9f6fba19a4626c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7063b9a371df4010a5fcabdf9f6fba19a4626c5"}], "stats": {"total": 95, "additions": 74, "deletions": 21}, "files": [{"sha": "119e51a45780f8527c4f2b5fc646f2296846e6ae", "filename": "gcc/reload1.c", "status": "modified", "additions": 74, "deletions": 21, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31418d3513edce4366a45f622701fbc858c3dad8/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31418d3513edce4366a45f622701fbc858c3dad8/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=31418d3513edce4366a45f622701fbc858c3dad8", "patch": "@@ -400,7 +400,7 @@ static void reload_cse_invalidate_mem\tPROTO((rtx));\n static void reload_cse_invalidate_rtx\tPROTO((rtx, rtx));\n static void reload_cse_regs\t\tPROTO((rtx));\n static int reload_cse_regno_equal_p\tPROTO((int, rtx, enum machine_mode));\n-static int reload_cse_noop_set_p\tPROTO((rtx));\n+static int reload_cse_noop_set_p\tPROTO((rtx, rtx));\n static void reload_cse_simplify_set\tPROTO((rtx, rtx));\n static void reload_cse_check_clobber\tPROTO((rtx, rtx));\n static void reload_cse_record_set\tPROTO((rtx, rtx));\n@@ -7844,11 +7844,8 @@ reload_cse_regs (first)\n       body = PATTERN (insn);\n       if (GET_CODE (body) == SET)\n \t{\n-\t  if (reload_cse_noop_set_p (body))\n+\t  if (reload_cse_noop_set_p (body, insn))\n \t    {\n-\t      /* If we were preserving death notes, then we would want\n-\t\t to remove any existing death note for the register\n-\t\t being set.  */\n \t      PUT_CODE (insn, NOTE);\n \t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \t      NOTE_SOURCE_FILE (insn) = 0;\n@@ -7868,13 +7865,10 @@ reload_cse_regs (first)\n              the entire PARALLEL.  */\n \t  for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n \t    if (GET_CODE (XVECEXP (body, 0, i)) != SET\n-\t\t|| ! reload_cse_noop_set_p (XVECEXP (body, 0, i)))\n+\t\t|| ! reload_cse_noop_set_p (XVECEXP (body, 0, i), insn))\n \t      break;\n \t  if (i < 0)\n \t    {\n-\t      /* If we were preserving death notes, then we would want\n-\t\t to remove any existing death notes for the registers\n-\t\t being set.  */\n \t      PUT_CODE (insn, NOTE);\n \t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \t      NOTE_SOURCE_FILE (insn) = 0;\n@@ -7957,15 +7951,18 @@ reload_cse_regno_equal_p (regno, val, mode)\n   return 0;\n }\n \n-/* See whether a single SET instruction is a nooop.  */\n+/* See whether a single set is a noop.  SET is the set instruction we\n+   are should check, and INSN is the instruction from which it came.  */\n \n static int\n-reload_cse_noop_set_p (set)\n+reload_cse_noop_set_p (set, insn)\n      rtx set;\n+     rtx insn;\n {\n   rtx src, dest;\n   enum machine_mode dest_mode;\n   int dreg, sreg;\n+  int ret;\n \n   src = SET_SRC (set);\n   dest = SET_DEST (set);\n@@ -7977,27 +7974,38 @@ reload_cse_noop_set_p (set)\n   dreg = true_regnum (dest);\n   sreg = true_regnum (src);\n \n+  /* Check for setting a register to itself.  In this case, we don't\n+     have to worry about REG_DEAD notes.  */\n+  if (dreg >= 0 && dreg == sreg)\n+    return 1;\n+\n+  ret = 0;\n   if (dreg >= 0)\n     {\n       /* Check for setting a register to itself.  */\n       if (dreg == sreg)\n-\treturn 1;\n+\tret = 1;\n \n       /* Check for setting a register to a value which we already know\n          is in the register.  */\n-      if (reload_cse_regno_equal_p (dreg, src, dest_mode))\n-\treturn 1;\n+      else if (reload_cse_regno_equal_p (dreg, src, dest_mode))\n+\tret = 1;\n \n       /* Check for setting a register DREG to another register SREG\n          where SREG is equal to a value which is already in DREG.  */\n-      if (sreg >= 0)\n+      else if (sreg >= 0)\n \t{\n \t  rtx x;\n \n \t  for (x = reg_values[sreg]; x; x = XEXP (x, 1))\n-\t    if (XEXP (x, 0) != 0\n-\t\t&& reload_cse_regno_equal_p (dreg, XEXP (x, 0), dest_mode))\n-\t      return 1;\n+\t    {\n+\t      if (XEXP (x, 0) != 0\n+\t\t  && reload_cse_regno_equal_p (dreg, XEXP (x, 0), dest_mode))\n+\t\t{\n+\t\t  ret = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n \t}\n     }\n   else if (GET_CODE (dest) == MEM)\n@@ -8007,10 +8015,33 @@ reload_cse_noop_set_p (set)\n       if (sreg >= 0\n \t  && reload_cse_regno_equal_p (sreg, dest, dest_mode)\n \t  && ! side_effects_p (dest))\n-\treturn 1;\n+\tret = 1;\n     }\n \n-  return 0;\n+  /* If we can delete this SET, then we need to look for an earlier\n+     REG_DEAD note on DREG, and remove it if it exists.  */\n+  if (ret)\n+    {\n+      if (! find_regno_note (insn, REG_UNUSED, dreg))\n+\t{\n+\t  rtx trial;\n+\n+\t  for (trial = prev_nonnote_insn (insn);\n+\t       (trial\n+\t\t&& GET_CODE (trial) != CODE_LABEL\n+\t\t&& GET_CODE (trial) != BARRIER);\n+\t       trial = prev_nonnote_insn (trial))\n+\t    {\n+\t      if (find_regno_note (trial, REG_DEAD, dreg))\n+\t\t{\n+\t\t  remove_death (dreg, trial);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  return ret;\n }\n \n /* Try to simplify a single SET instruction.  SET is the set pattern.\n@@ -8065,7 +8096,29 @@ reload_cse_simplify_set (set, insn)\n \t  push_obstacks (&reload_obstack, &reload_obstack);\n \n \t  if (validated)\n-\t    return;\n+\t    {\n+\t      /* We need to look for an earlier REG_DEAD note on I,\n+\t\t and remove it if it exists.  */\n+\t      if (! find_regno_note (insn, REG_UNUSED, i))\n+\t\t{\n+\t\t  rtx trial;\n+\n+\t\t  for (trial = prev_nonnote_insn (insn);\n+\t\t       (trial\n+\t\t\t&& GET_CODE (trial) != CODE_LABEL\n+\t\t\t&& GET_CODE (trial) != BARRIER);\n+\t\t       trial = prev_nonnote_insn (trial))\n+\t\t    {\n+\t\t      if (find_regno_note (trial, REG_DEAD, i))\n+\t\t\t{\n+\t\t\t  remove_death (i, trial);\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\n+\t      return;\n+\t    }\n \t}\n     }\n }"}]}