{"sha": "4d779342f00ac9b678043e8a2e474a1ae14b8660", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ3NzkzNDJmMDBhYzliNjc4MDQzZThhMmU0NzRhMWFlMTRiODY2MA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2006-01-11T12:57:18Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2006-01-11T12:57:18Z"}, "message": "df.h (DF_SCAN, [...]): New macros.\n\n2005-01-11  Danny Berlin <dberlin@dberlin.org>\n            Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* df.h (DF_SCAN, DF_RU, DF_RD, DF_LR, DF_UR, DF_UREC, DF_CHAIN,\n\tDF_RI, DF_LAST_PROBLEM_PLUS1, DF_DU_CHAIN, DF_UD_CHAIN,\n\tDF_REF_TYPE_NAMES, DF_HARD_REGS, DF_EQUIV_NOTES, DF_SUBREGS,\n\tDF_SCAN_BB_INFO, DF_RU_BB_INFO, DF_RD_BB_INFO, DF_LR_BB_INFO,\n\tDF_UR_BB_INFO, DF_UREC_BB_INFO, DF_LIVE_IN, DF_LIVE_OUT,\n\tDF_RA_LIVE_IN, DF_RA_LIVE_OUT, DF_UPWARD_LIVE_IN,\n\tDF_UPWARD_LIVE_OUT, DF_REF_REAL_REG, DF_REF_REGNO,\n\tDF_REF_REAL_LOC, DF_REF_REG, DF_REF_LOC, DF_REF_BB, DF_REF_BBNO,\n\tDF_REF_INSN, DF_REF_INSN_UID, DF_REF_TYPE, DF_REF_CHAIN,\n\tDF_REF_ID, DF_REF_FLAGS, DF_REF_NEXT_REG, DF_REF_PREV_REG,\n\tDF_REF_NEXT_REF, DF_REF_DATA, DF_REF_REG_DEF_P, DF_REF_REG_USE_P,\n\tDF_REF_REG_MEM_STORE_P, DF_REF_REG_MEM_LOAD_P, DF_REF_REG_MEM_P,\n\tDF_DEFS_SIZE, DF_DEFS_GET, DF_DEFS_SET, DF_USES_SIZE, DF_USES_GET,\n\tDF_USES_SET, DF_REG_SIZE, DF_REG_DEF_GET, DF_REG_DEF_SET,\n\tDF_REG_USE_GET, DF_REG_USE_SET, DF_REGNO_FIRST_DEF,\n\tDF_REGNO_LAST_USE, DF_INSN_SIZE, DF_INSN_GET, DF_INSN_SET,\n\tDF_INSN_CONTAINS_ASM, DF_INSN_LUID, DF_INSN_DEFS, DF_INSN_USES,\n\tDF_INSN_UID_GET, DF_INSN_UID_LUID, DF_INSN_UID_DEFS,\n\tDF_INSN_UID_USES, DF_SCAN_INITIAL, DF_SCAN_GLOBAL,\n\tDF_SCAN_POST_ALLOC): New macros.\n\t(df_flow_dir, df_ref_type, df_ref_flags, df_alloc_function,\n\tdf_free_bb_function, df_local_compute_function, df_init_function,\n\tdf_dataflow_function, df_confluence_function_0,\n\tdf_confluence_function_n, df_transfer_function,\n\tdf_finalizer_function, df_free_function, df_dump_problem_function,\n\tdf_problem, dataflow, df_insn_info, df_reg_info, df_ref, df_link,\n\tdf_ref_info, df, df_map, df_scan_bb_info, df_ru_bb_info,\n\tdf_ru_bb_info, df_rd_bb_info, df_lr_bb_info, df_ur_bb_info,\n\tdf_urec_bb_info, ) New types.\n\t(df_invalidated_by_call, df_all_hard_regs, df_state) New public\n\tvariables.\n\t(df_init, df_add_problem, df_set_blocks, df_finish, df_analyze,\n\tdf_analyze_simple_change_some_blocks,\n\tdf_analyze_simple_change_one_block, df_compact_blocks,\n\tdf_bb_replace, df_bb_regno_last_use_find,\n\tdf_bb_regno_first_def_find, df_bb_regno_last_def_find,\n\tdf_insn_regno_def_p, df_find_def, df_find_use,\n\tdf_iterative_dataflow, df_dump, df_chain_dump, df_refs_chain_dump,\n\tdf_regs_chain_dump, df_insn_debug, df_insn_debug_regno,\n\tdf_regno_debug, df_ref_debug, debug_df_insn, debug_df_regno,\n\tdebug_df_reg, debug_df_defno, debug_df_useno, debug_df_ref,\n\tdebug_df_chain, df_get_dependent_problem, df_chain_create,\n\tdf_chain_unlink, df_chain_copy, df_get_live_in, df_get_live_out,\n\tdf_grow_bb_info, df_chain_dump, df_print_bb_index,\n\tdf_ru_add_problem, df_ru_get_bb_info, df_rd_add_problem,\n\tdf_rd_get_bb_info, df_lr_add_problem, df_lr_get_bb_info,\n\tdf_ur_add_problem, df_ur_get_bb_info, df_urec_add_problem,\n\tdf_urec_get_bb_info, df_chain_add_problem, df_ri_add_problem,\n\tdf_reg_lifetime, df_scan_get_bb_info, df_scan_add_problem,\n\tdf_rescan_blocks, df_ref_create, df_get_artificial_defs,\n\tdf_get_artificial_uses, df_reg_chain_create, df_reg_chain_unlink,\n\tdf_ref_remove, df_insn_refs_delete, df_refs_delete,\n\tdf_reorganize_refs, df_set_state, df_hard_reg_init,\n\tdf_read_modify_subreg_p) New public functions.\n        * df-core.c: The core dataflow solver and glue routines for rtl\n\tdataflow.\n\t(df_init, df_add_problem, df_set_blocks, df_finish,\n\tdf_hybrid_search_forward, df_hybrid_search_backward,\n\tdf_iterative_dataflow, df_prune_to_subcfg, df_analyze_problem,\n\tdf_analyze, df_get_bb_info, df_set_bb_info, df_bb_replace,\n\tdf_bb_regno_last_use_find, df_bb_regno_first_def_find,\n\tdf_bb_regno_last_def_find, df_insn_regno_def_p, df_find_def,\n\tdf_reg_defined, df_find_use, df_reg_used, df_dump,\n\tdf_refs_chain_dump, df_regs_chain_dump, df_insn_debug,\n\tdf_insn_debug_regno, df_regno_debug, df_ref_debug, debug_df_insn,\n\tdebug_df_reg, debug_df_regno, debug_df_ref debug_df_defno,\n\tdebug_df_useno, reset_df_after_reload): New functions.\n\t* df-scan.c: The scanning fuctions, once in df.c, completely\n\trewritten so that they now fully model the functionality of\n\tregister usage at the backend.\n\t(df_scan_free_internal, df_scan_get_bb_info, df_scan_set_bb_info,\n\tdf_scan_free_bb_info, df_scan_alloc, df_scan_free, df_scan_dump,\n\tdf_scan_add_problem, df_grow_reg_info, df_grow_ref_info,\n\tdf_grow_insn_info, df_rescan_blocks, df_ref_create,\n\tdf_get_artificial_defs, df_get_artificial_uses,\n\tdf_reg_chain_create, df_ref_unlink, df_reg_chain_unlink,\n\tdf_ref_remove, df_insn_create_insn_record, df_insn_refs_delete,\n\tdf_refs_delete, df_reorganize_refs, df_set_state,\n\tdf_ref_create_structure, df_ref_record, df_read_modify_subreg_p,\n\tdf_def_record_1, df_defs_record, df_uses_record,\n\tdf_insn_contains_asm_1, df_insn_contains_asm, df_insn_refs_record,\n\tdf_has_eh_preds, df_bb_refs_record, df_refs_record, df_mark_reg,\n\tdf_record_exit_block_uses, df_hard_reg_init): New functions.\n\n\t* df-problems.c: Seven concrete dataflow problems that use the\n\tscanning in df-scan.c and are solved by the engine in df-core.c.\n\t(df_get_dependent_problem, df_chain_create, df_chain_unlink,\n\tdf_chain_copy, df_get_live_in, df_get_live_out, df_grow_bb_info,\n\tdf_chain_dump, df_print_bb_index, df_ref_bitmap, df_set_seen,\n\tdf_unset_seen, df_ru_get_bb_info, df_ru_set_bb_info,\n\tdf_ru_free_bb_info, df_ru_alloc,\n\tdf_ru_bb_local_compute_process_def,\n\tdf_ru_bb_local_compute_process_use, df_ru_bb_local_compute,\n\tdf_ru_local_compute, df_ru_init_solution, df_ru_confluence_n,\n\tdf_ru_transfer_function, df_ru_free, df_ru_dump,\n\tdf_ru_add_problem, df_rd_get_bb_info, df_rd_set_bb_info,\n\tdf_rd_free_bb_info, df_rd_alloc,\n\tdf_rd_bb_local_compute_process_def, df_rd_bb_local_compute,\n\tdf_rd_local_compute, df_rd_init_solution, df_rd_confluence_n,\n\tdf_rd_transfer_function, df_rd_free, df_rd_dump,\n\tdf_rd_add_problem, df_lr_get_bb_info, df_lr_set_bb_info,\n\tdf_lr_free_bb_info, df_lr_alloc, df_lr_bb_local_compute,\n\tdf_lr_local_compute, df_lr_init, df_lr_confluence_0,\n\tdf_lr_confluence_n, df_lr_transfer_function, df_lr_free,\n\tdf_lr_dump, df_lr_add_problem, df_ur_get_bb_info,\n\tdf_ur_set_bb_info, df_ur_free_bb_info, df_ur_alloc,\n\tdf_ur_bb_local_compute, df_ur_local_compute, df_ur_init,\n\tdf_ur_local_finalize, df_ur_confluence_n, df_ur_transfer_function,\n\tdf_ur_free, df_ur_dump, df_ur_add_problem, df_urec_get_bb_info,\n\tdf_urec_set_bb_info, df_urec_free_bb_info, df_urec_alloc,\n\tdf_urec_mark_reg_change, df_urec_check_earlyclobber,\n\tdf_urec_mark_reg_use_for_earlyclobber,\n\tdf_urec_mark_reg_use_for_earlyclobber_1, df_urec_bb_local_compute,\n\tdf_urec_local_compute, df_urec_init, df_urec_local_finalize,\n\tdf_urec_confluence_n, df_urec_transfer_function, df_urec_free,\n\tdf_urec_dump, df_urec_add_problem, df_chain_alloc,\n\tdf_chain_create_bb_process_use, df_chain_create_bb,\n\tdf_chain_finalize, df_chain_free, df_chains_dump,\n\tdf_chain_add_problem, df_ri_alloc, df_ri_bb_compute,\n\tdf_ri_compute, df_ri_free, df_ri_dump, df_ri_add_problem,\n\tdf_reg_lifetime): New functions.\n\t* df.c: Deleted file.\n        * ddg.c (create_ddg_dep_no_link, build_inter_loop_deps): Made code\n\tconsistent with new df api.\n        * modulo-sched.c (sms_schedule, rest_of_handle_sms,\n        rest_of_handle_sms): Ditto.\n        * web.c (unionfind_union, union_defs, entry_register, web_main):\n\tDitto.\n\t* loop_invariant.c (invariant_for_use, hash_invariant_expr_1,\n\tinvariant_expr_equal_p, find_defs, check_dependencies,\n\tfind_invariant_insn, find_invariants_to_move, move_invariant_reg,\n\tfree_inv_motion_data, move_loop_invariants): Ditto.\n\t* sched-deps.c (sched_analyze_1): Ditto.\n\n\nCo-Authored-By: Kenneth Zadeck <zadeck@naturalbridge.com>\n\nFrom-SVN: r109577", "tree": {"sha": "458130d4608c530b1bd76381cc853507472b4512", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/458130d4608c530b1bd76381cc853507472b4512"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d779342f00ac9b678043e8a2e474a1ae14b8660", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d779342f00ac9b678043e8a2e474a1ae14b8660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d779342f00ac9b678043e8a2e474a1ae14b8660", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d779342f00ac9b678043e8a2e474a1ae14b8660/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "243cdfa86a25cafde210927deeb510910a942f12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/243cdfa86a25cafde210927deeb510910a942f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/243cdfa86a25cafde210927deeb510910a942f12"}], "stats": {"total": 11054, "additions": 6748, "deletions": 4306}, "files": [{"sha": "2f622a133a934dcb8e6916979e39dac731d3ac95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d779342f00ac9b678043e8a2e474a1ae14b8660", "patch": "@@ -1,3 +1,140 @@\n+2005-01-11  Danny Berlin <dberlin@dberlin.org>\n+            Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* df.h (DF_SCAN, DF_RU, DF_RD, DF_LR, DF_UR, DF_UREC, DF_CHAIN,\n+\tDF_RI, DF_LAST_PROBLEM_PLUS1, DF_DU_CHAIN, DF_UD_CHAIN,\n+\tDF_REF_TYPE_NAMES, DF_HARD_REGS, DF_EQUIV_NOTES, DF_SUBREGS,\n+\tDF_SCAN_BB_INFO, DF_RU_BB_INFO, DF_RD_BB_INFO, DF_LR_BB_INFO,\n+\tDF_UR_BB_INFO, DF_UREC_BB_INFO, DF_LIVE_IN, DF_LIVE_OUT,\n+\tDF_RA_LIVE_IN, DF_RA_LIVE_OUT, DF_UPWARD_LIVE_IN,\n+\tDF_UPWARD_LIVE_OUT, DF_REF_REAL_REG, DF_REF_REGNO,\n+\tDF_REF_REAL_LOC, DF_REF_REG, DF_REF_LOC, DF_REF_BB, DF_REF_BBNO,\n+\tDF_REF_INSN, DF_REF_INSN_UID, DF_REF_TYPE, DF_REF_CHAIN,\n+\tDF_REF_ID, DF_REF_FLAGS, DF_REF_NEXT_REG, DF_REF_PREV_REG,\n+\tDF_REF_NEXT_REF, DF_REF_DATA, DF_REF_REG_DEF_P, DF_REF_REG_USE_P,\n+\tDF_REF_REG_MEM_STORE_P, DF_REF_REG_MEM_LOAD_P, DF_REF_REG_MEM_P,\n+\tDF_DEFS_SIZE, DF_DEFS_GET, DF_DEFS_SET, DF_USES_SIZE, DF_USES_GET,\n+\tDF_USES_SET, DF_REG_SIZE, DF_REG_DEF_GET, DF_REG_DEF_SET,\n+\tDF_REG_USE_GET, DF_REG_USE_SET, DF_REGNO_FIRST_DEF,\n+\tDF_REGNO_LAST_USE, DF_INSN_SIZE, DF_INSN_GET, DF_INSN_SET,\n+\tDF_INSN_CONTAINS_ASM, DF_INSN_LUID, DF_INSN_DEFS, DF_INSN_USES,\n+\tDF_INSN_UID_GET, DF_INSN_UID_LUID, DF_INSN_UID_DEFS,\n+\tDF_INSN_UID_USES, DF_SCAN_INITIAL, DF_SCAN_GLOBAL,\n+\tDF_SCAN_POST_ALLOC): New macros.\n+\t(df_flow_dir, df_ref_type, df_ref_flags, df_alloc_function,\n+\tdf_free_bb_function, df_local_compute_function, df_init_function,\n+\tdf_dataflow_function, df_confluence_function_0,\n+\tdf_confluence_function_n, df_transfer_function,\n+\tdf_finalizer_function, df_free_function, df_dump_problem_function,\n+\tdf_problem, dataflow, df_insn_info, df_reg_info, df_ref, df_link,\n+\tdf_ref_info, df, df_map, df_scan_bb_info, df_ru_bb_info,\n+\tdf_ru_bb_info, df_rd_bb_info, df_lr_bb_info, df_ur_bb_info,\n+\tdf_urec_bb_info, ) New types.\n+\t(df_invalidated_by_call, df_all_hard_regs, df_state) New public\n+\tvariables.\n+\t(df_init, df_add_problem, df_set_blocks, df_finish, df_analyze,\n+\tdf_analyze_simple_change_some_blocks,\n+\tdf_analyze_simple_change_one_block, df_compact_blocks,\n+\tdf_bb_replace, df_bb_regno_last_use_find,\n+\tdf_bb_regno_first_def_find, df_bb_regno_last_def_find,\n+\tdf_insn_regno_def_p, df_find_def, df_find_use,\n+\tdf_iterative_dataflow, df_dump, df_chain_dump, df_refs_chain_dump,\n+\tdf_regs_chain_dump, df_insn_debug, df_insn_debug_regno,\n+\tdf_regno_debug, df_ref_debug, debug_df_insn, debug_df_regno,\n+\tdebug_df_reg, debug_df_defno, debug_df_useno, debug_df_ref,\n+\tdebug_df_chain, df_get_dependent_problem, df_chain_create,\n+\tdf_chain_unlink, df_chain_copy, df_get_live_in, df_get_live_out,\n+\tdf_grow_bb_info, df_chain_dump, df_print_bb_index,\n+\tdf_ru_add_problem, df_ru_get_bb_info, df_rd_add_problem,\n+\tdf_rd_get_bb_info, df_lr_add_problem, df_lr_get_bb_info,\n+\tdf_ur_add_problem, df_ur_get_bb_info, df_urec_add_problem,\n+\tdf_urec_get_bb_info, df_chain_add_problem, df_ri_add_problem,\n+\tdf_reg_lifetime, df_scan_get_bb_info, df_scan_add_problem,\n+\tdf_rescan_blocks, df_ref_create, df_get_artificial_defs,\n+\tdf_get_artificial_uses, df_reg_chain_create, df_reg_chain_unlink,\n+\tdf_ref_remove, df_insn_refs_delete, df_refs_delete,\n+\tdf_reorganize_refs, df_set_state, df_hard_reg_init,\n+\tdf_read_modify_subreg_p) New public functions.\n+        * df-core.c: The core dataflow solver and glue routines for rtl\n+\tdataflow.\n+\t(df_init, df_add_problem, df_set_blocks, df_finish,\n+\tdf_hybrid_search_forward, df_hybrid_search_backward,\n+\tdf_iterative_dataflow, df_prune_to_subcfg, df_analyze_problem,\n+\tdf_analyze, df_get_bb_info, df_set_bb_info, df_bb_replace,\n+\tdf_bb_regno_last_use_find, df_bb_regno_first_def_find,\n+\tdf_bb_regno_last_def_find, df_insn_regno_def_p, df_find_def,\n+\tdf_reg_defined, df_find_use, df_reg_used, df_dump,\n+\tdf_refs_chain_dump, df_regs_chain_dump, df_insn_debug,\n+\tdf_insn_debug_regno, df_regno_debug, df_ref_debug, debug_df_insn,\n+\tdebug_df_reg, debug_df_regno, debug_df_ref debug_df_defno,\n+\tdebug_df_useno, reset_df_after_reload): New functions.\n+\t* df-scan.c: The scanning fuctions, once in df.c, completely\n+\trewritten so that they now fully model the functionality of\n+\tregister usage at the backend.\n+\t(df_scan_free_internal, df_scan_get_bb_info, df_scan_set_bb_info,\n+\tdf_scan_free_bb_info, df_scan_alloc, df_scan_free, df_scan_dump,\n+\tdf_scan_add_problem, df_grow_reg_info, df_grow_ref_info,\n+\tdf_grow_insn_info, df_rescan_blocks, df_ref_create,\n+\tdf_get_artificial_defs, df_get_artificial_uses,\n+\tdf_reg_chain_create, df_ref_unlink, df_reg_chain_unlink,\n+\tdf_ref_remove, df_insn_create_insn_record, df_insn_refs_delete,\n+\tdf_refs_delete, df_reorganize_refs, df_set_state,\n+\tdf_ref_create_structure, df_ref_record, df_read_modify_subreg_p,\n+\tdf_def_record_1, df_defs_record, df_uses_record,\n+\tdf_insn_contains_asm_1, df_insn_contains_asm, df_insn_refs_record,\n+\tdf_has_eh_preds, df_bb_refs_record, df_refs_record, df_mark_reg,\n+\tdf_record_exit_block_uses, df_hard_reg_init): New functions.\n+\n+\t* df-problems.c: Seven concrete dataflow problems that use the\n+\tscanning in df-scan.c and are solved by the engine in df-core.c.\n+\t(df_get_dependent_problem, df_chain_create, df_chain_unlink,\n+\tdf_chain_copy, df_get_live_in, df_get_live_out, df_grow_bb_info,\n+\tdf_chain_dump, df_print_bb_index, df_ref_bitmap, df_set_seen,\n+\tdf_unset_seen, df_ru_get_bb_info, df_ru_set_bb_info,\n+\tdf_ru_free_bb_info, df_ru_alloc,\n+\tdf_ru_bb_local_compute_process_def,\n+\tdf_ru_bb_local_compute_process_use, df_ru_bb_local_compute,\n+\tdf_ru_local_compute, df_ru_init_solution, df_ru_confluence_n,\n+\tdf_ru_transfer_function, df_ru_free, df_ru_dump,\n+\tdf_ru_add_problem, df_rd_get_bb_info, df_rd_set_bb_info,\n+\tdf_rd_free_bb_info, df_rd_alloc,\n+\tdf_rd_bb_local_compute_process_def, df_rd_bb_local_compute,\n+\tdf_rd_local_compute, df_rd_init_solution, df_rd_confluence_n,\n+\tdf_rd_transfer_function, df_rd_free, df_rd_dump,\n+\tdf_rd_add_problem, df_lr_get_bb_info, df_lr_set_bb_info,\n+\tdf_lr_free_bb_info, df_lr_alloc, df_lr_bb_local_compute,\n+\tdf_lr_local_compute, df_lr_init, df_lr_confluence_0,\n+\tdf_lr_confluence_n, df_lr_transfer_function, df_lr_free,\n+\tdf_lr_dump, df_lr_add_problem, df_ur_get_bb_info,\n+\tdf_ur_set_bb_info, df_ur_free_bb_info, df_ur_alloc,\n+\tdf_ur_bb_local_compute, df_ur_local_compute, df_ur_init,\n+\tdf_ur_local_finalize, df_ur_confluence_n, df_ur_transfer_function,\n+\tdf_ur_free, df_ur_dump, df_ur_add_problem, df_urec_get_bb_info,\n+\tdf_urec_set_bb_info, df_urec_free_bb_info, df_urec_alloc,\n+\tdf_urec_mark_reg_change, df_urec_check_earlyclobber,\n+\tdf_urec_mark_reg_use_for_earlyclobber,\n+\tdf_urec_mark_reg_use_for_earlyclobber_1, df_urec_bb_local_compute,\n+\tdf_urec_local_compute, df_urec_init, df_urec_local_finalize,\n+\tdf_urec_confluence_n, df_urec_transfer_function, df_urec_free,\n+\tdf_urec_dump, df_urec_add_problem, df_chain_alloc,\n+\tdf_chain_create_bb_process_use, df_chain_create_bb,\n+\tdf_chain_finalize, df_chain_free, df_chains_dump,\n+\tdf_chain_add_problem, df_ri_alloc, df_ri_bb_compute,\n+\tdf_ri_compute, df_ri_free, df_ri_dump, df_ri_add_problem,\n+\tdf_reg_lifetime): New functions.\n+\t* df.c: Deleted file.\n+        * ddg.c (create_ddg_dep_no_link, build_inter_loop_deps): Made code\n+\tconsistent with new df api.\n+        * modulo-sched.c (sms_schedule, rest_of_handle_sms,\n+        rest_of_handle_sms): Ditto.\n+        * web.c (unionfind_union, union_defs, entry_register, web_main):\n+\tDitto.\n+\t* loop_invariant.c (invariant_for_use, hash_invariant_expr_1,\n+\tinvariant_expr_equal_p, find_defs, check_dependencies,\n+\tfind_invariant_insn, find_invariants_to_move, move_invariant_reg,\n+\tfree_inv_motion_data, move_loop_invariants): Ditto.\n+\t* sched-deps.c (sched_analyze_1): Ditto.\n+\n 2006-01-11  Zdenek Dvorak <dvorakz@suse.cz>\n \n \t* tree-ssa-operands.c (get_expr_operands): Record addressable"}, {"sha": "8318090645af2584c2670d832da635a83375281a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4d779342f00ac9b678043e8a2e474a1ae14b8660", "patch": "@@ -761,7 +761,7 @@ IPA_UTILS_H = ipa-utils.h $(TREE_H) $(CGRAPH_H)\n IPA_REFERENCE_H = ipa-reference.h bitmap.h $(TREE_H)  \n IPA_TYPE_ESCAPE_H = ipa-type-escape.h $(TREE_H)  \n CGRAPH_H = cgraph.h $(TREE_H)\n-DF_H = df.h bitmap.h sbitmap.h $(BASIC_BLOCK_H)\n+DF_H = df.h bitmap.h $(BASIC_BLOCK_H) alloc-pool.h\n DDG_H = ddg.h sbitmap.h $(DF_H)\n GCC_H = gcc.h version.h\n GGC_H = ggc.h gtype-desc.h\n@@ -973,7 +973,8 @@ OBJS-common = \\\n  cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n  cfgrtl.o combine.o conflict.o convert.o coverage.o cse.o cselib.o \t   \\\n  dbxout.o ddg.o tree-ssa-loop-ch.o loop-invariant.o tree-ssa-loop-im.o\t   \\\n- debug.o df.o dfp.o diagnostic.o dojump.o dominance.o loop-doloop.o\t   \\\n+ debug.o df-core.o df-problems.o odf.o df-scan.o dfp.o diagnostic.o dojump.o     \\\n+ dominance.o loop-doloop.o\t   \t\t\t\t\t   \\\n  dwarf2asm.o dwarf2out.o emit-rtl.o except.o explow.o loop-iv.o\t\t   \\\n  expmed.o expr.o final.o flow.o fold-const.o function.o gcse.o\t\t   \\\n  genrtl.o ggc-common.o global.o graph.o gtype-desc.o\t\t\t   \\\n@@ -2301,9 +2302,22 @@ tree-vect-generic.o : tree-vect-generic.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n     $(FLAGS_H) $(OPTABS_H) $(RTL_H) $(MACHMODE_H) $(EXPR_H) \\\n     langhooks.h $(FLAGS_H) $(DIAGNOSTIC_H) gt-tree-vect-generic.h $(GGC_H) \\\n     coretypes.h insn-codes.h\n-df.o : df.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   insn-config.h $(RECOG_H) function.h $(REGS_H) alloc-pool.h hard-reg-set.h \\\n-   $(BASIC_BLOCK_H) $(DF_H) bitmap.h sbitmap.h $(TM_P_H)\n+df-core.o : df-core.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h \\\n+   hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) bitmap.h sbitmap.h \\\n+   $(TM_P_H) $(FLAGS_H) output.h tree-pass.h\n+df-problems.o : df-problems.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(RTL_H) insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h \\\n+   hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) bitmap.h sbitmap.h $(TM_P_H) \\\n+   $(FLAGS_H) output.h\n+odf.o : odf.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h hard-reg-set.h \\\n+   $(BASIC_BLOCK_H) $(DF_H) bitmap.h sbitmap.h $(TM_P_H) $(FLAGS_H) \\\n+   output.h\n+df-scan.o : df-scan.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h hard-reg-set.h \\\n+   $(BASIC_BLOCK_H) $(DF_H) bitmap.h sbitmap.h $(TM_P_H) $(FLAGS_H) \\\n+   output.h\n var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h $(FLAGS_H) \\\n    $(BASIC_BLOCK_H) output.h sbitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H) \\"}, {"sha": "86ffa1f3161fc10872c56bd431afb728756b34c2", "filename": "gcc/ddg.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=4d779342f00ac9b678043e8a2e474a1ae14b8660", "patch": "@@ -1,5 +1,5 @@\n /* DDG - Data Dependence Graph implementation.\n-   Copyright (C) 2004, 2005\n+   Copyright (C) 2004, 2005, 2006\n    Free Software Foundation, Inc.\n    Contributed by Ayal Zaks and Mustafa Hagog <zaks,mustafa@il.ibm.com>\n \n@@ -222,10 +222,10 @@ create_ddg_dep_no_link (ddg_ptr g, ddg_node_ptr from, ddg_node_ptr to,\n    for all its uses in the next iteration, and an output dependence to the\n    first def of the next iteration.  */\n static void\n-add_deps_for_def (ddg_ptr g, struct df *df, struct ref *rd)\n+add_deps_for_def (ddg_ptr g, struct df *df, struct df_ref *rd)\n {\n   int regno = DF_REF_REGNO (rd);\n-  struct bb_info *bb_info = DF_BB_INFO (df, g->bb);\n+  struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (df, g->bb);\n   struct df_link *r_use;\n   int use_before_def = false;\n   rtx def_insn = DF_REF_INSN (rd);\n@@ -235,7 +235,7 @@ add_deps_for_def (ddg_ptr g, struct df *df, struct ref *rd)\n      that is upwards exposed in RD's block.  */\n   for (r_use = DF_REF_CHAIN (rd); r_use != NULL; r_use = r_use->next)\n     {\n-      if (bitmap_bit_p (bb_info->ru_gen, r_use->ref->id))\n+      if (bitmap_bit_p (bb_info->gen, r_use->ref->id))\n \t{\n \t  rtx use_insn = DF_REF_INSN (r_use->ref);\n \t  ddg_node_ptr dest_node = get_node_of_insn (g, use_insn);\n@@ -257,7 +257,7 @@ add_deps_for_def (ddg_ptr g, struct df *df, struct ref *rd)\n      there is a use between the two defs.  */\n   if (! use_before_def)\n     {\n-      struct ref *def = df_bb_regno_first_def_find (df, g->bb, regno);\n+      struct df_ref *def = df_bb_regno_first_def_find (df, g->bb, regno);\n       int i;\n       ddg_node_ptr dest_node;\n \n@@ -266,7 +266,7 @@ add_deps_for_def (ddg_ptr g, struct df *df, struct ref *rd)\n \n       /* Check if there are uses after RD.  */\n       for (i = src_node->cuid + 1; i < g->num_nodes; i++)\n-\t if (df_reg_used (df, g->nodes[i].insn, rd->reg))\n+\t if (df_find_use (df, g->nodes[i].insn, rd->reg))\n \t   return;\n \n       dest_node = get_node_of_insn (g, def->insn);\n@@ -278,16 +278,16 @@ add_deps_for_def (ddg_ptr g, struct df *df, struct ref *rd)\n    (nearest BLOCK_BEGIN) def of the next iteration, unless USE is followed\n    by a def in the block.  */\n static void\n-add_deps_for_use (ddg_ptr g, struct df *df, struct ref *use)\n+add_deps_for_use (ddg_ptr g, struct df *df, struct df_ref *use)\n {\n   int i;\n   int regno = DF_REF_REGNO (use);\n-  struct ref *first_def = df_bb_regno_first_def_find (df, g->bb, regno);\n+  struct df_ref *first_def = df_bb_regno_first_def_find (df, g->bb, regno);\n   ddg_node_ptr use_node;\n   ddg_node_ptr def_node;\n-  struct bb_info *bb_info;\n+  struct df_rd_bb_info *bb_info;\n \n-  bb_info = DF_BB_INFO (df, g->bb);\n+  bb_info = DF_RD_BB_INFO (df, g->bb);\n \n   if (!first_def)\n     return;\n@@ -304,7 +304,7 @@ add_deps_for_use (ddg_ptr g, struct df *df, struct ref *use)\n   /* We must not add ANTI dep when there is an intra-loop TRUE dep in\n      the opposite direction. If the first_def reaches the USE then there is\n      such a dep.  */\n-  if (! bitmap_bit_p (bb_info->rd_gen, first_def->id))\n+  if (! bitmap_bit_p (bb_info->gen, first_def->id))\n     create_ddg_dep_no_link (g, use_node, def_node, ANTI_DEP, REG_DEP, 1);\n }\n \n@@ -313,25 +313,28 @@ static void\n build_inter_loop_deps (ddg_ptr g, struct df *df)\n {\n   unsigned rd_num, u_num;\n-  struct bb_info *bb_info;\n+  struct df_rd_bb_info *rd_bb_info;\n+  struct df_ru_bb_info *ru_bb_info;\n   bitmap_iterator bi;\n \n-  bb_info = DF_BB_INFO (df, g->bb);\n+  rd_bb_info = DF_RD_BB_INFO (df, g->bb);\n \n   /* Find inter-loop output and true deps by connecting downward exposed defs\n      to the first def of the BB and to upwards exposed uses.  */\n-  EXECUTE_IF_SET_IN_BITMAP (bb_info->rd_gen, 0, rd_num, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (rd_bb_info->gen, 0, rd_num, bi)\n     {\n-      struct ref *rd = df->defs[rd_num];\n+      struct df_ref *rd = DF_DEFS_GET (df, rd_num);\n \n       add_deps_for_def (g, df, rd);\n     }\n \n+  ru_bb_info = DF_RU_BB_INFO (df, g->bb);\n+\n   /* Find inter-loop anti deps.  We are interested in uses of the block that\n      appear below all defs; this implies that these uses are killed.  */\n-  EXECUTE_IF_SET_IN_BITMAP (bb_info->ru_kill, 0, u_num, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (ru_bb_info->kill, 0, u_num, bi)\n     {\n-      struct ref *use = df->uses[u_num];\n+      struct df_ref *use = DF_USES_GET (df, u_num);\n \n       /* We are interested in uses of this BB.  */\n       if (BLOCK_FOR_INSN (use->insn) == g->bb)"}, {"sha": "aef38cb43547852dd3ed5305743f97ab2fbe7157", "filename": "gcc/df-core.c", "status": "added", "additions": 1164, "deletions": 0, "changes": 1164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=4d779342f00ac9b678043e8a2e474a1ae14b8660", "patch": "@@ -0,0 +1,1164 @@\n+/* Allocation for dataflow support routines.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n+   Originally contributed by Michael P. Hayes \n+             (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)\n+   Major rewrite contributed by Danny Berlin (dberlin@dberlin.org)\n+             and Kenneth Zadeck (zadeck@naturalbridge.com).\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  \n+*/\n+\n+/*\n+OVERVIEW:\n+\n+The files in this collection (df*.c,df.h) provide a general framework\n+for solving dataflow problems.  The global dataflow is performed using\n+a good implementation of iterative dataflow analysis.\n+\n+The file df-problems.c provides problem instance for the most common\n+dataflow problems: reaching defs, upward exposed uses, live variables,\n+uninitialized variables, def-use chains, and use-def chains.  However,\n+the interface allows other dataflow problems to be defined as well.\n+\n+\n+USAGE:\n+\n+Here is an example of using the dataflow routines.\n+\n+      struct df *df;\n+\n+      df = df_init (init_flags);\n+      \n+      df_add_problem (df, problem);\n+\n+      df_set_blocks (df, blocks);\n+\n+      df_rescan_blocks (df, blocks);\n+\n+      df_analyze (df);\n+\n+      df_dump (df, stderr);\n+\n+      df_finish (df);\n+\n+\n+\n+DF_INIT simply creates a poor man's object (df) that needs to be\n+passed to all the dataflow routines.  df_finish destroys this object\n+and frees up any allocated memory.\n+\n+There are two flags that can be passed to df_init:\n+\n+DF_NO_SCAN means that no scanning of the rtl code is performed.  This\n+is used if the problem instance is to do it's own scanning.\n+\n+DF_HARD_REGS means that the scanning is to build information about\n+both pseudo registers and hardware registers.  Without this\n+information, the problems will be solved only on pseudo registers.\n+\n+\n+\n+DF_ADD_PROBLEM adds a problem, defined by an instance to struct\n+df_problem, to the set of problems solved in this instance of df.  All\n+calls to add a problem for a given instance of df must occur before\n+the first call to DF_RESCAN_BLOCKS or DF_ANALYZE.\n+\n+For all of the problems defined in df-problems.c, there are\n+convienence functions named DF_*_ADD_PROBLEM.\n+\n+\n+Problems can be dependent on other problems.  For instance, solving\n+def-use or use-def chains is dependant on solving reaching\n+definitions. As long as these dependancies are listed in the problem\n+definition, the order of adding the problems is not material.\n+Otherwise, the problems will be solved in the order of calls to\n+df_add_problem.  Note that it is not necessary to have a problem.  In\n+that case, df will just be used to do the scanning.\n+\n+\n+\n+DF_SET_BLOCKS is an optional call used to define a region of the\n+function on which the analysis will be performed.  The normal case is\n+to analyze the entire function and no call to df_set_blocks is made.\n+\n+When a subset is given, the analysis behaves as if the function only\n+contains those blocks and any edges that occur directly between the\n+blocks in the set.  Care should be taken to call df_set_blocks right\n+before the call to analyze in order to eliminate the possiblity that\n+optimizations that reorder blocks invalidate the bitvector.\n+\n+\n+\n+DF_RESCAN_BLOCKS is an optional call that causes the scanner to be\n+ (re)run over the set of blocks passed in.  If blocks is NULL, the entire\n+function (or all of the blocks defined in df_set_blocks) is rescanned.\n+If blocks contains blocks that were not defined in the call to\n+df_set_blocks, these blocks are added to the set of blocks.\n+\n+\n+DF_ANALYZE causes all of the defined problems to be (re)solved.  It\n+does not cause blocks to be (re)scanned at the rtl level unless no\n+prior call is made to df_rescan_blocks.\n+\n+\n+DF_DUMP can then be called to dump the information produce to some\n+file.\n+\n+\n+\n+DF_FINISH causes all of the datastructures to be cleaned up and freed.\n+The df_instance is also freed and its pointer should be NULLed.\n+\n+\n+\n+\n+Scanning produces a `struct df_ref' data structure (ref) is allocated\n+for every register reference (def or use) and this records the insn\n+and bb the ref is found within.  The refs are linked together in\n+chains of uses and defs for each insn and for each register.  Each ref\n+also has a chain field that links all the use refs for a def or all\n+the def refs for a use.  This is used to create use-def or def-use\n+chains.\n+\n+Different optimizations have different needs.  Ultimately, only\n+register allocation and schedulers should be using the bitmaps\n+produced for the live register and uninitialized register problems.\n+The rest of the backend should be upgraded to using and maintaining\n+the linked information such as def use or use def chains.\n+\n+\n+\n+PHILOSOPHY:\n+\n+While incremental bitmaps are not worthwhile to maintain, incremental\n+chains may be perfectly reasonable.  The fastest way to build chains\n+from scratch or after significant modifications is to build reaching\n+definitions (RD) and build the chains from this.\n+\n+However, general algorithms for maintaining use-def or def-use chains\n+are not practical.  The amount of work to recompute the chain any\n+chain after an arbitrary change is large.  However, with a modest\n+amount of work it is generally possible to have the application that\n+uses the chains keep them up to date.  The high level knowledge of\n+what is really happening is essential to crafting efficient\n+incremental algorithms.\n+\n+As for the bit vector problems, there is no interface to give a set of\n+blocks over with to resolve the iteration.  In general, restarting a\n+dataflow iteration is difficult and expensive.  Again, the best way to\n+keep the dataflow infomation up to data (if this is really what is\n+needed) it to formulate a problem specific solution.\n+\n+There are fine grained calls for creating and deleting references from\n+instructions in df-scan.c.  However, these are not currently connected\n+to the engine that resolves the dataflow equations.\n+\n+\n+DATA STRUCTURES:\n+\n+The basic object is a DF_REF (reference) and this may either be a \n+DEF (definition) or a USE of a register.\n+\n+These are linked into a variety of lists; namely reg-def, reg-use,\n+insn-def, insn-use, def-use, and use-def lists.  For example, the\n+reg-def lists contain all the locations that define a given register\n+while the insn-use lists contain all the locations that use a\n+register.\n+\n+Note that the reg-def and reg-use chains are generally short for\n+pseudos and long for the hard registers.\n+\n+ACCESSING REFS:\n+\n+There are 4 ways to obtain access to refs:\n+\n+1) References are divided into two categories, REAL and ARTIFICIAL.\n+\n+   REAL refs are associated with instructions.  They are linked into\n+   either in the insn's defs list (accessed by the DF_INSN_DEFS or\n+   DF_INSN_UID_DEFS macros) or the insn's uses list (accessed by the\n+   DF_INSN_USES or DF_INSN_UID_USES macros).  These macros produce a\n+   ref (or NULL), the rest of the list can be obtained by traversal of\n+   the NEXT_REF field (accessed by the DF_REF_NEXT_REF macro.)  There\n+   is no significance to the ordering of the uses or refs in an\n+   instruction.\n+\n+   ARTIFICIAL refs are associated with basic blocks.  The heads of\n+   these lists can be accessed by calling get_artificial_defs or\n+   get_artificial_uses for the particular basic block.  Artificial\n+   defs and uses are only there if DF_HARD_REGS was specified when the\n+   df instance was created.\n+ \n+   Artificial defs and uses occur at the beginning blocks that are the\n+   destination of eh edges.  The defs come from the registers\n+   specified in EH_RETURN_DATA_REGNO and the uses come from the\n+   registers specified in ED_USES.  Logically these defs and uses\n+   should really occur along the eh edge, but there is no convienent\n+   way to do this.  Artificial edges that occur at the beginning of\n+   the block have the DF_REF_AT_TOP flag set.\n+   \n+   Artificial uses also occur at the end of all blocks.  These arise\n+   from the hard registers that are always live, such as the stack\n+   register and are put there to keep the code from forgetting about\n+   them.\n+\n+2) All of the uses and defs associated with each pseudo or hard\n+   register are linked in a bidirectional chain.  These are called\n+   reg-use or reg_def chains.\n+\n+   The first use (or def) for a register can be obtained using the\n+   DF_REG_USE_GET macro (or DF_REG_DEF_GET macro).  Subsequent uses\n+   for the same regno can be obtained by following the next_reg field\n+   of the ref.\n+\n+   In previous versions of this code, these chains were ordered.  It\n+   has not been practical to continue this practice.\n+\n+3) If def-use or use-def chains are built, these can be traversed to\n+   get to other refs.\n+\n+4) An array of all of the uses (and an array of all of the defs) can\n+   be built.  These arrays are indexed by the value in the id\n+   structure.  These arrays are only lazily kept up to date, and that\n+   process can be expensive.  To have these arrays built, call\n+   df_reorganize_refs.   Note that the values in the id field of a ref\n+   may change across calls to df_analyze or df_reorganize refs.\n+\n+   If the only use of this array is to find all of the refs, it is\n+   better to traverse all of the registers and then traverse all of\n+   reg-use or reg-def chains.\n+\n+\n+\n+NOTES:\n+ \n+Embedded addressing side-effects, such as POST_INC or PRE_INC, generate\n+both a use and a def.  These are both marked read/write to show that they\n+are dependent. For example, (set (reg 40) (mem (post_inc (reg 42))))\n+will generate a use of reg 42 followed by a def of reg 42 (both marked\n+read/write).  Similarly, (set (reg 40) (mem (pre_dec (reg 41))))\n+generates a use of reg 41 then a def of reg 41 (both marked read/write),\n+even though reg 41 is decremented before it is used for the memory\n+address in this second example.\n+\n+A set to a REG inside a ZERO_EXTRACT, or a set to a non-paradoxical SUBREG\n+for which the number of word_mode units covered by the outer mode is\n+smaller than that covered by the inner mode, invokes a read-modify-write.\n+operation.  We generate both a use and a def and again mark them\n+read/write.\n+\n+Paradoxical subreg writes do not leave a trace of the old content, so they\n+are write-only operations.  \n+*/\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"function.h\"\n+#include \"regs.h\"\n+#include \"output.h\"\n+#include \"alloc-pool.h\"\n+#include \"flags.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"sbitmap.h\"\n+#include \"bitmap.h\"\n+#include \"timevar.h\"\n+#include \"df.h\"\n+#include \"tree-pass.h\"\n+\n+static struct df *ddf = NULL;\n+struct df *shared_df = NULL;\n+\n+/*----------------------------------------------------------------------------\n+  Functions to create, destroy and manipulate an instance of df.\n+----------------------------------------------------------------------------*/\n+\n+\n+/* Initialize dataflow analysis and allocate and initialize dataflow\n+   memory.  */\n+\n+struct df *\n+df_init (int flags)\n+{\n+  struct df *df = xcalloc (1, sizeof (struct df));\n+  df->flags = flags;\n+\n+  /* This is executed once per compilation to initialize platform\n+     specific data structures. */\n+  df_hard_reg_init ();\n+  \n+  /* All df instance must define the scanning problem.  */\n+  df_scan_add_problem (df);\n+  ddf = df;\n+  return df;\n+}\n+\n+/* Add PROBLEM to the DF instance.  */\n+\n+struct dataflow *\n+df_add_problem (struct df *df, struct df_problem *problem)\n+{\n+  struct dataflow *dflow;\n+\n+  /* First try to add the dependent problem. */\n+  if (problem->dependent_problem)\n+    df_add_problem (df, problem->dependent_problem);\n+\n+  /* Check to see if this problem has already been defined.  If it\n+     has, just return that instance, if not, add it to the end of the\n+     vector.  */\n+  dflow = df->problems_by_index[problem->id];\n+  if (dflow)\n+    return dflow;\n+\n+  /* Make a new one and add it to the end.  */\n+  dflow = xcalloc (1, sizeof (struct dataflow));\n+  dflow->df = df;\n+  dflow->problem = problem;\n+  df->problems_in_order[df->num_problems_defined++] = dflow;\n+  df->problems_by_index[dflow->problem->id] = dflow;\n+\n+  return dflow;\n+}\n+\n+\n+/* Set the blocks that are to be considered for analysis.  If this is\n+   not called or is called with null, the entire function in\n+   analyzed.  */\n+\n+void \n+df_set_blocks (struct df *df, bitmap blocks)\n+{\n+  if (blocks)\n+    {\n+      if (!df->blocks_to_analyze)\n+\tdf->blocks_to_analyze = BITMAP_ALLOC (NULL);\n+      bitmap_copy (df->blocks_to_analyze, blocks);\n+    }\n+  else\n+    {\n+      if (df->blocks_to_analyze)\n+\t{\n+\t  BITMAP_FREE (df->blocks_to_analyze);\n+\t  df->blocks_to_analyze = NULL;\n+\t}\n+    }\n+}\n+\n+\n+/* Free all the dataflow info and the DF structure.  This should be\n+   called from the df_finish macro which also NULLs the parm.  */\n+\n+void\n+df_finish1 (struct df *df)\n+{\n+  int i;\n+\n+  for (i = 0; i < df->num_problems_defined; i++)\n+    (*df->problems_in_order[i]->problem->free_fun) (df->problems_in_order[i]); \n+\n+  free (df);\n+}\n+\n+\f\n+/*----------------------------------------------------------------------------\n+   The general data flow analysis engine.\n+----------------------------------------------------------------------------*/\n+\n+\n+/* Hybrid search algorithm from \"Implementation Techniques for\n+   Efficient Data-Flow Analysis of Large Programs\".  */\n+\n+static void\n+df_hybrid_search_forward (basic_block bb, \n+\t\t\t  struct dataflow *dataflow,\n+\t\t\t  bool single_pass)\n+{\n+  int result_changed;\n+  int i = bb->index;\n+  edge e;\n+  edge_iterator ei;\n+\n+  SET_BIT (dataflow->visited, bb->index);\n+  gcc_assert (TEST_BIT (dataflow->pending, bb->index));\n+  RESET_BIT (dataflow->pending, i);\n+\n+  /*  Calculate <conf_op> of predecessor_outs.  */\n+  if (EDGE_COUNT (bb->preds) > 0)\n+    FOR_EACH_EDGE (e, ei, bb->preds)\n+      {\n+\tif (!TEST_BIT (dataflow->considered, e->src->index))\n+\t  continue;\n+\t\n+\t(*dataflow->problem->con_fun_n) (dataflow, e);\n+      }\n+  else if (*dataflow->problem->con_fun_0)\n+    (*dataflow->problem->con_fun_0) (dataflow, bb);\n+  \n+  result_changed = (*dataflow->problem->trans_fun) (dataflow, i);\n+  \n+  if (!result_changed || single_pass)\n+    return;\n+  \n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      if (e->dest->index == i)\n+\tcontinue;\n+      if (!TEST_BIT (dataflow->considered, e->dest->index))\n+\tcontinue;\n+      SET_BIT (dataflow->pending, e->dest->index);\n+    }\n+  \n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      if (e->dest->index == i)\n+\tcontinue;\n+      \n+      if (!TEST_BIT (dataflow->considered, e->dest->index))\n+\tcontinue;\n+      if (!TEST_BIT (dataflow->visited, e->dest->index))\n+\tdf_hybrid_search_forward (e->dest, dataflow, single_pass);\n+    }\n+}\n+\n+static void\n+df_hybrid_search_backward (basic_block bb,\n+\t\t\t   struct dataflow *dataflow,\n+\t\t\t   bool single_pass)\n+{\n+  int result_changed;\n+  int i = bb->index;\n+  edge e;\n+  edge_iterator ei;\n+  \n+  SET_BIT (dataflow->visited, bb->index);\n+  gcc_assert (TEST_BIT (dataflow->pending, bb->index));\n+  RESET_BIT (dataflow->pending, i);\n+\n+  /*  Calculate <conf_op> of predecessor_outs.  */\n+  if (EDGE_COUNT (bb->succs) > 0)\n+    FOR_EACH_EDGE (e, ei, bb->succs)\t\t\t\t\t\n+      {\t\t\t\t\t\t\t\t\n+\tif (!TEST_BIT (dataflow->considered, e->dest->index))\t\t\n+\t  continue;\t\t\t\t\t\t\t\n+\t\n+\t(*dataflow->problem->con_fun_n) (dataflow, e);\n+      }\t\t\t\t\t\t\t\t\n+  else if (*dataflow->problem->con_fun_0)\n+    (*dataflow->problem->con_fun_0) (dataflow, bb);\n+\n+  result_changed = (*dataflow->problem->trans_fun) (dataflow, i);\n+  \n+  if (!result_changed || single_pass)\n+    return;\n+  \n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\t\t\t\t\t\t\t\t\n+      if (e->src->index == i)\n+\tcontinue;\n+      \n+      if (!TEST_BIT (dataflow->considered, e->src->index))\n+\tcontinue;\n+\n+      SET_BIT (dataflow->pending, e->src->index);\n+    }\t\t\t\t\t\t\t\t\n+  \n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      if (e->src->index == i)\n+\tcontinue;\n+\n+      if (!TEST_BIT (dataflow->considered, e->src->index))\n+\tcontinue;\n+      \n+      if (!TEST_BIT (dataflow->visited, e->src->index))\n+\tdf_hybrid_search_backward (e->src, dataflow, single_pass);\n+    }\n+}\n+\n+\n+/* This function will perform iterative bitvector dataflow described\n+   by DATAFLOW, producing the in and out sets.  Only the part of the\n+   cfg induced by blocks in DATAFLOW->order is taken into account.\n+\n+   SINGLE_PASS is true if you just want to make one pass over the\n+   blocks.  */\n+\n+void\n+df_iterative_dataflow (struct dataflow *dataflow,\n+\t\t       bitmap blocks_to_consider, bitmap blocks_to_init, \n+\t\t       int *blocks_in_postorder, int n_blocks, \n+\t\t       bool single_pass)\n+{\n+  unsigned int idx;\n+  int i;\n+  sbitmap visited = sbitmap_alloc (last_basic_block);\n+  sbitmap pending = sbitmap_alloc (last_basic_block);\n+  sbitmap considered = sbitmap_alloc (last_basic_block);\n+  bitmap_iterator bi;\n+\n+  dataflow->visited = visited;\n+  dataflow->pending = pending;\n+  dataflow->considered = considered;\n+\n+  sbitmap_zero (visited);\n+  sbitmap_zero (pending);\n+  sbitmap_zero (considered);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (blocks_to_consider, 0, idx, bi)\n+    {\n+      SET_BIT (considered, idx);\n+    }\n+\n+  for (i = 0; i < n_blocks; i++)\n+    {\n+      idx = blocks_in_postorder[i];\n+      SET_BIT (pending, idx);\n+    };\n+\n+  (*dataflow->problem->init_fun) (dataflow, blocks_to_init);\n+\n+  while (1)\n+    {\n+\n+      /* For forward problems, you want to pass in reverse postorder\n+         and for backward problems you want postorder.  This has been\n+         shown to be as good as you can do by several people, the\n+         first being Mathew Hecht in his phd dissertation.\n+\n+\t The nodes are passed into this function in postorder.  */\n+\n+      if (dataflow->problem->dir == DF_FORWARD)\n+\t{\n+\t  for (i = n_blocks - 1 ; i >= 0 ; i--)\n+\t    {\n+\t      idx = blocks_in_postorder[i];\n+\t      \n+\t      if (TEST_BIT (pending, idx) && !TEST_BIT (visited, idx))\n+\t\tdf_hybrid_search_forward (BASIC_BLOCK (idx), dataflow, single_pass);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (i = 0; i < n_blocks; i++)\n+\t    {\n+\t      idx = blocks_in_postorder[i];\n+\t      \n+\t      if (TEST_BIT (pending, idx) && !TEST_BIT (visited, idx))\n+\t\tdf_hybrid_search_backward (BASIC_BLOCK (idx), dataflow, single_pass);\n+\t    }\n+\t}\n+\n+      if (sbitmap_first_set_bit (pending) == -1)\n+\tbreak;\n+\n+      sbitmap_zero (visited);\n+    }\n+\n+  sbitmap_free (pending);\n+  sbitmap_free (visited);\n+  sbitmap_free (considered);\n+}\n+\n+\n+/* Remove the entries not in BLOCKS from the LIST of length LEN, preserving\n+   the order of the remaining entries.  Returns the length of the resulting\n+   list.  */\n+\n+static unsigned\n+df_prune_to_subcfg (int list[], unsigned len, bitmap blocks)\n+{\n+  unsigned act, last;\n+\n+  for (act = 0, last = 0; act < len; act++)\n+    if (bitmap_bit_p (blocks, list[act]))\n+      list[last++] = list[act];\n+\n+  return last;\n+}\n+\n+\n+/* Execute dataflow analysis on a single dataflow problem. \n+\n+   There are three sets of blocks passed in: \n+\n+   BLOCKS_TO_CONSIDER are the blocks whose solution can either be\n+   examined or will be computed.  For calls from DF_ANALYZE, this is\n+   the set of blocks that has been passed to DF_SET_BLOCKS.  For calls\n+   from DF_ANALYZE_SIMPLE_CHANGE_SOME_BLOCKS, this is the set of\n+   blocks in the fringe (the set of blocks passed in plus the set of\n+   immed preds and succs of those blocks).\n+\n+   BLOCKS_TO_INIT are the blocks whose solution will be changed by\n+   this iteration.  For calls from DF_ANALYZE, this is the set of\n+   blocks that has been passed to DF_SET_BLOCKS.  For calls from\n+   DF_ANALYZE_SIMPLE_CHANGE_SOME_BLOCKS, this is the set of blocks\n+   passed in.\n+\n+   BLOCKS_TO_SCAN are the set of blocks that need to be rescanned.\n+   For calls from DF_ANALYZE, this is the accumulated set of blocks\n+   that has been passed to DF_RESCAN_BLOCKS since the last call to\n+   DF_ANALYZE.  For calls from DF_ANALYZE_SIMPLE_CHANGE_SOME_BLOCKS,\n+   this is the set of blocks passed in.\n+ \n+                   blocks_to_consider    blocks_to_init    blocks_to_scan\n+   full redo       all                   all               all\n+   partial redo    all                   all               sub\n+   small fixup     fringe                sub               sub\n+*/\n+\n+static void\n+df_analyze_problem (struct dataflow *dflow, \n+\t\t    bitmap blocks_to_consider, \n+\t\t    bitmap blocks_to_init,\n+\t\t    bitmap blocks_to_scan,\n+\t\t    int *postorder, int n_blocks, bool single_pass)\n+{\n+  /* (Re)Allocate the datastructures necessary to solve the problem.  */ \n+  if (*dflow->problem->alloc_fun)\n+    (*dflow->problem->alloc_fun) (dflow, blocks_to_scan);\n+\n+  /* Set up the problem and compute the local information.  This\n+     function is passed both the blocks_to_consider and the\n+     blocks_to_scan because the RD and RU problems require the entire\n+     function to be rescanned if they are going to be updated.  */\n+  if (*dflow->problem->local_compute_fun)\n+    (*dflow->problem->local_compute_fun) (dflow, blocks_to_consider, blocks_to_scan);\n+\n+  /* Solve the equations.  */\n+  if (*dflow->problem->dataflow_fun)\n+    (*dflow->problem->dataflow_fun) (dflow, blocks_to_consider, blocks_to_init,\n+\t\t\t\t    postorder, n_blocks, single_pass);\n+\n+  /* Massage the solution.  */\n+  if (*dflow->problem->finalize_fun)\n+    (*dflow->problem->finalize_fun) (dflow, blocks_to_consider);\n+}\n+\n+\n+/* Analyze dataflow info for the basic blocks specified by the bitmap\n+   BLOCKS, or for the whole CFG if BLOCKS is zero.  */\n+\n+void\n+df_analyze (struct df *df)\n+{\n+  int *postorder = xmalloc (sizeof (int) *last_basic_block);\n+  bitmap current_all_blocks = BITMAP_ALLOC (NULL);\n+  int n_blocks;\n+  int i;\n+  bool everything;\n+\n+  n_blocks = post_order_compute (postorder, true);\n+\n+  if (n_blocks != n_basic_blocks)\n+    delete_unreachable_blocks ();\n+\n+  for (i = 0; i < n_blocks; i++)\n+    bitmap_set_bit (current_all_blocks, postorder[i]);\n+\n+  /* No one called df_rescan_blocks, so do it.  */\n+  if (!df->blocks_to_scan)\n+    df_rescan_blocks (df, NULL);\n+\n+  /* Make sure that we have pruned any unreachable blocks from these\n+     sets.  */\n+  bitmap_and_into (df->blocks_to_scan, current_all_blocks);\n+\n+  if (df->blocks_to_analyze)\n+    {\n+      everything = false;\n+      bitmap_and_into (df->blocks_to_analyze, current_all_blocks);\n+      n_blocks = df_prune_to_subcfg (postorder, n_blocks, df->blocks_to_analyze);\n+      BITMAP_FREE (current_all_blocks);\n+    }\n+  else\n+    {\n+      everything = true;\n+      df->blocks_to_analyze = current_all_blocks;\n+      current_all_blocks = NULL;\n+    }\n+\n+  /* Skip over the DF_SCAN problem. */\n+  for (i = 1; i < df->num_problems_defined; i++)\n+    df_analyze_problem (df->problems_in_order[i], \n+\t\t\tdf->blocks_to_analyze, df->blocks_to_analyze, \n+\t\t\tdf->blocks_to_scan,\n+\t\t\tpostorder, n_blocks, false);\n+\n+  if (everything)\n+    {\n+      BITMAP_FREE (df->blocks_to_analyze);\n+      df->blocks_to_analyze = NULL;\n+    }\n+\n+  BITMAP_FREE (df->blocks_to_scan);\n+  df->blocks_to_scan = NULL;\n+}\n+\n+\n+\f\n+/*----------------------------------------------------------------------------\n+   Functions to support limited incremental change.\n+----------------------------------------------------------------------------*/\n+\n+\n+/* Get basic block info.  */\n+\n+static void *\n+df_get_bb_info (struct dataflow *dflow, unsigned int index)\n+{\n+  return (struct df_scan_bb_info *) dflow->block_info[index];\n+}\n+\n+\n+/* Set basic block info.  */\n+\n+static void\n+df_set_bb_info (struct dataflow *dflow, unsigned int index, \n+\t\tvoid *bb_info)\n+{\n+  dflow->block_info[index] = bb_info;\n+}\n+\n+\n+/* Called from the rtl_compact_blocks to reorganize the problems basic\n+   block info.  */\n+\n+void \n+df_compact_blocks (struct df *df)\n+{\n+  int i, p;\n+  basic_block bb;\n+  void **problem_temps;\n+  int size = last_basic_block *sizeof (void *);\n+  problem_temps = xmalloc (size);\n+\n+  for (p = 0; p < df->num_problems_defined; p++)\n+    {\n+      struct dataflow *dflow = df->problems_in_order[p];\n+      if (*dflow->problem->free_bb_fun)\n+\t{\n+\t  df_grow_bb_info (dflow);\n+\t  memcpy (problem_temps, dflow->block_info, size);\n+\n+\t  /* Copy the bb info from the problem tmps to the proper\n+\t     place in the block_info vector.  Null out the copied\n+\t     item.  */\n+\t  i = NUM_FIXED_BLOCKS;\n+\t  FOR_EACH_BB (bb) \n+\t    {\n+\t      df_set_bb_info (dflow, i, problem_temps[bb->index]);\n+\t      problem_temps[bb->index] = NULL;\n+\t      i++;\n+\t    }\n+\t  memset (dflow->block_info + i, 0, \n+\t\t  (last_basic_block - i) *sizeof (void *));\n+\n+\t  /* Free any block infos that were not copied (and NULLed).\n+\t     These are from orphaned blocks.  */\n+\t  for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n+\t    {\n+\t      if (problem_temps[i])\n+\t\t(*dflow->problem->free_bb_fun) (dflow, problem_temps[i]);\n+\t    }\n+\t}\n+    }\n+\n+  free (problem_temps);\n+\n+  i = NUM_FIXED_BLOCKS;\n+  FOR_EACH_BB (bb) \n+    {\n+      BASIC_BLOCK (i) = bb;\n+      bb->index = i;\n+      i++;\n+    }\n+\n+  gcc_assert (i == n_basic_blocks);\n+\n+  for (; i < last_basic_block; i++)\n+    BASIC_BLOCK (i) = NULL;\n+}\n+\n+\n+/* Shove NEW_BLOCK in at OLD_INDEX.  Called from if-cvt to hack a\n+   block.  There is no excuse for people to do this kind of thing.  */\n+\n+void \n+df_bb_replace (struct df *df, int old_index, basic_block new_block)\n+{\n+  int p;\n+\n+  for (p = 0; p < df->num_problems_defined; p++)\n+    {\n+      struct dataflow *dflow = df->problems_in_order[p];\n+      if (dflow->block_info)\n+\t{\n+\t  void *temp;\n+\n+\t  df_grow_bb_info (dflow);\n+\n+\t  /* The old switcheroo.  */\n+\n+\t  temp = df_get_bb_info (dflow, old_index);\n+\t  df_set_bb_info (dflow, old_index, \n+\t\t\t  df_get_bb_info (dflow, new_block->index));\n+\t  df_set_bb_info (dflow, new_block->index, temp);\n+\t}\n+    }\n+\n+  BASIC_BLOCK (old_index) = new_block;\n+  new_block->index = old_index;\n+}\n+\n+/*----------------------------------------------------------------------------\n+   PUBLIC INTERFACES TO QUERY INFORMATION.\n+----------------------------------------------------------------------------*/\n+\n+\n+/* Return last use of REGNO within BB.  */\n+\n+struct df_ref *\n+df_bb_regno_last_use_find (struct df *df, basic_block bb, unsigned int regno)\n+{\n+  rtx insn;\n+  struct df_ref *use;\n+\n+  FOR_BB_INSNS_REVERSE (bb, insn)\n+    {\n+      unsigned int uid = INSN_UID (insn);\n+      for (use = DF_INSN_UID_GET (df, uid)->uses; use; use = use->next_ref)\n+\tif (DF_REF_REGNO (use) == regno)\n+\t  return use;\n+    }\n+  return NULL;\n+}\n+\n+\n+/* Return first def of REGNO within BB.  */\n+\n+struct df_ref *\n+df_bb_regno_first_def_find (struct df *df, basic_block bb, unsigned int regno)\n+{\n+  rtx insn;\n+  struct df_ref *def;\n+\n+  FOR_BB_INSNS (bb, insn)\n+    {\n+      unsigned int uid = INSN_UID (insn);\n+      for (def = DF_INSN_UID_GET (df, uid)->defs; def; def = def->next_ref)\n+\tif (DF_REF_REGNO (def) == regno)\n+\t  return def;\n+    }\n+  return NULL;\n+}\n+\n+\n+/* Return last def of REGNO within BB.  */\n+\n+struct df_ref *\n+df_bb_regno_last_def_find (struct df *df, basic_block bb, unsigned int regno)\n+{\n+  rtx insn;\n+  struct df_ref *def;\n+\n+  FOR_BB_INSNS_REVERSE (bb, insn)\n+    {\n+      unsigned int uid = INSN_UID (insn);\n+\n+      for (def = DF_INSN_UID_GET (df, uid)->defs; def; def = def->next_ref)\n+\tif (DF_REF_REGNO (def) == regno)\n+\t  return def;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Return true if INSN defines REGNO.  */\n+\n+bool\n+df_insn_regno_def_p (struct df *df, rtx insn, unsigned int regno)\n+{\n+  unsigned int uid;\n+  struct df_ref *def;\n+\n+  uid = INSN_UID (insn);\n+  for (def = DF_INSN_UID_GET (df, uid)->defs; def; def = def->next_ref)\n+    if (DF_REF_REGNO (def) == regno)\n+      return true;\n+  \n+  return false;\n+}\n+\n+\n+/* Finds the reference corresponding to the definition of REG in INSN.\n+   DF is the dataflow object.  */\n+\n+struct df_ref *\n+df_find_def (struct df *df, rtx insn, rtx reg)\n+{\n+  unsigned int uid;\n+  struct df_ref *def;\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+  gcc_assert (REG_P (reg));\n+\n+  uid = INSN_UID (insn);\n+  for (def = DF_INSN_UID_GET (df, uid)->defs; def; def = def->next_ref)\n+    if (rtx_equal_p (DF_REF_REAL_REG (def), reg))\n+      return def;\n+\n+  return NULL;\n+}\n+\n+\n+/* Return true if REG is defined in INSN, zero otherwise.  */ \n+\n+bool\n+df_reg_defined (struct df *df, rtx insn, rtx reg)\n+{\n+  return df_find_def (df, insn, reg) != NULL;\n+}\n+  \n+\n+/* Finds the reference corresponding to the use of REG in INSN.\n+   DF is the dataflow object.  */\n+  \n+struct df_ref *\n+df_find_use (struct df *df, rtx insn, rtx reg)\n+{\n+  unsigned int uid;\n+  struct df_ref *use;\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+  gcc_assert (REG_P (reg));\n+\n+  uid = INSN_UID (insn);\n+  for (use = DF_INSN_UID_GET (df, uid)->uses; use; use = use->next_ref)\n+    if (rtx_equal_p (DF_REF_REAL_REG (use), reg))\n+      return use; \n+\n+  return NULL;\n+}\n+\n+\n+/* Return true if REG is referenced in INSN, zero otherwise.  */ \n+\n+bool\n+df_reg_used (struct df *df, rtx insn, rtx reg)\n+{\n+  return df_find_use (df, insn, reg) != NULL;\n+}\n+  \n+\f\n+/*----------------------------------------------------------------------------\n+   Debugging and printing functions.\n+----------------------------------------------------------------------------*/\n+\n+/* Dump dataflow info.  */\n+void\n+df_dump (struct df *df, FILE *file)\n+{\n+  int i;\n+\n+  if (! df || ! file)\n+    return;\n+\n+  fprintf (file, \"\\n\\n%s\\n\", current_function_name ());\n+  fprintf (file, \"\\nDataflow summary:\\n\");\n+  fprintf (file, \"def_info->bitmap_size = %d, use_info->bitmap_size = %d\\n\",\n+\t   df->def_info.bitmap_size, df->use_info.bitmap_size);\n+\n+  for (i = 0; i < df->num_problems_defined; i++)\n+    (*df->problems_in_order[i]->problem->dump_fun) (df->problems_in_order[i], file); \n+\n+  fprintf (file, \"\\n\");\n+}\n+\n+\n+void\n+df_refs_chain_dump (struct df *df, struct df_ref *ref, \n+\t\t   bool follow_chain, FILE *file)\n+{\n+  fprintf (file, \"{ \");\n+  while (ref)\n+    {\n+      fprintf (file, \"%c%d(%d) \",\n+\t       DF_REF_REG_DEF_P (ref) ? 'd' : 'u',\n+\t       DF_REF_ID (ref),\n+\t       DF_REF_REGNO (ref));\n+      if (follow_chain)\n+\tdf_chain_dump (df, DF_REF_CHAIN (ref), file);\n+      ref = ref->next_ref;\n+    }\n+  fprintf (file, \"}\");\n+}\n+\n+\n+/* Dump either a ref-def or reg-use chain.  */\n+\n+void\n+df_regs_chain_dump (struct df *df ATTRIBUTE_UNUSED, struct df_ref *ref,  FILE *file)\n+{\n+  fprintf (file, \"{ \");\n+  while (ref)\n+    {\n+      fprintf (file, \"%c%d(%d) \",\n+\t       DF_REF_REG_DEF_P (ref) ? 'd' : 'u',\n+\t       DF_REF_ID (ref),\n+\t       DF_REF_REGNO (ref));\n+      ref = ref->next_reg;\n+    }\n+  fprintf (file, \"}\");\n+}\n+\n+\n+void\n+df_insn_debug (struct df *df, rtx insn, bool follow_chain, FILE *file)\n+{\n+  unsigned int uid;\n+  int bbi;\n+\n+  uid = INSN_UID (insn);\n+\n+  if (DF_INSN_UID_DEFS (df, uid))\n+    bbi = DF_REF_BBNO (DF_INSN_UID_DEFS (df, uid));\n+  else if (DF_INSN_UID_USES(df, uid))\n+    bbi = DF_REF_BBNO (DF_INSN_UID_USES (df, uid));\n+  else\n+    bbi = -1;\n+\n+  fprintf (file, \"insn %d bb %d luid %d defs \",\n+\t   uid, bbi, DF_INSN_LUID (df, insn));\n+\n+  df_refs_chain_dump (df, DF_INSN_UID_DEFS (df, uid), follow_chain, file);\n+  fprintf (file, \" defs \");\n+  df_refs_chain_dump (df, DF_INSN_UID_USES (df, uid), follow_chain, file);\n+  fprintf (file, \"\\n\");\n+}\n+\n+void\n+df_insn_debug_regno (struct df *df, rtx insn, FILE *file)\n+{\n+  unsigned int uid;\n+  int bbi;\n+\n+  uid = INSN_UID (insn);\n+  if (DF_INSN_UID_DEFS (df, uid))\n+    bbi = DF_REF_BBNO (DF_INSN_UID_DEFS (df, uid));\n+  else if (DF_INSN_UID_USES(df, uid))\n+    bbi = DF_REF_BBNO (DF_INSN_UID_USES (df, uid));\n+  else\n+    bbi = -1;\n+\n+  fprintf (file, \"insn %d bb %d luid %d defs \",\n+\t   uid, bbi, DF_INSN_LUID (df, insn));\n+  df_regs_chain_dump (df, DF_INSN_UID_DEFS (df, uid), file);\n+    \n+  fprintf (file, \" uses \");\n+  df_regs_chain_dump (df, DF_INSN_UID_USES (df, uid), file);\n+  fprintf (file, \"\\n\");\n+}\n+\n+void\n+df_regno_debug (struct df *df, unsigned int regno, FILE *file)\n+{\n+  fprintf (file, \"reg %d defs \", regno);\n+  df_regs_chain_dump (df, DF_REG_DEF_GET (df, regno)->reg_chain, file);\n+  fprintf (file, \" uses \");\n+  df_regs_chain_dump (df, DF_REG_USE_GET (df, regno)->reg_chain, file);\n+  fprintf (file, \"\\n\");\n+}\n+\n+\n+void\n+df_ref_debug (struct df *df, struct df_ref *ref, FILE *file)\n+{\n+  fprintf (file, \"%c%d \",\n+\t   DF_REF_REG_DEF_P (ref) ? 'd' : 'u',\n+\t   DF_REF_ID (ref));\n+  fprintf (file, \"reg %d bb %d luid %d insn %d chain \",\n+\t   DF_REF_REGNO (ref),\n+\t   DF_REF_BBNO (ref),\n+\t   DF_REF_INSN (ref) ? DF_INSN_LUID (df, DF_REF_INSN (ref)) : -1,\n+\t   DF_REF_INSN (ref) ? INSN_UID (DF_REF_INSN (ref)) : -1);\n+  df_chain_dump (df, DF_REF_CHAIN (ref), file);\n+  fprintf (file, \"\\n\");\n+}\n+\f\n+/* Functions for debugging from GDB.  */\n+\n+void\n+debug_df_insn (rtx insn)\n+{\n+  df_insn_debug (ddf, insn, true, stderr);\n+  debug_rtx (insn);\n+}\n+\n+\n+void\n+debug_df_reg (rtx reg)\n+{\n+  df_regno_debug (ddf, REGNO (reg), stderr);\n+}\n+\n+\n+void\n+debug_df_regno (unsigned int regno)\n+{\n+  df_regno_debug (ddf, regno, stderr);\n+}\n+\n+\n+void\n+debug_df_ref (struct df_ref *ref)\n+{\n+  df_ref_debug (ddf, ref, stderr);\n+}\n+\n+\n+void\n+debug_df_defno (unsigned int defno)\n+{\n+  df_ref_debug (ddf, DF_DEFS_GET (ddf, defno), stderr);\n+}\n+\n+\n+void\n+debug_df_useno (unsigned int defno)\n+{\n+  df_ref_debug (ddf, DF_USES_GET (ddf, defno), stderr);\n+}\n+\n+\n+void\n+debug_df_chain (struct df_link *link)\n+{\n+  df_chain_dump (ddf, link, stderr);\n+  fputc ('\\n', stderr);\n+}"}, {"sha": "c17e048edad0ce56849f10fc9ddb811e9184ca6d", "filename": "gcc/df-problems.c", "status": "added", "additions": 3093, "deletions": 0, "changes": 3093, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=4d779342f00ac9b678043e8a2e474a1ae14b8660"}, {"sha": "0aa07bf33c6c68593885653e77b2099a80b51a10", "filename": "gcc/df-scan.c", "status": "added", "additions": 1795, "deletions": 0, "changes": 1795, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=4d779342f00ac9b678043e8a2e474a1ae14b8660", "patch": "@@ -0,0 +1,1795 @@\n+/* FIXME: We need to go back and add the warning messages about code\n+   moved across setjmp.  */\n+\n+\n+/* Scanning of rtl for dataflow analysis.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n+   Originally contributed by Michael P. Hayes \n+             (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)\n+   Major rewrite contributed by Danny Berlin (dberlin@dberlin.org)\n+             and Kenneth Zadeck (zadeck@naturalbridge.com).\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"function.h\"\n+#include \"regs.h\"\n+#include \"output.h\"\n+#include \"alloc-pool.h\"\n+#include \"flags.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"sbitmap.h\"\n+#include \"bitmap.h\"\n+#include \"timevar.h\"\n+#include \"df.h\"\n+\n+#ifndef HAVE_epilogue\n+#define HAVE_epilogue 0\n+#endif\n+#ifndef HAVE_prologue\n+#define HAVE_prologue 0\n+#endif\n+#ifndef HAVE_sibcall_epilogue\n+#define HAVE_sibcall_epilogue 0\n+#endif\n+\n+#ifndef EPILOGUE_USES\n+#define EPILOGUE_USES(REGNO)  0\n+#endif\n+\n+/* Indicates where we are in the compilation.  */\n+int df_state;\n+\n+/* The bitmap_obstack is used to hold some static variables that\n+   should not be reset after each function is compiled.  */\n+\n+static bitmap_obstack persistent_obstack;\n+\n+/* The set of hard registers in eliminables[i].from. */\n+\n+static HARD_REG_SET elim_reg_set;\n+\n+/* This is a bitmap copy of regs_invalidated_by_call so that we can\n+   easily add it into bitmaps, etc. */ \n+\n+bitmap df_invalidated_by_call = NULL;\n+\n+/* Initialize ur_in and ur_out as if all hard registers were partially\n+   available.  */\n+\n+bitmap df_all_hard_regs = NULL;\n+\n+static void df_ref_record (struct dataflow *, rtx, rtx *, \n+\t\t\t   basic_block, rtx, enum df_ref_type,\n+\t\t\t   enum df_ref_flags, bool record_live);\n+static void df_def_record_1 (struct dataflow *, rtx, basic_block, rtx,\n+\t\t\t     enum df_ref_flags, bool record_live);\n+static void df_defs_record (struct dataflow *, rtx, basic_block, rtx);\n+static void df_uses_record (struct dataflow *, rtx *, enum df_ref_type,\n+\t\t\t    basic_block, rtx, enum df_ref_flags);\n+\n+static void df_insn_refs_record (struct dataflow *, basic_block, rtx);\n+static void df_bb_refs_record (struct dataflow *, basic_block);\n+static void df_refs_record (struct dataflow *, bitmap);\n+static struct df_ref *df_ref_create_structure (struct dataflow *, rtx, rtx *, \n+\t\t\t\t\t       basic_block, rtx, enum df_ref_type, \n+\t\t\t\t\t       enum df_ref_flags);\n+static void df_record_exit_block_uses (struct dataflow *);\n+static void df_grow_reg_info (struct dataflow *, struct df_ref_info *);\n+static void df_grow_ref_info (struct df_ref_info *, unsigned int);\n+static void df_grow_insn_info (struct df *);\n+\n+\f\n+/*----------------------------------------------------------------------------\n+   SCANNING DATAFLOW PROBLEM\n+\n+   There are several ways in which scanning looks just like the other\n+   dataflow problems.  It shares the all the mechanisms for local info\n+   as well as basic block info.  Where it differs is when and how often\n+   it gets run.  It also has no need for the iterative solver.\n+----------------------------------------------------------------------------*/\n+\n+/* Problem data for the scanning dataflow function.  */\n+struct df_scan_problem_data\n+{\n+  alloc_pool ref_pool;\n+  alloc_pool insn_pool;\n+  alloc_pool reg_pool;\n+};\n+\n+typedef struct df_scan_bb_info *df_scan_bb_info_t;\n+\n+static void \n+df_scan_free_internal (struct dataflow *dflow)\n+{\n+  struct df *df = dflow->df;\n+  struct df_scan_problem_data *problem_data = \n+    (struct df_scan_problem_data *) dflow->problem_data;\n+\n+  free (df->def_info.regs);\n+  free (df->def_info.refs);\n+  memset (&df->def_info, 0, (sizeof (struct df_ref_info)));\n+\n+  free (df->use_info.regs);\n+  free (df->use_info.refs);\n+  memset (&df->use_info, 0, (sizeof (struct df_ref_info)));\n+\n+  free (df->insns);\n+  df->insns = NULL;\n+  df->insns_size = 0;\n+\n+  free (dflow->block_info);\n+  dflow->block_info = NULL;\n+  dflow->block_info_size = 0;\n+\n+  BITMAP_FREE (df->hardware_regs_used);\n+  BITMAP_FREE (df->exit_block_uses);\n+\n+  free_alloc_pool (dflow->block_pool);\n+  free_alloc_pool (problem_data->ref_pool);\n+  free_alloc_pool (problem_data->insn_pool);\n+  free_alloc_pool (problem_data->reg_pool);\n+}\n+\n+\n+/* Get basic block info.  */\n+\n+struct df_scan_bb_info *\n+df_scan_get_bb_info (struct dataflow *dflow, unsigned int index)\n+{\n+  gcc_assert (index < dflow->block_info_size); \n+  return (struct df_scan_bb_info *) dflow->block_info[index];\n+}\n+\n+\n+/* Set basic block info.  */\n+\n+static void\n+df_scan_set_bb_info (struct dataflow *dflow, unsigned int index, \n+\t\t     struct df_scan_bb_info *bb_info)\n+{\n+  gcc_assert (index < dflow->block_info_size); \n+  dflow->block_info[index] = (void *) bb_info;\n+}\n+\n+\n+/* Free basic block info.  */\n+\n+static void\n+df_scan_free_bb_info (struct dataflow *dflow, void *vbb_info)\n+{\n+  struct df_scan_bb_info *bb_info = (struct df_scan_bb_info *) vbb_info;\n+  if (bb_info)\n+    pool_free (dflow->block_pool, bb_info);\n+}\n+\n+\n+/* Allocate the problem data for the scanning problem.  This should be\n+   called when the problem is created or when the entire function is to\n+   be rescanned.  */\n+\n+static void \n+df_scan_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n+{\n+  struct df *df = dflow->df;\n+  struct df_scan_problem_data *problem_data;\n+  unsigned int insn_num = get_max_uid () + 1;\n+  unsigned int block_size = 50;\n+  unsigned int bb_index;\n+  bitmap_iterator bi;\n+\n+  /* Given the number of pools, this is really faster than tearing\n+     everything apart.  */\n+  if (dflow->problem_data)\n+    df_scan_free_internal (dflow);\n+\n+  dflow->block_pool \n+    = create_alloc_pool (\"df_scan_block pool\", \n+\t\t\t sizeof (struct df_scan_bb_info), \n+\t\t\t block_size);\n+\n+  problem_data = xmalloc (sizeof (struct df_scan_problem_data));\n+  dflow->problem_data = problem_data;\n+\n+  problem_data->ref_pool \n+    = create_alloc_pool (\"df_scan_ref pool\", \n+\t\t\t sizeof (struct df_ref), block_size);\n+  problem_data->insn_pool \n+    = create_alloc_pool (\"df_scan_insn pool\", \n+\t\t\t sizeof (struct df_insn_info), block_size);\n+\n+  problem_data->reg_pool \n+    = create_alloc_pool (\"df_scan_reg pool\", \n+\t\t\t sizeof (struct df_reg_info), block_size);\n+\n+  insn_num += insn_num / 4; \n+  df_grow_reg_info (dflow, &df->def_info);\n+  df_grow_ref_info (&df->def_info, insn_num);\n+\n+  df_grow_reg_info (dflow, &df->use_info);\n+  df_grow_ref_info (&df->use_info, insn_num *2);\n+\n+  df_grow_insn_info (df);\n+  df_grow_bb_info (dflow);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (blocks_to_rescan, 0, bb_index, bi)\n+    {\n+      struct df_scan_bb_info *bb_info = df_scan_get_bb_info (dflow, bb_index);\n+      if (!bb_info)\n+\t{\n+\t  bb_info = (struct df_scan_bb_info *) pool_alloc (dflow->block_pool);\n+\t  df_scan_set_bb_info (dflow, bb_index, bb_info);\n+\t}\n+      bb_info->artificial_defs = NULL;\n+      bb_info->artificial_uses = NULL;\n+    }\n+\n+  df->hardware_regs_used = BITMAP_ALLOC (NULL);\n+  df->exit_block_uses = BITMAP_ALLOC (NULL);\n+}\n+\n+\n+/* Free all of the data associated with the scan problem.  */\n+\n+static void \n+df_scan_free (struct dataflow *dflow)\n+{\n+  struct df *df = dflow->df;\n+  \n+  df_scan_free_internal (dflow);\n+  if (df->blocks_to_scan)\n+    BITMAP_FREE (df->blocks_to_scan);\n+  \n+  if (df->blocks_to_analyze)\n+    BITMAP_FREE (df->blocks_to_analyze);\n+\n+  free (dflow->problem_data);\n+  free (dflow);\n+}\n+\n+static void \n+df_scan_dump (struct dataflow *dflow ATTRIBUTE_UNUSED, FILE *file ATTRIBUTE_UNUSED)\n+{\n+  struct df *df = dflow->df;\n+  int i;\n+\n+  fprintf (file, \"  all hard regs \\t\");\n+  dump_bitmap (file, df_all_hard_regs);\n+  fprintf (file, \"  invalidated by call \\t\");\n+  dump_bitmap (file, df_invalidated_by_call);\n+  fprintf (file, \"  hardware regs used \\t\");\n+  dump_bitmap (file, df->hardware_regs_used);\n+  fprintf (file, \"  exit block uses \\t\");\n+  dump_bitmap (file, df->exit_block_uses);\n+  fprintf (file, \"  regs ever live \\t\");\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (regs_ever_live[i])\n+      fprintf (file, \"%d \", i);\n+  fprintf (file, \"\\n\");\n+}\n+\n+static struct df_problem problem_SCAN =\n+{\n+  DF_SCAN,                    /* Problem id.  */\n+  DF_NONE,                    /* Direction.  */\n+  df_scan_alloc,              /* Allocate the problem specific data.  */\n+  df_scan_free_bb_info,       /* Free basic block info.  */\n+  NULL,                       /* Local compute function.  */\n+  NULL,                       /* Init the solution specific data.  */\n+  NULL,                       /* Iterative solver.  */\n+  NULL,                       /* Confluence operator 0.  */ \n+  NULL,                       /* Confluence operator n.  */ \n+  NULL,                       /* Transfer function.  */\n+  NULL,                       /* Finalize function.  */\n+  df_scan_free,               /* Free all of the problem information.  */\n+  df_scan_dump,               /* Debugging.  */\n+  NULL                        /* Dependent problem.  */\n+};\n+\n+\n+/* Create a new DATAFLOW instance and add it to an existing instance\n+   of DF.  The returned structure is what is used to get at the\n+   solution.  */\n+\n+struct dataflow *\n+df_scan_add_problem (struct df *df)\n+{\n+  return df_add_problem (df, &problem_SCAN);\n+}\n+\n+/*----------------------------------------------------------------------------\n+   Storage Allocation Utilities\n+----------------------------------------------------------------------------*/\n+\n+\n+/* First, grow the reg_info information.  If the current size is less than\n+   the number of psuedos, grow to 25% more than the number of\n+   pseudos.  \n+\n+   Second, assure that all of the slots up to max_reg_num have been\n+   filled with reg_info structures.  */\n+\n+static void \n+df_grow_reg_info (struct dataflow *dflow, struct df_ref_info *ref_info)\n+{\n+  unsigned int max_reg = max_reg_num ();\n+  unsigned int new_size = max_reg;\n+  struct df_scan_problem_data *problem_data =\n+    (struct df_scan_problem_data *) dflow->problem_data;\n+  unsigned int i;\n+\n+  if (ref_info->regs_size < new_size)\n+    {\n+      new_size += new_size / 4;\n+      ref_info->regs = xrealloc (ref_info->regs, \n+\t\t\t\t new_size *sizeof (struct df_reg_info*));\n+      ref_info->regs_size = new_size;\n+    }\n+\n+  for (i = ref_info->regs_inited; i < max_reg; i++)\n+    {\n+      struct df_reg_info *reg_info = pool_alloc (problem_data->reg_pool);\n+      memset (reg_info, 0, sizeof (struct df_reg_info));\n+      ref_info->regs[i] = reg_info;\n+    }\n+  \n+  ref_info->regs_inited = max_reg;\n+}\n+\n+\n+/* Grow the ref information.  */\n+\n+static void \n+df_grow_ref_info (struct df_ref_info *ref_info, unsigned int new_size)\n+{\n+  if (ref_info->refs_size < new_size)\n+    {\n+      ref_info->refs = xrealloc (ref_info->refs, \n+\t\t\t\t new_size *sizeof (struct df_ref *));\n+      memset (ref_info->refs + ref_info->refs_size, 0,\n+\t      (new_size - ref_info->refs_size) *sizeof (struct df_ref *));\n+      ref_info->refs_size = new_size;\n+    }\n+}\n+\n+\n+/* Grow the ref information.  If the current size is less than the\n+   number of instructions, grow to 25% more than the number of\n+   instructions.  */\n+\n+static void \n+df_grow_insn_info (struct df *df)\n+{\n+  unsigned int new_size = get_max_uid () + 1;\n+  if (df->insns_size < new_size)\n+    {\n+      new_size += new_size / 4;\n+      df->insns = xrealloc (df->insns, \n+\t\t\t    new_size *sizeof (struct df_insn_info *));\n+      memset (df->insns + df->insns_size, 0,\n+\t      (new_size - df->insns_size) *sizeof (struct df_insn_info *));\n+      df->insns_size = new_size;\n+    }\n+}\n+\n+\n+\n+\f\n+/*----------------------------------------------------------------------------\n+   PUBLIC INTERFACES FOR SMALL GRAIN CHANGES TO SCANNING.\n+----------------------------------------------------------------------------*/\n+\n+/* Rescan some BLOCKS or all the blocks defined by the last call to\n+   df_set_blocks if BLOCKS is NULL);  */\n+\n+void\n+df_rescan_blocks (struct df *df, bitmap blocks)\n+{\n+  bitmap local_blocks_to_scan = BITMAP_ALLOC (NULL);\n+\n+  struct dataflow *dflow = df->problems_by_index [DF_SCAN];\n+  basic_block bb;\n+\n+  df->def_info.refs_organized = false;\n+  df->use_info.refs_organized = false;\n+\n+  if (blocks)\n+    {\n+      /* Need to assure that there are space in all of the tables.  */\n+      unsigned int insn_num = get_max_uid () + 1;\n+      insn_num += insn_num / 4;\n+\n+      df_grow_reg_info (dflow, &df->def_info);\n+      df_grow_ref_info (&df->def_info, insn_num);\n+      \n+      df_grow_reg_info (dflow, &df->use_info);\n+      df_grow_ref_info (&df->use_info, insn_num *2);\n+      \n+      df_grow_insn_info (df);\n+      df_grow_bb_info (dflow);\n+\n+      bitmap_copy (local_blocks_to_scan, blocks);\n+      df->def_info.add_refs_inline = true;\n+      df->use_info.add_refs_inline = true;\n+\n+      df_refs_delete (dflow, local_blocks_to_scan);\n+\n+      /* This may be a mistake, but if an explicit blocks is passed in\n+         and the set of blocks to analyze has been explicitly set, add\n+         the extra blocks to blocks_to_analyze.  The alternative is to\n+         put an assert here.  We do not want this to just go by\n+         silently or else we may get storage leaks.  */\n+      if (df->blocks_to_analyze)\n+\tbitmap_ior_into (df->blocks_to_analyze, blocks);\n+    }\n+  else\n+    {\n+      /* If we are going to do everything, just reallocate everything.\n+\t Most stuff is allocated in pools so this is faster than\n+\t walking it.  */\n+      if (df->blocks_to_analyze)\n+\tbitmap_copy (local_blocks_to_scan, df->blocks_to_analyze);\n+      else\n+\tFOR_ALL_BB (bb) \n+\t  {\n+\t    bitmap_set_bit (local_blocks_to_scan, bb->index);\n+\t  }\n+      df_scan_alloc (dflow, local_blocks_to_scan);\n+\n+      df->def_info.add_refs_inline = false;\n+      df->use_info.add_refs_inline = false;\n+    }\n+\n+  df_refs_record (dflow, local_blocks_to_scan);\n+#if 0\n+  bitmap_print (stderr, local_blocks_to_scan, \"scanning: \", \"\\n\");\n+#endif\n+      \n+  if (!df->blocks_to_scan)\n+    df->blocks_to_scan = BITMAP_ALLOC (NULL);\n+\n+  bitmap_ior_into (df->blocks_to_scan, local_blocks_to_scan); \n+  BITMAP_FREE (local_blocks_to_scan);\n+}\n+\n+/* Create a new ref of type DF_REF_TYPE for register REG at address\n+   LOC within INSN of BB.  */\n+\n+struct df_ref *\n+df_ref_create (struct df *df, rtx reg, rtx *loc, rtx insn, \n+\t       basic_block bb,\n+\t       enum df_ref_type ref_type, \n+\t       enum df_ref_flags ref_flags)\n+{\n+  struct dataflow *dflow = df->problems_by_index[DF_SCAN];\n+  struct df_scan_bb_info *bb_info;\n+  \n+  df_grow_reg_info (dflow, &df->use_info);\n+  df_grow_reg_info (dflow, &df->def_info);\n+  df_grow_bb_info (dflow);\n+  \n+  /* Make sure there is the bb_info for this block.  */\n+  bb_info = df_scan_get_bb_info (dflow, bb->index);\n+  if (!bb_info)\n+    {\n+      bb_info = (struct df_scan_bb_info *) pool_alloc (dflow->block_pool);\n+      df_scan_set_bb_info (dflow, bb->index, bb_info);\n+      bb_info->artificial_defs = NULL;\n+      bb_info->artificial_uses = NULL;\n+    }\n+\n+  if (ref_type == DF_REF_REG_DEF)\n+    df->def_info.add_refs_inline = true;\n+  else\n+    df->use_info.add_refs_inline = true;\n+  \n+  return df_ref_create_structure (dflow, reg, loc, bb, insn, ref_type, ref_flags);\n+}\n+\n+\n+\f\n+/*----------------------------------------------------------------------------\n+   UTILITIES TO CREATE AND DESTROY REFS AND CHAINS.\n+----------------------------------------------------------------------------*/\n+\n+\n+/* Get the artifical uses for a basic block.  */\n+\n+struct df_ref *\n+df_get_artificial_defs (struct df *df, unsigned int bb_index)\n+{\n+  struct dataflow *dflow = df->problems_by_index[DF_SCAN];\n+  return df_scan_get_bb_info (dflow, bb_index)->artificial_defs;\n+}\n+\n+\n+/* Get the artifical uses for a basic block.  */\n+\n+struct df_ref *\n+df_get_artificial_uses (struct df *df, unsigned int bb_index)\n+{\n+  struct dataflow *dflow = df->problems_by_index[DF_SCAN];\n+  return df_scan_get_bb_info (dflow, bb_index)->artificial_uses;\n+}\n+\n+\n+/* Link REF at the front of reg_use or reg_def chain for REGNO.  */\n+\n+void\n+df_reg_chain_create (struct df_reg_info *reg_info, \n+\t\t     struct df_ref *ref) \n+{\n+  struct df_ref *head = reg_info->reg_chain;\n+  reg_info->reg_chain = ref;\n+\n+  DF_REF_NEXT_REG (ref) = head;\n+\n+  /* We cannot actually link to the head of the chain.  */\n+  DF_REF_PREV_REG (ref) = NULL;\n+\n+  if (head)\n+    DF_REF_PREV_REG (head) = ref;\n+}\n+\n+\n+/* Remove REF from the CHAIN.  Return the head of the chain.  This\n+   will be CHAIN unless the REF was at the beginning of the chain.  */\n+\n+static struct df_ref *\n+df_ref_unlink (struct df_ref *chain, struct df_ref *ref)\n+{\n+  struct df_ref *orig_chain = chain;\n+  struct df_ref *prev = NULL;\n+  while (chain)\n+    {\n+      if (chain == ref)\n+\t{\n+\t  if (prev)\n+\t    {\n+\t      prev->next_ref = ref->next_ref;\n+\t      ref->next_ref = NULL;\n+\t      return orig_chain;\n+\t    }\n+\t  else\n+\t    {\n+\t      chain = ref->next_ref;\n+\t      ref->next_ref = NULL;\n+\t      return chain;\n+\t    }\n+\t}\n+\n+      prev = chain;\n+      chain = chain->next_ref;\n+    }\n+\n+  /* Someone passed in a ref that was not in the chain.  */\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+\n+\n+/* Unlink and delete REF at the reg_use or reg_def chain.  Also delete\n+   the def-use or use-def chain if it exists.  Returns the next ref in\n+   uses or defs chain.  */\n+\n+struct df_ref *\n+df_reg_chain_unlink (struct dataflow *dflow, struct df_ref *ref) \n+{\n+  struct df *df = dflow->df;\n+  struct df_ref *next = DF_REF_NEXT_REG (ref);  \n+  struct df_ref *prev = DF_REF_PREV_REG (ref);\n+  struct df_scan_problem_data *problem_data =\n+    (struct df_scan_problem_data *) dflow->problem_data;\n+  struct df_reg_info *reg_info;\n+  struct df_ref *next_ref = ref->next_ref;\n+  unsigned int id = DF_REF_ID (ref);\n+\n+  if (DF_REF_TYPE (ref) == DF_REF_REG_DEF)\n+    {\n+      reg_info = DF_REG_DEF_GET (df, DF_REF_REGNO (ref));\n+      df->def_info.bitmap_size--;\n+      if (df->def_info.refs && (id < df->def_info.refs_size))\n+\tDF_DEFS_SET (df, id, NULL);\n+    }\n+  else \n+    {\n+      reg_info = DF_REG_USE_GET (df, DF_REF_REGNO (ref));\n+      df->use_info.bitmap_size--;\n+      if (df->use_info.refs && (id < df->use_info.refs_size))\n+\tDF_USES_SET (df, id, NULL);\n+    }\n+  \n+  /* Delete any def-use or use-def chains that start here.  */\n+  if (DF_REF_CHAIN (ref))\n+    df_chain_unlink (df->problems_by_index[DF_CHAIN], ref, NULL);\n+\n+  reg_info->n_refs--;\n+\n+  /* Unlink from the reg chain.  If there is no prev, this is the\n+     first of the list.  If not, just join the next and prev.  */\n+  if (prev)\n+    {\n+      DF_REF_NEXT_REG (prev) = next;\n+      if (next)\n+\tDF_REF_PREV_REG (next) = prev;\n+    }\n+  else\n+    {\n+      reg_info->reg_chain = next;\n+      if (next)\n+\tDF_REF_PREV_REG (next) = NULL;\n+    }\n+\n+  pool_free (problem_data->ref_pool, ref);\n+  return next_ref;\n+}\n+\n+\n+/* Unlink REF from all def-use/use-def chains, etc.  */\n+\n+void\n+df_ref_remove (struct df *df, struct df_ref *ref)\n+{\n+  struct dataflow *dflow = df->problems_by_index [DF_SCAN];\n+  if (DF_REF_REG_DEF_P (ref))\n+    {\n+      if (DF_REF_FLAGS (ref) & DF_REF_ARTIFICIAL)\n+\t{\n+\t  struct df_scan_bb_info *bb_info \n+\t    = df_scan_get_bb_info (dflow, DF_REF_BB (ref)->index);\n+\t  bb_info->artificial_defs \n+\t    = df_ref_unlink (bb_info->artificial_defs, ref);\n+\t}\n+      else\n+\tDF_INSN_UID_DEFS (df, DF_REF_INSN_UID (ref)) = \n+\t  df_ref_unlink (DF_INSN_UID_DEFS (df, DF_REF_INSN_UID (ref)), ref);\n+\n+      if (df->def_info.add_refs_inline)\n+\tDF_DEFS_SET (df, DF_REF_ID (ref), NULL);\n+    }\n+  else\n+    {\n+      if (DF_REF_FLAGS (ref) & DF_REF_ARTIFICIAL)\n+\t{\n+\t  struct df_scan_bb_info *bb_info \n+\t    = df_scan_get_bb_info (dflow, DF_REF_BB (ref)->index);\n+\t  bb_info->artificial_uses \n+\t    = df_ref_unlink (bb_info->artificial_uses, ref);\n+\t}\n+      else\n+\tDF_INSN_UID_USES (df, DF_REF_INSN_UID (ref)) = \n+\t  df_ref_unlink (DF_INSN_UID_USES (df, DF_REF_INSN_UID (ref)), ref);\n+      \n+      if (df->use_info.add_refs_inline)\n+\tDF_USES_SET (df, DF_REF_ID (ref), NULL);\n+    }\n+\n+  df_reg_chain_unlink (dflow, ref);\n+}\n+\n+\n+/* Create the insn record for INSN.  If there was one there, zero it out.  */\n+\n+static struct df_insn_info *\n+df_insn_create_insn_record (struct dataflow *dflow, rtx insn)\n+{\n+  struct df *df = dflow->df;\n+  struct df_scan_problem_data *problem_data =\n+    (struct df_scan_problem_data *) dflow->problem_data;\n+\n+  struct df_insn_info *insn_rec = DF_INSN_GET (df, insn);\n+  if (!insn_rec)\n+    {\n+      insn_rec = pool_alloc (problem_data->insn_pool);\n+      DF_INSN_SET (df, insn, insn_rec);\n+    }\n+  memset (insn_rec, 0, sizeof (struct df_insn_info));\n+\n+  return insn_rec;\n+}\n+\n+/* Delete all of the refs information from BLOCKS.  */\n+\n+void \n+df_insn_refs_delete (struct dataflow *dflow, rtx insn)\n+{\n+  struct df *df = dflow->df;\n+  unsigned int uid = INSN_UID (insn);\n+  struct df_insn_info *insn_info = DF_INSN_UID_GET (df, uid);\n+  struct df_ref *ref;\n+  struct df_scan_problem_data *problem_data =\n+    (struct df_scan_problem_data *) dflow->problem_data;\n+\n+  if (insn_info)\n+    {\n+      ref = insn_info->defs;\n+      while (ref) \n+\tref = df_reg_chain_unlink (dflow, ref);\n+      \n+      ref = insn_info->uses;\n+      while (ref) \n+\tref = df_reg_chain_unlink (dflow, ref);\n+\n+      pool_free (problem_data->insn_pool, insn_info);\n+      DF_INSN_SET (df, insn, NULL);\n+    }\n+}\n+\n+\n+/* Delete all of the refs information from BLOCKS.  */\n+\n+void \n+df_refs_delete (struct dataflow *dflow, bitmap blocks)\n+{\n+  bitmap_iterator bi;\n+  unsigned int bb_index;\n+  struct df_ref *def;\n+  struct df_ref *use;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, bb_index, bi)\n+    {\n+      struct df_scan_bb_info *bb_info \n+\t= df_scan_get_bb_info (dflow, bb_index);\n+      rtx insn;\n+      basic_block bb = BASIC_BLOCK (bb_index);\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  if (INSN_P (insn))\n+\t    {\n+\t      /* Record defs within INSN.  */\n+\t      df_insn_refs_delete (dflow, insn);\n+\t    }\n+\t}\n+\n+      /* Get rid of any artifical uses.  */\n+      if (bb_info)\n+\t{\n+\t  def = bb_info->artificial_defs;\n+\t  while (def)\n+\t    def = df_reg_chain_unlink (dflow, def);\n+\t  bb_info->artificial_defs = NULL;\n+\t  use = bb_info->artificial_uses;\n+\t  while (use)\n+\t    use = df_reg_chain_unlink (dflow, use);\n+\t  bb_info->artificial_uses = NULL;\n+\t}\n+    }\n+}\n+\n+\n+/* Take build ref table for either the uses or defs from the reg-use\n+   or reg-def chains.  */ \n+\n+void \n+df_reorganize_refs (struct df_ref_info *ref_info)\n+{\n+  unsigned int m = ref_info->regs_inited;\n+  unsigned int regno;\n+  unsigned int offset = 0;\n+  unsigned int size = 0;\n+\n+  if (ref_info->refs_organized)\n+    return;\n+\n+  if (ref_info->refs_size < ref_info->bitmap_size)\n+    {  \n+      int new_size = ref_info->bitmap_size + ref_info->bitmap_size / 4;\n+      df_grow_ref_info (ref_info, new_size);\n+    }\n+\n+  for (regno = 0; regno < m; regno++)\n+    {\n+      struct df_reg_info *reg_info = ref_info->regs[regno];\n+      int count = 0;\n+      if (reg_info)\n+\t{\n+\t  struct df_ref *ref = reg_info->reg_chain;\n+\t  reg_info->begin = offset;\n+\t  while (ref) \n+\t    {\n+\t      ref_info->refs[offset] = ref;\n+\t      DF_REF_ID (ref) = offset++;\n+\t      ref = DF_REF_NEXT_REG (ref);\n+\t      count++;\n+\t      size++;\n+\t    }\n+\t  reg_info->n_refs = count;\n+\t}\n+    }\n+\n+  /* The bitmap size is not decremented when refs are deleted.  So\n+     reset it now that we have squished out all of the empty\n+     slots.  */\n+  ref_info->bitmap_size = size;\n+  ref_info->refs_organized = true;\n+  ref_info->add_refs_inline = true;\n+}\n+\n+\f\n+/* Local miscellaneous routines.  */\n+\n+/* Local routines for recording refs.  */\n+\n+/* Set where we are in the compilation.  */\n+\n+void \n+df_set_state (int state)\n+{\n+  df_state = state;\n+}\n+\n+\n+\f\n+/*----------------------------------------------------------------------------\n+   Hard core instruction scanning code.  No external interfaces here,\n+   just a lot of routines that look inside insns.\n+----------------------------------------------------------------------------*/\n+\n+/* Create a ref and add it to the reg-def or reg-use chains.  */\n+\n+static struct df_ref *\n+df_ref_create_structure (struct dataflow *dflow, rtx reg, rtx *loc,\n+\t\t\t basic_block bb, rtx insn, \n+\t\t\t enum df_ref_type ref_type, \n+\t\t\t enum df_ref_flags ref_flags)\n+{\n+  struct df_ref *this_ref;\n+  struct df *df = dflow->df;\n+  int regno = REGNO (GET_CODE (reg) == SUBREG ? SUBREG_REG (reg) : reg);\n+  struct df_scan_problem_data *problem_data =\n+    (struct df_scan_problem_data *) dflow->problem_data;\n+\n+  this_ref = pool_alloc (problem_data->ref_pool);\n+  DF_REF_REG (this_ref) = reg;\n+  DF_REF_REGNO (this_ref) =  regno;\n+  DF_REF_LOC (this_ref) = loc;\n+  DF_REF_INSN (this_ref) = insn;\n+  DF_REF_CHAIN (this_ref) = NULL;\n+  DF_REF_TYPE (this_ref) = ref_type;\n+  DF_REF_FLAGS (this_ref) = ref_flags;\n+  DF_REF_DATA (this_ref) = NULL;\n+  DF_REF_BB (this_ref) = bb;\n+\n+  /* Link the ref into the reg_def and reg_use chains and keep a count\n+     of the instances.  */\n+  if (ref_type == DF_REF_REG_DEF)\n+    {\n+      struct df_reg_info *reg_info = DF_REG_DEF_GET (df, regno);\n+      reg_info->n_refs++;\n+\n+      /* Add the ref to the reg_def chain.  */\n+      df_reg_chain_create (reg_info, this_ref);\n+      DF_REF_ID (this_ref) = df->def_info.bitmap_size;\n+      if (df->def_info.add_refs_inline)\n+\t{\n+\t  if (DF_DEFS_SIZE (df) >= df->def_info.refs_size)\n+\t    {\n+\t      int new_size = df->def_info.bitmap_size \n+\t\t+ df->def_info.bitmap_size / 4;\n+\t      df_grow_ref_info (&df->def_info, new_size);\n+\t    }\n+\t  /* Add the ref to the big array of defs.  */\n+\t  DF_DEFS_SET (df, df->def_info.bitmap_size, this_ref);\n+\t  df->def_info.refs_organized = false;\n+\t}\n+\n+      df->def_info.bitmap_size++;\n+\n+      if (DF_REF_FLAGS (this_ref) & DF_REF_ARTIFICIAL)\n+\t{\n+\t  struct df_scan_bb_info *bb_info \n+\t    = df_scan_get_bb_info (dflow, bb->index);\n+\t  this_ref->next_ref = bb_info->artificial_defs;\n+\t  bb_info->artificial_defs = this_ref;\n+\t}\n+      else\n+\t{\n+\t  this_ref->next_ref = DF_INSN_GET (df, insn)->defs;\n+\t  DF_INSN_GET (df, insn)->defs = this_ref;\n+\t}\n+    }\n+  else\n+    {\n+      struct df_reg_info *reg_info = DF_REG_USE_GET (df, regno);\n+      reg_info->n_refs++;\n+\n+      /* Add the ref to the reg_use chain.  */\n+      df_reg_chain_create (reg_info, this_ref);\n+      DF_REF_ID (this_ref) = df->use_info.bitmap_size;\n+      if (df->use_info.add_refs_inline)\n+\t{\n+\t  if (DF_USES_SIZE (df) >= df->use_info.refs_size)\n+\t    {\n+\t      int new_size = df->use_info.bitmap_size \n+\t\t+ df->use_info.bitmap_size / 4;\n+\t      df_grow_ref_info (&df->use_info, new_size);\n+\t    }\n+\t  /* Add the ref to the big array of defs.  */\n+\t  DF_USES_SET (df, df->use_info.bitmap_size, this_ref);\n+\t  df->use_info.refs_organized = false;\n+\t}\n+\n+      df->use_info.bitmap_size++;\n+      if (DF_REF_FLAGS (this_ref) & DF_REF_ARTIFICIAL)\n+\t{\n+\t  struct df_scan_bb_info *bb_info \n+\t    = df_scan_get_bb_info (dflow, bb->index);\n+\t  this_ref->next_ref = bb_info->artificial_uses;\n+\t  bb_info->artificial_uses = this_ref;\n+\t}\n+      else\n+\t{\n+\t  this_ref->next_ref = DF_INSN_GET (df, insn)->uses;\n+\t  DF_INSN_GET (df, insn)->uses = this_ref;\n+\t}\n+    }\n+  return this_ref;\n+}\n+\n+\n+/* Create new references of type DF_REF_TYPE for each part of register REG\n+   at address LOC within INSN of BB.  */\n+\n+static void\n+df_ref_record (struct dataflow *dflow, rtx reg, rtx *loc, \n+\t       basic_block bb, rtx insn, \n+\t       enum df_ref_type ref_type, \n+\t       enum df_ref_flags ref_flags, \n+\t       bool record_live)\n+{\n+  unsigned int regno;\n+  struct df *df = dflow->df;\n+\n+  gcc_assert (REG_P (reg) || GET_CODE (reg) == SUBREG);\n+\n+  /* For the reg allocator we are interested in some SUBREG rtx's, but not\n+     all.  Notably only those representing a word extraction from a multi-word\n+     reg.  As written in the docu those should have the form\n+     (subreg:SI (reg:M A) N), with size(SImode) > size(Mmode).\n+     XXX Is that true?  We could also use the global word_mode variable.  */\n+  if ((df->flags & DF_SUBREGS) == 0\n+      && GET_CODE (reg) == SUBREG\n+      && (GET_MODE_SIZE (GET_MODE (reg)) < GET_MODE_SIZE (word_mode)\n+\t  || GET_MODE_SIZE (GET_MODE (reg))\n+\t       >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (reg)))))\n+    {\n+      loc = &SUBREG_REG (reg);\n+      reg = *loc;\n+      ref_flags |= DF_REF_STRIPPED;\n+    }\n+\n+  regno = REGNO (GET_CODE (reg) == SUBREG ? SUBREG_REG (reg) : reg);\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    {\n+      int i;\n+      int endregno;\n+\n+      if (! (df->flags & DF_HARD_REGS))\n+\treturn;\n+\n+      /* GET_MODE (reg) is correct here.  We do not want to go into a SUBREG\n+         for the mode, because we only want to add references to regs, which\n+\t are really referenced.  E.g., a (subreg:SI (reg:DI 0) 0) does _not_\n+\t reference the whole reg 0 in DI mode (which would also include\n+\t reg 1, at least, if 0 and 1 are SImode registers).  */\n+      endregno = hard_regno_nregs[regno][GET_MODE (reg)];\n+      if (GET_CODE (reg) == SUBREG)\n+        regno += subreg_regno_offset (regno, GET_MODE (SUBREG_REG (reg)),\n+\t\t\t\t      SUBREG_BYTE (reg), GET_MODE (reg));\n+      endregno += regno;\n+\n+      for (i = regno; i < endregno; i++)\n+\t{\n+\t  /* Calls are handled at call site because regs_ever_live\n+\t     doesn't include clobbered regs, only used ones.  */\n+\t  if (ref_type == DF_REF_REG_DEF && record_live)\n+\t    regs_ever_live[i] = 1;\n+\t  else if ((ref_type == DF_REF_REG_USE \n+\t\t   || ref_type == DF_REF_REG_MEM_STORE\n+\t\t   || ref_type == DF_REF_REG_MEM_LOAD)\n+\t\t   && ((ref_flags & DF_REF_ARTIFICIAL) == 0))\n+\t    {\n+\t      /* Set regs_ever_live on uses of non-eliminable frame\n+\t\t pointers and arg pointers.  */\n+\t      if (! (TEST_HARD_REG_BIT (elim_reg_set, regno)\n+\t\t     && (regno == FRAME_POINTER_REGNUM \n+\t\t\t || regno == ARG_POINTER_REGNUM)))\n+\t\tregs_ever_live[i] = 1;\n+\t    }\n+\n+\t  df_ref_create_structure (dflow, regno_reg_rtx[i], loc, \n+\t\t\t\t   bb, insn, ref_type, ref_flags);\n+\t}\n+    }\n+  else\n+    {\n+      df_ref_create_structure (dflow, reg, loc, \n+\t\t\t       bb, insn, ref_type, ref_flags);\n+    }\n+}\n+\n+\n+/* A set to a non-paradoxical SUBREG for which the number of word_mode units\n+   covered by the outer mode is smaller than that covered by the inner mode,\n+   is a read-modify-write operation.\n+   This function returns true iff the SUBREG X is such a SUBREG.  */\n+\n+bool\n+df_read_modify_subreg_p (rtx x)\n+{\n+  unsigned int isize, osize;\n+  if (GET_CODE (x) != SUBREG)\n+    return false;\n+  isize = GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)));\n+  osize = GET_MODE_SIZE (GET_MODE (x));\n+  return (isize > osize && isize > UNITS_PER_WORD);\n+}\n+\n+\n+/* Process all the registers defined in the rtx, X.\n+   Autoincrement/decrement definitions will be picked up by\n+   df_uses_record.  */\n+\n+static void\n+df_def_record_1 (struct dataflow *dflow, rtx x, \n+\t\t basic_block bb, rtx insn, \n+\t\t enum df_ref_flags flags, bool record_live)\n+{\n+  rtx *loc;\n+  rtx dst;\n+\n+ /* We may recursively call ourselves on EXPR_LIST when dealing with PARALLEL\n+     construct.  */\n+  if (GET_CODE (x) == EXPR_LIST || GET_CODE (x) == CLOBBER)\n+    loc = &XEXP (x, 0);\n+  else\n+    loc = &SET_DEST (x);\n+  dst = *loc;\n+\n+  /* Some targets place small structures in registers for\n+     return values of functions.  */\n+  if (GET_CODE (dst) == PARALLEL && GET_MODE (dst) == BLKmode)\n+    {\n+      int i;\n+\n+      for (i = XVECLEN (dst, 0) - 1; i >= 0; i--)\n+\t{\n+\t  rtx temp = XVECEXP (dst, 0, i);\n+\t  if (GET_CODE (temp) == EXPR_LIST || GET_CODE (temp) == CLOBBER\n+\t      || GET_CODE (temp) == SET)\n+\t    df_def_record_1 (dflow, temp, bb, insn, \n+\t\t\t     GET_CODE (temp) == CLOBBER ? flags | DF_REF_CLOBBER : flags, \n+\t\t\t     record_live);\n+\t}\n+      return;\n+    }\n+\n+  /* Maybe, we should flag the use of STRICT_LOW_PART somehow.  It might\n+     be handy for the reg allocator.  */\n+  while (GET_CODE (dst) == STRICT_LOW_PART\n+\t || GET_CODE (dst) == ZERO_EXTRACT\n+\t || df_read_modify_subreg_p (dst))\n+    {\n+#if 0\n+      /* Strict low part always contains SUBREG, but we do not want to make\n+\t it appear outside, as whole register is always considered.  */\n+      if (GET_CODE (dst) == STRICT_LOW_PART)\n+\t{\n+\t  loc = &XEXP (dst, 0);\n+\t  dst = *loc;\n+\t}\n+#endif\n+      loc = &XEXP (dst, 0);\n+      dst = *loc;\n+      flags |= DF_REF_READ_WRITE;\n+    }\n+\n+  if (REG_P (dst)\n+      || (GET_CODE (dst) == SUBREG && REG_P (SUBREG_REG (dst))))\n+    df_ref_record (dflow, dst, loc, bb, insn, \n+\t\t   DF_REF_REG_DEF, flags, record_live);\n+}\n+\n+\n+/* Process all the registers defined in the pattern rtx, X.  */\n+\n+static void\n+df_defs_record (struct dataflow *dflow, rtx x, basic_block bb, rtx insn)\n+{\n+  RTX_CODE code = GET_CODE (x);\n+\n+  if (code == SET || code == CLOBBER)\n+    {\n+      /* Mark the single def within the pattern.  */\n+      df_def_record_1 (dflow, x, bb, insn, \n+\t\t       code == CLOBBER ? DF_REF_CLOBBER : 0, true);\n+    }\n+  else if (code == COND_EXEC)\n+    {\n+      df_defs_record  (dflow, COND_EXEC_CODE (x), bb, insn);\n+    }\n+  else if (code == PARALLEL)\n+    {\n+      int i;\n+\n+      /* Mark the multiple defs within the pattern.  */\n+      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n+\t df_defs_record (dflow, XVECEXP (x, 0, i), bb, insn);\n+    }\n+}\n+\n+\n+/* Process all the registers used in the rtx at address LOC.  */\n+\n+static void\n+df_uses_record (struct dataflow *dflow, rtx *loc, enum df_ref_type ref_type,\n+\t\tbasic_block bb, rtx insn, enum df_ref_flags flags)\n+{\n+  RTX_CODE code;\n+  rtx x;\n+ retry:\n+  x = *loc;\n+  if (!x)\n+    return;\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_INT:\n+    case CONST:\n+    case CONST_DOUBLE:\n+    case CONST_VECTOR:\n+    case PC:\n+    case CC0:\n+    case ADDR_VEC:\n+    case ADDR_DIFF_VEC:\n+      return;\n+\n+    case CLOBBER:\n+      /* If we are clobbering a MEM, mark any registers inside the address\n+\t as being used.  */\n+      if (MEM_P (XEXP (x, 0)))\n+\tdf_uses_record (dflow, &XEXP (XEXP (x, 0), 0),\n+\t\t\tDF_REF_REG_MEM_STORE, bb, insn, flags);\n+\n+      /* If we're clobbering a REG then we have a def so ignore.  */\n+      return;\n+\n+    case MEM:\n+      df_uses_record (dflow, &XEXP (x, 0), DF_REF_REG_MEM_LOAD, bb, insn,\n+\t\t      flags & DF_REF_IN_NOTE);\n+      return;\n+\n+    case SUBREG:\n+      /* While we're here, optimize this case.  */\n+\n+      /* In case the SUBREG is not of a REG, do not optimize.  */\n+      if (!REG_P (SUBREG_REG (x)))\n+\t{\n+\t  loc = &SUBREG_REG (x);\n+\t  df_uses_record (dflow, loc, ref_type, bb, insn, flags);\n+\t  return;\n+\t}\n+      /* ... Fall through ...  */\n+\n+    case REG:\n+      df_ref_record (dflow, x, loc, bb, insn, ref_type, flags, true);\n+      return;\n+\n+    case SET:\n+      {\n+\trtx dst = SET_DEST (x);\n+\tgcc_assert (!(flags & DF_REF_IN_NOTE));\n+\tdf_uses_record (dflow, &SET_SRC (x), DF_REF_REG_USE, bb, insn, 0);\n+\n+\tswitch (GET_CODE (dst))\n+\t  {\n+\t    case SUBREG:\n+\t      if (df_read_modify_subreg_p (dst))\n+\t\t{\n+\t\t  df_uses_record (dflow, &SUBREG_REG (dst), \n+\t\t\t\t  DF_REF_REG_USE, bb,\n+\t\t\t\t  insn, DF_REF_READ_WRITE);\n+\t\t  break;\n+\t\t}\n+\t      /* Fall through.  */\n+\t    case REG:\n+\t    case PARALLEL:\n+\t    case SCRATCH:\n+\t    case PC:\n+\t    case CC0:\n+\t\tbreak;\n+\t    case MEM:\n+\t      df_uses_record (dflow, &XEXP (dst, 0),\n+\t\t\t      DF_REF_REG_MEM_STORE,\n+\t\t\t      bb, insn, 0);\n+\t      break;\n+\t    case STRICT_LOW_PART:\n+\t      {\n+\t\trtx *temp = &XEXP (dst, 0);\n+\t\t/* A strict_low_part uses the whole REG and not just the\n+\t\t SUBREG.  */\n+\t\tdst = XEXP (dst, 0);\n+\t\tdf_uses_record (dflow, \n+\t\t\t\t(GET_CODE (dst) == SUBREG) \n+\t\t\t\t? &SUBREG_REG (dst) : temp, \n+\t\t\t\tDF_REF_REG_USE, bb,\n+\t\t\t\tinsn, DF_REF_READ_WRITE);\n+\t      }\n+\t      break;\n+\t    case ZERO_EXTRACT:\n+\t    case SIGN_EXTRACT:\n+\t      df_uses_record (dflow, &XEXP (dst, 0), \n+\t\t\t      DF_REF_REG_USE, bb, insn,\n+\t\t\t      DF_REF_READ_WRITE);\n+\t      df_uses_record (dflow, &XEXP (dst, 1), \n+\t\t\t      DF_REF_REG_USE, bb, insn, 0);\n+\t      df_uses_record (dflow, &XEXP (dst, 2), \n+\t\t\t      DF_REF_REG_USE, bb, insn, 0);\n+\t      dst = XEXP (dst, 0);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t  }\n+\treturn;\n+      }\n+\n+    case RETURN:\n+      break;\n+\n+    case ASM_OPERANDS:\n+    case UNSPEC_VOLATILE:\n+    case TRAP_IF:\n+    case ASM_INPUT:\n+      {\n+\t/* Traditional and volatile asm instructions must be\n+\t   considered to use and clobber all hard registers, all\n+\t   pseudo-registers and all of memory.  So must TRAP_IF and\n+\t   UNSPEC_VOLATILE operations.\n+\n+\t   Consider for instance a volatile asm that changes the fpu\n+\t   rounding mode.  An insn should not be moved across this\n+\t   even if it only uses pseudo-regs because it might give an\n+\t   incorrectly rounded result.\n+\n+\t   However, flow.c's liveness computation did *not* do this,\n+\t   giving the reasoning as \" ?!? Unfortunately, marking all\n+\t   hard registers as live causes massive problems for the\n+\t   register allocator and marking all pseudos as live creates\n+\t   mountains of uninitialized variable warnings.\"\n+\n+\t   In order to maintain the status quo with regard to liveness\n+\t   and uses, we do what flow.c did and just mark any regs we\n+\t   can find in ASM_OPERANDS as used.  Later on, when liveness\n+\t   is computed, asm insns are scanned and regs_asm_clobbered\n+\t   is filled out.  \n+\n+\t   For all ASM_OPERANDS, we must traverse the vector of input\n+\t   operands.  We can not just fall through here since then we\n+\t   would be confused by the ASM_INPUT rtx inside ASM_OPERANDS,\n+\t   which do not indicate traditional asms unlike their normal\n+\t   usage.  */\n+\tif (code == ASM_OPERANDS)\n+\t  {\n+\t    int j;\n+\n+\t    for (j = 0; j < ASM_OPERANDS_INPUT_LENGTH (x); j++)\n+\t      df_uses_record (dflow, &ASM_OPERANDS_INPUT (x, j),\n+\t\t\t      DF_REF_REG_USE, bb, insn, 0);\n+\t    return;\n+\t  }\n+\tbreak;\n+      }\n+\n+    case PRE_DEC:\n+    case POST_DEC:\n+    case PRE_INC:\n+    case POST_INC:\n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n+      /* Catch the def of the register being modified.  */\n+      df_ref_record (dflow, XEXP (x, 0), &XEXP (x, 0), bb, insn, \n+\t\t     DF_REF_REG_DEF, DF_REF_READ_WRITE, true);\n+\n+      /* ... Fall through to handle uses ...  */\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Recursively scan the operands of this expression.  */\n+  {\n+    const char *fmt = GET_RTX_FORMAT (code);\n+    int i;\n+\n+    for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+      {\n+\tif (fmt[i] == 'e')\n+\t  {\n+\t    /* Tail recursive case: save a function call level.  */\n+\t    if (i == 0)\n+\t      {\n+\t\tloc = &XEXP (x, 0);\n+\t\tgoto retry;\n+\t      }\n+\t    df_uses_record (dflow, &XEXP (x, i), ref_type, bb, insn, flags);\n+\t  }\n+\telse if (fmt[i] == 'E')\n+\t  {\n+\t    int j;\n+\t    for (j = 0; j < XVECLEN (x, i); j++)\n+\t      df_uses_record (dflow, &XVECEXP (x, i, j), ref_type,\n+\t\t\t      bb, insn, flags);\n+\t  }\n+      }\n+  }\n+}\n+\n+/* Return true if *LOC contains an asm.  */\n+\n+static int\n+df_insn_contains_asm_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n+{\n+  if ( !*loc)\n+    return 0;\n+  if (GET_CODE (*loc) == ASM_OPERANDS)\n+    return 1;\n+  return 0;\n+}\n+\n+\n+/* Return true if INSN contains an ASM.  */\n+\n+static int\n+df_insn_contains_asm (rtx insn)\n+{\n+  return for_each_rtx (&insn, df_insn_contains_asm_1, NULL);\n+}\n+\n+\n+\n+/* Record all the refs for DF within INSN of basic block BB.  */\n+\n+static void\n+df_insn_refs_record (struct dataflow *dflow, basic_block bb, rtx insn)\n+{\n+  int i;\n+  struct df *df = dflow->df;\n+\n+  if (INSN_P (insn))\n+    {\n+      rtx note;\n+\n+      if (df_insn_contains_asm (insn))\n+\tDF_INSN_CONTAINS_ASM (df, insn) = true;\n+      \n+      /* Record register defs.  */\n+      df_defs_record (dflow, PATTERN (insn), bb, insn);\n+\n+      if (df->flags & DF_EQUIV_NOTES)\n+\tfor (note = REG_NOTES (insn); note;\n+\t     note = XEXP (note, 1))\n+\t  {\n+\t    switch (REG_NOTE_KIND (note))\n+\t      {\n+\t      case REG_EQUIV:\n+\t      case REG_EQUAL:\n+\t\tdf_uses_record (dflow, &XEXP (note, 0), DF_REF_REG_USE,\n+\t\t\t\tbb, insn, DF_REF_IN_NOTE);\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t  }\n+\n+      if (CALL_P (insn))\n+\t{\n+\t  rtx note;\n+\n+\t  /* Record the registers used to pass arguments, and explicitly\n+\t     noted as clobbered.  */\n+\t  for (note = CALL_INSN_FUNCTION_USAGE (insn); note;\n+\t       note = XEXP (note, 1))\n+\t    {\n+\t      if (GET_CODE (XEXP (note, 0)) == USE)\n+\t\tdf_uses_record (dflow, &XEXP (XEXP (note, 0), 0), \n+\t\t\t\tDF_REF_REG_USE,\n+\t\t\t\tbb, insn, 0);\n+              else if (GET_CODE (XEXP (note, 0)) == CLOBBER)\n+\t\t{\n+\t\t  df_defs_record (dflow, XEXP (note, 0), bb, insn);\n+\t\t  if (REG_P (XEXP (XEXP (note, 0), 0)))\n+\t\t    {\n+\t\t      rtx reg = XEXP (XEXP (note, 0), 0);\n+\t\t      int regno_last;\n+\t\t      int regno_first;\n+\t\t      int i;\n+\t\t\n+\t\t      regno_last = regno_first = REGNO (reg);\n+\t\t      if (regno_first < FIRST_PSEUDO_REGISTER)\n+\t\t\tregno_last \n+\t\t\t  += hard_regno_nregs[regno_first][GET_MODE (reg)] - 1;\n+\t\t      for (i = regno_first; i <= regno_last; i++)\n+\t\t\tregs_ever_live[i] = 1;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* The stack ptr is used (honorarily) by a CALL insn.  */\n+\t  df_uses_record (dflow, &regno_reg_rtx[STACK_POINTER_REGNUM],\n+\t\t\t  DF_REF_REG_USE, bb, insn, \n+\t\t\t  0);\n+\n+\t  if (df->flags & DF_HARD_REGS)\n+\t    {\n+\t      bitmap_iterator bi;\n+\t      unsigned int ui;\n+\t      /* Calls may also reference any of the global registers,\n+\t\t so they are recorded as used.  */\n+\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\tif (global_regs[i])\n+\t\t  df_uses_record (dflow, &regno_reg_rtx[i],\n+\t\t\t\t  DF_REF_REG_USE, bb, insn, \n+\t\t\t\t  0);\n+\t      EXECUTE_IF_SET_IN_BITMAP (df_invalidated_by_call, 0, ui, bi)\n+\t        df_ref_record (dflow, regno_reg_rtx[ui], &regno_reg_rtx[ui], bb, insn, \n+\t                       DF_REF_REG_DEF, DF_REF_CLOBBER, false);\n+\t    }\n+\t}\n+\n+      /* Record the register uses.  */\n+      df_uses_record (dflow, &PATTERN (insn),\n+\t\t      DF_REF_REG_USE, bb, insn, 0);\n+\n+    }\n+}\n+\n+static bool\n+df_has_eh_preds (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      if (e->flags & EDGE_EH)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Record all the refs within the basic block BB.  */\n+\n+static void\n+df_bb_refs_record (struct dataflow *dflow, basic_block bb)\n+{\n+  struct df *df = dflow->df;\n+  rtx insn;\n+  int luid = 0;\n+  struct df_scan_bb_info *bb_info = df_scan_get_bb_info (dflow, bb->index);\n+\n+  /* Need to make sure that there is a record in the basic block info. */  \n+  if (!bb_info)\n+    {\n+      bb_info = (struct df_scan_bb_info *) pool_alloc (dflow->block_pool);\n+      df_scan_set_bb_info (dflow, bb->index, bb_info);\n+      bb_info->artificial_defs = NULL;\n+      bb_info->artificial_uses = NULL;\n+    }\n+\n+  /* Scan the block an insn at a time from beginning to end.  */\n+  FOR_BB_INSNS (bb, insn)\n+    {\n+      df_insn_create_insn_record (dflow, insn);\n+      if (INSN_P (insn))\n+\t{\n+\t  /* Record defs within INSN.  */\n+\t  DF_INSN_LUID (df, insn) = luid++;\n+\t  df_insn_refs_record (dflow, bb, insn);\n+\t}\n+      DF_INSN_LUID (df, insn) = luid;\n+    }\n+\n+#ifdef EH_RETURN_DATA_REGNO\n+  if ((df->flags & DF_HARD_REGS)\n+      && df_has_eh_preds (bb))\n+    {\n+      unsigned int i;\n+      /* Mark the registers that will contain data for the handler.  */\n+      if (current_function_calls_eh_return)\n+\tfor (i = 0; ; ++i)\n+\t  {\n+\t    unsigned regno = EH_RETURN_DATA_REGNO (i);\n+\t    if (regno == INVALID_REGNUM)\n+\t      break;\n+\t    df_ref_record (dflow, regno_reg_rtx[i], &regno_reg_rtx[i], bb, NULL, \n+\t\t           DF_REF_REG_DEF, DF_REF_ARTIFICIAL | DF_REF_AT_TOP, false);\n+\t  }\n+    }\n+#endif\n+\n+#ifdef EH_USES\n+  /*  This code is putting in a artificial ref for the use at the TOP\n+      of the block that receives the exception.  It is too cumbersome\n+      to actually put the ref on the edge.  We could either model this\n+      at the top of the receiver block or the bottom of the sender\n+      block.\n+\n+      The bottom of the sender block is problematic because not all\n+      out-edges of the a block are eh-edges.  However, it is true that\n+      all edges into a block are either eh-edges or none of them are\n+      eh-edges.  Thus, we can model this at the top of the eh-receiver\n+      for all of the edges at once. */\n+  if ((df->flags & DF_HARD_REGS)\n+      && df_has_eh_preds (bb))\n+    {\n+      unsigned int i;\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (EH_USES (i))\n+\t  df_uses_record (dflow, &regno_reg_rtx[i], \n+\t\t\t\t   DF_REF_REG_USE, EXIT_BLOCK_PTR, NULL,\n+\t\t\t\t   DF_REF_ARTIFICIAL | DF_REF_AT_TOP);\n+    }\n+#endif\n+\n+  if ((df->flags & DF_HARD_REGS) \n+      && bb->index >= NUM_FIXED_BLOCKS)\n+    {\n+      /* Before reload, there are a few registers that must be forced\n+\t live everywhere -- which might not already be the case for\n+\t blocks within infinite loops.  */\n+      if (! reload_completed)\n+\t{\n+\t  \n+\t  /* Any reference to any pseudo before reload is a potential\n+\t     reference of the frame pointer.  */\n+\t  df_uses_record (dflow, &regno_reg_rtx [FRAME_POINTER_REGNUM],\n+\t\t\t  DF_REF_REG_USE, bb, NULL, DF_REF_ARTIFICIAL);\n+\t  \n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+\t  /* Pseudos with argument area equivalences may require\n+\t     reloading via the argument pointer.  */\n+\t  if (fixed_regs[ARG_POINTER_REGNUM])\n+\t    df_uses_record (dflow, &regno_reg_rtx[ARG_POINTER_REGNUM],\n+\t\t\t    DF_REF_REG_USE, bb, NULL, \n+\t\t\t    DF_REF_ARTIFICIAL);\n+#endif\n+\t  \n+\t  /* Any constant, or pseudo with constant equivalences, may\n+\t     require reloading from memory using the pic register.  */\n+\t  if ((unsigned) PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM\n+\t      && fixed_regs[PIC_OFFSET_TABLE_REGNUM])\n+\t    df_uses_record (dflow, &regno_reg_rtx[PIC_OFFSET_TABLE_REGNUM],\n+\t\t\t    DF_REF_REG_USE, bb, NULL, \n+\t\t\t    DF_REF_ARTIFICIAL);\n+\t}\n+      /* The all-important stack pointer must always be live.  */\n+      df_uses_record (dflow, &regno_reg_rtx[STACK_POINTER_REGNUM],\n+\t\t      DF_REF_REG_USE, bb, NULL, DF_REF_ARTIFICIAL);\n+    }\n+}\n+\n+\n+/* Record all the refs in the basic blocks specified by BLOCKS.  */\n+\n+static void\n+df_refs_record (struct dataflow *dflow, bitmap blocks)\n+{\n+  unsigned int bb_index;\n+  bitmap_iterator bi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, bb_index, bi)\n+    {\n+      basic_block bb = BASIC_BLOCK (bb_index);\n+      df_bb_refs_record (dflow, bb);\n+    }\n+\n+  if (bitmap_bit_p (blocks, EXIT_BLOCK))\n+    df_record_exit_block_uses (dflow);\n+}\n+\n+\n+/*----------------------------------------------------------------------------\n+   Specialized hard register scanning functions.\n+----------------------------------------------------------------------------*/\n+\n+/* Mark a register in SET.  Hard registers in large modes get all\n+   of their component registers set as well.  */\n+\n+static void\n+df_mark_reg (rtx reg, void *vset)\n+{\n+  bitmap set = (bitmap) vset;\n+  int regno = REGNO (reg);\n+\n+  gcc_assert (GET_MODE (reg) != BLKmode);\n+\n+  bitmap_set_bit (set, regno);\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    {\n+      int n = hard_regno_nregs[regno][GET_MODE (reg)];\n+      while (--n > 0)\n+\tbitmap_set_bit  (set, regno + n);\n+    }\n+}\n+\n+/* Record the set of hard registers that are used in the exit block.  */\n+\n+static void\n+df_record_exit_block_uses (struct dataflow *dflow)\n+{\n+  unsigned int i; \n+  bitmap_iterator bi;\n+  struct df *df = dflow->df;\n+\n+  bitmap_clear (df->exit_block_uses);\n+  \n+  if (! (df->flags & DF_HARD_REGS))\n+    return;\n+\n+  /* If exiting needs the right stack value, consider the stack\n+     pointer live at the end of the function.  */\n+  if ((HAVE_epilogue && epilogue_completed)\n+      || ! EXIT_IGNORE_STACK\n+      || (! FRAME_POINTER_REQUIRED\n+\t  && ! current_function_calls_alloca\n+\t  && flag_omit_frame_pointer)\n+      || current_function_sp_is_unchanging)\n+    {\n+      bitmap_set_bit (df->exit_block_uses, STACK_POINTER_REGNUM);\n+    }\n+  \n+  /* Mark the frame pointer if needed at the end of the function.\n+     If we end up eliminating it, it will be removed from the live\n+     list of each basic block by reload.  */\n+  \n+  if (! reload_completed || frame_pointer_needed)\n+    {\n+      bitmap_set_bit (df->exit_block_uses, FRAME_POINTER_REGNUM);\n+#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n+      /* If they are different, also mark the hard frame pointer as live.  */\n+      if (! LOCAL_REGNO (HARD_FRAME_POINTER_REGNUM))\n+\tbitmap_set_bit (df->exit_block_uses, HARD_FRAME_POINTER_REGNUM);\n+#endif\n+    }\n+\n+#ifndef PIC_OFFSET_TABLE_REG_CALL_CLOBBERED\n+  /* Many architectures have a GP register even without flag_pic.\n+     Assume the pic register is not in use, or will be handled by\n+     other means, if it is not fixed.  */\n+  if ((unsigned) PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM\n+      && fixed_regs[PIC_OFFSET_TABLE_REGNUM])\n+    bitmap_set_bit (df->exit_block_uses, PIC_OFFSET_TABLE_REGNUM);\n+#endif\n+  \n+  /* Mark all global registers, and all registers used by the\n+     epilogue as being live at the end of the function since they\n+     may be referenced by our caller.  */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (global_regs[i] || EPILOGUE_USES (i))\n+      bitmap_set_bit (df->exit_block_uses, i);\n+  \n+  if (HAVE_epilogue && epilogue_completed)\n+    {\n+      /* Mark all call-saved registers that we actually used.  */\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (regs_ever_live[i] && ! LOCAL_REGNO (i)\n+\t    && ! TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n+\t  bitmap_set_bit (df->exit_block_uses, i);\n+    }\n+  \n+#ifdef EH_RETURN_DATA_REGNO\n+  /* Mark the registers that will contain data for the handler.  */\n+  if (reload_completed && current_function_calls_eh_return)\n+    for (i = 0; ; ++i)\n+      {\n+\tunsigned regno = EH_RETURN_DATA_REGNO (i);\n+\tif (regno == INVALID_REGNUM)\n+\t  break;\n+\tbitmap_set_bit (df->exit_block_uses, regno);\n+      }\n+#endif\n+\n+#ifdef EH_RETURN_STACKADJ_RTX\n+  if ((! HAVE_epilogue || ! epilogue_completed)\n+      && current_function_calls_eh_return)\n+    {\n+      rtx tmp = EH_RETURN_STACKADJ_RTX;\n+      if (tmp && REG_P (tmp))\n+\tdf_mark_reg (tmp, df->exit_block_uses);\n+    }\n+#endif\n+\n+#ifdef EH_RETURN_HANDLER_RTX\n+  if ((! HAVE_epilogue || ! epilogue_completed)\n+      && current_function_calls_eh_return)\n+    {\n+      rtx tmp = EH_RETURN_HANDLER_RTX;\n+      if (tmp && REG_P (tmp))\n+\tdf_mark_reg (tmp, df->exit_block_uses);\n+    }\n+#endif \n+  \n+  /* Mark function return value.  */\n+  diddle_return_value (df_mark_reg, (void*) df->exit_block_uses);\n+\n+  if (df->flags & DF_HARD_REGS)\n+    EXECUTE_IF_SET_IN_BITMAP (df->exit_block_uses, 0, i, bi)\n+      df_uses_record (dflow, &regno_reg_rtx[i], \n+  \t\t      DF_REF_REG_USE, EXIT_BLOCK_PTR, NULL,\n+\t\t      DF_REF_ARTIFICIAL);\n+}\n+\n+static bool initialized = false;\n+\n+/* Initialize some platform specific structures.  */\n+\n+void \n+df_hard_reg_init (void)\n+{\n+#ifdef ELIMINABLE_REGS\n+  int i;\n+  static const struct {const int from, to; } eliminables[] = ELIMINABLE_REGS;\n+#endif\n+  /* After reload, some ports add certain bits to regs_ever_live so\n+     this cannot be reset.  */\n+  \n+  if (!reload_completed)\n+    memset (regs_ever_live, 0, sizeof (regs_ever_live));\n+\n+  if (initialized)\n+    return;\n+\n+  bitmap_obstack_initialize (&persistent_obstack);\n+\n+  /* Record which registers will be eliminated.  We use this in\n+     mark_used_regs.  */\n+  CLEAR_HARD_REG_SET (elim_reg_set);\n+  \n+#ifdef ELIMINABLE_REGS\n+  for (i = 0; i < (int) ARRAY_SIZE (eliminables); i++)\n+    SET_HARD_REG_BIT (elim_reg_set, eliminables[i].from);\n+#else\n+  SET_HARD_REG_BIT (elim_reg_set, FRAME_POINTER_REGNUM);\n+#endif\n+  \n+  df_invalidated_by_call = BITMAP_ALLOC (&persistent_obstack);\n+  \n+  /* Inconveniently, this is only readily available in hard reg set\n+     form.  */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+    if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n+      bitmap_set_bit (df_invalidated_by_call, i);\n+  \n+  df_all_hard_regs = BITMAP_ALLOC (&persistent_obstack);\n+  \n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    bitmap_set_bit (df_all_hard_regs, i);\n+  \n+  initialized = true;\n+}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/df.c", "status": "modified", "additions": 0, "deletions": 3975, "changes": 3975, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=4d779342f00ac9b678043e8a2e474a1ae14b8660"}, {"sha": "09a112762bf6abcd2780107afeb545fd9d2b5e17", "filename": "gcc/df.h", "status": "modified", "additions": 440, "deletions": 230, "changes": 670, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=4d779342f00ac9b678043e8a2e474a1ae14b8660", "patch": "@@ -1,8 +1,11 @@\n /* Form lists of pseudo register references for autoinc optimization\n    for GNU compiler.  This is part of flow optimization.\n-   Copyright (C) 1999, 2000, 2001, 2003, 2004, 2005\n+   Copyright (C) 1999, 2000, 2001, 2003, 2004, 2005, 2006\n    Free Software Foundation, Inc.\n-   Contributed by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)\n+   Originally contributed by Michael P. Hayes \n+             (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)\n+   Major rewrite contributed by Danny Berlin (dberlin@dberlin.org)\n+             and Kenneth Zadeck (zadeck@naturalbridge.com).\n \n This file is part of GCC.\n \n@@ -26,32 +29,152 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bitmap.h\"\n #include \"basic-block.h\"\n+#include \"alloc-pool.h\"\n+\n+struct dataflow;\n+struct df;\n+struct df_problem;\n+\n+/* Data flow problems.  All problems must have a unique here.  */ \n+/* Scanning is not really a dataflow problem, but it is useful to have\n+   the basic block functions in the vector so that things get done in\n+   a uniform manner.  */\n+#define DF_SCAN  0 \n+#define DF_RU    1      /* Reaching Uses. */\n+#define DF_RD    2      /* Reaching Defs. */\n+#define DF_LR    3      /* Live Registers. */\n+#define DF_UR    4      /* Uninitialized Registers. */\n+#define DF_UREC  5      /* Uninitialized Registers with Early Clobber. */\n+#define DF_CHAIN 6      /* Def-Use and/or Use-Def Chains. */\n+#define DF_RI    7      /* Register Info. */\n+#define DF_LAST_PROBLEM_PLUS1 (DF_RI + 1)\n+\n+/* Flags that control the building of chains.  */\n+#define DF_DU_CHAIN   1    /* Build DU chains.  */  \n+#define DF_UD_CHAIN   2    /* Build UD chains.  */\n \n-#define DF_RD\t\t1\t/* Reaching definitions.  */\n-#define DF_RU\t\t2\t/* Reaching uses.  */\n-#define DF_LR\t\t4\t/* Live registers.  */\n-#define DF_DU_CHAIN\t8\t/* Def-use chain.  */\n-#define DF_UD_CHAIN\t16\t/* Use-def chain.  */\n-#define DF_REG_INFO\t32\t/* Register info.  */\n-#define DF_RD_CHAIN\t64\t/* Reg-def chain.  */\n-#define DF_RU_CHAIN\t128\t/* Reg-use chain.  */\n-#define DF_ALL\t\t255\n-#define DF_HARD_REGS\t1024\t/* Mark hard registers.  */\n-#define DF_EQUIV_NOTES\t2048\t/* Mark uses present in EQUIV/EQUAL notes.  */\n-#define DF_SUBREGS\t4096\t/* Return subregs rather than the inner reg.  */\n \n-enum df_ref_type {DF_REF_REG_DEF, DF_REF_REG_USE, DF_REF_REG_MEM_LOAD,\n-\t\t  DF_REF_REG_MEM_STORE};\n+/* Dataflow direction.  */\n+enum df_flow_dir\n+  {\n+    DF_NONE,\n+    DF_FORWARD,\n+    DF_BACKWARD\n+  };\n \n-#define DF_REF_TYPE_NAMES {\"def\", \"use\", \"mem load\", \"mem store\"}\n+/* Function prototypes added to df_problem instance.  */\n \n-/* Link on a def-use or use-def chain.  */\n-struct df_link\n+/* Allocate the problem specific data.  */\n+typedef void (*df_alloc_function) (struct dataflow *, bitmap);\n+\n+/* Free the basic block info.  Called from the block reordering code\n+   to get rid of the blocks that have been squished down.   */\n+typedef void (*df_free_bb_function) (struct dataflow *, void *);\n+\n+/* Local compute function.  */\n+typedef void (*df_local_compute_function) (struct dataflow *, bitmap, bitmap);\n+\n+/* Init the solution specific data.  */\n+typedef void (*df_init_function) (struct dataflow *, bitmap);\n+\n+/* Iterative dataflow function.  */\n+typedef void (*df_dataflow_function) (struct dataflow *, bitmap, bitmap, \n+\t\t\t\t   int *, int, bool);\n+\n+/* Confluence operator for blocks with 0 out (or in) edges.  */\n+typedef void (*df_confluence_function_0) (struct dataflow *, basic_block);\n+\n+/* Confluence operator for blocks with 1 or more out (or in) edges.  */\n+typedef void (*df_confluence_function_n) (struct dataflow *, edge);\n+\n+/* Transfer function for blocks.  */\n+typedef bool (*df_transfer_function) (struct dataflow *, int);\n+\n+/* Function to massage the information after the problem solving.  */\n+typedef void (*df_finalizer_function) (struct dataflow*, bitmap);\n+\n+/* Function to free all of the problem specific datastructures.  */\n+typedef void (*df_free_function) (struct dataflow *);\n+\n+/* Function to dump results to FILE.  */\n+typedef void (*df_dump_problem_function) (struct dataflow *, FILE *);\n+\n+/* The static description of a dataflow problem to solve.  See above\n+   typedefs for doc for the function fields.  */\n+\n+struct df_problem {\n+  /* The unique id of the problem.  This is used it index into\n+     df->defined_problems to make accessing the problem data easy.  */\n+  unsigned int id;                        \n+  enum df_flow_dir dir;\t\t\t/* Dataflow direction.  */\n+  df_alloc_function alloc_fun;\n+  df_free_bb_function free_bb_fun;\n+  df_local_compute_function local_compute_fun;\n+  df_init_function init_fun;\n+  df_dataflow_function dataflow_fun;\n+  df_confluence_function_0 con_fun_0;\n+  df_confluence_function_n con_fun_n;\n+  df_transfer_function trans_fun;\n+  df_finalizer_function finalize_fun;\n+  df_free_function free_fun;\n+  df_dump_problem_function dump_fun;\n+\n+  /* A dataflow problem that must be solved before this problem can be\n+     solved.  */\n+  struct df_problem *dependent_problem;\n+};\n+\n+\n+/* The specific instance of the problem to solve.  */\n+struct dataflow\n {\n-  struct df_link *next;\n-  struct ref *ref;\n+  struct df *df;                        /* Instance of df we are working in.  */\n+  struct df_problem *problem;           /* The problem to be solved.  */\n+\n+  /* Communication between iterative_dataflow and hybrid_search. */\n+  sbitmap visited, pending, considered; \n+\n+  /* Array indexed by bb->index, that contains basic block problem and\n+     solution specific information.  */\n+  void **block_info;\n+  unsigned int block_info_size;\n+\n+  /* The pool to allocate the block_info from. */\n+  alloc_pool block_pool;                \n+\n+  /* Other problem specific data that is not on a per basic block\n+     basis.  The structure is generally defined privately for the\n+     problem.  The exception being the scanning problem where it is\n+     fully public.  */\n+  void *problem_data;                  \n };\n \n+/* One of these structures is allocated for every insn.  */\n+struct df_insn_info\n+{\n+  struct df_ref *defs;\t        /* Head of insn-def chain.  */\n+  struct df_ref *uses;\t        /* Head of insn-use chain.  */\n+  /* ???? The following luid field should be considered private so that\n+     we can change it on the fly to accommodate new insns?  */\n+  int luid;\t\t\t/* Logical UID.  */\n+  bool contains_asm;            /* Contains an asm instruction.  */\n+};\n+\n+/* Two of these structures are allocated for every pseudo reg, one for\n+   the uses and one for the defs.  */\n+struct df_reg_info\n+{\n+  struct df_ref *reg_chain;     /* Head of reg-use or def chain.  */\n+  unsigned int begin;           /* First def_index for this pseudo.  */\n+  unsigned int n_refs;          /* Number of refs or defs for this pseudo.  */\n+};\n+\n+\n+enum df_ref_type {DF_REF_REG_DEF, DF_REF_REG_USE, DF_REF_REG_MEM_LOAD,\n+\t\t  DF_REF_REG_MEM_STORE};\n+\n+#define DF_REF_TYPE_NAMES {\"def\", \"use\", \"mem load\", \"mem store\"}\n+\n enum df_ref_flags\n   {\n     /* Read-modify-write refs generate both a use and a def and\n@@ -62,129 +185,177 @@ enum df_ref_flags\n     /* This flag is set, if we stripped the subreg from the reference.\n        In this case we must make conservative guesses, at what the\n        outer mode was.  */\n-    DF_REF_STRIPPED = 2\n+    DF_REF_STRIPPED = 2,\n+    \n+    /* If this flag is set, this is not a real definition/use, but an\n+       artificial one created to model always live registers, eh uses, etc.  */\n+    DF_REF_ARTIFICIAL = 4,\n+\n+\n+    /* If this flag is set for an artificial use or def, that ref\n+       logically happens at the top of the block.  If it is not set\n+       for an artificial use or def, that ref logically happens at the\n+       bottom of the block.  This is never set for regular refs.  */\n+    DF_REF_AT_TOP = 8,\n+\n+    /* This flag is set if the use is inside a REG_EQUAL note.  */\n+    DF_REF_IN_NOTE = 16,\n+\n+    /* This flag is set if this ref is really a clobber, and not a def.  */\n+    DF_REF_CLOBBER = 32\n   };\n \n \n /* Define a register reference structure.  One of these is allocated\n    for every register reference (use or def).  Note some register\n    references (e.g., post_inc, subreg) generate both a def and a use.  */\n-struct ref\n+struct df_ref\n {\n   rtx reg;\t\t\t/* The register referenced.  */\n-  rtx insn;\t\t\t/* Insn containing ref.  */\n+  unsigned int regno;           /* The register number referenced.  */\n+  basic_block bb;               /* Basic block containing the instruction. */\n+  rtx insn;\t\t\t/* Insn containing ref.  NB: THIS MAY BE NULL.  */\n   rtx *loc;\t\t\t/* The location of the reg.  */\n-  struct df_link *chain;\t/* Head of def-use or use-def chain.  */\n-  unsigned int id;\t\t/* Ref index.  */\n+  struct df_link *chain;\t/* Head of def-use, use-def or bi chain.  */\n+  unsigned int id;\t\t/* Location in table.  */\n   enum df_ref_type type;\t/* Type of ref.  */\n   enum df_ref_flags flags;\t/* Various flags.  */\n-  void *data;\t\t\t/* The data assigned to it by user.  */\n-};\n \n+  /* For each regno, there are two chains of refs, one for the uses\n+     and one for the defs.  These chains go thru the refs themselves\n+     rather than using an external structure.  */\n+  struct df_ref *next_reg;     /* Next ref with same regno and type.  */\n+  struct df_ref *prev_reg;     /* Prev ref with same regno and type.  */\n \n-/* One of these structures is allocated for every insn.  */\n-struct insn_info\n-{\n-  struct df_link *defs;\t\t/* Head of insn-def chain.  */\n-  struct df_link *uses;\t\t/* Head of insn-use chain.  */\n-  /* ???? The following luid field should be considered private so that\n-     we can change it on the fly to accommodate new insns?  */\n-  int luid;\t\t\t/* Logical UID.  */\n+  /* Each insn has two lists, one for the uses and one for the\n+     defs. This is the next field in either of these chains. */\n+  struct df_ref *next_ref; \n+  void *data;\t\t\t/* The data assigned to it by user.  */\n };\n \n+/* There are two kinds of links: */\n \n-/* One of these structures is allocated for every reg.  */\n-struct reg_info\n+/* This is used for def-use or use-def chains.  */\n+struct df_link\n {\n-  struct df_link *defs;\t\t/* Head of reg-def chain.  */\n-  struct df_link *uses;\t\t/* Head of reg-use chain.  */\n-  int lifetime;\n-  int n_defs;\n-  int n_uses;\n+  struct df_ref *ref;\n+  struct df_link *next;\n };\n \n-\n-/* One of these structures is allocated for every basic block.  */\n-struct bb_info\n+/* Two of these structures are allocated, one for the uses and one for\n+   the defs.  */\n+struct df_ref_info\n {\n-  /* Reaching def bitmaps have def_id elements.  */\n-  bitmap rd_kill;\n-  bitmap rd_gen;\n-  bitmap rd_in;\n-  bitmap rd_out;\n-  /* Reaching use bitmaps have use_id elements.  */\n-  bitmap ru_kill;\n-  bitmap ru_gen;\n-  bitmap ru_in;\n-  bitmap ru_out;\n-  /* Live variable bitmaps have n_regs elements.  */\n-  bitmap lr_def;\n-  bitmap lr_use;\n-  bitmap lr_in;\n-  bitmap lr_out;\n-  int rd_valid;\n-  int ru_valid;\n-  int lr_valid;\n+  struct df_reg_info **regs;    /* Array indexed by pseudo regno. */\n+  unsigned int regs_size;       /* Size of currently allocated regs table.  */\n+  unsigned int regs_inited;     /* Number of regs with reg_infos allocated.  */\n+  struct df_ref **refs;         /* Ref table, indexed by id.  */\n+  unsigned int refs_size;       /* Size of currently allocated refs table.  */\n+  unsigned int bitmap_size;\t/* Number of refs seen.  */\n+\n+  /* True if refs table is organized so that every reference for a\n+     pseudo is contigious.  */\n+  bool refs_organized;\n+  /* True if the next refs should be added immediately or false to\n+     defer to later to reorganize the table.  */\n+  bool add_refs_inline; \n };\n \n+\f\n+/*----------------------------------------------------------------------------\n+   Problem data for the scanning dataflow problem.  Unlike the other\n+   dataflow problems, the problem data for scanning is fully exposed and\n+   used by owners of the problem.\n+----------------------------------------------------------------------------*/\n \n struct df\n {\n+\n+#define DF_HARD_REGS\t     1\t/* Mark hard registers.  */\n+#define DF_EQUIV_NOTES\t     2\t/* Mark uses present in EQUIV/EQUAL notes.  */\n+#define DF_SUBREGS\t     4\t/* Return subregs rather than the inner reg.  */\n+\n   int flags;\t\t\t/* Indicates what's recorded.  */\n-  struct bb_info *bbs;\t\t/* Basic block table.  */\n-  struct ref **defs;\t\t/* Def table, indexed by def_id.  */\n-  struct ref **uses;\t\t/* Use table, indexed by use_id.  */\n-  struct ref **reg_def_last;\t/* Indexed by regno.  */\n-  struct reg_info *regs;\t/* Regs table, index by regno.  */\n-  unsigned int reg_size;\t/* Size of regs table.  */\n-  struct insn_info *insns;\t/* Insn table, indexed by insn UID.  */\n-  unsigned int insn_size;\t/* Size of insn table.  */\n-  unsigned int def_id;\t\t/* Next def ID.  */\n-  unsigned int def_size;\t/* Size of def table.  */\n-  unsigned int n_defs;\t\t/* Size of def bitmaps.  */\n-  unsigned int use_id;\t\t/* Next use ID.  */\n-  unsigned int use_size;\t/* Size of use table.  */\n-  unsigned int n_uses;\t\t/* Size of use bitmaps.  */\n-  unsigned int n_bbs;\t\t/* Number of basic blocks.  */\n-  unsigned int n_regs;\t\t/* Number of regs.  */\n-  unsigned int def_id_save;\t/* Saved next def ID.  */\n-  unsigned int use_id_save;\t/* Saved next use ID.  */\n-  bitmap insns_modified;\t/* Insns that (may) have changed.  */\n-  bitmap bbs_modified;\t\t/* Blocks that (may) have changed.  */\n-  bitmap all_blocks;\t\t/* All blocks in CFG.  */\n-  int *dfs_order;\t\t/* DFS order -> block number.  */\n-  int *rc_order;\t\t/* Reverse completion order -> block number.  */\n-  int *rts_order;\t\t/* Reverse top sort order -> block number.  */\n+\n+  /* The set of problems to be solved is stored in two arrays.  In\n+     PROBLEMS_IN_ORDER, the problems are stored in the order that they\n+     are solved.  This is an internally dense array that may have\n+     nulls at the end of it.  In PROBLEMS_BY_INDEX, the problem is\n+     stored by the value in df_problem.id.  These are used to access\n+     the problem local data without having to search the first\n+     array.  */\n+\n+  struct dataflow *problems_in_order [DF_LAST_PROBLEM_PLUS1]; \n+  struct dataflow *problems_by_index [DF_LAST_PROBLEM_PLUS1]; \n+  int num_problems_defined;\n+\n+  /* Set after calls to df_scan_blocks, this contains all of the\n+     blocks that higher level problems must rescan before solving the\n+     dataflow equations.  If this is NULL, the blocks_to_analyze is\n+     used. */\n+  bitmap blocks_to_scan;\n+\n+  /* If not NULL, the subset of blocks of the program to be considered\n+     for analysis.  */ \n+  bitmap blocks_to_analyze;\n+\n+  /* The following information is really the problem data for the\n+     scanning instance but it is used too often by the other problems\n+     to keep getting it from there.  */\n+  struct df_ref_info def_info;   /* Def info.  */\n+  struct df_ref_info use_info;   /* Use info.  */\n+  struct df_insn_info **insns;   /* Insn table, indexed by insn UID.  */\n+  unsigned int insns_size;       /* Size of insn table.  */\n+  bitmap hardware_regs_used;     /* The set of hardware registers used.  */\n+  bitmap exit_block_uses;        /* The set of hardware registers used in exit block.  */\n };\n \n+#define DF_SCAN_BB_INFO(DF, BB) (df_scan_get_bb_info((DF)->problems_by_index[DF_SCAN],(BB)->index))\n+#define DF_RU_BB_INFO(DF, BB) (df_ru_get_bb_info((DF)->problems_by_index[DF_RU],(BB)->index))\n+#define DF_RD_BB_INFO(DF, BB) (df_rd_get_bb_info((DF)->problems_by_index[DF_RD],(BB)->index))\n+#define DF_LR_BB_INFO(DF, BB) (df_lr_get_bb_info((DF)->problems_by_index[DF_LR],(BB)->index))\n+#define DF_UR_BB_INFO(DF, BB) (df_ur_get_bb_info((DF)->problems_by_index[DF_UR],(BB)->index))\n+#define DF_UREC_BB_INFO(DF, BB) (df_urec_get_bb_info((DF)->problems_by_index[DF_UREC],(BB)->index))\n \n-struct df_map\n-{\n-  rtx old;\n-  rtx new;\n-};\n+/* Most transformations that wish to use live register analysis will\n+   use these macros.  The DF_UPWARD_LIVE* macros are only half of the\n+   solution.  */\n+#define DF_LIVE_IN(DF, BB) (DF_UR_BB_INFO(DF, BB)->in) \n+#define DF_LIVE_OUT(DF, BB) (DF_UR_BB_INFO(DF, BB)->out) \n \n \n-#define DF_BB_INFO(REFS, BB) (&REFS->bbs[(BB)->index])\n+/* Live in for register allocation also takes into account several other factors.  */\n+#define DF_RA_LIVE_IN(DF, BB) (DF_UREC_BB_INFO(DF, BB)->in) \n+#define DF_RA_LIVE_OUT(DF, BB) (DF_UREC_BB_INFO(DF, BB)->out) \n+\n+/* These macros are currently used by only reg-stack since it is not\n+   tolerant of uninitialized variables.  This intolerance should be\n+   fixed because it causes other problems.  */ \n+#define DF_UPWARD_LIVE_IN(DF, BB) (DF_LR_BB_INFO(DF, BB)->in) \n+#define DF_UPWARD_LIVE_OUT(DF, BB) (DF_LR_BB_INFO(DF, BB)->out) \n \n \n /* Macros to access the elements within the ref structure.  */\n \n+\n #define DF_REF_REAL_REG(REF) (GET_CODE ((REF)->reg) == SUBREG \\\n \t\t\t\t? SUBREG_REG ((REF)->reg) : ((REF)->reg))\n-#define DF_REF_REGNO(REF) REGNO (DF_REF_REAL_REG (REF))\n+#define DF_REF_REGNO(REF) ((REF)->regno)\n #define DF_REF_REAL_LOC(REF) (GET_CODE ((REF)->reg) == SUBREG \\\n \t\t\t        ? &SUBREG_REG ((REF)->reg) : ((REF)->loc))\n #define DF_REF_REG(REF) ((REF)->reg)\n #define DF_REF_LOC(REF) ((REF)->loc)\n-#define DF_REF_BB(REF) (BLOCK_FOR_INSN ((REF)->insn))\n-#define DF_REF_BBNO(REF) (BLOCK_FOR_INSN ((REF)->insn)->index)\n+#define DF_REF_BB(REF) ((REF)->bb)\n+#define DF_REF_BBNO(REF) (DF_REF_BB (REF)->index)\n #define DF_REF_INSN(REF) ((REF)->insn)\n #define DF_REF_INSN_UID(REF) (INSN_UID ((REF)->insn))\n #define DF_REF_TYPE(REF) ((REF)->type)\n #define DF_REF_CHAIN(REF) ((REF)->chain)\n #define DF_REF_ID(REF) ((REF)->id)\n #define DF_REF_FLAGS(REF) ((REF)->flags)\n+#define DF_REF_NEXT_REG(REF) ((REF)->next_reg)\n+#define DF_REF_PREV_REG(REF) ((REF)->prev_reg)\n+#define DF_REF_NEXT_REF(REF) ((REF)->next_ref)\n #define DF_REF_DATA(REF) ((REF)->data)\n \n /* Macros to determine the reference type.  */\n@@ -196,174 +367,213 @@ struct df_map\n #define DF_REF_REG_MEM_P(REF) (DF_REF_REG_MEM_STORE_P (REF) \\\n                                || DF_REF_REG_MEM_LOAD_P (REF))\n \n+/* Macros to get the refs out of def_info or use_info refs table.  */\n+#define DF_DEFS_SIZE(DF) ((DF)->def_info.bitmap_size)\n+#define DF_DEFS_GET(DF,ID) ((DF)->def_info.refs[(ID)])\n+#define DF_DEFS_SET(DF,ID,VAL) ((DF)->def_info.refs[(ID)]=(VAL))\n+#define DF_USES_SIZE(DF) ((DF)->use_info.bitmap_size)\n+#define DF_USES_GET(DF,ID) ((DF)->use_info.refs[(ID)])\n+#define DF_USES_SET(DF,ID,VAL) ((DF)->use_info.refs[(ID)]=(VAL))\n+\n+/* Macros to access the register information from scan dataflow record.  */\n+\n+#define DF_REG_SIZE(DF) ((DF)->def_info.regs_size)\n+#define DF_REG_DEF_GET(DF, REG) ((DF)->def_info.regs[(REG)])\n+#define DF_REG_DEF_SET(DF, REG, VAL) ((DF)->def_info.regs[(REG)]=(VAL))\n+#define DF_REG_USE_GET(DF, REG) ((DF)->use_info.regs[(REG)])\n+#define DF_REG_USE_SET(DF, REG, VAL) ((DF)->use_info.regs[(REG)]=(VAL))\n \n /* Macros to access the elements within the reg_info structure table.  */\n \n #define DF_REGNO_FIRST_DEF(DF, REGNUM) \\\n-((DF)->regs[REGNUM].defs ? (DF)->regs[REGNUM].defs->ref : 0)\n+(DF_REG_DEF_GET(DF, REGNUM) ? DF_REG_DEF_GET(DF, REGNUM) : 0)\n #define DF_REGNO_LAST_USE(DF, REGNUM) \\\n-((DF)->regs[REGNUM].uses ? (DF)->regs[REGNUM].uses->ref : 0)\n-\n-#define DF_REGNO_FIRST_BB(DF, REGNUM) \\\n-((DF)->regs[REGNUM].defs ? DF_REF_BB ((DF)->regs[REGNUM].defs->ref) : 0)\n-#define DF_REGNO_LAST_BB(DF, REGNUM) \\\n-((DF)->regs[REGNUM].uses ? DF_REF_BB ((DF)->regs[REGNUM].uses->ref) : 0)\n-\n+(DF_REG_USE_GET(DF, REGNUM) ? DF_REG_USE_GET(DF, REGNUM) : 0)\n \n /* Macros to access the elements within the insn_info structure table.  */\n \n-#define DF_INSN_LUID(DF, INSN) ((DF)->insns[INSN_UID (INSN)].luid)\n-#define DF_INSN_DEFS(DF, INSN) ((DF)->insns[INSN_UID (INSN)].defs)\n-#define DF_INSN_USES(DF, INSN) ((DF)->insns[INSN_UID (INSN)].uses)\n-\n-\n-/* Functions to build and analyze dataflow information.  */\n-\n-extern struct df *df_init (void);\n-\n-extern int df_analyze (struct df *, bitmap, int);\n-extern void df_analyze_subcfg (struct df *, bitmap, int);\n-\n-extern void df_finish (struct df *);\n-\n-extern void df_dump (struct df *, int, FILE *);\n-\n-\n-/* Functions to modify insns.  */\n-\n-extern bool df_insn_modified_p (struct df *, rtx);\n-\n-extern void df_insn_modify (struct df *, basic_block, rtx);\n-\n-extern rtx df_insn_delete (struct df *, basic_block, rtx);\n-\n-extern rtx df_pattern_emit_before (struct df *, rtx, basic_block, rtx);\n-\n-extern rtx df_jump_pattern_emit_after (struct df *, rtx, basic_block, rtx);\n-\n-extern rtx df_pattern_emit_after (struct df *, rtx, basic_block, rtx);\n+#define DF_INSN_SIZE(DF) ((DF)->insns_size)\n+#define DF_INSN_GET(DF,INSN) ((DF)->insns[(INSN_UID(INSN))])\n+#define DF_INSN_SET(DF,INSN,VAL) ((DF)->insns[(INSN_UID (INSN))]=(VAL))\n+#define DF_INSN_CONTAINS_ASM(DF, INSN) (DF_INSN_GET(DF,INSN)->contains_asm)\n+#define DF_INSN_LUID(DF, INSN) (DF_INSN_GET(DF,INSN)->luid)\n+#define DF_INSN_DEFS(DF, INSN) (DF_INSN_GET(DF,INSN)->defs)\n+#define DF_INSN_USES(DF, INSN) (DF_INSN_GET(DF,INSN)->uses)\n \n-extern rtx df_insn_move_before (struct df *, basic_block, rtx, basic_block,\n-\t\t\t\trtx);\n+#define DF_INSN_UID_GET(DF,UID) ((DF)->insns[(UID)])\n+#define DF_INSN_UID_LUID(DF, INSN) (DF_INSN_UID_GET(DF,INSN)->luid)\n+#define DF_INSN_UID_DEFS(DF, INSN) (DF_INSN_UID_GET(DF,INSN)->defs)\n+#define DF_INSN_UID_USES(DF, INSN) (DF_INSN_UID_GET(DF,INSN)->uses)\n \n-extern int df_reg_replace (struct df *, bitmap, rtx, rtx);\n+/* This is a bitmap copy of regs_invalidated_by_call so that we can\n+   easily add it into bitmaps, etc. */ \n \n-extern int df_ref_reg_replace (struct df *, struct ref *, rtx, rtx);\n+extern bitmap df_invalidated_by_call;\n \n-extern int df_ref_remove (struct df *, struct ref *);\n+/* Initialize ur_in and ur_out as if all hard registers were partially\n+available.  */\n \n-extern int df_insn_mem_replace (struct df *, basic_block, rtx, rtx, rtx);\n+extern bitmap df_all_hard_regs;\n \n-extern struct ref *df_bb_def_use_swap (struct df *, basic_block, rtx, rtx,\n-\t\t\t\t       unsigned int);\n+/* The way that registers are processed, especially hard registers,\n+   changes as the compilation proceeds. These states are passed to\n+   df_set_state to control this processing.  */\n \n+#define DF_SCAN_INITIAL    1    /* Processing from beginning of rtl to\n+\t\t\t\t   global-alloc.  */\n+#define DF_SCAN_GLOBAL     2    /* Processing before global\n+\t\t\t\t   allocation.  */\n+#define DF_SCAN_POST_ALLOC 4    /* Processing after register\n+\t\t\t\t   allocation.  */\n+extern int df_state;            /* Indicates where we are in the compilation.  */\n \n-/* Functions to query dataflow information.  */\n \n-extern basic_block df_regno_bb (struct df *, unsigned int);\n-\n-extern int df_reg_lifetime (struct df *, rtx);\n-\n-extern int df_reg_global_p (struct df *, rtx);\n-\n-extern int df_insn_regno_def_p (struct df *, basic_block, rtx, unsigned int);\n-\n-extern int df_insn_dominates_all_uses_p (struct df *, basic_block, rtx);\n-\n-extern int df_insn_dominates_uses_p (struct df *, basic_block, rtx, bitmap);\n+/* One of these structures is allocated for every basic block.  */\n+struct df_scan_bb_info\n+{\n+  /* Defs at the start of a basic block that is the target of an\n+     exception edge.  */\n+  struct df_ref *artificial_defs;\n \n-extern int df_bb_reg_live_start_p (struct df *, basic_block, rtx);\n+  /* Uses of hard registers that are live at every block.  */\n+  struct df_ref *artificial_uses;\n+};\n \n-extern int df_bb_reg_live_end_p (struct df *, basic_block, rtx);\n \n-extern int df_bb_regs_lives_compare (struct df *, basic_block, rtx, rtx);\n+/* Reaching uses.  */\n+struct df_ru_bb_info \n+{\n+  bitmap kill;\n+  bitmap sparse_kill;\n+  bitmap gen;\n+  bitmap in;\n+  bitmap out;\n+};\n \n-extern bool df_local_def_available_p (struct df *, struct ref *, struct ref *);\n \n-extern rtx df_bb_single_def_use_insn_find (struct df *, basic_block, rtx,\n-\t\t\t\t\t   rtx);\n-extern struct ref *df_bb_regno_last_use_find (struct df *, basic_block, unsigned int);\n+/* Reaching definitions.  */\n+struct df_rd_bb_info \n+{\n+  bitmap kill;\n+  bitmap sparse_kill;\n+  bitmap gen;\n+  bitmap in;\n+  bitmap out;\n+};\n \n-extern struct ref *df_bb_regno_first_def_find (struct df *, basic_block, unsigned int);\n \n-extern struct ref *df_bb_regno_last_def_find (struct df *, basic_block, unsigned int);\n+/* Live registers.  */\n+struct df_lr_bb_info \n+{\n+  bitmap def;\n+  bitmap use;\n+  bitmap in;\n+  bitmap out;\n+};\n \n-extern struct ref *df_find_def (struct df *, rtx, rtx);\n \n-extern struct ref *df_find_use (struct df *, rtx, rtx);\n+/* Uninitialized registers.  */\n+struct df_ur_bb_info \n+{\n+  bitmap kill;\n+  bitmap gen;\n+  bitmap in;\n+  bitmap out;\n+};\n \n-extern int df_reg_used (struct df *, rtx, rtx);\n+/* Uninitialized registers.  */\n+struct df_urec_bb_info \n+{\n+  bitmap earlyclobber;\n+  bitmap kill;\n+  bitmap gen;\n+  bitmap in;\n+  bitmap out;\n+};\n \n-/* Functions for debugging from GDB.  */\n \n+#define df_finish(df) {df_finish1(df); df=NULL;}\n+\n+/* Functions defined in df-core.c.  */\n+\n+extern struct df *df_init (int);\n+extern struct dataflow *df_add_problem (struct df *, struct df_problem *);\n+extern void df_set_blocks (struct df*, bitmap);\n+extern void df_finish1 (struct df *);\n+extern void df_analyze (struct df *);\n+extern void df_compact_blocks (struct df *);\n+extern void df_bb_replace (struct df *, int, basic_block);\n+extern struct df_ref *df_bb_regno_last_use_find (struct df *, basic_block, unsigned int);\n+extern struct df_ref *df_bb_regno_first_def_find (struct df *, basic_block, unsigned int);\n+extern struct df_ref *df_bb_regno_last_def_find (struct df *, basic_block, unsigned int);\n+extern bool df_insn_regno_def_p (struct df *, rtx, unsigned int);\n+extern struct df_ref *df_find_def (struct df *, rtx, rtx);\n+extern bool df_reg_defined (struct df *, rtx, rtx);\n+extern struct df_ref *df_find_use (struct df *, rtx, rtx);\n+extern bool df_reg_used (struct df *, rtx, rtx);\n+extern void df_iterative_dataflow (struct dataflow *, bitmap, bitmap, int *, int, bool);\n+extern void df_dump (struct df *, FILE *);\n+extern void df_chain_dump (struct df *, struct df_link *, FILE *);\n+extern void df_refs_chain_dump (struct df *, struct df_ref *, bool, FILE *);\n+extern void df_regs_chain_dump (struct df *, struct df_ref *,  FILE *);\n+extern void df_insn_debug (struct df *, rtx, bool, FILE *);\n+extern void df_insn_debug_regno (struct df *, rtx, FILE *);\n+extern void df_regno_debug (struct df *, unsigned int, FILE *);\n+extern void df_ref_debug (struct df *, struct df_ref *, FILE *);\n extern void debug_df_insn (rtx);\n-\n extern void debug_df_regno (unsigned int);\n-\n extern void debug_df_reg (rtx);\n-\n extern void debug_df_defno (unsigned int);\n-\n extern void debug_df_useno (unsigned int);\n-\n-extern void debug_df_ref (struct ref *);\n-\n+extern void debug_df_ref (struct df_ref *);\n extern void debug_df_chain (struct df_link *);\n+/* An instance of df that can be shared between passes.  */\n+extern struct df *shared_df; \n+\n+\n+/* Functions defined in df-problems.c. */\n+\n+extern struct dataflow *df_get_dependent_problem (struct dataflow *);\n+extern struct df_link *df_chain_create (struct dataflow *, struct df_ref *, struct df_ref *);\n+extern void df_chain_unlink (struct dataflow *, struct df_ref *, struct df_link *);\n+extern void df_chain_copy (struct dataflow *, struct df_ref *, struct df_link *);\n+extern bitmap df_get_live_in (struct df *, basic_block);\n+extern bitmap df_get_live_out (struct df *, basic_block);\n+extern void df_grow_bb_info (struct dataflow *);\n+extern void df_chain_dump (struct df *, struct df_link *, FILE *);\n+extern void df_print_bb_index (basic_block bb, FILE *file);\n+extern struct dataflow *df_ru_add_problem (struct df *);\n+extern struct df_ru_bb_info *df_ru_get_bb_info (struct dataflow *, unsigned int);\n+extern struct dataflow *df_rd_add_problem (struct df *);\n+extern struct df_rd_bb_info *df_rd_get_bb_info (struct dataflow *, unsigned int);\n+extern struct dataflow *df_lr_add_problem (struct df *);\n+extern struct df_lr_bb_info *df_lr_get_bb_info (struct dataflow *, unsigned int);\n+extern struct dataflow *df_ur_add_problem (struct df *);\n+extern struct df_ur_bb_info *df_ur_get_bb_info (struct dataflow *, unsigned int);\n+extern struct dataflow *df_urec_add_problem (struct df *);\n+extern struct df_urec_bb_info *df_urec_get_bb_info (struct dataflow *, unsigned int);\n+extern struct dataflow *df_chain_add_problem (struct df *, int flags);\n+extern struct dataflow *df_ri_add_problem (struct df *);\n+extern int df_reg_lifetime (struct df *, rtx reg);\n+\n+\n+/* Functions defined in df-scan.c.  */\n+\n+extern struct df_scan_bb_info *df_scan_get_bb_info (struct dataflow *, unsigned int);\n+extern struct dataflow *df_scan_add_problem (struct df *);\n+extern void df_rescan_blocks (struct df *, bitmap);\n+extern struct df_ref *df_ref_create (struct df *, rtx, rtx *, rtx,basic_block,enum df_ref_type, enum df_ref_flags);\n+extern struct df_ref *df_get_artificial_defs (struct df *, unsigned int);\n+extern struct df_ref *df_get_artificial_uses (struct df *, unsigned int);\n+extern void df_reg_chain_create (struct df_reg_info *, struct df_ref *);\n+extern struct df_ref *df_reg_chain_unlink (struct dataflow *, struct df_ref *);\n+extern void df_ref_remove (struct df *, struct df_ref *);\n+extern void df_insn_refs_delete (struct dataflow *, rtx);\n+extern void df_refs_delete (struct dataflow *, bitmap);\n+extern void df_reorganize_refs (struct df_ref_info *);\n+extern void df_set_state (int);\n+extern void df_hard_reg_init (void);\n+extern bool df_read_modify_subreg_p (rtx);\n \n-extern void df_insn_debug (struct df *, rtx, FILE *);\n-\n-extern void df_insn_debug_regno (struct df *, rtx, FILE *);\n-\n-\n-/* Meet over any path (UNION) or meet over all paths (INTERSECTION).  */\n-enum df_confluence_op\n-  {\n-    DF_UNION,\n-    DF_INTERSECTION\n-  };\n-\n-\n-/* Dataflow direction.  */\n-enum df_flow_dir\n-  {\n-    DF_FORWARD,\n-    DF_BACKWARD\n-  };\n-\n-\n-typedef void (*transfer_function) (int, int *, void *, void *,\n-\t\t\t\t   void *, void *, void *);\n-\n-/* The description of a dataflow problem to solve.  */\n-\n-enum set_representation\n-{\n-  SR_SBITMAP,\t\t/* Represent sets by bitmaps.  */\n-  SR_BITMAP\t\t/* Represent sets by sbitmaps.  */\n-};\n-\n-struct dataflow\n-{\n-  enum set_representation repr;\t\t/* The way the sets are represented.  */\n-\n-  /* The following arrays are indexed by block indices, so they must always\n-     be large enough even if we restrict ourselves just to a subset of cfg.  */\n-  void **gen, **kill;\t\t\t/* Gen and kill sets.  */\n-  void **in, **out;\t\t\t/* Results.  */\n-\n-  enum df_flow_dir dir;\t\t\t/* Dataflow direction.  */\n-  enum df_confluence_op conf_op;\t/* Confluence operator.  */ \n-  unsigned n_blocks;\t\t\t/* Number of basic blocks in the\n-\t\t\t\t\t   order.  */\n-  int *order;\t\t\t\t/* The list of basic blocks to work\n-\t\t\t\t\t   with, in the order they should\n-\t\t\t\t\t   be processed in.  */\n-  transfer_function transfun;\t\t/* The transfer function.  */\n-  void *data;\t\t\t\t/* Data used by the transfer\n-\t\t\t\t\t   function.  */\n-};\n-\n-extern void iterative_dataflow (struct dataflow *);\n-extern bool read_modify_subreg_p (rtx);\n \n #endif /* GCC_DF_H */"}, {"sha": "96d216e2672b3bbe0a9ef678bc5bf845ed493f49", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 31, "deletions": 37, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=4d779342f00ac9b678043e8a2e474a1ae14b8660", "patch": "@@ -1,5 +1,5 @@\n /* RTL-level loop invariant motion.\n-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -153,7 +153,7 @@ static VEC(invariant_p,heap) *invariants;\n \n /* The dataflow object.  */\n \n-static struct df *df;\n+static struct df *df = NULL;\n \n /* Test for possibility of invariantness of X.  */\n \n@@ -226,10 +226,10 @@ check_maybe_invariant (rtx x)\n    invariant.  */\n \n static struct invariant *\n-invariant_for_use (struct ref *use)\n+invariant_for_use (struct df_ref *use)\n {\n   struct df_link *defs;\n-  struct ref *def;\n+  struct df_ref *def;\n   basic_block bb = BLOCK_FOR_INSN (use->insn), def_bb;\n \n   defs = DF_REF_CHAIN (use);\n@@ -255,7 +255,7 @@ hash_invariant_expr_1 (rtx insn, rtx x)\n   const char *fmt;\n   hashval_t val = code;\n   int do_not_record_p;\n-  struct ref *use;\n+  struct df_ref *use;\n   struct invariant *inv;\n \n   switch (code)\n@@ -306,7 +306,7 @@ invariant_expr_equal_p (rtx insn1, rtx e1, rtx insn2, rtx e2)\n   enum rtx_code code = GET_CODE (e1);\n   int i, j;\n   const char *fmt;\n-  struct ref *use1, *use2;\n+  struct df_ref *use1, *use2;\n   struct invariant *inv1 = NULL, *inv2 = NULL;\n   rtx sub1, sub2;\n \n@@ -600,7 +600,8 @@ find_defs (struct loop *loop, basic_block *body)\n   for (i = 0; i < loop->num_nodes; i++)\n     bitmap_set_bit (blocks, body[i]->index);\n \n-  df_analyze_subcfg (df, blocks, DF_UD_CHAIN | DF_HARD_REGS | DF_EQUIV_NOTES);\n+  df_set_blocks (df, blocks);\n+  df_analyze (df);\n   BITMAP_FREE (blocks);\n }\n \n@@ -673,16 +674,14 @@ record_use (struct def *def, rtx *use, rtx insn)\n static bool\n check_dependencies (rtx insn, bitmap depends_on)\n {\n-  struct df_link *uses, *defs;\n-  struct ref *use, *def;\n+  struct df_link *defs;\n+  struct df_ref *use, *def;\n   basic_block bb = BLOCK_FOR_INSN (insn), def_bb;\n   struct def *def_data;\n   struct invariant *inv;\n \n-  for (uses = DF_INSN_USES (df, insn); uses; uses = uses->next)\n+  for (use = DF_INSN_GET (df, insn)->uses; use; use = use->next_ref)\n     {\n-      use = uses->ref;\n-\n       defs = DF_REF_CHAIN (use);\n       if (!defs)\n \tcontinue;\n@@ -718,7 +717,7 @@ check_dependencies (rtx insn, bitmap depends_on)\n static void\n find_invariant_insn (rtx insn, bool always_reached, bool always_executed)\n {\n-  struct ref *ref;\n+  struct df_ref *ref;\n   struct def *def;\n   bitmap depends_on;\n   rtx set, dest;\n@@ -781,13 +780,11 @@ find_invariant_insn (rtx insn, bool always_reached, bool always_executed)\n static void\n record_uses (rtx insn)\n {\n-  struct df_link *uses;\n-  struct ref *use;\n+  struct df_ref *use;\n   struct invariant *inv;\n \n-  for (uses = DF_INSN_USES (df, insn); uses; uses = uses->next)\n+  for (use = DF_INSN_GET (df, insn)->uses; use; use = use->next_ref)\n     {\n-      use = uses->ref;\n       inv = invariant_for_use (use);\n       if (inv)\n \trecord_use (inv->def, DF_REF_LOC (use), DF_REF_INSN (use));\n@@ -1025,6 +1022,7 @@ find_invariants_to_move (void)\n {\n   unsigned i, regs_used, n_inv_uses, regs_needed = 0, new_regs;\n   struct invariant *inv = NULL;\n+  unsigned int n_regs = DF_REG_SIZE (df);\n \n   if (!VEC_length (invariant_p, invariants))\n     return;\n@@ -1037,7 +1035,7 @@ find_invariants_to_move (void)\n      here to stand for induction variables etc. that we do not detect.  */\n   regs_used = 2;\n \n-  for (i = 0; i < df->n_regs; i++)\n+  for (i = 0; i < n_regs; i++)\n     {\n       if (!DF_REGNO_FIRST_DEF (df, i) && DF_REGNO_LAST_USE (df, i))\n \t{\n@@ -1098,8 +1096,7 @@ move_invariant_reg (struct loop *loop, unsigned invno)\n \t need to create a temporary register.  */\n       set = single_set (inv->insn);\n       reg = gen_reg_rtx (GET_MODE (SET_DEST (set)));\n-      df_pattern_emit_after (df, gen_move_insn (SET_DEST (set), reg),\n-\t\t\t     BLOCK_FOR_INSN (inv->insn), inv->insn);\n+      emit_insn_after (gen_move_insn (SET_DEST (set), reg), inv->insn);\n \n       /* If the SET_DEST of the invariant insn is a reg, we can just move\n \t the insn out of the loop.  Otherwise, we have to use gen_move_insn\n@@ -1108,23 +1105,20 @@ move_invariant_reg (struct loop *loop, unsigned invno)\n \t{\n \t  SET_DEST (set) = reg;\n \t  reorder_insns (inv->insn, inv->insn, BB_END (preheader));\n-\t  df_insn_modify (df, preheader, inv->insn);\n \t}\n       else\n \t{\n-\t  df_pattern_emit_after (df, gen_move_insn (reg, SET_SRC (set)),\n-\t\t\t\t preheader, BB_END (preheader));\n-\t  df_insn_delete (df, BLOCK_FOR_INSN (inv->insn), inv->insn);\n+\t  emit_insn_after (gen_move_insn (reg, SET_SRC (set)), BB_END (preheader));\n+\t  delete_insn (inv->insn);\n \t}\n     }\n   else\n     {\n       move_invariant_reg (loop, repr->invno);\n       reg = repr->reg;\n       set = single_set (inv->insn);\n-      df_pattern_emit_after (df, gen_move_insn (SET_DEST (set), reg),\n-\t\t\t     BLOCK_FOR_INSN (inv->insn), inv->insn);\n-      df_insn_delete (df, BLOCK_FOR_INSN (inv->insn), inv->insn);\n+      emit_insn_after (gen_move_insn (SET_DEST (set), reg), inv->insn);\n+      delete_insn (inv->insn);\n     }\n \n   inv->reg = reg;\n@@ -1135,10 +1129,7 @@ move_invariant_reg (struct loop *loop, unsigned invno)\n   if (inv->def)\n     {\n       for (use = inv->def->uses; use; use = use->next)\n-\t{\n-\t  *use->pos = reg;\n-\t  df_insn_modify (df, BLOCK_FOR_INSN (use->insn), use->insn);\n-\t}\n+\t*use->pos = reg;\n     }\n }\n \n@@ -1174,20 +1165,22 @@ free_inv_motion_data (void)\n   struct def *def;\n   struct invariant *inv;\n \n-  for (i = 0; i < df->n_defs; i++)\n+  for (i = 0; i < DF_DEFS_SIZE (df); i++)\n     {\n-      if (!df->defs[i])\n+      struct df_ref * ref = DF_DEFS_GET (df, i);\n+      if (!ref)\n \tcontinue;\n \n-      inv = DF_REF_DATA (df->defs[i]);\n+      inv = DF_REF_DATA (ref);\n       if (!inv)\n \tcontinue;\n+\n       def = inv->def;\n       gcc_assert (def != NULL);\n \n       free_use_list (def->uses);\n       free (def);\n-      DF_REF_DATA (df->defs[i]) = NULL;\n+      DF_REF_DATA (ref) = NULL;\n     }\n \n   for (i = 0; VEC_iterate (invariant_p, invariants, i, inv); i++)\n@@ -1231,8 +1224,9 @@ move_loop_invariants (struct loops *loops)\n   struct loop *loop;\n   unsigned i;\n \n-  df = df_init ();\n-\n+  df = df_init (DF_HARD_REGS | DF_EQUIV_NOTES);\n+  df_chain_add_problem (df, DF_UD_CHAIN);\n+ \n   /* Process the loops, innermost first.  */\n   loop = loops->tree_root;\n   while (loop->inner)"}, {"sha": "a669bb87fddec1b18d9264a9678a7f014b44cad6", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=4d779342f00ac9b678043e8a2e474a1ae14b8660", "patch": "@@ -1,5 +1,5 @@\n /* Swing Modulo Scheduling implementation.\n-   Copyright (C) 2004, 2005\n+   Copyright (C) 2004, 2005, 2006\n    Free Software Foundation, Inc.\n    Contributed by Ayal Zaks and Mustafa Hagog <zaks,mustafa@il.ibm.com>\n \n@@ -976,8 +976,11 @@ sms_schedule (FILE *dump_file)\n   sched_init (NULL);\n \n   /* Init Data Flow analysis, to be used in interloop dep calculation.  */\n-  df = df_init ();\n-  df_analyze (df, 0, DF_ALL);\n+  df = df_init (DF_HARD_REGS | DF_EQUIV_NOTES |\tDF_SUBREGS);\n+  df_rd_add_problem (df);\n+  df_ru_add_problem (df);\n+  df_chain_add_problem (df, DF_DU_CHAIN | DF_UD_CHAIN);\n+  df_analyze (df);\n \n   /* Allocate memory to hold the DDG array one entry for each loop.\n      We use loop->num as index into this array.  */\n@@ -1091,6 +1094,7 @@ sms_schedule (FILE *dump_file)\n \n   /* Release Data Flow analysis data structures.  */\n   df_finish (df);\n+  df = NULL;\n \n   /* We don't want to perform SMS on new loops - created by versioning.  */\n   num_loops = loops->num;\n@@ -2536,7 +2540,6 @@ rest_of_handle_sms (void)\n {\n #ifdef INSN_SCHEDULING\n   basic_block bb;\n-  sbitmap blocks;\n \n   /* We want to be able to create new pseudos.  */\n   no_new_pseudos = 0;\n@@ -2547,9 +2550,7 @@ rest_of_handle_sms (void)\n   /* Update the life information, because we add pseudos.  */\n   max_regno = max_reg_num ();\n   allocate_reg_info (max_regno, FALSE, FALSE);\n-  blocks = sbitmap_alloc (last_basic_block);\n-  sbitmap_ones (blocks);\n-  update_life_info (blocks, UPDATE_LIFE_GLOBAL_RM_NOTES,\n+  update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n                     (PROP_DEATH_NOTES\n                      | PROP_REG_INFO\n                      | PROP_KILL_DEAD_CODE"}, {"sha": "4732529a7c5652fedca8248c03d30be440ba7b8e", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=4d779342f00ac9b678043e8a2e474a1ae14b8660", "patch": "@@ -1,7 +1,8 @@\n /* Instruction scheduling pass.  This file computes dependencies between\n    instructions.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n    and currently maintained by, Jim Wilson (wilson@cygnus.com)\n \n@@ -520,7 +521,7 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n     {\n       if (GET_CODE (dest) == STRICT_LOW_PART\n \t || GET_CODE (dest) == ZERO_EXTRACT\n-\t || read_modify_subreg_p (dest))\n+\t || df_read_modify_subreg_p (dest))\n         {\n \t  /* These both read and modify the result.  We must handle\n              them as writes to get proper dependencies for following"}, {"sha": "820288b7e51002fbb45877a461683312f344c7b7", "filename": "gcc/web.c", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d779342f00ac9b678043e8a2e474a1ae14b8660/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=4d779342f00ac9b678043e8a2e474a1ae14b8660", "patch": "@@ -1,6 +1,7 @@\n /* Web construction code for GNU compiler.\n    Contributed by Jan Hubicka.\n-   Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2004, 2006\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -71,10 +72,10 @@ struct web_entry\n \n static struct web_entry *unionfind_root (struct web_entry *);\n static void unionfind_union (struct web_entry *, struct web_entry *);\n-static void union_defs (struct df *, struct ref *, struct web_entry *, \n+static void union_defs (struct df *, struct df_ref *, struct web_entry *, \n                         struct web_entry *);\n-static rtx entry_register (struct web_entry *, struct ref *, char *);\n-static void replace_ref (struct ref *, rtx);\n+static rtx entry_register (struct web_entry *, struct df_ref *, char *);\n+static void replace_ref (struct df_ref *, rtx);\n \n /* Find the root of unionfind tree (the representative of set).  */\n \n@@ -110,13 +111,13 @@ unionfind_union (struct web_entry *first, struct web_entry *second)\n    register, union them.  */\n \n static void\n-union_defs (struct df *df, struct ref *use, struct web_entry *def_entry,\n+union_defs (struct df *df, struct df_ref *use, struct web_entry *def_entry,\n             struct web_entry *use_entry)\n {\n   rtx insn = DF_REF_INSN (use);\n   struct df_link *link = DF_REF_CHAIN (use);\n-  struct df_link *use_link = DF_INSN_USES (df, insn);\n-  struct df_link *def_link = DF_INSN_DEFS (df, insn);\n+  struct df_ref *use_link = DF_INSN_USES (df, insn);\n+  struct df_ref *def_link = DF_INSN_DEFS (df, insn);\n   rtx set = single_set (insn);\n \n   /* Some instructions may use match_dup for their operands.  In case the\n@@ -126,11 +127,11 @@ union_defs (struct df *df, struct ref *use, struct web_entry *def_entry,\n \n   while (use_link)\n     {\n-      if (use != use_link->ref\n-\t  && DF_REF_REAL_REG (use) == DF_REF_REAL_REG (use_link->ref))\n+      if (use != use_link\n+\t  && DF_REF_REAL_REG (use) == DF_REF_REAL_REG (use_link))\n \tunionfind_union (use_entry + DF_REF_ID (use),\n-\t\t         use_entry + DF_REF_ID (use_link->ref));\n-      use_link = use_link->next;\n+\t\t         use_entry + DF_REF_ID (use_link));\n+      use_link = use_link->next_ref;\n     }\n \n   /* Recognize trivial noop moves and attempt to keep them as noop.\n@@ -143,10 +144,10 @@ union_defs (struct df *df, struct ref *use, struct web_entry *def_entry,\n     {\n       while (def_link)\n \t{\n-\t  if (DF_REF_REAL_REG (use) == DF_REF_REAL_REG (def_link->ref))\n+\t  if (DF_REF_REAL_REG (use) == DF_REF_REAL_REG (def_link))\n \t    unionfind_union (use_entry + DF_REF_ID (use),\n-\t\t\t     def_entry + DF_REF_ID (def_link->ref));\n-\t  def_link = def_link->next;\n+\t\t\t     def_entry + DF_REF_ID (def_link));\n+\t  def_link = def_link->next_ref;\n \t}\n     }\n   while (link)\n@@ -160,22 +161,22 @@ union_defs (struct df *df, struct ref *use, struct web_entry *def_entry,\n      register.  Find it and union.  */\n   if (use->flags & DF_REF_READ_WRITE)\n     {\n-      struct df_link *link = DF_INSN_DEFS (df, DF_REF_INSN (use));\n+      struct df_ref *link = DF_INSN_DEFS (df, DF_REF_INSN (use));\n \n       while (link)\n \t{\n-\t  if (DF_REF_REAL_REG (link->ref) == DF_REF_REAL_REG (use))\n+\t  if (DF_REF_REAL_REG (link) == DF_REF_REAL_REG (use))\n \t    unionfind_union (use_entry + DF_REF_ID (use),\n-\t\t\t     def_entry + DF_REF_ID (link->ref));\n-\t  link = link->next;\n+\t\t\t     def_entry + DF_REF_ID (link));\n+\t  link = link->next_ref;\n \t}\n     }\n }\n \n /* Find the corresponding register for the given entry.  */\n \n static rtx\n-entry_register (struct web_entry *entry, struct ref *ref, char *used)\n+entry_register (struct web_entry *entry, struct df_ref *ref, char *used)\n {\n   struct web_entry *root;\n   rtx reg, newreg;\n@@ -217,7 +218,7 @@ entry_register (struct web_entry *entry, struct ref *ref, char *used)\n /* Replace the reference by REG.  */\n \n static void\n-replace_ref (struct ref *ref, rtx reg)\n+replace_ref (struct df_ref *ref, rtx reg)\n {\n   rtx oldreg = DF_REF_REAL_REG (ref);\n   rtx *loc = DF_REF_REAL_LOC (ref);\n@@ -242,28 +243,31 @@ web_main (void)\n   int max = max_reg_num ();\n   char *used;\n \n-  df = df_init ();\n-  df_analyze (df, 0, DF_UD_CHAIN | DF_EQUIV_NOTES);\n+  df = df_init (DF_EQUIV_NOTES);\n+  df_chain_add_problem (df, DF_UD_CHAIN);\n+  df_analyze (df);\n+  df_reorganize_refs (&df->def_info);\n+  df_reorganize_refs (&df->use_info);\n \n-  def_entry = xcalloc (df->n_defs, sizeof (struct web_entry));\n-  use_entry = xcalloc (df->n_uses, sizeof (struct web_entry));\n+  def_entry = xcalloc (DF_DEFS_SIZE (df), sizeof (struct web_entry));\n+  use_entry = xcalloc (DF_USES_SIZE (df), sizeof (struct web_entry));\n   used = xcalloc (max, sizeof (char));\n \n   if (dump_file)\n-    df_dump (df, DF_UD_CHAIN | DF_DU_CHAIN, dump_file);\n+    df_dump (df, dump_file);\n \n   /* Produce the web.  */\n-  for (i = 0; i < df->n_uses; i++)\n-    union_defs (df, df->uses[i], def_entry, use_entry);\n+  for (i = 0; i < DF_USES_SIZE (df); i++)\n+    union_defs (df, DF_USES_GET (df, i), def_entry, use_entry);\n \n   /* Update the instruction stream, allocating new registers for split pseudos\n      in progress.  */\n-  for (i = 0; i < df->n_uses; i++)\n-    replace_ref (df->uses[i], entry_register (use_entry + i, df->uses[i],\n-\t\t\t\t\t      used));\n-  for (i = 0; i < df->n_defs; i++)\n-    replace_ref (df->defs[i], entry_register (def_entry + i, df->defs[i],\n-\t\t\t\t\t      used));\n+  for (i = 0; i < DF_USES_SIZE (df); i++)\n+    replace_ref (DF_USES_GET (df, i), \n+\t\t entry_register (use_entry + i, DF_USES_GET (df, i), used));\n+  for (i = 0; i < DF_DEFS_SIZE (df); i++)\n+    replace_ref (DF_DEFS_GET (df, i), \n+\t\t entry_register (def_entry + i, DF_DEFS_GET (df, i), used));\n \n   /* Dataflow information is corrupt here, but it can be easily updated\n      by creating new entries for new registers and updates or calling\n@@ -272,6 +276,7 @@ web_main (void)\n   free (use_entry);\n   free (used);\n   df_finish (df);\n+  df = NULL;\n }\n \f\n static bool"}]}