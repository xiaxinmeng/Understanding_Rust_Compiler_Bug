{"sha": "f5fb834c96ee4dc828299f984c46608814c9f0a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVmYjgzNGM5NmVlNGRjODI4Mjk5Zjk4NGM0NjYwODgxNGM5ZjBhMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@torsion.usersys.redhat.com", "date": "2020-05-07T22:21:48Z"}, "committer": {"name": "Jeff Law", "email": "law@torsion.usersys.redhat.com", "date": "2020-05-07T22:21:48Z"}, "message": "Move all patterns and expanders out of h8300.md and into other files that are included into h8300.md\n\n\t* config/h8300/h8300.md: Move expanders and patterns into\n\tfiles based on functionality.\n\t* config/h8300/addsub.md: New file.\n\t* config/h8300/bitfield.md: New file\n\t* config/h8300/combiner.md: New file\n\t* config/h8300/divmod.md: New file\n\t* config/h8300/extensions.md: New file\n\t* config/h8300/jumpcall.md: New file\n\t* config/h8300/logical.md: New file\n\t* config/h8300/movepush.md: New file\n\t* config/h8300/multiply.md: New file\n\t* config/h8300/other.md: New file\n\t* config/h8300/proepi.md: New file\n\t* config/h8300/shiftrotate.md: New file\n\t* config/h8300/testcompare.md: New file\n\ncommit da1de1d91088ac506c1bed0fba9b0f04c5b8c876", "tree": {"sha": "dd6f45e4401ae34b1b69f8dfdc28cdc425eb26f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd6f45e4401ae34b1b69f8dfdc28cdc425eb26f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5fb834c96ee4dc828299f984c46608814c9f0a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5fb834c96ee4dc828299f984c46608814c9f0a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5fb834c96ee4dc828299f984c46608814c9f0a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5fb834c96ee4dc828299f984c46608814c9f0a2/comments", "author": null, "committer": null, "parents": [{"sha": "8e8b576639cd41490c89668c6aff04853654cf87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e8b576639cd41490c89668c6aff04853654cf87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e8b576639cd41490c89668c6aff04853654cf87"}], "stats": {"total": 6303, "additions": 3159, "deletions": 3144}, "files": [{"sha": "ce5c3eac23c253deeb9cb5242f71a33fcc9d2c39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5fb834c96ee4dc828299f984c46608814c9f0a2", "patch": "@@ -1,5 +1,21 @@\n 2020-05-07 Jeff Law  <law@redhat.com>\n \n+\t* config/h8300/h8300.md: Move expanders and patterns into\n+\tfiles based on functionality.\n+\t* config/h8300/addsub.md: New file.\n+\t* config/h8300/bitfield.md: New file\n+\t* config/h8300/combiner.md: New file\n+\t* config/h8300/divmod.md: New file\n+\t* config/h8300/extensions.md: New file\n+\t* config/h8300/jumpcall.md: New file\n+\t* config/h8300/logical.md: New file\n+\t* config/h8300/movepush.md: New file\n+\t* config/h8300/multiply.md: New file\n+\t* config/h8300/other.md: New file\n+\t* config/h8300/proepi.md: New file\n+\t* config/h8300/shiftrotate.md: New file\n+\t* config/h8300/testcompare.md: New file\n+\n \t* config/h8300/h8300.md (adds/subs splitters): Merge into single\n \tsplitter.\n \t(negation expanders and patterns): Simplify and combine using"}, {"sha": "f3392856b7609293b291b783dad19affba644b07", "filename": "gcc/config/h8300/addsub.md", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Faddsub.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Faddsub.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Faddsub.md?ref=f5fb834c96ee4dc828299f984c46608814c9f0a2", "patch": "@@ -0,0 +1,159 @@\n+;; ----------------------------------------------------------------------\n+;; ADD INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_expand \"add<mode>3\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"\")\n+\t(plus:QHSI (match_operand:QHSI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:QHSI 2 \"h8300_src_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*addqi3\"\n+  [(set (match_operand:QI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(plus:QI (match_operand:QI 1 \"h8300_dst_operand\" \"%0\")\n+\t\t (match_operand:QI 2 \"h8300_src_operand\" \"rQi\")))]\n+  \"h8300_operands_match_p (operands)\"\n+  \"add.b\t%X2,%X0\"\n+  [(set_attr \"length_table\" \"add\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"*addhi3_h8300hs\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r,r\")\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0,0\")\n+\t\t (match_operand:HI 2 \"h8300_src_operand\" \"L,N,J,n,r\")))]\n+  \"!TARGET_H8300SX\"\n+  \"@\n+   adds\t%2,%S0\n+   subs\t%G2,%S0\n+   add.b\t%t2,%t0\n+   add.w\t%T2,%T0\n+   add.w\t%T2,%T0\"\n+  [(set_attr \"length\" \"2,2,2,4,2\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,clobber,set_zn,set_zn\")])\n+\n+(define_insn \"*add<mode>3_incdec\"\n+  [(set (match_operand:HSI 0 \"register_operand\" \"=r,r\")\n+\t(unspec:HSI [(match_operand:HSI 1 \"register_operand\" \"0,0\")\n+\t\t     (match_operand:HSI 2 \"incdec_operand\" \"M,O\")]\n+\t\t    UNSPEC_INCDEC))]\n+  \"\"\n+  {\n+    if (which_alternative == 0)\n+      return <MODE>mode == HImode ? \"inc.w\\t%2,%T0\" : \"inc.l\\t%2,%S0\";\n+    else if (which_alternative == 1)\n+      return <MODE>mode == HImode ? \"dec.w\\t%G2,%T0\" : \"dec.l\\t%G2,%S0\";\n+    gcc_unreachable ();\n+   }\n+  [(set_attr \"length\" \"2,2\")\n+   (set_attr \"cc\" \"set_zn,set_zn\")])\n+\n+(define_insn \"*addhi3_h8sx\"\n+  [(set (match_operand:HI 0 \"h8300_dst_operand\" \"=rU,rU,r,rQ\")\n+\t(plus:HI (match_operand:HI 1 \"h8300_dst_operand\" \"%0,0,0,0\")\n+\t\t (match_operand:HI 2 \"h8300_src_operand\" \"P3>X,P3<X,J,rQi\")))]\n+  \"TARGET_H8300SX && h8300_operands_match_p (operands)\"\n+  \"@\n+   add.w\t%T2:3,%T0\n+   sub.w\t%G2:3,%T0\n+   add.b\t%t2,%t0\n+   add.w\t%T2,%T0\"\n+  [(set_attr \"length_table\" \"short_immediate,short_immediate,*,add\")\n+   (set_attr \"length\" \"*,*,2,*\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_split\n+  [(set (match_operand:HSI 0 \"register_operand\" \"\")\n+\t(plus:HSI (match_dup 0)\n+\t\t (match_operand:HSI 1 \"two_insn_adds_subs_operand\" \"\")))]\n+  \"\"\n+  [(const_int 0)]\n+  {\n+    split_adds_subs (<MODE>mode, operands);\n+    DONE;\n+  })\n+\n+\n+(define_insn \"*addsi_h8300hs\"\n+  [(set (match_operand:SI 0 \"h8300_dst_operand\" \"=rQ,rQ\")\n+\t(plus:SI (match_operand:SI 1 \"h8300_dst_operand\" \"%0,0\")\n+\t\t (match_operand:SI 2 \"h8300_src_operand\" \"i,rQ\")))]\n+  \"h8300_operands_match_p (operands)\"\n+{\n+  return output_plussi (operands);\n+}\n+  [(set (attr \"length\")\n+\t(symbol_ref \"compute_plussi_length (operands)\"))\n+   (set (attr \"cc\")\n+\t(symbol_ref \"compute_plussi_cc (operands)\"))])\n+\n+;; ----------------------------------------------------------------------\n+;; SUBTRACT INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_expand \"sub<mode>3\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"\")\n+\t(minus:QHSI (match_operand:QHSI 1 \"register_operand\" \"\")\n+\t\t    (match_operand:QHSI 2 \"h8300_src_operand\" \"\")))]\n+  \"\"\n+  {\n+  })\n+\n+(define_insn \"*subqi3\"\n+  [(set (match_operand:QI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(minus:QI (match_operand:QI 1 \"h8300_dst_operand\" \"0\")\n+\t\t  (match_operand:QI 2 \"h8300_dst_operand\" \"rQ\")))]\n+  \"h8300_operands_match_p (operands)\"\n+  \"sub.b\t%X2,%X0\"\n+  [(set_attr \"length_table\" \"add\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"*sub<mode>3_h8300hs\"\n+  [(set (match_operand:HSI 0 \"h8300_dst_operand\" \"=rQ,rQ\")\n+\t(minus:HSI (match_operand:HSI 1 \"h8300_dst_operand\" \"0,0\")\n+\t\t   (match_operand:HSI 2 \"h8300_src_operand\" \"rQ,i\")))]\n+  \"h8300_operands_match_p (operands)\"\n+  { \n+    if (<MODE>mode == HImode)\n+      return \"sub.w\t%T2,%T0\";\n+    else if (<MODE>mode == SImode)\n+      return \"sub.l\t%S2,%S0\";\n+    gcc_unreachable ();\n+  }\n+  [(set_attr \"length_table\" \"add\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+;; ----------------------------------------------------------------------\n+;; NEGATION INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_expand \"neg<mode>2\"\n+  [(set (match_operand:QHSIF 0 \"register_operand\" \"\")\n+\t(neg:QHSIF (match_operand:QHSIF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*neg<mode>2\"\n+  [(set (match_operand:QHSI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(neg:QHSI (match_operand:QHSI 1 \"h8300_dst_operand\" \"0\")))]\n+  \"\"\n+  {\n+    if (<MODE>mode == E_QImode)\n+      return \"neg\t%X0\";\n+    if (<MODE>mode == E_HImode)\n+      return \"neg.w\t%T0\";\n+    if (<MODE>mode == E_SImode)\n+      return \"neg.l\t%S0\";\n+    gcc_unreachable ();\n+  }\n+  [(set_attr \"length_table\" \"unary\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+\n+(define_insn \"*negsf2_h8300hs\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+       (neg:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"xor.w\\\\t#32768,%e0\"\n+  [(set_attr \"length\" \"4\")])\n+"}, {"sha": "bed712d830b827554c6626f1976c260e53824bc9", "filename": "gcc/config/h8300/bitfield.md", "status": "added", "additions": 440, "deletions": 0, "changes": 440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fbitfield.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fbitfield.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fbitfield.md?ref=f5fb834c96ee4dc828299f984c46608814c9f0a2", "patch": "@@ -0,0 +1,440 @@\n+;; -----------------------------------------------------------------\n+;; BIT FIELDS\n+;; -----------------------------------------------------------------\n+;; The H8/300 has given 1/8th of its opcode space to bitfield\n+;; instructions so let's use them as well as we can.\n+\n+;; You'll never believe all these patterns perform one basic action --\n+;; load a bit from the source, optionally invert the bit, then store it\n+;; in the destination (which is known to be zero).\n+;;\n+;; Combine obviously need some work to better identify this situation and\n+;; canonicalize the form better.\n+\n+;;\n+;; Inverted loads with a 16bit destination.\n+;;\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n+\t(zero_extract:HI (xor:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t\t (match_operand:HI 3 \"const_int_operand\" \"n\"))\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:HI 2 \"const_int_operand\" \"n\")))]\n+  \"(TARGET_H8300SX)\n+    && (1 << INTVAL (operands[2])) == INTVAL (operands[3])\"\n+  \"sub.w\t%0,%0\\;bild\t%Z2,%Y1\\;bst\t#0,%X0\"\n+  [(set_attr \"length\" \"8\")])\n+\n+;;\n+;; Normal loads with a 32bit destination.\n+;;\n+\n+(define_insn \"*extzv_1_r_h8300hs\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"?0,r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand 2 \"const_int_operand\" \"n,n\")))]\n+  \"INTVAL (operands[2]) < 16\"\n+{\n+  return output_simode_bld (0, operands);\n+}\n+  [(set_attr \"cc\" \"set_znv,set_znv\")\n+   (set_attr \"length\" \"8,6\")])\n+\n+;;\n+;; Inverted loads with a 32bit destination.\n+;;\n+\n+(define_insn \"*extzv_1_r_inv_h8300hs\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extract:SI (xor:SI (match_operand:SI 1 \"register_operand\" \"?0,r\")\n+\t\t\t\t (match_operand 3 \"const_int_operand\" \"n,n\"))\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand 2 \"const_int_operand\" \"n,n\")))]\n+  \"INTVAL (operands[2]) < 16\n+    && (1 << INTVAL (operands[2])) == INTVAL (operands[3])\"\n+{\n+  return output_simode_bld (1, operands);\n+}\n+  [(set_attr \"cc\" \"set_znv,set_znv\")\n+   (set_attr \"length\" \"8,6\")])\n+\n+(define_expand \"insv\"\n+  [(set (zero_extract:HI (match_operand:HI 0 \"general_operand\" \"\")\n+\t\t\t (match_operand:HI 1 \"general_operand\" \"\")\n+\t\t\t (match_operand:HI 2 \"general_operand\" \"\"))\n+\t(match_operand:HI 3 \"general_operand\" \"\"))]\n+  \"TARGET_H8300SX\"\n+  {\n+    if (GET_CODE (operands[1]) == CONST_INT\n+\t&& GET_CODE (operands[2]) == CONST_INT\n+\t&& INTVAL (operands[1]) <= 8\n+\t&& INTVAL (operands[2]) >= 0\n+\t&& INTVAL (operands[1]) + INTVAL (operands[2]) <= 8\n+\t&& memory_operand (operands[0], GET_MODE (operands[0])))\n+      {\n+\t/* If the source operand is zero, it's better to use AND rather\n+\t   than BFST.  Likewise OR if the operand is all ones.  */\n+\tif (GET_CODE (operands[3]) == CONST_INT)\n+\t  {\n+\t    HOST_WIDE_INT mask = (1 << INTVAL (operands[1])) - 1;\n+\t    if ((INTVAL (operands[3]) & mask) == 0)\n+\t      FAIL;\n+\t    if ((INTVAL (operands[3]) & mask) == mask)\n+\t      FAIL;\n+\t  }\n+\tif (! bit_memory_operand (operands[0], GET_MODE (operands[0])))\n+\t  {\n+\t    if (!can_create_pseudo_p ())\n+\t      FAIL;\n+\t    operands[0] =  replace_equiv_address (operands[0], force_reg (Pmode,\n+\t\t\t\t\t\t  XEXP (operands[0], 0)));\n+\t  }\n+\toperands[3] = gen_lowpart (QImode, operands[3]);\n+\tif (! operands[3])\n+\t  FAIL;\n+\tif (! register_operand (operands[3], QImode))\n+\t  {\n+\t    if (!can_create_pseudo_p ())\n+\t      FAIL;\n+\t    operands[3] = force_reg (QImode, operands[3]);\n+\t  }\n+\temit_insn (gen_bfst (adjust_address (operands[0], QImode, 0),\n+\t\t\t\t\t     operands[3], operands[1], operands[2]));\n+\tDONE;\n+      }\n+    FAIL;\n+  })\n+\n+(define_insn \"\"\n+  [(set (zero_extract:HI (match_operand:HI 0 \"register_operand\" \"+r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:HI 1 \"immediate_operand\" \"n\"))\n+\t(match_operand:HI 2 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"bld\t#0,%R2\\;bst\t%Z1,%Y0 ; i1\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_expand \"extzv\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(zero_extract:HI (match_operand:HI 1 \"bit_operand\" \"\")\n+\t\t\t (match_operand:HI 2 \"general_operand\" \"\")\n+\t\t\t (match_operand:HI 3 \"general_operand\" \"\")))]\n+  \"TARGET_H8300SX\"\n+  {\n+    if (GET_CODE (operands[2]) == CONST_INT\n+\t&& GET_CODE (operands[3]) == CONST_INT\n+\t&& INTVAL (operands[2]) <= 8\n+\t&& INTVAL (operands[3]) >= 0\n+\t&& INTVAL (operands[2]) + INTVAL (operands[3]) <= 8\n+\t&& memory_operand (operands[1], QImode))\n+      {\n+\trtx temp;\n+\n+\t/* Optimize the case where we're extracting into a paradoxical\n+\t   subreg.  It's only necessary to extend to the inner reg.  */\n+\tif (GET_CODE (operands[0]) == SUBREG\n+\t    && subreg_lowpart_p (operands[0])\n+\t    && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (operands[0])))\n+\t\t< GET_MODE_SIZE (GET_MODE (operands[0])))\n+\t    && (GET_MODE_CLASS (GET_MODE (SUBREG_REG (operands[0])))\n+\t\t== MODE_INT))\n+\t   operands[0] = SUBREG_REG (operands[0]);\n+\n+\tif (!can_create_pseudo_p ())\n+\t  temp = gen_lowpart (QImode, operands[0]);\n+\telse\n+\t  temp = gen_reg_rtx (QImode);\n+\tif (! temp)\n+\t  FAIL;\n+        if (! bit_memory_operand (operands[1], QImode))\n+\t  {\n+\t    if (!can_create_pseudo_p ())\n+\t      FAIL;\n+\t    operands[1] = replace_equiv_address (operands[1],\n+\t\t\t\t\t\t force_reg (Pmode, XEXP (operands[1], 0)));\n+\t  }\n+\temit_insn (gen_bfld (temp, operands[1], operands[2], operands[3]));\n+\tconvert_move (operands[0], temp, 1);\n+\tDONE;\n+      }\n+    FAIL;\n+  })\n+\n+;; BAND, BOR, and BXOR patterns\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"bit_operand\" \"=Ur\")\n+\t(match_operator:HI 4 \"bit_operator\"\n+\t [(zero_extract:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_operand:HI 2 \"immediate_operand\" \"n\"))\n+\t  (match_operand:HI 3 \"bit_operand\" \"0\")]))]\n+  \"\"\n+  \"bld\t%Z2,%Y1\\;b%c4\t#0,%R0\\;bst\t#0,%R0; bl1\"\n+  [(set_attr \"length\" \"6\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"bit_operand\" \"=Ur\")\n+\t(match_operator:HI 5 \"bit_operator\"\n+\t [(zero_extract:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_operand:HI 2 \"immediate_operand\" \"n\"))\n+\t  (zero_extract:HI (match_operand:HI 3 \"register_operand\" \"r\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_operand:HI 4 \"immediate_operand\" \"n\"))]))]\n+  \"\"\n+  \"bld\t%Z2,%Y1\\;b%c5\t%Z4,%Y3\\;bst\t#0,%R0; bl3\"\n+  [(set_attr \"length\" \"6\")])\n+\n+(define_insn \"bfld\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:QI (match_operand:QI 1 \"bit_memory_operand\" \"WU\")\n+\t\t\t (match_operand:QI 2 \"immediate_operand\" \"n\")\n+\t\t\t (match_operand:QI 3 \"immediate_operand\" \"n\")))]\n+  \"TARGET_H8300SX && INTVAL (operands[2]) + INTVAL (operands[3]) <= 8\"\n+{\n+  operands[2] = GEN_INT ((1 << (INTVAL (operands[2]) + INTVAL (operands[3])))\n+\t\t\t - (1 << INTVAL (operands[3])));\n+  return \"bfld\t%2,%1,%R0\";\n+}\n+  [(set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"length_table\" \"bitfield\")])\n+\n+(define_insn \"bfst\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"bit_memory_operand\" \"+WU\")\n+\t\t\t (match_operand:QI 2 \"immediate_operand\" \"n\")\n+\t\t\t (match_operand:QI 3 \"immediate_operand\" \"n\"))\n+\t(match_operand:QI 1 \"register_operand\" \"r\"))]\n+  \"TARGET_H8300SX && INTVAL (operands[2]) + INTVAL (operands[3]) <= 8\"\n+{\n+  operands[2] = GEN_INT ((1 << (INTVAL (operands[2]) + INTVAL (operands[3])))\n+\t\t\t - (1 << INTVAL (operands[3])));\n+  return \"bfst\t%R1,%2,%0\";\n+}\n+  [(set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"length_table\" \"bitfield\")])\n+\n+(define_expand \"cstoreqi4\"\n+  [(use (match_operator 1 \"eqne_operator\"\n+         [(match_operand:QI 2 \"h8300_dst_operand\" \"\")\n+          (match_operand:QI 3 \"h8300_src_operand\" \"\")]))\n+   (clobber (match_operand:HI 0 \"register_operand\"))]\n+  \"TARGET_H8300SX\"\n+  {\n+    h8300_expand_store (operands);\n+    DONE;\n+  })\n+\n+(define_expand \"cstorehi4\"\n+  [(use (match_operator 1 \"eqne_operator\"\n+         [(match_operand:HI 2 \"h8300_dst_operand\" \"\")\n+          (match_operand:HI 3 \"h8300_src_operand\" \"\")]))\n+   (clobber (match_operand:HI 0 \"register_operand\"))]\n+  \"TARGET_H8300SX\"\n+  {\n+    h8300_expand_store (operands);\n+    DONE;\n+  })\n+\n+(define_expand \"cstoresi4\"\n+  [(use (match_operator 1 \"eqne_operator\"\n+         [(match_operand:SI 2 \"h8300_dst_operand\" \"\")\n+          (match_operand:SI 3 \"h8300_src_operand\" \"\")]))\n+   (clobber (match_operand:HI 0 \"register_operand\"))]\n+  \"TARGET_H8300SX\"\n+  {\n+    h8300_expand_store (operands);\n+    DONE;\n+  })\n+\n+(define_insn \"*bstzhireg\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(match_operator:HI 1 \"eqne_operator\" [(cc0) (const_int 0)]))]\n+  \"TARGET_H8300SX\"\n+  \"mulu.w\t#0,%T0\\;b%k1\t.Lh8BR%=\\;inc.w\t#1,%T0\\\\n.Lh8BR%=:\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn_and_split \"*cmpstz\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"bit_memory_operand\" \"+WU,WU\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:QI 1 \"immediate_operand\" \"n,n\"))\n+\t(match_operator:QI 2 \"eqne_operator\"\n+\t [(match_operand 3 \"h8300_dst_operand\" \"r,rQ\")\n+\t  (match_operand 4 \"h8300_src_operand\" \"I,rQi\")]))]\n+  \"TARGET_H8300SX\n+   && (GET_MODE (operands[3]) == GET_MODE (operands[4])\n+       || GET_CODE (operands[4]) == CONST_INT)\n+   && GET_MODE_CLASS (GET_MODE (operands[3])) == MODE_INT\n+   && GET_MODE_SIZE (GET_MODE (operands[3])) <= 4\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (cc0) (match_dup 5))\n+   (set (zero_extract:QI (match_dup 0) (const_int 1) (match_dup 1))\n+\t(match_op_dup:QI 2 [(cc0) (const_int 0)]))]\n+  {\n+    operands[5] = gen_rtx_COMPARE (VOIDmode, operands[3], operands[4]);\n+  }\n+  [(set_attr \"cc\" \"set_znv,compare\")])\n+\n+(define_insn \"*bstz\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"bit_memory_operand\" \"+WU\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:QI 1 \"immediate_operand\" \"n\"))\n+\t(eq:QI (cc0) (const_int 0)))]\n+  \"TARGET_H8300SX && reload_completed\"\n+  \"bstz\t%1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"length_table\" \"unary\")])\n+\n+(define_insn \"*bistz\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"bit_memory_operand\" \"+WU\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:QI 1 \"immediate_operand\" \"n\"))\n+\t(ne:QI (cc0) (const_int 0)))]\n+  \"TARGET_H8300SX && reload_completed\"\n+  \"bistz\t%1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"length_table\" \"unary\")])\n+\n+(define_insn_and_split \"*cmpcondbset\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=WU,WU\")\n+\t(if_then_else:QI (match_operator 1 \"eqne_operator\"\n+\t\t\t  [(match_operand 2 \"h8300_dst_operand\" \"r,rQ\")\n+\t\t\t   (match_operand 3 \"h8300_src_operand\" \"I,rQi\")])\n+\t\t\t (ior:QI (match_operand:QI 4 \"bit_memory_operand\" \"0,0\")\n+\t\t\t\t (match_operand:QI 5 \"single_one_operand\" \"n,n\"))\n+\t\t\t (match_dup 4)))]\n+  \"TARGET_H8300SX\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (cc0) (match_dup 6))\n+   (set (match_dup 0)\n+\t(if_then_else:QI (match_op_dup 1 [(cc0) (const_int 0)])\n+\t\t\t (ior:QI (match_dup 4) (match_dup 5))\n+\t\t\t (match_dup 4)))]\n+  {\n+    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\n+  }\n+  [(set_attr \"cc\" \"set_znv,compare\")])\n+\n+(define_insn \"*condbset\"\n+  [(set (match_operand:QI 0 \"bit_memory_operand\" \"=WU\")\n+\t(if_then_else:QI (match_operator:QI 2 \"eqne_operator\"\n+\t\t\t  [(cc0) (const_int 0)])\n+\t\t\t (ior:QI (match_operand:QI 3 \"bit_memory_operand\" \"0\")\n+\t\t\t\t (match_operand:QI 1 \"single_one_operand\" \"n\"))\n+\t\t\t (match_dup 3)))]\n+  \"TARGET_H8300SX && reload_completed\"\n+  \"bset/%j2\\t%V1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"length_table\" \"logicb\")])\n+\n+(define_insn_and_split \"*cmpcondbclr\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=WU,WU\")\n+\t(if_then_else:QI (match_operator 1 \"eqne_operator\"\n+\t\t\t  [(match_operand 2 \"h8300_dst_operand\" \"r,rQ\")\n+\t\t\t   (match_operand 3 \"h8300_src_operand\" \"I,rQi\")])\n+\t\t\t (and:QI (match_operand:QI 4 \"bit_memory_operand\" \"0,0\")\n+\t\t\t\t (match_operand:QI 5 \"single_zero_operand\" \"n,n\"))\n+\t\t\t (match_dup 4)))]\n+  \"TARGET_H8300SX\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (cc0) (match_dup 6))\n+   (set (match_dup 0)\n+\t(if_then_else:QI (match_op_dup 1 [(cc0) (const_int 0)])\n+\t\t\t (and:QI (match_dup 4) (match_dup 5))\n+\t\t\t (match_dup 4)))]\n+  {\n+    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\n+  }\n+  [(set_attr \"cc\" \"set_znv,compare\")])\n+\n+(define_insn \"*condbclr\"\n+  [(set (match_operand:QI 0 \"bit_memory_operand\" \"=WU\")\n+\t(if_then_else:QI (match_operator:QI 2 \"eqne_operator\"\n+\t\t\t  [(cc0) (const_int 0)])\n+\t\t\t (and:QI (match_operand:QI 3 \"bit_memory_operand\" \"0\")\n+\t\t\t\t (match_operand:QI 1 \"single_zero_operand\" \"n\"))\n+\t\t\t (match_dup 3)))]\n+  \"TARGET_H8300SX && reload_completed\"\n+  \"bclr/%j2\\t%W1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"length_table\" \"logicb\")])\n+\n+(define_insn_and_split \"*cmpcondbsetreg\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=WU,WU\")\n+\t(if_then_else:QI (match_operator 1 \"eqne_operator\"\n+\t\t\t  [(match_operand 2 \"h8300_dst_operand\" \"r,rQ\")\n+\t\t\t   (match_operand 3 \"h8300_src_operand\" \"I,rQi\")])\n+\t\t\t (ior:QI (match_operand:QI 4 \"bit_memory_operand\" \"0,0\")\n+\t\t\t\t (ashift:QI (const_int 1)\n+\t\t\t\t\t    (match_operand:QI 5 \"register_operand\" \"r,r\")))\n+\t\t\t (match_dup 4)))]\n+  \"TARGET_H8300SX\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (cc0) (match_dup 6))\n+   (set (match_dup 0)\n+\t(if_then_else:QI (match_op_dup 1 [(cc0) (const_int 0)])\n+\t\t\t (ior:QI (match_dup 4)\n+\t\t\t\t (ashift:QI (const_int 1)\n+\t\t\t\t\t    (match_operand:QI 5 \"register_operand\" \"r,r\")))\n+\t\t\t (match_dup 4)))]\n+  {\n+    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\n+  }\n+  [(set_attr \"cc\" \"set_znv,compare\")])\n+\n+(define_insn \"*condbsetreg\"\n+  [(set (match_operand:QI 0 \"bit_memory_operand\" \"=WU\")\n+\t(if_then_else:QI (match_operator:QI 2 \"eqne_operator\"\n+\t\t\t  [(cc0) (const_int 0)])\n+\t\t\t (ior:QI (match_operand:QI 3 \"bit_memory_operand\" \"0\")\n+\t\t\t\t (ashift:QI (const_int 1)\n+\t\t\t\t\t    (match_operand:QI 1 \"register_operand\" \"r\")))\n+\t\t\t (match_dup 3)))]\n+  \"TARGET_H8300SX && reload_completed\"\n+  \"bset/%j2\\t%R1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"length_table\" \"logicb\")])\n+\n+(define_insn_and_split \"*cmpcondbclrreg\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=WU,WU\")\n+\t(if_then_else:QI (match_operator 1 \"eqne_operator\"\n+\t\t\t  [(match_operand 2 \"h8300_dst_operand\" \"r,rQ\")\n+\t\t\t   (match_operand 3 \"h8300_src_operand\" \"I,rQi\")])\n+\t\t\t (and:QI (match_operand:QI 4 \"bit_memory_operand\" \"0,0\")\n+\t\t\t\t (ashift:QI (const_int 1)\n+\t\t\t\t\t    (match_operand:QI 5 \"register_operand\" \"r,r\")))\n+\t\t\t (match_dup 4)))]\n+  \"TARGET_H8300SX\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (cc0) (match_dup 6))\n+   (set (match_dup 0)\n+\t(if_then_else:QI (match_op_dup 1 [(cc0) (const_int 0)])\n+\t\t\t (and:QI (match_dup 4)\n+\t\t\t\t (ashift:QI (const_int 1)\n+\t\t\t\t\t    (match_operand:QI 5 \"register_operand\" \"r,r\")))\n+\t\t\t (match_dup 4)))]\n+  {\n+    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\n+  }\n+  [(set_attr \"cc\" \"set_znv,compare\")])\n+\n+(define_insn \"*condbclrreg\"\n+  [(set (match_operand:QI 0 \"bit_memory_operand\" \"=WU\")\n+\t(if_then_else:QI (match_operator:QI 2 \"eqne_operator\"\n+\t\t\t  [(cc0) (const_int 0)])\n+\t\t\t (and:QI (match_operand:QI 3 \"bit_memory_operand\" \"0\")\n+\t\t\t\t (ashift:QI (const_int 1)\n+\t\t\t\t\t    (match_operand:QI 1 \"register_operand\" \"r\")))\n+\t\t\t (match_dup 3)))]\n+  \"TARGET_H8300SX && reload_completed\"\n+  \"bclr/%j2\\t%R1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"length_table\" \"logicb\")])\n+"}, {"sha": "f59ff5f15bdc637090933b5d32cfb7234a6f4ac2", "filename": "gcc/config/h8300/combiner.md", "status": "added", "additions": 775, "deletions": 0, "changes": 775, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fcombiner.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fcombiner.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fcombiner.md?ref=f5fb834c96ee4dc828299f984c46608814c9f0a2", "patch": "@@ -0,0 +1,775 @@\n+;; -----------------------------------------------------------------\n+;; COMBINE PATTERNS\n+;; -----------------------------------------------------------------\n+\n+;; insv:SI\n+\n+(define_insn \"*insv_si_1_n\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\"))\n+\t(match_operand:SI 2 \"register_operand\" \"r\"))]\n+  \"INTVAL (operands[1]) < 16\"\n+  \"bld\\\\t#0,%w2\\;bst\\\\t%Z1,%Y0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*insv_si_1_n_lshiftrt\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\"))\n+\t(lshiftrt:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t     (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n+  \"INTVAL (operands[1]) < 16 && INTVAL (operands[3]) < 16\"\n+  \"bld\\\\t%Z3,%Y2\\;bst\\\\t%Z1,%Y0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*insv_si_1_n_lshiftrt_16\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\"))\n+\t(lshiftrt:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t     (const_int 16)))]\n+  \"INTVAL (operands[1]) < 16\"\n+  \"rotr.w\\\\t%e2\\;rotl.w\\\\t%e2\\;bst\\\\t%Z1,%Y0\"\n+  [(set_attr \"length\" \"6\")])\n+\n+(define_insn \"*insv_si_8_8\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t\t\t (const_int 8)\n+\t\t\t (const_int 8))\n+\t(match_operand:SI 1 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"mov.b\\\\t%w1,%x0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*insv_si_8_8_lshiftrt_8\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t\t\t (const_int 8)\n+\t\t\t (const_int 8))\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t     (const_int 8)))]\n+  \"\"\n+  \"mov.b\\\\t%x1,%x0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+;; extzv:SI\n+\n+(define_insn \"*extzv_8_8\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"?0,r\")\n+\t\t\t (const_int 8)\n+\t\t\t (const_int 8)))]\n+  \"\"\n+  \"@\n+   mov.b\\\\t%x1,%w0\\;extu.w\\\\t%f0\\;extu.l\\\\t%S0\n+   sub.l\\\\t%S0,%S0\\;mov.b\\\\t%x1,%w0\"\n+  [(set_attr \"cc\" \"set_znv,clobber\")\n+   (set_attr \"length\" \"6,4\")])\n+\n+(define_insn \"*extzv_8_16\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 8)\n+\t\t\t (const_int 16)))]\n+  \"\"\n+  \"mov.w\\\\t%e1,%f0\\;extu.w\\\\t%f0\\;extu.l\\\\t%S0\"\n+  [(set_attr \"cc\" \"set_znv\")\n+   (set_attr \"length\" \"6\")])\n+\n+(define_insn \"*extzv_16_8\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 16)\n+\t\t\t (const_int 8)))\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n+  \"TARGET_H8300H\"\n+  \"mov.w\\\\t%e1,%f2\\;mov.b\\\\t%x1,%w0\\;mov.b\\\\t%w2,%x0\\;extu.l\\\\t%S0\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+;; Extract the exponent of a float.\n+\n+(define_insn_and_split \"*extzv_8_23\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t (const_int 8)\n+\t\t\t (const_int 23)))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ashift:SI (match_dup 0)\n+\t\t\t      (const_int 1)))\n+\t      (clobber (scratch:QI))])\n+   (parallel [(set (match_dup 0)\n+\t\t   (lshiftrt:SI (match_dup 0)\n+\t\t\t\t(const_int 24)))\n+\t      (clobber (scratch:QI))])]\n+  \"\")\n+\n+;; and:SI\n+\n+;; ((SImode) HImode) << 15\n+\n+(define_insn_and_split \"*twoshifts_l16_r1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t   (const_int 15))\n+\t\t(const_int 2147450880)))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ashift:SI (match_dup 0)\n+\t\t\t      (const_int 16)))\n+\t      (clobber (scratch:QI))])\n+   (parallel [(set (match_dup 0)\n+\t\t   (lshiftrt:SI (match_dup 0)\n+\t\t\t\t(const_int 1)))\n+\t      (clobber (scratch:QI))])]\n+  \"\")\n+\n+;; Transform (SImode << B) & 0xffff into (SImode) (HImode << B).\n+\n+(define_insn_and_split \"*andsi3_ashift_n_lower\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(and:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t\t   (match_operand:QI 2 \"const_int_operand\" \"S,n\"))\n+\t\t(match_operand:SI 3 \"const_int_operand\" \"n,n\")))\n+   (clobber (match_scratch:QI 4 \"=X,&r\"))]\n+  \"INTVAL (operands[2]) <= 15\n+   && UINTVAL (operands[3]) == ((HOST_WIDE_INT_M1U << INTVAL (operands[2]))\n+\t\t\t\t& 0xffff)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 5)\n+\t\t   (ashift:HI (match_dup 5)\n+\t\t\t      (match_dup 2)))\n+\t      (clobber (match_dup 4))])\n+   (set (match_dup 0)\n+\t(zero_extend:SI (match_dup 5)))]\n+  {\n+    operands[5] = gen_rtx_REG (HImode, REGNO (operands[0]));\n+  })\n+\n+;; Accept (A >> 30) & 2 and the like.\n+\n+(define_insn \"*andsi3_lshiftrt_n_sb\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\"))\n+\t\t(match_operand:SI 3 \"single_one_operand\" \"n\")))]\n+  \"exact_log2 (INTVAL (operands[3])) < 16\n+   && INTVAL (operands[2]) + exact_log2 (INTVAL (operands[3])) == 31\"\n+{\n+  operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));\n+  return \"shll.l\\\\t%S0\\;xor.l\\\\t%S0,%S0\\;bst\\\\t%Z3,%Y0\";\n+}\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn_and_split \"*andsi3_lshiftrt_9_sb\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t     (const_int 9))\n+\t\t(const_int 4194304)))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0)\n+\t(and:SI (lshiftrt:SI (match_dup 0)\n+\t\t\t     (const_int 25))\n+\t\t(const_int 64)))\n+   (parallel [(set (match_dup 0)\n+\t\t   (ashift:SI (match_dup 0)\n+\t\t\t      (const_int 16)))\n+\t      (clobber (scratch:QI))])]\n+  \"\")\n+\n+;; plus:SI\n+\n+(define_insn \"*addsi3_upper\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t  (const_int 65536))\n+\t\t (match_operand:SI 2 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"add.w\\\\t%f1,%e0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*addsi3_lshiftrt_16_zexthi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t      (const_int 16))\n+\t\t (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"0\"))))]\n+  \"\"\n+  \"add.w\\\\t%e1,%f0\\;xor.w\\\\t%e0,%e0\\;rotxl.w\\\\t%e0\"\n+  [(set_attr \"length\" \"6\")])\n+\n+(define_insn_and_split \"*addsi3_and_r_1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 1))\n+\t\t (match_operand:SI 2 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (cc0) (compare (zero_extract:SI (match_dup 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 0))\n+\t\t       (const_int 0)))\n+   (set (pc)\n+        (if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))\n+   (set (match_dup 2)\n+        (plus:SI (match_dup 2)\n+\t\t (const_int 1)))\n+   (match_dup 3)]\n+  {\n+    operands[3] = gen_label_rtx ();\n+  })\n+\n+(define_insn_and_split \"*addsi3_and_not_r_1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t\t (const_int 1))\n+\t\t (match_operand:SI 2 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (cc0) (compare (zero_extract:SI (match_dup 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 0))\n+\t\t       (const_int 0)))\n+   (set (pc)\n+        (if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))\n+   (set (match_dup 2)\n+        (plus:SI (match_dup 2)\n+\t\t (const_int 1)))\n+   (match_dup 3)]\n+  {\n+    operands[3] = gen_label_rtx ();\n+  })\n+\n+;; [ix]or:HI\n+\n+(define_insn \"*ixorhi3_zext\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(match_operator:HI 1 \"iorxor_operator\"\n+\t [(zero_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))\n+\t  (match_operand:HI 3 \"register_operand\" \"0\")]))]\n+  \"\"\n+  \"%c1.b\\\\t%X2,%s0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+;; [ix]or:SI\n+\n+(define_insn \"*ixorsi3_zext_qi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 1 \"iorxor_operator\"\n+\t [(zero_extend:SI (match_operand:QI 2 \"register_operand\" \"r\"))\n+\t  (match_operand:SI 3 \"register_operand\" \"0\")]))]\n+  \"\"\n+  \"%c1.b\\\\t%X2,%w0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*ixorsi3_zext_hi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 1 \"iorxor_operator\"\n+\t [(zero_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))\n+\t  (match_operand:SI 3 \"register_operand\" \"0\")]))]\n+  \"\"\n+  \"%c1.w\\\\t%T2,%f0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*ixorsi3_ashift_16\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 1 \"iorxor_operator\"\n+\t [(ashift:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t     (const_int 16))\n+\t  (match_operand:SI 3 \"register_operand\" \"0\")]))]\n+  \"\"\n+  \"%c1.w\\\\t%f2,%e0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*ixorsi3_lshiftrt_16\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 1 \"iorxor_operator\"\n+\t [(lshiftrt:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t       (const_int 16))\n+\t  (match_operand:SI 3 \"register_operand\" \"0\")]))]\n+  \"\"\n+  \"%c1.w\\\\t%e2,%f0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+;; ior:HI\n+\n+(define_insn \"*iorhi3_ashift_8\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ior:HI (ashift:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t   (const_int 8))\n+\t\t(match_operand:HI 2 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"or.b\\\\t%s1,%t0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*iorhi3_lshiftrt_8\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ior:HI (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t     (const_int 8))\n+\t\t(match_operand:HI 2 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"or.b\\\\t%t1,%s0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*iorhi3_two_qi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ior:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"0\"))\n+\t\t(ashift:HI (match_operand:HI 2 \"register_operand\" \"r\")\n+\t\t\t   (const_int 8))))]\n+  \"\"\n+  \"mov.b\\\\t%s2,%t0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*iorhi3_two_qi_mem\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n+\t(ior:HI (zero_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\"))\n+\t\t(ashift:HI (subreg:HI (match_operand:QI 2 \"memory_operand\" \"m\") 0)\n+\t\t\t   (const_int 8))))]\n+  \"\"\n+  \"mov.b\\\\t%X2,%t0\\;mov.b\\\\t%X1,%s0\"\n+  [(set_attr \"length\" \"16\")])\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(ior:HI (zero_extend:HI (match_operand:QI 1 \"memory_operand\" \"\"))\n+\t\t(ashift:HI (subreg:HI (match_operand:QI 2 \"memory_operand\" \"\") 0)\n+\t\t\t   (const_int 8))))]\n+  \"reload_completed\n+   && byte_accesses_mergeable_p (XEXP (operands[2], 0), XEXP (operands[1], 0))\"\n+  [(set (match_dup 0)\n+\t(match_dup 3))]\n+  {\n+    operands[3] = gen_rtx_MEM (HImode, XEXP (operands[2], 0));\n+  })\n+\n+;; ior:SI\n+\n+(define_insn \"*iorsi3_two_hi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"0\"))\n+\t\t(ashift:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t   (const_int 16))))]\n+  \"\"\n+  \"mov.w\\\\t%f2,%e0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn_and_split \"*iorsi3_two_qi_zext\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(ior:SI (zero_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\"))\n+\t\t(and:SI (ashift:SI (subreg:SI (match_operand:QI 2 \"memory_operand\" \"m\") 0)\n+\t\t\t\t   (const_int 8))\n+\t\t\t(const_int 65280))))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3)\n+\t(ior:HI (zero_extend:HI (match_dup 1))\n+\t\t(ashift:HI (subreg:HI (match_dup 2) 0)\n+\t\t\t   (const_int 8))))\n+   (set (match_dup 0)\n+\t(zero_extend:SI (match_dup 3)))]\n+  {\n+    operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));\n+  })\n+\n+(define_insn \"*iorsi3_e2f\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (and:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t(const_int -65536))\n+\t\t(lshiftrt:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t     (const_int 16))))]\n+  \"\"\n+  \"mov.w\\\\t%e2,%f0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn_and_split \"*iorsi3_two_qi_sext\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"0\"))\n+\t\t(ashift:SI (sign_extend:SI (match_operand:QI 2 \"register_operand\" \"r\"))\n+\t\t\t   (const_int 8))))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3)\n+\t(ior:HI (zero_extend:HI (match_dup 1))\n+\t\t(ashift:HI (match_dup 4)\n+\t\t\t   (const_int 8))))\n+   (set (match_dup 0)\n+\t(sign_extend:SI (match_dup 3)))]\n+  {\n+    operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));\n+    operands[4] = gen_rtx_REG (HImode, REGNO (operands[2]));\n+  })\n+\n+(define_insn \"*iorsi3_w\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,&r\")\n+\t(ior:SI (and:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t\t(const_int -256))\n+\t\t(zero_extend:SI (match_operand:QI 2 \"general_operand_src\" \"r,g>\"))))]\n+  \"\"\n+  \"mov.b\\\\t%X2,%w0\"\n+  [(set_attr \"length\" \"2,8\")])\n+\n+(define_insn \"*iorsi3_ashift_31\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t   (const_int 31))\n+\t\t(match_operand:SI 2 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"rotxl.l\\\\t%S0\\;bor\\\\t#0,%w1\\;rotxr.l\\\\t%S0\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"*iorsi3_and_ashift\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (and:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t   (match_operand:SI 2 \"const_int_operand\" \"n\"))\n+\t\t\t(match_operand:SI 3 \"single_one_operand\" \"n\"))\n+\t\t(match_operand:SI 4 \"register_operand\" \"0\")))]\n+  \"(INTVAL (operands[3]) & ~0xffff) == 0\"\n+{\n+  rtx srcpos = GEN_INT (exact_log2 (INTVAL (operands[3]))\n+\t\t\t- INTVAL (operands[2]));\n+  rtx dstpos = GEN_INT (exact_log2 (INTVAL (operands[3])));\n+  operands[2] = srcpos;\n+  operands[3] = dstpos;\n+  return \"bld\\\\t%Z2,%Y1\\;bor\\\\t%Z3,%Y0\\;bst\\\\t%Z3,%Y0\";\n+}\n+  [(set_attr \"length\" \"6\")])\n+\n+(define_insn \"*iorsi3_and_lshiftrt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (and:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\"))\n+\t\t\t(match_operand:SI 3 \"single_one_operand\" \"n\"))\n+\t\t(match_operand:SI 4 \"register_operand\" \"0\")))]\n+  \"((INTVAL (operands[3]) << INTVAL (operands[2])) & ~0xffff) == 0\"\n+{\n+  rtx srcpos = GEN_INT (exact_log2 (INTVAL (operands[3]))\n+\t\t\t+ INTVAL (operands[2]));\n+  rtx dstpos = GEN_INT (exact_log2 (INTVAL (operands[3])));\n+  operands[2] = srcpos;\n+  operands[3] = dstpos;\n+  return \"bld\\\\t%Z2,%Y1\\;bor\\\\t%Z3,%Y0\\;bst\\\\t%Z3,%Y0\";\n+}\n+  [(set_attr \"length\" \"6\")])\n+\n+(define_insn \"*iorsi3_zero_extract\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t (const_int 1)\n+\t\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n+\t\t(match_operand:SI 3 \"register_operand\" \"0\")))]\n+  \"INTVAL (operands[2]) < 16\"\n+  \"bld\\\\t%Z2,%Y1\\;bor\\\\t#0,%w0\\;bst\\\\t#0,%w0\"\n+  [(set_attr \"length\" \"6\")])\n+\n+(define_insn \"*iorsi3_and_lshiftrt_n_sb\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (and:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t     (const_int 30))\n+\t\t\t(const_int 2))\n+\t\t(match_operand:SI 2 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"rotl.l\\\\t%S1\\;rotr.l\\\\t%S1\\;bor\\\\t#1,%w0\\;bst\\\\t#1,%w0\"\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn \"*iorsi3_and_lshiftrt_9_sb\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (and:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t     (const_int 9))\n+\t\t\t(const_int 4194304))\n+\t\t(match_operand:SI 2 \"register_operand\" \"0\")))\n+   (clobber (match_scratch:HI 3 \"=&r\"))]\n+  \"\"\n+{\n+  if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+    return \"shll.l\\\\t%S1\\;xor.w\\\\t%T3,%T3\\;bst\\\\t#6,%s3\\;or.w\\\\t%T3,%e0\";\n+  else\n+    return \"rotl.l\\\\t%S1\\;rotr.l\\\\t%S1\\;xor.w\\\\t%T3,%T3\\;bst\\\\t#6,%s3\\;or.w\\\\t%T3,%e0\";\n+}\n+  [(set_attr \"length\" \"10\")])\n+\n+;; Used to OR the exponent of a float.\n+\n+(define_insn \"*iorsi3_shift\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t   (const_int 23))\n+\t\t(match_operand:SI 2 \"register_operand\" \"0\")))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  \"\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t   (const_int 23))\n+\t\t(match_dup 0)))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n+  \"epilogue_completed\n+   && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n+   && REGNO (operands[0]) != REGNO (operands[1])\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (ashift:HI (match_dup 3)\n+\t\t\t      (const_int 7)))\n+\t      (clobber (scratch:QI))])\n+   (set (match_dup 0)\n+\t(ior:SI (ashift:SI (match_dup 1)\n+\t\t\t   (const_int 16))\n+\t\t(match_dup 0)))]\n+  {\n+    operands[3] = gen_rtx_REG (HImode, REGNO (operands[1]));\n+  })\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t   (const_int 23))\n+\t\t(match_dup 0)))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n+  \"epilogue_completed\n+   && !(find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n+\t&& REGNO (operands[0]) != REGNO (operands[1]))\"\n+  [(set (match_dup 2)\n+\t(match_dup 1))\n+   (parallel [(set (match_dup 3)\n+\t\t   (ashift:HI (match_dup 3)\n+\t\t\t      (const_int 7)))\n+\t      (clobber (scratch:QI))])\n+   (set (match_dup 0)\n+\t(ior:SI (ashift:SI (match_dup 2)\n+\t\t\t   (const_int 16))\n+\t\t(match_dup 0)))]\n+  {\n+    operands[3] = gen_rtx_REG (HImode, REGNO (operands[2]));\n+  })\n+\n+(define_insn \"*iorsi2_and_1_lshiftrt_1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (and:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t(const_int 1))\n+\t\t(lshiftrt:SI (match_dup 1)\n+\t\t\t     (const_int 1))))]\n+  \"\"\n+  \"shlr.l\\\\t%S0\\;bor\\\\t#0,%w0\\;bst\\\\t#0,%w0\"\n+  [(set_attr \"length\" \"6\")])\n+\n+(define_insn_and_split \"*iorsi3_ashift_16_ashift_24\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t   (const_int 16))\n+\t\t(ashift:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t   (const_int 24))))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3)\n+        (ior:HI (ashift:HI (match_dup 4)\n+\t\t\t   (const_int 8))\n+\t\t(match_dup 3)))\n+   (parallel [(set (match_dup 0)\n+\t\t   (ashift:SI (match_dup 0)\n+\t\t\t      (const_int 16)))\n+\t      (clobber (scratch:QI))])]\n+  {\n+    operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));\n+    operands[4] = gen_rtx_REG (HImode, REGNO (operands[2]));\n+  })\n+\n+(define_insn_and_split \"*iorsi3_ashift_16_ashift_24_mem\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(ior:SI (and:SI (ashift:SI (subreg:SI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t\t   (const_int 16))\n+\t\t\t(const_int 16711680))\n+\t\t(ashift:SI (subreg:SI (match_operand:QI 2 \"memory_operand\" \"m\") 0)\n+\t\t\t   (const_int 24))))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3)\n+        (ior:HI (zero_extend:HI (match_dup 1))\n+\t\t(ashift:HI (subreg:HI (match_dup 2) 0)\n+\t\t\t   (const_int 8))))\n+   (parallel [(set (match_dup 0)\n+\t\t   (ashift:SI (match_dup 0)\n+\t\t\t      (const_int 16)))\n+\t      (clobber (scratch:QI))])]\n+  {\n+    operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));\n+  })\n+\n+;; Used to add the exponent of a float.\n+\n+(define_insn \"*addsi3_shift\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t  (const_int 8388608))\n+\t\t (match_operand:SI 2 \"register_operand\" \"0\")))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  \"\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t  (const_int 8388608))\n+\t\t (match_dup 0)))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n+  \"epilogue_completed\n+   && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n+   && REGNO (operands[0]) != REGNO (operands[1])\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (ashift:HI (match_dup 3)\n+\t\t\t      (const_int 7)))\n+\t      (clobber (scratch:QI))])\n+   (set (match_dup 0)\n+\t(plus:SI (mult:SI (match_dup 1)\n+\t\t\t  (const_int 65536))\n+\t\t (match_dup 0)))]\n+  {\n+    operands[3] = gen_rtx_REG (HImode, REGNO (operands[1]));\n+  })\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t  (const_int 8388608))\n+\t\t (match_dup 0)))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n+  \"epilogue_completed\n+   && !(find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n+\t&& REGNO (operands[0]) != REGNO (operands[1]))\"\n+  [(set (match_dup 2)\n+\t(match_dup 1))\n+   (parallel [(set (match_dup 3)\n+\t\t   (ashift:HI (match_dup 3)\n+\t\t\t      (const_int 7)))\n+\t      (clobber (scratch:QI))])\n+   (set (match_dup 0)\n+\t(plus:SI (mult:SI (match_dup 2)\n+\t\t\t  (const_int 65536))\n+\t\t (match_dup 0)))]\n+  {\n+    operands[3] = gen_rtx_REG (HImode, REGNO (operands[2]));\n+  })\n+\n+;; ashift:SI\n+\n+(define_insn_and_split \"*ashiftsi_sextqi_7\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashift:SI (sign_extend:SI (match_operand:QI 1 \"register_operand\" \"0\"))\n+\t\t   (const_int 7)))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 2)\n+\t\t   (ashift:HI (match_dup 2)\n+\t\t\t      (const_int 8)))\n+\t      (clobber (scratch:QI))])\n+   (set (match_dup 0)\n+\t(sign_extend:SI (match_dup 2)))\n+   (parallel [(set (match_dup 0)\n+\t\t   (ashiftrt:SI (match_dup 0)\n+\t\t\t\t(const_int 1)))\n+\t      (clobber (scratch:QI))])]\n+  {\n+    operands[2] = gen_rtx_REG (HImode, REGNO (operands[0]));\n+  })\n+\n+;; Storing a part of HImode to QImode.\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand_dst\" \"=rm<\")\n+\t(subreg:QI (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t\t(const_int 8)) 1))]\n+  \"\"\n+  \"mov.b\\\\t%t1,%R0\"\n+  [(set_attr \"cc\" \"set_znv\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; Storing a part of SImode to QImode.\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand_dst\" \"=rm<\")\n+\t(subreg:QI (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t(const_int 8)) 3))]\n+  \"\"\n+  \"mov.b\\\\t%x1,%R0\"\n+  [(set_attr \"cc\" \"set_znv\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand_dst\" \"=rm<\")\n+\t(subreg:QI (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t(const_int 16)) 3))\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n+  \"\"\n+  \"mov.w\\\\t%e1,%f2\\;mov.b\\\\t%w2,%R0\"\n+  [(set_attr \"cc\" \"set_znv\")\n+   (set_attr \"length\" \"10\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand_dst\" \"=rm<\")\n+\t(subreg:QI (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t(const_int 24)) 3))\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n+  \"\"\n+  \"mov.w\\\\t%e1,%f2\\;mov.b\\\\t%x2,%R0\"\n+  [(set_attr \"cc\" \"set_znv\")\n+   (set_attr \"length\" \"10\")])\n+\n+(define_insn_and_split \"\"\n+  [(set (pc)\n+\t(if_then_else (eq (zero_extract:SI (subreg:SI (match_operand:QI 0 \"register_operand\" \"\") 0)\n+\t\t\t\t\t   (const_int 1)\n+\t\t\t\t\t   (const_int 7))\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"#\"\n+  \"\"\n+  [(set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_dup 1))\n+\t\t      (pc)))]\n+  \"\")\n+\n+(define_insn_and_split \"\"\n+  [(set (pc)\n+\t(if_then_else (ne (zero_extract:SI (subreg:SI (match_operand:QI 0 \"register_operand\" \"\") 0)\n+\t\t\t\t\t   (const_int 1)\n+\t\t\t\t\t   (const_int 7))\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"#\"\n+  \"\"\n+  [(set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_dup 1))\n+\t\t      (pc)))]\n+  \"\")"}, {"sha": "7e0d7f09dc9232fcf3ae262d0405472e749dadf7", "filename": "gcc/config/h8300/divmod.md", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fdivmod.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fdivmod.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fdivmod.md?ref=f5fb834c96ee4dc828299f984c46608814c9f0a2", "patch": "@@ -0,0 +1,99 @@\n+;; ----------------------------------------------------------------------\n+;; DIVIDE/MOD INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"udiv<mode>3\"\n+  [(set (match_operand:HSI 0 \"register_operand\" \"=r\")\n+\t(udiv:HSI (match_operand:HSI 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:HSI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  { return <MODE>mode == HImode ? \"divu.w\\\\t%T2,%T0\" : \"divu.l\\\\t%S2,%S0\"; }\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"div<mode>3\"\n+  [(set (match_operand:HSI 0 \"register_operand\" \"=r\")\n+\t(div:HSI (match_operand:HSI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:HSI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  { return <MODE>mode == HImode ? \"divs.w\\\\t%T2,%T0\" : \"divs.l\\\\t%S2,%S0\"; }\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"udivmodqi4\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(truncate:QI\n+\t  (udiv:HI\n+\t    (match_operand:HI 1 \"register_operand\" \"0\")\n+\t    (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"r\")))))\n+   (set (match_operand:QI 3 \"register_operand\" \"=r\")\n+\t(truncate:QI\n+\t  (umod:HI\n+\t    (match_dup 1)\n+\t    (zero_extend:HI (match_dup 2)))))]\n+  \"\"\n+{\n+  if (find_reg_note (insn, REG_UNUSED, operands[3]))\n+    return \"divxu.b\\\\t%X2,%T0\";\n+  else\n+    return \"divxu.b\\\\t%X2,%T0\\;mov.b\\\\t%t0,%s3\";\n+}\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"divmodqi4\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(truncate:QI\n+\t  (div:HI\n+\t    (match_operand:HI 1 \"register_operand\" \"0\")\n+\t    (sign_extend:HI (match_operand:QI 2 \"register_operand\" \"r\")))))\n+   (set (match_operand:QI 3 \"register_operand\" \"=r\")\n+\t(truncate:QI\n+\t  (mod:HI\n+\t    (match_dup 1)\n+\t    (sign_extend:HI (match_dup 2)))))]\n+  \"\"\n+{\n+  if (find_reg_note (insn, REG_UNUSED, operands[3]))\n+    return \"divxs.b\\\\t%X2,%T0\";\n+  else\n+    return \"divxs.b\\\\t%X2,%T0\\;mov.b\\\\t%t0,%s3\";\n+}\n+  [(set_attr \"length\" \"6\")])\n+\n+(define_insn \"udivmodhi4\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(truncate:HI\n+\t  (udiv:SI\n+\t    (match_operand:SI 1 \"register_operand\" \"0\")\n+\t    (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"r\")))))\n+   (set (match_operand:HI 3 \"register_operand\" \"=r\")\n+\t(truncate:HI\n+\t  (umod:SI\n+\t    (match_dup 1)\n+\t    (zero_extend:SI (match_dup 2)))))]\n+  \"\"\n+{\n+  if (find_reg_note (insn, REG_UNUSED, operands[3]))\n+    return \"divxu.w\\\\t%T2,%S0\";\n+  else\n+    return \"divxu.w\\\\t%T2,%S0\\;mov.w\\\\t%e0,%f3\";\n+}\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"divmodhi4\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(truncate:HI\n+\t  (div:SI\n+\t    (match_operand:SI 1 \"register_operand\" \"0\")\n+\t    (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"r\")))))\n+   (set (match_operand:HI 3 \"register_operand\" \"=r\")\n+\t(truncate:HI\n+\t  (mod:SI\n+\t    (match_dup 1)\n+\t    (sign_extend:SI (match_dup 2)))))]\n+  \"\"\n+{\n+  if (find_reg_note (insn, REG_UNUSED, operands[3]))\n+    return \"divxs.w\\\\t%T2,%S0\";\n+  else\n+    return \"divxs.w\\\\t%T2,%S0\\;mov.w\\\\t%e0,%f3\";\n+}\n+  [(set_attr \"length\" \"6\")])"}, {"sha": "cf6fb6d1eb98734b726f2dea7161b6f44bcac745", "filename": "gcc/config/h8300/extensions.md", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fextensions.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fextensions.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fextensions.md?ref=f5fb834c96ee4dc828299f984c46608814c9f0a2", "patch": "@@ -0,0 +1,152 @@\n+;; ----------------------------------------------------------------------\n+;; EXTEND INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_expand \"zero_extendqi<mode>2\"\n+  [(set (match_operand:HSI 0 \"register_operand\" \"\")\n+\t(zero_extend:HSI (match_operand:QI 1 \"general_operand_src\" \"\")))]\n+  \"\"\n+  {\n+    if (TARGET_H8300SX)\n+      operands[1] = force_reg (QImode, operands[1]);\n+  })\n+\n+(define_insn \"*zero_extendqihi2_h8300hs\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"general_operand_src\" \"0,g>\")))]\n+  \"\"\n+  \"@\n+  extu.w\t%T0\n+  #\"\n+  [(set_attr \"length\" \"2,10\")\n+   (set_attr \"cc\" \"set_znv,set_znv\")])\n+\n+;; Split the zero extension of a general operand (actually a memory\n+;; operand) into a load of the operand and the actual zero extension\n+;; so that 1) the length will be accurate, and 2) the zero extensions\n+;; appearing at the end of basic blocks may be merged.\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(zero_extend:HI (match_operand:QI 1 \"general_operand_src\" \"\")))]\n+  \"reload_completed\"\n+  [(set (match_dup 2)\n+\t(match_dup 1))\n+   (set (match_dup 0)\n+\t(zero_extend:HI (match_dup 2)))]\n+  {\n+    operands[2] = gen_rtx_REG (QImode, REGNO (operands[0]));\n+  })\n+\n+(define_insn \"*zero_extendqisi2_h8300hs\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"general_operand_src\" \"0,g>\")))]\n+  \"!TARGET_H8300SX\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:QI 1 \"general_operand_src\" \"\")))]\n+  \"!TARGET_H8300SX\n+    && reg_overlap_mentioned_p (operands[0], operands[1])\n+    && reload_completed\"\n+  [(set (match_dup 2)\n+\t(match_dup 1))\n+   (set (match_dup 3)\n+\t(zero_extend:HI (match_dup 2)))\n+   (set (match_dup 0)\n+\t(zero_extend:SI (match_dup 3)))]\n+  {\n+    operands[2] = gen_lowpart (QImode, operands[0]);\n+    operands[3] = gen_lowpart (HImode, operands[0]);\n+  })\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:QI 1 \"general_operand_src\" \"\")))]\n+  \"!TARGET_H8300SX\n+    && !reg_overlap_mentioned_p (operands[0], operands[1])\n+    && reload_completed\"\n+  [(set (match_dup 0)\n+\t(const_int 0))\n+   (set (strict_low_part (match_dup 2))\n+\t(match_dup 1))]\n+  {\n+    operands[2] = gen_rtx_REG (QImode, REGNO (operands[0]));\n+  })\n+\n+(define_insn \"*zero_extendqisi2_h8sx\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"TARGET_H8300SX\"\n+  \"extu.l\\t#2,%0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_expand \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*zero_extendhisi2_h8300hs\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"extu.l\t%S0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_expand \"extendqi<mode>2\"\n+  [(set (match_operand:HSI 0 \"register_operand\" \"\")\n+\t(sign_extend:HSI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*extendqihi2_h8300hs\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"exts.w\t%T0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+;; The following pattern is needed because without the pattern, the\n+;; combiner would split (sign_extend:SI (reg:QI)) into two 24-bit\n+;; shifts, one ashift and one ashiftrt.\n+\n+(define_insn_and_split \"*extendqisi2_h8300hs\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"!TARGET_H8300SX\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 2)\n+\t(sign_extend:HI (match_dup 1)))\n+   (set (match_dup 0)\n+\t(sign_extend:SI (match_dup 2)))]\n+  {\n+    operands[2] = gen_rtx_REG (HImode, REGNO (operands[0]));\n+  })\n+\n+(define_insn \"*extendqisi2_h8sx\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"TARGET_H8300SX\"\n+  \"exts.l\\t#2,%0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_expand \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*extendhisi2_h8300hs\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"exts.l\t%S0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_znv\")])"}, {"sha": "e9b598d375a687e66e25d73e1fed27608165ce16", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 13, "deletions": 3144, "changes": 3157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=f5fb834c96ee4dc828299f984c46608814c9f0a2"}, {"sha": "4c0a5ccf8af4d66088001a1978b44964fdfe99d1", "filename": "gcc/config/h8300/jumpcall.md", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fjumpcall.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fjumpcall.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fjumpcall.md?ref=f5fb834c96ee4dc828299f984c46608814c9f0a2", "patch": "@@ -0,0 +1,306 @@\n+;; ----------------------------------------------------------------------\n+;; JUMP INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+;; Conditional jump instructions\n+\n+(define_expand \"cbranchqi4\"\n+  [(use (match_operator 0 \"ordered_comparison_operator\"\n+         [(match_operand:QI 1 \"h8300_dst_operand\" \"\")\n+          (match_operand:QI 2 \"h8300_src_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n+  \"\"\n+  {\n+    h8300_expand_branch (operands);\n+    DONE;\n+  })\n+\n+(define_expand \"cbranchhi4\"\n+  [(use (match_operator 0 \"ordered_comparison_operator\"\n+         [(match_operand:HI 1 \"h8300_dst_operand\" \"\")\n+          (match_operand:HI 2 \"h8300_src_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n+  \"\"\n+  {\n+    h8300_expand_branch (operands);\n+    DONE;\n+  })\n+\n+(define_expand \"cbranchsi4\"\n+  [(use (match_operator 0 \"ordered_comparison_operator\"\n+         [(match_operand:SI 1 \"h8300_dst_operand\" \"\")\n+          (match_operand:SI 2 \"h8300_src_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n+  \"\"\n+  {\n+    h8300_expand_branch (operands);\n+    DONE;\n+  })\n+\n+(define_insn \"branch_true\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+{\n+  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0\n+      && (GET_CODE (operands[1]) == GT\n+\t  || GET_CODE (operands[1]) == GE\n+\t  || GET_CODE (operands[1]) == LE\n+\t  || GET_CODE (operands[1]) == LT))\n+    {\n+      cc_status.flags &= ~CC_OVERFLOW_UNUSABLE;\n+      return 0;\n+    }\n+\n+  if (get_attr_length (insn) == 2)\n+    return \"b%j1\t%l0\";\n+  else if (get_attr_length (insn) == 4)\n+    return \"b%j1\t%l0:16\";\n+  else\n+    return \"b%k1\t.Lh8BR%=\\;jmp\t@%l0\\\\n.Lh8BR%=:\";\n+}\n+ [(set_attr \"type\" \"branch\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"branch_false\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+{\n+  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0\n+      && (GET_CODE (operands[1]) == GT\n+\t  || GET_CODE (operands[1]) == GE\n+\t  || GET_CODE (operands[1]) == LE\n+\t  || GET_CODE (operands[1]) == LT))\n+    {\n+      cc_status.flags &= ~CC_OVERFLOW_UNUSABLE;\n+      return 0;\n+    }\n+\n+  if (get_attr_length (insn) == 2)\n+    return \"b%k1\t%l0\";\n+  else if (get_attr_length (insn) == 4)\n+    return \"b%k1\t%l0:16\";\n+  else\n+    return \"b%j1\t.Lh8BR%=\\;jmp\t@%l0\\\\n.Lh8BR%=:\";\n+}\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"*brabc\"\n+  [(set (pc)\n+\t(if_then_else (eq (zero_extract (match_operand:QI 1 \"bit_memory_operand\" \"WU\")\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(match_operand:QI 2 \"immediate_operand\" \"n\"))\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_H8300SX\"\n+{\n+  switch (get_attr_length (insn)\n+\t  - h8300_insn_length_from_table (insn, operands))\n+    {\n+    case 2:\n+      return \"bra/bc\t%2,%R1,%l0\";\n+    case 4:\n+      return \"bra/bc\t%2,%R1,%l0:16\";\n+    default:\n+      return \"bra/bs\t%2,%R1,.Lh8BR%=\\;jmp\t@%l0\\\\n.Lh8BR%=:\";\n+    }\n+}\n+  [(set_attr \"type\" \"bitbranch\")\n+   (set_attr \"length_table\" \"bitbranch\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"*brabs\"\n+  [(set (pc)\n+\t(if_then_else (ne (zero_extract (match_operand:QI 1 \"bit_memory_operand\" \"WU\")\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(match_operand:QI 2 \"immediate_operand\" \"n\"))\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_H8300SX\"\n+{\n+  switch (get_attr_length (insn)\n+\t  - h8300_insn_length_from_table (insn, operands))\n+    {\n+    case 2:\n+      return \"bra/bs\t%2,%R1,%l0\";\n+    case 4:\n+      return \"bra/bs\t%2,%R1,%l0:16\";\n+    default:\n+      return \"bra/bc\t%2,%R1,.Lh8BR%=\\;jmp\t@%l0\\\\n.Lh8BR%=:\";\n+    }\n+}\n+  [(set_attr \"type\" \"bitbranch\")\n+   (set_attr \"length_table\" \"bitbranch\")\n+   (set_attr \"cc\" \"none\")])\n+\n+;; Unconditional and other jump instructions.\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+{\n+  if (final_sequence != 0)\n+    {\n+      if (get_attr_length (insn) == 2)\n+\treturn \"bra/s\t%l0\";\n+      else\n+\t{\n+\t  /* The branch isn't short enough to use bra/s.  Output the\n+\t     branch and delay slot in their normal order.\n+\n+\t     If this is a backward branch, it will now be branching two\n+\t     bytes further than previously thought.  The length-based\n+\t     test for bra vs. jump is very conservative though, so the\n+\t     branch will still be within range.  */\n+\t  rtx_sequence *seq;\n+\t  int seen;\n+\n+\t  seq = final_sequence;\n+\t  final_sequence = 0;\n+\t  final_scan_insn (seq->insn (1), asm_out_file, optimize, 1, & seen);\n+\t  final_scan_insn (seq->insn (0), asm_out_file, optimize, 1, & seen);\n+\t  seq->insn (1)->set_deleted ();\n+\t  return \"\";\n+\t}\n+    }\n+  else if (get_attr_length (insn) == 2)\n+    return \"bra\t%l0\";\n+  else if (get_attr_length (insn) == 4)\n+    return \"bra\t%l0:16\";\n+  else\n+    return \"jmp\t@%l0\";\n+}\n+  [(set_attr \"type\" \"branch\")\n+   (set (attr \"delay_slot\")\n+\t(if_then_else (match_test \"TARGET_H8300SX\")\n+\t\t      (const_string \"jump\")\n+\t\t      (const_string \"none\")))\n+   (set_attr \"cc\" \"none\")])\n+\n+;; This is a define expand, because pointers may be either 16 or 32 bits.\n+\n+(define_expand \"tablejump\"\n+  [(parallel [(set (pc) (match_operand 0 \"register_operand\" \"\"))\n+\t      (use (label_ref (match_operand 1 \"\" \"\")))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"tablejump<mode>\"\n+  [(set (pc) (match_operand:P 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  {\n+    if (<MODE>mode == E_HImode)\n+      return \"jmp\t@%0\";\n+    if (<MODE>mode == E_SImode)\n+      return \"jmp\t@%S0\";\n+    abort ();\n+  }\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"2\")])\n+\n+;; This is a define expand, because pointers may be either 16 or 32 bits.\n+\n+(define_expand \"indirect_jump\"\n+  [(set (pc) (match_operand 0 \"jump_address_operand\" \"\"))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*indirect_jump_<mode>\"\n+  [(set (pc) (match_operand:P 0 \"jump_address_operand\" \"Vr\"))]\n+  \"\"\n+  {\n+    if (<MODE>mode == E_HImode)\n+      return \"jmp\t@%0\";\n+    if (<MODE>mode == E_SImode)\n+      return \"jmp\t@%S0\";\n+    abort ();\n+  }\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"2\")])\n+\n+;; Call subroutine with no return value.\n+\n+;; ??? Even though we use HImode here, this works on the H8/300H and H8S.\n+\n+(define_expand \"call\"\n+  [(call (match_operand:QI 0 \"call_expander_operand\" \"\")\n+\t (match_operand 1 \"general_operand\" \"\"))]\n+  \"\"\n+  {\n+    if (!register_operand (XEXP (operands[0], 0), Pmode)\n+\t&& GET_CODE (XEXP (operands[0], 0)) != SYMBOL_REF)\n+      XEXP (operands[0], 0) = force_reg (Pmode, XEXP (operands[0], 0));\n+  })\n+\n+(define_insn \"call_insn_<mode>\"\n+  [(call (mem:QI (match_operand 0 \"call_insn_operand\" \"Cr\"))\n+\t         (match_operand:P 1 \"general_operand\" \"g\"))]\n+  \"\"\n+{\n+  rtx xoperands[1];\n+  xoperands[0] = gen_rtx_MEM (QImode, operands[0]);\n+  gcc_assert (GET_MODE (operands[0]) == Pmode);\n+  if (GET_CODE (XEXP (xoperands[0], 0)) == SYMBOL_REF\n+      && (SYMBOL_REF_FLAGS (XEXP (xoperands[0], 0)) & SYMBOL_FLAG_FUNCVEC_FUNCTION))\n+    output_asm_insn (\"jsr\\\\t@%0:8\", xoperands);\n+  else\n+    output_asm_insn (\"jsr\\\\t%0\", xoperands);\n+  return \"\";\n+}\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\")\n+\t(if_then_else (match_operand:QI 0 \"small_call_insn_operand\" \"\")\n+\t\t      (const_int 2)\n+\t\t      (const_int 4)))])\n+\n+;; Call subroutine, returning value in operand 0\n+;; (which must be a hard register).\n+\n+;; ??? Even though we use HImode here, this works on the H8/300H and H8S.\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (match_operand:QI 1 \"call_expander_operand\" \"\")\n+\t      (match_operand 2 \"general_operand\" \"\")))]\n+  \"\"\n+  {\n+    if (!register_operand (XEXP (operands[1], 0), Pmode)\n+\t&& GET_CODE (XEXP (operands[1], 0)) != SYMBOL_REF)\n+      XEXP (operands[1], 0) = force_reg (Pmode, XEXP (operands[1], 0));\n+  })\n+\n+(define_insn \"call_value_insn_<mode>\"\n+  [(set (match_operand 0 \"\" \"=r\")\n+\t(call (mem:QI (match_operand 1 \"call_insn_operand\" \"Cr\"))\n+\t\t      (match_operand:P 2 \"general_operand\" \"g\")))]\n+  \"\"\n+{\n+  rtx xoperands[2];\n+  gcc_assert (GET_MODE (operands[1]) == Pmode);\n+  xoperands[0] = operands[0];\n+  xoperands[1] = gen_rtx_MEM (QImode, operands[1]);\n+  if (GET_CODE (XEXP (xoperands[1], 0)) == SYMBOL_REF\n+      && (SYMBOL_REF_FLAGS (XEXP (xoperands[1], 0)) & SYMBOL_FLAG_FUNCVEC_FUNCTION))\n+    output_asm_insn (\"jsr\\\\t@%1:8\", xoperands);\n+  else\n+    output_asm_insn (\"jsr\\\\t%1\", xoperands);\n+  return \"\";\n+}\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\")\n+\t(if_then_else (match_operand:QI 0 \"small_call_insn_operand\" \"\")\n+\t\t      (const_int 2)\n+\t\t      (const_int 4)))])\n+"}, {"sha": "9dd863cdd8c6371d43d5e569943442787be20204", "filename": "gcc/config/h8300/logical.md", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Flogical.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Flogical.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Flogical.md?ref=f5fb834c96ee4dc828299f984c46608814c9f0a2", "patch": "@@ -0,0 +1,204 @@\n+;; ----------------------------------------------------------------------\n+;; AND INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"bclrqi_msx\"\n+  [(set (match_operand:QI 0 \"bit_register_indirect_operand\" \"=WU\")\n+\t(and:QI (match_operand:QI 1 \"bit_register_indirect_operand\" \"%0\")\n+\t\t(match_operand:QI 2 \"single_zero_operand\" \"Y0\")))]\n+  \"TARGET_H8300SX && rtx_equal_p (operands[0], operands[1])\"\n+  \"bclr\\\\t%W2,%0\"\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"bit_register_indirect_operand\")\n+\t(and:HI (match_operand:HI 1 \"bit_register_indirect_operand\")\n+\t\t(match_operand:HI 2 \"single_zero_operand\")))]\n+  \"TARGET_H8300SX\"\n+  [(set (match_dup 0)\n+\t(and:QI (match_dup 1)\n+\t\t(match_dup 2)))]\n+  {\n+    if (abs (INTVAL (operands[2])) > 0xFF)\n+      {\n+\toperands[0] = adjust_address (operands[0], QImode, 0);\n+\toperands[1] = adjust_address (operands[1], QImode, 0);\n+\toperands[2] = GEN_INT ((INTVAL (operands[2])) >> 8);\n+      }\n+    else\n+      {\n+\toperands[0] = adjust_address (operands[0], QImode, 1);\n+\toperands[1] = adjust_address (operands[1], QImode, 1);\n+      }\n+  })\n+\n+(define_insn \"bclrhi_msx\"\n+  [(set (match_operand:HI 0 \"bit_register_indirect_operand\" \"=m\")\n+\t(and:HI (match_operand:HI 1 \"bit_register_indirect_operand\" \"%0\")\n+\t\t(match_operand:HI 2 \"single_zero_operand\" \"Y0\")))]\n+  \"TARGET_H8300SX\"\n+  \"bclr\\\\t%W2,%0\"\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn \"*andqi3_2\"\n+  [(set (match_operand:QI 0 \"bit_operand\" \"=U,rQ,r\")\n+\t(and:QI (match_operand:QI 1 \"bit_operand\" \"%0,0,WU\")\n+\t\t(match_operand:QI 2 \"h8300_src_operand\" \"Y0,rQi,IP1>X\")))]\n+  \"TARGET_H8300SX\"\n+  \"@\n+   bclr\\\\t %W2,%R0\n+   and  %X2,%X0\n+   bfld %2,%1,%R0\"\n+  [(set_attr \"length\" \"8,*,8\")\n+   (set_attr \"length_table\" \"*,logicb,*\")\n+   (set_attr \"cc\" \"none_0hit,set_znv,none_0hit\")])\n+\n+(define_insn \"andqi3_1\"\n+  [(set (match_operand:QI 0 \"bit_operand\" \"=U,r\")\n+\t(and:QI (match_operand:QI 1 \"bit_operand\" \"%0,0\")\n+\t\t(match_operand:QI 2 \"h8300_src_operand\" \"Y0,rn\")))]\n+  \"register_operand (operands[0], QImode)\n+   || single_zero_operand (operands[2], QImode)\"\n+  \"@\n+   bclr %W2,%R0\n+   and  %X2,%X0\"\n+  [(set_attr \"length\" \"2,8\")\n+   (set_attr \"cc\" \"none_0hit,set_znv\")])\n+\n+(define_expand \"and<mode>3\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"\")\n+\t(and:QHSI (match_operand:QHSI 1 \"register_operand\" \"\")\n+\t\t  (match_operand:QHSI 2 \"h8300_src_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*andor<mode>3\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"=r\")\n+\t(ior:QHSI (and:QHSI (match_operand:QHSI 2 \"register_operand\" \"r\")\n+\t\t\t    (match_operand:QHSI 3 \"single_one_operand\" \"n\"))\n+\t\t  (match_operand:QHSI 1 \"register_operand\" \"0\")))]\n+  \"(<MODE>mode == QImode\n+    || <MODE>mode == HImode\n+    || (<MODE>mode == SImode\n+\t&& (INTVAL (operands[3]) & 0xffff) != 0))\"\n+  {\n+    if (<MODE>mode == QImode)\n+      return \"bld\\\\t%V3,%X2\\;bor\\\\t%V3,%X0\\;bst\\\\t%V3,%X0\";\n+\n+    if (<MODE>mode == HImode)\n+      {\n+\toperands[3] = GEN_INT (INTVAL (operands[3]) & 0xffff);\n+\tif (INTVAL (operands[3]) > 128)\n+\t  {\n+\t    operands[3] = GEN_INT (INTVAL (operands[3]) >> 8);\n+\t    return \"bld\\\\t%V3,%t2\\;bor\\\\t%V3,%t0\\;bst\\\\t%V3,%t0\";\n+\t  }\n+\treturn \"bld\\\\t%V3,%s2\\;bor\\\\t%V3,%s0\\;bst\\\\t%V3,%s0\";\n+      }\n+\n+    if (<MODE>mode == SImode)\n+      {\n+\toperands[3] = GEN_INT (INTVAL (operands[3]) & 0xffff);\n+\tif (INTVAL (operands[3]) > 128)\n+\t  {\n+\t    operands[3] = GEN_INT (INTVAL (operands[3]) >> 8);\n+\t    return \"bld\\\\t%V3,%x2\\;bor\\\\t%V3,%x0\\;bst\\\\t%V3,%x0\";\n+\t  }\n+\treturn \"bld\\\\t%V3,%w2\\;bor\\\\t%V3,%w0\\;bst\\\\t%V3,%w0\";\n+      }\n+\n+    gcc_unreachable ();\n+\t\n+  }\n+  [(set_attr \"length\" \"6\")])\n+\n+(define_insn \"*andorsi3_shift_8\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (and:SI (ashift:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t   (const_int 8))\n+\t\t\t(const_int 65280))\n+\t\t(match_operand:SI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"or.b\\\\t%w2,%x0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+;; ----------------------------------------------------------------------\n+;; OR/XOR INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"b<code>qi_msx\"\n+  [(set (match_operand:QI 0 \"bit_register_indirect_operand\" \"=WU\")\n+\t(ors:QI (match_operand:QI 1 \"bit_register_indirect_operand\" \"%0\")\n+\t\t(match_operand:QI 2 \"single_one_operand\" \"Y2\")))]\n+  \"TARGET_H8300SX && rtx_equal_p (operands[0], operands[1])\"\n+  { return <CODE> == IOR ? \"bset\\\\t%V2,%0\" : \"bnot\\\\t%V2,%0\"; }\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn \"b<code>hi_msx\"\n+  [(set (match_operand:HI 0 \"bit_register_indirect_operand\" \"=m\")\n+\t(ors:HI (match_operand:HI 1 \"bit_register_indirect_operand\" \"%0\")\n+\t\t(match_operand:HI 2 \"single_one_operand\" \"Y2\")))]\n+  \"TARGET_H8300SX\"\n+  { return <CODE> == IOR ? \"bset\\\\t%V2,%0\" : \"bnot\\\\t%V2,%0\"; }\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn \"<code>qi3_1\"\n+  [(set (match_operand:QI 0 \"bit_operand\" \"=U,rQ\")\n+\t(ors:QI (match_operand:QI 1 \"bit_operand\" \"%0,0\")\n+\t\t(match_operand:QI 2 \"h8300_src_operand\" \"Y2,rQi\")))]\n+  \"TARGET_H8300SX || register_operand (operands[0], QImode)\n+   || single_one_operand (operands[2], QImode)\"\n+  {\n+    if (which_alternative == 0)\n+      return <CODE> == IOR ? \"bset\\\\t%V2,%R0\" : \"bnot\\\\t%V2,%R0\"; \n+    else if (which_alternative == 1)\n+      return <CODE> == IOR ? \"or\\\\t%X2,%X0\" : \"xor\\\\t%X2,%X0\";\n+    gcc_unreachable ();\n+  }\n+  [(set_attr \"length\" \"8,*\")\n+   (set_attr \"length_table\" \"*,logicb\")\n+   (set_attr \"cc\" \"none_0hit,set_znv\")])\n+\n+(define_expand \"<code><mode>3\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"\")\n+\t(ors:QHSI (match_operand:QHSI 1 \"register_operand\" \"\")\n+\t\t  (match_operand:QHSI 2 \"h8300_src_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+;; ----------------------------------------------------------------------\n+;; {AND,IOR,XOR}{HI3,SI3} PATTERNS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"*logical<mode>3\"\n+  [(set (match_operand:HSI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(match_operator:HSI 3 \"bit_operator\"\n+\t  [(match_operand:HSI 1 \"h8300_dst_operand\" \"%0\")\n+\t   (match_operand:HSI 2 \"h8300_src_operand\" \"rQi\")]))]\n+  \"h8300_operands_match_p (operands)\"\n+  { return output_logical_op (<MODE>mode, operands); }\n+  [(set (attr \"length\")\n+\t(symbol_ref \"compute_logical_op_length (<MODE>mode, operands)\"))\n+   (set (attr \"cc\")\n+\t(symbol_ref \"compute_logical_op_cc (<MODE>mode, operands)\"))])\n+\n+\f\n+;; ----------------------------------------------------------------------\n+;; NOT INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"one_cmpl<mode>2\"\n+  [(set (match_operand:QHSI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(not:QHSI (match_operand:QHSI 1 \"h8300_dst_operand\" \"0\")))]\n+  \"\"\n+  {\n+    if (<MODE>mode == E_QImode)\n+      return \"not\t%X0\";\n+    if (<MODE>mode == E_HImode)\n+      return \"not.w\t%T0\";\n+    if (<MODE>mode == E_SImode)\n+      return \"not.l\t%S0\";\n+    gcc_unreachable ();\n+  }\n+  [(set_attr \"length_table\" \"unary\")\n+   (set_attr \"cc\" \"set_znv\")])"}, {"sha": "a8241b90a45ea0f4e65d0820200701af15d7b8d8", "filename": "gcc/config/h8300/movepush.md", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fmovepush.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fmovepush.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fmovepush.md?ref=f5fb834c96ee4dc828299f984c46608814c9f0a2", "patch": "@@ -0,0 +1,233 @@\n+;; ----------------------------------------------------------------------\n+;; MOVE INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+;; movqi\n+\n+(define_insn \"*movqi_h8nosx\"\n+  [(set (match_operand:QI 0 \"general_operand_dst\" \"=r,r ,<,r,r,m\")\n+\t(match_operand:QI 1 \"general_operand_src\" \" I,r>,r,n,m,r\"))]\n+  \"!TARGET_H8300SX\n+    && h8300_move_ok (operands[0], operands[1])\"\n+  \"@\n+   sub.b\t%X0,%X0\n+   mov.b\t%R1,%X0\n+   mov.b\t%X1,%R0\n+   mov.b\t%R1,%X0\n+   mov.b\t%R1,%X0\n+   mov.b\t%X1,%R0\"\n+  [(set (attr \"length\")\n+\t(symbol_ref \"compute_mov_length (operands)\"))\n+   (set_attr \"cc\" \"set_zn,set_znv,set_znv,set_znv,set_znv,set_znv\")])\n+\n+(define_insn \"*movqi_h8sx\"\n+  [(set (match_operand:QI 0 \"general_operand_dst\" \"=Z,rQ\")\n+\t(match_operand:QI 1 \"general_operand_src\" \"P4>X,rQi\"))]\n+  \"TARGET_H8300SX\"\n+  \"@\n+    mov.b\t%X1:4,%X0\n+    mov.b\t%X1,%X0\"\n+  [(set_attr \"length_table\" \"mov_imm4,movb\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:QHSIF 0 \"general_operand_dst\" \"\")\n+\t(match_operand:QHSIF 1 \"general_operand_src\" \"\"))]\n+  \"\"\n+  {\n+    enum machine_mode mode = <MODE>mode;\n+    if (!TARGET_H8300SX)\n+      {\n+\t/* Other H8 chips, except the H8/SX family can only handle a\n+\t   single memory operand, which is checked by h8300_move_ok.\n+\n+\t   We could perhaps have h8300_move_ok handle the H8/SX better\n+\t   and just remove the !TARGET_H8300SX conditional.  */\n+\tif (!h8300_move_ok (operands[0], operands[1]))\n+\t  operands[1] = copy_to_mode_reg (mode, operand1);\n+      }\n+  })\n+\n+(define_insn \"movstrictqi\"\n+  [(set (strict_low_part (match_operand:QI 0 \"general_operand_dst\" \"+r,r\"))\n+\t\t\t (match_operand:QI 1 \"general_operand_src\" \"I,rmi>\"))]\n+  \"\"\n+  \"@\n+   sub.b\t%X0,%X0\n+   mov.b\t%X1,%X0\"\n+  [(set_attr \"length\" \"2,*\")\n+   (set_attr \"length_table\" \"*,movb\")\n+   (set_attr \"cc\" \"set_zn,set_znv\")])\n+\n+;; movhi\n+\n+(define_insn \"*movhi_h8nosx\"\n+  [(set (match_operand:HI 0 \"general_operand_dst\" \"=r,r,<,r,r,m\")\n+\t(match_operand:HI 1 \"general_operand_src\" \"I,r>,r,i,m,r\"))]\n+  \"!TARGET_H8300SX\n+    && h8300_move_ok (operands[0], operands[1])\"\n+  \"@\n+   sub.w\t%T0,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\"\n+  [(set (attr \"length\")\n+\t(symbol_ref \"compute_mov_length (operands)\"))\n+   (set_attr \"cc\" \"set_zn,set_znv,set_znv,set_znv,set_znv,set_znv\")])\n+\n+(define_insn \"*movhi_h8sx\"\n+  [(set (match_operand:HI 0 \"general_operand_dst\" \"=r,r,Z,Q,rQ\")\n+\t(match_operand:HI 1 \"general_operand_src\" \"I,P3>X,P4>X,IP8>X,rQi\"))]\n+  \"TARGET_H8300SX\"\n+  \"@\n+   sub.w\t%T0,%T0\n+   mov.w\t%T1:3,%T0\n+   mov.w\t%T1:4,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\"\n+  [(set_attr \"length_table\" \"*,*,mov_imm4,short_immediate,movw\")\n+   (set_attr \"length\" \"2,2,*,*,*\")\n+   (set_attr \"cc\" \"set_zn,set_znv,set_znv,set_znv,set_znv\")])\n+\n+(define_insn \"movstricthi\"\n+  [(set (strict_low_part (match_operand:HI 0 \"general_operand_dst\" \"+r,r,r\"))\n+\t\t\t (match_operand:HI 1 \"general_operand_src\" \"I,P3>X,rmi\"))]\n+  \"\"\n+  \"@\n+   sub.w\t%T0,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\"\n+  [(set_attr \"length\" \"2,2,*\")\n+   (set_attr \"length_table\" \"*,*,movw\")\n+   (set_attr \"cc\" \"set_zn,set_znv,set_znv\")])\n+\n+;; movsi\n+(define_insn \"*movsi_h8300hs\"\n+  [(set (match_operand:SI 0 \"general_operand_dst\" \"=r,r,r,<,r,r,m,*a,*a,r\")\n+\t(match_operand:SI 1 \"general_operand_src\" \"I,r,i,r,>,m,r,I,r,*a\"))]\n+  \"(TARGET_H8300S || TARGET_H8300H) && !TARGET_H8300SX\n+    && h8300_move_ok (operands[0], operands[1])\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"sub.l\t%S0,%S0\";\n+    case 7:\n+      return \"clrmac\";\n+    case 8:\n+      return \"clrmac\\;ldmac %1,macl\";\n+    case 9:\n+      return \"stmac\tmacl,%0\";\n+    default:\n+      if (GET_CODE (operands[1]) == CONST_INT)\n+\t{\n+\t  int val = INTVAL (operands[1]);\n+\n+\t  /* Look for constants which can be made by adding an 8-bit\n+\t     number to zero in one of the two low bytes.  */\n+\t  if (val == (val & 0xff))\n+\t    {\n+\t      operands[1] = GEN_INT ((char) val & 0xff);\n+\t      return \"sub.l\\\\t%S0,%S0\\;add.b\\\\t%1,%w0\";\n+\t    }\n+\n+\t  if (val == (val & 0xff00))\n+\t    {\n+\t      operands[1] = GEN_INT ((char) (val >> 8) & 0xff);\n+\t      return \"sub.l\\\\t%S0,%S0\\;add.b\\\\t%1,%x0\";\n+\t    }\n+\n+\t  /* Look for constants that can be obtained by subs, inc, and\n+\t     dec to 0.  */\n+\t  switch (val & 0xffffffff)\n+\t    {\n+\t    case 0xffffffff:\n+\t      return \"sub.l\\\\t%S0,%S0\\;subs\\\\t#1,%S0\";\n+\t    case 0xfffffffe:\n+\t      return \"sub.l\\\\t%S0,%S0\\;subs\\\\t#2,%S0\";\n+\t    case 0xfffffffc:\n+\t      return \"sub.l\\\\t%S0,%S0\\;subs\\\\t#4,%S0\";\n+\n+\t    case 0x0000ffff:\n+\t      return \"sub.l\\\\t%S0,%S0\\;dec.w\\\\t#1,%f0\";\n+\t    case 0x0000fffe:\n+\t      return \"sub.l\\\\t%S0,%S0\\;dec.w\\\\t#2,%f0\";\n+\n+\t    case 0xffff0000:\n+\t      return \"sub.l\\\\t%S0,%S0\\;dec.w\\\\t#1,%e0\";\n+\t    case 0xfffe0000:\n+\t      return \"sub.l\\\\t%S0,%S0\\;dec.w\\\\t#2,%e0\";\n+\n+\t    case 0x00010000:\n+\t      return \"sub.l\\\\t%S0,%S0\\;inc.w\\\\t#1,%e0\";\n+\t    case 0x00020000:\n+\t      return \"sub.l\\\\t%S0,%S0\\;inc.w\\\\t#2,%e0\";\n+\t    }\n+\t}\n+    }\n+   return \"mov.l\t%S1,%S0\";\n+}\n+  [(set (attr \"length\")\n+\t(symbol_ref \"compute_mov_length (operands)\"))\n+   (set_attr \"cc\" \"set_zn,set_znv,clobber,set_znv,set_znv,set_znv,set_znv,none_0hit,none_0hit,set_znv\")])\n+\n+(define_insn \"*movsi_h8sx\"\n+  [(set (match_operand:SI 0 \"general_operand_dst\" \"=r,r,Q,rQ,*a,*a,r\")\n+\t(match_operand:SI 1 \"general_operand_src\" \"I,P3>X,IP8>X,rQi,I,r,*a\"))]\n+  \"TARGET_H8300SX\"\n+  \"@\n+   sub.l\t%S0,%S0\n+   mov.l\t%S1:3,%S0\n+   mov.l\t%S1,%S0\n+   mov.l\t%S1,%S0\n+   clrmac\n+   clrmac\\;ldmac\t%1,macl\n+   stmac\tmacl,%0\"\n+  [(set_attr \"length_table\" \"*,*,short_immediate,movl,*,*,*\")\n+   (set_attr \"length\" \"2,2,*,*,2,6,4\")\n+   (set_attr \"cc\" \"set_zn,set_znv,set_znv,set_znv,none_0hit,none_0hit,set_znv\")])\n+\n+(define_insn \"*movsf_h8sx\"\n+  [(set (match_operand:SF 0 \"general_operand_dst\" \"=r,rQ\")\n+\t(match_operand:SF 1 \"general_operand_src\" \"G,rQi\"))]\n+  \"TARGET_H8300SX\"\n+  \"@\n+    sub.l\t%S0,%S0\n+    mov.l\t%S1,%S0\"\n+  [(set_attr \"length\" \"2,*\")\n+   (set_attr \"length_table\" \"*,movl\")\n+   (set_attr \"cc\" \"set_zn,set_znv\")])\n+\n+(define_insn \"*movsf_h8300hs\"\n+  [(set (match_operand:SF 0 \"general_operand_dst\" \"=r,r,r,m,<,r\")\n+\t(match_operand:SF 1 \"general_operand_src\" \"G,r,im,r,r,>\"))]\n+  \"!TARGET_H8300SX\n+    && (register_operand (operands[0], SFmode)\n+\t|| register_operand (operands[1], SFmode))\"\n+  \"@\n+   sub.l\t%S0,%S0\n+   mov.l\t%S1,%S0\n+   mov.l\t%S1,%S0\n+   mov.l\t%S1,%S0\n+   mov.l\t%S1,%S0\n+   mov.l\t%S1,%S0\"\n+  [(set (attr \"length\")\n+\t(symbol_ref \"compute_mov_length (operands)\"))\n+   (set_attr \"cc\" \"set_zn,set_znv,set_znv,set_znv,set_znv,set_znv\")])\n+\f\n+;; ----------------------------------------------------------------------\n+;; PUSH INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"*push1_h8300hs_<QHI:mode>\"\n+  [(set (mem:QHI\n+\t(pre_modify:P\n+\t  (reg:P SP_REG)\n+\t  (plus:P (reg:P SP_REG) (const_int -4))))\n+\t(match_operand:QHI 0 \"register_no_sp_elim_operand\" \"r\"))]\n+  \"\"\n+  \"mov.l\\\\t%S0,@-er7\"\n+  [(set_attr \"length\" \"4\")])\n+"}, {"sha": "4e9112f970cc77adf3043db1e4f38102059e0bcd", "filename": "gcc/config/h8300/multiply.md", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fmultiply.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fmultiply.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fmultiply.md?ref=f5fb834c96ee4dc828299f984c46608814c9f0a2", "patch": "@@ -0,0 +1,194 @@\n+;; ----------------------------------------------------------------------\n+;; MULTIPLY INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+;; Note that the H8/300 can only handle umulqihi3.\n+\n+(define_expand \"mulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"\"))\n+\t\t ;; intentionally-mismatched modes\n+\t\t (match_operand:QI 2 \"reg_or_nibble_operand\" \"\")))]\n+  \"\"\n+  {\n+    if (GET_MODE (operands[2]) != VOIDmode)\n+      operands[2] = gen_rtx_SIGN_EXTEND (HImode, operands[2]);\n+  })\n+\n+(define_insn \"*mulqihi3_const\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n+\t\t (match_operand:QI 2 \"nibble_operand\" \"IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  \"mulxs.b\t%X2,%T0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"*mulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n+\t\t (sign_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"mulxs.b\t%X2,%T0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_expand \"mulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\"))\n+\t\t ;; intentionally-mismatched modes\n+\t\t (match_operand:HI 2 \"reg_or_nibble_operand\" \"\")))]\n+  \"\"\n+  {\n+    if (GET_MODE (operands[2]) != VOIDmode)\n+      operands[2] = gen_rtx_SIGN_EXTEND (SImode, operands[2]);\n+  })\n+\n+(define_insn \"*mulhisi3_const\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n+\t\t (match_operand:SI 2 \"nibble_operand\" \"IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  \"mulxs.w\t%T2,%S0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"*mulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n+\t\t (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"mulxs.w\t%T2,%S0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_expand \"umulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"\"))\n+\t\t ;; intentionally-mismatched modes\n+\t\t (match_operand:QI 2 \"reg_or_nibble_operand\" \"\")))]\n+  \"\"\n+  {\n+    if (GET_MODE (operands[2]) != VOIDmode)\n+      operands[2] = gen_rtx_ZERO_EXTEND (HImode, operands[2]);\n+  })\n+\n+(define_insn \"*umulqihi3_const\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n+\t\t (match_operand:QI 2 \"nibble_operand\" \"IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  \"mulxu.b\t%X2,%T0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"*umulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n+\t\t (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"mulxu.b\t%X2,%T0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_expand \"umulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"\"))\n+\t\t ;; intentionally-mismatched modes\n+\t\t (match_operand:HI 2 \"reg_or_nibble_operand\" \"\")))]\n+  \"\"\n+  {\n+    if (GET_MODE (operands[2]) != VOIDmode)\n+      operands[2] = gen_rtx_ZERO_EXTEND (SImode, operands[2]);\n+  })\n+\n+(define_insn \"*umulhisi3_const\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n+\t\t (match_operand:SI 2 \"nibble_operand\" \"IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  \"mulxu.w\t%T2,%S0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"*umulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n+\t\t (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"mulxu.w\t%T2,%S0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+;; We could have used mulu.[wl] here, but mulu.[lw] is only available\n+;; on a H8SX with a multiplier, whereas muls.w seems to be available\n+;; on all H8SX variants.\n+\n+(define_insn \"mul<mode>3\"\n+  [(set (match_operand:HSI 0 \"register_operand\" \"=r\")\n+        (mult:HSI (match_operand:HSI 1 \"register_operand\" \"%0\")\n+\t\t  (match_operand:HSI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  { return <MODE>mode == HImode ? \"muls.w\\\\t%T2,%T0\" : \"muls.l\\\\t%S2,%S0\"; }\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"smulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(truncate:SI\n+\t (lshiftrt:DI\n+\t  (mult:DI\n+\t   (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n+\t   (sign_extend:DI (match_operand:SI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))\n+\t  (const_int 32))))]\n+  \"TARGET_H8300SXMUL\"\n+  \"muls/u.l\\\\t%S2,%S0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"umulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(truncate:SI\n+\t  (ashiftrt:DI\n+\t    (mult:DI\n+\t      (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n+\t      (zero_extend:DI (match_operand:SI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))\n+\t    (const_int 32))))]\n+  \"TARGET_H8300SX\"\n+  \"mulu/u.l\\\\t%S2,%S0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+;; This is a \"bridge\" instruction.  Combine can't cram enough insns\n+;; together to crate a MAC instruction directly, but it can create\n+;; this instruction, which then allows combine to create the real\n+;; MAC insn.\n+;;\n+;; Unfortunately, if combine doesn't create a MAC instruction, this\n+;; insn must generate reasonably correct code.  Egad.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(mult:SI\n+\t  (sign_extend:SI\n+\t    (mem:HI (post_inc:SI (match_operand:SI 1 \"register_operand\" \"r\"))))\n+\t  (sign_extend:SI\n+\t    (mem:HI (post_inc:SI (match_operand:SI 2 \"register_operand\" \"r\"))))))]\n+  \"TARGET_MAC\"\n+  \"clrmac\\;mac\t@%2+,@%1+\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(plus:SI (mult:SI\n+\t  (sign_extend:SI (mem:HI\n+\t    (post_inc:SI (match_operand:SI 1 \"register_operand\" \"r\"))))\n+\t  (sign_extend:SI (mem:HI\n+\t    (post_inc:SI (match_operand:SI 2 \"register_operand\" \"r\")))))\n+\t      (match_operand:SI 3 \"register_operand\" \"0\")))]\n+  \"TARGET_MAC\"\n+  \"mac\t@%2+,@%1+\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+"}, {"sha": "4b96a7c4a4075d17b55742b39c0afb1f315241b9", "filename": "gcc/config/h8300/other.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fother.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fother.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fother.md?ref=f5fb834c96ee4dc828299f984c46608814c9f0a2", "patch": "@@ -0,0 +1,17 @@\n+;; ----------------------------------------------------------------------\n+;; ABSOLUTE VALUE INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(abs:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"and.w\\\\t#32767,%e0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"2\")])"}, {"sha": "9d19ff5408413b8a38ace35019379dfd8ee8b46d", "filename": "gcc/config/h8300/proepi.md", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fproepi.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fproepi.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fproepi.md?ref=f5fb834c96ee4dc828299f984c46608814c9f0a2", "patch": "@@ -0,0 +1,127 @@\n+;; ----------------------------------------------------------------------\n+;; PROLOGUE/EPILOGUE-RELATED INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_expand \"push_h8300hs_advanced\"\n+  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n+        (match_operand:SI 0 \"register_operand\" \"\"))]\n+  \"TARGET_H8300H && TARGET_H8300S && !TARGET_NORMAL_MODE\"\n+  \"\")\n+\n+(define_expand \"push_h8300hs_normal\"\n+  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n+        (match_operand:SI 0 \"register_operand\" \"\"))]\n+  \"TARGET_H8300H && TARGET_H8300S && TARGET_NORMAL_MODE\"\n+  \"\")\n+\n+(define_expand \"pop_h8300hs_advanced\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mem:SI (post_inc:SI (reg:SI SP_REG))))]\n+  \"TARGET_H8300H && TARGET_H8300S && !TARGET_NORMAL_MODE\"\n+  \"\")\n+\n+(define_expand \"pop_h8300hs_normal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mem:SI (post_inc:HI (reg:HI SP_REG))))]\n+  \"TARGET_H8300H && TARGET_H8300S && TARGET_NORMAL_MODE\"\n+  \"\")\n+\n+(define_insn \"ldm_h8300sx\"\n+  [(match_parallel           0 \"h8300_ldm_parallel\"\n+    [(set (match_operand:SI 1 \"register_operand\" \"\")\n+\t  (match_operand:SI 2 \"memory_operand\" \"\"))])]\n+  \"TARGET_H8300S\"\n+{\n+  operands[3] = SET_DEST (XVECEXP (operands[0], 0,\n+\t\t\t\t   XVECLEN (operands[0], 0) - 2));\n+  return \"ldm.l\\t@er7+,%S1-%S3\";\n+}\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"stm_h8300sx\"\n+  [(match_parallel           0 \"h8300_stm_parallel\"\n+    [(set (match_operand:SI 1 \"memory_operand\" \"\")\n+\t  (match_operand:SI 2 \"register_operand\" \"\"))])]\n+  \"TARGET_H8300S\"\n+{\n+  operands[3] = SET_SRC (XVECEXP (operands[0], 0,\n+\t\t\t\t  XVECLEN (operands[0], 0) - 2));\n+  return \"stm.l\\t%S2-%S3,@-er7\";\n+}\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"return_h8sx\"\n+  [(match_parallel           0 \"h8300_return_parallel\"\n+    [(return)\n+     (set (match_operand:SI 1 \"register_operand\" \"\")\n+\t  (match_operand:SI 2 \"memory_operand\" \"\"))])]\n+  \"TARGET_H8300SX\"\n+{\n+  operands[3] = SET_DEST (XVECEXP (operands[0], 0,\n+\t\t\t\t   XVECLEN (operands[0], 0) - 2));\n+  if (h8300_current_function_interrupt_function_p ()\n+      || h8300_current_function_monitor_function_p ())\n+    return \"rte/l\\t%S1-%S3\";\n+  else\n+    return \"rts/l\\t%S1-%S3\";\n+}\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"can_delay\" \"no\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_expand \"return\"\n+  [(return)]\n+  \"h8300_can_use_return_insn_p ()\"\n+  \"\")\n+\n+(define_insn \"*return_1\"\n+  [(return)]\n+  \"reload_completed\"\n+{\n+  if (h8300_current_function_interrupt_function_p ()\n+      || h8300_current_function_monitor_function_p ())\n+    return \"rte\";\n+  else\n+    return \"rts\";\n+}\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"can_delay\" \"no\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  {\n+    h8300_expand_prologue ();\n+    DONE;\n+  })\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  {\n+    h8300_expand_epilogue ();\n+    DONE;\n+  })\n+\n+(define_insn \"monitor_prologue\"\n+  [(unspec_volatile [(const_int 0)] UNSPEC_MONITOR)]\n+  \"\"\n+{\n+  if (TARGET_H8300H && TARGET_NORMAL_MODE)\n+    return \"subs\\\\t#2,er7\\;mov.l\\\\ter0,@-er7\\;stc\\\\tccr,r0l\\;mov.b\\\\tr0l,@(4,er7)\\;mov.l\\\\t@er7+,er0\\;orc\\\\t#128,ccr\";\n+  else if (TARGET_H8300H)\n+    return \"mov.l\\\\ter0,@-er7\\;stc\\\\tccr,r0l\\;mov.b\\\\tr0l,@(4,er7)\\;mov.l\\\\t@er7+,er0\\;orc\\\\t#128,ccr\";\n+  else if (TARGET_H8300S && TARGET_NEXR )\n+    return \"mov.l\\\\ter0,@-er7\\;stc\\tccr,r0l\\;mov.b\\tr0l,@(4,er7)\\;mov.l\\\\t@er7+,er0\\;orc\\t#128,ccr\";\n+  else if (TARGET_H8300S && TARGET_NEXR && TARGET_NORMAL_MODE)\n+    return \"subs\\\\t#2,er7\\;mov.l\\\\ter0,@-er7\\;stc\\tccr,r0l\\;mov.b\\tr0l,@(4,er7)\\;mov.l\\\\t@er7+,er0\\;orc\\t#128,ccr\";\n+  else if (TARGET_H8300S && TARGET_NORMAL_MODE)\n+    return \"subs\\\\t#2,er7\\;stc\\texr,@-er7\\;mov.l\\\\ter0,@-er7\\;stc\\tccr,r0l\\;mov.b\\tr0l,@(6,er7)\\;mov.l\\\\t@er7+,er0\\;orc\\t#128,ccr\";\n+  else if (TARGET_H8300S)\n+    return \"stc\\texr,@-er7\\;mov.l\\\\ter0,@-er7\\;stc\\tccr,r0l\\;mov.b\\tr0l,@(6,er7)\\;mov.l\\\\t@er7+,er0\\;orc\\t#128,ccr\";\n+  gcc_unreachable ();\n+}\n+  [(set_attr \"length\" \"20\")])"}, {"sha": "75606d7c50b7190602f3547768770350da64b1bc", "filename": "gcc/config/h8300/shiftrotate.md", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fshiftrotate.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Fshiftrotate.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fshiftrotate.md?ref=f5fb834c96ee4dc828299f984c46608814c9f0a2", "patch": "@@ -0,0 +1,223 @@\n+;; ----------------------------------------------------------------------\n+;; SHIFTS\n+;; ----------------------------------------------------------------------\n+;;\n+;; We make some attempt to provide real efficient shifting.  One example is\n+;; doing an 8-bit shift of a 16-bit value by moving a byte reg into the other\n+;; reg and moving 0 into the former reg.\n+;;\n+;; We also try to achieve this in a uniform way.  IE: We don't try to achieve\n+;; this in both rtl and at insn emit time.  Ideally, we'd use rtl as that would\n+;; give the optimizer more cracks at the code.  However, we wish to do things\n+;; like optimizing shifting the sign bit to bit 0 by rotating the other way.\n+;; There is rtl to handle this (rotate + and), but the H8/300 doesn't handle\n+;; 16-bit rotates.  Also, if we emit complicated rtl, combine may not be able\n+;; to detect cases it can optimize.\n+;;\n+;; For these and other fuzzy reasons, I've decided to go the less pretty but\n+;; easier \"do it at insn emit time\" route.\n+\n+\n+(define_expand \"ashl<mode>3\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"\")\n+\t(ashift:QHSI (match_operand:QHSI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  {\n+    if (expand_a_shift (<MODE>mode, ASHIFT, operands))\n+    DONE;\n+  })\n+\n+(define_expand \"ashr<mode>3\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"\")\n+\t(ashiftrt:QHSI (match_operand:QHSI 1 \"register_operand\" \"\")\n+\t\t       (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  {\n+    if (expand_a_shift (<MODE>mode, ASHIFTRT, operands))\n+    DONE;\n+  })\n+\n+(define_expand \"lshr<mode>3\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"\")\n+\t(lshiftrt:QHSI (match_operand:QHSI 1 \"register_operand\" \"\")\n+\t\t       (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  {\n+    if (expand_a_shift (<MODE>mode, LSHIFTRT, operands))\n+    DONE;\n+  })\n+\n+;; QI/HI/SI BIT SHIFTS\n+\n+(define_insn \"\"\n+  [(set (match_operand:QHSI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(match_operator:QHSI 3 \"h8sx_unary_shift_operator\"\n+\t [(match_operand:QHSI 1 \"h8300_dst_operand\" \"0\")\n+\t  (match_operand:QI 2 \"const_int_operand\" \"\")]))]\n+  \"h8300_operands_match_p (operands)\"\n+{\n+  if (<MODE>mode == E_QImode)\n+    return output_h8sx_shift (operands, 'b', 'X');\n+  if (<MODE>mode == E_HImode)\n+    return output_h8sx_shift (operands, 'w', 'T');\n+  if (<MODE>mode == E_SImode)\n+    return output_h8sx_shift (operands, 'l', 'S');\n+  gcc_unreachable ();\n+}\n+  [(set_attr \"length_table\" \"unary\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"=r\")\n+\t(match_operator:QHSI 3 \"h8sx_binary_shift_operator\"\n+\t [(match_operand:QHSI 1 \"register_operand\" \"0\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \"r P5>X\")]))]\n+  \"\"\n+{\n+  if (<MODE>mode == QImode)\n+    return output_h8sx_shift (operands, 'b', 'X');\n+  if (<MODE>mode == HImode)\n+    return output_h8sx_shift (operands, 'w', 'T');\n+  if (<MODE>mode == SImode)\n+    return output_h8sx_shift (operands, 'l', 'S');\n+  gcc_unreachable ();\n+}\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"*shiftqi\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n+\t(match_operator:QI 3 \"nshift_operator\"\n+\t [(match_operand:QI 1 \"register_operand\" \"0,0\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \"R,rn\")]))\n+   (clobber (match_scratch:QI 4 \"=X,&r\"))]\n+  \"\"\n+{\n+  return output_a_shift (operands);\n+}\n+  [(set (attr \"length\")\n+\t(symbol_ref \"compute_a_shift_length (insn, operands)\"))\n+   (set (attr \"cc\")\n+\t(symbol_ref \"compute_a_shift_cc (insn, operands)\"))])\n+\n+(define_insn \"*shifthi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(match_operator:HI 3 \"nshift_operator\"\n+\t [(match_operand:HI 1 \"register_operand\" \"0,0\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \"S,rn\")]))\n+   (clobber (match_scratch:QI 4 \"=X,&r\"))]\n+  \"\"\n+{\n+  return output_a_shift (operands);\n+}\n+  [(set (attr \"length\")\n+\t(symbol_ref \"compute_a_shift_length (insn, operands)\"))\n+   (set (attr \"cc\")\n+\t(symbol_ref \"compute_a_shift_cc (insn, operands)\"))])\n+\n+(define_insn \"*shiftsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(match_operator:SI 3 \"nshift_operator\"\n+\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \"T,rn\")]))\n+   (clobber (match_scratch:QI 4 \"=X,&r\"))]\n+  \"\"\n+{\n+  return output_a_shift (operands);\n+}\n+  [(set (attr \"length\")\n+\t(symbol_ref \"compute_a_shift_length (insn, operands)\"))\n+   (set (attr \"cc\")\n+\t(symbol_ref \"compute_a_shift_cc (insn, operands)\"))])\n+\n+\n+;; Split a variable shift into a loop.  If the register containing\n+;; the shift count dies, then we just use that register.\n+\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operator 2 \"nshift_operator\"\n+\t [(match_dup 0)\n+\t  (match_operand:QI 1 \"register_operand\" \"\")]))\n+   (clobber (match_operand:QI 3 \"register_operand\" \"\"))]\n+  \"epilogue_completed\n+   && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\"\n+  [(set (cc0) (compare (match_dup 1) (const_int 0)))\n+   (set (pc)\n+        (if_then_else (le (cc0) (const_int 0))\n+\t\t      (label_ref (match_dup 5))\n+\t\t      (pc)))\n+   (match_dup 4)\n+   (parallel\n+     [(set (match_dup 0)\n+\t   (match_op_dup 2 [(match_dup 0) (const_int 1)]))\n+      (clobber (scratch:QI))])\n+   (set (match_dup 1) (plus:QI (match_dup 1) (const_int -1)))\n+   (set (cc0) (compare (match_dup 1) (const_int 0)))\n+   (set (pc)\n+        (if_then_else (ne (cc0) (const_int 0))\n+\t\t      (label_ref (match_dup 4))\n+\t\t      (pc)))\n+   (match_dup 5)]\n+  {\n+    operands[4] = gen_label_rtx ();\n+    operands[5] = gen_label_rtx ();\n+  })\n+\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operator 2 \"nshift_operator\"\n+\t [(match_dup 0)\n+\t  (match_operand:QI 1 \"register_operand\" \"\")]))\n+   (clobber (match_operand:QI 3 \"register_operand\" \"\"))]\n+  \"epilogue_completed\n+   && !find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\"\n+  [(set (match_dup 3)\n+\t(match_dup 1))\n+   (set (cc0) (compare (match_dup 3) (const_int 0)))\n+   (set (pc)\n+        (if_then_else (le (cc0) (const_int 0))\n+\t\t      (label_ref (match_dup 5))\n+\t\t      (pc)))\n+   (match_dup 4)\n+   (parallel\n+     [(set (match_dup 0)\n+\t   (match_op_dup 2 [(match_dup 0) (const_int 1)]))\n+      (clobber (scratch:QI))])\n+   (set (match_dup 3) (plus:QI (match_dup 3) (const_int -1)))\n+   (set (cc0) (compare (match_dup 3) (const_int 0)))\n+   (set (pc)\n+        (if_then_else (ne (cc0) (const_int 0))\n+\t\t      (label_ref (match_dup 4))\n+\t\t      (pc)))\n+   (match_dup 5)]\n+  {\n+    operands[4] = gen_label_rtx ();\n+    operands[5] = gen_label_rtx ();\n+  })\n+\f\n+;; ----------------------------------------------------------------------\n+;; ROTATIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_expand \"rotl<mode>3\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"\")\n+\t(rotate:QHSI (match_operand:QHSI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  {\n+    if (expand_a_rotate (operands))\n+    DONE;\n+  })\n+\n+(define_insn \"rotl<mode>3_1\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"=r\")\n+\t(rotate:QHSI (match_operand:QHSI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"immediate_operand\" \"\")))]\n+  \"\"\n+{\n+  return output_a_rotate (ROTATE, operands);\n+}\n+  [(set (attr \"length\")\n+\t(symbol_ref \"compute_a_rotate_length (operands)\"))])"}, {"sha": "2e4cb5afee746f8458b5c67931538913fb6230db", "filename": "gcc/config/h8300/testcompare.md", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Ftestcompare.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fb834c96ee4dc828299f984c46608814c9f0a2/gcc%2Fconfig%2Fh8300%2Ftestcompare.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Ftestcompare.md?ref=f5fb834c96ee4dc828299f984c46608814c9f0a2", "patch": "@@ -0,0 +1,201 @@\n+;; ----------------------------------------------------------------------\n+;; TEST INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn_and_split \"*tst_extzv_1_n\"\n+  [(set (cc0)\n+\t(compare (zero_extract:SI (match_operand:QI 0 \"general_operand_src\" \"r,U,mn>\")\n+\t\t\t\t  (const_int 1)\n+\t\t\t\t  (match_operand 1 \"const_int_operand\" \"n,n,n\"))\n+\t\t (const_int 0)))\n+   (clobber (match_scratch:QI 2 \"=X,X,&r\"))]\n+  \"\"\n+  \"@\n+   btst\\\\t%Z1,%Y0\n+   btst\\\\t%Z1,%Y0\n+   #\"\n+  \"&& reload_completed\n+   && !satisfies_constraint_U (operands[0])\"\n+  [(set (match_dup 2)\n+\t(match_dup 0))\n+   (parallel [(set (cc0) (compare (zero_extract:SI (match_dup 2)\n+\t\t\t\t\t\t   (const_int 1)\n+\t\t\t\t\t\t   (match_dup 1))\n+\t\t\t\t  (const_int 0)))\n+\t      (clobber (scratch:QI))])]\n+  \"\"\n+  [(set_attr \"length\" \"2,8,10\")\n+   (set_attr \"cc\" \"set_zn,set_zn,set_zn\")])\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare (zero_extract:HSI (match_operand:HSI 0 \"register_operand\" \"r\")\n+\t\t\t\t   (const_int 1)\n+\t\t\t\t   (match_operand 1 \"const_int_operand\" \"n\"))\n+\t\t (const_int 0)))]\n+  \"INTVAL (operands[1]) <= 15\"\n+  \"btst\t%Z1,%Y0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn_and_split \"*tstsi_upper_bit\"\n+  [(set (cc0)\n+\t(compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t  (const_int 1)\n+\t\t\t\t  (match_operand 1 \"const_int_operand\" \"n\"))\n+\t\t (const_int 0)))\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n+  \"INTVAL (operands[1]) >= 16\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 2)\n+\t(ior:SI (and:SI (match_dup 2)\n+\t\t\t(const_int -65536))\n+\t\t(lshiftrt:SI (match_dup 0)\n+\t\t\t     (const_int 16))))\n+   (set (cc0)\n+\t(compare (zero_extract:SI (match_dup 2)\n+\t\t\t\t  (const_int 1)\n+\t\t\t\t  (match_dup 3))\n+\t\t (const_int 0)))]\n+  {\n+    operands[3] = GEN_INT (INTVAL (operands[1]) - 16);\n+  })\n+\n+(define_insn \"*tstsi_variable_bit\"\n+  [(set (cc0)\n+\t(compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t  (const_int 1)\n+\t\t\t\t  (and:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t\t  (const_int 7)))\n+\t\t (const_int 0)))]\n+  \"\"\n+  \"btst\t%w1,%w0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn_and_split \"*tstsi_variable_bit_qi\"\n+  [(set (cc0)\n+\t(compare (zero_extract:SI (zero_extend:SI (match_operand:QI 0 \"general_operand_src\" \"r,U,mn>\"))\n+\t\t\t\t  (const_int 1)\n+\t\t\t\t  (and:SI (match_operand:SI 1 \"register_operand\" \"r,r,r\")\n+\t\t\t\t\t  (const_int 7)))\n+\t\t (const_int 0)))\n+   (clobber (match_scratch:QI 2 \"=X,X,&r\"))]\n+  \"\"\n+  \"@\n+   btst\\\\t%w1,%X0\n+   btst\\\\t%w1,%X0\n+   #\"\n+  \"&& reload_completed\n+   && !satisfies_constraint_U (operands[0])\"\n+  [(set (match_dup 2)\n+\t(match_dup 0))\n+   (parallel [(set (cc0)\n+\t\t   (compare (zero_extract:SI (zero_extend:SI (match_dup 2))\n+\t\t\t\t\t     (const_int 1)\n+\t\t\t\t\t     (and:SI (match_dup 1)\n+\t\t\t\t\t\t     (const_int 7)))\n+\t\t\t    (const_int 0)))\n+\t      (clobber (scratch:QI))])]\n+  \"\"\n+  [(set_attr \"length\" \"2,8,10\")\n+   (set_attr \"cc\" \"set_zn,set_zn,set_zn\")])\n+\n+(define_insn \"*tst<mode>\"\n+  [(set (cc0)\n+\t(compare (match_operand:QHI 0 \"register_operand\" \"r\")\n+\t\t (const_int 0)))]\n+  \"\"\n+  {\n+    if (<MODE>mode == QImode)\n+      return \"mov.b\t%X0,%X0\";\n+    else if (<MODE>mode == HImode)\n+      return \"mov.w\t%T0,%T0\";\n+    gcc_unreachable ();\n+  }\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"*tsthi_upper\"\n+  [(set (cc0)\n+\t(compare (and:HI (match_operand:HI 0 \"register_operand\" \"r\")\n+\t\t\t (const_int -256))\n+\t\t (const_int 0)))]\n+  \"\"\n+  \"mov.b\t%t0,%t0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"*tstsi\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t (const_int 0)))]\n+  \"\"\n+  \"mov.l\t%S0,%S0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"*tstsi_upper\"\n+  [(set (cc0)\n+\t(compare (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t (const_int -65536))\n+\t\t (const_int 0)))]\n+  \"\"\n+  \"mov.w\t%e0,%e0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"*cmpqi\"\n+  [(set (cc0)\n+\t(compare (match_operand:QI 0 \"h8300_dst_operand\" \"rQ\")\n+\t\t (match_operand:QI 1 \"h8300_src_operand\" \"rQi\")))]\n+  \"\"\n+  \"cmp.b\t%X1,%X0\"\n+  [(set_attr \"length_table\" \"add\")\n+   (set_attr \"cc\" \"compare\")])\n+\n+(define_insn \"*cmphi_h8300hs_znvc\"\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"h8300_dst_operand\" \"rU,rQ\")\n+\t\t (match_operand:HI 1 \"h8300_src_operand\" \"P3>X,rQi\")))]\n+  \"\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (!TARGET_H8300SX)\n+\treturn \"cmp.w\t%T1,%T0\";\n+      else\n+\treturn \"cmp.w\t%T1:3,%T0\";\n+    case 1:\n+      return \"cmp.w\t%T1,%T0\";\n+    default:\n+      gcc_unreachable ();\n+      }\n+}\n+  [(set_attr \"length_table\" \"short_immediate,add\")\n+   (set_attr \"cc\" \"compare,compare\")])\n+\n+(define_insn \"cmpsi\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"h8300_dst_operand\" \"r,rQ\")\n+\t\t (match_operand:SI 1 \"h8300_src_operand\" \"P3>X,rQi\")))]\n+  \"\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (!TARGET_H8300SX)\n+\treturn \"cmp.l\t%S1,%S0\";\n+      else\n+\treturn \"cmp.l\t%S1:3,%S0\";\n+    case 1:\n+      return \"cmp.l\t%S1,%S0\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"length\" \"2,*\")\n+   (set_attr \"length_table\" \"*,add\")\n+   (set_attr \"cc\" \"compare,compare\")])"}]}