{"sha": "b2ef23239f245871e9b35b902391f2e94a041627", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJlZjIzMjM5ZjI0NTg3MWU5YjM1YjkwMjM5MWYyZTk0YTA0MTYyNw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-08-26T17:57:00Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-08-26T17:57:00Z"}, "message": "Improved handling of shifts/rotates in bit CCP.\n\nThis patch is the next in the series to improve bit bounds in tree-ssa's\nbit CCP pass, this time: bounds for shifts and rotates by unknown amounts.\nThis allows us to optimize expressions such as ((x&15)<<(y&24))&64.\nIn this case, the expression (y&24) contains only two unknown bits,\nand can therefore have only four possible values: 0, 8, 16 and 24.\nFrom this (x&15)<<(y&24) has the nonzero bits 0x0f0f0f0f, and from\nthat ((x&15)<<(y&24))&64 must always be zero.\n\nOne clever use of computer science in this patch is the use of XOR\nto efficiently enumerate bit patterns in Gray code order.  As the\norder in which we generate values is not significant, it's faster\nand more convenient to enumerate values by flipping one bit at a\ntime, rather than in numerical order [which would require carry\nbits and additional logic].\n\nThere's a pre-existing ??? comment in tree-ssa-ccp.c that we should\neventually be able to optimize (x<<(y|8))&255, but this patch takes the\nconservatively paranoid approach of only optimizing cases where the\nshift/rotate is guaranteed to be less than the target precision, and\ntherefore avoids changing any cases that potentially might invoke\nundefined behavior.  This patch does optimize (x<<((y&31)|8))&255.\n\n2021-08-26  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\t* tree-ssa-ccp.c (get_individual_bits): Helper function to\n\textract the individual bits from a widest_int constant (mask).\n\t(gray_code_bit_flips): New read-only table for effiently\n\tenumerating permutations/combinations of bits.\n\t(bit_value_binop) [LROTATE_EXPR, RROTATE_EXPR]: Handle rotates\n\tby unknown counts that are guaranteed less than the target\n\tprecision and four or fewer unknown bits by enumeration.\n\t[LSHIFT_EXPR, RSHIFT_EXPR]: Likewise, also handle shifts by\n\tenumeration under the same conditions.  Handle remaining\n\tshifts as a mask based upon the minimum possible shift value.\n\ngcc/testsuite/ChangeLog\n\t* gcc.dg/tree-ssa/ssa-ccp-41.c: New test case.", "tree": {"sha": "ff0f4e31822a2de9031c62cca2bcd3df655b2179", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff0f4e31822a2de9031c62cca2bcd3df655b2179"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2ef23239f245871e9b35b902391f2e94a041627", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2ef23239f245871e9b35b902391f2e94a041627", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2ef23239f245871e9b35b902391f2e94a041627", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2ef23239f245871e9b35b902391f2e94a041627/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2d9b558299df91e9c34a583eb0f0b14d1cacce9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2d9b558299df91e9c34a583eb0f0b14d1cacce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2d9b558299df91e9c34a583eb0f0b14d1cacce9"}], "stats": {"total": 171, "additions": 171, "deletions": 0}, "files": [{"sha": "d2b054e9355cd975673b359b35b6efa92bf7a607", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-41.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ef23239f245871e9b35b902391f2e94a041627/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-41.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ef23239f245871e9b35b902391f2e94a041627/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-41.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-41.c?ref=b2ef23239f245871e9b35b902391f2e94a041627", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+int foo(int x)\n+{\n+    int p = x & 24;\n+    int r = 1 << p; \n+    return r & (1<<17);\n+}\n+\n+/* { dg-final { scan-tree-dump \"return 0;\" \"optimized\" } } */"}, {"sha": "f4a99aca4b434e6c699f24e9dc8ea862952e7e28", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ef23239f245871e9b35b902391f2e94a041627/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ef23239f245871e9b35b902391f2e94a041627/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=b2ef23239f245871e9b35b902391f2e94a041627", "patch": "@@ -1448,6 +1448,34 @@ bit_value_mult_const (signop sgn, int width,\n   *mask = wi::ext (sum_mask, width, sgn);\n }\n \n+/* Fill up to MAX values in the BITS array with values representing\n+   each of the non-zero bits in the value X.  Returns the number of\n+   bits in X (capped at the maximum value MAX).  For example, an X\n+   value 11, places 1, 2 and 8 in BITS and returns the value 3.  */\n+\n+unsigned int\n+get_individual_bits (widest_int *bits, widest_int x, unsigned int max)\n+{\n+  unsigned int count = 0;\n+  while (count < max && x != 0)\n+    {\n+      int bitpos = wi::ctz (x);\n+      bits[count] = wi::lshift (1, bitpos);\n+      x ^= bits[count];\n+      count++;\n+    }\n+  return count;\n+}\n+\n+/* Array of 2^N - 1 values representing the bits flipped between\n+   consecutive Gray codes.  This is used to efficiently enumerate\n+   all permutations on N bits using XOR.  */\n+static const unsigned char gray_code_bit_flips[63] = {\n+  0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4,\n+  0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5,\n+  0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4,\n+  0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0\n+};\n \n /* Apply the operation CODE in type TYPE to the value, mask pairs\n    R1VAL, R1MASK and R2VAL, R2MASK representing a values of type R1TYPE\n@@ -1525,6 +1553,48 @@ bit_value_binop (enum tree_code code, signop sgn, int width,\n \t\t}\n \t    }\n \t}\n+      else if (wi::ltu_p (r2val | r2mask, width)\n+\t       && wi::popcount (r2mask) <= 4)\n+\t{\n+\t  widest_int bits[4];\n+\t  widest_int res_val, res_mask;\n+\t  widest_int tmp_val, tmp_mask;\n+\t  widest_int shift = wi::bit_and_not (r2val, r2mask);\n+\t  unsigned int bit_count = get_individual_bits (bits, r2mask, 4);\n+\t  unsigned int count = (1 << bit_count) - 1;\n+\n+\t  /* Initialize result to rotate by smallest value of shift.  */\n+\t  if (code == RROTATE_EXPR)\n+\t    {\n+\t      res_mask = wi::rrotate (r1mask, shift, width);\n+\t      res_val = wi::rrotate (r1val, shift, width);\n+\t    }\n+\t  else\n+\t    {\n+\t      res_mask = wi::lrotate (r1mask, shift, width);\n+\t      res_val = wi::lrotate (r1val, shift, width);\n+\t    }\n+\n+\t  /* Iterate through the remaining values of shift.  */\n+\t  for (unsigned int i=0; i<count; i++)\n+\t    {\n+\t      shift ^= bits[gray_code_bit_flips[i]];\n+\t      if (code == RROTATE_EXPR)\n+\t\t{\n+\t\t  tmp_mask = wi::rrotate (r1mask, shift, width);\n+\t\t  tmp_val = wi::rrotate (r1val, shift, width);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  tmp_mask = wi::lrotate (r1mask, shift, width);\n+\t\t  tmp_val = wi::lrotate (r1val, shift, width);\n+\t\t}\n+\t      /* Accumulate the result.  */\n+\t      res_mask |= tmp_mask | (res_val ^ tmp_val);\n+\t    }\n+\t  *val = wi::bit_and_not (res_val, res_mask);\n+\t  *mask = res_mask;\n+\t}\n       break;\n \n     case LSHIFT_EXPR:\n@@ -1556,6 +1626,96 @@ bit_value_binop (enum tree_code code, signop sgn, int width,\n \t\t}\n \t    }\n \t}\n+      else if (wi::ltu_p (r2val | r2mask, width))\n+\t{\n+\t  if (wi::popcount (r2mask) <= 4)\n+\t    {\n+\t      widest_int bits[4];\n+\t      widest_int arg_val, arg_mask;\n+\t      widest_int res_val, res_mask;\n+\t      widest_int tmp_val, tmp_mask;\n+\t      widest_int shift = wi::bit_and_not (r2val, r2mask);\n+\t      unsigned int bit_count = get_individual_bits (bits, r2mask, 4);\n+\t      unsigned int count = (1 << bit_count) - 1;\n+\n+\t      /* Initialize result to shift by smallest value of shift.  */\n+\t      if (code == RSHIFT_EXPR)\n+\t\t{\n+\t\t  arg_mask = wi::ext (r1mask, width, sgn);\n+\t\t  arg_val = wi::ext (r1val, width, sgn);\n+\t\t  res_mask = wi::rshift (arg_mask, shift, sgn);\n+\t\t  res_val = wi::rshift (arg_val, shift, sgn);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  arg_mask = r1mask;\n+\t\t  arg_val = r1val;\n+\t\t  res_mask = arg_mask << shift;\n+\t\t  res_val = arg_val << shift;\n+\t\t}\n+\n+\t      /* Iterate through the remaining values of shift.  */\n+\t      for (unsigned int i=0; i<count; i++)\n+\t\t{\n+\t\t  shift ^= bits[gray_code_bit_flips[i]];\n+\t\t  if (code == RSHIFT_EXPR)\n+\t\t    {\n+\t\t      tmp_mask = wi::rshift (arg_mask, shift, sgn);\n+\t\t      tmp_val = wi::rshift (arg_val, shift, sgn);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      tmp_mask = arg_mask << shift;\n+\t\t      tmp_val = arg_val << shift;\n+\t\t    }\n+\t\t  /* Accumulate the result.  */\n+\t\t  res_mask |= tmp_mask | (res_val ^ tmp_val);\n+\t\t}\n+\t      res_mask = wi::ext (res_mask, width, sgn);\n+\t      res_val = wi::ext (res_val, width, sgn);\n+\t      *val = wi::bit_and_not (res_val, res_mask);\n+\t      *mask = res_mask;\n+\t    }\n+\t  else if ((r1val | r1mask) == 0)\n+\t    {\n+\t      /* Handle shifts of zero to avoid undefined wi::ctz below.  */\n+\t      *mask = 0;\n+\t      *val = 0;\n+\t    }\n+\t  else if (code == LSHIFT_EXPR)\n+\t    {\n+\t      widest_int tmp = wi::mask <widest_int> (width, false);\n+\t      tmp <<= wi::ctz (r1val | r1mask);\n+\t      tmp <<= wi::bit_and_not (r2val, r2mask);\n+\t      *mask = wi::ext (tmp, width, sgn);\n+\t      *val = 0;\n+\t    }\n+\t  else if (!wi::neg_p (r1val | r1mask, sgn))\n+\t    {\n+\t      /* Logical right shift, or zero sign bit.  */\n+\t      widest_int arg = r1val | r1mask;\n+\t      int lzcount = wi::clz (arg);\n+\t      lzcount -= wi::get_precision (arg) - width;\n+\t      widest_int tmp = wi::mask <widest_int> (width, false);\n+\t      tmp = wi::lrshift (tmp, lzcount);\n+\t      tmp = wi::lrshift (tmp, wi::bit_and_not (r2val, r2mask));\n+\t      *mask = wi::ext (tmp, width, sgn);\n+\t      *val = 0;\n+\t    }\n+\t  else if (!wi::neg_p (r1mask))\n+\t    {\n+\t      /* Arithmetic right shift with set sign bit.  */\n+\t      widest_int arg = wi::bit_and_not (r1val, r1mask);\n+\t      int sbcount = wi::clrsb (arg);\n+\t      sbcount -= wi::get_precision (arg) - width;\n+\t      widest_int tmp = wi::mask <widest_int> (width, false);\n+\t      tmp = wi::lrshift (tmp, sbcount);\n+\t      tmp = wi::lrshift (tmp, wi::bit_and_not (r2val, r2mask));\n+\t      *mask = wi::sext (tmp, width);\n+\t      tmp = wi::bit_not (tmp);\n+\t      *val = wi::sext (tmp, width);\n+\t    }\n+\t}\n       break;\n \n     case PLUS_EXPR:"}]}