{"sha": "4a50e99c6531d1d413e75f19c802ba5fd6ab103a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE1MGU5OWM2NTMxZDFkNDEzZTc1ZjE5YzgwMmJhNWZkNmFiMTAzYQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2009-09-07T17:08:12Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2009-09-07T17:08:12Z"}, "message": "re PR middle-end/41282 (Revision 151394 failed to compile mplayer)\n\n2009-09-07  Martin Jambor  <mjambor@suse.cz>\n\n\tPR middle-end/41282\n\t* tree-sra.c (create_artificial_child_access): Return NULL if\n\tbuild_ref_for_offset fails.\n\t(propagate_subacesses_accross_link): Allow build_ref_for_offset\n\tand create_artificial_child_access to fail.\n\n\t* testsuite/gcc.c-torture/compile/pr41282.c: New test.\n\nFrom-SVN: r151484", "tree": {"sha": "0fe789e9c973b1097403272d2569032c96f3d0e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fe789e9c973b1097403272d2569032c96f3d0e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a50e99c6531d1d413e75f19c802ba5fd6ab103a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a50e99c6531d1d413e75f19c802ba5fd6ab103a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a50e99c6531d1d413e75f19c802ba5fd6ab103a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a50e99c6531d1d413e75f19c802ba5fd6ab103a/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e5b258a4c95ee45aae8fb7ec9f7ba81dc68addc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5b258a4c95ee45aae8fb7ec9f7ba81dc68addc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5b258a4c95ee45aae8fb7ec9f7ba81dc68addc2"}], "stats": {"total": 75, "additions": 56, "deletions": 19}, "files": [{"sha": "5329be5c577549f1707a88fff7fefccf34812b15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a50e99c6531d1d413e75f19c802ba5fd6ab103a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a50e99c6531d1d413e75f19c802ba5fd6ab103a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a50e99c6531d1d413e75f19c802ba5fd6ab103a", "patch": "@@ -1,3 +1,11 @@\n+2009-09-07  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR middle-end/41282\n+\t* tree-sra.c (create_artificial_child_access): Return NULL if\n+\tbuild_ref_for_offset fails.\n+\t(propagate_subacesses_accross_link): Allow build_ref_for_offset\n+\tand create_artificial_child_access to fail.\n+\n 2009-09-06  Dmitry Gorbachev  <d.g.gorbachev@gmail.com>\n \n \tPR c++/41214"}, {"sha": "166d03dd9bc012415cb33be33f61493872390491", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a50e99c6531d1d413e75f19c802ba5fd6ab103a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a50e99c6531d1d413e75f19c802ba5fd6ab103a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4a50e99c6531d1d413e75f19c802ba5fd6ab103a", "patch": "@@ -1,3 +1,8 @@\n+2009-09-07  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR middle-end/41282\n+\t* gcc.c-torture/compile/pr41282.c: New test.\n+\n 2009-09-07  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/41197"}, {"sha": "3a0f02d63ab10219658fbc83e214c4a25c4ddfe5", "filename": "gcc/testsuite/gcc.c-torture/compile/pr41282.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a50e99c6531d1d413e75f19c802ba5fd6ab103a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr41282.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a50e99c6531d1d413e75f19c802ba5fd6ab103a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr41282.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr41282.c?ref=4a50e99c6531d1d413e75f19c802ba5fd6ab103a", "patch": "@@ -0,0 +1,20 @@\n+struct S\n+{\n+  unsigned int iu;\n+};\n+\n+union U\n+{\n+  struct S s;\n+  signed int is;\n+};\n+\n+extern signed int bar ();\n+\n+struct S foo (void)\n+{\n+  union U u;\n+\n+  u.is = bar ();\n+  return u.s;\n+}"}, {"sha": "431c456e2060b3bbf5f94530d8814dd0608bb836", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a50e99c6531d1d413e75f19c802ba5fd6ab103a/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a50e99c6531d1d413e75f19c802ba5fd6ab103a/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=4a50e99c6531d1d413e75f19c802ba5fd6ab103a", "patch": "@@ -1518,32 +1518,33 @@ child_would_conflict_in_lacc (struct access *lacc, HOST_WIDE_INT norm_offset,\n \n /* Create a new child access of PARENT, with all properties just like MODEL\n    except for its offset and with its grp_write false and grp_read true.\n-   Return the new access. Note that this access is created long after all\n-   splicing and sorting, it's not located in any access vector and is\n-   automatically a representative of its group.  */\n+   Return the new access or NULL if it cannot be created.  Note that this access\n+   is created long after all splicing and sorting, it's not located in any\n+   access vector and is automatically a representative of its group.  */\n \n static struct access *\n create_artificial_child_access (struct access *parent, struct access *model,\n \t\t\t\tHOST_WIDE_INT new_offset)\n {\n   struct access *access;\n   struct access **child;\n-  bool ok;\n+  tree expr = parent->base;;\n \n   gcc_assert (!model->grp_unscalarizable_region);\n \n+  if (!build_ref_for_offset (&expr, TREE_TYPE (expr), new_offset,\n+\t\t\t     model->type, false))\n+    return NULL;\n+\n   access = (struct access *) pool_alloc (access_pool);\n   memset (access, 0, sizeof (struct access));\n   access->base = parent->base;\n+  access->expr = expr;\n   access->offset = new_offset;\n   access->size = model->size;\n   access->type = model->type;\n   access->grp_write = true;\n   access->grp_read = false;\n-  access->expr = access->base;\n-  ok = build_ref_for_offset (&access->expr, TREE_TYPE (access->expr),\n-\t\t\t     new_offset, access->type, false);\n-  gcc_assert (ok);\n \n   child = &parent->first_child;\n   while (*child && (*child)->offset < new_offset)\n@@ -1558,7 +1559,7 @@ create_artificial_child_access (struct access *parent, struct access *model,\n \n /* Propagate all subaccesses of RACC across an assignment link to LACC. Return\n    true if any new subaccess was created.  Additionally, if RACC is a scalar\n-   access but LACC is not, change the type of the latter.  */\n+   access but LACC is not, change the type of the latter, if possible.  */\n \n static bool\n propagate_subacesses_accross_link (struct access *lacc, struct access *racc)\n@@ -1575,13 +1576,14 @@ propagate_subacesses_accross_link (struct access *lacc, struct access *racc)\n   if (!lacc->first_child && !racc->first_child\n       && is_gimple_reg_type (racc->type))\n     {\n-      bool ok;\n+      tree t = lacc->base;\n \n-      lacc->expr = lacc->base;\n-      ok = build_ref_for_offset (&lacc->expr, TREE_TYPE (lacc->expr),\n-\t\t\t     lacc->offset, racc->type, false);\n-      gcc_assert (ok);\n-      lacc->type = racc->type;\n+      if (build_ref_for_offset (&t, TREE_TYPE (t), lacc->offset, racc->type,\n+\t\t\t\tfalse))\n+\t{\n+\t  lacc->expr = t;\n+\t  lacc->type = racc->type;\n+\t}\n       return false;\n     }\n \n@@ -1615,10 +1617,12 @@ propagate_subacesses_accross_link (struct access *lacc, struct access *racc)\n \n       rchild->grp_hint = 1;\n       new_acc = create_artificial_child_access (lacc, rchild, norm_offset);\n-      if (racc->first_child)\n-\tpropagate_subacesses_accross_link (new_acc, rchild);\n-\n-      ret = true;\n+      if (new_acc)\n+\t{\n+\t  ret = true;\n+\t  if (racc->first_child)\n+\t    propagate_subacesses_accross_link (new_acc, rchild);\n+\t}\n     }\n \n   return ret;"}]}