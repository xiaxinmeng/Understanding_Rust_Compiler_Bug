{"sha": "573850d4cba486247fc9f166502c98e20c09f915", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTczODUwZDRjYmE0ODYyNDdmYzlmMTY2NTAyYzk4ZTIwYzA5ZjkxNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-09-30T07:14:39Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-09-30T07:14:39Z"}, "message": "re PR rtl-optimization/12345 (internal compiler error: verify_flow_info failed)\n\n\tPR optimization/12345\n\t* config/mips/mips-protos.h (mips_restore_gp): Remove.\n\t(mips_gp_save_slot): Declare.\n\t* config/mips/mips.c (mips_restore_gp): Remove in favor of...\n\t(mips_gp_save_slot): ...this new function.\n\t* config/mips/mips.md (exception_receiver): Use mips_gp_save_slot\n\tand mips_output_move to generate the output template.\n\t(call_internal): Force splitting if TARGET_SPLIT_CALLS.  Don't emit\n\ta gp load after a noreturn call.  Load the gp using a move rather\n\tthan an exception_receiver pattern.\n\t(call_value_internal, call_value_multiple_internal): Likewise.\n\t(call_split, call_value_split, call_value_multiple_split): Clobber $28.\n\nFrom-SVN: r71935", "tree": {"sha": "d9bb6788e6323d712f0199315f1b13c2a591f53f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9bb6788e6323d712f0199315f1b13c2a591f53f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/573850d4cba486247fc9f166502c98e20c09f915", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/573850d4cba486247fc9f166502c98e20c09f915", "html_url": "https://github.com/Rust-GCC/gccrs/commit/573850d4cba486247fc9f166502c98e20c09f915", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/573850d4cba486247fc9f166502c98e20c09f915/comments", "author": null, "committer": null, "parents": [{"sha": "3c44a3c4b7774802efe6b79cd733551d7ed9325c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c44a3c4b7774802efe6b79cd733551d7ed9325c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c44a3c4b7774802efe6b79cd733551d7ed9325c"}], "stats": {"total": 112, "additions": 85, "deletions": 27}, "files": [{"sha": "78531d31642e38145f971de16c69e0e921c7bca5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573850d4cba486247fc9f166502c98e20c09f915/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573850d4cba486247fc9f166502c98e20c09f915/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=573850d4cba486247fc9f166502c98e20c09f915", "patch": "@@ -1,3 +1,18 @@\n+2003-09-30  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\tPR optimization/12345\n+\t* config/mips/mips-protos.h (mips_restore_gp): Remove.\n+\t(mips_gp_save_slot): Declare.\n+\t* config/mips/mips.c (mips_restore_gp): Remove in favor of...\n+\t(mips_gp_save_slot): ...this new function.\n+\t* config/mips/mips.md (exception_receiver): Use mips_gp_save_slot\n+\tand mips_output_move to generate the output template.\n+\t(call_internal): Force splitting if TARGET_SPLIT_CALLS.  Don't emit\n+\ta gp load after a noreturn call.  Load the gp using a move rather\n+\tthan an exception_receiver pattern.\n+\t(call_value_internal, call_value_multiple_internal): Likewise.\n+\t(call_split, call_value_split, call_value_multiple_split): Clobber $28.\n+\n 2003-09-30  Carlo Wood  <carlo@alinoe.com>\n \n \tPR debug/12319"}, {"sha": "3e3e414ad53e6e391e3090d1a05ec059252d043a", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573850d4cba486247fc9f166502c98e20c09f915/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573850d4cba486247fc9f166502c98e20c09f915/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=573850d4cba486247fc9f166502c98e20c09f915", "patch": "@@ -61,7 +61,7 @@ extern rtx mips_subword (rtx, int);\n extern bool mips_split_64bit_move_p (rtx, rtx);\n extern void mips_split_64bit_move (rtx, rtx);\n extern const char *mips_output_move (rtx, rtx);\n-extern const char *mips_restore_gp (rtx *);\n+extern rtx mips_gp_save_slot (void);\n #ifdef RTX_CODE\n extern rtx gen_int_relational (enum rtx_code, rtx, rtx, rtx, int *);\n extern void gen_conditional_branch (rtx *, enum rtx_code);"}, {"sha": "a2232f0c0df9c4c34ae5a510d7fc0cd6972c5212", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573850d4cba486247fc9f166502c98e20c09f915/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573850d4cba486247fc9f166502c98e20c09f915/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=573850d4cba486247fc9f166502c98e20c09f915", "patch": "@@ -2749,30 +2749,27 @@ mips_output_move (rtx dest, rtx src)\n   abort ();\n }\n \f\n-/* Return instructions to restore the global pointer from the stack,\n-   assuming TARGET_ABICALLS.  Used by exception_receiver to set up\n-   the GP for exception handlers.\n+/* Return an rtx for the gp save slot.  Valid only when using o32 or\n+   o64 abicalls.  */\n \n-   OPERANDS is an array of operands whose contents are undefined\n-   on entry.  */\n-\n-const char *\n-mips_restore_gp (rtx *operands)\n+rtx\n+mips_gp_save_slot (void)\n {\n   rtx loc;\n \n-  operands[0] = pic_offset_table_rtx;\n+  if (!TARGET_ABICALLS || TARGET_NEWABI)\n+    abort ();\n+\n   if (frame_pointer_needed)\n     loc = hard_frame_pointer_rtx;\n   else\n     loc = stack_pointer_rtx;\n   loc = plus_constant (loc, current_function_outgoing_args_size);\n-  operands[1] = gen_rtx_MEM (ptr_mode, loc);\n-\n-  return mips_output_move (operands[0], operands[1]);\n+  loc = gen_rtx_MEM (Pmode, loc);\n+  RTX_UNCHANGING_P (loc) = 1;\n+  return loc;\n }\n \f\n-\f\n /* Make normal rtx_code into something we can index from an array */\n \n static enum internal_test"}, {"sha": "1b184ac11fe1090e06362569bd2ae7d51f8fedae", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573850d4cba486247fc9f166502c98e20c09f915/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573850d4cba486247fc9f166502c98e20c09f915/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=573850d4cba486247fc9f166502c98e20c09f915", "patch": "@@ -8228,7 +8228,11 @@ ld\\t%2,%1-%S1(%2)\\;daddu\\t%2,%2,$31\\;%*j\\t%2%/\"\n   [(set (reg:SI 28)\n \t(unspec_volatile:SI [(const_int 0)] UNSPEC_EH_RECEIVER))]\n   \"TARGET_ABICALLS && (mips_abi == ABI_32 || mips_abi == ABI_O64)\"\n-  { return mips_restore_gp (operands); }\n+{\n+  operands[0] = pic_offset_table_rtx;\n+  operands[1] = mips_gp_save_slot ();\n+  return mips_output_move (operands[0], operands[1]);\n+}\n   [(set_attr \"type\"   \"load\")\n    (set_attr \"length\" \"8\")])\n \f\n@@ -8317,17 +8321,55 @@ ld\\t%2,%1-%S1(%2)\\;daddu\\t%2,%2,$31\\;%*j\\t%2%/\"\n   DONE;\n })\n \n+;; This instruction directly corresponds to an assembly-language \"jal\".\n+;; There are four cases:\n+;;\n+;;    - -mno-abicalls:\n+;;\t  Both symbolic and register destinations are OK.  The pattern\n+;;\t  always expands to a single mips instruction.\n+;;\n+;;    - -mabicalls/-mno-explicit-relocs:\n+;;\t  Again, both symbolic and register destinations are OK.\n+;;\t  The call is treated as a multi-instruction black box.\n+;;\n+;;    - -mabicalls/-mexplicit-relocs with n32 or n64:\n+;;\t  Only \"jal $25\" is allowed.  This expands to a single \"jalr $25\"\n+;;\t  instruction.\n+;;\n+;;    - -mabicalls/-mexplicit-relocs with o32 or o64:\n+;;\t  Only \"jal $25\" is allowed.  The call is actually two instructions:\n+;;\t  \"jalr $25\" followed by an insn to reload $gp.\n+;;\n+;; In the last case, we can generate the individual instructions with\n+;; a define_split.  There are several things to be wary of:\n+;;\n+;;   - We can't expose the load of $gp before reload.  If we did,\n+;;     it might get removed as dead, but reload can introduce new\n+;;     uses of $gp by rematerializing constants.\n+;;\n+;;   - We shouldn't restore $gp after calls that never return.\n+;;     It isn't valid to insert instructions between a noreturn\n+;;     call and the following barrier.\n+;;\n+;;   - The splitter deliberately changes the liveness of $gp.  The unsplit\n+;;     instruction preserves $gp and so have no effect on its liveness.\n+;;     But once we generate the separate insns, it becomes obvious that\n+;;     $gp is not live on entry to the call.\n+;;\n+;; ??? The operands[2] = insn check is a hack to make the original insn\n+;; available to the splitter.\n (define_insn_and_split \"call_internal\"\n   [(call (mem:SI (match_operand 0 \"call_insn_operand\" \"c,S\"))\n \t (match_operand 1 \"\" \"\"))\n    (clobber (reg:SI 31))]\n   \"\"\n-  \"%*jal\\t%0%/\"\n-  \"reload_completed && TARGET_SPLIT_CALLS\"\n+  { return TARGET_SPLIT_CALLS ? \"#\" : \"%*jal\\t%0%/\"; }\n+  \"reload_completed && TARGET_SPLIT_CALLS && (operands[2] = insn)\"\n   [(const_int 0)]\n {\n   emit_call_insn (gen_call_split (operands[0], operands[1]));\n-  emit_insn (gen_exception_receiver ());\n+  if (!find_reg_note (operands[2], REG_NORETURN, 0))\n+    emit_move_insn (pic_offset_table_rtx, mips_gp_save_slot ());\n   DONE;\n }\n   [(set_attr \"jal\" \"indirect,direct\")\n@@ -8337,7 +8379,7 @@ ld\\t%2,%1-%S1(%2)\\;daddu\\t%2,%2,$31\\;%*j\\t%2%/\"\n   [(call (mem:SI (match_operand 0 \"call_insn_operand\" \"c\"))\n \t (match_operand 1 \"\" \"\"))\n    (clobber (reg:SI 31))\n-   (const_int 1)]\n+   (clobber (reg:SI 28))]\n   \"TARGET_SPLIT_CALLS\"\n   \"%*jalr\\t%0%/\"\n   [(set_attr \"type\" \"call\")])\n@@ -8354,19 +8396,21 @@ ld\\t%2,%1-%S1(%2)\\;daddu\\t%2,%2,$31\\;%*j\\t%2%/\"\n   DONE;\n })\n \n+;; See comment for call_internal.\n (define_insn_and_split \"call_value_internal\"\n   [(set (match_operand 0 \"register_operand\" \"=df,df\")\n         (call (mem:SI (match_operand 1 \"call_insn_operand\" \"c,S\"))\n               (match_operand 2 \"\" \"\")))\n    (clobber (reg:SI 31))]\n   \"\"\n-  \"%*jal\\t%1%/\"\n-  \"reload_completed && TARGET_SPLIT_CALLS\"\n+  { return TARGET_SPLIT_CALLS ? \"#\" : \"%*jal\\t%1%/\"; }\n+  \"reload_completed && TARGET_SPLIT_CALLS && (operands[3] = insn)\"\n   [(const_int 0)]\n {\n   emit_call_insn (gen_call_value_split (operands[0], operands[1],\n \t\t\t\t\toperands[2]));\n-  emit_insn (gen_exception_receiver ());\n+  if (!find_reg_note (operands[3], REG_NORETURN, 0))\n+    emit_move_insn (pic_offset_table_rtx, mips_gp_save_slot ());\n   DONE;\n }\n   [(set_attr \"jal\" \"indirect,direct\")\n@@ -8377,11 +8421,12 @@ ld\\t%2,%1-%S1(%2)\\;daddu\\t%2,%2,$31\\;%*j\\t%2%/\"\n         (call (mem:SI (match_operand 1 \"call_insn_operand\" \"c\"))\n               (match_operand 2 \"\" \"\")))\n    (clobber (reg:SI 31))\n-   (const_int 1)]\n+   (clobber (reg:SI 28))]\n   \"TARGET_SPLIT_CALLS\"\n   \"%*jalr\\t%1%/\"\n   [(set_attr \"type\" \"call\")])\n \n+;; See comment for call_internal.\n (define_insn_and_split \"call_value_multiple_internal\"\n   [(set (match_operand 0 \"register_operand\" \"=df,df\")\n         (call (mem:SI (match_operand 1 \"call_insn_operand\" \"c,S\"))\n@@ -8391,13 +8436,14 @@ ld\\t%2,%1-%S1(%2)\\;daddu\\t%2,%2,$31\\;%*j\\t%2%/\"\n \t      (match_dup 2)))\n    (clobber (reg:SI 31))]\n   \"\"\n-  \"%*jal\\t%1%/\"\n-  \"reload_completed && TARGET_SPLIT_CALLS\"\n+  { return TARGET_SPLIT_CALLS ? \"#\" : \"%*jal\\t%1%/\"; }\n+  \"reload_completed && TARGET_SPLIT_CALLS && (operands[4] = insn)\"\n   [(const_int 0)]\n {\n   emit_call_insn (gen_call_value_multiple_split (operands[0], operands[1],\n \t\t\t\t\t\t operands[2], operands[3]));\n-  emit_insn (gen_exception_receiver ());\n+  if (!find_reg_note (operands[4], REG_NORETURN, 0))\n+    emit_move_insn (pic_offset_table_rtx, mips_gp_save_slot ());\n   DONE;\n }\n   [(set_attr \"jal\" \"indirect,direct\")\n@@ -8411,7 +8457,7 @@ ld\\t%2,%1-%S1(%2)\\;daddu\\t%2,%2,$31\\;%*j\\t%2%/\"\n \t(call (mem:SI (match_dup 1))\n \t      (match_dup 2)))\n    (clobber (reg:SI 31))\n-   (const_int 1)]\n+   (clobber (reg:SI 28))]\n   \"TARGET_SPLIT_CALLS\"\n   \"%*jalr\\t%1%/\"\n   [(set_attr \"type\" \"call\")])"}]}