{"sha": "09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDllMzYxYmJkZTViNGY5Yzc0ZTg0NmZmNDkzNjBhNDJkMjVlYzJkNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-02-16T12:19:34Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-02-16T12:19:34Z"}, "message": "gthr-dce.h: Uglify function parameter and local variable names.\n\n\t* gthr-dce.h: Uglify function parameter and local variable names.\n\t* gthr-gnat.h: Likewise.\n\t* gthr-mipssde.h: Likewise.\n\t* gthr-nks.h: Likewise.\n\t* gthr-posix95.h: Likewise.\n\t* gthr-posix.h: Likewise.\n\t* gthr-rtems.h: Likewise.\n\t* gthr-single.h: Likewise.\n\t* gthr-solaris.h: Likewise.\n\t* gthr-tpf.h: Likewise.\n\t* gthr-vxworks.h: Likewise.\n\t* gthr-win32.h: Likewise.\n\nFrom-SVN: r144201", "tree": {"sha": "dcc77a0b95af985cbd224bc073c240ec95ae226c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcc77a0b95af985cbd224bc073c240ec95ae226c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "70f5fc7c74889090b3989c37c302ba244ea46fcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70f5fc7c74889090b3989c37c302ba244ea46fcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70f5fc7c74889090b3989c37c302ba244ea46fcc"}], "stats": {"total": 1025, "additions": 523, "deletions": 502}, "files": [{"sha": "d4b7860060811345bbc3d92c9a448dc17e1fe112", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "patch": "@@ -1,3 +1,18 @@\n+2009-02-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gthr-dce.h: Uglify function parameter and local variable names.\n+\t* gthr-gnat.h: Likewise.\n+\t* gthr-mipssde.h: Likewise.\n+\t* gthr-nks.h: Likewise.\n+\t* gthr-posix95.h: Likewise.\n+\t* gthr-posix.h: Likewise.\n+\t* gthr-rtems.h: Likewise.\n+\t* gthr-single.h: Likewise.\n+\t* gthr-solaris.h: Likewise.\n+\t* gthr-tpf.h: Likewise.\n+\t* gthr-vxworks.h: Likewise.\n+\t* gthr-win32.h: Likewise.\n+\n 2009-02-15  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/39196"}, {"sha": "50b6fdb51e6931e1cb119ba1eb4deb3bf349cf0d", "filename": "gcc/gthr-dce.h", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-dce.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-dce.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-dce.h?ref=09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "patch": "@@ -1,6 +1,6 @@\n /* Threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 1997, 1999, 2000, 2001, 2004, 2005\n+/* Copyright (C) 1997, 1999, 2000, 2001, 2004, 2005, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -431,122 +431,123 @@ __gthread_objc_condition_signal (objc_condition_t condition\n #else /* _LIBOBJC */\n \n static inline int\n-__gthread_once (__gthread_once_t *once, void (*func) (void))\n+__gthread_once (__gthread_once_t *__once, void (*__func) (void))\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(pthread_once) (once, func);\n+    return __gthrw_(pthread_once) (__once, __func);\n   else\n     return -1;\n }\n \n static inline int\n-__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))\n {\n-  return __gthrw_(pthread_keycreate) (key, dtor);\n+  return __gthrw_(pthread_keycreate) (__key, __dtor);\n }\n \n static inline int\n-__gthread_key_delete (__gthread_key_t key __attribute__ ((__unused__)))\n+__gthread_key_delete (__gthread_key_t __key __attribute__ ((__unused__)))\n {\n   /* Operation is not supported.  */\n   return -1;\n }\n \n static inline void *\n-__gthread_getspecific (__gthread_key_t key)\n+__gthread_getspecific (__gthread_key_t __key)\n {\n-  void *ptr;\n-  if (__gthrw_(pthread_getspecific) (key, &ptr) == 0)\n-    return ptr;\n+  void *__ptr;\n+  if (__gthrw_(pthread_getspecific) (__key, &__ptr) == 0)\n+    return __ptr;\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_setspecific (__gthread_key_t key, const void *ptr)\n+__gthread_setspecific (__gthread_key_t __key, const void *__ptr)\n {\n-  return __gthrw_(pthread_setspecific) (key, (void *) ptr);\n+  return __gthrw_(pthread_setspecific) (__key, (void *) __ptr);\n }\n \n static inline void\n-__gthread_mutex_init_function (__gthread_mutex_t *mutex)\n+__gthread_mutex_init_function (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    __gthrw_(pthread_mutex_init) (mutex, pthread_mutexattr_default);\n+    __gthrw_(pthread_mutex_init) (__mutex, pthread_mutexattr_default);\n }\n \n static inline int\n-__gthread_mutx_destroy (__gthread_mutex_t *mutex)\n+__gthread_mutx_destroy (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_destroy) (mutex);\n+    return __gthrw_(pthread_mutex_destroy) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+__gthread_mutex_lock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_lock) (mutex);\n+    return __gthrw_(pthread_mutex_lock) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_trylock) (mutex);\n+    return __gthrw_(pthread_mutex_trylock) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+__gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_unlock) (mutex);\n+    return __gthrw_(pthread_mutex_unlock) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      pthread_mutexattr_t attr;\n-      int r;\n-\n-      r = __gthrw_(pthread_mutexattr_create) (&attr);\n-      if (!r)\n-\tr = __gthrw_(pthread_mutexattr_setkind_np) (&attr, MUTEX_RECURSIVE_NP);\n-      if (!r)\n-\tr = __gthrw_(pthread_mutex_init) (mutex, attr);\n-      if (!r)\n-\tr = __gthrw_(pthread_mutexattr_delete) (&attr);\n-      return r;\n+      pthread_mutexattr_t __attr;\n+      int __r;\n+\n+      __r = __gthrw_(pthread_mutexattr_create) (&__attr);\n+      if (!__r)\n+\t__r = __gthrw_(pthread_mutexattr_setkind_np) (&__attr,\n+\t\t\t\t\t\t      MUTEX_RECURSIVE_NP);\n+      if (!__r)\n+\t__r = __gthrw_(pthread_mutex_init) (__mutex, __attr);\n+      if (!__r)\n+\t__r = __gthrw_(pthread_mutexattr_delete) (&__attr);\n+      return __r;\n     }\n   return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n {\n-  return __gthread_mutex_lock (mutex);\n+  return __gthread_mutex_lock (__mutex);\n }\n \n static inline int\n-__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n {\n-  return __gthread_mutex_trylock (mutex);\n+  return __gthread_mutex_trylock (__mutex);\n }\n \n static inline int\n-__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n {\n-  return __gthread_mutex_unlock (mutex);\n+  return __gthread_mutex_unlock (__mutex);\n }\n \n #endif /* _LIBOBJC */"}, {"sha": "51066df47bd287d7026d5a119356a1dd1f85a2b2", "filename": "gcc/gthr-gnat.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-gnat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-gnat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-gnat.h?ref=09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "patch": "@@ -1,6 +1,6 @@\n /* Threads compatibility routines for libgcc2.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+/* Copyright (C) 2003, 2004, 2008, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -38,7 +38,7 @@ typedef int __gthread_mutex_t;\n \n #define __GTHREAD_MUTEX_INIT 0\n \n-extern void __gnat_install_locks (void (*lock) (void), void (*unlock) (void));\n+extern void __gnat_install_locks (void (*) (void), void (*) (void));\n extern int __gthread_active_p (void);\n extern int __gthread_mutex_lock (__gthread_mutex_t *);\n extern int __gthread_mutex_unlock (__gthread_mutex_t *);"}, {"sha": "325bcc52e600e6ec5f0745cda305acd24ad7d148", "filename": "gcc/gthr-mipssde.h", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-mipssde.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-mipssde.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-mipssde.h?ref=09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "patch": "@@ -1,6 +1,6 @@\n /* MIPS SDE threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n    Contributed by Nigel Stephens <nigel@mips.com>\n \n This file is part of GCC.\n@@ -55,7 +55,7 @@ typedef struct {\n #define __GTHREAD_MUTEX_INIT __SDETHREAD_MUTEX_INITIALIZER(\"gthr\")\n #define __GTHREAD_ONCE_INIT __SDETHREAD_ONCE_INIT\n static inline int\n-__gthread_recursive_mutex_init_function(__gthread_recursive_mutex_t *mutex);\n+__gthread_recursive_mutex_init_function(__gthread_recursive_mutex_t *__mutex);\n #define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n@@ -102,125 +102,125 @@ __gthread_active_p (void)\n #endif /* SUPPORTS_WEAK */\n \n static inline int\n-__gthread_once (__gthread_once_t *once, void (*func) (void))\n+__gthread_once (__gthread_once_t *__once, void (*__func) (void))\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(__sdethread_once) (once, func);\n+    return __gthrw_(__sdethread_once) (__once, __func);\n   else\n     return -1;\n }\n \n static inline int\n-__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))\n {\n-  return __gthrw_(__sdethread_key_create) (key, dtor);\n+  return __gthrw_(__sdethread_key_create) (__key, __dtor);\n }\n \n static inline int\n-__gthread_key_delete (__gthread_key_t key)\n+__gthread_key_delete (__gthread_key_t __key)\n {\n-  return __gthrw_(__sdethread_key_delete) (key);\n+  return __gthrw_(__sdethread_key_delete) (__key);\n }\n \n static inline void *\n-__gthread_getspecific (__gthread_key_t key)\n+__gthread_getspecific (__gthread_key_t __key)\n {\n-  return __gthrw_(__sdethread_getspecific) (key);\n+  return __gthrw_(__sdethread_getspecific) (__key);\n }\n \n static inline int\n-__gthread_setspecific (__gthread_key_t key, const void *ptr)\n+__gthread_setspecific (__gthread_key_t __key, const void *__ptr)\n {\n-  return __gthrw_(__sdethread_setspecific) (key, ptr);\n+  return __gthrw_(__sdethread_setspecific) (__key, __ptr);\n }\n \n static inline int\n-__gthread_mutex_destroy (__gthread_mutex_t * UNUSED(mutex))\n+__gthread_mutex_destroy (__gthread_mutex_t * UNUSED(__mutex))\n {\n   return 0;\n }\n \n static inline int\n-__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+__gthread_mutex_lock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(__sdethread_mutex_lock) (mutex);\n+    return __gthrw_(__sdethread_mutex_lock) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(__sdethread_mutex_trylock) (mutex);\n+    return __gthrw_(__sdethread_mutex_trylock) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+__gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(__sdethread_mutex_unlock) (mutex);\n+    return __gthrw_(__sdethread_mutex_unlock) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)\n {\n-  mutex->depth = 0;\n-  mutex->owner = __gthrw_(__sdethread_self) ();\n-  return __gthrw_(__sdethread_mutex_init) (&mutex->actual, NULL);\n+  __mutex->depth = 0;\n+  __mutex->owner = __gthrw_(__sdethread_self) ();\n+  return __gthrw_(__sdethread_mutex_init) (&__mutex->actual, NULL);\n }\n \n static inline int\n-__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      __sdethread_t me = __gthrw_(__sdethread_self) ();\n+      __sdethread_t __me = __gthrw_(__sdethread_self) ();\n \n-      if (mutex->owner != me)\n+      if (__mutex->owner != __me)\n \t{\n-\t  __gthrw_(__sdethread_mutex_lock) (&mutex->actual);\n-\t  mutex->owner = me;\n+\t  __gthrw_(__sdethread_mutex_lock) (&__mutex->actual);\n+\t  __mutex->owner = __me;\n \t}\n \n-      mutex->depth++;\n+      __mutex->depth++;\n     }\n   return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      __sdethread_t me = __gthrw_(__sdethread_self) ();\n+      __sdethread_t __me = __gthrw_(__sdethread_self) ();\n \n-      if (mutex->owner != me)\n+      if (__mutex->owner != __me)\n \t{\n-\t  if (__gthrw_(__sdethread_mutex_trylock) (&mutex->actual))\n+\t  if (__gthrw_(__sdethread_mutex_trylock) (&__mutex->actual))\n \t    return 1;\n-\t  mutex->owner = me;\n+\t  __mutex->owner = __me;\n \t}\n \n-      mutex->depth++;\n+      __mutex->depth++;\n     }\n   return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      if (--mutex->depth == 0)\n+      if (--__mutex->depth == 0)\n \t{\n-\t   mutex->owner = (__sdethread_t) 0;\n-\t   __gthrw_(__sdethread_mutex_unlock) (&mutex->actual);\n+\t   __mutex->owner = (__sdethread_t) 0;\n+\t   __gthrw_(__sdethread_mutex_unlock) (&__mutex->actual);\n \t}\n     }\n   return 0;"}, {"sha": "1d0d1c2f1258e586407395a2714d35ddbc506f51", "filename": "gcc/gthr-nks.h", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-nks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-nks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-nks.h?ref=09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "patch": "@@ -1,6 +1,6 @@\n /* Threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2004, 2008, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -281,118 +281,118 @@ typedef volatile long __gthread_once_t;\n #define __GTHREAD_ONCE_INIT 0\n \n static inline int\n-__gthread_once (__gthread_once_t *once, void (*func) (void))\n+__gthread_once (__gthread_once_t *__once, void (*__func) (void))\n {\n-  if (__compare_and_swap (once, 0, 1))\n+  if (__compare_and_swap (__once, 0, 1))\n   {\n-    func();\n-    *once |= 2;\n+    __func ();\n+    *__once |= 2;\n   }\n   else\n   {\n-    while (!(*once & 2))\n+    while (!(*__once & 2))\n       NXThreadYield ();\n   }\n   return 0;\n }\n \n static inline int\n-__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))\n {\n-  return NXKeyCreate (dtor, NULL, key);\n+  return NXKeyCreate (__dtor, NULL, __key);\n }\n \n static inline int\n-__gthread_key_dtor (__gthread_key_t key, void *ptr)\n+__gthread_key_dtor (__gthread_key_t __key, void *__ptr)\n {\n   /* Just reset the key value to zero. */\n-  if (ptr)\n-    return NXKeySetValue (key, NULL);\n+  if (__ptr)\n+    return NXKeySetValue (__key, NULL);\n   return 0;\n }\n \n static inline int\n-__gthread_key_delete (__gthread_key_t key)\n+__gthread_key_delete (__gthread_key_t __key)\n {\n-  return NXKeyDelete (key);\n+  return NXKeyDelete (__key);\n }\n \n static inline void *\n-__gthread_getspecific (__gthread_key_t key)\n+__gthread_getspecific (__gthread_key_t __key)\n {\n-  void *value;\n+  void *__value;\n \n-  if (NXKeyGetValue (key, &value) == 0)\n-    return value;\n+  if (NXKeyGetValue (__key, &__value) == 0)\n+    return __value;\n   return NULL;\n }\n \n static inline int\n-__gthread_setspecific (__gthread_key_t key, const void *ptr)\n+__gthread_setspecific (__gthread_key_t __key, const void *__ptr)\n {\n-  return NXKeySetValue (key, (void *)ptr);\n+  return NXKeySetValue (__key, (void *)__ptr);\n }\n \n static inline void\n-__gthread_mutex_init_function (__gthread_mutex_t *mutex)\n+__gthread_mutex_init_function (__gthread_mutex_t *__mutex)\n {\n-  static const NX_LOCK_INFO_ALLOC (info, \"GTHREADS\", 0);\n+  static const NX_LOCK_INFO_ALLOC (__info, \"GTHREADS\", 0);\n \n-  *mutex = NXMutexAlloc (0, 0, &info);\n+  *__mutex = NXMutexAlloc (0, 0, &__info);\n }\n \n static inline int\n-__gthread_mutex_destroy (__gthread_mutex_t * UNUSED(mutex))\n+__gthread_mutex_destroy (__gthread_mutex_t * UNUSED(__mutex))\n {\n   return 0;\n }\n \n static inline int\n-__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+__gthread_mutex_lock (__gthread_mutex_t *__mutex)\n {\n-  return NXLock (*mutex);\n+  return NXLock (*__mutex);\n }\n \n static inline int\n-__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n {\n-  if (NXTryLock (*mutex))\n+  if (NXTryLock (*__mutex))\n     return 0;\n   return -1;\n }\n \n static inline int\n-__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+__gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n {\n-  return NXUnlock (*mutex);\n+  return NXUnlock (*__mutex);\n }\n \n static inline void\n-__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)\n {\n-  static const NX_LOCK_INFO_ALLOC (info, \"GTHREADS\", 0);\n+  static const NX_LOCK_INFO_ALLOC (__info, \"GTHREADS\", 0);\n \n-  *mutex = NXMutexAlloc (NX_MUTEX_RECURSIVE, 0, &info);\n+  *__mutex = NXMutexAlloc (NX_MUTEX_RECURSIVE, 0, &__info);\n }\n \n static inline int\n-__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n {\n-  return NXLock (*mutex);\n+  return NXLock (*__mutex);\n }\n \n static inline int\n-__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n {\n-  if (NXTryLock (*mutex))\n+  if (NXTryLock (*__mutex))\n     return 0;\n   return -1;\n }\n \n static inline int\n-__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n {\n-  return NXUnlock (*mutex);\n+  return NXUnlock (*__mutex);\n }\n \n #endif /* _LIBOBJC */"}, {"sha": "e0d2bbff61171219b9c461dfdfa31a13c79aef7c", "filename": "gcc/gthr-posix.h", "status": "modified", "additions": 81, "deletions": 79, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix.h?ref=09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "patch": "@@ -1,7 +1,7 @@\n /* Threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 1997, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n-   Free Software Foundation, Inc.\n+/* Copyright (C) 1997, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\n+   2008, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -267,7 +267,7 @@ __gthread_active_p (void)\n static volatile int __gthread_active = -1;\n \n static void *\n-__gthread_start (void *arg __attribute__((unused)))\n+__gthread_start (void *__arg __attribute__((unused)))\n {\n   return NULL;\n }\n@@ -277,21 +277,21 @@ static void\n __gthread_active_init (void)\n {\n   static pthread_mutex_t __gthread_active_mutex = PTHREAD_MUTEX_INITIALIZER;\n-  pthread_t t;\n-  pthread_attr_t a;\n-  int result;\n+  pthread_t __t;\n+  pthread_attr_t __a;\n+  int __result;\n \n   __gthrw_(pthread_mutex_lock) (&__gthread_active_mutex);\n   if (__gthread_active < 0)\n     {\n-      __gthrw_(pthread_attr_init) (&a);\n-      __gthrw_(pthread_attr_setdetachstate) (&a, PTHREAD_CREATE_DETACHED);\n-      result = __gthrw_(pthread_create) (&t, &a, __gthread_start, NULL);\n-      if (result != ENOSYS)\n+      __gthrw_(pthread_attr_init) (&__a);\n+      __gthrw_(pthread_attr_setdetachstate) (&__a, PTHREAD_CREATE_DETACHED);\n+      __result = __gthrw_(pthread_create) (&__t, &__a, __gthread_start, NULL);\n+      if (__result != ENOSYS)\n \t__gthread_active = 1;\n       else\n \t__gthread_active = 0;\n-      __gthrw_(pthread_attr_destroy) (&a);\n+      __gthrw_(pthread_attr_destroy) (&__a);\n     }\n   __gthrw_(pthread_mutex_unlock) (&__gthread_active_mutex);\n }\n@@ -676,27 +676,28 @@ __gthread_objc_condition_signal (objc_condition_t condition)\n #else /* _LIBOBJC */\n \n static inline int\n-__gthread_create (__gthread_t *thread, void *(*func) (void*), void *args)\n+__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),\n+\t\t  void *__args)\n {\n-  return __gthrw_(pthread_create) (thread, NULL, func, args);\n+  return __gthrw_(pthread_create) (__threadid, NULL, __func, __args);\n }\n \n static inline int\n-__gthread_join (__gthread_t thread, void **value_ptr)\n+__gthread_join (__gthread_t __threadid, void **__value_ptr)\n {\n-  return __gthrw_(pthread_join) (thread, value_ptr);\n+  return __gthrw_(pthread_join) (__threadid, __value_ptr);\n }\n \n static inline int\n-__gthread_detach (__gthread_t thread)\n+__gthread_detach (__gthread_t __threadid)\n {\n-  return __gthrw_(pthread_detach) (thread);\n+  return __gthrw_(pthread_detach) (__threadid);\n }\n \n static inline int\n-__gthread_equal (__gthread_t t1, __gthread_t t2)\n+__gthread_equal (__gthread_t __t1, __gthread_t __t2)\n {\n-  return __gthrw_(pthread_equal) (t1, t2);\n+  return __gthrw_(pthread_equal) (__t1, __t2);\n }\n \n static inline __gthread_t\n@@ -712,183 +713,184 @@ __gthread_yield (void)\n }\n \n static inline int\n-__gthread_once (__gthread_once_t *once, void (*func) (void))\n+__gthread_once (__gthread_once_t *__once, void (*__func) (void))\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(pthread_once) (once, func);\n+    return __gthrw_(pthread_once) (__once, __func);\n   else\n     return -1;\n }\n \n static inline int\n-__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))\n {\n-  return __gthrw_(pthread_key_create) (key, dtor);\n+  return __gthrw_(pthread_key_create) (__key, __dtor);\n }\n \n static inline int\n-__gthread_key_delete (__gthread_key_t key)\n+__gthread_key_delete (__gthread_key_t __key)\n {\n-  return __gthrw_(pthread_key_delete) (key);\n+  return __gthrw_(pthread_key_delete) (__key);\n }\n \n static inline void *\n-__gthread_getspecific (__gthread_key_t key)\n+__gthread_getspecific (__gthread_key_t __key)\n {\n-  return __gthrw_(pthread_getspecific) (key);\n+  return __gthrw_(pthread_getspecific) (__key);\n }\n \n static inline int\n-__gthread_setspecific (__gthread_key_t key, const void *ptr)\n+__gthread_setspecific (__gthread_key_t __key, const void *__ptr)\n {\n-  return __gthrw_(pthread_setspecific) (key, ptr);\n+  return __gthrw_(pthread_setspecific) (__key, __ptr);\n }\n \n static inline int\n-__gthread_mutex_destroy (__gthread_mutex_t *mutex)\n+__gthread_mutex_destroy (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_destroy) (mutex);\n+    return __gthrw_(pthread_mutex_destroy) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+__gthread_mutex_lock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_lock) (mutex);\n+    return __gthrw_(pthread_mutex_lock) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_trylock) (mutex);\n+    return __gthrw_(pthread_mutex_trylock) (__mutex);\n   else\n     return 0;\n }\n \n #ifdef _POSIX_TIMEOUTS\n #if _POSIX_TIMEOUTS >= 0\n static inline int\n-__gthread_mutex_timedlock (__gthread_mutex_t *mutex,\n-\t\t\t   const __gthread_time_t *abs_timeout)\n+__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,\n+\t\t\t   const __gthread_time_t *__abs_timeout)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_timedlock) (mutex, abs_timeout);\n+    return __gthrw_(pthread_mutex_timedlock) (__mutex, __abs_timeout);\n   else\n     return 0;\n }\n #endif\n #endif\n \n static inline int\n-__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+__gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_unlock) (mutex);\n+    return __gthrw_(pthread_mutex_unlock) (__mutex);\n   else\n     return 0;\n }\n \n #ifndef PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP\n static inline int\n-__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      pthread_mutexattr_t attr;\n-      int r;\n-\n-      r = __gthrw_(pthread_mutexattr_init) (&attr);\n-      if (!r)\n-\tr = __gthrw_(pthread_mutexattr_settype) (&attr, PTHREAD_MUTEX_RECURSIVE);\n-      if (!r)\n-\tr = __gthrw_(pthread_mutex_init) (mutex, &attr);\n-      if (!r)\n-\tr = __gthrw_(pthread_mutexattr_destroy) (&attr);\n-      return r;\n+      pthread_mutexattr_t __attr;\n+      int __r;\n+\n+      __r = __gthrw_(pthread_mutexattr_init) (&__attr);\n+      if (!__r)\n+\t__r = __gthrw_(pthread_mutexattr_settype) (&__attr,\n+\t\t\t\t\t\t   PTHREAD_MUTEX_RECURSIVE);\n+      if (!__r)\n+\t__r = __gthrw_(pthread_mutex_init) (__mutex, &__attr);\n+      if (!__r)\n+\t__r = __gthrw_(pthread_mutexattr_destroy) (&__attr);\n+      return __r;\n     }\n   return 0;\n }\n #endif\n \n static inline int\n-__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n {\n-  return __gthread_mutex_lock (mutex);\n+  return __gthread_mutex_lock (__mutex);\n }\n \n static inline int\n-__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n {\n-  return __gthread_mutex_trylock (mutex);\n+  return __gthread_mutex_trylock (__mutex);\n }\n \n #ifdef _POSIX_TIMEOUTS\n #if _POSIX_TIMEOUTS >= 0\n static inline int\n-__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *mutex,\n-\t\t\t\t     const __gthread_time_t *abs_timeout)\n+__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,\n+\t\t\t\t     const __gthread_time_t *__abs_timeout)\n {\n-  return __gthread_mutex_timedlock (mutex, abs_timeout);\n+  return __gthread_mutex_timedlock (__mutex, __abs_timeout);\n }\n #endif\n #endif\n \n static inline int\n-__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n {\n-  return __gthread_mutex_unlock (mutex);\n+  return __gthread_mutex_unlock (__mutex);\n }\n \n static inline int\n-__gthread_cond_broadcast (__gthread_cond_t *cond)\n+__gthread_cond_broadcast (__gthread_cond_t *__cond)\n {\n-  return __gthrw_(pthread_cond_broadcast) (cond);\n+  return __gthrw_(pthread_cond_broadcast) (__cond);\n }\n \n static inline int\n-__gthread_cond_signal (__gthread_cond_t *cond)\n+__gthread_cond_signal (__gthread_cond_t *__cond)\n {\n-  return __gthrw_(pthread_cond_signal) (cond);\n+  return __gthrw_(pthread_cond_signal) (__cond);\n }\n \n static inline int\n-__gthread_cond_wait (__gthread_cond_t *cond, __gthread_mutex_t *mutex)\n+__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)\n {\n-  return __gthrw_(pthread_cond_wait) (cond, mutex);\n+  return __gthrw_(pthread_cond_wait) (__cond, __mutex);\n }\n \n static inline int\n-__gthread_cond_timedwait (__gthread_cond_t *cond, __gthread_mutex_t *mutex,\n-\t\t\t  const __gthread_time_t *abs_timeout)\n+__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,\n+\t\t\t  const __gthread_time_t *__abs_timeout)\n {\n-  return __gthrw_(pthread_cond_timedwait) (cond, mutex, abs_timeout);\n+  return __gthrw_(pthread_cond_timedwait) (__cond, __mutex, __abs_timeout);\n }\n \n static inline int\n-__gthread_cond_wait_recursive (__gthread_cond_t *cond,\n-\t\t\t       __gthread_recursive_mutex_t *mutex)\n+__gthread_cond_wait_recursive (__gthread_cond_t *__cond,\n+\t\t\t       __gthread_recursive_mutex_t *__mutex)\n {\n-  return __gthread_cond_wait (cond, mutex);\n+  return __gthread_cond_wait (__cond, __mutex);\n }\n \n static inline int\n-__gthread_cond_timedwait_recursive (__gthread_cond_t *cond,\n-\t\t\t\t    __gthread_recursive_mutex_t *mutex,\n-\t\t\t\t    const __gthread_time_t *abs_timeout)\n+__gthread_cond_timedwait_recursive (__gthread_cond_t *__cond,\n+\t\t\t\t    __gthread_recursive_mutex_t *__mutex,\n+\t\t\t\t    const __gthread_time_t *__abs_timeout)\n {\n-  return __gthread_cond_timedwait (cond, mutex, abs_timeout);\n+  return __gthread_cond_timedwait (__cond, __mutex, __abs_timeout);\n }\n \n static inline int\n-__gthread_cond_destroy (__gthread_cond_t* cond)\n+__gthread_cond_destroy (__gthread_cond_t* __cond)\n {\n-  return __gthrw_(pthread_cond_destroy) (cond);\n+  return __gthrw_(pthread_cond_destroy) (__cond);\n }\n \n #endif /* _LIBOBJC */"}, {"sha": "9310a7e2dd0b82305032a6eb484ec6de8d15405b", "filename": "gcc/gthr-posix95.h", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-posix95.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-posix95.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix95.h?ref=09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "patch": "@@ -1,6 +1,6 @@\n /* Threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 2004, 2005, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -610,150 +610,150 @@ __gthread_objc_condition_signal (objc_condition_t condition)\n #else /* _LIBOBJC */\n \n static inline int\n-__gthread_once (__gthread_once_t *once, void (*func) (void))\n+__gthread_once (__gthread_once_t *__once, void (*__func) (void))\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(pthread_once) (once, func);\n+    return __gthrw_(pthread_once) (__once, __func);\n   else\n     return -1;\n }\n \n static inline int\n-__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))\n {\n-  return __gthrw_(pthread_key_create) (key, dtor);\n+  return __gthrw_(pthread_key_create) (__key, __dtor);\n }\n \n static inline int\n-__gthread_key_delete (__gthread_key_t key)\n+__gthread_key_delete (__gthread_key_t __key)\n {\n-  return __gthrw_(pthread_key_delete) (key);\n+  return __gthrw_(pthread_key_delete) (__key);\n }\n \n static inline void *\n-__gthread_getspecific (__gthread_key_t key)\n+__gthread_getspecific (__gthread_key_t __key)\n {\n-  return __gthrw_(pthread_getspecific) (key);\n+  return __gthrw_(pthread_getspecific) (__key);\n }\n \n static inline int\n-__gthread_setspecific (__gthread_key_t key, const void *ptr)\n+__gthread_setspecific (__gthread_key_t __key, const void *__ptr)\n {\n-  return __gthrw_(pthread_setspecific) (key, ptr);\n+  return __gthrw_(pthread_setspecific) (__key, __ptr);\n }\n \n static inline int\n-__gthread_mutex_destroy (__gthread_mutex_t *mutex)\n+__gthread_mutex_destroy (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_destroy) (mutex);\n+    return __gthrw_(pthread_mutex_destroy) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+__gthread_mutex_lock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_lock) (mutex);\n+    return __gthrw_(pthread_mutex_lock) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_trylock) (mutex);\n+    return __gthrw_(pthread_mutex_trylock) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+__gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_unlock) (mutex);\n+    return __gthrw_(pthread_mutex_unlock) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)\n {\n-  mutex->depth = 0;\n-  mutex->owner = (pthread_t) 0;\n-  return __gthrw_(pthread_mutex_init) (&mutex->actual, NULL);\n+  __mutex->depth = 0;\n+  __mutex->owner = (pthread_t) 0;\n+  return __gthrw_(pthread_mutex_init) (&__mutex->actual, NULL);\n }\n \n static inline int\n-__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      pthread_t me = __gthrw_(pthread_self) ();\n+      pthread_t __me = __gthrw_(pthread_self) ();\n \n-      if (mutex->owner != me)\n+      if (__mutex->owner != __me)\n \t{\n-\t  __gthrw_(pthread_mutex_lock) (&mutex->actual);\n-\t  mutex->owner = me;\n+\t  __gthrw_(pthread_mutex_lock) (&__mutex->actual);\n+\t  __mutex->owner = __me;\n \t}\n \n-      mutex->depth++;\n+      __mutex->depth++;\n     }\n   return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      pthread_t me = __gthrw_(pthread_self) ();\n+      pthread_t __me = __gthrw_(pthread_self) ();\n \n-      if (mutex->owner != me)\n+      if (__mutex->owner != __me)\n \t{\n-\t  if (__gthrw_(pthread_mutex_trylock) (&mutex->actual))\n+\t  if (__gthrw_(pthread_mutex_trylock) (&__mutex->actual))\n \t    return 1;\n-\t  mutex->owner = me;\n+\t  __mutex->owner = __me;\n \t}\n \n-      mutex->depth++;\n+      __mutex->depth++;\n     }\n   return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      if (--mutex->depth == 0)\n+      if (--__mutex->depth == 0)\n \t{\n-\t   mutex->owner = (pthread_t) 0;\n-\t   __gthrw_(pthread_mutex_unlock) (&mutex->actual);\n+\t   __mutex->owner = (pthread_t) 0;\n+\t   __gthrw_(pthread_mutex_unlock) (&__mutex->actual);\n \t}\n     }\n   return 0;\n }\n \n static inline int\n-__gthread_cond_broadcast (__gthread_cond_t *cond)\n+__gthread_cond_broadcast (__gthread_cond_t *__cond)\n {\n-  return __gthrw_(pthread_cond_broadcast) (cond);\n+  return __gthrw_(pthread_cond_broadcast) (__cond);\n }\n \n static inline int\n-__gthread_cond_wait (__gthread_cond_t *cond, __gthread_mutex_t *mutex)\n+__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)\n {\n-  return __gthrw_(pthread_cond_wait) (cond, mutex);\n+  return __gthrw_(pthread_cond_wait) (__cond, __mutex);\n }\n \n static inline int\n-__gthread_cond_wait_recursive (__gthread_cond_t *cond,\n-\t\t\t       __gthread_recursive_mutex_t *mutex)\n+__gthread_cond_wait_recursive (__gthread_cond_t *__cond,\n+\t\t\t       __gthread_recursive_mutex_t *__mutex)\n {\n-  return __gthrw_(pthread_cond_wait) (cond, &mutex->actual);\n+  return __gthrw_(pthread_cond_wait) (__cond, &__mutex->actual);\n }\n \n #endif /* _LIBOBJC */"}, {"sha": "d15ad5e1976f6c991c2124bca84b038da36ff017", "filename": "gcc/gthr-rtems.h", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-rtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-rtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-rtems.h?ref=09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "patch": "@@ -1,7 +1,7 @@\n /* RTEMS threads compatibility routines for libgcc2 and libobjc.\n    by: Rosimildo da Silva( rdasilva@connecttel.com ) */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 1997, 1999, 2000, 2002, 2003, 2005 \n+/* Copyright (C) 1997, 1999, 2000, 2002, 2003, 2005, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -54,24 +54,24 @@ typedef void *__gthread_recursive_mutex_t;\n  */\n \n /* generic per task variables */\n-extern int rtems_gxx_once (__gthread_once_t *once, void (*func) (void));\n-extern int rtems_gxx_key_create (__gthread_key_t *key, void (*dtor) (void *));\n-extern int rtems_gxx_key_delete (__gthread_key_t key);\n-extern void *rtems_gxx_getspecific (__gthread_key_t key);\n-extern int rtems_gxx_setspecific (__gthread_key_t key, const void *ptr);\n+extern int rtems_gxx_once (__gthread_once_t *__once, void (*__func) (void));\n+extern int rtems_gxx_key_create (__gthread_key_t *__key, void (*__dtor) (void *));\n+extern int rtems_gxx_key_delete (__gthread_key_t __key);\n+extern void *rtems_gxx_getspecific (__gthread_key_t __key);\n+extern int rtems_gxx_setspecific (__gthread_key_t __key, const void *__ptr);\n \n /* mutex support */\n-extern void rtems_gxx_mutex_init (__gthread_mutex_t *mutex);\n-extern int rtems_gxx_mutex_destroy (__gthread_mutex_t *mutex);\n-extern int rtems_gxx_mutex_lock (__gthread_mutex_t *mutex);\n-extern int rtems_gxx_mutex_trylock (__gthread_mutex_t *mutex);\n-extern int rtems_gxx_mutex_unlock (__gthread_mutex_t *mutex);\n+extern void rtems_gxx_mutex_init (__gthread_mutex_t *__mutex);\n+extern int rtems_gxx_mutex_destroy (__gthread_mutex_t *__mutex);\n+extern int rtems_gxx_mutex_lock (__gthread_mutex_t *__mutex);\n+extern int rtems_gxx_mutex_trylock (__gthread_mutex_t *__mutex);\n+extern int rtems_gxx_mutex_unlock (__gthread_mutex_t *__mutex);\n \n /* recursive mutex support */\n-extern void rtems_gxx_recursive_mutex_init (__gthread_recursive_mutex_t *mutex);\n-extern int rtems_gxx_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex);\n-extern int rtems_gxx_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex);\n-extern int rtems_gxx_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex);\n+extern void rtems_gxx_recursive_mutex_init (__gthread_recursive_mutex_t *__mutex);\n+extern int rtems_gxx_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex);\n+extern int rtems_gxx_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex);\n+extern int rtems_gxx_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex);\n \n /* RTEMS threading is always active */\n static inline int\n@@ -82,75 +82,75 @@ __gthread_active_p (void)\n \n /* Wrapper calls */\n static inline int\n-__gthread_once (__gthread_once_t *once, void (*func) (void))\n+__gthread_once (__gthread_once_t *__once, void (*__func) (void))\n {\n-   return rtems_gxx_once( once, func );\n+   return rtems_gxx_once( __once, __func );\n }\n \n static inline int\n-__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))\n {\n-  return rtems_gxx_key_create( key, dtor );\n+  return rtems_gxx_key_create( __key, __dtor );\n }\n \n static inline int\n-__gthread_key_delete (__gthread_key_t key)\n+__gthread_key_delete (__gthread_key_t __key)\n {\n-  return rtems_gxx_key_delete (key);\n+  return rtems_gxx_key_delete (__key);\n }\n \n static inline void *\n-__gthread_getspecific (__gthread_key_t key)\n+__gthread_getspecific (__gthread_key_t __key)\n {\n-  return rtems_gxx_getspecific (key);\n+  return rtems_gxx_getspecific (__key);\n }\n \n static inline int\n-__gthread_setspecific (__gthread_key_t key, const void *ptr)\n+__gthread_setspecific (__gthread_key_t __key, const void *__ptr)\n {\n-  return rtems_gxx_setspecific (key, ptr);\n+  return rtems_gxx_setspecific (__key, __ptr);\n }\n \n static inline int\n-__gthread_mutex_destroy (__gthread_mutex_t *mutex)\n+__gthread_mutex_destroy (__gthread_mutex_t *__mutex)\n {\n-  return rtems_gxx_mutex_destroy (mutex);\n+  return rtems_gxx_mutex_destroy (__mutex);\n }\n \n static inline int\n-__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+__gthread_mutex_lock (__gthread_mutex_t *__mutex)\n {\n-    return rtems_gxx_mutex_lock (mutex);\n+    return rtems_gxx_mutex_lock (__mutex);\n }\n \n static inline int\n-__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n {\n-    return rtems_gxx_mutex_trylock (mutex);\n+    return rtems_gxx_mutex_trylock (__mutex);\n }\n \n static inline int\n-__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+__gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n {\n-    return rtems_gxx_mutex_unlock( mutex );\n+    return rtems_gxx_mutex_unlock( __mutex );\n }\n \n static inline int\n-__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n {\n-    return rtems_gxx_recursive_mutex_lock (mutex);\n+    return rtems_gxx_recursive_mutex_lock (__mutex);\n }\n \n static inline int\n-__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n {\n-    return rtems_gxx_recursive_mutex_trylock (mutex);\n+    return rtems_gxx_recursive_mutex_trylock (__mutex);\n }\n \n static inline int\n-__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n {\n-    return rtems_gxx_recursive_mutex_unlock( mutex );\n+    return rtems_gxx_recursive_mutex_unlock( __mutex );\n }\n \n #ifdef __cplusplus"}, {"sha": "56dd8bc89f9448c49dfa448d662b470c48880bc9", "filename": "gcc/gthr-single.h", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-single.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-single.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-single.h?ref=09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "patch": "@@ -1,6 +1,7 @@\n /* Threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 1997, 1999, 2000, 2004, 2008 Free Software Foundation, Inc.\n+/* Copyright (C) 1997, 1999, 2000, 2004, 2008, 2009\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -216,75 +217,75 @@ __gthread_active_p (void)\n }\n \n static inline int \n-__gthread_once (__gthread_once_t *once UNUSED, void (*func) (void) UNUSED)\n+__gthread_once (__gthread_once_t *__once UNUSED, void (*__func) (void) UNUSED)\n {\n   return 0;\n }\n   \n static inline int UNUSED\n-__gthread_key_create (__gthread_key_t *key UNUSED, void (*func) (void *) UNUSED)\n+__gthread_key_create (__gthread_key_t *__key UNUSED, void (*__func) (void *) UNUSED)\n {\n   return 0;\n }\n \n static int UNUSED\n-__gthread_key_delete (__gthread_key_t key UNUSED)\n+__gthread_key_delete (__gthread_key_t __key UNUSED)\n {\n   return 0;\n }\n   \n static inline void *\n-__gthread_getspecific (__gthread_key_t key UNUSED)\n+__gthread_getspecific (__gthread_key_t __key UNUSED)\n {\n   return 0;\n }\n \n static inline int \n-__gthread_setspecific (__gthread_key_t key UNUSED, const void *v UNUSED)\n+__gthread_setspecific (__gthread_key_t __key UNUSED, const void *__v UNUSED)\n {\n   return 0;\n }\n \n static inline int\n-__gthread_mutex_destroy (__gthread_mutex_t *mutex UNUSED)\n+__gthread_mutex_destroy (__gthread_mutex_t *__mutex UNUSED)\n {\n   return 0;\n }\n \n static inline int\n-__gthread_mutex_lock (__gthread_mutex_t *mutex UNUSED)\n+__gthread_mutex_lock (__gthread_mutex_t *__mutex UNUSED)\n {\n   return 0;\n }\n \n static inline int\n-__gthread_mutex_trylock (__gthread_mutex_t *mutex UNUSED)\n+__gthread_mutex_trylock (__gthread_mutex_t *__mutex UNUSED)\n {\n   return 0;\n }\n \n static inline int\n-__gthread_mutex_unlock (__gthread_mutex_t *mutex UNUSED)\n+__gthread_mutex_unlock (__gthread_mutex_t *__mutex UNUSED)\n {\n   return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n {\n-  return __gthread_mutex_lock (mutex);\n+  return __gthread_mutex_lock (__mutex);\n }\n \n static inline int\n-__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n {\n-  return __gthread_mutex_trylock (mutex);\n+  return __gthread_mutex_trylock (__mutex);\n }\n \n static inline int\n-__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n {\n-  return __gthread_mutex_unlock (mutex);\n+  return __gthread_mutex_unlock (__mutex);\n }\n \n #endif /* _LIBOBJC */"}, {"sha": "083a43346a4646d567bd3db9639623690a46f4ff", "filename": "gcc/gthr-solaris.h", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-solaris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-solaris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-solaris.h?ref=09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "patch": "@@ -1,6 +1,6 @@\n /* Threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 1997, 1999, 2000, 2004, 2005, 2006\n+/* Copyright (C) 1997, 1999, 2000, 2004, 2005, 2006, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -403,154 +403,155 @@ __gthread_objc_condition_signal (objc_condition_t condition)\n #else /* _LIBOBJC */\n \n static inline int\n-__gthread_once (__gthread_once_t *once, void (*func) (void))\n+__gthread_once (__gthread_once_t *__once, void (*__func) (void))\n {\n   if (! __gthread_active_p ())\n     return -1;\n \n-  if (once == 0 || func == 0)\n+  if (__once == 0 || __func == 0)\n     return EINVAL;\n \n-  if (once->once == 0)\n+  if (__once->once == 0)\n     {\n-      int status = __gthrw_(mutex_lock) (&once->mutex);\n-      if (status != 0)\n-\treturn status;\n-      if (once->once == 0)\n+      int __status = __gthrw_(mutex_lock) (&__once->mutex);\n+      if (__status != 0)\n+\treturn __status;\n+      if (__once->once == 0)\n \t{\n-\t  (*func) ();\n-\t  once->once++;\n+\t  (*__func) ();\n+\t  __once->once++;\n \t}\n-      __gthrw_(mutex_unlock) (&once->mutex);\n+      __gthrw_(mutex_unlock) (&__once->mutex);\n     }\n   return 0;\n }\n \n static inline int\n-__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))\n {\n   /* Solaris 2.5 contains thr_* routines no-op in libc, so test if we actually\n      got a reasonable key value, and if not, fail.  */\n-  *key = (__gthread_key_t)-1;\n-  if (__gthrw_(thr_keycreate) (key, dtor) != 0 || *key == (__gthread_key_t)-1)\n+  *__key = (__gthread_key_t)-1;\n+  if (__gthrw_(thr_keycreate) (__key, __dtor) != 0\n+      || *__key == (__gthread_key_t)-1)\n     return -1;\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_key_delete (__gthread_key_t UNUSED (key))\n+__gthread_key_delete (__gthread_key_t UNUSED (__key))\n {\n   /* Not possible.  */\n   return -1;\n }\n \n static inline void *\n-__gthread_getspecific (__gthread_key_t key)\n+__gthread_getspecific (__gthread_key_t __key)\n {\n-  void *ptr;\n-  if (__gthrw_(thr_getspecific) (key, &ptr) == 0)\n-    return ptr;\n+  void *__ptr;\n+  if (__gthrw_(thr_getspecific) (__key, &__ptr) == 0)\n+    return __ptr;\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_setspecific (__gthread_key_t key, const void *ptr)\n+__gthread_setspecific (__gthread_key_t __key, const void *__ptr)\n {\n-  return __gthrw_(thr_setspecific) (key, (void *) ptr);\n+  return __gthrw_(thr_setspecific) (__key, (void *) __ptr);\n }\n \n static inline int\n-__gthread_mutex_destroy (__gthread_mutex_t * UNUSED(mutex))\n+__gthread_mutex_destroy (__gthread_mutex_t * UNUSED(__mutex))\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(mutex_destroy) (mutex);\n+    return __gthrw_(mutex_destroy) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+__gthread_mutex_lock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(mutex_lock) (mutex);\n+    return __gthrw_(mutex_lock) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(mutex_trylock) (mutex);\n+    return __gthrw_(mutex_trylock) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+__gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_(mutex_unlock) (mutex);\n+    return __gthrw_(mutex_unlock) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)\n {\n-  mutex->depth = 0;\n-  mutex->owner = (thread_t) 0;\n-  return __gthrw_(mutex_init) (&mutex->actual, USYNC_THREAD, 0);\n+  __mutex->depth = 0;\n+  __mutex->owner = (thread_t) 0;\n+  return __gthrw_(mutex_init) (&__mutex->actual, USYNC_THREAD, 0);\n }\n \n static inline int\n-__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      thread_t me = __gthrw_(thr_self) ();\n+      thread_t __me = __gthrw_(thr_self) ();\n \n-      if (mutex->owner != me)\n+      if (__mutex->owner != __me)\n \t{\n-\t  __gthrw_(mutex_lock) (&mutex->actual);\n-\t  mutex->owner = me;\n+\t  __gthrw_(mutex_lock) (&__mutex->actual);\n+\t  __mutex->owner = __me;\n \t}\n \n-      mutex->depth++;\n+      __mutex->depth++;\n     }\n   return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      thread_t me = __gthrw_(thr_self) ();\n+      thread_t __me = __gthrw_(thr_self) ();\n \n-      if (mutex->owner != me)\n+      if (__mutex->owner != __me)\n \t{\n-\t  if (__gthrw_(mutex_trylock) (&mutex->actual))\n+\t  if (__gthrw_(mutex_trylock) (&__mutex->actual))\n \t    return 1;\n-\t  mutex->owner = me;\n+\t  __mutex->owner = __me;\n \t}\n \n-      mutex->depth++;\n+      __mutex->depth++;\n     }\n   return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      if (--mutex->depth == 0)\n+      if (--__mutex->depth == 0)\n \t{\n-\t   mutex->owner = (thread_t) 0;\n-\t   __gthrw_(mutex_unlock) (&mutex->actual);\n+\t   __mutex->owner = (thread_t) 0;\n+\t   __gthrw_(mutex_unlock) (&__mutex->actual);\n \t}\n     }\n   return 0;"}, {"sha": "c4b8f0b3805f1116c811a491d0b71111b1152c6d", "filename": "gcc/gthr-tpf.h", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-tpf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-tpf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-tpf.h?ref=09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "patch": "@@ -1,6 +1,6 @@\n /* Threads compatibility routines for libgcc2 and libobjc.\n    Compile this one with gcc.\n-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2008, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -101,129 +101,130 @@ __gthread_active_p (void)\n }\n \n static inline int\n-__gthread_once (__gthread_once_t *once, void (*func) (void))\n+__gthread_once (__gthread_once_t *__once, void (*__func) (void))\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_(pthread_once) (once, func);\n+    return __gthrw_(pthread_once) (__once, __func);\n   else\n     return -1;\n }\n \n static inline int\n-__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_(pthread_key_create) (key, dtor);\n+    return __gthrw_(pthread_key_create) (__key, __dtor);\n   else\n     return -1;\n }\n \n static inline int\n-__gthread_key_delete (__gthread_key_t key)\n+__gthread_key_delete (__gthread_key_t __key)\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_(pthread_key_delete) (key);\n+    return __gthrw_(pthread_key_delete) (__key);\n   else\n     return -1;\n }\n \n static inline void *\n-__gthread_getspecific (__gthread_key_t key)\n+__gthread_getspecific (__gthread_key_t __key)\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_(pthread_getspecific) (key);\n+    return __gthrw_(pthread_getspecific) (__key);\n   else\n     return NULL;\n }\n \n static inline int\n-__gthread_setspecific (__gthread_key_t key, const void *ptr)\n+__gthread_setspecific (__gthread_key_t __key, const void *__ptr)\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_(pthread_setspecific) (key, ptr);\n+    return __gthrw_(pthread_setspecific) (__key, __ptr);\n   else\n     return -1;\n }\n \n static inline int\n-__gthread_mutex_destroy (__gthread_mutex_t *mutex)\n+__gthread_mutex_destroy (__gthread_mutex_t *__mutex)\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_(pthread_mutex_destroy) (mutex);\n+    return __gthrw_(pthread_mutex_destroy) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+__gthread_mutex_lock (__gthread_mutex_t *__mutex)\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_(pthread_mutex_lock) (mutex);\n+    return __gthrw_(pthread_mutex_lock) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_(pthread_mutex_trylock) (mutex);\n+    return __gthrw_(pthread_mutex_trylock) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+__gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_(pthread_mutex_unlock) (mutex);\n+    return __gthrw_(pthread_mutex_unlock) (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__tpf_pthread_active ())\n-    return __gthread_mutex_lock (mutex);\n+    return __gthread_mutex_lock (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__tpf_pthread_active ())\n-    return __gthread_mutex_trylock (mutex);\n+    return __gthread_mutex_trylock (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__tpf_pthread_active ())\n-    return __gthread_mutex_unlock (mutex);\n+    return __gthread_mutex_unlock (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)\n { \n   if (__tpf_pthread_active ())\n     {\n-      pthread_mutexattr_t attr;\n-      int r;\n-\n-      r = __gthrw_(pthread_mutexattr_init) (&attr);\n-      if (!r)\n-\tr = __gthrw_(pthread_mutexattr_settype) (&attr, PTHREAD_MUTEX_RECURSIVE);\n-      if (!r)\n-\tr = __gthrw_(pthread_mutex_init) (mutex, &attr);\n-      if (!r)\n-\tr = __gthrw_(pthread_mutexattr_destroy) (&attr);\n-      return r;\n+      pthread_mutexattr_t __attr;\n+      int __r;\n+\n+      __r = __gthrw_(pthread_mutexattr_init) (&__attr);\n+      if (!__r)\n+\t__r = __gthrw_(pthread_mutexattr_settype) (&__attr,\n+\t\t\t\t\t\t   PTHREAD_MUTEX_RECURSIVE);\n+      if (!__r)\n+\t__r = __gthrw_(pthread_mutex_init) (__mutex, &__attr);\n+      if (!__r)\n+\t__r = __gthrw_(pthread_mutexattr_destroy) (&__attr);\n+      return __r;\n     }\n   return 0;\n }"}, {"sha": "e0ff957e4f4557e7085c1a72b565b38a86bc02dd", "filename": "gcc/gthr-vxworks.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-vxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-vxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-vxworks.h?ref=09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "patch": "@@ -1,6 +1,6 @@\n /* Threads compatibility routines for libgcc2 and libobjc for VxWorks.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.\n+/* Copyright (C) 1997, 1999, 2000, 2008, 2009 Free Software Foundation, Inc.\n    Contributed by Mike Stump <mrs@wrs.com>.\n \n This file is part of GCC.\n@@ -131,7 +131,7 @@ __gthread_once_t;\n # define __GTHREAD_ONCE_INIT { 0 }\n #endif\n \n-extern int __gthread_once (__gthread_once_t *once, void (*func)(void));\n+extern int __gthread_once (__gthread_once_t *__once, void (*__func)(void));\n \n /* Thread-specific data requires a great deal of effort, since VxWorks\n    is not really set up for it.  See config/vxlib.c for the gory\n@@ -140,11 +140,11 @@ extern int __gthread_once (__gthread_once_t *once, void (*func)(void));\n \n typedef unsigned int __gthread_key_t;\n \n-extern int __gthread_key_create (__gthread_key_t *keyp, void (*dtor)(void *));\n-extern int __gthread_key_delete (__gthread_key_t key);\n+extern int __gthread_key_create (__gthread_key_t *__keyp, void (*__dtor)(void *));\n+extern int __gthread_key_delete (__gthread_key_t __key);\n \n-extern void *__gthread_getspecific (__gthread_key_t key);\n-extern int __gthread_setspecific (__gthread_key_t key, void *ptr);\n+extern void *__gthread_getspecific (__gthread_key_t __key);\n+extern int __gthread_setspecific (__gthread_key_t __key, void *__ptr);\n \n #undef UNUSED\n "}, {"sha": "6b97ed9ea5d78f2b3e55032d5077194716a14ab3", "filename": "gcc/gthr-win32.h", "status": "modified", "additions": 111, "deletions": 111, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-win32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e361bbde5b4f9c74e846ff49360a42d25ec2d5/gcc%2Fgthr-win32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-win32.h?ref=09e361bbde5b4f9c74e846ff49360a42d25ec2d5", "patch": "@@ -1,7 +1,7 @@\n /* Threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n \n-/* Copyright (C) 1999, 2000, 2002, 2003, 2004, 2005\n+/* Copyright (C) 1999, 2000, 2002, 2003, 2004, 2005, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by Mumit Khan <khan@xraylith.wisc.edu>.\n \n@@ -381,14 +381,14 @@ extern int __mingwthr_key_dtor (unsigned long, void (*) (void *));\n    gthread_mutex_try_lock is not referenced by libgcc or libstdc++.  */\n #ifdef __GTHREAD_I486_INLINE_LOCK_PRIMITIVES\n static inline long\n-__gthr_i486_lock_cmp_xchg(long *dest, long xchg, long comperand)\n+__gthr_i486_lock_cmp_xchg(long *__dest, long __xchg, long __comperand)\n {\n   long result;\n   __asm__ __volatile__ (\"\\n\\\n \tlock\\n\\\n \tcmpxchg{l} {%4, %1|%1, %4}\\n\"\n-\t: \"=a\" (result), \"=m\" (*dest)\n-\t: \"0\" (comperand), \"m\" (*dest), \"r\" (xchg)\n+\t: \"=a\" (result), \"=m\" (*__dest)\n+\t: \"0\" (__comperand), \"m\" (*__dest), \"r\" (__xchg)\n \t: \"cc\");\n   return result;\n }\n@@ -431,106 +431,106 @@ extern int __gthr_win32_recursive_mutex_unlock (__gthread_recursive_mutex_t *);\n extern void __gthr_win32_mutex_destroy (__gthread_mutex_t *);\n \n static inline int\n-__gthread_once (__gthread_once_t *once, void (*func) (void))\n+__gthread_once (__gthread_once_t *__once, void (*__func) (void))\n {\n   if (__gthread_active_p ())\n-    return __gthr_win32_once (once, func);\n+    return __gthr_win32_once (__once, __func);\n   else\n     return -1;\n }\n \n static inline int\n-__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))\n {\n-  return __gthr_win32_key_create (key, dtor);\n+  return __gthr_win32_key_create (__key, __dtor);\n }\n \n static inline int\n-__gthread_key_delete (__gthread_key_t key)\n+__gthread_key_delete (__gthread_key_t __key)\n {\n-  return __gthr_win32_key_delete (key);\n+  return __gthr_win32_key_delete (__key);\n }\n \n static inline void *\n-__gthread_getspecific (__gthread_key_t key)\n+__gthread_getspecific (__gthread_key_t __key)\n {\n-  return __gthr_win32_getspecific (key);\n+  return __gthr_win32_getspecific (__key);\n }\n \n static inline int\n-__gthread_setspecific (__gthread_key_t key, const void *ptr)\n+__gthread_setspecific (__gthread_key_t __key, const void *__ptr)\n {\n-  return __gthr_win32_setspecific (key, ptr);\n+  return __gthr_win32_setspecific (__key, __ptr);\n }\n \n static inline void\n-__gthread_mutex_init_function (__gthread_mutex_t *mutex)\n+__gthread_mutex_init_function (__gthread_mutex_t *__mutex)\n {\n-  __gthr_win32_mutex_init_function (mutex);\n+  __gthr_win32_mutex_init_function (__mutex);\n }\n \n static inline void\n-__gthread_mutex_destroy (__gthread_mutex_t *mutex)\n+__gthread_mutex_destroy (__gthread_mutex_t *__mutex)\n {\n-  __gthr_win32_mutex_destroy (mutex);\n+  __gthr_win32_mutex_destroy (__mutex);\n }\n \n static inline int\n-__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+__gthread_mutex_lock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthr_win32_mutex_lock (mutex);\n+    return __gthr_win32_mutex_lock (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthr_win32_mutex_trylock (mutex);\n+    return __gthr_win32_mutex_trylock (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+__gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthr_win32_mutex_unlock (mutex);\n+    return __gthr_win32_mutex_unlock (__mutex);\n   else\n     return 0;\n }\n \n static inline void\n-__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)\n {\n-   __gthr_win32_recursive_mutex_init_function (mutex);\n+   __gthr_win32_recursive_mutex_init_function (__mutex);\n }\n \n static inline int\n-__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthr_win32_recursive_mutex_lock (mutex);\n+    return __gthr_win32_recursive_mutex_lock (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthr_win32_recursive_mutex_trylock (mutex);\n+    return __gthr_win32_recursive_mutex_trylock (__mutex);\n   else\n     return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthr_win32_recursive_mutex_unlock (mutex);\n+    return __gthr_win32_recursive_mutex_unlock (__mutex);\n   else\n     return 0;\n }\n@@ -541,19 +541,19 @@ __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n #include <errno.h>\n \n static inline int\n-__gthread_once (__gthread_once_t *once, void (*func) (void))\n+__gthread_once (__gthread_once_t *__once, void (*__func) (void))\n {\n   if (! __gthread_active_p ())\n     return -1;\n-  else if (once == NULL || func == NULL)\n+  else if (__once == NULL || __func == NULL)\n     return EINVAL;\n \n-  if (! once->done)\n+  if (! __once->done)\n     {\n-      if (InterlockedIncrement (&(once->started)) == 0)\n+      if (InterlockedIncrement (&(__once->started)) == 0)\n \t{\n-\t  (*func) ();\n-\t  once->done = TRUE;\n+\t  (*__func) ();\n+\t  __once->done = TRUE;\n \t}\n       else\n \t{\n@@ -562,7 +562,7 @@ __gthread_once (__gthread_once_t *once, void (*func) (void))\n \t     does become an issue, the solution is to use an Event that\n \t     we wait on here (and set above), but that implies a place to\n \t     create the event before this routine is called.  */\n-\t  while (! once->done)\n+\t  while (! __once->done)\n \t    Sleep (0);\n \t}\n     }\n@@ -574,187 +574,187 @@ __gthread_once (__gthread_once_t *once, void (*func) (void))\n    leaks, especially in threaded applications making extensive use of\n    C++ EH. Mingw uses a thread-support DLL to work-around this problem.  */\n static inline int\n-__gthread_key_create (__gthread_key_t *key,\n-\t\t      void (*dtor) (void *) __attribute__((unused)))\n+__gthread_key_create (__gthread_key_t *__key,\n+\t\t      void (*__dtor) (void *) __attribute__((unused)))\n {\n-  int status = 0;\n-  DWORD tls_index = TlsAlloc ();\n-  if (tls_index != 0xFFFFFFFF)\n+  int __status = 0;\n+  DWORD __tls_index = TlsAlloc ();\n+  if (__tls_index != 0xFFFFFFFF)\n     {\n-      *key = tls_index;\n+      *__key = __tls_index;\n #ifdef MINGW32_SUPPORTS_MT_EH\n       /* Mingw runtime will run the dtors in reverse order for each thread\n          when the thread exits.  */\n-      status = __mingwthr_key_dtor (*key, dtor);\n+      __status = __mingwthr_key_dtor (*__key, __dtor);\n #endif\n     }\n   else\n-    status = (int) GetLastError ();\n-  return status;\n+    __status = (int) GetLastError ();\n+  return __status;\n }\n \n static inline int\n-__gthread_key_delete (__gthread_key_t key)\n+__gthread_key_delete (__gthread_key_t __key)\n {\n-  return (TlsFree (key) != 0) ? 0 : (int) GetLastError ();\n+  return (TlsFree (__key) != 0) ? 0 : (int) GetLastError ();\n }\n \n static inline void *\n-__gthread_getspecific (__gthread_key_t key)\n+__gthread_getspecific (__gthread_key_t __key)\n {\n-  DWORD lasterror;\n-  void *ptr;\n+  DWORD __lasterror;\n+  void *__ptr;\n \n-  lasterror = GetLastError ();\n+  __lasterror = GetLastError ();\n \n-  ptr = TlsGetValue (key);\n+  __ptr = TlsGetValue (__key);\n \n-  SetLastError (lasterror);\n+  SetLastError (__lasterror);\n \n-  return ptr;\n+  return __ptr;\n }\n \n static inline int\n-__gthread_setspecific (__gthread_key_t key, const void *ptr)\n+__gthread_setspecific (__gthread_key_t __key, const void *__ptr)\n {\n-  if (TlsSetValue (key, CONST_CAST2(void *, const void *, ptr)) != 0)\n+  if (TlsSetValue (__key, CONST_CAST2(void *, const void *, __ptr)) != 0)\n     return 0;\n   else\n     return GetLastError ();\n }\n \n static inline void\n-__gthread_mutex_init_function (__gthread_mutex_t *mutex)\n+__gthread_mutex_init_function (__gthread_mutex_t *__mutex)\n {\n-  mutex->counter = -1;\n-  mutex->sema = CreateSemaphore (NULL, 0, 65535, NULL);\n+  __mutex->counter = -1;\n+  __mutex->sema = CreateSemaphore (NULL, 0, 65535, NULL);\n }\n \n static inline void\n-__gthread_mutex_destroy (__gthread_mutex_t *mutex)\n+__gthread_mutex_destroy (__gthread_mutex_t *__mutex)\n {\n-  CloseHandle ((HANDLE) mutex->sema);\n+  CloseHandle ((HANDLE) __mutex->sema);\n }\n \n static inline int\n-__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+__gthread_mutex_lock (__gthread_mutex_t *__mutex)\n {\n-  int status = 0;\n+  int __status = 0;\n \n   if (__gthread_active_p ())\n     {\n-      if (InterlockedIncrement (&mutex->counter) == 0 ||\n-\t  WaitForSingleObject (mutex->sema, INFINITE) == WAIT_OBJECT_0)\n-\tstatus = 0;\n+      if (InterlockedIncrement (&__mutex->counter) == 0 ||\n+\t  WaitForSingleObject (__mutex->sema, INFINITE) == WAIT_OBJECT_0)\n+\t__status = 0;\n       else\n \t{\n \t  /* WaitForSingleObject returns WAIT_FAILED, and we can only do\n \t     some best-effort cleanup here.  */\n-\t  InterlockedDecrement (&mutex->counter);\n-\t  status = 1;\n+\t  InterlockedDecrement (&__mutex->counter);\n+\t  __status = 1;\n \t}\n     }\n-  return status;\n+  return __status;\n }\n \n static inline int\n-__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n {\n-  int status = 0;\n+  int __status = 0;\n \n   if (__gthread_active_p ())\n     {\n-      if (__GTHR_W32_InterlockedCompareExchange (&mutex->counter, 0, -1) < 0)\n-\tstatus = 0;\n+      if (__GTHR_W32_InterlockedCompareExchange (&__mutex->counter, 0, -1) < 0)\n+\t__status = 0;\n       else\n-\tstatus = 1;\n+\t__status = 1;\n     }\n-  return status;\n+  return __status;\n }\n \n static inline int\n-__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+__gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      if (InterlockedDecrement (&mutex->counter) >= 0)\n-\treturn ReleaseSemaphore (mutex->sema, 1, NULL) ? 0 : 1;\n+      if (InterlockedDecrement (&__mutex->counter) >= 0)\n+\treturn ReleaseSemaphore (__mutex->sema, 1, NULL) ? 0 : 1;\n     }\n   return 0;\n }\n \n static inline void\n-__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)\n {\n-  mutex->counter = -1;\n-  mutex->depth = 0;\n-  mutex->owner = 0;\n-  mutex->sema = CreateSemaphore (NULL, 0, 65535, NULL);\n+  __mutex->counter = -1;\n+  __mutex->depth = 0;\n+  __mutex->owner = 0;\n+  __mutex->sema = CreateSemaphore (NULL, 0, 65535, NULL);\n }\n \n static inline int\n-__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      DWORD me = GetCurrentThreadId();\n-      if (InterlockedIncrement (&mutex->counter) == 0)\n+      DWORD __me = GetCurrentThreadId();\n+      if (InterlockedIncrement (&__mutex->counter) == 0)\n \t{\n-\t  mutex->depth = 1;\n-\t  mutex->owner = me;\n+\t  __mutex->depth = 1;\n+\t  __mutex->owner = __me;\n \t}\n-      else if (mutex->owner == me)\n+      else if (__mutex->owner == __me)\n \t{\n-\t  InterlockedDecrement (&mutex->counter);\n-\t  ++(mutex->depth);\n+\t  InterlockedDecrement (&__mutex->counter);\n+\t  ++(__mutex->depth);\n \t}\n-      else if (WaitForSingleObject (mutex->sema, INFINITE) == WAIT_OBJECT_0)\n+      else if (WaitForSingleObject (__mutex->sema, INFINITE) == WAIT_OBJECT_0)\n \t{\n-\t  mutex->depth = 1;\n-\t  mutex->owner = me;\n+\t  __mutex->depth = 1;\n+\t  __mutex->owner = __me;\n \t}\n       else\n \t{\n \t  /* WaitForSingleObject returns WAIT_FAILED, and we can only do\n \t     some best-effort cleanup here.  */\n-\t  InterlockedDecrement (&mutex->counter);\n+\t  InterlockedDecrement (&__mutex->counter);\n \t  return 1;\n \t}\n     }\n   return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      DWORD me = GetCurrentThreadId();\n-      if (__GTHR_W32_InterlockedCompareExchange (&mutex->counter, 0, -1) < 0)\n+      DWORD __me = GetCurrentThreadId();\n+      if (__GTHR_W32_InterlockedCompareExchange (&__mutex->counter, 0, -1) < 0)\n \t{\n-\t  mutex->depth = 1;\n-\t  mutex->owner = me;\n+\t  __mutex->depth = 1;\n+\t  __mutex->owner = __me;\n \t}\n-      else if (mutex->owner == me)\n-\t++(mutex->depth);\n+      else if (__mutex->owner == __me)\n+\t++(__mutex->depth);\n       else\n \treturn 1;\n     }\n   return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      --(mutex->depth);\n-      if (mutex->depth == 0)\n+      --(__mutex->depth);\n+      if (__mutex->depth == 0)\n \t{\n-\t  mutex->owner = 0;\n+\t  __mutex->owner = 0;\n \n-\t  if (InterlockedDecrement (&mutex->counter) >= 0)\n-\t    return ReleaseSemaphore (mutex->sema, 1, NULL) ? 0 : 1;\n+\t  if (InterlockedDecrement (&__mutex->counter) >= 0)\n+\t    return ReleaseSemaphore (__mutex->sema, 1, NULL) ? 0 : 1;\n \t}\n     }\n   return 0;"}]}