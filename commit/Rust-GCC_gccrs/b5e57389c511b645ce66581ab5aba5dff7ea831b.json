{"sha": "b5e57389c511b645ce66581ab5aba5dff7ea831b", "node_id": "C_kwDOANBUbNoAKGI1ZTU3Mzg5YzUxMWI2NDVjZTY2NTgxYWI1YWJhNWRmZjdlYTgzMWI", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2021-11-25T14:35:39Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-12-02T16:26:30Z"}, "message": "[Ada] Proof of System.Arith_32 for double arithmetic on 32bits\n\ngcc/ada/\n\n\t* libgnat/s-arit32.adb: Add ghost instances and lemmas.\n\t(Scaled_Divide32): Add ghost code to prove. Minor code\n\tmodification to return early in error when divisor is zero.\n\t* libgnat/s-arit32.ads: Add ghost instances and utilities.\n\t(Scaled_Divide32): Add contract.", "tree": {"sha": "c64180704b81efb4638ab3331f8a6fe8ff86039c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c64180704b81efb4638ab3331f8a6fe8ff86039c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5e57389c511b645ce66581ab5aba5dff7ea831b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5e57389c511b645ce66581ab5aba5dff7ea831b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5e57389c511b645ce66581ab5aba5dff7ea831b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5e57389c511b645ce66581ab5aba5dff7ea831b/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "544b30f81e53ee636aac905be63cc1ed0de88119", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/544b30f81e53ee636aac905be63cc1ed0de88119", "html_url": "https://github.com/Rust-GCC/gccrs/commit/544b30f81e53ee636aac905be63cc1ed0de88119"}], "stats": {"total": 517, "additions": 499, "deletions": 18}, "files": [{"sha": "ac6582fb61adf896d3a695e53c0d7eb28ba1a0a6", "filename": "gcc/ada/libgnat/s-arit32.adb", "status": "modified", "additions": 434, "deletions": 15, "changes": 449, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e57389c511b645ce66581ab5aba5dff7ea831b/gcc%2Fada%2Flibgnat%2Fs-arit32.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e57389c511b645ce66581ab5aba5dff7ea831b/gcc%2Fada%2Flibgnat%2Fs-arit32.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-arit32.adb?ref=b5e57389c511b645ce66581ab5aba5dff7ea831b", "patch": "@@ -29,9 +29,24 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  Preconditions, postconditions, ghost code, loop invariants and assertions\n+--  in this unit are meant for analysis only, not for run-time checking, as it\n+--  would be too costly otherwise. This is enforced by setting the assertion\n+--  policy to Ignore.\n+\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Ghost          => Ignore,\n+                         Loop_Invariant => Ignore,\n+                         Assert         => Ignore);\n+\n+with Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n+use Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n with Ada.Unchecked_Conversion;\n \n-package body System.Arith_32 is\n+package body System.Arith_32\n+  with SPARK_Mode\n+is\n \n    pragma Suppress (Overflow_Check);\n    pragma Suppress (Range_Check);\n@@ -43,27 +58,65 @@ package body System.Arith_32 is\n \n    function To_Int is new Ada.Unchecked_Conversion (Uns32, Int32);\n \n+   package Unsigned_Conversion is new Unsigned_Conversions (Int => Uns32);\n+\n+   function Big (Arg : Uns32) return Big_Integer is\n+     (Unsigned_Conversion.To_Big_Integer (Arg))\n+   with Ghost;\n+\n+   package Unsigned_Conversion_64 is new Unsigned_Conversions (Int => Uns64);\n+\n+   function Big (Arg : Uns64) return Big_Integer is\n+     (Unsigned_Conversion_64.To_Big_Integer (Arg))\n+   with Ghost;\n+\n+   pragma Warnings\n+     (Off, \"non-preelaborable call not allowed in preelaborated unit\",\n+      Reason => \"Ghost code is not compiled\");\n+   Big_0 : constant Big_Integer :=\n+     Big (Uns32'(0))\n+   with Ghost;\n+   Big_2xx32 : constant Big_Integer :=\n+     Big (Uns32'(2 ** 32 - 1)) + 1\n+   with Ghost;\n+   Big_2xx64 : constant Big_Integer :=\n+     Big (Uns64'(2 ** 64 - 1)) + 1\n+   with Ghost;\n+   pragma Warnings\n+     (On, \"non-preelaborable call not allowed in preelaborated unit\");\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n    function \"abs\" (X : Int32) return Uns32 is\n      (if X = Int32'First\n-      then 2**31\n+      then Uns32'(2**31)\n       else Uns32 (Int32'(abs X)));\n    --  Convert absolute value of X to unsigned. Note that we can't just use\n    --  the expression of the Else since it overflows for X = Int32'First.\n \n+   function Lo (A : Uns64) return Uns32 is (Uns32 (A and (2 ** 32 - 1)));\n+   --  Low order half of 64-bit value\n+\n    function Hi (A : Uns64) return Uns32 is (Uns32 (Shift_Right (A, 32)));\n    --  High order half of 64-bit value\n \n-   function To_Neg_Int (A : Uns32) return Int32;\n+   function To_Neg_Int (A : Uns32) return Int32\n+   with\n+     Annotate => (GNATprove, Terminating),\n+     Pre      => In_Int32_Range (-Big (A)),\n+     Post     => Big (To_Neg_Int'Result) = -Big (A);\n    --  Convert to negative integer equivalent. If the input is in the range\n    --  0 .. 2**31, then the corresponding nonpositive signed integer (obtained\n    --  by negating the given value) is returned, otherwise constraint error is\n    --  raised.\n \n-   function To_Pos_Int (A : Uns32) return Int32;\n+   function To_Pos_Int (A : Uns32) return Int32\n+   with\n+     Annotate => (GNATprove, Terminating),\n+     Pre      => In_Int32_Range (Big (A)),\n+     Post     => Big (To_Pos_Int'Result) = Big (A);\n    --  Convert to positive integer equivalent. If the input is in the range\n    --  0 .. 2**31 - 1, then the corresponding nonnegative signed integer is\n    --  returned, otherwise constraint error is raised.\n@@ -72,13 +125,178 @@ package body System.Arith_32 is\n    pragma No_Return (Raise_Error);\n    --  Raise constraint error with appropriate message\n \n+   ------------------\n+   -- Local Lemmas --\n+   ------------------\n+\n+   procedure Lemma_Abs_Commutation (X : Int32)\n+   with\n+     Ghost,\n+     Post => abs (Big (X)) = Big (Uns32'(abs X));\n+\n+   procedure Lemma_Abs_Div_Commutation (X, Y : Big_Integer)\n+   with\n+     Ghost,\n+     Pre  => Y /= 0,\n+     Post => abs (X / Y) = abs X / abs Y;\n+\n+   procedure Lemma_Abs_Mult_Commutation (X, Y : Big_Integer)\n+   with\n+     Ghost,\n+     Post => abs (X * Y) = abs X * abs Y;\n+\n+   procedure Lemma_Abs_Rem_Commutation (X, Y : Big_Integer)\n+   with\n+     Ghost,\n+     Pre  => Y /= 0,\n+     Post => abs (X rem Y) = (abs X) rem (abs Y);\n+\n+   procedure Lemma_Div_Commutation (X, Y : Uns64)\n+   with\n+     Ghost,\n+     Pre  => Y /= 0,\n+     Post => Big (X) / Big (Y) = Big (X / Y);\n+\n+   procedure Lemma_Div_Ge (X, Y, Z : Big_Integer)\n+   with\n+     Ghost,\n+     Pre  => Z > 0 and then X >= Y * Z,\n+     Post => X / Z >= Y;\n+\n+   procedure Lemma_Ge_Commutation (A, B : Uns32)\n+   with\n+     Ghost,\n+     Pre  => A >= B,\n+     Post => Big (A) >= Big (B);\n+\n+   procedure Lemma_Hi_Lo (Xu : Uns64; Xhi, Xlo : Uns32)\n+   with\n+     Ghost,\n+     Pre  => Xhi = Hi (Xu) and Xlo = Lo (Xu),\n+     Post => Big (Xu) = Big_2xx32 * Big (Xhi) + Big (Xlo);\n+\n+   procedure Lemma_Mult_Commutation (X, Y, Z : Uns64)\n+   with\n+     Ghost,\n+     Pre  => Big (X) * Big (Y) < Big_2xx64 and then Z = X * Y,\n+     Post => Big (X) * Big (Y) = Big (Z);\n+\n+   procedure Lemma_Mult_Non_Negative (X, Y : Big_Integer)\n+   with\n+     Ghost,\n+     Pre  => (X >= Big_0 and then Y >= Big_0)\n+       or else (X <= Big_0 and then Y <= Big_0),\n+     Post => X * Y >= Big_0;\n+\n+   procedure Lemma_Mult_Non_Positive (X, Y : Big_Integer)\n+   with\n+     Ghost,\n+     Pre  => (X <= Big_0 and then Y >= Big_0)\n+       or else (X >= Big_0 and then Y <= Big_0),\n+     Post => X * Y <= Big_0;\n+\n+   procedure Lemma_Neg_Div (X, Y : Big_Integer)\n+   with\n+     Ghost,\n+     Pre  => Y /= 0,\n+     Post => X / Y = (-X) / (-Y);\n+\n+   procedure Lemma_Neg_Rem (X, Y : Big_Integer)\n+   with\n+     Ghost,\n+     Pre  => Y /= 0,\n+     Post => X rem Y = X rem (-Y);\n+\n+   procedure Lemma_Not_In_Range_Big2xx32\n+   with\n+     Post => not In_Int32_Range (Big_2xx32)\n+       and then not In_Int32_Range (-Big_2xx32);\n+\n+   procedure Lemma_Rem_Commutation (X, Y : Uns64)\n+   with\n+     Ghost,\n+     Pre  => Y /= 0,\n+     Post => Big (X) rem Big (Y) = Big (X rem Y);\n+\n+   -----------------------------\n+   -- Local lemma null bodies --\n+   -----------------------------\n+\n+   procedure Lemma_Abs_Commutation (X : Int32) is null;\n+   procedure Lemma_Abs_Mult_Commutation (X, Y : Big_Integer) is null;\n+   procedure Lemma_Div_Commutation (X, Y : Uns64) is null;\n+   procedure Lemma_Div_Ge (X, Y, Z : Big_Integer) is null;\n+   procedure Lemma_Ge_Commutation (A, B : Uns32) is null;\n+   procedure Lemma_Mult_Commutation (X, Y, Z : Uns64) is null;\n+   procedure Lemma_Mult_Non_Negative (X, Y : Big_Integer) is null;\n+   procedure Lemma_Mult_Non_Positive (X, Y : Big_Integer) is null;\n+   procedure Lemma_Neg_Rem (X, Y : Big_Integer) is null;\n+   procedure Lemma_Not_In_Range_Big2xx32 is null;\n+   procedure Lemma_Rem_Commutation (X, Y : Uns64) is null;\n+\n+   -------------------------------\n+   -- Lemma_Abs_Div_Commutation --\n+   -------------------------------\n+\n+   procedure Lemma_Abs_Div_Commutation (X, Y : Big_Integer) is\n+   begin\n+      if Y < 0 then\n+         if X < 0 then\n+            pragma Assert (abs (X / Y) = abs (X / (-Y)));\n+         else\n+            Lemma_Neg_Div (X, Y);\n+            pragma Assert (abs (X / Y) = abs ((-X) / (-Y)));\n+         end if;\n+      end if;\n+   end Lemma_Abs_Div_Commutation;\n+\n+   -------------------------------\n+   -- Lemma_Abs_Rem_Commutation --\n+   -------------------------------\n+\n+   procedure Lemma_Abs_Rem_Commutation (X, Y : Big_Integer) is\n+   begin\n+      if Y < 0 then\n+         Lemma_Neg_Rem (X, Y);\n+         if X < 0 then\n+            pragma Assert (X rem Y = -((-X) rem (-Y)));\n+            pragma Assert (abs (X rem Y) = (abs X) rem (abs Y));\n+         else\n+            pragma Assert (abs (X rem Y) = (abs X) rem (abs Y));\n+         end if;\n+      end if;\n+   end Lemma_Abs_Rem_Commutation;\n+\n+   -----------------\n+   -- Lemma_Hi_Lo --\n+   -----------------\n+\n+   procedure Lemma_Hi_Lo (Xu : Uns64; Xhi, Xlo : Uns32) is\n+   begin\n+      pragma Assert (Uns64 (Xhi) = Xu / Uns64'(2 ** 32));\n+      pragma Assert (Uns64 (Xlo) = Xu mod 2 ** 32);\n+   end Lemma_Hi_Lo;\n+\n+   -------------------\n+   -- Lemma_Neg_Div --\n+   -------------------\n+\n+   procedure Lemma_Neg_Div (X, Y : Big_Integer) is\n+   begin\n+      pragma Assert ((-X) / (-Y) = -(X / (-Y)));\n+      pragma Assert (X / (-Y) = -(X / Y));\n+   end Lemma_Neg_Div;\n+\n    -----------------\n    -- Raise_Error --\n    -----------------\n \n    procedure Raise_Error is\n    begin\n       raise Constraint_Error with \"32-bit arithmetic overflow\";\n+      pragma Annotate\n+        (GNATprove, Intentional, \"exception might be raised\",\n+         \"Procedure Raise_Error is called to signal input errors\");\n    end Raise_Error;\n \n    -------------------\n@@ -101,51 +319,252 @@ package body System.Arith_32 is\n       Ru : Uns32;\n       --  Unsigned quotient and remainder\n \n+      --  Local ghost variables\n+\n+      Mult  : constant Big_Integer := abs (Big (X) * Big (Y)) with Ghost;\n+      Quot  : Big_Integer with Ghost;\n+      Big_R : Big_Integer with Ghost;\n+      Big_Q : Big_Integer with Ghost;\n+\n+      --  Local lemmas\n+\n+      procedure Prove_Negative_Dividend\n+      with\n+        Ghost,\n+        Pre  => Z /= 0\n+          and then ((X >= 0 and Y < 0) or (X < 0 and Y >= 0))\n+          and then Big_Q =\n+            (if Round then Round_Quotient (Big (X) * Big (Y), Big (Z),\n+                                           Big (X) * Big (Y) / Big (Z),\n+                                           Big (X) * Big (Y) rem Big (Z))\n+             else Big (X) * Big (Y) / Big (Z)),\n+         Post =>\n+           (if Z > 0 then Big_Q <= Big_0 else Big_Q >= Big_0);\n+      --  Proves the sign of rounded quotient when dividend is non-positive\n+\n+      procedure Prove_Overflow\n+      with\n+        Ghost,\n+        Pre  => Z /= 0 and then Mult >= Big_2xx32 * Big (Uns32'(abs Z)),\n+        Post => not In_Int32_Range (Big (X) * Big (Y) / Big (Z))\n+          and then not In_Int32_Range\n+            (Round_Quotient (Big (X) * Big (Y), Big (Z),\n+                             Big (X) * Big (Y) / Big (Z),\n+                             Big (X) * Big (Y) rem Big (Z)));\n+      --  Proves overflow case\n+\n+      procedure Prove_Positive_Dividend\n+      with\n+        Ghost,\n+        Pre  => Z /= 0\n+          and then ((X >= 0 and Y >= 0) or (X < 0 and Y < 0))\n+          and then Big_Q =\n+            (if Round then Round_Quotient (Big (X) * Big (Y), Big (Z),\n+                                           Big (X) * Big (Y) / Big (Z),\n+                                           Big (X) * Big (Y) rem Big (Z))\n+             else Big (X) * Big (Y) / Big (Z)),\n+         Post =>\n+           (if Z > 0 then Big_Q >= Big_0 else Big_Q <= Big_0);\n+      --  Proves the sign of rounded quotient when dividend is non-negative\n+\n+      procedure Prove_Rounding_Case\n+      with\n+        Ghost,\n+        Pre  => Z /= 0\n+          and then Quot = Big (X) * Big (Y) / Big (Z)\n+          and then Big_R = Big (X) * Big (Y) rem Big (Z)\n+          and then Big_Q =\n+            Round_Quotient (Big (X) * Big (Y), Big (Z), Quot, Big_R)\n+          and then Big (Ru) = abs Big_R\n+          and then Big (Zu) = Big (Uns32'(abs Z)),\n+        Post => abs Big_Q =\n+          (if Ru > (Zu - Uns32'(1)) / Uns32'(2)\n+           then abs Quot + 1\n+           else abs Quot);\n+      --  Proves correctness of the rounding of the unsigned quotient\n+\n+      procedure Prove_Sign_R\n+      with\n+        Ghost,\n+        Pre  => Z /= 0 and then Big_R = Big (X) * Big (Y) rem Big (Z),\n+        Post => In_Int32_Range (Big_R);\n+\n+      procedure Prove_Signs\n+      with\n+        Ghost,\n+        Pre  => Z /= 0\n+          and then Quot = Big (X) * Big (Y) / Big (Z)\n+          and then Big_R = Big (X) * Big (Y) rem Big (Z)\n+          and then Big_Q =\n+            (if Round then\n+               Round_Quotient (Big (X) * Big (Y), Big (Z), Quot, Big_R)\n+             else Quot)\n+          and then Big (Ru) = abs Big_R\n+          and then Big (Qu) = abs Big_Q\n+          and then In_Int32_Range (Big_Q)\n+          and then In_Int32_Range (Big_R)\n+          and then R =\n+            (if (X >= 0) = (Y >= 0) then To_Pos_Int (Ru) else To_Neg_Int (Ru))\n+          and then Q =\n+            (if ((X >= 0) = (Y >= 0)) = (Z >= 0) then To_Pos_Int (Qu)\n+             else To_Neg_Int (Qu)),  --  need to ensure To_Pos_Int precondition\n+        Post => Big (R) = Big_R and then Big (Q) = Big_Q;\n+      --  Proves final signs match the intended result after the unsigned\n+      --  division is done.\n+\n+      -----------------------------\n+      -- Prove_Negative_Dividend --\n+      -----------------------------\n+\n+      procedure Prove_Negative_Dividend is\n+      begin\n+         Lemma_Mult_Non_Positive (Big (X), Big (Y));\n+      end Prove_Negative_Dividend;\n+\n+      --------------------\n+      -- Prove_Overflow --\n+      --------------------\n+\n+      procedure Prove_Overflow is\n+      begin\n+         Lemma_Div_Ge (Mult, Big_2xx32, Big (Uns32'(abs Z)));\n+         Lemma_Abs_Commutation (Z);\n+         Lemma_Abs_Div_Commutation (Big (X) * Big (Y), Big (Z));\n+      end Prove_Overflow;\n+\n+      -----------------------------\n+      -- Prove_Positive_Dividend --\n+      -----------------------------\n+\n+      procedure Prove_Positive_Dividend is\n+      begin\n+         Lemma_Mult_Non_Negative (Big (X), Big (Y));\n+      end Prove_Positive_Dividend;\n+\n+      -------------------------\n+      -- Prove_Rounding_Case --\n+      -------------------------\n+\n+      procedure Prove_Rounding_Case is\n+      begin\n+         if Same_Sign (Big (X) * Big (Y), Big (Z)) then\n+            null;\n+         end if;\n+      end Prove_Rounding_Case;\n+\n+      ------------------\n+      -- Prove_Sign_R --\n+      ------------------\n+\n+      procedure Prove_Sign_R is\n+      begin\n+         pragma Assert (In_Int32_Range (Big (Z)));\n+      end Prove_Sign_R;\n+\n+      -----------------\n+      -- Prove_Signs --\n+      -----------------\n+\n+      procedure Prove_Signs is null;\n+\n+   --  Start of processing for Scaled_Divide32\n+\n    begin\n       --  First do the 64-bit multiplication\n \n       D := Uns64 (Xu) * Uns64 (Yu);\n \n+      pragma Assert (Mult = Big (D));\n+      Lemma_Hi_Lo (D, Hi (D), Lo (D));\n+      pragma Assert (Mult = Big_2xx32 * Big (Hi (D)) + Big (Lo (D)));\n+\n+      --  If divisor is zero, raise error\n+\n+      if Z = 0 then\n+         Raise_Error;\n+      end if;\n+\n+      Quot := Big (X) * Big (Y) / Big (Z);\n+      Big_R := Big (X) * Big (Y) rem Big (Z);\n+      if Round then\n+         Big_Q := Round_Quotient (Big (X) * Big (Y), Big (Z), Quot, Big_R);\n+      else\n+         Big_Q := Quot;\n+      end if;\n+\n       --  If dividend is too large, raise error\n \n       if Hi (D) >= Zu then\n+         Lemma_Ge_Commutation (Hi (D), Zu);\n+         pragma Assert (Mult >= Big_2xx32 * Big (Zu));\n+         Prove_Overflow;\n          Raise_Error;\n+      end if;\n \n       --  Then do the 64-bit division\n \n-      else\n-         Qu := Uns32 (D / Uns64 (Zu));\n-         Ru := Uns32 (D rem Uns64 (Zu));\n-      end if;\n+      Qu := Uns32 (D / Uns64 (Zu));\n+      Ru := Uns32 (D rem Uns64 (Zu));\n+\n+      Lemma_Abs_Div_Commutation (Big (X) * Big (Y), Big (Z));\n+      Lemma_Abs_Rem_Commutation (Big (X) * Big (Y), Big (Z));\n+      Lemma_Abs_Mult_Commutation (Big (X), Big (Y));\n+      Lemma_Abs_Commutation (X);\n+      Lemma_Abs_Commutation (Y);\n+      Lemma_Abs_Commutation (Z);\n+      Lemma_Mult_Commutation (Uns64 (Xu), Uns64 (Yu), D);\n+      Lemma_Div_Commutation (D, Uns64 (Zu));\n+      Lemma_Rem_Commutation (D, Uns64 (Zu));\n+\n+      pragma Assert (Big (Ru) = abs Big_R);\n+      pragma Assert (Big (Qu) = abs Quot);\n+      pragma Assert (Big (Zu) = Big (Uns32'(abs Z)));\n \n       --  Deal with rounding case\n \n-      if Round and then Ru > (Zu - Uns32'(1)) / Uns32'(2) then\n+      if Round then\n+         Prove_Rounding_Case;\n \n-         --  Protect against wrapping around when rounding, by signaling\n-         --  an overflow when the quotient is too large.\n+         if Ru > (Zu - Uns32'(1)) / Uns32'(2) then\n+            pragma Assert (abs Big_Q = Big (Qu) + 1);\n \n-         if Qu = Uns32'Last then\n-            Raise_Error;\n-         end if;\n+            --  Protect against wrapping around when rounding, by signaling\n+            --  an overflow when the quotient is too large.\n \n-         Qu := Qu + Uns32'(1);\n+            if Qu = Uns32'Last then\n+               pragma Assert (abs Big_Q = Big_2xx32);\n+               Lemma_Not_In_Range_Big2xx32;\n+               Raise_Error;\n+            end if;\n+\n+            Qu := Qu + Uns32'(1);\n+         end if;\n       end if;\n \n+      pragma Assert (Big (Qu) = abs Big_Q);\n+      pragma Assert (Big (Ru) = abs Big_R);\n+\n       --  Set final signs (RM 4.5.5(27-30))\n \n       --  Case of dividend (X * Y) sign positive\n \n       if (X >= 0 and then Y >= 0) or else (X < 0 and then Y < 0) then\n+         Prove_Positive_Dividend;\n+\n          R := To_Pos_Int (Ru);\n          Q := (if Z > 0 then To_Pos_Int (Qu) else To_Neg_Int (Qu));\n \n       --  Case of dividend (X * Y) sign negative\n \n       else\n+         Prove_Negative_Dividend;\n+\n          R := To_Neg_Int (Ru);\n          Q := (if Z > 0 then To_Neg_Int (Qu) else To_Pos_Int (Qu));\n       end if;\n+\n+      Prove_Sign_R;\n+      Prove_Signs;\n    end Scaled_Divide32;\n \n    ----------------"}, {"sha": "5163351075b50571586fcc0dd7fc7c86d41eb962", "filename": "gcc/ada/libgnat/s-arit32.ads", "status": "modified", "additions": 65, "deletions": 3, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e57389c511b645ce66581ab5aba5dff7ea831b/gcc%2Fada%2Flibgnat%2Fs-arit32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e57389c511b645ce66581ab5aba5dff7ea831b/gcc%2Fada%2Flibgnat%2Fs-arit32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-arit32.ads?ref=b5e57389c511b645ce66581ab5aba5dff7ea831b", "patch": "@@ -33,17 +33,79 @@\n --  signed integer values in cases where either overflow checking is\n --  required, or intermediate results are longer than 32 bits.\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced\n+--  by setting the corresponding assertion policy to Ignore. Postconditions\n+--  and contract cases should not be executed at runtime as well, in order\n+--  not to slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Contract_Cases => Ignore,\n+                         Ghost          => Ignore);\n+\n with Interfaces;\n+with Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n \n-package System.Arith_32 is\n-   pragma Pure;\n+package System.Arith_32\n+  with Pure, SPARK_Mode\n+is\n+   use type Ada.Numerics.Big_Numbers.Big_Integers_Ghost.Big_Integer;\n+   use type Interfaces.Integer_32;\n \n    subtype Int32 is Interfaces.Integer_32;\n \n+   subtype Big_Integer is\n+     Ada.Numerics.Big_Numbers.Big_Integers_Ghost.Big_Integer\n+   with Ghost;\n+\n+   package Signed_Conversion is new\n+     Ada.Numerics.Big_Numbers.Big_Integers_Ghost.Signed_Conversions\n+     (Int => Int32);\n+\n+   function Big (Arg : Int32) return Big_Integer is\n+     (Signed_Conversion.To_Big_Integer (Arg))\n+   with Ghost;\n+\n+   function In_Int32_Range (Arg : Big_Integer) return Boolean is\n+     (Ada.Numerics.Big_Numbers.Big_Integers_Ghost.In_Range\n+       (Arg, Big (Int32'First), Big (Int32'Last)))\n+   with Ghost;\n+\n+   function Same_Sign (X, Y : Big_Integer) return Boolean is\n+     (X = Big (Int32'(0))\n+        or else Y = Big (Int32'(0))\n+        or else (X < Big (Int32'(0))) = (Y < Big (Int32'(0))))\n+   with Ghost;\n+\n+   function Round_Quotient (X, Y, Q, R : Big_Integer) return Big_Integer is\n+     (if abs R > (abs Y - Big (Int32'(1))) / Big (Int32'(2)) then\n+       (if Same_Sign (X, Y) then Q + Big (Int32'(1))\n+        else Q - Big (Int32'(1)))\n+      else\n+        Q)\n+   with\n+     Ghost,\n+     Pre => Y /= 0 and then Q = X / Y and then R = X rem Y;\n+\n    procedure Scaled_Divide32\n      (X, Y, Z : Int32;\n       Q, R    : out Int32;\n-      Round   : Boolean);\n+      Round   : Boolean)\n+   with\n+     Pre  => Z /= 0\n+       and then In_Int32_Range\n+         (if Round then Round_Quotient (Big (X) * Big (Y), Big (Z),\n+                                        Big (X) * Big (Y) / Big (Z),\n+                                        Big (X) * Big (Y) rem Big (Z))\n+          else Big (X) * Big (Y) / Big (Z)),\n+     Post => Big (R) = Big (X) * Big (Y) rem Big (Z)\n+       and then\n+         (if Round then\n+            Big (Q) = Round_Quotient (Big (X) * Big (Y), Big (Z),\n+                                      Big (X) * Big (Y) / Big (Z), Big (R))\n+          else\n+            Big (Q) = Big (X) * Big (Y) / Big (Z));\n    --  Performs the division of (X * Y) / Z, storing the quotient in Q\n    --  and the remainder in R. Constraint_Error is raised if Z is zero,\n    --  or if the quotient does not fit in 32 bits. Round indicates if"}]}