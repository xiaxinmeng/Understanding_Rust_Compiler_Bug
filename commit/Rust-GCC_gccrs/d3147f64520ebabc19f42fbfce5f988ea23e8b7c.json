{"sha": "d3147f64520ebabc19f42fbfce5f988ea23e8b7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMxNDdmNjQ1MjBlYmFiYzE5ZjQyZmJmY2U1Zjk4OGVhMjNlOGI3Yw==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@redhat.com", "date": "2004-09-23T06:16:09Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-09-23T06:16:09Z"}, "message": "builtins.c (simplify_builtin_va_start): Remove.\n\n2004-09-22  Eric Christopher  <echristo@redhat.com>\n\n        * builtins.c (simplify_builtin_va_start): Remove.\n        (simplify_builtin): Ditto.\n        (fold_builtin_strchr): Ditto.\n        (simplify_builtin_*): Rename remainders to fold_builtin_*.\n        (expand_builtin): Fix up for above changes.\n        (fold_builtin_1): Add new folders. Change for above.\n        (expand_builtin_va_start): Call fold_builtin_next_arg.\n        * gimplify.c (gimplify_call_expr): Fix calls to simplify_builtin.\n        * tree.h: Remove prototype for simplify_builtin.\n\nFrom-SVN: r87921", "tree": {"sha": "fc46a731e280a8be2a02927b73a51abce29db748", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc46a731e280a8be2a02927b73a51abce29db748"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3147f64520ebabc19f42fbfce5f988ea23e8b7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3147f64520ebabc19f42fbfce5f988ea23e8b7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3147f64520ebabc19f42fbfce5f988ea23e8b7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3147f64520ebabc19f42fbfce5f988ea23e8b7c/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1381bf1ac4198588486c541537555b33ffa2e3ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1381bf1ac4198588486c541537555b33ffa2e3ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1381bf1ac4198588486c541537555b33ffa2e3ad"}], "stats": {"total": 374, "additions": 131, "deletions": 243}, "files": [{"sha": "017c8e65140fff235098d5312d649bb854af4e24", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3147f64520ebabc19f42fbfce5f988ea23e8b7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3147f64520ebabc19f42fbfce5f988ea23e8b7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d3147f64520ebabc19f42fbfce5f988ea23e8b7c", "patch": "@@ -1,3 +1,15 @@\n+2004-09-22  Eric Christopher  <echristo@redhat.com>\n+\n+\t* builtins.c (simplify_builtin_va_start): Remove.\n+\t(simplify_builtin): Ditto.\n+\t(fold_builtin_strchr): Ditto.\n+\t(simplify_builtin_*): Rename remainders to fold_builtin_*.\n+\t(expand_builtin): Fix up for above changes.\n+\t(fold_builtin_1): Add new folders. Change for above.\n+\t(expand_builtin_va_start): Call fold_builtin_next_arg.\n+\t* gimplify.c (gimplify_call_expr): Fix calls to simplify_builtin.\n+\t* tree.h: Remove prototype for simplify_builtin.\n+\n 2004-09-23  Jan Hubicka  <jh@suse.cz>\n \n \tPR debug/17389\n@@ -23,7 +35,7 @@\n \t(AC_ICONV, AC_LCMESSAGES, GCC_PATH_PROG): Remove.\n \t* configure.ac: Add in check for iconv.h\n \t* configure: Regenerate.\n-\t\n+\n 2004-09-22  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* aclocal.m4: Update for rename of gettext-sister.m4.\n@@ -69,7 +81,7 @@\n \n \t* config/darwin.c (darwin_make_decl_one_only)\n \tAllow coalesced symbol to appear in static archive's table of contents\n-\t\n+\n 2004-09-22  Kazu Hirata  <kazu@cs.umass.edu>\n \n \tPR tree-optimization/17512\n@@ -165,7 +177,7 @@\n \tthe initial lattice value.\n \t(substitute_and_fold): Transfer equivalences discovered into\n \tSSA_NAME_EQUIV.\n- \n+\n \t* tree.h (SSA_NAME_EQUIV): Add comments.\n \t(SET_SSA_NAME_EQUIV): Similarly.\n \n@@ -184,12 +196,12 @@\n \n \t* tree.def (VEC_COND_EXPR): New tree node.\n \t* tree-ssa-operands.c (get_expr_operands): Handle VEC_COND_EXPR.\n-\t\n+\n 2004-09-21  Stan Shebs  <shebs@apple.com>\n \n \t* config/rs6000/darwin-tramp.asm: Add __ppc64__ case.\n \t* config/rs6000/darwin-world.asm: Likewise.\n-\t\n+\n 2004-09-21  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-ssa.c (verify_def): Use print_generic_stmt,"}, {"sha": "89549c6b5a91fa5bb0f0c8a46a26a0c3489f7b63", "filename": "gcc/builtins.c", "status": "modified", "additions": 90, "deletions": 213, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3147f64520ebabc19f42fbfce5f988ea23e8b7c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3147f64520ebabc19f42fbfce5f988ea23e8b7c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=d3147f64520ebabc19f42fbfce5f988ea23e8b7c", "patch": "@@ -164,7 +164,7 @@ static tree fold_builtin_bitop (tree);\n static tree fold_builtin_memcpy (tree);\n static tree fold_builtin_mempcpy (tree);\n static tree fold_builtin_memmove (tree);\n-static tree fold_builtin_strchr (tree, bool);\n+static tree fold_builtin_strchr (tree);\n static tree fold_builtin_memcmp (tree);\n static tree fold_builtin_strcmp (tree);\n static tree fold_builtin_strncmp (tree);\n@@ -178,17 +178,15 @@ static tree fold_builtin_abs (tree, tree);\n static tree fold_builtin_unordered_cmp (tree, enum tree_code, enum tree_code);\n static tree fold_builtin_1 (tree, bool);\n \n-static tree simplify_builtin_strpbrk (tree);\n-static tree simplify_builtin_strstr (tree);\n-static tree simplify_builtin_strchr (tree);\n-static tree simplify_builtin_strrchr (tree);\n-static tree simplify_builtin_strcat (tree);\n-static tree simplify_builtin_strncat (tree);\n-static tree simplify_builtin_strspn (tree);\n-static tree simplify_builtin_strcspn (tree);\n-static void simplify_builtin_next_arg (tree);\n-static void simplify_builtin_va_start (tree);\n-static tree simplify_builtin_sprintf (tree, int);\n+static tree fold_builtin_strpbrk (tree);\n+static tree fold_builtin_strstr (tree);\n+static tree fold_builtin_strrchr (tree);\n+static tree fold_builtin_strcat (tree);\n+static tree fold_builtin_strncat (tree);\n+static tree fold_builtin_strspn (tree);\n+static tree fold_builtin_strcspn (tree);\n+static void fold_builtin_next_arg (tree);\n+static tree fold_builtin_sprintf (tree, int);\n \n \n /* Return the alignment in bits of EXP, a pointer valued expression.\n@@ -4286,6 +4284,8 @@ expand_builtin_va_start (tree arglist)\n   if (TREE_CHAIN (chain))\n     error (\"too many arguments to function %<va_start%>\");\n \n+  fold_builtin_next_arg (chain);\n+\n   nextarg = expand_builtin_next_arg (chain);\n   valist = stabilize_va_list (TREE_VALUE (arglist), 1);\n \n@@ -5728,7 +5728,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \n       /* Return the address of the first anonymous stack arg.  */\n     case BUILT_IN_NEXT_ARG:\n-      simplify_builtin_next_arg (arglist);\n+      fold_builtin_next_arg (arglist);\n       return expand_builtin_next_arg (arglist);\n \n     case BUILT_IN_CLASSIFY_TYPE:\n@@ -7576,61 +7576,6 @@ fold_builtin_strncpy (tree exp, tree slen)\n \t\t       build_function_call_expr (fn, arglist));\n }\n \n-/* Fold function call to builtin strchr and strrchr.\n-   Return NULL_TREE if no simplification can be made.  */\n-\n-static tree\n-fold_builtin_strchr (tree exp, bool actually_strrchr)\n-{\n-  tree arglist = TREE_OPERAND (exp, 1);\n-  if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-    return 0;\n-  else\n-    {\n-      tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n-      const char *p1;\n-\n-      if (TREE_CODE (s2) != INTEGER_CST)\n-\treturn 0;\n-\n-      p1 = c_getstr (s1);\n-      if (p1 != NULL)\n-\t{\n-\t  char c;\n-\t  const char *r;\n-\n-\t  if (target_char_cast (s2, &c))\n-\t    return 0;\n-\n-\t  r = actually_strrchr ? strrchr (p1, c) : strchr (p1, c);\n-\n-\t  if (r == NULL)\n-\t    return build_int_cst (TREE_TYPE (s1), 0);\n-\n-\t  /* Return an offset into the constant string argument.  */\n-\t  return fold (build2 (PLUS_EXPR, TREE_TYPE (s1),\n-\t\t\t       s1, build_int_cst (TREE_TYPE (s1), r - p1)));\n-\t}\n-\n-      if (actually_strrchr)\n-\t{\n-\t  tree fn;\n-\n-\t  if (!integer_zerop (s2))\n-\t    return 0;\n-\n-\t  fn = implicit_built_in_decls[BUILT_IN_STRCHR];\n-\t  if (!fn)\n-\t    return 0;\n-\n-\t  /* Transform strrchr(s1, '\\0') to strchr(s1, '\\0').  */\n-\t  return build_function_call_expr (fn, arglist);\n-\t}\n-\n-      return 0;\n-    }\n-}\n-\n /* Fold function call to builtin memcmp.  Return\n    NULL_TREE if no simplification can be made.  */\n \n@@ -8210,8 +8155,70 @@ fold_builtin_1 (tree exp, bool ignore)\n \n   switch (DECL_FUNCTION_CODE (fndecl))\n     {\n+    case BUILT_IN_FPUTS:\n+      return fold_builtin_fputs (arglist, ignore, false, NULL_TREE);\n+\n+    case BUILT_IN_FPUTS_UNLOCKED:\n+      return fold_builtin_fputs (arglist, ignore, true, NULL_TREE);\n+\n+    case BUILT_IN_STRSTR:\n+      return fold_builtin_strstr (arglist);\n+\n+    case BUILT_IN_STRCAT:\n+      return fold_builtin_strcat (arglist);\n+\n+    case BUILT_IN_STRNCAT:\n+      return fold_builtin_strncat (arglist);\n+\n+    case BUILT_IN_STRSPN:\n+      return fold_builtin_strspn (arglist);\n+\n+    case BUILT_IN_STRCSPN:\n+      return fold_builtin_strcspn (arglist);\n+\n+    case BUILT_IN_STRCHR:\n+    case BUILT_IN_INDEX:\n+      return fold_builtin_strchr (arglist);\n+\n+    case BUILT_IN_STRRCHR:\n+    case BUILT_IN_RINDEX:\n+      return fold_builtin_strrchr (arglist);\n+\n+    case BUILT_IN_STRCPY:\n+      return fold_builtin_strcpy (exp, NULL_TREE);\n+\n+    case BUILT_IN_STRNCPY:\n+      return fold_builtin_strncpy (exp, NULL_TREE);\n+\n+    case BUILT_IN_STRCMP:\n+      return fold_builtin_strcmp (arglist);\n+\n+    case BUILT_IN_STRNCMP:\n+      return fold_builtin_strncmp (arglist);\n+\n+    case BUILT_IN_STRPBRK:\n+      return fold_builtin_strpbrk (arglist);\n+\n+    case BUILT_IN_BCMP:\n+    case BUILT_IN_MEMCMP:\n+      return fold_builtin_memcmp (arglist);\n+\n+    case BUILT_IN_SPRINTF:\n+      return fold_builtin_sprintf (arglist, ignore);\n+\n     case BUILT_IN_CONSTANT_P:\n-      return fold_builtin_constant_p (arglist);\n+      {\n+\ttree val;\n+\n+\tval = fold_builtin_constant_p (arglist);\n+\t/* Gimplification will pull the CALL_EXPR for the builtin out of\n+\t   an if condition.  When not optimizing, we'll not CSE it back.\n+\t   To avoid link error types of regressions, return false now.  */\n+\tif (!val && !optimize)\n+\t  val = integer_zero_node;\n+\n+\treturn val;\n+      }\n \n     case BUILT_IN_EXPECT:\n       return fold_builtin_expect (arglist);\n@@ -8419,29 +8426,6 @@ fold_builtin_1 (tree exp, bool ignore)\n     case BUILT_IN_MEMMOVE:\n       return fold_builtin_memmove (exp);\n \n-    case BUILT_IN_STRCPY:\n-      return fold_builtin_strcpy (exp, NULL_TREE);\n-\n-    case BUILT_IN_STRNCPY:\n-      return fold_builtin_strncpy (exp, NULL_TREE);\n-\n-    case BUILT_IN_INDEX:\n-    case BUILT_IN_STRCHR:\n-      return fold_builtin_strchr (exp, false);\n-\n-    case BUILT_IN_RINDEX:\n-    case BUILT_IN_STRRCHR:\n-      return fold_builtin_strchr (exp, true);\n-\n-    case BUILT_IN_MEMCMP:\n-      return fold_builtin_memcmp (arglist);\n-\n-    case BUILT_IN_STRCMP:\n-      return fold_builtin_strcmp (arglist);\n-\n-    case BUILT_IN_STRNCMP:\n-      return fold_builtin_strncmp (arglist);\n-\n     case BUILT_IN_SIGNBIT:\n     case BUILT_IN_SIGNBITF:\n     case BUILT_IN_SIGNBITL:\n@@ -8489,11 +8473,9 @@ fold_builtin_1 (tree exp, bool ignore)\n     case BUILT_IN_ISUNORDERED:\n       return fold_builtin_unordered_cmp (exp, UNORDERED_EXPR, NOP_EXPR);\n \n-    case BUILT_IN_FPUTS:\n-      return fold_builtin_fputs (arglist, ignore, false, NULL_TREE);\n-\n-    case BUILT_IN_FPUTS_UNLOCKED:\n-      return fold_builtin_fputs (arglist, ignore, true, NULL_TREE);\n+      /* We do the folding for va_start in the expander.  */\n+    case BUILT_IN_VA_START:\n+      break;\n \n     default:\n       break;\n@@ -8517,6 +8499,7 @@ fold_builtin (tree exp, bool ignore)\n \texp = build1 (NOP_EXPR, TREE_TYPE (exp), exp);\n       TREE_NO_WARNING (exp) = 1;\n     }\n+\n   return exp;\n }\n \n@@ -8620,101 +8603,6 @@ readonly_data_expr (tree exp)\n     return false;\n }\n \n-/* Front-end to the simplify_builtin_XXX routines.\n-\n-   EXP is a call to a builtin function.  If possible try to simplify\n-   that into a constant, expression or call to a more efficient\n-   builtin function.\n-\n-   If IGNORE is nonzero, then the result of this builtin function\n-   call is ignored.\n-\n-   If simplification is possible, return the simplified tree, otherwise\n-   return NULL_TREE.  */\n-\n-tree\n-simplify_builtin (tree exp, int ignore)\n-{\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  tree arglist = TREE_OPERAND (exp, 1);\n-  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n-  tree val;\n-\n-  switch (fcode)\n-    {\n-    case BUILT_IN_FPUTS:\n-      val = fold_builtin_fputs (arglist, ignore, false, NULL_TREE);\n-      break;\n-    case BUILT_IN_FPUTS_UNLOCKED:\n-      val = fold_builtin_fputs (arglist, ignore, true, NULL_TREE);\n-      break;\n-    case BUILT_IN_STRSTR:\n-      val = simplify_builtin_strstr (arglist);\n-      break;\n-    case BUILT_IN_STRCAT:\n-      val = simplify_builtin_strcat (arglist);\n-      break;\n-    case BUILT_IN_STRNCAT:\n-      val = simplify_builtin_strncat (arglist);\n-      break;\n-    case BUILT_IN_STRSPN:\n-      val = simplify_builtin_strspn (arglist);\n-      break;\n-    case BUILT_IN_STRCSPN:\n-      val = simplify_builtin_strcspn (arglist);\n-      break;\n-    case BUILT_IN_STRCHR:\n-    case BUILT_IN_INDEX:\n-      val = simplify_builtin_strchr (arglist);\n-      break;\n-    case BUILT_IN_STRRCHR:\n-    case BUILT_IN_RINDEX:\n-      val = simplify_builtin_strrchr (arglist);\n-      break;\n-    case BUILT_IN_STRCPY:\n-      val = fold_builtin_strcpy (exp, NULL_TREE);\n-      break;\n-    case BUILT_IN_STRNCPY:\n-      val = fold_builtin_strncpy (exp, NULL_TREE);\n-      break;\n-    case BUILT_IN_STRCMP:\n-      val = fold_builtin_strcmp (arglist);\n-      break;\n-    case BUILT_IN_STRNCMP:\n-      val = fold_builtin_strncmp (arglist);\n-      break;\n-    case BUILT_IN_STRPBRK:\n-      val = simplify_builtin_strpbrk (arglist);\n-      break;\n-    case BUILT_IN_BCMP:\n-    case BUILT_IN_MEMCMP:\n-      val = fold_builtin_memcmp (arglist);\n-      break;\n-    case BUILT_IN_VA_START:\n-      simplify_builtin_va_start (arglist);\n-      val = NULL_TREE;\n-      break;\n-    case BUILT_IN_SPRINTF:\n-      val = simplify_builtin_sprintf (arglist, ignore);\n-      break;\n-    case BUILT_IN_CONSTANT_P:\n-      val = fold_builtin_constant_p (arglist);\n-      /* Gimplification will pull the CALL_EXPR for the builtin out of\n-\t an if condition.  When not optimizing, we'll not CSE it back.\n-\t To avoid link error types of regressions, return false now.  */\n-      if (!val && !optimize)\n-\tval = integer_zero_node;\n-      break;\n-    default:\n-      val = NULL_TREE;\n-      break;\n-    }\n-\n-  if (val)\n-    val = fold_convert (TREE_TYPE (exp), val);\n-  return val;\n-}\n-\n /* Simplify a call to the strstr builtin.\n \n    Return 0 if no simplification was possible, otherwise return the\n@@ -8733,7 +8621,7 @@ simplify_builtin (tree exp, int ignore)\n    form of the builtin function call.  */\n \n static tree\n-simplify_builtin_strstr (tree arglist)\n+fold_builtin_strstr (tree arglist)\n {\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n@@ -8797,7 +8685,7 @@ simplify_builtin_strstr (tree arglist)\n    form of the builtin function call.  */\n \n static tree\n-simplify_builtin_strchr (tree arglist)\n+fold_builtin_strchr (tree arglist)\n {\n   if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n@@ -8852,7 +8740,7 @@ simplify_builtin_strchr (tree arglist)\n    form of the builtin function call.  */\n \n static tree\n-simplify_builtin_strrchr (tree arglist)\n+fold_builtin_strrchr (tree arglist)\n {\n   if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n@@ -8914,7 +8802,7 @@ simplify_builtin_strrchr (tree arglist)\n    form of the builtin function call.  */\n \n static tree\n-simplify_builtin_strpbrk (tree arglist)\n+fold_builtin_strpbrk (tree arglist)\n {\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n@@ -8980,7 +8868,7 @@ simplify_builtin_strpbrk (tree arglist)\n    form of the builtin function call.  */\n \n static tree\n-simplify_builtin_strcat (tree arglist)\n+fold_builtin_strcat (tree arglist)\n {\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n@@ -9016,7 +8904,7 @@ simplify_builtin_strcat (tree arglist)\n    form of the builtin function call.  */\n \n static tree\n-simplify_builtin_strncat (tree arglist)\n+fold_builtin_strncat (tree arglist)\n {\n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n@@ -9071,7 +8959,7 @@ simplify_builtin_strncat (tree arglist)\n    form of the builtin function call.  */\n \n static tree\n-simplify_builtin_strspn (tree arglist)\n+fold_builtin_strspn (tree arglist)\n {\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n@@ -9115,7 +9003,7 @@ simplify_builtin_strspn (tree arglist)\n    form of the builtin function call.  */\n \n static tree\n-simplify_builtin_strcspn (tree arglist)\n+fold_builtin_strcspn (tree arglist)\n {\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n@@ -9242,18 +9130,7 @@ fold_builtin_fputs (tree arglist, bool ignore, bool unlocked, tree len)\n }\n \n static void\n-simplify_builtin_va_start (tree arglist)\n-{\n-  tree chain = TREE_CHAIN (arglist);\n-\n-  if (TREE_CHAIN (chain))\n-    error (\"too many arguments to function %<va_start%>\");\n-\n-  simplify_builtin_next_arg (chain);\n-}\n-\n-static void\n-simplify_builtin_next_arg (tree arglist)\n+fold_builtin_next_arg (tree arglist)\n {\n   tree fntype = TREE_TYPE (current_function_decl);\n \n@@ -9293,7 +9170,7 @@ simplify_builtin_next_arg (tree arglist)\n    the caller does not use the returned value of the function.  */\n \n static tree\n-simplify_builtin_sprintf (tree arglist, int ignored)\n+fold_builtin_sprintf (tree arglist, int ignored)\n {\n   tree call, retval, dest, fmt;\n   const char *fmt_str = NULL;"}, {"sha": "1bf14a738a36950ec9505890cd4cc835dbc50014", "filename": "gcc/gimplify.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3147f64520ebabc19f42fbfce5f988ea23e8b7c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3147f64520ebabc19f42fbfce5f988ea23e8b7c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=d3147f64520ebabc19f42fbfce5f988ea23e8b7c", "patch": "@@ -772,7 +772,7 @@ voidify_wrapper_expr (tree wrapper, tree temp)\n \t  p = tsi_end_p (i) ? NULL : tsi_stmt_ptr (i);\n \t}\n       else\n-\t{ \n+\t{\n \t  for (; TREE_CODE (*p) == COMPOUND_EXPR; p = &TREE_OPERAND (*p, 1))\n \t    {\n \t      TREE_SIDE_EFFECTS (*p) = 1;\n@@ -925,7 +925,7 @@ gimplify_return_expr (tree stmt, tree *pre_p)\n      Recall that aggregate_value_p is FALSE for any aggregate type that is\n      returned in registers.  If we're returning values in registers, then\n      we don't want to extend the lifetime of the RESULT_DECL, particularly\n-     across another call.  In addition, for those aggregates for which \n+     across another call.  In addition, for those aggregates for which\n      hard_function_value generates a PARALLEL, we'll abort during normal\n      expansion of structure assignments; there's special code in expand_return\n      to handle this case that does not exist in expand_expr.  */\n@@ -1000,7 +1000,7 @@ gimplify_decl_expr (tree *stmt_p)\n \t  /* All occurrences of this decl in final gimplified code will be\n \t     replaced by indirection.  Setting DECL_VALUE_EXPR does two\n \t     things: First, it lets the rest of the gimplifier know what\n-\t     replacement to use.  Second, it lets the debug info know \n+\t     replacement to use.  Second, it lets the debug info know\n \t     where to find the value.  */\n \t  ptr_type = build_pointer_type (TREE_TYPE (decl));\n \t  addr = create_tmp_var (ptr_type, get_name (decl));\n@@ -1331,7 +1331,7 @@ canonicalize_component_ref (tree *expr_p)\n }\n \n /* If a NOP conversion is changing a pointer to array of foo to a pointer\n-   to foo, embed that change in the ADDR_EXPR by converting \n+   to foo, embed that change in the ADDR_EXPR by converting\n       T array[U];\n       (T *)&array\n    ==>\n@@ -1389,7 +1389,7 @@ canonicalize_addr_expr (tree *expr_p)\n \n static enum gimplify_status\n gimplify_conversion (tree *expr_p)\n-{  \n+{\n   /* If we still have a conversion at the toplevel, then strip\n      away all but the outermost conversion.  */\n   if (TREE_CODE (*expr_p) == NOP_EXPR || TREE_CODE (*expr_p) == CONVERT_EXPR)\n@@ -1454,7 +1454,7 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n   int i;\n \n   /* Create a stack of the subexpressions so later we can walk them in\n-     order from inner to outer.  \n+     order from inner to outer.\n \n      This array is very memory consuming.  Don't even think of making\n      it VARRAY_TREE.  */\n@@ -1749,7 +1749,7 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n \n   gcc_assert (TREE_CODE (*expr_p) == CALL_EXPR);\n \n-  /* For reliable diagnostics during inlining, it is necessary that \n+  /* For reliable diagnostics during inlining, it is necessary that\n      every call_expr be annotated with file and line.  */\n   if (! EXPR_HAS_LOCATION (*expr_p))\n     SET_EXPR_LOCATION (*expr_p, input_location);\n@@ -1769,7 +1769,7 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n   decl = get_callee_fndecl (*expr_p);\n   if (decl && DECL_BUILT_IN (decl))\n     {\n-      tree new = simplify_builtin (*expr_p, !want_value);\n+      tree new = fold_builtin (*expr_p, !want_value);\n \n       if (new && new != *expr_p)\n \t{\n@@ -1810,7 +1810,7 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n   /* Try this again in case gimplification exposed something.  */\n   if (ret != GS_ERROR && decl && DECL_BUILT_IN (decl))\n     {\n-      tree new = simplify_builtin (*expr_p, !want_value);\n+      tree new = fold_builtin (*expr_p, !want_value);\n \n       if (new && new != *expr_p)\n \t{\n@@ -2088,7 +2088,7 @@ gimple_boolify (tree expr)\n       /* These expressions always produce boolean results.  */\n       TREE_TYPE (expr) = boolean_type_node;\n       return expr;\n-      \n+\n     default:\n       /* Other expressions that get here must have boolean values, but\n \t might need to be converted to the appropriate mode.  */\n@@ -2358,7 +2358,7 @@ gimplify_init_ctor_preeval (tree *expr_p, tree *pre_p, tree *post_p,\n \n   /* Gimplify the constructor element to something appropriate for the rhs\n      of a MODIFY_EXPR.  Given that we know the lhs is an aggregate, we know\n-     the gimplifier will consider this a store to memory.  Doing this \n+     the gimplifier will consider this a store to memory.  Doing this\n      gimplification now means that we won't have to deal with complicated\n      language-specific trees, nor trees like SAVE_EXPR that can induce\n      exponential search behavior.  */\n@@ -2568,7 +2568,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t  }\n \n \t/* If there are \"lots\" of initialized elements, even discounting\n-\t   those that are not address constants (and thus *must* be \n+\t   those that are not address constants (and thus *must* be\n \t   computed at runtime), then partition the constructor into\n \t   constant and non-constant parts.  Block copy the constant\n \t   parts in, then generate code for the non-constant parts.  */\n@@ -2755,7 +2755,7 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n       case COND_EXPR:\n \t/* If we're assigning to a non-register type, push the assignment\n \t   down into the branches.  This is mandatory for ADDRESSABLE types,\n-\t   since we cannot generate temporaries for such, but it saves a \n+\t   since we cannot generate temporaries for such, but it saves a\n \t   copy in other cases as well.  */\n \tif (!is_gimple_reg_type (TREE_TYPE (*from_p)))\n \t  {\n@@ -2924,10 +2924,10 @@ gimplify_boolean_expr (tree *expr_p)\n \n    PRE_P points to the list where the side effects for all the\n        expressions in the sequence will be emitted.\n-    \n+\n    WANT_VALUE is true when the result of the last COMPOUND_EXPR is used.  */\n /* ??? Should rearrange to share the pre-queue with all the indirect\n-   invocations of gimplify_expr.  Would probably save on creations \n+   invocations of gimplify_expr.  Would probably save on creations\n    of statement_list nodes.  */\n \n static enum gimplify_status\n@@ -3737,7 +3737,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \n \t      *expr_p = NULL_TREE;\n \t    }\n-\t\t  \n+\n \t  ret = GS_ALL_DONE;\n \t  break;\n \n@@ -3825,7 +3825,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \tcase WITH_SIZE_EXPR:\n \t  {\n \t    enum gimplify_status r0, r1;\n-\t    r0 = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, \n+\t    r0 = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p,\n \t\t\t\tpost_p == &internal_post ? NULL : post_p,\n \t\t\t\tgimple_test_f, fallback);\n \t    r1 = gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p, post_p,\n@@ -3837,7 +3837,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  /* ??? If this is a local variable, and it has not been seen in any\n \t     outer BIND_EXPR, then it's probably the result of a duplicate\n \t     declaration, for which we've already issued an error.  It would\n-\t     be really nice if the front end wouldn't leak these at all. \n+\t     be really nice if the front end wouldn't leak these at all.\n \t     Currently the only known culprit is C++ destructors, as seen\n \t     in g++.old-deja/g++.jason/binding.C.  */\n \t  tmp = *expr_p;\n@@ -3881,7 +3881,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t\tgoto expr_2;\n \t      ret = gimplify_variable_sized_compare (expr_p);\n \t      break;\n-\t      \n+\n \t    /* If *EXPR_P does not need to be special-cased, handle it\n \t       according to its class.  */\n \t    case tcc_unary:\n@@ -3893,21 +3893,21 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t    expr_2:\n \t      {\n \t\tenum gimplify_status r0, r1;\n-\t\t\n+\n \t\tr0 = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p,\n \t\t\t\t    post_p, is_gimple_val, fb_rvalue);\n \t\tr1 = gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p,\n \t\t\t\t    post_p, is_gimple_val, fb_rvalue);\n-\t\t\n+\n \t\tret = MIN (r0, r1);\n \t\tbreak;\n \t      }\n-\t      \n+\n \t    case tcc_declaration:\n \t    case tcc_constant:\n \t      ret = GS_ALL_DONE;\n \t      goto dont_recalculate;\n-\t      \n+\n \t    default:\n \t      gcc_assert (TREE_CODE (*expr_p) == TRUTH_AND_EXPR\n \t\t\t  || TREE_CODE (*expr_p) == TRUTH_OR_EXPR\n@@ -3919,7 +3919,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \tdont_recalculate:\n \t  break;\n \t}\n-      \n+\n       /* If we replaced *expr_p, gimplify again.  */\n       if (ret == GS_OK && (*expr_p == NULL || *expr_p == save_expr))\n \tret = GS_ALL_DONE;"}, {"sha": "db2a4fb5fc49315fed9a0a0b3dc03474b229df77", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3147f64520ebabc19f42fbfce5f988ea23e8b7c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3147f64520ebabc19f42fbfce5f988ea23e8b7c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d3147f64520ebabc19f42fbfce5f988ea23e8b7c", "patch": "@@ -3559,7 +3559,6 @@ extern enum built_in_function builtin_mathfn_code (tree);\n extern tree build_function_call_expr (tree, tree);\n extern tree mathfn_built_in (tree, enum built_in_function fn);\n extern tree strip_float_extensions (tree);\n-extern tree simplify_builtin (tree, int);\n extern tree c_strlen (tree, int);\n extern tree std_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n extern tree build_va_arg_indirect_ref (tree);"}]}