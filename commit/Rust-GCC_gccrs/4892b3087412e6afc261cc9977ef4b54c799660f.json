{"sha": "4892b3087412e6afc261cc9977ef4b54c799660f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg5MmIzMDg3NDEyZTZhZmMyNjFjYzk5NzdlZjRiNTRjNzk5NjYwZg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-08-23T18:01:01Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-08-23T18:01:01Z"}, "message": "analyzer: fix uninit false positive on overlapping bindings\n\ngcc/analyzer/ChangeLog:\n\t* store.cc (bit_range::intersects_p): New overload.\n\t(bit_range::operator-): New.\n\t(binding_cluster::maybe_get_compound_binding): Handle the partial\n\toverlap case.\n\t(selftest::test_bit_range_intersects_p): Add test coverage for\n\tnew overload of bit_range::intersects_p.\n\t* store.h (bit_range::intersects_p): New overload.\n\t(bit_range::operator-): New.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/data-model-22.c: New test.\n\t* gcc.dg/analyzer/uninit-6.c: New test.\n\t* gcc.dg/analyzer/uninit-6b.c: New test.", "tree": {"sha": "9c0804943ad79b2480c8b575b71d8bc21161e405", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c0804943ad79b2480c8b575b71d8bc21161e405"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4892b3087412e6afc261cc9977ef4b54c799660f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4892b3087412e6afc261cc9977ef4b54c799660f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4892b3087412e6afc261cc9977ef4b54c799660f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4892b3087412e6afc261cc9977ef4b54c799660f/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38757aa88735ab2e511bc428e2407a5a5e9fa0be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38757aa88735ab2e511bc428e2407a5a5e9fa0be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38757aa88735ab2e511bc428e2407a5a5e9fa0be"}], "stats": {"total": 241, "additions": 238, "deletions": 3}, "files": [{"sha": "3760858c26d387ceada1217663af7a72392a65cb", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 74, "deletions": 3, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4892b3087412e6afc261cc9977ef4b54c799660f/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4892b3087412e6afc261cc9977ef4b54c799660f/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=4892b3087412e6afc261cc9977ef4b54c799660f", "patch": "@@ -253,6 +253,35 @@ bit_range::contains_p (const bit_range &other, bit_range *out) const\n     return false;\n }\n \n+/* If OTHER intersects this, return true and write\n+   the relative range of OTHER within THIS to *OUT_THIS,\n+   and the relative range of THIS within OTHER to *OUT_OTHER.\n+   Otherwise return false.  */\n+\n+bool\n+bit_range::intersects_p (const bit_range &other,\n+\t\t\t bit_range *out_this,\n+\t\t\t bit_range *out_other) const\n+{\n+  if (get_start_bit_offset () < other.get_next_bit_offset ()\n+      && other.get_start_bit_offset () < get_next_bit_offset ())\n+    {\n+      bit_offset_t overlap_start\n+\t= MAX (get_start_bit_offset (),\n+\t       other.get_start_bit_offset ());\n+      bit_offset_t overlap_next\n+\t= MIN (get_next_bit_offset (),\n+\t       other.get_next_bit_offset ());\n+      gcc_assert (overlap_next > overlap_start);\n+      bit_range abs_overlap_bits (overlap_start, overlap_next - overlap_start);\n+      *out_this = abs_overlap_bits - get_start_bit_offset ();\n+      *out_other = abs_overlap_bits - other.get_start_bit_offset ();\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n int\n bit_range::cmp (const bit_range &br1, const bit_range &br2)\n {\n@@ -263,6 +292,14 @@ bit_range::cmp (const bit_range &br1, const bit_range &br2)\n   return wi::cmpu (br1.m_size_in_bits, br2.m_size_in_bits);\n }\n \n+/* Offset this range by OFFSET.  */\n+\n+bit_range\n+bit_range::operator- (bit_offset_t offset) const\n+{\n+  return bit_range (m_start_bit_offset - offset, m_size_in_bits);\n+}\n+\n /* If MASK is a contiguous range of set bits, write them\n    to *OUT and return true.\n    Otherwise return false.  */\n@@ -1570,9 +1607,29 @@ binding_cluster::maybe_get_compound_binding (store_manager *mgr,\n \t    }\n \t  else\n \t    {\n-\t      /* REG and the bound range partially overlap.\n-\t\t We don't handle this case yet.  */\n-\t      return NULL;\n+\t      /* REG and the bound range partially overlap.  */\n+\t      bit_range reg_subrange (0, 0);\n+\t      bit_range bound_subrange (0, 0);\n+\t      reg_range.intersects_p (bound_range,\n+\t\t\t\t      &reg_subrange, &bound_subrange);\n+\n+\t      /* Get the bits from the bound value for the bits at the\n+\t\t intersection (relative to the bound value).  */\n+\t      const svalue *overlap_sval\n+\t\t= sval->extract_bit_range (NULL_TREE,\n+\t\t\t\t\t   bound_subrange,\n+\t\t\t\t\t   mgr->get_svalue_manager ());\n+\n+\t      /* Get key for overlap, relative to the REG.  */\n+\t      const concrete_binding *overlap_concrete_key\n+\t\t= mgr->get_concrete_binding (reg_subrange);\n+\t      result_map.put (overlap_concrete_key, overlap_sval);\n+\n+\t      /* Clobber default_map, removing/trimming/spliting where\n+\t\t it overlaps with overlap_concrete_key.  */\n+\t      default_map.remove_overlapping_bindings (mgr,\n+\t\t\t\t\t\t       overlap_concrete_key,\n+\t\t\t\t\t\t       NULL);\n \t    }\n \t}\n       else\n@@ -2905,6 +2962,20 @@ test_bit_range_intersects_p ()\n \n   ASSERT_FALSE (b3_to_5.intersects_p (b6_to_7));\n   ASSERT_FALSE (b6_to_7.intersects_p (b3_to_5));\n+\n+  bit_range r1 (0,0);\n+  bit_range r2 (0,0);\n+  ASSERT_TRUE (b1_to_6.intersects_p (b0_to_7, &r1, &r2));\n+  ASSERT_EQ (r1.get_start_bit_offset (), 0);\n+  ASSERT_EQ (r1.m_size_in_bits, 6);\n+  ASSERT_EQ (r2.get_start_bit_offset (), 1);\n+  ASSERT_EQ (r2.m_size_in_bits, 6);\n+\n+  ASSERT_TRUE (b0_to_7.intersects_p (b1_to_6, &r1, &r2));\n+  ASSERT_EQ (r1.get_start_bit_offset (), 1);\n+  ASSERT_EQ (r1.m_size_in_bits, 6);\n+  ASSERT_EQ (r2.get_start_bit_offset (), 0);\n+  ASSERT_EQ (r2.m_size_in_bits, 6);\n }\n \n /* Implementation detail of ASSERT_BIT_RANGE_FROM_MASK_EQ.  */"}, {"sha": "da82bd1bdec755d80652cd510e8fbfc339864c27", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4892b3087412e6afc261cc9977ef4b54c799660f/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4892b3087412e6afc261cc9977ef4b54c799660f/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=4892b3087412e6afc261cc9977ef4b54c799660f", "patch": "@@ -269,9 +269,14 @@ struct bit_range\n     return (get_start_bit_offset () < other.get_next_bit_offset ()\n \t    && other.get_start_bit_offset () < get_next_bit_offset ());\n   }\n+  bool intersects_p (const bit_range &other,\n+\t\t     bit_range *out_this,\n+\t\t     bit_range *out_other) const;\n \n   static int cmp (const bit_range &br1, const bit_range &br2);\n \n+  bit_range operator- (bit_offset_t offset) const;\n+\n   static bool from_mask (unsigned HOST_WIDE_INT mask, bit_range *out);\n \n   bool as_byte_range (byte_range *out) const;"}, {"sha": "8429b2f4dc68de23c295e6841fa7530c294043cc", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-22.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4892b3087412e6afc261cc9977ef4b54c799660f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4892b3087412e6afc261cc9977ef4b54c799660f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-22.c?ref=4892b3087412e6afc261cc9977ef4b54c799660f", "patch": "@@ -0,0 +1,101 @@\n+#include <string.h>\n+#include \"analyzer-decls.h\"\n+\n+extern void check_init_char (char v);\n+extern void check_init_int (int v);\n+\n+void test_1 (void)\n+{\n+  union\n+  {\n+    char c[16];\n+    int  i[4];\n+  } v;\n+  memset (&v, 0, sizeof (v));\n+  v.c[5] = 42;\n+  check_init_int (v.c[0]);\n+  check_init_int (v.c[4]);\n+  check_init_int (v.c[6]);\n+  check_init_int (v.i[1]);\n+}\n+\n+void test_2 (void)\n+{\n+  /* Intersection of byte ranges within \"v\".  */\n+  union\n+  {\n+    struct {\n+      int  a;\n+      char b;\n+      char c;\n+    } __attribute__((packed)) icc;\n+    struct {\n+      char a;\n+      int  b;\n+      char c;\n+    } __attribute__((packed)) cic;\n+    struct {\n+      char a;\n+      char b;\n+      int  c;\n+    } __attribute__((packed)) cci;\n+  } v;\n+\n+  v.icc.a = 1066;\n+  v.icc.b = 42;\n+  v.icc.c = 17;\n+\n+  __analyzer_eval (v.icc.a == 1066); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (v.icc.b == 42); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (v.icc.c == 17); /* { dg-warning \"TRUE\" } */\n+  check_init_int (v.icc.a);\n+  check_init_char (v.icc.b);\n+  check_init_char (v.icc.c);\n+  \n+  check_init_char (v.cic.a);\n+  check_init_int (v.cic.b);\n+  check_init_char (v.cic.c);\n+  \n+  check_init_char (v.cci.a);\n+  check_init_char (v.cci.b);\n+  check_init_int (v.cci.c);\n+\n+  v.cic.a = 42;\n+  v.cic.b = 1066;\n+  v.cic.c = 17;\n+\n+  __analyzer_eval (v.cic.a == 42); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (v.cic.b == 1066); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (v.cic.c == 17); /* { dg-warning \"TRUE\" } */\n+  check_init_int (v.icc.a);\n+  check_init_char (v.icc.b);\n+  check_init_char (v.icc.c);\n+  \n+  check_init_char (v.cic.a);\n+  check_init_int (v.cic.b);\n+  check_init_char (v.cic.c);\n+  \n+  check_init_char (v.cci.a);\n+  check_init_char (v.cci.b);\n+  check_init_int (v.cci.c);  \n+\n+  v.cci.a = 42;\n+  v.cci.b = 17;\n+  v.cci.c = 1066;\n+\n+  __analyzer_eval (v.cci.a == 42); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (v.cci.b == 17); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (v.cci.c == 1066); /* { dg-warning \"TRUE\" } */\n+  check_init_int (v.icc.a);\n+  check_init_char (v.icc.b);\n+  check_init_char (v.icc.c);\n+  \n+  check_init_char (v.cic.a);\n+  check_init_int (v.cic.b);\n+  check_init_char (v.cic.c);\n+  \n+  check_init_char (v.cci.a);\n+  check_init_char (v.cci.b);\n+  check_init_int (v.cci.c);  \n+\n+}"}, {"sha": "75a99ad2c4483be1646d3fb180ea73601e18279f", "filename": "gcc/testsuite/gcc.dg/analyzer/uninit-6.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4892b3087412e6afc261cc9977ef4b54c799660f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4892b3087412e6afc261cc9977ef4b54c799660f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-6.c?ref=4892b3087412e6afc261cc9977ef4b54c799660f", "patch": "@@ -0,0 +1,29 @@\n+/* Reduced from uninit false positive seen on Linux kernel with\n+   net/ethtool/ioctl.c  */\n+\n+typedef signed char s8;\n+typedef unsigned int u32;\n+typedef __SIZE_TYPE__ size_t;\n+\n+void *memset(void *s, int c, size_t n);\n+\n+struct ethtool_link_settings {\n+  u32 cmd;\n+  s8 link_mode_masks_nwords;\n+};\n+\n+struct ethtool_link_ksettings {\n+  struct ethtool_link_settings base;\n+  u32 lanes;\n+};\n+\n+struct ethtool_link_settings\n+ethtool_get_link_ksettings(void) {\n+  struct ethtool_link_ksettings link_ksettings;\n+\n+  memset(&link_ksettings, 0, sizeof(link_ksettings));\n+  link_ksettings.base.cmd = 0x0000004c;\n+  link_ksettings.base.link_mode_masks_nwords = -3;\n+\n+  return link_ksettings.base;\n+}"}, {"sha": "32ba30fb38460abb2738041597b0629f455dbca7", "filename": "gcc/testsuite/gcc.dg/analyzer/uninit-6b.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4892b3087412e6afc261cc9977ef4b54c799660f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-6b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4892b3087412e6afc261cc9977ef4b54c799660f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-6b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-6b.c?ref=4892b3087412e6afc261cc9977ef4b54c799660f", "patch": "@@ -0,0 +1,29 @@\n+/* Reduced from uninit false positive seen on Linux kernel with\n+   net/ethtool/ioctl.c  */\n+\n+typedef signed char s8;\n+typedef unsigned int u32;\n+typedef __SIZE_TYPE__ size_t;\n+\n+void *memset(void *s, int c, size_t n);\n+\n+struct ethtool_link_settings {\n+  u32 cmd;\n+  s8 link_mode_masks_nwords;\n+};\n+\n+struct ethtool_link_ksettings {\n+  u32 lanes;\n+  struct ethtool_link_settings base;\n+};\n+\n+struct ethtool_link_settings\n+ethtool_get_link_ksettings(void) {\n+  struct ethtool_link_ksettings link_ksettings;\n+\n+  memset(&link_ksettings, 0, sizeof(link_ksettings));\n+  link_ksettings.base.cmd = 0x0000004c;\n+  link_ksettings.base.link_mode_masks_nwords = -3;\n+\n+  return link_ksettings.base;\n+}"}]}