{"sha": "56710e421f38c3cbe737f824fa3f8abe33567e2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY3MTBlNDIxZjM4YzNjYmU3MzdmODI0ZmEzZjhhYmUzMzU2N2UyZA==", "commit": {"author": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-07-24T20:41:43Z"}, "committer": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-07-24T20:41:43Z"}, "message": "(movsfcc, movdfcc, movxfcc, movsfcc_1, movdfcc_1,\n\nmovxfcc_1): New patterns for Pentium Pro floating point\nconditional move.\n\nFrom-SVN: r12559", "tree": {"sha": "f71762dbfccd98e4ebe96eaced876b83db358040", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f71762dbfccd98e4ebe96eaced876b83db358040"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56710e421f38c3cbe737f824fa3f8abe33567e2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56710e421f38c3cbe737f824fa3f8abe33567e2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56710e421f38c3cbe737f824fa3f8abe33567e2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56710e421f38c3cbe737f824fa3f8abe33567e2d/comments", "author": null, "committer": null, "parents": [{"sha": "2414e0e2839a136fb9d20114cae95dcd19746532", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2414e0e2839a136fb9d20114cae95dcd19746532", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2414e0e2839a136fb9d20114cae95dcd19746532"}], "stats": {"total": 111, "additions": 106, "deletions": 5}, "files": [{"sha": "4cc9f2468ccaaa03bfd96acbae09a16f89b96c97", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 106, "deletions": 5, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56710e421f38c3cbe737f824fa3f8abe33567e2d/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56710e421f38c3cbe737f824fa3f8abe33567e2d/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=56710e421f38c3cbe737f824fa3f8abe33567e2d", "patch": "@@ -36,8 +36,8 @@\n ;; 'L' Print the opcode suffix for a 32-bit integer opcode.\n ;; 'W' Print the opcode suffix for a 16-bit integer opcode.\n ;; 'B' Print the opcode suffix for an 8-bit integer opcode.\n-;; 'S' Print the opcode suffix for a 32-bit float opcode.\n ;; 'Q' Print the opcode suffix for a 64-bit float opcode.\n+;; 'S' Print the opcode suffix for a 32-bit float opcode.\n ;; 'T' Print the opcode suffix for an 80-bit extended real XFmode float opcode.\n ;; 'J' Print the appropriate jump operand.\n \n@@ -6783,13 +6783,13 @@\n   else if (which_alternative == 1)\n     {\n       /* r <- cond ? r : arg */\n-      output_asm_insn (AS2 (cmov%N1,%3,%0), operands);\n+      output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n     }\n   else if (which_alternative == 2)\n     {\n       /* r <- cond ? arg1 : arg2 */\n       output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n-      output_asm_insn (AS2 (cmov%N1,%3,%0), operands);\n+      output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n     }\n   else \n     {\n@@ -6823,13 +6823,13 @@\n   else if (which_alternative == 1)\n     {\n       /* r <- cond ? r : arg */\n-      output_asm_insn (AS2 (cmov%N1,%3,%0), operands);\n+      output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n     }\n   else if (which_alternative == 2)\n     {\n       /* r <- cond ? arg1 : arg2 */\n       output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n-      output_asm_insn (AS2 (cmov%N1,%3,%0), operands);\n+      output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n     }\n   else \n     {\n@@ -6843,6 +6843,107 @@\n   RET;\n }\")\n \n+(define_expand \"movsfcc\"\n+  [(match_dup 4)\n+   (set (match_operand 0 \"register_operand\" \"\")\n+\t(if_then_else:SF (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t (match_operand:SF 2 \"register_operand\" \"\")\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"\")))]\n+  \"TARGET_CMOVE\"\n+  \"\n+{\n+  operands[4] = i386_compare_gen (i386_compare_op0, i386_compare_op1);\n+}\")\n+\n+(define_expand \"movdfcc\"\n+  [(match_dup 4)\n+   (set (match_operand 0 \"register_operand\" \"\")\n+\t(if_then_else:DF (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t (match_operand:DF 2 \"register_operand\" \"\")\n+\t\t\t (match_operand:DF 3 \"register_operand\" \"\")))]\n+  \"TARGET_CMOVE\"\n+  \"\n+{\n+  operands[4] = i386_compare_gen (i386_compare_op0, i386_compare_op1);\n+}\")\n+\n+(define_expand \"movxfcc\"\n+  [(match_dup 4)\n+   (set (match_operand 0 \"register_operand\" \"\")\n+\t(if_then_else:XF (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t (match_operand:XF 2 \"register_operand\" \"\")\n+\t\t\t (match_operand:XF 3 \"register_operand\" \"\")))]\n+  \"TARGET_CMOVE\"\n+  \"\n+{\n+  operands[4] = i386_compare_gen (i386_compare_op0, i386_compare_op1);\n+}\")\n+\n+(define_insn \"movsfcc_1\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=t,t\")\n+\t(if_then_else:SF (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(cc0) (const_int 0)])\n+\t\t      (match_operand:SF 2 \"register_operand\" \"0,f\")\n+\t\t      (match_operand:SF 3 \"register_operand\" \"f,0\")))]\n+  \"TARGET_CMOVE\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      /* r <- cond ? arg : r */\n+      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n+    }\n+  else if (which_alternative == 1)\n+    {\n+      /* r <- cond ? r : arg */\n+      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n+    }\n+  RET;\n+}\")\n+\n+(define_insn \"movdfcc_1\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=t,t\")\n+\t(if_then_else:DF (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(cc0) (const_int 0)])\n+\t\t      (match_operand:DF 2 \"register_operand\" \"0,f\")\n+\t\t      (match_operand:DF 3 \"register_operand\" \"f,0\")))]\n+  \"TARGET_CMOVE\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      /* r <- cond ? arg : r */\n+      output_asm_insn (AS2 (fcmov%F1,%3,%0), operands);\n+    }\n+  else if (which_alternative == 1)\n+    {\n+      /* r <- cond ? r : arg */\n+      output_asm_insn (AS2 (fcmov%f1,%2,%0), operands);\n+    }\n+  RET;\n+}\")\n+\n+(define_insn \"movxfcc_1\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=t,t\")\n+\t(if_then_else:XF (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(cc0) (const_int 0)])\n+\t\t      (match_operand:XF 2 \"register_operand\" \"0,f\")\n+\t\t      (match_operand:XF 3 \"register_operand\" \"f,0\")))]\n+  \"TARGET_CMOVE\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      /* r <- cond ? arg : r */\n+      output_asm_insn (AS2 (fcmov%F1,%3,%0), operands);\n+    }\n+  else if (which_alternative == 1)\n+    {\n+      /* r <- cond ? r : arg */\n+      output_asm_insn (AS2 (fcmov%f1,%2,%0), operands);\n+    }\n+  RET;\n+}\")\n \n (define_insn \"strlensi_unroll\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&r,&r\")"}]}