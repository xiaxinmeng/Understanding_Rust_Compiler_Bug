{"sha": "7187798577a9a9035d1d492d1686217ff5ca30d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE4Nzc5ODU3N2E5YTkwMzVkMWQ0OTJkMTY4NjIxN2ZmNWNhMzBkNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-06-08T16:29:57Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-08T16:29:57Z"}, "message": "gimple-low.c (struct lower_data): Replace the_return_label and one_return_stmt with return_statements.\n\n        * gimple-low.c (struct lower_data): Replace the_return_label and\n        one_return_stmt with return_statements.\n        (lower_function_body): Process the entire list of return_statements.\n        (lower_return_expr): Check source value before unifying return_exprs.\n        * gimplify.c (gimplify_return_expr): Force the use of a temporary\n        for !aggregate_value_p.\n        * tree-gimple.c: Update RETURN_EXPR grammer.\n\nFrom-SVN: r82768", "tree": {"sha": "916bbf6a5966ddcddcc46c35c1346ae0899e2b22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/916bbf6a5966ddcddcc46c35c1346ae0899e2b22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7187798577a9a9035d1d492d1686217ff5ca30d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7187798577a9a9035d1d492d1686217ff5ca30d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7187798577a9a9035d1d492d1686217ff5ca30d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7187798577a9a9035d1d492d1686217ff5ca30d7/comments", "author": null, "committer": null, "parents": [{"sha": "de101ad2f75511c715a846770e3cd446e49f882c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de101ad2f75511c715a846770e3cd446e49f882c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de101ad2f75511c715a846770e3cd446e49f882c"}], "stats": {"total": 118, "additions": 94, "deletions": 24}, "files": [{"sha": "1f8964f31b68019be2ebcb08a07799ff6b94cd25", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7187798577a9a9035d1d492d1686217ff5ca30d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7187798577a9a9035d1d492d1686217ff5ca30d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7187798577a9a9035d1d492d1686217ff5ca30d7", "patch": "@@ -1,3 +1,13 @@\n+2004-06-08  Richard Henderson  <rth@redhat.com>\n+\n+        * gimple-low.c (struct lower_data): Replace the_return_label and\n+        one_return_stmt with return_statements.\n+        (lower_function_body): Process the entire list of return_statements.\n+        (lower_return_expr): Check source value before unifying return_exprs.   \n+        * gimplify.c (gimplify_return_expr): Force the use of a temporary\n+        for !aggregate_value_p.\n+        * tree-gimple.c: Update RETURN_EXPR grammer.\n+\n 2004-06-08  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR target/15598"}, {"sha": "aac3341b8ccee7d4220be47d3d7b1dbb46e46150", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7187798577a9a9035d1d492d1686217ff5ca30d7/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7187798577a9a9035d1d492d1686217ff5ca30d7/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=7187798577a9a9035d1d492d1686217ff5ca30d7", "patch": "@@ -47,9 +47,9 @@ struct lower_data\n   /* Block the current statement belongs to.  */\n   tree block;\n \n-  /* Label that unifies the return statements.  */\n-  tree the_return_label;\n-  tree one_return_stmt;\n+  /* A TREE_LIST of label and return statements to be moved to the end\n+     of the function.  */\n+  tree return_statements;\n };\n \n static void lower_stmt (tree_stmt_iterator *, struct lower_data *);\n@@ -76,8 +76,7 @@ lower_function_body (void)\n   BLOCK_CHAIN (data.block) = NULL_TREE;\n   TREE_ASM_WRITTEN (data.block) = 1;\n \n-  data.the_return_label = NULL_TREE;\n-  data.one_return_stmt = NULL_TREE;\n+  data.return_statements = NULL_TREE;\n \n   *body_p = alloc_stmt_list ();\n   i = tsi_start (*body_p);\n@@ -86,13 +85,23 @@ lower_function_body (void)\n \n   /* If we lowered any return statements, emit the representative at the\n      end of the function.  */\n-  if (data.one_return_stmt)\n+  if (data.return_statements)\n     {\n-      tree t;\n-      t = build (LABEL_EXPR, void_type_node, data.the_return_label);\n+      tree t, x;\n       i = tsi_last (*body_p);\n-      tsi_link_after (&i, t, TSI_CONTINUE_LINKING);\n-      tsi_link_after (&i, data.one_return_stmt, TSI_CONTINUE_LINKING);\n+\n+      for (t = data.return_statements; t ; t = TREE_CHAIN (t))\n+\t{\n+\t  x = build (LABEL_EXPR, void_type_node, TREE_PURPOSE (t));\n+          tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n+\n+\t  /* Remove the line number from the representative return statement.\n+\t     It now fills in for many such returns.  Failure to remove this\n+\t     will result in incorrect results for coverage analysis.  */\n+\t  x = TREE_VALUE (t);\n+\t  SET_EXPR_LOCUS (x, NULL);\n+          tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n+        }\n     }\n \n   if (data.block != DECL_INITIAL (current_function_decl))\n@@ -392,16 +401,37 @@ lower_cond_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n static void\n lower_return_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n {\n-  tree stmt, label = data->the_return_label;\n+  tree stmt = tsi_stmt (*tsi);\n+  tree value, t, label;\n+\n+  /* Extract the value being returned.  */\n+  value = TREE_OPERAND (stmt, 0);\n+  if (value && TREE_CODE (value) == MODIFY_EXPR)\n+    value = TREE_OPERAND (value, 1);\n \n-  if (!label)\n+  /* Match this up with an existing return statement that's been created.  */\n+  for (t = data->return_statements; t ; t = TREE_CHAIN (t))\n     {\n-      data->the_return_label = label = create_artificial_label ();\n-      data->one_return_stmt = tsi_stmt (*tsi);\n+      tree tvalue = TREE_OPERAND (TREE_VALUE (t), 0);\n+      if (tvalue && TREE_CODE (tvalue) == MODIFY_EXPR)\n+\ttvalue = TREE_OPERAND (tvalue, 1);\n+\n+      if (value == tvalue)\n+\t{\n+\t  label = TREE_PURPOSE (t);\n+\t  goto found;\n+\t}\n     }\n \n-  stmt = build (GOTO_EXPR, void_type_node, label);\n-  tsi_link_before (tsi, stmt, TSI_SAME_STMT);\n+  /* Not found.  Create a new label and record the return statement.  */\n+  label = create_artificial_label ();\n+  data->return_statements = tree_cons (label, stmt, data->return_statements);\n+\n+  /* Generate a goto statement and remove the return statement.  */\n+ found:\n+  t = build (GOTO_EXPR, void_type_node, label);\n+  SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n+  tsi_link_before (tsi, t, TSI_SAME_STMT);\n   tsi_delink (tsi);\n }\n \f"}, {"sha": "c6378aa4d29e4e320d07121076e16b0efb7ce521", "filename": "gcc/gimplify.c", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7187798577a9a9035d1d492d1686217ff5ca30d7/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7187798577a9a9035d1d492d1686217ff5ca30d7/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=7187798577a9a9035d1d492d1686217ff5ca30d7", "patch": "@@ -54,6 +54,7 @@ static struct gimplify_ctx\n   tree conditional_cleanups;\n   int conditions;\n   tree exit_label;\n+  tree return_temp;\n   varray_type case_labels;\n   /* The formal temporary table.  Should this be persistent?  */\n   htab_t temp_htab;\n@@ -888,7 +889,7 @@ static enum gimplify_status\n gimplify_return_expr (tree stmt, tree *pre_p)\n {\n   tree ret_expr = TREE_OPERAND (stmt, 0);\n-  tree result;\n+  tree result_decl, result;\n \n   if (!ret_expr || TREE_CODE (ret_expr) == RESULT_DECL)\n     return GS_ALL_DONE;\n@@ -897,24 +898,51 @@ gimplify_return_expr (tree stmt, tree *pre_p)\n     return GS_ERROR;\n \n   if (VOID_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl))))\n-    result = NULL_TREE;\n+    result_decl = NULL_TREE;\n   else\n     {\n-      result = TREE_OPERAND (ret_expr, 0);\n+      result_decl = TREE_OPERAND (ret_expr, 0);\n #ifdef ENABLE_CHECKING\n       if ((TREE_CODE (ret_expr) != MODIFY_EXPR\n \t   && TREE_CODE (ret_expr) != INIT_EXPR)\n-\t  || TREE_CODE (result) != RESULT_DECL)\n+\t  || TREE_CODE (result_decl) != RESULT_DECL)\n \tabort ();\n #endif\n     }\n \n-  /* We need to pass the full MODIFY_EXPR down so that special handling\n-     can replace it with something else.  */\n+  /* If aggregate_value_p is true, then we can return the bare RESULT_DECL.\n+     Recall that aggregate_value_p is FALSE for any aggregate type that is\n+     returned in registers.  If we're returning values in registers, then\n+     we don't want to extend the lifetime of the RESULT_DECL, particularly\n+     across another call.  In addition, for those aggregates for which \n+     hard_function_value generates a PARALLEL, we'll abort during normal\n+     expansion of structure assignments; there's special code in expand_return\n+     to handle this case that does not exist in expand_expr.  */\n+  if (!result_decl\n+      || aggregate_value_p (result_decl, TREE_TYPE (current_function_decl)))\n+    result = result_decl;\n+  else if (gimplify_ctxp->return_temp)\n+    result = gimplify_ctxp->return_temp;\n+  else\n+    {\n+      result = create_tmp_var (TREE_TYPE (result_decl), NULL);\n+      gimplify_ctxp->return_temp = result;\n+    }\n+\n+  /* Smash the lhs of the MODIFY_EXPR to the temporary we plan to use.\n+     Then gimplify the whole thing.  */\n+  if (result != result_decl)\n+    TREE_OPERAND (ret_expr, 0) = result;\n   gimplify_stmt (&TREE_OPERAND (stmt, 0));\n   append_to_statement_list (TREE_OPERAND (stmt, 0), pre_p);\n \n-  TREE_OPERAND (stmt, 0) = result;\n+  /* If we didn't use a temporary, then the result is just the result_decl.\n+     Otherwise we need a simple copy.  This should already be gimple.  */\n+  if (result == result_decl)\n+    ret_expr = result;\n+  else\n+    ret_expr = build (MODIFY_EXPR, TREE_TYPE (result), result_decl, result);\n+  TREE_OPERAND (stmt, 0) = ret_expr;\n \n   return GS_ALL_DONE;\n }"}, {"sha": "d3231c01fb68239f49010567c4ed1ac4e1a0ec7a", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7187798577a9a9035d1d492d1686217ff5ca30d7/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7187798577a9a9035d1d492d1686217ff5ca30d7/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=7187798577a9a9035d1d492d1686217ff5ca30d7", "patch": "@@ -79,7 +79,9 @@ Boston, MA 02111-1307, USA.  */\n        GOTO_EXPR\n          op0 -> LABEL_DECL | '*' ID\n      | RETURN_EXPR\n-         op0 -> RESULT_DECL | NULL_TREE\n+         op0 -> NULL_TREE\n+\t      | RESULT_DECL\n+\t      | MODIFY_EXPR -> RESULT_DECL, varname\n      | THROW_EXPR?  do we need/want such a thing for opts, perhaps\n          to generate an ERT_THROW region?  I think so.\n \t Hmm...this would only work at the GIMPLE level, where we know that"}]}