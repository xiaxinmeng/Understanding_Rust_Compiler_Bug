{"sha": "be477406042409e5431463f963e02b4365e94ef6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU0Nzc0MDYwNDI0MDllNTQzMTQ2M2Y5NjNlMDJiNDM2NWU5NGVmNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-03-08T03:39:19Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-03-08T03:39:19Z"}, "message": "tree-cfg.c (find_taken_edge_computed_goto): New function.\n\n        * tree-cfg.c (find_taken_edge_computed_goto): New function.\n        (find_taken_edge): Call find_taken_edge_computed_goto as\n        appropriate.  Allow any gimple invariant rather than just\n        INTEGER_CST for VAL.\n        (cleanup_control_flow): Cleanup a computed goto which has turned\n        into a simple goto.\n        (tree_merge_blocks): If block B has any forced labels, move\n        them to the start of block A.\n        * tree-ssa-dom.c (thread_across_edge): Allow threading across\n        computed gotos as well.\n        * tree-ssa-threadupdate.c (remove_ctrl_stmt_and_useless_edges): Handle\n        removal of unnecessary computed gotos too.\n        (lookup_redirection_data): Fix type of INSERT argument.  Callers\n        updated.\n\nFrom-SVN: r96084", "tree": {"sha": "c58611cf62c9432b67999f9b9ddee77792efffb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c58611cf62c9432b67999f9b9ddee77792efffb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be477406042409e5431463f963e02b4365e94ef6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be477406042409e5431463f963e02b4365e94ef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be477406042409e5431463f963e02b4365e94ef6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be477406042409e5431463f963e02b4365e94ef6/comments", "author": null, "committer": null, "parents": [{"sha": "58261bc2462eacb994befe7f3e25295b4a5e6eb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58261bc2462eacb994befe7f3e25295b4a5e6eb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58261bc2462eacb994befe7f3e25295b4a5e6eb9"}], "stats": {"total": 120, "additions": 114, "deletions": 6}, "files": [{"sha": "99505d8b56866fd0de1f8dca61bb6e21ab712dae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be477406042409e5431463f963e02b4365e94ef6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be477406042409e5431463f963e02b4365e94ef6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be477406042409e5431463f963e02b4365e94ef6", "patch": "@@ -1,3 +1,20 @@\n+2005-03-07  Jeff Law  <law@redhat.com>\n+\n+\t* tree-cfg.c (find_taken_edge_computed_goto): New function.\n+\t(find_taken_edge): Call find_taken_edge_computed_goto as\n+\tappropriate.  Allow any gimple invariant rather than just\n+\tINTEGER_CST for VAL.\n+\t(cleanup_control_flow): Cleanup a computed goto which has turned\n+\tinto a simple goto.\n+\t(tree_merge_blocks): If block B has any forced labels, move\n+\tthem to the start of block A.\n+\t* tree-ssa-dom.c (thread_across_edge): Allow threading across\n+\tcomputed gotos as well.\n+\t* tree-ssa-threadupdate.c (remove_ctrl_stmt_and_useless_edges): Handle\n+\tremoval of unnecessary computed gotos too.\n+\t(lookup_redirection_data): Fix type of INSERT argument.  Callers\n+\tupdated.\n+\n 2005-03-08  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-ssa-phiopt.c: Update copyright.  Fix indentations."}, {"sha": "7622bf77190c3afdc3154079179d58f278cf72d3", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 77, "deletions": 2, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be477406042409e5431463f963e02b4365e94ef6/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be477406042409e5431463f963e02b4365e94ef6/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=be477406042409e5431463f963e02b4365e94ef6", "patch": "@@ -129,6 +129,7 @@ static bool tree_can_merge_blocks_p (basic_block, basic_block);\n static void remove_bb (basic_block);\n static bool cleanup_control_flow (void);\n static bool cleanup_control_expr_graph (basic_block, block_stmt_iterator);\n+static edge find_taken_edge_computed_goto (basic_block, tree);\n static edge find_taken_edge_cond_expr (basic_block, tree);\n static edge find_taken_edge_switch_expr (basic_block, tree);\n static tree find_case_label_for_value (tree, tree);\n@@ -1301,7 +1302,22 @@ tree_merge_blocks (basic_block a, basic_block b)\n   for (bsi = bsi_start (b); !bsi_end_p (bsi);)\n     {\n       if (TREE_CODE (bsi_stmt (bsi)) == LABEL_EXPR)\n-\tbsi_remove (&bsi);\n+\t{\n+\t  tree label = bsi_stmt (bsi);\n+\n+\t  bsi_remove (&bsi);\n+\t  /* Now that we can thread computed gotos, we might have\n+\t     a situation where we have a forced label in block B\n+\t     However, the label at the start of block B might still be\n+\t     used in other ways (think about the runtime checking for\n+\t     Fortran assigned gotos).  So we can not just delete the\n+\t     label.  Instead we move the label to the start of block A.  */\n+\t  if (FORCED_LABEL (LABEL_EXPR_LABEL (label)))\n+\t    {\n+\t      block_stmt_iterator dest_bsi = bsi_start (a);\n+\t      bsi_insert_before (&dest_bsi, label, BSI_NEW_STMT);\n+\t    }\n+\t}\n       else\n \t{\n \t  set_bb_for_stmt (bsi_stmt (bsi), a);\n@@ -2122,6 +2138,43 @@ cleanup_control_flow (void)\n \t  || TREE_CODE (stmt) == SWITCH_EXPR)\n \tretval |= cleanup_control_expr_graph (bb, bsi);\n \n+      /* If we had a computed goto which has a compile-time determinable\n+\t destination, then we can eliminate the goto.  */\n+      if (TREE_CODE (stmt) == GOTO_EXPR\n+\t  && TREE_CODE (GOTO_DESTINATION (stmt)) == ADDR_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (GOTO_DESTINATION (stmt), 0)) == LABEL_DECL)\n+\t{\n+\t  edge e;\n+\t  tree label;\n+\t  edge_iterator ei;\n+\t  basic_block target_block;\n+\n+\t  /* First look at all the outgoing edges.  Delete any outgoing\n+\t     edges which do not go to the right block.  For the one\n+\t     edge which goes to the right block, fix up its flags.  */\n+\t  label = TREE_OPERAND (GOTO_DESTINATION (stmt), 0);\n+\t  target_block = label_to_block (label);\n+\t  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n+\t    {\n+\t      if (e->dest != target_block)\n+\t\tremove_edge (e);\n+\t      else\n+\t        {\n+\t\t  /* Turn off the EDGE_ABNORMAL flag.  */\n+\t\t  EDGE_SUCC (bb, 0)->flags &= ~EDGE_ABNORMAL;\n+\n+\t\t  /* And set EDGE_FALLTHRU.  */\n+\t\t  EDGE_SUCC (bb, 0)->flags |= EDGE_FALLTHRU;\n+\t\t  ei_next (&ei);\n+\t\t}\n+\t    }\n+\n+\t  /* Remove the GOTO_EXPR as it is not needed.  The CFG has all the\n+\t     relevant information we need.  */\n+\t  bsi_remove (&bsi);\n+\t  retval = true;\n+\t}\n+\n       /* Check for indirect calls that have been turned into\n \t noreturn calls.  */\n       if (noreturn_call_p (stmt) && remove_fallthru_edge (bb->succs))\n@@ -2229,7 +2282,7 @@ find_taken_edge (basic_block bb, tree val)\n   gcc_assert (is_ctrl_stmt (stmt));\n   gcc_assert (val);\n \n-  if (TREE_CODE (val) != INTEGER_CST)\n+  if (! is_gimple_min_invariant (val))\n     return NULL;\n \n   if (TREE_CODE (stmt) == COND_EXPR)\n@@ -2238,9 +2291,31 @@ find_taken_edge (basic_block bb, tree val)\n   if (TREE_CODE (stmt) == SWITCH_EXPR)\n     return find_taken_edge_switch_expr (bb, val);\n \n+  if (computed_goto_p (stmt))\n+    return find_taken_edge_computed_goto (bb, TREE_OPERAND( val, 0));\n+\n   gcc_unreachable ();\n }\n \n+/* Given a constant value VAL and the entry block BB to a GOTO_EXPR\n+   statement, determine which of the outgoing edges will be taken out of the\n+   block.  Return NULL if either edge may be taken.  */\n+\n+static edge\n+find_taken_edge_computed_goto (basic_block bb, tree val)\n+{\n+  basic_block dest;\n+  edge e = NULL;\n+\n+  dest = label_to_block (val);\n+  if (dest)\n+    {\n+      e = find_edge (bb, dest);\n+      gcc_assert (e != NULL);\n+    }\n+\n+  return e;\n+}\n \n /* Given a constant value VAL and the entry block BB to a COND_EXPR\n    statement, determine which of the two edges will be taken out of the"}, {"sha": "aaa0dc5f491621d2b5514fdda837fd87f983cf91", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be477406042409e5431463f963e02b4365e94ef6/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be477406042409e5431463f963e02b4365e94ef6/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=be477406042409e5431463f963e02b4365e94ef6", "patch": "@@ -715,14 +715,17 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n      arm will be taken.  */\n   if (stmt\n       && (TREE_CODE (stmt) == COND_EXPR\n-\t  || TREE_CODE (stmt) == SWITCH_EXPR))\n+\t  || TREE_CODE (stmt) == SWITCH_EXPR\n+\t  || TREE_CODE (stmt) == GOTO_EXPR))\n     {\n       tree cond, cached_lhs;\n \n       /* Now temporarily cprop the operands and try to find the resulting\n \t expression in the hash tables.  */\n       if (TREE_CODE (stmt) == COND_EXPR)\n \tcond = COND_EXPR_COND (stmt);\n+      else if (TREE_CODE (stmt) == GOTO_EXPR)\n+\tcond = GOTO_DESTINATION (stmt);\n       else\n \tcond = SWITCH_COND (stmt);\n \n@@ -1000,6 +1003,18 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n     {\n       thread_across_edge (walk_data, EDGE_SUCC (bb, 0));\n     }\n+  else if ((last = last_stmt (bb))\n+\t   && TREE_CODE (last) == GOTO_EXPR\n+\t   && TREE_CODE (TREE_OPERAND (last, 0)) == SSA_NAME)\n+    {\n+      edge_iterator ei;\n+      edge e;\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  thread_across_edge (walk_data, e);\n+\t}\n+    }\n   else if ((last = last_stmt (bb))\n \t   && TREE_CODE (last) == COND_EXPR\n \t   && (COMPARISON_CLASS_P (COND_EXPR_COND (last))"}, {"sha": "e1e0d3ea889ce2299a5dcb54e87a1a27425e864d", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be477406042409e5431463f963e02b4365e94ef6/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be477406042409e5431463f963e02b4365e94ef6/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=be477406042409e5431463f963e02b4365e94ef6", "patch": "@@ -169,6 +169,7 @@ remove_ctrl_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n   if (!bsi_end_p (bsi)\n       && bsi_stmt (bsi)\n       && (TREE_CODE (bsi_stmt (bsi)) == COND_EXPR\n+\t  || TREE_CODE (bsi_stmt (bsi)) == GOTO_EXPR\n \t  || TREE_CODE (bsi_stmt (bsi)) == SWITCH_EXPR))\n     bsi_remove (&bsi);\n \n@@ -228,7 +229,7 @@ redirection_data_eq (const void *p1, const void *p2)\n    edges associated with E in the hash table.  */\n \n static struct redirection_data *\n-lookup_redirection_data (edge e, edge incoming_edge, bool insert)\n+lookup_redirection_data (edge e, edge incoming_edge, enum insert_option insert)\n {\n   void **slot;\n   struct redirection_data *elt;\n@@ -733,7 +734,7 @@ thread_block (basic_block bb)\n \n \t  /* Insert the outgoing edge into the hash table if it is not\n \t     already in the hash table.  */\n-\t  lookup_redirection_data (e2, e, true);\n+\t  lookup_redirection_data (e2, e, INSERT);\n \t}\n     }\n \n@@ -744,7 +745,7 @@ thread_block (basic_block bb)\n   if (all)\n     {\n       edge e = EDGE_PRED (bb, 0)->aux;\n-      lookup_redirection_data (e, NULL, false)->do_not_duplicate = true;\n+      lookup_redirection_data (e, NULL, NO_INSERT)->do_not_duplicate = true;\n     }\n \n   /* Now create duplicates of BB."}]}