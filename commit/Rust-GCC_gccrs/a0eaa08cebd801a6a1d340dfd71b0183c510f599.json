{"sha": "a0eaa08cebd801a6a1d340dfd71b0183c510f599", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBlYWEwOGNlYmQ4MDFhNmExZDM0MGRmZDcxYjAxODNjNTEwZjU5OQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-05-17T12:58:46Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-05-17T12:58:46Z"}, "message": "re PR libstdc++/60966 (std::call_once sometime hangs)\n\n\tPR libstdc++/60966\n\t* include/std/future (__future_base::_State_baseV2::_M_set_result):\n\tPass lock into _M_do_set and hold it until the function returns.\n\tSignal condition variable after call_once completes.\n\t(__future_base::_State_baseV2::_M_do_set): Use lock argument. Do not\n\tsignal here.\n\t* testsuite/30_threads/promise/60966.cc: New.\n\nFrom-SVN: r210556", "tree": {"sha": "7237fcd1362424020b6b0b80fa7c6d219d31eb50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7237fcd1362424020b6b0b80fa7c6d219d31eb50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0eaa08cebd801a6a1d340dfd71b0183c510f599", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0eaa08cebd801a6a1d340dfd71b0183c510f599", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0eaa08cebd801a6a1d340dfd71b0183c510f599", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0eaa08cebd801a6a1d340dfd71b0183c510f599/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71ca302852481c082a944d5e58cd4821df5d8a6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71ca302852481c082a944d5e58cd4821df5d8a6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71ca302852481c082a944d5e58cd4821df5d8a6e"}], "stats": {"total": 104, "additions": 90, "deletions": 14}, "files": [{"sha": "8c6b15b346f1543287cdb19bd4bd5e4d7996eb7c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0eaa08cebd801a6a1d340dfd71b0183c510f599/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0eaa08cebd801a6a1d340dfd71b0183c510f599/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a0eaa08cebd801a6a1d340dfd71b0183c510f599", "patch": "@@ -1,8 +1,18 @@\n+2014-05-17  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/60966\n+\t* include/std/future (__future_base::_State_baseV2::_M_set_result):\n+\tPass lock into _M_do_set and hold it until the function returns.\n+\tSignal condition variable after call_once completes.\n+\t(__future_base::_State_baseV2::_M_do_set): Use lock argument. Do not\n+\tsignal here.\n+\t* testsuite/30_threads/promise/60966.cc: New.\n+\n 2014-05-16  Iain Sandoe  <iain@codesourcery.com>\n \t    Sandra Loosemore  <sandra@codesourcery.com>\n \n-        * testsuite/libstdc++-abi/abi.exp: Defer setting of baseline_subdir\n-        until after checking that the test is eligible to be run.\n+\t* testsuite/libstdc++-abi/abi.exp: Defer setting of baseline_subdir\n+\tuntil after checking that the test is eligible to be run.\n \n 2014-05-16  Jonathan Wakely  <jwakely@redhat.com>\n "}, {"sha": "ea11f3f03e970292bff4fa87c9e4c9367d4367bc", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0eaa08cebd801a6a1d340dfd71b0183c510f599/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0eaa08cebd801a6a1d340dfd71b0183c510f599/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=a0eaa08cebd801a6a1d340dfd71b0183c510f599", "patch": "@@ -365,12 +365,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_set_result(function<_Ptr_type()> __res, bool __ignore_failure = false)\n       {\n-        bool __set = __ignore_failure;\n+\tunique_lock<mutex> __lock(_M_mutex, defer_lock);\n         // all calls to this function are serialized,\n         // side-effects of invoking __res only happen once\n-        call_once(_M_once, &_State_baseV2::_M_do_set, this, ref(__res),\n-            ref(__set));\n-        if (!__set)\n+\tcall_once(_M_once, &_State_baseV2::_M_do_set, this,\n+\t\t  ref(__res), ref(__lock));\n+\tif (__lock.owns_lock())\n+\t  _M_cond.notify_all();\n+\telse if (!__ignore_failure)\n           __throw_future_error(int(future_errc::promise_already_satisfied));\n       }\n \n@@ -478,15 +480,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       void\n-      _M_do_set(function<_Ptr_type()>& __f, bool& __set)\n+      _M_do_set(function<_Ptr_type()>& __f, unique_lock<mutex>& __lock)\n       {\n-        _Ptr_type __res = __f();\n-        {\n-          lock_guard<mutex> __lock(_M_mutex);\n-          _M_result.swap(__res);\n-        }\n-        _M_cond.notify_all();\n-        __set = true;\n+        _Ptr_type __res = __f(); // do not hold lock while running setter\n+\t__lock.lock();\n+        _M_result.swap(__res);\n       }\n \n       bool _M_ready() const noexcept { return static_cast<bool>(_M_result); }\n@@ -495,6 +493,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       virtual void _M_complete_async() { }\n \n       // Return true if state contains a deferred function.\n+      // Caller must own _M_mutex.\n       virtual bool _M_has_deferred() const { return false; }\n     };\n "}, {"sha": "269268b989b9fa2314439986d216ecafb74925fe", "filename": "libstdc++-v3/testsuite/30_threads/promise/60966.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0eaa08cebd801a6a1d340dfd71b0183c510f599/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2F60966.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0eaa08cebd801a6a1d340dfd71b0183c510f599/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2F60966.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2F60966.cc?ref=a0eaa08cebd801a6a1d340dfd71b0183c510f599", "patch": "@@ -0,0 +1,67 @@\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-gnu* *-*-solaris* *-*-cygwin *-*-darwin* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++11 -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-gnu* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++11 -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++11 \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+// { dg-require-atomic-builtins \"\" }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// libstdc++/60966\n+// This test hangs if std::promise::~promise() destroys the\n+// shared state before std::promise::set_value() finishes using it.\n+\n+#include <future>\n+#include <thread>\n+#include <vector>\n+\n+const int THREADS = 10;\n+\n+void run_task(std::promise<void>* pr)\n+{\n+  std::this_thread::sleep_for(std::chrono::milliseconds(100));\n+  pr->set_value();\n+}\n+\n+int main()\n+{\n+  std::vector<std::promise<void>*> tasks(THREADS);\n+  std::vector<std::thread> threads(THREADS);\n+  std::vector<std::future<void>> futures(THREADS);\n+\n+  for (int i = 0; i < THREADS; ++i)\n+  {\n+    std::promise<void>* task = new std::promise<void>;\n+    tasks[i] = task;\n+    futures[i] = task->get_future();\n+    threads[i] = std::thread(run_task, task);\n+  }\n+\n+  for (int i = 0; i < THREADS; ++i)\n+  {\n+    // the temporary future releases the state as soon as wait() returns\n+    std::future<void>(std::move(futures[i])).wait();\n+    // state is ready, should now be safe to delete promise, so it\n+    // releases the shared state too\n+    delete tasks[i];\n+  }\n+\n+  for (auto& t : threads)\n+    t.join();\n+}"}]}