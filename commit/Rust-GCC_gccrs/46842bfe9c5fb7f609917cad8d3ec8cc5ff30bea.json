{"sha": "46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY4NDJiZmU5YzVmYjdmNjA5OTE3Y2FkOGQzZWM4Y2M1ZmYzMGJlYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-09-22T19:41:02Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-09-22T19:41:02Z"}, "message": "tree-ssa-ccp.c (prop_value_d): Rename to ...\n\n\n\t* tree-ssa-ccp.c (prop_value_d): Rename to ...\n\t(ccp_prop_value_t): ... this one to avoid ODR violation; update uses.\n\t* ipa-prop.c (struct type_change_info): Rename to ...\n\t(prop_type_change_info): ... this; update uses.\n\t* ggc-page.c (globals): Rename to ...\n\t(static struct ggc_globals): ... this; update uses.\n\t* tree-ssa-loop-im.c (mem_ref): Rename to ...\n\t(im_mem_ref): ... this; update uses.\n\t* ggc-common.c (loc_descriptor): Rename to ...\n\t(ggc_loc_descriptor): ... this; update uses.\n\t* lra-eliminations.c (elim_table): Rename to ...\n\t(lra_elim_table): ... this; update uses.\n\t* bitmap.c (output_info): Rename to ...\n\t(bitmap_output_info): ... this; update uses.\n\t* gcse.c (expr): Rename to ...\n\t(gcse_expr) ... this; update uses.\n\t(occr): Rename to ...\n\t(gcse_occr): .. this; update uses.\n\t* tree-ssa-copy.c (prop_value_d): Rename to ...\n\t(prop_value_t): ... this.\n\t* predict.c (block_info_def): Rename to ...\n\t(block_info): ... this; update uses.\n\t(edge_info_def): Rename to ...\n\t(edge_info): ... this; update uses.\n\t* profile.c (bb_info): Rename to ...\n\t(bb_profile_info): ... this; update uses.\n\t* alloc-pool.c (output_info): Rename to ...\n\t(pool_output_info): ... this; update uses.\n\t* ipa-cp.c (topo_info): Rename to ..\n\t(ipa_topo_info): ... this; update uses.\n\t* tree-nrv.c (nrv_data): Rename to ...\n\t(nrv_data_t): ... this; update uses.\n\t* ipa-split.c (bb_info): Rename to ...\n\t(split_bb_info): ... this one.\n\t* profile.h (edge_info): Rename to ...\n\t(edge_profile_info): ... this one; update uses.\n\t* dse.c (bb_info): Rename to ...\n\t(dse_bb_info): ... this one; update uses.\n\t* cprop.c (occr): Rename to ...\n\t(cprop_occr): ... this one; update uses.\n\t(expr): Rename to ...\n\t(cprop_expr): ... this one; update uses.\n\nFrom-SVN: r215481", "tree": {"sha": "81a83ef7308d61e0af0e1f1e3ed2c94921012d73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81a83ef7308d61e0af0e1f1e3ed2c94921012d73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea/comments", "author": null, "committer": null, "parents": [{"sha": "114783066e5d1046dfe83bb987008f4c2729e8f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/114783066e5d1046dfe83bb987008f4c2729e8f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/114783066e5d1046dfe83bb987008f4c2729e8f6"}], "stats": {"total": 47, "additions": 26, "deletions": 21}, "files": [{"sha": "245a554d5211ff1af7f1da71ff0e5e32c0e26a5f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea", "patch": "@@ -1,3 +1,8 @@\n+2014-09-21  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* openmp.c (omp_context): Rename to ...\n+\t(fortran_omp_context): ... this one.\n+\n 2014-09-21  Dominique d'Humieres <dominiq@lps.ens.fr>\n \n \t* resolve.c (resolve_fl_procedure): Remove duplicated lines."}, {"sha": "3ee0f9252d81ad4cdbbcdbaacd6e0a2844c9c020", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea", "patch": "@@ -3015,12 +3015,12 @@ resolve_omp_atomic (gfc_code *code)\n }\n \n \n-struct omp_context\n+struct fortran_omp_context\n {\n   gfc_code *code;\n   hash_set<gfc_symbol *> *sharing_clauses;\n   hash_set<gfc_symbol *> *private_iterators;\n-  struct omp_context *previous;\n+  struct fortran_omp_context *previous;\n } *omp_current_ctx;\n static gfc_code *omp_current_do_code;\n static int omp_current_do_collapse;\n@@ -3056,7 +3056,7 @@ gfc_resolve_omp_do_blocks (gfc_code *code, gfc_namespace *ns)\n void\n gfc_resolve_omp_parallel_blocks (gfc_code *code, gfc_namespace *ns)\n {\n-  struct omp_context ctx;\n+  struct fortran_omp_context ctx;\n   gfc_omp_clauses *omp_clauses = code->ext.omp_clauses;\n   gfc_omp_namelist *n;\n   int list;\n@@ -3126,7 +3126,7 @@ gfc_omp_save_and_clear_state (struct gfc_omp_saved_state *state)\n void\n gfc_omp_restore_state (struct gfc_omp_saved_state *state)\n {\n-  omp_current_ctx = (struct omp_context *) state->ptrs[0];\n+  omp_current_ctx = (struct fortran_omp_context *) state->ptrs[0];\n   omp_current_do_code = (gfc_code *) state->ptrs[1];\n   omp_current_do_collapse = state->ints[0];\n }"}, {"sha": "7d8b54c4b4ed682b67e968dd8768322b45f6cccc", "filename": "gcc/profile.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea", "patch": "@@ -74,15 +74,15 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"profile.h\"\n \n-struct bb_info {\n+struct bb_profile_info {\n   unsigned int count_valid : 1;\n \n   /* Number of successor and predecessor edges.  */\n   gcov_type succ_count;\n   gcov_type pred_count;\n };\n \n-#define BB_INFO(b)  ((struct bb_info *) (b)->aux)\n+#define BB_INFO(b)  ((struct bb_profile_info *) (b)->aux)\n \n \n /* Counter summary from the last set of coverage counts read.  */\n@@ -128,7 +128,7 @@ instrument_edges (struct edge_list *el)\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n-\t  struct edge_info *inf = EDGE_INFO (e);\n+\t  struct edge_profile_info *inf = EDGE_INFO (e);\n \n \t  if (!inf->ignore && !inf->on_tree)\n \t    {\n@@ -542,7 +542,7 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n     }\n \n   /* Attach extra info block to each bb.  */\n-  alloc_aux_for_blocks (sizeof (struct bb_info));\n+  alloc_aux_for_blocks (sizeof (struct bb_profile_info));\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     {\n       edge e;\n@@ -590,7 +590,7 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n       changes = 0;\n       FOR_BB_BETWEEN (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), NULL, prev_bb)\n \t{\n-\t  struct bb_info *bi = BB_INFO (bb);\n+\t  struct bb_profile_info *bi = BB_INFO (bb);\n \t  if (! bi->count_valid)\n \t    {\n \t      if (bi->succ_count == 0)\n@@ -1129,7 +1129,7 @@ branch_prob (void)\n \n   el = create_edge_list ();\n   num_edges = NUM_EDGES (el);\n-  alloc_aux_for_edges (sizeof (struct edge_info));\n+  alloc_aux_for_edges (sizeof (struct edge_profile_info));\n \n   /* The basic blocks are expected to be numbered sequentially.  */\n   compact_blocks ();\n@@ -1161,7 +1161,7 @@ branch_prob (void)\n   for (num_instrumented = i = 0; i < num_edges; i++)\n     {\n       edge e = INDEX_EDGE (el, i);\n-      struct edge_info *inf = EDGE_INFO (e);\n+      struct edge_profile_info *inf = EDGE_INFO (e);\n \n       if (inf->ignore || inf->on_tree)\n \t/*NOP*/;\n@@ -1221,7 +1221,7 @@ branch_prob (void)\n \n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n-\t      struct edge_info *i = EDGE_INFO (e);\n+\t      struct edge_profile_info *i = EDGE_INFO (e);\n \t      if (!i->ignore)\n \t\t{\n \t\t  unsigned flag_bits = 0;"}, {"sha": "325f777b8d068b763a8eb25054fe0540976a386f", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=46842bfe9c5fb7f609917cad8d3ec8cc5ff30bea", "patch": "@@ -116,7 +116,7 @@ typedef struct mem_ref_loc\n \n /* Description of a memory reference.  */\n \n-typedef struct mem_ref\n+typedef struct im_mem_ref\n {\n   unsigned id;\t\t\t/* ID assigned to the memory reference\n \t\t\t\t   (its index in memory_accesses.refs_list)  */\n@@ -153,23 +153,23 @@ typedef struct mem_ref\n \n /* Mem_ref hashtable helpers.  */\n \n-struct mem_ref_hasher : typed_noop_remove <mem_ref>\n+struct mem_ref_hasher : typed_noop_remove <im_mem_ref>\n {\n-  typedef mem_ref value_type;\n+  typedef im_mem_ref value_type;\n   typedef tree_node compare_type;\n   static inline hashval_t hash (const value_type *);\n   static inline bool equal (const value_type *, const compare_type *);\n };\n \n-/* A hash function for struct mem_ref object OBJ.  */\n+/* A hash function for struct im_mem_ref object OBJ.  */\n \n inline hashval_t\n mem_ref_hasher::hash (const value_type *mem)\n {\n   return mem->hash;\n }\n \n-/* An equality function for struct mem_ref object MEM1 with\n+/* An equality function for struct im_mem_ref object MEM1 with\n    memory reference OBJ2.  */\n \n inline bool\n@@ -1395,7 +1395,7 @@ force_move_till (tree ref, tree *index, void *data)\n /* A function to free the mem_ref object OBJ.  */\n \n static void\n-memref_free (struct mem_ref *mem)\n+memref_free (struct im_mem_ref *mem)\n {\n   mem->accesses_in_loop.release ();\n }\n@@ -1406,7 +1406,7 @@ memref_free (struct mem_ref *mem)\n static mem_ref_p\n mem_ref_alloc (tree mem, unsigned hash, unsigned id)\n {\n-  mem_ref_p ref = XOBNEW (&mem_ref_obstack, struct mem_ref);\n+  mem_ref_p ref = XOBNEW (&mem_ref_obstack, struct im_mem_ref);\n   ao_ref_init (&ref->mem, mem);\n   ref->id = id;\n   ref->hash = hash;\n@@ -1461,7 +1461,7 @@ gather_mem_refs_stmt (struct loop *loop, gimple stmt)\n {\n   tree *mem = NULL;\n   hashval_t hash;\n-  mem_ref **slot;\n+  im_mem_ref **slot;\n   mem_ref_p ref;\n   bool is_stored;\n   unsigned id;\n@@ -1578,7 +1578,7 @@ analyze_memory_references (void)\n \n   /* Sort the location list of gathered memory references after their\n      loop postorder number.  */\n-  mem_ref *ref;\n+  im_mem_ref *ref;\n   FOR_EACH_VEC_ELT (memory_accesses.refs_list, i, ref)\n     ref->accesses_in_loop.qsort (sort_locs_in_loop_postorder_cmp);\n "}]}