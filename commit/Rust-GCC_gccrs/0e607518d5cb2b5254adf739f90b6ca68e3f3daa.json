{"sha": "0e607518d5cb2b5254adf739f90b6ca68e3f3daa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU2MDc1MThkNWNiMmI1MjU0YWRmNzM5ZjkwYjZjYTY4ZTNmM2RhYQ==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2010-08-31T19:32:59Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2010-08-31T19:32:59Z"}, "message": "m32c.c (classes_intersect): Remove.\n\n\t* config/m32c/m32c.c (classes_intersect): Remove.\n\t(m32c_preferred_reload_class, m32c_secondary_reload_class): Use\n\treg_classes_intersect_p instead of classes_intersect.\n\t(class_can_hold_mode): Change arguments type from enum reg_class to\n\treg_class_t.  Use reg_class_contents instead of class_contents.\n\t(m32c_register_move_cost): Make static. Change arguments type from\n\tenum reg_class to reg_class_t. Use reg_classes_intersect_p instead of\n\tclasses_intersect. Use reg_class_contents instead of class_contents.\n\t(m32c_memory_move_cost): Make static. Change arguments type from\n\tenum reg_class to reg_class_t.\n\t(TARGET_REGISTER_MOVE_COST, TARGET_MEMORY_MOVE_COST): Define.\n\t* config/m32c/m32c.h (REGISTER_MOVE_COST, MEMORY_MOVE_COST): Remove.\n\t* config/m32c/m32c-protos.h (m32c_register_move_cost,\n\tm32c_memory_move_cost): Remove.\n\nFrom-SVN: r163693", "tree": {"sha": "1acdfeafd368992b156f4865d48a4dfba43efa60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1acdfeafd368992b156f4865d48a4dfba43efa60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e607518d5cb2b5254adf739f90b6ca68e3f3daa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e607518d5cb2b5254adf739f90b6ca68e3f3daa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e607518d5cb2b5254adf739f90b6ca68e3f3daa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e607518d5cb2b5254adf739f90b6ca68e3f3daa/comments", "author": null, "committer": null, "parents": [{"sha": "ad5f4de228737897d59cb3e629f934d504029e16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad5f4de228737897d59cb3e629f934d504029e16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad5f4de228737897d59cb3e629f934d504029e16"}], "stats": {"total": 113, "additions": 61, "deletions": 52}, "files": [{"sha": "865232c22c488dad352846377aa61d3d5c07f71d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e607518d5cb2b5254adf739f90b6ca68e3f3daa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e607518d5cb2b5254adf739f90b6ca68e3f3daa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e607518d5cb2b5254adf739f90b6ca68e3f3daa", "patch": "@@ -1,3 +1,20 @@\n+2010-08-31  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* config/m32c/m32c.c (classes_intersect): Remove.\n+\t(m32c_preferred_reload_class, m32c_secondary_reload_class): Use\n+\treg_classes_intersect_p instead of classes_intersect.\n+\t(class_can_hold_mode): Change arguments type from enum reg_class to\n+\treg_class_t.  Use reg_class_contents instead of class_contents.\n+\t(m32c_register_move_cost): Make static. Change arguments type from\n+\tenum reg_class to reg_class_t. Use reg_classes_intersect_p instead of\n+\tclasses_intersect. Use reg_class_contents instead of class_contents.\n+\t(m32c_memory_move_cost): Make static. Change arguments type from\n+\tenum reg_class to reg_class_t.\n+\t(TARGET_REGISTER_MOVE_COST, TARGET_MEMORY_MOVE_COST): Define.\n+\t* config/m32c/m32c.h (REGISTER_MOVE_COST, MEMORY_MOVE_COST): Remove.\n+\t* config/m32c/m32c-protos.h (m32c_register_move_cost,\n+\tm32c_memory_move_cost): Remove.\n+\n 2010-08-31  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* config/arm/arm-protos.h (arm_function_arg_advance): Delete."}, {"sha": "cd3c24087ded4934e482fdd8adc93741dcdf62ea", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e607518d5cb2b5254adf739f90b6ca68e3f3daa/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e607518d5cb2b5254adf739f90b6ca68e3f3daa/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=0e607518d5cb2b5254adf739f90b6ca68e3f3daa", "patch": "@@ -75,7 +75,6 @@ rtx  m32c_incoming_return_addr_rtx (void);\n int  m32c_legitimate_constant_p (rtx);\n int  m32c_legitimize_reload_address (rtx *, MM, int, int, int);\n int  m32c_limit_reload_class (MM, int);\n-int  m32c_memory_move_cost (MM, int, int);\n int  m32c_modes_tieable_p (MM, MM);\n bool m32c_mov_ok (rtx *, MM);\n char * m32c_output_compare (rtx, rtx *);\n@@ -86,7 +85,6 @@ int  m32c_prepare_shift (rtx *, int, int);\n void m32c_print_operand (FILE *, rtx, int);\n void m32c_print_operand_address (FILE *, rtx);\n int  m32c_reg_ok_for_base_p (rtx, int);\n-int  m32c_register_move_cost (MM, int, int);\n MM   m32c_regno_reg_class (int);\n rtx  m32c_return_addr_rtx (int);\n const char *m32c_scc_pattern (rtx *, RTX_CODE);"}, {"sha": "42d343a0bb0a607627a5d73b30e7b5a647dab1e3", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e607518d5cb2b5254adf739f90b6ca68e3f3daa/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e607518d5cb2b5254adf739f90b6ca68e3f3daa/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=0e607518d5cb2b5254adf739f90b6ca68e3f3daa", "patch": "@@ -340,47 +340,33 @@ reduce_class (int original_class, int limiting_class, int returned_if_empty)\n   return best;\n }\n \n-/* Returns TRUE If there are any registers that exist in both register\n-   classes.  */\n-static int\n-classes_intersect (int class1, int class2)\n-{\n-  return class_contents[class1][0] & class_contents[class2][0];\n-}\n-\n /* Used by m32c_register_move_cost to determine if a move is\n    impossibly expensive.  */\n-static int\n-class_can_hold_mode (int rclass, enum machine_mode mode)\n+static bool\n+class_can_hold_mode (reg_class_t rclass, enum machine_mode mode)\n {\n   /* Cache the results:  0=untested  1=no  2=yes */\n   static char results[LIM_REG_CLASSES][MAX_MACHINE_MODE];\n-  if (results[rclass][mode] == 0)\n+\n+  if (results[(int) rclass][mode] == 0)\n     {\n-      int r, n, i;\n+      int r;\n       results[rclass][mode] = 1;\n       for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n-\tif (class_contents[rclass][0] & (1 << r)\n+\tif (in_hard_reg_set_p (reg_class_contents[(int) rclass], mode, r)\n \t    && HARD_REGNO_MODE_OK (r, mode))\n \t  {\n-\t    int ok = 1;\n-\t    n = HARD_REGNO_NREGS (r, mode);\n-\t    for (i = 1; i < n; i++)\n-\t      if (!(class_contents[rclass][0] & (1 << (r + i))))\n-\t\tok = 0;\n-\t    if (ok)\n-\t      {\n-\t\tresults[rclass][mode] = 2;\n-\t\tbreak;\n-\t      }\n+\t    results[rclass][mode] = 2;\n+\t    break;\n \t  }\n     }\n+\n #if DEBUG0\n   fprintf (stderr, \"class %s can hold %s? %s\\n\",\n-\t   class_names[rclass], mode_name[mode],\n+\t   class_names[(int) rclass], mode_name[mode],\n \t   (results[rclass][mode] == 2) ? \"yes\" : \"no\");\n #endif\n-  return results[rclass][mode] == 2;\n+  return results[(int) rclass][mode] == 2;\n }\n \n /* Run-time Target Specification.  */\n@@ -740,7 +726,7 @@ m32c_preferred_reload_class (rtx x, int rclass)\n   if (rclass == NO_REGS)\n     rclass = GET_MODE (x) == QImode ? HL_REGS : R03_REGS;\n \n-  if (classes_intersect (rclass, CR_REGS))\n+  if (reg_classes_intersect_p (rclass, CR_REGS))\n     {\n       switch (GET_MODE (x))\n \t{\n@@ -826,7 +812,7 @@ m32c_secondary_reload_class (int rclass, enum machine_mode mode, rtx x)\n   if (mode == QImode\n       && GET_CODE (x) == MEM && (cc & ~class_contents[R23_REGS][0]) == 0)\n     return QI_REGS;\n-  if (classes_intersect (rclass, CR_REGS)\n+  if (reg_classes_intersect_p (rclass, CR_REGS)\n       && GET_CODE (x) == REG\n       && REGNO (x) >= SB_REGNO && REGNO (x) <= SP_REGNO)\n     return TARGET_A16 ? HI_REGS : A_REGS;\n@@ -2096,19 +2082,29 @@ m32c_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n \n /* Describing Relative Costs of Operations */\n \n-/* Implements REGISTER_MOVE_COST.  We make impossible moves\n+/* Implements TARGET_REGISTER_MOVE_COST.  We make impossible moves\n    prohibitively expensive, like trying to put QIs in r2/r3 (there are\n    no opcodes to do that).  We also discourage use of mem* registers\n    since they're really memory.  */\n-int\n-m32c_register_move_cost (enum machine_mode mode, int from, int to)\n+\n+#undef TARGET_REGISTER_MOVE_COST\n+#define TARGET_REGISTER_MOVE_COST m32c_register_move_cost\n+\n+static int\n+m32c_register_move_cost (enum machine_mode mode, reg_class_t from,\n+\t\t\t reg_class_t to)\n {\n   int cost = COSTS_N_INSNS (3);\n-  int cc = class_contents[from][0] | class_contents[to][0];\n-  /* FIXME: pick real values, but not 2 for now.  */\n-  if (mode == QImode && (cc & class_contents[R23_REGS][0]))\n+  HARD_REG_SET cc;\n+\n+/* FIXME: pick real values, but not 2 for now.  */\n+  COPY_HARD_REG_SET (cc, reg_class_contents[(int) from]);\n+  IOR_HARD_REG_SET (cc, reg_class_contents[(int) to]);\n+\n+  if (mode == QImode\n+      && hard_reg_set_intersect_p (cc, reg_class_contents[R23_REGS]))\n     {\n-      if (!(cc & ~class_contents[R23_REGS][0]))\n+      if (hard_reg_set_subset_p (cc, reg_class_contents[R23_REGS]))\n \tcost = COSTS_N_INSNS (1000);\n       else\n \tcost = COSTS_N_INSNS (80);\n@@ -2117,30 +2113,35 @@ m32c_register_move_cost (enum machine_mode mode, int from, int to)\n   if (!class_can_hold_mode (from, mode) || !class_can_hold_mode (to, mode))\n     cost = COSTS_N_INSNS (1000);\n \n-  if (classes_intersect (from, CR_REGS))\n+  if (reg_classes_intersect_p (from, CR_REGS))\n     cost += COSTS_N_INSNS (5);\n \n-  if (classes_intersect (to, CR_REGS))\n+  if (reg_classes_intersect_p (to, CR_REGS))\n     cost += COSTS_N_INSNS (5);\n \n   if (from == MEM_REGS || to == MEM_REGS)\n     cost += COSTS_N_INSNS (50);\n-  else if (classes_intersect (from, MEM_REGS)\n-\t   || classes_intersect (to, MEM_REGS))\n+  else if (reg_classes_intersect_p (from, MEM_REGS)\n+\t   || reg_classes_intersect_p (to, MEM_REGS))\n     cost += COSTS_N_INSNS (10);\n \n #if DEBUG0\n   fprintf (stderr, \"register_move_cost %s from %s to %s = %d\\n\",\n-\t   mode_name[mode], class_names[from], class_names[to], cost);\n+\t   mode_name[mode], class_names[(int) from], class_names[(int) to],\n+\t   cost);\n #endif\n   return cost;\n }\n \n-/*  Implements MEMORY_MOVE_COST.  */\n-int\n+/*  Implements TARGET_MEMORY_MOVE_COST.  */\n+\n+#undef TARGET_MEMORY_MOVE_COST\n+#define TARGET_MEMORY_MOVE_COST m32c_memory_move_cost\n+\n+static int\n m32c_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t       int reg_class ATTRIBUTE_UNUSED,\n-\t\t       int in ATTRIBUTE_UNUSED)\n+\t\t       reg_class_t rclass ATTRIBUTE_UNUSED,\n+\t\t       bool in ATTRIBUTE_UNUSED)\n {\n   /* FIXME: pick real values.  */\n   return COSTS_N_INSNS (10);"}, {"sha": "ed20b822159411d55c3f66a80c594644f73bc968", "filename": "gcc/config/m32c/m32c.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e607518d5cb2b5254adf739f90b6ca68e3f3daa/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e607518d5cb2b5254adf739f90b6ca68e3f3daa/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=0e607518d5cb2b5254adf739f90b6ca68e3f3daa", "patch": "@@ -578,13 +578,6 @@ typedef struct m32c_cumulative_args\n \n #define REVERSIBLE_CC_MODE(MODE) 1\n \n-/* Describing Relative Costs of Operations */\n-\n-#define REGISTER_MOVE_COST(MODE,FROM,TO) \\\n-\tm32c_register_move_cost (MODE, FROM, TO)\n-#define MEMORY_MOVE_COST(MODE,CLASS,IN) \\\n-\tm32c_memory_move_cost (MODE, CLASS, IN)\n-\n /* Dividing the Output into Sections (Texts, Data, ...) */\n \n #define TEXT_SECTION_ASM_OP \".text\""}]}