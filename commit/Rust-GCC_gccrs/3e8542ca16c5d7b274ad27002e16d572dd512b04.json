{"sha": "3e8542ca16c5d7b274ad27002e16d572dd512b04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U4NTQyY2ExNmM1ZDdiMjc0YWQyNzAwMmUxNmQ1NzJkZDUxMmIwNA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-04-13T09:53:19Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-04-13T09:53:19Z"}, "message": "tree-ssa-structalias.c (callused_id): Remove.\n\n2010-04-13  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-structalias.c (callused_id): Remove.\n\t(call_stmt_vars): New.\n\t(get_call_vi): Likewise.\n\t(lookup_call_use_vi): Likewise.\n\t(lookup_call_clobber_vi): Likewise.\n\t(get_call_use_vi): Likewise.\n\t(get_call_clobber_vi): Likewise.\n\t(make_transitive_closure_constraints): Likewise.\n\t(handle_const_call): Adjust to do per-call call-used handling.\n\t(handle_pure_call): Likewise.\n\t(find_what_var_points_to): Remove general callused handling.\n\t(init_base_vars): Likewise.\n\t(init_alias_vars): Initialize call_stmt_vars.\n\t(compute_points_to_sets): Process call-used and call-clobbered\n\tvars for call statements.\n\t(delete_points_to_sets): Free call_stmt_vars.\n\nFrom-SVN: r158260", "tree": {"sha": "9973b986af305de702b32cdd7c195a7acf7ab078", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9973b986af305de702b32cdd7c195a7acf7ab078"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e8542ca16c5d7b274ad27002e16d572dd512b04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e8542ca16c5d7b274ad27002e16d572dd512b04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e8542ca16c5d7b274ad27002e16d572dd512b04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e8542ca16c5d7b274ad27002e16d572dd512b04/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "777e1f09ffc68eb0c122c74275fd69aef2dea61d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777e1f09ffc68eb0c122c74275fd69aef2dea61d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/777e1f09ffc68eb0c122c74275fd69aef2dea61d"}], "stats": {"total": 224, "additions": 170, "deletions": 54}, "files": [{"sha": "e0e55a964d5266caa83b4c4adc634207ad7853f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e8542ca16c5d7b274ad27002e16d572dd512b04/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e8542ca16c5d7b274ad27002e16d572dd512b04/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3e8542ca16c5d7b274ad27002e16d572dd512b04", "patch": "@@ -1,3 +1,22 @@\n+2010-04-13  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-structalias.c (callused_id): Remove.\n+\t(call_stmt_vars): New.\n+\t(get_call_vi): Likewise.\n+\t(lookup_call_use_vi): Likewise.\n+\t(lookup_call_clobber_vi): Likewise.\n+\t(get_call_use_vi): Likewise.\n+\t(get_call_clobber_vi): Likewise.\n+\t(make_transitive_closure_constraints): Likewise.\n+\t(handle_const_call): Adjust to do per-call call-used handling.\n+\t(handle_pure_call): Likewise.\n+\t(find_what_var_points_to): Remove general callused handling.\n+\t(init_base_vars): Likewise.\n+\t(init_alias_vars): Initialize call_stmt_vars.\n+\t(compute_points_to_sets): Process call-used and call-clobbered\n+\tvars for call statements.\n+\t(delete_points_to_sets): Free call_stmt_vars.\n+\n 2010-04-13  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence):"}, {"sha": "85493a2dd503e4ba5db8037200eb8112b9bedf81", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 151, "deletions": 54, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e8542ca16c5d7b274ad27002e16d572dd512b04/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e8542ca16c5d7b274ad27002e16d572dd512b04/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=3e8542ca16c5d7b274ad27002e16d572dd512b04", "patch": "@@ -288,8 +288,8 @@ get_varinfo (unsigned int n)\n \n /* Static IDs for the special variables.  */\n enum { nothing_id = 0, anything_id = 1, readonly_id = 2,\n-       escaped_id = 3, nonlocal_id = 4, callused_id = 5,\n-       storedanything_id = 6, integer_id = 7 };\n+       escaped_id = 3, nonlocal_id = 4,\n+       storedanything_id = 5, integer_id = 6 };\n \n struct GTY(()) heapvar_map {\n   struct tree_map map;\n@@ -379,6 +379,86 @@ new_var_info (tree t, const char *name)\n   return ret;\n }\n \n+\n+/* A map mapping call statements to per-stmt variables for uses\n+   and clobbers specific to the call.  */\n+struct pointer_map_t *call_stmt_vars;\n+\n+/* Lookup or create the variable for the call statement CALL.  */\n+\n+static varinfo_t\n+get_call_vi (gimple call)\n+{\n+  void **slot_p;\n+  varinfo_t vi, vi2;\n+\n+  slot_p = pointer_map_insert (call_stmt_vars, call);\n+  if (*slot_p)\n+    return (varinfo_t) *slot_p;\n+\n+  vi = new_var_info (NULL_TREE, \"CALLUSED\");\n+  vi->offset = 0;\n+  vi->size = 1;\n+  vi->fullsize = 2;\n+  vi->is_full_var = true;\n+\n+  vi->next = vi2 = new_var_info (NULL_TREE, \"CALLCLOBBERED\");\n+  vi2->offset = 1;\n+  vi2->size = 1;\n+  vi2->fullsize = 2;\n+  vi2->is_full_var = true;\n+\n+  *slot_p = (void *) vi;\n+  return vi;\n+}\n+\n+/* Lookup the variable for the call statement CALL representing\n+   the uses.  Returns NULL if there is nothing special about this call.  */\n+\n+static varinfo_t\n+lookup_call_use_vi (gimple call)\n+{\n+  void **slot_p;\n+\n+  slot_p = pointer_map_contains (call_stmt_vars, call);\n+  if (slot_p)\n+    return (varinfo_t) *slot_p;\n+\n+  return NULL;\n+}\n+\n+/* Lookup the variable for the call statement CALL representing\n+   the clobbers.  Returns NULL if there is nothing special about this call.  */\n+\n+static varinfo_t\n+lookup_call_clobber_vi (gimple call)\n+{\n+  varinfo_t uses = lookup_call_use_vi (call);\n+  if (!uses)\n+    return NULL;\n+\n+  return uses->next;\n+}\n+\n+/* Lookup or create the variable for the call statement CALL representing\n+   the uses.  */\n+\n+static varinfo_t\n+get_call_use_vi (gimple call)\n+{\n+  return get_call_vi (call);\n+}\n+\n+/* Lookup or create the variable for the call statement CALL representing\n+   the clobbers.  */\n+\n+static varinfo_t ATTRIBUTE_UNUSED\n+get_call_clobber_vi (gimple call)\n+{\n+  return get_call_vi (call)->next;\n+}\n+\n+\n typedef enum {SCALAR, DEREF, ADDRESSOF} constraint_expr_type;\n \n /* An expression that appears in a constraint.  */\n@@ -3377,6 +3457,32 @@ make_escape_constraint (tree op)\n   make_constraint_to (escaped_id, op);\n }\n \n+/* Add constraints to that the solution of VI is transitively closed.  */\n+\n+static void\n+make_transitive_closure_constraints (varinfo_t vi)\n+{\n+  struct constraint_expr lhs, rhs;\n+\n+  /* VAR = *VAR;  */\n+  lhs.type = SCALAR;\n+  lhs.var = vi->id;\n+  lhs.offset = 0;\n+  rhs.type = DEREF;\n+  rhs.var = vi->id;\n+  rhs.offset = 0;\n+  process_constraint (new_constraint (lhs, rhs));\n+\n+  /* VAR = VAR + UNKNOWN;  */\n+  lhs.type = SCALAR;\n+  lhs.var = vi->id;\n+  lhs.offset = 0;\n+  rhs.type = SCALAR;\n+  rhs.var = vi->id;\n+  rhs.offset = UNKNOWN_OFFSET;\n+  process_constraint (new_constraint (lhs, rhs));\n+}\n+\n /* Create a new artificial heap variable with NAME and make a\n    constraint from it to LHS.  Return the created variable.  */\n \n@@ -3538,8 +3644,10 @@ handle_const_call (gimple stmt, VEC(ce_s, heap) **results)\n      as the static chain is concerned.  */\n   if (gimple_call_chain (stmt))\n     {\n-      make_constraint_to (callused_id, gimple_call_chain (stmt));\n-      rhsc.var = callused_id;\n+      varinfo_t uses = get_call_use_vi (stmt);\n+      make_transitive_closure_constraints (uses);\n+      make_constraint_to (uses->id, gimple_call_chain (stmt));\n+      rhsc.var = uses->id;\n       rhsc.offset = 0;\n       rhsc.type = SCALAR;\n       VEC_safe_push (ce_s, heap, *results, &rhsc);\n@@ -3577,7 +3685,7 @@ handle_pure_call (gimple stmt, VEC(ce_s, heap) **results)\n {\n   struct constraint_expr rhsc;\n   unsigned i;\n-  bool need_callused = false;\n+  varinfo_t uses = NULL;\n \n   /* Memory reached from pointer arguments is call-used.  */\n   for (i = 0; i < gimple_call_num_args (stmt); ++i)\n@@ -3586,22 +3694,30 @@ handle_pure_call (gimple stmt, VEC(ce_s, heap) **results)\n \n       if (could_have_pointers (arg))\n \t{\n-\t  make_constraint_to (callused_id, arg);\n-\t  need_callused = true;\n+\t  if (!uses)\n+\t    {\n+\t      uses = get_call_use_vi (stmt);\n+\t      make_transitive_closure_constraints (uses);\n+\t    }\n+\t  make_constraint_to (uses->id, arg);\n \t}\n     }\n \n   /* The static chain is used as well.  */\n   if (gimple_call_chain (stmt))\n     {\n-      make_constraint_to (callused_id, gimple_call_chain (stmt));\n-      need_callused = true;\n+      if (!uses)\n+\t{\n+\t  uses = get_call_use_vi (stmt);\n+\t  make_transitive_closure_constraints (uses);\n+\t}\n+      make_constraint_to (uses->id, gimple_call_chain (stmt));\n     }\n \n-  /* Pure functions may return callused and nonlocal memory.  */\n-  if (need_callused)\n+  /* Pure functions may return call-used and nonlocal memory.  */\n+  if (uses)\n     {\n-      rhsc.var = callused_id;\n+      rhsc.var = uses->id;\n       rhsc.offset = 0;\n       rhsc.type = SCALAR;\n       VEC_safe_push (ce_s, heap, *results, &rhsc);\n@@ -4004,8 +4120,8 @@ find_func_aliases (gimple origt)\n \t  if (!allows_reg && allows_mem)\n \t    make_escape_constraint (build_fold_addr_expr (op));\n \t  /* Strictly we'd only need the constraint to ESCAPED if\n-\t     the asm clobbers memory, otherwise using CALLUSED\n-\t     would be enough.  */\n+\t     the asm clobbers memory, otherwise using something\n+\t     along the lines of per-call clobbers/uses would be enough.  */\n \t  else if (op && could_have_pointers (op))\n \t    make_escape_constraint (op);\n \t}\n@@ -4811,8 +4927,6 @@ find_what_var_points_to (varinfo_t orig_vi, struct pt_solution *pt)\n \t    pt->null = 1;\n \t  else if (vi->id == escaped_id)\n \t    pt->escaped = 1;\n-\t  else if (vi->id == callused_id)\n-\t    gcc_unreachable ();\n \t  else if (vi->id == nonlocal_id)\n \t    pt->nonlocal = 1;\n \t  else if (vi->is_heap_var)\n@@ -5138,7 +5252,6 @@ init_base_vars (void)\n   varinfo_t var_readonly;\n   varinfo_t var_escaped;\n   varinfo_t var_nonlocal;\n-  varinfo_t var_callused;\n   varinfo_t var_storedanything;\n   varinfo_t var_integer;\n \n@@ -5265,35 +5378,6 @@ init_base_vars (void)\n   rhs.offset = 0;\n   process_constraint (new_constraint (lhs, rhs));\n \n-  /* Create the CALLUSED variable, used to represent the set of call-used\n-     memory.  */\n-  var_callused = new_var_info (NULL_TREE, \"CALLUSED\");\n-  gcc_assert (var_callused->id == callused_id);\n-  var_callused->is_artificial_var = 1;\n-  var_callused->offset = 0;\n-  var_callused->size = ~0;\n-  var_callused->fullsize = ~0;\n-  var_callused->is_special_var = 0;\n-\n-  /* CALLUSED = *CALLUSED, because call-used is may-deref'd at calls, etc.  */\n-  lhs.type = SCALAR;\n-  lhs.var = callused_id;\n-  lhs.offset = 0;\n-  rhs.type = DEREF;\n-  rhs.var = callused_id;\n-  rhs.offset = 0;\n-  process_constraint (new_constraint (lhs, rhs));\n-\n-  /* CALLUSED = CALLUSED + UNKNOWN, because if a sub-field is call-used the\n-     whole variable is call-used.  */\n-  lhs.type = SCALAR;\n-  lhs.var = callused_id;\n-  lhs.offset = 0;\n-  rhs.type = SCALAR;\n-  rhs.var = callused_id;\n-  rhs.offset = UNKNOWN_OFFSET;\n-  process_constraint (new_constraint (lhs, rhs));\n-\n   /* Create the STOREDANYTHING variable, used to represent the set of\n      variables stored to *ANYTHING.  */\n   var_storedanything = new_var_info (NULL_TREE, \"STOREDANYTHING\");\n@@ -5344,6 +5428,7 @@ init_alias_vars (void)\n   constraints = VEC_alloc (constraint_t, heap, 8);\n   varmap = VEC_alloc (varinfo_t, heap, 8);\n   vi_for_tree = pointer_map_create ();\n+  call_stmt_vars = pointer_map_create ();\n \n   memset (&stats, 0, sizeof (stats));\n   shared_bitmap_table = htab_create (511, shared_bitmap_hash,\n@@ -5480,7 +5565,6 @@ compute_points_to_sets (void)\n   basic_block bb;\n   unsigned i;\n   varinfo_t vi;\n-  struct pt_solution callused;\n \n   timevar_push (TV_TREE_PTA);\n \n@@ -5513,11 +5597,9 @@ compute_points_to_sets (void)\n   /* From the constraints compute the points-to sets.  */\n   solve_constraints ();\n \n-  /* Compute the points-to sets for ESCAPED and CALLUSED used for\n-     call-clobber analysis.  */\n+  /* Compute the points-to set for ESCAPED used for call-clobber analysis.  */\n   find_what_var_points_to (get_varinfo (escaped_id),\n \t\t\t   &cfun->gimple_df->escaped);\n-  find_what_var_points_to (get_varinfo (callused_id), &callused);\n \n   /* Make sure the ESCAPED solution (which is used as placeholder in\n      other solutions) does not reference itself.  This simplifies\n@@ -5556,27 +5638,41 @@ compute_points_to_sets (void)\n \t  pt = gimple_call_use_set (stmt);\n \t  if (gimple_call_flags (stmt) & ECF_CONST)\n \t    memset (pt, 0, sizeof (struct pt_solution));\n-\t  else if (gimple_call_flags (stmt) & ECF_PURE)\n+\t  else if ((vi = lookup_call_use_vi (stmt)) != NULL)\n \t    {\n-\t      /* For const calls we should now be able to compute the\n-\t\t call-used set per function.  */\n-\t      *pt = callused;\n+\t      find_what_var_points_to (vi, pt);\n+\t      /* Escaped (and thus nonlocal) variables are always\n+\t         implicitly used by calls.  */\n \t      /* ???  ESCAPED can be empty even though NONLOCAL\n \t\t always escaped.  */\n \t      pt->nonlocal = 1;\n \t      pt->escaped = 1;\n \t    }\n \t  else\n \t    {\n+\t      /* If there is nothing special about this call then\n+\t\t we have made everything that is used also escape.  */\n \t      *pt = cfun->gimple_df->escaped;\n \t      pt->nonlocal = 1;\n \t    }\n \n \t  pt = gimple_call_clobber_set (stmt);\n \t  if (gimple_call_flags (stmt) & (ECF_CONST|ECF_PURE|ECF_NOVOPS))\n \t    memset (pt, 0, sizeof (struct pt_solution));\n+\t  else if ((vi = lookup_call_clobber_vi (stmt)) != NULL)\n+\t    {\n+\t      find_what_var_points_to (vi, pt);\n+\t      /* Escaped (and thus nonlocal) variables are always\n+\t         implicitly clobbered by calls.  */\n+\t      /* ???  ESCAPED can be empty even though NONLOCAL\n+\t\t always escaped.  */\n+\t      pt->nonlocal = 1;\n+\t      pt->escaped = 1;\n+\t    }\n \t  else\n \t    {\n+\t      /* If there is nothing special about this call then\n+\t\t we have made everything that is used also escape.  */\n \t      *pt = cfun->gimple_df->escaped;\n \t      pt->nonlocal = 1;\n \t    }\n@@ -5600,6 +5696,7 @@ delete_points_to_sets (void)\n \t     stats.points_to_sets_created);\n \n   pointer_map_destroy (vi_for_tree);\n+  pointer_map_destroy (call_stmt_vars);\n   bitmap_obstack_release (&pta_obstack);\n   VEC_free (constraint_t, heap, constraints);\n "}]}