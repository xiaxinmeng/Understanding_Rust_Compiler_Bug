{"sha": "6b9b5de22a60008f1139279ad1bf7141aeab1341", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI5YjVkZTIyYTYwMDA4ZjExMzkyNzlhZDFiZjcxNDFhZWFiMTM0MQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-05-08T01:41:41Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-05-08T01:41:41Z"}, "message": "re PR java/1200 (gcjh -jni doesn't respect class hierarchy)\n\n\tFix for PR java/1200:\n\t* gjavah.c (throwable_p): New function.\n\t(decode_signature_piece): Use it.  A `WeakReference' isn't the\n\tsame as a `jweak'.\n\tInclude hashtab.h.\n\t(gcjh_streq): New function.\n\nFrom-SVN: r53275", "tree": {"sha": "4acb29adf6d91fc12701fb2159f77e7e32d489c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4acb29adf6d91fc12701fb2159f77e7e32d489c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b9b5de22a60008f1139279ad1bf7141aeab1341", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b9b5de22a60008f1139279ad1bf7141aeab1341", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b9b5de22a60008f1139279ad1bf7141aeab1341", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b9b5de22a60008f1139279ad1bf7141aeab1341/comments", "author": null, "committer": null, "parents": [{"sha": "db84f1bded499cdcc8a8eb7e81383ac8d86f2a44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db84f1bded499cdcc8a8eb7e81383ac8d86f2a44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db84f1bded499cdcc8a8eb7e81383ac8d86f2a44"}], "stats": {"total": 130, "additions": 119, "deletions": 11}, "files": [{"sha": "a8f7f208706c3bf32697061bbde33e105e651edf", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9b5de22a60008f1139279ad1bf7141aeab1341/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9b5de22a60008f1139279ad1bf7141aeab1341/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=6b9b5de22a60008f1139279ad1bf7141aeab1341", "patch": "@@ -1,3 +1,12 @@\n+2002-05-07  Tom Tromey  <tromey@redhat.com>\n+\n+\tFix for PR java/1200:\n+\t* gjavah.c (throwable_p): New function.\n+\t(decode_signature_piece): Use it.  A `WeakReference' isn't the\n+\tsame as a `jweak'.\n+\tInclude hashtab.h.\n+\t(gcjh_streq): New function.\n+\n 2002-05-07  Andreas Jaeger  <aj@suse.de>\n \n         * parse.y (finish_for_loop): Fix if statement."}, {"sha": "d152b3729445eee8299a769e51255b3d8bf8bdc3", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 110, "deletions": 11, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9b5de22a60008f1139279ad1bf7141aeab1341/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9b5de22a60008f1139279ad1bf7141aeab1341/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=6b9b5de22a60008f1139279ad1bf7141aeab1341", "patch": "@@ -33,6 +33,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"javaop.h\"\n #include \"java-tree.h\"\n #include \"java-opcodes.h\"\n+#include \"hashtab.h\"\n \n #include <getopt.h>\n \n@@ -142,6 +143,8 @@ static char *get_field_name PARAMS ((JCF *, int, JCF_u2));\n static void print_field_name PARAMS ((FILE *, JCF *, int, JCF_u2));\n static const unsigned char *super_class_name PARAMS ((JCF *, int *));\n static void print_include PARAMS ((FILE *, const unsigned char *, int));\n+static int gcjh_streq PARAMS ((const void *p1, const void *p2));\n+static int throwable_p PARAMS ((const unsigned char *signature));\n static const unsigned char *decode_signature_piece\n   PARAMS ((FILE *, const unsigned char *, const unsigned char *, int *));\n static void print_class_decls PARAMS ((FILE *, JCF *, int));\n@@ -1091,6 +1094,111 @@ decompile_method (out, jcf, code_len)\n     }\n }\n \n+/* Like strcmp, but invert the return result for the hash table.  This\n+   should probably be in hashtab.c to complement the existing string\n+   hash function.  */\n+static int\n+gcjh_streq (p1, p2)\n+     const void *p1, *p2;\n+{\n+  return ! strcmp ((char *) p1, (char *) p2);\n+}\n+\n+/* Return 1 if the initial (L<classname>;) part of SIGNATURE names a\n+   subclass of throwable, or 0 if not.  */\n+static int\n+throwable_p (signature)\n+     const unsigned char *signature;\n+{\n+  int length;\n+  unsigned char *current;\n+  int i;\n+  int result = 0;\n+\n+  /* We keep two hash tables of class names.  In one we list all the\n+     classes which are subclasses of Throwable.  In the other we will\n+     all other classes.  We keep two tables to make the code a bit\n+     simpler; we don't have to have a structure mapping class name to\n+     a `throwable?' bit.  */\n+  static htab_t throw_hash;\n+  static htab_t non_throw_hash;\n+  static int init_done = 0;\n+\n+  if (! init_done)\n+    {\n+      PTR *slot;\n+      const unsigned char *str;\n+\n+      /* Self-initializing.  The cost of this really doesn't matter.\n+\t We also don't care about freeing these, either.  */\n+      throw_hash = htab_create (10, htab_hash_string, gcjh_streq,\n+\t\t\t\t(htab_del) free);\n+      non_throw_hash = htab_create (10, htab_hash_string, gcjh_streq,\n+\t\t\t\t    (htab_del) free);\n+\n+      /* Make sure the root classes show up in the tables.  */\n+      str = strdup (\"java.lang.Throwable\");\n+      slot = htab_find_slot (throw_hash, str, INSERT);\n+      *slot = (PTR) str;\n+\n+      str = strdup (\"java.lang.Object\");\n+      slot = htab_find_slot (non_throw_hash, str, INSERT);\n+      *slot = (PTR) str;\n+\n+      init_done = 1;\n+    }\n+\n+  for (length = 0; signature[length] != ';'; ++length)\n+    ;\n+  current = (unsigned char *) ALLOC (length);\n+  for (i = 1; signature[i] != ';'; ++i)\n+    current[i - 1] = signature[i] == '/' ? '.' : signature[i];\n+  current[i - 1] = '\\0';\n+\n+  /* We don't compute the hash slot here because the table might be\n+     modified by the recursion.  In that case the slot could be\n+     invalidated.  */\n+  if (htab_find (throw_hash, current))\n+    result = 1;\n+  else if (htab_find (non_throw_hash, current))\n+    result = 0;\n+  else\n+    {\n+      JCF jcf;\n+      PTR *slot;\n+      const char *classfile_name = find_class (current, strlen (current),\n+\t\t\t\t\t       &jcf, 0);\n+\n+      if (! classfile_name)\n+\t{\n+\t  fprintf (stderr, \"couldn't find class %s\\n\", current);\n+\t  found_error = 1;\n+\t  return 0;\n+\t}\n+      if (jcf_parse_preamble (&jcf) != 0\n+\t  || jcf_parse_constant_pool (&jcf) != 0\n+\t  || verify_constant_pool (&jcf) > 0)\n+\t{\n+\t  fprintf (stderr, \"parse error while reading %s\\n\", classfile_name);\n+\t  found_error = 1;\n+\t  return 0;\n+\t}\n+      jcf_parse_class (&jcf);\n+\n+      result = throwable_p (super_class_name (&jcf, NULL));\n+      slot = htab_find_slot (result ? throw_hash : non_throw_hash,\n+\t\t\t     current, INSERT);\n+      *slot = current;\n+      current = NULL;\n+\n+      JCF_FINISH (&jcf);\n+    }\n+\n+  if (current)\n+    free (current);\n+  return result;\n+}\n+\n /* Print one piece of a signature.  Returns pointer to next parseable\n    character on success, NULL on error.  */\n static const unsigned char *\n@@ -1204,24 +1312,15 @@ decode_signature_piece (stream, signature, limit, need_space)\n     case 'L':\n       if (flag_jni)\n \t{\n-\t  /* We know about certain types and special-case their\n-\t     names.\n-\t     FIXME: something like java.lang.Exception should be\n-\t     printed as `jthrowable', because it is a subclass.  This\n-\t     means that gcjh must read the entire hierarchy and\n-\t     comprehend it.  */\n+\t  /* We know about certain types and special-case their names.  */\n \t  if (! strncmp (signature, \"Ljava/lang/String;\",\n \t\t\t sizeof (\"Ljava/lang/String;\") -1))\n \t    ctype = \"jstring\";\n \t  else if (! strncmp (signature, \"Ljava/lang/Class;\",\n \t\t\t      sizeof (\"Ljava/lang/Class;\") - 1))\n \t    ctype = \"jclass\";\n-\t  else if (! strncmp (signature, \"Ljava/lang/Throwable;\",\n-\t\t\t      sizeof (\"Ljava/lang/Throwable;\") - 1))\n+\t  else if (throwable_p (signature))\n \t    ctype = \"jthrowable\";\n-\t  else if (! strncmp (signature, \"Ljava/lang/ref/WeakReference;\",\n-\t\t\t      sizeof (\"Ljava/lang/ref/WeakReference;\") - 1))\n-\t    ctype = \"jweak\";\n \t  else\n \t    ctype = \"jobject\";\n "}]}