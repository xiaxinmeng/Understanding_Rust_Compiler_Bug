{"sha": "112a861d6d6cbc78372888692043ebbb70c310d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEyYTg2MWQ2ZDZjYmM3ODM3Mjg4ODY5MjA0M2ViYmI3MGMzMTBkMQ==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2011-04-04T07:11:51Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2011-04-04T07:11:51Z"}, "message": "sparc.h (PREFERRED_RELOAD_CLASS): Remove.\n\n\t* config/sparc/sparc.h (PREFERRED_RELOAD_CLASS): Remove.\n\t* config/sparc/sparc.c (TARGET_PREFERRED_RELOAD_CLASS): Define.\n\t(sparc_preferred_reload_class): New function.\n\nFrom-SVN: r171925", "tree": {"sha": "b2820903bd47f1712a6ab8b7757fba8b8b4bcfe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2820903bd47f1712a6ab8b7757fba8b8b4bcfe6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/112a861d6d6cbc78372888692043ebbb70c310d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/112a861d6d6cbc78372888692043ebbb70c310d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/112a861d6d6cbc78372888692043ebbb70c310d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/112a861d6d6cbc78372888692043ebbb70c310d1/comments", "author": null, "committer": null, "parents": [{"sha": "e8c6bb74735360c22bdae320caaee5f5db7d6092", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8c6bb74735360c22bdae320caaee5f5db7d6092", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8c6bb74735360c22bdae320caaee5f5db7d6092"}], "stats": {"total": 66, "additions": 38, "deletions": 28}, "files": [{"sha": "02bb52209b51ffe41b8fcd051efe32a6f81fffec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112a861d6d6cbc78372888692043ebbb70c310d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112a861d6d6cbc78372888692043ebbb70c310d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=112a861d6d6cbc78372888692043ebbb70c310d1", "patch": "@@ -1,3 +1,9 @@\n+2011-04-04  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* config/sparc/sparc.h (PREFERRED_RELOAD_CLASS): Remove.\n+\t* config/sparc/sparc.c (TARGET_PREFERRED_RELOAD_CLASS): Define.\n+\t(sparc_preferred_reload_class): New function.\n+\n 2011-04-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/48404"}, {"sha": "30c0d34174dbbcc5583ffe9af0a7c54f3c2a9e33", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112a861d6d6cbc78372888692043ebbb70c310d1/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112a861d6d6cbc78372888692043ebbb70c310d1/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=112a861d6d6cbc78372888692043ebbb70c310d1", "patch": "@@ -465,6 +465,7 @@ static const char *sparc_mangle_type (const_tree);\n #endif\n static void sparc_trampoline_init (rtx, tree, rtx);\n static enum machine_mode sparc_preferred_simd_mode (enum machine_mode);\n+static reg_class_t sparc_preferred_reload_class (rtx x, reg_class_t rclass);\n \f\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n /* Table of valid machine attributes.  */\n@@ -641,6 +642,8 @@ static const struct default_options sparc_option_optimization_table[] =\n \n #undef TARGET_CAN_ELIMINATE\n #define TARGET_CAN_ELIMINATE sparc_can_eliminate\n+#undef  TARGET_PREFERRED_RELOAD_CLASS\n+#define TARGET_PREFERRED_RELOAD_CLASS sparc_preferred_reload_class\n \n #undef TARGET_CONDITIONAL_REGISTER_USAGE\n #define TARGET_CONDITIONAL_REGISTER_USAGE sparc_conditional_register_usage\n@@ -9699,4 +9702,33 @@ sparc_conditional_register_usage (void)\n     fixed_regs[4] = 0;\n }\n \n+/* Implement TARGET_PREFERRED_RELOAD_CLASS\n+\n+   - We can't load constants into FP registers.\n+   - We can't load FP constants into integer registers when soft-float,\n+     because there is no soft-float pattern with a r/F constraint.\n+   - We can't load FP constants into integer registers for TFmode unless\n+     it is 0.0L, because there is no movtf pattern with a r/F constraint.\n+   - Try and reload integer constants (symbolic or otherwise) back into\n+     registers directly, rather than having them dumped to memory.  */\n+\n+static reg_class_t\n+sparc_preferred_reload_class (rtx x, reg_class_t rclass)\n+{\n+  if (CONSTANT_P (x))\n+    {\n+      if (FP_REG_CLASS_P (rclass)\n+\t  || rclass == GENERAL_OR_FP_REGS\n+\t  || rclass == GENERAL_OR_EXTRA_FP_REGS\n+\t  || (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT && ! TARGET_FPU)\n+\t  || (GET_MODE (x) == TFmode && ! const_zero_operand (x, TFmode)))\n+\treturn NO_REGS;\n+\n+      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n+\treturn GENERAL_REGS;\n+    }\n+\n+  return rclass;\n+}\n+\n #include \"gt-sparc.h\""}, {"sha": "87c29fcb84f938597d12b98befeff919355ccaaa", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112a861d6d6cbc78372888692043ebbb70c310d1/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112a861d6d6cbc78372888692043ebbb70c310d1/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=112a861d6d6cbc78372888692043ebbb70c310d1", "patch": "@@ -1104,34 +1104,6 @@ extern char leaf_reg_remap[];\n #define SPARC_SETHI32_P(X) \\\n   (SPARC_SETHI_P ((unsigned HOST_WIDE_INT) (X) & GET_MODE_MASK (SImode)))\n \n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.  */\n-/* - We can't load constants into FP registers.\n-   - We can't load FP constants into integer registers when soft-float,\n-     because there is no soft-float pattern with a r/F constraint.\n-   - We can't load FP constants into integer registers for TFmode unless\n-     it is 0.0L, because there is no movtf pattern with a r/F constraint.\n-   - Try and reload integer constants (symbolic or otherwise) back into\n-     registers directly, rather than having them dumped to memory.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\\\n-  (CONSTANT_P (X)\t\t\t\t\t\\\n-   ? ((FP_REG_CLASS_P (CLASS)\t\t\t\t\\\n-       || (CLASS) == GENERAL_OR_FP_REGS\t\t\t\\\n-       || (CLASS) == GENERAL_OR_EXTRA_FP_REGS\t\t\\\n-       || (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\\\n-\t   && ! TARGET_FPU)\t\t\t\t\\\n-       || (GET_MODE (X) == TFmode\t\t\t\\\n-\t   && ! const_zero_operand (X, TFmode)))\t\\\n-      ? NO_REGS\t\t\t\t\t\t\\\n-      : (!FP_REG_CLASS_P (CLASS)\t\t\t\\\n-         && GET_MODE_CLASS (GET_MODE (X)) == MODE_INT)\t\\\n-      ? GENERAL_REGS\t\t\t\t\t\\\n-      : (CLASS))\t\t\t\t\t\\\n-   : (CLASS))\n-\n /* Return the register class of a scratch register needed to load IN into\n    a register of class CLASS in MODE.\n "}]}