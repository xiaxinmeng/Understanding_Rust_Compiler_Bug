{"sha": "683ccd0568569c67b117e87638782c6d870791b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgzY2NkMDU2ODU2OWM2N2IxMTdlODc2Mzg3ODJjNmQ4NzA3OTFiMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-01-27T19:14:14Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-01-27T19:14:14Z"}, "message": "repinfo.adb (List_Component_Layout): Remove superfluous space for zero-sized field.\n\n\t* repinfo.adb (List_Component_Layout): Remove superfluous space for\n\tzero-sized field.\n\t* gcc-interface/ada-tree.h (TYPE_IS_EXTRA_SUBTYPE_P): New macro.\n\t* gcc-interface/gigi.h (create_extra_subtype): Declare.\n\t* gcc-interface/decl.c (TYPE_ARRAY_SIZE_LIMIT): Likewise.\n\t(update_n_elem): New function.\n\t(gnat_to_gnu_entity): Use create_extra_subtype to create extra subtypes\n\tinstead of doing it manually.\n\t<E_Array_Type>: Use update_n_elem to compute the maximum size.  Use the\n \tindex type instead of base type for the bounds. Set TYPE_ARRAY_MAX_SIZE\n\tof the array to the maximum size.\n\t<E_Array_Subtype>: Create an extra subtype using the index type of the\n\tbase array type for self-referential bounds.  Use update_n_elem to\n\tcompute the maximum size.  Set TYPE_ARRAY_MAX_SIZE of the array to the\n\tmaximum size.\n\t(gnat_to_gnu_field): Clear DECL_NONADDRESSABLE_P on discriminants.\n\t* gcc-interface/misc.c (gnat_get_alias_set): Return the alias set of\n\tthe base type for an extra subtype.\n\t(gnat_type_max_size): Remove obsolete code.\n\t* gcc-interface/trans.c (Attribute_to_gnu): Minor tweak.\n\t(can_be_lower_p): Deal with pathological types.\n\t* gcc-interface/utils.c (create_extra_subtype): New function.\n\t(create_field_decl): Minor tweak.\n\t(max_size) <tcc_reference>: Compute a better value by using the extra\n \tsubtypes on the self-referential bounds.\n\t<tcc_binary>: Rewrite.  Deal with \"negative value\" in unsigned types.\n\t<tcc_expression>: Likewise.\n\t* gcc-interface/utils2.c (compare_arrays): Retrieve the original bounds\n\tof the arrays upfront.  Swap only if the second length is not constant.\n\tUse comparisons on the original bounds consistently for the null tests.\n\t(build_binary_op): Use TYPE_IS_EXTRA_SUBTYPE_P macro.\n\t(build_allocator): Minor tweak.\n\nFrom-SVN: r268318", "tree": {"sha": "d3ad36179e7f2d6037dde651ff566d81ef28ab8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3ad36179e7f2d6037dde651ff566d81ef28ab8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/683ccd0568569c67b117e87638782c6d870791b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683ccd0568569c67b117e87638782c6d870791b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/683ccd0568569c67b117e87638782c6d870791b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683ccd0568569c67b117e87638782c6d870791b2/comments", "author": null, "committer": null, "parents": [{"sha": "33731c666114349344848ddd4218f98ef486398e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33731c666114349344848ddd4218f98ef486398e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33731c666114349344848ddd4218f98ef486398e"}], "stats": {"total": 784, "additions": 419, "deletions": 365}, "files": [{"sha": "123da2f16234ed0fd2d7720f3e12050e447ed2a9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=683ccd0568569c67b117e87638782c6d870791b2", "patch": "@@ -1,3 +1,38 @@\n+2019-01-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* repinfo.adb (List_Component_Layout): Remove superfluous space for\n+\tzero-sized field.\n+\t* gcc-interface/ada-tree.h (TYPE_IS_EXTRA_SUBTYPE_P): New macro.\n+\t* gcc-interface/gigi.h (create_extra_subtype): Declare.\n+\t* gcc-interface/decl.c (TYPE_ARRAY_SIZE_LIMIT): Likewise.\n+\t(update_n_elem): New function.\n+\t(gnat_to_gnu_entity): Use create_extra_subtype to create extra subtypes\n+\tinstead of doing it manually.\n+\t<E_Array_Type>: Use update_n_elem to compute the maximum size.  Use the\n+ \tindex type instead of base type for the bounds. Set TYPE_ARRAY_MAX_SIZE\n+\tof the array to the maximum size.\n+\t<E_Array_Subtype>: Create an extra subtype using the index type of the\n+\tbase array type for self-referential bounds.  Use update_n_elem to\n+\tcompute the maximum size.  Set TYPE_ARRAY_MAX_SIZE of the array to the\n+\tmaximum size.\n+\t(gnat_to_gnu_field): Clear DECL_NONADDRESSABLE_P on discriminants.\n+\t* gcc-interface/misc.c (gnat_get_alias_set): Return the alias set of\n+\tthe base type for an extra subtype.\n+\t(gnat_type_max_size): Remove obsolete code.\n+\t* gcc-interface/trans.c (Attribute_to_gnu): Minor tweak.\n+\t(can_be_lower_p): Deal with pathological types.\n+\t* gcc-interface/utils.c (create_extra_subtype): New function.\n+\t(create_field_decl): Minor tweak.\n+\t(max_size) <tcc_reference>: Compute a better value by using the extra\n+ \tsubtypes on the self-referential bounds.\n+\t<tcc_binary>: Rewrite.  Deal with \"negative value\" in unsigned types.\n+\t<tcc_expression>: Likewise.\n+\t* gcc-interface/utils2.c (compare_arrays): Retrieve the original bounds\n+\tof the arrays upfront.  Swap only if the second length is not constant.\n+\tUse comparisons on the original bounds consistently for the null tests.\n+\t(build_binary_op): Use TYPE_IS_EXTRA_SUBTYPE_P macro.\n+\t(build_allocator): Minor tweak.\n+\n 2019-01-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (array_type_has_nonaliased_component): Return"}, {"sha": "ea2c94559920de67903095f256f11d81be5c0d5a", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=683ccd0568569c67b117e87638782c6d870791b2", "patch": "@@ -111,6 +111,9 @@ do {\t\t\t\t\t\t\t \\\n    front-end.  */\n #define TYPE_EXTRA_SUBTYPE_P(NODE) TYPE_LANG_FLAG_2 (INTEGER_TYPE_CHECK (NODE))\n \n+#define TYPE_IS_EXTRA_SUBTYPE_P(NODE) \\\n+  (TREE_CODE (NODE) == INTEGER_TYPE && TYPE_EXTRA_SUBTYPE_P (NODE))\n+\n /* Nonzero for an aggregate type if this is a by-reference type.  We also\n    set this on an ENUMERAL_TYPE that is dummy.  */\n #define TYPE_BY_REFERENCE_P(NODE)\t\t\t\t       \\"}, {"sha": "ed015baa57f6e9e8830d2bfe2b5c9c9f2bf77df7", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 173, "deletions": 189, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=683ccd0568569c67b117e87638782c6d870791b2", "patch": "@@ -85,6 +85,12 @@\n #define FOREIGN_FORCE_REALIGN_STACK 0\n #endif\n \n+/* The largest TYPE_ARRAY_MAX_SIZE value we set on an array type.\n+   It's an artibrary limit (256 MB) above which we consider that\n+   the allocation is essentially unbounded.  */\n+\n+#define TYPE_ARRAY_SIZE_LIMIT (1 << 28)\n+\n struct incomplete\n {\n   struct incomplete *next;\n@@ -216,6 +222,7 @@ static bool cannot_be_superflat (Node_Id);\n static bool constructor_address_p (tree);\n static bool allocatable_size_p (tree, bool);\n static bool initial_value_needs_conversion (tree, tree);\n+static tree update_n_elem (tree, tree, tree);\n static int compare_field_bitpos (const PTR, const PTR);\n static bool components_to_record (Node_Id, Entity_Id, tree, tree, int, bool,\n \t\t\t\t  bool, bool, bool, bool, bool, bool, tree,\n@@ -1760,12 +1767,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \tif (gnu_high\n \t    && !tree_int_cst_equal (gnu_high, TYPE_MAX_VALUE (gnu_type)))\n \t  {\n-\t    tree gnu_subtype = make_unsigned_type (esize);\n-\t    SET_TYPE_RM_MAX_VALUE (gnu_subtype, gnu_high);\n-\t    TREE_TYPE (gnu_subtype) = gnu_type;\n-\t    TYPE_EXTRA_SUBTYPE_P (gnu_subtype) = 1;\n \t    TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"UMT\");\n-\t    gnu_type = gnu_subtype;\n+\t    gnu_type\n+\t      = create_extra_subtype (gnu_type, TYPE_MIN_VALUE (gnu_type),\n+\t\t\t\t      gnu_high);\n \t  }\n       }\n       goto discrete_type;\n@@ -2052,7 +2057,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \ttree gnu_template_reference, gnu_template_fields, gnu_fat_type;\n \ttree *gnu_index_types = XALLOCAVEC (tree, ndim);\n \ttree *gnu_temp_fields = XALLOCAVEC (tree, ndim);\n-\ttree gnu_max_size = size_one_node, gnu_max_size_unit, tem, t;\n+\ttree gnu_max_size = size_one_node, tem, t;\n \tEntity_Id gnat_index, gnat_name;\n \tint index;\n \ttree comp_type;\n@@ -2165,25 +2170,35 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  {\n \t    char field_name[16];\n \t    tree gnu_index_type = get_unpadded_type (Etype (gnat_index));\n-\t    tree gnu_index_base_type\n-\t      = maybe_character_type (get_base_type (gnu_index_type));\n-\t    tree gnu_lb_field, gnu_hb_field, gnu_orig_min, gnu_orig_max;\n+\t    tree gnu_orig_min = TYPE_MIN_VALUE (gnu_index_type);\n+\t    tree gnu_orig_max = TYPE_MAX_VALUE (gnu_index_type);\n+\t    tree gnu_index_base_type = get_base_type (gnu_index_type);\n+\t    tree gnu_lb_field, gnu_hb_field;\n \t    tree gnu_min, gnu_max, gnu_high;\n \n+\t    /* Update the maximum size of the array in elements.  */\n+\t    if (gnu_max_size)\n+\t      gnu_max_size\n+\t\t= update_n_elem (gnu_max_size, gnu_orig_min, gnu_orig_max);\n+\n+\t    /* Now build the self-referential bounds of the index type.  */\n+\t    gnu_index_type = maybe_character_type (gnu_index_type);\n+\t    gnu_index_base_type = maybe_character_type (gnu_index_base_type);\n+\n \t    /* Make the FIELD_DECLs for the low and high bounds of this\n \t       type and then make extractions of these fields from the\n \t       template.  */\n \t    sprintf (field_name, \"LB%d\", index);\n \t    gnu_lb_field = create_field_decl (get_identifier (field_name),\n-\t\t\t\t\t      gnu_index_base_type,\n+\t\t\t\t\t      gnu_index_type,\n \t\t\t\t\t      gnu_template_type, NULL_TREE,\n \t\t\t\t\t      NULL_TREE, 0, 0);\n \t    Sloc_to_locus (Sloc (gnat_entity),\n \t\t\t   &DECL_SOURCE_LOCATION (gnu_lb_field));\n \n \t    field_name[0] = 'U';\n \t    gnu_hb_field = create_field_decl (get_identifier (field_name),\n-\t\t\t\t\t      gnu_index_base_type,\n+\t\t\t\t\t      gnu_index_type,\n \t\t\t\t\t      gnu_template_type, NULL_TREE,\n \t\t\t\t\t      NULL_TREE, 0, 0);\n \t    Sloc_to_locus (Sloc (gnat_entity),\n@@ -2193,10 +2208,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n \t    /* We can't use build_component_ref here since the template type\n \t       isn't complete yet.  */\n-\t    gnu_orig_min = build3 (COMPONENT_REF, gnu_index_base_type,\n+\t    gnu_orig_min = build3 (COMPONENT_REF, TREE_TYPE (gnu_lb_field),\n \t\t\t\t   gnu_template_reference, gnu_lb_field,\n \t\t\t\t   NULL_TREE);\n-\t    gnu_orig_max = build3 (COMPONENT_REF, gnu_index_base_type,\n+\t    gnu_orig_max = build3 (COMPONENT_REF, TREE_TYPE (gnu_hb_field),\n \t\t\t\t   gnu_template_reference, gnu_hb_field,\n \t\t\t\t   NULL_TREE);\n \t    TREE_READONLY (gnu_orig_min) = TREE_READONLY (gnu_orig_max) = 1;\n@@ -2222,25 +2237,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t\t\t\t      gnu_orig_max),\n \t\t\t\t   gnat_entity);\n \n-\t    /* Update the maximum size of the array in elements.  */\n-\t    if (gnu_max_size)\n-\t      {\n-\t\ttree gnu_min\n-\t\t  = convert (sizetype, TYPE_MIN_VALUE (gnu_index_type));\n-\t\ttree gnu_max\n-\t\t  = convert (sizetype, TYPE_MAX_VALUE (gnu_index_type));\n-\t\ttree gnu_this_max\n-\t\t  = size_binop (PLUS_EXPR, size_one_node,\n-\t\t\t\tsize_binop (MINUS_EXPR, gnu_max, gnu_min));\n-\n-\t\tif (TREE_CODE (gnu_this_max) == INTEGER_CST\n-\t\t    && TREE_OVERFLOW (gnu_this_max))\n-\t\t  gnu_max_size = NULL_TREE;\n-\t\telse\n-\t\t  gnu_max_size\n-\t\t    = size_binop (MULT_EXPR, gnu_max_size, gnu_this_max);\n-\t      }\n-\n \t    TYPE_NAME (gnu_index_types[index])\n \t      = create_concat_name (gnat_entity, field_name);\n \t  }\n@@ -2262,17 +2258,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  Set_Component_Size (gnat_entity,\n                               annotate_value (TYPE_SIZE (comp_type)));\n \n-\t/* Compute the maximum size of the array in units and bits.  */\n+\t/* Compute the maximum size of the array in units.  */\n \tif (gnu_max_size)\n-\t  {\n-\t    gnu_max_size_unit = size_binop (MULT_EXPR, gnu_max_size,\n-\t\t\t\t\t    TYPE_SIZE_UNIT (comp_type));\n-\t    gnu_max_size = size_binop (MULT_EXPR,\n-\t\t\t\t       convert (bitsizetype, gnu_max_size),\n-\t\t\t\t       TYPE_SIZE (comp_type));\n-\t  }\n-\telse\n-\t  gnu_max_size_unit = NULL_TREE;\n+\t  gnu_max_size\n+\t    = size_binop (MULT_EXPR, gnu_max_size, TYPE_SIZE_UNIT (comp_type));\n \n \t/* Now build the array type.  */\n         tem = comp_type;\n@@ -2329,14 +2318,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \tif (gnu_max_size\n \t    && TREE_CODE (gnu_max_size) == INTEGER_CST\n \t    && !TREE_OVERFLOW (gnu_max_size)\n-\t    && TREE_CODE (gnu_max_size_unit) == INTEGER_CST\n-\t    && !TREE_OVERFLOW (gnu_max_size_unit))\n-\t  {\n-\t    TYPE_SIZE (tem) = size_binop (MIN_EXPR, gnu_max_size,\n-\t\t\t\t\t  TYPE_SIZE (tem));\n-\t    TYPE_SIZE_UNIT (tem) = size_binop (MIN_EXPR, gnu_max_size_unit,\n-\t\t\t\t\t       TYPE_SIZE_UNIT (tem));\n-\t  }\n+\t    && compare_tree_int (gnu_max_size, TYPE_ARRAY_SIZE_LIMIT) <= 0)\n+\t  TYPE_ARRAY_MAX_SIZE (tem) = gnu_max_size;\n \n \tcreate_type_decl (create_concat_name (gnat_entity, \"XUA\"), tem,\n \t\t\t  artificial_p, debug_info_p, gnat_entity);\n@@ -2400,7 +2383,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  const int ndim = Number_Dimensions (gnat_entity);\n \t  tree gnu_base_type = gnu_type;\n \t  tree *gnu_index_types = XALLOCAVEC (tree, ndim);\n-\t  tree gnu_max_size = size_one_node, gnu_max_size_unit;\n+\t  tree gnu_max_size = size_one_node;\n \t  bool need_index_type_struct = false;\n \t  int index;\n \n@@ -2416,27 +2399,83 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t       gnat_base_index = Next_Index (gnat_base_index))\n \t    {\n \t      tree gnu_index_type = get_unpadded_type (Etype (gnat_index));\n-\t      tree gnu_index_base_type\n-\t\t= maybe_character_type (get_base_type (gnu_index_type));\n-\t      tree gnu_orig_min\n-\t\t= convert (gnu_index_base_type,\n-\t\t\t   TYPE_MIN_VALUE (gnu_index_type));\n-\t      tree gnu_orig_max\n-\t\t= convert (gnu_index_base_type,\n-\t\t\t   TYPE_MAX_VALUE (gnu_index_type));\n-\t      tree gnu_min = convert (sizetype, gnu_orig_min);\n-\t      tree gnu_max = convert (sizetype, gnu_orig_max);\n+\t      tree gnu_orig_min = TYPE_MIN_VALUE (gnu_index_type);\n+\t      tree gnu_orig_max = TYPE_MAX_VALUE (gnu_index_type);\n+\t      tree gnu_index_base_type = get_base_type (gnu_index_type);\n \t      tree gnu_base_index_type\n \t\t= get_unpadded_type (Etype (gnat_base_index));\n-\t      tree gnu_base_index_base_type\n-\t        = maybe_character_type (get_base_type (gnu_base_index_type));\n-\t      tree gnu_base_orig_min\n-\t\t= convert (gnu_base_index_base_type,\n-\t\t\t   TYPE_MIN_VALUE (gnu_base_index_type));\n-\t      tree gnu_base_orig_max\n-\t        = convert (gnu_base_index_base_type,\n-\t\t\t   TYPE_MAX_VALUE (gnu_base_index_type));\n-\t      tree gnu_high;\n+\t      tree gnu_base_orig_min = TYPE_MIN_VALUE (gnu_base_index_type);\n+\t      tree gnu_base_orig_max = TYPE_MAX_VALUE (gnu_base_index_type);\n+\t      tree gnu_min, gnu_max, gnu_high;\n+\n+\t      /* We try to define subtypes for discriminants used as bounds\n+\t\t that are more restrictive than those declared by using the\n+\t\t bounds of the index type of the base array type.  This will\n+\t\t make it possible to calculate the maximum size of the record\n+\t\t type more conservatively.  This may have already been done by\n+\t\t the front-end (Exp_Ch3.Adjust_Discriminants), in which case\n+\t\t there will be a conversion that needs to be removed first.  */\n+\t      if (CONTAINS_PLACEHOLDER_P (gnu_orig_min)\n+\t\t  && TYPE_RM_SIZE (gnu_base_index_type)\n+\t\t  && !tree_int_cst_lt (TYPE_RM_SIZE (gnu_index_type),\n+\t\t\t\t       TYPE_RM_SIZE (gnu_base_index_type)))\n+\t\t{\n+\t\t  gnu_orig_min = remove_conversions (gnu_orig_min, false);\n+\t\t  TREE_TYPE (gnu_orig_min)\n+\t\t    = create_extra_subtype (TREE_TYPE (gnu_orig_min),\n+\t\t\t\t\t    gnu_base_orig_min,\n+\t\t\t\t\t    gnu_base_orig_max);\n+\t\t}\n+\n+\t      if (CONTAINS_PLACEHOLDER_P (gnu_orig_max)\n+\t\t  && TYPE_RM_SIZE (gnu_base_index_type)\n+\t\t  && !tree_int_cst_lt (TYPE_RM_SIZE (gnu_index_type),\n+\t\t\t\t       TYPE_RM_SIZE (gnu_base_index_type)))\n+\t\t{\n+\t\t  gnu_orig_max = remove_conversions (gnu_orig_max, false);\n+\t\t  TREE_TYPE (gnu_orig_max)\n+\t\t    = create_extra_subtype (TREE_TYPE (gnu_orig_max),\n+\t\t\t\t\t    gnu_base_orig_min,\n+\t\t\t\t\t    gnu_base_orig_max);\n+\t\t}\n+\n+\t      /* Update the maximum size of the array in elements.  Here we\n+\t\t see if any constraint on the index type of the base type\n+\t\t can be used in the case of self-referential bounds on the\n+\t\t index type of the array type. We look for a non-\"infinite\"\n+\t\t and non-self-referential bound from any type involved and\n+\t\t handle each bound separately.  */\n+\t      if (gnu_max_size)\n+\t\t{\n+\t\t  if (CONTAINS_PLACEHOLDER_P (gnu_orig_min))\n+\t\t    gnu_min = gnu_base_orig_min;\n+\t\t  else\n+\t\t    gnu_min = gnu_orig_min;\n+\n+\t\t  if (TREE_CODE (gnu_min) != INTEGER_CST\n+\t\t      || TREE_OVERFLOW (gnu_min))\n+\t\t    gnu_min = TYPE_MIN_VALUE (TREE_TYPE (gnu_min));\n+\n+\t\t  if (CONTAINS_PLACEHOLDER_P (gnu_orig_max))\n+\t\t    gnu_max = gnu_base_orig_max;\n+\t\t  else\n+\t\t    gnu_max = gnu_orig_max;\n+\n+\t\t  if (TREE_CODE (gnu_max) != INTEGER_CST\n+\t\t      || TREE_OVERFLOW (gnu_max))\n+\t\t    gnu_max = TYPE_MAX_VALUE (TREE_TYPE (gnu_max));\n+\n+\t\t  gnu_max_size\n+\t\t    = update_n_elem (gnu_max_size, gnu_min, gnu_max);\n+\t\t}\n+\n+\t      /* Convert the bounds to the base type for consistency below.  */\n+\t      gnu_index_base_type = maybe_character_type (gnu_index_base_type);\n+\t      gnu_orig_min = convert (gnu_index_base_type, gnu_orig_min);\n+\t      gnu_orig_max = convert (gnu_index_base_type, gnu_orig_max);\n+\n+\t      gnu_min = convert (sizetype, gnu_orig_min);\n+\t      gnu_max = convert (sizetype, gnu_orig_max);\n \n \t      /* See if the base array type is already flat.  If it is, we\n \t\t are probably compiling an ACATS test but it will cause the\n@@ -2470,7 +2509,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t       && TREE_OVERFLOW (gnu_min) && TREE_OVERFLOW (gnu_max)\n \t\t       && !TREE_OVERFLOW\n \t\t\t   (convert (sizetype,\n-\t\t\t\t     fold_build2 (MINUS_EXPR, gnu_index_type,\n+\t\t\t\t     fold_build2 (MINUS_EXPR,\n+\t\t\t\t\t\t  gnu_index_base_type,\n \t\t\t\t\t\t  gnu_orig_max,\n \t\t\t\t\t\t  gnu_orig_min))))\n \t\t{\n@@ -2512,12 +2552,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t}\n \n \t      /* Finally we use (hb >= lb) ? hb : lb - 1 for the upper bound\n-\t\t in all the other cases.  Note that, here as well as above,\n-\t\t the condition used in the comparison must be equivalent to\n-\t\t the condition (length != 0).  This is relied upon in order\n-\t\t to optimize array comparisons in compare_arrays.  Moreover\n-\t\t we use int_const_binop for the shift by 1 if the bound is\n-\t\t constant to avoid any unwanted overflow.  */\n+\t\t in all the other cases.  Note that we use int_const_binop for\n+\t\t the shift by 1 if the bound is constant to avoid any unwanted\n+\t\t overflow.  */\n \t      else\n \t\tgnu_high\n \t\t  = build_cond_expr (sizetype,\n@@ -2538,65 +2575,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t= create_index_type (gnu_min, gnu_high, gnu_index_type,\n \t\t\t\t     gnat_entity);\n \n-\t      /* Update the maximum size of the array in elements.  Here we\n-\t\t see if any constraint on the index type of the base type\n-\t\t can be used in the case of self-referential bound on the\n-\t\t index type of the subtype.  We look for a non-\"infinite\"\n-\t\t and non-self-referential bound from any type involved and\n-\t\t handle each bound separately.  */\n-\t      if (gnu_max_size)\n-\t\t{\n-\t\t  tree gnu_base_min = convert (sizetype, gnu_base_orig_min);\n-\t\t  tree gnu_base_max = convert (sizetype, gnu_base_orig_max);\n-\t\t  tree gnu_base_base_min\n-\t\t    = convert (sizetype,\n-\t\t\t       TYPE_MIN_VALUE (gnu_base_index_base_type));\n-\t\t  tree gnu_base_base_max\n-\t\t    = convert (sizetype,\n-\t\t\t       TYPE_MAX_VALUE (gnu_base_index_base_type));\n-\n-\t\t  if (!CONTAINS_PLACEHOLDER_P (gnu_min)\n-\t\t      || !(TREE_CODE (gnu_base_min) == INTEGER_CST\n-\t\t\t   && !TREE_OVERFLOW (gnu_base_min)))\n-\t\t    gnu_base_min = gnu_min;\n-\n-\t\t  if (!CONTAINS_PLACEHOLDER_P (gnu_max)\n-\t\t      || !(TREE_CODE (gnu_base_max) == INTEGER_CST\n-\t\t\t   && !TREE_OVERFLOW (gnu_base_max)))\n-\t\t    gnu_base_max = gnu_max;\n-\n-\t\t  if ((TREE_CODE (gnu_base_min) == INTEGER_CST\n-\t\t       && TREE_OVERFLOW (gnu_base_min))\n-\t\t      || operand_equal_p (gnu_base_min, gnu_base_base_min, 0)\n-\t\t      || (TREE_CODE (gnu_base_max) == INTEGER_CST\n-\t\t\t  && TREE_OVERFLOW (gnu_base_max))\n-\t\t      || operand_equal_p (gnu_base_max, gnu_base_base_max, 0))\n-\t\t    gnu_max_size = NULL_TREE;\n-\t\t  else\n-\t\t    {\n-\t\t      tree gnu_this_max;\n-\n-\t\t      /* Use int_const_binop if the bounds are constant to\n-\t\t\t avoid any unwanted overflow.  */\n-\t\t      if (TREE_CODE (gnu_base_min) == INTEGER_CST\n-\t\t\t  && TREE_CODE (gnu_base_max) == INTEGER_CST)\n-\t\t\tgnu_this_max\n-\t\t\t  = int_const_binop (PLUS_EXPR, size_one_node,\n-\t\t\t\t\t     int_const_binop (MINUS_EXPR,\n-\t\t\t\t\t\t\t      gnu_base_max,\n-\t\t\t\t\t\t\t      gnu_base_min));\n-\t\t      else\n-\t\t\tgnu_this_max\n-\t\t\t  = size_binop (PLUS_EXPR, size_one_node,\n-\t\t\t\t\tsize_binop (MINUS_EXPR,\n-\t\t\t\t\t\t    gnu_base_max,\n-\t\t\t\t\t\t    gnu_base_min));\n-\n-\t\t      gnu_max_size\n-\t\t\t= size_binop (MULT_EXPR, gnu_max_size, gnu_this_max);\n-\t\t    }\n-\t\t}\n-\n \t      /* We need special types for debugging information to point to\n \t\t the index types if they have variable bounds, are not integer\n \t\t types, are biased or are wider than sizetype.  These are GNAT\n@@ -2646,17 +2624,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t}\n \t    }\n \n-\t  /* Compute the maximum size of the array in units and bits.  */\n+\t  /* Compute the maximum size of the array in units.  */\n \t  if (gnu_max_size)\n-\t    {\n-\t      gnu_max_size_unit = size_binop (MULT_EXPR, gnu_max_size,\n-\t\t\t\t\t      TYPE_SIZE_UNIT (gnu_type));\n-\t      gnu_max_size = size_binop (MULT_EXPR,\n-\t\t\t\t\t convert (bitsizetype, gnu_max_size),\n-\t\t\t\t\t TYPE_SIZE (gnu_type));\n-\t    }\n-\t  else\n-\t    gnu_max_size_unit = NULL_TREE;\n+\t    gnu_max_size\n+\t      = size_binop (MULT_EXPR, gnu_max_size, TYPE_SIZE_UNIT (gnu_type));\n \n \t  /* Now build the array type.  */\n \t  for (index = ndim - 1; index >= 0; index --)\n@@ -2776,21 +2747,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    = (Is_Packed (gnat_entity)\n \t       || Is_Packed_Array_Impl_Type (gnat_entity));\n \n-\t  /* If the size is self-referential and the maximum size doesn't\n-\t     overflow, use it.  */\n-\t  if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type))\n-\t      && gnu_max_size\n-\t      && !(TREE_CODE (gnu_max_size) == INTEGER_CST\n-\t\t   && TREE_OVERFLOW (gnu_max_size))\n-\t      && !(TREE_CODE (gnu_max_size_unit) == INTEGER_CST\n-\t\t   && TREE_OVERFLOW (gnu_max_size_unit)))\n-\t    {\n-\t      TYPE_SIZE (gnu_type) = size_binop (MIN_EXPR, gnu_max_size,\n-\t\t\t\t\t\t TYPE_SIZE (gnu_type));\n-\t      TYPE_SIZE_UNIT (gnu_type)\n-\t\t= size_binop (MIN_EXPR, gnu_max_size_unit,\n-\t\t\t      TYPE_SIZE_UNIT (gnu_type));\n-\t    }\n+\t  /* If the maximum size doesn't overflow, use it.  */\n+\t  if (gnu_max_size\n+\t      && TREE_CODE (gnu_max_size) == INTEGER_CST\n+\t      && !TREE_OVERFLOW (gnu_max_size)\n+\t      && compare_tree_int (gnu_max_size, TYPE_ARRAY_SIZE_LIMIT) <= 0)\n+\t    TYPE_ARRAY_MAX_SIZE (gnu_type) = gnu_max_size;\n \n \t  /* Set our alias set to that of our base type.  This gives all\n \t     array subtypes the same alias set.  */\n@@ -2850,17 +2812,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t TYPE_MODULUS for modular types so we make an extra\n \t\t\t subtype if necessary.  */\n \t\t      if (TYPE_MODULAR_P (gnu_inner))\n-\t\t\t{\n-\t\t\t  tree gnu_subtype\n-\t\t\t    = make_unsigned_type (TYPE_PRECISION (gnu_inner));\n-\t\t\t  TREE_TYPE (gnu_subtype) = gnu_inner;\n-\t\t\t  TYPE_EXTRA_SUBTYPE_P (gnu_subtype) = 1;\n-\t\t\t  SET_TYPE_RM_MIN_VALUE (gnu_subtype,\n-\t\t\t\t\t\t TYPE_MIN_VALUE (gnu_inner));\n-\t\t\t  SET_TYPE_RM_MAX_VALUE (gnu_subtype,\n-\t\t\t\t\t\t TYPE_MAX_VALUE (gnu_inner));\n-\t\t\t  gnu_inner = gnu_subtype;\n-\t\t\t}\n+\t\t\tgnu_inner\n+\t\t\t  = create_extra_subtype (gnu_inner,\n+\t\t\t\t\t\t  TYPE_MIN_VALUE (gnu_inner),\n+\t\t\t\t\t\t  TYPE_MAX_VALUE (gnu_inner));\n \n \t\t      TYPE_HAS_ACTUAL_BOUNDS_P (gnu_inner) = 1;\n \n@@ -3259,7 +3214,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t&& !Is_Access_Type (Etype (Node (gnat_constr)))\n \t\t&& Ekind (Entity (Node (gnat_constr))) == E_Discriminant)\n \t      {\n-\t\tEntity_Id gnat_discr = Entity (Node (gnat_constr));\n+\t\tconst Entity_Id gnat_discr = Entity (Node (gnat_constr));\n \t\ttree gnu_discr_type = gnat_to_gnu_type (Etype (gnat_discr));\n \t\ttree gnu_ref\n \t\t  = gnat_to_gnu_entity (Original_Record_Component (gnat_discr),\n@@ -3270,20 +3225,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\tgcc_assert (TREE_TYPE (TREE_OPERAND (gnu_ref, 0)) == gnu_type);\n \n \t\tif (gnu_discr_type != TREE_TYPE (gnu_ref))\n-\t\t  {\n-\t\t    const unsigned prec = TYPE_PRECISION (TREE_TYPE (gnu_ref));\n-\t\t    tree gnu_subtype\n-\t\t      = TYPE_UNSIGNED (TREE_TYPE (gnu_ref))\n-\t\t        ? make_unsigned_type (prec) : make_signed_type (prec);\n-\t\t    TREE_TYPE (gnu_subtype) = TREE_TYPE (gnu_ref);\n-\t\t    TYPE_EXTRA_SUBTYPE_P (gnu_subtype) = 1;\n-\t\t    SET_TYPE_RM_MIN_VALUE (gnu_subtype,\n-\t\t\t\t\t   TYPE_MIN_VALUE (gnu_discr_type));\n-\t\t    SET_TYPE_RM_MAX_VALUE (gnu_subtype,\n-\t\t\t\t\t   TYPE_MAX_VALUE (gnu_discr_type));\n-\t\t    TREE_TYPE (gnu_ref)\n-\t\t      = TREE_TYPE (TREE_OPERAND (gnu_ref, 1)) = gnu_subtype;\n-\t\t  }\n+\t\t  TREE_TYPE (gnu_ref)\n+\t\t    = create_extra_subtype (TREE_TYPE (gnu_ref),\n+\t\t\t\t\t    TYPE_MIN_VALUE (gnu_discr_type),\n+\t\t\t\t\t    TYPE_MAX_VALUE (gnu_discr_type));\n \t      }\n \n \t/* If this is a derived type with discriminants and these discriminants\n@@ -6399,6 +6344,37 @@ initial_value_needs_conversion (tree gnu_type, tree gnu_expr)\n   /* In all the other cases, convert the expression to the object's type.  */\n   return true;\n }\n+\n+/* Add the contribution of [MIN, MAX] to the current number of elements N_ELEM\n+   of an array type and return the result, or NULL_TREE if it overflowed.  */\n+\n+static tree\n+update_n_elem (tree n_elem, tree min, tree max)\n+{\n+  /* First deal with the empty case.  */\n+  if (TREE_CODE (min) == INTEGER_CST\n+      && TREE_CODE (max) == INTEGER_CST\n+      && tree_int_cst_lt (max, min))\n+    return size_zero_node;\n+\n+  min = convert (sizetype, min);\n+  max = convert (sizetype, max);\n+\n+  /* Compute the number of elements in this dimension.  */\n+  tree this_n_elem\n+    = size_binop (PLUS_EXPR, size_one_node, size_binop (MINUS_EXPR, max, min));\n+\n+  if (TREE_CODE (this_n_elem) == INTEGER_CST && TREE_OVERFLOW (this_n_elem))\n+    return NULL_TREE;\n+\n+  /* Multiply the current number of elements by the result.  */\n+  n_elem = size_binop (MULT_EXPR, n_elem, this_n_elem);\n+\n+  if (TREE_CODE (n_elem) == INTEGER_CST && TREE_OVERFLOW (n_elem))\n+    return NULL_TREE;\n+\n+  return n_elem;\n+}\n \f\n /* Given GNAT_ENTITY, elaborate all expressions that are required to\n    be elaborated at the point of its definition, but do nothing else.  */\n@@ -7222,12 +7198,20 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   DECL_ALIASED_P (gnu_field) = is_aliased;\n   TREE_SIDE_EFFECTS (gnu_field) = TREE_THIS_VOLATILE (gnu_field) = is_volatile;\n \n+  /* If this is a discriminant, then we treat it specially: first, we set its\n+     index number for the back-annotation; second, we record whether it cannot\n+     be changed once it has been set for the computation of loop invariants;\n+     third, we make it addressable in order for the optimizer to more easily\n+     see that it cannot be modified by assignments to the other fields of the\n+     record (see create_field_decl for a more detailed explanation), which is\n+     crucial to hoist the offset and size computations of dynamic fields.  */\n   if (Ekind (gnat_field) == E_Discriminant)\n     {\n-      DECL_INVARIANT_P (gnu_field)\n-\t= No (Discriminant_Default_Value (gnat_field));\n       DECL_DISCRIMINANT_NUMBER (gnu_field)\n \t= UI_To_gnu (Discriminant_Number (gnat_field), sizetype);\n+      DECL_INVARIANT_P (gnu_field)\n+\t= No (Discriminant_Default_Value (gnat_field));\n+      DECL_NONADDRESSABLE_P (gnu_field) = 0;\n     }\n \n   return gnu_field;"}, {"sha": "191a017f6068e35714d93335c5404118e5d3271d", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=683ccd0568569c67b117e87638782c6d870791b2", "patch": "@@ -637,6 +637,9 @@ extern tree create_index_type (tree min, tree max, tree index,\n    sizetype is used.  */\n extern tree create_range_type (tree type, tree min, tree max);\n \n+/* Return an extra subtype of TYPE with range MIN to MAX.  */\n+extern tree create_extra_subtype (tree type, tree min, tree max);\n+\n /* Return a TYPE_DECL node suitable for the TYPE_STUB_DECL field of TYPE.\n    NAME gives the name of the type to be used in the declaration.  */\n extern tree create_type_stub_decl (tree name, tree type);"}, {"sha": "38e33beea70005b34057ec7ad5dfa903df3c17a1", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 19, "deletions": 52, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=683ccd0568569c67b117e87638782c6d870791b2", "patch": "@@ -727,6 +727,10 @@ gnat_get_alias_set (tree type)\n   if (TYPE_IS_PADDING_P (type))\n     return get_alias_set (TREE_TYPE (TYPE_FIELDS (type)));\n \n+  /* If this is an extra subtype, use the base type.  */\n+  else if (TYPE_IS_EXTRA_SUBTYPE_P (type))\n+    return get_alias_set (get_base_type (type));\n+\n   /* If the type is an unconstrained array, use the type of the\n      self-referential array we make.  */\n   else if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n@@ -753,59 +757,22 @@ gnat_type_max_size (const_tree gnu_type)\n      elaborated and possibly replaced by a VAR_DECL.  */\n   tree max_size_unit = max_size (TYPE_SIZE_UNIT (gnu_type), true);\n \n-  /* If we don't have a constant, try to look at attributes which should have\n-     stayed untouched.  */\n-  if (!tree_fits_uhwi_p (max_size_unit))\n+  /* If we don't have a constant, see what we can get from TYPE_ADA_SIZE,\n+     which should stay untouched.  */\n+  if (!tree_fits_uhwi_p (max_size_unit)\n+      && RECORD_OR_UNION_TYPE_P (gnu_type)\n+      && !TYPE_FAT_POINTER_P (gnu_type)\n+      && TYPE_ADA_SIZE (gnu_type))\n     {\n-      /* For record types, see what we can get from TYPE_ADA_SIZE.  */\n-      if (RECORD_OR_UNION_TYPE_P (gnu_type)\n-\t  && !TYPE_FAT_POINTER_P (gnu_type)\n-\t  && TYPE_ADA_SIZE (gnu_type))\n-\t{\n-\t  tree max_ada_size = max_size (TYPE_ADA_SIZE (gnu_type), true);\n-\n-\t  /* If we have succeeded in finding a constant, round it up to the\n-\t     type's alignment and return the result in units.  */\n-\t  if (tree_fits_uhwi_p (max_ada_size))\n-\t    max_size_unit\n-\t      = size_binop (CEIL_DIV_EXPR,\n-\t\t\t    round_up (max_ada_size, TYPE_ALIGN (gnu_type)),\n-\t\t\t    bitsize_unit_node);\n-\t}\n-\n-      /* For array types, see what we can get from TYPE_INDEX_TYPE.  */\n-      else if (TREE_CODE (gnu_type) == ARRAY_TYPE\n-\t       && TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type))\n-\t       && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (gnu_type))))\n-\t{\n-\t  tree lb = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type)));\n-\t  tree hb = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type)));\n-\t  if (TREE_CODE (lb) != INTEGER_CST\n-\t      && TYPE_RM_SIZE (TREE_TYPE (lb))\n-\t      && compare_tree_int (TYPE_RM_SIZE (TREE_TYPE (lb)), 16) <= 0)\n-\t    lb = TYPE_MIN_VALUE (TREE_TYPE (lb));\n-\t  if (TREE_CODE (hb) != INTEGER_CST\n-\t      && TYPE_RM_SIZE (TREE_TYPE (hb))\n-\t      && compare_tree_int (TYPE_RM_SIZE (TREE_TYPE (hb)), 16) <= 0)\n-\t    hb = TYPE_MAX_VALUE (TREE_TYPE (hb));\n-\t  if (TREE_CODE (lb) == INTEGER_CST && TREE_CODE (hb) == INTEGER_CST)\n-\t    {\n-\t      tree ctype = get_base_type (TREE_TYPE (lb));\n-\t      lb = fold_convert (ctype, lb);\n-\t      hb = fold_convert (ctype, hb);\n-\t      if (tree_int_cst_le (lb, hb))\n-\t\t{\n-\t\t  tree length\n-\t\t    = fold_build2 (PLUS_EXPR, ctype,\n-\t\t\t\t   fold_build2 (MINUS_EXPR, ctype, hb, lb),\n-\t\t\t\t   build_int_cst (ctype, 1));\n-\t\t  max_size_unit\n-\t\t    = fold_build2 (MULT_EXPR, sizetype,\n-\t\t\t\t   fold_convert (sizetype, length),\n-\t\t\t\t   TYPE_SIZE_UNIT (TREE_TYPE (gnu_type)));\n-\t\t}\n-\t    }\n-\t}\n+      tree max_ada_size = max_size (TYPE_ADA_SIZE (gnu_type), true);\n+\n+      /* If we have succeeded in finding a constant, round it up to the\n+\t type's alignment and return the result in units.  */\n+      if (tree_fits_uhwi_p (max_ada_size))\n+\tmax_size_unit\n+\t  = size_binop (CEIL_DIV_EXPR,\n+\t\t\tround_up (max_ada_size, TYPE_ALIGN (gnu_type)),\n+\t\t\tbitsize_unit_node);\n     }\n \n   return max_size_unit;"}, {"sha": "3b0093e12292b63e475b1d321f20a3fc772f21fb", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=683ccd0568569c67b117e87638782c6d870791b2", "patch": "@@ -2374,15 +2374,12 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       else\n \tgnu_result = rm_size (gnu_type);\n \n-      /* Deal with a self-referential size by returning the maximum size for\n-\t a type and by qualifying the size with the object otherwise.  */\n-      if (CONTAINS_PLACEHOLDER_P (gnu_result))\n-\t{\n-\t  if (TREE_CODE (gnu_prefix) == TYPE_DECL)\n-\t    gnu_result = max_size (gnu_result, true);\n-\t  else\n-\t    gnu_result = substitute_placeholder_in_expr (gnu_result, gnu_expr);\n-\t}\n+      /* Deal with a self-referential size by qualifying the size with the\n+\t object or returning the maximum size for a type.  */\n+      if (TREE_CODE (gnu_prefix) != TYPE_DECL)\n+\tgnu_result = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_result, gnu_expr);\n+      else if (CONTAINS_PLACEHOLDER_P (gnu_result))\n+\tgnu_result = max_size (gnu_result, true);\n \n       /* If the type contains a template, subtract the padded size of the\n \t template, except for 'Max_Size_In_Storage_Elements because we need\n@@ -3227,13 +3224,25 @@ static bool\n can_be_lower_p (tree val1, tree val2)\n {\n   if (TREE_CODE (val1) == NOP_EXPR)\n-    val1 = TYPE_MIN_VALUE (TREE_TYPE (TREE_OPERAND (val1, 0)));\n+    {\n+      tree type = TREE_TYPE (TREE_OPERAND (val1, 0));\n+      if (can_be_lower_p (TYPE_MAX_VALUE (type), TYPE_MIN_VALUE (type)))\n+\treturn true;\n+\n+      val1 = TYPE_MIN_VALUE (type);\n+    }\n \n   if (TREE_CODE (val1) != INTEGER_CST)\n     return true;\n \n   if (TREE_CODE (val2) == NOP_EXPR)\n-    val2 = TYPE_MAX_VALUE (TREE_TYPE (TREE_OPERAND (val2, 0)));\n+    {\n+      tree type = TREE_TYPE (TREE_OPERAND (val2, 0));\n+      if (can_be_lower_p (TYPE_MAX_VALUE (type), TYPE_MIN_VALUE (type)))\n+\treturn true;\n+\n+      val2 = TYPE_MAX_VALUE (type);\n+    }\n \n   if (TREE_CODE (val2) != INTEGER_CST)\n     return true;"}, {"sha": "2ff664ba04e3bfae611b6aa19d86ff52e8c95215", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 114, "deletions": 50, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=683ccd0568569c67b117e87638782c6d870791b2", "patch": "@@ -2260,7 +2260,7 @@ merge_sizes (tree last_size, tree first_bit, tree size, bool special,\n \t\t\t\t\t\t       1, has_rep));\n \n   /* We don't need any NON_VALUE_EXPRs and they can confuse us (especially\n-     when fed through substitute_in_expr) into thinking that a constant\n+     when fed through SUBSTITUTE_IN_EXPR) into thinking that a constant\n      size is not constant.  */\n   while (TREE_CODE (new_size) == NON_LVALUE_EXPR)\n     new_size = TREE_OPERAND (new_size, 0);\n@@ -2429,6 +2429,24 @@ create_range_type (tree type, tree min, tree max)\n   return range_type;\n }\n \f\n+\f/* Return an extra subtype of TYPE with range MIN to MAX.  */\n+\n+tree\n+create_extra_subtype (tree type, tree min, tree max)\n+{\n+  const bool uns = TYPE_UNSIGNED (type);\n+  const unsigned prec = TYPE_PRECISION (type);\n+  tree subtype = uns ? make_unsigned_type (prec) : make_signed_type (prec);\n+\n+  TREE_TYPE (subtype) = type;\n+  TYPE_EXTRA_SUBTYPE_P (subtype) = 1;\n+\n+  SET_TYPE_RM_MIN_VALUE (subtype, min);\n+  SET_TYPE_RM_MAX_VALUE (subtype, max);\n+\n+  return subtype;\n+}\n+\f\n /* Return a TYPE_DECL node suitable for the TYPE_STUB_DECL field of TYPE.\n    NAME gives the name of the type to be used in the declaration.  */\n \n@@ -2811,8 +2829,8 @@ create_field_decl (tree name, tree type, tree record_type, tree size, tree pos,\n \n       layout_decl (field_decl, known_align);\n       SET_DECL_OFFSET_ALIGN (field_decl,\n-\t\t\t     tree_fits_uhwi_p (pos) ? BIGGEST_ALIGNMENT\n-\t\t\t     : BITS_PER_UNIT);\n+\t\t\t     tree_fits_uhwi_p (pos)\n+\t\t\t     ? BIGGEST_ALIGNMENT : BITS_PER_UNIT);\n       pos_from_bit (&DECL_FIELD_OFFSET (field_decl),\n \t\t    &DECL_FIELD_BIT_OFFSET (field_decl),\n \t\t    DECL_OFFSET_ALIGN (field_decl), pos);\n@@ -2829,6 +2847,15 @@ create_field_decl (tree name, tree type, tree record_type, tree size, tree pos,\n   if (!addressable && !type_for_nonaliased_component_p (type))\n     addressable = 1;\n \n+  /* Note that there is a trade-off in making a field nonaddressable because\n+     this will cause type-based alias analysis to use the same alias set for\n+     accesses to the field as for accesses to the whole record: while doing\n+     so will make it more likely to disambiguate accesses to other objects\n+     and accesses to the field, it will make it less likely to disambiguate\n+     accesses to the other fields of the record and accesses to the field.\n+     If the record is fully static, then the trade-off is irrelevant since\n+     the fields of the record can always be disambiguated by their offsets\n+     but, if the record is dynamic, then it can become problematic.  */\n   DECL_NONADDRESSABLE_P (field_decl) = !addressable;\n \n   return field_decl;\n@@ -3658,11 +3685,27 @@ max_size (tree exp, bool max_p)\n \t modify.  Otherwise, we treat it like a variable.  */\n       if (CONTAINS_PLACEHOLDER_P (exp))\n \t{\n-\t  tree val_type = TREE_TYPE (TREE_OPERAND (exp, 1));\n-\t  tree val = (max_p ? TYPE_MAX_VALUE (type) : TYPE_MIN_VALUE (type));\n-\t  return\n-\t    convert (type,\n-\t\t     max_size (convert (get_base_type (val_type), val), true));\n+\t  tree base_type = get_base_type (TREE_TYPE (TREE_OPERAND (exp, 1)));\n+\t  tree val\n+\t    = fold_convert (base_type,\n+\t\t\t    max_p\n+\t\t\t    ? TYPE_MAX_VALUE (type) : TYPE_MIN_VALUE (type));\n+\n+\t  /* Walk down the extra subtypes to get more restrictive bounds.  */\n+\t  while (TYPE_IS_EXTRA_SUBTYPE_P (type))\n+\t    {\n+\t      type = TREE_TYPE (type);\n+\t      if (max_p)\n+\t\tval = fold_build2 (MIN_EXPR, base_type, val,\n+\t\t\t\t   fold_convert (base_type,\n+\t\t\t\t\t\t TYPE_MAX_VALUE (type)));\n+\t      else\n+\t\tval = fold_build2 (MAX_EXPR, base_type, val,\n+\t\t\t\t   fold_convert (base_type,\n+\t\t\t\t\t\t TYPE_MIN_VALUE (type)));\n+\t    }\n+\n+\t  return fold_convert (type, max_size (val, max_p));\n \t}\n \n       return exp;\n@@ -3683,49 +3726,57 @@ max_size (tree exp, bool max_p)\n       return fold_build1 (code, type, op0);\n \n     case tcc_binary:\n-      {\n-\ttree lhs = max_size (TREE_OPERAND (exp, 0), max_p);\n-\ttree rhs = max_size (TREE_OPERAND (exp, 1),\n-\t\t\t     code == MINUS_EXPR ? !max_p : max_p);\n+      op0 = TREE_OPERAND (exp, 0);\n+      op1 = TREE_OPERAND (exp, 1);\n+\n+      /* If we have a multiply-add with a \"negative\" value in an unsigned\n+\t type, do a multiply-subtract with the negated value, in order to\n+\t avoid creating a spurious overflow below.  */\n+      if (code == PLUS_EXPR\n+\t  && TREE_CODE (op0) == MULT_EXPR\n+\t  && TYPE_UNSIGNED (type)\n+\t  && TREE_CODE (TREE_OPERAND (op0, 1)) == INTEGER_CST\n+\t  && !TREE_OVERFLOW (TREE_OPERAND (op0, 1))\n+\t  && tree_int_cst_sign_bit (TREE_OPERAND (op0, 1)))\n+\t{\n+\t  tree tmp = op1;\n+\t  op1 = build2 (MULT_EXPR, type, TREE_OPERAND (op0, 0),\n+\t\t\tfold_build1 (NEGATE_EXPR, type,\n+\t\t\t\t    TREE_OPERAND (op0, 1)));\n+\t  op0 = tmp;\n+\t  code = MINUS_EXPR;\n+\t}\n \n-\t/* Special-case wanting the maximum value of a MIN_EXPR.\n-\t   In that case, if one side overflows, return the other.  */\n-\tif (max_p && code == MIN_EXPR)\n-\t  {\n-\t    if (TREE_CODE (rhs) == INTEGER_CST && TREE_OVERFLOW (rhs))\n-\t      return lhs;\n+      op0 = max_size (op0, max_p);\n+      op1 = max_size (op1, code == MINUS_EXPR ? !max_p : max_p);\n \n-\t    if (TREE_CODE (lhs) == INTEGER_CST && TREE_OVERFLOW (lhs))\n-\t      return rhs;\n-\t  }\n-\n-\t/* Likewise, handle a MINUS_EXPR or PLUS_EXPR with the LHS\n-\t   overflowing and the RHS a variable.  */\n-\tif ((code == MINUS_EXPR || code == PLUS_EXPR)\n-\t    && TREE_CODE (lhs) == INTEGER_CST\n-\t    && TREE_OVERFLOW (lhs)\n-\t    && TREE_CODE (rhs) != INTEGER_CST)\n-\t  return lhs;\n-\n-\t/* If we are going to subtract a \"negative\" value in an unsigned type,\n-\t   do the operation as an addition of the negated value, in order to\n-\t   avoid creating a spurious overflow below.  */\n-\tif (code == MINUS_EXPR\n-\t    && TYPE_UNSIGNED (type)\n-\t    && TREE_CODE (rhs) == INTEGER_CST\n-\t    && !TREE_OVERFLOW (rhs)\n-\t    && tree_int_cst_sign_bit (rhs) != 0)\n-\t  {\n-\t    rhs = fold_build1 (NEGATE_EXPR, type, rhs);\n-\t    code = PLUS_EXPR;\n-\t  }\n+      if ((code == MINUS_EXPR || code == PLUS_EXPR))\n+\t{\n+\t  /* If the op0 has overflowed and the op1 is a variable,\n+\t     propagate the overflow by returning the op0.  */\n+\t  if (TREE_CODE (op0) == INTEGER_CST\n+\t      && TREE_OVERFLOW (op0)\n+\t      && TREE_CODE (op1) != INTEGER_CST)\n+\t    return op0;\n+\n+\t  /* If we have a \"negative\" value in an unsigned type, do the\n+\t     opposite operation on the negated value, in order to avoid\n+\t     creating a spurious overflow below.  */\n+\t  if (TYPE_UNSIGNED (type)\n+\t      && TREE_CODE (op1) == INTEGER_CST\n+\t      && !TREE_OVERFLOW (op1)\n+\t      && tree_int_cst_sign_bit (op1))\n+\t    {\n+\t      op1 = fold_build1 (NEGATE_EXPR, type, op1);\n+\t      code = (code == MINUS_EXPR ? PLUS_EXPR : MINUS_EXPR);\n+\t    }\n+\t}\n \n-\tif (lhs == TREE_OPERAND (exp, 0) && rhs == TREE_OPERAND (exp, 1))\n-\t  return exp;\n+      if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n+\treturn exp;\n \n-\t/* We need to detect overflows so we call size_binop here.  */\n-\treturn size_binop (code, lhs, rhs);\n-      }\n+      /* We need to detect overflows so we call size_binop here.  */\n+      return size_binop (code, op0, op1);\n \n     case tcc_expression:\n       switch (TREE_CODE_LENGTH (code))\n@@ -3757,15 +3808,28 @@ max_size (tree exp, bool max_p)\n \tcase 3:\n \t  if (code == COND_EXPR)\n \t    {\n+\t      op0 = TREE_OPERAND (exp, 0);\n \t      op1 = TREE_OPERAND (exp, 1);\n \t      op2 = TREE_OPERAND (exp, 2);\n \n \t      if (!op1 || !op2)\n \t\treturn exp;\n \n-\t      return\n-\t\tfold_build2 (max_p ? MAX_EXPR : MIN_EXPR, type,\n-\t\t\t     max_size (op1, max_p), max_size (op2, max_p));\n+\t      op1 = max_size (op1, max_p);\n+\t      op2 = max_size (op2, max_p);\n+\n+\t      /* If we have the MAX of a \"negative\" value in an unsigned type\n+\t\t and zero for a length expression, just return zero.  */\n+\t      if (max_p\n+\t\t  && TREE_CODE (op0) == LE_EXPR\n+\t\t  && TYPE_UNSIGNED (type)\n+\t\t  && TREE_CODE (op1) == INTEGER_CST\n+\t\t  && !TREE_OVERFLOW (op1)\n+\t\t  && tree_int_cst_sign_bit (op1)\n+\t\t  && integer_zerop (op2))\n+\t\treturn op2;\n+\n+\t      return fold_build2 (max_p ? MAX_EXPR : MIN_EXPR, type, op1, op2);\n \t    }\n \t  break;\n "}, {"sha": "6ff1372899c006beecbc445f94ce84fef2f6e20f", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 51, "deletions": 62, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=683ccd0568569c67b117e87638782c6d870791b2", "patch": "@@ -301,19 +301,31 @@ compare_arrays (location_t loc, tree result_type, tree a1, tree a2)\n      in order to suppress the comparison of the data at the end.  */\n   while (TREE_CODE (t1) == ARRAY_TYPE && TREE_CODE (t2) == ARRAY_TYPE)\n     {\n-      tree lb1 = TYPE_MIN_VALUE (TYPE_DOMAIN (t1));\n-      tree ub1 = TYPE_MAX_VALUE (TYPE_DOMAIN (t1));\n-      tree lb2 = TYPE_MIN_VALUE (TYPE_DOMAIN (t2));\n-      tree ub2 = TYPE_MAX_VALUE (TYPE_DOMAIN (t2));\n-      tree length1 = size_binop (PLUS_EXPR, size_binop (MINUS_EXPR, ub1, lb1),\n+      tree dom1 = TYPE_DOMAIN (t1);\n+      tree dom2 = TYPE_DOMAIN (t2);\n+      tree length1 = size_binop (PLUS_EXPR,\n+\t\t\t\t size_binop (MINUS_EXPR,\n+\t\t\t\t\t     TYPE_MAX_VALUE (dom1),\n+\t\t\t\t\t     TYPE_MIN_VALUE (dom1)),\n \t\t\t\t size_one_node);\n-      tree length2 = size_binop (PLUS_EXPR, size_binop (MINUS_EXPR, ub2, lb2),\n+      tree length2 = size_binop (PLUS_EXPR,\n+\t\t\t\t size_binop (MINUS_EXPR,\n+\t\t\t\t\t     TYPE_MAX_VALUE (dom2),\n+\t\t\t\t\t     TYPE_MIN_VALUE (dom2)),\n \t\t\t\t size_one_node);\n+      tree ind1 = TYPE_INDEX_TYPE (dom1);\n+      tree ind2 = TYPE_INDEX_TYPE (dom2);\n+      tree base_type = maybe_character_type (get_base_type (ind1));\n+      tree lb1 = convert (base_type, TYPE_MIN_VALUE (ind1));\n+      tree ub1 = convert (base_type, TYPE_MAX_VALUE (ind1));\n+      tree lb2 = convert (base_type, TYPE_MIN_VALUE (ind2));\n+      tree ub2 = convert (base_type, TYPE_MAX_VALUE (ind2));\n       tree comparison, this_a1_is_null, this_a2_is_null;\n \n-      /* If the length of the first array is a constant, swap our operands\n-\t unless the length of the second array is the constant zero.  */\n-      if (TREE_CODE (length1) == INTEGER_CST && !integer_zerop (length2))\n+      /* If the length of the first array is a constant and that of the second\n+\t array is not, swap our operands to have the constant second.  */\n+      if (TREE_CODE (length1) == INTEGER_CST\n+\t  && TREE_CODE (length2) != INTEGER_CST)\n \t{\n \t  tree tem;\n \t  bool btem;\n@@ -333,17 +345,12 @@ compare_arrays (location_t loc, tree result_type, tree a1, tree a2)\n \t last < first holds.  */\n       if (integer_zerop (length2))\n \t{\n-\t  tree b = get_base_type (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n-\n \t  length_zero_p = true;\n \n-\t  ub1\n-\t    = convert (b, TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1))));\n-\t  lb1\n-\t    = convert (b, TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1))));\n+\t  lb1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (lb1, a1);\n+\t  ub1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (ub1, a1);\n \n \t  comparison = fold_build2_loc (loc, LT_EXPR, result_type, ub1, lb1);\n-\t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n \t  if (EXPR_P (comparison))\n \t    SET_EXPR_LOCATION (comparison, loc);\n \n@@ -356,24 +363,17 @@ compare_arrays (location_t loc, tree result_type, tree a1, tree a2)\n \t just use its length computed from the actual stored bounds.  */\n       else if (TREE_CODE (length2) == INTEGER_CST)\n \t{\n-\t  tree b = get_base_type (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n-\n-\t  ub1\n-\t    = convert (b, TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1))));\n-\t  lb1\n-\t    = convert (b, TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1))));\n-\t  /* Note that we know that UB2 and LB2 are constant and hence\n+\t  /* Note that we know that LB2 and UB2 are constant and hence\n \t     cannot contain a PLACEHOLDER_EXPR.  */\n-\t  ub2\n-\t    = convert (b, TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t2))));\n-\t  lb2\n-\t    = convert (b, TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t2))));\n+\t  lb1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (lb1, a1);\n+\t  ub1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (ub1, a1);\n \n \t  comparison\n \t    = fold_build2_loc (loc, EQ_EXPR, result_type,\n-\t\t\t       build_binary_op (MINUS_EXPR, b, ub1, lb1),\n-\t\t\t       build_binary_op (MINUS_EXPR, b, ub2, lb2));\n-\t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n+\t\t\t       build_binary_op (MINUS_EXPR, base_type,\n+\t\t\t\t\t\tub1, lb1),\n+\t\t\t       build_binary_op (MINUS_EXPR, base_type,\n+\t\t\t\t\t\tub2, lb2));\n \t  if (EXPR_P (comparison))\n \t    SET_EXPR_LOCATION (comparison, loc);\n \n@@ -391,26 +391,20 @@ compare_arrays (location_t loc, tree result_type, tree a1, tree a2)\n \n \t  comparison\n \t    = fold_build2_loc (loc, EQ_EXPR, result_type, length1, length2);\n+\t  if (EXPR_P (comparison))\n+\t    SET_EXPR_LOCATION (comparison, loc);\n \n-\t  /* If the length expression is of the form (cond ? val : 0), assume\n-\t     that cond is equivalent to (length != 0).  That's guaranteed by\n-\t     construction of the array types in gnat_to_gnu_entity.  */\n-\t  if (TREE_CODE (length1) == COND_EXPR\n-\t      && integer_zerop (TREE_OPERAND (length1, 2)))\n-\t    this_a1_is_null\n-\t      = invert_truthvalue_loc (loc, TREE_OPERAND (length1, 0));\n-\t  else\n-\t    this_a1_is_null = fold_build2_loc (loc, EQ_EXPR, result_type,\n-\t\t\t\t\t       length1, size_zero_node);\n-\n-\t  /* Likewise for the second array.  */\n-\t  if (TREE_CODE (length2) == COND_EXPR\n-\t      && integer_zerop (TREE_OPERAND (length2, 2)))\n-\t    this_a2_is_null\n-\t      = invert_truthvalue_loc (loc, TREE_OPERAND (length2, 0));\n-\t  else\n-\t    this_a2_is_null = fold_build2_loc (loc, EQ_EXPR, result_type,\n-\t\t\t\t\t       length2, size_zero_node);\n+\t  lb1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (lb1, a1);\n+\t  ub1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (ub1, a1);\n+\n+\t  this_a1_is_null\n+\t    = fold_build2_loc (loc, LT_EXPR, result_type, ub1, lb1);\n+\n+\t  lb2 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (lb2, a2);\n+\t  ub2 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (ub2, a2);\n+\n+\t  this_a2_is_null\n+\t    = fold_build2_loc (loc, LT_EXPR, result_type, ub2, lb2);\n \t}\n \n       /* Append expressions for this dimension to the final expressions.  */\n@@ -861,9 +855,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n       && TYPE_JUSTIFIED_MODULAR_P (operation_type))\n     operation_type = TREE_TYPE (TYPE_FIELDS (operation_type));\n \n-  if (operation_type\n-      && TREE_CODE (operation_type) == INTEGER_TYPE\n-      && TYPE_EXTRA_SUBTYPE_P (operation_type))\n+  if (operation_type && TYPE_IS_EXTRA_SUBTYPE_P (operation_type))\n     operation_type = get_base_type (operation_type);\n \n   modulus = (operation_type\n@@ -2431,16 +2423,13 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n     size = TYPE_SIZE_UNIT (TREE_TYPE (init));\n \n   /* If the size is still self-referential, reference the initializing\n-     expression, if it is present.  If not, this must have been a\n-     call to allocate a library-level object, in which case we use\n-     the maximum size.  */\n-  if (CONTAINS_PLACEHOLDER_P (size))\n-    {\n-      if (!ignore_init_type && init)\n-\tsize = substitute_placeholder_in_expr (size, init);\n-      else\n-\tsize = max_size (size, true);\n-    }\n+     expression, if it is present.  If not, this must have been a call\n+     to allocate a library-level object, in which case we just use the\n+     maximum size.  */\n+  if (!ignore_init_type && init)\n+    size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (size, init);\n+  else if (CONTAINS_PLACEHOLDER_P (size))\n+    size = max_size (size, true);\n \n   /* If the size overflows, pass -1 so Storage_Error will be raised.  */\n   if (TREE_CODE (size) == INTEGER_CST && !valid_constant_size_p (size))"}, {"sha": "007fe39c42227129142e307761b03f632e913c0c", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683ccd0568569c67b117e87638782c6d870791b2/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=683ccd0568569c67b117e87638782c6d870791b2", "patch": "@@ -1338,7 +1338,7 @@ package body Repinfo is\n             if List_Representation_Info_To_JSON then\n                UI_Write (Esiz);\n             else\n-               if Lbit < 10 then\n+               if Lbit >= 0 and then Lbit < 10 then\n                   Write_Char (' ');\n                end if;\n "}]}