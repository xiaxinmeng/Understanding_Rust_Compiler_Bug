{"sha": "3a0c8ca2156038b726e2689e9b46be4d8c40c55f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2EwYzhjYTIxNTYwMzhiNzI2ZTI2ODllOWI0NmJlNGQ4YzQwYzU1Zg==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2021-02-02T05:19:26Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2021-02-02T07:55:58Z"}, "message": "Cleanup of AST - moved outer_attrs to child classes\n\nFixed compile errors\n\nFixed more compile errors", "tree": {"sha": "3c5e0391cd9ba3a2336a0692f0bc7980469dc165", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c5e0391cd9ba3a2336a0692f0bc7980469dc165"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a0c8ca2156038b726e2689e9b46be4d8c40c55f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a0c8ca2156038b726e2689e9b46be4d8c40c55f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a0c8ca2156038b726e2689e9b46be4d8c40c55f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3a39d99c1d6f45890dbac33a9d17c8dd464654e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3a39d99c1d6f45890dbac33a9d17c8dd464654e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3a39d99c1d6f45890dbac33a9d17c8dd464654e"}], "stats": {"total": 1151, "additions": 570, "deletions": 581}, "files": [{"sha": "53007e70a9dee76f3b27cb0ae5bb05a57d01e6c5", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 263, "deletions": 303, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=3a0c8ca2156038b726e2689e9b46be4d8c40c55f", "patch": "@@ -109,6 +109,47 @@ frag_spec_to_str (MacroFragSpec frag_spec)\n     }\n }\n \n+enum AttrMode \n+{\n+  OUTER,\n+  INNER\n+};\n+\n+std::string get_mode_dump_desc (AttrMode mode) {\n+  switch (mode) {\n+    case OUTER:\n+      return \"outer attributes\";\n+    case INNER:\n+      return \"inner attributes\";\n+    default:\n+      gcc_unreachable ();\n+      return \"\";\n+  }\n+}\n+\n+// Adds lines below adding attributes\n+std::string append_attributes (std::vector<Attribute> attrs, AttrMode mode) {\n+  indent_spaces (enter);\n+\n+  std::string str = \"\\n\" + indent_spaces (stay) + get_mode_dump_desc (mode) + \": \";\n+  //str += \"\\n\" + indent_spaces (stay) + \"inner attributes: \";\n+  if (attrs.empty ())\n+    {\n+      str += \"none\";\n+    }\n+  else\n+    {\n+      /* note that this does not print them with outer or \"inner attribute\" \n+       * syntax - just prints the body */\n+      for (const auto &attr : attrs)\n+\tstr += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n+    }\n+\n+  indent_spaces (out);\n+  \n+  return str;\n+}\n+\n std::string\n Crate::as_string () const\n {\n@@ -156,7 +197,7 @@ Crate::as_string () const\n \t    {\n \t      fprintf (stderr, \"something really terrible has gone wrong - \"\n \t\t\t       \"null pointer item in crate.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + item->as_string ();\n@@ -236,7 +277,7 @@ DelimTokenTree::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"token tree in delim token tree.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += tree->as_string ();\n@@ -405,7 +446,7 @@ ModuleBodied::as_string () const\n \t    {\n \t      fprintf (stderr, \"something really terrible has gone wrong - \"\n \t\t\t       \"null pointer item in crate.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + item->as_string ();\n@@ -444,7 +485,7 @@ StaticItem::as_string () const\n     {\n       fprintf (stderr, \"something really terrible has gone wrong - null \"\n \t\t       \"pointer type in static item.\");\n-      return \"nullptr_POINTER_MARK\";\n+      return \"NULL_POINTER_MARK\";\n     }\n   str += \"\\n\" + indent_spaces (stay) + \"Type: \" + type->as_string ();\n \n@@ -453,7 +494,7 @@ StaticItem::as_string () const\n     {\n       fprintf (stderr, \"something really terrible has gone wrong - null \"\n \t\t       \"pointer expr in static item.\");\n-      return \"nullptr_POINTER_MARK\";\n+      return \"NULL_POINTER_MARK\";\n     }\n   str += \"\\n\" + indent_spaces (stay) + \"Expression: \" + expr->as_string ();\n \n@@ -499,7 +540,7 @@ TupleStruct::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in enum.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -545,7 +586,7 @@ ConstantItem::as_string () const\n     {\n       fprintf (stderr, \"something really terrible has gone wrong - null \"\n \t\t       \"pointer type in const item.\");\n-      return \"nullptr_POINTER_MARK\";\n+      return \"NULL_POINTER_MARK\";\n     }\n   str += \"\\n  Type: \" + type->as_string ();\n \n@@ -554,7 +595,7 @@ ConstantItem::as_string () const\n     {\n       fprintf (stderr, \"something really terrible has gone wrong - null \"\n \t\t       \"pointer expr in const item.\");\n-      return \"nullptr_POINTER_MARK\";\n+      return \"NULL_POINTER_MARK\";\n     }\n   str += \"\\n  Expression: \" + const_expr->as_string ();\n \n@@ -585,7 +626,7 @@ InherentImpl::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in inherent impl.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -663,7 +704,7 @@ Method::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in method.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -725,7 +766,7 @@ StructStruct::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in enum.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -775,7 +816,7 @@ UseDeclaration::as_string () const\n \tstderr,\n \t\"something really terrible has gone wrong - null pointer use tree in \"\n \t\"use declaration.\");\n-      return \"nullptr_POINTER_MARK\";\n+      return \"NULL_POINTER_MARK\";\n     }\n \n   str += \"use \" + use_tree->as_string ();\n@@ -835,7 +876,7 @@ UseTreeList::as_string () const\n \t  fprintf (stderr,\n \t\t   \"something really terrible has gone wrong - null pointer \"\n \t\t   \"tree in use tree list.\");\n-\t  return \"nullptr_POINTER_MARK\";\n+\t  return \"NULL_POINTER_MARK\";\n \t}\n \n       for (; i != e; i++)\n@@ -900,7 +941,7 @@ Enum::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in enum.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -934,7 +975,7 @@ Enum::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"enum item in enum.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + item->as_string ();\n@@ -950,9 +991,7 @@ Trait::as_string () const\n   std::string str = VisItem::as_string ();\n \n   if (has_unsafe)\n-    {\n       str += \"unsafe \";\n-    }\n \n   str += \"trait \" + name;\n \n@@ -973,7 +1012,7 @@ Trait::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in trait.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -996,7 +1035,7 @@ Trait::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"type param bound in trait.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + bound->as_string ();\n@@ -1005,13 +1044,9 @@ Trait::as_string () const\n \n   str += \"\\n Where clause: \";\n   if (!has_where_clause ())\n-    {\n       str += \"none\";\n-    }\n   else\n-    {\n       str += where_clause.as_string ();\n-    }\n \n   str += \"\\n Trait items: \";\n   if (!has_trait_items ())\n@@ -1029,7 +1064,7 @@ Trait::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"trait item in trait.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + item->as_string ();\n@@ -1063,7 +1098,7 @@ Union::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in union.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -1072,13 +1107,9 @@ Union::as_string () const\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-    {\n       str += where_clause.as_string ();\n-    }\n   else\n-    {\n       str += \"none\";\n-    }\n \n   // struct fields\n   str += \"\\n Struct fields (variants): \";\n@@ -1089,9 +1120,7 @@ Union::as_string () const\n   else\n     {\n       for (const auto &field : variants)\n-\t{\n \t  str += \"\\n  \" + field.as_string ();\n-\t}\n     }\n \n   return str;\n@@ -1114,7 +1143,7 @@ Function::as_string () const\n \t    stderr,\n \t    \"something really terrible has gone wrong - null pointer return \"\n \t    \"type in function.\");\n-\t  return \"nullptr_POINTER_MARK\";\n+\t  return \"NULL_POINTER_MARK\";\n \t}\n \n       str += return_type->as_string () + \" \";\n@@ -1139,7 +1168,7 @@ Function::as_string () const\n \t  fprintf (stderr,\n \t\t   \"something really terrible has gone wrong - null pointer \"\n \t\t   \"generic param in function item.\");\n-\t  return \"nullptr_POINTER_MARK\";\n+\t  return \"NULL_POINTER_MARK\";\n \t}\n \n       for (; i != e; i++)\n@@ -1181,7 +1210,7 @@ Function::as_string () const\n \tstderr,\n \t\"something really terrible has gone wrong - null pointer function \"\n \t\"body in function.\");\n-      return \"nullptr_POINTER_MARK\";\n+      return \"NULL_POINTER_MARK\";\n     }\n   str += function_body->as_string () + \"\\n\";\n \n@@ -1212,8 +1241,20 @@ BlockExpr::as_string () const\n {\n   std::string istr = indent_spaces (enter);\n   std::string str = istr + \"BlockExpr:\\n\" + istr;\n+  \n   // get outer attributes\n-  str += \"{\\n\" + indent_spaces (stay) + Expr::as_string ();\n+  str += \"{\\n\" + indent_spaces (stay) + \"outer attributes: \";\n+  if (outer_attrs.empty ())\n+    {\n+      str += \"none\";\n+    }\n+  else\n+    {\n+      /* note that this does not print them with \"outer attribute\" syntax -\n+       * just the body */\n+      for (const auto &attr : outer_attrs)\n+\tstr += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n+    }\n \n   // inner attributes\n   str += \"\\n\" + indent_spaces (stay) + \"inner attributes: \";\n@@ -1246,7 +1287,7 @@ BlockExpr::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"stmt in block expr.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n\" + indent_spaces (stay) + stmt->as_string ();\n@@ -1400,7 +1441,7 @@ MacroInvocationSemi::as_string () const\n \t  fprintf (stderr,\n \t\t   \"something really terrible has gone wrong - null pointer \"\n \t\t   \"token tree in macro invocation semi.\");\n-\t  return \"nullptr_POINTER_MARK\";\n+\t  return \"NULL_POINTER_MARK\";\n \t}\n \n       std::string s;\n@@ -1425,9 +1466,7 @@ ExternBlock::as_string () const\n \n   str += \"extern \";\n   if (has_abi ())\n-    {\n       str += \"\\\"\" + abi + \"\\\" \";\n-    }\n \n   // inner attributes\n   str += \"\\n inner attributes: \";\n@@ -1576,7 +1615,27 @@ ClosureParam::as_string () const\n std::string\n ClosureExpr::as_string () const\n {\n-  std::string str (\"ClosureExpr:\\n Has move: \");\n+  std::string str = \"ClosureExpr:\";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n+\n+#if 0\n+  // outer attributes\n+  str += \"\\n outer attributes: \";\n+  if (outer_attrs.empty ())\n+    {\n+      str += \"none\";\n+    }\n+  else\n+    {\n+      /* note that this does not print them with \"outer attribute\" syntax -\n+       * just the body */\n+      for (const auto &attr : outer_attrs)\n+\t  str += \"\\n  \" + attr.as_string ();\n+    }\n+#endif\n+\n+  str += \"\\n Has move: \";\n   if (has_move)\n     str += \"true\";\n   else\n@@ -1643,6 +1702,9 @@ QualifiedPathInExpression::as_string () const\n std::string\n BorrowExpr::as_string () const\n {\n+  /* TODO: find way to incorporate outer attrs - may have to represent in \n+   * different style (i.e. something more like BorrowExpr: \\n outer attrs) */\n+\n   std::string str (\"&\");\n \n   if (double_borrow)\n@@ -1659,6 +1721,9 @@ BorrowExpr::as_string () const\n std::string\n ReturnExpr::as_string () const\n {\n+  /* TODO: find way to incorporate outer attrs - may have to represent in \n+   * different style (i.e. something more like BorrowExpr: \\n outer attrs) */\n+\n   std::string str (\"return \");\n \n   if (has_returned_expr ())\n@@ -1672,7 +1737,11 @@ GroupedExpr::as_string () const\n {\n   std::string str (\"Grouped expr:\");\n \n+  // outer attrs\n+  str += append_attributes (outer_attrs, OUTER);\n+\n   // inner attributes\n+#if 0\n   str += \"\\n inner attributes: \";\n   if (inner_attrs.empty ())\n     {\n@@ -1685,6 +1754,8 @@ GroupedExpr::as_string () const\n       for (const auto &attr : inner_attrs)\n \tstr += \"\\n  \" + attr.as_string ();\n     }\n+#endif\n+  str += append_attributes (inner_attrs, INNER);\n \n   str += \"\\n Expr in parens: \" + expr_in_parens->as_string ();\n \n@@ -1700,6 +1771,7 @@ RangeToExpr::as_string () const\n std::string\n ContinueExpr::as_string () const\n {\n+  // TODO: rewrite format to allow outer attributes\n   std::string str (\"continue \");\n \n   if (has_label ())\n@@ -1711,6 +1783,7 @@ ContinueExpr::as_string () const\n std::string\n NegationExpr::as_string () const\n {\n+  // TODO: rewrite formula to allow outer attributes\n   std::string str;\n \n   switch (negation_type)\n@@ -1745,6 +1818,7 @@ RangeFullExpr::as_string () const\n std::string\n ArrayIndexExpr::as_string () const\n {\n+  // TODO: rewrite formula to allow outer attributes\n   return array_expr->as_string () + \"[\" + index_expr->as_string () + \"]\";\n }\n \n@@ -1775,7 +1849,8 @@ AsyncBlockExpr::as_string () const\n   std::string str = \"AsyncBlockExpr: \";\n \n   // get outer attributes\n-  str += \"\\n \" + Expr::as_string ();\n+  //str += \"\\n \" + Expr::as_string ();\n+  str += append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n Has move: \";\n   str += has_move ? \"true\" : \"false\";\n@@ -1786,6 +1861,7 @@ AsyncBlockExpr::as_string () const\n std::string\n ComparisonExpr::as_string () const\n {\n+  // TODO: rewrite to better reflect non-literal expressions\n   std::string str (main_or_left_expr->as_string ());\n \n   switch (expr_type)\n@@ -1820,12 +1896,14 @@ ComparisonExpr::as_string () const\n std::string\n MethodCallExpr::as_string () const\n {\n-  std::string str (\"MethodCallExpr: \\n Object (receiver) expr: \");\n+  std::string str = \"MethodCallExpr: \";\n \n+  str += append_attributes (outer_attrs, OUTER);\n+  \n+  str += \"\\n Object (receiver) expr: \\n\";\n   str += receiver->as_string ();\n \n   str += \"\\n Method path segment: \\n\";\n-\n   str += method_name.as_string ();\n \n   str += \"\\n Call params:\";\n@@ -1850,24 +1928,28 @@ MethodCallExpr::as_string () const\n std::string\n TupleIndexExpr::as_string () const\n {\n+  // TODO: rewrite dump to better reflect non-literal exprs\n   return tuple_expr->as_string () + \".\" + std::to_string (tuple_index);\n }\n \n std::string\n DereferenceExpr::as_string () const\n {\n+  // TODO: rewrite dump to better reflect non-literal exprs\n   return \"*\" + main_or_left_expr->as_string ();\n }\n \n std::string\n FieldAccessExpr::as_string () const\n {\n+  // TODO: rewrite dump to better reflect non-literal exprs\n   return receiver->as_string () + \".\" + field;\n }\n \n std::string\n LazyBooleanExpr::as_string () const\n {\n+  // TODO: rewrite dump to better reflect non-literal exprs\n   std::string str (main_or_left_expr->as_string ());\n \n   switch (expr_type)\n@@ -1890,12 +1972,14 @@ LazyBooleanExpr::as_string () const\n std::string\n RangeFromToExpr::as_string () const\n {\n+  // TODO: rewrite dump to better reflect non-literal exprs\n   return from->as_string () + \"..\" + to->as_string ();\n }\n \n std::string\n RangeToInclExpr::as_string () const\n {\n+  // TODO: rewrite dump to better reflect non-literal exprs\n   return \"..=\" + to->as_string ();\n }\n \n@@ -1907,7 +1991,8 @@ UnsafeBlockExpr::as_string () const\n   str += istr + \"{\";\n \n   // get outer attributes\n-  str += \"\\n\" + indent_spaces (stay) + Expr::as_string ();\n+  //str += \"\\n\" + indent_spaces (stay) + Expr::as_string ();\n+  str += append_attributes (outer_attrs, OUTER);\n \n   return str + \"\\n\" + indent_spaces (out) + \"}\\n\" + expr->as_string ();\n }\n@@ -1925,6 +2010,8 @@ ClosureExprInner::as_string () const\n std::string\n IfExpr::as_string () const\n {\n+  /* TODO: can if exprs have outer attributes? i thought no, but can't find it\n+   * in docs */\n   std::string str (\"IfExpr: \");\n \n   str += \"\\n Condition expr: \" + condition->as_string ();\n@@ -1967,6 +2054,8 @@ IfExprConseqIfLet::as_string () const\n std::string\n IfLetExpr::as_string () const\n {\n+  /* TODO: can if let exprs have outer attributes? i thought no, but can't find \n+   * it in docs */\n   std::string str (\"IfLetExpr: \");\n \n   str += \"\\n Condition match arm patterns: \";\n@@ -2020,12 +2109,14 @@ IfLetExprConseqIfLet::as_string () const\n std::string\n RangeFromToInclExpr::as_string () const\n {\n+  // TODO: rewrite to allow dumps with non-literal exprs\n   return from->as_string () + \"..=\" + to->as_string ();\n }\n \n std::string\n ErrorPropagationExpr::as_string () const\n {\n+  // TODO: rewrite to allow dumps with non-literal exprs\n   return main_or_left_expr->as_string () + \"?\";\n }\n \n@@ -2152,8 +2243,11 @@ ArithmeticOrLogicalExpr::as_string () const\n std::string\n CallExpr::as_string () const\n {\n-  std::string str (\"CallExpr: \\n Function expr: \");\n+  std::string str = \"CallExpr: \";\n \n+  str += append_attributes (outer_attrs, OUTER);\n+  \n+  str += \"\\n Function expr: \";\n   str += function->as_string ();\n \n   str += \"\\n Call params:\";\n@@ -2178,7 +2272,9 @@ CallExpr::as_string () const\n std::string\n WhileLoopExpr::as_string () const\n {\n-  std::string str (\"WhileLoopExpr: \");\n+  std::string str = \"WhileLoopExpr: \";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n@@ -2196,7 +2292,9 @@ WhileLoopExpr::as_string () const\n std::string\n WhileLetLoopExpr::as_string () const\n {\n-  std::string str (\"WhileLetLoopExpr: \");\n+  std::string str = \"WhileLetLoopExpr: \";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n@@ -2225,7 +2323,9 @@ WhileLetLoopExpr::as_string () const\n std::string\n LoopExpr::as_string () const\n {\n-  std::string str (\"LoopExpr: (infinite loop)\");\n+  std::string str = \"LoopExpr: (infinite loop)\";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n@@ -2241,9 +2341,13 @@ LoopExpr::as_string () const\n std::string\n ArrayExpr::as_string () const\n {\n-  std::string str (\"ArrayExpr:\");\n+  std::string str = \"ArrayExpr:\";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n \n   // inner attributes\n+  str += append_attributes (inner_attrs, INNER);\n+  #if 0\n   str += \"\\n inner attributes: \";\n   if (inner_attrs.empty ())\n     {\n@@ -2256,6 +2360,7 @@ ArrayExpr::as_string () const\n       for (const auto &attr : inner_attrs)\n \tstr += \"\\n  \" + attr.as_string ();\n     }\n+  #endif\n \n   str += \"\\n Array elems: \";\n   if (!has_array_elems ())\n@@ -2269,12 +2374,14 @@ ArrayExpr::as_string () const\n std::string\n AwaitExpr::as_string () const\n {\n+  // TODO: rewrite dump to allow non-literal exprs\n   return awaited_expr->as_string () + \".await\";\n }\n \n std::string\n BreakExpr::as_string () const\n {\n+  // TODO: rewrite dump to allow outer attrs, non-literal exprs\n   std::string str (\"break \");\n \n   if (has_label ())\n@@ -2296,6 +2403,8 @@ std::string\n MatchArm::as_string () const\n {\n   // outer attributes\n+  std::string str = append_attributes (outer_attrs, OUTER);\n+#if 0\n   std::string str = \"Outer attributes: \";\n   if (outer_attrs.empty ())\n     {\n@@ -2308,6 +2417,7 @@ MatchArm::as_string () const\n       for (const auto &attr : outer_attrs)\n \tstr += \"\\n \" + attr.as_string ();\n     }\n+#endif\n \n   str += \"\\nPatterns: \";\n   if (match_arm_patterns.empty ())\n@@ -2365,9 +2475,13 @@ MatchExpr::as_string () const\n {\n   std::string str (\"MatchExpr:\");\n \n+  str += append_attributes (outer_attrs, OUTER);\n+\n   str += \"\\n Scrutinee expr: \" + branch_value->as_string ();\n \n   // inner attributes\n+  str += append_attributes (inner_attrs, INNER);\n+#if 0\n   str += \"\\n inner attributes: \";\n   if (inner_attrs.empty ())\n     {\n@@ -2378,10 +2492,9 @@ MatchExpr::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n+#endif\n \n   // match arms\n   str += \"\\n Match arms: \";\n@@ -2403,7 +2516,11 @@ TupleExpr::as_string () const\n {\n   std::string str (\"TupleExpr:\");\n \n+  str += append_attributes (outer_attrs, OUTER);\n+\n   // inner attributes\n+  str += append_attributes (inner_attrs, INNER);\n+#if 0\n   str += \"\\n inner attributes: \";\n   if (inner_attrs.empty ())\n     {\n@@ -2414,10 +2531,9 @@ TupleExpr::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n+#endif\n \n   str += \"\\n Tuple elements: \";\n   if (tuple_elems.empty ())\n@@ -2427,9 +2543,7 @@ TupleExpr::as_string () const\n   else\n     {\n       for (const auto &elem : tuple_elems)\n-\t{\n \t  str += \"\\n  \" + elem->as_string ();\n-\t}\n     }\n \n   return str;\n@@ -2443,13 +2557,9 @@ ExprStmtWithoutBlock::as_string () const\n   str += indent_spaces (stay);\n \n   if (expr == nullptr)\n-    {\n       str += \"none (this shouldn't happen and is probably an error)\";\n-    }\n   else\n-    {\n       str += expr->as_string ();\n-    }\n   indent_spaces (out);\n \n   return str;\n@@ -2458,6 +2568,7 @@ ExprStmtWithoutBlock::as_string () const\n std::string\n FunctionParam::as_string () const\n {\n+  // TODO: rewrite dump to allow non-literal types\n   return param_name->as_string () + \" : \" + type->as_string ();\n }\n \n@@ -2482,17 +2593,13 @@ FunctionQualifiers::as_string () const\n     }\n \n   if (has_unsafe)\n-    {\n       str += \"unsafe \";\n-    }\n \n   if (has_extern)\n     {\n       str += \"extern\";\n       if (extern_abi != \"\")\n-\t{\n-\t  str += \" \\\"\" + extern_abi + \"\\\"\";\n-\t}\n+\t      str += \" \\\"\" + extern_abi + \"\\\"\";\n     }\n \n   return str;\n@@ -2505,13 +2612,9 @@ TraitBound::as_string () const\n \n   str += \"\\n Has opening question mark: \";\n   if (opening_question_mark)\n-    {\n       str += \"true\";\n-    }\n   else\n-    {\n       str += \"false\";\n-    }\n \n   str += \"\\n For lifetimes: \";\n   if (!has_for_lifetimes ())\n@@ -2521,9 +2624,7 @@ TraitBound::as_string () const\n   else\n     {\n       for (const auto &lifetime : for_lifetimes)\n-\t{\n \t  str += \"\\n  \" + lifetime.as_string ();\n-\t}\n     }\n \n   str += \"\\n Type path: \" + type_path.as_string ();\n@@ -2562,9 +2663,7 @@ MacroMatcher::as_string () const\n   else\n     {\n       for (const auto &match : matches)\n-\t{\n-\t  str += \"\\n  \" + match->as_string ();\n-\t}\n+\t      str += \"\\n  \" + match->as_string ();\n     }\n \n   return str;\n@@ -2577,13 +2676,9 @@ LifetimeParam::as_string () const\n \n   str += \"\\n Outer attribute: \";\n   if (!has_outer_attribute ())\n-    {\n       str += \"none\";\n-    }\n   else\n-    {\n       str += outer_attr.as_string ();\n-    }\n \n   str += \"\\n Lifetime: \" + lifetime.as_string ();\n \n@@ -2595,9 +2690,7 @@ LifetimeParam::as_string () const\n   else\n     {\n       for (const auto &bound : lifetime_bounds)\n-\t{\n-\t  str += \"\\n  \" + bound.as_string ();\n-\t}\n+\t      str += \"\\n  \" + bound.as_string ();\n     }\n \n   return str;\n@@ -2612,12 +2705,12 @@ MacroMatchFragment::as_string () const\n std::string\n QualifiedPathInType::as_string () const\n {\n+  /* TODO: this may need adjusting if segments (e.g. with functions) can't be \n+   * literalised */\n   std::string str = path_type.as_string ();\n \n   for (const auto &segment : segments)\n-    {\n       str += \"::\" + segment->as_string ();\n-    }\n \n   return str;\n }\n@@ -2635,20 +2728,14 @@ MacroMatchRepetition::as_string () const\n   else\n     {\n       for (const auto &match : matches)\n-\t{\n \t  str += \"\\n  \" + match->as_string ();\n-\t}\n     }\n \n   str += \"\\n Sep: \";\n   if (!has_sep ())\n-    {\n       str += \"none\";\n-    }\n   else\n-    {\n       str += sep->as_string ();\n-    }\n \n   str += \"\\n Op: \";\n   switch (op)\n@@ -2676,9 +2763,7 @@ std::string\n Lifetime::as_string () const\n {\n   if (is_error ())\n-    {\n       return \"error lifetime\";\n-    }\n \n   switch (lifetime_type)\n     {\n@@ -2696,17 +2781,15 @@ Lifetime::as_string () const\n std::string\n TypePath::as_string () const\n {\n+  /* TODO: this may need to be rewritten if a segment (e.g. function) can't be \n+   * literalised */\n   std::string str;\n \n   if (has_opening_scope_resolution)\n-    {\n       str = \"::\";\n-    }\n \n   for (const auto &segment : segments)\n-    {\n       str += segment->as_string () + \"::\";\n-    }\n \n   // kinda hack - remove last 2 '::' characters\n   str.erase (str.length () - 2);\n@@ -2721,13 +2804,9 @@ TypeParam::as_string () const\n \n   str += \"\\n Outer attribute: \";\n   if (!has_outer_attribute ())\n-    {\n       str += \"none\";\n-    }\n   else\n-    {\n       str += outer_attr.as_string ();\n-    }\n \n   str += \"\\n Identifier: \" + type_representation;\n \n@@ -2739,20 +2818,14 @@ TypeParam::as_string () const\n   else\n     {\n       for (const auto &bound : type_param_bounds)\n-\t{\n \t  str += \"\\n  \" + bound->as_string ();\n-\t}\n     }\n \n   str += \"\\n Type: \";\n   if (!has_type ())\n-    {\n       str += \"none\";\n-    }\n   else\n-    {\n       str += type->as_string ();\n-    }\n \n   return str;\n }\n@@ -2761,9 +2834,7 @@ SimplePath\n PathPattern::convert_to_simple_path (bool with_opening_scope_resolution) const\n {\n   if (!has_segments ())\n-    {\n       return SimplePath::create_empty ();\n-    }\n \n   // create vector of reserved size (to minimise reallocations)\n   std::vector<SimplePathSegment> simple_segments;\n@@ -2774,9 +2845,7 @@ PathPattern::convert_to_simple_path (bool with_opening_scope_resolution) const\n       // return empty path if doesn't meet simple path segment requirements\n       if (segment.is_error () || segment.has_generic_args ()\n \t  || segment.as_string () == \"Self\")\n-\t{\n \t  return SimplePath::create_empty ();\n-\t}\n \n       // create segment and add to vector\n       std::string segment_str = segment.as_string ();\n@@ -2787,13 +2856,10 @@ PathPattern::convert_to_simple_path (bool with_opening_scope_resolution) const\n   // kind of a HACK to get locus depending on opening scope resolution\n   Location locus = Linemap::unknown_location ();\n   if (with_opening_scope_resolution)\n-    {\n       locus = simple_segments[0].get_locus () - 2; // minus 2 chars for ::\n-    }\n   else\n-    {\n       locus = simple_segments[0].get_locus ();\n-    }\n+  // FIXME: this hack probably doesn't actually work\n \n   return SimplePath (std::move (simple_segments), with_opening_scope_resolution,\n \t\t     locus);\n@@ -2803,9 +2869,7 @@ SimplePath\n TypePath::as_simple_path () const\n {\n   if (segments.empty ())\n-    {\n       return SimplePath::create_empty ();\n-    }\n \n   // create vector of reserved size (to minimise reallocations)\n   std::vector<SimplePathSegment> simple_segments;\n@@ -2816,9 +2880,7 @@ TypePath::as_simple_path () const\n       // return empty path if doesn't meet simple path segment requirements\n       if (segment == nullptr || segment->is_error ()\n \t  || !segment->is_ident_only () || segment->as_string () == \"Self\")\n-\t{\n \t  return SimplePath::create_empty ();\n-\t}\n \n       // create segment and add to vector\n       std::string segment_str = segment->as_string ();\n@@ -2833,11 +2895,10 @@ TypePath::as_simple_path () const\n std::string\n PathExprSegment::as_string () const\n {\n+  // TODO: rewrite dump to work with non-literalisable types\n   std::string ident_str = segment_name.as_string ();\n   if (has_generic_args ())\n-    {\n       ident_str += \"::<\" + generic_args.as_string () + \">\";\n-    }\n \n   return ident_str;\n }\n@@ -2895,23 +2956,22 @@ GenericArgs::as_string () const\n std::string\n GenericArgsBinding::as_string () const\n {\n+  // TODO: rewrite to work with non-literalisable types\n   return identifier + \" = \" + type->as_string ();\n }\n \n std::string\n ForLoopExpr::as_string () const\n {\n-  std::string str (\"ForLoopExpr: \");\n+  std::string str = \"ForLoopExpr: \";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n-    {\n       str += \"none\";\n-    }\n   else\n-    {\n       str += loop_label.as_string ();\n-    }\n \n   str += \"\\n Pattern: \" + pattern->as_string ();\n \n@@ -2925,14 +2985,11 @@ ForLoopExpr::as_string () const\n std::string\n RangePattern::as_string () const\n {\n+  // TODO: maybe rewrite to work with non-linearisable bounds\n   if (has_ellipsis_syntax)\n-    {\n       return lower->as_string () + \"...\" + upper->as_string ();\n-    }\n   else\n-    {\n       return lower->as_string () + \"..=\" + upper->as_string ();\n-    }\n }\n \n std::string\n@@ -2941,9 +2998,7 @@ RangePatternBoundLiteral::as_string () const\n   std::string str;\n \n   if (has_minus)\n-    {\n       str += \"-\";\n-    }\n \n   str += literal.as_string ();\n \n@@ -2956,9 +3011,7 @@ SlicePattern::as_string () const\n   std::string str (\"SlicePattern: \");\n \n   for (const auto &pattern : items)\n-    {\n       str += \"\\n \" + pattern->as_string ();\n-    }\n \n   return str;\n }\n@@ -2969,9 +3022,7 @@ TuplePatternItemsMultiple::as_string () const\n   std::string str;\n \n   for (const auto &pattern : patterns)\n-    {\n       str += \"\\n \" + pattern->as_string ();\n-    }\n \n   return str;\n }\n@@ -2989,9 +3040,7 @@ TuplePatternItemsRanged::as_string () const\n   else\n     {\n       for (const auto &lower : lower_patterns)\n-\t{\n \t  str += \"\\n  \" + lower->as_string ();\n-\t}\n     }\n \n   str += \"\\n Upper patterns: \";\n@@ -3002,9 +3051,7 @@ TuplePatternItemsRanged::as_string () const\n   else\n     {\n       for (const auto &upper : upper_patterns)\n-\t{\n \t  str += \"\\n  \" + upper->as_string ();\n-\t}\n     }\n \n   return str;\n@@ -3020,6 +3067,8 @@ std::string\n StructPatternField::as_string () const\n {\n   // outer attributes\n+  std::string str = append_attributes (outer_attrs, OUTER);\n+#if 0\n   std::string str (\"Outer attributes: \");\n   if (outer_attrs.empty ())\n     {\n@@ -3030,10 +3079,9 @@ StructPatternField::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n+#endif\n \n   return str;\n }\n@@ -3046,14 +3094,10 @@ StructPatternFieldIdent::as_string () const\n   str += \"\\n\";\n \n   if (has_ref)\n-    {\n       str += \"ref \";\n-    }\n \n   if (has_mut)\n-    {\n       str += \"mut \";\n-    }\n \n   str += ident;\n \n@@ -3063,6 +3107,7 @@ StructPatternFieldIdent::as_string () const\n std::string\n StructPatternFieldTuplePat::as_string () const\n {\n+  // TODO: maybe rewrite to work with non-linearisable patterns\n   std::string str = StructPatternField::as_string ();\n \n   str += \"\\n\";\n@@ -3075,6 +3120,7 @@ StructPatternFieldTuplePat::as_string () const\n std::string\n StructPatternFieldIdentPat::as_string () const\n {\n+  // TODO: maybe rewrite to work with non-linearisable patterns\n   std::string str = StructPatternField::as_string ();\n \n   str += \"\\n\";\n@@ -3096,20 +3142,14 @@ StructPatternElements::as_string () const\n   else\n     {\n       for (const auto &field : fields)\n-\t{\n \t  str += \"\\n   \" + field->as_string ();\n-\t}\n     }\n \n   str += \"\\n  Etc: \";\n   if (has_struct_pattern_etc)\n-    {\n       str += \"true\";\n-    }\n   else\n-    {\n       str += \"false\";\n-    }\n \n   return str;\n }\n@@ -3123,13 +3163,9 @@ StructPattern::as_string () const\n \n   str += \"\\n Struct pattern elems: \";\n   if (!has_struct_pattern_elems ())\n-    {\n       str += \"none\";\n-    }\n   else\n-    {\n       str += elems.as_string ();\n-    }\n \n   return str;\n }\n@@ -3140,27 +3176,22 @@ LiteralPattern::as_string () const\n   std::string str;\n \n   if (has_minus)\n-    {\n       str += \"-\";\n-    }\n \n   return str + lit.as_string ();\n }\n \n std::string\n ReferencePattern::as_string () const\n {\n+  // TODO: maybe rewrite to work with non-linearisable patterns\n   std::string str (\"&\");\n \n   if (has_two_amps)\n-    {\n       str += \"&\";\n-    }\n \n   if (is_mut)\n-    {\n       str += \"mut \";\n-    }\n \n   str += pattern->as_string ();\n \n@@ -3170,24 +3201,19 @@ ReferencePattern::as_string () const\n std::string\n IdentifierPattern::as_string () const\n {\n+  // TODO: maybe rewrite to work with non-linearisable patterns\n   std::string str;\n \n   if (is_ref)\n-    {\n       str += \"ref \";\n-    }\n \n   if (is_mut)\n-    {\n       str += \"mut \";\n-    }\n \n   str += variable_ident;\n \n   if (has_pattern_to_bind ())\n-    {\n       str += \" @ \" + to_bind->as_string ();\n-    }\n \n   return str;\n }\n@@ -3198,9 +3224,7 @@ TupleStructItemsNoRange::as_string () const\n   std::string str;\n \n   for (const auto &pattern : patterns)\n-    {\n       str += \"\\n  \" + pattern->as_string ();\n-    }\n \n   return str;\n }\n@@ -3217,9 +3241,7 @@ TupleStructItemsRange::as_string () const\n   else\n     {\n       for (const auto &lower : lower_patterns)\n-\t{\n \t  str += \"\\n   \" + lower->as_string ();\n-\t}\n     }\n \n   str += \"\\n  Upper patterns: \";\n@@ -3230,9 +3252,7 @@ TupleStructItemsRange::as_string () const\n   else\n     {\n       for (const auto &upper : upper_patterns)\n-\t{\n \t  str += \"\\n   \" + upper->as_string ();\n-\t}\n     }\n \n   return str;\n@@ -3253,39 +3273,21 @@ TupleStructPattern::as_string () const\n std::string\n LetStmt::as_string () const\n {\n-  // outer attributes\n-  std::string str = \"Outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      indent_spaces (enter);\n-      for (const auto &attr : outer_attrs)\n-\t{\n-\t  str += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n-\t}\n-      indent_spaces (out);\n-    }\n+  // TODO: rewrite to work with non-linearisable types and exprs\n+  std::string str = append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n\" + indent_spaces (stay) + \"let \" + variables_pattern->as_string ();\n \n   if (has_type ())\n-    {\n       str += \" : \" + type->as_string ();\n-    }\n \n   if (has_init_expr ())\n-    {\n       str += \" = \" + init_expr->as_string ();\n-    }\n \n   return str;\n }\n \n+#if 0\n // Used to get outer attributes for expressions.\n std::string\n Expr::as_string () const\n@@ -3301,22 +3303,18 @@ Expr::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n \n   return str;\n }\n+#endif\n \n // hopefully definition here will prevent circular dependency issue\n TraitBound *\n TypePath::to_trait_bound (bool in_parens) const\n {\n-  // create clone FIXME is this required? or is copy constructor automatically\n-  // called?\n-  TypePath copy (*this);\n-  return new TraitBound (std::move (copy), copy.get_locus (), in_parens);\n+  return new TraitBound (TypePath (*this), get_locus (), in_parens);\n }\n \n std::string\n@@ -3328,6 +3326,7 @@ InferredType::as_string () const\n std::string\n TypeCastExpr::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs and types\n   return main_or_left_expr->as_string () + \" as \"\n \t + type_to_convert_to->as_string ();\n }\n@@ -3344,9 +3343,7 @@ ImplTraitType::as_string () const\n   else\n     {\n       for (const auto &bound : type_param_bounds)\n-\t{\n \t  str += \"\\n  \" + bound->as_string ();\n-\t}\n     }\n \n   return str;\n@@ -3355,17 +3352,14 @@ ImplTraitType::as_string () const\n std::string\n ReferenceType::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable types\n   std::string str (\"&\");\n \n   if (has_lifetime ())\n-    {\n       str += lifetime.as_string () + \" \";\n-    }\n \n   if (has_mut)\n-    {\n       str += \"mut \";\n-    }\n \n   str += type->as_string ();\n \n@@ -3375,6 +3369,7 @@ ReferenceType::as_string () const\n std::string\n RawPointerType::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable types\n   std::string str (\"*\");\n \n   switch (pointer_type)\n@@ -3400,13 +3395,9 @@ TraitObjectType::as_string () const\n   std::string str (\"TraitObjectType: \\n Has dyn dispatch: \");\n \n   if (has_dyn)\n-    {\n       str += \"true\";\n-    }\n   else\n-    {\n       str += \"false\";\n-    }\n \n   str += \"\\n TypeParamBounds: \";\n   if (type_param_bounds.empty ())\n@@ -3416,9 +3407,7 @@ TraitObjectType::as_string () const\n   else\n     {\n       for (const auto &bound : type_param_bounds)\n-\t{\n \t  str += \"\\n  \" + bound->as_string ();\n-\t}\n     }\n \n   return str;\n@@ -3436,9 +3425,7 @@ BareFunctionType::as_string () const\n   else\n     {\n       for (const auto &for_lifetime : for_lifetimes)\n-\t{\n \t  str += \"\\n  \" + for_lifetime.as_string ();\n-\t}\n     }\n \n   str += \"\\n Qualifiers: \" + function_qualifiers.as_string ();\n@@ -3451,30 +3438,20 @@ BareFunctionType::as_string () const\n   else\n     {\n       for (const auto &param : params)\n-\t{\n \t  str += \"\\n  \" + param.as_string ();\n-\t}\n     }\n \n   str += \"\\n Is variadic: \";\n   if (is_variadic)\n-    {\n       str += \"true\";\n-    }\n   else\n-    {\n       str += \"false\";\n-    }\n \n   str += \"\\n Return type: \";\n   if (!has_return_type ())\n-    {\n       str += \"none (void)\";\n-    }\n   else\n-    {\n       str += return_type->as_string ();\n-    }\n \n   return str;\n }\n@@ -3490,6 +3467,7 @@ ImplTraitTypeOneBound::as_string () const\n std::string\n TypePathSegmentGeneric::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable types\n   return TypePathSegment::as_string () + \"<\" + generic_args.as_string () + \">\";\n }\n \n@@ -3499,13 +3477,9 @@ TraitObjectTypeOneBound::as_string () const\n   std::string str (\"TraitObjectTypeOneBound: \\n Has dyn dispatch: \");\n \n   if (has_dyn)\n-    {\n       str += \"true\";\n-    }\n   else\n-    {\n       str += \"false\";\n-    }\n \n   str += \"\\n TraitBound: \" + trait_bound.as_string ();\n \n@@ -3515,6 +3489,7 @@ TraitObjectTypeOneBound::as_string () const\n std::string\n TypePathFunction::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable types\n   std::string str (\"(\");\n \n   if (has_inputs ())\n@@ -3533,34 +3508,36 @@ TypePathFunction::as_string () const\n   str += \")\";\n \n   if (has_return_type ())\n-    {\n       str += \" -> \" + return_type->as_string ();\n-    }\n \n   return str;\n }\n \n std::string\n TypePathSegmentFunction::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable types\n   return TypePathSegment::as_string () + function_path.as_string ();\n }\n \n std::string\n ArrayType::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable types and exprs\n   return \"[\" + elem_type->as_string () + \"; \" + size->as_string () + \"]\";\n }\n \n std::string\n SliceType::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable types\n   return \"[\" + elem_type->as_string () + \"]\";\n }\n \n std::string\n TupleType::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable types\n   std::string str (\"(\");\n \n   if (!is_unit_type ())\n@@ -3584,7 +3561,7 @@ TupleType::as_string () const\n std::string\n StructExpr::as_string () const\n {\n-  std::string str = ExprWithoutBlock::as_string ();\n+  std::string str = append_attributes (outer_attrs, OUTER);\n   indent_spaces (enter);\n   str += \"\\n\" + indent_spaces (stay) + \"StructExpr:\";\n   indent_spaces (enter);\n@@ -3611,9 +3588,7 @@ StructExprTuple::as_string () const\n \n       // debug - null pointer check\n       if (*i == nullptr)\n-\t{\n \t  return \"ERROR_MARK_STRING - nullptr struct expr tuple field\";\n-\t}\n \n       str += '(';\n       for (; i != e; i++)\n@@ -3649,11 +3624,14 @@ StructExprTuple::as_string () const\n std::string\n StructExprStruct::as_string () const\n {\n+  // TODO: doesn't this require data from StructExpr?\n   std::string str (\"StructExprStruct (or subclass): \");\n \n   str += \"\\n Path: \" + get_struct_name ().as_string ();\n \n   // inner attributes\n+  str += append_attributes (inner_attrs, INNER);\n+#if 0\n   str += \"\\n inner attributes: \";\n   if (inner_attrs.empty ())\n     {\n@@ -3666,6 +3644,7 @@ StructExprStruct::as_string () const\n       for (const auto &attr : inner_attrs)\n \tstr += \"\\n  \" + attr.as_string ();\n     }\n+#endif\n \n   return str;\n }\n@@ -3689,12 +3668,14 @@ StructExprFieldWithVal::as_string () const\n std::string\n StructExprFieldIdentifierValue::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs\n   return field_name + \" : \" + StructExprFieldWithVal::as_string ();\n }\n \n std::string\n StructExprFieldIndexValue::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs\n   return std::to_string (index) + \" : \" + StructExprFieldWithVal::as_string ();\n }\n \n@@ -3726,7 +3707,7 @@ StructExprStructFields::as_string () const\n std::string\n EnumExprStruct::as_string () const\n {\n-  std::string str (\"StructExprStruct (or subclass): \");\n+  std::string str (\"EnumExprStruct (or subclass): \");\n \n   str += \"\\n Path: \" + get_enum_variant_path ().as_string ();\n \n@@ -3754,19 +3735,23 @@ EnumExprFieldWithVal::as_string () const\n std::string\n EnumExprFieldIdentifierValue::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs\n   return field_name + \" : \" + EnumExprFieldWithVal::as_string ();\n }\n \n std::string\n EnumExprFieldIndexValue::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs\n   return std::to_string (index) + \" : \" + EnumExprFieldWithVal::as_string ();\n }\n \n std::string\n EnumItem::as_string () const\n {\n   // outer attributes\n+  std::string str = append_attributes (outer_attrs, OUTER);\n+#if 0\n   std::string str = \"outer attributes: \";\n   if (outer_attrs.empty ())\n     {\n@@ -3779,6 +3764,7 @@ EnumItem::as_string () const\n       for (const auto &attr : outer_attrs)\n \tstr += \"\\n  \" + attr.as_string ();\n     }\n+#endif\n \n   str += \"\\n\" + variant_name;\n \n@@ -3816,7 +3802,11 @@ EnumItemTuple::as_string () const\n std::string\n TupleField::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs\n+\n   // outer attributes\n+  std::string str = append_attributes (outer_attrs, OUTER);\n+#if 0\n   std::string str = \"outer attributes: \";\n   if (outer_attrs.empty ())\n     {\n@@ -3827,15 +3817,12 @@ TupleField::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n+#endif\n \n   if (has_visibility ())\n-    {\n       str += \"\\n\" + visibility.as_string ();\n-    }\n \n   str += \" \" + field_type->as_string ();\n \n@@ -3873,7 +3860,10 @@ EnumItemStruct::as_string () const\n std::string\n StructField::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs\n   // outer attributes\n+  std::string str = append_attributes (outer_attrs, OUTER);\n+#if 0\n   std::string str = \"outer attributes: \";\n   if (outer_attrs.empty ())\n     {\n@@ -3884,15 +3874,12 @@ StructField::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n+#endif\n \n   if (has_visibility ())\n-    {\n       str += \"\\n\" + visibility.as_string ();\n-    }\n \n   str += \" \" + field_name + \" : \" + field_type->as_string ();\n \n@@ -3902,6 +3889,7 @@ StructField::as_string () const\n std::string\n EnumItemDiscriminant::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs\n   std::string str = EnumItem::as_string ();\n \n   // add equal and expression\n@@ -3939,6 +3927,8 @@ std::string\n ExternalStaticItem::as_string () const\n {\n   // outer attributes\n+  std::string str = append_attributes (outer_attrs, OUTER);\n+#if 0\n   std::string str = \"outer attributes: \";\n   if (outer_attrs.empty ())\n     {\n@@ -3951,6 +3941,7 @@ ExternalStaticItem::as_string () const\n       for (const auto &attr : outer_attrs)\n \tstr += \"\\n  \" + attr.as_string ();\n     }\n+#endif\n \n   // start visibility on new line and with a space\n   str += \"\\n\" + visibility.as_string () + \" \";\n@@ -3973,6 +3964,8 @@ std::string\n ExternalFunctionItem::as_string () const\n {\n   // outer attributes\n+  std::string str = append_attributes (outer_attrs, OUTER);\n+#if 0\n   std::string str = \"outer attributes: \";\n   if (outer_attrs.empty ())\n     {\n@@ -3985,6 +3978,7 @@ ExternalFunctionItem::as_string () const\n       for (const auto &attr : outer_attrs)\n \tstr += \"\\n  \" + attr.as_string ();\n     }\n+#endif\n \n   // start visibility on new line and with a space\n   str += \"\\n\" + visibility.as_string () + \" \";\n@@ -4011,7 +4005,7 @@ ExternalFunctionItem::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in external function item.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -4061,6 +4055,8 @@ ExternalFunctionItem::as_string () const\n std::string\n NamedFunctionParam::as_string () const\n {\n+  std::string str = append_attributes (outer_attrs, OUTER);\n+#if 0\n   std::string str = \"outer attributes: \";\n \n   if (!has_outer_attrs ())\n@@ -4072,6 +4068,7 @@ NamedFunctionParam::as_string () const\n       for (const auto &attr : outer_attrs)\n \tstr += \"\\n \" + attr.as_string ();\n     }\n+#endif\n \n   str += \"\\n\" + name;\n \n@@ -4098,6 +4095,8 @@ attr.as_string();\n std::string\n TraitItemFunc::as_string () const\n {\n+  std::string str = append_attributes (outer_attrs, OUTER);\n+#if 0\n   std::string str = \"outer attributes: \";\n   if (outer_attrs.empty ())\n     {\n@@ -4108,22 +4107,17 @@ TraitItemFunc::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n+#endif\n \n   str += \"\\n\" + decl.as_string ();\n \n   str += \"\\n Definition (block expr): \";\n   if (has_definition ())\n-    {\n       str += block_expr->as_string ();\n-    }\n   else\n-    {\n       str += \"none\";\n-    }\n \n   return str;\n }\n@@ -4150,7 +4144,7 @@ TraitFunctionDecl::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in trait function decl.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -4161,9 +4155,7 @@ TraitFunctionDecl::as_string () const\n   if (has_params ())\n     {\n       for (const auto &param : function_params)\n-\t{\n \t  str += \"\\n  \" + param.as_string ();\n-\t}\n     }\n   else\n     {\n@@ -4172,30 +4164,24 @@ TraitFunctionDecl::as_string () const\n \n   str += \"\\n Return type: \";\n   if (has_return_type ())\n-    {\n       str += return_type->as_string ();\n-    }\n   else\n-    {\n       str += \"none (void)\";\n-    }\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-    {\n       str += where_clause.as_string ();\n-    }\n   else\n-    {\n       str += \"none\";\n-    }\n \n   return str;\n }\n \n std::string\n TraitItemMethod::as_string () const\n {\n+  std::string str = append_attributes (outer_attrs, OUTER);\n+#if 0\n   std::string str = \"outer attributes: \";\n   if (outer_attrs.empty ())\n     {\n@@ -4206,22 +4192,17 @@ TraitItemMethod::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n+#endif\n \n   str += \"\\n\" + decl.as_string ();\n \n   str += \"\\n Definition (block expr): \";\n   if (has_definition ())\n-    {\n       str += block_expr->as_string ();\n-    }\n   else\n-    {\n       str += \"none\";\n-    }\n \n   return str;\n }\n@@ -4248,7 +4229,7 @@ TraitMethodDecl::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in trait function decl.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -4261,9 +4242,7 @@ TraitMethodDecl::as_string () const\n   if (has_params ())\n     {\n       for (const auto &param : function_params)\n-\t{\n \t  str += \"\\n  \" + param.as_string ();\n-\t}\n     }\n   else\n     {\n@@ -4272,30 +4251,25 @@ TraitMethodDecl::as_string () const\n \n   str += \"\\n Return type: \";\n   if (has_return_type ())\n-    {\n       str += return_type->as_string ();\n-    }\n   else\n-    {\n       str += \"none (void)\";\n-    }\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-    {\n       str += where_clause.as_string ();\n-    }\n   else\n-    {\n       str += \"none\";\n-    }\n \n   return str;\n }\n \n std::string\n TraitItemConst::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs\n+  std::string str = append_attributes (outer_attrs, OUTER);\n+#if 0\n   std::string str = \"outer attributes: \";\n   if (outer_attrs.empty ())\n     {\n@@ -4306,24 +4280,23 @@ TraitItemConst::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n+#endif\n \n   str += \"\\nconst \" + name + \" : \" + type->as_string ();\n \n   if (has_expression ())\n-    {\n       str += \" = \" + expr->as_string ();\n-    }\n \n   return str;\n }\n \n std::string\n TraitItemType::as_string () const\n {\n+  std::string str = append_attributes (outer_attrs, OUTER);\n+#if 0\n   std::string str = \"outer attributes: \";\n   if (outer_attrs.empty ())\n     {\n@@ -4334,10 +4307,9 @@ TraitItemType::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n+#endif\n \n   str += \"\\ntype \" + name;\n \n@@ -4357,7 +4329,7 @@ TraitItemType::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"type param bound in trait item type.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + bound->as_string ();\n@@ -4370,6 +4342,7 @@ TraitItemType::as_string () const\n std::string\n SelfParam::as_string () const\n {\n+  // TODO: rewrite to allow non-linearisable types\n   if (is_error ())\n     {\n       return \"error\";\n@@ -4382,9 +4355,7 @@ SelfParam::as_string () const\n \t  std::string str;\n \n \t  if (is_mut)\n-\t    {\n \t      str += \"mut \";\n-\t    }\n \n \t  str += \"self : \";\n \n@@ -4398,9 +4369,7 @@ SelfParam::as_string () const\n \t  std::string str = \"&\" + lifetime.as_string () + \" \";\n \n \t  if (is_mut)\n-\t    {\n \t      str += \"mut \";\n-\t    }\n \n \t  str += \"self\";\n \n@@ -4412,9 +4381,7 @@ SelfParam::as_string () const\n \t  std::string str = \"&\";\n \n \t  if (is_mut)\n-\t    {\n \t      str += \" mut \";\n-\t    }\n \n \t  str += \"self\";\n \n@@ -4426,9 +4393,7 @@ SelfParam::as_string () const\n \t  std::string str;\n \n \t  if (is_mut)\n-\t    {\n \t      str += \"mut \";\n-\t    }\n \n \t  str += \"self\";\n \n@@ -4440,6 +4405,7 @@ SelfParam::as_string () const\n std::string\n ArrayElemsCopied::as_string () const\n {\n+  // TODO: rewrite to allow non-linearisable exprs\n   return elem_to_copy->as_string () + \"; \" + num_copies->as_string ();\n }\n \n@@ -4453,9 +4419,7 @@ LifetimeWhereClauseItem::as_string () const\n   str += \"\\nLifetime bounds: \";\n \n   for (const auto &bound : lifetime_bounds)\n-    {\n       str += \"\\n \" + bound.as_string ();\n-    }\n \n   return str;\n }\n@@ -4472,9 +4436,7 @@ TypeBoundWhereClauseItem::as_string () const\n   else\n     {\n       for (const auto &for_lifetime : for_lifetimes)\n-\t{\n \t  str += \"\\n \" + for_lifetime.as_string ();\n-\t}\n     }\n \n   str += \"\\nType: \" + bound_type->as_string ();\n@@ -4485,9 +4447,7 @@ TypeBoundWhereClauseItem::as_string () const\n     {\n       // debug null pointer check\n       if (bound == nullptr)\n-\t{\n-\t  return \"nullptr_POINTER_MARK - type param bounds\";\n-\t}\n+\t  return \"NULL_POINTER_MARK - type param bounds\";\n \n       str += \"\\n \" + bound->as_string ();\n     }\n@@ -4508,7 +4468,7 @@ ArrayElemsValues::as_string () const\n \t  fprintf (stderr,\n \t\t   \"something really terrible has gone wrong - null pointer \"\n \t\t   \"expr in array elems values.\");\n-\t  return \"nullptr_POINTER_MARK\";\n+\t  return \"NULL_POINTER_MARK\";\n \t}\n \n       str += \"\\n  \" + expr->as_string ();\n@@ -4520,6 +4480,7 @@ ArrayElemsValues::as_string () const\n std::string\n MaybeNamedParam::as_string () const\n {\n+  // TODO: rewrite to allow using non-linearisable types in dump\n   std::string str;\n \n   switch (param_kind)\n@@ -4838,7 +4799,7 @@ MacroParser::parse_path_meta_item ()\n \t\t\t   \"failed to parse literal in attribute\");\n \t    return nullptr;\n \t  }\n-\tLiteralExpr expr (std::move (lit), locus);\n+\tLiteralExpr expr (std::move (lit), {}, locus);\n \t// stream_pos++;\n \t/* shouldn't be required anymore due to parsing literal actually\n \t * skipping the token */\n@@ -4893,9 +4854,8 @@ MacroParser::parse_meta_item_seq ()\n       meta_items.push_back (std::move (inner));\n \n       if (peek_token ()->get_id () != COMMA)\n-\t{\n \t  break;\n-\t}\n+\n       skip_token ();\n     }\n \n@@ -5056,7 +5016,7 @@ std::unique_ptr<MetaItemLitExpr>\n MacroParser::parse_meta_item_lit ()\n {\n   Location locus = peek_token ()->get_locus ();\n-  LiteralExpr lit_expr (parse_literal (), locus);\n+  LiteralExpr lit_expr (parse_literal (), {}, locus);\n   return std::unique_ptr<MetaItemLitExpr> (\n     new MetaItemLitExpr (std::move (lit_expr)));\n }\n@@ -5294,7 +5254,7 @@ Attribute\n MetaNameValueStr::to_attribute () const\n {\n   LiteralExpr lit_expr (str, Literal::LitType::STRING,\n-\t\t\tPrimitiveCoreType::CORETYPE_UNKNOWN, Location ());\n+\t\t\tPrimitiveCoreType::CORETYPE_UNKNOWN, {}, Location ());\n   return Attribute (SimplePath::from_str (ident),\n \t\t    std::unique_ptr<AttrInputLiteral> (\n \t\t      new AttrInputLiteral (std::move (lit_expr))));"}, {"sha": "9c7c5674a1fb64c0c39c72d715703b1d9a08170a", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 12, "deletions": 43, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=3a0c8ca2156038b726e2689e9b46be4d8c40c55f", "patch": "@@ -846,14 +846,7 @@ class ExprWithoutBlock;\n // Base expression AST node - abstract\n class Expr\n {\n-  // TODO: move outer attribute data to derived classes?\n-  std::vector<Attribute> outer_attrs;\n-\n public:\n-  // TODO: this mutable getter seems really dodgy. Think up better way.\n-  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n-  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n-\n   // Unique pointer custom clone function\n   std::unique_ptr<Expr> clone_expr () const\n   {\n@@ -869,8 +862,7 @@ class Expr\n    * overrided in subclasses of ExprWithoutBlock */\n   virtual ExprWithoutBlock *as_expr_without_block () const { return nullptr; }\n \n-  // TODO: make pure virtual if move out outer attributes to derived classes\n-  virtual std::string as_string () const;\n+  virtual std::string as_string () const = 0;\n \n   virtual ~Expr () {}\n \n@@ -890,20 +882,15 @@ class Expr\n \n protected:\n   // Constructor\n-  Expr (std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n-    : outer_attrs (std::move (outer_attribs)),\n-      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  Expr () : node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Clone function implementation as pure virtual method\n   virtual Expr *clone_expr_impl () const = 0;\n \n   // TODO: think of less hacky way to implement this kind of thing\n   // Sets outer attributes.\n-  void set_outer_attrs (std::vector<Attribute> outer_attrs_to_set)\n-  {\n-    outer_attrs = std::move (outer_attrs_to_set);\n-  }\n+  virtual void set_outer_attrs (std::vector<Attribute>) = 0;\n \n   NodeId node_id;\n };\n@@ -912,12 +899,6 @@ class Expr\n class ExprWithoutBlock : public Expr\n {\n protected:\n-  // Constructor\n-  ExprWithoutBlock (std::vector<Attribute> outer_attribs\n-\t\t    = std::vector<Attribute> ())\n-    : Expr (std::move (outer_attribs))\n-  {}\n-\n   // pure virtual clone implementation\n   virtual ExprWithoutBlock *clone_expr_without_block_impl () const = 0;\n \n@@ -952,15 +933,13 @@ class ExprWithoutBlock : public Expr\n  */\n class IdentifierExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   Identifier ident;\n   Location locus;\n \n public:\n-  IdentifierExpr (Identifier ident, Location locus = Location (),\n-\t\t  std::vector<Attribute> outer_attrs\n-\t\t  = std::vector<Attribute> ())\n-    : ExprWithoutBlock (std::move (outer_attrs)), ident (std::move (ident)),\n-      locus (locus)\n+  IdentifierExpr (Identifier ident, std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)), ident (std::move (ident)), locus (locus)\n   {}\n \n   std::string as_string () const override { return ident; }\n@@ -982,6 +961,11 @@ class IdentifierExpr : public ExprWithoutBlock\n   void mark_for_strip () override { ident = {}; }\n   bool is_marked_for_strip () const override { return ident.empty (); }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   // Clone method implementation\n   IdentifierExpr *clone_expr_without_block_impl () const final override\n@@ -1677,22 +1661,7 @@ struct Crate\n \n // Base path expression AST node - abstract\n class PathExpr : public ExprWithoutBlock\n-{\n-protected:\n-  PathExpr (std::vector<Attribute> outer_attribs)\n-    : ExprWithoutBlock (std::move (outer_attribs))\n-  {}\n-\n-public:\n-  // TODO: think of a better and less hacky way to allow this\n-\n-  /* Replaces the outer attributes of this path expression with the given outer\n-   * attributes. */\n-  void replace_outer_attrs (std::vector<Attribute> outer_attrs)\n-  {\n-    set_outer_attrs (std::move (outer_attrs));\n-  }\n-};\n+{};\n } // namespace AST\n } // namespace Rust\n "}, {"sha": "5177785c5ad03734331cdfb48503f8d54a6771b6", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 215, "deletions": 124, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=3a0c8ca2156038b726e2689e9b46be4d8c40c55f", "patch": "@@ -13,12 +13,7 @@ namespace AST {\n // AST node for an expression with an accompanying block - abstract\n class ExprWithBlock : public Expr\n {\n-  // TODO: should this mean that a BlockExpr should be a member variable?\n protected:\n-  ExprWithBlock (std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n-    : Expr (std::move (outer_attrs))\n-  {}\n-\n   // pure virtual clone implementation\n   virtual ExprWithBlock *clone_expr_with_block_impl () const = 0;\n \n@@ -41,6 +36,7 @@ class ExprWithBlock : public Expr\n // Literals? Or literal base?\n class LiteralExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   Literal literal;\n   Location locus;\n \n@@ -50,15 +46,15 @@ class LiteralExpr : public ExprWithoutBlock\n   Literal::LitType get_lit_type () const { return literal.get_lit_type (); }\n \n   LiteralExpr (std::string value_as_string, Literal::LitType type,\n-\t       PrimitiveCoreType type_hint, Location locus,\n-\t       std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n-    : ExprWithoutBlock (std::move (outer_attrs)),\n+\t       PrimitiveCoreType type_hint,\n+\t       std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)),\n       literal (std::move (value_as_string), type, type_hint), locus (locus)\n   {}\n \n-  LiteralExpr (Literal literal, Location locus,\n-\t       std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n-    : ExprWithoutBlock (std::move (outer_attrs)), literal (std::move (literal)),\n+  LiteralExpr (Literal literal,\n+\t       std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)), literal (std::move (literal)),\n       locus (locus)\n   {}\n \n@@ -79,6 +75,11 @@ class LiteralExpr : public ExprWithoutBlock\n   void mark_for_strip () override { literal = Literal::create_error (); }\n   bool is_marked_for_strip () const override { return literal.is_error (); }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -196,20 +197,21 @@ class OperatorExpr : public ExprWithoutBlock\n   Location locus;\n \n protected:\n-  /* Variable must be protected to allow derived classes to use it as a first\n-   * class citizen */\n+  /* Variables must be protected to allow derived classes to use them as first\n+   * class citizens */\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> main_or_left_expr;\n \n   // Constructor (only for initialisation of expr purposes)\n   OperatorExpr (std::unique_ptr<Expr> main_or_left_expr,\n \t\tstd::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)), locus (locus),\n+    : locus (locus), outer_attrs (std::move (outer_attribs)),\n       main_or_left_expr (std::move (main_or_left_expr))\n   {}\n \n   // Copy constructor (only for initialisation of expr purposes)\n   OperatorExpr (OperatorExpr const &other)\n-    : ExprWithoutBlock (other), locus (other.locus)\n+    : locus (other.locus), outer_attrs (other.outer_attrs)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.main_or_left_expr != nullptr)\n@@ -221,7 +223,7 @@ class OperatorExpr : public ExprWithoutBlock\n   {\n     ExprWithoutBlock::operator= (other);\n     locus = other.locus;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.main_or_left_expr != nullptr)\n@@ -246,6 +248,11 @@ class OperatorExpr : public ExprWithoutBlock\n   {\n     return main_or_left_expr == nullptr;\n   }\n+\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n };\n \n /* Unary prefix & or &mut (or && and &&mut) borrow operator. Cannot be\n@@ -859,6 +866,7 @@ class CompoundAssignmentExpr : public OperatorExpr\n // Expression in parentheses (i.e. like literally just any 3 + (2 * 6))\n class GroupedExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::vector<Attribute> inner_attrs;\n   std::unique_ptr<Expr> expr_in_parens;\n   Location locus;\n@@ -869,17 +877,22 @@ class GroupedExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n   std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n   GroupedExpr (std::unique_ptr<Expr> parenthesised_expr,\n \t       std::vector<Attribute> inner_attribs,\n \t       std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       inner_attrs (std::move (inner_attribs)),\n       expr_in_parens (std::move (parenthesised_expr)), locus (locus)\n   {}\n \n   // Copy constructor includes clone for expr_in_parens\n   GroupedExpr (GroupedExpr const &other)\n-    : ExprWithoutBlock (other), inner_attrs (other.inner_attrs),\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), inner_attrs (other.inner_attrs),\n       locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n@@ -893,7 +906,7 @@ class GroupedExpr : public ExprWithoutBlock\n     ExprWithoutBlock::operator= (other);\n     inner_attrs = other.inner_attrs;\n     locus = other.locus;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.expr_in_parens != nullptr)\n@@ -1090,9 +1103,9 @@ class ArrayElemsCopied : public ArrayElems\n // Array definition-ish expression\n class ArrayExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::vector<Attribute> inner_attrs;\n   std::unique_ptr<ArrayElems> internal_elements;\n-\n   Location locus;\n \n   // TODO: find another way to store this to save memory?\n@@ -1104,21 +1117,26 @@ class ArrayExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n   std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n   // Returns whether array expr has array elems or if it is just empty.\n   bool has_array_elems () const { return internal_elements != nullptr; }\n \n   // Constructor requires ArrayElems pointer\n   ArrayExpr (std::unique_ptr<ArrayElems> array_elems,\n \t     std::vector<Attribute> inner_attribs,\n \t     std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       inner_attrs (std::move (inner_attribs)),\n       internal_elements (std::move (array_elems)), locus (locus)\n   {}\n \n   // Copy constructor requires cloning ArrayElems for polymorphism to hold\n   ArrayExpr (ArrayExpr const &other)\n-    : ExprWithoutBlock (other), inner_attrs (other.inner_attrs),\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), inner_attrs (other.inner_attrs),\n       locus (other.locus), marked_for_strip (other.marked_for_strip)\n   {\n     if (other.has_array_elems ())\n@@ -1132,7 +1150,7 @@ class ArrayExpr : public ExprWithoutBlock\n     inner_attrs = other.inner_attrs;\n     locus = other.locus;\n     marked_for_strip = other.marked_for_strip;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     if (other.has_array_elems ())\n       internal_elements = other.internal_elements->clone_array_elems ();\n@@ -1178,9 +1196,9 @@ class ArrayExpr : public ExprWithoutBlock\n  * implementation */\n class ArrayIndexExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> array_expr;\n   std::unique_ptr<Expr> index_expr;\n-\n   Location locus;\n \n public:\n@@ -1189,14 +1207,14 @@ class ArrayIndexExpr : public ExprWithoutBlock\n   ArrayIndexExpr (std::unique_ptr<Expr> array_expr,\n \t\t  std::unique_ptr<Expr> array_index_expr,\n \t\t  std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       array_expr (std::move (array_expr)),\n       index_expr (std::move (array_index_expr)), locus (locus)\n   {}\n \n   // Copy constructor requires special cloning due to unique_ptr\n   ArrayIndexExpr (ArrayIndexExpr const &other)\n-    : ExprWithoutBlock (other), locus (other.locus)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.array_expr != nullptr)\n@@ -1209,7 +1227,7 @@ class ArrayIndexExpr : public ExprWithoutBlock\n   ArrayIndexExpr &operator= (ArrayIndexExpr const &other)\n   {\n     ExprWithoutBlock::operator= (other);\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n     // guard to prevent null dereference (only required if error state)\n@@ -1259,6 +1277,11 @@ class ArrayIndexExpr : public ExprWithoutBlock\n     return index_expr;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1271,11 +1294,9 @@ class ArrayIndexExpr : public ExprWithoutBlock\n // AST representation of a tuple\n class TupleExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::vector<Attribute> inner_attrs;\n-\n   std::vector<std::unique_ptr<Expr> > tuple_elems;\n-  // replaces (inlined version of) TupleElements\n-\n   Location locus;\n \n   // TODO: find another way to store this to save memory?\n@@ -1287,17 +1308,22 @@ class TupleExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n   std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n   TupleExpr (std::vector<std::unique_ptr<Expr> > tuple_elements,\n \t     std::vector<Attribute> inner_attribs,\n \t     std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       inner_attrs (std::move (inner_attribs)),\n       tuple_elems (std::move (tuple_elements)), locus (locus)\n   {}\n \n   // copy constructor with vector clone\n   TupleExpr (TupleExpr const &other)\n-    : ExprWithoutBlock (other), inner_attrs (other.inner_attrs),\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), inner_attrs (other.inner_attrs),\n       locus (other.locus), marked_for_strip (other.marked_for_strip)\n   {\n     tuple_elems.reserve (other.tuple_elems.size ());\n@@ -1309,6 +1335,7 @@ class TupleExpr : public ExprWithoutBlock\n   TupleExpr &operator= (TupleExpr const &other)\n   {\n     ExprWithoutBlock::operator= (other);\n+    outer_attrs = other.outer_attrs;\n     inner_attrs = other.inner_attrs;\n     locus = other.locus;\n     marked_for_strip = other.marked_for_strip;\n@@ -1359,6 +1386,7 @@ class TupleExpr : public ExprWithoutBlock\n // AST representation of a tuple indexing expression\n class TupleIndexExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> tuple_expr;\n   // TupleIndex is a decimal int literal with no underscores or suffix\n   TupleIndex tuple_index;\n@@ -1374,13 +1402,13 @@ class TupleIndexExpr : public ExprWithoutBlock\n \n   TupleIndexExpr (std::unique_ptr<Expr> tuple_expr, TupleIndex index,\n \t\t  std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       tuple_expr (std::move (tuple_expr)), tuple_index (index), locus (locus)\n   {}\n \n   // Copy constructor requires a clone for tuple_expr\n   TupleIndexExpr (TupleIndexExpr const &other)\n-    : ExprWithoutBlock (other), tuple_index (other.tuple_index),\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), tuple_index (other.tuple_index),\n       locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n@@ -1394,7 +1422,7 @@ class TupleIndexExpr : public ExprWithoutBlock\n     ExprWithoutBlock::operator= (other);\n     tuple_index = other.tuple_index;\n     locus = other.locus;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.tuple_expr != nullptr)\n@@ -1425,6 +1453,11 @@ class TupleIndexExpr : public ExprWithoutBlock\n     return tuple_expr;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1437,13 +1470,14 @@ class TupleIndexExpr : public ExprWithoutBlock\n // Base struct/tuple/union value creator AST node (abstract)\n class StructExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   PathInExpression struct_name;\n \n protected:\n   // Protected constructor to allow initialising struct_name\n   StructExpr (PathInExpression struct_path,\n \t      std::vector<Attribute> outer_attribs)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       struct_name (std::move (struct_path))\n   {}\n \n@@ -1459,6 +1493,11 @@ class StructExpr : public ExprWithoutBlock\n     struct_name = PathInExpression::create_error ();\n   }\n   bool is_marked_for_strip () const override { return struct_name.is_error (); }\n+\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n };\n \n // Actual AST node of the struct creator (with no fields). Not abstract!\n@@ -1936,13 +1975,14 @@ class StructExprUnit : public StructExpr\n // Base AST node representing creation of an enum variant instance - abstract\n class EnumVariantExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   PathInExpression enum_variant_path;\n \n protected:\n   // Protected constructor for initialising enum_variant_path\n   EnumVariantExpr (PathInExpression path_to_enum_variant,\n \t\t   std::vector<Attribute> outer_attribs)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       enum_variant_path (std::move (path_to_enum_variant))\n   {}\n \n@@ -1962,6 +2002,11 @@ class EnumVariantExpr : public ExprWithoutBlock\n   {\n     return enum_variant_path.is_error ();\n   }\n+\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n };\n \n /* Base AST node for a single enum expression field (in enum instance creation)\n@@ -2183,7 +2228,6 @@ class EnumExprStruct : public EnumVariantExpr\n class EnumExprTuple : public EnumVariantExpr\n {\n   std::vector<std::unique_ptr<Expr> > values;\n-\n   Location locus;\n \n public:\n@@ -2282,10 +2326,9 @@ class Function;\n // Function call expression AST node\n class CallExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> function;\n-  // inlined form of CallParams\n   std::vector<std::unique_ptr<Expr> > params;\n-\n   Location locus;\n \n public:\n@@ -2296,14 +2339,14 @@ class CallExpr : public ExprWithoutBlock\n   CallExpr (std::unique_ptr<Expr> function_expr,\n \t    std::vector<std::unique_ptr<Expr> > function_params,\n \t    std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       function (std::move (function_expr)),\n       params (std::move (function_params)), locus (locus)\n   {}\n \n   // copy constructor requires clone\n   CallExpr (CallExpr const &other)\n-    : ExprWithoutBlock (other), locus (other.locus)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.function != nullptr)\n@@ -2319,7 +2362,7 @@ class CallExpr : public ExprWithoutBlock\n   {\n     ExprWithoutBlock::operator= (other);\n     locus = other.locus;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.function != nullptr)\n@@ -2373,6 +2416,11 @@ class CallExpr : public ExprWithoutBlock\n     return function;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2385,11 +2433,10 @@ class CallExpr : public ExprWithoutBlock\n // Method call expression AST node\n class MethodCallExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> receiver;\n   PathExprSegment method_name;\n-  // inlined form of CallParams\n   std::vector<std::unique_ptr<Expr> > params;\n-\n   Location locus;\n \n public:\n@@ -2399,15 +2446,15 @@ class MethodCallExpr : public ExprWithoutBlock\n \t\t  PathExprSegment method_path,\n \t\t  std::vector<std::unique_ptr<Expr> > method_params,\n \t\t  std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       receiver (std::move (call_receiver)),\n       method_name (std::move (method_path)), params (std::move (method_params)),\n       locus (locus)\n   {}\n \n   // copy constructor required due to cloning\n   MethodCallExpr (MethodCallExpr const &other)\n-    : ExprWithoutBlock (other), method_name (other.method_name),\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), method_name (other.method_name),\n       locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n@@ -2425,7 +2472,7 @@ class MethodCallExpr : public ExprWithoutBlock\n     ExprWithoutBlock::operator= (other);\n     method_name = other.method_name;\n     locus = other.locus;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.receiver != nullptr)\n@@ -2470,6 +2517,11 @@ class MethodCallExpr : public ExprWithoutBlock\n   const PathExprSegment &get_method_name () const { return method_name; }\n   PathExprSegment &get_method_name () { return method_name; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2483,9 +2535,9 @@ class MethodCallExpr : public ExprWithoutBlock\n // Struct or union field access expression AST node\n class FieldAccessExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> receiver;\n   Identifier field;\n-\n   Location locus;\n \n public:\n@@ -2494,14 +2546,14 @@ class FieldAccessExpr : public ExprWithoutBlock\n   FieldAccessExpr (std::unique_ptr<Expr> field_access_receiver,\n \t\t   Identifier field_name, std::vector<Attribute> outer_attribs,\n \t\t   Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       receiver (std::move (field_access_receiver)),\n       field (std::move (field_name)), locus (locus)\n   {}\n \n   // Copy constructor required due to unique_ptr cloning\n   FieldAccessExpr (FieldAccessExpr const &other)\n-    : ExprWithoutBlock (other), field (other.field), locus (other.locus)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), field (other.field), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.receiver != nullptr)\n@@ -2514,7 +2566,7 @@ class FieldAccessExpr : public ExprWithoutBlock\n     ExprWithoutBlock::operator= (other);\n     field = other.field;\n     locus = other.locus;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.receiver != nullptr)\n@@ -2547,6 +2599,11 @@ class FieldAccessExpr : public ExprWithoutBlock\n \n   Identifier get_field_name () const { return field; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2645,17 +2702,15 @@ struct ClosureParam\n // Base closure definition expression AST node - abstract\n class ClosureExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   bool has_move;\n   std::vector<ClosureParam> params; // may be empty\n-  /* also note a double pipe \"||\" can be used for empty params - does not need a\n-   * space */\n-\n   Location locus;\n \n protected:\n   ClosureExpr (std::vector<ClosureParam> closure_params, bool has_move,\n \t       std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)), has_move (has_move),\n+    : outer_attrs (std::move (outer_attribs)), has_move (has_move),\n       params (std::move (closure_params)), locus (locus)\n   {}\n \n@@ -2668,6 +2723,11 @@ class ClosureExpr : public ExprWithoutBlock\n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   const std::vector<ClosureParam> &get_params () const { return params; }\n   std::vector<ClosureParam> &get_params () { return params; }\n+\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n };\n \n // Represents a non-type-specified closure expression AST node\n@@ -2746,13 +2806,10 @@ class ClosureExprInner : public ClosureExpr\n // A block AST node\n class BlockExpr : public ExprWithBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::vector<Attribute> inner_attrs;\n-\n-  // bool has_statements;\n   std::vector<std::unique_ptr<Stmt> > statements;\n-  // bool has_expr;\n-  std::unique_ptr<ExprWithoutBlock> expr; // inlined from Statements\n-\n+  std::unique_ptr<ExprWithoutBlock> expr; \n   Location locus;\n   bool marked_for_strip = false;\n \n@@ -2769,15 +2826,15 @@ class BlockExpr : public ExprWithBlock\n \t     std::unique_ptr<ExprWithoutBlock> block_expr,\n \t     std::vector<Attribute> inner_attribs,\n \t     std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       inner_attrs (std::move (inner_attribs)),\n       statements (std::move (block_statements)), expr (std::move (block_expr)),\n       locus (locus)\n   {}\n \n   // Copy constructor with clone\n   BlockExpr (BlockExpr const &other)\n-    : ExprWithBlock (other), inner_attrs (other.inner_attrs),\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs), inner_attrs (other.inner_attrs),\n       locus (other.locus), marked_for_strip (other.marked_for_strip)\n   {\n     // guard to protect from null pointer dereference\n@@ -2796,7 +2853,7 @@ class BlockExpr : public ExprWithBlock\n     inner_attrs = other.inner_attrs;\n     locus = other.locus;\n     marked_for_strip = other.marked_for_strip;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to protect from null pointer dereference\n     if (other.expr != nullptr)\n@@ -2861,6 +2918,11 @@ class BlockExpr : public ExprWithBlock\n   // Removes the tail expression from the block.\n   void strip_tail_expr () { expr = nullptr; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2970,7 +3032,7 @@ class ClosureExprInnerTyped : public ClosureExpr\n // AST node representing continue expression within loops\n class ContinueExpr : public ExprWithoutBlock\n {\n-  // bool has_label;\n+  std::vector<Attribute> outer_attrs;\n   Lifetime label;\n   Location locus;\n \n@@ -2984,10 +3046,9 @@ class ContinueExpr : public ExprWithoutBlock\n   bool has_label () const { return !label.is_error (); }\n \n   // Constructor for a ContinueExpr with a label.\n-  ContinueExpr (Location locus, Lifetime label = Lifetime::error (),\n-\t\tstd::vector<Attribute> outer_attribs\n-\t\t= std::vector<Attribute> ())\n-    : ExprWithoutBlock (std::move (outer_attribs)), label (std::move (label)),\n+  ContinueExpr (Lifetime label,\n+\t\tstd::vector<Attribute> outer_attribs, Location locus)\n+    : outer_attrs (std::move (outer_attribs)), label (std::move (label)),\n       locus (locus)\n   {}\n \n@@ -3000,6 +3061,11 @@ class ContinueExpr : public ExprWithoutBlock\n   void mark_for_strip () override { marked_for_strip = true; }\n   bool is_marked_for_strip () const override { return marked_for_strip; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3013,12 +3079,9 @@ class ContinueExpr : public ExprWithoutBlock\n // AST node representing break expression within loops\n class BreakExpr : public ExprWithoutBlock\n {\n-  // bool has_label;\n+  std::vector<Attribute> outer_attrs;\n   Lifetime label;\n-\n-  // bool has_break_expr;\n   std::unique_ptr<Expr> break_expr;\n-\n   Location locus;\n \n   // TODO: find another way to store this to save memory?\n@@ -3035,17 +3098,17 @@ class BreakExpr : public ExprWithoutBlock\n   bool has_break_expr () const { return break_expr != nullptr; }\n \n   // Constructor for a break expression\n-  BreakExpr (Location locus, Lifetime break_label = Lifetime::error (),\n-\t     std::unique_ptr<Expr> expr_in_break = nullptr,\n-\t     std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+  BreakExpr (Lifetime break_label,\n+\t     std::unique_ptr<Expr> expr_in_break,\n+\t     std::vector<Attribute> outer_attribs, Location locus)\n+    : outer_attrs (std::move (outer_attribs)),\n       label (std::move (break_label)), break_expr (std::move (expr_in_break)),\n       locus (locus)\n   {}\n \n   // Copy constructor defined to use clone for unique pointer\n   BreakExpr (BreakExpr const &other)\n-    : ExprWithoutBlock (other), label (other.label), locus (other.locus),\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), label (other.label), locus (other.locus),\n       marked_for_strip (other.marked_for_strip)\n   {\n     // guard to protect from null pointer dereference\n@@ -3060,7 +3123,7 @@ class BreakExpr : public ExprWithoutBlock\n     label = other.label;\n     locus = other.locus;\n     marked_for_strip = other.marked_for_strip;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to protect from null pointer dereference\n     if (other.break_expr != nullptr)\n@@ -3091,6 +3154,11 @@ class BreakExpr : public ExprWithoutBlock\n     return break_expr;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3107,13 +3175,14 @@ class RangeExpr : public ExprWithoutBlock\n \n protected:\n   // outer attributes not allowed before range expressions\n-  RangeExpr (Location locus)\n-    : ExprWithoutBlock (std::vector<Attribute> ()), locus (locus)\n-  {}\n+  RangeExpr (Location locus) : locus (locus) {}\n \n public:\n   Location get_locus () const { return locus; }\n   Location get_locus_slow () const final override { return get_locus (); }\n+\n+  // should never be called - error if called\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { rust_assert (false); }\n };\n \n // Range from (inclusive) and to (exclusive) expression AST node object\n@@ -3501,8 +3570,8 @@ class RangeToInclExpr : public RangeExpr\n // Return expression AST node representation\n class ReturnExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> return_expr;\n-\n   Location locus;\n \n   // TODO: find another way to store this to save memory?\n@@ -3516,15 +3585,15 @@ class ReturnExpr : public ExprWithoutBlock\n   bool has_returned_expr () const { return return_expr != nullptr; }\n \n   // Constructor for ReturnExpr.\n-  ReturnExpr (Location locus, std::unique_ptr<Expr> returned_expr = nullptr,\n-\t      std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+  ReturnExpr (std::unique_ptr<Expr> returned_expr,\n+\t      std::vector<Attribute> outer_attribs, Location locus)\n+    : outer_attrs (std::move (outer_attribs)),\n       return_expr (std::move (returned_expr)), locus (locus)\n   {}\n \n   // Copy constructor with clone\n   ReturnExpr (ReturnExpr const &other)\n-    : ExprWithoutBlock (other), locus (other.locus),\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), locus (other.locus),\n       marked_for_strip (other.marked_for_strip)\n   {\n     // guard to protect from null pointer dereference\n@@ -3538,7 +3607,7 @@ class ReturnExpr : public ExprWithoutBlock\n     ExprWithoutBlock::operator= (other);\n     locus = other.locus;\n     marked_for_strip = other.marked_for_strip;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to protect from null pointer dereference\n     if (other.return_expr != nullptr)\n@@ -3569,6 +3638,11 @@ class ReturnExpr : public ExprWithoutBlock\n     return return_expr;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3584,6 +3658,7 @@ class MacroInvocation;\n // An unsafe block AST node\n class UnsafeBlockExpr : public ExprWithBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   // Or just have it extend BlockExpr\n   std::unique_ptr<BlockExpr> expr;\n   Location locus;\n@@ -3593,13 +3668,13 @@ class UnsafeBlockExpr : public ExprWithBlock\n \n   UnsafeBlockExpr (std::unique_ptr<BlockExpr> block_expr,\n \t\t   std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithBlock (std::move (outer_attribs)), expr (std::move (block_expr)),\n+    : outer_attrs (std::move (outer_attribs)), expr (std::move (block_expr)),\n       locus (locus)\n   {}\n \n   // Copy constructor with clone\n   UnsafeBlockExpr (UnsafeBlockExpr const &other)\n-    : ExprWithBlock (other), locus (other.locus)\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.expr != nullptr)\n@@ -3611,7 +3686,7 @@ class UnsafeBlockExpr : public ExprWithBlock\n   {\n     ExprWithBlock::operator= (other);\n     locus = other.locus;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.expr != nullptr)\n@@ -3642,6 +3717,11 @@ class UnsafeBlockExpr : public ExprWithBlock\n     return expr;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3679,9 +3759,8 @@ class BaseLoopExpr : public ExprWithBlock\n {\n protected:\n   // protected to allow subclasses better use of them\n-  // bool has_loop_label;\n+  std::vector<Attribute> outer_attrs;\n   LoopLabel loop_label;\n-\n   std::unique_ptr<BlockExpr> loop_block;\n \n private:\n@@ -3693,14 +3772,14 @@ class BaseLoopExpr : public ExprWithBlock\n \t\tLoopLabel loop_label = LoopLabel::error (),\n \t\tstd::vector<Attribute> outer_attribs\n \t\t= std::vector<Attribute> ())\n-    : ExprWithBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       loop_label (std::move (loop_label)), loop_block (std::move (loop_block)),\n       locus (locus)\n   {}\n \n   // Copy constructor for BaseLoopExpr with clone\n   BaseLoopExpr (BaseLoopExpr const &other)\n-    : ExprWithBlock (other), loop_label (other.loop_label), locus (other.locus)\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs), loop_label (other.loop_label), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.loop_block != nullptr)\n@@ -3713,7 +3792,7 @@ class BaseLoopExpr : public ExprWithBlock\n     ExprWithBlock::operator= (other);\n     loop_label = other.loop_label;\n     locus = other.locus;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.loop_block != nullptr)\n@@ -3744,6 +3823,11 @@ class BaseLoopExpr : public ExprWithBlock\n     rust_assert (loop_block != nullptr);\n     return loop_block;\n   }\n+\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n };\n \n // 'Loop' expression (i.e. the infinite loop) AST node\n@@ -3989,16 +4073,14 @@ class IfExpr : public ExprWithBlock\n {\n   std::unique_ptr<Expr> condition;\n   std::unique_ptr<BlockExpr> if_block;\n-\n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n   IfExpr (std::unique_ptr<Expr> condition, std::unique_ptr<BlockExpr> if_block,\n \t  Location locus)\n-    : ExprWithBlock (std::vector<Attribute> ()),\n-      condition (std::move (condition)), if_block (std::move (if_block)),\n+    : condition (std::move (condition)), if_block (std::move (if_block)),\n       locus (locus)\n   {}\n   // outer attributes are never allowed on IfExprs\n@@ -4079,6 +4161,9 @@ class IfExpr : public ExprWithBlock\n     return if_block == nullptr && condition == nullptr;\n   }\n \n+  // this should never be called\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { rust_assert (false); }\n+\n protected:\n   // Base clone function but still concrete as concrete base class\n   virtual IfExpr *clone_if_expr_impl () const { return new IfExpr (*this); }\n@@ -4209,7 +4294,6 @@ class IfExprConseqIf : public IfExpr\n // Basic \"if let\" expression AST node with no else\n class IfLetExpr : public ExprWithBlock\n {\n-  // MatchArmPatterns patterns;\n   std::vector<std::unique_ptr<Pattern> > match_arm_patterns; // inlined\n   std::unique_ptr<Expr> value;\n   std::unique_ptr<BlockExpr> if_block;\n@@ -4221,8 +4305,7 @@ class IfLetExpr : public ExprWithBlock\n   IfLetExpr (std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n \t     std::unique_ptr<Expr> value, std::unique_ptr<BlockExpr> if_block,\n \t     Location locus)\n-    : ExprWithBlock (std::vector<Attribute> ()),\n-      match_arm_patterns (std::move (match_arm_patterns)),\n+    : match_arm_patterns (std::move (match_arm_patterns)),\n       value (std::move (value)), if_block (std::move (if_block)), locus (locus)\n   {}\n   // outer attributes not allowed on if let exprs either\n@@ -4315,6 +4398,9 @@ class IfLetExpr : public ExprWithBlock\n     return match_arm_patterns;\n   }\n \n+  // this should never be called\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { rust_assert (false); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base (or rather this or any derived object) */\n@@ -4826,15 +4912,10 @@ class MatchCaseExpr : public MatchCase\n // Match expression AST node\n class MatchExpr : public ExprWithBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> branch_value;\n   std::vector<Attribute> inner_attrs;\n-\n-  // bool has_match_arms;\n-  // MatchArms match_arms;\n-  // std::vector<std::unique_ptr<MatchCase> > match_arms; // inlined from\n-  // MatchArms\n   std::vector<MatchCase> match_arms;\n-\n   Location locus;\n \n public:\n@@ -4844,28 +4925,23 @@ class MatchExpr : public ExprWithBlock\n   bool has_match_arms () const { return !match_arms.empty (); }\n \n   MatchExpr (std::unique_ptr<Expr> branch_value,\n-\t     // std::vector<std::unique_ptr<MatchCase> > match_arms,\n \t     std::vector<MatchCase> match_arms,\n \t     std::vector<Attribute> inner_attrs,\n \t     std::vector<Attribute> outer_attrs, Location locus)\n-    : ExprWithBlock (std::move (outer_attrs)),\n+    : outer_attrs (std::move (outer_attrs)),\n       branch_value (std::move (branch_value)),\n       inner_attrs (std::move (inner_attrs)),\n       match_arms (std::move (match_arms)), locus (locus)\n   {}\n \n   // Copy constructor requires clone due to unique_ptr\n   MatchExpr (MatchExpr const &other)\n-    : ExprWithBlock (other), inner_attrs (other.inner_attrs),\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs), inner_attrs (other.inner_attrs),\n       match_arms (other.match_arms), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.branch_value != nullptr)\n       branch_value = other.branch_value->clone_expr ();\n-\n-    /*match_arms.reserve (other.match_arms.size ());\n-    for (const auto &e : other.match_arms)\n-      match_arms.push_back (e->clone_match_case ());*/\n   }\n \n   // Overloaded assignment operator to clone due to unique_ptr\n@@ -4874,7 +4950,7 @@ class MatchExpr : public ExprWithBlock\n     ExprWithBlock::operator= (other);\n     inner_attrs = other.inner_attrs;\n     match_arms = other.match_arms;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n     // guard to prevent null dereference (only required if error state)\n@@ -4883,10 +4959,6 @@ class MatchExpr : public ExprWithBlock\n     else\n       branch_value = nullptr;\n \n-    /*match_arms.reserve (other.match_arms.size ());\n-    for (const auto &e : other.match_arms)\n-      match_arms.push_back (e->clone_match_case ());*/\n-\n     return *this;\n   }\n \n@@ -4907,6 +4979,11 @@ class MatchExpr : public ExprWithBlock\n   const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n   std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Expr> &get_scrutinee_expr ()\n   {\n@@ -4929,20 +5006,21 @@ class MatchExpr : public ExprWithBlock\n // Await expression AST node (pseudo-member variable access)\n class AwaitExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> awaited_expr;\n   Location locus;\n \n public:\n   // TODO: ensure outer attributes are actually allowed\n   AwaitExpr (std::unique_ptr<Expr> awaited_expr,\n \t     std::vector<Attribute> outer_attrs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attrs)),\n+    : outer_attrs (std::move (outer_attrs)),\n       awaited_expr (std::move (awaited_expr)), locus (locus)\n   {}\n \n   // copy constructor with clone\n   AwaitExpr (AwaitExpr const &other)\n-    : ExprWithoutBlock (other), locus (other.locus)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.awaited_expr != nullptr)\n@@ -4953,6 +5031,7 @@ class AwaitExpr : public ExprWithoutBlock\n   AwaitExpr &operator= (AwaitExpr const &other)\n   {\n     ExprWithoutBlock::operator= (other);\n+    outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n     // guard to prevent null dereference (only required if error state)\n@@ -4986,6 +5065,11 @@ class AwaitExpr : public ExprWithoutBlock\n     return awaited_expr;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -4999,20 +5083,21 @@ class AwaitExpr : public ExprWithoutBlock\n class AsyncBlockExpr : public ExprWithBlock\n {\n   // TODO: should this extend BlockExpr rather than be a composite of it?\n+  std::vector<Attribute> outer_attrs;\n   bool has_move;\n   std::unique_ptr<BlockExpr> block_expr;\n   Location locus;\n \n public:\n   AsyncBlockExpr (std::unique_ptr<BlockExpr> block_expr, bool has_move,\n \t\t  std::vector<Attribute> outer_attrs, Location locus)\n-    : ExprWithBlock (std::move (outer_attrs)), has_move (has_move),\n+    : outer_attrs (std::move (outer_attrs)), has_move (has_move),\n       block_expr (std::move (block_expr)), locus (locus)\n   {}\n \n   // copy constructor with clone\n   AsyncBlockExpr (AsyncBlockExpr const &other)\n-    : ExprWithBlock (other), has_move (other.has_move), locus (other.locus)\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs), has_move (other.has_move), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.block_expr != nullptr)\n@@ -5023,6 +5108,7 @@ class AsyncBlockExpr : public ExprWithBlock\n   AsyncBlockExpr &operator= (AsyncBlockExpr const &other)\n   {\n     ExprWithBlock::operator= (other);\n+    outer_attrs = other.outer_attrs;\n     has_move = other.has_move;\n     locus = other.locus;\n \n@@ -5057,6 +5143,11 @@ class AsyncBlockExpr : public ExprWithBlock\n     return block_expr;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "79d513f87409edcc42135f6694a0e91989659a62", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=3a0c8ca2156038b726e2689e9b46be4d8c40c55f", "patch": "@@ -360,6 +360,7 @@ class MacroInvocation : public TypeNoBounds,\n \t\t\tpublic Pattern,\n \t\t\tpublic ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   /*SimplePath path;\n   DelimTokenTree token_tree;*/\n   MacroInvocData invoc_data;\n@@ -375,7 +376,7 @@ class MacroInvocation : public TypeNoBounds,\n   {}*/\n   MacroInvocation (MacroInvocData invoc_data,\n \t\t   std::vector<Attribute> outer_attrs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attrs)),\n+    : outer_attrs (std::move (outer_attrs)),\n       invoc_data (std::move (invoc_data)), locus (locus)\n   {}\n \n@@ -391,6 +392,11 @@ class MacroInvocation : public TypeNoBounds,\n     return invoc_data.is_marked_for_strip ();\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "b30dffca6e6041e873f3e6001fd250e637f9ffe5", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=3a0c8ca2156038b726e2689e9b46be4d8c40c55f", "patch": "@@ -311,30 +311,28 @@ class PathPattern : public Pattern\n  * arguments) */\n class PathInExpression : public PathPattern, public PathExpr\n {\n+  std::vector<Attribute> outer_attrs;\n   bool has_opening_scope_resolution;\n   Location locus;\n-\n   NodeId _node_id;\n \n public:\n   std::string as_string () const override;\n \n   // Constructor\n   PathInExpression (std::vector<PathExprSegment> path_segments,\n-\t\t    Location locus = Location (),\n-\t\t    bool has_opening_scope_resolution = false,\n-\t\t    std::vector<Attribute> outer_attrs\n-\t\t    = std::vector<Attribute> ())\n+\t\t    std::vector<Attribute> outer_attrs, Location locus,\n+\t\t    bool has_opening_scope_resolution = false)\n     : PathPattern (std::move (path_segments)),\n-      PathExpr (std::move (outer_attrs)),\n+      outer_attrs (std::move (outer_attrs)),\n       has_opening_scope_resolution (has_opening_scope_resolution),\n       locus (locus), _node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Creates an error state path in expression.\n   static PathInExpression create_error ()\n   {\n-    return PathInExpression (std::vector<PathExprSegment> ());\n+    return PathInExpression ({}, {}, Location ());\n   }\n \n   // Returns whether path in expression is in an error state.\n@@ -360,10 +358,16 @@ class PathInExpression : public PathPattern, public PathExpr\n   // Invalid if path is empty (error state), so base stripping on that.\n   void mark_for_strip () override { remove_all_segments (); }\n   bool is_marked_for_strip () const override { return is_error (); }\n-  bool opening_scope_resolution () { return has_opening_scope_resolution; }\n+\n+  bool opening_scope_resolution () const { return has_opening_scope_resolution; }\n \n   NodeId get_node_id () const override { return _node_id; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -835,6 +839,7 @@ struct QualifiedPathType\n  * allows specifying trait functions) */\n class QualifiedPathInExpression : public PathPattern, public PathExpr\n {\n+  std::vector<Attribute> outer_attrs;\n   QualifiedPathType path_type;\n   Location locus;\n \n@@ -843,11 +848,10 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n \n   QualifiedPathInExpression (QualifiedPathType qual_path_type,\n \t\t\t     std::vector<PathExprSegment> path_segments,\n-\t\t\t     Location locus = Location (),\n-\t\t\t     std::vector<Attribute> outer_attrs\n-\t\t\t     = std::vector<Attribute> ())\n+\t\t\t     std::vector<Attribute> outer_attrs,\n+           Location locus)\n     : PathPattern (std::move (path_segments)),\n-      PathExpr (std::move (outer_attrs)),\n+      outer_attrs (std::move (outer_attrs)),\n       path_type (std::move (qual_path_type)), locus (locus)\n   {}\n \n@@ -861,7 +865,7 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n   static QualifiedPathInExpression create_error ()\n   {\n     return QualifiedPathInExpression (QualifiedPathType::create_error (),\n-\t\t\t\t      std::vector<PathExprSegment> ());\n+\t\t\t\t      {}, {}, Location ());\n   }\n \n   Location get_locus () const { return locus; }\n@@ -883,6 +887,11 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n     return path_type;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "2f4c010ed9d13a1e3314b8b4d453119ee6271b2a", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 13, "deletions": 56, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=3a0c8ca2156038b726e2689e9b46be4d8c40c55f", "patch": "@@ -1529,13 +1529,12 @@ class AttrVisitor : public AST::ASTVisitor\n   }\n   void visit (AST::IfExpr &expr) override\n   {\n-    // initial strip test based on outer attrs\n-    expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n-      {\n-\texpr.mark_for_strip ();\n-\treturn;\n-      }\n+    // TODO: for if expressions, are attributes allowed if it is part of an expression statement?\n+    // if so, probably have to add a \"does_expr_allow_attrs()\" method to Expr and then don't move attrs.\n+    // otherwise, that may be useful anyway for better error messages. \n+\n+    // NOTE: IfExpr literally doesn't support outer attrs, so no strip code\n+    // TODO: is this still true? can't find info on page\n \n     // can't strip condition expr itself, but can strip sub-expressions\n     auto &condition_expr = expr.get_condition_expr ();\n@@ -1555,13 +1554,7 @@ class AttrVisitor : public AST::ASTVisitor\n   }\n   void visit (AST::IfExprConseqElse &expr) override\n   {\n-    // initial strip test based on outer attrs\n-    expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n-      {\n-\texpr.mark_for_strip ();\n-\treturn;\n-      }\n+    // NOTE: IfExpr literally doesn't support outer attrs, so no strip code\n \n     // can't strip condition expr itself, but can strip sub-expressions\n     auto &condition_expr = expr.get_condition_expr ();\n@@ -1589,13 +1582,7 @@ class AttrVisitor : public AST::ASTVisitor\n   }\n   void visit (AST::IfExprConseqIf &expr) override\n   {\n-    // initial strip test based on outer attrs\n-    expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n-      {\n-\texpr.mark_for_strip ();\n-\treturn;\n-      }\n+    // NOTE: IfExpr literally doesn't support outer attrs, so no strip code\n \n     // can't strip condition expr itself, but can strip sub-expressions\n     auto &condition_expr = expr.get_condition_expr ();\n@@ -1623,13 +1610,7 @@ class AttrVisitor : public AST::ASTVisitor\n   }\n   void visit (AST::IfExprConseqIfLet &expr) override\n   {\n-    // initial strip test based on outer attrs\n-    expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n-      {\n-\texpr.mark_for_strip ();\n-\treturn;\n-      }\n+    // NOTE: IfExpr literally doesn't support outer attrs, so no strip code\n \n     // can't strip condition expr itself, but can strip sub-expressions\n     auto &condition_expr = expr.get_condition_expr ();\n@@ -1658,13 +1639,7 @@ class AttrVisitor : public AST::ASTVisitor\n   }\n   void visit (AST::IfLetExpr &expr) override\n   {\n-    // initial strip test based on outer attrs\n-    expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n-      {\n-\texpr.mark_for_strip ();\n-\treturn;\n-      }\n+    // NOTE: IfLetExpr literally doesn't support outer attrs, so no strip code\n \n     for (auto &pattern : expr.get_patterns ())\n       {\n@@ -1692,13 +1667,7 @@ class AttrVisitor : public AST::ASTVisitor\n   }\n   void visit (AST::IfLetExprConseqElse &expr) override\n   {\n-    // initial strip test based on outer attrs\n-    expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n-      {\n-\texpr.mark_for_strip ();\n-\treturn;\n-      }\n+    // NOTE: IfLetExpr literally doesn't support outer attrs, so no strip code\n \n     for (auto &pattern : expr.get_patterns ())\n       {\n@@ -1734,13 +1703,7 @@ class AttrVisitor : public AST::ASTVisitor\n   }\n   void visit (AST::IfLetExprConseqIf &expr) override\n   {\n-    // initial strip test based on outer attrs\n-    expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n-      {\n-\texpr.mark_for_strip ();\n-\treturn;\n-      }\n+    // NOTE: IfLetExpr literally doesn't support outer attrs, so no strip code\n \n     for (auto &pattern : expr.get_patterns ())\n       {\n@@ -1776,13 +1739,7 @@ class AttrVisitor : public AST::ASTVisitor\n   }\n   void visit (AST::IfLetExprConseqIfLet &expr) override\n   {\n-    // initial strip test based on outer attrs\n-    expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n-      {\n-\texpr.mark_for_strip ();\n-\treturn;\n-      }\n+    // NOTE: IfLetExpr literally doesn't support outer attrs, so no strip code\n \n     for (auto &pattern : expr.get_patterns ())\n       {"}, {"sha": "a0d2af99425e12d72ca2cf15f28d6b2212c58720", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=3a0c8ca2156038b726e2689e9b46be4d8c40c55f", "patch": "@@ -791,7 +791,7 @@ Parser<ManagedTokenSource>::parse_attr_input ()\n \t  }\n \n \t// create actual LiteralExpr\n-\tAST::LiteralExpr lit_expr (t->get_str (), lit_type, t->get_type_hint (),\n+\tAST::LiteralExpr lit_expr (t->get_str (), lit_type, t->get_type_hint (), {},\n \t\t\t\t   t->get_locus ());\n \n \tstd::unique_ptr<AST::AttrInputLiteral> attr_input_lit (\n@@ -6361,9 +6361,8 @@ Parser<ManagedTokenSource>::parse_path_in_expression ()\n \n   segments.shrink_to_fit ();\n \n-  return AST::PathInExpression (std::move (segments), locus,\n-\t\t\t\thas_opening_scope_resolution,\n-\t\t\t\tstd::vector<AST::Attribute> ());\n+  return AST::PathInExpression (std::move (segments), {}, locus,\n+\t\t\t\thas_opening_scope_resolution);\n }\n \n /* Parses a single path in expression path segment (including generic\n@@ -6476,8 +6475,7 @@ Parser<ManagedTokenSource>::parse_qualified_path_in_expression (\n \n   // FIXME: outer attr parsing\n   return AST::QualifiedPathInExpression (std::move (qual_path_type),\n-\t\t\t\t\t std::move (segments), locus,\n-\t\t\t\t\t std::vector<AST::Attribute> ());\n+\t\t\t\t\t std::move (segments), {}, locus);\n }\n \n // Parses the type syntactical construction at the start of a qualified path.\n@@ -7377,8 +7375,7 @@ Parser<ManagedTokenSource>::parse_literal_expr (\n   // create literal based on stuff in switch\n   return std::unique_ptr<AST::LiteralExpr> (\n     new AST::LiteralExpr (std::move (literal_value), std::move (type),\n-\t\t\t  t->get_type_hint (), t->get_locus (),\n-\t\t\t  std::move (outer_attrs)));\n+\t\t\t  t->get_type_hint (), std::move (outer_attrs), t->get_locus ()));\n }\n \n // Parses a return expression (including any expression to return).\n@@ -7406,8 +7403,8 @@ Parser<ManagedTokenSource>::parse_return_expr (\n   // FIXME: ensure this doesn't ruin the middle of any expressions or anything\n \n   return std::unique_ptr<AST::ReturnExpr> (\n-    new AST::ReturnExpr (locus, std::move (returned_expr),\n-\t\t\t std::move (outer_attrs)));\n+    new AST::ReturnExpr (std::move (returned_expr),\n+\t\t\t std::move (outer_attrs), locus));\n }\n \n /* Parses a break expression (including any label to break to AND any return\n@@ -7442,8 +7439,8 @@ Parser<ManagedTokenSource>::parse_break_expr (\n   std::unique_ptr<AST::Expr> return_expr = parse_expr ();\n \n   return std::unique_ptr<AST::BreakExpr> (\n-    new AST::BreakExpr (locus, std::move (label), std::move (return_expr),\n-\t\t\tstd::move (outer_attrs)));\n+    new AST::BreakExpr (std::move (label), std::move (return_expr),\n+\t\t\tstd::move (outer_attrs), locus));\n }\n \n // Parses a continue expression (including any label to continue from).\n@@ -7474,7 +7471,7 @@ Parser<ManagedTokenSource>::parse_continue_expr (\n     }\n \n   return std::unique_ptr<AST::ContinueExpr> (\n-    new AST::ContinueExpr (locus, std::move (label), std::move (outer_attrs)));\n+    new AST::ContinueExpr (std::move (label), std::move (outer_attrs), locus));\n }\n \n // Parses a loop label used in loop expressions.\n@@ -11488,7 +11485,7 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t    // lexer.skip_token();\n \n \t    // HACK: add outer attrs to path\n-\t    path.replace_outer_attrs (std::move (outer_attrs));\n+\t    path.set_outer_attrs (std::move (outer_attrs));\n \t    expr = std::unique_ptr<AST::PathInExpression> (\n \t      new AST::PathInExpression (std::move (path)));\n \t  }\n@@ -11539,7 +11536,7 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t// lexer.skip_token();\n \n \t// HACK: replace outer attributes in path\n-\tpath.replace_outer_attrs (std::move (outer_attrs));\n+\tpath.set_outer_attrs (std::move (outer_attrs));\n \tstd::unique_ptr<AST::PathInExpression> expr (\n \t  new AST::PathInExpression (std::move (path)));\n \n@@ -12047,11 +12044,11 @@ Parser<ManagedTokenSource>::null_denotation (\n \t\t      /* HACK: may have to become permanent, but this is my\n \t\t       * current identifier expression */\n \t\t      return std::unique_ptr<AST::IdentifierExpr> (\n-\t\t\tnew AST::IdentifierExpr (tok->get_str (),\n+\t\t\tnew AST::IdentifierExpr (tok->get_str (), {},\n \t\t\t\t\t\t tok->get_locus ()));\n \t\t    }\n \t\t  // HACK: add outer attrs to path\n-\t\t  path.replace_outer_attrs (std::move (outer_attrs));\n+\t\t  path.set_outer_attrs (std::move (outer_attrs));\n \t\t  return std::unique_ptr<AST::PathInExpression> (\n \t\t    new AST::PathInExpression (std::move (path)));\n \t\t}\n@@ -12069,11 +12066,11 @@ Parser<ManagedTokenSource>::null_denotation (\n \t\t    /* HACK: may have to become permanent, but this is my\n \t\t     * current identifier expression */\n \t\t    return std::unique_ptr<AST::IdentifierExpr> (\n-\t\t      new AST::IdentifierExpr (tok->get_str (),\n+\t\t      new AST::IdentifierExpr (tok->get_str (), {},\n \t\t\t\t\t       tok->get_locus ()));\n \t\t  }\n \t\t// HACK: add outer attrs to path\n-\t\tpath.replace_outer_attrs (std::move (outer_attrs));\n+\t\tpath.set_outer_attrs (std::move (outer_attrs));\n \t\treturn std::unique_ptr<AST::PathInExpression> (\n \t\t  new AST::PathInExpression (std::move (path)));\n \t      }\n@@ -12087,10 +12084,10 @@ Parser<ManagedTokenSource>::null_denotation (\n \t\t/* HACK: may have to become permanent, but this is my current\n \t\t * identifier expression */\n \t\treturn std::unique_ptr<AST::IdentifierExpr> (\n-\t\t  new AST::IdentifierExpr (tok->get_str (), tok->get_locus ()));\n+\t\t  new AST::IdentifierExpr (tok->get_str (), {}, tok->get_locus ()));\n \t      }\n \t    // HACK: add outer attrs to path\n-\t    path.replace_outer_attrs (std::move (outer_attrs));\n+\t    path.set_outer_attrs (std::move (outer_attrs));\n \t    return std::unique_ptr<AST::PathInExpression> (\n \t      new AST::PathInExpression (std::move (path)));\n \t  }\n@@ -12105,33 +12102,34 @@ Parser<ManagedTokenSource>::null_denotation (\n \t// HACK: add outer attrs to path\n \tAST::QualifiedPathInExpression path\n \t  = parse_qualified_path_in_expression (true);\n-\tpath.replace_outer_attrs (std::move (outer_attrs));\n+\tpath.set_outer_attrs (std::move (outer_attrs));\n \treturn std::unique_ptr<AST::QualifiedPathInExpression> (\n \t  new AST::QualifiedPathInExpression (std::move (path)));\n       }\n+    // FIXME: for literal exprs, should outer attrs be passed in or just ignored?\n     case INT_LITERAL:\n       // we should check the range, but ignore for now\n       // encode as int?\n       return std::unique_ptr<AST::LiteralExpr> (\n \tnew AST::LiteralExpr (tok->get_str (), AST::Literal::INT,\n-\t\t\t      tok->get_type_hint (), tok->get_locus ()));\n+\t\t\t      tok->get_type_hint (), {}, tok->get_locus ()));\n     case FLOAT_LITERAL:\n       // encode as float?\n       return std::unique_ptr<AST::LiteralExpr> (\n \tnew AST::LiteralExpr (tok->get_str (), AST::Literal::FLOAT,\n-\t\t\t      tok->get_type_hint (), tok->get_locus ()));\n+\t\t\t      tok->get_type_hint (), {}, tok->get_locus ()));\n     case STRING_LITERAL:\n       return std::unique_ptr<AST::LiteralExpr> (\n \tnew AST::LiteralExpr (tok->get_str (), AST::Literal::STRING,\n-\t\t\t      tok->get_type_hint (), tok->get_locus ()));\n+\t\t\t      tok->get_type_hint (), {}, tok->get_locus ()));\n     case TRUE_LITERAL:\n       return std::unique_ptr<AST::LiteralExpr> (\n \tnew AST::LiteralExpr (\"true\", AST::Literal::BOOL, tok->get_type_hint (),\n-\t\t\t      tok->get_locus ()));\n+\t\t\t      {}, tok->get_locus ()));\n     case FALSE_LITERAL:\n       return std::unique_ptr<AST::LiteralExpr> (\n \tnew AST::LiteralExpr (\"false\", AST::Literal::BOOL,\n-\t\t\t      tok->get_type_hint (), tok->get_locus ()));\n+\t\t\t      tok->get_type_hint (), {}, tok->get_locus ()));\n       case LEFT_PAREN: { // have to parse whole expression if inside brackets\n \t/* recursively invoke parse_expression with lowest priority possible as\n \t * it it were a top-level expression. */\n@@ -12170,7 +12168,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \tParseRestrictions entered_from_unary;\n \tentered_from_unary.entered_from_unary = true;\n \tstd::unique_ptr<AST::Expr> expr\n-\t  = parse_expr (LBP_UNARY_MINUS, std::vector<AST::Attribute> (),\n+\t  = parse_expr (LBP_UNARY_MINUS, {},\n \t\t\tentered_from_unary);\n \n \tif (expr == nullptr)\n@@ -12195,7 +12193,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \tParseRestrictions entered_from_unary;\n \tentered_from_unary.entered_from_unary = true;\n \tstd::unique_ptr<AST::Expr> expr\n-\t  = parse_expr (LBP_UNARY_EXCLAM, std::vector<AST::Attribute> (),\n+\t  = parse_expr (LBP_UNARY_EXCLAM, {},\n \t\t\tentered_from_unary);\n \n \tif (expr == nullptr)\n@@ -12222,7 +12220,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \tentered_from_unary.entered_from_unary = true;\n \tentered_from_unary.can_be_struct_expr = false;\n \tstd::unique_ptr<AST::Expr> expr\n-\t  = parse_expr (LBP_UNARY_ASTERISK, std::vector<AST::Attribute> (),\n+\t  = parse_expr (LBP_UNARY_ASTERISK, {},\n \t\t\tentered_from_unary);\n \t// FIXME: allow outer attributes on expression\n \treturn std::unique_ptr<AST::DereferenceExpr> (\n@@ -12245,13 +12243,13 @@ Parser<ManagedTokenSource>::null_denotation (\n \t  {\n \t    lexer.skip_token ();\n \t    expr\n-\t      = parse_expr (LBP_UNARY_AMP_MUT, std::vector<AST::Attribute> (),\n+\t      = parse_expr (LBP_UNARY_AMP_MUT, {},\n \t\t\t    entered_from_unary);\n \t    is_mut_borrow = true;\n \t  }\n \telse\n \t  {\n-\t    expr = parse_expr (LBP_UNARY_AMP, std::vector<AST::Attribute> (),\n+\t    expr = parse_expr (LBP_UNARY_AMP, {},\n \t\t\t       entered_from_unary);\n \t  }\n \n@@ -12272,13 +12270,13 @@ Parser<ManagedTokenSource>::null_denotation (\n \t  {\n \t    lexer.skip_token ();\n \t    expr\n-\t      = parse_expr (LBP_UNARY_AMP_MUT, std::vector<AST::Attribute> (),\n+\t      = parse_expr (LBP_UNARY_AMP_MUT, {},\n \t\t\t    entered_from_unary);\n \t    is_mut_borrow = true;\n \t  }\n \telse\n \t  {\n-\t    expr = parse_expr (LBP_UNARY_AMP, std::vector<AST::Attribute> (),\n+\t    expr = parse_expr (LBP_UNARY_AMP, {},\n \t\t\t       entered_from_unary);\n \t  }\n \n@@ -12317,7 +12315,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \tif (tok->get_id () == SELF && path.is_single_segment ())\n \t  {\n \t    // HACK: add outer attrs to path\n-\t    path.replace_outer_attrs (std::move (outer_attrs));\n+\t    path.set_outer_attrs (std::move (outer_attrs));\n \t    return std::unique_ptr<AST::PathInExpression> (\n \t      new AST::PathInExpression (std::move (path)));\n \t  }\n@@ -12347,7 +12345,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \t\t{\n \t\t  // assume path is returned\n \t\t  // HACK: add outer attributes to path\n-\t\t  path.replace_outer_attrs (std::move (outer_attrs));\n+\t\t  path.set_outer_attrs (std::move (outer_attrs));\n \t\t  return std::unique_ptr<AST::PathInExpression> (\n \t\t    new AST::PathInExpression (std::move (path)));\n \t\t}\n@@ -12360,7 +12358,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \t      {\n \t\t// assume path is returned\n \t\t// HACK: add outer attributes to path\n-\t\tpath.replace_outer_attrs (std::move (outer_attrs));\n+\t\tpath.set_outer_attrs (std::move (outer_attrs));\n \t\treturn std::unique_ptr<AST::PathInExpression> (\n \t\t  new AST::PathInExpression (std::move (path)));\n \t      }\n@@ -12369,7 +12367,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \t  default:\n \t    // assume path is returned\n \t    // HACK: add outer attributes to path\n-\t    path.replace_outer_attrs (std::move (outer_attrs));\n+\t    path.set_outer_attrs (std::move (outer_attrs));\n \t    return std::unique_ptr<AST::PathInExpression> (\n \t      new AST::PathInExpression (std::move (path)));\n \t  }\n@@ -14115,9 +14113,8 @@ Parser<ManagedTokenSource>::parse_struct_expr_tuple_partial (\n       exprs.push_back (std::move (expr));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t{\n \t  break;\n-\t}\n+\n       lexer.skip_token ();\n \n       t = lexer.peek_token ();\n@@ -14243,7 +14240,7 @@ Parser<ManagedTokenSource>::parse_path_in_expression_pratt (const_TokenPtr tok)\n     \"current token (just about to return path to null denotation): '%s'\\n\",\n     lexer.peek_token ()->get_token_description ());\n \n-  return AST::PathInExpression (std::move (segments), tok->get_locus (), false);\n+  return AST::PathInExpression (std::move (segments), {}, tok->get_locus (), false);\n }\n \n // Parses a closure expression with pratt parsing (from null denotation)."}]}