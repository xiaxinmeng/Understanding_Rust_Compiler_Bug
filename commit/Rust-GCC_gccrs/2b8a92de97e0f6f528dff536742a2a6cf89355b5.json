{"sha": "2b8a92de97e0f6f528dff536742a2a6cf89355b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI4YTkyZGU5N2UwZjZmNTI4ZGZmNTM2NzQyYTJhNmNmODkzNTViNQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-04-29T15:39:12Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-04-29T15:39:12Z"}, "message": "builtins.c, [...]: Fix comment typos.\n\n\t* builtins.c, cgraph.c, cgraphunit.c, final.c, fold-const.c:\n\tFix comment typos.\n\nFrom-SVN: r81291", "tree": {"sha": "6c0fb333200e6a04c7e72f1b30ce293bef0d3d4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c0fb333200e6a04c7e72f1b30ce293bef0d3d4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b8a92de97e0f6f528dff536742a2a6cf89355b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b8a92de97e0f6f528dff536742a2a6cf89355b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b8a92de97e0f6f528dff536742a2a6cf89355b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b8a92de97e0f6f528dff536742a2a6cf89355b5/comments", "author": null, "committer": null, "parents": [{"sha": "8fd583973e51d76536f33d0d57120bf69e43f408", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fd583973e51d76536f33d0d57120bf69e43f408", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fd583973e51d76536f33d0d57120bf69e43f408"}], "stats": {"total": 29, "additions": 17, "deletions": 12}, "files": [{"sha": "b660fdbf794b3d137fb7a673a713d537b50b63f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8a92de97e0f6f528dff536742a2a6cf89355b5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8a92de97e0f6f528dff536742a2a6cf89355b5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b8a92de97e0f6f528dff536742a2a6cf89355b5", "patch": "@@ -1,3 +1,8 @@\n+2004-04-29  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* builtins.c, cgraph.c, cgraphunit.c, final.c, fold-const.c:\n+\tFix comment typos.\n+\n 2004-04-29  Douglas B Rupp  <rupp@gnat.com>\n \n \t* gcc.c (DELETE_IF_ORDINARY): New macro default definition."}, {"sha": "3130f3b70890b217027fa52995d6914cacd4c228", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8a92de97e0f6f528dff536742a2a6cf89355b5/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8a92de97e0f6f528dff536742a2a6cf89355b5/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=2b8a92de97e0f6f528dff536742a2a6cf89355b5", "patch": "@@ -5134,7 +5134,7 @@ expand_builtin_fork_or_exec (tree fn, tree arglist, rtx target, int ignore)\n \n   /* Otherwise call the wrapper.  This should be equivalent for the rest of\n      compiler, so the code does not diverge, and the wrapper may run the\n-     code neccesary for keeping the profiling sane.  */\n+     code necessary for keeping the profiling sane.  */\n \n   switch (DECL_FUNCTION_CODE (fn))\n     {"}, {"sha": "0766a5dcb6be5555a49f2a83a2ae4f9a37e0c195", "filename": "gcc/cgraph.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8a92de97e0f6f528dff536742a2a6cf89355b5/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8a92de97e0f6f528dff536742a2a6cf89355b5/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=2b8a92de97e0f6f528dff536742a2a6cf89355b5", "patch": "@@ -68,8 +68,8 @@ The callgraph:\n       caller. \n \n       Each edge has \"inline_failed\" field.  When the field is set to NULL,\n-      the call will be inlined.  When it is non-NULL it contains an reason\n-      why inlining wasn't performaned.\n+      the call will be inlined.  When it is non-NULL it contains a reason\n+      why inlining wasn't performed.\n \n \n The varpool data structure:\n@@ -99,8 +99,8 @@ The varpool data structure:\n /* Hash table used to convert declarations into nodes.  */\n static GTY((param_is (struct cgraph_node))) htab_t cgraph_hash;\n \n-/* We destructivly update callgraph during inlining and thus we need to\n-   keep information on whether inlining happent separately.  */\n+/* We destructively update callgraph during inlining and thus we need to\n+   keep information on whether inlining happend separately.  */\n htab_t cgraph_inline_hash;\n \n /* The linked list of cgraph nodes.  */\n@@ -209,7 +209,7 @@ cgraph_edge (struct cgraph_node *node, tree call_expr)\n \n   /* This loop may turn out to be performance problem.  In such case adding\n      hashtables into call nodes with very many edges is probably best\n-     sollution.  It is not good idea to add pointer into CALL_EXPR itself\n+     solution.  It is not good idea to add pointer into CALL_EXPR itself\n      because we want to make possible having multiple cgraph nodes representing\n      different clones of the same body before the body is actually cloned.  */\n   for (e = node->callees; e; e= e->next_callee)"}, {"sha": "cbe468e2a9eaef0fa3ea918e1e3b129a3acfb5ee", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8a92de97e0f6f528dff536742a2a6cf89355b5/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8a92de97e0f6f528dff536742a2a6cf89355b5/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=2b8a92de97e0f6f528dff536742a2a6cf89355b5", "patch": "@@ -923,7 +923,7 @@ cgraph_remove_unreachable_nodes (void)\n      eliminated\n      Reachable extern inline functions we sometimes inlined will be turned into\n      unanalyzed nodes so they look like for true extern functions to the rest\n-     of code.  Body of such functions is relased via remove_node once the\n+     of code.  Body of such functions is released via remove_node once the\n      inline clones are eliminated.  */\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n@@ -1047,7 +1047,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate)\n   else\n     e->callee->global.inlined_to = e->caller;\n \n-  /* Recursivly clone all bodies.  */\n+  /* Recursively clone all bodies.  */\n   for (e = e->callee->callees; e; e = e->next_callee)\n     if (!e->inline_failed)\n       cgraph_clone_inlined_nodes (e, duplicate);\n@@ -1110,7 +1110,7 @@ cgraph_mark_inline (struct cgraph_edge *edge)\n   struct cgraph_edge *e, *next;\n   int times = 0;\n \n-  /* Look for all calls, mark them inline and clone recursivly\n+  /* Look for all calls, mark them inline and clone recursively\n      all inlined functions.  */\n   for (e = what->callers; e; e = next)\n     {\n@@ -1182,7 +1182,7 @@ cgraph_default_inline_p (struct cgraph_node *n)\n \n /* Return true when inlining WHAT would create recursive inlining.\n    We call recursive inlining all cases where same function appears more than\n-   once in the single recusion nest path in the inline graph.  */\n+   once in the single recursion nest path in the inline graph.  */\n \n static bool\n cgraph_recursive_inlining_p (struct cgraph_node *to,"}, {"sha": "500f4062e2dde41d8f3da29fd17e1e25bbb43c85", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8a92de97e0f6f528dff536742a2a6cf89355b5/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8a92de97e0f6f528dff536742a2a6cf89355b5/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=2b8a92de97e0f6f528dff536742a2a6cf89355b5", "patch": "@@ -1713,7 +1713,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t  \n \tcase NOTE_INSN_BASIC_BLOCK:\n \t  \n-\t  /* If we are performing the optimization that paritions\n+\t  /* If we are performing the optimization that partitions\n \t     basic blocks into hot & cold sections of the .o file,\n \t     then at the start of each new basic block, before\n \t     beginning to write code for the basic block, we need to"}, {"sha": "e2a1ffb096fe8573b4de2cfaa1b7c696981829ea", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8a92de97e0f6f528dff536742a2a6cf89355b5/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8a92de97e0f6f528dff536742a2a6cf89355b5/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=2b8a92de97e0f6f528dff536742a2a6cf89355b5", "patch": "@@ -4806,7 +4806,7 @@ count_cond (tree expr, int lim)\n    expression, and ARG to `a'.  If COND_FIRST_P is nonzero, then the\n    COND is the first argument to CODE; otherwise (as in the example\n    given here), it is the second argument.  TYPE is the type of the\n-   original expression.  Return NULL_TREE if no simplication is\n+   original expression.  Return NULL_TREE if no simplification is\n    possible.  */\n \n static tree"}]}