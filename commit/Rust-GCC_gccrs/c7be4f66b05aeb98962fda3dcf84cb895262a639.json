{"sha": "c7be4f66b05aeb98962fda3dcf84cb895262a639", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdiZTRmNjZiMDVhZWI5ODk2MmZkYTNkY2Y4NGNiODk1MjYyYTYzOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-01-17T18:27:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-01-17T18:27:37Z"}, "message": "combine.c (try_combine): Don't set i3_subst_into_i2 for case of making new double-word constant.\n\n\t* combine.c (try_combine): Don't set i3_subst_into_i2 for\n\tcase of making new double-word constant.\n\tRevert last change: instead just test i3_subst_into_i2.\n\nFrom-SVN: r39094", "tree": {"sha": "83f1f2aacb0598a9018d6c2fffeb97c179c93bf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83f1f2aacb0598a9018d6c2fffeb97c179c93bf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7be4f66b05aeb98962fda3dcf84cb895262a639", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7be4f66b05aeb98962fda3dcf84cb895262a639", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7be4f66b05aeb98962fda3dcf84cb895262a639", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7be4f66b05aeb98962fda3dcf84cb895262a639/comments", "author": null, "committer": null, "parents": [{"sha": "d70401eb2fc86f75d6a8ad6eda48386292b4a856", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d70401eb2fc86f75d6a8ad6eda48386292b4a856", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d70401eb2fc86f75d6a8ad6eda48386292b4a856"}], "stats": {"total": 14, "additions": 11, "deletions": 3}, "files": [{"sha": "3206f2ca6c536cac5fee2f1cd903ae6bd877e091", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be4f66b05aeb98962fda3dcf84cb895262a639/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be4f66b05aeb98962fda3dcf84cb895262a639/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7be4f66b05aeb98962fda3dcf84cb895262a639", "patch": "@@ -1,3 +1,9 @@\n+Wed Jan 17 13:26:34 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* combine.c (try_combine): Don't set i3_subst_into_i2 for\n+\tcase of making new double-word constant.\n+\tRevert last change: instead just test i3_subst_into_i2.\n+\n 2001-01-17  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.md (cmpqi_minus_1): Use {b} for QImode operation."}, {"sha": "6028f6ae8d1fec5d67755460b7620a84c4d5ca47", "filename": "gcc/combine.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be4f66b05aeb98962fda3dcf84cb895262a639/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be4f66b05aeb98962fda3dcf84cb895262a639/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=c7be4f66b05aeb98962fda3dcf84cb895262a639", "patch": "@@ -1558,13 +1558,16 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n   added_links_insn = 0;\n \n   /* First check for one important special-case that the code below will\n-     not handle.  Namely, the case where I1 is zero, I2 has multiple sets,\n+     not handle.  Namely, the case where I1 is zero, I2 is a PARALLEL\n      and I3 is a SET whose SET_SRC is a SET_DEST in I2.  In that case,\n      we may be able to replace that destination with the destination of I3.\n      This occurs in the common code where we compute both a quotient and\n      remainder into a structure, in which case we want to do the computation\n      directly into the structure to avoid register-register copies.\n \n+     Note that this case handles both multiple sets in I2 and also\n+     cases where I2 has a number of CLOBBER or PARALLELs.\n+\n      We make very conservative checks below and only try to handle the\n      most common cases of this.  For example, we only handle the case\n      where I2 and I3 are adjacent to avoid making difficult register\n@@ -1673,7 +1676,6 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t     immed_double_const (lo, hi, GET_MODE (SET_DEST (temp))));\n \n       newpat = PATTERN (i2);\n-      i3_subst_into_i2 = 1;\n       goto validate_replacement;\n     }\n \n@@ -2524,7 +2526,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n        actually came from I3, so that REG_UNUSED notes from I2 will be\n        properly handled.  */\n \n-    if (i3_subst_into_i2 && single_set (i2) == 0)\n+    if (i3_subst_into_i2)\n       {\n \tfor (i = 0; i < XVECLEN (PATTERN (i2), 0); i++)\n \t  if (GET_CODE (XVECEXP (PATTERN (i2), 0, i)) != USE"}]}