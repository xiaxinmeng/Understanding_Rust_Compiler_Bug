{"sha": "003e0ad60130a4ba700a7b65e58ffcf0f051076c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAzZTBhZDYwMTMwYTRiYTcwMGE3YjY1ZTU4ZmZjZjBmMDUxMDc2Yw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-01-05T21:15:52Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-01-05T21:15:52Z"}, "message": "PR fortran/PR48946\n\n2012-01-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/PR48946\n\t* resolve.c (resolve_typebound_static): If the typebound\n\tprocedure is 'deferred' try to find the correct specific\n\tprocedure in the derived type operator space itself.\n\n2012-01-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/PR48946\n\t* gfortran.dg/typebound_operator_9.f03: This is now a copy of\n\tthe old typebound_operator_8.f03.\n\t* gfortran.dg/typebound_operator_8.f03: New version of\n\ttypebound_operator_7.f03 with 'u' a derived type instead of a\n\tclass object.\n\nFrom-SVN: r182929", "tree": {"sha": "31b9d65f981832104905adc6a62d92f7429f99fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31b9d65f981832104905adc6a62d92f7429f99fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/003e0ad60130a4ba700a7b65e58ffcf0f051076c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/003e0ad60130a4ba700a7b65e58ffcf0f051076c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/003e0ad60130a4ba700a7b65e58ffcf0f051076c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/003e0ad60130a4ba700a7b65e58ffcf0f051076c/comments", "author": null, "committer": null, "parents": [{"sha": "f7d6ad0a5c2b3759f1952aa23bf5941013fec280", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d6ad0a5c2b3759f1952aa23bf5941013fec280", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7d6ad0a5c2b3759f1952aa23bf5941013fec280"}], "stats": {"total": 1126, "additions": 628, "deletions": 498}, "files": [{"sha": "879c564027e353606f7da918321e9784baa18d2e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003e0ad60130a4ba700a7b65e58ffcf0f051076c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003e0ad60130a4ba700a7b65e58ffcf0f051076c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=003e0ad60130a4ba700a7b65e58ffcf0f051076c", "patch": "@@ -1,3 +1,10 @@\n+2012-01-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/PR48946\n+\t* resolve.c (resolve_typebound_static): If the typebound\n+\tprocedure is 'deferred' try to find the correct specific\n+\tprocedure in the derived type operator space itself.\n+\n 2012-01-04  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/50981"}, {"sha": "79245ce89bf94be728dc8b7178012f6aa27858ed", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003e0ad60130a4ba700a7b65e58ffcf0f051076c/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003e0ad60130a4ba700a7b65e58ffcf0f051076c/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=003e0ad60130a4ba700a7b65e58ffcf0f051076c", "patch": "@@ -5614,6 +5614,39 @@ resolve_typebound_static (gfc_expr* e, gfc_symtree** target,\n   e->ref = NULL;\n   e->value.compcall.actual = NULL;\n \n+  /* If we find a deferred typebound procedure, check for derived types\n+     that an over-riding typebound procedure has not been missed.  */\n+  if (e->value.compcall.tbp->deferred\n+\t&& e->value.compcall.name\n+\t&& !e->value.compcall.tbp->non_overridable\n+\t&& e->value.compcall.base_object\n+\t&& e->value.compcall.base_object->ts.type == BT_DERIVED)\n+    {\n+      gfc_symtree *st;\n+      gfc_symbol *derived;\n+\n+      /* Use the derived type of the base_object.  */\n+      derived = e->value.compcall.base_object->ts.u.derived;\n+      st = NULL;\n+\n+      /* If necessary, go throught the inheritance chain.  */\n+      while (!st && derived)\n+\t{\n+\t  /* Look for the typebound procedure 'name'.  */\n+\t  if (derived->f2k_derived && derived->f2k_derived->tb_sym_root)\n+\t    st = gfc_find_symtree (derived->f2k_derived->tb_sym_root,\n+\t\t\t\t   e->value.compcall.name);\n+\t  if (!st)\n+\t    derived = gfc_get_derived_super_type (derived);\n+\t}\n+\n+      /* Now find the specific name in the derived type namespace.  */\n+      if (st && st->n.tb && st->n.tb->u.specific)\n+\tgfc_find_sym_tree (st->n.tb->u.specific->name,\n+\t\t\t   derived->ns, 1, &st);\n+      if (st)\n+\t*target = st;\n+    }\n   return SUCCESS;\n }\n "}, {"sha": "3821d7c3be6d7642ed8be1c70accc3b0d95c7471", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003e0ad60130a4ba700a7b65e58ffcf0f051076c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003e0ad60130a4ba700a7b65e58ffcf0f051076c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=003e0ad60130a4ba700a7b65e58ffcf0f051076c", "patch": "@@ -1,21 +1,11 @@\n-2012-01-05  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR debug/51762\n-\t* gcc.dg/pr51762.c: New test.\n-\n-\tPR rtl-optimization/51767\n-\t* gcc.c-torture/compile/pr51767.c: New test.\n-\n-\tPR middle-end/51768\n-\t* c-c++-common/pr51768.c: New test.\n-\n-\tPR middle-end/44777\n-\t* gcc.dg/tree-prof/pr44777.c: New test.\n-\n-2012-01-05  Jan Hubicka  <jh@suse.cz>\n-\n-\tPR middle-end/49710\n-\t* gcc.c-torture/compile/pr49710.c: New file.\n+2012-01-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/PR48946\n+\t* gfortran.dg/typebound_operator_9.f03: This is now a copy of\n+\tthe old typebound_operator_8.f03.\n+\t* gfortran.dg/typebound_operator_8.f03: New version of\n+\ttypebound_operator_7.f03 with 'u' a derived type instead of a\n+\tclass object.\n \n 2012-01-05  Richard Guenther  <rguenther@suse.de>\n "}, {"sha": "a3726ba9f1adf322fc575094081620cd58155834", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_8.f03", "status": "modified", "additions": 80, "deletions": 480, "changes": 560, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003e0ad60130a4ba700a7b65e58ffcf0f051076c/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003e0ad60130a4ba700a7b65e58ffcf0f051076c/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_8.f03?ref=003e0ad60130a4ba700a7b65e58ffcf0f051076c", "patch": "@@ -1,500 +1,100 @@\n ! { dg-do run }\n-! { dg-add-options ieee }\n+! PR48946 - complex expressions involving typebound operators of derived types.\n !\n-!     Solve a diffusion problem using an object-oriented approach\n-!\n-!     Author: Arjen Markus (comp.lang.fortran)\n-!     This version: pault@gcc.gnu.org\n-!\n-!     Note:\n-!     (i) This could be turned into a more sophisticated program\n-!     using the techniques described in the chapter on\n-!     mathematical abstractions.\n-!     (That would allow the selection of the time integration\n-!     method in a transparent way)\n-!\n-!     (ii) The target procedures for process_p and source_p are\n-!     different to the typebound procedures for dynamic types\n-!     because the passed argument is not type(base_pde_object).\n-!\n-!     (iii) Two solutions are calculated, one with the procedure\n-!     pointers and the other with typebound procedures. The sums\n-!     of the solutions are compared.\n-\n-!     (iv) The source is a delta function in the middle of the\n-!     mesh, whilst the process is quartic in the local value,\n-!     when it is positive.\n-!\n-! base_pde_objects --\n-!     Module to define the basic objects\n-!\n-module base_pde_objects\n+module field_module\n   implicit none\n-  type, abstract :: base_pde_object\n-! No data\n-    procedure(process_p), pointer, pass :: process_p\n-    procedure(source_p), pointer, pass  :: source_p\n+  type ,abstract :: field\n   contains\n-    procedure(process), deferred :: process\n-    procedure(source), deferred :: source\n-    procedure :: initialise\n-    procedure :: nabla2\n-    procedure :: print\n-    procedure(real_times_obj), pass(obj), deferred :: real_times_obj\n-    procedure(obj_plus_obj),              deferred :: obj_plus_obj\n-    procedure(obj_assign_obj),            deferred :: obj_assign_obj\n-    generic :: operator(*)    => real_times_obj\n-    generic :: operator(+)    => obj_plus_obj\n-    generic :: assignment(=)  => obj_assign_obj\n+    procedure(field_op_real) ,deferred :: multiply_real\n+    procedure(field_plus_field) ,deferred :: plus\n+    procedure(assign_field) ,deferred :: assn\n+    generic :: operator(*) => multiply_real\n+    generic :: operator(+) => plus\n+    generic :: ASSIGNMENT(=) => assn\n   end type\n   abstract interface\n-    function process_p (obj)\n-      import base_pde_object\n-      class(base_pde_object), intent(in)  :: obj\n-      class(base_pde_object), allocatable :: process_p\n-    end function process_p\n-  end interface\n-  abstract interface\n-    function source_p (obj, time)\n-      import base_pde_object\n-      class(base_pde_object), intent(in)  :: obj\n-      real, intent(in)                    :: time\n-      class(base_pde_object), allocatable :: source_p\n-    end function source_p\n+    function field_plus_field(lhs,rhs)\n+      import :: field\n+      class(field) ,intent(in)  :: lhs\n+      class(field) ,intent(in)  :: rhs\n+      class(field) ,allocatable :: field_plus_field\n+    end function\n   end interface\n   abstract interface\n-    function process (obj)\n-      import base_pde_object\n-      class(base_pde_object), intent(in)  :: obj\n-      class(base_pde_object), allocatable :: process\n-    end function process\n+    function field_op_real(lhs,rhs)\n+      import :: field\n+      class(field) ,intent(in)  :: lhs\n+      real ,intent(in) :: rhs\n+      class(field) ,allocatable :: field_op_real\n+    end function\n   end interface\n   abstract interface\n-    function source (obj, time)\n-      import base_pde_object\n-      class(base_pde_object), intent(in)  :: obj\n-      real, intent(in)                    :: time\n-      class(base_pde_object), allocatable :: source\n-    end function source\n+    subroutine assign_field(lhs,rhs)\n+      import :: field\n+      class(field) ,intent(OUT)  :: lhs\n+      class(field) ,intent(IN)  :: rhs\n+    end subroutine\n   end interface\n-  abstract interface\n-    function real_times_obj (factor, obj) result(newobj)\n-      import base_pde_object\n-      real, intent(in)                    :: factor\n-      class(base_pde_object), intent(in)  :: obj\n-      class(base_pde_object), allocatable :: newobj\n-    end function real_times_obj\n-  end interface\n-  abstract interface\n-    function obj_plus_obj (obj1, obj2) result(newobj)\n-      import base_pde_object\n-      class(base_pde_object), intent(in)  :: obj1\n-      class(base_pde_object), intent(in)  :: obj2\n-      class(base_pde_object), allocatable :: newobj\n-    end function obj_plus_obj\n-  end interface\n-  abstract interface\n-    subroutine obj_assign_obj (obj1, obj2)\n-      import base_pde_object\n-      class(base_pde_object), intent(inout)  :: obj1\n-      class(base_pde_object), intent(in)     :: obj2\n-    end subroutine obj_assign_obj\n-  end interface\n-contains\n-! print --\n-!     Print the concentration field\n-  subroutine print (obj)\n-    class(base_pde_object) :: obj\n-    ! Dummy\n-  end subroutine print\n-! initialise --\n-!     Initialise the concentration field using a specific function\n-  subroutine initialise (obj, funcxy)\n-    class(base_pde_object) :: obj\n-    interface\n-      real function funcxy (coords)\n-        real, dimension(:), intent(in) :: coords\n-      end function funcxy\n-    end interface\n-    ! Dummy\n-  end subroutine initialise\n-! nabla2 --\n-!     Determine the divergence\n-  function nabla2 (obj)\n-    class(base_pde_object), intent(in)  :: obj\n-    class(base_pde_object), allocatable :: nabla2\n-    ! Dummy\n-  end function nabla2\n-end module base_pde_objects\n-! cartesian_2d_objects --\n-!     PDE object on a 2D cartesian grid\n-!\n-module cartesian_2d_objects\n-  use base_pde_objects\n+end module\n+\n+module i_field_module\n+  use field_module\n   implicit none\n-  type, extends(base_pde_object) :: cartesian_2d_object\n-    real, dimension(:,:), allocatable :: c\n-    real                              :: dx\n-    real                              :: dy\n+  type, extends (field)  :: i_field\n+    integer :: i\n   contains\n-    procedure            :: process       => process_cart2d\n-    procedure            :: source         => source_cart2d\n-    procedure            :: initialise     => initialise_cart2d\n-    procedure            :: nabla2         => nabla2_cart2d\n-    procedure            :: print          => print_cart2d\n-    procedure, pass(obj) :: real_times_obj => real_times_cart2d\n-    procedure            :: obj_plus_obj   => obj_plus_cart2d\n-    procedure            :: obj_assign_obj => obj_assign_cart2d\n-  end type cartesian_2d_object\n-  interface grid_definition\n-    module procedure grid_definition_cart2d\n-  end interface\n+    procedure :: multiply_real => i_multiply_real\n+    procedure :: plus => i_plus_i\n+    procedure :: assn => i_assn\n+  end type\n contains\n-  function process_cart2d (obj)\n-    class(cartesian_2d_object), intent(in)  :: obj\n-    class(base_pde_object), allocatable :: process_cart2d\n-    allocate (process_cart2d,source = obj)\n-    select type (process_cart2d)\n-      type is (cartesian_2d_object)\n-        process_cart2d%c = -sign (obj%c, 1.0)*obj%c** 4\n-      class default\n-        call abort\n-    end select\n-  end function process_cart2d\n-  function process_cart2d_p (obj)\n-    class(base_pde_object), intent(in)  :: obj\n-    class(base_pde_object), allocatable :: process_cart2d_p\n-    allocate (process_cart2d_p,source = obj)\n-    select type (process_cart2d_p)\n-      type is (cartesian_2d_object)\n-        select type (obj)\n-          type is (cartesian_2d_object)\n-            process_cart2d_p%c = -sign (obj%c, 1.0)*obj%c** 4\n-        end select\n-      class default\n-        call abort\n+  function i_plus_i(lhs,rhs)\n+    class(i_field) ,intent(in)  :: lhs\n+    class(field) ,intent(in)  :: rhs\n+    class(field) ,allocatable :: i_plus_i\n+    integer :: m = 0\n+    select type (lhs)\n+      type is (i_field); m = lhs%i\n     end select\n-  end function process_cart2d_p\n-  function source_cart2d (obj, time)\n-    class(cartesian_2d_object), intent(in)  :: obj\n-    real, intent(in)                    :: time\n-    class(base_pde_object), allocatable :: source_cart2d\n-    integer :: m, n\n-    m = size (obj%c, 1)\n-    n = size (obj%c, 2)\n-    allocate (source_cart2d, source = obj)\n-    select type (source_cart2d)\n-      type is (cartesian_2d_object)\n-        if (allocated (source_cart2d%c)) deallocate (source_cart2d%c)\n-        allocate (source_cart2d%c(m, n))\n-        source_cart2d%c = 0.0\n-        if (time .lt. 5.0) source_cart2d%c(m/2, n/2) = 0.1\n-      class default\n-        call abort\n+    select type (rhs)\n+      type is (i_field); m = rhs%i + m\n     end select\n-  end function source_cart2d\n-\n-  function source_cart2d_p (obj, time)\n-    class(base_pde_object), intent(in)  :: obj\n-    real, intent(in)                    :: time\n-    class(base_pde_object), allocatable :: source_cart2d_p\n-    integer :: m, n\n-    select type (obj)\n-      type is (cartesian_2d_object)\n-        m = size (obj%c, 1)\n-        n = size (obj%c, 2)\n-      class default\n-       call abort\n-    end select\n-    allocate (source_cart2d_p,source = obj)\n-    select type (source_cart2d_p)\n-      type is (cartesian_2d_object)\n-        if (allocated (source_cart2d_p%c)) deallocate (source_cart2d_p%c)\n-        allocate (source_cart2d_p%c(m,n))\n-        source_cart2d_p%c = 0.0\n-        if (time .lt. 5.0) source_cart2d_p%c(m/2, n/2) = 0.1\n-      class default\n-        call abort\n+    allocate (i_plus_i, source = i_field (m))\n+  end function\n+  function i_multiply_real(lhs,rhs)\n+    class(i_field) ,intent(in)  :: lhs\n+    real ,intent(in) :: rhs\n+    class(field) ,allocatable :: i_multiply_real\n+    integer :: m = 0\n+    select type (lhs)\n+      type is (i_field); m = lhs%i * int (rhs)\n     end select\n-  end function source_cart2d_p\n+    allocate (i_multiply_real, source = i_field (m))\n+  end function\n+  subroutine i_assn(lhs,rhs)\n+    class(i_field) ,intent(OUT)  :: lhs\n+    class(field) ,intent(IN)  :: rhs\n+    select type (lhs)\n+      type is (i_field)\n+        select type (rhs)\n+          type is (i_field)\n+            lhs%i = rhs%i\n+        end select         \n+      end select\n+    end subroutine\n+end module\n \n-! grid_definition --\n-!     Initialises the grid\n-!\n-  subroutine grid_definition_cart2d (obj, sizes, dims)\n-    class(base_pde_object), allocatable :: obj\n-    real, dimension(:)                  :: sizes\n-    integer, dimension(:)               :: dims\n-    allocate( cartesian_2d_object :: obj )\n-    select type (obj)\n-      type is (cartesian_2d_object)\n-        allocate (obj%c(dims(1), dims(2)))\n-        obj%c  = 0.0\n-        obj%dx = sizes(1)/dims(1)\n-        obj%dy = sizes(2)/dims(2)\n-      class default\n-        call abort\n-    end select\n-  end subroutine grid_definition_cart2d\n-! print_cart2d --\n-!     Print the concentration field to the screen\n-!\n-  subroutine print_cart2d (obj)\n-    class(cartesian_2d_object) :: obj\n-    character(len=20)          :: format\n-    write( format, '(a,i0,a)' ) '(', size(obj%c,1), 'f6.3)'\n-    write( *, format ) obj%c\n-  end subroutine print_cart2d\n-! initialise_cart2d --\n-!     Initialise the concentration field using a specific function\n-!\n-  subroutine initialise_cart2d (obj, funcxy)\n-    class(cartesian_2d_object) :: obj\n-    interface\n-      real function funcxy (coords)\n-        real, dimension(:), intent(in) :: coords\n-      end function funcxy\n-    end interface\n-    integer                    :: i, j\n-    real, dimension(2)         :: x\n-    obj%c = 0.0\n-    do j = 2,size (obj%c, 2)-1\n-      x(2) = obj%dy * (j-1)\n-      do i = 2,size (obj%c, 1)-1\n-        x(1) = obj%dx * (i-1)\n-        obj%c(i,j) = funcxy (x)\n-      enddo\n-    enddo\n-  end subroutine initialise_cart2d\n-! nabla2_cart2d\n-!     Determine the divergence\n-  function nabla2_cart2d (obj)\n-    class(cartesian_2d_object), intent(in)  :: obj\n-    class(base_pde_object), allocatable     :: nabla2_cart2d\n-    integer                                 :: m, n\n-    real                                    :: dx, dy\n-    m = size (obj%c, 1)\n-    n = size (obj%c, 2)\n-    dx = obj%dx\n-    dy = obj%dy\n-    allocate (cartesian_2d_object :: nabla2_cart2d)\n-    select type (nabla2_cart2d)\n-      type is (cartesian_2d_object)\n-        allocate (nabla2_cart2d%c(m,n))\n-        nabla2_cart2d%c = 0.0\n-        nabla2_cart2d%c(2:m-1,2:n-1) = &\n-          -(2.0 * obj%c(2:m-1,2:n-1) - obj%c(1:m-2,2:n-1) - obj%c(3:m,2:n-1)) / dx**2 &\n-          -(2.0 * obj%c(2:m-1,2:n-1) - obj%c(2:m-1,1:n-2) - obj%c(2:m-1,3:n)) / dy**2\n-      class default\n-        call abort\n-    end select\n-  end function nabla2_cart2d\n-  function real_times_cart2d (factor, obj) result(newobj)\n-    real, intent(in)                        :: factor\n-    class(cartesian_2d_object), intent(in)  :: obj\n-    class(base_pde_object), allocatable     :: newobj\n-    integer                                 :: m, n\n-    m = size (obj%c, 1)\n-    n = size (obj%c, 2)\n-    allocate (cartesian_2d_object :: newobj)\n-    select type (newobj)\n-      type is (cartesian_2d_object)\n-        allocate (newobj%c(m,n))\n-        newobj%c = factor * obj%c\n-      class default\n-        call abort\n-    end select\n-  end function real_times_cart2d\n-  function obj_plus_cart2d (obj1, obj2) result( newobj )\n-    class(cartesian_2d_object), intent(in)  :: obj1\n-    class(base_pde_object), intent(in)      :: obj2\n-    class(base_pde_object), allocatable     :: newobj\n-    integer                                 :: m, n\n-    m = size (obj1%c, 1)\n-    n = size (obj1%c, 2)\n-    allocate (cartesian_2d_object :: newobj)\n-    select type (newobj)\n-      type is (cartesian_2d_object)\n-        allocate (newobj%c(m,n))\n-          select type (obj2)\n-            type is (cartesian_2d_object)\n-              newobj%c = obj1%c + obj2%c\n-            class default\n-              call abort\n-          end select\n-      class default\n-        call abort\n-    end select\n-  end function obj_plus_cart2d\n-  subroutine obj_assign_cart2d (obj1, obj2)\n-    class(cartesian_2d_object), intent(inout) :: obj1\n-    class(base_pde_object), intent(in)        :: obj2\n-    select type (obj2)\n-      type is (cartesian_2d_object)\n-        obj1%c = obj2%c\n-      class default\n-        call abort\n-    end select\n-  end subroutine obj_assign_cart2d\n-end module cartesian_2d_objects\n-! define_pde_objects --\n-!     Module to bring all the PDE object types together\n-!\n-module define_pde_objects\n-  use base_pde_objects\n-  use cartesian_2d_objects\n-  implicit none\n-  interface grid_definition\n-    module procedure grid_definition_general\n-  end interface\n-contains\n-  subroutine grid_definition_general (obj, type, sizes, dims)\n-    class(base_pde_object), allocatable :: obj\n-    character(len=*)                    :: type\n-    real, dimension(:)                  :: sizes\n-    integer, dimension(:)               :: dims\n-    select case (type)\n-      case (\"cartesian 2d\")\n-        call grid_definition (obj, sizes, dims)\n-      case default\n-        write(*,*) 'Unknown grid type: ', trim (type)\n-        stop\n-    end select\n-  end subroutine grid_definition_general\n-end module define_pde_objects\n-! pde_specific --\n-!     Module holding the routines specific to the PDE that\n-!     we are solving\n-!\n-module pde_specific\n+program main\n+  use i_field_module\n   implicit none\n-contains\n-  real function patch (coords)\n-    real, dimension(:), intent(in) :: coords\n-    if (sum ((coords-[50.0,50.0])**2) < 40.0) then\n-      patch = 1.0\n-    else\n-      patch = 0.0\n-    endif\n-  end function patch\n-end module pde_specific\n-! test_pde_solver --\n-!     Small test program to demonstrate the usage\n-!\n-program test_pde_solver\n-  use define_pde_objects\n-  use pde_specific\n-  implicit none\n-  class(base_pde_object), allocatable :: solution, deriv\n-  integer                             :: i\n-  real                                :: time, dtime, diff, chksum(2)\n+  type(i_field) ,allocatable :: u\n+  allocate (u, source = i_field (99))\n \n-  call simulation1     ! Use proc pointers for source and process define_pde_objects\n-  select type (solution)\n-    type is (cartesian_2d_object)\n-      deallocate (solution%c)\n-  end select\n-  select type (deriv)\n-    type is (cartesian_2d_object)\n-      deallocate (deriv%c)\n-  end select\n-  deallocate (solution, deriv)\n-\n-  call simulation2     ! Use typebound procedures for source and process\n-  if (chksum(1) .ne. chksum(2)) call abort\n-  if ((chksum(1) - 0.881868720)**2 > 1e-4) call abort\n-contains\n-  subroutine simulation1\n-!\n-! Create the grid\n-!\n-    call grid_definition (solution, \"cartesian 2d\", [100.0, 100.0], [16, 16])\n-    call grid_definition (deriv,    \"cartesian 2d\", [100.0, 100.0], [16, 16])\n-!\n-! Initialise the concentration field\n-!\n-    call solution%initialise (patch)\n-!\n-! Set the procedure pointers\n-!\n-    solution%source_p => source_cart2d_p\n-    solution%process_p => process_cart2d_p\n-!\n-! Perform the integration - explicit method\n-!\n-    time  = 0.0\n-    dtime = 0.1\n-    diff =  5.0e-3\n-\n-! Give the diffusion coefficient correct dimensions.\n-    select type (solution)\n-      type is (cartesian_2d_object)\n-        diff  = diff * solution%dx * solution%dy / dtime\n-    end select\n-\n-!     write(*,*) 'Time: ', time, diff\n-!     call solution%print\n-    do i = 1,100\n-      deriv    =  solution%nabla2 ()\n-      solution = solution + diff * dtime * deriv + solution%source_p (time) + solution%process_p ()\n-!         if ( mod(i, 25) == 0 ) then\n-!             write(*,*)'Time: ', time\n-!             call solution%print\n-!         endif\n-    time = time + dtime\n-    enddo\n-!    write(*,*) 'End result 1: '\n-!    call solution%print\n-    select type (solution)\n-      type is (cartesian_2d_object)\n-        chksum(1) = sum (solution%c)\n-    end select\n-  end subroutine\n-  subroutine simulation2\n-!\n-! Create the grid\n-!\n-    call grid_definition (solution, \"cartesian 2d\", [100.0, 100.0], [16, 16])\n-    call grid_definition (deriv,    \"cartesian 2d\", [100.0, 100.0], [16, 16])\n-!\n-! Initialise the concentration field\n-!\n-    call solution%initialise (patch)\n-!\n-! Set the procedure pointers\n-!\n-    solution%source_p => source_cart2d_p\n-    solution%process_p => process_cart2d_p\n-!\n-! Perform the integration - explicit method\n-!\n-    time  = 0.0\n-    dtime = 0.1\n-    diff =  5.0e-3\n-\n-! Give the diffusion coefficient correct dimensions.\n-    select type (solution)\n-      type is (cartesian_2d_object)\n-        diff  = diff * solution%dx * solution%dy / dtime\n-    end select\n-\n-!     write(*,*) 'Time: ', time, diff\n-!     call solution%print\n-    do i = 1,100\n-      deriv    =  solution%nabla2 ()\n-      solution = solution + diff * dtime * deriv + solution%source (time) + solution%process ()\n-!         if ( mod(i, 25) == 0 ) then\n-!             write(*,*)'Time: ', time\n-!             call solution%print\n-!         endif\n-      time = time + dtime\n-    enddo\n-!    write(*,*) 'End result 2: '\n-!    call solution%print\n-    select type (solution)\n-      type is (cartesian_2d_object)\n-        chksum(2) = sum (solution%c)\n-    end select\n-  end subroutine\n-end program test_pde_solver\n-! { dg-final { cleanup-modules \"pde_specific define_pde_objects cartesian_2d_objects base_pde_objects\" } }\n+  u = u*2.\n+  u = (u*2.0*4.0) + u*4.0\n+  u = u%multiply_real (2.0)*4.0\n+  u = i_multiply_real (u, 2.0) * 4.0\n+  \n+  if (u%i .ne. 152064) call abort\n+end program\n+! { dg-final { cleanup-modules \"field_module i_field_module\" } }"}, {"sha": "b27210bc646d86ce4f157af80b02c99f3d6b4456", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_9.f03", "status": "added", "additions": 500, "deletions": 0, "changes": 500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003e0ad60130a4ba700a7b65e58ffcf0f051076c/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_9.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003e0ad60130a4ba700a7b65e58ffcf0f051076c/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_9.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_9.f03?ref=003e0ad60130a4ba700a7b65e58ffcf0f051076c", "patch": "@@ -0,0 +1,500 @@\n+! { dg-do run }\n+! { dg-add-options ieee }\n+!\n+!     Solve a diffusion problem using an object-oriented approach\n+!\n+!     Author: Arjen Markus (comp.lang.fortran)\n+!     This version: pault@gcc.gnu.org\n+!\n+!     Note:\n+!     (i) This could be turned into a more sophisticated program\n+!     using the techniques described in the chapter on\n+!     mathematical abstractions.\n+!     (That would allow the selection of the time integration\n+!     method in a transparent way)\n+!\n+!     (ii) The target procedures for process_p and source_p are\n+!     different to the typebound procedures for dynamic types\n+!     because the passed argument is not type(base_pde_object).\n+!\n+!     (iii) Two solutions are calculated, one with the procedure\n+!     pointers and the other with typebound procedures. The sums\n+!     of the solutions are compared.\n+\n+!     (iv) The source is a delta function in the middle of the\n+!     mesh, whilst the process is quartic in the local value,\n+!     when it is positive.\n+!\n+! base_pde_objects --\n+!     Module to define the basic objects\n+!\n+module base_pde_objects\n+  implicit none\n+  type, abstract :: base_pde_object\n+! No data\n+    procedure(process_p), pointer, pass :: process_p\n+    procedure(source_p), pointer, pass  :: source_p\n+  contains\n+    procedure(process), deferred :: process\n+    procedure(source), deferred :: source\n+    procedure :: initialise\n+    procedure :: nabla2\n+    procedure :: print\n+    procedure(real_times_obj), pass(obj), deferred :: real_times_obj\n+    procedure(obj_plus_obj),              deferred :: obj_plus_obj\n+    procedure(obj_assign_obj),            deferred :: obj_assign_obj\n+    generic :: operator(*)    => real_times_obj\n+    generic :: operator(+)    => obj_plus_obj\n+    generic :: assignment(=)  => obj_assign_obj\n+  end type\n+  abstract interface\n+    function process_p (obj)\n+      import base_pde_object\n+      class(base_pde_object), intent(in)  :: obj\n+      class(base_pde_object), allocatable :: process_p\n+    end function process_p\n+  end interface\n+  abstract interface\n+    function source_p (obj, time)\n+      import base_pde_object\n+      class(base_pde_object), intent(in)  :: obj\n+      real, intent(in)                    :: time\n+      class(base_pde_object), allocatable :: source_p\n+    end function source_p\n+  end interface\n+  abstract interface\n+    function process (obj)\n+      import base_pde_object\n+      class(base_pde_object), intent(in)  :: obj\n+      class(base_pde_object), allocatable :: process\n+    end function process\n+  end interface\n+  abstract interface\n+    function source (obj, time)\n+      import base_pde_object\n+      class(base_pde_object), intent(in)  :: obj\n+      real, intent(in)                    :: time\n+      class(base_pde_object), allocatable :: source\n+    end function source\n+  end interface\n+  abstract interface\n+    function real_times_obj (factor, obj) result(newobj)\n+      import base_pde_object\n+      real, intent(in)                    :: factor\n+      class(base_pde_object), intent(in)  :: obj\n+      class(base_pde_object), allocatable :: newobj\n+    end function real_times_obj\n+  end interface\n+  abstract interface\n+    function obj_plus_obj (obj1, obj2) result(newobj)\n+      import base_pde_object\n+      class(base_pde_object), intent(in)  :: obj1\n+      class(base_pde_object), intent(in)  :: obj2\n+      class(base_pde_object), allocatable :: newobj\n+    end function obj_plus_obj\n+  end interface\n+  abstract interface\n+    subroutine obj_assign_obj (obj1, obj2)\n+      import base_pde_object\n+      class(base_pde_object), intent(inout)  :: obj1\n+      class(base_pde_object), intent(in)     :: obj2\n+    end subroutine obj_assign_obj\n+  end interface\n+contains\n+! print --\n+!     Print the concentration field\n+  subroutine print (obj)\n+    class(base_pde_object) :: obj\n+    ! Dummy\n+  end subroutine print\n+! initialise --\n+!     Initialise the concentration field using a specific function\n+  subroutine initialise (obj, funcxy)\n+    class(base_pde_object) :: obj\n+    interface\n+      real function funcxy (coords)\n+        real, dimension(:), intent(in) :: coords\n+      end function funcxy\n+    end interface\n+    ! Dummy\n+  end subroutine initialise\n+! nabla2 --\n+!     Determine the divergence\n+  function nabla2 (obj)\n+    class(base_pde_object), intent(in)  :: obj\n+    class(base_pde_object), allocatable :: nabla2\n+    ! Dummy\n+  end function nabla2\n+end module base_pde_objects\n+! cartesian_2d_objects --\n+!     PDE object on a 2D cartesian grid\n+!\n+module cartesian_2d_objects\n+  use base_pde_objects\n+  implicit none\n+  type, extends(base_pde_object) :: cartesian_2d_object\n+    real, dimension(:,:), allocatable :: c\n+    real                              :: dx\n+    real                              :: dy\n+  contains\n+    procedure            :: process       => process_cart2d\n+    procedure            :: source         => source_cart2d\n+    procedure            :: initialise     => initialise_cart2d\n+    procedure            :: nabla2         => nabla2_cart2d\n+    procedure            :: print          => print_cart2d\n+    procedure, pass(obj) :: real_times_obj => real_times_cart2d\n+    procedure            :: obj_plus_obj   => obj_plus_cart2d\n+    procedure            :: obj_assign_obj => obj_assign_cart2d\n+  end type cartesian_2d_object\n+  interface grid_definition\n+    module procedure grid_definition_cart2d\n+  end interface\n+contains\n+  function process_cart2d (obj)\n+    class(cartesian_2d_object), intent(in)  :: obj\n+    class(base_pde_object), allocatable :: process_cart2d\n+    allocate (process_cart2d,source = obj)\n+    select type (process_cart2d)\n+      type is (cartesian_2d_object)\n+        process_cart2d%c = -sign (obj%c, 1.0)*obj%c** 4\n+      class default\n+        call abort\n+    end select\n+  end function process_cart2d\n+  function process_cart2d_p (obj)\n+    class(base_pde_object), intent(in)  :: obj\n+    class(base_pde_object), allocatable :: process_cart2d_p\n+    allocate (process_cart2d_p,source = obj)\n+    select type (process_cart2d_p)\n+      type is (cartesian_2d_object)\n+        select type (obj)\n+          type is (cartesian_2d_object)\n+            process_cart2d_p%c = -sign (obj%c, 1.0)*obj%c** 4\n+        end select\n+      class default\n+        call abort\n+    end select\n+  end function process_cart2d_p\n+  function source_cart2d (obj, time)\n+    class(cartesian_2d_object), intent(in)  :: obj\n+    real, intent(in)                    :: time\n+    class(base_pde_object), allocatable :: source_cart2d\n+    integer :: m, n\n+    m = size (obj%c, 1)\n+    n = size (obj%c, 2)\n+    allocate (source_cart2d, source = obj)\n+    select type (source_cart2d)\n+      type is (cartesian_2d_object)\n+        if (allocated (source_cart2d%c)) deallocate (source_cart2d%c)\n+        allocate (source_cart2d%c(m, n))\n+        source_cart2d%c = 0.0\n+        if (time .lt. 5.0) source_cart2d%c(m/2, n/2) = 0.1\n+      class default\n+        call abort\n+    end select\n+  end function source_cart2d\n+\n+  function source_cart2d_p (obj, time)\n+    class(base_pde_object), intent(in)  :: obj\n+    real, intent(in)                    :: time\n+    class(base_pde_object), allocatable :: source_cart2d_p\n+    integer :: m, n\n+    select type (obj)\n+      type is (cartesian_2d_object)\n+        m = size (obj%c, 1)\n+        n = size (obj%c, 2)\n+      class default\n+       call abort\n+    end select\n+    allocate (source_cart2d_p,source = obj)\n+    select type (source_cart2d_p)\n+      type is (cartesian_2d_object)\n+        if (allocated (source_cart2d_p%c)) deallocate (source_cart2d_p%c)\n+        allocate (source_cart2d_p%c(m,n))\n+        source_cart2d_p%c = 0.0\n+        if (time .lt. 5.0) source_cart2d_p%c(m/2, n/2) = 0.1\n+      class default\n+        call abort\n+    end select\n+  end function source_cart2d_p\n+\n+! grid_definition --\n+!     Initialises the grid\n+!\n+  subroutine grid_definition_cart2d (obj, sizes, dims)\n+    class(base_pde_object), allocatable :: obj\n+    real, dimension(:)                  :: sizes\n+    integer, dimension(:)               :: dims\n+    allocate( cartesian_2d_object :: obj )\n+    select type (obj)\n+      type is (cartesian_2d_object)\n+        allocate (obj%c(dims(1), dims(2)))\n+        obj%c  = 0.0\n+        obj%dx = sizes(1)/dims(1)\n+        obj%dy = sizes(2)/dims(2)\n+      class default\n+        call abort\n+    end select\n+  end subroutine grid_definition_cart2d\n+! print_cart2d --\n+!     Print the concentration field to the screen\n+!\n+  subroutine print_cart2d (obj)\n+    class(cartesian_2d_object) :: obj\n+    character(len=20)          :: format\n+    write( format, '(a,i0,a)' ) '(', size(obj%c,1), 'f6.3)'\n+    write( *, format ) obj%c\n+  end subroutine print_cart2d\n+! initialise_cart2d --\n+!     Initialise the concentration field using a specific function\n+!\n+  subroutine initialise_cart2d (obj, funcxy)\n+    class(cartesian_2d_object) :: obj\n+    interface\n+      real function funcxy (coords)\n+        real, dimension(:), intent(in) :: coords\n+      end function funcxy\n+    end interface\n+    integer                    :: i, j\n+    real, dimension(2)         :: x\n+    obj%c = 0.0\n+    do j = 2,size (obj%c, 2)-1\n+      x(2) = obj%dy * (j-1)\n+      do i = 2,size (obj%c, 1)-1\n+        x(1) = obj%dx * (i-1)\n+        obj%c(i,j) = funcxy (x)\n+      enddo\n+    enddo\n+  end subroutine initialise_cart2d\n+! nabla2_cart2d\n+!     Determine the divergence\n+  function nabla2_cart2d (obj)\n+    class(cartesian_2d_object), intent(in)  :: obj\n+    class(base_pde_object), allocatable     :: nabla2_cart2d\n+    integer                                 :: m, n\n+    real                                    :: dx, dy\n+    m = size (obj%c, 1)\n+    n = size (obj%c, 2)\n+    dx = obj%dx\n+    dy = obj%dy\n+    allocate (cartesian_2d_object :: nabla2_cart2d)\n+    select type (nabla2_cart2d)\n+      type is (cartesian_2d_object)\n+        allocate (nabla2_cart2d%c(m,n))\n+        nabla2_cart2d%c = 0.0\n+        nabla2_cart2d%c(2:m-1,2:n-1) = &\n+          -(2.0 * obj%c(2:m-1,2:n-1) - obj%c(1:m-2,2:n-1) - obj%c(3:m,2:n-1)) / dx**2 &\n+          -(2.0 * obj%c(2:m-1,2:n-1) - obj%c(2:m-1,1:n-2) - obj%c(2:m-1,3:n)) / dy**2\n+      class default\n+        call abort\n+    end select\n+  end function nabla2_cart2d\n+  function real_times_cart2d (factor, obj) result(newobj)\n+    real, intent(in)                        :: factor\n+    class(cartesian_2d_object), intent(in)  :: obj\n+    class(base_pde_object), allocatable     :: newobj\n+    integer                                 :: m, n\n+    m = size (obj%c, 1)\n+    n = size (obj%c, 2)\n+    allocate (cartesian_2d_object :: newobj)\n+    select type (newobj)\n+      type is (cartesian_2d_object)\n+        allocate (newobj%c(m,n))\n+        newobj%c = factor * obj%c\n+      class default\n+        call abort\n+    end select\n+  end function real_times_cart2d\n+  function obj_plus_cart2d (obj1, obj2) result( newobj )\n+    class(cartesian_2d_object), intent(in)  :: obj1\n+    class(base_pde_object), intent(in)      :: obj2\n+    class(base_pde_object), allocatable     :: newobj\n+    integer                                 :: m, n\n+    m = size (obj1%c, 1)\n+    n = size (obj1%c, 2)\n+    allocate (cartesian_2d_object :: newobj)\n+    select type (newobj)\n+      type is (cartesian_2d_object)\n+        allocate (newobj%c(m,n))\n+          select type (obj2)\n+            type is (cartesian_2d_object)\n+              newobj%c = obj1%c + obj2%c\n+            class default\n+              call abort\n+          end select\n+      class default\n+        call abort\n+    end select\n+  end function obj_plus_cart2d\n+  subroutine obj_assign_cart2d (obj1, obj2)\n+    class(cartesian_2d_object), intent(inout) :: obj1\n+    class(base_pde_object), intent(in)        :: obj2\n+    select type (obj2)\n+      type is (cartesian_2d_object)\n+        obj1%c = obj2%c\n+      class default\n+        call abort\n+    end select\n+  end subroutine obj_assign_cart2d\n+end module cartesian_2d_objects\n+! define_pde_objects --\n+!     Module to bring all the PDE object types together\n+!\n+module define_pde_objects\n+  use base_pde_objects\n+  use cartesian_2d_objects\n+  implicit none\n+  interface grid_definition\n+    module procedure grid_definition_general\n+  end interface\n+contains\n+  subroutine grid_definition_general (obj, type, sizes, dims)\n+    class(base_pde_object), allocatable :: obj\n+    character(len=*)                    :: type\n+    real, dimension(:)                  :: sizes\n+    integer, dimension(:)               :: dims\n+    select case (type)\n+      case (\"cartesian 2d\")\n+        call grid_definition (obj, sizes, dims)\n+      case default\n+        write(*,*) 'Unknown grid type: ', trim (type)\n+        stop\n+    end select\n+  end subroutine grid_definition_general\n+end module define_pde_objects\n+! pde_specific --\n+!     Module holding the routines specific to the PDE that\n+!     we are solving\n+!\n+module pde_specific\n+  implicit none\n+contains\n+  real function patch (coords)\n+    real, dimension(:), intent(in) :: coords\n+    if (sum ((coords-[50.0,50.0])**2) < 40.0) then\n+      patch = 1.0\n+    else\n+      patch = 0.0\n+    endif\n+  end function patch\n+end module pde_specific\n+! test_pde_solver --\n+!     Small test program to demonstrate the usage\n+!\n+program test_pde_solver\n+  use define_pde_objects\n+  use pde_specific\n+  implicit none\n+  class(base_pde_object), allocatable :: solution, deriv\n+  integer                             :: i\n+  real                                :: time, dtime, diff, chksum(2)\n+\n+  call simulation1     ! Use proc pointers for source and process define_pde_objects\n+  select type (solution)\n+    type is (cartesian_2d_object)\n+      deallocate (solution%c)\n+  end select\n+  select type (deriv)\n+    type is (cartesian_2d_object)\n+      deallocate (deriv%c)\n+  end select\n+  deallocate (solution, deriv)\n+\n+  call simulation2     ! Use typebound procedures for source and process\n+  if (chksum(1) .ne. chksum(2)) call abort\n+  if ((chksum(1) - 0.881868720)**2 > 1e-4) call abort\n+contains\n+  subroutine simulation1\n+!\n+! Create the grid\n+!\n+    call grid_definition (solution, \"cartesian 2d\", [100.0, 100.0], [16, 16])\n+    call grid_definition (deriv,    \"cartesian 2d\", [100.0, 100.0], [16, 16])\n+!\n+! Initialise the concentration field\n+!\n+    call solution%initialise (patch)\n+!\n+! Set the procedure pointers\n+!\n+    solution%source_p => source_cart2d_p\n+    solution%process_p => process_cart2d_p\n+!\n+! Perform the integration - explicit method\n+!\n+    time  = 0.0\n+    dtime = 0.1\n+    diff =  5.0e-3\n+\n+! Give the diffusion coefficient correct dimensions.\n+    select type (solution)\n+      type is (cartesian_2d_object)\n+        diff  = diff * solution%dx * solution%dy / dtime\n+    end select\n+\n+!     write(*,*) 'Time: ', time, diff\n+!     call solution%print\n+    do i = 1,100\n+      deriv    =  solution%nabla2 ()\n+      solution = solution + diff * dtime * deriv + solution%source_p (time) + solution%process_p ()\n+!         if ( mod(i, 25) == 0 ) then\n+!             write(*,*)'Time: ', time\n+!             call solution%print\n+!         endif\n+    time = time + dtime\n+    enddo\n+!    write(*,*) 'End result 1: '\n+!    call solution%print\n+    select type (solution)\n+      type is (cartesian_2d_object)\n+        chksum(1) = sum (solution%c)\n+    end select\n+  end subroutine\n+  subroutine simulation2\n+!\n+! Create the grid\n+!\n+    call grid_definition (solution, \"cartesian 2d\", [100.0, 100.0], [16, 16])\n+    call grid_definition (deriv,    \"cartesian 2d\", [100.0, 100.0], [16, 16])\n+!\n+! Initialise the concentration field\n+!\n+    call solution%initialise (patch)\n+!\n+! Set the procedure pointers\n+!\n+    solution%source_p => source_cart2d_p\n+    solution%process_p => process_cart2d_p\n+!\n+! Perform the integration - explicit method\n+!\n+    time  = 0.0\n+    dtime = 0.1\n+    diff =  5.0e-3\n+\n+! Give the diffusion coefficient correct dimensions.\n+    select type (solution)\n+      type is (cartesian_2d_object)\n+        diff  = diff * solution%dx * solution%dy / dtime\n+    end select\n+\n+!     write(*,*) 'Time: ', time, diff\n+!     call solution%print\n+    do i = 1,100\n+      deriv    =  solution%nabla2 ()\n+      solution = solution + diff * dtime * deriv + solution%source (time) + solution%process ()\n+!         if ( mod(i, 25) == 0 ) then\n+!             write(*,*)'Time: ', time\n+!             call solution%print\n+!         endif\n+      time = time + dtime\n+    enddo\n+!    write(*,*) 'End result 2: '\n+!    call solution%print\n+    select type (solution)\n+      type is (cartesian_2d_object)\n+        chksum(2) = sum (solution%c)\n+    end select\n+  end subroutine\n+end program test_pde_solver\n+! { dg-final { cleanup-modules \"pde_specific define_pde_objects cartesian_2d_objects base_pde_objects\" } }"}]}