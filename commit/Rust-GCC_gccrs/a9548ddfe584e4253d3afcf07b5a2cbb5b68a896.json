{"sha": "a9548ddfe584e4253d3afcf07b5a2cbb5b68a896", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk1NDhkZGZlNTg0ZTQyNTNkM2FmY2YwN2I1YTJjYmI1YjY4YTg5Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-04-26T18:44:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-04-26T18:44:59Z"}, "message": "tree.h (DECL_BY_REFERENCE): Note that it is also valid for !TREE_STATIC VAR_DECLs.\n\n\t* tree.h (DECL_BY_REFERENCE): Note that it is also valid for\n\t!TREE_STATIC VAR_DECLs.\n\t* dwarf2out.c (loc_by_reference, gen_decl_die): Handle\n\tDECL_BY_REFERENCE on !TREE_STATIC VAR_DECLs.\n\t(gen_variable_die): Likewise.  Don't look at TREE_PRIVATE if\n\tDECL_BY_REFERENCE is valid.\n\t* dbxout.c (DECL_ACCESSIBILITY_CHAR): Don't look at TREE_PRIVATE\n\tfor PARM_DECLs, RESULT_DECLs or !TREE_STATIC VAR_DECLs.\n\t* tree-nested.c (get_nonlocal_debug_decl, get_local_debug_decl):\n\tCopy DECL_BY_REFERENCE.\n\t(struct nesting_copy_body_data): New type.\n\t(nesting_copy_decl): New function.\n\t(finalize_nesting_tree_1): Remap types of debug_var_chain variables,\n\tif they have variable length.\n\nFrom-SVN: r146808", "tree": {"sha": "389fce94fdeefafd175cbeb3d0ca842d67200c62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/389fce94fdeefafd175cbeb3d0ca842d67200c62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9548ddfe584e4253d3afcf07b5a2cbb5b68a896", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9548ddfe584e4253d3afcf07b5a2cbb5b68a896", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9548ddfe584e4253d3afcf07b5a2cbb5b68a896", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9548ddfe584e4253d3afcf07b5a2cbb5b68a896/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "10555d08b4bee4c92649200866ce0ee9e8d9af5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10555d08b4bee4c92649200866ce0ee9e8d9af5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10555d08b4bee4c92649200866ce0ee9e8d9af5d"}], "stats": {"total": 149, "additions": 137, "deletions": 12}, "files": [{"sha": "b7bd93bce7a7e00b20f8b48b984d8b69cf4d0579", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9548ddfe584e4253d3afcf07b5a2cbb5b68a896/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9548ddfe584e4253d3afcf07b5a2cbb5b68a896/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9548ddfe584e4253d3afcf07b5a2cbb5b68a896", "patch": "@@ -1,3 +1,20 @@\n+2009-04-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree.h (DECL_BY_REFERENCE): Note that it is also valid for\n+\t!TREE_STATIC VAR_DECLs.\n+\t* dwarf2out.c (loc_by_reference, gen_decl_die): Handle\n+\tDECL_BY_REFERENCE on !TREE_STATIC VAR_DECLs.\n+\t(gen_variable_die): Likewise.  Don't look at TREE_PRIVATE if\n+\tDECL_BY_REFERENCE is valid.\n+\t* dbxout.c (DECL_ACCESSIBILITY_CHAR): Don't look at TREE_PRIVATE\n+\tfor PARM_DECLs, RESULT_DECLs or !TREE_STATIC VAR_DECLs.\n+\t* tree-nested.c (get_nonlocal_debug_decl, get_local_debug_decl):\n+\tCopy DECL_BY_REFERENCE.\n+\t(struct nesting_copy_body_data): New type.\n+\t(nesting_copy_decl): New function.\n+\t(finalize_nesting_tree_1): Remap types of debug_var_chain variables,\n+\tif they have variable length.\n+\n 2009-04-26  Michael Matz  <matz@suse.de>\n \n \t* tree-sra.c (sra_build_assignment): Don't use into_ssa mode,"}, {"sha": "077fc1a383e5107d7291e754d30e881794293070", "filename": "gcc/dbxout.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9548ddfe584e4253d3afcf07b5a2cbb5b68a896/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9548ddfe584e4253d3afcf07b5a2cbb5b68a896/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=a9548ddfe584e4253d3afcf07b5a2cbb5b68a896", "patch": "@@ -1398,7 +1398,9 @@ dbxout_type_index (tree type)\n /* Used in several places: evaluates to '0' for a private decl,\n    '1' for a protected decl, '2' for a public decl.  */\n #define DECL_ACCESSIBILITY_CHAR(DECL) \\\n-(TREE_PRIVATE (DECL) ? '0' : TREE_PROTECTED (DECL) ? '1' : '2')\n+((TREE_CODE (DECL) != PARM_DECL && TREE_CODE (DECL) != RESULT_DECL \\\n+  && (TREE_CODE (DECL) != VAR_DECL || TREE_STATIC (DECL)) \\\n+  && TREE_PRIVATE (DECL)) ? '0' : TREE_PROTECTED (DECL) ? '1' : '2')\n \n /* Subroutine of `dbxout_type'.  Output the type fields of TYPE.\n    This must be a separate function because anonymous unions require"}, {"sha": "0b25382896f6108b1fe68658eee0bef1cc24c1d8", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9548ddfe584e4253d3afcf07b5a2cbb5b68a896/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9548ddfe584e4253d3afcf07b5a2cbb5b68a896/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a9548ddfe584e4253d3afcf07b5a2cbb5b68a896", "patch": "@@ -11701,7 +11701,9 @@ loc_by_reference (dw_loc_descr_ref loc, tree decl)\n   if (loc == NULL)\n     return NULL;\n \n-  if ((TREE_CODE (decl) != PARM_DECL && TREE_CODE (decl) != RESULT_DECL)\n+  if ((TREE_CODE (decl) != PARM_DECL\n+       && TREE_CODE (decl) != RESULT_DECL\n+       && (TREE_CODE (decl) != VAR_DECL || TREE_STATIC (decl)))\n       || !DECL_BY_REFERENCE (decl))\n     return loc;\n \n@@ -14040,12 +14042,19 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n   else\n     {\n       tree type = TREE_TYPE (decl);\n+      bool private_flag_valid = true;\n \n       add_name_and_src_coords_attributes (var_die, decl);\n       if ((TREE_CODE (decl) == PARM_DECL\n-\t   || TREE_CODE (decl) == RESULT_DECL)\n+\t   || TREE_CODE (decl) == RESULT_DECL\n+\t   || (TREE_CODE (decl) == VAR_DECL && !TREE_STATIC (decl)))\n \t  && DECL_BY_REFERENCE (decl))\n-\tadd_type_attribute (var_die, TREE_TYPE (type), 0, 0, context_die);\n+\t{\n+\t  add_type_attribute (var_die, TREE_TYPE (type), 0, 0, context_die);\n+\t  /* DECL_BY_REFERENCE uses the same bit as TREE_PRIVATE,\n+\t     for PARM_DECL, RESULT_DECL or non-static VAR_DECL.  */\n+\t  private_flag_valid = false;\n+\t}\n       else\n \tadd_type_attribute (var_die, type, TREE_READONLY (decl),\n \t\t\t    TREE_THIS_VOLATILE (decl), context_die);\n@@ -14058,7 +14067,7 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n \n       if (TREE_PROTECTED (decl))\n \tadd_AT_unsigned (var_die, DW_AT_accessibility, DW_ACCESS_protected);\n-      else if (TREE_PRIVATE (decl))\n+      else if (private_flag_valid && TREE_PRIVATE (decl))\n \tadd_AT_unsigned (var_die, DW_AT_accessibility, DW_ACCESS_private);\n     }\n \n@@ -15291,7 +15300,9 @@ gen_decl_die (tree decl, tree origin, dw_die_ref context_die)\n \n       /* Output any DIEs that are needed to specify the type of this data\n \t object.  */\n-      if (TREE_CODE (decl_or_origin) == RESULT_DECL\n+      if ((TREE_CODE (decl_or_origin) == RESULT_DECL\n+\t   || (TREE_CODE (decl_or_origin) == VAR_DECL\n+\t       && !TREE_STATIC (decl_or_origin)))\n           && DECL_BY_REFERENCE (decl_or_origin))\n \tgen_type_die (TREE_TYPE (TREE_TYPE (decl_or_origin)), context_die);\n       else"}, {"sha": "b3301a712a80ddd4cb905d5a4fc9c2dd468df5d2", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 97, "deletions": 3, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9548ddfe584e4253d3afcf07b5a2cbb5b68a896/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9548ddfe584e4253d3afcf07b5a2cbb5b68a896/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=a9548ddfe584e4253d3afcf07b5a2cbb5b68a896", "patch": "@@ -827,6 +827,11 @@ get_nonlocal_debug_decl (struct nesting_info *info, tree decl)\n   TREE_READONLY (new_decl) = TREE_READONLY (decl);\n   TREE_ADDRESSABLE (new_decl) = TREE_ADDRESSABLE (decl);\n   DECL_SEEN_IN_BIND_EXPR_P (new_decl) = 1;\n+  if ((TREE_CODE (decl) == PARM_DECL\n+       || TREE_CODE (decl) == RESULT_DECL\n+       || TREE_CODE (decl) == VAR_DECL)\n+      && DECL_BY_REFERENCE (decl))\n+    DECL_BY_REFERENCE (new_decl) = 1;\n \n   SET_DECL_VALUE_EXPR (new_decl, x);\n   DECL_HAS_VALUE_EXPR_P (new_decl) = 1;\n@@ -1240,6 +1245,11 @@ get_local_debug_decl (struct nesting_info *info, tree decl, tree field)\n   TREE_READONLY (new_decl) = TREE_READONLY (decl);\n   TREE_ADDRESSABLE (new_decl) = TREE_ADDRESSABLE (decl);\n   DECL_SEEN_IN_BIND_EXPR_P (new_decl) = 1;\n+  if ((TREE_CODE (decl) == PARM_DECL\n+       || TREE_CODE (decl) == RESULT_DECL\n+       || TREE_CODE (decl) == VAR_DECL)\n+      && DECL_BY_REFERENCE (decl))\n+    DECL_BY_REFERENCE (new_decl) = 1;\n \n   SET_DECL_VALUE_EXPR (new_decl, x);\n   DECL_HAS_VALUE_EXPR_P (new_decl) = 1;\n@@ -1944,6 +1954,34 @@ convert_all_function_calls (struct nesting_info *root)\n   while (root);\n }\n \n+struct nesting_copy_body_data\n+{\n+  copy_body_data cb;\n+  struct nesting_info *root;\n+};\n+\n+/* A helper subroutine for debug_var_chain type remapping.  */\n+\n+static tree\n+nesting_copy_decl (tree decl, copy_body_data *id)\n+{\n+  struct nesting_copy_body_data *nid = (struct nesting_copy_body_data *) id;\n+  void **slot = pointer_map_contains (nid->root->var_map, decl);\n+\n+  if (slot)\n+    return (tree) *slot;\n+\n+  if (TREE_CODE (decl) == TYPE_DECL && DECL_ORIGINAL_TYPE (decl))\n+    {\n+      tree new_decl = copy_decl_no_change (decl, id);\n+      DECL_ORIGINAL_TYPE (new_decl)\n+\t= remap_type (DECL_ORIGINAL_TYPE (decl), id);\n+      return new_decl;\n+    }\n+\n+  return copy_decl_no_change (decl, id);\n+}\n+\n /* Do \"everything else\" to clean up or complete state collected by the\n    various walking passes -- lay out the types and decls, generate code\n    to initialize the frame decl, store critical expressions in the\n@@ -2076,10 +2114,66 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n     declare_vars (root->new_local_var_chain,\n \t\t  gimple_seq_first_stmt (gimple_body (root->context)),\n \t\t  false);\n+\n   if (root->debug_var_chain)\n-    declare_vars (root->debug_var_chain,\n-\t\t  gimple_seq_first_stmt (gimple_body (root->context)),\n-\t\t  true);\n+    {\n+      tree debug_var;\n+\n+      for (debug_var = root->debug_var_chain; debug_var;\n+\t   debug_var = TREE_CHAIN (debug_var))\n+\tif (variably_modified_type_p (TREE_TYPE (debug_var), NULL))\n+\t  break;\n+\n+      /* If there are any debug decls with variable length types,\n+\t remap those types using other debug_var_chain variables.  */\n+      if (debug_var)\n+\t{\n+\t  struct nesting_copy_body_data id;\n+\n+\t  memset (&id, 0, sizeof (id));\n+\t  id.cb.copy_decl = nesting_copy_decl;\n+\t  id.cb.decl_map = pointer_map_create ();\n+\t  id.root = root;\n+\n+\t  for (; debug_var; debug_var = TREE_CHAIN (debug_var))\n+\t    if (variably_modified_type_p (TREE_TYPE (debug_var), NULL))\n+\t      {\n+\t\ttree type = TREE_TYPE (debug_var);\n+\t\ttree newt, t = type;\n+\t\tstruct nesting_info *i;\n+\n+\t\tfor (i = root; i; i = i->outer)\n+\t\t  if (variably_modified_type_p (type, i->context))\n+\t\t    break;\n+\n+\t\tif (i == NULL)\n+\t\t  continue;\n+\n+\t\tid.cb.src_fn = i->context;\n+\t\tid.cb.dst_fn = i->context;\n+\t\tid.cb.src_cfun = DECL_STRUCT_FUNCTION (root->context);\n+\n+\t\tTREE_TYPE (debug_var) = newt = remap_type (type, &id.cb);\n+\t\twhile (POINTER_TYPE_P (newt) && !TYPE_NAME (newt))\n+\t\t  {\n+\t\t    newt = TREE_TYPE (newt);\n+\t\t    t = TREE_TYPE (t);\n+\t\t  }\n+\t\tif (TYPE_NAME (newt)\n+\t\t    && TREE_CODE (TYPE_NAME (newt)) == TYPE_DECL\n+\t\t    && DECL_ORIGINAL_TYPE (TYPE_NAME (newt))\n+\t\t    && newt != t\n+\t\t    && TYPE_NAME (newt) == TYPE_NAME (t))\n+\t\t  TYPE_NAME (newt) = remap_decl (TYPE_NAME (newt), &id.cb);\n+\t      }\n+\n+\t  pointer_map_destroy (id.cb.decl_map);\n+\t}\n+\n+      declare_vars (root->debug_var_chain,\n+\t\t    gimple_seq_first_stmt (gimple_body (root->context)),\n+\t\t    true);\n+    }\n \n   /* Dump the translated tree function.  */\n   dump_function (TDI_nested, root->context);"}, {"sha": "d6550b51c50e5a96622c10e8c71ca46b91e2d9eb", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9548ddfe584e4253d3afcf07b5a2cbb5b68a896/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9548ddfe584e4253d3afcf07b5a2cbb5b68a896/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a9548ddfe584e4253d3afcf07b5a2cbb5b68a896", "patch": "@@ -476,7 +476,7 @@ struct GTY(()) tree_common {\n            CALL_EXPR\n \n        DECL_BY_REFERENCE in\n-           PARM_DECL, RESULT_DECL\n+           PARM_DECL, RESULT_DECL, VAR_DECL (only !TREE_STATIC)\n \n        OMP_SECTION_LAST in\n            OMP_SECTION\n@@ -1294,8 +1294,9 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define CALL_EXPR_RETURN_SLOT_OPT(NODE) \\\n   (CALL_EXPR_CHECK (NODE)->base.private_flag)\n \n-/* In a RESULT_DECL or PARM_DECL, means that it is passed by invisible\n-   reference (and the TREE_TYPE is a pointer to the true type).  */\n+/* In a RESULT_DECL, PARM_DECL or VAR_DECL without TREE_STATIC, means that it is\n+   passed by invisible reference (and the TREE_TYPE is a pointer to the true\n+   type).  */\n #define DECL_BY_REFERENCE(NODE) (DECL_COMMON_CHECK (NODE)->base.private_flag)\n \n /* In a CALL_EXPR, means that the call is the jump from a thunk to the"}]}