{"sha": "b66af6ed30d4bfa930e7afa30d078d7e83af42a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY2YWY2ZWQzMGQ0YmZhOTMwZTdhZmEzMGQwNzhkN2U4M2FmNDJhMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-06-01T14:05:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-06-01T14:05:22Z"}, "message": "re PR tree-optimization/71366 (ICE on valid code at -O3 on x86_64-linux-gnu: Segmentation fault)\n\n2016-06-01  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/71366\n\t* tree-ssa-loop-ivcanon.c (edges_to_remove): New global.\n\t(unloop_loops): Move removing edges here ...\n\t(try_unroll_loop_completely): ... from here.\n\t(try_peel_loop): ... and here.\n\t(tree_unroll_loops_completely_1): Track parent loops via\n\tbitmap of header BBs.\n\t(tree_unroll_loops_completely): Adjust for that.\n\n\t* gcc.dg/torture/pr71366-1.c: New testcase.\n\t* gcc.dg/torture/pr71366-2.c: Likewise.\n\nFrom-SVN: r236993", "tree": {"sha": "8b8ed7a675e257cb9dcb8877949db457a3b73760", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b8ed7a675e257cb9dcb8877949db457a3b73760"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b66af6ed30d4bfa930e7afa30d078d7e83af42a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b66af6ed30d4bfa930e7afa30d078d7e83af42a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b66af6ed30d4bfa930e7afa30d078d7e83af42a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b66af6ed30d4bfa930e7afa30d078d7e83af42a0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e342b9d826f4e7bea5bd409b795c210ab9910899", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e342b9d826f4e7bea5bd409b795c210ab9910899", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e342b9d826f4e7bea5bd409b795c210ab9910899"}], "stats": {"total": 158, "additions": 106, "deletions": 52}, "files": [{"sha": "0c4aa2d09356a6c01b3a9aebd8fa389349c37e05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66af6ed30d4bfa930e7afa30d078d7e83af42a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66af6ed30d4bfa930e7afa30d078d7e83af42a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b66af6ed30d4bfa930e7afa30d078d7e83af42a0", "patch": "@@ -1,3 +1,14 @@\n+2016-06-01  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/71366\n+\t* tree-ssa-loop-ivcanon.c (edges_to_remove): New global.\n+\t(unloop_loops): Move removing edges here ...\n+\t(try_unroll_loop_completely): ... from here.\n+\t(try_peel_loop): ... and here.\n+\t(tree_unroll_loops_completely_1): Track parent loops via\n+\tbitmap of header BBs.\n+\t(tree_unroll_loops_completely): Adjust for that.\n+\n 2016-06-01  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n \n \t* config/rs6000/altivec.h (vec_slv): New macro."}, {"sha": "cb2f8c62407e54f78d4fbf863c9c64835b5ff542", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66af6ed30d4bfa930e7afa30d078d7e83af42a0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66af6ed30d4bfa930e7afa30d078d7e83af42a0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b66af6ed30d4bfa930e7afa30d078d7e83af42a0", "patch": "@@ -1,3 +1,9 @@\n+2016-06-01  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/71366\n+\t* gcc.dg/torture/pr71366-1.c: New testcase.\n+\t* gcc.dg/torture/pr71366-2.c: Likewise.\n+\n 2016-06-01  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n \n \t* gcc.target/powerpc/vslv-0.c: New test."}, {"sha": "44406520a3fe4c2985d6eb199bf7be78addd1d2f", "filename": "gcc/testsuite/gcc.dg/torture/pr71366-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66af6ed30d4bfa930e7afa30d078d7e83af42a0/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71366-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66af6ed30d4bfa930e7afa30d078d7e83af42a0/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71366-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71366-1.c?ref=b66af6ed30d4bfa930e7afa30d078d7e83af42a0", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+\n+int a[1][2], b, c;\n+\n+int\n+fn1 ()\n+{ \n+  int d;\n+  for (; c;)\n+    for (d = 2; d >= 0;)\n+      { \n+\tint e[4], f = e[3];\n+\tif (f)\n+\t  return b;\n+\td--;\n+\tfor (;;)\n+\t  { \n+\t    c = a[0][d];\n+\t    break;\n+\t  }\n+      }\n+  return 0;\n+}"}, {"sha": "f32875eb9f215c599c3fdf38431321f80411c036", "filename": "gcc/testsuite/gcc.dg/torture/pr71366-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66af6ed30d4bfa930e7afa30d078d7e83af42a0/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71366-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66af6ed30d4bfa930e7afa30d078d7e83af42a0/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71366-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71366-2.c?ref=b66af6ed30d4bfa930e7afa30d078d7e83af42a0", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+\n+char a[1];\n+int b;\n+void fn1()\n+{\n+  int i;\n+  for (;;)\n+    {\n+      i = 0;\n+      for (; i < 6; i++)\n+\t{\n+\t  if (b)\n+\t    for (;;)\n+\t      ;\n+\t  int c = a[i];\n+\t  __builtin_printf(\"\", i);\n+\t}\n+    }\n+}"}, {"sha": "248c125949679bf573c97db9bc93d01d9d7b1901", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 46, "deletions": 52, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66af6ed30d4bfa930e7afa30d078d7e83af42a0/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66af6ed30d4bfa930e7afa30d078d7e83af42a0/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=b66af6ed30d4bfa930e7afa30d078d7e83af42a0", "patch": "@@ -591,9 +591,11 @@ remove_redundant_iv_tests (struct loop *loop)\n   return changed;\n }\n \n-/* Stores loops that will be unlooped after we process whole loop tree. */\n+/* Stores loops that will be unlooped and edges that will be removed\n+   after we process whole loop tree. */\n static vec<loop_p> loops_to_unloop;\n static vec<int> loops_to_unloop_nunroll;\n+static vec<edge> edges_to_remove;\n /* Stores loops that has been peeled.  */\n static bitmap peeled_loops;\n \n@@ -613,6 +615,16 @@ static void\n unloop_loops (bitmap loop_closed_ssa_invalidated,\n \t      bool *irred_invalidated)\n {\n+  /* First remove edges in peeled copies.  */\n+  unsigned i;\n+  edge e;\n+  FOR_EACH_VEC_ELT (edges_to_remove, i, e)\n+    {\n+      bool ok = remove_path (e);\n+      gcc_assert (ok);\n+    }\n+  edges_to_remove.release ();\n+\n   while (loops_to_unloop.length ())\n     {\n       struct loop *loop = loops_to_unloop.pop ();\n@@ -725,10 +737,7 @@ try_unroll_loop_completely (struct loop *loop,\n   if (n_unroll)\n     {\n       sbitmap wont_exit;\n-      edge e;\n-      unsigned i;\n       bool large;\n-      vec<edge> to_remove = vNULL;\n       if (ul == UL_SINGLE_ITER)\n \treturn false;\n \n@@ -862,7 +871,7 @@ try_unroll_loop_completely (struct loop *loop,\n \n       if (!gimple_duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\t\t\t\t\t n_unroll, wont_exit,\n-\t\t\t\t\t\t exit, &to_remove,\n+\t\t\t\t\t\t exit, &edges_to_remove,\n \t\t\t\t\t\t DLTHE_FLAG_UPDATE_FREQ\n \t\t\t\t\t\t | DLTHE_FLAG_COMPLETTE_PEEL))\n \t{\n@@ -873,18 +882,10 @@ try_unroll_loop_completely (struct loop *loop,\n \t  return false;\n \t}\n \n-      FOR_EACH_VEC_ELT (to_remove, i, e)\n-\t{\n-\t  bool ok = remove_path (e);\n-\t  gcc_assert (ok);\n-\t}\n-\n-      to_remove.release ();\n       free (wont_exit);\n       free_original_copy_tables ();\n     }\n \n-\n   /* Remove the conditional from the last copy of the loop.  */\n   if (edge_to_cancel)\n     {\n@@ -960,9 +961,6 @@ try_peel_loop (struct loop *loop,\n   struct loop_size size;\n   int peeled_size;\n   sbitmap wont_exit;\n-  unsigned i;\n-  vec<edge> to_remove = vNULL;\n-  edge e;\n \n   if (!flag_peel_loops || PARAM_VALUE (PARAM_MAX_PEEL_TIMES) <= 0\n       || !peeled_loops)\n@@ -1052,18 +1050,13 @@ try_peel_loop (struct loop *loop,\n     }\n   if (!gimple_duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\t\t\t\t     npeel, wont_exit,\n-\t\t\t\t\t     exit, &to_remove,\n+\t\t\t\t\t     exit, &edges_to_remove,\n \t\t\t\t\t     DLTHE_FLAG_UPDATE_FREQ))\n     {\n       free_original_copy_tables ();\n       free (wont_exit);\n       return false;\n     }\n-  FOR_EACH_VEC_ELT (to_remove, i, e)\n-    {\n-      bool ok = remove_path (e);\n-      gcc_assert (ok);\n-    }\n   free (wont_exit);\n   free_original_copy_tables ();\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1099,6 +1092,7 @@ try_peel_loop (struct loop *loop,\n   gcov_type entry_count = 0;\n   int entry_freq = 0;\n \n+  edge e;\n   edge_iterator ei;\n   FOR_EACH_EDGE (e, ei, loop->header->preds)\n     if (e->src != loop->latch)\n@@ -1299,8 +1293,7 @@ propagate_constants_for_unrolling (basic_block bb)\n \n static bool\n tree_unroll_loops_completely_1 (bool may_increase_size, bool unroll_outer,\n-\t\t\t\tvec<loop_p, va_heap>& father_stack,\n-\t\t\t\tstruct loop *loop)\n+\t\t\t\tbitmap father_bbs, struct loop *loop)\n {\n   struct loop *loop_father;\n   bool changed = false;\n@@ -1310,7 +1303,7 @@ tree_unroll_loops_completely_1 (bool may_increase_size, bool unroll_outer,\n   /* Process inner loops first.  */\n   for (inner = loop->inner; inner != NULL; inner = inner->next)\n     changed |= tree_unroll_loops_completely_1 (may_increase_size,\n-\t\t\t\t\t       unroll_outer, father_stack,\n+\t\t\t\t\t       unroll_outer, father_bbs,\n \t\t\t\t\t       inner);\n  \n   /* If we changed an inner loop we cannot process outer loops in this\n@@ -1344,11 +1337,8 @@ tree_unroll_loops_completely_1 (bool may_increase_size, bool unroll_outer,\n \t within the new basic blocks to fold away induction variable\n \t computations; otherwise, the size might blow up before the\n \t iteration is complete and the IR eventually cleaned up.  */\n-      if (loop_outer (loop_father) && !loop_father->aux)\n-\t{\n-\t  father_stack.safe_push (loop_father);\n-\t  loop_father->aux = loop_father;\n-\t}\n+      if (loop_outer (loop_father))\n+\tbitmap_set_bit (father_bbs, loop_father->header->index);\n \n       return true;\n     }\n@@ -1363,7 +1353,7 @@ tree_unroll_loops_completely_1 (bool may_increase_size, bool unroll_outer,\n unsigned int\n tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n {\n-  auto_vec<loop_p, 16> father_stack;\n+  bitmap father_bbs = BITMAP_ALLOC (NULL);\n   bool changed;\n   int iteration = 0;\n   bool irred_invalidated = false;\n@@ -1380,20 +1370,12 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n       estimate_numbers_of_iterations ();\n \n       changed = tree_unroll_loops_completely_1 (may_increase_size,\n-\t\t\t\t\t\tunroll_outer, father_stack,\n+\t\t\t\t\t\tunroll_outer, father_bbs,\n \t\t\t\t\t\tcurrent_loops->tree_root);\n       if (changed)\n \t{\n-\t  struct loop **iter;\n \t  unsigned i;\n \n-\t  /* Be sure to skip unlooped loops while procesing father_stack\n-\t     array.  */\n-\t  FOR_EACH_VEC_ELT (loops_to_unloop, i, iter)\n-\t    (*iter)->aux = NULL;\n-\t  FOR_EACH_VEC_ELT (father_stack, i, iter)\n-\t    if (!(*iter)->aux)\n-\t      *iter = NULL;\n           unloop_loops (loop_closed_ssa_invalidated, &irred_invalidated);\n \n \t  /* We can not use TODO_update_ssa_no_phi because VOPS gets confused.  */\n@@ -1404,18 +1386,30 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \t  else\n \t    update_ssa (TODO_update_ssa);\n \n+\t  /* father_bbs is a bitmap of loop father header BB indices.\n+\t     Translate that to what non-root loops these BBs belong to now.  */\n+\t  bitmap_iterator bi;\n+\t  bitmap fathers = BITMAP_ALLOC (NULL);\n+\t  EXECUTE_IF_SET_IN_BITMAP (father_bbs, 0, i, bi)\n+\t    {\n+\t      basic_block unrolled_loop_bb = BASIC_BLOCK_FOR_FN (cfun, i);\n+\t      if (! unrolled_loop_bb)\n+\t\tcontinue;\n+\t      if (loop_outer (unrolled_loop_bb->loop_father))\n+\t\tbitmap_set_bit (fathers,\n+\t\t\t\tunrolled_loop_bb->loop_father->num);\n+\t    }\n+\t  bitmap_clear (father_bbs);\n \t  /* Propagate the constants within the new basic blocks.  */\n-\t  FOR_EACH_VEC_ELT (father_stack, i, iter)\n-\t    if (*iter)\n-\t      {\n-\t\tunsigned j;\n-\t\tbasic_block *body = get_loop_body_in_dom_order (*iter);\n-\t\tfor (j = 0; j < (*iter)->num_nodes; j++)\n-\t\t  propagate_constants_for_unrolling (body[j]);\n-\t\tfree (body);\n-\t\t(*iter)->aux = NULL;\n-\t      }\n-\t  father_stack.truncate (0);\n+\t  EXECUTE_IF_SET_IN_BITMAP (fathers, 0, i, bi)\n+\t    {\n+\t      loop_p father = get_loop (cfun, i);\n+\t      basic_block *body = get_loop_body_in_dom_order (father);\n+\t      for (unsigned j = 0; j < father->num_nodes; j++)\n+\t\tpropagate_constants_for_unrolling (body[j]);\n+\t      free (body);\n+\t    }\n+\t  BITMAP_FREE (fathers);\n \n \t  /* This will take care of removing completely unrolled loops\n \t     from the loop structures so we can continue unrolling now\n@@ -1435,7 +1429,7 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n   while (changed\n \t && ++iteration <= PARAM_VALUE (PARAM_MAX_UNROLL_ITERATIONS));\n \n-  father_stack.release ();\n+  BITMAP_FREE (father_bbs);\n \n   if (irred_invalidated\n       && loops_state_satisfies_p (LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS))"}]}