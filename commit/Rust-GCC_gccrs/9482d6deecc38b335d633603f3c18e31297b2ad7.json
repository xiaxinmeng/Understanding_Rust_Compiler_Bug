{"sha": "9482d6deecc38b335d633603f3c18e31297b2ad7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ4MmQ2ZGVlY2MzOGIzMzVkNjMzNjAzZjNjMThlMzEyOTdiMmFkNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-18T20:23:49Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-18T20:23:49Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r784", "tree": {"sha": "051695d6d4fbf3728f1df3fd2c926e2adbdb8ab5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/051695d6d4fbf3728f1df3fd2c926e2adbdb8ab5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9482d6deecc38b335d633603f3c18e31297b2ad7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9482d6deecc38b335d633603f3c18e31297b2ad7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9482d6deecc38b335d633603f3c18e31297b2ad7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9482d6deecc38b335d633603f3c18e31297b2ad7/comments", "author": null, "committer": null, "parents": [{"sha": "3bb22aee136865d9eb1d0b34875fd10a130bdec3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bb22aee136865d9eb1d0b34875fd10a130bdec3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bb22aee136865d9eb1d0b34875fd10a130bdec3"}], "stats": {"total": 359, "additions": 240, "deletions": 119}, "files": [{"sha": "68cc05829542af358a1678cf21340d7e40fe8e64", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9482d6deecc38b335d633603f3c18e31297b2ad7/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9482d6deecc38b335d633603f3c18e31297b2ad7/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=9482d6deecc38b335d633603f3c18e31297b2ad7", "patch": "@@ -2922,7 +2922,7 @@\n (define_insn \"\"\n   [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"l,s\"))\n \t (match_operand 1 \"\" \"fg,fg\"))\n-   (clobber (match_scratch:SI 3 \"=l,l\"))]\n+   (clobber (match_scratch:SI 2 \"=l,l\"))]\n   \"\"\n   \"@\n    brl\\;l 2,20(1)"}, {"sha": "fb58aaf35effb5fc602047446fed99c5dcb2f314", "filename": "gcc/genextract.c", "status": "modified", "additions": 239, "deletions": 118, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9482d6deecc38b335d633603f3c18e31297b2ad7/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9482d6deecc38b335d633603f3c18e31297b2ad7/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=9482d6deecc38b335d633603f3c18e31297b2ad7", "patch": "@@ -1,5 +1,5 @@\n /* Generate code from machine description to extract operands from insn as rtl.\n-   Copyright (C) 1987, 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1991, 1992 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -22,6 +22,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"config.h\"\n #include \"rtl.h\"\n #include \"obstack.h\"\n+#include \"insn-config.h\"\n \n static struct obstack obstack;\n struct obstack *rtl_obstack = &obstack;\n@@ -31,46 +32,73 @@ struct obstack *rtl_obstack = &obstack;\n \n extern void free ();\n \n+/* This structure contains all the information needed to describe one\n+   set of extractions methods.  Each method may be used by more than \n+   one pattern if the operands are in the same place.\n+\n+   The string for each operand describes that path to the operand and\n+   contains `0' through `9' when going into an expression and `a' through\n+   `z' when going into a vector.  We assume here that only the first operand\n+   of an rtl expression is a vector.  genrecog.c makes the same assumption\n+   (and uses the same representation) and it is currently true.  */\n+\n+struct extraction\n+{\n+  int op_count;\n+  char *oplocs[MAX_RECOG_OPERANDS];\n+  int dup_count;\n+  char *duplocs[MAX_DUP_OPERANDS];\n+  int dupnums[MAX_DUP_OPERANDS];\n+  struct code_ptr *insns;\n+  struct extraction *next;\n+};\n+\n+/* Holds a single insn code that use an extraction method.  */\n+\n+struct code_ptr\n+{\n+  int insn_code;\n+  struct code_ptr *next;\n+};\n+\n+static struct extraction *extractions;\n+\n /* Number instruction patterns handled, starting at 0 for first one.  */\n \n static int insn_code_number;\n \n+/* Records the large operand number in this insn.  */\n+\n+static int op_count;\n+\n+/* Records the location of any operands using the string format described\n+   above.  */\n+\n+static char *oplocs[MAX_RECOG_OPERANDS];\n+\n /* Number the occurrences of MATCH_DUP in each instruction,\n    starting at 0 for the first occurrence.  */\n \n static int dup_count;\n \n-/* Record which operand numbers have been seen in the current pattern.\n-   This table is made longer as needed.  */\n-\n-static char *operand_seen;\n-\n-/* Current allocated length of operand_seen.  */\n+/* Records the location of any MATCH_DUP operands.  */\n \n-static int operand_seen_length;\n+static char *duplocs[MAX_DUP_OPERANDS];\n \n-/* Have we got any peephole patterns yet?  */\n+/* Record the operand number of any MATCH_DUPs.  */\n \n-static int peephole_seen;\n+static int dupnums[MAX_DUP_OPERANDS];\n \n-/* While tree-walking an instruction pattern, we keep a chain\n-   of these `struct link's to record how to get down to the\n-   current position.  In each one, POS is the operand number,\n-   and if the operand is a vector VEC is the element number.\n-   VEC is -1 if the operand is not a vector.  */\n+/* Record the list of insn_codes for peepholes.  */\n \n-struct link\n-{\n-  struct link *next;\n-  int pos;\n-  int vecelt;\n-};\n+static struct code_ptr *peepholes;\n \n static void walk_rtx ();\n static void print_path ();\n char *xmalloc ();\n char *xrealloc ();\n static void fatal ();\n+static char *copystr ();\n static void mybzero ();\n void fancy_abort ();\n \f\n@@ -79,68 +107,93 @@ gen_insn (insn)\n      rtx insn;\n {\n   register int i;\n+  register struct extraction *p;\n+  register struct code_ptr *link;\n \n+  op_count = 0;\n   dup_count = 0;\n \n   /* No operands seen so far in this pattern.  */\n-  mybzero (operand_seen, operand_seen_length);\n-\n-  printf (\"    case %d:\\n\", insn_code_number);\n+  mybzero (oplocs, sizeof oplocs);\n \n   /* Walk the insn's pattern, remembering at all times the path\n      down to the walking point.  */\n \n   if (XVECLEN (insn, 1) == 1)\n-    walk_rtx (XVECEXP (insn, 1, 0), 0);\n+    walk_rtx (XVECEXP (insn, 1, 0), \"\");\n   else\n     for (i = XVECLEN (insn, 1) - 1; i >= 0; i--)\n       {\n-\tstruct link link;\n-\tlink.next = 0;\n-\tlink.pos = 0;\n-\tlink.vecelt = i;\n-\twalk_rtx (XVECEXP (insn, 1, i), &link);\n-      }\n+\tchar *path = (char *) alloca (2);\n \n-  /* If the operand numbers used in the pattern are not consecutive,\n-     don't leave an operand uninitialized.  */\n-  for (i = operand_seen_length - 1; i >= 0; i--)\n-    if (operand_seen[i])\n-      break;\n-  for (; i >= 0; i--)\n-    if (!operand_seen[i])\n-      {\n-\tprintf (\"      ro[%d] = const0_rtx;\\n\", i);\n-\tprintf (\"      ro_loc[%d] = &junk;\\n\", i);\n+\tpath[0] = 'a' + i;\n+\tpath[1] = 0;\n+\n+\twalk_rtx (XVECEXP (insn, 1, i), path);\n       }\n-  printf (\"      break;\\n\");\n-}\n-\f\n-/* Record that we have seen an operand with number OPNO in this pattern.  */\n \n-static void\n-mark_operand_seen (opno)\n-     int opno;\n-{\n-  if (opno >= operand_seen_length)\n+  link = (struct code_ptr *) xmalloc (sizeof (struct code_ptr));\n+  link->insn_code = insn_code_number;\n+\n+  /* See if we find something that already had this extraction method. */\n+\n+  for (p = extractions; p; p = p->next)\n     {\n-      operand_seen_length *= 2;\n-      operand_seen = (char *) xrealloc (operand_seen, operand_seen_length);\n+      if (p->op_count != op_count || p->dup_count != dup_count)\n+\tcontinue;\n+\n+      for (i = 0; i < op_count; i++)\n+\tif (p->oplocs[i] != oplocs[i]\n+\t    && ! (p->oplocs[i] != 0 && oplocs[i] != 0\n+\t\t  && ! strcmp (p->oplocs[i], oplocs[i])))\n+\t  break;\n+\n+      if (i != op_count)\n+\tcontinue;\n+\n+      for (i = 0; i < dup_count; i++)\n+\tif (p->dupnums[i] != dupnums[i]\n+\t    || strcmp (p->duplocs[i], duplocs[i]))\n+\t  break;\n+\n+      if (i != dup_count)\n+\tcontinue;\n+\n+      /* This extraction is the same as ours.  Just link us in.  */\n+      link->next = p->insns;\n+      p->insns = link;\n+      return;\n     }\n \n-  operand_seen[opno] = 1;\n-}\n+  /* Otherwise, make a new extraction method.  */\n \n+  p = (struct extraction *) xmalloc (sizeof (struct extraction));\n+  p->op_count = op_count;\n+  p->dup_count = dup_count;\n+  p->next = extractions;\n+  extractions = p;\n+  p->insns = link;\n+  link->next = 0;\n+\n+  for (i = 0; i < op_count; i++)\n+    p->oplocs[i] = oplocs[i];\n+\n+  for (i = 0; i < dup_count; i++)\n+    p->dupnums[i] = dupnums[i], p->duplocs[i] = duplocs[i];\n+}\n+\f\n static void\n walk_rtx (x, path)\n      rtx x;\n-     struct link *path;\n+     char *path;\n {\n   register RTX_CODE code;\n   register int i;\n   register int len;\n   register char *fmt;\n-  struct link link;\n+  register struct code_ptr *link;\n+  int depth = strlen (path);\n+  char *newpath;\n \n   if (x == 0)\n     return;\n@@ -157,49 +210,44 @@ walk_rtx (x, path)\n \n     case MATCH_OPERAND:\n     case MATCH_SCRATCH:\n-      mark_operand_seen (XINT (x, 0));\n-      printf (\"      ro[%d] = *(ro_loc[%d] = &\",\n-\t      XINT (x, 0), XINT (x, 0));\n-      print_path (path);\n-      printf (\");\\n\");\n+      oplocs[XINT (x, 0)] = copystr (path);\n+      op_count = MAX (op_count, XINT (x, 0) + 1);\n       break;\n \n     case MATCH_DUP:\n     case MATCH_OP_DUP:\n-      printf (\"      recog_dup_loc[%d] = &\", dup_count);\n-      print_path (path);\n-      printf (\";\\n\");\n-      printf (\"      recog_dup_num[%d] = %d;\\n\", dup_count, XINT (x, 0));\n+      duplocs[dup_count] = copystr (path);\n+      dupnums[dup_count] = XINT (x, 0);\n       dup_count++;\n       break;\n \n     case MATCH_OPERATOR:\n-      mark_operand_seen (XINT (x, 0));\n-      printf (\"      ro[%d] = *(ro_loc[%d]\\n        = &\",\n-\t      XINT (x, 0), XINT (x, 0));\n-      print_path (path);\n-      printf (\");\\n\");\n-      link.next = path;\n-      link.vecelt = -1;\n+      oplocs[XINT (x, 0)] = copystr (path);\n+      op_count = MAX (op_count, XINT (x, 0) + 1);\n+\n+      newpath = (char *) alloca (depth + 2);\n+      strcpy (newpath, path);\n+      newpath[depth + 1] = 0;\n+\n       for (i = XVECLEN (x, 2) - 1; i >= 0; i--)\n \t{\n-\t  link.pos = i;\n-\t  walk_rtx (XVECEXP (x, 2, i), &link);\n+\t  newpath[depth] = '0' + i;\n+\t  walk_rtx (XVECEXP (x, 2, i), newpath);\n \t}\n       return;\n \n     case MATCH_PARALLEL:\n-      mark_operand_seen (XINT (x, 0));\n-      printf (\"      ro[%d] = *(ro_loc[%d]\\n        = &\",\n-\t      XINT (x, 0), XINT (x, 0));\n-      print_path (path);\n-      printf (\");\\n\");\n-      link.next = path;\n-      link.pos = 0;\n+      oplocs[XINT (x, 0)] = copystr (path);\n+      op_count = MAX (op_count, XINT (x, 0) + 1);\n+\n+      newpath = (char *) alloca (depth + 2);\n+      strcpy (newpath, path);\n+      newpath[depth + 1] = 0;\n+\n       for (i = XVECLEN (x, 2) - 1; i >= 0; i--)\n \t{\n-\t  link.vecelt = i;\n-\t  walk_rtx (XVECEXP (x, 2, i), &link);\n+\t  newpath[depth] = 'a' + i;\n+\t  walk_rtx (XVECEXP (x, 2, i), newpath);\n \t}\n       return;\n \n@@ -208,24 +256,26 @@ walk_rtx (x, path)\n       return;\n     }\n \n-  link.next = path;\n-  link.vecelt = -1;\n+  newpath = (char *) alloca (depth + 2);\n+  strcpy (newpath, path);\n+  newpath[depth + 1] = 0;\n+\n   fmt = GET_RTX_FORMAT (code);\n   len = GET_RTX_LENGTH (code);\n   for (i = 0; i < len; i++)\n     {\n-      link.pos = i;\n       if (fmt[i] == 'e' || fmt[i] == 'u')\n \t{\n-\t  walk_rtx (XEXP (x, i), &link);\n+\t  newpath[depth] = '0' + i;\n+\t  walk_rtx (XEXP (x, i), newpath);\n \t}\n       else if (fmt[i] == 'E')\n \t{\n \t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    {\n-\t      link.vecelt = j;\n-\t      walk_rtx (XVECEXP (x, i, j), &link);\n+\t      newpath[depth] = 'a' + i;\n+\t      walk_rtx (XVECEXP (x, i, j), newpath);\n \t    }\n \t}\n     }\n@@ -237,21 +287,34 @@ walk_rtx (x, path)\n \n static void\n print_path (path)\n-     struct link *path;\n+     char *path;\n {\n-  if (path == 0)\n-    printf (\"insn\");\n-  else if (path->vecelt >= 0)\n+  register int len = strlen (path);\n+  register int i;\n+\n+  /* We first write out the operations (XEXP or XVECEXP) in reverse\n+     order, then write \"insn\", then the indices in forward order.  */\n+\n+  for (i = len - 1; i >=0 ; i--)\n     {\n-      printf (\"XVECEXP (\");\n-      print_path (path->next);\n-      printf (\", %d, %d)\", path->pos, path->vecelt);\n+      if (path[i] >= 'a' && path[i] <= 'z')\n+\tprintf (\"XVECEXP (\");\n+      else if (path[i] >= '0' && path[i] <= '9')\n+\tprintf (\"XEXP (\");\n+      else\n+\tabort ();\n     }\n-  else\n+  \n+  printf (\"insn\");\n+\n+  for (i = 0; i < len; i++)\n     {\n-      printf (\"XEXP (\");\n-      print_path (path->next);\n-      printf (\", %d)\", path->pos);\n+      if (path[i] >= 'a' && path[i] <= 'z')\n+\tprintf (\", 0, %d)\", path[i] - 'a');\n+      else if (path[i] >= '0' && path[i] <= '9')\n+\tprintf (\", %d)\", path[i] - '0');\n+      else\n+\tabort ();\n     }\n }\n \f\n@@ -296,6 +359,21 @@ fancy_abort ()\n   fatal (\"Internal gcc abort.\");\n }\n \n+static char *\n+copystr (s1)\n+     char *s1;\n+{\n+  register char *tem;\n+\n+  if (s1 == 0)\n+    return 0;\n+\n+  tem = (char *) xmalloc (strlen (s1) + 1);\n+  strcpy (tem, s1);\n+\n+  return tem;\n+}\n+\n static void\n mybzero (b, length)\n      register char *b;\n@@ -314,6 +392,8 @@ main (argc, argv)\n   FILE *infile;\n   extern rtx read_rtx ();\n   register int c, i;\n+  struct extraction *p;\n+  struct code_ptr *link;\n \n   obstack_init (rtl_obstack);\n \n@@ -334,9 +414,6 @@ main (argc, argv)\n \n   insn_code_number = 0;\n \n-  operand_seen_length = 40;\n-  operand_seen = (char *) xmalloc (40);\n-\n   printf (\"/* Generated automatically by the program `genextract'\\n\\\n from the machine description file `md'.  */\\n\\n\");\n \n@@ -346,6 +423,7 @@ from the machine description file `md'.  */\\n\\n\");\n   /* This variable exists only so it can be the \"location\"\n      of any missing operand whose numbers are skipped by a given pattern.  */\n   printf (\"static rtx junk;\\n\");\n+\n   printf (\"extern rtx recog_operand[];\\n\");\n   printf (\"extern rtx *recog_operand_loc[];\\n\");\n   printf (\"extern rtx *recog_dup_loc[];\\n\");\n@@ -359,10 +437,11 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"  register rtx *ro = recog_operand;\\n\");\n   printf (\"  register rtx **ro_loc = recog_operand_loc;\\n\");\n   printf (\"  int insn_code = INSN_CODE (insn);\\n\");\n-  printf (\"  if (insn_code == -1) fatal_insn_not_found (insn);\\n\");\n   printf (\"  insn = PATTERN (insn);\\n\");\n   printf (\"  switch (insn_code)\\n\");\n   printf (\"    {\\n\");\n+  printf (\"    case -1:\\n\");\n+  printf (\"      fatal_insn_not_found (insn);\\n\\n\");\n \n   /* Read the machine description.  */\n \n@@ -379,36 +458,78 @@ from the machine description file `md'.  */\\n\\n\");\n \t  gen_insn (desc);\n \t  ++insn_code_number;\n \t}\n-      if (GET_CODE (desc) == DEFINE_PEEPHOLE)\n-\t{\n-\t  printf (\"    case %d: goto peephole;\\n\", insn_code_number);\n-\t  ++insn_code_number;\n-\t  ++peephole_seen;\n-\t}\n-      if (GET_CODE (desc) == DEFINE_EXPAND || GET_CODE (desc) == DEFINE_SPLIT)\n+\n+      else if (GET_CODE (desc) == DEFINE_PEEPHOLE)\n \t{\n-\t  printf (\"    case %d: break;\\n\", insn_code_number);\n+\t  struct code_ptr *link\n+\t    = (struct code_ptr *) xmalloc (sizeof (struct code_ptr));\n+\n+\t  link->insn_code = insn_code_number;\n+\t  link->next = peepholes;\n+\t  peepholes = link;\n \t  ++insn_code_number;\n \t}\n-    }\n \n-  /* This should never be reached.  */\n-  printf (\"\\n    default:\\n      abort ();\\n\");\n+      else if (GET_CODE (desc) == DEFINE_EXPAND\n+\t       || GET_CODE (desc) == DEFINE_SPLIT)\n+\t++insn_code_number;\n+    }\n \n-  if (peephole_seen)\n+  /* Write out code to handle peepholes and the insn_codes that it should\n+     be called for.  */\n+  if (peepholes)\n     {\n+      for (link = peepholes; link; link = link->next)\n+\tprintf (\"    case %d:\\n\", link->insn_code);\n+\n       /* The vector in the insn says how many operands it has.\n \t And all it contains are operands.  In fact, the vector was\n \t created just for the sake of this function.  */\n-      printf (\"    peephole:\\n\");\n       printf (\"#if __GNUC__ > 1 && !defined (bcopy)\\n\");\n       printf (\"#define bcopy(FROM,TO,COUNT) __builtin_memcpy(TO,FROM,COUNT)\\n\");\n       printf (\"#endif\\n\");\n       printf (\"      bcopy (&XVECEXP (insn, 0, 0), ro,\\n\");\n       printf (\"             sizeof (rtx) * XVECLEN (insn, 0));\\n\");\n-      printf (\"      break;\\n\");\n+      printf (\"      break;\\n\\n\");\n+    }\n+\n+  /* Write out all the ways to extract insn operands.  */\n+  for (p = extractions; p; p = p->next)\n+    {\n+      for (link = p->insns; link; link = link->next)\n+\tprintf (\"    case %d:\\n\", link->insn_code);\n+\n+      for (i = 0; i < p->op_count; i++)\n+\t{\n+\t  if (p->oplocs[i] == 0)\n+\t    {\n+\t      printf (\"      ro[%d] = const0_rtx;\\n\", i);\n+\t      printf (\"      ro_loc[%d] = &junk;\\n\", i, i);\n+\t    }\n+\t  else\n+\t    {\n+\t      printf (\"      ro[%d] = *(ro_loc[%d] = &\", i, i);\n+\t      print_path (p->oplocs[i]);\n+\t      printf (\");\\n\");\n+\t    }\n+\t}\n+\n+      for (i = 0; i < p->dup_count; i++)\n+\t{\n+\t  printf (\"      recog_dup_loc[%d] = &\", i);\n+\t  print_path (p->duplocs[i]);\n+\t  printf (\";\\n\");\n+\t  printf (\"      recog_dup_num[%d] = %d;\\n\", i, p->dupnums[i]);\n+\t}\n+\n+      printf (\"      break;\\n\\n\");\n     }\n \n+  /* This should never be reached.  Note that we would also reach this abort\n+   if we tried to extract something whose INSN_CODE was a DEFINE_EXPAND or\n+   DEFINE_SPLIT, but that is correct.  */\n+  printf (\"    default:\\n      abort ();\\n\");\n+\n   printf (\"    }\\n}\\n\");\n \n   fflush (stdout);"}]}