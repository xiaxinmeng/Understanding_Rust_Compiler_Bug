{"sha": "96f26e41615a7767578deead92417485696c7f4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZmMjZlNDE2MTVhNzc2NzU3OGRlZWFkOTI0MTc0ODU2OTZjN2Y0Zg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-06-12T20:33:02Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-06-12T20:33:02Z"}, "message": "re PR middle-end/168 (Spurious signed/unsigned comparison warning)\n\n\n\tPR middle-end/168\n\t* fold-const.c (tree_expr_nonnegative_p):  Handle addition\n\tand multiplication of zero extensions, floating point division,\n\tand integer<->fp, fp<->fp and zero extension conversions.\n\tThe built-in ceil and floor functions preserve signedness.\n\n\t* gcc.dg/20030612-1.c: New test case.\n\nFrom-SVN: r67850", "tree": {"sha": "d43978ab935534e794d98400e5934ee15ca8180e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d43978ab935534e794d98400e5934ee15ca8180e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96f26e41615a7767578deead92417485696c7f4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96f26e41615a7767578deead92417485696c7f4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96f26e41615a7767578deead92417485696c7f4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96f26e41615a7767578deead92417485696c7f4f/comments", "author": null, "committer": null, "parents": [{"sha": "6356f8928853bc14e841e5b4e990ce2508c38f26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6356f8928853bc14e841e5b4e990ce2508c38f26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6356f8928853bc14e841e5b4e990ce2508c38f26"}], "stats": {"total": 118, "additions": 111, "deletions": 7}, "files": [{"sha": "d50d290912ca1fc01b0686c6b3f9977fa310687a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f26e41615a7767578deead92417485696c7f4f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f26e41615a7767578deead92417485696c7f4f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96f26e41615a7767578deead92417485696c7f4f", "patch": "@@ -1,3 +1,11 @@\n+2003-06-12  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR middle-end/168\n+\t* fold-const.c (tree_expr_nonnegative_p):  Handle addition\n+\tand multiplication of zero extensions, floating point division,\n+\tand integer<->fp, fp<->fp and zero extension conversions.\n+\tThe built-in ceil and floor functions preserve signedness.\n+\n 2003-06-12  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* ChangeLog: Follow spelling conventions."}, {"sha": "e67f0f657699b25ef0afe153251a058e8ff9c7e6", "filename": "gcc/fold-const.c", "status": "modified", "additions": 78, "deletions": 7, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f26e41615a7767578deead92417485696c7f4f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f26e41615a7767578deead92417485696c7f4f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=96f26e41615a7767578deead92417485696c7f4f", "patch": "@@ -8022,9 +8022,27 @@ tree_expr_nonnegative_p (t)\n       return ! REAL_VALUE_NEGATIVE (TREE_REAL_CST (t));\n \n     case PLUS_EXPR:\n-      return FLOAT_TYPE_P (TREE_TYPE (t))\n-\t     && tree_expr_nonnegative_p (TREE_OPERAND (t, 0))\n-\t     && tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n+      if (FLOAT_TYPE_P (TREE_TYPE (t)))\n+\treturn tree_expr_nonnegative_p (TREE_OPERAND (t, 0))\n+\t       && tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n+\n+      /* zero_extend(x) + zero_extend(y) is non-negative is x and y are\n+\t both unsigned and at atleast 2 bits shorter than the result.  */\n+      if (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE\n+\t  && TREE_CODE (TREE_OPERAND (t, 0)) == NOP_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (t, 1)) == NOP_EXPR)\n+\t{\n+\t  tree inner1 = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n+\t  tree inner2 = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 1), 0));\n+\t  if (TREE_CODE (inner1) == INTEGER_TYPE && TREE_UNSIGNED (inner1)\n+\t      && TREE_CODE (inner2) == INTEGER_TYPE && TREE_UNSIGNED (inner2))\n+\t    {\n+\t      unsigned int prec = MAX (TYPE_PRECISION (inner1),\n+\t\t\t\t       TYPE_PRECISION (inner2)) + 1;\n+\t      return prec < TYPE_PRECISION (TREE_TYPE (t));\n+\t    }\n+\t}\n+      break;\n \n     case MULT_EXPR:\n       if (FLOAT_TYPE_P (TREE_TYPE (t)))\n@@ -8035,19 +8053,66 @@ tree_expr_nonnegative_p (t)\n \t  return tree_expr_nonnegative_p (TREE_OPERAND (t, 0))\n \t\t && tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n \t}\n+\n+      /* zero_extend(x) * zero_extend(y) is non-negative is x and y are\n+\t both unsigned and their total bits is shorter than the result.  */\n+      if (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE\n+\t  && TREE_CODE (TREE_OPERAND (t, 0)) == NOP_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (t, 1)) == NOP_EXPR)\n+\t{\n+\t  tree inner1 = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n+\t  tree inner2 = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 1), 0));\n+\t  if (TREE_CODE (inner1) == INTEGER_TYPE && TREE_UNSIGNED (inner1)\n+\t      && TREE_CODE (inner2) == INTEGER_TYPE && TREE_UNSIGNED (inner2))\n+\t    return TYPE_PRECISION (inner1) + TYPE_PRECISION (inner2)\n+\t\t   < TYPE_PRECISION (TREE_TYPE (t));\n+\t}\n       return 0;\n \n     case TRUNC_DIV_EXPR:\n     case CEIL_DIV_EXPR:\n     case FLOOR_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n       return tree_expr_nonnegative_p (TREE_OPERAND (t, 0))\n-\t&& tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n+\t     && tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n+\n     case TRUNC_MOD_EXPR:\n     case CEIL_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n     case ROUND_MOD_EXPR:\n       return tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n+\n+    case RDIV_EXPR:\n+      return tree_expr_nonnegative_p (TREE_OPERAND (t, 0))\n+\t     && tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n+\n+    case NOP_EXPR:\n+      {\n+\ttree inner_type = TREE_TYPE (TREE_OPERAND (t, 0));\n+\ttree outer_type = TREE_TYPE (t);\n+\n+\tif (TREE_CODE (outer_type) == REAL_TYPE)\n+\t  {\n+\t    if (TREE_CODE (inner_type) == REAL_TYPE)\n+\t      return tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n+\t    if (TREE_CODE (inner_type) == INTEGER_TYPE)\n+\t      {\n+\t\tif (TREE_UNSIGNED (inner_type))\n+\t\t  return 1;\n+\t\treturn tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n+\t      }\n+\t  }\n+\telse if (TREE_CODE (outer_type) == INTEGER_TYPE)\n+\t  {\n+\t    if (TREE_CODE (inner_type) == REAL_TYPE)\n+\t      return tree_expr_nonnegative_p (TREE_OPERAND (t,0));\n+\t    if (TREE_CODE (inner_type) == INTEGER_TYPE)\n+\t      return TYPE_PRECISION (inner_type) < TYPE_PRECISION (outer_type)\n+\t\t      && TREE_UNSIGNED (inner_type);\n+\t  }\n+      }\n+      break;\n+\n     case COND_EXPR:\n       return tree_expr_nonnegative_p (TREE_OPERAND (t, 1))\n \t&& tree_expr_nonnegative_p (TREE_OPERAND (t, 2));\n@@ -8097,6 +8162,12 @@ tree_expr_nonnegative_p (t)\n \t      case BUILT_IN_ATAN:\n \t      case BUILT_IN_ATANF:\n \t      case BUILT_IN_ATANL:\n+\t      case BUILT_IN_CEIL:\n+\t      case BUILT_IN_CEILF:\n+\t      case BUILT_IN_CEILL:\n+\t      case BUILT_IN_FLOOR:\n+\t      case BUILT_IN_FLOORF:\n+\t      case BUILT_IN_FLOORL:\n \t\treturn tree_expr_nonnegative_p (TREE_VALUE (arglist));\n \n \t      case BUILT_IN_POW:\n@@ -8115,10 +8186,10 @@ tree_expr_nonnegative_p (t)\n       if (truth_value_p (TREE_CODE (t)))\n \t/* Truth values evaluate to 0 or 1, which is nonnegative.  */\n \treturn 1;\n-      else\n-\t/* We don't know sign of `t', so be conservative and return false.  */\n-\treturn 0;\n     }\n+\n+  /* We don't know sign of `t', so be conservative and return false.  */\n+  return 0;\n }\n \n /* Return true if `r' is known to be non-negative."}, {"sha": "5a31745ce5eb48722af495e9c6c8a1d8813faf6c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f26e41615a7767578deead92417485696c7f4f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f26e41615a7767578deead92417485696c7f4f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=96f26e41615a7767578deead92417485696c7f4f", "patch": "@@ -1,3 +1,8 @@\n+2003-06-12  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR middle-end/168\n+\t* gcc.dg/20030612-1.c: New test case.\n+\n 2003-06-12  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/10635"}, {"sha": "f9f212caba112278fb463846c8efa760106aaf55", "filename": "gcc/testsuite/gcc.dg/20030612-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f26e41615a7767578deead92417485696c7f4f/gcc%2Ftestsuite%2Fgcc.dg%2F20030612-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f26e41615a7767578deead92417485696c7f4f/gcc%2Ftestsuite%2Fgcc.dg%2F20030612-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20030612-1.c?ref=96f26e41615a7767578deead92417485696c7f4f", "patch": "@@ -0,0 +1,20 @@\n+/* Derived from PR middle-end/168.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-W\" } */\n+\n+extern void foo ();\n+\n+unsigned char uc;\n+unsigned short int usi;\n+unsigned int ui;\n+\n+\n+void bar()\n+{\n+  if (uc + usi >= ui)  /* { dg-bogus \"between signed and unsigned\" } */\n+    foo ();\n+  if (uc * usi >= ui)  /* { dg-bogus \"between signed and unsigned\" } */\n+    foo ();\n+}\n+"}]}