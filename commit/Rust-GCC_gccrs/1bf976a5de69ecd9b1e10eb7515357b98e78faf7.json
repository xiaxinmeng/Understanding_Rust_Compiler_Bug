{"sha": "1bf976a5de69ecd9b1e10eb7515357b98e78faf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJmOTc2YTVkZTY5ZWNkOWIxZTEwZWI3NTE1MzU3Yjk4ZTc4ZmFmNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-08-18T08:20:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-08-18T08:20:50Z"}, "message": "openmp: Actually ignore pragma_stmt pragmas for which c_parser_pragma returns false\n\nUnlike the C++ FE, the C FE ignored pragmas (as if they weren't there) in\npragma_stmt contexts if c*_parser_pragma returns false only when after labels,\nnot inside of substatements of selection or loop statements.\nAfter making just that change, several gomp/goacc testcases started failing,\nbecause extra diagnostics has been emitted (in C, in C++ it was emitted\nalready before).  Say\nvoid\nfoo (int x)\n{\n  if (x)\n    #pragma omp barrier\n}\nused to in C emit just an error that the pragma is not allowed in such\ncontexts, but in C++ emitted both that and a parsing error that\n  if (x)\n}\nis invalid.  So, the rest of this patch is mostly about returning true\nafter we report that that certain pragma is not allowed in pragma_stmt\ncontexts, because for error-recovery it seems better to treat the\npragma in that case as something that is the substatement of such if etc.\nc*_parser_pragma return value is only ever used for pragma_stmt context,\nin which false means act as if the pragma isn't there (e.g. has been handled\nalready by preprocessor etc.), and true which means it was there.\n\n2021-08-18  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/c/\n\t* c-parser.c (c_parser_statement_after_labels): Add restart label\n\tnear the start of the function.  If c_parser_pragma returns false,\n\tgoto restart.\n\t(c_parser_pragma): For PRAGMA_OMP_CANCELLATION_POINT return what\n\tc_parser_omp_cancellation_point returned.  For PRAGMA_OMP_DECLARE\n\treturn what c_parser_omp_declare returned.  Return true instead of\n\tfalse after emitting errors that the directive is not allowed in\n\tpragma_stmt context.\n\t(c_parser_omp_ordered): Return true instead of\n\tfalse after emitting errors that the directive is not allowed in\n\tpragma_stmt context.\n\t(c_parser_omp_target_update): Likewise.\n\t(c_parser_omp_target_enter_data, c_parser_omp_target_exit_data):\n\tChange return type from tree to bool, return false if the\n\tdirective should be ignored in pragma_stmt contexts.\n\t(c_parser_omp_target): Adjust callers of c_parser_omp_target_*_data,\n\treturn their result directly.\n\t(c_parser_omp_cancellation_point): Change return type from void to\n\tbool, return false if the directive should be ignored in pragma_stmt\n\tcontexts.\n\t(c_parser_omp_declare): Likewise.\ngcc/cp/\n\t* parser.c (cp_parser_omp_ordered): Return true instead of\n\tfalse after emitting errors that the directive is not allowed in\n\tpragma_stmt context.\n\t(cp_parser_omp_target_update): Likewise.\n\t(cp_parser_omp_cancellation_point): Change return type from void to\n\tbool, return false if the directive should be ignored in pragma_stmt\n\tcontexts.\n\t(cp_parser_omp_target_enter_data, cp_parser_omp_target_exit_data):\n\tChange return type from tree to bool, return false if the\n\tdirective should be ignored in pragma_stmt contexts.\n\t(cp_parser_omp_target): Adjust callers of cp_parser_omp_target_*_data,\n\treturn their result directly.\n\t(cp_parser_pragma): For PRAGMA_OMP_CANCELLATION_POINT return what\n\tcp_parser_omp_cancellation_point returned.  Return true instead of\n\tfalse after emitting errors that the directive is not allowed in\n\tpragma_stmt context.\ngcc/testsuite/\n\t* c-c++-common/gomp/pr63326.c: Don't expect extra \"before\" errors\n\tin C++.\n\t* g++.dg/gomp/attrs-7.C: Don't expect one extra error.\n\t* g++.dg/gomp/barrier-2.C: Likewise.\n\t* gcc.dg/gomp/declare-simd-5.c: Likewise.\n\t* gcc.dg/gomp/barrier-2.c: Likewise.\n\t* gcc.dg/gomp/declare-variant-2.c: Likewise.", "tree": {"sha": "41975adde158ceed57cf4f3a2573fad707c4fb2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41975adde158ceed57cf4f3a2573fad707c4fb2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bf976a5de69ecd9b1e10eb7515357b98e78faf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bf976a5de69ecd9b1e10eb7515357b98e78faf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bf976a5de69ecd9b1e10eb7515357b98e78faf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97d51c1764554fcef05fe94ee6445f5d2252bcff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97d51c1764554fcef05fe94ee6445f5d2252bcff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97d51c1764554fcef05fe94ee6445f5d2252bcff"}], "stats": {"total": 188, "additions": 99, "deletions": 89}, "files": [{"sha": "565efc4d2e96d0430c7735899ace3399941bd5a7", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=1bf976a5de69ecd9b1e10eb7515357b98e78faf7", "patch": "@@ -1582,10 +1582,10 @@ static void c_parser_omp_cancel (c_parser *);\n enum pragma_context { pragma_external, pragma_struct, pragma_param,\n \t\t      pragma_stmt, pragma_compound };\n static bool c_parser_pragma (c_parser *, enum pragma_context, bool *);\n-static void c_parser_omp_cancellation_point (c_parser *, enum pragma_context);\n+static bool c_parser_omp_cancellation_point (c_parser *, enum pragma_context);\n static bool c_parser_omp_target (c_parser *, enum pragma_context, bool *);\n static void c_parser_omp_end_declare_target (c_parser *);\n-static void c_parser_omp_declare (c_parser *, enum pragma_context);\n+static bool c_parser_omp_declare (c_parser *, enum pragma_context);\n static void c_parser_omp_requires (c_parser *);\n static bool c_parser_omp_ordered (c_parser *, enum pragma_context, bool *);\n static void c_parser_oacc_routine (c_parser *, enum pragma_context);\n@@ -6100,6 +6100,7 @@ c_parser_statement_after_labels (c_parser *parser, bool *if_p,\n   if (c_parser_peek_token (parser)->type != CPP_OPEN_BRACE)\n     add_debug_begin_stmt (loc);\n \n+ restart:\n   switch (c_parser_peek_token (parser)->type)\n     {\n     case CPP_OPEN_BRACE:\n@@ -6246,7 +6247,8 @@ c_parser_statement_after_labels (c_parser *parser, bool *if_p,\n       c_parser_consume_token (parser);\n       break;\n     case CPP_PRAGMA:\n-      c_parser_pragma (parser, pragma_stmt, if_p);\n+      if (!c_parser_pragma (parser, pragma_stmt, if_p))\n+        goto restart;\n       break;\n     default:\n     expr_stmt:\n@@ -12346,7 +12348,7 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)\n \t\t\t\"%<#pragma %s%> may only be used in compound \"\n \t\t\t\"statements\", construct);\n \t      c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n-\t      return false;\n+\t      return true;\n \t    }\n \t  goto bad_stmt;\n \t}\n@@ -12437,8 +12439,7 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)\n       return false;\n \n     case PRAGMA_OMP_CANCELLATION_POINT:\n-      c_parser_omp_cancellation_point (parser, context);\n-      return false;\n+      return c_parser_omp_cancellation_point (parser, context);\n \n     case PRAGMA_OMP_THREADPRIVATE:\n       c_parser_omp_threadprivate (parser);\n@@ -12466,8 +12467,7 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)\n       return false;\n \n     case PRAGMA_OMP_DECLARE:\n-      c_parser_omp_declare (parser, context);\n-      return false;\n+      return c_parser_omp_declare (parser, context);\n \n     case PRAGMA_OMP_REQUIRES:\n       if (context != pragma_external)\n@@ -12505,7 +12505,7 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)\n \telse\n \t  c_parser_do_statement (parser, ivdep, unroll);\n       }\n-      return false;\n+      return true;\n \n     case PRAGMA_UNROLL:\n       {\n@@ -12529,7 +12529,7 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)\n \telse\n \t  c_parser_do_statement (parser, ivdep, unroll);\n       }\n-      return false;\n+      return true;\n \n     case PRAGMA_GCC_PCH_PREPROCESS:\n       c_parser_error (parser, \"%<#pragma GCC pch_preprocess%> must be first\");\n@@ -19125,7 +19125,7 @@ c_parser_omp_ordered (c_parser *parser, enum pragma_context context,\n \t\t\t\"%<#pragma omp ordered%> with %<depend%> clause may \"\n \t\t\t\"only be used in compound statements\");\n \t      c_parser_skip_to_pragma_eol (parser, false);\n-\t      return false;\n+\t      return true;\n \t    }\n \n \t  tree clauses\n@@ -19655,7 +19655,7 @@ c_parser_omp_cancel (c_parser *parser)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SECTIONS)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_TASKGROUP))\n \n-static void\n+static bool\n c_parser_omp_cancellation_point (c_parser *parser, enum pragma_context context)\n {\n   location_t loc = c_parser_peek_token (parser)->location;\n@@ -19676,7 +19676,7 @@ c_parser_omp_cancellation_point (c_parser *parser, enum pragma_context context)\n     {\n       c_parser_error (parser, \"expected %<point%>\");\n       c_parser_skip_to_pragma_eol (parser);\n-      return;\n+      return false;\n     }\n \n   if (context != pragma_compound)\n@@ -19688,14 +19688,15 @@ c_parser_omp_cancellation_point (c_parser *parser, enum pragma_context context)\n       else\n \tc_parser_error (parser, \"expected declaration specifiers\");\n       c_parser_skip_to_pragma_eol (parser, false);\n-      return;\n+      return true;\n     }\n \n   clauses\n     = c_parser_omp_all_clauses (parser, OMP_CANCELLATION_POINT_CLAUSE_MASK,\n \t\t\t\t\"#pragma omp cancellation point\");\n \n   c_finish_omp_cancellation_point (loc, clauses);\n+  return true;\n }\n \n /* OpenMP 4.0:\n@@ -19981,7 +19982,7 @@ c_parser_omp_target_update (location_t loc, c_parser *parser,\n       error_at (loc, \"%<#pragma %s%> may only be used in compound statements\",\n \t\t\"omp target update\");\n       c_parser_skip_to_pragma_eol (parser, false);\n-      return false;\n+      return true;\n     }\n \n   tree clauses\n@@ -20014,7 +20015,7 @@ c_parser_omp_target_update (location_t loc, c_parser *parser,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n-static tree\n+static bool\n c_parser_omp_target_enter_data (location_t loc, c_parser *parser,\n \t\t\t\tenum pragma_context context)\n {\n@@ -20032,15 +20033,15 @@ c_parser_omp_target_enter_data (location_t loc, c_parser *parser,\n     {\n       c_parser_error (parser, \"expected %<data%>\");\n       c_parser_skip_to_pragma_eol (parser);\n-      return NULL_TREE;\n+      return false;\n     }\n \n   if (context == pragma_stmt)\n     {\n       error_at (loc, \"%<#pragma %s%> may only be used in compound statements\",\n \t\t\"omp target enter data\");\n       c_parser_skip_to_pragma_eol (parser, false);\n-      return NULL_TREE;\n+      return true;\n     }\n \n   tree clauses\n@@ -20079,15 +20080,15 @@ c_parser_omp_target_enter_data (location_t loc, c_parser *parser,\n \terror_at (loc,\n \t\t  \"%<#pragma omp target enter data%> must contain at least \"\n \t\t  \"one %<map%> clause\");\n-      return NULL_TREE;\n+      return true;\n     }\n \n   tree stmt = make_node (OMP_TARGET_ENTER_DATA);\n   TREE_TYPE (stmt) = void_type_node;\n   OMP_TARGET_ENTER_DATA_CLAUSES (stmt) = clauses;\n   SET_EXPR_LOCATION (stmt, loc);\n   add_stmt (stmt);\n-  return stmt;\n+  return true;\n }\n \n /* OpenMP 4.5:\n@@ -20100,7 +20101,7 @@ c_parser_omp_target_enter_data (location_t loc, c_parser *parser,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n-static tree\n+static bool\n c_parser_omp_target_exit_data (location_t loc, c_parser *parser,\n \t\t\t       enum pragma_context context)\n {\n@@ -20118,15 +20119,15 @@ c_parser_omp_target_exit_data (location_t loc, c_parser *parser,\n     {\n       c_parser_error (parser, \"expected %<data%>\");\n       c_parser_skip_to_pragma_eol (parser);\n-      return NULL_TREE;\n+      return false;\n     }\n \n   if (context == pragma_stmt)\n     {\n       error_at (loc, \"%<#pragma %s%> may only be used in compound statements\",\n \t\t\"omp target exit data\");\n       c_parser_skip_to_pragma_eol (parser, false);\n-      return NULL_TREE;\n+      return true;\n     }\n \n   tree clauses\n@@ -20167,15 +20168,15 @@ c_parser_omp_target_exit_data (location_t loc, c_parser *parser,\n \terror_at (loc,\n \t\t  \"%<#pragma omp target exit data%> must contain at least one \"\n \t\t  \"%<map%> clause\");\n-      return NULL_TREE;\n+      return true;\n     }\n \n   tree stmt = make_node (OMP_TARGET_EXIT_DATA);\n   TREE_TYPE (stmt) = void_type_node;\n   OMP_TARGET_EXIT_DATA_CLAUSES (stmt) = clauses;\n   SET_EXPR_LOCATION (stmt, loc);\n   add_stmt (stmt);\n-  return stmt;\n+  return true;\n }\n \n /* OpenMP 4.0:\n@@ -20333,14 +20334,12 @@ c_parser_omp_target (c_parser *parser, enum pragma_context context, bool *if_p)\n       else if (strcmp (p, \"enter\") == 0)\n \t{\n \t  c_parser_consume_token (parser);\n-\t  c_parser_omp_target_enter_data (loc, parser, context);\n-\t  return false;\n+\t  return c_parser_omp_target_enter_data (loc, parser, context);\n \t}\n       else if (strcmp (p, \"exit\") == 0)\n \t{\n \t  c_parser_consume_token (parser);\n-\t  c_parser_omp_target_exit_data (loc, parser, context);\n-\t  return false;\n+\t  return c_parser_omp_target_exit_data (loc, parser, context);\n \t}\n       else if (strcmp (p, \"update\") == 0)\n \t{\n@@ -21599,7 +21598,7 @@ c_parser_omp_declare_reduction (c_parser *parser, enum pragma_context context)\n    OpenMP 5.0\n    #pragma omp declare variant (identifier) match (context-selector)  */\n \n-static void\n+static bool\n c_parser_omp_declare (c_parser *parser, enum pragma_context context)\n {\n   c_parser_consume_pragma (parser);\n@@ -21611,37 +21610,38 @@ c_parser_omp_declare (c_parser *parser, enum pragma_context context)\n \t  /* c_parser_consume_token (parser); done in\n \t     c_parser_omp_declare_simd.  */\n \t  c_parser_omp_declare_simd (parser, context);\n-\t  return;\n+\t  return true;\n \t}\n       if (strcmp (p, \"reduction\") == 0)\n \t{\n \t  c_parser_consume_token (parser);\n \t  c_parser_omp_declare_reduction (parser, context);\n-\t  return;\n+\t  return false;\n \t}\n       if (!flag_openmp)  /* flag_openmp_simd  */\n \t{\n \t  c_parser_skip_to_pragma_eol (parser, false);\n-\t  return;\n+\t  return false;\n \t}\n       if (strcmp (p, \"target\") == 0)\n \t{\n \t  c_parser_consume_token (parser);\n \t  c_parser_omp_declare_target (parser);\n-\t  return;\n+\t  return false;\n \t}\n       if (strcmp (p, \"variant\") == 0)\n \t{\n \t  /* c_parser_consume_token (parser); done in\n \t     c_parser_omp_declare_simd.  */\n \t  c_parser_omp_declare_simd (parser, context);\n-\t  return;\n+\t  return true;\n \t}\n     }\n \n   c_parser_error (parser, \"expected %<simd%>, %<reduction%>, \"\n \t\t\t  \"%<target%> or %<variant%>\");\n   c_parser_skip_to_pragma_eol (parser);\n+  return false;\n }\n \n /* OpenMP 5.0"}, {"sha": "8f2d0fce8071f8ca253ae88817fec6908edc6711", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=1bf976a5de69ecd9b1e10eb7515357b98e78faf7", "patch": "@@ -42137,7 +42137,7 @@ cp_parser_omp_ordered (cp_parser *parser, cp_token *pragma_tok,\n \t\t\t\"%<depend%> clause may only be used in compound \"\n \t\t\t\"statements\");\n \t      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-\t      return false;\n+\t      return true;\n \t    }\n \t  tree clauses\n \t    = cp_parser_omp_all_clauses (parser,\n@@ -42661,7 +42661,7 @@ cp_parser_omp_cancel (cp_parser *parser, cp_token *pragma_tok)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SECTIONS)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_TASKGROUP))\n \n-static void\n+static bool\n cp_parser_omp_cancellation_point (cp_parser *parser, cp_token *pragma_tok,\n \t\t\t\t  enum pragma_context context)\n {\n@@ -42683,7 +42683,7 @@ cp_parser_omp_cancellation_point (cp_parser *parser, cp_token *pragma_tok,\n     {\n       cp_parser_error (parser, \"expected %<point%>\");\n       cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-      return;\n+      return false;\n     }\n \n   if (context != pragma_compound)\n@@ -42695,14 +42695,15 @@ cp_parser_omp_cancellation_point (cp_parser *parser, cp_token *pragma_tok,\n       else\n \tcp_parser_error (parser, \"expected declaration specifiers\");\n       cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-      return;\n+      return true;\n     }\n \n   clauses = cp_parser_omp_all_clauses (parser,\n \t\t\t\t       OMP_CANCELLATION_POINT_CLAUSE_MASK,\n \t\t\t\t       \"#pragma omp cancellation point\",\n \t\t\t\t       pragma_tok);\n   finish_omp_cancellation_point (clauses);\n+  return true;\n }\n \n /* OpenMP 4.0:\n@@ -42998,7 +42999,7 @@ cp_parser_omp_target_data (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n-static tree\n+static bool\n cp_parser_omp_target_enter_data (cp_parser *parser, cp_token *pragma_tok,\n \t\t\t\t enum pragma_context context)\n {\n@@ -43018,7 +43019,7 @@ cp_parser_omp_target_enter_data (cp_parser *parser, cp_token *pragma_tok,\n     {\n       cp_parser_error (parser, \"expected %<data%>\");\n       cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-      return NULL_TREE;\n+      return false;\n     }\n \n   if (context == pragma_stmt)\n@@ -43027,7 +43028,7 @@ cp_parser_omp_target_enter_data (cp_parser *parser, cp_token *pragma_tok,\n \t\t\"%<#pragma %s%> may only be used in compound statements\",\n \t\t\"omp target enter data\");\n       cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-      return NULL_TREE;\n+      return true;\n     }\n \n   tree clauses\n@@ -43067,14 +43068,15 @@ cp_parser_omp_target_enter_data (cp_parser *parser, cp_token *pragma_tok,\n \terror_at (pragma_tok->location,\n \t\t  \"%<#pragma omp target enter data%> must contain at least \"\n \t\t  \"one %<map%> clause\");\n-      return NULL_TREE;\n+      return true;\n     }\n \n   tree stmt = make_node (OMP_TARGET_ENTER_DATA);\n   TREE_TYPE (stmt) = void_type_node;\n   OMP_TARGET_ENTER_DATA_CLAUSES (stmt) = clauses;\n   SET_EXPR_LOCATION (stmt, pragma_tok->location);\n-  return add_stmt (stmt);\n+  add_stmt (stmt);\n+  return true;\n }\n \n /* OpenMP 4.5:\n@@ -43088,7 +43090,7 @@ cp_parser_omp_target_enter_data (cp_parser *parser, cp_token *pragma_tok,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n-static tree\n+static bool\n cp_parser_omp_target_exit_data (cp_parser *parser, cp_token *pragma_tok,\n \t\t\t\tenum pragma_context context)\n {\n@@ -43108,7 +43110,7 @@ cp_parser_omp_target_exit_data (cp_parser *parser, cp_token *pragma_tok,\n     {\n       cp_parser_error (parser, \"expected %<data%>\");\n       cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-      return NULL_TREE;\n+      return false;\n     }\n \n   if (context == pragma_stmt)\n@@ -43117,7 +43119,7 @@ cp_parser_omp_target_exit_data (cp_parser *parser, cp_token *pragma_tok,\n \t\t\"%<#pragma %s%> may only be used in compound statements\",\n \t\t\"omp target exit data\");\n       cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-      return NULL_TREE;\n+      return true;\n     }\n \n   tree clauses\n@@ -43159,14 +43161,15 @@ cp_parser_omp_target_exit_data (cp_parser *parser, cp_token *pragma_tok,\n \terror_at (pragma_tok->location,\n \t\t  \"%<#pragma omp target exit data%> must contain at least \"\n \t\t  \"one %<map%> clause\");\n-      return NULL_TREE;\n+      return true;\n     }\n \n   tree stmt = make_node (OMP_TARGET_EXIT_DATA);\n   TREE_TYPE (stmt) = void_type_node;\n   OMP_TARGET_EXIT_DATA_CLAUSES (stmt) = clauses;\n   SET_EXPR_LOCATION (stmt, pragma_tok->location);\n-  return add_stmt (stmt);\n+  add_stmt (stmt);\n+  return true;\n }\n \n /* OpenMP 4.0:\n@@ -43190,7 +43193,7 @@ cp_parser_omp_target_update (cp_parser *parser, cp_token *pragma_tok,\n \t\t\"%<#pragma %s%> may only be used in compound statements\",\n \t\t\"omp target update\");\n       cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-      return false;\n+      return true;\n     }\n \n   tree clauses\n@@ -43202,15 +43205,15 @@ cp_parser_omp_target_update (cp_parser *parser, cp_token *pragma_tok,\n       error_at (pragma_tok->location,\n \t\t\"%<#pragma omp target update%> must contain at least one \"\n \t\t\"%<from%> or %<to%> clauses\");\n-      return false;\n+      return true;\n     }\n \n   tree stmt = make_node (OMP_TARGET_UPDATE);\n   TREE_TYPE (stmt) = void_type_node;\n   OMP_TARGET_UPDATE_CLAUSES (stmt) = clauses;\n   SET_EXPR_LOCATION (stmt, pragma_tok->location);\n   add_stmt (stmt);\n-  return false;\n+  return true;\n }\n \n /* OpenMP 4.0:\n@@ -43364,14 +43367,12 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n       else if (strcmp (p, \"enter\") == 0)\n \t{\n \t  cp_lexer_consume_token (parser->lexer);\n-\t  cp_parser_omp_target_enter_data (parser, pragma_tok, context);\n-\t  return false;\n+\t  return cp_parser_omp_target_enter_data (parser, pragma_tok, context);\n \t}\n       else if (strcmp (p, \"exit\") == 0)\n \t{\n \t  cp_lexer_consume_token (parser->lexer);\n-\t  cp_parser_omp_target_exit_data (parser, pragma_tok, context);\n-\t  return false;\n+\t  return cp_parser_omp_target_exit_data (parser, pragma_tok, context);\n \t}\n       else if (strcmp (p, \"update\") == 0)\n \t{\n@@ -46432,7 +46433,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n   cp_token *pragma_tok;\n   unsigned int id;\n   tree stmt;\n-  bool ret;\n+  bool ret = false;\n \n   pragma_tok = cp_lexer_consume_token (parser->lexer);\n   gcc_assert (pragma_tok->type == CPP_PRAGMA);\n@@ -46457,6 +46458,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \tcase pragma_stmt:\n \t  error_at (pragma_tok->location, \"%<#pragma %s%> may only be \"\n \t\t    \"used in compound statements\", \"omp barrier\");\n+\t  ret = true;\n \t  break;\n \tdefault:\n \t  goto bad_stmt;\n@@ -46472,6 +46474,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \tcase pragma_stmt:\n \t  error_at (pragma_tok->location, \"%<#pragma %s%> may only be \"\n \t\t    \"used in compound statements\", \"omp depobj\");\n+\t  ret = true;\n \t  break;\n \tdefault:\n \t  goto bad_stmt;\n@@ -46487,6 +46490,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \tcase pragma_stmt:\n \t  error_at (pragma_tok->location, \"%<#pragma %s%> may only be \"\n \t\t    \"used in compound statements\", \"omp flush\");\n+\t  ret = true;\n \t  break;\n \tdefault:\n \t  goto bad_stmt;\n@@ -46503,6 +46507,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \t  error_at (pragma_tok->location,\n \t\t    \"%<#pragma %s%> may only be used in compound statements\",\n \t\t    \"omp taskwait\");\n+\t  ret = true;\n \t  break;\n \tdefault:\n \t  goto bad_stmt;\n@@ -46519,6 +46524,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \t  error_at (pragma_tok->location,\n \t\t    \"%<#pragma %s%> may only be used in compound statements\",\n \t\t    \"omp taskyield\");\n+\t  ret = true;\n \t  break;\n \tdefault:\n \t  goto bad_stmt;\n@@ -46535,15 +46541,15 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \t  error_at (pragma_tok->location,\n \t\t    \"%<#pragma %s%> may only be used in compound statements\",\n \t\t    \"omp cancel\");\n+\t  ret = true;\n \t  break;\n \tdefault:\n \t  goto bad_stmt;\n \t}\n       break;\n \n     case PRAGMA_OMP_CANCELLATION_POINT:\n-      cp_parser_omp_cancellation_point (parser, pragma_tok, context);\n-      return false;\n+      return cp_parser_omp_cancellation_point (parser, pragma_tok, context);\n \n     case PRAGMA_OMP_THREADPRIVATE:\n       cp_parser_omp_threadprivate (parser, pragma_tok);\n@@ -46562,6 +46568,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \t  error_at (pragma_tok->location,\n \t\t    \"%<#pragma %s%> may only be used in compound statements\",\n \t\t    \"acc enter data\");\n+\t  ret = true;\n \t  break;\n \t}\n       else if (context != pragma_compound)\n@@ -46575,6 +46582,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \t  error_at (pragma_tok->location,\n \t\t    \"%<#pragma %s%> may only be used in compound statements\",\n \t\t    \"acc exit data\");\n+\t  ret = true;\n \t  break;\n \t}\n       else if (context != pragma_compound)\n@@ -46587,6 +46595,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \t{\n \t  error_at (pragma_tok->location,\n \t\t    \"%<#pragma acc routine%> must be at file scope\");\n+\t  ret = true;\n \t  break;\n \t}\n       cp_parser_oacc_routine (parser, pragma_tok, context);\n@@ -46598,6 +46607,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \t  error_at (pragma_tok->location,\n \t\t    \"%<#pragma %s%> may only be used in compound statements\",\n \t\t    \"acc update\");\n+\t  ret = true;\n \t  break;\n \t}\n       else if (context != pragma_compound)\n@@ -46611,6 +46621,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \t  error_at (pragma_tok->location,\n \t\t    \"%<#pragma %s%> may only be used in compound statements\",\n \t\t    \"acc wait\");\n+\t  ret = true;\n \t  break;\n \t}\n       else if (context != pragma_compound)\n@@ -46657,6 +46668,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \t  error_at (pragma_tok->location,\n \t\t    \"%<#pragma omp requires%> may only be used at file or \"\n \t\t    \"namespace scope\");\n+\t  ret = true;\n \t  break;\n \t}\n       return cp_parser_omp_requires (parser, pragma_tok);\n@@ -46769,7 +46781,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n     }\n \n   cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-  return false;\n+  return ret;\n }\n \n /* The interface the pragma parsers have to the lexer.  */"}, {"sha": "48ab4f64a41c6f2e1e1f9a35a1ff32e9284d79c5", "filename": "gcc/testsuite/c-c++-common/gomp/pr63326.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr63326.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr63326.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr63326.c?ref=1bf976a5de69ecd9b1e10eb7515357b98e78faf7", "patch": "@@ -156,64 +156,64 @@ f4 (int x)\n   {\n     do\n       #pragma omp barrier\t\t\t/* { dg-error \"may only be used in compound statements\" } */\n-    while (0); /* { dg-error \"before\" \"\" { target c++ } } */\n-  } /* { dg-error \"before\" \"\" { target c++ } } */\n+    while (0);\n+  }\n   {\n     do\n       #pragma omp flush\t\t\t\t/* { dg-error \"may only be used in compound statements\" } */\n-    while (0); /* { dg-error \"before\" \"\" { target c++ } } */\n-  } /* { dg-error \"before\" \"\" { target c++ } } */\n+    while (0);\n+  }\n   {\n     do\n       #pragma omp taskwait\t\t\t/* { dg-error \"may only be used in compound statements\" } */\n-    while (0); /* { dg-error \"before\" \"\" { target c++ } } */\n-  } /* { dg-error \"before\" \"\" { target c++ } } */\n+    while (0);\n+  }\n   {\n     do\n       #pragma omp taskyield\t\t\t/* { dg-error \"may only be used in compound statements\" } */\n-    while (0); /* { dg-error \"before\" \"\" { target c++ } } */\n-  } /* { dg-error \"before\" \"\" { target c++ } } */\n+    while (0);\n+  }\n   #pragma omp parallel\n   {\n     do\n       #pragma omp cancel parallel\t\t/* { dg-error \"may only be used in compound statements\" } */\n-    while (0); /* { dg-error \"before\" \"\" { target c++ } } */\n-  } /* { dg-error \"before\" \"\" { target c++ } } */\n+    while (0);\n+  }\n   #pragma omp parallel\n   {\n     do\n       #pragma omp cancellation point parallel\t/* { dg-error \"may only be used in compound statements\" } */\n-    while (0); /* { dg-error \"before\" \"\" { target c++ } } */\n-  } /* { dg-error \"before\" \"\" { target c++ } } */\n+    while (0);\n+  }\n   #pragma omp for ordered(1)\n   for (i = 0; i < 16; i++)\n     {\n       {\n \tdo\n \t  #pragma omp ordered depend(source)\t/* { dg-error \"may only be used in compound statements\" } */\n-\twhile (0); /* { dg-error \"before\" \"\" { target c++ } } */\n-      } /* { dg-error \"before\" \"\" { target c++ } } */\n+\twhile (0);\n+      }\n       {\n \tdo\n \t  #pragma omp ordered depend(sink: i-1)\t/* { dg-error \"may only be used in compound statements\" } */\n-\twhile (0); /* { dg-error \"before\" \"\" { target c++ } } */\n-      } /* { dg-error \"before\" \"\" { target c++ } } */\n+\twhile (0);\n+      }\n     }\n   {\n     do\n       #pragma omp target enter data map(to:i)\t/* { dg-error \"may only be used in compound statements\" } */\n-    while (0); /* { dg-error \"before\" \"\" { target c++ } } */\n-  } /* { dg-error \"before\" \"\" { target c++ } } */\n+    while (0);\n+  }\n   {\n     do\n       #pragma omp target update to(i)\t\t/* { dg-error \"may only be used in compound statements\" } */\n-    while (0); /* { dg-error \"before\" \"\" { target c++ } } */\n-  } /* { dg-error \"before\" \"\" { target c++ } } */\n+    while (0);\n+  }\n   {\n     do\n       #pragma omp target exit data map(from:i)\t/* { dg-error \"may only be used in compound statements\" } */\n-    while (0); /* { dg-error \"before\" \"\" { target c++ } } */\n-  } /* { dg-error \"before\" \"\" { target c++ } } */\n+    while (0);\n+  }\n }\n \n void"}, {"sha": "cf84281465770e0da78242c470220bbcdc64374b", "filename": "gcc/testsuite/g++.dg/gomp/attrs-7.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-7.C?ref=1bf976a5de69ecd9b1e10eb7515357b98e78faf7", "patch": "@@ -11,8 +11,7 @@ foo ()\n \t\t\t\t\t\t\t\t\t// { dg-error \"#pragma omp section\" \"\" { target *-*-* } .-1 }\n \t\t\t\t\t\t\t\t\t// { dg-error \"#pragma omp flush\" \"\" { target *-*-* } .-2 }\n     [[omp::sequence (directive (flush), omp::directive (section))]];\t// { dg-error \"must be the only specified attribute on a statement\" }\n-\t\t\t\t\t\t\t\t\t// { dg-error \"#pragma omp section\" \"\" { target *-*-* } .-1 }\n-\t\t\t\t\t\t\t\t\t// { dg-error \"#pragma omp flush\" \"\" { target *-*-* } .-2 }\n+\t\t\t\t\t\t\t\t\t// { dg-error \"#pragma omp flush\" \"\" { target *-*-* } .-1 }\n     [[gnu::cold, omp::directive (section)]];\t\t\t\t// { dg-error \"must be the only specified attribute on a statement\" }\n \t\t\t\t\t\t\t\t\t// { dg-error \"#pragma omp section\" \"\" { target *-*-* } .-1 }\n     [[omp::directive (section)]] [[gnu::cold]];\t\t\t\t// { dg-error \"must be the only specified attribute on a statement\" }"}, {"sha": "6f3fded924ebf443b473d56e6966fc3fb1494866", "filename": "gcc/testsuite/g++.dg/gomp/barrier-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fbarrier-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fbarrier-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fbarrier-2.C?ref=1bf976a5de69ecd9b1e10eb7515357b98e78faf7", "patch": "@@ -9,4 +9,4 @@ void f3(bool p)\n {\n   if (p)\n     #pragma omp barrier\t\t// { dg-error \"compound statements\" }\n-}\t\t\t\t// { dg-error \"\" }\n+}"}, {"sha": "ef605a090c6114e30917da32825aefb52d429d8a", "filename": "gcc/testsuite/gcc.dg/gomp/barrier-2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fbarrier-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fbarrier-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fbarrier-2.c?ref=1bf976a5de69ecd9b1e10eb7515357b98e78faf7", "patch": "@@ -16,8 +16,7 @@ void f1(void)\n \n void f2(void)\n {\n-  label:       /* { dg-error \"label at end of compound statement\" } */\n-    /* { dg-warning \"defined but not used\" \"\" { target *-*-* } .-1 } */\n+  label:\t\t\t/* { dg-warning \"defined but not used\" } */\n     #pragma omp barrier\t\t/* { dg-error \"may only be used in compound statements\" } */\n }\n "}, {"sha": "93978208002533833aad39a4d91ec7e532180e91", "filename": "gcc/testsuite/gcc.dg/gomp/declare-simd-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-5.c?ref=1bf976a5de69ecd9b1e10eb7515357b98e78faf7", "patch": "@@ -15,7 +15,7 @@ f1 (int x)\n lab:\n     #pragma omp declare simd simdlen (8) aligned (b : 8 * sizeof (int))\n     extern int f5 (int a, int *b, int c);\t/* { dg-error \"must be followed by function declaration or definition\" } */\n-    x++;\t\t\t\t\t/* { dg-error \"a label can only be part of a statement and a declaration is not a statement\" \"\" { target *-*-* } .-1 } */\n+    x++;\n   }\n   return x;\n }"}, {"sha": "3da5dc7bd0c749e12d762bde975327e763078a73", "filename": "gcc/testsuite/gcc.dg/gomp/declare-variant-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-variant-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf976a5de69ecd9b1e10eb7515357b98e78faf7/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-variant-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-variant-2.c?ref=1bf976a5de69ecd9b1e10eb7515357b98e78faf7", "patch": "@@ -17,7 +17,7 @@ f1 (int x)\n lab:\n     #pragma omp declare variant (fn0) match (user={condition(0)})\n     extern int f5 (int a, int *b, int c);\t/* { dg-error \"must be followed by function declaration or definition\" } */\n-    x++;\t\t\t\t\t/* { dg-error \"a label can only be part of a statement and a declaration is not a statement\" \"\" { target *-*-* } .-1 } */\n+    x++;\n   }\n   return x;\n }"}]}