{"sha": "ce72a38e081426b508fe799e7a0005bfcea7daa8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U3MmEzOGUwODE0MjZiNTA4ZmU3OTllN2EwMDA1YmZjZWE3ZGFhOA==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-08-22T07:03:19Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:20Z"}, "message": "Attempted to solve string escape vs null character location issues", "tree": {"sha": "47ea0f5ced05c800f501eaa1d16bff0577f7e725", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47ea0f5ced05c800f501eaa1d16bff0577f7e725"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce72a38e081426b508fe799e7a0005bfcea7daa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce72a38e081426b508fe799e7a0005bfcea7daa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce72a38e081426b508fe799e7a0005bfcea7daa8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce72a38e081426b508fe799e7a0005bfcea7daa8/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b758ec724cc06cb866a72ce17dbfd8a426cf21db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b758ec724cc06cb866a72ce17dbfd8a426cf21db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b758ec724cc06cb866a72ce17dbfd8a426cf21db"}], "stats": {"total": 86, "additions": 27, "deletions": 59}, "files": [{"sha": "322079e5ffbc016a2c67234b5abba7fc2f72ace1", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 24, "deletions": 57, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72a38e081426b508fe799e7a0005bfcea7daa8/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72a38e081426b508fe799e7a0005bfcea7daa8/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=ce72a38e081426b508fe799e7a0005bfcea7daa8", "patch": "@@ -588,8 +588,8 @@ namespace Rust {\n                     // detect escapes\n                     if (current_char == '\\\\') {\n                         auto escape_length_pair = parse_escape('\\'');\n-                        byte_char = escape_length_pair.first;\n-                        length += escape_length_pair.second;\n+                        byte_char = std::get<0>(escape_length_pair);\n+                        length += std::get<1>(escape_length_pair);\n \n                         if (byte_char > 127) {\n                             rust_error_at(\n@@ -644,15 +644,15 @@ namespace Rust {\n                     while (current_char != '\"' && current_char != '\\n') {\n                         if (current_char == '\\\\') {\n                             auto escape_length_pair = parse_escape('\"');\n-                            char output_char = escape_length_pair.first;\n+                            char output_char = std::get<0>(escape_length_pair);\n                             //length += escape_length_pair.second;\n \n                             // TODO: need to fix length - after escape, the length of the line up to the next non-whitespace char of the string is added to length, which is not what we want - we want length to be replaced by that.\n                             // possible option could if \"if escape_length_pair.first == 0, then length = escape_length_pair.second else length += escape_length_pair.second.\"\n-                            if (output_char == 0)\n-                                length = escape_length_pair.second - 1; \n+                            if (output_char == 0 && std::get<2>(escape_length_pair))\n+                                length = std::get<1>(escape_length_pair) - 1;\n                             else\n-                                length += escape_length_pair.second;\n+                                length += std::get<1>(escape_length_pair);\n \n                             if (output_char > 127) {\n                                 rust_error_at(get_current_location(),\n@@ -1193,15 +1193,15 @@ namespace Rust {\n                     if (current_char32.value == '\\\\') {\n                         // parse escape\n                         auto utf8_escape_pair = parse_utf8_escape('\\'');\n-                        current_char32 = utf8_escape_pair.first;\n+                        current_char32 = std::get<0>(utf8_escape_pair);\n                         //length += utf8_escape_pair.second;\n \n                         // TODO: need to fix length - after escape, the length of the line up to the next non-whitespace char of the string is added to length, which is not what we want - we want length to be replaced by that.\n                         // possible option could if \"if escape_length_pair.first == 0, then length = escape_length_pair.second else length += escape_length_pair.second.\"\n-                        if (current_char32 == Codepoint(0))\n-                            length = utf8_escape_pair.second - 1; \n+                        if (current_char32 == Codepoint(0) && std::get<2>(utf8_escape_pair))\n+                            length = std::get<1>(utf8_escape_pair);\n                         else\n-                            length += utf8_escape_pair.second;\n+                            length += std::get<1>(utf8_escape_pair);\n \n                         if (current_char32 != Codepoint(0))\n                             str += current_char32;\n@@ -1249,8 +1249,8 @@ namespace Rust {\n                 if (current_char32.value == '\\\\') {\n                     // parse escape\n                     auto utf8_escape_pair = parse_utf8_escape('\\'');\n-                    current_char32 = utf8_escape_pair.first;\n-                    length += utf8_escape_pair.second;\n+                    current_char32 = std::get<0>(utf8_escape_pair);\n+                    length += std::get<1>(utf8_escape_pair);\n \n                     if (test_peek_codepoint_input().value != '\\'') {\n                         rust_error_at(get_current_location(), \"unended char literal\");\n@@ -1439,7 +1439,7 @@ namespace Rust {\n     }\n \n     /* Parses escapes (and string continues) in \"byte\" strings and characters. Does not support unicode. */\n-    std::pair<char, int> Lexer::parse_escape(char opening_char) {\n+    std::tuple<char, int, bool> Lexer::parse_escape(char opening_char) {\n         int additional_length_offset = 0;\n         char output_char = 0;\n \n@@ -1509,7 +1509,7 @@ namespace Rust {\n                 rust_error_at(get_current_location(),\n                   \"cannot have a unicode escape \\\\u in a byte %s!\",\n                   opening_char == '\\'' ? \"character\" : \"string\");\n-                return std::make_pair(output_char, additional_length_offset);\n+                return std::make_tuple(output_char, additional_length_offset, false);\n #if 0\n \t\t\t{\n                 // TODO: shouldn't be used with this - use parse_utf8_escape\n@@ -1626,32 +1626,12 @@ namespace Rust {\n                     additional_length_offset++;\n                 }\n \n-                // shouldn't need this\n-#if 0\n-                if (current_char == opening_char) {\n-                    // TODO: does this skip the ' or \" character? It shouldn't.\n-                    output_char = 0;\n-                    // return true;\n-                    return std::make_pair(output_char, additional_length_offset);\n-                } else {\n-                    // TODO: shouldn't this make output_char null so that it isn't added to string?\n-                    // or check for escape being zero?\n-                    output_char = /*current_char*/0;\n-\n-                    // TODO: test has right result\n-                    /*skip_input();\n-                    current_char = peek_input();*/\n-\n-                    // return true;\n-                    return std::make_pair(output_char, additional_length_offset);\n-                }\n-#endif\n-                return std::make_pair(0, additional_length_offset);\n+                return std::make_tuple(0, additional_length_offset, true);\n             default:\n                 rust_error_at(get_current_location(), \"unknown escape sequence '\\\\%c'\", current_char);\n                 // returns false if no parsing could be done\n                 // return false;\n-                return std::make_pair(output_char, additional_length_offset);\n+                return std::make_tuple(output_char, additional_length_offset, false);\n                 break;\n         }\n         // all non-special cases (string continue) should skip their used char\n@@ -1661,11 +1641,11 @@ namespace Rust {\n \n         // returns true if parsing was successful\n         // return true;\n-        return std::make_pair(output_char, additional_length_offset);\n+        return std::make_tuple(output_char, additional_length_offset, false);\n     }\n \n     // Parses an escape (or string continue) in a string or character. Supports unicode escapes.\n-    std::pair<Codepoint, int> Lexer::parse_utf8_escape(char opening_char) {\n+    std::tuple<Codepoint, int, bool> Lexer::parse_utf8_escape(char opening_char) {\n         Codepoint output_char;\n         int additional_length_offset = 0;\n \n@@ -1782,7 +1762,7 @@ namespace Rust {\n                         rust_error_at(\n                           get_current_location(), \"expected terminating '}' in unicode escape\");\n                         // return false;\n-                        return std::make_pair(output_char, additional_length_offset);\n+                        return std::make_tuple(output_char, additional_length_offset, false);\n                     }\n                 }\n \n@@ -1793,7 +1773,7 @@ namespace Rust {\n                       \"characters; it is %lu\",\n                       num_str.length());\n                     // return false;\n-                    return std::make_pair(output_char, additional_length_offset);\n+                    return std::make_tuple(output_char, additional_length_offset, false);\n                 }\n \n                 long hex_num = std::strtol(num_str.c_str(), NULL, 16);\n@@ -1807,7 +1787,7 @@ namespace Rust {\n                 // (unicode number) or the character number?\n \n                 // return true;\n-                return std::make_pair(output_char, additional_length_offset);\n+                return std::make_tuple(output_char, additional_length_offset, false);\n             } break;\n             case '\\r':\n             case '\\n':\n@@ -1834,25 +1814,12 @@ namespace Rust {\n                     additional_length_offset++;\n                 }\n \n-                // shouldn't need this\n-#if 0\n-                if (current_char == opening_char) {\n-                    output_char = 0;\n-                    // return true;\n-                    return std::make_pair(output_char, additional_length_offset);\n-                } else {\n-                    output_char = /*current_char*/0;\n-\n-                    // return true;\n-                    return std::make_pair(output_char, additional_length_offset);\n-                }\n-#endif\n-                return std::make_pair(0, additional_length_offset);\n+                return std::make_tuple(0, additional_length_offset, true);\n             default:\n                 rust_error_at(get_current_location(), \"unknown escape sequence '\\\\%c'\", current_char);\n                 // returns false if no parsing could be done\n                 // return false;\n-                return std::make_pair(output_char, additional_length_offset);\n+                return std::make_tuple(output_char, additional_length_offset, false);\n                 break;\n         }\n         /* all non-special cases (unicode, string continue) should skip their used\n@@ -1863,7 +1830,7 @@ namespace Rust {\n \n         // returns true if parsing was successful\n         // return true;\n-        return std::make_pair(output_char, additional_length_offset);\n+        return std::make_tuple(output_char, additional_length_offset, false);\n     }\n \n #if 0"}, {"sha": "1465cb2b9218b8b121dafc28ad40c0f89e530ecc", "filename": "gcc/rust/lex/rust-lex.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72a38e081426b508fe799e7a0005bfcea7daa8/gcc%2Frust%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72a38e081426b508fe799e7a0005bfcea7daa8/gcc%2Frust%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.h?ref=ce72a38e081426b508fe799e7a0005bfcea7daa8", "patch": "@@ -6,6 +6,7 @@\n #include \"rust-token.h\"\n \n #include <utility>\n+#include <tuple>\n \n namespace Rust {\n class Lexer\n@@ -44,8 +45,8 @@ class Lexer\n     char& current_char, int &length, Codepoint &output_char);*/\n   /*bool parse_byte_escape (char& current_char, int &length,\n \t\t\t\t char &output_char);*/\n-  std::pair<char, int> parse_escape (char opening_char);\n-  std::pair<Codepoint, int> parse_utf8_escape (char opening_char);\n+  std::tuple<char, int, bool> parse_escape (char opening_char);\n+  std::tuple<Codepoint, int, bool> parse_utf8_escape (char opening_char);\n   int test_get_input_codepoint_length ();\n   int test_get_input_codepoint_n_length (int n_start_offset);\n   Codepoint test_peek_codepoint_input ();"}]}