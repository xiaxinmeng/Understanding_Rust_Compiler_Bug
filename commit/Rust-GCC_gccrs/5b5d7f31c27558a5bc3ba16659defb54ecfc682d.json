{"sha": "5b5d7f31c27558a5bc3ba16659defb54ecfc682d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI1ZDdmMzFjMjc1NThhNWJjM2JhMTY2NTlkZWZiNTRlY2ZjNjgyZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-03-13T19:10:05Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-03-13T19:10:05Z"}, "message": "re PR tree-optimization/59779 (FAIL: gcc.dg/autopar/outer-1.c scan-tree-dump-times parloops \"parallelizing outer loop\")\n\n\tPR tree-optimization/59779\n\t* tree-dfa.c (get_ref_base_and_extent): Use double_int\n\ttype for bitsize and maxsize instead of HOST_WIDE_INT.\n\nFrom-SVN: r208554", "tree": {"sha": "76e5159d1f6f0a796c8fcd40dce8fc664f8affa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76e5159d1f6f0a796c8fcd40dce8fc664f8affa4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b5d7f31c27558a5bc3ba16659defb54ecfc682d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b5d7f31c27558a5bc3ba16659defb54ecfc682d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b5d7f31c27558a5bc3ba16659defb54ecfc682d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b5d7f31c27558a5bc3ba16659defb54ecfc682d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "52684bb3c8ab4b566cb10d20aa06ab388a4a81c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52684bb3c8ab4b566cb10d20aa06ab388a4a81c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52684bb3c8ab4b566cb10d20aa06ab388a4a81c7"}], "stats": {"total": 133, "additions": 75, "deletions": 58}, "files": [{"sha": "a16001b703a3480c65141427a216cdb130483bb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b5d7f31c27558a5bc3ba16659defb54ecfc682d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b5d7f31c27558a5bc3ba16659defb54ecfc682d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b5d7f31c27558a5bc3ba16659defb54ecfc682d", "patch": "@@ -1,3 +1,9 @@\n+2014-03-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/59779\n+\t* tree-dfa.c (get_ref_base_and_extent): Use double_int\n+\ttype for bitsize and maxsize instead of HOST_WIDE_INT.\n+\n 2014-03-13  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR rtl-optimization/57320"}, {"sha": "fcf8d80fda4bc0c658fb38e868c709ef4d19fab5", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 69, "deletions": 58, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b5d7f31c27558a5bc3ba16659defb54ecfc682d/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b5d7f31c27558a5bc3ba16659defb54ecfc682d/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=5b5d7f31c27558a5bc3ba16659defb54ecfc682d", "patch": "@@ -389,11 +389,10 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t\t HOST_WIDE_INT *psize,\n \t\t\t HOST_WIDE_INT *pmax_size)\n {\n-  HOST_WIDE_INT bitsize = -1;\n-  HOST_WIDE_INT maxsize = -1;\n+  double_int bitsize = double_int_minus_one;\n+  double_int maxsize;\n   tree size_tree = NULL_TREE;\n   double_int bit_offset = double_int_zero;\n-  HOST_WIDE_INT hbit_offset;\n   bool seen_variable_array_ref = false;\n \n   /* First get the final access size from just the outermost expression.  */\n@@ -407,15 +406,11 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n       if (mode == BLKmode)\n \tsize_tree = TYPE_SIZE (TREE_TYPE (exp));\n       else\n-\tbitsize = GET_MODE_BITSIZE (mode);\n-    }\n-  if (size_tree != NULL_TREE)\n-    {\n-      if (! tree_fits_uhwi_p (size_tree))\n-\tbitsize = -1;\n-      else\n-\tbitsize = tree_to_uhwi (size_tree);\n+\tbitsize = double_int::from_uhwi (GET_MODE_BITSIZE (mode));\n     }\n+  if (size_tree != NULL_TREE\n+      && TREE_CODE (size_tree) == INTEGER_CST)\n+    bitsize = tree_to_double_int (size_tree);\n \n   /* Initially, maxsize is the same as the accessed element size.\n      In the following it will only grow (or become -1).  */\n@@ -448,7 +443,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t   referenced the last field of a struct or a union member\n \t\t   then we have to adjust maxsize by the padding at the end\n \t\t   of our field.  */\n-\t\tif (seen_variable_array_ref && maxsize != -1)\n+\t\tif (seen_variable_array_ref && !maxsize.is_minus_one ())\n \t\t  {\n \t\t    tree stype = TREE_TYPE (TREE_OPERAND (exp, 0));\n \t\t    tree next = DECL_CHAIN (field);\n@@ -459,15 +454,22 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t      {\n \t\t\ttree fsize = DECL_SIZE_UNIT (field);\n \t\t\ttree ssize = TYPE_SIZE_UNIT (stype);\n-\t\t\tif (tree_fits_shwi_p (fsize)\n-\t\t\t    && tree_fits_shwi_p (ssize)\n-\t\t\t    && doffset.fits_shwi ())\n-\t\t\t  maxsize += ((tree_to_shwi (ssize)\n-\t\t\t\t       - tree_to_shwi (fsize))\n-\t\t\t\t      * BITS_PER_UNIT\n-\t\t\t\t\t- doffset.to_shwi ());\n+\t\t\tif (fsize == NULL\n+\t\t\t    || TREE_CODE (fsize) != INTEGER_CST\n+\t\t\t    || ssize == NULL\n+\t\t\t    || TREE_CODE (ssize) != INTEGER_CST)\n+\t\t\t  maxsize = double_int_minus_one;\n \t\t\telse\n-\t\t\t  maxsize = -1;\n+\t\t\t  {\n+\t\t\t    double_int tem = tree_to_double_int (ssize)\n+\t\t\t\t\t     - tree_to_double_int (fsize);\n+\t\t\t    if (BITS_PER_UNIT == 8)\n+\t\t\t      tem = tem.lshift (3);\n+\t\t\t    else\n+\t\t\t      tem *= double_int::from_uhwi (BITS_PER_UNIT);\n+\t\t\t    tem -= doffset;\n+\t\t\t    maxsize += tem;\n+\t\t\t  }\n \t\t      }\n \t\t  }\n \t      }\n@@ -477,13 +479,12 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t/* We need to adjust maxsize to the whole structure bitsize.\n \t\t   But we can subtract any constant offset seen so far,\n \t\t   because that would get us out of the structure otherwise.  */\n-\t\tif (maxsize != -1\n+\t\tif (!maxsize.is_minus_one ()\n \t\t    && csize\n-\t\t    && tree_fits_uhwi_p (csize)\n-\t\t    && bit_offset.fits_shwi ())\n-\t\t  maxsize = tree_to_uhwi (csize) - bit_offset.to_shwi ();\n+\t\t    && TREE_CODE (csize) == INTEGER_CST)\n+\t\t  maxsize = tree_to_double_int (csize) - bit_offset;\n \t\telse\n-\t\t  maxsize = -1;\n+\t\t  maxsize = double_int_minus_one;\n \t      }\n \t  }\n \t  break;\n@@ -520,13 +521,12 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t/* We need to adjust maxsize to the whole array bitsize.\n \t\t   But we can subtract any constant offset seen so far,\n \t\t   because that would get us outside of the array otherwise.  */\n-\t\tif (maxsize != -1\n+\t\tif (!maxsize.is_minus_one ()\n \t\t    && asize\n-\t\t    && tree_fits_uhwi_p (asize)\n-\t\t    && bit_offset.fits_shwi ())\n-\t\t  maxsize = tree_to_uhwi (asize) - bit_offset.to_shwi ();\n+\t\t    && TREE_CODE (asize) == INTEGER_CST)\n+\t\t  maxsize = tree_to_double_int (asize) - bit_offset;\n \t\telse\n-\t\t  maxsize = -1;\n+\t\t  maxsize = double_int_minus_one;\n \n \t\t/* Remember that we have seen an array ref with a variable\n \t\t   index.  */\n@@ -539,7 +539,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t  break;\n \n \tcase IMAGPART_EXPR:\n-\t  bit_offset += double_int::from_uhwi (bitsize);\n+\t  bit_offset += bitsize;\n \t  break;\n \n \tcase VIEW_CONVERT_EXPR:\n@@ -553,7 +553,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t    {\n \t      exp = TREE_OPERAND (TMR_BASE (exp), 0);\n \t      bit_offset = double_int_zero;\n-\t      maxsize = -1;\n+\t      maxsize = double_int_minus_one;\n \t      goto done;\n \t    }\n \t  /* Fallthru.  */\n@@ -569,13 +569,12 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t     base type boundary.  This needs to include possible trailing\n \t     padding that is there for alignment purposes.  */\n \t  if (seen_variable_array_ref\n-\t      && maxsize != -1\n-\t      && (!bit_offset.fits_shwi ()\n-\t\t  || !tree_fits_uhwi_p (TYPE_SIZE (TREE_TYPE (exp)))\n-\t\t  || (bit_offset.to_shwi () + maxsize\n-\t\t      == (HOST_WIDE_INT) tree_to_uhwi\n-\t\t            (TYPE_SIZE (TREE_TYPE (exp))))))\n-\t    maxsize = -1;\n+\t      && !maxsize.is_minus_one ()\n+\t      && (TYPE_SIZE (TREE_TYPE (exp)) == NULL_TREE\n+\t\t  || TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) != INTEGER_CST\n+\t\t  || (bit_offset + maxsize\n+\t\t      == tree_to_double_int (TYPE_SIZE (TREE_TYPE (exp))))))\n+\t    maxsize = double_int_minus_one;\n \n \t  /* Hand back the decl for MEM[&decl, off].  */\n \t  if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR)\n@@ -606,51 +605,63 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \n   /* We need to deal with variable arrays ending structures.  */\n   if (seen_variable_array_ref\n-      && maxsize != -1\n-      && (!bit_offset.fits_shwi ()\n-\t  || !tree_fits_uhwi_p (TYPE_SIZE (TREE_TYPE (exp)))\n-\t  || (bit_offset.to_shwi () + maxsize\n-\t      == (HOST_WIDE_INT) tree_to_uhwi\n-\t           (TYPE_SIZE (TREE_TYPE (exp))))))\n-    maxsize = -1;\n+      && !maxsize.is_minus_one ()\n+      && (TYPE_SIZE (TREE_TYPE (exp)) == NULL_TREE\n+\t  || TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) != INTEGER_CST\n+\t  || (bit_offset + maxsize\n+\t      == tree_to_double_int (TYPE_SIZE (TREE_TYPE (exp))))))\n+    maxsize = double_int_minus_one;\n \n  done:\n-  if (!bit_offset.fits_shwi ())\n+  if (!bitsize.fits_shwi () || bitsize.is_negative ())\n     {\n       *poffset = 0;\n-      *psize = bitsize;\n+      *psize = -1;\n       *pmax_size = -1;\n \n       return exp;\n     }\n \n-  hbit_offset = bit_offset.to_shwi ();\n+  *psize = bitsize.to_shwi ();\n+\n+  if (!bit_offset.fits_shwi ())\n+    {\n+      *poffset = 0;\n+      *pmax_size = -1;\n+\n+      return exp;\n+    }\n \n   /* In case of a decl or constant base object we can do better.  */\n \n   if (DECL_P (exp))\n     {\n       /* If maxsize is unknown adjust it according to the size of the\n          base decl.  */\n-      if (maxsize == -1\n-\t  && tree_fits_uhwi_p (DECL_SIZE (exp)))\n-\tmaxsize = tree_to_uhwi (DECL_SIZE (exp)) - hbit_offset;\n+      if (maxsize.is_minus_one ()\n+\t  && DECL_SIZE (exp)\n+\t  && TREE_CODE (DECL_SIZE (exp)) == INTEGER_CST)\n+\tmaxsize = tree_to_double_int (DECL_SIZE (exp)) - bit_offset;\n     }\n   else if (CONSTANT_CLASS_P (exp))\n     {\n       /* If maxsize is unknown adjust it according to the size of the\n          base type constant.  */\n-      if (maxsize == -1\n-\t  && tree_fits_uhwi_p (TYPE_SIZE (TREE_TYPE (exp))))\n-\tmaxsize = tree_to_uhwi (TYPE_SIZE (TREE_TYPE (exp))) - hbit_offset;\n+      if (maxsize.is_minus_one ()\n+\t  && TYPE_SIZE (TREE_TYPE (exp))\n+\t  && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) == INTEGER_CST)\n+\tmaxsize = tree_to_double_int (TYPE_SIZE (TREE_TYPE (exp)))\n+\t\t  - bit_offset;\n     }\n \n   /* ???  Due to negative offsets in ARRAY_REF we can end up with\n      negative bit_offset here.  We might want to store a zero offset\n      in this case.  */\n-  *poffset = hbit_offset;\n-  *psize = bitsize;\n-  *pmax_size = maxsize;\n+  *poffset = bit_offset.to_shwi ();\n+  if (!maxsize.fits_shwi () || maxsize.is_negative ())\n+    *pmax_size = -1;\n+  else\n+    *pmax_size = maxsize.to_shwi ();\n \n   return exp;\n }"}]}