{"sha": "7bd80f37385aeba292ea80630726c5963f02782e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JkODBmMzczODVhZWJhMjkyZWE4MDYzMDcyNmM1OTYzZjAyNzgyZQ==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-10-09T18:31:57Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-10-09T18:31:57Z"}, "message": "(start_of_epilogue_needs): New variable.\n\n\t(mark_target_live_regs): Add in start_of_epilogue_needs when\n\tNOTE_INSN_EPILOGUE_BEG is scanned.\n\t(dbr_schedule): Compute start_of_epilogue_needs and update\n\tend_of_function_needs to include sets by all instructions\n\tfollowing NOTE_INSN_EPILOGUE_BEG.\n\nFrom-SVN: r2386", "tree": {"sha": "5c120ece14dbce7d57b4770368e0d748a1f097a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c120ece14dbce7d57b4770368e0d748a1f097a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bd80f37385aeba292ea80630726c5963f02782e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bd80f37385aeba292ea80630726c5963f02782e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bd80f37385aeba292ea80630726c5963f02782e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bd80f37385aeba292ea80630726c5963f02782e/comments", "author": null, "committer": null, "parents": [{"sha": "014830a56db576f8fabdb74dedd312bf4b0d9423", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/014830a56db576f8fabdb74dedd312bf4b0d9423", "html_url": "https://github.com/Rust-GCC/gccrs/commit/014830a56db576f8fabdb74dedd312bf4b0d9423"}], "stats": {"total": 45, "additions": 41, "deletions": 4}, "files": [{"sha": "8ad147fc47578c94948e09374807d4750307cbfb", "filename": "gcc/reorg.c", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd80f37385aeba292ea80630726c5963f02782e/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd80f37385aeba292ea80630726c5963f02782e/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=7bd80f37385aeba292ea80630726c5963f02782e", "patch": "@@ -165,6 +165,9 @@ struct resources\n  do { (RES)->memory = (RES)->volatil = (RES)->cc = 0;\t\\\n       CLEAR_HARD_REG_SET ((RES)->regs); } while (0)\n \n+/* Indicates what resources are required at the beginning of the epilogue.  */\n+static struct resources start_of_epilogue_needs;\n+\n /* Indicates what resources are required at function end.  */\n static struct resources end_of_function_needs;\n \n@@ -2124,13 +2127,20 @@ mark_target_live_regs (target, res)\n \t\t  }\n \t    }\n \n-\t  if (GET_CODE (real_insn) == CODE_LABEL)\n+\t  else if (GET_CODE (real_insn) == CODE_LABEL)\n \t    {\n \t      /* A label clobbers the pending dead registers since neither\n \t\t reload nor jump will propagate a value across a label.  */\n \t      AND_COMPL_HARD_REG_SET (current_live_regs, pending_dead_regs);\n \t      CLEAR_HARD_REG_SET (pending_dead_regs);\n \t    }\n+\n+\t  /* The beginning of the epilogue corresponds to the end of the\n+\t     RTL chain when there are no epilogue insns.  Certain resources\n+\t     are implicitly required at that point.  */\n+\t  else if (GET_CODE (real_insn) == NOTE\n+ \t\t   && NOTE_LINE_NUMBER (real_insn) == NOTE_INSN_EPILOGUE_BEG)\n+\t    IOR_HARD_REG_SET (current_live_regs, start_of_epilogue_needs.regs);\n \t}\n \n       COPY_HARD_REG_SET (res->regs, current_live_regs);\n@@ -3549,7 +3559,7 @@ dbr_schedule (first, file)\n      rtx first;\n      FILE *file;\n {\n-  rtx insn, next;\n+  rtx insn, next, epilogue_insn = 0;\n   int i;\n #if 0\n   int old_flag_no_peephole = flag_no_peephole;\n@@ -3566,8 +3576,13 @@ dbr_schedule (first, file)\n   /* Find the highest INSN_UID and allocate and initialize our map from\n      INSN_UID's to position in code.  */\n   for (max_uid = 0, insn = first; insn; insn = NEXT_INSN (insn))\n-    if (INSN_UID (insn) > max_uid)\n-      max_uid = INSN_UID (insn);\n+    {\n+      if (INSN_UID (insn) > max_uid)\n+\tmax_uid = INSN_UID (insn);\n+      if (GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EPILOGUE_BEG)\n+\tepilogue_insn = insn;\n+    }\n \n   uid_to_ruid = (int *) alloca ((max_uid + 1) * sizeof (int *));\n   for (i = 0, insn = first; insn; i++, insn = NEXT_INSN (insn))\n@@ -3635,6 +3650,28 @@ dbr_schedule (first, file)\n     if (global_regs[i])\n       SET_HARD_REG_BIT (end_of_function_needs.regs, i);\n \n+  /* The registers required to be live at the end of the function are\n+     represented in the flow information as being dead just prior to\n+     reaching the end of the function.  For example, the return of a value\n+     might be represented by a USE of the return register immediately\n+     followed by an unconditional jump to the return label where the\n+     return label is the end of the RTL chain.  The end of the RTL chain\n+     is then taken to mean that the return register is live.\n+\n+     This sequence is no longer maintained when epilogue instructions are\n+     added to the RTL chain.  To reconstruct the original meaning, the\n+     start of the epilogue (NOTE_INSN_EPILOGUE_BEG) is regarded as the\n+     point where these registers become live (start_of_epilogue_needs).\n+     If epilogue instructions are present, the registers set by those\n+     instructions won't have been processed by flow.  Thus, those\n+     registers are additionally required at the end of the RTL chain\n+     (end_of_function_needs).  */\n+\n+  start_of_epilogue_needs = end_of_function_needs;\n+\n+  while (epilogue_insn = next_nonnote_insn (epilogue_insn))\n+    mark_set_resources (epilogue_insn, &end_of_function_needs, 0, 0);\n+\n   /* Show we haven't computed an end-of-function label yet.  */\n   end_of_function_label = 0;\n "}]}