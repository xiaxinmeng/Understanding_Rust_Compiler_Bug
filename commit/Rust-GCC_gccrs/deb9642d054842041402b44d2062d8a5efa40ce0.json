{"sha": "deb9642d054842041402b44d2062d8a5efa40ce0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGViOTY0MmQwNTQ4NDIwNDE0MDJiNDRkMjA2MmQ4YTVlZmE0MGNlMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-04-16T00:28:17Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-04-16T00:28:17Z"}, "message": "Implement N3271\n\n\tImplement N3271\n\t* parser.c (cp_convert_range_for): Split into\n\tcp_parser_perform_range_for_lookup.\n\t(cp_parser_perform_range_for_lookup): New.\n\t(cp_parser_range_for_member_function): New.\n\t(cp_parser_for_init_statement): Correct error message.\n\t* semantics.c (finish_call_expr): Accept COMPONENT_REF.\n\nFrom-SVN: r172531", "tree": {"sha": "f935ef5d5afe9c68c523e956499fa96210611ab5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f935ef5d5afe9c68c523e956499fa96210611ab5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/deb9642d054842041402b44d2062d8a5efa40ce0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deb9642d054842041402b44d2062d8a5efa40ce0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/deb9642d054842041402b44d2062d8a5efa40ce0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deb9642d054842041402b44d2062d8a5efa40ce0/comments", "author": null, "committer": null, "parents": [{"sha": "5a0f6eba53087e09a70dcb51c80654bb3bf01342", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a0f6eba53087e09a70dcb51c80654bb3bf01342", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a0f6eba53087e09a70dcb51c80654bb3bf01342"}], "stats": {"total": 697, "additions": 639, "deletions": 58}, "files": [{"sha": "aae532a8e1a937714c15567d54ed1295b413c981", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=deb9642d054842041402b44d2062d8a5efa40ce0", "patch": "@@ -1,3 +1,13 @@\n+2011-04-15  Rodrigo Rivas Costa <rodrigorivascosta@gmail.com>\n+\n+\tImplement N3271\n+\t* parser.c (cp_convert_range_for): Split into\n+\tcp_parser_perform_range_for_lookup.\n+\t(cp_parser_perform_range_for_lookup): New.\n+\t(cp_parser_range_for_member_function): New.\n+\t(cp_parser_for_init_statement): Correct error message.\n+\t* semantics.c (finish_call_expr): Accept COMPONENT_REF.\n+\n 2011-04-14  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* parser.c (cp_parser_objc_protocol_declaration): Updated for"}, {"sha": "2c7ace6bbb965c310e33e2ece9b60741d154a492", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 141, "deletions": 53, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=deb9642d054842041402b44d2062d8a5efa40ce0", "patch": "@@ -1607,6 +1607,10 @@ static tree cp_parser_c_for\n   (cp_parser *, tree, tree);\n static tree cp_parser_range_for\n   (cp_parser *, tree, tree, tree);\n+static tree cp_parser_perform_range_for_lookup\n+  (tree, tree *, tree *);\n+static tree cp_parser_range_for_member_function\n+  (tree, tree);\n static tree cp_parser_jump_statement\n   (cp_parser *);\n static void cp_parser_declaration_statement\n@@ -8557,14 +8561,20 @@ cp_parser_range_for (cp_parser *parser, tree scope, tree init, tree range_decl)\n       }\n \n    If RANGE_EXPR is an array:\n-       BEGIN_EXPR = __range\n-       END_EXPR = __range + ARRAY_SIZE(__range)\n+\tBEGIN_EXPR = __range\n+\tEND_EXPR = __range + ARRAY_SIZE(__range)\n+   Else if RANGE_EXPR has a member 'begin' or 'end':\n+\tBEGIN_EXPR = __range.begin()\n+\tEND_EXPR = __range.end()\n    Else:\n \tBEGIN_EXPR = begin(__range)\n \tEND_EXPR = end(__range);\n \n-   When calling begin()/end() we must use argument dependent\n-   lookup, but always considering 'std' as an associated namespace.  */\n+   If __range has a member 'begin' but not 'end', or vice versa, we must\n+   still use the second alternative (it will surely fail, however).\n+   When calling begin()/end() in the third alternative we must use\n+   argument dependent lookup, but always considering 'std' as an associated\n+   namespace.  */\n \n tree\n cp_convert_range_for (tree statement, tree range_decl, tree range_expr)\n@@ -8581,12 +8591,12 @@ cp_convert_range_for (tree statement, tree range_decl, tree range_expr)\n   else\n     {\n       /* Find out the type deduced by the declaration\n-       * `auto &&__range = range_expr' */\n+         `auto &&__range = range_expr'.  */\n       range_type = cp_build_reference_type (make_auto (), true);\n       range_type = do_auto_deduction (range_type, range_expr,\n \t\t\t\t      type_uses_auto (range_type));\n \n-      /* Create the __range variable */\n+      /* Create the __range variable.  */\n       range_temp = build_decl (input_location, VAR_DECL,\n \t\t\t       get_identifier (\"__for_range\"), range_type);\n       TREE_USED (range_temp) = 1;\n@@ -8597,51 +8607,11 @@ cp_convert_range_for (tree statement, tree range_decl, tree range_expr)\n \t\t      LOOKUP_ONLYCONVERTING);\n \n       range_temp = convert_from_reference (range_temp);\n-\n-      if (TREE_CODE (TREE_TYPE (range_temp)) == ARRAY_TYPE)\n-\t{\n-\t  /* If RANGE_TEMP is an array we will use pointer arithmetic */\n-\t  iter_type = build_pointer_type (TREE_TYPE (TREE_TYPE (range_temp)));\n-\t  begin_expr = range_temp;\n-\t  end_expr\n-\t      = build_binary_op (input_location, PLUS_EXPR,\n-\t\t\t\t range_temp,\n-\t\t\t\t array_type_nelts_top (TREE_TYPE (range_temp)),\n-\t\t\t\t 0);\n-\t}\n-      else\n-\t{\n-\t  /* If it is not an array, we must call begin(__range)/end__range() */\n-\t  VEC(tree,gc) *vec;\n-\n-\t  begin_expr = get_identifier (\"begin\");\n-\t  vec = make_tree_vector ();\n-\t  VEC_safe_push (tree, gc, vec, range_temp);\n-\t  begin_expr = perform_koenig_lookup (begin_expr, vec,\n-\t\t\t\t\t      /*include_std=*/true);\n-\t  begin_expr = finish_call_expr (begin_expr, &vec, false, true,\n-\t\t\t\t\t tf_warning_or_error);\n-\t  release_tree_vector (vec);\n-\n-\t  end_expr = get_identifier (\"end\");\n-\t  vec = make_tree_vector ();\n-\t  VEC_safe_push (tree, gc, vec, range_temp);\n-\t  end_expr = perform_koenig_lookup (end_expr, vec,\n-\t\t\t\t\t    /*include_std=*/true);\n-\t  end_expr = finish_call_expr (end_expr, &vec, false, true,\n-\t\t\t\t       tf_warning_or_error);\n-\t  release_tree_vector (vec);\n-\n-\t  /* The unqualified type of the __begin and __end temporaries should\n-\t   * be the same as required by the multiple auto declaration */\n-\t  iter_type = cv_unqualified (TREE_TYPE (begin_expr));\n-\t  if (!same_type_p (iter_type, cv_unqualified (TREE_TYPE (end_expr))))\n-\t    error (\"inconsistent begin/end types in range-based for: %qT and %qT\",\n-\t\t   TREE_TYPE (begin_expr), TREE_TYPE (end_expr));\n-\t}\n+      iter_type = cp_parser_perform_range_for_lookup (range_temp,\n+\t\t\t\t\t\t      &begin_expr, &end_expr);\n     }\n \n-  /* The new for initialization statement */\n+  /* The new for initialization statement.  */\n   begin = build_decl (input_location, VAR_DECL,\n \t\t      get_identifier (\"__for_begin\"), iter_type);\n   TREE_USED (begin) = 1;\n@@ -8662,18 +8632,18 @@ cp_convert_range_for (tree statement, tree range_decl, tree range_expr)\n \n   finish_for_init_stmt (statement);\n \n-/* The new for condition */\n+  /* The new for condition.  */\n   condition = build_x_binary_op (NE_EXPR,\n \t\t\t\t begin, ERROR_MARK,\n \t\t\t\t end, ERROR_MARK,\n \t\t\t\t NULL, tf_warning_or_error);\n   finish_for_cond (condition, statement);\n \n-  /* The new increment expression */\n+  /* The new increment expression.  */\n   expression = finish_unary_op_expr (PREINCREMENT_EXPR, begin);\n   finish_for_expr (expression, statement);\n \n-  /* The declaration is initialized with *__begin inside the loop body */\n+  /* The declaration is initialized with *__begin inside the loop body.  */\n   cp_finish_decl (range_decl,\n \t\t  build_x_indirect_ref (begin, RO_NULL, tf_warning_or_error),\n \t\t  /*is_constant_init*/false, NULL_TREE,\n@@ -8682,6 +8652,124 @@ cp_convert_range_for (tree statement, tree range_decl, tree range_expr)\n   return statement;\n }\n \n+/* Solves BEGIN_EXPR and END_EXPR as described in cp_convert_range_for.\n+   We need to solve both at the same time because the method used\n+   depends on the existence of members begin or end.\n+   Returns the type deduced for the iterator expression.  */\n+\n+static tree\n+cp_parser_perform_range_for_lookup (tree range, tree *begin, tree *end)\n+{\n+  if (!COMPLETE_TYPE_P (TREE_TYPE (range)))\n+    {\n+      error (\"range-based %<for%> expression of type %qT \"\n+\t     \"has incomplete type\", TREE_TYPE (range));\n+      *begin = *end = error_mark_node;\n+      return error_mark_node;\n+    }\n+  if (TREE_CODE (TREE_TYPE (range)) == ARRAY_TYPE)\n+    {\n+      /* If RANGE is an array, we will use pointer arithmetic.  */\n+      *begin = range;\n+      *end = build_binary_op (input_location, PLUS_EXPR,\n+\t\t\t      range,\n+\t\t\t      array_type_nelts_top (TREE_TYPE (range)),\n+\t\t\t      0);\n+      return build_pointer_type (TREE_TYPE (TREE_TYPE (range)));\n+    }\n+  else\n+    {\n+      /* If it is not an array, we must do a bit of magic.  */\n+      tree id_begin, id_end;\n+      tree member_begin, member_end;\n+\n+      *begin = *end = error_mark_node;\n+\n+      id_begin = get_identifier (\"begin\");\n+      id_end = get_identifier (\"end\");\n+      member_begin = lookup_member (TREE_TYPE (range), id_begin,\n+\t\t\t\t    /*protect=*/2, /*want_type=*/false);\n+      member_end = lookup_member (TREE_TYPE (range), id_end,\n+\t\t\t\t  /*protect=*/2, /*want_type=*/false);\n+\n+      if (member_begin != NULL_TREE || member_end != NULL_TREE)\n+\t{\n+\t  /* Use the member functions.  */\n+\t  if (member_begin != NULL_TREE)\n+\t    *begin = cp_parser_range_for_member_function (range, id_begin);\n+\t  else\n+\t    error (\"range-based %<for%> expression of type %qT has an \"\n+\t\t   \"%<end%> member but not a %<begin%>\", TREE_TYPE (range));\n+\n+\t  if (member_end != NULL_TREE)\n+\t    *end = cp_parser_range_for_member_function (range, id_end);\n+\t  else\n+\t    error (\"range-based %<for%> expression of type %qT has a \"\n+\t\t   \"%<begin%> member but not an %<end%>\", TREE_TYPE (range));\n+\t}\n+      else\n+\t{\n+\t  /* Use global functions with ADL.  */\n+\t  VEC(tree,gc) *vec;\n+\t  vec = make_tree_vector ();\n+\n+\t  VEC_safe_push (tree, gc, vec, range);\n+\n+\t  member_begin = perform_koenig_lookup (id_begin, vec,\n+\t\t\t\t\t\t/*include_std=*/true);\n+\t  *begin = finish_call_expr (member_begin, &vec, false, true,\n+\t\t\t\t     tf_warning_or_error);\n+\t  member_end = perform_koenig_lookup (id_end, vec,\n+\t\t\t\t\t      /*include_std=*/true);\n+\t  *end = finish_call_expr (member_end, &vec, false, true,\n+\t\t\t\t   tf_warning_or_error);\n+\n+\t  release_tree_vector (vec);\n+\t}\n+\n+      /* Last common checks.  */\n+      if (*begin == error_mark_node || *end == error_mark_node)\n+\t{\n+\t  /* If one of the expressions is an error do no more checks.  */\n+\t  *begin = *end = error_mark_node;\n+\t  return error_mark_node;\n+\t}\n+      else\n+\t{\n+\t  tree iter_type = cv_unqualified (TREE_TYPE (*begin));\n+\t  /* The unqualified type of the __begin and __end temporaries should\n+\t     be the same, as required by the multiple auto declaration.  */\n+\t  if (!same_type_p (iter_type, cv_unqualified (TREE_TYPE (*end))))\n+\t    error (\"inconsistent begin/end types in range-based %<for%> \"\n+\t\t   \"statement: %qT and %qT\",\n+\t\t   TREE_TYPE (*begin), TREE_TYPE (*end));\n+\t  return iter_type;\n+\t}\n+    }\n+}\n+\n+/* Helper function for cp_parser_perform_range_for_lookup.\n+   Builds a tree for RANGE.IDENTIFIER().  */\n+\n+static tree\n+cp_parser_range_for_member_function (tree range, tree identifier)\n+{\n+  tree member, res;\n+  VEC(tree,gc) *vec;\n+\n+  member = finish_class_member_access_expr (range, identifier,\n+\t\t\t\t\t    false, tf_warning_or_error);\n+  if (member == error_mark_node)\n+    return error_mark_node;\n+\n+  vec = make_tree_vector ();\n+  res = finish_call_expr (member, &vec,\n+\t\t\t  /*disallow_virtual=*/false,\n+\t\t\t  /*koenig_p=*/false,\n+\t\t\t  tf_warning_or_error);\n+  release_tree_vector (vec);\n+  return res;\n+}\n \n /* Parse an iteration-statement.\n \n@@ -8830,7 +8918,7 @@ cp_parser_for_init_statement (cp_parser* parser, tree *decl)\n \t  if (cxx_dialect < cxx0x)\n \t    {\n \t      error_at (cp_lexer_peek_token (parser->lexer)->location,\n-\t\t\t\"range-based-for loops are not allowed \"\n+\t\t\t\"range-based %<for%> loops are not allowed \"\n \t\t\t\"in C++98 mode\");\n \t      *decl = error_mark_node;\n \t    }"}, {"sha": "793883e898254e4793dd5e9251f5d42f4ea417e5", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=deb9642d054842041402b44d2062d8a5efa40ce0", "patch": "@@ -2074,6 +2074,22 @@ finish_call_expr (tree fn, VEC(tree,gc) **args, bool disallow_virtual,\n       make_args_non_dependent (*args);\n     }\n \n+  if (TREE_CODE (fn) == COMPONENT_REF)\n+    {\n+      tree member = TREE_OPERAND (fn, 1);\n+      if (BASELINK_P (member))\n+\t{\n+\t  tree object = TREE_OPERAND (fn, 0);\n+\t  return build_new_method_call (object, member,\n+\t\t\t\t\targs, NULL_TREE,\n+                                        (disallow_virtual\n+                                         ? LOOKUP_NORMAL | LOOKUP_NONVIRTUAL\n+\t\t\t\t\t : LOOKUP_NORMAL),\n+\t\t\t\t\t/*fn_p=*/NULL,\n+\t\t\t\t\tcomplain);\n+\t}\n+    }\n+\n   if (is_overloaded_fn (fn))\n     fn = baselink_for_fns (fn);\n "}, {"sha": "ea66b492b77abc12733fb4f5999175e0e83c7164", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=deb9642d054842041402b44d2062d8a5efa40ce0", "patch": "@@ -1,3 +1,19 @@\n+2011-04-15  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/range-for17.C: New.\n+\n+2011-04-15  Rodrigo Rivas Costa <rodrigorivascosta@gmail.com>\n+\n+\t* g++.dg/cpp0x/range-for2.C: Correct for declaration.\n+\t* g++.dg/cpp0x/range-for3.C: Likewise.\n+\t* g++.dg/cpp0x/range-for9.C: Correct error message.\n+\t* g++.dg/cpp0x/range-for11.C: New.\n+\t* g++.dg/cpp0x/range-for12.C: New.\n+\t* g++.dg/cpp0x/range-for13.C: New.\n+\t* g++.dg/cpp0x/range-for14.C: New.\n+\t* g++.dg/cpp0x/range-for15.C: New.\n+\t* g++.dg/cpp0x/range-for16.C: New.\n+\n 2011-04-15  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/18918"}, {"sha": "d02519a2519b16582300a558328965a51c7c08dc", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for11.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for11.C?ref=deb9642d054842041402b44d2062d8a5efa40ce0", "patch": "@@ -0,0 +1,40 @@\n+// Test for range-based for loop\n+// Test the loop with a custom iterator\n+// with begin/end as member functions\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+struct iterator\n+{\n+    int x;\n+    explicit iterator(int v) :x(v) {}\n+    iterator &operator ++() { ++x; return *this; }\n+    int operator *() { return x; }\n+    bool operator != (const iterator &o) { return x != o.x; }\n+};\n+\n+namespace foo\n+{\n+    struct container\n+    {\n+        int min, max;\n+        container(int a, int b) :min(a), max(b) {}\n+\n+        iterator begin()\n+        {\n+            return iterator(min);\n+        }\n+        iterator end()\n+        {\n+            return iterator(max + 1);\n+        }\n+    };\n+}\n+\n+int main()\n+{\n+    foo::container c(1,4);\n+    for (int it : c)\n+        ;\n+}"}, {"sha": "9b405dc620a9b5562fa91128304e7212f2e367ab", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for12.C", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for12.C?ref=deb9642d054842041402b44d2062d8a5efa40ce0", "patch": "@@ -0,0 +1,116 @@\n+// Test for range-based for loop with templates\n+// and begin/end as member functions\n+\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+/* Preliminary declarations */\n+namespace pre\n+{\n+  struct iterator\n+  {\n+    int x;\n+    explicit iterator (int v) :x(v) {}\n+    iterator &operator ++() { ++x; return *this; }\n+    int operator *() { return x; }\n+    bool operator != (const iterator &o) { return x != o.x; }\n+  };\n+\n+  struct container\n+  {\n+    int min, max;\n+    container(int a, int b) :min(a), max(b) {}\n+    iterator begin() const\n+    {\n+        return iterator(min);\n+    }\n+    iterator end() const\n+    {\n+        return iterator(max);\n+    }\n+\n+  };\n+\n+} //namespace pre\n+\n+using pre::container;\n+extern \"C\" void abort(void);\n+\n+container run_me_just_once()\n+{\n+    static bool run = false;\n+    if (run)\n+        abort();\n+    run = true;\n+    return container(1,2);\n+}\n+\n+/* Template with dependent expression. */\n+template<typename T> int test1(const T &r)\n+{\n+  int t = 0;\n+  for (int i : r)\n+    t += i;\n+  return t;\n+}\n+\n+/* Template with non-dependent expression and dependent declaration. */\n+template<typename T> int test2(const container &r)\n+{\n+  int t = 0;\n+  for (T i : r)\n+    t += i;\n+  return t;\n+}\n+\n+/* Template with non-dependent expression (array) and dependent declaration. */\n+template<typename T> int test2(const int (&r)[4])\n+{\n+  int t = 0;\n+  for (T i : r)\n+    t += i;\n+  return t;\n+}\n+\n+/* Template with non-dependent expression and auto declaration. */\n+template<typename T> int test3(const container &r)\n+{\n+  int t = 0;\n+  for (auto i : r)\n+    t += i;\n+  return t;\n+}\n+\n+/* Template with non-dependent expression (array) and auto declaration. */\n+template<typename T> int test3(const int (&r)[4])\n+{\n+  int t = 0;\n+  for (auto i : r)\n+    t += i;\n+  return t;\n+}\n+\n+int main ()\n+{\n+  container c(1,5);\n+  int a[4] = {5,6,7,8};\n+\n+  for (auto x : run_me_just_once())\n+      ;\n+\n+  if (test1 (c) != 10)\n+    abort();\n+  if (test1 (a) != 26)\n+    abort();\n+\n+  if (test2<int> (c) != 10)\n+    abort();\n+  if (test2<int> (a) != 26)\n+    abort();\n+\n+  if (test3<int> (c) != 10)\n+    abort();\n+  if (test3<int> (a) != 26)\n+    abort();\n+  return 0;\n+}"}, {"sha": "7ebf0c563e83a040a8effdb67d6075e4668082ff", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for13.C", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for13.C?ref=deb9642d054842041402b44d2062d8a5efa40ce0", "patch": "@@ -0,0 +1,103 @@\n+// Test for errors in range-based for loops\n+// with member begin/end\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+//These should not be used\n+template<typename T> int *begin(T &t)\n+{\n+    T::fail;\n+}\n+template<typename T> int *end(T &t)\n+{\n+    T::fail;\n+}\n+\n+struct container1\n+{\n+    int *begin();\n+    //no end\n+};\n+\n+struct container2\n+{\n+    int *end();\n+    //no begin\n+};\n+\n+struct container3\n+{\n+private:\n+    int *begin(); // { dg-error \"is private\" }\n+    int *end(); // { dg-error \"is private\" }\n+};\n+\n+struct container4\n+{\n+    int *begin;\n+    int *end;\n+};\n+\n+struct container5\n+{\n+    typedef int *begin;\n+    typedef int *end;\n+};\n+\n+struct callable\n+{\n+    int *operator()();\n+};\n+\n+struct container6\n+{\n+    callable begin;\n+    callable end;\n+};\n+\n+struct container7\n+{\n+    static callable begin;\n+    static callable end;\n+};\n+\n+struct container8\n+{\n+    static int *begin();\n+    int *end();\n+};\n+\n+struct private_callable\n+{\n+private:\n+    int *operator()(); // { dg-error \"is private\" }\n+};\n+\n+struct container9\n+{\n+    private_callable begin;\n+    private_callable end;\n+};\n+\n+struct container10\n+{\n+    typedef int *(*function)();\n+\n+    function begin;\n+    static function end;\n+};\n+\n+void test1()\n+{\n+  for (int x : container1()); // { dg-error \"member but not\" }\n+  for (int x : container2()); // { dg-error \"member but not\" }\n+  for (int x : container3()); // { dg-error \"within this context\" }\n+  for (int x : container4()); // { dg-error \"cannot be used as a function\" }\n+  for (int x : container5()); // { dg-error \"invalid use of\" }\n+  for (int x : container6());\n+  for (int x : container7());\n+  for (int x : container8());\n+  for (int x : container9()); // { dg-error \"within this context\" }\n+  for (int x : container10());\n+}"}, {"sha": "26ae477d70e7f7dd9609f8c6da8a6e2359a3f1c6", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for14.C", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for14.C?ref=deb9642d054842041402b44d2062d8a5efa40ce0", "patch": "@@ -0,0 +1,95 @@\n+// Test for other range-based for loops with\n+// begin/end member functions\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+//These should not be used\n+template<typename T> int *begin(T &t)\n+{\n+    T::fail;\n+}\n+template<typename T> int *end(T &t)\n+{\n+    T::fail;\n+}\n+\n+//Test for defaults\n+\n+struct default1\n+{\n+    int *begin(int x); // { dg-message \"note\" }\n+    int *end();\n+};\n+\n+struct default2\n+{\n+    int *begin(int x=0);\n+    int *end();\n+};\n+\n+struct default3\n+{\n+    template <typename T> T *begin(); // { dg-message \"note\" }\n+    int *end();\n+};\n+\n+struct default4\n+{\n+    template <typename T=int> T *begin();\n+    int *end();\n+};\n+\n+struct default5\n+{\n+    template <typename T=int> T *begin(int x=0);\n+    int *end();\n+};\n+\n+void test1()\n+{\n+  for (int x : default1()); // { dg-error \"no matching function|note\" }\n+  for (int x : default2());\n+  for (int x : default3()); // { dg-error \"no matching function|note\" }\n+  for (int x : default4());\n+  for (int x : default5());\n+}\n+\n+//Inheritance tests\n+\n+struct base_begin\n+{\n+    int *begin(); // { dg-error \"\" }\n+};\n+\n+struct base_end\n+{\n+    int *end();\n+};\n+\n+struct derived1 : base_begin, base_end\n+{\n+};\n+\n+struct base_begin2 : base_begin\n+{\n+};\n+\n+struct derived2 : base_begin, base_end, base_begin2 // { dg-warning \"\" }\n+{\n+};\n+\n+struct base_begin3 : virtual base_begin\n+{\n+};\n+\n+struct derived3 : virtual base_begin, base_end, base_begin3\n+{\n+};\n+\n+void test2()\n+{\n+  for (int x : derived1());\n+  for (int x : derived2()); // { dg-error \"is ambiguous\" }\n+  for (int x : derived3());\n+}"}, {"sha": "38f330771ea22b38ae972caea036b637af9dc9b7", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for15.C", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for15.C?ref=deb9642d054842041402b44d2062d8a5efa40ce0", "patch": "@@ -0,0 +1,59 @@\n+// Test for range-based for loop with templates\n+// and begin/end as member (non-)virtual functions\n+\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+unsigned int g;\n+\n+struct A\n+{\n+    virtual int *begin()\n+    {\n+        g |= 1;\n+        return 0;\n+    }\n+    int *end()\n+    {\n+        g |= 2;\n+        return 0;\n+    }\n+};\n+\n+struct B : A\n+{\n+    virtual int *begin()\n+    {\n+        g |= 4;\n+        return 0;\n+    }\n+    int *end()\n+    {\n+        g |= 8;\n+        return 0;\n+    }\n+};\n+\n+extern \"C\" void abort(void);\n+\n+int main ()\n+{\n+    A a;\n+    B b;\n+    A &aa = b;\n+\n+    g = 0;\n+    for (int x : a);\n+    if (g != (1 | 2))\n+        abort();\n+\n+    g = 0;\n+    for (int x : b);\n+    if (g != (4 | 8))\n+        abort();\n+\n+    g = 0;\n+    for (int x : aa);\n+    if (g != (4 | 2))\n+        abort();\n+}"}, {"sha": "86cc2a828bff2ec8fa56ad66e1d662370f59bdb5", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for16.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for16.C?ref=deb9642d054842041402b44d2062d8a5efa40ce0", "patch": "@@ -0,0 +1,21 @@\n+// Test for range-based for loop with arrays of\n+// incomplete type or unknown size\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+extern int a[10];\n+extern int b[];\n+\n+struct S;\n+extern S c[10];\n+extern S d[];\n+\n+void test()\n+{\n+    for (int n : a);\n+    for (int n : b); // { dg-error \"incomplete type\" }\n+    for (S &n : c); // { dg-error \"incomplete type\" }\n+    for (S &n : d); // { dg-error \"incomplete type\" }\n+    for (int n : *c); // { dg-error \"incomplete type\" }\n+}"}, {"sha": "eb888d9ab62a2c0e0965e287ea4078c70143c4ec", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for17.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for17.C?ref=deb9642d054842041402b44d2062d8a5efa40ce0", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options -std=c++0x }\n+\n+extern \"C\" int printf (const char *, ...);\n+\n+enum E { e1, e2, e3, X };\n+E operator*(E e) { return e; }\n+E begin(E e) { return e; }\n+E end(E e) { return X; };\n+E operator++(E& e) { return e = E(e+1); }\n+\n+int main()\n+{\n+  for (auto e: e1)\n+    {\n+      printf (\"%d \", e);\n+    }\n+}"}, {"sha": "17eb41dba7bae83fc62598f621d42b117c5d8d89", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for2.C?ref=deb9642d054842041402b44d2062d8a5efa40ce0", "patch": "@@ -8,7 +8,7 @@\n struct iterator\n {\n     int x;\n-    iterator(int v) :x(v) {}\n+    explicit iterator(int v) :x(v) {}\n     iterator &operator ++() { ++x; return *this; }\n     int operator *() { return x; }\n     bool operator != (const iterator &o) { return x != o.x; }\n@@ -36,6 +36,6 @@ namespace foo\n int main()\n {\n     foo::container c(1,4);\n-    for (iterator it : c)\n+    for (int it : c)\n         ;\n }"}, {"sha": "85115a38f5ee5135d01192356be20f580e873714", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for3.C?ref=deb9642d054842041402b44d2062d8a5efa40ce0", "patch": "@@ -8,7 +8,7 @@\n struct iterator\n {\n     int x;\n-    iterator(int v) :x(v) {}\n+    explicit iterator(int v) :x(v) {}\n     iterator &operator ++() { ++x; return *this; }\n     int operator *() { return x; }\n     bool operator != (const iterator &o) { return x != o.x; }\n@@ -36,7 +36,7 @@ namespace std\n int main()\n {\n     container c(1,4);\n-    for (iterator it : c)\n+    for (int it : c)\n     {\n     }\n }"}, {"sha": "c51cbf994698480ac1d84357fa5f8f9acd28171d", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb9642d054842041402b44d2062d8a5efa40ce0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for9.C?ref=deb9642d054842041402b44d2062d8a5efa40ce0", "patch": "@@ -6,6 +6,6 @@\n void test()\n {\n     int a[] = {0,1,2};\n-    for (int x : a)  // { dg-error \"range-based-for\" }\n+    for (int x : a)  // { dg-error \"range-based 'for'\" }\n         ;\n }"}]}