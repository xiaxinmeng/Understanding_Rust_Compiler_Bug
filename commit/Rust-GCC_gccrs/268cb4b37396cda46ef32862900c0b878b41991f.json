{"sha": "268cb4b37396cda46ef32862900c0b878b41991f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY4Y2I0YjM3Mzk2Y2RhNDZlZjMyODYyOTAwYzBiODc4YjQxOTkxZg==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2015-03-06T16:35:30Z"}, "committer": {"name": "Jiong Wang", "email": "jiwang@gcc.gnu.org", "date": "2015-03-06T16:35:30Z"}, "message": "Remove inefficient branchless conditional negate optimization\n\n2015-03-06  Wilco Dijkstra  <wdijkstr@arm.com>\n\n  gcc/\n    * tree-ssa-phiopt.c (neg_replacement): Remove.\n    (tree_ssa_phiopt_worker): Remove negate optimization.\n\n  gcc/testsuite/\n    * gcc.dg/tree-ssa/pr45685.c: Move to gcc.target/i386.\n    * gcc.target/aarch64/csneg-1.c (test_csneg_cmp): New test.\n    * gcc.target/i386/pr45685.c: Moved test, check for conditional move on x64.\n\nFrom-SVN: r221246", "tree": {"sha": "111df7de9b826cec41098784818c97eca99f054e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/111df7de9b826cec41098784818c97eca99f054e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/268cb4b37396cda46ef32862900c0b878b41991f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/268cb4b37396cda46ef32862900c0b878b41991f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/268cb4b37396cda46ef32862900c0b878b41991f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/268cb4b37396cda46ef32862900c0b878b41991f/comments", "author": null, "committer": null, "parents": [{"sha": "c271e224c2e6bcda1068754def0b0cfd6a2b2958", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c271e224c2e6bcda1068754def0b0cfd6a2b2958", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c271e224c2e6bcda1068754def0b0cfd6a2b2958"}], "stats": {"total": 184, "additions": 23, "deletions": 161}, "files": [{"sha": "3b7801ed54acd50905cbca082a7cf5891d23cb56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268cb4b37396cda46ef32862900c0b878b41991f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268cb4b37396cda46ef32862900c0b878b41991f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=268cb4b37396cda46ef32862900c0b878b41991f", "patch": "@@ -1,3 +1,8 @@\n+2015-03-06  Wilco Dijkstra  <wilco.dijkstra@arm.com>\n+\n+\t* tree-ssa-phiopt.c (neg_replacement): Remove.\n+\t(tree_ssa_phiopt_worker): Remove negate optimization.\n+\n 2015-03-05  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/65302"}, {"sha": "ede3d7433361b8a78687b128dfef8da1e730e202", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268cb4b37396cda46ef32862900c0b878b41991f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268cb4b37396cda46ef32862900c0b878b41991f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=268cb4b37396cda46ef32862900c0b878b41991f", "patch": "@@ -1,3 +1,10 @@\n+2015-03-06  Wilco Dijkstra  <wilco.dijkstra@arm.com>\n+\n+\t* gcc.dg/tree-ssa/pr45685.c: Move to gcc.target/i386.\n+\t* gcc.target/aarch64/csneg-1.c (test_csneg_cmp): New test.\n+\t* gcc.target/i386/pr45685.c: Moved test, check for conditional move on\n+\tx64.\n+\n 2015-03-05  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* g++.dg/lto/pr65302_1.C: New testcase."}, {"sha": "29d4e4ee70ff3e5bb67dec29ca5c4d5064877143", "filename": "gcc/testsuite/gcc.target/aarch64/csneg-1.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268cb4b37396cda46ef32862900c0b878b41991f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcsneg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268cb4b37396cda46ef32862900c0b878b41991f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcsneg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcsneg-1.c?ref=268cb4b37396cda46ef32862900c0b878b41991f", "patch": "@@ -48,3 +48,11 @@ test_csneg64_condasn2(long long x0,\n   x4 = (x0 == x1) ? x3 : -x2;\n   return x4;\n }\n+\n+int test_csneg_cmp(int x)\n+{\n+  /* { dg-final { scan-assembler \"csneg\\tw\\[0-9\\]\" } } */\n+  if (x > 3)\n+    x = -x;\n+  return x;\n+}"}, {"sha": "7f50bb332f2c841f75a644281fbe5a71dad7400b", "filename": "gcc/testsuite/gcc.target/i386/pr45685.c", "status": "renamed", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268cb4b37396cda46ef32862900c0b878b41991f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr45685.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268cb4b37396cda46ef32862900c0b878b41991f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr45685.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr45685.c?ref=268cb4b37396cda46ef32862900c0b878b41991f", "patch": "@@ -1,5 +1,5 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O3 -fdump-tree-phiopt1-details\" } */\n+/* { dg-do compile { target { ! { ia32 } } } } */\n+/* { dg-options \"-O3\" } */\n \n typedef unsigned long int uint64_t;\n typedef long int int64_t;\n@@ -36,6 +36,4 @@ int summation_helper_2(int64_t* products, uint64_t count)\n \treturn s;\n }\n \n-/* { dg-final { scan-tree-dump-times \"converted to straightline code\" 2 \"phiopt1\" } } */\n-/* { dg-final { cleanup-tree-dump \"phiopt1\" } } */\n-\n+/* { dg-final { scan-assembler-times \"cmov\" 4 } } */", "previous_filename": "gcc/testsuite/gcc.dg/tree-ssa/pr45685.c"}, {"sha": "14a7122f9709d38d9476ad499cec83cf8621253f", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268cb4b37396cda46ef32862900c0b878b41991f/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268cb4b37396cda46ef32862900c0b878b41991f/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=268cb4b37396cda46ef32862900c0b878b41991f", "patch": "@@ -96,8 +96,6 @@ static bool minmax_replacement (basic_block, basic_block,\n \t\t\t\tedge, edge, gimple, tree, tree);\n static bool abs_replacement (basic_block, basic_block,\n \t\t\t     edge, edge, gimple, tree, tree);\n-static bool neg_replacement (basic_block, basic_block,\n-\t\t\t     edge, edge, gimple, tree, tree);\n static bool cond_store_replacement (basic_block, basic_block, edge, edge,\n \t\t\t\t    hash_set<tree> *);\n static bool cond_if_else_store_replacement (basic_block, basic_block, basic_block);\n@@ -209,23 +207,6 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n     /* Calculate the set of non-trapping memory accesses.  */\n     nontrap = get_non_trapping ();\n \n-  /* The replacement of conditional negation with a non-branching\n-     sequence is really only a win when optimizing for speed and we\n-     can avoid transformations by gimple if-conversion that result\n-     in poor RTL generation.\n-\n-     Ideally either gimple if-conversion or the RTL expanders will\n-     be improved and the code to emit branchless conditional negation\n-     can be removed.  */\n-  bool replace_conditional_negation = false;\n-  if (!do_store_elim)\n-    replace_conditional_negation\n-      = ((!optimize_size && optimize >= 2)\n-\t || (((flag_tree_loop_vectorize || cfun->has_force_vectorize_loops)\n-\t      && flag_tree_loop_if_convert != 0)\n-\t     || flag_tree_loop_if_convert == 1\n-\t     || flag_tree_loop_if_convert_stores == 1));\n-\n   /* Search every basic block for COND_EXPR we may be able to optimize.\n \n      We walk the blocks in order that guarantees that a block with\n@@ -380,9 +361,6 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n \t    cfgchanged = true;\n \t  else if (abs_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n \t    cfgchanged = true;\n-\t  else if (replace_conditional_negation\n-\t\t   && neg_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n-\t    cfgchanged = true;\n \t  else if (minmax_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n \t    cfgchanged = true;\n \t}\n@@ -1319,140 +1297,6 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n   return true;\n }\n \n-/*  The function neg_replacement replaces conditional negation with\n-    equivalent straight line code.  Returns TRUE if replacement is done,\n-    otherwise returns FALSE.\n-\n-    COND_BB branches around negation occuring in MIDDLE_BB.\n-\n-    E0 and E1 are edges out of COND_BB.  E0 reaches MIDDLE_BB and\n-    E1 reaches the other successor which should contain PHI with\n-    arguments ARG0 and ARG1.\n-\n-    Assuming negation is to occur when the condition is true,\n-    then the non-branching sequence is:\n-\n-       result = (rhs ^ -cond) + cond\n-\n-    Inverting the condition or its result gives us negation\n-    when the original condition is false.  */\n-\n-static bool\n-neg_replacement (basic_block cond_bb, basic_block middle_bb,\n-\t\t edge e0 ATTRIBUTE_UNUSED, edge e1,\n-\t\t gimple phi, tree arg0, tree arg1)\n-{\n-  gimple new_stmt, cond;\n-  gimple_stmt_iterator gsi;\n-  gimple assign;\n-  edge true_edge, false_edge;\n-  tree rhs, lhs;\n-  enum tree_code cond_code;\n-  bool invert = false;\n-\n-  /* This transformation performs logical operations on the\n-     incoming arguments.  So force them to be integral types.   */\n-  if (!INTEGRAL_TYPE_P (TREE_TYPE (arg0)))\n-    return false;\n-\n-  /* OTHER_BLOCK must have only one executable statement which must have the\n-     form arg0 = -arg1 or arg1 = -arg0.  */\n-\n-  assign = last_and_only_stmt (middle_bb);\n-  /* If we did not find the proper negation assignment, then we can not\n-     optimize.  */\n-  if (assign == NULL)\n-    return false;\n-\n-  /* If we got here, then we have found the only executable statement\n-     in OTHER_BLOCK.  If it is anything other than arg0 = -arg1 or\n-     arg1 = -arg0, then we can not optimize.  */\n-  if (gimple_code (assign) != GIMPLE_ASSIGN)\n-    return false;\n-\n-  lhs = gimple_assign_lhs (assign);\n-\n-  if (gimple_assign_rhs_code (assign) != NEGATE_EXPR)\n-    return false;\n-\n-  rhs = gimple_assign_rhs1 (assign);\n-\n-  /* The assignment has to be arg0 = -arg1 or arg1 = -arg0.  */\n-  if (!(lhs == arg0 && rhs == arg1)\n-      && !(lhs == arg1 && rhs == arg0))\n-    return false;\n-\n-  /* The basic sequence assumes we negate when the condition is true.\n-     If we need the opposite, then we will either need to invert the\n-     condition or its result.  */\n-  extract_true_false_edges_from_block (cond_bb, &true_edge, &false_edge);\n-  invert = false_edge->dest == middle_bb;\n-\n-  /* Unlike abs_replacement, we can handle arbitrary conditionals here.  */\n-  cond = last_stmt (cond_bb);\n-  cond_code = gimple_cond_code (cond);\n-\n-  /* If inversion is needed, first try to invert the test since\n-     that's cheapest.  */\n-  if (invert)\n-    {\n-      bool honor_nans = HONOR_NANS (gimple_cond_lhs (cond));\n-      enum tree_code new_code = invert_tree_comparison (cond_code, honor_nans);\n-\n-      /* If invert_tree_comparison was successful, then use its return\n-\t value as the new code and note that inversion is no longer\n-\t needed.  */\n-      if (new_code != ERROR_MARK)\n-\t{\n-\t  cond_code = new_code;\n-\t  invert = false;\n-\t}\n-    }\n-\n-  tree cond_val = make_ssa_name (boolean_type_node);\n-  new_stmt = gimple_build_assign (cond_val, cond_code,\n-\t\t\t\t  gimple_cond_lhs (cond),\n-\t\t\t\t  gimple_cond_rhs (cond));\n-  gsi = gsi_last_bb (cond_bb);\n-  gsi_insert_before (&gsi, new_stmt, GSI_NEW_STMT);\n-\n-  /* If we still need inversion, then invert the result of the\n-     condition.  */\n-  if (invert)\n-    {\n-      tree tmp = make_ssa_name (boolean_type_node);\n-      new_stmt = gimple_build_assign (tmp, BIT_XOR_EXPR, cond_val,\n-\t\t\t\t      boolean_true_node);\n-      gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n-      cond_val = tmp;\n-    }\n-\n-  /* Get the condition in the right type so that we can perform\n-     logical and arithmetic operations on it.  */\n-  tree cond_val_converted = make_ssa_name (TREE_TYPE (rhs));\n-  new_stmt = gimple_build_assign (cond_val_converted, NOP_EXPR, cond_val);\n-  gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n-\n-  tree neg_cond_val_converted = make_ssa_name (TREE_TYPE (rhs));\n-  new_stmt = gimple_build_assign (neg_cond_val_converted, NEGATE_EXPR,\n-\t\t\t\t  cond_val_converted);\n-  gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n-\n-  tree tmp = make_ssa_name (TREE_TYPE (rhs));\n-  new_stmt = gimple_build_assign (tmp, BIT_XOR_EXPR, rhs,\n-\t\t\t\t  neg_cond_val_converted);\n-  gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n-\n-  tree new_lhs = make_ssa_name (TREE_TYPE (rhs));\n-  new_stmt = gimple_build_assign (new_lhs, PLUS_EXPR, tmp, cond_val_converted);\n-  gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n-\n-  replace_phi_edge_with_variable (cond_bb, e1, phi, new_lhs);\n-\n-  /* Note that we optimized this PHI.  */\n-  return true;\n-}\n-\n /* Auxiliary functions to determine the set of memory accesses which\n    can't trap because they are preceded by accesses to the same memory\n    portion.  We do that for MEM_REFs, so we only need to track"}]}