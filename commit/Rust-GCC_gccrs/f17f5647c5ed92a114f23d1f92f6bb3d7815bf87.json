{"sha": "f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE3ZjU2NDdjNWVkOTJhMTE0ZjIzZDFmOTJmNmJiM2Q3ODE1YmY4Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2019-12-16T10:33:36Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-12-16T10:33:36Z"}, "message": "[Ada] AI12-0208 Support for Ada.Numerics.Big_Numbers.Big_Integers and Big_Reals\n\n2019-12-16  Arnaud Charlet  <charlet@adacore.com>\n\ngcc/ada/\n\n\t* impunit.adb: Add a-nbnbin, a-nbnbre, a-nubinu to Ada 2020\n\tunits.\n\t* Makefile.rtl: Enable new file.\n\t* libgnat/a-nbnbin.adb, libgnat/a-nbnbin.ads,\n\tlibgnat/a-nbnbre.adb, libgnat/a-nbnbre.ads,\n\tlibgnat/a-nubinu.ads: New files. Provide default standalone\n\timplementation of Ada.Numerics.Big_Numbers.Big_* based on\n\tSystem.Generic_Bignum.\n\t* libgnat/a-nbnbin__gmp.adb: Alternate implementation of\n\tAda.Numerics.Big_Numbers.Big_Integers based on GMP. Not enabled\n\tfor now.\n\t* libgnat/s-bignum.ads, libgnat/s-bignum.adb: Now a simple\n\twrapper on top of s-genbig.ads.\n\t* libgnat/s-genbig.ads, libgnat/s-genbig.adb: New files, making\n\ts-bignum generic for reuse in Ada.Numerics.Big_Numbers.\n\nFrom-SVN: r279418", "tree": {"sha": "020615e1cc1c3ab8ffb2972b543313d503fb9025", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/020615e1cc1c3ab8ffb2972b543313d503fb9025"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a4ada47ed008c7a14b24221107c2ece7af934a8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4ada47ed008c7a14b24221107c2ece7af934a8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4ada47ed008c7a14b24221107c2ece7af934a8b"}], "stats": {"total": 4554, "additions": 3454, "deletions": 1100}, "files": [{"sha": "c86fd3f9dbfe7d93cb7de5d7e6fba4794291df4d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "patch": "@@ -1,3 +1,21 @@\n+2019-12-16  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* impunit.adb: Add a-nbnbin, a-nbnbre, a-nubinu to Ada 2020\n+\tunits.\n+\t* Makefile.rtl: Enable new file.\n+\t* libgnat/a-nbnbin.adb, libgnat/a-nbnbin.ads,\n+\tlibgnat/a-nbnbre.adb, libgnat/a-nbnbre.ads,\n+\tlibgnat/a-nubinu.ads: New files. Provide default standalone\n+\timplementation of Ada.Numerics.Big_Numbers.Big_* based on\n+\tSystem.Generic_Bignum.\n+\t* libgnat/a-nbnbin__gmp.adb: Alternate implementation of\n+\tAda.Numerics.Big_Numbers.Big_Integers based on GMP. Not enabled\n+\tfor now.\n+\t* libgnat/s-bignum.ads, libgnat/s-bignum.adb: Now a simple\n+\twrapper on top of s-genbig.ads.\n+\t* libgnat/s-genbig.ads, libgnat/s-genbig.adb: New files, making\n+\ts-bignum generic for reuse in Ada.Numerics.Big_Numbers.\n+\n 2019-12-16  Bob Duff  <duff@adacore.com>\n \n \t* doc/gnat_ugn/building_executable_programs_with_gnat.rst:"}, {"sha": "baa9d933c2c7f3aa60c0e820f76cb39add63cc58", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "patch": "@@ -205,6 +205,8 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-lliwti$(objext) \\\n   a-llizti$(objext) \\\n   a-locale$(objext) \\\n+  a-nbnbin$(objext) \\\n+  a-nbnbre$(objext) \\\n   a-ncelfu$(objext) \\\n   a-ngcefu$(objext) \\\n   a-ngcoar$(objext) \\\n@@ -224,6 +226,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-nscefu$(objext) \\\n   a-nscoty$(objext) \\\n   a-nselfu$(objext) \\\n+  a-nubinu$(objext) \\\n   a-nucoar$(objext) \\\n   a-nucoty$(objext) \\\n   a-nudira$(objext) \\\n@@ -570,6 +573,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-flocon$(objext) \\\n   s-fore$(objext)   \\\n   s-gearop$(objext) \\\n+  s-genbig$(objext) \\\n   s-geveop$(objext) \\\n   s-gloloc$(objext) \\\n   s-htable$(objext) \\"}, {"sha": "99bb9980370684a44931ed4d5d8f725d95325b26", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "patch": "@@ -620,11 +620,10 @@ package body Impunit is\n    --  The following units should be used only in Ada 202X mode\n \n    Non_Imp_File_Names_2X : constant File_List := (\n-    0 => (\"a-stteou\", T)  -- Ada.Strings.Text_Output\n-    --  ???We use named notation, because there is only one of these so far.\n-    --  When we add more, we should switch to positional notation, and erase\n-    --  the \"0 =>\".\n-   );\n+    (\"a-stteou\", T),  -- Ada.Strings.Text_Output\n+    (\"a-nubinu\", T),  -- Ada.Numerics.Big_Numbers\n+    (\"a-nbnbin\", T),  -- Ada.Numerics.Big_Numbers.Big_Integers\n+    (\"a-nbnbre\", T)); -- Ada.Numerics.Big_Numbers.Big_Reals\n \n    -----------------------\n    -- Alternative Units --"}, {"sha": "1c066f3a31e045b00e90dfe575a4d9dc35bbf6e8", "filename": "gcc/ada/libgnat/a-nbnbin.adb", "status": "added", "additions": 477, "deletions": 0, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fa-nbnbin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fa-nbnbin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-nbnbin.adb?ref=f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "patch": "@@ -0,0 +1,477 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  ADA.NUMERICS.BIG_NUMBERS.BIG_INTEGERS                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+with Ada.Characters.Conversions; use Ada.Characters.Conversions;\n+\n+with Interfaces; use Interfaces;\n+\n+with System.Generic_Bignums;\n+\n+package body Ada.Numerics.Big_Numbers.Big_Integers is\n+\n+   package Bignums is new\n+     System.Generic_Bignums (Use_Secondary_Stack => False);\n+   use Bignums, System;\n+\n+   procedure Free is new Ada.Unchecked_Deallocation (Bignum_Data, Bignum);\n+\n+   function Get_Bignum (Arg : Optional_Big_Integer) return Bignum is\n+     (To_Bignum (Arg.Value.C));\n+   --  Return the Bignum value stored in Arg\n+\n+   procedure Set_Bignum (Arg : in out Optional_Big_Integer; Value : Bignum)\n+     with Inline;\n+   --  Set the Bignum value stored in Arg to Value\n+\n+   ----------------\n+   -- Set_Bignum --\n+   ----------------\n+\n+   procedure Set_Bignum (Arg : in out Optional_Big_Integer; Value : Bignum) is\n+   begin\n+      Arg.Value.C := To_Address (Value);\n+   end Set_Bignum;\n+\n+   --------------\n+   -- Is_Valid --\n+   --------------\n+\n+   function Is_Valid (Arg : Optional_Big_Integer) return Boolean is\n+     (Arg.Value.C /= System.Null_Address);\n+\n+   --------------------------\n+   -- Invalid_Big_Integer --\n+   --------------------------\n+\n+   function Invalid_Big_Integer return Optional_Big_Integer is\n+     (Value => (Ada.Finalization.Controlled with C => System.Null_Address));\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (L, R : Big_Integer) return Boolean is\n+   begin\n+      return Big_EQ (Get_Bignum (L), Get_Bignum (R));\n+   end \"=\";\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\" (L, R : Big_Integer) return Boolean is\n+   begin\n+      return Big_LT (Get_Bignum (L), Get_Bignum (R));\n+   end \"<\";\n+\n+   ----------\n+   -- \"<=\" --\n+   ----------\n+\n+   function \"<=\" (L, R : Big_Integer) return Boolean is\n+   begin\n+      return Big_LE (Get_Bignum (L), Get_Bignum (R));\n+   end \"<=\";\n+\n+   ---------\n+   -- \">\" --\n+   ---------\n+\n+   function \">\" (L, R : Big_Integer) return Boolean is\n+   begin\n+      return Big_GT (Get_Bignum (L), Get_Bignum (R));\n+   end \">\";\n+\n+   ----------\n+   -- \">=\" --\n+   ----------\n+\n+   function \">=\" (L, R : Big_Integer) return Boolean is\n+   begin\n+      return Big_GE (Get_Bignum (L), Get_Bignum (R));\n+   end \">=\";\n+\n+   --------------------\n+   -- To_Big_Integer --\n+   --------------------\n+\n+   function To_Big_Integer (Arg : Integer) return Big_Integer is\n+      Result : Optional_Big_Integer;\n+   begin\n+      Set_Bignum (Result, To_Bignum (Long_Long_Integer (Arg)));\n+      return Result;\n+   end To_Big_Integer;\n+\n+   ----------------\n+   -- To_Integer --\n+   ----------------\n+\n+   function To_Integer (Arg : Big_Integer) return Integer is\n+   begin\n+      return Integer (From_Bignum (Get_Bignum (Arg)));\n+   end To_Integer;\n+\n+   ------------------------\n+   -- Signed_Conversions --\n+   ------------------------\n+\n+   package body Signed_Conversions is\n+\n+      --------------------\n+      -- To_Big_Integer --\n+      --------------------\n+\n+      function To_Big_Integer (Arg : Int) return Big_Integer is\n+         Result : Optional_Big_Integer;\n+      begin\n+         Set_Bignum (Result, To_Bignum (Long_Long_Integer (Arg)));\n+         return Result;\n+      end To_Big_Integer;\n+\n+      ----------------------\n+      -- From_Big_Integer --\n+      ----------------------\n+\n+      function From_Big_Integer (Arg : Big_Integer) return Int is\n+      begin\n+         return Int (From_Bignum (Get_Bignum (Arg)));\n+      end From_Big_Integer;\n+\n+   end Signed_Conversions;\n+\n+   --------------------------\n+   -- Unsigned_Conversions --\n+   --------------------------\n+\n+   package body Unsigned_Conversions is\n+\n+      --------------------\n+      -- To_Big_Integer --\n+      --------------------\n+\n+      function To_Big_Integer (Arg : Int) return Big_Integer is\n+         Result : Optional_Big_Integer;\n+      begin\n+         Set_Bignum (Result, To_Bignum (Unsigned_64 (Arg)));\n+         return Result;\n+      end To_Big_Integer;\n+\n+      ----------------------\n+      -- From_Big_Integer --\n+      ----------------------\n+\n+      function From_Big_Integer (Arg : Big_Integer) return Int is\n+      begin\n+         return Int (From_Bignum (Get_Bignum (Arg)));\n+      end From_Big_Integer;\n+\n+   end Unsigned_Conversions;\n+\n+   ---------------\n+   -- To_String --\n+   ---------------\n+\n+   Hex_Chars : constant array (0 .. 15) of Character := \"0123456789ABCDEF\";\n+\n+   function To_String\n+     (Arg : Big_Integer; Width : Field := 0; Base : Number_Base := 10)\n+      return String\n+   is\n+      Big_Base : constant Big_Integer := To_Big_Integer (Integer (Base));\n+\n+      function Add_Base (S : String) return String;\n+      --  Add base information if Base /= 10\n+\n+      function Leading_Padding\n+        (Str        : String;\n+         Min_Length : Field;\n+         Char       : Character := ' ') return String;\n+      --  Return padding of Char concatenated with Str so that the resulting\n+      --  string is at least Min_Length long.\n+\n+      function Image (Arg : Big_Integer) return String;\n+      --  Return image of Arg, assuming Arg is positive.\n+\n+      function Image (N : Natural) return String;\n+      --  Return image of N, with no leading space.\n+\n+      --------------\n+      -- Add_Base --\n+      --------------\n+\n+      function Add_Base (S : String) return String is\n+      begin\n+         if Base = 10 then\n+            return S;\n+         else\n+            return Image (Base) & \"#\" & S & \"#\";\n+         end if;\n+      end Add_Base;\n+\n+      -----------\n+      -- Image --\n+      -----------\n+\n+      function Image (N : Natural) return String is\n+         S : constant String := Natural'Image (N);\n+      begin\n+         return S (2 .. S'Last);\n+      end Image;\n+\n+      function Image (Arg : Big_Integer) return String is\n+      begin\n+         if Arg < Big_Base then\n+            return (1 => Hex_Chars (To_Integer (Arg)));\n+         else\n+            return Image (Arg / Big_Base)\n+              & Hex_Chars (To_Integer (Arg rem Big_Base));\n+         end if;\n+      end Image;\n+\n+      ---------------------\n+      -- Leading_Padding --\n+      ---------------------\n+\n+      function Leading_Padding\n+        (Str        : String;\n+         Min_Length : Field;\n+         Char       : Character := ' ') return String is\n+      begin\n+         return (1 .. Integer'Max (Integer (Min_Length) - Str'Length, 0)\n+                        => Char) & Str;\n+      end Leading_Padding;\n+\n+   begin\n+      if Arg < To_Big_Integer (0) then\n+         return Leading_Padding (\"-\" & Add_Base (Image (-Arg)), Width);\n+      else\n+         return Leading_Padding (\" \" & Add_Base (Image (Arg)), Width);\n+      end if;\n+   end To_String;\n+\n+   -----------------\n+   -- From_String --\n+   -----------------\n+\n+   function From_String (Arg : String) return Big_Integer is\n+      Result : Optional_Big_Integer;\n+   begin\n+      --  ??? only support Long_Long_Integer, good enough for now\n+      Set_Bignum (Result, To_Bignum (Long_Long_Integer'Value (Arg)));\n+      return Result;\n+   end From_String;\n+\n+   ---------------\n+   -- Put_Image --\n+   ---------------\n+\n+   procedure Put_Image\n+     (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n+      Arg    : Big_Integer) is\n+   begin\n+      Wide_Wide_String'Write (Stream, To_Wide_Wide_String (To_String (Arg)));\n+   end Put_Image;\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   function \"+\" (L : Big_Integer) return Big_Integer is\n+      Result : Optional_Big_Integer;\n+   begin\n+      Set_Bignum (Result, new Bignum_Data'(Get_Bignum (L).all));\n+      return Result;\n+   end \"+\";\n+\n+   ---------\n+   -- \"-\" --\n+   ---------\n+\n+   function \"-\" (L : Big_Integer) return Big_Integer is\n+      Result : Optional_Big_Integer;\n+   begin\n+      Set_Bignum (Result, Big_Neg (Get_Bignum (L)));\n+      return Result;\n+   end \"-\";\n+\n+   -----------\n+   -- \"abs\" --\n+   -----------\n+\n+   function \"abs\" (L : Big_Integer) return Big_Integer is\n+      Result : Optional_Big_Integer;\n+   begin\n+      Set_Bignum (Result, Big_Abs (Get_Bignum (L)));\n+      return Result;\n+   end \"abs\";\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   function \"+\" (L, R : Big_Integer) return Big_Integer is\n+      Result : Optional_Big_Integer;\n+   begin\n+      Set_Bignum (Result, Big_Add (Get_Bignum (L), Get_Bignum (R)));\n+      return Result;\n+   end \"+\";\n+\n+   ---------\n+   -- \"-\" --\n+   ---------\n+\n+   function \"-\" (L, R : Big_Integer) return Big_Integer is\n+      Result : Optional_Big_Integer;\n+   begin\n+      Set_Bignum (Result, Big_Sub (Get_Bignum (L), Get_Bignum (R)));\n+      return Result;\n+   end \"-\";\n+\n+   ---------\n+   -- \"*\" --\n+   ---------\n+\n+   function \"*\" (L, R : Big_Integer) return Big_Integer is\n+      Result : Optional_Big_Integer;\n+   begin\n+      Set_Bignum (Result, Big_Mul (Get_Bignum (L), Get_Bignum (R)));\n+      return Result;\n+   end \"*\";\n+\n+   ---------\n+   -- \"/\" --\n+   ---------\n+\n+   function \"/\" (L, R : Big_Integer) return Big_Integer is\n+      Result : Optional_Big_Integer;\n+   begin\n+      Set_Bignum (Result, Big_Div (Get_Bignum (L), Get_Bignum (R)));\n+      return Result;\n+   end \"/\";\n+\n+   -----------\n+   -- \"mod\" --\n+   -----------\n+\n+   function \"mod\" (L, R : Big_Integer) return Big_Integer is\n+      Result : Optional_Big_Integer;\n+   begin\n+      Set_Bignum (Result, Big_Mod (Get_Bignum (L), Get_Bignum (R)));\n+      return Result;\n+   end \"mod\";\n+\n+   -----------\n+   -- \"rem\" --\n+   -----------\n+\n+   function \"rem\" (L, R : Big_Integer) return Big_Integer is\n+      Result : Optional_Big_Integer;\n+   begin\n+      Set_Bignum (Result, Big_Rem (Get_Bignum (L), Get_Bignum (R)));\n+      return Result;\n+   end \"rem\";\n+\n+   ----------\n+   -- \"**\" --\n+   ----------\n+\n+   function \"**\" (L : Big_Integer; R : Natural) return Big_Integer is\n+      Exp    : Bignum := To_Bignum (Long_Long_Integer (R));\n+      Result : Optional_Big_Integer;\n+   begin\n+      Set_Bignum (Result, Big_Exp (Get_Bignum (L), Exp));\n+      Free (Exp);\n+      return Result;\n+   end \"**\";\n+\n+   ---------\n+   -- Min --\n+   ---------\n+\n+   function Min (L, R : Big_Integer) return Big_Integer is\n+     (if L < R then L else R);\n+\n+   ---------\n+   -- Max --\n+   ---------\n+\n+   function Max (L, R : Big_Integer) return Big_Integer is\n+     (if L > R then L else R);\n+\n+   -----------------------------\n+   -- Greatest_Common_Divisor --\n+   -----------------------------\n+\n+   function Greatest_Common_Divisor (L, R : Big_Integer) return Big_Positive is\n+      function GCD (A, B : Big_Integer) return Big_Integer;\n+      --  Recursive internal version\n+\n+      ---------\n+      -- GCD --\n+      ---------\n+\n+      function GCD (A, B : Big_Integer) return Big_Integer is\n+      begin\n+         if Is_Zero (Get_Bignum (B)) then\n+            return A;\n+         else\n+            return GCD (B, A rem B);\n+         end if;\n+      end GCD;\n+\n+   begin\n+      return GCD (abs L, abs R);\n+   end Greatest_Common_Divisor;\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (This : in out Controlled_Bignum) is\n+   begin\n+      if This.C /= System.Null_Address then\n+         This.C := To_Address (new Bignum_Data'(To_Bignum (This.C).all));\n+      end if;\n+   end Adjust;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (This : in out Controlled_Bignum) is\n+      Tmp : Bignum := To_Bignum (This.C);\n+   begin\n+      Free (Tmp);\n+      This.C := System.Null_Address;\n+   end Finalize;\n+\n+end Ada.Numerics.Big_Numbers.Big_Integers;"}, {"sha": "52f01ea8e630ec02f9c509ff5b2cf24c3d088efd", "filename": "gcc/ada/libgnat/a-nbnbin.ads", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fa-nbnbin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fa-nbnbin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-nbnbin.ads?ref=f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "patch": "@@ -0,0 +1,164 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  ADA.NUMERICS.BIG_NUMBERS.BIG_INTEGERS                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Finalization;\n+with Ada.Streams;\n+\n+private with System;\n+\n+--  Note that some Ada 2020 aspects are commented out since they are not\n+--  supported yet.\n+\n+package Ada.Numerics.Big_Numbers.Big_Integers\n+  with Preelaborate\n+--  Nonblocking\n+is\n+   type Optional_Big_Integer is private\n+     with Default_Initial_Condition => not Is_Valid (Optional_Big_Integer);\n+   --       Integer_Literal => From_String,\n+   --       Put_Image => Put_Image;\n+\n+   function Is_Valid (Arg : Optional_Big_Integer) return Boolean;\n+\n+   subtype Big_Integer is Optional_Big_Integer\n+     with Dynamic_Predicate => Is_Valid (Big_Integer),\n+          Predicate_Failure => (raise Constraint_Error);\n+\n+   function Invalid_Big_Integer return Optional_Big_Integer\n+     with Post => not Is_Valid (Invalid_Big_Integer'Result);\n+\n+   function \"=\" (L, R : Big_Integer) return Boolean;\n+\n+   function \"<\" (L, R : Big_Integer) return Boolean;\n+\n+   function \"<=\" (L, R : Big_Integer) return Boolean;\n+\n+   function \">\" (L, R : Big_Integer) return Boolean;\n+\n+   function \">=\" (L, R : Big_Integer) return Boolean;\n+\n+   function To_Big_Integer (Arg : Integer) return Big_Integer;\n+\n+   subtype Optional_Big_Positive is Optional_Big_Integer\n+     with Dynamic_Predicate =>\n+            (not Is_Valid (Optional_Big_Positive))\n+             or else (Optional_Big_Positive > To_Big_Integer (0)),\n+          Predicate_Failure => (raise Constraint_Error);\n+\n+   subtype Optional_Big_Natural is Optional_Big_Integer\n+     with Dynamic_Predicate =>\n+            (not Is_Valid (Optional_Big_Natural))\n+             or else (Optional_Big_Natural >= To_Big_Integer (0)),\n+          Predicate_Failure => (raise Constraint_Error);\n+\n+   subtype Big_Positive is Big_Integer\n+     with Dynamic_Predicate => Big_Positive > To_Big_Integer (0),\n+          Predicate_Failure => (raise Constraint_Error);\n+\n+   subtype Big_Natural is Big_Integer\n+     with Dynamic_Predicate => Big_Natural >= To_Big_Integer (0),\n+          Predicate_Failure => (raise Constraint_Error);\n+\n+   function In_Range (Arg, Low, High : Big_Integer) return Boolean is\n+     ((Low <= Arg) and (Arg <= High));\n+\n+   function To_Integer (Arg : Big_Integer) return Integer\n+     with Pre => In_Range (Arg,\n+                           Low  => To_Big_Integer (Integer'First),\n+                           High => To_Big_Integer (Integer'Last))\n+                  or else (raise Constraint_Error);\n+\n+   generic\n+      type Int is range <>;\n+   package Signed_Conversions is\n+\n+      function To_Big_Integer (Arg : Int) return Big_Integer;\n+\n+      function From_Big_Integer (Arg : Big_Integer) return Int\n+        with Pre => In_Range (Arg,\n+                              Low  => To_Big_Integer (Int'First),\n+                              High => To_Big_Integer (Int'Last))\n+                     or else (raise Constraint_Error);\n+\n+   end Signed_Conversions;\n+\n+   generic\n+      type Int is mod <>;\n+   package Unsigned_Conversions is\n+\n+      function To_Big_Integer (Arg : Int) return Big_Integer;\n+\n+      function From_Big_Integer (Arg : Big_Integer) return Int\n+        with Pre => In_Range (Arg,\n+                              Low  => To_Big_Integer (Int'First),\n+                              High => To_Big_Integer (Int'Last))\n+                     or else (raise Constraint_Error);\n+\n+   end Unsigned_Conversions;\n+\n+   function To_String (Arg : Big_Integer;\n+                       Width : Field := 0;\n+                       Base  : Number_Base := 10) return String\n+     with Post => To_String'Result'First = 1;\n+\n+   function From_String (Arg : String) return Big_Integer;\n+\n+   procedure Put_Image\n+     (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n+      Arg    : Big_Integer);\n+\n+   function \"+\" (L : Big_Integer) return Big_Integer;\n+\n+   function \"-\" (L : Big_Integer) return Big_Integer;\n+\n+   function \"abs\" (L : Big_Integer) return Big_Integer;\n+\n+   function \"+\" (L, R : Big_Integer) return Big_Integer;\n+\n+   function \"-\" (L, R : Big_Integer) return Big_Integer;\n+\n+   function \"*\" (L, R : Big_Integer) return Big_Integer;\n+\n+   function \"/\" (L, R : Big_Integer) return Big_Integer;\n+\n+   function \"mod\" (L, R : Big_Integer) return Big_Integer;\n+\n+   function \"rem\" (L, R : Big_Integer) return Big_Integer;\n+\n+   function \"**\" (L : Big_Integer; R : Natural) return Big_Integer;\n+\n+   function Min (L, R : Big_Integer) return Big_Integer;\n+\n+   function Max (L, R : Big_Integer) return Big_Integer;\n+\n+   function Greatest_Common_Divisor\n+     (L, R : Big_Integer) return Big_Positive\n+     with Pre => (L /= To_Big_Integer (0) and R /= To_Big_Integer (0))\n+       or else (raise Constraint_Error);\n+\n+private\n+\n+   type Controlled_Bignum is new Ada.Finalization.Controlled with record\n+      C : System.Address := System.Null_Address;\n+   end record;\n+\n+   procedure Adjust   (This : in out Controlled_Bignum);\n+   procedure Finalize (This : in out Controlled_Bignum);\n+\n+   type Optional_Big_Integer is record\n+      Value : Controlled_Bignum;\n+   end record;\n+\n+end Ada.Numerics.Big_Numbers.Big_Integers;"}, {"sha": "041dfe2a0bb4bb25e765236b123ccb8c15614c44", "filename": "gcc/ada/libgnat/a-nbnbin__gmp.adb", "status": "added", "additions": 730, "deletions": 0, "changes": 730, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fa-nbnbin__gmp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fa-nbnbin__gmp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-nbnbin__gmp.adb?ref=f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "patch": "@@ -0,0 +1,730 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  ADA.NUMERICS.BIG_NUMBERS.BIG_INTEGERS                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the GMP version of this package\n+\n+with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n+with Interfaces.C;               use Interfaces.C;\n+with Interfaces.C.Strings;       use Interfaces.C.Strings;\n+with Ada.Characters.Conversions; use Ada.Characters.Conversions;\n+with Ada.Characters.Handling;    use Ada.Characters.Handling;\n+\n+package body Ada.Numerics.Big_Numbers.Big_Integers is\n+\n+   use System;\n+\n+   pragma Linker_Options (\"-lgmp\");\n+\n+   type mpz_t is record\n+      mp_alloc : Integer;\n+      mp_size  : Integer;\n+      mp_d     : System.Address;\n+   end record;\n+   pragma Convention (C, mpz_t);\n+   type mpz_t_ptr is access all mpz_t;\n+\n+   function To_Mpz is new Ada.Unchecked_Conversion (System.Address, mpz_t_ptr);\n+   function To_Address is new\n+     Ada.Unchecked_Conversion (mpz_t_ptr, System.Address);\n+\n+   function Get_Mpz (Arg : Optional_Big_Integer) return mpz_t_ptr is\n+     (To_Mpz (Arg.Value.C));\n+   --  Return the mpz_t value stored in Arg\n+\n+   procedure Set_Mpz (Arg : in out Optional_Big_Integer; Value : mpz_t_ptr)\n+     with Inline;\n+   --  Set the mpz_t value stored in Arg to Value\n+\n+   procedure Allocate (This : in out Optional_Big_Integer) with Inline;\n+   --  Allocate an Optional_Big_Integer, including the underlying mpz\n+\n+   procedure mpz_init_set (ROP : access mpz_t;  OP : access constant mpz_t);\n+   pragma Import (C, mpz_init_set, \"__gmpz_init_set\");\n+\n+   procedure mpz_set (ROP : access mpz_t;  OP : access constant mpz_t);\n+   pragma Import (C, mpz_set, \"__gmpz_set\");\n+\n+   function mpz_cmp (OP1, OP2 : access constant mpz_t) return Integer;\n+   pragma Import (C, mpz_cmp, \"__gmpz_cmp\");\n+\n+   function mpz_cmp_ui\n+     (OP1 : access constant mpz_t; OP2 : unsigned_long) return Integer;\n+   pragma Import (C, mpz_cmp_ui, \"__gmpz_cmp_ui\");\n+\n+   procedure mpz_set_si (ROP : access mpz_t; OP : long);\n+   pragma Import (C, mpz_set_si, \"__gmpz_set_si\");\n+\n+   procedure mpz_set_ui (ROP : access mpz_t; OP : unsigned_long);\n+   pragma Import (C, mpz_set_ui, \"__gmpz_set_ui\");\n+\n+   function mpz_get_si (OP : access constant mpz_t) return long;\n+   pragma Import (C, mpz_get_si, \"__gmpz_get_si\");\n+\n+   function mpz_get_ui (OP : access constant mpz_t) return unsigned_long;\n+   pragma Import (C, mpz_get_ui, \"__gmpz_get_ui\");\n+\n+   procedure mpz_neg (ROP : access mpz_t;  OP : access constant mpz_t);\n+   pragma Import (C, mpz_neg, \"__gmpz_neg\");\n+\n+   procedure mpz_sub (ROP : access mpz_t;  OP1, OP2 : access constant mpz_t);\n+   pragma Import (C, mpz_sub, \"__gmpz_sub\");\n+\n+   -------------\n+   -- Set_Mpz --\n+   -------------\n+\n+   procedure Set_Mpz (Arg : in out Optional_Big_Integer; Value : mpz_t_ptr) is\n+   begin\n+      Arg.Value.C := To_Address (Value);\n+   end Set_Mpz;\n+\n+   --------------\n+   -- Is_Valid --\n+   --------------\n+\n+   function Is_Valid (Arg : Optional_Big_Integer) return Boolean is\n+     (Arg.Value.C /= System.Null_Address);\n+\n+   --------------------------\n+   -- Invalid_Big_Integer --\n+   --------------------------\n+\n+   function Invalid_Big_Integer return Optional_Big_Integer is\n+     (Value => (Ada.Finalization.Controlled with C => System.Null_Address));\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (L, R : Big_Integer) return Boolean is\n+   begin\n+      return mpz_cmp (Get_Mpz (L), Get_Mpz (R)) = 0;\n+   end \"=\";\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\" (L, R : Big_Integer) return Boolean is\n+   begin\n+      return mpz_cmp (Get_Mpz (L), Get_Mpz (R)) < 0;\n+   end \"<\";\n+\n+   ----------\n+   -- \"<=\" --\n+   ----------\n+\n+   function \"<=\" (L, R : Big_Integer) return Boolean is\n+   begin\n+      return mpz_cmp (Get_Mpz (L), Get_Mpz (R)) <= 0;\n+   end \"<=\";\n+\n+   ---------\n+   -- \">\" --\n+   ---------\n+\n+   function \">\" (L, R : Big_Integer) return Boolean is\n+   begin\n+      return mpz_cmp (Get_Mpz (L), Get_Mpz (R)) > 0;\n+   end \">\";\n+\n+   ----------\n+   -- \">=\" --\n+   ----------\n+\n+   function \">=\" (L, R : Big_Integer) return Boolean is\n+   begin\n+      return mpz_cmp (Get_Mpz (L), Get_Mpz (R)) >= 0;\n+   end \">=\";\n+\n+   --------------------\n+   -- To_Big_Integer --\n+   --------------------\n+\n+   function To_Big_Integer (Arg : Integer) return Big_Integer is\n+      Result : Optional_Big_Integer;\n+   begin\n+      Allocate (Result);\n+      mpz_set_si (Get_Mpz (Result), long (Arg));\n+      return Result;\n+   end To_Big_Integer;\n+\n+   ----------------\n+   -- To_Integer --\n+   ----------------\n+\n+   function To_Integer (Arg : Big_Integer) return Integer is\n+   begin\n+      return Integer (mpz_get_si (Get_Mpz (Arg)));\n+   end To_Integer;\n+\n+   ------------------------\n+   -- Signed_Conversions --\n+   ------------------------\n+\n+   package body Signed_Conversions is\n+\n+      --------------------\n+      -- To_Big_Integer --\n+      --------------------\n+\n+      function To_Big_Integer (Arg : Int) return Big_Integer is\n+         Result : Optional_Big_Integer;\n+      begin\n+         Allocate (Result);\n+         mpz_set_si (Get_Mpz (Result), long (Arg));\n+         return Result;\n+      end To_Big_Integer;\n+\n+      ----------------------\n+      -- From_Big_Integer --\n+      ----------------------\n+\n+      function From_Big_Integer (Arg : Big_Integer) return Int is\n+      begin\n+         return Int (mpz_get_si (Get_Mpz (Arg)));\n+      end From_Big_Integer;\n+\n+   end Signed_Conversions;\n+\n+   --------------------------\n+   -- Unsigned_Conversions --\n+   --------------------------\n+\n+   package body Unsigned_Conversions is\n+\n+      --------------------\n+      -- To_Big_Integer --\n+      --------------------\n+\n+      function To_Big_Integer (Arg : Int) return Big_Integer is\n+         Result : Optional_Big_Integer;\n+      begin\n+         Allocate (Result);\n+         mpz_set_ui (Get_Mpz (Result), unsigned_long (Arg));\n+         return Result;\n+      end To_Big_Integer;\n+\n+      ----------------------\n+      -- From_Big_Integer --\n+      ----------------------\n+\n+      function From_Big_Integer (Arg : Big_Integer) return Int is\n+      begin\n+         return Int (mpz_get_ui (Get_Mpz (Arg)));\n+      end From_Big_Integer;\n+\n+   end Unsigned_Conversions;\n+\n+   ---------------\n+   -- To_String --\n+   ---------------\n+\n+   function To_String\n+     (Arg : Big_Integer; Width : Field := 0; Base : Number_Base := 10)\n+      return String\n+   is\n+      function mpz_get_str\n+        (STR  : System.Address;\n+         BASE : Integer;\n+         OP   : access constant mpz_t) return chars_ptr;\n+      pragma Import (C, mpz_get_str, \"__gmpz_get_str\");\n+\n+      function mpz_sizeinbase\n+         (this : access constant mpz_t; base : Integer) return size_t;\n+      pragma Import (C, mpz_sizeinbase, \"__gmpz_sizeinbase\");\n+\n+      function Add_Base (S : String) return String;\n+      --  Add base information if Base /= 10\n+\n+      function Leading_Padding\n+        (Str        : String;\n+         Min_Length : Field;\n+         Char       : Character := ' ') return String;\n+      --  Return padding of Char concatenated with Str so that the resulting\n+      --  string is at least Min_Length long.\n+\n+      function Image (N : Natural) return String;\n+      --  Return image of N, with no leading space.\n+\n+      --------------\n+      -- Add_Base --\n+      --------------\n+\n+      function Add_Base (S : String) return String is\n+      begin\n+         if Base = 10 then\n+            return S;\n+         else\n+            return Image (Base) & \"#\" & To_Upper (S) & \"#\";\n+         end if;\n+      end Add_Base;\n+\n+      -----------\n+      -- Image --\n+      -----------\n+\n+      function Image (N : Natural) return String is\n+         S : constant String := Natural'Image (N);\n+      begin\n+         return S (2 .. S'Last);\n+      end Image;\n+\n+      ---------------------\n+      -- Leading_Padding --\n+      ---------------------\n+\n+      function Leading_Padding\n+        (Str        : String;\n+         Min_Length : Field;\n+         Char       : Character := ' ') return String is\n+      begin\n+         return (1 .. Integer'Max (Integer (Min_Length) - Str'Length, 0)\n+                        => Char) & Str;\n+      end Leading_Padding;\n+\n+      Number_Digits : constant Integer :=\n+        Integer (mpz_sizeinbase (Get_Mpz (Arg), Integer (abs Base)));\n+\n+      Buffer : aliased String (1 .. Number_Digits + 2);\n+      --  The correct number to allocate is 2 more than Number_Digits in order\n+      --  to handle a possible minus sign and the null-terminator.\n+\n+      Result : constant chars_ptr :=\n+        mpz_get_str (Buffer'Address, Integer (Base), Get_Mpz (Arg));\n+      S      : constant String := Value (Result);\n+\n+   begin\n+      if S (1) = '-' then\n+         return Leading_Padding (\"-\" & Add_Base (S (2 .. S'Last)), Width);\n+      else\n+         return Leading_Padding (\" \" & Add_Base (S), Width);\n+      end if;\n+   end To_String;\n+\n+   -----------------\n+   -- From_String --\n+   -----------------\n+\n+   function From_String (Arg : String) return Big_Integer is\n+      function mpz_set_str\n+        (this : access mpz_t;\n+         str  : System.Address;\n+         base : Integer := 10) return Integer;\n+      pragma Import (C, mpz_set_str, \"__gmpz_set_str\");\n+\n+      Result : Optional_Big_Integer;\n+      First  : Natural;\n+      Last   : Natural;\n+      Base   : Natural;\n+\n+   begin\n+      Allocate (Result);\n+\n+      if Arg (Arg'Last) /= '#' then\n+\n+         --  Base 10 number\n+\n+         First := Arg'First;\n+         Last  := Arg'Last;\n+         Base  := 10;\n+      else\n+         --  Compute the xx base in a xx#yyyyy# number\n+\n+         if Arg'Length < 4 then\n+            raise Constraint_Error;\n+         end if;\n+\n+         First := 0;\n+         Last  := Arg'Last - 1;\n+\n+         for J in Arg'First + 1 .. Last loop\n+            if Arg (J) = '#' then\n+               First := J;\n+               exit;\n+            end if;\n+         end loop;\n+\n+         if First = 0 then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Base  := Natural'Value (Arg (Arg'First .. First - 1));\n+         First := First + 1;\n+      end if;\n+\n+      declare\n+         Str   : aliased String (1 .. Last - First + 2);\n+         Index : Natural := 0;\n+      begin\n+         --  Strip underscores\n+\n+         for J in First .. Last loop\n+            if Arg (J) /= '_' then\n+               Index := Index + 1;\n+               Str (Index) := Arg (J);\n+            end if;\n+         end loop;\n+\n+         Index := Index + 1;\n+         Str (Index) := ASCII.NUL;\n+\n+         if mpz_set_str (Get_Mpz (Result), Str'Address, Base) /= 0 then\n+            raise Constraint_Error;\n+         end if;\n+      end;\n+\n+      return Result;\n+   end From_String;\n+\n+   ---------------\n+   -- Put_Image --\n+   ---------------\n+\n+   procedure Put_Image\n+     (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n+      Arg    : Big_Integer) is\n+   begin\n+      Wide_Wide_String'Write (Stream, To_Wide_Wide_String (To_String (Arg)));\n+   end Put_Image;\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   function \"+\" (L : Big_Integer) return Big_Integer is\n+      Result : Optional_Big_Integer;\n+   begin\n+      Set_Mpz (Result, new mpz_t);\n+      mpz_init_set (Get_Mpz (Result), Get_Mpz (L));\n+      return Result;\n+   end \"+\";\n+\n+   ---------\n+   -- \"-\" --\n+   ---------\n+\n+   function \"-\" (L : Big_Integer) return Big_Integer is\n+      Result : Optional_Big_Integer;\n+   begin\n+      Allocate (Result);\n+      mpz_neg (Get_Mpz (Result), Get_Mpz (L));\n+      return Result;\n+   end \"-\";\n+\n+   -----------\n+   -- \"abs\" --\n+   -----------\n+\n+   function \"abs\" (L : Big_Integer) return Big_Integer is\n+      procedure mpz_abs (ROP : access mpz_t;  OP : access constant mpz_t);\n+      pragma Import (C, mpz_abs, \"__gmpz_abs\");\n+\n+      Result : Optional_Big_Integer;\n+   begin\n+      Allocate (Result);\n+      mpz_abs (Get_Mpz (Result), Get_Mpz (L));\n+      return Result;\n+   end \"abs\";\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   function \"+\" (L, R : Big_Integer) return Big_Integer is\n+      procedure mpz_add\n+        (ROP : access mpz_t;  OP1, OP2 : access constant mpz_t);\n+      pragma Import (C, mpz_add, \"__gmpz_add\");\n+\n+      Result : Optional_Big_Integer;\n+\n+   begin\n+      Allocate (Result);\n+      mpz_add (Get_Mpz (Result), Get_Mpz (L), Get_Mpz (R));\n+      return Result;\n+   end \"+\";\n+\n+   ---------\n+   -- \"-\" --\n+   ---------\n+\n+   function \"-\" (L, R : Big_Integer) return Big_Integer is\n+      Result : Optional_Big_Integer;\n+   begin\n+      Allocate (Result);\n+      mpz_sub (Get_Mpz (Result), Get_Mpz (L), Get_Mpz (R));\n+      return Result;\n+   end \"-\";\n+\n+   ---------\n+   -- \"*\" --\n+   ---------\n+\n+   function \"*\" (L, R : Big_Integer) return Big_Integer is\n+      procedure mpz_mul\n+        (ROP : access mpz_t;  OP1, OP2 : access constant mpz_t);\n+      pragma Import (C, mpz_mul, \"__gmpz_mul\");\n+\n+      Result : Optional_Big_Integer;\n+\n+   begin\n+      Allocate (Result);\n+      mpz_mul (Get_Mpz (Result), Get_Mpz (L), Get_Mpz (R));\n+      return Result;\n+   end \"*\";\n+\n+   ---------\n+   -- \"/\" --\n+   ---------\n+\n+   function \"/\" (L, R : Big_Integer) return Big_Integer is\n+      procedure mpz_tdiv_q (Q : access mpz_t;  N, D : access constant mpz_t);\n+      pragma Import (C, mpz_tdiv_q, \"__gmpz_tdiv_q\");\n+   begin\n+      if mpz_cmp_ui (Get_Mpz (R), 0) = 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         Result : Optional_Big_Integer;\n+      begin\n+         Allocate (Result);\n+         mpz_tdiv_q (Get_Mpz (Result), Get_Mpz (L), Get_Mpz (R));\n+         return Result;\n+      end;\n+   end \"/\";\n+\n+   -----------\n+   -- \"mod\" --\n+   -----------\n+\n+   function \"mod\" (L, R : Big_Integer) return Big_Integer is\n+      procedure mpz_mod (R : access mpz_t;  N, D : access constant mpz_t);\n+      pragma Import (C, mpz_mod, \"__gmpz_mod\");\n+      --  result is always non-negative\n+\n+      L_Negative, R_Negative : Boolean;\n+\n+   begin\n+      if mpz_cmp_ui (Get_Mpz (R), 0) = 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         Result : Optional_Big_Integer;\n+      begin\n+         Allocate (Result);\n+         L_Negative := mpz_cmp_ui (Get_Mpz (L), 0) < 0;\n+         R_Negative := mpz_cmp_ui (Get_Mpz (R), 0) < 0;\n+\n+         if not (L_Negative or R_Negative) then\n+            mpz_mod (Get_Mpz (Result), Get_Mpz (L), Get_Mpz (R));\n+         else\n+            --  The GMP library provides operators defined by C semantics, but\n+            --  the semantics of Ada's mod operator are not the same as C's\n+            --  when negative values are involved. We do the following to\n+            --  implement the required Ada semantics.\n+\n+            declare\n+               Temp_Left   : Big_Integer;\n+               Temp_Right  : Big_Integer;\n+               Temp_Result : Big_Integer;\n+\n+            begin\n+               Allocate (Temp_Result);\n+               Set_Mpz (Temp_Left, new mpz_t);\n+               Set_Mpz (Temp_Right, new mpz_t);\n+               mpz_init_set (Get_Mpz (Temp_Left), Get_Mpz (L));\n+               mpz_init_set (Get_Mpz (Temp_Right), Get_Mpz (R));\n+\n+               if L_Negative then\n+                  mpz_neg (Get_Mpz (Temp_Left), Get_Mpz (Temp_Left));\n+               end if;\n+\n+               if R_Negative then\n+                  mpz_neg (Get_Mpz (Temp_Right), Get_Mpz (Temp_Right));\n+               end if;\n+\n+               --  now both Temp_Left and Temp_Right are nonnegative\n+\n+               mpz_mod (Get_Mpz (Temp_Result),\n+                        Get_Mpz (Temp_Left),\n+                        Get_Mpz (Temp_Right));\n+\n+               if mpz_cmp_ui (Get_Mpz (Temp_Result), 0) = 0 then\n+                  --  if Temp_Result is zero we are done\n+                  mpz_set (Get_Mpz (Result), Get_Mpz (Temp_Result));\n+\n+               elsif L_Negative then\n+                  if R_Negative then\n+                     mpz_neg (Get_Mpz (Result), Get_Mpz (Temp_Result));\n+                  else -- L is negative but R is not\n+                     mpz_sub (Get_Mpz (Result),\n+                              Get_Mpz (Temp_Right),\n+                              Get_Mpz (Temp_Result));\n+                  end if;\n+               else\n+                  pragma Assert (R_Negative);\n+                  mpz_sub (Get_Mpz (Result),\n+                           Get_Mpz (Temp_Result),\n+                           Get_Mpz (Temp_Right));\n+               end if;\n+            end;\n+         end if;\n+\n+         return Result;\n+      end;\n+   end \"mod\";\n+\n+   -----------\n+   -- \"rem\" --\n+   -----------\n+\n+   function \"rem\" (L, R : Big_Integer) return Big_Integer is\n+      procedure mpz_tdiv_r (R : access mpz_t;  N, D : access constant mpz_t);\n+      pragma Import (C, mpz_tdiv_r, \"__gmpz_tdiv_r\");\n+      --   R will have the same sign as N.\n+\n+   begin\n+      if mpz_cmp_ui (Get_Mpz (R), 0) = 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         Result : Optional_Big_Integer;\n+      begin\n+         Allocate (Result);\n+         mpz_tdiv_r (R => Get_Mpz (Result),\n+                     N => Get_Mpz (L),\n+                     D => Get_Mpz (R));\n+         --  the result takes the sign of N, as required by the RM\n+\n+         return Result;\n+      end;\n+   end \"rem\";\n+\n+   ----------\n+   -- \"**\" --\n+   ----------\n+\n+   function \"**\" (L : Big_Integer; R : Natural) return Big_Integer is\n+      procedure mpz_pow_ui (ROP : access mpz_t;\n+                            BASE : access constant mpz_t;\n+                            EXP : unsigned_long);\n+      pragma Import (C, mpz_pow_ui, \"__gmpz_pow_ui\");\n+\n+      Result : Optional_Big_Integer;\n+\n+   begin\n+      Allocate (Result);\n+      mpz_pow_ui (Get_Mpz (Result), Get_Mpz (L), unsigned_long (R));\n+      return Result;\n+   end \"**\";\n+\n+   ---------\n+   -- Min --\n+   ---------\n+\n+   function Min (L, R : Big_Integer) return Big_Integer is\n+     (if L < R then L else R);\n+\n+   ---------\n+   -- Max --\n+   ---------\n+\n+   function Max (L, R : Big_Integer) return Big_Integer is\n+     (if L > R then L else R);\n+\n+   -----------------------------\n+   -- Greatest_Common_Divisor --\n+   -----------------------------\n+\n+   function Greatest_Common_Divisor (L, R : Big_Integer) return Big_Integer is\n+      procedure mpz_gcd\n+        (ROP : access mpz_t;  Op1, Op2 : access constant mpz_t);\n+      pragma Import (C, mpz_gcd, \"__gmpz_gcd\");\n+\n+      Result : Optional_Big_Integer;\n+\n+   begin\n+      Allocate (Result);\n+      mpz_gcd (Get_Mpz (Result), Get_Mpz (L), Get_Mpz (R));\n+      return Result;\n+   end Greatest_Common_Divisor;\n+\n+   --------------\n+   -- Allocate --\n+   --------------\n+\n+   procedure Allocate (This : in out Optional_Big_Integer) is\n+      procedure mpz_init (this : access mpz_t);\n+      pragma Import (C, mpz_init, \"__gmpz_init\");\n+   begin\n+      Set_Mpz (This, new mpz_t);\n+      mpz_init (Get_Mpz (This));\n+   end Allocate;\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (This : in out Controlled_Bignum) is\n+      Value : constant mpz_t_ptr := To_Mpz (This.C);\n+   begin\n+      if Value /= null then\n+         This.C := To_Address (new mpz_t);\n+         mpz_init_set (To_Mpz (This.C), Value);\n+      end if;\n+   end Adjust;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (This : in out Controlled_Bignum) is\n+      procedure Free is new Ada.Unchecked_Deallocation (mpz_t, mpz_t_ptr);\n+\n+      procedure mpz_clear (this : access mpz_t);\n+      pragma Import (C, mpz_clear, \"__gmpz_clear\");\n+\n+      Mpz : mpz_t_ptr;\n+\n+   begin\n+      if This.C /= System.Null_Address then\n+         Mpz := To_Mpz (This.C);\n+         mpz_clear (Mpz);\n+         Free (Mpz);\n+         This.C := System.Null_Address;\n+      end if;\n+   end Finalize;\n+\n+end Ada.Numerics.Big_Numbers.Big_Integers;"}, {"sha": "8cb0f63e7136cd47df9a14fa3e17cc602ff1416e", "filename": "gcc/ada/libgnat/a-nbnbre.adb", "status": "added", "additions": 547, "deletions": 0, "changes": 547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fa-nbnbre.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fa-nbnbre.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-nbnbre.adb?ref=f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "patch": "@@ -0,0 +1,547 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                   ADA.NUMERICS.BIG_NUMBERS.BIG_REALS                     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the default version of this package, based on Big_Integers only.\n+\n+with Ada.Characters.Conversions; use Ada.Characters.Conversions;\n+\n+package body Ada.Numerics.Big_Numbers.Big_Reals is\n+\n+   use Big_Integers;\n+\n+   procedure Normalize (Arg : in out Big_Real);\n+   --  Normalize Arg by ensuring that Arg.Den is always positive and that\n+   --  Arg.Num and Arg.Den always have a GCD of 1.\n+\n+   --------------\n+   -- Is_Valid --\n+   --------------\n+\n+   function Is_Valid (Arg : Optional_Big_Real) return Boolean is\n+     (Is_Valid (Arg.Num) and then Is_Valid (Arg.Den));\n+\n+   -----------------\n+   -- No_Big_Real --\n+   -----------------\n+\n+   function No_Big_Real return Optional_Big_Real is\n+     (Num => Invalid_Big_Integer, Den => Invalid_Big_Integer);\n+\n+   ---------\n+   -- \"/\" --\n+   ---------\n+\n+   function \"/\" (Num, Den : Big_Integer) return Big_Real is\n+      Result : Optional_Big_Real;\n+   begin\n+      if Den = To_Big_Integer (0) then\n+         raise Constraint_Error with \"divide by zero\";\n+      end if;\n+\n+      Result.Num := Num;\n+      Result.Den := Den;\n+      Normalize (Result);\n+      return Result;\n+   end \"/\";\n+\n+   ---------------\n+   -- Numerator --\n+   ---------------\n+\n+   function Numerator (Arg : Big_Real) return Big_Integer is (Arg.Num);\n+\n+   -----------------\n+   -- Denominator --\n+   -----------------\n+\n+   function Denominator (Arg : Big_Real) return Big_Positive is (Arg.Den);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (L, R : Big_Real) return Boolean is\n+     (abs L.Num = abs R.Num and then L.Den = R.Den);\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\" (L, R : Big_Real) return Boolean is\n+     (abs L.Num * R.Den < abs R.Num * L.Den);\n+\n+   ----------\n+   -- \"<=\" --\n+   ----------\n+\n+   function \"<=\" (L, R : Big_Real) return Boolean is (not (R < L));\n+\n+   ---------\n+   -- \">\" --\n+   ---------\n+\n+   function \">\" (L, R : Big_Real) return Boolean is (R < L);\n+\n+   ----------\n+   -- \">=\" --\n+   ----------\n+\n+   function \">=\" (L, R : Big_Real) return Boolean is (not (L < R));\n+\n+   -----------------------\n+   -- Float_Conversions --\n+   -----------------------\n+\n+   package body Float_Conversions is\n+\n+      -----------------\n+      -- To_Big_Real --\n+      -----------------\n+\n+      function To_Big_Real (Arg : Num) return Big_Real is\n+      begin\n+         return From_String (Arg'Image);\n+      end To_Big_Real;\n+\n+      -------------------\n+      -- From_Big_Real --\n+      -------------------\n+\n+      function From_Big_Real (Arg : Big_Real) return Num is\n+      begin\n+         return Num'Value (To_String (Arg));\n+      end From_Big_Real;\n+\n+   end Float_Conversions;\n+\n+   -----------------------\n+   -- Fixed_Conversions --\n+   -----------------------\n+\n+   package body Fixed_Conversions is\n+\n+      -----------------\n+      -- To_Big_Real --\n+      -----------------\n+\n+      function To_Big_Real (Arg : Num) return Big_Real is\n+      begin\n+         return From_String (Arg'Image);\n+      end To_Big_Real;\n+\n+      -------------------\n+      -- From_Big_Real --\n+      -------------------\n+\n+      function From_Big_Real (Arg : Big_Real) return Num is\n+      begin\n+         return Num'Value (To_String (Arg));\n+      end From_Big_Real;\n+\n+   end Fixed_Conversions;\n+\n+   ---------------\n+   -- To_String --\n+   ---------------\n+\n+   function To_String\n+     (Arg : Big_Real; Fore : Field := 2; Aft : Field := 3; Exp : Field := 0)\n+      return String\n+   is\n+      Zero : constant Big_Integer := To_Big_Integer (0);\n+      Ten  : constant Big_Integer := To_Big_Integer (10);\n+\n+      function Leading_Padding\n+        (Str        : String;\n+         Min_Length : Field;\n+         Char       : Character := ' ') return String;\n+      --  Return padding of Char concatenated with Str so that the resulting\n+      --  string is at least Min_Length long.\n+\n+      function Trailing_Padding\n+        (Str    : String;\n+         Length : Field;\n+         Char   : Character := '0') return String;\n+      --  Return Str with trailing Char removed, and if needed either\n+      --  truncated or concatenated with padding of Char so that the resulting\n+      --  string is Length long.\n+\n+      function Image (N : Natural) return String;\n+      --  Return image of N, with no leading space.\n+\n+      function Numerator_Image\n+        (Num   : Big_Integer;\n+         After : Natural) return String;\n+      --  Return image of Num as a float value with After digits after the \".\"\n+      --  and taking Fore, Aft, Exp into account.\n+\n+      -----------\n+      -- Image --\n+      -----------\n+\n+      function Image (N : Natural) return String is\n+         S : constant String := Natural'Image (N);\n+      begin\n+         return S (2 .. S'Last);\n+      end Image;\n+\n+      ---------------------\n+      -- Leading_Padding --\n+      ---------------------\n+\n+      function Leading_Padding\n+        (Str        : String;\n+         Min_Length : Field;\n+         Char       : Character := ' ') return String is\n+      begin\n+         if Str = \"\" then\n+            return Leading_Padding (\"0\", Min_Length, Char);\n+         else\n+            return (1 .. Integer'Max (Integer (Min_Length) - Str'Length, 0)\n+                           => Char) & Str;\n+         end if;\n+      end Leading_Padding;\n+\n+      ----------------------\n+      -- Trailing_Padding --\n+      ----------------------\n+\n+      function Trailing_Padding\n+        (Str    : String;\n+         Length : Field;\n+         Char   : Character := '0') return String is\n+      begin\n+         if Str'Length > 0 and then Str (Str'Last) = Char then\n+            for J in reverse Str'Range loop\n+               if Str (J) /= '0' then\n+                  return Trailing_Padding\n+                    (Str (Str'First .. J), Length, Char);\n+               end if;\n+            end loop;\n+         end if;\n+\n+         if Str'Length >= Length then\n+            return Str (Str'First .. Str'First + Length - 1);\n+         else\n+            return Str &\n+              (1 .. Integer'Max (Integer (Length) - Str'Length, 0)\n+                      => Char);\n+         end if;\n+      end Trailing_Padding;\n+\n+      ---------------------\n+      -- Numerator_Image --\n+      ---------------------\n+\n+      function Numerator_Image\n+        (Num   : Big_Integer;\n+         After : Natural) return String\n+      is\n+         Tmp   : constant String := To_String (Num);\n+         Str   : constant String (1 .. Tmp'Last - 1) := Tmp (2 .. Tmp'Last);\n+         Index : Integer;\n+\n+      begin\n+         if After = 0 then\n+            return Leading_Padding (Str, Fore) & \".\"\n+                   & Trailing_Padding (\"0\", Aft);\n+         else\n+            Index := Str'Last - After;\n+\n+            if Index < 0 then\n+               return Leading_Padding (\"0\", Fore)\n+                 & \".\"\n+                 & Trailing_Padding ((1 .. -Index => '0') & Str, Aft)\n+                 & (if Exp = 0 then \"\" else \"E+\" & Image (Natural (Exp)));\n+            else\n+               return Leading_Padding (Str (Str'First .. Index), Fore)\n+                 & \".\"\n+                 & Trailing_Padding (Str (Index + 1 .. Str'Last), Aft)\n+                 & (if Exp = 0 then \"\" else \"E+\" & Image (Natural (Exp)));\n+            end if;\n+         end if;\n+      end Numerator_Image;\n+\n+   begin\n+      if Arg.Num < Zero then\n+         declare\n+            Str : String := To_String (-Arg, Fore, Aft, Exp);\n+         begin\n+            if Str (1) = ' ' then\n+               for J in 1 .. Str'Last - 1 loop\n+                  if Str (J + 1) /= ' ' then\n+                     Str (J) := '-';\n+                     exit;\n+                  end if;\n+               end loop;\n+\n+               return Str;\n+            else\n+               return '-' & Str;\n+            end if;\n+         end;\n+      else\n+         --  Compute Num * 10^Aft so that we get Aft significant digits\n+         --  in the integer part (rounded) to display.\n+\n+         return Numerator_Image\n+           ((Arg.Num * Ten ** Aft) / Arg.Den, After => Exp + Aft);\n+      end if;\n+   end To_String;\n+\n+   -----------------\n+   -- From_String --\n+   -----------------\n+\n+   function From_String (Arg : String) return Big_Real is\n+      Ten   : constant Big_Integer := To_Big_Integer (10);\n+      Frac  : Optional_Big_Integer;\n+      Exp   : Integer := 0;\n+      Pow   : Natural := 0;\n+      Index : Natural := 0;\n+      Last  : Natural := Arg'Last;\n+\n+   begin\n+      for J in reverse Arg'Range loop\n+         if Arg (J) in 'e' | 'E' then\n+            if Last /= Arg'Last then\n+               raise Constraint_Error with \"multiple exponents specified\";\n+            end if;\n+\n+            Last := J - 1;\n+            Exp := Integer'Value (Arg (J + 1 .. Arg'Last));\n+            Pow := 0;\n+\n+         elsif Arg (J) = '.' then\n+            Index := J - 1;\n+            exit;\n+         else\n+            Pow := Pow + 1;\n+         end if;\n+      end loop;\n+\n+      if Index = 0 then\n+         raise Constraint_Error with \"invalid real value\";\n+      end if;\n+\n+      declare\n+         Result : Optional_Big_Real;\n+      begin\n+         Result.Den := Ten ** Pow;\n+         Result.Num := From_String (Arg (Arg'First .. Index)) * Result.Den;\n+         Frac := From_String (Arg (Index + 2 .. Last));\n+\n+         if Result.Num < To_Big_Integer (0) then\n+            Result.Num := Result.Num - Frac;\n+         else\n+            Result.Num := Result.Num + Frac;\n+         end if;\n+\n+         if Exp > 0 then\n+            Result.Num := Result.Num * Ten ** Exp;\n+         elsif Exp < 0 then\n+            Result.Den := Result.Den * Ten ** (-Exp);\n+         end if;\n+\n+         Normalize (Result);\n+         return Result;\n+      end;\n+   end From_String;\n+\n+   --------------------------\n+   -- From_Quotient_String --\n+   --------------------------\n+\n+   function From_Quotient_String (Arg : String) return Big_Real is\n+      Index : Natural := 0;\n+   begin\n+      for J in Arg'First + 1 .. Arg'Last - 1 loop\n+         if Arg (J) = '/' then\n+            Index := J;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      if Index = 0 then\n+         raise Constraint_Error with \"no quotient found\";\n+      end if;\n+\n+      return Big_Integers.From_String (Arg (Arg'First .. Index - 1)) /\n+        Big_Integers.From_String (Arg (Index + 1 .. Arg'Last));\n+   end From_Quotient_String;\n+\n+   ---------------\n+   -- Put_Image --\n+   ---------------\n+\n+   procedure Put_Image\n+     (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n+      Arg    : Big_Real) is\n+   begin\n+      Wide_Wide_String'Write (Stream, To_Wide_Wide_String (To_String (Arg)));\n+   end Put_Image;\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   function \"+\" (L : Big_Real) return Big_Real is\n+      Result : Optional_Big_Real;\n+   begin\n+      Result.Num := L.Num;\n+      Result.Den := L.Den;\n+      return Result;\n+   end \"+\";\n+\n+   ---------\n+   -- \"-\" --\n+   ---------\n+\n+   function \"-\" (L : Big_Real) return Big_Real is\n+     (Num => -L.Num, Den => L.Den);\n+\n+   -----------\n+   -- \"abs\" --\n+   -----------\n+\n+   function \"abs\" (L : Big_Real) return Big_Real is\n+     (Num => abs L.Num, Den => L.Den);\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   function \"+\" (L, R : Big_Real) return Big_Real is\n+      Result : Optional_Big_Real;\n+   begin\n+      Result.Num := L.Num * R.Den + R.Num * L.Den;\n+      Result.Den := L.Den * R.Den;\n+      Normalize (Result);\n+      return Result;\n+   end \"+\";\n+\n+   ---------\n+   -- \"-\" --\n+   ---------\n+\n+   function \"-\" (L, R : Big_Real) return Big_Real is\n+      Result : Optional_Big_Real;\n+   begin\n+      Result.Num := L.Num * R.Den - R.Num * L.Den;\n+      Result.Den := L.Den * R.Den;\n+      Normalize (Result);\n+      return Result;\n+   end \"-\";\n+\n+   ---------\n+   -- \"*\" --\n+   ---------\n+\n+   function \"*\" (L, R : Big_Real) return Big_Real is\n+      Result : Optional_Big_Real;\n+   begin\n+      Result.Num := L.Num * R.Num;\n+      Result.Den := L.Den * R.Den;\n+      Normalize (Result);\n+      return Result;\n+   end \"*\";\n+\n+   ---------\n+   -- \"/\" --\n+   ---------\n+\n+   function \"/\" (L, R : Big_Real) return Big_Real is\n+      Result : Optional_Big_Real;\n+   begin\n+      Result.Num := L.Num * R.Den;\n+      Result.Den := L.Den * R.Num;\n+      Normalize (Result);\n+      return Result;\n+   end \"/\";\n+\n+   ----------\n+   -- \"**\" --\n+   ----------\n+\n+   function \"**\" (L : Big_Real; R : Integer) return Big_Real is\n+      Result : Optional_Big_Real;\n+   begin\n+      if R = 0 then\n+         Result.Num := To_Big_Integer (1);\n+         Result.Den := To_Big_Integer (1);\n+      else\n+         if R < 0 then\n+            Result.Num := L.Den ** (-R);\n+            Result.Den := L.Num ** (-R);\n+         else\n+            Result.Num := L.Num ** R;\n+            Result.Den := L.Den ** R;\n+         end if;\n+\n+         Normalize (Result);\n+      end if;\n+\n+      return Result;\n+   end \"**\";\n+\n+   ---------\n+   -- Min --\n+   ---------\n+\n+   function Min (L, R : Big_Real) return Big_Real is (if L < R then L else R);\n+\n+   ---------\n+   -- Max --\n+   ---------\n+\n+   function Max (L, R : Big_Real) return Big_Real is (if L > R then L else R);\n+\n+   ---------------\n+   -- Normalize --\n+   ---------------\n+\n+   procedure Normalize (Arg : in out Big_Real) is\n+   begin\n+      if Arg.Den < To_Big_Integer (0) then\n+         Arg.Num := -Arg.Num;\n+         Arg.Den := -Arg.Den;\n+      end if;\n+\n+      declare\n+         GCD : constant Big_Integer :=\n+           Greatest_Common_Divisor (Arg.Num, Arg.Den);\n+      begin\n+         Arg.Num := Arg.Num / GCD;\n+         Arg.Den := Arg.Den / GCD;\n+      end;\n+   end Normalize;\n+\n+end Ada.Numerics.Big_Numbers.Big_Reals;"}, {"sha": "07e9173fd7869cd0f07d39c91ce84aa06c3952bc", "filename": "gcc/ada/libgnat/a-nbnbre.ads", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fa-nbnbre.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fa-nbnbre.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-nbnbre.ads?ref=f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "patch": "@@ -0,0 +1,146 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                   ADA.NUMERICS.BIG_NUMBERS.BIG_REALS                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Big_Numbers.Big_Integers;\n+with Ada.Streams;\n+\n+--  Note that some Ada 2020 aspects are commented out since they are not\n+--  supported yet.\n+\n+package Ada.Numerics.Big_Numbers.Big_Reals\n+  with Preelaborate\n+--  Nonblocking, Global => in out synchronized Big_Reals\n+is\n+   type Optional_Big_Real is private with\n+     Default_Initial_Condition => not Is_Valid (Optional_Big_Real);\n+--   Real_Literal => From_String,\n+--   Put_Image => Put_Image;\n+\n+   function Is_Valid (Arg : Optional_Big_Real) return Boolean;\n+\n+   function No_Big_Real return Optional_Big_Real\n+     with Post => not Is_Valid (No_Big_Real'Result);\n+\n+   subtype Big_Real is Optional_Big_Real\n+     with Dynamic_Predicate => Is_Valid (Big_Real),\n+          Predicate_Failure => (raise Constraint_Error);\n+\n+   function \"/\" (Num, Den : Big_Integers.Big_Integer) return Big_Real;\n+--   with Pre => (if Big_Integers.\"=\" (Den, Big_Integers.To_Big_Integer (0))\n+--                then raise Constraint_Error);\n+\n+   function Numerator (Arg : Big_Real) return Big_Integers.Big_Integer;\n+\n+   function Denominator (Arg : Big_Real) return Big_Integers.Big_Positive\n+     with Post =>\n+       (Arg = To_Real (0)) or else\n+       (Big_Integers.\"=\"\n+         (Big_Integers.Greatest_Common_Divisor\n+           (Numerator (Arg), Denominator'Result),\n+          Big_Integers.To_Big_Integer (1)));\n+\n+   function To_Big_Real\n+     (Arg : Big_Integers.Big_Integer)\n+     return Big_Real is (Arg / Big_Integers.To_Big_Integer (1));\n+\n+   function To_Real (Arg : Integer) return Big_Real is\n+     (Big_Integers.To_Big_Integer (Arg) / Big_Integers.To_Big_Integer (1));\n+\n+   function \"=\" (L, R : Big_Real) return Boolean;\n+\n+   function \"<\" (L, R : Big_Real) return Boolean;\n+\n+   function \"<=\" (L, R : Big_Real) return Boolean;\n+\n+   function \">\" (L, R : Big_Real) return Boolean;\n+\n+   function \">=\" (L, R : Big_Real) return Boolean;\n+\n+   function In_Range (Arg, Low, High : Big_Real) return Boolean is\n+     (Low <= Arg and then Arg <= High);\n+\n+   generic\n+      type Num is digits <>;\n+   package Float_Conversions is\n+\n+      function To_Big_Real (Arg : Num) return Big_Real;\n+\n+      function From_Big_Real (Arg : Big_Real) return Num\n+        with Pre => In_Range (Arg,\n+                              Low  => To_Big_Real (Num'First),\n+                              High => To_Big_Real (Num'Last))\n+                    or else (raise Constraint_Error);\n+\n+   end Float_Conversions;\n+\n+   generic\n+      type Num is delta <>;\n+   package Fixed_Conversions is\n+\n+      function To_Big_Real (Arg : Num) return Big_Real;\n+\n+      function From_Big_Real (Arg : Big_Real) return Num\n+        with Pre => In_Range (Arg,\n+                              Low  => To_Big_Real (Num'First),\n+                              High => To_Big_Real (Num'Last))\n+                    or else (raise Constraint_Error);\n+\n+   end Fixed_Conversions;\n+\n+   function To_String (Arg  : Big_Real;\n+                       Fore : Field := 2;\n+                       Aft  : Field := 3;\n+                       Exp  : Field := 0) return String\n+      with Post => To_String'Result'First = 1;\n+\n+   function From_String (Arg : String) return Big_Real;\n+\n+   function To_Quotient_String (Arg : Big_Real) return String is\n+     (Big_Integers.To_String (Numerator (Arg)) & \" / \"\n+      & Big_Integers.To_String (Denominator (Arg)));\n+\n+   function From_Quotient_String (Arg : String) return Big_Real;\n+\n+   procedure Put_Image\n+     (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n+      Arg    : Big_Real);\n+\n+   function \"+\" (L : Big_Real) return Big_Real;\n+\n+   function \"-\" (L : Big_Real) return Big_Real;\n+\n+   function \"abs\" (L : Big_Real) return Big_Real;\n+\n+   function \"+\" (L, R : Big_Real) return Big_Real;\n+\n+   function \"-\" (L, R : Big_Real) return Big_Real;\n+\n+   function \"*\" (L, R : Big_Real) return Big_Real;\n+\n+   function \"/\" (L, R : Big_Real) return Big_Real;\n+\n+   function \"**\" (L : Big_Real; R : Integer) return Big_Real;\n+\n+   function Min (L, R : Big_Real) return Big_Real;\n+\n+   function Max (L, R : Big_Real) return Big_Real;\n+\n+private\n+\n+   type Optional_Big_Real is record\n+      Num, Den : Big_Integers.Optional_Big_Integer;\n+   end record;\n+\n+end Ada.Numerics.Big_Numbers.Big_Reals;"}, {"sha": "a25e39c75fe6be0644bd60b57ecafb0da11084a2", "filename": "gcc/ada/libgnat/a-nubinu.ads", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fa-nubinu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fa-nubinu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-nubinu.ads?ref=f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "patch": "@@ -0,0 +1,25 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                         A D A . N U M E R I C S                          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Note that some Ada 2020 aspects are commented out since they are not\n+--  supported yet.\n+\n+package Ada.Numerics.Big_Numbers\n+  --  with Pure, Nonblocking, Global => null\n+  with Pure\n+is\n+   subtype Field is Integer range 0 .. 255;\n+   subtype Number_Base is Integer range 2 .. 16;\n+end Ada.Numerics.Big_Numbers;"}, {"sha": "bde6c1ff3e0c89eef8c4f1896d9ddc2614240838", "filename": "gcc/ada/libgnat/s-bignum.adb", "status": "modified", "additions": 44, "deletions": 1053, "changes": 1097, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fs-bignum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fs-bignum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-bignum.adb?ref=f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "patch": "@@ -29,1077 +29,68 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package provides arbitrary precision signed integer arithmetic for\n---  use in computing intermediate values in expressions for the case where\n---  pragma Overflow_Check (Eliminate) is in effect.\n-\n-with System;                  use System;\n-with System.Secondary_Stack;  use System.Secondary_Stack;\n-with System.Storage_Elements; use System.Storage_Elements;\n+with System.Generic_Bignums;\n+with Ada.Unchecked_Conversion;\n \n package body System.Bignums is\n \n-   use Interfaces;\n-   --  So that operations on Unsigned_32 are available\n-\n-   type DD is mod Base ** 2;\n-   --  Double length digit used for intermediate computations\n-\n-   function MSD (X : DD) return SD is (SD (X / Base));\n-   function LSD (X : DD) return SD is (SD (X mod Base));\n-   --  Most significant and least significant digit of double digit value\n-\n-   function \"&\" (X, Y : SD) return DD is (DD (X) * Base + DD (Y));\n-   --  Compose double digit value from two single digit values\n-\n-   subtype LLI is Long_Long_Integer;\n-\n-   One_Data : constant Digit_Vector (1 .. 1) := (1 => 1);\n-   --  Constant one\n-\n-   Zero_Data : constant Digit_Vector (1 .. 0) := (1 .. 0 => 0);\n-   --  Constant zero\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   function Add\n-     (X, Y  : Digit_Vector;\n-      X_Neg : Boolean;\n-      Y_Neg : Boolean) return Bignum\n-   with\n-     Pre => X'First = 1 and then Y'First = 1;\n-   --  This procedure adds two signed numbers returning the Sum, it is used\n-   --  for both addition and subtraction. The value computed is X + Y, with\n-   --  X_Neg and Y_Neg giving the signs of the operands.\n-\n-   function Allocate_Bignum (Len : Length) return Bignum with\n-     Post => Allocate_Bignum'Result.Len = Len;\n-   --  Allocate Bignum value of indicated length on secondary stack. On return\n-   --  the Neg and D fields are left uninitialized.\n-\n-   type Compare_Result is (LT, EQ, GT);\n-   --  Indicates result of comparison in following call\n-\n-   function Compare\n-     (X, Y         : Digit_Vector;\n-      X_Neg, Y_Neg : Boolean) return Compare_Result\n-   with\n-     Pre => X'First = 1 and then Y'First = 1;\n-   --  Compare (X with sign X_Neg) with (Y with sign Y_Neg), and return the\n-   --  result of the signed comparison.\n-\n-   procedure Div_Rem\n-     (X, Y              : Bignum;\n-      Quotient          : out Bignum;\n-      Remainder         : out Bignum;\n-      Discard_Quotient  : Boolean := False;\n-      Discard_Remainder : Boolean := False);\n-   --  Returns the Quotient and Remainder from dividing abs (X) by abs (Y). The\n-   --  values of X and Y are not modified. If Discard_Quotient is True, then\n-   --  Quotient is undefined on return, and if Discard_Remainder is True, then\n-   --  Remainder is undefined on return. Service routine for Big_Div/Rem/Mod.\n-\n-   procedure Free_Bignum (X : Bignum) is null;\n-   --  Called to free a Bignum value used in intermediate computations. In\n-   --  this implementation using the secondary stack, it does nothing at all,\n-   --  because we rely on Mark/Release, but it may be of use for some\n-   --  alternative implementation.\n-\n-   function Normalize\n-     (X   : Digit_Vector;\n-      Neg : Boolean := False) return Bignum;\n-   --  Given a digit vector and sign, allocate and construct a Bignum value.\n-   --  Note that X may have leading zeroes which must be removed, and if the\n-   --  result is zero, the sign is forced positive.\n-\n-   ---------\n-   -- Add --\n-   ---------\n-\n-   function Add\n-     (X, Y  : Digit_Vector;\n-      X_Neg : Boolean;\n-      Y_Neg : Boolean) return Bignum\n-   is\n-   begin\n-      --  If signs are the same, we are doing an addition, it is convenient to\n-      --  ensure that the first operand is the longer of the two.\n-\n-      if X_Neg = Y_Neg then\n-         if X'Last < Y'Last then\n-            return Add (X => Y, Y => X, X_Neg => Y_Neg, Y_Neg => X_Neg);\n-\n-         --  Here signs are the same, and the first operand is the longer\n-\n-         else\n-            pragma Assert (X_Neg = Y_Neg and then X'Last >= Y'Last);\n-\n-            --  Do addition, putting result in Sum (allowing for carry)\n-\n-            declare\n-               Sum : Digit_Vector (0 .. X'Last);\n-               RD  : DD;\n-\n-            begin\n-               RD := 0;\n-               for J in reverse 1 .. X'Last loop\n-                  RD := RD + DD (X (J));\n-\n-                  if J >= 1 + (X'Last - Y'Last) then\n-                     RD := RD + DD (Y (J - (X'Last - Y'Last)));\n-                  end if;\n-\n-                  Sum (J) := LSD (RD);\n-                  RD := RD / Base;\n-               end loop;\n-\n-               Sum (0) := SD (RD);\n-               return Normalize (Sum, X_Neg);\n-            end;\n-         end if;\n-\n-      --  Signs are different so really this is a subtraction, we want to make\n-      --  sure that the largest magnitude operand is the first one, and then\n-      --  the result will have the sign of the first operand.\n-\n-      else\n-         declare\n-            CR : constant Compare_Result := Compare (X, Y, False, False);\n-\n-         begin\n-            if CR = EQ then\n-               return Normalize (Zero_Data);\n-\n-            elsif CR = LT then\n-               return Add (X => Y, Y => X, X_Neg => Y_Neg, Y_Neg => X_Neg);\n-\n-            else\n-               pragma Assert (X_Neg /= Y_Neg and then CR = GT);\n-\n-               --  Do subtraction, putting result in Diff\n-\n-               declare\n-                  Diff : Digit_Vector (1 .. X'Length);\n-                  RD   : DD;\n-\n-               begin\n-                  RD := 0;\n-                  for J in reverse 1 .. X'Last loop\n-                     RD := RD + DD (X (J));\n-\n-                     if J >= 1 + (X'Last - Y'Last) then\n-                        RD := RD - DD (Y (J - (X'Last - Y'Last)));\n-                     end if;\n-\n-                     Diff (J) := LSD (RD);\n-                     RD := (if RD < Base then 0 else -1);\n-                  end loop;\n-\n-                  return Normalize (Diff, X_Neg);\n-               end;\n-            end if;\n-         end;\n-      end if;\n-   end Add;\n-\n-   ---------------------\n-   -- Allocate_Bignum --\n-   ---------------------\n-\n-   function Allocate_Bignum (Len : Length) return Bignum is\n-      Addr : Address;\n-\n-   begin\n-      --  Change the if False here to if True to get allocation on the heap\n-      --  instead of the secondary stack, which is convenient for debugging\n-      --  System.Bignum itself.\n-\n-      if False then\n-         declare\n-            B : Bignum;\n-         begin\n-            B := new Bignum_Data'(Len, False, (others => 0));\n-            return B;\n-         end;\n-\n-      --  Normal case of allocation on the secondary stack\n-\n-      else\n-         --  Note: The approach used here is designed to avoid strict aliasing\n-         --  warnings that appeared previously using unchecked conversion.\n-\n-         SS_Allocate (Addr, Storage_Offset (4 + 4 * Len));\n-\n-         declare\n-            B : Bignum;\n-            for B'Address use Addr'Address;\n-            pragma Import (Ada, B);\n-\n-            BD : Bignum_Data (Len);\n-            for BD'Address use Addr;\n-            pragma Import (Ada, BD);\n-\n-            --  Expose a writable view of discriminant BD.Len so that we can\n-            --  initialize it. We need to use the exact layout of the record\n-            --  to ensure that the Length field has 24 bits as expected.\n-\n-            type Bignum_Data_Header is record\n-               Len : Length;\n-               Neg : Boolean;\n-            end record;\n-\n-            for Bignum_Data_Header use record\n-               Len at 0 range 0 .. 23;\n-               Neg at 3 range 0 .. 7;\n-            end record;\n-\n-            BDH : Bignum_Data_Header;\n-            for BDH'Address use BD'Address;\n-            pragma Import (Ada, BDH);\n-\n-            pragma Assert (BDH.Len'Size = BD.Len'Size);\n-\n-         begin\n-            BDH.Len := Len;\n-            return B;\n-         end;\n-      end if;\n-   end Allocate_Bignum;\n-\n-   -------------\n-   -- Big_Abs --\n-   -------------\n-\n-   function Big_Abs (X : Bignum) return Bignum is\n-   begin\n-      return Normalize (X.D);\n-   end Big_Abs;\n-\n-   -------------\n-   -- Big_Add --\n-   -------------\n-\n-   function Big_Add  (X, Y : Bignum) return Bignum is\n-   begin\n-      return Add (X.D, Y.D, X.Neg, Y.Neg);\n-   end Big_Add;\n-\n-   -------------\n-   -- Big_Div --\n-   -------------\n-\n-   --  This table is excerpted from RM 4.5.5(28-30) and shows how the result\n-   --  varies with the signs of the operands.\n-\n-   --   A      B   A/B      A     B    A/B\n-   --\n-   --   10     5    2      -10    5    -2\n-   --   11     5    2      -11    5    -2\n-   --   12     5    2      -12    5    -2\n-   --   13     5    2      -13    5    -2\n-   --   14     5    2      -14    5    -2\n-   --\n-   --   A      B   A/B      A     B    A/B\n-   --\n-   --   10    -5   -2      -10   -5     2\n-   --   11    -5   -2      -11   -5     2\n-   --   12    -5   -2      -12   -5     2\n-   --   13    -5   -2      -13   -5     2\n-   --   14    -5   -2      -14   -5     2\n-\n-   function Big_Div  (X, Y : Bignum) return Bignum is\n-      Q, R : Bignum;\n-   begin\n-      Div_Rem (X, Y, Q, R, Discard_Remainder => True);\n-      Q.Neg := Q.Len > 0 and then (X.Neg xor Y.Neg);\n-      return Q;\n-   end Big_Div;\n-\n-   -------------\n-   -- Big_Exp --\n-   -------------\n-\n-   function Big_Exp  (X, Y : Bignum) return Bignum is\n+   package Sec_Stack_Bignums is new\n+     System.Generic_Bignums (Use_Secondary_Stack => True);\n+   use Sec_Stack_Bignums;\n \n-      function \"**\" (X : Bignum; Y : SD) return Bignum;\n-      --  Internal routine where we know right operand is one word\n+   function \"+\" is new Ada.Unchecked_Conversion\n+     (Bignum, Sec_Stack_Bignums.Bignum);\n \n-      ----------\n-      -- \"**\" --\n-      ----------\n+   function \"-\" is new Ada.Unchecked_Conversion\n+     (Sec_Stack_Bignums.Bignum, Bignum);\n \n-      function \"**\" (X : Bignum; Y : SD) return Bignum is\n-      begin\n-         case Y is\n+   function Big_Add (X, Y : Bignum) return Bignum is\n+     (-Sec_Stack_Bignums.Big_Add (+X, +Y));\n \n-            --  X ** 0 is 1\n-\n-            when 0 =>\n-               return Normalize (One_Data);\n-\n-            --  X ** 1 is X\n-\n-            when 1 =>\n-               return Normalize (X.D);\n-\n-            --  X ** 2 is X * X\n-\n-            when 2 =>\n-               return Big_Mul (X, X);\n-\n-            --  For X greater than 2, use the recursion\n-\n-            --  X even, X ** Y = (X ** (Y/2)) ** 2;\n-            --  X odd,  X ** Y = (X ** (Y/2)) ** 2 * X;\n-\n-            when others =>\n-               declare\n-                  XY2  : constant Bignum := X ** (Y / 2);\n-                  XY2S : constant Bignum := Big_Mul (XY2, XY2);\n-                  Res  : Bignum;\n-\n-               begin\n-                  Free_Bignum (XY2);\n-\n-                  --  Raise storage error if intermediate value is getting too\n-                  --  large, which we arbitrarily define as 200 words for now.\n-\n-                  if XY2S.Len > 200 then\n-                     Free_Bignum (XY2S);\n-                     raise Storage_Error with\n-                       \"exponentiation result is too large\";\n-                  end if;\n-\n-                  --  Otherwise take care of even/odd cases\n-\n-                  if (Y and 1) = 0 then\n-                     return XY2S;\n-\n-                  else\n-                     Res := Big_Mul (XY2S, X);\n-                     Free_Bignum (XY2S);\n-                     return Res;\n-                  end if;\n-               end;\n-         end case;\n-      end \"**\";\n-\n-   --  Start of processing for Big_Exp\n-\n-   begin\n-      --  Error if right operand negative\n-\n-      if Y.Neg then\n-         raise Constraint_Error with \"exponentiation to negative power\";\n-\n-      --  X ** 0 is always 1 (including 0 ** 0, so do this test first)\n-\n-      elsif Y.Len = 0 then\n-         return Normalize (One_Data);\n-\n-      --  0 ** X is always 0 (for X non-zero)\n-\n-      elsif X.Len = 0 then\n-         return Normalize (Zero_Data);\n-\n-      --  (+1) ** Y = 1\n-      --  (-1) ** Y = +/-1 depending on whether Y is even or odd\n-\n-      elsif X.Len = 1 and then X.D (1) = 1 then\n-         return Normalize\n-           (X.D, Neg => X.Neg and then ((Y.D (Y.Len) and 1) = 1));\n-\n-      --  If the absolute value of the base is greater than 1, then the\n-      --  exponent must not be bigger than one word, otherwise the result\n-      --  is ludicrously large, and we just signal Storage_Error right away.\n-\n-      elsif Y.Len > 1 then\n-         raise Storage_Error with \"exponentiation result is too large\";\n-\n-      --  Special case (+/-)2 ** K, where K is 1 .. 31 using a shift\n-\n-      elsif X.Len = 1 and then X.D (1) = 2 and then Y.D (1) < 32 then\n-         declare\n-            D : constant Digit_Vector (1 .. 1) :=\n-                  (1 => Shift_Left (SD'(1), Natural (Y.D (1))));\n-         begin\n-            return Normalize (D, X.Neg);\n-         end;\n-\n-      --  Remaining cases have right operand of one word\n-\n-      else\n-         return X ** Y.D (1);\n-      end if;\n-   end Big_Exp;\n-\n-   ------------\n-   -- Big_EQ --\n-   ------------\n-\n-   function Big_EQ (X, Y : Bignum) return Boolean is\n-   begin\n-      return Compare (X.D, Y.D, X.Neg, Y.Neg) = EQ;\n-   end Big_EQ;\n-\n-   ------------\n-   -- Big_GE --\n-   ------------\n-\n-   function Big_GE (X, Y : Bignum) return Boolean is\n-   begin\n-      return Compare (X.D, Y.D, X.Neg, Y.Neg) /= LT;\n-   end Big_GE;\n-\n-   ------------\n-   -- Big_GT --\n-   ------------\n-\n-   function Big_GT (X, Y : Bignum) return Boolean is\n-   begin\n-      return Compare (X.D, Y.D, X.Neg, Y.Neg) = GT;\n-   end Big_GT;\n-\n-   ------------\n-   -- Big_LE --\n-   ------------\n-\n-   function Big_LE (X, Y : Bignum) return Boolean is\n-   begin\n-      return Compare (X.D, Y.D, X.Neg, Y.Neg) /= GT;\n-   end Big_LE;\n-\n-   ------------\n-   -- Big_LT --\n-   ------------\n-\n-   function Big_LT (X, Y : Bignum) return Boolean is\n-   begin\n-      return Compare (X.D, Y.D, X.Neg, Y.Neg) = LT;\n-   end Big_LT;\n-\n-   -------------\n-   -- Big_Mod --\n-   -------------\n-\n-   --  This table is excerpted from RM 4.5.5(28-30) and shows how the result\n-   --  of Rem and Mod vary with the signs of the operands.\n-\n-   --   A      B    A mod B  A rem B     A     B    A mod B  A rem B\n-\n-   --   10     5       0        0       -10    5       0        0\n-   --   11     5       1        1       -11    5       4       -1\n-   --   12     5       2        2       -12    5       3       -2\n-   --   13     5       3        3       -13    5       2       -3\n-   --   14     5       4        4       -14    5       1       -4\n-\n-   --   A      B    A mod B  A rem B     A     B    A mod B  A rem B\n-\n-   --   10    -5       0        0       -10   -5       0        0\n-   --   11    -5      -4        1       -11   -5      -1       -1\n-   --   12    -5      -3        2       -12   -5      -2       -2\n-   --   13    -5      -2        3       -13   -5      -3       -3\n-   --   14    -5      -1        4       -14   -5      -4       -4\n-\n-   function Big_Mod (X, Y : Bignum) return Bignum is\n-      Q, R : Bignum;\n-\n-   begin\n-      --  If signs are same, result is same as Rem\n-\n-      if X.Neg = Y.Neg then\n-         return Big_Rem (X, Y);\n-\n-      --  Case where Mod is different\n-\n-      else\n-         --  Do division\n-\n-         Div_Rem (X, Y, Q, R, Discard_Quotient => True);\n-\n-         --  Zero result is unchanged\n-\n-         if R.Len = 0 then\n-            return R;\n-\n-         --  Otherwise adjust result\n-\n-         else\n-            declare\n-               T1 : constant Bignum := Big_Sub (Y, R);\n-            begin\n-               T1.Neg := Y.Neg;\n-               Free_Bignum (R);\n-               return T1;\n-            end;\n-         end if;\n-      end if;\n-   end Big_Mod;\n-\n-   -------------\n-   -- Big_Mul --\n-   -------------\n+   function Big_Sub (X, Y : Bignum) return Bignum is\n+     (-Sec_Stack_Bignums.Big_Sub (+X, +Y));\n \n    function Big_Mul (X, Y : Bignum) return Bignum is\n-      Result : Digit_Vector (1 .. X.Len + Y.Len) := (others => 0);\n-      --  Accumulate result (max length of result is sum of operand lengths)\n-\n-      L : Length;\n-      --  Current result digit\n-\n-      D : DD;\n-      --  Result digit\n-\n-   begin\n-      for J in 1 .. X.Len loop\n-         for K in 1 .. Y.Len loop\n-            L := Result'Last - (X.Len - J) - (Y.Len - K);\n-            D := DD (X.D (J)) * DD (Y.D (K)) + DD (Result (L));\n-            Result (L) := LSD (D);\n-            D := D / Base;\n-\n-            --  D is carry which must be propagated\n+     (-Sec_Stack_Bignums.Big_Mul (+X, +Y));\n \n-            while D /= 0 and then L >= 1 loop\n-               L := L - 1;\n-               D := D + DD (Result (L));\n-               Result (L) := LSD (D);\n-               D := D / Base;\n-            end loop;\n+   function Big_Div (X, Y : Bignum) return Bignum is\n+     (-Sec_Stack_Bignums.Big_Div (+X, +Y));\n \n-            --  Must not have a carry trying to extend max length\n+   function Big_Exp (X, Y : Bignum) return Bignum is\n+     (-Sec_Stack_Bignums.Big_Exp (+X, +Y));\n \n-            pragma Assert (D = 0);\n-         end loop;\n-      end loop;\n-\n-      --  Return result\n-\n-      return Normalize (Result, X.Neg xor Y.Neg);\n-   end Big_Mul;\n-\n-   ------------\n-   -- Big_NE --\n-   ------------\n-\n-   function Big_NE (X, Y : Bignum) return Boolean is\n-   begin\n-      return Compare (X.D, Y.D, X.Neg, Y.Neg) /= EQ;\n-   end Big_NE;\n-\n-   -------------\n-   -- Big_Neg --\n-   -------------\n-\n-   function Big_Neg (X : Bignum) return Bignum is\n-   begin\n-      return Normalize (X.D, not X.Neg);\n-   end Big_Neg;\n-\n-   -------------\n-   -- Big_Rem --\n-   -------------\n-\n-   --  This table is excerpted from RM 4.5.5(28-30) and shows how the result\n-   --  varies with the signs of the operands.\n-\n-   --   A      B   A rem B   A     B   A rem B\n-\n-   --   10     5      0     -10    5      0\n-   --   11     5      1     -11    5     -1\n-   --   12     5      2     -12    5     -2\n-   --   13     5      3     -13    5     -3\n-   --   14     5      4     -14    5     -4\n-\n-   --   A      B  A rem B    A     B   A rem B\n-\n-   --   10    -5     0      -10   -5      0\n-   --   11    -5     1      -11   -5     -1\n-   --   12    -5     2      -12   -5     -2\n-   --   13    -5     3      -13   -5     -3\n-   --   14    -5     4      -14   -5     -4\n+   function Big_Mod (X, Y : Bignum) return Bignum is\n+     (-Sec_Stack_Bignums.Big_Mod (+X, +Y));\n \n    function Big_Rem (X, Y : Bignum) return Bignum is\n-      Q, R : Bignum;\n-   begin\n-      Div_Rem (X, Y, Q, R, Discard_Quotient => True);\n-      R.Neg := R.Len > 0 and then X.Neg;\n-      return R;\n-   end Big_Rem;\n-\n-   -------------\n-   -- Big_Sub --\n-   -------------\n-\n-   function Big_Sub (X, Y : Bignum) return Bignum is\n-   begin\n-      --  If right operand zero, return left operand (avoiding sharing)\n-\n-      if Y.Len = 0 then\n-         return Normalize (X.D, X.Neg);\n-\n-      --  Otherwise add negative of right operand\n-\n-      else\n-         return Add (X.D, Y.D, X.Neg, not Y.Neg);\n-      end if;\n-   end Big_Sub;\n-\n-   -------------\n-   -- Compare --\n-   -------------\n-\n-   function Compare\n-     (X, Y         : Digit_Vector;\n-      X_Neg, Y_Neg : Boolean) return Compare_Result\n-   is\n-   begin\n-      --  Signs are different, that's decisive, since 0 is always plus\n-\n-      if X_Neg /= Y_Neg then\n-         return (if X_Neg then LT else GT);\n-\n-      --  Lengths are different, that's decisive since no leading zeroes\n-\n-      elsif X'Last /= Y'Last then\n-         return (if (X'Last > Y'Last) xor X_Neg then GT else LT);\n-\n-      --  Need to compare data\n-\n-      else\n-         for J in X'Range loop\n-            if X (J) /= Y (J) then\n-               return (if (X (J) > Y (J)) xor X_Neg then GT else LT);\n-            end if;\n-         end loop;\n-\n-         return EQ;\n-      end if;\n-   end Compare;\n-\n-   -------------\n-   -- Div_Rem --\n-   -------------\n-\n-   procedure Div_Rem\n-     (X, Y              : Bignum;\n-      Quotient          : out Bignum;\n-      Remainder         : out Bignum;\n-      Discard_Quotient  : Boolean := False;\n-      Discard_Remainder : Boolean := False)\n-   is\n-   begin\n-      --  Error if division by zero\n-\n-      if Y.Len = 0 then\n-         raise Constraint_Error with \"division by zero\";\n-      end if;\n-\n-      --  Handle simple cases with special tests\n-\n-      --  If X < Y then quotient is zero and remainder is X\n-\n-      if Compare (X.D, Y.D, False, False) = LT then\n-         Remainder := Normalize (X.D);\n-         Quotient  := Normalize (Zero_Data);\n-         return;\n-\n-      --  If both X and Y are less than 2**63-1, we can use Long_Long_Integer\n-      --  arithmetic. Note it is good not to do an accurate range check against\n-      --  Long_Long_Integer since -2**63 / -1 overflows.\n-\n-      elsif (X.Len <= 1 or else (X.Len = 2 and then X.D (1) < 2**31))\n-              and then\n-            (Y.Len <= 1 or else (Y.Len = 2 and then Y.D (1) < 2**31))\n-      then\n-         declare\n-            A : constant LLI := abs (From_Bignum (X));\n-            B : constant LLI := abs (From_Bignum (Y));\n-         begin\n-            Quotient  := To_Bignum (A / B);\n-            Remainder := To_Bignum (A rem B);\n-            return;\n-         end;\n-\n-      --  Easy case if divisor is one digit\n-\n-      elsif Y.Len = 1 then\n-         declare\n-            ND  : DD;\n-            Div : constant DD := DD (Y.D (1));\n-\n-            Result : Digit_Vector (1 .. X.Len);\n-            Remdr  : Digit_Vector (1 .. 1);\n-\n-         begin\n-            ND := 0;\n-            for J in 1 .. X.Len loop\n-               ND := Base * ND + DD (X.D (J));\n-               Result (J) := SD (ND / Div);\n-               ND := ND rem Div;\n-            end loop;\n-\n-            Quotient  := Normalize (Result);\n-            Remdr (1) := SD (ND);\n-            Remainder := Normalize (Remdr);\n-            return;\n-         end;\n-      end if;\n-\n-      --  The complex full multi-precision case. We will employ algorithm\n-      --  D defined in the section \"The Classical Algorithms\" (sec. 4.3.1)\n-      --  of Donald Knuth's \"The Art of Computer Programming\", Vol. 2, 2nd\n-      --  edition. The terminology is adjusted for this section to match that\n-      --  reference.\n-\n-      --  We are dividing X.Len digits of X (called u here) by Y.Len digits\n-      --  of Y (called v here), developing the quotient and remainder. The\n-      --  numbers are represented using Base, which was chosen so that we have\n-      --  the operations of multiplying to single digits (SD) to form a double\n-      --  digit (DD), and dividing a double digit (DD) by a single digit (SD)\n-      --  to give a single digit quotient and a single digit remainder.\n-\n-      --  Algorithm D from Knuth\n-\n-      --  Comments here with square brackets are directly from Knuth\n-\n-      Algorithm_D : declare\n-\n-         --  The following lower case variables correspond exactly to the\n-         --  terminology used in algorithm D.\n-\n-         m : constant Length := X.Len - Y.Len;\n-         n : constant Length := Y.Len;\n-         b : constant DD     := Base;\n-\n-         u : Digit_Vector (0 .. m + n);\n-         v : Digit_Vector (1 .. n);\n-         q : Digit_Vector (0 .. m);\n-         r : Digit_Vector (1 .. n);\n-\n-         u0 : SD renames u (0);\n-         v1 : SD renames v (1);\n-         v2 : SD renames v (2);\n-\n-         d    : DD;\n-         j    : Length;\n-         qhat : DD;\n-         rhat : DD;\n-         temp : DD;\n-\n-      begin\n-         --  Initialize data of left and right operands\n-\n-         for J in 1 .. m + n loop\n-            u (J) := X.D (J);\n-         end loop;\n-\n-         for J in 1 .. n loop\n-            v (J) := Y.D (J);\n-         end loop;\n-\n-         --  [Division of nonnegative integers.] Given nonnegative integers u\n-         --  = (ul,u2..um+n) and v = (v1,v2..vn), where v1 /= 0 and n > 1, we\n-         --  form the quotient u / v = (q0,ql..qm) and the remainder u mod v =\n-         --  (r1,r2..rn).\n-\n-         pragma Assert (v1 /= 0);\n-         pragma Assert (n > 1);\n-\n-         --  Dl. [Normalize.] Set d = b/(vl + 1). Then set (u0,u1,u2..um+n)\n-         --  equal to (u1,u2..um+n) times d, and set (v1,v2..vn) equal to\n-         --  (v1,v2..vn) times d. Note the introduction of a new digit position\n-         --  u0 at the left of u1; if d = 1 all we need to do in this step is\n-         --  to set u0 = 0.\n-\n-         d := b / (DD (v1) + 1);\n-\n-         if d = 1 then\n-            u0 := 0;\n-\n-         else\n-            declare\n-               Carry : DD;\n-               Tmp   : DD;\n-\n-            begin\n-               --  Multiply Dividend (u) by d\n-\n-               Carry := 0;\n-               for J in reverse 1 .. m + n loop\n-                  Tmp   := DD (u (J)) * d + Carry;\n-                  u (J) := LSD (Tmp);\n-                  Carry := Tmp / Base;\n-               end loop;\n-\n-               u0 := SD (Carry);\n-\n-               --  Multiply Divisor (v) by d\n-\n-               Carry := 0;\n-               for J in reverse 1 .. n loop\n-                  Tmp   := DD (v (J)) * d + Carry;\n-                  v (J) := LSD (Tmp);\n-                  Carry := Tmp / Base;\n-               end loop;\n-\n-               pragma Assert (Carry = 0);\n-            end;\n-         end if;\n-\n-         --  D2. [Initialize j.] Set j = 0. The loop on j, steps D2 through D7,\n-         --  will be essentially a division of (uj, uj+1..uj+n) by (v1,v2..vn)\n-         --  to get a single quotient digit qj.\n-\n-         j := 0;\n-\n-         --  Loop through digits\n-\n-         loop\n-            --  Note: In the original printing, step D3 was as follows:\n-\n-            --  D3. [Calculate qhat.] If uj = v1, set qhat to b-l; otherwise\n-            --  set qhat to (uj,uj+1)/v1. Now test if v2 * qhat is greater than\n-            --  (uj*b + uj+1 - qhat*v1)*b + uj+2. If so, decrease qhat by 1 and\n-            --  repeat this test\n-\n-            --  This had a bug not discovered till 1995, see Vol 2 errata:\n-            --  http://www-cs-faculty.stanford.edu/~uno/err2-2e.ps.gz. Under\n-            --  rare circumstances the expression in the test could overflow.\n-            --  This version was further corrected in 2005, see Vol 2 errata:\n-            --  http://www-cs-faculty.stanford.edu/~uno/all2-pre.ps.gz.\n-            --  The code below is the fixed version of this step.\n-\n-            --  D3. [Calculate qhat.] Set qhat to (uj,uj+1)/v1 and rhat to\n-            --  to (uj,uj+1) mod v1.\n-\n-            temp := u (j) & u (j + 1);\n-            qhat := temp / DD (v1);\n-            rhat := temp mod DD (v1);\n-\n-            --  D3 (continued). Now test if qhat >= b or v2*qhat > (rhat,uj+2):\n-            --  if so, decrease qhat by 1, increase rhat by v1, and repeat this\n-            --  test if rhat < b. [The test on v2 determines at high speed\n-            --  most of the cases in which the trial value qhat is one too\n-            --  large, and eliminates all cases where qhat is two too large.]\n-\n-            while qhat >= b\n-              or else DD (v2) * qhat > LSD (rhat) & u (j + 2)\n-            loop\n-               qhat := qhat - 1;\n-               rhat := rhat + DD (v1);\n-               exit when rhat >= b;\n-            end loop;\n-\n-            --  D4. [Multiply and subtract.] Replace (uj,uj+1..uj+n) by\n-            --  (uj,uj+1..uj+n) minus qhat times (v1,v2..vn). This step\n-            --  consists of a simple multiplication by a one-place number,\n-            --  combined with a subtraction.\n-\n-            --  The digits (uj,uj+1..uj+n) are always kept positive; if the\n-            --  result of this step is actually negative then (uj,uj+1..uj+n)\n-            --  is left as the true value plus b**(n+1), i.e. as the b's\n-            --  complement of the true value, and a \"borrow\" to the left is\n-            --  remembered.\n-\n-            declare\n-               Borrow : SD;\n-               Carry  : DD;\n-               Temp   : DD;\n-\n-               Negative : Boolean;\n-               --  Records if subtraction causes a negative result, requiring\n-               --  an add back (case where qhat turned out to be 1 too large).\n-\n-            begin\n-               Borrow := 0;\n-               for K in reverse 1 .. n loop\n-                  Temp := qhat * DD (v (K)) + DD (Borrow);\n-                  Borrow := MSD (Temp);\n-\n-                  if LSD (Temp) > u (j + K) then\n-                     Borrow := Borrow + 1;\n-                  end if;\n-\n-                  u (j + K) := u (j + K) - LSD (Temp);\n-               end loop;\n-\n-               Negative := u (j) < Borrow;\n-               u (j) := u (j) - Borrow;\n-\n-               --  D5. [Test remainder.] Set qj = qhat. If the result of step\n-               --  D4 was negative, we will do the add back step (step D6).\n-\n-               q (j) := LSD (qhat);\n-\n-               if Negative then\n-\n-                  --  D6. [Add back.] Decrease qj by 1, and add (0,v1,v2..vn)\n-                  --  to (uj,uj+1,uj+2..uj+n). (A carry will occur to the left\n-                  --  of uj, and it is be ignored since it cancels with the\n-                  --  borrow that occurred in D4.)\n-\n-                  q (j) := q (j) - 1;\n-\n-                  Carry := 0;\n-                  for K in reverse 1 .. n loop\n-                     Temp := DD (v (K)) + DD (u (j + K)) + Carry;\n-                     u (j + K) := LSD (Temp);\n-                     Carry := Temp / Base;\n-                  end loop;\n-\n-                  u (j) := u (j) + SD (Carry);\n-               end if;\n-            end;\n-\n-            --  D7. [Loop on j.] Increase j by one. Now if j <= m, go back to\n-            --  D3 (the start of the loop on j).\n-\n-            j := j + 1;\n-            exit when not (j <= m);\n-         end loop;\n-\n-         --  D8. [Unnormalize.] Now (qo,ql..qm) is the desired quotient, and\n-         --  the desired remainder may be obtained by dividing (um+1..um+n)\n-         --  by d.\n-\n-         if not Discard_Quotient then\n-            Quotient := Normalize (q);\n-         end if;\n-\n-         if not Discard_Remainder then\n-            declare\n-               Remdr : DD;\n-\n-            begin\n-               Remdr := 0;\n-               for K in 1 .. n loop\n-                  Remdr := Base * Remdr + DD (u (m + K));\n-                  r (K) := SD (Remdr / d);\n-                  Remdr := Remdr rem d;\n-               end loop;\n-\n-               pragma Assert (Remdr = 0);\n-            end;\n-\n-            Remainder := Normalize (r);\n-         end if;\n-      end Algorithm_D;\n-   end Div_Rem;\n-\n-   -----------------\n-   -- From_Bignum --\n-   -----------------\n-\n-   function From_Bignum (X : Bignum) return Long_Long_Integer is\n-   begin\n-      if X.Len = 0 then\n-         return 0;\n-\n-      elsif X.Len = 1 then\n-         return (if X.Neg then -LLI (X.D (1)) else LLI (X.D (1)));\n-\n-      elsif X.Len = 2 then\n-         declare\n-            Mag : constant DD := X.D (1) & X.D (2);\n-         begin\n-            if X.Neg and then Mag <= 2 ** 63 then\n-               return -LLI (Mag);\n-            elsif Mag < 2 ** 63 then\n-               return LLI (Mag);\n-            end if;\n-         end;\n-      end if;\n-\n-      raise Constraint_Error with \"expression value out of range\";\n-   end From_Bignum;\n-\n-   -------------------------\n-   -- Bignum_In_LLI_Range --\n-   -------------------------\n+     (-Sec_Stack_Bignums.Big_Rem (+X, +Y));\n+\n+   function Big_Neg (X    : Bignum) return Bignum is\n+     (-Sec_Stack_Bignums.Big_Neg (+X));\n+\n+   function Big_Abs (X    : Bignum) return Bignum is\n+     (-Sec_Stack_Bignums.Big_Abs (+X));\n+\n+   function Big_EQ  (X, Y : Bignum) return Boolean is\n+     (Sec_Stack_Bignums.Big_EQ (+X, +Y));\n+   function Big_NE  (X, Y : Bignum) return Boolean is\n+     (Sec_Stack_Bignums.Big_NE (+X, +Y));\n+   function Big_GE  (X, Y : Bignum) return Boolean is\n+     (Sec_Stack_Bignums.Big_GE (+X, +Y));\n+   function Big_LE  (X, Y : Bignum) return Boolean is\n+     (Sec_Stack_Bignums.Big_LE (+X, +Y));\n+   function Big_GT  (X, Y : Bignum) return Boolean is\n+     (Sec_Stack_Bignums.Big_GT (+X, +Y));\n+   function Big_LT  (X, Y : Bignum) return Boolean is\n+     (Sec_Stack_Bignums.Big_LT (+X, +Y));\n \n    function Bignum_In_LLI_Range (X : Bignum) return Boolean is\n-   begin\n-      --  If length is 0 or 1, definitely fits\n-\n-      if X.Len <= 1 then\n-         return True;\n-\n-      --  If length is greater than 2, definitely does not fit\n-\n-      elsif X.Len > 2 then\n-         return False;\n-\n-      --  Length is 2, more tests needed\n-\n-      else\n-         declare\n-            Mag : constant DD := X.D (1) & X.D (2);\n-         begin\n-            return Mag < 2 ** 63 or else (X.Neg and then Mag = 2 ** 63);\n-         end;\n-      end if;\n-   end Bignum_In_LLI_Range;\n-\n-   ---------------\n-   -- Normalize --\n-   ---------------\n-\n-   function Normalize\n-     (X   : Digit_Vector;\n-      Neg : Boolean := False) return Bignum\n-   is\n-      B : Bignum;\n-      J : Length;\n-\n-   begin\n-      J := X'First;\n-      while J <= X'Last and then X (J) = 0 loop\n-         J := J + 1;\n-      end loop;\n-\n-      B := Allocate_Bignum (X'Last - J + 1);\n-      B.Neg := B.Len > 0 and then Neg;\n-      B.D := X (J .. X'Last);\n-      return B;\n-   end Normalize;\n-\n-   ---------------\n-   -- To_Bignum --\n-   ---------------\n+     (Sec_Stack_Bignums.Bignum_In_LLI_Range (+X));\n \n    function To_Bignum (X : Long_Long_Integer) return Bignum is\n-      R : Bignum;\n-\n-   begin\n-      if X = 0 then\n-         R := Allocate_Bignum (0);\n+     (-Sec_Stack_Bignums.To_Bignum (X));\n \n-      --  One word result\n-\n-      elsif X in -(2 ** 32 - 1) .. +(2 ** 32 - 1) then\n-         R := Allocate_Bignum (1);\n-         R.D (1) := SD (abs (X));\n-\n-      --  Largest negative number annoyance\n-\n-      elsif X = Long_Long_Integer'First then\n-         R := Allocate_Bignum (2);\n-         R.D (1) := 2 ** 31;\n-         R.D (2) := 0;\n-\n-      --  Normal two word case\n-\n-      else\n-         R := Allocate_Bignum (2);\n-         R.D (2) := SD (abs (X) mod Base);\n-         R.D (1) := SD (abs (X) / Base);\n-      end if;\n-\n-      R.Neg := X < 0;\n-      return R;\n-   end To_Bignum;\n+   function From_Bignum (X : Bignum) return Long_Long_Integer is\n+     (Sec_Stack_Bignums.From_Bignum (+X));\n \n end System.Bignums;"}, {"sha": "5edb62c48a7c90e9b3a1df467d72167cab54d3bb", "filename": "gcc/ada/libgnat/s-bignum.ads", "status": "modified", "additions": 27, "deletions": 42, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fs-bignum.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fs-bignum.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-bignum.ads?ref=f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "patch": "@@ -33,51 +33,13 @@\n --  use in computing intermediate values in expressions for the case where\n --  pragma Overflow_Check (Eliminated) is in effect.\n \n-with Interfaces;\n+--  Note that we cannot use a straight instantiation of System.Generic_Bignums\n+--  because the rtsfind mechanism is not ready to handle instantiations.\n \n package System.Bignums is\n+   pragma Preelaborate;\n \n-   pragma Assert (Long_Long_Integer'Size = 64);\n-   --  This package assumes that Long_Long_Integer size is 64 bit (i.e. that it\n-   --  has a range of -2**63 to 2**63-1). The front end ensures that the mode\n-   --  ELIMINATED is not allowed for overflow checking if this is not the case.\n-\n-   subtype Length is Natural range 0 .. 2 ** 23 - 1;\n-   --  Represent number of words in Digit_Vector\n-\n-   Base : constant := 2 ** 32;\n-   --  Digit vectors use this base\n-\n-   subtype SD is Interfaces.Unsigned_32;\n-   --  Single length digit\n-\n-   type Digit_Vector is array (Length range <>) of SD;\n-   --  Represent digits of a number (most significant digit first)\n-\n-   type Bignum_Data (Len : Length) is record\n-      Neg : Boolean;\n-      --  Set if value is negative, never set for zero\n-\n-      D : Digit_Vector (1 .. Len);\n-      --  Digits of number, most significant first, represented in base\n-      --  2**Base. No leading zeroes are stored, and the value of zero is\n-      --  represented using an empty vector for D.\n-   end record;\n-\n-   for Bignum_Data use record\n-      Len at 0 range 0 .. 23;\n-      Neg at 3 range 0 .. 7;\n-   end record;\n-\n-   type Bignum is access all Bignum_Data;\n-   --  This is the type that is used externally. Possibly this could be a\n-   --  private type, but we leave the structure exposed for now. For one\n-   --  thing it helps with debugging. Note that this package never shares\n-   --  an allocated Bignum value, so for example for X + 0, a copy of X is\n-   --  returned, not X itself.\n-\n-   --  Note: none of the subprograms in this package modify the Bignum_Data\n-   --  records referenced by Bignum arguments of mode IN.\n+   type Bignum is private;\n \n    function Big_Add (X, Y : Bignum) return Bignum;  --  \"+\"\n    function Big_Sub (X, Y : Bignum) return Bignum;  --  \"-\"\n@@ -113,4 +75,27 @@ package System.Bignums is\n    --  Convert Bignum to Long_Long_Integer. Constraint_Error raised with\n    --  appropriate message if value is out of range of Long_Long_Integer.\n \n+private\n+\n+   type Bignum is new System.Address;\n+\n+   pragma Inline (Big_Add);\n+   pragma Inline (Big_Sub);\n+   pragma Inline (Big_Mul);\n+   pragma Inline (Big_Div);\n+   pragma Inline (Big_Exp);\n+   pragma Inline (Big_Mod);\n+   pragma Inline (Big_Rem);\n+   pragma Inline (Big_Neg);\n+   pragma Inline (Big_Abs);\n+   pragma Inline (Big_EQ);\n+   pragma Inline (Big_NE);\n+   pragma Inline (Big_GE);\n+   pragma Inline (Big_LE);\n+   pragma Inline (Big_GT);\n+   pragma Inline (Big_LT);\n+   pragma Inline (Bignum_In_LLI_Range);\n+   pragma Inline (To_Bignum);\n+   pragma Inline (From_Bignum);\n+\n end System.Bignums;"}, {"sha": "0a92dfb3126e2c871a711c91194b1fde45218464", "filename": "gcc/ada/libgnat/s-genbig.adb", "status": "added", "additions": 1133, "deletions": 0, "changes": 1133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fs-genbig.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fs-genbig.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-genbig.adb?ref=f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "patch": "@@ -0,0 +1,1133 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--               S Y S T E M . G E N E R I C _ B I G N U M S                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2012-2019, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides arbitrary precision signed integer arithmetic.\n+\n+with System;                  use System;\n+with System.Secondary_Stack;  use System.Secondary_Stack;\n+with System.Storage_Elements; use System.Storage_Elements;\n+\n+package body System.Generic_Bignums is\n+\n+   use Interfaces;\n+   --  So that operations on Unsigned_32/Unsigned_64 are available\n+\n+   type DD is mod Base ** 2;\n+   --  Double length digit used for intermediate computations\n+\n+   function MSD (X : DD) return SD is (SD (X / Base));\n+   function LSD (X : DD) return SD is (SD (X mod Base));\n+   --  Most significant and least significant digit of double digit value\n+\n+   function \"&\" (X, Y : SD) return DD is (DD (X) * Base + DD (Y));\n+   --  Compose double digit value from two single digit values\n+\n+   subtype LLI is Long_Long_Integer;\n+\n+   One_Data : constant Digit_Vector (1 .. 1) := (1 => 1);\n+   --  Constant one\n+\n+   Zero_Data : constant Digit_Vector (1 .. 0) := (1 .. 0 => 0);\n+   --  Constant zero\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Add\n+     (X, Y  : Digit_Vector;\n+      X_Neg : Boolean;\n+      Y_Neg : Boolean) return Bignum\n+   with\n+     Pre => X'First = 1 and then Y'First = 1;\n+   --  This procedure adds two signed numbers returning the Sum, it is used\n+   --  for both addition and subtraction. The value computed is X + Y, with\n+   --  X_Neg and Y_Neg giving the signs of the operands.\n+\n+   function Allocate_Bignum (Len : Length) return Bignum with\n+     Post => Allocate_Bignum'Result.Len = Len;\n+   --  Allocate Bignum value of indicated length on secondary stack. On return\n+   --  the Neg and D fields are left uninitialized.\n+\n+   type Compare_Result is (LT, EQ, GT);\n+   --  Indicates result of comparison in following call\n+\n+   function Compare\n+     (X, Y         : Digit_Vector;\n+      X_Neg, Y_Neg : Boolean) return Compare_Result\n+   with\n+     Pre => X'First = 1 and then Y'First = 1;\n+   --  Compare (X with sign X_Neg) with (Y with sign Y_Neg), and return the\n+   --  result of the signed comparison.\n+\n+   procedure Div_Rem\n+     (X, Y              : Bignum;\n+      Quotient          : out Bignum;\n+      Remainder         : out Bignum;\n+      Discard_Quotient  : Boolean := False;\n+      Discard_Remainder : Boolean := False);\n+   --  Returns the Quotient and Remainder from dividing abs (X) by abs (Y). The\n+   --  values of X and Y are not modified. If Discard_Quotient is True, then\n+   --  Quotient is undefined on return, and if Discard_Remainder is True, then\n+   --  Remainder is undefined on return. Service routine for Big_Div/Rem/Mod.\n+\n+   procedure Free_Bignum (X : Bignum) is null;\n+   --  Called to free a Bignum value used in intermediate computations. In\n+   --  this implementation using the secondary stack, it does nothing at all,\n+   --  because we rely on Mark/Release, but it may be of use for some\n+   --  alternative implementation.\n+\n+   function Normalize\n+     (X   : Digit_Vector;\n+      Neg : Boolean := False) return Bignum;\n+   --  Given a digit vector and sign, allocate and construct a Bignum value.\n+   --  Note that X may have leading zeroes which must be removed, and if the\n+   --  result is zero, the sign is forced positive.\n+\n+   ---------\n+   -- Add --\n+   ---------\n+\n+   function Add\n+     (X, Y  : Digit_Vector;\n+      X_Neg : Boolean;\n+      Y_Neg : Boolean) return Bignum\n+   is\n+   begin\n+      --  If signs are the same, we are doing an addition, it is convenient to\n+      --  ensure that the first operand is the longer of the two.\n+\n+      if X_Neg = Y_Neg then\n+         if X'Last < Y'Last then\n+            return Add (X => Y, Y => X, X_Neg => Y_Neg, Y_Neg => X_Neg);\n+\n+         --  Here signs are the same, and the first operand is the longer\n+\n+         else\n+            pragma Assert (X_Neg = Y_Neg and then X'Last >= Y'Last);\n+\n+            --  Do addition, putting result in Sum (allowing for carry)\n+\n+            declare\n+               Sum : Digit_Vector (0 .. X'Last);\n+               RD  : DD;\n+\n+            begin\n+               RD := 0;\n+               for J in reverse 1 .. X'Last loop\n+                  RD := RD + DD (X (J));\n+\n+                  if J >= 1 + (X'Last - Y'Last) then\n+                     RD := RD + DD (Y (J - (X'Last - Y'Last)));\n+                  end if;\n+\n+                  Sum (J) := LSD (RD);\n+                  RD := RD / Base;\n+               end loop;\n+\n+               Sum (0) := SD (RD);\n+               return Normalize (Sum, X_Neg);\n+            end;\n+         end if;\n+\n+      --  Signs are different so really this is a subtraction, we want to make\n+      --  sure that the largest magnitude operand is the first one, and then\n+      --  the result will have the sign of the first operand.\n+\n+      else\n+         declare\n+            CR : constant Compare_Result := Compare (X, Y, False, False);\n+\n+         begin\n+            if CR = EQ then\n+               return Normalize (Zero_Data);\n+\n+            elsif CR = LT then\n+               return Add (X => Y, Y => X, X_Neg => Y_Neg, Y_Neg => X_Neg);\n+\n+            else\n+               pragma Assert (X_Neg /= Y_Neg and then CR = GT);\n+\n+               --  Do subtraction, putting result in Diff\n+\n+               declare\n+                  Diff : Digit_Vector (1 .. X'Length);\n+                  RD   : DD;\n+\n+               begin\n+                  RD := 0;\n+                  for J in reverse 1 .. X'Last loop\n+                     RD := RD + DD (X (J));\n+\n+                     if J >= 1 + (X'Last - Y'Last) then\n+                        RD := RD - DD (Y (J - (X'Last - Y'Last)));\n+                     end if;\n+\n+                     Diff (J) := LSD (RD);\n+                     RD := (if RD < Base then 0 else -1);\n+                  end loop;\n+\n+                  return Normalize (Diff, X_Neg);\n+               end;\n+            end if;\n+         end;\n+      end if;\n+   end Add;\n+\n+   ---------------------\n+   -- Allocate_Bignum --\n+   ---------------------\n+\n+   function Allocate_Bignum (Len : Length) return Bignum is\n+      Addr : Address;\n+\n+   begin\n+      --  Allocation on the heap\n+\n+      if not Use_Secondary_Stack then\n+         declare\n+            B : Bignum;\n+         begin\n+            B := new Bignum_Data'(Len, False, (others => 0));\n+            return B;\n+         end;\n+\n+      --  Allocation on the secondary stack\n+\n+      else\n+         --  Note: The approach used here is designed to avoid strict aliasing\n+         --  warnings that appeared previously using unchecked conversion.\n+\n+         SS_Allocate (Addr, Storage_Offset (4 + 4 * Len));\n+\n+         declare\n+            B : Bignum;\n+            for B'Address use Addr'Address;\n+            pragma Import (Ada, B);\n+\n+            BD : Bignum_Data (Len);\n+            for BD'Address use Addr;\n+            pragma Import (Ada, BD);\n+\n+            --  Expose a writable view of discriminant BD.Len so that we can\n+            --  initialize it. We need to use the exact layout of the record\n+            --  to ensure that the Length field has 24 bits as expected.\n+\n+            type Bignum_Data_Header is record\n+               Len : Length;\n+               Neg : Boolean;\n+            end record;\n+\n+            for Bignum_Data_Header use record\n+               Len at 0 range 0 .. 23;\n+               Neg at 3 range 0 .. 7;\n+            end record;\n+\n+            BDH : Bignum_Data_Header;\n+            for BDH'Address use BD'Address;\n+            pragma Import (Ada, BDH);\n+\n+            pragma Assert (BDH.Len'Size = BD.Len'Size);\n+\n+         begin\n+            BDH.Len := Len;\n+            return B;\n+         end;\n+      end if;\n+   end Allocate_Bignum;\n+\n+   -------------\n+   -- Big_Abs --\n+   -------------\n+\n+   function Big_Abs (X : Bignum) return Bignum is\n+   begin\n+      return Normalize (X.D);\n+   end Big_Abs;\n+\n+   -------------\n+   -- Big_Add --\n+   -------------\n+\n+   function Big_Add  (X, Y : Bignum) return Bignum is\n+   begin\n+      return Add (X.D, Y.D, X.Neg, Y.Neg);\n+   end Big_Add;\n+\n+   -------------\n+   -- Big_Div --\n+   -------------\n+\n+   --  This table is excerpted from RM 4.5.5(28-30) and shows how the result\n+   --  varies with the signs of the operands.\n+\n+   --   A      B   A/B      A     B    A/B\n+   --\n+   --   10     5    2      -10    5    -2\n+   --   11     5    2      -11    5    -2\n+   --   12     5    2      -12    5    -2\n+   --   13     5    2      -13    5    -2\n+   --   14     5    2      -14    5    -2\n+   --\n+   --   A      B   A/B      A     B    A/B\n+   --\n+   --   10    -5   -2      -10   -5     2\n+   --   11    -5   -2      -11   -5     2\n+   --   12    -5   -2      -12   -5     2\n+   --   13    -5   -2      -13   -5     2\n+   --   14    -5   -2      -14   -5     2\n+\n+   function Big_Div  (X, Y : Bignum) return Bignum is\n+      Q, R : Bignum;\n+   begin\n+      Div_Rem (X, Y, Q, R, Discard_Remainder => True);\n+      Q.Neg := Q.Len > 0 and then (X.Neg xor Y.Neg);\n+      return Q;\n+   end Big_Div;\n+\n+   -------------\n+   -- Big_Exp --\n+   -------------\n+\n+   function Big_Exp  (X, Y : Bignum) return Bignum is\n+\n+      function \"**\" (X : Bignum; Y : SD) return Bignum;\n+      --  Internal routine where we know right operand is one word\n+\n+      ----------\n+      -- \"**\" --\n+      ----------\n+\n+      function \"**\" (X : Bignum; Y : SD) return Bignum is\n+      begin\n+         case Y is\n+\n+            --  X ** 0 is 1\n+\n+            when 0 =>\n+               return Normalize (One_Data);\n+\n+            --  X ** 1 is X\n+\n+            when 1 =>\n+               return Normalize (X.D);\n+\n+            --  X ** 2 is X * X\n+\n+            when 2 =>\n+               return Big_Mul (X, X);\n+\n+            --  For X greater than 2, use the recursion\n+\n+            --  X even, X ** Y = (X ** (Y/2)) ** 2;\n+            --  X odd,  X ** Y = (X ** (Y/2)) ** 2 * X;\n+\n+            when others =>\n+               declare\n+                  XY2  : constant Bignum := X ** (Y / 2);\n+                  XY2S : constant Bignum := Big_Mul (XY2, XY2);\n+                  Res  : Bignum;\n+\n+               begin\n+                  Free_Bignum (XY2);\n+\n+                  --  Raise storage error if intermediate value is getting too\n+                  --  large, which we arbitrarily define as 200 words for now.\n+\n+                  if XY2S.Len > 200 then\n+                     Free_Bignum (XY2S);\n+                     raise Storage_Error with\n+                       \"exponentiation result is too large\";\n+                  end if;\n+\n+                  --  Otherwise take care of even/odd cases\n+\n+                  if (Y and 1) = 0 then\n+                     return XY2S;\n+\n+                  else\n+                     Res := Big_Mul (XY2S, X);\n+                     Free_Bignum (XY2S);\n+                     return Res;\n+                  end if;\n+               end;\n+         end case;\n+      end \"**\";\n+\n+   --  Start of processing for Big_Exp\n+\n+   begin\n+      --  Error if right operand negative\n+\n+      if Y.Neg then\n+         raise Constraint_Error with \"exponentiation to negative power\";\n+\n+      --  X ** 0 is always 1 (including 0 ** 0, so do this test first)\n+\n+      elsif Y.Len = 0 then\n+         return Normalize (One_Data);\n+\n+      --  0 ** X is always 0 (for X non-zero)\n+\n+      elsif X.Len = 0 then\n+         return Normalize (Zero_Data);\n+\n+      --  (+1) ** Y = 1\n+      --  (-1) ** Y = +/-1 depending on whether Y is even or odd\n+\n+      elsif X.Len = 1 and then X.D (1) = 1 then\n+         return Normalize\n+           (X.D, Neg => X.Neg and then ((Y.D (Y.Len) and 1) = 1));\n+\n+      --  If the absolute value of the base is greater than 1, then the\n+      --  exponent must not be bigger than one word, otherwise the result\n+      --  is ludicrously large, and we just signal Storage_Error right away.\n+\n+      elsif Y.Len > 1 then\n+         raise Storage_Error with \"exponentiation result is too large\";\n+\n+      --  Special case (+/-)2 ** K, where K is 1 .. 31 using a shift\n+\n+      elsif X.Len = 1 and then X.D (1) = 2 and then Y.D (1) < 32 then\n+         declare\n+            D : constant Digit_Vector (1 .. 1) :=\n+                  (1 => Shift_Left (SD'(1), Natural (Y.D (1))));\n+         begin\n+            return Normalize (D, X.Neg);\n+         end;\n+\n+      --  Remaining cases have right operand of one word\n+\n+      else\n+         return X ** Y.D (1);\n+      end if;\n+   end Big_Exp;\n+\n+   ------------\n+   -- Big_EQ --\n+   ------------\n+\n+   function Big_EQ (X, Y : Bignum) return Boolean is\n+   begin\n+      return Compare (X.D, Y.D, X.Neg, Y.Neg) = EQ;\n+   end Big_EQ;\n+\n+   ------------\n+   -- Big_GE --\n+   ------------\n+\n+   function Big_GE (X, Y : Bignum) return Boolean is\n+   begin\n+      return Compare (X.D, Y.D, X.Neg, Y.Neg) /= LT;\n+   end Big_GE;\n+\n+   ------------\n+   -- Big_GT --\n+   ------------\n+\n+   function Big_GT (X, Y : Bignum) return Boolean is\n+   begin\n+      return Compare (X.D, Y.D, X.Neg, Y.Neg) = GT;\n+   end Big_GT;\n+\n+   ------------\n+   -- Big_LE --\n+   ------------\n+\n+   function Big_LE (X, Y : Bignum) return Boolean is\n+   begin\n+      return Compare (X.D, Y.D, X.Neg, Y.Neg) /= GT;\n+   end Big_LE;\n+\n+   ------------\n+   -- Big_LT --\n+   ------------\n+\n+   function Big_LT (X, Y : Bignum) return Boolean is\n+   begin\n+      return Compare (X.D, Y.D, X.Neg, Y.Neg) = LT;\n+   end Big_LT;\n+\n+   -------------\n+   -- Big_Mod --\n+   -------------\n+\n+   --  This table is excerpted from RM 4.5.5(28-30) and shows how the result\n+   --  of Rem and Mod vary with the signs of the operands.\n+\n+   --   A      B    A mod B  A rem B     A     B    A mod B  A rem B\n+\n+   --   10     5       0        0       -10    5       0        0\n+   --   11     5       1        1       -11    5       4       -1\n+   --   12     5       2        2       -12    5       3       -2\n+   --   13     5       3        3       -13    5       2       -3\n+   --   14     5       4        4       -14    5       1       -4\n+\n+   --   A      B    A mod B  A rem B     A     B    A mod B  A rem B\n+\n+   --   10    -5       0        0       -10   -5       0        0\n+   --   11    -5      -4        1       -11   -5      -1       -1\n+   --   12    -5      -3        2       -12   -5      -2       -2\n+   --   13    -5      -2        3       -13   -5      -3       -3\n+   --   14    -5      -1        4       -14   -5      -4       -4\n+\n+   function Big_Mod (X, Y : Bignum) return Bignum is\n+      Q, R : Bignum;\n+\n+   begin\n+      --  If signs are same, result is same as Rem\n+\n+      if X.Neg = Y.Neg then\n+         return Big_Rem (X, Y);\n+\n+      --  Case where Mod is different\n+\n+      else\n+         --  Do division\n+\n+         Div_Rem (X, Y, Q, R, Discard_Quotient => True);\n+\n+         --  Zero result is unchanged\n+\n+         if R.Len = 0 then\n+            return R;\n+\n+         --  Otherwise adjust result\n+\n+         else\n+            declare\n+               T1 : constant Bignum := Big_Sub (Y, R);\n+            begin\n+               T1.Neg := Y.Neg;\n+               Free_Bignum (R);\n+               return T1;\n+            end;\n+         end if;\n+      end if;\n+   end Big_Mod;\n+\n+   -------------\n+   -- Big_Mul --\n+   -------------\n+\n+   function Big_Mul (X, Y : Bignum) return Bignum is\n+      Result : Digit_Vector (1 .. X.Len + Y.Len) := (others => 0);\n+      --  Accumulate result (max length of result is sum of operand lengths)\n+\n+      L : Length;\n+      --  Current result digit\n+\n+      D : DD;\n+      --  Result digit\n+\n+   begin\n+      for J in 1 .. X.Len loop\n+         for K in 1 .. Y.Len loop\n+            L := Result'Last - (X.Len - J) - (Y.Len - K);\n+            D := DD (X.D (J)) * DD (Y.D (K)) + DD (Result (L));\n+            Result (L) := LSD (D);\n+            D := D / Base;\n+\n+            --  D is carry which must be propagated\n+\n+            while D /= 0 and then L >= 1 loop\n+               L := L - 1;\n+               D := D + DD (Result (L));\n+               Result (L) := LSD (D);\n+               D := D / Base;\n+            end loop;\n+\n+            --  Must not have a carry trying to extend max length\n+\n+            pragma Assert (D = 0);\n+         end loop;\n+      end loop;\n+\n+      --  Return result\n+\n+      return Normalize (Result, X.Neg xor Y.Neg);\n+   end Big_Mul;\n+\n+   ------------\n+   -- Big_NE --\n+   ------------\n+\n+   function Big_NE (X, Y : Bignum) return Boolean is\n+   begin\n+      return Compare (X.D, Y.D, X.Neg, Y.Neg) /= EQ;\n+   end Big_NE;\n+\n+   -------------\n+   -- Big_Neg --\n+   -------------\n+\n+   function Big_Neg (X : Bignum) return Bignum is\n+   begin\n+      return Normalize (X.D, not X.Neg);\n+   end Big_Neg;\n+\n+   -------------\n+   -- Big_Rem --\n+   -------------\n+\n+   --  This table is excerpted from RM 4.5.5(28-30) and shows how the result\n+   --  varies with the signs of the operands.\n+\n+   --   A      B   A rem B   A     B   A rem B\n+\n+   --   10     5      0     -10    5      0\n+   --   11     5      1     -11    5     -1\n+   --   12     5      2     -12    5     -2\n+   --   13     5      3     -13    5     -3\n+   --   14     5      4     -14    5     -4\n+\n+   --   A      B  A rem B    A     B   A rem B\n+\n+   --   10    -5     0      -10   -5      0\n+   --   11    -5     1      -11   -5     -1\n+   --   12    -5     2      -12   -5     -2\n+   --   13    -5     3      -13   -5     -3\n+   --   14    -5     4      -14   -5     -4\n+\n+   function Big_Rem (X, Y : Bignum) return Bignum is\n+      Q, R : Bignum;\n+   begin\n+      Div_Rem (X, Y, Q, R, Discard_Quotient => True);\n+      R.Neg := R.Len > 0 and then X.Neg;\n+      return R;\n+   end Big_Rem;\n+\n+   -------------\n+   -- Big_Sub --\n+   -------------\n+\n+   function Big_Sub (X, Y : Bignum) return Bignum is\n+   begin\n+      --  If right operand zero, return left operand (avoiding sharing)\n+\n+      if Y.Len = 0 then\n+         return Normalize (X.D, X.Neg);\n+\n+      --  Otherwise add negative of right operand\n+\n+      else\n+         return Add (X.D, Y.D, X.Neg, not Y.Neg);\n+      end if;\n+   end Big_Sub;\n+\n+   -------------\n+   -- Compare --\n+   -------------\n+\n+   function Compare\n+     (X, Y         : Digit_Vector;\n+      X_Neg, Y_Neg : Boolean) return Compare_Result\n+   is\n+   begin\n+      --  Signs are different, that's decisive, since 0 is always plus\n+\n+      if X_Neg /= Y_Neg then\n+         return (if X_Neg then LT else GT);\n+\n+      --  Lengths are different, that's decisive since no leading zeroes\n+\n+      elsif X'Last /= Y'Last then\n+         return (if (X'Last > Y'Last) xor X_Neg then GT else LT);\n+\n+      --  Need to compare data\n+\n+      else\n+         for J in X'Range loop\n+            if X (J) /= Y (J) then\n+               return (if (X (J) > Y (J)) xor X_Neg then GT else LT);\n+            end if;\n+         end loop;\n+\n+         return EQ;\n+      end if;\n+   end Compare;\n+\n+   -------------\n+   -- Div_Rem --\n+   -------------\n+\n+   procedure Div_Rem\n+     (X, Y              : Bignum;\n+      Quotient          : out Bignum;\n+      Remainder         : out Bignum;\n+      Discard_Quotient  : Boolean := False;\n+      Discard_Remainder : Boolean := False)\n+   is\n+   begin\n+      --  Error if division by zero\n+\n+      if Y.Len = 0 then\n+         raise Constraint_Error with \"division by zero\";\n+      end if;\n+\n+      --  Handle simple cases with special tests\n+\n+      --  If X < Y then quotient is zero and remainder is X\n+\n+      if Compare (X.D, Y.D, False, False) = LT then\n+         Remainder := Normalize (X.D);\n+         Quotient  := Normalize (Zero_Data);\n+         return;\n+\n+      --  If both X and Y are less than 2**63-1, we can use Long_Long_Integer\n+      --  arithmetic. Note it is good not to do an accurate range check against\n+      --  Long_Long_Integer since -2**63 / -1 overflows.\n+\n+      elsif (X.Len <= 1 or else (X.Len = 2 and then X.D (1) < 2**31))\n+              and then\n+            (Y.Len <= 1 or else (Y.Len = 2 and then Y.D (1) < 2**31))\n+      then\n+         declare\n+            A : constant LLI := abs (From_Bignum (X));\n+            B : constant LLI := abs (From_Bignum (Y));\n+         begin\n+            Quotient  := To_Bignum (A / B);\n+            Remainder := To_Bignum (A rem B);\n+            return;\n+         end;\n+\n+      --  Easy case if divisor is one digit\n+\n+      elsif Y.Len = 1 then\n+         declare\n+            ND  : DD;\n+            Div : constant DD := DD (Y.D (1));\n+\n+            Result : Digit_Vector (1 .. X.Len);\n+            Remdr  : Digit_Vector (1 .. 1);\n+\n+         begin\n+            ND := 0;\n+            for J in 1 .. X.Len loop\n+               ND := Base * ND + DD (X.D (J));\n+               Result (J) := SD (ND / Div);\n+               ND := ND rem Div;\n+            end loop;\n+\n+            Quotient  := Normalize (Result);\n+            Remdr (1) := SD (ND);\n+            Remainder := Normalize (Remdr);\n+            return;\n+         end;\n+      end if;\n+\n+      --  The complex full multi-precision case. We will employ algorithm\n+      --  D defined in the section \"The Classical Algorithms\" (sec. 4.3.1)\n+      --  of Donald Knuth's \"The Art of Computer Programming\", Vol. 2, 2nd\n+      --  edition. The terminology is adjusted for this section to match that\n+      --  reference.\n+\n+      --  We are dividing X.Len digits of X (called u here) by Y.Len digits\n+      --  of Y (called v here), developing the quotient and remainder. The\n+      --  numbers are represented using Base, which was chosen so that we have\n+      --  the operations of multiplying to single digits (SD) to form a double\n+      --  digit (DD), and dividing a double digit (DD) by a single digit (SD)\n+      --  to give a single digit quotient and a single digit remainder.\n+\n+      --  Algorithm D from Knuth\n+\n+      --  Comments here with square brackets are directly from Knuth\n+\n+      Algorithm_D : declare\n+\n+         --  The following lower case variables correspond exactly to the\n+         --  terminology used in algorithm D.\n+\n+         m : constant Length := X.Len - Y.Len;\n+         n : constant Length := Y.Len;\n+         b : constant DD     := Base;\n+\n+         u : Digit_Vector (0 .. m + n);\n+         v : Digit_Vector (1 .. n);\n+         q : Digit_Vector (0 .. m);\n+         r : Digit_Vector (1 .. n);\n+\n+         u0 : SD renames u (0);\n+         v1 : SD renames v (1);\n+         v2 : SD renames v (2);\n+\n+         d    : DD;\n+         j    : Length;\n+         qhat : DD;\n+         rhat : DD;\n+         temp : DD;\n+\n+      begin\n+         --  Initialize data of left and right operands\n+\n+         for J in 1 .. m + n loop\n+            u (J) := X.D (J);\n+         end loop;\n+\n+         for J in 1 .. n loop\n+            v (J) := Y.D (J);\n+         end loop;\n+\n+         --  [Division of nonnegative integers.] Given nonnegative integers u\n+         --  = (ul,u2..um+n) and v = (v1,v2..vn), where v1 /= 0 and n > 1, we\n+         --  form the quotient u / v = (q0,ql..qm) and the remainder u mod v =\n+         --  (r1,r2..rn).\n+\n+         pragma Assert (v1 /= 0);\n+         pragma Assert (n > 1);\n+\n+         --  Dl. [Normalize.] Set d = b/(vl + 1). Then set (u0,u1,u2..um+n)\n+         --  equal to (u1,u2..um+n) times d, and set (v1,v2..vn) equal to\n+         --  (v1,v2..vn) times d. Note the introduction of a new digit position\n+         --  u0 at the left of u1; if d = 1 all we need to do in this step is\n+         --  to set u0 = 0.\n+\n+         d := b / (DD (v1) + 1);\n+\n+         if d = 1 then\n+            u0 := 0;\n+\n+         else\n+            declare\n+               Carry : DD;\n+               Tmp   : DD;\n+\n+            begin\n+               --  Multiply Dividend (u) by d\n+\n+               Carry := 0;\n+               for J in reverse 1 .. m + n loop\n+                  Tmp   := DD (u (J)) * d + Carry;\n+                  u (J) := LSD (Tmp);\n+                  Carry := Tmp / Base;\n+               end loop;\n+\n+               u0 := SD (Carry);\n+\n+               --  Multiply Divisor (v) by d\n+\n+               Carry := 0;\n+               for J in reverse 1 .. n loop\n+                  Tmp   := DD (v (J)) * d + Carry;\n+                  v (J) := LSD (Tmp);\n+                  Carry := Tmp / Base;\n+               end loop;\n+\n+               pragma Assert (Carry = 0);\n+            end;\n+         end if;\n+\n+         --  D2. [Initialize j.] Set j = 0. The loop on j, steps D2 through D7,\n+         --  will be essentially a division of (uj, uj+1..uj+n) by (v1,v2..vn)\n+         --  to get a single quotient digit qj.\n+\n+         j := 0;\n+\n+         --  Loop through digits\n+\n+         loop\n+            --  Note: In the original printing, step D3 was as follows:\n+\n+            --  D3. [Calculate qhat.] If uj = v1, set qhat to b-l; otherwise\n+            --  set qhat to (uj,uj+1)/v1. Now test if v2 * qhat is greater than\n+            --  (uj*b + uj+1 - qhat*v1)*b + uj+2. If so, decrease qhat by 1 and\n+            --  repeat this test\n+\n+            --  This had a bug not discovered till 1995, see Vol 2 errata:\n+            --  http://www-cs-faculty.stanford.edu/~uno/err2-2e.ps.gz. Under\n+            --  rare circumstances the expression in the test could overflow.\n+            --  This version was further corrected in 2005, see Vol 2 errata:\n+            --  http://www-cs-faculty.stanford.edu/~uno/all2-pre.ps.gz.\n+            --  The code below is the fixed version of this step.\n+\n+            --  D3. [Calculate qhat.] Set qhat to (uj,uj+1)/v1 and rhat to\n+            --  to (uj,uj+1) mod v1.\n+\n+            temp := u (j) & u (j + 1);\n+            qhat := temp / DD (v1);\n+            rhat := temp mod DD (v1);\n+\n+            --  D3 (continued). Now test if qhat >= b or v2*qhat > (rhat,uj+2):\n+            --  if so, decrease qhat by 1, increase rhat by v1, and repeat this\n+            --  test if rhat < b. [The test on v2 determines at high speed\n+            --  most of the cases in which the trial value qhat is one too\n+            --  large, and eliminates all cases where qhat is two too large.]\n+\n+            while qhat >= b\n+              or else DD (v2) * qhat > LSD (rhat) & u (j + 2)\n+            loop\n+               qhat := qhat - 1;\n+               rhat := rhat + DD (v1);\n+               exit when rhat >= b;\n+            end loop;\n+\n+            --  D4. [Multiply and subtract.] Replace (uj,uj+1..uj+n) by\n+            --  (uj,uj+1..uj+n) minus qhat times (v1,v2..vn). This step\n+            --  consists of a simple multiplication by a one-place number,\n+            --  combined with a subtraction.\n+\n+            --  The digits (uj,uj+1..uj+n) are always kept positive; if the\n+            --  result of this step is actually negative then (uj,uj+1..uj+n)\n+            --  is left as the true value plus b**(n+1), i.e. as the b's\n+            --  complement of the true value, and a \"borrow\" to the left is\n+            --  remembered.\n+\n+            declare\n+               Borrow : SD;\n+               Carry  : DD;\n+               Temp   : DD;\n+\n+               Negative : Boolean;\n+               --  Records if subtraction causes a negative result, requiring\n+               --  an add back (case where qhat turned out to be 1 too large).\n+\n+            begin\n+               Borrow := 0;\n+               for K in reverse 1 .. n loop\n+                  Temp := qhat * DD (v (K)) + DD (Borrow);\n+                  Borrow := MSD (Temp);\n+\n+                  if LSD (Temp) > u (j + K) then\n+                     Borrow := Borrow + 1;\n+                  end if;\n+\n+                  u (j + K) := u (j + K) - LSD (Temp);\n+               end loop;\n+\n+               Negative := u (j) < Borrow;\n+               u (j) := u (j) - Borrow;\n+\n+               --  D5. [Test remainder.] Set qj = qhat. If the result of step\n+               --  D4 was negative, we will do the add back step (step D6).\n+\n+               q (j) := LSD (qhat);\n+\n+               if Negative then\n+\n+                  --  D6. [Add back.] Decrease qj by 1, and add (0,v1,v2..vn)\n+                  --  to (uj,uj+1,uj+2..uj+n). (A carry will occur to the left\n+                  --  of uj, and it is be ignored since it cancels with the\n+                  --  borrow that occurred in D4.)\n+\n+                  q (j) := q (j) - 1;\n+\n+                  Carry := 0;\n+                  for K in reverse 1 .. n loop\n+                     Temp := DD (v (K)) + DD (u (j + K)) + Carry;\n+                     u (j + K) := LSD (Temp);\n+                     Carry := Temp / Base;\n+                  end loop;\n+\n+                  u (j) := u (j) + SD (Carry);\n+               end if;\n+            end;\n+\n+            --  D7. [Loop on j.] Increase j by one. Now if j <= m, go back to\n+            --  D3 (the start of the loop on j).\n+\n+            j := j + 1;\n+            exit when not (j <= m);\n+         end loop;\n+\n+         --  D8. [Unnormalize.] Now (qo,ql..qm) is the desired quotient, and\n+         --  the desired remainder may be obtained by dividing (um+1..um+n)\n+         --  by d.\n+\n+         if not Discard_Quotient then\n+            Quotient := Normalize (q);\n+         end if;\n+\n+         if not Discard_Remainder then\n+            declare\n+               Remdr : DD;\n+\n+            begin\n+               Remdr := 0;\n+               for K in 1 .. n loop\n+                  Remdr := Base * Remdr + DD (u (m + K));\n+                  r (K) := SD (Remdr / d);\n+                  Remdr := Remdr rem d;\n+               end loop;\n+\n+               pragma Assert (Remdr = 0);\n+            end;\n+\n+            Remainder := Normalize (r);\n+         end if;\n+      end Algorithm_D;\n+   end Div_Rem;\n+\n+   -----------------\n+   -- From_Bignum --\n+   -----------------\n+\n+   function From_Bignum (X : Bignum) return Long_Long_Integer is\n+   begin\n+      if X.Len = 0 then\n+         return 0;\n+\n+      elsif X.Len = 1 then\n+         return (if X.Neg then -LLI (X.D (1)) else LLI (X.D (1)));\n+\n+      elsif X.Len = 2 then\n+         declare\n+            Mag : constant DD := X.D (1) & X.D (2);\n+         begin\n+            if X.Neg and then Mag <= 2 ** 63 then\n+               return -LLI (Mag);\n+            elsif Mag < 2 ** 63 then\n+               return LLI (Mag);\n+            end if;\n+         end;\n+      end if;\n+\n+      raise Constraint_Error with \"expression value out of range\";\n+   end From_Bignum;\n+\n+   -------------------------\n+   -- Bignum_In_LLI_Range --\n+   -------------------------\n+\n+   function Bignum_In_LLI_Range (X : Bignum) return Boolean is\n+   begin\n+      --  If length is 0 or 1, definitely fits\n+\n+      if X.Len <= 1 then\n+         return True;\n+\n+      --  If length is greater than 2, definitely does not fit\n+\n+      elsif X.Len > 2 then\n+         return False;\n+\n+      --  Length is 2, more tests needed\n+\n+      else\n+         declare\n+            Mag : constant DD := X.D (1) & X.D (2);\n+         begin\n+            return Mag < 2 ** 63 or else (X.Neg and then Mag = 2 ** 63);\n+         end;\n+      end if;\n+   end Bignum_In_LLI_Range;\n+\n+   ---------------\n+   -- Normalize --\n+   ---------------\n+\n+   function Normalize\n+     (X   : Digit_Vector;\n+      Neg : Boolean := False) return Bignum\n+   is\n+      B : Bignum;\n+      J : Length;\n+\n+   begin\n+      J := X'First;\n+      while J <= X'Last and then X (J) = 0 loop\n+         J := J + 1;\n+      end loop;\n+\n+      B := Allocate_Bignum (X'Last - J + 1);\n+      B.Neg := B.Len > 0 and then Neg;\n+      B.D := X (J .. X'Last);\n+      return B;\n+   end Normalize;\n+\n+   ---------------\n+   -- To_Bignum --\n+   ---------------\n+\n+   function To_Bignum (X : Long_Long_Integer) return Bignum is\n+      R : Bignum;\n+\n+   begin\n+      if X = 0 then\n+         R := Allocate_Bignum (0);\n+\n+      --  One word result\n+\n+      elsif X in -(2 ** 32 - 1) .. +(2 ** 32 - 1) then\n+         R := Allocate_Bignum (1);\n+         R.D (1) := SD (abs (X));\n+\n+      --  Largest negative number annoyance\n+\n+      elsif X = Long_Long_Integer'First then\n+         R := Allocate_Bignum (2);\n+         R.D (1) := 2 ** 31;\n+         R.D (2) := 0;\n+\n+      --  Normal two word case\n+\n+      else\n+         R := Allocate_Bignum (2);\n+         R.D (2) := SD (abs (X) mod Base);\n+         R.D (1) := SD (abs (X) / Base);\n+      end if;\n+\n+      R.Neg := X < 0;\n+      return R;\n+   end To_Bignum;\n+\n+   function To_Bignum (X : Unsigned_64) return Bignum is\n+      R : Bignum;\n+\n+   begin\n+      if X = 0 then\n+         R := Allocate_Bignum (0);\n+\n+      --  One word result\n+\n+      elsif X < 2 ** 32 then\n+         R := Allocate_Bignum (1);\n+         R.D (1) := SD (X);\n+\n+      --  Two word result\n+\n+      else\n+         R := Allocate_Bignum (2);\n+         R.D (2) := SD (X mod Base);\n+         R.D (1) := SD (X / Base);\n+      end if;\n+\n+      R.Neg := False;\n+      return R;\n+   end To_Bignum;\n+\n+   -------------\n+   -- Is_Zero --\n+   -------------\n+\n+   function Is_Zero (X : Bignum) return Boolean is\n+     (X /= null and then X.D = Zero_Data);\n+\n+end System.Generic_Bignums;"}, {"sha": "d9408af1035821650c09a4164383ff43af6a0b7e", "filename": "gcc/ada/libgnat/s-genbig.ads", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fs-genbig.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17f5647c5ed92a114f23d1f92f6bb3d7815bf87/gcc%2Fada%2Flibgnat%2Fs-genbig.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-genbig.ads?ref=f17f5647c5ed92a114f23d1f92f6bb3d7815bf87", "patch": "@@ -0,0 +1,135 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--               S Y S T E M . G E N E R I C _ B I G N U M S                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2012-2019, Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides arbitrary precision signed integer arithmetic\n+--  and can be used either built into the compiler via System.Bignums or to\n+--  implement a default version of Ada.Numerics.Big_Numbers.Big_Integers.\n+\n+--  If Use_Secondary_Stack is True then all Bignum values are allocated on the\n+--  secondary stack. If False, the heap is used and the caller is responsible\n+--  for memory management.\n+\n+with Ada.Unchecked_Conversion;\n+with Interfaces;\n+\n+generic\n+   Use_Secondary_Stack : Boolean;\n+package System.Generic_Bignums is\n+   pragma Preelaborate;\n+\n+   pragma Assert (Long_Long_Integer'Size = 64);\n+   --  This package assumes that Long_Long_Integer size is 64 bit (i.e. that it\n+   --  has a range of -2**63 to 2**63-1). The front end ensures that the mode\n+   --  ELIMINATED is not allowed for overflow checking if this is not the case.\n+\n+   subtype Length is Natural range 0 .. 2 ** 23 - 1;\n+   --  Represent number of words in Digit_Vector\n+\n+   Base : constant := 2 ** 32;\n+   --  Digit vectors use this base\n+\n+   subtype SD is Interfaces.Unsigned_32;\n+   --  Single length digit\n+\n+   type Digit_Vector is array (Length range <>) of SD;\n+   --  Represent digits of a number (most significant digit first)\n+\n+   type Bignum_Data (Len : Length) is record\n+      Neg : Boolean;\n+      --  Set if value is negative, never set for zero\n+\n+      D : Digit_Vector (1 .. Len);\n+      --  Digits of number, most significant first, represented in base\n+      --  2**Base. No leading zeroes are stored, and the value of zero is\n+      --  represented using an empty vector for D.\n+   end record;\n+\n+   for Bignum_Data use record\n+      Len at 0 range 0 .. 23;\n+      Neg at 3 range 0 .. 7;\n+   end record;\n+\n+   type Bignum is access all Bignum_Data;\n+   --  This is the type that is used externally. Possibly this could be a\n+   --  private type, but we leave the structure exposed for now. For one\n+   --  thing it helps with debugging. Note that this package never shares\n+   --  an allocated Bignum value, so for example for X + 0, a copy of X is\n+   --  returned, not X itself.\n+\n+   function To_Bignum is new Ada.Unchecked_Conversion (System.Address, Bignum);\n+   function To_Address is new\n+     Ada.Unchecked_Conversion (Bignum, System.Address);\n+\n+   --  Note: none of the subprograms in this package modify the Bignum_Data\n+   --  records referenced by Bignum arguments of mode IN.\n+\n+   function Big_Add (X, Y : Bignum) return Bignum;  --  \"+\"\n+   function Big_Sub (X, Y : Bignum) return Bignum;  --  \"-\"\n+   function Big_Mul (X, Y : Bignum) return Bignum;  --  \"*\"\n+   function Big_Div (X, Y : Bignum) return Bignum;  --  \"/\"\n+   function Big_Exp (X, Y : Bignum) return Bignum;  --  \"**\"\n+   function Big_Mod (X, Y : Bignum) return Bignum;  --  \"mod\"\n+   function Big_Rem (X, Y : Bignum) return Bignum;  --  \"rem\"\n+   function Big_Neg (X    : Bignum) return Bignum;  --  \"-\"\n+   function Big_Abs (X    : Bignum) return Bignum;  --  \"abs\"\n+   --  Perform indicated arithmetic operation on bignum values. No exception\n+   --  raised except for Div/Mod/Rem by 0 which raises Constraint_Error with\n+   --  an appropriate message.\n+\n+   function Big_EQ  (X, Y : Bignum) return Boolean;  -- \"=\"\n+   function Big_NE  (X, Y : Bignum) return Boolean;  -- \"/=\"\n+   function Big_GE  (X, Y : Bignum) return Boolean;  -- \">=\"\n+   function Big_LE  (X, Y : Bignum) return Boolean;  -- \"<=\"\n+   function Big_GT  (X, Y : Bignum) return Boolean;  --  \">\"\n+   function Big_LT  (X, Y : Bignum) return Boolean;  --  \"<\"\n+   --  Perform indicated comparison on bignums, returning result as Boolean.\n+   --  No exception raised for any input arguments.\n+\n+   function Bignum_In_LLI_Range (X : Bignum) return Boolean;\n+   --  Returns True if the Bignum value is in the range of Long_Long_Integer,\n+   --  so that a call to From_Bignum is guaranteed not to raise an exception.\n+\n+   function To_Bignum (X : Long_Long_Integer) return Bignum;\n+   --  Convert Long_Long_Integer to Bignum. No exception can be raised for any\n+   --  input argument.\n+\n+   function To_Bignum (X : Interfaces.Unsigned_64) return Bignum;\n+   --  Convert Unsigned_64 to Bignum. No exception can be raised for any\n+   --  input argument.\n+\n+   function From_Bignum (X : Bignum) return Long_Long_Integer;\n+   --  Convert Bignum to Long_Long_Integer. Constraint_Error raised with\n+   --  appropriate message if value is out of range of Long_Long_Integer.\n+\n+   function Is_Zero (X : Bignum) return Boolean;\n+   --  Return True if X = 0\n+\n+end System.Generic_Bignums;"}]}