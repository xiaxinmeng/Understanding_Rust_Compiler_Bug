{"sha": "49b91f055dbcf33c0230356a6ff41916c7cac917", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDliOTFmMDU1ZGJjZjMzYzAyMzAzNTZhNmZmNDE5MTZjN2NhYzkxNw==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-09-30T08:23:37Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-09-30T08:23:37Z"}, "message": "In gcc/c-family/: 2010-09-30 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/c-family/:\n2010-09-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * c-lex.c (c_lex_with_flags): Updated comments for CPP_AT_NAME\n        Objective-C/Objective-C++ keywords.\n\nIn gcc/cp/:\n2010-09-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * parser.c (cp_lexer_get_preprocessor_token): Tidied up comments\n        and indentation when finding an Objective-C++ CPP_AT_NAME token.\n\nIn gcc/:\n2010-09-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * c-parser.c (c_lex_one_token): When finding a CPP_AT_NAME\n        Objective-C token, map RID_CLASS to RID_AT_CLASS and similar.\n        (c_parser_external_declaration): Use RID_AT_CLASS\n        instead of RID_CLASS.\n        (c_parser_objc_class_declaration): Same change.\n        (c_parser_objc_try_catch_statement): Use RID_AT_TRY instead of\n        RID_TRY and RID_AT_CATCH instead of RID_CATCH.\n        (c_parser_objc_class_instance_variables): Use RID_AT_PRIVATE\n        instead of RID_PRIVATE, RID_AT_PROTECTED instead of RID_PROTECTED\n        and RID_AT_PUBLIC instead of RID_PUBLIC.\n        (c_parser_statement_after_labels): Use RID_AT_TRY instead of\n        RID_TRY and RID_AT_CATCH instead of RID_CATCH.\n\nFrom-SVN: r164744", "tree": {"sha": "febeddb29ba321d8891cab7a7b66a19df3e27ea9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/febeddb29ba321d8891cab7a7b66a19df3e27ea9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49b91f055dbcf33c0230356a6ff41916c7cac917", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49b91f055dbcf33c0230356a6ff41916c7cac917", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49b91f055dbcf33c0230356a6ff41916c7cac917", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49b91f055dbcf33c0230356a6ff41916c7cac917/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "10ad386ac38c8c9de3e7eb4fcdfaf597c8e1d591", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10ad386ac38c8c9de3e7eb4fcdfaf597c8e1d591", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10ad386ac38c8c9de3e7eb4fcdfaf597c8e1d591"}], "stats": {"total": 94, "additions": 75, "deletions": 19}, "files": [{"sha": "d58cf7ccf1f9bb2fcc82a7a448b3c2b02147f2ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b91f055dbcf33c0230356a6ff41916c7cac917/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b91f055dbcf33c0230356a6ff41916c7cac917/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49b91f055dbcf33c0230356a6ff41916c7cac917", "patch": "@@ -1,3 +1,18 @@\n+2010-09-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* c-parser.c (c_lex_one_token): When finding a CPP_AT_NAME\n+\tObjective-C token, map RID_CLASS to RID_AT_CLASS and similar.\n+\t(c_parser_external_declaration): Use RID_AT_CLASS\n+\tinstead of RID_CLASS.\n+\t(c_parser_objc_class_declaration): Same change.\n+\t(c_parser_objc_try_catch_statement): Use RID_AT_TRY instead of\n+\tRID_TRY and RID_AT_CATCH instead of RID_CATCH.\n+\t(c_parser_objc_class_instance_variables): Use RID_AT_PRIVATE\n+\tinstead of RID_PRIVATE, RID_AT_PROTECTED instead of RID_PROTECTED\n+\tand RID_AT_PUBLIC instead of RID_PUBLIC.\n+\t(c_parser_statement_after_labels): Use RID_AT_TRY instead of\n+\tRID_TRY and RID_AT_CATCH instead of RID_CATCH.\n+\t\n 2010-09-30  Tom G. Christensen <tgc@jupiterrise.com>\n \n \t* doc/install.texi (Binaries): Update link to HP-UX porting centre."}, {"sha": "b895a45852fad9af8a39ee5693875712132538a0", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b91f055dbcf33c0230356a6ff41916c7cac917/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b91f055dbcf33c0230356a6ff41916c7cac917/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=49b91f055dbcf33c0230356a6ff41916c7cac917", "patch": "@@ -1,3 +1,8 @@\n+2010-09-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* c-lex.c (c_lex_with_flags): Updated comments for CPP_AT_NAME\n+\tObjective-C/Objective-C++ keywords.\n+\n 2010-09-29  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tMerge from 'apple/trunk' branch on FSF servers.\t"}, {"sha": "851449fbac437d078357cbaad4a9fb907acd0b93", "filename": "gcc/c-family/c-lex.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b91f055dbcf33c0230356a6ff41916c7cac917/gcc%2Fc-family%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b91f055dbcf33c0230356a6ff41916c7cac917/gcc%2Fc-family%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.c?ref=49b91f055dbcf33c0230356a6ff41916c7cac917", "patch": "@@ -370,6 +370,12 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,\n \t\t  || OBJC_IS_CXX_KEYWORD (C_RID_CODE (*value)))\n \t\t{\n \t\t  type = CPP_AT_NAME;\n+\t\t  /* Note the complication: if we found an OBJC_CXX\n+\t\t     keyword, for example, 'class', we will be\n+\t\t     returning a token of type CPP_AT_NAME and rid\n+\t\t     code RID_CLASS (not RID_AT_CLASS).  The language\n+\t\t     parser needs to convert that to RID_AT_CLASS.\n+\t\t  */\n \t\t  break;\n \t\t}\n \t      /* FALLTHROUGH */"}, {"sha": "564077449e465499299445ac3965ab5cd4b195f9", "filename": "gcc/c-parser.c", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b91f055dbcf33c0230356a6ff41916c7cac917/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b91f055dbcf33c0230356a6ff41916c7cac917/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=49b91f055dbcf33c0230356a6ff41916c7cac917", "patch": "@@ -310,7 +310,25 @@ c_lex_one_token (c_parser *parser, c_token *token)\n     case CPP_AT_NAME:\n       /* This only happens in Objective-C; it must be a keyword.  */\n       token->type = CPP_KEYWORD;\n-      token->keyword = C_RID_CODE (token->value);\n+      switch (C_RID_CODE (token->value))\n+\t{\n+\t  /* Replace 'class' with '@class', 'private' with '@private',\n+\t     etc.  This prevents confusion with the C++ keyword\n+\t     'class', and makes the tokens consistent with other\n+\t     Objective-C 'AT' keywords.  For example '@class' is\n+\t     reported as RID_AT_CLASS which is consistent with\n+\t     '@synchronized', which is reported as\n+\t     RID_AT_SYNCHRONIZED.\n+\t  */\n+\tcase RID_CLASS:     token->keyword = RID_AT_CLASS; break;\n+\tcase RID_PRIVATE:   token->keyword = RID_AT_PRIVATE; break;\n+\tcase RID_PROTECTED: token->keyword = RID_AT_PROTECTED; break;\n+\tcase RID_PUBLIC:    token->keyword = RID_AT_PUBLIC; break;\n+\tcase RID_THROW:     token->keyword = RID_AT_THROW; break;\n+\tcase RID_TRY:       token->keyword = RID_AT_TRY; break;\n+\tcase RID_CATCH:     token->keyword = RID_AT_CATCH; break;\n+\tdefault:            token->keyword = C_RID_CODE (token->value);\n+\t}\n       break;\n     case CPP_COLON:\n     case CPP_COMMA:\n@@ -1106,7 +1124,7 @@ c_parser_external_declaration (c_parser *parser)\n \t  gcc_assert (c_dialect_objc ());\n \t  c_parser_objc_class_definition (parser, NULL_TREE);\n \t  break;\n-\tcase RID_CLASS:\n+\tcase RID_AT_CLASS:\n \t  gcc_assert (c_dialect_objc ());\n \t  c_parser_objc_class_declaration (parser);\n \t  break;\n@@ -4081,7 +4099,7 @@ c_parser_statement_after_labels (c_parser *parser)\n \tcase RID_ASM:\n \t  stmt = c_parser_asm_statement (parser);\n \t  break;\n-\tcase RID_THROW:\n+\tcase RID_AT_THROW:\n \t  gcc_assert (c_dialect_objc ());\n \t  c_parser_consume_token (parser);\n \t  if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n@@ -4097,7 +4115,7 @@ c_parser_statement_after_labels (c_parser *parser)\n \t      goto expect_semicolon;\n \t    }\n \t  break;\n-\tcase RID_TRY:\n+\tcase RID_AT_TRY:\n \t  gcc_assert (c_dialect_objc ());\n \t  c_parser_objc_try_catch_statement (parser);\n \t  break;\n@@ -6483,19 +6501,19 @@ c_parser_objc_class_instance_variables (c_parser *parser)\n \t  break;\n \t}\n       /* Parse any objc-visibility-spec.  */\n-      if (c_parser_next_token_is_keyword (parser, RID_PRIVATE))\n+      if (c_parser_next_token_is_keyword (parser, RID_AT_PRIVATE))\n \t{\n \t  c_parser_consume_token (parser);\n \t  objc_set_visibility (2);\n \t  continue;\n \t}\n-      else if (c_parser_next_token_is_keyword (parser, RID_PROTECTED))\n+      else if (c_parser_next_token_is_keyword (parser, RID_AT_PROTECTED))\n \t{\n \t  c_parser_consume_token (parser);\n \t  objc_set_visibility (0);\n \t  continue;\n \t}\n-      else if (c_parser_next_token_is_keyword (parser, RID_PUBLIC))\n+      else if (c_parser_next_token_is_keyword (parser, RID_AT_PUBLIC))\n \t{\n \t  c_parser_consume_token (parser);\n \t  objc_set_visibility (1);\n@@ -6530,7 +6548,7 @@ static void\n c_parser_objc_class_declaration (c_parser *parser)\n {\n   tree list = NULL_TREE;\n-  gcc_assert (c_parser_next_token_is_keyword (parser, RID_CLASS));\n+  gcc_assert (c_parser_next_token_is_keyword (parser, RID_AT_CLASS));\n   c_parser_consume_token (parser);\n   /* Any identifiers, including those declared as type names, are OK\n      here.  */\n@@ -7052,12 +7070,12 @@ c_parser_objc_try_catch_statement (c_parser *parser)\n {\n   location_t loc;\n   tree stmt;\n-  gcc_assert (c_parser_next_token_is_keyword (parser, RID_TRY));\n+  gcc_assert (c_parser_next_token_is_keyword (parser, RID_AT_TRY));\n   c_parser_consume_token (parser);\n   loc = c_parser_peek_token (parser)->location;\n   stmt = c_parser_compound_statement (parser);\n   objc_begin_try_stmt (loc, stmt);\n-  while (c_parser_next_token_is_keyword (parser, RID_CATCH))\n+  while (c_parser_next_token_is_keyword (parser, RID_AT_CATCH))\n     {\n       struct c_parm *parm;\n       c_parser_consume_token (parser);"}, {"sha": "4b0dd12638e7c9cd4a55ece4386f8602bdb3302e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b91f055dbcf33c0230356a6ff41916c7cac917/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b91f055dbcf33c0230356a6ff41916c7cac917/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=49b91f055dbcf33c0230356a6ff41916c7cac917", "patch": "@@ -1,3 +1,8 @@\n+2010-09-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* parser.c (cp_lexer_get_preprocessor_token): Tidied up comments\n+\tand indentation when finding an Objective-C++ CPP_AT_NAME token.\n+\n 2010-09-29  Richard Guenther  <rguenther@suse.de>\n \n \t* cp-tree.h (CP_DECL_CONTEXT): Check DECL_FILE_SCOPE_P."}, {"sha": "d9cc7271b84471a0735b68ff9a4215f888210ba7", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b91f055dbcf33c0230356a6ff41916c7cac917/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b91f055dbcf33c0230356a6ff41916c7cac917/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=49b91f055dbcf33c0230356a6ff41916c7cac917", "patch": "@@ -565,21 +565,28 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer, cp_token *token)\n \t  token->keyword = RID_MAX;\n \t}\n     }\n-  /* Handle Objective-C++ keywords.  */\n   else if (token->type == CPP_AT_NAME)\n     {\n+      /* This only happens in Objective-C++; it must be a keyword.  */\n       token->type = CPP_KEYWORD;\n       switch (C_RID_CODE (token->u.value))\n \t{\n-\t/* Map 'class' to '@class', 'private' to '@private', etc.  */\n-\tcase RID_CLASS: token->keyword = RID_AT_CLASS; break;\n-\tcase RID_PRIVATE: token->keyword = RID_AT_PRIVATE; break;\n+\t  /* Replace 'class' with '@class', 'private' with '@private',\n+\t     etc.  This prevents confusion with the C++ keyword\n+\t     'class', and makes the tokens consistent with other\n+\t     Objective-C 'AT' keywords.  For example '@class' is\n+\t     reported as RID_AT_CLASS which is consistent with\n+\t     '@synchronized', which is reported as\n+\t     RID_AT_SYNCHRONIZED.\n+\t  */\n+\tcase RID_CLASS:     token->keyword = RID_AT_CLASS; break;\n+\tcase RID_PRIVATE:   token->keyword = RID_AT_PRIVATE; break;\n \tcase RID_PROTECTED: token->keyword = RID_AT_PROTECTED; break;\n-\tcase RID_PUBLIC: token->keyword = RID_AT_PUBLIC; break;\n-\tcase RID_THROW: token->keyword = RID_AT_THROW; break;\n-\tcase RID_TRY: token->keyword = RID_AT_TRY; break;\n-\tcase RID_CATCH: token->keyword = RID_AT_CATCH; break;\n-\tdefault: token->keyword = C_RID_CODE (token->u.value);\n+\tcase RID_PUBLIC:    token->keyword = RID_AT_PUBLIC; break;\n+\tcase RID_THROW:     token->keyword = RID_AT_THROW; break;\n+\tcase RID_TRY:       token->keyword = RID_AT_TRY; break;\n+\tcase RID_CATCH:     token->keyword = RID_AT_CATCH; break;\n+\tdefault:            token->keyword = C_RID_CODE (token->u.value);\n \t}\n     }\n   else if (token->type == CPP_PRAGMA)"}]}