{"sha": "7e8176d77891d6bfb95844e3918690ccbfcc7b71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U4MTc2ZDc3ODkxZDZiZmI5NTg0NGUzOTE4NjkwY2NiZmNjN2I3MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-07-31T01:13:08Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-07-31T01:13:08Z"}, "message": "c-typeck.c (initializer_constant_valid_p): Move ...\n\n        * c-typeck.c (initializer_constant_valid_p): Move ...\n        * c-common.c (initializer_constant_valid_p): ... here.  Use\n        FOO_TYPE_P instead of tests against TREE_CODE.  Allow subtraction\n        of label addresses.\n        * c-common.h (initializer_constant_valid_p): Declare.\n        * c-tree.h (initializer_constant_valid_p): Remove.\n\nFrom-SVN: r28349", "tree": {"sha": "2f3e1a3cf22e4e54e7419196de2cc7403340bbb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f3e1a3cf22e4e54e7419196de2cc7403340bbb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e8176d77891d6bfb95844e3918690ccbfcc7b71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e8176d77891d6bfb95844e3918690ccbfcc7b71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e8176d77891d6bfb95844e3918690ccbfcc7b71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e8176d77891d6bfb95844e3918690ccbfcc7b71/comments", "author": null, "committer": null, "parents": [{"sha": "96a0a146e23185b9e1dc2f369781ea88efd4120c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96a0a146e23185b9e1dc2f369781ea88efd4120c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96a0a146e23185b9e1dc2f369781ea88efd4120c"}], "stats": {"total": 307, "additions": 167, "deletions": 140}, "files": [{"sha": "55dd80940afc355e6fb9139a38af54585b6f29f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8176d77891d6bfb95844e3918690ccbfcc7b71/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8176d77891d6bfb95844e3918690ccbfcc7b71/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e8176d77891d6bfb95844e3918690ccbfcc7b71", "patch": "@@ -1,3 +1,12 @@\n+1999-07-30  Richard Henderson  <rth@cygnus.com>\n+\n+\t* c-typeck.c (initializer_constant_valid_p): Move ...\n+\t* c-common.c (initializer_constant_valid_p): ... here.  Use \n+\tFOO_TYPE_P instead of tests against TREE_CODE.  Allow subtraction\n+\tof label addresses.\n+\t* c-common.h (initializer_constant_valid_p): Declare.\n+\t* c-tree.h (initializer_constant_valid_p): Remove.\n+\n Fri Jul 30 16:33:42 1999  Mathias Froehlich  <frohlich@na.uni-tuebingen.de>\n \n \t* config/i386/sol2-c1.asm: Align the stack."}, {"sha": "137d1d3d9f3ba48d19a96ff7bc841b8471f20bb0", "filename": "gcc/c-common.c", "status": "modified", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8176d77891d6bfb95844e3918690ccbfcc7b71/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8176d77891d6bfb95844e3918690ccbfcc7b71/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=7e8176d77891d6bfb95844e3918690ccbfcc7b71", "patch": "@@ -3767,3 +3767,159 @@ build_va_arg (expr, type)\n {\n   return build1 (VA_ARG_EXPR, type, expr);\n }\n+\n+/* Return nonzero if VALUE is a valid constant-valued expression\n+   for use in initializing a static variable; one that can be an\n+   element of a \"constant\" initializer.\n+\n+   Return null_pointer_node if the value is absolute;\n+   if it is relocatable, return the variable that determines the relocation.\n+   We assume that VALUE has been folded as much as possible;\n+   therefore, we do not need to check for such things as\n+   arithmetic-combinations of integers.  */\n+\n+tree\n+initializer_constant_valid_p (value, endtype)\n+     tree value;\n+     tree endtype;\n+{\n+  switch (TREE_CODE (value))\n+    {\n+    case CONSTRUCTOR:\n+      if ((TREE_CODE (TREE_TYPE (value)) == UNION_TYPE\n+\t   || TREE_CODE (TREE_TYPE (value)) == RECORD_TYPE)\n+\t  && TREE_CONSTANT (value)\n+\t  && CONSTRUCTOR_ELTS (value))\n+\treturn\n+\t  initializer_constant_valid_p (TREE_VALUE (CONSTRUCTOR_ELTS (value)),\n+\t\t\t\t\tendtype);\n+\t\n+      return TREE_STATIC (value) ? null_pointer_node : 0;\n+\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case STRING_CST:\n+    case COMPLEX_CST:\n+      return null_pointer_node;\n+\n+    case ADDR_EXPR:\n+      return TREE_OPERAND (value, 0);\n+\n+    case NON_LVALUE_EXPR:\n+      return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n+\n+    case CONVERT_EXPR:\n+    case NOP_EXPR:\n+      /* Allow conversions between pointer types.  */\n+      if (POINTER_TYPE_P (TREE_TYPE (value))\n+\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n+\n+      /* Allow conversions between real types.  */\n+      if (FLOAT_TYPE_P (TREE_TYPE (value))\n+\t  && FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n+\n+      /* Allow length-preserving conversions between integer types.  */\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (value))\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0)))\n+\t  && (TYPE_PRECISION (TREE_TYPE (value))\n+\t      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n+\n+      /* Allow conversions between other integer types only if\n+\t explicit value.  */\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (value))\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))\n+\t{\n+\t  tree inner = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t\t     endtype);\n+\t  if (inner == null_pointer_node)\n+\t    return null_pointer_node;\n+\t  break;\n+\t}\n+\n+      /* Allow (int) &foo provided int is as wide as a pointer.  */\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (value))\n+\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0)))\n+\t  && (TYPE_PRECISION (TREE_TYPE (value))\n+\t      >= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t     endtype);\n+\n+      /* Likewise conversions from int to pointers, but also allow\n+\t conversions from 0.  */\n+      if (POINTER_TYPE_P (TREE_TYPE (value))\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))\n+\t{\n+\t  if (integer_zerop (TREE_OPERAND (value, 0)))\n+\t    return null_pointer_node;\n+\t  else if (TYPE_PRECISION (TREE_TYPE (value))\n+\t\t   <= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0))))\n+\t    return initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t\t endtype);\n+\t}\n+\n+      /* Allow conversions to union types if the value inside is okay.  */\n+      if (TREE_CODE (TREE_TYPE (value)) == UNION_TYPE)\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t     endtype);\n+      break;\n+\n+    case PLUS_EXPR:\n+      if (! INTEGRAL_TYPE_P (endtype)\n+\t  || TYPE_PRECISION (endtype) >= POINTER_SIZE)\n+        {\n+\t  tree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t\t      endtype);\n+\t  tree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n+\t\t\t\t\t\t      endtype);\n+\t  /* If either term is absolute, use the other terms relocation.  */\n+\t  if (valid0 == null_pointer_node)\n+\t    return valid1;\n+\t  if (valid1 == null_pointer_node)\n+\t    return valid0;\n+        }\n+      break;\n+\n+    case MINUS_EXPR:\n+      if (! INTEGRAL_TYPE_P (endtype)\n+\t  || TYPE_PRECISION (endtype) >= POINTER_SIZE)\n+\t{\n+\t  tree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t\t      endtype);\n+\t  tree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n+\t\t\t\t\t\t      endtype);\n+\t  /* Win if second argument is absolute.  */\n+\t  if (valid1 == null_pointer_node)\n+\t    return valid0;\n+\t  /* Win if both arguments have the same relocation.\n+\t     Then the value is absolute.  */\n+\t  if (valid0 == valid1)\n+\t    return null_pointer_node;\n+\t}\n+\n+      /* Support differences between labels.  */\n+      if (INTEGRAL_TYPE_P (endtype))\n+\t{\n+\t  tree op0, op1;\n+\t  op0 = TREE_OPERAND (value, 0);\n+\t  op1 = TREE_OPERAND (value, 1);\n+\t  STRIP_NOPS (op0);\n+\t  STRIP_NOPS (op1);\n+\n+\t  if (TREE_CODE (op0) == ADDR_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (op0, 0)) == LABEL_DECL\n+\t      && TREE_CODE (op1) == ADDR_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (op1, 0)) == LABEL_DECL)\n+\t    return null_pointer_node;\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return 0;\n+}\n+"}, {"sha": "ab0cdecbd37484104df71eafa343fc37694fc3c9", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8176d77891d6bfb95844e3918690ccbfcc7b71/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8176d77891d6bfb95844e3918690ccbfcc7b71/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=7e8176d77891d6bfb95844e3918690ccbfcc7b71", "patch": "@@ -190,3 +190,5 @@ extern tree builtin_function\t\t\tPROTO((const char *, tree, enum built_in_function\n extern void c_common_nodes_and_builtins\t\tPROTO((int, int, int));\n \n extern tree build_va_arg\t\t\tPROTO((tree, tree));\n+\n+extern tree initializer_constant_valid_p\tPROTO((tree, tree));"}, {"sha": "8e5aa73ac267416b1f73e8c1f9040c1a1d45cac5", "filename": "gcc/c-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8176d77891d6bfb95844e3918690ccbfcc7b71/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8176d77891d6bfb95844e3918690ccbfcc7b71/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=7e8176d77891d6bfb95844e3918690ccbfcc7b71", "patch": "@@ -282,7 +282,6 @@ extern tree build_compound_expr                 PROTO((tree));\n extern tree build_c_cast                        PROTO((tree, tree));\n extern tree build_modify_expr                   PROTO((tree, enum tree_code,\n \t\t\t\t\t\t       tree));\n-extern tree initializer_constant_valid_p\tPROTO((tree, tree));\n extern void store_init_value                    PROTO((tree, tree));\n extern void error_init\t\t\t\tPROTO((const char *));\n extern void pedwarn_init\t\t\tPROTO((const char *));"}, {"sha": "6d4c7df75fe8f6bf64650254e6ba1f5169d2c384", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8176d77891d6bfb95844e3918690ccbfcc7b71/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8176d77891d6bfb95844e3918690ccbfcc7b71/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=7e8176d77891d6bfb95844e3918690ccbfcc7b71", "patch": "@@ -4246,145 +4246,6 @@ warn_for_assignment (msgid, opname, function, argnum)\n   pedwarn (msgid, opname);\n }\n \f\n-/* Return nonzero if VALUE is a valid constant-valued expression\n-   for use in initializing a static variable; one that can be an\n-   element of a \"constant\" initializer.\n-\n-   Return null_pointer_node if the value is absolute;\n-   if it is relocatable, return the variable that determines the relocation.\n-   We assume that VALUE has been folded as much as possible;\n-   therefore, we do not need to check for such things as\n-   arithmetic-combinations of integers.  */\n-\n-tree\n-initializer_constant_valid_p (value, endtype)\n-     tree value;\n-     tree endtype;\n-{\n-  switch (TREE_CODE (value))\n-    {\n-    case CONSTRUCTOR:\n-      if ((TREE_CODE (TREE_TYPE (value)) == UNION_TYPE\n-\t   || TREE_CODE (TREE_TYPE (value)) == RECORD_TYPE)\n-\t  && TREE_CONSTANT (value)\n-\t  && CONSTRUCTOR_ELTS (value))\n-\treturn\n-\t  initializer_constant_valid_p (TREE_VALUE (CONSTRUCTOR_ELTS (value)),\n-\t\t\t\t\tendtype);\n-\t\n-      return TREE_STATIC (value) ? null_pointer_node : 0;\n-\n-    case INTEGER_CST:\n-    case REAL_CST:\n-    case STRING_CST:\n-    case COMPLEX_CST:\n-      return null_pointer_node;\n-\n-    case ADDR_EXPR:\n-      return TREE_OPERAND (value, 0);\n-\n-    case NON_LVALUE_EXPR:\n-      return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-\n-    case CONVERT_EXPR:\n-    case NOP_EXPR:\n-      /* Allow conversions between pointer types.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == POINTER_TYPE)\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-\n-      /* Allow conversions between real types.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == REAL_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == REAL_TYPE)\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-\n-      /* Allow length-preserving conversions between integer types.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE\n-\t  && (TYPE_PRECISION (TREE_TYPE (value))\n-\t      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-\n-      /* Allow conversions between other integer types only if\n-\t explicit value.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE)\n-\t{\n-\t  tree inner = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t     endtype);\n-\t  if (inner == null_pointer_node)\n-\t    return null_pointer_node;\n-\t  return 0;\n-\t}\n-\n-      /* Allow (int) &foo provided int is as wide as a pointer.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == POINTER_TYPE\n-\t  && (TYPE_PRECISION (TREE_TYPE (value))\n-\t      >= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t     endtype);\n-\n-      /* Likewise conversions from int to pointers, but also allow\n-\t conversions from 0.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE)\n-\t{\n-\t  if (integer_zerop (TREE_OPERAND (value, 0)))\n-\t    return null_pointer_node;\n-\t  else if (TYPE_PRECISION (TREE_TYPE (value))\n-\t\t   <= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0))))\n-\t    return initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t endtype);\n-\t}\n-\n-      /* Allow conversions to union types if the value inside is okay.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == UNION_TYPE)\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t     endtype);\n-      return 0;\n-\n-    case PLUS_EXPR:\n-      if (TREE_CODE (endtype) == INTEGER_TYPE\n-\t  && TYPE_PRECISION (endtype) < POINTER_SIZE)\n-\treturn 0;\n-      {\n-\ttree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t    endtype);\n-\ttree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n-\t\t\t\t\t\t    endtype);\n-\t/* If either term is absolute, use the other terms relocation.  */\n-\tif (valid0 == null_pointer_node)\n-\t  return valid1;\n-\tif (valid1 == null_pointer_node)\n-\t  return valid0;\n-\treturn 0;\n-      }\n-\n-    case MINUS_EXPR:\n-      if (TREE_CODE (endtype) == INTEGER_TYPE\n-\t  && TYPE_PRECISION (endtype) < POINTER_SIZE)\n-\treturn 0;\n-      {\n-\ttree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t    endtype);\n-\ttree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n-\t\t\t\t\t\t    endtype);\n-\t/* Win if second argument is absolute.  */\n-\tif (valid1 == null_pointer_node)\n-\t  return valid0;\n-\t/* Win if both arguments have the same relocation.\n-\t   Then the value is absolute.  */\n-\tif (valid0 == valid1)\n-\t  return null_pointer_node;\n-\treturn 0;\n-      }\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n /* If VALUE is a compound expr all of whose expressions are constant, then\n    return its value.  Otherwise, return error_mark_node.\n "}]}