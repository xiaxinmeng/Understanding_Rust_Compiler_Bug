{"sha": "89b578be68dd3d91e551c3ba922f054ead36c4e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODliNTc4YmU2OGRkM2Q5MWU1NTFjM2JhOTIyZjA1NGVhZDM2YzRlNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-07-08T04:32:27Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-07-08T04:32:27Z"}, "message": "cp-tree.h (saved_scope): Remove x_previous_class_type and x_previous_class_values...\n\n\t* cp-tree.h (saved_scope): Remove x_previous_class_type and\n\tx_previous_class_values; add x_previous_class_level.\n\t(previous_class_type): Remove.\n\t(previous_class_values): Remove.\n\t(previous_class_level): New macro.\n\t* class.c (pushclass): Restore the identifier cache more\n\texpeditiously.\n\t(invalidate_class_lookup_cache): Use vector for class_shadowed and\n\tprevious_class_values.\n\t* decl.c (poplevel): Likewise.\n\t* name-lookup.c (cxx_binding_init): New function.\n\t(cxx_binding_make): Use it.\n\t(push_binding): For a binding in a class level, use a vector of\n\tcp_class_binding nodes.\n\t(push_binding_level): New function.\n\t(begin_scope): Use it.\n\t(leave_scope): Do not put class binding levels on the free list.\n\t(print_binding_level): Adjust for the fact that class_shadowed is\n\ta vector.\n\t(poplevel_class): Likewise.\n\t(clear_identifier_class_values): Likewise.\n\t(push_class_level_binding): Likewise.\n\t(set_class_shadows): Remove.\n\t(store_binding): New function.\n\t(store_class_bindings): New function.\n\t(push_to_top_level): Use store_class_bindings as appropriate.\n\t(pop_from_top_level): Use previous_class_level, not\n\tprevious_class_type.\n\t* name-lookup.h (cp_class_binding): New type.\n\t(cp_binding_level): Use a vector object for class_shadowed.\n\t(push_binding_level): Declare.\n\t(set_class_shadows): Remove.\n\nFrom-SVN: r84259", "tree": {"sha": "b704620d1b4bd63427c4b884a49c7ece575dd1e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b704620d1b4bd63427c4b884a49c7ece575dd1e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89b578be68dd3d91e551c3ba922f054ead36c4e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89b578be68dd3d91e551c3ba922f054ead36c4e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89b578be68dd3d91e551c3ba922f054ead36c4e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89b578be68dd3d91e551c3ba922f054ead36c4e4/comments", "author": null, "committer": null, "parents": [{"sha": "beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7"}], "stats": {"total": 397, "additions": 259, "deletions": 138}, "files": [{"sha": "5d2aae04082eccc52194cb7c30cc20b128540ea0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b578be68dd3d91e551c3ba922f054ead36c4e4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b578be68dd3d91e551c3ba922f054ead36c4e4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=89b578be68dd3d91e551c3ba922f054ead36c4e4", "patch": "@@ -1,3 +1,38 @@\n+2004-07-07  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (saved_scope): Remove x_previous_class_type and\n+\tx_previous_class_values; add x_previous_class_level.\n+\t(previous_class_type): Remove.\n+\t(previous_class_values): Remove.\n+\t(previous_class_level): New macro.\n+\t* class.c (pushclass): Restore the identifier cache more\n+\texpeditiously.\n+\t(invalidate_class_lookup_cache): Use vector for class_shadowed and\n+\tprevious_class_values.\n+\t* decl.c (poplevel): Likewise.\n+\t* name-lookup.c (cxx_binding_init): New function.\n+\t(cxx_binding_make): Use it.\n+\t(push_binding): For a binding in a class level, use a vector of\n+\tcp_class_binding nodes.\n+\t(push_binding_level): New function.\n+\t(begin_scope): Use it.\n+\t(leave_scope): Do not put class binding levels on the free list.\n+\t(print_binding_level): Adjust for the fact that class_shadowed is\n+\ta vector.\n+\t(poplevel_class): Likewise.\n+\t(clear_identifier_class_values): Likewise.\n+\t(push_class_level_binding): Likewise.\n+\t(set_class_shadows): Remove.\n+\t(store_binding): New function.\n+\t(store_class_bindings): New function.\n+\t(push_to_top_level): Use store_class_bindings as appropriate.\n+\t(pop_from_top_level): Use previous_class_level, not\n+\tprevious_class_type.\n+\t* name-lookup.h (cp_class_binding): New type.\n+\t(cp_binding_level): Use a vector object for class_shadowed.\n+\t(push_binding_level): Declare.\n+\t(set_class_shadows): Remove.\n+\n 2004-07-07  Andrew Pinski  <apinski@apple.com>\n \n \t* class.c (instantiate_type): BUFFER_REF is dead."}, {"sha": "1f3b22a7ddcb8bd213da0c02f64051cbe07dede6", "filename": "gcc/cp/class.c", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b578be68dd3d91e551c3ba922f054ead36c4e4/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b578be68dd3d91e551c3ba922f054ead36c4e4/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=89b578be68dd3d91e551c3ba922f054ead36c4e4", "patch": "@@ -5486,9 +5486,8 @@ pushclass (tree type)\n \t\t\t      ? access_private_node \n \t\t\t      : access_public_node);\n \n-  if (previous_class_type != NULL_TREE\n-      && (type != previous_class_type \n-\t  || !COMPLETE_TYPE_P (previous_class_type))\n+  if (previous_class_level\n+      && type != previous_class_level->this_entity\n       && current_class_depth == 1)\n     {\n       /* Forcibly remove any old class remnants.  */\n@@ -5500,10 +5499,11 @@ pushclass (tree type)\n   if (current_class_depth > 1)\n     clear_identifier_class_values ();\n \n-  pushlevel_class ();\n-\n-  if (type != previous_class_type || current_class_depth > 1)\n+  if (!previous_class_level \n+      || type != previous_class_level->this_entity\n+      || current_class_depth > 1)\n     {\n+      pushlevel_class ();\n       push_class_decls (type);\n       if (CLASSTYPE_TEMPLATE_INFO (type) && !CLASSTYPE_USE_TEMPLATE (type))\n \t{\n@@ -5520,22 +5520,33 @@ pushclass (tree type)\n     }\n   else\n     {\n-      tree item;\n+      cp_class_binding *cb;\n+      size_t i;\n \n       /* We are re-entering the same class we just left, so we don't\n \t have to search the whole inheritance matrix to find all the\n \t decls to bind again.  Instead, we install the cached\n \t class_shadowed list, and walk through it binding names and\n \t setting up IDENTIFIER_TYPE_VALUEs.  */\n-      set_class_shadows (previous_class_values);\n-      for (item = previous_class_values; item; item = TREE_CHAIN (item))\n+      push_binding_level (previous_class_level);\n+      class_binding_level = previous_class_level;\n+      for (i = 0; \n+\t   (cb = VEC_iterate (cp_class_binding, \n+\t\t\t      previous_class_level->class_shadowed,\n+\t\t\t      i));\n+\t   ++i)\n \t{\n-\t  tree id = TREE_PURPOSE (item);\n-\t  tree decl = TREE_TYPE (item);\n-\t  \n-\t  push_class_binding (id, decl);\n-\t  if (TREE_CODE (decl) == TYPE_DECL)\n-\t    set_identifier_type_value (id, decl);\n+\t  tree id;\n+\t  tree type_decl;\n+\n+\t  id = cb->identifier;\n+\t  cb->base.previous = IDENTIFIER_BINDING (id);\n+\t  IDENTIFIER_BINDING (id) = &cb->base;\n+\t  type_decl = cb->base.value;\n+\t  if (!type_decl || TREE_CODE (type_decl) != TYPE_DECL)\n+\t    type_decl = cb->base.type;\n+\t  if (type_decl && TREE_CODE (type_decl) == TYPE_DECL)\n+\t    set_identifier_type_value (id, type_decl);\n \t}\n       unuse_fields (type);\n     }\n@@ -5551,14 +5562,17 @@ pushclass (tree type)\n void\n invalidate_class_lookup_cache (void)\n {\n-  tree t;\n+  size_t i;\n+  cp_class_binding *cb;\n   \n   /* The IDENTIFIER_CLASS_VALUEs are no longer valid.  */\n-  for (t = previous_class_values; t; t = TREE_CHAIN (t))\n-    IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (t)) = NULL_TREE;\n+  for (i = 0;\n+       (cb = VEC_iterate (cp_class_binding, \n+\t\t\t  previous_class_level->class_shadowed, i));\n+       ++i)\n+    IDENTIFIER_CLASS_VALUE (cb->identifier) = NULL_TREE;\n \n-  previous_class_values = NULL_TREE;\n-  previous_class_type = NULL_TREE;\n+  previous_class_level = NULL;\n }\n  \n /* Get out of the current class scope. If we were in a class scope"}, {"sha": "15cfd8457f8de0e5e034f212423684b2eea2f48e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b578be68dd3d91e551c3ba922f054ead36c4e4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b578be68dd3d91e551c3ba922f054ead36c4e4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=89b578be68dd3d91e551c3ba922f054ead36c4e4", "patch": "@@ -640,8 +640,7 @@ struct saved_scope GTY(())\n   varray_type lang_base;\n   tree lang_name;\n   tree template_parms;\n-  tree x_previous_class_type;\n-  tree x_previous_class_values;\n+  struct cp_binding_level *x_previous_class_level;\n   tree x_saved_tree;\n \n   HOST_WIDE_INT x_processing_template_decl;\n@@ -694,16 +693,10 @@ struct saved_scope GTY(())\n #define processing_specialization scope_chain->x_processing_specialization\n #define processing_explicit_instantiation scope_chain->x_processing_explicit_instantiation\n \n-/* _TYPE: the previous type that was a class */\n+/* The cached class binding level, from the most recently exited\n+   class, or NULL if none.  */\n \n-#define previous_class_type scope_chain->x_previous_class_type\n-\n-/* This is a copy of the class_shadowed list of the previous class\n-   binding contour when at global scope.  It's used to reset\n-   IDENTIFIER_CLASS_VALUEs when entering another class scope (i.e. a\n-   cache miss).  */\n-\n-#define previous_class_values scope_chain->x_previous_class_values\n+#define previous_class_level scope_chain->x_previous_class_level\n \n /* A list of private types mentioned, for deferred access checking.  */\n "}, {"sha": "f17f91cc4b5d34b8143c02e8011d5f3b68eea5e3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b578be68dd3d91e551c3ba922f054ead36c4e4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b578be68dd3d91e551c3ba922f054ead36c4e4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=89b578be68dd3d91e551c3ba922f054ead36c4e4", "patch": "@@ -443,7 +443,8 @@ poplevel (int keep, int reverse, int functionbody)\n \t\t       ? ((functionbody = 0), tmp) : functionbody);\n   subblocks = functionbody >= 0 ? current_binding_level->blocks : 0;\n \n-  my_friendly_assert (!current_binding_level->class_shadowed,\n+  my_friendly_assert (VEC_length(cp_class_binding, \n+\t\t\t\t current_binding_level->class_shadowed) == 0,\n \t\t      19990414);\n \n   /* We used to use KEEP == 2 to indicate that the new block should go"}, {"sha": "879d2bf6897fb075603d347fd5d36c6e33908e66", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 173, "deletions": 104, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b578be68dd3d91e551c3ba922f054ead36c4e4/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b578be68dd3d91e551c3ba922f054ead36c4e4/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=89b578be68dd3d91e551c3ba922f054ead36c4e4", "patch": "@@ -328,6 +328,17 @@ binding_table_foreach (binding_table table, bt_foreach_proc proc, void *data)\n \n static GTY((deletable)) cxx_binding *free_bindings;\n \n+/* Initialize VALUE and TYPE field for BINDING, and set the PREVIOUS\n+   field to NULL.  */\n+\n+static inline void\n+cxx_binding_init (cxx_binding *binding, tree value, tree type)\n+{\n+  binding->value = value;\n+  binding->type = type;\n+  binding->previous = NULL;\n+}\n+\n /* (GC)-allocate a binding object with VALUE and TYPE member initialized.  */\n \n static cxx_binding *\n@@ -342,9 +353,7 @@ cxx_binding_make (tree value, tree type)\n   else\n     binding = ggc_alloc (sizeof (cxx_binding));\n \n-  binding->value = value;\n-  binding->type = type;\n-  binding->previous = NULL;\n+  cxx_binding_init (binding, value, type);\n \n   return binding;\n }\n@@ -365,8 +374,31 @@ cxx_binding_free (cxx_binding *binding)\n static void\n push_binding (tree id, tree decl, cxx_scope* level)\n {\n-   cxx_binding *binding = cxx_binding_make (decl, NULL);\n+  cxx_binding *binding;\n \n+  if (level != class_binding_level)\n+    binding = cxx_binding_make (decl, NULL_TREE);\n+  else\n+    {\n+      cp_class_binding *cb;\n+      size_t length;\n+      size_t i;\n+      bool need_fixup;\n+\n+      length = VEC_length (cp_class_binding, level->class_shadowed);\n+      need_fixup = (length && length == level->class_shadowed->alloc);\n+      cb = VEC_safe_push (cp_class_binding, level->class_shadowed, NULL);\n+      cb->identifier = id;\n+      binding = &cb->base;\n+      cxx_binding_init (binding, decl, NULL_TREE);\n+      if (need_fixup)\n+\tfor (i = 0; i < length; ++i)\n+\t  {\n+\t    cb = VEC_index (cp_class_binding, level->class_shadowed, i);\n+\t    IDENTIFIER_BINDING (cb->identifier) = &cb->base;\n+\t  }\n+    }\n+\t\t\t      \n   /* Now, fill in the binding information.  */\n   binding->previous = IDENTIFIER_BINDING (id);\n   binding->scope = level;\n@@ -1261,6 +1293,26 @@ namespace_scope_ht_size (tree ns)\n \n static GTY((deletable)) struct cp_binding_level *free_binding_level;\n \n+/* Insert SCOPE as the innermost binding level.  */\n+\n+void\n+push_binding_level (struct cp_binding_level *scope)\n+{\n+  /* Add it to the front of currently active scopes stack.  */\n+  scope->level_chain = current_binding_level;\n+  current_binding_level = scope;\n+  keep_next_level_flag = false;\n+\n+  if (ENABLE_SCOPE_CHECKING)\n+    {\n+      scope->binding_depth = binding_depth;\n+      indent (binding_depth);\n+      cxx_scope_debug (scope, input_line, \"push\");\n+      is_class_level = 0;\n+      binding_depth++;\n+    }\n+}\n+\n /* Create a new KIND scope and make it the top of the active scopes stack.\n    ENTITY is the scope of the associated C++ entity (namespace, class,\n    function); it is NULL otherwise.  */\n@@ -1319,19 +1371,7 @@ begin_scope (scope_kind kind, tree entity)\n     }\n   scope->kind = kind;\n \n-  /* Add it to the front of currently active scopes stack.  */\n-  scope->level_chain = current_binding_level;\n-  current_binding_level = scope;\n-  keep_next_level_flag = false;\n-\n-  if (ENABLE_SCOPE_CHECKING)\n-    {\n-      scope->binding_depth = binding_depth;\n-      indent (binding_depth);\n-      cxx_scope_debug (scope, input_line, \"push\");\n-      is_class_level = 0;\n-      binding_depth++;\n-    }\n+  push_binding_level (scope);\n \n   return scope;\n }\n@@ -1366,11 +1406,13 @@ leave_scope (void)\n   /* Move one nesting level up.  */\n   current_binding_level = scope->level_chain;\n \n-  /* Namespace-scopes are left most probably temporarily, not completely;\n-     they can be reopen later, e.g. in namespace-extension or any name\n-     binding activity that requires us to resume a namespace.  For other\n+  /* Namespace-scopes are left most probably temporarily, not\n+     completely; they can be reopen later, e.g. in namespace-extension\n+     or any name binding activity that requires us to resume a\n+     namespace.  For classes, we cache some binding levels.  For other\n      scopes, we just make the structure available for reuse.  */\n-  if (scope->kind != sk_namespace)\n+  if (scope->kind != sk_namespace\n+      && scope->kind != sk_class)\n     {\n       scope->level_chain = free_binding_level;\n       if (scope->kind == sk_class)\n@@ -1628,13 +1670,17 @@ print_binding_level (struct cp_binding_level* lvl)\n       if (i)\n \tfprintf (stderr, \"\\n\");\n     }\n-  if (lvl->class_shadowed)\n+  if (VEC_length (cp_class_binding, lvl->class_shadowed))\n     {\n+      size_t i;\n+      cp_class_binding *b;\n       fprintf (stderr, \" class-shadowed:\");\n-      for (t = lvl->class_shadowed; t; t = TREE_CHAIN (t))\n-\t{\n-\t  fprintf (stderr, \" %s \", IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n-\t}\n+      for (i = 0; \n+\t   (b = VEC_iterate(cp_class_binding, \n+\t\t\t    lvl->class_shadowed,\n+\t\t\t    i));\n+\t   ++i) \n+\tfprintf (stderr, \" %s \", IDENTIFIER_POINTER (b->identifier));\n       fprintf (stderr, \"\\n\");\n     }\n   if (lvl->type_shadowed)\n@@ -2576,6 +2622,8 @@ void\n poplevel_class (void)\n {\n   struct cp_binding_level *level = class_binding_level;\n+  cp_class_binding *cb;\n+  size_t i;\n   tree shadowed;\n \n   timevar_push (TV_NAME_LOOKUP);\n@@ -2589,12 +2637,11 @@ poplevel_class (void)\n   if (current_class_depth != 1)\n     {\n       struct cp_binding_level* b;\n+      cp_class_binding* cb;\n+      size_t i;\n \n       /* Clear out our IDENTIFIER_CLASS_VALUEs.  */\n-      for (shadowed = level->class_shadowed;\n-\t   shadowed;\n-\t   shadowed = TREE_CHAIN (shadowed))\n-\tIDENTIFIER_CLASS_VALUE (TREE_PURPOSE (shadowed)) = NULL_TREE;\n+      clear_identifier_class_values ();\n \n       /* Find the next enclosing class, and recreate\n \t IDENTIFIER_CLASS_VALUEs appropriate for that class.  */\n@@ -2603,38 +2650,36 @@ poplevel_class (void)\n \tb = b->level_chain;\n \n       if (b)\n-\tfor (shadowed = b->class_shadowed;\n-\t     shadowed;\n-\t     shadowed = TREE_CHAIN (shadowed))\n+\tfor (i = 0;\n+\t     (cb = VEC_iterate (cp_class_binding, \n+\t\t\t\tb->class_shadowed, \n+\t\t\t\ti));\n+\t     ++i)\n \t  {\n \t    cxx_binding *binding;\n             \n-\t    binding = IDENTIFIER_BINDING (TREE_PURPOSE (shadowed));\n+\t    binding = IDENTIFIER_BINDING (cb->identifier);\n \t    while (binding && binding->scope != b)\n \t      binding = binding->previous;\n \n \t    if (binding)\n-\t      IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (shadowed))\n-\t\t= binding->value;\n+\t      IDENTIFIER_CLASS_VALUE (cb->identifier) = binding->value;\n \t  }\n     }\n   else\n     /* Remember to save what IDENTIFIER's were bound in this scope so we\n        can recover from cache misses.  */\n-    {\n-      previous_class_type = current_class_type;\n-      previous_class_values = class_binding_level->class_shadowed;\n-    }\n+    previous_class_level = level;\n   for (shadowed = level->type_shadowed;\n        shadowed;\n        shadowed = TREE_CHAIN (shadowed))\n     SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (shadowed), TREE_VALUE (shadowed));\n \n   /* Remove the bindings for all of the class-level declarations.  */\n-  for (shadowed = level->class_shadowed;\n-       shadowed;\n-       shadowed = TREE_CHAIN (shadowed))\n-    pop_binding (TREE_PURPOSE (shadowed), TREE_TYPE (shadowed));\n+  for (i = 0;\n+       (cb = VEC_iterate (cp_class_binding, level->class_shadowed, i));\n+       ++i)\n+    IDENTIFIER_BINDING (cb->identifier) = cb->base.previous;\n \n   /* Now, pop out of the binding level which we created up in the\n      `pushlevel_class' routine.  */\n@@ -2707,15 +2752,16 @@ push_class_binding (tree id, tree decl)\n void\n clear_identifier_class_values (void)\n {\n-  tree t;\n-\n-  if (!class_binding_level)\n-    return;\n+  size_t i;\n+  cp_class_binding *cb;\n \n-  for (t = class_binding_level->class_shadowed;\n-       t;\n-       t = TREE_CHAIN (t))\n-    IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (t)) = NULL_TREE;\n+  if (class_binding_level)\n+    for (i = 0;\n+\t (cb = VEC_iterate (cp_class_binding, \n+\t\t\t    class_binding_level->class_shadowed, \n+\t\t\t    i));\n+\t ++i)\n+      IDENTIFIER_CLASS_VALUE (cb->identifier) = NULL_TREE;\n }\n \n /* Make the declaration of X appear in CLASS scope.  */\n@@ -2859,22 +2905,25 @@ push_class_level_binding (tree name, tree x)\n \told_decl = bval;\n       else if (TREE_CODE (bval) == USING_DECL && is_overloaded_fn (x))\n \tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n-      \n+\n       if (old_decl)\n \t{\n-\t  tree shadow;\n-\t  \n+\t  cp_class_binding *cb;\n+\t  size_t i;\n+\n \t  /* Find the previous binding of name on the class-shadowed\n              list, and update it.  */\n-\t  for (shadow = class_binding_level->class_shadowed;\n-\t       shadow;\n-\t       shadow = TREE_CHAIN (shadow))\n-\t    if (TREE_PURPOSE (shadow) == name\n-\t\t&& TREE_TYPE (shadow) == old_decl)\n+\t  for (i = 0; \n+\t       (cb = VEC_iterate (cp_class_binding,\n+\t\t\t\t  class_binding_level->class_shadowed,\n+\t\t\t\t  i));\n+\t       ++i)\n+\t    if (cb->identifier == name\n+\t\t&& (cb->base.value == old_decl\n+\t\t    || cb->base.type == old_decl))\n \t      {\n \t\tbinding->value = x;\n \t\tINHERITED_VALUE_BINDING_P (binding) = 0;\n-\t\tTREE_TYPE (shadow) = x;\n \t\tIDENTIFIER_CLASS_VALUE (name) = x;\n \t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n \t      }\n@@ -2884,15 +2933,7 @@ push_class_level_binding (tree name, tree x)\n   /* If we didn't replace an existing binding, put the binding on the\n      stack of bindings for the identifier, and update the shadowed list.  */\n   if (push_class_binding (name, x))\n-    {\n-      class_binding_level->class_shadowed\n-\t= tree_cons (name, NULL,\n-\t\t     class_binding_level->class_shadowed);\n-      /* Record the value we are binding NAME to so that we can know\n-\t what to pop later.  */\n-      TREE_TYPE (class_binding_level->class_shadowed) = x;\n-      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n-    }\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n \n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, false);\n }\n@@ -2945,11 +2986,6 @@ do_class_using_decl (tree decl)\n   return value;\n }\n \n-void\n-set_class_shadows (tree shadows)\n-{\n-  class_binding_level->class_shadowed = shadows;\n-}\n \f\n /* Return the binding value for name in scope.  */\n \n@@ -4796,6 +4832,41 @@ struct cxx_saved_binding GTY(())\n    scope isn't enough, because more binding levels may be pushed.  */\n struct saved_scope *scope_chain;\n \n+/* If ID is not already in the SEARCH_BINDINGS, prepend its binding\n+   information to OLD_BINDINGS.  Returns the new OLD_BINDINGS\n+   list.  */\n+\n+static cxx_saved_binding *\n+store_binding (tree id,\n+\t       cxx_saved_binding *old_bindings,\n+\t       cxx_saved_binding *search_bindings)\n+{\n+  cxx_saved_binding *saved;\n+  cxx_saved_binding *t1;\n+\n+  if (!id\n+      /* Note that we may have an IDENTIFIER_CLASS_VALUE even when\n+\t we have no IDENTIFIER_BINDING if we have left the class\n+\t scope, but cached the class-level declarations.  */\n+      || !(IDENTIFIER_BINDING (id) || IDENTIFIER_CLASS_VALUE (id)))\n+     return old_bindings;\n+\n+  for (t1 = search_bindings; t1; t1 = t1->previous)\n+    if (t1->identifier == id)\n+     return old_bindings;\n+\n+  my_friendly_assert (TREE_CODE (id) == IDENTIFIER_NODE, 135);\n+  saved = cxx_saved_binding_make ();\n+  saved->previous = old_bindings;\n+  saved->identifier = id;\n+  saved->binding = IDENTIFIER_BINDING (id);\n+  saved->class_value = IDENTIFIER_CLASS_VALUE (id);;\n+  saved->real_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n+  IDENTIFIER_BINDING (id) = NULL;\n+  IDENTIFIER_CLASS_VALUE (id) = NULL_TREE;\n+  return saved;\n+}\n+\n static cxx_saved_binding *\n store_bindings (tree names, cxx_saved_binding *old_bindings)\n {\n@@ -4806,41 +4877,38 @@ store_bindings (tree names, cxx_saved_binding *old_bindings)\n   for (t = names; t; t = TREE_CHAIN (t))\n     {\n       tree id;\n-      cxx_saved_binding *saved;\n-      cxx_saved_binding *t1;\n \n       if (TREE_CODE (t) == TREE_LIST)\n \tid = TREE_PURPOSE (t);\n       else\n \tid = DECL_NAME (t);\n \n-      if (!id\n-\t  /* Note that we may have an IDENTIFIER_CLASS_VALUE even when\n-\t     we have no IDENTIFIER_BINDING if we have left the class\n-\t     scope, but cached the class-level declarations.  */\n-\t  || !(IDENTIFIER_BINDING (id) || IDENTIFIER_CLASS_VALUE (id)))\n-\tcontinue;\n-\n-      for (t1 = search_bindings; t1; t1 = t1->previous)\n-\tif (t1->identifier == id)\n-\t  goto skip_it;\n-\n-      my_friendly_assert (TREE_CODE (id) == IDENTIFIER_NODE, 135);\n-      saved = cxx_saved_binding_make ();\n-      saved->previous = old_bindings;\n-      saved->identifier = id;\n-      saved->binding = IDENTIFIER_BINDING (id);\n-      saved->class_value = IDENTIFIER_CLASS_VALUE (id);;\n-      saved->real_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n-      IDENTIFIER_BINDING (id) = NULL;\n-      IDENTIFIER_CLASS_VALUE (id) = NULL_TREE;\n-      old_bindings = saved;\n-    skip_it:\n-      ;\n+      old_bindings \n+\t= store_binding (id, old_bindings, search_bindings);\n     }\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, old_bindings);\n }\n \n+/* Like store_bindings, but NAMES is a vector of cp_class_binding\n+   objects, rather than a TREE_LIST.  */\n+\n+static cxx_saved_binding *\n+store_class_bindings (VEC(cp_class_binding) *names, \n+\t\t      cxx_saved_binding *old_bindings)\n+{\n+  size_t i;\n+  cp_class_binding *cb;\n+  cxx_saved_binding *search_bindings = old_bindings;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  for (i = 0; \n+       (cb = VEC_iterate(cp_class_binding, names, i));\n+       ++i)\n+    old_bindings \n+      = store_binding (cb->identifier, old_bindings, search_bindings);\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, old_bindings);\n+}\n+\n void\n push_to_top_level (void)\n {\n@@ -4864,8 +4932,9 @@ push_to_top_level (void)\n     need_pop = 0;\n \n   old_bindings = NULL;\n-  if (scope_chain && previous_class_type)\n-    old_bindings = store_bindings (previous_class_values, old_bindings);\n+  if (scope_chain && previous_class_level)\n+    old_bindings = store_class_bindings (previous_class_level->class_shadowed,\n+\t\t\t\t\t old_bindings);\n \n   /* Have to include the global scope, because class-scope decls\n      aren't listed anywhere useful.  */\n@@ -4884,7 +4953,7 @@ push_to_top_level (void)\n       /* We also need to check class_shadowed to save class-level type\n \t bindings, since pushclass doesn't fill in b->names.  */\n       if (b->kind == sk_class)\n-\told_bindings = store_bindings (b->class_shadowed, old_bindings);\n+\told_bindings = store_class_bindings (b->class_shadowed, old_bindings);\n \n       /* Unwind type-value slots back to top level.  */\n       for (t = b->type_shadowed; t; t = TREE_CHAIN (t))\n@@ -4912,7 +4981,7 @@ pop_from_top_level (void)\n \n   timevar_push (TV_NAME_LOOKUP); \n   /* Clear out class-level bindings cache.  */\n-  if (previous_class_type)\n+  if (previous_class_level)\n     invalidate_class_lookup_cache ();\n \n   current_lang_base = 0;"}, {"sha": "1d1f09f789d5b35b1aa6ef64ab6d00657baf50c1", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b578be68dd3d91e551c3ba922f054ead36c4e4/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b578be68dd3d91e551c3ba922f054ead36c4e4/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=89b578be68dd3d91e551c3ba922f054ead36c4e4", "patch": "@@ -117,6 +117,15 @@ typedef enum scope_kind {\n \t\t\t\"template <>\", this scope is always empty.  */\n } scope_kind;\n \n+typedef struct cp_class_binding GTY(())\n+{\n+  cxx_binding base;\n+  /* The bound name.  */\n+  tree identifier;\n+} cp_class_binding;\n+\n+DEF_VEC_O(cp_class_binding);\n+\n /* For each binding contour we allocate a binding_level structure\n    which records the names defined in that contour.\n    Contours include:\n@@ -175,7 +184,7 @@ struct cp_binding_level GTY(())\n        class_shadowed is a TREE_LIST.  The TREE_PURPOSE of each node\n        is the name of an entity bound in the class.  The TREE_TYPE is\n        the DECL bound by this name in the class.  */\n-    tree class_shadowed;\n+    VEC(cp_class_binding) *class_shadowed;\n \n     /* Similar to class_shadowed, but for IDENTIFIER_TYPE_VALUE, and\n        is used for all binding levels. In addition the TREE_VALUE is the\n@@ -273,6 +282,7 @@ extern void keep_next_level (bool);\n extern bool is_ancestor (tree, tree);\n extern bool push_scope (tree);\n extern void pop_scope (tree);\n+extern void push_binding_level (struct cp_binding_level *);\n \f\n extern void push_namespace (tree);\n extern void pop_namespace (void);\n@@ -299,7 +309,6 @@ extern bool push_class_level_binding (tree, tree);\n extern void storetags (tree);\n extern tree getdecls (void);\n extern tree cp_namespace_decls (tree);\n-extern void set_class_shadows (tree);\n extern void set_decl_namespace (tree, tree, bool);\n extern tree current_decl_namespace (void);\n extern void push_decl_namespace (tree);"}]}