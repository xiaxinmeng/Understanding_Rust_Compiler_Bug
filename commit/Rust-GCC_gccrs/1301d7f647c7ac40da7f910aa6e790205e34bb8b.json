{"sha": "1301d7f647c7ac40da7f910aa6e790205e34bb8b", "node_id": "C_kwDOANBUbNoAKDEzMDFkN2Y2NDdjN2FjNDBkYTdmOTEwYWE2ZTc5MDIwNWUzNGJiOGI", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2022-03-05T05:01:52Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2022-03-05T05:01:52Z"}, "message": "Optimize signed DImode -> TImode on power10.\n\nOn power10, GCC tries to optimize the signed conversion from DImode to\nTImode by using the vextsd2q instruction.  However to generate this\ninstruction, it would have to generate 3 direct moves (1 from the GPR\nregisters to the altivec registers, and 2 from the altivec registers to\nthe GPR register).\n\nThis patch generates the shift right immediate instruction to do the\nconversion if the target/source registers ares GPR registers like it does\non earlier systems.  If the target/source registers are Altivec registers,\nit will generate the vextsd2q instruction.\n\n2022-03-05   Michael Meissner  <meissner@linux.ibm.com>\n\ngcc/\n\tPR target/104698\n\t* config/rs6000/vsx.md (UNSPEC_MTVSRD_DITI_W1): Delete.\n\t(mtvsrdd_diti_w1): Delete.\n\t(extendditi2): Convert from define_expand to\n\tdefine_insn_and_split.  Replace with code to deal with both GPR\n\tregisters and with altivec registers.\n\ngcc/testsuite/\n\tPR target/104698\n\t* gcc.target/powerpc/pr104698-1.c: New test.\n\t* gcc.target/powerpc/pr104698-2.c: New test.", "tree": {"sha": "5c7c68c556cd1267e48da4a0bb1cf70b6c3d4543", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c7c68c556cd1267e48da4a0bb1cf70b6c3d4543"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1301d7f647c7ac40da7f910aa6e790205e34bb8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1301d7f647c7ac40da7f910aa6e790205e34bb8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1301d7f647c7ac40da7f910aa6e790205e34bb8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1301d7f647c7ac40da7f910aa6e790205e34bb8b/comments", "author": null, "committer": null, "parents": [{"sha": "8d96e14c1d61b04cd424cdbb6c830bb204dafbcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d96e14c1d61b04cd424cdbb6c830bb204dafbcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d96e14c1d61b04cd424cdbb6c830bb204dafbcf"}], "stats": {"total": 146, "additions": 124, "deletions": 22}, "files": [{"sha": "d0fb92f598578b3bc5a73cd9dfa95c7722866d44", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 61, "deletions": 22, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1301d7f647c7ac40da7f910aa6e790205e34bb8b/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1301d7f647c7ac40da7f910aa6e790205e34bb8b/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=1301d7f647c7ac40da7f910aa6e790205e34bb8b", "patch": "@@ -360,7 +360,6 @@\n    UNSPEC_XXGENPCV\n    UNSPEC_MTVSBM\n    UNSPEC_EXTENDDITI2\n-   UNSPEC_MTVSRD_DITI_W1\n    UNSPEC_VCNTMB\n    UNSPEC_VEXPAND\n    UNSPEC_VEXTRACT\n@@ -5023,15 +5022,67 @@\n   DONE;\n })\n \n-;; ISA 3.1 vector sign extend\n-;; Move DI value from GPR to TI mode in VSX register, word 1.\n-(define_insn \"mtvsrdd_diti_w1\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"=wa\")\n-\t(unspec:TI [(match_operand:DI 1 \"register_operand\" \"r\")]\n-\t\t     UNSPEC_MTVSRD_DITI_W1))]\n-  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n-  \"mtvsrdd %x0,0,%1\"\n-  [(set_attr \"type\" \"vecmove\")])\n+;; Sign extend DI to TI.  We provide both GPR targets and Altivec targets on\n+;; power10.  On earlier systems, the machine independent code will generate a\n+;; shift left to sign extend the 64-bit value to 128-bit.\n+;;\n+;; If the register allocator prefers to use GPR registers, we will use a shift\n+;; left instruction to sign extend the 64-bit value to 128-bit.\n+;;\n+;; If the register allocator prefers to use Altivec registers on power10,\n+;; generate the vextsd2q instruction.\n+(define_insn_and_split \"extendditi2\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=r,r,v,v,v\")\n+\t(sign_extend:TI (match_operand:DI 1 \"input_operand\" \"r,m,r,wa,Z\")))\n+   (clobber (reg:DI CA_REGNO))]\n+  \"TARGET_POWERPC64 && TARGET_POWER10\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(pc)]\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  int dest_regno = reg_or_subregno (dest);\n+\n+  /* Handle conversion to GPR registers.  Load up the low part and then do\n+     a sign extension to the upper part.  */\n+  if (INT_REGNO_P (dest_regno))\n+    {\n+      rtx dest_hi = gen_highpart (DImode, dest);\n+      rtx dest_lo = gen_lowpart (DImode, dest);\n+\n+      emit_move_insn (dest_lo, src);\n+      /* In case src is a MEM, we have to use the destination, which is a\n+         register, instead of re-using the source.  */\n+      rtx src2 = (REG_P (src) || SUBREG_P (src)) ? src : dest_lo;\n+      emit_insn (gen_ashrdi3 (dest_hi, src2, GEN_INT (63)));\n+      DONE;\n+    }\n+\n+  /* For conversion to an Altivec register, generate either a splat operation\n+     or a load rightmost double word instruction.  Both instructions gets the\n+     DImode value into the lower 64 bits, and then do the vextsd2q\n+     instruction.  */\n+\n+  else if (ALTIVEC_REGNO_P (dest_regno))\n+    {\n+      if (MEM_P (src))\n+\temit_insn (gen_vsx_lxvrdx (dest, src));\n+      else\n+\t{\n+\t  rtx dest_v2di = gen_rtx_REG (V2DImode, dest_regno);\n+\t  emit_insn (gen_vsx_splat_v2di (dest_v2di, src));\n+\t}\n+\n+      emit_insn (gen_extendditi2_vector (dest, dest));\n+      DONE;\n+    }\n+\n+  else\n+    gcc_unreachable ();\n+}\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"shift,load,vecmove,vecperm,load\")])\n \n ;; Sign extend 64-bit value in TI reg, word 1, to 128-bit value in TI reg\n (define_insn \"extendditi2_vector\"\n@@ -5042,18 +5093,6 @@\n   \"vextsd2q %0,%1\"\n   [(set_attr \"type\" \"vecexts\")])\n \n-(define_expand \"extendditi2\"\n-  [(set (match_operand:TI 0 \"gpc_reg_operand\")\n-\t(sign_extend:DI (match_operand:DI 1 \"gpc_reg_operand\")))]\n-  \"TARGET_POWER10\"\n-  {\n-    /* Move 64-bit src from GPR to vector reg and sign extend to 128-bits.  */\n-    rtx temp = gen_reg_rtx (TImode);\n-    emit_insn (gen_mtvsrdd_diti_w1 (temp, operands[1]));\n-    emit_insn (gen_extendditi2_vector (operands[0], temp));\n-    DONE;\n-  })\n-\n \f\n ;; ISA 3.0 Binary Floating-Point Support\n "}, {"sha": "cd17b6b616d5620751c3df66581f35438bb216de", "filename": "gcc/testsuite/gcc.target/powerpc/pr104698-1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1301d7f647c7ac40da7f910aa6e790205e34bb8b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr104698-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1301d7f647c7ac40da7f910aa6e790205e34bb8b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr104698-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr104698-1.c?ref=1301d7f647c7ac40da7f910aa6e790205e34bb8b", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-require-effective-target int128     } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+/* PR target/104698 involved a regression where on power10, conversion from\n+   long long to __int128_t generated mtvsrdd, vextsd2q, mfvsrd, and mfvsrld\n+   instructions instead of just a GPR sign extension.  This test makes sure the\n+   result is kept in the GPR registers.  */\n+\n+__int128_t convert_1 (long long a)\n+{\n+  return a;\t/* sradi.  */\n+}\n+\n+/* Like convert_1, but make sure a normal offsettable load is done.  The\n+   pattern in vsx.md has support for generating lxvdsx if it is coming from\n+   memory.  Make sure when the gpr is used, a normal load with offset is still\n+   done.  */\n+\n+__int128_t convert_2 (long long *p)\n+{\n+  return p[2];\t/* ld and sradi.  */\n+}\n+\n+/* { dg-final { scan-assembler-not   {\\mmfvsrd\\M}     } } */\n+/* { dg-final { scan-assembler-not   {\\mmfvsrld\\M}    } } */\n+/* { dg-final { scan-assembler-not   {\\mmtvsrdd\\M}    } } */\n+/* { dg-final { scan-assembler-not   {\\mvextsd2q\\M}   } } */\n+/* { dg-final { scan-assembler-times {\\mld\\M}       1 } } */\n+/* { dg-final { scan-assembler-times {\\msradi\\M}    2 } } */"}, {"sha": "6966fce2ba93d2e43e144af470bba5bd499f2d5d", "filename": "gcc/testsuite/gcc.target/powerpc/pr104698-2.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1301d7f647c7ac40da7f910aa6e790205e34bb8b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr104698-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1301d7f647c7ac40da7f910aa6e790205e34bb8b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr104698-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr104698-2.c?ref=1301d7f647c7ac40da7f910aa6e790205e34bb8b", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-require-effective-target int128     } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+/* PR target/104694 involved GCC generating vextsd2q to convent long long to\n+   __int128_t when the long long value was in the GPR register.  This test\n+   verifies that if the result is in the Altivec registers, we still want to\n+   generate vextsd2q.  We use __int128_t to indicate that we want the result of\n+   the conversion to be in an Altivec register. */\n+\n+void do_div_1 (__int128_t *p, __int128_t *q, long long r)\n+{\n+  *p = *q / r;\t\t/* mtvsrdd, vextsd2q, vdivsq.  */\n+}\n+\n+/* Test the optimization in vsx.md to use lxvrdx instead of ld and mtvsrdd if\n+   the value is coming from memory.  */\n+\n+void do_div_2 (__int128_t *p, __int128_t *q, long long *r)\n+{\n+  *p = *q / r[2];\t/* lxvrdx, vextsd2q, vdivsq.  */\n+}\n+\n+/* { dg-final { scan-assembler-not   {\\mld\\M}         } } */\n+/* { dg-final { scan-assembler-not   {\\mmfvsrd\\M}     } } */\n+/* { dg-final { scan-assembler-not   {\\mmfvsrld\\M}    } } */\n+/* { dg-final { scan-assembler-not   {\\msradi\\M}      } } */\n+/* { dg-final { scan-assembler-times {\\mlxv\\M}      2 } } */\n+/* { dg-final { scan-assembler-times {\\mlxvrdx\\M}   1 } } */\n+/* { dg-final { scan-assembler-times {\\mmtvsrdd\\M}  1 } } */\n+/* { dg-final { scan-assembler-times {\\mstxv\\M}     2 } } */\n+/* { dg-final { scan-assembler-times {\\mvdivsq\\M}   2 } } */\n+/* { dg-final { scan-assembler-times {\\mvextsd2q\\M} 2 } } */"}]}