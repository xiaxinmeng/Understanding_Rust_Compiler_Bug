{"sha": "696abb30d602208b316845bff9974e4b8b6e86ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk2YWJiMzBkNjAyMjA4YjMxNjg0NWJmZjk5NzRlNGI4YjZlODZlZg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-12-11T23:14:45Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-12-11T23:14:45Z"}, "message": "re PR fortran/46705 (Spurious \"Missing '&' in continued character constant\" warning occurs twice)\n\n2010-12-11  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/46705\n\t* gfortran.h: New enum gfc_instring.\n\t(gfc_next_char_literal): Update prototype.\n\t* scanner.c (gfc_next_char_literal): Use new enum. Only give missing\n\t'&' warning for INSTRING_WARN. (gfc_next_char): Use new enum.\n\t(gfc_gobble_whitespace): Likewise.\n\t* io.c (next_char): Use new enum. (next_char_not_space): Likewise.\n\t(format_lex): Likewise.\n\t* match.c (gfc_match_parens): Likewise.\n\t(gfc_match_special_char): Likewise. (gfc_match_name_C): Likewise.\n\t* parse.c (next_fixed): Likewise.\n\t* primary.c (match_hollerith_constant): Likewise.\n\t(next_string_char): Likewise.\n\nFrom-SVN: r167716", "tree": {"sha": "982b960730fe59e92f42e77b35659f096fb2a00c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/982b960730fe59e92f42e77b35659f096fb2a00c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/696abb30d602208b316845bff9974e4b8b6e86ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/696abb30d602208b316845bff9974e4b8b6e86ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/696abb30d602208b316845bff9974e4b8b6e86ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/696abb30d602208b316845bff9974e4b8b6e86ef/comments", "author": null, "committer": null, "parents": [{"sha": "a70de21ffba9c1c8b4c5096bf9faf3deeb054c76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a70de21ffba9c1c8b4c5096bf9faf3deeb054c76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a70de21ffba9c1c8b4c5096bf9faf3deeb054c76"}], "stats": {"total": 85, "additions": 54, "deletions": 31}, "files": [{"sha": "90337d27327d1708d740e98979b5e1e869c73f22", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696abb30d602208b316845bff9974e4b8b6e86ef/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696abb30d602208b316845bff9974e4b8b6e86ef/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=696abb30d602208b316845bff9974e4b8b6e86ef", "patch": "@@ -1,3 +1,19 @@\n+2010-12-11  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/46705\n+\t* gfortran.h: New enum gfc_instring.\n+\t(gfc_next_char_literal): Update prototype.\n+\t* scanner.c (gfc_next_char_literal): Use new enum. Only give missing\n+\t'&' warning for INSTRING_WARN. (gfc_next_char): Use new enum.\n+\t(gfc_gobble_whitespace): Likewise.\n+\t* io.c (next_char): Use new enum. (next_char_not_space): Likewise.\n+\t(format_lex): Likewise.\n+\t* match.c (gfc_match_parens): Likewise.\n+\t(gfc_match_special_char): Likewise. (gfc_match_name_C): Likewise.\n+\t* parse.c (next_fixed): Likewise.\n+\t* primary.c (match_hollerith_constant): Likewise.\n+\t(next_string_char): Likewise.\n+\n 2010-12-11  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/46370"}, {"sha": "6f6a9f46f764dd09f30f231d9d4fadecd69fc671", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696abb30d602208b316845bff9974e4b8b6e86ef/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696abb30d602208b316845bff9974e4b8b6e86ef/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=696abb30d602208b316845bff9974e4b8b6e86ef", "patch": "@@ -96,6 +96,13 @@ typedef enum\n { SUCCESS = 1, FAILURE }\n gfc_try;\n \n+/* These are flags for identifying whether we are reading a character literal\n+   between quotes or normal source code.  */\n+   \n+typedef enum\n+{ NONSTRING = 0, INSTRING_WARN, INSTRING_NOWARN }\n+gfc_instring;\n+\n /* This is returned by gfc_notification_std to know if, given the flags\n    that were given (-std=, -pedantic) we should issue an error, a warning\n    or nothing.  */\n@@ -113,6 +120,7 @@ typedef enum\n { MATCH_NO = 1, MATCH_YES, MATCH_ERROR }\n match;\n \n+/* Used for different Fortran source forms in places like scanner.c.  */\n typedef enum\n { FORM_FREE, FORM_FIXED, FORM_UNKNOWN }\n gfc_source_form;\n@@ -160,7 +168,6 @@ typedef enum\n }\n gfc_intrinsic_op;\n \n-\n /* This macro is the number of intrinsic operators that exist.\n    Assumptions are made about the numbering of the interface_op enums.  */\n #define GFC_INTRINSIC_OPS GFC_INTRINSIC_END\n@@ -206,7 +213,6 @@ typedef enum\n }\n gfc_statement;\n \n-\n /* Types of interfaces that we can have.  Assignment interfaces are\n    considered to be intrinsic operators.  */\n typedef enum\n@@ -2332,7 +2338,7 @@ gfc_char_t *gfc_char_to_widechar (const char *);\n #define gfc_get_wide_string(n) XCNEWVEC (gfc_char_t, n)\n \n void gfc_skip_comments (void);\n-gfc_char_t gfc_next_char_literal (int);\n+gfc_char_t gfc_next_char_literal (gfc_instring);\n gfc_char_t gfc_next_char (void);\n char gfc_next_ascii_char (void);\n gfc_char_t gfc_peek_char (void);"}, {"sha": "938dc9a92244bc0e7260d81b933f6ee227572d8c", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696abb30d602208b316845bff9974e4b8b6e86ef/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696abb30d602208b316845bff9974e4b8b6e86ef/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=696abb30d602208b316845bff9974e4b8b6e86ef", "patch": "@@ -136,7 +136,7 @@ mode;\n /* Return the next character in the format string.  */\n \n static char\n-next_char (int in_string)\n+next_char (gfc_instring in_string)\n {\n   static gfc_char_t c;\n \n@@ -197,7 +197,7 @@ next_char_not_space (bool *error)\n   char c;\n   do\n     {\n-      error_element = c = next_char (0);\n+      error_element = c = next_char (NONSTRING);\n       if (c == '\\t')\n \t{\n \t  if (gfc_option.allow_std & GFC_STD_GNU)\n@@ -374,7 +374,7 @@ format_lex (void)\n \n       for (;;)\n \t{\n-\t  c = next_char (1);\n+\t  c = next_char (INSTRING_WARN);\n \t  if (c == '\\0')\n \t    {\n \t      token = FMT_END;\n@@ -383,7 +383,7 @@ format_lex (void)\n \n \t  if (c == delim)\n \t    {\n-\t      c = next_char (1);\n+\t      c = next_char (INSTRING_NOWARN);\n \n \t      if (c == '\\0')\n \t\t{\n@@ -981,7 +981,7 @@ check_format (bool is_input)\n \t{\n \t  while (repeat >0)\n \t   {\n-\t     next_char (1);\n+\t     next_char (INSTRING_WARN);\n \t     repeat -- ;\n \t   }\n \t}"}, {"sha": "44da1bb97bd1205064a21cd21551319f11b033c7", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696abb30d602208b316845bff9974e4b8b6e86ef/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696abb30d602208b316845bff9974e4b8b6e86ef/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=696abb30d602208b316845bff9974e4b8b6e86ef", "patch": "@@ -118,12 +118,13 @@ match\n gfc_match_parens (void)\n {\n   locus old_loc, where;\n-  int count, instring;\n+  int count;\n+  gfc_instring instring;\n   gfc_char_t c, quote;\n \n   old_loc = gfc_current_locus;\n   count = 0;\n-  instring = 0;\n+  instring = NONSTRING;\n   quote = ' ';\n \n   for (;;)\n@@ -134,13 +135,13 @@ gfc_match_parens (void)\n       if (quote == ' ' && ((c == '\\'') || (c == '\"')))\n \t{\n \t  quote = c;\n-\t  instring = 1;\n+\t  instring = INSTRING_WARN;\n \t  continue;\n \t}\n       if (quote != ' ' && c == quote)\n \t{\n \t  quote = ' ';\n-\t  instring = 0;\n+\t  instring = NONSTRING;\n \t  continue;\n \t}\n \n@@ -185,7 +186,7 @@ gfc_match_special_char (gfc_char_t *res)\n \n   m = MATCH_YES;\n \n-  switch ((c = gfc_next_char_literal (1)))\n+  switch ((c = gfc_next_char_literal (INSTRING_WARN)))\n     {\n     case 'a':\n       *res = '\\a';\n@@ -225,7 +226,7 @@ gfc_match_special_char (gfc_char_t *res)\n \t{\n \t  char buf[2] = { '\\0', '\\0' };\n \n-\t  c = gfc_next_char_literal (1);\n+\t  c = gfc_next_char_literal (INSTRING_WARN);\n \t  if (!gfc_wide_fits_in_byte (c)\n \t      || !gfc_check_digit ((unsigned char) c, 16))\n \t    return MATCH_NO;\n@@ -592,7 +593,7 @@ gfc_match_name_C (char *buffer)\n \n   /* Get the next char (first possible char of name) and see if\n      it's valid for C (either a letter or an underscore).  */\n-  c = gfc_next_char_literal (1);\n+  c = gfc_next_char_literal (INSTRING_WARN);\n \n   /* If the user put nothing expect spaces between the quotes, it is valid\n      and simply means there is no name= specifier and the name is the fortran\n@@ -632,7 +633,7 @@ gfc_match_name_C (char *buffer)\n       old_loc = gfc_current_locus;\n       \n       /* Get next char; param means we're in a string.  */\n-      c = gfc_next_char_literal (1);\n+      c = gfc_next_char_literal (INSTRING_WARN);\n     } while (ISALNUM (c) || c == '_');\n \n   buffer[i] = '\\0';"}, {"sha": "ea9667d4a6b2098f43864a0ad76143f9a50c1b4e", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696abb30d602208b316845bff9974e4b8b6e86ef/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696abb30d602208b316845bff9974e4b8b6e86ef/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=696abb30d602208b316845bff9974e4b8b6e86ef", "patch": "@@ -745,7 +745,7 @@ next_fixed (void)\n \n   for (i = 0; i < 5; i++)\n     {\n-      c = gfc_next_char_literal (0);\n+      c = gfc_next_char_literal (NONSTRING);\n \n       switch (c)\n \t{\n@@ -771,18 +771,18 @@ next_fixed (void)\n \t     here, except for GCC attributes and OpenMP directives.  */\n \n \tcase '*':\n-\t  c = gfc_next_char_literal (0);\n+\t  c = gfc_next_char_literal (NONSTRING);\n \t  \n \t  if (TOLOWER (c) == 'g')\n \t    {\n-\t      for (i = 0; i < 4; i++, c = gfc_next_char_literal (0))\n+\t      for (i = 0; i < 4; i++, c = gfc_next_char_literal (NONSTRING))\n \t\tgcc_assert (TOLOWER (c) == \"gcc$\"[i]);\n \n \t      return decode_gcc_attribute ();\n \t    }\n \t  else if (c == '$' && gfc_option.gfc_flag_openmp)\n \t    {\n-\t      for (i = 0; i < 4; i++, c = gfc_next_char_literal (0))\n+\t      for (i = 0; i < 4; i++, c = gfc_next_char_literal (NONSTRING))\n \t\tgcc_assert ((char) gfc_wide_tolower (c) == \"$omp\"[i]);\n \n \t      if (c != ' ' && c != '0')\n@@ -821,7 +821,7 @@ next_fixed (void)\n      of a previous statement.  If we see something here besides a\n      space or zero, it must be a bad continuation line.  */\n \n-  c = gfc_next_char_literal (0);\n+  c = gfc_next_char_literal (NONSTRING);\n   if (c == '\\n')\n     goto blank_line;\n \n@@ -839,7 +839,7 @@ next_fixed (void)\n   do\n     {\n       loc = gfc_current_locus;\n-      c = gfc_next_char_literal (0);\n+      c = gfc_next_char_literal (NONSTRING);\n     }\n   while (gfc_is_whitespace (c));\n "}, {"sha": "da028b42df835aa3080174264e14ac411feb579a", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696abb30d602208b316845bff9974e4b8b6e86ef/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696abb30d602208b316845bff9974e4b8b6e86ef/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=696abb30d602208b316845bff9974e4b8b6e86ef", "patch": "@@ -288,7 +288,7 @@ match_hollerith_constant (gfc_expr **result)\n \n \t  for (i = 0; i < num; i++)\n \t    {\n-\t      gfc_char_t c = gfc_next_char_literal (1);\n+\t      gfc_char_t c = gfc_next_char_literal (INSTRING_WARN);\n \t      if (! gfc_wide_fits_in_byte (c))\n \t\t{\n \t\t  gfc_error (\"Invalid Hollerith constant at %L contains a \"\n@@ -761,7 +761,7 @@ next_string_char (gfc_char_t delimiter, int *ret)\n   locus old_locus;\n   gfc_char_t c;\n \n-  c = gfc_next_char_literal (1);\n+  c = gfc_next_char_literal (INSTRING_WARN);\n   *ret = 0;\n \n   if (c == '\\n')\n@@ -785,7 +785,7 @@ next_string_char (gfc_char_t delimiter, int *ret)\n     return c;\n \n   old_locus = gfc_current_locus;\n-  c = gfc_next_char_literal (0);\n+  c = gfc_next_char_literal (NONSTRING);\n \n   if (c == delimiter)\n     return c;"}, {"sha": "c226baee9667780f71250a317751d2c46bf949f3", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696abb30d602208b316845bff9974e4b8b6e86ef/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696abb30d602208b316845bff9974e4b8b6e86ef/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=696abb30d602208b316845bff9974e4b8b6e86ef", "patch": "@@ -997,7 +997,7 @@ gfc_skip_comments (void)\n    context or not.  */\n \n gfc_char_t\n-gfc_next_char_literal (int in_string)\n+gfc_next_char_literal (gfc_instring in_string)\n {\n   locus old_loc;\n   int i, prev_openmp_flag;\n@@ -1146,10 +1146,10 @@ gfc_next_char_literal (int in_string)\n \t{\n \t  if (in_string)\n \t    {\n-\t      if (gfc_option.warn_ampersand)\n-\t\tgfc_warning_now (\"Missing '&' in continued character \"\n-\t\t\t\t \"constant at %C\");\n \t      gfc_current_locus.nextc--;\n+\t      if (gfc_option.warn_ampersand && in_string == INSTRING_WARN)\n+\t\tgfc_warning (\"Missing '&' in continued character \"\n+\t\t\t     \"constant at %C\");\n \t    }\n \t  /* Both !$omp and !$ -fopenmp continuation lines have & on the\n \t     continuation line only optionally.  */\n@@ -1270,7 +1270,7 @@ gfc_next_char (void)\n \n   do\n     {\n-      c = gfc_next_char_literal (0);\n+      c = gfc_next_char_literal (NONSTRING);\n     }\n   while (gfc_current_form == FORM_FIXED && gfc_is_whitespace (c));\n \n@@ -1371,7 +1371,7 @@ gfc_gobble_whitespace (void)\n   do\n     {\n       old_loc = gfc_current_locus;\n-      c = gfc_next_char_literal (0);\n+      c = gfc_next_char_literal (NONSTRING);\n       /* Issue a warning for nonconforming tabs.  We keep track of the line\n \t number because the Fortran matchers will often back up and the same\n \t line will be scanned multiple times.  */"}]}