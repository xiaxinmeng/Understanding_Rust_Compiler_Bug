{"sha": "9645c3c57385f21e01f6c0af9dc552485b156edd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY0NWMzYzU3Mzg1ZjIxZTAxZjZjMGFmOWRjNTUyNDg1YjE1NmVkZA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2007-03-09T17:09:54Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-03-09T17:09:54Z"}, "message": "cuintp.c (UI_To_gnu): Use fold_buildN calls instead of calling fold with the result of buildN.\n\n\n\t* cuintp.c (UI_To_gnu): Use fold_buildN calls instead of calling\n\tfold with the result of buildN.\n\t* decl.c (gnat_to_gnu_entity): Likewise.\n\t* trans.c (Attribute_to_gnu, gnat_to_gnu, emit_check): Likewise.\n\t* utils.c (finish_record_type, merge_sizes, max_size, convert):\n\tLikewise.\n\t* utils2.c (gnat_truthvalue_conversion, compare_arrays,\n\tnonbinary_modular_operation, build_binary_op, build_unary_op,\n\tbuild_cond_expr): Likewise.\n\n\t* utils.c (convert): Use fold_build1 when casting values to void.\n\t* utils2.c (gnat_truthvalue_conversion): Use build_int_cst and\n\tfold_convert instead of convert when appropriate.\n\nFrom-SVN: r122752", "tree": {"sha": "1e4b81524f87b3b337510637b1b2c66422dfc8ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e4b81524f87b3b337510637b1b2c66422dfc8ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9645c3c57385f21e01f6c0af9dc552485b156edd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9645c3c57385f21e01f6c0af9dc552485b156edd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9645c3c57385f21e01f6c0af9dc552485b156edd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9645c3c57385f21e01f6c0af9dc552485b156edd/comments", "author": null, "committer": null, "parents": [{"sha": "63a0874077b3325c2b3cc47401d8bfe916d8f128", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63a0874077b3325c2b3cc47401d8bfe916d8f128", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63a0874077b3325c2b3cc47401d8bfe916d8f128"}], "stats": {"total": 281, "additions": 153, "deletions": 128}, "files": [{"sha": "8fe5c3cfb51451478e9fab4deaf903ca51e7ac8a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9645c3c57385f21e01f6c0af9dc552485b156edd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9645c3c57385f21e01f6c0af9dc552485b156edd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9645c3c57385f21e01f6c0af9dc552485b156edd", "patch": "@@ -1,3 +1,19 @@\n+2007-03-09  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* cuintp.c (UI_To_gnu): Use fold_buildN calls instead of calling\n+\tfold with the result of buildN.\n+\t* decl.c (gnat_to_gnu_entity): Likewise.\n+\t* trans.c (Attribute_to_gnu, gnat_to_gnu, emit_check): Likewise.\n+\t* utils.c (finish_record_type, merge_sizes, max_size, convert):\n+\tLikewise.\n+\t* utils2.c (gnat_truthvalue_conversion, compare_arrays,\n+\tnonbinary_modular_operation, build_binary_op, build_unary_op,\n+\tbuild_cond_expr): Likewise.\n+\n+\t* utils.c (convert): Use fold_build1 when casting values to void.\n+\t* utils2.c (gnat_truthvalue_conversion): Use build_int_cst and\n+\tfold_convert instead of convert when appropriate.\n+\n 2007-03-01  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \t* Make-lang.in: Add install-pdf target as copied from"}, {"sha": "f81072823231b72966a8478e4c8e380e1cd3b00e", "filename": "gcc/ada/cuintp.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9645c3c57385f21e01f6c0af9dc552485b156edd/gcc%2Fada%2Fcuintp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9645c3c57385f21e01f6c0af9dc552485b156edd/gcc%2Fada%2Fcuintp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcuintp.c?ref=9645c3c57385f21e01f6c0af9dc552485b156edd", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2005 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2007 Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -113,18 +113,18 @@ UI_To_gnu (Uint Input, tree type)\n       gnu_ret = build_cst_from_int (comp_type, First);\n       if (First < 0)\n \tfor (Idx++, Length--; Length; Idx++, Length--)\n-\t  gnu_ret = fold (build2 (MINUS_EXPR, comp_type,\n-\t\t\t\t  fold (build2 (MULT_EXPR, comp_type,\n-\t\t\t\t\t\tgnu_ret, gnu_base)),\n-\t\t\t\t  build_cst_from_int (comp_type,\n-\t\t\t\t\t\t      Udigits_Ptr[Idx])));\n+\t  gnu_ret = fold_build2 (MINUS_EXPR, comp_type,\n+\t\t\t\t fold_build2 (MULT_EXPR, comp_type,\n+\t\t\t\t\t      gnu_ret, gnu_base),\n+\t\t\t\t build_cst_from_int (comp_type,\n+\t\t\t\t\t\t     Udigits_Ptr[Idx]));\n       else\n \tfor (Idx++, Length--; Length; Idx++, Length--)\n-\t  gnu_ret = fold (build2 (PLUS_EXPR, comp_type,\n-\t\t\t\t  fold (build2 (MULT_EXPR, comp_type,\n-\t\t\t\t\t\tgnu_ret, gnu_base)),\n-\t\t\t\t  build_cst_from_int (comp_type,\n-\t\t\t\t\t\t      Udigits_Ptr[Idx])));\n+\t  gnu_ret = fold_build2 (PLUS_EXPR, comp_type,\n+\t\t\t\t fold_build2 (MULT_EXPR, comp_type,\n+\t\t\t\t\t      gnu_ret, gnu_base),\n+\t\t\t\t build_cst_from_int (comp_type,\n+\t\t\t\t\t\t     Udigits_Ptr[Idx]));\n     }\n \n   gnu_ret = convert (type, gnu_ret);"}, {"sha": "80b904444db2a4168ed928153ee038c3fff4cfce", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9645c3c57385f21e01f6c0af9dc552485b156edd/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9645c3c57385f21e01f6c0af9dc552485b156edd/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=9645c3c57385f21e01f6c0af9dc552485b156edd", "patch": "@@ -1332,8 +1332,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  {\n \t    TYPE_MODULAR_P (gnu_type) = 1;\n \t    SET_TYPE_MODULUS (gnu_type, gnu_modulus);\n-\t    gnu_high = fold (build2 (MINUS_EXPR, gnu_type, gnu_modulus,\n-\t\t\t\t     convert (gnu_type, integer_one_node)));\n+\t    gnu_high = fold_build2 (MINUS_EXPR, gnu_type, gnu_modulus,\n+\t\t\t\t    convert (gnu_type, integer_one_node));\n \t  }\n \n \t/* If we have to set TYPE_PRECISION different from its natural value,\n@@ -1909,10 +1909,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  && TREE_CODE (gnu_max) == INTEGER_CST\n \t\t  && TREE_OVERFLOW (gnu_min) && TREE_OVERFLOW (gnu_max)\n \t\t  && (!TREE_OVERFLOW\n-\t\t      (fold (build2 (MINUS_EXPR, gnu_index_subtype,\n-\t\t\t\t     TYPE_MAX_VALUE (gnu_index_subtype),\n-\t\t\t\t     TYPE_MIN_VALUE (gnu_index_subtype))))))\n-\t\tTREE_OVERFLOW (gnu_min) = TREE_OVERFLOW (gnu_max) = 0;\n+\t\t      (fold_build2 (MINUS_EXPR, gnu_index_subtype,\n+\t\t\t\t    TYPE_MAX_VALUE (gnu_index_subtype),\n+\t\t\t\t    TYPE_MIN_VALUE (gnu_index_subtype)))))\n+\t\t{\n+\t\t  TREE_OVERFLOW (gnu_min) = 0;\n+\t\t  TREE_OVERFLOW (gnu_max) = 0;\n+\t\t}\n \n \t      /* Similarly, if the range is null, use bounds of 1..0 for\n \t\t the sizetype bounds.  */"}, {"sha": "965382278b8b28de940ce8df6d5cbf37f6a21b1e", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9645c3c57385f21e01f6c0af9dc552485b156edd/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9645c3c57385f21e01f6c0af9dc552485b156edd/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=9645c3c57385f21e01f6c0af9dc552485b156edd", "patch": "@@ -782,8 +782,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \n       if (attribute == Attr_Max_Size_In_Storage_Elements)\n \tgnu_result = convert (sizetype,\n-\t\t\t      fold (build2 (CEIL_DIV_EXPR, bitsizetype,\n-\t\t\t\t\t    gnu_result, bitsize_unit_node)));\n+\t\t\t      fold_build2 (CEIL_DIV_EXPR, bitsizetype,\n+\t\t\t\t\t   gnu_result, bitsize_unit_node));\n       break;\n \n     case Attr_Alignment:\n@@ -1100,8 +1100,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n      example in AARM 11.6(5.e). */\n   if (prefix_unused && TREE_SIDE_EFFECTS (gnu_prefix)\n       && !Is_Entity_Name (Prefix (gnat_node)))\n-    gnu_result = fold (build2 (COMPOUND_EXPR, TREE_TYPE (gnu_result),\n-\t\t\t       gnu_prefix, gnu_result));\n+    gnu_result = fold_build2 (COMPOUND_EXPR, TREE_TYPE (gnu_result),\n+\t\t\t      gnu_prefix, gnu_result);\n \n   *gnu_result_type_p = gnu_result_type;\n   return gnu_result;\n@@ -3079,13 +3079,13 @@ gnat_to_gnu (Node_Id gnat_node)\n                expression if the slice range is not null (max >= min) or\n                returns the min if the slice range is null */\n             gnu_expr\n-              = fold (build3 (COND_EXPR, gnu_expr_type,\n-\t\t\t      build_binary_op (GE_EXPR, gnu_expr_type,\n-\t\t\t\t\t       convert (gnu_expr_type,\n-\t\t\t\t\t\t\tgnu_max_expr),\n-\t\t\t\t\t       convert (gnu_expr_type,\n-\t\t\t\t\t\t\tgnu_min_expr)),\n-\t\t\t      gnu_expr, gnu_min_expr));\n+              = fold_build3 (COND_EXPR, gnu_expr_type,\n+\t\t\t     build_binary_op (GE_EXPR, gnu_expr_type,\n+\t\t\t\t\t      convert (gnu_expr_type,\n+\t\t\t\t\t\t       gnu_max_expr),\n+\t\t\t\t\t      convert (gnu_expr_type,\n+\t\t\t\t\t\t       gnu_min_expr)),\n+\t\t\t     gnu_expr, gnu_min_expr);\n           }\n         else\n           gnu_expr = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_result_type));\n@@ -5403,10 +5403,10 @@ emit_check (tree gnu_cond, tree gnu_expr, int reason)\n      in front of the comparison in case it ends up being a SAVE_EXPR.  Put the\n      whole thing inside its own SAVE_EXPR so the inner SAVE_EXPR doesn't leak\n      out.  */\n-  gnu_result = fold (build3 (COND_EXPR, TREE_TYPE (gnu_expr), gnu_cond,\n-\t\t\t     build2 (COMPOUND_EXPR, TREE_TYPE (gnu_expr),\n-\t\t\t\t     gnu_call, gnu_expr),\n-\t\t\t     gnu_expr));\n+  gnu_result = fold_build3 (COND_EXPR, TREE_TYPE (gnu_expr), gnu_cond,\n+\t\t\t    build2 (COMPOUND_EXPR, TREE_TYPE (gnu_expr),\n+\t\t\t\t    gnu_call, gnu_expr),\n+\t\t\t    gnu_expr);\n \n   /* If GNU_EXPR has side effects, make the outer COMPOUND_EXPR and\n      protect it.  Otherwise, show GNU_RESULT has no side effects: we"}, {"sha": "42c9a9df23ed30fdfc41ea4bb3e1017a885424c7", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9645c3c57385f21e01f6c0af9dc552485b156edd/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9645c3c57385f21e01f6c0af9dc552485b156edd/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=9645c3c57385f21e01f6c0af9dc552485b156edd", "patch": "@@ -868,10 +868,10 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n \n \tcase QUAL_UNION_TYPE:\n \t  ada_size\n-\t    = fold (build3 (COND_EXPR, bitsizetype, DECL_QUALIFIER (field),\n-\t\t\t    this_ada_size, ada_size));\n-\t  size = fold (build3 (COND_EXPR, bitsizetype, DECL_QUALIFIER (field),\n-\t\t\t       this_size, size));\n+\t    = fold_build3 (COND_EXPR, bitsizetype, DECL_QUALIFIER (field),\n+\t\t\t   this_ada_size, ada_size);\n+\t  size = fold_build3 (COND_EXPR, bitsizetype, DECL_QUALIFIER (field),\n+\t\t\t      this_size, size);\n \t  break;\n \n \tcase RECORD_TYPE:\n@@ -1133,15 +1133,15 @@ merge_sizes (tree last_size, tree first_bit, tree size, bool special,\n     }\n \n   else\n-    new = fold (build3 (COND_EXPR, type, TREE_OPERAND (size, 0),\n-\t\t\tinteger_zerop (TREE_OPERAND (size, 1))\n-\t\t\t? last_size : merge_sizes (last_size, first_bit,\n-\t\t\t\t\t\t   TREE_OPERAND (size, 1),\n-\t\t\t\t\t\t   1, has_rep),\n-\t\t\tinteger_zerop (TREE_OPERAND (size, 2))\n-\t\t\t? last_size : merge_sizes (last_size, first_bit,\n-\t\t\t\t\t\t   TREE_OPERAND (size, 2),\n-\t\t\t\t\t\t   1, has_rep)));\n+    new = fold_build3 (COND_EXPR, type, TREE_OPERAND (size, 0),\n+\t\t       integer_zerop (TREE_OPERAND (size, 1))\n+\t\t       ? last_size : merge_sizes (last_size, first_bit,\n+\t\t\t\t\t\t  TREE_OPERAND (size, 1),\n+\t\t\t\t\t\t  1, has_rep),\n+\t\t       integer_zerop (TREE_OPERAND (size, 2))\n+\t\t       ? last_size : merge_sizes (last_size, first_bit,\n+\t\t\t\t\t\t  TREE_OPERAND (size, 2),\n+\t\t\t\t\t\t  1, has_rep));\n \n   /* We don't need any NON_VALUE_EXPRs and they can confuse us (especially\n      when fed through substitute_in_expr) into thinking that a constant\n@@ -2372,9 +2372,9 @@ max_size (tree exp, bool max_p)\n \t    return max_size (TREE_OPERAND (exp, 0), max_p);\n \t  else\n \t    return\n-\t      fold (build1 (code, type,\n-\t\t\t    max_size (TREE_OPERAND (exp, 0),\n-\t\t\t\t      code == NEGATE_EXPR ? !max_p : max_p)));\n+\t      fold_build1 (code, type,\n+\t\t\t   max_size (TREE_OPERAND (exp, 0),\n+\t\t\t\t     code == NEGATE_EXPR ? !max_p : max_p));\n \n \tcase 2:\n \t  if (code == COMPOUND_EXPR)\n@@ -2424,16 +2424,16 @@ max_size (tree exp, bool max_p)\n \t\t     && !TREE_CONSTANT (rhs))\n \t      return lhs;\n \t    else\n-\t      return fold (build2 (code, type, lhs, rhs));\n+\t      return fold_build2 (code, type, lhs, rhs);\n \t  }\n \n \tcase 3:\n \t  if (code == SAVE_EXPR)\n \t    return exp;\n \t  else if (code == COND_EXPR)\n-\t    return fold (build2 (max_p ? MAX_EXPR : MIN_EXPR, type,\n-\t\t\t\t max_size (TREE_OPERAND (exp, 1), max_p),\n-\t\t\t\t max_size (TREE_OPERAND (exp, 2), max_p)));\n+\t    return fold_build2 (max_p ? MAX_EXPR : MIN_EXPR, type,\n+\t\t\t\tmax_size (TREE_OPERAND (exp, 1), max_p),\n+\t\t\t\tmax_size (TREE_OPERAND (exp, 2), max_p));\n \t}\n \n       /* Other tree classes cannot happen.  */\n@@ -3167,10 +3167,10 @@ convert (tree type, tree expr)\n \n   /* If the input is a biased type, adjust first.  */\n   if (ecode == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (etype))\n-    return convert (type, fold (build2 (PLUS_EXPR, TREE_TYPE (etype),\n-\t\t\t\t\tfold_convert (TREE_TYPE (etype),\n-\t\t\t\t\t\t      expr),\n-\t\t\t\t\tTYPE_MIN_VALUE (etype))));\n+    return convert (type, fold_build2 (PLUS_EXPR, TREE_TYPE (etype),\n+\t\t\t\t       fold_convert (TREE_TYPE (etype),\n+\t\t\t\t\t\t     expr),\n+\t\t\t\t       TYPE_MIN_VALUE (etype)));\n \n   /* If the input is a justified modular type, we need to extract the actual\n      object before converting it to any other type with the exceptions of an\n@@ -3321,7 +3321,7 @@ convert (tree type, tree expr)\n   switch (code)\n     {\n     case VOID_TYPE:\n-      return build1 (CONVERT_EXPR, type, expr);\n+      return fold_build1 (CONVERT_EXPR, type, expr);\n \n     case BOOLEAN_TYPE:\n       return fold_convert (type, gnat_truthvalue_conversion (expr));"}, {"sha": "8ad4c68c8672ef0c00a9fbf1d01c2c6f435172d7", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 77, "deletions": 71, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9645c3c57385f21e01f6c0af9dc552485b156edd/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9645c3c57385f21e01f6c0af9dc552485b156edd/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=9645c3c57385f21e01f6c0af9dc552485b156edd", "patch": "@@ -87,23 +87,27 @@ gnat_truthvalue_conversion (tree expr)\n       return expr;\n \n     case INTEGER_CST:\n-      return (integer_zerop (expr) ? convert (type, integer_zero_node)\n-\t      : convert (type, integer_one_node));\n+      return (integer_zerop (expr)\n+\t      ? build_int_cst (type, 0)\n+\t      : build_int_cst (type, 1));\n \n     case REAL_CST:\n-      return (real_zerop (expr) ? convert (type, integer_zero_node)\n-\t      : convert (type, integer_one_node));\n+      return (real_zerop (expr)\n+\t      ? fold_convert (type, integer_zero_node)\n+\t      : fold_convert (type, integer_one_node));\n \n     case COND_EXPR:\n       /* Distribute the conversion into the arms of a COND_EXPR.  */\n-      return fold\n-\t(build3 (COND_EXPR, type, TREE_OPERAND (expr, 0),\n-\t\t gnat_truthvalue_conversion (TREE_OPERAND (expr, 1)),\n-\t\t gnat_truthvalue_conversion (TREE_OPERAND (expr, 2))));\n+      {\n+\ttree arg1 = gnat_truthvalue_conversion (TREE_OPERAND (expr, 1));\n+\ttree arg2 = gnat_truthvalue_conversion (TREE_OPERAND (expr, 2));\n+\treturn fold_build3 (COND_EXPR, type, TREE_OPERAND (expr, 0),\n+\t\t\t    arg1, arg2);\n+      }\n \n     default:\n       return build_binary_op (NE_EXPR, type, expr,\n-\t\t\t      convert (type, integer_zero_node));\n+\t\t\t      fold_convert (type, integer_zero_node));\n     }\n }\n \f\n@@ -351,8 +355,8 @@ compare_arrays (tree result_type, tree a1, tree a2)\n       tree lb2 = TYPE_MIN_VALUE (TYPE_DOMAIN (t2));\n       tree ub2 = TYPE_MAX_VALUE (TYPE_DOMAIN (t2));\n       tree bt = get_base_type (TREE_TYPE (lb1));\n-      tree length1 = fold (build2 (MINUS_EXPR, bt, ub1, lb1));\n-      tree length2 = fold (build2 (MINUS_EXPR, bt, ub2, lb2));\n+      tree length1 = fold_build2 (MINUS_EXPR, bt, ub1, lb1);\n+      tree length2 = fold_build2 (MINUS_EXPR, bt, ub2, lb2);\n       tree nbt;\n       tree tem;\n       tree comparison, this_a1_is_null, this_a2_is_null;\n@@ -361,8 +365,8 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t unless the length of the second array is the constant zero.\n \t Note that we have set the `length' values to the length - 1.  */\n       if (TREE_CODE (length1) == INTEGER_CST\n-\t  && !integer_zerop (fold (build2 (PLUS_EXPR, bt, length2,\n-\t\t\t\t\t   convert (bt, integer_one_node)))))\n+\t  && !integer_zerop (fold_build2 (PLUS_EXPR, bt, length2,\n+\t\t\t\t\t  convert (bt, integer_one_node))))\n \t{\n \t  tem = a1, a1 = a2, a2 = tem;\n \t  tem = t1, t1 = t2, t2 = tem;\n@@ -375,8 +379,8 @@ compare_arrays (tree result_type, tree a1, tree a2)\n       /* If the length of this dimension in the second array is the constant\n \t zero, we can just go inside the original bounds for the first\n \t array and see if last < first.  */\n-      if (integer_zerop (fold (build2 (PLUS_EXPR, bt, length2,\n-\t\t\t\t       convert (bt, integer_one_node)))))\n+      if (integer_zerop (fold_build2 (PLUS_EXPR, bt, length2,\n+\t\t\t\t      convert (bt, integer_one_node))))\n \t{\n \t  tree ub = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n \t  tree lb = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n@@ -455,7 +459,7 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \ta1 = convert (type, a1), a2 = convert (type, a2);\n \n       result = build_binary_op (TRUTH_ANDIF_EXPR, result_type, result,\n-\t\t\t\tfold (build2 (EQ_EXPR, result_type, a1, a2)));\n+\t\t\t\tfold_build2 (EQ_EXPR, result_type, a1, a2));\n \n     }\n \n@@ -496,7 +500,10 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n   /* If this is an addition of a constant, convert it to a subtraction\n      of a constant since we can do that faster.  */\n   if (op_code == PLUS_EXPR && TREE_CODE (rhs) == INTEGER_CST)\n-    rhs = fold (build2 (MINUS_EXPR, type, modulus, rhs)), op_code = MINUS_EXPR;\n+    {\n+      rhs = fold_build2 (MINUS_EXPR, type, modulus, rhs);\n+      op_code = MINUS_EXPR;\n+    }\n \n   /* For the logical operations, we only need PRECISION bits.  For\n      addition and subtraction, we need one more and for multiplication we\n@@ -528,7 +535,7 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n     }\n \n   /* Do the operation, then we'll fix it up.  */\n-  result = fold (build2 (op_code, op_type, lhs, rhs));\n+  result = fold_build2 (op_code, op_type, lhs, rhs);\n \n   /* For multiplication, we have no choice but to do a full modulus\n      operation.  However, we want to do this in the narrowest\n@@ -540,32 +547,31 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n       SET_TYPE_MODULUS (div_type, modulus);\n       TYPE_MODULAR_P (div_type) = 1;\n       result = convert (op_type,\n-\t\t\tfold (build2 (TRUNC_MOD_EXPR, div_type,\n-\t\t\t\t      convert (div_type, result), modulus)));\n+\t\t\tfold_build2 (TRUNC_MOD_EXPR, div_type,\n+\t\t\t\t     convert (div_type, result), modulus));\n     }\n \n   /* For subtraction, add the modulus back if we are negative.  */\n   else if (op_code == MINUS_EXPR)\n     {\n       result = save_expr (result);\n-      result = fold (build3 (COND_EXPR, op_type,\n-\t\t\t     build2 (LT_EXPR, integer_type_node, result,\n-\t\t\t\t     convert (op_type, integer_zero_node)),\n-\t\t\t     fold (build2 (PLUS_EXPR, op_type,\n-\t\t\t\t\t   result, modulus)),\n-\t\t\t     result));\n+      result = fold_build3 (COND_EXPR, op_type,\n+\t\t\t    fold_build2 (LT_EXPR, integer_type_node, result,\n+\t\t\t\t\t convert (op_type, integer_zero_node)),\n+\t\t\t    fold_build2 (PLUS_EXPR, op_type, result, modulus),\n+\t\t\t    result);\n     }\n \n   /* For the other operations, subtract the modulus if we are >= it.  */\n   else\n     {\n       result = save_expr (result);\n-      result = fold (build3 (COND_EXPR, op_type,\n-\t\t\t     build2 (GE_EXPR, integer_type_node,\n-\t\t\t\t     result, modulus),\n-\t\t\t     fold (build2 (MINUS_EXPR, op_type,\n-\t\t\t\t\t   result, modulus)),\n-\t\t\t     result));\n+      result = fold_build3 (COND_EXPR, op_type,\n+\t\t\t    fold_build2 (GE_EXPR, integer_type_node,\n+\t\t\t\t\t result, modulus),\n+\t\t\t    fold_build2 (MINUS_EXPR, op_type,\n+\t\t\t\t\t result, modulus),\n+\t\t\t    result);\n     }\n \n   return convert (type, result);\n@@ -955,11 +961,11 @@ build_binary_op (enum tree_code op_code, tree result_type,\n   else if (TREE_CODE (right_operand) == NULL_EXPR)\n     return build1 (NULL_EXPR, operation_type, TREE_OPERAND (right_operand, 0));\n   else if (op_code == ARRAY_REF || op_code == ARRAY_RANGE_REF)\n-    result = fold (build4 (op_code, operation_type, left_operand,\n-\t\t\t   right_operand, NULL_TREE, NULL_TREE));\n+    result = build4 (op_code, operation_type, left_operand,\n+\t\t     right_operand, NULL_TREE, NULL_TREE);\n   else\n     result\n-      = fold (build2 (op_code, operation_type, left_operand, right_operand));\n+      = fold_build2 (op_code, operation_type, left_operand, right_operand);\n \n   TREE_SIDE_EFFECTS (result) |= has_side_effects;\n   TREE_CONSTANT (result)\n@@ -973,8 +979,8 @@ build_binary_op (enum tree_code op_code, tree result_type,\n   /* If we are working with modular types, perform the MOD operation\n      if something above hasn't eliminated the need for it.  */\n   if (modulus)\n-    result = fold (build2 (FLOOR_MOD_EXPR, operation_type, result,\n-\t\t\t   convert (operation_type, modulus)));\n+    result = fold_build2 (FLOOR_MOD_EXPR, operation_type, result,\n+\t\t\t  convert (operation_type, modulus));\n \n   if (result_type && result_type != operation_type)\n     result = convert (result_type, result);\n@@ -1012,7 +1018,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n       else\n \tgcc_assert (result_type == TREE_TYPE (type));\n \n-      result = fold (build1 (op_code, operation_type, operand));\n+      result = fold_build1 (op_code, operation_type, operand);\n       break;\n \n     case TRUTH_NOT_EXPR:\n@@ -1160,7 +1166,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t    operation_type = build_pointer_type (type);\n \n \t  gnat_mark_addressable (operand);\n-\t  result = fold (build1 (ADDR_EXPR, operation_type, operand));\n+\t  result = fold_build1 (ADDR_EXPR, operation_type, operand);\n \t}\n \n       TREE_CONSTANT (result) = staticp (operand) || TREE_CONSTANT (operand);\n@@ -1192,7 +1198,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \n       else\n \t{\n-\t  result = fold (build1 (op_code, TREE_TYPE (type), operand));\n+\t  result = fold_build1 (op_code, TREE_TYPE (type), operand);\n \t  TREE_READONLY (result) = TYPE_READONLY (TREE_TYPE (type));\n \t}\n \n@@ -1222,35 +1228,35 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t       the straightforward code; the TRUNC_MOD_EXPR below\n \t       is an AND operation.  */\n \t    if (op_code == NEGATE_EXPR && mod_pow2)\n-\t      result = fold (build2 (TRUNC_MOD_EXPR, operation_type,\n-\t\t\t\t     fold (build1 (NEGATE_EXPR, operation_type,\n-\t\t\t\t\t\t   operand)),\n-\t\t\t\t     modulus));\n+\t      result = fold_build2 (TRUNC_MOD_EXPR, operation_type,\n+\t\t\t\t    fold_build1 (NEGATE_EXPR, operation_type,\n+\t\t\t\t\t\t operand),\n+\t\t\t\t    modulus);\n \n \t    /* For nonbinary negate case, return zero for zero operand,\n \t       else return the modulus minus the operand.  If the modulus\n \t       is a power of two minus one, we can do the subtraction\n \t       as an XOR since it is equivalent and faster on most machines. */\n \t    else if (op_code == NEGATE_EXPR && !mod_pow2)\n \t      {\n-\t\tif (integer_pow2p (fold (build2 (PLUS_EXPR, operation_type,\n-\t\t\t\t\t\t modulus,\n-\t\t\t\t\t\t convert (operation_type,\n-\t\t\t\t\t\t\t  integer_one_node)))))\n-\t\t  result = fold (build2 (BIT_XOR_EXPR, operation_type,\n-\t\t\t\t\t operand, modulus));\n+\t\tif (integer_pow2p (fold_build2 (PLUS_EXPR, operation_type,\n+\t\t\t\t\t\tmodulus,\n+\t\t\t\t\t\tconvert (operation_type,\n+\t\t\t\t\t\t\t integer_one_node))))\n+\t\t  result = fold_build2 (BIT_XOR_EXPR, operation_type,\n+\t\t\t\t\toperand, modulus);\n \t\telse\n-\t\t  result = fold (build2 (MINUS_EXPR, operation_type,\n-\t\t\t\t\tmodulus, operand));\n-\n-\t\tresult = fold (build3 (COND_EXPR, operation_type,\n-\t\t\t\t       fold (build2 (NE_EXPR,\n-\t\t\t\t\t\t     integer_type_node,\n-\t\t\t\t\t\t     operand,\n-\t\t\t\t\t\t     convert\n+\t\t  result = fold_build2 (MINUS_EXPR, operation_type,\n+\t\t\t\t\tmodulus, operand);\n+\n+\t\tresult = fold_build3 (COND_EXPR, operation_type,\n+\t\t\t\t      fold_build2 (NE_EXPR,\n+\t\t\t\t\t\t   integer_type_node,\n+\t\t\t\t\t\t   operand,\n+\t\t\t\t\t\t   convert\n \t\t\t\t\t\t     (operation_type,\n-\t\t\t\t\t\t      integer_zero_node))),\n-\t\t\t\t       result, operand));\n+\t\t\t\t\t\t      integer_zero_node)),\n+\t\t\t\t      result, operand);\n \t      }\n \t    else\n \t      {\n@@ -1259,16 +1265,16 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t\t   XOR against the constant and subtract the operand from\n \t\t   that constant for nonbinary modulus.  */\n \n-\t\ttree cnst = fold (build2 (MINUS_EXPR, operation_type, modulus,\n-\t\t\t\t\t  convert (operation_type,\n-\t\t\t\t\t\t   integer_one_node)));\n+\t\ttree cnst = fold_build2 (MINUS_EXPR, operation_type, modulus,\n+\t\t\t\t\t convert (operation_type,\n+\t\t\t\t\t\t  integer_one_node));\n \n \t\tif (mod_pow2)\n-\t\t  result = fold (build2 (BIT_XOR_EXPR, operation_type,\n-\t\t\t\t\t operand, cnst));\n+\t\t  result = fold_build2 (BIT_XOR_EXPR, operation_type,\n+\t\t\t\t\toperand, cnst);\n \t\telse\n-\t\t  result = fold (build2 (MINUS_EXPR, operation_type,\n-\t\t\t\t\t cnst, operand));\n+\t\t  result = fold_build2 (MINUS_EXPR, operation_type,\n+\t\t\t\t\tcnst, operand);\n \t      }\n \n \t    break;\n@@ -1279,8 +1285,8 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \n     default:\n       gcc_assert (operation_type == base_type);\n-      result = fold (build1 (op_code, operation_type, convert (operation_type,\n-\t\t\t\t\t\t\t       operand)));\n+      result = fold_build1 (op_code, operation_type,\n+\t\t\t    convert (operation_type, operand));\n     }\n \n   if (side_effects)\n@@ -1322,8 +1328,8 @@ build_cond_expr (tree result_type, tree condition_operand,\n       false_operand = build_unary_op (ADDR_EXPR, result_type, false_operand);\n     }\n \n-  result = fold (build3 (COND_EXPR, result_type, condition_operand,\n-\t\t\t true_operand, false_operand));\n+  result = fold_build3 (COND_EXPR, result_type, condition_operand,\n+\t\t\ttrue_operand, false_operand);\n \n   /* If either operand is a SAVE_EXPR (possibly surrounded by\n      arithmetic, make sure it gets done.  */"}]}