{"sha": "287b3dd2b2d990bebaa274ba2183b09f8e2aadae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg3YjNkZDJiMmQ5OTBiZWJhYTI3NGJhMjE4M2IwOWY4ZTJhYWRhZQ==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael.morin@sfr.fr", "date": "2011-10-07T19:39:22Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-10-07T19:39:22Z"}, "message": "trans-array.c (gfc_conv_section_startstride): Move code to evaluate_bound.\n\n\t* trans-array.c (gfc_conv_section_startstride): Move code to\n\tevaluate_bound.  Use evaluate_bound.\n\t(evaluate_bound): New function.\n\nFrom-SVN: r179681", "tree": {"sha": "d8dd5e2c97ccdb22320cbeb611401519d8482676", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8dd5e2c97ccdb22320cbeb611401519d8482676"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/287b3dd2b2d990bebaa274ba2183b09f8e2aadae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/287b3dd2b2d990bebaa274ba2183b09f8e2aadae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/287b3dd2b2d990bebaa274ba2183b09f8e2aadae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/287b3dd2b2d990bebaa274ba2183b09f8e2aadae/comments", "author": null, "committer": null, "parents": [{"sha": "b0ac6998a7fd8565334e19c488aeaa73a91a1e4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0ac6998a7fd8565334e19c488aeaa73a91a1e4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0ac6998a7fd8565334e19c488aeaa73a91a1e4a"}], "stats": {"total": 76, "additions": 42, "deletions": 34}, "files": [{"sha": "668149b68e974c1bd0e327dd5ca7c06e81673107", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/287b3dd2b2d990bebaa274ba2183b09f8e2aadae/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/287b3dd2b2d990bebaa274ba2183b09f8e2aadae/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=287b3dd2b2d990bebaa274ba2183b09f8e2aadae", "patch": "@@ -1,3 +1,9 @@\n+2011-10-07  Mikael Morin  <mikael.morin@sfr.fr>\n+\n+\t* trans-array.c (gfc_conv_section_startstride): Move code to\n+\tevaluate_bound.  Use evaluate_bound.\n+\t(evaluate_bound): New function.\n+\n 2011-10-07  Mikael Morin  <mikael.morin@sfr.fr>\n \n \t* trans-array.c (gfc_conv_section_startstride): Update assertion to"}, {"sha": "ee5761bd947c413dcbe7c6e7152c9f4cd7d56232", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/287b3dd2b2d990bebaa274ba2183b09f8e2aadae/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/287b3dd2b2d990bebaa274ba2183b09f8e2aadae/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=287b3dd2b2d990bebaa274ba2183b09f8e2aadae", "patch": "@@ -3175,14 +3175,46 @@ gfc_trans_scalarized_loop_boundary (gfc_loopinfo * loop, stmtblock_t * body)\n }\n \n \n+/* Precalculate (either lower or upper) bound of an array section.\n+     BLOCK: Block in which the (pre)calculation code will go.\n+     BOUNDS[DIM]: Where the bound value will be stored once evaluated.\n+     VALUES[DIM]: Specified bound (NULL <=> unspecified).\n+     DESC: Array descriptor from which the bound will be picked if unspecified\n+       (either lower or upper bound according to LBOUND).  */\n+\n+static void\n+evaluate_bound (stmtblock_t *block, tree *bounds, gfc_expr ** values,\n+\t\ttree desc, int dim, bool lbound)\n+{\n+  gfc_se se;\n+  gfc_expr * input_val = values[dim];\n+  tree *output = &bounds[dim];\n+\n+\n+  if (input_val)\n+    {\n+      /* Specified section bound.  */\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr_type (&se, input_val, gfc_array_index_type);\n+      gfc_add_block_to_block (block, &se.pre);\n+      *output = se.expr;\n+    }\n+  else\n+    {\n+      /* No specific bound specified so use the bound of the array.  */\n+      *output = lbound ? gfc_conv_array_lbound (desc, dim) :\n+\t\t\t gfc_conv_array_ubound (desc, dim);\n+    }\n+  *output = gfc_evaluate_now (*output, block);\n+}\n+\n+\n /* Calculate the lower bound of an array section.  */\n \n static void\n gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int dim,\n \t\t\t      bool coarray, bool coarray_last)\n {\n-  gfc_expr *start;\n-  gfc_expr *end;\n   gfc_expr *stride = NULL;\n   tree desc;\n   gfc_se se;\n@@ -3207,48 +3239,18 @@ gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int dim,\n   gcc_assert (ar->dimen_type[dim] == DIMEN_RANGE\n \t      || ar->dimen_type[dim] == DIMEN_THIS_IMAGE);\n   desc = info->descriptor;\n-  start = ar->start[dim];\n-  end = ar->end[dim];\n   if (!coarray)\n     stride = ar->stride[dim];\n \n   /* Calculate the start of the range.  For vector subscripts this will\n      be the range of the vector.  */\n-  if (start)\n-    {\n-      /* Specified section start.  */\n-      gfc_init_se (&se, NULL);\n-      gfc_conv_expr_type (&se, start, gfc_array_index_type);\n-      gfc_add_block_to_block (&loop->pre, &se.pre);\n-      info->start[dim] = se.expr;\n-    }\n-  else\n-    {\n-      /* No lower bound specified so use the bound of the array.  */\n-      info->start[dim] = gfc_conv_array_lbound (desc, dim);\n-    }\n-  info->start[dim] = gfc_evaluate_now (info->start[dim], &loop->pre);\n+  evaluate_bound (&loop->pre, info->start, ar->start, desc, dim, true);\n \n   /* Similarly calculate the end.  Although this is not used in the\n      scalarizer, it is needed when checking bounds and where the end\n      is an expression with side-effects.  */\n   if (!coarray_last)\n-    {\n-      if (end)\n-\t{\n-\t  /* Specified section start.  */\n-\t  gfc_init_se (&se, NULL);\n-\t  gfc_conv_expr_type (&se, end, gfc_array_index_type);\n-\t  gfc_add_block_to_block (&loop->pre, &se.pre);\n-\t  info->end[dim] = se.expr;\n-\t}\n-      else\n-\t{\n-\t  /* No upper bound specified so use the bound of the array.  */\n-\t  info->end[dim] = gfc_conv_array_ubound (desc, dim);\n-\t}\n-      info->end[dim] = gfc_evaluate_now (info->end[dim], &loop->pre);\n-    }\n+    evaluate_bound (&loop->pre, info->end, ar->end, desc, dim, false);\n \n   /* Calculate the stride.  */\n   if (!coarray && stride == NULL)"}]}