{"sha": "2cad8a59a8060b0897d18d4075d96eb7c541e845", "node_id": "C_kwDOANBUbNoAKDJjYWQ4YTU5YTgwNjBiMDg5N2QxOGQ0MDc1ZDk2ZWI3YzU0MWU4NDU", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-05-27T13:28:29Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-04T07:45:58Z"}, "message": "[Ada] Use static stack allocation for small dynamic string concatenations\n\nThis changes the expanded code generated for dynamic concatenations to\nuse a static array subtype for the temporary created on the stack if a\nsmall upper bound can be computed for the length of the result.  Static\nstack allocation is preferred over dynamic allocation for code\ngeneration purposes.\n\ngcc/ada/\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration.Rewrite_As_Renaming):\n\tBe prepared for slices.\n\t* exp_ch4.adb (Get_First_Index_Bounds): New procedure.\n\t(Expand_Array_Comparison.Length_Less_Than_4): Call it.\n\t(Expand_Concatenate): Try to compute a maximum length for\n\toperands with variable length and a maximum total length at the\n\tend.  If the concatenation is dynamic, but a sensible maximum\n\ttotal length has been computed, use this length to create a\n\tstatic array subtype for the temporary and return a slice of it.", "tree": {"sha": "a27d06b646a7a93c8c3ec1620d04dde3cc45fdd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a27d06b646a7a93c8c3ec1620d04dde3cc45fdd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2cad8a59a8060b0897d18d4075d96eb7c541e845", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cad8a59a8060b0897d18d4075d96eb7c541e845", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cad8a59a8060b0897d18d4075d96eb7c541e845", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cad8a59a8060b0897d18d4075d96eb7c541e845/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3451ba8aa3a54c6f09ee049a1a406603ed2ec30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3451ba8aa3a54c6f09ee049a1a406603ed2ec30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3451ba8aa3a54c6f09ee049a1a406603ed2ec30"}], "stats": {"total": 310, "additions": 207, "deletions": 103}, "files": [{"sha": "75d94b0947a830cf01f5a92d47d98647842c0973", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cad8a59a8060b0897d18d4075d96eb7c541e845/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cad8a59a8060b0897d18d4075d96eb7c541e845/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=2cad8a59a8060b0897d18d4075d96eb7c541e845", "patch": "@@ -6806,6 +6806,21 @@ package body Exp_Ch3 is\n       -------------------------\n \n       function Rewrite_As_Renaming return Boolean is\n+\n+         function OK_To_Rename_Entity_Name (N : Node_Id) return Boolean;\n+         --  Return True if N denotes an entity with OK_To_Rename set\n+\n+         ------------------------------\n+         -- OK_To_Rename_Entity_Name --\n+         ------------------------------\n+\n+         function OK_To_Rename_Entity_Name (N : Node_Id) return Boolean is\n+         begin\n+            return Is_Entity_Name (N)\n+              and then Ekind (Entity (N)) = E_Variable\n+              and then OK_To_Rename (Entity (N));\n+         end OK_To_Rename_Entity_Name;\n+\n          Result : constant Boolean :=\n \n          --  If the object declaration appears in the form\n@@ -6844,10 +6859,11 @@ package body Exp_Ch3 is\n \n            or else\n              (not Aliased_Present (N)\n-               and then Is_Entity_Name (Expr_Q)\n-               and then Ekind (Entity (Expr_Q)) = E_Variable\n-               and then OK_To_Rename (Entity (Expr_Q))\n-               and then Is_Entity_Name (Obj_Def));\n+               and then (OK_To_Rename_Entity_Name (Expr_Q)\n+                          or else\n+                         (Nkind (Expr_Q) = N_Slice\n+                           and then\n+                          OK_To_Rename_Entity_Name (Prefix (Expr_Q)))));\n       begin\n          --  ??? Return False if there are any aspect specifications, because\n          --  otherwise we duplicate that corresponding implicit attribute"}, {"sha": "cf29fb797b0ab8a1453fe5815935ed2e7b4c2209", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 187, "deletions": 99, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cad8a59a8060b0897d18d4075d96eb7c541e845/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cad8a59a8060b0897d18d4075d96eb7c541e845/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=2cad8a59a8060b0897d18d4075d96eb7c541e845", "patch": "@@ -174,6 +174,10 @@ package body Exp_Ch4 is\n    --  routine is to find the real type by looking up the tree. We also\n    --  determine if the operation must be rounded.\n \n+   procedure Get_First_Index_Bounds (T : Entity_Id; Lo, Hi : out Uint);\n+   --  T is an array whose index bounds are all known at compile time. Return\n+   --  the value of the low and high bounds of the first index of T.\n+\n    function Get_Size_For_Range (Lo, Hi : Uint) return Uint;\n    --  Return the size of a small signed integer type covering Lo .. Hi, the\n    --  main goal being to return a size lower than that of standard types.\n@@ -1328,29 +1332,17 @@ package body Exp_Ch4 is\n          if Ekind (Otyp) = E_String_Literal_Subtype then\n             return String_Literal_Length (Otyp) < 4;\n \n-         else\n+         elsif Compile_Time_Known_Bounds (Otyp) then\n             declare\n-               Ityp : constant Entity_Id := Etype (First_Index (Otyp));\n-               Lo   : constant Node_Id   := Type_Low_Bound (Ityp);\n-               Hi   : constant Node_Id   := Type_High_Bound (Ityp);\n-               Lov  : Uint;\n-               Hiv  : Uint;\n+               Lo, Hi : Uint;\n \n             begin\n-               if Compile_Time_Known_Value (Lo) then\n-                  Lov := Expr_Value (Lo);\n-               else\n-                  return False;\n-               end if;\n-\n-               if Compile_Time_Known_Value (Hi) then\n-                  Hiv := Expr_Value (Hi);\n-               else\n-                  return False;\n-               end if;\n-\n-               return Hiv < Lov + 3;\n+               Get_First_Index_Bounds (Otyp, Lo, Hi);\n+               return Hi < Lo + 3;\n             end;\n+\n+         else\n+            return False;\n          end if;\n       end Length_Less_Than_4;\n \n@@ -2701,6 +2693,9 @@ package body Exp_Ch4 is\n       --  this loop is complete, always contains the last operand (which is not\n       --  the same as Operands (NN), since null operands are skipped).\n \n+      Too_Large_Max_Length : constant Unat := UI_From_Int (256);\n+      --  Threshold from which the computation of maximum lengths is useless\n+\n       --  Arrays describing the operands, only the first NN entries of each\n       --  array are set (NN < N when we exclude known null operands).\n \n@@ -2711,10 +2706,15 @@ package body Exp_Ch4 is\n       --  Set to the corresponding entry in the Opnds list (but note that null\n       --  operands are excluded, so not all entries in the list are stored).\n \n-      Fixed_Length : array (1 .. N) of Uint;\n+      Fixed_Length : array (1 .. N) of Unat;\n       --  Set to length of operand. Entries in this array are set only if the\n       --  corresponding entry in Is_Fixed_Length is True.\n \n+      Max_Length : array (1 .. N) of Unat;\n+      --  Set to the maximum length of operand, or Too_Large_Max_Length if it\n+      --  is not known. Entries in this array are set only if the corresponding\n+      --  entry in Is_Fixed_Length is False;\n+\n       Opnd_Low_Bound : array (1 .. N) of Node_Id;\n       --  Set to lower bound of operand. Either an integer literal in the case\n       --  where the bound is known at compile time, else actual lower bound.\n@@ -2727,17 +2727,24 @@ package body Exp_Ch4 is\n       --  is False. The entity is of type Artyp.\n \n       Aggr_Length : array (0 .. N) of Node_Id;\n-      --  The J'th entry in an expression node that represents the total length\n+      --  The J'th entry is an expression node that represents the total length\n       --  of operands 1 through J. It is either an integer literal node, or a\n       --  reference to a constant entity with the right value, so it is fine\n       --  to just do a Copy_Node to get an appropriate copy. The extra zeroth\n       --  entry always is set to zero. The length is of type Artyp.\n \n+      Max_Aggr_Length : Unat := Too_Large_Max_Length;\n+      --  Set to the maximum total length, or at least Too_Large_Max_Length if\n+      --  it is not known.\n+\n       Low_Bound : Node_Id := Empty;\n       --  A tree node representing the low bound of the result (of type Ityp).\n       --  This is either an integer literal node, or an identifier reference to\n       --  a constant entity initialized to the appropriate value.\n \n+      High_Bound : Node_Id := Empty;\n+      --  A tree node representing the high bound of the result (of type Ityp)\n+\n       Last_Opnd_Low_Bound : Node_Id := Empty;\n       --  A tree node representing the low bound of the last operand. This\n       --  need only be set if the result could be null. It is used for the\n@@ -2750,9 +2757,6 @@ package body Exp_Ch4 is\n       --  special case of setting the right high bound for a null result.\n       --  This is of type Ityp.\n \n-      High_Bound : Node_Id := Empty;\n-      --  A tree node representing the high bound of the result (of type Ityp)\n-\n       Result : Node_Id := Empty;\n       --  Result of the concatenation (of type Ityp)\n \n@@ -2767,7 +2771,7 @@ package body Exp_Ch4 is\n       --  Return True if the concatenation is within the expression of the\n       --  declaration of a library-level object.\n \n-      function Make_Artyp_Literal (Val : Nat) return Node_Id;\n+      function Make_Artyp_Literal (Val : Uint) return Node_Id;\n       --  This function makes an N_Integer_Literal node that is returned in\n       --  analyzed form with the type set to Artyp. Importantly this literal\n       --  is not flagged as static, so that if we do computations with it that\n@@ -2810,7 +2814,7 @@ package body Exp_Ch4 is\n       -- Make_Artyp_Literal --\n       ------------------------\n \n-      function Make_Artyp_Literal (Val : Nat) return Node_Id is\n+      function Make_Artyp_Literal (Val : Uint) return Node_Id is\n          Result : constant Node_Id := Make_Integer_Literal (Loc, Val);\n       begin\n          Set_Etype (Result, Artyp);\n@@ -2867,9 +2871,10 @@ package body Exp_Ch4 is\n       --  Local Declarations\n \n       Opnd_Typ   : Entity_Id;\n+      Slice_Rng  : Entity_Id;\n       Subtyp_Ind : Entity_Id;\n       Ent        : Entity_Id;\n-      Len        : Uint;\n+      Len        : Unat;\n       J          : Nat;\n       Clen       : Node_Id;\n       Set        : Boolean;\n@@ -2925,7 +2930,7 @@ package body Exp_Ch4 is\n \n       --  Supply dummy entry at start of length array\n \n-      Aggr_Length (0) := Make_Artyp_Literal (0);\n+      Aggr_Length (0) := Make_Artyp_Literal (Uint_0);\n \n       --  Go through operands setting up the above arrays\n \n@@ -2969,7 +2974,7 @@ package body Exp_Ch4 is\n          elsif Nkind (Opnd) = N_String_Literal then\n             Len := String_Literal_Length (Opnd_Typ);\n \n-            if Len /= 0 then\n+            if Len > 0 then\n                Result_May_Be_Null := False;\n             end if;\n \n@@ -3010,61 +3015,47 @@ package body Exp_Ch4 is\n          else\n             --  Check constrained case with known bounds\n \n-            if Is_Constrained (Opnd_Typ) then\n+            if Is_Constrained (Opnd_Typ)\n+              and then Compile_Time_Known_Bounds (Opnd_Typ)\n+            then\n                declare\n-                  Index    : constant Node_Id   := First_Index (Opnd_Typ);\n-                  Indx_Typ : constant Entity_Id := Etype (Index);\n-                  Lo       : constant Node_Id   := Type_Low_Bound  (Indx_Typ);\n-                  Hi       : constant Node_Id   := Type_High_Bound (Indx_Typ);\n+                  Lo, Hi : Uint;\n \n                begin\n                   --  Fixed length constrained array type with known at compile\n                   --  time bounds is last case of fixed length operand.\n \n-                  if Compile_Time_Known_Value (Lo)\n-                       and then\n-                     Compile_Time_Known_Value (Hi)\n-                  then\n-                     declare\n-                        Loval : constant Uint := Expr_Value (Lo);\n-                        Hival : constant Uint := Expr_Value (Hi);\n-                        Len   : constant Uint :=\n-                                  UI_Max (Hival - Loval + 1, Uint_0);\n+                  Get_First_Index_Bounds (Opnd_Typ, Lo, Hi);\n+                  Len := UI_Max (Hi - Lo + 1, Uint_0);\n \n-                     begin\n-                        if Len > 0 then\n-                           Result_May_Be_Null := False;\n-                        end if;\n+                  if Len > 0 then\n+                     Result_May_Be_Null := False;\n+                  end if;\n \n-                        --  Capture last operand bounds if result could be null\n+                  --  Capture last operand bounds if result could be null\n \n-                        if J = N and then Result_May_Be_Null then\n-                           Last_Opnd_Low_Bound :=\n-                             Convert_To (Ityp,\n-                               Make_Integer_Literal (Loc, Expr_Value (Lo)));\n+                  if J = N and then Result_May_Be_Null then\n+                     Last_Opnd_Low_Bound :=\n+                       To_Ityp (Make_Integer_Literal (Loc, Lo));\n \n-                           Last_Opnd_High_Bound :=\n-                             Convert_To (Ityp,\n-                               Make_Integer_Literal (Loc, Expr_Value (Hi)));\n-                        end if;\n+                     Last_Opnd_High_Bound :=\n+                       To_Ityp (Make_Integer_Literal (Loc, Hi));\n+                  end if;\n \n-                        --  Exclude null length case unless last operand\n+                  --  Exclude null length case unless last operand\n \n-                        if J < N and then Len = 0 then\n-                           goto Continue;\n-                        end if;\n+                  if J < N and then Len = 0 then\n+                     goto Continue;\n+                  end if;\n \n-                        NN := NN + 1;\n-                        Operands (NN) := Opnd;\n-                        Is_Fixed_Length (NN) := True;\n-                        Fixed_Length (NN)    := Len;\n+                  NN := NN + 1;\n+                  Operands (NN) := Opnd;\n+                  Is_Fixed_Length (NN) := True;\n+                  Fixed_Length (NN)    := Len;\n \n-                        Opnd_Low_Bound (NN) :=\n-                          To_Ityp\n-                            (Make_Integer_Literal (Loc, Expr_Value (Lo)));\n-                        Set := True;\n-                     end;\n-                  end if;\n+                  Opnd_Low_Bound (NN) :=\n+                    To_Ityp (Make_Integer_Literal (Loc, Lo));\n+                  Set := True;\n                end;\n             end if;\n \n@@ -3108,6 +3099,25 @@ package body Exp_Ch4 is\n \n                Var_Length (NN) := Make_Temporary (Loc, 'L');\n \n+               --  If the operand is a slice, try to compute an upper bound for\n+               --  its length.\n+\n+               if Nkind (Opnd) = N_Slice\n+                  and then Is_Constrained (Etype (Prefix (Opnd)))\n+                  and then Compile_Time_Known_Bounds (Etype (Prefix (Opnd)))\n+               then\n+                  declare\n+                     Lo, Hi : Uint;\n+\n+                  begin\n+                     Get_First_Index_Bounds (Etype (Prefix (Opnd)), Lo, Hi);\n+                     Max_Length (NN) := UI_Max (Hi - Lo + 1, Uint_0);\n+                  end;\n+\n+               else\n+                  Max_Length (NN) := Too_Large_Max_Length;\n+               end if;\n+\n                Append_To (Actions,\n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => Var_Length (NN),\n@@ -3129,8 +3139,10 @@ package body Exp_Ch4 is\n          if NN = 1 then\n             if Is_Fixed_Length (1) then\n                Aggr_Length (1) := Make_Integer_Literal (Loc, Fixed_Length (1));\n+               Max_Aggr_Length := Fixed_Length (1);\n             else\n                Aggr_Length (1) := New_Occurrence_Of (Var_Length (1), Loc);\n+               Max_Aggr_Length := Max_Length (1);\n             end if;\n \n          --  If entry is fixed length and only fixed lengths so far, make\n@@ -3142,6 +3154,7 @@ package body Exp_Ch4 is\n             Aggr_Length (NN) :=\n               Make_Integer_Literal (Loc,\n                 Intval => Fixed_Length (NN) + Intval (Aggr_Length (NN - 1)));\n+            Max_Aggr_Length := Intval (Aggr_Length (NN));\n \n          --  All other cases, construct an addition node for the length and\n          --  create an entity initialized to this length.\n@@ -3151,8 +3164,11 @@ package body Exp_Ch4 is\n \n             if Is_Fixed_Length (NN) then\n                Clen := Make_Integer_Literal (Loc, Fixed_Length (NN));\n+               Max_Aggr_Length := Max_Aggr_Length + Fixed_Length (NN);\n+\n             else\n                Clen := New_Occurrence_Of (Var_Length (NN), Loc);\n+               Max_Aggr_Length := Max_Aggr_Length + Max_Length (NN);\n             end if;\n \n             Append_To (Actions,\n@@ -3277,29 +3293,38 @@ package body Exp_Ch4 is\n \n       pragma Assert (Present (Low_Bound));\n \n-      --  Now we can safely compute the upper bound, normally\n-      --  Low_Bound + Length - 1.\n-\n-      High_Bound :=\n-        To_Ityp\n-          (Make_Op_Add (Loc,\n-             Left_Opnd  => To_Artyp (New_Copy_Tree (Low_Bound)),\n-             Right_Opnd =>\n-               Make_Op_Subtract (Loc,\n-                 Left_Opnd  => New_Copy_Tree (Aggr_Length (NN)),\n-                 Right_Opnd => Make_Artyp_Literal (1))));\n-\n-      --  Note that calculation of the high bound may cause overflow in some\n-      --  very weird cases, so in the general case we need an overflow check on\n-      --  the high bound. We can avoid this for the common case of string types\n-      --  and other types whose index is Positive, since we chose a wider range\n-      --  for the arithmetic type. If checks are suppressed we do not set the\n-      --  flag, and possibly superfluous warnings will be omitted.\n+      --  Now we can compute the high bound as Low_Bound + Length - 1\n \n-      if Istyp /= Standard_Positive\n-        and then not Overflow_Checks_Suppressed (Istyp)\n+      if Compile_Time_Known_Value (Low_Bound)\n+        and then Nkind (Aggr_Length (NN)) = N_Integer_Literal\n       then\n-         Activate_Overflow_Check (High_Bound);\n+         High_Bound :=\n+           To_Ityp\n+             (Make_Artyp_Literal\n+                (Expr_Value (Low_Bound) + Intval (Aggr_Length (NN)) - 1));\n+\n+      else\n+         High_Bound :=\n+           To_Ityp\n+             (Make_Op_Add (Loc,\n+                Left_Opnd  => To_Artyp (New_Copy_Tree (Low_Bound)),\n+                Right_Opnd =>\n+                  Make_Op_Subtract (Loc,\n+                    Left_Opnd  => New_Copy_Tree (Aggr_Length (NN)),\n+                    Right_Opnd => Make_Artyp_Literal (Uint_1))));\n+\n+         --  Note that calculation of the high bound may cause overflow in some\n+         --  very weird cases, so in the general case we need an overflow check\n+         --  on the high bound. We can avoid this for the common case of string\n+         --  types and other types whose index is Positive, since we chose a\n+         --  wider range for the arithmetic type. If checks are suppressed, we\n+         --  do not set the flag so superfluous warnings may be omitted.\n+\n+         if Istyp /= Standard_Positive\n+           and then not Overflow_Checks_Suppressed (Istyp)\n+         then\n+            Activate_Overflow_Check (High_Bound);\n+         end if;\n       end if;\n \n       --  Handle the exceptional case where the result is null, in which case\n@@ -3312,7 +3337,7 @@ package body Exp_Ch4 is\n              Expressions => New_List (\n                Make_Op_Eq (Loc,\n                  Left_Opnd  => New_Copy_Tree (Aggr_Length (NN)),\n-                 Right_Opnd => Make_Artyp_Literal (0)),\n+                 Right_Opnd => Make_Artyp_Literal (Uint_0)),\n                Last_Opnd_Low_Bound,\n                Low_Bound));\n \n@@ -3321,7 +3346,7 @@ package body Exp_Ch4 is\n              Expressions => New_List (\n                Make_Op_Eq (Loc,\n                  Left_Opnd  => New_Copy_Tree (Aggr_Length (NN)),\n-                 Right_Opnd => Make_Artyp_Literal (0)),\n+                 Right_Opnd => Make_Artyp_Literal (Uint_0)),\n                Last_Opnd_High_Bound,\n                High_Bound));\n       end if;\n@@ -3330,6 +3355,35 @@ package body Exp_Ch4 is\n \n       Insert_Actions (Cnode, Actions, Suppress => All_Checks);\n \n+      --  If the low bound is known at compile time and not the high bound, but\n+      --  we have computed a sensible upper bound for the length, then adjust\n+      --  the high bound for the subtype of the array. This will change it into\n+      --  a static subtype and thus help the code generator.\n+\n+      if Compile_Time_Known_Value (Low_Bound)\n+        and then not Compile_Time_Known_Value (High_Bound)\n+        and then Max_Aggr_Length < Too_Large_Max_Length\n+      then\n+         declare\n+            Known_High_Bound : constant Node_Id :=\n+              To_Ityp\n+                (Make_Artyp_Literal\n+                   (Expr_Value (Low_Bound) +  Max_Aggr_Length - 1));\n+\n+         begin\n+            if not Is_Out_Of_Range (Known_High_Bound, Ityp) then\n+               Slice_Rng  := Make_Range (Loc, Low_Bound, High_Bound);\n+               High_Bound := Known_High_Bound;\n+\n+            else\n+               Slice_Rng := Empty;\n+            end if;\n+         end;\n+\n+      else\n+         Slice_Rng := Empty;\n+      end if;\n+\n       --  Now we construct an array object with appropriate bounds. We mark\n       --  the target as internal to prevent useless initialization when\n       --  Initialize_Scalars is enabled. Also since this is the actual result\n@@ -3443,16 +3497,26 @@ package body Exp_Ch4 is\n \n       --  Catch the static out of range case now\n \n-      if Raises_Constraint_Error (High_Bound) then\n+      if Raises_Constraint_Error (High_Bound)\n+        or else Is_Out_Of_Range (High_Bound, Ityp)\n+      then\n          --  Kill warning generated for the declaration of the static out of\n          --  range high bound, and instead generate a Constraint_Error with\n          --  an appropriate specific message.\n \n-         Kill_Dead_Code (Declaration_Node (Entity (High_Bound)));\n+         if Nkind (High_Bound) = N_Integer_Literal then\n+            Kill_Dead_Code (High_Bound);\n+            Rewrite (High_Bound, New_Copy_Tree (Low_Bound));\n+\n+         else\n+            Kill_Dead_Code (Declaration_Node (Entity (High_Bound)));\n+         end if;\n+\n          Apply_Compile_Time_Constraint_Error\n            (N      => Cnode,\n             Msg    => \"concatenation result upper bound out of range??\",\n             Reason => CE_Range_Check_Failed);\n+\n          return;\n       end if;\n \n@@ -3529,8 +3593,9 @@ package body Exp_Ch4 is\n                       Name => New_Occurrence_Of (RTE (RR (NN)), Loc),\n                       Parameter_Associations => Opnds));\n \n-                  Result := New_Occurrence_Of (Ent, Loc);\n-                  goto Done;\n+                  --  No assignments left to do below\n+\n+                  NN := 0;\n                end;\n             end if;\n          end;\n@@ -3553,7 +3618,7 @@ package body Exp_Ch4 is\n                      Right_Opnd =>\n                        Make_Op_Subtract (Loc,\n                          Left_Opnd  => Aggr_Length (J),\n-                         Right_Opnd => Make_Artyp_Literal (1)));\n+                         Right_Opnd => Make_Artyp_Literal (Uint_1)));\n \n          begin\n             --  Singleton case, simple assignment\n@@ -3614,10 +3679,15 @@ package body Exp_Ch4 is\n          end;\n       end loop;\n \n-      --  Finally we build the result, which is a reference to the array object\n+      --  Finally we build the result, which is either a direct reference to\n+      --  the array object or a slice of it.\n \n       Result := New_Occurrence_Of (Ent, Loc);\n \n+      if Present (Slice_Rng) then\n+         Result := Make_Slice (Loc, Result, Slice_Rng);\n+      end if;\n+\n    <<Done>>\n       pragma Assert (Present (Result));\n       Rewrite (Cnode, Result);\n@@ -13318,6 +13388,24 @@ package body Exp_Ch4 is\n       end if;\n    end Fixup_Universal_Fixed_Operation;\n \n+   ----------------------------\n+   -- Get_First_Index_Bounds --\n+   ----------------------------\n+\n+   procedure Get_First_Index_Bounds (T : Entity_Id; Lo, Hi : out Uint) is\n+      Typ  : Entity_Id;\n+\n+   begin\n+      pragma Assert (Is_Array_Type (T));\n+\n+      --  This follows Sem_Eval.Compile_Time_Known_Bounds\n+\n+      Typ := Underlying_Type (Etype (First_Index (T)));\n+\n+      Lo := Expr_Value (Type_Low_Bound (Typ));\n+      Hi := Expr_Value (Type_High_Bound (Typ));\n+   end Get_First_Index_Bounds;\n+\n    ------------------------\n    -- Get_Size_For_Range --\n    ------------------------"}]}