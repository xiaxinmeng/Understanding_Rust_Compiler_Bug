{"sha": "d7429b6aeb5a4167e3bcaf8153387ba9509da0b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc0MjliNmFlYjVhNDE2N2UzYmNhZjgxNTMzODdiYTk1MDlkYTBiMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-15T21:33:30Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-15T21:33:30Z"}, "message": "Initial revision\n\nFrom-SVN: r190", "tree": {"sha": "9cd4ee00a6ac94d42551ddd9350af1e0e386b6a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cd4ee00a6ac94d42551ddd9350af1e0e386b6a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7429b6aeb5a4167e3bcaf8153387ba9509da0b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7429b6aeb5a4167e3bcaf8153387ba9509da0b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7429b6aeb5a4167e3bcaf8153387ba9509da0b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7429b6aeb5a4167e3bcaf8153387ba9509da0b0/comments", "author": null, "committer": null, "parents": [{"sha": "de6a431bee95a409f848f3f2276bf026c4e7272a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de6a431bee95a409f848f3f2276bf026c4e7272a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de6a431bee95a409f848f3f2276bf026c4e7272a"}], "stats": {"total": 2557, "additions": 2557, "deletions": 0}, "files": [{"sha": "901ed6f8b9b3c0bf5fbd7934280c6913d42e0824", "filename": "gcc/flow.c", "status": "added", "additions": 2557, "deletions": 0, "changes": 2557, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7429b6aeb5a4167e3bcaf8153387ba9509da0b0/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7429b6aeb5a4167e3bcaf8153387ba9509da0b0/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=d7429b6aeb5a4167e3bcaf8153387ba9509da0b0", "patch": "@@ -0,0 +1,2557 @@\n+/* Data flow analysis for GNU compiler.\n+   Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* This file contains the data flow analysis pass of the compiler.\n+   It computes data flow information\n+   which tells combine_instructions which insns to consider combining\n+   and controls register allocation.\n+\n+   Additional data flow information that is too bulky to record\n+   is generated during the analysis, and is used at that time to\n+   create autoincrement and autodecrement addressing.\n+\n+   The first step is dividing the function into basic blocks.\n+   find_basic_blocks does this.  Then life_analysis determines\n+   where each register is live and where it is dead.\n+\n+   ** find_basic_blocks **\n+\n+   find_basic_blocks divides the current function's rtl\n+   into basic blocks.  It records the beginnings and ends of the\n+   basic blocks in the vectors basic_block_head and basic_block_end,\n+   and the number of blocks in n_basic_blocks.\n+\n+   find_basic_blocks also finds any unreachable loops\n+   and deletes them.\n+\n+   ** life_analysis **\n+\n+   life_analysis is called immediately after find_basic_blocks.\n+   It uses the basic block information to determine where each\n+   hard or pseudo register is live.\n+\n+   ** live-register info **\n+\n+   The information about where each register is live is in two parts:\n+   the REG_NOTES of insns, and the vector basic_block_live_at_start.\n+\n+   basic_block_live_at_start has an element for each basic block,\n+   and the element is a bit-vector with a bit for each hard or pseudo\n+   register.  The bit is 1 if the register is live at the beginning\n+   of the basic block.\n+\n+   Two types of elements can be added to an insn's REG_NOTES.  \n+   A REG_DEAD note is added to an insn's REG_NOTES for any register\n+   that meets both of two conditions:  The value in the register is not\n+   needed in subsequent insns and the insn does not replace the value in\n+   the register (in the case of multi-word hard registers, the value in\n+   each register must be replaced by the insn to avoid a REG_DEAD note).\n+\n+   In the vast majority of cases, an object in a REG_DEAD note will be\n+   used somewhere in the insn.  The (rare) exception to this is if an\n+   insn uses a multi-word hard register and only some of the registers are\n+   needed in subsequent insns.  In that case, REG_DEAD notes will be\n+   provided for those hard registers that are not subsequently needed.\n+   Partial REG_DEAD notes of this type do not occur when an insn sets\n+   only some of the hard registers used in such a multi-word operand;\n+   omitting REG_DEAD notes for objects stored in an insn is optional and\n+   the desire to do so does not justify the complexity of the partial\n+   REG_DEAD notes.\n+\n+   REG_UNUSED notes are added for each register that is set by the insn\n+   but is unused subsequently (if every register set by the insn is unused\n+   and the insn does not reference memory or have some other side-effect,\n+   the insn is deleted instead).  If only part of a multi-word hard\n+   register is used in a subsequent insn, REG_UNUSED notes are made for\n+   the parts that will not be used.\n+\n+   To determine which registers are live after any insn, one can\n+   start from the beginning of the basic block and scan insns, noting\n+   which registers are set by each insn and which die there.\n+\n+   ** Other actions of life_analysis **\n+\n+   life_analysis sets up the LOG_LINKS fields of insns because the\n+   information needed to do so is readily available.\n+\n+   life_analysis deletes insns whose only effect is to store a value\n+   that is never used.\n+\n+   life_analysis notices cases where a reference to a register as\n+   a memory address can be combined with a preceding or following\n+   incrementation or decrementation of the register.  The separate\n+   instruction to increment or decrement is deleted and the address\n+   is changed to a POST_INC or similar rtx.\n+\n+   Each time an incrementing or decrementing address is created,\n+   a REG_INC element is added to the insn's REG_NOTES list.\n+\n+   life_analysis fills in certain vectors containing information about\n+   register usage: reg_n_refs, reg_n_deaths, reg_n_sets, reg_live_length,\n+   reg_n_calls_crosses and reg_basic_block.  */\n+\f\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"basic-block.h\"\n+#include \"insn-config.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+#include \"output.h\"\n+\n+#include \"obstack.h\"\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+extern int xmalloc ();\n+extern void free ();\n+\n+/* List of labels that must never be deleted.  */\n+extern rtx forced_labels;\n+\n+/* Get the basic block number of an insn.\n+   This info should not be expected to remain available\n+   after the end of life_analysis.  */\n+\n+/* This is the limit of the allocated space in the following two arrays.  */\n+\n+static int max_uid_for_flow;\n+\n+#define BLOCK_NUM(INSN)  uid_block_number[INSN_UID (INSN)]\n+\n+/* This is where the BLOCK_NUM values are really stored.\n+   This is set up by find_basic_blocks and used there and in life_analysis,\n+   and then freed.  */\n+\n+static short *uid_block_number;\n+\n+/* INSN_VOLATILE (insn) is 1 if the insn refers to anything volatile.  */\n+\n+#define INSN_VOLATILE(INSN) uid_volatile[INSN_UID (INSN)]\n+static char *uid_volatile;\n+\n+/* Number of basic blocks in the current function.  */\n+\n+int n_basic_blocks;\n+\n+/* Maximum register number used in this function, plus one.  */\n+\n+int max_regno;\n+\n+/* Maximum number of SCRATCH rtx's used in any basic block of this function. */\n+\n+int max_scratch;\n+\n+/* Number of SCRATCH rtx's in the current block.  */\n+\n+static int num_scratch;\n+\n+/* Indexed by n, gives number of basic block that  (REG n) is used in.\n+   If the value is REG_BLOCK_GLOBAL (-2),\n+   it means (REG n) is used in more than one basic block.\n+   REG_BLOCK_UNKNOWN (-1) means it hasn't been seen yet so we don't know.\n+   This information remains valid for the rest of the compilation\n+   of the current function; it is used to control register allocation.  */\n+\n+short *reg_basic_block;\n+\n+/* Indexed by n, gives number of times (REG n) is used or set, each\n+   weighted by its loop-depth.\n+   This information remains valid for the rest of the compilation\n+   of the current function; it is used to control register allocation.  */\n+\n+int *reg_n_refs;\n+\n+/* Indexed by N, gives number of places register N dies.\n+   This information remains valid for the rest of the compilation\n+   of the current function; it is used to control register allocation.  */\n+\n+short *reg_n_deaths;\n+\n+/* Indexed by N, gives 1 if that reg is live across any CALL_INSNs.\n+   This information remains valid for the rest of the compilation\n+   of the current function; it is used to control register allocation.  */\n+\n+int *reg_n_calls_crossed;\n+\n+/* Total number of instructions at which (REG n) is live.\n+   The larger this is, the less priority (REG n) gets for\n+   allocation in a real register.\n+   This information remains valid for the rest of the compilation\n+   of the current function; it is used to control register allocation.\n+\n+   local-alloc.c may alter this number to change the priority.\n+\n+   Negative values are special.\n+   -1 is used to mark a pseudo reg which has a constant or memory equivalent\n+   and is used infrequently enough that it should not get a hard register.\n+   -2 is used to mark a pseudo reg for a parameter, when a frame pointer\n+   is not required.  global-alloc.c makes an allocno for this but does\n+   not try to assign a hard register to it.  */\n+\n+int *reg_live_length;\n+\n+/* Element N is the next insn that uses (hard or pseudo) register number N\n+   within the current basic block; or zero, if there is no such insn.\n+   This is valid only during the final backward scan in propagate_block.  */\n+\n+static rtx *reg_next_use;\n+\n+/* Size of a regset for the current function,\n+   in (1) bytes and (2) elements.  */\n+\n+int regset_bytes;\n+int regset_size;\n+\n+/* Element N is first insn in basic block N.\n+   This info lasts until we finish compiling the function.  */\n+\n+rtx *basic_block_head;\n+\n+/* Element N is last insn in basic block N.\n+   This info lasts until we finish compiling the function.  */\n+\n+rtx *basic_block_end;\n+\n+/* Element N is a regset describing the registers live\n+   at the start of basic block N.\n+   This info lasts until we finish compiling the function.  */\n+\n+regset *basic_block_live_at_start;\n+\n+/* Regset of regs live when calls to `setjmp'-like functions happen.  */\n+\n+regset regs_live_at_setjmp;\n+\n+/* List made of EXPR_LIST rtx's which gives pairs of pseudo registers\n+   that have to go in the same hard reg.\n+   The first two regs in the list are a pair, and the next two\n+   are another pair, etc.  */\n+rtx regs_may_share;\n+\n+/* Element N is nonzero if control can drop into basic block N\n+   from the preceding basic block.  Freed after life_analysis.  */\n+\n+static char *basic_block_drops_in;\n+\n+/* Element N is depth within loops of the last insn in basic block number N.\n+   Freed after life_analysis.  */\n+\n+static short *basic_block_loop_depth;\n+\n+/* Element N nonzero if basic block N can actually be reached.\n+   Vector exists only during find_basic_blocks.  */\n+\n+static char *block_live_static;\n+\n+/* Depth within loops of basic block being scanned for lifetime analysis,\n+   plus one.  This is the weight attached to references to registers.  */\n+\n+static int loop_depth;\n+\n+/* During propagate_block, this is non-zero if the value of CC0 is live.  */\n+\n+static int cc0_live;\n+\n+/* During propagate_block, this contains the last MEM stored into.  It\n+   is used to eliminate consecutive stores to the same location.  */\n+\n+static rtx last_mem_set;\n+\n+/* Set of registers that may be eliminable.  These are handled specially\n+   in updating regs_ever_live.  */\n+\n+static HARD_REG_SET elim_reg_set;\n+\n+/* Forward declarations */\n+static void find_basic_blocks ();\n+static void life_analysis ();\n+static void mark_label_ref ();\n+void allocate_for_life_analysis (); /* Used also in stupid_life_analysis */\n+static void init_regset_vector ();\n+static void propagate_block ();\n+static void mark_set_regs ();\n+static void mark_used_regs ();\n+static int insn_dead_p ();\n+static int libcall_dead_p ();\n+static int try_pre_increment ();\n+static int try_pre_increment_1 ();\n+static rtx find_use_as_address ();\n+void dump_flow_info ();\n+\f\n+/* Find basic blocks of the current function and perform data flow analysis.\n+   F is the first insn of the function and NREGS the number of register numbers\n+   in use.  */\n+\n+void\n+flow_analysis (f, nregs, file)\n+     rtx f;\n+     int nregs;\n+     FILE *file;\n+{\n+  register rtx insn;\n+  register int i;\n+\n+#ifdef ELIMINABLE_REGS\n+  static struct {int from, to; } eliminables[] = ELIMINABLE_REGS;\n+#endif\n+\n+  /* Record which registers will be eliminated.  We use this in\n+     mark_used_regs. */\n+\n+  CLEAR_HARD_REG_SET (elim_reg_set);\n+\n+#ifdef ELIMINABLE_REGS\n+  for (i = 0; i < sizeof eliminables / sizeof eliminables[0]; i++)\n+    SET_HARD_REG_BIT (elim_reg_set, eliminables[i].from);\n+#else\n+  SET_HARD_REG_BIT (elim_reg_set, FRAME_POINTER_REGNUM);\n+#endif\n+\n+  /* Count the basic blocks.  Also find maximum insn uid value used.  */\n+\n+  {\n+    register RTX_CODE prev_code = JUMP_INSN;\n+    register RTX_CODE code;\n+\n+    max_uid_for_flow = 0;\n+\n+    for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n+      {\n+\tcode = GET_CODE (insn);\n+\tif (INSN_UID (insn) > max_uid_for_flow)\n+\t  max_uid_for_flow = INSN_UID (insn);\n+\tif (code == CODE_LABEL\n+\t    || (prev_code != INSN && prev_code != CALL_INSN\n+\t\t&& prev_code != CODE_LABEL\n+\t\t&& GET_RTX_CLASS (code) == 'i'))\n+\t  i++;\n+\tif (code != NOTE)\n+\t  prev_code = code;\n+      }\n+  }\n+\n+#ifdef AUTO_INC_DEC\n+  /* Leave space for insns we make in some cases for auto-inc.  These cases\n+     are rare, so we don't need too much space.  */\n+  max_uid_for_flow += max_uid_for_flow / 10;\n+#endif\n+\n+  /* Allocate some tables that last till end of compiling this function\n+     and some needed only in find_basic_blocks and life_analysis.  */\n+\n+  n_basic_blocks = i;\n+  basic_block_head = (rtx *) oballoc (n_basic_blocks * sizeof (rtx));\n+  basic_block_end = (rtx *) oballoc (n_basic_blocks * sizeof (rtx));\n+  basic_block_drops_in = (char *) alloca (n_basic_blocks);\n+  basic_block_loop_depth = (short *) alloca (n_basic_blocks * sizeof (short));\n+  uid_block_number\n+    = (short *) alloca ((max_uid_for_flow + 1) * sizeof (short));\n+  uid_volatile = (char *) alloca (max_uid_for_flow + 1);\n+  bzero (uid_volatile, max_uid_for_flow + 1);\n+\n+  find_basic_blocks (f);\n+  life_analysis (f, nregs);\n+  if (file)\n+    dump_flow_info (file);\n+\n+  basic_block_drops_in = 0;\n+  uid_block_number = 0;\n+  basic_block_loop_depth = 0;\n+}\n+\f\n+/* Find all basic blocks of the function whose first insn is F.\n+   Store the correct data in the tables that describe the basic blocks,\n+   set up the chains of references for each CODE_LABEL, and\n+   delete any entire basic blocks that cannot be reached.  */\n+\n+static void\n+find_basic_blocks (f)\n+     rtx f;\n+{\n+  register rtx insn;\n+  register int i;\n+  register char *block_live = (char *) alloca (n_basic_blocks);\n+  register char *block_marked = (char *) alloca (n_basic_blocks);\n+  /* List of label_refs to all labels whose addresses are taken\n+     and used as data.  */\n+  rtx label_value_list = 0;\n+\n+  block_live_static = block_live;\n+  bzero (block_live, n_basic_blocks);\n+  bzero (block_marked, n_basic_blocks);\n+\n+  /* Initialize with just block 0 reachable and no blocks marked.  */\n+  if (n_basic_blocks > 0)\n+    block_live[0] = 1;\n+\n+  /* Initialize the ref chain of each label to 0.  */\n+  /* Record where all the blocks start and end and their depth in loops.  */\n+  /* For each insn, record the block it is in.  */\n+  /* Also mark as reachable any blocks headed by labels that\n+     must not be deleted.  */\n+\n+  {\n+    register RTX_CODE prev_code = JUMP_INSN;\n+    register RTX_CODE code;\n+    int depth = 1;\n+\n+    for (insn = f, i = -1; insn; insn = NEXT_INSN (insn))\n+      {\n+\tcode = GET_CODE (insn);\n+\tif (code == NOTE)\n+\t  {\n+\t    if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\t      depth++;\n+\t    else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\t      depth--;\n+\t  }\n+\telse if (code == CODE_LABEL\n+\t\t || (prev_code != INSN && prev_code != CALL_INSN\n+\t\t     && prev_code != CODE_LABEL\n+\t\t     && GET_RTX_CLASS (code) == 'i'))\n+\t  {\n+\t    basic_block_head[++i] = insn;\n+\t    basic_block_end[i] = insn;\n+\t    basic_block_loop_depth[i] = depth;\n+\t    if (code == CODE_LABEL)\n+\t      {\n+\t\tLABEL_REFS (insn) = insn;\n+\t\t/* Any label that cannot be deleted\n+\t\t   is considered to start a reachable block.  */\n+\t\tif (LABEL_PRESERVE_P (insn))\n+\t\t  block_live[i] = 1;\n+\t      }\n+\t  }\n+\telse if (GET_RTX_CLASS (code) == 'i')\n+\t  {\n+\t    basic_block_end[i] = insn;\n+\t    basic_block_loop_depth[i] = depth;\n+\t  }\n+\n+\t/* Make a list of all labels referred to other than by jumps.  */\n+\tif (code == INSN || code == CALL_INSN)\n+\t  {\n+\t    rtx note = find_reg_note (insn, REG_LABEL, 0);\n+\t    if (note != 0)\n+\t      label_value_list = gen_rtx (EXPR_LIST, VOIDmode, XEXP (note, 0),\n+\t\t\t\t\t  label_value_list);\n+\t  }\n+\n+\tBLOCK_NUM (insn) = i;\n+\tif (code != NOTE)\n+\t  prev_code = code;\n+      }\n+    if (i + 1 != n_basic_blocks)\n+      abort ();\n+  }\n+\n+  /* Record which basic blocks control can drop in to.  */\n+\n+  {\n+    register int i;\n+    for (i = 0; i < n_basic_blocks; i++)\n+      {\n+\tregister rtx insn = PREV_INSN (basic_block_head[i]);\n+\t/* TEMP1 is used to avoid a bug in Sequent's compiler.  */\n+\tregister int temp1;\n+\twhile (insn && GET_CODE (insn) == NOTE)\n+\t  insn = PREV_INSN (insn);\n+\ttemp1 = insn && GET_CODE (insn) != BARRIER;\n+\tbasic_block_drops_in[i] = temp1;\n+      }\n+  }\n+\n+  /* Now find which basic blocks can actually be reached\n+     and put all jump insns' LABEL_REFS onto the ref-chains\n+     of their target labels.  */\n+\n+  if (n_basic_blocks > 0)\n+    {\n+      int something_marked = 1;\n+\n+      /* Find all indirect jump insns and mark them as possibly jumping\n+\t to all the labels whose addresses are explicitly used.\n+\t This is because, when there are computed gotos,\n+\t we can't tell which labels they jump to, of all the possibilities.  */\n+\n+      for (insn = f; insn; insn = NEXT_INSN (insn))\n+\tif (GET_CODE (insn) == JUMP_INSN\n+\t    && GET_CODE (PATTERN (insn)) == SET\n+\t    && SET_DEST (PATTERN (insn)) == pc_rtx\n+\t    && GET_CODE (SET_SRC (PATTERN (insn))) == REG)\n+\t  {\n+\t    rtx x;\n+\t    for (x = label_value_list; x; x = XEXP (x, 1))\n+\t      mark_label_ref (gen_rtx (LABEL_REF, VOIDmode, XEXP (x, 0)),\n+\t\t\t      insn, 0);\n+\t    for (x = forced_labels; x; x = XEXP (x, 1))\n+\t      mark_label_ref (gen_rtx (LABEL_REF, VOIDmode, XEXP (x, 0)),\n+\t\t\t      insn, 0);\n+\t  }\n+\n+      /* Pass over all blocks, marking each block that is reachable\n+\t and has not yet been marked.\n+\t Keep doing this until, in one pass, no blocks have been marked.\n+\t Then blocks_live and blocks_marked are identical and correct.\n+\t In addition, all jumps actually reachable have been marked.  */\n+\n+      while (something_marked)\n+\t{\n+\t  something_marked = 0;\n+\t  for (i = 0; i < n_basic_blocks; i++)\n+\t    if (block_live[i] && !block_marked[i])\n+\t      {\n+\t\tblock_marked[i] = 1;\n+\t\tsomething_marked = 1;\n+\t\tif (i + 1 < n_basic_blocks && basic_block_drops_in[i + 1])\n+\t\t  block_live[i + 1] = 1;\n+\t\tinsn = basic_block_end[i];\n+\t\tif (GET_CODE (insn) == JUMP_INSN)\n+\t\t  mark_label_ref (PATTERN (insn), insn, 0);\n+\t      }\n+\t}\n+\n+      /* Now delete the code for any basic blocks that can't be reached.\n+\t They can occur because jump_optimize does not recognize\n+\t unreachable loops as unreachable.  */\n+\n+      for (i = 0; i < n_basic_blocks; i++)\n+\tif (!block_live[i])\n+\t  {\n+\t    insn = basic_block_head[i];\n+\t    while (1)\n+\t      {\n+\t\tif (GET_CODE (insn) == BARRIER)\n+\t\t  abort ();\n+\t\tif (GET_CODE (insn) != NOTE)\n+\t\t  {\n+\t\t    PUT_CODE (insn, NOTE);\n+\t\t    NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\t    NOTE_SOURCE_FILE (insn) = 0;\n+\t\t  }\n+\t\tif (insn == basic_block_end[i])\n+\t\t  {\n+\t\t    /* BARRIERs are between basic blocks, not part of one.\n+\t\t       Delete a BARRIER if the preceding jump is deleted.\n+\t\t       We cannot alter a BARRIER into a NOTE\n+\t\t       because it is too short; but we can really delete\n+\t\t       it because it is not part of a basic block.  */\n+\t\t    if (NEXT_INSN (insn) != 0\n+\t\t\t&& GET_CODE (NEXT_INSN (insn)) == BARRIER)\n+\t\t      delete_insn (NEXT_INSN (insn));\n+\t\t    break;\n+\t\t  }\n+\t\tinsn = NEXT_INSN (insn);\n+\t      }\n+\t    /* Each time we delete some basic blocks,\n+\t       see if there is a jump around them that is\n+\t       being turned into a no-op.  If so, delete it.  */\n+\n+\t    if (block_live[i - 1])\n+\t      {\n+\t\tregister int j;\n+\t\tfor (j = i; j < n_basic_blocks; j++)\n+\t\t  if (block_live[j])\n+\t\t    {\n+\t\t      rtx label;\n+\t\t      insn = basic_block_end[i - 1];\n+\t\t      if (GET_CODE (insn) == JUMP_INSN\n+\t\t\t  /* An unconditional jump is the only possibility\n+\t\t\t     we must check for, since a conditional one\n+\t\t\t     would make these blocks live.  */\n+\t\t\t  && simplejump_p (insn)\n+\t\t\t  && (label = XEXP (SET_SRC (PATTERN (insn)), 0), 1)\n+\t\t\t  && INSN_UID (label) != 0\n+\t\t\t  && BLOCK_NUM (label) == j)\n+\t\t\t{\n+\t\t\t  PUT_CODE (insn, NOTE);\n+\t\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\t\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t\t\t  if (GET_CODE (NEXT_INSN (insn)) != BARRIER)\n+\t\t\t    abort ();\n+\t\t\t  delete_insn (NEXT_INSN (insn));\n+\t\t\t}\n+\t\t      break;\n+\t\t    }\n+\t      }\n+\t  }\n+    }\n+}\n+\f\n+/* Check expression X for label references;\n+   if one is found, add INSN to the label's chain of references.\n+\n+   CHECKDUP means check for and avoid creating duplicate references\n+   from the same insn.  Such duplicates do no serious harm but\n+   can slow life analysis.  CHECKDUP is set only when duplicates\n+   are likely.  */\n+\n+static void\n+mark_label_ref (x, insn, checkdup)\n+     rtx x, insn;\n+     int checkdup;\n+{\n+  register RTX_CODE code;\n+  register int i;\n+  register char *fmt;\n+\n+  /* We can be called with NULL when scanning label_value_list.  */\n+  if (x == 0)\n+    return;\n+\n+  code = GET_CODE (x);\n+  if (code == LABEL_REF)\n+    {\n+      register rtx label = XEXP (x, 0);\n+      register rtx y;\n+      if (GET_CODE (label) != CODE_LABEL)\n+\tabort ();\n+      /* If the label was never emitted, this insn is junk,\n+\t but avoid a crash trying to refer to BLOCK_NUM (label).\n+\t This can happen as a result of a syntax error\n+\t and a diagnostic has already been printed.  */\n+      if (INSN_UID (label) == 0)\n+\treturn;\n+      CONTAINING_INSN (x) = insn;\n+      /* if CHECKDUP is set, check for duplicate ref from same insn\n+\t and don't insert.  */\n+      if (checkdup)\n+\tfor (y = LABEL_REFS (label); y != label; y = LABEL_NEXTREF (y))\n+\t  if (CONTAINING_INSN (y) == insn)\n+\t    return;\n+      LABEL_NEXTREF (x) = LABEL_REFS (label);\n+      LABEL_REFS (label) = x;\n+      block_live_static[BLOCK_NUM (label)] = 1;\n+      return;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tmark_label_ref (XEXP (x, i), insn, 0);\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    mark_label_ref (XVECEXP (x, i, j), insn, 1);\n+\t}\n+    }\n+}\n+\f\n+/* Determine which registers are live at the start of each\n+   basic block of the function whose first insn is F.\n+   NREGS is the number of registers used in F.\n+   We allocate the vector basic_block_live_at_start\n+   and the regsets that it points to, and fill them with the data.\n+   regset_size and regset_bytes are also set here.  */\n+\n+static void\n+life_analysis (f, nregs)\n+     rtx f;\n+     int nregs;\n+{\n+  register regset tem;\n+  int first_pass;\n+  int changed;\n+  /* For each basic block, a bitmask of regs\n+     live on exit from the block.  */\n+  regset *basic_block_live_at_end;\n+  /* For each basic block, a bitmask of regs\n+     live on entry to a successor-block of this block.\n+     If this does not match basic_block_live_at_end,\n+     that must be updated, and the block must be rescanned.  */\n+  regset *basic_block_new_live_at_end;\n+  /* For each basic block, a bitmask of regs\n+     whose liveness at the end of the basic block\n+     can make a difference in which regs are live on entry to the block.\n+     These are the regs that are set within the basic block,\n+     possibly excluding those that are used after they are set.  */\n+  regset *basic_block_significant;\n+  register int i;\n+  rtx insn;\n+\n+  struct obstack flow_obstack;\n+\n+  gcc_obstack_init (&flow_obstack);\n+\n+  max_regno = nregs;\n+\n+  bzero (regs_ever_live, sizeof regs_ever_live);\n+\n+  /* Allocate and zero out many data structures\n+     that will record the data from lifetime analysis.  */\n+\n+  allocate_for_life_analysis ();\n+\n+  reg_next_use = (rtx *) alloca (nregs * sizeof (rtx));\n+  bzero (reg_next_use, nregs * sizeof (rtx));\n+\n+  /* Set up several regset-vectors used internally within this function.\n+     Their meanings are documented above, with their declarations.  */\n+\n+  basic_block_live_at_end = (regset *) alloca (n_basic_blocks * sizeof (regset));\n+  /* Don't use alloca since that leads to a crash rather than an error message\n+     if there isn't enough space.\n+     Don't use oballoc since we may need to allocate other things during\n+     this function on the temporary obstack.  */\n+  tem = (regset) obstack_alloc (&flow_obstack, n_basic_blocks * regset_bytes);\n+  bzero (tem, n_basic_blocks * regset_bytes);\n+  init_regset_vector (basic_block_live_at_end, tem, n_basic_blocks, regset_bytes);\n+\n+  basic_block_new_live_at_end = (regset *) alloca (n_basic_blocks * sizeof (regset));\n+  tem = (regset) obstack_alloc (&flow_obstack, n_basic_blocks * regset_bytes);\n+  bzero (tem, n_basic_blocks * regset_bytes);\n+  init_regset_vector (basic_block_new_live_at_end, tem, n_basic_blocks, regset_bytes);\n+\n+  basic_block_significant = (regset *) alloca (n_basic_blocks * sizeof (regset));\n+  tem = (regset) obstack_alloc (&flow_obstack, n_basic_blocks * regset_bytes);\n+  bzero (tem, n_basic_blocks * regset_bytes);\n+  init_regset_vector (basic_block_significant, tem, n_basic_blocks, regset_bytes);\n+\n+  /* Record which insns refer to any volatile memory\n+     or for any reason can't be deleted just because they are dead stores.\n+     Also, delete any insns that copy a register to itself. */\n+\n+  for (insn = f; insn; insn = NEXT_INSN (insn))\n+    {\n+      enum rtx_code code1 = GET_CODE (insn);\n+      if (code1 == CALL_INSN)\n+\tINSN_VOLATILE (insn) = 1;\n+      else if (code1 == INSN || code1 == JUMP_INSN)\n+\t{\n+\t  /* Delete (in effect) any obvious no-op moves.  */\n+\t  if (GET_CODE (PATTERN (insn)) == SET\n+\t      && GET_CODE (SET_DEST (PATTERN (insn))) == REG\n+\t      && GET_CODE (SET_SRC (PATTERN (insn))) == REG\n+\t      && REGNO (SET_DEST (PATTERN (insn))) ==\n+\t\t\tREGNO (SET_SRC (PATTERN (insn)))\n+\t      /* Insns carrying these notes are useful later on.  */\n+\t      && ! find_reg_note (insn, REG_EQUAL, 0))\n+\t    {\n+\t      PUT_CODE (insn, NOTE);\n+\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t      NOTE_SOURCE_FILE (insn) = 0;\n+\t    }\n+\t  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+\t    {\n+\t      /* If nothing but SETs of registers to themselves,\n+\t\t this insn can also be deleted.  */\n+\t      for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n+\t\t{\n+\t\t  rtx tem = XVECEXP (PATTERN (insn), 0, i);\n+\n+\t\t  if (GET_CODE (tem) == USE\n+\t\t      || GET_CODE (tem) == CLOBBER)\n+\t\t    continue;\n+\t\t    \n+\t\t  if (GET_CODE (tem) != SET\n+\t\t      || GET_CODE (SET_DEST (tem)) != REG\n+\t\t      || GET_CODE (SET_SRC (tem)) != REG\n+\t\t      || REGNO (SET_DEST (tem)) != REGNO (SET_SRC (tem)))\n+\t\t    break;\n+\t\t}\n+\t\t\n+\t      if (i == XVECLEN (PATTERN (insn), 0)\n+\t\t  /* Insns carrying these notes are useful later on.  */\n+\t\t  && ! find_reg_note (insn, REG_EQUAL, 0))\n+\t\t{\n+\t\t  PUT_CODE (insn, NOTE);\n+\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t\t}\n+\t      else\n+\t\tINSN_VOLATILE (insn) = volatile_refs_p (PATTERN (insn));\n+\t    }\n+\t  else if (GET_CODE (PATTERN (insn)) != USE)\n+\t    INSN_VOLATILE (insn) = volatile_refs_p (PATTERN (insn));\n+\t  /* A SET that makes space on the stack cannot be dead.\n+\t     (Such SETs occur only for allocating variable-size data,\n+\t     so they will always have a PLUS or MINUS according to the\n+\t     direction of stack growth.)\n+\t     Even if this function never uses this stack pointer value,\n+\t     signal handlers do!  */\n+\t  else if (code1 == INSN && GET_CODE (PATTERN (insn)) == SET\n+\t\t   && SET_DEST (PATTERN (insn)) == stack_pointer_rtx\n+#ifdef STACK_GROWS_DOWNWARD\n+\t\t   && GET_CODE (SET_SRC (PATTERN (insn))) == MINUS\n+#else\n+\t\t   && GET_CODE (SET_SRC (PATTERN (insn))) == PLUS\n+#endif\n+\t\t   && XEXP (SET_SRC (PATTERN (insn)), 0) == stack_pointer_rtx)\n+\t    INSN_VOLATILE (insn) = 1;\n+\t}\n+    }\n+\n+  if (n_basic_blocks > 0)\n+#ifdef EXIT_IGNORE_STACK\n+    if (! EXIT_IGNORE_STACK\n+\t|| (! FRAME_POINTER_REQUIRED && flag_omit_frame_pointer))\n+#endif\n+      {\n+\t/* If exiting needs the right stack value,\n+\t   consider the stack pointer live at the end of the function.  */\n+\tbasic_block_live_at_end[n_basic_blocks - 1]\n+\t  [STACK_POINTER_REGNUM / REGSET_ELT_BITS]\n+\t    |= 1 << (STACK_POINTER_REGNUM % REGSET_ELT_BITS);\n+\tbasic_block_new_live_at_end[n_basic_blocks - 1]\n+\t  [STACK_POINTER_REGNUM / REGSET_ELT_BITS]\n+\t    |= 1 << (STACK_POINTER_REGNUM % REGSET_ELT_BITS);\n+      }\n+\n+  /* Mark all global registers as being live at the end of the function\n+     since they may be referenced by our caller.  */\n+\n+  if (n_basic_blocks > 0)\n+    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+      if (global_regs[i])\n+\t{\n+\t  basic_block_live_at_end[n_basic_blocks - 1]\n+\t    [i / REGSET_ELT_BITS] |= 1 << (i % REGSET_ELT_BITS);\n+\t  basic_block_new_live_at_end[n_basic_blocks - 1]\n+\t    [i / REGSET_ELT_BITS] |= 1 << (i % REGSET_ELT_BITS);\n+\t}\n+\n+  /* Propagate life info through the basic blocks\n+     around the graph of basic blocks.\n+\n+     This is a relaxation process: each time a new register\n+     is live at the end of the basic block, we must scan the block\n+     to determine which registers are, as a consequence, live at the beginning\n+     of that block.  These registers must then be marked live at the ends\n+     of all the blocks that can transfer control to that block.\n+     The process continues until it reaches a fixed point.  */\n+\n+  first_pass = 1;\n+  changed = 1;\n+  while (changed)\n+    {\n+      changed = 0;\n+      for (i = n_basic_blocks - 1; i >= 0; i--)\n+\t{\n+\t  int consider = first_pass;\n+\t  int must_rescan = first_pass;\n+\t  register int j;\n+\n+\t  if (!first_pass)\n+\t    {\n+\t      /* Set CONSIDER if this block needs thinking about at all\n+\t\t (that is, if the regs live now at the end of it\n+\t\t are not the same as were live at the end of it when\n+\t\t we last thought about it).\n+\t\t Set must_rescan if it needs to be thought about\n+\t\t instruction by instruction (that is, if any additional\n+\t\t reg that is live at the end now but was not live there before\n+\t\t is one of the significant regs of this basic block).  */\n+\n+\t      for (j = 0; j < regset_size; j++)\n+\t\t{\n+\t\t  register int x = (basic_block_new_live_at_end[i][j]\n+\t\t\t\t    & ~basic_block_live_at_end[i][j]);\n+\t\t  if (x)\n+\t\t    consider = 1;\n+\t\t  if (x & basic_block_significant[i][j])\n+\t\t    {\n+\t\t      must_rescan = 1;\n+\t\t      consider = 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\n+\t      if (! consider)\n+\t\tcontinue;\n+\t    }\n+\n+\t  /* The live_at_start of this block may be changing,\n+\t     so another pass will be required after this one.  */\n+\t  changed = 1;\n+\n+\t  if (! must_rescan)\n+\t    {\n+\t      /* No complete rescan needed;\n+\t\t just record those variables newly known live at end\n+\t\t as live at start as well.  */\n+\t      for (j = 0; j < regset_size; j++)\n+\t\t{\n+\t\t  register int x = basic_block_new_live_at_end[i][j]\n+\t\t\t& ~basic_block_live_at_end[i][j];\n+\t\t  basic_block_live_at_start[i][j] |= x;\n+\t\t  basic_block_live_at_end[i][j] |= x;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Update the basic_block_live_at_start\n+\t\t by propagation backwards through the block.  */\n+\t      bcopy (basic_block_new_live_at_end[i],\n+\t\t     basic_block_live_at_end[i], regset_bytes);\n+\t      bcopy (basic_block_live_at_end[i],\n+\t\t     basic_block_live_at_start[i], regset_bytes);\n+\t      propagate_block (basic_block_live_at_start[i],\n+\t\t\t       basic_block_head[i], basic_block_end[i], 0,\n+\t\t\t       first_pass ? basic_block_significant[i] : 0,\n+\t\t\t       i);\n+\t    }\n+\n+\t  {\n+\t    register rtx jump, head;\n+\t    /* Update the basic_block_new_live_at_end's of the block\n+\t       that falls through into this one (if any).  */\n+\t    head = basic_block_head[i];\n+\t    jump = PREV_INSN (head);\n+\t    if (basic_block_drops_in[i])\n+\t      {\n+\t\tregister int from_block = BLOCK_NUM (jump);\n+\t\tregister int j;\n+\t\tfor (j = 0; j < regset_size; j++)\n+\t\t  basic_block_new_live_at_end[from_block][j]\n+\t\t    |= basic_block_live_at_start[i][j];\n+\t      }\n+\t    /* Update the basic_block_new_live_at_end's of\n+\t       all the blocks that jump to this one.  */\n+\t    if (GET_CODE (head) == CODE_LABEL)\n+\t      for (jump = LABEL_REFS (head);\n+\t\t   jump != head;\n+\t\t   jump = LABEL_NEXTREF (jump))\n+\t\t{\n+\t\t  register int from_block = BLOCK_NUM (CONTAINING_INSN (jump));\n+\t\t  register int j;\n+\t\t  for (j = 0; j < regset_size; j++)\n+\t\t    basic_block_new_live_at_end[from_block][j]\n+\t\t      |= basic_block_live_at_start[i][j];\n+\t\t}\n+\t  }\n+#ifdef USE_C_ALLOCA\n+\t  alloca (0);\n+#endif\n+\t}\n+      first_pass = 0;\n+    }\n+\n+  /* The only pseudos that are live at the beginning of the function are\n+     those that were not set anywhere in the function.  local-alloc doesn't\n+     know how to handle these correctly, so mark them as not local to any\n+     one basic block.  */\n+\n+  if (n_basic_blocks > 0)\n+    for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+      if (basic_block_live_at_start[0][i / REGSET_ELT_BITS]\n+\t  & (1 << (i % REGSET_ELT_BITS)))\n+\treg_basic_block[i] = REG_BLOCK_GLOBAL;\n+\n+  /* Now the life information is accurate.\n+     Make one more pass over each basic block\n+     to delete dead stores, create autoincrement addressing\n+     and record how many times each register is used, is set, or dies.\n+\n+     To save time, we operate directly in basic_block_live_at_end[i],\n+     thus destroying it (in fact, converting it into a copy of\n+     basic_block_live_at_start[i]).  This is ok now because\n+     basic_block_live_at_end[i] is no longer used past this point.  */\n+\n+  max_scratch = 0;\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      propagate_block (basic_block_live_at_end[i],\n+\t\t       basic_block_head[i], basic_block_end[i], 1, 0, i);\n+#ifdef USE_C_ALLOCA\n+      alloca (0);\n+#endif\n+    }\n+\n+#if 0\n+  /* Something live during a setjmp should not be put in a register\n+     on certain machines which restore regs from stack frames\n+     rather than from the jmpbuf.\n+     But we don't need to do this for the user's variables, since\n+     ANSI says only volatile variables need this.  */\n+#ifdef LONGJMP_RESTORE_FROM_STACK\n+  for (i = FIRST_PSEUDO_REGISTER; i < nregs; i++)\n+    if (regs_live_at_setjmp[i / REGSET_ELT_BITS] & (1 << (i % REGSET_ELT_BITS))\n+\t&& regno_reg_rtx[i] != 0 && ! REG_USERVAR_P (regno_reg_rtx[i]))\n+      {\n+\treg_live_length[i] = -1;\n+\treg_basic_block[i] = -1;\n+      }\n+#endif\n+#endif\n+\n+  /* We have a problem with any pseudoreg that\n+     lives across the setjmp.  ANSI says that if a\n+     user variable does not change in value\n+     between the setjmp and the longjmp, then the longjmp preserves it.\n+     This includes longjmp from a place where the pseudo appears dead.\n+     (In principle, the value still exists if it is in scope.)\n+     If the pseudo goes in a hard reg, some other value may occupy\n+     that hard reg where this pseudo is dead, thus clobbering the pseudo.\n+     Conclusion: such a pseudo must not go in a hard reg.  */\n+  for (i = FIRST_PSEUDO_REGISTER; i < nregs; i++)\n+    if (regs_live_at_setjmp[i / REGSET_ELT_BITS] & (1 << (i % REGSET_ELT_BITS))\n+\t&& regno_reg_rtx[i] != 0)\n+      {\n+\treg_live_length[i] = -1;\n+\treg_basic_block[i] = -1;\n+      }\n+\n+  obstack_free (&flow_obstack, 0);\n+}\n+\f\n+/* Subroutines of life analysis.  */\n+\n+/* Allocate the permanent data structures that represent the results\n+   of life analysis.  Not static since used also for stupid life analysis.  */\n+\n+void\n+allocate_for_life_analysis ()\n+{\n+  register int i;\n+  register regset tem;\n+\n+  regset_size = ((max_regno + REGSET_ELT_BITS - 1) / REGSET_ELT_BITS);\n+  regset_bytes = regset_size * sizeof (*(regset)0);\n+\n+  reg_n_refs = (int *) oballoc (max_regno * sizeof (int));\n+  bzero (reg_n_refs, max_regno * sizeof (int));\n+\n+  reg_n_sets = (short *) oballoc (max_regno * sizeof (short));\n+  bzero (reg_n_sets, max_regno * sizeof (short));\n+\n+  reg_n_deaths = (short *) oballoc (max_regno * sizeof (short));\n+  bzero (reg_n_deaths, max_regno * sizeof (short));\n+\n+  reg_live_length = (int *) oballoc (max_regno * sizeof (int));\n+  bzero (reg_live_length, max_regno * sizeof (int));\n+\n+  reg_n_calls_crossed = (int *) oballoc (max_regno * sizeof (int));\n+  bzero (reg_n_calls_crossed, max_regno * sizeof (int));\n+\n+  reg_basic_block = (short *) oballoc (max_regno * sizeof (short));\n+  for (i = 0; i < max_regno; i++)\n+    reg_basic_block[i] = REG_BLOCK_UNKNOWN;\n+\n+  basic_block_live_at_start = (regset *) oballoc (n_basic_blocks * sizeof (regset));\n+  tem = (regset) oballoc (n_basic_blocks * regset_bytes);\n+  bzero (tem, n_basic_blocks * regset_bytes);\n+  init_regset_vector (basic_block_live_at_start, tem, n_basic_blocks, regset_bytes);\n+\n+  regs_live_at_setjmp = (regset) oballoc (regset_bytes);\n+  bzero (regs_live_at_setjmp, regset_bytes);\n+}\n+\n+/* Make each element of VECTOR point at a regset,\n+   taking the space for all those regsets from SPACE.\n+   SPACE is of type regset, but it is really as long as NELTS regsets.\n+   BYTES_PER_ELT is the number of bytes in one regset.  */\n+\n+static void\n+init_regset_vector (vector, space, nelts, bytes_per_elt)\n+     regset *vector;\n+     regset space;\n+     int nelts;\n+     int bytes_per_elt;\n+{\n+  register int i;\n+  register regset p = space;\n+\n+  for (i = 0; i < nelts; i++)\n+    {\n+      vector[i] = p;\n+      p += bytes_per_elt / sizeof (*p);\n+    }\n+}\n+\f\n+/* Compute the registers live at the beginning of a basic block\n+   from those live at the end.\n+\n+   When called, OLD contains those live at the end.\n+   On return, it contains those live at the beginning.\n+   FIRST and LAST are the first and last insns of the basic block.\n+\n+   FINAL is nonzero if we are doing the final pass which is not\n+   for computing the life info (since that has already been done)\n+   but for acting on it.  On this pass, we delete dead stores,\n+   set up the logical links and dead-variables lists of instructions,\n+   and merge instructions for autoincrement and autodecrement addresses.\n+\n+   SIGNIFICANT is nonzero only the first time for each basic block.\n+   If it is nonzero, it points to a regset in which we store\n+   a 1 for each register that is set within the block.\n+\n+   BNUM is the number of the basic block.  */\n+\n+static void\n+propagate_block (old, first, last, final, significant, bnum)\n+     register regset old;\n+     rtx first;\n+     rtx last;\n+     int final;\n+     regset significant;\n+     int bnum;\n+{\n+  register rtx insn;\n+  rtx prev;\n+  regset live;\n+  regset dead;\n+\n+  /* The following variables are used only if FINAL is nonzero.  */\n+  /* This vector gets one element for each reg that has been live\n+     at any point in the basic block that has been scanned so far.\n+     SOMETIMES_MAX says how many elements are in use so far.\n+     In each element, OFFSET is the byte-number within a regset\n+     for the register described by the element, and BIT is a mask\n+     for that register's bit within the byte.  */\n+  register struct foo { short offset; short bit; } *regs_sometimes_live;\n+  int sometimes_max = 0;\n+  /* This regset has 1 for each reg that we have seen live so far.\n+     It and REGS_SOMETIMES_LIVE are updated together.  */\n+  regset maxlive;\n+\n+  /* The loop depth may change in the middle of a basic block.  Since we\n+     scan from end to beginning, we start with the depth at the end of the\n+     current basic block, and adjust as we pass ends and starts of loops.  */\n+  loop_depth = basic_block_loop_depth[bnum];\n+\n+  dead = (regset) alloca (regset_bytes);\n+  live = (regset) alloca (regset_bytes);\n+\n+  cc0_live = 0;\n+  last_mem_set = 0;\n+\n+  /* Include any notes at the end of the block in the scan.\n+     This is in case the block ends with a call to setjmp.  */\n+\n+  while (NEXT_INSN (last) != 0 && GET_CODE (NEXT_INSN (last)) == NOTE)\n+    {\n+      /* Look for loop boundaries, we are going forward here.  */\n+      last = NEXT_INSN (last);\n+      if (NOTE_LINE_NUMBER (last) == NOTE_INSN_LOOP_BEG)\n+\tloop_depth++;\n+      else if (NOTE_LINE_NUMBER (last) == NOTE_INSN_LOOP_END)\n+\tloop_depth--;\n+    }\n+\n+  if (final)\n+    {\n+      register int i, offset, bit;\n+\n+      num_scratch = 0;\n+      maxlive = (regset) alloca (regset_bytes);\n+      bcopy (old, maxlive, regset_bytes);\n+      regs_sometimes_live\n+\t= (struct foo *) alloca (max_regno * sizeof (struct foo));\n+\n+      /* Process the regs live at the end of the block.\n+\t Enter them in MAXLIVE and REGS_SOMETIMES_LIVE.\n+\t Also mark them as not local to any one basic block.  */\n+\n+      for (offset = 0, i = 0; offset < regset_size; offset++)\n+\tfor (bit = 1; bit; bit <<= 1, i++)\n+\t  {\n+\t    if (i == max_regno)\n+\t      break;\n+\t    if (old[offset] & bit)\n+\t      {\n+\t\treg_basic_block[i] = REG_BLOCK_GLOBAL;\n+\t\tregs_sometimes_live[sometimes_max].offset = offset;\n+\t\tregs_sometimes_live[sometimes_max].bit = i % REGSET_ELT_BITS;\n+\t\tsometimes_max++;\n+\t      }\n+\t  }\n+    }\n+\n+  /* Scan the block an insn at a time from end to beginning.  */\n+\n+  for (insn = last; ; insn = prev)\n+    {\n+      prev = PREV_INSN (insn);\n+\n+      /* Look for loop boundaries, remembering that we are going backwards.  */\n+      if (GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\tloop_depth++;\n+      else if (GET_CODE (insn) == NOTE\n+\t       && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\tloop_depth--;\n+\n+      /* If we have LOOP_DEPTH == 0, there has been a bookkeeping error. \n+\t Abort now rather than setting register status incorrectly.  */\n+      if (loop_depth == 0)\n+\tabort ();\n+\n+      /* If this is a call to `setjmp' et al,\n+\t warn if any non-volatile datum is live.  */\n+\n+      if (final && GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n+\t{\n+\t  int i;\n+\t  for (i = 0; i < regset_size; i++)\n+\t    regs_live_at_setjmp[i] |= old[i];\n+\t}\n+\n+      /* Update the life-status of regs for this insn.\n+\t First DEAD gets which regs are set in this insn\n+\t then LIVE gets which regs are used in this insn.\n+\t Then the regs live before the insn\n+\t are those live after, with DEAD regs turned off,\n+\t and then LIVE regs turned on.  */\n+\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t{\n+\t  register int i;\n+\t  rtx note = find_reg_note (insn, REG_RETVAL, 0);\n+\t  int insn_is_dead\n+\t    = (insn_dead_p (PATTERN (insn), old, 0)\n+\t       /* Don't delete something that refers to volatile storage!  */\n+\t       && ! INSN_VOLATILE (insn));\n+\t  int libcall_is_dead \n+\t    = (insn_is_dead && note != 0\n+\t       && libcall_dead_p (PATTERN (insn), old, note, insn));\n+\n+\t  /* If an instruction consists of just dead store(s) on final pass,\n+\t     \"delete\" it by turning it into a NOTE of type NOTE_INSN_DELETED.\n+\t     We could really delete it with delete_insn, but that\n+\t     can cause trouble for first or last insn in a basic block.  */\n+\t  if (final && insn_is_dead)\n+\t    {\n+\t      PUT_CODE (insn, NOTE);\n+\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t      NOTE_SOURCE_FILE (insn) = 0;\n+\n+\t      /* If this insn is copying the return value from a library call,\n+\t\t delete the entire library call.  */\n+\t      if (libcall_is_dead)\n+\t\t{\n+\t\t  rtx first = XEXP (note, 0);\n+\t\t  rtx p = insn;\n+\t\t  while (INSN_DELETED_P (first))\n+\t\t    first = NEXT_INSN (first);\n+\t\t  while (p != first)\n+\t\t    {\n+\t\t      p = PREV_INSN (p);\n+\t\t      PUT_CODE (p, NOTE);\n+\t\t      NOTE_LINE_NUMBER (p) = NOTE_INSN_DELETED;\n+\t\t      NOTE_SOURCE_FILE (p) = 0;\n+\t\t    }\n+\t\t}\n+\t      goto flushed;\n+\t    }\n+\n+\t  for (i = 0; i < regset_size; i++)\n+\t    {\n+\t      dead[i] = 0;\t/* Faster than bzero here */\n+\t      live[i] = 0;\t/* since regset_size is usually small */\n+\t    }\n+\n+\t  /* See if this is an increment or decrement that can be\n+\t     merged into a following memory address.  */\n+#ifdef AUTO_INC_DEC\n+\t  {\n+\t    register rtx x = PATTERN (insn);\n+\t    /* Does this instruction increment or decrement a register?  */\n+\t    if (final && GET_CODE (x) == SET\n+\t\t&& GET_CODE (SET_DEST (x)) == REG\n+\t\t&& (GET_CODE (SET_SRC (x)) == PLUS\n+\t\t    || GET_CODE (SET_SRC (x)) == MINUS)\n+\t\t&& XEXP (SET_SRC (x), 0) == SET_DEST (x)\n+\t\t&& GET_CODE (XEXP (SET_SRC (x), 1)) == CONST_INT\n+\t\t/* Ok, look for a following memory ref we can combine with.\n+\t\t   If one is found, change the memory ref to a PRE_INC\n+\t\t   or PRE_DEC, cancel this insn, and return 1.\n+\t\t   Return 0 if nothing has been done.  */\n+\t\t&& try_pre_increment_1 (insn))\n+\t      goto flushed;\n+\t  }\n+#endif /* AUTO_INC_DEC */\n+\n+\t  /* If this is not the final pass, and this insn is copying the\n+\t     value of a library call and it's dead, don't scan the\n+\t     insns that perform the library call, so that the call's\n+\t     arguments are not marked live.  */\n+\t  if (libcall_is_dead)\n+\t    {\n+\t      /* Mark the dest reg as `significant'.  */\n+\t      mark_set_regs (old, dead, PATTERN (insn), 0, significant);\n+\n+\t      insn = XEXP (note, 0);\n+\t      prev = PREV_INSN (insn);\n+\t    }\n+\t  else if (GET_CODE (PATTERN (insn)) == SET\n+\t\t   && SET_DEST (PATTERN (insn)) == stack_pointer_rtx\n+\t\t   && GET_CODE (SET_SRC (PATTERN (insn))) == PLUS\n+\t\t   && XEXP (SET_SRC (PATTERN (insn)), 0) == stack_pointer_rtx\n+\t\t   && GET_CODE (XEXP (SET_SRC (PATTERN (insn)), 1)) == CONST_INT)\n+\t    /* We have an insn to pop a constant amount off the stack.\n+\t       (Such insns use PLUS regardless of the direction of the stack,\n+\t       and any insn to adjust the stack by a constant is always a pop.)\n+\t       These insns, if not dead stores, have no effect on life.  */\n+\t    ;\n+\t  else\n+\t    {\n+\t      /* LIVE gets the regs used in INSN;\n+\t\t DEAD gets those set by it.  Dead insns don't make anything\n+\t\t live.  */\n+\n+\t      mark_set_regs (old, dead, PATTERN (insn), final ? insn : 0,\n+\t\t\t     significant);\n+\n+\t      /* If an insn doesn't use CC0, it becomes dead since we \n+\t\t assume that every insn clobbers it.  So show it dead here;\n+\t\t mark_used_regs will set it live if it is referenced.  */\n+\t      cc0_live = 0;\n+\n+\t      if (! insn_is_dead)\n+\t\tmark_used_regs (old, live, PATTERN (insn), final, insn);\n+\n+\t      /* Sometimes we may have inserted something before INSN (such as\n+\t\t a move) when we make an auto-inc.  So ensure we will scan\n+\t\t those insns.  */\n+#ifdef AUTO_INC_DEC\n+\t      prev = PREV_INSN (insn);\n+#endif\n+\n+\t      if (! insn_is_dead && GET_CODE (insn) == CALL_INSN)\n+\t\t{\n+\t\t  register int i;\n+\n+\t\t  /* Each call clobbers all call-clobbered regs that are not\n+\t\t     global.  Note that the function-value reg is a\n+\t\t     call-clobbered reg, and mark_set_regs has already had\n+\t\t     a chance to handle it.  */\n+\n+\t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\t    if (call_used_regs[i] && ! global_regs[i])\n+\t\t      dead[i / REGSET_ELT_BITS]\n+\t\t\t|= (1 << (i % REGSET_ELT_BITS));\n+\n+\t\t  /* The stack ptr is used (honorarily) by a CALL insn.  */\n+\t\t  live[STACK_POINTER_REGNUM / REGSET_ELT_BITS]\n+\t\t    |= (1 << (STACK_POINTER_REGNUM % REGSET_ELT_BITS));\n+\n+\t\t  /* Calls may also reference any of the global registers,\n+\t\t     so they are made live.  */\n+\n+\t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\t    if (global_regs[i])\n+\t\t      live[i / REGSET_ELT_BITS]\n+\t\t\t|= (1 << (i % REGSET_ELT_BITS));\n+\n+\t\t  /* Calls also clobber memory.  */\n+\t\t  last_mem_set = 0;\n+\t\t}\n+\n+\t      /* Update OLD for the registers used or set.  */\n+\t      for (i = 0; i < regset_size; i++)\n+\t\t{\n+\t\t  old[i] &= ~dead[i];\n+\t\t  old[i] |= live[i];\n+\t\t}\n+\n+\t      if (GET_CODE (insn) == CALL_INSN && final)\n+\t\t{\n+\t\t  /* Any regs live at the time of a call instruction\n+\t\t     must not go in a register clobbered by calls.\n+\t\t     Find all regs now live and record this for them.  */\n+\n+\t\t  register struct foo *p = regs_sometimes_live;\n+\n+\t\t  for (i = 0; i < sometimes_max; i++, p++)\n+\t\t    if (old[p->offset] & (1 << p->bit))\n+\t\t      reg_n_calls_crossed[p->offset * REGSET_ELT_BITS + p->bit]+= 1;\n+\t\t}\n+\t    }\n+\n+\t  /* On final pass, add any additional sometimes-live regs\n+\t     into MAXLIVE and REGS_SOMETIMES_LIVE.\n+\t     Also update counts of how many insns each reg is live at.  */\n+\n+\t  if (final)\n+\t    {\n+\t      for (i = 0; i < regset_size; i++)\n+\t\t{\n+\t\t  register int diff = live[i] & ~maxlive[i];\n+\n+\t\t  if (diff)\n+\t\t    {\n+\t\t      register int regno;\n+\t\t      maxlive[i] |= diff;\n+\t\t      for (regno = 0; diff && regno < REGSET_ELT_BITS; regno++)\n+\t\t\tif (diff & (1 << regno))\n+\t\t\t  {\n+\t\t\t    regs_sometimes_live[sometimes_max].offset = i;\n+\t\t\t    regs_sometimes_live[sometimes_max].bit = regno;\n+\t\t\t    diff &= ~ (1 << regno);\n+\t\t\t    sometimes_max++;\n+\t\t\t  }\n+\t\t    }\n+\t\t}\n+\n+\t      {\n+\t\tregister struct foo *p = regs_sometimes_live;\n+\t\tfor (i = 0; i < sometimes_max; i++, p++)\n+\t\t  {\n+\t\t    if (old[p->offset] & (1 << p->bit))\n+\t\t      reg_live_length[p->offset * REGSET_ELT_BITS + p->bit]++;\n+\t\t  }\n+\t      }\n+\t    }\n+\t}\n+    flushed: ;\n+      if (insn == first)\n+\tbreak;\n+    }\n+\n+  if (num_scratch > max_scratch)\n+    max_scratch = num_scratch;\n+}\n+\f\n+/* Return 1 if X (the body of an insn, or part of it) is just dead stores\n+   (SET expressions whose destinations are registers dead after the insn).\n+   NEEDED is the regset that says which regs are alive after the insn.\n+\n+   Unless CALL_OK is non-zero, an insn is needed if it contains a CALL.  */\n+\n+static int\n+insn_dead_p (x, needed, call_ok)\n+     rtx x;\n+     regset needed;\n+     int call_ok;\n+{\n+  register RTX_CODE code = GET_CODE (x);\n+  /* If setting something that's a reg or part of one,\n+     see if that register's altered value will be live.  */\n+\n+  if (code == SET)\n+    {\n+      register rtx r = SET_DEST (x);\n+      /* A SET that is a subroutine call cannot be dead.  */\n+      if (! call_ok && GET_CODE (SET_SRC (x)) == CALL)\n+\treturn 0;\n+\n+#ifdef HAVE_cc0\n+      if (GET_CODE (r) == CC0)\n+\treturn ! cc0_live;\n+#endif\n+      \n+      if (GET_CODE (r) == MEM && last_mem_set && ! MEM_VOLATILE_P (r)\n+\t  && rtx_equal_p (r, last_mem_set))\n+\treturn 1;\n+\n+      while (GET_CODE (r) == SUBREG\n+\t     || GET_CODE (r) == STRICT_LOW_PART\n+\t     || GET_CODE (r) == ZERO_EXTRACT\n+\t     || GET_CODE (r) == SIGN_EXTRACT)\n+\tr = SUBREG_REG (r);\n+\n+      if (GET_CODE (r) == REG)\n+\t{\n+\t  register int regno = REGNO (r);\n+\t  register int offset = regno / REGSET_ELT_BITS;\n+\t  register int bit = 1 << (regno % REGSET_ELT_BITS);\n+\n+\t  if ((regno < FIRST_PSEUDO_REGISTER && global_regs[regno])\n+\t      /* Make sure insns to set frame pointer aren't deleted.  */\n+\t      || regno == FRAME_POINTER_REGNUM\n+\t      /* Make sure insns to set arg pointer are never deleted.  */\n+\t      || regno == ARG_POINTER_REGNUM\n+\t      || (needed[offset] & bit) != 0)\n+\t    return 0;\n+\n+\t  /* If this is a hard register, verify that subsequent words are\n+\t     not needed.  */\n+\t  if (regno < FIRST_PSEUDO_REGISTER)\n+\t    {\n+\t      int n = HARD_REGNO_NREGS (regno, GET_MODE (r));\n+\n+\t      while (--n > 0)\n+\t\tif ((needed[(regno + n) / REGSET_ELT_BITS]\n+\t\t     & 1 << ((regno + n) % REGSET_ELT_BITS)) != 0)\n+\t\t  return 0;\n+\t    }\n+\n+\t  return 1;\n+\t}\n+    }\n+  /* If performing several activities,\n+     insn is dead if each activity is individually dead.\n+     Also, CLOBBERs and USEs can be ignored; a CLOBBER or USE\n+     that's inside a PARALLEL doesn't make the insn worth keeping.  */\n+  else if (code == PARALLEL)\n+    {\n+      register int i = XVECLEN (x, 0);\n+      for (i--; i >= 0; i--)\n+\t{\n+\t  rtx elt = XVECEXP (x, 0, i);\n+\t  if (!insn_dead_p (elt, needed, call_ok)\n+\t      && GET_CODE (elt) != CLOBBER\n+\t      && GET_CODE (elt) != USE)\n+\t    return 0;\n+\t}\n+      return 1;\n+    }\n+  /* We do not check CLOBBER or USE here.\n+     An insn consisting of just a CLOBBER or just a USE\n+     should not be deleted.  */\n+  return 0;\n+}\n+\n+/* If X is the pattern of the last insn in a libcall, and assuming X is dead,\n+   return 1 if the entire library call is dead.\n+   This is true if X copies a register (hard or pseudo)\n+   and if the hard return  reg of the call insn is dead.\n+   (The caller should have tested the destination of X already for death.)\n+\n+   If this insn doesn't just copy a register, then we don't\n+   have an ordinary libcall.  In that case, cse could not have\n+   managed to substitute the source for the dest later on,\n+   so we can assume the libcall is dead.\n+\n+   NEEDED is the bit vector of pseudoregs live before this insn.\n+   NOTE is the REG_RETVAL note of the insn.  INSN is the insn itself.  */\n+\n+static int\n+libcall_dead_p (x, needed, note, insn)\n+     rtx x;\n+     regset needed;\n+     rtx note;\n+     rtx insn;\n+{\n+  register RTX_CODE code = GET_CODE (x);\n+\n+  if (code == SET)\n+    {\n+      register rtx r = SET_SRC (x);\n+      if (GET_CODE (r) == REG)\n+\t{\n+\t  rtx call = XEXP (note, 0);\n+\t  register int i;\n+\n+\t  /* Find the call insn.  */\n+\t  while (call != insn && GET_CODE (call) != CALL_INSN)\n+\t    call = NEXT_INSN (call);\n+\n+\t  /* If there is none, do nothing special,\n+\t     since ordinary death handling can understand these insns.  */\n+\t  if (call == insn)\n+\t    return 0;\n+\n+\t  /* See if the hard reg holding the value is dead.\n+\t     If this is a PARALLEL, find the call within it.  */\n+\t  call = PATTERN (call);\n+\t  if (GET_CODE (call) == PARALLEL)\n+\t    {\n+\t      for (i = XVECLEN (call, 0) - 1; i >= 0; i--)\n+\t\tif (GET_CODE (XVECEXP (call, 0, i)) == SET\n+\t\t    && GET_CODE (SET_SRC (XVECEXP (call, 0, i))) == CALL)\n+\t\t  break;\n+\n+\t      if (i < 0)\n+\t\tabort ();\n+\n+\t      call = XVECEXP (call, 0, i);\n+\t    }\n+\n+\t  return insn_dead_p (call, needed, 1);\n+\t}\n+    }\n+  return 1;\n+}\n+\n+/* Return 1 if register REGNO was used before it was set.\n+   In other words, if it is live at function entry.  */\n+\n+int\n+regno_uninitialized (regno)\n+     int regno;\n+{\n+  if (n_basic_blocks == 0)\n+    return 0;\n+\n+  return (basic_block_live_at_start[0][regno / REGSET_ELT_BITS]\n+\t  & (1 << (regno % REGSET_ELT_BITS)));\n+}\n+\n+/* 1 if register REGNO was alive at a place where `setjmp' was called\n+   and was set more than once or is an argument.\n+   Such regs may be clobbered by `longjmp'.  */\n+\n+int\n+regno_clobbered_at_setjmp (regno)\n+     int regno;\n+{\n+  if (n_basic_blocks == 0)\n+    return 0;\n+\n+  return ((reg_n_sets[regno] > 1\n+\t   || (basic_block_live_at_start[0][regno / REGSET_ELT_BITS]\n+\t       & (1 << (regno % REGSET_ELT_BITS))))\n+\t  && (regs_live_at_setjmp[regno / REGSET_ELT_BITS]\n+\t      & (1 << (regno % REGSET_ELT_BITS))));\n+}\n+\f\n+/* Process the registers that are set within X.\n+   Their bits are set to 1 in the regset DEAD,\n+   because they are dead prior to this insn.\n+\n+   If INSN is nonzero, it is the insn being processed\n+   and the fact that it is nonzero implies this is the FINAL pass\n+   in propagate_block.  In this case, various info about register\n+   usage is stored, LOG_LINKS fields of insns are set up.  */\n+\n+static void mark_set_1 ();\n+\n+static void\n+mark_set_regs (needed, dead, x, insn, significant)\n+     regset needed;\n+     regset dead;\n+     rtx x;\n+     rtx insn;\n+     regset significant;\n+{\n+  register RTX_CODE code = GET_CODE (x);\n+\n+  if (code == SET || code == CLOBBER)\n+    mark_set_1 (needed, dead, x, insn, significant);\n+  else if (code == PARALLEL)\n+    {\n+      register int i;\n+      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n+\t{\n+\t  code = GET_CODE (XVECEXP (x, 0, i));\n+\t  if (code == SET || code == CLOBBER)\n+\t    mark_set_1 (needed, dead, XVECEXP (x, 0, i), insn, significant);\n+\t}\n+    }\n+}\n+\n+/* Process a single SET rtx, X.  */\n+\n+static void\n+mark_set_1 (needed, dead, x, insn, significant)\n+     regset needed;\n+     regset dead;\n+     rtx x;\n+     rtx insn;\n+     regset significant;\n+{\n+  register int regno;\n+  register rtx reg = SET_DEST (x);\n+\n+  /* Modifying just one hardware register of a multi-reg value\n+     or just a byte field of a register\n+     does not mean the value from before this insn is now dead.\n+     But it does mean liveness of that register at the end of the block\n+     is significant.\n+\n+     Within mark_set_1, however, we treat it as if the register is\n+     indeed modified.  mark_used_regs will, however, also treat this\n+     register as being used.  Thus, we treat these insns as setting a\n+     new value for the register as a function of its old value.  This\n+     cases LOG_LINKS to be made appropriately and this will help combine.  */\n+\n+  while (GET_CODE (reg) == SUBREG || GET_CODE (reg) == ZERO_EXTRACT\n+\t || GET_CODE (reg) == SIGN_EXTRACT\n+\t || GET_CODE (reg) == STRICT_LOW_PART)\n+    reg = XEXP (reg, 0);\n+\n+  /* If we are writing into memory or into a register mentioned in the\n+     address of the last thing stored into memory, show we don't know\n+     what the last store was.  If we are writing memory, save the address\n+     unless it is volatile.  */\n+  if (GET_CODE (reg) == MEM\n+      || (GET_CODE (reg) == REG\n+\t  && last_mem_set != 0 && reg_overlap_mentioned_p (reg, last_mem_set)))\n+    last_mem_set = 0;\n+    \n+  if (GET_CODE (reg) == MEM && ! side_effects_p (reg)\n+      /* There are no REG_INC notes for SP, so we can't assume we'll see \n+\t everything that invalidates it.  To be safe, don't eliminate any\n+\t stores though SP; none of them should be redundant anyway.  */\n+      && ! reg_mentioned_p (stack_pointer_rtx, reg))\n+    last_mem_set = reg;\n+\n+  if (GET_CODE (reg) == REG\n+      && (regno = REGNO (reg), regno != FRAME_POINTER_REGNUM)\n+      && regno != ARG_POINTER_REGNUM\n+      && ! (regno < FIRST_PSEUDO_REGISTER && global_regs[regno]))\n+    /* && regno != STACK_POINTER_REGNUM) -- let's try without this.  */\n+    {\n+      register int offset = regno / REGSET_ELT_BITS;\n+      register int bit = 1 << (regno % REGSET_ELT_BITS);\n+      int all_needed = (needed[offset] & bit) != 0;\n+      int some_needed = (needed[offset] & bit) != 0;\n+\n+      /* Mark it as a significant register for this basic block.  */\n+      if (significant)\n+\tsignificant[offset] |= bit;\n+\n+      /* Mark it as as dead before this insn.  */\n+      dead[offset] |= bit;\n+\n+      /* A hard reg in a wide mode may really be multiple registers.\n+\t If so, mark all of them just like the first.  */\n+      if (regno < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  int n;\n+\n+\t  /* Nothing below is needed for the stack pointer; get out asap.\n+\t     Eg, log links aren't needed, since combine won't use them.  */\n+\t  if (regno == STACK_POINTER_REGNUM)\n+\t    return;\n+\n+\t  n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+\t  while (--n > 0)\n+\t    {\n+\t      if (significant)\n+\t\tsignificant[(regno + n) / REGSET_ELT_BITS]\n+\t\t  |= 1 << ((regno + n) % REGSET_ELT_BITS);\n+\t      dead[(regno + n) / REGSET_ELT_BITS]\n+\t\t|= 1 << ((regno + n) % REGSET_ELT_BITS);\n+\t      some_needed |= (needed[(regno + n) / REGSET_ELT_BITS]\n+\t\t\t      & 1 << ((regno + n) % REGSET_ELT_BITS));\n+\t      all_needed &= (needed[(regno + n) / REGSET_ELT_BITS]\n+\t\t\t     & 1 << ((regno + n) % REGSET_ELT_BITS));\n+\t    }\n+\t}\n+      /* Additional data to record if this is the final pass.  */\n+      if (insn)\n+\t{\n+\t  register rtx y = reg_next_use[regno];\n+\t  register int blocknum = BLOCK_NUM (insn);\n+\n+\t  /* If this is a hard reg, record this function uses the reg.  */\n+\n+\t  if (regno < FIRST_PSEUDO_REGISTER)\n+\t    {\n+\t      register int i;\n+\t      int endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+\n+\t      for (i = regno; i < endregno; i++)\n+\t\t{\n+\t\t  regs_ever_live[i] = 1;\n+\t\t  reg_n_sets[i]++;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Keep track of which basic blocks each reg appears in.  */\n+\n+\t      if (reg_basic_block[regno] == REG_BLOCK_UNKNOWN)\n+\t\treg_basic_block[regno] = blocknum;\n+\t      else if (reg_basic_block[regno] != blocknum)\n+\t\treg_basic_block[regno] = REG_BLOCK_GLOBAL;\n+\n+\t      /* Count (weighted) references, stores, etc.  This counts a\n+\t\t register twice if it is modified, but that is correct.  */\n+\t      reg_n_sets[regno]++;\n+\n+\t      reg_n_refs[regno] += loop_depth;\n+\t\t  \n+\t      /* The insns where a reg is live are normally counted\n+\t\t elsewhere, but we want the count to include the insn\n+\t\t where the reg is set, and the normal counting mechanism\n+\t\t would not count it.  */\n+\t      reg_live_length[regno]++;\n+\t    }\n+\n+\t  /* The next use is no longer \"next\", since a store intervenes.  */\n+\t  reg_next_use[regno] = 0;\n+\n+\t  if (all_needed)\n+\t    {\n+\t      /* Make a logical link from the next following insn\n+\t\t that uses this register, back to this insn.\n+\t\t The following insns have already been processed.\n+\n+\t\t We don't build a LOG_LINK for hard registers containing\n+\t\t in ASM_OPERANDs.  If these registers get replaced,\n+\t\t we might wind up changing the semantics of the insn,\n+\t\t even if reload can make what appear to be valid assignments\n+\t\t later.  */\n+\t      if (y && (BLOCK_NUM (y) == blocknum)\n+\t\t  && (regno >= FIRST_PSEUDO_REGISTER\n+\t\t      || asm_noperands (PATTERN (y)) < 0))\n+\t\tLOG_LINKS (y)\n+\t\t  = gen_rtx (INSN_LIST, VOIDmode, insn, LOG_LINKS (y));\n+\t    }\n+\t  else if (! some_needed)\n+\t    {\n+\t      /* Note that dead stores have already been deleted when possible\n+\t\t If we get here, we have found a dead store that cannot\n+\t\t be eliminated (because the same insn does something useful).\n+\t\t Indicate this by marking the reg being set as dying here.  */\n+\t      REG_NOTES (insn)\n+\t\t= gen_rtx (EXPR_LIST, REG_UNUSED, reg, REG_NOTES (insn));\n+\t      reg_n_deaths[REGNO (reg)]++;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* This is a case where we have a multi-word hard register\n+\t\t and some, but not all, of the words of the register are\n+\t\t needed in subsequent insns.  Write REG_UNUSED notes\n+\t\t for those parts that were not needed.  This case should\n+\t\t be rare.  */\n+\n+\t      int i;\n+\n+\t      for (i = HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1;\n+\t\t   i >= 0; i--)\n+\t\tif ((needed[(regno + i) / REGSET_ELT_BITS]\n+\t\t     & 1 << ((regno + i) % REGSET_ELT_BITS)) == 0)\n+\t\t  REG_NOTES (insn)\n+\t\t    = gen_rtx (EXPR_LIST, REG_UNUSED,\n+\t\t\t       gen_rtx (REG, word_mode, regno + i),\n+\t\t\t       REG_NOTES (insn));\n+\t    }\n+\t}\n+    }\n+\n+  /* If this is the last pass and this is a SCRATCH, show it will be dying\n+     here and count it.  */\n+  else if (GET_CODE (reg) == SCRATCH && insn != 0)\n+    {\n+      REG_NOTES (insn)\n+\t= gen_rtx (EXPR_LIST, REG_UNUSED, reg, REG_NOTES (insn));\n+      num_scratch++;\n+    }\n+}\n+\f\n+#ifdef AUTO_INC_DEC\n+\n+/* X is a MEM found in INSN.  See if we can convert it into an auto-increment\n+   reference.  */\n+\n+static void\n+find_auto_inc (needed, x, insn)\n+     regset needed;\n+     rtx x;\n+     rtx insn;\n+{\n+  rtx addr = XEXP (x, 0);\n+  int offset = 0;\n+\n+  /* Here we detect use of an index register which might be good for\n+     postincrement, postdecrement, preincrement, or predecrement.  */\n+\n+  if (GET_CODE (addr) == PLUS && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+    offset = INTVAL (XEXP (addr, 1)), addr = XEXP (addr, 0);\n+\n+  if (GET_CODE (addr) == REG)\n+    {\n+      register rtx y;\n+      register int size = GET_MODE_SIZE (GET_MODE (x));\n+      rtx use;\n+      rtx incr;\n+      int regno = REGNO (addr);\n+\n+      /* Is the next use an increment that might make auto-increment? */\n+      incr = reg_next_use[regno];\n+      if (incr && GET_CODE (PATTERN (incr)) == SET\n+\t  && BLOCK_NUM (incr) == BLOCK_NUM (insn)\n+\t  /* Can't add side effects to jumps; if reg is spilled and\n+\t     reloaded, there's no way to store back the altered value.  */\n+\t  && GET_CODE (insn) != JUMP_INSN\n+\t  && (y = SET_SRC (PATTERN (incr)), GET_CODE (y) == PLUS)\n+\t  && XEXP (y, 0) == addr\n+\t  && GET_CODE (XEXP (y, 1)) == CONST_INT\n+\t  && (0\n+#ifdef HAVE_POST_INCREMENT\n+\t      || (INTVAL (XEXP (y, 1)) == size && offset == 0)\n+#endif\n+#ifdef HAVE_POST_DECREMENT\n+\t      || (INTVAL (XEXP (y, 1)) == - size && offset == 0)\n+#endif\n+#ifdef HAVE_PRE_INCREMENT\n+\t      || (INTVAL (XEXP (y, 1)) == size && offset == size)\n+#endif\n+#ifdef HAVE_PRE_DECREMENT\n+\t      || (INTVAL (XEXP (y, 1)) == - size && offset == - size)\n+#endif\n+\t      )\n+\t  /* Make sure this reg appears only once in this insn.  */\n+\t  && (use = find_use_as_address (PATTERN (insn), addr, offset),\n+\t      use != 0 && use != (rtx) 1))\n+\t{\n+\t  int win = 0;\n+\t  rtx q = SET_DEST (PATTERN (incr));\n+\n+\t  if (dead_or_set_p (incr, addr))\n+\t    win = 1;\n+\t  else if (GET_CODE (q) == REG && ! reg_used_between_p (q, insn, incr))\n+\t    {\n+\t      /* We have *p followed by q = p+size.\n+\t\t Both p and q must be live afterward,\n+\t\t and q must be dead before.\n+\t\t Change it to q = p, ...*q..., q = q+size.\n+\t\t Then fall into the usual case.  */\n+\t      rtx insns, temp;\n+\n+\t      start_sequence ();\n+\t      emit_move_insn (q, addr);\n+\t      insns = get_insns ();\n+\t      end_sequence ();\n+\n+\t      /* If anything in INSNS have UID's that don't fit within the\n+\t\t extra space we allocate earlier, we can't make this auto-inc.\n+\t\t This should never happen.  */\n+\t      for (temp = insns; temp; temp = NEXT_INSN (temp))\n+\t\t{\n+\t\t  if (INSN_UID (temp) > max_uid_for_flow)\n+\t\t    return;\n+\t\t  BLOCK_NUM (temp) = BLOCK_NUM (insn);\n+\t\t}\n+\n+\t      emit_insns_before (insns, insn);\n+\t      XEXP (x, 0) = q;\n+\t      XEXP (y, 0) = q;\n+\n+\t      /* INCR will become a NOTE and INSN won't contain a\n+\t\t use of ADDR.  If a use of ADDR was just placed in\n+\t\t the insn before INSN, make that the next use. \n+\t\t Otherwise, invalidate it.  */\n+\t      if (GET_CODE (PREV_INSN (insn)) == INSN\n+\t\t  && GET_CODE (PATTERN (PREV_INSN (insn))) == SET\n+\t\t  && SET_SRC (PATTERN (PREV_INSN (insn))) == addr)\n+\t\treg_next_use[regno] = PREV_INSN (insn);\n+\t      else\n+\t\treg_next_use[regno] = 0;\n+\n+\t      addr = q;\n+\t      regno = REGNO (q);\n+\t      win = 1;\n+\n+\t      /* REGNO is now used in INCR which is below INSN, but\n+\t\t it previously wasn't live here.  If we don't mark\n+\t\t it as needed, we'll put a REG_DEAD note for it\n+\t\t on this insn, which is incorrect.  */\n+\t      needed[regno / REGSET_ELT_BITS]\n+\t\t|= 1 << (regno % REGSET_ELT_BITS);\n+\n+\t      /* If there are any calls between INSN and INCR, show\n+\t\t that REGNO now crosses them.  */\n+\t      for (temp = insn; temp != incr; temp = NEXT_INSN (temp))\n+\t\tif (GET_CODE (temp) == CALL_INSN)\n+\t\t  reg_n_calls_crossed[regno]++;\n+\t    }\n+\n+\t  if (win)\n+\t    {\n+\t      /* We have found a suitable auto-increment: do POST_INC around\n+\t\t the register here, and patch out the increment instruction \n+\t\t that follows. */\n+\t      XEXP (x, 0) = gen_rtx ((INTVAL (XEXP (y, 1)) == size\n+\t\t\t\t      ? (offset ? PRE_INC : POST_INC)\n+\t\t\t\t      : (offset ? PRE_DEC : POST_DEC)),\n+\t\t\t\t     Pmode, addr);\n+\n+\t      /* Record that this insn has an implicit side effect.  */\n+\t      REG_NOTES (insn)\n+\t\t= gen_rtx (EXPR_LIST, REG_INC, addr, REG_NOTES (insn));\n+\n+\t      /* Modify the old increment-insn to simply copy\n+\t\t the already-incremented value of our register.  */\n+\t      SET_SRC (PATTERN (incr)) = addr;\n+\t      /* Indicate insn must be re-recognized.  */\n+\t      INSN_CODE (incr) = -1;\n+\n+\t      /* If that makes it a no-op (copying the register into itself)\n+\t\t then delete it so it won't appear to be a \"use\" and a \"set\"\n+\t\t of this register.  */\n+\t      if (SET_DEST (PATTERN (incr)) == addr)\n+\t\t{\n+\t\t  PUT_CODE (incr, NOTE);\n+\t\t  NOTE_LINE_NUMBER (incr) = NOTE_INSN_DELETED;\n+\t\t  NOTE_SOURCE_FILE (incr) = 0;\n+\t\t}\n+\n+\t      if (regno >= FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  /* Count an extra reference to the reg.  When a reg is\n+\t\t     incremented, spilling it is worse, so we want to make\n+\t\t     that less likely.  */\n+\t\t  reg_n_refs[regno] += loop_depth;\n+\t\t  /* Count the increment as a setting of the register,\n+\t\t     even though it isn't a SET in rtl.  */\n+\t\t  reg_n_sets[regno]++;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+#endif /* AUTO_INC_DEC */\n+\f\n+/* Scan expression X and store a 1-bit in LIVE for each reg it uses.\n+   This is done assuming the registers needed from X\n+   are those that have 1-bits in NEEDED.\n+\n+   On the final pass, FINAL is 1.  This means try for autoincrement\n+   and count the uses and deaths of each pseudo-reg.\n+\n+   INSN is the containing instruction.  If INSN is dead, this function is not\n+   called.  */\n+\n+static void\n+mark_used_regs (needed, live, x, final, insn)\n+     regset needed;\n+     regset live;\n+     rtx x;\n+     rtx insn;\n+     int final;\n+{\n+  register RTX_CODE code;\n+  register int regno;\n+  int i;\n+\n+ retry:\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_INT:\n+    case CONST:\n+    case CONST_DOUBLE:\n+    case PC:\n+    case CLOBBER:\n+    case ADDR_VEC:\n+    case ADDR_DIFF_VEC:\n+    case ASM_INPUT:\n+      return;\n+\n+#ifdef HAVE_cc0\n+    case CC0:\n+      cc0_live = 1;\n+      return;\n+#endif\n+\n+    case MEM:\n+      /* Invalidate the data for the last MEM stored.  We could do this only\n+\t if the addresses conflict, but this doesn't seem worthwhile.  */\n+      last_mem_set = 0;\n+\n+#ifdef AUTO_INC_DEC\n+      if (final)\n+\tfind_auto_inc (needed, x, insn);\n+#endif\n+      break;\n+\n+    case REG:\n+      /* See a register other than being set\n+\t => mark it as needed.  */\n+\n+      regno = REGNO (x);\n+      {\n+\tregister int offset = regno / REGSET_ELT_BITS;\n+\tregister int bit = 1 << (regno % REGSET_ELT_BITS);\n+\tint all_needed = (needed[offset] & bit) != 0;\n+\tint some_needed = (needed[offset] & bit) != 0;\n+\n+\tlive[offset] |= bit;\n+\t/* A hard reg in a wide mode may really be multiple registers.\n+\t   If so, mark all of them just like the first.  */\n+\tif (regno < FIRST_PSEUDO_REGISTER)\n+\t  {\n+\t    int n;\n+\n+\t    /* For stack ptr or arg pointer,\n+\t       nothing below can be necessary, so waste no more time.  */\n+\t    if (regno == STACK_POINTER_REGNUM\n+\t\t|| regno == ARG_POINTER_REGNUM\n+\t\t|| regno == FRAME_POINTER_REGNUM)\n+\t      {\n+\t\t/* If this is a register we are going to try to eliminate,\n+\t\t   don't mark it live here.  If we are successful in\n+\t\t   eliminating it, it need not be live unless it is used for\n+\t\t   pseudos, in which case it will have been set live when\n+\t\t   it was allocated to the pseudos.  If the register will not\n+\t\t   be eliminated, reload will set it live at that point.  */\n+\n+\t\tif (! TEST_HARD_REG_BIT (elim_reg_set, regno))\n+\t\t  regs_ever_live[regno] = 1;\n+\t\treturn;\n+\t      }\n+\t    /* No death notes for global register variables;\n+\t       their values are live after this function exits.  */\n+\t    if (global_regs[regno])\n+\t      return;\n+\n+\t    n = HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\t    while (--n > 0)\n+\t      {\n+\t\tlive[(regno + n) / REGSET_ELT_BITS]\n+\t\t  |= 1 << ((regno + n) % REGSET_ELT_BITS);\n+\t\tsome_needed |= (needed[(regno + n) / REGSET_ELT_BITS]\n+\t\t\t\t& 1 << ((regno + n) % REGSET_ELT_BITS));\n+\t\tall_needed &= (needed[(regno + n) / REGSET_ELT_BITS]\n+\t\t\t       & 1 << ((regno + n) % REGSET_ELT_BITS));\n+\t      }\n+\t  }\n+\tif (final)\n+\t  {\n+\t    /* Record where each reg is used, so when the reg\n+\t       is set we know the next insn that uses it.  */\n+\n+\t    reg_next_use[regno] = insn;\n+\n+\t    if (regno < FIRST_PSEUDO_REGISTER)\n+\t      {\n+\t\t/* If a hard reg is being used,\n+\t\t   record that this function does use it.  */\n+\n+\t\ti = HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\t\tif (i == 0)\n+\t\t  i = 1;\n+\t\tdo\n+\t\t  regs_ever_live[regno + --i] = 1;\n+\t\twhile (i > 0);\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* Keep track of which basic block each reg appears in.  */\n+\n+\t\tregister int blocknum = BLOCK_NUM (insn);\n+\n+\t\tif (reg_basic_block[regno] == REG_BLOCK_UNKNOWN)\n+\t\t  reg_basic_block[regno] = blocknum;\n+\t\telse if (reg_basic_block[regno] != blocknum)\n+\t\t  reg_basic_block[regno] = REG_BLOCK_GLOBAL;\n+\n+\t\t/* Count (weighted) number of uses of each reg.  */\n+\n+\t\treg_n_refs[regno] += loop_depth;\n+\t      }\n+\n+\t    /* Record and count the insns in which a reg dies.\n+\t       If it is used in this insn and was dead below the insn\n+\t       then it dies in this insn.  If it was set in this insn,\n+\t       we do not make a REG_DEAD note; likewise if we already\n+\t       made such a note.  */\n+\n+\t    if (! all_needed\n+\t\t&& ! dead_or_set_p (insn, x)\n+#if 0\n+\t\t&& (regno >= FIRST_PSEUDO_REGISTER || ! fixed_regs[regno])\n+#endif\n+\t\t)\n+\t      {\n+\t\t/* If none of the words in X is needed, make a REG_DEAD\n+\t\t   note.  Otherwise, we must make partial REG_DEAD notes.  */\n+\t\tif (! some_needed)\n+\t\t  {\n+\t\t    REG_NOTES (insn)\n+\t\t      = gen_rtx (EXPR_LIST, REG_DEAD, x, REG_NOTES (insn));\n+\t\t    reg_n_deaths[regno]++;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    int i;\n+\n+\t\t    /* Don't make a REG_DEAD note for a part of a register\n+\t\t       that is set in the insn.  */\n+\n+\t\t    for (i = HARD_REGNO_NREGS (regno, GET_MODE (x)) - 1;\n+\t\t\t i >= 0; i--)\n+\t\t      if ((needed[(regno + i) / REGSET_ELT_BITS]\n+\t\t\t   & 1 << ((regno + i) % REGSET_ELT_BITS)) == 0\n+\t\t\t  && ! dead_or_set_regno_p (insn, regno + i))\n+\t\t\tREG_NOTES (insn)\n+\t\t\t  = gen_rtx (EXPR_LIST, REG_DEAD,\n+\t\t\t\t     gen_rtx (REG, word_mode, regno + i),\n+\t\t\t\t     REG_NOTES (insn));\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+      return;\n+\n+    case SET:\n+      {\n+\tregister rtx testreg = SET_DEST (x);\n+\tint mark_dest = 0;\n+\n+\t/* If storing into MEM, don't show it as being used.  But do\n+\t   show the address as being used.  */\n+\tif (GET_CODE (testreg) == MEM)\n+\t  {\n+#ifdef AUTO_INC_DEC\n+\t    if (final)\n+\t      find_auto_inc (needed, testreg, insn);\n+#endif\n+\t    mark_used_regs (needed, live, XEXP (testreg, 0), final, insn);\n+\t    mark_used_regs (needed, live, SET_SRC (x), final, insn);\n+\t    return;\n+\t  }\n+\t    \n+\t/* Storing in STRICT_LOW_PART is like storing in a reg\n+\t   in that this SET might be dead, so ignore it in TESTREG.\n+\t   but in some other ways it is like using the reg.\n+\n+\t   Storing in a SUBREG or a bit field is like storing the entire\n+\t   register in that if the register's value is not used\n+\t   then this SET is not needed.  */\n+\twhile (GET_CODE (testreg) == STRICT_LOW_PART\n+\t       || GET_CODE (testreg) == ZERO_EXTRACT\n+\t       || GET_CODE (testreg) == SIGN_EXTRACT\n+\t       || GET_CODE (testreg) == SUBREG)\n+\t  {\n+\t    /* Modifying a single register in an alternate mode\n+\t       does not use any of the old value.  But these other\n+\t       ways of storing in a register do use the old value.  */\n+\t    if (GET_CODE (testreg) == SUBREG\n+\t\t&& !(REG_SIZE (SUBREG_REG (testreg)) > REG_SIZE (testreg)))\n+\t      ;\n+\t    else\n+\t      mark_dest = 1;\n+\n+\t    testreg = XEXP (testreg, 0);\n+\t  }\n+\n+\t/* If this is a store into a register,\n+\t   recursively scan the value being stored.  */\n+\n+\tif (GET_CODE (testreg) == REG\n+\t    && (regno = REGNO (testreg), regno != FRAME_POINTER_REGNUM)\n+\t    && regno != ARG_POINTER_REGNUM\n+\t    && ! (regno < FIRST_PSEUDO_REGISTER && global_regs[regno]))\n+\t  {\n+\t    mark_used_regs (needed, live, SET_SRC (x), final, insn);\n+\t    if (mark_dest)\n+\t      mark_used_regs (needed, live, SET_DEST (x), final, insn);\n+\t    return;\n+\t  }\n+      }\n+      break;\n+\n+    case RETURN:\n+      /* If exiting needs the right stack value, consider this insn as\n+\t using the stack pointer.  In any event, consider it as using\n+\t all global registers.  */\n+\n+#ifdef EXIT_IGNORE_STACK\n+      if (! EXIT_IGNORE_STACK\n+\t  || (! FRAME_POINTER_REQUIRED && flag_omit_frame_pointer))\n+#endif\n+\tlive[STACK_POINTER_REGNUM / REGSET_ELT_BITS]\n+\t  |= 1 << (STACK_POINTER_REGNUM % REGSET_ELT_BITS);\n+\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (global_regs[i])\n+\t  live[i / REGSET_ELT_BITS] |= 1 << (i % REGSET_ELT_BITS);\n+      break;\n+    }\n+\n+  /* Recursively scan the operands of this expression.  */\n+\n+  {\n+    register char *fmt = GET_RTX_FORMAT (code);\n+    register int i;\n+    \n+    for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+      {\n+\tif (fmt[i] == 'e')\n+\t  {\n+\t    /* Tail recursive case: save a function call level.  */\n+\t    if (i == 0)\n+\t      {\n+\t\tx = XEXP (x, 0);\n+\t\tgoto retry;\n+\t      }\n+\t    mark_used_regs (needed, live, XEXP (x, i), final, insn);\n+\t  }\n+\telse if (fmt[i] == 'E')\n+\t  {\n+\t    register int j;\n+\t    for (j = 0; j < XVECLEN (x, i); j++)\n+\t      mark_used_regs (needed, live, XVECEXP (x, i, j), final, insn);\n+\t  }\n+      }\n+  }\n+}\n+\f\n+#ifdef AUTO_INC_DEC\n+\n+static int\n+try_pre_increment_1 (insn)\n+     rtx insn;\n+{\n+  /* Find the next use of this reg.  If in same basic block,\n+     make it do pre-increment or pre-decrement if appropriate.  */\n+  rtx x = PATTERN (insn);\n+  int amount = ((GET_CODE (SET_SRC (x)) == PLUS ? 1 : -1)\n+\t\t* INTVAL (XEXP (SET_SRC (x), 1)));\n+  int regno = REGNO (SET_DEST (x));\n+  rtx y = reg_next_use[regno];\n+  if (y != 0\n+      && BLOCK_NUM (y) == BLOCK_NUM (insn)\n+      && try_pre_increment (y, SET_DEST (PATTERN (insn)),\n+\t\t\t    amount))\n+    {\n+      /* We have found a suitable auto-increment\n+\t and already changed insn Y to do it.\n+\t So flush this increment-instruction.  */\n+      PUT_CODE (insn, NOTE);\n+      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+      NOTE_SOURCE_FILE (insn) = 0;\n+      /* Count a reference to this reg for the increment\n+\t insn we are deleting.  When a reg is incremented.\n+\t spilling it is worse, so we want to make that\n+\t less likely.  */\n+      if (regno >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  reg_n_refs[regno] += loop_depth;\n+\t  reg_n_sets[regno]++;\n+\t}\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Try to change INSN so that it does pre-increment or pre-decrement\n+   addressing on register REG in order to add AMOUNT to REG.\n+   AMOUNT is negative for pre-decrement.\n+   Returns 1 if the change could be made.\n+   This checks all about the validity of the result of modifying INSN.  */\n+\n+static int\n+try_pre_increment (insn, reg, amount)\n+     rtx insn, reg;\n+     int amount;\n+{\n+  register rtx use;\n+\n+  /* Nonzero if we can try to make a pre-increment or pre-decrement.\n+     For example, addl $4,r1; movl (r1),... can become movl +(r1),...  */\n+  int pre_ok = 0;\n+  /* Nonzero if we can try to make a post-increment or post-decrement.\n+     For example, addl $4,r1; movl -4(r1),... can become movl (r1)+,...\n+     It is possible for both PRE_OK and POST_OK to be nonzero if the machine\n+     supports both pre-inc and post-inc, or both pre-dec and post-dec.  */\n+  int post_ok = 0;\n+\n+  /* Nonzero if the opportunity actually requires post-inc or post-dec.  */\n+  int do_post = 0;\n+\n+  /* From the sign of increment, see which possibilities are conceivable\n+     on this target machine.  */\n+#ifdef HAVE_PRE_INCREMENT\n+  if (amount > 0)\n+    pre_ok = 1;\n+#endif\n+#ifdef HAVE_POST_INCREMENT\n+  if (amount > 0)\n+    post_ok = 1;\n+#endif\n+\n+#ifdef HAVE_PRE_DECREMENT\n+  if (amount < 0)\n+    pre_ok = 1;\n+#endif\n+#ifdef HAVE_POST_DECREMENT\n+  if (amount < 0)\n+    post_ok = 1;\n+#endif\n+\n+  if (! (pre_ok || post_ok))\n+    return 0;\n+\n+  /* It is not safe to add a side effect to a jump insn\n+     because if the incremented register is spilled and must be reloaded\n+     there would be no way to store the incremented value back in memory.  */\n+\n+  if (GET_CODE (insn) == JUMP_INSN)\n+    return 0;\n+\n+  use = 0;\n+  if (pre_ok)\n+    use = find_use_as_address (PATTERN (insn), reg, 0);\n+  if (post_ok && (use == 0 || use == (rtx) 1))\n+    {\n+      use = find_use_as_address (PATTERN (insn), reg, -amount);\n+      do_post = 1;\n+    }\n+\n+  if (use == 0 || use == (rtx) 1)\n+    return 0;\n+\n+  if (GET_MODE_SIZE (GET_MODE (use)) != (amount > 0 ? amount : - amount))\n+    return 0;\n+\n+  XEXP (use, 0) = gen_rtx (amount > 0\n+\t\t\t   ? (do_post ? POST_INC : PRE_INC)\n+\t\t\t   : (do_post ? POST_DEC : PRE_DEC),\n+\t\t\t   Pmode, reg);\n+\n+  /* Record that this insn now has an implicit side effect on X.  */\n+  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_INC, reg, REG_NOTES (insn));\n+  return 1;\n+}\n+\n+#endif /* AUTO_INC_DEC */\n+\f\n+/* Find the place in the rtx X where REG is used as a memory address.\n+   Return the MEM rtx that so uses it.\n+   If PLUSCONST is nonzero, search instead for a memory address equivalent to\n+   (plus REG (const_int PLUSCONST)).\n+\n+   If such an address does not appear, return 0.\n+   If REG appears more than once, or is used other than in such an address,\n+   return (rtx)1.  */\n+\n+static rtx\n+find_use_as_address (x, reg, plusconst)\n+     register rtx x;\n+     rtx reg;\n+     int plusconst;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  char *fmt = GET_RTX_FORMAT (code);\n+  register int i;\n+  register rtx value = 0;\n+  register rtx tem;\n+\n+  if (code == MEM && XEXP (x, 0) == reg && plusconst == 0)\n+    return x;\n+\n+  if (code == MEM && GET_CODE (XEXP (x, 0)) == PLUS\n+      && XEXP (XEXP (x, 0), 0) == reg\n+      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+      && INTVAL (XEXP (XEXP (x, 0), 1)) == plusconst)\n+    return x;\n+\n+  if (code == SIGN_EXTRACT || code == ZERO_EXTRACT)\n+    {\n+      /* If REG occurs inside a MEM used in a bit-field reference,\n+\t that is unacceptable.  */\n+      if (find_use_as_address (XEXP (x, 0), reg, 0) != 0)\n+\treturn (rtx) 1;\n+    }\n+\n+  if (x == reg)\n+    return (rtx) 1;\n+\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  tem = find_use_as_address (XEXP (x, i), reg, plusconst);\n+\t  if (value == 0)\n+\t    value = tem;\n+\t  else if (tem != 0)\n+\t    return (rtx) 1;\n+\t}\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    {\n+\t      tem = find_use_as_address (XVECEXP (x, i, j), reg, plusconst);\n+\t      if (value == 0)\n+\t\tvalue = tem;\n+\t      else if (tem != 0)\n+\t\treturn (rtx) 1;\n+\t    }\n+\t}\n+    }\n+\n+  return value;\n+}\n+\f\n+/* Write information about registers and basic blocks into FILE.\n+   This is part of making a debugging dump.  */\n+\n+void\n+dump_flow_info (file)\n+     FILE *file;\n+{\n+  register int i;\n+  static char *reg_class_names[] = REG_CLASS_NAMES;\n+\n+  fprintf (file, \"%d registers.\\n\", max_regno);\n+\n+  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+    if (reg_n_refs[i])\n+      {\n+\tenum reg_class class;\n+\tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n+\t\t i, reg_n_refs[i], reg_live_length[i]);\n+\tif (reg_basic_block[i] >= 0)\n+\t  fprintf (file, \" in block %d\", reg_basic_block[i]);\n+\tif (reg_n_deaths[i] != 1)\n+\t  fprintf (file, \"; dies in %d places\", reg_n_deaths[i]);\n+\tif (reg_n_calls_crossed[i] == 1)\n+\t  fprintf (file, \"; crosses 1 call\");\n+\telse if (reg_n_calls_crossed[i])\n+\t  fprintf (file, \"; crosses %d calls\", reg_n_calls_crossed[i]);\n+\tif (PSEUDO_REGNO_BYTES (i) != UNITS_PER_WORD)\n+\t  fprintf (file, \"; %d bytes\", PSEUDO_REGNO_BYTES (i));\n+\tclass = reg_preferred_class (i);\n+\tif (class != GENERAL_REGS)\n+\t  {\n+\t    if (reg_preferred_or_nothing (i))\n+\t      fprintf (file, \"; %s or none\", reg_class_names[(int) class]);\n+\t    else\n+\t      fprintf (file, \"; pref %s\", reg_class_names[(int) class]);\n+\t  }\n+\tif (REGNO_POINTER_FLAG (i))\n+\t  fprintf (file, \"; pointer\");\n+\tfprintf (file, \".\\n\");\n+      }\n+  fprintf (file, \"\\n%d basic blocks.\\n\", n_basic_blocks);\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      register rtx head, jump;\n+      register int regno;\n+      fprintf (file, \"\\nBasic block %d: first insn %d, last %d.\\n\",\n+\t       i,\n+\t       INSN_UID (basic_block_head[i]),\n+\t       INSN_UID (basic_block_end[i]));\n+      /* The control flow graph's storage is freed\n+\t now when flow_analysis returns.\n+\t Don't try to print it if it is gone.  */\n+      if (basic_block_drops_in)\n+\t{\n+\t  fprintf (file, \"Reached from blocks: \");\n+\t  head = basic_block_head[i];\n+\t  if (GET_CODE (head) == CODE_LABEL)\n+\t    for (jump = LABEL_REFS (head);\n+\t\t jump != head;\n+\t\t jump = LABEL_NEXTREF (jump))\n+\t      {\n+\t\tregister int from_block = BLOCK_NUM (CONTAINING_INSN (jump));\n+\t\tfprintf (file, \" %d\", from_block);\n+\t      }\n+\t  if (basic_block_drops_in[i])\n+\t    fprintf (file, \" previous\");\n+\t}\n+      fprintf (file, \"\\nRegisters live at start:\");\n+      for (regno = 0; regno < max_regno; regno++)\n+\t{\n+\t  register int offset = regno / REGSET_ELT_BITS;\n+\t  register int bit = 1 << (regno % REGSET_ELT_BITS);\n+\t  if (basic_block_live_at_start[i][offset] & bit)\n+\t      fprintf (file, \" %d\", regno);\n+\t}\n+      fprintf (file, \"\\n\");\n+    }\n+  fprintf (file, \"\\n\");\n+}"}]}