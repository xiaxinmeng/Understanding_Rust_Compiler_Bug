{"sha": "69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlkODBmMGYyZjBiYjhhODhjZDgyZDhhYjZjNGI5MmNmODAxM2NhMQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-06-20T16:47:18Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-06-20T16:47:18Z"}, "message": "libstdc++: Implement new views::split as per P2210\n\nThis implements the new views::split from P2210R2 \"Superior String\nSplitting\".\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/ranges (__non_propagating_cache::operator bool):\n\tDefine for split_view::begin().\n\t(split_view): Define as per P2210.\n\t(views::__detail::__can_split_view): Define.\n\t(views::_Split, views::split): Define.\n\t* testsuite/std/ranges/adaptors/100577.cc (test01, test02):\n\tTest views::split.\n\t* testsuite/std/ranges/adaptors/split.cc: New test.\n\t* testsuite/std/ranges/p2325.cc (test08a): New test.\n\t* testsuite/std/ranges/p2367.cc (test01): Test views::split.", "tree": {"sha": "a49bc449bdb49235bc853865ac332ee2983a414b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a49bc449bdb49235bc853865ac332ee2983a414b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1/comments", "author": null, "committer": null, "parents": [{"sha": "adbd2c7102d30cafdb82062940b2181df30c20c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adbd2c7102d30cafdb82062940b2181df30c20c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adbd2c7102d30cafdb82062940b2181df30c20c8"}], "stats": {"total": 437, "additions": 435, "deletions": 2}, "files": [{"sha": "f552caa9d5b787bf0bcc711536b667d9288a1b3c", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1", "patch": "@@ -1195,6 +1195,10 @@ namespace views::__adaptor\n \t  return *this;\n \t}\n \n+\tconstexpr explicit\n+\toperator bool() const noexcept\n+\t{ return this->_M_is_engaged(); }\n+\n \tconstexpr _Tp&\n \toperator*() noexcept\n \t{ return this->_M_get(); }\n@@ -3272,6 +3276,207 @@ namespace views::__adaptor\n     inline constexpr _LazySplit lazy_split;\n   } // namespace views\n \n+  template<forward_range _Vp, forward_range _Pattern>\n+    requires view<_Vp> && view<_Pattern>\n+      && indirectly_comparable<iterator_t<_Vp>, iterator_t<_Pattern>,\n+\t\t\t       ranges::equal_to>\n+  class split_view : public view_interface<split_view<_Vp, _Pattern>>\n+  {\n+  private:\n+    _Pattern _M_pattern = _Pattern();\n+    __detail::__non_propagating_cache<subrange<iterator_t<_Vp>>> _M_cached_begin;\n+    _Vp _M_base = _Vp();\n+\n+    struct _Iterator;\n+    struct _Sentinel;\n+\n+  public:\n+    split_view() requires (default_initializable<_Vp>\n+\t\t\t   && default_initializable<_Pattern>)\n+      = default;\n+\n+    constexpr\n+    split_view(_Vp __base, _Pattern __pattern)\n+      : _M_pattern(std::move(__pattern)),\n+\t_M_base(std::move(__base))\n+    { }\n+\n+    template<forward_range _Range>\n+      requires constructible_from<_Vp, views::all_t<_Range>>\n+\t&& constructible_from<_Pattern, single_view<range_value_t<_Range>>>\n+    constexpr\n+    split_view(_Range&& __r, range_value_t<_Range> __e)\n+      : _M_pattern(views::single(__e)),\n+\t_M_base(views::all(std::forward<_Range>(__r)))\n+    { }\n+\n+    constexpr _Vp\n+    base() const& requires copyable<_Vp>\n+    { return _M_base; }\n+\n+    constexpr _Vp\n+    base() &&\n+    { return std::move(_M_base); }\n+\n+    constexpr _Iterator\n+    begin()\n+    {\n+      if (!_M_cached_begin)\n+\t_M_cached_begin = _M_find_next(ranges::begin(_M_base));\n+      return {this, ranges::begin(_M_base), *_M_cached_begin};\n+    }\n+\n+    constexpr auto\n+    end()\n+    {\n+      if constexpr (common_range<_Vp>)\n+\treturn _Iterator{this, ranges::end(_M_base), {}};\n+      else\n+\treturn _Sentinel{this};\n+    }\n+\n+    constexpr subrange<iterator_t<_Vp>>\n+    _M_find_next(iterator_t<_Vp> __it)\n+    {\n+      auto [__b, __e] = ranges::search(subrange(__it, ranges::end(_M_base)), _M_pattern);\n+      if (__b != ranges::end(_M_base) && ranges::empty(_M_pattern))\n+\t{\n+\t  ++__b;\n+\t  ++__e;\n+\t}\n+      return {__b, __e};\n+    }\n+\n+  private:\n+    struct _Iterator\n+    {\n+    private:\n+      split_view* _M_parent = nullptr;\n+      iterator_t<_Vp> _M_cur = iterator_t<_Vp>();\n+      subrange<iterator_t<_Vp>> _M_next = subrange<iterator_t<_Vp>>();\n+      bool _M_trailing_empty = false;\n+\n+      friend struct _Sentinel;\n+\n+    public:\n+      using iterator_concept = forward_iterator_tag;\n+      using iterator_category = input_iterator_tag;\n+      using value_type = subrange<iterator_t<_Vp>>;\n+      using difference_type = range_difference_t<_Vp>;\n+\n+      _Iterator() requires default_initializable<iterator_t<_Vp>> = default;\n+\n+      constexpr\n+      _Iterator(split_view* __parent,\n+\t\titerator_t<_Vp> __current,\n+\t\tsubrange<iterator_t<_Vp>> __next)\n+\t: _M_parent(__parent),\n+\t  _M_cur(std::move(__current)),\n+\t  _M_next(std::move(__next))\n+      { }\n+\n+      constexpr iterator_t<_Vp>\n+      base() const\n+      { return _M_cur; }\n+\n+      constexpr value_type\n+      operator*() const\n+      { return {_M_cur, _M_next.begin()}; }\n+\n+      constexpr _Iterator&\n+      operator++()\n+      {\n+\t_M_cur = _M_next.begin();\n+\tif (_M_cur != ranges::end(_M_parent->_M_base))\n+\t  {\n+\t    _M_cur = _M_next.end();\n+\t    if (_M_cur == ranges::end(_M_parent->_M_base))\n+\t      {\n+\t\t_M_trailing_empty = true;\n+\t\t_M_next = {_M_cur, _M_cur};\n+\t      }\n+\t    else\n+\t      _M_next = _M_parent->_M_find_next(_M_cur);\n+\t  }\n+\telse\n+\t  _M_trailing_empty = false;\n+\treturn *this;\n+      }\n+\n+      constexpr _Iterator\n+      operator++(int)\n+      {\n+\tauto __tmp = *this;\n+\t++*this;\n+\treturn __tmp;\n+      }\n+\n+      friend constexpr bool\n+      operator==(const _Iterator& __x, const _Iterator& __y)\n+      {\n+\treturn __x._M_cur == __y._M_cur\n+\t  && __x._M_trailing_empty == __y._M_trailing_empty;\n+      }\n+    };\n+\n+    struct _Sentinel\n+    {\n+    private:\n+      sentinel_t<_Vp> _M_end = sentinel_t<_Vp>();\n+\n+      constexpr bool\n+      _M_equal(const _Iterator& __x) const\n+      { return __x._M_cur == _M_end && !__x._M_trailing_empty; }\n+\n+    public:\n+      constexpr explicit\n+      _Sentinel(split_view* __parent)\n+\t: _M_end(ranges::end(__parent->_M_base))\n+      { }\n+\n+      friend constexpr bool\n+      operator==(const _Iterator& __x, const _Sentinel& __y)\n+      { return __y._M_equal(__x); }\n+    };\n+  };\n+\n+  template<typename _Range, typename _Pattern>\n+    split_view(_Range&&, _Pattern&&)\n+      -> split_view<views::all_t<_Range>, views::all_t<_Pattern>>;\n+\n+  template<forward_range _Range>\n+    split_view(_Range&&, range_value_t<_Range>)\n+      -> split_view<views::all_t<_Range>, single_view<range_value_t<_Range>>>;\n+\n+  namespace views\n+  {\n+    namespace __detail\n+    {\n+      template<typename _Range, typename _Pattern>\n+\tconcept __can_split_view\n+\t  = requires { split_view(std::declval<_Range>(), std::declval<_Pattern>()); };\n+    } // namespace __detail\n+\n+    struct _Split : __adaptor::_RangeAdaptor<_Split>\n+    {\n+      template<viewable_range _Range, typename _Pattern>\n+\trequires __detail::__can_split_view<_Range, _Pattern>\n+\tconstexpr auto\n+\toperator()(_Range&& __r, _Pattern&& __f) const\n+\t{\n+\t  return split_view(std::forward<_Range>(__r), std::forward<_Pattern>(__f));\n+\t}\n+\n+      using _RangeAdaptor<_Split>::operator();\n+      static constexpr int _S_arity = 2;\n+      template<typename _Pattern>\n+\tstatic constexpr bool _S_has_simple_extra_args\n+\t  = _LazySplit::_S_has_simple_extra_args<_Pattern>;\n+    };\n+\n+    inline constexpr _Split split;\n+  } // namespace views\n+\n   namespace views\n   {\n     struct _Counted"}, {"sha": "26da4970ccc1df85fbe3b7696f3b4ffbf8a55f73", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/100577.cc", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2F100577.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2F100577.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2F100577.cc?ref=69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1", "patch": "@@ -42,8 +42,6 @@ test01()\n   static_assert(__adaptor_has_simple_extra_args<decltype(views::lazy_split), char>);\n   static_assert(!__adaptor_has_simple_extra_args<decltype(views::lazy_split), std::string>);\n \n-  // Verify all adaptor closures except for views::lazy_split(pattern) have a simple\n-  // operator().\n   using views::__adaptor::__closure_has_simple_call_op;\n   __closure_has_simple_call_op auto a00 = views::all;\n   __closure_has_simple_call_op auto a01 = views::transform(std::identity{});\n@@ -57,6 +55,7 @@ test01()\n   __closure_has_simple_call_op auto a09 = views::reverse;\n   __closure_has_simple_call_op auto a10 = views::keys;\n   __closure_has_simple_call_op auto a11 = views::lazy_split(' ');\n+  __closure_has_simple_call_op auto a11a = views::split(' ');\n   // Verify composition of simple closures is simple.\n   __closure_has_simple_call_op auto b\n     = (a00 | a01) | (a02 | a03) | (a04 | a05 | a06) | (a07 | a08 | a09 | a10) | a11;\n@@ -67,6 +66,12 @@ test01()\n   static_assert(!__closure_has_simple_call_op<decltype(a12)>);\n   static_assert(!__closure_has_simple_call_op<decltype(a12 | a00)>);\n   static_assert(!__closure_has_simple_call_op<decltype(a00 | a12)>);\n+\n+  // Likewise views::split(non_view_range).\n+  auto a12a = views::split(s);\n+  static_assert(!__closure_has_simple_call_op<decltype(a12a)>);\n+  static_assert(!__closure_has_simple_call_op<decltype(a12a | a00)>);\n+  static_assert(!__closure_has_simple_call_op<decltype(a00 | a12a)>);\n }\n \n void\n@@ -98,6 +103,13 @@ test02()\n   auto a1 = a0 | views::all;\n   a1(x); // { dg-error \"no match\" }\n \n+  views::split(badarg)(x); // { dg-error \"deleted function\" }\n+  (views::split(badarg) | views::all)(x); // { dg-error \"deleted function\" }\n+  auto a0a = views::split(badarg);\n+  a0a(x); // { dg-error \"no match\" };\n+  auto a1a = a0a | views::all;\n+  a1a(x); // { dg-error \"no match\" }\n+\n   views::take(badarg)(x); // { dg-error \"deleted\" }\n   views::drop(badarg)(x); // { dg-error \"deleted\" }\n   (views::take(badarg) | views::all)(x); // { dg-error \"deleted\" }"}, {"sha": "02c6073a503447354690d16e3716c25fafc23147", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/split.cc", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit.cc?ref=69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1", "patch": "@@ -0,0 +1,201 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <string>\n+#include <string_view>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::input_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+namespace views = std::ranges::views;\n+\n+using namespace std::literals;\n+\n+void\n+test01()\n+{\n+  auto from_chars = [] (auto v) {\n+    return std::stoi(std::string(v.data(), v.data() + v.size()));\n+  };\n+  auto ints = \"1.2.3.4\"sv\n+    | views::split('.')\n+    | views::transform(from_chars);\n+  VERIFY( ranges::equal(ints, (int[]){1,2,3,4}) );\n+}\n+\n+// The following testcases are adapted from lazy_split.cc.\n+namespace from_lazy_split_cc\n+{\n+void\n+test01()\n+{\n+  auto x = \"the  quick  brown  fox\"sv;\n+  auto p = std::string{\"  \"};\n+  auto v = x | views::split(views::all(p)); // views::all is needed here after P2281.\n+  auto i = v.begin();\n+  VERIFY( ranges::equal(*i++, \"the\"sv) );\n+  VERIFY( ranges::equal(*i++, \"quick\"sv) );\n+  VERIFY( ranges::equal(*i++, \"brown\"sv) );\n+  VERIFY( ranges::equal(*i++, \"fox\"sv) );\n+  VERIFY( i == v.end() );\n+}\n+\n+void\n+test02()\n+{\n+  auto x = \"the quick brown fox\"sv;\n+  auto v = x | views::split(' ');\n+  auto i = v.begin();\n+  VERIFY( ranges::equal(*i++, \"the\"sv) );\n+  VERIFY( ranges::equal(*i++, \"quick\"sv) );\n+  VERIFY( ranges::equal(*i++, \"brown\"sv) );\n+  VERIFY( ranges::equal(*i++, \"fox\"sv) );\n+  VERIFY( i == v.end() );\n+}\n+\n+void\n+test03()\n+{\n+  char x[] = \"the quick brown fox\";\n+  test_range<char, forward_iterator_wrapper> rx(x, x+sizeof(x)-1);\n+  auto v = rx | views::split(' ');\n+  auto i = v.begin();\n+  VERIFY( ranges::equal(*i++, \"the\"sv) );\n+  VERIFY( ranges::equal(*i++, \"quick\"sv) );\n+  VERIFY( ranges::equal(*i++, \"brown\"sv) );\n+  VERIFY( ranges::equal(*i++, \"fox\"sv) );\n+  VERIFY( i == v.end() );\n+}\n+\n+void\n+test04()\n+{\n+  auto x = \"the  quick  brown  fox\"sv;\n+  std::initializer_list<char> p = {' ', ' '};\n+  static_assert(!ranges::view<decltype(p)>);\n+  static_assert(std::same_as<decltype(p | views::all),\n+\t\t\t     ranges::ref_view<decltype(p)>>);\n+  auto v = x | views::split(views::all(p)); // views::all is needed here after P2281.\n+  auto i = v.begin();\n+  VERIFY( ranges::equal(*i++, \"the\"sv) );\n+  VERIFY( ranges::equal(*i++, \"quick\"sv) );\n+  VERIFY( ranges::equal(*i++, \"brown\"sv) );\n+  VERIFY( ranges::equal(*i++, \"fox\"sv) );\n+  VERIFY( i == v.end() );\n+}\n+\n+void\n+test05()\n+{\n+  auto as_string = [](ranges::view auto rng) {\n+    auto in = rng | views::common;\n+    return std::string(in.begin(), in.end());\n+  };\n+  std::string str\n+    = \"Now is the time for all good men to come to the aid of their county.\";\n+  auto rng\n+    = str | views::split(' ') | views::transform(as_string) | views::common;\n+  std::vector<std::string> words(rng.begin(), rng.end());\n+  auto not_space_p = [](char c) { return c != ' '; };\n+  VERIFY( ranges::equal(words | views::join,\n+\t\t\tstr | views::filter(not_space_p)) );\n+}\n+\n+template<auto split = views::split>\n+void\n+test06()\n+{\n+  // Verify SFINAE behavior.\n+  std::string s, p;\n+  static_assert(!requires { split(); });\n+  static_assert(!requires { split(s, p, 0); });\n+  static_assert(!requires { split(p)(); });\n+  static_assert(!requires { s | split; });\n+\n+  static_assert(!requires { s | split(p); });\n+  static_assert(!requires { split(p)(s); });\n+  static_assert(!requires { s | (split(p) | views::all); });\n+  static_assert(!requires { (split(p) | views::all)(s); });\n+\n+  static_assert(requires { s | split(views::all(p)); });\n+  static_assert(requires { split(views::all(p))(s); });\n+  static_assert(requires { s | (split(views::all(p)) | views::all); });\n+  static_assert(requires { (split(views::all(p)) | views::all)(s); });\n+\n+  auto adapt = split(p);\n+  static_assert(requires { s | adapt; });\n+  static_assert(requires { adapt(s); });\n+\n+  auto adapt2 = split(p) | views::all;\n+  static_assert(requires { s | adapt2; });\n+  static_assert(requires { adapt2(s); });\n+}\n+\n+void\n+test10()\n+{\n+  // LWG 3505\n+  auto to_string = [] (auto r) {\n+    return std::string(r.begin(), ranges::next(r.begin(), r.end()));\n+  };\n+  auto v = \"xxyx\"sv | views::split(\"xy\"sv) | views::transform(to_string);\n+  VERIFY( ranges::equal(v, (std::string_view[]){\"x\", \"x\"}) );\n+}\n+\n+void\n+test11()\n+{\n+  // LWG 3478\n+  auto v = views::split(\"text\"sv, \"text\"sv);\n+  auto i = v.begin();\n+  VERIFY( ranges::empty(*i++) );\n+  VERIFY( ranges::empty(*i++) );\n+  VERIFY( i == v.end() );\n+\n+  static_assert(ranges::distance(views::split(\" text \"sv, ' ')) == 3);\n+  static_assert(ranges::distance(views::split(\" t e x t \"sv, ' ')) == 6);\n+  static_assert(ranges::distance(views::split(\"  text  \"sv, \"  \"sv)) == 3);\n+  static_assert(ranges::distance(views::split(\"  text    \"sv, \"  \"sv)) == 4);\n+  static_assert(ranges::distance(views::split(\"  text     \"sv, \"  \"sv)) == 4);\n+  static_assert(ranges::distance(views::split(\"t\"sv, 't')) == 2);\n+  static_assert(ranges::distance(views::split(\"text\"sv, \"\"sv)) == 4);\n+}\n+} // namespace from_lazy_split_cc\n+\n+int\n+main()\n+{\n+  test01();\n+\n+  from_lazy_split_cc::test01();\n+  from_lazy_split_cc::test02();\n+  from_lazy_split_cc::test03();\n+  from_lazy_split_cc::test04();\n+  from_lazy_split_cc::test05();\n+  from_lazy_split_cc::test06();\n+  from_lazy_split_cc::test10();\n+  from_lazy_split_cc::test11();\n+}"}, {"sha": "d2ebe9af8630a1cb8aba8ad7b925f691ae9d8451", "filename": "libstdc++-v3/testsuite/std/ranges/p2325.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fp2325.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fp2325.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fp2325.cc?ref=69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1", "patch": "@@ -124,6 +124,20 @@ test08()\n   static_assert(default_initializable<type4>);\n }\n \n+void\n+test08a()\n+{\n+  // Verify split_view is conditionally default constructible.\n+  using type1 = ranges::split_view<ranges::ref_view<int[2]>, ranges::single_view<int>>;\n+  static_assert(!default_initializable<type1>);\n+  using type2 = ranges::split_view<ranges::single_view<int>, ranges::ref_view<int[2]>>;\n+  static_assert(!default_initializable<type2>);\n+  using type3 = ranges::split_view<ranges::ref_view<int[2]>, ranges::ref_view<int[2]>>;\n+  static_assert(!default_initializable<type3>);\n+  using type4 = ranges::split_view<ranges::single_view<int>, ranges::single_view<int>>;\n+  static_assert(default_initializable<type4>);\n+}\n+\n void\n test09()\n {"}, {"sha": "70a0304593f12282ab271dd154643a0d72bec637", "filename": "libstdc++-v3/testsuite/std/ranges/p2367.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fp2367.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fp2367.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fp2367.cc?ref=69d80f0f2f0bb8a88cd82d8ab6c4b92cf8013ca1", "patch": "@@ -45,4 +45,5 @@ test01()\n \n   // Verify changes to views::lazy_split.\n   auto v6 = views::lazy_split(x, 5u);\n+  auto v7 = views::split(x, 5u);\n }"}]}