{"sha": "ef835bb0c34abed46e891257dc9bb12abc8b926d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY4MzViYjBjMzRhYmVkNDZlODkxMjU3ZGM5YmIxMmFiYzhiOTI2ZA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-11-14T11:45:55Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-11-14T11:45:55Z"}, "message": "Delete two unused functions\n\nFrom-SVN: r30526", "tree": {"sha": "fffac5074c241f48ba23ce2fcf3bc69cd93108ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fffac5074c241f48ba23ce2fcf3bc69cd93108ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef835bb0c34abed46e891257dc9bb12abc8b926d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef835bb0c34abed46e891257dc9bb12abc8b926d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef835bb0c34abed46e891257dc9bb12abc8b926d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef835bb0c34abed46e891257dc9bb12abc8b926d/comments", "author": null, "committer": null, "parents": [{"sha": "6d6ce8b210827a658383a9a4a7c2d64e0a19f09c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d6ce8b210827a658383a9a4a7c2d64e0a19f09c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d6ce8b210827a658383a9a4a7c2d64e0a19f09c"}], "stats": {"total": 213, "additions": 5, "deletions": 208}, "files": [{"sha": "45949899068e4a56e6bad35207d4ec08cb3f6740", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef835bb0c34abed46e891257dc9bb12abc8b926d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef835bb0c34abed46e891257dc9bb12abc8b926d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef835bb0c34abed46e891257dc9bb12abc8b926d", "patch": "@@ -1,3 +1,8 @@\n+Sun Nov 14 12:41:57 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* cse.c (set_nonvarying_address_components): Delete unused function.\n+\t(refers_to_p): Likewise.\n+\n Fri Nov 12 20:53:22 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* function.c (diddle_return_value): Set REG_FUNCTION_VALUE_P as"}, {"sha": "0736cd967e834677eb47bc7b18c7386d03060fc2", "filename": "gcc/cse.c", "status": "modified", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef835bb0c34abed46e891257dc9bb12abc8b926d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef835bb0c34abed46e891257dc9bb12abc8b926d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=ef835bb0c34abed46e891257dc9bb12abc8b926d", "patch": "@@ -669,10 +669,6 @@ static rtx use_related_value\tPROTO((rtx, struct table_elt *));\n static unsigned canon_hash\tPROTO((rtx, enum machine_mode));\n static unsigned safe_hash\tPROTO((rtx, enum machine_mode));\n static int exp_equiv_p\t\tPROTO((rtx, rtx, int, int));\n-static void set_nonvarying_address_components PROTO((rtx, int, rtx *,\n-\t\t\t\t\t\t     HOST_WIDE_INT *,\n-\t\t\t\t\t\t     HOST_WIDE_INT *));\n-static int refers_to_p\t\tPROTO((rtx, rtx));\n static rtx canon_reg\t\tPROTO((rtx, rtx));\n static void find_best_addr\tPROTO((rtx, rtx *));\n static enum rtx_code find_comparison_args PROTO((enum rtx_code, rtx *, rtx *,\n@@ -2455,210 +2451,6 @@ exp_equiv_p (x, y, validate, equal_values)\n   return 1;\n }\n \f\n-/* Return 1 iff any subexpression of X matches Y.\n-   Here we do not require that X or Y be valid (for registers referred to)\n-   for being in the hash table.  */\n-\n-static int\n-refers_to_p (x, y)\n-     rtx x, y;\n-{\n-  register int i;\n-  register enum rtx_code code;\n-  register const char *fmt;\n-\n- repeat:\n-  if (x == y)\n-    return 1;\n-  if (x == 0 || y == 0)\n-    return 0;\n-\n-  code = GET_CODE (x);\n-  /* If X as a whole has the same code as Y, they may match.\n-     If so, return 1.  */\n-  if (code == GET_CODE (y))\n-    {\n-      if (exp_equiv_p (x, y, 0, 1))\n-\treturn 1;\n-    }\n-\n-  /* X does not match, so try its subexpressions.  */\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    if (fmt[i] == 'e')\n-      {\n-\tif (i == 0)\n-\t  {\n-\t    x = XEXP (x, 0);\n-\t    goto repeat;\n-\t  }\n-\telse\n-\t  if (refers_to_p (XEXP (x, i), y))\n-\t    return 1;\n-      }\n-    else if (fmt[i] == 'E')\n-      {\n-\tint j;\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  if (refers_to_p (XVECEXP (x, i, j), y))\n-\t    return 1;\n-      }\n-\n-  return 0;\n-}\n-\f\n-/* Given ADDR and SIZE (a memory address, and the size of the memory reference),\n-   set PBASE, PSTART, and PEND which correspond to the base of the address,\n-   the starting offset, and ending offset respectively.\n-\n-   ADDR is known to be a nonvarying address.  */\n-\n-/* ??? Despite what the comments say, this function is in fact frequently\n-   passed varying addresses.  This does not appear to cause any problems.  */\n-\n-static void\n-set_nonvarying_address_components (addr, size, pbase, pstart, pend)\n-     rtx addr;\n-     int size;\n-     rtx *pbase;\n-     HOST_WIDE_INT *pstart, *pend;\n-{\n-  rtx base;\n-  HOST_WIDE_INT start, end;\n-\n-  base = addr;\n-  start = 0;\n-  end = 0;\n-\n-  if (flag_pic && GET_CODE (base) == PLUS\n-      && XEXP (base, 0) == pic_offset_table_rtx)\n-    base = XEXP (base, 1);\n-\n-  /* Registers with nonvarying addresses usually have constant equivalents;\n-     but the frame pointer register is also possible.  */\n-  if (GET_CODE (base) == REG\n-      && qty_const != 0\n-      && REGNO_QTY_VALID_P (REGNO (base))\n-      && qty_mode[REG_QTY (REGNO (base))] == GET_MODE (base)\n-      && qty_const[REG_QTY (REGNO (base))] != 0)\n-    base = qty_const[REG_QTY (REGNO (base))];\n-  else if (GET_CODE (base) == PLUS\n-\t   && GET_CODE (XEXP (base, 1)) == CONST_INT\n-\t   && GET_CODE (XEXP (base, 0)) == REG\n-\t   && qty_const != 0\n-\t   && REGNO_QTY_VALID_P (REGNO (XEXP (base, 0)))\n-\t   && (qty_mode[REG_QTY (REGNO (XEXP (base, 0)))]\n-\t       == GET_MODE (XEXP (base, 0)))\n-\t   && qty_const[REG_QTY (REGNO (XEXP (base, 0)))])\n-    {\n-      start = INTVAL (XEXP (base, 1));\n-      base = qty_const[REG_QTY (REGNO (XEXP (base, 0)))];\n-    }\n-  /* This can happen as the result of virtual register instantiation,\n-     if the initial offset is too large to be a valid address.  */\n-  else if (GET_CODE (base) == PLUS\n-\t   && GET_CODE (XEXP (base, 0)) == REG\n-\t   && GET_CODE (XEXP (base, 1)) == REG\n-\t   && qty_const != 0\n-\t   && REGNO_QTY_VALID_P (REGNO (XEXP (base, 0)))\n-\t   && (qty_mode[REG_QTY (REGNO (XEXP (base, 0)))]\n-\t       == GET_MODE (XEXP (base, 0)))\n-\t   && qty_const[REG_QTY (REGNO (XEXP (base, 0)))]\n-\t   && REGNO_QTY_VALID_P (REGNO (XEXP (base, 1)))\n-\t   && (qty_mode[REG_QTY (REGNO (XEXP (base, 1)))]\n-\t       == GET_MODE (XEXP (base, 1)))\n-\t   && qty_const[REG_QTY (REGNO (XEXP (base, 1)))])\n-    {\n-      rtx tem = qty_const[REG_QTY (REGNO (XEXP (base, 1)))];\n-      base = qty_const[REG_QTY (REGNO (XEXP (base, 0)))];\n-\n-      /* One of the two values must be a constant.  */\n-      if (GET_CODE (base) != CONST_INT)\n-\t{\n-\t  if (GET_CODE (tem) != CONST_INT)\n-\t    abort ();\n-\t  start = INTVAL (tem);\n-\t}\n-      else\n-\t{\n-\t  start = INTVAL (base);\n-\t  base = tem;\n-\t}\n-    }\n-\n-  /* Handle everything that we can find inside an address that has been\n-     viewed as constant.  */\n-\n-  while (1)\n-    {\n-      /* If no part of this switch does a \"continue\", the code outside\n-\t will exit this loop.  */\n-\n-      switch (GET_CODE (base))\n-\t{\n-\tcase LO_SUM:\n-\t  /* By definition, operand1 of a LO_SUM is the associated constant\n-\t     address.  Use the associated constant address as the base\n-\t     instead.  */\n-\t  base = XEXP (base, 1);\n-\t  continue;\n-\n-\tcase CONST:\n-\t  /* Strip off CONST.  */\n-\t  base = XEXP (base, 0);\n-\t  continue;\n-\n-\tcase PLUS:\n-\t  if (GET_CODE (XEXP (base, 1)) == CONST_INT)\n-\t    {\n-\t      start += INTVAL (XEXP (base, 1));\n-\t      base = XEXP (base, 0);\n-\t      continue;\n-\t    }\n-\t  break;\n-\n-\tcase AND:\n-\t  /* Handle the case of an AND which is the negative of a power of\n-\t     two.  This is used to represent unaligned memory operations.  */\n-\t  if (GET_CODE (XEXP (base, 1)) == CONST_INT\n-\t      && exact_log2 (- INTVAL (XEXP (base, 1))) > 0)\n-\t    {\n-\t      set_nonvarying_address_components (XEXP (base, 0), size,\n-\t\t\t\t\t\t pbase, pstart, pend);\n-\n-\t      /* Assume the worst misalignment.  START is affected, but not\n-\t\t END, so compensate but adjusting SIZE.  Don't lose any\n-\t\t constant we already had.  */\n-\n-\t      size = *pend - *pstart - INTVAL (XEXP (base, 1)) - 1;\n-\t      start += *pstart + INTVAL (XEXP (base, 1)) + 1;\n-\t      end += *pend;\n-\t      base = *pbase;\n-\t    }\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      break;\n-    }\n-\n-  if (GET_CODE (base) == CONST_INT)\n-    {\n-      start += INTVAL (base);\n-      base = const0_rtx;\n-    }\n-\n-  end = start + size;\n-\n-  /* Set the return values.  */\n-  *pbase = base;\n-  *pstart = start;\n-  *pend = end;\n-}\n-\n /* Return 1 if X has a value that can vary even between two\n    executions of the program.  0 means X can be compared reliably\n    against certain constants or near-constants.  */"}]}