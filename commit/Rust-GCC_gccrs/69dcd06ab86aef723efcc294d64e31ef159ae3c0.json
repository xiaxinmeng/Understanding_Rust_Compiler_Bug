{"sha": "69dcd06ab86aef723efcc294d64e31ef159ae3c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlkY2QwNmFiODZhZWY3MjNlZmNjMjk0ZDY0ZTMxZWYxNTlhZTNjMA==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2010-07-28T17:06:40Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2010-07-28T17:06:40Z"}, "message": "gfortran.h (gfc_build_intrinsic_call): New method.\n\n2010-07-28  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.h (gfc_build_intrinsic_call): New method.\n\t* expr.c (gfc_build_intrinsic_call): New method.\n\t* simplify.c (range_check): Ignore non-constant value.\n\t(simplify_bound_dim): Handle non-variable expressions and\n\tfix memory leak with non-free'ed expression.\n\t(simplify_bound): Handle non-variable expressions.\n\t(gfc_simplify_shape): Ditto.\n\t(gfc_simplify_size): Ditto, but only in certain cases possible.\n\n2010-07-28  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.dg/bound_8.f90: New test.\n\nFrom-SVN: r162648", "tree": {"sha": "d6abc79640b3f8726b5ce5ea87b458be1a547ddc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6abc79640b3f8726b5ce5ea87b458be1a547ddc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69dcd06ab86aef723efcc294d64e31ef159ae3c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69dcd06ab86aef723efcc294d64e31ef159ae3c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69dcd06ab86aef723efcc294d64e31ef159ae3c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69dcd06ab86aef723efcc294d64e31ef159ae3c0/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "05b5ea3495029f4da3687c03a27d70dad682f585", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05b5ea3495029f4da3687c03a27d70dad682f585", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05b5ea3495029f4da3687c03a27d70dad682f585"}], "stats": {"total": 255, "additions": 229, "deletions": 26}, "files": [{"sha": "c87b611904293427c45009e971955dc0c8538667", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dcd06ab86aef723efcc294d64e31ef159ae3c0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dcd06ab86aef723efcc294d64e31ef159ae3c0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=69dcd06ab86aef723efcc294d64e31ef159ae3c0", "patch": "@@ -1,3 +1,14 @@\n+2010-07-28  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.h (gfc_build_intrinsic_call): New method.\n+\t* expr.c (gfc_build_intrinsic_call): New method.\n+\t* simplify.c (range_check): Ignore non-constant value.\n+\t(simplify_bound_dim): Handle non-variable expressions and\n+\tfix memory leak with non-free'ed expression.\n+\t(simplify_bound): Handle non-variable expressions.\n+\t(gfc_simplify_shape): Ditto.\n+\t(gfc_simplify_size): Ditto, but only in certain cases possible.\n+\n 2010-07-28  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gfortranspec.c (SWITCH_TAKES_ARG, WORD_SWITCH_TAKES_ARG):"}, {"sha": "661cac49a4de9e948622b6070e25b6966c121b53", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dcd06ab86aef723efcc294d64e31ef159ae3c0/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dcd06ab86aef723efcc294d64e31ef159ae3c0/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=69dcd06ab86aef723efcc294d64e31ef159ae3c0", "patch": "@@ -4199,3 +4199,47 @@ gfc_is_simply_contiguous (gfc_expr *expr, bool strict)\n   \n   return true;\n }\n+\n+\n+/* Build call to an intrinsic procedure.  The number of arguments has to be\n+   passed (rather than ending the list with a NULL value) because we may\n+   want to add arguments but with a NULL-expression.  */\n+\n+gfc_expr*\n+gfc_build_intrinsic_call (const char* name, locus where, unsigned numarg, ...)\n+{\n+  gfc_expr* result;\n+  gfc_actual_arglist* atail;\n+  gfc_intrinsic_sym* isym;\n+  va_list ap;\n+  unsigned i;\n+\n+  isym = gfc_find_function (name);\n+  gcc_assert (isym);\n+  \n+  result = gfc_get_expr ();\n+  result->expr_type = EXPR_FUNCTION;\n+  result->ts = isym->ts;\n+  result->where = where;\n+  gfc_get_ha_sym_tree (isym->name, &result->symtree);\n+  result->value.function.name = name;\n+  result->value.function.isym = isym;\n+\n+  va_start (ap, numarg);\n+  atail = NULL;\n+  for (i = 0; i < numarg; ++i)\n+    {\n+      if (atail)\n+\t{\n+\t  atail->next = gfc_get_actual_arglist ();\n+\t  atail = atail->next;\n+\t}\n+      else\n+\tatail = result->value.function.actual = gfc_get_actual_arglist ();\n+\n+      atail->expr = va_arg (ap, gfc_expr*);\n+    }\n+  va_end (ap);\n+\n+  return result;\n+}"}, {"sha": "d35a040d7117cafd9fb02d3b2229b382d328057f", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dcd06ab86aef723efcc294d64e31ef159ae3c0/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dcd06ab86aef723efcc294d64e31ef159ae3c0/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=69dcd06ab86aef723efcc294d64e31ef159ae3c0", "patch": "@@ -2691,6 +2691,8 @@ bool gfc_get_corank (gfc_expr *);\n bool gfc_has_ultimate_allocatable (gfc_expr *);\n bool gfc_has_ultimate_pointer (gfc_expr *);\n \n+gfc_expr* gfc_build_intrinsic_call (const char*, locus, unsigned, ...);\n+\n \n /* st.c */\n extern gfc_code new_st;"}, {"sha": "a77f6bd35444240fd971c6913d48a71d936c57ee", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 124, "deletions": 26, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dcd06ab86aef723efcc294d64e31ef159ae3c0/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dcd06ab86aef723efcc294d64e31ef159ae3c0/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=69dcd06ab86aef723efcc294d64e31ef159ae3c0", "patch": "@@ -73,6 +73,9 @@ range_check (gfc_expr *result, const char *name)\n   if (result == NULL)\n     return &gfc_bad_expr;\n \n+  if (result->expr_type != EXPR_CONSTANT)\n+    return result;\n+\n   switch (gfc_range_check (result))\n     {\n       case ARITH_OK:\n@@ -2727,24 +2730,52 @@ simplify_bound_dim (gfc_expr *array, gfc_expr *kind, int d, int upper,\n   gfc_expr *l, *u, *result;\n   int k;\n \n+  k = get_kind (BT_INTEGER, kind, upper ? \"UBOUND\" : \"LBOUND\",\n+\t\tgfc_default_integer_kind); \n+  if (k == -1)\n+    return &gfc_bad_expr;\n+\n+  result = gfc_get_constant_expr (BT_INTEGER, k, &array->where);\n+\n+  /* For non-variables, LBOUND(expr, DIM=n) = 1 and\n+     UBOUND(expr, DIM=n) = SIZE(expr, DIM=n).  */\n+  if (!coarray && array->expr_type != EXPR_VARIABLE)\n+    {\n+      if (upper)\n+\t{\n+\t  gfc_expr* dim = result;\n+\t  mpz_set_si (dim->value.integer, d);\n+\n+\t  result = gfc_simplify_size (array, dim, kind);\n+\t  gfc_free_expr (dim);\n+\t  if (!result)\n+\t    goto returnNull;\n+\t}\n+      else\n+\tmpz_set_si (result->value.integer, 1);\n+\n+      goto done;\n+    }\n+\n+  /* Otherwise, we have a variable expression.  */\n+  gcc_assert (array->expr_type == EXPR_VARIABLE);\n+  gcc_assert (as);\n+\n   /* The last dimension of an assumed-size array is special.  */\n   if ((!coarray && d == as->rank && as->type == AS_ASSUMED_SIZE && !upper)\n       || (coarray && d == as->rank + as->corank))\n     {\n       if (as->lower[d-1]->expr_type == EXPR_CONSTANT)\n-\treturn gfc_copy_expr (as->lower[d-1]);\n-      else\n-\treturn NULL;\n-    }\n+\t{\n+\t  gfc_free_expr (result);\n+\t  return gfc_copy_expr (as->lower[d-1]);\n+\t}\n \n-  k = get_kind (BT_INTEGER, kind, upper ? \"UBOUND\" : \"LBOUND\",\n-\t\tgfc_default_integer_kind); \n-  if (k == -1)\n-    return &gfc_bad_expr;\n+      goto returnNull;\n+    }\n \n   result = gfc_get_constant_expr (BT_INTEGER, k, &array->where);\n \n-\n   /* Then, we need to know the extent of the given dimension.  */\n   if (coarray || ref->u.ar.type == AR_FULL)\n     {\n@@ -2753,7 +2784,7 @@ simplify_bound_dim (gfc_expr *array, gfc_expr *kind, int d, int upper,\n \n       if (l->expr_type != EXPR_CONSTANT || u == NULL\n \t  || u->expr_type != EXPR_CONSTANT)\n-\treturn NULL;\n+\tgoto returnNull;\n \n       if (mpz_cmp (l->value.integer, u->value.integer) > 0)\n \t{\n@@ -2778,13 +2809,18 @@ simplify_bound_dim (gfc_expr *array, gfc_expr *kind, int d, int upper,\n \t{\n \t  if (gfc_ref_dimen_size (&ref->u.ar, d-1, &result->value.integer)\n \t      != SUCCESS)\n-\t    return NULL;\n+\t    goto returnNull;\n \t}\n       else\n \tmpz_set_si (result->value.integer, (long int) 1);\n     }\n \n+done:\n   return range_check (result, upper ? \"UBOUND\" : \"LBOUND\");\n+\n+returnNull:\n+  gfc_free_expr (result);\n+  return NULL;\n }\n \n \n@@ -2796,7 +2832,11 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n   int d;\n \n   if (array->expr_type != EXPR_VARIABLE)\n-    return NULL;\n+    {\n+      as = NULL;\n+      ref = NULL;\n+      goto done;\n+    }\n \n   /* Follow any component references.  */\n   as = array->symtree->n.sym->as;\n@@ -2815,7 +2855,7 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n \t      /* We're done because 'as' has already been set in the\n \t\t previous iteration.  */\n \t      if (!ref->next)\n-\t        goto done;\n+\t\tgoto done;\n \n \t    /* Fall through.  */\n \n@@ -2842,7 +2882,7 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n \n  done:\n \n-  if (as->type == AS_DEFERRED || as->type == AS_ASSUMED_SHAPE)\n+  if (as && (as->type == AS_DEFERRED || as->type == AS_ASSUMED_SHAPE))\n     return NULL;\n \n   if (dim == NULL)\n@@ -2853,7 +2893,7 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n       int k;\n \n       /* UBOUND(ARRAY) is not valid for an assumed-size array.  */\n-      if (upper && as->type == AS_ASSUMED_SIZE)\n+      if (upper && as && as->type == AS_ASSUMED_SIZE)\n \t{\n \t  /* An error message will be emitted in\n \t     check_assumed_size_reference (resolve.c).  */\n@@ -2904,8 +2944,8 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n \n       d = mpz_get_si (dim->value.integer);\n \n-      if (d < 1 || d > as->rank\n-\t  || (d == as->rank && as->type == AS_ASSUMED_SIZE && upper))\n+      if (d < 1 || d > array->rank\n+\t  || (d == array->rank && as && as->type == AS_ASSUMED_SIZE && upper))\n \t{\n \t  gfc_error (\"DIM argument at %L is out of bounds\", &dim->where);\n \t  return &gfc_bad_expr;\n@@ -4728,15 +4768,25 @@ gfc_simplify_shape (gfc_expr *source)\n     return gfc_get_array_expr (BT_INTEGER, gfc_default_integer_kind,\n \t\t\t       &source->where);\n \n-  if (source->expr_type != EXPR_VARIABLE)\n-    return NULL;\n-\n   result = gfc_get_array_expr (BT_INTEGER, gfc_default_integer_kind,\n \t\t\t       &source->where);\n \n-  ar = gfc_find_array_ref (source);\n-\n-  t = gfc_array_ref_shape (ar, shape);\n+  if (source->expr_type == EXPR_VARIABLE)\n+    {\n+      ar = gfc_find_array_ref (source);\n+      t = gfc_array_ref_shape (ar, shape);\n+    }\n+  else if (source->shape)\n+    {\n+      t = SUCCESS;\n+      for (n = 0; n < source->rank; n++)\n+\t{\n+\t  mpz_init (shape[n]);\n+\t  mpz_set (shape[n], source->shape[n]);\n+\t}\n+    }\n+  else\n+    t = FAILURE;\n \n   for (n = 0; n < source->rank; n++)\n     {\n@@ -4760,9 +4810,7 @@ gfc_simplify_shape (gfc_expr *source)\n \t      return NULL;\n \t    }\n \t  else\n-\t    {\n-\t      e = f;\n-\t    }\n+\t    e = f;\n \t}\n \n       gfc_constructor_append_expr (&result->value.constructor, e, NULL);\n@@ -4782,6 +4830,56 @@ gfc_simplify_size (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n   if (k == -1)\n     return &gfc_bad_expr;\n \n+  /* For unary operations, the size of the result is given by the size\n+     of the operand.  For binary ones, it's the size of the first operand\n+     unless it is scalar, then it is the size of the second.  */\n+  if (array->expr_type == EXPR_OP && !array->value.op.uop)\n+    {\n+      gfc_expr* replacement;\n+      gfc_expr* simplified;\n+\n+      switch (array->value.op.op)\n+\t{\n+\t  /* Unary operations.  */\n+\t  case INTRINSIC_NOT:\n+\t  case INTRINSIC_UPLUS:\n+\t  case INTRINSIC_UMINUS:\n+\t    replacement = array->value.op.op1;\n+\t    break;\n+\n+\t  /* Binary operations.  If any one of the operands is scalar, take\n+\t     the other one's size.  If both of them are arrays, it does not\n+\t     matter -- try to find one with known shape, if possible.  */\n+\t  default:\n+\t    if (array->value.op.op1->rank == 0)\n+\t      replacement = array->value.op.op2;\n+\t    else if (array->value.op.op2->rank == 0)\n+\t      replacement = array->value.op.op1;\n+\t    else\n+\t      {\n+\t\tsimplified = gfc_simplify_size (array->value.op.op1, dim, kind);\n+\t\tif (simplified)\n+\t\t  return simplified;\n+\n+\t\treplacement = array->value.op.op2;\n+\t      }\n+\t    break;\n+\t}\n+\n+      /* Try to reduce it directly if possible.  */\n+      simplified = gfc_simplify_size (replacement, dim, kind);\n+\n+      /* Otherwise, we build a new SIZE call.  This is hopefully at least\n+\t simpler than the original one.  */\n+      if (!simplified)\n+\tsimplified = gfc_build_intrinsic_call (\"size\", array->where, 3,\n+\t\t\t\t\t       gfc_copy_expr (replacement),\n+\t\t\t\t\t       gfc_copy_expr (dim),\n+\t\t\t\t\t       gfc_copy_expr (kind));\n+\n+      return simplified;\n+    }\n+\n   if (dim == NULL)\n     {\n       if (gfc_array_size (array, &size) == FAILURE)"}, {"sha": "88b3691ed09f2b78ae9d5a71dfbe4b8a955d3038", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dcd06ab86aef723efcc294d64e31ef159ae3c0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dcd06ab86aef723efcc294d64e31ef159ae3c0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=69dcd06ab86aef723efcc294d64e31ef159ae3c0", "patch": "@@ -1,3 +1,7 @@\n+2010-07-28  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.dg/bound_8.f90: New test.\n+\n 2010-07-28  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/45105"}, {"sha": "046fc7eb2afe3eadbf3b2cd179925948a9b0db60", "filename": "gcc/testsuite/gfortran.dg/bound_8.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dcd06ab86aef723efcc294d64e31ef159ae3c0/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dcd06ab86aef723efcc294d64e31ef159ae3c0/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_8.f90?ref=69dcd06ab86aef723efcc294d64e31ef159ae3c0", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do run }\n+! { dg-options \"-Warray-temporaries -fall-intrinsics\" }\n+\n+! Check that LBOUND/UBOUND/SIZE/SHAPE of array-expressions get simplified\n+! in certain cases.\n+! There should no array-temporaries warnings pop up, as this means that\n+! the intrinsic call has not been properly simplified.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+\n+  ! Some explicitely shaped arrays and allocatable ones.\n+  INTEGER :: a(2, 3), b(0:1, 4:6)\n+  INTEGER, ALLOCATABLE :: x(:, :), y(:, :)\n+\n+  ! Allocate to matching sizes and initialize.\n+  ALLOCATE (x(-1:0, -3:-1), y(11:12, 3))\n+  a = 0\n+  b = 1\n+  x = 2\n+  y = 3\n+\n+  ! Run the checks.  This should be simplified without array temporaries,\n+  ! and additionally correct (of course).\n+\n+  ! Shape of expressions known at compile-time.\n+  IF (ANY (LBOUND (a + b) /= 1)) CALL abort ()\n+  IF (ANY (UBOUND (2 * b) /= (/ 2, 3 /))) CALL abort ()\n+  IF (ANY (SHAPE (- b) /= (/ 2, 3 /))) CALL abort ()\n+  IF (SIZE (a ** 2) /= 6) CALL abort\n+\n+  ! Shape unknown at compile-time.\n+  IF (ANY (LBOUND (x + y) /= 1)) CALL abort ()\n+  IF (SIZE (x ** 2) /= 6) CALL abort ()\n+\n+  ! Unfortunately, the array-version of UBOUND and SHAPE keep generating\n+  ! temporary arrays for their results (not for the operation).  Thus we\n+  ! can not check SHAPE in this case and do UBOUND in the single-dimension\n+  ! version.\n+  IF (UBOUND (2 * y, 1) /= 2 .OR. UBOUND (2 * y, 2) /= 3) CALL abort ()\n+  !IF (ANY (SHAPE (- y) /= (/ 2, 3 /))) CALL abort ()\n+END PROGRAM main"}]}