{"sha": "5f3f175d79b2263927f1a4b84db71fb61a71d0e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYzZjE3NWQ3OWIyMjYzOTI3ZjFhNGI4NGRiNzFmYjYxYTcxZDBlMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-10-28T13:41:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-10-28T13:41:05Z"}, "message": "[multiple changes]\n\n2009-10-28  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Type_Conversion): Perform Integer promotion for\n\tthe operand of the unary minus and ABS operators.\n\n\t* sem_type.adb (Covers): A concurrent type and its corresponding record\n\ttype are compatible.\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Do not rewrite a 'Access\n\tattribute reference for the current instance of a protected type while\n\tanalyzing an access discriminant constraint in a component definition.\n\tSuch a reference is handled in the corresponding record's init proc,\n\twhile initializing the constrained component.\n\t* exp_ch9.adb (Expand_N_Protected_Type_Declaration): When creating the\n\tcorresponding record type, propagate components'\n\tHas_Per_Object_Constraint flag.\n\t* exp_ch3.adb (Build_Init_Procedure.Build_Init_Statements):\n\tFor a concurrent type, set up concurrent aspects before initializing\n\tcomponents with a per object constrain, because they may be controlled,\n\tand their initialization may call entries or protected subprograms of\n\tthe enclosing concurrent object.\n\n2009-10-28  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-nmsc.adb (Add_If_Not_In_List): New subprogram, for better sharing\n\tof code.\n\t(Find_Source_Dirs): resolve links if Opt.Follow_Links_For_Dirs when\n\tprocessing the directories specified explicitly in the project file.\n\nFrom-SVN: r153657", "tree": {"sha": "0ec6ddca28d1acb07647a4b52045e1a5b622bdb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ec6ddca28d1acb07647a4b52045e1a5b622bdb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f3f175d79b2263927f1a4b84db71fb61a71d0e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f3f175d79b2263927f1a4b84db71fb61a71d0e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f3f175d79b2263927f1a4b84db71fb61a71d0e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f3f175d79b2263927f1a4b84db71fb61a71d0e1/comments", "author": null, "committer": null, "parents": [{"sha": "b87971f33ef5446f674fb9f80c6ff16e82145ee1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b87971f33ef5446f674fb9f80c6ff16e82145ee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b87971f33ef5446f674fb9f80c6ff16e82145ee1"}], "stats": {"total": 527, "additions": 250, "deletions": 277}, "files": [{"sha": "7cc30bb7d4a4e60b7b36f82f8c7c7a1aaf9b1855", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3f175d79b2263927f1a4b84db71fb61a71d0e1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3f175d79b2263927f1a4b84db71fb61a71d0e1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5f3f175d79b2263927f1a4b84db71fb61a71d0e1", "patch": "@@ -1,3 +1,31 @@\n+2009-10-28  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Type_Conversion): Perform Integer promotion for\n+\tthe operand of the unary minus and ABS operators.\n+\n+\t* sem_type.adb (Covers): A concurrent type and its corresponding record\n+\ttype are compatible.\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Do not rewrite a 'Access\n+\tattribute reference for the current instance of a protected type while\n+\tanalyzing an access discriminant constraint in a component definition.\n+\tSuch a reference is handled in the corresponding record's init proc,\n+\twhile initializing the constrained component.\n+\t* exp_ch9.adb (Expand_N_Protected_Type_Declaration): When creating the\n+\tcorresponding record type, propagate components'\n+\tHas_Per_Object_Constraint flag.\n+\t* exp_ch3.adb (Build_Init_Procedure.Build_Init_Statements):\n+\tFor a concurrent type, set up concurrent aspects before initializing\n+\tcomponents with a per object constrain, because they may be controlled,\n+\tand their initialization may call entries or protected subprograms of\n+\tthe enclosing concurrent object.\n+\n+2009-10-28  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-nmsc.adb (Add_If_Not_In_List): New subprogram, for better sharing\n+\tof code.\n+\t(Find_Source_Dirs): resolve links if Opt.Follow_Links_For_Dirs when\n+\tprocessing the directories specified explicitly in the project file.\n+\n 2009-10-28  Robert Dewar  <dewar@adacore.com>\n \n \t* a-ztexio.adb, a-ztexio.ads, a-witeio.ads, a-witeio.adb,"}, {"sha": "67babece63d3b204fa878f72ffd5e9ccbece2d1a", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3f175d79b2263927f1a4b84db71fb61a71d0e1/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3f175d79b2263927f1a4b84db71fb61a71d0e1/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=5f3f175d79b2263927f1a4b84db71fb61a71d0e1", "patch": "@@ -654,10 +654,20 @@ package body Exp_Attr is\n          Make_Build_In_Place_Call_In_Anonymous_Context (Pref);\n       end if;\n \n-      --  If prefix is a protected type name, this is a reference to\n-      --  the current instance of the type.\n-\n-      if Is_Protected_Self_Reference (Pref) then\n+      --  If prefix is a protected type name, this is a reference to the\n+      --  current instance of the type. For a component definition, nothing\n+      --  to do (expansion will occur in the init proc). In other contexts,\n+      --  rewrite into reference to current instance.\n+\n+      if Is_Protected_Self_Reference (Pref)\n+           and then not\n+             (Nkind_In (Parent (N),\n+                N_Index_Or_Discriminant_Constraint,\n+                N_Discriminant_Association)\n+                and then\n+              Nkind (Parent (Parent (Parent (Parent (N)))))\n+                = N_Component_Definition)\n+      then\n          Rewrite (Pref, Concurrent_Ref (Pref));\n          Analyze (Pref);\n       end if;"}, {"sha": "9a91e2aa9bb0822827b0c733a91e3dd7a7fb3b94", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 70, "deletions": 64, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3f175d79b2263927f1a4b84db71fb61a71d0e1/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3f175d79b2263927f1a4b84db71fb61a71d0e1/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=5f3f175d79b2263927f1a4b84db71fb61a71d0e1", "patch": "@@ -2733,70 +2733,11 @@ package body Exp_Ch3 is\n             Next_Non_Pragma (Decl);\n          end loop;\n \n-         if Per_Object_Constraint_Components then\n-\n-            --  Second pass: components with per-object constraints\n-\n-            Decl := First_Non_Pragma (Component_Items (Comp_List));\n-            while Present (Decl) loop\n-               Loc := Sloc (Decl);\n-               Id := Defining_Identifier (Decl);\n-               Typ := Etype (Id);\n-\n-               if Has_Access_Constraint (Id)\n-                 and then No (Expression (Decl))\n-               then\n-                  if Has_Non_Null_Base_Init_Proc (Typ) then\n-                     Append_List_To (Statement_List,\n-                       Build_Initialization_Call (Loc,\n-                         Make_Selected_Component (Loc,\n-                           Prefix        => Make_Identifier (Loc, Name_uInit),\n-                           Selector_Name => New_Occurrence_Of (Id, Loc)),\n-                         Typ,\n-                         In_Init_Proc => True,\n-                         Enclos_Type  => Rec_Type,\n-                         Discr_Map    => Discr_Map));\n-\n-                     Clean_Task_Names (Typ, Proc_Id);\n-\n-                  elsif Component_Needs_Simple_Initialization (Typ) then\n-                     Append_List_To (Statement_List,\n-                       Build_Assignment\n-                         (Id, Get_Simple_Init_Val (Typ, N, Esize (Id))));\n-                  end if;\n-               end if;\n-\n-               Next_Non_Pragma (Decl);\n-            end loop;\n-         end if;\n-\n-         --  Process the variant part\n-\n-         if Present (Variant_Part (Comp_List)) then\n-            Alt_List := New_List;\n-            Variant := First_Non_Pragma (Variants (Variant_Part (Comp_List)));\n-            while Present (Variant) loop\n-               Loc := Sloc (Variant);\n-               Append_To (Alt_List,\n-                 Make_Case_Statement_Alternative (Loc,\n-                   Discrete_Choices =>\n-                     New_Copy_List (Discrete_Choices (Variant)),\n-                   Statements =>\n-                     Build_Init_Statements (Component_List (Variant))));\n-               Next_Non_Pragma (Variant);\n-            end loop;\n-\n-            --  The expression of the case statement which is a reference\n-            --  to one of the discriminants is replaced by the appropriate\n-            --  formal parameter of the initialization procedure.\n-\n-            Append_To (Statement_List,\n-              Make_Case_Statement (Loc,\n-                Expression =>\n-                  New_Reference_To (Discriminal (\n-                    Entity (Name (Variant_Part (Comp_List)))), Loc),\n-                Alternatives => Alt_List));\n-         end if;\n+         --  Set up tasks and protected object support. This needs to be done\n+         --  before any component with a per-object access discriminant\n+         --  constraint, or any variant part (which may contain such\n+         --  components) is initialized, because the initialization of these\n+         --  components may reference the enclosing concurrent object.\n \n          --  For a task record type, add the task create call and calls\n          --  to bind any interrupt (signal) entries.\n@@ -2898,6 +2839,71 @@ package body Exp_Ch3 is\n             end if;\n          end if;\n \n+         if Per_Object_Constraint_Components then\n+\n+            --  Second pass: components with per-object constraints\n+\n+            Decl := First_Non_Pragma (Component_Items (Comp_List));\n+            while Present (Decl) loop\n+               Loc := Sloc (Decl);\n+               Id := Defining_Identifier (Decl);\n+               Typ := Etype (Id);\n+\n+               if Has_Access_Constraint (Id)\n+                 and then No (Expression (Decl))\n+               then\n+                  if Has_Non_Null_Base_Init_Proc (Typ) then\n+                     Append_List_To (Statement_List,\n+                       Build_Initialization_Call (Loc,\n+                         Make_Selected_Component (Loc,\n+                           Prefix        => Make_Identifier (Loc, Name_uInit),\n+                           Selector_Name => New_Occurrence_Of (Id, Loc)),\n+                         Typ,\n+                         In_Init_Proc => True,\n+                         Enclos_Type  => Rec_Type,\n+                         Discr_Map    => Discr_Map));\n+\n+                     Clean_Task_Names (Typ, Proc_Id);\n+\n+                  elsif Component_Needs_Simple_Initialization (Typ) then\n+                     Append_List_To (Statement_List,\n+                       Build_Assignment\n+                         (Id, Get_Simple_Init_Val (Typ, N, Esize (Id))));\n+                  end if;\n+               end if;\n+\n+               Next_Non_Pragma (Decl);\n+            end loop;\n+         end if;\n+\n+         --  Process the variant part\n+\n+         if Present (Variant_Part (Comp_List)) then\n+            Alt_List := New_List;\n+            Variant := First_Non_Pragma (Variants (Variant_Part (Comp_List)));\n+            while Present (Variant) loop\n+               Loc := Sloc (Variant);\n+               Append_To (Alt_List,\n+                 Make_Case_Statement_Alternative (Loc,\n+                   Discrete_Choices =>\n+                     New_Copy_List (Discrete_Choices (Variant)),\n+                   Statements =>\n+                     Build_Init_Statements (Component_List (Variant))));\n+               Next_Non_Pragma (Variant);\n+            end loop;\n+\n+            --  The expression of the case statement which is a reference\n+            --  to one of the discriminants is replaced by the appropriate\n+            --  formal parameter of the initialization procedure.\n+\n+            Append_To (Statement_List,\n+              Make_Case_Statement (Loc,\n+                Expression =>\n+                  New_Reference_To (Discriminal (\n+                    Entity (Name (Variant_Part (Comp_List)))), Loc),\n+                Alternatives => Alt_List));\n+         end if;\n+\n          --  If no initializations when generated for component declarations\n          --  corresponding to this Statement_List, append a null statement\n          --  to the Statement_List to make it a valid Ada tree."}, {"sha": "6a7ea4fdb1b314616eef9b404034a1946da6497c", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3f175d79b2263927f1a4b84db71fb61a71d0e1/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3f175d79b2263927f1a4b84db71fb61a71d0e1/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=5f3f175d79b2263927f1a4b84db71fb61a71d0e1", "patch": "@@ -8056,27 +8056,25 @@ package body Exp_Ch4 is\n                 Subtype_Mark => New_Reference_To (Standard_Integer, Loc),\n                 Expression   => Relocate_Node (Right_Opnd (Operand)));\n \n-            if Nkind (Operand) = N_Op_Minus then\n-               Opnd := Make_Op_Minus (Loc, Right_Opnd => R);\n+            Opnd := New_Op_Node (Nkind (Operand), Loc);\n+            Set_Right_Opnd (Opnd, R);\n \n-            else\n+            if Nkind (Operand) in N_Binary_Op then\n                L :=\n                  Make_Type_Conversion (Loc,\n                    Subtype_Mark => New_Reference_To (Standard_Integer, Loc),\n                    Expression   => Relocate_Node (Left_Opnd (Operand)));\n \n-               Opnd := New_Op_Node (Nkind (Operand), Loc);\n-               Set_Left_Opnd (Opnd, L);\n-               Set_Right_Opnd (Opnd, R);\n+               Set_Left_Opnd  (Opnd, L);\n+            end if;\n \n-               Rewrite (N,\n-                 Make_Type_Conversion (Loc,\n-                   Subtype_Mark => Relocate_Node (Subtype_Mark (N)),\n-                   Expression   => Opnd));\n+            Rewrite (N,\n+              Make_Type_Conversion (Loc,\n+                Subtype_Mark => Relocate_Node (Subtype_Mark (N)),\n+                Expression   => Opnd));\n \n-               Analyze_And_Resolve (N, Target_Type);\n-               return;\n-            end if;\n+            Analyze_And_Resolve (N, Target_Type);\n+            return;\n          end;\n       end if;\n \n@@ -9174,10 +9172,12 @@ package body Exp_Ch4 is\n               Root_Operand_Type = Base_Type (Standard_Short_Short_Integer))\n \n            --  Test for interesting operation, which includes addition,\n-           --  division, exponentiation, multiplication, subtraction, and\n-           --  unary negation.\n+           --  division, exponentiation, multiplication, subtraction, absolute\n+           --  value and unary negation. Unary \"+\" is omitted since it is a\n+           --  no-op and thus can't overflow.\n \n-           and then Nkind_In (Operand, N_Op_Add,\n+           and then Nkind_In (Operand, N_Op_Abs,\n+                                       N_Op_Add,\n                                        N_Op_Divide,\n                                        N_Op_Expon,\n                                        N_Op_Minus,"}, {"sha": "20790526e9fc07e2bb1c8167b97edf7e1047b5a3", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3f175d79b2263927f1a4b84db71fb61a71d0e1/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3f175d79b2263927f1a4b84db71fb61a71d0e1/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=5f3f175d79b2263927f1a4b84db71fb61a71d0e1", "patch": "@@ -7821,20 +7821,23 @@ package body Exp_Ch9 is\n \n                declare\n                   Old_Comp : constant Node_Id   := Component_Definition (Priv);\n-                  Pent     : constant Entity_Id := Defining_Identifier (Priv);\n+                  Oent     : constant Entity_Id := Defining_Identifier (Priv);\n                   New_Comp : Node_Id;\n+                  Nent     : constant Entity_Id :=\n+                               Make_Defining_Identifier\n+                                 (Sloc (Oent), Chars (Oent));\n \n                begin\n                   if Present (Subtype_Indication (Old_Comp)) then\n                      New_Comp :=\n-                       Make_Component_Definition (Sloc (Pent),\n+                       Make_Component_Definition (Sloc (Oent),\n                          Aliased_Present    => False,\n                          Subtype_Indication =>\n                            New_Copy_Tree (Subtype_Indication (Old_Comp),\n                                            Discr_Map));\n                   else\n                      New_Comp :=\n-                       Make_Component_Definition (Sloc (Pent),\n+                       Make_Component_Definition (Sloc (Oent),\n                          Aliased_Present    => False,\n                          Access_Definition  =>\n                            New_Copy_Tree (Access_Definition (Old_Comp),\n@@ -7843,11 +7846,13 @@ package body Exp_Ch9 is\n \n                   New_Priv :=\n                     Make_Component_Declaration (Loc,\n-                      Defining_Identifier =>\n-                        Make_Defining_Identifier (Sloc (Pent), Chars (Pent)),\n+                      Defining_Identifier => Nent,\n                       Component_Definition => New_Comp,\n                       Expression => Expression (Priv));\n \n+                  Set_Has_Per_Object_Constraint (Nent,\n+                    Has_Per_Object_Constraint (Oent));\n+\n                   Append_To (Cdecls, New_Priv);\n                end;\n "}, {"sha": "064cbb69a7b83322458d33a8693498c33359049a", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 105, "deletions": 187, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3f175d79b2263927f1a4b84db71fb61a71d0e1/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3f175d79b2263927f1a4b84db71fb61a71d0e1/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=5f3f175d79b2263927f1a4b84db71fb61a71d0e1", "patch": "@@ -4707,119 +4707,80 @@ package body Prj.Nmsc is\n          Removed  : Boolean := False)\n       is\n          Directory : constant String := Get_Name_String (From);\n-         Element   : String_Element;\n+\n+         procedure Add_If_Not_In_List\n+           (Path_Id         : Name_Id;\n+            Display_Path_Id : Name_Id);\n+         --  Add the directory Path_Id to the list of source_dirs if not\n+         --  already in the list\n \n          procedure Recursive_Find_Dirs (Path : Name_Id);\n          --  Find all the subdirectories (recursively) of Path and add them\n          --  to the list of source directories of the project.\n \n-         -------------------------\n-         -- Recursive_Find_Dirs --\n-         -------------------------\n-\n-         procedure Recursive_Find_Dirs (Path : Name_Id) is\n-            Dir     : Dir_Type;\n-            Name    : String (1 .. 250);\n-            Last    : Natural;\n-            List    : String_List_Id;\n-            Prev    : String_List_Id;\n-            Rank_List : Number_List_Index;\n-            Prev_Rank : Number_List_Index;\n-            Element : String_Element;\n-            Found   : Boolean := False;\n-\n-            Non_Canonical_Path : Name_Id := No_Name;\n-            Canonical_Path     : Name_Id := No_Name;\n-\n-            The_Path : constant String :=\n-                         Normalize_Pathname\n-                           (Get_Name_String (Path),\n-                            Directory     =>\n-                              Get_Name_String (Project.Directory.Display_Name),\n-                            Resolve_Links => Opt.Follow_Links_For_Dirs) &\n-                         Directory_Separator;\n-\n-            The_Path_Last : constant Natural :=\n-                              Compute_Directory_Last (The_Path);\n-\n+         ------------------------\n+         -- Add_If_Not_In_List --\n+         ------------------------\n+\n+         procedure Add_If_Not_In_List\n+           (Path_Id         : Name_Id;\n+            Display_Path_Id : Name_Id)\n+         is\n+            List       : String_List_Id;\n+            Prev       : String_List_Id;\n+            Rank_List  : Number_List_Index;\n+            Prev_Rank  : Number_List_Index;\n+            Element    : String_Element;\n          begin\n-            Name_Len := The_Path_Last - The_Path'First + 1;\n-            Name_Buffer (1 .. Name_Len) :=\n-              The_Path (The_Path'First .. The_Path_Last);\n-            Non_Canonical_Path := Name_Find;\n-            Canonical_Path :=\n-              Name_Id (Canonical_Case_File_Name (Non_Canonical_Path));\n-\n-            --  To avoid processing the same directory several times, check\n-            --  if the directory is already in Recursive_Dirs. If it is, then\n-            --  there is nothing to do, just return. If it is not, put it there\n-            --  and continue recursive processing.\n-\n-            if not Removed then\n-               if Recursive_Dirs.Get (Visited, Canonical_Path) then\n-                  return;\n-               else\n-                  Recursive_Dirs.Set (Visited, Canonical_Path, True);\n-               end if;\n-            end if;\n-\n-            --  Check if directory is already in list\n-\n-            List := Project.Source_Dirs;\n-            Prev := Nil_String;\n-            Rank_List := Project.Source_Dir_Ranks;\n+            Prev      := Nil_String;\n             Prev_Rank := No_Number_List;\n+            List      := Project.Source_Dirs;\n+            Rank_List := Project.Source_Dir_Ranks;\n+\n             while List /= Nil_String loop\n                Element := Data.Tree.String_Elements.Table (List);\n-\n-               if Element.Value /= No_Name then\n-                  Found := Element.Value = Canonical_Path;\n-                  exit when Found;\n-               end if;\n-\n+               exit when Element.Value = Path_Id;\n                Prev := List;\n                List := Element.Next;\n                Prev_Rank := Rank_List;\n-               Rank_List := Data.Tree.Number_Lists.Table (Rank_List).Next;\n+               Rank_List := Data.Tree.Number_Lists.Table (Prev_Rank).Next;\n             end loop;\n \n-            --  If directory is not already in list, put it there\n+            --  The directory is in the list if List is not Nil_String\n \n-            if (not Removed) and (not Found) then\n+            if not Removed and then List = Nil_String then\n                if Current_Verbosity = High then\n-                  Write_Str  (\"   \");\n-                  Write_Line (The_Path (The_Path'First .. The_Path_Last));\n+                  Write_Str  (\"   Adding Source Dir=\");\n+                  Write_Line (Get_Name_String (Path_Id));\n                end if;\n \n                String_Element_Table.Increment_Last (Data.Tree.String_Elements);\n                Element :=\n-                 (Value         => Canonical_Path,\n-                  Display_Value => Non_Canonical_Path,\n+                 (Value         => Path_Id,\n+                  Index         => 0,\n+                  Display_Value => Display_Path_Id,\n                   Location      => No_Location,\n                   Flag          => False,\n-                  Next          => Nil_String,\n-                  Index         => 0);\n+                  Next          => Nil_String);\n \n                Number_List_Table.Increment_Last (Data.Tree.Number_Lists);\n \n-               --  Case of first source directory\n-\n                if Last_Source_Dir = Nil_String then\n+\n+                  --  This is the first source directory\n+\n                   Project.Source_Dirs :=\n                     String_Element_Table.Last (Data.Tree.String_Elements);\n                   Project.Source_Dir_Ranks :=\n                     Number_List_Table.Last (Data.Tree.Number_Lists);\n \n-                  --  Here we already have source directories\n-\n                else\n-                  --  Link the previous last to the new one\n+                  --  We already have source directories, link the previous\n+                  --  last to the new one.\n \n-                  Data.Tree.String_Elements.Table\n-                    (Last_Source_Dir).Next :=\n+                  Data.Tree.String_Elements.Table (Last_Source_Dir).Next :=\n                     String_Element_Table.Last (Data.Tree.String_Elements);\n-                  Data.Tree.Number_Lists.Table\n-                    (Last_Src_Dir_Rank).Next :=\n+                  Data.Tree.Number_Lists.Table (Last_Src_Dir_Rank).Next :=\n                     Number_List_Table.Last (Data.Tree.Number_Lists);\n \n                end if;\n@@ -4834,19 +4795,70 @@ package body Prj.Nmsc is\n                Data.Tree.Number_Lists.Table (Last_Src_Dir_Rank) :=\n                  (Number => Rank, Next => No_Number_List);\n \n-            elsif Removed and Found then\n+            elsif List /= Nil_String then\n+               --  Remove source dir, if present\n+\n                if Prev = Nil_String then\n                   Project.Source_Dirs :=\n                     Data.Tree.String_Elements.Table (List).Next;\n                   Project.Source_Dir_Ranks :=\n                     Data.Tree.Number_Lists.Table (Rank_List).Next;\n+\n                else\n                   Data.Tree.String_Elements.Table (Prev).Next :=\n                     Data.Tree.String_Elements.Table (List).Next;\n                   Data.Tree.Number_Lists.Table (Prev_Rank).Next :=\n                     Data.Tree.Number_Lists.Table (Rank_List).Next;\n                end if;\n             end if;\n+         end Add_If_Not_In_List;\n+\n+         -------------------------\n+         -- Recursive_Find_Dirs --\n+         -------------------------\n+\n+         procedure Recursive_Find_Dirs (Path : Name_Id) is\n+            Dir     : Dir_Type;\n+            Name    : String (1 .. 250);\n+            Last    : Natural;\n+            Non_Canonical_Path : Name_Id := No_Name;\n+            Canonical_Path     : Name_Id := No_Name;\n+\n+            The_Path : constant String :=\n+                         Normalize_Pathname\n+                           (Get_Name_String (Path),\n+                            Directory     =>\n+                              Get_Name_String (Project.Directory.Display_Name),\n+                            Resolve_Links => Opt.Follow_Links_For_Dirs) &\n+                         Directory_Separator;\n+\n+            The_Path_Last : constant Natural :=\n+                              Compute_Directory_Last (The_Path);\n+\n+         begin\n+            Name_Len := The_Path_Last - The_Path'First + 1;\n+            Name_Buffer (1 .. Name_Len) :=\n+              The_Path (The_Path'First .. The_Path_Last);\n+            Non_Canonical_Path := Name_Find;\n+            Canonical_Path :=\n+              Name_Id (Canonical_Case_File_Name (Non_Canonical_Path));\n+\n+            --  To avoid processing the same directory several times, check\n+            --  if the directory is already in Recursive_Dirs. If it is, then\n+            --  there is nothing to do, just return. If it is not, put it there\n+            --  and continue recursive processing.\n+\n+            if not Removed then\n+               if Recursive_Dirs.Get (Visited, Canonical_Path) then\n+                  return;\n+               else\n+                  Recursive_Dirs.Set (Visited, Canonical_Path, True);\n+               end if;\n+            end if;\n+\n+            Add_If_Not_In_List\n+              (Path_Id         => Canonical_Path,\n+               Display_Path_Id => Non_Canonical_Path);\n \n             --  Now look for subdirectories. We do that even when this\n             --  directory is already in the list, because some of its\n@@ -4945,7 +4957,8 @@ package body Prj.Nmsc is\n                                Directory =>\n                                  Get_Name_String\n                                    (Project.Directory.Display_Name),\n-                               Resolve_Links  => False,\n+                               Resolve_Links  =>\n+                                 Opt.Follow_Links_For_Dirs,\n                                Case_Sensitive => True);\n \n             begin\n@@ -4987,10 +5000,6 @@ package body Prj.Nmsc is\n          else\n             declare\n                Path_Name  : Path_Information;\n-               List       : String_List_Id;\n-               Prev       : String_List_Id;\n-               Rank_List  : Number_List_Index;\n-               Prev_Rank  : Number_List_Index;\n                Dir_Exists : Boolean;\n \n             begin\n@@ -5020,7 +5029,13 @@ package body Prj.Nmsc is\n                else\n                   declare\n                      Path              : constant String :=\n-                                           Get_Name_String (Path_Name.Name);\n+                        Normalize_Pathname\n+                         (Name           => Get_Name_String (Path_Name.Name),\n+                          Directory      =>\n+                            Get_Name_String (Project.Directory.Name),\n+                          Resolve_Links  => Opt.Follow_Links_For_Dirs,\n+                          Case_Sensitive => True);\n+\n                      Last_Path         : constant Natural :=\n                                            Compute_Directory_Last (Path);\n                      Path_Id           : Name_Id;\n@@ -5036,113 +5051,16 @@ package body Prj.Nmsc is\n                      Name_Len := 0;\n                      Add_Str_To_Name_Buffer (Path (Path'First .. Last_Path));\n                      Path_Id := Name_Find;\n+\n                      Name_Len := 0;\n                      Add_Str_To_Name_Buffer\n                        (Display_Path\n                           (Display_Path'First .. Last_Display_Path));\n                      Display_Path_Id := Name_Find;\n \n-                     --  Check if the directory is already in the list\n-\n-                     Prev := Nil_String;\n-                     Prev_Rank := No_Number_List;\n-\n-                     --  Look for source dir in current list\n-\n-                     List := Project.Source_Dirs;\n-                     Rank_List := Project.Source_Dir_Ranks;\n-                     while List /= Nil_String loop\n-                        Element := Data.Tree.String_Elements.Table (List);\n-                        exit when Element.Value = Path_Id;\n-                        Prev := List;\n-                        List := Element.Next;\n-                        Prev_Rank := Rank_List;\n-                        Rank_List :=\n-                          Data.Tree.Number_Lists.Table (Prev_Rank).Next;\n-                     end loop;\n-\n-                     --  The directory is in the list if List is not Nil_String\n-\n-                     if not Removed then\n-\n-                        --  As it is an existing directory, we add it to the\n-                        --  list of directories, if not already in the list.\n-\n-                        if List = Nil_String then\n-                           String_Element_Table.Increment_Last\n-                             (Data.Tree.String_Elements);\n-                           Element :=\n-                             (Value         => Path_Id,\n-                              Index         => 0,\n-                              Display_Value => Display_Path_Id,\n-                              Location      => No_Location,\n-                              Flag          => False,\n-                              Next          => Nil_String);\n-                           Number_List_Table.Increment_Last\n-                             (Data.Tree.Number_Lists);\n-\n-                           if Last_Source_Dir = Nil_String then\n-\n-                              --  This is the first source directory\n-\n-                              Project.Source_Dirs :=\n-                                String_Element_Table.Last\n-                                  (Data.Tree.String_Elements);\n-                              Project.Source_Dir_Ranks :=\n-                                Number_List_Table.Last\n-                                  (Data.Tree.Number_Lists);\n-\n-                           else\n-                              --  We already have source directories, link the\n-                              --  previous last to the new one.\n-\n-                              Data.Tree.String_Elements.Table\n-                                (Last_Source_Dir).Next :=\n-                                String_Element_Table.Last\n-                                  (Data.Tree.String_Elements);\n-                              Data.Tree.Number_Lists.Table\n-                                (Last_Src_Dir_Rank).Next :=\n-                                Number_List_Table.Last\n-                                  (Data.Tree.Number_Lists);\n-\n-                           end if;\n-\n-                           --  And register this source directory as the new\n-                           --  last.\n-\n-                           Last_Source_Dir :=\n-                             String_Element_Table.Last\n-                               (Data.Tree.String_Elements);\n-                           Data.Tree.String_Elements.Table\n-                             (Last_Source_Dir) := Element;\n-                           Last_Src_Dir_Rank :=\n-                             Number_List_Table.Last\n-                               (Data.Tree.Number_Lists);\n-                           Data.Tree.Number_Lists.Table\n-                             (Last_Src_Dir_Rank) :=\n-                             (Number => Rank, Next => No_Number_List);\n-                        end if;\n-\n-                     else\n-                        --  Remove source dir, if present\n-\n-                        if List /= Nil_String then\n-                           --  Source dir was found, remove it from the list\n-\n-                           if Prev = Nil_String then\n-                              Project.Source_Dirs :=\n-                                Data.Tree.String_Elements.Table (List).Next;\n-                              Project.Source_Dir_Ranks :=\n-                                Data.Tree.Number_Lists.Table (Rank_List).Next;\n-\n-                           else\n-                              Data.Tree.String_Elements.Table (Prev).Next :=\n-                                Data.Tree.String_Elements.Table (List).Next;\n-                              Data.Tree.Number_Lists.Table (Prev_Rank).Next :=\n-                                Data.Tree.Number_Lists.Table (Rank_List).Next;\n-                           end if;\n-                        end if;\n-                     end if;\n+                     Add_If_Not_In_List\n+                       (Path_Id         => Path_Id,\n+                        Display_Path_Id => Display_Path_Id);\n                   end;\n                end if;\n             end;"}, {"sha": "6f3e36935fb001b95fe28b690de8938f1c87d693", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3f175d79b2263927f1a4b84db71fb61a71d0e1/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3f175d79b2263927f1a4b84db71fb61a71d0e1/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=5f3f175d79b2263927f1a4b84db71fb61a71d0e1", "patch": "@@ -791,7 +791,7 @@ package body Sem_Type is\n                      or else Scope (T1) /= Scope (T2));\n          end if;\n \n-      --  Literals are compatible with types in  a given \"class\"\n+      --  Literals are compatible with types in a given \"class\"\n \n       elsif     (T2 = Universal_Integer and then Is_Integer_Type (T1))\n         or else (T2 = Universal_Real    and then Is_Real_Type (T1))\n@@ -970,6 +970,12 @@ package body Sem_Type is\n       then\n          return Covers (Corresponding_Remote_Type (T2), T1);\n \n+      elsif Is_Record_Type (T1) and then Is_Concurrent_Type (T2) then\n+         return Covers (T1, Corresponding_Record_Type (T2));\n+\n+      elsif Is_Concurrent_Type (T1) and then Is_Record_Type (T2) then\n+         return Covers (Corresponding_Record_Type (T1), T2);\n+\n       elsif Ekind (T2) = E_Access_Attribute_Type\n         and then (Ekind (BT1) = E_General_Access_Type\n                     or else Ekind (BT1) = E_Access_Type)"}]}