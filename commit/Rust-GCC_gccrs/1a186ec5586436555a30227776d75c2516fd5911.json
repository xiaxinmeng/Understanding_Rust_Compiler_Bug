{"sha": "1a186ec5586436555a30227776d75c2516fd5911", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWExODZlYzU1ODY0MzY1NTVhMzAyMjc3NzZkNzVjMjUxNmZkNTkxMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-08-11T04:16:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-11T04:16:07Z"}, "message": "builtins.def (BUILT_IN_STACK_ALLOC): Remove.\n\n        * builtins.def (BUILT_IN_STACK_ALLOC): Remove.\n        * builtins.c (expand_builtin) <BUILT_IN_STACK_ALLOC>: Remove.\n        * dwarf2out.c (loc_descriptor): Handle PARALLEL here ...\n        (add_location_or_const_value_attribute): ... not here.  Use\n        loc_descriptor_from_tree if possible.\n        (loc_descriptor_from_tree_1): Rename from loc_descriptor_from_tree.\n        Simplify address handling.  Handle DECL_VALUE_EXPR.  Handle register\n        values specially.\n        (loc_descriptor_from_tree): New.  Update callers.\n        * expr.c (expand_var): Ignore DECL_VALUE_EXPR variables.\n        * gimplify.c (gimplify_decl_expr): Lower variable sized types to\n        pointer plus dereference.  Set DECL_VALUE_EXPR.  Set save_stack.\n        (gimplify_call_expr): Do not recognize BUILT_IN_STACK_ALLOC\n        and BUILT_IN_STACK_RESTORE.\n        (gimplify_expr): Lower DECL_VALUE_EXPR decls.\n        * stmt.c (expand_stack_alloc): Remove.\n        * tree-mudflap.c (mx_register_decls): Don't look for\n        BUILT_IN_STACK_ALLOC.\n        * tree-nested.c (convert_local_reference): Likewise.\n        * tree.h (DECL_VALUE_EXPR): New.\nada/\n        * utils.c (gnat_install_builtins): Remove __builtin_stack_alloc,\n        add __builtin_alloca.\nfortran/\n        * f95-lang.c (gfc_init_builtin_functions): Remove\n         __builtin_stack_alloc, add __builtin_alloca.\n        * trans-array.c (gfc_trans_auto_array_allocation): Use DECL_EXPR.\n        * trans-decl.c (gfc_trans_auto_character_variable): Likewise.\n\nFrom-SVN: r85794", "tree": {"sha": "e57fc8a325147e3d2f9c065e1b28d63cdcb6c70a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e57fc8a325147e3d2f9c065e1b28d63cdcb6c70a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a186ec5586436555a30227776d75c2516fd5911", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a186ec5586436555a30227776d75c2516fd5911", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a186ec5586436555a30227776d75c2516fd5911", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a186ec5586436555a30227776d75c2516fd5911/comments", "author": null, "committer": null, "parents": [{"sha": "89f1a7022ee2b62d67948797837c2a683bfa4995", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89f1a7022ee2b62d67948797837c2a683bfa4995", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89f1a7022ee2b62d67948797837c2a683bfa4995"}], "stats": {"total": 564, "additions": 208, "deletions": 356}, "files": [{"sha": "ffa4aeeaa88edafe74100446605dfec5cfcdf6ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a186ec5586436555a30227776d75c2516fd5911/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a186ec5586436555a30227776d75c2516fd5911/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a186ec5586436555a30227776d75c2516fd5911", "patch": "@@ -1,3 +1,26 @@\n+2004-08-10  Richard Henderson  <rth@redhat.com>\n+\n+\t* builtins.def (BUILT_IN_STACK_ALLOC): Remove.\n+\t* builtins.c (expand_builtin) <BUILT_IN_STACK_ALLOC>: Remove.\n+\t* dwarf2out.c (loc_descriptor): Handle PARALLEL here ...\n+\t(add_location_or_const_value_attribute): ... not here.  Use\n+\tloc_descriptor_from_tree if possible.\n+\t(loc_descriptor_from_tree_1): Rename from loc_descriptor_from_tree.\n+\tSimplify address handling.  Handle DECL_VALUE_EXPR.  Handle register\n+\tvalues specially.\n+\t(loc_descriptor_from_tree): New.  Update callers.\n+\t* expr.c (expand_var): Ignore DECL_VALUE_EXPR variables.\n+\t* gimplify.c (gimplify_decl_expr): Lower variable sized types to\n+\tpointer plus dereference.  Set DECL_VALUE_EXPR.  Set save_stack.\n+\t(gimplify_call_expr): Do not recognize BUILT_IN_STACK_ALLOC\n+\tand BUILT_IN_STACK_RESTORE.\n+\t(gimplify_expr): Lower DECL_VALUE_EXPR decls.\n+\t* stmt.c (expand_stack_alloc): Remove.\n+\t* tree-mudflap.c (mx_register_decls): Don't look for\n+\tBUILT_IN_STACK_ALLOC.\n+\t* tree-nested.c (convert_local_reference): Likewise.\n+\t* tree.h (DECL_VALUE_EXPR): New.\n+\n 2004-08-10  Richard Henderson  <rth@redhat.com>\n \n \t* stor-layout.c (round_up): Check for 0/1 before dividing."}, {"sha": "9cb2dfdb4a91cef2e65d38dacfa3c340d5bf41bd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1a186ec5586436555a30227776d75c2516fd5911", "patch": "@@ -1,3 +1,8 @@\n+2004-08-10  Richard Henderson  <rth@redhat.com>\n+\n+\t* utils.c (gnat_install_builtins): Remove __builtin_stack_alloc,\n+\tadd __builtin_alloca.\n+\n 2004-08-10  Richard Henderson  <rth@redhat.com>\n \n \t* config-lang.in (boot_language): Yes."}, {"sha": "4f2362981c5f003903ae4d360ffd9585416f9556", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=1a186ec5586436555a30227776d75c2516fd5911", "patch": "@@ -481,6 +481,9 @@ gnat_install_builtins ()\n   gnat_define_builtin (\"__builtin_clzll\", ftype, BUILT_IN_CLZLL, \"clzll\",\n \t\t       true);\n \n+  /* The init_trampoline and adjust_trampoline builtins aren't used directly.\n+     They are inserted during lowering of nested functions.  */\n+\n   tmp = tree_cons (NULL_TREE, ptr_void_type_node, void_list_node);\n   tmp = tree_cons (NULL_TREE, ptr_void_type_node, tmp);\n   tmp = tree_cons (NULL_TREE, ptr_void_type_node, tmp);\n@@ -493,21 +496,24 @@ gnat_install_builtins ()\n   gnat_define_builtin (\"__builtin_adjust_trampoline\", ftype,\n \t\t       BUILT_IN_ADJUST_TRAMPOLINE, \"adjust_trampoline\", true);\n \n-  tmp = tree_cons (NULL_TREE, ptr_void_type_node, void_list_node);\n-  tmp = tree_cons (NULL_TREE, size_type_node, void_list_node);\n-  ftype = build_function_type (ptr_void_type_node, tmp);\n-  gnat_define_builtin (\"__builtin_stack_alloc\", ftype, BUILT_IN_STACK_ALLOC,\n-\t\t       \"stack_alloc\", false);\n+  /* The stack_save, stack_restore, and alloca builtins aren't used directly.\n+     They are inserted during gimplification to implement variable sized stack\n+     allocation.  */\n \n-  /* The stack_save and stack_restore builtins aren't used directly.  They\n-     are inserted during gimplification to implement stack_alloc calls.  */\n   ftype = build_function_type (ptr_void_type_node, void_list_node);\n   gnat_define_builtin (\"__builtin_stack_save\", ftype, BUILT_IN_STACK_SAVE,\n \t\t       \"stack_save\", false);\n+\n   tmp = tree_cons (NULL_TREE, ptr_void_type_node, void_list_node);\n   ftype = build_function_type (void_type_node, tmp);\n   gnat_define_builtin (\"__builtin_stack_restore\", ftype,\n \t\t       BUILT_IN_STACK_RESTORE, \"stack_restore\", false);\n+\n+  tmp = tree_cons (NULL_TREE, size_type_node, void_list_node);\n+  ftype = build_function_type (ptr_void_type_node, tmp);\n+  gnat_define_builtin (\"__builtin_alloca\", ftype, BUILT_IN_ALLOCA,\n+\t\t       \"alloca\", false);\n+\n }\n \n /* Create the predefined scalar types such as `integer_type_node' needed"}, {"sha": "fb852ff0b55d4db45ce107ae461ad364a3b3d1f1", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1a186ec5586436555a30227776d75c2516fd5911", "patch": "@@ -5756,11 +5756,6 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \treturn target;\n       break;\n \n-    case BUILT_IN_STACK_ALLOC:\n-      expand_stack_alloc (TREE_VALUE (arglist),\n-\t\t\t  TREE_VALUE (TREE_CHAIN (arglist)));\n-      return const0_rtx;\n-\n     case BUILT_IN_STACK_SAVE:\n       return expand_stack_save ();\n "}, {"sha": "1cfbf7129994efc06cf6252207a1def53db2c3ea", "filename": "gcc/builtins.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=1a186ec5586436555a30227776d75c2516fd5911", "patch": "@@ -607,7 +607,6 @@ DEF_GCC_BUILTIN        (BUILT_IN_RETURN, \"return\", BT_FN_VOID_PTR, ATTR_NORETURN\n DEF_GCC_BUILTIN        (BUILT_IN_RETURN_ADDRESS, \"return_address\", BT_FN_PTR_UINT, ATTR_NULL)\n DEF_GCC_BUILTIN        (BUILT_IN_SAVEREGS, \"saveregs\", BT_FN_PTR_VAR, ATTR_NULL)\n DEF_GCC_BUILTIN        (BUILT_IN_SETJMP, \"setjmp\", BT_FN_INT_PTR, ATTR_NULL)\n-DEF_GCC_BUILTIN        (BUILT_IN_STACK_ALLOC, \"stack_alloc\", BT_FN_VOID_PTR_SIZE, ATTR_NULL)\n DEF_GCC_BUILTIN        (BUILT_IN_STACK_SAVE, \"stack_save\", BT_FN_PTR, ATTR_NULL)\n DEF_GCC_BUILTIN        (BUILT_IN_STACK_RESTORE, \"stack_restore\", BT_FN_VOID_PTR, ATTR_NULL)\n DEF_GCC_BUILTIN        (BUILT_IN_STDARG_START, \"stdarg_start\", BT_FN_VOID_VALIST_REF_VAR, ATTR_NULL)"}, {"sha": "242a653b278bcba7c7ebb7a680d6271aba7539d7", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 97, "deletions": 137, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=1a186ec5586436555a30227776d75c2516fd5911", "patch": "@@ -3907,7 +3907,8 @@ static int is_based_loc (rtx);\n static dw_loc_descr_ref mem_loc_descriptor (rtx, enum machine_mode mode, bool);\n static dw_loc_descr_ref concat_loc_descriptor (rtx, rtx);\n static dw_loc_descr_ref loc_descriptor (rtx, bool);\n-static dw_loc_descr_ref loc_descriptor_from_tree (tree, int);\n+static dw_loc_descr_ref loc_descriptor_from_tree_1 (tree, int);\n+static dw_loc_descr_ref loc_descriptor_from_tree (tree);\n static HOST_WIDE_INT ceiling (HOST_WIDE_INT, unsigned int);\n static tree field_type (tree);\n static unsigned int simple_type_align_in_bits (tree);\n@@ -8805,34 +8806,38 @@ loc_descriptor (rtx rtl, bool can_use_fbreg)\n       if (GET_CODE (XEXP (rtl, 1)) != PARALLEL)\n \t{\n \t  loc_result = loc_descriptor (XEXP (XEXP (rtl, 1), 0), can_use_fbreg);\n+\t  break;\n \t}\n-      /* Multiple parts.  */\n-      else\n-\t{\n-\t  rtvec par_elems = XVEC (XEXP (rtl, 1), 0);\n-\t  int num_elem = GET_NUM_ELEM (par_elems);\n-\t  enum machine_mode mode;\n-\t  int i;\n \n-\t  /* Create the first one, so we have something to add to.  */\n-\t  loc_result = loc_descriptor (XEXP (RTVEC_ELT (par_elems, 0), 0),\n-\t\t\t\t       can_use_fbreg);\n-\t  mode = GET_MODE (XEXP (RTVEC_ELT (par_elems, 0), 0));\n-\t  add_loc_descr (&loc_result,\n-\t\t\t new_loc_descr (DW_OP_piece, GET_MODE_SIZE (mode), 0));\n-\t  for (i = 1; i < num_elem; i++)\n-\t    {\n-\t      dw_loc_descr_ref temp;\n+      rtl = XEXP (rtl, 1);\n+      /* FALLTHRU */\n \n-\t      temp = loc_descriptor (XEXP (RTVEC_ELT (par_elems, i), 0),\n+    case PARALLEL:\n+      {\n+\trtvec par_elems = XVEC (rtl, 0);\n+\tint num_elem = GET_NUM_ELEM (par_elems);\n+\tenum machine_mode mode;\n+\tint i;\n+\n+\t/* Create the first one, so we have something to add to.  */\n+\tloc_result = loc_descriptor (XEXP (RTVEC_ELT (par_elems, 0), 0),\n \t\t\t\t     can_use_fbreg);\n-\t      add_loc_descr (&loc_result, temp);\n-\t      mode = GET_MODE (XEXP (RTVEC_ELT (par_elems, i), 0));\n-\t      add_loc_descr (&loc_result,\n-\t\t\t     new_loc_descr (DW_OP_piece,\n-\t\t\t\t\t    GET_MODE_SIZE (mode), 0));\n-\t    }\n-\t}\n+\tmode = GET_MODE (XEXP (RTVEC_ELT (par_elems, 0), 0));\n+\tadd_loc_descr (&loc_result,\n+\t\t       new_loc_descr (DW_OP_piece, GET_MODE_SIZE (mode), 0));\n+\tfor (i = 1; i < num_elem; i++)\n+\t  {\n+\t    dw_loc_descr_ref temp;\n+\n+\t    temp = loc_descriptor (XEXP (RTVEC_ELT (par_elems, i), 0),\n+\t\t\t\t   can_use_fbreg);\n+\t    add_loc_descr (&loc_result, temp);\n+\t    mode = GET_MODE (XEXP (RTVEC_ELT (par_elems, i), 0));\n+\t    add_loc_descr (&loc_result,\n+\t\t\t   new_loc_descr (DW_OP_piece,\n+\t\t\t\t\t  GET_MODE_SIZE (mode), 0));\n+\t  }\n+      }\n       break;\n \n     default:\n@@ -8843,15 +8848,16 @@ loc_descriptor (rtx rtl, bool can_use_fbreg)\n }\n \n /* Similar, but generate the descriptor from trees instead of rtl.  This comes\n-   up particularly with variable length arrays.  If ADDRESSP is nonzero, we are\n-   looking for an address.  Otherwise, we return a value.  If we can't make a\n-   descriptor, return 0.  */\n+   up particularly with variable length arrays.  WANT_ADDRESS is 2 if this is\n+   a top-level invocation of loc_descriptor_from_tree; is 1 if this is not a\n+   top-level invocation, and we require the address of LOC; is 0 if we require\n+   the value of LOC.  */\n \n static dw_loc_descr_ref\n-loc_descriptor_from_tree (tree loc, int addressp)\n+loc_descriptor_from_tree_1 (tree loc, int want_address)\n {\n   dw_loc_descr_ref ret, ret1;\n-  int indirect_p = 0;\n+  int have_address = 0;\n   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (loc));\n   enum dwarf_location_atom op;\n \n@@ -8882,19 +8888,12 @@ loc_descriptor_from_tree (tree loc, int addressp)\n       return 0;\n \n     case ADDR_EXPR:\n-      /* We can support this only if we can look through conversions and\n-\t find an INDIRECT_EXPR.  */\n-      for (loc = TREE_OPERAND (loc, 0);\n-\t   TREE_CODE (loc) == CONVERT_EXPR || TREE_CODE (loc) == NOP_EXPR\n-\t   || TREE_CODE (loc) == NON_LVALUE_EXPR\n-\t   || TREE_CODE (loc) == VIEW_CONVERT_EXPR\n-\t   || TREE_CODE (loc) == SAVE_EXPR;\n-\t   loc = TREE_OPERAND (loc, 0))\n-\t;\n+      /* If we already want an address, there's nothing we can do.  */\n+      if (want_address)\n+\treturn 0;\n \n-       return (TREE_CODE (loc) == INDIRECT_REF\n-\t       ? loc_descriptor_from_tree (TREE_OPERAND (loc, 0), addressp)\n-\t       : 0);\n+      /* Otherwise, process the argument and look for the address.  */\n+      return loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), 1);\n \n     case VAR_DECL:\n       if (DECL_THREAD_LOCAL (loc))\n@@ -8928,55 +8927,71 @@ loc_descriptor_from_tree (tree loc, int addressp)\n \t  ret1 = new_loc_descr (DW_OP_GNU_push_tls_address, 0, 0);\n \t  add_loc_descr (&ret, ret1);\n \n-\t  indirect_p = 1;\n+\t  have_address = 1;\n \t  break;\n \t}\n-      /* Fall through.  */\n+      /* FALLTHRU */\n \n     case PARM_DECL:\n+      if (DECL_VALUE_EXPR (loc))\n+\treturn loc_descriptor_from_tree_1 (DECL_VALUE_EXPR (loc), want_address);\n+      /* FALLTHRU */\n+\n     case RESULT_DECL:\n       {\n \trtx rtl = rtl_for_decl_location (loc);\n \n \tif (rtl == NULL_RTX)\n \t  return 0;\n+        else if (GET_CODE (rtl) == CONST_INT)\n+\t  {\n+\t    HOST_WIDE_INT val = INTVAL (rtl);\n+\t    if (TYPE_UNSIGNED (TREE_TYPE (loc)))\n+\t      val &= GET_MODE_MASK (DECL_MODE (loc));\n+\t    ret = int_loc_descriptor (val);\n+\t  }\n+\telse if (GET_CODE (rtl) == CONST_STRING)\n+\t  return 0;\n \telse if (CONSTANT_P (rtl))\n \t  {\n \t    ret = new_loc_descr (DW_OP_addr, 0, 0);\n \t    ret->dw_loc_oprnd1.val_class = dw_val_class_addr;\n \t    ret->dw_loc_oprnd1.v.val_addr = rtl;\n-\t    indirect_p = 1;\n \t  }\n \telse\n \t  {\n-\t    enum machine_mode mode = GET_MODE (rtl);\n+\t    enum machine_mode mode;\n+\n+\t    /* Certain constructs can only be represented at top-level.  */\n+\t    if (want_address == 2)\n+\t      return loc_descriptor (rtl, true);\n \n+\t    mode = GET_MODE (rtl);\n \t    if (MEM_P (rtl))\n \t      {\n-\t\tindirect_p = 1;\n \t\trtl = XEXP (rtl, 0);\n+\t\thave_address = 1;\n \t      }\n-\n \t    ret = mem_loc_descriptor (rtl, mode, true);\n \t  }\n       }\n       break;\n \n     case INDIRECT_REF:\n-      ret = loc_descriptor_from_tree (TREE_OPERAND (loc, 0), 0);\n-      indirect_p = 1;\n+      ret = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), 0);\n+      have_address = 1;\n       break;\n \n     case COMPOUND_EXPR:\n-      return loc_descriptor_from_tree (TREE_OPERAND (loc, 1), addressp);\n+      return loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 1), want_address);\n \n     case NOP_EXPR:\n     case CONVERT_EXPR:\n     case NON_LVALUE_EXPR:\n     case VIEW_CONVERT_EXPR:\n     case SAVE_EXPR:\n     case MODIFY_EXPR:\n-      return loc_descriptor_from_tree (TREE_OPERAND (loc, 0), addressp);\n+      return loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), want_address);\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n@@ -8994,21 +9009,18 @@ loc_descriptor_from_tree (tree loc, int addressp)\n \tif (obj == loc)\n \t  return 0;\n \n-\tret = loc_descriptor_from_tree (obj, 1);\n+\tret = loc_descriptor_from_tree_1 (obj, 1);\n \tif (ret == 0\n \t    || bitpos % BITS_PER_UNIT != 0 || bitsize % BITS_PER_UNIT != 0)\n \t  return 0;\n \n \tif (offset != NULL_TREE)\n \t  {\n \t    /* Variable offset.  */\n-\t    add_loc_descr (&ret, loc_descriptor_from_tree (offset, 0));\n+\t    add_loc_descr (&ret, loc_descriptor_from_tree_1 (offset, 0));\n \t    add_loc_descr (&ret, new_loc_descr (DW_OP_plus, 0, 0));\n \t  }\n \n-\tif (!addressp)\n-\t  indirect_p = 1;\n-\n \tbytepos = bitpos / BITS_PER_UNIT;\n \tif (bytepos > 0)\n \t  add_loc_descr (&ret, new_loc_descr (DW_OP_plus_uconst, bytepos, 0));\n@@ -9017,6 +9029,8 @@ loc_descriptor_from_tree (tree loc, int addressp)\n \t    add_loc_descr (&ret, int_loc_descriptor (bytepos));\n \t    add_loc_descr (&ret, new_loc_descr (DW_OP_plus, 0, 0));\n \t  }\n+\n+\thave_address = 1;\n \tbreak;\n       }\n \n@@ -9033,15 +9047,12 @@ loc_descriptor_from_tree (tree loc, int addressp)\n \trtx rtl = lookup_constant_def (loc);\n \tenum machine_mode mode;\n \n-\tif (!MEM_P (rtl))\n+\tif (!rtl || !MEM_P (rtl))\n \t  return 0;\n \tmode = GET_MODE (rtl);\n \trtl = XEXP (rtl, 0);\n-\n-\trtl = targetm.delegitimize_address (rtl);\n-\n-\tindirect_p = 1;\n \tret = mem_loc_descriptor (rtl, mode, true);\n+\thave_address = 1;\n \tbreak;\n       }\n \n@@ -9096,7 +9107,7 @@ loc_descriptor_from_tree (tree loc, int addressp)\n       if (TREE_CODE (TREE_OPERAND (loc, 1)) == INTEGER_CST\n \t  && host_integerp (TREE_OPERAND (loc, 1), 0))\n \t{\n-\t  ret = loc_descriptor_from_tree (TREE_OPERAND (loc, 0), 0);\n+\t  ret = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), 0);\n \t  if (ret == 0)\n \t    return 0;\n \n@@ -9148,8 +9159,8 @@ loc_descriptor_from_tree (tree loc, int addressp)\n       goto do_binop;\n \n     do_binop:\n-      ret = loc_descriptor_from_tree (TREE_OPERAND (loc, 0), 0);\n-      ret1 = loc_descriptor_from_tree (TREE_OPERAND (loc, 1), 0);\n+      ret = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), 0);\n+      ret1 = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 1), 0);\n       if (ret == 0 || ret1 == 0)\n \treturn 0;\n \n@@ -9171,7 +9182,7 @@ loc_descriptor_from_tree (tree loc, int addressp)\n       goto do_unop;\n \n     do_unop:\n-      ret = loc_descriptor_from_tree (TREE_OPERAND (loc, 0), 0);\n+      ret = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), 0);\n       if (ret == 0)\n \treturn 0;\n \n@@ -9187,20 +9198,20 @@ loc_descriptor_from_tree (tree loc, int addressp)\n         loc = build3 (COND_EXPR, TREE_TYPE (loc),\n \t\t      build2 (code, integer_type_node,\n \t\t\t      TREE_OPERAND (loc, 0), TREE_OPERAND (loc, 1)),\n-                     TREE_OPERAND (loc, 1), TREE_OPERAND (loc, 0));\n+                      TREE_OPERAND (loc, 1), TREE_OPERAND (loc, 0));\n       }\n \n       /* ... fall through ...  */\n \n     case COND_EXPR:\n       {\n \tdw_loc_descr_ref lhs\n-\t  = loc_descriptor_from_tree (TREE_OPERAND (loc, 1), 0);\n+\t  = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 1), 0);\n \tdw_loc_descr_ref rhs\n-\t  = loc_descriptor_from_tree (TREE_OPERAND (loc, 2), 0);\n+\t  = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 2), 0);\n \tdw_loc_descr_ref bra_node, jump_node, tmp;\n \n-\tret = loc_descriptor_from_tree (TREE_OPERAND (loc, 0), 0);\n+\tret = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), 0);\n \tif (ret == 0 || lhs == 0 || rhs == 0)\n \t  return 0;\n \n@@ -9236,11 +9247,11 @@ loc_descriptor_from_tree (tree loc, int addressp)\n     }\n \n   /* Show if we can't fill the request for an address.  */\n-  if (addressp && indirect_p == 0)\n+  if (want_address && !have_address)\n     return 0;\n \n   /* If we've got an address and don't want one, dereference.  */\n-  if (!addressp && indirect_p > 0)\n+  if (!want_address && have_address)\n     {\n       HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (loc));\n \n@@ -9257,6 +9268,12 @@ loc_descriptor_from_tree (tree loc, int addressp)\n   return ret;\n }\n \n+static inline dw_loc_descr_ref\n+loc_descriptor_from_tree (tree loc)\n+{\n+  return loc_descriptor_from_tree_1 (loc, 2);\n+}\n+\n /* Given a value, round it up to the lowest multiple of `boundary'\n    which is not less than the value itself.  */\n \n@@ -10072,72 +10089,15 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n     }\n \n   rtl = rtl_for_decl_location (decl);\n-  if (rtl == NULL_RTX)\n-    return;\n-\n-  switch (GET_CODE (rtl))\n+  if (rtl && (CONSTANT_P (rtl) || GET_CODE (rtl) == CONST_STRING))\n     {\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST_VECTOR:\n-    case CONST_STRING:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    case CONST:\n-    case PLUS:\n-      /* DECL_RTL could be (plus (reg ...) (const_int ...)) */\n       add_const_value_attribute (die, rtl);\n-      break;\n-\n-    case MEM:\n-      if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL (decl))\n-\t{\n-\t  /* Need loc_descriptor_from_tree since that's where we know\n-\t     how to handle TLS variables.  Want the object's address\n-\t     since the top-level DW_AT_location assumes such.  See\n-\t     the confusion in loc_descriptor for reference.  */\n-\t  descr = loc_descriptor_from_tree (decl, 1);\n-\t}\n-      else\n-\t{\n-\tcase REG:\n-\tcase SUBREG:\n-\tcase CONCAT:\n-\t  descr = loc_descriptor (rtl, true);\n-\t}\n-      add_AT_location_description (die, attr, descr);\n-      break;\n-\n-    case PARALLEL:\n-      {\n-\trtvec par_elems = XVEC (rtl, 0);\n-\tint num_elem = GET_NUM_ELEM (par_elems);\n-\tenum machine_mode mode;\n-\tint i;\n-\n-\t/* Create the first one, so we have something to add to.  */\n-\tdescr = loc_descriptor (XEXP (RTVEC_ELT (par_elems, 0), 0), true);\n-\tmode = GET_MODE (XEXP (RTVEC_ELT (par_elems, 0), 0));\n-\tadd_loc_descr (&descr,\n-\t\t       new_loc_descr (DW_OP_piece, GET_MODE_SIZE (mode), 0));\n-\tfor (i = 1; i < num_elem; i++)\n-\t  {\n-\t    dw_loc_descr_ref temp;\n-\n-\t    temp = loc_descriptor (XEXP (RTVEC_ELT (par_elems, i), 0), true);\n-\t    add_loc_descr (&descr, temp);\n-\t    mode = GET_MODE (XEXP (RTVEC_ELT (par_elems, i), 0));\n-\t    add_loc_descr (&descr,\n-\t\t\t   new_loc_descr (DW_OP_piece,\n-\t\t\t\t\t  GET_MODE_SIZE (mode), 0));\n-\t  }\n-      }\n-      add_AT_location_description (die, DW_AT_location, descr);\n-      break;\n-\n-    default:\n-      abort ();\n+      return;\n     }\n+\n+  descr = loc_descriptor_from_tree (decl);\n+  if (descr)\n+    add_AT_location_description (die, attr, descr);\n }\n \n /* If we don't have a copy of this variable in memory for some reason (such\n@@ -10254,7 +10214,7 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr, tree b\n \tdw_die_ref ctx, decl_die;\n \tdw_loc_descr_ref loc;\n \n-\tloc = loc_descriptor_from_tree (bound, 0);\n+\tloc = loc_descriptor_from_tree (bound);\n \tif (loc == NULL)\n \t  break;\n \n@@ -11388,7 +11348,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \n       if (cfun->static_chain_decl)\n \tadd_AT_location_description (subr_die, DW_AT_static_link,\n-\t\t loc_descriptor_from_tree (cfun->static_chain_decl, 0));\n+\t\t loc_descriptor_from_tree (cfun->static_chain_decl));\n     }\n \n   /* Now output descriptions of the arguments for this function. This gets"}, {"sha": "282bb9af57d9233e11839e92525cc18b47088d81", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1a186ec5586436555a30227776d75c2516fd5911", "patch": "@@ -6008,20 +6008,8 @@ expand_var (tree var)\n       ? !TREE_ASM_WRITTEN (var)\n       : !DECL_RTL_SET_P (var))\n     {\n-      if (TREE_CODE (var) == VAR_DECL && DECL_DEFER_OUTPUT (var))\n-\t{\n-\t  /* Prepare a mem & address for the decl.  */\n-\t  rtx x;\n-\n-\t  if (TREE_STATIC (var))\n-\t    abort ();\n-\n-\t  x = gen_rtx_MEM (DECL_MODE (var),\n-\t\t\t   gen_reg_rtx (Pmode));\n-\n-\t  set_mem_attributes (x, var, 1);\n-\t  SET_DECL_RTL (var, x);\n-\t}\n+      if (TREE_CODE (var) == VAR_DECL && DECL_VALUE_EXPR (var))\n+\t/* Should be ignored.  */;\n       else if (lang_hooks.expand_decl (var))\n \t/* OK.  */;\n       else if (TREE_CODE (var) == VAR_DECL && !TREE_STATIC (var))"}, {"sha": "b45197dd191bebe146b68020d6c6d970ae03ef28", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1a186ec5586436555a30227776d75c2516fd5911", "patch": "@@ -1,3 +1,10 @@\n+2004-08-10  Richard Henderson  <rth@redhat.com>\n+\n+\t* f95-lang.c (gfc_init_builtin_functions): Remove\n+\t __builtin_stack_alloc, add __builtin_alloca.\n+\t* trans-array.c (gfc_trans_auto_array_allocation): Use DECL_EXPR.\n+\t* trans-decl.c (gfc_trans_auto_character_variable): Likewise.\n+\n 2004-08-10  Paul Brook  <paul@codesourcery.com>\n \n \t* trans-io.c (transfer_expr): Handle pointters."}, {"sha": "3e8320c3f44de2847b5d61f71a8e51ab6dbb3ba7", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=1a186ec5586436555a30227776d75c2516fd5911", "patch": "@@ -794,21 +794,23 @@ gfc_init_builtin_functions (void)\n   gfc_define_builtin (\"__builtin_adjust_trampoline\", ftype,\n \t\t      BUILT_IN_ADJUST_TRAMPOLINE, \"adjust_trampoline\", true);\n \n-  tmp = tree_cons (NULL_TREE, pvoid_type_node, void_list_node);\n-  tmp = tree_cons (NULL_TREE, size_type_node, void_list_node);\n-  ftype = build_function_type (pvoid_type_node, tmp);\n-  gfc_define_builtin (\"__builtin_stack_alloc\", ftype, BUILT_IN_STACK_ALLOC,\n-\t\t      \"stack_alloc\", false);\n+  /* The stack_save, stack_restore, and alloca builtins aren't used directly.\n+     They are inserted during gimplification to implement variable sized\n+     stack allocation.  */\n \n-  /* The stack_save and stack_restore builtins aren't used directly.  They\n-     are inserted during gimplification to implement stack_alloc calls.  */\n   ftype = build_function_type (pvoid_type_node, void_list_node);\n   gfc_define_builtin (\"__builtin_stack_save\", ftype, BUILT_IN_STACK_SAVE,\n \t\t      \"stack_save\", false);\n+\n   tmp = tree_cons (NULL_TREE, pvoid_type_node, void_list_node);\n   ftype = build_function_type (void_type_node, tmp);\n   gfc_define_builtin (\"__builtin_stack_restore\", ftype, BUILT_IN_STACK_RESTORE,\n \t\t      \"stack_restore\", false);\n+\n+  tmp = tree_cons (NULL_TREE, size_type_node, void_list_node);\n+  ftype = build_function_type (pvoid_type_node, tmp);\n+  gfc_define_builtin (\"__builtin_alloca\", ftype, BUILT_IN_ALLOCA,\n+\t\t      \"alloca\", false);\n }\n \n #undef DEFINE_MATH_BUILTIN"}, {"sha": "e267ebf2287d528a8d4ccff7eaebf5b3ceec0f05", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=1a186ec5586436555a30227776d75c2516fd5911", "patch": "@@ -2926,15 +2926,9 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n     {\n       gfc_trans_init_string_length (sym->ts.cl, &block);\n \n-      DECL_DEFER_OUTPUT (decl) = 1;\n-\n-      /* Generate code to allocate the automatic variable.  It will be\n-\t freed automatically.  */\n-      tmp = gfc_build_addr_expr (NULL, decl);\n-      args = gfc_chainon_list (NULL_TREE, tmp);\n-      args = gfc_chainon_list (args, sym->ts.cl->backend_decl);\n-      tmp = gfc_build_function_call (built_in_decls[BUILT_IN_STACK_ALLOC],\n-\t\t\t\t     args);\n+      /* Emit a DECL_EXPR for this variable, which will cause the\n+\t gimplifier to allocate stoage, and all that good stuff.  */\n+      tmp = build (DECL_EXPR, TREE_TYPE (decl), decl);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n "}, {"sha": "4710e150fa0178728e32d3ea46168e4b980bd126", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=1a186ec5586436555a30227776d75c2516fd5911", "patch": "@@ -1626,7 +1626,6 @@ gfc_trans_auto_character_variable (gfc_symbol * sym, tree fnbody)\n {\n   stmtblock_t body;\n   tree decl;\n-  tree args;\n   tree tmp;\n \n   assert (sym->backend_decl);\n@@ -1639,23 +1638,11 @@ gfc_trans_auto_character_variable (gfc_symbol * sym, tree fnbody)\n \n   decl = sym->backend_decl;\n \n-  DECL_DEFER_OUTPUT (decl) = 1;\n-\n-  /* Since we don't use a DECL_STMT or equivalent, we have to deal\n-     with getting these gimplified.  But we can't gimplify it yet since\n-     we're still generating statements.\n-\n-     ??? This should be cleaned up and handled like other front ends.  */\n-  gfc_add_expr_to_block (&body, save_expr (DECL_SIZE (decl)));\n-  gfc_add_expr_to_block (&body, save_expr (DECL_SIZE_UNIT (decl)));\n-\n-  /* Generate code to allocate the automatic variable.  It will be freed\n-     automatically.  */\n-  tmp = gfc_build_addr_expr (NULL, decl);\n-  args = gfc_chainon_list (NULL_TREE, tmp);\n-  args = gfc_chainon_list (args, sym->ts.cl->backend_decl);\n-  tmp = gfc_build_function_call (built_in_decls[BUILT_IN_STACK_ALLOC], args);\n+  /* Emit a DECL_EXPR for this variable, which will cause the\n+     gimplifier to allocate stoage, and all that good stuff.  */\n+  tmp = build (DECL_EXPR, TREE_TYPE (decl), decl);\n   gfc_add_expr_to_block (&body, tmp);\n+\n   gfc_add_expr_to_block (&body, fnbody);\n   return gfc_finish_block (&body);\n }"}, {"sha": "8a8679b54de83e0d34bb94c403b75090e2335e4d", "filename": "gcc/gimplify.c", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=1a186ec5586436555a30227776d75c2516fd5911", "patch": "@@ -976,20 +976,34 @@ gimplify_decl_expr (tree *stmt_p)\n \t  /* This is a variable-sized decl.  Simplify its size and mark it\n \t     for deferred expansion.  Note that mudflap depends on the format\n \t     of the emitted code: see mx_register_decls().  */\n-\t  tree t, args;\n+\t  tree t, args, addr, ptr_type;\n \n \t  gimplify_type_sizes (TREE_TYPE (decl), stmt_p);\n \t  gimplify_one_sizepos (&DECL_SIZE (decl), stmt_p);\n \t  gimplify_one_sizepos (&DECL_SIZE_UNIT (decl), stmt_p);\n \n+\t  /* All occurences of this decl in final gimplified code will be\n+\t     replaced by indirection.  Setting DECL_VALUE_EXPR does two\n+\t     things: First, it lets the rest of the gimplifier know what\n+\t     replacement to use.  Second, it lets the debug info know \n+\t     where to find the value.  */\n+\t  ptr_type = build_pointer_type (TREE_TYPE (decl));\n+\t  addr = create_tmp_var (ptr_type, get_name (decl));\n+\t  DECL_IGNORED_P (addr) = 0;\n+\t  t = build_fold_indirect_ref (addr);\n+\t  DECL_VALUE_EXPR (decl) = t;\n+\n \t  args = tree_cons (NULL, DECL_SIZE_UNIT (decl), NULL);\n-\t  t = build_fold_addr_expr (decl);\n-\t  args = tree_cons (NULL, t, args);\n-\t  t = implicit_built_in_decls[BUILT_IN_STACK_ALLOC];\n+\t  t = built_in_decls[BUILT_IN_ALLOCA];\n \t  t = build_function_call_expr (t, args);\n+\t  t = fold_convert (ptr_type, t);\n+\t  t = build2 (MODIFY_EXPR, void_type_node, addr, t);\n \n \t  gimplify_and_add (t, stmt_p);\n-\t  DECL_DEFER_OUTPUT (decl) = 1;\n+\n+\t  /* Indicate that we need to restore the stack level when the\n+\t     enclosing BIND_EXPR is exited.  */\n+\t  gimplify_ctxp->save_stack = true;\n \t}\n \n       if (init && init != error_mark_node)\n@@ -1834,20 +1848,7 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n   decl = get_callee_fndecl (*expr_p);\n   if (decl && DECL_BUILT_IN (decl))\n     {\n-      tree new;\n-\n-      /* If it is allocation of stack, record the need to restore the memory\n-\t when the enclosing bind_expr is exited.  */\n-      if (DECL_FUNCTION_CODE (decl) == BUILT_IN_STACK_ALLOC)\n-\tgimplify_ctxp->save_stack = true;\n-\n-      /* If it is restore of the stack, reset it, since it means we are\n-\t regimplifying the bind_expr.  Note that we use the fact that\n-\t for try_finally_expr, try part is processed first.  */\n-      if (DECL_FUNCTION_CODE (decl) == BUILT_IN_STACK_RESTORE)\n-\tgimplify_ctxp->save_stack = false;\n-\n-      new = simplify_builtin (*expr_p, !want_value);\n+      tree new = simplify_builtin (*expr_p, !want_value);\n \n       if (new && new != *expr_p)\n \t{\n@@ -3781,9 +3782,19 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t\tabort ();\n #endif\n \t      ret = GS_ERROR;\n+\t      break;\n \t    }\n-\t  else\n-\t    ret = GS_ALL_DONE;\n+\n+\t  /* If this is a local variable sized decl, it must be accessed\n+\t     indirectly.  Perform that substitution.  */\n+\t  if (DECL_VALUE_EXPR (tmp))\n+\t    {\n+\t      *expr_p = unshare_expr (DECL_VALUE_EXPR (tmp));\n+\t      ret = GS_OK;\n+\t      break;\n+\t    }\n+\n+\t  ret = GS_ALL_DONE;\n \t  break;\n \n \tcase SSA_NAME:"}, {"sha": "86d4fe98dd36e79829bc32a6e6c29f238e361117", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=1a186ec5586436555a30227776d75c2516fd5911", "patch": "@@ -2042,40 +2042,6 @@ expand_decl (tree decl)\n     }\n }\n \f\n-/* Emit code to allocate T_SIZE bytes of dynamic stack space for ALLOC.  */\n-void\n-expand_stack_alloc (tree alloc, tree t_size)\n-{\n-  rtx address, dest, size;\n-  tree var, type;\n-\n-  if (TREE_CODE (alloc) != ADDR_EXPR)\n-    abort ();\n-  var = TREE_OPERAND (alloc, 0);\n-  if (TREE_CODE (var) != VAR_DECL)\n-    abort ();\n-\n-  type = TREE_TYPE (var);\n-\n-  /* Compute the variable's size, in bytes.  */\n-  size = expand_expr (t_size, NULL_RTX, VOIDmode, 0);\n-  free_temp_slots ();\n-\n-  /* Allocate space on the stack for the variable.  */\n-  address = XEXP (DECL_RTL (var), 0);\n-  dest = allocate_dynamic_stack_space (size, address, TYPE_ALIGN (type));\n-  if (dest != address)\n-    emit_move_insn (address, dest);\n-\n-  /* Indicate the alignment we actually gave this variable.  */\n-#ifdef STACK_BOUNDARY\n-  DECL_ALIGN (var) = STACK_BOUNDARY;\n-#else\n-  DECL_ALIGN (var) = BIGGEST_ALIGNMENT;\n-#endif\n-  DECL_USER_ALIGN (var) = 0;\n-}\n-\n /* Emit code to save the current value of stack.  */\n rtx\n expand_stack_save (void)"}, {"sha": "4f8e1742f2d694e391b6fad97d6fe69972b7f4b8", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 3, "deletions": 67, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=1a186ec5586436555a30227776d75c2516fd5911", "patch": "@@ -897,80 +897,16 @@ mx_register_decls (tree decl, tree *stmt_list)\n           && TREE_ADDRESSABLE (decl)\n           /* The type of the variable must be complete.  */\n           && COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (decl))\n+\t  /* The decl hasn't been decomposed somehow.  */\n+\t  && DECL_VALUE_EXPR (decl) == NULL\n           /* Don't process the same decl twice.  */\n           && ! mf_marked_p (decl))\n         {\n           tree size = NULL_TREE, variable_name;\n           tree unregister_fncall, unregister_fncall_params;\n           tree register_fncall, register_fncall_params;\n \n-          if (DECL_DEFER_OUTPUT (decl))\n-            {\n-              /* Oh no ... it's probably a variable-length array (VLA).\n-                 The size and address cannot be computed by merely\n-                 looking at the DECL.  See gimplify_decl_stmt for the\n-                 method by which VLA declarations turn into calls to\n-                 BUILT_IN_STACK_ALLOC.  We assume that multiple\n-                 VLAs declared later in the same block get allocation \n-                 code later than the others.  */\n-              tree stack_alloc_call = NULL_TREE;\n-\n-              while(! tsi_end_p (initially_stmts))\n-                {\n-                  tree t = tsi_stmt (initially_stmts);\n-\n-                  tree call = NULL_TREE;\n-                  if (TREE_CODE (t) == CALL_EXPR)\n-                    call = t;\n-                  else if (TREE_CODE (t) == MODIFY_EXPR &&\n-                           TREE_CODE (TREE_OPERAND (t, 1)) == CALL_EXPR)\n-                    call = TREE_OPERAND (t, 1);\n-                  else if (TREE_CODE (t) == TRY_FINALLY_EXPR)\n-                    {\n-                      /* We hope that this is the try/finally block sometimes\n-                         constructed by gimplify_bind_expr() for a BIND_EXPR\n-                         that contains VLAs.  This very naive recursion\n-                         appears to be sufficient.  */\n-                      initially_stmts = tsi_start (TREE_OPERAND (t, 0));\n-                    }\n-\n-                  if (call != NULL_TREE)\n-                    {\n-                      if (TREE_CODE (TREE_OPERAND(call, 0)) == ADDR_EXPR &&\n-                          TREE_OPERAND (TREE_OPERAND (call, 0), 0) ==\n-                                implicit_built_in_decls [BUILT_IN_STACK_ALLOC])\n-                        {\n-                          tree stack_alloc_args = TREE_OPERAND (call, 1);\n-                          tree stack_alloc_op1 = TREE_VALUE (stack_alloc_args);\n-                          tree stack_alloc_op2 = TREE_VALUE (TREE_CHAIN (stack_alloc_args));\n-                          \n-                          if (TREE_CODE (stack_alloc_op1) == ADDR_EXPR &&\n-                              TREE_OPERAND (stack_alloc_op1, 0) == decl)\n-                            {\n-                              /* Got it! */\n-                              size = stack_alloc_op2;\n-                              stack_alloc_call = call;\n-                              /* Advance iterator to point past this allocation call.  */\n-                              tsi_next (&initially_stmts);\n-                              break;\n-                            }\n-                        }\n-                    }\n-\n-                  tsi_next (&initially_stmts);\n-                }\n-\n-              if (stack_alloc_call == NULL_TREE)\n-                {\n-                  warning (\"mudflap cannot handle variable-sized declaration `%s'\",\n-                         IDENTIFIER_POINTER (DECL_NAME (decl)));\n-                  break;\n-                }\n-            }\n-          else\n-            {\n-              size = convert (size_type_node, TYPE_SIZE_UNIT (TREE_TYPE (decl)));\n-            }\n+\t  size = convert (size_type_node, TYPE_SIZE_UNIT (TREE_TYPE (decl)));\n \n           /* (& VARIABLE, sizeof (VARIABLE), __MF_TYPE_STACK) */\n           unregister_fncall_params ="}, {"sha": "7ae506e8558f0c2ad82401ceb6b384c1bb5100d9", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=1a186ec5586436555a30227776d75c2516fd5911", "patch": "@@ -855,7 +855,7 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n {\n   struct walk_stmt_info *wi = data;\n   struct nesting_info *info = wi->info;\n-  tree t = *tp, field, x, y;\n+  tree t = *tp, field, x;\n \n   switch (TREE_CODE (t))\n     {\n@@ -909,40 +909,6 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n       }\n       break;\n \n-    case CALL_EXPR:\n-      *walk_subtrees = 1;\n-\n-      /* Ready for some fun?  We need to recognize\n-\t    __builtin_stack_alloc (&x, n)\n-\t and insert\n-\t    FRAME.x = &x\n-\t after that.  X should have use_pointer_in_frame set.  We can't\n-\t do this any earlier, since we can't meaningfully evaluate &x.  */\n-\n-      x = get_callee_fndecl (t);\n-      if (!x || DECL_BUILT_IN_CLASS (x) != BUILT_IN_NORMAL)\n-\tbreak;\n-      if (DECL_FUNCTION_CODE (x) != BUILT_IN_STACK_ALLOC)\n-\tbreak;\n-      t = TREE_VALUE (TREE_OPERAND (t, 1));\n-      if (TREE_CODE (t) != ADDR_EXPR)\n-\tabort ();\n-      t = TREE_OPERAND (t, 0);\n-      if (TREE_CODE (t) != VAR_DECL)\n-\tabort ();\n-      field = lookup_field_for_decl (info, t, NO_INSERT);\n-      if (!field)\n-\tbreak;\n-      if (!use_pointer_in_frame (t))\n-\tabort ();\n-\n-      x = build_addr (t);\n-      y = get_frame_field (info, info->context, field, &wi->tsi);\n-      x = build (MODIFY_EXPR, void_type_node, y, x);\n-      SET_EXPR_LOCUS (x, EXPR_LOCUS (tsi_stmt (wi->tsi)));\n-      tsi_link_after (&wi->tsi, x, TSI_SAME_STMT);\n-      break;\n-\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n     case COMPONENT_REF:"}, {"sha": "0d6d5608310ab4e19ed7ddcc57e419d8afd6b461", "filename": "gcc/tree.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a186ec5586436555a30227776d75c2516fd5911/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1a186ec5586436555a30227776d75c2516fd5911", "patch": "@@ -2027,6 +2027,13 @@ struct tree_binfo GTY (())\n    entire function.  */\n #define DECL_SAVED_TREE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.saved_tree)\n \n+/* In a VAR_DECL or PARM_DECL, the location at which the value may be found,\n+   if transformations have made this more complicated than evaluating the\n+   decl itself.  This should only be used for debugging; once this field has\n+   been set, the decl itself may not legitimately appear in the function.  */\n+#define DECL_VALUE_EXPR(NODE) \\\n+  (TREE_CHECK2 (NODE, VAR_DECL, PARM_DECL)->decl.saved_tree)\n+\n /* List of FUNCTION_DECLs inlined into this function's body.  */\n #define DECL_INLINED_FNS(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.inlined_fns)\n \n@@ -2278,7 +2285,8 @@ struct tree_decl GTY(())\n     int GTY ((tag (\"VAR_DECL\"))) i;\n   } GTY ((desc (\"TREE_CODE((tree) &(%0))\"))) u2;\n \n-  /* In a FUNCTION_DECL, this is DECL_SAVED_TREE.  */\n+  /* In a FUNCTION_DECL, this is DECL_SAVED_TREE.\n+     In a VAR_DECL or PARM_DECL, this is DECL_VALUE_EXPR.  */\n   tree saved_tree;\n \n   /* In a FUNCTION_DECL, these are function data which is to be kept\n@@ -3353,7 +3361,6 @@ extern void expand_label (tree);\n extern void expand_goto (tree);\n extern void expand_asm (tree, int);\n \n-extern void expand_stack_alloc (tree, tree);\n extern rtx expand_stack_save (void);\n extern void expand_stack_restore (tree);\n extern void expand_return (tree);"}]}