{"sha": "2fe0a2080e33f946fc685c1a0518e438f642d8f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZlMGEyMDgwZTMzZjk0NmZjNjg1YzFhMDUxOGU0MzhmNjQyZDhmOQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2016-01-04T12:27:08Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2016-01-04T12:27:08Z"}, "message": "re PR c/68908 (inefficient code for _Atomic operations)\n\n\tPR c/68908\n\t* c-typeck.c (build_atomic_assign): Improve commentary.  Add\n\toptimization to use __atomic_fetch_* built-in if possible.\n\n\t* gcc.dg/atomic/c11-atomic-exec-6.c: New test.\n\t* gcc.dg/atomic/c11-atomic-exec-7.c: New test.\n\t* gcc.dg/atomic/stdatomic-op-5.c: New test.\n\nFrom-SVN: r232052", "tree": {"sha": "afd3c3142238b8e1226bab23d98cc2a9cf3b1cd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afd3c3142238b8e1226bab23d98cc2a9cf3b1cd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fe0a2080e33f946fc685c1a0518e438f642d8f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fe0a2080e33f946fc685c1a0518e438f642d8f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fe0a2080e33f946fc685c1a0518e438f642d8f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fe0a2080e33f946fc685c1a0518e438f642d8f9/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8db883aa82562867eba7e8a82b34ed70204bad6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8db883aa82562867eba7e8a82b34ed70204bad6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8db883aa82562867eba7e8a82b34ed70204bad6b"}], "stats": {"total": 358, "additions": 343, "deletions": 15}, "files": [{"sha": "b4714dce6623cde1a0bbcfc982acc56477c4895f", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe0a2080e33f946fc685c1a0518e438f642d8f9/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe0a2080e33f946fc685c1a0518e438f642d8f9/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=2fe0a2080e33f946fc685c1a0518e438f642d8f9", "patch": "@@ -1,3 +1,9 @@\n+2016-01-04  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/68908\n+\t* c-typeck.c (build_atomic_assign): Improve commentary.  Add\n+\toptimization to use __atomic_fetch_* built-in if possible.\n+\n 2015-12-23  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* c-parser.c (c_parser_oacc_clause_use_device): Merge function"}, {"sha": "06050b2616aac35528aac9add3ed0e4ed21e7a46", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 101, "deletions": 15, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe0a2080e33f946fc685c1a0518e438f642d8f9/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe0a2080e33f946fc685c1a0518e438f642d8f9/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=2fe0a2080e33f946fc685c1a0518e438f642d8f9", "patch": "@@ -3698,9 +3698,9 @@ pointer_diff (location_t loc, tree op0, tree op1)\n   return convert (restype, result);\n }\n \f\n-/* Expand atomic compound assignments into an approriate sequence as\n-   specified by the C11 standard section 6.5.16.2.   \n-    given \n+/* Expand atomic compound assignments into an appropriate sequence as\n+   specified by the C11 standard section 6.5.16.2.\n+\n        _Atomic T1 E1\n        T2 E2\n        E1 op= E2\n@@ -3732,26 +3732,25 @@ pointer_diff (location_t loc, tree op0, tree op1)\n done:\n   feupdateenv (&fenv);\n \n-  Also note that the compiler is simply issuing the generic form of\n-  the atomic operations.  This requires temp(s) and has their address\n-  taken.  The atomic processing is smart enough to figure out when the\n-  size of an object can utilize a lock-free version, and convert the\n-  built-in call to the appropriate lock-free routine.  The optimizers\n-  will then dispose of any temps that are no longer required, and\n-  lock-free implementations are utilized as long as there is target\n-  support for the required size.\n+  The compiler will issue the __atomic_fetch_* built-in when possible,\n+  otherwise it will generate the generic form of the atomic operations.\n+  This requires temp(s) and has their address taken.  The atomic processing\n+  is smart enough to figure out when the size of an object can utilize\n+  a lock-free version, and convert the built-in call to the appropriate\n+  lock-free routine.  The optimizers will then dispose of any temps that\n+  are no longer required, and lock-free implementations are utilized as\n+  long as there is target support for the required size.\n \n   If the operator is NOP_EXPR, then this is a simple assignment, and\n   an __atomic_store is issued to perform the assignment rather than\n-  the above loop.\n-\n-*/\n+  the above loop.  */\n \n /* Build an atomic assignment at LOC, expanding into the proper\n    sequence to store LHS MODIFYCODE= RHS.  Return a value representing\n-   the result of the operation, unless RETURN_OLD_P in which case\n+   the result of the operation, unless RETURN_OLD_P, in which case\n    return the old value of LHS (this is only for postincrement and\n    postdecrement).  */\n+\n static tree\n build_atomic_assign (location_t loc, tree lhs, enum tree_code modifycode,\n \t\t     tree rhs, bool return_old_p)\n@@ -3818,6 +3817,93 @@ build_atomic_assign (location_t loc, tree lhs, enum tree_code modifycode,\n       return build2 (COMPOUND_EXPR, nonatomic_lhs_type, compound_stmt, val);\n     }\n \n+  /* Attempt to implement the atomic operation as an __atomic_fetch_* or\n+     __atomic_*_fetch built-in rather than a CAS loop.  atomic_bool type\n+     isn't applicable for such builtins.  ??? Do we want to handle enums?  */\n+  if ((TREE_CODE (lhs_type) == INTEGER_TYPE || POINTER_TYPE_P (lhs_type))\n+      && TREE_CODE (rhs_type) == INTEGER_TYPE)\n+    {\n+      built_in_function fncode;\n+      switch (modifycode)\n+\t{\n+\tcase PLUS_EXPR:\n+\tcase POINTER_PLUS_EXPR:\n+\t  fncode = (return_old_p\n+\t\t    ? BUILT_IN_ATOMIC_FETCH_ADD_N\n+\t\t    : BUILT_IN_ATOMIC_ADD_FETCH_N);\n+\t  break;\n+\tcase MINUS_EXPR:\n+\t  fncode = (return_old_p\n+\t\t    ? BUILT_IN_ATOMIC_FETCH_SUB_N\n+\t\t    : BUILT_IN_ATOMIC_SUB_FETCH_N);\n+\t  break;\n+\tcase BIT_AND_EXPR:\n+\t  fncode = (return_old_p\n+\t\t    ? BUILT_IN_ATOMIC_FETCH_AND_N\n+\t\t    : BUILT_IN_ATOMIC_AND_FETCH_N);\n+\t  break;\n+\tcase BIT_IOR_EXPR:\n+\t  fncode = (return_old_p\n+\t\t    ? BUILT_IN_ATOMIC_FETCH_OR_N\n+\t\t    : BUILT_IN_ATOMIC_OR_FETCH_N);\n+\t  break;\n+\tcase BIT_XOR_EXPR:\n+\t  fncode = (return_old_p\n+\t\t    ? BUILT_IN_ATOMIC_FETCH_XOR_N\n+\t\t    : BUILT_IN_ATOMIC_XOR_FETCH_N);\n+\t  break;\n+\tdefault:\n+\t  goto cas_loop;\n+\t}\n+\n+      /* We can only use \"_1\" through \"_16\" variants of the atomic fetch\n+\t built-ins.  */\n+      unsigned HOST_WIDE_INT size = tree_to_uhwi (TYPE_SIZE_UNIT (lhs_type));\n+      if (size != 1 && size != 2 && size != 4 && size != 8 && size != 16)\n+\tgoto cas_loop;\n+\n+      /* If this is a pointer type, we need to multiply by the size of\n+\t the pointer target type.  */\n+      if (POINTER_TYPE_P (lhs_type))\n+\t{\n+\t  if (!COMPLETE_TYPE_P (TREE_TYPE (lhs_type))\n+\t      /* ??? This would introduce -Wdiscarded-qualifiers\n+\t\t warning: __atomic_fetch_* expect volatile void *\n+\t\t type as the first argument.  (Assignments between\n+\t\t atomic and non-atomic objects are OK.) */\n+\t      || TYPE_RESTRICT (lhs_type))\n+\t    goto cas_loop;\n+\t  tree sz = TYPE_SIZE_UNIT (TREE_TYPE (lhs_type));\n+\t  rhs = fold_build2_loc (loc, MULT_EXPR, ptrdiff_type_node,\n+\t\t\t\t convert (ptrdiff_type_node, rhs),\n+\t\t\t\t convert (ptrdiff_type_node, sz));\n+\t}\n+\n+      /* Build __atomic_fetch_* (&lhs, &val, SEQ_CST), or\n+\t __atomic_*_fetch (&lhs, &val, SEQ_CST).  */\n+      fndecl = builtin_decl_explicit (fncode);\n+      params->quick_push (lhs_addr);\n+      params->quick_push (rhs);\n+      params->quick_push (seq_cst);\n+      func_call = c_build_function_call_vec (loc, vNULL, fndecl, params, NULL);\n+\n+      newval = create_tmp_var_raw (nonatomic_lhs_type);\n+      TREE_ADDRESSABLE (newval) = 1;\n+      TREE_NO_WARNING (newval) = 1;\n+      rhs = build4 (TARGET_EXPR, nonatomic_lhs_type, newval, func_call,\n+\t\t    NULL_TREE, NULL_TREE);\n+      SET_EXPR_LOCATION (rhs, loc);\n+      add_stmt (rhs);\n+\n+      /* Finish the compound statement.  */\n+      compound_stmt = c_end_compound_stmt (loc, compound_stmt, false);\n+\n+      /* NEWVAL is the value which was stored, return a COMPOUND_STMT of\n+\t the statement and that value.  */\n+      return build2 (COMPOUND_EXPR, nonatomic_lhs_type, compound_stmt, newval);\n+    }\n+\n+cas_loop:\n   /* Create the variables and labels required for the op= form.  */\n   old = create_tmp_var_raw (nonatomic_lhs_type);\n   old_addr = build_unary_op (loc, ADDR_EXPR, old, 0);"}, {"sha": "648fe6c40f0b00931f6557aa1fc9b09a04c27713", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe0a2080e33f946fc685c1a0518e438f642d8f9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe0a2080e33f946fc685c1a0518e438f642d8f9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2fe0a2080e33f946fc685c1a0518e438f642d8f9", "patch": "@@ -1,3 +1,10 @@\n+2016-01-04  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/68908\n+\t* gcc.dg/atomic/c11-atomic-exec-6.c: New test.\n+\t* gcc.dg/atomic/c11-atomic-exec-7.c: New test.\n+\t* gcc.dg/atomic/stdatomic-op-5.c: New test.\n+\n 2016-01-04  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.target/sparc/20160104-2.c: New test."}, {"sha": "2dc91c510bae703f806bd4296e557aaf3b6f1b38", "filename": "gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-6.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe0a2080e33f946fc685c1a0518e438f642d8f9/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe0a2080e33f946fc685c1a0518e438f642d8f9/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-6.c?ref=2fe0a2080e33f946fc685c1a0518e438f642d8f9", "patch": "@@ -0,0 +1,54 @@\n+/* Test we do correct thing for adding to / subtracting from a pointer,\n+   i.e. that the multiplication by the size of the pointer target type\n+   still occurs.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#define TEST_POINTER_ADD_SUB(TYPE)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      TYPE a[3][3];\t\t\t\t\t\\\n+      TYPE (*_Atomic q)[3] = &a[0];\t\t\t\\\n+      ++q;\t\t\t\t\t\t\\\n+      if (q != &a[1])\t\t\t\t\t\\\n+\t__builtin_abort ();\t\t\t\t\\\n+      q++;\t\t\t\t\t\t\\\n+      if (q != &a[2])\t\t\t\t\t\\\n+\t__builtin_abort ();\t\t\t\t\\\n+      --q;\t\t\t\t\t\t\\\n+      if (q != &a[1])\t\t\t\t\t\\\n+\t__builtin_abort ();\t\t\t\t\\\n+      q--;\t\t\t\t\t\t\\\n+      if (q != &a[0])\t\t\t\t\t\\\n+\t__builtin_abort ();\t\t\t\t\\\n+      q += 2;\t\t\t\t\t\t\\\n+      if (q != &a[2])\t\t\t\t\t\\\n+\t__builtin_abort ();\t\t\t\t\\\n+      q -= 2;\t\t\t\t\t\t\\\n+      if (q != &a[0])\t\t\t\t\t\\\n+\t__builtin_abort ();\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+int\n+main (void)\n+{\n+  TEST_POINTER_ADD_SUB (_Bool);\n+  TEST_POINTER_ADD_SUB (char);\n+  TEST_POINTER_ADD_SUB (signed char);\n+  TEST_POINTER_ADD_SUB (unsigned char);\n+  TEST_POINTER_ADD_SUB (signed short);\n+  TEST_POINTER_ADD_SUB (unsigned short);\n+  TEST_POINTER_ADD_SUB (signed int);\n+  TEST_POINTER_ADD_SUB (unsigned int);\n+  TEST_POINTER_ADD_SUB (signed long);\n+  TEST_POINTER_ADD_SUB (unsigned long);\n+  TEST_POINTER_ADD_SUB (signed long long);\n+  TEST_POINTER_ADD_SUB (unsigned long long);\n+  TEST_POINTER_ADD_SUB (float);\n+  TEST_POINTER_ADD_SUB (double);\n+  TEST_POINTER_ADD_SUB (long double);\n+  TEST_POINTER_ADD_SUB (_Complex float);\n+  TEST_POINTER_ADD_SUB (_Complex double);\n+  TEST_POINTER_ADD_SUB (_Complex long double);\n+}"}, {"sha": "eb7082d8d33b0329b24289e5fdc5bc89256978f3", "filename": "gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-7.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe0a2080e33f946fc685c1a0518e438f642d8f9/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe0a2080e33f946fc685c1a0518e438f642d8f9/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-7.c?ref=2fe0a2080e33f946fc685c1a0518e438f642d8f9", "patch": "@@ -0,0 +1,34 @@\n+/* Test we're able use __atomic_fetch_* where possible and verify\n+   we generate correct code.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors -fdump-tree-original\" } */\n+\n+#include <stdatomic.h>\n+#include <limits.h>\n+\n+extern void abort (void);\n+\n+#define TEST_TYPE(TYPE, MAX)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      struct S { char a[(MAX) + 1]; };\t\t\t\\\n+      TYPE t = 1;\t\t\t\t\t\\\n+      struct S a[2][2];\t\t\t\t\t\\\n+      struct S (*_Atomic p)[2] = &a[0];\t\t\t\\\n+      p += t;\t\t\t\t\t\t\\\n+      if (p != &a[1])\t\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\\\n+      p -= t;\t\t\t\t\t\t\\\n+      if (p != &a[0])\t\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+int\n+main (void)\n+{\n+  TEST_TYPE (signed char, UCHAR_MAX);\n+  TEST_TYPE (signed short, USHRT_MAX);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"__atomic_compare_exchange\" \"original\" } } */"}, {"sha": "daba8ec351310e8ab609d8b844d15837649921e0", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-op-5.c", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe0a2080e33f946fc685c1a0518e438f642d8f9/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-op-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe0a2080e33f946fc685c1a0518e438f642d8f9/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-op-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-op-5.c?ref=2fe0a2080e33f946fc685c1a0518e438f642d8f9", "patch": "@@ -0,0 +1,141 @@\n+/* Test we're able use __atomic_fetch_* where possible and verify\n+   we generate correct code.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors -fdump-tree-original\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+static void\n+test_inc_dec (void)\n+{\n+  atomic_int i = ATOMIC_VAR_INIT (1);\n+\n+  i++;\n+  if (i != 2)\n+    abort ();\n+  i--;\n+  if (i != 1)\n+    abort ();\n+  ++i;\n+  if (i != 2)\n+    abort ();\n+  --i;\n+  if (i != 1)\n+    abort ();\n+  if (++i != 2)\n+    abort ();\n+  if (i++ != 2)\n+    abort ();\n+  if (i != 3)\n+    abort ();\n+  if (i-- != 3)\n+    abort ();\n+  if (i != 2)\n+    abort ();\n+}\n+\n+static void\n+test_add_sub (void)\n+{\n+  atomic_int i = ATOMIC_VAR_INIT (1);\n+\n+  i += 2;\n+  if (i != 3)\n+    abort ();\n+  i -= 2;\n+  if (i != 1)\n+    abort ();\n+  if ((i += 2) != 3)\n+    abort ();\n+  if ((i -= 2) != 1)\n+    abort ();\n+}\n+\n+static void\n+test_and (void)\n+{\n+  atomic_int i = ATOMIC_VAR_INIT (5);\n+\n+  i &= 4;\n+  if (i != 4)\n+    abort ();\n+  if ((i &= 4) != 4)\n+    abort ();\n+}\n+\n+static void\n+test_xor (void)\n+{\n+  atomic_int i = ATOMIC_VAR_INIT (5);\n+\n+  i ^= 2;\n+  if (i != 7)\n+    abort ();\n+  if ((i ^= 4) != 3)\n+    abort ();\n+}\n+\n+static void\n+test_or (void)\n+{\n+  atomic_int i = ATOMIC_VAR_INIT (5);\n+\n+  i |= 2;\n+  if (i != 7)\n+    abort ();\n+  if ((i |= 8) != 15)\n+    abort ();\n+}\n+\n+static void\n+test_ptr (atomic_int *p)\n+{\n+  ++*p;\n+  if (*p != 2)\n+    abort ();\n+\n+  *p += 2;\n+  if (*p != 4)\n+    abort ();\n+\n+  (*p)++;\n+  if (*p != 5)\n+    abort ();\n+\n+  --*p;\n+  if (*p != 4)\n+    abort ();\n+\n+  (*p)--;\n+  if (*p != 3)\n+    abort ();\n+\n+  *p -= 2;\n+  if (*p != 1)\n+    abort ();\n+\n+  atomic_int j = ATOMIC_VAR_INIT (0);\n+  j += *p;\n+  if (j != 1)\n+    abort ();\n+\n+  j -= *p;\n+  if (j != 0)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  atomic_int i = ATOMIC_VAR_INIT (1);\n+  test_inc_dec ();\n+  test_add_sub ();\n+  test_and ();\n+  test_xor ();\n+  test_or ();\n+  test_ptr (&i);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"__atomic_compare_exchange\" \"original\" } } */"}]}