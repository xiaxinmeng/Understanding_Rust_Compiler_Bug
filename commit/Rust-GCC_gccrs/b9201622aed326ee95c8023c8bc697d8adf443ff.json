{"sha": "b9201622aed326ee95c8023c8bc697d8adf443ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkyMDE2MjJhZWQzMjZlZTk1YzgwMjNjOGJjNjk3ZDhhZGY0NDNmZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2002-12-24T22:12:17Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2002-12-24T22:12:17Z"}, "message": "re PR c++/9053 (g++ confused about ambiguity of overloaded function templates)\n\ncp:\n        PR c++/9053\n        * decl.c (duplicate_decls): Templates may be disambiguated by\n        return type.\n\n        PR c++/8702\n        * decl2.c (check_classfn): Use lookup_fnfield_1. List all\n        conversion operators on failure.\ntestsuite\n        * g++.dg/lookup/decl1.C: New test.\n        * g++.dg/lookup/decl2.C: New test.\n\nFrom-SVN: r60482", "tree": {"sha": "77d6b2efb9525308ac4a4185821f8c3a21401842", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77d6b2efb9525308ac4a4185821f8c3a21401842"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9201622aed326ee95c8023c8bc697d8adf443ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9201622aed326ee95c8023c8bc697d8adf443ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9201622aed326ee95c8023c8bc697d8adf443ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9201622aed326ee95c8023c8bc697d8adf443ff/comments", "author": null, "committer": null, "parents": [{"sha": "40aa9d95e2f81b94d4eccf64d870dea3fe9e4083", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40aa9d95e2f81b94d4eccf64d870dea3fe9e4083", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40aa9d95e2f81b94d4eccf64d870dea3fe9e4083"}], "stats": {"total": 227, "additions": 155, "deletions": 72}, "files": [{"sha": "921550ed4b2f9cec3f3e0364be9389c77554ceaa", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9201622aed326ee95c8023c8bc697d8adf443ff/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9201622aed326ee95c8023c8bc697d8adf443ff/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b9201622aed326ee95c8023c8bc697d8adf443ff", "patch": "@@ -1,3 +1,13 @@\n+2002-12-24  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/9053\n+\t* decl.c (duplicate_decls): Templates may be disambiguated by\n+\treturn type.\n+\t\n+\tPR c++/8702\n+\t* decl2.c (check_classfn): Use lookup_fnfield_1. List all\n+\tconversion operators on failure.\n+\n 2002-12-23  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* call.c (tourney, build_field_call, equal_functions, joust) "}, {"sha": "95680dd60fa10b919655d215d6c44cb2c15ee389", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9201622aed326ee95c8023c8bc697d8adf443ff/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9201622aed326ee95c8023c8bc697d8adf443ff/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b9201622aed326ee95c8023c8bc697d8adf443ff", "patch": "@@ -3212,7 +3212,11 @@ duplicate_decls (newdecl, olddecl)\n \t\t   && compparms (TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl))),\n \t\t\t\t TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (newdecl))))\n \t\t   && comp_template_parms (DECL_TEMPLATE_PARMS (newdecl),\n-\t\t\t\t\t   DECL_TEMPLATE_PARMS (olddecl)))\n+\t\t\t\t\t   DECL_TEMPLATE_PARMS (olddecl))\n+\t\t   /* Template functions can be disambiguated by\n+\t\t      return type.  */\n+\t\t   && same_type_p (TREE_TYPE (TREE_TYPE (newdecl)),\n+\t\t\t\t   TREE_TYPE (TREE_TYPE (olddecl))))\n \t    {\n \t      error (\"new declaration `%#D'\", newdecl);\n \t      cp_error_at (\"ambiguates old declaration `%#D'\", olddecl);"}, {"sha": "afb8693a6b730643285377b96e6318ca008cd848", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 74, "deletions": 69, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9201622aed326ee95c8023c8bc697d8adf443ff/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9201622aed326ee95c8023c8bc697d8adf443ff/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b9201622aed326ee95c8023c8bc697d8adf443ff", "patch": "@@ -676,11 +676,7 @@ tree\n check_classfn (ctype, function)\n      tree ctype, function;\n {\n-  tree fn_name = DECL_NAME (function);\n-  tree fndecl, fndecls;\n-  tree method_vec = CLASSTYPE_METHOD_VEC (complete_type (ctype));\n-  tree *methods = 0;\n-  tree *end = 0;\n+  int ix;\n   \n   if (DECL_USE_TEMPLATE (function)\n       && !(TREE_CODE (function) == TEMPLATE_DECL\n@@ -697,81 +693,90 @@ check_classfn (ctype, function)\n        reason we should, either.  We let our callers know we didn't\n        find the method, but we don't complain.  */\n     return NULL_TREE;\n-      \n-  if (method_vec != 0)\n+\n+  ix = lookup_fnfields_1 (complete_type (ctype),\n+\t\t\t  DECL_CONSTRUCTOR_P (function) ? ctor_identifier :\n+\t\t\t  DECL_DESTRUCTOR_P (function) ? dtor_identifier :\n+\t\t\t  DECL_NAME (function));\n+\n+  if (ix >= 0)\n     {\n-      methods = &TREE_VEC_ELT (method_vec, 0);\n-      end = TREE_VEC_END (method_vec);\n-\n-      /* First suss out ctors and dtors.  */\n-      if (*methods && fn_name == DECL_NAME (OVL_CURRENT (*methods))\n-\t  && DECL_CONSTRUCTOR_P (function))\n-\tgoto got_it;\n-      if (*++methods && fn_name == DECL_NAME (OVL_CURRENT (*methods))\n-\t  && DECL_DESTRUCTOR_P (function))\n-\tgoto got_it;\n-\n-      while (++methods != end && *methods)\n+      tree methods = CLASSTYPE_METHOD_VEC (ctype);\n+      tree fndecls, fndecl;\n+      bool is_conv_op;\n+      const char *format = NULL;\n+      \n+      for (fndecls = TREE_VEC_ELT (methods, ix);\n+\t   fndecls; fndecls = OVL_NEXT (fndecls))\n+\t{\n+\t  tree p1, p2;\n+\t  \n+\t  fndecl = OVL_CURRENT (fndecls);\n+\t  p1 = TYPE_ARG_TYPES (TREE_TYPE (function));\n+\t  p2 = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+\n+\t  /* We cannot simply call decls_match because this doesn't\n+\t     work for static member functions that are pretending to\n+\t     be methods, and because the name may have been changed by\n+\t     asm(\"new_name\").  */ \n+\t      \n+\t   /* Get rid of the this parameter on functions that become\n+\t      static.  */\n+\t  if (DECL_STATIC_FUNCTION_P (fndecl)\n+\t      && TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE)\n+\t    p1 = TREE_CHAIN (p1);\n+\t      \n+\t  if (same_type_p (TREE_TYPE (TREE_TYPE (function)),\n+\t\t\t   TREE_TYPE (TREE_TYPE (fndecl)))\n+\t      && compparms (p1, p2)\n+\t      && (DECL_TEMPLATE_SPECIALIZATION (function)\n+\t\t  == DECL_TEMPLATE_SPECIALIZATION (fndecl))\n+\t      && (!DECL_TEMPLATE_SPECIALIZATION (function)\n+\t\t  || (DECL_TI_TEMPLATE (function) \n+\t\t      == DECL_TI_TEMPLATE (fndecl))))\n+\t    return fndecl;\n+\t}\n+      error (\"prototype for `%#D' does not match any in class `%T'\",\n+\t     function, ctype);\n+      is_conv_op = DECL_CONV_FN_P (fndecl);\n+\n+      if (is_conv_op)\n+\tix = CLASSTYPE_FIRST_CONVERSION_SLOT;\n+      fndecls = TREE_VEC_ELT (methods, ix);\n+      while (fndecls)\n \t{\n-\t  fndecl = *methods;\n-\t  if (fn_name == DECL_NAME (OVL_CURRENT (*methods)))\n+\t  fndecl = OVL_CURRENT (fndecls);\n+\t  fndecls = OVL_NEXT (fndecls);\n+\n+\t  if (!fndecls && is_conv_op)\n \t    {\n-\t    got_it:\n-\t      for (fndecls = *methods; fndecls != NULL_TREE;\n-\t\t   fndecls = OVL_NEXT (fndecls))\n+\t      if (TREE_VEC_LENGTH (methods) > ix)\n \t\t{\n-\t\t  fndecl = OVL_CURRENT (fndecls);\n-\n-\t\t  /* We cannot simply call decls_match because this\n-\t\t     doesn't work for static member functions that are \n-                     pretending to be methods, and because the name\n-\t\t     may have been changed by asm(\"new_name\").  */ \n-\t\t  if (DECL_NAME (function) == DECL_NAME (fndecl))\n+\t\t  ix++;\n+\t\t  fndecls = TREE_VEC_ELT (methods, ix);\n+\t\t  if (!DECL_CONV_FN_P (OVL_CURRENT (fndecls)))\n \t\t    {\n-\t\t      tree p1 = TYPE_ARG_TYPES (TREE_TYPE (function));\n-\t\t      tree p2 = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n-\n-\t\t      /* Get rid of the this parameter on functions that become\n-\t\t\t static.  */\n-\t\t      if (DECL_STATIC_FUNCTION_P (fndecl)\n-\t\t\t  && TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE)\n-\t\t\tp1 = TREE_CHAIN (p1);\n-\n-\t\t      if (same_type_p (TREE_TYPE (TREE_TYPE (function)),\n-\t\t\t\t       TREE_TYPE (TREE_TYPE (fndecl)))\n-\t\t\t  && compparms (p1, p2)\n-\t\t\t  && (DECL_TEMPLATE_SPECIALIZATION (function)\n-\t\t\t      == DECL_TEMPLATE_SPECIALIZATION (fndecl))\n-\t\t\t  && (!DECL_TEMPLATE_SPECIALIZATION (function)\n-\t\t\t      || (DECL_TI_TEMPLATE (function) \n-\t\t\t\t  == DECL_TI_TEMPLATE (fndecl))))\n-\t\t\treturn fndecl;\n+\t\t      fndecls = NULL_TREE;\n+\t\t      is_conv_op = false;\n \t\t    }\n \t\t}\n-\t      break;\t\t/* loser */\n+\t      else\n+\t\tis_conv_op = false;\n \t    }\n+\t  if (format)\n+\t    format = \"                %#D\";\n+\t  else if (fndecls)\n+\t    format = \"candidates are: %#D\";\n+\t  else\n+\t    format = \"candidate is: %#D\";\n+\t  cp_error_at (format, fndecl);\n \t}\n     }\n-\n-  if (methods != end && *methods)\n-    {\n-      tree fndecl = *methods;\n-      error (\"prototype for `%#D' does not match any in class `%T'\",\n-\t\tfunction, ctype);\n-      cp_error_at (\"candidate%s: %+#D\", OVL_NEXT (fndecl) ? \"s are\" : \" is\",\n-\t\t   OVL_CURRENT (fndecl));\n-      while (fndecl = OVL_NEXT (fndecl), fndecl)\n-\tcp_error_at (\"                %#D\", OVL_CURRENT(fndecl));\n-    }\n+  else if (!COMPLETE_TYPE_P (ctype))\n+    cxx_incomplete_type_error (function, ctype);\n   else\n-    {\n-      methods = 0;\n-      if (!COMPLETE_TYPE_P (ctype))\n-        cxx_incomplete_type_error (function, ctype);\n-      else\n-        error (\"no `%#D' member function declared in class `%T'\",\n-\t\t  function, ctype);\n-    }\n+    error (\"no `%#D' member function declared in class `%T'\",\n+\t   function, ctype);\n \n   /* If we did not find the method in the class, add it to avoid\n      spurious errors (unless the CTYPE is not yet defined, in which"}, {"sha": "b40420e24c3d490229a6f7d56c903872ba78d254", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9201622aed326ee95c8023c8bc697d8adf443ff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9201622aed326ee95c8023c8bc697d8adf443ff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b9201622aed326ee95c8023c8bc697d8adf443ff", "patch": "@@ -1,3 +1,8 @@\n+2002-12-24  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/lookup/decl1.C: New test.\n+\t* g++.dg/lookup/decl2.C: New test.\n+\n 2002-12-24  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* g++.dg/init/new1.C, g++.dg/template/alignof1.C,\n@@ -12,9 +17,9 @@\n \n 2002-12-23  Mark Mitchell  <mark@codesourcery.com>\n \n-\t* testsuite/gcc.dg/i386-bitfield3.c: New test.\n+\t* gcc.dg/i386-bitfield3.c: New test.\n \t\n-\t* testsuite/gcc.dg/i386-bitfield2.c: New test.\n+\t* gcc.dg/i386-bitfield2.c: New test.\n \t\n 2002-12-22  Nathan Sidwell  <nathan@codesourcery.com>\n "}, {"sha": "d9af65604cb2e04aef4f872e023f2446c7d7c949", "filename": "gcc/testsuite/g++.dg/lookup/decl1.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9201622aed326ee95c8023c8bc697d8adf443ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fdecl1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9201622aed326ee95c8023c8bc697d8adf443ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fdecl1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fdecl1.C?ref=b9201622aed326ee95c8023c8bc697d8adf443ff", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 24 Dec 2002 <nathan@codesourcery.com>\n+\n+// PR 8702. Failure to match templates.\n+\n+template <typename X> struct C1{};\n+\n+template <typename X>\n+struct C2 {\n+  template<typename Y> operator C1<Y>();\n+  template<typename Y> operator C2<Y>();\n+};\n+\n+template<typename X> template<typename Y>\n+C2<X>::operator C1<Y>()\n+{\n+  return C1<Y>();\n+}\n+\n+struct A\n+{\n+  operator int ();\t\t\t// { dg-error \"operator\" \"\" }\n+  operator float ();\t\t\t// { dg-error \"operator\" \"\" }\n+  operator float () const;\t\t// { dg-error \"operator\" \"\" }\n+  template <typename T> operator T * (); // { dg-error \"candidates\" \"\" }\n+};\n+\n+A::operator short () { // { dg-error \"prototype for\" \"\" }\n+  return 0;\n+}"}, {"sha": "75ce0967a4b4a30e2119322f41c141fee3ecc7c3", "filename": "gcc/testsuite/g++.dg/lookup/decl2.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9201622aed326ee95c8023c8bc697d8adf443ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fdecl2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9201622aed326ee95c8023c8bc697d8adf443ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fdecl2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fdecl2.C?ref=b9201622aed326ee95c8023c8bc697d8adf443ff", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 24 Dec 2002 <nathan@codesourcery.com>\n+// Source Martin Buchholz martin@xemacs.org\n+\n+// PR 9053. Failed to consider templates that are disambiguated by\n+// return type.\n+\n+template <typename T> class bar;\n+template <> struct bar<const char*> { typedef void type; };\n+template <typename T> class qux;\n+template <> struct qux<int> { typedef void type; };\n+\n+template <typename T>\n+typename bar<T>::type foo (T t) { }\n+\n+template <typename T>\n+typename qux<T>::type foo (T t) { }\n+\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  foo (\"foo\");\n+  foo (7);\n+}"}]}