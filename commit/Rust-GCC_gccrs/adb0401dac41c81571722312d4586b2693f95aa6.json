{"sha": "adb0401dac41c81571722312d4586b2693f95aa6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRiMDQwMWRhYzQxYzgxNTcxNzIyMzEyZDQ1ODZiMjY5M2Y5NWFhNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-09-16T15:47:21Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-09-16T15:47:21Z"}, "message": "Update Go library to r60.\n\nFrom-SVN: r178910", "tree": {"sha": "ea2b52e3c258d6b6d9356977c683c7f72a4a5fd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea2b52e3c258d6b6d9356977c683c7f72a4a5fd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adb0401dac41c81571722312d4586b2693f95aa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adb0401dac41c81571722312d4586b2693f95aa6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adb0401dac41c81571722312d4586b2693f95aa6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adb0401dac41c81571722312d4586b2693f95aa6/comments", "author": null, "committer": null, "parents": [{"sha": "5548ca3540bccbc908a45942896d635ea5f1c23f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5548ca3540bccbc908a45942896d635ea5f1c23f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5548ca3540bccbc908a45942896d635ea5f1c23f"}], "stats": {"total": 89330, "additions": 58886, "deletions": 30444}, "files": [{"sha": "5068dd7f63d8b9a67628d450da7394093e7ad26d", "filename": "gcc/testsuite/go.test/go-test.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/gcc%2Ftestsuite%2Fgo.test%2Fgo-test.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/gcc%2Ftestsuite%2Fgo.test%2Fgo-test.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Fgo-test.exp?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -806,7 +806,7 @@ proc go-gc-tests { } {\n \t\t$status $name\n \t    } else {\n \t\tverbose -log $comp_output\n-\t\tfali $name\n+\t\tfail $name\n \t    }\n \t    file delete $ofile1 $ofile2 $output_file\n \t    set runtests $hold_runtests"}, {"sha": "60718216712ee41d77d271748612c11970e614ad", "filename": "gcc/testsuite/go.test/test/chan/select5.go", "status": "modified", "additions": 144, "deletions": 146, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect5.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -37,7 +37,7 @@ func main() {\n \t\t}\n \t\tfmt.Fprintln(out, `}`)\n \t}\n-\t\n+\n \tdo(recv)\n \tdo(send)\n \tdo(recvOrder)\n@@ -54,8 +54,8 @@ func run(t *template.Template, a interface{}, out io.Writer) {\n \t}\n }\n \n-type arg struct{\n-\tdef bool\n+type arg struct {\n+\tdef    bool\n \tnreset int\n }\n \n@@ -135,280 +135,279 @@ func main() {\n }\n `\n \n-func parse(s string) *template.Template {\n-\tt := template.New(nil)\n-\tt.SetDelims(\"\u2329\", \"\u232a\")\n-\tif err := t.Parse(s); err != nil {\n-\t\tpanic(s)\n+func parse(name, s string) *template.Template {\n+\tt, err := template.New(name).Parse(s)\n+\tif err != nil {\n+\t\tpanic(fmt.Sprintf(\"%q: %s\", name, err))\n \t}\n \treturn t\n }\n \n-var recv = parse(`\n-\t\u2329# Send n, receive it one way or another into x, check that they match.\u232a\n+var recv = parse(\"recv\", `\n+\t{{/*  Send n, receive it one way or another into x, check that they match. */}}\n \tc <- n\n-\t\u2329.section Maybe\u232a\n+\t{{if .Maybe}}\n \tx = <-c\n-\t\u2329.or\u232a\n+\t{{else}}\n \tselect {\n-\t\u2329# Blocking or non-blocking, before the receive.\u232a\n-\t\u2329# The compiler implements two-case select where one is default with custom code,\u232a\n-\t\u2329# so test the default branch both before and after the send.\u232a\n-\t\u2329.section MaybeDefault\u232a\n+\t{{/*  Blocking or non-blocking, before the receive. */}}\n+\t{{/*  The compiler implements two-case select where one is default with custom code, */}}\n+\t{{/*  so test the default branch both before and after the send. */}}\n+\t{{if .MaybeDefault}}\n \tdefault:\n \t\tpanic(\"nonblock\")\n-\t\u2329.end\u232a\n-\t\u2329# Receive from c.  Different cases are direct, indirect, :=, interface, and map assignment.\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{/*  Receive from c.  Different cases are direct, indirect, :=, interface, and map assignment. */}}\n+\t{{if .Maybe}}\n \tcase x = <-c:\n-\t\u2329.or\u232a\u2329.section Maybe\u232a\n+\t{{else}}{{if .Maybe}}\n \tcase *f(&x) = <-c:\n-\t\u2329.or\u232a\u2329.section Maybe\u232a\n+\t{{else}}{{if .Maybe}}\n \tcase y := <-c:\n \t\tx = y\n-\t\u2329.or\u232a\u2329.section Maybe\u232a\n+\t{{else}}{{if .Maybe}}\n \tcase i = <-c:\n \t\tx = i.(int)\n-\t\u2329.or\u232a\n+\t{{else}}\n \tcase m[13] = <-c:\n \t\tx = m[13]\n-\t\u2329.end\u232a\u2329.end\u232a\u2329.end\u232a\u2329.end\u232a\n-\t\u2329# Blocking or non-blocking again, after the receive.\u232a\n-\t\u2329.section MaybeDefault\u232a\n+\t{{end}}{{end}}{{end}}{{end}}\n+\t{{/*  Blocking or non-blocking again, after the receive. */}}\n+\t{{if .MaybeDefault}}\n \tdefault:\n \t\tpanic(\"nonblock\")\n-\t\u2329.end\u232a\n-\t\u2329# Dummy send, receive to keep compiler from optimizing select.\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{/*  Dummy send, receive to keep compiler from optimizing select. */}}\n+\t{{if .Maybe}}\n \tcase dummy <- 1:\n \t\tpanic(\"dummy send\")\n-\t\u2329.end\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{if .Maybe}}\n \tcase <-dummy:\n \t\tpanic(\"dummy receive\")\n-\t\u2329.end\u232a\n-\t\u2329# Nil channel send, receive to keep compiler from optimizing select.\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{/*  Nil channel send, receive to keep compiler from optimizing select. */}}\n+\t{{if .Maybe}}\n \tcase nilch <- 1:\n \t\tpanic(\"nilch send\")\n-\t\u2329.end\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{if .Maybe}}\n \tcase <-nilch:\n \t\tpanic(\"nilch recv\")\n-\t\u2329.end\u232a\n+\t{{end}}\n \t}\n-\t\u2329.end\u232a\n+\t{{end}}\n \tif x != n {\n \t\tdie(x)\n \t}\n \tn++\n `)\n \n-var recvOrder = parse(`\n-\t\u2329# Send n, receive it one way or another into x, check that they match.\u232a\n-\t\u2329# Check order of operations along the way by calling functions that check\u232a\n-\t\u2329# that the argument sequence is strictly increasing.\u232a\n+var recvOrder = parse(\"recvOrder\", `\n+\t{{/*  Send n, receive it one way or another into x, check that they match. */}}\n+\t{{/*  Check order of operations along the way by calling functions that check */}}\n+\t{{/*  that the argument sequence is strictly increasing. */}}\n \torder = 0\n \tc <- n\n-\t\u2329.section Maybe\u232a\n-\t\u2329# Outside of select, left-to-right rule applies.\u232a\n-\t\u2329# (Inside select, assignment waits until case is chosen,\u232a\n-\t\u2329# so right hand side happens before anything on left hand side.\u232a\n+\t{{if .Maybe}}\n+\t{{/*  Outside of select, left-to-right rule applies. */}}\n+\t{{/*  (Inside select, assignment waits until case is chosen, */}}\n+\t{{/*  so right hand side happens before anything on left hand side. */}}\n \t*fp(&x, 1) = <-fc(c, 2)\n-\t\u2329.or\u232a\u2329.section Maybe\u232a\n+\t{{else}}{{if .Maybe}}\n \tm[fn(13, 1)] = <-fc(c, 2)\n \tx = m[13]\n-\t\u2329.or\u232a\n+\t{{else}}\n \tselect {\n-\t\u2329# Blocking or non-blocking, before the receive.\u232a\n-\t\u2329# The compiler implements two-case select where one is default with custom code,\u232a\n-\t\u2329# so test the default branch both before and after the send.\u232a\n-\t\u2329.section MaybeDefault\u232a\n+\t{{/*  Blocking or non-blocking, before the receive. */}}\n+\t{{/*  The compiler implements two-case select where one is default with custom code, */}}\n+\t{{/*  so test the default branch both before and after the send. */}}\n+\t{{if .MaybeDefault}}\n \tdefault:\n \t\tpanic(\"nonblock\")\n-\t\u2329.end\u232a\n-\t\u2329# Receive from c.  Different cases are direct, indirect, :=, interface, and map assignment.\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{/*  Receive from c.  Different cases are direct, indirect, :=, interface, and map assignment. */}}\n+\t{{if .Maybe}}\n \tcase *fp(&x, 100) = <-fc(c, 1):\n-\t\u2329.or\u232a\u2329.section Maybe\u232a\n+\t{{else}}{{if .Maybe}}\n \tcase y := <-fc(c, 1):\n \t\tx = y\n-\t\u2329.or\u232a\u2329.section Maybe\u232a\n+\t{{else}}{{if .Maybe}}\n \tcase i = <-fc(c, 1):\n \t\tx = i.(int)\n-\t\u2329.or\u232a\n+\t{{else}}\n \tcase m[fn(13, 100)] = <-fc(c, 1):\n \t\tx = m[13]\n-\t\u2329.end\u232a\u2329.end\u232a\u2329.end\u232a\n-\t\u2329# Blocking or non-blocking again, after the receive.\u232a\n-\t\u2329.section MaybeDefault\u232a\n+\t{{end}}{{end}}{{end}}\n+\t{{/*  Blocking or non-blocking again, after the receive. */}}\n+\t{{if .MaybeDefault}}\n \tdefault:\n \t\tpanic(\"nonblock\")\n-\t\u2329.end\u232a\n-\t\u2329# Dummy send, receive to keep compiler from optimizing select.\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{/*  Dummy send, receive to keep compiler from optimizing select. */}}\n+\t{{if .Maybe}}\n \tcase fc(dummy, 2) <- fn(1, 3):\n \t\tpanic(\"dummy send\")\n-\t\u2329.end\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{if .Maybe}}\n \tcase <-fc(dummy, 4):\n \t\tpanic(\"dummy receive\")\n-\t\u2329.end\u232a\n-\t\u2329# Nil channel send, receive to keep compiler from optimizing select.\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{/*  Nil channel send, receive to keep compiler from optimizing select. */}}\n+\t{{if .Maybe}}\n \tcase fc(nilch, 5) <- fn(1, 6):\n \t\tpanic(\"nilch send\")\n-\t\u2329.end\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{if .Maybe}}\n \tcase <-fc(nilch, 7):\n \t\tpanic(\"nilch recv\")\n-\t\u2329.end\u232a\n+\t{{end}}\n \t}\n-\t\u2329.end\u232a\u2329.end\u232a\n+\t{{end}}{{end}}\n \tif x != n {\n \t\tdie(x)\n \t}\n \tn++\n `)\n \n-var send = parse(`\n-\t\u2329# Send n one way or another, receive it into x, check that they match.\u232a\n-\t\u2329.section Maybe\u232a\n+var send = parse(\"send\", `\n+\t{{/*  Send n one way or another, receive it into x, check that they match. */}}\n+\t{{if .Maybe}}\n \tc <- n\n-\t\u2329.or\u232a\n+\t{{else}}\n \tselect {\n-\t\u2329# Blocking or non-blocking, before the receive (same reason as in recv).\u232a\n-\t\u2329.section MaybeDefault\u232a\n+\t{{/*  Blocking or non-blocking, before the receive (same reason as in recv). */}}\n+\t{{if .MaybeDefault}}\n \tdefault:\n \t\tpanic(\"nonblock\")\n-\t\u2329.end\u232a\n-\t\u2329# Send c <- n.  No real special cases here, because no values come back\u232a\n-\t\u2329# from the send operation.\u232a\n+\t{{end}}\n+\t{{/*  Send c <- n.  No real special cases here, because no values come back */}}\n+\t{{/*  from the send operation. */}}\n \tcase c <- n:\n-\t\u2329# Blocking or non-blocking.\u232a\n-\t\u2329.section MaybeDefault\u232a\n+\t{{/*  Blocking or non-blocking. */}}\n+\t{{if .MaybeDefault}}\n \tdefault:\n \t\tpanic(\"nonblock\")\n-\t\u2329.end\u232a\n-\t\u2329# Dummy send, receive to keep compiler from optimizing select.\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{/*  Dummy send, receive to keep compiler from optimizing select. */}}\n+\t{{if .Maybe}}\n \tcase dummy <- 1:\n \t\tpanic(\"dummy send\")\n-\t\u2329.end\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{if .Maybe}}\n \tcase <-dummy:\n \t\tpanic(\"dummy receive\")\n-\t\u2329.end\u232a\n-\t\u2329# Nil channel send, receive to keep compiler from optimizing select.\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{/*  Nil channel send, receive to keep compiler from optimizing select. */}}\n+\t{{if .Maybe}}\n \tcase nilch <- 1:\n \t\tpanic(\"nilch send\")\n-\t\u2329.end\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{if .Maybe}}\n \tcase <-nilch:\n \t\tpanic(\"nilch recv\")\n-\t\u2329.end\u232a\n+\t{{end}}\n \t}\n-\t\u2329.end\u232a\n+\t{{end}}\n \tx = <-c\n \tif x != n {\n \t\tdie(x)\n \t}\n \tn++\n `)\n \n-var sendOrder = parse(`\n-\t\u2329# Send n one way or another, receive it into x, check that they match.\u232a\n-\t\u2329# Check order of operations along the way by calling functions that check\u232a\n-\t\u2329# that the argument sequence is strictly increasing.\u232a\n+var sendOrder = parse(\"sendOrder\", `\n+\t{{/*  Send n one way or another, receive it into x, check that they match. */}}\n+\t{{/*  Check order of operations along the way by calling functions that check */}}\n+\t{{/*  that the argument sequence is strictly increasing. */}}\n \torder = 0\n-\t\u2329.section Maybe\u232a\n+\t{{if .Maybe}}\n \tfc(c, 1) <- fn(n, 2)\n-\t\u2329.or\u232a\n+\t{{else}}\n \tselect {\n-\t\u2329# Blocking or non-blocking, before the receive (same reason as in recv).\u232a\n-\t\u2329.section MaybeDefault\u232a\n+\t{{/*  Blocking or non-blocking, before the receive (same reason as in recv). */}}\n+\t{{if .MaybeDefault}}\n \tdefault:\n \t\tpanic(\"nonblock\")\n-\t\u2329.end\u232a\n-\t\u2329# Send c <- n.  No real special cases here, because no values come back\u232a\n-\t\u2329# from the send operation.\u232a\n+\t{{end}}\n+\t{{/*  Send c <- n.  No real special cases here, because no values come back */}}\n+\t{{/*  from the send operation. */}}\n \tcase fc(c, 1) <- fn(n, 2):\n-\t\u2329# Blocking or non-blocking.\u232a\n-\t\u2329.section MaybeDefault\u232a\n+\t{{/*  Blocking or non-blocking. */}}\n+\t{{if .MaybeDefault}}\n \tdefault:\n \t\tpanic(\"nonblock\")\n-\t\u2329.end\u232a\n-\t\u2329# Dummy send, receive to keep compiler from optimizing select.\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{/*  Dummy send, receive to keep compiler from optimizing select. */}}\n+\t{{if .Maybe}}\n \tcase fc(dummy, 3) <- fn(1, 4):\n \t\tpanic(\"dummy send\")\n-\t\u2329.end\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{if .Maybe}}\n \tcase <-fc(dummy, 5):\n \t\tpanic(\"dummy receive\")\n-\t\u2329.end\u232a\n-\t\u2329# Nil channel send, receive to keep compiler from optimizing select.\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{/*  Nil channel send, receive to keep compiler from optimizing select. */}}\n+\t{{if .Maybe}}\n \tcase fc(nilch, 6) <- fn(1, 7):\n \t\tpanic(\"nilch send\")\n-\t\u2329.end\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{if .Maybe}}\n \tcase <-fc(nilch, 8):\n \t\tpanic(\"nilch recv\")\n-\t\u2329.end\u232a\n+\t{{end}}\n \t}\n-\t\u2329.end\u232a\n+\t{{end}}\n \tx = <-c\n \tif x != n {\n \t\tdie(x)\n \t}\n \tn++\n `)\n \n-var nonblock = parse(`\n+var nonblock = parse(\"nonblock\", `\n \tx = n\n-\t\u2329# Test various combinations of non-blocking operations.\u232a\n-\t\u2329# Receive assignments must not edit or even attempt to compute the address of the lhs.\u232a\n+\t{{/*  Test various combinations of non-blocking operations. */}}\n+\t{{/*  Receive assignments must not edit or even attempt to compute the address of the lhs. */}}\n \tselect {\n-\t\u2329.section MaybeDefault\u232a\n+\t{{if .MaybeDefault}}\n \tdefault:\n-\t\u2329.end\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{if .Maybe}}\n \tcase dummy <- 1:\n \t\tpanic(\"dummy <- 1\")\n-\t\u2329.end\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{if .Maybe}}\n \tcase nilch <- 1:\n \t\tpanic(\"nilch <- 1\")\n-\t\u2329.end\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{if .Maybe}}\n \tcase <-dummy:\n \t\tpanic(\"<-dummy\")\n-\t\u2329.end\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{if .Maybe}}\n \tcase x = <-dummy:\n \t\tpanic(\"<-dummy x\")\n-\t\u2329.end\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{if .Maybe}}\n \tcase **(**int)(nil) = <-dummy:\n \t\tpanic(\"<-dummy (and didn't crash saving result!)\")\n-\t\u2329.end\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{if .Maybe}}\n \tcase <-nilch:\n \t\tpanic(\"<-nilch\")\n-\t\u2329.end\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{if .Maybe}}\n \tcase x = <-nilch:\n \t\tpanic(\"<-nilch x\")\n-\t\u2329.end\u232a\n-\t\u2329.section Maybe\u232a\n+\t{{end}}\n+\t{{if .Maybe}}\n \tcase **(**int)(nil) = <-nilch:\n \t\tpanic(\"<-nilch (and didn't crash saving result!)\")\n-\t\u2329.end\u232a\n-\t\u2329.section MustDefault\u232a\n+\t{{end}}\n+\t{{if .MustDefault}}\n \tdefault:\n-\t\u2329.end\u232a\n+\t{{end}}\n \t}\n \tif x != n {\n \t\tdie(x)\n@@ -466,7 +465,7 @@ func next() bool {\n \t}\n \n \t// increment last choice sequence\n-\tcp = len(choices)-1\n+\tcp = len(choices) - 1\n \tfor cp >= 0 && choices[cp].i == choices[cp].n-1 {\n \t\tcp--\n \t}\n@@ -479,4 +478,3 @@ func next() bool {\n \tcp = 0\n \treturn true\n }\n-"}, {"sha": "95514cfd650ae6d95c767e040fddc4c02c60c95e", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug243.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug243.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug243.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug243.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -38,7 +38,7 @@ func Listen(x, y string) (T, string) {\n }\n \n func (t T) Addr() os.Error {\n-\treturn os.ErrorString(\"stringer\")\n+\treturn os.NewError(\"stringer\")\n }\n \n func (t T) Accept() (int, string) {\n@@ -49,4 +49,3 @@ func Dial(x, y, z string) (int, string) {\n \tglobal <- 1\n \treturn 0, \"\"\n }\n-"}, {"sha": "9f47e52e2b60a80776ac1070ac1ef5f54e37a89f", "filename": "gcc/testsuite/go.test/test/mallocrep.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmallocrep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmallocrep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmallocrep.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -18,6 +18,7 @@ var chatty = flag.Bool(\"v\", false, \"chatty\")\n var oldsys uint64\n \n func bigger() {\n+\truntime.UpdateMemStats()\n \tif st := runtime.MemStats; oldsys < st.Sys {\n \t\toldsys = st.Sys\n \t\tif *chatty {\n@@ -31,7 +32,7 @@ func bigger() {\n }\n \n func main() {\n-\truntime.GC()\t\t   // clean up garbage from init\n+\truntime.GC()               // clean up garbage from init\n \truntime.MemProfileRate = 0 // disable profiler\n \truntime.MemStats.Alloc = 0 // ignore stacks\n \tflag.Parse()\n@@ -45,8 +46,10 @@ func main() {\n \t\t\t\tpanic(\"fail\")\n \t\t\t}\n \t\t\tb := runtime.Alloc(uintptr(j))\n+\t\t\truntime.UpdateMemStats()\n \t\t\tduring := runtime.MemStats.Alloc\n \t\t\truntime.Free(b)\n+\t\t\truntime.UpdateMemStats()\n \t\t\tif a := runtime.MemStats.Alloc; a != 0 {\n \t\t\t\tprintln(\"allocated \", j, \": wrong stats: during=\", during, \" after=\", a, \" (want 0)\")\n \t\t\t\tpanic(\"fail\")"}, {"sha": "0b1479900e69805222f4bfad0e84516df669ea3b", "filename": "gcc/testsuite/go.test/test/mallocrep1.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmallocrep1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmallocrep1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmallocrep1.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -42,6 +42,7 @@ func AllocAndFree(size, count int) {\n \tif *chatty {\n \t\tfmt.Printf(\"size=%d count=%d ...\\n\", size, count)\n \t}\n+\truntime.UpdateMemStats()\n \tn1 := stats.Alloc\n \tfor i := 0; i < count; i++ {\n \t\tb[i] = runtime.Alloc(uintptr(size))\n@@ -50,11 +51,13 @@ func AllocAndFree(size, count int) {\n \t\t\tprintln(\"lookup failed: got\", base, n, \"for\", b[i])\n \t\t\tpanic(\"fail\")\n \t\t}\n-\t\tif runtime.MemStats.Sys > 1e9 {\n+\t\truntime.UpdateMemStats()\n+\t\tif stats.Sys > 1e9 {\n \t\t\tprintln(\"too much memory allocated\")\n \t\t\tpanic(\"fail\")\n \t\t}\n \t}\n+\truntime.UpdateMemStats()\n \tn2 := stats.Alloc\n \tif *chatty {\n \t\tfmt.Printf(\"size=%d count=%d stats=%+v\\n\", size, count, *stats)\n@@ -72,6 +75,7 @@ func AllocAndFree(size, count int) {\n \t\t\tpanic(\"fail\")\n \t\t}\n \t\truntime.Free(b[i])\n+\t\truntime.UpdateMemStats()\n \t\tif stats.Alloc != uint64(alloc-n) {\n \t\t\tprintln(\"free alloc got\", stats.Alloc, \"expected\", alloc-n, \"after free of\", n)\n \t\t\tpanic(\"fail\")\n@@ -81,6 +85,7 @@ func AllocAndFree(size, count int) {\n \t\t\tpanic(\"fail\")\n \t\t}\n \t}\n+\truntime.UpdateMemStats()\n \tn4 := stats.Alloc\n \n \tif *chatty {"}, {"sha": "f0849cc1a188715627b50638991bf2a50b8388d7", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -1,4 +1,4 @@\n-aea0ba6e5935\n+504f4e9b079c\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "2881c6d7c0967ec6abf5668258071c73ba422b11", "filename": "libgo/Makefile.am", "status": "modified", "additions": 438, "deletions": 167, "changes": 605, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -106,6 +106,7 @@ toolexeclibgo_DATA = \\\n \tbytes.gox \\\n \tcmath.gox \\\n \tcrypto.gox \\\n+\tcsv.gox \\\n \tebnf.gox \\\n \texec.gox \\\n \texpvar.gox \\\n@@ -120,6 +121,7 @@ toolexeclibgo_DATA = \\\n \tjson.gox \\\n \tlog.gox \\\n \tmath.gox \\\n+\tmail.gox \\\n \tmime.gox \\\n \tnet.gox \\\n \tnetchan.gox \\\n@@ -145,6 +147,7 @@ toolexeclibgo_DATA = \\\n \ttime.gox \\\n \ttry.gox \\\n \tunicode.gox \\\n+\turl.gox \\\n \tutf16.gox \\\n \tutf8.gox \\\n \twebsocket.gox \\\n@@ -206,19 +209,24 @@ toolexeclibgocryptoopenpgpdir = $(toolexeclibgocryptodir)/openpgp\n \n toolexeclibgocryptoopenpgp_DATA = \\\n \tcrypto/openpgp/armor.gox \\\n+\tcrypto/openpgp/elgamal.gox \\\n \tcrypto/openpgp/error.gox \\\n \tcrypto/openpgp/packet.gox \\\n \tcrypto/openpgp/s2k.gox\n \n+toolexeclibgocryptox509dir = $(toolexeclibgocryptodir)/x509\n+\n+toolexeclibgocryptox509_DATA = \\\n+\tcrypto/x509/pkix.gox\n+\n toolexeclibgodebugdir = $(toolexeclibgodir)/debug\n \n toolexeclibgodebug_DATA = \\\n \tdebug/dwarf.gox \\\n \tdebug/elf.gox \\\n \tdebug/gosym.gox \\\n \tdebug/macho.gox \\\n-\tdebug/pe.gox \\\n-\tdebug/proc.gox\n+\tdebug/pe.gox\n \n toolexeclibgoencodingdir = $(toolexeclibgodir)/encoding\n \n@@ -227,7 +235,6 @@ toolexeclibgoencoding_DATA = \\\n \tencoding/base32.gox \\\n \tencoding/base64.gox \\\n \tencoding/binary.gox \\\n-\tencoding/line.gox \\\n \tencoding/git85.gox \\\n \tencoding/hex.gox \\\n \tencoding/pem.gox\n@@ -236,13 +243,30 @@ toolexeclibgoexpdir = $(toolexeclibgodir)/exp\n \n toolexeclibgoexp_DATA = \\\n \texp/datafmt.gox \\\n-\texp/draw.gox \\\n-\texp/eval.gox\n+\texp/gui.gox \\\n+\texp/norm.gox \\\n+\texp/regexp.gox\n+\n+toolexeclibgoexpguidir = $(toolexeclibgoexpdir)/gui\n+\n+toolexeclibgoexpgui_DATA = \\\n+\texp/gui/x11.gox\n+\n+toolexeclibgoexpregexpdir = $(toolexeclibgoexpdir)/regexp\n+\n+toolexeclibgoexpregexp_DATA = \\\n+\texp/regexp/syntax.gox\n+\n+toolexeclibgoexptemplatedir = $(toolexeclibgoexpdir)/template\n+\n+toolexeclibgoexptemplate_DATA = \\\n+\texp/template/html.gox\n \n toolexeclibgogodir = $(toolexeclibgodir)/go\n \n toolexeclibgogo_DATA = \\\n \tgo/ast.gox \\\n+\tgo/build.gox \\\n \tgo/doc.gox \\\n \tgo/parser.gox \\\n \tgo/printer.gox \\\n@@ -271,6 +295,8 @@ toolexeclibgohttp_DATA = \\\n toolexeclibgoimagedir = $(toolexeclibgodir)/image\n \n toolexeclibgoimage_DATA = \\\n+\timage/bmp.gox \\\n+\timage/draw.gox \\\n \timage/gif.gox \\\n \timage/jpeg.gox \\\n \timage/png.gox \\\n@@ -298,6 +324,11 @@ toolexeclibgonet_DATA = \\\n \tnet/dict.gox \\\n \tnet/textproto.gox\n \n+toolexeclibgoolddir = $(toolexeclibgodir)/old\n+\n+toolexeclibgoold_DATA = \\\n+\told/template.gox\n+\n toolexeclibgoosdir = $(toolexeclibgodir)/os\n \n if LIBGO_IS_LINUX\n@@ -328,6 +359,11 @@ toolexeclibgoruntime_DATA = \\\n \truntime/debug.gox \\\n \truntime/pprof.gox\n \n+toolexeclibgotemplatedir = $(toolexeclibgodir)/template\n+\n+toolexeclibgotemplate_DATA = \\\n+\ttemplate/parse.gox\n+\n toolexeclibgosyncdir = $(toolexeclibgodir)/sync\n \n toolexeclibgosync_DATA = \\\n@@ -394,6 +430,7 @@ runtime_files = \\\n \truntime/go-panic.c \\\n \truntime/go-panic-defer.c \\\n \truntime/go-print.c \\\n+\truntime/go-rand.c \\\n \truntime/go-rec-big.c \\\n \truntime/go-rec-nb-big.c \\\n \truntime/go-rec-nb-small.c \\\n@@ -519,6 +556,10 @@ go_cmath_files = \\\n go_crypto_files = \\\n \tgo/crypto/crypto.go\n \n+go_csv_files = \\\n+\tgo/csv/reader.go \\\n+\tgo/csv/writer.go\n+\n go_ebnf_files = \\\n \tgo/ebnf/ebnf.go \\\n \tgo/ebnf/parser.go\n@@ -552,9 +593,11 @@ go_hash_files = \\\n \tgo/hash/hash.go\n \n go_html_files = \\\n+\tgo/html/const.go \\\n \tgo/html/doc.go \\\n \tgo/html/entity.go \\\n \tgo/html/escape.go \\\n+\tgo/html/node.go \\\n \tgo/html/parse.go \\\n \tgo/html/token.go\n \n@@ -571,10 +614,10 @@ go_http_files = \\\n \tgo/http/response.go \\\n \tgo/http/reverseproxy.go \\\n \tgo/http/server.go \\\n+\tgo/http/sniff.go \\\n \tgo/http/status.go \\\n \tgo/http/transfer.go \\\n-\tgo/http/transport.go \\\n-\tgo/http/url.go\n+\tgo/http/transport.go\n \n go_image_files = \\\n \tgo/image/color.go \\\n@@ -646,6 +689,9 @@ go_math_files = \\\n \tgo/math/tanh.go \\\n \tgo/math/unsafe.go\n \n+go_mail_files = \\\n+\tgo/mail/message.go\n+\n go_mime_files = \\\n \tgo/mime/grammar.go \\\n \tgo/mime/mediatype.go \\\n@@ -684,31 +730,52 @@ endif\n endif\n endif\n \n+if LIBGO_IS_LINUX\n+go_net_sendfile_file = go/net/sendfile_linux.go\n+else\n+go_net_sendfile_file = go/net/sendfile_stub.go\n+endif\n+\n+if LIBGO_IS_LINUX\n+go_net_interface_file = go/net/interface_linux.go\n+else\n+go_net_interface_file = go/net/interface_stub.go\n+endif\n+\n go_net_files = \\\n \tgo/net/cgo_unix.go \\\n \t$(go_net_cgo_file) \\\n \tgo/net/dial.go \\\n \tgo/net/dnsclient.go \\\n+\tgo/net/dnsclient_unix.go \\\n \tgo/net/dnsconfig.go \\\n \tgo/net/dnsmsg.go \\\n \t$(go_net_newpollserver_file) \\\n \tgo/net/fd.go \\\n \t$(go_net_fd_os_file) \\\n \tgo/net/file.go \\\n \tgo/net/hosts.go \\\n+\tgo/net/interface.go \\\n+\t$(go_net_interface_file) \\\n \tgo/net/ip.go \\\n \tgo/net/iprawsock.go \\\n+\tgo/net/iprawsock_posix.go \\\n \tgo/net/ipsock.go \\\n-\tgo/net/lookup.go \\\n+\tgo/net/ipsock_posix.go \\\n+\tgo/net/lookup_unix.go \\\n \tgo/net/net.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n \tgo/net/port.go \\\n+\t$(go_net_sendfile_file) \\\n \tgo/net/sock.go \\\n \t$(go_net_sock_file) \\\n \tgo/net/tcpsock.go \\\n+\tgo/net/tcpsock_posix.go \\\n \tgo/net/udpsock.go \\\n-\tgo/net/unixsock.go\n+\tgo/net/udpsock_posix.go \\\n+\tgo/net/unixsock.go \\\n+\tgo/net/unixsock_posix.go\n \n go_netchan_files = \\\n \tgo/netchan/common.go \\\n@@ -766,11 +833,14 @@ go_os_files = \\\n \tgo/os/file_unix.go \\\n \tgo/os/getwd.go \\\n \tgo/os/path.go \\\n+\tgo/os/path_unix.go \\\n \tgo/os/proc.go \\\n \tgo/os/stat.go \\\n+\tgo/os/str.go \\\n \t$(go_os_sys_file) \\\n \tgo/os/time.go \\\n-\tgo/os/types.go\n+\tgo/os/types.go \\\n+\tsignal_unix.go\n \n go_patch_files = \\\n \tgo/patch/apply.go \\\n@@ -874,8 +944,12 @@ go_tabwriter_files = \\\n \tgo/tabwriter/tabwriter.go\n \n go_template_files = \\\n-\tgo/template/format.go \\\n-\tgo/template/template.go\n+\tgo/template/doc.go \\\n+\tgo/template/exec.go \\\n+\tgo/template/funcs.go \\\n+\tgo/template/helper.go \\\n+\tgo/template/parse.go \\\n+\tgo/template/set.go\n \n go_testing_files = \\\n \tgo/testing/benchmark.go \\\n@@ -885,8 +959,10 @@ go_time_files = \\\n \tgo/time/format.go \\\n \tgo/time/sleep.go \\\n \tgo/time/sys.go \\\n+\tgo/time/sys_posix.go \\\n \tgo/time/tick.go \\\n \tgo/time/time.go \\\n+\tgo/time/zoneinfo_posix.go \\\n \tgo/time/zoneinfo_unix.go\n \n go_try_files = \\\n@@ -895,9 +971,13 @@ go_try_files = \\\n go_unicode_files = \\\n \tgo/unicode/casetables.go \\\n \tgo/unicode/digit.go \\\n+\tgo/unicode/graphic.go \\\n \tgo/unicode/letter.go \\\n \tgo/unicode/tables.go\n \n+go_url_files = \\\n+\tgo/url/url.go\n+\n go_utf16_files = \\\n \tgo/utf16/utf16.go\n \n@@ -911,6 +991,7 @@ go_websocket_files = \\\n \tgo/websocket/websocket.go\n \n go_xml_files = \\\n+\tgo/xml/marshal.go \\\n \tgo/xml/read.go \\\n \tgo/xml/xml.go\n \n@@ -921,7 +1002,8 @@ go_archive_tar_files = \\\n \n go_archive_zip_files = \\\n \tgo/archive/zip/reader.go \\\n-\tgo/archive/zip/struct.go\n+\tgo/archive/zip/struct.go \\\n+\tgo/archive/zip/writer.go\n \n go_compress_bzip2_files = \\\n \tgo/compress/bzip2/bit_reader.go \\\n@@ -1010,7 +1092,8 @@ go_crypto_openpgp_files = \\\n \tgo/crypto/openpgp/write.go\n go_crypto_rand_files = \\\n \tgo/crypto/rand/rand.go \\\n-\tgo/crypto/rand/rand_unix.go\n+\tgo/crypto/rand/rand_unix.go \\\n+\tgo/crypto/rand/util.go\n go_crypto_rc4_files = \\\n \tgo/crypto/rc4/rc4.go\n go_crypto_ripemd160_files = \\\n@@ -1054,6 +1137,8 @@ go_crypto_xtea_files = \\\n go_crypto_openpgp_armor_files = \\\n \tgo/crypto/openpgp/armor/armor.go \\\n \tgo/crypto/openpgp/armor/encode.go\n+go_crypto_openpgp_elgamal_files = \\\n+\tgo/crypto/openpgp/elgamal/elgamal.go\n go_crypto_openpgp_error_files = \\\n \tgo/crypto/openpgp/error/error.go\n go_crypto_openpgp_packet_files = \\\n@@ -1072,6 +1157,9 @@ go_crypto_openpgp_packet_files = \\\n go_crypto_openpgp_s2k_files = \\\n \tgo/crypto/openpgp/s2k/s2k.go\n \n+go_crypto_x509_pkix_files = \\\n+\tgo/crypto/x509/pkix/pkix.go\n+\n go_debug_dwarf_files = \\\n \tgo/debug/dwarf/buf.go \\\n \tgo/debug/dwarf/const.go \\\n@@ -1092,11 +1180,6 @@ go_debug_pe_files = \\\n \tgo/debug/pe/file.go \\\n \tgo/debug/pe/pe.go\n \n-go_debug_proc_files = \\\n-\tgo/debug/proc/proc.go \\\n-\tgo/debug/proc/proc_$(GOOS).go \\\n-\t$(GO_DEBUG_PROC_REGS_OS_ARCH_FILE)\n-\n go_encoding_ascii85_files = \\\n \tgo/encoding/ascii85/ascii85.go\n go_encoding_base32_files = \\\n@@ -1109,30 +1192,39 @@ go_encoding_git85_files = \\\n \tgo/encoding/git85/git.go\n go_encoding_hex_files = \\\n \tgo/encoding/hex/hex.go\n-go_encoding_line_files = \\\n-\tgo/encoding/line/line.go\n go_encoding_pem_files = \\\n \tgo/encoding/pem/pem.go\n \n go_exp_datafmt_files = \\\n \tgo/exp/datafmt/datafmt.go \\\n \tgo/exp/datafmt/parser.go\n-go_exp_draw_files = \\\n-\tgo/exp/draw/draw.go \\\n-\tgo/exp/draw/event.go\n-go_exp_eval_files = \\\n-\tgo/exp/eval/abort.go \\\n-\tgo/exp/eval/bridge.go \\\n-\tgo/exp/eval/compiler.go \\\n-\tgo/exp/eval/expr.go \\\n-\tgo/exp/eval/expr1.go \\\n-\tgo/exp/eval/func.go \\\n-\tgo/exp/eval/scope.go \\\n-\tgo/exp/eval/stmt.go \\\n-\tgo/exp/eval/type.go \\\n-\tgo/exp/eval/typec.go \\\n-\tgo/exp/eval/value.go \\\n-\tgo/exp/eval/world.go\n+go_exp_gui_files = \\\n+\tgo/exp/gui/gui.go\n+go_exp_norm_files = \\\n+\tgo/exp/norm/composition.go \\\n+\tgo/exp/norm/forminfo.go \\\n+\tgo/exp/norm/normalize.go \\\n+\tgo/exp/norm/tables.go \\\n+\tgo/exp/norm/trie.go\n+go_exp_regexp_files = \\\n+\tgo/exp/regexp/exec.go \\\n+\tgo/exp/regexp/regexp.go\n+\n+go_exp_gui_x11_files = \\\n+\tgo/exp/gui/x11/auth.go \\\n+\tgo/exp/gui/x11/conn.go\n+\n+go_exp_template_html_files = \\\n+\tgo/exp/template/html/context.go \\\n+\tgo/exp/template/html/escape.go\n+\n+go_exp_regexp_syntax_files = \\\n+\tgo/exp/regexp/syntax/compile.go \\\n+\tgo/exp/regexp/syntax/parse.go \\\n+\tgo/exp/regexp/syntax/perl_groups.go \\\n+\tgo/exp/regexp/syntax/prog.go \\\n+\tgo/exp/regexp/syntax/regexp.go \\\n+\tgo/exp/regexp/syntax/simplify.go\n \n go_go_ast_files = \\\n \tgo/go/ast/ast.go \\\n@@ -1141,6 +1233,11 @@ go_go_ast_files = \\\n \tgo/go/ast/resolve.go \\\n \tgo/go/ast/scope.go \\\n \tgo/go/ast/walk.go\n+go_go_build_files = \\\n+\tgo/go/build/build.go \\\n+\tgo/go/build/dir.go \\\n+\tgo/go/build/path.go \\\n+\tsyslist.go\n go_go_doc_files = \\\n \tgo/go/doc/comment.go \\\n \tgo/go/doc/doc.go\n@@ -1162,6 +1259,7 @@ go_go_typechecker_files = \\\n \tgo/go/typechecker/typechecker.go \\\n \tgo/go/typechecker/universe.go\n go_go_types_files = \\\n+\tgo/go/types/check.go \\\n \tgo/go/types/const.go \\\n \tgo/go/types/exportdata.go \\\n \tgo/go/types/gcimporter.go \\\n@@ -1171,7 +1269,8 @@ go_go_types_files = \\\n go_hash_adler32_files = \\\n \tgo/hash/adler32/adler32.go\n go_hash_crc32_files = \\\n-\tgo/hash/crc32/crc32.go\n+\tgo/hash/crc32/crc32.go \\\n+\tgo/hash/crc32/crc32_generic.go\n go_hash_crc64_files = \\\n \tgo/hash/crc64/crc64.go\n go_hash_fnv_files = \\\n@@ -1189,7 +1288,15 @@ go_http_httptest_files = \\\n go_http_pprof_files = \\\n \tgo/http/pprof/pprof.go\n go_http_spdy_files = \\\n-\tgo/http/spdy/protocol.go\n+\tgo/http/spdy/read.go \\\n+\tgo/http/spdy/types.go \\\n+\tgo/http/spdy/write.go\n+\n+go_image_bmp_files = \\\n+\tgo/image/bmp/reader.go\n+\n+go_image_draw_files = \\\n+\tgo/image/draw/draw.go\n \n go_image_gif_files = \\\n \tgo/image/gif/reader.go\n@@ -1223,7 +1330,8 @@ go_io_ioutil_files = \\\n \n go_mime_multipart_files = \\\n \tgo/mime/multipart/formdata.go \\\n-\tgo/mime/multipart/multipart.go\n+\tgo/mime/multipart/multipart.go \\\n+\tgo/mime/multipart/writer.go\n \n go_net_dict_files = \\\n \tgo/net/dict/dict.go\n@@ -1235,6 +1343,12 @@ go_net_textproto_files = \\\n \tgo/net/textproto/textproto.go \\\n \tgo/net/textproto/writer.go\n \n+go_old_template_files = \\\n+\tgo/old/template/doc.go \\\n+\tgo/old/template/execute.go \\\n+\tgo/old/template/format.go \\\n+\tgo/old/template/parse.go\n+\n go_os_inotify_files = \\\n \tgo/os/inotify/inotify_linux.go\n \n@@ -1243,8 +1357,7 @@ go_os_user_files = \\\n \tgo/os/user/lookup_unix.go\n \n go_os_signal_files = \\\n-\tgo/os/signal/signal.go \\\n-\tunix.go\n+\tgo/os/signal/signal.go\n \n go_path_filepath_files = \\\n \tgo/path/filepath/match.go \\\n@@ -1260,6 +1373,12 @@ go_runtime_debug_files = \\\n go_runtime_pprof_files = \\\n \tgo/runtime/pprof/pprof.go\n \n+go_template_parse_files = \\\n+\tgo/template/parse/lex.go \\\n+\tgo/template/parse/node.go \\\n+\tgo/template/parse/parse.go \\\n+\tgo/template/parse/set.go\n+\n go_sync_atomic_files = \\\n \tgo/sync/atomic/doc.go\n go_sync_atomic_c_files = \\\n@@ -1391,6 +1510,13 @@ else # !LIBGO_IS_SOLARIS\n syscall_uname_file = syscalls/syscall_uname.go\n endif\n \n+# Support for netlink sockets and messages.\n+if LIBGO_IS_LINUX\n+syscall_netlink_file = syscalls/netlink_linux.go\n+else\n+syscall_netlink_file =\n+endif\n+\n syscall_arch.go: s-syscall_arch; @true\n s-syscall_arch: Makefile\n \trm -f syscall_arch.go.tmp\n@@ -1407,6 +1533,7 @@ go_syscall_files = \\\n \t$(syscall_exec_os_file) \\\n \t$(syscall_wait_file) \\\n \t$(syscall_filesize_file) \\\n+\t$(syscall_netlink_file) \\\n \t$(syscall_stat_file) \\\n \t$(syscall_sleep_file) \\\n \tsyscalls/socket.go \\\n@@ -1439,6 +1566,7 @@ libgo_go_objs = \\\n \tbytes/index.lo \\\n \tcmath/cmath.lo \\\n \tcrypto/crypto.lo \\\n+\tcsv/csv.lo \\\n \tebnf/ebnf.lo \\\n \texec/exec.lo \\\n \texpvar/expvar.lo \\\n@@ -1453,6 +1581,7 @@ libgo_go_objs = \\\n \tjson/json.lo \\\n \tlog/log.lo \\\n \tmath/math.lo \\\n+\tmail/mail.lo \\\n \tmime/mime.lo \\\n \tnet/net.lo \\\n \tnetchan/netchan.lo \\\n@@ -1477,6 +1606,7 @@ libgo_go_objs = \\\n \ttime/time.lo \\\n \ttry/try.lo \\\n \tunicode/unicode.lo \\\n+\turl/url.lo \\\n \tutf16/utf16.lo \\\n \tutf8/utf8.lo \\\n \twebsocket/websocket.lo \\\n@@ -1518,27 +1648,32 @@ libgo_go_objs = \\\n \tcrypto/x509.lo \\\n \tcrypto/xtea.lo \\\n \tcrypto/openpgp/armor.lo \\\n+\tcrypto/openpgp/elgamal.lo \\\n \tcrypto/openpgp/error.lo \\\n \tcrypto/openpgp/packet.lo \\\n \tcrypto/openpgp/s2k.lo \\\n+\tcrypto/x509/pkix.lo \\\n \tdebug/dwarf.lo \\\n \tdebug/elf.lo \\\n \tdebug/gosym.lo \\\n \tdebug/macho.lo \\\n \tdebug/pe.lo \\\n-\tdebug/proc.lo \\\n \tencoding/ascii85.lo \\\n \tencoding/base32.lo \\\n \tencoding/base64.lo \\\n \tencoding/binary.lo \\\n \tencoding/git85.lo \\\n \tencoding/hex.lo \\\n-\tencoding/line.lo \\\n \tencoding/pem.lo \\\n \texp/datafmt.lo \\\n-\texp/draw.lo \\\n-\texp/eval.lo \\\n+\texp/gui.lo \\\n+\texp/norm.lo \\\n+\texp/regexp.lo \\\n+\texp/gui/x11.lo \\\n+\texp/regexp/syntax.lo \\\n+\texp/template/html.lo \\\n \tgo/ast.lo \\\n+\tgo/build.lo \\\n \tgo/doc.lo \\\n \tgo/parser.lo \\\n \tgo/printer.lo \\\n@@ -1555,6 +1690,8 @@ libgo_go_objs = \\\n \thttp/httptest.lo \\\n \thttp/pprof.lo \\\n \thttp/spdy.lo \\\n+\timage/bmp.lo \\\n+\timage/draw.lo \\\n \timage/gif.lo \\\n \timage/jpeg.lo \\\n \timage/png.lo \\\n@@ -1565,6 +1702,7 @@ libgo_go_objs = \\\n \tmime/multipart.lo \\\n \tnet/dict.lo \\\n \tnet/textproto.lo \\\n+\told/template.lo \\\n \t$(os_lib_inotify_lo) \\\n \tos/user.lo \\\n \tos/signal.lo \\\n@@ -1576,6 +1714,7 @@ libgo_go_objs = \\\n \tsync/atomic_c.lo \\\n \tsyscalls/syscall.lo \\\n \tsyscalls/errno.lo \\\n+\ttemplate/parse.lo \\\n \ttesting/testing.lo \\\n \ttesting/iotest.lo \\\n \ttesting/quick.lo \\\n@@ -1647,18 +1786,6 @@ CHECK = \\\n \t  fi; \\\n \tfi\n \n-# Check a package that is only tested if GCCGO_RUN_ALL_TESTS is set.\n-CHECK_ON_REQUEST = \\\n-\tif test \"$$GCCGO_RUN_ALL_TESTS\" != \"\"; then \\\n-\t  $(CHECK); \\\n-\telse \\\n-\t  rm -f $@-testsum $@-testlog; \\\n-\t  echo \"Set GCCGO_RUN_ALL_TESTS in environment to run $(@D) test\" > $@-testlog; \\\n-\t  echo \"UNTESTED: $(@D)\" >> $@-testlog; \\\n-\t  echo \"UNTESTED: $(@D)\"; \\\n-\t  echo \"UNTESTED: $(@D)\" > $@-testsum; \\\n-\tfi\n-\n # Build all packages before checking any.\n CHECK_DEPS = libgo.la libgobegin.a \\\n \t$(toolexeclibgo_DATA) \\\n@@ -1685,14 +1812,15 @@ CHECK_DEPS = libgo.la libgobegin.a \\\n \t$(toolexeclibgosync_DATA) \\\n \t$(toolexeclibgotesting_DATA)\n \n-asn1/asn1.lo: $(go_asn1_files) bytes.gox fmt.gox io.gox os.gox reflect.gox \\\n-\t\tstrconv.gox strings.gox time.gox\n+asn1/asn1.lo: $(go_asn1_files) big.gox bytes.gox fmt.gox io.gox os.gox \\\n+\t\treflect.gox strconv.gox strings.gox time.gox\n \t$(BUILDPACKAGE)\n asn1/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: asn1/check\n \n-big/big.lo: $(go_big_files) fmt.gox rand.gox strings.gox os.gox\n+big/big.lo: $(go_big_files) encoding/binary.gox fmt.gox io.gox os.gox \\\n+\t\trand.gox strings.gox\n \t$(BUILDPACKAGE)\n big/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -1724,14 +1852,22 @@ crypto/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/check\n \n+csv/csv.lo: $(go_csv_files) bufio.gox bytes.gox fmt.gox io.gox os.gox \\\n+\t\tstrings.gox unicode.gox utf8.gox\n+\t$(BUILDPACKAGE)\n+csv/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: csv/check\n+\n ebnf/ebnf.lo: $(go_ebnf_files) container/vector.gox go/scanner.gox \\\n \t\tgo/token.gox os.gox strconv.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n ebnf/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: ebnf/check\n \n-exec/exec.lo: $(go_exec_files) os.gox strconv.gox strings.gox\n+exec/exec.lo: $(go_exec_files) bytes.gox io.gox os.gox strconv.gox \\\n+\t\tstrings.gox syscall.gox\n \t$(BUILDPACKAGE)\n exec/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -1779,11 +1915,11 @@ html/check: $(CHECK_DEPS)\n .PHONY: html/check\n \n http/http.lo: $(go_http_files) bufio.gox bytes.gox compress/gzip.gox \\\n-\t\tcontainer/vector.gox crypto/rand.gox crypto/tls.gox \\\n-\t\tencoding/base64.gox fmt.gox io.gox io/ioutil.gox log.gox \\\n+\t\tcrypto/rand.gox crypto/tls.gox encoding/base64.gox \\\n+\t\tencoding/binary.gox fmt.gox io.gox io/ioutil.gox log.gox \\\n \t\tmime.gox mime/multipart.gox net.gox net/textproto.gox os.gox \\\n-\t\tpath.gox path/filepath.gox sort.gox strconv.gox strings.gox \\\n-\t\tsync.gox time.gox utf8.gox\n+\t\tpath.gox path/filepath.gox runtime/debug.gox sort.gox \\\n+\t\tstrconv.gox strings.gox sync.gox time.gox url.gox utf8.gox\n \t$(BUILDPACKAGE)\n http/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -1801,10 +1937,9 @@ io/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: io/check\n \n-json/json.lo: $(go_json_files) bytes.gox container/vector.gox \\\n-\t\tencoding/base64.gox fmt.gox io.gox math.gox os.gox \\\n-\t\treflect.gox runtime.gox strconv.gox strings.gox unicode.gox \\\n-\t\tutf16.gox utf8.gox\n+json/json.lo: $(go_json_files) bytes.gox encoding/base64.gox fmt.gox io.gox \\\n+\t\tmath.gox os.gox reflect.gox runtime.gox strconv.gox \\\n+\t\tstrings.gox unicode.gox utf16.gox utf8.gox\n \t$(BUILDPACKAGE)\n json/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -1823,6 +1958,14 @@ math/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: math/check\n \n+mail/mail.lo: $(go_mail_files) bufio.gox bytes.gox encoding/base64.gox \\\n+\t\tfmt.gox io.gox io/ioutil.gox log.gox net/textproto.gox os.gox \\\n+\t\tstrconv.gox strings.gox time.gox\n+\t$(BUILDPACKAGE)\n+mail/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: mail/check\n+\n mime/mime.lo: $(go_mime_files) bufio.gox bytes.gox fmt.gox os.gox strings.gox \\\n \t\tsync.gox unicode.gox\n \t$(BUILDPACKAGE)\n@@ -1835,7 +1978,7 @@ net/net.lo: $(go_net_files) bytes.gox fmt.gox io.gox os.gox rand.gox \\\n \t\tsyscall.gox time.gox\n \t$(BUILDPACKAGE)\n net/check: $(CHECK_DEPS)\n-\t@$(CHECK_ON_REQUEST)\n+\t@$(CHECK)\n .PHONY: net/check\n \n netchan/netchan.lo: $(go_netchan_files) gob.gox io.gox log.gox net.gox os.gox \\\n@@ -1851,6 +1994,10 @@ os/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: os/check\n \n+signal_unix.go: $(srcdir)/go/os/mkunixsignals.sh sysinfo.go\n+\t$(SHELL) $(srcdir)/go/os/mkunixsignals.sh sysinfo.go > $@.tmp\n+\tmv -f $@.tmp $@\n+\n patch/patch.lo: $(go_patch_files) bytes.gox compress/zlib.gox \\\n \t\tcrypto/sha1.gox encoding/git85.gox fmt.gox io.gox os.gox \\\n \t\tpath.gox strings.gox\n@@ -1913,7 +2060,7 @@ smtp/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: smtp/check\n \n-sort/sort.lo: $(go_sort_files)\n+sort/sort.lo: $(go_sort_files) math.gox\n \t$(BUILDPACKAGE)\n sort/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -1943,7 +2090,7 @@ syslog/syslog.lo: $(go_syslog_files) fmt.gox log.gox net.gox os.gox syscall.gox\n syslog/syslog_c.lo: $(go_syslog_c_files) syslog/syslog.lo\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/syslog/syslog_c.c\n syslog/check: $(CHECK_DEPS)\n-\t@$(CHECK_ON_REQUEST)\n+\t@$(CHECK)\n .PHONY: syslog/check\n \n tabwriter/tabwriter.lo: $(go_tabwriter_files) bytes.gox io.gox os.gox utf8.gox\n@@ -1952,15 +2099,17 @@ tabwriter/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: tabwriter/check\n \n-template/template.lo: $(go_template_files) bytes.gox fmt.gox io.gox os.gox \\\n-\t\treflect.gox runtime.gox strings.gox container/vector.gox\n+template/template.lo: $(go_template_files) bytes.gox fmt.gox io.gox \\\n+\t\tio/ioutil.gox os.gox path/filepath.gox reflect.gox \\\n+\t\truntime.gox strings.gox template/parse.gox unicode.gox \\\n+\t\turl.gox utf8.gox\n \t$(BUILDPACKAGE)\n template/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: template/check\n \n testing/testing.lo: $(go_testing_files) flag.gox fmt.gox os.gox regexp.gox \\\n-\t\truntime.gox runtime/pprof.gox time.gox\n+\t\truntime.gox runtime/pprof.gox strings.gox strconv.gox time.gox\n \t$(BUILDPACKAGE)\n testing/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -1985,6 +2134,12 @@ unicode/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: unicode/check\n \n+url/url.lo: $(go_url_files) os.gox strconv.gox strings.gox\n+\t$(BUILDPACKAGE)\n+url/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: url/check\n+\n utf16/utf16.lo: $(go_utf16_files) unicode.gox\n \t$(BUILDPACKAGE)\n utf16/check: $(CHECK_DEPS)\n@@ -1998,9 +2153,8 @@ utf8/check: $(CHECK_DEPS)\n .PHONY: utf8/check\n \n websocket/websocket.lo: $(go_websocket_files) bufio.gox bytes.gox \\\n-\t\tcontainer/vector.gox crypto/md5.gox crypto/tls.gox \\\n-\t\tencoding/binary.gox fmt.gox http.gox io.gox net.gox os.gox \\\n-\t\trand.gox strings.gox\n+\t\tcrypto/md5.gox crypto/tls.gox encoding/binary.gox fmt.gox \\\n+\t\thttp.gox io.gox net.gox os.gox rand.gox strings.gox url.gox\n \t$(BUILDPACKAGE)\n websocket/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -2021,9 +2175,9 @@ archive/tar/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: archive/tar/check\n \n-archive/zip.lo: $(go_archive_zip_files) bufio.gox bytes.gox \\\n-\t\tcompress/flate.gox hash.gox hash/crc32.gox \\\n-\t\tencoding/binary.gox io.gox io/ioutil.gox os.gox\n+archive/zip.lo: $(go_archive_zip_files) bufio.gox compress/flate.gox \\\n+\t\tencoding/binary.gox hash.gox hash/crc32.gox \\\n+\t\tencoding/binary.gox io.gox io/ioutil.gox os.gox time.gox\n \t$(BUILDPACKAGE)\n archive/zip/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) archive/zip\n@@ -2176,25 +2330,27 @@ crypto/md5/check: $(CHECK_DEPS)\n .PHONY: crypto/md5/check\n \n crypto/ocsp.lo: $(go_crypto_ocsp_files) asn1.gox crypto.gox crypto/rsa.gox \\\n-\t\tcrypto/sha1.gox crypto/x509.gox os.gox time.gox\n+\t\tcrypto/sha1.gox crypto/x509.gox crypto/x509/pkix.gox os.gox \\\n+\t\ttime.gox\n \t$(BUILDPACKAGE)\n crypto/ocsp/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/ocsp\n \t@$(CHECK)\n .PHONY: crypto/ocsp/check\n \n-crypto/openpgp.lo: $(go_crypto_openpgp_files) crypto.gox crypto/dsa.gox \\\n+crypto/openpgp.lo: $(go_crypto_openpgp_files) crypto.gox \\\n \t\tcrypto/openpgp/armor.gox crypto/openpgp/error.gox \\\n-\t\tcrypto/openpgp/packet.gox crypto/rsa.gox crypto/sha256.gox \\\n-\t\thash.gox io.gox os.gox strconv.gox time.gox\n+\t\tcrypto/openpgp/packet.gox crypto/openpgp/s2k.gox \\\n+\t\tcrypto/rand.gox crypto/rsa.gox crypto/sha256.gox hash.gox \\\n+\t\tio.gox os.gox strconv.gox time.gox\n \t$(BUILDPACKAGE)\n crypto/openpgp/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/openpgp\n \t@$(CHECK)\n .PHONY: crypto/openpgp/check\n \n-crypto/rand.lo: $(go_crypto_rand_files) bufio.gox crypto/aes.gox io.gox \\\n-\t\tos.gox sync.gox time.gox\n+crypto/rand.lo: $(go_crypto_rand_files) big.gox bufio.gox crypto/aes.gox \\\n+\t\tio.gox os.gox sync.gox time.gox\n \t$(BUILDPACKAGE)\n crypto/rand/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/rand\n@@ -2215,8 +2371,9 @@ crypto/ripemd160/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/ripemd160/check\n \n-crypto/rsa.lo: $(go_crypto_rsa_files) big.gox crypto.gox crypto/sha1.gox \\\n-\t\tcrypto/subtle.gox encoding/hex.gox hash.gox io.gox os.gox\n+crypto/rsa.lo: $(go_crypto_rsa_files) big.gox crypto.gox crypto/rand.gox \\\n+\t\tcrypto/sha1.gox crypto/subtle.gox encoding/hex.gox hash.gox \\\n+\t\tio.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/rsa/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/rsa\n@@ -2255,9 +2412,9 @@ crypto/tls.lo: $(go_crypto_tls_files) big.gox bytes.gox crypto.gox \\\n \t\tcrypto/aes.gox crypto/cipher.gox crypto/elliptic.gox \\\n \t\tcrypto/hmac.gox crypto/md5.gox crypto/rand.gox crypto/rc4.gox \\\n \t\tcrypto/rsa.gox crypto/sha1.gox crypto/subtle.gox \\\n-\t\tcrypto/x509.gox encoding/pem.gox hash.gox io.gox \\\n-\t\tio/ioutil.gox net.gox os.gox strconv.gox strings.gox sync.gox \\\n-\t\ttime.gox\n+\t\tcrypto/x509.gox crypto/x509/pkix.gox encoding/pem.gox \\\n+\t\thash.gox io.gox io/ioutil.gox net.gox os.gox strconv.gox \\\n+\t\tstrings.gox sync.gox time.gox\n \t$(BUILDPACKAGE)\n crypto/tls/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/tls\n@@ -2271,9 +2428,9 @@ crypto/twofish/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/twofish/check\n \n-crypto/x509.lo: $(go_crypto_x509_files) asn1.gox big.gox bytes.gox \\\n-\t\tcontainer/vector.gox crypto.gox crypto/rsa.gox \\\n-\t\tcrypto/sha1.gox encoding/pem.gox hash.gox os.gox strings.gox \\\n+crypto/x509.lo: $(go_crypto_x509_files) asn1.gox big.gox bytes.gox crypto.gox \\\n+\t\tcrypto/dsa.gox crypto/rsa.gox crypto/sha1.gox \\\n+\t\tcrypto/x509/pkix.gox encoding/pem.gox os.gox strings.gox \\\n \t\ttime.gox\n \t$(BUILDPACKAGE)\n crypto/x509/check: $(CHECK_DEPS)\n@@ -2296,6 +2453,14 @@ crypto/openpgp/armor/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/openpgp/armor/check\n \n+crypto/openpgp/elgamal.lo: $(go_crypto_openpgp_elgamal_files) big.gox \\\n+\t\tcrypto/rand.gox crypto/subtle.gox io.gox os.gox\n+\t$(BUILDPACKAGE)\n+crypto/openpgp/elgamal/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/openpgp/elgamal\n+\t@$(CHECK)\n+.PHONY: crypto/openpgp/elgamal/check\n+\n crypto/openpgp/error.lo: $(go_crypto_openpgp_error_files) strconv.gox\n \t$(BUILDPACKAGE)\n crypto/openpgp/error/check: $(CHECK_DEPS)\n@@ -2306,9 +2471,10 @@ crypto/openpgp/error/check: $(CHECK_DEPS)\n crypto/openpgp/packet.lo: $(go_crypto_openpgp_packet_files) big.gox bytes.gox \\\n \t\tcompress/flate.gox compress/zlib.gox crypto.gox \\\n \t\tcrypto/aes.gox crypto/cast5.gox crypto/cipher.gox \\\n-\t\tcrypto/dsa.gox crypto/openpgp/error.gox \\\n-\t\tcrypto/openpgp/s2k.gox crypto/rand.gox crypto/rsa.gox \\\n-\t\tcrypto/sha1.gox crypto/subtle.gox encoding/binary.gox fmt.gox \\\n+\t\tcrypto/dsa.gox crypto/openpgp/elgamal.gox \\\n+\t\tcrypto/openpgp/error.gox crypto/openpgp/s2k.gox \\\n+\t\tcrypto/rand.gox crypto/rsa.gox crypto/sha1.gox \\\n+\t\tcrypto/subtle.gox encoding/binary.gox fmt.gox \\\n \t\thash.gox io.gox io/ioutil.gox os.gox strconv.gox strings.gox\n \t$(BUILDPACKAGE)\n crypto/openpgp/packet/check: $(CHECK_DEPS)\n@@ -2317,15 +2483,22 @@ crypto/openpgp/packet/check: $(CHECK_DEPS)\n .PHONY: crypto/openpgp/packet/check\n \n crypto/openpgp/s2k.lo: $(go_crypto_openpgp_s2k_files) crypto.gox \\\n-\t\tcrypto/md5.gox crypto/openpgp/error.gox crypto/ripemd160.gox \\\n-\t\tcrypto/sha1.gox crypto/sha256.gox crypto/sha512.gox hash.gox \\\n-\t\tio.gox os.gox\n+\t\tcrypto/md5.gox crypto/openpgp/error.gox crypto/rand.gox \\\n+\t\tcrypto/ripemd160.gox crypto/sha1.gox crypto/sha256.gox \\\n+\t\tcrypto/sha512.gox hash.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/openpgp/s2k/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/openpgp/s2k\n \t@$(CHECK)\n .PHONY: crypto/openpgp/s2k/check\n \n+crypto/x509/pkix.lo: $(go_crypto_x509_pkix_files) asn1.gox big.gox time.gox\n+\t$(BUILDPACKAGE)\n+crypto/x509/pkix/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/x509/pkix\n+\t@$(CHECK)\n+.PHONY: crypto/x509/pkix/check\n+\n debug/dwarf.lo: $(go_debug_dwarf_files) encoding/binary.gox os.gox strconv.gox\n \t$(BUILDPACKAGE)\n debug/dwarf/check: $(CHECK_DEPS)\n@@ -2365,15 +2538,6 @@ debug/pe/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: debug/pe/check\n \n-debug/proc.lo: $(go_debug_proc_files) container/vector.gox fmt.gox \\\n-\t\tio/ioutil.gox os.gox runtime.gox strconv.gox strings.gox \\\n-\t\tsync.gox syscall.gox\n-\t$(BUILDPACKAGE)\n-debug/proc/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) debug/proc\n-\t@$(CHECK)\n-.PHONY: debug/proc/check\n-\n encoding/ascii85.lo: $(go_encoding_ascii85_files) io.gox os.gox strconv.gox\n \t$(BUILDPACKAGE)\n encoding/ascii85/check: $(CHECK_DEPS)\n@@ -2411,60 +2575,101 @@ encoding/git85/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: encoding/git85/check\n \n-encoding/hex.lo: $(go_encoding_hex_files) os.gox strconv.gox\n+encoding/hex.lo: $(go_encoding_hex_files) bytes.gox io.gox os.gox strconv.gox\n \t$(BUILDPACKAGE)\n encoding/hex/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) encoding/hex\n \t@$(CHECK)\n .PHONY: encoding/hex/check\n \n-encoding/line.lo: $(go_encoding_line_files) io.gox os.gox\n-\t$(BUILDPACKAGE)\n-encoding/line/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) encoding/line\n-\t@$(CHECK)\n-.PHONY: encoding/line/check\n-\n encoding/pem.lo: $(go_encoding_pem_files) bytes.gox encoding/base64.gox\n \t$(BUILDPACKAGE)\n encoding/pem/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) encoding/pem\n \t@$(CHECK)\n .PHONY: encoding/pem/check\n \n-exp/datafmt.lo: $(go_exp_datafmt_files) bytes.gox container/vector.gox \\\n-\t\tfmt.gox go/scanner.gox go/token.gox io.gox os.gox reflect.gox \\\n-\t\truntime.gox strconv.gox strings.gox\n+exp/datafmt.lo: $(go_exp_datafmt_files) bytes.gox fmt.gox go/scanner.gox \\\n+\t\tgo/token.gox io.gox os.gox reflect.gox runtime.gox \\\n+\t\tstrconv.gox strings.gox\n \t$(BUILDPACKAGE)\n exp/datafmt/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) exp/datafmt\n \t@$(CHECK)\n .PHONY: exp/datafmt/check\n \n-exp/draw.lo: $(go_exp_draw_files) image.gox image/ycbcr.gox os.gox\n+exp/gui.lo: $(go_exp_gui_files) image.gox image/draw.gox os.gox\n+\t$(BUILDPACKAGE)\n+exp/gui/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/gui\n+\t@$(CHECK)\n+.PHONY: exp/gui/check\n+\n+exp/norm.lo: $(go_exp_norm_files) utf8.gox\n+\t$(BUILDPACKAGE)\n+exp/norm/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/norm\n+\t@$(CHECK)\n+.PHONY: exp/norm/check\n+\n+exp/regexp.lo: $(go_exp_regexp_files) bytes.gox exp/regexp/syntax.gox io.gox \\\n+\t\tos.gox strings.gox sync.gox utf8.gox\n+\t$(BUILDPACKAGE)\n+exp/regexp/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/regexp\n+\t@$(CHECK)\n+.PHONY: exp/regexp/check\n+\n+exp/gui/x11.lo: $(go_exp_gui_x11_files) bufio.gox exp/gui.gox image.gox \\\n+\t\timage/draw.gox io.gox log.gox net.gox os.gox strconv.gox \\\n+\t\tstrings.gox time.gox\n+\t$(BUILDPACKAGE)\n+exp/gui/x11/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/gui/x11\n+\t@$(CHECK)\n+.PHONY: exp/gui/x11/check\n+\n+exp/regexp/syntax.lo: $(go_exp_regexp_syntax_files) bytes.gox os.gox sort.gox strconv.gox strings.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n-exp/draw/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/draw\n+exp/regexp/syntax/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/regexp/syntax\n \t@$(CHECK)\n-.PHONY: exp/draw/check\n+.PHONY: exp/regexp/syntax/check\n \n-exp/eval.lo: $(go_exp_eval_files) big.gox go/ast.gox go/parser.gox \\\n-\t\tgo/scanner.gox go/token.gox fmt.gox log.gox strconv.gox \\\n-\t\tstrings.gox os.gox reflect.gox runtime.gox sort.gox template.gox\n+exp/template/html.lo: $(go_exp_template_html_files) fmt.gox template.gox \\\n+\t\ttemplate/parse.gox\n \t$(BUILDPACKAGE)\n-exp/eval/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/eval\n+exp/template/html/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/template/html\n \t@$(CHECK)\n-.PHONY: exp/eval/check\n+.PHONY: exp/template/html/check\n \n go/ast.lo: $(go_go_ast_files) bytes.gox fmt.gox go/scanner.gox go/token.gox \\\n-\t\tio.gox os.gox reflect.gox unicode.gox utf8.gox\n+\t\tio.gox os.gox reflect.gox strconv.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n go/ast/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/ast\n \t@$(CHECK)\n .PHONY: go/ast/check\n \n+go/build.lo: $(go_go_build_files) bytes.gox exec.gox fmt.gox go/parser.gox \\\n+\t\tgo/token.gox log.gox os.gox path/filepath.gox regexp.gox \\\n+\t\truntime.gox strconv.gox strings.gox runtime.gox\n+\t$(BUILDPACKAGE)\n+go/build/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) go/build\n+\t@$(CHECK)\n+.PHONY: go/build/check\n+\n+syslist.go: s-syslist; @true\n+s-syslist: Makefile\n+\techo '// Generated automatically by make.' >syslist.go.tmp\n+\techo 'package build' >>syslist.go.tmp\n+\techo 'const goosList = \"$(GOOS)\"' >>syslist.go.tmp\n+\techo 'const goarchList = \"$(GOARCH)\"' >>syslist.go.tmp\n+\t$(SHELL) $(srcdir)/../move-if-change syslist.go.tmp syslist.go\n+\t$(STAMP) $@\n+\n go/doc.lo: $(go_go_doc_files) go/ast.gox go/token.gox io.gox regexp.gox \\\n \t\tsort.gox strings.gox template.gox\n \t$(BUILDPACKAGE)\n@@ -2491,9 +2696,9 @@ go/printer/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/printer/check\n \n-go/scanner.lo: $(go_go_scanner_files) bytes.gox container/vector.gox fmt.gox \\\n-\t\tgo/token.gox io.gox os.gox path/filepath.gox sort.gox \\\n-\t\tstrconv.gox unicode.gox utf8.gox\n+go/scanner.lo: $(go_go_scanner_files) bytes.gox fmt.gox go/token.gox io.gox \\\n+\t\tos.gox path/filepath.gox sort.gox strconv.gox unicode.gox \\\n+\t\tutf8.gox\n \t$(BUILDPACKAGE)\n go/scanner/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/scanner\n@@ -2517,7 +2722,7 @@ go/typechecker/check: $(CHECK_DEPS)\n \n go/types.lo: $(go_go_types_files) big.gox bufio.gox fmt.gox go/ast.gox \\\n \t\tgo/token.gox io.gox os.gox path/filepath.gox runtime.gox \\\n-\t\tscanner.gox strconv.gox strings.gox\n+\t\tscanner.gox sort.gox strconv.gox strings.gox\n \t$(BUILDPACKAGE)\n go/types/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/types\n@@ -2531,7 +2736,7 @@ hash/adler32/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: hash/adler32/check\n \n-hash/crc32.lo: $(go_hash_crc32_files) hash.gox os.gox\n+hash/crc32.lo: $(go_hash_crc32_files) hash.gox os.gox sync.gox\n \t$(BUILDPACKAGE)\n hash/crc32/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) hash/crc32\n@@ -2552,10 +2757,9 @@ hash/fnv/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: hash/fnv/check\n \n-http/cgi.lo: $(go_http_cgi_files) bufio.gox bytes.gox crypto/tls.gox \\\n-\t\texec.gox fmt.gox http.gox net.gox io.gox io/ioutil.gox \\\n-\t\tlog.gox os.gox path/filepath.gox regexp.gox strconv.gox \\\n-\t\tstrings.gox\n+http/cgi.lo: $(go_http_cgi_files) bufio.gox crypto/tls.gox exec.gox fmt.gox \\\n+\t\thttp.gox net.gox io.gox io/ioutil.gox log.gox os.gox \\\n+\t\tpath/filepath.gox regexp.gox strconv.gox strings.gox url.gox\n \t$(BUILDPACKAGE)\n http/cgi/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) http/cgi\n@@ -2572,7 +2776,8 @@ http/fcgi/check: $(CHECK_DEPS)\n .PHONY: http/fcgi/check\n \n http/httptest.lo: $(go_http_httptest_files) bytes.gox crypto/rand.gox \\\n-\t\tcrypto/tls.gox fmt.gox http.gox net.gox os.gox time.gox\n+\t\tcrypto/tls.gox flag.gox fmt.gox http.gox net.gox os.gox \\\n+\t\ttime.gox\n \t$(BUILDPACKAGE)\n http/httptest/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) http/httptest\n@@ -2596,6 +2801,20 @@ http/spdy/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: http/spdy/check\n \n+image/bmp.lo: $(go_image_bmp_files) image.gox io.gox os.gox\n+\t$(BUILDPACKAGE)\n+image/bmp/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) image/bmp\n+\t@$(CHECK)\n+.PHONY: image/bmp/check\n+\n+image/draw.lo: $(go_image_draw_files) image.gox image/ycbcr.gox\n+\t$(BUILDPACKAGE)\n+image/draw/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) image/draw\n+\t@$(CHECK)\n+.PHONY: image/draw/check\n+\n image/gif.lo: $(go_image_gif_files) bufio.gox compress/lzw.gox fmt.gox \\\n \t\timage.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n@@ -2651,28 +2870,36 @@ io/ioutil/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: io/ioutil/check\n \n-mime/multipart.lo: $(go_mime_multipart_files) bufio.gox bytes.gox fmt.gox \\\n-\t\tio.gox io/ioutil.gox mime.gox net/textproto.gox os.gox \\\n-\t\tregexp.gox\n+mime/multipart.lo: $(go_mime_multipart_files) bufio.gox bytes.gox \\\n+\t\tcrypto/rand.gox fmt.gox io.gox io/ioutil.gox mime.gox \\\n+\t\tnet/textproto.gox os.gox strings.gox\n \t$(BUILDPACKAGE)\n mime/multipart/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) mime/multipart\n \t@$(CHECK)\n .PHONY: mime/multipart/check\n \n-net/dict.lo: $(go_net_dict_files) container/vector.gox net/textproto.gox \\\n-\t\tos.gox strconv.gox strings.gox\n+net/dict.lo: $(go_net_dict_files) net/textproto.gox os.gox strconv.gox \\\n+\t\tstrings.gox\n \t$(BUILDPACKAGE)\n \n-net/textproto.lo: $(go_net_textproto_files) bufio.gox bytes.gox \\\n-\t\tcontainer/vector.gox fmt.gox io.gox io/ioutil.gox net.gox \\\n-\t\tos.gox strconv.gox sync.gox\n+net/textproto.lo: $(go_net_textproto_files) bufio.gox bytes.gox fmt.gox \\\n+\t\tio.gox io/ioutil.gox net.gox os.gox strconv.gox sync.gox\n \t$(BUILDPACKAGE)\n net/textproto/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) net/textproto\n \t@$(CHECK)\n .PHONY: net/textproto/check\n \n+old/template.lo: $(go_old_template_files) bytes.gox fmt.gox io.gox \\\n+\t\tio/ioutil.gox os.gox reflect.gox strconv.gox strings.gox \\\n+\t\tunicode.gox utf8.gox\n+\t$(BUILDPACKAGE)\n+old/template/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) old/template\n+\t@$(CHECK)\n+.PHONY: old/template/check\n+\n os/inotify.lo: $(go_os_inotify_files) fmt.gox os.gox strings.gox syscall.gox\n \t$(BUILDPACKAGE)\n os/inotify/check: $(CHECK_DEPS)\n@@ -2688,19 +2915,15 @@ os/user/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: os/user/check\n \n-os/signal.lo: $(go_os_signal_files) runtime.gox strconv.gox\n+os/signal.lo: $(go_os_signal_files) os.gox runtime.gox\n \t$(BUILDPACKAGE)\n os/signal/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) os/signal\n \t@$(CHECK)\n .PHONY: os/signal/check\n \n-unix.go: $(srcdir)/go/os/signal/mkunix.sh sysinfo.go\n-\t$(SHELL) $(srcdir)/go/os/signal/mkunix.sh sysinfo.go > $@.tmp\n-\tmv -f $@.tmp $@\n-\n-path/filepath.lo: $(go_path_filepath_files) bytes.gox os.gox sort.gox \\\n-\t\tstrings.gox utf8.gox\n+path/filepath.lo: $(go_path_filepath_files) bytes.gox os.gox runtime.gox \\\n+\t\tsort.gox strings.gox utf8.gox\n \t$(BUILDPACKAGE)\n path/filepath/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) path/filepath\n@@ -2740,6 +2963,14 @@ sync/atomic/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: sync/atomic/check\n \n+template/parse.lo: $(go_template_parse_files) bytes.gox fmt.gox os.gox \\\n+\t\truntime.gox strconv.gox strings.gox unicode.gox utf8.gox\n+\t$(BUILDPACKAGE)\n+template/parse/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) template/parse\n+\t@$(CHECK)\n+.PHONY: template/parse/check\n+\n testing/iotest.lo: $(go_testing_iotest_files) io.gox log.gox os.gox\n \t$(BUILDPACKAGE)\n testing/iotest/check: $(CHECK_DEPS)\n@@ -2791,6 +3022,8 @@ cmath.gox: cmath/cmath.lo\n \t$(BUILDGOX)\n crypto.gox: crypto/crypto.lo\n \t$(BUILDGOX)\n+csv.gox: csv/csv.lo\n+\t$(BUILDGOX)\n ebnf.gox: ebnf/ebnf.lo\n \t$(BUILDGOX)\n exec.gox: exec/exec.lo\n@@ -2819,6 +3052,8 @@ log.gox: log/log.lo\n \t$(BUILDGOX)\n math.gox: math/math.lo\n \t$(BUILDGOX)\n+mail.gox: mail/mail.lo\n+\t$(BUILDGOX)\n mime.gox: mime/mime.lo\n \t$(BUILDGOX)\n net.gox: net/net.lo\n@@ -2869,6 +3104,8 @@ try.gox: try/try.lo\n \t$(BUILDGOX)\n unicode.gox: unicode/unicode.lo\n \t$(BUILDGOX)\n+url.gox: url/url.lo\n+\t$(BUILDGOX)\n utf16.gox: utf16/utf16.lo\n \t$(BUILDGOX)\n utf8.gox: utf8/utf8.lo\n@@ -2956,13 +3193,18 @@ crypto/xtea.gox: crypto/xtea.lo\n \n crypto/openpgp/armor.gox: crypto/openpgp/armor.lo\n \t$(BUILDGOX)\n+crypto/openpgp/elgamal.gox: crypto/openpgp/elgamal.lo\n+\t$(BUILDGOX)\n crypto/openpgp/error.gox: crypto/openpgp/error.lo\n \t$(BUILDGOX)\n crypto/openpgp/packet.gox: crypto/openpgp/packet.lo\n \t$(BUILDGOX)\n crypto/openpgp/s2k.gox: crypto/openpgp/s2k.lo\n \t$(BUILDGOX)\n \n+crypto/x509/pkix.gox: crypto/x509/pkix.lo\n+\t$(BUILDGOX)\n+\n debug/dwarf.gox: debug/dwarf.lo\n \t$(BUILDGOX)\n debug/elf.gox: debug/elf.lo\n@@ -2973,8 +3215,6 @@ debug/macho.gox: debug/macho.lo\n \t$(BUILDGOX)\n debug/pe.gox: debug/pe.lo\n \t$(BUILDGOX)\n-debug/proc.gox: debug/proc.lo\n-\t$(BUILDGOX)\n \n encoding/ascii85.gox: encoding/ascii85.lo\n \t$(BUILDGOX)\n@@ -2988,20 +3228,31 @@ encoding/git85.gox: encoding/git85.lo\n \t$(BUILDGOX)\n encoding/hex.gox: encoding/hex.lo\n \t$(BUILDGOX)\n-encoding/line.gox: encoding/line.lo\n-\t$(BUILDGOX)\n encoding/pem.gox: encoding/pem.lo\n \t$(BUILDGOX)\n \n exp/datafmt.gox: exp/datafmt.lo\n \t$(BUILDGOX)\n-exp/draw.gox: exp/draw.lo\n+exp/gui.gox: exp/gui.lo\n+\t$(BUILDGOX)\n+exp/norm.gox: exp/norm.lo\n+\t$(BUILDGOX)\n+exp/regexp.gox: exp/regexp.lo\n+\t$(BUILDGOX)\n+\n+exp/gui/x11.gox: exp/gui/x11.lo\n+\t$(BUILDGOX)\n+\n+exp/regexp/syntax.gox: exp/regexp/syntax.lo\n \t$(BUILDGOX)\n-exp/eval.gox: exp/eval.lo\n+\n+exp/template/html.gox: exp/template/html.lo\n \t$(BUILDGOX)\n \n go/ast.gox: go/ast.lo\n \t$(BUILDGOX)\n+go/build.gox: go/build.lo\n+\t$(BUILDGOX)\n go/doc.gox: go/doc.lo\n \t$(BUILDGOX)\n go/parser.gox: go/parser.lo\n@@ -3037,6 +3288,10 @@ http/pprof.gox: http/pprof.lo\n http/spdy.gox: http/spdy.lo\n \t$(BUILDGOX)\n \n+image/bmp.gox: image/bmp.lo\n+\t$(BUILDGOX)\n+image/draw.gox: image/draw.lo\n+\t$(BUILDGOX)\n image/gif.gox: image/gif.lo\n \t$(BUILDGOX)\n image/jpeg.gox: image/jpeg.lo\n@@ -3062,6 +3317,9 @@ net/dict.gox: net/dict.lo\n net/textproto.gox: net/textproto.lo\n \t$(BUILDGOX)\n \n+old/template.gox: old/template.lo\n+\t$(BUILDGOX)\n+\n os/inotify.gox: os/inotify.lo\n \t$(BUILDGOX)\n os/user.gox: os/user.lo\n@@ -3083,6 +3341,9 @@ runtime/pprof.gox: runtime/pprof.lo\n sync/atomic.gox: sync/atomic.lo\n \t$(BUILDGOX)\n \n+template/parse.gox: template/parse.lo\n+\t$(BUILDGOX)\n+\n testing/iotest.gox: testing/iotest.lo\n \t$(BUILDGOX)\n testing/quick.gox: testing/quick.lo\n@@ -3103,6 +3364,7 @@ TEST_PACKAGES = \\\n \tbufio/check \\\n \tbytes/check \\\n \tcmath/check \\\n+\tcsv/check \\\n \tebnf/check \\\n \texec/check \\\n \texpvar/check \\\n@@ -3111,10 +3373,12 @@ TEST_PACKAGES = \\\n \tgob/check \\\n \thtml/check \\\n \thttp/check \\\n+\timage/check \\\n \tio/check \\\n \tjson/check \\\n \tlog/check \\\n \tmath/check \\\n+\tmail/check \\\n \tmime/check \\\n \tnet/check \\\n \tnetchan/check \\\n@@ -3138,6 +3402,7 @@ TEST_PACKAGES = \\\n \ttime/check \\\n \ttry/check \\\n \tunicode/check \\\n+\turl/check \\\n \tutf16/check \\\n \tutf8/check \\\n \twebsocket/check \\\n@@ -3179,6 +3444,7 @@ TEST_PACKAGES = \\\n \tcrypto/x509/check \\\n \tcrypto/xtea/check \\\n \tcrypto/openpgp/armor/check \\\n+\tcrypto/openpgp/elgamal/check \\\n \tcrypto/openpgp/packet/check \\\n \tcrypto/openpgp/s2k/check \\\n \tdebug/dwarf/check \\\n@@ -3191,12 +3457,14 @@ TEST_PACKAGES = \\\n \tencoding/binary/check \\\n \tencoding/git85/check \\\n \tencoding/hex/check \\\n-\tencoding/line/check \\\n \tencoding/pem/check \\\n \texp/datafmt/check \\\n-\texp/draw/check \\\n-\texp/eval/check \\\n+\texp/norm/check \\\n+\texp/regexp/check \\\n+\texp/regexp/syntax/check \\\n+\texp/template/html/check \\\n \tgo/ast/check \\\n+\t$(go_build_check_omitted_since_it_calls_6g) \\\n \tgo/parser/check \\\n \tgo/printer/check \\\n \tgo/scanner/check \\\n@@ -3210,6 +3478,7 @@ TEST_PACKAGES = \\\n \thttp/cgi/check \\\n \thttp/fcgi/check \\\n \thttp/spdy/check \\\n+\timage/draw/check \\\n \timage/jpeg/check \\\n \timage/png/check \\\n \timage/tiff/check \\\n@@ -3218,12 +3487,14 @@ TEST_PACKAGES = \\\n \tio/ioutil/check \\\n \tmime/multipart/check \\\n \tnet/textproto/check \\\n+\told/template/check \\\n \t$(os_inotify_check) \\\n \tos/user/check \\\n \tos/signal/check \\\n \tpath/filepath/check \\\n \trpc/jsonrpc/check \\\n \tsync/atomic/check \\\n+\ttemplate/parse/check \\\n \ttesting/quick/check \\\n \ttesting/script/check\n "}, {"sha": "41ffe7c7230fcae72add9373b9ea122dd0a7ffaa", "filename": "libgo/Makefile.in", "status": "modified", "additions": 655, "deletions": 238, "changes": 893, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -98,9 +98,13 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgocontainerdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgocryptodir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgodebugdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoencodingdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoexpdir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgoexpguidir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgoexpregexpdir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgoexptemplatedir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgogodir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgohashdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgohttpdir)\" \\\n@@ -109,11 +113,13 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoiodir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgomimedir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgonetdir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgoolddir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoosdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgopathdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgorpcdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoruntimedir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgosyncdir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgotemplatedir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgotestingdir)\"\n LIBRARIES = $(toolexeclib_LIBRARIES)\n ARFLAGS = cru\n@@ -125,18 +131,18 @@ LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__DEPENDENCIES_1 =\n am__DEPENDENCIES_2 = asn1/asn1.lo big/big.lo bufio/bufio.lo \\\n \tbytes/bytes.lo bytes/index.lo cmath/cmath.lo crypto/crypto.lo \\\n-\tebnf/ebnf.lo exec/exec.lo expvar/expvar.lo flag/flag.lo \\\n-\tfmt/fmt.lo gob/gob.lo hash/hash.lo html/html.lo http/http.lo \\\n-\timage/image.lo io/io.lo json/json.lo log/log.lo math/math.lo \\\n-\tmime/mime.lo net/net.lo netchan/netchan.lo os/os.lo \\\n-\tpatch/patch.lo path/path.lo rand/rand.lo reflect/reflect.lo \\\n-\tregexp/regexp.lo rpc/rpc.lo runtime/runtime.lo \\\n-\tscanner/scanner.lo smtp/smtp.lo sort/sort.lo \\\n-\tstrconv/strconv.lo strings/strings.lo sync/sync.lo \\\n-\tsyslog/syslog.lo syslog/syslog_c.lo tabwriter/tabwriter.lo \\\n-\ttemplate/template.lo time/time.lo try/try.lo \\\n-\tunicode/unicode.lo utf16/utf16.lo utf8/utf8.lo \\\n-\twebsocket/websocket.lo xml/xml.lo archive/tar.lo \\\n+\tcsv/csv.lo ebnf/ebnf.lo exec/exec.lo expvar/expvar.lo \\\n+\tflag/flag.lo fmt/fmt.lo gob/gob.lo hash/hash.lo html/html.lo \\\n+\thttp/http.lo image/image.lo io/io.lo json/json.lo log/log.lo \\\n+\tmath/math.lo mail/mail.lo mime/mime.lo net/net.lo \\\n+\tnetchan/netchan.lo os/os.lo patch/patch.lo path/path.lo \\\n+\trand/rand.lo reflect/reflect.lo regexp/regexp.lo rpc/rpc.lo \\\n+\truntime/runtime.lo scanner/scanner.lo smtp/smtp.lo \\\n+\tsort/sort.lo strconv/strconv.lo strings/strings.lo \\\n+\tsync/sync.lo syslog/syslog.lo syslog/syslog_c.lo \\\n+\ttabwriter/tabwriter.lo template/template.lo time/time.lo \\\n+\ttry/try.lo unicode/unicode.lo url/url.lo utf16/utf16.lo \\\n+\tutf8/utf8.lo websocket/websocket.lo xml/xml.lo archive/tar.lo \\\n \tarchive/zip.lo compress/bzip2.lo compress/flate.lo \\\n \tcompress/gzip.lo compress/lzw.lo compress/zlib.lo \\\n \tcontainer/heap.lo container/list.lo container/ring.lo \\\n@@ -148,24 +154,27 @@ am__DEPENDENCIES_2 = asn1/asn1.lo big/big.lo bufio/bufio.lo \\\n \tcrypto/sha1.lo crypto/sha256.lo crypto/sha512.lo \\\n \tcrypto/subtle.lo crypto/tls.lo crypto/twofish.lo \\\n \tcrypto/x509.lo crypto/xtea.lo crypto/openpgp/armor.lo \\\n-\tcrypto/openpgp/error.lo crypto/openpgp/packet.lo \\\n-\tcrypto/openpgp/s2k.lo debug/dwarf.lo debug/elf.lo \\\n-\tdebug/gosym.lo debug/macho.lo debug/pe.lo debug/proc.lo \\\n-\tencoding/ascii85.lo encoding/base32.lo encoding/base64.lo \\\n-\tencoding/binary.lo encoding/git85.lo encoding/hex.lo \\\n-\tencoding/line.lo encoding/pem.lo exp/datafmt.lo exp/draw.lo \\\n-\texp/eval.lo go/ast.lo go/doc.lo go/parser.lo go/printer.lo \\\n+\tcrypto/openpgp/elgamal.lo crypto/openpgp/error.lo \\\n+\tcrypto/openpgp/packet.lo crypto/openpgp/s2k.lo \\\n+\tcrypto/x509/pkix.lo debug/dwarf.lo debug/elf.lo debug/gosym.lo \\\n+\tdebug/macho.lo debug/pe.lo encoding/ascii85.lo \\\n+\tencoding/base32.lo encoding/base64.lo encoding/binary.lo \\\n+\tencoding/git85.lo encoding/hex.lo encoding/pem.lo \\\n+\texp/datafmt.lo exp/gui.lo exp/norm.lo exp/regexp.lo \\\n+\texp/gui/x11.lo exp/regexp/syntax.lo exp/template/html.lo \\\n+\tgo/ast.lo go/build.lo go/doc.lo go/parser.lo go/printer.lo \\\n \tgo/scanner.lo go/token.lo go/typechecker.lo go/types.lo \\\n \thash/adler32.lo hash/crc32.lo hash/crc64.lo hash/fnv.lo \\\n \thttp/cgi.lo http/fcgi.lo http/httptest.lo http/pprof.lo \\\n-\thttp/spdy.lo image/gif.lo image/jpeg.lo image/png.lo \\\n-\timage/tiff.lo image/ycbcr.lo index/suffixarray.lo io/ioutil.lo \\\n-\tmime/multipart.lo net/dict.lo net/textproto.lo \\\n+\thttp/spdy.lo image/bmp.lo image/draw.lo image/gif.lo \\\n+\timage/jpeg.lo image/png.lo image/tiff.lo image/ycbcr.lo \\\n+\tindex/suffixarray.lo io/ioutil.lo mime/multipart.lo \\\n+\tnet/dict.lo net/textproto.lo old/template.lo \\\n \t$(am__DEPENDENCIES_1) os/user.lo os/signal.lo path/filepath.lo \\\n \trpc/jsonrpc.lo runtime/debug.lo runtime/pprof.lo \\\n \tsync/atomic.lo sync/atomic_c.lo syscalls/syscall.lo \\\n-\tsyscalls/errno.lo testing/testing.lo testing/iotest.lo \\\n-\ttesting/quick.lo testing/script.lo\n+\tsyscalls/errno.lo template/parse.lo testing/testing.lo \\\n+\ttesting/iotest.lo testing/quick.lo testing/script.lo\n libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1)\n@@ -189,7 +198,7 @@ am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n \truntime/go-map-range.c runtime/go-nanotime.c \\\n \truntime/go-new-channel.c runtime/go-new-map.c runtime/go-new.c \\\n \truntime/go-note.c runtime/go-panic.c runtime/go-panic-defer.c \\\n-\truntime/go-print.c runtime/go-rec-big.c \\\n+\truntime/go-print.c runtime/go-rand.c runtime/go-rec-big.c \\\n \truntime/go-rec-nb-big.c runtime/go-rec-nb-small.c \\\n \truntime/go-rec-small.c runtime/go-recover.c \\\n \truntime/go-reflect.c runtime/go-reflect-call.c \\\n@@ -230,22 +239,23 @@ am__objects_3 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-make-slice.lo go-map-delete.lo go-map-index.lo \\\n \tgo-map-len.lo go-map-range.lo go-nanotime.lo go-new-channel.lo \\\n \tgo-new-map.lo go-new.lo go-note.lo go-panic.lo \\\n-\tgo-panic-defer.lo go-print.lo go-rec-big.lo go-rec-nb-big.lo \\\n-\tgo-rec-nb-small.lo go-rec-small.lo go-recover.lo go-reflect.lo \\\n-\tgo-reflect-call.lo go-reflect-chan.lo go-reflect-map.lo \\\n-\tgo-rune.lo go-runtime-error.lo go-sched.lo go-select.lo \\\n-\tgo-semacquire.lo go-send-big.lo go-send-nb-big.lo \\\n-\tgo-send-nb-small.lo go-send-small.lo go-setenv.lo go-signal.lo \\\n-\tgo-strcmp.lo go-string-to-byte-array.lo \\\n-\tgo-string-to-int-array.lo go-strplus.lo go-strslice.lo \\\n-\tgo-trampoline.lo go-type-eface.lo go-type-error.lo \\\n-\tgo-type-identity.lo go-type-interface.lo go-type-string.lo \\\n-\tgo-typedesc-equal.lo go-typestring.lo go-unreflect.lo \\\n-\tgo-unsafe-new.lo go-unsafe-newarray.lo go-unsafe-pointer.lo \\\n-\tgo-unwind.lo cpuprof.lo mcache.lo mcentral.lo $(am__objects_1) \\\n-\tmfinal.lo mfixalloc.lo mgc0.lo mheap.lo msize.lo proc.lo \\\n-\tthread.lo $(am__objects_2) chan.lo iface.lo malloc.lo map.lo \\\n-\tmprof.lo reflect.lo sigqueue.lo string.lo\n+\tgo-panic-defer.lo go-print.lo go-rand.lo go-rec-big.lo \\\n+\tgo-rec-nb-big.lo go-rec-nb-small.lo go-rec-small.lo \\\n+\tgo-recover.lo go-reflect.lo go-reflect-call.lo \\\n+\tgo-reflect-chan.lo go-reflect-map.lo go-rune.lo \\\n+\tgo-runtime-error.lo go-sched.lo go-select.lo go-semacquire.lo \\\n+\tgo-send-big.lo go-send-nb-big.lo go-send-nb-small.lo \\\n+\tgo-send-small.lo go-setenv.lo go-signal.lo go-strcmp.lo \\\n+\tgo-string-to-byte-array.lo go-string-to-int-array.lo \\\n+\tgo-strplus.lo go-strslice.lo go-trampoline.lo go-type-eface.lo \\\n+\tgo-type-error.lo go-type-identity.lo go-type-interface.lo \\\n+\tgo-type-string.lo go-typedesc-equal.lo go-typestring.lo \\\n+\tgo-unreflect.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n+\tgo-unsafe-pointer.lo go-unwind.lo cpuprof.lo mcache.lo \\\n+\tmcentral.lo $(am__objects_1) mfinal.lo mfixalloc.lo mgc0.lo \\\n+\tmheap.lo msize.lo proc.lo thread.lo $(am__objects_2) chan.lo \\\n+\tiface.lo malloc.lo map.lo mprof.lo reflect.lo sigqueue.lo \\\n+\tstring.lo\n am_libgo_la_OBJECTS = $(am__objects_3)\n libgo_la_OBJECTS = $(am_libgo_la_OBJECTS)\n libgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n@@ -282,14 +292,17 @@ RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n DATA = $(toolexeclibgo_DATA) $(toolexeclibgoarchive_DATA) \\\n \t$(toolexeclibgocompress_DATA) $(toolexeclibgocontainer_DATA) \\\n \t$(toolexeclibgocrypto_DATA) $(toolexeclibgocryptoopenpgp_DATA) \\\n-\t$(toolexeclibgodebug_DATA) $(toolexeclibgoencoding_DATA) \\\n-\t$(toolexeclibgoexp_DATA) $(toolexeclibgogo_DATA) \\\n+\t$(toolexeclibgocryptox509_DATA) $(toolexeclibgodebug_DATA) \\\n+\t$(toolexeclibgoencoding_DATA) $(toolexeclibgoexp_DATA) \\\n+\t$(toolexeclibgoexpgui_DATA) $(toolexeclibgoexpregexp_DATA) \\\n+\t$(toolexeclibgoexptemplate_DATA) $(toolexeclibgogo_DATA) \\\n \t$(toolexeclibgohash_DATA) $(toolexeclibgohttp_DATA) \\\n \t$(toolexeclibgoimage_DATA) $(toolexeclibgoindex_DATA) \\\n \t$(toolexeclibgoio_DATA) $(toolexeclibgomime_DATA) \\\n-\t$(toolexeclibgonet_DATA) $(toolexeclibgoos_DATA) \\\n-\t$(toolexeclibgopath_DATA) $(toolexeclibgorpc_DATA) \\\n-\t$(toolexeclibgoruntime_DATA) $(toolexeclibgosync_DATA) \\\n+\t$(toolexeclibgonet_DATA) $(toolexeclibgoold_DATA) \\\n+\t$(toolexeclibgoos_DATA) $(toolexeclibgopath_DATA) \\\n+\t$(toolexeclibgorpc_DATA) $(toolexeclibgoruntime_DATA) \\\n+\t$(toolexeclibgosync_DATA) $(toolexeclibgotemplate_DATA) \\\n \t$(toolexeclibgotesting_DATA)\n RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n   distclean-recursive maintainer-clean-recursive\n@@ -363,7 +376,6 @@ GOARCH = @GOARCH@\n GOC = @GOC@\n GOCFLAGS = $(CFLAGS)\n GOOS = @GOOS@\n-GO_DEBUG_PROC_REGS_OS_ARCH_FILE = @GO_DEBUG_PROC_REGS_OS_ARCH_FILE@\n GO_SYSCALLS_SYSCALL_OS_ARCH_FILE = @GO_SYSCALLS_SYSCALL_OS_ARCH_FILE@\n GREP = @GREP@\n INSTALL = @INSTALL@\n@@ -559,6 +571,7 @@ toolexeclibgo_DATA = \\\n \tbytes.gox \\\n \tcmath.gox \\\n \tcrypto.gox \\\n+\tcsv.gox \\\n \tebnf.gox \\\n \texec.gox \\\n \texpvar.gox \\\n@@ -573,6 +586,7 @@ toolexeclibgo_DATA = \\\n \tjson.gox \\\n \tlog.gox \\\n \tmath.gox \\\n+\tmail.gox \\\n \tmime.gox \\\n \tnet.gox \\\n \tnetchan.gox \\\n@@ -598,6 +612,7 @@ toolexeclibgo_DATA = \\\n \ttime.gox \\\n \ttry.gox \\\n \tunicode.gox \\\n+\turl.gox \\\n \tutf16.gox \\\n \tutf8.gox \\\n \twebsocket.gox \\\n@@ -654,39 +669,56 @@ toolexeclibgocrypto_DATA = \\\n toolexeclibgocryptoopenpgpdir = $(toolexeclibgocryptodir)/openpgp\n toolexeclibgocryptoopenpgp_DATA = \\\n \tcrypto/openpgp/armor.gox \\\n+\tcrypto/openpgp/elgamal.gox \\\n \tcrypto/openpgp/error.gox \\\n \tcrypto/openpgp/packet.gox \\\n \tcrypto/openpgp/s2k.gox\n \n+toolexeclibgocryptox509dir = $(toolexeclibgocryptodir)/x509\n+toolexeclibgocryptox509_DATA = \\\n+\tcrypto/x509/pkix.gox\n+\n toolexeclibgodebugdir = $(toolexeclibgodir)/debug\n toolexeclibgodebug_DATA = \\\n \tdebug/dwarf.gox \\\n \tdebug/elf.gox \\\n \tdebug/gosym.gox \\\n \tdebug/macho.gox \\\n-\tdebug/pe.gox \\\n-\tdebug/proc.gox\n+\tdebug/pe.gox\n \n toolexeclibgoencodingdir = $(toolexeclibgodir)/encoding\n toolexeclibgoencoding_DATA = \\\n \tencoding/ascii85.gox \\\n \tencoding/base32.gox \\\n \tencoding/base64.gox \\\n \tencoding/binary.gox \\\n-\tencoding/line.gox \\\n \tencoding/git85.gox \\\n \tencoding/hex.gox \\\n \tencoding/pem.gox\n \n toolexeclibgoexpdir = $(toolexeclibgodir)/exp\n toolexeclibgoexp_DATA = \\\n \texp/datafmt.gox \\\n-\texp/draw.gox \\\n-\texp/eval.gox\n+\texp/gui.gox \\\n+\texp/norm.gox \\\n+\texp/regexp.gox\n+\n+toolexeclibgoexpguidir = $(toolexeclibgoexpdir)/gui\n+toolexeclibgoexpgui_DATA = \\\n+\texp/gui/x11.gox\n+\n+toolexeclibgoexpregexpdir = $(toolexeclibgoexpdir)/regexp\n+toolexeclibgoexpregexp_DATA = \\\n+\texp/regexp/syntax.gox\n+\n+toolexeclibgoexptemplatedir = $(toolexeclibgoexpdir)/template\n+toolexeclibgoexptemplate_DATA = \\\n+\texp/template/html.gox\n \n toolexeclibgogodir = $(toolexeclibgodir)/go\n toolexeclibgogo_DATA = \\\n \tgo/ast.gox \\\n+\tgo/build.gox \\\n \tgo/doc.gox \\\n \tgo/parser.gox \\\n \tgo/printer.gox \\\n@@ -712,6 +744,8 @@ toolexeclibgohttp_DATA = \\\n \n toolexeclibgoimagedir = $(toolexeclibgodir)/image\n toolexeclibgoimage_DATA = \\\n+\timage/bmp.gox \\\n+\timage/draw.gox \\\n \timage/gif.gox \\\n \timage/jpeg.gox \\\n \timage/png.gox \\\n@@ -735,6 +769,10 @@ toolexeclibgonet_DATA = \\\n \tnet/dict.gox \\\n \tnet/textproto.gox\n \n+toolexeclibgoolddir = $(toolexeclibgodir)/old\n+toolexeclibgoold_DATA = \\\n+\told/template.gox\n+\n toolexeclibgoosdir = $(toolexeclibgodir)/os\n @LIBGO_IS_LINUX_FALSE@os_inotify_gox = \n \n@@ -758,6 +796,10 @@ toolexeclibgoruntime_DATA = \\\n \truntime/debug.gox \\\n \truntime/pprof.gox\n \n+toolexeclibgotemplatedir = $(toolexeclibgodir)/template\n+toolexeclibgotemplate_DATA = \\\n+\ttemplate/parse.gox\n+\n toolexeclibgosyncdir = $(toolexeclibgodir)/sync\n toolexeclibgosync_DATA = \\\n \tsync/atomic.gox\n@@ -814,6 +856,7 @@ runtime_files = \\\n \truntime/go-panic.c \\\n \truntime/go-panic-defer.c \\\n \truntime/go-print.c \\\n+\truntime/go-rand.c \\\n \truntime/go-rec-big.c \\\n \truntime/go-rec-nb-big.c \\\n \truntime/go-rec-nb-small.c \\\n@@ -914,6 +957,10 @@ go_cmath_files = \\\n go_crypto_files = \\\n \tgo/crypto/crypto.go\n \n+go_csv_files = \\\n+\tgo/csv/reader.go \\\n+\tgo/csv/writer.go\n+\n go_ebnf_files = \\\n \tgo/ebnf/ebnf.go \\\n \tgo/ebnf/parser.go\n@@ -947,9 +994,11 @@ go_hash_files = \\\n \tgo/hash/hash.go\n \n go_html_files = \\\n+\tgo/html/const.go \\\n \tgo/html/doc.go \\\n \tgo/html/entity.go \\\n \tgo/html/escape.go \\\n+\tgo/html/node.go \\\n \tgo/html/parse.go \\\n \tgo/html/token.go\n \n@@ -966,10 +1015,10 @@ go_http_files = \\\n \tgo/http/response.go \\\n \tgo/http/reverseproxy.go \\\n \tgo/http/server.go \\\n+\tgo/http/sniff.go \\\n \tgo/http/status.go \\\n \tgo/http/transfer.go \\\n-\tgo/http/transport.go \\\n-\tgo/http/url.go\n+\tgo/http/transport.go\n \n go_image_files = \\\n \tgo/image/color.go \\\n@@ -1041,6 +1090,9 @@ go_math_files = \\\n \tgo/math/tanh.go \\\n \tgo/math/unsafe.go\n \n+go_mail_files = \\\n+\tgo/mail/message.go\n+\n go_mime_files = \\\n \tgo/mime/grammar.go \\\n \tgo/mime/mediatype.go \\\n@@ -1062,31 +1114,44 @@ go_mime_files = \\\n @LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_sock_file = go/net/sock_linux.go\n @LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sock_file = go/net/sock_linux.go\n @LIBGO_IS_LINUX_TRUE@go_net_sock_file = go/net/sock_linux.go\n+@LIBGO_IS_LINUX_FALSE@go_net_sendfile_file = go/net/sendfile_stub.go\n+@LIBGO_IS_LINUX_TRUE@go_net_sendfile_file = go/net/sendfile_linux.go\n+@LIBGO_IS_LINUX_FALSE@go_net_interface_file = go/net/interface_stub.go\n+@LIBGO_IS_LINUX_TRUE@go_net_interface_file = go/net/interface_linux.go\n go_net_files = \\\n \tgo/net/cgo_unix.go \\\n \t$(go_net_cgo_file) \\\n \tgo/net/dial.go \\\n \tgo/net/dnsclient.go \\\n+\tgo/net/dnsclient_unix.go \\\n \tgo/net/dnsconfig.go \\\n \tgo/net/dnsmsg.go \\\n \t$(go_net_newpollserver_file) \\\n \tgo/net/fd.go \\\n \t$(go_net_fd_os_file) \\\n \tgo/net/file.go \\\n \tgo/net/hosts.go \\\n+\tgo/net/interface.go \\\n+\t$(go_net_interface_file) \\\n \tgo/net/ip.go \\\n \tgo/net/iprawsock.go \\\n+\tgo/net/iprawsock_posix.go \\\n \tgo/net/ipsock.go \\\n-\tgo/net/lookup.go \\\n+\tgo/net/ipsock_posix.go \\\n+\tgo/net/lookup_unix.go \\\n \tgo/net/net.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n \tgo/net/port.go \\\n+\t$(go_net_sendfile_file) \\\n \tgo/net/sock.go \\\n \t$(go_net_sock_file) \\\n \tgo/net/tcpsock.go \\\n+\tgo/net/tcpsock_posix.go \\\n \tgo/net/udpsock.go \\\n-\tgo/net/unixsock.go\n+\tgo/net/udpsock_posix.go \\\n+\tgo/net/unixsock.go \\\n+\tgo/net/unixsock_posix.go\n \n go_netchan_files = \\\n \tgo/netchan/common.go \\\n@@ -1118,11 +1183,14 @@ go_os_files = \\\n \tgo/os/file_unix.go \\\n \tgo/os/getwd.go \\\n \tgo/os/path.go \\\n+\tgo/os/path_unix.go \\\n \tgo/os/proc.go \\\n \tgo/os/stat.go \\\n+\tgo/os/str.go \\\n \t$(go_os_sys_file) \\\n \tgo/os/time.go \\\n-\tgo/os/types.go\n+\tgo/os/types.go \\\n+\tsignal_unix.go\n \n go_patch_files = \\\n \tgo/patch/apply.go \\\n@@ -1209,8 +1277,12 @@ go_tabwriter_files = \\\n \tgo/tabwriter/tabwriter.go\n \n go_template_files = \\\n-\tgo/template/format.go \\\n-\tgo/template/template.go\n+\tgo/template/doc.go \\\n+\tgo/template/exec.go \\\n+\tgo/template/funcs.go \\\n+\tgo/template/helper.go \\\n+\tgo/template/parse.go \\\n+\tgo/template/set.go\n \n go_testing_files = \\\n \tgo/testing/benchmark.go \\\n@@ -1220,8 +1292,10 @@ go_time_files = \\\n \tgo/time/format.go \\\n \tgo/time/sleep.go \\\n \tgo/time/sys.go \\\n+\tgo/time/sys_posix.go \\\n \tgo/time/tick.go \\\n \tgo/time/time.go \\\n+\tgo/time/zoneinfo_posix.go \\\n \tgo/time/zoneinfo_unix.go\n \n go_try_files = \\\n@@ -1230,9 +1304,13 @@ go_try_files = \\\n go_unicode_files = \\\n \tgo/unicode/casetables.go \\\n \tgo/unicode/digit.go \\\n+\tgo/unicode/graphic.go \\\n \tgo/unicode/letter.go \\\n \tgo/unicode/tables.go\n \n+go_url_files = \\\n+\tgo/url/url.go\n+\n go_utf16_files = \\\n \tgo/utf16/utf16.go\n \n@@ -1246,6 +1324,7 @@ go_websocket_files = \\\n \tgo/websocket/websocket.go\n \n go_xml_files = \\\n+\tgo/xml/marshal.go \\\n \tgo/xml/read.go \\\n \tgo/xml/xml.go\n \n@@ -1256,7 +1335,8 @@ go_archive_tar_files = \\\n \n go_archive_zip_files = \\\n \tgo/archive/zip/reader.go \\\n-\tgo/archive/zip/struct.go\n+\tgo/archive/zip/struct.go \\\n+\tgo/archive/zip/writer.go\n \n go_compress_bzip2_files = \\\n \tgo/compress/bzip2/bit_reader.go \\\n@@ -1358,7 +1438,8 @@ go_crypto_openpgp_files = \\\n \n go_crypto_rand_files = \\\n \tgo/crypto/rand/rand.go \\\n-\tgo/crypto/rand/rand_unix.go\n+\tgo/crypto/rand/rand_unix.go \\\n+\tgo/crypto/rand/util.go\n \n go_crypto_rc4_files = \\\n \tgo/crypto/rc4/rc4.go\n@@ -1414,6 +1495,9 @@ go_crypto_openpgp_armor_files = \\\n \tgo/crypto/openpgp/armor/armor.go \\\n \tgo/crypto/openpgp/armor/encode.go\n \n+go_crypto_openpgp_elgamal_files = \\\n+\tgo/crypto/openpgp/elgamal/elgamal.go\n+\n go_crypto_openpgp_error_files = \\\n \tgo/crypto/openpgp/error/error.go\n \n@@ -1434,6 +1518,9 @@ go_crypto_openpgp_packet_files = \\\n go_crypto_openpgp_s2k_files = \\\n \tgo/crypto/openpgp/s2k/s2k.go\n \n+go_crypto_x509_pkix_files = \\\n+\tgo/crypto/x509/pkix/pkix.go\n+\n go_debug_dwarf_files = \\\n \tgo/debug/dwarf/buf.go \\\n \tgo/debug/dwarf/const.go \\\n@@ -1458,11 +1545,6 @@ go_debug_pe_files = \\\n \tgo/debug/pe/file.go \\\n \tgo/debug/pe/pe.go\n \n-go_debug_proc_files = \\\n-\tgo/debug/proc/proc.go \\\n-\tgo/debug/proc/proc_$(GOOS).go \\\n-\t$(GO_DEBUG_PROC_REGS_OS_ARCH_FILE)\n-\n go_encoding_ascii85_files = \\\n \tgo/encoding/ascii85/ascii85.go\n \n@@ -1481,33 +1563,42 @@ go_encoding_git85_files = \\\n go_encoding_hex_files = \\\n \tgo/encoding/hex/hex.go\n \n-go_encoding_line_files = \\\n-\tgo/encoding/line/line.go\n-\n go_encoding_pem_files = \\\n \tgo/encoding/pem/pem.go\n \n go_exp_datafmt_files = \\\n \tgo/exp/datafmt/datafmt.go \\\n \tgo/exp/datafmt/parser.go\n \n-go_exp_draw_files = \\\n-\tgo/exp/draw/draw.go \\\n-\tgo/exp/draw/event.go\n-\n-go_exp_eval_files = \\\n-\tgo/exp/eval/abort.go \\\n-\tgo/exp/eval/bridge.go \\\n-\tgo/exp/eval/compiler.go \\\n-\tgo/exp/eval/expr.go \\\n-\tgo/exp/eval/expr1.go \\\n-\tgo/exp/eval/func.go \\\n-\tgo/exp/eval/scope.go \\\n-\tgo/exp/eval/stmt.go \\\n-\tgo/exp/eval/type.go \\\n-\tgo/exp/eval/typec.go \\\n-\tgo/exp/eval/value.go \\\n-\tgo/exp/eval/world.go\n+go_exp_gui_files = \\\n+\tgo/exp/gui/gui.go\n+\n+go_exp_norm_files = \\\n+\tgo/exp/norm/composition.go \\\n+\tgo/exp/norm/forminfo.go \\\n+\tgo/exp/norm/normalize.go \\\n+\tgo/exp/norm/tables.go \\\n+\tgo/exp/norm/trie.go\n+\n+go_exp_regexp_files = \\\n+\tgo/exp/regexp/exec.go \\\n+\tgo/exp/regexp/regexp.go\n+\n+go_exp_gui_x11_files = \\\n+\tgo/exp/gui/x11/auth.go \\\n+\tgo/exp/gui/x11/conn.go\n+\n+go_exp_template_html_files = \\\n+\tgo/exp/template/html/context.go \\\n+\tgo/exp/template/html/escape.go\n+\n+go_exp_regexp_syntax_files = \\\n+\tgo/exp/regexp/syntax/compile.go \\\n+\tgo/exp/regexp/syntax/parse.go \\\n+\tgo/exp/regexp/syntax/perl_groups.go \\\n+\tgo/exp/regexp/syntax/prog.go \\\n+\tgo/exp/regexp/syntax/regexp.go \\\n+\tgo/exp/regexp/syntax/simplify.go\n \n go_go_ast_files = \\\n \tgo/go/ast/ast.go \\\n@@ -1517,6 +1608,12 @@ go_go_ast_files = \\\n \tgo/go/ast/scope.go \\\n \tgo/go/ast/walk.go\n \n+go_go_build_files = \\\n+\tgo/go/build/build.go \\\n+\tgo/go/build/dir.go \\\n+\tgo/go/build/path.go \\\n+\tsyslist.go\n+\n go_go_doc_files = \\\n \tgo/go/doc/comment.go \\\n \tgo/go/doc/doc.go\n@@ -1544,6 +1641,7 @@ go_go_typechecker_files = \\\n \tgo/go/typechecker/universe.go\n \n go_go_types_files = \\\n+\tgo/go/types/check.go \\\n \tgo/go/types/const.go \\\n \tgo/go/types/exportdata.go \\\n \tgo/go/types/gcimporter.go \\\n@@ -1554,7 +1652,8 @@ go_hash_adler32_files = \\\n \tgo/hash/adler32/adler32.go\n \n go_hash_crc32_files = \\\n-\tgo/hash/crc32/crc32.go\n+\tgo/hash/crc32/crc32.go \\\n+\tgo/hash/crc32/crc32_generic.go\n \n go_hash_crc64_files = \\\n \tgo/hash/crc64/crc64.go\n@@ -1578,7 +1677,15 @@ go_http_pprof_files = \\\n \tgo/http/pprof/pprof.go\n \n go_http_spdy_files = \\\n-\tgo/http/spdy/protocol.go\n+\tgo/http/spdy/read.go \\\n+\tgo/http/spdy/types.go \\\n+\tgo/http/spdy/write.go\n+\n+go_image_bmp_files = \\\n+\tgo/image/bmp/reader.go\n+\n+go_image_draw_files = \\\n+\tgo/image/draw/draw.go\n \n go_image_gif_files = \\\n \tgo/image/gif/reader.go\n@@ -1612,7 +1719,8 @@ go_io_ioutil_files = \\\n \n go_mime_multipart_files = \\\n \tgo/mime/multipart/formdata.go \\\n-\tgo/mime/multipart/multipart.go\n+\tgo/mime/multipart/multipart.go \\\n+\tgo/mime/multipart/writer.go\n \n go_net_dict_files = \\\n \tgo/net/dict/dict.go\n@@ -1624,6 +1732,12 @@ go_net_textproto_files = \\\n \tgo/net/textproto/textproto.go \\\n \tgo/net/textproto/writer.go\n \n+go_old_template_files = \\\n+\tgo/old/template/doc.go \\\n+\tgo/old/template/execute.go \\\n+\tgo/old/template/format.go \\\n+\tgo/old/template/parse.go\n+\n go_os_inotify_files = \\\n \tgo/os/inotify/inotify_linux.go\n \n@@ -1632,8 +1746,7 @@ go_os_user_files = \\\n \tgo/os/user/lookup_unix.go\n \n go_os_signal_files = \\\n-\tgo/os/signal/signal.go \\\n-\tunix.go\n+\tgo/os/signal/signal.go\n \n go_path_filepath_files = \\\n \tgo/path/filepath/match.go \\\n@@ -1650,6 +1763,12 @@ go_runtime_debug_files = \\\n go_runtime_pprof_files = \\\n \tgo/runtime/pprof/pprof.go\n \n+go_template_parse_files = \\\n+\tgo/template/parse/lex.go \\\n+\tgo/template/parse/node.go \\\n+\tgo/template/parse/parse.go \\\n+\tgo/template/parse/set.go\n+\n go_sync_atomic_files = \\\n \tgo/sync/atomic/doc.go\n \n@@ -1729,13 +1848,18 @@ go_testing_script_files = \\\n # 32-bit Solaris 2/x86 needs _nuname, handled in syscall_solaris_386.go.\n @LIBGO_IS_386_TRUE@@LIBGO_IS_SOLARIS_TRUE@syscall_uname_file = \n @LIBGO_IS_SOLARIS_FALSE@syscall_uname_file = syscalls/syscall_uname.go\n+@LIBGO_IS_LINUX_FALSE@syscall_netlink_file = \n+\n+# Support for netlink sockets and messages.\n+@LIBGO_IS_LINUX_TRUE@syscall_netlink_file = syscalls/netlink_linux.go\n go_syscall_files = \\\n \t$(syscall_errstr_file) \\\n \t$(syscall_errstr_decl_file) \\\n \tsyscalls/exec_helpers.go \\\n \t$(syscall_exec_os_file) \\\n \t$(syscall_wait_file) \\\n \t$(syscall_filesize_file) \\\n+\t$(syscall_netlink_file) \\\n \t$(syscall_stat_file) \\\n \t$(syscall_sleep_file) \\\n \tsyscalls/socket.go \\\n@@ -1766,6 +1890,7 @@ libgo_go_objs = \\\n \tbytes/index.lo \\\n \tcmath/cmath.lo \\\n \tcrypto/crypto.lo \\\n+\tcsv/csv.lo \\\n \tebnf/ebnf.lo \\\n \texec/exec.lo \\\n \texpvar/expvar.lo \\\n@@ -1780,6 +1905,7 @@ libgo_go_objs = \\\n \tjson/json.lo \\\n \tlog/log.lo \\\n \tmath/math.lo \\\n+\tmail/mail.lo \\\n \tmime/mime.lo \\\n \tnet/net.lo \\\n \tnetchan/netchan.lo \\\n@@ -1804,6 +1930,7 @@ libgo_go_objs = \\\n \ttime/time.lo \\\n \ttry/try.lo \\\n \tunicode/unicode.lo \\\n+\turl/url.lo \\\n \tutf16/utf16.lo \\\n \tutf8/utf8.lo \\\n \twebsocket/websocket.lo \\\n@@ -1845,27 +1972,32 @@ libgo_go_objs = \\\n \tcrypto/x509.lo \\\n \tcrypto/xtea.lo \\\n \tcrypto/openpgp/armor.lo \\\n+\tcrypto/openpgp/elgamal.lo \\\n \tcrypto/openpgp/error.lo \\\n \tcrypto/openpgp/packet.lo \\\n \tcrypto/openpgp/s2k.lo \\\n+\tcrypto/x509/pkix.lo \\\n \tdebug/dwarf.lo \\\n \tdebug/elf.lo \\\n \tdebug/gosym.lo \\\n \tdebug/macho.lo \\\n \tdebug/pe.lo \\\n-\tdebug/proc.lo \\\n \tencoding/ascii85.lo \\\n \tencoding/base32.lo \\\n \tencoding/base64.lo \\\n \tencoding/binary.lo \\\n \tencoding/git85.lo \\\n \tencoding/hex.lo \\\n-\tencoding/line.lo \\\n \tencoding/pem.lo \\\n \texp/datafmt.lo \\\n-\texp/draw.lo \\\n-\texp/eval.lo \\\n+\texp/gui.lo \\\n+\texp/norm.lo \\\n+\texp/regexp.lo \\\n+\texp/gui/x11.lo \\\n+\texp/regexp/syntax.lo \\\n+\texp/template/html.lo \\\n \tgo/ast.lo \\\n+\tgo/build.lo \\\n \tgo/doc.lo \\\n \tgo/parser.lo \\\n \tgo/printer.lo \\\n@@ -1882,6 +2014,8 @@ libgo_go_objs = \\\n \thttp/httptest.lo \\\n \thttp/pprof.lo \\\n \thttp/spdy.lo \\\n+\timage/bmp.lo \\\n+\timage/draw.lo \\\n \timage/gif.lo \\\n \timage/jpeg.lo \\\n \timage/png.lo \\\n@@ -1892,6 +2026,7 @@ libgo_go_objs = \\\n \tmime/multipart.lo \\\n \tnet/dict.lo \\\n \tnet/textproto.lo \\\n+\told/template.lo \\\n \t$(os_lib_inotify_lo) \\\n \tos/user.lo \\\n \tos/signal.lo \\\n@@ -1903,6 +2038,7 @@ libgo_go_objs = \\\n \tsync/atomic_c.lo \\\n \tsyscalls/syscall.lo \\\n \tsyscalls/errno.lo \\\n+\ttemplate/parse.lo \\\n \ttesting/testing.lo \\\n \ttesting/iotest.lo \\\n \ttesting/quick.lo \\\n@@ -1967,19 +2103,6 @@ CHECK = \\\n \tfi\n \n \n-# Check a package that is only tested if GCCGO_RUN_ALL_TESTS is set.\n-CHECK_ON_REQUEST = \\\n-\tif test \"$$GCCGO_RUN_ALL_TESTS\" != \"\"; then \\\n-\t  $(CHECK); \\\n-\telse \\\n-\t  rm -f $@-testsum $@-testlog; \\\n-\t  echo \"Set GCCGO_RUN_ALL_TESTS in environment to run $(@D) test\" > $@-testlog; \\\n-\t  echo \"UNTESTED: $(@D)\" >> $@-testlog; \\\n-\t  echo \"UNTESTED: $(@D)\"; \\\n-\t  echo \"UNTESTED: $(@D)\" > $@-testsum; \\\n-\tfi\n-\n-\n # Build all packages before checking any.\n CHECK_DEPS = libgo.la libgobegin.a \\\n \t$(toolexeclibgo_DATA) \\\n@@ -2022,6 +2145,7 @@ TEST_PACKAGES = \\\n \tbufio/check \\\n \tbytes/check \\\n \tcmath/check \\\n+\tcsv/check \\\n \tebnf/check \\\n \texec/check \\\n \texpvar/check \\\n@@ -2030,10 +2154,12 @@ TEST_PACKAGES = \\\n \tgob/check \\\n \thtml/check \\\n \thttp/check \\\n+\timage/check \\\n \tio/check \\\n \tjson/check \\\n \tlog/check \\\n \tmath/check \\\n+\tmail/check \\\n \tmime/check \\\n \tnet/check \\\n \tnetchan/check \\\n@@ -2057,6 +2183,7 @@ TEST_PACKAGES = \\\n \ttime/check \\\n \ttry/check \\\n \tunicode/check \\\n+\turl/check \\\n \tutf16/check \\\n \tutf8/check \\\n \twebsocket/check \\\n@@ -2098,6 +2225,7 @@ TEST_PACKAGES = \\\n \tcrypto/x509/check \\\n \tcrypto/xtea/check \\\n \tcrypto/openpgp/armor/check \\\n+\tcrypto/openpgp/elgamal/check \\\n \tcrypto/openpgp/packet/check \\\n \tcrypto/openpgp/s2k/check \\\n \tdebug/dwarf/check \\\n@@ -2110,12 +2238,14 @@ TEST_PACKAGES = \\\n \tencoding/binary/check \\\n \tencoding/git85/check \\\n \tencoding/hex/check \\\n-\tencoding/line/check \\\n \tencoding/pem/check \\\n \texp/datafmt/check \\\n-\texp/draw/check \\\n-\texp/eval/check \\\n+\texp/norm/check \\\n+\texp/regexp/check \\\n+\texp/regexp/syntax/check \\\n+\texp/template/html/check \\\n \tgo/ast/check \\\n+\t$(go_build_check_omitted_since_it_calls_6g) \\\n \tgo/parser/check \\\n \tgo/printer/check \\\n \tgo/scanner/check \\\n@@ -2129,6 +2259,7 @@ TEST_PACKAGES = \\\n \thttp/cgi/check \\\n \thttp/fcgi/check \\\n \thttp/spdy/check \\\n+\timage/draw/check \\\n \timage/jpeg/check \\\n \timage/png/check \\\n \timage/tiff/check \\\n@@ -2137,12 +2268,14 @@ TEST_PACKAGES = \\\n \tio/ioutil/check \\\n \tmime/multipart/check \\\n \tnet/textproto/check \\\n+\told/template/check \\\n \t$(os_inotify_check) \\\n \tos/user/check \\\n \tos/signal/check \\\n \tpath/filepath/check \\\n \trpc/jsonrpc/check \\\n \tsync/atomic/check \\\n+\ttemplate/parse/check \\\n \ttesting/quick/check \\\n \ttesting/script/check\n \n@@ -2324,6 +2457,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-panic-defer.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-panic.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-print.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-rand.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-rec-big.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-rec-nb-big.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-rec-nb-small.Plo@am__quote@\n@@ -2704,6 +2838,13 @@ go-print.lo: runtime/go-print.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-print.lo `test -f 'runtime/go-print.c' || echo '$(srcdir)/'`runtime/go-print.c\n \n+go-rand.lo: runtime/go-rand.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-rand.lo -MD -MP -MF $(DEPDIR)/go-rand.Tpo -c -o go-rand.lo `test -f 'runtime/go-rand.c' || echo '$(srcdir)/'`runtime/go-rand.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-rand.Tpo $(DEPDIR)/go-rand.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-rand.c' object='go-rand.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-rand.lo `test -f 'runtime/go-rand.c' || echo '$(srcdir)/'`runtime/go-rand.c\n+\n go-rec-big.lo: runtime/go-rec-big.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-rec-big.lo -MD -MP -MF $(DEPDIR)/go-rec-big.Tpo -c -o go-rec-big.lo `test -f 'runtime/go-rec-big.c' || echo '$(srcdir)/'`runtime/go-rec-big.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-rec-big.Tpo $(DEPDIR)/go-rec-big.Plo\n@@ -3206,6 +3347,26 @@ uninstall-toolexeclibgocryptoopenpgpDATA:\n \ttest -n \"$$files\" || exit 0; \\\n \techo \" ( cd '$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)' && rm -f\" $$files \")\"; \\\n \tcd \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" && rm -f $$files\n+install-toolexeclibgocryptox509DATA: $(toolexeclibgocryptox509_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibgocryptox509dir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgocryptox509dir)\"\n+\t@list='$(toolexeclibgocryptox509_DATA)'; test -n \"$(toolexeclibgocryptox509dir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgocryptox509dir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgocryptox509DATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgocryptox509_DATA)'; test -n \"$(toolexeclibgocryptox509dir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgocryptox509dir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" && rm -f $$files\n install-toolexeclibgodebugDATA: $(toolexeclibgodebug_DATA)\n \t@$(NORMAL_INSTALL)\n \ttest -z \"$(toolexeclibgodebugdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgodebugdir)\"\n@@ -3266,6 +3427,66 @@ uninstall-toolexeclibgoexpDATA:\n \ttest -n \"$$files\" || exit 0; \\\n \techo \" ( cd '$(DESTDIR)$(toolexeclibgoexpdir)' && rm -f\" $$files \")\"; \\\n \tcd \"$(DESTDIR)$(toolexeclibgoexpdir)\" && rm -f $$files\n+install-toolexeclibgoexpguiDATA: $(toolexeclibgoexpgui_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibgoexpguidir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoexpguidir)\"\n+\t@list='$(toolexeclibgoexpgui_DATA)'; test -n \"$(toolexeclibgoexpguidir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgoexpguidir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgoexpguidir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgoexpguiDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgoexpgui_DATA)'; test -n \"$(toolexeclibgoexpguidir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgoexpguidir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgoexpguidir)\" && rm -f $$files\n+install-toolexeclibgoexpregexpDATA: $(toolexeclibgoexpregexp_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibgoexpregexpdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoexpregexpdir)\"\n+\t@list='$(toolexeclibgoexpregexp_DATA)'; test -n \"$(toolexeclibgoexpregexpdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgoexpregexpdir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgoexpregexpdir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgoexpregexpDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgoexpregexp_DATA)'; test -n \"$(toolexeclibgoexpregexpdir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgoexpregexpdir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgoexpregexpdir)\" && rm -f $$files\n+install-toolexeclibgoexptemplateDATA: $(toolexeclibgoexptemplate_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibgoexptemplatedir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoexptemplatedir)\"\n+\t@list='$(toolexeclibgoexptemplate_DATA)'; test -n \"$(toolexeclibgoexptemplatedir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgoexptemplatedir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgoexptemplatedir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgoexptemplateDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgoexptemplate_DATA)'; test -n \"$(toolexeclibgoexptemplatedir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgoexptemplatedir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgoexptemplatedir)\" && rm -f $$files\n install-toolexeclibgogoDATA: $(toolexeclibgogo_DATA)\n \t@$(NORMAL_INSTALL)\n \ttest -z \"$(toolexeclibgogodir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgogodir)\"\n@@ -3426,6 +3647,26 @@ uninstall-toolexeclibgonetDATA:\n \ttest -n \"$$files\" || exit 0; \\\n \techo \" ( cd '$(DESTDIR)$(toolexeclibgonetdir)' && rm -f\" $$files \")\"; \\\n \tcd \"$(DESTDIR)$(toolexeclibgonetdir)\" && rm -f $$files\n+install-toolexeclibgooldDATA: $(toolexeclibgoold_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibgoolddir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoolddir)\"\n+\t@list='$(toolexeclibgoold_DATA)'; test -n \"$(toolexeclibgoolddir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgoolddir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgoolddir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgooldDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgoold_DATA)'; test -n \"$(toolexeclibgoolddir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgoolddir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgoolddir)\" && rm -f $$files\n install-toolexeclibgoosDATA: $(toolexeclibgoos_DATA)\n \t@$(NORMAL_INSTALL)\n \ttest -z \"$(toolexeclibgoosdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoosdir)\"\n@@ -3526,6 +3767,26 @@ uninstall-toolexeclibgosyncDATA:\n \ttest -n \"$$files\" || exit 0; \\\n \techo \" ( cd '$(DESTDIR)$(toolexeclibgosyncdir)' && rm -f\" $$files \")\"; \\\n \tcd \"$(DESTDIR)$(toolexeclibgosyncdir)\" && rm -f $$files\n+install-toolexeclibgotemplateDATA: $(toolexeclibgotemplate_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibgotemplatedir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgotemplatedir)\"\n+\t@list='$(toolexeclibgotemplate_DATA)'; test -n \"$(toolexeclibgotemplatedir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgotemplatedir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgotemplatedir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgotemplateDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgotemplate_DATA)'; test -n \"$(toolexeclibgotemplatedir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgotemplatedir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgotemplatedir)\" && rm -f $$files\n install-toolexeclibgotestingDATA: $(toolexeclibgotesting_DATA)\n \t@$(NORMAL_INSTALL)\n \ttest -z \"$(toolexeclibgotestingdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgotestingdir)\"\n@@ -3863,7 +4124,7 @@ all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi $(DATA) \\\n \t\tconfig.h\n installdirs: installdirs-recursive\n installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohttpdir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgorpcdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgoexpguidir)\" \"$(DESTDIR)$(toolexeclibgoexpregexpdir)\" \"$(DESTDIR)$(toolexeclibgoexptemplatedir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohttpdir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgoolddir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgorpcdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotemplatedir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: install-recursive\n@@ -3930,15 +4191,21 @@ install-exec-am: install-multi install-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgocontainerDATA \\\n \tinstall-toolexeclibgocryptoDATA \\\n \tinstall-toolexeclibgocryptoopenpgpDATA \\\n+\tinstall-toolexeclibgocryptox509DATA \\\n \tinstall-toolexeclibgodebugDATA \\\n \tinstall-toolexeclibgoencodingDATA install-toolexeclibgoexpDATA \\\n+\tinstall-toolexeclibgoexpguiDATA \\\n+\tinstall-toolexeclibgoexpregexpDATA \\\n+\tinstall-toolexeclibgoexptemplateDATA \\\n \tinstall-toolexeclibgogoDATA install-toolexeclibgohashDATA \\\n \tinstall-toolexeclibgohttpDATA install-toolexeclibgoimageDATA \\\n \tinstall-toolexeclibgoindexDATA install-toolexeclibgoioDATA \\\n \tinstall-toolexeclibgomimeDATA install-toolexeclibgonetDATA \\\n-\tinstall-toolexeclibgoosDATA install-toolexeclibgopathDATA \\\n-\tinstall-toolexeclibgorpcDATA install-toolexeclibgoruntimeDATA \\\n-\tinstall-toolexeclibgosyncDATA install-toolexeclibgotestingDATA\n+\tinstall-toolexeclibgooldDATA install-toolexeclibgoosDATA \\\n+\tinstall-toolexeclibgopathDATA install-toolexeclibgorpcDATA \\\n+\tinstall-toolexeclibgoruntimeDATA install-toolexeclibgosyncDATA \\\n+\tinstall-toolexeclibgotemplateDATA \\\n+\tinstall-toolexeclibgotestingDATA\n \n install-html: install-html-recursive\n \n@@ -3987,18 +4254,23 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgocontainerDATA \\\n \tuninstall-toolexeclibgocryptoDATA \\\n \tuninstall-toolexeclibgocryptoopenpgpDATA \\\n+\tuninstall-toolexeclibgocryptox509DATA \\\n \tuninstall-toolexeclibgodebugDATA \\\n \tuninstall-toolexeclibgoencodingDATA \\\n-\tuninstall-toolexeclibgoexpDATA uninstall-toolexeclibgogoDATA \\\n-\tuninstall-toolexeclibgohashDATA \\\n+\tuninstall-toolexeclibgoexpDATA \\\n+\tuninstall-toolexeclibgoexpguiDATA \\\n+\tuninstall-toolexeclibgoexpregexpDATA \\\n+\tuninstall-toolexeclibgoexptemplateDATA \\\n+\tuninstall-toolexeclibgogoDATA uninstall-toolexeclibgohashDATA \\\n \tuninstall-toolexeclibgohttpDATA \\\n \tuninstall-toolexeclibgoimageDATA \\\n \tuninstall-toolexeclibgoindexDATA uninstall-toolexeclibgoioDATA \\\n \tuninstall-toolexeclibgomimeDATA uninstall-toolexeclibgonetDATA \\\n-\tuninstall-toolexeclibgoosDATA uninstall-toolexeclibgopathDATA \\\n-\tuninstall-toolexeclibgorpcDATA \\\n+\tuninstall-toolexeclibgooldDATA uninstall-toolexeclibgoosDATA \\\n+\tuninstall-toolexeclibgopathDATA uninstall-toolexeclibgorpcDATA \\\n \tuninstall-toolexeclibgoruntimeDATA \\\n \tuninstall-toolexeclibgosyncDATA \\\n+\tuninstall-toolexeclibgotemplateDATA \\\n \tuninstall-toolexeclibgotestingDATA\n \n .MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all all-multi \\\n@@ -4026,39 +4298,50 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgocontainerDATA \\\n \tinstall-toolexeclibgocryptoDATA \\\n \tinstall-toolexeclibgocryptoopenpgpDATA \\\n+\tinstall-toolexeclibgocryptox509DATA \\\n \tinstall-toolexeclibgodebugDATA \\\n \tinstall-toolexeclibgoencodingDATA install-toolexeclibgoexpDATA \\\n+\tinstall-toolexeclibgoexpguiDATA \\\n+\tinstall-toolexeclibgoexpregexpDATA \\\n+\tinstall-toolexeclibgoexptemplateDATA \\\n \tinstall-toolexeclibgogoDATA install-toolexeclibgohashDATA \\\n \tinstall-toolexeclibgohttpDATA install-toolexeclibgoimageDATA \\\n \tinstall-toolexeclibgoindexDATA install-toolexeclibgoioDATA \\\n \tinstall-toolexeclibgomimeDATA install-toolexeclibgonetDATA \\\n-\tinstall-toolexeclibgoosDATA install-toolexeclibgopathDATA \\\n-\tinstall-toolexeclibgorpcDATA install-toolexeclibgoruntimeDATA \\\n-\tinstall-toolexeclibgosyncDATA install-toolexeclibgotestingDATA \\\n-\tinstallcheck installcheck-am installdirs installdirs-am \\\n-\tmaintainer-clean maintainer-clean-generic \\\n-\tmaintainer-clean-multi mostlyclean mostlyclean-compile \\\n-\tmostlyclean-generic mostlyclean-libtool mostlyclean-local \\\n-\tmostlyclean-multi pdf pdf-am ps ps-am tags tags-recursive \\\n-\tuninstall uninstall-am uninstall-toolexeclibLIBRARIES \\\n+\tinstall-toolexeclibgooldDATA install-toolexeclibgoosDATA \\\n+\tinstall-toolexeclibgopathDATA install-toolexeclibgorpcDATA \\\n+\tinstall-toolexeclibgoruntimeDATA install-toolexeclibgosyncDATA \\\n+\tinstall-toolexeclibgotemplateDATA \\\n+\tinstall-toolexeclibgotestingDATA installcheck installcheck-am \\\n+\tinstalldirs installdirs-am maintainer-clean \\\n+\tmaintainer-clean-generic maintainer-clean-multi mostlyclean \\\n+\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n+\tmostlyclean-local mostlyclean-multi pdf pdf-am ps ps-am tags \\\n+\ttags-recursive uninstall uninstall-am \\\n+\tuninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibLTLIBRARIES uninstall-toolexeclibgoDATA \\\n \tuninstall-toolexeclibgoarchiveDATA \\\n \tuninstall-toolexeclibgocompressDATA \\\n \tuninstall-toolexeclibgocontainerDATA \\\n \tuninstall-toolexeclibgocryptoDATA \\\n \tuninstall-toolexeclibgocryptoopenpgpDATA \\\n+\tuninstall-toolexeclibgocryptox509DATA \\\n \tuninstall-toolexeclibgodebugDATA \\\n \tuninstall-toolexeclibgoencodingDATA \\\n-\tuninstall-toolexeclibgoexpDATA uninstall-toolexeclibgogoDATA \\\n-\tuninstall-toolexeclibgohashDATA \\\n+\tuninstall-toolexeclibgoexpDATA \\\n+\tuninstall-toolexeclibgoexpguiDATA \\\n+\tuninstall-toolexeclibgoexpregexpDATA \\\n+\tuninstall-toolexeclibgoexptemplateDATA \\\n+\tuninstall-toolexeclibgogoDATA uninstall-toolexeclibgohashDATA \\\n \tuninstall-toolexeclibgohttpDATA \\\n \tuninstall-toolexeclibgoimageDATA \\\n \tuninstall-toolexeclibgoindexDATA uninstall-toolexeclibgoioDATA \\\n \tuninstall-toolexeclibgomimeDATA uninstall-toolexeclibgonetDATA \\\n-\tuninstall-toolexeclibgoosDATA uninstall-toolexeclibgopathDATA \\\n-\tuninstall-toolexeclibgorpcDATA \\\n+\tuninstall-toolexeclibgooldDATA uninstall-toolexeclibgoosDATA \\\n+\tuninstall-toolexeclibgopathDATA uninstall-toolexeclibgorpcDATA \\\n \tuninstall-toolexeclibgoruntimeDATA \\\n \tuninstall-toolexeclibgosyncDATA \\\n+\tuninstall-toolexeclibgotemplateDATA \\\n \tuninstall-toolexeclibgotestingDATA\n \n \n@@ -4108,14 +4391,15 @@ s-syscall_arch: Makefile\n \t$(SHELL) $(srcdir)/../move-if-change syscall_arch.go.tmp syscall_arch.go\n \t$(STAMP) $@\n \n-asn1/asn1.lo: $(go_asn1_files) bytes.gox fmt.gox io.gox os.gox reflect.gox \\\n-\t\tstrconv.gox strings.gox time.gox\n+asn1/asn1.lo: $(go_asn1_files) big.gox bytes.gox fmt.gox io.gox os.gox \\\n+\t\treflect.gox strconv.gox strings.gox time.gox\n \t$(BUILDPACKAGE)\n asn1/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: asn1/check\n \n-big/big.lo: $(go_big_files) fmt.gox rand.gox strings.gox os.gox\n+big/big.lo: $(go_big_files) encoding/binary.gox fmt.gox io.gox os.gox \\\n+\t\trand.gox strings.gox\n \t$(BUILDPACKAGE)\n big/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -4147,14 +4431,22 @@ crypto/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/check\n \n+csv/csv.lo: $(go_csv_files) bufio.gox bytes.gox fmt.gox io.gox os.gox \\\n+\t\tstrings.gox unicode.gox utf8.gox\n+\t$(BUILDPACKAGE)\n+csv/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: csv/check\n+\n ebnf/ebnf.lo: $(go_ebnf_files) container/vector.gox go/scanner.gox \\\n \t\tgo/token.gox os.gox strconv.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n ebnf/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: ebnf/check\n \n-exec/exec.lo: $(go_exec_files) os.gox strconv.gox strings.gox\n+exec/exec.lo: $(go_exec_files) bytes.gox io.gox os.gox strconv.gox \\\n+\t\tstrings.gox syscall.gox\n \t$(BUILDPACKAGE)\n exec/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -4202,11 +4494,11 @@ html/check: $(CHECK_DEPS)\n .PHONY: html/check\n \n http/http.lo: $(go_http_files) bufio.gox bytes.gox compress/gzip.gox \\\n-\t\tcontainer/vector.gox crypto/rand.gox crypto/tls.gox \\\n-\t\tencoding/base64.gox fmt.gox io.gox io/ioutil.gox log.gox \\\n+\t\tcrypto/rand.gox crypto/tls.gox encoding/base64.gox \\\n+\t\tencoding/binary.gox fmt.gox io.gox io/ioutil.gox log.gox \\\n \t\tmime.gox mime/multipart.gox net.gox net/textproto.gox os.gox \\\n-\t\tpath.gox path/filepath.gox sort.gox strconv.gox strings.gox \\\n-\t\tsync.gox time.gox utf8.gox\n+\t\tpath.gox path/filepath.gox runtime/debug.gox sort.gox \\\n+\t\tstrconv.gox strings.gox sync.gox time.gox url.gox utf8.gox\n \t$(BUILDPACKAGE)\n http/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -4224,10 +4516,9 @@ io/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: io/check\n \n-json/json.lo: $(go_json_files) bytes.gox container/vector.gox \\\n-\t\tencoding/base64.gox fmt.gox io.gox math.gox os.gox \\\n-\t\treflect.gox runtime.gox strconv.gox strings.gox unicode.gox \\\n-\t\tutf16.gox utf8.gox\n+json/json.lo: $(go_json_files) bytes.gox encoding/base64.gox fmt.gox io.gox \\\n+\t\tmath.gox os.gox reflect.gox runtime.gox strconv.gox \\\n+\t\tstrings.gox unicode.gox utf16.gox utf8.gox\n \t$(BUILDPACKAGE)\n json/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -4246,6 +4537,14 @@ math/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: math/check\n \n+mail/mail.lo: $(go_mail_files) bufio.gox bytes.gox encoding/base64.gox \\\n+\t\tfmt.gox io.gox io/ioutil.gox log.gox net/textproto.gox os.gox \\\n+\t\tstrconv.gox strings.gox time.gox\n+\t$(BUILDPACKAGE)\n+mail/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: mail/check\n+\n mime/mime.lo: $(go_mime_files) bufio.gox bytes.gox fmt.gox os.gox strings.gox \\\n \t\tsync.gox unicode.gox\n \t$(BUILDPACKAGE)\n@@ -4258,7 +4557,7 @@ net/net.lo: $(go_net_files) bytes.gox fmt.gox io.gox os.gox rand.gox \\\n \t\tsyscall.gox time.gox\n \t$(BUILDPACKAGE)\n net/check: $(CHECK_DEPS)\n-\t@$(CHECK_ON_REQUEST)\n+\t@$(CHECK)\n .PHONY: net/check\n \n netchan/netchan.lo: $(go_netchan_files) gob.gox io.gox log.gox net.gox os.gox \\\n@@ -4274,6 +4573,10 @@ os/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: os/check\n \n+signal_unix.go: $(srcdir)/go/os/mkunixsignals.sh sysinfo.go\n+\t$(SHELL) $(srcdir)/go/os/mkunixsignals.sh sysinfo.go > $@.tmp\n+\tmv -f $@.tmp $@\n+\n patch/patch.lo: $(go_patch_files) bytes.gox compress/zlib.gox \\\n \t\tcrypto/sha1.gox encoding/git85.gox fmt.gox io.gox os.gox \\\n \t\tpath.gox strings.gox\n@@ -4336,7 +4639,7 @@ smtp/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: smtp/check\n \n-sort/sort.lo: $(go_sort_files)\n+sort/sort.lo: $(go_sort_files) math.gox\n \t$(BUILDPACKAGE)\n sort/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -4366,7 +4669,7 @@ syslog/syslog.lo: $(go_syslog_files) fmt.gox log.gox net.gox os.gox syscall.gox\n syslog/syslog_c.lo: $(go_syslog_c_files) syslog/syslog.lo\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/syslog/syslog_c.c\n syslog/check: $(CHECK_DEPS)\n-\t@$(CHECK_ON_REQUEST)\n+\t@$(CHECK)\n .PHONY: syslog/check\n \n tabwriter/tabwriter.lo: $(go_tabwriter_files) bytes.gox io.gox os.gox utf8.gox\n@@ -4375,15 +4678,17 @@ tabwriter/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: tabwriter/check\n \n-template/template.lo: $(go_template_files) bytes.gox fmt.gox io.gox os.gox \\\n-\t\treflect.gox runtime.gox strings.gox container/vector.gox\n+template/template.lo: $(go_template_files) bytes.gox fmt.gox io.gox \\\n+\t\tio/ioutil.gox os.gox path/filepath.gox reflect.gox \\\n+\t\truntime.gox strings.gox template/parse.gox unicode.gox \\\n+\t\turl.gox utf8.gox\n \t$(BUILDPACKAGE)\n template/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: template/check\n \n testing/testing.lo: $(go_testing_files) flag.gox fmt.gox os.gox regexp.gox \\\n-\t\truntime.gox runtime/pprof.gox time.gox\n+\t\truntime.gox runtime/pprof.gox strings.gox strconv.gox time.gox\n \t$(BUILDPACKAGE)\n testing/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -4408,6 +4713,12 @@ unicode/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: unicode/check\n \n+url/url.lo: $(go_url_files) os.gox strconv.gox strings.gox\n+\t$(BUILDPACKAGE)\n+url/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: url/check\n+\n utf16/utf16.lo: $(go_utf16_files) unicode.gox\n \t$(BUILDPACKAGE)\n utf16/check: $(CHECK_DEPS)\n@@ -4421,9 +4732,8 @@ utf8/check: $(CHECK_DEPS)\n .PHONY: utf8/check\n \n websocket/websocket.lo: $(go_websocket_files) bufio.gox bytes.gox \\\n-\t\tcontainer/vector.gox crypto/md5.gox crypto/tls.gox \\\n-\t\tencoding/binary.gox fmt.gox http.gox io.gox net.gox os.gox \\\n-\t\trand.gox strings.gox\n+\t\tcrypto/md5.gox crypto/tls.gox encoding/binary.gox fmt.gox \\\n+\t\thttp.gox io.gox net.gox os.gox rand.gox strings.gox url.gox\n \t$(BUILDPACKAGE)\n websocket/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -4444,9 +4754,9 @@ archive/tar/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: archive/tar/check\n \n-archive/zip.lo: $(go_archive_zip_files) bufio.gox bytes.gox \\\n-\t\tcompress/flate.gox hash.gox hash/crc32.gox \\\n-\t\tencoding/binary.gox io.gox io/ioutil.gox os.gox\n+archive/zip.lo: $(go_archive_zip_files) bufio.gox compress/flate.gox \\\n+\t\tencoding/binary.gox hash.gox hash/crc32.gox \\\n+\t\tencoding/binary.gox io.gox io/ioutil.gox os.gox time.gox\n \t$(BUILDPACKAGE)\n archive/zip/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) archive/zip\n@@ -4599,25 +4909,27 @@ crypto/md5/check: $(CHECK_DEPS)\n .PHONY: crypto/md5/check\n \n crypto/ocsp.lo: $(go_crypto_ocsp_files) asn1.gox crypto.gox crypto/rsa.gox \\\n-\t\tcrypto/sha1.gox crypto/x509.gox os.gox time.gox\n+\t\tcrypto/sha1.gox crypto/x509.gox crypto/x509/pkix.gox os.gox \\\n+\t\ttime.gox\n \t$(BUILDPACKAGE)\n crypto/ocsp/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/ocsp\n \t@$(CHECK)\n .PHONY: crypto/ocsp/check\n \n-crypto/openpgp.lo: $(go_crypto_openpgp_files) crypto.gox crypto/dsa.gox \\\n+crypto/openpgp.lo: $(go_crypto_openpgp_files) crypto.gox \\\n \t\tcrypto/openpgp/armor.gox crypto/openpgp/error.gox \\\n-\t\tcrypto/openpgp/packet.gox crypto/rsa.gox crypto/sha256.gox \\\n-\t\thash.gox io.gox os.gox strconv.gox time.gox\n+\t\tcrypto/openpgp/packet.gox crypto/openpgp/s2k.gox \\\n+\t\tcrypto/rand.gox crypto/rsa.gox crypto/sha256.gox hash.gox \\\n+\t\tio.gox os.gox strconv.gox time.gox\n \t$(BUILDPACKAGE)\n crypto/openpgp/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/openpgp\n \t@$(CHECK)\n .PHONY: crypto/openpgp/check\n \n-crypto/rand.lo: $(go_crypto_rand_files) bufio.gox crypto/aes.gox io.gox \\\n-\t\tos.gox sync.gox time.gox\n+crypto/rand.lo: $(go_crypto_rand_files) big.gox bufio.gox crypto/aes.gox \\\n+\t\tio.gox os.gox sync.gox time.gox\n \t$(BUILDPACKAGE)\n crypto/rand/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/rand\n@@ -4638,8 +4950,9 @@ crypto/ripemd160/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/ripemd160/check\n \n-crypto/rsa.lo: $(go_crypto_rsa_files) big.gox crypto.gox crypto/sha1.gox \\\n-\t\tcrypto/subtle.gox encoding/hex.gox hash.gox io.gox os.gox\n+crypto/rsa.lo: $(go_crypto_rsa_files) big.gox crypto.gox crypto/rand.gox \\\n+\t\tcrypto/sha1.gox crypto/subtle.gox encoding/hex.gox hash.gox \\\n+\t\tio.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/rsa/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/rsa\n@@ -4678,9 +4991,9 @@ crypto/tls.lo: $(go_crypto_tls_files) big.gox bytes.gox crypto.gox \\\n \t\tcrypto/aes.gox crypto/cipher.gox crypto/elliptic.gox \\\n \t\tcrypto/hmac.gox crypto/md5.gox crypto/rand.gox crypto/rc4.gox \\\n \t\tcrypto/rsa.gox crypto/sha1.gox crypto/subtle.gox \\\n-\t\tcrypto/x509.gox encoding/pem.gox hash.gox io.gox \\\n-\t\tio/ioutil.gox net.gox os.gox strconv.gox strings.gox sync.gox \\\n-\t\ttime.gox\n+\t\tcrypto/x509.gox crypto/x509/pkix.gox encoding/pem.gox \\\n+\t\thash.gox io.gox io/ioutil.gox net.gox os.gox strconv.gox \\\n+\t\tstrings.gox sync.gox time.gox\n \t$(BUILDPACKAGE)\n crypto/tls/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/tls\n@@ -4694,9 +5007,9 @@ crypto/twofish/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/twofish/check\n \n-crypto/x509.lo: $(go_crypto_x509_files) asn1.gox big.gox bytes.gox \\\n-\t\tcontainer/vector.gox crypto.gox crypto/rsa.gox \\\n-\t\tcrypto/sha1.gox encoding/pem.gox hash.gox os.gox strings.gox \\\n+crypto/x509.lo: $(go_crypto_x509_files) asn1.gox big.gox bytes.gox crypto.gox \\\n+\t\tcrypto/dsa.gox crypto/rsa.gox crypto/sha1.gox \\\n+\t\tcrypto/x509/pkix.gox encoding/pem.gox os.gox strings.gox \\\n \t\ttime.gox\n \t$(BUILDPACKAGE)\n crypto/x509/check: $(CHECK_DEPS)\n@@ -4719,6 +5032,14 @@ crypto/openpgp/armor/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/openpgp/armor/check\n \n+crypto/openpgp/elgamal.lo: $(go_crypto_openpgp_elgamal_files) big.gox \\\n+\t\tcrypto/rand.gox crypto/subtle.gox io.gox os.gox\n+\t$(BUILDPACKAGE)\n+crypto/openpgp/elgamal/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/openpgp/elgamal\n+\t@$(CHECK)\n+.PHONY: crypto/openpgp/elgamal/check\n+\n crypto/openpgp/error.lo: $(go_crypto_openpgp_error_files) strconv.gox\n \t$(BUILDPACKAGE)\n crypto/openpgp/error/check: $(CHECK_DEPS)\n@@ -4729,9 +5050,10 @@ crypto/openpgp/error/check: $(CHECK_DEPS)\n crypto/openpgp/packet.lo: $(go_crypto_openpgp_packet_files) big.gox bytes.gox \\\n \t\tcompress/flate.gox compress/zlib.gox crypto.gox \\\n \t\tcrypto/aes.gox crypto/cast5.gox crypto/cipher.gox \\\n-\t\tcrypto/dsa.gox crypto/openpgp/error.gox \\\n-\t\tcrypto/openpgp/s2k.gox crypto/rand.gox crypto/rsa.gox \\\n-\t\tcrypto/sha1.gox crypto/subtle.gox encoding/binary.gox fmt.gox \\\n+\t\tcrypto/dsa.gox crypto/openpgp/elgamal.gox \\\n+\t\tcrypto/openpgp/error.gox crypto/openpgp/s2k.gox \\\n+\t\tcrypto/rand.gox crypto/rsa.gox crypto/sha1.gox \\\n+\t\tcrypto/subtle.gox encoding/binary.gox fmt.gox \\\n \t\thash.gox io.gox io/ioutil.gox os.gox strconv.gox strings.gox\n \t$(BUILDPACKAGE)\n crypto/openpgp/packet/check: $(CHECK_DEPS)\n@@ -4740,15 +5062,22 @@ crypto/openpgp/packet/check: $(CHECK_DEPS)\n .PHONY: crypto/openpgp/packet/check\n \n crypto/openpgp/s2k.lo: $(go_crypto_openpgp_s2k_files) crypto.gox \\\n-\t\tcrypto/md5.gox crypto/openpgp/error.gox crypto/ripemd160.gox \\\n-\t\tcrypto/sha1.gox crypto/sha256.gox crypto/sha512.gox hash.gox \\\n-\t\tio.gox os.gox\n+\t\tcrypto/md5.gox crypto/openpgp/error.gox crypto/rand.gox \\\n+\t\tcrypto/ripemd160.gox crypto/sha1.gox crypto/sha256.gox \\\n+\t\tcrypto/sha512.gox hash.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/openpgp/s2k/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/openpgp/s2k\n \t@$(CHECK)\n .PHONY: crypto/openpgp/s2k/check\n \n+crypto/x509/pkix.lo: $(go_crypto_x509_pkix_files) asn1.gox big.gox time.gox\n+\t$(BUILDPACKAGE)\n+crypto/x509/pkix/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/x509/pkix\n+\t@$(CHECK)\n+.PHONY: crypto/x509/pkix/check\n+\n debug/dwarf.lo: $(go_debug_dwarf_files) encoding/binary.gox os.gox strconv.gox\n \t$(BUILDPACKAGE)\n debug/dwarf/check: $(CHECK_DEPS)\n@@ -4788,15 +5117,6 @@ debug/pe/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: debug/pe/check\n \n-debug/proc.lo: $(go_debug_proc_files) container/vector.gox fmt.gox \\\n-\t\tio/ioutil.gox os.gox runtime.gox strconv.gox strings.gox \\\n-\t\tsync.gox syscall.gox\n-\t$(BUILDPACKAGE)\n-debug/proc/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) debug/proc\n-\t@$(CHECK)\n-.PHONY: debug/proc/check\n-\n encoding/ascii85.lo: $(go_encoding_ascii85_files) io.gox os.gox strconv.gox\n \t$(BUILDPACKAGE)\n encoding/ascii85/check: $(CHECK_DEPS)\n@@ -4834,60 +5154,101 @@ encoding/git85/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: encoding/git85/check\n \n-encoding/hex.lo: $(go_encoding_hex_files) os.gox strconv.gox\n+encoding/hex.lo: $(go_encoding_hex_files) bytes.gox io.gox os.gox strconv.gox\n \t$(BUILDPACKAGE)\n encoding/hex/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) encoding/hex\n \t@$(CHECK)\n .PHONY: encoding/hex/check\n \n-encoding/line.lo: $(go_encoding_line_files) io.gox os.gox\n-\t$(BUILDPACKAGE)\n-encoding/line/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) encoding/line\n-\t@$(CHECK)\n-.PHONY: encoding/line/check\n-\n encoding/pem.lo: $(go_encoding_pem_files) bytes.gox encoding/base64.gox\n \t$(BUILDPACKAGE)\n encoding/pem/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) encoding/pem\n \t@$(CHECK)\n .PHONY: encoding/pem/check\n \n-exp/datafmt.lo: $(go_exp_datafmt_files) bytes.gox container/vector.gox \\\n-\t\tfmt.gox go/scanner.gox go/token.gox io.gox os.gox reflect.gox \\\n-\t\truntime.gox strconv.gox strings.gox\n+exp/datafmt.lo: $(go_exp_datafmt_files) bytes.gox fmt.gox go/scanner.gox \\\n+\t\tgo/token.gox io.gox os.gox reflect.gox runtime.gox \\\n+\t\tstrconv.gox strings.gox\n \t$(BUILDPACKAGE)\n exp/datafmt/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) exp/datafmt\n \t@$(CHECK)\n .PHONY: exp/datafmt/check\n \n-exp/draw.lo: $(go_exp_draw_files) image.gox image/ycbcr.gox os.gox\n+exp/gui.lo: $(go_exp_gui_files) image.gox image/draw.gox os.gox\n+\t$(BUILDPACKAGE)\n+exp/gui/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/gui\n+\t@$(CHECK)\n+.PHONY: exp/gui/check\n+\n+exp/norm.lo: $(go_exp_norm_files) utf8.gox\n+\t$(BUILDPACKAGE)\n+exp/norm/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/norm\n+\t@$(CHECK)\n+.PHONY: exp/norm/check\n+\n+exp/regexp.lo: $(go_exp_regexp_files) bytes.gox exp/regexp/syntax.gox io.gox \\\n+\t\tos.gox strings.gox sync.gox utf8.gox\n+\t$(BUILDPACKAGE)\n+exp/regexp/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/regexp\n+\t@$(CHECK)\n+.PHONY: exp/regexp/check\n+\n+exp/gui/x11.lo: $(go_exp_gui_x11_files) bufio.gox exp/gui.gox image.gox \\\n+\t\timage/draw.gox io.gox log.gox net.gox os.gox strconv.gox \\\n+\t\tstrings.gox time.gox\n+\t$(BUILDPACKAGE)\n+exp/gui/x11/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/gui/x11\n+\t@$(CHECK)\n+.PHONY: exp/gui/x11/check\n+\n+exp/regexp/syntax.lo: $(go_exp_regexp_syntax_files) bytes.gox os.gox sort.gox strconv.gox strings.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n-exp/draw/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/draw\n+exp/regexp/syntax/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/regexp/syntax\n \t@$(CHECK)\n-.PHONY: exp/draw/check\n+.PHONY: exp/regexp/syntax/check\n \n-exp/eval.lo: $(go_exp_eval_files) big.gox go/ast.gox go/parser.gox \\\n-\t\tgo/scanner.gox go/token.gox fmt.gox log.gox strconv.gox \\\n-\t\tstrings.gox os.gox reflect.gox runtime.gox sort.gox template.gox\n+exp/template/html.lo: $(go_exp_template_html_files) fmt.gox template.gox \\\n+\t\ttemplate/parse.gox\n \t$(BUILDPACKAGE)\n-exp/eval/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/eval\n+exp/template/html/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/template/html\n \t@$(CHECK)\n-.PHONY: exp/eval/check\n+.PHONY: exp/template/html/check\n \n go/ast.lo: $(go_go_ast_files) bytes.gox fmt.gox go/scanner.gox go/token.gox \\\n-\t\tio.gox os.gox reflect.gox unicode.gox utf8.gox\n+\t\tio.gox os.gox reflect.gox strconv.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n go/ast/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/ast\n \t@$(CHECK)\n .PHONY: go/ast/check\n \n+go/build.lo: $(go_go_build_files) bytes.gox exec.gox fmt.gox go/parser.gox \\\n+\t\tgo/token.gox log.gox os.gox path/filepath.gox regexp.gox \\\n+\t\truntime.gox strconv.gox strings.gox runtime.gox\n+\t$(BUILDPACKAGE)\n+go/build/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) go/build\n+\t@$(CHECK)\n+.PHONY: go/build/check\n+\n+syslist.go: s-syslist; @true\n+s-syslist: Makefile\n+\techo '// Generated automatically by make.' >syslist.go.tmp\n+\techo 'package build' >>syslist.go.tmp\n+\techo 'const goosList = \"$(GOOS)\"' >>syslist.go.tmp\n+\techo 'const goarchList = \"$(GOARCH)\"' >>syslist.go.tmp\n+\t$(SHELL) $(srcdir)/../move-if-change syslist.go.tmp syslist.go\n+\t$(STAMP) $@\n+\n go/doc.lo: $(go_go_doc_files) go/ast.gox go/token.gox io.gox regexp.gox \\\n \t\tsort.gox strings.gox template.gox\n \t$(BUILDPACKAGE)\n@@ -4914,9 +5275,9 @@ go/printer/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/printer/check\n \n-go/scanner.lo: $(go_go_scanner_files) bytes.gox container/vector.gox fmt.gox \\\n-\t\tgo/token.gox io.gox os.gox path/filepath.gox sort.gox \\\n-\t\tstrconv.gox unicode.gox utf8.gox\n+go/scanner.lo: $(go_go_scanner_files) bytes.gox fmt.gox go/token.gox io.gox \\\n+\t\tos.gox path/filepath.gox sort.gox strconv.gox unicode.gox \\\n+\t\tutf8.gox\n \t$(BUILDPACKAGE)\n go/scanner/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/scanner\n@@ -4940,7 +5301,7 @@ go/typechecker/check: $(CHECK_DEPS)\n \n go/types.lo: $(go_go_types_files) big.gox bufio.gox fmt.gox go/ast.gox \\\n \t\tgo/token.gox io.gox os.gox path/filepath.gox runtime.gox \\\n-\t\tscanner.gox strconv.gox strings.gox\n+\t\tscanner.gox sort.gox strconv.gox strings.gox\n \t$(BUILDPACKAGE)\n go/types/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/types\n@@ -4954,7 +5315,7 @@ hash/adler32/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: hash/adler32/check\n \n-hash/crc32.lo: $(go_hash_crc32_files) hash.gox os.gox\n+hash/crc32.lo: $(go_hash_crc32_files) hash.gox os.gox sync.gox\n \t$(BUILDPACKAGE)\n hash/crc32/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) hash/crc32\n@@ -4975,10 +5336,9 @@ hash/fnv/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: hash/fnv/check\n \n-http/cgi.lo: $(go_http_cgi_files) bufio.gox bytes.gox crypto/tls.gox \\\n-\t\texec.gox fmt.gox http.gox net.gox io.gox io/ioutil.gox \\\n-\t\tlog.gox os.gox path/filepath.gox regexp.gox strconv.gox \\\n-\t\tstrings.gox\n+http/cgi.lo: $(go_http_cgi_files) bufio.gox crypto/tls.gox exec.gox fmt.gox \\\n+\t\thttp.gox net.gox io.gox io/ioutil.gox log.gox os.gox \\\n+\t\tpath/filepath.gox regexp.gox strconv.gox strings.gox url.gox\n \t$(BUILDPACKAGE)\n http/cgi/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) http/cgi\n@@ -4995,7 +5355,8 @@ http/fcgi/check: $(CHECK_DEPS)\n .PHONY: http/fcgi/check\n \n http/httptest.lo: $(go_http_httptest_files) bytes.gox crypto/rand.gox \\\n-\t\tcrypto/tls.gox fmt.gox http.gox net.gox os.gox time.gox\n+\t\tcrypto/tls.gox flag.gox fmt.gox http.gox net.gox os.gox \\\n+\t\ttime.gox\n \t$(BUILDPACKAGE)\n http/httptest/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) http/httptest\n@@ -5019,6 +5380,20 @@ http/spdy/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: http/spdy/check\n \n+image/bmp.lo: $(go_image_bmp_files) image.gox io.gox os.gox\n+\t$(BUILDPACKAGE)\n+image/bmp/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) image/bmp\n+\t@$(CHECK)\n+.PHONY: image/bmp/check\n+\n+image/draw.lo: $(go_image_draw_files) image.gox image/ycbcr.gox\n+\t$(BUILDPACKAGE)\n+image/draw/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) image/draw\n+\t@$(CHECK)\n+.PHONY: image/draw/check\n+\n image/gif.lo: $(go_image_gif_files) bufio.gox compress/lzw.gox fmt.gox \\\n \t\timage.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n@@ -5074,28 +5449,36 @@ io/ioutil/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: io/ioutil/check\n \n-mime/multipart.lo: $(go_mime_multipart_files) bufio.gox bytes.gox fmt.gox \\\n-\t\tio.gox io/ioutil.gox mime.gox net/textproto.gox os.gox \\\n-\t\tregexp.gox\n+mime/multipart.lo: $(go_mime_multipart_files) bufio.gox bytes.gox \\\n+\t\tcrypto/rand.gox fmt.gox io.gox io/ioutil.gox mime.gox \\\n+\t\tnet/textproto.gox os.gox strings.gox\n \t$(BUILDPACKAGE)\n mime/multipart/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) mime/multipart\n \t@$(CHECK)\n .PHONY: mime/multipart/check\n \n-net/dict.lo: $(go_net_dict_files) container/vector.gox net/textproto.gox \\\n-\t\tos.gox strconv.gox strings.gox\n+net/dict.lo: $(go_net_dict_files) net/textproto.gox os.gox strconv.gox \\\n+\t\tstrings.gox\n \t$(BUILDPACKAGE)\n \n-net/textproto.lo: $(go_net_textproto_files) bufio.gox bytes.gox \\\n-\t\tcontainer/vector.gox fmt.gox io.gox io/ioutil.gox net.gox \\\n-\t\tos.gox strconv.gox sync.gox\n+net/textproto.lo: $(go_net_textproto_files) bufio.gox bytes.gox fmt.gox \\\n+\t\tio.gox io/ioutil.gox net.gox os.gox strconv.gox sync.gox\n \t$(BUILDPACKAGE)\n net/textproto/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) net/textproto\n \t@$(CHECK)\n .PHONY: net/textproto/check\n \n+old/template.lo: $(go_old_template_files) bytes.gox fmt.gox io.gox \\\n+\t\tio/ioutil.gox os.gox reflect.gox strconv.gox strings.gox \\\n+\t\tunicode.gox utf8.gox\n+\t$(BUILDPACKAGE)\n+old/template/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) old/template\n+\t@$(CHECK)\n+.PHONY: old/template/check\n+\n os/inotify.lo: $(go_os_inotify_files) fmt.gox os.gox strings.gox syscall.gox\n \t$(BUILDPACKAGE)\n os/inotify/check: $(CHECK_DEPS)\n@@ -5111,19 +5494,15 @@ os/user/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: os/user/check\n \n-os/signal.lo: $(go_os_signal_files) runtime.gox strconv.gox\n+os/signal.lo: $(go_os_signal_files) os.gox runtime.gox\n \t$(BUILDPACKAGE)\n os/signal/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) os/signal\n \t@$(CHECK)\n .PHONY: os/signal/check\n \n-unix.go: $(srcdir)/go/os/signal/mkunix.sh sysinfo.go\n-\t$(SHELL) $(srcdir)/go/os/signal/mkunix.sh sysinfo.go > $@.tmp\n-\tmv -f $@.tmp $@\n-\n-path/filepath.lo: $(go_path_filepath_files) bytes.gox os.gox sort.gox \\\n-\t\tstrings.gox utf8.gox\n+path/filepath.lo: $(go_path_filepath_files) bytes.gox os.gox runtime.gox \\\n+\t\tsort.gox strings.gox utf8.gox\n \t$(BUILDPACKAGE)\n path/filepath/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) path/filepath\n@@ -5163,6 +5542,14 @@ sync/atomic/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: sync/atomic/check\n \n+template/parse.lo: $(go_template_parse_files) bytes.gox fmt.gox os.gox \\\n+\t\truntime.gox strconv.gox strings.gox unicode.gox utf8.gox\n+\t$(BUILDPACKAGE)\n+template/parse/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) template/parse\n+\t@$(CHECK)\n+.PHONY: template/parse/check\n+\n testing/iotest.lo: $(go_testing_iotest_files) io.gox log.gox os.gox\n \t$(BUILDPACKAGE)\n testing/iotest/check: $(CHECK_DEPS)\n@@ -5209,6 +5596,8 @@ cmath.gox: cmath/cmath.lo\n \t$(BUILDGOX)\n crypto.gox: crypto/crypto.lo\n \t$(BUILDGOX)\n+csv.gox: csv/csv.lo\n+\t$(BUILDGOX)\n ebnf.gox: ebnf/ebnf.lo\n \t$(BUILDGOX)\n exec.gox: exec/exec.lo\n@@ -5237,6 +5626,8 @@ log.gox: log/log.lo\n \t$(BUILDGOX)\n math.gox: math/math.lo\n \t$(BUILDGOX)\n+mail.gox: mail/mail.lo\n+\t$(BUILDGOX)\n mime.gox: mime/mime.lo\n \t$(BUILDGOX)\n net.gox: net/net.lo\n@@ -5287,6 +5678,8 @@ try.gox: try/try.lo\n \t$(BUILDGOX)\n unicode.gox: unicode/unicode.lo\n \t$(BUILDGOX)\n+url.gox: url/url.lo\n+\t$(BUILDGOX)\n utf16.gox: utf16/utf16.lo\n \t$(BUILDGOX)\n utf8.gox: utf8/utf8.lo\n@@ -5374,13 +5767,18 @@ crypto/xtea.gox: crypto/xtea.lo\n \n crypto/openpgp/armor.gox: crypto/openpgp/armor.lo\n \t$(BUILDGOX)\n+crypto/openpgp/elgamal.gox: crypto/openpgp/elgamal.lo\n+\t$(BUILDGOX)\n crypto/openpgp/error.gox: crypto/openpgp/error.lo\n \t$(BUILDGOX)\n crypto/openpgp/packet.gox: crypto/openpgp/packet.lo\n \t$(BUILDGOX)\n crypto/openpgp/s2k.gox: crypto/openpgp/s2k.lo\n \t$(BUILDGOX)\n \n+crypto/x509/pkix.gox: crypto/x509/pkix.lo\n+\t$(BUILDGOX)\n+\n debug/dwarf.gox: debug/dwarf.lo\n \t$(BUILDGOX)\n debug/elf.gox: debug/elf.lo\n@@ -5391,8 +5789,6 @@ debug/macho.gox: debug/macho.lo\n \t$(BUILDGOX)\n debug/pe.gox: debug/pe.lo\n \t$(BUILDGOX)\n-debug/proc.gox: debug/proc.lo\n-\t$(BUILDGOX)\n \n encoding/ascii85.gox: encoding/ascii85.lo\n \t$(BUILDGOX)\n@@ -5406,20 +5802,31 @@ encoding/git85.gox: encoding/git85.lo\n \t$(BUILDGOX)\n encoding/hex.gox: encoding/hex.lo\n \t$(BUILDGOX)\n-encoding/line.gox: encoding/line.lo\n-\t$(BUILDGOX)\n encoding/pem.gox: encoding/pem.lo\n \t$(BUILDGOX)\n \n exp/datafmt.gox: exp/datafmt.lo\n \t$(BUILDGOX)\n-exp/draw.gox: exp/draw.lo\n+exp/gui.gox: exp/gui.lo\n \t$(BUILDGOX)\n-exp/eval.gox: exp/eval.lo\n+exp/norm.gox: exp/norm.lo\n+\t$(BUILDGOX)\n+exp/regexp.gox: exp/regexp.lo\n+\t$(BUILDGOX)\n+\n+exp/gui/x11.gox: exp/gui/x11.lo\n+\t$(BUILDGOX)\n+\n+exp/regexp/syntax.gox: exp/regexp/syntax.lo\n+\t$(BUILDGOX)\n+\n+exp/template/html.gox: exp/template/html.lo\n \t$(BUILDGOX)\n \n go/ast.gox: go/ast.lo\n \t$(BUILDGOX)\n+go/build.gox: go/build.lo\n+\t$(BUILDGOX)\n go/doc.gox: go/doc.lo\n \t$(BUILDGOX)\n go/parser.gox: go/parser.lo\n@@ -5455,6 +5862,10 @@ http/pprof.gox: http/pprof.lo\n http/spdy.gox: http/spdy.lo\n \t$(BUILDGOX)\n \n+image/bmp.gox: image/bmp.lo\n+\t$(BUILDGOX)\n+image/draw.gox: image/draw.lo\n+\t$(BUILDGOX)\n image/gif.gox: image/gif.lo\n \t$(BUILDGOX)\n image/jpeg.gox: image/jpeg.lo\n@@ -5480,6 +5891,9 @@ net/dict.gox: net/dict.lo\n net/textproto.gox: net/textproto.lo\n \t$(BUILDGOX)\n \n+old/template.gox: old/template.lo\n+\t$(BUILDGOX)\n+\n os/inotify.gox: os/inotify.lo\n \t$(BUILDGOX)\n os/user.gox: os/user.lo\n@@ -5501,6 +5915,9 @@ runtime/pprof.gox: runtime/pprof.lo\n sync/atomic.gox: sync/atomic.lo\n \t$(BUILDGOX)\n \n+template/parse.gox: template/parse.lo\n+\t$(BUILDGOX)\n+\n testing/iotest.gox: testing/iotest.lo\n \t$(BUILDGOX)\n testing/quick.gox: testing/quick.lo"}, {"sha": "be4a13a8b52daae23426a93445806c31c620106c", "filename": "libgo/config.h.in", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfig.h.in?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -12,12 +12,24 @@\n /* Define to 1 if you have the <inttypes.h> header file. */\n #undef HAVE_INTTYPES_H\n \n+/* Define to 1 if you have the <linux/filter.h> header file. */\n+#undef HAVE_LINUX_FILTER_H\n+\n+/* Define to 1 if you have the <linux/netlink.h> header file. */\n+#undef HAVE_LINUX_NETLINK_H\n+\n+/* Define to 1 if you have the <linux/rtnetlink.h> header file. */\n+#undef HAVE_LINUX_RTNETLINK_H\n+\n /* Define to 1 if you have the <memory.h> header file. */\n #undef HAVE_MEMORY_H\n \n /* Define to 1 if you have the `mincore' function. */\n #undef HAVE_MINCORE\n \n+/* Define to 1 if you have the <net/if.h> header file. */\n+#undef HAVE_NET_IF_H\n+\n /* Define to 1 if the system has the type `off64_t'. */\n #undef HAVE_OFF64_T\n \n@@ -71,6 +83,9 @@\n /* Define to 1 if you have the <sys/select.h> header file. */\n #undef HAVE_SYS_SELECT_H\n \n+/* Define to 1 if you have the <sys/socket.h> header file. */\n+#undef HAVE_SYS_SOCKET_H\n+\n /* Define to 1 if you have the <sys/stat.h> header file. */\n #undef HAVE_SYS_STAT_H\n "}, {"sha": "e6b5d15ba5959213ba4b0c0609d804628cf37295", "filename": "libgo/configure", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -617,7 +617,6 @@ USING_SPLIT_STACK_FALSE\n USING_SPLIT_STACK_TRUE\n SPLIT_STACK\n OSCFLAGS\n-GO_DEBUG_PROC_REGS_OS_ARCH_FILE\n GO_SYSCALLS_SYSCALL_OS_ARCH_FILE\n GOARCH\n LIBGO_IS_X86_64_FALSE\n@@ -10914,7 +10913,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 10917 \"configure\"\n+#line 10916 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11020,7 +11019,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11023 \"configure\"\n+#line 11022 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -13558,12 +13557,6 @@ if test -f ${srcdir}/syscalls/syscall_${GOOS}_${GOARCH}.go; then\n fi\n \n \n-GO_DEBUG_PROC_REGS_OS_ARCH_FILE=\n-if test -f ${srcdir}/go/debug/proc/regs_${GOOS}_${GOARCH}.go; then\n-  GO_DEBUG_PROC_REGS_OS_ARCH_FILE=go/debug/proc/regs_${GOOS}_${GOARCH}.go\n-fi\n-\n-\n case \"$target\" in\n     mips-sgi-irix6.5*)\n \t# IRIX 6 needs _XOPEN_SOURCE=500 for the XPG5 version of struct\n@@ -14252,7 +14245,7 @@ no)\n   ;;\n esac\n \n-for ac_header in sys/mman.h syscall.h sys/epoll.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h\n+for ac_header in sys/mman.h syscall.h sys/epoll.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h\n do :\n   as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n ac_fn_c_check_header_mongrel \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\"\n@@ -14266,6 +14259,26 @@ fi\n \n done\n \n+\n+for ac_header in linux/filter.h linux/netlink.h linux/rtnetlink.h\n+do :\n+  as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n+ac_fn_c_check_header_compile \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"#ifdef HAVE_SYS_SOCKET_H\n+#include <sys/socket.h>\n+#endif\n+\n+\"\n+eval as_val=\\$$as_ac_Header\n+   if test \"x$as_val\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define `$as_echo \"HAVE_$ac_header\" | $as_tr_cpp` 1\n+_ACEOF\n+\n+fi\n+\n+done\n+\n+\n  if test \"$ac_cv_header_sys_mman_h\" = yes; then\n   HAVE_SYS_MMAN_H_TRUE=\n   HAVE_SYS_MMAN_H_FALSE='#'"}, {"sha": "6702c26c2f8415fc73985016c49ada14f023e647", "filename": "libgo/configure.ac", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -255,12 +255,6 @@ if test -f ${srcdir}/syscalls/syscall_${GOOS}_${GOARCH}.go; then\n fi\n AC_SUBST(GO_SYSCALLS_SYSCALL_OS_ARCH_FILE)\n \n-GO_DEBUG_PROC_REGS_OS_ARCH_FILE=\n-if test -f ${srcdir}/go/debug/proc/regs_${GOOS}_${GOARCH}.go; then\n-  GO_DEBUG_PROC_REGS_OS_ARCH_FILE=go/debug/proc/regs_${GOOS}_${GOARCH}.go\n-fi\n-AC_SUBST(GO_DEBUG_PROC_REGS_OS_ARCH_FILE)\n-\n dnl Some targets need special flags to build sysinfo.go.\n case \"$target\" in\n     mips-sgi-irix6.5*)\n@@ -431,7 +425,14 @@ no)\n   ;;\n esac\n \n-AC_CHECK_HEADERS(sys/mman.h syscall.h sys/epoll.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h)\n+AC_CHECK_HEADERS(sys/mman.h syscall.h sys/epoll.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h)\n+\n+AC_CHECK_HEADERS([linux/filter.h linux/netlink.h linux/rtnetlink.h], [], [],\n+[#ifdef HAVE_SYS_SOCKET_H\n+#include <sys/socket.h>\n+#endif\n+])\n+\n AM_CONDITIONAL(HAVE_SYS_MMAN_H, test \"$ac_cv_header_sys_mman_h\" = yes)\n \n AC_CHECK_FUNCS(srandom random strerror_r strsignal wait4 mincore setenv)"}, {"sha": "45d95c3df299feacdd74b2b4cad9ed8609e80aed", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -16,7 +16,7 @@ import (\n )\n \n var (\n-\tHeaderError os.Error = os.ErrorString(\"invalid tar header\")\n+\tHeaderError = os.NewError(\"invalid tar header\")\n )\n \n // A Reader provides sequential access to the contents of a tar archive."}, {"sha": "f473c900f262531105b2e614d933e6e9271758e5", "filename": "libgo/go/archive/tar/reader_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -178,7 +178,6 @@ func TestPartialRead(t *testing.T) {\n \t}\n }\n \n-\n func TestIncrementalRead(t *testing.T) {\n \ttest := gnuTarTest\n \tf, err := os.Open(test.file)"}, {"sha": "f92f9297ada8c65137c3c176a5b5057ff2b7b427", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 133, "deletions": 148, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -2,18 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-/*\n-Package zip provides support for reading ZIP archives.\n-\n-See: http://www.pkware.com/documents/casestudies/APPNOTE.TXT\n-\n-This package does not support ZIP64 or disk spanning.\n-*/\n package zip\n \n import (\n \t\"bufio\"\n-\t\"bytes\"\n \t\"compress/flate\"\n \t\"hash\"\n \t\"hash/crc32\"\n@@ -24,9 +16,9 @@ import (\n )\n \n var (\n-\tFormatError       = os.NewError(\"not a valid zip file\")\n-\tUnsupportedMethod = os.NewError(\"unsupported compression algorithm\")\n-\tChecksumError     = os.NewError(\"checksum error\")\n+\tFormatError       = os.NewError(\"zip: not a valid zip file\")\n+\tUnsupportedMethod = os.NewError(\"zip: unsupported compression algorithm\")\n+\tChecksumError     = os.NewError(\"zip: checksum error\")\n )\n \n type Reader struct {\n@@ -44,15 +36,14 @@ type File struct {\n \tFileHeader\n \tzipr         io.ReaderAt\n \tzipsize      int64\n-\theaderOffset uint32\n-\tbodyOffset   int64\n+\theaderOffset int64\n }\n \n func (f *File) hasDataDescriptor() bool {\n \treturn f.Flags&0x8 != 0\n }\n \n-// OpenReader will open the Zip file specified by name and return a ReaderCloser.\n+// OpenReader will open the Zip file specified by name and return a ReadCloser.\n func OpenReader(name string) (*ReadCloser, os.Error) {\n \tf, err := os.Open(name)\n \tif err != nil {\n@@ -87,18 +78,33 @@ func (z *Reader) init(r io.ReaderAt, size int64) os.Error {\n \t\treturn err\n \t}\n \tz.r = r\n-\tz.File = make([]*File, end.directoryRecords)\n+\tz.File = make([]*File, 0, end.directoryRecords)\n \tz.Comment = end.comment\n \trs := io.NewSectionReader(r, 0, size)\n \tif _, err = rs.Seek(int64(end.directoryOffset), os.SEEK_SET); err != nil {\n \t\treturn err\n \t}\n \tbuf := bufio.NewReader(rs)\n-\tfor i := range z.File {\n-\t\tz.File[i] = &File{zipr: r, zipsize: size}\n-\t\tif err := readDirectoryHeader(z.File[i], buf); err != nil {\n+\n+\t// The count of files inside a zip is truncated to fit in a uint16.\n+\t// Gloss over this by reading headers until we encounter\n+\t// a bad one, and then only report a FormatError or UnexpectedEOF if\n+\t// the file count modulo 65536 is incorrect.\n+\tfor {\n+\t\tf := &File{zipr: r, zipsize: size}\n+\t\terr = readDirectoryHeader(f, buf)\n+\t\tif err == FormatError || err == io.ErrUnexpectedEOF {\n+\t\t\tbreak\n+\t\t}\n+\t\tif err != nil {\n \t\t\treturn err\n \t\t}\n+\t\tz.File = append(z.File, f)\n+\t}\n+\tif uint16(len(z.File)) != end.directoryRecords {\n+\t\t// Return the readDirectoryHeader error if we read\n+\t\t// the wrong number of directory entries.\n+\t\treturn err\n \t}\n \treturn nil\n }\n@@ -109,31 +115,22 @@ func (rc *ReadCloser) Close() os.Error {\n }\n \n // Open returns a ReadCloser that provides access to the File's contents.\n+// It is safe to Open and Read from files concurrently.\n func (f *File) Open() (rc io.ReadCloser, err os.Error) {\n-\toff := int64(f.headerOffset)\n-\tif f.bodyOffset == 0 {\n-\t\tr := io.NewSectionReader(f.zipr, off, f.zipsize-off)\n-\t\tif err = readFileHeader(f, r); err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tif f.bodyOffset, err = r.Seek(0, os.SEEK_CUR); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tbodyOffset, err := f.findBodyOffset()\n+\tif err != nil {\n+\t\treturn\n \t}\n \tsize := int64(f.CompressedSize)\n-\tif f.hasDataDescriptor() {\n-\t\tif size == 0 {\n-\t\t\t// permit SectionReader to see the rest of the file\n-\t\t\tsize = f.zipsize - (off + f.bodyOffset)\n-\t\t} else {\n-\t\t\tsize += dataDescriptorLen\n-\t\t}\n+\tif size == 0 && f.hasDataDescriptor() {\n+\t\t// permit SectionReader to see the rest of the file\n+\t\tsize = f.zipsize - (f.headerOffset + bodyOffset)\n \t}\n-\tr := io.NewSectionReader(f.zipr, off+f.bodyOffset, size)\n+\tr := io.NewSectionReader(f.zipr, f.headerOffset+bodyOffset, size)\n \tswitch f.Method {\n-\tcase 0: // store (no compression)\n+\tcase Store: // (no compression)\n \t\trc = ioutil.NopCloser(r)\n-\tcase 8: // DEFLATE\n+\tcase Deflate:\n \t\trc = flate.NewReader(r)\n \tdefault:\n \t\terr = UnsupportedMethod\n@@ -170,90 +167,102 @@ func (r *checksumReader) Read(b []byte) (n int, err os.Error) {\n \n func (r *checksumReader) Close() os.Error { return r.rc.Close() }\n \n-func readFileHeader(f *File, r io.Reader) (err os.Error) {\n-\tdefer func() {\n-\t\tif rerr, ok := recover().(os.Error); ok {\n-\t\t\terr = rerr\n-\t\t}\n-\t}()\n-\tvar (\n-\t\tsignature      uint32\n-\t\tfilenameLength uint16\n-\t\textraLength    uint16\n-\t)\n-\tread(r, &signature)\n-\tif signature != fileHeaderSignature {\n+func readFileHeader(f *File, r io.Reader) os.Error {\n+\tvar b [fileHeaderLen]byte\n+\tif _, err := io.ReadFull(r, b[:]); err != nil {\n+\t\treturn err\n+\t}\n+\tc := binary.LittleEndian\n+\tif sig := c.Uint32(b[:4]); sig != fileHeaderSignature {\n \t\treturn FormatError\n \t}\n-\tread(r, &f.ReaderVersion)\n-\tread(r, &f.Flags)\n-\tread(r, &f.Method)\n-\tread(r, &f.ModifiedTime)\n-\tread(r, &f.ModifiedDate)\n-\tread(r, &f.CRC32)\n-\tread(r, &f.CompressedSize)\n-\tread(r, &f.UncompressedSize)\n-\tread(r, &filenameLength)\n-\tread(r, &extraLength)\n-\tf.Name = string(readByteSlice(r, filenameLength))\n-\tf.Extra = readByteSlice(r, extraLength)\n-\treturn\n+\tf.ReaderVersion = c.Uint16(b[4:6])\n+\tf.Flags = c.Uint16(b[6:8])\n+\tf.Method = c.Uint16(b[8:10])\n+\tf.ModifiedTime = c.Uint16(b[10:12])\n+\tf.ModifiedDate = c.Uint16(b[12:14])\n+\tf.CRC32 = c.Uint32(b[14:18])\n+\tf.CompressedSize = c.Uint32(b[18:22])\n+\tf.UncompressedSize = c.Uint32(b[22:26])\n+\tfilenameLen := int(c.Uint16(b[26:28]))\n+\textraLen := int(c.Uint16(b[28:30]))\n+\td := make([]byte, filenameLen+extraLen)\n+\tif _, err := io.ReadFull(r, d); err != nil {\n+\t\treturn err\n+\t}\n+\tf.Name = string(d[:filenameLen])\n+\tf.Extra = d[filenameLen:]\n+\treturn nil\n }\n \n-func readDirectoryHeader(f *File, r io.Reader) (err os.Error) {\n-\tdefer func() {\n-\t\tif rerr, ok := recover().(os.Error); ok {\n-\t\t\terr = rerr\n-\t\t}\n-\t}()\n-\tvar (\n-\t\tsignature          uint32\n-\t\tfilenameLength     uint16\n-\t\textraLength        uint16\n-\t\tcommentLength      uint16\n-\t\tstartDiskNumber    uint16 // unused\n-\t\tinternalAttributes uint16 // unused\n-\t\texternalAttributes uint32 // unused\n-\t)\n-\tread(r, &signature)\n-\tif signature != directoryHeaderSignature {\n+// findBodyOffset does the minimum work to verify the file has a header\n+// and returns the file body offset.\n+func (f *File) findBodyOffset() (int64, os.Error) {\n+\tr := io.NewSectionReader(f.zipr, f.headerOffset, f.zipsize-f.headerOffset)\n+\tvar b [fileHeaderLen]byte\n+\tif _, err := io.ReadFull(r, b[:]); err != nil {\n+\t\treturn 0, err\n+\t}\n+\tc := binary.LittleEndian\n+\tif sig := c.Uint32(b[:4]); sig != fileHeaderSignature {\n+\t\treturn 0, FormatError\n+\t}\n+\tfilenameLen := int(c.Uint16(b[26:28]))\n+\textraLen := int(c.Uint16(b[28:30]))\n+\treturn int64(fileHeaderLen + filenameLen + extraLen), nil\n+}\n+\n+// readDirectoryHeader attempts to read a directory header from r.\n+// It returns io.ErrUnexpectedEOF if it cannot read a complete header,\n+// and FormatError if it doesn't find a valid header signature.\n+func readDirectoryHeader(f *File, r io.Reader) os.Error {\n+\tvar b [directoryHeaderLen]byte\n+\tif _, err := io.ReadFull(r, b[:]); err != nil {\n+\t\treturn err\n+\t}\n+\tc := binary.LittleEndian\n+\tif sig := c.Uint32(b[:4]); sig != directoryHeaderSignature {\n \t\treturn FormatError\n \t}\n-\tread(r, &f.CreatorVersion)\n-\tread(r, &f.ReaderVersion)\n-\tread(r, &f.Flags)\n-\tread(r, &f.Method)\n-\tread(r, &f.ModifiedTime)\n-\tread(r, &f.ModifiedDate)\n-\tread(r, &f.CRC32)\n-\tread(r, &f.CompressedSize)\n-\tread(r, &f.UncompressedSize)\n-\tread(r, &filenameLength)\n-\tread(r, &extraLength)\n-\tread(r, &commentLength)\n-\tread(r, &startDiskNumber)\n-\tread(r, &internalAttributes)\n-\tread(r, &externalAttributes)\n-\tread(r, &f.headerOffset)\n-\tf.Name = string(readByteSlice(r, filenameLength))\n-\tf.Extra = readByteSlice(r, extraLength)\n-\tf.Comment = string(readByteSlice(r, commentLength))\n-\treturn\n+\tf.CreatorVersion = c.Uint16(b[4:6])\n+\tf.ReaderVersion = c.Uint16(b[6:8])\n+\tf.Flags = c.Uint16(b[8:10])\n+\tf.Method = c.Uint16(b[10:12])\n+\tf.ModifiedTime = c.Uint16(b[12:14])\n+\tf.ModifiedDate = c.Uint16(b[14:16])\n+\tf.CRC32 = c.Uint32(b[16:20])\n+\tf.CompressedSize = c.Uint32(b[20:24])\n+\tf.UncompressedSize = c.Uint32(b[24:28])\n+\tfilenameLen := int(c.Uint16(b[28:30]))\n+\textraLen := int(c.Uint16(b[30:32]))\n+\tcommentLen := int(c.Uint16(b[32:34]))\n+\t// startDiskNumber := c.Uint16(b[34:36])    // Unused\n+\t// internalAttributes := c.Uint16(b[36:38]) // Unused\n+\t// externalAttributes := c.Uint32(b[38:42]) // Unused\n+\tf.headerOffset = int64(c.Uint32(b[42:46]))\n+\td := make([]byte, filenameLen+extraLen+commentLen)\n+\tif _, err := io.ReadFull(r, d); err != nil {\n+\t\treturn err\n+\t}\n+\tf.Name = string(d[:filenameLen])\n+\tf.Extra = d[filenameLen : filenameLen+extraLen]\n+\tf.Comment = string(d[filenameLen+extraLen:])\n+\treturn nil\n }\n \n-func readDataDescriptor(r io.Reader, f *File) (err os.Error) {\n-\tdefer func() {\n-\t\tif rerr, ok := recover().(os.Error); ok {\n-\t\t\terr = rerr\n-\t\t}\n-\t}()\n-\tread(r, &f.CRC32)\n-\tread(r, &f.CompressedSize)\n-\tread(r, &f.UncompressedSize)\n-\treturn\n+func readDataDescriptor(r io.Reader, f *File) os.Error {\n+\tvar b [dataDescriptorLen]byte\n+\tif _, err := io.ReadFull(r, b[:]); err != nil {\n+\t\treturn err\n+\t}\n+\tc := binary.LittleEndian\n+\tf.CRC32 = c.Uint32(b[:4])\n+\tf.CompressedSize = c.Uint32(b[4:8])\n+\tf.UncompressedSize = c.Uint32(b[8:12])\n+\treturn nil\n }\n \n-func readDirectoryEnd(r io.ReaderAt, size int64) (d *directoryEnd, err os.Error) {\n+func readDirectoryEnd(r io.ReaderAt, size int64) (dir *directoryEnd, err os.Error) {\n \t// look for directoryEndSignature in the last 1k, then in the last 65k\n \tvar b []byte\n \tfor i, bLen := range []int64{1024, 65 * 1024} {\n@@ -274,53 +283,29 @@ func readDirectoryEnd(r io.ReaderAt, size int64) (d *directoryEnd, err os.Error)\n \t}\n \n \t// read header into struct\n-\tdefer func() {\n-\t\tif rerr, ok := recover().(os.Error); ok {\n-\t\t\terr = rerr\n-\t\t\td = nil\n-\t\t}\n-\t}()\n-\tbr := bytes.NewBuffer(b[4:]) // skip over signature\n-\td = new(directoryEnd)\n-\tread(br, &d.diskNbr)\n-\tread(br, &d.dirDiskNbr)\n-\tread(br, &d.dirRecordsThisDisk)\n-\tread(br, &d.directoryRecords)\n-\tread(br, &d.directorySize)\n-\tread(br, &d.directoryOffset)\n-\tread(br, &d.commentLen)\n-\td.comment = string(readByteSlice(br, d.commentLen))\n+\tc := binary.LittleEndian\n+\td := new(directoryEnd)\n+\td.diskNbr = c.Uint16(b[4:6])\n+\td.dirDiskNbr = c.Uint16(b[6:8])\n+\td.dirRecordsThisDisk = c.Uint16(b[8:10])\n+\td.directoryRecords = c.Uint16(b[10:12])\n+\td.directorySize = c.Uint32(b[12:16])\n+\td.directoryOffset = c.Uint32(b[16:20])\n+\td.commentLen = c.Uint16(b[20:22])\n+\td.comment = string(b[22 : 22+int(d.commentLen)])\n \treturn d, nil\n }\n \n func findSignatureInBlock(b []byte) int {\n-\tconst minSize = 4 + 2 + 2 + 2 + 2 + 4 + 4 + 2 // fixed part of header\n-\tfor i := len(b) - minSize; i >= 0; i-- {\n+\tfor i := len(b) - directoryEndLen; i >= 0; i-- {\n \t\t// defined from directoryEndSignature in struct.go\n \t\tif b[i] == 'P' && b[i+1] == 'K' && b[i+2] == 0x05 && b[i+3] == 0x06 {\n \t\t\t// n is length of comment\n-\t\t\tn := int(b[i+minSize-2]) | int(b[i+minSize-1])<<8\n-\t\t\tif n+minSize+i == len(b) {\n+\t\t\tn := int(b[i+directoryEndLen-2]) | int(b[i+directoryEndLen-1])<<8\n+\t\t\tif n+directoryEndLen+i == len(b) {\n \t\t\t\treturn i\n \t\t\t}\n \t\t}\n \t}\n \treturn -1\n }\n-\n-func read(r io.Reader, data interface{}) {\n-\tif err := binary.Read(r, binary.LittleEndian, data); err != nil {\n-\t\tpanic(err)\n-\t}\n-}\n-\n-func readByteSlice(r io.Reader, l uint16) []byte {\n-\tb := make([]byte, l)\n-\tif l == 0 {\n-\t\treturn b\n-\t}\n-\tif _, err := io.ReadFull(r, b); err != nil {\n-\t\tpanic(err)\n-\t}\n-\treturn b\n-}"}, {"sha": "fd5fed2af05fa12acde9e437a518a0a487d22941", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"io/ioutil\"\n \t\"os\"\n \t\"testing\"\n+\t\"time\"\n )\n \n type ZipTest struct {\n@@ -24,8 +25,19 @@ type ZipTestFile struct {\n \tName    string\n \tContent []byte // if blank, will attempt to compare against File\n \tFile    string // name of file to compare to (relative to testdata/)\n+\tMtime   string // modified time in format \"mm-dd-yy hh:mm:ss\"\n }\n \n+// Caution: The Mtime values found for the test files should correspond to\n+//          the values listed with unzip -l <zipfile>. However, the values\n+//          listed by unzip appear to be off by some hours. When creating\n+//          fresh test files and testing them, this issue is not present.\n+//          The test files were created in Sydney, so there might be a time\n+//          zone issue. The time zone information does have to be encoded\n+//          somewhere, because otherwise unzip -l could not provide a different\n+//          time from what the archive/zip package provides, but there appears\n+//          to be no documentation about this.\n+\n var tests = []ZipTest{\n \t{\n \t\tName:    \"test.zip\",\n@@ -34,19 +46,22 @@ var tests = []ZipTest{\n \t\t\t{\n \t\t\t\tName:    \"test.txt\",\n \t\t\t\tContent: []byte(\"This is a test text file.\\n\"),\n+\t\t\t\tMtime:   \"09-05-10 12:12:02\",\n \t\t\t},\n \t\t\t{\n-\t\t\t\tName: \"gophercolor16x16.png\",\n-\t\t\t\tFile: \"gophercolor16x16.png\",\n+\t\t\t\tName:  \"gophercolor16x16.png\",\n+\t\t\t\tFile:  \"gophercolor16x16.png\",\n+\t\t\t\tMtime: \"09-05-10 15:52:58\",\n \t\t\t},\n \t\t},\n \t},\n \t{\n \t\tName: \"r.zip\",\n \t\tFile: []ZipTestFile{\n \t\t\t{\n-\t\t\t\tName: \"r/r.zip\",\n-\t\t\t\tFile: \"r.zip\",\n+\t\t\t\tName:  \"r/r.zip\",\n+\t\t\t\tFile:  \"r.zip\",\n+\t\t\t\tMtime: \"03-04-10 00:24:16\",\n \t\t\t},\n \t\t},\n \t},\n@@ -58,6 +73,7 @@ var tests = []ZipTest{\n \t\t\t{\n \t\t\t\tName:    \"filename\",\n \t\t\t\tContent: []byte(\"This is a test textfile.\\n\"),\n+\t\t\t\tMtime:   \"02-02-11 13:06:20\",\n \t\t\t},\n \t\t},\n \t},\n@@ -136,29 +152,49 @@ func readTestFile(t *testing.T, ft ZipTestFile, f *File) {\n \tif f.Name != ft.Name {\n \t\tt.Errorf(\"name=%q, want %q\", f.Name, ft.Name)\n \t}\n+\n+\tmtime, err := time.Parse(\"01-02-06 15:04:05\", ft.Mtime)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\tif got, want := f.Mtime_ns()/1e9, mtime.Seconds(); got != want {\n+\t\tt.Errorf(\"%s: mtime=%s (%d); want %s (%d)\", f.Name, time.SecondsToUTC(got), got, mtime, want)\n+\t}\n+\n+\tsize0 := f.UncompressedSize\n+\n \tvar b bytes.Buffer\n \tr, err := f.Open()\n \tif err != nil {\n \t\tt.Error(err)\n \t\treturn\n \t}\n+\n+\tif size1 := f.UncompressedSize; size0 != size1 {\n+\t\tt.Errorf(\"file %q changed f.UncompressedSize from %d to %d\", f.Name, size0, size1)\n+\t}\n+\n \t_, err = io.Copy(&b, r)\n \tif err != nil {\n \t\tt.Error(err)\n \t\treturn\n \t}\n \tr.Close()\n+\n \tvar c []byte\n \tif len(ft.Content) != 0 {\n \t\tc = ft.Content\n \t} else if c, err = ioutil.ReadFile(\"testdata/\" + ft.File); err != nil {\n \t\tt.Error(err)\n \t\treturn\n \t}\n+\n \tif b.Len() != len(c) {\n \t\tt.Errorf(\"%s: len=%d, want %d\", f.Name, b.Len(), len(c))\n \t\treturn\n \t}\n+\n \tfor i, b := range b.Bytes() {\n \t\tif b != c[i] {\n \t\t\tt.Errorf(\"%s: content[%d]=%q want %q\", f.Name, i, b, c[i])"}, {"sha": "1d6e70f105a9299a781acf551a6cfe85e78f52fe", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -1,9 +1,32 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+/*\n+Package zip provides support for reading and writing ZIP archives.\n+\n+See: http://www.pkware.com/documents/casestudies/APPNOTE.TXT\n+\n+This package does not support ZIP64 or disk spanning.\n+*/\n package zip\n \n+import \"os\"\n+import \"time\"\n+\n+// Compression methods.\n+const (\n+\tStore   uint16 = 0\n+\tDeflate uint16 = 8\n+)\n+\n const (\n \tfileHeaderSignature      = 0x04034b50\n \tdirectoryHeaderSignature = 0x02014b50\n \tdirectoryEndSignature    = 0x06054b50\n+\tfileHeaderLen            = 30 // + filename + extra\n+\tdirectoryHeaderLen       = 46 // + filename + extra + comment\n+\tdirectoryEndLen          = 22 // + comment\n \tdataDescriptorLen        = 12\n )\n \n@@ -13,8 +36,8 @@ type FileHeader struct {\n \tReaderVersion    uint16\n \tFlags            uint16\n \tMethod           uint16\n-\tModifiedTime     uint16\n-\tModifiedDate     uint16\n+\tModifiedTime     uint16 // MS-DOS time\n+\tModifiedDate     uint16 // MS-DOS date\n \tCRC32            uint32\n \tCompressedSize   uint32\n \tUncompressedSize uint32\n@@ -32,3 +55,37 @@ type directoryEnd struct {\n \tcommentLen         uint16\n \tcomment            string\n }\n+\n+func recoverError(err *os.Error) {\n+\tif e := recover(); e != nil {\n+\t\tif osErr, ok := e.(os.Error); ok {\n+\t\t\t*err = osErr\n+\t\t\treturn\n+\t\t}\n+\t\tpanic(e)\n+\t}\n+}\n+\n+// msDosTimeToTime converts an MS-DOS date and time into a time.Time.\n+// The resolution is 2s.\n+// See: http://msdn.microsoft.com/en-us/library/ms724247(v=VS.85).aspx\n+func msDosTimeToTime(dosDate, dosTime uint16) time.Time {\n+\treturn time.Time{\n+\t\t// date bits 0-4: day of month; 5-8: month; 9-15: years since 1980\n+\t\tYear:  int64(dosDate>>9 + 1980),\n+\t\tMonth: int(dosDate >> 5 & 0xf),\n+\t\tDay:   int(dosDate & 0x1f),\n+\n+\t\t// time bits 0-4: second/2; 5-10: minute; 11-15: hour\n+\t\tHour:   int(dosTime >> 11),\n+\t\tMinute: int(dosTime >> 5 & 0x3f),\n+\t\tSecond: int(dosTime & 0x1f * 2),\n+\t}\n+}\n+\n+// Mtime_ns returns the modified time in ns since epoch.\n+// The resolution is 2s.\n+func (h *FileHeader) Mtime_ns() int64 {\n+\tt := msDosTimeToTime(h.ModifiedDate, h.ModifiedTime)\n+\treturn t.Seconds() * 1e9\n+}"}, {"sha": "2065b06daac80fd8eebf8dd38de68ecaebd05273", "filename": "libgo/go/archive/zip/writer.go", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -0,0 +1,244 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package zip\n+\n+import (\n+\t\"bufio\"\n+\t\"compress/flate\"\n+\t\"encoding/binary\"\n+\t\"hash\"\n+\t\"hash/crc32\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// TODO(adg): support zip file comments\n+// TODO(adg): support specifying deflate level\n+\n+// Writer implements a zip file writer.\n+type Writer struct {\n+\t*countWriter\n+\tdir    []*header\n+\tlast   *fileWriter\n+\tclosed bool\n+}\n+\n+type header struct {\n+\t*FileHeader\n+\toffset uint32\n+}\n+\n+// NewWriter returns a new Writer writing a zip file to w.\n+func NewWriter(w io.Writer) *Writer {\n+\treturn &Writer{countWriter: &countWriter{w: bufio.NewWriter(w)}}\n+}\n+\n+// Close finishes writing the zip file by writing the central directory.\n+// It does not (and can not) close the underlying writer.\n+func (w *Writer) Close() (err os.Error) {\n+\tif w.last != nil && !w.last.closed {\n+\t\tif err = w.last.close(); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tw.last = nil\n+\t}\n+\tif w.closed {\n+\t\treturn os.NewError(\"zip: writer closed twice\")\n+\t}\n+\tw.closed = true\n+\n+\tdefer recoverError(&err)\n+\n+\t// write central directory\n+\tstart := w.count\n+\tfor _, h := range w.dir {\n+\t\twrite(w, uint32(directoryHeaderSignature))\n+\t\twrite(w, h.CreatorVersion)\n+\t\twrite(w, h.ReaderVersion)\n+\t\twrite(w, h.Flags)\n+\t\twrite(w, h.Method)\n+\t\twrite(w, h.ModifiedTime)\n+\t\twrite(w, h.ModifiedDate)\n+\t\twrite(w, h.CRC32)\n+\t\twrite(w, h.CompressedSize)\n+\t\twrite(w, h.UncompressedSize)\n+\t\twrite(w, uint16(len(h.Name)))\n+\t\twrite(w, uint16(len(h.Extra)))\n+\t\twrite(w, uint16(len(h.Comment)))\n+\t\twrite(w, uint16(0)) // disk number start\n+\t\twrite(w, uint16(0)) // internal file attributes\n+\t\twrite(w, uint32(0)) // external file attributes\n+\t\twrite(w, h.offset)\n+\t\twriteBytes(w, []byte(h.Name))\n+\t\twriteBytes(w, h.Extra)\n+\t\twriteBytes(w, []byte(h.Comment))\n+\t}\n+\tend := w.count\n+\n+\t// write end record\n+\twrite(w, uint32(directoryEndSignature))\n+\twrite(w, uint16(0))          // disk number\n+\twrite(w, uint16(0))          // disk number where directory starts\n+\twrite(w, uint16(len(w.dir))) // number of entries this disk\n+\twrite(w, uint16(len(w.dir))) // number of entries total\n+\twrite(w, uint32(end-start))  // size of directory\n+\twrite(w, uint32(start))      // start of directory\n+\twrite(w, uint16(0))          // size of comment\n+\n+\treturn w.w.(*bufio.Writer).Flush()\n+}\n+\n+// Create adds a file to the zip file using the provided name.\n+// It returns a Writer to which the file contents should be written.\n+// The file's contents must be written to the io.Writer before the next\n+// call to Create, CreateHeader, or Close.\n+func (w *Writer) Create(name string) (io.Writer, os.Error) {\n+\theader := &FileHeader{\n+\t\tName:   name,\n+\t\tMethod: Deflate,\n+\t}\n+\treturn w.CreateHeader(header)\n+}\n+\n+// CreateHeader adds a file to the zip file using the provided FileHeader\n+// for the file metadata. \n+// It returns a Writer to which the file contents should be written.\n+// The file's contents must be written to the io.Writer before the next\n+// call to Create, CreateHeader, or Close.\n+func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, os.Error) {\n+\tif w.last != nil && !w.last.closed {\n+\t\tif err := w.last.close(); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tfh.Flags |= 0x8 // we will write a data descriptor\n+\tfh.CreatorVersion = 0x14\n+\tfh.ReaderVersion = 0x14\n+\n+\tfw := &fileWriter{\n+\t\tzipw:      w,\n+\t\tcompCount: &countWriter{w: w},\n+\t\tcrc32:     crc32.NewIEEE(),\n+\t}\n+\tswitch fh.Method {\n+\tcase Store:\n+\t\tfw.comp = nopCloser{fw.compCount}\n+\tcase Deflate:\n+\t\tfw.comp = flate.NewWriter(fw.compCount, 5)\n+\tdefault:\n+\t\treturn nil, UnsupportedMethod\n+\t}\n+\tfw.rawCount = &countWriter{w: fw.comp}\n+\n+\th := &header{\n+\t\tFileHeader: fh,\n+\t\toffset:     uint32(w.count),\n+\t}\n+\tw.dir = append(w.dir, h)\n+\tfw.header = h\n+\n+\tif err := writeHeader(w, fh); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tw.last = fw\n+\treturn fw, nil\n+}\n+\n+func writeHeader(w io.Writer, h *FileHeader) (err os.Error) {\n+\tdefer recoverError(&err)\n+\twrite(w, uint32(fileHeaderSignature))\n+\twrite(w, h.ReaderVersion)\n+\twrite(w, h.Flags)\n+\twrite(w, h.Method)\n+\twrite(w, h.ModifiedTime)\n+\twrite(w, h.ModifiedDate)\n+\twrite(w, h.CRC32)\n+\twrite(w, h.CompressedSize)\n+\twrite(w, h.UncompressedSize)\n+\twrite(w, uint16(len(h.Name)))\n+\twrite(w, uint16(len(h.Extra)))\n+\twriteBytes(w, []byte(h.Name))\n+\twriteBytes(w, h.Extra)\n+\treturn nil\n+}\n+\n+type fileWriter struct {\n+\t*header\n+\tzipw      io.Writer\n+\trawCount  *countWriter\n+\tcomp      io.WriteCloser\n+\tcompCount *countWriter\n+\tcrc32     hash.Hash32\n+\tclosed    bool\n+}\n+\n+func (w *fileWriter) Write(p []byte) (int, os.Error) {\n+\tif w.closed {\n+\t\treturn 0, os.NewError(\"zip: write to closed file\")\n+\t}\n+\tw.crc32.Write(p)\n+\treturn w.rawCount.Write(p)\n+}\n+\n+func (w *fileWriter) close() (err os.Error) {\n+\tif w.closed {\n+\t\treturn os.NewError(\"zip: file closed twice\")\n+\t}\n+\tw.closed = true\n+\tif err = w.comp.Close(); err != nil {\n+\t\treturn\n+\t}\n+\n+\t// update FileHeader\n+\tfh := w.header.FileHeader\n+\tfh.CRC32 = w.crc32.Sum32()\n+\tfh.CompressedSize = uint32(w.compCount.count)\n+\tfh.UncompressedSize = uint32(w.rawCount.count)\n+\n+\t// write data descriptor\n+\tdefer recoverError(&err)\n+\twrite(w.zipw, fh.CRC32)\n+\twrite(w.zipw, fh.CompressedSize)\n+\twrite(w.zipw, fh.UncompressedSize)\n+\n+\treturn nil\n+}\n+\n+type countWriter struct {\n+\tw     io.Writer\n+\tcount int64\n+}\n+\n+func (w *countWriter) Write(p []byte) (int, os.Error) {\n+\tn, err := w.w.Write(p)\n+\tw.count += int64(n)\n+\treturn n, err\n+}\n+\n+type nopCloser struct {\n+\tio.Writer\n+}\n+\n+func (w nopCloser) Close() os.Error {\n+\treturn nil\n+}\n+\n+func write(w io.Writer, data interface{}) {\n+\tif err := binary.Write(w, binary.LittleEndian, data); err != nil {\n+\t\tpanic(err)\n+\t}\n+}\n+\n+func writeBytes(w io.Writer, b []byte) {\n+\tn, err := w.Write(b)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tif n != len(b) {\n+\t\tpanic(io.ErrShortWrite)\n+\t}\n+}"}, {"sha": "eb2a80c3f7027b9710c6611775346a8f4564d626", "filename": "libgo/go/archive/zip/writer_test.go", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package zip\n+\n+import (\n+\t\"bytes\"\n+\t\"io/ioutil\"\n+\t\"rand\"\n+\t\"testing\"\n+)\n+\n+// TODO(adg): a more sophisticated test suite\n+\n+const testString = \"Rabbits, guinea pigs, gophers, marsupial rats, and quolls.\"\n+\n+func TestWriter(t *testing.T) {\n+\tlargeData := make([]byte, 1<<17)\n+\tfor i := range largeData {\n+\t\tlargeData[i] = byte(rand.Int())\n+\t}\n+\n+\t// write a zip file\n+\tbuf := new(bytes.Buffer)\n+\tw := NewWriter(buf)\n+\ttestCreate(t, w, \"foo\", []byte(testString), Store)\n+\ttestCreate(t, w, \"bar\", largeData, Deflate)\n+\tif err := w.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// read it back\n+\tr, err := NewReader(sliceReaderAt(buf.Bytes()), int64(buf.Len()))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\ttestReadFile(t, r.File[0], []byte(testString))\n+\ttestReadFile(t, r.File[1], largeData)\n+}\n+\n+func testCreate(t *testing.T, w *Writer, name string, data []byte, method uint16) {\n+\theader := &FileHeader{\n+\t\tName:   name,\n+\t\tMethod: method,\n+\t}\n+\tf, err := w.CreateHeader(header)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t_, err = f.Write(data)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n+func testReadFile(t *testing.T, f *File, data []byte) {\n+\trc, err := f.Open()\n+\tif err != nil {\n+\t\tt.Fatal(\"opening:\", err)\n+\t}\n+\tb, err := ioutil.ReadAll(rc)\n+\tif err != nil {\n+\t\tt.Fatal(\"reading:\", err)\n+\t}\n+\terr = rc.Close()\n+\tif err != nil {\n+\t\tt.Fatal(\"closing:\", err)\n+\t}\n+\tif !bytes.Equal(b, data) {\n+\t\tt.Errorf(\"File contents %q, want %q\", b, data)\n+\t}\n+}"}, {"sha": "0f71fdfac17970ae5e14f74ea8c7f4661e6050e3", "filename": "libgo/go/archive/zip/zip_test.go", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Tests that involve both reading and writing.\n+\n+package zip\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+type stringReaderAt string\n+\n+func (s stringReaderAt) ReadAt(p []byte, off int64) (n int, err os.Error) {\n+\tif off >= int64(len(s)) {\n+\t\treturn 0, os.EOF\n+\t}\n+\tn = copy(p, s[off:])\n+\treturn\n+}\n+\n+func TestOver65kFiles(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Logf(\"slow test; skipping\")\n+\t\treturn\n+\t}\n+\tbuf := new(bytes.Buffer)\n+\tw := NewWriter(buf)\n+\tconst nFiles = (1 << 16) + 42\n+\tfor i := 0; i < nFiles; i++ {\n+\t\t_, err := w.Create(fmt.Sprintf(\"%d.dat\", i))\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"creating file %d: %v\", i, err)\n+\t\t}\n+\t}\n+\tif err := w.Close(); err != nil {\n+\t\tt.Fatalf(\"Writer.Close: %v\", err)\n+\t}\n+\trat := stringReaderAt(buf.String())\n+\tzr, err := NewReader(rat, int64(len(rat)))\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewReader: %v\", err)\n+\t}\n+\tif got := len(zr.File); got != nFiles {\n+\t\tt.Fatalf(\"File contains %d files, want %d\", got, nFiles)\n+\t}\n+\tfor i := 0; i < nFiles; i++ {\n+\t\twant := fmt.Sprintf(\"%d.dat\", i)\n+\t\tif zr.File[i].Name != want {\n+\t\t\tt.Fatalf(\"File(%d) = %q, want %q\", i, zr.File[i].Name, want)\n+\t\t}\n+\t}\n+}"}, {"sha": "39b676b4190e834e0bf726d672742e4a6ff9354e", "filename": "libgo/go/asn1/asn1.go", "status": "modified", "additions": 75, "deletions": 42, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fasn1%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fasn1%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fasn1.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -20,6 +20,7 @@ package asn1\n // everything by any means.\n \n import (\n+\t\"big\"\n \t\"fmt\"\n \t\"os\"\n \t\"reflect\"\n@@ -88,6 +89,27 @@ func parseInt(bytes []byte) (int, os.Error) {\n \treturn int(ret64), nil\n }\n \n+var bigOne = big.NewInt(1)\n+\n+// parseBigInt treats the given bytes as a big-endian, signed integer and returns\n+// the result.\n+func parseBigInt(bytes []byte) *big.Int {\n+\tret := new(big.Int)\n+\tif len(bytes) > 0 && bytes[0]&0x80 == 0x80 {\n+\t\t// This is a negative number.\n+\t\tnotBytes := make([]byte, len(bytes))\n+\t\tfor i := range notBytes {\n+\t\t\tnotBytes[i] = ^bytes[i]\n+\t\t}\n+\t\tret.SetBytes(notBytes)\n+\t\tret.Add(ret, bigOne)\n+\t\tret.Neg(ret)\n+\t\treturn ret\n+\t}\n+\tret.SetBytes(bytes)\n+\treturn ret\n+}\n+\n // BIT STRING\n \n // BitString is the structure to use when you want an ASN.1 BIT STRING type. A\n@@ -127,7 +149,7 @@ func (b BitString) RightAlign() []byte {\n \treturn a\n }\n \n-// parseBitString parses an ASN.1 bit string from the given byte array and returns it.\n+// parseBitString parses an ASN.1 bit string from the given byte slice and returns it.\n func parseBitString(bytes []byte) (ret BitString, err os.Error) {\n \tif len(bytes) == 0 {\n \t\terr = SyntaxError{\"zero length BIT STRING\"}\n@@ -164,9 +186,9 @@ func (oi ObjectIdentifier) Equal(other ObjectIdentifier) bool {\n \treturn true\n }\n \n-// parseObjectIdentifier parses an OBJECT IDENTIFER from the given bytes and\n-// returns it. An object identifer is a sequence of variable length integers\n-// that are assigned in a hierarachy.\n+// parseObjectIdentifier parses an OBJECT IDENTIFIER from the given bytes and\n+// returns it. An object identifier is a sequence of variable length integers\n+// that are assigned in a hierarchy.\n func parseObjectIdentifier(bytes []byte) (s []int, err os.Error) {\n \tif len(bytes) == 0 {\n \t\terr = SyntaxError{\"zero length OBJECT IDENTIFIER\"}\n@@ -198,14 +220,13 @@ func parseObjectIdentifier(bytes []byte) (s []int, err os.Error) {\n // An Enumerated is represented as a plain int.\n type Enumerated int\n \n-\n // FLAG\n \n // A Flag accepts any data and is set to true if present.\n type Flag bool\n \n // parseBase128Int parses a base-128 encoded int from the given offset in the\n-// given byte array. It returns the value and the new offset.\n+// given byte slice. It returns the value and the new offset.\n func parseBase128Int(bytes []byte, initOffset int) (ret, offset int, err os.Error) {\n \toffset = initOffset\n \tfor shifted := 0; offset < len(bytes); shifted++ {\n@@ -237,7 +258,7 @@ func parseUTCTime(bytes []byte) (ret *time.Time, err os.Error) {\n \treturn\n }\n \n-// parseGeneralizedTime parses the GeneralizedTime from the given byte array\n+// parseGeneralizedTime parses the GeneralizedTime from the given byte slice\n // and returns the resulting time.\n func parseGeneralizedTime(bytes []byte) (ret *time.Time, err os.Error) {\n \treturn time.Parse(\"20060102150405Z0700\", string(bytes))\n@@ -269,7 +290,7 @@ func isPrintable(b byte) bool {\n \t\tb == ':' ||\n \t\tb == '=' ||\n \t\tb == '?' ||\n-\t\t// This is techincally not allowed in a PrintableString.\n+\t\t// This is technically not allowed in a PrintableString.\n \t\t// However, x509 certificates with wildcard strings don't\n \t\t// always use the correct string type so we permit it.\n \t\tb == '*'\n@@ -278,7 +299,7 @@ func isPrintable(b byte) bool {\n // IA5String\n \n // parseIA5String parses a ASN.1 IA5String (ASCII string) from the given\n-// byte array and returns it.\n+// byte slice and returns it.\n func parseIA5String(bytes []byte) (ret string, err os.Error) {\n \tfor _, b := range bytes {\n \t\tif b >= 0x80 {\n@@ -293,11 +314,19 @@ func parseIA5String(bytes []byte) (ret string, err os.Error) {\n // T61String\n \n // parseT61String parses a ASN.1 T61String (8-bit clean string) from the given\n-// byte array and returns it.\n+// byte slice and returns it.\n func parseT61String(bytes []byte) (ret string, err os.Error) {\n \treturn string(bytes), nil\n }\n \n+// UTF8String\n+\n+// parseUTF8String parses a ASN.1 UTF8String (raw UTF-8) from the given byte\n+// array and returns it.\n+func parseUTF8String(bytes []byte) (ret string, err os.Error) {\n+\treturn string(bytes), nil\n+}\n+\n // A RawValue represents an undecoded ASN.1 object.\n type RawValue struct {\n \tClass, Tag int\n@@ -314,7 +343,7 @@ type RawContent []byte\n // Tagging\n \n // parseTagAndLength parses an ASN.1 tag and length pair from the given offset\n-// into a byte array. It returns the parsed data and the new offset. SET and\n+// into a byte slice. It returns the parsed data and the new offset. SET and\n // SET OF (tag 17) are mapped to SEQUENCE and SEQUENCE OF (tag 16) since we\n // don't distinguish between ordered and unordered objects in this code.\n func parseTagAndLength(bytes []byte, initOffset int) (ret tagAndLength, offset int, err os.Error) {\n@@ -371,7 +400,7 @@ func parseTagAndLength(bytes []byte, initOffset int) (ret tagAndLength, offset i\n }\n \n // parseSequenceOf is used for SEQUENCE OF and SET OF values. It tries to parse\n-// a number of ASN.1 values from the given byte array and returns them as a\n+// a number of ASN.1 values from the given byte slice and returns them as a\n // slice of Go values of the given type.\n func parseSequenceOf(bytes []byte, sliceType reflect.Type, elemType reflect.Type) (ret reflect.Value, err os.Error) {\n \texpectedTag, compoundType, ok := getUniversalType(elemType)\n@@ -425,6 +454,7 @@ var (\n \ttimeType             = reflect.TypeOf(&time.Time{})\n \trawValueType         = reflect.TypeOf(RawValue{})\n \trawContentsType      = reflect.TypeOf(RawContent(nil))\n+\tbigIntType           = reflect.TypeOf(new(big.Int))\n )\n \n // invalidLength returns true iff offset + length > sliceLength, or if the\n@@ -433,7 +463,7 @@ func invalidLength(offset, length, sliceLength int) bool {\n \treturn offset+length < offset || offset+length > sliceLength\n }\n \n-// parseField is the main parsing function. Given a byte array and an offset\n+// parseField is the main parsing function. Given a byte slice and an offset\n // into the array, it will try to parse a suitable ASN.1 value out and store it\n // in the given Value.\n func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParameters) (offset int, err os.Error) {\n@@ -550,16 +580,15 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\t}\n \t}\n \n-\t// Special case for strings: PrintableString and IA5String both map to\n-\t// the Go type string. getUniversalType returns the tag for\n-\t// PrintableString when it sees a string so, if we see an IA5String on\n-\t// the wire, we change the universal type to match.\n-\tif universalTag == tagPrintableString && t.tag == tagIA5String {\n-\t\tuniversalTag = tagIA5String\n-\t}\n-\t// Likewise for GeneralString\n-\tif universalTag == tagPrintableString && t.tag == tagGeneralString {\n-\t\tuniversalTag = tagGeneralString\n+\t// Special case for strings: all the ASN.1 string types map to the Go\n+\t// type string. getUniversalType returns the tag for PrintableString\n+\t// when it sees a string, so if we see a different string type on the\n+\t// wire, we change the universal type to match.\n+\tif universalTag == tagPrintableString {\n+\t\tswitch t.tag {\n+\t\tcase tagIA5String, tagGeneralString, tagT61String, tagUTF8String:\n+\t\t\tuniversalTag = t.tag\n+\t\t}\n \t}\n \n \t// Special case for time: UTCTime and GeneralizedTime both map to the\n@@ -639,6 +668,10 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \tcase flagType:\n \t\tv.SetBool(true)\n \t\treturn\n+\tcase bigIntType:\n+\t\tparsedInt := parseBigInt(innerBytes)\n+\t\tv.Set(reflect.ValueOf(parsedInt))\n+\t\treturn\n \t}\n \tswitch val := v; val.Kind() {\n \tcase reflect.Bool:\n@@ -648,23 +681,21 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\t}\n \t\terr = err1\n \t\treturn\n-\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n-\t\tswitch val.Type().Kind() {\n-\t\tcase reflect.Int:\n-\t\t\tparsedInt, err1 := parseInt(innerBytes)\n-\t\t\tif err1 == nil {\n-\t\t\t\tval.SetInt(int64(parsedInt))\n-\t\t\t}\n-\t\t\terr = err1\n-\t\t\treturn\n-\t\tcase reflect.Int64:\n-\t\t\tparsedInt, err1 := parseInt64(innerBytes)\n-\t\t\tif err1 == nil {\n-\t\t\t\tval.SetInt(parsedInt)\n-\t\t\t}\n-\t\t\terr = err1\n-\t\t\treturn\n+\tcase reflect.Int, reflect.Int32:\n+\t\tparsedInt, err1 := parseInt(innerBytes)\n+\t\tif err1 == nil {\n+\t\t\tval.SetInt(int64(parsedInt))\n \t\t}\n+\t\terr = err1\n+\t\treturn\n+\tcase reflect.Int64:\n+\t\tparsedInt, err1 := parseInt64(innerBytes)\n+\t\tif err1 == nil {\n+\t\t\tval.SetInt(parsedInt)\n+\t\t}\n+\t\terr = err1\n+\t\treturn\n+\t// TODO(dfc) Add support for the remaining integer types\n \tcase reflect.Struct:\n \t\tstructType := fieldType\n \n@@ -680,7 +711,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\t\tif i == 0 && field.Type == rawContentsType {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tinnerOffset, err = parseField(val.Field(i), innerBytes, innerOffset, parseFieldParameters(field.Tag))\n+\t\t\tinnerOffset, err = parseField(val.Field(i), innerBytes, innerOffset, parseFieldParameters(field.Tag.Get(\"asn1\")))\n \t\t\tif err != nil {\n \t\t\t\treturn\n \t\t\t}\n@@ -711,6 +742,8 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\t\tv, err = parseIA5String(innerBytes)\n \t\tcase tagT61String:\n \t\t\tv, err = parseT61String(innerBytes)\n+\t\tcase tagUTF8String:\n+\t\t\tv, err = parseUTF8String(innerBytes)\n \t\tcase tagGeneralString:\n \t\t\t// GeneralString is specified in ISO-2022/ECMA-35,\n \t\t\t// A brief review suggests that it includes structures\n@@ -725,7 +758,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\t}\n \t\treturn\n \t}\n-\terr = StructuralError{\"unknown Go type\"}\n+\terr = StructuralError{\"unsupported: \" + v.Type().String()}\n \treturn\n }\n \n@@ -752,7 +785,7 @@ func setDefaultValue(v reflect.Value, params fieldParameters) (ok bool) {\n // Because Unmarshal uses the reflect package, the structs\n // being written to must use upper case field names.\n //\n-// An ASN.1 INTEGER can be written to an int or int64.\n+// An ASN.1 INTEGER can be written to an int, int32 or int64.\n // If the encoded value does not fit in the Go type,\n // Unmarshal returns a parse error.\n //"}, {"sha": "9f48f7bdd5dda32bd814171246fe2f09c6fd0f1b", "filename": "libgo/go/asn1/asn1_test.go", "status": "modified", "additions": 68, "deletions": 10, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fasn1%2Fasn1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fasn1%2Fasn1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fasn1_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -42,6 +42,64 @@ func TestParseInt64(t *testing.T) {\n \t}\n }\n \n+type int32Test struct {\n+\tin  []byte\n+\tok  bool\n+\tout int32\n+}\n+\n+var int32TestData = []int32Test{\n+\t{[]byte{0x00}, true, 0},\n+\t{[]byte{0x7f}, true, 127},\n+\t{[]byte{0x00, 0x80}, true, 128},\n+\t{[]byte{0x01, 0x00}, true, 256},\n+\t{[]byte{0x80}, true, -128},\n+\t{[]byte{0xff, 0x7f}, true, -129},\n+\t{[]byte{0xff, 0xff, 0xff, 0xff}, true, -1},\n+\t{[]byte{0xff}, true, -1},\n+\t{[]byte{0x80, 0x00, 0x00, 0x00}, true, -2147483648},\n+\t{[]byte{0x80, 0x00, 0x00, 0x00, 0x00}, false, 0},\n+}\n+\n+func TestParseInt32(t *testing.T) {\n+\tfor i, test := range int32TestData {\n+\t\tret, err := parseInt(test.in)\n+\t\tif (err == nil) != test.ok {\n+\t\t\tt.Errorf(\"#%d: Incorrect error result (did fail? %v, expected: %v)\", i, err == nil, test.ok)\n+\t\t}\n+\t\tif test.ok && int32(ret) != test.out {\n+\t\t\tt.Errorf(\"#%d: Bad result: %v (expected %v)\", i, ret, test.out)\n+\t\t}\n+\t}\n+}\n+\n+var bigIntTests = []struct {\n+\tin     []byte\n+\tbase10 string\n+}{\n+\t{[]byte{0xff}, \"-1\"},\n+\t{[]byte{0x00}, \"0\"},\n+\t{[]byte{0x01}, \"1\"},\n+\t{[]byte{0x00, 0xff}, \"255\"},\n+\t{[]byte{0xff, 0x00}, \"-256\"},\n+\t{[]byte{0x01, 0x00}, \"256\"},\n+}\n+\n+func TestParseBigInt(t *testing.T) {\n+\tfor i, test := range bigIntTests {\n+\t\tret := parseBigInt(test.in)\n+\t\tif ret.String() != test.base10 {\n+\t\t\tt.Errorf(\"#%d: bad result from %x, got %s want %s\", i, test.in, ret.String(), test.base10)\n+\t\t}\n+\t\tfw := newForkableWriter()\n+\t\tmarshalBigInt(fw, ret)\n+\t\tresult := fw.Bytes()\n+\t\tif !bytes.Equal(result, test.in) {\n+\t\t\tt.Errorf(\"#%d: got %x from marshaling %s, want %x\", i, result, ret, test.in)\n+\t\t}\n+\t}\n+}\n+\n type bitStringTest struct {\n \tin        []byte\n \tok        bool\n@@ -148,10 +206,10 @@ type timeTest struct {\n }\n \n var utcTestData = []timeTest{\n-\t{\"910506164540-0700\", true, &time.Time{1991, 05, 06, 16, 45, 40, 0, -7 * 60 * 60, \"\"}},\n-\t{\"910506164540+0730\", true, &time.Time{1991, 05, 06, 16, 45, 40, 0, 7*60*60 + 30*60, \"\"}},\n-\t{\"910506234540Z\", true, &time.Time{1991, 05, 06, 23, 45, 40, 0, 0, \"UTC\"}},\n-\t{\"9105062345Z\", true, &time.Time{1991, 05, 06, 23, 45, 0, 0, 0, \"UTC\"}},\n+\t{\"910506164540-0700\", true, &time.Time{1991, 05, 06, 16, 45, 40, 0, 0, -7 * 60 * 60, \"\"}},\n+\t{\"910506164540+0730\", true, &time.Time{1991, 05, 06, 16, 45, 40, 0, 0, 7*60*60 + 30*60, \"\"}},\n+\t{\"910506234540Z\", true, &time.Time{1991, 05, 06, 23, 45, 40, 0, 0, 0, \"UTC\"}},\n+\t{\"9105062345Z\", true, &time.Time{1991, 05, 06, 23, 45, 0, 0, 0, 0, \"UTC\"}},\n \t{\"a10506234540Z\", false, nil},\n \t{\"91a506234540Z\", false, nil},\n \t{\"9105a6234540Z\", false, nil},\n@@ -177,10 +235,10 @@ func TestUTCTime(t *testing.T) {\n }\n \n var generalizedTimeTestData = []timeTest{\n-\t{\"20100102030405Z\", true, &time.Time{2010, 01, 02, 03, 04, 05, 0, 0, \"UTC\"}},\n+\t{\"20100102030405Z\", true, &time.Time{2010, 01, 02, 03, 04, 05, 0, 0, 0, \"UTC\"}},\n \t{\"20100102030405\", false, nil},\n-\t{\"20100102030405+0607\", true, &time.Time{2010, 01, 02, 03, 04, 05, 0, 6*60*60 + 7*60, \"\"}},\n-\t{\"20100102030405-0607\", true, &time.Time{2010, 01, 02, 03, 04, 05, 0, -6*60*60 - 7*60, \"\"}},\n+\t{\"20100102030405+0607\", true, &time.Time{2010, 01, 02, 03, 04, 05, 0, 0, 6*60*60 + 7*60, \"\"}},\n+\t{\"20100102030405-0607\", true, &time.Time{2010, 01, 02, 03, 04, 05, 0, 0, -6*60*60 - 7*60, \"\"}},\n }\n \n func TestGeneralizedTime(t *testing.T) {\n@@ -272,11 +330,11 @@ type TestObjectIdentifierStruct struct {\n }\n \n type TestContextSpecificTags struct {\n-\tA int \"tag:1\"\n+\tA int `asn1:\"tag:1\"`\n }\n \n type TestContextSpecificTags2 struct {\n-\tA int \"explicit,tag:1\"\n+\tA int `asn1:\"explicit,tag:1\"`\n \tB int\n }\n \n@@ -326,7 +384,7 @@ type Certificate struct {\n }\n \n type TBSCertificate struct {\n-\tVersion            int \"optional,explicit,default:0,tag:0\"\n+\tVersion            int `asn1:\"optional,explicit,default:0,tag:0\"`\n \tSerialNumber       RawValue\n \tSignatureAlgorithm AlgorithmIdentifier\n \tIssuer             RDNSequence"}, {"sha": "01f4f7b6ec7a6519caf9dd508685a4484a0fdf46", "filename": "libgo/go/asn1/common.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fasn1%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fasn1%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fcommon.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -10,7 +10,7 @@ import (\n \t\"strings\"\n )\n \n-// ASN.1 objects have metadata preceeding them:\n+// ASN.1 objects have metadata preceding them:\n //   the tag: the type of the object\n //   a flag denoting if this object is compound or not\n //   the class type: the namespace of the tag\n@@ -25,6 +25,7 @@ const (\n \ttagOctetString     = 4\n \ttagOID             = 6\n \ttagEnum            = 10\n+\ttagUTF8String      = 12\n \ttagSequence        = 16\n \ttagSet             = 17\n \ttagPrintableString = 19\n@@ -83,7 +84,7 @@ type fieldParameters struct {\n // parseFieldParameters will parse it into a fieldParameters structure,\n // ignoring unknown parts of the string.\n func parseFieldParameters(str string) (ret fieldParameters) {\n-\tfor _, part := range strings.Split(str, \",\", -1) {\n+\tfor _, part := range strings.Split(str, \",\") {\n \t\tswitch {\n \t\tcase part == \"optional\":\n \t\t\tret.optional = true\n@@ -132,6 +133,8 @@ func getUniversalType(t reflect.Type) (tagNumber int, isCompound, ok bool) {\n \t\treturn tagUTCTime, false, true\n \tcase enumeratedType:\n \t\treturn tagEnum, false, true\n+\tcase bigIntType:\n+\t\treturn tagInteger, false, true\n \t}\n \tswitch t.Kind() {\n \tcase reflect.Bool:"}, {"sha": "d7eb63bf82c9f1531f4ae617086276b771a5540d", "filename": "libgo/go/asn1/marshal.go", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fasn1%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fasn1%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fmarshal.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -5,6 +5,7 @@\n package asn1\n \n import (\n+\t\"big\"\n \t\"bytes\"\n \t\"fmt\"\n \t\"io\"\n@@ -125,6 +126,43 @@ func int64Length(i int64) (numBytes int) {\n \treturn\n }\n \n+func marshalBigInt(out *forkableWriter, n *big.Int) (err os.Error) {\n+\tif n.Sign() < 0 {\n+\t\t// A negative number has to be converted to two's-complement\n+\t\t// form. So we'll subtract 1 and invert. If the\n+\t\t// most-significant-bit isn't set then we'll need to pad the\n+\t\t// beginning with 0xff in order to keep the number negative.\n+\t\tnMinus1 := new(big.Int).Neg(n)\n+\t\tnMinus1.Sub(nMinus1, bigOne)\n+\t\tbytes := nMinus1.Bytes()\n+\t\tfor i := range bytes {\n+\t\t\tbytes[i] ^= 0xff\n+\t\t}\n+\t\tif len(bytes) == 0 || bytes[0]&0x80 == 0 {\n+\t\t\terr = out.WriteByte(0xff)\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t\t_, err = out.Write(bytes)\n+\t} else if n.Sign() == 0 {\n+\t\t// Zero is written as a single 0 zero rather than no bytes.\n+\t\terr = out.WriteByte(0x00)\n+\t} else {\n+\t\tbytes := n.Bytes()\n+\t\tif len(bytes) > 0 && bytes[0]&0x80 != 0 {\n+\t\t\t// We'll have to pad this with 0x00 in order to stop it\n+\t\t\t// looking like a negative number.\n+\t\t\terr = out.WriteByte(0)\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t\t_, err = out.Write(bytes)\n+\t}\n+\treturn\n+}\n+\n func marshalLength(out *forkableWriter, i int) (err os.Error) {\n \tn := lengthLength(i)\n \n@@ -334,6 +372,8 @@ func marshalBody(out *forkableWriter, value reflect.Value, params fieldParameter\n \t\treturn marshalBitString(out, value.Interface().(BitString))\n \tcase objectIdentifierType:\n \t\treturn marshalObjectIdentifier(out, value.Interface().(ObjectIdentifier))\n+\tcase bigIntType:\n+\t\treturn marshalBigInt(out, value.Interface().(*big.Int))\n \t}\n \n \tswitch v := value; v.Kind() {\n@@ -351,7 +391,7 @@ func marshalBody(out *forkableWriter, value reflect.Value, params fieldParameter\n \t\tstartingField := 0\n \n \t\t// If the first element of the structure is a non-empty\n-\t\t// RawContents, then we don't bother serialising the rest.\n+\t\t// RawContents, then we don't bother serializing the rest.\n \t\tif t.NumField() > 0 && t.Field(0).Type == rawContentsType {\n \t\t\ts := v.Field(0)\n \t\t\tif s.Len() > 0 {\n@@ -361,7 +401,7 @@ func marshalBody(out *forkableWriter, value reflect.Value, params fieldParameter\n \t\t\t\t}\n \t\t\t\t/* The RawContents will contain the tag and\n \t\t\t\t * length fields but we'll also be writing\n-\t\t\t\t * those outselves, so we strip them out of\n+\t\t\t\t * those ourselves, so we strip them out of\n \t\t\t\t * bytes */\n \t\t\t\t_, err = out.Write(stripTagAndLength(bytes))\n \t\t\t\treturn\n@@ -373,7 +413,7 @@ func marshalBody(out *forkableWriter, value reflect.Value, params fieldParameter\n \t\tfor i := startingField; i < t.NumField(); i++ {\n \t\t\tvar pre *forkableWriter\n \t\t\tpre, out = out.fork()\n-\t\t\terr = marshalField(pre, v.Field(i), parseFieldParameters(t.Field(i).Tag))\n+\t\t\terr = marshalField(pre, v.Field(i), parseFieldParameters(t.Field(i).Tag.Get(\"asn1\")))\n \t\t\tif err != nil {\n \t\t\t\treturn\n \t\t\t}\n@@ -418,6 +458,10 @@ func marshalField(out *forkableWriter, v reflect.Value, params fieldParameters)\n \t\treturn marshalField(out, v.Elem(), params)\n \t}\n \n+\tif params.optional && reflect.DeepEqual(v.Interface(), reflect.Zero(v.Type()).Interface()) {\n+\t\treturn\n+\t}\n+\n \tif v.Type() == rawValueType {\n \t\trv := v.Interface().(RawValue)\n \t\terr = marshalTagAndLength(out, tagAndLength{rv.Class, rv.Tag, len(rv.Bytes), rv.IsCompound})\n@@ -428,10 +472,6 @@ func marshalField(out *forkableWriter, v reflect.Value, params fieldParameters)\n \t\treturn\n \t}\n \n-\tif params.optional && reflect.DeepEqual(v.Interface(), reflect.Zero(v.Type()).Interface()) {\n-\t\treturn\n-\t}\n-\n \ttag, isCompound, ok := getUniversalType(v.Type())\n \tif !ok {\n \t\terr = StructuralError{fmt.Sprintf(\"unknown Go type: %v\", v.Type())}"}, {"sha": "03df5f1e1d52b86fd24eb7ebd45a57f64b57ae2c", "filename": "libgo/go/asn1/marshal_test.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fasn1%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fasn1%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fmarshal_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -30,19 +30,23 @@ type rawContentsStruct struct {\n }\n \n type implicitTagTest struct {\n-\tA int \"implicit,tag:5\"\n+\tA int `asn1:\"implicit,tag:5\"`\n }\n \n type explicitTagTest struct {\n-\tA int \"explicit,tag:5\"\n+\tA int `asn1:\"explicit,tag:5\"`\n }\n \n type ia5StringTest struct {\n-\tA string \"ia5\"\n+\tA string `asn1:\"ia5\"`\n }\n \n type printableStringTest struct {\n-\tA string \"printable\"\n+\tA string `asn1:\"printable\"`\n+}\n+\n+type optionalRawValueTest struct {\n+\tA RawValue `asn1:\"optional\"`\n }\n \n type testSET []int\n@@ -102,6 +106,7 @@ var marshalTests = []marshalTest{\n \t\t\t\"7878787878787878787878787878787878787878787878787878787878787878\",\n \t},\n \t{ia5StringTest{\"test\"}, \"3006160474657374\"},\n+\t{optionalRawValueTest{}, \"3000\"},\n \t{printableStringTest{\"test\"}, \"3006130474657374\"},\n \t{printableStringTest{\"test*\"}, \"30071305746573742a\"},\n \t{rawContentsStruct{nil, 64}, \"3003020140\"},"}, {"sha": "242bd1e8cc42d66c6cd28e2bee93bbb16f728375", "filename": "libgo/go/big/arith.go", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Farith.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Farith.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Farith.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -27,7 +27,6 @@ const (\n \t_M2 = _B2 - 1  // half digit mask\n )\n \n-\n // ----------------------------------------------------------------------------\n // Elementary operations on words\n //\n@@ -43,7 +42,6 @@ func addWW_g(x, y, c Word) (z1, z0 Word) {\n \treturn\n }\n \n-\n // z1<<_W + z0 = x-y-c, with c == 0 or 1\n func subWW_g(x, y, c Word) (z1, z0 Word) {\n \tyc := y + c\n@@ -54,7 +52,6 @@ func subWW_g(x, y, c Word) (z1, z0 Word) {\n \treturn\n }\n \n-\n // z1<<_W + z0 = x*y\n func mulWW(x, y Word) (z1, z0 Word) { return mulWW_g(x, y) }\n // Adapted from Warren, Hacker's Delight, p. 132.\n@@ -73,7 +70,6 @@ func mulWW_g(x, y Word) (z1, z0 Word) {\n \treturn\n }\n \n-\n // z1<<_W + z0 = x*y + c\n func mulAddWWW_g(x, y, c Word) (z1, z0 Word) {\n \tz1, zz0 := mulWW(x, y)\n@@ -83,7 +79,6 @@ func mulAddWWW_g(x, y, c Word) (z1, z0 Word) {\n \treturn\n }\n \n-\n // Length of x in bits.\n func bitLen(x Word) (n int) {\n \tfor ; x >= 0x100; x >>= 8 {\n@@ -95,21 +90,18 @@ func bitLen(x Word) (n int) {\n \treturn\n }\n \n-\n // log2 computes the integer binary logarithm of x.\n // The result is the integer n for which 2^n <= x < 2^(n+1).\n // If x == 0, the result is -1.\n func log2(x Word) int {\n \treturn bitLen(x) - 1\n }\n \n-\n // Number of leading zeros in x.\n func leadingZeros(x Word) uint {\n \treturn uint(_W - bitLen(x))\n }\n \n-\n // q = (u1<<_W + u0 - r)/y\n func divWW(x1, x0, y Word) (q, r Word) { return divWW_g(x1, x0, y) }\n // Adapted from Warren, Hacker's Delight, p. 152.\n@@ -155,7 +147,6 @@ again2:\n \treturn q1*_B2 + q0, (un21*_B2 + un0 - q0*v) >> s\n }\n \n-\n func addVV(z, x, y []Word) (c Word) { return addVV_g(z, x, y) }\n func addVV_g(z, x, y []Word) (c Word) {\n \tfor i := range z {\n@@ -164,7 +155,6 @@ func addVV_g(z, x, y []Word) (c Word) {\n \treturn\n }\n \n-\n func subVV(z, x, y []Word) (c Word) { return subVV_g(z, x, y) }\n func subVV_g(z, x, y []Word) (c Word) {\n \tfor i := range z {\n@@ -173,7 +163,6 @@ func subVV_g(z, x, y []Word) (c Word) {\n \treturn\n }\n \n-\n func addVW(z, x []Word, y Word) (c Word) { return addVW_g(z, x, y) }\n func addVW_g(z, x []Word, y Word) (c Word) {\n \tc = y\n@@ -183,7 +172,6 @@ func addVW_g(z, x []Word, y Word) (c Word) {\n \treturn\n }\n \n-\n func subVW(z, x []Word, y Word) (c Word) { return subVW_g(z, x, y) }\n func subVW_g(z, x []Word, y Word) (c Word) {\n \tc = y\n@@ -193,9 +181,8 @@ func subVW_g(z, x []Word, y Word) (c Word) {\n \treturn\n }\n \n-\n-func shlVW(z, x []Word, s Word) (c Word) { return shlVW_g(z, x, s) }\n-func shlVW_g(z, x []Word, s Word) (c Word) {\n+func shlVU(z, x []Word, s uint) (c Word) { return shlVU_g(z, x, s) }\n+func shlVU_g(z, x []Word, s uint) (c Word) {\n \tif n := len(z); n > 0 {\n \t\t\u015d := _W - s\n \t\tw1 := x[n-1]\n@@ -210,9 +197,8 @@ func shlVW_g(z, x []Word, s Word) (c Word) {\n \treturn\n }\n \n-\n-func shrVW(z, x []Word, s Word) (c Word) { return shrVW_g(z, x, s) }\n-func shrVW_g(z, x []Word, s Word) (c Word) {\n+func shrVU(z, x []Word, s uint) (c Word) { return shrVU_g(z, x, s) }\n+func shrVU_g(z, x []Word, s uint) (c Word) {\n \tif n := len(z); n > 0 {\n \t\t\u015d := _W - s\n \t\tw1 := x[0]\n@@ -227,7 +213,6 @@ func shrVW_g(z, x []Word, s Word) (c Word) {\n \treturn\n }\n \n-\n func mulAddVWW(z, x []Word, y, r Word) (c Word) { return mulAddVWW_g(z, x, y, r) }\n func mulAddVWW_g(z, x []Word, y, r Word) (c Word) {\n \tc = r\n@@ -237,7 +222,6 @@ func mulAddVWW_g(z, x []Word, y, r Word) (c Word) {\n \treturn\n }\n \n-\n func addMulVVW(z, x []Word, y Word) (c Word) { return addMulVVW_g(z, x, y) }\n func addMulVVW_g(z, x []Word, y Word) (c Word) {\n \tfor i := range z {\n@@ -248,7 +232,6 @@ func addMulVVW_g(z, x []Word, y Word) (c Word) {\n \treturn\n }\n \n-\n func divWVW(z []Word, xn Word, x []Word, y Word) (r Word) { return divWVW_g(z, xn, x, y) }\n func divWVW_g(z []Word, xn Word, x []Word, y Word) (r Word) {\n \tr = xn"}, {"sha": "95fcd8b94bed8208cd7bac115e3d970eeb951ae7", "filename": "libgo/go/big/arith_decl.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Farith_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Farith_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Farith_decl.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -11,8 +11,8 @@ func addVV(z, x, y []Word) (c Word)\n func subVV(z, x, y []Word) (c Word)\n func addVW(z, x []Word, y Word) (c Word)\n func subVW(z, x []Word, y Word) (c Word)\n-func shlVW(z, x []Word, s Word) (c Word)\n-func shrVW(z, x []Word, s Word) (c Word)\n+func shlVU(z, x []Word, s uint) (c Word)\n+func shrVU(z, x []Word, s uint) (c Word)\n func mulAddVWW(z, x []Word, y, r Word) (c Word)\n func addMulVVW(z, x []Word, y Word) (c Word)\n func divWVW(z []Word, xn Word, x []Word, y Word) (r Word)"}, {"sha": "b6c56c39ef4756a65ec1dbee6f76aec203c3e498", "filename": "libgo/go/big/arith_test.go", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Farith_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Farith_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Farith_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -6,7 +6,6 @@ package big\n \n import \"testing\"\n \n-\n type funWW func(x, y, c Word) (z1, z0 Word)\n type argWW struct {\n \tx, y, c, z1, z0 Word\n@@ -26,15 +25,13 @@ var sumWW = []argWW{\n \t{_M, _M, 1, 1, _M},\n }\n \n-\n func testFunWW(t *testing.T, msg string, f funWW, a argWW) {\n \tz1, z0 := f(a.x, a.y, a.c)\n \tif z1 != a.z1 || z0 != a.z0 {\n \t\tt.Errorf(\"%s%+v\\n\\tgot z1:z0 = %#x:%#x; want %#x:%#x\", msg, a, z1, z0, a.z1, a.z0)\n \t}\n }\n \n-\n func TestFunWW(t *testing.T) {\n \tfor _, a := range sumWW {\n \t\targ := a\n@@ -51,7 +48,6 @@ func TestFunWW(t *testing.T) {\n \t}\n }\n \n-\n type funVV func(z, x, y []Word) (c Word)\n type argVV struct {\n \tz, x, y nat\n@@ -70,7 +66,6 @@ var sumVV = []argVV{\n \t{nat{0, 0, 0, 0}, nat{_M, 0, _M, 0}, nat{1, _M, 0, _M}, 1},\n }\n \n-\n func testFunVV(t *testing.T, msg string, f funVV, a argVV) {\n \tz := make(nat, len(a.z))\n \tc := f(z, a.x, a.y)\n@@ -85,7 +80,6 @@ func testFunVV(t *testing.T, msg string, f funVV, a argVV) {\n \t}\n }\n \n-\n func TestFunVV(t *testing.T) {\n \tfor _, a := range sumVV {\n \t\targ := a\n@@ -106,7 +100,6 @@ func TestFunVV(t *testing.T) {\n \t}\n }\n \n-\n type funVW func(z, x []Word, y Word) (c Word)\n type argVW struct {\n \tz, x nat\n@@ -169,7 +162,6 @@ var rshVW = []argVW{\n \t{nat{_M, _M, _M >> 20}, nat{_M, _M, _M}, 20, _M << (_W - 20) & _M},\n }\n \n-\n func testFunVW(t *testing.T, msg string, f funVW, a argVW) {\n \tz := make(nat, len(a.z))\n \tc := f(z, a.x, a.y)\n@@ -184,6 +176,11 @@ func testFunVW(t *testing.T, msg string, f funVW, a argVW) {\n \t}\n }\n \n+func makeFunVW(f func(z, x []Word, s uint) (c Word)) funVW {\n+\treturn func(z, x []Word, s Word) (c Word) {\n+\t\treturn f(z, x, uint(s))\n+\t}\n+}\n \n func TestFunVW(t *testing.T) {\n \tfor _, a := range sumVW {\n@@ -196,20 +193,23 @@ func TestFunVW(t *testing.T) {\n \t\ttestFunVW(t, \"subVW\", subVW, arg)\n \t}\n \n+\tshlVW_g := makeFunVW(shlVU_g)\n+\tshlVW := makeFunVW(shlVU)\n \tfor _, a := range lshVW {\n \t\targ := a\n-\t\ttestFunVW(t, \"shlVW_g\", shlVW_g, arg)\n-\t\ttestFunVW(t, \"shlVW\", shlVW, arg)\n+\t\ttestFunVW(t, \"shlVU_g\", shlVW_g, arg)\n+\t\ttestFunVW(t, \"shlVU\", shlVW, arg)\n \t}\n \n+\tshrVW_g := makeFunVW(shrVU_g)\n+\tshrVW := makeFunVW(shrVU)\n \tfor _, a := range rshVW {\n \t\targ := a\n-\t\ttestFunVW(t, \"shrVW_g\", shrVW_g, arg)\n-\t\ttestFunVW(t, \"shrVW\", shrVW, arg)\n+\t\ttestFunVW(t, \"shrVU_g\", shrVW_g, arg)\n+\t\ttestFunVW(t, \"shrVU\", shrVW, arg)\n \t}\n }\n \n-\n type funVWW func(z, x []Word, y, r Word) (c Word)\n type argVWW struct {\n \tz, x nat\n@@ -243,7 +243,6 @@ var prodVWW = []argVWW{\n \t{nat{_M<<7&_M + 1<<6, _M, _M, _M}, nat{_M, _M, _M, _M}, 1 << 7, 1 << 6, _M >> (_W - 7)},\n }\n \n-\n func testFunVWW(t *testing.T, msg string, f funVWW, a argVWW) {\n \tz := make(nat, len(a.z))\n \tc := f(z, a.x, a.y, a.r)\n@@ -258,7 +257,6 @@ func testFunVWW(t *testing.T, msg string, f funVWW, a argVWW) {\n \t}\n }\n \n-\n // TODO(gri) mulAddVWW and divWVW are symmetric operations but\n //           their signature is not symmetric. Try to unify.\n \n@@ -285,7 +283,6 @@ func testFunWVW(t *testing.T, msg string, f funWVW, a argWVW) {\n \t}\n }\n \n-\n func TestFunVWW(t *testing.T) {\n \tfor _, a := range prodVWW {\n \t\targ := a\n@@ -300,7 +297,6 @@ func TestFunVWW(t *testing.T) {\n \t}\n }\n \n-\n var mulWWTests = []struct {\n \tx, y Word\n \tq, r Word\n@@ -309,7 +305,6 @@ var mulWWTests = []struct {\n \t// 32 bit only: {0xc47dfa8c, 50911, 0x98a4, 0x998587f4},\n }\n \n-\n func TestMulWW(t *testing.T) {\n \tfor i, test := range mulWWTests {\n \t\tq, r := mulWW_g(test.x, test.y)\n@@ -319,7 +314,6 @@ func TestMulWW(t *testing.T) {\n \t}\n }\n \n-\n var mulAddWWWTests = []struct {\n \tx, y, c Word\n \tq, r    Word\n@@ -331,7 +325,6 @@ var mulAddWWWTests = []struct {\n \t{_M, _M, _M, _M, 0},\n }\n \n-\n func TestMulAddWWW(t *testing.T) {\n \tfor i, test := range mulAddWWWTests {\n \t\tq, r := mulAddWWW_g(test.x, test.y, test.c)"}, {"sha": "1cd93b1052bd1b2e0561f89b3be3f182cc471f58", "filename": "libgo/go/big/calibrate_test.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Fcalibrate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Fcalibrate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fcalibrate_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -19,10 +19,8 @@ import (\n \t\"time\"\n )\n \n-\n var calibrate = flag.Bool(\"calibrate\", false, \"run calibration test\")\n \n-\n // measure returns the time to run f\n func measure(f func()) int64 {\n \tconst N = 100\n@@ -34,7 +32,6 @@ func measure(f func()) int64 {\n \treturn (stop - start) / N\n }\n \n-\n func computeThresholds() {\n \tfmt.Printf(\"Multiplication times for varying Karatsuba thresholds\\n\")\n \tfmt.Printf(\"(run repeatedly for good results)\\n\")\n@@ -84,7 +81,6 @@ func computeThresholds() {\n \t}\n }\n \n-\n func TestCalibrate(t *testing.T) {\n \tif *calibrate {\n \t\tcomputeThresholds()"}, {"sha": "1a84341b3c0b63bfa7040c5631c2af9c8670578a", "filename": "libgo/go/big/hilbert_test.go", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Fhilbert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Fhilbert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fhilbert_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -13,29 +13,25 @@ import (\n \t\"testing\"\n )\n \n-\n type matrix struct {\n \tn, m int\n \ta    []*Rat\n }\n \n-\n func (a *matrix) at(i, j int) *Rat {\n \tif !(0 <= i && i < a.n && 0 <= j && j < a.m) {\n \t\tpanic(\"index out of range\")\n \t}\n \treturn a.a[i*a.m+j]\n }\n \n-\n func (a *matrix) set(i, j int, x *Rat) {\n \tif !(0 <= i && i < a.n && 0 <= j && j < a.m) {\n \t\tpanic(\"index out of range\")\n \t}\n \ta.a[i*a.m+j] = x\n }\n \n-\n func newMatrix(n, m int) *matrix {\n \tif !(0 <= n && 0 <= m) {\n \t\tpanic(\"illegal matrix\")\n@@ -47,7 +43,6 @@ func newMatrix(n, m int) *matrix {\n \treturn a\n }\n \n-\n func newUnit(n int) *matrix {\n \ta := newMatrix(n, n)\n \tfor i := 0; i < n; i++ {\n@@ -62,7 +57,6 @@ func newUnit(n int) *matrix {\n \treturn a\n }\n \n-\n func newHilbert(n int) *matrix {\n \ta := newMatrix(n, n)\n \tfor i := 0; i < n; i++ {\n@@ -73,7 +67,6 @@ func newHilbert(n int) *matrix {\n \treturn a\n }\n \n-\n func newInverseHilbert(n int) *matrix {\n \ta := newMatrix(n, n)\n \tfor i := 0; i < n; i++ {\n@@ -98,7 +91,6 @@ func newInverseHilbert(n int) *matrix {\n \treturn a\n }\n \n-\n func (a *matrix) mul(b *matrix) *matrix {\n \tif a.m != b.n {\n \t\tpanic(\"illegal matrix multiply\")\n@@ -116,7 +108,6 @@ func (a *matrix) mul(b *matrix) *matrix {\n \treturn c\n }\n \n-\n func (a *matrix) eql(b *matrix) bool {\n \tif a.n != b.n || a.m != b.m {\n \t\treturn false\n@@ -131,7 +122,6 @@ func (a *matrix) eql(b *matrix) bool {\n \treturn true\n }\n \n-\n func (a *matrix) String() string {\n \ts := \"\"\n \tfor i := 0; i < a.n; i++ {\n@@ -143,7 +133,6 @@ func (a *matrix) String() string {\n \treturn s\n }\n \n-\n func doHilbert(t *testing.T, n int) {\n \ta := newHilbert(n)\n \tb := newInverseHilbert(n)\n@@ -160,12 +149,10 @@ func doHilbert(t *testing.T, n int) {\n \t}\n }\n \n-\n func TestHilbert(t *testing.T) {\n \tdoHilbert(t, 10)\n }\n \n-\n func BenchmarkHilbert(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tdoHilbert(nil, 10)"}, {"sha": "701b69715dbedddb6ec3df96f0227586038f27f5", "filename": "libgo/go/big/int.go", "status": "modified", "additions": 218, "deletions": 84, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fint.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -8,8 +8,10 @@ package big\n \n import (\n \t\"fmt\"\n+\t\"io\"\n \t\"os\"\n \t\"rand\"\n+\t\"strings\"\n )\n \n // An Int represents a signed multi-precision integer.\n@@ -19,10 +21,8 @@ type Int struct {\n \tabs nat  // absolute value of the integer\n }\n \n-\n var intOne = &Int{false, natOne}\n \n-\n // Sign returns:\n //\n //\t-1 if x <  0\n@@ -39,7 +39,6 @@ func (x *Int) Sign() int {\n \treturn 1\n }\n \n-\n // SetInt64 sets z to x and returns z.\n func (z *Int) SetInt64(x int64) *Int {\n \tneg := false\n@@ -52,37 +51,32 @@ func (z *Int) SetInt64(x int64) *Int {\n \treturn z\n }\n \n-\n // NewInt allocates and returns a new Int set to x.\n func NewInt(x int64) *Int {\n \treturn new(Int).SetInt64(x)\n }\n \n-\n // Set sets z to x and returns z.\n func (z *Int) Set(x *Int) *Int {\n \tz.abs = z.abs.set(x.abs)\n \tz.neg = x.neg\n \treturn z\n }\n \n-\n // Abs sets z to |x| (the absolute value of x) and returns z.\n func (z *Int) Abs(x *Int) *Int {\n \tz.abs = z.abs.set(x.abs)\n \tz.neg = false\n \treturn z\n }\n \n-\n // Neg sets z to -x and returns z.\n func (z *Int) Neg(x *Int) *Int {\n \tz.abs = z.abs.set(x.abs)\n \tz.neg = len(z.abs) > 0 && !x.neg // 0 has no sign\n \treturn z\n }\n \n-\n // Add sets z to the sum x+y and returns z.\n func (z *Int) Add(x, y *Int) *Int {\n \tneg := x.neg\n@@ -104,7 +98,6 @@ func (z *Int) Add(x, y *Int) *Int {\n \treturn z\n }\n \n-\n // Sub sets z to the difference x-y and returns z.\n func (z *Int) Sub(x, y *Int) *Int {\n \tneg := x.neg\n@@ -126,7 +119,6 @@ func (z *Int) Sub(x, y *Int) *Int {\n \treturn z\n }\n \n-\n // Mul sets z to the product x*y and returns z.\n func (z *Int) Mul(x, y *Int) *Int {\n \t// x * y == x * y\n@@ -138,7 +130,6 @@ func (z *Int) Mul(x, y *Int) *Int {\n \treturn z\n }\n \n-\n // MulRange sets z to the product of all integers\n // in the range [a, b] inclusively and returns z.\n // If a > b (empty range), the result is 1.\n@@ -162,7 +153,6 @@ func (z *Int) MulRange(a, b int64) *Int {\n \treturn z\n }\n \n-\n // Binomial sets z to the binomial coefficient of (n, k) and returns z.\n func (z *Int) Binomial(n, k int64) *Int {\n \tvar a, b Int\n@@ -171,7 +161,6 @@ func (z *Int) Binomial(n, k int64) *Int {\n \treturn z.Quo(&a, &b)\n }\n \n-\n // Quo sets z to the quotient x/y for y != 0 and returns z.\n // If y == 0, a division-by-zero run-time panic occurs.\n // See QuoRem for more details.\n@@ -181,7 +170,6 @@ func (z *Int) Quo(x, y *Int) *Int {\n \treturn z\n }\n \n-\n // Rem sets z to the remainder x%y for y != 0 and returns z.\n // If y == 0, a division-by-zero run-time panic occurs.\n // See QuoRem for more details.\n@@ -191,7 +179,6 @@ func (z *Int) Rem(x, y *Int) *Int {\n \treturn z\n }\n \n-\n // QuoRem sets z to the quotient x/y and r to the remainder x%y\n // and returns the pair (z, r) for y != 0.\n // If y == 0, a division-by-zero run-time panic occurs.\n@@ -209,7 +196,6 @@ func (z *Int) QuoRem(x, y, r *Int) (*Int, *Int) {\n \treturn z, r\n }\n \n-\n // Div sets z to the quotient x/y for y != 0 and returns z.\n // If y == 0, a division-by-zero run-time panic occurs.\n // See DivMod for more details.\n@@ -227,7 +213,6 @@ func (z *Int) Div(x, y *Int) *Int {\n \treturn z\n }\n \n-\n // Mod sets z to the modulus x%y for y != 0 and returns z.\n // If y == 0, a division-by-zero run-time panic occurs.\n // See DivMod for more details.\n@@ -248,7 +233,6 @@ func (z *Int) Mod(x, y *Int) *Int {\n \treturn z\n }\n \n-\n // DivMod sets z to the quotient x div y and m to the modulus x mod y\n // and returns the pair (z, m) for y != 0.\n // If y == 0, a division-by-zero run-time panic occurs.\n@@ -281,7 +265,6 @@ func (z *Int) DivMod(x, y, m *Int) (*Int, *Int) {\n \treturn z, m\n }\n \n-\n // Cmp compares x and y and returns:\n //\n //   -1 if x <  y\n@@ -307,49 +290,197 @@ func (x *Int) Cmp(y *Int) (r int) {\n \treturn\n }\n \n-\n func (x *Int) String() string {\n-\ts := \"\"\n-\tif x.neg {\n-\t\ts = \"-\"\n+\tswitch {\n+\tcase x == nil:\n+\t\treturn \"<nil>\"\n+\tcase x.neg:\n+\t\treturn \"-\" + x.abs.decimalString()\n \t}\n-\treturn s + x.abs.string(10)\n+\treturn x.abs.decimalString()\n }\n \n-\n-func fmtbase(ch int) int {\n+func charset(ch int) string {\n \tswitch ch {\n \tcase 'b':\n-\t\treturn 2\n+\t\treturn lowercaseDigits[0:2]\n \tcase 'o':\n-\t\treturn 8\n-\tcase 'd':\n-\t\treturn 10\n+\t\treturn lowercaseDigits[0:8]\n+\tcase 'd', 's', 'v':\n+\t\treturn lowercaseDigits[0:10]\n \tcase 'x':\n-\t\treturn 16\n+\t\treturn lowercaseDigits[0:16]\n+\tcase 'X':\n+\t\treturn uppercaseDigits[0:16]\n \t}\n-\treturn 10\n+\treturn \"\" // unknown format\n }\n \n+// write count copies of text to s\n+func writeMultiple(s fmt.State, text string, count int) {\n+\tif len(text) > 0 {\n+\t\tb := []byte(text)\n+\t\tfor ; count > 0; count-- {\n+\t\t\ts.Write(b)\n+\t\t}\n+\t}\n+}\n \n // Format is a support routine for fmt.Formatter. It accepts\n-// the formats 'b' (binary), 'o' (octal), 'd' (decimal) and\n-// 'x' (hexadecimal).\n+// the formats 'b' (binary), 'o' (octal), 'd' (decimal), 'x'\n+// (lowercase hexadecimal), and 'X' (uppercase hexadecimal).\n+// Also supported are the full suite of package fmt's format\n+// verbs for integral types, including '+', '-', and ' '\n+// for sign control, '#' for leading zero in octal and for\n+// hexadecimal, a leading \"0x\" or \"0X\" for \"%#x\" and \"%#X\"\n+// respectively, specification of minimum digits precision,\n+// output field width, space or zero padding, and left or\n+// right justification.\n //\n func (x *Int) Format(s fmt.State, ch int) {\n-\tif x == nil {\n+\tcs := charset(ch)\n+\n+\t// special cases\n+\tswitch {\n+\tcase cs == \"\":\n+\t\t// unknown format\n+\t\tfmt.Fprintf(s, \"%%!%c(big.Int=%s)\", ch, x.String())\n+\t\treturn\n+\tcase x == nil:\n \t\tfmt.Fprint(s, \"<nil>\")\n \t\treturn\n \t}\n-\tif x.neg {\n-\t\tfmt.Fprint(s, \"-\")\n+\n+\t// determine sign character\n+\tsign := \"\"\n+\tswitch {\n+\tcase x.neg:\n+\t\tsign = \"-\"\n+\tcase s.Flag('+'): // supersedes ' ' when both specified\n+\t\tsign = \"+\"\n+\tcase s.Flag(' '):\n+\t\tsign = \" \"\n+\t}\n+\n+\t// determine prefix characters for indicating output base\n+\tprefix := \"\"\n+\tif s.Flag('#') {\n+\t\tswitch ch {\n+\t\tcase 'o': // octal\n+\t\t\tprefix = \"0\"\n+\t\tcase 'x': // hexadecimal\n+\t\t\tprefix = \"0x\"\n+\t\tcase 'X':\n+\t\t\tprefix = \"0X\"\n+\t\t}\n+\t}\n+\n+\t// determine digits with base set by len(cs) and digit characters from cs\n+\tdigits := x.abs.string(cs)\n+\n+\t// number of characters for the three classes of number padding\n+\tvar left int   // space characters to left of digits for right justification (\"%8d\")\n+\tvar zeroes int // zero characters (actually cs[0]) as left-most digits (\"%.8d\")\n+\tvar right int  // space characters to right of digits for left justification (\"%-8d\")\n+\n+\t// determine number padding from precision: the least number of digits to output\n+\tprecision, precisionSet := s.Precision()\n+\tif precisionSet {\n+\t\tswitch {\n+\t\tcase len(digits) < precision:\n+\t\t\tzeroes = precision - len(digits) // count of zero padding \n+\t\tcase digits == \"0\" && precision == 0:\n+\t\t\treturn // print nothing if zero value (x == 0) and zero precision (\".\" or \".0\")\n+\t\t}\n+\t}\n+\n+\t// determine field pad from width: the least number of characters to output\n+\tlength := len(sign) + len(prefix) + zeroes + len(digits)\n+\tif width, widthSet := s.Width(); widthSet && length < width { // pad as specified\n+\t\tswitch d := width - length; {\n+\t\tcase s.Flag('-'):\n+\t\t\t// pad on the right with spaces; supersedes '0' when both specified\n+\t\t\tright = d\n+\t\tcase s.Flag('0') && !precisionSet:\n+\t\t\t// pad with zeroes unless precision also specified\n+\t\t\tzeroes = d\n+\t\tdefault:\n+\t\t\t// pad on the left with spaces\n+\t\t\tleft = d\n+\t\t}\n \t}\n-\tfmt.Fprint(s, x.abs.string(fmtbase(ch)))\n+\n+\t// print number as [left pad][sign][prefix][zero pad][digits][right pad]\n+\twriteMultiple(s, \" \", left)\n+\twriteMultiple(s, sign, 1)\n+\twriteMultiple(s, prefix, 1)\n+\twriteMultiple(s, \"0\", zeroes)\n+\twriteMultiple(s, digits, 1)\n+\twriteMultiple(s, \" \", right)\n }\n \n+// scan sets z to the integer value corresponding to the longest possible prefix\n+// read from r representing a signed integer number in a given conversion base.\n+// It returns z, the actual conversion base used, and an error, if any. In the\n+// error case, the value of z is undefined. The syntax follows the syntax of\n+// integer literals in Go.\n+//\n+// The base argument must be 0 or a value from 2 through MaxBase. If the base\n+// is 0, the string prefix determines the actual conversion base. A prefix of\n+// ``0x'' or ``0X'' selects base 16; the ``0'' prefix selects base 8, and a\n+// ``0b'' or ``0B'' prefix selects base 2. Otherwise the selected base is 10.\n+//\n+func (z *Int) scan(r io.RuneScanner, base int) (*Int, int, os.Error) {\n+\t// determine sign\n+\tch, _, err := r.ReadRune()\n+\tif err != nil {\n+\t\treturn z, 0, err\n+\t}\n+\tneg := false\n+\tswitch ch {\n+\tcase '-':\n+\t\tneg = true\n+\tcase '+': // nothing to do\n+\tdefault:\n+\t\tr.UnreadRune()\n+\t}\n \n-// Int64 returns the int64 representation of z.\n-// If z cannot be represented in an int64, the result is undefined.\n+\t// determine mantissa\n+\tz.abs, base, err = z.abs.scan(r, base)\n+\tif err != nil {\n+\t\treturn z, base, err\n+\t}\n+\tz.neg = len(z.abs) > 0 && neg // 0 has no sign\n+\n+\treturn z, base, nil\n+}\n+\n+// Scan is a support routine for fmt.Scanner; it sets z to the value of\n+// the scanned number. It accepts the formats 'b' (binary), 'o' (octal),\n+// 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal).\n+func (z *Int) Scan(s fmt.ScanState, ch int) os.Error {\n+\ts.SkipSpace() // skip leading space characters\n+\tbase := 0\n+\tswitch ch {\n+\tcase 'b':\n+\t\tbase = 2\n+\tcase 'o':\n+\t\tbase = 8\n+\tcase 'd':\n+\t\tbase = 10\n+\tcase 'x', 'X':\n+\t\tbase = 16\n+\tcase 's', 'v':\n+\t\t// let scan determine the base\n+\tdefault:\n+\t\treturn os.NewError(\"Int.Scan: invalid verb\")\n+\t}\n+\t_, _, err := z.scan(s, base)\n+\treturn err\n+}\n+\n+// Int64 returns the int64 representation of x.\n+// If x cannot be represented in an int64, the result is undefined.\n func (x *Int) Int64() int64 {\n \tif len(x.abs) == 0 {\n \t\treturn 0\n@@ -364,40 +495,25 @@ func (x *Int) Int64() int64 {\n \treturn v\n }\n \n-\n // SetString sets z to the value of s, interpreted in the given base,\n // and returns z and a boolean indicating success. If SetString fails,\n // the value of z is undefined.\n //\n-// If the base argument is 0, the string prefix determines the actual\n-// conversion base. A prefix of ``0x'' or ``0X'' selects base 16; the\n-// ``0'' prefix selects base 8, and a ``0b'' or ``0B'' prefix selects\n-// base 2. Otherwise the selected base is 10.\n+// The base argument must be 0 or a value from 2 through MaxBase. If the base\n+// is 0, the string prefix determines the actual conversion base. A prefix of\n+// ``0x'' or ``0X'' selects base 16; the ``0'' prefix selects base 8, and a\n+// ``0b'' or ``0B'' prefix selects base 2. Otherwise the selected base is 10.\n //\n func (z *Int) SetString(s string, base int) (*Int, bool) {\n-\tif len(s) == 0 || base < 0 || base == 1 || 16 < base {\n-\t\treturn z, false\n-\t}\n-\n-\tneg := s[0] == '-'\n-\tif neg || s[0] == '+' {\n-\t\ts = s[1:]\n-\t\tif len(s) == 0 {\n-\t\t\treturn z, false\n-\t\t}\n-\t}\n-\n-\tvar scanned int\n-\tz.abs, _, scanned = z.abs.scan(s, base)\n-\tif scanned != len(s) {\n+\tr := strings.NewReader(s)\n+\t_, _, err := z.scan(r, base)\n+\tif err != nil {\n \t\treturn z, false\n \t}\n-\tz.neg = len(z.abs) > 0 && neg // 0 has no sign\n-\n-\treturn z, true\n+\t_, _, err = r.ReadRune()\n+\treturn z, err == os.EOF // err == os.EOF => scan consumed all of s\n }\n \n-\n // SetBytes interprets buf as the bytes of a big-endian unsigned\n // integer, sets z to that value, and returns z.\n func (z *Int) SetBytes(buf []byte) *Int {\n@@ -406,21 +522,18 @@ func (z *Int) SetBytes(buf []byte) *Int {\n \treturn z\n }\n \n-\n // Bytes returns the absolute value of z as a big-endian byte slice.\n func (z *Int) Bytes() []byte {\n \tbuf := make([]byte, len(z.abs)*_S)\n \treturn buf[z.abs.bytes(buf):]\n }\n \n-\n // BitLen returns the length of the absolute value of z in bits.\n // The bit length of 0 is 0.\n func (z *Int) BitLen() int {\n \treturn z.abs.bitLen()\n }\n \n-\n // Exp sets z = x**y mod m. If m is nil, z = x**y.\n // See Knuth, volume 2, section 4.6.3.\n func (z *Int) Exp(x, y, m *Int) *Int {\n@@ -441,7 +554,6 @@ func (z *Int) Exp(x, y, m *Int) *Int {\n \treturn z\n }\n \n-\n // GcdInt sets d to the greatest common divisor of a and b, which must be\n // positive numbers.\n // If x and y are not nil, GcdInt sets x and y such that d = a*x + b*y.\n@@ -500,16 +612,14 @@ func GcdInt(d, x, y, a, b *Int) {\n \t*d = *A\n }\n \n-\n // ProbablyPrime performs n Miller-Rabin tests to check whether z is prime.\n // If it returns true, z is prime with probability 1 - 1/4^n.\n // If it returns false, z is not prime.\n func ProbablyPrime(z *Int, n int) bool {\n \treturn !z.neg && z.abs.probablyPrime(n)\n }\n \n-\n-// Rand sets z to a pseudo-random number in [0, n) and returns z. \n+// Rand sets z to a pseudo-random number in [0, n) and returns z.\n func (z *Int) Rand(rnd *rand.Rand, n *Int) *Int {\n \tz.neg = false\n \tif n.neg == true || len(n.abs) == 0 {\n@@ -520,7 +630,6 @@ func (z *Int) Rand(rnd *rand.Rand, n *Int) *Int {\n \treturn z\n }\n \n-\n // ModInverse sets z to the multiplicative inverse of g in the group \u2124/p\u2124 (where\n // p is a prime) and returns z.\n func (z *Int) ModInverse(g, p *Int) *Int {\n@@ -534,15 +643,13 @@ func (z *Int) ModInverse(g, p *Int) *Int {\n \treturn z\n }\n \n-\n // Lsh sets z = x << n and returns z.\n func (z *Int) Lsh(x *Int, n uint) *Int {\n \tz.abs = z.abs.shl(x.abs, n)\n \tz.neg = x.neg\n \treturn z\n }\n \n-\n // Rsh sets z = x >> n and returns z.\n func (z *Int) Rsh(x *Int, n uint) *Int {\n \tif x.neg {\n@@ -559,6 +666,39 @@ func (z *Int) Rsh(x *Int, n uint) *Int {\n \treturn z\n }\n \n+// Bit returns the value of the i'th bit of z. That is, it\n+// returns (z>>i)&1. The bit index i must be >= 0.\n+func (z *Int) Bit(i int) uint {\n+\tif i < 0 {\n+\t\tpanic(\"negative bit index\")\n+\t}\n+\tif z.neg {\n+\t\tt := nat{}.sub(z.abs, natOne)\n+\t\treturn t.bit(uint(i)) ^ 1\n+\t}\n+\n+\treturn z.abs.bit(uint(i))\n+}\n+\n+// SetBit sets the i'th bit of z to bit and returns z.\n+// That is, if bit is 1 SetBit sets z = x | (1 << i);\n+// if bit is 0 it sets z = x &^ (1 << i). If bit is not 0 or 1,\n+// SetBit will panic.\n+func (z *Int) SetBit(x *Int, i int, b uint) *Int {\n+\tif i < 0 {\n+\t\tpanic(\"negative bit index\")\n+\t}\n+\tif x.neg {\n+\t\tt := z.abs.sub(x.abs, natOne)\n+\t\tt = t.setBit(t, uint(i), b^1)\n+\t\tz.abs = t.add(t, natOne)\n+\t\tz.neg = len(z.abs) > 0\n+\t\treturn z\n+\t}\n+\tz.abs = z.abs.setBit(x.abs, uint(i), b)\n+\tz.neg = false\n+\treturn z\n+}\n \n // And sets z = x & y and returns z.\n func (z *Int) And(x, y *Int) *Int {\n@@ -590,7 +730,6 @@ func (z *Int) And(x, y *Int) *Int {\n \treturn z\n }\n \n-\n // AndNot sets z = x &^ y and returns z.\n func (z *Int) AndNot(x, y *Int) *Int {\n \tif x.neg == y.neg {\n@@ -624,7 +763,6 @@ func (z *Int) AndNot(x, y *Int) *Int {\n \treturn z\n }\n \n-\n // Or sets z = x | y and returns z.\n func (z *Int) Or(x, y *Int) *Int {\n \tif x.neg == y.neg {\n@@ -655,7 +793,6 @@ func (z *Int) Or(x, y *Int) *Int {\n \treturn z\n }\n \n-\n // Xor sets z = x ^ y and returns z.\n func (z *Int) Xor(x, y *Int) *Int {\n \tif x.neg == y.neg {\n@@ -686,7 +823,6 @@ func (z *Int) Xor(x, y *Int) *Int {\n \treturn z\n }\n \n-\n // Not sets z = ^x and returns z.\n func (z *Int) Not(x *Int) *Int {\n \tif x.neg {\n@@ -702,30 +838,28 @@ func (z *Int) Not(x *Int) *Int {\n \treturn z\n }\n \n-\n // Gob codec version. Permits backward-compatible changes to the encoding.\n-const version byte = 1\n+const intGobVersion byte = 1\n \n // GobEncode implements the gob.GobEncoder interface.\n func (z *Int) GobEncode() ([]byte, os.Error) {\n-\tbuf := make([]byte, len(z.abs)*_S+1) // extra byte for version and sign bit\n+\tbuf := make([]byte, 1+len(z.abs)*_S) // extra byte for version and sign bit\n \ti := z.abs.bytes(buf) - 1            // i >= 0\n-\tb := version << 1                    // make space for sign bit\n+\tb := intGobVersion << 1              // make space for sign bit\n \tif z.neg {\n \t\tb |= 1\n \t}\n \tbuf[i] = b\n \treturn buf[i:], nil\n }\n \n-\n // GobDecode implements the gob.GobDecoder interface.\n func (z *Int) GobDecode(buf []byte) os.Error {\n \tif len(buf) == 0 {\n \t\treturn os.NewError(\"Int.GobDecode: no data\")\n \t}\n \tb := buf[0]\n-\tif b>>1 != version {\n+\tif b>>1 != intGobVersion {\n \t\treturn os.NewError(fmt.Sprintf(\"Int.GobDecode: encoding version %d not supported\", b>>1))\n \t}\n \tz.neg = b&1 != 0"}, {"sha": "03446d6ae2d9cf81398401505dd3df0400cec4b9", "filename": "libgo/go/big/int_test.go", "status": "modified", "additions": 346, "deletions": 56, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Fint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Fint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fint_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -13,7 +13,6 @@ import (\n \t\"testing/quick\"\n )\n \n-\n func isNormalized(x *Int) bool {\n \tif len(x.abs) == 0 {\n \t\treturn !x.neg\n@@ -22,13 +21,11 @@ func isNormalized(x *Int) bool {\n \treturn x.abs[len(x.abs)-1] != 0\n }\n \n-\n type funZZ func(z, x, y *Int) *Int\n type argZZ struct {\n \tz, x, y *Int\n }\n \n-\n var sumZZ = []argZZ{\n \t{NewInt(0), NewInt(0), NewInt(0)},\n \t{NewInt(1), NewInt(1), NewInt(0)},\n@@ -38,7 +35,6 @@ var sumZZ = []argZZ{\n \t{NewInt(-1111111110), NewInt(-123456789), NewInt(-987654321)},\n }\n \n-\n var prodZZ = []argZZ{\n \t{NewInt(0), NewInt(0), NewInt(0)},\n \t{NewInt(0), NewInt(1), NewInt(0)},\n@@ -47,7 +43,6 @@ var prodZZ = []argZZ{\n \t// TODO(gri) add larger products\n }\n \n-\n func TestSignZ(t *testing.T) {\n \tvar zero Int\n \tfor _, a := range sumZZ {\n@@ -59,7 +54,6 @@ func TestSignZ(t *testing.T) {\n \t}\n }\n \n-\n func TestSetZ(t *testing.T) {\n \tfor _, a := range sumZZ {\n \t\tvar z Int\n@@ -73,7 +67,6 @@ func TestSetZ(t *testing.T) {\n \t}\n }\n \n-\n func TestAbsZ(t *testing.T) {\n \tvar zero Int\n \tfor _, a := range sumZZ {\n@@ -90,7 +83,6 @@ func TestAbsZ(t *testing.T) {\n \t}\n }\n \n-\n func testFunZZ(t *testing.T, msg string, f funZZ, a argZZ) {\n \tvar z Int\n \tf(&z, a.x, a.y)\n@@ -102,7 +94,6 @@ func testFunZZ(t *testing.T, msg string, f funZZ, a argZZ) {\n \t}\n }\n \n-\n func TestSumZZ(t *testing.T) {\n \tAddZZ := func(z, x, y *Int) *Int { return z.Add(x, y) }\n \tSubZZ := func(z, x, y *Int) *Int { return z.Sub(x, y) }\n@@ -121,7 +112,6 @@ func TestSumZZ(t *testing.T) {\n \t}\n }\n \n-\n func TestProdZZ(t *testing.T) {\n \tMulZZ := func(z, x, y *Int) *Int { return z.Mul(x, y) }\n \tfor _, a := range prodZZ {\n@@ -133,7 +123,6 @@ func TestProdZZ(t *testing.T) {\n \t}\n }\n \n-\n // mulBytes returns x*y via grade school multiplication. Both inputs\n // and the result are assumed to be in big-endian representation (to\n // match the semantics of Int.Bytes and Int.SetBytes).\n@@ -166,7 +155,6 @@ func mulBytes(x, y []byte) []byte {\n \treturn z[i:]\n }\n \n-\n func checkMul(a, b []byte) bool {\n \tvar x, y, z1 Int\n \tx.SetBytes(a)\n@@ -179,14 +167,12 @@ func checkMul(a, b []byte) bool {\n \treturn z1.Cmp(&z2) == 0\n }\n \n-\n func TestMul(t *testing.T) {\n \tif err := quick.Check(checkMul, nil); err != nil {\n \t\tt.Error(err)\n \t}\n }\n \n-\n var mulRangesZ = []struct {\n \ta, b int64\n \tprod string\n@@ -212,7 +198,6 @@ var mulRangesZ = []struct {\n \t},\n }\n \n-\n func TestMulRangeZ(t *testing.T) {\n \tvar tmp Int\n \t// test entirely positive ranges\n@@ -231,7 +216,6 @@ func TestMulRangeZ(t *testing.T) {\n \t}\n }\n \n-\n var stringTests = []struct {\n \tin   string\n \tout  string\n@@ -280,7 +264,6 @@ var stringTests = []struct {\n \t{\"1001010111\", \"1001010111\", 2, 0x257, true},\n }\n \n-\n func format(base int) string {\n \tswitch base {\n \tcase 2:\n@@ -293,7 +276,6 @@ func format(base int) string {\n \treturn \"%d\"\n }\n \n-\n func TestGetString(t *testing.T) {\n \tz := new(Int)\n \tfor i, test := range stringTests {\n@@ -316,7 +298,6 @@ func TestGetString(t *testing.T) {\n \t}\n }\n \n-\n func TestSetString(t *testing.T) {\n \ttmp := new(Int)\n \tfor i, test := range stringTests {\n@@ -347,6 +328,212 @@ func TestSetString(t *testing.T) {\n \t}\n }\n \n+var formatTests = []struct {\n+\tinput  string\n+\tformat string\n+\toutput string\n+}{\n+\t{\"<nil>\", \"%x\", \"<nil>\"},\n+\t{\"<nil>\", \"%#x\", \"<nil>\"},\n+\t{\"<nil>\", \"%#y\", \"%!y(big.Int=<nil>)\"},\n+\n+\t{\"10\", \"%b\", \"1010\"},\n+\t{\"10\", \"%o\", \"12\"},\n+\t{\"10\", \"%d\", \"10\"},\n+\t{\"10\", \"%v\", \"10\"},\n+\t{\"10\", \"%x\", \"a\"},\n+\t{\"10\", \"%X\", \"A\"},\n+\t{\"-10\", \"%X\", \"-A\"},\n+\t{\"10\", \"%y\", \"%!y(big.Int=10)\"},\n+\t{\"-10\", \"%y\", \"%!y(big.Int=-10)\"},\n+\n+\t{\"10\", \"%#b\", \"1010\"},\n+\t{\"10\", \"%#o\", \"012\"},\n+\t{\"10\", \"%#d\", \"10\"},\n+\t{\"10\", \"%#v\", \"10\"},\n+\t{\"10\", \"%#x\", \"0xa\"},\n+\t{\"10\", \"%#X\", \"0XA\"},\n+\t{\"-10\", \"%#X\", \"-0XA\"},\n+\t{\"10\", \"%#y\", \"%!y(big.Int=10)\"},\n+\t{\"-10\", \"%#y\", \"%!y(big.Int=-10)\"},\n+\n+\t{\"1234\", \"%d\", \"1234\"},\n+\t{\"1234\", \"%3d\", \"1234\"},\n+\t{\"1234\", \"%4d\", \"1234\"},\n+\t{\"-1234\", \"%d\", \"-1234\"},\n+\t{\"1234\", \"% 5d\", \" 1234\"},\n+\t{\"1234\", \"%+5d\", \"+1234\"},\n+\t{\"1234\", \"%-5d\", \"1234 \"},\n+\t{\"1234\", \"%x\", \"4d2\"},\n+\t{\"1234\", \"%X\", \"4D2\"},\n+\t{\"-1234\", \"%3x\", \"-4d2\"},\n+\t{\"-1234\", \"%4x\", \"-4d2\"},\n+\t{\"-1234\", \"%5x\", \" -4d2\"},\n+\t{\"-1234\", \"%-5x\", \"-4d2 \"},\n+\t{\"1234\", \"%03d\", \"1234\"},\n+\t{\"1234\", \"%04d\", \"1234\"},\n+\t{\"1234\", \"%05d\", \"01234\"},\n+\t{\"1234\", \"%06d\", \"001234\"},\n+\t{\"-1234\", \"%06d\", \"-01234\"},\n+\t{\"1234\", \"%+06d\", \"+01234\"},\n+\t{\"1234\", \"% 06d\", \" 01234\"},\n+\t{\"1234\", \"%-6d\", \"1234  \"},\n+\t{\"1234\", \"%-06d\", \"1234  \"},\n+\t{\"-1234\", \"%-06d\", \"-1234 \"},\n+\n+\t{\"1234\", \"%.3d\", \"1234\"},\n+\t{\"1234\", \"%.4d\", \"1234\"},\n+\t{\"1234\", \"%.5d\", \"01234\"},\n+\t{\"1234\", \"%.6d\", \"001234\"},\n+\t{\"-1234\", \"%.3d\", \"-1234\"},\n+\t{\"-1234\", \"%.4d\", \"-1234\"},\n+\t{\"-1234\", \"%.5d\", \"-01234\"},\n+\t{\"-1234\", \"%.6d\", \"-001234\"},\n+\n+\t{\"1234\", \"%8.3d\", \"    1234\"},\n+\t{\"1234\", \"%8.4d\", \"    1234\"},\n+\t{\"1234\", \"%8.5d\", \"   01234\"},\n+\t{\"1234\", \"%8.6d\", \"  001234\"},\n+\t{\"-1234\", \"%8.3d\", \"   -1234\"},\n+\t{\"-1234\", \"%8.4d\", \"   -1234\"},\n+\t{\"-1234\", \"%8.5d\", \"  -01234\"},\n+\t{\"-1234\", \"%8.6d\", \" -001234\"},\n+\n+\t{\"1234\", \"%+8.3d\", \"   +1234\"},\n+\t{\"1234\", \"%+8.4d\", \"   +1234\"},\n+\t{\"1234\", \"%+8.5d\", \"  +01234\"},\n+\t{\"1234\", \"%+8.6d\", \" +001234\"},\n+\t{\"-1234\", \"%+8.3d\", \"   -1234\"},\n+\t{\"-1234\", \"%+8.4d\", \"   -1234\"},\n+\t{\"-1234\", \"%+8.5d\", \"  -01234\"},\n+\t{\"-1234\", \"%+8.6d\", \" -001234\"},\n+\n+\t{\"1234\", \"% 8.3d\", \"    1234\"},\n+\t{\"1234\", \"% 8.4d\", \"    1234\"},\n+\t{\"1234\", \"% 8.5d\", \"   01234\"},\n+\t{\"1234\", \"% 8.6d\", \"  001234\"},\n+\t{\"-1234\", \"% 8.3d\", \"   -1234\"},\n+\t{\"-1234\", \"% 8.4d\", \"   -1234\"},\n+\t{\"-1234\", \"% 8.5d\", \"  -01234\"},\n+\t{\"-1234\", \"% 8.6d\", \" -001234\"},\n+\n+\t{\"1234\", \"%.3x\", \"4d2\"},\n+\t{\"1234\", \"%.4x\", \"04d2\"},\n+\t{\"1234\", \"%.5x\", \"004d2\"},\n+\t{\"1234\", \"%.6x\", \"0004d2\"},\n+\t{\"-1234\", \"%.3x\", \"-4d2\"},\n+\t{\"-1234\", \"%.4x\", \"-04d2\"},\n+\t{\"-1234\", \"%.5x\", \"-004d2\"},\n+\t{\"-1234\", \"%.6x\", \"-0004d2\"},\n+\n+\t{\"1234\", \"%8.3x\", \"     4d2\"},\n+\t{\"1234\", \"%8.4x\", \"    04d2\"},\n+\t{\"1234\", \"%8.5x\", \"   004d2\"},\n+\t{\"1234\", \"%8.6x\", \"  0004d2\"},\n+\t{\"-1234\", \"%8.3x\", \"    -4d2\"},\n+\t{\"-1234\", \"%8.4x\", \"   -04d2\"},\n+\t{\"-1234\", \"%8.5x\", \"  -004d2\"},\n+\t{\"-1234\", \"%8.6x\", \" -0004d2\"},\n+\n+\t{\"1234\", \"%+8.3x\", \"    +4d2\"},\n+\t{\"1234\", \"%+8.4x\", \"   +04d2\"},\n+\t{\"1234\", \"%+8.5x\", \"  +004d2\"},\n+\t{\"1234\", \"%+8.6x\", \" +0004d2\"},\n+\t{\"-1234\", \"%+8.3x\", \"    -4d2\"},\n+\t{\"-1234\", \"%+8.4x\", \"   -04d2\"},\n+\t{\"-1234\", \"%+8.5x\", \"  -004d2\"},\n+\t{\"-1234\", \"%+8.6x\", \" -0004d2\"},\n+\n+\t{\"1234\", \"% 8.3x\", \"     4d2\"},\n+\t{\"1234\", \"% 8.4x\", \"    04d2\"},\n+\t{\"1234\", \"% 8.5x\", \"   004d2\"},\n+\t{\"1234\", \"% 8.6x\", \"  0004d2\"},\n+\t{\"1234\", \"% 8.7x\", \" 00004d2\"},\n+\t{\"1234\", \"% 8.8x\", \" 000004d2\"},\n+\t{\"-1234\", \"% 8.3x\", \"    -4d2\"},\n+\t{\"-1234\", \"% 8.4x\", \"   -04d2\"},\n+\t{\"-1234\", \"% 8.5x\", \"  -004d2\"},\n+\t{\"-1234\", \"% 8.6x\", \" -0004d2\"},\n+\t{\"-1234\", \"% 8.7x\", \"-00004d2\"},\n+\t{\"-1234\", \"% 8.8x\", \"-000004d2\"},\n+\n+\t{\"1234\", \"%-8.3d\", \"1234    \"},\n+\t{\"1234\", \"%-8.4d\", \"1234    \"},\n+\t{\"1234\", \"%-8.5d\", \"01234   \"},\n+\t{\"1234\", \"%-8.6d\", \"001234  \"},\n+\t{\"1234\", \"%-8.7d\", \"0001234 \"},\n+\t{\"1234\", \"%-8.8d\", \"00001234\"},\n+\t{\"-1234\", \"%-8.3d\", \"-1234   \"},\n+\t{\"-1234\", \"%-8.4d\", \"-1234   \"},\n+\t{\"-1234\", \"%-8.5d\", \"-01234  \"},\n+\t{\"-1234\", \"%-8.6d\", \"-001234 \"},\n+\t{\"-1234\", \"%-8.7d\", \"-0001234\"},\n+\t{\"-1234\", \"%-8.8d\", \"-00001234\"},\n+\n+\t{\"16777215\", \"%b\", \"111111111111111111111111\"}, // 2**24 - 1\n+\n+\t{\"0\", \"%.d\", \"\"},\n+\t{\"0\", \"%.0d\", \"\"},\n+\t{\"0\", \"%3.d\", \"\"},\n+}\n+\n+func TestFormat(t *testing.T) {\n+\tfor i, test := range formatTests {\n+\t\tvar x *Int\n+\t\tif test.input != \"<nil>\" {\n+\t\t\tvar ok bool\n+\t\t\tx, ok = new(Int).SetString(test.input, 0)\n+\t\t\tif !ok {\n+\t\t\t\tt.Errorf(\"#%d failed reading input %s\", i, test.input)\n+\t\t\t}\n+\t\t}\n+\t\toutput := fmt.Sprintf(test.format, x)\n+\t\tif output != test.output {\n+\t\t\tt.Errorf(\"#%d got %q; want %q, {%q, %q, %q}\", i, output, test.output, test.input, test.format, test.output)\n+\t\t}\n+\t}\n+}\n+\n+var scanTests = []struct {\n+\tinput     string\n+\tformat    string\n+\toutput    string\n+\tremaining int\n+}{\n+\t{\"1010\", \"%b\", \"10\", 0},\n+\t{\"0b1010\", \"%v\", \"10\", 0},\n+\t{\"12\", \"%o\", \"10\", 0},\n+\t{\"012\", \"%v\", \"10\", 0},\n+\t{\"10\", \"%d\", \"10\", 0},\n+\t{\"10\", \"%v\", \"10\", 0},\n+\t{\"a\", \"%x\", \"10\", 0},\n+\t{\"0xa\", \"%v\", \"10\", 0},\n+\t{\"A\", \"%X\", \"10\", 0},\n+\t{\"-A\", \"%X\", \"-10\", 0},\n+\t{\"+0b1011001\", \"%v\", \"89\", 0},\n+\t{\"0xA\", \"%v\", \"10\", 0},\n+\t{\"0 \", \"%v\", \"0\", 1},\n+\t{\"2+3\", \"%v\", \"2\", 2},\n+\t{\"0XABC 12\", \"%v\", \"2748\", 3},\n+}\n+\n+func TestScan(t *testing.T) {\n+\tvar buf bytes.Buffer\n+\tfor i, test := range scanTests {\n+\t\tx := new(Int)\n+\t\tbuf.Reset()\n+\t\tbuf.WriteString(test.input)\n+\t\tif _, err := fmt.Fscanf(&buf, test.format, x); err != nil {\n+\t\t\tt.Errorf(\"#%d error: %s\", i, err.String())\n+\t\t}\n+\t\tif x.String() != test.output {\n+\t\t\tt.Errorf(\"#%d got %s; want %s\", i, x.String(), test.output)\n+\t\t}\n+\t\tif buf.Len() != test.remaining {\n+\t\t\tt.Errorf(\"#%d got %d bytes remaining; want %d\", i, buf.Len(), test.remaining)\n+\t\t}\n+\t}\n+}\n \n // Examples from the Go Language Spec, section \"Arithmetic operators\"\n var divisionSignsTests = []struct {\n@@ -362,7 +549,6 @@ var divisionSignsTests = []struct {\n \t{8, 4, 2, 0, 2, 0},\n }\n \n-\n func TestDivisionSigns(t *testing.T) {\n \tfor i, test := range divisionSignsTests {\n \t\tx := NewInt(test.x)\n@@ -420,7 +606,6 @@ func TestDivisionSigns(t *testing.T) {\n \t}\n }\n \n-\n func checkSetBytes(b []byte) bool {\n \thex1 := hex.EncodeToString(new(Int).SetBytes(b).Bytes())\n \thex2 := hex.EncodeToString(b)\n@@ -436,27 +621,23 @@ func checkSetBytes(b []byte) bool {\n \treturn hex1 == hex2\n }\n \n-\n func TestSetBytes(t *testing.T) {\n \tif err := quick.Check(checkSetBytes, nil); err != nil {\n \t\tt.Error(err)\n \t}\n }\n \n-\n func checkBytes(b []byte) bool {\n \tb2 := new(Int).SetBytes(b).Bytes()\n \treturn bytes.Compare(b, b2) == 0\n }\n \n-\n func TestBytes(t *testing.T) {\n \tif err := quick.Check(checkSetBytes, nil); err != nil {\n \t\tt.Error(err)\n \t}\n }\n \n-\n func checkQuo(x, y []byte) bool {\n \tu := new(Int).SetBytes(x)\n \tv := new(Int).SetBytes(y)\n@@ -479,7 +660,6 @@ func checkQuo(x, y []byte) bool {\n \treturn uprime.Cmp(u) == 0\n }\n \n-\n var quoTests = []struct {\n \tx, y string\n \tq, r string\n@@ -498,7 +678,6 @@ var quoTests = []struct {\n \t},\n }\n \n-\n func TestQuo(t *testing.T) {\n \tif err := quick.Check(checkQuo, nil); err != nil {\n \t\tt.Error(err)\n@@ -519,7 +698,6 @@ func TestQuo(t *testing.T) {\n \t}\n }\n \n-\n func TestQuoStepD6(t *testing.T) {\n \t// See Knuth, Volume 2, section 4.3.1, exercise 21. This code exercises\n \t// a code path which only triggers 1 in 10^{-19} cases.\n@@ -539,7 +717,6 @@ func TestQuoStepD6(t *testing.T) {\n \t}\n }\n \n-\n var bitLenTests = []struct {\n \tin  string\n \tout int\n@@ -558,7 +735,6 @@ var bitLenTests = []struct {\n \t{\"-0x4000000000000000000000\", 87},\n }\n \n-\n func TestBitLen(t *testing.T) {\n \tfor i, test := range bitLenTests {\n \t\tx, ok := new(Int).SetString(test.in, 0)\n@@ -573,7 +749,6 @@ func TestBitLen(t *testing.T) {\n \t}\n }\n \n-\n var expTests = []struct {\n \tx, y, m string\n \tout     string\n@@ -598,7 +773,6 @@ var expTests = []struct {\n \t},\n }\n \n-\n func TestExp(t *testing.T) {\n \tfor i, test := range expTests {\n \t\tx, ok1 := new(Int).SetString(test.x, 0)\n@@ -629,7 +803,6 @@ func TestExp(t *testing.T) {\n \t}\n }\n \n-\n func checkGcd(aBytes, bBytes []byte) bool {\n \ta := new(Int).SetBytes(aBytes)\n \tb := new(Int).SetBytes(bBytes)\n@@ -646,15 +819,13 @@ func checkGcd(aBytes, bBytes []byte) bool {\n \treturn x.Cmp(d) == 0\n }\n \n-\n var gcdTests = []struct {\n \ta, b    int64\n \td, x, y int64\n }{\n \t{120, 23, 1, -9, 47},\n }\n \n-\n func TestGcd(t *testing.T) {\n \tfor i, test := range gcdTests {\n \t\ta := NewInt(test.a)\n@@ -680,7 +851,6 @@ func TestGcd(t *testing.T) {\n \tquick.Check(checkGcd, nil)\n }\n \n-\n var primes = []string{\n \t\"2\",\n \t\"3\",\n@@ -706,15 +876,13 @@ var primes = []string{\n \t\"203956878356401977405765866929034577280193993314348263094772646453283062722701277632936616063144088173312372882677123879538709400158306567338328279154499698366071906766440037074217117805690872792848149112022286332144876183376326512083574821647933992961249917319836219304274280243803104015000563790123\",\n }\n \n-\n var composites = []string{\n \t\"21284175091214687912771199898307297748211672914763848041968395774954376176754\",\n \t\"6084766654921918907427900243509372380954290099172559290432744450051395395951\",\n \t\"84594350493221918389213352992032324280367711247940675652888030554255915464401\",\n \t\"82793403787388584738507275144194252681\",\n }\n \n-\n func TestProbablyPrime(t *testing.T) {\n \tnreps := 20\n \tif testing.Short() {\n@@ -738,14 +906,12 @@ func TestProbablyPrime(t *testing.T) {\n \t}\n }\n \n-\n type intShiftTest struct {\n \tin    string\n \tshift uint\n \tout   string\n }\n \n-\n var rshTests = []intShiftTest{\n \t{\"0\", 0, \"0\"},\n \t{\"-0\", 0, \"0\"},\n@@ -773,7 +939,6 @@ var rshTests = []intShiftTest{\n \t{\"340282366920938463463374607431768211456\", 128, \"1\"},\n }\n \n-\n func TestRsh(t *testing.T) {\n \tfor i, test := range rshTests {\n \t\tin, _ := new(Int).SetString(test.in, 10)\n@@ -789,7 +954,6 @@ func TestRsh(t *testing.T) {\n \t}\n }\n \n-\n func TestRshSelf(t *testing.T) {\n \tfor i, test := range rshTests {\n \t\tz, _ := new(Int).SetString(test.in, 10)\n@@ -805,7 +969,6 @@ func TestRshSelf(t *testing.T) {\n \t}\n }\n \n-\n var lshTests = []intShiftTest{\n \t{\"0\", 0, \"0\"},\n \t{\"0\", 1, \"0\"},\n@@ -828,7 +991,6 @@ var lshTests = []intShiftTest{\n \t{\"1\", 128, \"340282366920938463463374607431768211456\"},\n }\n \n-\n func TestLsh(t *testing.T) {\n \tfor i, test := range lshTests {\n \t\tin, _ := new(Int).SetString(test.in, 10)\n@@ -844,7 +1006,6 @@ func TestLsh(t *testing.T) {\n \t}\n }\n \n-\n func TestLshSelf(t *testing.T) {\n \tfor i, test := range lshTests {\n \t\tz, _ := new(Int).SetString(test.in, 10)\n@@ -860,7 +1021,6 @@ func TestLshSelf(t *testing.T) {\n \t}\n }\n \n-\n func TestLshRsh(t *testing.T) {\n \tfor i, test := range rshTests {\n \t\tin, _ := new(Int).SetString(test.in, 10)\n@@ -888,7 +1048,6 @@ func TestLshRsh(t *testing.T) {\n \t}\n }\n \n-\n var int64Tests = []int64{\n \t0,\n \t1,\n@@ -902,7 +1061,6 @@ var int64Tests = []int64{\n \t-9223372036854775808,\n }\n \n-\n func TestInt64(t *testing.T) {\n \tfor i, testVal := range int64Tests {\n \t\tin := NewInt(testVal)\n@@ -914,7 +1072,6 @@ func TestInt64(t *testing.T) {\n \t}\n }\n \n-\n var bitwiseTests = []struct {\n \tx, y                 string\n \tand, or, xor, andNot string\n@@ -958,7 +1115,6 @@ var bitwiseTests = []struct {\n \t},\n }\n \n-\n type bitFun func(z, x, y *Int) *Int\n \n func testBitFun(t *testing.T, msg string, f bitFun, x, y *Int, exp string) {\n@@ -971,7 +1127,6 @@ func testBitFun(t *testing.T, msg string, f bitFun, x, y *Int, exp string) {\n \t}\n }\n \n-\n func testBitFunSelf(t *testing.T, msg string, f bitFun, x, y *Int, exp string) {\n \tself := new(Int)\n \tself.Set(x)\n@@ -984,6 +1139,142 @@ func testBitFunSelf(t *testing.T, msg string, f bitFun, x, y *Int, exp string) {\n \t}\n }\n \n+func altBit(x *Int, i int) uint {\n+\tz := new(Int).Rsh(x, uint(i))\n+\tz = z.And(z, NewInt(1))\n+\tif z.Cmp(new(Int)) != 0 {\n+\t\treturn 1\n+\t}\n+\treturn 0\n+}\n+\n+func altSetBit(z *Int, x *Int, i int, b uint) *Int {\n+\tone := NewInt(1)\n+\tm := one.Lsh(one, uint(i))\n+\tswitch b {\n+\tcase 1:\n+\t\treturn z.Or(x, m)\n+\tcase 0:\n+\t\treturn z.AndNot(x, m)\n+\t}\n+\tpanic(\"set bit is not 0 or 1\")\n+}\n+\n+func testBitset(t *testing.T, x *Int) {\n+\tn := x.BitLen()\n+\tz := new(Int).Set(x)\n+\tz1 := new(Int).Set(x)\n+\tfor i := 0; i < n+10; i++ {\n+\t\told := z.Bit(i)\n+\t\told1 := altBit(z1, i)\n+\t\tif old != old1 {\n+\t\t\tt.Errorf(\"bitset: inconsistent value for Bit(%s, %d), got %v want %v\", z1, i, old, old1)\n+\t\t}\n+\t\tz := new(Int).SetBit(z, i, 1)\n+\t\tz1 := altSetBit(new(Int), z1, i, 1)\n+\t\tif z.Bit(i) == 0 {\n+\t\t\tt.Errorf(\"bitset: bit %d of %s got 0 want 1\", i, x)\n+\t\t}\n+\t\tif z.Cmp(z1) != 0 {\n+\t\t\tt.Errorf(\"bitset: inconsistent value after SetBit 1, got %s want %s\", z, z1)\n+\t\t}\n+\t\tz.SetBit(z, i, 0)\n+\t\taltSetBit(z1, z1, i, 0)\n+\t\tif z.Bit(i) != 0 {\n+\t\t\tt.Errorf(\"bitset: bit %d of %s got 1 want 0\", i, x)\n+\t\t}\n+\t\tif z.Cmp(z1) != 0 {\n+\t\t\tt.Errorf(\"bitset: inconsistent value after SetBit 0, got %s want %s\", z, z1)\n+\t\t}\n+\t\taltSetBit(z1, z1, i, old)\n+\t\tz.SetBit(z, i, old)\n+\t\tif z.Cmp(z1) != 0 {\n+\t\t\tt.Errorf(\"bitset: inconsistent value after SetBit old, got %s want %s\", z, z1)\n+\t\t}\n+\t}\n+\tif z.Cmp(x) != 0 {\n+\t\tt.Errorf(\"bitset: got %s want %s\", z, x)\n+\t}\n+}\n+\n+var bitsetTests = []struct {\n+\tx string\n+\ti int\n+\tb uint\n+}{\n+\t{\"0\", 0, 0},\n+\t{\"0\", 200, 0},\n+\t{\"1\", 0, 1},\n+\t{\"1\", 1, 0},\n+\t{\"-1\", 0, 1},\n+\t{\"-1\", 200, 1},\n+\t{\"0x2000000000000000000000000000\", 108, 0},\n+\t{\"0x2000000000000000000000000000\", 109, 1},\n+\t{\"0x2000000000000000000000000000\", 110, 0},\n+\t{\"-0x2000000000000000000000000001\", 108, 1},\n+\t{\"-0x2000000000000000000000000001\", 109, 0},\n+\t{\"-0x2000000000000000000000000001\", 110, 1},\n+}\n+\n+func TestBitSet(t *testing.T) {\n+\tfor _, test := range bitwiseTests {\n+\t\tx := new(Int)\n+\t\tx.SetString(test.x, 0)\n+\t\ttestBitset(t, x)\n+\t\tx = new(Int)\n+\t\tx.SetString(test.y, 0)\n+\t\ttestBitset(t, x)\n+\t}\n+\tfor i, test := range bitsetTests {\n+\t\tx := new(Int)\n+\t\tx.SetString(test.x, 0)\n+\t\tb := x.Bit(test.i)\n+\t\tif b != test.b {\n+\n+\t\t\tt.Errorf(\"#%d want %v got %v\", i, test.b, b)\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkBitset(b *testing.B) {\n+\tz := new(Int)\n+\tz.SetBit(z, 512, 1)\n+\tb.ResetTimer()\n+\tb.StartTimer()\n+\tfor i := b.N - 1; i >= 0; i-- {\n+\t\tz.SetBit(z, i&512, 1)\n+\t}\n+}\n+\n+func BenchmarkBitsetNeg(b *testing.B) {\n+\tz := NewInt(-1)\n+\tz.SetBit(z, 512, 0)\n+\tb.ResetTimer()\n+\tb.StartTimer()\n+\tfor i := b.N - 1; i >= 0; i-- {\n+\t\tz.SetBit(z, i&512, 0)\n+\t}\n+}\n+\n+func BenchmarkBitsetOrig(b *testing.B) {\n+\tz := new(Int)\n+\taltSetBit(z, z, 512, 1)\n+\tb.ResetTimer()\n+\tb.StartTimer()\n+\tfor i := b.N - 1; i >= 0; i-- {\n+\t\taltSetBit(z, z, i&512, 1)\n+\t}\n+}\n+\n+func BenchmarkBitsetNegOrig(b *testing.B) {\n+\tz := NewInt(-1)\n+\taltSetBit(z, z, 512, 0)\n+\tb.ResetTimer()\n+\tb.StartTimer()\n+\tfor i := b.N - 1; i >= 0; i-- {\n+\t\taltSetBit(z, z, i&512, 0)\n+\t}\n+}\n \n func TestBitwise(t *testing.T) {\n \tx := new(Int)\n@@ -1003,7 +1294,6 @@ func TestBitwise(t *testing.T) {\n \t}\n }\n \n-\n var notTests = []struct {\n \tin  string\n \tout string\n@@ -1037,7 +1327,6 @@ func TestNot(t *testing.T) {\n \t}\n }\n \n-\n var modInverseTests = []struct {\n \telement string\n \tprime   string\n@@ -1062,7 +1351,7 @@ func TestModInverse(t *testing.T) {\n \t}\n }\n \n-\n+// used by TestIntGobEncoding and TestRatGobEncoding\n var gobEncodingTests = []string{\n \t\"0\",\n \t\"1\",\n@@ -1073,15 +1362,16 @@ var gobEncodingTests = []string{\n \t\"298472983472983471903246121093472394872319615612417471234712061\",\n }\n \n-func TestGobEncoding(t *testing.T) {\n+func TestIntGobEncoding(t *testing.T) {\n \tvar medium bytes.Buffer\n \tenc := gob.NewEncoder(&medium)\n \tdec := gob.NewDecoder(&medium)\n \tfor i, test := range gobEncodingTests {\n \t\tfor j := 0; j < 2; j++ {\n \t\t\tmedium.Reset() // empty buffer for each test case (in case of failures)\n \t\t\tstest := test\n-\t\t\tif j == 0 {\n+\t\t\tif j != 0 {\n+\t\t\t\t// negative numbers\n \t\t\t\tstest = \"-\" + test\n \t\t\t}\n \t\t\tvar tx Int"}, {"sha": "be3aff29d1840d4644567db1aa09ec620b674a7d", "filename": "libgo/go/big/nat.go", "status": "modified", "additions": 273, "deletions": 115, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fnat.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -18,7 +18,11 @@ package big\n // These are the building blocks for the operations on signed integers\n // and rationals.\n \n-import \"rand\"\n+import (\n+\t\"io\"\n+\t\"os\"\n+\t\"rand\"\n+)\n \n // An unsigned integer x of the form\n //\n@@ -40,14 +44,12 @@ var (\n \tnatTen = nat{10}\n )\n \n-\n func (z nat) clear() {\n \tfor i := range z {\n \t\tz[i] = 0\n \t}\n }\n \n-\n func (z nat) norm() nat {\n \ti := len(z)\n \tfor i > 0 && z[i-1] == 0 {\n@@ -56,7 +58,6 @@ func (z nat) norm() nat {\n \treturn z[0:i]\n }\n \n-\n func (z nat) make(n int) nat {\n \tif n <= cap(z) {\n \t\treturn z[0:n] // reuse z\n@@ -67,7 +68,6 @@ func (z nat) make(n int) nat {\n \treturn make(nat, n, n+e)\n }\n \n-\n func (z nat) setWord(x Word) nat {\n \tif x == 0 {\n \t\treturn z.make(0)\n@@ -77,7 +77,6 @@ func (z nat) setWord(x Word) nat {\n \treturn z\n }\n \n-\n func (z nat) setUint64(x uint64) nat {\n \t// single-digit values\n \tif w := Word(x); uint64(w) == x {\n@@ -100,14 +99,12 @@ func (z nat) setUint64(x uint64) nat {\n \treturn z\n }\n \n-\n func (z nat) set(x nat) nat {\n \tz = z.make(len(x))\n \tcopy(z, x)\n \treturn z\n }\n \n-\n func (z nat) add(x, y nat) nat {\n \tm := len(x)\n \tn := len(y)\n@@ -134,7 +131,6 @@ func (z nat) add(x, y nat) nat {\n \treturn z.norm()\n }\n \n-\n func (z nat) sub(x, y nat) nat {\n \tm := len(x)\n \tn := len(y)\n@@ -163,7 +159,6 @@ func (z nat) sub(x, y nat) nat {\n \treturn z.norm()\n }\n \n-\n func (x nat) cmp(y nat) (r int) {\n \tm := len(x)\n \tn := len(y)\n@@ -191,7 +186,6 @@ func (x nat) cmp(y nat) (r int) {\n \treturn\n }\n \n-\n func (z nat) mulAddWW(x nat, y, r Word) nat {\n \tm := len(x)\n \tif m == 0 || y == 0 {\n@@ -205,7 +199,6 @@ func (z nat) mulAddWW(x nat, y, r Word) nat {\n \treturn z.norm()\n }\n \n-\n // basicMul multiplies x and y and leaves the result in z.\n // The (non-normalized) result is placed in z[0 : len(x) + len(y)].\n func basicMul(z, x, y nat) {\n@@ -217,7 +210,6 @@ func basicMul(z, x, y nat) {\n \t}\n }\n \n-\n // Fast version of z[0:n+n>>1].add(z[0:n+n>>1], x[0:n]) w/o bounds checks.\n // Factored out for readability - do not use outside karatsuba.\n func karatsubaAdd(z, x nat, n int) {\n@@ -226,15 +218,13 @@ func karatsubaAdd(z, x nat, n int) {\n \t}\n }\n \n-\n // Like karatsubaAdd, but does subtract.\n func karatsubaSub(z, x nat, n int) {\n \tif c := subVV(z[0:n], z, x); c != 0 {\n \t\tsubVW(z[n:n+n>>1], z[n:], c)\n \t}\n }\n \n-\n // Operands that are shorter than karatsubaThreshold are multiplied using\n // \"grade school\" multiplication; for longer operands the Karatsuba algorithm\n // is used.\n@@ -339,13 +329,11 @@ func karatsuba(z, x, y nat) {\n \t}\n }\n \n-\n // alias returns true if x and y share the same base array.\n func alias(x, y nat) bool {\n \treturn cap(x) > 0 && cap(y) > 0 && &x[0:cap(x)][cap(x)-1] == &y[0:cap(y)][cap(y)-1]\n }\n \n-\n // addAt implements z += x*(1<<(_W*i)); z must be long enough.\n // (we don't use nat.add because we need z to stay the same\n // slice, and we don't need to normalize z after each addition)\n@@ -360,15 +348,13 @@ func addAt(z, x nat, i int) {\n \t}\n }\n \n-\n func max(x, y int) int {\n \tif x > y {\n \t\treturn x\n \t}\n \treturn y\n }\n \n-\n // karatsubaLen computes an approximation to the maximum k <= n such that\n // k = p<<i for a number p <= karatsubaThreshold and an i >= 0. Thus, the\n // result is the largest number that can be divided repeatedly by 2 before\n@@ -382,7 +368,6 @@ func karatsubaLen(n int) int {\n \treturn n << i\n }\n \n-\n func (z nat) mul(x, y nat) nat {\n \tm := len(x)\n \tn := len(y)\n@@ -450,7 +435,6 @@ func (z nat) mul(x, y nat) nat {\n \treturn z.norm()\n }\n \n-\n // mulRange computes the product of all the unsigned integers in the\n // range [a, b] inclusively. If a > b (empty range), the result is 1.\n func (z nat) mulRange(a, b uint64) nat {\n@@ -469,7 +453,6 @@ func (z nat) mulRange(a, b uint64) nat {\n \treturn z.mul(nat(nil).mulRange(a, m), nat(nil).mulRange(m+1, b))\n }\n \n-\n // q = (x-r)/y, with 0 <= r < y\n func (z nat) divW(x nat, y Word) (q nat, r Word) {\n \tm := len(x)\n@@ -490,7 +473,6 @@ func (z nat) divW(x nat, y Word) (q nat, r Word) {\n \treturn\n }\n \n-\n func (z nat) div(z2, u, v nat) (q, r nat) {\n \tif len(v) == 0 {\n \t\tpanic(\"division by zero\")\n@@ -518,7 +500,6 @@ func (z nat) div(z2, u, v nat) (q, r nat) {\n \treturn\n }\n \n-\n // q = (uIn-r)/v, with 0 <= r < y\n // Uses z as storage for q, and u as storage for r if possible.\n // See Knuth, Volume 2, section 4.3.1, Algorithm D.\n@@ -545,9 +526,14 @@ func (z nat) divLarge(u, uIn, v nat) (q, r nat) {\n \tu.clear()\n \n \t// D1.\n-\tshift := Word(leadingZeros(v[n-1]))\n-\tshlVW(v, v, shift)\n-\tu[len(uIn)] = shlVW(u[0:len(uIn)], uIn, shift)\n+\tshift := leadingZeros(v[n-1])\n+\tif shift > 0 {\n+\t\t// do not modify v, it may be used by another goroutine simultaneously\n+\t\tv1 := make(nat, n)\n+\t\tshlVU(v1, v, shift)\n+\t\tv = v1\n+\t}\n+\tu[len(uIn)] = shlVU(u[0:len(uIn)], uIn, shift)\n \n \t// D2.\n \tfor j := m; j >= 0; j-- {\n@@ -586,14 +572,12 @@ func (z nat) divLarge(u, uIn, v nat) (q, r nat) {\n \t}\n \n \tq = q.norm()\n-\tshrVW(u, u, shift)\n-\tshrVW(v, v, shift)\n+\tshrVU(u, u, shift)\n \tr = u.norm()\n \n \treturn q, r\n }\n \n-\n // Length of x in bits. x must be normalized.\n func (x nat) bitLen() int {\n \tif i := len(x) - 1; i >= 0 {\n@@ -602,103 +586,253 @@ func (x nat) bitLen() int {\n \treturn 0\n }\n \n+// MaxBase is the largest number base accepted for string conversions.\n+const MaxBase = 'z' - 'a' + 10 + 1 // = hexValue('z') + 1\n \n-func hexValue(ch byte) int {\n-\tvar d byte\n+\n+func hexValue(ch int) Word {\n+\td := MaxBase + 1 // illegal base\n \tswitch {\n \tcase '0' <= ch && ch <= '9':\n \t\td = ch - '0'\n-\tcase 'a' <= ch && ch <= 'f':\n+\tcase 'a' <= ch && ch <= 'z':\n \t\td = ch - 'a' + 10\n-\tcase 'A' <= ch && ch <= 'F':\n+\tcase 'A' <= ch && ch <= 'Z':\n \t\td = ch - 'A' + 10\n-\tdefault:\n-\t\treturn -1\n \t}\n-\treturn int(d)\n+\treturn Word(d)\n }\n \n-\n-// scan returns the natural number corresponding to the\n-// longest possible prefix of s representing a natural number in a\n-// given conversion base, the actual conversion base used, and the\n-// prefix length. The syntax of natural numbers follows the syntax\n-// of unsigned integer literals in Go.\n+// scan sets z to the natural number corresponding to the longest possible prefix\n+// read from r representing an unsigned integer in a given conversion base.\n+// It returns z, the actual conversion base used, and an error, if any. In the\n+// error case, the value of z is undefined. The syntax follows the syntax of\n+// unsigned integer literals in Go.\n //\n-// If the base argument is 0, the string prefix determines the actual\n-// conversion base. A prefix of ``0x'' or ``0X'' selects base 16; the\n-// ``0'' prefix selects base 8, and a ``0b'' or ``0B'' prefix selects\n-// base 2. Otherwise the selected base is 10.\n+// The base argument must be 0 or a value from 2 through MaxBase. If the base\n+// is 0, the string prefix determines the actual conversion base. A prefix of\n+// ``0x'' or ``0X'' selects base 16; the ``0'' prefix selects base 8, and a\n+// ``0b'' or ``0B'' prefix selects base 2. Otherwise the selected base is 10.\n //\n-func (z nat) scan(s string, base int) (nat, int, int) {\n+func (z nat) scan(r io.RuneScanner, base int) (nat, int, os.Error) {\n+\t// reject illegal bases\n+\tif base < 0 || base == 1 || MaxBase < base {\n+\t\treturn z, 0, os.NewError(\"illegal number base\")\n+\t}\n+\n+\t// one char look-ahead\n+\tch, _, err := r.ReadRune()\n+\tif err != nil {\n+\t\treturn z, 0, err\n+\t}\n+\n \t// determine base if necessary\n-\ti, n := 0, len(s)\n+\tb := Word(base)\n \tif base == 0 {\n-\t\tbase = 10\n-\t\tif n > 0 && s[0] == '0' {\n-\t\t\tbase, i = 8, 1\n-\t\t\tif n > 1 {\n-\t\t\t\tswitch s[1] {\n+\t\tb = 10\n+\t\tif ch == '0' {\n+\t\t\tswitch ch, _, err = r.ReadRune(); err {\n+\t\t\tcase nil:\n+\t\t\t\tb = 8\n+\t\t\t\tswitch ch {\n \t\t\t\tcase 'x', 'X':\n-\t\t\t\t\tbase, i = 16, 2\n+\t\t\t\t\tb = 16\n \t\t\t\tcase 'b', 'B':\n-\t\t\t\t\tbase, i = 2, 2\n+\t\t\t\t\tb = 2\n \t\t\t\t}\n+\t\t\t\tif b == 2 || b == 16 {\n+\t\t\t\t\tif ch, _, err = r.ReadRune(); err != nil {\n+\t\t\t\t\t\treturn z, 0, err\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tcase os.EOF:\n+\t\t\t\treturn z, 10, nil\n+\t\t\tdefault:\n+\t\t\t\treturn z, 10, err\n \t\t\t}\n \t\t}\n \t}\n \n-\t// reject illegal bases or strings consisting only of prefix\n-\tif base < 2 || 16 < base || (base != 8 && i >= n) {\n-\t\treturn z, 0, 0\n-\t}\n-\n \t// convert string\n+\t// - group as many digits d as possible together into a \"super-digit\" dd with \"super-base\" bb\n+\t// - only when bb does not fit into a word anymore, do a full number mulAddWW using bb and dd\n \tz = z.make(0)\n-\tfor ; i < n; i++ {\n-\t\td := hexValue(s[i])\n-\t\tif 0 <= d && d < base {\n-\t\t\tz = z.mulAddWW(z, Word(base), Word(d))\n+\tbb := Word(1)\n+\tdd := Word(0)\n+\tfor max := _M / b; ; {\n+\t\td := hexValue(ch)\n+\t\tif d >= b {\n+\t\t\tr.UnreadRune() // ch does not belong to number anymore\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tif bb <= max {\n+\t\t\tbb *= b\n+\t\t\tdd = dd*b + d\n \t\t} else {\n+\t\t\t// bb * b would overflow\n+\t\t\tz = z.mulAddWW(z, bb, dd)\n+\t\t\tbb = b\n+\t\t\tdd = d\n+\t\t}\n+\n+\t\tif ch, _, err = r.ReadRune(); err != nil {\n+\t\t\tif err != os.EOF {\n+\t\t\t\treturn z, int(b), err\n+\t\t\t}\n \t\t\tbreak\n \t\t}\n \t}\n \n-\treturn z.norm(), base, i\n+\tswitch {\n+\tcase bb > 1:\n+\t\t// there was at least one mantissa digit\n+\t\tz = z.mulAddWW(z, bb, dd)\n+\tcase base == 0 && b == 8:\n+\t\t// there was only the octal prefix 0 (possibly followed by digits > 7);\n+\t\t// return base 10, not 8\n+\t\treturn z, 10, nil\n+\tcase base != 0 || b != 8:\n+\t\t// there was neither a mantissa digit nor the octal prefix 0\n+\t\treturn z, int(b), os.NewError(\"syntax error scanning number\")\n+\t}\n+\n+\treturn z.norm(), int(b), nil\n }\n \n+// Character sets for string conversion.\n+const (\n+\tlowercaseDigits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n+\tuppercaseDigits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n+)\n \n-// string converts x to a string for a given base, with 2 <= base <= 16.\n-// TODO(gri) in the style of the other routines, perhaps this should take\n-//           a []byte buffer and return it\n-func (x nat) string(base int) string {\n-\tif base < 2 || 16 < base {\n-\t\tpanic(\"illegal base\")\n-\t}\n+// decimalString returns a decimal representation of x.\n+// It calls x.string with the charset \"0123456789\".\n+func (x nat) decimalString() string {\n+\treturn x.string(lowercaseDigits[0:10])\n+}\n \n-\tif len(x) == 0 {\n-\t\treturn \"0\"\n+// string converts x to a string using digits from a charset; a digit with\n+// value d is represented by charset[d]. The conversion base is determined\n+// by len(charset), which must be >= 2.\n+func (x nat) string(charset string) string {\n+\tb := Word(len(charset))\n+\n+\t// special cases\n+\tswitch {\n+\tcase b < 2 || b > 256:\n+\t\tpanic(\"illegal base\")\n+\tcase len(x) == 0:\n+\t\treturn string(charset[0])\n \t}\n \n \t// allocate buffer for conversion\n-\ti := x.bitLen()/log2(Word(base)) + 1 // +1: round up\n+\ti := x.bitLen()/log2(b) + 1 // +1: round up\n \ts := make([]byte, i)\n \n-\t// don't destroy x\n+\t// special case: power of two bases can avoid divisions completely\n+\tif b == b&-b {\n+\t\t// shift is base-b digit size in bits\n+\t\tshift := uint(trailingZeroBits(b)) // shift > 0 because b >= 2\n+\t\tmask := Word(1)<<shift - 1\n+\t\tw := x[0]\n+\t\tnbits := uint(_W) // number of unprocessed bits in w\n+\n+\t\t// convert less-significant words\n+\t\tfor k := 1; k < len(x); k++ {\n+\t\t\t// convert full digits\n+\t\t\tfor nbits >= shift {\n+\t\t\t\ti--\n+\t\t\t\ts[i] = charset[w&mask]\n+\t\t\t\tw >>= shift\n+\t\t\t\tnbits -= shift\n+\t\t\t}\n+\n+\t\t\t// convert any partial leading digit and advance to next word\n+\t\t\tif nbits == 0 {\n+\t\t\t\t// no partial digit remaining, just advance\n+\t\t\t\tw = x[k]\n+\t\t\t\tnbits = _W\n+\t\t\t} else {\n+\t\t\t\t// partial digit in current (k-1) and next (k) word\n+\t\t\t\tw |= x[k] << nbits\n+\t\t\t\ti--\n+\t\t\t\ts[i] = charset[w&mask]\n+\n+\t\t\t\t// advance\n+\t\t\t\tw = x[k] >> (shift - nbits)\n+\t\t\t\tnbits = _W - (shift - nbits)\n+\t\t\t}\n+\t\t}\n+\n+\t\t// convert digits of most-significant word (omit leading zeros)\n+\t\tfor nbits >= 0 && w != 0 {\n+\t\t\ti--\n+\t\t\ts[i] = charset[w&mask]\n+\t\t\tw >>= shift\n+\t\t\tnbits -= shift\n+\t\t}\n+\n+\t\treturn string(s[i:])\n+\t}\n+\n+\t// general case: extract groups of digits by multiprecision division\n+\n+\t// maximize ndigits where b**ndigits < 2^_W; bb (big base) is b**ndigits\n+\tbb := Word(1)\n+\tndigits := 0\n+\tfor max := Word(_M / b); bb <= max; bb *= b {\n+\t\tndigits++\n+\t}\n+\n+\t// preserve x, create local copy for use in repeated divisions\n \tq := nat(nil).set(x)\n+\tvar r Word\n \n \t// convert\n-\tfor len(q) > 0 {\n-\t\ti--\n-\t\tvar r Word\n-\t\tq, r = q.divW(q, Word(base))\n-\t\ts[i] = \"0123456789abcdef\"[r]\n+\tif b == 10 { // hard-coding for 10 here speeds this up by 1.25x\n+\t\tfor len(q) > 0 {\n+\t\t\t// extract least significant, base bb \"digit\"\n+\t\t\tq, r = q.divW(q, bb) // N.B. >82% of time is here. Optimize divW\n+\t\t\tif len(q) == 0 {\n+\t\t\t\t// skip leading zeros in most-significant group of digits\n+\t\t\t\tfor j := 0; j < ndigits && r != 0; j++ {\n+\t\t\t\t\ti--\n+\t\t\t\t\ts[i] = charset[r%10]\n+\t\t\t\t\tr /= 10\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfor j := 0; j < ndigits; j++ {\n+\t\t\t\t\ti--\n+\t\t\t\t\ts[i] = charset[r%10]\n+\t\t\t\t\tr /= 10\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\tfor len(q) > 0 {\n+\t\t\t// extract least significant group of digits\n+\t\t\tq, r = q.divW(q, bb) // N.B. >82% of time is here. Optimize divW\n+\t\t\tif len(q) == 0 {\n+\t\t\t\t// skip leading zeros in most-significant group of digits\n+\t\t\t\tfor j := 0; j < ndigits && r != 0; j++ {\n+\t\t\t\t\ti--\n+\t\t\t\t\ts[i] = charset[r%b]\n+\t\t\t\t\tr /= b\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfor j := 0; j < ndigits; j++ {\n+\t\t\t\t\ti--\n+\t\t\t\t\ts[i] = charset[r%b]\n+\t\t\t\t\tr /= b\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n \n \treturn string(s[i:])\n }\n \n-\n const deBruijn32 = 0x077CB531\n \n var deBruijn32Lookup = []byte{\n@@ -721,7 +855,7 @@ var deBruijn64Lookup = []byte{\n func trailingZeroBits(x Word) int {\n \t// x & -x leaves only the right-most bit set in the word. Let k be the\n \t// index of that bit. Since only a single bit is set, the value is two\n-\t// to the power of k. Multipling by a power of two is equivalent to\n+\t// to the power of k. Multiplying by a power of two is equivalent to\n \t// left shifting, in this case by k bits.  The de Bruijn constant is\n \t// such that all six bit, consecutive substrings are distinct.\n \t// Therefore, if we have a left shifted version of this constant we can\n@@ -739,7 +873,6 @@ func trailingZeroBits(x Word) int {\n \treturn 0\n }\n \n-\n // z = x << s\n func (z nat) shl(x nat, s uint) nat {\n \tm := len(x)\n@@ -750,13 +883,12 @@ func (z nat) shl(x nat, s uint) nat {\n \n \tn := m + int(s/_W)\n \tz = z.make(n + 1)\n-\tz[n] = shlVW(z[n-m:n], x, Word(s%_W))\n+\tz[n] = shlVU(z[n-m:n], x, s%_W)\n \tz[0 : n-m].clear()\n \n \treturn z.norm()\n }\n \n-\n // z = x >> s\n func (z nat) shr(x nat, s uint) nat {\n \tm := len(x)\n@@ -767,11 +899,45 @@ func (z nat) shr(x nat, s uint) nat {\n \t// n > 0\n \n \tz = z.make(n)\n-\tshrVW(z, x[m-n:], Word(s%_W))\n+\tshrVU(z, x[m-n:], s%_W)\n \n \treturn z.norm()\n }\n \n+func (z nat) setBit(x nat, i uint, b uint) nat {\n+\tj := int(i / _W)\n+\tm := Word(1) << (i % _W)\n+\tn := len(x)\n+\tswitch b {\n+\tcase 0:\n+\t\tz = z.make(n)\n+\t\tcopy(z, x)\n+\t\tif j >= n {\n+\t\t\t// no need to grow\n+\t\t\treturn z\n+\t\t}\n+\t\tz[j] &^= m\n+\t\treturn z.norm()\n+\tcase 1:\n+\t\tif j >= n {\n+\t\t\tn = j + 1\n+\t\t}\n+\t\tz = z.make(n)\n+\t\tcopy(z, x)\n+\t\tz[j] |= m\n+\t\t// no need to normalize\n+\t\treturn z\n+\t}\n+\tpanic(\"set bit is not 0 or 1\")\n+}\n+\n+func (z nat) bit(i uint) uint {\n+\tj := int(i / _W)\n+\tif j >= len(z) {\n+\t\treturn 0\n+\t}\n+\treturn uint(z[j] >> (i % _W) & 1)\n+}\n \n func (z nat) and(x, y nat) nat {\n \tm := len(x)\n@@ -789,7 +955,6 @@ func (z nat) and(x, y nat) nat {\n \treturn z.norm()\n }\n \n-\n func (z nat) andNot(x, y nat) nat {\n \tm := len(x)\n \tn := len(y)\n@@ -807,7 +972,6 @@ func (z nat) andNot(x, y nat) nat {\n \treturn z.norm()\n }\n \n-\n func (z nat) or(x, y nat) nat {\n \tm := len(x)\n \tn := len(y)\n@@ -827,7 +991,6 @@ func (z nat) or(x, y nat) nat {\n \treturn z.norm()\n }\n \n-\n func (z nat) xor(x, y nat) nat {\n \tm := len(x)\n \tn := len(y)\n@@ -847,10 +1010,10 @@ func (z nat) xor(x, y nat) nat {\n \treturn z.norm()\n }\n \n-\n // greaterThan returns true iff (x1<<_W + x2) > (y1<<_W + y2)\n-func greaterThan(x1, x2, y1, y2 Word) bool { return x1 > y1 || x1 == y1 && x2 > y2 }\n-\n+func greaterThan(x1, x2, y1, y2 Word) bool {\n+\treturn x1 > y1 || x1 == y1 && x2 > y2\n+}\n \n // modW returns x % d.\n func (x nat) modW(d Word) (r Word) {\n@@ -860,30 +1023,29 @@ func (x nat) modW(d Word) (r Word) {\n \treturn divWVW(q, 0, x, d)\n }\n \n-\n-// powersOfTwoDecompose finds q and k such that q * 1<<k = n and q is odd.\n-func (n nat) powersOfTwoDecompose() (q nat, k Word) {\n-\tif len(n) == 0 {\n-\t\treturn n, 0\n+// powersOfTwoDecompose finds q and k with x = q * 1<<k and q is odd, or q and k are 0.\n+func (x nat) powersOfTwoDecompose() (q nat, k int) {\n+\tif len(x) == 0 {\n+\t\treturn x, 0\n \t}\n \n-\tzeroWords := 0\n-\tfor n[zeroWords] == 0 {\n-\t\tzeroWords++\n+\t// One of the words must be non-zero by definition,\n+\t// so this loop will terminate with i < len(x), and\n+\t// i is the number of 0 words.\n+\ti := 0\n+\tfor x[i] == 0 {\n+\t\ti++\n \t}\n-\t// One of the words must be non-zero by invariant, therefore\n-\t// zeroWords < len(n).\n-\tx := trailingZeroBits(n[zeroWords])\n+\tn := trailingZeroBits(x[i]) // x[i] != 0\n \n-\tq = q.make(len(n) - zeroWords)\n-\tshrVW(q, n[zeroWords:], Word(x))\n-\tq = q.norm()\n+\tq = make(nat, len(x)-i)\n+\tshrVU(q, x[i:], uint(n))\n \n-\tk = Word(_W*zeroWords + x)\n+\tq = q.norm()\n+\tk = i*_W + n\n \treturn\n }\n \n-\n // random creates a random integer in [0..limit), using the space in z if\n // possible. n is the bit length of limit.\n func (z nat) random(rand *rand.Rand, limit nat, n int) nat {\n@@ -914,7 +1076,6 @@ func (z nat) random(rand *rand.Rand, limit nat, n int) nat {\n \treturn z.norm()\n }\n \n-\n // If m != nil, expNN calculates x**y mod m. Otherwise it calculates x**y. It\n // reuses the storage of z if possible.\n func (z nat) expNN(x, y, m nat) nat {\n@@ -983,7 +1144,6 @@ func (z nat) expNN(x, y, m nat) nat {\n \treturn z\n }\n \n-\n // probablyPrime performs reps Miller-Rabin tests to check whether n is prime.\n // If it returns true, n is prime with probability 1 - 1/4^reps.\n // If it returns false, n is not prime.\n@@ -1050,7 +1210,7 @@ NextRandom:\n \t\tif y.cmp(natOne) == 0 || y.cmp(nm1) == 0 {\n \t\t\tcontinue\n \t\t}\n-\t\tfor j := Word(1); j < k; j++ {\n+\t\tfor j := 1; j < k; j++ {\n \t\t\ty = y.mul(y, y)\n \t\t\tquotient, y = quotient.div(y, y, n)\n \t\t\tif y.cmp(nm1) == 0 {\n@@ -1066,7 +1226,6 @@ NextRandom:\n \treturn true\n }\n \n-\n // bytes writes the value of z into buf using big-endian encoding.\n // len(buf) must be >= len(z)*_S. The value of z is encoded in the\n // slice buf[i:]. The number i of unused bytes at the beginning of\n@@ -1088,7 +1247,6 @@ func (z nat) bytes(buf []byte) (i int) {\n \treturn\n }\n \n-\n // setBytes interprets buf as the bytes of a big-endian unsigned\n // integer, sets z to that value, and returns z.\n func (z nat) setBytes(buf []byte) nat {"}, {"sha": "71d0860878cb8753ffcc06fb8e0b9a0a437cd2ab", "filename": "libgo/go/big/nat_test.go", "status": "modified", "additions": 357, "deletions": 46, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Fnat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Fnat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fnat_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -4,7 +4,12 @@\n \n package big\n \n-import \"testing\"\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n \n var cmpTests = []struct {\n \tx, y nat\n@@ -26,7 +31,6 @@ var cmpTests = []struct {\n \t{nat{34986, 41, 105, 1957}, nat{56, 7458, 104, 1957}, 1},\n }\n \n-\n func TestCmp(t *testing.T) {\n \tfor i, a := range cmpTests {\n \t\tr := a.x.cmp(a.y)\n@@ -36,13 +40,11 @@ func TestCmp(t *testing.T) {\n \t}\n }\n \n-\n type funNN func(z, x, y nat) nat\n type argNN struct {\n \tz, x, y nat\n }\n \n-\n var sumNN = []argNN{\n \t{},\n \t{nat{1}, nil, nat{1}},\n@@ -52,7 +54,6 @@ var sumNN = []argNN{\n \t{nat{0, 0, 0, 1}, nat{0, 0, _M}, nat{0, 0, 1}},\n }\n \n-\n var prodNN = []argNN{\n \t{},\n \t{nil, nil, nil},\n@@ -64,7 +65,6 @@ var prodNN = []argNN{\n \t{nat{4, 11, 20, 30, 20, 11, 4}, nat{1, 2, 3, 4}, nat{4, 3, 2, 1}},\n }\n \n-\n func TestSet(t *testing.T) {\n \tfor _, a := range sumNN {\n \t\tz := nat(nil).set(a.z)\n@@ -74,15 +74,13 @@ func TestSet(t *testing.T) {\n \t}\n }\n \n-\n func testFunNN(t *testing.T, msg string, f funNN, a argNN) {\n \tz := f(nil, a.x, a.y)\n \tif z.cmp(a.z) != 0 {\n \t\tt.Errorf(\"%s%+v\\n\\tgot z = %v; want %v\", msg, a, z, a.z)\n \t}\n }\n \n-\n func TestFunNN(t *testing.T) {\n \tfor _, a := range sumNN {\n \t\targ := a\n@@ -107,7 +105,6 @@ func TestFunNN(t *testing.T) {\n \t}\n }\n \n-\n var mulRangesN = []struct {\n \ta, b uint64\n \tprod string\n@@ -130,17 +127,15 @@ var mulRangesN = []struct {\n \t},\n }\n \n-\n func TestMulRangeN(t *testing.T) {\n \tfor i, r := range mulRangesN {\n-\t\tprod := nat(nil).mulRange(r.a, r.b).string(10)\n+\t\tprod := nat(nil).mulRange(r.a, r.b).decimalString()\n \t\tif prod != r.prod {\n \t\t\tt.Errorf(\"#%d: got %s; want %s\", i, prod, r.prod)\n \t\t}\n \t}\n }\n \n-\n var mulArg, mulTmp nat\n \n func init() {\n@@ -151,54 +146,383 @@ func init() {\n \t}\n }\n \n-\n func benchmarkMulLoad() {\n \tfor j := 1; j <= 10; j++ {\n \t\tx := mulArg[0 : j*100]\n \t\tmulTmp.mul(x, x)\n \t}\n }\n \n-\n func BenchmarkMul(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tbenchmarkMulLoad()\n \t}\n }\n \n+func toString(x nat, charset string) string {\n+\tbase := len(charset)\n \n-var tab = []struct {\n-\tx nat\n-\tb int\n-\ts string\n-}{\n-\t{nil, 10, \"0\"},\n-\t{nat{1}, 10, \"1\"},\n-\t{nat{10}, 10, \"10\"},\n-\t{nat{1234567890}, 10, \"1234567890\"},\n+\t// special cases\n+\tswitch {\n+\tcase base < 2:\n+\t\tpanic(\"illegal base\")\n+\tcase len(x) == 0:\n+\t\treturn string(charset[0])\n+\t}\n+\n+\t// allocate buffer for conversion\n+\ti := x.bitLen()/log2(Word(base)) + 1 // +1: round up\n+\ts := make([]byte, i)\n+\n+\t// don't destroy x\n+\tq := nat(nil).set(x)\n+\n+\t// convert\n+\tfor len(q) > 0 {\n+\t\ti--\n+\t\tvar r Word\n+\t\tq, r = q.divW(q, Word(base))\n+\t\ts[i] = charset[r]\n+\t}\n+\n+\treturn string(s[i:])\n }\n \n+var strTests = []struct {\n+\tx nat    // nat value to be converted\n+\tc string // conversion charset\n+\ts string // expected result\n+}{\n+\t{nil, \"01\", \"0\"},\n+\t{nat{1}, \"01\", \"1\"},\n+\t{nat{0xc5}, \"01\", \"11000101\"},\n+\t{nat{03271}, lowercaseDigits[0:8], \"3271\"},\n+\t{nat{10}, lowercaseDigits[0:10], \"10\"},\n+\t{nat{1234567890}, uppercaseDigits[0:10], \"1234567890\"},\n+\t{nat{0xdeadbeef}, lowercaseDigits[0:16], \"deadbeef\"},\n+\t{nat{0xdeadbeef}, uppercaseDigits[0:16], \"DEADBEEF\"},\n+\t{nat{0x229be7}, lowercaseDigits[0:17], \"1a2b3c\"},\n+\t{nat{0x309663e6}, uppercaseDigits[0:32], \"O9COV6\"},\n+}\n \n func TestString(t *testing.T) {\n-\tfor _, a := range tab {\n-\t\ts := a.x.string(a.b)\n+\tfor _, a := range strTests {\n+\t\ts := a.x.string(a.c)\n \t\tif s != a.s {\n \t\t\tt.Errorf(\"string%+v\\n\\tgot s = %s; want %s\", a, s, a.s)\n \t\t}\n \n-\t\tx, b, n := nat(nil).scan(a.s, a.b)\n+\t\tx, b, err := nat(nil).scan(strings.NewReader(a.s), len(a.c))\n+\t\tif x.cmp(a.x) != 0 {\n+\t\t\tt.Errorf(\"scan%+v\\n\\tgot z = %v; want %v\", a, x, a.x)\n+\t\t}\n+\t\tif b != len(a.c) {\n+\t\t\tt.Errorf(\"scan%+v\\n\\tgot b = %d; want %d\", a, b, len(a.c))\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"scan%+v\\n\\tgot error = %s\", a, err)\n+\t\t}\n+\t}\n+}\n+\n+var natScanTests = []struct {\n+\ts    string // string to be scanned\n+\tbase int    // input base\n+\tx    nat    // expected nat\n+\tb    int    // expected base\n+\tok   bool   // expected success\n+\tnext int    // next character (or 0, if at EOF)\n+}{\n+\t// error: illegal base\n+\t{base: -1},\n+\t{base: 1},\n+\t{base: 37},\n+\n+\t// error: no mantissa\n+\t{},\n+\t{s: \"?\"},\n+\t{base: 10},\n+\t{base: 36},\n+\t{s: \"?\", base: 10},\n+\t{s: \"0x\"},\n+\t{s: \"345\", base: 2},\n+\n+\t// no errors\n+\t{\"0\", 0, nil, 10, true, 0},\n+\t{\"0\", 10, nil, 10, true, 0},\n+\t{\"0\", 36, nil, 36, true, 0},\n+\t{\"1\", 0, nat{1}, 10, true, 0},\n+\t{\"1\", 10, nat{1}, 10, true, 0},\n+\t{\"0 \", 0, nil, 10, true, ' '},\n+\t{\"08\", 0, nil, 10, true, '8'},\n+\t{\"018\", 0, nat{1}, 8, true, '8'},\n+\t{\"0b1\", 0, nat{1}, 2, true, 0},\n+\t{\"0b11000101\", 0, nat{0xc5}, 2, true, 0},\n+\t{\"03271\", 0, nat{03271}, 8, true, 0},\n+\t{\"10ab\", 0, nat{10}, 10, true, 'a'},\n+\t{\"1234567890\", 0, nat{1234567890}, 10, true, 0},\n+\t{\"xyz\", 36, nat{(33*36+34)*36 + 35}, 36, true, 0},\n+\t{\"xyz?\", 36, nat{(33*36+34)*36 + 35}, 36, true, '?'},\n+\t{\"0x\", 16, nil, 16, true, 'x'},\n+\t{\"0xdeadbeef\", 0, nat{0xdeadbeef}, 16, true, 0},\n+\t{\"0XDEADBEEF\", 0, nat{0xdeadbeef}, 16, true, 0},\n+}\n+\n+func TestScanBase(t *testing.T) {\n+\tfor _, a := range natScanTests {\n+\t\tr := strings.NewReader(a.s)\n+\t\tx, b, err := nat(nil).scan(r, a.base)\n+\t\tif err == nil && !a.ok {\n+\t\t\tt.Errorf(\"scan%+v\\n\\texpected error\", a)\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tif a.ok {\n+\t\t\t\tt.Errorf(\"scan%+v\\n\\tgot error = %s\", a, err)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n \t\tif x.cmp(a.x) != 0 {\n \t\t\tt.Errorf(\"scan%+v\\n\\tgot z = %v; want %v\", a, x, a.x)\n \t\t}\n \t\tif b != a.b {\n-\t\t\tt.Errorf(\"scan%+v\\n\\tgot b = %d; want %d\", a, b, a.b)\n+\t\t\tt.Errorf(\"scan%+v\\n\\tgot b = %d; want %d\", a, b, a.base)\n+\t\t}\n+\t\tnext, _, err := r.ReadRune()\n+\t\tif err == os.EOF {\n+\t\t\tnext = 0\n+\t\t\terr = nil\n \t\t}\n-\t\tif n != len(a.s) {\n-\t\t\tt.Errorf(\"scan%+v\\n\\tgot n = %d; want %d\", a, n, len(a.s))\n+\t\tif err == nil && next != a.next {\n+\t\t\tt.Errorf(\"scan%+v\\n\\tgot next = %q; want %q\", a, next, a.next)\n \t\t}\n \t}\n }\n \n+var pi = \"3\" +\n+\t\"14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651\" +\n+\t\"32823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461\" +\n+\t\"28475648233786783165271201909145648566923460348610454326648213393607260249141273724587006606315588174881520920\" +\n+\t\"96282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179\" +\n+\t\"31051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798\" +\n+\t\"60943702770539217176293176752384674818467669405132000568127145263560827785771342757789609173637178721468440901\" +\n+\t\"22495343014654958537105079227968925892354201995611212902196086403441815981362977477130996051870721134999999837\" +\n+\t\"29780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083\" +\n+\t\"81420617177669147303598253490428755468731159562863882353787593751957781857780532171226806613001927876611195909\" +\n+\t\"21642019893809525720106548586327886593615338182796823030195203530185296899577362259941389124972177528347913151\" +\n+\t\"55748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035\" +\n+\t\"63707660104710181942955596198946767837449448255379774726847104047534646208046684259069491293313677028989152104\" +\n+\t\"75216205696602405803815019351125338243003558764024749647326391419927260426992279678235478163600934172164121992\" +\n+\t\"45863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818\" +\n+\t\"34797753566369807426542527862551818417574672890977772793800081647060016145249192173217214772350141441973568548\" +\n+\t\"16136115735255213347574184946843852332390739414333454776241686251898356948556209921922218427255025425688767179\" +\n+\t\"04946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886\" +\n+\t\"26945604241965285022210661186306744278622039194945047123713786960956364371917287467764657573962413890865832645\" +\n+\t\"99581339047802759009946576407895126946839835259570982582262052248940772671947826848260147699090264013639443745\" +\n+\t\"53050682034962524517493996514314298091906592509372216964615157098583874105978859597729754989301617539284681382\" +\n+\t\"68683868942774155991855925245953959431049972524680845987273644695848653836736222626099124608051243884390451244\" +\n+\t\"13654976278079771569143599770012961608944169486855584840635342207222582848864815845602850601684273945226746767\" +\n+\t\"88952521385225499546667278239864565961163548862305774564980355936345681743241125150760694794510965960940252288\" +\n+\t\"79710893145669136867228748940560101503308617928680920874760917824938589009714909675985261365549781893129784821\" +\n+\t\"68299894872265880485756401427047755513237964145152374623436454285844479526586782105114135473573952311342716610\" +\n+\t\"21359695362314429524849371871101457654035902799344037420073105785390621983874478084784896833214457138687519435\" +\n+\t\"06430218453191048481005370614680674919278191197939952061419663428754440643745123718192179998391015919561814675\" +\n+\t\"14269123974894090718649423196156794520809514655022523160388193014209376213785595663893778708303906979207734672\" +\n+\t\"21825625996615014215030680384477345492026054146659252014974428507325186660021324340881907104863317346496514539\" +\n+\t\"05796268561005508106658796998163574736384052571459102897064140110971206280439039759515677157700420337869936007\" +\n+\t\"23055876317635942187312514712053292819182618612586732157919841484882916447060957527069572209175671167229109816\" +\n+\t\"90915280173506712748583222871835209353965725121083579151369882091444210067510334671103141267111369908658516398\" +\n+\t\"31501970165151168517143765761835155650884909989859982387345528331635507647918535893226185489632132933089857064\" +\n+\t\"20467525907091548141654985946163718027098199430992448895757128289059232332609729971208443357326548938239119325\" +\n+\t\"97463667305836041428138830320382490375898524374417029132765618093773444030707469211201913020330380197621101100\" +\n+\t\"44929321516084244485963766983895228684783123552658213144957685726243344189303968642624341077322697802807318915\" +\n+\t\"44110104468232527162010526522721116603966655730925471105578537634668206531098965269186205647693125705863566201\" +\n+\t\"85581007293606598764861179104533488503461136576867532494416680396265797877185560845529654126654085306143444318\" +\n+\t\"58676975145661406800700237877659134401712749470420562230538994561314071127000407854733269939081454664645880797\" +\n+\t\"27082668306343285878569830523580893306575740679545716377525420211495576158140025012622859413021647155097925923\" +\n+\t\"09907965473761255176567513575178296664547791745011299614890304639947132962107340437518957359614589019389713111\" +\n+\t\"79042978285647503203198691514028708085990480109412147221317947647772622414254854540332157185306142288137585043\" +\n+\t\"06332175182979866223717215916077166925474873898665494945011465406284336639379003976926567214638530673609657120\" +\n+\t\"91807638327166416274888800786925602902284721040317211860820419000422966171196377921337575114959501566049631862\" +\n+\t\"94726547364252308177036751590673502350728354056704038674351362222477158915049530984448933309634087807693259939\" +\n+\t\"78054193414473774418426312986080998886874132604721569516239658645730216315981931951673538129741677294786724229\" +\n+\t\"24654366800980676928238280689964004824354037014163149658979409243237896907069779422362508221688957383798623001\" +\n+\t\"59377647165122893578601588161755782973523344604281512627203734314653197777416031990665541876397929334419521541\" +\n+\t\"34189948544473456738316249934191318148092777710386387734317720754565453220777092120190516609628049092636019759\" +\n+\t\"88281613323166636528619326686336062735676303544776280350450777235547105859548702790814356240145171806246436267\" +\n+\t\"94561275318134078330336254232783944975382437205835311477119926063813346776879695970309833913077109870408591337\"\n+\n+// Test case for BenchmarkScanPi.\n+func TestScanPi(t *testing.T) {\n+\tvar x nat\n+\tz, _, err := x.scan(strings.NewReader(pi), 10)\n+\tif err != nil {\n+\t\tt.Errorf(\"scanning pi: %s\", err)\n+\t}\n+\tif s := z.decimalString(); s != pi {\n+\t\tt.Errorf(\"scanning pi: got %s\", s)\n+\t}\n+}\n+\n+func BenchmarkScanPi(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tvar x nat\n+\t\tx.scan(strings.NewReader(pi), 10)\n+\t}\n+}\n+\n+const (\n+\t// 314**271\n+\t// base  2: 2249 digits\n+\t// base  8:  751 digits\n+\t// base 10:  678 digits\n+\t// base 16:  563 digits\n+\tshortBase     = 314\n+\tshortExponent = 271\n+\n+\t// 3141**2178\n+\t// base  2: 31577 digits\n+\t// base  8: 10527 digits\n+\t// base 10:  9507 digits\n+\t// base 16:  7895 digits\n+\tmediumBase     = 3141\n+\tmediumExponent = 2718\n+\n+\t// 3141**2178\n+\t// base  2: 406078 digits\n+\t// base  8: 135360 digits\n+\t// base 10: 122243 digits\n+\t// base 16: 101521 digits\n+\tlongBase     = 31415\n+\tlongExponent = 27182\n+)\n+\n+func BenchmarkScanShort2(b *testing.B) {\n+\tScanHelper(b, 2, shortBase, shortExponent)\n+}\n+\n+func BenchmarkScanShort8(b *testing.B) {\n+\tScanHelper(b, 8, shortBase, shortExponent)\n+}\n+\n+func BenchmarkScanSort10(b *testing.B) {\n+\tScanHelper(b, 10, shortBase, shortExponent)\n+}\n+\n+func BenchmarkScanShort16(b *testing.B) {\n+\tScanHelper(b, 16, shortBase, shortExponent)\n+}\n+\n+func BenchmarkScanMedium2(b *testing.B) {\n+\tScanHelper(b, 2, mediumBase, mediumExponent)\n+}\n+\n+func BenchmarkScanMedium8(b *testing.B) {\n+\tScanHelper(b, 8, mediumBase, mediumExponent)\n+}\n+\n+func BenchmarkScanMedium10(b *testing.B) {\n+\tScanHelper(b, 10, mediumBase, mediumExponent)\n+}\n+\n+func BenchmarkScanMedium16(b *testing.B) {\n+\tScanHelper(b, 16, mediumBase, mediumExponent)\n+}\n+\n+func BenchmarkScanLong2(b *testing.B) {\n+\tScanHelper(b, 2, longBase, longExponent)\n+}\n+\n+func BenchmarkScanLong8(b *testing.B) {\n+\tScanHelper(b, 8, longBase, longExponent)\n+}\n+\n+func BenchmarkScanLong10(b *testing.B) {\n+\tScanHelper(b, 10, longBase, longExponent)\n+}\n+\n+func BenchmarkScanLong16(b *testing.B) {\n+\tScanHelper(b, 16, longBase, longExponent)\n+}\n+\n+func ScanHelper(b *testing.B, base int, xv, yv Word) {\n+\tb.StopTimer()\n+\tvar x, y, z nat\n+\tx = x.setWord(xv)\n+\ty = y.setWord(yv)\n+\tz = z.expNN(x, y, nil)\n+\n+\tvar s string\n+\ts = z.string(lowercaseDigits[0:base])\n+\tif t := toString(z, lowercaseDigits[0:base]); t != s {\n+\t\tpanic(fmt.Sprintf(\"scanning: got %s; want %s\", s, t))\n+\t}\n+\tb.StartTimer()\n+\n+\tfor i := 0; i < b.N; i++ {\n+\t\tx.scan(strings.NewReader(s), base)\n+\t}\n+}\n+\n+func BenchmarkStringShort2(b *testing.B) {\n+\tStringHelper(b, 2, shortBase, shortExponent)\n+}\n+\n+func BenchmarkStringShort8(b *testing.B) {\n+\tStringHelper(b, 8, shortBase, shortExponent)\n+}\n+\n+func BenchmarkStringShort10(b *testing.B) {\n+\tStringHelper(b, 10, shortBase, shortExponent)\n+}\n+\n+func BenchmarkStringShort16(b *testing.B) {\n+\tStringHelper(b, 16, shortBase, shortExponent)\n+}\n+\n+func BenchmarkStringMedium2(b *testing.B) {\n+\tStringHelper(b, 2, mediumBase, mediumExponent)\n+}\n+\n+func BenchmarkStringMedium8(b *testing.B) {\n+\tStringHelper(b, 8, mediumBase, mediumExponent)\n+}\n+\n+func BenchmarkStringMedium10(b *testing.B) {\n+\tStringHelper(b, 10, mediumBase, mediumExponent)\n+}\n+\n+func BenchmarkStringMedium16(b *testing.B) {\n+\tStringHelper(b, 16, mediumBase, mediumExponent)\n+}\n+\n+func BenchmarkStringLong2(b *testing.B) {\n+\tStringHelper(b, 2, longBase, longExponent)\n+}\n+\n+func BenchmarkStringLong8(b *testing.B) {\n+\tStringHelper(b, 8, longBase, longExponent)\n+}\n+\n+func BenchmarkStringLong10(b *testing.B) {\n+\tStringHelper(b, 10, longBase, longExponent)\n+}\n+\n+func BenchmarkStringLong16(b *testing.B) {\n+\tStringHelper(b, 16, longBase, longExponent)\n+}\n+\n+func StringHelper(b *testing.B, base int, xv, yv Word) {\n+\tb.StopTimer()\n+\tvar x, y, z nat\n+\tx = x.setWord(xv)\n+\ty = y.setWord(yv)\n+\tz = z.expNN(x, y, nil)\n+\tb.StartTimer()\n+\n+\tfor i := 0; i < b.N; i++ {\n+\t\tz.string(lowercaseDigits[0:base])\n+\t}\n+}\n \n func TestLeadingZeros(t *testing.T) {\n \tvar x Word = _B >> 1\n@@ -210,14 +534,12 @@ func TestLeadingZeros(t *testing.T) {\n \t}\n }\n \n-\n type shiftTest struct {\n \tin    nat\n \tshift uint\n \tout   nat\n }\n \n-\n var leftShiftTests = []shiftTest{\n \t{nil, 0, nil},\n \t{nil, 1, nil},\n@@ -227,7 +549,6 @@ var leftShiftTests = []shiftTest{\n \t{nat{1 << (_W - 1), 0}, 1, nat{0, 1}},\n }\n \n-\n func TestShiftLeft(t *testing.T) {\n \tfor i, test := range leftShiftTests {\n \t\tvar z nat\n@@ -241,7 +562,6 @@ func TestShiftLeft(t *testing.T) {\n \t}\n }\n \n-\n var rightShiftTests = []shiftTest{\n \t{nil, 0, nil},\n \t{nil, 1, nil},\n@@ -252,7 +572,6 @@ var rightShiftTests = []shiftTest{\n \t{nat{2, 1, 1}, 1, nat{1<<(_W-1) + 1, 1 << (_W - 1)}},\n }\n \n-\n func TestShiftRight(t *testing.T) {\n \tfor i, test := range rightShiftTests {\n \t\tvar z nat\n@@ -266,24 +585,20 @@ func TestShiftRight(t *testing.T) {\n \t}\n }\n \n-\n type modWTest struct {\n \tin       string\n \tdividend string\n \tout      string\n }\n \n-\n var modWTests32 = []modWTest{\n \t{\"23492635982634928349238759823742\", \"252341\", \"220170\"},\n }\n \n-\n var modWTests64 = []modWTest{\n \t{\"6527895462947293856291561095690465243862946\", \"524326975699234\", \"375066989628668\"},\n }\n \n-\n func runModWTests(t *testing.T, tests []modWTest) {\n \tfor i, test := range tests {\n \t\tin, _ := new(Int).SetString(test.in, 10)\n@@ -297,7 +612,6 @@ func runModWTests(t *testing.T, tests []modWTest) {\n \t}\n }\n \n-\n func TestModW(t *testing.T) {\n \tif _W >= 32 {\n \t\trunModWTests(t, modWTests32)\n@@ -307,7 +621,6 @@ func TestModW(t *testing.T) {\n \t}\n }\n \n-\n func TestTrailingZeroBits(t *testing.T) {\n \tvar x Word\n \tx--\n@@ -319,7 +632,6 @@ func TestTrailingZeroBits(t *testing.T) {\n \t}\n }\n \n-\n var expNNTests = []struct {\n \tx, y, m string\n \tout     string\n@@ -337,17 +649,16 @@ var expNNTests = []struct {\n \t},\n }\n \n-\n func TestExpNN(t *testing.T) {\n \tfor i, test := range expNNTests {\n-\t\tx, _, _ := nat(nil).scan(test.x, 0)\n-\t\ty, _, _ := nat(nil).scan(test.y, 0)\n-\t\tout, _, _ := nat(nil).scan(test.out, 0)\n+\t\tx, _, _ := nat(nil).scan(strings.NewReader(test.x), 0)\n+\t\ty, _, _ := nat(nil).scan(strings.NewReader(test.y), 0)\n+\t\tout, _, _ := nat(nil).scan(strings.NewReader(test.out), 0)\n \n \t\tvar m nat\n \n \t\tif len(test.m) > 0 {\n-\t\t\tm, _, _ = nat(nil).scan(test.m, 0)\n+\t\t\tm, _, _ = nat(nil).scan(strings.NewReader(test.m), 0)\n \t\t}\n \n \t\tz := nat(nil).expNN(x, y, m)"}, {"sha": "327b9bd9ca72665092dc62634c26428d89065360", "filename": "libgo/go/big/rat.go", "status": "modified", "additions": 76, "deletions": 31, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Frat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Frat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Frat.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -6,7 +6,12 @@\n \n package big\n \n-import \"strings\"\n+import (\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"strings\"\n+)\n \n // A Rat represents a quotient a/b of arbitrary precision. The zero value for\n // a Rat, 0/0, is not a legal Rat.\n@@ -15,13 +20,11 @@ type Rat struct {\n \tb nat\n }\n \n-\n // NewRat creates a new Rat with numerator a and denominator b.\n func NewRat(a, b int64) *Rat {\n \treturn new(Rat).SetFrac64(a, b)\n }\n \n-\n // SetFrac sets z to a/b and returns z.\n func (z *Rat) SetFrac(a, b *Int) *Rat {\n \tz.a.Set(a)\n@@ -30,7 +33,6 @@ func (z *Rat) SetFrac(a, b *Int) *Rat {\n \treturn z.norm()\n }\n \n-\n // SetFrac64 sets z to a/b and returns z.\n func (z *Rat) SetFrac64(a, b int64) *Rat {\n \tz.a.SetInt64(a)\n@@ -42,23 +44,20 @@ func (z *Rat) SetFrac64(a, b int64) *Rat {\n \treturn z.norm()\n }\n \n-\n // SetInt sets z to x (by making a copy of x) and returns z.\n func (z *Rat) SetInt(x *Int) *Rat {\n \tz.a.Set(x)\n \tz.b = z.b.setWord(1)\n \treturn z\n }\n \n-\n // SetInt64 sets z to x and returns z.\n func (z *Rat) SetInt64(x int64) *Rat {\n \tz.a.SetInt64(x)\n \tz.b = z.b.setWord(1)\n \treturn z\n }\n \n-\n // Sign returns:\n //\n //\t-1 if x <  0\n@@ -69,29 +68,25 @@ func (x *Rat) Sign() int {\n \treturn x.a.Sign()\n }\n \n-\n // IsInt returns true if the denominator of x is 1.\n func (x *Rat) IsInt() bool {\n \treturn len(x.b) == 1 && x.b[0] == 1\n }\n \n-\n // Num returns the numerator of z; it may be <= 0.\n // The result is a reference to z's numerator; it\n // may change if a new value is assigned to z.\n func (z *Rat) Num() *Int {\n \treturn &z.a\n }\n \n-\n-// Demom returns the denominator of z; it is always > 0.\n+// Denom returns the denominator of z; it is always > 0.\n // The result is a reference to z's denominator; it\n // may change if a new value is assigned to z.\n func (z *Rat) Denom() *Int {\n \treturn &Int{false, z.b}\n }\n \n-\n func gcd(x, y nat) nat {\n \t// Euclidean algorithm.\n \tvar a, b nat\n@@ -106,7 +101,6 @@ func gcd(x, y nat) nat {\n \treturn a\n }\n \n-\n func (z *Rat) norm() *Rat {\n \tf := gcd(z.a.abs, z.b)\n \tif len(z.a.abs) == 0 {\n@@ -122,15 +116,13 @@ func (z *Rat) norm() *Rat {\n \treturn z\n }\n \n-\n func mulNat(x *Int, y nat) *Int {\n \tvar z Int\n \tz.abs = z.abs.mul(x.abs, y)\n \tz.neg = len(z.abs) > 0 && x.neg\n \treturn &z\n }\n \n-\n // Cmp compares x and y and returns:\n //\n //   -1 if x <  y\n@@ -141,15 +133,13 @@ func (x *Rat) Cmp(y *Rat) (r int) {\n \treturn mulNat(&x.a, y.b).Cmp(mulNat(&y.a, x.b))\n }\n \n-\n // Abs sets z to |x| (the absolute value of x) and returns z.\n func (z *Rat) Abs(x *Rat) *Rat {\n \tz.a.Abs(&x.a)\n \tz.b = z.b.set(x.b)\n \treturn z\n }\n \n-\n // Add sets z to the sum x+y and returns z.\n func (z *Rat) Add(x, y *Rat) *Rat {\n \ta1 := mulNat(&x.a, y.b)\n@@ -159,7 +149,6 @@ func (z *Rat) Add(x, y *Rat) *Rat {\n \treturn z.norm()\n }\n \n-\n // Sub sets z to the difference x-y and returns z.\n func (z *Rat) Sub(x, y *Rat) *Rat {\n \ta1 := mulNat(&x.a, y.b)\n@@ -169,15 +158,13 @@ func (z *Rat) Sub(x, y *Rat) *Rat {\n \treturn z.norm()\n }\n \n-\n // Mul sets z to the product x*y and returns z.\n func (z *Rat) Mul(x, y *Rat) *Rat {\n \tz.a.Mul(&x.a, &y.a)\n \tz.b = z.b.mul(x.b, y.b)\n \treturn z.norm()\n }\n \n-\n // Quo sets z to the quotient x/y and returns z.\n // If y == 0, a division-by-zero run-time panic occurs.\n func (z *Rat) Quo(x, y *Rat) *Rat {\n@@ -192,22 +179,39 @@ func (z *Rat) Quo(x, y *Rat) *Rat {\n \treturn z.norm()\n }\n \n-\n // Neg sets z to -x (by making a copy of x if necessary) and returns z.\n func (z *Rat) Neg(x *Rat) *Rat {\n \tz.a.Neg(&x.a)\n \tz.b = z.b.set(x.b)\n \treturn z\n }\n \n-\n // Set sets z to x (by making a copy of x if necessary) and returns z.\n func (z *Rat) Set(x *Rat) *Rat {\n \tz.a.Set(&x.a)\n \tz.b = z.b.set(x.b)\n \treturn z\n }\n \n+func ratTok(ch int) bool {\n+\treturn strings.IndexRune(\"+-/0123456789.eE\", ch) >= 0\n+}\n+\n+// Scan is a support routine for fmt.Scanner. It accepts the formats\n+// 'e', 'E', 'f', 'F', 'g', 'G', and 'v'. All formats are equivalent.\n+func (z *Rat) Scan(s fmt.ScanState, ch int) os.Error {\n+\ttok, err := s.Token(true, ratTok)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif strings.IndexRune(\"efgEFGv\", ch) < 0 {\n+\t\treturn os.NewError(\"Rat.Scan: invalid verb\")\n+\t}\n+\tif _, ok := z.SetString(string(tok)); !ok {\n+\t\treturn os.NewError(\"Rat.Scan: invalid syntax\")\n+\t}\n+\treturn nil\n+}\n \n // SetString sets z to the value of s and returns z and a boolean indicating\n // success. s can be given as a fraction \"a/b\" or as a floating-point number\n@@ -225,8 +229,8 @@ func (z *Rat) SetString(s string) (*Rat, bool) {\n \t\t\treturn z, false\n \t\t}\n \t\ts = s[sep+1:]\n-\t\tvar n int\n-\t\tif z.b, _, n = z.b.scan(s, 10); n != len(s) {\n+\t\tvar err os.Error\n+\t\tif z.b, _, err = z.b.scan(strings.NewReader(s), 10); err != nil {\n \t\t\treturn z, false\n \t\t}\n \t\treturn z.norm(), true\n@@ -267,13 +271,11 @@ func (z *Rat) SetString(s string) (*Rat, bool) {\n \treturn z, true\n }\n \n-\n // String returns a string representation of z in the form \"a/b\" (even if b == 1).\n func (z *Rat) String() string {\n-\treturn z.a.String() + \"/\" + z.b.string(10)\n+\treturn z.a.String() + \"/\" + z.b.decimalString()\n }\n \n-\n // RatString returns a string representation of z in the form \"a/b\" if b != 1,\n // and in the form \"a\" if b == 1.\n func (z *Rat) RatString() string {\n@@ -283,12 +285,15 @@ func (z *Rat) RatString() string {\n \treturn z.String()\n }\n \n-\n // FloatString returns a string representation of z in decimal form with prec\n // digits of precision after the decimal point and the last digit rounded.\n func (z *Rat) FloatString(prec int) string {\n \tif z.IsInt() {\n-\t\treturn z.a.String()\n+\t\ts := z.a.String()\n+\t\tif prec > 0 {\n+\t\t\ts += \".\" + strings.Repeat(\"0\", prec)\n+\t\t}\n+\t\treturn s\n \t}\n \n \tq, r := nat{}.div(nat{}, z.a.abs, z.b)\n@@ -311,16 +316,56 @@ func (z *Rat) FloatString(prec int) string {\n \t\t}\n \t}\n \n-\ts := q.string(10)\n+\ts := q.decimalString()\n \tif z.a.neg {\n \t\ts = \"-\" + s\n \t}\n \n \tif prec > 0 {\n-\t\trs := r.string(10)\n+\t\trs := r.decimalString()\n \t\tleadingZeros := prec - len(rs)\n \t\ts += \".\" + strings.Repeat(\"0\", leadingZeros) + rs\n \t}\n \n \treturn s\n }\n+\n+// Gob codec version. Permits backward-compatible changes to the encoding.\n+const ratGobVersion byte = 1\n+\n+// GobEncode implements the gob.GobEncoder interface.\n+func (z *Rat) GobEncode() ([]byte, os.Error) {\n+\tbuf := make([]byte, 1+4+(len(z.a.abs)+len(z.b))*_S) // extra bytes for version and sign bit (1), and numerator length (4)\n+\ti := z.b.bytes(buf)\n+\tj := z.a.abs.bytes(buf[0:i])\n+\tn := i - j\n+\tif int(uint32(n)) != n {\n+\t\t// this should never happen\n+\t\treturn nil, os.NewError(\"Rat.GobEncode: numerator too large\")\n+\t}\n+\tbinary.BigEndian.PutUint32(buf[j-4:j], uint32(n))\n+\tj -= 1 + 4\n+\tb := ratGobVersion << 1 // make space for sign bit\n+\tif z.a.neg {\n+\t\tb |= 1\n+\t}\n+\tbuf[j] = b\n+\treturn buf[j:], nil\n+}\n+\n+// GobDecode implements the gob.GobDecoder interface.\n+func (z *Rat) GobDecode(buf []byte) os.Error {\n+\tif len(buf) == 0 {\n+\t\treturn os.NewError(\"Rat.GobDecode: no data\")\n+\t}\n+\tb := buf[0]\n+\tif b>>1 != ratGobVersion {\n+\t\treturn os.NewError(fmt.Sprintf(\"Rat.GobDecode: encoding version %d not supported\", b>>1))\n+\t}\n+\tconst j = 1 + 4\n+\ti := j + binary.BigEndian.Uint32(buf[j-4:j])\n+\tz.a.neg = b&1 != 0\n+\tz.a.abs = z.a.abs.setBytes(buf[j:i])\n+\tz.b = z.b.setBytes(buf[i:])\n+\treturn nil\n+}"}, {"sha": "dbc5bb6cca11552c5b32166c3b44ef26f3049cad", "filename": "libgo/go/big/rat_test.go", "status": "modified", "additions": 62, "deletions": 12, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Frat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbig%2Frat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Frat_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -4,8 +4,12 @@\n \n package big\n \n-import \"testing\"\n-\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"gob\"\n+\t\"testing\"\n+)\n \n var setStringTests = []struct {\n \tin, out string\n@@ -52,19 +56,41 @@ func TestRatSetString(t *testing.T) {\n \t}\n }\n \n+func TestRatScan(t *testing.T) {\n+\tvar buf bytes.Buffer\n+\tfor i, test := range setStringTests {\n+\t\tx := new(Rat)\n+\t\tbuf.Reset()\n+\t\tbuf.WriteString(test.in)\n+\n+\t\t_, err := fmt.Fscanf(&buf, \"%v\", x)\n+\t\tif err == nil != test.ok {\n+\t\t\tif test.ok {\n+\t\t\t\tt.Errorf(\"#%d error: %s\", i, err.String())\n+\t\t\t} else {\n+\t\t\t\tt.Errorf(\"#%d expected error\", i)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err == nil && x.RatString() != test.out {\n+\t\t\tt.Errorf(\"#%d got %s want %s\", i, x.RatString(), test.out)\n+\t\t}\n+\t}\n+}\n \n var floatStringTests = []struct {\n \tin   string\n \tprec int\n \tout  string\n }{\n \t{\"0\", 0, \"0\"},\n-\t{\"0\", 4, \"0\"},\n+\t{\"0\", 4, \"0.0000\"},\n \t{\"1\", 0, \"1\"},\n-\t{\"1\", 2, \"1\"},\n+\t{\"1\", 2, \"1.00\"},\n \t{\"-1\", 0, \"-1\"},\n \t{\".25\", 2, \"0.25\"},\n \t{\".25\", 1, \"0.3\"},\n+\t{\".25\", 3, \"0.250\"},\n \t{\"-1/3\", 3, \"-0.333\"},\n \t{\"-2/3\", 4, \"-0.6667\"},\n \t{\"0.96\", 1, \"1.0\"},\n@@ -84,7 +110,6 @@ func TestFloatString(t *testing.T) {\n \t}\n }\n \n-\n func TestRatSign(t *testing.T) {\n \tzero := NewRat(0, 1)\n \tfor _, a := range setStringTests {\n@@ -98,7 +123,6 @@ func TestRatSign(t *testing.T) {\n \t}\n }\n \n-\n var ratCmpTests = []struct {\n \trat1, rat2 string\n \tout        int\n@@ -126,7 +150,6 @@ func TestRatCmp(t *testing.T) {\n \t}\n }\n \n-\n func TestIsInt(t *testing.T) {\n \tone := NewInt(1)\n \tfor _, a := range setStringTests {\n@@ -140,7 +163,6 @@ func TestIsInt(t *testing.T) {\n \t}\n }\n \n-\n func TestRatAbs(t *testing.T) {\n \tzero := NewRat(0, 1)\n \tfor _, a := range setStringTests {\n@@ -158,7 +180,6 @@ func TestRatAbs(t *testing.T) {\n \t}\n }\n \n-\n type ratBinFun func(z, x, y *Rat) *Rat\n type ratBinArg struct {\n \tx, y, z string\n@@ -175,7 +196,6 @@ func testRatBin(t *testing.T, i int, name string, f ratBinFun, a ratBinArg) {\n \t}\n }\n \n-\n var ratBinTests = []struct {\n \tx, y      string\n \tsum, prod string\n@@ -232,7 +252,6 @@ func TestRatBin(t *testing.T) {\n \t}\n }\n \n-\n func TestIssue820(t *testing.T) {\n \tx := NewRat(3, 1)\n \ty := NewRat(2, 1)\n@@ -258,7 +277,6 @@ func TestIssue820(t *testing.T) {\n \t}\n }\n \n-\n var setFrac64Tests = []struct {\n \ta, b int64\n \tout  string\n@@ -280,3 +298,35 @@ func TestRatSetFrac64Rat(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestRatGobEncoding(t *testing.T) {\n+\tvar medium bytes.Buffer\n+\tenc := gob.NewEncoder(&medium)\n+\tdec := gob.NewDecoder(&medium)\n+\tfor i, test := range gobEncodingTests {\n+\t\tfor j := 0; j < 4; j++ {\n+\t\t\tmedium.Reset() // empty buffer for each test case (in case of failures)\n+\t\t\tstest := test\n+\t\t\tif j&1 != 0 {\n+\t\t\t\t// negative numbers\n+\t\t\t\tstest = \"-\" + test\n+\t\t\t}\n+\t\t\tif j%2 != 0 {\n+\t\t\t\t// fractions\n+\t\t\t\tstest = stest + \".\" + test\n+\t\t\t}\n+\t\t\tvar tx Rat\n+\t\t\ttx.SetString(stest)\n+\t\t\tif err := enc.Encode(&tx); err != nil {\n+\t\t\t\tt.Errorf(\"#%d%c: encoding failed: %s\", i, 'a'+j, err)\n+\t\t\t}\n+\t\t\tvar rx Rat\n+\t\t\tif err := dec.Decode(&rx); err != nil {\n+\t\t\t\tt.Errorf(\"#%d%c: decoding failed: %s\", i, 'a'+j, err)\n+\t\t\t}\n+\t\t\tif rx.Cmp(&tx) != 0 {\n+\t\t\t\tt.Errorf(\"#%d%c: transmission failed: got %s want %s\", i, 'a'+j, &rx, &tx)\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "727ebfdbbe2a0fe2121efea9a3033218387435fd", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -15,16 +15,17 @@ import (\n \t\"utf8\"\n )\n \n-\n const (\n \tdefaultBufSize = 4096\n )\n \n // Errors introduced by this package.\n type Error struct {\n-\tos.ErrorString\n+\tErrorString string\n }\n \n+func (err *Error) String() string { return err.ErrorString }\n+\n var (\n \tErrInvalidUnreadByte os.Error = &Error{\"bufio: invalid use of UnreadByte\"}\n \tErrInvalidUnreadRune os.Error = &Error{\"bufio: invalid use of UnreadRune\"}\n@@ -40,7 +41,6 @@ func (b BufSizeError) String() string {\n \treturn \"bufio: bad buffer size \" + strconv.Itoa(int(b))\n }\n \n-\n // Buffered input.\n \n // Reader implements buffering for an io.Reader object.\n@@ -101,6 +101,12 @@ func (b *Reader) fill() {\n \t}\n }\n \n+func (b *Reader) readErr() os.Error {\n+\terr := b.err\n+\tb.err = nil\n+\treturn err\n+}\n+\n // Peek returns the next n bytes without advancing the reader. The bytes stop\n // being valid at the next read call. If Peek returns fewer than n bytes, it\n // also returns an error explaining why the read is short. The error is\n@@ -119,7 +125,7 @@ func (b *Reader) Peek(n int) ([]byte, os.Error) {\n \tif m > n {\n \t\tm = n\n \t}\n-\terr := b.err\n+\terr := b.readErr()\n \tif m < n && err == nil {\n \t\terr = ErrBufferFull\n \t}\n@@ -134,11 +140,11 @@ func (b *Reader) Peek(n int) ([]byte, os.Error) {\n func (b *Reader) Read(p []byte) (n int, err os.Error) {\n \tn = len(p)\n \tif n == 0 {\n-\t\treturn 0, b.err\n+\t\treturn 0, b.readErr()\n \t}\n \tif b.w == b.r {\n \t\tif b.err != nil {\n-\t\t\treturn 0, b.err\n+\t\t\treturn 0, b.readErr()\n \t\t}\n \t\tif len(p) >= len(b.buf) {\n \t\t\t// Large read, empty buffer.\n@@ -148,11 +154,11 @@ func (b *Reader) Read(p []byte) (n int, err os.Error) {\n \t\t\t\tb.lastByte = int(p[n-1])\n \t\t\t\tb.lastRuneSize = -1\n \t\t\t}\n-\t\t\treturn n, b.err\n+\t\t\treturn n, b.readErr()\n \t\t}\n \t\tb.fill()\n \t\tif b.w == b.r {\n-\t\t\treturn 0, b.err\n+\t\t\treturn 0, b.readErr()\n \t\t}\n \t}\n \n@@ -172,7 +178,7 @@ func (b *Reader) ReadByte() (c byte, err os.Error) {\n \tb.lastRuneSize = -1\n \tfor b.w == b.r {\n \t\tif b.err != nil {\n-\t\t\treturn 0, b.err\n+\t\t\treturn 0, b.readErr()\n \t\t}\n \t\tb.fill()\n \t}\n@@ -208,7 +214,7 @@ func (b *Reader) ReadRune() (rune int, size int, err os.Error) {\n \t}\n \tb.lastRuneSize = -1\n \tif b.r == b.w {\n-\t\treturn 0, 0, b.err\n+\t\treturn 0, 0, b.readErr()\n \t}\n \trune, size = int(b.buf[b.r]), 1\n \tif rune >= 0x80 {\n@@ -260,7 +266,7 @@ func (b *Reader) ReadSlice(delim byte) (line []byte, err os.Error) {\n \t\tif b.err != nil {\n \t\t\tline := b.buf[b.r:b.w]\n \t\t\tb.r = b.w\n-\t\t\treturn line, b.err\n+\t\t\treturn line, b.readErr()\n \t\t}\n \n \t\tn := b.Buffered()\n@@ -367,7 +373,6 @@ func (b *Reader) ReadString(delim byte) (line string, err os.Error) {\n \treturn string(bytes), e\n }\n \n-\n // buffered output\n \n // Writer implements buffering for an io.Writer object."}, {"sha": "82c73d36a9cda82013ada7f556c948e0b7754136", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -53,11 +53,12 @@ func readBytes(buf *Reader) string {\n \t\tif e == os.EOF {\n \t\t\tbreak\n \t\t}\n-\t\tif e != nil {\n+\t\tif e == nil {\n+\t\t\tb[nb] = c\n+\t\t\tnb++\n+\t\t} else if e != iotest.ErrTimeout {\n \t\t\tpanic(\"Data: \" + e.String())\n \t\t}\n-\t\tb[nb] = c\n-\t\tnb++\n \t}\n \treturn string(b[0:nb])\n }\n@@ -75,7 +76,6 @@ func TestReaderSimple(t *testing.T) {\n \t}\n }\n \n-\n type readMaker struct {\n \tname string\n \tfn   func(io.Reader) io.Reader\n@@ -86,6 +86,7 @@ var readMakers = []readMaker{\n \t{\"byte\", iotest.OneByteReader},\n \t{\"half\", iotest.HalfReader},\n \t{\"data+err\", iotest.DataErrReader},\n+\t{\"timeout\", iotest.TimeoutReader},\n }\n \n // Call ReadString (which ends up calling everything else)\n@@ -97,7 +98,7 @@ func readLines(b *Reader) string {\n \t\tif e == os.EOF {\n \t\t\tbreak\n \t\t}\n-\t\tif e != nil {\n+\t\tif e != nil && e != iotest.ErrTimeout {\n \t\t\tpanic(\"GetLines: \" + e.String())\n \t\t}\n \t\ts += s1"}, {"sha": "07acce4f7007ae823aa8c26be6be4733988d9c23", "filename": "libgo/go/builtin/builtin.go", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -0,0 +1,135 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+/*\n+\tPackage builtin provides documentation for Go's built-in functions.\n+\tThe functions documented here are not actually in package builtin\n+\tbut their descriptions here allow godoc to present documentation\n+\tfor the language's special functions.\n+*/\n+package builtin\n+\n+// Type is here for the purposes of documentation only. It is a stand-in\n+// for any Go type, but represents the same type for any given function\n+// invocation.\n+type Type int\n+\n+// IntegerType is here for the purposes of documentation only. It is a stand-in\n+// for any integer type: int, uint, int8 etc.\n+type IntegerType int\n+\n+// FloatType is here for the purposes of documentation only. It is a stand-in\n+// for either float type: float32 or float64.\n+type FloatType int\n+\n+// ComplexType is here for the purposes of documentation only. It is a\n+// stand-in for either complex type: complex64 or complex128.\n+type ComplexType int\n+\n+// The append built-in function appends elements to the end of a slice. If\n+// it has sufficient capacity, the destination is resliced to accommodate the\n+// new elements. If it does not, a new underlying array will be allocated.\n+// Append returns the updated slice. It is therefore necessary to store the\n+// result of append, often in the variable holding the slice itself:\n+//\tslice = append(slice, elem1, elem2)\n+//\tslice = append(slice, anotherSlice...)\n+func append(slice []Type, elems ...Type) []Type\n+\n+// The copy built-in function copies elements from a source slice into a\n+// destination slice. (As a special case, it also will copy bytes from a\n+// string to a slice of bytes.) The source and destination may overlap. Copy\n+// returns the number of elements copied, which will be the minimum of\n+// len(src) and len(dst).\n+func copy(dst, src []Type) int\n+\n+// The len built-in function returns the length of v, according to its type:\n+//\tArray: the number of elements in v.\n+//\tPointer to array: the number of elements in *v (even if v is nil).\n+//\tSlice, or map: the number of elements in v; if v is nil, len(v) is zero.\n+//\tString: the number of bytes in v.\n+//\tChannel: the number of elements queued (unread) in the channel buffer;\n+//\tif v is nil, len(v) is zero.\n+func len(v Type) int\n+\n+// The cap built-in function returns the capacity of v, according to its type:\n+//\tArray: the number of elements in v (same as len(v)).\n+//\tPointer to array: the number of elements in *v (same as len(v)).\n+//\tSlice: the maximum length the slice can reach when resliced;\n+//\tif v is nil, cap(v) is zero.\n+//\tChannel: the channel buffer capacity, in units of elements;\n+//\tif v is nil, cap(v) is zero.\n+func cap(v Type) int\n+\n+// The make built-in function allocates and initializes an object of type\n+// slice, map, or chan (only). Like new, the first argument is a type, not a\n+// value. Unlike new, make's return type is the same as the type of its\n+// argument, not a pointer to it. The specification of the result depends on\n+// the type:\n+//\tSlice: The size specifies the length. The capacity of the slice is\n+//\tequal to its length. A second integer argument may be provided to\n+//\tspecify a different capacity; it must be no smaller than the\n+//\tlength, so make([]int, 0, 10) allocates a slice of length 0 and\n+//\tcapacity 10.\n+//\tMap: An initial allocation is made according to the size but the\n+//\tresulting map has length 0. The size may be omitted, in which case\n+//\ta small starting size is allocated.\n+//\tChannel: The channel's buffer is initialized with the specified\n+//\tbuffer capacity. If zero, or the size is omitted, the channel is\n+//\tunbuffered.\n+func make(Type, size IntegerType) Type\n+\n+// The new built-in function allocates memory. The first argument is a type,\n+// not a value, and the value returned is a pointer to a newly\n+// allocated zero value of that type.\n+func new(Type) *Type\n+\n+// The complex built-in function constructs a complex value from two\n+// floating-point values. The real and imaginary parts must be of the same\n+// size, either float32 or float64 (or assignable to them), and the return\n+// value will be the corresponding complex type (complex64 for float32,\n+// complex128 for float64).\n+func complex(r, i FloatType) ComplexType\n+\n+// The real built-in function returns the real part of the complex number c.\n+// The return value will be floating point type corresponding to the type of c.\n+func real(c ComplexType) FloatType\n+\n+// The imaginary built-in function returns the imaginary part of the complex\n+// number c. The return value will be floating point type corresponding to\n+// the type of c.\n+func imag(c ComplexType) FloatType\n+\n+// The close built-in function closes a channel, which must be either\n+// bidirectional or send-only. It should be executed only by the sender,\n+// never the receiver, and has the effect of shutting down the channel after\n+// the last sent value is received. After the last value has been received\n+// from a closed channel c, any receive from c will succeed without\n+// blocking, returning the zero value for the channel element. The form\n+//\tx, ok := <-c\n+// will also set ok to false for a closed channel.\n+func close(c chan<- Type)\n+\n+// The panic built-in function stops normal execution of the current\n+// goroutine. When a function F calls panic, normal execution of F stops\n+// immediately. Any functions whose execution was deferred by F are run in\n+// the usual way, and then F returns to its caller. To the caller G, the\n+// invocation of F then behaves like a call to panic, terminating G's\n+// execution and running any deferred functions. This continues until all\n+// functions in the executing goroutine have stopped, in reverse order. At\n+// that point, the program is terminated and the error condition is reported,\n+// including the value of the argument to panic. This termination sequence\n+// is called panicking and can be controlled by the built-in function\n+// recover.\n+func panic(v interface{})\n+\n+// The recover built-in function allows a program to manage behavior of a\n+// panicking goroutine. Executing a call to recover inside a deferred\n+// function (but not any function called by it) stops the panicking sequence\n+// by restoring normal execution and retrieves the error value passed to the\n+// call of panic. If recover is called outside the deferred function it will\n+// not stop a panicking sequence. In this case, or when the goroutine is not\n+// panicking, or if the argument supplied to panic was nil, recover returns\n+// nil. Thus the return value from recover reports whether the goroutine is\n+// panicking.\n+func recover() interface{}"}, {"sha": "5de86105d058fa68eba3909877655703ba941ea2", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -280,7 +280,7 @@ func (b *Buffer) ReadRune() (r int, size int, err os.Error) {\n // from any read operation.)\n func (b *Buffer) UnreadRune() os.Error {\n \tif b.lastRead != opReadRune {\n-\t\treturn os.ErrorString(\"bytes.Buffer: UnreadRune: previous operation was not ReadRune\")\n+\t\treturn os.NewError(\"bytes.Buffer: UnreadRune: previous operation was not ReadRune\")\n \t}\n \tb.lastRead = opInvalid\n \tif b.off > 0 {\n@@ -295,7 +295,7 @@ func (b *Buffer) UnreadRune() os.Error {\n // returns an error.\n func (b *Buffer) UnreadByte() os.Error {\n \tif b.lastRead != opReadRune && b.lastRead != opRead {\n-\t\treturn os.ErrorString(\"bytes.Buffer: UnreadByte: previous operation was not a read\")\n+\t\treturn os.NewError(\"bytes.Buffer: UnreadByte: previous operation was not a read\")\n \t}\n \tb.lastRead = opInvalid\n \tif b.off > 0 {"}, {"sha": "06d2a65c673d9c03fc0f36040b8fd50e43852eef", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -12,7 +12,6 @@ import (\n \t\"utf8\"\n )\n \n-\n const N = 10000  // make this bigger for a larger (and slower) test\n var data string  // test data for write tests\n var bytes []byte // test data; same as data but as a slice.\n@@ -47,7 +46,6 @@ func check(t *testing.T, testname string, buf *Buffer, s string) {\n \t}\n }\n \n-\n // Fill buf through n writes of string fus.\n // The initial contents of buf corresponds to the string s;\n // the result is the final contents of buf returned as a string.\n@@ -67,7 +65,6 @@ func fillString(t *testing.T, testname string, buf *Buffer, s string, n int, fus\n \treturn s\n }\n \n-\n // Fill buf through n writes of byte slice fub.\n // The initial contents of buf corresponds to the string s;\n // the result is the final contents of buf returned as a string.\n@@ -87,19 +84,16 @@ func fillBytes(t *testing.T, testname string, buf *Buffer, s string, n int, fub\n \treturn s\n }\n \n-\n func TestNewBuffer(t *testing.T) {\n \tbuf := NewBuffer(bytes)\n \tcheck(t, \"NewBuffer\", buf, data)\n }\n \n-\n func TestNewBufferString(t *testing.T) {\n \tbuf := NewBufferString(data)\n \tcheck(t, \"NewBufferString\", buf, data)\n }\n \n-\n // Empty buf through repeated reads into fub.\n // The initial contents of buf corresponds to the string s.\n func empty(t *testing.T, testname string, buf *Buffer, s string, fub []byte) {\n@@ -120,7 +114,6 @@ func empty(t *testing.T, testname string, buf *Buffer, s string, fub []byte) {\n \tcheck(t, testname+\" (empty 4)\", buf, \"\")\n }\n \n-\n func TestBasicOperations(t *testing.T) {\n \tvar buf Buffer\n \n@@ -175,7 +168,6 @@ func TestBasicOperations(t *testing.T) {\n \t}\n }\n \n-\n func TestLargeStringWrites(t *testing.T) {\n \tvar buf Buffer\n \tlimit := 30\n@@ -189,7 +181,6 @@ func TestLargeStringWrites(t *testing.T) {\n \tcheck(t, \"TestLargeStringWrites (3)\", &buf, \"\")\n }\n \n-\n func TestLargeByteWrites(t *testing.T) {\n \tvar buf Buffer\n \tlimit := 30\n@@ -203,7 +194,6 @@ func TestLargeByteWrites(t *testing.T) {\n \tcheck(t, \"TestLargeByteWrites (3)\", &buf, \"\")\n }\n \n-\n func TestLargeStringReads(t *testing.T) {\n \tvar buf Buffer\n \tfor i := 3; i < 30; i += 3 {\n@@ -213,7 +203,6 @@ func TestLargeStringReads(t *testing.T) {\n \tcheck(t, \"TestLargeStringReads (3)\", &buf, \"\")\n }\n \n-\n func TestLargeByteReads(t *testing.T) {\n \tvar buf Buffer\n \tfor i := 3; i < 30; i += 3 {\n@@ -223,7 +212,6 @@ func TestLargeByteReads(t *testing.T) {\n \tcheck(t, \"TestLargeByteReads (3)\", &buf, \"\")\n }\n \n-\n func TestMixedReadsAndWrites(t *testing.T) {\n \tvar buf Buffer\n \ts := \"\"\n@@ -243,15 +231,13 @@ func TestMixedReadsAndWrites(t *testing.T) {\n \tempty(t, \"TestMixedReadsAndWrites (2)\", &buf, s, make([]byte, buf.Len()))\n }\n \n-\n func TestNil(t *testing.T) {\n \tvar b *Buffer\n \tif b.String() != \"<nil>\" {\n \t\tt.Errorf(\"expected <nil>; got %q\", b.String())\n \t}\n }\n \n-\n func TestReadFrom(t *testing.T) {\n \tvar buf Buffer\n \tfor i := 3; i < 30; i += 3 {\n@@ -262,7 +248,6 @@ func TestReadFrom(t *testing.T) {\n \t}\n }\n \n-\n func TestWriteTo(t *testing.T) {\n \tvar buf Buffer\n \tfor i := 3; i < 30; i += 3 {\n@@ -273,7 +258,6 @@ func TestWriteTo(t *testing.T) {\n \t}\n }\n \n-\n func TestRuneIO(t *testing.T) {\n \tconst NRune = 1000\n \t// Built a test array while we write the data\n@@ -323,7 +307,6 @@ func TestRuneIO(t *testing.T) {\n \t}\n }\n \n-\n func TestNext(t *testing.T) {\n \tb := []byte{0, 1, 2, 3, 4}\n \ttmp := make([]byte, 5)"}, {"sha": "5119fce949e31ad4cc1dc9e5cc68ab75b400e4f5", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -212,26 +212,40 @@ func genSplit(s, sep []byte, sepSave, n int) [][]byte {\n \treturn a[0 : na+1]\n }\n \n-// Split slices s into subslices separated by sep and returns a slice of\n+// SplitN slices s into subslices separated by sep and returns a slice of\n // the subslices between those separators.\n-// If sep is empty, Split splits after each UTF-8 sequence.\n+// If sep is empty, SplitN splits after each UTF-8 sequence.\n // The count determines the number of subslices to return:\n //   n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n //   n == 0: the result is nil (zero subslices)\n //   n < 0: all subslices\n-func Split(s, sep []byte, n int) [][]byte { return genSplit(s, sep, 0, n) }\n+func SplitN(s, sep []byte, n int) [][]byte { return genSplit(s, sep, 0, n) }\n \n-// SplitAfter slices s into subslices after each instance of sep and\n+// SplitAfterN slices s into subslices after each instance of sep and\n // returns a slice of those subslices.\n-// If sep is empty, Split splits after each UTF-8 sequence.\n+// If sep is empty, SplitAfterN splits after each UTF-8 sequence.\n // The count determines the number of subslices to return:\n //   n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n //   n == 0: the result is nil (zero subslices)\n //   n < 0: all subslices\n-func SplitAfter(s, sep []byte, n int) [][]byte {\n+func SplitAfterN(s, sep []byte, n int) [][]byte {\n \treturn genSplit(s, sep, len(sep), n)\n }\n \n+// Split slices s into all subslices separated by sep and returns a slice of\n+// the subslices between those separators.\n+// If sep is empty, Split splits after each UTF-8 sequence.\n+// It is equivalent to SplitN with a count of -1.\n+func Split(s, sep []byte) [][]byte { return genSplit(s, sep, 0, -1) }\n+\n+// SplitAfter slices s into all subslices after each instance of sep and\n+// returns a slice of those subslices.\n+// If sep is empty, SplitAfter splits after each UTF-8 sequence.\n+// It is equivalent to SplitAfterN with a count of -1.\n+func SplitAfter(s, sep []byte) [][]byte {\n+\treturn genSplit(s, sep, len(sep), -1)\n+}\n+\n // Fields splits the array s around each instance of one or more consecutive white space\n // characters, returning a slice of subarrays of s or an empty list if s contains only white space.\n func Fields(s []byte) [][]byte {\n@@ -384,7 +398,6 @@ func ToTitleSpecial(_case unicode.SpecialCase, s []byte) []byte {\n \treturn Map(func(r int) int { return _case.ToTitle(r) }, s)\n }\n \n-\n // isSeparator reports whether the rune could mark a word boundary.\n // TODO: update when package unicode captures more of the properties.\n func isSeparator(rune int) bool {"}, {"sha": "9444358a8584580b96ff1e80423c801514898dd3", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -6,6 +6,7 @@ package bytes_test\n \n import (\n \t. \"bytes\"\n+\t\"reflect\"\n \t\"testing\"\n \t\"unicode\"\n \t\"utf8\"\n@@ -315,7 +316,7 @@ var explodetests = []ExplodeTest{\n \n func TestExplode(t *testing.T) {\n \tfor _, tt := range explodetests {\n-\t\ta := Split([]byte(tt.s), nil, tt.n)\n+\t\ta := SplitN([]byte(tt.s), nil, tt.n)\n \t\tresult := arrayOfString(a)\n \t\tif !eq(result, tt.a) {\n \t\t\tt.Errorf(`Explode(\"%s\", %d) = %v; want %v`, tt.s, tt.n, result, tt.a)\n@@ -328,7 +329,6 @@ func TestExplode(t *testing.T) {\n \t}\n }\n \n-\n type SplitTest struct {\n \ts   string\n \tsep string\n@@ -354,7 +354,7 @@ var splittests = []SplitTest{\n \n func TestSplit(t *testing.T) {\n \tfor _, tt := range splittests {\n-\t\ta := Split([]byte(tt.s), []byte(tt.sep), tt.n)\n+\t\ta := SplitN([]byte(tt.s), []byte(tt.sep), tt.n)\n \t\tresult := arrayOfString(a)\n \t\tif !eq(result, tt.a) {\n \t\t\tt.Errorf(`Split(%q, %q, %d) = %v; want %v`, tt.s, tt.sep, tt.n, result, tt.a)\n@@ -367,6 +367,12 @@ func TestSplit(t *testing.T) {\n \t\tif string(s) != tt.s {\n \t\t\tt.Errorf(`Join(Split(%q, %q, %d), %q) = %q`, tt.s, tt.sep, tt.n, tt.sep, s)\n \t\t}\n+\t\tif tt.n < 0 {\n+\t\t\tb := Split([]byte(tt.s), []byte(tt.sep))\n+\t\t\tif !reflect.DeepEqual(a, b) {\n+\t\t\t\tt.Errorf(\"Split disagrees withSplitN(%q, %q, %d) = %v; want %v\", tt.s, tt.sep, tt.n, b, a)\n+\t\t\t}\n+\t\t}\n \t}\n }\n \n@@ -388,7 +394,7 @@ var splitaftertests = []SplitTest{\n \n func TestSplitAfter(t *testing.T) {\n \tfor _, tt := range splitaftertests {\n-\t\ta := SplitAfter([]byte(tt.s), []byte(tt.sep), tt.n)\n+\t\ta := SplitAfterN([]byte(tt.s), []byte(tt.sep), tt.n)\n \t\tresult := arrayOfString(a)\n \t\tif !eq(result, tt.a) {\n \t\t\tt.Errorf(`Split(%q, %q, %d) = %v; want %v`, tt.s, tt.sep, tt.n, result, tt.a)\n@@ -398,6 +404,12 @@ func TestSplitAfter(t *testing.T) {\n \t\tif string(s) != tt.s {\n \t\t\tt.Errorf(`Join(Split(%q, %q, %d), %q) = %q`, tt.s, tt.sep, tt.n, tt.sep, s)\n \t\t}\n+\t\tif tt.n < 0 {\n+\t\t\tb := SplitAfter([]byte(tt.s), []byte(tt.sep))\n+\t\t\tif !reflect.DeepEqual(a, b) {\n+\t\t\t\tt.Errorf(\"SplitAfter disagrees withSplitAfterN(%q, %q, %d) = %v; want %v\", tt.s, tt.sep, tt.n, b, a)\n+\t\t\t}\n+\t\t}\n \t}\n }\n \n@@ -649,7 +661,6 @@ func TestRunes(t *testing.T) {\n \t}\n }\n \n-\n type TrimTest struct {\n \tf               func([]byte, string) []byte\n \tin, cutset, out string"}, {"sha": "8b4572306b17842fc4491a29fa7ea0796ac585b5", "filename": "libgo/go/compress/bzip2/bzip2.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -284,7 +284,7 @@ func (bz2 *reader) readBlock() (err os.Error) {\n \trepeat := 0\n \trepeat_power := 0\n \n-\t// The `C' array (used by the inverse BWT) needs to be zero initialised.\n+\t// The `C' array (used by the inverse BWT) needs to be zero initialized.\n \tfor i := range bz2.c {\n \t\tbz2.c[i] = 0\n \t}\n@@ -330,7 +330,7 @@ func (bz2 *reader) readBlock() (err os.Error) {\n \n \t\tif int(v) == numSymbols-1 {\n \t\t\t// This is the EOF symbol. Because it's always at the\n-\t\t\t// end of the move-to-front list, and nevers gets moved\n+\t\t\t// end of the move-to-front list, and never gets moved\n \t\t\t// to the front, it has this unique value.\n \t\t\tbreak\n \t\t}"}, {"sha": "dc05739c7559b9583e74c2af093c7fd50777bb66", "filename": "libgo/go/compress/bzip2/huffman.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fbzip2%2Fhuffman.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fbzip2%2Fhuffman.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fhuffman.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -68,7 +68,7 @@ func newHuffmanTree(lengths []uint8) (huffmanTree, os.Error) {\n \t// each symbol (consider reflecting a tree down the middle, for\n \t// example). Since the code length assignments determine the\n \t// efficiency of the tree, each of these trees is equally good. In\n-\t// order to minimise the amount of information needed to build a tree\n+\t// order to minimize the amount of information needed to build a tree\n \t// bzip2 uses a canonical tree so that it can be reconstructed given\n \t// only the code length assignments.\n "}, {"sha": "b1cee0b2f0f919aad91690c43bc2b50e844f8816", "filename": "libgo/go/compress/flate/deflate.go", "status": "modified", "additions": 202, "deletions": 276, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -11,16 +11,18 @@ import (\n )\n \n const (\n-\tNoCompression        = 0\n-\tBestSpeed            = 1\n-\tfastCompression      = 3\n-\tBestCompression      = 9\n-\tDefaultCompression   = -1\n-\tlogMaxOffsetSize     = 15  // Standard DEFLATE\n-\twideLogMaxOffsetSize = 22  // Wide DEFLATE\n-\tminMatchLength       = 3   // The smallest match that the compressor looks for\n-\tmaxMatchLength       = 258 // The longest match for the compressor\n-\tminOffsetSize        = 1   // The shortest offset that makes any sence\n+\tNoCompression      = 0\n+\tBestSpeed          = 1\n+\tfastCompression    = 3\n+\tBestCompression    = 9\n+\tDefaultCompression = -1\n+\tlogWindowSize      = 15\n+\twindowSize         = 1 << logWindowSize\n+\twindowMask         = windowSize - 1\n+\tlogMaxOffsetSize   = 15  // Standard DEFLATE\n+\tminMatchLength     = 3   // The smallest match that the compressor looks for\n+\tmaxMatchLength     = 258 // The longest match for the compressor\n+\tminOffsetSize      = 1   // The shortest offset that makes any sence\n \n \t// The maximum number of tokens we put into a single flat block, just too\n \t// stop things from getting too large.\n@@ -32,22 +34,6 @@ const (\n \thashShift           = (hashBits + minMatchLength - 1) / minMatchLength\n )\n \n-type syncPipeReader struct {\n-\t*io.PipeReader\n-\tcloseChan chan bool\n-}\n-\n-func (sr *syncPipeReader) CloseWithError(err os.Error) os.Error {\n-\tretErr := sr.PipeReader.CloseWithError(err)\n-\tsr.closeChan <- true // finish writer close\n-\treturn retErr\n-}\n-\n-type syncPipeWriter struct {\n-\t*io.PipeWriter\n-\tcloseChan chan bool\n-}\n-\n type compressionLevel struct {\n \tgood, lazy, nice, chain, fastSkipHashing int\n }\n@@ -68,105 +54,73 @@ var levels = []compressionLevel{\n \t{32, 258, 258, 4096, math.MaxInt32},\n }\n \n-func (sw *syncPipeWriter) Close() os.Error {\n-\terr := sw.PipeWriter.Close()\n-\t<-sw.closeChan // wait for reader close\n-\treturn err\n-}\n-\n-func syncPipe() (*syncPipeReader, *syncPipeWriter) {\n-\tr, w := io.Pipe()\n-\tsr := &syncPipeReader{r, make(chan bool, 1)}\n-\tsw := &syncPipeWriter{w, sr.closeChan}\n-\treturn sr, sw\n-}\n-\n type compressor struct {\n-\tlevel         int\n-\tlogWindowSize uint\n-\tw             *huffmanBitWriter\n-\tr             io.Reader\n-\t// (1 << logWindowSize) - 1.\n-\twindowMask int\n+\tcompressionLevel\n \n-\teof      bool // has eof been reached on input?\n-\tsync     bool // writer wants to flush\n-\tsyncChan chan os.Error\n+\tw *huffmanBitWriter\n \n-\t// hashHead[hashValue] contains the largest inputIndex with the specified hash value\n-\thashHead []int\n+\t// compression algorithm\n+\tfill func(*compressor, []byte) int // copy data to window\n+\tstep func(*compressor)             // process window\n+\tsync bool                          // requesting flush\n \n+\t// Input hash chains\n+\t// hashHead[hashValue] contains the largest inputIndex with the specified hash value\n \t// If hashHead[hashValue] is within the current window, then\n \t// hashPrev[hashHead[hashValue] & windowMask] contains the previous index\n \t// with the same hash value.\n-\thashPrev []int\n-\n-\t// If we find a match of length >= niceMatch, then we don't bother searching\n-\t// any further.\n-\tniceMatch int\n-\n-\t// If we find a match of length >= goodMatch, we only do a half-hearted\n-\t// effort at doing lazy matching starting at the next character\n-\tgoodMatch int\n-\n-\t// The maximum number of chains we look at when finding a match\n-\tmaxChainLength int\n-\n-\t// The sliding window we use for matching\n-\twindow []byte\n-\n-\t// The index just past the last valid character\n-\twindowEnd int\n-\n-\t// index in \"window\" at which current block starts\n-\tblockStart int\n-}\n-\n-func (d *compressor) flush() os.Error {\n-\td.w.flush()\n-\treturn d.w.err\n+\tchainHead int\n+\thashHead  []int\n+\thashPrev  []int\n+\n+\t// input window: unprocessed data is window[index:windowEnd]\n+\tindex         int\n+\twindow        []byte\n+\twindowEnd     int\n+\tblockStart    int  // window index where current tokens start\n+\tbyteAvailable bool // if true, still need to process window[index-1].\n+\n+\t// queued output tokens: tokens[:ti]\n+\ttokens []token\n+\tti     int\n+\n+\t// deflate state\n+\tlength         int\n+\toffset         int\n+\thash           int\n+\tmaxInsertIndex int\n+\terr            os.Error\n }\n \n-func (d *compressor) fillWindow(index int) (int, os.Error) {\n-\tif d.sync {\n-\t\treturn index, nil\n-\t}\n-\twSize := d.windowMask + 1\n-\tif index >= wSize+wSize-(minMatchLength+maxMatchLength) {\n-\t\t// shift the window by wSize\n-\t\tcopy(d.window, d.window[wSize:2*wSize])\n-\t\tindex -= wSize\n-\t\td.windowEnd -= wSize\n-\t\tif d.blockStart >= wSize {\n-\t\t\td.blockStart -= wSize\n+func (d *compressor) fillDeflate(b []byte) int {\n+\tif d.index >= 2*windowSize-(minMatchLength+maxMatchLength) {\n+\t\t// shift the window by windowSize\n+\t\tcopy(d.window, d.window[windowSize:2*windowSize])\n+\t\td.index -= windowSize\n+\t\td.windowEnd -= windowSize\n+\t\tif d.blockStart >= windowSize {\n+\t\t\td.blockStart -= windowSize\n \t\t} else {\n \t\t\td.blockStart = math.MaxInt32\n \t\t}\n \t\tfor i, h := range d.hashHead {\n-\t\t\tv := h - wSize\n+\t\t\tv := h - windowSize\n \t\t\tif v < -1 {\n \t\t\t\tv = -1\n \t\t\t}\n \t\t\td.hashHead[i] = v\n \t\t}\n \t\tfor i, h := range d.hashPrev {\n-\t\t\tv := -h - wSize\n+\t\t\tv := -h - windowSize\n \t\t\tif v < -1 {\n \t\t\t\tv = -1\n \t\t\t}\n \t\t\td.hashPrev[i] = v\n \t\t}\n \t}\n-\tcount, err := d.r.Read(d.window[d.windowEnd:])\n-\td.windowEnd += count\n-\tif count == 0 && err == nil {\n-\t\td.sync = true\n-\t}\n-\tif err == os.EOF {\n-\t\td.eof = true\n-\t\terr = nil\n-\t}\n-\treturn index, err\n+\tn := copy(d.window[d.windowEnd:], b)\n+\td.windowEnd += n\n+\treturn n\n }\n \n func (d *compressor) writeBlock(tokens []token, index int, eof bool) os.Error {\n@@ -194,21 +148,21 @@ func (d *compressor) findMatch(pos int, prevHead int, prevLength int, lookahead\n \n \t// We quit when we get a match that's at least nice long\n \tnice := len(win) - pos\n-\tif d.niceMatch < nice {\n-\t\tnice = d.niceMatch\n+\tif d.nice < nice {\n+\t\tnice = d.nice\n \t}\n \n \t// If we've got a match that's good enough, only look in 1/4 the chain.\n-\ttries := d.maxChainLength\n+\ttries := d.chain\n \tlength = prevLength\n-\tif length >= d.goodMatch {\n+\tif length >= d.good {\n \t\ttries >>= 2\n \t}\n \n \tw0 := win[pos]\n \tw1 := win[pos+1]\n \twEnd := win[pos+length]\n-\tminIndex := pos - (d.windowMask + 1)\n+\tminIndex := pos - windowSize\n \n \tfor i := prevHead; tries > 0; tries-- {\n \t\tif w0 == win[i] && w1 == win[i+1] && wEnd == win[i+length] {\n@@ -233,7 +187,7 @@ func (d *compressor) findMatch(pos int, prevHead int, prevLength int, lookahead\n \t\t\t// hashPrev[i & windowMask] has already been overwritten, so stop now.\n \t\t\tbreak\n \t\t}\n-\t\tif i = d.hashPrev[i&d.windowMask]; i < minIndex || i < 0 {\n+\t\tif i = d.hashPrev[i&windowMask]; i < minIndex || i < 0 {\n \t\t\tbreak\n \t\t}\n \t}\n@@ -248,234 +202,224 @@ func (d *compressor) writeStoredBlock(buf []byte) os.Error {\n \treturn d.w.err\n }\n \n-func (d *compressor) storedDeflate() os.Error {\n-\tbuf := make([]byte, maxStoreBlockSize)\n-\tfor {\n-\t\tn, err := d.r.Read(buf)\n-\t\tif n == 0 && err == nil {\n-\t\t\td.sync = true\n-\t\t}\n-\t\tif n > 0 || d.sync {\n-\t\t\tif err := d.writeStoredBlock(buf[0:n]); err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\tif d.sync {\n-\t\t\t\td.syncChan <- nil\n-\t\t\t\td.sync = false\n-\t\t\t}\n-\t\t}\n-\t\tif err != nil {\n-\t\t\tif err == os.EOF {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-func (d *compressor) doDeflate() (err os.Error) {\n-\t// init\n-\td.windowMask = 1<<d.logWindowSize - 1\n+func (d *compressor) initDeflate() {\n \td.hashHead = make([]int, hashSize)\n-\td.hashPrev = make([]int, 1<<d.logWindowSize)\n-\td.window = make([]byte, 2<<d.logWindowSize)\n+\td.hashPrev = make([]int, windowSize)\n+\td.window = make([]byte, 2*windowSize)\n \tfillInts(d.hashHead, -1)\n-\ttokens := make([]token, maxFlateBlockTokens, maxFlateBlockTokens+1)\n-\tl := levels[d.level]\n-\td.goodMatch = l.good\n-\td.niceMatch = l.nice\n-\td.maxChainLength = l.chain\n-\tlazyMatch := l.lazy\n-\tlength := minMatchLength - 1\n-\toffset := 0\n-\tbyteAvailable := false\n-\tisFastDeflate := l.fastSkipHashing != 0\n-\tindex := 0\n-\t// run\n-\tif index, err = d.fillWindow(index); err != nil {\n+\td.tokens = make([]token, maxFlateBlockTokens, maxFlateBlockTokens+1)\n+\td.length = minMatchLength - 1\n+\td.offset = 0\n+\td.byteAvailable = false\n+\td.index = 0\n+\td.ti = 0\n+\td.hash = 0\n+\td.chainHead = -1\n+}\n+\n+func (d *compressor) deflate() {\n+\tif d.windowEnd-d.index < minMatchLength+maxMatchLength && !d.sync {\n \t\treturn\n \t}\n-\tmaxOffset := d.windowMask + 1 // (1 << logWindowSize);\n-\t// only need to change when you refill the window\n-\twindowEnd := d.windowEnd\n-\tmaxInsertIndex := windowEnd - (minMatchLength - 1)\n-\tti := 0\n-\n-\thash := int(0)\n-\tif index < maxInsertIndex {\n-\t\thash = int(d.window[index])<<hashShift + int(d.window[index+1])\n+\n+\td.maxInsertIndex = d.windowEnd - (minMatchLength - 1)\n+\tif d.index < d.maxInsertIndex {\n+\t\td.hash = int(d.window[d.index])<<hashShift + int(d.window[d.index+1])\n \t}\n-\tchainHead := -1\n+\n Loop:\n \tfor {\n-\t\tif index > windowEnd {\n+\t\tif d.index > d.windowEnd {\n \t\t\tpanic(\"index > windowEnd\")\n \t\t}\n-\t\tlookahead := windowEnd - index\n+\t\tlookahead := d.windowEnd - d.index\n \t\tif lookahead < minMatchLength+maxMatchLength {\n-\t\t\tif index, err = d.fillWindow(index); err != nil {\n-\t\t\t\treturn\n+\t\t\tif !d.sync {\n+\t\t\t\tbreak Loop\n \t\t\t}\n-\t\t\twindowEnd = d.windowEnd\n-\t\t\tif index > windowEnd {\n+\t\t\tif d.index > d.windowEnd {\n \t\t\t\tpanic(\"index > windowEnd\")\n \t\t\t}\n-\t\t\tmaxInsertIndex = windowEnd - (minMatchLength - 1)\n-\t\t\tlookahead = windowEnd - index\n \t\t\tif lookahead == 0 {\n \t\t\t\t// Flush current output block if any.\n-\t\t\t\tif byteAvailable {\n+\t\t\t\tif d.byteAvailable {\n \t\t\t\t\t// There is still one pending token that needs to be flushed\n-\t\t\t\t\ttokens[ti] = literalToken(uint32(d.window[index-1]) & 0xFF)\n-\t\t\t\t\tti++\n-\t\t\t\t\tbyteAvailable = false\n+\t\t\t\t\td.tokens[d.ti] = literalToken(uint32(d.window[d.index-1]))\n+\t\t\t\t\td.ti++\n+\t\t\t\t\td.byteAvailable = false\n \t\t\t\t}\n-\t\t\t\tif ti > 0 {\n-\t\t\t\t\tif err = d.writeBlock(tokens[0:ti], index, false); err != nil {\n+\t\t\t\tif d.ti > 0 {\n+\t\t\t\t\tif d.err = d.writeBlock(d.tokens[0:d.ti], d.index, false); d.err != nil {\n \t\t\t\t\t\treturn\n \t\t\t\t\t}\n-\t\t\t\t\tti = 0\n-\t\t\t\t}\n-\t\t\t\tif d.sync {\n-\t\t\t\t\td.w.writeStoredHeader(0, false)\n-\t\t\t\t\td.w.flush()\n-\t\t\t\t\td.syncChan <- d.w.err\n-\t\t\t\t\td.sync = false\n-\t\t\t\t}\n-\n-\t\t\t\t// If this was only a sync (not at EOF) keep going.\n-\t\t\t\tif !d.eof {\n-\t\t\t\t\tcontinue\n+\t\t\t\t\td.ti = 0\n \t\t\t\t}\n \t\t\t\tbreak Loop\n \t\t\t}\n \t\t}\n-\t\tif index < maxInsertIndex {\n+\t\tif d.index < d.maxInsertIndex {\n \t\t\t// Update the hash\n-\t\t\thash = (hash<<hashShift + int(d.window[index+2])) & hashMask\n-\t\t\tchainHead = d.hashHead[hash]\n-\t\t\td.hashPrev[index&d.windowMask] = chainHead\n-\t\t\td.hashHead[hash] = index\n+\t\t\td.hash = (d.hash<<hashShift + int(d.window[d.index+2])) & hashMask\n+\t\t\td.chainHead = d.hashHead[d.hash]\n+\t\t\td.hashPrev[d.index&windowMask] = d.chainHead\n+\t\t\td.hashHead[d.hash] = d.index\n \t\t}\n-\t\tprevLength := length\n-\t\tprevOffset := offset\n-\t\tlength = minMatchLength - 1\n-\t\toffset = 0\n-\t\tminIndex := index - maxOffset\n+\t\tprevLength := d.length\n+\t\tprevOffset := d.offset\n+\t\td.length = minMatchLength - 1\n+\t\td.offset = 0\n+\t\tminIndex := d.index - windowSize\n \t\tif minIndex < 0 {\n \t\t\tminIndex = 0\n \t\t}\n \n-\t\tif chainHead >= minIndex &&\n-\t\t\t(isFastDeflate && lookahead > minMatchLength-1 ||\n-\t\t\t\t!isFastDeflate && lookahead > prevLength && prevLength < lazyMatch) {\n-\t\t\tif newLength, newOffset, ok := d.findMatch(index, chainHead, minMatchLength-1, lookahead); ok {\n-\t\t\t\tlength = newLength\n-\t\t\t\toffset = newOffset\n+\t\tif d.chainHead >= minIndex &&\n+\t\t\t(d.fastSkipHashing != 0 && lookahead > minMatchLength-1 ||\n+\t\t\t\td.fastSkipHashing == 0 && lookahead > prevLength && prevLength < d.lazy) {\n+\t\t\tif newLength, newOffset, ok := d.findMatch(d.index, d.chainHead, minMatchLength-1, lookahead); ok {\n+\t\t\t\td.length = newLength\n+\t\t\t\td.offset = newOffset\n \t\t\t}\n \t\t}\n-\t\tif isFastDeflate && length >= minMatchLength ||\n-\t\t\t!isFastDeflate && prevLength >= minMatchLength && length <= prevLength {\n+\t\tif d.fastSkipHashing != 0 && d.length >= minMatchLength ||\n+\t\t\td.fastSkipHashing == 0 && prevLength >= minMatchLength && d.length <= prevLength {\n \t\t\t// There was a match at the previous step, and the current match is\n \t\t\t// not better. Output the previous match.\n-\t\t\tif isFastDeflate {\n-\t\t\t\ttokens[ti] = matchToken(uint32(length-minMatchLength), uint32(offset-minOffsetSize))\n+\t\t\tif d.fastSkipHashing != 0 {\n+\t\t\t\td.tokens[d.ti] = matchToken(uint32(d.length-minMatchLength), uint32(d.offset-minOffsetSize))\n \t\t\t} else {\n-\t\t\t\ttokens[ti] = matchToken(uint32(prevLength-minMatchLength), uint32(prevOffset-minOffsetSize))\n+\t\t\t\td.tokens[d.ti] = matchToken(uint32(prevLength-minMatchLength), uint32(prevOffset-minOffsetSize))\n \t\t\t}\n-\t\t\tti++\n+\t\t\td.ti++\n \t\t\t// Insert in the hash table all strings up to the end of the match.\n \t\t\t// index and index-1 are already inserted. If there is not enough\n \t\t\t// lookahead, the last two strings are not inserted into the hash\n \t\t\t// table.\n-\t\t\tif length <= l.fastSkipHashing {\n+\t\t\tif d.length <= d.fastSkipHashing {\n \t\t\t\tvar newIndex int\n-\t\t\t\tif isFastDeflate {\n-\t\t\t\t\tnewIndex = index + length\n+\t\t\t\tif d.fastSkipHashing != 0 {\n+\t\t\t\t\tnewIndex = d.index + d.length\n \t\t\t\t} else {\n \t\t\t\t\tnewIndex = prevLength - 1\n \t\t\t\t}\n-\t\t\t\tfor index++; index < newIndex; index++ {\n-\t\t\t\t\tif index < maxInsertIndex {\n-\t\t\t\t\t\thash = (hash<<hashShift + int(d.window[index+2])) & hashMask\n+\t\t\t\tfor d.index++; d.index < newIndex; d.index++ {\n+\t\t\t\t\tif d.index < d.maxInsertIndex {\n+\t\t\t\t\t\td.hash = (d.hash<<hashShift + int(d.window[d.index+2])) & hashMask\n \t\t\t\t\t\t// Get previous value with the same hash.\n \t\t\t\t\t\t// Our chain should point to the previous value.\n-\t\t\t\t\t\td.hashPrev[index&d.windowMask] = d.hashHead[hash]\n+\t\t\t\t\t\td.hashPrev[d.index&windowMask] = d.hashHead[d.hash]\n \t\t\t\t\t\t// Set the head of the hash chain to us.\n-\t\t\t\t\t\td.hashHead[hash] = index\n+\t\t\t\t\t\td.hashHead[d.hash] = d.index\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tif !isFastDeflate {\n-\t\t\t\t\tbyteAvailable = false\n-\t\t\t\t\tlength = minMatchLength - 1\n+\t\t\t\tif d.fastSkipHashing == 0 {\n+\t\t\t\t\td.byteAvailable = false\n+\t\t\t\t\td.length = minMatchLength - 1\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// For matches this long, we don't bother inserting each individual\n \t\t\t\t// item into the table.\n-\t\t\t\tindex += length\n-\t\t\t\thash = (int(d.window[index])<<hashShift + int(d.window[index+1]))\n+\t\t\t\td.index += d.length\n+\t\t\t\td.hash = (int(d.window[d.index])<<hashShift + int(d.window[d.index+1]))\n \t\t\t}\n-\t\t\tif ti == maxFlateBlockTokens {\n+\t\t\tif d.ti == maxFlateBlockTokens {\n \t\t\t\t// The block includes the current character\n-\t\t\t\tif err = d.writeBlock(tokens, index, false); err != nil {\n+\t\t\t\tif d.err = d.writeBlock(d.tokens, d.index, false); d.err != nil {\n \t\t\t\t\treturn\n \t\t\t\t}\n-\t\t\t\tti = 0\n+\t\t\t\td.ti = 0\n \t\t\t}\n \t\t} else {\n-\t\t\tif isFastDeflate || byteAvailable {\n-\t\t\t\ti := index - 1\n-\t\t\t\tif isFastDeflate {\n-\t\t\t\t\ti = index\n+\t\t\tif d.fastSkipHashing != 0 || d.byteAvailable {\n+\t\t\t\ti := d.index - 1\n+\t\t\t\tif d.fastSkipHashing != 0 {\n+\t\t\t\t\ti = d.index\n \t\t\t\t}\n-\t\t\t\ttokens[ti] = literalToken(uint32(d.window[i]) & 0xFF)\n-\t\t\t\tti++\n-\t\t\t\tif ti == maxFlateBlockTokens {\n-\t\t\t\t\tif err = d.writeBlock(tokens, i+1, false); err != nil {\n+\t\t\t\td.tokens[d.ti] = literalToken(uint32(d.window[i]))\n+\t\t\t\td.ti++\n+\t\t\t\tif d.ti == maxFlateBlockTokens {\n+\t\t\t\t\tif d.err = d.writeBlock(d.tokens, i+1, false); d.err != nil {\n \t\t\t\t\t\treturn\n \t\t\t\t\t}\n-\t\t\t\t\tti = 0\n+\t\t\t\t\td.ti = 0\n \t\t\t\t}\n \t\t\t}\n-\t\t\tindex++\n-\t\t\tif !isFastDeflate {\n-\t\t\t\tbyteAvailable = true\n+\t\t\td.index++\n+\t\t\tif d.fastSkipHashing == 0 {\n+\t\t\t\td.byteAvailable = true\n \t\t\t}\n \t\t}\n \t}\n-\treturn\n }\n \n-func (d *compressor) compress(r io.Reader, w io.Writer, level int, logWindowSize uint) (err os.Error) {\n-\td.r = r\n+func (d *compressor) fillStore(b []byte) int {\n+\tn := copy(d.window[d.windowEnd:], b)\n+\td.windowEnd += n\n+\treturn n\n+}\n+\n+func (d *compressor) store() {\n+\tif d.windowEnd > 0 {\n+\t\td.err = d.writeStoredBlock(d.window[:d.windowEnd])\n+\t}\n+\td.windowEnd = 0\n+}\n+\n+func (d *compressor) write(b []byte) (n int, err os.Error) {\n+\tn = len(b)\n+\tb = b[d.fill(d, b):]\n+\tfor len(b) > 0 {\n+\t\td.step(d)\n+\t\tb = b[d.fill(d, b):]\n+\t}\n+\treturn n, d.err\n+}\n+\n+func (d *compressor) syncFlush() os.Error {\n+\td.sync = true\n+\td.step(d)\n+\tif d.err == nil {\n+\t\td.w.writeStoredHeader(0, false)\n+\t\td.w.flush()\n+\t\td.err = d.w.err\n+\t}\n+\td.sync = false\n+\treturn d.err\n+}\n+\n+func (d *compressor) init(w io.Writer, level int) (err os.Error) {\n \td.w = newHuffmanBitWriter(w)\n-\td.level = level\n-\td.logWindowSize = logWindowSize\n \n \tswitch {\n \tcase level == NoCompression:\n-\t\terr = d.storedDeflate()\n+\t\td.window = make([]byte, maxStoreBlockSize)\n+\t\td.fill = (*compressor).fillStore\n+\t\td.step = (*compressor).store\n \tcase level == DefaultCompression:\n-\t\td.level = 6\n+\t\tlevel = 6\n \t\tfallthrough\n \tcase 1 <= level && level <= 9:\n-\t\terr = d.doDeflate()\n+\t\td.compressionLevel = levels[level]\n+\t\td.initDeflate()\n+\t\td.fill = (*compressor).fillDeflate\n+\t\td.step = (*compressor).deflate\n \tdefault:\n \t\treturn WrongValueError{\"level\", 0, 9, int32(level)}\n \t}\n+\treturn nil\n+}\n \n-\tif d.sync {\n-\t\td.syncChan <- err\n-\t\td.sync = false\n-\t}\n-\tif err != nil {\n-\t\treturn err\n+func (d *compressor) close() os.Error {\n+\td.sync = true\n+\td.step(d)\n+\tif d.err != nil {\n+\t\treturn d.err\n \t}\n \tif d.w.writeStoredHeader(0, true); d.w.err != nil {\n \t\treturn d.w.err\n \t}\n-\treturn d.flush()\n+\td.w.flush()\n+\treturn d.w.err\n }\n \n // NewWriter returns a new Writer compressing\n@@ -486,14 +430,9 @@ func (d *compressor) compress(r io.Reader, w io.Writer, level int, logWindowSize\n // compression; it only adds the necessary DEFLATE framing.\n func NewWriter(w io.Writer, level int) *Writer {\n \tconst logWindowSize = logMaxOffsetSize\n-\tvar d compressor\n-\td.syncChan = make(chan os.Error, 1)\n-\tpr, pw := syncPipe()\n-\tgo func() {\n-\t\terr := d.compress(pr, w, level, logWindowSize)\n-\t\tpr.CloseWithError(err)\n-\t}()\n-\treturn &Writer{pw, &d}\n+\tvar dw Writer\n+\tdw.d.init(w, level)\n+\treturn &dw\n }\n \n // NewWriterDict is like NewWriter but initializes the new\n@@ -526,18 +465,13 @@ func (w *dictWriter) Write(b []byte) (n int, err os.Error) {\n // A Writer takes data written to it and writes the compressed\n // form of that data to an underlying writer (see NewWriter).\n type Writer struct {\n-\tw *syncPipeWriter\n-\td *compressor\n+\td compressor\n }\n \n // Write writes data to w, which will eventually write the\n // compressed form of data to its underlying writer.\n func (w *Writer) Write(data []byte) (n int, err os.Error) {\n-\tif len(data) == 0 {\n-\t\t// no point, and nil interferes with sync\n-\t\treturn\n-\t}\n-\treturn w.w.Write(data)\n+\treturn w.d.write(data)\n }\n \n // Flush flushes any pending compressed data to the underlying writer.\n@@ -550,18 +484,10 @@ func (w *Writer) Write(data []byte) (n int, err os.Error) {\n func (w *Writer) Flush() os.Error {\n \t// For more about flushing:\n \t// http://www.bolet.org/~pornin/deflate-flush.html\n-\tif w.d.sync {\n-\t\tpanic(\"compress/flate: double Flush\")\n-\t}\n-\t_, err := w.w.Write(nil)\n-\terr1 := <-w.d.syncChan\n-\tif err == nil {\n-\t\terr = err1\n-\t}\n-\treturn err\n+\treturn w.d.syncFlush()\n }\n \n // Close flushes and closes the writer.\n func (w *Writer) Close() os.Error {\n-\treturn w.w.Close()\n+\treturn w.d.close()\n }"}, {"sha": "930823685f128fa72139c8593efb1b795c067bbd", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -57,7 +57,7 @@ var deflateInflateTests = []*deflateInflateTest{\n \t&deflateInflateTest{[]byte{0x11, 0x12}},\n \t&deflateInflateTest{[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11}},\n \t&deflateInflateTest{[]byte{0x11, 0x10, 0x13, 0x41, 0x21, 0x21, 0x41, 0x13, 0x87, 0x78, 0x13}},\n-\t&deflateInflateTest{getLargeDataChunk()},\n+\t&deflateInflateTest{largeDataChunk()},\n }\n \n var reverseBitsTests = []*reverseBitsTest{\n@@ -71,23 +71,22 @@ var reverseBitsTests = []*reverseBitsTest{\n \t&reverseBitsTest{29, 5, 23},\n }\n \n-func getLargeDataChunk() []byte {\n+func largeDataChunk() []byte {\n \tresult := make([]byte, 100000)\n \tfor i := range result {\n-\t\tresult[i] = byte(int64(i) * int64(i) & 0xFF)\n+\t\tresult[i] = byte(i * i & 0xFF)\n \t}\n \treturn result\n }\n \n func TestDeflate(t *testing.T) {\n \tfor _, h := range deflateTests {\n-\t\tbuffer := bytes.NewBuffer(nil)\n-\t\tw := NewWriter(buffer, h.level)\n+\t\tvar buf bytes.Buffer\n+\t\tw := NewWriter(&buf, h.level)\n \t\tw.Write(h.in)\n \t\tw.Close()\n-\t\tif bytes.Compare(buffer.Bytes(), h.out) != 0 {\n-\t\t\tt.Errorf(\"buffer is wrong; level = %v, buffer.Bytes() = %v, expected output = %v\",\n-\t\t\t\th.level, buffer.Bytes(), h.out)\n+\t\tif !bytes.Equal(buf.Bytes(), h.out) {\n+\t\t\tt.Errorf(\"Deflate(%d, %x) = %x, want %x\", h.level, h.in, buf.Bytes(), h.out)\n \t\t}\n \t}\n }\n@@ -226,7 +225,6 @@ func testSync(t *testing.T, level int, input []byte, name string) {\n \t}\n }\n \n-\n func testToFromWithLevel(t *testing.T, level int, input []byte, name string) os.Error {\n \tbuffer := bytes.NewBuffer(nil)\n \tw := NewWriter(buffer, level)"}, {"sha": "3981df5cba4e4580fa741167f8f54b8a45583d99", "filename": "libgo/go/compress/flate/huffman_bit_writer.go", "status": "modified", "additions": 41, "deletions": 53, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -15,9 +15,6 @@ const (\n \t// The largest offset code.\n \toffsetCodeCount = 30\n \n-\t// The largest offset code in the extensions.\n-\textendedOffsetCodeCount = 42\n-\n \t// The special code used to mark the end of a block.\n \tendBlockMarker = 256\n \n@@ -100,11 +97,11 @@ func newHuffmanBitWriter(w io.Writer) *huffmanBitWriter {\n \treturn &huffmanBitWriter{\n \t\tw:               w,\n \t\tliteralFreq:     make([]int32, maxLit),\n-\t\toffsetFreq:      make([]int32, extendedOffsetCodeCount),\n-\t\tcodegen:         make([]uint8, maxLit+extendedOffsetCodeCount+1),\n+\t\toffsetFreq:      make([]int32, offsetCodeCount),\n+\t\tcodegen:         make([]uint8, maxLit+offsetCodeCount+1),\n \t\tcodegenFreq:     make([]int32, codegenCodeCount),\n \t\tliteralEncoding: newHuffmanEncoder(maxLit),\n-\t\toffsetEncoding:  newHuffmanEncoder(extendedOffsetCodeCount),\n+\t\toffsetEncoding:  newHuffmanEncoder(offsetCodeCount),\n \t\tcodegenEncoding: newHuffmanEncoder(codegenCodeCount),\n \t}\n }\n@@ -185,7 +182,7 @@ func (w *huffmanBitWriter) writeBytes(bytes []byte) {\n \t_, w.err = w.w.Write(bytes)\n }\n \n-// RFC 1951 3.2.7 specifies a special run-length encoding for specifiying\n+// RFC 1951 3.2.7 specifies a special run-length encoding for specifying\n // the literal and offset lengths arrays (which are concatenated into a single\n // array).  This method generates that run-length encoding.\n //\n@@ -279,7 +276,7 @@ func (w *huffmanBitWriter) writeCode(code *huffmanEncoder, literal uint32) {\n //\n //  numLiterals  The number of literals specified in codegen\n //  numOffsets   The number of offsets specified in codegen\n-//  numCodegens  Tne number of codegens used in codegen\n+//  numCodegens  The number of codegens used in codegen\n func (w *huffmanBitWriter) writeDynamicHeader(numLiterals int, numOffsets int, numCodegens int, isEof bool) {\n \tif w.err != nil {\n \t\treturn\n@@ -290,13 +287,7 @@ func (w *huffmanBitWriter) writeDynamicHeader(numLiterals int, numOffsets int, n\n \t}\n \tw.writeBits(firstBits, 3)\n \tw.writeBits(int32(numLiterals-257), 5)\n-\tif numOffsets > offsetCodeCount {\n-\t\t// Extended version of decompressor\n-\t\tw.writeBits(int32(offsetCodeCount+((numOffsets-(1+offsetCodeCount))>>3)), 5)\n-\t\tw.writeBits(int32((numOffsets-(1+offsetCodeCount))&0x7), 3)\n-\t} else {\n-\t\tw.writeBits(int32(numOffsets-1), 5)\n-\t}\n+\tw.writeBits(int32(numOffsets-1), 5)\n \tw.writeBits(int32(numCodegens-4), 4)\n \n \tfor i := 0; i < numCodegens; i++ {\n@@ -368,24 +359,17 @@ func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {\n \ttokens = tokens[0 : n+1]\n \ttokens[n] = endBlockMarker\n \n-\ttotalLength := -1 // Subtract 1 for endBlock.\n \tfor _, t := range tokens {\n \t\tswitch t.typ() {\n \t\tcase literalType:\n \t\t\tw.literalFreq[t.literal()]++\n-\t\t\ttotalLength++\n-\t\t\tbreak\n \t\tcase matchType:\n \t\t\tlength := t.length()\n \t\t\toffset := t.offset()\n-\t\t\ttotalLength += int(length + 3)\n \t\t\tw.literalFreq[lengthCodesStart+lengthCode(length)]++\n \t\t\tw.offsetFreq[offsetCode(offset)]++\n-\t\t\tbreak\n \t\t}\n \t}\n-\tw.literalEncoding.generate(w.literalFreq, 15)\n-\tw.offsetEncoding.generate(w.offsetFreq, 15)\n \n \t// get the number of literals\n \tnumLiterals := len(w.literalFreq)\n@@ -394,15 +378,25 @@ func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {\n \t}\n \t// get the number of offsets\n \tnumOffsets := len(w.offsetFreq)\n-\tfor numOffsets > 1 && w.offsetFreq[numOffsets-1] == 0 {\n+\tfor numOffsets > 0 && w.offsetFreq[numOffsets-1] == 0 {\n \t\tnumOffsets--\n \t}\n+\tif numOffsets == 0 {\n+\t\t// We haven't found a single match. If we want to go with the dynamic encoding,\n+\t\t// we should count at least one offset to be sure that the offset huffman tree could be encoded.\n+\t\tw.offsetFreq[0] = 1\n+\t\tnumOffsets = 1\n+\t}\n+\n+\tw.literalEncoding.generate(w.literalFreq, 15)\n+\tw.offsetEncoding.generate(w.offsetFreq, 15)\n+\n \tstoredBytes := 0\n \tif input != nil {\n \t\tstoredBytes = len(input)\n \t}\n \tvar extraBits int64\n-\tvar storedSize int64\n+\tvar storedSize int64 = math.MaxInt64\n \tif storedBytes <= maxStoreBlockSize && input != nil {\n \t\tstoredSize = int64((storedBytes + 5) * 8)\n \t\t// We only bother calculating the costs of the extra bits required by\n@@ -417,34 +411,29 @@ func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {\n \t\t\t// First four offset codes have extra size = 0.\n \t\t\textraBits += int64(w.offsetFreq[offsetCode]) * int64(offsetExtraBits[offsetCode])\n \t\t}\n-\t} else {\n-\t\tstoredSize = math.MaxInt32\n \t}\n \n-\t// Figure out which generates smaller code, fixed Huffman, dynamic\n-\t// Huffman, or just storing the data.\n-\tvar fixedSize int64 = math.MaxInt64\n-\tif numOffsets <= offsetCodeCount {\n-\t\tfixedSize = int64(3) +\n-\t\t\tfixedLiteralEncoding.bitLength(w.literalFreq) +\n-\t\t\tfixedOffsetEncoding.bitLength(w.offsetFreq) +\n-\t\t\textraBits\n-\t}\n+\t// Figure out smallest code.\n+\t// Fixed Huffman baseline.\n+\tvar size = int64(3) +\n+\t\tfixedLiteralEncoding.bitLength(w.literalFreq) +\n+\t\tfixedOffsetEncoding.bitLength(w.offsetFreq) +\n+\t\textraBits\n+\tvar literalEncoding = fixedLiteralEncoding\n+\tvar offsetEncoding = fixedOffsetEncoding\n+\n+\t// Dynamic Huffman?\n+\tvar numCodegens int\n+\n \t// Generate codegen and codegenFrequencies, which indicates how to encode\n \t// the literalEncoding and the offsetEncoding.\n \tw.generateCodegen(numLiterals, numOffsets)\n \tw.codegenEncoding.generate(w.codegenFreq, 7)\n-\tnumCodegens := len(w.codegenFreq)\n+\tnumCodegens = len(w.codegenFreq)\n \tfor numCodegens > 4 && w.codegenFreq[codegenOrder[numCodegens-1]] == 0 {\n \t\tnumCodegens--\n \t}\n-\textensionSummand := 0\n-\tif numOffsets > offsetCodeCount {\n-\t\textensionSummand = 3\n-\t}\n \tdynamicHeader := int64(3+5+5+4+(3*numCodegens)) +\n-\t\t// Following line is an extension.\n-\t\tint64(extensionSummand) +\n \t\tw.codegenEncoding.bitLength(w.codegenFreq) +\n \t\tint64(extraBits) +\n \t\tint64(w.codegenFreq[16]*2) +\n@@ -454,26 +443,25 @@ func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {\n \t\tw.literalEncoding.bitLength(w.literalFreq) +\n \t\tw.offsetEncoding.bitLength(w.offsetFreq)\n \n-\tif storedSize < fixedSize && storedSize < dynamicSize {\n+\tif dynamicSize < size {\n+\t\tsize = dynamicSize\n+\t\tliteralEncoding = w.literalEncoding\n+\t\toffsetEncoding = w.offsetEncoding\n+\t}\n+\n+\t// Stored bytes?\n+\tif storedSize < size {\n \t\tw.writeStoredHeader(storedBytes, eof)\n \t\tw.writeBytes(input[0:storedBytes])\n \t\treturn\n \t}\n-\tvar literalEncoding *huffmanEncoder\n-\tvar offsetEncoding *huffmanEncoder\n \n-\tif fixedSize <= dynamicSize {\n+\t// Huffman.\n+\tif literalEncoding == fixedLiteralEncoding {\n \t\tw.writeFixedHeader(eof)\n-\t\tliteralEncoding = fixedLiteralEncoding\n-\t\toffsetEncoding = fixedOffsetEncoding\n \t} else {\n-\t\t// Write the header.\n \t\tw.writeDynamicHeader(numLiterals, numOffsets, numCodegens, eof)\n-\t\tliteralEncoding = w.literalEncoding\n-\t\toffsetEncoding = w.offsetEncoding\n \t}\n-\n-\t// Write the tokens.\n \tfor _, t := range tokens {\n \t\tswitch t.typ() {\n \t\tcase literalType:"}, {"sha": "7ed603a4f43361c4b1d34ad4cc2c7df8bcb8dbbe", "filename": "libgo/go/compress/flate/huffman_code.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -363,7 +363,12 @@ func (s literalNodeSorter) Less(i, j int) bool {\n func (s literalNodeSorter) Swap(i, j int) { s.a[i], s.a[j] = s.a[j], s.a[i] }\n \n func sortByFreq(a []literalNode) {\n-\ts := &literalNodeSorter{a, func(i, j int) bool { return a[i].freq < a[j].freq }}\n+\ts := &literalNodeSorter{a, func(i, j int) bool {\n+\t\tif a[i].freq == a[j].freq {\n+\t\t\treturn a[i].literal < a[j].literal\n+\t\t}\n+\t\treturn a[i].freq < a[j].freq\n+\t}}\n \tsort.Sort(s)\n }\n "}, {"sha": "3845f12041045f886f05bd9a17004512379b0a2a", "filename": "libgo/go/compress/flate/inflate.go", "status": "modified", "additions": 155, "deletions": 94, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -77,8 +77,6 @@ type huffmanDecoder struct {\n \n // Initialize Huffman decoding tables from array of code lengths.\n func (h *huffmanDecoder) init(bits []int) bool {\n-\t// TODO(rsc): Return false sometimes.\n-\n \t// Count number of codes of each length,\n \t// compute min and max length.\n \tvar count [maxCodeLen + 1]int\n@@ -197,9 +195,8 @@ type Reader interface {\n \n // Decompress state.\n type decompressor struct {\n-\t// Input/output sources.\n+\t// Input source.\n \tr       Reader\n-\tw       io.Writer\n \troffset int64\n \twoffset int64\n \n@@ -222,38 +219,79 @@ type decompressor struct {\n \n \t// Temporary buffer (avoids repeated allocation).\n \tbuf [4]byte\n+\n+\t// Next step in the decompression,\n+\t// and decompression state.\n+\tstep     func(*decompressor)\n+\tfinal    bool\n+\terr      os.Error\n+\ttoRead   []byte\n+\thl, hd   *huffmanDecoder\n+\tcopyLen  int\n+\tcopyDist int\n }\n \n-func (f *decompressor) inflate() (err os.Error) {\n-\tfinal := false\n-\tfor err == nil && !final {\n-\t\tfor f.nb < 1+2 {\n-\t\t\tif err = f.moreBits(); err != nil {\n-\t\t\t\treturn\n-\t\t\t}\n+func (f *decompressor) nextBlock() {\n+\tif f.final {\n+\t\tif f.hw != f.hp {\n+\t\t\tf.flush((*decompressor).nextBlock)\n+\t\t\treturn\n \t\t}\n-\t\tfinal = f.b&1 == 1\n-\t\tf.b >>= 1\n-\t\ttyp := f.b & 3\n-\t\tf.b >>= 2\n-\t\tf.nb -= 1 + 2\n-\t\tswitch typ {\n-\t\tcase 0:\n-\t\t\terr = f.dataBlock()\n-\t\tcase 1:\n-\t\t\t// compressed, fixed Huffman tables\n-\t\t\terr = f.decodeBlock(&fixedHuffmanDecoder, nil)\n-\t\tcase 2:\n-\t\t\t// compressed, dynamic Huffman tables\n-\t\t\tif err = f.readHuffman(); err == nil {\n-\t\t\t\terr = f.decodeBlock(&f.h1, &f.h2)\n-\t\t\t}\n-\t\tdefault:\n-\t\t\t// 3 is reserved.\n-\t\t\terr = CorruptInputError(f.roffset)\n+\t\tf.err = os.EOF\n+\t\treturn\n+\t}\n+\tfor f.nb < 1+2 {\n+\t\tif f.err = f.moreBits(); f.err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tf.final = f.b&1 == 1\n+\tf.b >>= 1\n+\ttyp := f.b & 3\n+\tf.b >>= 2\n+\tf.nb -= 1 + 2\n+\tswitch typ {\n+\tcase 0:\n+\t\tf.dataBlock()\n+\tcase 1:\n+\t\t// compressed, fixed Huffman tables\n+\t\tf.hl = &fixedHuffmanDecoder\n+\t\tf.hd = nil\n+\t\tf.huffmanBlock()\n+\tcase 2:\n+\t\t// compressed, dynamic Huffman tables\n+\t\tif f.err = f.readHuffman(); f.err != nil {\n+\t\t\tbreak\n+\t\t}\n+\t\tf.hl = &f.h1\n+\t\tf.hd = &f.h2\n+\t\tf.huffmanBlock()\n+\tdefault:\n+\t\t// 3 is reserved.\n+\t\tf.err = CorruptInputError(f.roffset)\n+\t}\n+}\n+\n+func (f *decompressor) Read(b []byte) (int, os.Error) {\n+\tfor {\n+\t\tif len(f.toRead) > 0 {\n+\t\t\tn := copy(b, f.toRead)\n+\t\t\tf.toRead = f.toRead[n:]\n+\t\t\treturn n, nil\n+\t\t}\n+\t\tif f.err != nil {\n+\t\t\treturn 0, f.err\n \t\t}\n+\t\tf.step(f)\n \t}\n-\treturn\n+\tpanic(\"unreachable\")\n+}\n+\n+func (f *decompressor) Close() os.Error {\n+\tif f.err == os.EOF {\n+\t\treturn nil\n+\t}\n+\treturn f.err\n }\n \n // RFC 1951 section 3.2.7.\n@@ -358,11 +396,12 @@ func (f *decompressor) readHuffman() os.Error {\n // hl and hd are the Huffman states for the lit/length values\n // and the distance values, respectively.  If hd == nil, using the\n // fixed distance encoding associated with fixed Huffman blocks.\n-func (f *decompressor) decodeBlock(hl, hd *huffmanDecoder) os.Error {\n+func (f *decompressor) huffmanBlock() {\n \tfor {\n-\t\tv, err := f.huffSym(hl)\n+\t\tv, err := f.huffSym(f.hl)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\tf.err = err\n+\t\t\treturn\n \t\t}\n \t\tvar n uint // number of bits extra\n \t\tvar length int\n@@ -371,13 +410,15 @@ func (f *decompressor) decodeBlock(hl, hd *huffmanDecoder) os.Error {\n \t\t\tf.hist[f.hp] = byte(v)\n \t\t\tf.hp++\n \t\t\tif f.hp == len(f.hist) {\n-\t\t\t\tif err = f.flush(); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n+\t\t\t\t// After the flush, continue this loop.\n+\t\t\t\tf.flush((*decompressor).huffmanBlock)\n+\t\t\t\treturn\n \t\t\t}\n \t\t\tcontinue\n \t\tcase v == 256:\n-\t\t\treturn nil\n+\t\t\t// Done with huffman block; read next block.\n+\t\t\tf.step = (*decompressor).nextBlock\n+\t\t\treturn\n \t\t// otherwise, reference to older data\n \t\tcase v < 265:\n \t\t\tlength = v - (257 - 3)\n@@ -404,7 +445,8 @@ func (f *decompressor) decodeBlock(hl, hd *huffmanDecoder) os.Error {\n \t\tif n > 0 {\n \t\t\tfor f.nb < n {\n \t\t\t\tif err = f.moreBits(); err != nil {\n-\t\t\t\t\treturn err\n+\t\t\t\t\tf.err = err\n+\t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t}\n \t\t\tlength += int(f.b & uint32(1<<n-1))\n@@ -413,33 +455,37 @@ func (f *decompressor) decodeBlock(hl, hd *huffmanDecoder) os.Error {\n \t\t}\n \n \t\tvar dist int\n-\t\tif hd == nil {\n+\t\tif f.hd == nil {\n \t\t\tfor f.nb < 5 {\n \t\t\t\tif err = f.moreBits(); err != nil {\n-\t\t\t\t\treturn err\n+\t\t\t\t\tf.err = err\n+\t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t}\n \t\t\tdist = int(reverseByte[(f.b&0x1F)<<3])\n \t\t\tf.b >>= 5\n \t\t\tf.nb -= 5\n \t\t} else {\n-\t\t\tif dist, err = f.huffSym(hd); err != nil {\n-\t\t\t\treturn err\n+\t\t\tif dist, err = f.huffSym(f.hd); err != nil {\n+\t\t\t\tf.err = err\n+\t\t\t\treturn\n \t\t\t}\n \t\t}\n \n \t\tswitch {\n \t\tcase dist < 4:\n \t\t\tdist++\n \t\tcase dist >= 30:\n-\t\t\treturn CorruptInputError(f.roffset)\n+\t\t\tf.err = CorruptInputError(f.roffset)\n+\t\t\treturn\n \t\tdefault:\n \t\t\tnb := uint(dist-2) >> 1\n \t\t\t// have 1 bit in bottom of dist, need nb more.\n \t\t\textra := (dist & 1) << nb\n \t\t\tfor f.nb < nb {\n \t\t\t\tif err = f.moreBits(); err != nil {\n-\t\t\t\t\treturn err\n+\t\t\t\t\tf.err = err\n+\t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t}\n \t\t\textra |= int(f.b & uint32(1<<nb-1))\n@@ -450,12 +496,14 @@ func (f *decompressor) decodeBlock(hl, hd *huffmanDecoder) os.Error {\n \n \t\t// Copy history[-dist:-dist+length] into output.\n \t\tif dist > len(f.hist) {\n-\t\t\treturn InternalError(\"bad history distance\")\n+\t\t\tf.err = InternalError(\"bad history distance\")\n+\t\t\treturn\n \t\t}\n \n \t\t// No check on length; encoding can be prescient.\n \t\tif !f.hfull && dist > f.hp {\n-\t\t\treturn CorruptInputError(f.roffset)\n+\t\t\tf.err = CorruptInputError(f.roffset)\n+\t\t\treturn\n \t\t}\n \n \t\tp := f.hp - dist\n@@ -467,9 +515,11 @@ func (f *decompressor) decodeBlock(hl, hd *huffmanDecoder) os.Error {\n \t\t\tf.hp++\n \t\t\tp++\n \t\t\tif f.hp == len(f.hist) {\n-\t\t\t\tif err = f.flush(); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n+\t\t\t\t// After flush continue copying out of history.\n+\t\t\t\tf.copyLen = length - (i + 1)\n+\t\t\t\tf.copyDist = dist\n+\t\t\t\tf.flush((*decompressor).copyHuff)\n+\t\t\t\treturn\n \t\t\t}\n \t\t\tif p == len(f.hist) {\n \t\t\t\tp = 0\n@@ -479,8 +529,33 @@ func (f *decompressor) decodeBlock(hl, hd *huffmanDecoder) os.Error {\n \tpanic(\"unreached\")\n }\n \n+func (f *decompressor) copyHuff() {\n+\tlength := f.copyLen\n+\tdist := f.copyDist\n+\tp := f.hp - dist\n+\tif p < 0 {\n+\t\tp += len(f.hist)\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tf.hist[f.hp] = f.hist[p]\n+\t\tf.hp++\n+\t\tp++\n+\t\tif f.hp == len(f.hist) {\n+\t\t\tf.copyLen = length - (i + 1)\n+\t\t\tf.flush((*decompressor).copyHuff)\n+\t\t\treturn\n+\t\t}\n+\t\tif p == len(f.hist) {\n+\t\t\tp = 0\n+\t\t}\n+\t}\n+\n+\t// Continue processing Huffman block.\n+\tf.huffmanBlock()\n+}\n+\n // Copy a single uncompressed data block from input to output.\n-func (f *decompressor) dataBlock() os.Error {\n+func (f *decompressor) dataBlock() {\n \t// Uncompressed.\n \t// Discard current half-byte.\n \tf.nb = 0\n@@ -490,21 +565,30 @@ func (f *decompressor) dataBlock() os.Error {\n \tnr, err := io.ReadFull(f.r, f.buf[0:4])\n \tf.roffset += int64(nr)\n \tif err != nil {\n-\t\treturn &ReadError{f.roffset, err}\n+\t\tf.err = &ReadError{f.roffset, err}\n+\t\treturn\n \t}\n \tn := int(f.buf[0]) | int(f.buf[1])<<8\n \tnn := int(f.buf[2]) | int(f.buf[3])<<8\n \tif uint16(nn) != uint16(^n) {\n-\t\treturn CorruptInputError(f.roffset)\n+\t\tf.err = CorruptInputError(f.roffset)\n+\t\treturn\n \t}\n \n \tif n == 0 {\n \t\t// 0-length block means sync\n-\t\treturn f.flush()\n+\t\tf.flush((*decompressor).nextBlock)\n+\t\treturn\n \t}\n \n-\t// Read len bytes into history,\n-\t// writing as history fills.\n+\tf.copyLen = n\n+\tf.copyData()\n+}\n+\n+func (f *decompressor) copyData() {\n+\t// Read f.dataLen bytes into history,\n+\t// pausing for reads as history fills.\n+\tn := f.copyLen\n \tfor n > 0 {\n \t\tm := len(f.hist) - f.hp\n \t\tif m > n {\n@@ -513,17 +597,18 @@ func (f *decompressor) dataBlock() os.Error {\n \t\tm, err := io.ReadFull(f.r, f.hist[f.hp:f.hp+m])\n \t\tf.roffset += int64(m)\n \t\tif err != nil {\n-\t\t\treturn &ReadError{f.roffset, err}\n+\t\t\tf.err = &ReadError{f.roffset, err}\n+\t\t\treturn\n \t\t}\n \t\tn -= m\n \t\tf.hp += m\n \t\tif f.hp == len(f.hist) {\n-\t\t\tif err = f.flush(); err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n+\t\t\tf.copyLen = n\n+\t\t\tf.flush((*decompressor).copyData)\n+\t\t\treturn\n \t\t}\n \t}\n-\treturn nil\n+\tf.step = (*decompressor).nextBlock\n }\n \n func (f *decompressor) setDict(dict []byte) {\n@@ -579,25 +664,16 @@ func (f *decompressor) huffSym(h *huffmanDecoder) (int, os.Error) {\n }\n \n // Flush any buffered output to the underlying writer.\n-func (f *decompressor) flush() os.Error {\n-\tif f.hw == f.hp {\n-\t\treturn nil\n-\t}\n-\tn, err := f.w.Write(f.hist[f.hw:f.hp])\n-\tif n != f.hp-f.hw && err == nil {\n-\t\terr = io.ErrShortWrite\n-\t}\n-\tif err != nil {\n-\t\treturn &WriteError{f.woffset, err}\n-\t}\n+func (f *decompressor) flush(step func(*decompressor)) {\n+\tf.toRead = f.hist[f.hw:f.hp]\n \tf.woffset += int64(f.hp - f.hw)\n \tf.hw = f.hp\n \tif f.hp == len(f.hist) {\n \t\tf.hp = 0\n \t\tf.hw = 0\n \t\tf.hfull = true\n \t}\n-\treturn nil\n+\tf.step = step\n }\n \n func makeReader(r io.Reader) Reader {\n@@ -607,30 +683,15 @@ func makeReader(r io.Reader) Reader {\n \treturn bufio.NewReader(r)\n }\n \n-// decompress reads DEFLATE-compressed data from r and writes\n-// the uncompressed data to w.\n-func (f *decompressor) decompress(r io.Reader, w io.Writer) os.Error {\n-\tf.r = makeReader(r)\n-\tf.w = w\n-\tf.woffset = 0\n-\tif err := f.inflate(); err != nil {\n-\t\treturn err\n-\t}\n-\tif err := f.flush(); err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n // NewReader returns a new ReadCloser that can be used\n // to read the uncompressed version of r.  It is the caller's\n // responsibility to call Close on the ReadCloser when\n // finished reading.\n func NewReader(r io.Reader) io.ReadCloser {\n \tvar f decompressor\n-\tpr, pw := io.Pipe()\n-\tgo func() { pw.CloseWithError(f.decompress(r, pw)) }()\n-\treturn pr\n+\tf.r = makeReader(r)\n+\tf.step = (*decompressor).nextBlock\n+\treturn &f\n }\n \n // NewReaderDict is like NewReader but initializes the reader\n@@ -641,7 +702,7 @@ func NewReader(r io.Reader) io.ReadCloser {\n func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser {\n \tvar f decompressor\n \tf.setDict(dict)\n-\tpr, pw := io.Pipe()\n-\tgo func() { pw.CloseWithError(f.decompress(r, pw)) }()\n-\treturn pr\n+\tf.r = makeReader(r)\n+\tf.step = (*decompressor).nextBlock\n+\treturn &f\n }"}, {"sha": "6ac9293d771b96aa9013f7a1cb7b2b1d39197b33", "filename": "libgo/go/compress/gzip/gunzip.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -36,8 +36,8 @@ func makeReader(r io.Reader) flate.Reader {\n \treturn bufio.NewReader(r)\n }\n \n-var HeaderError os.Error = os.ErrorString(\"invalid gzip header\")\n-var ChecksumError os.Error = os.ErrorString(\"gzip checksum error\")\n+var HeaderError = os.NewError(\"invalid gzip header\")\n+var ChecksumError = os.NewError(\"gzip checksum error\")\n \n // The gzip file stores a header giving metadata about the compressed file.\n // That header is exposed as the fields of the Compressor and Decompressor structs."}, {"sha": "121e627e6b234f98de3ae0b867adde1fd3522aea", "filename": "libgo/go/compress/gzip/gzip_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -11,7 +11,7 @@ import (\n )\n \n // pipe creates two ends of a pipe that gzip and gunzip, and runs dfunc at the\n-// writer end and ifunc at the reader end.\n+// writer end and cfunc at the reader end.\n func pipe(t *testing.T, dfunc func(*Compressor), cfunc func(*Decompressor)) {\n \tpiper, pipew := io.Pipe()\n \tdefer piper.Close()"}, {"sha": "21231c8e519a8882c712f59fceac1804e20b76a3", "filename": "libgo/go/compress/lzw/reader.go", "status": "modified", "additions": 133, "deletions": 93, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -32,13 +32,49 @@ const (\n \tMSB\n )\n \n+const (\n+\tmaxWidth           = 12\n+\tdecoderInvalidCode = 0xffff\n+\tflushBuffer        = 1 << maxWidth\n+)\n+\n // decoder is the state from which the readXxx method converts a byte\n // stream into a code stream.\n type decoder struct {\n-\tr     io.ByteReader\n-\tbits  uint32\n-\tnBits uint\n-\twidth uint\n+\tr        io.ByteReader\n+\tbits     uint32\n+\tnBits    uint\n+\twidth    uint\n+\tread     func(*decoder) (uint16, os.Error) // readLSB or readMSB\n+\tlitWidth int                               // width in bits of literal codes\n+\terr      os.Error\n+\n+\t// The first 1<<litWidth codes are literal codes.\n+\t// The next two codes mean clear and EOF.\n+\t// Other valid codes are in the range [lo, hi] where lo := clear + 2,\n+\t// with the upper bound incrementing on each code seen.\n+\t// overflow is the code at which hi overflows the code width.\n+\t// last is the most recently seen code, or decoderInvalidCode.\n+\tclear, eof, hi, overflow, last uint16\n+\n+\t// Each code c in [lo, hi] expands to two or more bytes. For c != hi:\n+\t//   suffix[c] is the last of these bytes.\n+\t//   prefix[c] is the code for all but the last byte.\n+\t//   This code can either be a literal code or another code in [lo, c).\n+\t// The c == hi case is a special case.\n+\tsuffix [1 << maxWidth]uint8\n+\tprefix [1 << maxWidth]uint16\n+\n+\t// output is the temporary output buffer.\n+\t// Literal codes are accumulated from the start of the buffer.\n+\t// Non-literal codes decode to a sequence of suffixes that are first\n+\t// written right-to-left from the end of the buffer before being copied\n+\t// to the start of the buffer.\n+\t// It is flushed when it contains >= 1<<maxWidth bytes,\n+\t// so that there is always room to decode an entire code.\n+\toutput [2 * 1 << maxWidth]byte\n+\to      int    // write index into output\n+\ttoRead []byte // bytes to return from Read\n }\n \n // readLSB returns the next code for \"Least Significant Bits first\" data.\n@@ -73,141 +109,145 @@ func (d *decoder) readMSB() (uint16, os.Error) {\n \treturn code, nil\n }\n \n-// decode decompresses bytes from r and writes them to pw.\n-// read specifies how to decode bytes into codes.\n-// litWidth is the width in bits of literal codes.\n-func decode(r io.Reader, read func(*decoder) (uint16, os.Error), litWidth int, pw *io.PipeWriter) {\n-\tbr, ok := r.(io.ByteReader)\n-\tif !ok {\n-\t\tbr = bufio.NewReader(r)\n+func (d *decoder) Read(b []byte) (int, os.Error) {\n+\tfor {\n+\t\tif len(d.toRead) > 0 {\n+\t\t\tn := copy(b, d.toRead)\n+\t\t\td.toRead = d.toRead[n:]\n+\t\t\treturn n, nil\n+\t\t}\n+\t\tif d.err != nil {\n+\t\t\treturn 0, d.err\n+\t\t}\n+\t\td.decode()\n \t}\n-\tpw.CloseWithError(decode1(pw, br, read, uint(litWidth)))\n+\tpanic(\"unreachable\")\n }\n \n-func decode1(pw *io.PipeWriter, r io.ByteReader, read func(*decoder) (uint16, os.Error), litWidth uint) os.Error {\n-\tconst (\n-\t\tmaxWidth    = 12\n-\t\tinvalidCode = 0xffff\n-\t)\n-\td := decoder{r, 0, 0, 1 + litWidth}\n-\tw := bufio.NewWriter(pw)\n-\t// The first 1<<litWidth codes are literal codes.\n-\t// The next two codes mean clear and EOF.\n-\t// Other valid codes are in the range [lo, hi] where lo := clear + 2,\n-\t// with the upper bound incrementing on each code seen.\n-\tclear := uint16(1) << litWidth\n-\teof, hi := clear+1, clear+1\n-\t// overflow is the code at which hi overflows the code width.\n-\toverflow := uint16(1) << d.width\n-\tvar (\n-\t\t// Each code c in [lo, hi] expands to two or more bytes. For c != hi:\n-\t\t//   suffix[c] is the last of these bytes.\n-\t\t//   prefix[c] is the code for all but the last byte.\n-\t\t//   This code can either be a literal code or another code in [lo, c).\n-\t\t// The c == hi case is a special case.\n-\t\tsuffix [1 << maxWidth]uint8\n-\t\tprefix [1 << maxWidth]uint16\n-\t\t// buf is a scratch buffer for reconstituting the bytes that a code expands to.\n-\t\t// Code suffixes are written right-to-left from the end of the buffer.\n-\t\tbuf [1 << maxWidth]byte\n-\t)\n-\n+// decode decompresses bytes from r and leaves them in d.toRead.\n+// read specifies how to decode bytes into codes.\n+// litWidth is the width in bits of literal codes.\n+func (d *decoder) decode() {\n \t// Loop over the code stream, converting codes into decompressed bytes.\n-\tlast := uint16(invalidCode)\n \tfor {\n-\t\tcode, err := read(&d)\n+\t\tcode, err := d.read(d)\n \t\tif err != nil {\n \t\t\tif err == os.EOF {\n \t\t\t\terr = io.ErrUnexpectedEOF\n \t\t\t}\n-\t\t\treturn err\n+\t\t\td.err = err\n+\t\t\treturn\n \t\t}\n \t\tswitch {\n-\t\tcase code < clear:\n+\t\tcase code < d.clear:\n \t\t\t// We have a literal code.\n-\t\t\tif err := w.WriteByte(uint8(code)); err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\tif last != invalidCode {\n+\t\t\td.output[d.o] = uint8(code)\n+\t\t\td.o++\n+\t\t\tif d.last != decoderInvalidCode {\n \t\t\t\t// Save what the hi code expands to.\n-\t\t\t\tsuffix[hi] = uint8(code)\n-\t\t\t\tprefix[hi] = last\n+\t\t\t\td.suffix[d.hi] = uint8(code)\n+\t\t\t\td.prefix[d.hi] = d.last\n \t\t\t}\n-\t\tcase code == clear:\n-\t\t\td.width = 1 + litWidth\n-\t\t\thi = eof\n-\t\t\toverflow = 1 << d.width\n-\t\t\tlast = invalidCode\n+\t\tcase code == d.clear:\n+\t\t\td.width = 1 + uint(d.litWidth)\n+\t\t\td.hi = d.eof\n+\t\t\td.overflow = 1 << d.width\n+\t\t\td.last = decoderInvalidCode\n \t\t\tcontinue\n-\t\tcase code == eof:\n-\t\t\treturn w.Flush()\n-\t\tcase code <= hi:\n-\t\t\tc, i := code, len(buf)-1\n-\t\t\tif code == hi {\n+\t\tcase code == d.eof:\n+\t\t\td.flush()\n+\t\t\td.err = os.EOF\n+\t\t\treturn\n+\t\tcase code <= d.hi:\n+\t\t\tc, i := code, len(d.output)-1\n+\t\t\tif code == d.hi {\n \t\t\t\t// code == hi is a special case which expands to the last expansion\n \t\t\t\t// followed by the head of the last expansion. To find the head, we walk\n \t\t\t\t// the prefix chain until we find a literal code.\n-\t\t\t\tc = last\n-\t\t\t\tfor c >= clear {\n-\t\t\t\t\tc = prefix[c]\n+\t\t\t\tc = d.last\n+\t\t\t\tfor c >= d.clear {\n+\t\t\t\t\tc = d.prefix[c]\n \t\t\t\t}\n-\t\t\t\tbuf[i] = uint8(c)\n+\t\t\t\td.output[i] = uint8(c)\n \t\t\t\ti--\n-\t\t\t\tc = last\n+\t\t\t\tc = d.last\n \t\t\t}\n-\t\t\t// Copy the suffix chain into buf and then write that to w.\n-\t\t\tfor c >= clear {\n-\t\t\t\tbuf[i] = suffix[c]\n+\t\t\t// Copy the suffix chain into output and then write that to w.\n+\t\t\tfor c >= d.clear {\n+\t\t\t\td.output[i] = d.suffix[c]\n \t\t\t\ti--\n-\t\t\t\tc = prefix[c]\n+\t\t\t\tc = d.prefix[c]\n \t\t\t}\n-\t\t\tbuf[i] = uint8(c)\n-\t\t\tif _, err := w.Write(buf[i:]); err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\tif last != invalidCode {\n+\t\t\td.output[i] = uint8(c)\n+\t\t\td.o += copy(d.output[d.o:], d.output[i:])\n+\t\t\tif d.last != decoderInvalidCode {\n \t\t\t\t// Save what the hi code expands to.\n-\t\t\t\tsuffix[hi] = uint8(c)\n-\t\t\t\tprefix[hi] = last\n+\t\t\t\td.suffix[d.hi] = uint8(c)\n+\t\t\t\td.prefix[d.hi] = d.last\n \t\t\t}\n \t\tdefault:\n-\t\t\treturn os.NewError(\"lzw: invalid code\")\n+\t\t\td.err = os.NewError(\"lzw: invalid code\")\n+\t\t\treturn\n \t\t}\n-\t\tlast, hi = code, hi+1\n-\t\tif hi >= overflow {\n+\t\td.last, d.hi = code, d.hi+1\n+\t\tif d.hi >= d.overflow {\n \t\t\tif d.width == maxWidth {\n-\t\t\t\tlast = invalidCode\n-\t\t\t\tcontinue\n+\t\t\t\td.last = decoderInvalidCode\n+\t\t\t} else {\n+\t\t\t\td.width++\n+\t\t\t\td.overflow <<= 1\n \t\t\t}\n-\t\t\td.width++\n-\t\t\toverflow <<= 1\n+\t\t}\n+\t\tif d.o >= flushBuffer {\n+\t\t\td.flush()\n+\t\t\treturn\n \t\t}\n \t}\n \tpanic(\"unreachable\")\n }\n \n+func (d *decoder) flush() {\n+\td.toRead = d.output[:d.o]\n+\td.o = 0\n+}\n+\n+func (d *decoder) Close() os.Error {\n+\td.err = os.EINVAL // in case any Reads come along\n+\treturn nil\n+}\n+\n // NewReader creates a new io.ReadCloser that satisfies reads by decompressing\n // the data read from r.\n // It is the caller's responsibility to call Close on the ReadCloser when\n // finished reading.\n // The number of bits to use for literal codes, litWidth, must be in the\n // range [2,8] and is typically 8.\n func NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser {\n-\tpr, pw := io.Pipe()\n-\tvar read func(*decoder) (uint16, os.Error)\n+\td := new(decoder)\n \tswitch order {\n \tcase LSB:\n-\t\tread = (*decoder).readLSB\n+\t\td.read = (*decoder).readLSB\n \tcase MSB:\n-\t\tread = (*decoder).readMSB\n+\t\td.read = (*decoder).readMSB\n \tdefault:\n-\t\tpw.CloseWithError(os.NewError(\"lzw: unknown order\"))\n-\t\treturn pr\n+\t\td.err = os.NewError(\"lzw: unknown order\")\n+\t\treturn d\n \t}\n \tif litWidth < 2 || 8 < litWidth {\n-\t\tpw.CloseWithError(fmt.Errorf(\"lzw: litWidth %d out of range\", litWidth))\n-\t\treturn pr\n+\t\td.err = fmt.Errorf(\"lzw: litWidth %d out of range\", litWidth)\n+\t\treturn d\n \t}\n-\tgo decode(r, read, litWidth, pw)\n-\treturn pr\n+\tif br, ok := r.(io.ByteReader); ok {\n+\t\td.r = br\n+\t} else {\n+\t\td.r = bufio.NewReader(r)\n+\t}\n+\td.litWidth = litWidth\n+\td.width = 1 + uint(litWidth)\n+\td.clear = uint16(1) << uint(litWidth)\n+\td.eof, d.hi = d.clear+1, d.clear+1\n+\td.overflow = uint16(1) << d.width\n+\td.last = decoderInvalidCode\n+\n+\treturn d\n }"}, {"sha": "f8042b0d191334f665d291853711826065f6ec0f", "filename": "libgo/go/compress/lzw/reader_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -84,7 +84,7 @@ var lzwTests = []lzwTest{\n func TestReader(t *testing.T) {\n \tb := bytes.NewBuffer(nil)\n \tfor _, tt := range lzwTests {\n-\t\td := strings.Split(tt.desc, \";\", -1)\n+\t\td := strings.Split(tt.desc, \";\")\n \t\tvar order Order\n \t\tswitch d[1] {\n \t\tcase \"LSB\":"}, {"sha": "4c5e522f94316cd5b726c6f68fcc749911a0a37b", "filename": "libgo/go/compress/lzw/writer_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -77,13 +77,13 @@ func testFile(t *testing.T, fn string, order Order, litWidth int) {\n \t\tt.Errorf(\"%s (order=%d litWidth=%d): %v\", fn, order, litWidth, err1)\n \t\treturn\n \t}\n-\tif len(b0) != len(b1) {\n-\t\tt.Errorf(\"%s (order=%d litWidth=%d): length mismatch %d versus %d\", fn, order, litWidth, len(b0), len(b1))\n+\tif len(b1) != len(b0) {\n+\t\tt.Errorf(\"%s (order=%d litWidth=%d): length mismatch %d != %d\", fn, order, litWidth, len(b1), len(b0))\n \t\treturn\n \t}\n \tfor i := 0; i < len(b0); i++ {\n-\t\tif b0[i] != b1[i] {\n-\t\t\tt.Errorf(\"%s (order=%d litWidth=%d): mismatch at %d, 0x%02x versus 0x%02x\\n\", fn, order, litWidth, i, b0[i], b1[i])\n+\t\tif b1[i] != b0[i] {\n+\t\t\tt.Errorf(\"%s (order=%d litWidth=%d): mismatch at %d, 0x%02x != 0x%02x\\n\", fn, order, litWidth, i, b1[i], b0[i])\n \t\t\treturn\n \t\t}\n \t}"}, {"sha": "78dabdf4d8c9df25918c554a284dbae343d3b8a5", "filename": "libgo/go/compress/zlib/reader.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -34,9 +34,9 @@ import (\n \n const zlibDeflate = 8\n \n-var ChecksumError os.Error = os.ErrorString(\"zlib checksum error\")\n-var HeaderError os.Error = os.ErrorString(\"invalid zlib header\")\n-var DictionaryError os.Error = os.ErrorString(\"invalid zlib dictionary\")\n+var ChecksumError = os.NewError(\"zlib checksum error\")\n+var HeaderError = os.NewError(\"invalid zlib header\")\n+var DictionaryError = os.NewError(\"invalid zlib dictionary\")\n \n type reader struct {\n \tr            flate.Reader"}, {"sha": "8f86e9c4ce342a48baa4bc23b1d8b48e09f1eeca", "filename": "libgo/go/compress/zlib/writer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -89,7 +89,7 @@ func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, os.Error) {\n \t\t}\n \t}\n \tz.w = w\n-\tz.compressor = flate.NewWriter(w, level)\n+\tz.compressor = flate.NewWriterDict(w, level, dict)\n \tz.digest = adler32.New()\n \treturn z, nil\n }"}, {"sha": "32f05ab68560c6027af38e14b1b5ed3b887aba83", "filename": "libgo/go/compress/zlib/writer_test.go", "status": "modified", "additions": 58, "deletions": 37, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -5,6 +5,8 @@\n package zlib\n \n import (\n+\t\"bytes\"\n+\t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n@@ -16,59 +18,54 @@ var filenames = []string{\n \t\"../testdata/pi.txt\",\n }\n \n+var data = []string{\n+\t\"test a reasonable sized string that can be compressed\",\n+}\n+\n // Tests that compressing and then decompressing the given file at the given compression level and dictionary\n // yields equivalent bytes to the original file.\n func testFileLevelDict(t *testing.T, fn string, level int, d string) {\n-\t// Read dictionary, if given.\n-\tvar dict []byte\n-\tif d != \"\" {\n-\t\tdict = []byte(d)\n-\t}\n-\n \t// Read the file, as golden output.\n \tgolden, err := os.Open(fn)\n \tif err != nil {\n \t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err)\n \t\treturn\n \t}\n \tdefer golden.Close()\n-\n-\t// Read the file again, and push it through a pipe that compresses at the write end, and decompresses at the read end.\n-\traw, err := os.Open(fn)\n-\tif err != nil {\n-\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err)\n+\tb0, err0 := ioutil.ReadAll(golden)\n+\tif err0 != nil {\n+\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err0)\n \t\treturn\n \t}\n+\ttestLevelDict(t, fn, b0, level, d)\n+}\n+\n+func testLevelDict(t *testing.T, fn string, b0 []byte, level int, d string) {\n+\t// Make dictionary, if given.\n+\tvar dict []byte\n+\tif d != \"\" {\n+\t\tdict = []byte(d)\n+\t}\n+\n+\t// Push data through a pipe that compresses at the write end, and decompresses at the read end.\n \tpiper, pipew := io.Pipe()\n \tdefer piper.Close()\n \tgo func() {\n-\t\tdefer raw.Close()\n \t\tdefer pipew.Close()\n \t\tzlibw, err := NewWriterDict(pipew, level, dict)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err)\n \t\t\treturn\n \t\t}\n \t\tdefer zlibw.Close()\n-\t\tvar b [1024]byte\n-\t\tfor {\n-\t\t\tn, err0 := raw.Read(b[0:])\n-\t\t\tif err0 != nil && err0 != os.EOF {\n-\t\t\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err0)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\t_, err1 := zlibw.Write(b[0:n])\n-\t\t\tif err1 == os.EPIPE {\n-\t\t\t\t// Fail, but do not report the error, as some other (presumably reportable) error broke the pipe.\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif err1 != nil {\n-\t\t\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err1)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif err0 == os.EOF {\n-\t\t\t\tbreak\n-\t\t\t}\n+\t\t_, err = zlibw.Write(b0)\n+\t\tif err == os.EPIPE {\n+\t\t\t// Fail, but do not report the error, as some other (presumably reported) error broke the pipe.\n+\t\t\treturn\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err)\n+\t\t\treturn\n \t\t}\n \t}()\n \tzlibr, err := NewReaderDict(piper, dict)\n@@ -78,13 +75,8 @@ func testFileLevelDict(t *testing.T, fn string, level int, d string) {\n \t}\n \tdefer zlibr.Close()\n \n-\t// Compare the two.\n-\tb0, err0 := ioutil.ReadAll(golden)\n+\t// Compare the decompressed data.\n \tb1, err1 := ioutil.ReadAll(zlibr)\n-\tif err0 != nil {\n-\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err0)\n-\t\treturn\n-\t}\n \tif err1 != nil {\n \t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err1)\n \t\treturn\n@@ -102,6 +94,18 @@ func testFileLevelDict(t *testing.T, fn string, level int, d string) {\n }\n \n func TestWriter(t *testing.T) {\n+\tfor i, s := range data {\n+\t\tb := []byte(s)\n+\t\ttag := fmt.Sprintf(\"#%d\", i)\n+\t\ttestLevelDict(t, tag, b, DefaultCompression, \"\")\n+\t\ttestLevelDict(t, tag, b, NoCompression, \"\")\n+\t\tfor level := BestSpeed; level <= BestCompression; level++ {\n+\t\t\ttestLevelDict(t, tag, b, level, \"\")\n+\t\t}\n+\t}\n+}\n+\n+func TestWriterBig(t *testing.T) {\n \tfor _, fn := range filenames {\n \t\ttestFileLevelDict(t, fn, DefaultCompression, \"\")\n \t\ttestFileLevelDict(t, fn, NoCompression, \"\")\n@@ -121,3 +125,20 @@ func TestWriterDict(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestWriterDictIsUsed(t *testing.T) {\n+\tvar input = []byte(\"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\")\n+\tbuf := bytes.NewBuffer(nil)\n+\tcompressor, err := NewWriterDict(buf, BestCompression, input)\n+\tif err != nil {\n+\t\tt.Errorf(\"error in NewWriterDict: %s\", err)\n+\t\treturn\n+\t}\n+\tcompressor.Write(input)\n+\tcompressor.Close()\n+\tconst expectedMaxSize = 25\n+\toutput := buf.Bytes()\n+\tif len(output) > expectedMaxSize {\n+\t\tt.Errorf(\"result too large (got %d, want <= %d bytes). Is the dictionary being used?\", len(output), expectedMaxSize)\n+\t}\n+}"}, {"sha": "2dfe5b43ca738c107ef1c8a440ede3e1d8af93eb", "filename": "libgo/go/container/heap/heap.go", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -21,8 +21,7 @@ type Interface interface {\n \tPop() interface{}\n }\n \n-\n-// A heaper must be initialized before any of the heap operations\n+// A heap must be initialized before any of the heap operations\n // can be used. Init is idempotent with respect to the heap invariants\n // and may be called whenever the heap invariants may have been invalidated.\n // Its complexity is O(n) where n = h.Len().\n@@ -35,7 +34,6 @@ func Init(h Interface) {\n \t}\n }\n \n-\n // Push pushes the element x onto the heap. The complexity is\n // O(log(n)) where n = h.Len().\n //\n@@ -44,7 +42,6 @@ func Push(h Interface, x interface{}) {\n \tup(h, h.Len()-1)\n }\n \n-\n // Pop removes the minimum element (according to Less) from the heap\n // and returns it. The complexity is O(log(n)) where n = h.Len().\n // Same as Remove(h, 0).\n@@ -56,7 +53,6 @@ func Pop(h Interface) interface{} {\n \treturn h.Pop()\n }\n \n-\n // Remove removes the element at index i from the heap.\n // The complexity is O(log(n)) where n = h.Len().\n //\n@@ -70,7 +66,6 @@ func Remove(h Interface, i int) interface{} {\n \treturn h.Pop()\n }\n \n-\n func up(h Interface, j int) {\n \tfor {\n \t\ti := (j - 1) / 2 // parent\n@@ -82,7 +77,6 @@ func up(h Interface, j int) {\n \t}\n }\n \n-\n func down(h Interface, i, n int) {\n \tfor {\n \t\tj1 := 2*i + 1"}, {"sha": "c5c1f76e1e1e5a0248bb64994969b17d4eabaac4", "filename": "libgo/go/container/heap/heap_test.go", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -10,17 +10,14 @@ import (\n \t. \"container/heap\"\n )\n \n-\n type myHeap struct {\n \t// A vector.Vector implements sort.Interface except for Less,\n \t// and it implements Push and Pop as required for heap.Interface.\n \tvector.Vector\n }\n \n-\n func (h *myHeap) Less(i, j int) bool { return h.At(i).(int) < h.At(j).(int) }\n \n-\n func (h *myHeap) verify(t *testing.T, i int) {\n \tn := h.Len()\n \tj1 := 2*i + 1\n@@ -41,7 +38,6 @@ func (h *myHeap) verify(t *testing.T, i int) {\n \t}\n }\n \n-\n func TestInit0(t *testing.T) {\n \th := new(myHeap)\n \tfor i := 20; i > 0; i-- {\n@@ -59,7 +55,6 @@ func TestInit0(t *testing.T) {\n \t}\n }\n \n-\n func TestInit1(t *testing.T) {\n \th := new(myHeap)\n \tfor i := 20; i > 0; i-- {\n@@ -77,7 +72,6 @@ func TestInit1(t *testing.T) {\n \t}\n }\n \n-\n func Test(t *testing.T) {\n \th := new(myHeap)\n \th.verify(t, 0)\n@@ -105,7 +99,6 @@ func Test(t *testing.T) {\n \t}\n }\n \n-\n func TestRemove0(t *testing.T) {\n \th := new(myHeap)\n \tfor i := 0; i < 10; i++ {\n@@ -123,7 +116,6 @@ func TestRemove0(t *testing.T) {\n \t}\n }\n \n-\n func TestRemove1(t *testing.T) {\n \th := new(myHeap)\n \tfor i := 0; i < 10; i++ {\n@@ -140,7 +132,6 @@ func TestRemove1(t *testing.T) {\n \t}\n }\n \n-\n func TestRemove2(t *testing.T) {\n \tN := 10\n "}, {"sha": "1d96918d37bec8146a8e94f07568f7974095f760", "filename": "libgo/go/container/ring/ring.go", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fring%2Fring.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fring%2Fring.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fring%2Fring.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -16,14 +16,12 @@ type Ring struct {\n \tValue      interface{} // for use by client; untouched by this library\n }\n \n-\n func (r *Ring) init() *Ring {\n \tr.next = r\n \tr.prev = r\n \treturn r\n }\n \n-\n // Next returns the next ring element. r must not be empty.\n func (r *Ring) Next() *Ring {\n \tif r.next == nil {\n@@ -32,7 +30,6 @@ func (r *Ring) Next() *Ring {\n \treturn r.next\n }\n \n-\n // Prev returns the previous ring element. r must not be empty.\n func (r *Ring) Prev() *Ring {\n \tif r.next == nil {\n@@ -41,7 +38,6 @@ func (r *Ring) Prev() *Ring {\n \treturn r.prev\n }\n \n-\n // Move moves n % r.Len() elements backward (n < 0) or forward (n >= 0)\n // in the ring and returns that ring element. r must not be empty.\n //\n@@ -62,7 +58,6 @@ func (r *Ring) Move(n int) *Ring {\n \treturn r\n }\n \n-\n // New creates a ring of n elements.\n func New(n int) *Ring {\n \tif n <= 0 {\n@@ -79,7 +74,6 @@ func New(n int) *Ring {\n \treturn r\n }\n \n-\n // Link connects ring r with with ring s such that r.Next()\n // becomes s and returns the original value for r.Next().\n // r must not be empty.\n@@ -110,7 +104,6 @@ func (r *Ring) Link(s *Ring) *Ring {\n \treturn n\n }\n \n-\n // Unlink removes n % r.Len() elements from the ring r, starting\n // at r.Next(). If n % r.Len() == 0, r remains unchanged.\n // The result is the removed subring. r must not be empty.\n@@ -122,7 +115,6 @@ func (r *Ring) Unlink(n int) *Ring {\n \treturn r.Link(r.Move(n + 1))\n }\n \n-\n // Len computes the number of elements in ring r.\n // It executes in time proportional to the number of elements.\n //\n@@ -137,7 +129,6 @@ func (r *Ring) Len() int {\n \treturn n\n }\n \n-\n // Do calls function f on each element of the ring, in forward order.\n // The behavior of Do is undefined if f changes *r.\n func (r *Ring) Do(f func(interface{})) {"}, {"sha": "099d92b25b2b449c3c93c60a2a2ebb0e7f9cb456", "filename": "libgo/go/container/ring/ring_test.go", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fring%2Fring_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fring%2Fring_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fring%2Fring_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"testing\"\n )\n \n-\n // For debugging - keep around.\n func dump(r *Ring) {\n \tif r == nil {\n@@ -24,7 +23,6 @@ func dump(r *Ring) {\n \tfmt.Println()\n }\n \n-\n func verify(t *testing.T, r *Ring, N int, sum int) {\n \t// Len\n \tn := r.Len()\n@@ -96,7 +94,6 @@ func verify(t *testing.T, r *Ring, N int, sum int) {\n \t}\n }\n \n-\n func TestCornerCases(t *testing.T) {\n \tvar (\n \t\tr0 *Ring\n@@ -118,7 +115,6 @@ func TestCornerCases(t *testing.T) {\n \tverify(t, &r1, 1, 0)\n }\n \n-\n func makeN(n int) *Ring {\n \tr := New(n)\n \tfor i := 1; i <= n; i++ {\n@@ -130,7 +126,6 @@ func makeN(n int) *Ring {\n \n func sumN(n int) int { return (n*n + n) / 2 }\n \n-\n func TestNew(t *testing.T) {\n \tfor i := 0; i < 10; i++ {\n \t\tr := New(i)\n@@ -142,7 +137,6 @@ func TestNew(t *testing.T) {\n \t}\n }\n \n-\n func TestLink1(t *testing.T) {\n \tr1a := makeN(1)\n \tvar r1b Ring\n@@ -163,7 +157,6 @@ func TestLink1(t *testing.T) {\n \tverify(t, r2b, 1, 0)\n }\n \n-\n func TestLink2(t *testing.T) {\n \tvar r0 *Ring\n \tr1a := &Ring{Value: 42}\n@@ -183,7 +176,6 @@ func TestLink2(t *testing.T) {\n \tverify(t, r10, 12, sumN(10)+42+77)\n }\n \n-\n func TestLink3(t *testing.T) {\n \tvar r Ring\n \tn := 1\n@@ -193,7 +185,6 @@ func TestLink3(t *testing.T) {\n \t}\n }\n \n-\n func TestUnlink(t *testing.T) {\n \tr10 := makeN(10)\n \ts10 := r10.Move(6)\n@@ -215,7 +206,6 @@ func TestUnlink(t *testing.T) {\n \tverify(t, r10, 9, sum10-2)\n }\n \n-\n func TestLinkUnlink(t *testing.T) {\n \tfor i := 1; i < 4; i++ {\n \t\tri := New(i)"}, {"sha": "6d6b2ac81a32ed873d159453cfaa7604032be330", "filename": "libgo/go/container/vector/defs.go", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fdefs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fdefs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fdefs.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -6,46 +6,38 @@\n // Vectors grow and shrink dynamically as necessary.\n package vector\n \n-\n // Vector is a container for numbered sequences of elements of type interface{}.\n // A vector's length and capacity adjusts automatically as necessary.\n // The zero value for Vector is an empty vector ready to use.\n type Vector []interface{}\n \n-\n // IntVector is a container for numbered sequences of elements of type int.\n // A vector's length and capacity adjusts automatically as necessary.\n // The zero value for IntVector is an empty vector ready to use.\n type IntVector []int\n \n-\n // StringVector is a container for numbered sequences of elements of type string.\n // A vector's length and capacity adjusts automatically as necessary.\n // The zero value for StringVector is an empty vector ready to use.\n type StringVector []string\n \n-\n // Initial underlying array size\n const initialSize = 8\n \n-\n // Partial sort.Interface support\n \n // LessInterface provides partial support of the sort.Interface.\n type LessInterface interface {\n \tLess(y interface{}) bool\n }\n \n-\n // Less returns a boolean denoting whether the i'th element is less than the j'th element.\n func (p *Vector) Less(i, j int) bool { return (*p)[i].(LessInterface).Less((*p)[j]) }\n \n-\n // sort.Interface support\n \n // Less returns a boolean denoting whether the i'th element is less than the j'th element.\n func (p *IntVector) Less(i, j int) bool { return (*p)[i] < (*p)[j] }\n \n-\n // Less returns a boolean denoting whether the i'th element is less than the j'th element.\n func (p *StringVector) Less(i, j int) bool { return (*p)[i] < (*p)[j] }"}, {"sha": "aa88cfeb367b44c3684cba0d77e453c4a2e207b8", "filename": "libgo/go/container/vector/intvector.go", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fintvector.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fintvector.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fintvector.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -7,7 +7,6 @@\n \n package vector\n \n-\n func (p *IntVector) realloc(length, capacity int) (b []int) {\n \tif capacity < initialSize {\n \t\tcapacity = initialSize\n@@ -21,7 +20,6 @@ func (p *IntVector) realloc(length, capacity int) (b []int) {\n \treturn\n }\n \n-\n // Insert n elements at position i.\n func (p *IntVector) Expand(i, n int) {\n \ta := *p\n@@ -51,11 +49,9 @@ func (p *IntVector) Expand(i, n int) {\n \t*p = a\n }\n \n-\n // Insert n elements at the end of a vector.\n func (p *IntVector) Extend(n int) { p.Expand(len(*p), n) }\n \n-\n // Resize changes the length and capacity of a vector.\n // If the new length is shorter than the current length, Resize discards\n // trailing elements. If the new length is longer than the current length,\n@@ -80,46 +76,38 @@ func (p *IntVector) Resize(length, capacity int) *IntVector {\n \treturn p\n }\n \n-\n // Len returns the number of elements in the vector.\n // Same as len(*p).\n func (p *IntVector) Len() int { return len(*p) }\n \n-\n // Cap returns the capacity of the vector; that is, the\n // maximum length the vector can grow without resizing.\n // Same as cap(*p).\n func (p *IntVector) Cap() int { return cap(*p) }\n \n-\n // At returns the i'th element of the vector.\n func (p *IntVector) At(i int) int { return (*p)[i] }\n \n-\n // Set sets the i'th element of the vector to value x.\n func (p *IntVector) Set(i int, x int) { (*p)[i] = x }\n \n-\n // Last returns the element in the vector of highest index.\n func (p *IntVector) Last() int { return (*p)[len(*p)-1] }\n \n-\n // Copy makes a copy of the vector and returns it.\n func (p *IntVector) Copy() IntVector {\n \tarr := make(IntVector, len(*p))\n \tcopy(arr, *p)\n \treturn arr\n }\n \n-\n // Insert inserts into the vector an element of value x before\n // the current element at index i.\n func (p *IntVector) Insert(i int, x int) {\n \tp.Expand(i, 1)\n \t(*p)[i] = x\n }\n \n-\n // Delete deletes the i'th element of the vector.  The gap is closed so the old\n // element at index i+1 has index i afterwards.\n func (p *IntVector) Delete(i int) {\n@@ -132,7 +120,6 @@ func (p *IntVector) Delete(i int) {\n \t*p = a[0 : n-1]\n }\n \n-\n // InsertVector inserts into the vector the contents of the vector\n // x such that the 0th element of x appears at index i after insertion.\n func (p *IntVector) InsertVector(i int, x *IntVector) {\n@@ -142,7 +129,6 @@ func (p *IntVector) InsertVector(i int, x *IntVector) {\n \tcopy((*p)[i:i+len(b)], b)\n }\n \n-\n // Cut deletes elements i through j-1, inclusive.\n func (p *IntVector) Cut(i, j int) {\n \ta := *p\n@@ -158,7 +144,6 @@ func (p *IntVector) Cut(i, j int) {\n \t*p = a[0:m]\n }\n \n-\n // Slice returns a new sub-vector by slicing the old one to extract slice [i:j].\n // The elements are copied. The original vector is unchanged.\n func (p *IntVector) Slice(i, j int) *IntVector {\n@@ -168,13 +153,11 @@ func (p *IntVector) Slice(i, j int) *IntVector {\n \treturn &s\n }\n \n-\n // Convenience wrappers\n \n // Push appends x to the end of the vector.\n func (p *IntVector) Push(x int) { p.Insert(len(*p), x) }\n \n-\n // Pop deletes the last element of the vector.\n func (p *IntVector) Pop() int {\n \ta := *p\n@@ -187,18 +170,15 @@ func (p *IntVector) Pop() int {\n \treturn x\n }\n \n-\n // AppendVector appends the entire vector x to the end of this vector.\n func (p *IntVector) AppendVector(x *IntVector) { p.InsertVector(len(*p), x) }\n \n-\n // Swap exchanges the elements at indexes i and j.\n func (p *IntVector) Swap(i, j int) {\n \ta := *p\n \ta[i], a[j] = a[j], a[i]\n }\n \n-\n // Do calls function f for each element of the vector, in order.\n // The behavior of Do is undefined if f changes *p.\n func (p *IntVector) Do(f func(elem int)) {"}, {"sha": "b825af912218e979e89a06115dc41d9fd1fd2008", "filename": "libgo/go/container/vector/intvector_test.go", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fintvector_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fintvector_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fintvector_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -9,7 +9,6 @@ package vector\n \n import \"testing\"\n \n-\n func TestIntZeroLen(t *testing.T) {\n \ta := new(IntVector)\n \tif a.Len() != 0 {\n@@ -27,7 +26,6 @@ func TestIntZeroLen(t *testing.T) {\n \t}\n }\n \n-\n func TestIntResize(t *testing.T) {\n \tvar a IntVector\n \tcheckSize(t, &a, 0, 0)\n@@ -40,7 +38,6 @@ func TestIntResize(t *testing.T) {\n \tcheckSize(t, a.Resize(11, 100), 11, 100)\n }\n \n-\n func TestIntResize2(t *testing.T) {\n \tvar a IntVector\n \tcheckSize(t, &a, 0, 0)\n@@ -62,7 +59,6 @@ func TestIntResize2(t *testing.T) {\n \t}\n }\n \n-\n func checkIntZero(t *testing.T, a *IntVector, i int) {\n \tfor j := 0; j < i; j++ {\n \t\tif a.At(j) == intzero {\n@@ -82,7 +78,6 @@ func checkIntZero(t *testing.T, a *IntVector, i int) {\n \t}\n }\n \n-\n func TestIntTrailingElements(t *testing.T) {\n \tvar a IntVector\n \tfor i := 0; i < 10; i++ {\n@@ -95,7 +90,6 @@ func TestIntTrailingElements(t *testing.T) {\n \tcheckIntZero(t, &a, 5)\n }\n \n-\n func TestIntAccess(t *testing.T) {\n \tconst n = 100\n \tvar a IntVector\n@@ -120,7 +114,6 @@ func TestIntAccess(t *testing.T) {\n \t}\n }\n \n-\n func TestIntInsertDeleteClear(t *testing.T) {\n \tconst n = 100\n \tvar a IntVector\n@@ -207,7 +200,6 @@ func TestIntInsertDeleteClear(t *testing.T) {\n \t}\n }\n \n-\n func verify_sliceInt(t *testing.T, x *IntVector, elt, i, j int) {\n \tfor k := i; k < j; k++ {\n \t\tif elem2IntValue(x.At(k)) != int2IntValue(elt) {\n@@ -223,7 +215,6 @@ func verify_sliceInt(t *testing.T, x *IntVector, elt, i, j int) {\n \t}\n }\n \n-\n func verify_patternInt(t *testing.T, x *IntVector, a, b, c int) {\n \tn := a + b + c\n \tif x.Len() != n {\n@@ -237,7 +228,6 @@ func verify_patternInt(t *testing.T, x *IntVector, a, b, c int) {\n \tverify_sliceInt(t, x, 0, a+b, n)\n }\n \n-\n func make_vectorInt(elt, len int) *IntVector {\n \tx := new(IntVector).Resize(len, 0)\n \tfor i := 0; i < len; i++ {\n@@ -246,7 +236,6 @@ func make_vectorInt(elt, len int) *IntVector {\n \treturn x\n }\n \n-\n func TestIntInsertVector(t *testing.T) {\n \t// 1\n \ta := make_vectorInt(0, 0)\n@@ -270,7 +259,6 @@ func TestIntInsertVector(t *testing.T) {\n \tverify_patternInt(t, a, 8, 1000, 2)\n }\n \n-\n func TestIntDo(t *testing.T) {\n \tconst n = 25\n \tconst salt = 17\n@@ -325,7 +313,6 @@ func TestIntDo(t *testing.T) {\n \n }\n \n-\n func TestIntVectorCopy(t *testing.T) {\n \t// verify Copy() returns a copy, not simply a slice of the original vector\n \tconst Len = 10"}, {"sha": "7b6a25952b12fecd80215e043768d8c96d8b3e9f", "filename": "libgo/go/container/vector/nogen_test.go", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fnogen_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fnogen_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fnogen_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -4,7 +4,6 @@\n \n package vector\n \n-\n import (\n \t\"fmt\"\n \t\"sort\"\n@@ -17,28 +16,23 @@ var (\n \tstrzero string\n )\n \n-\n func int2Value(x int) int       { return x }\n func int2IntValue(x int) int    { return x }\n func int2StrValue(x int) string { return string(x) }\n \n-\n func elem2Value(x interface{}) int  { return x.(int) }\n func elem2IntValue(x int) int       { return x }\n func elem2StrValue(x string) string { return x }\n \n-\n func intf2Value(x interface{}) int       { return x.(int) }\n func intf2IntValue(x interface{}) int    { return x.(int) }\n func intf2StrValue(x interface{}) string { return x.(string) }\n \n-\n type VectorInterface interface {\n \tLen() int\n \tCap() int\n }\n \n-\n func checkSize(t *testing.T, v VectorInterface, len, cap int) {\n \tif v.Len() != len {\n \t\tt.Errorf(\"%T expected len = %d; found %d\", v, len, v.Len())\n@@ -48,10 +42,8 @@ func checkSize(t *testing.T, v VectorInterface, len, cap int) {\n \t}\n }\n \n-\n func val(i int) int { return i*991 - 1234 }\n \n-\n func TestSorting(t *testing.T) {\n \tconst n = 100\n \n@@ -72,5 +64,4 @@ func TestSorting(t *testing.T) {\n \t}\n }\n \n-\n func tname(x interface{}) string { return fmt.Sprintf(\"%T: \", x) }"}, {"sha": "abe01a8fb180371c4d45c61b36018e8b39edbf23", "filename": "libgo/go/container/vector/numbers_test.go", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fnumbers_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fnumbers_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fnumbers_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -11,10 +11,8 @@ import (\n \t\"testing\"\n )\n \n-\n const memTestN = 1000000\n \n-\n func s(n uint64) string {\n \tstr := fmt.Sprintf(\"%d\", n)\n \tlens := len(str)\n@@ -31,7 +29,6 @@ func s(n uint64) string {\n \treturn strings.Join(a, \" \")\n }\n \n-\n func TestVectorNums(t *testing.T) {\n \tif testing.Short() {\n \t\treturn\n@@ -52,7 +49,6 @@ func TestVectorNums(t *testing.T) {\n \tt.Logf(\"%T.Push(%#v), n = %s: Alloc/n = %.2f\\n\", v, c, s(memTestN), float64(n)/memTestN)\n }\n \n-\n func TestIntVectorNums(t *testing.T) {\n \tif testing.Short() {\n \t\treturn\n@@ -73,7 +69,6 @@ func TestIntVectorNums(t *testing.T) {\n \tt.Logf(\"%T.Push(%#v), n = %s: Alloc/n = %.2f\\n\", v, c, s(memTestN), float64(n)/memTestN)\n }\n \n-\n func TestStringVectorNums(t *testing.T) {\n \tif testing.Short() {\n \t\treturn\n@@ -94,7 +89,6 @@ func TestStringVectorNums(t *testing.T) {\n \tt.Logf(\"%T.Push(%#v), n = %s: Alloc/n = %.2f\\n\", v, c, s(memTestN), float64(n)/memTestN)\n }\n \n-\n func BenchmarkVectorNums(b *testing.B) {\n \tc := int(0)\n \tvar v Vector\n@@ -106,7 +100,6 @@ func BenchmarkVectorNums(b *testing.B) {\n \t}\n }\n \n-\n func BenchmarkIntVectorNums(b *testing.B) {\n \tc := int(0)\n \tvar v IntVector\n@@ -118,7 +111,6 @@ func BenchmarkIntVectorNums(b *testing.B) {\n \t}\n }\n \n-\n func BenchmarkStringVectorNums(b *testing.B) {\n \tc := \"\"\n \tvar v StringVector"}, {"sha": "dc81f06b74dfe992a7f87869d2d8b1c56654a1c6", "filename": "libgo/go/container/vector/stringvector.go", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fstringvector.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fstringvector.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fstringvector.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -7,7 +7,6 @@\n \n package vector\n \n-\n func (p *StringVector) realloc(length, capacity int) (b []string) {\n \tif capacity < initialSize {\n \t\tcapacity = initialSize\n@@ -21,7 +20,6 @@ func (p *StringVector) realloc(length, capacity int) (b []string) {\n \treturn\n }\n \n-\n // Insert n elements at position i.\n func (p *StringVector) Expand(i, n int) {\n \ta := *p\n@@ -51,11 +49,9 @@ func (p *StringVector) Expand(i, n int) {\n \t*p = a\n }\n \n-\n // Insert n elements at the end of a vector.\n func (p *StringVector) Extend(n int) { p.Expand(len(*p), n) }\n \n-\n // Resize changes the length and capacity of a vector.\n // If the new length is shorter than the current length, Resize discards\n // trailing elements. If the new length is longer than the current length,\n@@ -80,46 +76,38 @@ func (p *StringVector) Resize(length, capacity int) *StringVector {\n \treturn p\n }\n \n-\n // Len returns the number of elements in the vector.\n // Same as len(*p).\n func (p *StringVector) Len() int { return len(*p) }\n \n-\n // Cap returns the capacity of the vector; that is, the\n // maximum length the vector can grow without resizing.\n // Same as cap(*p).\n func (p *StringVector) Cap() int { return cap(*p) }\n \n-\n // At returns the i'th element of the vector.\n func (p *StringVector) At(i int) string { return (*p)[i] }\n \n-\n // Set sets the i'th element of the vector to value x.\n func (p *StringVector) Set(i int, x string) { (*p)[i] = x }\n \n-\n // Last returns the element in the vector of highest index.\n func (p *StringVector) Last() string { return (*p)[len(*p)-1] }\n \n-\n // Copy makes a copy of the vector and returns it.\n func (p *StringVector) Copy() StringVector {\n \tarr := make(StringVector, len(*p))\n \tcopy(arr, *p)\n \treturn arr\n }\n \n-\n // Insert inserts into the vector an element of value x before\n // the current element at index i.\n func (p *StringVector) Insert(i int, x string) {\n \tp.Expand(i, 1)\n \t(*p)[i] = x\n }\n \n-\n // Delete deletes the i'th element of the vector.  The gap is closed so the old\n // element at index i+1 has index i afterwards.\n func (p *StringVector) Delete(i int) {\n@@ -132,7 +120,6 @@ func (p *StringVector) Delete(i int) {\n \t*p = a[0 : n-1]\n }\n \n-\n // InsertVector inserts into the vector the contents of the vector\n // x such that the 0th element of x appears at index i after insertion.\n func (p *StringVector) InsertVector(i int, x *StringVector) {\n@@ -142,7 +129,6 @@ func (p *StringVector) InsertVector(i int, x *StringVector) {\n \tcopy((*p)[i:i+len(b)], b)\n }\n \n-\n // Cut deletes elements i through j-1, inclusive.\n func (p *StringVector) Cut(i, j int) {\n \ta := *p\n@@ -158,7 +144,6 @@ func (p *StringVector) Cut(i, j int) {\n \t*p = a[0:m]\n }\n \n-\n // Slice returns a new sub-vector by slicing the old one to extract slice [i:j].\n // The elements are copied. The original vector is unchanged.\n func (p *StringVector) Slice(i, j int) *StringVector {\n@@ -168,13 +153,11 @@ func (p *StringVector) Slice(i, j int) *StringVector {\n \treturn &s\n }\n \n-\n // Convenience wrappers\n \n // Push appends x to the end of the vector.\n func (p *StringVector) Push(x string) { p.Insert(len(*p), x) }\n \n-\n // Pop deletes the last element of the vector.\n func (p *StringVector) Pop() string {\n \ta := *p\n@@ -187,18 +170,15 @@ func (p *StringVector) Pop() string {\n \treturn x\n }\n \n-\n // AppendVector appends the entire vector x to the end of this vector.\n func (p *StringVector) AppendVector(x *StringVector) { p.InsertVector(len(*p), x) }\n \n-\n // Swap exchanges the elements at indexes i and j.\n func (p *StringVector) Swap(i, j int) {\n \ta := *p\n \ta[i], a[j] = a[j], a[i]\n }\n \n-\n // Do calls function f for each element of the vector, in order.\n // The behavior of Do is undefined if f changes *p.\n func (p *StringVector) Do(f func(elem string)) {"}, {"sha": "c75676f786c0e364d49e947cf2fba08e42e67338", "filename": "libgo/go/container/vector/stringvector_test.go", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fstringvector_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fstringvector_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fstringvector_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -9,7 +9,6 @@ package vector\n \n import \"testing\"\n \n-\n func TestStrZeroLen(t *testing.T) {\n \ta := new(StringVector)\n \tif a.Len() != 0 {\n@@ -27,7 +26,6 @@ func TestStrZeroLen(t *testing.T) {\n \t}\n }\n \n-\n func TestStrResize(t *testing.T) {\n \tvar a StringVector\n \tcheckSize(t, &a, 0, 0)\n@@ -40,7 +38,6 @@ func TestStrResize(t *testing.T) {\n \tcheckSize(t, a.Resize(11, 100), 11, 100)\n }\n \n-\n func TestStrResize2(t *testing.T) {\n \tvar a StringVector\n \tcheckSize(t, &a, 0, 0)\n@@ -62,7 +59,6 @@ func TestStrResize2(t *testing.T) {\n \t}\n }\n \n-\n func checkStrZero(t *testing.T, a *StringVector, i int) {\n \tfor j := 0; j < i; j++ {\n \t\tif a.At(j) == strzero {\n@@ -82,7 +78,6 @@ func checkStrZero(t *testing.T, a *StringVector, i int) {\n \t}\n }\n \n-\n func TestStrTrailingElements(t *testing.T) {\n \tvar a StringVector\n \tfor i := 0; i < 10; i++ {\n@@ -95,7 +90,6 @@ func TestStrTrailingElements(t *testing.T) {\n \tcheckStrZero(t, &a, 5)\n }\n \n-\n func TestStrAccess(t *testing.T) {\n \tconst n = 100\n \tvar a StringVector\n@@ -120,7 +114,6 @@ func TestStrAccess(t *testing.T) {\n \t}\n }\n \n-\n func TestStrInsertDeleteClear(t *testing.T) {\n \tconst n = 100\n \tvar a StringVector\n@@ -207,7 +200,6 @@ func TestStrInsertDeleteClear(t *testing.T) {\n \t}\n }\n \n-\n func verify_sliceStr(t *testing.T, x *StringVector, elt, i, j int) {\n \tfor k := i; k < j; k++ {\n \t\tif elem2StrValue(x.At(k)) != int2StrValue(elt) {\n@@ -223,7 +215,6 @@ func verify_sliceStr(t *testing.T, x *StringVector, elt, i, j int) {\n \t}\n }\n \n-\n func verify_patternStr(t *testing.T, x *StringVector, a, b, c int) {\n \tn := a + b + c\n \tif x.Len() != n {\n@@ -237,7 +228,6 @@ func verify_patternStr(t *testing.T, x *StringVector, a, b, c int) {\n \tverify_sliceStr(t, x, 0, a+b, n)\n }\n \n-\n func make_vectorStr(elt, len int) *StringVector {\n \tx := new(StringVector).Resize(len, 0)\n \tfor i := 0; i < len; i++ {\n@@ -246,7 +236,6 @@ func make_vectorStr(elt, len int) *StringVector {\n \treturn x\n }\n \n-\n func TestStrInsertVector(t *testing.T) {\n \t// 1\n \ta := make_vectorStr(0, 0)\n@@ -270,7 +259,6 @@ func TestStrInsertVector(t *testing.T) {\n \tverify_patternStr(t, a, 8, 1000, 2)\n }\n \n-\n func TestStrDo(t *testing.T) {\n \tconst n = 25\n \tconst salt = 17\n@@ -325,7 +313,6 @@ func TestStrDo(t *testing.T) {\n \n }\n \n-\n func TestStrVectorCopy(t *testing.T) {\n \t// verify Copy() returns a copy, not simply a slice of the original vector\n \tconst Len = 10"}, {"sha": "8470ec067ac1ab5707ecbc40def98da6a8c64e72", "filename": "libgo/go/container/vector/vector.go", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fvector.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fvector.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fvector.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -7,7 +7,6 @@\n \n package vector\n \n-\n func (p *Vector) realloc(length, capacity int) (b []interface{}) {\n \tif capacity < initialSize {\n \t\tcapacity = initialSize\n@@ -21,7 +20,6 @@ func (p *Vector) realloc(length, capacity int) (b []interface{}) {\n \treturn\n }\n \n-\n // Insert n elements at position i.\n func (p *Vector) Expand(i, n int) {\n \ta := *p\n@@ -51,11 +49,9 @@ func (p *Vector) Expand(i, n int) {\n \t*p = a\n }\n \n-\n // Insert n elements at the end of a vector.\n func (p *Vector) Extend(n int) { p.Expand(len(*p), n) }\n \n-\n // Resize changes the length and capacity of a vector.\n // If the new length is shorter than the current length, Resize discards\n // trailing elements. If the new length is longer than the current length,\n@@ -80,46 +76,38 @@ func (p *Vector) Resize(length, capacity int) *Vector {\n \treturn p\n }\n \n-\n // Len returns the number of elements in the vector.\n // Same as len(*p).\n func (p *Vector) Len() int { return len(*p) }\n \n-\n // Cap returns the capacity of the vector; that is, the\n // maximum length the vector can grow without resizing.\n // Same as cap(*p).\n func (p *Vector) Cap() int { return cap(*p) }\n \n-\n // At returns the i'th element of the vector.\n func (p *Vector) At(i int) interface{} { return (*p)[i] }\n \n-\n // Set sets the i'th element of the vector to value x.\n func (p *Vector) Set(i int, x interface{}) { (*p)[i] = x }\n \n-\n // Last returns the element in the vector of highest index.\n func (p *Vector) Last() interface{} { return (*p)[len(*p)-1] }\n \n-\n // Copy makes a copy of the vector and returns it.\n func (p *Vector) Copy() Vector {\n \tarr := make(Vector, len(*p))\n \tcopy(arr, *p)\n \treturn arr\n }\n \n-\n // Insert inserts into the vector an element of value x before\n // the current element at index i.\n func (p *Vector) Insert(i int, x interface{}) {\n \tp.Expand(i, 1)\n \t(*p)[i] = x\n }\n \n-\n // Delete deletes the i'th element of the vector.  The gap is closed so the old\n // element at index i+1 has index i afterwards.\n func (p *Vector) Delete(i int) {\n@@ -132,7 +120,6 @@ func (p *Vector) Delete(i int) {\n \t*p = a[0 : n-1]\n }\n \n-\n // InsertVector inserts into the vector the contents of the vector\n // x such that the 0th element of x appears at index i after insertion.\n func (p *Vector) InsertVector(i int, x *Vector) {\n@@ -142,7 +129,6 @@ func (p *Vector) InsertVector(i int, x *Vector) {\n \tcopy((*p)[i:i+len(b)], b)\n }\n \n-\n // Cut deletes elements i through j-1, inclusive.\n func (p *Vector) Cut(i, j int) {\n \ta := *p\n@@ -158,7 +144,6 @@ func (p *Vector) Cut(i, j int) {\n \t*p = a[0:m]\n }\n \n-\n // Slice returns a new sub-vector by slicing the old one to extract slice [i:j].\n // The elements are copied. The original vector is unchanged.\n func (p *Vector) Slice(i, j int) *Vector {\n@@ -168,13 +153,11 @@ func (p *Vector) Slice(i, j int) *Vector {\n \treturn &s\n }\n \n-\n // Convenience wrappers\n \n // Push appends x to the end of the vector.\n func (p *Vector) Push(x interface{}) { p.Insert(len(*p), x) }\n \n-\n // Pop deletes the last element of the vector.\n func (p *Vector) Pop() interface{} {\n \ta := *p\n@@ -187,18 +170,15 @@ func (p *Vector) Pop() interface{} {\n \treturn x\n }\n \n-\n // AppendVector appends the entire vector x to the end of this vector.\n func (p *Vector) AppendVector(x *Vector) { p.InsertVector(len(*p), x) }\n \n-\n // Swap exchanges the elements at indexes i and j.\n func (p *Vector) Swap(i, j int) {\n \ta := *p\n \ta[i], a[j] = a[j], a[i]\n }\n \n-\n // Do calls function f for each element of the vector, in order.\n // The behavior of Do is undefined if f changes *p.\n func (p *Vector) Do(f func(elem interface{})) {"}, {"sha": "a7f47b8c2a568df3732a414f0c3b0ffdba391340", "filename": "libgo/go/container/vector/vector_test.go", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fvector_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcontainer%2Fvector%2Fvector_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fvector_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -9,7 +9,6 @@ package vector\n \n import \"testing\"\n \n-\n func TestZeroLen(t *testing.T) {\n \ta := new(Vector)\n \tif a.Len() != 0 {\n@@ -27,7 +26,6 @@ func TestZeroLen(t *testing.T) {\n \t}\n }\n \n-\n func TestResize(t *testing.T) {\n \tvar a Vector\n \tcheckSize(t, &a, 0, 0)\n@@ -40,7 +38,6 @@ func TestResize(t *testing.T) {\n \tcheckSize(t, a.Resize(11, 100), 11, 100)\n }\n \n-\n func TestResize2(t *testing.T) {\n \tvar a Vector\n \tcheckSize(t, &a, 0, 0)\n@@ -62,7 +59,6 @@ func TestResize2(t *testing.T) {\n \t}\n }\n \n-\n func checkZero(t *testing.T, a *Vector, i int) {\n \tfor j := 0; j < i; j++ {\n \t\tif a.At(j) == zero {\n@@ -82,7 +78,6 @@ func checkZero(t *testing.T, a *Vector, i int) {\n \t}\n }\n \n-\n func TestTrailingElements(t *testing.T) {\n \tvar a Vector\n \tfor i := 0; i < 10; i++ {\n@@ -95,7 +90,6 @@ func TestTrailingElements(t *testing.T) {\n \tcheckZero(t, &a, 5)\n }\n \n-\n func TestAccess(t *testing.T) {\n \tconst n = 100\n \tvar a Vector\n@@ -120,7 +114,6 @@ func TestAccess(t *testing.T) {\n \t}\n }\n \n-\n func TestInsertDeleteClear(t *testing.T) {\n \tconst n = 100\n \tvar a Vector\n@@ -207,7 +200,6 @@ func TestInsertDeleteClear(t *testing.T) {\n \t}\n }\n \n-\n func verify_slice(t *testing.T, x *Vector, elt, i, j int) {\n \tfor k := i; k < j; k++ {\n \t\tif elem2Value(x.At(k)) != int2Value(elt) {\n@@ -223,7 +215,6 @@ func verify_slice(t *testing.T, x *Vector, elt, i, j int) {\n \t}\n }\n \n-\n func verify_pattern(t *testing.T, x *Vector, a, b, c int) {\n \tn := a + b + c\n \tif x.Len() != n {\n@@ -237,7 +228,6 @@ func verify_pattern(t *testing.T, x *Vector, a, b, c int) {\n \tverify_slice(t, x, 0, a+b, n)\n }\n \n-\n func make_vector(elt, len int) *Vector {\n \tx := new(Vector).Resize(len, 0)\n \tfor i := 0; i < len; i++ {\n@@ -246,7 +236,6 @@ func make_vector(elt, len int) *Vector {\n \treturn x\n }\n \n-\n func TestInsertVector(t *testing.T) {\n \t// 1\n \ta := make_vector(0, 0)\n@@ -270,7 +259,6 @@ func TestInsertVector(t *testing.T) {\n \tverify_pattern(t, a, 8, 1000, 2)\n }\n \n-\n func TestDo(t *testing.T) {\n \tconst n = 25\n \tconst salt = 17\n@@ -325,7 +313,6 @@ func TestDo(t *testing.T) {\n \n }\n \n-\n func TestVectorCopy(t *testing.T) {\n \t// verify Copy() returns a copy, not simply a slice of the original vector\n \tconst Len = 10"}, {"sha": "73223531e1733d94280f44acead5adfe79f18d64", "filename": "libgo/go/crypto/aes/cipher.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -45,14 +45,14 @@ func NewCipher(key []byte) (*Cipher, os.Error) {\n \n // BlockSize returns the AES block size, 16 bytes.\n // It is necessary to satisfy the Cipher interface in the\n-// package \"crypto/block\".\n+// package \"crypto/cipher\".\n func (c *Cipher) BlockSize() int { return BlockSize }\n \n // Encrypt encrypts the 16-byte buffer src using the key k\n // and stores the result in dst.\n // Note that for amounts of data larger than a block,\n // it is not safe to just call Encrypt on successive blocks;\n-// instead, use an encryption mode like CBC (see crypto/block/cbc.go).\n+// instead, use an encryption mode like CBC (see crypto/cipher/cbc.go).\n func (c *Cipher) Encrypt(dst, src []byte) { encryptBlock(c.enc, dst, src) }\n \n // Decrypt decrypts the 16-byte buffer src using the key k"}, {"sha": "6c37dfe940594a7eea18de794f567a163e2d96fe", "filename": "libgo/go/crypto/blowfish/cipher.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -42,14 +42,14 @@ func NewCipher(key []byte) (*Cipher, os.Error) {\n \n // BlockSize returns the Blowfish block size, 8 bytes.\n // It is necessary to satisfy the Cipher interface in the\n-// package \"crypto/block\".\n+// package \"crypto/cipher\".\n func (c *Cipher) BlockSize() int { return BlockSize }\n \n // Encrypt encrypts the 8-byte buffer src using the key k\n // and stores the result in dst.\n // Note that for amounts of data larger than a block,\n // it is not safe to just call Encrypt on successive blocks;\n-// instead, use an encryption mode like CBC (see crypto/block/cbc.go).\n+// instead, use an encryption mode like CBC (see crypto/cipher/cbc.go).\n func (c *Cipher) Encrypt(dst, src []byte) {\n \tl := uint32(src[0])<<24 | uint32(src[1])<<16 | uint32(src[2])<<8 | uint32(src[3])\n \tr := uint32(src[4])<<24 | uint32(src[5])<<16 | uint32(src[6])<<8 | uint32(src[7])"}, {"sha": "e9d4a24e26b776305061fd44a379bf9119c7dca7", "filename": "libgo/go/crypto/cast5/cast5.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fcast5%2Fcast5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fcast5%2Fcast5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcast5%2Fcast5.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -20,7 +20,7 @@ type Cipher struct {\n \n func NewCipher(key []byte) (c *Cipher, err os.Error) {\n \tif len(key) != KeySize {\n-\t\treturn nil, os.ErrorString(\"CAST5: keys must be 16 bytes\")\n+\t\treturn nil, os.NewError(\"CAST5: keys must be 16 bytes\")\n \t}\n \n \tc = new(Cipher)"}, {"sha": "031e74a9dca1633bb20a2eb8528538093e81a785", "filename": "libgo/go/crypto/cipher/ocfb.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -80,9 +80,10 @@ type ocfbDecrypter struct {\n // NewOCFBDecrypter returns a Stream which decrypts data with OpenPGP's cipher\n // feedback mode using the given Block. Prefix must be the first blockSize + 2\n // bytes of the ciphertext, where blockSize is the Block's block size. If an\n-// incorrect key is detected then nil is returned. Resync determines if the\n-// \"resynchronization step\" from RFC 4880, 13.9 step 7 is performed. Different\n-// parts of OpenPGP vary on this point.\n+// incorrect key is detected then nil is returned. On successful exit,\n+// blockSize+2 bytes of decrypted data are written into prefix. Resync\n+// determines if the \"resynchronization step\" from RFC 4880, 13.9 step 7 is\n+// performed. Different parts of OpenPGP vary on this point.\n func NewOCFBDecrypter(block Block, prefix []byte, resync OCFBResyncOption) Stream {\n \tblockSize := block.BlockSize()\n \tif len(prefix) != blockSize+2 {\n@@ -118,6 +119,7 @@ func NewOCFBDecrypter(block Block, prefix []byte, resync OCFBResyncOption) Strea\n \t\tx.fre[1] = prefix[blockSize+1]\n \t\tx.outUsed = 2\n \t}\n+\tcopy(prefix, prefixCopy)\n \treturn x\n }\n "}, {"sha": "a5f96fe942c335528cca108d1d307187f9cfcf8d", "filename": "libgo/go/crypto/dsa/dsa.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -79,7 +79,7 @@ func GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes\n \t\tL = 3072\n \t\tN = 256\n \tdefault:\n-\t\treturn os.ErrorString(\"crypto/dsa: invalid ParameterSizes\")\n+\t\treturn os.NewError(\"crypto/dsa: invalid ParameterSizes\")\n \t}\n \n \tqBytes := make([]byte, N/8)\n@@ -158,7 +158,7 @@ GeneratePrimes:\n // PrivateKey must already be valid (see GenerateParameters).\n func GenerateKey(priv *PrivateKey, rand io.Reader) os.Error {\n \tif priv.P == nil || priv.Q == nil || priv.G == nil {\n-\t\treturn os.ErrorString(\"crypto/dsa: parameters not set up before generating key\")\n+\t\treturn os.NewError(\"crypto/dsa: parameters not set up before generating key\")\n \t}\n \n \tx := new(big.Int)"}, {"sha": "41835f1a9c8729ad1a24413d3acefde4b694548f", "filename": "libgo/go/crypto/elliptic/elliptic.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -284,7 +284,7 @@ func (curve *Curve) Marshal(x, y *big.Int) []byte {\n \treturn ret\n }\n \n-// Unmarshal converts a point, serialised by Marshal, into an x, y pair. On\n+// Unmarshal converts a point, serialized by Marshal, into an x, y pair. On\n // error, x = nil.\n func (curve *Curve) Unmarshal(data []byte) (x, y *big.Int) {\n \tbyteLen := (curve.BitSize + 7) >> 3"}, {"sha": "b7e7f035fa56c7521c0052c4f275a52f3150efbc", "filename": "libgo/go/crypto/elliptic/elliptic_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -321,8 +321,8 @@ func TestMarshal(t *testing.T) {\n \t\tt.Error(err)\n \t\treturn\n \t}\n-\tserialised := p224.Marshal(x, y)\n-\txx, yy := p224.Unmarshal(serialised)\n+\tserialized := p224.Marshal(x, y)\n+\txx, yy := p224.Unmarshal(serialized)\n \tif xx == nil {\n \t\tt.Error(\"failed to unmarshal\")\n \t\treturn"}, {"sha": "bcae63b8af84e3a2e919d7261e819349e047a35e", "filename": "libgo/go/crypto/hmac/hmac_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -190,7 +190,7 @@ func TestHMAC(t *testing.T) {\n \t\t\t\tcontinue\n \t\t\t}\n \n-\t\t\t// Repetive Sum() calls should return the same value\n+\t\t\t// Repetitive Sum() calls should return the same value\n \t\t\tfor k := 0; k < 2; k++ {\n \t\t\t\tsum := fmt.Sprintf(\"%x\", h.Sum())\n \t\t\t\tif sum != tt.out {"}, {"sha": "7ea7a1e825ca18b10d99e1d6bab468bbef1e8145", "filename": "libgo/go/crypto/ocsp/ocsp.go", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"crypto/rsa\"\n \t_ \"crypto/sha1\"\n \t\"crypto/x509\"\n+\t\"crypto/x509/pkix\"\n \t\"os\"\n \t\"time\"\n )\n@@ -32,29 +33,16 @@ const (\n \tocspUnauthorized  = 5\n )\n \n-type rdnSequence []relativeDistinguishedNameSET\n-\n-type relativeDistinguishedNameSET []attributeTypeAndValue\n-\n-type attributeTypeAndValue struct {\n-\tType  asn1.ObjectIdentifier\n-\tValue interface{}\n-}\n-\n-type algorithmIdentifier struct {\n-\tAlgorithm asn1.ObjectIdentifier\n-}\n-\n type certID struct {\n-\tHashAlgorithm algorithmIdentifier\n+\tHashAlgorithm pkix.AlgorithmIdentifier\n \tNameHash      []byte\n \tIssuerKeyHash []byte\n \tSerialNumber  asn1.RawValue\n }\n \n type responseASN1 struct {\n \tStatus   asn1.Enumerated\n-\tResponse responseBytes \"explicit,tag:0\"\n+\tResponse responseBytes `asn1:\"explicit,tag:0\"`\n }\n \n type responseBytes struct {\n@@ -64,32 +52,32 @@ type responseBytes struct {\n \n type basicResponse struct {\n \tTBSResponseData    responseData\n-\tSignatureAlgorithm algorithmIdentifier\n+\tSignatureAlgorithm pkix.AlgorithmIdentifier\n \tSignature          asn1.BitString\n-\tCertificates       []asn1.RawValue \"explicit,tag:0,optional\"\n+\tCertificates       []asn1.RawValue `asn1:\"explicit,tag:0,optional\"`\n }\n \n type responseData struct {\n \tRaw           asn1.RawContent\n-\tVersion       int         \"optional,default:1,explicit,tag:0\"\n-\tRequestorName rdnSequence \"optional,explicit,tag:1\"\n-\tKeyHash       []byte      \"optional,explicit,tag:2\"\n+\tVersion       int              `asn1:\"optional,default:1,explicit,tag:0\"`\n+\tRequestorName pkix.RDNSequence `asn1:\"optional,explicit,tag:1\"`\n+\tKeyHash       []byte           `asn1:\"optional,explicit,tag:2\"`\n \tProducedAt    *time.Time\n \tResponses     []singleResponse\n }\n \n type singleResponse struct {\n \tCertID     certID\n-\tGood       asn1.Flag   \"explicit,tag:0,optional\"\n-\tRevoked    revokedInfo \"explicit,tag:1,optional\"\n-\tUnknown    asn1.Flag   \"explicit,tag:2,optional\"\n+\tGood       asn1.Flag   `asn1:\"explicit,tag:0,optional\"`\n+\tRevoked    revokedInfo `asn1:\"explicit,tag:1,optional\"`\n+\tUnknown    asn1.Flag   `asn1:\"explicit,tag:2,optional\"`\n \tThisUpdate *time.Time\n-\tNextUpdate *time.Time \"explicit,tag:0,optional\"\n+\tNextUpdate *time.Time `asn1:\"explicit,tag:0,optional\"`\n }\n \n type revokedInfo struct {\n \tRevocationTime *time.Time\n-\tReason         int \"explicit,tag:0,optional\"\n+\tReason         int `asn1:\"explicit,tag:0,optional\"`\n }\n \n // This is the exposed reflection of the internal OCSP structures."}, {"sha": "9c4180d6d6d54d0ed3425665bf9c8f78d44df51f", "filename": "libgo/go/crypto/openpgp/armor/armor.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -153,7 +153,7 @@ func (r *openpgpReader) Read(p []byte) (n int, err os.Error) {\n \n // Decode reads a PGP armored block from the given Reader. It will ignore\n // leading garbage. If it doesn't find a block, it will return nil, os.EOF. The\n-// given Reader is not usable after calling this function: an arbitary amount\n+// given Reader is not usable after calling this function: an arbitrary amount\n // of data may have been read past the end of the block.\n func Decode(in io.Reader) (p *Block, err os.Error) {\n \tr, _ := bufio.NewReaderSize(in, 100)"}, {"sha": "ccf2910cc6c4d765bd5f639e07a5a9e10c4f442d", "filename": "libgo/go/crypto/openpgp/canonical_text_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -30,7 +30,6 @@ func (r recordingHash) Size() int {\n \tpanic(\"shouldn't be called\")\n }\n \n-\n func testCanonicalText(t *testing.T, input, expected string) {\n \tr := recordingHash{bytes.NewBuffer(nil)}\n \tc := NewCanonicalTextHash(r)"}, {"sha": "99a6e3e1f2d7074f0024afb7f083e1858602f63f", "filename": "libgo/go/crypto/openpgp/elgamal/elgamal.go", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Felgamal%2Felgamal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Felgamal%2Felgamal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Felgamal%2Felgamal.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package elgamal implements ElGamal encryption, suitable for OpenPGP,\n+// as specified in \"A Public-Key Cryptosystem and a Signature Scheme Based on\n+// Discrete Logarithms,\" IEEE Transactions on Information Theory, v. IT-31,\n+// n. 4, 1985, pp. 469-472.\n+//\n+// This form of ElGamal embeds PKCS#1 v1.5 padding, which may make it\n+// unsuitable for other protocols. RSA should be used in preference in any\n+// case.\n+package elgamal\n+\n+import (\n+\t\"big\"\n+\t\"crypto/rand\"\n+\t\"crypto/subtle\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// PublicKey represents an ElGamal public key.\n+type PublicKey struct {\n+\tG, P, Y *big.Int\n+}\n+\n+// PrivateKey represents an ElGamal private key.\n+type PrivateKey struct {\n+\tPublicKey\n+\tX *big.Int\n+}\n+\n+// Encrypt encrypts the given message to the given public key. The result is a\n+// pair of integers. Errors can result from reading random, or because msg is\n+// too large to be encrypted to the public key.\n+func Encrypt(random io.Reader, pub *PublicKey, msg []byte) (c1, c2 *big.Int, err os.Error) {\n+\tpLen := (pub.P.BitLen() + 7) / 8\n+\tif len(msg) > pLen-11 {\n+\t\terr = os.NewError(\"elgamal: message too long\")\n+\t\treturn\n+\t}\n+\n+\t// EM = 0x02 || PS || 0x00 || M\n+\tem := make([]byte, pLen-1)\n+\tem[0] = 2\n+\tps, mm := em[1:len(em)-len(msg)-1], em[len(em)-len(msg):]\n+\terr = nonZeroRandomBytes(ps, random)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tem[len(em)-len(msg)-1] = 0\n+\tcopy(mm, msg)\n+\n+\tm := new(big.Int).SetBytes(em)\n+\n+\tk, err := rand.Int(random, pub.P)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tc1 = new(big.Int).Exp(pub.G, k, pub.P)\n+\ts := new(big.Int).Exp(pub.Y, k, pub.P)\n+\tc2 = s.Mul(s, m)\n+\tc2.Mod(c2, pub.P)\n+\n+\treturn\n+}\n+\n+// Decrypt takes two integers, resulting from an ElGamal encryption, and\n+// returns the plaintext of the message. An error can result only if the\n+// ciphertext is invalid. Users should keep in mind that this is a padding\n+// oracle and thus, if exposed to an adaptive chosen ciphertext attack, can\n+// be used to break the cryptosystem.  See ``Chosen Ciphertext Attacks\n+// Against Protocols Based on the RSA Encryption Standard PKCS #1'', Daniel\n+// Bleichenbacher, Advances in Cryptology (Crypto '98),\n+func Decrypt(priv *PrivateKey, c1, c2 *big.Int) (msg []byte, err os.Error) {\n+\ts := new(big.Int).Exp(c1, priv.X, priv.P)\n+\ts.ModInverse(s, priv.P)\n+\ts.Mul(s, c2)\n+\ts.Mod(s, priv.P)\n+\tem := s.Bytes()\n+\n+\tfirstByteIsTwo := subtle.ConstantTimeByteEq(em[0], 2)\n+\n+\t// The remainder of the plaintext must be a string of non-zero random\n+\t// octets, followed by a 0, followed by the message.\n+\t//   lookingForIndex: 1 iff we are still looking for the zero.\n+\t//   index: the offset of the first zero byte.\n+\tvar lookingForIndex, index int\n+\tlookingForIndex = 1\n+\n+\tfor i := 1; i < len(em); i++ {\n+\t\tequals0 := subtle.ConstantTimeByteEq(em[i], 0)\n+\t\tindex = subtle.ConstantTimeSelect(lookingForIndex&equals0, i, index)\n+\t\tlookingForIndex = subtle.ConstantTimeSelect(equals0, 0, lookingForIndex)\n+\t}\n+\n+\tif firstByteIsTwo != 1 || lookingForIndex != 0 || index < 9 {\n+\t\treturn nil, os.NewError(\"elgamal: decryption error\")\n+\t}\n+\treturn em[index+1:], nil\n+}\n+\n+// nonZeroRandomBytes fills the given slice with non-zero random octets.\n+func nonZeroRandomBytes(s []byte, rand io.Reader) (err os.Error) {\n+\t_, err = io.ReadFull(rand, s)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tfor i := 0; i < len(s); i++ {\n+\t\tfor s[i] == 0 {\n+\t\t\t_, err = io.ReadFull(rand, s[i:i+1])\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn\n+}"}, {"sha": "101121aa65820e9ad59d7583fa3c7ca832c5a710", "filename": "libgo/go/crypto/openpgp/elgamal/elgamal_test.go", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Felgamal%2Felgamal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Felgamal%2Felgamal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Felgamal%2Felgamal_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package elgamal\n+\n+import (\n+\t\"big\"\n+\t\"bytes\"\n+\t\"crypto/rand\"\n+\t\"testing\"\n+)\n+\n+// This is the 1024-bit MODP group from RFC 5114, section 2.1:\n+const primeHex = \"B10B8F96A080E01DDE92DE5EAE5D54EC52C99FBCFB06A3C69A6A9DCA52D23B616073E28675A23D189838EF1E2EE652C013ECB4AEA906112324975C3CD49B83BFACCBDD7D90C4BD7098488E9C219A73724EFFD6FAE5644738FAA31A4FF55BCCC0A151AF5F0DC8B4BD45BF37DF365C1A65E68CFDA76D4DA708DF1FB2BC2E4A4371\"\n+\n+const generatorHex = \"A4D1CBD5C3FD34126765A442EFB99905F8104DD258AC507FD6406CFF14266D31266FEA1E5C41564B777E690F5504F213160217B4B01B886A5E91547F9E2749F4D7FBD7D3B9A92EE1909D0D2263F80A76A6A24C087A091F531DBF0A0169B6A28AD662A4D18E73AFA32D779D5918D08BC8858F4DCEF97C2A24855E6EEB22B3B2E5\"\n+\n+func fromHex(hex string) *big.Int {\n+\tn, ok := new(big.Int).SetString(hex, 16)\n+\tif !ok {\n+\t\tpanic(\"failed to parse hex number\")\n+\t}\n+\treturn n\n+}\n+\n+func TestEncryptDecrypt(t *testing.T) {\n+\tpriv := &PrivateKey{\n+\t\tPublicKey: PublicKey{\n+\t\t\tG: fromHex(generatorHex),\n+\t\t\tP: fromHex(primeHex),\n+\t\t},\n+\t\tX: fromHex(\"42\"),\n+\t}\n+\tpriv.Y = new(big.Int).Exp(priv.G, priv.X, priv.P)\n+\n+\tmessage := []byte(\"hello world\")\n+\tc1, c2, err := Encrypt(rand.Reader, &priv.PublicKey, message)\n+\tif err != nil {\n+\t\tt.Errorf(\"error encrypting: %s\", err)\n+\t}\n+\tmessage2, err := Decrypt(priv, c1, c2)\n+\tif err != nil {\n+\t\tt.Errorf(\"error decrypting: %s\", err)\n+\t}\n+\tif !bytes.Equal(message2, message) {\n+\t\tt.Errorf(\"decryption failed, got: %x, want: %x\", message2, message)\n+\t}\n+}"}, {"sha": "c70fb79270488b37919628e62aa2366297362081", "filename": "libgo/go/crypto/openpgp/keys.go", "status": "modified", "additions": 247, "deletions": 1, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -5,11 +5,14 @@\n package openpgp\n \n import (\n+\t\"crypto\"\n \t\"crypto/openpgp/armor\"\n \t\"crypto/openpgp/error\"\n \t\"crypto/openpgp/packet\"\n+\t\"crypto/rsa\"\n \t\"io\"\n \t\"os\"\n+\t\"time\"\n )\n \n // PublicKeyType is the armor type for a PGP public key.\n@@ -62,6 +65,78 @@ type KeyRing interface {\n \tDecryptionKeys() []Key\n }\n \n+// primaryIdentity returns the Identity marked as primary or the first identity\n+// if none are so marked.\n+func (e *Entity) primaryIdentity() *Identity {\n+\tvar firstIdentity *Identity\n+\tfor _, ident := range e.Identities {\n+\t\tif firstIdentity == nil {\n+\t\t\tfirstIdentity = ident\n+\t\t}\n+\t\tif ident.SelfSignature.IsPrimaryId != nil && *ident.SelfSignature.IsPrimaryId {\n+\t\t\treturn ident\n+\t\t}\n+\t}\n+\treturn firstIdentity\n+}\n+\n+// encryptionKey returns the best candidate Key for encrypting a message to the\n+// given Entity.\n+func (e *Entity) encryptionKey() Key {\n+\tcandidateSubkey := -1\n+\n+\tfor i, subkey := range e.Subkeys {\n+\t\tif subkey.Sig.FlagsValid && subkey.Sig.FlagEncryptCommunications && subkey.PublicKey.PubKeyAlgo.CanEncrypt() {\n+\t\t\tcandidateSubkey = i\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\ti := e.primaryIdentity()\n+\n+\tif e.PrimaryKey.PubKeyAlgo.CanEncrypt() {\n+\t\t// If we don't have any candidate subkeys for encryption and\n+\t\t// the primary key doesn't have any usage metadata then we\n+\t\t// assume that the primary key is ok. Or, if the primary key is\n+\t\t// marked as ok to encrypt to, then we can obviously use it.\n+\t\tif candidateSubkey == -1 && !i.SelfSignature.FlagsValid || i.SelfSignature.FlagEncryptCommunications && i.SelfSignature.FlagsValid {\n+\t\t\treturn Key{e, e.PrimaryKey, e.PrivateKey, i.SelfSignature}\n+\t\t}\n+\t}\n+\n+\tif candidateSubkey != -1 {\n+\t\tsubkey := e.Subkeys[candidateSubkey]\n+\t\treturn Key{e, subkey.PublicKey, subkey.PrivateKey, subkey.Sig}\n+\t}\n+\n+\t// This Entity appears to be signing only.\n+\treturn Key{}\n+}\n+\n+// signingKey return the best candidate Key for signing a message with this\n+// Entity.\n+func (e *Entity) signingKey() Key {\n+\tcandidateSubkey := -1\n+\n+\tfor i, subkey := range e.Subkeys {\n+\t\tif subkey.Sig.FlagsValid && subkey.Sig.FlagSign && subkey.PublicKey.PubKeyAlgo.CanSign() {\n+\t\t\tcandidateSubkey = i\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\ti := e.primaryIdentity()\n+\n+\t// If we have no candidate subkey then we assume that it's ok to sign\n+\t// with the primary key.\n+\tif candidateSubkey == -1 || i.SelfSignature.FlagsValid && i.SelfSignature.FlagSign {\n+\t\treturn Key{e, e.PrimaryKey, e.PrivateKey, i.SelfSignature}\n+\t}\n+\n+\tsubkey := e.Subkeys[candidateSubkey]\n+\treturn Key{e, subkey.PublicKey, subkey.PrivateKey, subkey.Sig}\n+}\n+\n // An EntityList contains one or more Entities.\n type EntityList []*Entity\n \n@@ -197,6 +272,10 @@ func readEntity(packets *packet.Reader) (*Entity, os.Error) {\n \t\t}\n \t}\n \n+\tif !e.PrimaryKey.PubKeyAlgo.CanSign() {\n+\t\treturn nil, error.StructuralError(\"primary key cannot be used for signatures\")\n+\t}\n+\n \tvar current *Identity\n EachPacket:\n \tfor {\n@@ -227,7 +306,7 @@ EachPacket:\n \t\t\t\t\treturn nil, error.StructuralError(\"user ID packet not followed by self-signature\")\n \t\t\t\t}\n \n-\t\t\t\tif sig.SigType == packet.SigTypePositiveCert && sig.IssuerKeyId != nil && *sig.IssuerKeyId == e.PrimaryKey.KeyId {\n+\t\t\t\tif (sig.SigType == packet.SigTypePositiveCert || sig.SigType == packet.SigTypeGenericCert) && sig.IssuerKeyId != nil && *sig.IssuerKeyId == e.PrimaryKey.KeyId {\n \t\t\t\t\tif err = e.PrimaryKey.VerifyUserIdSignature(pkt.Id, sig); err != nil {\n \t\t\t\t\t\treturn nil, error.StructuralError(\"user ID self-signature invalid: \" + err.String())\n \t\t\t\t\t}\n@@ -297,3 +376,170 @@ func addSubkey(e *Entity, packets *packet.Reader, pub *packet.PublicKey, priv *p\n \te.Subkeys = append(e.Subkeys, subKey)\n \treturn nil\n }\n+\n+const defaultRSAKeyBits = 2048\n+\n+// NewEntity returns an Entity that contains a fresh RSA/RSA keypair with a\n+// single identity composed of the given full name, comment and email, any of\n+// which may be empty but must not contain any of \"()<>\\x00\".\n+func NewEntity(rand io.Reader, currentTimeSecs int64, name, comment, email string) (*Entity, os.Error) {\n+\tuid := packet.NewUserId(name, comment, email)\n+\tif uid == nil {\n+\t\treturn nil, error.InvalidArgumentError(\"user id field contained invalid characters\")\n+\t}\n+\tsigningPriv, err := rsa.GenerateKey(rand, defaultRSAKeyBits)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tencryptingPriv, err := rsa.GenerateKey(rand, defaultRSAKeyBits)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tt := uint32(currentTimeSecs)\n+\n+\te := &Entity{\n+\t\tPrimaryKey: packet.NewRSAPublicKey(t, &signingPriv.PublicKey, false /* not a subkey */ ),\n+\t\tPrivateKey: packet.NewRSAPrivateKey(t, signingPriv, false /* not a subkey */ ),\n+\t\tIdentities: make(map[string]*Identity),\n+\t}\n+\tisPrimaryId := true\n+\te.Identities[uid.Id] = &Identity{\n+\t\tName:   uid.Name,\n+\t\tUserId: uid,\n+\t\tSelfSignature: &packet.Signature{\n+\t\t\tCreationTime: t,\n+\t\t\tSigType:      packet.SigTypePositiveCert,\n+\t\t\tPubKeyAlgo:   packet.PubKeyAlgoRSA,\n+\t\t\tHash:         crypto.SHA256,\n+\t\t\tIsPrimaryId:  &isPrimaryId,\n+\t\t\tFlagsValid:   true,\n+\t\t\tFlagSign:     true,\n+\t\t\tFlagCertify:  true,\n+\t\t\tIssuerKeyId:  &e.PrimaryKey.KeyId,\n+\t\t},\n+\t}\n+\n+\te.Subkeys = make([]Subkey, 1)\n+\te.Subkeys[0] = Subkey{\n+\t\tPublicKey:  packet.NewRSAPublicKey(t, &encryptingPriv.PublicKey, true /* is a subkey */ ),\n+\t\tPrivateKey: packet.NewRSAPrivateKey(t, encryptingPriv, true /* is a subkey */ ),\n+\t\tSig: &packet.Signature{\n+\t\t\tCreationTime:              t,\n+\t\t\tSigType:                   packet.SigTypeSubkeyBinding,\n+\t\t\tPubKeyAlgo:                packet.PubKeyAlgoRSA,\n+\t\t\tHash:                      crypto.SHA256,\n+\t\t\tFlagsValid:                true,\n+\t\t\tFlagEncryptStorage:        true,\n+\t\t\tFlagEncryptCommunications: true,\n+\t\t\tIssuerKeyId:               &e.PrimaryKey.KeyId,\n+\t\t},\n+\t}\n+\n+\treturn e, nil\n+}\n+\n+// SerializePrivate serializes an Entity, including private key material, to\n+// the given Writer. For now, it must only be used on an Entity returned from\n+// NewEntity.\n+func (e *Entity) SerializePrivate(w io.Writer) (err os.Error) {\n+\terr = e.PrivateKey.Serialize(w)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tfor _, ident := range e.Identities {\n+\t\terr = ident.UserId.Serialize(w)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\terr = ident.SelfSignature.SignUserId(ident.UserId.Id, e.PrimaryKey, e.PrivateKey)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\terr = ident.SelfSignature.Serialize(w)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tfor _, subkey := range e.Subkeys {\n+\t\terr = subkey.PrivateKey.Serialize(w)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\terr = subkey.Sig.SignKey(subkey.PublicKey, e.PrivateKey)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\terr = subkey.Sig.Serialize(w)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// Serialize writes the public part of the given Entity to w. (No private\n+// key material will be output).\n+func (e *Entity) Serialize(w io.Writer) os.Error {\n+\terr := e.PrimaryKey.Serialize(w)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tfor _, ident := range e.Identities {\n+\t\terr = ident.UserId.Serialize(w)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\terr = ident.SelfSignature.Serialize(w)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tfor _, sig := range ident.Signatures {\n+\t\t\terr = sig.Serialize(w)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t}\n+\tfor _, subkey := range e.Subkeys {\n+\t\terr = subkey.PublicKey.Serialize(w)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\terr = subkey.Sig.Serialize(w)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// SignIdentity adds a signature to e, from signer, attesting that identity is\n+// associated with e. The provided identity must already be an element of\n+// e.Identities and the private key of signer must have been decrypted if\n+// necessary.\n+func (e *Entity) SignIdentity(identity string, signer *Entity) os.Error {\n+\tif signer.PrivateKey == nil {\n+\t\treturn error.InvalidArgumentError(\"signing Entity must have a private key\")\n+\t}\n+\tif signer.PrivateKey.Encrypted {\n+\t\treturn error.InvalidArgumentError(\"signing Entity's private key must be decrypted\")\n+\t}\n+\tident, ok := e.Identities[identity]\n+\tif !ok {\n+\t\treturn error.InvalidArgumentError(\"given identity string not found in Entity\")\n+\t}\n+\n+\tsig := &packet.Signature{\n+\t\tSigType:      packet.SigTypeGenericCert,\n+\t\tPubKeyAlgo:   signer.PrivateKey.PubKeyAlgo,\n+\t\tHash:         crypto.SHA256,\n+\t\tCreationTime: uint32(time.Seconds()),\n+\t\tIssuerKeyId:  &signer.PrivateKey.KeyId,\n+\t}\n+\tif err := sig.SignKey(e.PrimaryKey, signer.PrivateKey); err != nil {\n+\t\treturn err\n+\t}\n+\tident.Signatures = append(ident.Signatures, sig)\n+\treturn nil\n+}"}, {"sha": "b4730cbc9bc24b0b58169f5f59800a5b7560655b", "filename": "libgo/go/crypto/openpgp/packet/encrypted_key.go", "status": "modified", "additions": 117, "deletions": 15, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -5,6 +5,8 @@\n package packet\n \n import (\n+\t\"big\"\n+\t\"crypto/openpgp/elgamal\"\n \t\"crypto/openpgp/error\"\n \t\"crypto/rand\"\n \t\"crypto/rsa\"\n@@ -14,14 +16,17 @@ import (\n \t\"strconv\"\n )\n \n+const encryptedKeyVersion = 3\n+\n // EncryptedKey represents a public-key encrypted session key. See RFC 4880,\n // section 5.1.\n type EncryptedKey struct {\n \tKeyId      uint64\n \tAlgo       PublicKeyAlgorithm\n-\tEncrypted  []byte\n \tCipherFunc CipherFunction // only valid after a successful Decrypt\n \tKey        []byte         // only valid after a successful Decrypt\n+\n+\tencryptedMPI1, encryptedMPI2 []byte\n }\n \n func (e *EncryptedKey) parse(r io.Reader) (err os.Error) {\n@@ -30,37 +35,134 @@ func (e *EncryptedKey) parse(r io.Reader) (err os.Error) {\n \tif err != nil {\n \t\treturn\n \t}\n-\tif buf[0] != 3 {\n+\tif buf[0] != encryptedKeyVersion {\n \t\treturn error.UnsupportedError(\"unknown EncryptedKey version \" + strconv.Itoa(int(buf[0])))\n \t}\n \te.KeyId = binary.BigEndian.Uint64(buf[1:9])\n \te.Algo = PublicKeyAlgorithm(buf[9])\n-\tif e.Algo == PubKeyAlgoRSA || e.Algo == PubKeyAlgoRSAEncryptOnly {\n-\t\te.Encrypted, _, err = readMPI(r)\n+\tswitch e.Algo {\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly:\n+\t\te.encryptedMPI1, _, err = readMPI(r)\n+\tcase PubKeyAlgoElGamal:\n+\t\te.encryptedMPI1, _, err = readMPI(r)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\te.encryptedMPI2, _, err = readMPI(r)\n \t}\n \t_, err = consumeAll(r)\n \treturn\n }\n \n-// DecryptRSA decrypts an RSA encrypted session key with the given private key.\n-func (e *EncryptedKey) DecryptRSA(priv *rsa.PrivateKey) (err os.Error) {\n-\tif e.Algo != PubKeyAlgoRSA && e.Algo != PubKeyAlgoRSAEncryptOnly {\n-\t\treturn error.InvalidArgumentError(\"EncryptedKey not RSA encrypted\")\n+func checksumKeyMaterial(key []byte) uint16 {\n+\tvar checksum uint16\n+\tfor _, v := range key {\n+\t\tchecksum += uint16(v)\n \t}\n-\tb, err := rsa.DecryptPKCS1v15(rand.Reader, priv, e.Encrypted)\n+\treturn checksum\n+}\n+\n+// Decrypt decrypts an encrypted session key with the given private key. The\n+// private key must have been decrypted first.\n+func (e *EncryptedKey) Decrypt(priv *PrivateKey) os.Error {\n+\tvar err os.Error\n+\tvar b []byte\n+\n+\t// TODO(agl): use session key decryption routines here to avoid\n+\t// padding oracle attacks.\n+\tswitch priv.PubKeyAlgo {\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly:\n+\t\tb, err = rsa.DecryptPKCS1v15(rand.Reader, priv.PrivateKey.(*rsa.PrivateKey), e.encryptedMPI1)\n+\tcase PubKeyAlgoElGamal:\n+\t\tc1 := new(big.Int).SetBytes(e.encryptedMPI1)\n+\t\tc2 := new(big.Int).SetBytes(e.encryptedMPI2)\n+\t\tb, err = elgamal.Decrypt(priv.PrivateKey.(*elgamal.PrivateKey), c1, c2)\n+\tdefault:\n+\t\terr = error.InvalidArgumentError(\"cannot decrypted encrypted session key with private key of type \" + strconv.Itoa(int(priv.PubKeyAlgo)))\n+\t}\n+\n \tif err != nil {\n-\t\treturn\n+\t\treturn err\n \t}\n+\n \te.CipherFunc = CipherFunction(b[0])\n \te.Key = b[1 : len(b)-2]\n \texpectedChecksum := uint16(b[len(b)-2])<<8 | uint16(b[len(b)-1])\n-\tvar checksum uint16\n-\tfor _, v := range e.Key {\n-\t\tchecksum += uint16(v)\n-\t}\n+\tchecksum := checksumKeyMaterial(e.Key)\n \tif checksum != expectedChecksum {\n \t\treturn error.StructuralError(\"EncryptedKey checksum incorrect\")\n \t}\n \n-\treturn\n+\treturn nil\n+}\n+\n+// SerializeEncryptedKey serializes an encrypted key packet to w that contains\n+// key, encrypted to pub.\n+func SerializeEncryptedKey(w io.Writer, rand io.Reader, pub *PublicKey, cipherFunc CipherFunction, key []byte) os.Error {\n+\tvar buf [10]byte\n+\tbuf[0] = encryptedKeyVersion\n+\tbinary.BigEndian.PutUint64(buf[1:9], pub.KeyId)\n+\tbuf[9] = byte(pub.PubKeyAlgo)\n+\n+\tkeyBlock := make([]byte, 1 /* cipher type */ +len(key)+2 /* checksum */ )\n+\tkeyBlock[0] = byte(cipherFunc)\n+\tcopy(keyBlock[1:], key)\n+\tchecksum := checksumKeyMaterial(key)\n+\tkeyBlock[1+len(key)] = byte(checksum >> 8)\n+\tkeyBlock[1+len(key)+1] = byte(checksum)\n+\n+\tswitch pub.PubKeyAlgo {\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly:\n+\t\treturn serializeEncryptedKeyRSA(w, rand, buf, pub.PublicKey.(*rsa.PublicKey), keyBlock)\n+\tcase PubKeyAlgoElGamal:\n+\t\treturn serializeEncryptedKeyElGamal(w, rand, buf, pub.PublicKey.(*elgamal.PublicKey), keyBlock)\n+\tcase PubKeyAlgoDSA, PubKeyAlgoRSASignOnly:\n+\t\treturn error.InvalidArgumentError(\"cannot encrypt to public key of type \" + strconv.Itoa(int(pub.PubKeyAlgo)))\n+\t}\n+\n+\treturn error.UnsupportedError(\"encrypting a key to public key of type \" + strconv.Itoa(int(pub.PubKeyAlgo)))\n+}\n+\n+func serializeEncryptedKeyRSA(w io.Writer, rand io.Reader, header [10]byte, pub *rsa.PublicKey, keyBlock []byte) os.Error {\n+\tcipherText, err := rsa.EncryptPKCS1v15(rand, pub, keyBlock)\n+\tif err != nil {\n+\t\treturn error.InvalidArgumentError(\"RSA encryption failed: \" + err.String())\n+\t}\n+\n+\tpacketLen := 10 /* header length */ + 2 /* mpi size */ + len(cipherText)\n+\n+\terr = serializeHeader(w, packetTypeEncryptedKey, packetLen)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\t_, err = w.Write(header[:])\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn writeMPI(w, 8*uint16(len(cipherText)), cipherText)\n+}\n+\n+func serializeEncryptedKeyElGamal(w io.Writer, rand io.Reader, header [10]byte, pub *elgamal.PublicKey, keyBlock []byte) os.Error {\n+\tc1, c2, err := elgamal.Encrypt(rand, pub, keyBlock)\n+\tif err != nil {\n+\t\treturn error.InvalidArgumentError(\"ElGamal encryption failed: \" + err.String())\n+\t}\n+\n+\tpacketLen := 10 /* header length */\n+\tpacketLen += 2 /* mpi size */ + (c1.BitLen()+7)/8\n+\tpacketLen += 2 /* mpi size */ + (c2.BitLen()+7)/8\n+\n+\terr = serializeHeader(w, packetTypeEncryptedKey, packetLen)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\t_, err = w.Write(header[:])\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\terr = writeBig(w, c1)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn writeBig(w, c2)\n }"}, {"sha": "b402245bdae2d9bf3bb4cf1ec3885c4beb37fc93", "filename": "libgo/go/crypto/openpgp/packet/encrypted_key_test.go", "status": "modified", "additions": 72, "deletions": 13, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -6,6 +6,8 @@ package packet\n \n import (\n \t\"big\"\n+\t\"bytes\"\n+\t\"crypto/rand\"\n \t\"crypto/rsa\"\n \t\"fmt\"\n \t\"testing\"\n@@ -19,7 +21,27 @@ func bigFromBase10(s string) *big.Int {\n \treturn b\n }\n \n-func TestEncryptedKey(t *testing.T) {\n+var encryptedKeyPub = rsa.PublicKey{\n+\tE: 65537,\n+\tN: bigFromBase10(\"115804063926007623305902631768113868327816898845124614648849934718568541074358183759250136204762053879858102352159854352727097033322663029387610959884180306668628526686121021235757016368038585212410610742029286439607686208110250133174279811431933746643015923132833417396844716207301518956640020862630546868823\"),\n+}\n+\n+var encryptedKeyRSAPriv = &rsa.PrivateKey{\n+\tPublicKey: encryptedKeyPub,\n+\tD:         bigFromBase10(\"32355588668219869544751561565313228297765464314098552250409557267371233892496951383426602439009993875125222579159850054973310859166139474359774543943714622292329487391199285040721944491839695981199720170366763547754915493640685849961780092241140181198779299712578774460837139360803883139311171713302987058393\"),\n+}\n+\n+var encryptedKeyPriv = &PrivateKey{\n+\tPublicKey: PublicKey{\n+\t\tPubKeyAlgo: PubKeyAlgoRSA,\n+\t},\n+\tPrivateKey: encryptedKeyRSAPriv,\n+}\n+\n+func TestDecryptingEncryptedKey(t *testing.T) {\n+\tconst encryptedKeyHex = \"c18c032a67d68660df41c70104005789d0de26b6a50c985a02a13131ca829c413a35d0e6fa8d6842599252162808ac7439c72151c8c6183e76923fe3299301414d0c25a2f06a2257db3839e7df0ec964773f6e4c4ac7ff3b48c444237166dd46ba8ff443a5410dc670cb486672fdbe7c9dfafb75b4fea83af3a204fe2a7dfa86bd20122b4f3d2646cbeecb8f7be8\"\n+\tconst expectedKeyHex = \"d930363f7e0308c333b9618617ea728963d8df993665ae7be1092d4926fd864b\"\n+\n \tp, err := Read(readerFromHex(encryptedKeyHex))\n \tif err != nil {\n \t\tt.Errorf(\"error from Read: %s\", err)\n@@ -36,23 +58,63 @@ func TestEncryptedKey(t *testing.T) {\n \t\treturn\n \t}\n \n-\tpub := rsa.PublicKey{\n-\t\tE: 65537,\n-\t\tN: bigFromBase10(\"115804063926007623305902631768113868327816898845124614648849934718568541074358183759250136204762053879858102352159854352727097033322663029387610959884180306668628526686121021235757016368038585212410610742029286439607686208110250133174279811431933746643015923132833417396844716207301518956640020862630546868823\"),\n+\terr = ek.Decrypt(encryptedKeyPriv)\n+\tif err != nil {\n+\t\tt.Errorf(\"error from Decrypt: %s\", err)\n+\t\treturn\n+\t}\n+\n+\tif ek.CipherFunc != CipherAES256 {\n+\t\tt.Errorf(\"unexpected EncryptedKey contents: %#v\", ek)\n+\t\treturn\n+\t}\n+\n+\tkeyHex := fmt.Sprintf(\"%x\", ek.Key)\n+\tif keyHex != expectedKeyHex {\n+\t\tt.Errorf(\"bad key, got %s want %x\", keyHex, expectedKeyHex)\n+\t}\n+}\n+\n+func TestEncryptingEncryptedKey(t *testing.T) {\n+\tkey := []byte{1, 2, 3, 4}\n+\tconst expectedKeyHex = \"01020304\"\n+\tconst keyId = 42\n+\n+\tpub := &PublicKey{\n+\t\tPublicKey:  &encryptedKeyPub,\n+\t\tKeyId:      keyId,\n+\t\tPubKeyAlgo: PubKeyAlgoRSAEncryptOnly,\n+\t}\n+\n+\tbuf := new(bytes.Buffer)\n+\terr := SerializeEncryptedKey(buf, rand.Reader, pub, CipherAES128, key)\n+\tif err != nil {\n+\t\tt.Errorf(\"error writing encrypted key packet: %s\", err)\n+\t}\n+\n+\tp, err := Read(buf)\n+\tif err != nil {\n+\t\tt.Errorf(\"error from Read: %s\", err)\n+\t\treturn\n+\t}\n+\tek, ok := p.(*EncryptedKey)\n+\tif !ok {\n+\t\tt.Errorf(\"didn't parse an EncryptedKey, got %#v\", p)\n+\t\treturn\n \t}\n \n-\tpriv := &rsa.PrivateKey{\n-\t\tPublicKey: pub,\n-\t\tD:         bigFromBase10(\"32355588668219869544751561565313228297765464314098552250409557267371233892496951383426602439009993875125222579159850054973310859166139474359774543943714622292329487391199285040721944491839695981199720170366763547754915493640685849961780092241140181198779299712578774460837139360803883139311171713302987058393\"),\n+\tif ek.KeyId != keyId || ek.Algo != PubKeyAlgoRSAEncryptOnly {\n+\t\tt.Errorf(\"unexpected EncryptedKey contents: %#v\", ek)\n+\t\treturn\n \t}\n \n-\terr = ek.DecryptRSA(priv)\n+\terr = ek.Decrypt(encryptedKeyPriv)\n \tif err != nil {\n-\t\tt.Errorf(\"error from DecryptRSA: %s\", err)\n+\t\tt.Errorf(\"error from Decrypt: %s\", err)\n \t\treturn\n \t}\n \n-\tif ek.CipherFunc != CipherAES256 {\n+\tif ek.CipherFunc != CipherAES128 {\n \t\tt.Errorf(\"unexpected EncryptedKey contents: %#v\", ek)\n \t\treturn\n \t}\n@@ -62,6 +124,3 @@ func TestEncryptedKey(t *testing.T) {\n \t\tt.Errorf(\"bad key, got %s want %x\", keyHex, expectedKeyHex)\n \t}\n }\n-\n-const encryptedKeyHex = \"c18c032a67d68660df41c70104005789d0de26b6a50c985a02a13131ca829c413a35d0e6fa8d6842599252162808ac7439c72151c8c6183e76923fe3299301414d0c25a2f06a2257db3839e7df0ec964773f6e4c4ac7ff3b48c444237166dd46ba8ff443a5410dc670cb486672fdbe7c9dfafb75b4fea83af3a204fe2a7dfa86bd20122b4f3d2646cbeecb8f7be8\"\n-const expectedKeyHex = \"d930363f7e0308c333b9618617ea728963d8df993665ae7be1092d4926fd864b\""}, {"sha": "9411572d7c99ff0bc513680403a7ffe142145d16", "filename": "libgo/go/crypto/openpgp/packet/literal.go", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fliteral.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fliteral.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fliteral.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -51,3 +51,40 @@ func (l *LiteralData) parse(r io.Reader) (err os.Error) {\n \tl.Body = r\n \treturn\n }\n+\n+// SerializeLiteral serializes a literal data packet to w and returns a\n+// WriteCloser to which the data itself can be written and which MUST be closed\n+// on completion. The fileName is truncated to 255 bytes.\n+func SerializeLiteral(w io.WriteCloser, isBinary bool, fileName string, time uint32) (plaintext io.WriteCloser, err os.Error) {\n+\tvar buf [4]byte\n+\tbuf[0] = 't'\n+\tif isBinary {\n+\t\tbuf[0] = 'b'\n+\t}\n+\tif len(fileName) > 255 {\n+\t\tfileName = fileName[:255]\n+\t}\n+\tbuf[1] = byte(len(fileName))\n+\n+\tinner, err := serializeStreamHeader(w, packetTypeLiteralData)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\t_, err = inner.Write(buf[:2])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, err = inner.Write([]byte(fileName))\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tbinary.BigEndian.PutUint32(buf[:], time)\n+\t_, err = inner.Write(buf[:])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tplaintext = inner\n+\treturn\n+}"}, {"sha": "ca826e4f4d2e691a938800b4175f9ba2b2c5f0db", "filename": "libgo/go/crypto/openpgp/packet/one_pass_signature.go", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fone_pass_signature.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fone_pass_signature.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fone_pass_signature.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -24,14 +24,16 @@ type OnePassSignature struct {\n \tIsLast     bool\n }\n \n+const onePassSignatureVersion = 3\n+\n func (ops *OnePassSignature) parse(r io.Reader) (err os.Error) {\n \tvar buf [13]byte\n \n \t_, err = readFull(r, buf[:])\n \tif err != nil {\n \t\treturn\n \t}\n-\tif buf[0] != 3 {\n+\tif buf[0] != onePassSignatureVersion {\n \t\terr = error.UnsupportedError(\"one-pass-signature packet version \" + strconv.Itoa(int(buf[0])))\n \t}\n \n@@ -47,3 +49,26 @@ func (ops *OnePassSignature) parse(r io.Reader) (err os.Error) {\n \tops.IsLast = buf[12] != 0\n \treturn\n }\n+\n+// Serialize marshals the given OnePassSignature to w.\n+func (ops *OnePassSignature) Serialize(w io.Writer) os.Error {\n+\tvar buf [13]byte\n+\tbuf[0] = onePassSignatureVersion\n+\tbuf[1] = uint8(ops.SigType)\n+\tvar ok bool\n+\tbuf[2], ok = s2k.HashToHashId(ops.Hash)\n+\tif !ok {\n+\t\treturn error.UnsupportedError(\"hash type: \" + strconv.Itoa(int(ops.Hash)))\n+\t}\n+\tbuf[3] = uint8(ops.PubKeyAlgo)\n+\tbinary.BigEndian.PutUint64(buf[4:12], ops.KeyId)\n+\tif ops.IsLast {\n+\t\tbuf[12] = 1\n+\t}\n+\n+\tif err := serializeHeader(w, packetTypeOnePassSignature, len(buf)); err != nil {\n+\t\treturn err\n+\t}\n+\t_, err := w.Write(buf[:])\n+\treturn err\n+}"}, {"sha": "1d7297e38847a1751cdb4b28328137d80bda2d8d", "filename": "libgo/go/crypto/openpgp/packet/packet.go", "status": "modified", "additions": 96, "deletions": 14, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package packet implements parsing and serialisation of OpenPGP packets, as\n+// Package packet implements parsing and serialization of OpenPGP packets, as\n // specified in RFC 4880.\n package packet\n \n@@ -92,6 +92,46 @@ func (r *partialLengthReader) Read(p []byte) (n int, err os.Error) {\n \treturn\n }\n \n+// partialLengthWriter writes a stream of data using OpenPGP partial lengths.\n+// See RFC 4880, section 4.2.2.4.\n+type partialLengthWriter struct {\n+\tw          io.WriteCloser\n+\tlengthByte [1]byte\n+}\n+\n+func (w *partialLengthWriter) Write(p []byte) (n int, err os.Error) {\n+\tfor len(p) > 0 {\n+\t\tfor power := uint(14); power < 32; power-- {\n+\t\t\tl := 1 << power\n+\t\t\tif len(p) >= l {\n+\t\t\t\tw.lengthByte[0] = 224 + uint8(power)\n+\t\t\t\t_, err = w.w.Write(w.lengthByte[:])\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tvar m int\n+\t\t\t\tm, err = w.w.Write(p[:l])\n+\t\t\t\tn += m\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tp = p[l:]\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+func (w *partialLengthWriter) Close() os.Error {\n+\tw.lengthByte[0] = 0\n+\t_, err := w.w.Write(w.lengthByte[:])\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn w.w.Close()\n+}\n+\n // A spanReader is an io.LimitReader, but it returns ErrUnexpectedEOF if the\n // underlying Reader returns EOF before the limit has been reached.\n type spanReader struct {\n@@ -195,6 +235,20 @@ func serializeHeader(w io.Writer, ptype packetType, length int) (err os.Error) {\n \treturn\n }\n \n+// serializeStreamHeader writes an OpenPGP packet header to w where the\n+// length of the packet is unknown. It returns a io.WriteCloser which can be\n+// used to write the contents of the packet. See RFC 4880, section 4.2.\n+func serializeStreamHeader(w io.WriteCloser, ptype packetType) (out io.WriteCloser, err os.Error) {\n+\tvar buf [1]byte\n+\tbuf[0] = 0x80 | 0x40 | byte(ptype)\n+\t_, err = w.Write(buf[:])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tout = &partialLengthWriter{w: w}\n+\treturn\n+}\n+\n // Packet represents an OpenPGP packet. Users are expected to try casting\n // instances of this interface to specific packet types.\n type Packet interface {\n@@ -301,12 +355,12 @@ type SignatureType uint8\n \n const (\n \tSigTypeBinary        SignatureType = 0\n-\tSigTypeText          = 1\n-\tSigTypeGenericCert   = 0x10\n-\tSigTypePersonaCert   = 0x11\n-\tSigTypeCasualCert    = 0x12\n-\tSigTypePositiveCert  = 0x13\n-\tSigTypeSubkeyBinding = 0x18\n+\tSigTypeText                        = 1\n+\tSigTypeGenericCert                 = 0x10\n+\tSigTypePersonaCert                 = 0x11\n+\tSigTypeCasualCert                  = 0x12\n+\tSigTypePositiveCert                = 0x13\n+\tSigTypeSubkeyBinding               = 0x18\n )\n \n // PublicKeyAlgorithm represents the different public key system specified for\n@@ -318,23 +372,43 @@ const (\n \tPubKeyAlgoRSA            PublicKeyAlgorithm = 1\n \tPubKeyAlgoRSAEncryptOnly PublicKeyAlgorithm = 2\n \tPubKeyAlgoRSASignOnly    PublicKeyAlgorithm = 3\n-\tPubKeyAlgoElgamal        PublicKeyAlgorithm = 16\n+\tPubKeyAlgoElGamal        PublicKeyAlgorithm = 16\n \tPubKeyAlgoDSA            PublicKeyAlgorithm = 17\n )\n \n+// CanEncrypt returns true if it's possible to encrypt a message to a public\n+// key of the given type.\n+func (pka PublicKeyAlgorithm) CanEncrypt() bool {\n+\tswitch pka {\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoElGamal:\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+// CanSign returns true if it's possible for a public key of the given type to\n+// sign a message.\n+func (pka PublicKeyAlgorithm) CanSign() bool {\n+\tswitch pka {\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly, PubKeyAlgoDSA:\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n // CipherFunction represents the different block ciphers specified for OpenPGP. See\n // http://www.iana.org/assignments/pgp-parameters/pgp-parameters.xhtml#pgp-parameters-13\n type CipherFunction uint8\n \n const (\n-\tCipherCAST5  = 3\n-\tCipherAES128 = 7\n-\tCipherAES192 = 8\n-\tCipherAES256 = 9\n+\tCipherCAST5  CipherFunction = 3\n+\tCipherAES128 CipherFunction = 7\n+\tCipherAES192 CipherFunction = 8\n+\tCipherAES256 CipherFunction = 9\n )\n \n-// keySize returns the key size, in bytes, of cipher.\n-func (cipher CipherFunction) keySize() int {\n+// KeySize returns the key size, in bytes, of cipher.\n+func (cipher CipherFunction) KeySize() int {\n \tswitch cipher {\n \tcase CipherCAST5:\n \t\treturn cast5.KeySize\n@@ -386,6 +460,14 @@ func readMPI(r io.Reader) (mpi []byte, bitLength uint16, err os.Error) {\n \treturn\n }\n \n+// mpiLength returns the length of the given *big.Int when serialized as an\n+// MPI.\n+func mpiLength(n *big.Int) (mpiLengthInBytes int) {\n+\tmpiLengthInBytes = 2 /* MPI length */\n+\tmpiLengthInBytes += (n.BitLen() + 7) / 8\n+\treturn\n+}\n+\n // writeMPI serializes a big integer to w.\n func writeMPI(w io.Writer, bitLength uint16, mpiBytes []byte) (err os.Error) {\n \t_, err = w.Write([]byte{byte(bitLength >> 8), byte(bitLength)})"}, {"sha": "23d9978ae1f30e1e699fc6a51225863ebda0eb41", "filename": "libgo/go/crypto/openpgp/packet/packet_test.go", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -210,3 +210,47 @@ func TestSerializeHeader(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestPartialLengths(t *testing.T) {\n+\tbuf := bytes.NewBuffer(nil)\n+\tw := new(partialLengthWriter)\n+\tw.w = noOpCloser{buf}\n+\n+\tconst maxChunkSize = 64\n+\n+\tvar b [maxChunkSize]byte\n+\tvar n uint8\n+\tfor l := 1; l <= maxChunkSize; l++ {\n+\t\tfor i := 0; i < l; i++ {\n+\t\t\tb[i] = n\n+\t\t\tn++\n+\t\t}\n+\t\tm, err := w.Write(b[:l])\n+\t\tif m != l {\n+\t\t\tt.Errorf(\"short write got: %d want: %d\", m, l)\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error from write: %s\", err)\n+\t\t}\n+\t}\n+\tw.Close()\n+\n+\twant := (maxChunkSize * (maxChunkSize + 1)) / 2\n+\tcopyBuf := bytes.NewBuffer(nil)\n+\tr := &partialLengthReader{buf, 0, true}\n+\tm, err := io.Copy(copyBuf, r)\n+\tif m != int64(want) {\n+\t\tt.Errorf(\"short copy got: %d want: %d\", m, want)\n+\t}\n+\tif err != nil {\n+\t\tt.Errorf(\"error from copy: %s\", err)\n+\t}\n+\n+\tcopyBytes := copyBuf.Bytes()\n+\tfor i := 0; i < want; i++ {\n+\t\tif copyBytes[i] != uint8(i) {\n+\t\t\tt.Errorf(\"bad pattern in copy at %d\", i)\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}"}, {"sha": "6f8133d981ad00d9f896344059bc2ef2644531f4", "filename": "libgo/go/crypto/openpgp/packet/private_key.go", "status": "modified", "additions": 107, "deletions": 1, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"bytes\"\n \t\"crypto/cipher\"\n \t\"crypto/dsa\"\n+\t\"crypto/openpgp/elgamal\"\n \t\"crypto/openpgp/error\"\n \t\"crypto/openpgp/s2k\"\n \t\"crypto/rsa\"\n@@ -32,6 +33,13 @@ type PrivateKey struct {\n \tiv            []byte\n }\n \n+func NewRSAPrivateKey(currentTimeSecs uint32, priv *rsa.PrivateKey, isSubkey bool) *PrivateKey {\n+\tpk := new(PrivateKey)\n+\tpk.PublicKey = *NewRSAPublicKey(currentTimeSecs, &priv.PublicKey, isSubkey)\n+\tpk.PrivateKey = priv\n+\treturn pk\n+}\n+\n func (pk *PrivateKey) parse(r io.Reader) (err os.Error) {\n \terr = (&pk.PublicKey).parse(r)\n \tif err != nil {\n@@ -91,13 +99,90 @@ func (pk *PrivateKey) parse(r io.Reader) (err os.Error) {\n \treturn\n }\n \n+func mod64kHash(d []byte) uint16 {\n+\th := uint16(0)\n+\tfor i := 0; i < len(d); i += 2 {\n+\t\tv := uint16(d[i]) << 8\n+\t\tif i+1 < len(d) {\n+\t\t\tv += uint16(d[i+1])\n+\t\t}\n+\t\th += v\n+\t}\n+\treturn h\n+}\n+\n+func (pk *PrivateKey) Serialize(w io.Writer) (err os.Error) {\n+\t// TODO(agl): support encrypted private keys\n+\tbuf := bytes.NewBuffer(nil)\n+\terr = pk.PublicKey.serializeWithoutHeaders(buf)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tbuf.WriteByte(0 /* no encryption */ )\n+\n+\tprivateKeyBuf := bytes.NewBuffer(nil)\n+\n+\tswitch priv := pk.PrivateKey.(type) {\n+\tcase *rsa.PrivateKey:\n+\t\terr = serializeRSAPrivateKey(privateKeyBuf, priv)\n+\tdefault:\n+\t\terr = error.InvalidArgumentError(\"non-RSA private key\")\n+\t}\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tptype := packetTypePrivateKey\n+\tcontents := buf.Bytes()\n+\tprivateKeyBytes := privateKeyBuf.Bytes()\n+\tif pk.IsSubkey {\n+\t\tptype = packetTypePrivateSubkey\n+\t}\n+\terr = serializeHeader(w, ptype, len(contents)+len(privateKeyBytes)+2)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, err = w.Write(contents)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, err = w.Write(privateKeyBytes)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tchecksum := mod64kHash(privateKeyBytes)\n+\tvar checksumBytes [2]byte\n+\tchecksumBytes[0] = byte(checksum >> 8)\n+\tchecksumBytes[1] = byte(checksum)\n+\t_, err = w.Write(checksumBytes[:])\n+\n+\treturn\n+}\n+\n+func serializeRSAPrivateKey(w io.Writer, priv *rsa.PrivateKey) os.Error {\n+\terr := writeBig(w, priv.D)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\terr = writeBig(w, priv.Primes[1])\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\terr = writeBig(w, priv.Primes[0])\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn writeBig(w, priv.Precomputed.Qinv)\n+}\n+\n // Decrypt decrypts an encrypted private key using a passphrase.\n func (pk *PrivateKey) Decrypt(passphrase []byte) os.Error {\n \tif !pk.Encrypted {\n \t\treturn nil\n \t}\n \n-\tkey := make([]byte, pk.cipher.keySize())\n+\tkey := make([]byte, pk.cipher.KeySize())\n \tpk.s2k(key, passphrase)\n \tblock := pk.cipher.new(key)\n \tcfb := cipher.NewCFBDecrypter(block, pk.iv)\n@@ -140,6 +225,8 @@ func (pk *PrivateKey) parsePrivateKey(data []byte) (err os.Error) {\n \t\treturn pk.parseRSAPrivateKey(data)\n \tcase PubKeyAlgoDSA:\n \t\treturn pk.parseDSAPrivateKey(data)\n+\tcase PubKeyAlgoElGamal:\n+\t\treturn pk.parseElGamalPrivateKey(data)\n \t}\n \tpanic(\"impossible\")\n }\n@@ -193,3 +280,22 @@ func (pk *PrivateKey) parseDSAPrivateKey(data []byte) (err os.Error) {\n \n \treturn nil\n }\n+\n+func (pk *PrivateKey) parseElGamalPrivateKey(data []byte) (err os.Error) {\n+\tpub := pk.PublicKey.PublicKey.(*elgamal.PublicKey)\n+\tpriv := new(elgamal.PrivateKey)\n+\tpriv.PublicKey = *pub\n+\n+\tbuf := bytes.NewBuffer(data)\n+\tx, _, err := readMPI(buf)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tpriv.X = new(big.Int).SetBytes(x)\n+\tpk.PrivateKey = priv\n+\tpk.Encrypted = false\n+\tpk.encryptedData = nil\n+\n+\treturn nil\n+}"}, {"sha": "60eebaa6b094dd3125e05fe701c342f24c115bb0", "filename": "libgo/go/crypto/openpgp/packet/private_key_test.go", "status": "modified", "additions": 42, "deletions": 22, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -8,30 +8,50 @@ import (\n \t\"testing\"\n )\n \n-func TestPrivateKeyRead(t *testing.T) {\n-\tpacket, err := Read(readerFromHex(privKeyHex))\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\n-\tprivKey := packet.(*PrivateKey)\n-\n-\tif !privKey.Encrypted {\n-\t\tt.Error(\"private key isn't encrypted\")\n-\t\treturn\n-\t}\n-\n-\terr = privKey.Decrypt([]byte(\"testing\"))\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n+var privateKeyTests = []struct {\n+\tprivateKeyHex string\n+\tcreationTime  uint32\n+}{\n+\t{\n+\t\tprivKeyRSAHex,\n+\t\t0x4cc349a8,\n+\t},\n+\t{\n+\t\tprivKeyElGamalHex,\n+\t\t0x4df9ee1a,\n+\t},\n+}\n \n-\tif privKey.CreationTime != 0x4cc349a8 || privKey.Encrypted {\n-\t\tt.Errorf(\"failed to parse, got: %#v\", privKey)\n+func TestPrivateKeyRead(t *testing.T) {\n+\tfor i, test := range privateKeyTests {\n+\t\tpacket, err := Read(readerFromHex(test.privateKeyHex))\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: failed to parse: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tprivKey := packet.(*PrivateKey)\n+\n+\t\tif !privKey.Encrypted {\n+\t\t\tt.Errorf(\"#%d: private key isn't encrypted\", i)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = privKey.Decrypt([]byte(\"testing\"))\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: failed to decrypt: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif privKey.CreationTime != test.creationTime || privKey.Encrypted {\n+\t\t\tt.Errorf(\"#%d: bad result, got: %#v\", i, privKey)\n+\t\t}\n \t}\n }\n \n // Generated with `gpg --export-secret-keys \"Test Key 2\"`\n-const privKeyHex = \"9501fe044cc349a8010400b70ca0010e98c090008d45d1ee8f9113bd5861fd57b88bacb7c68658747663f1e1a3b5a98f32fda6472373c024b97359cd2efc88ff60f77751adfbf6af5e615e6a1408cfad8bf0cea30b0d5f53aa27ad59089ba9b15b7ebc2777a25d7b436144027e3bcd203909f147d0e332b240cf63d3395f5dfe0df0a6c04e8655af7eacdf0011010001fe0303024a252e7d475fd445607de39a265472aa74a9320ba2dac395faa687e9e0336aeb7e9a7397e511b5afd9dc84557c80ac0f3d4d7bfec5ae16f20d41c8c84a04552a33870b930420e230e179564f6d19bb153145e76c33ae993886c388832b0fa042ddda7f133924f3854481533e0ede31d51278c0519b29abc3bf53da673e13e3e1214b52413d179d7f66deee35cac8eacb060f78379d70ef4af8607e68131ff529439668fc39c9ce6dfef8a5ac234d234802cbfb749a26107db26406213ae5c06d4673253a3cbee1fcbae58d6ab77e38d6e2c0e7c6317c48e054edadb5a40d0d48acb44643d998139a8a66bb820be1f3f80185bc777d14b5954b60effe2448a036d565c6bc0b915fcea518acdd20ab07bc1529f561c58cd044f723109b93f6fd99f876ff891d64306b5d08f48bab59f38695e9109c4dec34013ba3153488ce070268381ba923ee1eb77125b36afcb4347ec3478c8f2735b06ef17351d872e577fa95d0c397c88c71b59629a36aec\"\n+const privKeyRSAHex = \"9501fe044cc349a8010400b70ca0010e98c090008d45d1ee8f9113bd5861fd57b88bacb7c68658747663f1e1a3b5a98f32fda6472373c024b97359cd2efc88ff60f77751adfbf6af5e615e6a1408cfad8bf0cea30b0d5f53aa27ad59089ba9b15b7ebc2777a25d7b436144027e3bcd203909f147d0e332b240cf63d3395f5dfe0df0a6c04e8655af7eacdf0011010001fe0303024a252e7d475fd445607de39a265472aa74a9320ba2dac395faa687e9e0336aeb7e9a7397e511b5afd9dc84557c80ac0f3d4d7bfec5ae16f20d41c8c84a04552a33870b930420e230e179564f6d19bb153145e76c33ae993886c388832b0fa042ddda7f133924f3854481533e0ede31d51278c0519b29abc3bf53da673e13e3e1214b52413d179d7f66deee35cac8eacb060f78379d70ef4af8607e68131ff529439668fc39c9ce6dfef8a5ac234d234802cbfb749a26107db26406213ae5c06d4673253a3cbee1fcbae58d6ab77e38d6e2c0e7c6317c48e054edadb5a40d0d48acb44643d998139a8a66bb820be1f3f80185bc777d14b5954b60effe2448a036d565c6bc0b915fcea518acdd20ab07bc1529f561c58cd044f723109b93f6fd99f876ff891d64306b5d08f48bab59f38695e9109c4dec34013ba3153488ce070268381ba923ee1eb77125b36afcb4347ec3478c8f2735b06ef17351d872e577fa95d0c397c88c71b59629a36aec\"\n+\n+// Generated by `gpg --export-secret-keys` followed by a manual extraction of\n+// the ElGamal subkey from the packets.\n+const privKeyElGamalHex = \"9d0157044df9ee1a100400eb8e136a58ec39b582629cdadf830bc64e0a94ed8103ca8bb247b27b11b46d1d25297ef4bcc3071785ba0c0bedfe89eabc5287fcc0edf81ab5896c1c8e4b20d27d79813c7aede75320b33eaeeaa586edc00fd1036c10133e6ba0ff277245d0d59d04b2b3421b7244aca5f4a8d870c6f1c1fbff9e1c26699a860b9504f35ca1d700030503fd1ededd3b840795be6d9ccbe3c51ee42e2f39233c432b831ddd9c4e72b7025a819317e47bf94f9ee316d7273b05d5fcf2999c3a681f519b1234bbfa6d359b4752bd9c3f77d6b6456cde152464763414ca130f4e91d91041432f90620fec0e6d6b5116076c2985d5aeaae13be492b9b329efcaf7ee25120159a0a30cd976b42d7afe030302dae7eb80db744d4960c4df930d57e87fe81412eaace9f900e6c839817a614ddb75ba6603b9417c33ea7b6c93967dfa2bcff3fa3c74a5ce2c962db65b03aece14c96cbd0038fc\""}, {"sha": "e6b0ae5f3afc13b99284b07b5f6845656fef7747", "filename": "libgo/go/crypto/openpgp/packet/public_key.go", "status": "modified", "additions": 131, "deletions": 23, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -7,6 +7,7 @@ package packet\n import (\n \t\"big\"\n \t\"crypto/dsa\"\n+\t\"crypto/openpgp/elgamal\"\n \t\"crypto/openpgp/error\"\n \t\"crypto/rsa\"\n \t\"crypto/sha1\"\n@@ -30,6 +31,28 @@ type PublicKey struct {\n \tn, e, p, q, g, y parsedMPI\n }\n \n+func fromBig(n *big.Int) parsedMPI {\n+\treturn parsedMPI{\n+\t\tbytes:     n.Bytes(),\n+\t\tbitLength: uint16(n.BitLen()),\n+\t}\n+}\n+\n+// NewRSAPublicKey returns a PublicKey that wraps the given rsa.PublicKey.\n+func NewRSAPublicKey(creationTimeSecs uint32, pub *rsa.PublicKey, isSubkey bool) *PublicKey {\n+\tpk := &PublicKey{\n+\t\tCreationTime: creationTimeSecs,\n+\t\tPubKeyAlgo:   PubKeyAlgoRSA,\n+\t\tPublicKey:    pub,\n+\t\tIsSubkey:     isSubkey,\n+\t\tn:            fromBig(pub.N),\n+\t\te:            fromBig(big.NewInt(int64(pub.E))),\n+\t}\n+\n+\tpk.setFingerPrintAndKeyId()\n+\treturn pk\n+}\n+\n func (pk *PublicKey) parse(r io.Reader) (err os.Error) {\n \t// RFC 4880, section 5.5.2\n \tvar buf [6]byte\n@@ -47,21 +70,26 @@ func (pk *PublicKey) parse(r io.Reader) (err os.Error) {\n \t\terr = pk.parseRSA(r)\n \tcase PubKeyAlgoDSA:\n \t\terr = pk.parseDSA(r)\n+\tcase PubKeyAlgoElGamal:\n+\t\terr = pk.parseElGamal(r)\n \tdefault:\n \t\terr = error.UnsupportedError(\"public key type: \" + strconv.Itoa(int(pk.PubKeyAlgo)))\n \t}\n \tif err != nil {\n \t\treturn\n \t}\n \n+\tpk.setFingerPrintAndKeyId()\n+\treturn\n+}\n+\n+func (pk *PublicKey) setFingerPrintAndKeyId() {\n \t// RFC 4880, section 12.2\n \tfingerPrint := sha1.New()\n \tpk.SerializeSignaturePrefix(fingerPrint)\n-\tpk.Serialize(fingerPrint)\n+\tpk.serializeWithoutHeaders(fingerPrint)\n \tcopy(pk.Fingerprint[:], fingerPrint.Sum())\n \tpk.KeyId = binary.BigEndian.Uint64(pk.Fingerprint[12:20])\n-\n-\treturn\n }\n \n // parseRSA parses RSA public key material from the given Reader. See RFC 4880,\n@@ -92,7 +120,7 @@ func (pk *PublicKey) parseRSA(r io.Reader) (err os.Error) {\n \treturn\n }\n \n-// parseRSA parses DSA public key material from the given Reader. See RFC 4880,\n+// parseDSA parses DSA public key material from the given Reader. See RFC 4880,\n // section 5.5.2.\n func (pk *PublicKey) parseDSA(r io.Reader) (err os.Error) {\n \tpk.p.bytes, pk.p.bitLength, err = readMPI(r)\n@@ -121,6 +149,30 @@ func (pk *PublicKey) parseDSA(r io.Reader) (err os.Error) {\n \treturn\n }\n \n+// parseElGamal parses ElGamal public key material from the given Reader. See\n+// RFC 4880, section 5.5.2.\n+func (pk *PublicKey) parseElGamal(r io.Reader) (err os.Error) {\n+\tpk.p.bytes, pk.p.bitLength, err = readMPI(r)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tpk.g.bytes, pk.g.bitLength, err = readMPI(r)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tpk.y.bytes, pk.y.bitLength, err = readMPI(r)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\telgamal := new(elgamal.PublicKey)\n+\telgamal.P = new(big.Int).SetBytes(pk.p.bytes)\n+\telgamal.G = new(big.Int).SetBytes(pk.g.bytes)\n+\telgamal.Y = new(big.Int).SetBytes(pk.y.bytes)\n+\tpk.PublicKey = elgamal\n+\treturn\n+}\n+\n // SerializeSignaturePrefix writes the prefix for this public key to the given Writer.\n // The prefix is used when calculating a signature over this public key. See\n // RFC 4880, section 5.2.4.\n@@ -135,6 +187,10 @@ func (pk *PublicKey) SerializeSignaturePrefix(h hash.Hash) {\n \t\tpLength += 2 + uint16(len(pk.q.bytes))\n \t\tpLength += 2 + uint16(len(pk.g.bytes))\n \t\tpLength += 2 + uint16(len(pk.y.bytes))\n+\tcase PubKeyAlgoElGamal:\n+\t\tpLength += 2 + uint16(len(pk.p.bytes))\n+\t\tpLength += 2 + uint16(len(pk.g.bytes))\n+\t\tpLength += 2 + uint16(len(pk.y.bytes))\n \tdefault:\n \t\tpanic(\"unknown public key algorithm\")\n \t}\n@@ -143,9 +199,40 @@ func (pk *PublicKey) SerializeSignaturePrefix(h hash.Hash) {\n \treturn\n }\n \n-// Serialize marshals the PublicKey to w in the form of an OpenPGP public key\n-// packet, not including the packet header.\n func (pk *PublicKey) Serialize(w io.Writer) (err os.Error) {\n+\tlength := 6 // 6 byte header\n+\n+\tswitch pk.PubKeyAlgo {\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:\n+\t\tlength += 2 + len(pk.n.bytes)\n+\t\tlength += 2 + len(pk.e.bytes)\n+\tcase PubKeyAlgoDSA:\n+\t\tlength += 2 + len(pk.p.bytes)\n+\t\tlength += 2 + len(pk.q.bytes)\n+\t\tlength += 2 + len(pk.g.bytes)\n+\t\tlength += 2 + len(pk.y.bytes)\n+\tcase PubKeyAlgoElGamal:\n+\t\tlength += 2 + len(pk.p.bytes)\n+\t\tlength += 2 + len(pk.g.bytes)\n+\t\tlength += 2 + len(pk.y.bytes)\n+\tdefault:\n+\t\tpanic(\"unknown public key algorithm\")\n+\t}\n+\n+\tpacketType := packetTypePublicKey\n+\tif pk.IsSubkey {\n+\t\tpacketType = packetTypePublicSubkey\n+\t}\n+\terr = serializeHeader(w, packetType, length)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\treturn pk.serializeWithoutHeaders(w)\n+}\n+\n+// serializeWithoutHeaders marshals the PublicKey to w in the form of an\n+// OpenPGP public key packet, not including the packet header.\n+func (pk *PublicKey) serializeWithoutHeaders(w io.Writer) (err os.Error) {\n \tvar buf [6]byte\n \tbuf[0] = 4\n \tbuf[1] = byte(pk.CreationTime >> 24)\n@@ -164,13 +251,15 @@ func (pk *PublicKey) Serialize(w io.Writer) (err os.Error) {\n \t\treturn writeMPIs(w, pk.n, pk.e)\n \tcase PubKeyAlgoDSA:\n \t\treturn writeMPIs(w, pk.p, pk.q, pk.g, pk.y)\n+\tcase PubKeyAlgoElGamal:\n+\t\treturn writeMPIs(w, pk.p, pk.g, pk.y)\n \t}\n \treturn error.InvalidArgumentError(\"bad public-key algorithm\")\n }\n \n // CanSign returns true iff this public key can generate signatures\n func (pk *PublicKey) CanSign() bool {\n-\treturn pk.PubKeyAlgo != PubKeyAlgoRSAEncryptOnly && pk.PubKeyAlgo != PubKeyAlgoElgamal\n+\treturn pk.PubKeyAlgo != PubKeyAlgoRSAEncryptOnly && pk.PubKeyAlgo != PubKeyAlgoElGamal\n }\n \n // VerifySignature returns nil iff sig is a valid signature, made by this\n@@ -194,14 +283,14 @@ func (pk *PublicKey) VerifySignature(signed hash.Hash, sig *Signature) (err os.E\n \tswitch pk.PubKeyAlgo {\n \tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n \t\trsaPublicKey, _ := pk.PublicKey.(*rsa.PublicKey)\n-\t\terr = rsa.VerifyPKCS1v15(rsaPublicKey, sig.Hash, hashBytes, sig.RSASignature)\n+\t\terr = rsa.VerifyPKCS1v15(rsaPublicKey, sig.Hash, hashBytes, sig.RSASignature.bytes)\n \t\tif err != nil {\n \t\t\treturn error.SignatureError(\"RSA verification failure\")\n \t\t}\n \t\treturn nil\n \tcase PubKeyAlgoDSA:\n \t\tdsaPublicKey, _ := pk.PublicKey.(*dsa.PublicKey)\n-\t\tif !dsa.Verify(dsaPublicKey, hashBytes, sig.DSASigR, sig.DSASigS) {\n+\t\tif !dsa.Verify(dsaPublicKey, hashBytes, new(big.Int).SetBytes(sig.DSASigR.bytes), new(big.Int).SetBytes(sig.DSASigS.bytes)) {\n \t\t\treturn error.SignatureError(\"DSA verification failure\")\n \t\t}\n \t\treturn nil\n@@ -211,34 +300,43 @@ func (pk *PublicKey) VerifySignature(signed hash.Hash, sig *Signature) (err os.E\n \tpanic(\"unreachable\")\n }\n \n-// VerifyKeySignature returns nil iff sig is a valid signature, make by this\n-// public key, of the public key in signed.\n-func (pk *PublicKey) VerifyKeySignature(signed *PublicKey, sig *Signature) (err os.Error) {\n-\th := sig.Hash.New()\n+// keySignatureHash returns a Hash of the message that needs to be signed for\n+// pk to assert a subkey relationship to signed.\n+func keySignatureHash(pk, signed *PublicKey, sig *Signature) (h hash.Hash, err os.Error) {\n+\th = sig.Hash.New()\n \tif h == nil {\n-\t\treturn error.UnsupportedError(\"hash function\")\n+\t\treturn nil, error.UnsupportedError(\"hash function\")\n \t}\n \n \t// RFC 4880, section 5.2.4\n \tpk.SerializeSignaturePrefix(h)\n-\tpk.Serialize(h)\n+\tpk.serializeWithoutHeaders(h)\n \tsigned.SerializeSignaturePrefix(h)\n-\tsigned.Serialize(h)\n+\tsigned.serializeWithoutHeaders(h)\n+\treturn\n+}\n \n+// VerifyKeySignature returns nil iff sig is a valid signature, made by this\n+// public key, of signed.\n+func (pk *PublicKey) VerifyKeySignature(signed *PublicKey, sig *Signature) (err os.Error) {\n+\th, err := keySignatureHash(pk, signed, sig)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \treturn pk.VerifySignature(h, sig)\n }\n \n-// VerifyUserIdSignature returns nil iff sig is a valid signature, make by this\n-// public key, of the given user id.\n-func (pk *PublicKey) VerifyUserIdSignature(id string, sig *Signature) (err os.Error) {\n-\th := sig.Hash.New()\n+// userIdSignatureHash returns a Hash of the message that needs to be signed\n+// to assert that pk is a valid key for id.\n+func userIdSignatureHash(id string, pk *PublicKey, sig *Signature) (h hash.Hash, err os.Error) {\n+\th = sig.Hash.New()\n \tif h == nil {\n-\t\treturn error.UnsupportedError(\"hash function\")\n+\t\treturn nil, error.UnsupportedError(\"hash function\")\n \t}\n \n \t// RFC 4880, section 5.2.4\n \tpk.SerializeSignaturePrefix(h)\n-\tpk.Serialize(h)\n+\tpk.serializeWithoutHeaders(h)\n \n \tvar buf [5]byte\n \tbuf[0] = 0xb4\n@@ -249,6 +347,16 @@ func (pk *PublicKey) VerifyUserIdSignature(id string, sig *Signature) (err os.Er\n \th.Write(buf[:])\n \th.Write([]byte(id))\n \n+\treturn\n+}\n+\n+// VerifyUserIdSignature returns nil iff sig is a valid signature, made by this\n+// public key, of id.\n+func (pk *PublicKey) VerifyUserIdSignature(id string, sig *Signature) (err os.Error) {\n+\th, err := userIdSignatureHash(id, pk, sig)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \treturn pk.VerifySignature(h, sig)\n }\n \n@@ -272,7 +380,7 @@ type parsedMPI struct {\n \tbitLength uint16\n }\n \n-// writeMPIs is a utility function for serialising several big integers to the\n+// writeMPIs is a utility function for serializing several big integers to the\n // given Writer.\n func writeMPIs(w io.Writer, mpis ...parsedMPI) (err os.Error) {\n \tfor _, mpi := range mpis {"}, {"sha": "6e8bfbce66e732dbc109e71a8e3c1738d89e82e0", "filename": "libgo/go/crypto/openpgp/packet/public_key_test.go", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -28,12 +28,12 @@ func TestPublicKeyRead(t *testing.T) {\n \t\tpacket, err := Read(readerFromHex(test.hexData))\n \t\tif err != nil {\n \t\t\tt.Errorf(\"#%d: Read error: %s\", i, err)\n-\t\t\treturn\n+\t\t\tcontinue\n \t\t}\n \t\tpk, ok := packet.(*PublicKey)\n \t\tif !ok {\n \t\t\tt.Errorf(\"#%d: failed to parse, got: %#v\", i, packet)\n-\t\t\treturn\n+\t\t\tcontinue\n \t\t}\n \t\tif pk.PubKeyAlgo != test.pubKeyAlgo {\n \t\t\tt.Errorf(\"#%d: bad public key algorithm got:%x want:%x\", i, pk.PubKeyAlgo, test.pubKeyAlgo)\n@@ -57,6 +57,38 @@ func TestPublicKeyRead(t *testing.T) {\n \t}\n }\n \n+func TestPublicKeySerialize(t *testing.T) {\n+\tfor i, test := range pubKeyTests {\n+\t\tpacket, err := Read(readerFromHex(test.hexData))\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: Read error: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tpk, ok := packet.(*PublicKey)\n+\t\tif !ok {\n+\t\t\tt.Errorf(\"#%d: failed to parse, got: %#v\", i, packet)\n+\t\t\tcontinue\n+\t\t}\n+\t\tserializeBuf := bytes.NewBuffer(nil)\n+\t\terr = pk.Serialize(serializeBuf)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: failed to serialize: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tpacket, err = Read(serializeBuf)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: Read error (from serialized data): %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tpk, ok = packet.(*PublicKey)\n+\t\tif !ok {\n+\t\t\tt.Errorf(\"#%d: failed to parse serialized data, got: %#v\", i, packet)\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+}\n+\n const rsaFingerprintHex = \"5fb74b1d03b1e3cb31bc2f8aa34d7e18c20c31bb\"\n \n const rsaPkDataHex = \"988d044d3c5c10010400b1d13382944bd5aba23a4312968b5095d14f947f600eb478e14a6fcb16b0e0cac764884909c020bc495cfcc39a935387c661507bdb236a0612fb582cac3af9b29cc2c8c70090616c41b662f4da4c1201e195472eb7f4ae1ccbcbf9940fe21d985e379a5563dde5b9a23d35f1cfaa5790da3b79db26f23695107bfaca8e7b5bcd0011010001\""}, {"sha": "7577e28758810826b651e1ac7cb2a0859e5b3756", "filename": "libgo/go/crypto/openpgp/packet/signature.go", "status": "modified", "additions": 69, "deletions": 41, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -5,7 +5,6 @@\n package packet\n \n import (\n-\t\"big\"\n \t\"crypto\"\n \t\"crypto/dsa\"\n \t\"crypto/openpgp/error\"\n@@ -32,8 +31,11 @@ type Signature struct {\n \tHashTag      [2]byte\n \tCreationTime uint32 // Unix epoch time\n \n-\tRSASignature     []byte\n-\tDSASigR, DSASigS *big.Int\n+\tRSASignature     parsedMPI\n+\tDSASigR, DSASigS parsedMPI\n+\n+\t// rawSubpackets contains the unparsed subpackets, in order.\n+\trawSubpackets []outputSubpacket\n \n \t// The following are optional so are nil when not included in the\n \t// signature.\n@@ -128,14 +130,11 @@ func (sig *Signature) parse(r io.Reader) (err os.Error) {\n \n \tswitch sig.PubKeyAlgo {\n \tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n-\t\tsig.RSASignature, _, err = readMPI(r)\n+\t\tsig.RSASignature.bytes, sig.RSASignature.bitLength, err = readMPI(r)\n \tcase PubKeyAlgoDSA:\n-\t\tvar rBytes, sBytes []byte\n-\t\trBytes, _, err = readMPI(r)\n-\t\tsig.DSASigR = new(big.Int).SetBytes(rBytes)\n+\t\tsig.DSASigR.bytes, sig.DSASigR.bitLength, err = readMPI(r)\n \t\tif err == nil {\n-\t\t\tsBytes, _, err = readMPI(r)\n-\t\t\tsig.DSASigS = new(big.Int).SetBytes(sBytes)\n+\t\t\tsig.DSASigS.bytes, sig.DSASigS.bitLength, err = readMPI(r)\n \t\t}\n \tdefault:\n \t\tpanic(\"unreachable\")\n@@ -177,7 +176,11 @@ const (\n // parseSignatureSubpacket parses a single subpacket. len(subpacket) is >= 1.\n func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (rest []byte, err os.Error) {\n \t// RFC 4880, section 5.2.3.1\n-\tvar length uint32\n+\tvar (\n+\t\tlength     uint32\n+\t\tpacketType signatureSubpacketType\n+\t\tisCritical bool\n+\t)\n \tswitch {\n \tcase subpacket[0] < 192:\n \t\tlength = uint32(subpacket[0])\n@@ -207,10 +210,11 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \t\terr = error.StructuralError(\"zero length signature subpacket\")\n \t\treturn\n \t}\n-\tpacketType := subpacket[0] & 0x7f\n-\tisCritial := subpacket[0]&0x80 == 0x80\n+\tpacketType = signatureSubpacketType(subpacket[0] & 0x7f)\n+\tisCritical = subpacket[0]&0x80 == 0x80\n \tsubpacket = subpacket[1:]\n-\tswitch signatureSubpacketType(packetType) {\n+\tsig.rawSubpackets = append(sig.rawSubpackets, outputSubpacket{isHashed, packetType, isCritical, subpacket})\n+\tswitch packetType {\n \tcase creationTimeSubpacket:\n \t\tif !isHashed {\n \t\t\terr = error.StructuralError(\"signature creation time in non-hashed area\")\n@@ -309,7 +313,7 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \t\t}\n \n \tdefault:\n-\t\tif isCritial {\n+\t\tif isCritical {\n \t\t\terr = error.UnsupportedError(\"unknown critical signature subpacket type \" + strconv.Itoa(int(packetType)))\n \t\t\treturn\n \t\t}\n@@ -381,7 +385,6 @@ func serializeSubpackets(to []byte, subpackets []outputSubpacket, hashed bool) {\n \n // buildHashSuffix constructs the HashSuffix member of sig in preparation for signing.\n func (sig *Signature) buildHashSuffix() (err os.Error) {\n-\tsig.outSubpackets = sig.buildSubpackets()\n \thashedSubpacketsLen := subpacketsLength(sig.outSubpackets, true)\n \n \tvar ok bool\n@@ -393,7 +396,7 @@ func (sig *Signature) buildHashSuffix() (err os.Error) {\n \tsig.HashSuffix[3], ok = s2k.HashToHashId(sig.Hash)\n \tif !ok {\n \t\tsig.HashSuffix = nil\n-\t\treturn error.InvalidArgumentError(\"hash cannot be repesented in OpenPGP: \" + strconv.Itoa(int(sig.Hash)))\n+\t\treturn error.InvalidArgumentError(\"hash cannot be represented in OpenPGP: \" + strconv.Itoa(int(sig.Hash)))\n \t}\n \tsig.HashSuffix[4] = byte(hashedSubpacketsLen >> 8)\n \tsig.HashSuffix[5] = byte(hashedSubpacketsLen)\n@@ -420,53 +423,80 @@ func (sig *Signature) signPrepareHash(h hash.Hash) (digest []byte, err os.Error)\n \treturn\n }\n \n-// SignRSA signs a message with an RSA private key. The hash, h, must contain\n+// Sign signs a message with a private key. The hash, h, must contain\n // the hash of the message to be signed and will be mutated by this function.\n // On success, the signature is stored in sig. Call Serialize to write it out.\n-func (sig *Signature) SignRSA(h hash.Hash, priv *rsa.PrivateKey) (err os.Error) {\n+func (sig *Signature) Sign(h hash.Hash, priv *PrivateKey) (err os.Error) {\n+\tsig.outSubpackets = sig.buildSubpackets()\n \tdigest, err := sig.signPrepareHash(h)\n \tif err != nil {\n \t\treturn\n \t}\n-\tsig.RSASignature, err = rsa.SignPKCS1v15(rand.Reader, priv, sig.Hash, digest)\n+\n+\tswitch priv.PubKeyAlgo {\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n+\t\tsig.RSASignature.bytes, err = rsa.SignPKCS1v15(rand.Reader, priv.PrivateKey.(*rsa.PrivateKey), sig.Hash, digest)\n+\t\tsig.RSASignature.bitLength = uint16(8 * len(sig.RSASignature.bytes))\n+\tcase PubKeyAlgoDSA:\n+\t\tr, s, err := dsa.Sign(rand.Reader, priv.PrivateKey.(*dsa.PrivateKey), digest)\n+\t\tif err == nil {\n+\t\t\tsig.DSASigR.bytes = r.Bytes()\n+\t\t\tsig.DSASigR.bitLength = uint16(8 * len(sig.DSASigR.bytes))\n+\t\t\tsig.DSASigS.bytes = s.Bytes()\n+\t\t\tsig.DSASigS.bitLength = uint16(8 * len(sig.DSASigS.bytes))\n+\t\t}\n+\tdefault:\n+\t\terr = error.UnsupportedError(\"public key algorithm: \" + strconv.Itoa(int(sig.PubKeyAlgo)))\n+\t}\n+\n \treturn\n }\n \n-// SignDSA signs a message with a DSA private key. The hash, h, must contain\n-// the hash of the message to be signed and will be mutated by this function.\n-// On success, the signature is stored in sig. Call Serialize to write it out.\n-func (sig *Signature) SignDSA(h hash.Hash, priv *dsa.PrivateKey) (err os.Error) {\n-\tdigest, err := sig.signPrepareHash(h)\n+// SignUserId computes a signature from priv, asserting that pub is a valid\n+// key for the identity id.  On success, the signature is stored in sig. Call\n+// Serialize to write it out.\n+func (sig *Signature) SignUserId(id string, pub *PublicKey, priv *PrivateKey) os.Error {\n+\th, err := userIdSignatureHash(id, pub, sig)\n \tif err != nil {\n-\t\treturn\n+\t\treturn nil\n \t}\n-\tsig.DSASigR, sig.DSASigS, err = dsa.Sign(rand.Reader, priv, digest)\n-\treturn\n+\treturn sig.Sign(h, priv)\n+}\n+\n+// SignKey computes a signature from priv, asserting that pub is a subkey.  On\n+// success, the signature is stored in sig. Call Serialize to write it out.\n+func (sig *Signature) SignKey(pub *PublicKey, priv *PrivateKey) os.Error {\n+\th, err := keySignatureHash(&priv.PublicKey, pub, sig)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn sig.Sign(h, priv)\n }\n \n // Serialize marshals sig to w. SignRSA or SignDSA must have been called first.\n func (sig *Signature) Serialize(w io.Writer) (err os.Error) {\n-\tif sig.RSASignature == nil && sig.DSASigR == nil {\n+\tif len(sig.outSubpackets) == 0 {\n+\t\tsig.outSubpackets = sig.rawSubpackets\n+\t}\n+\tif sig.RSASignature.bytes == nil && sig.DSASigR.bytes == nil {\n \t\treturn error.InvalidArgumentError(\"Signature: need to call SignRSA or SignDSA before Serialize\")\n \t}\n \n \tsigLength := 0\n \tswitch sig.PubKeyAlgo {\n \tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n-\t\tsigLength = len(sig.RSASignature)\n+\t\tsigLength = 2 + len(sig.RSASignature.bytes)\n \tcase PubKeyAlgoDSA:\n-\t\tsigLength = 2 /* MPI length */\n-\t\tsigLength += (sig.DSASigR.BitLen() + 7) / 8\n-\t\tsigLength += 2 /* MPI length */\n-\t\tsigLength += (sig.DSASigS.BitLen() + 7) / 8\n+\t\tsigLength = 2 + len(sig.DSASigR.bytes)\n+\t\tsigLength += 2 + len(sig.DSASigS.bytes)\n \tdefault:\n \t\tpanic(\"impossible\")\n \t}\n \n \tunhashedSubpacketsLen := subpacketsLength(sig.outSubpackets, false)\n \tlength := len(sig.HashSuffix) - 6 /* trailer not included */ +\n \t\t2 /* length of unhashed subpackets */ + unhashedSubpacketsLen +\n-\t\t2 /* hash tag */ + 2 /* length of signature MPI */ + sigLength\n+\t\t2 /* hash tag */ + sigLength\n \terr = serializeHeader(w, packetTypeSignature, length)\n \tif err != nil {\n \t\treturn\n@@ -493,12 +523,9 @@ func (sig *Signature) Serialize(w io.Writer) (err os.Error) {\n \n \tswitch sig.PubKeyAlgo {\n \tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n-\t\terr = writeMPI(w, 8*uint16(len(sig.RSASignature)), sig.RSASignature)\n+\t\terr = writeMPIs(w, sig.RSASignature)\n \tcase PubKeyAlgoDSA:\n-\t\terr = writeBig(w, sig.DSASigR)\n-\t\tif err == nil {\n-\t\t\terr = writeBig(w, sig.DSASigS)\n-\t\t}\n+\t\terr = writeMPIs(w, sig.DSASigR, sig.DSASigS)\n \tdefault:\n \t\tpanic(\"impossible\")\n \t}\n@@ -509,6 +536,7 @@ func (sig *Signature) Serialize(w io.Writer) (err os.Error) {\n type outputSubpacket struct {\n \thashed        bool // true if this subpacket is in the hashed area.\n \tsubpacketType signatureSubpacketType\n+\tisCritical    bool\n \tcontents      []byte\n }\n \n@@ -518,12 +546,12 @@ func (sig *Signature) buildSubpackets() (subpackets []outputSubpacket) {\n \tcreationTime[1] = byte(sig.CreationTime >> 16)\n \tcreationTime[2] = byte(sig.CreationTime >> 8)\n \tcreationTime[3] = byte(sig.CreationTime)\n-\tsubpackets = append(subpackets, outputSubpacket{true, creationTimeSubpacket, creationTime})\n+\tsubpackets = append(subpackets, outputSubpacket{true, creationTimeSubpacket, false, creationTime})\n \n \tif sig.IssuerKeyId != nil {\n \t\tkeyId := make([]byte, 8)\n \t\tbinary.BigEndian.PutUint64(keyId, *sig.IssuerKeyId)\n-\t\tsubpackets = append(subpackets, outputSubpacket{true, issuerSubpacket, keyId})\n+\t\tsubpackets = append(subpackets, outputSubpacket{true, issuerSubpacket, false, keyId})\n \t}\n \n \treturn"}, {"sha": "c1bbde8b0c3b0933b5890af10037664ed576faad", "filename": "libgo/go/crypto/openpgp/packet/signature_test.go", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -12,9 +12,7 @@ import (\n )\n \n func TestSignatureRead(t *testing.T) {\n-\tsignatureData, _ := hex.DecodeString(signatureDataHex)\n-\tbuf := bytes.NewBuffer(signatureData)\n-\tpacket, err := Read(buf)\n+\tpacket, err := Read(readerFromHex(signatureDataHex))\n \tif err != nil {\n \t\tt.Error(err)\n \t\treturn\n@@ -25,4 +23,20 @@ func TestSignatureRead(t *testing.T) {\n \t}\n }\n \n-const signatureDataHex = \"89011c04000102000605024cb45112000a0910ab105c91af38fb158f8d07ff5596ea368c5efe015bed6e78348c0f033c931d5f2ce5db54ce7f2a7e4b4ad64db758d65a7a71773edeab7ba2a9e0908e6a94a1175edd86c1d843279f045b021a6971a72702fcbd650efc393c5474d5b59a15f96d2eaad4c4c426797e0dcca2803ef41c6ff234d403eec38f31d610c344c06f2401c262f0993b2e66cad8a81ebc4322c723e0d4ba09fe917e8777658307ad8329adacba821420741009dfe87f007759f0982275d028a392c6ed983a0d846f890b36148c7358bdb8a516007fac760261ecd06076813831a36d0459075d1befa245ae7f7fb103d92ca759e9498fe60ef8078a39a3beda510deea251ea9f0a7f0df6ef42060f20780360686f3e400e\"\n+func TestSignatureReserialize(t *testing.T) {\n+\tpacket, _ := Read(readerFromHex(signatureDataHex))\n+\tsig := packet.(*Signature)\n+\tout := new(bytes.Buffer)\n+\terr := sig.Serialize(out)\n+\tif err != nil {\n+\t\tt.Errorf(\"error reserializing: %s\", err)\n+\t\treturn\n+\t}\n+\n+\texpected, _ := hex.DecodeString(signatureDataHex)\n+\tif !bytes.Equal(expected, out.Bytes()) {\n+\t\tt.Errorf(\"output doesn't match input (got vs expected):\\n%s\\n%s\", hex.Dump(out.Bytes()), hex.Dump(expected))\n+\t}\n+}\n+\n+const signatureDataHex = \"c2c05c04000102000605024cb45112000a0910ab105c91af38fb158f8d07ff5596ea368c5efe015bed6e78348c0f033c931d5f2ce5db54ce7f2a7e4b4ad64db758d65a7a71773edeab7ba2a9e0908e6a94a1175edd86c1d843279f045b021a6971a72702fcbd650efc393c5474d5b59a15f96d2eaad4c4c426797e0dcca2803ef41c6ff234d403eec38f31d610c344c06f2401c262f0993b2e66cad8a81ebc4322c723e0d4ba09fe917e8777658307ad8329adacba821420741009dfe87f007759f0982275d028a392c6ed983a0d846f890b36148c7358bdb8a516007fac760261ecd06076813831a36d0459075d1befa245ae7f7fb103d92ca759e9498fe60ef8078a39a3beda510deea251ea9f0a7f0df6ef42060f20780360686f3e400e\""}, {"sha": "ad4f1d6212a0bb7158fedfc666deed05d95f7bad", "filename": "libgo/go/crypto/openpgp/packet/symmetric_key_encrypted.go", "status": "modified", "additions": 63, "deletions": 3, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -5,6 +5,7 @@\n package packet\n \n import (\n+\t\"bytes\"\n \t\"crypto/cipher\"\n \t\"crypto/openpgp/error\"\n \t\"crypto/openpgp/s2k\"\n@@ -27,19 +28,21 @@ type SymmetricKeyEncrypted struct {\n \tencryptedKey []byte\n }\n \n+const symmetricKeyEncryptedVersion = 4\n+\n func (ske *SymmetricKeyEncrypted) parse(r io.Reader) (err os.Error) {\n \t// RFC 4880, section 5.3.\n \tvar buf [2]byte\n \t_, err = readFull(r, buf[:])\n \tif err != nil {\n \t\treturn\n \t}\n-\tif buf[0] != 4 {\n+\tif buf[0] != symmetricKeyEncryptedVersion {\n \t\treturn error.UnsupportedError(\"SymmetricKeyEncrypted version\")\n \t}\n \tske.CipherFunc = CipherFunction(buf[1])\n \n-\tif ske.CipherFunc.keySize() == 0 {\n+\tif ske.CipherFunc.KeySize() == 0 {\n \t\treturn error.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(buf[1])))\n \t}\n \n@@ -75,7 +78,7 @@ func (ske *SymmetricKeyEncrypted) Decrypt(passphrase []byte) os.Error {\n \t\treturn nil\n \t}\n \n-\tkey := make([]byte, ske.CipherFunc.keySize())\n+\tkey := make([]byte, ske.CipherFunc.KeySize())\n \tske.s2k(key, passphrase)\n \n \tif len(ske.encryptedKey) == 0 {\n@@ -100,3 +103,60 @@ func (ske *SymmetricKeyEncrypted) Decrypt(passphrase []byte) os.Error {\n \tske.Encrypted = false\n \treturn nil\n }\n+\n+// SerializeSymmetricKeyEncrypted serializes a symmetric key packet to w. The\n+// packet contains a random session key, encrypted by a key derived from the\n+// given passphrase. The session key is returned and must be passed to\n+// SerializeSymmetricallyEncrypted.\n+func SerializeSymmetricKeyEncrypted(w io.Writer, rand io.Reader, passphrase []byte, cipherFunc CipherFunction) (key []byte, err os.Error) {\n+\tkeySize := cipherFunc.KeySize()\n+\tif keySize == 0 {\n+\t\treturn nil, error.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(cipherFunc)))\n+\t}\n+\n+\ts2kBuf := new(bytes.Buffer)\n+\tkeyEncryptingKey := make([]byte, keySize)\n+\t// s2k.Serialize salts and stretches the passphrase, and writes the\n+\t// resulting key to keyEncryptingKey and the s2k descriptor to s2kBuf.\n+\terr = s2k.Serialize(s2kBuf, keyEncryptingKey, rand, passphrase)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\ts2kBytes := s2kBuf.Bytes()\n+\n+\tpacketLength := 2 /* header */ + len(s2kBytes) + 1 /* cipher type */ + keySize\n+\terr = serializeHeader(w, packetTypeSymmetricKeyEncrypted, packetLength)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tvar buf [2]byte\n+\tbuf[0] = symmetricKeyEncryptedVersion\n+\tbuf[1] = byte(cipherFunc)\n+\t_, err = w.Write(buf[:])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, err = w.Write(s2kBytes)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tsessionKey := make([]byte, keySize)\n+\t_, err = io.ReadFull(rand, sessionKey)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tiv := make([]byte, cipherFunc.blockSize())\n+\tc := cipher.NewCFBEncrypter(cipherFunc.new(keyEncryptingKey), iv)\n+\tencryptedCipherAndKey := make([]byte, keySize+1)\n+\tc.XORKeyStream(encryptedCipherAndKey, buf[1:])\n+\tc.XORKeyStream(encryptedCipherAndKey[1:], sessionKey)\n+\t_, err = w.Write(encryptedCipherAndKey)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tkey = sessionKey\n+\treturn\n+}"}, {"sha": "823ec400d40aad45dd463d90b7d36a7c7d8e86ed", "filename": "libgo/go/crypto/openpgp/packet/symmetric_key_encrypted_test.go", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -6,6 +6,7 @@ package packet\n \n import (\n \t\"bytes\"\n+\t\"crypto/rand\"\n \t\"encoding/hex\"\n \t\"io/ioutil\"\n \t\"os\"\n@@ -60,3 +61,41 @@ func TestSymmetricKeyEncrypted(t *testing.T) {\n \n const symmetricallyEncryptedHex = \"8c0d04030302371a0b38d884f02060c91cf97c9973b8e58e028e9501708ccfe618fb92afef7fa2d80ddadd93cf\"\n const symmetricallyEncryptedContentsHex = \"cb1062004d14c4df636f6e74656e74732e0a\"\n+\n+func TestSerializeSymmetricKeyEncrypted(t *testing.T) {\n+\tbuf := bytes.NewBuffer(nil)\n+\tpassphrase := []byte(\"testing\")\n+\tcipherFunc := CipherAES128\n+\n+\tkey, err := SerializeSymmetricKeyEncrypted(buf, rand.Reader, passphrase, cipherFunc)\n+\tif err != nil {\n+\t\tt.Errorf(\"failed to serialize: %s\", err)\n+\t\treturn\n+\t}\n+\n+\tp, err := Read(buf)\n+\tif err != nil {\n+\t\tt.Errorf(\"failed to reparse: %s\", err)\n+\t\treturn\n+\t}\n+\tske, ok := p.(*SymmetricKeyEncrypted)\n+\tif !ok {\n+\t\tt.Errorf(\"parsed a different packet type: %#v\", p)\n+\t\treturn\n+\t}\n+\n+\tif !ske.Encrypted {\n+\t\tt.Errorf(\"SKE not encrypted but should be\")\n+\t}\n+\tif ske.CipherFunc != cipherFunc {\n+\t\tt.Errorf(\"SKE cipher function is %d (expected %d)\", ske.CipherFunc, cipherFunc)\n+\t}\n+\terr = ske.Decrypt(passphrase)\n+\tif err != nil {\n+\t\tt.Errorf(\"failed to decrypt reparsed SKE: %s\", err)\n+\t\treturn\n+\t}\n+\tif !bytes.Equal(key, ske.Key) {\n+\t\tt.Errorf(\"keys don't match after Decrpyt: %x (original) vs %x (parsed)\", key, ske.Key)\n+\t}\n+}"}, {"sha": "e33c9f3a060b4f0bfa8ba8860189e5eeb07df4e9", "filename": "libgo/go/crypto/openpgp/packet/symmetrically_encrypted.go", "status": "modified", "additions": 90, "deletions": 5, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -7,6 +7,7 @@ package packet\n import (\n \t\"crypto/cipher\"\n \t\"crypto/openpgp/error\"\n+\t\"crypto/rand\"\n \t\"crypto/sha1\"\n \t\"crypto/subtle\"\n \t\"hash\"\n@@ -24,6 +25,8 @@ type SymmetricallyEncrypted struct {\n \tprefix   []byte\n }\n \n+const symmetricallyEncryptedVersion = 1\n+\n func (se *SymmetricallyEncrypted) parse(r io.Reader) os.Error {\n \tif se.MDC {\n \t\t// See RFC 4880, section 5.13.\n@@ -32,7 +35,7 @@ func (se *SymmetricallyEncrypted) parse(r io.Reader) os.Error {\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif buf[0] != 1 {\n+\t\tif buf[0] != symmetricallyEncryptedVersion {\n \t\t\treturn error.UnsupportedError(\"unknown SymmetricallyEncrypted version\")\n \t\t}\n \t}\n@@ -44,7 +47,7 @@ func (se *SymmetricallyEncrypted) parse(r io.Reader) os.Error {\n // packet can be read. An incorrect key can, with high probability, be detected\n // immediately and this will result in a KeyIncorrect error being returned.\n func (se *SymmetricallyEncrypted) Decrypt(c CipherFunction, key []byte) (io.ReadCloser, os.Error) {\n-\tkeySize := c.keySize()\n+\tkeySize := c.KeySize()\n \tif keySize == 0 {\n \t\treturn nil, error.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(c)))\n \t}\n@@ -174,6 +177,9 @@ func (ser *seMDCReader) Read(buf []byte) (n int, err os.Error) {\n \treturn\n }\n \n+// This is a new-format packet tag byte for a type 19 (MDC) packet.\n+const mdcPacketTagByte = byte(0x80) | 0x40 | 19\n+\n func (ser *seMDCReader) Close() os.Error {\n \tif ser.error {\n \t\treturn error.SignatureError(\"error during reading\")\n@@ -191,16 +197,95 @@ func (ser *seMDCReader) Close() os.Error {\n \t\t}\n \t}\n \n-\t// This is a new-format packet tag byte for a type 19 (MDC) packet.\n-\tconst mdcPacketTagByte = byte(0x80) | 0x40 | 19\n \tif ser.trailer[0] != mdcPacketTagByte || ser.trailer[1] != sha1.Size {\n \t\treturn error.SignatureError(\"MDC packet not found\")\n \t}\n \tser.h.Write(ser.trailer[:2])\n \n \tfinal := ser.h.Sum()\n-\tif subtle.ConstantTimeCompare(final, ser.trailer[2:]) == 1 {\n+\tif subtle.ConstantTimeCompare(final, ser.trailer[2:]) != 1 {\n \t\treturn error.SignatureError(\"hash mismatch\")\n \t}\n \treturn nil\n }\n+\n+// An seMDCWriter writes through to an io.WriteCloser while maintains a running\n+// hash of the data written. On close, it emits an MDC packet containing the\n+// running hash.\n+type seMDCWriter struct {\n+\tw io.WriteCloser\n+\th hash.Hash\n+}\n+\n+func (w *seMDCWriter) Write(buf []byte) (n int, err os.Error) {\n+\tw.h.Write(buf)\n+\treturn w.w.Write(buf)\n+}\n+\n+func (w *seMDCWriter) Close() (err os.Error) {\n+\tvar buf [mdcTrailerSize]byte\n+\n+\tbuf[0] = mdcPacketTagByte\n+\tbuf[1] = sha1.Size\n+\tw.h.Write(buf[:2])\n+\tdigest := w.h.Sum()\n+\tcopy(buf[2:], digest)\n+\n+\t_, err = w.w.Write(buf[:])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\treturn w.w.Close()\n+}\n+\n+// noOpCloser is like an ioutil.NopCloser, but for an io.Writer.\n+type noOpCloser struct {\n+\tw io.Writer\n+}\n+\n+func (c noOpCloser) Write(data []byte) (n int, err os.Error) {\n+\treturn c.w.Write(data)\n+}\n+\n+func (c noOpCloser) Close() os.Error {\n+\treturn nil\n+}\n+\n+// SerializeSymmetricallyEncrypted serializes a symmetrically encrypted packet\n+// to w and returns a WriteCloser to which the to-be-encrypted packets can be\n+// written.\n+func SerializeSymmetricallyEncrypted(w io.Writer, c CipherFunction, key []byte) (contents io.WriteCloser, err os.Error) {\n+\tif c.KeySize() != len(key) {\n+\t\treturn nil, error.InvalidArgumentError(\"SymmetricallyEncrypted.Serialize: bad key length\")\n+\t}\n+\twriteCloser := noOpCloser{w}\n+\tciphertext, err := serializeStreamHeader(writeCloser, packetTypeSymmetricallyEncryptedMDC)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\t_, err = ciphertext.Write([]byte{symmetricallyEncryptedVersion})\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tblock := c.new(key)\n+\tblockSize := block.BlockSize()\n+\tiv := make([]byte, blockSize)\n+\t_, err = rand.Reader.Read(iv)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\ts, prefix := cipher.NewOCFBEncrypter(block, iv, cipher.OCFBNoResync)\n+\t_, err = ciphertext.Write(prefix)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tplaintext := cipher.StreamWriter{S: s, W: ciphertext}\n+\n+\th := sha1.New()\n+\th.Write(iv)\n+\th.Write(iv[blockSize-2:])\n+\tcontents = &seMDCWriter{w: plaintext, h: h}\n+\treturn\n+}"}, {"sha": "1054fc2f91a7a45e02af9c1c33f826faaba6c900", "filename": "libgo/go/crypto/openpgp/packet/symmetrically_encrypted_test.go", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"crypto/openpgp/error\"\n \t\"crypto/sha1\"\n \t\"encoding/hex\"\n+\t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"testing\"\n@@ -76,3 +77,48 @@ func testMDCReader(t *testing.T) {\n }\n \n const mdcPlaintextHex = \"a302789c3b2d93c4e0eb9aba22283539b3203335af44a134afb800c849cb4c4de10200aff40b45d31432c80cb384299a0655966d6939dfdeed1dddf980\"\n+\n+func TestSerialize(t *testing.T) {\n+\tbuf := bytes.NewBuffer(nil)\n+\tc := CipherAES128\n+\tkey := make([]byte, c.KeySize())\n+\n+\tw, err := SerializeSymmetricallyEncrypted(buf, c, key)\n+\tif err != nil {\n+\t\tt.Errorf(\"error from SerializeSymmetricallyEncrypted: %s\", err)\n+\t\treturn\n+\t}\n+\n+\tcontents := []byte(\"hello world\\n\")\n+\n+\tw.Write(contents)\n+\tw.Close()\n+\n+\tp, err := Read(buf)\n+\tif err != nil {\n+\t\tt.Errorf(\"error from Read: %s\", err)\n+\t\treturn\n+\t}\n+\n+\tse, ok := p.(*SymmetricallyEncrypted)\n+\tif !ok {\n+\t\tt.Errorf(\"didn't read a *SymmetricallyEncrypted\")\n+\t\treturn\n+\t}\n+\n+\tr, err := se.Decrypt(c, key)\n+\tif err != nil {\n+\t\tt.Errorf(\"error from Decrypt: %s\", err)\n+\t\treturn\n+\t}\n+\n+\tcontentsCopy := bytes.NewBuffer(nil)\n+\t_, err = io.Copy(contentsCopy, r)\n+\tif err != nil {\n+\t\tt.Errorf(\"error from io.Copy: %s\", err)\n+\t\treturn\n+\t}\n+\tif !bytes.Equal(contentsCopy.Bytes(), contents) {\n+\t\tt.Errorf(\"contents not equal got: %x want: %x\", contentsCopy.Bytes(), contents)\n+\t}\n+}"}, {"sha": "0580ba3edc04b364476eb0f7568be914669df41a", "filename": "libgo/go/crypto/openpgp/packet/userid.go", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -20,6 +20,51 @@ type UserId struct {\n \tName, Comment, Email string\n }\n \n+func hasInvalidCharacters(s string) bool {\n+\tfor _, c := range s {\n+\t\tswitch c {\n+\t\tcase '(', ')', '<', '>', 0:\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// NewUserId returns a UserId or nil if any of the arguments contain invalid\n+// characters. The invalid characters are '\\x00', '(', ')', '<' and '>'\n+func NewUserId(name, comment, email string) *UserId {\n+\t// RFC 4880 doesn't deal with the structure of userid strings; the\n+\t// name, comment and email form is just a convention. However, there's\n+\t// no convention about escaping the metacharacters and GPG just refuses\n+\t// to create user ids where, say, the name contains a '('. We mirror\n+\t// this behaviour.\n+\n+\tif hasInvalidCharacters(name) || hasInvalidCharacters(comment) || hasInvalidCharacters(email) {\n+\t\treturn nil\n+\t}\n+\n+\tuid := new(UserId)\n+\tuid.Name, uid.Comment, uid.Email = name, comment, email\n+\tuid.Id = name\n+\tif len(comment) > 0 {\n+\t\tif len(uid.Id) > 0 {\n+\t\t\tuid.Id += \" \"\n+\t\t}\n+\t\tuid.Id += \"(\"\n+\t\tuid.Id += comment\n+\t\tuid.Id += \")\"\n+\t}\n+\tif len(email) > 0 {\n+\t\tif len(uid.Id) > 0 {\n+\t\t\tuid.Id += \" \"\n+\t\t}\n+\t\tuid.Id += \"<\"\n+\t\tuid.Id += email\n+\t\tuid.Id += \">\"\n+\t}\n+\treturn uid\n+}\n+\n func (uid *UserId) parse(r io.Reader) (err os.Error) {\n \t// RFC 4880, section 5.11\n \tb, err := ioutil.ReadAll(r)\n@@ -31,6 +76,17 @@ func (uid *UserId) parse(r io.Reader) (err os.Error) {\n \treturn\n }\n \n+// Serialize marshals uid to w in the form of an OpenPGP packet, including\n+// header.\n+func (uid *UserId) Serialize(w io.Writer) os.Error {\n+\terr := serializeHeader(w, packetTypeUserId, len(uid.Id))\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\t_, err = w.Write([]byte(uid.Id))\n+\treturn err\n+}\n+\n // parseUserId extracts the name, comment and email from a user id string that\n // is formatted as \"Full Name (Comment) <email@example.com>\".\n func parseUserId(id string) (name, comment, email string) {"}, {"sha": "29681938938c687b9e6ef78b17761925042d8cad", "filename": "libgo/go/crypto/openpgp/packet/userid_test.go", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -40,3 +40,48 @@ func TestParseUserId(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+var newUserIdTests = []struct {\n+\tname, comment, email, id string\n+}{\n+\t{\"foo\", \"\", \"\", \"foo\"},\n+\t{\"\", \"bar\", \"\", \"(bar)\"},\n+\t{\"\", \"\", \"baz\", \"<baz>\"},\n+\t{\"foo\", \"bar\", \"\", \"foo (bar)\"},\n+\t{\"foo\", \"\", \"baz\", \"foo <baz>\"},\n+\t{\"\", \"bar\", \"baz\", \"(bar) <baz>\"},\n+\t{\"foo\", \"bar\", \"baz\", \"foo (bar) <baz>\"},\n+}\n+\n+func TestNewUserId(t *testing.T) {\n+\tfor i, test := range newUserIdTests {\n+\t\tuid := NewUserId(test.name, test.comment, test.email)\n+\t\tif uid == nil {\n+\t\t\tt.Errorf(\"#%d: returned nil\", i)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif uid.Id != test.id {\n+\t\t\tt.Errorf(\"#%d: got '%s', want '%s'\", i, uid.Id, test.id)\n+\t\t}\n+\t}\n+}\n+\n+var invalidNewUserIdTests = []struct {\n+\tname, comment, email string\n+}{\n+\t{\"foo(\", \"\", \"\"},\n+\t{\"foo<\", \"\", \"\"},\n+\t{\"\", \"bar)\", \"\"},\n+\t{\"\", \"bar<\", \"\"},\n+\t{\"\", \"\", \"baz>\"},\n+\t{\"\", \"\", \"baz)\"},\n+\t{\"\", \"\", \"baz\\x00\"},\n+}\n+\n+func TestNewUserIdWithInvalidInput(t *testing.T) {\n+\tfor i, test := range invalidNewUserIdTests {\n+\t\tif uid := NewUserId(test.name, test.comment, test.email); uid != nil {\n+\t\t\tt.Errorf(\"#%d: returned non-nil value: %#v\", i, uid)\n+\t\t}\n+\t}\n+}"}, {"sha": "d95f613c62b9a7fb8a2b9159d9da05991ad6fc4e", "filename": "libgo/go/crypto/openpgp/read.go", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -10,7 +10,6 @@ import (\n \t\"crypto/openpgp/armor\"\n \t\"crypto/openpgp/error\"\n \t\"crypto/openpgp/packet\"\n-\t\"crypto/rsa\"\n \t_ \"crypto/sha256\"\n \t\"hash\"\n \t\"io\"\n@@ -44,7 +43,7 @@ type MessageDetails struct {\n \tDecryptedWith            Key                 // the private key used to decrypt the message, if any.\n \tIsSigned                 bool                // true if the message is signed.\n \tSignedByKeyId            uint64              // the key id of the signer, if any.\n-\tSignedBy                 *Key                // the key of the signer, if availible.\n+\tSignedBy                 *Key                // the key of the signer, if available.\n \tLiteralData              *packet.LiteralData // the metadata of the contents\n \tUnverifiedBody           io.Reader           // the contents of the message.\n \n@@ -57,7 +56,6 @@ type MessageDetails struct {\n \t// been consumed. Once EOF has been seen, the following fields are\n \t// valid. (An authentication code failure is reported as a\n \t// SignatureError error when reading from UnverifiedBody.)\n-\n \tSignatureError os.Error          // nil if the signature is good.\n \tSignature      *packet.Signature // the signature packet itself.\n \n@@ -112,7 +110,10 @@ ParsePackets:\n \t\tcase *packet.EncryptedKey:\n \t\t\t// This packet contains the decryption key encrypted to a public key.\n \t\t\tmd.EncryptedToKeyIds = append(md.EncryptedToKeyIds, p.KeyId)\n-\t\t\tif p.Algo != packet.PubKeyAlgoRSA && p.Algo != packet.PubKeyAlgoRSAEncryptOnly {\n+\t\t\tswitch p.Algo {\n+\t\t\tcase packet.PubKeyAlgoRSA, packet.PubKeyAlgoRSAEncryptOnly, packet.PubKeyAlgoElGamal:\n+\t\t\t\tbreak\n+\t\t\tdefault:\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tvar keys []Key\n@@ -145,7 +146,7 @@ ParsePackets:\n \t// function so that it can decrypt a key or give us a passphrase.\n FindKey:\n \tfor {\n-\t\t// See if any of the keys already have a private key availible\n+\t\t// See if any of the keys already have a private key available\n \t\tcandidates = candidates[:0]\n \t\tcandidateFingerprints := make(map[string]bool)\n \n@@ -155,7 +156,7 @@ FindKey:\n \t\t\t}\n \t\t\tif !pk.key.PrivateKey.Encrypted {\n \t\t\t\tif len(pk.encryptedKey.Key) == 0 {\n-\t\t\t\t\tpk.encryptedKey.DecryptRSA(pk.key.PrivateKey.PrivateKey.(*rsa.PrivateKey))\n+\t\t\t\t\tpk.encryptedKey.Decrypt(pk.key.PrivateKey)\n \t\t\t\t}\n \t\t\t\tif len(pk.encryptedKey.Key) == 0 {\n \t\t\t\t\tcontinue\n@@ -214,7 +215,7 @@ FindKey:\n \treturn readSignedMessage(packets, md, keyring)\n }\n \n-// readSignedMessage reads a possibily signed message if mdin is non-zero then\n+// readSignedMessage reads a possibly signed message if mdin is non-zero then\n // that structure is updated and returned. Otherwise a fresh MessageDetails is\n // used.\n func readSignedMessage(packets *packet.Reader, mdin *MessageDetails, keyring KeyRing) (md *MessageDetails, err os.Error) {\n@@ -249,11 +250,12 @@ FindLiteralData:\n \t\t\tmd.IsSigned = true\n \t\t\tmd.SignedByKeyId = p.KeyId\n \t\t\tkeys := keyring.KeysById(p.KeyId)\n-\t\t\tfor _, key := range keys {\n+\t\t\tfor i, key := range keys {\n \t\t\t\tif key.SelfSignature.FlagsValid && !key.SelfSignature.FlagSign {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t\tmd.SignedBy = &key\n+\t\t\t\tmd.SignedBy = &keys[i]\n+\t\t\t\tbreak\n \t\t\t}\n \t\tcase *packet.LiteralData:\n \t\t\tmd.LiteralData = p\n@@ -274,13 +276,13 @@ FindLiteralData:\n \n // hashForSignature returns a pair of hashes that can be used to verify a\n // signature. The signature may specify that the contents of the signed message\n-// should be preprocessed (i.e. to normalise line endings). Thus this function\n+// should be preprocessed (i.e. to normalize line endings). Thus this function\n // returns two hashes. The second should be used to hash the message itself and\n // performs any needed preprocessing.\n func hashForSignature(hashId crypto.Hash, sigType packet.SignatureType) (hash.Hash, hash.Hash, os.Error) {\n \th := hashId.New()\n \tif h == nil {\n-\t\treturn nil, nil, error.UnsupportedError(\"hash not availible: \" + strconv.Itoa(int(hashId)))\n+\t\treturn nil, nil, error.UnsupportedError(\"hash not available: \" + strconv.Itoa(int(hashId)))\n \t}\n \n \tswitch sigType {"}, {"sha": "4dc290ef29d5842c4f0de0788624e03f6fd14581", "filename": "libgo/go/crypto/openpgp/read_test.go", "status": "modified", "additions": 87, "deletions": 38, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -33,6 +33,29 @@ func TestReadKeyRing(t *testing.T) {\n \t}\n }\n \n+func TestRereadKeyRing(t *testing.T) {\n+\tkring, err := ReadKeyRing(readerFromHex(testKeys1And2Hex))\n+\tif err != nil {\n+\t\tt.Errorf(\"error in initial parse: %s\", err)\n+\t\treturn\n+\t}\n+\tout := new(bytes.Buffer)\n+\terr = kring[0].Serialize(out)\n+\tif err != nil {\n+\t\tt.Errorf(\"error in serialization: %s\", err)\n+\t\treturn\n+\t}\n+\tkring, err = ReadKeyRing(out)\n+\tif err != nil {\n+\t\tt.Errorf(\"error in second parse: %s\", err)\n+\t\treturn\n+\t}\n+\n+\tif len(kring) != 1 || uint32(kring[0].PrimaryKey.KeyId) != 0xC20C31BB {\n+\t\tt.Errorf(\"bad keyring: %#v\", kring)\n+\t}\n+}\n+\n func TestReadPrivateKeyRing(t *testing.T) {\n \tkring, err := ReadKeyRing(readerFromHex(testKeys1And2PrivateHex))\n \tif err != nil {\n@@ -102,49 +125,71 @@ func TestTextSignedMessage(t *testing.T) {\n \tcheckSignedMessage(t, signedTextMessageHex, signedTextInput)\n }\n \n-func TestSignedEncryptedMessage(t *testing.T) {\n-\texpected := \"Signed and encrypted message\\n\"\n-\tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2PrivateHex))\n-\tprompt := func(keys []Key, symmetric bool) ([]byte, os.Error) {\n-\t\tif symmetric {\n-\t\t\tt.Errorf(\"prompt: message was marked as symmetrically encrypted\")\n-\t\t\treturn nil, error.KeyIncorrectError\n-\t\t}\n+var signedEncryptedMessageTests = []struct {\n+\tkeyRingHex       string\n+\tmessageHex       string\n+\tsignedByKeyId    uint64\n+\tencryptedToKeyId uint64\n+}{\n+\t{\n+\t\ttestKeys1And2PrivateHex,\n+\t\tsignedEncryptedMessageHex,\n+\t\t0xa34d7e18c20c31bb,\n+\t\t0x2a67d68660df41c7,\n+\t},\n+\t{\n+\t\tdsaElGamalTestKeysHex,\n+\t\tsignedEncryptedMessage2Hex,\n+\t\t0x33af447ccd759b09,\n+\t\t0xcf6a7abcd43e3673,\n+\t},\n+}\n \n-\t\tif len(keys) == 0 {\n-\t\t\tt.Error(\"prompt: no keys requested\")\n-\t\t\treturn nil, error.KeyIncorrectError\n+func TestSignedEncryptedMessage(t *testing.T) {\n+\tfor i, test := range signedEncryptedMessageTests {\n+\t\texpected := \"Signed and encrypted message\\n\"\n+\t\tkring, _ := ReadKeyRing(readerFromHex(test.keyRingHex))\n+\t\tprompt := func(keys []Key, symmetric bool) ([]byte, os.Error) {\n+\t\t\tif symmetric {\n+\t\t\t\tt.Errorf(\"prompt: message was marked as symmetrically encrypted\")\n+\t\t\t\treturn nil, error.KeyIncorrectError\n+\t\t\t}\n+\n+\t\t\tif len(keys) == 0 {\n+\t\t\t\tt.Error(\"prompt: no keys requested\")\n+\t\t\t\treturn nil, error.KeyIncorrectError\n+\t\t\t}\n+\n+\t\t\terr := keys[0].PrivateKey.Decrypt([]byte(\"passphrase\"))\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"prompt: error decrypting key: %s\", err)\n+\t\t\t\treturn nil, error.KeyIncorrectError\n+\t\t\t}\n+\n+\t\t\treturn nil, nil\n \t\t}\n \n-\t\terr := keys[0].PrivateKey.Decrypt([]byte(\"passphrase\"))\n+\t\tmd, err := ReadMessage(readerFromHex(test.messageHex), kring, prompt)\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"prompt: error decrypting key: %s\", err)\n-\t\t\treturn nil, error.KeyIncorrectError\n+\t\t\tt.Errorf(\"#%d: error reading message: %s\", i, err)\n+\t\t\treturn\n \t\t}\n \n-\t\treturn nil, nil\n-\t}\n-\n-\tmd, err := ReadMessage(readerFromHex(signedEncryptedMessageHex), kring, prompt)\n-\tif err != nil {\n-\t\tt.Errorf(\"error reading message: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tif !md.IsSigned || md.SignedByKeyId != 0xa34d7e18c20c31bb || md.SignedBy == nil || !md.IsEncrypted || md.IsSymmetricallyEncrypted || len(md.EncryptedToKeyIds) == 0 || md.EncryptedToKeyIds[0] != 0x2a67d68660df41c7 {\n-\t\tt.Errorf(\"bad MessageDetails: %#v\", md)\n-\t}\n+\t\tif !md.IsSigned || md.SignedByKeyId != test.signedByKeyId || md.SignedBy == nil || !md.IsEncrypted || md.IsSymmetricallyEncrypted || len(md.EncryptedToKeyIds) == 0 || md.EncryptedToKeyIds[0] != test.encryptedToKeyId {\n+\t\t\tt.Errorf(\"#%d: bad MessageDetails: %#v\", i, md)\n+\t\t}\n \n-\tcontents, err := ioutil.ReadAll(md.UnverifiedBody)\n-\tif err != nil {\n-\t\tt.Errorf(\"error reading UnverifiedBody: %s\", err)\n-\t}\n-\tif string(contents) != expected {\n-\t\tt.Errorf(\"bad UnverifiedBody got:%s want:%s\", string(contents), expected)\n-\t}\n+\t\tcontents, err := ioutil.ReadAll(md.UnverifiedBody)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: error reading UnverifiedBody: %s\", i, err)\n+\t\t}\n+\t\tif string(contents) != expected {\n+\t\t\tt.Errorf(\"#%d: bad UnverifiedBody got:%s want:%s\", i, string(contents), expected)\n+\t\t}\n \n-\tif md.SignatureError != nil || md.Signature == nil {\n-\t\tt.Errorf(\"failed to validate: %s\", md.SignatureError)\n+\t\tif md.SignatureError != nil || md.Signature == nil {\n+\t\t\tt.Errorf(\"#%d: failed to validate: %s\", i, md.SignatureError)\n+\t\t}\n \t}\n }\n \n@@ -193,9 +238,9 @@ func TestSymmetricallyEncrypted(t *testing.T) {\n \t\tt.Errorf(\"ReadAll: %s\", err)\n \t}\n \n-\texpectedCreatationTime := uint32(1295992998)\n-\tif md.LiteralData.Time != expectedCreatationTime {\n-\t\tt.Errorf(\"LiteralData.Time is %d, want %d\", md.LiteralData.Time, expectedCreatationTime)\n+\texpectedCreationTime := uint32(1295992998)\n+\tif md.LiteralData.Time != expectedCreationTime {\n+\t\tt.Errorf(\"LiteralData.Time is %d, want %d\", md.LiteralData.Time, expectedCreationTime)\n \t}\n \n \tif string(contents) != expected {\n@@ -265,12 +310,16 @@ const testKeys1And2Hex = \"988d044d3c5c10010400b1d13382944bd5aba23a4312968b5095d1\n \n const testKeys1And2PrivateHex = \"9501d8044d3c5c10010400b1d13382944bd5aba23a4312968b5095d14f947f600eb478e14a6fcb16b0e0cac764884909c020bc495cfcc39a935387c661507bdb236a0612fb582cac3af9b29cc2c8c70090616c41b662f4da4c1201e195472eb7f4ae1ccbcbf9940fe21d985e379a5563dde5b9a23d35f1cfaa5790da3b79db26f23695107bfaca8e7b5bcd00110100010003ff4d91393b9a8e3430b14d6209df42f98dc927425b881f1209f319220841273a802a97c7bdb8b3a7740b3ab5866c4d1d308ad0d3a79bd1e883aacf1ac92dfe720285d10d08752a7efe3c609b1d00f17f2805b217be53999a7da7e493bfc3e9618fd17018991b8128aea70a05dbce30e4fbe626aa45775fa255dd9177aabf4df7cf0200c1ded12566e4bc2bb590455e5becfb2e2c9796482270a943343a7835de41080582c2be3caf5981aa838140e97afa40ad652a0b544f83eb1833b0957dce26e47b0200eacd6046741e9ce2ec5beb6fb5e6335457844fb09477f83b050a96be7da043e17f3a9523567ed40e7a521f818813a8b8a72209f1442844843ccc7eb9805442570200bdafe0438d97ac36e773c7162028d65844c4d463e2420aa2228c6e50dc2743c3d6c72d0d782a5173fe7be2169c8a9f4ef8a7cf3e37165e8c61b89c346cdc6c1799d2b41054657374204b6579203120285253412988b804130102002205024d3c5c10021b03060b090807030206150802090a0b0416020301021e01021780000a0910a34d7e18c20c31bbb5b304009cc45fe610b641a2c146331be94dade0a396e73ca725e1b25c21708d9cab46ecca5ccebc23055879df8f99eea39b377962a400f2ebdc36a7c99c333d74aeba346315137c3ff9d0a09b0273299090343048afb8107cf94cbd1400e3026f0ccac7ecebbc4d78588eb3e478fe2754d3ca664bcf3eac96ca4a6b0c8d7df5102f60f6b00200009d01d8044d3c5c10010400b201df61d67487301f11879d514f4248ade90c8f68c7af1284c161098de4c28c2850f1ec7b8e30f959793e571542ffc6532189409cb51c3d30dad78c4ad5165eda18b20d9826d8707d0f742e2ab492103a85bbd9ddf4f5720f6de7064feb0d39ee002219765bb07bcfb8b877f47abe270ddeda4f676108cecb6b9bb2ad484a4f00110100010003fd17a7490c22a79c59281fb7b20f5e6553ec0c1637ae382e8adaea295f50241037f8997cf42c1ce26417e015091451b15424b2c59eb8d4161b0975630408e394d3b00f88d4b4e18e2cc85e8251d4753a27c639c83f5ad4a571c4f19d7cd460b9b73c25ade730c99df09637bd173d8e3e981ac64432078263bb6dc30d3e974150dd0200d0ee05be3d4604d2146fb0457f31ba17c057560785aa804e8ca5530a7cd81d3440d0f4ba6851efcfd3954b7e68908fc0ba47f7ac37bf559c6c168b70d3a7c8cd0200da1c677c4bce06a068070f2b3733b0a714e88d62aa3f9a26c6f5216d48d5c2b5624144f3807c0df30be66b3268eeeca4df1fbded58faf49fc95dc3c35f134f8b01fd1396b6c0fc1b6c4f0eb8f5e44b8eace1e6073e20d0b8bc5385f86f1cf3f050f66af789f3ef1fc107b7f4421e19e0349c730c68f0a226981f4e889054fdb4dc149e8e889f04180102000905024d3c5c10021b0c000a0910a34d7e18c20c31bb1a03040085c8d62e16d05dc4e9dad64953c8a2eed8b6c12f92b1575eeaa6dcf7be9473dd5b24b37b6dffbb4e7c99ed1bd3cb11634be19b3e6e207bed7505c7ca111ccf47cb323bf1f8851eb6360e8034cbff8dd149993c959de89f8f77f38e7e98b8e3076323aa719328e2b408db5ec0d03936efd57422ba04f925cdc7b4c1af7590e40ab00200009501fe044d3c5c33010400b488c3e5f83f4d561f317817538d9d0397981e9aef1321ca68ebfae1cf8b7d388e19f4b5a24a82e2fbbf1c6c26557a6c5845307a03d815756f564ac7325b02bc83e87d5480a8fae848f07cb891f2d51ce7df83dcafdc12324517c86d472cc0ee10d47a68fd1d9ae49a6c19bbd36d82af597a0d88cc9c49de9df4e696fc1f0b5d0011010001fe030302e9030f3c783e14856063f16938530e148bc57a7aa3f3e4f90df9dceccdc779bc0835e1ad3d006e4a8d7b36d08b8e0de5a0d947254ecfbd22037e6572b426bcfdc517796b224b0036ff90bc574b5509bede85512f2eefb520fb4b02aa523ba739bff424a6fe81c5041f253f8d757e69a503d3563a104d0d49e9e890b9d0c26f96b55b743883b472caa7050c4acfd4a21f875bdf1258d88bd61224d303dc9df77f743137d51e6d5246b88c406780528fd9a3e15bab5452e5b93970d9dcc79f48b38651b9f15bfbcf6da452837e9cc70683d1bdca94507870f743e4ad902005812488dd342f836e72869afd00ce1850eea4cfa53ce10e3608e13d3c149394ee3cbd0e23d018fcbcb6e2ec5a1a22972d1d462ca05355d0d290dd2751e550d5efb38c6c89686344df64852bf4ff86638708f644e8ec6bd4af9b50d8541cb91891a431326ab2e332faa7ae86cfb6e0540aa63160c1e5cdd5a4add518b303fff0a20117c6bc77f7cfbaf36b04c865c6c2b42754657374204b6579203220285253412c20656e637279707465642070726976617465206b65792988b804130102002205024d3c5c33021b03060b090807030206150802090a0b0416020301021e01021780000a0910d4984f961e35246b98940400908a73b6a6169f700434f076c6c79015a49bee37130eaf23aaa3cfa9ce60bfe4acaa7bc95f1146ada5867e0079babb38804891f4f0b8ebca57a86b249dee786161a755b7a342e68ccf3f78ed6440a93a6626beb9a37aa66afcd4f888790cb4bb46d94a4ae3eb3d7d3e6b00f6bfec940303e89ec5b32a1eaaacce66497d539328b00200009d01fe044d3c5c33010400a4e913f9442abcc7f1804ccab27d2f787ffa592077ca935a8bb23165bd8d57576acac647cc596b2c3f814518cc8c82953c7a4478f32e0cf645630a5ba38d9618ef2bc3add69d459ae3dece5cab778938d988239f8c5ae437807075e06c828019959c644ff05ef6a5a1dab72227c98e3a040b0cf219026640698d7a13d8538a570011010001fe030302e9030f3c783e148560f936097339ae381d63116efcf802ff8b1c9360767db5219cc987375702a4123fd8657d3e22700f23f95020d1b261eda5257e9a72f9a918e8ef22dd5b3323ae03bbc1923dd224db988cadc16acc04b120a9f8b7e84da9716c53e0334d7b66586ddb9014df604b41be1e960dcfcbc96f4ed150a1a0dd070b9eb14276b9b6be413a769a75b519a53d3ecc0c220e85cd91ca354d57e7344517e64b43b6e29823cbd87eae26e2b2e78e6dedfbb76e3e9f77bcb844f9a8932eb3db2c3f9e44316e6f5d60e9e2a56e46b72abe6b06dc9a31cc63f10023d1f5e12d2a3ee93b675c96f504af0001220991c88db759e231b3320dcedf814dcf723fd9857e3d72d66a0f2af26950b915abdf56c1596f46a325bf17ad4810d3535fb02a259b247ac3dbd4cc3ecf9c51b6c07cebb009c1506fba0a89321ec8683e3fd009a6e551d50243e2d5092fefb3321083a4bad91320dc624bd6b5dddf93553e3d53924c05bfebec1fb4bd47e89a1a889f04180102000905024d3c5c33021b0c000a0910d4984f961e35246b26c703ff7ee29ef53bc1ae1ead533c408fa136db508434e233d6e62be621e031e5940bbd4c08142aed0f82217e7c3e1ec8de574bc06ccf3c36633be41ad78a9eacd209f861cae7b064100758545cc9dd83db71806dc1cfd5fb9ae5c7474bba0c19c44034ae61bae5eca379383339dece94ff56ff7aa44a582f3e5c38f45763af577c0934b0020000\"\n \n+const dsaElGamalTestKeysHex = \"9501e1044dfcb16a110400aa3e5c1a1f43dd28c2ffae8abf5cfce555ee874134d8ba0a0f7b868ce2214beddc74e5e1e21ded354a95d18acdaf69e5e342371a71fbb9093162e0c5f3427de413a7f2c157d83f5cd2f9d791256dc4f6f0e13f13c3302af27f2384075ab3021dff7a050e14854bbde0a1094174855fc02f0bae8e00a340d94a1f22b32e48485700a0cec672ac21258fb95f61de2ce1af74b2c4fa3e6703ff698edc9be22c02ae4d916e4fa223f819d46582c0516235848a77b577ea49018dcd5e9e15cff9dbb4663a1ae6dd7580fa40946d40c05f72814b0f88481207e6c0832c3bded4853ebba0a7e3bd8e8c66df33d5a537cd4acf946d1080e7a3dcea679cb2b11a72a33a2b6a9dc85f466ad2ddf4c3db6283fa645343286971e3dd700703fc0c4e290d45767f370831a90187e74e9972aae5bff488eeff7d620af0362bfb95c1a6c3413ab5d15a2e4139e5d07a54d72583914661ed6a87cce810be28a0aa8879a2dd39e52fb6fe800f4f181ac7e328f740cde3d09a05cecf9483e4cca4253e60d4429ffd679d9996a520012aad119878c941e3cf151459873bdfc2a9563472fe0303027a728f9feb3b864260a1babe83925ce794710cfd642ee4ae0e5b9d74cee49e9c67b6cd0ea5dfbb582132195a121356a1513e1bca73e5b80c58c7ccb4164453412f456c47616d616c2054657374204b65792031886204131102002205024dfcb16a021b03060b090807030206150802090a0b0416020301021e01021780000a091033af447ccd759b09fadd00a0b8fd6f5a790bad7e9f2dbb7632046dc4493588db009c087c6a9ba9f7f49fab221587a74788c00db4889ab00200009d0157044dfcb16a1004008dec3f9291205255ccff8c532318133a6840739dd68b03ba942676f9038612071447bf07d00d559c5c0875724ea16a4c774f80d8338b55fca691a0522e530e604215b467bbc9ccfd483a1da99d7bc2648b4318fdbd27766fc8bfad3fddb37c62b8ae7ccfe9577e9b8d1e77c1d417ed2c2ef02d52f4da11600d85d3229607943700030503ff506c94c87c8cab778e963b76cf63770f0a79bf48fb49d3b4e52234620fc9f7657f9f8d56c96a2b7c7826ae6b57ebb2221a3fe154b03b6637cea7e6d98e3e45d87cf8dc432f723d3d71f89c5192ac8d7290684d2c25ce55846a80c9a7823f6acd9bb29fa6cd71f20bc90eccfca20451d0c976e460e672b000df49466408d527affe0303027a728f9feb3b864260abd761730327bca2aaa4ea0525c175e92bf240682a0e83b226f97ecb2e935b62c9a133858ce31b271fa8eb41f6a1b3cd72a63025ce1a75ee4180dcc284884904181102000905024dfcb16a021b0c000a091033af447ccd759b09dd0b009e3c3e7296092c81bee5a19929462caaf2fff3ae26009e218c437a2340e7ea628149af1ec98ec091a43992b00200009501e1044dfcb1be1104009f61faa61aa43df75d128cbe53de528c4aec49ce9360c992e70c77072ad5623de0a3a6212771b66b39a30dad6781799e92608316900518ec01184a85d872365b7d2ba4bacfb5882ea3c2473d3750dc6178cc1cf82147fb58caa28b28e9f12f6d1efcb0534abed644156c91cca4ab78834268495160b2400bc422beb37d237c2300a0cac94911b6d493bda1e1fbc6feeca7cb7421d34b03fe22cec6ccb39675bb7b94a335c2b7be888fd3906a1125f33301d8aa6ec6ee6878f46f73961c8d57a3e9544d8ef2a2cbfd4d52da665b1266928cfe4cb347a58c412815f3b2d2369dec04b41ac9a71cc9547426d5ab941cccf3b18575637ccfb42df1a802df3cfe0a999f9e7109331170e3a221991bf868543960f8c816c28097e503fe319db10fb98049f3a57d7c80c420da66d56f3644371631fad3f0ff4040a19a4fedc2d07727a1b27576f75a4d28c47d8246f27071e12d7a8de62aad216ddbae6aa02efd6b8a3e2818cda48526549791ab277e447b3a36c57cefe9b592f5eab73959743fcc8e83cbefec03a329b55018b53eec196765ae40ef9e20521a603c551efe0303020950d53a146bf9c66034d00c23130cce95576a2ff78016ca471276e8227fb30b1ffbd92e61804fb0c3eff9e30b1a826ee8f3e4730b4d86273ca977b4164453412f456c47616d616c2054657374204b65792032886204131102002205024dfcb1be021b03060b090807030206150802090a0b0416020301021e01021780000a0910a86bf526325b21b22bd9009e34511620415c974750a20df5cb56b182f3b48e6600a0a9466cb1a1305a84953445f77d461593f1d42bc1b00200009d0157044dfcb1be1004009565a951da1ee87119d600c077198f1c1bceb0f7aa54552489298e41ff788fa8f0d43a69871f0f6f77ebdfb14a4260cf9fbeb65d5844b4272a1904dd95136d06c3da745dc46327dd44a0f16f60135914368c8039a34033862261806bb2c5ce1152e2840254697872c85441ccb7321431d75a747a4bfb1d2c66362b51ce76311700030503fc0ea76601c196768070b7365a200e6ddb09307f262d5f39eec467b5f5784e22abdf1aa49226f59ab37cb49969d8f5230ea65caf56015abda62604544ed526c5c522bf92bed178a078789f6c807b6d34885688024a5bed9e9f8c58d11d4b82487b44c5f470c5606806a0443b79cadb45e0f897a561a53f724e5349b9267c75ca17fe0303020950d53a146bf9c660bc5f4ce8f072465e2d2466434320c1e712272fafc20e342fe7608101580fa1a1a367e60486a7cd1246b7ef5586cf5e10b32762b710a30144f12dd17dd4884904181102000905024dfcb1be021b0c000a0910a86bf526325b21b2904c00a0b2b66b4b39ccffda1d10f3ea8d58f827e30a8b8e009f4255b2d8112a184e40cde43a34e8655ca7809370b0020000\"\n+\n const signedMessageHex = \"a3019bc0cbccc0c4b8d8b74ee2108fe16ec6d3ca490cbe362d3f8333d3f352531472538b8b13d353b97232f352158c20943157c71c16064626063656269052062e4e01987e9b6fccff4b7df3a34c534b23e679cbec3bc0f8f6e64dfb4b55fe3f8efa9ce110ddb5cd79faf1d753c51aecfa669f7e7aa043436596cccc3359cb7dd6bbe9ecaa69e5989d9e57209571edc0b2fa7f57b9b79a64ee6e99ce1371395fee92fec2796f7b15a77c386ff668ee27f6d38f0baa6c438b561657377bf6acff3c5947befd7bf4c196252f1d6e5c524d0300\"\n \n const signedTextMessageHex = \"a3019bc0cbccc8c4b8d8b74ee2108fe16ec6d36a250cbece0c178233d3f352531472538b8b13d35379b97232f352158ca0b4312f57c71c1646462606365626906a062e4e019811591798ff99bf8afee860b0d8a8c2a85c3387e3bcf0bb3b17987f2bbcfab2aa526d930cbfd3d98757184df3995c9f3e7790e36e3e9779f06089d4c64e9e47dd6202cb6e9bc73c5d11bb59fbaf89d22d8dc7cf199ddf17af96e77c5f65f9bbed56f427bd8db7af37f6c9984bf9385efaf5f184f986fb3e6adb0ecfe35bbf92d16a7aa2a344fb0bc52fb7624f0200\"\n \n const signedEncryptedMessageHex = \"848c032a67d68660df41c70103ff5789d0de26b6a50c985a02a13131ca829c413a35d0e6fa8d6842599252162808ac7439c72151c8c6183e76923fe3299301414d0c25a2f06a2257db3839e7df0ec964773f6e4c4ac7ff3b48c444237166dd46ba8ff443a5410dc670cb486672fdbe7c9dfafb75b4fea83af3a204fe2a7dfa86bd20122b4f3d2646cbeecb8f7be8d2c03b018bd210b1d3791e1aba74b0f1034e122ab72e760492c192383cf5e20b5628bd043272d63df9b923f147eb6091cd897553204832aba48fec54aa447547bb16305a1024713b90e77fd0065f1918271947549205af3c74891af22ee0b56cd29bfec6d6e351901cd4ab3ece7c486f1e32a792d4e474aed98ee84b3f591c7dff37b64e0ecd68fd036d517e412dcadf85840ce184ad7921ad446c4ee28db80447aea1ca8d4f574db4d4e37688158ddd19e14ee2eab4873d46947d65d14a23e788d912cf9a19624ca7352469b72a83866b7c23cb5ace3deab3c7018061b0ba0f39ed2befe27163e5083cf9b8271e3e3d52cc7ad6e2a3bd81d4c3d7022f8d\"\n \n+const signedEncryptedMessage2Hex = \"85010e03cf6a7abcd43e36731003fb057f5495b79db367e277cdbe4ab90d924ddee0c0381494112ff8c1238fb0184af35d1731573b01bc4c55ecacd2aafbe2003d36310487d1ecc9ac994f3fada7f9f7f5c3a64248ab7782906c82c6ff1303b69a84d9a9529c31ecafbcdb9ba87e05439897d87e8a2a3dec55e14df19bba7f7bd316291c002ae2efd24f83f9e3441203fc081c0c23dc3092a454ca8a082b27f631abf73aca341686982e8fbda7e0e7d863941d68f3de4a755c2964407f4b5e0477b3196b8c93d551dd23c8beef7d0f03fbb1b6066f78907faf4bf1677d8fcec72651124080e0b7feae6b476e72ab207d38d90b958759fdedfc3c6c35717c9dbfc979b3cfbbff0a76d24a5e57056bb88acbd2a901ef64bc6e4db02adc05b6250ff378de81dca18c1910ab257dff1b9771b85bb9bbe0a69f5989e6d1710a35e6dfcceb7d8fb5ccea8db3932b3d9ff3fe0d327597c68b3622aec8e3716c83a6c93f497543b459b58ba504ed6bcaa747d37d2ca746fe49ae0a6ce4a8b694234e941b5159ff8bd34b9023da2814076163b86f40eed7c9472f81b551452d5ab87004a373c0172ec87ea6ce42ccfa7dbdad66b745496c4873d8019e8c28d6b3\"\n+\n const symmetricallyEncryptedCompressedHex = \"8c0d04030302eb4a03808145d0d260c92f714339e13de5a79881216431925bf67ee2898ea61815f07894cd0703c50d0a76ef64d482196f47a8bc729af9b80bb6\"\n \n const dsaTestKeyHex = \"9901a2044d6c49de110400cb5ce438cf9250907ac2ba5bf6547931270b89f7c4b53d9d09f4d0213a5ef2ec1f26806d3d259960f872a4a102ef1581ea3f6d6882d15134f21ef6a84de933cc34c47cc9106efe3bd84c6aec12e78523661e29bc1a61f0aab17fa58a627fd5fd33f5149153fbe8cd70edf3d963bc287ef875270ff14b5bfdd1bca4483793923b00a0fe46d76cb6e4cbdc568435cd5480af3266d610d303fe33ae8273f30a96d4d34f42fa28ce1112d425b2e3bf7ea553d526e2db6b9255e9dc7419045ce817214d1a0056dbc8d5289956a4b1b69f20f1105124096e6a438f41f2e2495923b0f34b70642607d45559595c7fe94d7fa85fc41bf7d68c1fd509ebeaa5f315f6059a446b9369c277597e4f474a9591535354c7e7f4fd98a08aa60400b130c24ff20bdfbf683313f5daebf1c9b34b3bdadfc77f2ddd72ee1fb17e56c473664bc21d66467655dd74b9005e3a2bacce446f1920cd7017231ae447b67036c9b431b8179deacd5120262d894c26bc015bffe3d827ba7087ad9b700d2ca1f6d16cc1786581e5dd065f293c31209300f9b0afcc3f7c08dd26d0a22d87580b4db41054657374204b65792033202844534129886204131102002205024d6c49de021b03060b090807030206150802090a0b0416020301021e01021780000a0910338934250ccc03607e0400a0bdb9193e8a6b96fc2dfc108ae848914b504481f100a09c4dc148cb693293a67af24dd40d2b13a9e36794\""}, {"sha": "da926a76ed28a3c1b5dc9ee1c2e35cfa34d87249", "filename": "libgo/go/crypto/openpgp/s2k/s2k.go", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -90,7 +90,7 @@ func Parse(r io.Reader) (f func(out, in []byte), err os.Error) {\n \t}\n \th := hash.New()\n \tif h == nil {\n-\t\treturn nil, error.UnsupportedError(\"hash not availible: \" + strconv.Itoa(int(hash)))\n+\t\treturn nil, error.UnsupportedError(\"hash not available: \" + strconv.Itoa(int(hash)))\n \t}\n \n \tswitch buf[0] {\n@@ -123,6 +123,26 @@ func Parse(r io.Reader) (f func(out, in []byte), err os.Error) {\n \treturn nil, error.UnsupportedError(\"S2K function\")\n }\n \n+// Serialize salts and stretches the given passphrase and writes the resulting\n+// key into key. It also serializes an S2K descriptor to w.\n+func Serialize(w io.Writer, key []byte, rand io.Reader, passphrase []byte) os.Error {\n+\tvar buf [11]byte\n+\tbuf[0] = 3 /* iterated and salted */\n+\tbuf[1], _ = HashToHashId(crypto.SHA1)\n+\tsalt := buf[2:10]\n+\tif _, err := io.ReadFull(rand, salt); err != nil {\n+\t\treturn err\n+\t}\n+\tconst count = 65536 // this is the default in gpg\n+\tbuf[10] = 96        // 65536 iterations\n+\tif _, err := w.Write(buf[:]); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tIterated(key, crypto.SHA1.New(), passphrase, salt, count)\n+\treturn nil\n+}\n+\n // hashToHashIdMapping contains pairs relating OpenPGP's hash identifier with\n // Go's crypto.Hash type. See RFC 4880, section 9.4.\n var hashToHashIdMapping = []struct {"}, {"sha": "ec4012c23846d0daf17aeb7c8b019b10d3d591b6", "filename": "libgo/go/crypto/openpgp/s2k/s2k_test.go", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -7,6 +7,7 @@ package s2k\n import (\n \t\"bytes\"\n \t\"crypto/sha1\"\n+\t\"crypto/rand\"\n \t\"encoding/hex\"\n \t\"testing\"\n )\n@@ -36,7 +37,6 @@ func TestSalted(t *testing.T) {\n \t}\n }\n \n-\n var iteratedTests = []struct {\n \tin, out string\n }{\n@@ -62,7 +62,6 @@ func TestIterated(t *testing.T) {\n \t}\n }\n \n-\n var parseTests = []struct {\n \tspec, in, out string\n }{\n@@ -95,3 +94,25 @@ func TestParse(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestSerialize(t *testing.T) {\n+\tbuf := bytes.NewBuffer(nil)\n+\tkey := make([]byte, 16)\n+\tpassphrase := []byte(\"testing\")\n+\terr := Serialize(buf, key, rand.Reader, passphrase)\n+\tif err != nil {\n+\t\tt.Errorf(\"failed to serialize: %s\", err)\n+\t\treturn\n+\t}\n+\n+\tf, err := Parse(buf)\n+\tif err != nil {\n+\t\tt.Errorf(\"failed to reparse: %s\", err)\n+\t\treturn\n+\t}\n+\tkey2 := make([]byte, len(key))\n+\tf(key2, passphrase)\n+\tif !bytes.Equal(key2, key) {\n+\t\tt.Errorf(\"keys don't match: %x (serialied) vs %x (parsed)\", key, key2)\n+\t}\n+}"}, {"sha": "9884472ce75151dbe77a5a28afcd28aa7e6404d0", "filename": "libgo/go/crypto/openpgp/write.go", "status": "modified", "additions": 224, "deletions": 12, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -6,12 +6,13 @@ package openpgp\n \n import (\n \t\"crypto\"\n-\t\"crypto/dsa\"\n \t\"crypto/openpgp/armor\"\n \t\"crypto/openpgp/error\"\n \t\"crypto/openpgp/packet\"\n-\t\"crypto/rsa\"\n+\t\"crypto/openpgp/s2k\"\n+\t\"crypto/rand\"\n \t_ \"crypto/sha256\"\n+\t\"hash\"\n \t\"io\"\n \t\"os\"\n \t\"strconv\"\n@@ -77,20 +78,231 @@ func detachSign(w io.Writer, signer *Entity, message io.Reader, sigType packet.S\n \t}\n \tio.Copy(wrappedHash, message)\n \n-\tswitch signer.PrivateKey.PubKeyAlgo {\n-\tcase packet.PubKeyAlgoRSA, packet.PubKeyAlgoRSASignOnly:\n-\t\tpriv := signer.PrivateKey.PrivateKey.(*rsa.PrivateKey)\n-\t\terr = sig.SignRSA(h, priv)\n-\tcase packet.PubKeyAlgoDSA:\n-\t\tpriv := signer.PrivateKey.PrivateKey.(*dsa.PrivateKey)\n-\t\terr = sig.SignDSA(h, priv)\n-\tdefault:\n-\t\terr = error.UnsupportedError(\"public key algorithm: \" + strconv.Itoa(int(sig.PubKeyAlgo)))\n+\terr = sig.Sign(h, signer.PrivateKey)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\treturn sig.Serialize(w)\n+}\n+\n+// FileHints contains metadata about encrypted files. This metadata is, itself,\n+// encrypted.\n+type FileHints struct {\n+\t// IsBinary can be set to hint that the contents are binary data.\n+\tIsBinary bool\n+\t// FileName hints at the name of the file that should be written. It's\n+\t// truncated to 255 bytes if longer. It may be empty to suggest that the\n+\t// file should not be written to disk. It may be equal to \"_CONSOLE\" to\n+\t// suggest the data should not be written to disk.\n+\tFileName string\n+\t// EpochSeconds contains the modification time of the file, or 0 if not applicable.\n+\tEpochSeconds uint32\n+}\n+\n+// SymmetricallyEncrypt acts like gpg -c: it encrypts a file with a passphrase.\n+// The resulting WriteCloser must be closed after the contents of the file have\n+// been written.\n+func SymmetricallyEncrypt(ciphertext io.Writer, passphrase []byte, hints *FileHints) (plaintext io.WriteCloser, err os.Error) {\n+\tif hints == nil {\n+\t\thints = &FileHints{}\n \t}\n \n+\tkey, err := packet.SerializeSymmetricKeyEncrypted(ciphertext, rand.Reader, passphrase, packet.CipherAES128)\n \tif err != nil {\n \t\treturn\n \t}\n+\tw, err := packet.SerializeSymmetricallyEncrypted(ciphertext, packet.CipherAES128, key)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\treturn packet.SerializeLiteral(w, hints.IsBinary, hints.FileName, hints.EpochSeconds)\n+}\n \n-\treturn sig.Serialize(w)\n+// intersectPreferences mutates and returns a prefix of a that contains only\n+// the values in the intersection of a and b. The order of a is preserved.\n+func intersectPreferences(a []uint8, b []uint8) (intersection []uint8) {\n+\tvar j int\n+\tfor _, v := range a {\n+\t\tfor _, v2 := range b {\n+\t\t\tif v == v2 {\n+\t\t\t\ta[j] = v\n+\t\t\t\tj++\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn a[:j]\n+}\n+\n+func hashToHashId(h crypto.Hash) uint8 {\n+\tv, ok := s2k.HashToHashId(h)\n+\tif !ok {\n+\t\tpanic(\"tried to convert unknown hash\")\n+\t}\n+\treturn v\n+}\n+\n+// Encrypt encrypts a message to a number of recipients and, optionally, signs\n+// it. hints contains optional information, that is also encrypted, that aids\n+// the recipients in processing the message. The resulting WriteCloser must\n+// be closed after the contents of the file have been written.\n+func Encrypt(ciphertext io.Writer, to []*Entity, signed *Entity, hints *FileHints) (plaintext io.WriteCloser, err os.Error) {\n+\tvar signer *packet.PrivateKey\n+\tif signed != nil {\n+\t\tsigner = signed.signingKey().PrivateKey\n+\t\tif signer == nil || signer.Encrypted {\n+\t\t\treturn nil, error.InvalidArgumentError(\"signing key must be decrypted\")\n+\t\t}\n+\t}\n+\n+\t// These are the possible ciphers that we'll use for the message.\n+\tcandidateCiphers := []uint8{\n+\t\tuint8(packet.CipherAES128),\n+\t\tuint8(packet.CipherAES256),\n+\t\tuint8(packet.CipherCAST5),\n+\t}\n+\t// These are the possible hash functions that we'll use for the signature.\n+\tcandidateHashes := []uint8{\n+\t\thashToHashId(crypto.SHA256),\n+\t\thashToHashId(crypto.SHA512),\n+\t\thashToHashId(crypto.SHA1),\n+\t\thashToHashId(crypto.RIPEMD160),\n+\t}\n+\t// In the event that a recipient doesn't specify any supported ciphers\n+\t// or hash functions, these are the ones that we assume that every\n+\t// implementation supports.\n+\tdefaultCiphers := candidateCiphers[len(candidateCiphers)-1:]\n+\tdefaultHashes := candidateHashes[len(candidateHashes)-1:]\n+\n+\tencryptKeys := make([]Key, len(to))\n+\tfor i := range to {\n+\t\tencryptKeys[i] = to[i].encryptionKey()\n+\t\tif encryptKeys[i].PublicKey == nil {\n+\t\t\treturn nil, error.InvalidArgumentError(\"cannot encrypt a message to key id \" + strconv.Uitob64(to[i].PrimaryKey.KeyId, 16) + \" because it has no encryption keys\")\n+\t\t}\n+\n+\t\tsig := to[i].primaryIdentity().SelfSignature\n+\n+\t\tpreferredSymmetric := sig.PreferredSymmetric\n+\t\tif len(preferredSymmetric) == 0 {\n+\t\t\tpreferredSymmetric = defaultCiphers\n+\t\t}\n+\t\tpreferredHashes := sig.PreferredHash\n+\t\tif len(preferredHashes) == 0 {\n+\t\t\tpreferredHashes = defaultHashes\n+\t\t}\n+\t\tcandidateCiphers = intersectPreferences(candidateCiphers, preferredSymmetric)\n+\t\tcandidateHashes = intersectPreferences(candidateHashes, preferredHashes)\n+\t}\n+\n+\tif len(candidateCiphers) == 0 || len(candidateHashes) == 0 {\n+\t\treturn nil, error.InvalidArgumentError(\"cannot encrypt because recipient set shares no common algorithms\")\n+\t}\n+\n+\tcipher := packet.CipherFunction(candidateCiphers[0])\n+\thash, _ := s2k.HashIdToHash(candidateHashes[0])\n+\tsymKey := make([]byte, cipher.KeySize())\n+\tif _, err := io.ReadFull(rand.Reader, symKey); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tfor _, key := range encryptKeys {\n+\t\tif err := packet.SerializeEncryptedKey(ciphertext, rand.Reader, key.PublicKey, cipher, symKey); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tencryptedData, err := packet.SerializeSymmetricallyEncrypted(ciphertext, cipher, symKey)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tif signer != nil {\n+\t\tops := &packet.OnePassSignature{\n+\t\t\tSigType:    packet.SigTypeBinary,\n+\t\t\tHash:       hash,\n+\t\t\tPubKeyAlgo: signer.PubKeyAlgo,\n+\t\t\tKeyId:      signer.KeyId,\n+\t\t\tIsLast:     true,\n+\t\t}\n+\t\tif err := ops.Serialize(encryptedData); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tif hints == nil {\n+\t\thints = &FileHints{}\n+\t}\n+\n+\tw := encryptedData\n+\tif signer != nil {\n+\t\t// If we need to write a signature packet after the literal\n+\t\t// data then we need to stop literalData from closing\n+\t\t// encryptedData.\n+\t\tw = noOpCloser{encryptedData}\n+\n+\t}\n+\tliteralData, err := packet.SerializeLiteral(w, hints.IsBinary, hints.FileName, hints.EpochSeconds)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif signer != nil {\n+\t\treturn signatureWriter{encryptedData, literalData, hash, hash.New(), signer}, nil\n+\t}\n+\treturn literalData, nil\n+}\n+\n+// signatureWriter hashes the contents of a message while passing it along to\n+// literalData. When closed, it closes literalData, writes a signature packet\n+// to encryptedData and then also closes encryptedData.\n+type signatureWriter struct {\n+\tencryptedData io.WriteCloser\n+\tliteralData   io.WriteCloser\n+\thashType      crypto.Hash\n+\th             hash.Hash\n+\tsigner        *packet.PrivateKey\n+}\n+\n+func (s signatureWriter) Write(data []byte) (int, os.Error) {\n+\ts.h.Write(data)\n+\treturn s.literalData.Write(data)\n+}\n+\n+func (s signatureWriter) Close() os.Error {\n+\tsig := &packet.Signature{\n+\t\tSigType:      packet.SigTypeBinary,\n+\t\tPubKeyAlgo:   s.signer.PubKeyAlgo,\n+\t\tHash:         s.hashType,\n+\t\tCreationTime: uint32(time.Seconds()),\n+\t\tIssuerKeyId:  &s.signer.KeyId,\n+\t}\n+\n+\tif err := sig.Sign(s.h, s.signer); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := s.literalData.Close(); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := sig.Serialize(s.encryptedData); err != nil {\n+\t\treturn err\n+\t}\n+\treturn s.encryptedData.Close()\n+}\n+\n+// noOpCloser is like an ioutil.NopCloser, but for an io.Writer.\n+// TODO: we have two of these in OpenPGP packages alone. This probably needs\n+// to be promoted somewhere more common.\n+type noOpCloser struct {\n+\tw io.Writer\n+}\n+\n+func (c noOpCloser) Write(data []byte) (n int, err os.Error) {\n+\treturn c.w.Write(data)\n+}\n+\n+func (c noOpCloser) Close() os.Error {\n+\treturn nil\n }"}, {"sha": "c542dfa45d8b7df48dcadbc71f249c50082a942e", "filename": "libgo/go/crypto/openpgp/write_test.go", "status": "modified", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -6,7 +6,12 @@ package openpgp\n \n import (\n \t\"bytes\"\n+\t\"crypto/rand\"\n+\t\"os\"\n+\t\"io\"\n+\t\"io/ioutil\"\n \t\"testing\"\n+\t\"time\"\n )\n \n func TestSignDetached(t *testing.T) {\n@@ -44,3 +49,185 @@ func TestSignDetachedDSA(t *testing.T) {\n \n \ttestDetachedSignature(t, kring, out, signedInput, \"check\", testKey3KeyId)\n }\n+\n+func TestNewEntity(t *testing.T) {\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n+\n+\te, err := NewEntity(rand.Reader, time.Seconds(), \"Test User\", \"test\", \"test@example.com\")\n+\tif err != nil {\n+\t\tt.Errorf(\"failed to create entity: %s\", err)\n+\t\treturn\n+\t}\n+\n+\tw := bytes.NewBuffer(nil)\n+\tif err := e.SerializePrivate(w); err != nil {\n+\t\tt.Errorf(\"failed to serialize entity: %s\", err)\n+\t\treturn\n+\t}\n+\tserialized := w.Bytes()\n+\n+\tel, err := ReadKeyRing(w)\n+\tif err != nil {\n+\t\tt.Errorf(\"failed to reparse entity: %s\", err)\n+\t\treturn\n+\t}\n+\n+\tif len(el) != 1 {\n+\t\tt.Errorf(\"wrong number of entities found, got %d, want 1\", len(el))\n+\t}\n+\n+\tw = bytes.NewBuffer(nil)\n+\tif err := e.SerializePrivate(w); err != nil {\n+\t\tt.Errorf(\"failed to serialize entity second time: %s\", err)\n+\t\treturn\n+\t}\n+\n+\tif !bytes.Equal(w.Bytes(), serialized) {\n+\t\tt.Errorf(\"results differed\")\n+\t}\n+}\n+\n+func TestSymmetricEncryption(t *testing.T) {\n+\tbuf := new(bytes.Buffer)\n+\tplaintext, err := SymmetricallyEncrypt(buf, []byte(\"testing\"), nil)\n+\tif err != nil {\n+\t\tt.Errorf(\"error writing headers: %s\", err)\n+\t\treturn\n+\t}\n+\tmessage := []byte(\"hello world\\n\")\n+\t_, err = plaintext.Write(message)\n+\tif err != nil {\n+\t\tt.Errorf(\"error writing to plaintext writer: %s\", err)\n+\t}\n+\terr = plaintext.Close()\n+\tif err != nil {\n+\t\tt.Errorf(\"error closing plaintext writer: %s\", err)\n+\t}\n+\n+\tmd, err := ReadMessage(buf, nil, func(keys []Key, symmetric bool) ([]byte, os.Error) {\n+\t\treturn []byte(\"testing\"), nil\n+\t})\n+\tif err != nil {\n+\t\tt.Errorf(\"error rereading message: %s\", err)\n+\t}\n+\tmessageBuf := bytes.NewBuffer(nil)\n+\t_, err = io.Copy(messageBuf, md.UnverifiedBody)\n+\tif err != nil {\n+\t\tt.Errorf(\"error rereading message: %s\", err)\n+\t}\n+\tif !bytes.Equal(message, messageBuf.Bytes()) {\n+\t\tt.Errorf(\"recovered message incorrect got '%s', want '%s'\", messageBuf.Bytes(), message)\n+\t}\n+}\n+\n+var testEncryptionTests = []struct {\n+\tkeyRingHex string\n+\tisSigned   bool\n+}{\n+\t{\n+\t\ttestKeys1And2PrivateHex,\n+\t\tfalse,\n+\t},\n+\t{\n+\t\ttestKeys1And2PrivateHex,\n+\t\ttrue,\n+\t},\n+\t{\n+\t\tdsaElGamalTestKeysHex,\n+\t\tfalse,\n+\t},\n+\t{\n+\t\tdsaElGamalTestKeysHex,\n+\t\ttrue,\n+\t},\n+}\n+\n+func TestEncryption(t *testing.T) {\n+\tfor i, test := range testEncryptionTests {\n+\t\tkring, _ := ReadKeyRing(readerFromHex(test.keyRingHex))\n+\n+\t\tpassphrase := []byte(\"passphrase\")\n+\t\tfor _, entity := range kring {\n+\t\t\tif entity.PrivateKey != nil && entity.PrivateKey.Encrypted {\n+\t\t\t\terr := entity.PrivateKey.Decrypt(passphrase)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"#%d: failed to decrypt key\", i)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfor _, subkey := range entity.Subkeys {\n+\t\t\t\tif subkey.PrivateKey != nil && subkey.PrivateKey.Encrypted {\n+\t\t\t\t\terr := subkey.PrivateKey.Decrypt(passphrase)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tt.Errorf(\"#%d: failed to decrypt subkey\", i)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tvar signed *Entity\n+\t\tif test.isSigned {\n+\t\t\tsigned = kring[0]\n+\t\t}\n+\n+\t\tbuf := new(bytes.Buffer)\n+\t\tw, err := Encrypt(buf, kring[:1], signed, nil /* no hints */ )\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: error in Encrypt: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tconst message = \"testing\"\n+\t\t_, err = w.Write([]byte(message))\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: error writing plaintext: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\terr = w.Close()\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: error closing WriteCloser: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tmd, err := ReadMessage(buf, kring, nil /* no prompt */ )\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: error reading message: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif test.isSigned {\n+\t\t\texpectedKeyId := kring[0].signingKey().PublicKey.KeyId\n+\t\t\tif md.SignedByKeyId != expectedKeyId {\n+\t\t\t\tt.Errorf(\"#%d: message signed by wrong key id, got: %d, want: %d\", i, *md.SignedBy, expectedKeyId)\n+\t\t\t}\n+\t\t\tif md.SignedBy == nil {\n+\t\t\t\tt.Errorf(\"#%d: failed to find the signing Entity\", i)\n+\t\t\t}\n+\t\t}\n+\n+\t\tplaintext, err := ioutil.ReadAll(md.UnverifiedBody)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: error reading encrypted contents: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\texpectedKeyId := kring[0].encryptionKey().PublicKey.KeyId\n+\t\tif len(md.EncryptedToKeyIds) != 1 || md.EncryptedToKeyIds[0] != expectedKeyId {\n+\t\t\tt.Errorf(\"#%d: expected message to be encrypted to %v, but got %#v\", i, expectedKeyId, md.EncryptedToKeyIds)\n+\t\t}\n+\n+\t\tif string(plaintext) != message {\n+\t\t\tt.Errorf(\"#%d: got: %s, want: %s\", i, string(plaintext), message)\n+\t\t}\n+\n+\t\tif test.isSigned {\n+\t\t\tif md.SignatureError != nil {\n+\t\t\t\tt.Errorf(\"#%d: signature error: %s\", i, err)\n+\t\t\t}\n+\t\t\tif md.Signature == nil {\n+\t\t\t\tt.Error(\"signature missing\")\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "0eab6b213a0a9ae68491830265bd4a29e3a46fbc", "filename": "libgo/go/crypto/rand/rand_windows.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -19,7 +19,7 @@ func init() { Reader = &rngReader{} }\n \n // A rngReader satisfies reads by reading from the Windows CryptGenRandom API.\n type rngReader struct {\n-\tprov uint32\n+\tprov syscall.Handle\n \tmu   sync.Mutex\n }\n "}, {"sha": "77028476e4ff4342271a8b56666e9f50a4931813", "filename": "libgo/go/crypto/rand/util.go", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package rand\n+\n+import (\n+\t\"big\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// Prime returns a number, p, of the given size, such that p is prime\n+// with high probability.\n+func Prime(rand io.Reader, bits int) (p *big.Int, err os.Error) {\n+\tif bits < 1 {\n+\t\terr = os.EINVAL\n+\t}\n+\n+\tb := uint(bits % 8)\n+\tif b == 0 {\n+\t\tb = 8\n+\t}\n+\n+\tbytes := make([]byte, (bits+7)/8)\n+\tp = new(big.Int)\n+\n+\tfor {\n+\t\t_, err = io.ReadFull(rand, bytes)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\t// Clear bits in the first byte to make sure the candidate has a size <= bits.\n+\t\tbytes[0] &= uint8(int(1<<b) - 1)\n+\t\t// Don't let the value be too small, i.e, set the most significant bit.\n+\t\tbytes[0] |= 1 << (b - 1)\n+\t\t// Make the value odd since an even number this large certainly isn't prime.\n+\t\tbytes[len(bytes)-1] |= 1\n+\n+\t\tp.SetBytes(bytes)\n+\t\tif big.ProbablyPrime(p, 20) {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\treturn\n+}\n+\n+// Int returns a uniform random value in [0, max).\n+func Int(rand io.Reader, max *big.Int) (n *big.Int, err os.Error) {\n+\tk := (max.BitLen() + 7) / 8\n+\n+\t// b is the number of bits in the most significant byte of max.\n+\tb := uint(max.BitLen() % 8)\n+\tif b == 0 {\n+\t\tb = 8\n+\t}\n+\n+\tbytes := make([]byte, k)\n+\tn = new(big.Int)\n+\n+\tfor {\n+\t\t_, err = io.ReadFull(rand, bytes)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\t// Clear bits in the first byte to increase the probability\n+\t\t// that the candidate is < max.\n+\t\tbytes[0] &= uint8(int(1<<b) - 1)\n+\n+\t\tn.SetBytes(bytes)\n+\t\tif n.Cmp(max) < 0 {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\treturn\n+}"}, {"sha": "6006231145ac487a99462786d031d5cbc14c2ad2", "filename": "libgo/go/crypto/rsa/pkcs1v15.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -232,11 +232,11 @@ func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte)\n func pkcs1v15HashInfo(hash crypto.Hash, inLen int) (hashLen int, prefix []byte, err os.Error) {\n \thashLen = hash.Size()\n \tif inLen != hashLen {\n-\t\treturn 0, nil, os.ErrorString(\"input must be hashed message\")\n+\t\treturn 0, nil, os.NewError(\"input must be hashed message\")\n \t}\n \tprefix, ok := hashPrefixes[hash]\n \tif !ok {\n-\t\treturn 0, nil, os.ErrorString(\"unsupported hash function\")\n+\t\treturn 0, nil, os.NewError(\"unsupported hash function\")\n \t}\n \treturn\n }"}, {"sha": "6957659f2843052fd3511f3d0847b2d597760ec3", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 19, "deletions": 81, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -9,6 +9,7 @@ package rsa\n \n import (\n \t\"big\"\n+\t\"crypto/rand\"\n \t\"crypto/subtle\"\n \t\"hash\"\n \t\"io\"\n@@ -18,69 +19,6 @@ import (\n var bigZero = big.NewInt(0)\n var bigOne = big.NewInt(1)\n \n-// randomPrime returns a number, p, of the given size, such that p is prime\n-// with high probability.\n-func randomPrime(rand io.Reader, bits int) (p *big.Int, err os.Error) {\n-\tif bits < 1 {\n-\t\terr = os.EINVAL\n-\t}\n-\n-\tbytes := make([]byte, (bits+7)/8)\n-\tp = new(big.Int)\n-\n-\tfor {\n-\t\t_, err = io.ReadFull(rand, bytes)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\n-\t\t// Don't let the value be too small.\n-\t\tbytes[0] |= 0x80\n-\t\t// Make the value odd since an even number this large certainly isn't prime.\n-\t\tbytes[len(bytes)-1] |= 1\n-\n-\t\tp.SetBytes(bytes)\n-\t\tif big.ProbablyPrime(p, 20) {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\treturn\n-}\n-\n-// randomNumber returns a uniform random value in [0, max).\n-func randomNumber(rand io.Reader, max *big.Int) (n *big.Int, err os.Error) {\n-\tk := (max.BitLen() + 7) / 8\n-\n-\t// r is the number of bits in the used in the most significant byte of\n-\t// max.\n-\tr := uint(max.BitLen() % 8)\n-\tif r == 0 {\n-\t\tr = 8\n-\t}\n-\n-\tbytes := make([]byte, k)\n-\tn = new(big.Int)\n-\n-\tfor {\n-\t\t_, err = io.ReadFull(rand, bytes)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\n-\t\t// Clear bits in the first byte to increase the probability\n-\t\t// that the candidate is < max.\n-\t\tbytes[0] &= uint8(int(1<<r) - 1)\n-\n-\t\tn.SetBytes(bytes)\n-\t\tif n.Cmp(max) < 0 {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\treturn\n-}\n-\n // A PublicKey represents the public part of an RSA key.\n type PublicKey struct {\n \tN *big.Int // modulus\n@@ -94,7 +32,7 @@ type PrivateKey struct {\n \tPrimes    []*big.Int // prime factors of N, has >= 2 elements.\n \n \t// Precomputed contains precomputed values that speed up private\n-\t// operations, if availible.\n+\t// operations, if available.\n \tPrecomputed PrecomputedValues\n }\n \n@@ -126,7 +64,7 @@ func (priv *PrivateKey) Validate() os.Error {\n \t// easy for an attack to generate composites that pass this test.\n \tfor _, prime := range priv.Primes {\n \t\tif !big.ProbablyPrime(prime, 20) {\n-\t\t\treturn os.ErrorString(\"Prime factor is composite\")\n+\t\t\treturn os.NewError(\"prime factor is composite\")\n \t\t}\n \t}\n \n@@ -136,7 +74,7 @@ func (priv *PrivateKey) Validate() os.Error {\n \t\tmodulus.Mul(modulus, prime)\n \t}\n \tif modulus.Cmp(priv.N) != 0 {\n-\t\treturn os.ErrorString(\"invalid modulus\")\n+\t\treturn os.NewError(\"invalid modulus\")\n \t}\n \t// Check that e and totient(\u03a0primes) are coprime.\n \ttotient := new(big.Int).Set(bigOne)\n@@ -150,20 +88,20 @@ func (priv *PrivateKey) Validate() os.Error {\n \ty := new(big.Int)\n \tbig.GcdInt(gcd, x, y, totient, e)\n \tif gcd.Cmp(bigOne) != 0 {\n-\t\treturn os.ErrorString(\"invalid public exponent E\")\n+\t\treturn os.NewError(\"invalid public exponent E\")\n \t}\n \t// Check that de \u2261 1 (mod totient(\u03a0primes))\n \tde := new(big.Int).Mul(priv.D, e)\n \tde.Mod(de, totient)\n \tif de.Cmp(bigOne) != 0 {\n-\t\treturn os.ErrorString(\"invalid private exponent D\")\n+\t\treturn os.NewError(\"invalid private exponent D\")\n \t}\n \treturn nil\n }\n \n // GenerateKey generates an RSA keypair of the given bit size.\n-func GenerateKey(rand io.Reader, bits int) (priv *PrivateKey, err os.Error) {\n-\treturn GenerateMultiPrimeKey(rand, 2, bits)\n+func GenerateKey(random io.Reader, bits int) (priv *PrivateKey, err os.Error) {\n+\treturn GenerateMultiPrimeKey(random, 2, bits)\n }\n \n // GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit\n@@ -176,7 +114,7 @@ func GenerateKey(rand io.Reader, bits int) (priv *PrivateKey, err os.Error) {\n //\n // [1] US patent 4405829 (1972, expired)\n // [2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n-func GenerateMultiPrimeKey(rand io.Reader, nprimes int, bits int) (priv *PrivateKey, err os.Error) {\n+func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (priv *PrivateKey, err os.Error) {\n \tpriv = new(PrivateKey)\n \t// Smaller public exponents lead to faster public key\n \t// operations. Since the exponent must be coprime to\n@@ -189,7 +127,7 @@ func GenerateMultiPrimeKey(rand io.Reader, nprimes int, bits int) (priv *Private\n \tpriv.E = 3\n \n \tif nprimes < 2 {\n-\t\treturn nil, os.ErrorString(\"rsa.GenerateMultiPrimeKey: nprimes must be >= 2\")\n+\t\treturn nil, os.NewError(\"rsa.GenerateMultiPrimeKey: nprimes must be >= 2\")\n \t}\n \n \tprimes := make([]*big.Int, nprimes)\n@@ -198,7 +136,7 @@ NextSetOfPrimes:\n \tfor {\n \t\ttodo := bits\n \t\tfor i := 0; i < nprimes; i++ {\n-\t\t\tprimes[i], err = randomPrime(rand, todo/(nprimes-i))\n+\t\t\tprimes[i], err = rand.Prime(random, todo/(nprimes-i))\n \t\t\tif err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n@@ -293,7 +231,7 @@ func encrypt(c *big.Int, pub *PublicKey, m *big.Int) *big.Int {\n // EncryptOAEP encrypts the given message with RSA-OAEP.\n // The message must be no longer than the length of the public modulus less\n // twice the hash length plus 2.\n-func EncryptOAEP(hash hash.Hash, rand io.Reader, pub *PublicKey, msg []byte, label []byte) (out []byte, err os.Error) {\n+func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) (out []byte, err os.Error) {\n \thash.Reset()\n \tk := (pub.N.BitLen() + 7) / 8\n \tif len(msg) > k-2*hash.Size()-2 {\n@@ -313,7 +251,7 @@ func EncryptOAEP(hash hash.Hash, rand io.Reader, pub *PublicKey, msg []byte, lab\n \tdb[len(db)-len(msg)-1] = 1\n \tcopy(db[len(db)-len(msg):], msg)\n \n-\t_, err = io.ReadFull(rand, seed)\n+\t_, err = io.ReadFull(random, seed)\n \tif err != nil {\n \t\treturn\n \t}\n@@ -405,24 +343,24 @@ func (priv *PrivateKey) Precompute() {\n \n // decrypt performs an RSA decryption, resulting in a plaintext integer. If a\n // random source is given, RSA blinding is used.\n-func decrypt(rand io.Reader, priv *PrivateKey, c *big.Int) (m *big.Int, err os.Error) {\n+func decrypt(random io.Reader, priv *PrivateKey, c *big.Int) (m *big.Int, err os.Error) {\n \t// TODO(agl): can we get away with reusing blinds?\n \tif c.Cmp(priv.N) > 0 {\n \t\terr = DecryptionError{}\n \t\treturn\n \t}\n \n \tvar ir *big.Int\n-\tif rand != nil {\n+\tif random != nil {\n \t\t// Blinding enabled. Blinding involves multiplying c by r^e.\n \t\t// Then the decryption operation performs (m^e * r^e)^d mod n\n \t\t// which equals mr mod n. The factor of r can then be removed\n-\t\t// by multipling by the multiplicative inverse of r.\n+\t\t// by multiplying by the multiplicative inverse of r.\n \n \t\tvar r *big.Int\n \n \t\tfor {\n-\t\t\tr, err = randomNumber(rand, priv.N)\n+\t\t\tr, err = rand.Int(random, priv.N)\n \t\t\tif err != nil {\n \t\t\t\treturn\n \t\t\t}\n@@ -483,7 +421,7 @@ func decrypt(rand io.Reader, priv *PrivateKey, c *big.Int) (m *big.Int, err os.E\n \n // DecryptOAEP decrypts ciphertext using RSA-OAEP.\n // If rand != nil, DecryptOAEP uses RSA blinding to avoid timing side-channel attacks.\n-func DecryptOAEP(hash hash.Hash, rand io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) (msg []byte, err os.Error) {\n+func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) (msg []byte, err os.Error) {\n \tk := (priv.N.BitLen() + 7) / 8\n \tif len(ciphertext) > k ||\n \t\tk < hash.Size()*2+2 {\n@@ -493,7 +431,7 @@ func DecryptOAEP(hash hash.Hash, rand io.Reader, priv *PrivateKey, ciphertext []\n \n \tc := new(big.Int).SetBytes(ciphertext)\n \n-\tm, err := decrypt(rand, priv, c)\n+\tm, err := decrypt(random, priv, c)\n \tif err != nil {\n \t\treturn\n \t}"}, {"sha": "adab8e2e8ddedab229a483e51cb4dff5f004be0a", "filename": "libgo/go/crypto/subtle/constant_time_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -14,14 +14,14 @@ type TestConstantTimeCompareStruct struct {\n \tout  int\n }\n \n-var testConstandTimeCompareData = []TestConstantTimeCompareStruct{\n+var testConstantTimeCompareData = []TestConstantTimeCompareStruct{\n \t{[]byte{}, []byte{}, 1},\n \t{[]byte{0x11}, []byte{0x11}, 1},\n \t{[]byte{0x12}, []byte{0x11}, 0},\n }\n \n func TestConstantTimeCompare(t *testing.T) {\n-\tfor i, test := range testConstandTimeCompareData {\n+\tfor i, test := range testConstantTimeCompareData {\n \t\tif r := ConstantTimeCompare(test.a, test.b); r != test.out {\n \t\t\tt.Errorf(\"#%d bad result (got %x, want %x)\", i, r, test.out)\n \t\t}"}, {"sha": "3efac9c13b087a97623d14782ecbf42a217fb2aa", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -87,7 +87,7 @@ const (\n \tcertTypeRSASign    = 1 // A certificate containing an RSA key\n \tcertTypeDSSSign    = 2 // A certificate containing a DSA key\n \tcertTypeRSAFixedDH = 3 // A certificate containing a static DH key\n-\tcertTypeDSSFixedDH = 4 // A certficiate containing a static DH key\n+\tcertTypeDSSFixedDH = 4 // A certificate containing a static DH key\n \t// Rest of these are reserved by the TLS spec\n )\n "}, {"sha": "fac65afd9cfb84807d79abdfcb99f19bd76898a3", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -34,7 +34,7 @@ type Conn struct {\n \tcipherSuite       uint16\n \tocspResponse      []byte // stapled OCSP response\n \tpeerCertificates  []*x509.Certificate\n-\t// verifedChains contains the certificate chains that we built, as\n+\t// verifiedChains contains the certificate chains that we built, as\n \t// opposed to the ones presented by the server.\n \tverifiedChains [][]*x509.Certificate\n \n@@ -237,7 +237,7 @@ func (hc *halfConn) decrypt(b *block) (bool, alert) {\n \t\t\t// \"Password Interception in a SSL/TLS Channel\", Brice\n \t\t\t// Canvel et al.\n \t\t\t//\n-\t\t\t// However, our behaviour matches OpenSSL, so we leak\n+\t\t\t// However, our behavior matches OpenSSL, so we leak\n \t\t\t// only as much as they do.\n \t\tdefault:\n \t\t\tpanic(\"unknown cipher type\")\n@@ -410,7 +410,7 @@ func (hc *halfConn) freeBlock(b *block) {\n \n // splitBlock splits a block after the first n bytes,\n // returning a block with those n bytes and a\n-// block with the remaindec.  the latter may be nil.\n+// block with the remainder.  the latter may be nil.\n func (hc *halfConn) splitBlock(b *block, n int) (*block, *block) {\n \tif len(b.data) <= n {\n \t\treturn b, nil\n@@ -790,10 +790,10 @@ func (c *Conn) VerifyHostname(host string) os.Error {\n \tc.handshakeMutex.Lock()\n \tdefer c.handshakeMutex.Unlock()\n \tif !c.isClient {\n-\t\treturn os.ErrorString(\"VerifyHostname called on TLS server connection\")\n+\t\treturn os.NewError(\"VerifyHostname called on TLS server connection\")\n \t}\n \tif !c.handshakeComplete {\n-\t\treturn os.ErrorString(\"TLS handshake has not yet been performed\")\n+\t\treturn os.NewError(\"TLS handshake has not yet been performed\")\n \t}\n \treturn c.peerCertificates[0].VerifyHostname(host)\n }"}, {"sha": "41206e276b3790dd3d6ad525dad0094848004f18", "filename": "libgo/go/crypto/tls/generate_cert.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -8,8 +8,10 @@\n package main\n \n import (\n-\t\"crypto/rsa\"\n+\t\"big\"\n+\t\"crypto/x509/pkix\"\n \t\"crypto/rand\"\n+\t\"crypto/rsa\"\n \t\"crypto/x509\"\n \t\"encoding/pem\"\n \t\"flag\"\n@@ -32,8 +34,8 @@ func main() {\n \tnow := time.Seconds()\n \n \ttemplate := x509.Certificate{\n-\t\tSerialNumber: []byte{0},\n-\t\tSubject: x509.Name{\n+\t\tSerialNumber: new(big.Int).SetInt64(0),\n+\t\tSubject: pkix.Name{\n \t\t\tCommonName:   *hostName,\n \t\t\tOrganization: []string{\"Acme Co\"},\n \t\t},\n@@ -59,7 +61,7 @@ func main() {\n \tcertOut.Close()\n \tlog.Print(\"written cert.pem\\n\")\n \n-\tkeyOut, err := os.OpenFile(\"key.pem\", os.O_WRONLY|os.O_CREAT|os.O_TRUNC, 0600)\n+\tkeyOut, err := os.OpenFile(\"key.pem\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)\n \tif err != nil {\n \t\tlog.Print(\"failed to open key.pem for writing:\", err)\n \t\treturn"}, {"sha": "15604cea7ea6bff9258d95c7ce46628ed0a19327", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -40,7 +40,7 @@ func (c *Conn) clientHandshake() os.Error {\n \t_, err := io.ReadFull(c.config.rand(), hello.random[4:])\n \tif err != nil {\n \t\tc.sendAlert(alertInternalError)\n-\t\treturn os.ErrorString(\"short read from Rand\")\n+\t\treturn os.NewError(\"short read from Rand\")\n \t}\n \n \tfinishedHash.Write(hello.marshal())\n@@ -69,7 +69,7 @@ func (c *Conn) clientHandshake() os.Error {\n \n \tif !hello.nextProtoNeg && serverHello.nextProtoNeg {\n \t\tc.sendAlert(alertHandshakeFailure)\n-\t\treturn os.ErrorString(\"server advertised unrequested NPN\")\n+\t\treturn os.NewError(\"server advertised unrequested NPN\")\n \t}\n \n \tsuite, suiteId := mutualCipherSuite(c.config.cipherSuites(), serverHello.cipherSuite)\n@@ -92,7 +92,7 @@ func (c *Conn) clientHandshake() os.Error {\n \t\tcert, err := x509.ParseCertificate(asn1Data)\n \t\tif err != nil {\n \t\t\tc.sendAlert(alertBadCertificate)\n-\t\t\treturn os.ErrorString(\"failed to parse certificate from server: \" + err.String())\n+\t\t\treturn os.NewError(\"failed to parse certificate from server: \" + err.String())\n \t\t}\n \t\tcerts[i] = cert\n \t}"}, {"sha": "44a32404148cbdafb642499e7c434725b062dbeb", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -173,7 +173,7 @@ FindCipherSuite:\n \t\t\tcert, err := x509.ParseCertificate(asn1Data)\n \t\t\tif err != nil {\n \t\t\t\tc.sendAlert(alertBadCertificate)\n-\t\t\t\treturn os.ErrorString(\"could not parse client's certificate: \" + err.String())\n+\t\t\t\treturn os.NewError(\"could not parse client's certificate: \" + err.String())\n \t\t\t}\n \t\t\tcerts[i] = cert\n \t\t}\n@@ -182,7 +182,7 @@ FindCipherSuite:\n \t\tfor i := 1; i < len(certs); i++ {\n \t\t\tif err := certs[i-1].CheckSignatureFrom(certs[i]); err != nil {\n \t\t\t\tc.sendAlert(alertBadCertificate)\n-\t\t\t\treturn os.ErrorString(\"could not validate certificate signature: \" + err.String())\n+\t\t\t\treturn os.NewError(\"could not validate certificate signature: \" + err.String())\n \t\t\t}\n \t\t}\n \n@@ -209,10 +209,10 @@ FindCipherSuite:\n \n \t// If we received a client cert in response to our certificate request message,\n \t// the client will send us a certificateVerifyMsg immediately after the\n-\t// clientKeyExchangeMsg.  This message is a MD5SHA1 digest of all preceeding\n+\t// clientKeyExchangeMsg.  This message is a MD5SHA1 digest of all preceding\n \t// handshake-layer messages that is signed using the private key corresponding\n \t// to the client's certificate. This allows us to verify that the client is in\n-\t// posession of the private key of the certificate.\n+\t// possession of the private key of the certificate.\n \tif len(c.peerCertificates) > 0 {\n \t\tmsg, err = c.readHandshake()\n \t\tif err != nil {\n@@ -229,7 +229,7 @@ FindCipherSuite:\n \t\terr = rsa.VerifyPKCS1v15(pub, crypto.MD5SHA1, digest, certVerify.signature)\n \t\tif err != nil {\n \t\t\tc.sendAlert(alertBadCertificate)\n-\t\t\treturn os.ErrorString(\"could not validate signature of connection nonces: \" + err.String())\n+\t\t\treturn os.NewError(\"could not validate signature of connection nonces: \" + err.String())\n \t\t}\n \n \t\tfinishedHash.Write(certVerify.marshal())"}, {"sha": "b77646e4383cb0da92785824033b1281ade80120", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -106,7 +106,6 @@ func TestClose(t *testing.T) {\n \t}\n }\n \n-\n func testServerScript(t *testing.T, name string, serverScript [][]byte, config *Config) {\n \tc, s := net.Pipe()\n \tsrv := Server(s, config)"}, {"sha": "a40d18fd9cd33717d5aaeac3b31f0757e28151cb", "filename": "libgo/go/crypto/tls/key_agreement.go", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -32,11 +32,11 @@ func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, ckx *clientKe\n \t}\n \n \tif len(ckx.ciphertext) < 2 {\n-\t\treturn nil, os.ErrorString(\"bad ClientKeyExchange\")\n+\t\treturn nil, os.NewError(\"bad ClientKeyExchange\")\n \t}\n \tciphertextLen := int(ckx.ciphertext[0])<<8 | int(ckx.ciphertext[1])\n \tif ciphertextLen != len(ckx.ciphertext)-2 {\n-\t\treturn nil, os.ErrorString(\"bad ClientKeyExchange\")\n+\t\treturn nil, os.NewError(\"bad ClientKeyExchange\")\n \t}\n \tciphertext := ckx.ciphertext[2:]\n \n@@ -54,7 +54,7 @@ func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, ckx *clientKe\n }\n \n func (ka rsaKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) os.Error {\n-\treturn os.ErrorString(\"unexpected ServerKeyExchange\")\n+\treturn os.NewError(\"unexpected ServerKeyExchange\")\n }\n \n func (ka rsaKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, os.Error) {\n@@ -78,7 +78,6 @@ func (ka rsaKeyAgreement) generateClientKeyExchange(config *Config, clientHello\n \treturn preMasterSecret, ckx, nil\n }\n \n-\n // md5SHA1Hash implements TLS 1.0's hybrid hash function which consists of the\n // concatenation of an MD5 and SHA1 hash.\n func md5SHA1Hash(slices ...[]byte) []byte {\n@@ -146,7 +145,7 @@ Curve:\n \tmd5sha1 := md5SHA1Hash(clientHello.random, hello.random, serverECDHParams)\n \tsig, err := rsa.SignPKCS1v15(config.rand(), config.Certificates[0].PrivateKey, crypto.MD5SHA1, md5sha1)\n \tif err != nil {\n-\t\treturn nil, os.ErrorString(\"failed to sign ECDHE parameters: \" + err.String())\n+\t\treturn nil, os.NewError(\"failed to sign ECDHE parameters: \" + err.String())\n \t}\n \n \tskx := new(serverKeyExchangeMsg)\n@@ -162,11 +161,11 @@ Curve:\n \n func (ka *ecdheRSAKeyAgreement) processClientKeyExchange(config *Config, ckx *clientKeyExchangeMsg) ([]byte, os.Error) {\n \tif len(ckx.ciphertext) == 0 || int(ckx.ciphertext[0]) != len(ckx.ciphertext)-1 {\n-\t\treturn nil, os.ErrorString(\"bad ClientKeyExchange\")\n+\t\treturn nil, os.NewError(\"bad ClientKeyExchange\")\n \t}\n \tx, y := ka.curve.Unmarshal(ckx.ciphertext[1:])\n \tif x == nil {\n-\t\treturn nil, os.ErrorString(\"bad ClientKeyExchange\")\n+\t\treturn nil, os.NewError(\"bad ClientKeyExchange\")\n \t}\n \tx, _ = ka.curve.ScalarMult(x, y, ka.privateKey)\n \tpreMasterSecret := make([]byte, (ka.curve.BitSize+7)>>3)\n@@ -176,12 +175,14 @@ func (ka *ecdheRSAKeyAgreement) processClientKeyExchange(config *Config, ckx *cl\n \treturn preMasterSecret, nil\n }\n \n+var errServerKeyExchange = os.NewError(\"invalid ServerKeyExchange\")\n+\n func (ka *ecdheRSAKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) os.Error {\n \tif len(skx.key) < 4 {\n-\t\tgoto Error\n+\t\treturn errServerKeyExchange\n \t}\n \tif skx.key[0] != 3 { // named curve\n-\t\treturn os.ErrorString(\"server selected unsupported curve\")\n+\t\treturn os.NewError(\"server selected unsupported curve\")\n \t}\n \tcurveid := uint16(skx.key[1])<<8 | uint16(skx.key[2])\n \n@@ -193,39 +194,36 @@ func (ka *ecdheRSAKeyAgreement) processServerKeyExchange(config *Config, clientH\n \tcase curveP521:\n \t\tka.curve = elliptic.P521()\n \tdefault:\n-\t\treturn os.ErrorString(\"server selected unsupported curve\")\n+\t\treturn os.NewError(\"server selected unsupported curve\")\n \t}\n \n \tpublicLen := int(skx.key[3])\n \tif publicLen+4 > len(skx.key) {\n-\t\tgoto Error\n+\t\treturn errServerKeyExchange\n \t}\n \tka.x, ka.y = ka.curve.Unmarshal(skx.key[4 : 4+publicLen])\n \tif ka.x == nil {\n-\t\tgoto Error\n+\t\treturn errServerKeyExchange\n \t}\n \tserverECDHParams := skx.key[:4+publicLen]\n \n \tsig := skx.key[4+publicLen:]\n \tif len(sig) < 2 {\n-\t\tgoto Error\n+\t\treturn errServerKeyExchange\n \t}\n \tsigLen := int(sig[0])<<8 | int(sig[1])\n \tif sigLen+2 != len(sig) {\n-\t\tgoto Error\n+\t\treturn errServerKeyExchange\n \t}\n \tsig = sig[2:]\n \n \tmd5sha1 := md5SHA1Hash(clientHello.random, serverHello.random, serverECDHParams)\n \treturn rsa.VerifyPKCS1v15(cert.PublicKey.(*rsa.PublicKey), crypto.MD5SHA1, md5sha1, sig)\n-\n-Error:\n-\treturn os.ErrorString(\"invalid ServerKeyExchange\")\n }\n \n func (ka *ecdheRSAKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, os.Error) {\n \tif ka.curve == nil {\n-\t\treturn nil, nil, os.ErrorString(\"missing ServerKeyExchange message\")\n+\t\treturn nil, nil, os.NewError(\"missing ServerKeyExchange message\")\n \t}\n \tpriv, mx, my, err := ka.curve.GenerateKey(config.rand())\n \tif err != nil {\n@@ -236,12 +234,12 @@ func (ka *ecdheRSAKeyAgreement) generateClientKeyExchange(config *Config, client\n \txBytes := x.Bytes()\n \tcopy(preMasterSecret[len(preMasterSecret)-len(xBytes):], xBytes)\n \n-\tserialised := ka.curve.Marshal(mx, my)\n+\tserialized := ka.curve.Marshal(mx, my)\n \n \tckx := new(clientKeyExchangeMsg)\n-\tckx.ciphertext = make([]byte, 1+len(serialised))\n-\tckx.ciphertext[0] = byte(len(serialised))\n-\tcopy(ckx.ciphertext[1:], serialised)\n+\tckx.ciphertext = make([]byte, 1+len(serialized))\n+\tckx.ciphertext[0] = byte(len(serialized))\n+\tcopy(ckx.ciphertext[1:], serialized)\n \n \treturn preMasterSecret, ckx, nil\n }"}, {"sha": "4f0859fee64ab564240607a8d2f3cbc74f214692", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -147,19 +147,19 @@ func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (cert Certificate, err os.Err\n \t}\n \n \tif len(cert.Certificate) == 0 {\n-\t\terr = os.ErrorString(\"crypto/tls: failed to parse certificate PEM data\")\n+\t\terr = os.NewError(\"crypto/tls: failed to parse certificate PEM data\")\n \t\treturn\n \t}\n \n \tkeyDERBlock, _ := pem.Decode(keyPEMBlock)\n \tif keyDERBlock == nil {\n-\t\terr = os.ErrorString(\"crypto/tls: failed to parse key PEM data\")\n+\t\terr = os.NewError(\"crypto/tls: failed to parse key PEM data\")\n \t\treturn\n \t}\n \n \tkey, err := x509.ParsePKCS1PrivateKey(keyDERBlock.Bytes)\n \tif err != nil {\n-\t\terr = os.ErrorString(\"crypto/tls: failed to parse key\")\n+\t\terr = os.NewError(\"crypto/tls: failed to parse key: \" + err.String())\n \t\treturn\n \t}\n \n@@ -173,7 +173,7 @@ func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (cert Certificate, err os.Err\n \t}\n \n \tif x509Cert.PublicKeyAlgorithm != x509.RSA || x509Cert.PublicKey.(*rsa.PublicKey).N.Cmp(key.PublicKey.N) != 0 {\n-\t\terr = os.ErrorString(\"crypto/tls: private key does not match public key\")\n+\t\terr = os.NewError(\"crypto/tls: private key does not match public key\")\n \t\treturn\n \t}\n "}, {"sha": "2e537c606118c89c2e3e07f3d63fc56b0ff6b2f5", "filename": "libgo/go/crypto/twofish/twofish.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -116,7 +116,7 @@ func (c *Cipher) Reset() {\n \t\tc.k[i] = 0\n \t}\n \tfor i := range c.s {\n-\t\tfor j := 0; j < 265; j++ {\n+\t\tfor j := 0; j < 256; j++ {\n \t\t\tc.s[i][j] = 0\n \t\t}\n \t}\n@@ -269,7 +269,7 @@ func h(in, key []byte, offset int) uint32 {\n // Encrypt encrypts a 16-byte block from src to dst, which may overlap.\n // Note that for amounts of data larger than a block,\n // it is not safe to just call Encrypt on successive blocks;\n-// instead, use an encryption mode like CBC (see crypto/block/cbc.go).\n+// instead, use an encryption mode like CBC (see crypto/cipher/cbc.go).\n func (c *Cipher) Encrypt(dst, src []byte) {\n \tS1 := c.s[0]\n \tS2 := c.s[1]"}, {"sha": "16cd92efc3be71e76cfd4eee18f535bdb6ec0ff6", "filename": "libgo/go/crypto/x509/cert_pool.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -5,6 +5,7 @@\n package x509\n \n import (\n+\t\"crypto/x509/pkix\"\n \t\"encoding/pem\"\n \t\"strings\"\n )\n@@ -25,7 +26,7 @@ func NewCertPool() *CertPool {\n \t}\n }\n \n-func nameToKey(name *Name) string {\n+func nameToKey(name *pkix.Name) string {\n \treturn strings.Join(name.Country, \",\") + \"/\" + strings.Join(name.Organization, \",\") + \"/\" + strings.Join(name.OrganizationalUnit, \",\") + \"/\" + name.CommonName\n }\n "}, {"sha": "266fd557a52c98af090341b5a7c6e10ea35dc9be", "filename": "libgo/go/crypto/x509/pkix/pkix.go", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -0,0 +1,167 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package pkix contains shared, low level structures used for ASN.1 parsing\n+// and serialization of X.509 certificates, CRL and OCSP.\n+package pkix\n+\n+import (\n+\t\"asn1\"\n+\t\"big\"\n+\t\"time\"\n+)\n+\n+// AlgorithmIdentifier represents the ASN.1 structure of the same name. See RFC\n+// 5280, section 4.1.1.2.\n+type AlgorithmIdentifier struct {\n+\tAlgorithm  asn1.ObjectIdentifier\n+\tParameters asn1.RawValue `asn1:\"optional\"`\n+}\n+\n+type RDNSequence []RelativeDistinguishedNameSET\n+\n+type RelativeDistinguishedNameSET []AttributeTypeAndValue\n+\n+type AttributeTypeAndValue struct {\n+\tType  asn1.ObjectIdentifier\n+\tValue interface{}\n+}\n+\n+// Extension represents the ASN.1 structure of the same name. See RFC\n+// 5280, section 4.2.\n+type Extension struct {\n+\tId       asn1.ObjectIdentifier\n+\tCritical bool `asn1:\"optional\"`\n+\tValue    []byte\n+}\n+\n+// Name represents an X.509 distinguished name. This only includes the common\n+// elements of a DN.  Additional elements in the name are ignored.\n+type Name struct {\n+\tCountry, Organization, OrganizationalUnit []string\n+\tLocality, Province                        []string\n+\tStreetAddress, PostalCode                 []string\n+\tSerialNumber, CommonName                  string\n+}\n+\n+func (n *Name) FillFromRDNSequence(rdns *RDNSequence) {\n+\tfor _, rdn := range *rdns {\n+\t\tif len(rdn) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tatv := rdn[0]\n+\t\tvalue, ok := atv.Value.(string)\n+\t\tif !ok {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tt := atv.Type\n+\t\tif len(t) == 4 && t[0] == 2 && t[1] == 5 && t[2] == 4 {\n+\t\t\tswitch t[3] {\n+\t\t\tcase 3:\n+\t\t\t\tn.CommonName = value\n+\t\t\tcase 5:\n+\t\t\t\tn.SerialNumber = value\n+\t\t\tcase 6:\n+\t\t\t\tn.Country = append(n.Country, value)\n+\t\t\tcase 7:\n+\t\t\t\tn.Locality = append(n.Locality, value)\n+\t\t\tcase 8:\n+\t\t\t\tn.Province = append(n.Province, value)\n+\t\t\tcase 9:\n+\t\t\t\tn.StreetAddress = append(n.StreetAddress, value)\n+\t\t\tcase 10:\n+\t\t\t\tn.Organization = append(n.Organization, value)\n+\t\t\tcase 11:\n+\t\t\t\tn.OrganizationalUnit = append(n.OrganizationalUnit, value)\n+\t\t\tcase 17:\n+\t\t\t\tn.PostalCode = append(n.PostalCode, value)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+var (\n+\toidCountry            = []int{2, 5, 4, 6}\n+\toidOrganization       = []int{2, 5, 4, 10}\n+\toidOrganizationalUnit = []int{2, 5, 4, 11}\n+\toidCommonName         = []int{2, 5, 4, 3}\n+\toidSerialNumber       = []int{2, 5, 4, 5}\n+\toidLocality           = []int{2, 5, 4, 7}\n+\toidProvince           = []int{2, 5, 4, 8}\n+\toidStreetAddress      = []int{2, 5, 4, 9}\n+\toidPostalCode         = []int{2, 5, 4, 17}\n+)\n+\n+// appendRDNs appends a relativeDistinguishedNameSET to the given RDNSequence\n+// and returns the new value. The relativeDistinguishedNameSET contains an\n+// attributeTypeAndValue for each of the given values. See RFC 5280, A.1, and\n+// search for AttributeTypeAndValue.\n+func appendRDNs(in RDNSequence, values []string, oid asn1.ObjectIdentifier) RDNSequence {\n+\tif len(values) == 0 {\n+\t\treturn in\n+\t}\n+\n+\ts := make([]AttributeTypeAndValue, len(values))\n+\tfor i, value := range values {\n+\t\ts[i].Type = oid\n+\t\ts[i].Value = value\n+\t}\n+\n+\treturn append(in, s)\n+}\n+\n+func (n Name) ToRDNSequence() (ret RDNSequence) {\n+\tret = appendRDNs(ret, n.Country, oidCountry)\n+\tret = appendRDNs(ret, n.Organization, oidOrganization)\n+\tret = appendRDNs(ret, n.OrganizationalUnit, oidOrganizationalUnit)\n+\tret = appendRDNs(ret, n.Locality, oidLocality)\n+\tret = appendRDNs(ret, n.Province, oidProvince)\n+\tret = appendRDNs(ret, n.StreetAddress, oidStreetAddress)\n+\tret = appendRDNs(ret, n.PostalCode, oidPostalCode)\n+\tif len(n.CommonName) > 0 {\n+\t\tret = appendRDNs(ret, []string{n.CommonName}, oidCommonName)\n+\t}\n+\tif len(n.SerialNumber) > 0 {\n+\t\tret = appendRDNs(ret, []string{n.SerialNumber}, oidSerialNumber)\n+\t}\n+\n+\treturn ret\n+}\n+\n+// CertificateList represents the ASN.1 structure of the same name. See RFC\n+// 5280, section 5.1. Use Certificate.CheckCRLSignature to verify the\n+// signature.\n+type CertificateList struct {\n+\tTBSCertList        TBSCertificateList\n+\tSignatureAlgorithm AlgorithmIdentifier\n+\tSignatureValue     asn1.BitString\n+}\n+\n+// HasExpired returns true iff currentTimeSeconds is past the expiry time of\n+// certList.\n+func (certList *CertificateList) HasExpired(currentTimeSeconds int64) bool {\n+\treturn certList.TBSCertList.NextUpdate.Seconds() <= currentTimeSeconds\n+}\n+\n+// TBSCertificateList represents the ASN.1 structure of the same name. See RFC\n+// 5280, section 5.1.\n+type TBSCertificateList struct {\n+\tRaw                 asn1.RawContent\n+\tVersion             int `asn1:\"optional,default:2\"`\n+\tSignature           AlgorithmIdentifier\n+\tIssuer              RDNSequence\n+\tThisUpdate          *time.Time\n+\tNextUpdate          *time.Time\n+\tRevokedCertificates []RevokedCertificate `asn1:\"optional\"`\n+\tExtensions          []Extension          `asn1:\"tag:0,optional,explicit\"`\n+}\n+\n+// RevokedCertificate represents the ASN.1 structure of the same name. See RFC\n+// 5280, section 5.1.\n+type RevokedCertificate struct {\n+\tSerialNumber   *big.Int\n+\tRevocationTime *time.Time\n+\tExtensions     []Extension `asn1:\"optional\"`\n+}"}, {"sha": "4c0fecccbdf77a11978b48529e260c64081fde93", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -62,7 +62,6 @@ func (h HostnameError) String() string {\n \treturn \"certificate is valid for \" + valid + \", not \" + h.Host\n }\n \n-\n // UnknownAuthorityError results when the certificate issuer is unknown\n type UnknownAuthorityError struct {\n \tcert *Certificate\n@@ -171,8 +170,14 @@ func (c *Certificate) buildChains(cache map[int][][]*Certificate, currentChain [\n \t\tchains = append(chains, appendToFreshChain(currentChain, root))\n \t}\n \n+nextIntermediate:\n \tfor _, intermediateNum := range opts.Intermediates.findVerifiedParents(c) {\n \t\tintermediate := opts.Intermediates.certs[intermediateNum]\n+\t\tfor _, cert := range currentChain {\n+\t\t\tif cert == intermediate {\n+\t\t\t\tcontinue nextIntermediate\n+\t\t\t}\n+\t\t}\n \t\terr = intermediate.isValid(intermediateCertificate, opts)\n \t\tif err != nil {\n \t\t\tcontinue\n@@ -202,8 +207,8 @@ func matchHostnames(pattern, host string) bool {\n \t\treturn false\n \t}\n \n-\tpatternParts := strings.Split(pattern, \".\", -1)\n-\thostParts := strings.Split(host, \".\", -1)\n+\tpatternParts := strings.Split(pattern, \".\")\n+\thostParts := strings.Split(host, \".\")\n \n \tif len(patternParts) != len(hostParts) {\n \t\treturn false"}, {"sha": "111f60eb1141d9745c4a5370e7a715f129c890c2", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -72,23 +72,24 @@ var verifyTests = []verifyTest{\n \t\t},\n \t},\n \t{\n-\t\tleaf:          googleLeaf,\n-\t\tintermediates: []string{verisignRoot, thawteIntermediate},\n-\t\troots:         []string{verisignRoot},\n+\t\tleaf:          dnssecExpLeaf,\n+\t\tintermediates: []string{startComIntermediate},\n+\t\troots:         []string{startComRoot},\n \t\tcurrentTime:   1302726541,\n \n \t\texpectedChains: [][]string{\n-\t\t\t[]string{\"Google\", \"Thawte\", \"VeriSign\"},\n+\t\t\t[]string{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\"},\n \t\t},\n \t},\n \t{\n \t\tleaf:          dnssecExpLeaf,\n-\t\tintermediates: []string{startComIntermediate},\n+\t\tintermediates: []string{startComIntermediate, startComRoot},\n \t\troots:         []string{startComRoot},\n \t\tcurrentTime:   1302726541,\n \n \t\texpectedChains: [][]string{\n \t\t\t[]string{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\"},\n+\t\t\t[]string{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\", \"StartCom Certification Authority\"},\n \t\t},\n \t},\n }\n@@ -120,7 +121,7 @@ func expectAuthorityUnknown(t *testing.T, i int, err os.Error) (ok bool) {\n func certificateFromPEM(pemBytes string) (*Certificate, os.Error) {\n \tblock, _ := pem.Decode([]byte(pemBytes))\n \tif block == nil {\n-\t\treturn nil, os.ErrorString(\"failed to decode PEM\")\n+\t\treturn nil, os.NewError(\"failed to decode PEM\")\n \t}\n \treturn ParseCertificate(block.Bytes)\n }"}, {"sha": "8fda4715927ad02251227ab0ee4ddec79528dcd9", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 304, "deletions": 248, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -9,11 +9,12 @@ import (\n \t\"asn1\"\n \t\"big\"\n \t\"bytes\"\n-\t\"container/vector\"\n \t\"crypto\"\n+\t\"crypto/dsa\"\n \t\"crypto/rsa\"\n \t\"crypto/sha1\"\n-\t\"hash\"\n+\t\"crypto/x509/pkix\"\n+\t\"encoding/pem\"\n \t\"io\"\n \t\"os\"\n \t\"time\"\n@@ -22,30 +23,25 @@ import (\n // pkcs1PrivateKey is a structure which mirrors the PKCS#1 ASN.1 for an RSA private key.\n type pkcs1PrivateKey struct {\n \tVersion int\n-\tN       asn1.RawValue\n+\tN       *big.Int\n \tE       int\n-\tD       asn1.RawValue\n-\tP       asn1.RawValue\n-\tQ       asn1.RawValue\n+\tD       *big.Int\n+\tP       *big.Int\n+\tQ       *big.Int\n \t// We ignore these values, if present, because rsa will calculate them.\n-\tDp   asn1.RawValue \"optional\"\n-\tDq   asn1.RawValue \"optional\"\n-\tQinv asn1.RawValue \"optional\"\n+\tDp   *big.Int `asn1:\"optional\"`\n+\tDq   *big.Int `asn1:\"optional\"`\n+\tQinv *big.Int `asn1:\"optional\"`\n \n-\tAdditionalPrimes []pkcs1AddtionalRSAPrime \"optional\"\n+\tAdditionalPrimes []pkcs1AdditionalRSAPrime `asn1:\"optional\"`\n }\n \n-type pkcs1AddtionalRSAPrime struct {\n-\tPrime asn1.RawValue\n+type pkcs1AdditionalRSAPrime struct {\n+\tPrime *big.Int\n \n \t// We ignore these values because rsa will calculate them.\n-\tExp   asn1.RawValue\n-\tCoeff asn1.RawValue\n-}\n-\n-// rawValueIsInteger returns true iff the given ASN.1 RawValue is an INTEGER type.\n-func rawValueIsInteger(raw *asn1.RawValue) bool {\n-\treturn raw.Class == 0 && raw.Tag == 2 && raw.IsCompound == false\n+\tExp   *big.Int\n+\tCoeff *big.Int\n }\n \n // ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.\n@@ -61,32 +57,28 @@ func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err os.Error) {\n \t}\n \n \tif priv.Version > 1 {\n-\t\treturn nil, os.ErrorString(\"x509: unsupported private key version\")\n+\t\treturn nil, os.NewError(\"x509: unsupported private key version\")\n \t}\n \n-\tif !rawValueIsInteger(&priv.N) ||\n-\t\t!rawValueIsInteger(&priv.D) ||\n-\t\t!rawValueIsInteger(&priv.P) ||\n-\t\t!rawValueIsInteger(&priv.Q) {\n-\t\terr = asn1.StructuralError{\"tags don't match\"}\n-\t\treturn\n+\tif priv.N.Sign() <= 0 || priv.D.Sign() <= 0 || priv.P.Sign() <= 0 || priv.Q.Sign() <= 0 {\n+\t\treturn nil, os.NewError(\"private key contains zero or negative value\")\n \t}\n \n \tkey = new(rsa.PrivateKey)\n \tkey.PublicKey = rsa.PublicKey{\n \t\tE: priv.E,\n-\t\tN: new(big.Int).SetBytes(priv.N.Bytes),\n+\t\tN: priv.N,\n \t}\n \n-\tkey.D = new(big.Int).SetBytes(priv.D.Bytes)\n+\tkey.D = priv.D\n \tkey.Primes = make([]*big.Int, 2+len(priv.AdditionalPrimes))\n-\tkey.Primes[0] = new(big.Int).SetBytes(priv.P.Bytes)\n-\tkey.Primes[1] = new(big.Int).SetBytes(priv.Q.Bytes)\n+\tkey.Primes[0] = priv.P\n+\tkey.Primes[1] = priv.Q\n \tfor i, a := range priv.AdditionalPrimes {\n-\t\tif !rawValueIsInteger(&a.Prime) {\n-\t\t\treturn nil, asn1.StructuralError{\"tags don't match\"}\n+\t\tif a.Prime.Sign() <= 0 {\n+\t\t\treturn nil, os.NewError(\"private key contains zero or negative prime\")\n \t\t}\n-\t\tkey.Primes[i+2] = new(big.Int).SetBytes(a.Prime.Bytes)\n+\t\tkey.Primes[i+2] = a.Prime\n \t\t// We ignore the other two values because rsa will calculate\n \t\t// them as needed.\n \t}\n@@ -100,19 +92,6 @@ func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err os.Error) {\n \treturn\n }\n \n-// rawValueForBig returns an asn1.RawValue which represents the given integer.\n-func rawValueForBig(n *big.Int) asn1.RawValue {\n-\tb := n.Bytes()\n-\tif n.Sign() >= 0 && len(b) > 0 && b[0]&0x80 != 0 {\n-\t\t// This positive number would be interpreted as a negative\n-\t\t// number in ASN.1 because the MSB is set.\n-\t\tpadded := make([]byte, len(b)+1)\n-\t\tcopy(padded[1:], b)\n-\t\tb = padded\n-\t}\n-\treturn asn1.RawValue{Tag: 2, Bytes: b}\n-}\n-\n // MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.\n func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte {\n \tkey.Precompute()\n@@ -124,21 +103,21 @@ func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte {\n \n \tpriv := pkcs1PrivateKey{\n \t\tVersion: version,\n-\t\tN:       rawValueForBig(key.N),\n+\t\tN:       key.N,\n \t\tE:       key.PublicKey.E,\n-\t\tD:       rawValueForBig(key.D),\n-\t\tP:       rawValueForBig(key.Primes[0]),\n-\t\tQ:       rawValueForBig(key.Primes[1]),\n-\t\tDp:      rawValueForBig(key.Precomputed.Dp),\n-\t\tDq:      rawValueForBig(key.Precomputed.Dq),\n-\t\tQinv:    rawValueForBig(key.Precomputed.Qinv),\n+\t\tD:       key.D,\n+\t\tP:       key.Primes[0],\n+\t\tQ:       key.Primes[1],\n+\t\tDp:      key.Precomputed.Dp,\n+\t\tDq:      key.Precomputed.Dq,\n+\t\tQinv:    key.Precomputed.Qinv,\n \t}\n \n-\tpriv.AdditionalPrimes = make([]pkcs1AddtionalRSAPrime, len(key.Precomputed.CRTValues))\n+\tpriv.AdditionalPrimes = make([]pkcs1AdditionalRSAPrime, len(key.Precomputed.CRTValues))\n \tfor i, values := range key.Precomputed.CRTValues {\n-\t\tpriv.AdditionalPrimes[i].Prime = rawValueForBig(key.Primes[2+i])\n-\t\tpriv.AdditionalPrimes[i].Exp = rawValueForBig(values.Exp)\n-\t\tpriv.AdditionalPrimes[i].Coeff = rawValueForBig(values.Coeff)\n+\t\tpriv.AdditionalPrimes[i].Prime = key.Primes[2+i]\n+\t\tpriv.AdditionalPrimes[i].Exp = values.Exp\n+\t\tpriv.AdditionalPrimes[i].Coeff = values.Coeff\n \t}\n \n \tb, _ := asn1.Marshal(priv)\n@@ -150,35 +129,30 @@ func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte {\n type certificate struct {\n \tRaw                asn1.RawContent\n \tTBSCertificate     tbsCertificate\n-\tSignatureAlgorithm algorithmIdentifier\n+\tSignatureAlgorithm pkix.AlgorithmIdentifier\n \tSignatureValue     asn1.BitString\n }\n \n type tbsCertificate struct {\n \tRaw                asn1.RawContent\n-\tVersion            int \"optional,explicit,default:1,tag:0\"\n-\tSerialNumber       asn1.RawValue\n-\tSignatureAlgorithm algorithmIdentifier\n-\tIssuer             rdnSequence\n+\tVersion            int `asn1:\"optional,explicit,default:1,tag:0\"`\n+\tSerialNumber       *big.Int\n+\tSignatureAlgorithm pkix.AlgorithmIdentifier\n+\tIssuer             pkix.RDNSequence\n \tValidity           validity\n-\tSubject            rdnSequence\n+\tSubject            pkix.RDNSequence\n \tPublicKey          publicKeyInfo\n-\tUniqueId           asn1.BitString \"optional,tag:1\"\n-\tSubjectUniqueId    asn1.BitString \"optional,tag:2\"\n-\tExtensions         []extension    \"optional,explicit,tag:3\"\n+\tUniqueId           asn1.BitString   `asn1:\"optional,tag:1\"`\n+\tSubjectUniqueId    asn1.BitString   `asn1:\"optional,tag:2\"`\n+\tExtensions         []pkix.Extension `asn1:\"optional,explicit,tag:3\"`\n }\n \n-type algorithmIdentifier struct {\n-\tAlgorithm asn1.ObjectIdentifier\n+type dsaAlgorithmParameters struct {\n+\tP, Q, G *big.Int\n }\n \n-type rdnSequence []relativeDistinguishedNameSET\n-\n-type relativeDistinguishedNameSET []attributeTypeAndValue\n-\n-type attributeTypeAndValue struct {\n-\tType  asn1.ObjectIdentifier\n-\tValue interface{}\n+type dsaSignature struct {\n+\tR, S *big.Int\n }\n \n type validity struct {\n@@ -187,19 +161,13 @@ type validity struct {\n \n type publicKeyInfo struct {\n \tRaw       asn1.RawContent\n-\tAlgorithm algorithmIdentifier\n+\tAlgorithm pkix.AlgorithmIdentifier\n \tPublicKey asn1.BitString\n }\n \n-type extension struct {\n-\tId       asn1.ObjectIdentifier\n-\tCritical bool \"optional\"\n-\tValue    []byte\n-}\n-\n // RFC 5280,  4.2.1.1\n type authKeyId struct {\n-\tId []byte \"optional,tag:0\"\n+\tId []byte `asn1:\"optional,tag:0\"`\n }\n \n type SignatureAlgorithm int\n@@ -212,140 +180,105 @@ const (\n \tSHA256WithRSA\n \tSHA384WithRSA\n \tSHA512WithRSA\n+\tDSAWithSHA1\n+\tDSAWithSHA256\n )\n \n type PublicKeyAlgorithm int\n \n const (\n \tUnknownPublicKeyAlgorithm PublicKeyAlgorithm = iota\n \tRSA\n+\tDSA\n )\n \n-// Name represents an X.509 distinguished name. This only includes the common\n-// elements of a DN.  Additional elements in the name are ignored.\n-type Name struct {\n-\tCountry, Organization, OrganizationalUnit []string\n-\tLocality, Province                        []string\n-\tStreetAddress, PostalCode                 []string\n-\tSerialNumber, CommonName                  string\n-}\n-\n-func (n *Name) fillFromRDNSequence(rdns *rdnSequence) {\n-\tfor _, rdn := range *rdns {\n-\t\tif len(rdn) == 0 {\n-\t\t\tcontinue\n-\t\t}\n-\t\tatv := rdn[0]\n-\t\tvalue, ok := atv.Value.(string)\n-\t\tif !ok {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tt := atv.Type\n-\t\tif len(t) == 4 && t[0] == 2 && t[1] == 5 && t[2] == 4 {\n-\t\t\tswitch t[3] {\n-\t\t\tcase 3:\n-\t\t\t\tn.CommonName = value\n-\t\t\tcase 5:\n-\t\t\t\tn.SerialNumber = value\n-\t\t\tcase 6:\n-\t\t\t\tn.Country = append(n.Country, value)\n-\t\t\tcase 7:\n-\t\t\t\tn.Locality = append(n.Locality, value)\n-\t\t\tcase 8:\n-\t\t\t\tn.Province = append(n.Province, value)\n-\t\t\tcase 9:\n-\t\t\t\tn.StreetAddress = append(n.StreetAddress, value)\n-\t\t\tcase 10:\n-\t\t\t\tn.Organization = append(n.Organization, value)\n-\t\t\tcase 11:\n-\t\t\t\tn.OrganizationalUnit = append(n.OrganizationalUnit, value)\n-\t\t\tcase 17:\n-\t\t\t\tn.PostalCode = append(n.PostalCode, value)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n+// OIDs for signature algorithms\n+//\n+// pkcs-1 OBJECT IDENTIFIER ::= {\n+//    iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1 }\n+// \n+// \n+// RFC 3279 2.2.1 RSA Signature Algorithms\n+//\n+// md2WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 2 }\n+//\n+// md5WithRSAEncryption OBJECT IDENTIFER ::= { pkcs-1 4 }\n+//\n+// sha-1WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 5 }\n+// \n+// dsaWithSha1 OBJECT IDENTIFIER ::= {\n+//    iso(1) member-body(2) us(840) x9-57(10040) x9cm(4) 3 } \n+//\n+//\n+// RFC 4055 5 PKCS #1 Version 1.5\n+// \n+// sha256WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 11 }\n+//\n+// sha384WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 12 }\n+//\n+// sha512WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 13 }\n+//\n+//\n+// RFC 5758 3.1 DSA Signature Algorithms\n+//\n+// dsaWithSha356 OBJECT IDENTIFER ::= {\n+//    joint-iso-ccitt(2) country(16) us(840) organization(1) gov(101)\n+//    algorithms(4) id-dsa-with-sha2(3) 2}\n+//\n var (\n-\toidCountry            = []int{2, 5, 4, 6}\n-\toidOrganization       = []int{2, 5, 4, 10}\n-\toidOrganizationalUnit = []int{2, 5, 4, 11}\n-\toidCommonName         = []int{2, 5, 4, 3}\n-\toidSerialNumber       = []int{2, 5, 4, 5}\n-\toidLocatity           = []int{2, 5, 4, 7}\n-\toidProvince           = []int{2, 5, 4, 8}\n-\toidStreetAddress      = []int{2, 5, 4, 9}\n-\toidPostalCode         = []int{2, 5, 4, 17}\n+\toidSignatureMD2WithRSA    = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 2}\n+\toidSignatureMD5WithRSA    = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 4}\n+\toidSignatureSHA1WithRSA   = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 5}\n+\toidSignatureSHA256WithRSA = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 11}\n+\toidSignatureSHA384WithRSA = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 12}\n+\toidSignatureSHA512WithRSA = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 13}\n+\toidSignatureDSAWithSHA1   = asn1.ObjectIdentifier{1, 2, 840, 10040, 4, 3}\n+\toidSignatureDSAWithSHA256 = asn1.ObjectIdentifier{2, 16, 840, 1, 101, 4, 3, 2}\n )\n \n-// appendRDNs appends a relativeDistinguishedNameSET to the given rdnSequence\n-// and returns the new value. The relativeDistinguishedNameSET contains an\n-// attributeTypeAndValue for each of the given values. See RFC 5280, A.1, and\n-// search for AttributeTypeAndValue.\n-func appendRDNs(in rdnSequence, values []string, oid asn1.ObjectIdentifier) rdnSequence {\n-\tif len(values) == 0 {\n-\t\treturn in\n-\t}\n-\n-\ts := make([]attributeTypeAndValue, len(values))\n-\tfor i, value := range values {\n-\t\ts[i].Type = oid\n-\t\ts[i].Value = value\n-\t}\n-\n-\treturn append(in, s)\n-}\n-\n-func (n Name) toRDNSequence() (ret rdnSequence) {\n-\tret = appendRDNs(ret, n.Country, oidCountry)\n-\tret = appendRDNs(ret, n.Organization, oidOrganization)\n-\tret = appendRDNs(ret, n.OrganizationalUnit, oidOrganizationalUnit)\n-\tret = appendRDNs(ret, n.Locality, oidLocatity)\n-\tret = appendRDNs(ret, n.Province, oidProvince)\n-\tret = appendRDNs(ret, n.StreetAddress, oidStreetAddress)\n-\tret = appendRDNs(ret, n.PostalCode, oidPostalCode)\n-\tif len(n.CommonName) > 0 {\n-\t\tret = appendRDNs(ret, []string{n.CommonName}, oidCommonName)\n-\t}\n-\tif len(n.SerialNumber) > 0 {\n-\t\tret = appendRDNs(ret, []string{n.SerialNumber}, oidSerialNumber)\n-\t}\n-\n-\treturn ret\n-}\n-\n-func getSignatureAlgorithmFromOID(oid []int) SignatureAlgorithm {\n-\tif len(oid) == 7 && oid[0] == 1 && oid[1] == 2 && oid[2] == 840 &&\n-\t\toid[3] == 113549 && oid[4] == 1 && oid[5] == 1 {\n-\t\tswitch oid[6] {\n-\t\tcase 2:\n-\t\t\treturn MD2WithRSA\n-\t\tcase 4:\n-\t\t\treturn MD5WithRSA\n-\t\tcase 5:\n-\t\t\treturn SHA1WithRSA\n-\t\tcase 11:\n-\t\t\treturn SHA256WithRSA\n-\t\tcase 12:\n-\t\t\treturn SHA384WithRSA\n-\t\tcase 13:\n-\t\t\treturn SHA512WithRSA\n-\t\t}\n+func getSignatureAlgorithmFromOID(oid asn1.ObjectIdentifier) SignatureAlgorithm {\n+\tswitch {\n+\tcase oid.Equal(oidSignatureMD2WithRSA):\n+\t\treturn MD2WithRSA\n+\tcase oid.Equal(oidSignatureMD5WithRSA):\n+\t\treturn MD5WithRSA\n+\tcase oid.Equal(oidSignatureSHA1WithRSA):\n+\t\treturn SHA1WithRSA\n+\tcase oid.Equal(oidSignatureSHA256WithRSA):\n+\t\treturn SHA256WithRSA\n+\tcase oid.Equal(oidSignatureSHA384WithRSA):\n+\t\treturn SHA384WithRSA\n+\tcase oid.Equal(oidSignatureSHA512WithRSA):\n+\t\treturn SHA512WithRSA\n+\tcase oid.Equal(oidSignatureDSAWithSHA1):\n+\t\treturn DSAWithSHA1\n+\tcase oid.Equal(oidSignatureDSAWithSHA256):\n+\t\treturn DSAWithSHA256\n \t}\n-\n \treturn UnknownSignatureAlgorithm\n }\n \n-func getPublicKeyAlgorithmFromOID(oid []int) PublicKeyAlgorithm {\n-\tif len(oid) == 7 && oid[0] == 1 && oid[1] == 2 && oid[2] == 840 &&\n-\t\toid[3] == 113549 && oid[4] == 1 && oid[5] == 1 {\n-\t\tswitch oid[6] {\n-\t\tcase 1:\n-\t\t\treturn RSA\n-\t\t}\n-\t}\n+// RFC 3279, 2.3 Public Key Algorithms\n+//\n+// pkcs-1 OBJECT IDENTIFIER ::== { iso(1) member-body(2) us(840)\n+//    rsadsi(113549) pkcs(1) 1 }\n+//\n+// rsaEncryption OBJECT IDENTIFIER ::== { pkcs1-1 1 }\n+//\n+// id-dsa OBJECT IDENTIFIER ::== { iso(1) member-body(2) us(840)\n+//    x9-57(10040) x9cm(4) 1 }\n+var (\n+\toidPublicKeyRsa = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 1}\n+\toidPublicKeyDsa = asn1.ObjectIdentifier{1, 2, 840, 10040, 4, 1}\n+)\n \n+func getPublicKeyAlgorithmFromOID(oid asn1.ObjectIdentifier) PublicKeyAlgorithm {\n+\tswitch {\n+\tcase oid.Equal(oidPublicKeyRsa):\n+\t\treturn RSA\n+\tcase oid.Equal(oidPublicKeyDsa):\n+\t\treturn DSA\n+\t}\n \treturn UnknownPublicKeyAlgorithm\n }\n \n@@ -414,9 +347,9 @@ type Certificate struct {\n \tPublicKey          interface{}\n \n \tVersion             int\n-\tSerialNumber        []byte\n-\tIssuer              Name\n-\tSubject             Name\n+\tSerialNumber        *big.Int\n+\tIssuer              pkix.Name\n+\tSubject             pkix.Name\n \tNotBefore, NotAfter *time.Time // Validity bounds.\n \tKeyUsage            KeyUsage\n \n@@ -485,26 +418,58 @@ func (c *Certificate) CheckSignatureFrom(parent *Certificate) (err os.Error) {\n \n \t// TODO(agl): don't ignore the path length constraint.\n \n-\tvar h hash.Hash\n+\treturn parent.CheckSignature(c.SignatureAlgorithm, c.RawTBSCertificate, c.Signature)\n+}\n+\n+// CheckSignature verifies that signature is a valid signature over signed from\n+// c's public key.\n+func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature []byte) (err os.Error) {\n \tvar hashType crypto.Hash\n \n-\tswitch c.SignatureAlgorithm {\n-\tcase SHA1WithRSA:\n-\t\th = sha1.New()\n+\tswitch algo {\n+\tcase SHA1WithRSA, DSAWithSHA1:\n \t\thashType = crypto.SHA1\n+\tcase SHA256WithRSA, DSAWithSHA256:\n+\t\thashType = crypto.SHA256\n+\tcase SHA384WithRSA:\n+\t\thashType = crypto.SHA384\n+\tcase SHA512WithRSA:\n+\t\thashType = crypto.SHA512\n \tdefault:\n \t\treturn UnsupportedAlgorithmError{}\n \t}\n \n-\tpub, ok := parent.PublicKey.(*rsa.PublicKey)\n-\tif !ok {\n+\th := hashType.New()\n+\tif h == nil {\n \t\treturn UnsupportedAlgorithmError{}\n \t}\n \n-\th.Write(c.RawTBSCertificate)\n+\th.Write(signed)\n \tdigest := h.Sum()\n \n-\treturn rsa.VerifyPKCS1v15(pub, hashType, digest, c.Signature)\n+\tswitch pub := c.PublicKey.(type) {\n+\tcase *rsa.PublicKey:\n+\t\treturn rsa.VerifyPKCS1v15(pub, hashType, digest, signature)\n+\tcase *dsa.PublicKey:\n+\t\tdsaSig := new(dsaSignature)\n+\t\tif _, err := asn1.Unmarshal(signature, dsaSig); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif dsaSig.R.Sign() <= 0 || dsaSig.S.Sign() <= 0 {\n+\t\t\treturn os.NewError(\"DSA signature contained zero or negative values\")\n+\t\t}\n+\t\tif !dsa.Verify(pub, digest, dsaSig.R, dsaSig.S) {\n+\t\t\treturn os.NewError(\"DSA verification failure\")\n+\t\t}\n+\t\treturn\n+\t}\n+\treturn UnsupportedAlgorithmError{}\n+}\n+\n+// CheckCRLSignature checks that the signature in crl is from c.\n+func (c *Certificate) CheckCRLSignature(crl *pkix.CertificateList) (err os.Error) {\n+\talgo := getSignatureAlgorithmFromOID(crl.SignatureAlgorithm.Algorithm)\n+\treturn c.CheckSignature(algo, crl.TBSCertList.Raw, crl.SignatureValue.RightAlign())\n }\n \n type UnhandledCriticalExtension struct{}\n@@ -514,12 +479,12 @@ func (h UnhandledCriticalExtension) String() string {\n }\n \n type basicConstraints struct {\n-\tIsCA       bool \"optional\"\n-\tMaxPathLen int  \"optional\"\n+\tIsCA       bool `asn1:\"optional\"`\n+\tMaxPathLen int  `asn1:\"optional\"`\n }\n \n type rsaPublicKey struct {\n-\tN asn1.RawValue\n+\tN *big.Int\n \tE int\n }\n \n@@ -531,17 +496,18 @@ type policyInformation struct {\n \n // RFC 5280, 4.2.1.10\n type nameConstraints struct {\n-\tPermitted []generalSubtree \"optional,tag:0\"\n-\tExcluded  []generalSubtree \"optional,tag:1\"\n+\tPermitted []generalSubtree `asn1:\"optional,tag:0\"`\n+\tExcluded  []generalSubtree `asn1:\"optional,tag:1\"`\n }\n \n type generalSubtree struct {\n-\tName string \"tag:2,optional,ia5\"\n-\tMin  int    \"optional,tag:0\"\n-\tMax  int    \"optional,tag:1\"\n+\tName string `asn1:\"tag:2,optional,ia5\"`\n+\tMin  int    `asn1:\"optional,tag:0\"`\n+\tMax  int    `asn1:\"optional,tag:1\"`\n }\n \n-func parsePublicKey(algo PublicKeyAlgorithm, asn1Data []byte) (interface{}, os.Error) {\n+func parsePublicKey(algo PublicKeyAlgorithm, keyData *publicKeyInfo) (interface{}, os.Error) {\n+\tasn1Data := keyData.PublicKey.RightAlign()\n \tswitch algo {\n \tcase RSA:\n \t\tp := new(rsaPublicKey)\n@@ -550,19 +516,38 @@ func parsePublicKey(algo PublicKeyAlgorithm, asn1Data []byte) (interface{}, os.E\n \t\t\treturn nil, err\n \t\t}\n \n-\t\tif !rawValueIsInteger(&p.N) {\n-\t\t\treturn nil, asn1.StructuralError{\"tags don't match\"}\n-\t\t}\n-\n \t\tpub := &rsa.PublicKey{\n \t\t\tE: p.E,\n-\t\t\tN: new(big.Int).SetBytes(p.N.Bytes),\n+\t\t\tN: p.N,\n+\t\t}\n+\t\treturn pub, nil\n+\tcase DSA:\n+\t\tvar p *big.Int\n+\t\t_, err := asn1.Unmarshal(asn1Data, &p)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tparamsData := keyData.Algorithm.Parameters.FullBytes\n+\t\tparams := new(dsaAlgorithmParameters)\n+\t\t_, err = asn1.Unmarshal(paramsData, params)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif p.Sign() <= 0 || params.P.Sign() <= 0 || params.Q.Sign() <= 0 || params.G.Sign() <= 0 {\n+\t\t\treturn nil, os.NewError(\"zero or negative DSA parameter\")\n+\t\t}\n+\t\tpub := &dsa.PublicKey{\n+\t\t\tParameters: dsa.Parameters{\n+\t\t\t\tP: params.P,\n+\t\t\t\tQ: params.Q,\n+\t\t\t\tG: params.G,\n+\t\t\t},\n+\t\t\tY: p,\n \t\t}\n \t\treturn pub, nil\n \tdefault:\n \t\treturn nil, nil\n \t}\n-\n \tpanic(\"unreachable\")\n }\n \n@@ -579,15 +564,19 @@ func parseCertificate(in *certificate) (*Certificate, os.Error) {\n \tout.PublicKeyAlgorithm =\n \t\tgetPublicKeyAlgorithmFromOID(in.TBSCertificate.PublicKey.Algorithm.Algorithm)\n \tvar err os.Error\n-\tout.PublicKey, err = parsePublicKey(out.PublicKeyAlgorithm, in.TBSCertificate.PublicKey.PublicKey.RightAlign())\n+\tout.PublicKey, err = parsePublicKey(out.PublicKeyAlgorithm, &in.TBSCertificate.PublicKey)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n+\tif in.TBSCertificate.SerialNumber.Sign() < 0 {\n+\t\treturn nil, os.NewError(\"negative serial number\")\n+\t}\n+\n \tout.Version = in.TBSCertificate.Version + 1\n-\tout.SerialNumber = in.TBSCertificate.SerialNumber.Bytes\n-\tout.Issuer.fillFromRDNSequence(&in.TBSCertificate.Issuer)\n-\tout.Subject.fillFromRDNSequence(&in.TBSCertificate.Subject)\n+\tout.SerialNumber = in.TBSCertificate.SerialNumber\n+\tout.Issuer.FillFromRDNSequence(&in.TBSCertificate.Issuer)\n+\tout.Subject.FillFromRDNSequence(&in.TBSCertificate.Subject)\n \tout.NotBefore = in.TBSCertificate.Validity.NotBefore\n \tout.NotAfter = in.TBSCertificate.Validity.NotAfter\n \n@@ -611,13 +600,13 @@ func parseCertificate(in *certificate) (*Certificate, os.Error) {\n \t\t\t\t}\n \t\t\tcase 19:\n \t\t\t\t// RFC 5280, 4.2.1.9\n-\t\t\t\tvar constriants basicConstraints\n-\t\t\t\t_, err := asn1.Unmarshal(e.Value, &constriants)\n+\t\t\t\tvar constraints basicConstraints\n+\t\t\t\t_, err := asn1.Unmarshal(e.Value, &constraints)\n \n \t\t\t\tif err == nil {\n \t\t\t\t\tout.BasicConstraintsValid = true\n-\t\t\t\t\tout.IsCA = constriants.IsCA\n-\t\t\t\t\tout.MaxPathLen = constriants.MaxPathLen\n+\t\t\t\t\tout.IsCA = constraints.IsCA\n+\t\t\t\t\tout.MaxPathLen = constraints.MaxPathLen\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\tcase 17:\n@@ -804,7 +793,7 @@ func ParseCertificate(asn1Data []byte) (*Certificate, os.Error) {\n // ParseCertificates parses one or more certificates from the given ASN.1 DER\n // data. The certificates must be concatenated with no intermediate padding.\n func ParseCertificates(asn1Data []byte) ([]*Certificate, os.Error) {\n-\tv := new(vector.Vector)\n+\tvar v []*certificate\n \n \tfor len(asn1Data) > 0 {\n \t\tcert := new(certificate)\n@@ -813,12 +802,12 @@ func ParseCertificates(asn1Data []byte) ([]*Certificate, os.Error) {\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tv.Push(cert)\n+\t\tv = append(v, cert)\n \t}\n \n-\tret := make([]*Certificate, v.Len())\n-\tfor i := 0; i < v.Len(); i++ {\n-\t\tcert, err := parseCertificate(v.At(i).(*certificate))\n+\tret := make([]*Certificate, len(v))\n+\tfor i, ci := range v {\n+\t\tcert, err := parseCertificate(ci)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -845,8 +834,8 @@ var (\n \toidExtensionNameConstraints     = []int{2, 5, 29, 30}\n )\n \n-func buildExtensions(template *Certificate) (ret []extension, err os.Error) {\n-\tret = make([]extension, 7 /* maximum number of elements. */ )\n+func buildExtensions(template *Certificate) (ret []pkix.Extension, err os.Error) {\n+\tret = make([]pkix.Extension, 7 /* maximum number of elements. */ )\n \tn := 0\n \n \tif template.KeyUsage != 0 {\n@@ -963,7 +952,7 @@ var (\n // The returned slice is the certificate in DER encoding.\n func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.PublicKey, priv *rsa.PrivateKey) (cert []byte, err os.Error) {\n \tasn1PublicKey, err := asn1.Marshal(rsaPublicKey{\n-\t\tN: asn1.RawValue{Tag: 2, Bytes: pub.N.Bytes()},\n+\t\tN: pub.N,\n \t\tE: pub.E,\n \t})\n \tif err != nil {\n@@ -982,12 +971,12 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.P\n \tencodedPublicKey := asn1.BitString{BitLength: len(asn1PublicKey) * 8, Bytes: asn1PublicKey}\n \tc := tbsCertificate{\n \t\tVersion:            2,\n-\t\tSerialNumber:       asn1.RawValue{Bytes: template.SerialNumber, Tag: 2},\n-\t\tSignatureAlgorithm: algorithmIdentifier{oidSHA1WithRSA},\n-\t\tIssuer:             parent.Subject.toRDNSequence(),\n+\t\tSerialNumber:       template.SerialNumber,\n+\t\tSignatureAlgorithm: pkix.AlgorithmIdentifier{Algorithm: oidSHA1WithRSA},\n+\t\tIssuer:             parent.Subject.ToRDNSequence(),\n \t\tValidity:           validity{template.NotBefore, template.NotAfter},\n-\t\tSubject:            template.Subject.toRDNSequence(),\n-\t\tPublicKey:          publicKeyInfo{nil, algorithmIdentifier{oidRSA}, encodedPublicKey},\n+\t\tSubject:            template.Subject.ToRDNSequence(),\n+\t\tPublicKey:          publicKeyInfo{nil, pkix.AlgorithmIdentifier{Algorithm: oidRSA}, encodedPublicKey},\n \t\tExtensions:         extensions,\n \t}\n \n@@ -1010,8 +999,75 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.P\n \tcert, err = asn1.Marshal(certificate{\n \t\tnil,\n \t\tc,\n-\t\talgorithmIdentifier{oidSHA1WithRSA},\n+\t\tpkix.AlgorithmIdentifier{Algorithm: oidSHA1WithRSA},\n \t\tasn1.BitString{Bytes: signature, BitLength: len(signature) * 8},\n \t})\n \treturn\n }\n+\n+// pemCRLPrefix is the magic string that indicates that we have a PEM encoded\n+// CRL.\n+var pemCRLPrefix = []byte(\"-----BEGIN X509 CRL\")\n+// pemType is the type of a PEM encoded CRL.\n+var pemType = \"X509 CRL\"\n+\n+// ParseCRL parses a CRL from the given bytes. It's often the case that PEM\n+// encoded CRLs will appear where they should be DER encoded, so this function\n+// will transparently handle PEM encoding as long as there isn't any leading\n+// garbage.\n+func ParseCRL(crlBytes []byte) (certList *pkix.CertificateList, err os.Error) {\n+\tif bytes.HasPrefix(crlBytes, pemCRLPrefix) {\n+\t\tblock, _ := pem.Decode(crlBytes)\n+\t\tif block != nil && block.Type == pemType {\n+\t\t\tcrlBytes = block.Bytes\n+\t\t}\n+\t}\n+\treturn ParseDERCRL(crlBytes)\n+}\n+\n+// ParseDERCRL parses a DER encoded CRL from the given bytes.\n+func ParseDERCRL(derBytes []byte) (certList *pkix.CertificateList, err os.Error) {\n+\tcertList = new(pkix.CertificateList)\n+\t_, err = asn1.Unmarshal(derBytes, certList)\n+\tif err != nil {\n+\t\tcertList = nil\n+\t}\n+\treturn\n+}\n+\n+// CreateCRL returns a DER encoded CRL, signed by this Certificate, that\n+// contains the given list of revoked certificates.\n+func (c *Certificate) CreateCRL(rand io.Reader, priv *rsa.PrivateKey, revokedCerts []pkix.RevokedCertificate, now, expiry *time.Time) (crlBytes []byte, err os.Error) {\n+\ttbsCertList := pkix.TBSCertificateList{\n+\t\tVersion: 2,\n+\t\tSignature: pkix.AlgorithmIdentifier{\n+\t\t\tAlgorithm: oidSignatureSHA1WithRSA,\n+\t\t},\n+\t\tIssuer:              c.Subject.ToRDNSequence(),\n+\t\tThisUpdate:          now,\n+\t\tNextUpdate:          expiry,\n+\t\tRevokedCertificates: revokedCerts,\n+\t}\n+\n+\ttbsCertListContents, err := asn1.Marshal(tbsCertList)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\th := sha1.New()\n+\th.Write(tbsCertListContents)\n+\tdigest := h.Sum()\n+\n+\tsignature, err := rsa.SignPKCS1v15(rand, priv, crypto.SHA1, digest)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\treturn asn1.Marshal(pkix.CertificateList{\n+\t\tTBSCertList: tbsCertList,\n+\t\tSignatureAlgorithm: pkix.AlgorithmIdentifier{\n+\t\t\tAlgorithm: oidSignatureSHA1WithRSA,\n+\t\t},\n+\t\tSignatureValue: asn1.BitString{Bytes: signature, BitLength: len(signature) * 8},\n+\t})\n+}"}, {"sha": "dc216505efe8feb668fd19c1ab616ebba5adb35f", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 186, "deletions": 2, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -7,8 +7,11 @@ package x509\n import (\n \t\"asn1\"\n \t\"big\"\n+\t\"crypto/dsa\"\n \t\"crypto/rand\"\n \t\"crypto/rsa\"\n+\t\"crypto/x509/pkix\"\n+\t\"encoding/base64\"\n \t\"encoding/hex\"\n \t\"encoding/pem\"\n \t\"testing\"\n@@ -54,6 +57,12 @@ func fromBase10(base10 string) *big.Int {\n \treturn i\n }\n \n+func bigFromHexString(s string) *big.Int {\n+\tret := new(big.Int)\n+\tret.SetString(s, 16)\n+\treturn ret\n+}\n+\n var rsaPrivateKey = &rsa.PrivateKey{\n \tPublicKey: rsa.PublicKey{\n \t\tN: bigFromString(\"9353930466774385905609975137998169297361893554149986716853295022578535724979677252958524466350471210367835187480748268864277464700638583474144061408845077\"),\n@@ -200,8 +209,8 @@ func TestCreateSelfSignedCertificate(t *testing.T) {\n \t}\n \n \ttemplate := Certificate{\n-\t\tSerialNumber: []byte{1},\n-\t\tSubject: Name{\n+\t\tSerialNumber: big.NewInt(1),\n+\t\tSubject: pkix.Name{\n \t\t\tCommonName:   \"test.example.com\",\n \t\t\tOrganization: []string{\"Acme Co\"},\n \t\t},\n@@ -245,3 +254,178 @@ func TestCreateSelfSignedCertificate(t *testing.T) {\n \t\treturn\n \t}\n }\n+\n+// Self-signed certificate using DSA with SHA1\n+var dsaCertPem = `-----BEGIN CERTIFICATE-----\n+MIIEDTCCA82gAwIBAgIJALHPghaoxeDhMAkGByqGSM44BAMweTELMAkGA1UEBhMC\n+VVMxCzAJBgNVBAgTAk5DMQ8wDQYDVQQHEwZOZXd0b24xFDASBgNVBAoTC0dvb2ds\n+ZSwgSW5jMRIwEAYDVQQDEwlKb24gQWxsaWUxIjAgBgkqhkiG9w0BCQEWE2pvbmFs\n+bGllQGdvb2dsZS5jb20wHhcNMTEwNTE0MDMwMTQ1WhcNMTEwNjEzMDMwMTQ1WjB5\n+MQswCQYDVQQGEwJVUzELMAkGA1UECBMCTkMxDzANBgNVBAcTBk5ld3RvbjEUMBIG\n+A1UEChMLR29vZ2xlLCBJbmMxEjAQBgNVBAMTCUpvbiBBbGxpZTEiMCAGCSqGSIb3\n+DQEJARYTam9uYWxsaWVAZ29vZ2xlLmNvbTCCAbcwggEsBgcqhkjOOAQBMIIBHwKB\n+gQC8hLUnQ7FpFYu4WXTj6DKvXvz8QrJkNJCVMTpKAT7uBpobk32S5RrPKXocd4gN\n+8lyGB9ggS03EVlEwXvSmO0DH2MQtke2jl9j1HLydClMf4sbx5V6TV9IFw505U1iW\n+jL7awRMgxge+FsudtJK254FjMFo03ZnOQ8ZJJ9E6AEDrlwIVAJpnBn9moyP11Ox5\n+Asc/5dnjb6dPAoGBAJFHd4KVv1iTVCvEG6gGiYop5DJh28hUQcN9kul+2A0yPUSC\n+X93oN00P8Vh3eYgSaCWZsha7zDG53MrVJ0Zf6v/X/CoZNhLldeNOepivTRAzn+Rz\n+kKUYy5l1sxYLHQKF0UGNCXfFKZT0PCmgU+PWhYNBBMn6/cIh44vp85ideo5CA4GE\n+AAKBgFmifCafzeRaohYKXJgMGSEaggCVCRq5xdyDCat+wbOkjC4mfG01/um3G8u5\n+LxasjlWRKTR/tcAL7t0QuokVyQaYdVypZXNaMtx1db7YBuHjj3aP+8JOQRI9xz8c\n+bp5NDJ5pISiFOv4p3GZfqZPcqckDt78AtkQrmnal2txhhjF6o4HeMIHbMB0GA1Ud\n+DgQWBBQVyyr7hO11ZFFpWX50298Sa3V+rzCBqwYDVR0jBIGjMIGggBQVyyr7hO11\n+ZFFpWX50298Sa3V+r6F9pHsweTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAk5DMQ8w\n+DQYDVQQHEwZOZXd0b24xFDASBgNVBAoTC0dvb2dsZSwgSW5jMRIwEAYDVQQDEwlK\n+b24gQWxsaWUxIjAgBgkqhkiG9w0BCQEWE2pvbmFsbGllQGdvb2dsZS5jb22CCQCx\n+z4IWqMXg4TAMBgNVHRMEBTADAQH/MAkGByqGSM44BAMDLwAwLAIUPtn/5j8Q1jJI\n+7ggOIsgrhgUdjGQCFCsmDq1H11q9+9Wp9IMeGrTSKHIM\n+-----END CERTIFICATE-----\n+`\n+\n+func TestParseCertificateWithDsaPublicKey(t *testing.T) {\n+\texpectedKey := &dsa.PublicKey{\n+\t\tParameters: dsa.Parameters{\n+\t\t\tP: bigFromHexString(\"00BC84B52743B169158BB85974E3E832AF5EFCFC42B264349095313A4A013EEE069A1B937D92E51ACF297A1C77880DF25C8607D8204B4DC45651305EF4A63B40C7D8C42D91EDA397D8F51CBC9D0A531FE2C6F1E55E9357D205C39D395358968CBEDAC11320C607BE16CB9DB492B6E78163305A34DD99CE43C64927D13A0040EB97\"),\n+\t\t\tQ: bigFromHexString(\"009A67067F66A323F5D4EC7902C73FE5D9E36FA74F\"),\n+\t\t\tG: bigFromHexString(\"009147778295BF5893542BC41BA806898A29E43261DBC85441C37D92E97ED80D323D44825FDDE8374D0FF15877798812682599B216BBCC31B9DCCAD527465FEAFFD7FC2A193612E575E34E7A98AF4D10339FE47390A518CB9975B3160B1D0285D1418D0977C52994F43C29A053E3D685834104C9FAFDC221E38BE9F3989D7A8E42\"),\n+\t\t},\n+\t\tY: bigFromHexString(\"59A27C269FCDE45AA2160A5C980C19211A820095091AB9C5DC8309AB7EC1B3A48C2E267C6D35FEE9B71BCBB92F16AC8E559129347FB5C00BEEDD10BA8915C90698755CA965735A32DC7575BED806E1E38F768FFBC24E41123DC73F1C6E9E4D0C9E692128853AFE29DC665FA993DCA9C903B7BF00B6442B9A76A5DADC6186317A\"),\n+\t}\n+\tpemBlock, _ := pem.Decode([]byte(dsaCertPem))\n+\tcert, err := ParseCertificate(pemBlock.Bytes)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to parse certificate: %s\", err)\n+\t}\n+\tif cert.PublicKeyAlgorithm != DSA {\n+\t\tt.Errorf(\"Parsed key algorithm was not DSA\")\n+\t}\n+\tparsedKey, ok := cert.PublicKey.(*dsa.PublicKey)\n+\tif !ok {\n+\t\tt.Fatalf(\"Parsed key was not a DSA key: %s\", err)\n+\t}\n+\tif expectedKey.Y.Cmp(parsedKey.Y) != 0 ||\n+\t\texpectedKey.P.Cmp(parsedKey.P) != 0 ||\n+\t\texpectedKey.Q.Cmp(parsedKey.Q) != 0 ||\n+\t\texpectedKey.G.Cmp(parsedKey.G) != 0 {\n+\t\tt.Fatal(\"Parsed key differs from expected key\")\n+\t}\n+}\n+\n+func TestParseCertificateWithDSASignatureAlgorithm(t *testing.T) {\n+\tpemBlock, _ := pem.Decode([]byte(dsaCertPem))\n+\tcert, err := ParseCertificate(pemBlock.Bytes)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to parse certificate: %s\", err)\n+\t}\n+\tif cert.SignatureAlgorithm != DSAWithSHA1 {\n+\t\tt.Errorf(\"Parsed signature algorithm was not DSAWithSHA1\")\n+\t}\n+}\n+\n+func TestVerifyCertificateWithDSASignature(t *testing.T) {\n+\tpemBlock, _ := pem.Decode([]byte(dsaCertPem))\n+\tcert, err := ParseCertificate(pemBlock.Bytes)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to parse certificate: %s\", err)\n+\t}\n+\t// test cert is self-signed\n+\tif err = cert.CheckSignatureFrom(cert); err != nil {\n+\t\tt.Fatalf(\"DSA Certificate verfication failed: %s\", err)\n+\t}\n+}\n+\n+const pemCertificate = `-----BEGIN CERTIFICATE-----\n+MIIB5DCCAZCgAwIBAgIBATALBgkqhkiG9w0BAQUwLTEQMA4GA1UEChMHQWNtZSBDbzEZMBcGA1UE\n+AxMQdGVzdC5leGFtcGxlLmNvbTAeFw03MDAxMDEwMDE2NDBaFw03MDAxMDIwMzQ2NDBaMC0xEDAO\n+BgNVBAoTB0FjbWUgQ28xGTAXBgNVBAMTEHRlc3QuZXhhbXBsZS5jb20wWjALBgkqhkiG9w0BAQED\n+SwAwSAJBALKZD0nEffqM1ACuak0bijtqE2QrI/KLADv7l3kK3ppMyCuLKoF0fd7Ai2KW5ToIwzFo\n+fvJcS/STa6HA5gQenRUCAwEAAaOBnjCBmzAOBgNVHQ8BAf8EBAMCAAQwDwYDVR0TAQH/BAUwAwEB\n+/zANBgNVHQ4EBgQEAQIDBDAPBgNVHSMECDAGgAQBAgMEMBsGA1UdEQQUMBKCEHRlc3QuZXhhbXBs\n+ZS5jb20wDwYDVR0gBAgwBjAEBgIqAzAqBgNVHR4EIzAhoB8wDoIMLmV4YW1wbGUuY29tMA2CC2V4\n+YW1wbGUuY29tMAsGCSqGSIb3DQEBBQNBAHKZKoS1wEQOGhgklx4+/yFYQlnqwKXvar/ZecQvJwui\n+0seMQnwBhwdBkHfVIU2Fu5VUMRyxlf0ZNaDXcpU581k=\n+-----END CERTIFICATE-----`\n+\n+func TestCRLCreation(t *testing.T) {\n+\tblock, _ := pem.Decode([]byte(pemPrivateKey))\n+\tpriv, _ := ParsePKCS1PrivateKey(block.Bytes)\n+\tblock, _ = pem.Decode([]byte(pemCertificate))\n+\tcert, _ := ParseCertificate(block.Bytes)\n+\n+\tnow := time.SecondsToUTC(1000)\n+\texpiry := time.SecondsToUTC(10000)\n+\n+\trevokedCerts := []pkix.RevokedCertificate{\n+\t\t{\n+\t\t\tSerialNumber:   big.NewInt(1),\n+\t\t\tRevocationTime: now,\n+\t\t},\n+\t\t{\n+\t\t\tSerialNumber:   big.NewInt(42),\n+\t\t\tRevocationTime: now,\n+\t\t},\n+\t}\n+\n+\tcrlBytes, err := cert.CreateCRL(rand.Reader, priv, revokedCerts, now, expiry)\n+\tif err != nil {\n+\t\tt.Errorf(\"error creating CRL: %s\", err)\n+\t}\n+\n+\t_, err = ParseDERCRL(crlBytes)\n+\tif err != nil {\n+\t\tt.Errorf(\"error reparsing CRL: %s\", err)\n+\t}\n+}\n+\n+func fromBase64(in string) []byte {\n+\tout := make([]byte, base64.StdEncoding.DecodedLen(len(in)))\n+\t_, err := base64.StdEncoding.Decode(out, []byte(in))\n+\tif err != nil {\n+\t\tpanic(\"failed to base64 decode\")\n+\t}\n+\treturn out\n+}\n+\n+func TestParseDERCRL(t *testing.T) {\n+\tderBytes := fromBase64(derCRLBase64)\n+\tcertList, err := ParseDERCRL(derBytes)\n+\tif err != nil {\n+\t\tt.Errorf(\"error parsing: %s\", err)\n+\t\treturn\n+\t}\n+\tnumCerts := len(certList.TBSCertList.RevokedCertificates)\n+\texpected := 88\n+\tif numCerts != expected {\n+\t\tt.Errorf(\"bad number of revoked certificates. got: %d want: %d\", numCerts, expected)\n+\t}\n+\n+\tif certList.HasExpired(1302517272) {\n+\t\tt.Errorf(\"CRL has expired (but shouldn't have)\")\n+\t}\n+\n+\t// Can't check the signature here without a package cycle.\n+}\n+\n+func TestParsePEMCRL(t *testing.T) {\n+\tpemBytes := fromBase64(pemCRLBase64)\n+\tcertList, err := ParseCRL(pemBytes)\n+\tif err != nil {\n+\t\tt.Errorf(\"error parsing: %s\", err)\n+\t\treturn\n+\t}\n+\tnumCerts := len(certList.TBSCertList.RevokedCertificates)\n+\texpected := 2\n+\tif numCerts != expected {\n+\t\tt.Errorf(\"bad number of revoked certificates. got: %d want: %d\", numCerts, expected)\n+\t}\n+\n+\tif certList.HasExpired(1302517272) {\n+\t\tt.Errorf(\"CRL has expired (but shouldn't have)\")\n+\t}\n+\n+\t// Can't check the signature here without a package cycle.\n+}\n+\n+const derCRLBase64 = \"MIINqzCCDJMCAQEwDQYJKoZIhvcNAQEFBQAwVjEZMBcGA1UEAxMQUEtJIEZJTk1FQ0NBTklDQTEVMBMGA1UEChMMRklOTUVDQ0FOSUNBMRUwEwYDVQQLEwxGSU5NRUNDQU5JQ0ExCzAJBgNVBAYTAklUFw0xMTA1MDQxNjU3NDJaFw0xMTA1MDQyMDU3NDJaMIIMBzAhAg4Ze1od49Lt1qIXBydAzhcNMDkwNzE2MDg0MzIyWjAAMCECDl0HSL9bcZ1Ci/UHJ0DPFw0wOTA3MTYwODQzMTNaMAAwIQIOESB9tVAmX3cY7QcnQNAXDTA5MDcxNjA4NDUyMlowADAhAg4S1tGAQ3mHt8uVBydA1RcNMDkwODA0MTUyNTIyWjAAMCECDlQ249Y7vtC25ScHJ0DWFw0wOTA4MDQxNTI1MzdaMAAwIQIOISMop3NkA4PfYwcnQNkXDTA5MDgwNDExMDAzNFowADAhAg56/BMoS29KEShTBydA2hcNMDkwODA0MTEwMTAzWjAAMCECDnBp/22HPH5CSWoHJ0DbFw0wOTA4MDQxMDU0NDlaMAAwIQIOV9IP+8CD8bK+XAcnQNwXDTA5MDgwNDEwNTcxN1owADAhAg4v5aRz0IxWqYiXBydA3RcNMDkwODA0MTA1NzQ1WjAAMCECDlOU34VzvZAybQwHJ0DeFw0wOTA4MDQxMDU4MjFaMAAwIAINO4CD9lluIxcwBydBAxcNMDkwNzIyMTUzMTU5WjAAMCECDgOllfO8Y1QA7/wHJ0ExFw0wOTA3MjQxMTQxNDNaMAAwIQIOJBX7jbiCdRdyjgcnQUQXDTA5MDkxNjA5MzAwOFowADAhAg5iYSAgmDrlH/RZBydBRRcNMDkwOTE2MDkzMDE3WjAAMCECDmu6k6srP3jcMaQHJ0FRFw0wOTA4MDQxMDU2NDBaMAAwIQIOX8aHlO0V+WVH4QcnQVMXDTA5MDgwNDEwNTcyOVowADAhAg5flK2rg3NnsRgDBydBzhcNMTEwMjAxMTUzMzQ2WjAAMCECDg35yJDL1jOPTgoHJ0HPFw0xMTAyMDExNTM0MjZaMAAwIQIOMyFJ6+e9iiGVBQcnQdAXDTA5MDkxODEzMjAwNVowADAhAg5Emb/Oykucmn8fBydB1xcNMDkwOTIxMTAxMDQ3WjAAMCECDjQKCncV+MnUavMHJ0HaFw0wOTA5MjIwODE1MjZaMAAwIQIOaxiFUt3dpd+tPwcnQfQXDTEwMDYxODA4NDI1MVowADAhAg5G7P8nO0tkrMt7BydB9RcNMTAwNjE4MDg0MjMwWjAAMCECDmTCC3SXhmDRst4HJ0H2Fw0wOTA5MjgxMjA3MjBaMAAwIQIOHoGhUr/pRwzTKgcnQfcXDTA5MDkyODEyMDcyNFowADAhAg50wrcrCiw8mQmPBydCBBcNMTAwMjE2MTMwMTA2WjAAMCECDifWmkvwyhEqwEcHJ0IFFw0xMDAyMTYxMzAxMjBaMAAwIQIOfgPmlW9fg+osNgcnQhwXDTEwMDQxMzA5NTIwMFowADAhAg4YHAGuA6LgCk7tBydCHRcNMTAwNDEzMDk1MTM4WjAAMCECDi1zH1bxkNJhokAHJ0IsFw0xMDA0MTMwOTU5MzBaMAAwIQIOMipNccsb/wo2fwcnQi0XDTEwMDQxMzA5NTkwMFowADAhAg46lCmvPl4GpP6ABydCShcNMTAwMTE5MDk1MjE3WjAAMCECDjaTcaj+wBpcGAsHJ0JLFw0xMDAxMTkwOTUyMzRaMAAwIQIOOMC13EOrBuxIOQcnQloXDTEwMDIwMTA5NDcwNVowADAhAg5KmZl+krz4RsmrBydCWxcNMTAwMjAxMDk0NjQwWjAAMCECDmLG3zQJ/fzdSsUHJ0JiFw0xMDAzMDEwOTUxNDBaMAAwIQIOP39ksgHdojf4owcnQmMXDTEwMDMwMTA5NTExN1owADAhAg4LDQzvWNRlD6v9BydCZBcNMTAwMzAxMDk0NjIyWjAAMCECDkmNfeclaFhIaaUHJ0JlFw0xMDAzMDEwOTQ2MDVaMAAwIQIOT/qWWfpH/m8NTwcnQpQXDTEwMDUxMTA5MTgyMVowADAhAg5m/ksYxvCEgJSvBydClRcNMTAwNTExMDkxODAxWjAAMCECDgvf3Ohq6JOPU9AHJ0KWFw0xMDA1MTEwOTIxMjNaMAAwIQIOKSPas10z4jNVIQcnQpcXDTEwMDUxMTA5MjEwMlowADAhAg4mCWmhoZ3lyKCDBydCohcNMTEwNDI4MTEwMjI1WjAAMCECDkeiyRsBMK0Gvr4HJ0KjFw0xMTA0MjgxMTAyMDdaMAAwIQIOa09b/nH2+55SSwcnQq4XDTExMDQwMTA4Mjk0NlowADAhAg5O7M7iq7gGplr1BydCrxcNMTEwNDAxMDgzMDE3WjAAMCECDjlT6mJxUjTvyogHJ0K1Fw0xMTAxMjcxNTQ4NTJaMAAwIQIODS/l4UUFLe21NAcnQrYXDTExMDEyNzE1NDgyOFowADAhAg5lPRA0XdOUF6lSBydDHhcNMTEwMTI4MTQzNTA1WjAAMCECDixKX4fFGGpENwgHJ0MfFw0xMTAxMjgxNDM1MzBaMAAwIQIORNBkqsPnpKTtbAcnQ08XDTEwMDkwOTA4NDg0MlowADAhAg5QL+EMM3lohedEBydDUBcNMTAwOTA5MDg0ODE5WjAAMCECDlhDnHK+HiTRAXcHJ0NUFw0xMDEwMTkxNjIxNDBaMAAwIQIOdBFqAzq/INz53gcnQ1UXDTEwMTAxOTE2MjA0NFowADAhAg4OjR7s8MgKles1BydDWhcNMTEwMTI3MTY1MzM2WjAAMCECDmfR/elHee+d0SoHJ0NbFw0xMTAxMjcxNjUzNTZaMAAwIQIOBTKv2ui+KFMI+wcnQ5YXDTEwMDkxNTEwMjE1N1owADAhAg49F3c/GSah+oRUBydDmxcNMTEwMTI3MTczMjMzWjAAMCECDggv4I61WwpKFMMHJ0OcFw0xMTAxMjcxNzMyNTVaMAAwIQIOXx/Y8sEvwS10LAcnQ6UXDTExMDEyODExMjkzN1owADAhAg5LSLbnVrSKaw/9BydDphcNMTEwMTI4MTEyOTIwWjAAMCECDmFFoCuhKUeACQQHJ0PfFw0xMTAxMTExMDE3MzdaMAAwIQIOQTDdFh2fSPF6AAcnQ+AXDTExMDExMTEwMTcxMFowADAhAg5B8AOXX61FpvbbBydD5RcNMTAxMDA2MTAxNDM2WjAAMCECDh41P2Gmi7PkwI4HJ0PmFw0xMDEwMDYxMDE2MjVaMAAwIQIOWUHGLQCd+Ale9gcnQ/0XDTExMDUwMjA3NTYxMFowADAhAg5Z2c9AYkikmgWOBydD/hcNMTEwNTAyMDc1NjM0WjAAMCECDmf/UD+/h8nf+74HJ0QVFw0xMTA0MTUwNzI4MzNaMAAwIQIOICvj4epy3MrqfwcnRBYXDTExMDQxNTA3Mjg1NlowADAhAg4bouRMfOYqgv4xBydEHxcNMTEwMzA4MTYyNDI1WjAAMCECDhebWHGoKiTp7pEHJ0QgFw0xMTAzMDgxNjI0NDhaMAAwIQIOX+qnxxAqJ8LtawcnRDcXDTExMDEzMTE1MTIyOFowADAhAg4j0fICqZ+wkOdqBydEOBcNMTEwMTMxMTUxMTQxWjAAMCECDhmXjsV4SUpWtAMHJ0RLFw0xMTAxMjgxMTI0MTJaMAAwIQIODno/w+zG43kkTwcnREwXDTExMDEyODExMjM1MlowADAhAg4b1gc88767Fr+LBydETxcNMTEwMTI4MTEwMjA4WjAAMCECDn+M3Pa1w2nyFeUHJ0RQFw0xMTAxMjgxMDU4NDVaMAAwIQIOaduoyIH61tqybAcnRJUXDTEwMTIxNTA5NDMyMlowADAhAg4nLqQPkyi3ESAKBydElhcNMTAxMjE1MDk0MzM2WjAAMCECDi504NIMH8578gQHJ0SbFw0xMTAyMTQxNDA1NDFaMAAwIQIOGuaM8PDaC5u1egcnRJwXDTExMDIxNDE0MDYwNFowADAhAg4ehYq/BXGnB5PWBydEnxcNMTEwMjA0MDgwOTUxWjAAMCECDkSD4eS4FxW5H20HJ0SgFw0xMTAyMDQwODA5MjVaMAAwIQIOOCcb6ilYObt1egcnRKEXDTExMDEyNjEwNDEyOVowADAhAg58tISWCCwFnKGnBydEohcNMTEwMjA0MDgxMzQyWjAAMCECDn5rjtabY/L/WL0HJ0TJFw0xMTAyMDQxMTAzNDFaMAAwDQYJKoZIhvcNAQEFBQADggEBAGnF2Gs0+LNiYCW1Ipm83OXQYP/bd5tFFRzyz3iepFqNfYs4D68/QihjFoRHQoXEB0OEe1tvaVnnPGnEOpi6krwekquMxo4H88B5SlyiFIqemCOIss0SxlCFs69LmfRYvPPvPEhoXtQ3ZThe0UvKG83GOklhvGl6OaiRf4Mt+m8zOT4Wox/j6aOBK6cw6qKCdmD+Yj1rrNqFGg1CnSWMoD6S6mwNgkzwdBUJZ22BwrzAAo4RHa2Uy3ef1FjwD0XtU5N3uDSxGGBEDvOe5z82rps3E22FpAA8eYl8kaXtmWqyvYU0epp4brGuTxCuBMCAsxt/OjIjeNNQbBGkwxgfYA0=\"\n+\n+const pemCRLBase64 = \"LS0tLS1CRUdJTiBYNTA5IENSTC0tLS0tDQpNSUlCOWpDQ0FWOENBUUV3RFFZSktvWklodmNOQVFFRkJRQXdiREVhTUJnR0ExVUVDaE1SVWxOQklGTmxZM1Z5DQphWFI1SUVsdVl5NHhIakFjQmdOVkJBTVRGVkpUUVNCUWRXSnNhV01nVW05dmRDQkRRU0IyTVRFdU1Dd0dDU3FHDQpTSWIzRFFFSkFSWWZjbk5oYTJWdmJuSnZiM1J6YVdkdVFISnpZWE5sWTNWeWFYUjVMbU52YlJjTk1URXdNakl6DQpNVGt5T0RNd1doY05NVEV3T0RJeU1Ua3lPRE13V2pDQmpEQktBaEVBckRxb2g5RkhKSFhUN09QZ3V1bjQrQmNODQpNRGt4TVRBeU1UUXlOekE1V2pBbU1Bb0dBMVVkRlFRRENnRUpNQmdHQTFVZEdBUVJHQTh5TURBNU1URXdNakUwDQpNalExTlZvd1BnSVJBTEd6blowOTVQQjVhQU9MUGc1N2ZNTVhEVEF5TVRBeU16RTBOVEF4TkZvd0dqQVlCZ05WDQpIUmdFRVJnUE1qQXdNakV3TWpNeE5EVXdNVFJhb0RBd0xqQWZCZ05WSFNNRUdEQVdnQlQxVERGNlVRTS9MTmVMDQpsNWx2cUhHUXEzZzltekFMQmdOVkhSUUVCQUlDQUlRd0RRWUpLb1pJaHZjTkFRRUZCUUFEZ1lFQUZVNUFzNk16DQpxNVBSc2lmYW9iUVBHaDFhSkx5QytNczVBZ2MwYld5QTNHQWR4dXI1U3BQWmVSV0NCamlQL01FSEJXSkNsQkhQDQpHUmNxNXlJZDNFakRrYUV5eFJhK2k2N0x6dmhJNmMyOUVlNks5cFNZd2ppLzdSVWhtbW5Qclh0VHhsTDBsckxyDQptUVFKNnhoRFJhNUczUUE0Q21VZHNITnZicnpnbUNZcHZWRT0NCi0tLS0tRU5EIFg1MDkgQ1JMLS0tLS0NCg0K\""}, {"sha": "bf5d245992d99dfba447c1b4e52b811a7e7653a6", "filename": "libgo/go/crypto/xtea/block.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fxtea%2Fblock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fxtea%2Fblock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fxtea%2Fblock.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -22,7 +22,7 @@ func blockToUint32(src []byte) (uint32, uint32) {\n \treturn r0, r1\n }\n \n-// uint32ToBlock writes two unint32s into an 8 byte data block.\n+// uint32ToBlock writes two uint32s into an 8 byte data block.\n // Values are written as big endian.\n func uint32ToBlock(v0, v1 uint32, dst []byte) {\n \tdst[0] = byte(v0 >> 24)"}, {"sha": "b3fba3c8418fdb17b5999813ff35692e8eca6f1a", "filename": "libgo/go/crypto/xtea/cipher.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fxtea%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fxtea%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fxtea%2Fcipher.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -48,13 +48,13 @@ func NewCipher(key []byte) (*Cipher, os.Error) {\n \n // BlockSize returns the XTEA block size, 8 bytes.\n // It is necessary to satisfy the Cipher interface in the\n-// package \"crypto/block\".\n+// package \"crypto/cipher\".\n func (c *Cipher) BlockSize() int { return BlockSize }\n \n // Encrypt encrypts the 8 byte buffer src using the key and stores the result in dst.\n // Note that for amounts of data larger than a block,\n // it is not safe to just call Encrypt on successive blocks;\n-// instead, use an encryption mode like CBC (see crypto/block/cbc.go).\n+// instead, use an encryption mode like CBC (see crypto/cipher/cbc.go).\n func (c *Cipher) Encrypt(dst, src []byte) { encryptBlock(c, dst, src) }\n \n // Decrypt decrypts the 8 byte buffer src using the key k and stores the result in dst."}, {"sha": "217d96adc2099756981bbfc75a306b8a54144d30", "filename": "libgo/go/crypto/xtea/xtea_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fxtea%2Fxtea_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcrypto%2Fxtea%2Fxtea_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fxtea%2Fxtea_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -8,7 +8,7 @@ import (\n \t\"testing\"\n )\n \n-// A sample test key for when we just want to initialise a cipher\n+// A sample test key for when we just want to initialize a cipher\n var testKey = []byte{0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF}\n \n // Test that the block size for XTEA is correct\n@@ -26,12 +26,12 @@ func TestBlocksize(t *testing.T) {\n \n \tresult := c.BlockSize()\n \tif result != 8 {\n-\t\tt.Errorf(\"BlockSize function - expected 8, gotr %d\", result)\n+\t\tt.Errorf(\"BlockSize function - expected 8, got %d\", result)\n \t\treturn\n \t}\n }\n \n-// A series of test values to confirm that the Cipher.table array was initialised correctly\n+// A series of test values to confirm that the Cipher.table array was initialized correctly\n var testTable = []uint32{\n \t0x00112233, 0x6B1568B8, 0xE28CE030, 0xC5089E2D, 0xC5089E2D, 0x1EFBD3A2, 0xA7845C2A, 0x78EF0917,\n \t0x78EF0917, 0x172682D0, 0x5B6AC714, 0x822AC955, 0x3DE68511, 0xDC1DFECA, 0x2062430E, 0x3611343F,\n@@ -43,7 +43,7 @@ var testTable = []uint32{\n \t0x4E22726F, 0x309E306C, 0x309E306C, 0x8A9165E1, 0x1319EE69, 0xF595AC66, 0xF595AC66, 0x4F88E1DB,\n }\n \n-// Test that the cipher context is initialised correctly\n+// Test that the cipher context is initialized correctly\n func TestCipherInit(t *testing.T) {\n \tc, err := NewCipher(testKey)\n \tif err != nil {\n@@ -53,7 +53,7 @@ func TestCipherInit(t *testing.T) {\n \n \tfor i := 0; i < len(c.table); i++ {\n \t\tif c.table[i] != testTable[i] {\n-\t\t\tt.Errorf(\"NewCipher() failed to initialise Cipher.table[%d] correctly. Expected %08X, got %08X\", i, testTable[i], c.table[i])\n+\t\t\tt.Errorf(\"NewCipher() failed to initialize Cipher.table[%d] correctly. Expected %08X, got %08X\", i, testTable[i], c.table[i])\n \t\t\tbreak\n \t\t}\n \t}"}, {"sha": "ea2c266a47d784142c71aa625d3c20dfd92d07fe", "filename": "libgo/go/csv/reader.go", "status": "added", "additions": 372, "deletions": 0, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcsv%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcsv%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcsv%2Freader.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -0,0 +1,372 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package csv reads and writes comma-separated values (CSV) files.\n+//\n+// A csv file contains zero or more records of one or more fields per record.\n+// Each record is separated by the newline character. The final record may\n+// optionally be followed by a newline character.\n+//\n+//\tfield1,field2,field3\n+//\n+// White space is considered part of a field.\n+//\n+// Carriage returns before newline characters are silently removed.\n+//\n+// Blank lines are ignored.  A line with only whitespace characters (excluding\n+// the ending newline character) is not considered a blank line.\n+//\n+// Fields which start and stop with the quote character \" are called\n+// quoted-fields.  The beginning and ending quote are not part of the\n+// field.\n+//\n+// The source:\n+//\n+//\tnormal string,\"quoted-field\"\n+//\n+// results in the fields\n+//\n+//\t{`normal string`, `quoted-field`}\n+//\n+// Within a quoted-field a quote character followed by a second quote\n+// character is considered a single quote.\n+//\n+//\t\"the \"\"word\"\" is true\",\"a \"\"quoted-field\"\"\"\n+//\n+// results in\n+//\n+//\t{`the \"word\" is true`, `a \"quoted-field\"`}\n+//\n+// Newlines and commas may be included in a quoted-field\n+//\n+//\t\"Multi-line\n+//\tfield\",\"comma is ,\"\n+//\n+// results in\n+//\n+//\t{`Multi-line\n+//\tfield`, `comma is ,`}\n+package csv\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"unicode\"\n+)\n+\n+// A ParseError is returned for parsing errors.\n+// The first line is 1.  The first column is 0.\n+type ParseError struct {\n+\tLine   int      // Line where the error occurred\n+\tColumn int      // Column (rune index) where the error occurred\n+\tError  os.Error // The actual error\n+}\n+\n+func (e *ParseError) String() string {\n+\treturn fmt.Sprintf(\"line %d, column %d: %s\", e.Line, e.Column, e.Error)\n+}\n+\n+// These are the errors that can be returned in ParseError.Error\n+var (\n+\tErrTrailingComma = os.NewError(\"extra delimiter at end of line\")\n+\tErrBareQuote     = os.NewError(\"bare \\\" in non-quoted-field\")\n+\tErrQuote         = os.NewError(\"extraneous \\\" in field\")\n+\tErrFieldCount    = os.NewError(\"wrong number of fields in line\")\n+)\n+\n+// A Reader reads records from a CSV-encoded file.\n+//\n+// As returned by NewReader, a Reader expects input conforming to RFC 4180.\n+// The exported fields can be changed to customize the details before the\n+// first call to Read or ReadAll.\n+//\n+// Comma is the field delimiter.  It defaults to ','.\n+//\n+// Comment, if not 0, is the comment character. Lines beginning with the\n+// Comment character are ignored.\n+//\n+// If FieldsPerRecord is positive, Read requires each record to\n+// have the given number of fields.  If FieldsPerRecord is 0, Read sets it to\n+// the number of fields in the first record, so that future records must\n+// have the same field count.\n+//\n+// If LazyQuotes is true, a quote may appear in an unquoted field and a\n+// non-doubled quote may appear in a quoted field.\n+//\n+// If TrailingComma is true, the last field may be an unquoted empty field.\n+//\n+// If TrimLeadingSpace is true, leading white space in a field is ignored.\n+type Reader struct {\n+\tComma            int  // Field delimiter (set to ',' by NewReader)\n+\tComment          int  // Comment character for start of line\n+\tFieldsPerRecord  int  // Number of expected fields per record\n+\tLazyQuotes       bool // Allow lazy quotes\n+\tTrailingComma    bool // Allow trailing comma\n+\tTrimLeadingSpace bool // Trim leading space\n+\tline             int\n+\tcolumn           int\n+\tr                *bufio.Reader\n+\tfield            bytes.Buffer\n+}\n+\n+// NewReader returns a new Reader that reads from r.\n+func NewReader(r io.Reader) *Reader {\n+\treturn &Reader{\n+\t\tComma: ',',\n+\t\tr:     bufio.NewReader(r),\n+\t}\n+}\n+\n+// error creates a new ParseError based on err.\n+func (r *Reader) error(err os.Error) os.Error {\n+\treturn &ParseError{\n+\t\tLine:   r.line,\n+\t\tColumn: r.column,\n+\t\tError:  err,\n+\t}\n+}\n+\n+// Read reads one record from r.  The record is a slice of strings with each\n+// string representing one field.\n+func (r *Reader) Read() (record []string, err os.Error) {\n+\tfor {\n+\t\trecord, err = r.parseRecord()\n+\t\tif record != nil {\n+\t\t\tbreak\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tif r.FieldsPerRecord > 0 {\n+\t\tif len(record) != r.FieldsPerRecord {\n+\t\t\tr.column = 0 // report at start of record\n+\t\t\treturn record, r.error(ErrFieldCount)\n+\t\t}\n+\t} else if r.FieldsPerRecord == 0 {\n+\t\tr.FieldsPerRecord = len(record)\n+\t}\n+\treturn record, nil\n+}\n+\n+// ReadAll reads all the remaining records from r.\n+// Each record is a slice of fields.\n+func (r *Reader) ReadAll() (records [][]string, err os.Error) {\n+\tfor {\n+\t\trecord, err := r.Read()\n+\t\tif err == os.EOF {\n+\t\t\treturn records, nil\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\trecords = append(records, record)\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+// readRune reads one rune from r, folding \\r\\n to \\n and keeping track\n+// of how far into the line we have read.  r.column will point to the start\n+// of this rune, not the end of this rune.\n+func (r *Reader) readRune() (int, os.Error) {\n+\trune, _, err := r.r.ReadRune()\n+\n+\t// Handle \\r\\n here.  We make the simplifying assumption that\n+\t// anytime \\r is followed by \\n that it can be folded to \\n.\n+\t// We will not detect files which contain both \\r\\n and bare \\n.\n+\tif rune == '\\r' {\n+\t\trune, _, err = r.r.ReadRune()\n+\t\tif err == nil {\n+\t\t\tif rune != '\\n' {\n+\t\t\t\tr.r.UnreadRune()\n+\t\t\t\trune = '\\r'\n+\t\t\t}\n+\t\t}\n+\t}\n+\tr.column++\n+\treturn rune, err\n+}\n+\n+// unreadRune puts the last rune read from r back.\n+func (r *Reader) unreadRune() {\n+\tr.r.UnreadRune()\n+\tr.column--\n+}\n+\n+// skip reads runes up to and including the rune delim or until error.\n+func (r *Reader) skip(delim int) os.Error {\n+\tfor {\n+\t\trune, err := r.readRune()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif rune == delim {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+// parseRecord reads and parses a single csv record from r.\n+func (r *Reader) parseRecord() (fields []string, err os.Error) {\n+\t// Each record starts on a new line.  We increment our line\n+\t// number (lines start at 1, not 0) and set column to -1\n+\t// so as we increment in readRune it points to the character we read.\n+\tr.line++\n+\tr.column = -1\n+\n+\t// Peek at the first rune.  If it is an error we are done.\n+\t// If we are support comments and it is the comment character\n+\t// then skip to the end of line.\n+\n+\trune, _, err := r.r.ReadRune()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif r.Comment != 0 && rune == r.Comment {\n+\t\treturn nil, r.skip('\\n')\n+\t}\n+\tr.r.UnreadRune()\n+\n+\t// At this point we have at least one field.\n+\tfor {\n+\t\thaveField, delim, err := r.parseField()\n+\t\tif haveField {\n+\t\t\tfields = append(fields, r.field.String())\n+\t\t}\n+\t\tif delim == '\\n' || err == os.EOF {\n+\t\t\treturn fields, err\n+\t\t} else if err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+// parseField parses the next field in the record.  The read field is\n+// located in r.field.  Delim is the first character not part of the field\n+// (r.Comma or '\\n').\n+func (r *Reader) parseField() (haveField bool, delim int, err os.Error) {\n+\tr.field.Reset()\n+\n+\trune, err := r.readRune()\n+\tif err != nil {\n+\t\t// If we have EOF and are not at the start of a line\n+\t\t// then we return the empty field.  We have already\n+\t\t// checked for trailing commas if needed.\n+\t\tif err == os.EOF && r.column != 0 {\n+\t\t\treturn true, 0, err\n+\t\t}\n+\t\treturn false, 0, err\n+\t}\n+\n+\tif r.TrimLeadingSpace {\n+\t\tfor unicode.IsSpace(rune) {\n+\t\t\trune, err = r.readRune()\n+\t\t\tif err != nil {\n+\t\t\t\treturn false, 0, err\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tswitch rune {\n+\tcase r.Comma:\n+\t\t// will check below\n+\n+\tcase '\\n':\n+\t\t// We are a trailing empty field or a blank line\n+\t\tif r.column == 0 {\n+\t\t\treturn false, rune, nil\n+\t\t}\n+\t\treturn true, rune, nil\n+\n+\tcase '\"':\n+\t\t// quoted field\n+\tQuoted:\n+\t\tfor {\n+\t\t\trune, err = r.readRune()\n+\t\t\tif err != nil {\n+\t\t\t\tif err == os.EOF {\n+\t\t\t\t\tif r.LazyQuotes {\n+\t\t\t\t\t\treturn true, 0, err\n+\t\t\t\t\t}\n+\t\t\t\t\treturn false, 0, r.error(ErrQuote)\n+\t\t\t\t}\n+\t\t\t\treturn false, 0, err\n+\t\t\t}\n+\t\t\tswitch rune {\n+\t\t\tcase '\"':\n+\t\t\t\trune, err = r.readRune()\n+\t\t\t\tif err != nil || rune == r.Comma {\n+\t\t\t\t\tbreak Quoted\n+\t\t\t\t}\n+\t\t\t\tif rune == '\\n' {\n+\t\t\t\t\treturn true, rune, nil\n+\t\t\t\t}\n+\t\t\t\tif rune != '\"' {\n+\t\t\t\t\tif !r.LazyQuotes {\n+\t\t\t\t\t\tr.column--\n+\t\t\t\t\t\treturn false, 0, r.error(ErrQuote)\n+\t\t\t\t\t}\n+\t\t\t\t\t// accept the bare quote\n+\t\t\t\t\tr.field.WriteRune('\"')\n+\t\t\t\t}\n+\t\t\tcase '\\n':\n+\t\t\t\tr.line++\n+\t\t\t\tr.column = -1\n+\t\t\t}\n+\t\t\tr.field.WriteRune(rune)\n+\t\t}\n+\n+\tdefault:\n+\t\t// unquoted field\n+\t\tfor {\n+\t\t\tr.field.WriteRune(rune)\n+\t\t\trune, err = r.readRune()\n+\t\t\tif err != nil || rune == r.Comma {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tif rune == '\\n' {\n+\t\t\t\treturn true, rune, nil\n+\t\t\t}\n+\t\t\tif !r.LazyQuotes && rune == '\"' {\n+\t\t\t\treturn false, 0, r.error(ErrBareQuote)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif err != nil {\n+\t\tif err == os.EOF {\n+\t\t\treturn true, 0, err\n+\t\t}\n+\t\treturn false, 0, err\n+\t}\n+\n+\tif !r.TrailingComma {\n+\t\t// We don't allow trailing commas.  See if we\n+\t\t// are at the end of the line (being mindful\n+\t\t// of trimming spaces).\n+\t\tc := r.column\n+\t\trune, err = r.readRune()\n+\t\tif r.TrimLeadingSpace {\n+\t\t\tfor unicode.IsSpace(rune) {\n+\t\t\t\trune, err = r.readRune()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif err == os.EOF || rune == '\\n' {\n+\t\t\tr.column = c // report the comma\n+\t\t\treturn false, 0, r.error(ErrTrailingComma)\n+\t\t}\n+\t\tr.unreadRune()\n+\t}\n+\treturn true, rune, nil\n+}"}, {"sha": "0068bad1db69bb3d673291f90d1bb9f0d8cfe978", "filename": "libgo/go/csv/reader_test.go", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcsv%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcsv%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcsv%2Freader_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -0,0 +1,265 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package csv\n+\n+import (\n+\t\"reflect\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+var readTests = []struct {\n+\tName               string\n+\tInput              string\n+\tOutput             [][]string\n+\tUseFieldsPerRecord bool // false (default) means FieldsPerRecord is -1\n+\n+\t// These fields are copied into the Reader\n+\tComma            int\n+\tComment          int\n+\tFieldsPerRecord  int\n+\tLazyQuotes       bool\n+\tTrailingComma    bool\n+\tTrimLeadingSpace bool\n+\n+\tError  string\n+\tLine   int // Expected error line if != 0\n+\tColumn int // Expected error column if line != 0\n+}{\n+\t{\n+\t\tName:   \"Simple\",\n+\t\tInput:  \"a,b,c\\n\",\n+\t\tOutput: [][]string{{\"a\", \"b\", \"c\"}},\n+\t},\n+\t{\n+\t\tName:   \"CRLF\",\n+\t\tInput:  \"a,b\\r\\nc,d\\r\\n\",\n+\t\tOutput: [][]string{{\"a\", \"b\"}, {\"c\", \"d\"}},\n+\t},\n+\t{\n+\t\tName:   \"BareCR\",\n+\t\tInput:  \"a,b\\rc,d\\r\\n\",\n+\t\tOutput: [][]string{{\"a\", \"b\\rc\", \"d\"}},\n+\t},\n+\t{\n+\t\tName:               \"RFC4180test\",\n+\t\tUseFieldsPerRecord: true,\n+\t\tInput: `#field1,field2,field3\n+\"aaa\",\"bb\n+b\",\"ccc\"\n+\"a,a\",\"b\"\"bb\",\"ccc\"\n+zzz,yyy,xxx\n+`,\n+\t\tOutput: [][]string{\n+\t\t\t{\"#field1\", \"field2\", \"field3\"},\n+\t\t\t{\"aaa\", \"bb\\nb\", \"ccc\"},\n+\t\t\t{\"a,a\", `b\"bb`, \"ccc\"},\n+\t\t\t{\"zzz\", \"yyy\", \"xxx\"},\n+\t\t},\n+\t},\n+\t{\n+\t\tName:   \"NoEOLTest\",\n+\t\tInput:  \"a,b,c\",\n+\t\tOutput: [][]string{{\"a\", \"b\", \"c\"}},\n+\t},\n+\t{\n+\t\tName:   \"Semicolon\",\n+\t\tComma:  ';',\n+\t\tInput:  \"a;b;c\\n\",\n+\t\tOutput: [][]string{{\"a\", \"b\", \"c\"}},\n+\t},\n+\t{\n+\t\tName: \"MultiLine\",\n+\t\tInput: `\"two\n+line\",\"one line\",\"three\n+line\n+field\"`,\n+\t\tOutput: [][]string{{\"two\\nline\", \"one line\", \"three\\nline\\nfield\"}},\n+\t},\n+\t{\n+\t\tName:  \"BlankLine\",\n+\t\tInput: \"a,b,c\\n\\nd,e,f\\n\\n\",\n+\t\tOutput: [][]string{\n+\t\t\t{\"a\", \"b\", \"c\"},\n+\t\t\t{\"d\", \"e\", \"f\"},\n+\t\t},\n+\t},\n+\t{\n+\t\tName:             \"TrimSpace\",\n+\t\tInput:            \" a,  b,   c\\n\",\n+\t\tTrimLeadingSpace: true,\n+\t\tOutput:           [][]string{{\"a\", \"b\", \"c\"}},\n+\t},\n+\t{\n+\t\tName:   \"LeadingSpace\",\n+\t\tInput:  \" a,  b,   c\\n\",\n+\t\tOutput: [][]string{{\" a\", \"  b\", \"   c\"}},\n+\t},\n+\t{\n+\t\tName:    \"Comment\",\n+\t\tComment: '#',\n+\t\tInput:   \"#1,2,3\\na,b,c\\n#comment\",\n+\t\tOutput:  [][]string{{\"a\", \"b\", \"c\"}},\n+\t},\n+\t{\n+\t\tName:   \"NoComment\",\n+\t\tInput:  \"#1,2,3\\na,b,c\",\n+\t\tOutput: [][]string{{\"#1\", \"2\", \"3\"}, {\"a\", \"b\", \"c\"}},\n+\t},\n+\t{\n+\t\tName:       \"LazyQuotes\",\n+\t\tLazyQuotes: true,\n+\t\tInput:      `a \"word\",\"1\"2\",a\",\"b`,\n+\t\tOutput:     [][]string{{`a \"word\"`, `1\"2`, `a\"`, `b`}},\n+\t},\n+\t{\n+\t\tName:       \"BareQuotes\",\n+\t\tLazyQuotes: true,\n+\t\tInput:      `a \"word\",\"1\"2\",a\"`,\n+\t\tOutput:     [][]string{{`a \"word\"`, `1\"2`, `a\"`}},\n+\t},\n+\t{\n+\t\tName:       \"BareDoubleQuotes\",\n+\t\tLazyQuotes: true,\n+\t\tInput:      `a\"\"b,c`,\n+\t\tOutput:     [][]string{{`a\"\"b`, `c`}},\n+\t},\n+\t{\n+\t\tName:   \"BadDoubleQuotes\",\n+\t\tInput:  `a\"\"b,c`,\n+\t\tOutput: [][]string{{`a\"\"b`, `c`}},\n+\t\tError:  `bare \" in non-quoted-field`, Line: 1, Column: 1,\n+\t},\n+\t{\n+\t\tName:             \"TrimQuote\",\n+\t\tInput:            ` \"a\",\" b\",c`,\n+\t\tTrimLeadingSpace: true,\n+\t\tOutput:           [][]string{{\"a\", \" b\", \"c\"}},\n+\t},\n+\t{\n+\t\tName:  \"BadBareQuote\",\n+\t\tInput: `a \"word\",\"b\"`,\n+\t\tError: `bare \" in non-quoted-field`, Line: 1, Column: 2,\n+\t},\n+\t{\n+\t\tName:  \"BadTrailingQuote\",\n+\t\tInput: `\"a word\",b\"`,\n+\t\tError: `bare \" in non-quoted-field`, Line: 1, Column: 10,\n+\t},\n+\t{\n+\t\tName:  \"ExtraneousQuote\",\n+\t\tInput: `\"a \"word\",\"b\"`,\n+\t\tError: `extraneous \" in field`, Line: 1, Column: 3,\n+\t},\n+\t{\n+\t\tName:               \"BadFieldCount\",\n+\t\tUseFieldsPerRecord: true,\n+\t\tInput:              \"a,b,c\\nd,e\",\n+\t\tError:              \"wrong number of fields\", Line: 2,\n+\t},\n+\t{\n+\t\tName:               \"BadFieldCount1\",\n+\t\tUseFieldsPerRecord: true,\n+\t\tFieldsPerRecord:    2,\n+\t\tInput:              `a,b,c`,\n+\t\tError:              \"wrong number of fields\", Line: 1,\n+\t},\n+\t{\n+\t\tName:   \"FieldCount\",\n+\t\tInput:  \"a,b,c\\nd,e\",\n+\t\tOutput: [][]string{{\"a\", \"b\", \"c\"}, {\"d\", \"e\"}},\n+\t},\n+\t{\n+\t\tName:  \"BadTrailingCommaEOF\",\n+\t\tInput: \"a,b,c,\",\n+\t\tError: \"extra delimiter at end of line\", Line: 1, Column: 5,\n+\t},\n+\t{\n+\t\tName:  \"BadTrailingCommaEOL\",\n+\t\tInput: \"a,b,c,\\n\",\n+\t\tError: \"extra delimiter at end of line\", Line: 1, Column: 5,\n+\t},\n+\t{\n+\t\tName:             \"BadTrailingCommaSpaceEOF\",\n+\t\tTrimLeadingSpace: true,\n+\t\tInput:            \"a,b,c, \",\n+\t\tError:            \"extra delimiter at end of line\", Line: 1, Column: 5,\n+\t},\n+\t{\n+\t\tName:             \"BadTrailingCommaSpaceEOL\",\n+\t\tTrimLeadingSpace: true,\n+\t\tInput:            \"a,b,c, \\n\",\n+\t\tError:            \"extra delimiter at end of line\", Line: 1, Column: 5,\n+\t},\n+\t{\n+\t\tName:             \"BadTrailingCommaLine3\",\n+\t\tTrimLeadingSpace: true,\n+\t\tInput:            \"a,b,c\\nd,e,f\\ng,hi,\",\n+\t\tError:            \"extra delimiter at end of line\", Line: 3, Column: 4,\n+\t},\n+\t{\n+\t\tName:   \"NotTrailingComma3\",\n+\t\tInput:  \"a,b,c, \\n\",\n+\t\tOutput: [][]string{{\"a\", \"b\", \"c\", \" \"}},\n+\t},\n+\t{\n+\t\tName:          \"CommaFieldTest\",\n+\t\tTrailingComma: true,\n+\t\tInput: `x,y,z,w\n+x,y,z,\n+x,y,,\n+x,,,\n+,,,\n+\"x\",\"y\",\"z\",\"w\"\n+\"x\",\"y\",\"z\",\"\"\n+\"x\",\"y\",\"\",\"\"\n+\"x\",\"\",\"\",\"\"\n+\"\",\"\",\"\",\"\"\n+`,\n+\t\tOutput: [][]string{\n+\t\t\t{\"x\", \"y\", \"z\", \"w\"},\n+\t\t\t{\"x\", \"y\", \"z\", \"\"},\n+\t\t\t{\"x\", \"y\", \"\", \"\"},\n+\t\t\t{\"x\", \"\", \"\", \"\"},\n+\t\t\t{\"\", \"\", \"\", \"\"},\n+\t\t\t{\"x\", \"y\", \"z\", \"w\"},\n+\t\t\t{\"x\", \"y\", \"z\", \"\"},\n+\t\t\t{\"x\", \"y\", \"\", \"\"},\n+\t\t\t{\"x\", \"\", \"\", \"\"},\n+\t\t\t{\"\", \"\", \"\", \"\"},\n+\t\t},\n+\t},\n+}\n+\n+func TestRead(t *testing.T) {\n+\tfor _, tt := range readTests {\n+\t\tr := NewReader(strings.NewReader(tt.Input))\n+\t\tr.Comment = tt.Comment\n+\t\tif tt.UseFieldsPerRecord {\n+\t\t\tr.FieldsPerRecord = tt.FieldsPerRecord\n+\t\t} else {\n+\t\t\tr.FieldsPerRecord = -1\n+\t\t}\n+\t\tr.LazyQuotes = tt.LazyQuotes\n+\t\tr.TrailingComma = tt.TrailingComma\n+\t\tr.TrimLeadingSpace = tt.TrimLeadingSpace\n+\t\tif tt.Comma != 0 {\n+\t\t\tr.Comma = tt.Comma\n+\t\t}\n+\t\tout, err := r.ReadAll()\n+\t\tperr, _ := err.(*ParseError)\n+\t\tif tt.Error != \"\" {\n+\t\t\tif err == nil || !strings.Contains(err.String(), tt.Error) {\n+\t\t\t\tt.Errorf(\"%s: error %v, want error %q\", tt.Name, err, tt.Error)\n+\t\t\t} else if tt.Line != 0 && (tt.Line != perr.Line || tt.Column != perr.Column) {\n+\t\t\t\tt.Errorf(\"%s: error at %d:%d expected %d:%d\", tt.Name, perr.Line, perr.Column, tt.Line, tt.Column)\n+\t\t\t}\n+\t\t} else if err != nil {\n+\t\t\tt.Errorf(\"%s: unexpected error %v\", tt.Name, err)\n+\t\t} else if !reflect.DeepEqual(out, tt.Output) {\n+\t\t\tt.Errorf(\"%s: out=%q want %q\", tt.Name, out, tt.Output)\n+\t\t}\n+\t}\n+}"}, {"sha": "ccf703f0f8cfae254b275b993c6fc90b993e9d5f", "filename": "libgo/go/csv/writer.go", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcsv%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcsv%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcsv%2Fwriter.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package csv\n+\n+import (\n+\t\"bufio\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"unicode\"\n+\t\"utf8\"\n+)\n+\n+// A Writer writes records to a CSV encoded file.\n+//\n+// As returned by NewWriter, a Writer writes records terminated by a\n+// newline and uses ',' as the field delimiter.  The exported fields can be\n+// changed to customize the details before the first call to Write or WriteAll.\n+//\n+// Comma is the field delimiter.\n+//\n+// If UseCRLF is true, the Writer ends each record with \\r\\n instead of \\n.\n+type Writer struct {\n+\tComma   int  // Field delimiter (set to to ',' by NewWriter)\n+\tUseCRLF bool // True to use \\r\\n as the line terminator\n+\tw       *bufio.Writer\n+}\n+\n+// NewWriter returns a new Writer that writes to w.\n+func NewWriter(w io.Writer) *Writer {\n+\treturn &Writer{\n+\t\tComma: ',',\n+\t\tw:     bufio.NewWriter(w),\n+\t}\n+}\n+\n+// Writer writes a single CSV record to w along with any necessary quoting.\n+// A record is a slice of strings with each string being one field.\n+func (w *Writer) Write(record []string) (err os.Error) {\n+\tfor n, field := range record {\n+\t\tif n > 0 {\n+\t\t\tif _, err = w.w.WriteRune(w.Comma); err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\t// If we don't have to have a quoted field then just\n+\t\t// write out the field and continue to the next field.\n+\t\tif !w.fieldNeedsQuotes(field) {\n+\t\t\tif _, err = w.w.WriteString(field); err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err = w.w.WriteByte('\"'); err != nil {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfor _, rune := range field {\n+\t\t\tswitch rune {\n+\t\t\tcase '\"':\n+\t\t\t\t_, err = w.w.WriteString(`\"\"`)\n+\t\t\tcase '\\r':\n+\t\t\t\tif !w.UseCRLF {\n+\t\t\t\t\terr = w.w.WriteByte('\\r')\n+\t\t\t\t}\n+\t\t\tcase '\\n':\n+\t\t\t\tif w.UseCRLF {\n+\t\t\t\t\t_, err = w.w.WriteString(\"\\r\\n\")\n+\t\t\t\t} else {\n+\t\t\t\t\terr = w.w.WriteByte('\\n')\n+\t\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\t_, err = w.w.WriteRune(rune)\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\tif err = w.w.WriteByte('\"'); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tif w.UseCRLF {\n+\t\t_, err = w.w.WriteString(\"\\r\\n\")\n+\t} else {\n+\t\terr = w.w.WriteByte('\\n')\n+\t}\n+\treturn\n+}\n+\n+// Flush writes any buffered data to the underlying io.Writer.\n+func (w *Writer) Flush() {\n+\tw.w.Flush()\n+}\n+\n+// WriteAll writes multiple CSV records to w using Write and then calls Flush.\n+func (w *Writer) WriteAll(records [][]string) (err os.Error) {\n+\tfor _, record := range records {\n+\t\terr = w.Write(record)\n+\t\tif err != nil {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tw.Flush()\n+\treturn nil\n+}\n+\n+// fieldNeedsQuotes returns true if our field must be enclosed in quotes.\n+// Empty fields, files with a Comma, fields with a quote or newline, and\n+// fields which start with a space must be enclosed in quotes.\n+func (w *Writer) fieldNeedsQuotes(field string) bool {\n+\tif len(field) == 0 || strings.IndexRune(field, w.Comma) >= 0 || strings.IndexAny(field, \"\\\"\\r\\n\") >= 0 {\n+\t\treturn true\n+\t}\n+\n+\trune, _ := utf8.DecodeRuneInString(field)\n+\treturn unicode.IsSpace(rune)\n+}"}, {"sha": "578959007fd37f58fb745b559debb2dbd88c9c7f", "filename": "libgo/go/csv/writer_test.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcsv%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fcsv%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcsv%2Fwriter_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package csv\n+\n+import (\n+\t\"bytes\"\n+\t\"testing\"\n+)\n+\n+var writeTests = []struct {\n+\tInput   [][]string\n+\tOutput  string\n+\tUseCRLF bool\n+}{\n+\t{Input: [][]string{{\"abc\"}}, Output: \"abc\\n\"},\n+\t{Input: [][]string{{\"abc\"}}, Output: \"abc\\r\\n\", UseCRLF: true},\n+\t{Input: [][]string{{`\"abc\"`}}, Output: `\"\"\"abc\"\"\"` + \"\\n\"},\n+\t{Input: [][]string{{`a\"b`}}, Output: `\"a\"\"b\"` + \"\\n\"},\n+\t{Input: [][]string{{`\"a\"b\"`}}, Output: `\"\"\"a\"\"b\"\"\"` + \"\\n\"},\n+\t{Input: [][]string{{\" abc\"}}, Output: `\" abc\"` + \"\\n\"},\n+\t{Input: [][]string{{\"abc,def\"}}, Output: `\"abc,def\"` + \"\\n\"},\n+\t{Input: [][]string{{\"abc\", \"def\"}}, Output: \"abc,def\\n\"},\n+\t{Input: [][]string{{\"abc\"}, {\"def\"}}, Output: \"abc\\ndef\\n\"},\n+\t{Input: [][]string{{\"abc\\ndef\"}}, Output: \"\\\"abc\\ndef\\\"\\n\"},\n+\t{Input: [][]string{{\"abc\\ndef\"}}, Output: \"\\\"abc\\r\\ndef\\\"\\r\\n\", UseCRLF: true},\n+}\n+\n+func TestWrite(t *testing.T) {\n+\tfor n, tt := range writeTests {\n+\t\tb := &bytes.Buffer{}\n+\t\tf := NewWriter(b)\n+\t\tf.UseCRLF = tt.UseCRLF\n+\t\terr := f.WriteAll(tt.Input)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Unexpected error: %s\\n\", err)\n+\t\t}\n+\t\tout := b.String()\n+\t\tif out != tt.Output {\n+\t\t\tt.Errorf(\"#%d: out=%q want %q\", n, out, tt.Output)\n+\t\t}\n+\t}\n+}"}, {"sha": "f35365ebeb08cd709200777ea0e07efb5d80d322", "filename": "libgo/go/debug/dwarf/type.go", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -352,8 +352,8 @@ func (d *Data) Type(off Offset) (Type, os.Error) {\n \t\t\t}\n \t\t}\n \t\tif ndim == 0 {\n-\t\t\terr = DecodeError{\"info\", e.Offset, \"missing dimension for array\"}\n-\t\t\tgoto Error\n+\t\t\t// LLVM generates this for x[].\n+\t\t\tt.Count = -1\n \t\t}\n \n \tcase TagBaseType:\n@@ -523,7 +523,7 @@ func (d *Data) Type(off Offset) (Type, os.Error) {\n \t\t// Attributes:\n \t\t//\tAttrType: type of return value if any\n \t\t//\tAttrName: possible name of type [ignored]\n-\t\t//\tAttrPrototyped: whether used ANSI C prototye [ignored]\n+\t\t//\tAttrPrototyped: whether used ANSI C prototype [ignored]\n \t\t// Children:\n \t\t//\tTagFormalParameter: typed parameter\n \t\t//\t\tAttrType: type of parameter\n@@ -566,12 +566,13 @@ func (d *Data) Type(off Offset) (Type, os.Error) {\n \t\tgoto Error\n \t}\n \n-\tb, ok := e.Val(AttrByteSize).(int64)\n-\tif !ok {\n-\t\tb = -1\n+\t{\n+\t\tb, ok := e.Val(AttrByteSize).(int64)\n+\t\tif !ok {\n+\t\t\tb = -1\n+\t\t}\n+\t\ttyp.Common().ByteSize = b\n \t}\n-\ttyp.Common().ByteSize = b\n-\n \treturn typ, nil\n \n Error:"}, {"sha": "b9470a4fcb4dad4dc27421906aa1ffd10f8ba923", "filename": "libgo/go/debug/dwarf/type_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -58,7 +58,6 @@ func machoData(t *testing.T, name string) *Data {\n \treturn d\n }\n \n-\n func TestTypedefsELF(t *testing.T) { testTypedefs(t, elfData(t, \"testdata/typedef.elf\")) }\n \n func TestTypedefsMachO(t *testing.T) {"}, {"sha": "c71b230bd95e9c63739fb8ad782fda0774553f42", "filename": "libgo/go/debug/elf/elf.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Felf%2Felf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Felf%2Felf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Felf.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -1289,7 +1289,6 @@ func (i R_SPARC) GoString() string { return stringName(uint32(i), rsparcStrings,\n // Magic number for the elf trampoline, chosen wisely to be an immediate value.\n const ARM_MAGIC_TRAMP_NUMBER = 0x5c000003\n \n-\n // ELF32 File header.\n type Header32 struct {\n \tIdent     [EI_NIDENT]byte /* File identification. */\n@@ -1455,7 +1454,6 @@ func R_SYM64(info uint64) uint32    { return uint32(info >> 32) }\n func R_TYPE64(info uint64) uint32   { return uint32(info) }\n func R_INFO(sym, typ uint32) uint64 { return uint64(sym)<<32 | uint64(typ) }\n \n-\n // ELF64 symbol table entries.\n type Sym64 struct {\n \tName  uint32 /* String table index of name. */"}, {"sha": "a0ddb1fc7ad2bbe065f9e2aad5ff8429bfa63d38", "filename": "libgo/go/debug/elf/file.go", "status": "modified", "additions": 68, "deletions": 13, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -81,7 +81,7 @@ func (s *Section) Data() ([]byte, os.Error) {\n // specified link value.\n func (f *File) stringTable(link uint32) ([]byte, os.Error) {\n \tif link <= 0 || link >= uint32(len(f.Sections)) {\n-\t\treturn nil, os.ErrorString(\"section has invalid string table link\")\n+\t\treturn nil, os.NewError(\"section has invalid string table link\")\n \t}\n \treturn f.Sections[link].Data()\n }\n@@ -93,6 +93,7 @@ func (s *Section) Open() io.ReadSeeker { return io.NewSectionReader(s.sr, 0, 1<<\n type ProgHeader struct {\n \tType   ProgType\n \tFlags  ProgFlag\n+\tOff    uint64\n \tVaddr  uint64\n \tPaddr  uint64\n \tFilesz uint64\n@@ -224,6 +225,8 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \tf.ABIVersion = ident[EI_ABIVERSION]\n \n \t// Read ELF file header\n+\tvar phoff int64\n+\tvar phentsize, phnum int\n \tvar shoff int64\n \tvar shentsize, shnum, shstrndx int\n \tshstrndx = -1\n@@ -239,6 +242,9 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \t\tif v := Version(hdr.Version); v != f.Version {\n \t\t\treturn nil, &FormatError{0, \"mismatched ELF version\", v}\n \t\t}\n+\t\tphoff = int64(hdr.Phoff)\n+\t\tphentsize = int(hdr.Phentsize)\n+\t\tphnum = int(hdr.Phnum)\n \t\tshoff = int64(hdr.Shoff)\n \t\tshentsize = int(hdr.Shentsize)\n \t\tshnum = int(hdr.Shnum)\n@@ -254,6 +260,9 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \t\tif v := Version(hdr.Version); v != f.Version {\n \t\t\treturn nil, &FormatError{0, \"mismatched ELF version\", v}\n \t\t}\n+\t\tphoff = int64(hdr.Phoff)\n+\t\tphentsize = int(hdr.Phentsize)\n+\t\tphnum = int(hdr.Phnum)\n \t\tshoff = int64(hdr.Shoff)\n \t\tshentsize = int(hdr.Shentsize)\n \t\tshnum = int(hdr.Shnum)\n@@ -264,7 +273,47 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \t}\n \n \t// Read program headers\n-\t// TODO\n+\tf.Progs = make([]*Prog, phnum)\n+\tfor i := 0; i < phnum; i++ {\n+\t\toff := phoff + int64(i)*int64(phentsize)\n+\t\tsr.Seek(off, os.SEEK_SET)\n+\t\tp := new(Prog)\n+\t\tswitch f.Class {\n+\t\tcase ELFCLASS32:\n+\t\t\tph := new(Prog32)\n+\t\t\tif err := binary.Read(sr, f.ByteOrder, ph); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tp.ProgHeader = ProgHeader{\n+\t\t\t\tType:   ProgType(ph.Type),\n+\t\t\t\tFlags:  ProgFlag(ph.Flags),\n+\t\t\t\tOff:    uint64(ph.Off),\n+\t\t\t\tVaddr:  uint64(ph.Vaddr),\n+\t\t\t\tPaddr:  uint64(ph.Paddr),\n+\t\t\t\tFilesz: uint64(ph.Filesz),\n+\t\t\t\tMemsz:  uint64(ph.Memsz),\n+\t\t\t\tAlign:  uint64(ph.Align),\n+\t\t\t}\n+\t\tcase ELFCLASS64:\n+\t\t\tph := new(Prog64)\n+\t\t\tif err := binary.Read(sr, f.ByteOrder, ph); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tp.ProgHeader = ProgHeader{\n+\t\t\t\tType:   ProgType(ph.Type),\n+\t\t\t\tFlags:  ProgFlag(ph.Flags),\n+\t\t\t\tOff:    uint64(ph.Off),\n+\t\t\t\tVaddr:  uint64(ph.Vaddr),\n+\t\t\t\tPaddr:  uint64(ph.Paddr),\n+\t\t\t\tFilesz: uint64(ph.Filesz),\n+\t\t\t\tMemsz:  uint64(ph.Memsz),\n+\t\t\t\tAlign:  uint64(ph.Align),\n+\t\t\t}\n+\t\t}\n+\t\tp.sr = io.NewSectionReader(r, int64(p.Off), int64(p.Filesz))\n+\t\tp.ReaderAt = p.sr\n+\t\tf.Progs[i] = p\n+\t}\n \n \t// Read section headers\n \tf.Sections = make([]*Section, shnum)\n@@ -341,27 +390,27 @@ func (f *File) getSymbols(typ SectionType) ([]Symbol, []byte, os.Error) {\n \t\treturn f.getSymbols32(typ)\n \t}\n \n-\treturn nil, nil, os.ErrorString(\"not implemented\")\n+\treturn nil, nil, os.NewError(\"not implemented\")\n }\n \n func (f *File) getSymbols32(typ SectionType) ([]Symbol, []byte, os.Error) {\n \tsymtabSection := f.SectionByType(typ)\n \tif symtabSection == nil {\n-\t\treturn nil, nil, os.ErrorString(\"no symbol section\")\n+\t\treturn nil, nil, os.NewError(\"no symbol section\")\n \t}\n \n \tdata, err := symtabSection.Data()\n \tif err != nil {\n-\t\treturn nil, nil, os.ErrorString(\"cannot load symbol section\")\n+\t\treturn nil, nil, os.NewError(\"cannot load symbol section\")\n \t}\n \tsymtab := bytes.NewBuffer(data)\n \tif symtab.Len()%Sym32Size != 0 {\n-\t\treturn nil, nil, os.ErrorString(\"length of symbol section is not a multiple of SymSize\")\n+\t\treturn nil, nil, os.NewError(\"length of symbol section is not a multiple of SymSize\")\n \t}\n \n \tstrdata, err := f.stringTable(symtabSection.Link)\n \tif err != nil {\n-\t\treturn nil, nil, os.ErrorString(\"cannot load string table section\")\n+\t\treturn nil, nil, os.NewError(\"cannot load string table section\")\n \t}\n \n \t// The first entry is all zeros.\n@@ -390,21 +439,21 @@ func (f *File) getSymbols32(typ SectionType) ([]Symbol, []byte, os.Error) {\n func (f *File) getSymbols64(typ SectionType) ([]Symbol, []byte, os.Error) {\n \tsymtabSection := f.SectionByType(typ)\n \tif symtabSection == nil {\n-\t\treturn nil, nil, os.ErrorString(\"no symbol section\")\n+\t\treturn nil, nil, os.NewError(\"no symbol section\")\n \t}\n \n \tdata, err := symtabSection.Data()\n \tif err != nil {\n-\t\treturn nil, nil, os.ErrorString(\"cannot load symbol section\")\n+\t\treturn nil, nil, os.NewError(\"cannot load symbol section\")\n \t}\n \tsymtab := bytes.NewBuffer(data)\n \tif symtab.Len()%Sym64Size != 0 {\n-\t\treturn nil, nil, os.ErrorString(\"length of symbol section is not a multiple of Sym64Size\")\n+\t\treturn nil, nil, os.NewError(\"length of symbol section is not a multiple of Sym64Size\")\n \t}\n \n \tstrdata, err := f.stringTable(symtabSection.Link)\n \tif err != nil {\n-\t\treturn nil, nil, os.ErrorString(\"cannot load string table section\")\n+\t\treturn nil, nil, os.NewError(\"cannot load string table section\")\n \t}\n \n \t// The first entry is all zeros.\n@@ -462,12 +511,12 @@ func (f *File) applyRelocations(dst []byte, rels []byte) os.Error {\n \t\treturn f.applyRelocationsAMD64(dst, rels)\n \t}\n \n-\treturn os.ErrorString(\"not implemented\")\n+\treturn os.NewError(\"not implemented\")\n }\n \n func (f *File) applyRelocationsAMD64(dst []byte, rels []byte) os.Error {\n \tif len(rels)%Sym64Size != 0 {\n-\t\treturn os.ErrorString(\"length of relocation section is not a multiple of Sym64Size\")\n+\t\treturn os.NewError(\"length of relocation section is not a multiple of Sym64Size\")\n \t}\n \n \tsymbols, _, err := f.getSymbols(SHT_SYMTAB)\n@@ -546,6 +595,12 @@ func (f *File) DWARF() (*dwarf.Data, os.Error) {\n \treturn dwarf.New(abbrev, nil, nil, info, nil, nil, nil, str)\n }\n \n+// Symbols returns the symbol table for f.\n+func (f *File) Symbols() ([]Symbol, os.Error) {\n+\tsym, _, err := f.getSymbols(SHT_SYMTAB)\n+\treturn sym, err\n+}\n+\n type ImportedSymbol struct {\n \tName    string\n \tVersion string"}, {"sha": "98f2723c86e6e1d3f3108254ed5e6bde2c7700c7", "filename": "libgo/go/debug/elf/file_test.go", "status": "modified", "additions": 67, "deletions": 3, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -7,14 +7,18 @@ package elf\n import (\n \t\"debug/dwarf\"\n \t\"encoding/binary\"\n+\t\"net\"\n+\t\"os\"\n \t\"reflect\"\n+\t\"runtime\"\n \t\"testing\"\n )\n \n type fileTest struct {\n \tfile     string\n \thdr      FileHeader\n \tsections []SectionHeader\n+\tprogs    []ProgHeader\n }\n \n var fileTests = []fileTest{\n@@ -53,6 +57,13 @@ var fileTests = []fileTest{\n \t\t\t{\".symtab\", SHT_SYMTAB, 0x0, 0x0, 0xfb8, 0x4b0, 0x1d, 0x38, 0x4, 0x10},\n \t\t\t{\".strtab\", SHT_STRTAB, 0x0, 0x0, 0x1468, 0x206, 0x0, 0x0, 0x1, 0x0},\n \t\t},\n+\t\t[]ProgHeader{\n+\t\t\t{PT_PHDR, PF_R + PF_X, 0x34, 0x8048034, 0x8048034, 0xa0, 0xa0, 0x4},\n+\t\t\t{PT_INTERP, PF_R, 0xd4, 0x80480d4, 0x80480d4, 0x15, 0x15, 0x1},\n+\t\t\t{PT_LOAD, PF_R + PF_X, 0x0, 0x8048000, 0x8048000, 0x5fb, 0x5fb, 0x1000},\n+\t\t\t{PT_LOAD, PF_R + PF_W, 0x5fc, 0x80495fc, 0x80495fc, 0xd8, 0xf8, 0x1000},\n+\t\t\t{PT_DYNAMIC, PF_R + PF_W, 0x60c, 0x804960c, 0x804960c, 0x98, 0x98, 0x4},\n+\t\t},\n \t},\n \t{\n \t\t\"testdata/gcc-amd64-linux-exec\",\n@@ -96,6 +107,16 @@ var fileTests = []fileTest{\n \t\t\t{\".symtab\", SHT_SYMTAB, 0x0, 0x0, 0x19a0, 0x6f0, 0x24, 0x39, 0x8, 0x18},\n \t\t\t{\".strtab\", SHT_STRTAB, 0x0, 0x0, 0x2090, 0x1fc, 0x0, 0x0, 0x1, 0x0},\n \t\t},\n+\t\t[]ProgHeader{\n+\t\t\t{PT_PHDR, PF_R + PF_X, 0x40, 0x400040, 0x400040, 0x1c0, 0x1c0, 0x8},\n+\t\t\t{PT_INTERP, PF_R, 0x200, 0x400200, 0x400200, 0x1c, 0x1c, 1},\n+\t\t\t{PT_LOAD, PF_R + PF_X, 0x0, 0x400000, 0x400000, 0x684, 0x684, 0x200000},\n+\t\t\t{PT_LOAD, PF_R + PF_W, 0x688, 0x600688, 0x600688, 0x210, 0x218, 0x200000},\n+\t\t\t{PT_DYNAMIC, PF_R + PF_W, 0x6b0, 0x6006b0, 0x6006b0, 0x1a0, 0x1a0, 0x8},\n+\t\t\t{PT_NOTE, PF_R, 0x21c, 0x40021c, 0x40021c, 0x20, 0x20, 0x4},\n+\t\t\t{PT_LOOS + 0x474E550, PF_R, 0x5b8, 0x4005b8, 0x4005b8, 0x24, 0x24, 0x4},\n+\t\t\t{PT_LOOS + 0x474E551, PF_R + PF_W, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8},\n+\t\t},\n \t},\n }\n \n@@ -121,11 +142,25 @@ func TestOpen(t *testing.T) {\n \t\t\t\tt.Errorf(\"open %s, section %d:\\n\\thave %#v\\n\\twant %#v\\n\", tt.file, i, &s.SectionHeader, sh)\n \t\t\t}\n \t\t}\n+\t\tfor i, p := range f.Progs {\n+\t\t\tif i >= len(tt.progs) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tph := &tt.progs[i]\n+\t\t\tif !reflect.DeepEqual(&p.ProgHeader, ph) {\n+\t\t\t\tt.Errorf(\"open %s, program %d:\\n\\thave %#v\\n\\twant %#v\\n\", tt.file, i, &p.ProgHeader, ph)\n+\t\t\t}\n+\t\t}\n \t\ttn := len(tt.sections)\n \t\tfn := len(f.Sections)\n \t\tif tn != fn {\n \t\t\tt.Errorf(\"open %s: len(Sections) = %d, want %d\", tt.file, fn, tn)\n \t\t}\n+\t\ttn = len(tt.progs)\n+\t\tfn = len(f.Progs)\n+\t\tif tn != fn {\n+\t\t\tt.Errorf(\"open %s: len(Progs) = %d, want %d\", tt.file, fn, tn)\n+\t\t}\n \t}\n }\n \n@@ -136,15 +171,15 @@ type relocationTest struct {\n \n var relocationTests = []relocationTest{\n \t{\n-\t\t\"testdata/go-relocation-test-gcc441-x86-64.o\",\n+\t\t\"testdata/go-relocation-test-gcc441-x86-64.obj\",\n \t\t&dwarf.Entry{Offset: 0xb, Tag: dwarf.TagCompileUnit, Children: true, Field: []dwarf.Field{{Attr: dwarf.AttrProducer, Val: \"GNU C 4.4.1\"}, {Attr: dwarf.AttrLanguage, Val: int64(1)}, {Attr: dwarf.AttrName, Val: \"go-relocation-test.c\"}, {Attr: dwarf.AttrCompDir, Val: \"/tmp\"}, {Attr: dwarf.AttrLowpc, Val: uint64(0x0)}, {Attr: dwarf.AttrHighpc, Val: uint64(0x6)}, {Attr: dwarf.AttrStmtList, Val: int64(0)}}},\n \t},\n \t{\n-\t\t\"testdata/go-relocation-test-gcc441-x86.o\",\n+\t\t\"testdata/go-relocation-test-gcc441-x86.obj\",\n \t\t&dwarf.Entry{Offset: 0xb, Tag: dwarf.TagCompileUnit, Children: true, Field: []dwarf.Field{{Attr: dwarf.AttrProducer, Val: \"GNU C 4.4.1\"}, {Attr: dwarf.AttrLanguage, Val: int64(1)}, {Attr: dwarf.AttrName, Val: \"t.c\"}, {Attr: dwarf.AttrCompDir, Val: \"/tmp\"}, {Attr: dwarf.AttrLowpc, Val: uint64(0x0)}, {Attr: dwarf.AttrHighpc, Val: uint64(0x5)}, {Attr: dwarf.AttrStmtList, Val: int64(0)}}},\n \t},\n \t{\n-\t\t\"testdata/go-relocation-test-gcc424-x86-64.o\",\n+\t\t\"testdata/go-relocation-test-gcc424-x86-64.obj\",\n \t\t&dwarf.Entry{Offset: 0xb, Tag: dwarf.TagCompileUnit, Children: true, Field: []dwarf.Field{{Attr: dwarf.AttrProducer, Val: \"GNU C 4.2.4 (Ubuntu 4.2.4-1ubuntu4)\"}, {Attr: dwarf.AttrLanguage, Val: int64(1)}, {Attr: dwarf.AttrName, Val: \"go-relocation-test-gcc424.c\"}, {Attr: dwarf.AttrCompDir, Val: \"/tmp\"}, {Attr: dwarf.AttrLowpc, Val: uint64(0x0)}, {Attr: dwarf.AttrHighpc, Val: uint64(0x6)}, {Attr: dwarf.AttrStmtList, Val: int64(0)}}},\n \t},\n }\n@@ -178,3 +213,32 @@ func TestDWARFRelocations(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestNoSectionOverlaps(t *testing.T) {\n+\t// Ensure 6l outputs sections without overlaps.\n+\tif runtime.GOOS != \"linux\" && runtime.GOOS != \"freebsd\" {\n+\t\treturn // not ELF\n+\t}\n+\t_ = net.ResolveIPAddr // force dynamic linkage\n+\tf, err := Open(os.Args[0])\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\tfor i, si := range f.Sections {\n+\t\tsih := si.SectionHeader\n+\t\tif sih.Type == SHT_NOBITS {\n+\t\t\tcontinue\n+\t\t}\n+\t\tfor j, sj := range f.Sections {\n+\t\t\tsjh := sj.SectionHeader\n+\t\t\tif i == j || sjh.Type == SHT_NOBITS || sih.Offset == sjh.Offset && sih.Size == 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif sih.Offset >= sjh.Offset && sih.Offset < sjh.Offset+sjh.Size {\n+\t\t\t\tt.Errorf(\"ld produced ELF with section %s within %s: 0x%x <= 0x%x..0x%x < 0x%x\",\n+\t\t\t\t\tsih.Name, sjh.Name, sjh.Offset, sih.Offset, sih.Offset+sih.Size, sjh.Offset+sjh.Size)\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "a7c6d6e562c1c70342d9d1cf41194b7ef3fdedf6", "filename": "libgo/go/debug/elf/testdata/go-relocation-test-gcc424-x86-64.obj", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc424-x86-64.obj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc424-x86-64.obj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc424-x86-64.obj?ref=adb0401dac41c81571722312d4586b2693f95aa6", "previous_filename": "libgo/go/debug/elf/testdata/go-relocation-test-gcc424-x86-64.o"}, {"sha": "2d37ab6e6e12cfb6625cdda41dc7ecf775ade4e8", "filename": "libgo/go/debug/elf/testdata/go-relocation-test-gcc441-x86-64.obj", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc441-x86-64.obj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc441-x86-64.obj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc441-x86-64.obj?ref=adb0401dac41c81571722312d4586b2693f95aa6", "previous_filename": "libgo/go/debug/elf/testdata/go-relocation-test-gcc441-x86-64.o"}, {"sha": "0d59fe303b6dad25698a1e7c0644d285460797a9", "filename": "libgo/go/debug/elf/testdata/go-relocation-test-gcc441-x86.obj", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc441-x86.obj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc441-x86.obj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc441-x86.obj?ref=adb0401dac41c81571722312d4586b2693f95aa6", "previous_filename": "libgo/go/debug/elf/testdata/go-relocation-test-gcc441-x86.o"}, {"sha": "721a4c4168d6a74c30e4a83f85ae267eb3edd547", "filename": "libgo/go/debug/macho/file.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -184,7 +184,7 @@ func (f *File) Close() os.Error {\n \treturn err\n }\n \n-// NewFile creates a new File for acecssing a Mach-O binary in an underlying reader.\n+// NewFile creates a new File for accessing a Mach-O binary in an underlying reader.\n // The Mach-O binary is expected to start at position 0 in the ReaderAt.\n func NewFile(r io.ReaderAt) (*File, os.Error) {\n \tf := new(File)"}, {"sha": "d86d916f50592494e4fd800e8715863ac773e1d2", "filename": "libgo/go/debug/pe/file.go", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "patch": "@@ -35,7 +35,6 @@ type SectionHeader struct {\n \tCharacteristics      uint32\n }\n \n-\n type Section struct {\n \tSectionHeader\n \n@@ -69,7 +68,6 @@ func (s *Section) Data() ([]byte, os.Error) {\n // Open returns a new ReadSeeker reading the PE section.\n func (s *Section) Open() io.ReadSeeker { return io.NewSectionReader(s.sr, 0, 1<<63-1) }\n \n-\n type FormatError struct {\n \toff int64\n \tmsg string\n@@ -112,7 +110,7 @@ func (f *File) Close() os.Error {\n \treturn err\n }\n \n-// NewFile creates a new File for acecssing a PE binary in an underlying reader.\n+// NewFile creates a new File for accessing a PE binary in an underlying reader.\n func NewFile(r io.ReaderAt) (*File, os.Error) {\n \tf := new(File)\n \tsr := io.NewSectionReader(r, 0, 1<<63-1)\n@@ -245,6 +243,7 @@ func (f *File) DWARF() (*dwarf.Data, os.Error) {\n // satisfied by other libraries at dynamic load time.\n // It does not return weak symbols.\n func (f *File) ImportedSymbols() ([]string, os.Error) {\n+\tpe64 := f.Machine == IMAGE_FILE_MACHINE_AMD64\n \tds := f.Section(\".idata\")\n \tif ds == nil {\n \t\t// not dynamic, so no libraries\n@@ -274,17 +273,31 @@ func (f *File) ImportedSymbols() ([]string, os.Error) {\n \t\t// seek to OriginalFirstThunk\n \t\td = d[dt.OriginalFirstThunk-ds.VirtualAddress:]\n \t\tfor len(d) > 0 {\n-\t\t\tva := binary.LittleEndian.Uint32(d[0:4])\n-\t\t\td = d[4:]\n-\t\t\tif va == 0 {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tif va&0x80000000 > 0 { // is Ordinal\n-\t\t\t\t// TODO add dynimport ordinal support.\n-\t\t\t\t//ord := va&0x0000FFFF\n-\t\t\t} else {\n-\t\t\t\tfn, _ := getString(names, int(va-ds.VirtualAddress+2))\n-\t\t\t\tall = append(all, fn+\":\"+dt.dll)\n+\t\t\tif pe64 { // 64bit\n+\t\t\t\tva := binary.LittleEndian.Uint64(d[0:8])\n+\t\t\t\td = d[8:]\n+\t\t\t\tif va == 0 {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tif va&0x8000000000000000 > 0 { // is Ordinal\n+\t\t\t\t\t// TODO add dynimport ordinal support.\n+\t\t\t\t} else {\n+\t\t\t\t\tfn, _ := getString(names, int(uint32(va)-ds.VirtualAddress+2))\n+\t\t\t\t\tall = append(all, fn+\":\"+dt.dll)\n+\t\t\t\t}\n+\t\t\t} else { // 32bit\n+\t\t\t\tva := binary.LittleEndian.Uint32(d[0:4])\n+\t\t\t\td = d[4:]\n+\t\t\t\tif va == 0 {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tif va&0x80000000 > 0 { // is Ordinal\n+\t\t\t\t\t// TODO add dynimport ordinal support.\n+\t\t\t\t\t//ord := va&0x0000FFFF\n+\t\t\t\t} else {\n+\t\t\t\t\tfn, _ := getString(names, int(va-ds.VirtualAddress+2))\n+\t\t\t\t\tall = append(all, fn+\":\"+dt.dll)\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "d89649cf88781c8a5d76eccb9361d622306a7624", "filename": "libgo/go/debug/proc/proc.go", "status": "removed", "additions": 0, "deletions": 222, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fproc.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f", "patch": "@@ -1,222 +0,0 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package proc provides a platform-independent interface for\n-// tracing and controlling running processes.  It supports\n-// multi-threaded processes and provides typical low-level debugging\n-// controls such as breakpoints, single stepping, and manipulating\n-// memory and registers.\n-package proc\n-\n-// TODO(rsc): Have to import everything that proc_linux.go\n-// and proc_darwin.go do, because deps.bash only looks at\n-// this file.\n-import (\n-\t_ \"container/vector\"\n-\t_ \"fmt\"\n-\t_ \"io\"\n-\t\"os\"\n-\t_ \"runtime\"\n-\t\"strconv\"\n-\t_ \"strings\"\n-\t_ \"sync\"\n-\t_ \"syscall\"\n-)\n-\n-type Word uint64\n-\n-// A Cause explains why a thread is stopped.\n-type Cause interface {\n-\tString() string\n-}\n-\n-// Regs is a set of named machine registers, including a program\n-// counter, link register, and stack pointer.\n-//\n-// TODO(austin) There's quite a proliferation of methods here.  We\n-// could make a Reg interface with Get and Set and make this just PC,\n-// Link, SP, Names, and Reg.  We could also put Index in Reg and that\n-// makes it easy to get the index of things like the PC (currently\n-// there's just no way to know that).  This would also let us include\n-// other per-register information like how to print it.\n-type Regs interface {\n-\t// PC returns the value of the program counter.\n-\tPC() Word\n-\n-\t// SetPC sets the program counter to val.\n-\tSetPC(val Word) os.Error\n-\n-\t// Link returns the link register, if any.\n-\tLink() Word\n-\n-\t// SetLink sets the link register to val.\n-\tSetLink(val Word) os.Error\n-\n-\t// SP returns the value of the stack pointer.\n-\tSP() Word\n-\n-\t// SetSP sets the stack pointer register to val.\n-\tSetSP(val Word) os.Error\n-\n-\t// Names returns the names of all of the registers.\n-\tNames() []string\n-\n-\t// Get returns the value of a register, where i corresponds to\n-\t// the index of the register's name in the array returned by\n-\t// Names.\n-\tGet(i int) Word\n-\n-\t// Set sets the value of a register.\n-\tSet(i int, val Word) os.Error\n-}\n-\n-// Thread is a thread in the process being traced.\n-type Thread interface {\n-\t// Step steps this thread by a single instruction.  The thread\n-\t// must be stopped.  If the thread is currently stopped on a\n-\t// breakpoint, this will step over the breakpoint.\n-\t//\n-\t// XXX What if it's stopped because of a signal?\n-\tStep() os.Error\n-\n-\t// Stopped returns the reason that this thread is stopped.  It\n-\t// is an error is the thread not stopped.\n-\tStopped() (Cause, os.Error)\n-\n-\t// Regs retrieves the current register values from this\n-\t// thread.  The thread must be stopped.\n-\tRegs() (Regs, os.Error)\n-\n-\t// Peek reads len(out) bytes from the address addr in this\n-\t// thread into out.  The thread must be stopped.  It returns\n-\t// the number of bytes successfully read.  If an error occurs,\n-\t// such as attempting to read unmapped memory, this count\n-\t// could be short and an error will be returned.  If this does\n-\t// encounter unmapped memory, it will read up to the byte\n-\t// preceding the unmapped area.\n-\tPeek(addr Word, out []byte) (int, os.Error)\n-\n-\t// Poke writes b to the address addr in this thread.  The\n-\t// thread must be stopped.  It returns the number of bytes\n-\t// successfully written.  If an error occurs, such as\n-\t// attempting to write to unmapped memory, this count could be\n-\t// short and an error will be returned.  If this does\n-\t// encounter unmapped memory, it will write up to the byte\n-\t// preceding the unmapped area.\n-\tPoke(addr Word, b []byte) (int, os.Error)\n-}\n-\n-// Process is a process being traced.  It consists of a set of\n-// threads.  A process can be running, stopped, or terminated.  The\n-// process's state extends to all of its threads.\n-type Process interface {\n-\t// Threads returns an array of all threads in this process.\n-\tThreads() []Thread\n-\n-\t// AddBreakpoint creates a new breakpoint at program counter\n-\t// pc.  Breakpoints can only be created when the process is\n-\t// stopped.  It is an error if a breakpoint already exists at\n-\t// pc.\n-\tAddBreakpoint(pc Word) os.Error\n-\n-\t// RemoveBreakpoint removes the breakpoint at the program\n-\t// counter pc.  It is an error if no breakpoint exists at pc.\n-\tRemoveBreakpoint(pc Word) os.Error\n-\n-\t// Stop stops all running threads in this process before\n-\t// returning.\n-\tStop() os.Error\n-\n-\t// Continue resumes execution of all threads in this process.\n-\t// Any thread that is stopped on a breakpoint will be stepped\n-\t// over that breakpoint.  Any thread that is stopped because\n-\t// of a signal (other than SIGSTOP or SIGTRAP) will receive\n-\t// the pending signal.\n-\tContinue() os.Error\n-\n-\t// WaitStop waits until all threads in process p are stopped\n-\t// as a result of some thread hitting a breakpoint, receiving\n-\t// a signal, creating a new thread, or exiting.\n-\tWaitStop() os.Error\n-\n-\t// Detach detaches from this process.  All stopped threads\n-\t// will be resumed.\n-\tDetach() os.Error\n-}\n-\n-// Stopped is a stop cause used for threads that are stopped either by\n-// user request (e.g., from the Stop method or after single stepping),\n-// or that are stopped because some other thread caused the program to\n-// stop.\n-type Stopped struct{}\n-\n-func (c Stopped) String() string { return \"stopped\" }\n-\n-// Breakpoint is a stop cause resulting from a thread reaching a set\n-// breakpoint.\n-type Breakpoint Word\n-\n-// PC returns the program counter that the program is stopped at.\n-func (c Breakpoint) PC() Word { return Word(c) }\n-\n-func (c Breakpoint) String() string {\n-\treturn \"breakpoint at 0x\" + strconv.Uitob64(uint64(c.PC()), 16)\n-}\n-\n-// Signal is a stop cause resulting from a thread receiving a signal.\n-// When the process is continued, the signal will be delivered.\n-type Signal string\n-\n-// Signal returns the signal being delivered to the thread.\n-func (c Signal) Name() string { return string(c) }\n-\n-func (c Signal) String() string { return c.Name() }\n-\n-// ThreadCreate is a stop cause returned from an existing thread when\n-// it creates a new thread.  The new thread exists in a primordial\n-// form at this point and will begin executing in earnest when the\n-// process is continued.\n-type ThreadCreate struct {\n-\tthread Thread\n-}\n-\n-func (c *ThreadCreate) NewThread() Thread { return c.thread }\n-\n-func (c *ThreadCreate) String() string { return \"thread create\" }\n-\n-// ThreadExit is a stop cause resulting from a thread exiting.  When\n-// this cause first arises, the thread will still be in the list of\n-// process threads and its registers and memory will still be\n-// accessible.\n-type ThreadExit struct {\n-\texitStatus int\n-\tsignal     string\n-}\n-\n-// Exited returns true if the thread exited normally.\n-func (c *ThreadExit) Exited() bool { return c.exitStatus != -1 }\n-\n-// ExitStatus returns the exit status of the thread if it exited\n-// normally or -1 otherwise.\n-func (c *ThreadExit) ExitStatus() int { return c.exitStatus }\n-\n-// Signaled returns true if the thread was terminated by a signal.\n-func (c *ThreadExit) Signaled() bool { return c.exitStatus == -1 }\n-\n-// StopSignal returns the signal that terminated the thread, or \"\" if\n-// it was not terminated by a signal.\n-func (c *ThreadExit) StopSignal() string { return c.signal }\n-\n-func (c *ThreadExit) String() string {\n-\tres := \"thread exited \"\n-\tswitch {\n-\tcase c.Exited():\n-\t\tres += \"with status \" + strconv.Itoa(c.ExitStatus())\n-\tcase c.Signaled():\n-\t\tres += \"from signal \" + c.StopSignal()\n-\tdefault:\n-\t\tres += \"from unknown cause\"\n-\t}\n-\treturn res\n-}"}, {"sha": "49f0a5361fbf5410ae0e0e25414740e8ae3529a9", "filename": "libgo/go/debug/proc/proc_darwin.go", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_darwin.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package proc\n-\n-import \"os\"\n-\n-// Process tracing is not supported on OS X yet.\n-\n-func Attach(pid int) (Process, os.Error) {\n-\treturn nil, os.NewError(\"debug/proc not implemented on OS X\")\n-}\n-\n-func StartProcess(argv0 string, argv []string, attr *os.ProcAttr) (Process, os.Error) {\n-\treturn Attach(0)\n-}"}, {"sha": "4df07c365afe5ac9a4d712f2cc02c1a728113ad2", "filename": "libgo/go/debug/proc/proc_freebsd.go", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_freebsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_freebsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_freebsd.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package proc\n-\n-import \"os\"\n-\n-// Process tracing is not supported on FreeBSD yet.\n-\n-func Attach(pid int) (Process, os.Error) {\n-\treturn nil, os.NewError(\"debug/proc not implemented on FreeBSD\")\n-}\n-\n-func StartProcess(argv0 string, argv []string, attr *os.ProcAttr) (Process, os.Error) {\n-\treturn Attach(0)\n-}"}, {"sha": "17c8fa529f53aad2cb85d62bb57c8819962a77c9", "filename": "libgo/go/debug/proc/proc_linux.go", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_linux.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "661474b67aaaabe246ab0a2d0be3fa842580a4f9", "filename": "libgo/go/debug/proc/proc_windows.go", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_windows.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "60c9ac719e90a13f9b53cedc41905ea8ba26836c", "filename": "libgo/go/debug/proc/regs_darwin_386.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_darwin_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_darwin_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_darwin_386.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "60c9ac719e90a13f9b53cedc41905ea8ba26836c", "filename": "libgo/go/debug/proc/regs_darwin_amd64.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_darwin_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_darwin_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_darwin_amd64.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "60c9ac719e90a13f9b53cedc41905ea8ba26836c", "filename": "libgo/go/debug/proc/regs_freebsd_386.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_freebsd_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_freebsd_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_freebsd_386.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "60c9ac719e90a13f9b53cedc41905ea8ba26836c", "filename": "libgo/go/debug/proc/regs_freebsd_amd64.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_freebsd_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_freebsd_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_freebsd_amd64.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "b4a9769db55c40ccb64c78233006ee26dd1bbcea", "filename": "libgo/go/debug/proc/regs_linux_386.go", "status": "removed", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_linux_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_linux_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_linux_386.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "381be29b179c33192e1ffcca9345cf0b29da86b1", "filename": "libgo/go/debug/proc/regs_linux_amd64.go", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_linux_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_linux_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_linux_amd64.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "ec78cbcf2597630234ccde7f8782d93b4014881f", "filename": "libgo/go/debug/proc/regs_linux_arm.go", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_linux_arm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_linux_arm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_linux_arm.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "60c9ac719e90a13f9b53cedc41905ea8ba26836c", "filename": "libgo/go/debug/proc/regs_windows_386.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_windows_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_windows_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_windows_386.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "60c9ac719e90a13f9b53cedc41905ea8ba26836c", "filename": "libgo/go/debug/proc/regs_windows_amd64.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_windows_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_windows_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_windows_amd64.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "69da1176725f83a5737dabe1f5a04ed47230a2e2", "filename": "libgo/go/ebnf/ebnf.go", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Febnf%2Febnf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Febnf%2Febnf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Febnf%2Febnf.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "b086facc3ed3a24cae0f4a9be8cfd64e58e7a130", "filename": "libgo/go/ebnf/ebnf_test.go", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Febnf%2Febnf_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Febnf%2Febnf_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Febnf%2Febnf_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "ef2fac0000f0c89f56efbe55f49cf4f50c764e50", "filename": "libgo/go/ebnf/parser.go", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Febnf%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Febnf%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Febnf%2Fparser.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "3fa1c2b2669fb8af96b0a04edf2b5e4b12d84ab5", "filename": "libgo/go/encoding/base32/base32_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "c6b2a13e4a4947aa4fc8676c9bc228d3cb63eb78", "filename": "libgo/go/encoding/base64/base64.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "c163dae842d3f23a849a4d9af2934e13ce99b141", "filename": "libgo/go/encoding/base64/base64_test.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "8e55cb23b7c4707bf2a6ce6fd5fec4e02f76d788", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "b266996f6355b07eea213fefaafc7a77f9e678c6", "filename": "libgo/go/encoding/binary/binary_test.go", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "6bb74f46c86a8b4cccb5b4a269abcc18335ddad9", "filename": "libgo/go/encoding/git85/git.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "e7ea8b0f2a64bfd9a54c4c6b3973224b006b33eb", "filename": "libgo/go/encoding/hex/hex.go", "status": "modified", "additions": 116, "deletions": 1, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fhex%2Fhex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fhex%2Fhex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fhex%2Fhex.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "8e1838e51e6f4c2b2562f74b2e462ec75f47462a", "filename": "libgo/go/encoding/hex/hex_test.go", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fhex%2Fhex_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fhex%2Fhex_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fhex%2Fhex_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "123962b1f917998fda722a48ba32a22bb2860b82", "filename": "libgo/go/encoding/line/line.go", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fencoding%2Fline%2Fline.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fencoding%2Fline%2Fline.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fline%2Fline.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "ff3d51669b54326646975bd1a9ce2fa12e69a7e6", "filename": "libgo/go/encoding/line/line_test.go", "status": "removed", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fencoding%2Fline%2Fline_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fencoding%2Fline%2Fline_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fline%2Fline_test.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "12689b57b1ba0ca2f79bf599916bdf2fcaf3d6be", "filename": "libgo/go/encoding/pem/pem.go", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "3b20f2008cae0ccdf4905b486cccb76f0c9c0406", "filename": "libgo/go/exec/exec.go", "status": "modified", "additions": 322, "deletions": 149, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Fexec.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "242120faab544fa9af8a7ce9a2e3920dc07669c4", "filename": "libgo/go/exec/exec_test.go", "status": "modified", "additions": 165, "deletions": 118, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexec%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexec%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Fexec_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "e4751a4df29c6209ad641043ccc2b626b7c7faf9", "filename": "libgo/go/exec/lp_plan9.go", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexec%2Flp_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexec%2Flp_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Flp_plan9.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "77d8e848c74251bcd87d54ca9bf17fc00e8b6dea", "filename": "libgo/go/exec/lp_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexec%2Flp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexec%2Flp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Flp_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "008fb11a81c01186193a1fab5119cd72eee28391", "filename": "libgo/go/exec/lp_unix.go", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexec%2Flp_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexec%2Flp_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Flp_unix.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "7581088eb09a1126f22bd5bd50b2ea81fdc22b33", "filename": "libgo/go/exec/lp_windows.go", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexec%2Flp_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexec%2Flp_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Flp_windows.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "6d7e7644276cb1653367bae08acd89684bb20f70", "filename": "libgo/go/exp/datafmt/datafmt.go", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "87d07165933d44a4a9e3c884f42c57443e0fab73", "filename": "libgo/go/exp/datafmt/datafmt_test.go", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "a2ddd389723e754cd0cae204825aec1962fd817e", "filename": "libgo/go/exp/datafmt/parser.go", "status": "modified", "additions": 20, "deletions": 38, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fdatafmt%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fdatafmt%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdatafmt%2Fparser.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "22e17cec405444285aa692779060623f73dd6fff", "filename": "libgo/go/exp/eval/abort.go", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fabort.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fabort.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fabort.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "f31d9ab9bd6e0bcf124dda6e6edbd807ec75639f", "filename": "libgo/go/exp/eval/bridge.go", "status": "removed", "additions": 0, "deletions": 164, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fbridge.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fbridge.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fbridge.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "9d2923bfca4674eb0f0f7c0a8e7ad606c58b80e6", "filename": "libgo/go/exp/eval/compiler.go", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fcompiler.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fcompiler.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fcompiler.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "541d3feb71dc70d5febb81b8d967cdd5bdac9dcf", "filename": "libgo/go/exp/eval/eval_test.go", "status": "removed", "additions": 0, "deletions": 263, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Feval_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Feval_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Feval_test.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "e65f47617bdcd7b2964cc0088bdd2349be5e82e7", "filename": "libgo/go/exp/eval/expr.go", "status": "removed", "additions": 0, "deletions": 2015, "changes": 2015, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fexpr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fexpr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fexpr.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "5d0e50000325d675898e29638170ac710e7db73b", "filename": "libgo/go/exp/eval/expr1.go", "status": "removed", "additions": 0, "deletions": 1874, "changes": 1874, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fexpr1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fexpr1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fexpr1.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "0dbce431520f0102429a8fafa0969d351fca218d", "filename": "libgo/go/exp/eval/expr_test.go", "status": "removed", "additions": 0, "deletions": 355, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fexpr_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fexpr_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fexpr_test.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "cb1b579e42c9f35d92e7c5a0158222cfc096bcff", "filename": "libgo/go/exp/eval/func.go", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Ffunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Ffunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Ffunc.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "66305de25f034edb94b87a0944d2173b28c58596", "filename": "libgo/go/exp/eval/scope.go", "status": "removed", "additions": 0, "deletions": 207, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fscope.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "f6b7c1cda941ac4ef4798a7cbefb9f9f42064d63", "filename": "libgo/go/exp/eval/stmt.go", "status": "removed", "additions": 0, "deletions": 1299, "changes": 1299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fstmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fstmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fstmt.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "a8a3e16204121e4db0e58d5d2c85b5a05d801893", "filename": "libgo/go/exp/eval/stmt_test.go", "status": "removed", "additions": 0, "deletions": 343, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fstmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fstmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fstmt_test.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "8a93d8a6c27b3857d7158b9f824abf6086c9a123", "filename": "libgo/go/exp/eval/type.go", "status": "removed", "additions": 0, "deletions": 1252, "changes": 1252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Ftype.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "de90cf66496761e2d8310a34d3d0455da17702df", "filename": "libgo/go/exp/eval/typec.go", "status": "removed", "additions": 0, "deletions": 409, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Ftypec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Ftypec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Ftypec.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "daa69189792bcea1419b71f71ef5e33a338ad972", "filename": "libgo/go/exp/eval/value.go", "status": "removed", "additions": 0, "deletions": 586, "changes": 586, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fvalue.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "a5f6ac7e5e788aeb0c00180ad3d157593b7429bf", "filename": "libgo/go/exp/eval/world.go", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fworld.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Feval%2Fworld.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fworld.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "17149918605c31a47c35ad306e1dcadd7d919bab", "filename": "libgo/go/exp/gui/gui.go", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fgui%2Fgui.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fgui%2Fgui.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgui%2Fgui.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "previous_filename": "libgo/go/exp/draw/event.go"}, {"sha": "d48936ac178a865b9e5de82287e60036c5ca36c7", "filename": "libgo/go/exp/gui/x11/auth.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fauth.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fauth.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fauth.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "previous_filename": "libgo/go/exp/draw/x11/auth.go"}, {"sha": "1d237816abf923b53e7a4df71fc085e9381ed810", "filename": "libgo/go/exp/gui/x11/conn.go", "status": "renamed", "additions": 55, "deletions": 53, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fconn.go?ref=adb0401dac41c81571722312d4586b2693f95aa6", "previous_filename": "libgo/go/exp/draw/x11/conn.go"}, {"sha": "b2d2abaf63b731b570db8c3548f4ffe2b8b659d6", "filename": "libgo/go/exp/norm/composition.go", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "195a0c1e8e99122513f4b42be6863d5b035e8b84", "filename": "libgo/go/exp/norm/composition_test.go", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "ee3edb8ea7d78d1763217f7b71f38a342a04dc0f", "filename": "libgo/go/exp/norm/forminfo.go", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "e3e5700a64efcf419e464fc5a71fc5c88b3076a7", "filename": "libgo/go/exp/norm/maketables.go", "status": "added", "additions": 855, "deletions": 0, "changes": 855, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "c5f6a64368d2a991899257acdcc93f77f964d035", "filename": "libgo/go/exp/norm/maketesttables.go", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketesttables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketesttables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketesttables.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "12dacfcf3006ceda00dc883a1d14bfd8d4fd0406", "filename": "libgo/go/exp/norm/norm_test.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Fnorm_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Fnorm_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnorm_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "e9d18dd9ea9d71bccab1bf9304bbc57ef5e273aa", "filename": "libgo/go/exp/norm/normalize.go", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "76995c2fa18b63a4337ce41cb0ffb79d5c9d17a9", "filename": "libgo/go/exp/norm/tables.go", "status": "added", "additions": 6580, "deletions": 0, "changes": 6580, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "6b6540187578086888d9b8982feb34a24705c690", "filename": "libgo/go/exp/norm/trie.go", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "ad87d972b02f107feb6f46949117e40ab10a1572", "filename": "libgo/go/exp/norm/trie_test.go", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "f886e6004a49a673054e65efb9947faf080d16c8", "filename": "libgo/go/exp/norm/triedata_test.go", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Ftriedata_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Ftriedata_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftriedata_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "2b7eeee175b7bbcd8ee647bcc537f0f293cbcbfb", "filename": "libgo/go/exp/norm/triegen.go", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "311a7b38e24954bfc20a669b459d356c39a14fb9", "filename": "libgo/go/exp/ogle/abort.go", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Fabort.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Fabort.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Fabort.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "52b1c97572bf187e3495eba8bd7a1816e25830d3", "filename": "libgo/go/exp/ogle/arch.go", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Farch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Farch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Farch.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "a8db523ea18e9cdb17f5559b19e5f8366511e819", "filename": "libgo/go/exp/ogle/cmd.go", "status": "removed", "additions": 0, "deletions": 373, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "d7092ded336db99ff9f58dec39addb53f3414f6a", "filename": "libgo/go/exp/ogle/event.go", "status": "removed", "additions": 0, "deletions": 280, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Fevent.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Fevent.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Fevent.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "1538362bad233b7c28e55d742a09a941f367567a", "filename": "libgo/go/exp/ogle/frame.go", "status": "removed", "additions": 0, "deletions": 212, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Fframe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Fframe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Fframe.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "5104ec6d479e10106841a5513a2dfbce2724b486", "filename": "libgo/go/exp/ogle/goroutine.go", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Fgoroutine.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Fgoroutine.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Fgoroutine.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "1999ecccab824d806133eca2655caa938c2c1ab6", "filename": "libgo/go/exp/ogle/main.go", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Fmain.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "7c803b3a27e990f3282b8cdbb915a604e284f6a8", "filename": "libgo/go/exp/ogle/process.go", "status": "removed", "additions": 0, "deletions": 521, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Fprocess.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Fprocess.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Fprocess.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "950418b5388fee785449f8d131b50cf442213d60", "filename": "libgo/go/exp/ogle/rruntime.go", "status": "removed", "additions": 0, "deletions": 271, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Frruntime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Frruntime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Frruntime.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "b3c35575af4c96e88f6439066127705222b192d3", "filename": "libgo/go/exp/ogle/rtype.go", "status": "removed", "additions": 0, "deletions": 288, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Frtype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Frtype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Frtype.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "3d630f936644c678c6a030b250e21d41eb294e44", "filename": "libgo/go/exp/ogle/rvalue.go", "status": "removed", "additions": 0, "deletions": 515, "changes": 515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Frvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Frvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Frvalue.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "8a3a14791dbf014967e6aa84519a6a5b5aadf28c", "filename": "libgo/go/exp/ogle/vars.go", "status": "removed", "additions": 0, "deletions": 272, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Fvars.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5548ca3540bccbc908a45942896d635ea5f1c23f/libgo%2Fgo%2Fexp%2Fogle%2Fvars.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Fvars.go?ref=5548ca3540bccbc908a45942896d635ea5f1c23f"}, {"sha": "77f32ca1a57cc469f146b72742e7840d688f1d7e", "filename": "libgo/go/exp/regexp/all_test.go", "status": "added", "additions": 429, "deletions": 0, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fregexp%2Fall_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "0670bb9b1b4bdf12350a73a1bf2578d833e3ad2b", "filename": "libgo/go/exp/regexp/exec.go", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fregexp%2Fexec.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "dddc3484c9382efbfba2e4319aeac69a83d873c7", "filename": "libgo/go/exp/regexp/find_test.go", "status": "added", "additions": 472, "deletions": 0, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Ffind_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Ffind_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fregexp%2Ffind_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "1b75900f81632b23a7a60364e59bdec7d45fe333", "filename": "libgo/go/exp/regexp/regexp.go", "status": "added", "additions": 795, "deletions": 0, "changes": 795, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fregexp%2Fregexp.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "5ea2425c3aa3541ce3a3921f9751d48532fc3e5e", "filename": "libgo/go/exp/regexp/syntax/compile.go", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fcompile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fcompile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fcompile.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "4eed182687b90ff967f3f381c2d11ac9b192903a", "filename": "libgo/go/exp/regexp/syntax/parse.go", "status": "added", "additions": 1797, "deletions": 0, "changes": 1797, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fparse.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "779b9afdeae06c80244a2ad767a4cc019a75dd15", "filename": "libgo/go/exp/regexp/syntax/parse_test.go", "status": "added", "additions": 350, "deletions": 0, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fparse_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "05b392c40d80efd2186b3c16154b940c1d0efd34", "filename": "libgo/go/exp/regexp/syntax/perl_groups.go", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fperl_groups.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fperl_groups.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fperl_groups.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "bf85b720d02c524d9d1aab80bc0e7668f40d3911", "filename": "libgo/go/exp/regexp/syntax/prog.go", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fprog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fprog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fprog.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "7be4281c27f21bcb40a7717f3cb27ecb46653752", "filename": "libgo/go/exp/regexp/syntax/prog_test.go", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fprog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fprog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fprog_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "00a4addefc4ba23d390f8cbf8c0efed0fcdc4bb5", "filename": "libgo/go/exp/regexp/syntax/regexp.go", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fregexp.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "72390417bbed21c5ae5328b3c7612342bd241617", "filename": "libgo/go/exp/regexp/syntax/simplify.go", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fsimplify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fsimplify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fsimplify.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "c8cec21831aa26f7e246ca294fdd067623b54f23", "filename": "libgo/go/exp/regexp/syntax/simplify_test.go", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fsimplify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fsimplify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fregexp%2Fsyntax%2Fsimplify_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "41100688343731aef1fbeecf3fc594299cab425d", "filename": "libgo/go/exp/template/html/context.go", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcontext.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcontext.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcontext.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "e0e87b98d043fdfe8aa22b2177c576e8be0825de", "filename": "libgo/go/exp/template/html/escape.go", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "345a752a89676d55ca3bda8c0f454746d2d3059c", "filename": "libgo/go/exp/template/html/escape_test.go", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "31b57a2cc86003b0228f9c09fc3d361de95abc1d", "filename": "libgo/go/exp/wingui/winapi.go", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fwingui%2Fwinapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fwingui%2Fwinapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwingui%2Fwinapi.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "4c009dd69bc302d4ab3cc7eb6d636adfb8cd935a", "filename": "libgo/go/exp/wingui/zwinapi.go", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "7b733faf67469c4a97714ba8d67f6cbfe1946489", "filename": "libgo/go/expvar/expvar.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "8f7a48168eaa61b05df3f36f6d52cde371fbfad4", "filename": "libgo/go/expvar/expvar_test.go", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "7b190807a8a5253e489284d519daf929ad8f7e13", "filename": "libgo/go/flag/export_test.go", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fflag%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fflag%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fexport_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "01bbc3770080834ed444c3f6df470c1ce75d9728", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 312, "deletions": 104, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "63d0a9fc8946915af20225268930361f0f3ae928", "filename": "libgo/go/flag/flag_test.go", "status": "modified", "additions": 78, "deletions": 24, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fflag%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fflag%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "35a11e19fa18fbbdf6139b0448a5e453050908d6", "filename": "libgo/go/fmt/doc.go", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Ffmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Ffmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fdoc.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "1142c9f8ad72ad38754c8e925a4bb375e8cc3169", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 88, "deletions": 7, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "24b15a286b7c5a685321587dd7d2be8258bb2a52", "filename": "libgo/go/fmt/format.go", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Ffmt%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Ffmt%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fformat.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "738734908079a4eb6a8f2e5ce406a993b3b0f2da", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 76, "deletions": 27, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "259451d02f77c443560ed82cb6d5c4dd62b397b3", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 49, "deletions": 21, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "3f06e5725cacbabfbcafe690ec527c2ee3d9a3e8", "filename": "libgo/go/fmt/scan_test.go", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Ffmt%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Ffmt%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "22bd5ee2266ad4836eadf682d992207d1ea35e14", "filename": "libgo/go/go/ast/ast.go", "status": "modified", "additions": 12, "deletions": 54, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fast.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "26733430d64d65291e9333f9910d76f5938c5fdc", "filename": "libgo/go/go/ast/filter.go", "status": "modified", "additions": 87, "deletions": 43, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "62a30481d5cfcef1003d309e2f8e20dea8183e82", "filename": "libgo/go/go/ast/print.go", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fprint.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "f4e8f7a78f70449ac602f4b55c2ff89fd1e87cd7", "filename": "libgo/go/go/ast/print_test.go", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "3927a799e0a0a375e0a34ff4739a0f74471934eb", "filename": "libgo/go/go/ast/resolve.go", "status": "modified", "additions": 38, "deletions": 52, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "92e3669808121ab704e58afcbccb2de0266aec12", "filename": "libgo/go/go/ast/scope.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fast%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fast%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fscope.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "181cfd1491adf416894a7c806e9800fb057dd320", "filename": "libgo/go/go/ast/walk.go", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "97f92bfb6e7a352d0e476ef0791d7f76a669929c", "filename": "libgo/go/go/build/build.go", "status": "added", "additions": 444, "deletions": 0, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "e59d87672ca6e43b1086441dc29739da2be0b21b", "filename": "libgo/go/go/build/build_test.go", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "93bbf06883f39b3730a55732e23a23a873162373", "filename": "libgo/go/go/build/cgotest/cgotest.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fbuild%2Fcgotest%2Fcgotest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fbuild%2Fcgotest%2Fcgotest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fcgotest%2Fcgotest.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "bed4f485a0a222e1fc04d6753b07262cc0bff58a", "filename": "libgo/go/go/build/cmdtest/main.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fbuild%2Fcmdtest%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fbuild%2Fcmdtest%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fcmdtest%2Fmain.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "e0000b534468edfbb1e3358a625ca439edd9295c", "filename": "libgo/go/go/build/dir.go", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "e39b5f8fa575e2f70bc21cb03bc50cfe1f4a353c", "filename": "libgo/go/go/build/path.go", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "9322f5ebd716a6fb1d6eebc628082b8ee1216979", "filename": "libgo/go/go/build/pkgtest/pkgtest.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fpkgtest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fpkgtest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fpkgtest.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "eb0e5dcb6b2c75fb59ca6a1784c57514452dfee6", "filename": "libgo/go/go/build/syslist_test.go", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "e1989226b68cb725245b4fb9c079c9f65dd73ad2", "filename": "libgo/go/go/doc/comment.go", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "c7fed97841cc70a5cb02c19dccb58836f4eb8726", "filename": "libgo/go/go/doc/doc.go", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "4f980fc6539dd845b2df53709f2c42d468b9febc", "filename": "libgo/go/go/parser/interface.go", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "9c14d16673242fb2973924abd1f7c34a66bb703a", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 98, "deletions": 185, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "39a78e5156e79b8e64babc4fdf1c16777652aaf3", "filename": "libgo/go/go/parser/parser_test.go", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "9cd975ec1be783a01705e2f26a627605f4c0f7c5", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 142, "deletions": 98, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "84fb2808ebaab734a9a803e418052095f3cf803c", "filename": "libgo/go/go/printer/performance_test.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "871fefa0c8f5c695110beaaafaaf5c40e0c3185a", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 6, "deletions": 51, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "ff2d906b560e1f7440d0b4ce01e90bdc8a53dca7", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "7b332252c4ec0ad26ca17930c92d6fc0f5ab19f3", "filename": "libgo/go/go/printer/testdata/comments.golden", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "2a9a86b681584c2748ea58fcf97a9dc4dbf859a1", "filename": "libgo/go/go/printer/testdata/comments.input", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "ae7729286e5a63aae5c784d1e16d6b5973e66612", "filename": "libgo/go/go/printer/testdata/comments.x", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.x?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "970533e8cfbe1a3a3ad2ac557b907d4b90a39819", "filename": "libgo/go/go/printer/testdata/declarations.golden", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "c6134096bf131e15427a8f3be0f83b4574fe4e87", "filename": "libgo/go/go/printer/testdata/declarations.input", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "d0cf24ad6f6d8bd968f4d51837d41a2a311eaa95", "filename": "libgo/go/go/printer/testdata/expressions.golden", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "d7819a3baadcff99f25bfe2f4e468c78a37fbb5f", "filename": "libgo/go/go/printer/testdata/expressions.raw", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "2d27af49920cb49d515bc4030b4e3b4afd5aefb5", "filename": "libgo/go/go/printer/testdata/parser.go", "status": "modified", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fparser.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "a6d85107f0b307b154d005f591c4f55d495ceaed", "filename": "libgo/go/go/printer/testdata/statements.golden", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "86a753c5ad9eca33cefe7ec6f220c9f70586562e", "filename": "libgo/go/go/printer/testdata/statements.input", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "a0927e4167fafdeec7c657a752ccd75c3fc35f28", "filename": "libgo/go/go/scanner/errors.go", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fscanner%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fscanner%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Ferrors.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "7f3dd23732878a14155c682d4a4a63c1ff194f4c", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 6, "deletions": 53, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "eb9e1cb818a9f1da7169a01bfea0c17f399acd18", "filename": "libgo/go/go/scanner/scanner_test.go", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "c559e19f8865867b93735876cf946eeac89a176d", "filename": "libgo/go/go/token/position.go", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "30bec59913aa956f6b340cc68616dbc60ceff9eb", "filename": "libgo/go/go/token/position_test.go", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "557374052c91ad96d010e1b3973eb7b5632fab0c", "filename": "libgo/go/go/token/token.go", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "d73d1a45048db1621ec715086a1bf05c5dea713e", "filename": "libgo/go/go/typechecker/scope.go", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftypechecker%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftypechecker%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Fscope.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "1b88eb54b85de2e7f1a65e3c7d3b5545f595c481", "filename": "libgo/go/go/typechecker/type.go", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftype.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "24480165bde55b028e72f66ef2ed9f82747dc9f8", "filename": "libgo/go/go/typechecker/typechecker.go", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "4bad4499a47009a9323f2ccf80adf1b0fad0e810", "filename": "libgo/go/go/typechecker/typechecker_test.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "81c14a05e57e0ffc5425d870606d4180b4b311fd", "filename": "libgo/go/go/typechecker/universe.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftypechecker%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftypechecker%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Funiverse.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "87e3e93da73a0ef79334020405e92386f147e584", "filename": "libgo/go/go/types/check.go", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}, {"sha": "8be653fcb665542132c6c64ba1556e4899d4839e", "filename": "libgo/go/go/types/check_test.go", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb0401dac41c81571722312d4586b2693f95aa6/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck_test.go?ref=adb0401dac41c81571722312d4586b2693f95aa6"}]}