{"sha": "1a36a0cd695e3254367fc01d371ae23f3d3f50fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEzNmEwY2Q2OTVlMzI1NDM2N2ZjMDFkMzcxYWUyM2YzZDNmNTBmYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-10-13T11:00:13Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-10-13T11:00:13Z"}, "message": "[multiple changes]\n\n2011-10-13  Cyrille Comar  <comar@adacore.com>\n\n\t* gnat_ugn.texi: Minor editing.\n\n2011-10-13  Vincent Celier  <celier@adacore.com>\n\n\t* projects.texi: Add documentation on packages and attributes\n\tthat are inherited from a project being extended into the\n\textended project.\n\n2011-10-13  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch3.adb (Build_Master): Rewritten.\n\t(Expand_N_Full_Type_Declaration): Reformat the declarative\n\tregion. Update the call to Build_Master_Renaming.\n\t(Expand_Previous_Access_Type): Rewritten.\n\t* exp_ch6.adb (Add_Task_Actuals_To_Build_In_Place_Call):\n\tAdd local constant Result_Subt and update related usage.\n\t(Expand_N_Extended_Return_Statement): Add local constant\n\tResult_Subt and update related usage.\n\t* exp_ch9.adb (Build_Activation_Chain): Rewritten to use the\n\tnew context detection mechanism.\n\t(Build_Class_Wide_Master):\n\tUse Insert_Action to add the renaming into the tree.\n\t(Build_Master_Entity): Rewritten to use the new context detection\n\tmechanism.\n\t(Build_Master_Renaming): Add formal parameter Ins_Nod\n\tand related usage. Use Insert_Action to add the renaming into the\n\ttree.\n\t(Find_Enclosing_Context): New subsidiary routine. Rather\n\tthan relying on enclosing scopes, this routine looks at the\n\ttree structure to figure out the proper context for a _master\n\tor a _chain. This approach eliminates the issues with transient\n\tscopes which have not been converted into blocks.\n\t* exp_ch9.ads (Build_Master_Entity): Change parameter profile\n\tto better reflect the new usage. Update the related comment.\n\t(Build_Master_Renaming): Add formal parameter Ins_Nod. Update\n\tthe comment on usage.\n\t* sem_ch3.adb (Access_Definition): Update the calls to\n\tBuild_Master_Entity and Build_Master_Renaming.\n\t* sem_ch6.adb (Create_Extra_Formals): Add local variable\n\tFull_Subt. Code reformatting.\n\t* sem_util.adb (Is_Iterator): Alphabetized.\n\t(Is_LHS): Alphabetized.\n\t(Is_Limited_Class_Wide_Type): New routine.\n\t* sem_util.ads (Is_Limited_Class_Wide_Type): New routine.\n\nFrom-SVN: r179913", "tree": {"sha": "aa31cbc8e6e668e5151abda35b023b5a3b2ef393", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa31cbc8e6e668e5151abda35b023b5a3b2ef393"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a36a0cd695e3254367fc01d371ae23f3d3f50fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a36a0cd695e3254367fc01d371ae23f3d3f50fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a36a0cd695e3254367fc01d371ae23f3d3f50fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/comments", "author": null, "committer": null, "parents": [{"sha": "a5917ffb2cd7097f9b8b754c2745c23d860cb31a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5917ffb2cd7097f9b8b754c2745c23d860cb31a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5917ffb2cd7097f9b8b754c2745c23d860cb31a"}], "stats": {"total": 750, "additions": 498, "deletions": 252}, "files": [{"sha": "2b23da95a2118f3d03e3002dba0eac693808033d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1a36a0cd695e3254367fc01d371ae23f3d3f50fa", "patch": "@@ -1,3 +1,50 @@\n+2011-10-13  Cyrille Comar  <comar@adacore.com>\n+\n+\t* gnat_ugn.texi: Minor editing.\n+\n+2011-10-13  Vincent Celier  <celier@adacore.com>\n+\n+\t* projects.texi: Add documentation on packages and attributes\n+\tthat are inherited from a project being extended into the\n+\textended project.\n+\n+2011-10-13  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch3.adb (Build_Master): Rewritten.\n+\t(Expand_N_Full_Type_Declaration): Reformat the declarative\n+\tregion. Update the call to Build_Master_Renaming.\n+\t(Expand_Previous_Access_Type): Rewritten.\n+\t* exp_ch6.adb (Add_Task_Actuals_To_Build_In_Place_Call):\n+\tAdd local constant Result_Subt and update related usage.\n+\t(Expand_N_Extended_Return_Statement): Add local constant\n+\tResult_Subt and update related usage.\n+\t* exp_ch9.adb (Build_Activation_Chain): Rewritten to use the\n+\tnew context detection mechanism.\n+\t(Build_Class_Wide_Master):\n+\tUse Insert_Action to add the renaming into the tree.\n+\t(Build_Master_Entity): Rewritten to use the new context detection\n+\tmechanism.\n+\t(Build_Master_Renaming): Add formal parameter Ins_Nod\n+\tand related usage. Use Insert_Action to add the renaming into the\n+\ttree.\n+\t(Find_Enclosing_Context): New subsidiary routine. Rather\n+\tthan relying on enclosing scopes, this routine looks at the\n+\ttree structure to figure out the proper context for a _master\n+\tor a _chain. This approach eliminates the issues with transient\n+\tscopes which have not been converted into blocks.\n+\t* exp_ch9.ads (Build_Master_Entity): Change parameter profile\n+\tto better reflect the new usage. Update the related comment.\n+\t(Build_Master_Renaming): Add formal parameter Ins_Nod. Update\n+\tthe comment on usage.\n+\t* sem_ch3.adb (Access_Definition): Update the calls to\n+\tBuild_Master_Entity and Build_Master_Renaming.\n+\t* sem_ch6.adb (Create_Extra_Formals): Add local variable\n+\tFull_Subt. Code reformatting.\n+\t* sem_util.adb (Is_Iterator): Alphabetized.\n+\t(Is_LHS): Alphabetized.\n+\t(Is_Limited_Class_Wide_Type): New routine.\n+\t* sem_util.ads (Is_Limited_Class_Wide_Type): New routine.\n+\n 2011-10-13  Geert Bosch  <bosch@adacore.com>\n \n \t* a-ngrear.adb (Solve): Make generic and move to"}, {"sha": "dc3eb4bfec4bae47e33ed697dbad139945f5b35b", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 39, "deletions": 28, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=1a36a0cd695e3254367fc01d371ae23f3d3f50fa", "patch": "@@ -4124,29 +4124,27 @@ package body Exp_Ch3 is\n    ------------------------------------\n \n    procedure Expand_N_Full_Type_Declaration (N : Node_Id) is\n-      Def_Id : constant Entity_Id := Defining_Identifier (N);\n-      B_Id   : constant Entity_Id := Base_Type (Def_Id);\n-      FN     : Node_Id;\n-      Par_Id : Entity_Id;\n \n-      procedure Build_Master (Def_Id : Entity_Id);\n-      --  Create the master associated with Def_Id\n+      procedure Build_Master (Ptr_Typ : Entity_Id);\n+      --  Create the master associated with Ptr_Typ\n \n       ------------------\n       -- Build_Master --\n       ------------------\n \n-      procedure Build_Master (Def_Id : Entity_Id) is\n+      procedure Build_Master (Ptr_Typ : Entity_Id) is\n+         Desig_Typ : constant Entity_Id := Designated_Type (Ptr_Typ);\n+\n       begin\n          --  Anonymous access types are created for the components of the\n          --  record parameter for an entry declaration. No master is created\n          --  for such a type.\n \n-         if Has_Task (Designated_Type (Def_Id))\n-           and then Comes_From_Source (N)\n+         if Comes_From_Source (N)\n+           and then Has_Task (Desig_Typ)\n          then\n-            Build_Master_Entity (Def_Id);\n-            Build_Master_Renaming (Parent (Def_Id), Def_Id);\n+            Build_Master_Entity (Ptr_Typ);\n+            Build_Master_Renaming (Ptr_Typ);\n \n          --  Create a class-wide master because a Master_Id must be generated\n          --  for access-to-limited-class-wide types whose root may be extended\n@@ -4155,8 +4153,7 @@ package body Exp_Ch3 is\n          --  Note: This code covers access-to-limited-interfaces because they\n          --        can be used to reference tasks implementing them.\n \n-         elsif Is_Class_Wide_Type (Designated_Type (Def_Id))\n-           and then Is_Limited_Type (Designated_Type (Def_Id))\n+         elsif Is_Limited_Class_Wide_Type (Desig_Typ)\n            and then Tasking_Allowed\n \n             --  Do not create a class-wide master for types whose convention is\n@@ -4174,13 +4171,20 @@ package body Exp_Ch3 is\n             --  Because the convention appears after we have done the\n             --  processing for type Ref.\n \n-           and then Convention (Designated_Type (Def_Id)) /= Convention_Java\n-           and then Convention (Designated_Type (Def_Id)) /= Convention_CIL\n+           and then Convention (Desig_Typ) /= Convention_Java\n+           and then Convention (Desig_Typ) /= Convention_CIL\n          then\n-            Build_Class_Wide_Master (Def_Id);\n+            Build_Class_Wide_Master (Ptr_Typ);\n          end if;\n       end Build_Master;\n \n+      --  Local declarations\n+\n+      Def_Id : constant Entity_Id := Defining_Identifier (N);\n+      B_Id   : constant Entity_Id := Base_Type (Def_Id);\n+      FN     : Node_Id;\n+      Par_Id : Entity_Id;\n+\n    --  Start of processing for Expand_N_Full_Type_Declaration\n \n    begin\n@@ -4240,7 +4244,7 @@ package body Exp_Ch3 is\n \n                   if First then\n                      Build_Master_Entity (Def_Id);\n-                     Build_Master_Renaming (N, Typ);\n+                     Build_Master_Renaming (Typ);\n                      M_Id := Master_Id (Typ);\n \n                      First := False;\n@@ -5174,23 +5178,30 @@ package body Exp_Ch3 is\n    ---------------------------------\n \n    procedure Expand_Previous_Access_Type (Def_Id : Entity_Id) is\n-      T : Entity_Id := First_Entity (Current_Scope);\n+      Ptr_Typ : Entity_Id := First_Entity (Current_Scope);\n \n    begin\n-      --  Find all access types declared in the current scope, whose\n-      --  designated type is Def_Id. If it does not have a Master_Id,\n-      --  create one now.\n-\n-      while Present (T) loop\n-         if Is_Access_Type (T)\n-           and then Designated_Type (T) = Def_Id\n-           and then No (Master_Id (T))\n+      --  Find all access types in the current scope whose designated type is\n+      --  Def_Id and build master renamings for them.\n+\n+      while Present (Ptr_Typ) loop\n+         if Is_Access_Type (Ptr_Typ)\n+           and then Designated_Type (Ptr_Typ) = Def_Id\n+           and then No (Master_Id (Ptr_Typ))\n          then\n+            --  Ensure that the designated type has a master\n+\n             Build_Master_Entity (Def_Id);\n-            Build_Master_Renaming (Parent (Def_Id), T);\n+\n+            --  Private and incomplete types complicate the insertion of master\n+            --  renamings because the access type may precede the full view of\n+            --  the designated type. For this reason, the master renamings are\n+            --  inserted relative to the designated type.\n+\n+            Build_Master_Renaming (Ptr_Typ, Ins_Nod => Parent (Def_Id));\n          end if;\n \n-         Next_Entity (T);\n+         Next_Entity (Ptr_Typ);\n       end loop;\n    end Expand_Previous_Access_Type;\n "}, {"sha": "811c3fcdd071e5da83733b4109044e2bf5aff7f8", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=1a36a0cd695e3254367fc01d371ae23f3d3f50fa", "patch": "@@ -477,13 +477,14 @@ package body Exp_Ch6 is\n       Function_Id   : Entity_Id;\n       Master_Actual : Node_Id)\n    is\n-      Loc    : constant Source_Ptr := Sloc (Function_Call);\n-      Actual : Node_Id := Master_Actual;\n+      Loc         : constant Source_Ptr := Sloc (Function_Call);\n+      Result_Subt : constant Entity_Id := Available_View (Etype (Function_Id));\n+      Actual      : Node_Id := Master_Actual;\n \n    begin\n       --  No such extra parameters are needed if there are no tasks\n \n-      if not Has_Task (Available_View (Etype (Function_Id))) then\n+      if not Has_Task (Result_Subt) then\n          return;\n       end if;\n \n@@ -4590,6 +4591,7 @@ package body Exp_Ch6 is\n \n       Par_Func     : constant Entity_Id :=\n                        Return_Applies_To (Return_Statement_Entity (N));\n+      Result_Subt  : constant Entity_Id := Etype (Par_Func);\n       Ret_Obj_Id   : constant Entity_Id :=\n                        First_Entity (Return_Statement_Entity (N));\n       Ret_Obj_Decl : constant Node_Id := Parent (Ret_Obj_Id);\n@@ -4894,7 +4896,7 @@ package body Exp_Ch6 is\n       --  built in place (though we plan to do so eventually).\n \n       if Present (HSS)\n-        or else Is_Composite_Type (Etype (Par_Func))\n+        or else Is_Composite_Type (Result_Subt)\n         or else No (Exp)\n       then\n          if No (HSS) then\n@@ -4921,7 +4923,7 @@ package body Exp_Ch6 is\n          --  the case of result types with task parts.\n \n          if Is_Build_In_Place\n-           and then Has_Task (Etype (Par_Func))\n+           and then Has_Task (Result_Subt)\n          then\n             --  The return expression is an aggregate for a complex type which\n             --  contains tasks. This particular case is left unexpanded since\n@@ -4932,7 +4934,12 @@ package body Exp_Ch6 is\n                Expand_N_Aggregate (Exp);\n             end if;\n \n-            Append_To (Stmts, Move_Activation_Chain);\n+            --  Do not move the activation chain if the return object does not\n+            --  contain tasks.\n+\n+            if Has_Task (Etype (Ret_Obj_Id)) then\n+               Append_To (Stmts, Move_Activation_Chain);\n+            end if;\n          end if;\n \n          --  Update the state of the function right before the object is\n@@ -5031,7 +5038,6 @@ package body Exp_Ch6 is\n                Return_Obj_Typ   : constant Entity_Id := Etype (Return_Obj_Id);\n                Return_Obj_Expr  : constant Node_Id :=\n                                     Expression (Ret_Obj_Decl);\n-               Result_Subt      : constant Entity_Id := Etype (Par_Func);\n                Constr_Result    : constant Boolean :=\n                                     Is_Constrained (Result_Subt);\n                Obj_Alloc_Formal : Entity_Id;"}, {"sha": "8305278e8d87fb3ba70a27fe4e14c20c373b71a9", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 205, "deletions": 87, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=1a36a0cd695e3254367fc01d371ae23f3d3f50fa", "patch": "@@ -346,6 +346,18 @@ package body Exp_Ch9 is\n    --  to handle properly the case of bounds that depend on discriminants.\n    --  If Cap is true, the result is capped according to Entry_Family_Bound.\n \n+   procedure Find_Enclosing_Context\n+     (N             : Node_Id;\n+      Context       : out Node_Id;\n+      Context_Id    : out Entity_Id;\n+      Context_Decls : out List_Id);\n+   --  Subsidiary routine to procedures Build_Activation_Chain_Entity and\n+   --  Build_Master_Entity. Given an arbitrary node in the tree, find the\n+   --  nearest enclosing body, block, package or return statement and return\n+   --  its constituents. Context is the enclosing construct, Context_Id is\n+   --  the scope of Context_Id and Context_Decls is the declarative list of\n+   --  Context.\n+\n    procedure Extract_Dispatching_Call\n      (N        : Node_Id;\n       Call_Ent : out Entity_Id;\n@@ -870,64 +882,33 @@ package body Exp_Ch9 is\n \n       --  Local variables\n \n-      Decls : List_Id;\n-      Par   : Node_Id;\n+      Context    : Node_Id;\n+      Context_Id : Entity_Id;\n+      Decls      : List_Id;\n \n    --  Start of processing for Build_Activation_Chain_Entity\n \n    begin\n-      --  Traverse the parent chain looking for an enclosing construct which\n-      --  contains an activation chain variable. The construct is either a\n-      --  body, a block, or an extended return.\n-\n-      Par := Parent (N);\n-\n-      while not Nkind_In (Par, N_Block_Statement,\n-                               N_Entry_Body,\n-                               N_Extended_Return_Statement,\n-                               N_Package_Body,\n-                               N_Package_Declaration,\n-                               N_Subprogram_Body,\n-                               N_Task_Body)\n-      loop\n-         Par := Parent (Par);\n-      end loop;\n-\n-      --  When the enclosing construct is a package body, the activation chain\n-      --  variable is declared in the body, but the Activation_Chain_Entity is\n-      --  attached to the spec.\n-\n-      if Nkind (Par) = N_Package_Body then\n-         Decls := Declarations (Par);\n-         Par   := Unit_Declaration_Node (Corresponding_Spec (Par));\n-\n-      elsif Nkind (Par) = N_Package_Declaration then\n-         Decls := Visible_Declarations (Specification (Par));\n-\n-      elsif Nkind (Par) = N_Extended_Return_Statement then\n-         Decls := Return_Object_Declarations (Par);\n-\n-      else\n-         Decls := Declarations (Par);\n-      end if;\n+      Find_Enclosing_Context (N, Context, Context_Id, Decls);\n \n       --  If an activation chain entity has not been declared already, create\n       --  one.\n \n-      if Nkind (Par) = N_Extended_Return_Statement\n-        or else No (Activation_Chain_Entity (Par))\n+      if Nkind (Context) = N_Extended_Return_Statement\n+        or else No (Activation_Chain_Entity (Context))\n       then\n          --  Since extended return statements do not store the entity of the\n          --  chain, examine the return object declarations to avoid creating\n          --  a duplicate.\n \n-         if Nkind (Par) = N_Extended_Return_Statement\n-           and then Has_Activation_Chain (Par)\n+         if Nkind (Context) = N_Extended_Return_Statement\n+           and then Has_Activation_Chain (Context)\n          then\n             return;\n          end if;\n \n          declare\n+            Loc   : constant Source_Ptr := Sloc (Context);\n             Chain : Entity_Id;\n             Decl  : Node_Id;\n \n@@ -943,19 +924,29 @@ package body Exp_Ch9 is\n             --  Activate_Tasks. Task activation is the responsibility of the\n             --  caller.\n \n-            if Nkind (Par) /= N_Extended_Return_Statement then\n-               Set_Activation_Chain_Entity (Par, Chain);\n+            if Nkind (Context) /= N_Extended_Return_Statement then\n+               Set_Activation_Chain_Entity (Context, Chain);\n             end if;\n \n             Decl :=\n-              Make_Object_Declaration (Sloc (Par),\n+              Make_Object_Declaration (Loc,\n                 Defining_Identifier => Chain,\n                 Aliased_Present     => True,\n                 Object_Definition   =>\n-                  New_Reference_To (RTE (RE_Activation_Chain), Sloc (Par)));\n+                  New_Reference_To (RTE (RE_Activation_Chain), Loc));\n \n             Prepend_To (Decls, Decl);\n-            Analyze (Decl);\n+\n+            --  Ensure that the _chain appears in the proper scope of the\n+            --  context.\n+\n+            if Context_Id /= Current_Scope then\n+               Push_Scope (Context_Id);\n+               Analyze (Decl);\n+               Pop_Scope;\n+            else\n+               Analyze (Decl);\n+            end if;\n          end;\n       end if;\n    end Build_Activation_Chain_Entity;\n@@ -1189,8 +1180,7 @@ package body Exp_Ch9 is\n           Subtype_Mark        => New_Reference_To (Standard_Integer, Loc),\n           Name                => Name_Id);\n \n-      Insert_Before (Related_Node, Ren_Decl);\n-      Analyze (Ren_Decl);\n+      Insert_Action (Related_Node, Ren_Decl);\n \n       Set_Master_Id (Typ, Master_Id);\n    end Build_Class_Wide_Master;\n@@ -2885,43 +2875,51 @@ package body Exp_Ch9 is\n    -- Build_Master_Entity --\n    -------------------------\n \n-   procedure Build_Master_Entity\n-     (Id          : Entity_Id;\n-      Use_Current : Boolean := False)\n-   is\n-      Loc         : constant Source_Ptr := Sloc (Id);\n-      Context     : Node_Id;\n-      Master_Decl : Node_Id;\n-      Master_Scop : Entity_Id;\n+   procedure Build_Master_Entity (Obj_Or_Typ : Entity_Id) is\n+      Loc        : constant Source_Ptr := Sloc (Obj_Or_Typ);\n+      Context    : Node_Id;\n+      Context_Id : Entity_Id;\n+      Decl       : Node_Id;\n+      Decls      : List_Id;\n+      Par        : Node_Id;\n \n    begin\n-      if Use_Current then\n-         Master_Scop := Current_Scope;\n+      if Is_Itype (Obj_Or_Typ) then\n+         Par := Associated_Node_For_Itype (Obj_Or_Typ);\n       else\n-         Master_Scop := Find_Master_Scope (Id);\n+         Par := Parent (Obj_Or_Typ);\n       end if;\n \n-      --  Do not create a master if the enclosing scope already has one or if\n-      --  there is no task hierarchy.\n+      --  When creating a master for a record component which is either a task\n+      --  or access-to-task, the enclosing record is the master scope and the\n+      --  proper insertion point is the component list.\n \n-      if Has_Master_Entity (Master_Scop)\n-        or else Restriction_Active (No_Task_Hierarchy)\n-      then\n-         return;\n-      end if;\n+      if Is_Record_Type (Current_Scope) then\n+         Context    := Par;\n+         Context_Id := Current_Scope;\n+         Decls      := List_Containing (Context);\n \n-      --  Determine the proper context to insert the master\n+      --  Default case for object declarations and access types. Note that the\n+      --  context is updated to the nearest enclosing body, block, package or\n+      --  return statement.\n \n-      if Is_Access_Type (Id) and then Is_Itype (Id) then\n-         Context := Associated_Node_For_Itype (Id);\n       else\n-         Context := Parent (Id);\n+         Find_Enclosing_Context (Par, Context, Context_Id, Decls);\n+      end if;\n+\n+      --  Do not create a master if one already exists or there is no task\n+      --  hierarchy.\n+\n+      if Has_Master_Entity (Context_Id)\n+        or else Restriction_Active (No_Task_Hierarchy)\n+      then\n+         return;\n       end if;\n \n       --  Create a master, generate:\n       --    _Master : constant Master_Id := Current_Master.all;\n \n-      Master_Decl :=\n+      Decl :=\n         Make_Object_Declaration (Loc,\n           Defining_Identifier =>\n             Make_Defining_Identifier (Loc, Name_uMaster),\n@@ -2931,38 +2929,56 @@ package body Exp_Ch9 is\n             Make_Explicit_Dereference (Loc,\n               New_Reference_To (RTE (RE_Current_Master), Loc)));\n \n-      Insert_Before (Context, Master_Decl);\n-      Analyze (Master_Decl);\n+      --  The master is inserted at the start of the declarative list of the\n+      --  context.\n \n-      --  Mark enclosing scope and its associated construct as task masters\n+      Prepend_To (Decls, Decl);\n \n-      Set_Has_Master_Entity (Master_Scop);\n+      --  In certain cases where transient scopes are involved, the immediate\n+      --  scope is not always the proper master scope. Ensure that the master\n+      --  declaration and entity appear in the same context.\n \n-      while Nkind (Context) /= N_Compilation_Unit loop\n-         Context := Parent (Context);\n+      if Context_Id /= Current_Scope then\n+         Push_Scope (Context_Id);\n+         Analyze (Decl);\n+         Pop_Scope;\n+      else\n+         Analyze (Decl);\n+      end if;\n+\n+      --  Mark the enclosing scope and its associated construct as being task\n+      --  masters.\n \n-         --  If we fall off the top, we are at the outer level, and the\n-         --  environment task is our effective master, so nothing to mark.\n+      Set_Has_Master_Entity (Context_Id);\n \n+      while Present (Context)\n+        and then Nkind (Context) /= N_Compilation_Unit\n+      loop\n          if Nkind_In (Context, N_Block_Statement,\n                                N_Subprogram_Body,\n                                N_Task_Body)\n          then\n-            Set_Is_Task_Master (Context, True);\n-            return;\n+            Set_Is_Task_Master (Context);\n+            exit;\n \n          elsif Nkind (Parent (Context)) = N_Subunit then\n             Context := Corresponding_Stub (Parent (Context));\n          end if;\n+\n+         Context := Parent (Context);\n       end loop;\n    end Build_Master_Entity;\n \n    ---------------------------\n    -- Build_Master_Renaming --\n    ---------------------------\n \n-   procedure Build_Master_Renaming (N : Node_Id; Typ : Entity_Id) is\n-      Loc         : constant Source_Ptr := Sloc (N);\n+   procedure Build_Master_Renaming\n+     (Ptr_Typ : Entity_Id;\n+      Ins_Nod : Node_Id := Empty)\n+   is\n+      Loc         : constant Source_Ptr := Sloc (Ptr_Typ);\n+      Context     : Node_Id;\n       Master_Decl : Node_Id;\n       Master_Id   : Entity_Id;\n \n@@ -2973,20 +2989,34 @@ package body Exp_Ch9 is\n          return;\n       end if;\n \n+      --  Determine the proper context to insert the master renaming\n+\n+      if Present (Ins_Nod) then\n+         Context := Ins_Nod;\n+      elsif Is_Itype (Ptr_Typ) then\n+         Context := Associated_Node_For_Itype (Ptr_Typ);\n+      else\n+         Context := Parent (Ptr_Typ);\n+      end if;\n+\n+      --  Generate:\n+      --    <Ptr_Typ>M : Master_Id renames _Master;\n+\n       Master_Id :=\n         Make_Defining_Identifier (Loc,\n-          New_External_Name (Chars (Typ), 'M'));\n+          New_External_Name (Chars (Ptr_Typ), 'M'));\n \n       Master_Decl :=\n         Make_Object_Renaming_Declaration (Loc,\n           Defining_Identifier => Master_Id,\n           Subtype_Mark        => New_Reference_To (RTE (RE_Master_Id), Loc),\n           Name                => Make_Identifier (Loc, Name_uMaster));\n \n-      Insert_Before (N, Master_Decl);\n-      Analyze (Master_Decl);\n+      Insert_Action (Context, Master_Decl);\n \n-      Set_Master_Id (Typ, Master_Id);\n+      --  The renamed master now services the access type\n+\n+      Set_Master_Id (Ptr_Typ, Master_Id);\n    end Build_Master_Renaming;\n \n    -----------------------------------------\n@@ -4404,7 +4434,7 @@ package body Exp_Ch9 is\n \n             Make_Object_Declaration (Loc,\n               Defining_Identifier => Chain,\n-              Aliased_Present => True,\n+              Aliased_Present     => True,\n               Object_Definition   =>\n                 New_Reference_To (RTE (RE_Activation_Chain), Loc))),\n \n@@ -12017,6 +12047,94 @@ package body Exp_Ch9 is\n             Make_Integer_Literal (Loc, 0)));\n    end Family_Size;\n \n+   ----------------------------\n+   -- Find_Enclosing_Context --\n+   ----------------------------\n+\n+   procedure Find_Enclosing_Context\n+     (N             : Node_Id;\n+      Context       : out Node_Id;\n+      Context_Id    : out Entity_Id;\n+      Context_Decls : out List_Id)\n+   is\n+   begin\n+      --  Traverse the parent chain looking for an enclosing body, block,\n+      --  package or return statement.\n+\n+      Context := Parent (N);\n+      while not Nkind_In (Context, N_Block_Statement,\n+                                   N_Entry_Body,\n+                                   N_Extended_Return_Statement,\n+                                   N_Package_Body,\n+                                   N_Package_Declaration,\n+                                   N_Subprogram_Body,\n+                                   N_Task_Body)\n+      loop\n+         Context := Parent (Context);\n+      end loop;\n+\n+      --  Extract the constituents of the context\n+\n+      if Nkind (Context) = N_Extended_Return_Statement then\n+         Context_Decls := Return_Object_Declarations (Context);\n+         Context_Id    := Return_Statement_Entity (Context);\n+\n+      --  Package declarations and bodies use a common library-level activation\n+      --  chain or task master, therefore return the package declaration as the\n+      --  proper carrier for the appropriate flag.\n+\n+      elsif Nkind (Context) = N_Package_Body then\n+         Context_Decls := Declarations (Context);\n+         Context_Id    := Corresponding_Spec (Context);\n+         Context       := Parent (Context_Id);\n+\n+         if Nkind (Context) = N_Defining_Program_Unit_Name then\n+            Context := Parent (Parent (Context));\n+         else\n+            Context := Parent (Context);\n+         end if;\n+\n+      elsif Nkind (Context) = N_Package_Declaration then\n+         Context_Decls := Visible_Declarations (Specification (Context));\n+         Context_Id    := Defining_Unit_Name (Specification (Context));\n+\n+         if Nkind (Context_Id) = N_Defining_Program_Unit_Name then\n+            Context_Id := Defining_Identifier (Context_Id);\n+         end if;\n+\n+      else\n+         Context_Decls := Declarations (Context);\n+\n+         if Nkind (Context) = N_Block_Statement then\n+            Context_Id := Entity (Identifier (Context));\n+\n+         elsif Nkind (Context) = N_Entry_Body then\n+            Context_Id := Defining_Identifier (Context);\n+\n+         elsif Nkind (Context) = N_Subprogram_Body then\n+            if Present (Corresponding_Spec (Context)) then\n+               Context_Id := Corresponding_Spec (Context);\n+            else\n+               Context_Id := Defining_Unit_Name (Specification (Context));\n+\n+               if Nkind (Context_Id) = N_Defining_Program_Unit_Name then\n+                  Context_Id := Defining_Identifier (Context_Id);\n+               end if;\n+            end if;\n+\n+         elsif Nkind (Context) = N_Task_Body then\n+            Context_Id := Corresponding_Spec (Context);\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+      end if;\n+\n+      pragma Assert (Present (Context));\n+      pragma Assert (Present (Context_Id));\n+      pragma Assert (Present (Context_Decls));\n+   end Find_Enclosing_Context;\n+\n    -----------------------\n    -- Find_Master_Scope --\n    -----------------------"}, {"sha": "3bbbf0dc719d4c6cb536c4bb0da67e5fc36b8bbe", "filename": "gcc/ada/exp_ch9.ads", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fexp_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fexp_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.ads?ref=1a36a0cd695e3254367fc01d371ae23f3d3f50fa", "patch": "@@ -60,24 +60,22 @@ package Exp_Ch9 is\n    --  protected type. The statements are wrapped inside a block due to a local\n    --  declaration.\n \n-   procedure Build_Master_Entity\n-     (Id          : Entity_Id;\n-      Use_Current : Boolean := False);\n+   procedure Build_Master_Entity (Obj_Or_Typ : Entity_Id);\n    --  Given the name of an object or a type which is either a task, contains\n    --  tasks or designates tasks, create a _master in the appropriate scope\n-   --  which captures the value of Current_Master. Mark the enclosing body as\n-   --  being a task master. A _master is built to avoid multiple expensive\n-   --  calls to Current_Master and to facilitate object initialization. Flag\n-   --  Use_Current ensures that the master scope is the current scope.\n-\n-   procedure Build_Master_Renaming (N : Node_Id; Typ : Entity_Id);\n-   --  Given an access type Typ and a declaration N of a designated type that\n-   --  is either a task or contains tasks, create a renaming of the form:\n+   --  which captures the value of Current_Master. Mark the nearest enclosing\n+   --  body or block as being a task master.\n+\n+   procedure Build_Master_Renaming\n+     (Ptr_Typ : Entity_Id;\n+      Ins_Nod : Node_Id := Empty);\n+   --  Given an access type Ptr_Typ whose designated type is either a task or\n+   --  contains tasks, create a renaming of the form:\n    --\n-   --     TypM : Master_Id renames _Master;\n+   --     <Ptr_Typ>M : Master_Id renames _Master;\n    --\n-   --  where _master denotes the task master of the enclosing context. The\n-   --  renaming declaration is inserted before N.\n+   --  where _master denotes the task master of the enclosing context. Ins_Nod\n+   --  is used to provide a specific insertion node for the renaming.\n \n    function Build_Private_Protected_Declaration (N : Node_Id) return Entity_Id;\n    --  A subprogram body without a previous spec that appears in a protected"}, {"sha": "70994255f92f5d497bb580ceaa7186a984d2e6f1", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 106, "deletions": 60, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=1a36a0cd695e3254367fc01d371ae23f3d3f50fa", "patch": "@@ -192,7 +192,7 @@ AdaCore@*\n * Stack Related Facilities::\n * Verifying Properties Using gnatcheck::\n * Creating Sample Bodies Using gnatstub::\n-* Creating Test Drivers Using gnattest::\n+* Creating Unit Tests Using gnattest::\n * Generating Ada Bindings for C and C++ headers::\n * Other Utility Programs::\n * Running and Debugging Ada Programs::\n@@ -469,18 +469,18 @@ Sample Bodies Using gnatstub\n * Running gnatstub::\n * Switches for gnatstub::\n \n-Creating Test Drivers Using gnattest\n+Creating Unit Tests Using gnattest\n \n * Running gnattest::\n * Switches for gnattest::\n * Project Attributes for gnattest::\n-* Simple Test Driver::\n+* Simple Example::\n * Setting Up and Tearing Down Testing Environment::\n-* Reusing Previously Written Tests::\n+* Regenerating Tests::\n * Default Test Behavior::\n * Testing Primitive Operations of Tagged Types::\n * Test Inheritance::\n-* Liskov Substitution Principle Check::\n+* Tagged Types Substitutability Testing::\n * Testing with Contracts::\n * Additional Tests::\n * Current Limitations::\n@@ -831,7 +831,7 @@ a utility that checks Ada code against a set of rules.\n a utility that generates empty but compilable bodies for library units.\n \n @item\n-@ref{Creating Test Drivers Using gnattest}, discusses @code{gnattest},\n+@ref{Creating Unit Tests Using gnattest}, discusses @code{gnattest},\n a utility that generates unit testing templates for library units.\n \n @item\n@@ -17666,38 +17666,40 @@ Verbose mode: generate version information.\n @end table\n \n @c *********************************\n-@node Creating Test Drivers Using gnattest\n-@chapter Creating Test Drivers Using @command{gnattest}\n+@node Creating Unit Tests Using gnattest\n+@chapter Creating Unit Tests Using @command{gnattest}\n @findex gnattest\n \n @noindent\n-@command{gnattest} is an ASIS-based utility that creates template tests\n-(test stubs) as well as test driver infrastructure (harness) for unit testing\n-of Ada source code.\n+@command{gnattest} is an ASIS-based utility that creates unit tests stubs\n+as well as a test driver infrastructure (harness). @command{gnattest} creates\n+a stub for each visible subprogram in the packages under consideration when\n+they do not exist already.\n \n In order to process source files from the project, @command{gnattest} has to\n-semantically analyze these Ada sources. Therefore, test templates can only be\n+semantically analyze these Ada sources. Therefore, test stubs can only be\n generated for legal Ada units. If a unit is dependent on some other units,\n those units should be among source files of the project or of other projects\n imported by this one.\n \n-Generated stubs and harness are based on AUnit testing framework. AUnit\n-framework is an Ada adaptation of Java and C++ unit testing frameworks.\n-While it is advised that gnattest users read AUnit manual, deep knowledge\n-of AUnit is not necessary for using gnattest. For correct operation of\n-@command{gnattest} AUnit should be installed on default project path.\n-\n+Generated stubs and harness are based on the AUnit testing framework. AUnit is\n+an Ada adaptation of the xxxUnit testing frameworks similar to JUnit for Java or\n+CppUnit for C++. While it is advised that gnattest users read AUnit manual, deep\n+knowledge of AUnit is not necessary for using gnattest. For correct operation of\n+@command{gnattest} AUnit should be installed and aunit.gpr must be on the\n+project path. This happens automatically when Aunit is installed at its default\n+location.\n @menu\n * Running gnattest::\n * Switches for gnattest::\n * Project Attributes for gnattest::\n-* Simple Test Driver::\n+* Simple Example::\n * Setting Up and Tearing Down Testing Environment::\n-* Reusing Previously Written Tests::\n+* Regenerating Tests::\n * Default Test Behavior::\n * Testing Primitive Operations of Tagged Types::\n * Test Inheritance::\n-* Liskov Substitution Principle Check::\n+* Tagged Types Substitutability Testing::\n * Testing with Contracts::\n * Additional Tests::\n * Current Limitations::\n@@ -17710,18 +17712,19 @@ of AUnit is not necessary for using gnattest. For correct operation of\n @command{gnattest} has the command-line interface of the form\n \n @smallexample\n-@c $ gnattest @var{-Pprojname} @ovar{switches} @var{filename} @ovar{directory}\n+@c $ gnattest @var{-Pprojname} @ovar{switches} @ovar{filename} @ovar{directory}\n @c Expanding @ovar macro inline (explanation in macro def comments)\n-$ gnattest @var{-Pprojname} @r{[}@var{--harness-dir=dirname}@r{]} @r{[}@var{switches}@r{]} @var{filename} @r{[}-cargs @var{gcc_switches}@r{]}\n+$ gnattest @var{-Pprojname} @r{[}@var{--harness-dir=dirname}@r{]} @r{[}@var{switches}@r{]} @r{[}@var{filename}@r{]} @r{[}-cargs @var{gcc_switches}@r{]}\n @end smallexample\n \n @noindent\n where\n @table @var\n \n @item -Pprojname\n-specifies the project that allow locating the source files. If no [filenames]\n-are provided on the command line, all project sources are used as input.\n+specifies the project that allow locating the source files. When no [filenames]\n+are provided on the command line, all project sources are used as input. This\n+switch is mandatory.\n \n @item --harness-dir=dirname\n specifies directory to put harness packages and project file for the test\n@@ -17746,6 +17749,35 @@ is an optional sequence of switches as described in the next section\n \n @end table\n \n+@command{gnattest} results can be found in two different places.\n+\n+@itemize @bullet\n+@item automatic harness\n+the harnessing code which is located in the harness-dir as specified on the\n+comand line or in the project file. All this code is generated completely\n+automatically and can be destroyed and regenerated at will. It is not\n+recommended to modify manually this code since it might be overridden\n+easily. The entry point in this harnessing code is the project file called\n+@command{test_driver.gpr}. Tests can be compiled and run using a command\n+such as:\n+\n+@smallexample\n+gnatmake -P<harness-dir>/test_driver\n+test_runner\n+@end smallexample\n+\n+@item actual unit test stubs\n+a test stub for each visible subprogram is created in a separate file, if it\n+doesn't exist already. By default, those separate test files are located in a\n+\"tests\" directory that is created in the directory containing the source file\n+itself. if it is not appropriate to create the tests in subdirs of the source,\n+option @option{--separate-root} can be used. So let say for instance that\n+a source file my_unit.ads in directory src contains a visible subprogram Proc.\n+Then, the corresponding unit test will be found in file\n+src/tests/my_unit-tests-proc_<code>.adb. <code> is an signature encoding used to\n+differentiate test names in case of overloading.\n+@end itemize\n+\n @node Switches for gnattest\n @section Switches for @command{gnattest}\n \n@@ -17797,7 +17829,7 @@ will be created by default.\n \n @end table\n \n-Separate root ans subdir output modes cannot be used at the same time.\n+@option{--separate_root} and @option{--subdir} switches are mutually exclusive.\n \n @node Project Attributes for gnattest\n @section Project Attributes for @command{gnattest}\n@@ -17837,27 +17869,25 @@ All those attributes can be overridden from command line if needed.\n Other @command{gnattest} switches can also be passed via the project\n file as an attribute list called GNATtest_Switches.\n \n-@node Simple Test Driver\n-@section Simple Test Driver\n+@node Simple Example\n+@section Simple Example\n \n @noindent\n \n-@command{gnattest} works with package specifications. The basic functionality\n-of @command{gnattest} is creating one test stub per one subprogram declared\n-in package specification. This can be observes on a very simple example\n+Let's take a very simple example using the first @command{gnattest} example\n located at\n \n @smallexample\n-examples/lib1\n+<install_prefix>/share/examples/gnattest/lib1\n @end smallexample\n \n-This is a simple package containing one subprogram. By running gnattest\n+This project contains a simple package containing one subprogram. By running gnattest\n \n @smallexample\n $ gnattest --harness-dir=driver -Plib1.gpr\n @end smallexample\n \n-a test driver is created. It can be compiled and run:\n+a test driver is created in dir \"driver\". It can be compiled and run:\n \n @smallexample\n $ cd driver\n@@ -17870,20 +17900,20 @@ Since no special output option was specified the test package Lib1.Tests\n is located in\n \n @smallexample\n-examples/lib1/src/tests\n+<install_prefix>/share/examples/gnattest/lib1/src/tests\n @end smallexample\n \n-For each package containing testable subprograms a child test package is\n+For each package containing visible subprograms, a child test package is\n generated. It contains one test routine per tested subprogram. Each\n-declaration of test subprogram has a comment cpecifying to which tested\n+declaration of test subprogram has a comment specifying to which tested\n subprogram it corresponds. All the test routines have separated bodies.\n The test routine locates at lib1-tests-test_inc_5eaee3.adb has a single\n statement - procedure Assert. It has two arguments: the boolean expression\n which we want to check and the diagnosis message to display if the condition\n is false.\n \n That is where actual testing code should be written after a proper setup.\n-An actual check can be performed by replacing the stubbing code with\n+An actual check can be performed by replacing the assert statement with\n \n @smallexample @c ada\n Assert (Inc (1) = 2, \"wrong incrementation\");\n@@ -17904,17 +17934,17 @@ User_Tear_Down is called after each test routine. Those two procedures can\n be used to perform necessary initialization and finalization,\n memory allocation etc.\n \n-@node Reusing Previously Written Tests\n-@section Reusing Previously Written Tests\n+@node Regenerating Tests\n+@section Regenerating Tests\n \n @noindent\n \n Bodies of test routines and env_mgmt packages are never overridden after they\n-were created once. As long as the name of the subprogram, full expanded Ada\n-names and order of it's parameters are the same, the old test routine will\n-fit in it's place.\n+have been created once. As long as the name of the subprogram, full expanded Ada\n+names and order of its parameters are the same, the old test routine will\n+fit in it's place and no test stub will be generated for this subprogram.\n \n-This can be demonstrated with the presious example. By uncommenting declaration\n+This can be demonstrated with the previous example. By uncommenting declaration\n and body of function Dec in lib1.ads and lib1.adb, running\n @command{gnattest} on the project and then running the test driver:\n \n@@ -17925,7 +17955,11 @@ gprbuild -Ptest_driver\n test_runner\n @end smallexample\n \n-the old test is not replaced with a stub neither lost.\n+the old test is not replaced with a stub neither lost but a new test stub is\n+created for function Dec.\n+\n+The only way for regenerating tests stubs is t oremove the previously created\n+tests.\n \n @node Default Test Behavior\n @section Default Test Behavior\n@@ -17946,7 +17980,7 @@ passed to gnattest when generating the test driver.\n Passing it to the driver generated on the first example\n \n @smallexample\n-test_runer --stub-default=pass\n+test_runner --stub-default=pass\n @end smallexample\n \n makes both tests pass, even the unimplemented one.\n@@ -17993,8 +18027,8 @@ Thus test types repeat the hierarchy of tested types.\n The User_Set_Up procedure of Env_Mgmt package corresponding to a test package\n of primitive operations of type T assigns Fixture with a reference to an\n object of that exact type T. Notice however, that if the tagged type has\n-discriminants, the User_Set_Up does has only a commented template of setting\n-up the fixture since filling th discriminant with actual value is up\n+discriminants, the User_Set_Up only has a commented template of setting\n+up the fixture since filling the discriminant with actual value is up\n to the user.\n \n The knowledge of the structure if test types allows to have additional testing\n@@ -18005,7 +18039,7 @@ without additional effort. Those possibilities are described below.\n \n @noindent\n \n-Since test type hierarchy repeats the hierarchy of tested types, the\n+Since test type hierarchy mimics the hierarchy of tested types, the\n inheritance of tests take place. An example of such inheritance can be\n shown by running the test driver generated for second example. As previously\n mentioned, actual tests are already written for this example.\n@@ -18020,20 +18054,32 @@ There are 6 passed tests while there are only 5 testable subprograms. Test\n routine for function Speed has been inherited and ran against objects of the\n derived type.\n \n-@node Liskov Substitution Principle Check\n-@section Liskov Substitution Principle Check\n+@node Tagged Types Substitutability Testing\n+@section Tagged Types Substitutability Testing\n \n @noindent\n \n-Liskov substitution principle (LSP) is a principle in object-oriented\n-programming. It states that, in a computer program if S is a subtype of T,\n+Tagged Types Substitutability Testing is a way of verifying by testing\n+the Liskov substitution principle (LSP). LSP is a principle stating that if\n+S is a subtype of T (in Ada, S is a derived type of tagged type T),\n then objects of type T may be replaced with objects of type S (i.e., objects\n-of type S may be substitutes for objects of type T), without altering any of\n-the desirable properties of that program.\n-\n-In the example used for previous section there clearly have a violation of LSP.\n-The overriding function Adjust_Speed in package Speed2 removes the\n-functionality of the overridden function. Gnattest has a special option to run\n+of type S may be substituted for objects of type T), without altering any of\n+the desirable properties of the program. When the properties of the program are\n+expressed in the form of subprogram pre & postconditions, LSP is formulated\n+as relations between the pre & post of primitive operations and the pre & post\n+of theirs derived operations. The pre of a derived operation should not be\n+stronger that the original pre, and the post of the derived operation should not\n+be weaker than the original post. Those relations insure that verifying if a\n+dyspatching call is safe can be done just with the pre & post of the root\n+operation.\n+\n+Verifying LSP by testing consists in running all the unit tests associated with\n+the primitives of a given tagged type with objects of its derived types.\n+\n+In the example used by the previous section there clearly have a violation of LSP.\n+The overriding primitive Adjust_Speed in package Speed2 removes the\n+functionality of the overridden primitive and thus doesn't respect LSP.\n+Gnattest has a special option to run\n overridden parent tests against objects of the type which have overriding\n primitives.\n \n@@ -18059,7 +18105,7 @@ that have composition of pre- and postcondition of the subprogram an\n \"requires\" and \"ensures\" of the Test_Case (depending on the mode pre- and post\n either count for Nominal mode or do not for Robustness mode).\n \n-The thirg example demonstrates how it works:\n+The third example demonstrates how it works:\n \n @smallexample\n cd examples/lib3"}, {"sha": "d63923cd712141e29de3c2694642fe9fc23b017d", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=1a36a0cd695e3254367fc01d371ae23f3d3f50fa", "patch": "@@ -2015,8 +2015,16 @@ end Work;\n @end smallexample\n \n @noindent\n-An extending project retains all the switches specified in the\n-extended project.\n+All packages that are not declared in the extending project are inherited from\n+the project being extended, with their attributes, with the exception of\n+@code{Linker'Linker_Options} which is never inherited. In particular, an\n+extending project retains all the switches specified in the project being\n+extended.\n+\n+At the project level, if they are not declared in the extending project, some\n+attributes are inherited from the project being extended. They are:\n+@code{Languages}, @code{Main} (for a root non library project) and\n+@code{Library_Name} (for a project extending a library project)\n \n @menu\n * Project Hierarchy Extension::"}, {"sha": "cd833d5d04e5396b52dd3a56c5b560d5d99c9c95", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=1a36a0cd695e3254367fc01d371ae23f3d3f50fa", "patch": "@@ -887,7 +887,7 @@ package body Sem_Ch3 is\n       --  proper Master for the created tasks.\n \n       if Nkind (Related_Nod) = N_Object_Declaration\n-         and then Expander_Active\n+        and then Expander_Active\n       then\n          if Is_Interface (Desig_Type)\n            and then Is_Limited_Record (Desig_Type)\n@@ -899,10 +899,9 @@ package body Sem_Ch3 is\n \n          elsif Has_Task (Desig_Type)\n            and then Comes_From_Source (Related_Nod)\n-           and then not Restriction_Active (No_Task_Hierarchy)\n          then\n-            Build_Master_Entity (Defining_Identifier (Related_Nod), True);\n-            Build_Master_Renaming (Related_Nod, Anon_Type);\n+            Build_Master_Entity (Defining_Identifier (Related_Nod));\n+            Build_Master_Renaming (Anon_Type);\n          end if;\n       end if;\n "}, {"sha": "a92f7e0112967930fcb4cc5470a255c0ae384c4b", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=1a36a0cd695e3254367fc01d371ae23f3d3f50fa", "patch": "@@ -6461,9 +6461,11 @@ package body Sem_Ch6 is\n       if Ada_Version >= Ada_2005 and then Is_Build_In_Place_Function (E) then\n          declare\n             Result_Subt : constant Entity_Id := Etype (E);\n+            Full_Subt   : constant Entity_Id := Available_View (Result_Subt);\n \n-            Discard : Entity_Id;\n+            Discard     : Entity_Id;\n             pragma Warnings (Off, Discard);\n+            Formal_Typ  : Entity_Id;\n \n          begin\n             --  In the case of functions with unconstrained result subtypes,\n@@ -6510,7 +6512,7 @@ package body Sem_Ch6 is\n             --  master of the tasks to be created, and the caller's activation\n             --  chain.\n \n-            if Has_Task (Available_View (Result_Subt)) then\n+            if Has_Task (Full_Subt) then\n                Discard :=\n                  Add_Extra_Formal\n                    (E, RTE (RE_Master_Id),\n@@ -6524,31 +6526,27 @@ package body Sem_Ch6 is\n             --  All build-in-place functions get an extra formal that will be\n             --  passed the address of the return object within the caller.\n \n-            declare\n-               Formal_Type : constant Entity_Id :=\n-                               Create_Itype\n-                                 (E_Anonymous_Access_Type, E,\n-                                  Scope_Id => Scope (E));\n-            begin\n-               Set_Directly_Designated_Type (Formal_Type, Result_Subt);\n-               Set_Etype (Formal_Type, Formal_Type);\n-               Set_Depends_On_Private\n-                 (Formal_Type, Has_Private_Component (Formal_Type));\n-               Set_Is_Public (Formal_Type, Is_Public (Scope (Formal_Type)));\n-               Set_Is_Access_Constant (Formal_Type, False);\n+            Formal_Typ :=\n+              Create_Itype (E_Anonymous_Access_Type, E, Scope_Id => Scope (E));\n \n-               --  Ada 2005 (AI-50217): Propagate the attribute that indicates\n-               --  the designated type comes from the limited view (for\n-               --  back-end purposes).\n+            Set_Directly_Designated_Type (Formal_Typ, Result_Subt);\n+            Set_Etype (Formal_Typ, Formal_Typ);\n+            Set_Depends_On_Private\n+              (Formal_Typ, Has_Private_Component (Formal_Typ));\n+            Set_Is_Public (Formal_Typ, Is_Public (Scope (Formal_Typ)));\n+            Set_Is_Access_Constant (Formal_Typ, False);\n \n-               Set_From_With_Type (Formal_Type, From_With_Type (Result_Subt));\n+            --  Ada 2005 (AI-50217): Propagate the attribute that indicates\n+            --  the designated type comes from the limited view (for back-end\n+            --  purposes).\n \n-               Layout_Type (Formal_Type);\n+            Set_From_With_Type (Formal_Typ, From_With_Type (Result_Subt));\n \n-               Discard :=\n-                 Add_Extra_Formal\n-                   (E, Formal_Type, E, BIP_Formal_Suffix (BIP_Object_Access));\n-            end;\n+            Layout_Type (Formal_Typ);\n+\n+            Discard :=\n+              Add_Extra_Formal\n+                (E, Formal_Typ, E, BIP_Formal_Suffix (BIP_Object_Access));\n          end;\n       end if;\n    end Create_Extra_Formals;"}, {"sha": "43fb39f9ce2db370f6d2350a2fd63b26b262494b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 38, "deletions": 27, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=1a36a0cd695e3254367fc01d371ae23f3d3f50fa", "patch": "@@ -7345,6 +7345,33 @@ package body Sem_Util is\n       end if;\n    end Is_Fully_Initialized_Variant;\n \n+   ----------------------------\n+   -- Is_Inherited_Operation --\n+   ----------------------------\n+\n+   function Is_Inherited_Operation (E : Entity_Id) return Boolean is\n+      Kind : constant Node_Kind := Nkind (Parent (E));\n+   begin\n+      pragma Assert (Is_Overloadable (E));\n+      return Kind = N_Full_Type_Declaration\n+        or else Kind = N_Private_Extension_Declaration\n+        or else Kind = N_Subtype_Declaration\n+        or else (Ekind (E) = E_Enumeration_Literal\n+                  and then Is_Derived_Type (Etype (E)));\n+   end Is_Inherited_Operation;\n+\n+   -------------------------------------\n+   -- Is_Inherited_Operation_For_Type --\n+   -------------------------------------\n+\n+   function Is_Inherited_Operation_For_Type\n+     (E : Entity_Id; Typ : Entity_Id) return Boolean\n+   is\n+   begin\n+      return Is_Inherited_Operation (E)\n+        and then Etype (Parent (E)) = Typ;\n+   end Is_Inherited_Operation_For_Type;\n+\n    -----------------\n    -- Is_Iterator --\n    -----------------\n@@ -7415,33 +7442,6 @@ package body Sem_Util is\n       end if;\n    end Is_LHS;\n \n-   ----------------------------\n-   -- Is_Inherited_Operation --\n-   ----------------------------\n-\n-   function Is_Inherited_Operation (E : Entity_Id) return Boolean is\n-      Kind : constant Node_Kind := Nkind (Parent (E));\n-   begin\n-      pragma Assert (Is_Overloadable (E));\n-      return Kind = N_Full_Type_Declaration\n-        or else Kind = N_Private_Extension_Declaration\n-        or else Kind = N_Subtype_Declaration\n-        or else (Ekind (E) = E_Enumeration_Literal\n-                  and then Is_Derived_Type (Etype (E)));\n-   end Is_Inherited_Operation;\n-\n-   -------------------------------------\n-   -- Is_Inherited_Operation_For_Type --\n-   -------------------------------------\n-\n-   function Is_Inherited_Operation_For_Type\n-     (E : Entity_Id; Typ : Entity_Id) return Boolean\n-   is\n-   begin\n-      return Is_Inherited_Operation (E)\n-        and then Etype (Parent (E)) = Typ;\n-   end Is_Inherited_Operation_For_Type;\n-\n    -----------------------------\n    -- Is_Library_Level_Entity --\n    -----------------------------\n@@ -7462,6 +7462,17 @@ package body Sem_Util is\n       return Enclosing_Dynamic_Scope (E) = Standard_Standard;\n    end Is_Library_Level_Entity;\n \n+   --------------------------------\n+   -- Is_Limited_Class_Wide_Type --\n+   --------------------------------\n+\n+   function Is_Limited_Class_Wide_Type (Typ : Entity_Id) return Boolean is\n+   begin\n+      return\n+        Is_Class_Wide_Type (Typ)\n+          and then Is_Limited_Type (Typ);\n+   end Is_Limited_Class_Wide_Type;\n+\n    ---------------------------------\n    -- Is_Local_Variable_Reference --\n    ---------------------------------"}, {"sha": "2314633b40c7c729d1b7dd6dcdf95b09869c6187", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a36a0cd695e3254367fc01d371ae23f3d3f50fa/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=1a36a0cd695e3254367fc01d371ae23f3d3f50fa", "patch": "@@ -846,6 +846,10 @@ package Sem_Util is\n    --  A library-level declaration is one that is accessible from Standard,\n    --  i.e. a library unit or an entity declared in a library package.\n \n+   function Is_Limited_Class_Wide_Type (Typ : Entity_Id) return Boolean;\n+   --  Given an arbitrary type, determine whether it is a limited class-wide\n+   --  type.\n+\n    function Is_Local_Variable_Reference (Expr : Node_Id) return Boolean;\n    --  Determines whether Expr is a reference to a variable or IN OUT mode\n    --  parameter of the current enclosing subprogram."}]}