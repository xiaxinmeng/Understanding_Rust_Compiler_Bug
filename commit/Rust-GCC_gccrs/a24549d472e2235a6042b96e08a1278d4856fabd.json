{"sha": "a24549d472e2235a6042b96e08a1278d4856fabd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI0NTQ5ZDQ3MmUyMjM1YTYwNDJiOTZlMDhhMTI3OGQ0ODU2ZmFiZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2007-10-03T10:43:42Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2007-10-03T10:43:42Z"}, "message": "re PR c++/15764 (no cleanup if temporary's dtor terminates with an exception)\n\n        PR c++/15764\n        * cp/decl.c (wrap_cleanups_r): New fn.\n        (wrap_temporary_cleanups): New fn.\n        (initialize_local_var): Call it.\n        * tree-eh.c (same_handler_p): New fn.\n        (optimize_double_finally): New fn.\n        (refactor_eh_r): New fn.\n        (refactor_eh): New fn.\n        (pass_refactor_eh): New pass.\n        * tree-pass.h: Declare it.\n        * passes.c (init_optimization_passes): Add it.\n\nFrom-SVN: r128979", "tree": {"sha": "450766beb0e73108d3ac65ded3af710cf9a23474", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/450766beb0e73108d3ac65ded3af710cf9a23474"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a24549d472e2235a6042b96e08a1278d4856fabd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a24549d472e2235a6042b96e08a1278d4856fabd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a24549d472e2235a6042b96e08a1278d4856fabd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a24549d472e2235a6042b96e08a1278d4856fabd/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7a3c4b3ef39ecd9b3d7aab86f188871d9ea5f11a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a3c4b3ef39ecd9b3d7aab86f188871d9ea5f11a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a3c4b3ef39ecd9b3d7aab86f188871d9ea5f11a"}], "stats": {"total": 329, "additions": 296, "deletions": 33}, "files": [{"sha": "73010ea671c019e56dd79a0dfa94f7d91308e410", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a24549d472e2235a6042b96e08a1278d4856fabd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a24549d472e2235a6042b96e08a1278d4856fabd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a24549d472e2235a6042b96e08a1278d4856fabd", "patch": "@@ -1,3 +1,14 @@\n+2007-10-03  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/15764\n+\t* tree-eh.c (same_handler_p): New fn.\n+\t(optimize_double_finally): New fn.\n+\t(refactor_eh_r): New fn.\n+\t(refactor_eh): New fn.\n+\t(pass_refactor_eh): New pass.\n+\t* tree-pass.h: Declare it.\n+\t* passes.c (init_optimization_passes): Add it.\n+\n 2007-10-03  Doug Kwan  <dougkwan@google.com>\n \tRichard Guenther  <rguenther@suse.de>\n "}, {"sha": "02d549f87e9a9ddb5b10048b4d588b18f12dd23b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a24549d472e2235a6042b96e08a1278d4856fabd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a24549d472e2235a6042b96e08a1278d4856fabd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a24549d472e2235a6042b96e08a1278d4856fabd", "patch": "@@ -1,3 +1,10 @@\n+2007-10-03  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/15764\n+\t* decl.c (wrap_cleanups_r): New fn.\n+\t(wrap_temporary_cleanups): New fn.\n+\t(initialize_local_var): Call it.\n+\n 2007-09-29  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/33094"}, {"sha": "d653fc490d10068aa627dc4ecec41f9579c6d0d3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 76, "deletions": 33, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a24549d472e2235a6042b96e08a1278d4856fabd/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a24549d472e2235a6042b96e08a1278d4856fabd/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a24549d472e2235a6042b96e08a1278d4856fabd", "patch": "@@ -5136,13 +5136,49 @@ make_rtl_for_nonlocal_decl (tree decl, tree init, const char* asmspec)\n     rest_of_decl_compilation (decl, toplev, at_eof);\n }\n \n+/* walk_tree helper for wrap_temporary_cleanups, below.  */\n+\n+static tree\n+wrap_cleanups_r (tree *stmt_p, int *walk_subtrees, void *data)\n+{\n+  if (TYPE_P (*stmt_p))\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (*stmt_p) == TARGET_EXPR)\n+    {\n+      tree guard = (tree)data;\n+      tree tcleanup = TARGET_EXPR_CLEANUP (*stmt_p);\n+\n+      tcleanup = build2 (TRY_CATCH_EXPR, void_type_node, tcleanup, guard);\n+\n+      TARGET_EXPR_CLEANUP (*stmt_p) = tcleanup;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* We're initializing a local variable which has a cleanup GUARD.  If there\n+   are any temporaries used in the initializer INIT of this variable, we\n+   need to wrap their cleanups with TRY_CATCH_EXPR (, GUARD) so that the\n+   variable will be cleaned up properly if one of them throws.  */\n+\n+static void\n+wrap_temporary_cleanups (tree init, tree guard)\n+{\n+  cp_walk_tree_without_duplicates (&init, wrap_cleanups_r, (void *)guard);\n+}\n+\n /* Generate code to initialize DECL (a local variable).  */\n \n static void\n initialize_local_var (tree decl, tree init)\n {\n   tree type = TREE_TYPE (decl);\n   tree cleanup;\n+  int already_used;\n \n   gcc_assert (TREE_CODE (decl) == VAR_DECL\n \t      || TREE_CODE (decl) == RESULT_DECL);\n@@ -5153,46 +5189,53 @@ initialize_local_var (tree decl, tree init)\n       /* If we used it already as memory, it must stay in memory.  */\n       DECL_INITIAL (decl) = NULL_TREE;\n       TREE_ADDRESSABLE (decl) = TREE_USED (decl);\n+      return;\n     }\n \n-  if (DECL_SIZE (decl) && type != error_mark_node)\n-    {\n-      int already_used;\n+  if (type == error_mark_node)\n+    return;\n \n-      /* Compute and store the initial value.  */\n-      already_used = TREE_USED (decl) || TREE_USED (type);\n+  /* Compute and store the initial value.  */\n+  already_used = TREE_USED (decl) || TREE_USED (type);\n \n-      /* Perform the initialization.  */\n-      if (init)\n-\t{\n-\t  int saved_stmts_are_full_exprs_p;\n+  /* Generate a cleanup, if necessary.  */\n+  cleanup = cxx_maybe_build_cleanup (decl);\n \n-\t  gcc_assert (building_stmt_tree ());\n-\t  saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();\n-\t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n-\t  finish_expr_stmt (init);\n-\t  current_stmt_tree ()->stmts_are_full_exprs_p =\n-\t    saved_stmts_are_full_exprs_p;\n-\t}\n+  /* Perform the initialization.  */\n+  if (init)\n+    {\n+      int saved_stmts_are_full_exprs_p;\n \n-      /* Set this to 0 so we can tell whether an aggregate which was\n-\t initialized was ever used.  Don't do this if it has a\n-\t destructor, so we don't complain about the 'resource\n-\t allocation is initialization' idiom.  Now set\n-\t attribute((unused)) on types so decls of that type will be\n-\t marked used. (see TREE_USED, above.)  */\n-      if (TYPE_NEEDS_CONSTRUCTING (type)\n-\t  && ! already_used\n-\t  && TYPE_HAS_TRIVIAL_DESTRUCTOR (type)\n-\t  && DECL_NAME (decl))\n-\tTREE_USED (decl) = 0;\n-      else if (already_used)\n-\tTREE_USED (decl) = 1;\n-    }\n+      /* If we're only initializing a single object, guard the destructors\n+\t of any temporaries used in its initializer with its destructor.\n+\t This isn't right for arrays because each element initialization is\n+\t a full-expression.  */\n+      if (cleanup && TREE_CODE (type) != ARRAY_TYPE)\n+\twrap_temporary_cleanups (init, cleanup);\n \n-  /* Generate a cleanup, if necessary.  */\n-  cleanup = cxx_maybe_build_cleanup (decl);\n-  if (DECL_SIZE (decl) && cleanup)\n+      gcc_assert (building_stmt_tree ());\n+      saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();\n+      current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n+      finish_expr_stmt (init);\n+      current_stmt_tree ()->stmts_are_full_exprs_p =\n+\tsaved_stmts_are_full_exprs_p;\n+    }\n+\n+  /* Set this to 0 so we can tell whether an aggregate which was\n+     initialized was ever used.  Don't do this if it has a\n+     destructor, so we don't complain about the 'resource\n+     allocation is initialization' idiom.  Now set\n+     attribute((unused)) on types so decls of that type will be\n+     marked used. (see TREE_USED, above.)  */\n+  if (TYPE_NEEDS_CONSTRUCTING (type)\n+      && ! already_used\n+      && TYPE_HAS_TRIVIAL_DESTRUCTOR (type)\n+      && DECL_NAME (decl))\n+    TREE_USED (decl) = 0;\n+  else if (already_used)\n+    TREE_USED (decl) = 1;\n+\n+  if (cleanup)\n     finish_decl_cleanup (decl, cleanup);\n }\n "}, {"sha": "25644bc8b5aae14fe10175e51144eee27afa781c", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a24549d472e2235a6042b96e08a1278d4856fabd/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a24549d472e2235a6042b96e08a1278d4856fabd/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=a24549d472e2235a6042b96e08a1278d4856fabd", "patch": "@@ -480,6 +480,7 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_mudflap_1);\n   NEXT_PASS (pass_lower_omp);\n   NEXT_PASS (pass_lower_cf);\n+  NEXT_PASS (pass_refactor_eh);\n   NEXT_PASS (pass_lower_eh);\n   NEXT_PASS (pass_build_cfg);\n   NEXT_PASS (pass_lower_complex_O0);"}, {"sha": "29eae6972d63629e17dd79fb76e220088df3a911", "filename": "gcc/testsuite/g++.dg/eh/init-temp1.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a24549d472e2235a6042b96e08a1278d4856fabd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Finit-temp1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a24549d472e2235a6042b96e08a1278d4856fabd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Finit-temp1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Finit-temp1.C?ref=a24549d472e2235a6042b96e08a1278d4856fabd", "patch": "@@ -0,0 +1,44 @@\n+// PR c++/15764\n+\n+extern \"C\" void abort (); \n+ \n+int counter = 0; \n+int thrown; \n+struct a { \n+  ~a () { if (thrown++ == 0) throw 42; } \n+}; \n+ \n+int f (a const&) { return 1; } \n+int f (a const&, a const&) { return 1; } \n+ \n+struct b { \n+  b (...) { ++counter; } \n+  ~b ()   { --counter; } \n+}; \n+\n+bool p;\n+void g()\n+{\n+  if (p) throw 42;\n+}\n+\n+int main () { \n+  thrown = 0;\n+  try {\n+    b tmp(f (a(), a()));\n+\n+    g();\n+  }  \n+  catch (...) {} \n+\n+  thrown = 0;\n+  try {\n+    b tmp(f (a()));\n+\n+    g();\n+  }  \n+  catch (...) {} \n+ \n+  if (counter != 0) \n+    abort (); \n+} "}, {"sha": "3ea582f7b840030bbd8ae46fd329934b283acee6", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a24549d472e2235a6042b96e08a1278d4856fabd/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a24549d472e2235a6042b96e08a1278d4856fabd/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=a24549d472e2235a6042b96e08a1278d4856fabd", "patch": "@@ -2093,3 +2093,159 @@ maybe_clean_or_replace_eh_stmt (tree old_stmt, tree new_stmt)\n \n   return false;\n }\n+\f\n+/* Returns TRUE if oneh and twoh are exception handlers (op 1 of\n+   TRY_CATCH_EXPR or TRY_FINALLY_EXPR that are similar enough to be\n+   considered the same.  Currently this only handles handlers consisting of\n+   a single call, as that's the important case for C++: a destructor call\n+   for a particular object showing up in multiple handlers.  */\n+\n+static bool\n+same_handler_p (tree oneh, tree twoh)\n+{\n+  tree_stmt_iterator i;\n+  tree ones, twos;\n+  int ai;\n+\n+  i = tsi_start (oneh);\n+  if (!tsi_one_before_end_p (i))\n+    return false;\n+  ones = tsi_stmt (i);\n+\n+  i = tsi_start (twoh);\n+  if (!tsi_one_before_end_p (i))\n+    return false;\n+  twos = tsi_stmt (i);\n+\n+  if (TREE_CODE (ones) != CALL_EXPR\n+      || TREE_CODE (twos) != CALL_EXPR\n+      || !operand_equal_p (CALL_EXPR_FN (ones), CALL_EXPR_FN (twos), 0)\n+      || call_expr_nargs (ones) != call_expr_nargs (twos))\n+    return false;\n+\n+  for (ai = 0; ai < call_expr_nargs (ones); ++ai)\n+    if (!operand_equal_p (CALL_EXPR_ARG (ones, ai),\n+\t\t\t  CALL_EXPR_ARG (twos, ai), 0))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Optimize\n+    try { A() } finally { try { ~B() } catch { ~A() } }\n+    try { ... } finally { ~A() }\n+   into\n+    try { A() } catch { ~B() }\n+    try { ~B() ... } finally { ~A() }\n+\n+   This occurs frequently in C++, where A is a local variable and B is a\n+   temporary used in the initializer for A.  */\n+\n+static void\n+optimize_double_finally (tree one, tree two)\n+{\n+  tree oneh;\n+  tree_stmt_iterator i;\n+\n+  i = tsi_start (TREE_OPERAND (one, 1));\n+  if (!tsi_one_before_end_p (i))\n+    return;\n+\n+  oneh = tsi_stmt (i);\n+  if (TREE_CODE (oneh) != TRY_CATCH_EXPR)\n+    return;\n+\n+  if (same_handler_p (TREE_OPERAND (oneh, 1), TREE_OPERAND (two, 1)))\n+    {\n+      tree twoh;\n+\n+      tree b = TREE_OPERAND (oneh, 0);\n+      TREE_OPERAND (one, 1) = b;\n+      TREE_SET_CODE (one, TRY_CATCH_EXPR);\n+\n+      b = tsi_stmt (tsi_start (b));\n+      twoh = TREE_OPERAND (two, 0);\n+      /* same_handler_p only handles single-statement handlers,\n+\t so there must only be one statement.  */\n+      i = tsi_start (twoh);\n+      tsi_link_before (&i, unshare_expr (b), TSI_SAME_STMT);\n+    }\n+}\n+\n+/* Perform EH refactoring optimizations that are simpler to do when code\n+   flow has been lowered but EH structurs haven't.  */\n+\n+static void\n+refactor_eh_r (tree t)\n+{\n+ tailrecurse:\n+  switch (TREE_CODE (t))\n+    {\n+    case TRY_FINALLY_EXPR:\n+    case TRY_CATCH_EXPR:\n+      refactor_eh_r (TREE_OPERAND (t, 0));\n+      t = TREE_OPERAND (t, 1);\n+      goto tailrecurse;\n+\n+    case CATCH_EXPR:\n+      t = CATCH_BODY (t);\n+      goto tailrecurse;\n+\n+    case EH_FILTER_EXPR:\n+      t = EH_FILTER_FAILURE (t);\n+      goto tailrecurse;\n+\n+    case STATEMENT_LIST:\n+      {\n+\ttree_stmt_iterator i;\n+\ttree one = NULL_TREE, two = NULL_TREE;\n+\t/* Try to refactor double try/finally.  */\n+\tfor (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n+\t  {\n+\t    one = two;\n+\t    two = tsi_stmt (i);\n+\t    if (one && two\n+\t\t&& TREE_CODE (one) == TRY_FINALLY_EXPR\n+\t\t&& TREE_CODE (two) == TRY_FINALLY_EXPR)\n+\t      optimize_double_finally (one, two);\n+\t    if (one)\n+\t      refactor_eh_r (one);\n+\t  }\n+\tif (two)\n+\t  {\n+\t    t = two;\n+\t    goto tailrecurse;\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      /* A type, a decl, or some kind of statement that we're not\n+\t interested in.  Don't walk them.  */\n+      break;\n+    }\n+}\n+\n+static unsigned\n+refactor_eh (void)\n+{\n+  refactor_eh_r (DECL_SAVED_TREE (current_function_decl));\n+  return 0;\n+}\n+\n+struct tree_opt_pass pass_refactor_eh =\n+{\n+  \"ehopt\",\t\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  refactor_eh,\t\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_EH,\t\t\t\t/* tv_id */\n+  PROP_gimple_lcf,\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func,\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};"}, {"sha": "1f748e82635b06feb0999ed56bdddab315af31b1", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a24549d472e2235a6042b96e08a1278d4856fabd/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a24549d472e2235a6042b96e08a1278d4856fabd/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=a24549d472e2235a6042b96e08a1278d4856fabd", "patch": "@@ -246,6 +246,7 @@ extern struct tree_opt_pass pass_mudflap_1;\n extern struct tree_opt_pass pass_mudflap_2;\n extern struct tree_opt_pass pass_remove_useless_stmts;\n extern struct tree_opt_pass pass_lower_cf;\n+extern struct tree_opt_pass pass_refactor_eh;\n extern struct tree_opt_pass pass_lower_eh;\n extern struct tree_opt_pass pass_build_cfg;\n extern struct tree_opt_pass pass_tree_profile;"}]}