{"sha": "63ad61edae6f0ecd498f2d78beadf782e56c9c33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNhZDYxZWRhZTZmMGVjZDQ5OGYyZDc4YmVhZGY3ODJlNTZjOWMzMw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-08-29T21:39:49Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-08-29T21:39:49Z"}, "message": "top level:\n\n\t* c-common.c (declare_function_name): Use func_id_node,\n\tfunction_id_node, and pretty_function_id_node.  Do not make\n\t__func__ visible at file scope.\n\t* c-common.h (c_tree_index): Add CTI_FUNCTION_ID,\n\tCTI_PRETTY_FUNCTION_ID, and CTI_FUNC_ID.\n\t(function_id_node, pretty_function_id_node, func_id_node): New\n\tmacros.\n\t* c-decl.c (init_decl_processing): Initialize function_id_node,\n\tpretty_function_id_node, and func_id_node.\n\t(c_make_fname_decl): Correct comment.\n\n\t* tree.h (struct tree_identifier): Constify pointer member.\n\n\t* c-decl.c (pushdecl, implicit_decl_warning): Constify a char *.\n\t* c-pragma.h (struct weak_syms): Constify name and value members.\n\t(add_weak): Constify arguments.\n\n\t* calls.c (special_function_p): Constify a char *.\n\t(expand_call): Remove variable which is initialized and then\n\tnever used.\n\t* dependence.c (struct def_use, struct induction, struct subscript):\n\tConstify 'variable' member.\n\t(get_low_bound, have_induction_variable): Constify char * argument.\n\t(find_induction_variable): Add braces to avoid dangling else.\n\t(classify_dependence): Constify char * arrays.\n\t* profile.c (output_func_start_profiler): Constify a char *.\n\t* stor-layout.c (finalize_record_size): Constify a char *.\n\t* tree.c (is_attribute_p): Constify a char *.\n\t* varasm.c (add_weak, remove_from_pending_weak_list): Constify argument.\n\n\t* varasm.c (make_function_rtl, make_decl_rtl): Rearrange code\n\tfor comprehensibility.  Do not call get_identifier if we did\n\tnot change the DECL_ASSEMBLER_NAME of the decl.  Use alloca to\n\tcreate temporary string constants, not ggc_alloc_string.  No\n\tneed to copy result of ASM_FORMAT_PRIVATE_NAME.  Use const\n\tchar * to hold IDENTIFIER_POINTERs.\nch:\n\t* inout.c (add_enum_to_list): Use DECL_NAME directly, don't get\n\tits IDENTIFIER_POINTER and immediately call get_identifier on it.\n\t* lex.c (yywrap): Constify a char *.\ncp:\n\t* class.c (build_secondary_vtable): Constify a char *.\n\t* decl.c (init_decl_processing): Initialize function_id_node,\n\tpretty_function_id_node, and func_id_node.\n\t* input.c (struct input_source): Constify 'str'.\n\t(feed_input): Constify first argument.\n\t* mangle.c (write_identifier): Constify argument.\n\t* pt.c (mangle_class_name_for_template): Constify argument.\nf:\n\t* ansify.c: Use #line, not # <number>.\njava:\n\t* jcf-parse.c (set_source_filename): Constify a char *.\n\t* jcf-write.c (append_innerclasses_attribute,\n\tmake_class_file_name): Constify a char *.  Don't recycle a\n\tvariable for an unrelated purpose.\n\t* parse.y: (build_alias_initializer_parameter_list): Constify a char *.\n\t(breakdown_qualified): Do not modify IDENTIFIER_POINTER strings.\n\nFrom-SVN: r36055", "tree": {"sha": "f12dafe607163b1a32d59a3f95160157c959dc7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f12dafe607163b1a32d59a3f95160157c959dc7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63ad61edae6f0ecd498f2d78beadf782e56c9c33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63ad61edae6f0ecd498f2d78beadf782e56c9c33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63ad61edae6f0ecd498f2d78beadf782e56c9c33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63ad61edae6f0ecd498f2d78beadf782e56c9c33/comments", "author": null, "committer": null, "parents": [{"sha": "cee58bc005408e87d6b6ba77adf4f288e9a34b9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cee58bc005408e87d6b6ba77adf4f288e9a34b9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cee58bc005408e87d6b6ba77adf4f288e9a34b9c"}], "stats": {"total": 548, "additions": 318, "deletions": 230}, "files": [{"sha": "3ef282b1621827812d98997b8b4f372ca55f0b50", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -1,3 +1,42 @@\n+2000-08-29  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* c-common.c (declare_function_name): Use func_id_node,\n+\tfunction_id_node, and pretty_function_id_node.  Do not make\n+\t__func__ visible at file scope.   \n+\t* c-common.h (c_tree_index): Add CTI_FUNCTION_ID,\n+\tCTI_PRETTY_FUNCTION_ID, and CTI_FUNC_ID.\n+\t(function_id_node, pretty_function_id_node, func_id_node): New\n+\tmacros.\n+\t* c-decl.c (init_decl_processing): Initialize function_id_node,\n+\tpretty_function_id_node, and func_id_node.\n+\t(c_make_fname_decl): Correct comment.\n+\n+\t* tree.h (struct tree_identifier): Constify pointer member.\n+\n+\t* c-decl.c (pushdecl, implicit_decl_warning): Constify a char *.\n+\t* c-pragma.h (struct weak_syms): Constify name and value members.\n+\t(add_weak): Constify arguments.   \n+\n+\t* calls.c (special_function_p): Constify a char *.\n+\t(expand_call): Remove variable which is initialized and then\n+\tnever used.\n+\t* dependence.c (struct def_use, struct induction, struct subscript):\n+\tConstify 'variable' member.\n+\t(get_low_bound, have_induction_variable): Constify char * argument.\n+\t(find_induction_variable): Add braces to avoid dangling else.\n+\t(classify_dependence): Constify char * arrays.\n+\t* profile.c (output_func_start_profiler): Constify a char *.\n+\t* stor-layout.c (finalize_record_size): Constify a char *.\n+\t* tree.c (is_attribute_p): Constify a char *.\n+\t* varasm.c (add_weak, remove_from_pending_weak_list): Constify argument.\n+\n+\t* varasm.c (make_function_rtl, make_decl_rtl): Rearrange code\n+\tfor comprehensibility.  Do not call get_identifier if we did\n+\tnot change the DECL_ASSEMBLER_NAME of the decl.  Use alloca to\n+\tcreate temporary string constants, not ggc_alloc_string.  No\n+\tneed to copy result of ASM_FORMAT_PRIVATE_NAME.  Use const\n+\tchar * to hold IDENTIFIER_POINTERs.\n+\n 2000-08-29  Richard Henderson  <rth@cygnus.com>\n \n \t* config/ia64/ia64.md (muldi3): Use grfr_register_operand"}, {"sha": "7fcdbebfcc7a6721fb20e80e292d66988d8d5358", "filename": "gcc/c-common.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -130,6 +130,12 @@ enum cpp_token cpp_token;\n \n \ttree void_list_node;\n \n+  The identifiers __FUNCTION__, __PRETTY_FUNCTION__, and __func__.\n+\n+\ttree function_id_node;\n+\ttree pretty_function_id_node;\n+\ttree func_id_node;\n+\n */\n \n tree c_global_trees[CTI_MAX];\n@@ -271,13 +277,14 @@ declare_function_name ()\n       else\n \tname = \"\";\n       printable_name = (*decl_printable_name) (current_function_decl, 2);\n+\n+      /* ISO C99 defines __func__, which is a variable, not a string\n+\t constant, and which is not a defined symbol at file scope.  */\n+      (*make_fname_decl) (func_id_node, name, 0);\n     }\n   \n-  (*make_fname_decl) (get_identifier (\"__FUNCTION__\"), name, 0);\n-  (*make_fname_decl) (get_identifier (\"__PRETTY_FUNCTION__\"), printable_name, 1);\n-  /* The ISO C people \"of course\" couldn't use __FUNCTION__ in the\n-     ISO C 99 standard; instead a new variable is invented.  */\n-  (*make_fname_decl) (get_identifier (\"__func__\"), name, 0);\n+  (*make_fname_decl) (function_id_node, name, 0);\n+  (*make_fname_decl) (pretty_function_id_node, printable_name, 1);\n }\n \n /* Given a chain of STRING_CST nodes,"}, {"sha": "2d9e7b0daf008d404edb6de9f82776c7fb09fd96", "filename": "gcc/c-common.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -118,6 +118,11 @@ enum c_tree_index\n     CTI_G77_LONGINT_TYPE,\n     CTI_G77_ULONGINT_TYPE,\n \n+    /* These are not types, but we have to look them up all the time.  */\n+    CTI_FUNCTION_ID,\n+    CTI_PRETTY_FUNCTION_ID,\n+    CTI_FUNC_ID,\n+\n     CTI_MAX\n };\n \n@@ -153,6 +158,10 @@ enum c_tree_index\n #define g77_longint_type_node\t\tc_global_trees[CTI_G77_LONGINT_TYPE]\n #define g77_ulongint_type_node\t\tc_global_trees[CTI_G77_ULONGINT_TYPE]\n \n+#define function_id_node\t\tc_global_trees[CTI_FUNCTION_ID]\n+#define pretty_function_id_node\t\tc_global_trees[CTI_PRETTY_FUNCTION_ID]\n+#define func_id_node\t\t\tc_global_trees[CTI_FUNC_ID]\n+\n extern tree c_global_trees[CTI_MAX];\n \n typedef enum c_language_kind"}, {"sha": "6820cedcfccbd3c78b11d9cdcdae062c3a60e45a", "filename": "gcc/c-decl.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -2439,7 +2439,7 @@ pushdecl (x)\n \t\t   /* No shadow warnings for vars made for inlining.  */\n \t\t   && ! DECL_FROM_INLINE (x))\n \t    {\n-\t      char *id = IDENTIFIER_POINTER (name);\n+\t      const char *id = IDENTIFIER_POINTER (name);\n \n \t      if (TREE_CODE (x) == PARM_DECL\n \t\t  && current_binding_level->level_chain->parm_flag)\n@@ -2560,7 +2560,7 @@ void\n implicit_decl_warning (id)\n      tree id;\n {\n-  char *name = IDENTIFIER_POINTER (id);\n+  const char *name = IDENTIFIER_POINTER (id);\n   if (mesg_implicit_function_declaration == 2)\n     error (\"implicit declaration of function `%s'\", name);\n   else if (mesg_implicit_function_declaration == 1)\n@@ -3187,7 +3187,11 @@ init_decl_processing ()\n \n   pedantic_lvalues = pedantic;\n \n-  /* Create the global bindings for __FUNCTION__ and __PRETTY_FUNCTION__.  */\n+  /* Create the global bindings for __FUNCTION__, __PRETTY_FUNCTION__,\n+     and __func__.  */\n+  function_id_node = get_identifier (\"__FUNCTION__\");\n+  pretty_function_id_node = get_identifier (\"__PRETTY_FUNCTION__\");\n+  func_id_node = get_identifier (\"__func__\");\n   make_fname_decl = c_make_fname_decl;\n   declare_function_name ();\n \n@@ -3217,7 +3221,7 @@ init_decl_processing ()\n    delayed emission of static data, we mark the decl as emitted\n    so it is not placed in the output.  Anything using it must therefore pull\n    out the STRING_CST initializer directly.  This does mean that these names\n-   are string merging candidates, which C99 does not permit.  */\n+   are string merging candidates, which is wrong for C99's __func__.  FIXME.  */\n \n static tree\n c_make_fname_decl (id, name, type_dep)"}, {"sha": "65b1cc4df711d69bcbc4f102397ec7bed1978cdb", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -47,14 +47,14 @@ Boston, MA 02111-1307, USA.  */\n struct weak_syms\n {\n   struct weak_syms * next;\n-  char * name;\n-  char * value;\n+  const char * name;\n+  const char * value;\n };\n \n /* Declared in varasm.c */\n extern struct weak_syms * weak_decls;\n \n-extern int add_weak PARAMS ((char *, char *));\n+extern int add_weak PARAMS ((const char *, const char *));\n #endif /* HANDLE_PRAGMA_WEAK */\n \n "}, {"sha": "ed35daf9a64b88cb43e005080e0ea5b92bc72e60", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -683,8 +683,8 @@ special_function_p (fndecl, flags)\n \t think they are.  */\n       && DECL_CONTEXT (fndecl) == NULL_TREE && TREE_PUBLIC (fndecl))\n     {\n-      char *name = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n-      char *tname = name;\n+      const char *name = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n+      const char *tname = name;\n \n       /* We assume that alloca will always be called by name.  It\n \t makes no sense to pass it as a pointer-to-function to\n@@ -2070,7 +2070,6 @@ expand_call (exp, target, ignore)\n   /* Declaration of the function being called,\n      or 0 if the function is computed (not known by name).  */\n   tree fndecl = 0;\n-  char *name = 0;\n   rtx insn;\n   int try_tail_call = 1;\n   int try_tail_recursion = 1;\n@@ -2289,9 +2288,6 @@ expand_call (exp, target, ignore)\n \treturn temp;\n     }\n \n-  if (fndecl && DECL_NAME (fndecl))\n-    name = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n-\n   /* Figure out the amount to which the stack should be aligned.  */\n #ifdef PREFERRED_STACK_BOUNDARY\n   preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;"}, {"sha": "44049ccd1755cb8e97630df3975b4494b06a0edb", "filename": "gcc/ch/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fch%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fch%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FChangeLog?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -1,3 +1,9 @@\n+2000-08-29  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* inout.c (add_enum_to_list): Use DECL_NAME directly, don't get\n+\tits IDENTIFIER_POINTER and immediately call get_identifier on it.\n+\t* lex.c (yywrap): Constify a char *.\n+\n 2000-08-24  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Make-lang.in (cc1chill): Don't depend on c-iterate.o."}, {"sha": "ff2de0a3619fc1fea2885ca537f878da330bf257", "filename": "gcc/ch/inout.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fch%2Finout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fch%2Finout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Finout.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -130,8 +130,7 @@ static tree add_enum_to_list (type, context)\n       if (wrk->context == context && wrk->type == type)\n \t{\n \t  /* yes, found. look if the ptrdecl is valid in this scope */\n-\t  char  *name = IDENTIFIER_POINTER (DECL_NAME (wrk->ptrdecl));\n-\t  tree   var  = get_identifier (name);\n+\t  tree   var  = DECL_NAME (wrk->ptrdecl);\n \t  tree   decl = lookup_name (var);\n \t    \n \t  if (decl == NULL_TREE)"}, {"sha": "868d8eda03e48cd5e878a1b1a0182fa8ac534918", "filename": "gcc/ch/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fch%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fch%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Flex.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -2158,7 +2158,7 @@ yywrap ()\n   if (next_file_to_seize && !grant_only_flag)\n     {\n       FILE *grt_in = NULL;\n-      char *seizefile_name_chars\n+      const char *seizefile_name_chars\n \t= IDENTIFIER_POINTER (TREE_VALUE (next_file_to_seize));\n \n       /* find a seize file, open it.  If it's not at the path the"}, {"sha": "84954e7a703ee370c42931a15db0a114daf93290", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -1,3 +1,13 @@\n+2000-08-29  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* class.c (build_secondary_vtable): Constify a char *.\n+\t* decl.c (init_decl_processing): Initialize function_id_node,\n+\tpretty_function_id_node, and func_id_node.\n+\t* input.c (struct input_source): Constify 'str'.\n+\t(feed_input): Constify first argument.\n+\t* mangle.c (write_identifier): Constify argument.\n+\t* pt.c (mangle_class_name_for_template): Constify argument.\n+\n 2000-08-29  Mark Mitchell  <mark@codesourcery.com>\n \n \t* typeck.c (mark_addressable): Remove code that pokes around in"}, {"sha": "c10f09d340920f8a03687f4e277738ddfd8543d4", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -855,7 +855,8 @@ build_secondary_vtable (binfo, for_type)\n   tree new_decl;\n   tree offset;\n   tree path = binfo;\n-  char *buf, *buf2;\n+  char *buf;\n+  const char *buf2;\n   char joiner = '_';\n   int i;\n "}, {"sha": "e84232d64b5fbd5f84d9d2a7731cd63e2981e318", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -6671,6 +6671,10 @@ init_decl_processing ()\n     flag_weak = 0;\n \n   /* Create the global bindings for __FUNCTION__ and __PRETTY_FUNCTION__.  */\n+  function_id_node = get_identifier (\"__FUNCTION__\");\n+  pretty_function_id_node = get_identifier (\"__PRETTY_FUNCTION__\");\n+  func_id_node = get_identifier (\"__func__\");\n+\n   make_fname_decl = cp_make_fname_decl;\n   declare_function_name ();\n "}, {"sha": "431fed792a8b1684211914899274f4ce85390b5c", "filename": "gcc/cp/input.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fcp%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fcp%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finput.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -45,7 +45,7 @@ static struct putback_buffer putback = {NULL, 0, -1};\n \n struct input_source {\n   /* saved string */\n-  char *str;\n+  const char *str;\n   int length;\n   /* current position, when reading as input */\n   int offset;\n@@ -67,7 +67,7 @@ extern unsigned char *yy_cur, *yy_lim;\n extern int yy_get_token ();\n #endif\n \n-extern void feed_input PARAMS ((char *, int, const char *, int));\n+extern void feed_input PARAMS ((const char *, int, const char *, int));\n extern void put_input PARAMS ((int));\n extern void put_back PARAMS ((int));\n extern int getch PARAMS ((void));\n@@ -109,7 +109,7 @@ free_input (inp)\n inline\n void\n feed_input (str, len, file, line)\n-     char *str;\n+     const char *str;\n      int len;\n      const char *file;\n      int line;"}, {"sha": "fb4d166baab326ca5da2622b52d532fe9481e8b6", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -156,7 +156,7 @@ static void write_source_name PARAMS ((tree));\n static void write_number PARAMS ((unsigned HOST_WIDE_INT, int,\n \t\t\t\t  unsigned int));\n static void write_integer_cst PARAMS ((tree));\n-static void write_identifier PARAMS ((char *));\n+static void write_identifier PARAMS ((const char *));\n static void write_special_name_constructor PARAMS ((tree));\n static void write_special_name_destructor PARAMS ((tree));\n static void write_type PARAMS ((tree));\n@@ -1053,7 +1053,7 @@ write_integer_cst (cst)\n \n static void\n write_identifier (identifier)\n-     char *identifier;\n+     const char *identifier;\n {\n   MANGLE_TRACE (\"identifier\", identifier);\n   write_string (identifier);"}, {"sha": "9da72eeed919053d89eefd572313833ded3c101a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -103,7 +103,7 @@ static void add_pending_template PARAMS ((tree));\n static int push_tinst_level PARAMS ((tree));\n static void reopen_tinst_level PARAMS ((tree));\n static tree classtype_mangled_name PARAMS ((tree));\n-static char *mangle_class_name_for_template PARAMS ((char *, tree, tree));\n+static char *mangle_class_name_for_template PARAMS ((const char *, tree, tree));\n static tree tsubst_initializer_list PARAMS ((tree, tree));\n static int list_eq PARAMS ((tree, tree));\n static tree get_class_bindings PARAMS ((tree, tree, tree));\n@@ -3504,7 +3504,7 @@ comp_template_args (oldargs, newargs)\n \n static char *\n mangle_class_name_for_template (name, parms, arglist)\n-     char *name;\n+     const char *name;\n      tree parms, arglist;\n {\n   static struct obstack scratch_obstack;"}, {"sha": "141d9ac9d409f782ceb7e9089175af1853c4b8c2", "filename": "gcc/dependence.c", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fdependence.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fdependence.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdependence.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -89,7 +89,7 @@ typedef struct def_use\n   /* this expression */\n   tree expression;\n   /* our name */\n-  char *variable;\n+  const char *variable;\n   /* def or use */\n   enum def_use_type type;\n   /* status flags */\n@@ -126,7 +126,7 @@ typedef struct loop\n typedef struct induction\n {\n   /* our name */\n-  char *variable;\n+  const char *variable;\n   /* increment.  Currently only +1 or -1 */\n   int  increment;\n   /* lower bound */\n@@ -161,7 +161,7 @@ typedef struct subscript\n   /* Y in X * i + Y */\n   int offset;\n   /* our name */\n-  char *variable;\n+  const char *variable;\n   /* next subscript term.  Currently null. */\n   struct subscript *next;\n } subscript;\n@@ -186,8 +186,8 @@ void init_dependence_analysis PARAMS ((tree));\n static void build_def_use PARAMS ((tree, enum def_use_type));\n static loop* add_loop PARAMS ((tree, tree, int));\n static int find_induction_variable PARAMS ((tree, tree, tree, loop*));\n-static int get_low_bound PARAMS ((tree, char*));\n-static int have_induction_variable PARAMS ((tree, char*));\n+static int get_low_bound PARAMS ((tree, const char*));\n+static int have_induction_variable PARAMS ((tree, const char*));\n static void link_loops PARAMS ((void));\n static void get_node_dependence PARAMS ((void));\n static void check_node_dependence PARAMS ((def_use*));\n@@ -518,17 +518,23 @@ find_induction_variable (init_node, cond_node, incr_node, loop_def)\n       if (TREE_CODE (TREE_OPERAND (cond_node, 0)) == VAR_DECL\n \t  && IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (cond_node, 0))) \n \t     == ind_ptr->variable)\n-\tif (TREE_CODE (TREE_OPERAND (cond_node, 1)) == INTEGER_CST)\n-\t  ind_ptr->high_bound = TREE_INT_CST_LOW (TREE_OPERAND (cond_node, 1));\n-\telse\n-\t  ind_ptr->high_bound = ind_ptr->increment < 0 ? INT_MIN : INT_MAX;\n+\t{\n+\t  if (TREE_CODE (TREE_OPERAND (cond_node, 1)) == INTEGER_CST)\n+\t    ind_ptr->high_bound =\n+\t      TREE_INT_CST_LOW (TREE_OPERAND (cond_node, 1));\n+\t  else\n+\t    ind_ptr->high_bound = ind_ptr->increment < 0 ? INT_MIN : INT_MAX;\n+\t}\n       else if (TREE_CODE (TREE_OPERAND (cond_node, 1)) == VAR_DECL\n \t  && IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (cond_node, 1)))\n \t       == ind_ptr->variable)\n-\tif (TREE_CODE (TREE_OPERAND (cond_node, 0)) == INTEGER_CST)\n-\t  ind_ptr->high_bound = TREE_INT_CST_LOW (TREE_OPERAND (cond_node, 0));\n-\telse\n-\t  ind_ptr->high_bound = ind_ptr->increment < 0 ? INT_MIN : INT_MAX;\n+\t{\n+\t  if (TREE_CODE (TREE_OPERAND (cond_node, 0)) == INTEGER_CST)\n+\t    ind_ptr->high_bound =\n+\t      TREE_INT_CST_LOW (TREE_OPERAND (cond_node, 0));\n+\t  else\n+\t    ind_ptr->high_bound = ind_ptr->increment < 0 ? INT_MIN : INT_MAX;\n+\t}\n       ind_ptr->next = 0;\n       return 1;\n     }\n@@ -540,7 +546,7 @@ find_induction_variable (init_node, cond_node, incr_node, loop_def)\n static int\n get_low_bound (node, variable)\n      tree node;\n-     char *variable;\n+     const char *variable;\n {\n \n   if (TREE_CODE (node) == SCOPE_STMT)\n@@ -577,7 +583,7 @@ get_low_bound (node, variable)\n static int\n have_induction_variable (outer_loop, ind_var)\n      tree outer_loop;\n-     char *ind_var;\n+     const char *ind_var;\n {\n   induction *ind_ptr;\n   loop *loop_ptr;\n@@ -981,8 +987,8 @@ classify_dependence (icoefficients, ocoefficients, complexity, separability,\n      int *separability;\n      int count;\n {\n-  char *iiv_used [MAX_SUBSCRIPTS];\n-  char *oiv_used [MAX_SUBSCRIPTS];\n+  const char *iiv_used [MAX_SUBSCRIPTS];\n+  const char *oiv_used [MAX_SUBSCRIPTS];\n   int ocoeff [MAX_SUBSCRIPTS];\n   int icoeff [MAX_SUBSCRIPTS];\n   int idx, cidx;"}, {"sha": "19ca37992766da6bc599fd54772416fccce57dc5", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -1,3 +1,7 @@\n+2000-08-29  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* ansify.c: Use #line, not # <number>.\n+\n 2000-08-24  Greg McGary  <greg@mcgary.org>\n \n \t* intdoc.c (ARRAY_SIZE): Remove macro."}, {"sha": "ec9910779e78b0bde4579b1285f88720ee5093e2", "filename": "gcc/f/ansify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Ff%2Fansify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Ff%2Fansify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fansify.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -47,7 +47,7 @@ main(int argc, char **argv)\n   printf (\"\\\n /* This file is automatically generated from `%s',\\n\\\n    which you should modify instead.  */\\n\\\n-# 1 \\\"%s\\\"\\n\\\n+#line 1 \\\"%s\\\"\\n\\\n \",\n \t  argv[1], argv[1]);\n "}, {"sha": "4dfa874e472ca38a2da1830a3a6fb9e49f799cbe", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -1,3 +1,12 @@\n+2000-08-29  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* jcf-parse.c (set_source_filename): Constify a char *.\n+\t* jcf-write.c (append_innerclasses_attribute,\n+\tmake_class_file_name): Constify a char *.  Don't recycle a\n+\tvariable for an unrelated purpose.\n+\t* parse.y: (build_alias_initializer_parameter_list): Constify a char *.\n+\t(breakdown_qualified): Do not modify IDENTIFIER_POINTER strings.\n+\n 2000-08-29  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* expr.c (can_widen_reference_to): Fixed indentation."}, {"sha": "02becc074839d194fe7e760e7dfc244e9d8086a0", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -99,7 +99,7 @@ set_source_filename (jcf, index)\n      int index;\n {\n   tree sfname_id = get_name_constant (jcf, index);\n-  char *sfname = IDENTIFIER_POINTER (sfname_id);\n+  const char *sfname = IDENTIFIER_POINTER (sfname_id);\n   if (input_filename != NULL)\n     {\n       int old_len = strlen (input_filename);"}, {"sha": "6a6d7e1cb5bb776dcd28cafd0f312a4698c5707d", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -3161,7 +3161,7 @@ append_innerclasses_attribute (state, class)\n      process: itself, up and down. */\n   while (class && INNER_CLASS_TYPE_P (class))\n     {\n-      char *n;\n+      const char *n;\n \n       decl = TYPE_NAME (class);\n       n = IDENTIFIER_POINTER (DECL_NAME (decl)) + \n@@ -3218,8 +3218,8 @@ static char *\n make_class_file_name (clas)\n      tree clas;\n {\n-  const char *dname, *slash;\n-  char *cname, *r;\n+  const char *dname, *cname, *slash;\n+  char *r;\n   struct stat sb;\n \n   cname = IDENTIFIER_POINTER (identifier_subst (DECL_NAME (TYPE_NAME (clas)),\n@@ -3261,10 +3261,10 @@ make_class_file_name (clas)\n   dname = r + (slash - dname) + 1;\n   while (1)\n     {\n-      cname = strchr (dname, DIR_SEPARATOR);\n-      if (cname == NULL)\n+      char *s = strchr (dname, DIR_SEPARATOR);\n+      if (s == NULL)\n \tbreak;\n-      *cname = '\\0';\n+      *s = '\\0';\n       if (stat (r, &sb) == -1)\n \t{\n \t  /* Try to make it.  */\n@@ -3275,9 +3275,9 @@ make_class_file_name (clas)\n \t      return NULL;\n \t    }\n \t}\n-      *cname = DIR_SEPARATOR;\n+      *s = DIR_SEPARATOR;\n       /* Skip consecutive separators.  */\n-      for (dname = cname + 1; *dname && *dname == DIR_SEPARATOR; ++dname)\n+      for (dname = s + 1; *dname && *dname == DIR_SEPARATOR; ++dname)\n \t;\n     }\n "}, {"sha": "4676153b92ef0b89a4422fc7c0bddcdb7df35c0d", "filename": "gcc/java/parse.y", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -5014,7 +5014,7 @@ build_alias_initializer_parameter_list (mode, class_type, parm, artificial)\n   for (field = TYPE_FIELDS (class_type); field; field = TREE_CHAIN (field))\n     if (FIELD_LOCAL_ALIAS (field))\n       {\n-\tchar *buffer = IDENTIFIER_POINTER (DECL_NAME (field));\n+\tconst char *buffer = IDENTIFIER_POINTER (DECL_NAME (field));\n \ttree purpose = NULL_TREE, value = NULL_TREE, name = NULL_TREE;\n \n \tswitch (mode)\n@@ -10746,12 +10746,14 @@ static int\n breakdown_qualified (left, right, source)\n     tree *left, *right, source;\n {\n-  char *p = IDENTIFIER_POINTER (source), *base;\n+  char *p, *base;\n   int   l = IDENTIFIER_LENGTH (source);\n \n+  base = alloca (l + 1);\n+  memcpy (base, IDENTIFIER_POINTER (source), l + 1);\n+\n   /* Breakdown NAME into REMAINDER . IDENTIFIER */\n-  base = p;\n-  p += (l-1);\n+  p = base + l - 1;\n   while (*p != '.' && p != base)\n     p--;\n \n@@ -10762,8 +10764,7 @@ breakdown_qualified (left, right, source)\n   *p = '\\0';\n   if (right)\n     *right = get_identifier (p+1);\n-  *left = get_identifier (IDENTIFIER_POINTER (source));\n-  *p = '.';\n+  *left = get_identifier (base);\n   \n   return 0;\n }"}, {"sha": "fa6b2302bd26793faa54eeae749e76fa86e33f5b", "filename": "gcc/profile.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -1069,7 +1069,8 @@ void\n output_func_start_profiler ()\n {\n   tree fnname, fndecl;\n-  char *name, *cfnname;\n+  char *name;\n+  const char *cfnname;\n   rtx table_address;\n   enum machine_mode mode = mode_for_size (LONG_TYPE_SIZE, MODE_INT, 0);\n   int save_flag_inline_functions = flag_inline_functions;"}, {"sha": "af219ccbe91120a0e87653dace28d34dac1a3017", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -991,7 +991,7 @@ finalize_record_size (rli)\n \n \t  if (TYPE_NAME (rli->t))\n \t    {\n-\t      char *name;\n+\t      const char *name;\n \n \t      if (TREE_CODE (TYPE_NAME (rli->t)) == IDENTIFIER_NODE)\n \t\tname = IDENTIFIER_POINTER (TYPE_NAME (rli->t));"}, {"sha": "e1a4a7d0eb67b590d0ed34b7d811c536148e956d", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -3786,7 +3786,7 @@ is_attribute_p (attr, ident)\n      tree ident;\n {\n   int ident_len, attr_len;\n-  char *p;\n+  const char *p;\n \n   if (TREE_CODE (ident) != IDENTIFIER_NODE)\n     return 0;"}, {"sha": "e9b0da4d73011c3eb7e31c7d799ca479d8ffced2", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -737,7 +737,7 @@ struct tree_identifier\n {\n   struct tree_common common;\n   int length;\n-  char *pointer;\n+  const char *pointer;\n };\n \n /* In a TREE_LIST node.  */"}, {"sha": "5193dd6cb9c6b2b8aa7c36436bdb487b04797e17", "filename": "gcc/varasm.c", "status": "modified", "additions": 156, "deletions": 164, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ad61edae6f0ecd498f2d78beadf782e56c9c33/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=63ad61edae6f0ecd498f2d78beadf782e56c9c33", "patch": "@@ -175,7 +175,7 @@ static int output_addressed_constants\tPARAMS ((tree));\n static void output_after_function_constants PARAMS ((void));\n static void output_constructor\t\tPARAMS ((tree, int));\n #ifdef ASM_WEAKEN_LABEL\n-static void remove_from_pending_weak_list\tPARAMS ((char *));\n+static void remove_from_pending_weak_list\tPARAMS ((const char *));\n #endif\n #ifdef ASM_OUTPUT_BSS\n static void asm_output_bss\t\tPARAMS ((FILE *, tree, const char *, int, int));\n@@ -519,8 +519,27 @@ void\n make_function_rtl (decl)\n      tree decl;\n {\n-  char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-  char *new_name = name;\n+  const char *name;\n+  const char *new_name;\n+\n+  if (DECL_RTL (decl) != 0)\n+    {\n+      /* ??? Another way to do this would be to do what halfpic.c does\n+\t and maintain a hashed table of such critters.  */\n+      /* ??? Another way to do this would be to pass a flag bit to\n+\t ENCODE_SECTION_INFO saying whether this is a new decl or not.  */\n+      /* Let the target reassign the RTL if it wants.\n+\t This is necessary, for example, when one machine specific\n+\t decl attribute overrides another.  */\n+#ifdef REDO_SECTION_INFO_P\n+      if (REDO_SECTION_INFO_P (decl))\n+\tENCODE_SECTION_INFO (decl);\n+#endif\n+      return;\n+    }\n+\n+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+  new_name = name;\n \n   /* Rename a nested function to avoid conflicts, unless it's a member of\n      a local class, in which case the class name is already unique.  */\n@@ -530,60 +549,45 @@ make_function_rtl (decl)\n       && DECL_RTL (decl) == 0)\n     {\n       char *label;\n-\n-      name = IDENTIFIER_POINTER (DECL_NAME (decl));\n       ASM_FORMAT_PRIVATE_NAME (label, name, var_labelno);\n-      name = ggc_alloc_string (label, -1);\n       var_labelno++;\n+      new_name = label;\n     }\n-  else\n+  /* When -fprefix-function-name is used, every function name is\n+     prefixed.  Even static functions are prefixed because they\n+     could be declared latter.  Note that a nested function name\n+     is not prefixed.  */\n+  else if (flag_prefix_function_name)\n     {\n-      /* When -fprefix-function-name is used, every function name is\n-         prefixed.  Even static functions are prefixed because they\n-         could be declared latter.  Note that a nested function name\n-         is not prefixed.  */\n-      if (flag_prefix_function_name)\n-        {\n-\t  size_t name_len = strlen (name);\n+      size_t name_len = IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (decl));\n+      char *pname;\n \n-          new_name = ggc_alloc_string (NULL, name_len + CHKR_PREFIX_SIZE);\n-\t  memcpy (new_name, CHKR_PREFIX, CHKR_PREFIX_SIZE);\n-\t  memcpy (new_name + CHKR_PREFIX_SIZE, name, name_len + 1);\n-          name = new_name;\n-        }\n+      pname = alloca (name_len + CHKR_PREFIX_SIZE + 1);\n+      memcpy (pname, CHKR_PREFIX, CHKR_PREFIX_SIZE);\n+      memcpy (pname + CHKR_PREFIX_SIZE, name, name_len + 1);\n+      new_name = pname;\n     }\n \n-  if (DECL_RTL (decl) == 0)\n+  if (name != new_name)\n     {\n-      DECL_ASSEMBLER_NAME (decl) = get_identifier (name);\n-      DECL_RTL (decl)\n-\t= gen_rtx_MEM (DECL_MODE (decl),\n-\t\t       gen_rtx_SYMBOL_REF (Pmode, name));\n-\n-      /* Optionally set flags or add text to the name to record\n-\t information such as that it is a function name.  If the name\n-\t is changed, the macro ASM_OUTPUT_LABELREF will have to know\n-\t how to strip this information.  */\n-#ifdef ENCODE_SECTION_INFO\n-      ENCODE_SECTION_INFO (decl);\n-#endif\n+      DECL_ASSEMBLER_NAME (decl) = get_identifier (new_name);\n+      name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n     }\n-  else\n-    {\n-      /* ??? Another way to do this would be to do what halfpic.c does\n-\t and maintain a hashed table of such critters.  */\n-      /* ??? Another way to do this would be to pass a flag bit to\n-\t ENCODE_SECTION_INFO saying whether this is a new decl or not.  */\n-      /* Let the target reassign the RTL if it wants.\n-\t This is necessary, for example, when one machine specific\n-\t decl attribute overrides another.  */\n-#ifdef REDO_SECTION_INFO_P\n-      if (REDO_SECTION_INFO_P (decl))\n-\tENCODE_SECTION_INFO (decl);\n+\n+  DECL_RTL (decl)\n+    = gen_rtx_MEM (DECL_MODE (decl),\n+\t\t   gen_rtx_SYMBOL_REF (Pmode, name));\n+\n+  /* Optionally set flags or add text to the name to record\n+     information such as that it is a function name.  If the name\n+     is changed, the macro ASM_OUTPUT_LABELREF will have to know\n+     how to strip this information.  */\n+#ifdef ENCODE_SECTION_INFO\n+  ENCODE_SECTION_INFO (decl);\n #endif\n-    }\n }\n \n+\n /* Given NAME, a putative register name, discard any customary prefixes.  */\n \n static const char *\n@@ -673,54 +677,57 @@ make_decl_rtl (decl, asmspec, top_level)\n      const char *asmspec;\n      int top_level;\n {\n-  register char *name = 0;\n+  const char *name = 0;\n+  const char *new_name = 0;\n   int reg_number;\n \n-  reg_number = decode_reg_name (asmspec);\n-\n-  if (DECL_ASSEMBLER_NAME (decl) != NULL_TREE)\n-    name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-\n-  if (reg_number == -2)\n+  /* For a duplicate declaration, we can be called twice on the\n+     same DECL node.  Don't discard the RTL already made.  */\n+  if (DECL_RTL (decl) != 0)\n     {\n-      /* ASMSPEC is given, and not the name of a register.  */\n-      size_t len = strlen (asmspec);\n+      /* If the old RTL had the wrong mode, fix the mode.  */\n+      if (GET_MODE (DECL_RTL (decl)) != DECL_MODE (decl))\n+\t{\n+\t  rtx rtl = DECL_RTL (decl);\n+\t  PUT_MODE (rtl, DECL_MODE (decl));\n+\t}\n \n-      name = ggc_alloc_string (NULL, len + 1);\n-      name[0] = '*';\n-      memcpy (&name[1], asmspec, len + 1);\n+      /* ??? Another way to do this would be to do what halfpic.c does\n+\t and maintain a hashed table of such critters.  */\n+      /* ??? Another way to do this would be to pass a flag bit to\n+\t ENCODE_SECTION_INFO saying whether this is a new decl or not.  */\n+      /* Let the target reassign the RTL if it wants.\n+\t This is necessary, for example, when one machine specific\n+\t decl attribute overrides another.  */\n+#ifdef REDO_SECTION_INFO_P\n+      if (REDO_SECTION_INFO_P (decl))\n+\tENCODE_SECTION_INFO (decl);\n+#endif\n+      return;\n     }\n \n-  /* For a duplicate declaration, we can be called twice on the\n-     same DECL node.  Don't discard the RTL already made.  */\n-  if (DECL_RTL (decl) == 0)\n+  new_name = name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\n+  reg_number = decode_reg_name (asmspec);\n+  if (reg_number == -2)\n+    /* ASMSPEC is given, and not the name of a register.  */\n+    new_name = asmspec;\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL && DECL_REGISTER (decl))\n     {\n       /* First detect errors in declaring global registers.  */\n-      if (TREE_CODE (decl) != FUNCTION_DECL\n-\t  && DECL_REGISTER (decl) && reg_number == -1)\n-\terror_with_decl (decl,\n-\t\t\t \"register name not specified for `%s'\");\n-      else if (TREE_CODE (decl) != FUNCTION_DECL\n-\t       && DECL_REGISTER (decl) && reg_number < 0)\n-\terror_with_decl (decl,\n-\t\t\t \"invalid register name for `%s'\");\n-      else if ((reg_number >= 0 || reg_number == -3)\n-\t       && (TREE_CODE (decl) == FUNCTION_DECL\n-\t\t   && ! DECL_REGISTER (decl)))\n-\terror_with_decl (decl,\n-\t\t\t \"register name given for non-register variable `%s'\");\n-      else if (TREE_CODE (decl) != FUNCTION_DECL\n-\t       && DECL_REGISTER (decl)\n-\t       && TYPE_MODE (TREE_TYPE (decl)) == BLKmode)\n+      if (reg_number == -1)\n+\terror_with_decl (decl, \"register name not specified for `%s'\");\n+      else if (reg_number < 0)\n+\terror_with_decl (decl, \"invalid register name for `%s'\");\n+      else if (TYPE_MODE (TREE_TYPE (decl)) == BLKmode)\n \terror_with_decl (decl,\n \t\t\t \"data type of `%s' isn't suitable for a register\");\n-      else if (TREE_CODE (decl) != FUNCTION_DECL && DECL_REGISTER (decl)\n-\t       && ! HARD_REGNO_MODE_OK (reg_number,\n-\t\t\t\t\tTYPE_MODE (TREE_TYPE (decl))))\n+      else if (! HARD_REGNO_MODE_OK (reg_number, TYPE_MODE (TREE_TYPE (decl))))\n \terror_with_decl (decl,\n-\t\t\t \"register number for `%s' isn't suitable for data type\");\n+\t\t\t \"register specified for `%s' isn't suitable for data type\");\n       /* Now handle properly declared static register variables.  */\n-      else if (TREE_CODE (decl) != FUNCTION_DECL && DECL_REGISTER (decl))\n+      else\n \t{\n \t  int nregs;\n \n@@ -754,96 +761,81 @@ make_decl_rtl (decl, asmspec, top_level)\n \t      while (nregs > 0)\n \t\tglobalize_reg (reg_number + --nregs);\n \t    }\n+\n+\t  /* As a register variable, it has no section.  */\n+\t  return;\n \t}\n-      /* Specifying a section attribute on a variable forces it into a\n-         non-.bss section, and thus it cannot be common. */\n-      else if (TREE_CODE (decl) == VAR_DECL\n-\t       && DECL_SECTION_NAME (decl) != NULL_TREE\n-\t       && DECL_INITIAL (decl) == NULL_TREE\n-\t       && DECL_COMMON (decl))\n-          DECL_COMMON (decl) = 0;\n-\n-      /* Now handle ordinary static variables and functions (in memory).\n-\t Also handle vars declared register invalidly.  */\n-      if (DECL_RTL (decl) == 0)\n-\t{\n-\t  /* Can't use just the variable's own name for a variable\n-\t     whose scope is less than the whole file, unless it's a member\n-\t     of a local class (which will already be unambiguous).\n-\t     Concatenate a distinguishing number.  */\n-\t  if (!top_level && !TREE_PUBLIC (decl)\n-\t      && ! (DECL_CONTEXT (decl) && TYPE_P (DECL_CONTEXT (decl)))\n-\t      && asmspec == 0)\n-\t    {\n-\t      char *label;\n+    }\n \n-\t      ASM_FORMAT_PRIVATE_NAME (label, name, var_labelno);\n-\t      name = ggc_alloc_string (label, -1);\n-\t      var_labelno++;\n-\t    }\n+  /* Now handle ordinary static variables and functions (in memory).\n+     Also handle vars declared register invalidly.  */\n \n-\t  if (name == 0)\n-\t    abort ();\n+  if (reg_number >= 0 || reg_number == -3)\n+    error_with_decl (decl,\n+\t\t     \"register name given for non-register variable `%s'\");\n \n-\t  /* When -fprefix-function-name is used, the functions\n-\t     names are prefixed.  Only nested function names are not\n-\t     prefixed.  */\n-\t  if (flag_prefix_function_name && TREE_CODE (decl) == FUNCTION_DECL)\n-\t    {\n-\t      size_t name_len = strlen (name);\n-\t      char *new_name;\n+  /* Specifying a section attribute on a variable forces it into a\n+     non-.bss section, and thus it cannot be common. */\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && DECL_SECTION_NAME (decl) != NULL_TREE\n+      && DECL_INITIAL (decl) == NULL_TREE\n+      && DECL_COMMON (decl))\n+    DECL_COMMON (decl) = 0;\n+\n+  /* Can't use just the variable's own name for a variable\n+     whose scope is less than the whole file, unless it's a member\n+     of a local class (which will already be unambiguous).\n+     Concatenate a distinguishing number.  */\n+  if (!top_level && !TREE_PUBLIC (decl)\n+      && ! (DECL_CONTEXT (decl) && TYPE_P (DECL_CONTEXT (decl)))\n+      && asmspec == 0)\n+    {\n+      char *label;\n+      ASM_FORMAT_PRIVATE_NAME (label, name, var_labelno);\n+      var_labelno++;\n+      new_name = label;\n+    }\n \n-\t      new_name = ggc_alloc_string (NULL, name_len + CHKR_PREFIX_SIZE);\n-\t      memcpy (new_name, CHKR_PREFIX, CHKR_PREFIX_SIZE);\n-\t      memcpy (new_name + CHKR_PREFIX_SIZE, name, name_len + 1);\n-\t      name = new_name;\n-\t    }\n+  /* When -fprefix-function-name is used, the functions\n+     names are prefixed.  Only nested function names are not\n+     prefixed.  */\n+  else if (flag_prefix_function_name && TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      size_t name_len = IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (decl));\n+      char *pname;\n \n-\t  /* If this variable is to be treated as volatile, show its\n-\t     tree node has side effects.   */\n-\t  if ((flag_volatile_global && TREE_CODE (decl) == VAR_DECL\n-\t       && TREE_PUBLIC (decl))\n-\t      || ((flag_volatile_static && TREE_CODE (decl) == VAR_DECL\n-\t\t   && (TREE_PUBLIC (decl) || TREE_STATIC (decl)))))\n-\t    TREE_SIDE_EFFECTS (decl) = 1;\n-\n-\t  DECL_ASSEMBLER_NAME (decl)\n-\t    = get_identifier (name[0] == '*' ? name + 1 : name);\n-\t  DECL_RTL (decl) = gen_rtx_MEM (DECL_MODE (decl),\n-\t\t\t\t\t gen_rtx_SYMBOL_REF (Pmode, name));\n-\t  if (TREE_CODE (decl) != FUNCTION_DECL)\n-\t    set_mem_attributes (DECL_RTL (decl), decl, 1);\n-\n-\t  /* Optionally set flags or add text to the name to record information\n-\t     such as that it is a function name.\n-\t     If the name is changed, the macro ASM_OUTPUT_LABELREF\n-\t     will have to know how to strip this information.  */\n-#ifdef ENCODE_SECTION_INFO\n-\t  ENCODE_SECTION_INFO (decl);\n-#endif\n-\t}\n+      pname = alloca (name_len + CHKR_PREFIX_SIZE + 1);\n+      memcpy (pname, CHKR_PREFIX, CHKR_PREFIX_SIZE);\n+      memcpy (pname + CHKR_PREFIX_SIZE, name, name_len + 1);\n+      new_name = pname;\n     }\n-  else\n+\n+  if (name != new_name)\n     {\n-      /* If the old RTL had the wrong mode, fix the mode.  */\n-      if (GET_MODE (DECL_RTL (decl)) != DECL_MODE (decl))\n-\t{\n-\t  rtx rtl = DECL_RTL (decl);\n-\t  PUT_MODE (rtl, DECL_MODE (decl));\n-\t}\n+      DECL_ASSEMBLER_NAME (decl) = get_identifier (new_name);\n+      name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+    }\n \n-      /* ??? Another way to do this would be to do what halfpic.c does\n-\t and maintain a hashed table of such critters.  */\n-      /* ??? Another way to do this would be to pass a flag bit to\n-\t ENCODE_SECTION_INFO saying whether this is a new decl or not.  */\n-      /* Let the target reassign the RTL if it wants.\n-\t This is necessary, for example, when one machine specific\n-\t decl attribute overrides another.  */\n-#ifdef REDO_SECTION_INFO_P\n-      if (REDO_SECTION_INFO_P (decl))\n-\tENCODE_SECTION_INFO (decl);\n+  /* If this variable is to be treated as volatile, show its\n+     tree node has side effects.   */\n+  if ((flag_volatile_global && TREE_CODE (decl) == VAR_DECL\n+       && TREE_PUBLIC (decl))\n+      || ((flag_volatile_static && TREE_CODE (decl) == VAR_DECL\n+\t   && (TREE_PUBLIC (decl) || TREE_STATIC (decl)))))\n+    TREE_SIDE_EFFECTS (decl) = 1;\n+\n+  DECL_RTL (decl) = gen_rtx_MEM (DECL_MODE (decl),\n+\t\t\t\t gen_rtx_SYMBOL_REF (Pmode, name));\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    set_mem_attributes (DECL_RTL (decl), decl, 1);\n+\n+  /* Optionally set flags or add text to the name to record information\n+     such as that it is a function name.\n+     If the name is changed, the macro ASM_OUTPUT_LABELREF\n+     will have to know how to strip this information.  */\n+#ifdef ENCODE_SECTION_INFO\n+  ENCODE_SECTION_INFO (decl);\n #endif\n-    }\n }\n \n /* Make the rtl for variable VAR be volatile.\n@@ -4656,8 +4648,8 @@ output_constructor (exp, size)\n    \n int\n add_weak (name, value)\n-     char *name;\n-     char *value;\n+     const char *name;\n+     const char *value;\n {\n   struct weak_syms *weak;\n \n@@ -4724,7 +4716,7 @@ weak_finish ()\n #ifdef ASM_WEAKEN_LABEL\n static void\n remove_from_pending_weak_list (name)\n-     char *name ATTRIBUTE_UNUSED;\n+     const char *name ATTRIBUTE_UNUSED;\n {\n #ifdef HANDLE_PRAGMA_WEAK\n   if (HANDLE_PRAGMA_WEAK)"}]}