{"sha": "20de9568b49e663be848a35ce0bb08f63f14b5b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBkZTk1NjhiNDllNjYzYmU4NDhhMzVjZTBiYjA4ZjYzZjE0YjViMg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-10-12T08:27:36Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-10-12T08:27:36Z"}, "message": "c-common.h (c_omp_mark_declare_variant, [...]): Declare.\n\nc-family/\n\t* c-common.h (c_omp_mark_declare_variant,\n\tc_omp_context_selector_matches): Declare.\n\t* c-omp.c: Include attribs.h, gimplify.h, cgraph.h, symbol-summary.h\n\tand hsa-common.h.\n\t(c_omp_get_context_selector): Support second argument NULL.\n\t(c_omp_mark_declare_variant, c_omp_context_selector_matches): New\n\tfunctions.\n\t* c-attribs.c (c_common_attribute_table): Remove \"omp declare variant\"\n\tattribute, add \"omp declare variant base\" and\n\t\"omp declare variant variant\" attributes.\nc/\n\t* c-parser.c (c_parser_omp_context_selector): Improve error recovery.\n\tFor simd properties, put them directly into TREE_VALUE.\n\t(c_finish_omp_declare_variant): Call c_omp_mark_declare_variant.\n\tIf c_omp_context_selector_matches is 0, don't add attribute, otherwise\n\tadd \"omp declare variant base\" attribute rather than\n\t\"omp declare variant\".\ncp/\n\t* parser.c (cp_parser_omp_context_selector): Improve error recovery.\n\tFor simd properties, put them directly into TREE_VALUE.\n\t(cp_finish_omp_declare_variant): Add \"omp declare variant base\"\n\tattribute rather than \"omp declare variant\".\ntestsuite/\n\t* c-c++-common/gomp/declare-variant-2.c: Adjust for error recovery\n\timprovements.  Add new tests.\n\t* c-c++-common/gomp/declare-variant-4.c: New test.\n\t* c-c++-common/gomp/declare-variant-5.c: New test.\n\t* c-c++-common/gomp/declare-variant-6.c: New test.\n\t* c-c++-common/gomp/declare-variant-7.c: New test.\n\nFrom-SVN: r276914", "tree": {"sha": "302f44f3d609ab83db0ef9a7e4ec5aeb4287965e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/302f44f3d609ab83db0ef9a7e4ec5aeb4287965e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20de9568b49e663be848a35ce0bb08f63f14b5b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20de9568b49e663be848a35ce0bb08f63f14b5b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20de9568b49e663be848a35ce0bb08f63f14b5b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20de9568b49e663be848a35ce0bb08f63f14b5b2/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47370f050940a2e140e89fc0d46e808fab206f04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47370f050940a2e140e89fc0d46e808fab206f04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47370f050940a2e140e89fc0d46e808fab206f04"}], "stats": {"total": 575, "additions": 554, "deletions": 21}, "files": [{"sha": "2b63689bc7a778e3a96d5ab823af4e6f0db08bef", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=20de9568b49e663be848a35ce0bb08f63f14b5b2", "patch": "@@ -1,3 +1,16 @@\n+2019-10-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-common.h (c_omp_mark_declare_variant,\n+\tc_omp_context_selector_matches): Declare.\n+\t* c-omp.c: Include attribs.h, gimplify.h, cgraph.h, symbol-summary.h\n+\tand hsa-common.h.\n+\t(c_omp_get_context_selector): Support second argument NULL.\n+\t(c_omp_mark_declare_variant, c_omp_context_selector_matches): New\n+\tfunctions.\n+\t* c-attribs.c (c_common_attribute_table): Remove \"omp declare variant\"\n+\tattribute, add \"omp declare variant base\" and\n+\t\"omp declare variant variant\" attributes.\n+\n 2019-10-11  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c.opt (Wc11-c2x-compat): Add CPP(cpp_warn_c11_c2x_compat)"}, {"sha": "ea273f89a8ef1f13a47e666f69ecc7bfd6f55d8a", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=20de9568b49e663be848a35ce0bb08f63f14b5b2", "patch": "@@ -444,7 +444,9 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_returns_nonnull_attribute, NULL },\n   { \"omp declare simd\",       0, -1, true,  false, false, false,\n \t\t\t      handle_omp_declare_simd_attribute, NULL },\n-  { \"omp declare variant\",    0, -1, true,  false, false, false,\n+  { \"omp declare variant base\", 0, -1, true,  false, false, false,\n+\t\t\t      handle_omp_declare_variant_attribute, NULL },\n+  { \"omp declare variant variant\", 0, -1, true,  false, false, false,\n \t\t\t      handle_omp_declare_variant_attribute, NULL },\n   { \"simd\",\t\t      0, 1, true,  false, false, false,\n \t\t\t      handle_simd_attribute, NULL },\n@@ -3068,7 +3070,7 @@ handle_omp_declare_simd_attribute (tree *, tree, tree, int, bool *)\n   return NULL_TREE;\n }\n \n-/* Handle an \"omp declare variant\" attribute; arguments as in\n+/* Handle an \"omp declare variant {base,variant}\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n \n static tree"}, {"sha": "db7f26eec5350590d13b5c5c7f8f72345141c28c", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=20de9568b49e663be848a35ce0bb08f63f14b5b2", "patch": "@@ -1191,6 +1191,8 @@ extern bool c_omp_predefined_variable (tree);\n extern enum omp_clause_default_kind c_omp_predetermined_sharing (tree);\n extern tree c_omp_check_context_selector (location_t, tree);\n extern tree c_omp_get_context_selector (tree, const char *, const char *);\n+extern void c_omp_mark_declare_variant (location_t, tree, tree);\n+extern int c_omp_context_selector_matches (tree);\n \n /* Return next tree in the chain for chain_next walking of tree nodes.  */\n static inline tree"}, {"sha": "339818817e2805d9bf09a7e8a2bcc1e516f09ed4", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 328, "deletions": 5, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=20de9568b49e663be848a35ce0bb08f63f14b5b2", "patch": "@@ -32,6 +32,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-general.h\"\n #include \"gomp-constants.h\"\n #include \"memmodel.h\"\n+#include \"attribs.h\"\n+#include \"gimplify.h\"\n+#include \"cgraph.h\"\n+#include \"symbol-summary.h\"\n+#include \"hsa-common.h\"\n \n \n /* Complete a #pragma oacc wait construct.  LOC is the location of\n@@ -2236,17 +2241,335 @@ c_omp_check_context_selector (location_t loc, tree ctx)\n }\n \n /* From context selector CTX, return trait-selector with name SEL in\n-   trait-selector-set with name SET if any, or NULL_TREE if not found.  */\n+   trait-selector-set with name SET if any, or NULL_TREE if not found.\n+   If SEL is NULL, return the list of trait-selectors in SET.  */\n \n tree\n c_omp_get_context_selector (tree ctx, const char *set, const char *sel)\n {\n   tree setid = get_identifier (set);\n-  tree selid = get_identifier (sel);\n+  tree selid = sel ? get_identifier (sel) : NULL_TREE;\n   for (tree t1 = ctx; t1; t1 = TREE_CHAIN (t1))\n     if (TREE_PURPOSE (t1) == setid)\n-      for (tree t2 = TREE_VALUE (t1); t2; t2 = TREE_CHAIN (t2))\n-\tif (TREE_PURPOSE (t2) == selid)\n-\t  return t2;\n+      {\n+\tif (sel == NULL)\n+\t  return TREE_VALUE (t1);\n+\tfor (tree t2 = TREE_VALUE (t1); t2; t2 = TREE_CHAIN (t2))\n+\t  if (TREE_PURPOSE (t2) == selid)\n+\t    return t2;\n+      }\n   return NULL_TREE;\n }\n+\n+/* Register VARIANT as variant of some base function marked with\n+   #pragma omp declare variant.  CONSTRUCT is corresponding construct\n+   selector set.  */\n+\n+void\n+c_omp_mark_declare_variant (location_t loc, tree variant, tree construct)\n+{\n+  tree attr = lookup_attribute (\"omp declare variant variant\",\n+\t\t\t\tDECL_ATTRIBUTES (variant));\n+  if (attr == NULL_TREE)\n+    {\n+      attr = tree_cons (get_identifier (\"omp declare variant variant\"),\n+\t\t\tunshare_expr (construct),\n+\t\t\tDECL_ATTRIBUTES (variant));\n+      DECL_ATTRIBUTES (variant) = attr;\n+      return;\n+    }\n+  tree t1 = TREE_VALUE (attr);\n+  tree t2 = construct;\n+  tree simd = get_identifier (\"simd\");\n+  while (t1 && t2)\n+    {\n+      if (TREE_PURPOSE (t1) != TREE_PURPOSE (t2))\n+\tbreak;\n+      if (TREE_PURPOSE (t1) == simd)\n+\t{\n+\t  if ((TREE_VALUE (t1) == NULL_TREE)\n+\t      != (TREE_VALUE (t2) == NULL_TREE))\n+\t    break;\n+\t  if (TREE_VALUE (t1))\n+\t    {\n+\t      struct declare_variant_simd_data {\n+\t\tbool inbranch, notinbranch;\n+\t\ttree simdlen;\n+\t\tauto_vec<tree,16> data_sharing;\n+\t\tauto_vec<tree,16> aligned;\n+\t\tdeclare_variant_simd_data ()\n+\t\t  : inbranch(false), notinbranch(false), simdlen(NULL_TREE) {}\n+\t      } data[2];\n+\t      unsigned int i;\n+\t      for (i = 0; i < 2; i++)\n+\t\tfor (tree c = TREE_VALUE (i ? t2 : t1);\n+\t\t     c; c = OMP_CLAUSE_CHAIN (c))\n+\t\t  {\n+\t\t    vec<tree> *v;\n+\t\t    switch (OMP_CLAUSE_CODE (c))\n+\t\t      {\n+\t\t      case OMP_CLAUSE_INBRANCH:\n+\t\t\tdata[i].inbranch = true;\n+\t\t\tcontinue;\n+\t\t      case OMP_CLAUSE_NOTINBRANCH:\n+\t\t\tdata[i].notinbranch = true;\n+\t\t\tcontinue;\n+\t\t      case OMP_CLAUSE_SIMDLEN:\n+\t\t\tdata[i].simdlen = OMP_CLAUSE_SIMDLEN_EXPR (c);\n+\t\t\tcontinue;\n+\t\t      case OMP_CLAUSE_UNIFORM:\n+\t\t      case OMP_CLAUSE_LINEAR:\n+\t\t\tv = &data[i].data_sharing;\n+\t\t\tbreak;\n+\t\t      case OMP_CLAUSE_ALIGNED:\n+\t\t\tv = &data[i].aligned;\n+\t\t\tbreak;\n+\t\t      default:\n+\t\t\tgcc_unreachable ();\n+\t\t      }\n+\t\t    unsigned HOST_WIDE_INT argno\n+\t\t      = tree_to_uhwi (OMP_CLAUSE_DECL (c));\n+\t\t    if (argno >= v->length ())\n+\t\t      v->safe_grow_cleared (argno + 1);\n+\t\t    (*v)[argno] = c;\n+\t\t  }\n+\t      if (data[0].inbranch != data[1].inbranch\n+\t\t  || data[0].notinbranch != data[1].notinbranch\n+\t\t  || !simple_cst_equal (data[0].simdlen,\n+\t\t\t\t\tdata[1].simdlen)\n+\t\t  || (data[0].data_sharing.length ()\n+\t\t      != data[1].data_sharing.length ())\n+\t\t  || (data[0].aligned.length ()\n+\t\t      != data[1].aligned.length ()))\n+\t\tbreak;\n+\t      tree c1, c2;\n+\t      FOR_EACH_VEC_ELT (data[0].data_sharing, i, c1)\n+\t\t{\n+\t\t  c2 = data[1].data_sharing[i];\n+\t\t  if ((c1 == NULL_TREE) != (c2 == NULL_TREE))\n+\t\t    break;\n+\t\t  if (c1 == NULL_TREE)\n+\t\t    continue;\n+\t\t  if (OMP_CLAUSE_CODE (c1) != OMP_CLAUSE_CODE (c2))\n+\t\t    break;\n+\t\t  if (OMP_CLAUSE_CODE (c1) != OMP_CLAUSE_LINEAR)\n+\t\t    continue;\n+\t\t  if (OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (c1)\n+\t\t      != OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (c2))\n+\t\t    break;\n+\t\t  if (OMP_CLAUSE_LINEAR_KIND (c1)\n+\t\t      != OMP_CLAUSE_LINEAR_KIND (c2))\n+\t\t    break;\n+\t\t  if (!simple_cst_equal (OMP_CLAUSE_LINEAR_STEP (c1),\n+\t\t\t\t\t OMP_CLAUSE_LINEAR_STEP (c2)))\n+\t\t    break;\n+\t\t}\n+\t      if (i < data[0].data_sharing.length ())\n+\t\tbreak;\n+\t      FOR_EACH_VEC_ELT (data[0].aligned, i, c1)\n+\t\t{\n+\t\t  c2 = data[1].aligned[i];\n+\t\t  if ((c1 == NULL_TREE) != (c2 == NULL_TREE))\n+\t\t    break;\n+\t\t  if (c1 == NULL_TREE)\n+\t\t    continue;\n+\t\t  if (!simple_cst_equal (OMP_CLAUSE_ALIGNED_ALIGNMENT (c1),\n+\t\t\t\t\t OMP_CLAUSE_ALIGNED_ALIGNMENT (c2)))\n+\t\t    break;\n+\t\t}\n+\t      if (i < data[0].aligned.length ())\n+\t\tbreak;\n+\t    }\n+\t}\n+      t1 = TREE_CHAIN (t1);\n+      t2 = TREE_CHAIN (t2);\n+    }\n+  if (t1 || t2)\n+    error_at (loc, \"%qD used as a variant with incompatible %<constructor%> \"\n+\t\t   \"selector sets\", variant);\n+}\n+\n+/* Return 1 if context selector matches the current OpenMP context, 0\n+   if it does not and -1 if it is unknown and need to be determined later.\n+   Some properties can be checked right away during parsing (this routine),\n+   others need to wait until the whole TU is parsed, others need to wait until\n+   IPA, others until vectorization.  */\n+\n+int\n+c_omp_context_selector_matches (tree ctx)\n+{\n+  int ret = 1;\n+  for (tree t1 = ctx; t1; t1 = TREE_CHAIN (t1))\n+    {\n+      char set = IDENTIFIER_POINTER (TREE_PURPOSE (t1))[0];\n+      if (set == 'c')\n+\t{\n+\t  /* For now, ignore the construct set.  While something can be\n+\t     determined already during parsing, we don't know until end of TU\n+\t     whether additional constructs aren't added through declare variant\n+\t     unless \"omp declare variant variant\" attribute exists already\n+\t     (so in most of the cases), and we'd need to maintain set of\n+\t     surrounding OpenMP constructs, which is better handled during\n+\t     gimplification.  */\n+\t  ret = -1;\n+\t  continue;\n+\t}\n+      for (tree t2 = TREE_VALUE (t1); t2; t2 = TREE_CHAIN (t2))\n+\t{\n+\t  const char *sel = IDENTIFIER_POINTER (TREE_PURPOSE (t2));\n+\t  switch (*sel)\n+\t    {\n+\t    case 'v':\n+\t      if (set == 'i' && !strcmp (sel, \"vendor\"))\n+\t\tfor (tree t3 = TREE_VALUE (t2); t3; t3 = TREE_CHAIN (t3))\n+\t\t  {\n+\t\t    const char *prop = IDENTIFIER_POINTER (TREE_PURPOSE (t3));\n+\t\t    if (!strcmp (prop, \" score\") || !strcmp (prop, \"gnu\"))\n+\t\t      continue;\n+\t\t    return 0;\n+\t\t  }\n+\t      break;\n+\t    case 'e':\n+\t      if (set == 'i' && !strcmp (sel, \"extension\"))\n+\t\t/* We don't support any extensions right now.  */\n+\t\treturn 0;\n+\t      break;\n+\t    case 'a':\n+\t      if (set == 'i' && !strcmp (sel, \"atomic_default_mem_order\"))\n+\t\t{\n+\t\t  enum omp_memory_order omo\n+\t\t    = ((enum omp_memory_order)\n+\t\t       (omp_requires_mask\n+\t\t\t& OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER));\n+\t\t  if (omo == OMP_MEMORY_ORDER_UNSPECIFIED)\n+\t\t    {\n+\t\t      /* We don't know yet, until end of TU.  */\n+\t\t      ret = -1;\n+\t\t      break;\n+\t\t    }\n+\t\t  tree t3 = TREE_VALUE (t2);\n+\t\t  const char *prop = IDENTIFIER_POINTER (TREE_PURPOSE (t3));\n+\t\t  if (!strcmp (prop, \" score\"))\n+\t\t    {\n+\t\t      t3 = TREE_CHAIN (t3);\n+\t\t      prop = IDENTIFIER_POINTER (TREE_PURPOSE (t3));\n+\t\t    }\n+\t\t  if (!strcmp (prop, \"relaxed\")\n+\t\t      && omo != OMP_MEMORY_ORDER_RELAXED)\n+\t\t    return 0;\n+\t\t  else if (!strcmp (prop, \"seq_cst\")\n+\t\t\t   && omo != OMP_MEMORY_ORDER_SEQ_CST)\n+\t\t    return 0;\n+\t\t  else if (!strcmp (prop, \"acq_rel\")\n+\t\t\t   && omo != OMP_MEMORY_ORDER_ACQ_REL)\n+\t\t    return 0;\n+\t\t}\n+\t      if (set == 'd' && !strcmp (sel, \"arch\"))\n+\t\t/* For now, need a target hook.  */\n+\t\tret = -1;\n+\t      break;\n+\t    case 'u':\n+\t      if (set == 'i' && !strcmp (sel, \"unified_address\"))\n+\t\t{\n+\t\t  if ((omp_requires_mask & OMP_REQUIRES_UNIFIED_ADDRESS) == 0)\n+\t\t    ret = -1;\n+\t\t  break;\n+\t\t}\n+\t      if (set == 'i' && !strcmp (sel, \"unified_shared_memory\"))\n+\t\t{\n+\t\t  if ((omp_requires_mask\n+\t\t       & OMP_REQUIRES_UNIFIED_SHARED_MEMORY) == 0)\n+\t\t    ret = -1;\n+\t\t  break;\n+\t\t}\n+\t      break;\n+\t    case 'd':\n+\t      if (set == 'i' && !strcmp (sel, \"dynamic_allocators\"))\n+\t\t{\n+\t\t  if ((omp_requires_mask\n+\t\t       & OMP_REQUIRES_DYNAMIC_ALLOCATORS) == 0)\n+\t\t    ret = -1;\n+\t\t  break;\n+\t\t}\n+\t      break;\n+\t    case 'r':\n+\t      if (set == 'i' && !strcmp (sel, \"reverse_offload\"))\n+\t\t{\n+\t\t  if ((omp_requires_mask & OMP_REQUIRES_REVERSE_OFFLOAD) == 0)\n+\t\t    ret = -1;\n+\t\t  break;\n+\t\t}\n+\t      break;\n+\t    case 'k':\n+\t      if (set == 'd' && !strcmp (sel, \"kind\"))\n+\t\tfor (tree t3 = TREE_VALUE (t2); t3; t3 = TREE_CHAIN (t3))\n+\t\t  {\n+\t\t    const char *prop = IDENTIFIER_POINTER (TREE_PURPOSE (t3));\n+\t\t    if (!strcmp (prop, \"any\"))\n+\t\t      continue;\n+\t\t    if (!strcmp (prop, \"fpga\"))\n+\t\t      return 0;\t/* Right now GCC doesn't support any fpgas.  */\n+\t\t    if (!strcmp (prop, \"host\"))\n+\t\t      {\n+\t\t\tif (ENABLE_OFFLOADING || hsa_gen_requested_p ())\n+\t\t\t  ret = -1;\n+\t\t\tcontinue;\n+\t\t      }\n+\t\t    if (!strcmp (prop, \"nohost\"))\n+\t\t      {\n+\t\t\tif (ENABLE_OFFLOADING || hsa_gen_requested_p ())\n+\t\t\t  ret = -1;\n+\t\t\telse\n+\t\t\t  return 0;\n+\t\t\tcontinue;\n+\t\t      }\n+\t\t    if (!strcmp (prop, \"cpu\") || !strcmp (prop, \"gpu\"))\n+\t\t      {\n+\t\t\tbool maybe_gpu = false;\n+\t\t\tif (hsa_gen_requested_p ())\n+\t\t\t  maybe_gpu = true;\n+\t\t\telse if (ENABLE_OFFLOADING)\n+\t\t\t  for (const char *c = getenv (\"OFFLOAD_TARGET_NAMES\");\n+\t\t\t       c; )\n+\t\t\t    {\n+\t\t\t      if (!strncmp (c, \"nvptx\", strlen (\"nvptx\"))\n+\t\t\t\t  || !strncmp (c, \"amdgcn\", strlen (\"amdgcn\")))\n+\t\t\t\t{\n+\t\t\t\t  maybe_gpu = true;\n+\t\t\t\t  break;\n+\t\t\t\t}\n+\t\t\t      else if ((c = strchr (c, ',')))\n+\t\t\t\tc++;\n+\t\t\t    }\n+\t\t\tif (!maybe_gpu)\n+\t\t\t  {\n+\t\t\t    if (prop[0] == 'g')\n+\t\t\t      return 0;\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  ret = -1;\n+\t\t\tcontinue;\n+\t\t      }\n+\t\t    /* Any other kind doesn't match.  */\n+\t\t    return 0;\n+\t\t  }\n+\t      break;\n+\t    case 'i':\n+\t      if (set == 'd' && !strcmp (sel, \"isa\"))\n+\t\t/* For now, need a target hook.  */\n+\t\tret = -1;\n+\t      break;\n+\t    case 'c':\n+\t      if (set == 'u' && !strcmp (sel, \"condition\"))\n+\t\tfor (tree t3 = TREE_VALUE (t2); t3; t3 = TREE_CHAIN (t3))\n+\t\t  if (TREE_PURPOSE (t3) == NULL_TREE\n+\t\t      && integer_zerop (TREE_VALUE (t3)))\n+\t\t    return 0;\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  return ret;\n+}"}, {"sha": "5fb386c4b9e18d137295501529a31e64e0a8c1ab", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=20de9568b49e663be848a35ce0bb08f63f14b5b2", "patch": "@@ -1,3 +1,12 @@\n+2019-10-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-parser.c (c_parser_omp_context_selector): Improve error recovery.\n+\tFor simd properties, put them directly into TREE_VALUE.\n+\t(c_finish_omp_declare_variant): Call c_omp_mark_declare_variant.\n+\tIf c_omp_context_selector_matches is 0, don't add attribute, otherwise\n+\tadd \"omp declare variant base\" attribute rather than\n+\t\"omp declare variant\".\n+\n 2019-10-11  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-decl.c (declspecs_add_type): Use pedwarn_c11 for DFP types."}, {"sha": "9d0b2b671f84b9efc5645c2fe0096e73ebbd49b6", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=20de9568b49e663be848a35ce0bb08f63f14b5b2", "patch": "@@ -19219,6 +19219,8 @@ c_parser_omp_context_selector (c_parser *parser, tree set, tree parms)\n \t\t      else\n \t\t\tproperties = tree_cons (NULL_TREE, t, properties);\n \t\t    }\n+\t\t  else\n+\t\t    return error_mark_node;\n \n \t\t  if (c_parser_next_token_is (parser, CPP_COMMA))\n \t\t    c_parser_consume_token (parser);\n@@ -19263,6 +19265,8 @@ c_parser_omp_context_selector (c_parser *parser, tree set, tree parms)\n \t\t  else\n \t\t    properties = tree_cons (NULL_TREE, t, properties);\n \t\t}\n+\t      else\n+\t\treturn error_mark_node;\n \t      break;\n \t    case CTX_PROPERTY_SIMD:\n \t      if (parms == NULL_TREE)\n@@ -19280,7 +19284,7 @@ c_parser_omp_context_selector (c_parser *parser, tree set, tree parms)\n \t\t\t\t\t\t\t == error_mark_node\n \t\t\t\t\t\t\t ? NULL_TREE : parms,\n \t\t\t\t\t\t\t c);\n-\t      properties = tree_cons (NULL_TREE, c, properties);\n+\t      properties = c;\n \t      break;\n \t    default:\n \t      gcc_unreachable ();\n@@ -19389,7 +19393,7 @@ c_parser_omp_context_selector_specification (c_parser *parser, tree parms)\n }\n \n /* Finalize #pragma omp declare variant after FNDECL has been parsed, and put\n-   that into \"omp declare variant\" attribute.  */\n+   that into \"omp declare variant base\" attribute.  */\n \n static void\n c_finish_omp_declare_variant (c_parser *parser, tree fndecl, tree parms)\n@@ -19473,10 +19477,16 @@ c_finish_omp_declare_variant (c_parser *parser, tree fndecl, tree parms)\n       if (variant != error_mark_node)\n \t{\n \t  C_DECL_USED (variant) = 1;\n-\t  tree attr = tree_cons (get_identifier (\"omp declare variant\"),\n-\t\t\t\t build_tree_list (variant, ctx),\n-\t\t\t\t DECL_ATTRIBUTES (fndecl));\n-\t  DECL_ATTRIBUTES (fndecl) = attr;\n+\t  tree construct = c_omp_get_context_selector (ctx, \"construct\", NULL);\n+\t  c_omp_mark_declare_variant (match_loc, variant, construct);\n+\t  if (c_omp_context_selector_matches (ctx))\n+\t    {\n+\t      tree attr\n+\t\t= tree_cons (get_identifier (\"omp declare variant base\"),\n+\t\t\t     build_tree_list (variant, ctx),\n+\t\t\t     DECL_ATTRIBUTES (fndecl));\n+\t      DECL_ATTRIBUTES (fndecl) = attr;\n+\t    }\n \t}\n     }\n \n@@ -19486,7 +19496,7 @@ c_finish_omp_declare_variant (c_parser *parser, tree fndecl, tree parms)\n \n /* Finalize #pragma omp declare simd or #pragma omp declare variant\n    clauses after FNDECL has been parsed, and put that into \"omp declare simd\"\n-   or \"omp declare variant\" attribute.  */\n+   or \"omp declare variant base\" attribute.  */\n \n static void\n c_finish_omp_declare_simd (c_parser *parser, tree fndecl, tree parms,"}, {"sha": "dcae4909d5e10a4e7ffd0a3eab797baa0f09c80c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=20de9568b49e663be848a35ce0bb08f63f14b5b2", "patch": "@@ -1,3 +1,10 @@\n+2019-10-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* parser.c (cp_parser_omp_context_selector): Improve error recovery.\n+\tFor simd properties, put them directly into TREE_VALUE.\n+\t(cp_finish_omp_declare_variant): Add \"omp declare variant base\"\n+\tattribute rather than \"omp declare variant\".\n+\n 2019-10-11  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/92049 - extra error with -fchecking=2."}, {"sha": "9bf690a0efbd5e0632d0f39989087d2a6e8d5d0a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=20de9568b49e663be848a35ce0bb08f63f14b5b2", "patch": "@@ -40488,6 +40488,8 @@ cp_parser_omp_context_selector (cp_parser *parser, tree set, bool has_parms_p)\n \t\t      else\n \t\t\tproperties = tree_cons (NULL_TREE, t, properties);\n \t\t    }\n+\t\t  else\n+\t\t    return error_mark_node;\n \n \t\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n \t\t    cp_lexer_consume_token (parser->lexer);\n@@ -40532,6 +40534,8 @@ cp_parser_omp_context_selector (cp_parser *parser, tree set, bool has_parms_p)\n \t\t  else\n \t\t    properties = tree_cons (NULL_TREE, t, properties);\n \t\t}\n+\t      else\n+\t\treturn error_mark_node;\n \t      break;\n \t    case CTX_PROPERTY_SIMD:\n \t      if (!has_parms_p)\n@@ -40541,11 +40545,10 @@ cp_parser_omp_context_selector (cp_parser *parser, tree set, bool has_parms_p)\n \t\t\t    \"%<metadirective%>\");\n \t\t  return error_mark_node;\n \t\t}\n-\t      tree c;\n-\t      c = cp_parser_omp_all_clauses (parser,\n+\t      properties\n+\t\t= cp_parser_omp_all_clauses (parser,\n \t\t\t\t\t     OMP_DECLARE_SIMD_CLAUSE_MASK,\n \t\t\t\t\t     \"simd\", NULL, true, true);\n-\t      properties = tree_cons (NULL_TREE, c, properties);\n \t      break;\n \t    default:\n \t      gcc_unreachable ();\n@@ -40662,7 +40665,7 @@ cp_parser_omp_context_selector_specification (cp_parser *parser,\n }\n \n /* Finalize #pragma omp declare variant after a fndecl has been parsed, and put\n-   that into \"omp declare variant\" attribute.  */\n+   that into \"omp declare variant base\" attribute.  */\n \n static tree\n cp_finish_omp_declare_variant (cp_parser *parser, cp_token *pragma_tok,\n@@ -40717,7 +40720,7 @@ cp_finish_omp_declare_variant (cp_parser *parser, cp_token *pragma_tok,\n   ctx = c_omp_check_context_selector (match_loc, ctx);\n   if (ctx != error_mark_node && variant != error_mark_node)\n     {\n-      attrs = tree_cons (get_identifier (\"omp declare variant\"),\n+      attrs = tree_cons (get_identifier (\"omp declare variant base\"),\n \t\t\t build_tree_list (variant, ctx), attrs);\n       if (processing_template_decl)\n \tATTR_IS_DEPENDENT (attrs) = 1;"}, {"sha": "14b5da645ec25063fbb240da095688252d885363", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=20de9568b49e663be848a35ce0bb08f63f14b5b2", "patch": "@@ -1,3 +1,12 @@\n+2019-10-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-c++-common/gomp/declare-variant-2.c: Adjust for error recovery\n+\timprovements.  Add new tests.\n+\t* c-c++-common/gomp/declare-variant-4.c: New test.\n+\t* c-c++-common/gomp/declare-variant-5.c: New test.\n+\t* c-c++-common/gomp/declare-variant-6.c: New test.\n+\t* c-c++-common/gomp/declare-variant-7.c: New test.\n+\n 2019-10-11  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/dfp/c11-constants-1.c, gcc.dg/dfp/c11-constants-2.c,"}, {"sha": "f058f57e68726f2178b38893a2a011563a0543a3", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-2.c", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-2.c?ref=20de9568b49e663be848a35ce0bb08f63f14b5b2", "patch": "@@ -1,3 +1,4 @@\n+void f0 (void);\n void f1 (void);\n #pragma omp declare variant\t/* { dg-error \"expected '\\\\(' before end of line\" } */\n void f2 (void);\n@@ -34,7 +35,7 @@ void f17 (void);\n #pragma omp declare variant (f1) match(user={condition})\t/* { dg-error \"expected '\\\\(' before '\\\\\\}' token\" } */\n void f18 (void);\n #pragma omp declare variant (f1) match(user={condition(})\t/* { dg-error \"expected \\[^\\n\\r]*expression before '\\\\\\}' token\" } */\n-void f19 (void);\t\t\t\t\t\t/* { dg-error \"expected '\\\\)' before '\\\\\\}' token\" \"\" { target c++ } .-1 } */\n+void f19 (void);\n #pragma omp declare variant (f1) match(user={condition()})\t/* { dg-error \"expected \\[^\\n\\r]*expression before '\\\\)' token\" } */\n void f20 (void);\n #pragma omp declare variant (f1) match(user={condition(f1)})\t/* { dg-error \"property must be constant integer expression\" \"\" { target { c || c++11 } } } */\n@@ -50,7 +51,7 @@ void f25 (void);\t\t\t\t\t\t/* { dg-error \"expected '\\\\\\}' before end of line\" \"\" { ta\n \t\t\t\t\t\t\t\t/* { dg-error \"expected '\\\\\\}' before '\\\\(' token\" \"\" { target c } .-2 } */\n #pragma omp declare variant (f1) match(construct={parallel(1)})\t/* { dg-error \"selector 'parallel' does not accept any properties\" } */\n void f26 (void);\t\t\t\t\t\t\t/* { dg-error \"expected '\\\\\\}' before '\\\\(' token\" \"\" { target c } .-1 } */\n-#pragma omp declare variant (f1) match(construct={simd(12)})\t/* { dg-error \"expected \\[^\\n\\r]* clause before\" } */\n+#pragma omp declare variant (f0) match(construct={simd(12)})\t/* { dg-error \"expected \\[^\\n\\r]* clause before\" } */\n void f27 (void);\t\t\t\t\t\t/* { dg-error \"'\\\\)' before numeric constant\" \"\" { target c++ } .-1 } */\n #pragma omp declare variant (f1) match(construct={parallel},construct={for})\t/* { dg-error \"selector set 'construct' specified more than once\" } */\n void f28 (void);\n@@ -120,3 +121,31 @@ void f58 (void);\t\t\t\t\t\t/* { dg-error \"expected '\\\\\\}' before '\\\\(' token\" \"\" { ta\n void f59 (void);\t\t\t\t\t\t/* { dg-error \"expected '\\\\\\}' before '\\\\(' token\" \"\" { target c } .-1 } */\n #pragma omp declare variant (f1) match(construct={parallel},foobar={bar})\t/* { dg-error \"expected 'construct', 'device', 'implementation' or 'user' before 'foobar'\" } */\n void f60 (void);\n+#pragma omp declare variant (f1) match(construct={parallel,parallel})\t/* { dg-error \"selector 'parallel' specified more than once in set 'construct'\" } */\n+void f61 (void);\n+#pragma omp declare variant (f1) match(construct={target,parallel,for,simd,parallel})\t/* { dg-error \"selector 'parallel' specified more than once in set 'construct'\" } */\n+void f62 (void);\n+#pragma omp declare variant (f1) match(construct={target,teams,teams})\t/* { dg-error \"selector 'teams' specified more than once in set 'construct'\" } */\n+void f63 (void);\n+#pragma omp declare variant (f1) match(construct={single})\t/* { dg-error \"selector 'single' not allowed for context selector set 'construct'\" } */\n+void f64 (void);\n+#pragma omp declare variant (f1) match(construct={taskgroup})\t/* { dg-error \"selector 'taskgroup' not allowed for context selector set 'construct'\" } */\n+void f65 (void);\n+#pragma omp declare variant (f1) match(construct={do})\t/* { dg-error \"selector 'do' not allowed for context selector set 'construct'\" } */\n+void f66 (void);\n+#pragma omp declare variant (f1) match(construct={threadprivate})\t/* { dg-error \"selector 'threadprivate' not allowed for context selector set 'construct'\" } */\n+void f67 (void);\n+#pragma omp declare variant (f1) match(construct={critical})\t/* { dg-error \"selector 'critical' not allowed for context selector set 'construct'\" } */\n+void f68 (void);\n+#pragma omp declare variant (f1) match(construct={task})\t/* { dg-error \"selector 'task' not allowed for context selector set 'construct'\" } */\n+void f69 (void);\n+#pragma omp declare variant (f1) match(construct={taskloop})\t/* { dg-error \"selector 'taskloop' not allowed for context selector set 'construct'\" } */\n+void f70 (void);\n+#pragma omp declare variant (f1) match(construct={sections})\t/* { dg-error \"selector 'sections' not allowed for context selector set 'construct'\" } */\n+void f71 (void);\n+#pragma omp declare variant (f1) match(construct={section})\t/* { dg-error \"selector 'section' not allowed for context selector set 'construct'\" } */\n+void f72 (void);\n+#pragma omp declare variant (f1) match(construct={workshare})\t/* { dg-error \"selector 'workshare' not allowed for context selector set 'construct'\" } */\n+void f73 (void);\n+#pragma omp declare variant (f1) match(construct={requires})\t/* { dg-error \"selector 'requires' not allowed for context selector set 'construct'\" } */\n+void f74 (void);"}, {"sha": "add373006add018472d5a9e4a0a43bf8656d3964", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-4.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-4.c?ref=20de9568b49e663be848a35ce0bb08f63f14b5b2", "patch": "@@ -0,0 +1,22 @@\n+double f1 (int, long, float);\n+double f2 (int, long, float);\n+double f3 (int, long, float);\n+double f4 (int, long, float);\n+double f5 (int, long, float);\n+\n+#pragma omp declare variant (f1) match (user={condition(1)})\n+#pragma omp declare variant (f2) match (user={condition(score(1):1)})\n+#pragma omp declare variant (f3) match (user={condition(score(3):1)})\n+#pragma omp declare variant (f4) match (user={condition(score(2):1)})\n+#pragma omp declare variant (f5) match (implementation={vendor(gnu)})\n+double\n+f6 (int x, long y, float z)\n+{\n+  return z + x + y;\n+}\n+\n+double\n+test (int x)\n+{\n+  return f6 (x, x, 3.5f);\n+}"}, {"sha": "6ebf09457c02b72f5558cac1090d46972d0d45a0", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-5.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-5.c?ref=20de9568b49e663be848a35ce0bb08f63f14b5b2", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-additional-options \"-mavx2\" } */\n+\n+typedef float __v4sf __attribute__((vector_size (16)));\n+typedef int __v4si __attribute__((vector_size (16)));\n+typedef float __v8sf __attribute__((vector_size (32)));\n+typedef int __v8si __attribute__((vector_size (32)));\n+__v4si f1 (__v4sf, __v4sf, float *);\n+__v8si f2 (__v8sf, __v8sf, float *);\n+__v4si f3 (__v4si, int, __v4si);\n+\n+#pragma omp declare variant (f1) match (construct={parallel,for,simd(simdlen(4),notinbranch,uniform(z),aligned(z:4 * sizeof (*z)))})\n+#pragma omp declare variant (f2) match (construct={for,simd(uniform(z),simdlen(8),notinbranch)})\n+int f4 (float x, float y, float *z);\n+\n+#pragma omp declare variant (f3) match (construct={simd(simdlen(4),inbranch,linear(y:1))})\n+int f5 (int x, int y);\n+\n+void\n+test (int *x, float *y, float *z, float *w)\n+{\n+  #pragma omp parallel\n+  #pragma omp for simd aligned (w:4 * sizeof (float))\n+  for (int i = 0; i < 1024; i++)\n+    x[i] = f4 (y[i], z[i], w);\n+  #pragma omp parallel for simd aligned (w:4 * sizeof (float)) simdlen(4)\n+  for (int i = 1024; i < 2048; i++)\n+    x[i] = f4 (y[i], z[i], w);\n+  #pragma omp simd aligned (w:4 * sizeof (float))\n+  for (int i = 2048; i < 4096; i++)\n+    x[i] = f4 (y[i], z[i], w);\n+  #pragma omp simd\n+  for (int i = 4096; i < 8192; i++)\n+    if (x[i] > 10)\n+      x[i] = f5 (x[i], i);\n+}"}, {"sha": "67c5a00bd8ae017ea36a7b3093829717547db263", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-6.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-6.c?ref=20de9568b49e663be848a35ce0bb08f63f14b5b2", "patch": "@@ -0,0 +1,35 @@\n+double f1 (int, long, float);\n+double f2 (int, long, float);\n+#pragma omp declare variant (f1) match (user={condition(0)},construct={parallel})\n+double f3 (int, long, float);\n+#pragma omp declare variant (f1) match (construct={parallel},user={condition(score(1):1)})\n+double f4 (int, long, float);\n+double f5 (int, long, float);\n+#pragma omp declare variant (f5) match (user={condition(0)})\n+double f6 (int, long, float);\n+#pragma omp declare variant (f5) match (construct={parallel},user={condition(score(1):1)})\t/* { dg-error \"'f5' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+double f7 (int, long, float);\n+double f8 (int, long, float);\n+#pragma omp declare variant (f8) match (user={condition(0)},construct={for})\n+double f9 (int, long, float);\n+#pragma omp declare variant (f8) match (user={condition(1)})\t\t\t\t\t/* { dg-error \"'f8' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+double f10 (int, long, float);\n+double f11 (int, long, float);\n+#pragma omp declare variant (f11) match (construct={target,teams,parallel,for})\n+double f12 (int, long, float);\n+#pragma omp declare variant (f11) match (user={condition(score(1):1)},construct={target,teams,parallel,for})\n+double f13 (int, long, float);\n+#pragma omp declare variant (f11) match (implementation={vendor(gnu)},construct={target,teams,parallel})\t/* { dg-error \"'f11' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+double f14 (int, long, float);\n+#pragma omp declare variant (f11) match (device={kind(any)},construct={teams,parallel})\t\t/* { dg-error \"'f11' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+double f15 (int, long, float);\n+double f16 (int, long, float);\n+#pragma omp declare variant (f16) match (construct={teams,parallel})\n+double f17 (int, long, float);\n+#pragma omp declare variant (f16) match(construct={teams,parallel,for})\t\t\t\t/* { dg-error \"'f16' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+double f18 (int, long, float);\n+double f19 (int, long, float);\n+#pragma omp declare variant (f19) match (construct={parallel})\n+double f20 (int, long, float);\n+#pragma omp declare variant (f19) match (construct={for},implementation={vendor(gnu,llvm)})\t/* { dg-error \"'f19' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+double f21 (int, long, float);"}, {"sha": "f818cd5ec7ba5376a595f65fec42a28c11830fd1", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-7.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20de9568b49e663be848a35ce0bb08f63f14b5b2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-7.c?ref=20de9568b49e663be848a35ce0bb08f63f14b5b2", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-additional-options \"-mavx2\" } */\n+\n+typedef float __v4sf __attribute__((vector_size (16)));\n+typedef int __v4si __attribute__((vector_size (16)));\n+typedef float __v8sf __attribute__((vector_size (32)));\n+typedef int __v8si __attribute__((vector_size (32)));\n+__v4si f1 (__v4sf, __v4sf, float *);\n+__v8si f2 (__v8sf, __v8sf, float *);\n+__v4si f3 (__v4si, int, __v4si);\n+\n+#pragma omp declare variant (f1) match (construct={parallel,for,simd(simdlen(4),notinbranch,uniform(z),aligned(z:4 * sizeof (*z)))})\n+int f4 (float x, float y, float *z);\n+#pragma omp declare variant (f1) match (construct={parallel,for,simd(uniform(w),simdlen(8*2-12),aligned(w:4*sizeof (float)),notinbranch)})\n+int f5 (float u, float v, float *w);\n+#pragma omp declare variant (f1) match (construct={parallel,for,simd(linear(w),notinbranch,simdlen(4),aligned(w:4*sizeof (float)))})\t/* { dg-error \"'f1' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+int f6 (float u, float v, float *w);\n+#pragma omp declare variant (f1) match (construct={parallel,for,simd(uniform(w),notinbranch,simdlen(4),aligned(w:2*sizeof (float)))})\t/* { dg-error \"'f1' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+int f7 (float u, float v, float *w);\n+#pragma omp declare variant (f1) match (construct={parallel,for,simd(uniform(w),notinbranch,simdlen(4),aligned(w))})\t\t\t/* { dg-error \"'f1' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+int f8 (float u, float v, float *w);\n+#pragma omp declare variant (f2) match (construct={for,simd(uniform(z),simdlen(8),notinbranch)})\n+int f9 (float x, float y, float *z);\n+#pragma omp declare variant (f2) match (construct={for,simd(notinbranch,simdlen(2+2+4),uniform (q))})\n+int f10 (float x, float y, float *q);\n+#pragma omp declare variant (f2) match (construct={for,simd(linear(z:2),simdlen(8),notinbranch)})\t/* { dg-error \"'f2' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+int f11 (float x, float y, float *z);\n+#pragma omp declare variant (f3) match (construct={simd(simdlen(4),inbranch,linear(y:1))})\n+int f12 (int x, int y);\n+#pragma omp declare variant (f3) match (construct={simd(inbranch,simdlen(5-1),linear(q:4-3))})\n+int f13 (int x, int q);\n+#pragma omp declare variant (f3) match (construct={simd(inbranch,simdlen(4),linear(q:2))})\t\t/* { dg-error \"'f3' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+int f14 (int x, int q);"}]}